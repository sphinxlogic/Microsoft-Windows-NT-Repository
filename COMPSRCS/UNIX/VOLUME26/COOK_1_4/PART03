Newsgroups: comp.sources.unix
From: pmiller@bmr.gov.au (Peter Miller)
Subject: v26i211: cook-1.4 - a file construction tool (like "make"), Part03/11
Sender: unix-sources-moderator@efficacy.home.vix.com
Approved: WhoAmI@efficacy.home.vix.com

Submitted-By: pmiller@bmr.gov.au (Peter Miller)
Posting-Number: Volume 26, Issue 211
Archive-Name: cook-1.4/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 11)."
# Contents:  aux/patches.sh c_incl/lang_c.c c_incl/lang_roff.c
#   common/help.c common/mem.c common/trace.h conf/dcosx cook/cook.h
#   cook/env.c cook/listing.c cook/option.h cook/stmt.h doc/glossary
#   doc/intro.aa doc/match doc/option lib/c lib/library lib/program
#   lib/yacc lib/yacc_many man1/c_incl.1 man1/cooktime.1 man1/roffpp.1
#   test/00/t0038a.sh test/00/t0041a.sh
# Wrapped by vixie@efficacy.home.vix.com on Tue May  4 01:36:37 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'aux/patches.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aux/patches.sh'\"
else
echo shar: Extracting \"'aux/patches.sh'\" \(2787 characters\)
sed "s/^X//" >'aux/patches.sh' <<'END_OF_FILE'
X#! /bin/sh
X#
X#	cook - file construction tool
X#	Copyright (C) 1993 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: shell script to generate the patch file
X#
Xcase $# in
X2)
X	project=$1
X	change=$2
X	;;
X*)
X	echo "usage: $0 <project> <change>" 1>&2
X	exit 1
X	;;
Xesac
X
Xset -e
Xtmp=/tmp/$$
Xtmp2=/tmp/$$.2
X
X#
X# These files are generated
X# so we don't have an older version in history
X#
Xweird="README BUILDING CHANGES MANIFEST Makefile"
Xecho "#! /bin/sh"
Xecho "#"
Xecho "# This is a self-applying patch in a shell script."
Xecho "# It has this form because some of the files are generated,"
Xecho "# and thus no history is available for them;"
Xecho "# they need to be deleted before the patch is applied."
Xecho "#"
Xecho "# Change directory to the appropriate place"
Xecho "# before applying running this shell script."
Xecho "#"
Xecho "# Don't forget the -p0 option if you apply this patch manually."
Xecho "#"
Xecho "# ------------------------------------------------------------"
Xecho
Xecho "#"
Xecho "# Before you apply this patch,"
Xecho "# please delete the following files:"
Xecho "#"
Xecho "rm -f $weird"
Xecho
Xecho "#"
Xecho "# Now patch the files..."
Xecho "#	(Don't forget the -p0 option.)"
Xecho "#"
Xecho "patch -p0 << 'fubar'"
X
X#
X# the patchlevel patch can be generated accurately
X#
Xecho "Index: common/patchlevel.h"
Xprev=`aegis -list version -p $project -c $change | awk -F'"' '/previous/{print $2}'`
Xecho "Prereq: \"$prev\""
Xecho "#define PATCHLEVEL \"$prev\"" > $tmp
Xset +e
Xdiff -c $tmp common/patchlevel.h | sed '1,2d'
Xset -e
X
X#
X# fake patches for the generated files
X#
Xfor f in $weird
Xdo
X	echo "Index: $f"
X	set +e
X	diff -c /dev/null $f | sed '1,2d'
X	set -e
Xdone
X
X#
X# get a list of files from aegis
X#
Xfiles=`(aegis -l pf -p $project -c $change -ter; aegis -l cf -p $project -c $change -ter) | sort`
X
X#
X# get the diff listing for each file
X#
Xfor f in $files
Xdo
X	aegis -cp $f -delta 1 -output $tmp -p $project -c $change
X	set +e
X	if diff -c $tmp $f > $tmp2 2> /dev/null
X	then
X		set -e
X	else
X		set -e
X		echo "Index: $f"
X		sed '1,2d' < $tmp2
X	fi
Xdone
Xecho "fubar"
X
X#
X# clean up and go home
X#
Xrm -f $tmp $tmp2
Xexit 0
END_OF_FILE
if test 2787 -ne `wc -c <'aux/patches.sh'`; then
    echo shar: \"'aux/patches.sh'\" unpacked with wrong size!
fi
# end of 'aux/patches.sh'
fi
if test -f 'c_incl/lang_c.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'c_incl/lang_c.c'\"
else
echo shar: Extracting \"'c_incl/lang_c.c'\" \(4272 characters\)
sed "s/^X//" >'c_incl/lang_c.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to scan C language files
X */
X
X#include <ctype.h>
X#include <string.h>
X
X#include <error.h>
X#include <mem.h>
X#include <sniff.h>
X#include <trace.h>
X#include <word.h>
X
X
X/*
X * NAME
X *	directive
X *
X * SYNOPSIS
X *	void directive(char *line, wlist *type1, wlist *type2);
X *
X * DESCRIPTION
X *	The directive function is used to scan a # control line for an
X *	include directive.  If one is found, the filename
X *	is resolved, and the path appended to the appropriate list.
X *
X * ARGUMENTS
X *	line	- the line of text from the program
X *	type1	- list of <filenames>
X *	type2	- list of "filenames"
X *
X * CAVEATS
X *	Just ignore anything we don't understand.
X */
X
Xstatic void directive _((char *s, wlist *type1, wlist *type2));
X
Xstatic void
Xdirective(s, type1, type2)
X	char		*s;
X	wlist		*type1;
X	wlist		*type2;
X{
X	int		right;
X	char		*filename;
X	string_ty	*path;
X
X	/*
X	 * see if it is a #include directive
X	 */
X	trace(("directive(s = \"%s\", type1 = %08lX, type2 = %08lX)\n{\n"/*}*/,
X		s, type1, type2));
X	assert(*s == '#');
X	s++;
X	while (isspace(*s))
X		++s;
X	if (memcmp(s, "include", 7))
X		goto done;
X	s += 7;
X	while (isspace(*s))
X		++s;
X
X	/*
X	 * figure which type
X	 */
X	switch (*s++)
X	{
X	default:
X		goto done;
X
X	case '"':
X		right = '"';
X		break;
X
X	case '<':
X		right = '>';
X		break;
X	}
X
X	/*
X	 * find the end of the filename
X	 *	(ignore anything on the end of the line)
X	 */
X	filename = s;
X	while (*s != right)
X	{
X		if (!*s)
X			goto done;
X		++s;
X	}
X
X	/*
X	 * extract the path
X	 */
X	if (s == filename)
X		goto done;
X	path = str_n_from_c(filename, s - filename);
X
X	/*
X	 * dispatch the path to the appropriate list
X	 */
X	if (right != '"')
X		wl_append_unique(type1, path);
X	else
X		wl_append_unique(type2, path);
X	str_free(path);
X
X	/*
X	 * here for all exits
X	 */
X	done:
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	lang_c_scan
X *
X * SYNOPSIS
X *	int lang_c_scan(FILE *fp, wlist *type1, wlist *type2);
X *
X * DESCRIPTION
X *	The lang_c_scan function is used to scan a file looking
X *	for nclude files.  It does not walk the children.
X *	The names of any include files encountered are appended
X *	to the appropriate list.
X *
X * ARGUMENTS
X *	fp	- file stream to scan
X *	type1	- list of <filenames>
X *	type2	- list of "filenames"
X *	
X * RETURNS
X *	int;	0 on success
X *		-1 on file errors
X */
X
Xstatic int lang_c_scan _((FILE *, wlist *, wlist *));
X
Xstatic int
Xlang_c_scan(fp, type1, type2)
X	FILE		*fp;
X	wlist		*type1;
X	wlist		*type2;
X{
X	size_t		pos;
X	size_t		max;
X	char		*line;
X	int		result;
X	int		c;
X	char		*cp;
X
X	trace(("lang_c_scan(fp = %08lX, type1 = %08lX, \
Xtype2 = %08lX)\n{\n"/*}*/, fp, type1, type2));
X	pos = 0;
X	max = 100;
X	line = mem_alloc(max);
X	result = 0;
X	for (;;)
X	{
X		if (pos >= max)
X		{
X			max += 80;
X			mem_change_size(&line, max);
X		}
X		c = getc(fp);
X		switch (c)
X		{
X		case EOF:
X			if (ferror(fp))
X			{
X				result = -1;
X				break;
X			}
X			if (!pos)
X				break;
X			/* fall through... */
X
X		case '\n':
X			line[pos] = 0;
X			pos = 0;
X
X			/*
X			 * see if it is a hash line
X			 */
X			for (cp = line; isspace(*cp); ++cp)
X				;
X			if (*cp == '#')
X				directive(cp, type1, type2);
X			continue;
X
X		default:
X			line[pos++] = c;
X			continue;
X		}
X		break;
X	}
X	mem_free(line);
X	trace(("return %d;\n", result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
Xstatic void lang_c_prepare _((void));
X
Xstatic void
Xlang_c_prepare()
X{
X	trace(("lang_c_prepare()\n{\n"/*}*/));
X	sniff_include("/usr/include");
X	trace((/*{*/"}\n"));
X}
X
X
Xsniff_ty lang_c =
X{
X	lang_c_scan,
X	lang_c_prepare,
X};
END_OF_FILE
if test 4272 -ne `wc -c <'c_incl/lang_c.c'`; then
    echo shar: \"'c_incl/lang_c.c'\" unpacked with wrong size!
fi
# end of 'c_incl/lang_c.c'
fi
if test -f 'c_incl/lang_roff.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'c_incl/lang_roff.c'\"
else
echo shar: Extracting \"'c_incl/lang_roff.c'\" \(4013 characters\)
sed "s/^X//" >'c_incl/lang_roff.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to scan *roff source files
X */
X
X#include <ctype.h>
X#include <string.h>
X
X#include <error.h>
X#include <mem.h>
X#include <sniff.h>
X#include <trace.h>
X#include <word.h>
X
X
X/*
X * NAME
X *	directive
X *
X * SYNOPSIS
X *	void directive(char *line, wlist *type1, wlist *type2);
X *
X * DESCRIPTION
X *	The directive function is used to scan a . line for an
X *	include directive.  If one is found, the filename
X *	is resolved, and the path appended to the appropriate list.
X *
X * ARGUMENTS
X *	line	- the line of text from the program
X *	type1	- list of <filenames>
X *	type2	- list of "filenames"
X *
X * CAVEATS
X *	Just ignore anything we don't understand.
X */
X
Xstatic void directive _((char *s, wlist *type1, wlist *type2));
X
Xstatic void
Xdirective(s, type1, type2)
X	char		*s;
X	wlist		*type1;
X	wlist		*type2;
X{
X	char		*filename;
X	string_ty	*path;
X
X	/*
X	 * see if it is a .so directive
X	 */
X	trace(("directive(s = \"%s\", type1 = %08lX, type2 = %08lX)\n{\n"/*}*/,
X		s, type1, type2));
X	assert(*s == '.');
X	s++;
X	while (isspace(*s))
X		++s;
X	if (memcmp(s, "so", 2))
X		goto done;
X	s += 2;
X	while (isspace(*s))
X		++s;
X	if (!*s)
X		goto done;
X
X	/*
X	 * find the end of the filename
X	 *	(ignore anything on the end of the line)
X	 */
X	filename = s;
X	while (*s && !isspace(*s))
X		++s;
X
X	/*
X	 * extract the path
X	 */
X	path = str_n_from_c(filename, s - filename);
X
X	/*
X	 * dispatch the path to the appropriate list
X	 */
X	wl_append_unique(type1, path);
X	str_free(path);
X
X	/*
X	 * here for all exits
X	 */
X	done:
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	lang_roff_scan
X *
X * SYNOPSIS
X *	int lang_roff_scan(FILE *fp, wlist *type1, wlist *type2);
X *
X * DESCRIPTION
X *	The lang_roff_scan function is used to scan a file looking
X *	for nclude files.  It does not walk the children.
X *	The names of any include files encountered are appended
X *	to the appropriate list.
X *
X * ARGUMENTS
X *	fp	- file stream to scan
X *	type1	- list of <filenames>
X *	type2	- list of "filenames"
X *	
X * RETURNS
X *	int;	0 on success
X *		-1 on file errors
X */
X
Xstatic int lang_roff_scan _((FILE *, wlist *, wlist *));
X
Xstatic int
Xlang_roff_scan(fp, type1, type2)
X	FILE		*fp;
X	wlist		*type1;
X	wlist		*type2;
X{
X	size_t		pos;
X	size_t		max;
X	char		*line;
X	int		result;
X	int		c;
X
X	trace(("lang_roff_scan(fp = %08lX, type1 = %08lX, \
Xtype2 = %08lX)\n{\n"/*}*/, fp, type1, type2));
X	pos = 0;
X	max = 100;
X	line = mem_alloc(max);
X	result = 0;
X	for (;;)
X	{
X		if (pos >= max)
X		{
X			max += 80;
X			mem_change_size(&line, max);
X		}
X		c = getc(fp);
X		switch (c)
X		{
X		case EOF:
X			if (ferror(fp))
X			{
X				result = -1;
X				break;
X			}
X			if (!pos)
X				break;
X			/* fall through... */
X
X		case '\n':
X			line[pos] = 0;
X			pos = 0;
X
X			/*
X			 * see if it is a control line
X			 */
X			if (line[0] == '.')
X				directive(line, type1, type2);
X			continue;
X
X		default:
X			line[pos++] = c;
X			continue;
X		}
X		break;
X	}
X	mem_free(line);
X	trace(("return %d;\n", result));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
Xstatic void lang_roff_prepare _((void));
X
Xstatic void
Xlang_roff_prepare()
X{
X	trace(("lang_roff_prepare()\n{\n"/*}*/));
X	if (sniff_include_count() == 0)
X		sniff_include(".");
X	trace((/*{*/"}\n"));
X}
X
X
Xsniff_ty lang_roff =
X{
X	lang_roff_scan,
X	lang_roff_prepare,
X};
END_OF_FILE
if test 4013 -ne `wc -c <'c_incl/lang_roff.c'`; then
    echo shar: \"'c_incl/lang_roff.c'\" unpacked with wrong size!
fi
# end of 'c_incl/lang_roff.c'
fi
if test -f 'common/help.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/help.c'\"
else
echo shar: Extracting \"'common/help.c'\" \(3552 characters\)
sed "s/^X//" >'common/help.c' <<'END_OF_FILE'
X/*
X *	cook - a program construction tool
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to provide consistent -Help behaviour
X */
X
X#include <ctype.h>
X#include <stdio.h>
X#include <string.h>
X#include <stdlib.h>
X
X#include <arglex.h>
X#include <error.h>
X#include <help.h>
X#include <patchlevel.h>
X
X
Xint isatty _((int));
X
X
Xstatic char *cr[] =
X{
X	"%s version %v",
X	"Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993 Peter Miller.",
X	"All rights reserved.",
X	"",
X	"The %s program comes with ABSOLUTELY NO WARRANTY;",
X	"for details use the '%s -VERSion Warranty' command.",
X	"The %s program is free software, and you are welcome to",
X	"redistribute it under certain conditions;",
X	"for details use the '%s -VERSion Redistribution' command.",
X};
X
Xstatic char *au[] =
X{
X	"Peter Miller   UUCP     uunet!munnari!bmr.gov.au!pmiller",
X	"/\\/\\*          Internet pmiller@bmr.gov.au",
X};
X
X
Xstatic void interpret _((FILE *, char **, int, char *));
X
Xstatic void
Xinterpret(fp, text, text_len, prefix)
X	FILE	*fp;
X	char	**text;
X	int	text_len;
X	char	*prefix;
X{
X	int	j;
X
X	for (j = 0; j < text_len; ++j)
X	{
X		char	indent[10];
X		char	*ip1;
X		char	*ip2;
X		char	*s;
X
X		s = text[j];
X		strcpy(indent, prefix);
X		ip2 = indent + strlen(indent);
X		ip1 = s;
X		while (isspace(*ip1))
X			*ip2++ = *ip1++;
X		*ip2 = 0;
X		if (ip1[0] == '%' && isupper(ip1[1]) && !ip1[2])
X		{
X			switch (ip1[1])
X			{
X			default:
X				assert(0);
X				break;
X
X			case 'C':
X				interpret(fp, cr, SIZEOF(cr), indent);
X				break;
X
X			case 'A':
X				interpret(fp, au, SIZEOF(au), indent);
X				break;
X			}
X			continue;
X		}
X		if (*prefix)
X			fputs(prefix, fp);
X		while (*s)
X		{
X			if (*s != '%')
X				putc(*s, fp);
X			else
X			{
X				switch (*++s)
X				{
X				default:
X					assert(0);
X					break;
X
X				case '%':
X					putc(*s, fp);
X					break;
X
X				case 's':
X					fputs(progname, fp);
X					break;
X
X				case 'v':
X					fputs(version_stamp(), fp);
X					break;
X				}
X			}
X			++s;
X		}
X		fputc('\n', fp);
X	}
X}
X
X
Xvoid
Xhelp(text, text_len, usage)
X	char	**text;
X	int	text_len;
X	void	(*usage)_((void));
X{
X	FILE	*fp;
X	char	*pager;
X
X	/*
X	 * collect the rest of thge command line,
X	 * if necessary
X	 */
X	if (usage && arglex() != arglex_token_eoln)
X	{
X		error
X		(
X			"misplaced \"%s\" command line argument",
X			arglex_value.alv_string
X		);
X		usage();
X	}
X
X	/*
X	 * if output is to the terminal,
X	 * send the output through a paginator
X	 */
X	if (isatty(0))
X	{
X		pager = getenv("PAGER");
X		if (!pager)
X			pager = "more";
X	}
X	else
X		pager = 0;
X
X	/*
X	 * open the paginator
X	 */
X	if (pager)
X	{
X		fp = popen(pager, "w");
X		if (!fp)
X		{
X			nerror("%s", pager);
X			pager = 0;
X			fp = stdout;
X		}
X	}
X	else
X		fp = stdout;
X
X	/*
X	 * do what they asked
X	 */
X	interpret(fp, text, text_len, "");
X
X	/*
X	 * close the paginator
X	 */
X	if (pager)
X		pclose(fp);
X}
X
X
Xchar *
Xversion_stamp()
X{
X	return PATCHLEVEL;
X}
END_OF_FILE
if test 3552 -ne `wc -c <'common/help.c'`; then
    echo shar: \"'common/help.c'\" unpacked with wrong size!
fi
# end of 'common/help.c'
fi
if test -f 'common/mem.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/mem.c'\"
else
echo shar: Extracting \"'common/mem.c'\" \(3870 characters\)
sed "s/^X//" >'common/mem.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate dynamic memory
X */
X
X#include <stddef.h>
X#include <string.h>
X#include <stdlib.h>
X#include <errno.h>
X
X#include <mem.h>
X#include <error.h>
X
X
X/*
X * NAME
X *	memory_error - diagnostic
X *
X * SYNOPSIS
X *	void memory_error(void);
X *
X * DESCRIPTION
X *	The memory_error function is used to report fatal problems with the
X *	memory allocator.
X *
X * RETURNS
X *	The memory_error function does not return.
X */
X
Xstatic void memory_error _((void));
X
Xstatic void
Xmemory_error()
X{
X#ifdef DEBUG
X	nerror("memory allocator");
X	abort();
X#else
X	nfatal("memory allocator");
X#endif
X}
X
X
X/*
X * NAME
X *	mem_alloc - allocate and clear memory
X *
X * SYNOPSIS
X *	char *mem_alloc(size_t n);
X *
X * DESCRIPTION
X *	Mem_alloc uses malloc to allocate the required sized chunk of memory.
X *	If any error is returned from malloc() an fatal diagnostic is issued.
X *	The memory is zeroed befor it is returned.
X *
X * CAVEAT
X *	It is the responsibility of the caller to ensure that the space is
X *	freed when finished with, by a call to free().
X */
X
Xchar *
Xmem_alloc(n)
X	size_t		n;
X{
X	char		*cp;
X
X	if (n < 1)
X		n = 1;
X	errno = 0;
X	cp = (char *)malloc(n);
X	if (!cp)
X	{
X		if (!errno)
X			errno = ENOMEM;
X		memory_error();
X	}
X	return cp;
X}
X
X
X/*
X * NAME
X *	mem_alloc_clear - allocate and clear memory
X *
X * SYNOPSIS
X *	char *mem_alloc_clear(size_t n);
X *
X * DESCRIPTION
X *	Mem_alloc_clear uses malloc to allocate the required sized chunk of memory.
X *	If any error is returned from malloc() an fatal diagnostic is issued.
X *	The memory is zeroed befor it is returned.
X *
X * CAVEAT
X *	It is the responsibility of the caller to ensure that the space is
X *	freed when finished with, by a call to free().
X */
X
Xchar *
Xmem_alloc_clear(n)
X	size_t		n;
X{
X	char		*cp;
X
X	cp = mem_alloc(n);
X	memset(cp, 0, n);
X	return cp;
X}
X
X
Xvoid
Xmem_change_size(cpp, n)
X	char		**cpp;
X	size_t		n;
X{
X	char		*cp;
X
X	cp = *cpp;
X	if (n < 1)
X		n = 1;
X	errno = 0;
X	cp = realloc(cp, n);
X	if (!cp)
X	{
X		if (!errno)
X			errno = ENOMEM;
X		memory_error();
X	}
X	*cpp = cp;
X}
X
X
X/*
X * NAME
X *	enlarge - enlarges dynamic arrays
X *
X * SYNOPSIS
X *	char *enlarge(size_t *length, char **base, size_t size);
X *
X * DESCRIPTION
X *	Enlarge is used to append more space onto the end of dynamically
X *	allocated arrays.
X *	If any error is returned from the memory allocator,
X *	a fatal diagnostic is issued.
X *
X * RETURNS
X *	A pointer to the element added.
X *
X * CAVEAT
X *	Because it uses realloc, pointers into the array may be invalid after
X *	a call to enlarge(); only use indexing.
X *
X *	The new space is not zeroed.
X *
X *	It is the responsibility of the caller to ensure that the array is
X *	freed when finished with, by a call to free().
X */
X
Xchar *
Xenlarge(length, base, size)
X	size_t		*length;
X	char		**base;
X	size_t		size;
X{
X	char		*result;
X
X	assert(!*length == !*base);
X	if (*length)
X		*base = (char*)realloc(*base, (*length + 1) * size);
X	else
X		*base = (char*)malloc(size);
X	if (!*base)
X		memory_error();
X	result = (*base + (*length)++ * size);
X	return result;
X}
X
X
Xvoid
Xmem_free(cp)
X	char		*cp;
X{
X	free(cp);
X}
END_OF_FILE
if test 3870 -ne `wc -c <'common/mem.c'`; then
    echo shar: \"'common/mem.c'\" unpacked with wrong size!
fi
# end of 'common/mem.c'
fi
if test -f 'common/trace.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/trace.h'\"
else
echo shar: Extracting \"'common/trace.h'\" \(4845 characters\)
sed "s/^X//" >'common/trace.h' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: interface definition for common/trace.c
X */
X
X#ifndef TRACE_H
X#define TRACE_H
X
X#include <stddef.h>
X
X#include <main.h>
X
X#ifdef DEBUG
X#define trace_pretest_ \
X	(							\
X		(						\
X			trace_pretest_result			\
X		?						\
X			trace_pretest_result			\
X		:						\
X			trace_pretest(__FILE__, &trace_pretest_result) \
X		)						\
X	&							\
X		1						\
X	)
X#define trace_where_ trace_where(__FILE__, __LINE__)
X#define trace(x) (void)(trace_pretest_ && (trace_where_, trace_printf x, 0))
X#define trace_if() (trace_pretest_ && (trace_where_, 1))
X#else
X#define trace(x)
X#define trace_if() 0
X#endif
X
X/*
X * This variable is static to each file which
X * includes the "trace.h" file.
X * Tracing is file-by-file, but need only test this once.
X * Files will fail to trace if a trace call is executed in them
X * prior to a call to trace_enable turning it on.
X */
X#ifdef DEBUG
Xstatic int trace_pretest_result;
X#endif
X
Xint trace_pretest _((char *file, int *result));
Xvoid trace_where _((char *file, int line));
Xvoid trace_printf _((char *, ...));
Xvoid trace_enable _((char *));
X
X
X#if defined(__STDC__) || defined(__stdc__)
X#define trace_stringize(x) #x
X#else
X#define trace_stringize(x) "x"
X#endif
X
Xvoid trace_string_real _((char *, char *));
Xvoid trace_short_unsigned_real _((char *, unsigned short *));
Xvoid trace_short_real _((char *, short *));
Xvoid trace_pointer_real _((char *, void *));
Xvoid trace_long_unsigned_real _((char *, unsigned long *));
Xvoid trace_long_real _((char *, long *));
Xvoid trace_int_unsigned_real _((char *, unsigned *));
Xvoid trace_int_real _((char *, int *));
Xvoid trace_char_unsigned_real _((char *, unsigned char *));
Xvoid trace_char_real _((char *, char *));
X
X#ifdef DEBUG
X
X#define trace_char(x)						\
X	(void)							\
X	(							\
X		trace_pretest_					\
X	&&							\
X		(						\
X			trace_where_,				\
X			trace_char_real(trace_stringize(x), &x), \
X			0					\
X		)						\
X	)
X
X#define trace_char_unsigned(x)					\
X	(void)							\
X	(							\
X		trace_pretest_					\
X	&&							\
X		(						\
X			trace_where_,				\
X			trace_char_unsigned_real(trace_stringize(x), &x), \
X			0					\
X		)						\
X	)
X
X#define trace_int(x)						\
X	(void)							\
X	(							\
X		trace_pretest_					\
X	&&							\
X		(						\
X			trace_where_,				\
X			trace_int_real(trace_stringize(x), &x),	\
X			0					\
X		)						\
X	)
X
X#define trace_int_unsigned(x)					\
X	(void)							\
X	(							\
X		trace_pretest_					\
X	&&							\
X		(						\
X			trace_where_,				\
X			trace_int_unsigned_real(trace_stringize(x), &x), \
X			0					\
X		)						\
X	)
X
X#define trace_long(x)						\
X	(void)							\
X	(							\
X		trace_pretest_					\
X	&&							\
X		(						\
X			trace_where_,				\
X			trace_long_real(trace_stringize(x), &x), \
X			0					\
X		)						\
X	)
X
X#define trace_long_unsigned(x)					\
X	(void)							\
X	(							\
X		trace_pretest_					\
X	&&							\
X		(						\
X			trace_where_,				\
X			trace_long_unsigned_real(trace_stringize(x), &x), \
X			0					\
X		)						\
X	)
X
X#define trace_pointer(x)					\
X	(void)							\
X	(							\
X		trace_pretest_					\
X	&&							\
X		(						\
X			trace_where_,				\
X			trace_pointer_real(trace_stringize(x), &x), \
X			0					\
X		)						\
X	)
X
X#define trace_short(x)						\
X	(void)							\
X	(							\
X		trace_pretest_					\
X	&&							\
X		(						\
X			trace_where_,				\
X			trace_short_real(trace_stringize(x), &x), \
X			0					\
X		)						\
X	)
X
X#define trace_short_unsigned(x)					\
X	(void)							\
X	(							\
X		trace_pretest_					\
X	&&							\
X		(						\
X			trace_where_,				\
X			trace_short_unsigned_real(trace_stringize(x), &x), \
X			0					\
X		)						\
X	)
X
X#define trace_string(x)						\
X	(void)							\
X	(							\
X		trace_pretest_					\
X	&&							\
X		(						\
X			trace_where_,				\
X			trace_string_real(trace_stringize(x), x), \
X			0					\
X		)						\
X	)
X
X#else
X
X#define trace_char(x)
X#define trace_char_unsigned(x)
X#define trace_int(x)
X#define trace_int_unsigned(x)
X#define trace_long(x)
X#define trace_long_unsigned(x)
X#define trace_pointer(x)
X#define trace_short(x)
X#define trace_short_unsigned(x)
X#define trace_string(x)
X
X#endif
X
X#endif /* TRACE_H */
END_OF_FILE
if test 4845 -ne `wc -c <'common/trace.h'`; then
    echo shar: \"'common/trace.h'\" unpacked with wrong size!
fi
# end of 'common/trace.h'
fi
if test -f 'conf/dcosx' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'conf/dcosx'\"
else
echo shar: Extracting \"'conf/dcosx'\" \(2503 characters\)
sed "s/^X//" >'conf/dcosx' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: configuration for Pyramid SMP DC/OSx 1.0-92b023
X */
X
X#ifndef CONF_H
X#define CONF_H
X
X/*
X * Define this symbol if your system does NOT
X * have the ANSI C strerror system call, and
X * does not define strerror in <string.h>.
X *
X#define CONF_NO_strerror
X */
X
X/*
X * Define this symbol if your system does NOT
X * have the POSIX tcgetpgrp system call.
X *
X#define CONF_NO_tcgetpgrp
X */
X
X/*
X * Define this symbol if your system does NOT
X * have the stdarg.h include file mandated by ANSI C.
X */
X#define CONF_NO_stdarg
X
X/*
X * Define one of these symbols to indicate which
X * universe your UNIX is derived from.
X * If you have a choice, define both.
X */
X/* #define BSD */
X#define SYSV
X
X/*
X * Define this symbol as an appropriate arguemnt to
X * the getpgrp system call for your system.
X * Ignore if your system does not have a getpgrp system call.
X */
X/* #define CONF_getpgrp_arg 0 */
X#define CONF_getpgrp_arg
X
X/*
X * On the pyramid the author used to test cook,
X * the readdir function returned a structure that
X * had the name starting in the wrong place.
X * Maybe a version later than 1.0-92b023 has fixed it.
X */
X#define CONF_pyramid_broken_readdir
X
X/*
X * On the pyramid the author used to test cook,
X * the ftime function returned a timezone that
X * had the seconds included, making it 60 times too large.
X * Maybe a version later than 1.0-92b023 has fixed it.
X */
X#define CONF_pyramid_broken_ftime
X 
X/*
X * Define this symbol to be the pathname of your shell.
X * Leave it as a Bourne shell whenever possible.
X * Some systems have different versions of the Bourne shell,
X * with and without functions; choose the one *with* functions if so.
X */
X#define CONF_SHELL "/bin/sh"
X
X#endif /* CONF_H */
END_OF_FILE
if test 2503 -ne `wc -c <'conf/dcosx'`; then
    echo shar: \"'conf/dcosx'\" unpacked with wrong size!
fi
# end of 'conf/dcosx'
fi
if test -f 'cook/cook.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/cook.h'\"
else
echo shar: Extracting \"'cook/cook.h'\" \(2226 characters\)
sed "s/^X//" >'cook/cook.h' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: interface definition for cook/cook.c
X */
X
X#ifndef COOK_H
X#define COOK_H
X
X#include <main.h>
X#include <expr.h>
X#include <stmt.h>
X
Xextern int desist;
X
X
Xtypedef struct recipe recipe;
Xstruct	recipe
X{
X	wlist		r_target;
X	elist		r_need;
X	elist		r_need2;
X	int		r_flags;
X	stmt		*r_action;
X	stmt		*r_use_action;
X	int		r_tag;		/* for tracing and debugging */
X	expr		*r_precondition;
X	int		r_multiple;
X};
X
Xtypedef struct rlist rlist;
Xstruct	rlist
X{
X	size_t		rl_nrecipes;
X	recipe		*rl_recipe;
X};
X
Xextern	rlist	explicit;
Xextern	rlist	implicit;
X
X/*
X *  Cook results.
X *  The better the result, the higher then number.
X */
X
X#define COOK_BACKTRACK  4
X#define COOK_UPTODATE	3
X#define COOK_DONE	2
X#define COOK_ERROR	1
X#define COOK_DONTKNOW	0
X#define COOK_FAIL_DK	-1
X
X/*
X *  r_flags values
X */
X#define RF_ERROK        (1<<0)
X#define RF_ERROK_OFF    (1<<1)
X#define RF_FORCE        (1<<2)
X#define RF_FORCE_OFF    (1<<3)
X#define RF_METER        (1<<4)
X#define RF_METER_OFF    (1<<5)
X#define RF_PRECIOUS     (1<<6)
X#define RF_PRECIOUS_OFF (1<<7)
X#define RF_SILENT       (1<<8)
X#define RF_SILENT_OFF   (1<<9)
X#define RF_CLEARSTAT	(1<<10)
X#define RF_CLEARSTAT_OFF (1<<11)
X
Xint cook _((wlist *));
Xvoid rl_append _((rlist *, recipe *));
Xvoid cook_flags _((int, int));
Xint recipe_tag _((void));
Xint isit_uptodate _((string_ty *));
Xint cando _((string_ty *));
Xint cook_mtime_resolve _((wlist *, wlist *));
X
X#endif /* COOK_H */
END_OF_FILE
if test 2226 -ne `wc -c <'cook/cook.h'`; then
    echo shar: \"'cook/cook.h'\" unpacked with wrong size!
fi
# end of 'cook/cook.h'
fi
if test -f 'cook/env.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/env.c'\"
else
echo shar: Extracting \"'cook/env.c'\" \(3449 characters\)
sed "s/^X//" >'cook/env.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate environment variables
X */
X
X#include <stddef.h>
X#include <stdlib.h>
X#include <string.h>
X
X#include <main.h>
X#include <env.h>
X#include <mem.h>
X#include <error.h>
X
X
Xextern	char	**environ;
Xstatic	size_t	nenvirons;
X
X
X/*
X * NAME
X *	env_initialize - start up environment
X *
X * SYNOPSIS
X *	void env_initialize(void);
X *
X * DESCRIPTION
X *	The env_initialize function is used to copy all of the environment
X *	variables into dynamic memory, so that they may be altered by the
X *	setenv and unsetenv commands.
X */
X
Xvoid
Xenv_initialize()
X{
X	int		j;
X	char	**old;
X
X	nenvirons = 0;
X	for (j = 0; environ[j]; ++j)
X		++nenvirons;
X	old = environ;
X	environ = (char **)mem_alloc((nenvirons + 1) * sizeof(char *));
X	for (j = 0; j < nenvirons; ++j)
X	{
X		char	*cp;
X		char	*was;
X
X		was = old[j];
X		cp = mem_alloc(strlen(was) + 1);
X		strcpy(cp, was);
X		environ[j] = cp;
X	}
X	environ[nenvirons] = 0;
X	env_set("SHELL", "/bin/sh");
X}
X
X
X/*
X * NAME
X *	setenv - set environment variable
X *
X * SYNOPSIS
X *	void setenv(char *name, char *value);
X *
X * DESCRIPTION
X *	The setenv function is used to set the given environment variable to
X *	the given value.
X *
X * CAVEAT
X *	Assumes that the env_initialize function has already been called.
X */
X
Xvoid
Xenv_set(name, value)
X	char		*name;
X	char		*value;
X{
X	size_t		name_len;
X	int		j;
X	char		*cp;
X
X	cp = 0;
X	name_len = strlen(name);
X	for (j = 0; j < nenvirons; ++j)
X	{
X		cp = environ[j];
X		assert(cp);
X		if
X		(
X			(cp[name_len] == '=' || !cp[name_len])
X		&&
X			!strncmp(cp, name, name_len)
X		)
X			break;
X	}
X	if (environ[j])
X	{
X		environ[j] = 0;
X		if (cp)
X			free(cp);
X	}
X	else
X	{
X		mem_change_size
X		(
X			(char **)&environ,
X			(nenvirons + 2) * sizeof(char *)
X		);
X		environ[++nenvirons] = 0;
X	}
X	cp = (char *)mem_alloc(name_len + strlen(value) + 2);
X	strcpy(cp, name);
X	cp[name_len] = '=';
X	strcpy(cp + name_len + 1, value);
X	environ[j] = cp;
X}
X
X
X/*
X * NAME
X *	unsetenv - remove environment variable
X *
X * SYNOPSIS
X *	void unsetenv(char *name);
X *
X * DESCRIPTION
X *	The unsetenv function is used to remove the named variable from the
X *	environment.
X *
X * RETURNS
X *	void
X *
X * CAVEAT
X *	Assumes that the env_initialize function has been called already.
X */
X
Xvoid
Xenv_unset(name)
X	char		*name;
X{
X	size_t		name_len;
X	int		j;
X	char		*cp;
X
X	name_len = strlen(name);
X	cp = 0;
X	for (j = 0; j < nenvirons; ++j)
X	{
X		cp = environ[j];
X		assert(cp);
X		if
X		(
X			(cp[name_len] == '=' || !cp[name_len])
X		&&
X			!strncmp(cp, name, name_len)
X		)
X			break;
X	}
X	if (!environ[j])
X		return;
X	environ[j] = 0;
X	if (cp)
X		free(cp);
X	--nenvirons;
X	for ( ; j < nenvirons; ++j)
X		environ[j] = environ[j + 1];
X}
END_OF_FILE
if test 3449 -ne `wc -c <'cook/env.c'`; then
    echo shar: \"'cook/env.c'\" unpacked with wrong size!
fi
# end of 'cook/env.c'
fi
if test -f 'cook/listing.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/listing.c'\"
else
echo shar: Extracting \"'cook/listing.c'\" \(5821 characters\)
sed "s/^X//" >'cook/listing.c' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to open and close the listing file
X */
X
X#include <stddef.h>
X#include <stdio.h>
X#include <string.h>
X#include <time.h>
X#include <signal.h>
X#include <unistd.h>
X
X#include <conf.h>
X#include <error.h>
X#include <listing.h>
X#include <os.h>
X#include <option.h>
X#include <trace.h>
X
X
Xstatic int pid;
X
X
X#ifdef SIGSTOP
X#ifdef CONF_NO_tcgetpgrp
X
X#include <sys/termio.h>
X
Xint
Xtcgetpgrp(fd)
X	int		fd;
X{
X	int		result;
X
X	if (ioctl(fd, TIOCGETPGRP, &result))
X		return -1;
X	return result;
X}
X
X#endif
X#endif
X
X
X/*
X * NAME
X *	background - test for backgroundness
X *
X * SYNOPSIS
X *	int background(void);
X *
X * DESCRIPTION
X *	The background function is used to determin e if the curent process is
X *	in the background.
X *
X * RETURNS
X *	int: zero if process is not in the background, nonzero if the process
X *	is in the background.
X *
X * CAVEAT
X *	This function has a huge chance of being wrong for your system.
X *	If you need to modify this function, please let the author know.
X */
X
Xstatic int background _((void));
X
Xstatic int
Xbackground()
X{
X	void	(*x)_((int));
X
X	/*
X	 * csh changes the progess group of jobs.
X	 * you are a background job if the terminal is not
X	 * in your process group.
X	 */
X#ifdef SIGSTOP
X	if (getpgrp(CONF_getpgrp_arg) != tcgetpgrp(0))
X		return 1;
X#endif
X
X	/*
X	 * bourne shell tells you to ignore interrupts
X	 */
X	x = signal(SIGINT, SIG_IGN);
X	if (x == SIG_IGN)
X		return 1;
X	signal(SIGINT, x);
X
X	/*
X	 * must be forground
X	 */
X	return 0;
X}
X
X
X/*
X * NAME
X *	log_close - terminate logging
X *
X * SYNOPSIS
X *	void log_close(void);
X *
X * DESCRIPTION
X *	Log_close is used to terminate logging this session,
X *	and to close any como or comi files opened.
X *
X * CAVEAT
X *	Do not call any of the fatal error functions
X *	from this function.
X */
X
Xstatic void log_close _((void));
X
Xstatic void
Xlog_close()
X{
X	if (pid)
X	{
X		fclose(stdout);
X		fclose(stderr);
X		for (;;)
X		{
X			int who;
X			int status;
X
X			who = wait(&status);
X			if (who < 0 || who == pid)
X				break;
X		}
X		pid = 0;
X	}
X}
X
X
X/*
X * NAME
X *	log_open - start logging this session
X *
X * SYNOPSIS
X *	void log_open(void);
X *
X * DESCRIPTION
X *	Log_open is used to commence logging a cook session.
X */
X
Xvoid
Xlog_open()
X{
X	string_ty	*entryname;
X	string_ty	*dirname;
X	string_ty	*fullpath;
X	time_t		clock;
X	struct tm	*tm;
X
X	trace(("log_open()\n{\n"/*}*/));
X
X	/*
X	 * If we are logging the output to a file
X	 * and we are in the background,
X	 * don't send the output to the terminal.
X	 */
X	if (option_test(OPTION_LOGGING) && background())
X		option_set(OPTION_TERMINAL, OPTION_LEVEL_COMMAND_LINE, 0);
X
X	/*
X	 * redirect the output depending on the flags
X	 */
X	if (option_test(OPTION_LOGGING))
X	{
X		if (!option.o_logfile)
X			fatal("no list file specified");
X		if (option_test(OPTION_TERMINAL))
X		{
X			int	fd[2];
X			char	*cmd[3];
X
X			/*
X			 * list both to a file and to the terminal
X			 */
X			if (pipe(fd))
X				nfatal("pipe()");
X			switch (pid = fork())
X			{
X			case 0:
X					cmd[0] = "tee";
X					cmd[1] = option.o_logfile->str_text;
X					cmd[2] = 0;
X				close(fd[1]);
X				close(0);
X				if (dup(fd[0]) != 0)
X					fatal("dup was wrong");
X				close(fd[0]);
X				signal(SIGINT, SIG_IGN);
X				signal(SIGHUP, SIG_IGN);
X				signal(SIGTERM, SIG_IGN);
X				execvp(cmd[0], cmd);
X				fatal("%s not found", cmd[0]);
X
X			case -1:
X				nfatal("fork()");
X
X			default:
X				close(fd[0]);
X				close(1);
X				if (dup(fd[1]) != 1)
X					fatal("dup was wrong");
X				close(fd[1]);
X				break;
X			}
X		}
X		else
X		{
X			/* 
X			 * list only to a file
X			 */
X			if (!freopen(option.o_logfile->str_text, "w", stdout))
X				nfatal("%s", option.o_logfile->str_text);
X		}
X		/*
X		 * make sterr go to the same place as stdout
X		 *	[will this work if stdout is already closed?]
X		 */
X		close(2);
X		switch (dup(1))
X		{
X		case 0:
X			/* oops, stdin is was closed */
X			if (dup(1) != 2)
X				nfatal("dup");
X			close(0);
X			break;
X	
X		case 2:
X			break;
X	
X		default:
X			nfatal("dup");
X		}
X		time(&clock);
X		tm = localtime(&clock);
X		fullpath = 0;
X		entryname = 0;
X		dirname = 0;
X		fullpath = os_pathname(option.o_logfile);
X		if (!fullpath)
X			goto bomb;
X		entryname = os_entryname(fullpath);
X		if (!entryname)
X			goto bomb;
X		dirname = os_dirname(fullpath);
X		if (!dirname)
X			goto bomb;
X		fprintf
X		(
X			stderr,
X			"/* %s, %s, %3.3s %3.3s%3d %02d:%02d%5d */\n",
X			entryname->str_text,
X			dirname->str_text,
X			&("SunMonTueWedThuFriSat"[tm->tm_wday*3]),
X			&("JanFebMarAprMayJunJulAugSepOctNovDec"[tm->tm_mon*3]),
X			tm->tm_mday,
X			tm->tm_hour,
X			tm->tm_min,
X			1900+tm->tm_year
X		);
X	bomb:
X		if (fullpath)
X			str_free(fullpath);
X		if (entryname)
X			str_free(entryname);
X		if (dirname)
X			str_free(dirname);
X	}
X	else
X	{
X		if (option_test(OPTION_TERMINAL))
X		{
X			/*
X			 * list only to the terminal
X			 */
X		}
X		else
X		{
X			static char dev_null[] = "/dev/null";
X
X			/*
X			 * list neither to a file nor to the terminal
X			 */
X			if
X			(
X				!freopen(dev_null, "w", stdout)
X			||
X				!freopen(dev_null, "w", stderr)
X			)
X				nfatal("%s", dev_null);
X		}
X	}
X
X	quit_handler(log_close);
X	trace((/*{*/"}\n"));
X}
END_OF_FILE
if test 5821 -ne `wc -c <'cook/listing.c'`; then
    echo shar: \"'cook/listing.c'\" unpacked with wrong size!
fi
# end of 'cook/listing.c'
fi
if test -f 'cook/option.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/option.h'\"
else
echo shar: Extracting \"'cook/option.h'\" \(2577 characters\)
sed "s/^X//" >'cook/option.h' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: interface definition for cook/option.c
X */
X
X#ifndef OPTION_H
X#define OPTION_H
X
X#include <main.h>
X
X#include <str.h>
X#include <word.h>
X
X/*
X * option levels, highest to lowest
X * (room for 16 levels in a 32 bit unsigned)
X */
Xenum option_level_ty
X{
X	OPTION_LEVEL_ERROR,
X	OPTION_LEVEL_COMMAND_LINE,
X	OPTION_LEVEL_EXECUTE,
X	OPTION_LEVEL_RECIPE,
X	OPTION_LEVEL_COOKBOOK,
X	OPTION_LEVEL_ENVIRONMENT,
X	OPTION_LEVEL_DEFAULT
X};
Xtypedef enum option_level_ty option_level_ty;
X
Xenum option_number_ty
X{
X	OPTION_PERSEVERE,	/* keep trying if have errors */
X	OPTION_SILENT,		/* do not echo any command */
X	OPTION_ERROK,		/* ignore error returns from commands */
X	OPTION_ACTION,		/* do not execute the command */
X	OPTION_TOUCH,		/* do not execute the command, just touch */
X	OPTION_FORCE,		/* always execute the commands */
X	OPTION_PRECIOUS,	/* do not delete failed targets */
X	OPTION_TERMINAL,	/* enable tty output when logging */
X	OPTION_TRACE,		/* emit tracing information */
X	OPTION_CMDFILE,		/* generate a command file */
X	OPTION_METER,		/* meter each command */
X	OPTION_LOGGING,
X	OPTION_BOOK,
X	OPTION_INVALIDATE_STAT_CACHE,
X	OPTION_max
X};
Xtypedef enum option_number_ty option_number_ty;
X
Xtypedef struct option_ty option_ty;
Xstruct option_ty
X{
X	unsigned	o_flag[OPTION_max];
X	wlist		 o_target;
X	string_ty	*o_book;
X	string_ty	*o_logfile;
X	wlist		 o_search_path;
X};
X
Xextern	option_ty	option;
Xextern	char		*progname;
X
Xint option_already _((option_number_ty, option_level_ty));
Xint option_test _((option_number_ty));
Xvoid option_set _((option_number_ty, option_level_ty, int));
Xvoid option_undo _((option_number_ty, option_level_ty));
Xvoid option_undo_level _((option_level_ty));
Xvoid option_set_errors _((void));
Xvoid option_tidy_up _((void));
X
X#endif /* OPTION_H */
END_OF_FILE
if test 2577 -ne `wc -c <'cook/option.h'`; then
    echo shar: \"'cook/option.h'\" unpacked with wrong size!
fi
# end of 'cook/option.h'
fi
if test -f 'cook/stmt.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cook/stmt.h'\"
else
echo shar: Extracting \"'cook/stmt.h'\" \(2635 characters\)
sed "s/^X//" >'cook/stmt.h' <<'END_OF_FILE'
X/*
X *	cook - file construction tool
X *	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: interface definition for cook/stmt.c
X */
X
X#ifndef STMT_H
X#define STMT_H
X
X#include <main.h>
X#include <str.h>
X#include <expr.h>
X
X/*
X * s_op values
X */
Xenum stmt_op_ty
X{
X	OP_ASSIGN = 1,
X	OP_COMMAND,
X	OP_COMPOUND,
X	OP_FAIL,
X	OP_FAIL_DK,
X	OP_IF,
X	OP_LOOP,
X	OP_LOOPSTOP,
X	OP_NOP,
X	OP_RECIPE,
X	OP_SET,
X	OP_TOUCH,
X	OP_UNSETENV
X};
Xtypedef enum stmt_op_ty stmt_op_ty;
X
Xtypedef struct assign assign;
Xstruct assign
X{
X	elist		a_name;
X	elist		a_value;
X};
X
Xtypedef struct slist slist;
Xstruct slist
X{
X	size_t		sl_nstmts;
X	struct stmt	**sl_stmt;
X};
X
Xtypedef struct srecipe srecipe;
Xstruct srecipe
X{
X	elist		sr_target;
X	elist		sr_need;
X	elist		sr_need2;
X	int		sr_flags;
X	struct stmt	*sr_action;
X	struct stmt	*sr_use_action;
X	position	sr_position;
X	expr		*sr_precondition;
X	int		sr_multiple;
X};
X
Xtypedef struct command command;
Xstruct command
X{
X	elist		c_args;
X	int		c_flags;
X	expr		*c_input;
X};
X
Xtypedef struct sif sif;
Xstruct sif
X{
X	expr		*sif_cond;
X	struct stmt	*sif_true;
X	struct stmt	*sif_false;
X};
X
Xtypedef struct stmt stmt;
Xstruct stmt
X{
X	stmt_op_ty	s_op;
X	long		s_references;
X	union
X	{
X		assign		s__assign;
X		command		s__cmd;
X		slist		s__list;
X		sif		s__if;
X		stmt		*s__loop;
X		srecipe		s__recipe;
X		expr		*s__include;
X	}
X		s__u;
X};
X#define s_assign	s__u.s__assign
X#define s_cmd		s__u.s__cmd
X#define s_if		s__u.s__if
X#define s_list		s__u.s__list
X#define s_loop		s__u.s__loop
X#define s_recipe	s__u.s__recipe
X#define s_include	s__u.s__include
X
X/*
X * return values for stmt_eval()
X */
X#define STMT_OK		0
X#define STMT_LSTOP	-1
X#define STMT_RET	-2
X#define STMT_ERROR	-3
X#define STMT_BACKTRACK -4
X
Xstmt *stmt_alloc _((void));
Xstmt *stmt_copy _((stmt *));
Xvoid stmt_free _((stmt *));
Xint stmt_eval _((stmt *));
Xvoid sl_append _((slist *, stmt *));
Xvoid sl_free _((slist *));
Xvoid sl_zero _((slist *));
X
X#endif /* STMT_H */
END_OF_FILE
if test 2635 -ne `wc -c <'cook/stmt.h'`; then
    echo shar: \"'cook/stmt.h'\" unpacked with wrong size!
fi
# end of 'cook/stmt.h'
fi
if test -f 'doc/glossary' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/glossary'\"
else
echo shar: Extracting \"'doc/glossary'\" \(4615 characters\)
sed "s/^X//" >'doc/glossary' <<'END_OF_FILE'
X.\"
X.\"	cook - file construction tool
X.\"	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: Reference Manual, Glosary
X.\"	
X.H 1 "Glossary"
XThis document employs a number of terms specific to
X.BR cook .
X.VL 1i
X.\"===============================================================
X.LI \fIbody\fR
XA set of statements, usually commands, to be performed
Xto
X.I cook
Xthe
X.IR target s
Xof a 
X.I recipe
Xafter the
X.IR ingredient s
Xexist.
X.\"===============================================================
X.LI \fIcommand\fR
XA command is a list of words to be passed to the
X.I "operating system"
Xto be executed.
X.\"===============================================================
X.LI \fIcook\fR
XWhen used as a verb,
Xrefers to the actions
X.B cook
Xwould
Xperform to create a
X.IR target ,
Xaccording to some
X.IR recipe .
X.\"===============================================================
X.LI \fIcookbook\fR
XA file containing input for
X.BR cook ,
Xusually 
X.IR recipe s.
X.\"===============================================================
X.LI "\fIexplicit recipe\fR"
XAn explicit recipe is one where the
X.IR target s
Xcontain no patterns.
XThat is, there are no percent ('\fB%\fP') characters in any of the
X.IR target s.
X.\"===============================================================
X.LI \fIflag\fR
XA flag modifies the behaviour of a cook session,
X.I recipe
Xor command.
X.\"===============================================================
X.LI "\fIforced ingredient\fR"
XA files which must exist before a
X.I target
Xfile 
Xof an 
X.I "implicit recipe"
Xmay be cooked.
XThe inability to construct a forced ingredient
Xis an error.
X.\"===============================================================
X.LI \fIfunction\fP
XA function is an action applied to a word list.
X.\"===============================================================
X.LI \fIgate\fR
XA gate is a condition which allows the conditional application of
Xa
X.IR recipe .
X.\"===============================================================
X.LI "\fIimplicit recipe\fR"
XAn implicit recipe is a recipe with patterns in the
X.IR target s.
XThat is, there is a percent ('\fB%\fP') character in at least one of the
X.IR target s.
X.\"===============================================================
X.LI \fIingredient\fR
XA files which must exist before a
X.I target
Xfile may be cooked.
XIn an 
X.I "implicit recipe"
Xthe inability to construct of an ingredient
Xmeans that the
X.I recipe
Xwill not be applied.
XIn an explicit recipe
Xthe inability to construct an ingredient is an error.
X.\"===============================================================
X.LI "\fIlast-modified time\fR"
X.br
X\s-4UNIX\s0 imbues files with several attributes.
XOne of these is a time-stamp of when the file was last modified.
XUsually this is when the file was last written to.
X.\"===============================================================
X.LI \fIrecipe\fR
XA
X.I recipe
Xconsists of several parts.
X.AL
X.LI
XA set of
X.IR target s
Xto be cooked,
X.LI
XA set of ingredients of those
X.IR target s,
Xand
X.LI
XAn optional set of forced ingredients.
X.LI
XAn optional set of flags.
X.LI
XAn optional gate.
X.LI
XAn optional body .
X.LE
X.\"===============================================================
X.LI \fItarget\fR
XThe object of a
X.IR recipe ,
Xa thing which is cooked.
X.\"===============================================================
X.LI \fItouch\fR
XUNIX imbues files with several attributes.
XOne of these is a time-stamp of when the file was last modified.
XUsually this is when the file was last written to,
Xhowever it is possible to simply adjust this attribute,
Xrather than actually writing to the file;
Xthis is colloquially known as
X.IR touch ing
Xa file.
X.\"===============================================================
X.LI \fIvariable\fR
XA variable is a named place holder for a value.
XThe value may be changed.
X.\"===============================================================
X.LE
END_OF_FILE
if test 4615 -ne `wc -c <'doc/glossary'`; then
    echo shar: \"'doc/glossary'\" unpacked with wrong size!
fi
# end of 'doc/glossary'
fi
if test -f 'doc/intro.aa' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/intro.aa'\"
else
echo shar: Extracting \"'doc/intro.aa'\" \(4207 characters\)
sed "s/^X//" >'doc/intro.aa' <<'END_OF_FILE'
X.\"
X.\"	cook - file construction tool
X.\"	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: Reference Manual, Cook from the Outside
X.\"	
X.H 1 "Cook from the Outside"
XThis chapter is part of the tutorial on how to use the
X.B cook
Xprogram.
XIt focuses on how to use
X.BR cook ,
Xwithout needing to know how 
X.B cook
Xworks internally.
X.H 2 "What can cook do for me?"
XBy far the most common use of cook,
Xby experts and beginners alike,
Xis to issue the command
X.eB
Xcook
X.eE
Xand cook will consult its cookbook to see what needs to be done.
X.P
XIn general, 
X.B cook
Xis used to take a set of files and chew on them in some way to produce
Xanother set of files;
Xsuch as the source files for a program,
Xand how to turn them into the executable program file.
XIn order for 
X.B cook
Xto do anything useful, 
Xit nees to know what to do.
X"What to do" is contained in a file called
X.IR Howto.cook
Xin the same directory as the files it is going to work on.
XYou need to execute the  \f(CWcook\fP command in 
Xthe same directory as all of the files.
X.H 2 "What is cook doing?"
XThe
X.I Howto.cook
Xfile was written by the same person who wrote the source files.
XIt contains a set of recipes;
Xeach of which, among other things,
Xcontain commands for how to manipulate the files.
XThe
X.B cook
Xprogram echos each of the commands it is about to execute,
Xso that you can watch what it is doing as it goes.
X.P
XIf the
X.I Howto.cook
Xfile contained only commands,
Xyou would be better off using a shell script.
XIn addition to the commands is information telling 
X.B cook
Xwhich files need to be constructed before other files can be,
Xand from this information
X.B cook
Xdetermines the order in which to execute the commands.
XAlso,
X.B cook
Xexamines other information to determine which commands it need not do,
Xbecause the associated files are already up-to-date.
X.H 2 "What can cook always do?"
XIf you are in a directory with a
X.I Howto.cook
Xfile,
Xyou can expect a few common requests to work
X.VL 1.5i
X.LI "cook clobber"
XThis command can be expected to remove any files from the directory which
X.B cook
Xis able to reconstruct.
X.LI "cook all"
XThis is the default action,
Xand so can be obtained by a simple \f(CWcook\fP request.
XIt causes
X.B cook
Xto construct some specific file or set of files.
X.LI "cook clean"
XThis is similar to "cook clobber" above, 
Xbut it only removes intermediate files,
Xand not not the final file or files which "cook all" constructs.
X.LE
X.P
XIn addition to the above,
Xmany 
X.I Howto.cook 
Xfiles will also define
X.VL 1.5i
X.LI "cook install"
XIf a program or library or document is constructed in the directory,
Xthe this command will install it into the correct place in the
Xsystem.
X.LI "cook uninstall"
XThe reverse of the above,
Xit removes something from the system.
X.LE
X.H 2 "If something goes wrong"
XMost errors while 
X.B cook
Xis constructing file are caused by errors in the source files,
Xand not the 
X.I Howto.cook
Xfile.
XIn general,
Xyou can fix the problems in the source files,
Xand execute the
X.B cook
Xcommand again,
Xand 
X.B cook
Xwill resume from the command which incurred the error.
X.P
XTo help you while editing the files with the errors,
X.B cook
Xkeeps a listing file of all the commands it executed,
Xand any output of those commands,
Xin a file called
X.I Howto.list
Xin the current directory.
X.P
XYou may want 
X.B cook
Xto find all the errors it can before you do any editing,
Xdo do this,
Xuse the
X.B -Continue
Xoption (it may be abbreviated to 
X.B -c
Xfor convenience).
END_OF_FILE
if test 4207 -ne `wc -c <'doc/intro.aa'`; then
    echo shar: \"'doc/intro.aa'\" unpacked with wrong size!
fi
# end of 'doc/intro.aa'
fi
if test -f 'doc/match' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/match'\"
else
echo shar: Extracting \"'doc/match'\" \(2574 characters\)
sed "s/^X//" >'doc/match' <<'END_OF_FILE'
X.\"
X.\"	cook - file construction tool
X.\"	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: Reference Manual, File name patterns
X.\"	
X.H 1 "File name patterns"
XThe tough part about designing a pattern matcher for something like cook is
Xthat the patterns must be reversible.
XThat is,
Xit must be possible to use
Xthe same string both as a pattern to be matched against and as a template
Xfor building a string once a pattern has matched.
XRather like the
Xdifference between the left and right sides of an editor search-and-replace
Xcommand in an editor using the same description for both the search pattern
Xand the replace template.
XThis is why classic regular expressions have not been used.
XThey tend to be slow to match, too.
X.P
XThis matcher has eleven match "fields",
Xreferenced as
X.B %
Xand
X.B %0
Xto
X.BR %9 .
XThe
X.B %
Xcharacter can be escaped as
X.B %% .
XThe
X.B %
Xand
X.B %1
Xto
X.B %9
Xforms match any character except
X.BR / .
XThe
X.B %0
Xform matches all characters,
Xbut must be either empty,
Xor have whole path components,
Xincluding the trailing
X.B /
Xon each component.
X.P
XA few examples will make this clearer:
X.TS
Xbox, center, tab(;);
Xl l.
Xstring;does not match
X_
X%.c;snot/fred.c
X%1/%2.c;etc/boo/fred.c
X.TE
X.TS
Xbox, center, tab(;);
Xl l lw(1.5i).
Xstring;matches;setting
X_
X%.c;fred.c;%="fred"
X%1/%2.c;snot/fred.c;T{
X%1="snot"
X.br
X%2="fred"
XT}
X%0%5.c;fred.c;T{
X%0="" 
X.br
X%5="fred"
XT}
X%0%6.c;snot/fred.c;T{
X%0="snot/" 
X.br
X%6="fred"
XT}
X%0%7.c;etc/boo/fred.c;T{
X%0="etc/boo/" 
X.br
X%7="fred"
XT}
X/usr/%1/%1%2/%3.%2%4;/usr/man/man1/fred.1x;T{
X%1="man"
X.br
X%2="1"
X.br
X%3="fred" 
X.br
X%4="x"
XT}
X.TE
X.P
XThe
X.B %0
Xbehaviour is designed to allow patterns to range over subtrees in a
Xcontrolled manner.
XNote that the use of this sort of pattern in a recipe
Xwill result in deeper searches than the naive recipe designer would expect.
END_OF_FILE
if test 2574 -ne `wc -c <'doc/match'`; then
    echo shar: \"'doc/match'\" unpacked with wrong size!
fi
# end of 'doc/match'
fi
if test -f 'doc/option' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/option'\"
else
echo shar: Extracting \"'doc/option'\" \(2455 characters\)
sed "s/^X//" >'doc/option' <<'END_OF_FILE'
X.\"
X.\"	cook - file construction tool
X.\"	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: Reference Manual, Option Precedence
X.\"	
X.H 1 "Option Precedence"
XAt various points in the description there are a number of flags and options
Xwith the same,
Xor similar,
Xnames.
XThese are in fact different levels of the same option.
X.P
XThe different levels,
Xfrom highest precedence to lowest,
Xare as follows.
X.VL 1i
X.LI "Error"
XThis level is used to disable undesirable side effects when an error occurs.
X.LI "Command Line"
XOptions specified on the command line override almost everything.
XThere are some isolated cases where there is no equivalent command line option.
XThey are in scope for the entire 
X.B cook
Xsession.
X.LI "Execute"
XWhen a command attached to a recipe is executed,
Xthe flags in the '\fBset\fP' clause are given this precedence.
XThey are in scope for the duration of the execution of the command they are
Xbound to.
X.LI "Recipe"
XWhen a recipe is considered for use,
Xthe flags in the '\fBset\fP' clause are given the precedence.
XThey are in scope for the evaluation of the ingredients names and the execution of the recipe body;
Xthey are not in scope while cooking the ingredients.
X.LI "Cookbook"
XWhen a '\fBset\fP' statement is encountered in the cookbook,
Xthe option are given this priority.
XThey are in scope until the end of the 
X.B cook
Xsession.
X.LI "Environment Variable"
X.br
XWhen the  options in the
X.B COOK
Xenvironment variable are set,
Xthey are given this precedence.
XThey are in scope for the entire
X.B cook
Xsession.
X.LI "Default"
XAll options have a default setting.
XThe defaults noted in chapter 3
Xare given this precedence.
XThey are in scope for the entire
X.B cook
Xsession.
X.LE
END_OF_FILE
if test 2455 -ne `wc -c <'doc/option'`; then
    echo shar: \"'doc/option'\" unpacked with wrong size!
fi
# end of 'doc/option'
fi
if test -f 'lib/c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib/c'\"
else
echo shar: Extracting \"'lib/c'\" \(3162 characters\)
sed "s/^X//" >'lib/c' <<'END_OF_FILE'
X/*
X * NAME
X *	c - the C compiler cookbook
X *
X * DESCRIPTION
X *	This cookbook describes how to work with C files.
X *	Include file dependencies are automatically determined.
X *
X * RECIPES
X *	%.o: %.c	make object files form C source files
X *	%.ln: %.c	make lint object files from C source files
X *	
X * VARIABLES
X *	c_incl		The C indude dependency sniffer command.
X *			Not altered if already defined.
X *	cc		The C compiler command
X *			Not altered if already defined.
X *	lint		The lint command.
X *			Not altered if already defined.
X *	cc_flags	options to pass to the C compiler command
X *			Not altered if already defined.
X *			The default is "-O".
X *	cc_include_flags Options passed to the C compiler and c_incl
X *			controlling include file searching.
X *			Not altered if already defined.
X *			The default is empty.
X *	cc_link_flags	Options passed to the C compiler when linking,
X *			these are typically library search paths and libraries.
X *			Not altered if already defined.
X *			The default is empty.
X *	cc_src		C source files in the current directory.
X *	dot_src		Source files constructable in the current directory
X *			(unioned with existing setting, if necessary).
X *	dot_obj		Object files constructable in the current directory
X *			(unioned with existing setting, if necessary).
X *	dot_clean	Files which may be removed from the current directory
X *			in a clean target.			
X *	dot_lint_obj	Lint object files constructable in the current directory
X *			(unioned with existing setting, if necessary).
X *
X * MANIFEST: cookbook for using C
X */
X
X#pragma once 
X
Xif [not [defined c_incl]] then
X    c_incl = [find_command c_incl];
Xif [not [defined cc]] then
X    cc = cc;
Xif [not [defined cc_flags]] then
X    cc_flags = -O;
Xif [not [defined cc_include_flags]] then
X    cc_include_flags = ;
Xif [not [defined cc_link_flags]] then
X    cc_link_flags = ;
Xif [not [defined lint]] then
X    lint = lint;
Xcc_src = [glob *.c];
Xif [not [defined dot_src]] then
X    dot_src = ;
Xdot_src = [stringset [dot_src] [cc_src] - [fromto %.c %.s [cc_src]]];
Xif [not [defined dot_obj]] then
X    dot_obj = ;
Xdot_obj = [stringset [dot_obj] [fromto %.c %.o [cc_src]]];
Xif [not [defined dot_clean]] then
X    dot_clean = ;
Xdot_clean =
X    [stringset
X	[dot_clean]
X	[fromto %.c %.o [cc_src]]
X	[fromto %.c %.ln [cc_src]]
X	[fromto %.c %.s [cc_src]]
X    ];
Xif [not [defined dot_lint_obj]] then
X    dot_lint_obj = ;
Xdot_lint_obj = [stringset [dot_lint_obj] [fromto %.c %.ln [cc_src]]];
X
Xif [c_incl] then
X{
X    /*
X     * if the c_incl command is available, then check dependencies
X     */
X    %.o: %.c: [collect [c_incl] [cc_include_flags] %.c]
X        {
X            [cc] [cc_include_flags] [cc_flags] -c %.c;
X        }
X    %.ln: %.c: [collect [c_incl] [cc_include_flags] %.c]
X        {
X            [lint] [cc_include_flags] [cc_flags] -c %.c;
X        }
X}
Xelse
X{
X    /*
X     * if the c_incl command is not available
X     * (hopefully only when c_incl itself is being built)
X     * the don't check dependencies
X     */
X    %.o: %.c
X        {
X            [cc] [cc_include_flags] [cc_flags] -c %.c;
X        }
X    %.ln: %.c
X        {
X            [lint] [cc_include_flags] [cc_flags] -c %.c;
X        }
X}
END_OF_FILE
if test 3162 -ne `wc -c <'lib/c'`; then
    echo shar: \"'lib/c'\" unpacked with wrong size!
fi
# end of 'lib/c'
fi
if test -f 'lib/library' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib/library'\"
else
echo shar: Extracting \"'lib/library'\" \(2534 characters\)
sed "s/^X//" >'lib/library' <<'END_OF_FILE'
X/*
X * NAME
X *	library - construct a library
X *
X * DESCRIPTION
X *	This cookbook defines how to construct a library.
X *
X *	If an include file (or files) are defined for this file,
X *	you will have to append them to [install] in your Howto.cook file.
X *
X * VARIABLES
X *	all		targets of the all recipe
X *	install		targets of the install recipe
X *	me		the name of the library to be constructed.
X *			Defaults to the last component of the pathname
X *			of the current directory.
X *	ar		The archive command.
X *	install		targets of the install command.
X *
X * RECIPES
X *	all:		construct the targets defined in [all].
X *	clean:		remove the files named in [dot_clean].
X *	clobber:	remove the files name in [dot_clean] and [all].
X *
X * If the [lib] variable is defined
X *	install:	construct the files named in [install].
X *	uninstall:	remove the files named in [install].
X *
X * MANIFEST: cookbook for constructing libraries
X */
X
X#pragma once
X
Xif [not [defined dot_obj]] then
X{
X    echo "The [dot_obj] variable is not set." set silent;
X    echo "You probably want to use the "c" cookbook" set silent;
X    echo "before you use the "library" cookbook." set silent;
X    fail;
X}
X
Xif [not [defined ar]] then
X    ar = [find_command ar];
Xif [not [defined ranlib]] then
X	ranlib = [find_command ranlib];
Xif [not [defined me]] then
X    me = [entryname [dir [pathname x]]];
X
Xall = lib[me].a;
Xif [defined dot_lint_obj] then
X    all = [all] llib-l[me].ln;
X
Xall: [all];
X
Xclean:
X    {
X	rm -f [dot_clean]
X	    set clearstat;
X    }
X
Xclobber: clean
X    {
X	rm -f [all]
X	    set clearstat;
X    }
X
Xif [defined lib] then
X{
X    if [not [defined install]] then
X        install = ;
X    install = [install] [lib]/lib[me].a;
X    if [defined dot_lint_obj] then
X	install = [install] [lib]/llib-l[me].ln;
X
X    [lib]/%: %
X        {
X            cp -p % [lib]/%;
X            chmod og-w [lib]/%;
X        }
X}
X
Xif [defined include] then
X{
X    if [not [defined install]] then
X        install = ;
X    install = [install] [include]/[me].h;
X
X    [include]/%: %
X        {
X            cp -p % [include]/%;
X            chmod og-w [include]/%;
X        }
X}
X
Xif [defined install] then
X{
X    install: [install];
X
X    uninstall:
X        {
X            rm -f [install]
X		set clearstat;
X        }
X}
X
X
Xlib[me].a: [dot_obj]
X    {
X	if [exists [target]] then
X	    rm -f [target]
X	        set clearstat;
X	[ar] r [target] [dot_obj];
X	if [ranlib] then
X		[ranlib] [target];
X    }
X
Xif [defined dot_lint_obj] then
X{
X    llib-l[me].ln: [dot_lint_obj]
X        {
X	    [lint] [dot_lint_obj] -o [me];
X        }
X}
END_OF_FILE
if test 2534 -ne `wc -c <'lib/library'`; then
    echo shar: \"'lib/library'\" unpacked with wrong size!
fi
# end of 'lib/library'
fi
if test -f 'lib/program' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib/program'\"
else
echo shar: Extracting \"'lib/program'\" \(2207 characters\)
sed "s/^X//" >'lib/program' <<'END_OF_FILE'
X/*
X * NAME
X *	program - construct a program
X *
X * DESCRIPTION
X *	This cookbook defines how to construct a program.
X *
X *	If you program uses any libraries, you will have to append
X *	them to cc_link_flags in your Howto.cook file.
X *
X * VARIABLES
X *	all		targets of the all recipe
X *	install		targets of the install recipe
X *	me		the name of the program to be constructed.
X *			Defaults to the last component of the pathname
X *			of the current directory.
X *	install		targets of the install command.
X *
X * RECIPES
X *	all:		construct the targets defined in [all].
X *	clean:		remove the files named in [dot_clean].
X *	clobber:	remove the files name in [dot_clean] and [all].
X *
X * If the [lib] variable is defined
X *	install:	construct the files named in [install].
X *	uninstall:	remove the files named in [install].
X *
X * MANIFEST: cookbook for constructing programs
X */
X
X#pragma once
X
Xif [not [defined me]] then
X    me = [entryname [dir [pathname x]]];
X
Xall = [me];
Xif [defined dot_lint_obj] then
X    all = [all] [me].lint;
Xdot_clean = [dot_clean] [me]~;
X
Xall: [all];
X
Xclean:
X    {
X	rm -f [dot_clean]
X	    set clearstat;
X    }
X
Xclobber: clean
X    {
X	rm -f [all]
X	    set clearstat;
X    }
X
Xif [defined bin] then
X{
X    install = [bin]/[me];
X
X    install: [install];
X
X    uninstall:
X        {
X            rm -f [install]
X		set clearstat;
X        }
X
X    [bin]/%: %
X        {
X            cp % [bin]/%;
X            chmod og-w [bin]/%;
X        }
X
X    [lib]/%: %
X        {
X            cp % [lib]/%;
X            chmod og-w [lib]/%;
X        }
X}
X
Xfind_libs = [find_command find_libs];
X
Xif [find_libs] then
X{
X    [me]: [dot_obj] [collect [find_libs] [cc_link_flags]]
X        {
X	    if [exists [me]~] then
X		rm -f [me]~
X		    set clearstat;
X	    if [exists [me]] then
X		mv [me] [me]~
X		    set clearstat;
X    	    [cc] [dot_obj] [cc_link_flags] -o [me];
X        }
X}
Xelse
X{
X    [me]: [dot_obj]
X        {
X	    if [exists [me]~] then
X		rm -f [me]~
X		    set clearstat;
X	    if [exists [me]] then
X		mv [me] [me]~
X		    set clearstat;
X    	    [cc] [dot_obj] [cc_link_flags] -o [me];
X        }
X}
X
Xif [defined dot_lint_obj] then
X{
X    [me].lint: [dot_lint_obj]
X        {
X	    [lint] [dot_lint_obj] [cc_link_flags];
X        }
X}
END_OF_FILE
if test 2207 -ne `wc -c <'lib/program'`; then
    echo shar: \"'lib/program'\" unpacked with wrong size!
fi
# end of 'lib/program'
fi
if test -f 'lib/yacc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib/yacc'\"
else
echo shar: Extracting \"'lib/yacc'\" \(2216 characters\)
sed "s/^X//" >'lib/yacc' <<'END_OF_FILE'
X/*
X * NAME
X *	yacc - how to use yacc
X *
X * DESCRIPTION
X *	This cookbook describes how to use yacc.
X *
X *	You will have to add "-d" to the [yacc_flags] variable
X *	if you want %.h files generated.
X *
X *	If a y.output file is constructed, it will be moved to %.list
X *
X * RECIPES
X *	%.c %.h: %.y	applied if -d in [yacc_flags]
X *	%.c: %.y	applied if -d not in [yacc_flags]
X *
X * VARIABLES
X *	yacc_src	Yacc source files in the current directory.
X *	dot_src		Source files constructable in the current directory
X *			(unioned with existing setting, if necessary).
X *	dot_obj		Object files constructable in the current directory
X *			(unioned with existing setting, if necessary).
X *	dot_clean	Files which may be removed from the current directory
X *			in a clean target.			
X *	dot_lint_obj	Lint object files constructable in the current directory
X *			(unioned with existing setting, if necessary).
X *
X * MANIFEST: cookbook for using yacc
X */
X
X#pragma once
X
X#include "c"
X
Xif [not [defined yacc]] then
X    yacc = yacc;
Xif [not [defined yacc_flags]] then
X    yacc_flags = ;
Xyacc_src = [glob *.y];
Xcc_src = [stringset [cc_src] - [fromto %.y %.c [yacc_src]]];
Xdot_src =
X    [stringset
X	    [dot_src] [yacc_src]
X	-
X	    [fromto %.y %.c [yacc_src]] [fromto %.y %.s [yacc_src]]
X    ];
Xdot_obj = [stringset [dot_obj] [fromto %.y %.o [yacc_src]]];
Xdot_clean =
X    [stringset
X	[dot_clean]
X	[fromto %.y %.o [yacc_src]]
X	[fromto %.y %.c [yacc_src]]
X	[fromto %.y %.list [yacc_src]]
X	[fromto %.y %.ln [yacc_src]]
X	[fromto %.y %.s [yacc_src]]
X	y.tab.c y.tab.h y.output
X    ];
Xdot_lint_obj = [stringset [dot_lint_obj] [fromto %.y %.ln [yacc_src]]];
X
X%.c %.h: %.y if [in -d [yacc_flags]]
X    {
X	if [exists %.list] then
X	    rm -f %.list
X		set clearstat;
X	if [exists y.output] then
X	    rm -f y.output
X		set clearstat;
X	[yacc] [yacc_flags] %.y;
X	mv y.tab.c %.c;
X	mv y.tab.h %.h;
X	if [exists y.output] then
X	    mv y.output %.list
X		set clearstat;
X    }
X
X%.c: %.y if [not [in -d [yacc_flags]]]
X    {
X	if [exists %.list] then
X	    rm -f %.list
X		set clearstat;
X	if [exists y.output] then
X	    rm -f y.output
X		set clearstat;
X	[yacc] [yacc_flags] %.y;
X	mv y.tab.c %.c;
X	if [exists y.output] then
X	    mv y.output %.list
X		set clearstat;
X    }
END_OF_FILE
if test 2216 -ne `wc -c <'lib/yacc'`; then
    echo shar: \"'lib/yacc'\" unpacked with wrong size!
fi
# end of 'lib/yacc'
fi
if test -f 'lib/yacc_many' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib/yacc_many'\"
else
echo shar: Extracting \"'lib/yacc_many'\" \(2622 characters\)
sed "s/^X//" >'lib/yacc_many' <<'END_OF_FILE'
X/*
X * NAME
X *	yacc_many - how to use yacc several times in the same directory
X *
X * DESCRIPTION
X *	This cookbook describes how to use yacc.
X *	The difference with the "yacc" cookbook is that this cookbook
X *	allows you to have more that one yacc generated parser in the same
X *	program, by using the classic sed(1) hack of the output.
X *
X *	You will have to add "-d" to the [yacc_flags] variable
X *	if you want %.h files generated.
X *
X *	If a y.output file is constructed, it will be moved to %.list
X *
X * RECIPES
X *	%.c %.h: %.y	applied if -d in [yacc_flags]
X *	%.c: %.y	applied if -d not in [yacc_flags]
X *
X * VARIABLES
X *	yacc_src	Yacc source files in the current directory.
X *	dot_src		Source files constructable in the current directory
X *			(unioned with existing setting, if necessary).
X *	dot_obj		Object files constructable in the current directory
X *			(unioned with existing setting, if necessary).
X *	dot_clean	Files which may be removed from the current directory
X *			in a clean target.			
X *	dot_lint_obj	Lint object files constructable in the current directory
X *			(unioned with existing setting, if necessary).
X *
X * MANIFEST: cookbook for using yacc more than once in same program
X */
X
X#pragma once
X
X#include "c"
X
Xif [not [defined yacc]] then
X    yacc = yacc;
Xif [not [defined yacc_flags]] then
X    yacc_flags = ;
Xyacc_src = [glob *.y];
Xcc_src = [stringset [cc_src] - [fromto %.y %.c [yacc_src]]];
Xdot_src =
X    [stringset
X	    [dot_src] [yacc_src]
X	-
X	    [fromto %.y %.c [yacc_src]] [fromto %.y %.s [yacc_src]]
X    ];
Xdot_obj = [stringset [dot_obj] [fromto %.y %.o [yacc_src]]];
Xdot_clean =
X    [stringset
X	[dot_clean]
X	[fromto %.y %.o [yacc_src]]
X	[fromto %.y %.c [yacc_src]]
X	[fromto %.y %.list [yacc_src]]
X	[fromto %.y %.ln [yacc_src]]
X	[fromto %.y %.s [yacc_src]]
X	y.tab.c y.tab.h y.output
X    ];
Xdot_lint_obj = [stringset [dot_lint_obj] [fromto %.y %.ln [yacc_src]]];
X
X
X%.c %.h: %.y if [in -d [yacc_flags]]
X    {
X	if [exists %.list] then
X	    rm -f %.list
X		set clearstat;
X	if [exists y.output] then
X	    rm -f y.output
X		set clearstat;
X	[yacc] [yacc_flags] %.y;
X	sed -e \'s/\[yY\]\[yY\]/%_/g\' y.tab.c > %.c;
X	rm -f y.tab.c;
X	sed -e \'s/\[yY\]\[yY\]/%_/g\' y.tab.h > %.h;
X	rm -f y.tab.h;
X	if [exists y.output] then
X	    mv y.output %.list
X		set clearstat;
X    }
X
X%.c: %.y if [not [in -d [yacc_flags]]]
X    {
X	if [exists %.list] then
X	    rm -f %.list
X		set clearstat;
X	if [exists y.output] then
X	    rm -f y.output
X		set clearstat;
X	[yacc] [yacc_flags] %.y;
X	sed -e \'s/\[yY\]\[yY\]/%_/g\' y.tab.c > %.c;
X	rm -f y.tab.c;
X	if [exists y.output] then
X	    mv y.output %.list
X		set clearstat;
X    }
END_OF_FILE
if test 2622 -ne `wc -c <'lib/yacc_many'`; then
    echo shar: \"'lib/yacc_many'\" unpacked with wrong size!
fi
# end of 'lib/yacc_many'
fi
if test -f 'man1/c_incl.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man1/c_incl.1'\"
else
echo shar: Extracting \"'man1/c_incl.1'\" \(4489 characters\)
sed "s/^X//" >'man1/c_incl.1' <<'END_OF_FILE'
X'\" t
X.\"	cook - file construction tool
X.\"	Copyright (C) 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: manual entry for c_incl
X.\" 
X.TH C_INCL 1
X.ds n) c_incl
X.if n .ad l
X.if n .hy 0
X.if n .nr IN 8n
X.SH NAME
X\*(n) - determine dependencies
X.SH SYNOPSIS
X.B \*(n)
X[
X.IR option ...
X]
X.I filename
X.br
X.B \*(n)
X.B -Help
X.br
X.B \*(n)
X.B -VERSion
X.SH DESCRIPTION
XThe
X.I \*(n)
Xprogram
Xis used to traverse source files looking for include dependencies
Xsuitable for \f(CW[collect]\fPion by cook.
X.PP
XSeveral input languages are supported,
Xsee the options list for details.
X.br
X.ne 1i
X.SH OPTIONS
XThe following options are understood.
X.TP 8n
X.B -C
X.br
XThe source file is a C source file.
XIt is assumed that it will have the dependencies resolved
Xby the
X.IR cpp (1)
Xcommand.
XThe same include semantics as the
X.IR cpp (1)
Xcommand will be employed.
XThis is the default.
X.TP 8n
X.B -Roff
X.br
XThe source file is a *roff source file.
XIt is assumed that it will have the dependencies resolved
Xby the
X.IR roffpp (1)
Xcommand.
XThe same include semantics as the
X.IR roffpp (1)
Xcommand will be employed.
X.TP 8n
X.B -Verbose
X.br
XTell what is happening.
X.TP 8n
X.BI -I path
X.br
XSpecify include path, a la
X.IR cc (1).
X.TP 8n
X.B -Absent_Local_Ignore
X.br
XFor files included using a
X.I "#include ''filename.h''"
Xdirective,
Xignore the file if it cannot be found.
X.TP 8n
X.B -Absent_Local_Mention
X.br
XFor files included using a
X.I "#include ''filename.h''"
Xdirective,
Xprint the file name even if the file cannot be found.
XThis is the default (it probably needs to be built).
X.TP 8n
X.B -Absent_Local_Error
X.br
XFor files included using a
X.I "#include ''filename.h''"
Xdirective,
Xprint a fatal error if the file cannot be found.
X.TP 8n
X.B -Absent_System_Ignore
X.br
XFor files included with a
X.I "#include <filename.h>"
Xdirective,
Xignore the file if it cannot be found.
XThis is the default (it was probably ifdef'ed out).
X.TP 8n
X.B -Absent_System_Mention
X.br
XFor files included with a
X.I "#include <filename.h>"
Xdirective,
Xprint the file name even if the file cannot be found.
X.TP 8n
X.B -Absent_System_Error
X.br
XFor files included with a
X.I "#include <filename.h>"
Xdirective,
Xprint a fatal error if the file cannot be found.
X.TP 8n
X.B -Absent_Program_Ignore
X.br
XIf the file named on the command line cannot be found,
Xbehave as if the file were found, but was empty.
X.TP 8n
X.B -Absent_Program_Error
X.br
XIf the file named on the command line cannot be found,
Xprint a fatal error message.
XThis is the default.
X.TP 8n
X.B -Help
X.br
XGive information on how to use
X.IR \*(n) .
X.TP 8n
X.B -VERSion
X.br
XTell what version of
X.I \*(n)
Xis being run.
X.TP 8n
X.B -No_System
X.br
XDo not search the 
X.I /usr/include
Xdirectory.
XBy default this is searched last.
X.TP 8n
X.B -No_Cache
X.br
XThis option may be used to turn caching off.
X.PP
XAny other options will generate an error.
X.so o__rules.so
X.br
X.ne 1i
X.SH CACHING
XThe caching mechanism use by the
X.I \*(n)
Xprogram caches the results of searching files
Xfor include files (in a file called
X.I .\*(n)rc
Xin the current directory).
XThe cache is only refreshed when a file changes.
X.PP
XThe use of this cache has been shown to dramatically increase the
Xperformance of the
X.I \*(n)
Xprogram.
XTypically,
Xonly a small proportions files in a project change between builds,
Xresulting in a very high cache hit rate.
X.PP
XWhen using caching,
Xalways use the same command line options,
Xotherwise weird and wonderful things will happen.
X.PP
XThe
X.I .\*(n)rc
Xfile is a binary file.
XIf you wish to rebuild the cache,
Xsimply delete this file with the
X.IR rm (1)
Xcommand.
XBeing a binary file,
Xthe
X.I .\*(n)rc
Xfile is not portable across machines or operating systems,
Xso you will need to delete it when you move your sources.
XIt is a binary file for performance.
X.so copyright.so
END_OF_FILE
if test 4489 -ne `wc -c <'man1/c_incl.1'`; then
    echo shar: \"'man1/c_incl.1'\" unpacked with wrong size!
fi
# end of 'man1/c_incl.1'
fi
if test -f 'man1/cooktime.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man1/cooktime.1'\"
else
echo shar: Extracting \"'man1/cooktime.1'\" \(2200 characters\)
sed "s/^X//" >'man1/cooktime.1' <<'END_OF_FILE'
X'\" t
X.\"	cook - file construction tool
X.\"	Copyright (C) 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: manual entry for the cooktime command
X.\" 
X.TH COOKTIME 1
X.ds n) cooktime
X.if n .hy 0
X.if n .ad l
X.if n .nr IN 8n
X.SH NAME
X\*(n) \- set file times
X.SH SYNOPSIS
X.B \*(n)
X[
X.IR option \&...
X]
X.IR filename \&...
X.br
X.B \*(n)
X.B -Help
X.br
X.B \*(n)
X.B -VERSion
X.SH DESCRIPTION
XThe
X.I \*(n)
Xprogram is used to
Xset the modified time or access time of a file.
XThis can be used to defend against unwanted
Xlogical dependencies when making "minor" changes to files.
X.PP
XIf no option is specified,
Xthe default action is as if "\fI\-Modify now\fP" was specified.
X.br
X.ne 1i
X.SH OPTIONS
XThe following options are understood.
X.TP 8n
X\fB-Access\fP \fIdate\fP
X.br
XThis option may be used to 
Xset the last-access time of the files.
XThe date is relatively free-format;
Xrember to use quotes to insulate spaces from the shell.
X.TP 8n
X\fB-Modify\fP \fIdate\fP
X.br
XThis option may be used to 
Xset the last-modify time of the files.
XThe date is relatively free-format;
Xrember to use quotes to insulate spaces from the shell.
X.TP 8n 
X.B -Report
X.br
XWhen use alone,
Xproduces a listing of access times and modify times for the named files.
XWhen used with -Access or -Modify,
Xproduces a listing of the changes made.
X.TP 8n
X.B -Help
X.br
XGive some information on how to use the
X.I \*(n)
Xcommand.
X.PP
XAny other option will generate a disgnostic error.
X.so o__rules.so
X.so copyright.so
END_OF_FILE
if test 2200 -ne `wc -c <'man1/cooktime.1'`; then
    echo shar: \"'man1/cooktime.1'\" unpacked with wrong size!
fi
# end of 'man1/cooktime.1'
fi
if test -f 'man1/roffpp.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man1/roffpp.1'\"
else
echo shar: Extracting \"'man1/roffpp.1'\" \(3509 characters\)
sed "s/^X//" >'man1/roffpp.1' <<'END_OF_FILE'
X'\" t
X.\"	cook - file construction tool
X.\"	Copyright (C) 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: manual entry for the roffpp command
X.\" 
X.TH ROFFPP 1
X.ds n) roffpp
X.if n .ad l
X.if n .hy 0
X.if n .nr IN 8n
X.SH NAME
X\*(n) \- replace \&.so requests within *roff sources
X.SH SYNOPSIS
X.B \*(n)
X[
X.IR option ...
X][
X.I infile
X[
X.I outfile
X]]
X.br
X.B \*(n)
X.B -Help
X.br
X.B \*(n)
X.B -VERSion
X.SH DESCRIPTION
XThe
X.I \*(n)
Xcommand may be used to
Xcopies the input file to the output file,
Xincluding files named using
X.I \&.so
Xdirectives along the way,
Xand removing the
X.I \&.so
Xdirectives.
X.PP
XThis is useful when processing large multi-file documents
Xwith filters such as
X.IR tbl (1)
Xor
X.IR eqn (1)
Xwhich do not understand the
X.I .so
Xdirective.
XThe
X.I \&.nx
Xdirective is not understood.
XThe
X.I \*(n)
Xprogram is not a general *roff interpreter,
Xso many constructs will be beyond it,
Xfortunately, most of them have nothing to do with include files.
XInclude files which cannot be found,
Xprobably from uninterpreted *roff constructs,
Xif the files really does exist,
Xwill simply be passed through unchanged,
Xfor *roff to interpret at a later time.
X.PP
XThe
X.I \*(n)
Xprogram also allows the user to specify an include search path.
XThis allows, for example, common files to be kept in a central location.
X.PP
XOnly directives of the form
X.RS
X.B \&.so
X.I filename
X.RE
Xare processed.
XIf the directive is introduced using the single quote form,
Xor the dot is not the first character of the line,
Xthe directive will be ignored.
X.PP
XAny extra arguments on the line are ignored,
Xand quoting is not understood.
XAll characters are interpreted literally.
X.PP
XExamples of directives which will be ignored include
X.RS
X\&'so /usr/lib/tmac/tmac.an
X.br
X\&.if n .so yuck
X.RE
XThis list is not exhaustive.
X.PP
XThe special file name
X.RB ` \- '
Xon the command line
Xmeans the standard input or standard output,
Xas appropriate.
XFiles which are omitted are also assumed to be
Xthe standard input or standard output,
Xas appropriate.
X.PP
XThe output attempts to keep file names and line numbers in sync
Xby using the
X.B \&.lf
Xdirective.
XThe
X.B \&.lf
Xdirective is also understood as input.
XThis is compatible with
X.IR groff (1)
Xand the other GNU text utilities included in the groff package.
X.br
X.ne 1i
X.SH OPTIONS
XThe following options are understood.
X.TP 8n
X.BI -I path
X.br
XSpecify include path, a la
X.IR cc (1).
XInclude paths are searched in the order specified.
XThe include search path defaults to the current directory
Xif and only if the user does not specify any include search paths.
X.TP 8n
X.B -Help
X.br
XGive information on how to use
X.IR \*(n) .
X.TP 8n
X.B -VERSion
X.br
XTell what version of
X.I \*(n)
Xis being run.
X.PP
XAny other option will generate a diagnostic error.
X.so o__rules.so
X.so copyright.so
END_OF_FILE
if test 3509 -ne `wc -c <'man1/roffpp.1'`; then
    echo shar: \"'man1/roffpp.1'\" unpacked with wrong size!
fi
# end of 'man1/roffpp.1'
fi
if test -f 'test/00/t0038a.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test/00/t0038a.sh'\"
else
echo shar: Extracting \"'test/00/t0038a.sh'\" \(2829 characters\)
sed "s/^X//" >'test/00/t0038a.sh' <<'END_OF_FILE'
X#! /bin/sh
X#
X#	cook - file construction tool
X#	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: test roffpp functionality
X#
Xtmp=/tmp/$$
Xhere=`pwd`
Xif test $? -ne 0 ; then exit 1; fi
X
Xfail()
X{
X	echo 'FAILED test of roffpp command' 1>&2
X	cd $here
X	rm -rf $tmp
X	exit 1
X}
Xpass()
X{
X	cd $here
X	rm -rf $tmp
X	exit 0
X}
Xtrap "fail" 1 2 3 15
X
Xmkdir $tmp
Xmkdir $tmp/bloggs
Xcd $tmp
X
X#
X# test the plain-vanilla form
X#
Xcat > test.in << 'foobar'
Xtesting
X.so test2.in
Xline three
Xfoobar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test2.in << 'foobar'
Xone
Xtwo
Xthree
Xfoobar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.ok << 'foobar'
X.lf 1 test.in
Xtesting
X.lf 1 test2.in
Xone
Xtwo
Xthree
X.lf 3 test.in
Xline three
Xfoobar
Xif test $? -ne 0 ; then fail; fi
X
X$here/bin/roffpp test.in test.out
Xif test $? -ne 0 ; then fail; fi
X
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X
X#
X# test the .lf directive
X#
Xcat > test.in << 'foobar'
Xtesting
X.lf 47 granny-smith
XGranny Smith
X.so test2.in
Xline three
Xfoobar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test2.in << 'foobar'
Xone
Xtwo
Xthree
Xfoobar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.ok << 'foobar'
X.lf 1 test.in
Xtesting
X.lf 47 granny-smith
XGranny Smith
X.lf 1 test2.in
Xone
Xtwo
Xthree
X.lf 49 granny-smith
Xline three
Xfoobar
Xif test $? -ne 0 ; then fail; fi
X
X$here/bin/roffpp test.in test.out
Xif test $? -ne 0 ; then fail; fi
X
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X
X#
X# test the explicit include path form
X#
Xcat > test.in << 'foobar'
Xtesting
X.so test2.in
X.so ../test2.in
Xline four
Xfoobar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > bloggs/test2.in << 'foobar'
XBodgie Rent-a-Wreck
X-- free --
Xwith every 200 lb rotweiler sold
Xfoobar
Xif test $? -ne 0 ; then fail; fi
X
Xcat > test.ok << 'foobar'
X.lf 1 test.in
Xtesting
X.lf 1 bloggs/test2.in
XBodgie Rent-a-Wreck
X-- free --
Xwith every 200 lb rotweiler sold
X.lf 3 test.in
X.lf 1 bloggs/../test2.in
Xone
Xtwo
Xthree
X.lf 4 test.in
Xline four
Xfoobar
Xif test $? -ne 0 ; then fail; fi
X
X$here/bin/roffpp -Ibloggs -I. test.in test.out
Xif test $? -ne 0 ; then fail; fi
X
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X
X# probably OK
Xpass
END_OF_FILE
if test 2829 -ne `wc -c <'test/00/t0038a.sh'`; then
    echo shar: \"'test/00/t0038a.sh'\" unpacked with wrong size!
fi
# end of 'test/00/t0038a.sh'
fi
if test -f 'test/00/t0041a.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test/00/t0041a.sh'\"
else
echo shar: Extracting \"'test/00/t0041a.sh'\" \(2246 characters\)
sed "s/^X//" >'test/00/t0041a.sh' <<'END_OF_FILE'
X#! /bin/sh
X#
X#	cook - file construction tool
X#	Copyright (C) 1993 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: Test the "resolve" builtin function
X#
X
Xwork=/tmp/$$
XPAGER=cat
Xexport PAGER
X
Xhere=`pwd`
Xif test $? -ne 0 ; then exit 1; fi
X
Xfail()
X{
X	set +x
X	echo 'FAILED test of the builtin function "resolve"' 1>&2
X	cd $here
X	find $work -type d -user $USER -exec chmod u+w {} \;
X	rm -rf $work
X	exit 1
X}
Xpass()
X{
X	set +x
X	echo PASSED 1>&2
X	cd $here
X	find $work -type d -user $USER -exec chmod u+w {} \;
X	rm -rf $work
X	exit 0
X}
Xtrap "fail" 1 2 3 15
X
Xmkdir $work
Xif test $? -ne 0 ; then exit 1; fi
Xcd $work
Xif test $? -ne 0 ; then fail; fi
X
X#
X# test cookbook
X#
Xcat > book << 'fubar'
Xsearch_list  = . bl;
X%.o: %.c
X{
X	cc -O -c [resolve %.c];
X}
X
Xtest: a.o b.o
X{
X	cc -o test [resolve a.o b.o];
X}
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
X#
X# the first source file
X#
Xcat > a.c << 'fubar'
Xmain()
X{
X	b();
X	exit(0);
X}
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
X#
X# the second source file
X#
Xmkdir bl
Xif test $? -ne 0 ; then fail; fi
Xcat > bl/b.c << 'fubar'
Xb()
X{
X	printf("Hello, World!\n");
X}
Xfubar
Xif test $? -ne 0 ; then fail; fi
X
X#
X# try it out
X#
Xsleep 1
X$here/bin/cook -book book -nl
Xif test $? -ne 0 ; then fail; fi
X
X#
X# make sure works for object in search list, too
X#
Xmv b.o bl/b.o
Xif test $? -ne 0 ; then fail; fi
Xrm test
Xif test $? -ne 0 ; then fail; fi
Xsleep 1
X$here/bin/cook -book book -nl
Xif test $? -ne 0 ; then fail; fi
X
X#
X# Only definite negatives are possible.
X# The functionality exercised by this test appears to work,
X# no other guarantees are made.
X#
Xpass
END_OF_FILE
if test 2246 -ne `wc -c <'test/00/t0041a.sh'`; then
    echo shar: \"'test/00/t0041a.sh'\" unpacked with wrong size!
fi
# end of 'test/00/t0041a.sh'
fi
echo shar: End of archive 3 \(of 11\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
