Newsgroups: comp.sources.unix
From: lbroda@s.psych.uiuc.edu (Larry Broda)
Subject: v26i242: ee-1.23 - simple text editor for novice users, Part01/01
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: lbroda@s.psych.uiuc.edu (Larry Broda)
Posting-Number: Volume 26, Issue 242
Archive-Name: ee-1.23/part01

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 1)."
# Contents:  HELP-MANUAL HELP-WINDOW HELP-WINDOW-ADVANCED MANIFEST
#   Makefile.templ README easy-edit.man easyedit.el ee.license
#   ee.sh.template
# Wrapped by vixie@gw.home.vix.com on Sun Jun 20 12:03:47 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'HELP-MANUAL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HELP-MANUAL'\"
else
echo shar: Extracting \"'HELP-MANUAL'\" \(19631 characters\)
sed "s/^X//" >'HELP-MANUAL' <<'END_OF_FILE'
XEasy-edit v1.22	by Larry Broda  Dept. of Psychology, Univ. of Illinois
X
XScrolling this window                               
X=====================
X	The HELP window may be scrolled using the following commands:
X	ESC f -  forward one page
X	ESC F -  forward one line
X	ESC > -  forward to next topic (in this Manual only)
X	ESC b -  backward one page
X	ESC B -  backward one line
X	ESC < -  backward to previous topic (in this Manual only)
X
XIntroduction                        (ESC > next topic    ESC < previous topic)
X============     
X
X	Easy-edit (or "ee") is  a simple text  editor  designed to  be 
Xto be usable without any previous instruction.   Easy-edit splits your
Xscreen into  two "windows",  one in which you edit   your file and the
Xother in which a list of editing commands is displayed.
X	Type  in  text as with a word processor; line wraps will occur
Xautomatically if  you  do not type carriage returns.  Editing commands
Xare of two types:
X
X	1. Control commands (notated "^<key>"; e.g. ^A): Press the
X	   control key and the letter key together.
X
X	2. Escape commands (notated "ESC <key>"; e.g. ESC A): Press
X           and release "escape" key, then press the other key.
X
X	In most  cases the case of the letter following "ESC" does not
Xmatter  (that  is, an "ESC S" is  the same as "ESC  s");  but in a few
Xcases  (such as HELP window scrolling)  there is  a difference between
Xthe upper and lower case version.
X
XExiting/Saving work                (ESC > next topic    ESC < previous topic)
X===================
XESC S   -  Save and Exit
X
X	To exit easy-edit and save your work, press ESC, the S.  This
Xwill write your changes to the file and exit the editor.
X
XESC W   -  Save without exiting
X
X	ESC W save your changes as in ESC S, but does not exit the editor.
XThis is useful for periodically saving your changes if you are worried
Xabout a system crash or phone-line disconnection. 
X
XESC Q   -  Abort
X	To  quit  from  easy-edit without  saving the changes you have
Xmade,  type ESC,  then Q.   You will be asked  if  you  really want to
Xcancel your changes;  answer "yes" to proceed with  the abort, or "no"
Xto continue editing.  If you are creating a new file and abort with an
XESC Q, the file will not be created.
X
XESC T  -  Save to a different file and Exit
X
X	ESC T allows you to save your editing to a different file from
Xthe one you originally began editing.  The  original file will be left
Xunchanged.   You will  be asked for the new  filename and if it  is an
Xexisting file, you will be warned and asked whether you really want to
Xreplace the  current file.  ESC T will  fail if you try  to write to a
Xfile  that you  do  not have read  access to  or create   a  file in a
Xdirectory that you do not have write access to.
X
X
XMoving the cursor                   (ESC > next topic    ESC < previous topic)
X================
X^P / up arrow 
X^N / down arrow
X^F / right arrow
X^B / left arrow
X
X	When  you type  text,  it  will  be  inserted  at  the cursor
Xposition; likewise,  the  effect of editing commands is determined by
Xthe cursor position.
X	On most  terminals or PCs, the arrow keys may be  used to move
Xthe cursor  around  within  the file one character  or line at a time.
XAlternatively, the control keys listed above may be used.  To move the
Xcursor  by more than  one character or line  at  a time, the following
Xcommands may be used:
X
X   ^G - move forward (right) one word    
X   ^B - move backwards (left) one word
X   ^D - move forward one screenfull       
X   ^U - move backwards one screenfull
X   ^A - move to the beginning of the line
X   ^E - move to the end of the line
XESC A - move to the beginning of the file.
XESC E - move to the end of the file
XESC G - move to a particular line number (it will ask you for the
X        number).
X
XOverwrite/Insert                   (ESC > next topic    ESC < previous topic)
X===============
XESC N   -   Overwrite/Insert mode toggle
X
X	When you  initially  enter easy-edit, you  are in insert mode,
Xand text you type in is inserted into the file at the cursor location.
XThe text to  the right of  the cursor is pushed over  to make room for
Xthe new text.  The ESC N command switches  you into overwrite mode, so
Xthat text you  type in is written *over*  the current text,  replacing
Xit.  ESC N is a toggle switch; whichever typing mode you are in, ESC N
Xwill switch to the other mode.
X
XUndo                              (ESC > next topic    ESC < previous topic)
X====
XESC U  -  Undo
X
X	The ESC U (undo)  command lets you correct editing mistakes or 
Xby reversing the editing action.  The ESC U can command  repeatedly to
Xundo  earlier   changes;  each time  the  preceding  command  will  be
X"undone".  There is a limit  to the number  of  commands  that can  be
Xreversed; this is dependent upon  the types of  commands they were, as
Xit takes varying amounts of  space to  store different commands in the
Xeditor's memory.
X
X
XHELP Window                       (ESC > next topic    ESC < previous topic)
X===========
XESC F   -   Scroll HELP window forward one screenfull
XESC f   -   Scroll HELP window forward one line
XESC B   -   Scroll HELP window backward one screenfull
XESC b   -   Scroll HELP window backward one line
X
X	The HELP Window lists the editing commands that  are available
Xto you.  Since there are more commands than can be  listed  at once in
Xthe window, the ESC F  and  ESC B commands  may be used to  scroll the
XHELP window  forward and backward, respectively.   Note that these are
Xamong the only commands in which the case of the letter matters.
X
XESC V   -   Switch between regular HELP/ short HELP
X
X	When  you  are more familiar  with easy-edit,  you may want to
Xswitch the more  concise "advanced" HELP  window,  which in some cases
Xwill  fit entirely  on one page.   You may switch between the standard
XHELP window and  the advanced version  with the ESC  V command.  Also,
Xyou may display the advanced HELP window on initial entry by following
Xthe "ee" command with the "-e" option; e.g. ee -e filename.
X
XESC Z   -   Remove HELP window
XESC H   -   Restore HELP window
XESC J   -   Shrink HELP window (Enlarge EDIT window)
X
X	If you  feel you do not need the HELP listing at all and would
Xlike to have the entire screen space available for displaying the file
Xyou are editing, use the ESC Z command to "zap" the HELP window.   The
Xcommand ESC H will bring the HELP window back.  If  you merely want to
Xshrink the size of the HELP window  to gain  additional  space for the
Xediting window, use the ESC J command.  Each time you  type ESC J, the
Xedit window will grow be one line, at the expense of  the HELP window.
XESC H may be used at any time to return the windows  to their original
Xsizes.
X	You may also start ee with the HELP window turned off by giving
Xit a -z option (e.g. ee -z filename).
X
XDeleting text                       (ESC > next topic    ESC < previous topic)
X=============
XBackspace / ^H   -  backspace over text
X
X	A backspace  will move  the cursor backwards one character and
Xdelete that character in the  usual fashion.   On some terminals (esp.
XPCs), the backspace key may be redefined to be something else.  If the
Xbackspace key does not work, you may use ^H instead;  the DEL key will
Xalso work as a backspace on many keyboards.
X
X^X - delete character
X^W - delete word
X
X	A character  may be deleted  by moving  the cursor over it and
Xtyping ^X.  An entire word may be deleted by placing the cursor at the
Xbeginning of the  word and  typing ^W.   If the cursor  is  not at the
Xbeginning of the word, only  the  portion of the  word from the cursor
Xposition to the end will be erased.
X
XESC L  -  delete line
X
X	ESC L deletes the line that the cursor is on; the lines above
Xand below this line move together to fill in the space.
X
XESC X  -  delete to end of line
X
X	ESC X  erases the  line that the  cursor is on from the cursor
Xposition to the end of the line.  If the cursor is at the beginning of
Xthe line, a blank line will remain.  If the line  is already blank, it
Xwill be deleted as with an ESC L.
X
XESC K -  delete to end of file
X
X	ESC K deletes everything from the cursor position to the end
Xof the file.  (Reminder: An ESC U (undo) will restore the text.)
X
X
XUndeleting                       (ESC > next topic    ESC < previous topic)
X=========
X
X^Y  -  Undelete line/word
X
X	^Y Undeletes a line or word erased by ^W, ESC L, or ESC X.  If
Xdone   immediately  after  the  delete, the   text is restored  in its
Xoriginal location.  However, if the cursor has moved, the text will be
Xrestored at the new cursor location.  In addition,  repeating  ^Y will
Xinsert extra copies of the deleted text into the file; in  this way ^Y
Xcan be used to copy or move segments of text in the file.
X	If multiple ESC L, ESC X, or ^W commands were done in sequence
X(with no cursor motion or other commands between), the ^Y will restore
Xeverything that was deleted.
X	Note  that for situations where ^Y does not restore deleted or
Xchanged text  (for example, text deleted with  ^Xs),  the Undo (ESC U)
Xcommand can restore the file  to its  previous state.  Note  also that
Xunlike ^Y,  ESC U  will restore deleted  text to its original location
Xonly  (it will  also  remove newly inserted   text;   Undo undoes  all
Xchanges).
X
X
XMoving Blocks of Text           (ESC > next topic    ESC < previous topic)
X=====================
X
XESC /  -  Mark block
XESC +  -  Insert block
X
X	Although text can be moved by deleting and undeleting (or retyping
Xit), often it is more convenient to be able to mark a block of text and 
Xmove or copy it.  To move a block of text means to delete the block and 
Xre-insert it somewhere else in the file.  To copy the block means that the
Xoriginal block is left intact, but a copy of it is also inserted somewhere 
Xelse.
X	To move or copy a block, position the cursor the beginning of the 
Xblock of text (it may be the middle of a line) and type ESC /.  Then move
Xthe cursor to the other end of the block and type ESC / again.  This will 
Xmark the block.  At this point you will be asked whether you want to move
Xor copy the block (see paragraph above).  If you choose "m" for move, the
Xoriginal block will be deleted; if you choose "c", it will be left intact.
XIn either case, you may now insert the block where the cursor is located by
Xtyping ESC +.  This may be done repeatedly; ee will remember the block 
Xthroughout the editing session until the next block is marked.
X
X
XSearching                       (ESC > next topic    ESC < previous topic)
X========
X
X^S    -   Search forward
X^Q    -   Search backward
X
X	^S searches for a  text string  (you will  be prompted for it)
Xfrom the cursor location to the end of the file.  ^Q searches from the
Xcursor location  backwards to the beginning  of the file.  If the text
Xis  found, the  cursor  is positioned   to  that location.  The search
Xignores case.  If you merely  hit return when  prompted for the search
Xstring, the previous search string will be used (if there was one).
X
X
XSubstituting                       (ESC > next topic    ESC < previous topic)
X===========
X
XESC Y   -   Search/Replace
X
X	ESC Y searches for and replaces every instance of a given string 
Xwith a new string.  The replacement is done from the current position to
Xthe end of the file.  You will be asked for both strings, and then for
Xconfirm or no confirm.  Without confirm, all replacements are done without
Xpause.  If you say "y" for confirm, the cursor will stop at each instance of
Xthe search string and ask you to confirm before replacing it.  At this
Xpoint, the following options are available:
X
X  y     - do the replacement and continue searching
X  n     - don't replace, but continue searching
X  .     - Replace this occurrence and stop
X  q     - Don't replace, and stop
X  !     - replace all occurrences from here on without confirming
X
X	ESC or "n" will stop the search/replace at any time.  To replace only
Xone (or fewer than every) instance of the search string, use confirm, and
Xuse the "n" option to skip those you don't want to replace.  Then use "." 
Xto replace and stop when you reach the one you want to change.
X
X
XReformatting                       (ESC > next topic    ESC < previous topic)
X============
XESC P   -   fill paragraph
X
X	Typing ESC P reformats the paragraph in which the cursor rests,
X splitting lines which are too  long and  splicing short ones  together
Xuntil all the lines fill the width  of  the  page as well as possible.
XThe command is useful if editing changes have caused  you to have very
Xshort or long lines.  The program considers  a paragraph to be a block
Xof lines separated by blank lines from the  surrounding  text; it does
X*not* recognize indented lines as starting paragraphs.
X	A  repeat count  has a special meaning if used with ESC P.  If
Xyou use an ESC C to give ESC P a repeat count (the actual value of the
Xcount will be ignored), it will justify the paragraph on both the left
Xand right margins.
X
X
XRepeat                       (ESC > next topic    ESC < previous topic)
X=====
XESC C    -  repeat command
XESC <number> 
X	ESC C  allows you  to   give a  "repeat"  argument  to   the 
Xfollowing command.  Some commands will  ignore the  argument; however,
Xmotion and deletion commands will honor it.  To  use the command, type
XESC C  #  <command>, where # is the  repeat count and  <command>  is a
Xvalid editing command.  ESC C has a special meaning for ESC P; see the
Xdocumentation on ESC P for details.
X	ESC  followed   by  a number  has  the same   meaning as ESC C. 
Xif the  ESC C  <number> or ESC  <number> is   followed by  a   regular
Xcharacter, that character will be repeated as if you had typed in that
Xmany times.
X
XExamples:
X	ESC C 12 ESC L       will delete 12 lines (a ^Y following this
X                             will insert all 12 lines back into the file)
X	ESC 18 ^X            will delete the next 18 characters
X 	ESC C 5  ^N          will move the cursor down 5 lines
X	ESC 25 j             will insert 25 "j"s into the file
X
X	
XInserting Files                     (ESC > next topic    ESC < previous topic)
X==============
XESC I    -   Insert a file 
X
X	This  command allows you  to  insert  the   contents  of 
Xanother file into the file you are editing.  You will be asked for the
Xname of the file to insert.  If the file is  found, its  contents will
Xbe inserted at the cursor position.
X
XESC D    -   List a directory
X
X	This command is useful when you can't remember the name of the
Xfile you want to insert.  It will  give you a  directory listing  in a
Xtemporary window which  replaces the HELP  window.  You will be  asked
Xfor the name of the directory to list, or you  may hit  return to list
Xyour  current  working   directory.   While  the directory   window is
Xdisplayed, you are prompted for an f, b, or r command.  f and b scroll
Xthe listing forward and backward, respectively (if it is longer than a
Xwindowfull), and the   r  command  restores removes the    listing and
Xreturns you to editing.
X
X
XUnix Commands                       (ESC > next topic    ESC < previous topic)
X============
XESC !    -    Execute a Unix command in window
X
X	The ESC ! (exclamation point) command allows you to execute a
XUnix command and display it in a window which temporarily replaces the
XHELP window.  The   command  *must*   be  of the type   which    lists
Xinformation but does not require further input from  you; for example,
X"who", "ls", "cat filename", or "date", are allowable; "Elm", "nn", or
X"talk" are not, since you would be  required to type further input for
Xthese commands. (See ^Z below for interactive unix commands).
X	The results of the command are listed in a window identical to
Xthe  ESC D  window,   with the same    options  for scrolling  and one
Xadditional  choice:  an "i" command which  will insert the contents of
Xthe window  (i.e.  the command  output) into your   file at the cursor
Xlocation.  For  example,  you  could use ESC  ! to  execute the "date"
Xcommand, and then insert the date into your file with an "i".
X
X
XRefresh screen                       (ESC > next topic    ESC < previous topic)
X==============
X^R     -     Redraw the screen
X
X	If extraneous messages such as notification of incoming mail
Xor  requests  to "talk" jumble   your editing display, type  a   ^R to
Xrestore the screen.
X
X
XRecovery                       (ESC > next topic    ESC < previous topic)
X========
XESC R   -    Recover file from aborted edit session
X
X	If you are editing a file and the editor is aborted (either
Xintentionally  with ESC   Q, or accidently due to   a system  crash or
Xdisconnection),  your  editing session is  not  necessarily lost.  The
Xnext time you edit this file with easy-edit, you  will probably  get a
Xmessage warning you  that a recovery file  exists and  suggesting that
Xyou do  ESC R to recover. 
X	 As you  edit, easy-edit periodically   saves your file  to  a
Xrecovery file, and each time you edit  a file the editor  first checks
Xfor a recovery file which is newer than the file itself.  If  you have
Xreceived the  warning message and want to  recover  your lost changes,
Xtype ESC R.  The  editor will ask you if  you really want to  recover,
Xand if you answer "yes", the editor will read in  the recovery file in
Xplace of  the  old version.  (Note  that the actual  file will  not be
Xchanged until you exit with an  ESC S).  If,  upon seeing the recovery
Xfile, you decide that you would rather keep the old version, simply do
Xan ESC U (undo) to undo the recovery, or abort the editor  with an ESC
XQ.  However,   you will continue   to receive  the warning about   the
Xrecovery file upon editing that file until you  modify the file and do
Xa save (ESC S) so  that the true  file becomes newer than the recovery
Xfile.
X
XSuspending the Editor               (ESC > next topic    ESC < previous topic)
X====================
X^Z  -   Suspend (temporarily) editor
X
X	A ^Z will temporarily suspend easy-edit and return you to a
XUnix prompt, where you may read  mail, or even  edit a different file.
XWhen you wish to  resume the editing session  you suspended, type "fg"
X(for  "foreground").  If you do  not  resume the suspended session and
Xattempt to logout, you will find that the system will not  log you off
Xand will warn you that you have "stopped jobs".
X
X
XStatus
X======
X^T  -   Edit status
X
X	Type ^T to review the time, the name of the file you are editing,
Xand whether or not you have modified the file during this edit.
X
XEasyedit license
X================
XESC @  -  License Info
X	
X	ESC @ displays licensing informatin in a special window similar to
Xthe directory window.  The information displayed is the same as follows:
X
XEasy-edit novice screen editor for Unix systems with GNU emacs
X
X
X     Easy-edit 1.22
X
X     Copyright (C) 1992     Larry Broda
X                            Department of Psychology
X                            University of Illinois at Urbana-Champaign
X
X    This program is distributed in the hope that it will be useful, 
X    but WITHOUT ANY WARRANTY; without even the implied warranty of 
X    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  This program  
X    is an extension of GNU emacs; See the GNU General Public License  
X    for more details. 
X
X    This program is free software; you can redistribute it and/or modify
X    it under the same terms as the GNU General Public License as published by
X    the Free Software Foundation either version 1, or (at your option)
X    any later version.
X
X       By Larry Broda  
X       Department of Psychology
X       University of Illinois at Urbana-Champaign
X       Email: lbroda@s.psych.uiuc.edu
X       4/13/92 
X
X    for GNU emacs information contact:
X    Free Software Foundation
X    675 Massachusetts Avenu
X    Cambridge, MA 02139
X    USA
END_OF_FILE
if test 19631 -ne `wc -c <'HELP-MANUAL'`; then
    echo shar: \"'HELP-MANUAL'\" unpacked with wrong size!
fi
# end of 'HELP-MANUAL'
fi
if test -f 'HELP-WINDOW' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HELP-WINDOW'\"
else
echo shar: Extracting \"'HELP-WINDOW'\" \(3775 characters\)
sed "s/^X//" >'HELP-WINDOW' <<'END_OF_FILE'
XESC F  More help    | Cursor Motion   |KEY:  ^F Press Control,F keys together
X--------------------|                 |   ESC F  Press ESC key, then F key
XExiting             |     ^P          | type ^C to cancel current command
X                    |      |          |-------------------------------------- 
XESC S  exit/save    | ^B --+-- ^F     | Erase:          | Undeleting/undoing 
XESC Q  quit/no save |      |          |                 |
X--------------------|     ^N          |   ^X character  |   ^Y Undel line/word
XScroll HELP window  |                 |   ^W word       |
X                    |^G/^O word ->/<- |ESC L line       |ESC U Undo last 
XESC F/f  up line/pg |^D/^U page ->/<- |ESC X to end/line|      action 
XESC B/b  back ln/pg |^A/^E bg/end line|ESC K to end/file| (may be repeated)
X------------------------------------------------------------------------------
XOverwrite/Insert    | Motion, Cont.            |   Display Control   
Xmode switch:  ESC N |                          |
X--------------------| ESC A  Beginning of file |    ^R  Redraw screen      
XSearching for text  | ESC E  End of file       | ESC J  Enlarge Edit window  
X                    | ESC G  Goto Line #       | ESC Z  Remove HELP window  
X^S - search forward |--------------------------| ESC H  Restore HELP window 
X^Q - search backward| ESC F / ESC B  HELP->/<- | ESC V  long/short HELP format
X------------------------------------------------------------------------------
XESC Y - Search/Replace: Search for a string and replace it with another
X------------------------------------------------------------------------------
XEasy-edit Manual:  ESC M  Display manual    ESC > / ESC <  Next/Prev subject
X------------------------------------------------------------------------------
XReformatting:                              | Repeat:  
XESC P - reformat paragraph to fill short   | ESC C  Add a repeat count to the
X        lines.                             |        following command. 
X(assumes blank lines between paragraphs    |(e.g. ESC C 9 ESC L kills 9 lines)
X------------------------------------------------------------------------------
XBlocks: ESC / - Mark beginning/end of a text block for a block copy or move
X        ESC + - Insert text block at cursor positoin
X------------------------------------------------------------------------------
XFiles:  ESC I - Insert contents of a file at cursor position
X        ESC D - List a directory for review
X	ESC W - Save your changes without exiting ee.
X	ESC T - Save your editing to a different file (and exit).
X------------------------------------------------------------------------------
XESC R  Recover previous unsaved or aborted edits 
X------------------------------------------------------------------------------
XUnix Commands: ESC ! - (ESC exclamation-point) execute a Unix command, with
X                         the option of inserting the results into your file.
X------------------------------------------------------------------------------
XInformation:   ^T - status   |  ESC @  - Easy-edit license info
X
X* ESC F - Scroll HELP forward    ESC B  - Scroll HELP backward *
X
X   ********************************************************************* 
X   *  Easy-edit (ee) v1.22 --- GNU Emacs-based editor                  *
X   * Copyright (C) 1992     Larry Broda                                *
X   *                        Department of Psychology                   *
X   *                        University of Illinois at Urbana-Champaign *
X   *                                                                   *
X   * type ESC @ for license information                                *
X   ********************************************************************* 
X* ESC F - Scroll HELP forward    ESC B  - Scroll HELP backward *
END_OF_FILE
if test 3775 -ne `wc -c <'HELP-WINDOW'`; then
    echo shar: \"'HELP-WINDOW'\" unpacked with wrong size!
fi
# end of 'HELP-WINDOW'
fi
if test -f 'HELP-WINDOW-ADVANCED' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HELP-WINDOW-ADVANCED'\"
else
echo shar: Extracting \"'HELP-WINDOW-ADVANCED'\" \(1134 characters\)
sed "s/^X//" >'HELP-WINDOW-ADVANCED' <<'END_OF_FILE'
XESC S  Save/Exit     | ^P  Up        ^U  page->       | ESC N Overwrite/Insert
XESC W  Save/No Exit  | ^N  Down      ^D  page<-       |    ^Y  Undel word/ln
XESC Q  Quit/abort    | ^F  ->     ^A/^E  Beg/End Line | ^X/^W  Del char/word
XESC T  Save to other | ^B  <-     ESC A  Top of file  | ESC L  Del line     
X=====================| ^G  word-> ESC E  end of file  | ESC X  Del->End/line  
XESC F/B HELP up/down | ^O  <-word ESC G  Goto line #  | ESC K  Del->End/file
XESC f/b ... by line  |========================================================
XESC J  Shrink HELP   | ESC U  undo    |^Q/^S <-Search-> | ESC P  Fill paragraph
XESC Z  Remove HELP   |=============== | ESC Y Substitute| ESC I  Insert file   
XESC H  Restore HELP  | ESC R  recover |=================| ESC D  List directory
XESC V  Switch Help   |    ^R  redraw  |ESC / mark block | ESC !  Unix command 
XESC M  Full manual   | ESC C  repeat  |ESC + put block  | ^T     Edit status
X=============================================================================
XEasy-edit 1.22 by Larry Broda, Dept. of Psych. Univ of Il at Champaign-Urbana
Xtype ESC @  for license information
X
END_OF_FILE
if test 1134 -ne `wc -c <'HELP-WINDOW-ADVANCED'`; then
    echo shar: \"'HELP-WINDOW-ADVANCED'\" unpacked with wrong size!
fi
# end of 'HELP-WINDOW-ADVANCED'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(406 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X HELP-MANUAL                1	
X HELP-WINDOW                1	
X HELP-WINDOW-ADVANCED       1	
X MANIFEST                   1	
X Makefile.templ             1	
X README                     1	
X easy-edit.man              1	
X easyedit.el                1	
X ee.license                 1	
X ee.sh.template             1	
END_OF_FILE
if test 406 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile.templ' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.templ'\"
else
echo shar: Extracting \"'Makefile.templ'\" \(2932 characters\)
sed "s/^X//" >'Makefile.templ' <<'END_OF_FILE'
X# 	Makefile for easy-edit 1.1
X#
X#
X#Easy-edit novice screen editor for Unix systems with GNU emacs
X#
X# Copyright (C) 1992     Larry Broda
X#
X#    This program is distributed in the hope that it will be useful,
X#    but WITHOUT ANY WARRANTY; without even the implied warranty of
X#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#    GNU General Public License for more details.
X#
X#       By Larry Broda
X#       Department of Psychology
X#       University of Illinois at Urbana-Champaign
X#       Email: lbroda@s.psych.uiuc.edu
X#       4/8/92
X#
X#
X#
X#  STEPS:	1.  Make sure you have GNU emacs installed and working.
X#		2.  Make sure you modify the following variables in this 
X#		    Makefile to reflect your system:
X#
X#		    EMACS_EXE  -   The path to your GNU emacs executable file
X#		    EE_LIBDIR -   The directory where you will keep the
X#				  Easyedit program and documentation files.
X#		    EXEDIR    -   The directory where you want the easy-edit
X#				  script installed.
X#		    EE_RESUME_CMD -  the command users will use to resume
X#				  ee (emacs) after suspending it with ^Z.
X#				  Will usually be fg or exit.
X#		    MAN_DIR    -  Where to put the man pages. (don`t include 
X#				  the section; edit Makefile for other than
X#				  section 1).
X#		    
X#			Make sure EE_LIBDIR and EXEDIR exist.
X#
X#		3. Make sure your account has privelege to install the 
X#		   programs in the given directories.
X#
X#		4. Do "make easy-edit"
X#		5. Do "make install"
X#		6. Do "make install-man" if you want the man pages installed.
X#
X#
X#  SET THESE TO AGREE WITH YOUR INSTALLATION:
X# 
X# Examples:
X#
X# EMACS_EXE=/usr/local/bin/emacs
X# EXEDIR=/usr/local/bin
X# EMACS_EXE=/usr/local/bin/emacs
X# EE_LIBDIR=/usr/local/lib/easyedit
X# EE_RESUME_CMD=fg
X# MAN_DIR=/usr/local/man
X#
XEMACS_EXE=
XEXEDIR=
XEE_LIBDIR=
XEE_RESUME_CMD=
XMAN_DIR=
X#
X#
X
Xall: easy-edit
X
Xeasy-edit: ee.sh.template
X	echo "#! /bin/sh " > easy-edit
X	echo "# " >> easy-edit
X	echo "export EE_LIB ; EE_LIB=${EE_LIBDIR}" >> easy-edit
X	echo "export EE_RESUME_CMD ; EE_RESUME_CMD=${EE_RESUME_CMD}" >> easy-edit
X	echo "GNUemacs=${EMACS_EXE}" >> easy-edit
X	echo "# " >> easy-edit
X	cat  ee.sh.template >> easy-edit
X
Xinstall: easy-edit
X	cp easyedit.el ${EE_LIBDIR}/easyedit.el
X	cp HELP-WINDOW ${EE_LIBDIR}/HELP-WINDOW
X	cp HELP-WINDOW-ADVANCED ${EE_LIBDIR}/HELP-WINDOW-ADVANCED
X	cp HELP-MANUAL ${EE_LIBDIR}/HELP-MANUAL
X	mv easy-edit ${EXEDIR}/easy-edit
X	rm -f  ${EXEDIR}/ee
X	ln ${EXEDIR}/easy-edit ${EXEDIR}/ee
X	chmod 755 ${EE_LIBDIR}
X	chmod 744 ${EE_LIBDIR}/HELP-WINDOW 
X	chmod 744 ${EE_LIBDIR}/HELP-WINDOW-ADVANCED
X	chmod 744 ${EE_LIBDIR}/HELP-MANUAL 
X	chmod 744 ${EE_LIBDIR}/easyedit.el 
X	chmod 755 ${EE_LIBDIR} 
X	chmod 755 ${EXEDIR}/easy-edit  ${EXEDIR}/ee
Xinstall-man:
X	rm -f ${MAN_DIR}/man1/ee.1
X	cp easy-edit.man ${MAN_DIR}/man1/easy-edit.1
X	ln ${MAN_DIR}/man1/easy-edit.1 ${MAN_DIR}/man1/ee.1
X	chmod 744 ${MAN_DIR}/man1/easy-edit.1 ${MAN_DIR}/man1/ee.1
Xclean:
X	rm easy-edit
END_OF_FILE
if test 2932 -ne `wc -c <'Makefile.templ'`; then
    echo shar: \"'Makefile.templ'\" unpacked with wrong size!
fi
# end of 'Makefile.templ'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(5485 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X		Easy-edit v1.23  			by Larry Broda
X===================================================================
X
X	Easy-edit (or "ee") is a simple text editor for novice users.
XIt is designed to be usable with no training at all, and it was
Xdesigned primarily for a Unix user community who used the system for
Xe-mail and little else, and are not willing or do not have the time to
Xlearn vi or emacs to edit their mail messages.  (At our installation,
Xeven computer-shy users who were afraid of Unix or vi and emacs began
Xediting when ee was introduced.  The response from such people, who
Xranged from secretaries to professors, was quite positive).
X
X	When used as the default editor in Elm, it makes for a very
Xeasy-to-use mail system requiring a mininum of user education.
X
X	Easy-edit is a major-mode of GNU Emacs.  As such it avoids many
Xof the screen/keyboard handling bugs in custom-written editors of this sort,
Xas that work is actually done by Emacs.  Ee splits the editing
Xscreen into two windows; in the top window, the file is edited, and in
Xthe bottom window (called the "HELP" window), a list of editing
Xcommands is displayed.  The HELP window may be scrolled up and down to
Xdisplay everything the ee user needs to know to edit a file; however,
Xusually the first HELP page contains enough to edit, and the susequent
Xones reveal more advanced commands.  The editor itself contains most
Xdesirable simple editing commands for insertion, deletion, searching,
Xand even text-justification.
X
X	Advanced users may choose a more concise HELP window display,
Xor may eliminate the HELP window completely (the HELP window may also
Xbe shrunk to make more room for the file window).  A full-text manual
Xcan also be displayed in the HELP window.
X
X	Easy-edit can be installed for an entire system by the system 
Xmanager, or by individuals in their own accounts for personal use, as long
Xas the system has GNU emacs.  
X
X	Easy-edit consists of the following files:
X
X
Xeasyedit.el           The Emacs-lisp program file.  When loaded into Emacs,
X                      easy-edit mode is enabled.
X
XHELP-WINDOW           The default HELP window display
XHELP-WINDOW-ADVANCED  The advanced HELP window display 
XHELP-MANUAL           The full text manual HELP window display
X
Xeasy-edit             The Bourne shell script file used to call
X                      easy-edit.  This script calls emacs with the
X	              arguments to bring up easy-edit mode. This
X                      script is generated by the makefile to use
X                      to the site-define directories.
X
Xee.sh.template        The template for the sh script, used by the
X                      Makefile to create easy-edit.
X
Xee                    A link to easy-edit, created by the Makefile,
X                      provided as a convenient abbreviation.
X
Xeasy-edit.man	      The man page for easy-edit
X
Xee.license	      Copyright/license info
X
XInstallation
X===========
X
XRequirements:  GNU Emacs.
X
X	Easy-edit was designed with GNU Emacs version 18.57 and 18.58,
Xand is untested with other versions.
X	Ee assumes that  it is running on a Unix system with BSD/csh
Xtype process control facilities.  Some commands may not behave properly
Xon other types of systems (esp, ^Z, ESC D, and ESC !).
X
X
XProcedure:
X=========
X
X1. Edit the Makefile
X
XCopy Makefile.templ to Makefile and change path variables to reflect 
Xyour system according to the instructions at the top of the file.  It
Xis recommended that you create a new directory for EE_LIBDIR, where the
Xprogram and HELP files are stored.  Be sure the full pathname for your
XEmacs executable is given where required.
X
XThe variable EE_RESUME_CMD should be set to reflect the command that
Xis issued to resume a suspended process.  On most systems, it will be 
Xprobably be "fg"; if your system suspends Emacs by forking a shell, this
Xwill be "exit".  The sole purpose of this variable is to issue an 
Xinformational message to users who suspend Ee reminding them how to start
Xit again.
X
XCreate the directories for EE_LIBDIR and EXEDIR if they do not exist.
X
X2. Do a "make easy-edit" 
X
XThis will create the shell script "easy-edit".
X
X3. Do a "make install"
X 
XThis will mv easy-edit to the specified directory, create "ee", which
Xwill be a hard link to easy-edit, and copy the easyedit.el and HELP
Xfiles into the EE_LIBDIR directory.
X
X4. If you want man pages, do a "make install-man"
X
X5. Give it a try.
X
X
XEasy-edit novice screen editor for Unix systems with GNU emacs
X
X     Easy-edit 1.23
X
X     Copyright (C) 1992     Larry Broda
X                            Department of Psychology
X                            University of Illinois at Urbana-Champaign
X
X    This program is distributed in the hope that it will be useful, 
X    but WITHOUT ANY WARRANTY; without even the implied warranty of 
X    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  This program  
X    is an extension of GNU emacs; See the GNU General Public License  
X    for more details. 
X
X    This program is free software; you can redistribute it and/or modify
X    it under the same terms as the GNU General Public License as published by
X    the Free Software Foundation either version 1, or (at your option)
X    any later version.
X
X       By Larry Broda  
X       Department of Psychology
X       University of Illinois at Urbana-Champaign
X       Email: lbroda@s.psych.uiuc.edu
X       4/13/92 
X
X    for GNU emacs information contact:
X    Free Software Foundation
X    675 Massachusetts Avenu
X    Cambridge, MA 02139
X    USA
END_OF_FILE
if test 5485 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'easy-edit.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'easy-edit.man'\"
else
echo shar: Extracting \"'easy-edit.man'\" \(2863 characters\)
sed "s/^X//" >'easy-edit.man' <<'END_OF_FILE'
X.TH name l "2 July 1992"
X.SH NAME 
XEasy-edit \- Split-window editor with Help window
X.SH SYNOPSIS
X.B easy-edit [ -e ][ -z ] file    or
X.LP
X.B ee [ -e ][ -z ] file
X.SH DESCRIPTION
XEasy-edit, or "ee", is a simple editor designed to be usable by persons with 
Xno experience who need to do quick editing for mail or other needs and
Xdo not wish to invest the time needed to learn traditional Unix editors.
XEe splits the terminal screen into two windows, and editing window and a
XHELP window which lists editing commands.  Thus all the reference
Xinformation needed for editing is always available online, meaning that
Xa complete novice should be able to invoke ee and begin editing
Ximmediately.
X.PD
X.PP
XUsing Easy-edit can be as simple as invoking it with a filename, typing
Xin text (line-wraps are automatically inserted), and saving it with an
XESC S command.  More complex editing functions are performed with either
Xcontrol-keys (the control key pressed simultaneously with another key),
Xor escape sequences (the ESC key followed by another key).  
X
X.PP
XOnce familiar with the editing commands, the ee user may switch to a
Xmore concise HELP window listing with the ESC V commands, or invoke ee
Xwith the -e option (ee -e filename) to get the concise help listing at
Xthe outset.  The -z option allows ee to be started with no help window; 
Xthe HELP window may still be restored with the ESC H command, however.
XA full-text manual may also be displayed.  There are
Xcommands to shrink or eliminate the HELP window for experienced users
Xwho wish to have a larger editing display (the HELP window can always be
Xrestored with an ESC H).
X
XEasy-edit is a major mode of GNU Emacs.  
X.PD
X.PP
X.SH EXAMPLES
XTo edit the file "newfile":
X
X	ee newfile
X
XTo edit the file "oldfile", with the advanced HELP window listing:
X
X	ee -e oldfile
X.PD
X.PP
X.SH FILES
X.PD 0
X.TP 22
Xeasy-edit 
X- The script which calls GNU emacs and loads the easy-edit
Xconfiguration.
X.PD 0
X.TP 22
XHELP-WINDOW
X- The standard HELP window display
X.PD 0
X.TP 22
XHELP-WINDOW-ADVANCED
X- The advanced HELP display
X.PD 0
X.TP 22
XHELP-MANUAL
X- the manual display
X.PD 0
X.TP 22
Xeasyedit.el
X- The emacs lisp program which puts emacs in easy-edit mode.
X.SH SEE ALSO
Xemacs(1)
X.PD
X.PP
X.PP
X.SH WARNINGS
XIf for some reason the the easy-edit.el file cannot be loaded, or if
Xthere is a bug in this file, the user can be left in regular emacs with
Xno indication as to how to exit, or even with the regular emacs keys
Xunbound but the easy-edit keys not yet bound (and thus no way to exit).
XUsually in this case a ^Z will still suspend ee/emacs, allowing the
Xprocess to then be killed.
X.PD
X.PP
X.SH AUTHOR
X.nf
X	Larry Broda
X	Department of Psychology
X	University of Illinois at Urbana-Champaign
X	Champaign, Il
X
X	GNU Emacs was written by
X	primarily by Richard Stallman,
X	Free Software Foundation
X	675 Massachusetts Ave.
X	Cambridge,  MA  02139
END_OF_FILE
if test 2863 -ne `wc -c <'easy-edit.man'`; then
    echo shar: \"'easy-edit.man'\" unpacked with wrong size!
fi
# end of 'easy-edit.man'
fi
if test -f 'easyedit.el' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'easyedit.el'\"
else
echo shar: Extracting \"'easyedit.el'\" \(45297 characters\)
sed "s/^X//" >'easyedit.el' <<'END_OF_FILE'
X(setq ee-VERSION "1.23")
X
X;                    Easy-Edit  1.23       GNU Emacs configuration
X;			7/2/92
X;
X;
X; Easy-edit novice screen editor for Unix systems with GNU emacs
X;
X; Copyright (C) 1992     Larry Broda
X;                      
X;
X;    This program is distributed in the hope that it will be useful,
X;    but WITHOUT ANY WARRANTY; without even the implied warranty of
X;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  This program 
X;    is an extension of GNU emacs; See the GNU General Public License 
X;    for more details.
X;
X;    This program is free software; you can redistribute it and/or modify
X;    it under the same terms as the GNU General Public License as 
X;    published by the Free Software Foundation; either version 1, or 
X;    (at your option) any later version.
X;
X;
X;
X;	Easy-edit 1.23
X;       By Larry Broda  
X;	Department of Psychology
X;	University of Illinois at Urbana-Champaign
X;       Email: lbroda@s.psych.uiuc.edu
X;	4/13/92 
X;
X;    GNU emacs information:
X;    contact:
X;    Free Software Foundation
X;    675 Massachusetts Avenu
X;    Cambridge, MA 02139
X;    USA
X
X(defconst ee-com-map nil
X  "Keymap for easyedit")
X;
X; Function to give an error message for using an key out of context
X;
X(defun ee-not-here ()
X  "That key unbound at moment"
X  (interactive)
X  (ding))
X
X;
X; 
X;
X
X(defun ee-nofun ()
X  "function to give an error for an unbound key"
X  (interactive)
X  (message "Not currently an easy-edit command" (ding))
X  (sleep-for 2)
X  (ee-message HELP_HELP))
X
X
X(defun ee-quit ()
X  "Exit without saving"
X  (interactive)	
X  (progn
X    (if (buffer-modified-p (get-buffer "EDIT"))
X	(progn
X	  (cond 
X	   ((yes-or-no-p "Really quit and cancel changes? " ) 
X	    (message "Cancelling changes!")
X	    (sleep-for 1)
X	    (discard-input)
X	    (kill-emacs))
X	   ((ee-message HELP_HELP))))
X      (message "No changes to cancel...")
X      (sleep-for 1)
X      (discard-input)
X      (kill-emacs))))
X
X(defun ee-kill-to-eof ()
X  "Delete from point to End of buffer"
X  (interactive)
X  (end-of-buffer)
X  (delete-region (point) (mark)))
X
X(defun ee-move-block ()
X  "Demark a block of text and copy or move it"
X  (interactive)
X  (if (> ee-BLOCK-MARK 0)
X	 (progn 
X
X	   (let ((imsg "
X		 Type  m  to move the block (delete original)
X		 Type  c  to copy the block (leave original)
X
X                 Type ESC +  when ready to insert the block at cursor
X
X                 ... you may continue to insert the block repeatedly
X                     until you mark another block.")
X		 (iprmpt "Choose m or c, please: "))
X
X	     (setq DELFLG (eq (ee-choosefrom-list imsg iprmpt '(?c ?m)) ?m)))
X
X	   (copy-to-register ?b ee-BLOCK-MARK (point) DELFLG)
X	   (setq ee-BLOCK-MARK 0)
X	   (message "type ESC + to insert block at cursor location")
X	   (setq ee-BLOCK-SAVED 'true)
X	   (ding))
X
X    (setq ee-BLOCK-MARK (point))
X    (setq ee-BLOCK-SAVED 'nil)
X    (message "Move cursor to other end of text block and press ESC / again")
X    (ding)
X    (sleep-for 2)))
X
X;
X; Code from GNU Emacs: ee-query-replace and ee-perform-replace are modifications by
X; Larry Broda, Dept. of Psychology/University of Illinois at C-U, of the
X; functions query-replace and perform-replace from the GNU Emacs distribution, and are subject
X; to all terms of the GNU Emacs Public License.
X;
X
X(defun ee-query-replace (from-string to-string &optional arg)
X  "\
XReplace some occurrences of FROM-STRING with TO-STRING.
XAs each match is found, the user must type a character saying
Xwhat to do with it.  
XPreserves case in each replacement if  case-replace  and  case-fold-search
Xare non-nil and FROM-STRING has no uppercase letters.
XThird arg DELIMITED (prefix arg if interactive) non-nil means replace
Xonly matches surrounded by word boundaries."
X  (interactive "sQuery replace: \nsQuery replace %s with: \nP")
X  (ee-perform-replace from-string to-string t nil arg)
X  (message "Done"))
X
X(defun ee-perform-replace (from-string to-string
X		        query-flag regexp-flag delimited-flag)
X  (let ((nocasify (not (and case-fold-search case-replace
X			    (string-equal from-string
X					  (downcase from-string)))))
X	(literal (not regexp-flag))
X	(search-function (if regexp-flag 're-search-forward 'search-forward))
X	(search-string from-string)
X	(keep-going t)
X	(lastrepl nil))			;Position after last match considered.
X    (if delimited-flag
X	(setq search-function 're-search-forward
X	      search-string (concat "\\b"
X				    (if regexp-flag from-string
X				      (regexp-quote from-string))
X				    "\\b")))
X    (push-mark)
X    (push-mark)
X    (while (and keep-going
X		(not (eobp))
X		(progn
X		 (set-mark (point))
X		 (funcall search-function search-string nil t)))
X      ;; Don't replace the null string 
X      ;; right after end of previous replacement.
X      (if (eq lastrepl (point))
X	  (forward-char 1)
X	(undo-boundary)
X	(if (not query-flag)
X	    (replace-match to-string nocasify literal)
X	  (let (done replaced)
X	    (while (not done)
X	      ;; Preserve the match data.  Process filters and sentinels
X	      ;; could run inside read-char..
X;	      (let ((data (match-data))
X;		    (help-form
X;		     '(concat "Query replacing "
X;			      (if regexp-flag "regexp " "")
X;			      from-string " with " to-string ".\n\n"
X;			      (substitute-command-keys query-replace-help))))
X;		(setq char help-char)
X;		(while (= char help-char)
X;		  (message "Query replacing %s with %s: " from-string to-string)
X;		  (setq char (read-char))
X;		  (if (= char ??)
X;		      (setq unread-command-char help-char char help-char)))
X;		(store-match-data data))
X
X		 
X		(message "Query replacing %s with %s: " from-string to-string)
X		(setq char (read-char))
X
X	      (cond ((or (= char ?\e)
X			 (= char ?q))
X		     (setq keep-going nil)
X		     (setq done t))
X		    ((= char ?y)
X		     (or replaced
X			 (replace-match to-string nocasify literal))
X		     (setq done t))
X		    ((= char ?\.)
X		     (or replaced
X			 (replace-match to-string nocasify literal))
X		     (setq keep-going nil)
X		     (setq done t))
X		    ((= char ?!)
X		     (or replaced
X			 (replace-match to-string nocasify literal))
X		     (setq done t query-flag nil))
X		    ((= char ?n)
X		     (setq done t))
X		    ((= char ?\C-l)
X		     (recenter nil))
X		    (t
X		     (message "Not a choice")
X		     (ding)
X		     (sleep-for 2))))))
X	(setq lastrepl (point))))
X    (pop-mark)
X    keep-going))
X
X(defun ee-search-replace ()
X  "Do a text search/replace"
X  (interactive)
X  (setq sprompt (concat "Replace-> [" search-last-string "]: "))
X  (setq sstring (read-string sprompt))
X  (if (> (length sstring) 0)
X      (setq search-last-string sstring)
X    (setq sstring search-last-string))
X  
X    (if (> (length sstring) 0)
X	(progn
X	  (setq rstring (read-string "Replace with-> "))
X	  (save-window-excursion
X	    (with-output-to-temp-buffer "*INFORMATION*"
X	      (save-excursion
X		(set-buffer "*INFORMATION*")
X		(erase-buffer))
X	      (princ "             Search/Replace\n\n")
X	      (princ (concat "Replace all occurrences of " sstring " with " rstring "\n"))
X	      (princ "from the current position to the end of file.\n")
X	      (princ "(use confirm if you don't want to replace every occurrence)\n\n")
X	      (princ "Type y for confirm (will ask before doing each replacement)\n")
X	      (princ "Type n to do all replacements without confirming\n"))
X	    (setq SRFLG ?x)
X	    (while (not (ee-member SRFLG '(?y ?n)))
X	      (progn
X		(let ((cursor-in-echo-area t))
X		  (message "Confirm replacements (y or n)? ")
X		  (ding)
X		  (setq SRFLG (downcase (read-char))))
X		(let ((cursor-in-echo-area nil))
X		  (cond
X		 ((eq SRFLG ?y)
X		  (with-output-to-temp-buffer "*INFORMATION*"
X		    (save-excursion
X		      (set-buffer "*INFORMATION*")
X		      (erase-buffer))
X		    (princ "Choices for answering replace query: \n\n")
X		    (princ "(press ESC or q to stop the search/replace at any time)\n\n")
X		    (princ "  y     - do the replacement and continue searching\n")
X		    (princ "  n     - don't replace, but continue searching\n")
X		    (princ "  .     - Replace this occurrence and stop\n")
X		    (princ "  q     - Don't replace, and stop\n")
X		    (princ "  !     - replace all occurrences from here on without confirming\n"))
X		  (ee-query-replace sstring rstring nil))
X		 ((eq SRFLG ?n)  (replace-string sstring rstring))
X		 (t  (message "Type y for confirm, n for no confirm, please")
X		     (sleep-for 2))))))))))
X
X(defun ee-insert-block ()
X  "Insert block"
X  (interactive)
X
X  (if (null ee-BLOCK-SAVED )
X      (progn
X        (message "No block has been marked and saved with ESC /")
X        (ding))
X    (insert-register ?b)))
X	
X
X(defun ee-recover ()
X  "recover from an Emacs auto-save file"
X  (interactive)
X  (ee-recover-file EE_FILE_NAME)
X  (auto-save-mode 1)
X  (easyedit-mode))
X
X;
X; following function derived from GNU Emacs recover-file function, by
X; Richard Stallman
X;
X(defun ee-recover-file (file)
X  "Visit file FILE, but get contents from its last auto-save file."
X  (interactive "FRecover file: ")
X  (setq file (expand-file-name file))
X  (if (auto-save-file-name-p file) (error "%s is an auto-save file" file))
X  (let ((file-name (let ((buffer-file-name file))
X             (make-auto-save-file-name))))
X    (cond ((not (file-newer-than-file-p file-name file))
X       (error "Auto-save file %s not current" file-name))
X       ((yes-or-no-p "Recover previous unsaved edits? " ) 
X        (switch-to-buffer (find-file-noselect file t))
X        (let ((buffer-read-only nil))
X         (erase-buffer)
X         (insert-file-contents file-name nil))
X        (after-find-file nil))
X		(t (error "Recovery cancelled.")))
X  (setq buffer-auto-save-file-name nil)))
X  
X 
X(defun ee-check-recovery-file (file)
X  "Print a nicer message if the save file is current"
X  (interactive)
X  (setq file (expand-file-name file))
X  (if (auto-save-file-name-p file) (error "%s is an auto-save file" file))
X  (let ((file-name (let ((buffer-file-name file))
X             (make-auto-save-file-name))))
X    (cond ((file-newer-than-file-p file-name file)
X           (message "Found recovery file from unsaved edit; consider ESC R to recover.")
X            (ding)
X            (sleep-for 4)))))
X
X(defun ee-suspend-edit ()
X  "suspend"
X  (interactive)
X  (progn
X    (suspend-emacs EE_RESUME_MSG)
X    (ee-message HELP_HELP)))
X
X(defun ee-create-help ()
X  "Create the help window"
X  (progn
X    (setq EEHELPF
X	  (cond
X	   ((setq temp (getenv "EASYEDIT_HELP")) temp)
X	   (t "/usr/local/lib/easyedit/HELP-WINDOW")))
X    (setq ALTERNATE_HELP (concat EEHELPF "-ADVANCED"))
X    (setq EASYEDIT_MANUAL
X	  (cond
X	   ((setq temp (getenv "EASYEDIT_MANUAL")) temp)
X	   (t "/usr/local/lib/easyedit/HELP-MANUAL")))
X    (if (string-equal (getenv "HELP_LEVEL") "advanced")
X	(progn
X	  (setq temp ALTERNATE_HELP)
X	  (setq ALTERNATE_HELP EEHELPF)
X	  (setq EEHELPF temp)))
X    (if (file-exists-p EEHELPF)
X	(progn
X	  (setq ee-HWIN (split-window nil nil nil))
X	  (select-window ee-HWIN)
X	  (switch-to-buffer "HELP")
X	  (insert-file-contents EEHELPF)
X	  (setq buffer-read-only t)
X	  (select-window ee-EWIN))
X      (message "HELP FILE NOT FOUND!")
X      (ding)
X      (sleep-for 3)
X      (discard-input)
X      (kill-emacs))))
X
X(defun ee-switch-help ()
X  "toggle between the advanced and basic help files"
X  (interactive)
X  (if (not (file-exists-p ALTERNATE_HELP))
X      (progn
X	(message "Alternate help file not found!")
X	(ding))
X    (define-key ee-com-map "\e>" 'ee-not-manual)
X    (define-key ee-com-map "\e<" 'ee-not-manual)
X    (set-buffer "HELP")
X    (setq buffer-read-only nil)
X    (erase-buffer)
X    (insert-file-contents ALTERNATE_HELP)
X    (setq buffer-read-only t)
X    (set-buffer "EDIT")
X    (setq temp ALTERNATE_HELP)
X    (setq ALTERNATE_HELP EEHELPF)
X    (setq EEHELPF temp)))
X
X(defun ee-manual ()
X  "replace HELP with MANUAL display"
X  (interactive)
X  (if (not (file-exists-p EASYEDIT_MANUAL))
X      (progn
X	(message "Easy-edit manual file not found!")
X	(ding))
X    (set-buffer "HELP")
X    (let ((buffer-read-only nil))
X      (erase-buffer)
X      (insert-file-contents EASYEDIT_MANUAL))
X    (set-buffer "EDIT")
X    (define-key ee-com-map "\e>" 'ee-next-subject)
X    (define-key ee-com-map "\e<" 'ee-previous-subject)
X    (setq HELP_HELP "ESC F/B scroll fwd/bkwd;  ESC H - restore HELP")
X    (ee-message HELP_HELP)))
X
X(defun ee-insert-file ()
X  "Insert file"
X  (interactive)
X  (setq ifile (read-string "File to insert: "))
X  (if (> (length ifile) 0) 
X(let ((default-directory "./"))
X(insert-file-contents ifile)))
X  (ee-message HELP_HELP))
X
X(defun ee-search-forward ()
X  "search forward"
X  (interactive)
X  (setq sprompt (concat "Find-> [" search-last-string "]: "))
X  (setq sstring (read-string sprompt))
X  (if (> (length sstring) 0) (setq search-last-string sstring)) 
X  (search-forward search-last-string))
X
X(defun ee-search-backward ()
X  "search forward"
X  (interactive)
X  (setq sprompt (concat "<-Find [" search-last-string "]: "))
X  (setq sstring (read-string sprompt))
X  (if (> (length sstring) 0) (setq search-last-string sstring)) 
X  (search-backward search-last-string))
X
X(defun ee-message (ee_txt)
X  "write an easy-edit message at bottom of screen"
X  (interactive)
X  (message (concat EE_FILE_NAME (concat EE_MODE  (concat " ---- " ee_txt)))))
X
X(defun ee-upp-help ()
X  "Scroll help window upwards"
X  (interactive)
X  (if (window-point ee-HWIN)
X      (progn
X	(select-window ee-HWIN)
X	(setq HWSIZE (- (window-height) 1))
X	(select-window ee-EWIN)
X	(scroll-other-window (* -1 HWSIZE)))
X    (message "No HELP window to scroll")
X    (ding)
X    (sleep-for 2))
X  (ee-message HELP_HELP))
X
X(defun ee-downp-help ()
X  "Scroll help window upwards"
X  (interactive)
X  (if (window-point ee-HWIN)
X      (progn
X	(select-window ee-HWIN)
X	(setq HWSIZE (- (window-height) 1))
X	(select-window ee-EWIN)
X	(scroll-other-window HWSIZE))
X    (message "No HELP window to scroll")
X    (ding)
X    (sleep-for 2))
X  (ee-message HELP_HELP))
X
X
X(defun ee-upl-help ()
X  "Scroll help window upwards"
X  (interactive)
X  (if (window-point ee-HWIN)
X      (scroll-other-window -1)
X    (message "No HELP window to scroll")
X    (ding)
X    (sleep-for 2))
X  (ee-message HELP_HELP))
X
X(defun ee-downl-help ()
X  "Scroll help window upwards"
X  (interactive)
X  (if (window-point ee-HWIN)
X      (scroll-other-window 1)
X    (message "No HELP window to scroll")
X    (ding)
X    (sleep-for 2))
X  (ee-message HELP_HELP))
X
X
X(defun ee-kill-line (cnt)
X  "Delete a line"
X  (interactive "P")
X  (progn 
X    (beginning-of-line)
X    (kill-line (if (eq cnt nil) 1 cnt))))
X
X(defun ee-restore-help ()
X  "restore a lost help window"
X  (interactive)
X  (progn
X    (define-key ee-com-map "\e>" 'ee-not-manual)
X    (define-key ee-com-map "\e<" 'ee-not-manual)
X    (switch-to-buffer "EDIT")
X    (delete-other-windows)
X    (setq ee-HWIN (split-window nil nil nil))
X    (select-window ee-HWIN)
X    (switch-to-buffer "HELP")
X    (let ((buffer-read-only nil))
X      (erase-buffer)
X      (insert-file-contents EEHELPF))
X    (select-window ee-EWIN)
X    (setq HELP_HELP "ESC F / ESC B -> HELP forward / backward")
X    (ee-message HELP_HELP)))
X
X(defun ee-zap-help ()
X  "Remove the HELP window"
X  (interactive)
X  (progn
X    (delete-other-windows)
X    (switch-to-buffer "EDIT")
X    (setq HELP_HELP "To display HELP window: ESC H")
X    (ee-message HELP_HELP)))
X
X  ;
X  ;
X  ; display the *INFORMATION* window with the mesg "mesg", for 
X  ; duration seconds.  If duration =0, display it until a character is typed
X  ; if cmd is non-nil, execute the function
X  ;
X(defun ee-INFO (mesg)
X  (save-window-excursion
X    (with-output-to-temp-buffer "*INFORMATION*"
X      (save-excursion
X	(set-buffer "*INFORMATION*")
X	(erase-buffer)
X	)
X      (princ "\n\n")
X      (princ mesg))
X    (let ((cursor-in-echo-area t))
X      (message "Type any character to continue: ")(read-char))
X    ))
X
X
X;
X; this command displays "mesg" in a tien INFORMATION window,
X; and prompts for a character which must be a member of choices, using
X; the prompt string "prompt" to prompt for it
X;
X(defun ee-choosefrom-list (mesg prompt choices)
X  (progn
X      (save-window-excursion
X	(with-output-to-temp-buffer "*INFORMATION*"
X	  (save-excursion
X	    (set-buffer "*INFORMATION*")
X	    (erase-buffer)
X	    )
X	  (princ "\n\n")
X	  (princ mesg))
X	(let ((cursor-in-echo-area t))
X	  (setq achar '(x))
X	  (while (not (ee-member achar choices))
X	    (message prompt)
X	    (ding)
X	    (setq achar (downcase (read-char)))))
X	)
X      achar))
X
X(defun ee-member (item list)
X  "is item in list?"
X  (cond
X   ((null list)  nil)
X   ((eq item (car list))   list)
X   (t        (ee-member item (cdr list)))))
X
X(defun ee-status ()
X  "status "
X  (interactive)
X  (progn
X    (setq IMSG
X	  (concat (current-time-string) "
X
XYou are editing "  buffer-file-name "
X
XFile editing status: " (cond ((buffer-modified-p (get-buffer "EDIT")) "Modified")
X		     (t "Not modified")) "
X
X(type ESC @ for easy-edit license information)"))
X    (ee-INFO IMSG)))
X
X(defun ee-get-arg (mesg prompt)
X  (let (char)
X      (save-window-excursion
X(with-output-to-temp-buffer "*INFORMATION*"
X  (save-excursion
X    (set-buffer "*INFORMATION*")
X    (erase-buffer)
X    )
X  (princ mesg))
X(let ((cursor-in-echo-area t))
X  (read-string prompt))
X)))
X
X(defun ee-save-exit ()
X  "save file and exit"
X  (interactive)
X  (progn
X    (if (buffer-modified-p (get-buffer "EDIT"))
X	(message (concat "Saving " EE_FILE_NAME))
X      (message (concat EE_FILE_NAME " not modified")))
X    (sleep-for 1)      
X    (save-buffer)
X    (discard-input)
X    (kill-emacs)))
X
X(defun ee-save-noexit ()
X  "save file but do not exit"
X  (interactive)
X  (progn
X    (if (buffer-modified-p (get-buffer "EDIT"))
X	(message (concat "Saving " EE_FILE_NAME))
X      (message (concat EE_FILE_NAME " not modified")))
X    (sleep-for 1)      
X    (save-buffer)))
X
X(defun ee-saveto-file ()
X  "save file and exit"
X  (interactive)
X  (let ((default-directory "./"))
X    (progn
X      (set-buffer "EDIT")
X      
X      (setq sprompt "Save to what filename: ")
X      (setq savename (read-string sprompt))
X      (if (> (length savename) 0) 
X	  (progn
X	    (if (file-writable-p savename)
X		(progn
X		  (setq SAVEFL
X			(if (file-exists-p savename)
X			    (yes-or-no-p 
X			     (concat savename " exists!  Overwrite it? "))
X			  t))
X		  (if SAVEFL
X		      (progn
X			(write-file savename)
X			(message 
X			 (concat savename " saved;  " 
X				 EE_FILE_NAME " unchanged"))
X			(sleep-for 2)
X			(discard-input)
X			(kill-emacs))))
X	      (message (concat "Cannot create/write to " savename))))))))
X
X
X(defun ee-grow-EDIT ()
X  "Enlarge EDIT window"
X  (interactive)
X  (cond 
X   ((window-point ee-HWIN) 
X    (progn
X      (enlarge-window 1)
X      (if (not (window-point ee-HWIN))
X	  (setq HELP_HELP "To restore HELP window: ESC H"))
X	(ee-message HELP_HELP)))))
X
X(defun ee-next-subject ()
X  "Move to the next subject in the manual"
X  (interactive)
X  (if (window-point ee-HWIN)
X      (progn
X	(select-window ee-HWIN)
X	(forward-line)
X	(if (not (re-search-forward "^=" nil t))
X	    (progn
X	      (beginning-of-buffer)
X	      (re-search-forward "^=" nil t)))
X	(recenter 1)
X	(ee-message HELP_HELP)
X	(select-window ee-EWIN))))
X 
X(defun ee-previous-subject ()
X  "Move to the next subject in the manual"
X  (interactive)
X  (if (window-point ee-HWIN)
X      (progn
X	(select-window ee-HWIN)
X	(forward-line -1)
X	(if (not (re-search-backward "^=" nil t))
X	    (progn
X	      (end-of-buffer)
X	      (re-search-backward "^=" nil t)))
X	(recenter 1)
X	(ee-message HELP_HELP)
X	(select-window ee-EWIN))))
X
X(defun ee-toggle-insert ()
X  "toggle insert/overwrite modes"
X  (interactive)
X  (cond 
X   ((= EASYEDIT-INSERT 1) 
X    (overwrite-mode 1)
X    (setq EASYEDIT-INSERT 0)
X    (setq EE_MODE "  *Overwrite*")
X    (ee-message HELP_HELP))
X   (t   (overwrite-mode 0)
X(setq EASYEDIT-INSERT 1)
X(setq EE_MODE "  *Insert*")
X(ee-message HELP_HELP))))
X
X;
X; elm easy editor setup
X
X(defun easyedit-mode ()
X  "set easyedit mode"
X  (if (eq major-mode 'easyedit-mode)
X      (message "already in easyedit-mode" (ding))
X    (setq mode-name "easy-edit")
X    (setq major-mode "easyedit-mode")
X    (use-local-map ee-com-map)
X    (put 'switch-to-buffer 'disabled t)
X    (put 'switch-to-buffer-other-window 'disabled t)
X    (put 'other-window 'disabled t)
X    (put 'kill-region 'disabled t)
X    (put 'execute-extended-command 'disabled t)
X    (setq HELP_HELP "ESC F / ESC B -> HELP forward / backward")
X    (setq window-min-height 1)
X    (setq fill-column 72)
X    (setq EASYEDIT-INSERT 1)
X    (setq EE_MODE "  *Insert*")
X    (setq search-last-string "")
X    (setq make-backup-files nil)
X    (setq require-final-newline t)
X    (auto-fill-mode 1)
X
X    (if (setq EE_RES_CMD (getenv "EE_RESUME_CMD"))
X	(setq EE_RESUME_MSG (concat "echo Suspending easy-edit.... to resume type " EE_RES_CMD))
X      (setq EE_RESUME_MSG (concat "echo Suspending easy-edit")))
X
X    (ee-message HELP_HELP)))
X    
X(if ee-com-map nil
X  (setq ee-com-map (make-keymap))
X
X  (define-key ee-com-map "\C-a" 'beginning-of-line)
X  (define-key ee-com-map "\C-b" 'backward-char)
X  (define-key ee-com-map "\C-c" 'abort-recursive-edit)
X  (define-key ee-com-map "\C-d" 'scroll-up)
X  (define-key ee-com-map "\C-e" 'end-of-line)
X  (define-key ee-com-map "\C-f" 'forward-char)
X  (define-key ee-com-map "\C-g" 'forward-word)
X  (define-key ee-com-map "\C-h" 'backward-delete-char-untabify)
X; i is the tab
X  (define-key ee-com-map "\C-j" 'next-line)
X  (define-key ee-com-map "\C-k" 'previous-line)
X  (define-key ee-com-map "\C-l" 'ee-not-here)
X; m is carriage return
X  (define-key ee-com-map "\C-n" 'next-line)
X  (define-key ee-com-map "\C-o" 'backward-word)
X  (define-key ee-com-map "\C-p" 'previous-line)
X  (define-key ee-com-map "\C-q" 'ee-search-backward)
X  (define-key ee-com-map "\C-r" 'redraw-display)
X  (define-key ee-com-map "\C-s" 'ee-search-forward)
X  (define-key ee-com-map "\C-t" 'ee-status)
X  (define-key ee-com-map "\C-u" 'scroll-down)
X  (define-key ee-com-map "\C-v" 'next-line)
X  (define-key ee-com-map "\C-w" 'kill-word)
X  (define-key ee-com-map "\C-x" 'delete-char)
X  (define-key ee-com-map "\C-y" 'yank)
X  (define-key ee-com-map "\C-z" 'ee-suspend-edit)
X 
X; Make Sun and RT arrow keys work (at expense of back-paragraph (esc-[))
X  (defconst ee-esc-map (make-sparse-keymap)
X    " yea yea")
X  (define-key ee-com-map "\e" ee-esc-map)
X  (defconst esc-bracket-map (make-sparse-keymap)
X         "*Keymap for ESC-[ encoded keyboard")
X
X  (defconst esc-O-map (make-sparse-keymap)
X         "*Keymap for ESC-O encoded keyboard")
X  (define-key ee-esc-map "O" esc-O-map)
X
X  (define-key ee-esc-map "[" esc-bracket-map)   ; Install esc-bracket-map
X  (define-key ee-esc-map "[A" 'previous-line)   ; R8
X  (define-key ee-esc-map "[B" 'next-line)   ; R14
X  (define-key ee-esc-map "[C" 'forward-char)   ; R12
X  (define-key ee-esc-map "[D" 'backward-char)   ; R10
X  (define-key ee-esc-map "OA" 'previous-line)   ; R8
X (define-key ee-esc-map "OB" 'next-line)   ; R14
X (define-key ee-esc-map "OC" 'forward-char)   ; R12
X (define-key ee-esc-map "OD" 'backward-char)
X (define-key ee-esc-map "\e" 'abort-recursive-edit)
X
X  (define-key ee-com-map "\eA" 'beginning-of-buffer)
X  (define-key ee-com-map "\eb" 'ee-upp-help)
X  (define-key ee-com-map "\eB" 'ee-upl-help)
X  (define-key ee-com-map "\eC" 'ee-repeat-count)
X  (define-key ee-com-map "\eD" 'ee-nofun)
X  (define-key ee-com-map "\eE" 'end-of-buffer)
X  (define-key ee-com-map "\ef" 'ee-downp-help)
X  (define-key ee-com-map "\eF" 'ee-downl-help)
X  (define-key ee-com-map "\eG" 'goto-line)
X  (define-key ee-com-map "\eH" 'ee-restore-help)  
X  (define-key ee-com-map "\eI" 'ee-insert-file)  
X  (define-key ee-com-map "\eJ" 'ee-grow-EDIT)
X  (define-key ee-com-map "\eK" 'ee-kill-to-eof)
X  (define-key ee-com-map "\eL" 'ee-kill-line)  
X  (define-key ee-com-map "\eM" 'ee-manual)
X  (define-key ee-com-map "\eN" 'ee-toggle-insert)
X; ESC O used for cursor motion map
X  (define-key ee-com-map "\eP" 'fill-paragraph)  
X  (define-key ee-com-map "\eQ" 'ee-quit)
X  (define-key ee-com-map "\eR" 'ee-recover)
X  (define-key ee-com-map "\eS" 'ee-save-exit)
X  (define-key ee-com-map "\eT" 'ee-saveto-file)
X  (define-key ee-com-map "\eU" 'undo)
X  (define-key ee-com-map "\eV" 'ee-switch-help)
X  (define-key ee-com-map "\eW" 'ee-save-noexit)
X  (define-key ee-com-map "\eX" 'kill-line)
X  (define-key ee-com-map "\eY" 'ee-search-replace)
X  (define-key ee-com-map "\eZ" 'ee-zap-help)
X  (define-key ee-com-map "\ea" 'beginning-of-buffer)
X  (define-key ee-com-map "\ec" 'ee-repeat-count)
X  (define-key ee-com-map "\ed" 'ee-list-dir)
X  (define-key ee-com-map "\ee" 'end-of-buffer)
X  (define-key ee-com-map "\eg" 'goto-line)
X  (define-key ee-com-map "\eh" 'ee-restore-help)  
X  (define-key ee-com-map "\ei" 'ee-insert-file)  
X  (define-key ee-com-map "\ej" 'ee-grow-EDIT)
X  (define-key ee-com-map "\ek" 'ee-kill-to-eof)
X  (define-key ee-com-map "\el" 'ee-kill-line)  
X  (define-key ee-com-map "\em" 'ee-manual)
X  (define-key ee-com-map "\en" 'ee-toggle-insert)
X; ESC O used for cursor motion map
X  (define-key ee-com-map "\eo" 'ee-nofun)
X  (define-key ee-com-map "\ep" 'fill-paragraph)  
X  (define-key ee-com-map "\eq" 'ee-quit)
X  (define-key ee-com-map "\er" 'ee-recover)
X  (define-key ee-com-map "\es" 'ee-save-exit)
X  (define-key ee-com-map "\et" 'ee-saveto-file)
X  (define-key ee-com-map "\eu" 'undo)
X  (define-key ee-com-map "\ev" 'ee-switch-help)
X  (define-key ee-com-map "\ew" 'ee-save-noexit)
X  (define-key ee-com-map "\ex" 'kill-line)
X  (define-key ee-com-map "\ey" 'ee-search-replace)
X  (define-key ee-com-map "\ez" 'ee-zap-help)
X
X  (define-key ee-com-map "\e!" 'ee-unix-command)
X  (define-key ee-com-map "\e>" 'ee-not-manual)
X  (define-key ee-com-map "\e<" 'ee-not-manual)
X  (define-key ee-com-map "\e@" 'ee-license)
X  (define-key ee-com-map "\e#" 'ee-nofun)
X  (define-key ee-com-map "\e$" 'ee-nofun)
X  (define-key ee-com-map "\e%" 'ee-nofun)
X  (define-key ee-com-map "\e^" 'ee-nofun)
X  (define-key ee-com-map "\e&" 'ee-nofun)
X  (define-key ee-com-map "\e*" 'ee-nofun)
X  (define-key ee-com-map "\e(" 'ee-nofun)
X  (define-key ee-com-map "\e)" 'ee-nofun)
X  (define-key ee-com-map "\e_" 'ee-nofun)
X  (define-key ee-com-map "\e+" 'ee-insert-block)
X  (define-key ee-com-map "\e-" 'ee-nofun)
X  (define-key ee-com-map "\e=" 'ee-nofun)
X  (define-key ee-com-map "\e{" 'ee-nofun)
X  (define-key ee-com-map "\e}" 'ee-nofun)
X  (define-key ee-com-map "\e]" 'ee-nofun)
X  (define-key ee-com-map "\e:" 'ee-nofun)
X  (define-key ee-com-map "\e;" 'ee-nofun)
X  (define-key ee-com-map "\e\"" 'ee-nofun)
X  (define-key ee-com-map "\e~" 'ee-nofun)
X  (define-key ee-com-map "\e'" 'ee-nofun)
X  (define-key ee-com-map "\e`" 'ee-nofun)
X  (define-key ee-com-map "\e\." 'ee-nofun)
X  (define-key ee-com-map "\e\," 'ee-nofun)
X  (define-key ee-com-map "\e?" 'ee-nofun)
X  (define-key ee-com-map "\e/" 'ee-move-block)
X  (define-key ee-com-map "\e|" 'ee-nofun)
X  (define-key ee-com-map "\e\\" 'ee-nofun)
X
X;
X;  DISABLE (or set) all esc/control sequecnes for minibuffer and regular editing
X;
X
X  (define-key ee-com-map "\e\C-a" 'ee-nofun)
X  (define-key ee-com-map "\e\C-b" 'ee-nofun)
X  (define-key ee-com-map "\e\C-c" 'ee-nofun)
X  (define-key ee-com-map "\e\C-d" 'ee-nofun)
X  (define-key ee-com-map "\e\C-e" 'ee-nofun)
X  (define-key ee-com-map "\e\C-f" 'ee-nofun)
X  (define-key ee-com-map "\e\C-g" 'ee-nofun)
X  (define-key ee-com-map "\e\C-h" 'ee-nofun)
X  (define-key ee-com-map "\e\C-i" 'ee-nofun)
X  (define-key ee-com-map "\e\C-j" 'ee-nofun)
X  (define-key ee-com-map "\e\C-k" 'ee-nofun)
X  (define-key ee-com-map "\e\C-l" 'ee-nofun)
X  (define-key ee-com-map "\e\C-m" 'ee-nofun)
X  (define-key ee-com-map "\e\C-n" 'ee-nofun)
X  (define-key ee-com-map "\e\C-o" 'ee-nofun)
X  (define-key ee-com-map "\e\C-p" 'ee-nofun)
X  (define-key ee-com-map "\e\C-q" 'ee-nofun)
X  (define-key ee-com-map "\e\C-r" 'ee-nofun)
X  (define-key ee-com-map "\e\C-s" 'ee-nofun)
X  (define-key ee-com-map "\e\C-t" 'ee-nofun)
X  (define-key ee-com-map "\e\C-u" 'ee-nofun)
X  (define-key ee-com-map "\e\C-v" 'ee-nofun)
X  (define-key ee-com-map "\e\C-w" 'ee-nofun)
X  (define-key ee-com-map "\e\C-x" 'ee-nofun)
X  (define-key ee-com-map "\e\C-y" 'ee-nofun)
X  (define-key ee-com-map "\e\C-z" 'ee-nofun)
X  (define-key ee-com-map "\e\C-!" 'ee-nofun)
X  (define-key ee-com-map "\e\C->" 'ee-nofun)
X  (define-key ee-com-map "\e\C-<" 'ee-nofun)
X  (define-key ee-com-map "\e\C-@" 'ee-nofun)
X  (define-key ee-com-map "\e\C-#" 'ee-nofun)
X  (define-key ee-com-map "\e\C-$" 'ee-nofun)
X  (define-key ee-com-map "\e\C-%" 'ee-nofun)
X  (define-key ee-com-map "\e\C-^" 'ee-nofun)
X  (define-key ee-com-map "\e\C-&" 'ee-nofun)
X  (define-key ee-com-map "\e\C-*" 'ee-nofun)
X  (define-key ee-com-map "\e\C-(" 'ee-nofun)
X  (define-key ee-com-map "\e\C-)" 'ee-nofun)
X  (define-key ee-com-map "\e\C-_" 'ee-nofun)
X  (define-key ee-com-map "\e\C-+" 'ee-nofun)
X  (define-key ee-com-map "\e\C--" 'ee-nofun)
X  (define-key ee-com-map "\e\C-=" 'ee-nofun)
X  (define-key ee-com-map "\e\C-{" 'ee-nofun)
X  (define-key ee-com-map "\e\C-}" 'ee-nofun)
X  (define-key ee-com-map "\e\C-]" 'ee-nofun)
X  (define-key ee-com-map "\e\C-:" 'ee-nofun)
X  (define-key ee-com-map "\e\C-;" 'ee-nofun)
X  (define-key ee-com-map "\e\C-\"" 'ee-nofun)
X  (define-key ee-com-map "\e\C-~" 'ee-nofun)
X  (define-key ee-com-map "\e\C-'" 'ee-nofun)
X  (define-key ee-com-map "\e\C-`" 'ee-nofun)
X  (define-key ee-com-map "\e\C-\." 'ee-nofun)
X  (define-key ee-com-map "\e\C-\," 'ee-nofun)
X  (define-key ee-com-map "\e\C-?" 'ee-nofun)
X  (define-key ee-com-map "\e\C-/" 'ee-nofun)
X  (define-key ee-com-map "\e\C-|" 'ee-nofun)
X  (define-key ee-com-map "\e\C-\\" 'ee-nofun)
X
X  (define-key minibuffer-local-map "\e\C-a" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-b" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-c" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-d" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-e" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-f" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-g" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-h" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-i" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-j" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-k" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-l" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-m" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-n" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-o" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-p" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-q" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-r" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-s" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-t" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-u" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-v" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-w" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-x" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-y" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-z" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-!" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C->" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-<" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-@" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-#" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-$" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-%" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-^" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-&" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-*" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-(" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-)" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-_" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-+" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C--" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-=" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-{" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-}" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-]" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-:" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-;" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-\"" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-~" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-'" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-`" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-\." 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-\," 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-?" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-/" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-|" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\C-\\" 'ee-nofun)
X
X
X; various escape sequecnes for arrow keys in minibuffer
X; Make Sun and RT arrow keys work 
X  (defconst esc-bracket-map (make-sparse-keymap)
X    "*Keymap for ESC-[ encoded keyboard")
X  (progn
X    (define-key esc-map "[" esc-bracket-map)   ; Install esc-bracket-map
X    (define-key esc-map "[A" 'previous-line)   ; R8
X    (define-key esc-map "[B" 'next-line)   ; R14
X    (define-key esc-map "[C" 'forward-char)   ; R12
X    (define-key esc-map "[D" 'backward-char)   ; R10
X    (define-key esc-map "[[" 'backward-paragraph))   ; the original esc-[
X  
X  (defconst esc-O-map (make-sparse-keymap)
X    "*Keymap for ESC-[ encoded keyboard")
X  (progn
X    (define-key esc-map "O" esc-O-map)   ; Install esc-O-map
X    (define-key esc-map "OA" 'previous-line)   ; R8
X    (define-key esc-map "OB" 'next-line)   ; R14
X    (define-key esc-map "OC" 'forward-char)   ; R12
X    (define-key esc-map "OD" 'backward-char))   ; R10
X
X  (define-key minibuffer-local-map "\C-a" 'beginning-of-line)
X  (define-key minibuffer-local-map "\C-b" 'backward-char)
X  (define-key minibuffer-local-map "\C-c" 'abort-recursive-edit)
X  (define-key minibuffer-local-map "\C-d" 'ee-not-here)
X  (define-key minibuffer-local-map "\C-e" 'end-of-line)
X  (define-key minibuffer-local-map "\C-f" 'forward-char)
X  (define-key minibuffer-local-map "\C-g" 'forward-word)
X  (define-key minibuffer-local-map "\C-h" 'backward-delete-char-untabify)
X; i is the tab
X  (define-key minibuffer-local-map "\C-j" 'ee-not-here)
X  (define-key minibuffer-local-map "\C-k" 'ee-not-here)
X  (define-key minibuffer-local-map "\C-l" 'ee-not-here)
X; m is carriage return
X  (define-key minibuffer-local-map "\C-n" 'ee-not-here)
X  (define-key minibuffer-local-map "\C-o" 'backward-word)
X  (define-key minibuffer-local-map "\C-p" 'ee-not-here)
X  (define-key minibuffer-local-map "\C-q" 'ee-not-here)
X  (define-key minibuffer-local-map "\C-r" 'redraw-display)
X  (define-key minibuffer-local-map "\C-s" 'ee-not-here)
X  (define-key minibuffer-local-map "\C-t" 'ee-not-here)
X  (define-key minibuffer-local-map "\C-u" 'ee-not-here)
X  (define-key minibuffer-local-map "\C-v" 'ee-not-here)
X  (define-key minibuffer-local-map "\C-w" 'kill-word)
X  (define-key minibuffer-local-map "\C-x" 'delete-char)
X  (define-key minibuffer-local-map "\C-y" 'yank)
X  (define-key minibuffer-local-map "\C-z" 'ee-suspend-edit)
X  (define-key minibuffer-local-map "\eA" 'ee-not-here)
X  (define-key minibuffer-local-map "\eB" 'ee-not-here)
X  (define-key minibuffer-local-map "\eC" 'ee-not-here)
X  (define-key minibuffer-local-map "\eD" 'ee-list-dir)
X  (define-key minibuffer-local-map "\eE" 'ee-not-here)
X  (define-key minibuffer-local-map "\eF" 'ee-not-here)
X  (define-key minibuffer-local-map "\eG" 'ee-not-here)
X  (define-key minibuffer-local-map "\eH" 'ee-not-here)
X  (define-key minibuffer-local-map "\eI" 'ee-not-here)
X  (define-key minibuffer-local-map "\eJ" 'ee-not-here)
X  (define-key minibuffer-local-map "\eK" 'ee-not-here)
X  (define-key minibuffer-local-map "\eL" 'ee-kill-line)  
X  (define-key minibuffer-local-map "\eM" 'ee-not-here)
X  (define-key minibuffer-local-map "\eN" 'ee-toggle-insert)
X  (define-key minibuffer-local-map "\eP" 'ee-not-here)
X  (define-key minibuffer-local-map "\eQ" 'ee-not-here)
X  (define-key minibuffer-local-map "\eR" 'ee-not-here)
X  (define-key minibuffer-local-map "\eS" 'ee-not-here)
X  (define-key minibuffer-local-map "\eT" 'ee-not-here)
X  (define-key minibuffer-local-map "\eU" 'undo)
X  (define-key minibuffer-local-map "\eV" 'ee-not-here)
X  (define-key minibuffer-local-map "\eW" 'ee-not-here)
X  (define-key minibuffer-local-map "\eX" 'kill-line)
X  (define-key minibuffer-local-map "\eY" 'ee-not-here)
X  (define-key minibuffer-local-map "\eZ" 'ee-not-here)
X  (define-key minibuffer-local-map "\ea" 'ee-not-here)
X  (define-key minibuffer-local-map "\eb" 'ee-not-here)
X  (define-key minibuffer-local-map "\ec" 'ee-not-here)
X  (define-key minibuffer-local-map "\ed" 'ee-not-here)
X  (define-key minibuffer-local-map "\ee" 'ee-not-here)
X  (define-key minibuffer-local-map "\ef" 'ee-not-here)
X  (define-key minibuffer-local-map "\eg" 'ee-not-here)
X  (define-key minibuffer-local-map "\eh" 'ee-not-here)
X  (define-key minibuffer-local-map "\ei" 'ee-not-here)
X  (define-key minibuffer-local-map "\ej" 'ee-not-here)
X  (define-key minibuffer-local-map "\ek" 'ee-not-here)
X  (define-key minibuffer-local-map "\el" 'ee-kill-line)  
X  (define-key minibuffer-local-map "\em" 'ee-not-here)
X  (define-key minibuffer-local-map "\en" 'ee-toggle-insert)
X  (define-key minibuffer-local-map "\ep" 'ee-not-here)
X  (define-key minibuffer-local-map "\eq" 'ee-not-here)
X  (define-key minibuffer-local-map "\er" 'ee-not-here)
X  (define-key minibuffer-local-map "\es" 'ee-not-here)
X  (define-key minibuffer-local-map "\et" 'ee-not-here)
X  (define-key minibuffer-local-map "\eu" 'undo)
X  (define-key minibuffer-local-map "\ev" 'ee-not-here)
X  (define-key minibuffer-local-map "\ew" 'ee-not-here)
X  (define-key minibuffer-local-map "\ex" 'kill-line)
X  (define-key minibuffer-local-map "\ey" 'ee-not-here)
X  (define-key minibuffer-local-map "\ez" 'ee-not-here)
X  
X  (define-key minibuffer-local-map "\e!" 'ee-nofun)
X  (define-key minibuffer-local-map "\e@" 'ee-nofun)
X  (define-key minibuffer-local-map "\e#" 'ee-nofun)
X  (define-key minibuffer-local-map "\e$" 'ee-nofun)
X  (define-key minibuffer-local-map "\e%" 'ee-nofun)
X  (define-key minibuffer-local-map "\e^" 'ee-nofun)
X  (define-key minibuffer-local-map "\e&" 'ee-nofun)
X  (define-key minibuffer-local-map "\e*" 'ee-nofun)
X  (define-key minibuffer-local-map "\e(" 'ee-nofun)
X  (define-key minibuffer-local-map "\e)" 'ee-nofun)
X  (define-key minibuffer-local-map "\e_" 'ee-nofun)
X  (define-key minibuffer-local-map "\e+" 'ee-nofun)
X  (define-key minibuffer-local-map "\e-" 'ee-nofun)
X  (define-key minibuffer-local-map "\e=" 'ee-nofun)
X  (define-key minibuffer-local-map "\e{" 'ee-nofun)
X  (define-key minibuffer-local-map "\e}" 'ee-nofun)
X  (define-key minibuffer-local-map "\e]" 'ee-nofun)
X  (define-key minibuffer-local-map "\e:" 'ee-nofun)
X  (define-key minibuffer-local-map "\e;" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\"" 'ee-nofun)
X  (define-key minibuffer-local-map "\e~" 'ee-nofun)
X  (define-key minibuffer-local-map "\e'" 'ee-nofun)
X  (define-key minibuffer-local-map "\e`" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\." 'ee-nofun)
X  (define-key minibuffer-local-map "\e\," 'ee-nofun)
X  (define-key minibuffer-local-map "\e?" 'ee-nofun)
X  (define-key minibuffer-local-map "\e/" 'ee-nofun)
X  (define-key minibuffer-local-map "\e|" 'ee-nofun)
X  (define-key minibuffer-local-map "\e\\" 'ee-nofun)
X)
X
X
X
X(defun ee-list-dir ()
X  "List a directory in another window"
X  (interactive)
X  (let ((default-directory "./"))
X    (setq gamsg "\n\n\nType a filename, a directory name, or a wildcard 
X(e.g. t*   lists all files starting with t)
Xto list particular files or an entire directory.\n
XType a carriage return alone to list the current working directory")
X(setq ldir (ee-get-arg gamsg "Dir or file(s) to list: ")) 
X(save-window-excursion
X  (if (eq 0 (length ldir))
X      (setq ldir "."))
X  
X  (setq lcomm (concat "ls -l " ldir))
X  (setq command (concat "(set noglob; /bin/echo command executed: " lcomm ");" lcomm))
X  (with-output-to-temp-buffer "*Directory*"
X    (buffer-flush-undo standard-output)
X    (message "Working...")
X    (call-process "csh" nil standard-output nil "-c" command))
X  (let ((cursor-in-echo-area t))
X    (setq char ?b)
X    (while (not (eq char ?r))
X      (progn 
X	(message "(f)orward  (b)ackwards  (r)esume editing: ")
X	(setq char (downcase (read-char)))
X	(other-window 1)
X	(cond ((eq char ?f) 
X	       (if (not (pos-visible-in-window-p (point-max))) 
X		   (scroll-up)(ding)(message "At bottom")(sleep-for 2)))
X	      ((eq char ?b) 
X	       (if (not (pos-visible-in-window-p (point-min))) 
X		   (scroll-down)(ding)(message "At top")(sleep-for 2)))
X	      ((eq char ?r) nil)
X	      (t   (message "Type f, b, or r please: ")
X		   (sleep-for 2)
X		   t))
X	(other-window 1))) )))
X)
X
X(defun ee-license ()
X  "License info"
X  (interactive)
X(save-window-excursion
X
X  (with-output-to-temp-buffer "*LICENSE*"
X
X    (buffer-flush-undo standard-output)
X    (princ " Easy-edit novice screen editor for Unix systems with GNU emacs\n")
X    (princ "
X     Easy-edit " ) (princ ee-VERSION)
X    (princ "
X
X     Copyright (C) 1992     Larry Broda
X                            Department of Psychology
X                            University of Illinois at Urbana-Champaign
X
X    This program is distributed in the hope that it will be useful, 
X    but WITHOUT ANY WARRANTY; without even the implied warranty of 
X    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  This program  
X    is an extension of GNU emacs; See the GNU General Public License  
X    for more details. 
X
X    This program is free software; you can redistribute it and/or modify
X    it under the same terms as the GNU General Public License as published by
X    the Free Software Foundation; either version 1, or (at your option)
X    any later version.
X
X
X       By Larry Broda  
X       Department of Psychology
X       University of Illinois at Urbana-Champaign
X       Email: lbroda@s.psych.uiuc.edu
X       4/13/92 
X
X    for GNU emacs information contact:
X    Free Software Foundation
X    675 Massachusetts Avenu
X    Cambridge, MA 02139
X    USA
X"))
X  (let ((cursor-in-echo-area t))
X    (setq char ?b)
X    (while (not (eq char ?r))
X      (progn 
X	(message "(f)orward  (b)ackwards  (r)esume editing: ")
X	(setq char (downcase (read-char)))
X	(other-window 1)
X	(cond ((eq char ?f) 
X	       (if (not (pos-visible-in-window-p (point-max))) 
X		   (scroll-up)(ding)(message "At bottom")(sleep-for 2)))
X	      ((eq char ?b) 
X	       (if (not (pos-visible-in-window-p (point-min))) 
X		   (scroll-down)(ding)(message "At top")(sleep-for 2)))
X	      ((eq char ?r) nil)
X	      (t   (message "Type f, b, or r please: ")
X		   (sleep-for 2)
X		   t))
X	(other-window 1)))))
X)
X
X(defun ee-repeat-count ()
X  "Begin a numeric argument for the following command.
XDigits or minus sign following this command make up the numeric argument.
XIf no digits or minus sign follow, this command by itself provides 4 as argument.
XUsed more than once, this command multiplies the argument by 4 each time."
X  (interactive nil)
X  (message "Enter count followed by key or command to repeat: ")
X  (let ((c-u 4) (argstartchar last-command-char)
X	char)
X    (setq char (read-char))
X    (while (= char argstartchar)
X      (setq c-u (* 4 c-u))
X      (setq char (read-char)))
X    (prefix-arg-internal char c-u nil)))
X
X(defun ee-not-manual ()
X  "Error for using manual commands outside manual"
X  (interactive)
X  (message "This command only valid if manual is displayed")
X  (ding)
X  (sleep-for 3)
X  (ee-message HELP_HELP))
X
X(defun ee-unix-command ()
X  "execute a Unix command"
X  (interactive)
X  (setq gamsg "Type a unix command.  The output will be displayed in
Xa special window, where you may:
X1: Scroll the output listing forward and backward (f/b).
X2: Insert the command output listing into your edit file at the current 
X   cursor location (i).
XNOTE:  The command can *NOT* be a command that requires further input by you;
XUse ^Z to escape to a Unix prompt to perform interactive commands.
XEXAMPLES of valid commands: date; cat <filename>; who, etc.
XEXAMPLES of *INVALID* commands: Elm; easyedit; Mail, etc.
X...or anything that requires additional input from you..")
X  (let ((default-directory "./"))
X    (setq command (ee-get-arg gamsg "Unix Command: ")) 
X    (save-window-excursion
X      (with-output-to-temp-buffer "*Unix*"
X	(buffer-flush-undo standard-output)
X	(message (concat "executing " (concat command "...")))
X	(call-process "csh" nil standard-output nil "-c" command))
X      (let ((cursor-in-echo-area t))
X	(setq char ?b)
X	(while (not (eq char ?r))
X	  (progn 
X	    (message "(f)orward  (b)ackwards  (i)nsert output into file  (r)esume editing: ")
X	    (setq char (downcase (read-char)))
X	    (other-window 1)
X	    (cond ((eq char ?f) 
X		   (if (not (pos-visible-in-window-p (point-max))) 
X		       (scroll-up)(ding)(message "At bottom")(sleep-for 2)))
X		  ((eq char ?b) 
X		   (if (not (pos-visible-in-window-p (point-min))) 
X		       (scroll-down)(ding)(message "At top")(sleep-for 2)))
X		  ((eq char ?r) nil)
X		  ((eq char ?i) (progn (copy-to-register ?v (point-min)(point-max) nil)
X				       (other-window 1)
X				       (insert-register ?v)
X				       (other-window 1)))
X		  
X		  (t   (message "Type f, b, i, or r please: ")
X		       (sleep-for 2)
X		       t))
X	    (other-window 1))))))
X  )
X
X
X;
X;
X;  create the separate windows
X;
X
X(progn
X  (setq EE_FILE_NAME (file-name-nondirectory buffer-file-name))
X  (ee-check-recovery-file EE_FILE_NAME)
X  (rename-buffer "EDIT")
X  (setq ee-EWIN (selected-window))
X  (setq ee-BLOCK-MARK 0)
X  (setq ee-BLOCK-SAVED nil)
X  (ee-create-help)
X  (easyedit-mode)
X  (if (getenv "EE_HELP_OFF")
X        (progn (ee-zap-help) ))
X)
END_OF_FILE
if test 45297 -ne `wc -c <'easyedit.el'`; then
    echo shar: \"'easyedit.el'\" unpacked with wrong size!
fi
# end of 'easyedit.el'
fi
if test -f 'ee.license' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ee.license'\"
else
echo shar: Extracting \"'ee.license'\" \(1026 characters\)
sed "s/^X//" >'ee.license' <<'END_OF_FILE'
X
X     Easy-edit 1.23
X
X     Copyright (C) 1992     Larry Broda
X                            Department of Psychology
X                            University of Illinois at Urbana-Champaign
X
X    This program is distributed in the hope that it will be useful, 
X    but WITHOUT ANY WARRANTY; without even the implied warranty of 
X    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  This program  
X    is an extension of GNU emacs; See the GNU General Public License  
X    for more details. 
X
X    This program is free software; you can redistribute it and/or modify
X    it under the same terms as the GNU General Public License as published by
X    the Free Software Foundation either version 1, or (at your option)
X    any later version.
X
X       By Larry Broda  
X       Department of Psychology
X       University of Illinois at Urbana-Champaign
X       Email: lbroda@s.psych.uiuc.edu
X       7/2/92 
X
X    for GNU emacs information contact:
X    Free Software Foundation
X    675 Massachusetts Avenu
X    Cambridge, MA 02139
X    USA
END_OF_FILE
if test 1026 -ne `wc -c <'ee.license'`; then
    echo shar: \"'ee.license'\" unpacked with wrong size!
fi
# end of 'ee.license'
fi
if test -f 'ee.sh.template' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ee.sh.template'\"
else
echo shar: Extracting \"'ee.sh.template'\" \(2241 characters\)
sed "s/^X//" >'ee.sh.template' <<'END_OF_FILE'
X#
X#	Run emacs in the "easy edit" mode
X#
X# 
X#Easy-edit novice screen editor for Unix systems with GNU emacs
X# 
X# Copyright (C) 1992     Larry Broda
X# 
X#    This program is free software; you can redistribute it and/or modify
X#    it under the terms of the GNU General Public License as published by
X#    the Free Software Foundation; either version 1, or (at your option)
X#    any later version.
X# 
X#    This program is distributed in the hope that it will be useful,
X#    but WITHOUT ANY WARRANTY; without even the implied warranty of
X#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#    GNU General Public License for more details.
X# 
X#       By Larry Broda
X#       Department of Psychology
X#       University of Illinois at Urbana-Champaign
X#       Email: lbroda@s.psych.uiuc.edu
X#       4/8/92
X# 
X#    GNU emacs information:
X#    contact:
X#    Free Software Foundation
X#    675 Massachusetts Avenu
X#    Cambridge, MA 02139
X#    USA
X#
X#
X# setup environmental variables used by easy-edit
X#
Xexport EASY_EL; EASY_EL=$EE_LIB/easyedit.el
Xexport EASYEDIT_HELP; EASYEDIT_HELP=$EE_LIB/HELP-WINDOW
Xexport EASYEDIT_MANUAL ; EASYEDIT_MANUAL=$EE_LIB/HELP-MANUAL
Xexport HELP_LEVEL ; HELP_LEVEL=basic
Xexport EE_HELP_OFF ; unset EE_HELP_OFF 
XME=$0
XFILE=nofile$$
X
X#
X# process command line args
X#
Xfor ARG
Xdo
X	case $ARG in
X		-e) export HELP_LEVEL; HELP_LEVEL=advanced ;;
X		-[Zz]) export EE_HELP_OFF; EE_HELP_OFF=y ;;
X		-*) /bin/echo "Unrecognized option: $ARG" ;
X		    /bin/echo "Form: $ME [-e][-z] filename" ;
X		    /bin/echo "Options: -e - start with advanced HELP window"
X		    /bin/echo "         -z - start with no HELP window"
X		    exit 1 ;;
X		*) if [ "$FILE" != "nofile$$" ]; then
X		         /bin/echo "Form: $ME [-e] filename" 
X		         exit 1 
X			else
X				FILE="$ARG"
X			fi ;;
X	esac
Xdone
X
X#
X# check the file to edit, prompt for it if not on command line
X#
Xif [ "$FILE" = "nofile$$" ]; then
X	/bin/echo -n "File: "
X	read FILE
Xfi
Xif [ "$FILE" = "" ]; then
X	/bin/echo "You must call $0 with a filename or give a filename when asked"
X	/bin/echo " e.g.  $0 filename"
X	exit 1
Xfi
Xif [ -d "$FILE" ]; then
X	/bin/echo "$FILE is a directory.  You cannot edit a directory."
X	exit 1
Xfi
X
X$GNUemacs -no-init-file "$FILE" -l $EE_LIB/$EASY_EL 
END_OF_FILE
if test 2241 -ne `wc -c <'ee.sh.template'`; then
    echo shar: \"'ee.sh.template'\" unpacked with wrong size!
fi
# end of 'ee.sh.template'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
