Newsgroups: comp.sources.unix
From: mogul@dec.com (Jeff Mogul)
Subject: v26i072: psgraph - generate graph in Postscript, Part01/03
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: mogul@dec.com (Jeff Mogul)
Posting-Number: Volume 26, Issue 72
Archive-Name: psgraph/part01


"Psgraph" takes input files vaguely like those accepted by graph(1),
and produces PostScript output.  The manual page explains the rest.

Please obey the part in the LICENSE file that says not to redistribute
this software to anyone, unless you do it for free and include the
LICENSE file and all copyright notices.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 3)."
# Contents:  LICENSE MANIFEST Makefile README examples
#   examples/Makefile examples/README examples/distribb.data
#   examples/oneconn.data examples/rbi.plot examples/rbi2.plot
#   examples/simplecolor.data examples/wire-fusing.grf input.c main.c
#   patchlevel.h psgraph.h psgraph.man psgraph.pro psgsimp.c
#   psgsimp.man
# Wrapped by tp@cognition.pa.dec.com on Mon Sep  7 16:47:34 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'LICENSE' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'LICENSE'\"
else
echo shar: Extracting \"'LICENSE'\" \(2100 characters\)
sed "s/^X//" >'LICENSE' <<'END_OF_FILE'
X              Copyright 1989, 1992 Digital Equipment Corporation
X                         All Rights Reserved
X
X
XPermission to use, copy, and modify this software and its documentation is
Xhereby granted only under the following terms and conditions.  Both the above
Xcopyright notice and this permission notice must appear in all copies of the
Xsoftware, derivative works or modified versions, and any portions threof, and
Xboth notices must appear in supporting documentation.
X
XUsers of this software agree to the terms and conditions set forth herein,
Xand hereby grant back to Digital a non-exclusive, unrestricted, royalty-free
Xright and license under any changes, enhancements or extensions made to the
Xcore functions of the software, including but not limited to those affording
Xcompatibility with other hardware or software environments, but excluding
Xapplications which incorporate this software.  Users further agree to use
Xtheir best efforts to return to Digital any such changes, enhancements or
Xextensions that they make and inform Digital of noteworthy uses of this
Xsoftware.  Correspondence should be provided to Digital at:
X
X                      Director of Licensing
X                      Western Research Laboratory
X                      Digital Equipment Corporation
X                      250 University Avenue
X                      Palo Alto, California  94301  
X
XThis software may be distributed (but not offered for sale or transferred
Xfor compensation) to third parties, provided such third parties agree to
Xabide by the terms and conditions of this notice.
X  
XTHE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS
XALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
XWARRANTIES OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL
XEQUIPMENT CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR
XCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
XUSE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
XOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
XPERFORMANCE OF THIS SOFTWARE.
END_OF_FILE
if test 2100 -ne `wc -c <'LICENSE'`; then
    echo shar: \"'LICENSE'\" unpacked with wrong size!
fi
# end of 'LICENSE'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(871 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X LICENSE                    1	
X MANIFEST                   1	
X Makefile                   1	
X README                     1	
X examples                   1	
X examples/Makefile          1	
X examples/README            1	
X examples/distribb.data     1	
X examples/long.plot         2	
X examples/oneconn.data      1	
X examples/rbi.plot          1	
X examples/rbi.txt           3	
X examples/rbi2.plot         1	
X examples/simplecolor.data  1	
X examples/wire-fusing.grf   1	
X grid.c                     2	
X input.c                    1	
X main.c                     1	
X output.c                   2	
X patchlevel.h               1	
X psgraph.h                  1	
X psgraph.man                1	
X psgraph.pro                1	
X psgsimp.c                  1	
X psgsimp.man                1	
END_OF_FILE
if test 871 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(2466 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# $Header: Makefile,v 1.4 92/08/04 17:54:59 mogul Locked $
X# $Log:	Makefile,v $
X# Revision 1.4  92/08/04  17:54:59  mogul
X# undo RCS botch
X# 
X# Revision 1.3  1992/07/08  16:51:18  mogul
X# add examples to shar/tar files.
X#
X# Revision 1.2  92/07/08  15:54:17  mogul
X# PROLOG now defined in Makefile
X# 
X# Revision 1.2  92/05/15  14:28:07  mogul
X# PROLOG now defined in Makefile.
X# 
X# Revision 1.1  92/05/14  16:53:33  mogul
X# Initial revision
X# 
X# Revision 1.4  92/03/12  13:44:32  mogul
X# Added psgsimp
X# 
X# Revision 1.3  92/02/21  17:13:41  mogul
X# *** empty log message ***
X# 
X# Revision 1.2  89/01/27  15:53:54  kent
X# Added saber targets and installation.
X# 
X# Revision 1.1  89/01/04  13:57:24  kent
X# Initial revision
X# 
X
XDESTROOT=
X
X# These control where the binaries and manual pages will go
XBINDIR = /usr/local/bin
XMANDIR = /usr/local/man/man1
X
X# This overrides the #define PROLOG in psgraph.h
X# If you change this, you should do a "make clean; make" to
X# ensure that all references are recompiled.
XPROLOGDIR = /usr/local/lib/ps
X
X# Best to leave these two lines alone.
XPROLOGFILE = ${PROLOGDIR}/psgraph.pro
XDEFINES = -DPROLOG=\"${PROLOGFILE}\"
X
XCFLAGS= -O ${DEFINES}
X
XTARGETS = psgraph psgsimp
XOBJS=	main.o grid.o input.o output.o
XSRCS=	main.c grid.c input.c output.c psgsimp.c
X
Xall:	$(TARGETS)
X
Xinstall: $(TARGETS) psgraph.man
X	install -c -s psgraph	  ${DESTROOT}/${BINDIR}/
X	install -c -s psgsimp	  ${DESTROOT}/${BINDIR}/
X	install -c    psgraph.man ${DESTROOT}/${MANDIR}/psgraph.1
X	install -c    psgsimp.man ${DESTROOT}/${MANDIR}/psgsimp.1
X	install -c    psgraph.pro $(DESTROOT)/${PROLOGFILE}
X
Xclean:
X	rm -f *.o a.out ERRS LINT core ,* ${TARGETS} *.BAK *.CKP
X	rm -f psgraph.shar psgraph.tar psgraph.tar.Z
X
Xpsgraph: $(OBJS)
X	cc -o psgraph $(CFLAGS) $(OBJS) -lm
X
Xpsgsimp: psgsimp.o
X	cc -o psgsimp $(CFLAGS) psgsimp.o -lm
X
Xsaber:
X	#load ${CFLAGS} ${SRCS} -lm
X
Xsaber_o:
X	#load ${CFLAGS} ${OBJS} -lm
X
Xlint:	$(SRCS)
X	lint -c $(SRCS) > LINT
X
XFILES =  README $(SRCS) psgraph.h psgraph.man psgsimp.man \
X	psgraph.pro Makefile LICENSE patchlevel.h
X
XEXAMPLES_TAR = examples
X
XEXAMPLES_SHAR = examples examples/*
X
Xpsgraph.shar: $(FILES) $(EXAMPLES_SHAR)
X	rm -f psgraph.shar
X	shar $(FILES) $(EXAMPLES_SHAR) >psgraph.shar
X
Xpsgraph.tar: $(FILES)  $(EXAMPLES_TAR)
X	rm -f psgraph.tar
X	tar cf psgraph.tar $(FILES) $(EXAMPLES_TAR)
X
Xpsgraph.tar.Z: psgraph.tar
X	rm -f psgraph.tar.Z
X	compress psgraph.tar	
X
Xmain.o:	psgraph.h
Xgrid.o:	psgraph.h
Xinput.o:	psgraph.h
Xoutput.o:	psgraph.h
END_OF_FILE
if test 2466 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(1145 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XREADME for: "psgraph" version of 21 February 1992
X
X"Psgraph" takes input files vaguely like those accepted by graph(1),
Xand produces PostScript output.  The manual page explains the rest.
X
XPsgraph was written by Chris Kent of DECWRL (now Chris Kantarjiev
Xof Xerox PARC), based on some code from Bob Brown of NASA RIACS,
Xand has been hacked on by Brian Reid and Jeff Mogul of DECWRL.
X
XPlease obey the part in the LICENSE file that says not to redistribute
Xthis software to anyone, unless you do it for free and include the
XLICENSE file and all copyright notices.
X
XTo install psgraph, you might have to modify Makefile and psgraph.h
Xto reflect where you want to install the files.  In psgraph.h,
Xthe important line is:
X#define PROLOG  "/usr/local/lib/ps/psgraph.pro"
X
XTo obtain another copy of the code (in case someone updates the
Xcode later on):
X        ftp gatekeeper.dec.com
X        user anonymous
X                <give your name when asked for the password>
X        cd pub/DEC
X        type binary
X        get psgraph.tar.Z
Xthen "uncompress psgraph.tar.Z", cd to an empty directory where
Xyou want to put the sources, and "tar xf psgraph.tar".
END_OF_FILE
if test 1145 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test ! -d 'examples' ; then
    echo shar: Creating directory \"'examples'\"
    mkdir 'examples'
fi
if test -f 'examples/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/Makefile'\"
else
echo shar: Extracting \"'examples/Makefile'\" \(612 characters\)
sed "s/^X//" >'examples/Makefile' <<'END_OF_FILE'
X#
X# Makefile to generate PostScript from psgraph examples
X#
X
X# Where to find the psgraph and psgsimp programs
XPSGRAPH = psgraph
XPSGSIMP = psgsimp
X
XPLOTS = rbi.ps rbi2.ps wire-fusing.ps oneconn.ps distribb.ps long.ps \
X	shorter.ps simplecolor.ps
X
X# People like to use different suffixes
X.SUFFIXES: .ps .grf .plot .data
X
X.data.ps:
X	$(PSGRAPH) -P <$*.data >$*.ps
X
X.plot.ps:
X	$(PSGRAPH) -P <$*.plot >$*.ps
X
X.grf.ps:
X	$(PSGRAPH) -P <$*.grf >$*.ps
X
X
Xall: $(PLOTS)
X
Xclean:
X	rm -f $(PLOTS) shorter.plot
X
Xshorter.plot: long.plot Makefile
X	$(PSGSIMP) 0.01 <long.plot |grep -v '^#' >shorter.plot
X	wc long.plot shorter.plot
END_OF_FILE
if test 612 -ne `wc -c <'examples/Makefile'`; then
    echo shar: \"'examples/Makefile'\" unpacked with wrong size!
fi
# end of 'examples/Makefile'
fi
if test -f 'examples/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/README'\"
else
echo shar: Extracting \"'examples/README'\" \(726 characters\)
sed "s/^X//" >'examples/README' <<'END_OF_FILE'
XThis directory contains examples of some input files for "psgraph".
XYou should ignore the scientific content of these examples, since
Xthey may be incorrect or even sheer fabrications.
X
XSome examples might look better when printed on a color PostScript
Xprinter, or viewed using a PostScript previewer on a color display.
X
XType "make" to generate a bunch of .ps files.  (You might have to
Xchange the definitions in the Makefile for PSGRAPH and PSGSIMP).
XSome of these might take a long time to print, even on a fast printer.
X
XThe file shorter.plot is automatically generated from long.plot using
Xpsgsimp, to demonstrate how this program can simplify a graph (making
Xit much faster to print) without removing significant detail.
END_OF_FILE
if test 726 -ne `wc -c <'examples/README'`; then
    echo shar: \"'examples/README'\" unpacked with wrong size!
fi
# end of 'examples/README'
fi
if test -f 'examples/distribb.data' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/distribb.data'\"
else
echo shar: Extracting \"'examples/distribb.data'\" \(5498 characters\)
sed "s/^X//" >'examples/distribb.data' <<'END_OF_FILE'
Xx log
Xx intervals 10
X# Plot generated by plotsubs.c
Xx size 6
Xy size 4
Xgrid 2
Xmarker off
Xtransparent
Xline solid
Xy label "Number of connections"
Xx label "Total bytes transferred"
Xbreak
Xline solid
Xlinewidth 3
X1.071286 0
X1.071286 22
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X2.132844 0
X2.132844 2
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X4.873306 0
X4.873306 5
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X7.366410 0
X7.366410 7
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X8.454086 0
X8.454086 1
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X9.702361 0
X9.702361 1
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X12.779060 0
X12.779060 2
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X14.665932 0
X14.665932 14
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X19.316622 0
X19.316622 2
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X22.168787 0
X22.168787 2
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X25.442084 0
X25.442084 4
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X29.198694 0
X29.198694 15
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X33.509981 0
X33.509981 20
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X38.457844 0
X38.457844 22
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X44.136276 0
X44.136276 66
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X50.653147 0
X50.653147 17
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X58.132257 0
X58.132257 3
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X66.715683 0
X66.715683 6
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X76.566482 0
X76.566482 12
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X87.871784 0
X87.871784 22
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X100.846353 0
X100.846353 23
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X115.736661 0
X115.736661 25
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X132.825574 0
X132.825574 14
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X152.437723 0
X152.437723 6
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X174.945672 0
X174.945672 8
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X200.776998 0
X200.776998 16
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X230.422407 0
X230.422407 11
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X264.445061 0
X264.445061 13
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X303.491277 0
X303.491277 63
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X348.302799 0
X348.302799 436
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X399.730896 0
X399.730896 46
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X458.752526 0
X458.752526 14
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X526.488902 0
X526.488902 29
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X604.226785 0
X604.226785 39
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X693.442931 0
X693.442931 35
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X795.832145 0
X795.832145 41
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X913.339477 0
X913.339477 37
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X1048.197167 0
X1048.197167 65
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X1202.967055 0
X1202.967055 42
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X1380.589245 0
X1380.589245 57
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X1584.437957 0
X1584.437957 53
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X1818.385627 0
X1818.385627 36
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X2086.876469 0
X2086.876469 24
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X2395.010899 0
X2395.010899 45
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X2748.642430 0
X2748.642430 25
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X3154.488862 0
X3154.488862 20
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X3620.259905 0
X3620.259905 26
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X4154.803632 0
X4154.803632 6
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X4768.274563 0
X4768.274563 18
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X5472.326571 0
X5472.326571 22
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X6280.334259 0
X6280.334259 10
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X7207.647040 0
X7207.647040 8
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X8271.880716 0
X8271.880716 16
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X9493.252126 0
X9493.252126 1
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X10894.963191 0
X10894.963191 11
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X12503.641678 0
X12503.641678 5
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X14349.847031 0
X14349.847031 5
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X16468.650904 0
X16468.650904 4
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X18900.303398 0
X18900.303398 3
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X21690.997678 0
X21690.997678 3
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X24893.747491 0
X24893.747491 3
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X28569.394240 0
X28569.394240 3
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X32787.762772 0
X32787.762772 7
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X37628.987810 0
X37628.987810 12
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X43185.036242 0
X43185.036242 11
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X49561.454182 0
X49561.454182 5
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X56879.371985 0
X56879.371985 2
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X65277.805319 0
X65277.805319 24
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X74916.295988 0
X74916.295988 4
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X85977.942689 0
X85977.942689 6
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X98672.879265 0
X98672.879265 44
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X113242.266540 0
X113242.266540 3
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X129962.873553 0
X129962.873553 7
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X149152.335238 0
X149152.335238 6
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X171175.186412 0
X171175.186412 6
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X196449.786700 0
X196449.786700 5
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X225456.267951 0
X225456.267951 5
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X258745.655122 0
X258745.655122 3
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X340796.063816 0
X340796.063816 1
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X391115.765362 0
X391115.765362 3
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X448865.342521 0
X448865.342521 1
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X591204.292270 0
X591204.292270 1
Xbreak
Xbreak
Xline solid
Xlinewidth 3
X893654.887257 0
X893654.887257 1
Xbreak
X# NOTE "1098 connections sending zero bytes"
X10 460 "(1098 connections sending zero bytes)"
END_OF_FILE
if test 5498 -ne `wc -c <'examples/distribb.data'`; then
    echo shar: \"'examples/distribb.data'\" unpacked with wrong size!
fi
# end of 'examples/distribb.data'
fi
if test -f 'examples/oneconn.data' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/oneconn.data'\"
else
echo shar: Extracting \"'examples/oneconn.data'\" \(6580 characters\)
sed "s/^X//" >'examples/oneconn.data' <<'END_OF_FILE'
X# Plot generated by plotsubs.c
Xx size 6
Xy size 4
Xgrid 2
Xmarker off
Xtransparent
Xline solid
Xy label "SEQ number (bytes)"
Xx label "time (seconds since start of connection)"
X# line starts
Xbreak
Xcolor black
X0.000000 0.000000
X2.281259 1.000000
X5.630866 1.000000
X8.591328 26.000000
X11.324375 68.000000
X14.007842 104.000000
X14.045660 104.000000
X16.797053 110.000000
X27.143880 110.000000
X27.145650 1570.000000
X27.147066 3030.000000
X27.148296 4490.000000
X27.150135 5950.000000
X27.151365 7410.000000
X27.152595 8870.000000
X27.154005 10330.000000
X27.155235 11790.000000
X27.156996 13250.000000
X27.158226 14710.000000
X27.158635 16170.000000
X31.314444 16494.000000
X31.316334 17954.000000
X31.317564 19414.000000
X31.319414 20874.000000
X31.320644 22334.000000
X31.322923 23794.000000
X31.324153 25254.000000
X31.326110 26714.000000
X31.327704 28174.000000
X31.328934 29634.000000
X31.331024 31094.000000
X31.331345 32554.000000
X35.961998 32878.000000
X35.961998 32878.000000
Xbreak
Xcolor orange
Xmarker x
X35.961998 32878.000000
Xbreak
Xmarker off
Xcolor black
X35.961998 32878.000000
X35.964008 34338.000000
X35.965238 35798.000000
X35.965238 35798.000000
Xbreak
Xcolor orange
Xmarker x
X35.965238 35798.000000
Xbreak
Xmarker off
Xcolor black
X35.965238 35798.000000
X35.967161 37258.000000
X35.967161 37258.000000
Xbreak
Xcolor orange
Xmarker x
X35.967161 37258.000000
Xbreak
Xmarker off
Xcolor black
X35.967161 37258.000000
X35.968391 38718.000000
X35.968391 38718.000000
Xbreak
Xcolor orange
Xmarker x
X35.968391 38718.000000
Xbreak
Xmarker off
Xcolor black
X35.968391 38718.000000
X35.969621 40178.000000
X35.969621 40178.000000
Xbreak
Xcolor orange
Xmarker x
X35.969621 40178.000000
Xbreak
Xmarker off
Xcolor black
X35.969621 40178.000000
X35.970851 41638.000000
X35.970851 41638.000000
Xbreak
Xcolor orange
Xmarker x
X35.970851 41638.000000
Xbreak
Xmarker off
Xcolor black
X35.970851 41638.000000
X35.972523 43098.000000
X35.972523 43098.000000
Xbreak
Xcolor orange
Xmarker x
X35.972523 43098.000000
Xbreak
Xmarker off
Xcolor black
X35.972523 43098.000000
X35.974186 44558.000000
X35.974186 44558.000000
Xbreak
Xcolor orange
Xmarker x
X35.974186 44558.000000
Xbreak
Xmarker off
Xcolor black
X35.974186 44558.000000
X35.975416 46018.000000
X35.975416 46018.000000
Xbreak
Xcolor orange
Xmarker x
X35.975416 46018.000000
Xbreak
Xmarker off
Xcolor black
X35.975416 46018.000000
X35.976646 47478.000000
X35.976646 47478.000000
Xbreak
Xcolor orange
Xmarker x
X35.976646 47478.000000
Xbreak
Xmarker off
Xcolor black
X35.976646 47478.000000
X35.976967 48938.000000
X35.976967 48938.000000
Xbreak
Xcolor orange
Xmarker x
X35.976967 48938.000000
Xbreak
Xmarker off
Xcolor black
X35.976967 48938.000000
X39.504179 32878.000000
X39.542276 35798.000000
X39.544144 37258.000000
X39.555030 38718.000000
X39.556906 40178.000000
X39.562139 41638.000000
X39.564310 43098.000000
X39.565540 44558.000000
X39.568048 46018.000000
X39.569744 47478.000000
X39.570174 48938.000000
X41.920787 49262.000000
X41.920787 49262.000000
Xbreak
Xcolor orange
Xmarker x
X41.920787 49262.000000
Xbreak
Xmarker off
Xcolor black
X41.920787 49262.000000
X41.922909 50722.000000
X41.924139 52182.000000
X41.925879 53642.000000
X41.927165 55102.000000
X41.928395 56562.000000
X42.008235 49262.000000
X45.069602 58022.000000
X45.072649 59482.000000
X45.074249 60942.000000
X45.152496 62402.000000
X47.455308 63862.000000
X50.642708 65322.000000
X50.651306 65646.000000
X50.653039 67106.000000
X50.654904 68566.000000
X50.657009 70026.000000
X53.272351 71486.000000
X53.280078 72946.000000
X53.312317 74406.000000
X53.314369 75866.000000
X53.326965 77326.000000
X56.005093 78786.000000
X56.005093 78786.000000
Xbreak
Xcolor orange
Xmarker x
X56.005093 78786.000000
Xbreak
Xmarker off
Xcolor black
X56.005093 78786.000000
X56.007017 80246.000000
X60.011517 78786.000000
X60.011517 78786.000000
Xbreak
Xcolor orange
Xmarker x
X60.011517 78786.000000
Xbreak
Xmarker off
Xcolor black
X60.011517 78786.000000
X68.011686 78786.000000
X71.152442 81706.000000
X77.783339 81941.000000
X77.783339 81941.000000
Xbreak
Xcolor orange
Xmarker x
X77.783339 81941.000000
Xbreak
Xmarker off
Xcolor black
X77.783339 81941.000000
X84.016983 81941.000000
X86.738456 81947.000000
X97.951407 81947.000000
X97.953078 81947.000000
X97.953078 81947.000000
Xbreak
Xcolor black
X97.953078 81947.000000
Xbreak
Xcolor black
Xline dotted
X# line starts
Xbreak
Xcolor black
X0.000000 0.000000
X5.624398 0.000000
X8.576060 25.000000
X11.317558 67.000000
X11.321031 67.000000
X13.941923 103.000000
X16.363992 109.000000
X16.766290 109.000000
X30.143843 1569.000000
X30.154085 4489.000000
X30.213839 5949.000000
X30.220039 8869.000000
X30.230332 10329.000000
X30.320517 13249.000000
X31.242838 14709.000000
X31.308561 16493.000000
X34.885817 19413.000000
Xbreak
Xcolor blue
Xmarker plus
X34.885817 19413.000000
Xbreak
Xmarker off
Xcolor black
X34.885817 19413.000000
Xline dashed
X34.885817 19413.000000
Xbreak
Xcolor red
X34.885817 19413.000000
X35.052793 22333.000000
X35.072283 25253.000000
X35.075551 28173.000000
X35.077967 31093.000000
Xbreak
Xcolor blue
Xmarker plus
X35.077967 31093.000000
Xbreak
Xmarker off
Xcolor red
X35.077967 31093.000000
Xline dotted
X35.077967 31093.000000
Xbreak
Xcolor black
X35.077967 31093.000000
X35.956033 32877.000000
Xbreak
Xcolor blue
Xmarker plus
X35.956033 32877.000000
Xbreak
Xmarker off
Xcolor black
X35.956033 32877.000000
Xline dashed
X35.956033 32877.000000
Xbreak
Xcolor red
X35.956033 32877.000000
X39.538765 35797.000000
X39.551804 37257.000000
X39.558918 40177.000000
X39.565607 43097.000000
X39.574424 46017.000000
Xbreak
Xcolor blue
Xmarker plus
X39.574424 46017.000000
Xbreak
Xmarker off
Xcolor red
X39.574424 46017.000000
Xline dotted
X39.574424 46017.000000
Xbreak
Xcolor black
X39.574424 46017.000000
X41.914260 49261.000000
X41.985781 49261.000000
X41.992684 49261.000000
X42.004842 49261.000000
X42.335840 49261.000000
X42.896973 49261.000000
X42.899511 49261.000000
X42.905829 49261.000000
X42.977312 49261.000000
X43.096731 49261.000000
X45.061872 52181.000000
X45.066301 55101.000000
X45.069840 56561.000000
X45.148837 58021.000000
X45.400826 58021.000000
X47.451358 59481.000000
X47.658570 60941.000000
X47.984608 63861.000000
X50.640983 65321.000000
X53.267567 65645.000000
X53.275933 67105.000000
X53.308119 70025.000000
X53.322972 71485.000000
X56.000702 74405.000000
X56.005353 75865.000000
X56.162186 78785.000000
X71.150508 81705.000000
X77.780504 81940.000000
X86.628141 81946.000000
X97.950134 81946.000000
X99.722784 81947.000000
X99.722784 81947.000000
X# LABEL "1285"
Xbreak
Xcolor black
X99.722784 81947.000000
Xbreak
Xcolor black
Xline longdashed
X# line starts
Xbreak
Xcolor green
X0.000000 0.000000
X3.018948 81947.000000
Xbreak
Xcolor green
X3.018948 81947.000000
Xbreak
Xcolor green
X3.018948 81947.000000 "median ACK-bw = 27144 bytes/sec"
X# LABEL "median ACK-bw = 27144 bytes/sec"
Xbreak
Xcolor green
X3.018948 81947.000000
END_OF_FILE
if test 6580 -ne `wc -c <'examples/oneconn.data'`; then
    echo shar: \"'examples/oneconn.data'\" unpacked with wrong size!
fi
# end of 'examples/oneconn.data'
fi
if test -f 'examples/rbi.plot' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/rbi.plot'\"
else
echo shar: Extracting \"'examples/rbi.plot'\" \(177 characters\)
sed "s/^X//" >'examples/rbi.plot' <<'END_OF_FILE'
Xline off
Xgrid halftick
Xrangeframe
Xmarker filledcircle
Xmarkerscale 0.3
Xx min 0
Xy min 0
Xheight 6
Xwidth 6
Xtitle "RBI rate year-to-year comparison (corr. = 0.586)"
X
Xinclude rbi.txt
END_OF_FILE
if test 177 -ne `wc -c <'examples/rbi.plot'`; then
    echo shar: \"'examples/rbi.plot'\" unpacked with wrong size!
fi
# end of 'examples/rbi.plot'
fi
if test -f 'examples/rbi2.plot' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/rbi2.plot'\"
else
echo shar: Extracting \"'examples/rbi2.plot'\" \(188 characters\)
sed "s/^X//" >'examples/rbi2.plot' <<'END_OF_FILE'
Xline off
Xgrid halftick
Xrangeframe
Xmarker filledcircle
Xmarkerscale 0.3
Xx min 0 
Xy min 0
Xdataticks
Xheight 6
Xwidth 6
Xtitle "RBI rate year-to-year comparison (corr. = 0.586)"
X
Xinclude rbi.txt
END_OF_FILE
if test 188 -ne `wc -c <'examples/rbi2.plot'`; then
    echo shar: \"'examples/rbi2.plot'\" unpacked with wrong size!
fi
# end of 'examples/rbi2.plot'
fi
if test -f 'examples/simplecolor.data' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/simplecolor.data'\"
else
echo shar: Extracting \"'examples/simplecolor.data'\" \(273 characters\)
sed "s/^X//" >'examples/simplecolor.data' <<'END_OF_FILE'
Xtitle "Various color changes"
Xx max 8
Xy max 8
X0 0
X1 1 "Black text"
Xcolor red
X1 1
X2 2 "Red text"
Xmarker diamond
X3 3
X4 4
Xmarkergray 25
X4.5 4.5
X5 5
Xcolor green
X5 5 "Green text next to a gray marker"
Xcolor red
Xmarkergray 25
X5 5
X6 6
Xcolor blue
X6 6
Xmarkergray 0
X7 7 "Blue text"
X
END_OF_FILE
if test 273 -ne `wc -c <'examples/simplecolor.data'`; then
    echo shar: \"'examples/simplecolor.data'\" unpacked with wrong size!
fi
# end of 'examples/simplecolor.data'
fi
if test -f 'examples/wire-fusing.grf' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/wire-fusing.grf'\"
else
echo shar: Extracting \"'examples/wire-fusing.grf'\" \(2715 characters\)
sed "s/^X//" >'examples/wire-fusing.grf' <<'END_OF_FILE'
X# to view: 
X#   psgraph -P wire-fusing.grf > wire-fusing.ps
X# for scribe: 
X#   psgraph wire-fusing.grf > wire-fusing.ps
X# titlefont "Times-Roman15"
X# title "Effect of wire length on burnout current for gold bondwire arrays"
Xwidth 3.4
Xheight 3.4
Xcenter 6.8
Xx log
Xx font "Times-Roman12"
Xx label "Bondwire Length (mm)"
Xy log
Xy font "Times-Roman12"
Xy label "Fusing Current per Wire (A)"
Xfont "Times-Roman11"
Xmarkerscale 0.5
Xgrid 2
Xbreak
Xbreak
X# 
X# set bounds of the graph
X# marker none
X# 0.28 0.11
X# 12.7 3.3
X# break
X#
Xmarker plus
X6 6.7 "isolated wire"
X# 2 mil wire
Xbreak
X# spline
X# line solid
Xline none
X# 4.32	1.72
X4.70	1.62
X5.08	1.55
X# 5.72	1.52
X# 6.22	1.40
X6.60	1.30
X6.99	1.29
X7.11	1.37
X14.63	1.12
X16.48	1.12
X3.81	1.85
X# 4.32	1.64
X4.88	1.59
X4.88	1.58
X5.28	1.625
X# 5.97	1.440
X6.35	1.460
X6.48	1.460
X6.99	1.39
X7.24	1.430
X3.81	1.885
X4.83	1.72
X# 5.92	1.590
X3.81	1.82
X# 4.52	1.700
X5.26	1.562
X# 5.72	1.571
X6.96	1.390
X# 4.50	1.68
X5.28	1.58
X# 5.92	1.47
X7.75	1.27
X3.53	2.42
X2.92	2.62
X2.59	2.87
X2.31	3.38
X2.24	3.45
X2.01	3.53
X1.91	3.85
X3.66	2.28
X2.77	2.98
X2.49	3.00
X2.44	2.98
X1.98	3.73
X1.78	4.37
X1.37	4.92
X1.27	5.94
X1.12	6.30
X1.73	4.35
X1.37	5.05
X1.17	6.53
Xbreak
X#
X#
Xmarker plus
X# "isolated wire"
X# 1 mil wire
Xbreak
X# spline
X# line solid
X1.85	1.15
X3.23	.9
X1.24	1.66
X1.19	1.71
X1.12	1.62
X11.06   .573
X9.62    .590
X9.25    .595
X8.93    .600
X8.20    .615
X7.47   .625
X6.75   .645
X6.37   .655
X5.67   .686
X4.93   .745
X4.25   .771
X3.91   .789
Xbreak
X#
X#
Xmarker circle
X6 5.193 "3-wire group, 356 micron pitch"
X# 2 mil wire
Xbreak
X# spline
X# line solid
X4.22	1.58
X5.61	1.43
X5.92	1.38
Xbreak
X#
X#
Xmarker down
X6 4.026 "3-wire group, 178 micron pitch"
X# 2 mil wire
Xbreak
X# spline
X# line solid
X4.88	1.40
X6.05	1.23
X3.95	1.66
X4.83	1.40
X5.61	1.27
X6.27	1.10
X7.04	1.20
Xbreak
X#
X#
Xmarker down
X# "3-wire group, 178 micron pitch"
X# 1 mil wire
Xbreak
X# spline
X# line solid
X11.41   .480
X7.12    .505
X5.29	.560
X4.59	.615
Xbreak
X#
X#
Xmarker square
X6 3.121 "8-wire group, 178 micron pitch"
X# 2 mil wire
Xbreak
X# spline
X# line solid
X1.12	3.10
X1.60	3.09
X2.08	2.58
X2.59	2.35
X2.59	2.21
X3.02	2.08
X3.05	2.08
X3.07	1.98
X3.40	1.96
X3.89	1.83
X4.3    1.74
X# 4.47	1.64
X# 4.52	1.63
X# 5.33	1.41
X# 6.02	1.41 
Xbreak
X#
X#
Xmarker down
X# "8-wire group, 7 mil pitch"
X# 1 mil wire
Xbreak
X# spline
X# line solid
X1.04	1.718
X1.08	1.806
X1.58	1.41
X2.00	1.106
X2.60 	0.881
X2.67	0.750  
X# 2.61	0.688
X3.81	0.638
Xbreak
X#
X#
Xbreak
Xmarker none
Xline dotted
Xspline
X# 2 mil wire
X1.02	9.53
X12.9    .754
Xbreak
X# 1 mil wire
X1.02	2.38
X6.83    .356
Xbreak
X#
X#
Xbreak
Xmarker none
Xline dotted
Xspline
X# I = const
X# 2 mil wire
X17.75	1.067
X4.31	1.067
Xbreak
X# 1 mil wire
X17.75	.533
X2.16	.533
Xbreak
Xline none
Xmarker none
X1.2  .533 "Eqn (11)"
X6.0 .3 "Eqn (13)"
X18  1.2 "50.8 micron wire"
X18  .6 "25.4 micron wire"
Xbreak
X#
END_OF_FILE
if test 2715 -ne `wc -c <'examples/wire-fusing.grf'`; then
    echo shar: \"'examples/wire-fusing.grf'\" unpacked with wrong size!
fi
# end of 'examples/wire-fusing.grf'
fi
if test -f 'input.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'input.c'\"
else
echo shar: Extracting \"'input.c'\" \(11313 characters\)
sed "s/^X//" >'input.c' <<'END_OF_FILE'
X/* $Header: input.c,v 1.9 92/08/04 17:55:05 mogul Exp $ */
X
X/*
X *               Copyright 1989, 1992 Digital Equipment Corporation
X *                          All Rights Reserved
X * 
X * 
X * Permission to use, copy, and modify this software and its documentation
X * is hereby granted only under the following terms and conditions.  Both
X * the above copyright notice and this permission notice must appear in
X * all copies of the software, derivative works or modified versions, and
X * any portions threof, and both notices must appear in supporting
X * documentation.
X * 
X * Users of this software agree to the terms and conditions set forth
X * herein, and hereby grant back to Digital a non-exclusive, unrestricted,
X * royalty-free right and license under any changes, enhancements or
X * extensions made to the core functions of the software, including but
X * not limited to those affording compatibility with other hardware or
X * software environments, but excluding applications which incorporate
X * this software.  Users further agree to use their best efforts to return
X * to Digital any such changes, enhancements or extensions that they make
X * and inform Digital of noteworthy uses of this software.  Correspondence
X * should be provided to Digital at:
X * 
X *                       Director of Licensing
X *                       Western Research Laboratory
X *                       Digital Equipment Corporation
X *                       250 University Avenue
X *                       Palo Alto, California  94301  
X * 
X * This software may be distributed (but not offered for sale or
X * transferred for compensation) to third parties, provided such third
X * parties agree to abide by the terms and conditions of this notice.
X * 
X * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS
X * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
X * WARRANTIES OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL
X * EQUIPMENT CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
X * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
X * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X */
X
X/* 
X * input.c - Read and parse command and data input
X * 
X * Author:	Christopher A. Kent
X * 		Western Research Laboratory
X * 		Digital Equipment Corporation
X * Date:	Wed Jan  4 1989
X */
X
X/*
X * $Log:	input.c,v $
X * Revision 1.9  92/08/04  17:55:05  mogul
X * undo RCS botch
X * 
X * Revision 1.8  1992/04/03  23:55:47  kent
X * Fixed a problem where "include" reset the world.
X *
X * Revision 1.7  1992/04/01  23:27:34  kent
X * Added datalabel verb, fixed a bug in handling blank input lines.
X *
X * Revision 1.6  1992/03/31  23:13:12  kent
X * Added "dataticks" verb.
X *
X * Revision 1.5  1992/03/31  02:31:34  kent
X * Added markergray verb and fixed inverted gray values.
X *
X * Revision 1.4  1992/03/31  00:21:29  kent
X * Added "include" verb
X *
X * Revision 1.3  1992/03/31  00:07:39  kent
X * Added markerscale verb.
X *
X * Revision 1.2  1992/03/30  23:33:47  kent
X * Added halfopen, halfticks grid styles, range frames, and gray.
X *
X * Revision 1.1  1992/03/20  21:25:43  kent
X * Initial revision
X *
X * Revision 1.7  92/02/21  17:13:21  mogul
X * Added Digital license info
X * 
X * Revision 1.6  90/12/11  20:41:26  reid
X * Added code to parse input for new "color" and "linewidth" commands
X * 
X * Revision 1.5  89/01/10  18:19:57  kent
X * Moved marker code to prolog, added error checking and messages.
X * 
X * Revision 1.4  89/01/09  22:18:41  kent
X * Added log scales.
X * 
X * Revision 1.3  89/01/04  17:30:27  kent
X * Made command line arguments override compiled-in defaults for
X * all plots in a run, not just the first one. 
X * 
X * Revision 1.2  89/01/04  15:22:03  kent
X * Massive renaming. No functional change.
X * 
X * Revision 1.1  89/01/04  13:57:49  kent
X * Initial revision
X * 
X */
X
Xstatic char rcs_ident[] = "$Header: input.c,v 1.9 92/08/04 17:55:05 mogul Exp $";
X
X#include <stdio.h>
X
X#include "psgraph.h"
X
X/*
X * Read the input consisting of both numeric and text data.  An array, Token[*]
X * is built by this routine containing both numeric (type==POINT) and non-numeric
X * data.  Only the commands that take affect at a point relative to their
X * appearence in the input are placed in the Token array.  All others just
X * affect global data.
X */
X
Xdoinput(s)
X    FILE *s;
X{
X	char *argv[ARGC];
X	int argc;
X	char buf[BUFSIZ], cmd[BUFSIZ];
X
X	for(;;) {
X		if ( NumTokens >= SizeofToken ) {
X			SizeofToken += TOKENINC;
X			Token = (token_t *)realloc((char *)Token,(unsigned)(SizeofToken*sizeof(token_t)));
X		}
X		if( fgets(buf, BUFSIZ, s) == NULL )
X			break;
X		if ( strlen(buf)==0 || *buf=='#' || buf[0]=='\n')
X			continue;
X		strcpy(cmd,buf);
X		parse(cmd,&argc,argv);
X#ifdef DEBUG
X		if ( Debug ) {
X			fprintf(stderr,"argc=%d, ",argc);
X			fprintf(stderr,"input=%s\n",buf);
X		}
X#endif
X		if ( isalpha(argv[0][0]) ) {
X			if ( docmd(argc,argv) )
X				fprintf(stderr,"Error in input: %s\n",buf);
X		} else {
X			Token[NumTokens].type = POINT;
X			Token[NumTokens].xval = atof(argv[0]);
X			Token[NumTokens].yval = 0.0;
X			if ( argc > 1 ) Token[NumTokens].yval = atof(argv[1]);
X			if ( argc > 2 )
X				Token[NumTokens].label = newstr(argv[2]);
X			else
X				Token[NumTokens].label = NULL;
X			NumTokens++;
X		}
X	}
X}
X
Xdocmd(argc,argv)
Xint argc;
Xchar *argv[];
X{
X    	FILE *f;
X	
X	if ( strcmp(argv[0],"break")==0 ) {
X		Token[NumTokens].type = BREAK;
X		NumTokens++;
X	} else if ( strcmp(argv[0],"include")==0 ) {
X	    	if ( argc > 1 ) {
X		    f = fopen(argv[1], "r");
X		    if (f != NULL)
X			doinput(f);
X		}
X	} else if ( strcmp(argv[0],"line")==0 ) {
X		Token[NumTokens].type = LINETYPE;
X		if ( argc > 1 )
X			Token[NumTokens].label = newstr(argv[1]);
X		else
X			Token[NumTokens].label = NULL;
X		NumTokens++;
X	} else if ( strcmp(argv[0],"color")==0 ) {
X		Token[NumTokens].type = LINECOLOR;
X		if ( argc > 1 )
X			Token[NumTokens].label = newstr(argv[1]);
X		else
X			Token[NumTokens].label = NULL;
X		NumTokens++;
X	} else if ( strcmp(argv[0],"linewidth")==0 ) {
X		Token[NumTokens].type = LINEWIDTH;
X		if ( argc > 1 )
X			Token[NumTokens].label = newstr(argv[1]);
X		else
X			Token[NumTokens].label = "0.6";
X		NumTokens++;
X	} else if ( strcmp(argv[0],"spline")==0 ) {
X		Token[NumTokens].type = SPLINE;
X		NumTokens++;
X	} else if ( strcmp(argv[0],"label")==0 )
X		DoAxisLabels = TRUE;
X	else if ( strcmp(argv[0],"nolabel")==0 )
X		DoAxisLabels = FALSE;
X	else if ( strcmp(argv[0],"transparent")==0 ) {
X		Token[NumTokens].type = TRANS;
X		Token[NumTokens].ival = TRUE;
X		NumTokens++;
X	} else if ( strcmp(argv[0],"notransparent")==0 ) {
X		Token[NumTokens].type = TRANS;
X		Token[NumTokens].ival = FALSE;
X		NumTokens++;
X	} else if ( strcmp(argv[0],"grid")==0 ) {
X		Xaxis.gridtype = Yaxis.gridtype = gridval(argv[1]);
X		if (Xaxis.gridtype == HALFOPEN) {
X		    Xaxis.gridtype = Yaxis.gridtype = OPEN;
X		    Xaxis.halfgrid = Yaxis.halfgrid = TRUE;
X		}
X		if (Xaxis.gridtype == HALFTICKS) {
X		    Xaxis.gridtype = Yaxis.gridtype = TICKS;
X		    Xaxis.halfgrid = Yaxis.halfgrid = TRUE;
X		}
X	} else if ( strncmp(argv[0],"datatick",8)==0 ) {
X	    	Xaxis.datatick = Yaxis.datatick = TRUE;
X	} else if ( strncmp(argv[0],"datalabel",9)==0 ) {
X	    	Xaxis.datalabel = Yaxis.datalabel = TRUE;
X	} else if ( strcmp(argv[0],"tickgray")==0 )
X		Xaxis.tickgray = Yaxis.tickgray = 1.0 - atof(argv[1])/100.0;
X	else if ( strcmp(argv[0],"axisgray")==0 )
X		Xaxis.axisgray = Yaxis.axisgray = 1.0 - atof(argv[1])/100.0;
X	else if ( strcmp(argv[0],"title")==0 ) {
X	  	if (argc > 1) 
X			Title.title = newstr(argv[1]);
X		else 
X			Title.title = "";
X	} else if ( strcmp(argv[0],"titlefont")==0 )
X		Title.font = newstr(argv[1]);
X	else if ( strncmp(argv[0],"tick", 4)==0 ) {
X		TickLen = Tick2Len = atof(argv[1]);
X		if ( argc > 2 )
X			Tick2Len = atof(argv[2]);
X	} else if ( strcmp(argv[0], "clip")==0 ) {
X		if ( argc > 1 )
X			ClipDist = atof(argv[1]);
X	} else if ( strcmp(argv[0],"width")==0 )
X		Xaxis.size = atof(argv[1]);
X	else if ( strcmp(argv[0],"height")==0 )
X		Yaxis.size = atof(argv[1]);
X	else if ( strcmp(argv[0],"rangeframe")==0 )
X	    	Xaxis.rangeframe = Yaxis.rangeframe = TRUE;
X	else if ( strcmp(argv[0],"center")==0 )
X		Xcenter = atof(argv[1]);
X	else if ( strcmp(argv[0],"marker")==0 ) {
X		if ( argc > 1 ) {
X			Token[NumTokens].type = MARKER;
X			Token[NumTokens].label = newstr(argv[1]);
X			NumTokens++;
X		}
X	} else if ( strcmp(argv[0],"markerscale")==0 ) {
X	    	if ( argc > 1 ) {
X			Token[NumTokens].type = MARKERSCALE;
X			Token[NumTokens].val[0] = atof(argv[1]);
X			NumTokens++;
X		}
X	} else if ( strcmp(argv[0],"markergray")==0 ) {
X	    	if ( argc > 1 ) {
X			Token[NumTokens].type = MARKERGRAY;
X			Token[NumTokens].val[0] = 1.0 - atof(argv[1])/100.0;
X			NumTokens++;
X		}
X	} else if ( strcmp(argv[0],"x")==0 )
X		return domods(argc, argv, &Xaxis);
X	else if ( strcmp(argv[0],"y")==0 )
X		return domods(argc, argv, &Yaxis);
X	else if ( strcmp(argv[0],"font")==0 ) {
X		Token[NumTokens].type = FONT;
X		if (argc > 1)
X			Token[NumTokens].label = newstr(argv[1]);
X		else
X			Token[NumTokens].label = NULL;
X		NumTokens++;
X	} else
X		return TRUE;
X	return FALSE;
X}
X/*
X * domods - parse and handle input lines for making modifications to
X * x & y argument structure.
X *
X * The input lines handled by this module are
X *
X *	x options
X *
X * where "options" is one or more of the following
X *
X *	intervals N
X *	log
X *	min N
X *	max N
X *	rangeframe
X *	step N
X *	tick N
X *	size N
X *	offset N
X *	label "foo"
X *	grid {none,open,ticks,full,halfopen,halfticks}
X *	words
X *	font "foo"
X */
X
Xdomods(argc, argv, p)
Xint argc;
Xchar *argv[];
Xaxis_t *p;
X{
X	int arg;
X	for ( arg=1 ; arg<argc ; arg++ ) {
X		if (strcmp(argv[arg], "intervals") == 0)
X			p->intervals = atoi(argv[++arg]);
X		else if ( strcmp(argv[arg],"log")==0 )
X			p->tform = LOG10;
X		else if ( strcmp(argv[arg],"min")==0 ) {
X			p->minflag = TRUE;
X			p->gmin = atof(argv[++arg]);
X		} else if ( strcmp(argv[arg],"max")==0 ) {
X			p->maxflag = TRUE;
X			p->gmax = atof(argv[++arg]);
X		} else if ( strcmp(argv[arg],"step")==0 ) {
X			p->distf = TRUE;
X			p->dist = atof(argv[++arg]);
X		} else if ( strncmp(argv[arg],"tick",4)==0 ) {
X			p->tickflag = TRUE;
X			p->tick = atof(argv[++arg]);
X		} else if ( strcmp(argv[arg],"rangeframe")==0 ) {
X		    	p->rangeframe = TRUE;
X		} else if ( strcmp(argv[arg],"offset")==0 ) {
X			p->offset = atof(argv[++arg]);
X		} else if ( strcmp(argv[arg],"label")== 0 ) {
X			p->label = newstr(argv[++arg]);
X		} else if ( strcmp(argv[arg],"font")== 0 ) {
X			p->font = newstr(argv[++arg]);
X		} else if ( strcmp(argv[arg],"size")== 0 ) {
X			p->size = atof(argv[++arg]);
X		} else if ( strcmp(argv[arg],"grid")==0 ) {
X			p->gridtype = gridval(argv[++arg]);
X			if (p->gridtype == HALFOPEN) { /* hack hack */
X			    p->gridtype = OPEN;
X			    p->halfgrid = TRUE;
X			}
X			if (p->gridtype == HALFTICKS) {
X			    p->gridtype = TICKS;
X			    p->halfgrid = TRUE;
X			}
X		} else if ( strncmp(argv[0],"datatick",8)==0 ) {
X		    	p->datatick = TRUE;
X		} else if ( strncmp(argv[0],"datalabel",9)==0 ) {
X		    	p->datalabel = TRUE;
X		} else if ( strcmp(argv[0],"tickgray")==0 )
X		    	p->tickgray =  1.0 - atof(argv[++arg])/100.0;
X		else if ( strcmp(argv[0],"axisgray")==0 )
X		    	p->axisgray = 1.0 - atof(argv[++arg])/100.0;
X		else
X			return TRUE;
X	}
X	return FALSE;
X}
X
END_OF_FILE
if test 11313 -ne `wc -c <'input.c'`; then
    echo shar: \"'input.c'\" unpacked with wrong size!
fi
# end of 'input.c'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
echo shar: Extracting \"'main.c'\" \(15465 characters\)
sed "s/^X//" >'main.c' <<'END_OF_FILE'
X/* $Header: main.c,v 1.9 92/08/04 17:55:08 mogul Exp $ */
X/*
X *               Copyright 1989, 1992 Digital Equipment Corporation
X *                          All Rights Reserved
X * 
X * 
X * Permission to use, copy, and modify this software and its documentation
X * is hereby granted only under the following terms and conditions.  Both
X * the above copyright notice and this permission notice must appear in
X * all copies of the software, derivative works or modified versions, and
X * any portions threof, and both notices must appear in supporting
X * documentation.
X * 
X * Users of this software agree to the terms and conditions set forth
X * herein, and hereby grant back to Digital a non-exclusive, unrestricted,
X * royalty-free right and license under any changes, enhancements or
X * extensions made to the core functions of the software, including but
X * not limited to those affording compatibility with other hardware or
X * software environments, but excluding applications which incorporate
X * this software.  Users further agree to use their best efforts to return
X * to Digital any such changes, enhancements or extensions that they make
X * and inform Digital of noteworthy uses of this software.  Correspondence
X * should be provided to Digital at:
X * 
X *                       Director of Licensing
X *                       Western Research Laboratory
X *                       Digital Equipment Corporation
X *                       250 University Avenue
X *                       Palo Alto, California  94301  
X * 
X * This software may be distributed (but not offered for sale or
X * transferred for compensation) to third parties, provided such third
X * parties agree to abide by the terms and conditions of this notice.
X * 
X * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS
X * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
X * WARRANTIES OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL
X * EQUIPMENT CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
X * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
X * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X */
X
X/* 
X * main.c - produce PostScript graphs
X * 
X * Author:	Christopher A. Kent
X * 		Western Research Laboratory
X * 		Digital Equipment Corporation
X * Date:	Wed Jan  4 1989
X */
X
X/*
X * $Log:	main.c,v $
X * Revision 1.9  92/08/04  17:55:08  mogul
X * undo RCS botch
X * 
X * Revision 1.8  1992/06/17  22:14:41  kent
X * Make axis specs with max < min work, fix some bugs with centering
X * and multiple args.
X *
X * Revision 1.7  1992/04/03  23:55:47  kent
X * Fixed a problem where "include" reset the world.
X *
X * Revision 1.6  1992/04/01  23:27:34  kent
X * Added datalabel verb, fixed a bug in handling blank input lines.
X *
X * Revision 1.5  1992/04/01  00:38:24  kent
X * Fixed a problem with half grids specified with -g.
X *
X * Revision 1.4  1992/03/31  02:31:34  kent
X * Added markergray verb and fixed inverted gray values.
X *
X * Revision 1.3  1992/03/31  00:21:29  kent
X * Added "include" verb
X *
X * Revision 1.2  1992/03/30  23:33:47  kent
X * Added halfopen, halfticks grid styles, range frames, and gray.
X *
X * Revision 1.1  1992/03/20  21:25:43  kent
X * Initial revision
X *
X * Revision 1.12  92/02/21  17:13:22  mogul
X * Added Digital license info
X * 
X * Revision 1.11  91/12/19  16:00:52  mogul
X * Avoid an infinite loop if the graph is a horizontal or vertical
X * line.
X * 
X * Revision 1.10  91/02/04  16:48:01  mogul
X * Fixed text, marker colors
X * 
X * Revision 1.9  90/12/11  20:39:42  reid
X * Added default values for LineColor and LineWidth
X * 
X * Revision 1.8  89/02/03  09:33:06  kent
X * Use floor in calculating log limits.
X * 
X * Revision 1.7  89/01/10  18:19:59  kent
X * Moved marker code to prolog, added error checking and messages.
X * 
X * Revision 1.6  89/01/09  22:18:43  kent
X * Added log scales.
X * 
X * Revision 1.5  89/01/04  18:12:19  kent
X * Added -p flag to specify alternate prologue file.
X * 
X * Revision 1.4  89/01/04  17:57:36  kent
X * Moved font stuff from main.c to output.c.
X * newfont() sets PS fontsize variable so white background is the right size.
X * 
X * Revision 1.3  89/01/04  17:30:29  kent
X * Made command line arguments override compiled-in defaults for
X * all plots in a run, not just the first one. 
X * 
X * Revision 1.2  89/01/04  15:22:05  kent
X * Massive renaming. No functional change.
X * 
X * Revision 1.1  89/01/04  13:57:54  kent
X * Initial revision
X * 
X */
X
Xstatic char rcs_ident[] = "$Header: main.c,v 1.9 92/08/04 17:55:08 mogul Exp $";
X
X/*
X * This program has a long history. It started out as a program to take
X * graph(1) input and produce pic/troff output. That was done by Bob Brown. In
X * the process, he added to the input language to make it a lot more useful.
X * Chris Kent then took it and made it produce PostScript. As it got more use,
X * Chris' users didn't care about troff, so that code all went away, but they
X * wanted even more features.
X *
X * This incarnation was started when Chris was asked to add "one more feature"
X * and the single-file version just got to be too much to handle. Now it's
X * broken into several files, and the effects of time and feeping creaturism
X * have been cleaned up. But it almost certainly retains some code from some of
X * these versions:
X *
X *  Bob Brown/RIACS/NASA Ames
X *  Mostly untested. 3/86
X *  Converted to emit PostScript instead of Pic
X *		Chris Kent, DECWRL, 5/87
X *  More PostScript cleanup -- cak 11/87
X *  A few new options, made it use a private dictionary, attacked some
X *	roundoff problems -- cak 2/88
X *
X */
X
X#include <stdio.h>
X#include <pwd.h>
X#include <sys/file.h>
X
X#include "psgraph.h"
X
Xmain(argc,argv)
Xchar *argv[];
X{
X	int	i;
X	long	clock;
X	char	hostname[256];
X	struct passwd	*pwd;
X	fontName_t	*fp;
X	
X	MinX = MinY = MaxX = MaxY = 0.0;
X	Token = (token_t *) calloc(TOKENINC, sizeof(token_t));
X	SizeofToken = TOKENINC;
X	procargs(argc,argv);
X
X	FontList = (fontName_t *) malloc(sizeof (fontName_t));
X	FontList->name = newstr("Times-Roman");
X	FontList->next = (fontName_t *) NULL;
X
X	/* put out comment header */
X	printf("%%!PS-Adobe-1.0\n");
X	pwd = getpwuid(getuid());
X	gethostname(hostname, sizeof hostname);
X	printf("%%%%Creator: %s:%s (%s)\n",hostname,
X		pwd->pw_name, pwd->pw_gecos);
X	printf("%%%%Title: PostScript graph file\n");
X	printf("%%%%CreationDate: %s",(time(&clock), ctime(&clock)));
X	printf("%%%%DocumentFonts: (atend)\n");
X	printf("%%%%Pages: (atend)\n");
X	printf("%%%%BoundingBox: (atend)\n");
X	printf("%%%%EndComments\n");
X	
X	/* interpolate prolog and fixed header routines */
X	
X	if (copyFile(Prolog, stdout) < 0) {
X		perror(Prolog);
X		exit(1);
X	}
X	printf("%%%%EndProlog\n");
X	
X	if ( Files==0 ) {
X		process();
X	} else {
X		for ( i=0 ; i<Files ; i++ ) {
X			if ( freopen(File[i],"r", stdin)==NULL )
X				perror(File[i]);
X			else
X				process();
X		}
X	}
X	printf("%%%%Trailer\n");
X	printf("EndPSGraph\n");
X	printf("%%%%DocumentFonts: %s", FontList->name);
X	for (fp = FontList->next; fp; fp = fp->next)
X		printf(", %s", fp->name);
X	printf("\n");
X	printf("%%%%Pages: %d\n", CurrentPage);
X	printf("%%%%BoundingBox: %d %d %d %d\n",
X		(int) (MinX * 72), (int) (MinY * 72),
X		(int) (MaxX * 72), (int) (MaxY * 72));
X	exit(0);
X}
X
XcopyFile(fileName, stream)
Xchar	*fileName;
XFILE	*stream;
X{
X	int	fd, fo;
X	char	buf[BUFSIZ];
X	int	cnt;
X
X	fflush(stream);
X	fo = fileno(stream);
X	if ((fd = open(fileName, O_RDONLY, 0)) < 0) 
X		return -1;
X	do if (cnt = read(fd, buf, sizeof(buf)))
X		if (write(fo, buf, cnt) != cnt) return -2;
X	while (cnt == sizeof(buf));
X	close(fd);
X	fflush(stream);
X	return 0;
X}
X
Xprocess()
X{
X	/* reset everything */
X	init(&Xaxis);
X	init(&Yaxis);
X
X	/* copy command line defaults into place... */
X	BreakAfterLabel = Args.breakAfterLabel;
X	Xcenter = Args.center;
X	Xaxis.size = Width;
X	Yaxis.size = Height;
X	Xaxis.offset = Xoffset;
X	Yaxis.offset = Yoffset;
X	copyLimit(&Xaxis, &Xlim);
X	copyLimit(&Yaxis, &Ylim);
X
X	/* reset state */
X	DoAxisLabels = TRUE;
X	TransparentLabels = FALSE;
X	UseSpline = FALSE;
X	NumTokens = 0;
X	ClipDist = 0.05;
X	LineType = "solid";
X	LineColor = "black";
X	LineWidth = "0.6";
X	TickLen = 0.1;
X	Tick2Len = 0.05;
X	UseMarker = NULL;
X	TextColor = "black";
X	MarkColor = "black";
X	NumTokens = 0;
X	doinput(stdin);
X	if ( numpnts() > 0 ) {
X		transpose();
X		dolimits(0);
X		dolimits(1);
X		doplot();
X	}
X}
X
Xinit(p)
Xaxis_t *p;
X{
X	p->tickflag = FALSE;
X	p->label = NULL;
X	p->gridtype = GridType;
X	p->tickgray = 0.0;
X	p->axisgray = 0.0;
X	p->datatick = FALSE;
X	p->datalabel = FALSE;
X	p->halfgrid = HalfGrid;
X	p->rangeframe = FALSE;
X	p->intervals = 0;
X}
X
XinitLimit(l)
Xlimit_t	*l;
X{
X	l->minflag = FALSE;
X	l->maxflag = FALSE;
X	l->distf = FALSE;
X	l->tform = IDENT;
X}
X
XcopyLimit(a, l)
Xaxis_t	*a;
Xlimit_t	*l;
X{
X	a->tform   = l->tform;
X	a->minflag = l->minflag;
X	a->maxflag = l->maxflag;
X	a->distf   = l->distf;
X	a->min     = l->min;
X	a->max     = l->max;
X	a->dist    = l->dist;
X}
X
Xprocargs(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	int arg, more;
X	char *swptr;
X
X	Files = 0;
X	File = (char **)calloc(argc, sizeof (char *));
X	Args.breakAfterLabel = FALSE;
X	Args.center = 0.0;
X	GridType = FULL;
X	HalfGrid = FALSE;
X	Height = 6.5;
X	Width = 6.5;
X	Prolog = PROLOG;
X	Title.title = NULL;
X	Title.font = NULL;
X	Xoffset = 0.0;
X	Yoffset = 0.0;
X	TransposeAxes = FALSE;
X
X	for ( arg=1 ; arg<argc ; arg++ ) {
X		if ( argv[arg][0] == '-' ) {
X			more = 1;
X			swptr = &argv[arg][1];
X			while ( more && *swptr!='\0' ) {
X				switch ( *swptr++ ) {
X				case 'b':	/*breaks*/
X					Args.breakAfterLabel = TRUE;
X					break;
X				case 'c':
X					if (isfloat(argv[arg+1]))
X						Args.center = 
X							atof(argv[++arg]);
X					else
X						usagexit(argv[0]);
X					break;
X				case 'g':
X					if ( arg+1 >= argc )
X						usagexit(argv[0]);
X					GridType = gridval(argv[++arg]);
X					if (GridType == HALFOPEN) {
X					    GridType = OPEN;
X					    HalfGrid = TRUE;
X					}
X					if (GridType == HALFTICKS) {
X					    GridType = TICKS;
X					    HalfGrid = TRUE;
X					}
X					break;
X				case 'h':
X					if ( isfloat(argv[arg+1]) )
X						Height = atof(argv[++arg]);
X					else
X						usagexit(argv[0]);
X					break;
X				case 'l':
X					Title.title = newstr(argv[++arg]);
X					break;
X				case 'p':
X					if (arg+1 >= argc)
X						usagexit(argv[0]);
X					Prolog = argv[++arg];
X					break;
X				case 'P':
X					Preview = TRUE;
X					break;
X				case 'r':
X					if ( isfloat(argv[arg+1]) )
X						Xoffset = atof(argv[++arg]);
X					else
X						usagexit(argv[0]);
X					break;
X				case 't':
X					TransposeAxes = TRUE;
X					break;
X				case 'u':
X					if ( isfloat(argv[arg+1]) )
X						Yoffset = atof(argv[++arg]);
X					else
X						usagexit(argv[0]);
X					break;
X				case 'w':
X					if ( isfloat(argv[arg+1]) )
X						Width = atof(argv[++arg]);
X					else
X						usagexit(argv[0]);
X					break;
X				case 'x':
X					arg = limargs(&Xlim,argc,argv,arg+1)-1;
X					break;
X				case 'y':
X					arg = limargs(&Ylim,argc,argv,arg+1)-1;
X					break;
X				default:
X					usagexit(argv[0]);
X				}
X			}
X		} else { /* there's no dash in front */
X			File[Files++] = argv[arg];
X		}
X	}
X}
Xusagexit(pgm)
Xchar *pgm;
X{
X	fprintf(stderr,"usage: %s \n",pgm);
X	exit(1);
X}
X
X/*
X * numpnts - returns the number of actual data points
X */
X
Xnumpnts()
X{
X	int i, cnt;
X	cnt = 0;
X	for ( i=0 ; i<NumTokens ; i++ )
X		if ( Token[i].type == POINT )
X			cnt++;
X	return cnt;
X}
X
Xtranspose()
X{
X	register int	i;
X	float		f;
X	axis_t		t;
X
X	if(!TransposeAxes)
X		return;
X	t = Xaxis; 
X	Xaxis = Yaxis; 
X	Yaxis = t;
X	for(i= 0; i < NumTokens; i++) {
X		if ( Token[i].type != POINT ) continue;
X		f = Token[i].xval; 
X		Token[i].xval = Token[i].yval; 
X		Token[i].yval = f;
X	}
X}
X
Xchar *newstr(s)
Xchar *s;
X{
X	char *t;
X	t = (char *)malloc((unsigned)(strlen(s)+1));
X	strcpy(t,s);
X	return t;
X}
X
X/*
X * isfloat - returns TRUE if the argument is a floating point number
X */
X
Xisfloat(cp)
Xchar *cp;
X{
X	while ( *cp && isspace(*cp) )
X		cp++;
X	if ( *cp == '-' )
X		cp++;
X	if ( isdigit(*cp) || *cp=='.' )
X		return TRUE;
X	return FALSE;
X}
X
X/*
X * dolimits - compute the minimum and maximum of the data points.
X *	      compute the minimum and maximum to plot on the grid.
X */
X
Xdolimits(v)
X{
X
X	if (AxisArgs[v].tform == IDENT)
X		doLinearLimits(v);
X	else
X		doLogLimits(v);
X}
X
XdoLinearLimits(v)
Xregister int	v;
X{
X	register axis_t *argp;
X	register int i;
X	float min, max;
X
X	argp = &AxisArgs[v];
X	argp->min = HUGE;
X	for ( i=0; i<NumTokens ; i++ )
X	    if ( Token[i].type == POINT )
X		argp->min = MIN(argp->min, Token[i].val[v]);
X
X	argp->max = -HUGE;
X	for ( i=0; i<NumTokens ; i++ )
X	    if ( Token[i].type == POINT )
X		argp->max = MAX(argp->max, Token[i].val[v]);
X
X	if (argp->minflag)
X	    min = argp->gmin;
X	else
X	    min = argp->min;
X	if (argp->maxflag)
X	    max = argp->gmax;
X	else
X	    max = argp->max;
X
X	scale1(min, max, 5,
X		&argp->pmin, &argp->pmax, &argp->distp);
X	if ( !argp->minflag )
X		argp->gmin = argp->pmin;
X	if ( !argp->maxflag )
X		argp->gmax = argp->pmax;
X	if ( argp->distf )
X		argp->distg = argp->dist;
X	else
X		argp->distg = argp->distp;
X
X	/* avoid infinite loops */
X	if (argp->gmax == argp->gmin) {
X	    if (argp->gmin > 0.0)
X		argp->gmin = 0.0;
X	    else
X		argp->gmax += 1.0;
X	}
X}
X
XdoLogLimits(v)
Xregister int	v;
X{
X	register axis_t *argp;
X	register int i;
X
X	argp = &AxisArgs[v];
X
X	argp->min = HUGE;
X	for ( i=0; i<NumTokens ; i++ )
X	    if ( Token[i].type == POINT ) {
X		if (Token[i].val[v] <= 0.0) {
X		    fprintf(stderr, 
X			    "Bad log point (%g, %g)\n", 
X			    Token[i].val[0], 
X			    Token[i].val[1]);
X		    Token[i].type = IGNORE;
X		    continue;
X		}
X		argp->min = MIN(argp->min, Token[i].val[v]);
X	    }
X	if (argp->min <= 0.0) {
X		fprintf(stderr, "Illegal log minimum %g\n", argp->min);
X		exit(-1);
X	}
X	argp->max = -HUGE;
X	for ( i=0; i<NumTokens ; i++ )
X	    if ( Token[i].type == POINT )
X		argp->max = MAX(argp->max, Token[i].val[v]);
X
X	argp->pmin = ipow(10.0, (int)floor(log10(argp->min)));
X	argp->pmax = ipow(10.0, (int)floor(log10(argp->max)) + 1);
X	argp->distp = copysign(2.0, (argp->gmax - argp->gmin)) ;
X	
X/*	scale3(argp->min, argp->max, argp->intervals,
X		&argp->pmin, &argp->pmax, &argp->distp);
X*/
X	if ( !argp->minflag )
X		argp->gmin = argp->pmin;
X	if ( !argp->maxflag )
X		argp->gmax = argp->pmax;
X	if ( argp->distf )
X		argp->distg = argp->dist;
X	else
X		argp->distg = argp->distp;
X	argp->lgmin = log10(argp->gmin);
X	argp->lgmax = log10(argp->gmax);
X}
X
X/*
X *----------------------------------------------------------------------
X *
X * TEXT PARSING ROUTINES
X *
X * parse - break a string into substrings
X */
X
Xparse(line, argc, argv)
Xchar *line;
Xint *argc;
Xchar *argv[];
X{
X	char *ptr, *nextarg();
X
X	ptr = line;
X	*argc = 0;
X	while ((ptr=nextarg(ptr,&argv[*argc])) != NULL )
X		(*argc)++;
X	argv[*argc] = NULL;
X}
Xchar *
Xnextarg(line, start)
Xregister char *line, **start;
X{
X	bool esc;
X	register char *out;
X	char delim;
X	while ( isspace(*line) && *line != EOS )
X		line++;
X	if ( *line == EOS )
X		return NULL;
X	*start = line;
X	if ( *line=='\'' || *line=='"' ) {
X		delim = *line;
X		out = ++line;
X		(*start)++;
X		esc = FALSE;
X		while(TRUE) {
X			if ( *line == '\\' ) {
X				if ( esc ) {
X					out--;
X					esc = FALSE;
X				} else
X					esc = TRUE;
X			} else if ( *line == delim ) {
X				if ( esc ) {
X					out--;
X					esc = FALSE;
X				} else
X					break;
X			} else if ( *line == EOS ) {
X				line--;
X				break;
X			} else
X				esc = FALSE;
X			*out++ = *line++;
X		}
X		*out = EOS;
X		return (++line);
X	} else {
X		while ( !isspace(*line) && *line != EOS )
X			line++;
X		if ( *line != EOS )
X			*line++ = EOS;
X		return line;
X	}
X}
END_OF_FILE
if test 15465 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
fi
# end of 'main.c'
fi
if test -f 'patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patchlevel.h'\"
else
echo shar: Extracting \"'patchlevel.h'\" \(256 characters\)
sed "s/^X//" >'patchlevel.h' <<'END_OF_FILE'
X/*
X**  This file records official patches.  RCS records the edit log.
X**
X**  $Header: patchlevel.h,v 1.1 92/08/04 14:03:24 mogul Exp $
X**
X**  $Log:	patchlevel.h,v $
X * Revision 1.1  92/08/04  14:03:24  mogul
X * Initial revision
X * 
X*/
X#define PATCHLEVEL 0
END_OF_FILE
if test 256 -ne `wc -c <'patchlevel.h'`; then
    echo shar: \"'patchlevel.h'\" unpacked with wrong size!
fi
# end of 'patchlevel.h'
fi
if test -f 'psgraph.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'psgraph.h'\"
else
echo shar: Extracting \"'psgraph.h'\" \(8416 characters\)
sed "s/^X//" >'psgraph.h' <<'END_OF_FILE'
X/* $Header: psgraph.h,v 1.8 92/08/04 17:55:13 mogul Exp $ */
X
X/*
X *               Copyright 1989, 1992 Digital Equipment Corporation
X *                          All Rights Reserved
X * 
X * 
X * Permission to use, copy, and modify this software and its documentation
X * is hereby granted only under the following terms and conditions.  Both
X * the above copyright notice and this permission notice must appear in
X * all copies of the software, derivative works or modified versions, and
X * any portions threof, and both notices must appear in supporting
X * documentation.
X * 
X * Users of this software agree to the terms and conditions set forth
X * herein, and hereby grant back to Digital a non-exclusive, unrestricted,
X * royalty-free right and license under any changes, enhancements or
X * extensions made to the core functions of the software, including but
X * not limited to those affording compatibility with other hardware or
X * software environments, but excluding applications which incorporate
X * this software.  Users further agree to use their best efforts to return
X * to Digital any such changes, enhancements or extensions that they make
X * and inform Digital of noteworthy uses of this software.  Correspondence
X * should be provided to Digital at:
X * 
X *                       Director of Licensing
X *                       Western Research Laboratory
X *                       Digital Equipment Corporation
X *                       250 University Avenue
X *                       Palo Alto, California  94301  
X * 
X * This software may be distributed (but not offered for sale or
X * transferred for compensation) to third parties, provided such third
X * parties agree to abide by the terms and conditions of this notice.
X * 
X * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS
X * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
X * WARRANTIES OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL
X * EQUIPMENT CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
X * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
X * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X */
X
X/* 
X * psgraph.h - Definitions for psgraph
X * 
X * Author:	Christopher A. Kent
X * 		Western Research Laboratory
X * 		Digital Equipment Corporation
X * Date:	Wed Jan  4 1989
X */
X
X/*
X * $Log:	psgraph.h,v $
X * Revision 1.8  92/08/04  17:55:13  mogul
X * undo RCS botch
X * 
X * Revision 1.7  1992/07/08  16:43:46  mogul
X * Stupid Ul tricks.
X * (math.h doesn't declare copysign() as returning double)
X *
X * Revision 1.6  92/07/08  15:50:32  mogul
X * PROLOG can now be defined in Makefile.
X * 
X * Revision 1.5  1992/04/02  00:45:01  kent
X * Changes to handle lots of points; when using dataticks, the axis
X * routines could get too big and overflow the operand stack. As
X * a result, the output PostScript code is even uglier.
X *
X * Revision 1.4  1992/04/01  23:28:24  kent
X *  Added datalabel verb, fixed a bug in handling blank input lines.
X *
X * Revision 1.3  1992/03/31  00:07:39  kent
X * Added markerscale verb.
X *
X * Revision 1.2  1992/03/30  23:54:25  kent
X * Added halfopen, halfticks grid styles, range frames, and gray.
X *
X * Revision 1.1  1992/03/20  21:29:05  kent
X * Initial revision
X *
X * Revision 1.10  92/02/21  17:13:23  mogul
X * Added Digital license info
X * 
X * Revision 1.9  91/02/04  16:48:11  mogul
X * Fixed text, marker colors
X * 
X * Revision 1.8  90/12/11  20:42:27  reid
X * Added new enum type members for LINEWIDTH and LINECOLOR
X * 
X * Revision 1.7  89/01/27  15:59:38  kent
X * Need to get the prolog from the standard place!
X * 
X * Revision 1.6  89/01/10  18:20:01  kent
X * Moved marker code to prolog, added error checking and messages.
X * 
X * Revision 1.5  89/01/09  22:18:49  kent
X * Added log scales.
X * 
X * Revision 1.4  89/01/04  18:12:35  kent
X * Added -p flag to specify alternate prologue file.
X * 
X * Revision 1.3  89/01/04  17:29:47  kent
X * Made command line arguments override compiled-in defaults for
X * all plots in a run, not just the first one. 
X * 
X * Revision 1.2  89/01/04  15:22:10  kent
X * Massive renaming. No functional change.
X * 
X * Revision 1.1  89/01/04  13:58:10  kent
X * Initial revision
X * 
X */
X
X#include <ctype.h>
X#include <math.h>
X
X#ifdef	ultrix
Xextern double copysign();	/* grrrr */
X#endif	ultrix
X
Xtypedef	char	bool;
X#define	TRUE	1
X#define	FALSE	0
X
X#define TOKENINC	16
X#define ARGC	16
X#define EOS	'\0'
X
X#ifndef	PROLOG
X#define	PROLOG	"/usr/local/lib/ps/psgraph.pro"
X#endif	PROLOG
X
X#define	TEXTFONT	"Times-Roman10"
X
X#define	MIN(a,b)	((a)<(b)?(a):(b))
X#define	MAX(a,b)	((a)>(b)?(a):(b))
X
Xtypedef enum {IDENT, LOG10}		tform_t;
Xtypedef enum {NONE,OPEN,TICKS,FULL,HALFOPEN,HALFTICKS}	grid_t;
Xtypedef	enum {NORTH, SOUTH, EAST, WEST}	dir_t;
X
Xtypedef struct _title {
X	char	*title;		/* title string	*/
X	char	*font;		/* font for the title */
X} title_t;
X
Xtypedef struct _arg {		/* plot-specific parameters that can also be
X				 * specified on the command line */
X	bool	breakAfterLabel;/* automatic break after input label */
X	float	center;		/* center point of baseline */
X} arg_t;
X
Xtypedef struct _axis {		/* axis-specific parameters */
X	bool	minflag;	/* TRUE=>minimum specified explicitly	*/
X	bool	maxflag;	/* TRUE=>maximum specified explicitly	*/
X	bool	distf;		/* TRUE=>user-supplied grid spacing	*/
X	bool	tickflag;	/* TRUE=>user supplied tick positions	*/
X	bool	rangeframe;	/* TRUE=>axis only covers data range    */
X	bool	datatick;	/* TRUE=>ticks at real datapoints	*/
X	bool	datalabel;	/* TRUE=>labels at real datapoints	*/
X	float	tick;		/* user-supplied tick spacing		*/
X	float	tickgray;	/* percent gray in which to draw ticks  */
X	grid_t	gridtype;	/* grid type in this dimension		*/
X	bool	halfgrid;	/* don't draw a full frame for this axis*/
X	float	axisgray;	/* percent gray in which to draw axis   */
X	tform_t	tform;		/* transformation type			*/
X	float	min, max;	/* data minimum and maximum		*/
X	int	intervals;	/* number of intervals on axis		*/
X	float	pmin, pmax;	/* computed plot minimum and maximum	*/
X	float	distp;		/* computed distance between grid lines	*/
X	float	gmin, gmax;	/* min and max to use on the grid	*/
X        float	lgmin, lgmax;	/* log of gmin, gmax for log scales	*/
X	float	distg;		/* grid spacing to actually use		*/
X	float	dist;		/* grid line spacing			*/
X	float	offset;		/* displacement				*/
X	float	size;		/* grid size in inches			*/
X	char	*label;		/* label to place on the axis		*/
X	char	*font;		/* font to label axis in		*/
X} axis_t;
X
Xtypedef struct _limit {		/* axis limit argument */
X	tform_t	tform;		/* transformation type			*/
X	bool	minflag;	/* TRUE=>minimum specified explicitly	*/
X	bool	maxflag;	/* TRUE=>maximum specified explicitly	*/
X	bool	distf;		/* TRUE=>user-supplied grid spacing	*/
X	float	min, max;	/* data minimum and maximum		*/
X	float	dist;		/* grid line spacing			*/
X} limit_t;
X
Xtypedef enum tokenType {	/* internalized graph tokens */
X	POINT, BREAK, LINETYPE, LINECOLOR, LINEWIDTH, MARKER, MARKERGRAY,
X	MARKERSCALE, FONT, TEXT, SPLINE, TRANS, IGNORE
X} type_t;
Xtypedef struct _token {
X	type_t	type;
X	float	val[2];
X	int	ival;
X	char	*label;
X}token_t;
X#define xval val[0]
X#define yval val[1]
X
Xtypedef struct _fontName {	/* the chain of fonts that were used */
X	char *name;
X	struct _fontName *next;
X}fontName_t;
X
Xarg_t	Args;			/* command-line arguments override defaults */
Xchar	*Prolog;
Xgrid_t	GridType;
Xbool	HalfGrid;
Xfloat	Height;
Xbool	Preview;
Xfloat	Xoffset;
Xfloat	Yoffset;
Xbool	TransposeAxes;
Xfloat	Width;
Xlimit_t	Xlim, Ylim;
X
Xbool	BreakAfterLabel;	/* plot-specific values */
Xfloat	ClipDist;
Xbool	DoAxisLabels;
Xint	PointSize;
Xchar	*TextFont;
Xfloat	TickLen;
Xfloat	Tick2Len;
Xbool	TransparentLabels;
Xfloat	Xcenter;
Xaxis_t	AxisArgs[2];
X
Xchar	**File;			/* global state */
Xint	Files;
Xint	CurrentPage;
Xfloat	MinX, MinY, MaxX, MaxY;
Xfloat	minX, minY, maxX, maxY;
Xchar	*LineType;
Xchar	*LineColor;
Xchar	*LineWidth;
Xbool	UseSpline;
Xtitle_t	Title;
Xtoken_t	*Token;
Xint	SizeofToken, NumTokens;
Xchar	*UseMarker;
XfontName_t	*FontList;
XfontName_t	*CurrentFont;
Xchar	*TextColor;
Xchar	*MarkColor;
Xint	CurrentTemp;
Xbool	TempOpen;
Xint	LinesInTemp;
X
X#define	Xaxis	AxisArgs[0]
X#define	Yaxis	AxisArgs[1]
X
Xchar	*newstr();
Xgrid_t	gridval();
Xfloat	sx(), sy(), SX(), SY();
Xfloat	plotx(), ploty();
Xfloat	ipow();
Xchar	*calloc(), *malloc(), *realloc();
Xdouble	atof();
X
END_OF_FILE
if test 8416 -ne `wc -c <'psgraph.h'`; then
    echo shar: \"'psgraph.h'\" unpacked with wrong size!
fi
# end of 'psgraph.h'
fi
if test -f 'psgraph.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'psgraph.man'\"
else
echo shar: Extracting \"'psgraph.man'\" \(9533 characters\)
sed "s/^X//" >'psgraph.man' <<'END_OF_FILE'
X.TH PSGRAPH 1.1 "7 November 1990" DECWRL
X.SH NAME
Xpsgraph \- generate a graph in PostScript
X.SH SYNOPSIS
X.B psgraph
X[ option ] [ files ]...
X.SH DESCRIPTION
X.I Psgraph
Xoperates in a manner similar to
X.I graph(1),
Xin that it reads pairs of numbers from its standard input
Xand produces a graph.
XIf files are given as arguments, each file is processed to produce a separate 
Xgraph.
XThe output language is a complete 
X.I PostScript 
Xdocument, suitable for inclusion in a Scribe or TeX document, or, with the 
X.B \-P
Xflag, printing directly on a PostScript printer.
XSeveral differences exist between
X.I graph
Xand
X.IR psgraph ,
Xthe most significant of which is that
X.I psgraph
Xcan take all of its parameters
X(except 
X.BR \-P )
Xfrom its input instead of requiring that
Xeverything except data be on the command line.
X.SH OPTIONS
X.PP
XAll the options of
X.I graph
Xare supported, except
X.BR \-s .
XThe meaning of the
X.BR \-h ,
X.BR \-w ,
Xand
X.B \-c
Xoptions have changed.
XA few new options have been added as well.
X.TP
X.B  \-h
XNext argument is the height of the graph in inches.
X.TP
X.B  \-w
XSimilarly for width.
X.TP
X.B \-c
XCenter the X axis of the graph on the page width specified by the next argument
X(in inches). 
X.TP
X.B \-P
XProduce an output file with a 
X.B showpage
Xcommand at the end of each graph, and a 
X.B translate
Xcommand that assures that the entire graph will appear on the output page.
X.TP
X.B \-p
XUse the file named by the next argument as the PostScript prologue, instead of 
Xthe standard one. 
XThis allows you to define new line styles and marker shapes.
X.SH INPUT
X.PP
XInput is line oriented; lines beginning with a pound sign are ignored.
XEach line either specifies a data point (one or two numbers followed by an
Xoptional label) or a command.
XLines are parsed into fields separated by white space.
XA string of text enclosed in quotation marks or apostrophes is considered a
Xsingle field.
XCommand lines consist of a keyword followed by zero or more modifiers.
XSome commands affect the entire graph (such as one to specify the grid type)
Xand so can be placed anywhere in the input (though placing them at the top
Xis conventional).
XOther commands only affect the data that follows them (such as the one to
Xmodify the line or marker type).
X.PP
XData points in the input are interpreted as in
X.I graph(1).
XIf the 
X.B \-a
Xoption is specified, only one number is expected, otherwise two.
XIf a label (second or third field) is given, that label is printed on the
Xgraph at the location of the point given on the same line.
X.PP
XThe following commands are recognized:
X.sp
X.IP CMD 1i
XDESCRIPTION
X.IP break 1i
XBreak the plot at this point in the input.
X.IP "include F" 1i
XSwitch to reading input from the file
X.IR F .
XYes, recursive 
X.IR include s
Xare handled properly.
X.IP "line S" 1i
XConnect subsequent points with a line of type S,
Xwhere S is
X.IR solid ,
X.IR dotdashed ,
X.IR shortdashed ,
X.IR longdashed , 
X.IR dotted , 
Xor
X.IR off ,
Xwith or without quotes.  If S is omitted, splines are turned
Xoff (if on) and the line type remains unchanged.
X.IP "color C" 1i
XSet the color to be used in subsequent lines to be the one named "C",
Xwhere C is
X.IR red ,
X.IR blue ,
X.IR magenta ,
X.IR green ,
X.IR black ,
X.IR cyan ,
X.IR yellow ,
X.IR gray ,
X.IR orange ,
Xor
X.IR violet ,
Xwith or without quotes. If C is omitted, the color is set to black.
X.IP "linewidth D" 1i
XSets the width for subsequent graphed lines. The argument is a floating-point
Xnumber, and is the number of points of line width. There are 72 points to an
Xinch. The default line width is 0.6 points.
X.IP "transparent" 1i
XNormally, the label associated with a point is painted with a white background,
Xobliterating any text or graphics behind it. 
XThis command causes the text to be painted without first painting a white
Xbackground box.
X.IP "notransparent" 1i
XWhen painting a point label, first paint a white background box behind it.
X.IP "label" 1i
XPlace numeric labels on the end of each grid line.
X.IP "nolabel" 1i
XDo not place numeric labels on grid lines.
X.IP "tick N [M]" 1i
XMake grid tick marks (for
X.BR "grid tick" )
XN inches long.
XA second numeric parameter M states the length of secondary tick marks \-
Xthose generated by the 
X.B "x tick N"
Xcommand.
X.IP datatick 1i
XPlace ticks only where there is a data point.
X.IP datalabel 1i
XLabel every datatick.
X.ne 3
X.IP "grid N" 1i
XDraw grid type N, 0=no grid, 1=frame grid, 2=frame grid with tick marks,
X3=mesh grid, 4=frame grid with only left and bottom axes, 5=grid 4 with
Xtick marks.
XGets applied to both dimensions. Also, the more descriptive
X.IR none , 
X.IR open ,
X.IR tick ,
X.IR full ,
X.IR halfopen ,
Xor
X.I halftick
Xmay be used.
XFor historical reasons, grid type 3, 
X.IR full ,
Xis the default. 
X.ne 2
X.IP rangeframe 1i
XFor all grid types except
X.I none
Xand
X.IR full,
Xonly draw the axis line over the range of the data on that axis.
XTicks or scales, if any, are drawn on the entire axis.
X.IP "tickgray f"
XDraw the ticks in f percent gray; default is 100% (full black).
X.IP "axisgray f"
XDraw the ticks in f percent gray; default is 100% (full black).
X.ne 3
X.IP "clip N"
XData points and connecting lines are clipped to the grid, to some
Xtolerance. The default tolerance is 0.05; that is, if the data value lies
Xup to 5% outside the axis limits, it will be plotted. The 
X.B clip
Xverb is used to change the value of this tolerance. 
XLog scale users should be warned that the calculation is done in ``linear
Xspace'' and will often not behave as expected.
X.IP "font f"
XSwitch to font 
X.I f
Xfor subsequent marker label text. 
XFonts are named as for 
X.IR enscript(1) ,
Xe.g., ``Times-Roman10''.
X.IP "width N" 1i
XMake the grid N (float) inches wide.
XOverridden by the
X.B "size N"
Xcommand.
X.IP "height N" 1i
XMake the grid N (float) inches high.
XOverridden by the
X.B "size N"
Xcommand.
X.IP "center N" 1i
XCenter the X axis on an N (float) inch wide line.
X.IP "spline" 1i
XSubsequent data is plotted as splines.  Causes
Xa break.
XMarkers, if turned on, still appear at the actual data point.
X.IP "marker m" 1i
XPlot subsequent points with marker type 
X.IR m .
XIf 
X.I m
Xis 
X.IR none ,
X.IR off ,
Xor omitted, markers are turned off.
XOtherwise, valid values for 
X.I m
Xare
X.IR square , 
X.IR diamond , 
X.IR triangle , 
X.IR up , 
X.IR down , 
X.IR right ,
X.IR left , 
X.IR circle , 
X.IR x , 
X.IR plus ,
X.IR cross , 
X.IR circle-x , 
X.IR circle-plus ,
X.IR filledsquare ,
X.IR filleddiamond ,
X.IR filledtriangle ,
Xand 
X.IR filledcircle .
X.IP "markerscale s" 1i
XScale the markers (if they are turned on) by the floating point scale value
X.IR s .
XThe default value for s is 1.0.
X.IP "markergray f" 1i
XDraw the markers in f percent gray; default is 100% (full black). 
XAny subsequent \fBcolor\fR command overrides this setting, and this
Xoverrides only the marker color if a \fBcolor\fR command has been issued.
X.IP "title \fIfoo\fR" 1i
XUse 
X.I foo
Xas the title for this plot (displayed at the top).
X.IP "titlefont \fIbar\fR" 1i
XDisplay the title in font
X.IR bar .
XFonts are named as for
X.IR enscript(1) ,
Xe.g., ``Times-Roman10''.
X.IP "x args" 1i
XModify x data processing (see below)
X.IP "y args" 1i
XModify y data processing (see below)
X.LP
XThe arguments for the 
X.B x 
Xand 
X.B y 
Xcommands can all be placed on a
Xsingle line, or separate 
X.B x
Xand 
X.B y
Xlines can be used for each.
X.IP "log" 1i
XPlot this dimension on a logarithmic scale.
X.IP "min N" 1i
XMinimum on the grid is N (float)
X.IP "max N" 1i
XMaximum on the grid is N (float)
X.IP "step N" 1i
XDistance between grid lines and numeric labels is N (float). No effect for
Xlinear scales.
X.IP "tick N" 1i
XDistance between secondary ticks is N (float). No effect for log scales.
X.IP "intervals N" 1i
XNumber of intervals in a decade is N (integer). No effect for linear scales.
X.IP datatick 1i
XPlace ticks only where there is a data point.
X.IP datalabel 1i
XLabel every datatick.
X.IP "offset N" 1i
XDistance between border of page and minimum edge of the grid in this
Xdimension is N (float) inches.
X.ne 2
X.IP rangeframe 1i
XFor all grid types except
X.I none
Xand
X.IR full,
Xonly draw the axis line over the range of the data on that axis.
XTicks or labels, if any, are drawn on the entire axis.
X.IP "tickgray f"
XDraw the ticks in f percent gray; default is 100% (full black).
X.IP "axisgray f"
XDraw the ticks in f percent gray; default is 100% (full black).
X.IP "label \fIfoo\fR" 1i
XUse
X.I foo
Xas the label for this axis.
X.IP "size N" 1i
XMake the grid this big (N is in inches).
XOverrides the 
X.B width
Xand
X.B height
Xcommands.
X.IP "grid N" 1i
XSpecify the grid type in this dimension (as above).
X.IP "font \fIfoo\fR" 1i
XDraw the axis labels in font
X.IR foo .
XFonts are named as for 
X.IR enscript(1) ,
Xe.g., ``Times-Roman10''.
X.SH FILES
X/usr/local/lib/ps/psgraph.pro \- standard prologue
X.SH SUGGESTIONS
XMany of the options are provided to minimize 
X.BR chartjunk ,
Xthat is, to maximize the data to ink ratio. 
XTo this end, the grid types 
X.I halfopen
Xand
X.I halftick
Xare the most useful.
X.PP
X.I Rangeframe
Xand 
X.I datatick
Xwere designed to make a standard bivariate scatterplot more useful.
X.PP
XAll the graphical elements of the frame can be removed, either by careful
Xselection of the grid type, the various gray settings, or 
X.IR nolabel .
X.SH "SEE ALSO"
Xenscript(1), graph(1), psgsimp(1)
X.PP
XTufte, Edward, R. 
X.I "The Visual Display of Quantitative Information."
XGraphics Press, P.O. Box 430, Cheshire, CT. 1983.
X.PP
XTufte, Edward, R. 
X.I "Envisioning Information."
XGraphics Press, P.O. Box 430, Cheshire, CT. 1990.
X.SH BUGS
XA superset of the bugs listed in
X.I graph(1).
X.PP
XThere are almost certainly too many options.
END_OF_FILE
if test 9533 -ne `wc -c <'psgraph.man'`; then
    echo shar: \"'psgraph.man'\" unpacked with wrong size!
fi
# end of 'psgraph.man'
fi
if test -f 'psgraph.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'psgraph.pro'\"
else
echo shar: Extracting \"'psgraph.pro'\" \(4169 characters\)
sed "s/^X//" >'psgraph.pro' <<'END_OF_FILE'
X% psgraph.pro -- included prolog for PS graph files
X% based on lib/psplot.pro, Copyright 1984 Adobe Systems, Inc.
X% $Header: psgraph.pro,v 1.6 92/08/04 17:55:20 mogul Exp $
Xsave 500 dict begin /psgraph exch def
X/StartPSGraph
X   {newpath 0 0 moveto 0.6 setlinewidth 0 setgray 1 setlinecap
X    /imtx matrix currentmatrix def 
X    /fnt /Times-Roman findfont def /fontsize 10 def
X    72 72 scale
X    /ex 72 nail def /ey 720 nail def
X    /smtx matrix def fnt fontsize scalefont setfont}bind def
X/len{dup mul exch dup mul add sqrt}bind def
X/nail{0 dtransform len 0 idtransform len}bind def
X/ljust{0 fontsize -3 div rmoveto}bind def
X/rjust{dup stringwidth pop neg fontsize -3 div rmoveto}bind def
X/cjust{dup stringwidth pop -2 div fontsize -3 div rmoveto}bind def
X/vjust{90 rotate /cjust load exec}bind def
X/prnt{dup stringwidth pop 6 add /tx exch def /ty fontsize 5 add def
X    currentpoint /toy exch def /tox exch def 1 setgray
X    newpath
X      tox 3 sub toy 5 sub moveto 0 ty rlineto tx 0 rlineto 0 ty neg rlineto
X    closepath fill tox toy moveto
X    currentColor fc
X    show}bind def
X/m{newpath moveto}bind def
X/s{pts stroke ins}bind def
X/fl{pts fill ins}bind def
X/n{lineto currentpoint s moveto}bind def
X/nf{lineto}bind def
X/l{moveto lineto currentpoint s moveto}bind def
X/pts{smtx currentmatrix pop imtx setmatrix}bind def
X/ins{smtx setmatrix}bind def
X/t{pts load exec show ins}bind def
X/w{pts load exec prnt ins}bind def
X/e{pts ex ey moveto prnt prnt /ey ey 12 sub def ins}bind def
X/gs{gsave}bind def
X/gr{grestore}bind def
X/c{gs newpath 0 0 3 -1 roll 0 360 arc s gr}bind def
X/cf{gs newpath 0 0 3 -1 roll 0 360 arc fl gr}bind def
X/f{dup lineStyles exch known
X    {lineStyles begin load exec setdash end}
X    {gs C 20 string cvs (No such line style: ) e gr unC/solid f}ifelse}bind def
X/fc{dup dup /currentColor exch store lineColors exch known
X    {lineColors begin load exec aload pop setrgbcolor end}
X    {gs C 20 string cvs (No such psgraph color: ) e gr unC/black fc}ifelse}bind def
X/fw{setlinewidth} def
X/C{/Courier findfont 10 scalefont setfont 
X    /sfs fontsize def /fontsize 10 def}bind def
X/unC{/fontsize sfs def}bind def
X/EX{/exec load}bind def
X/EndPSGraph{clear psgraph end restore}bind def
X/lineStyles 10 dict def lineStyles begin
X/solid{{}0}bind def
X/dotted{[2 nail 5 nail ] 0}bind def
X/longdashed{[10 nail] 0}bind def
X/shortdashed{[6 nail] 0}bind def
X/dotdashed{[2 nail 6 nail 10 nail 6 nail] 0}bind def
X/dashed{/shortdashed load exec}bind def
X%/off{[0 100] 0}bind def
X%/none{/off load exec}bind def
Xend
X/currentColor 0 def
X/lineColors 10 dict def lineColors begin
X/red {[1 0 0]}bind def
X/blue {[0 0 1]}bind def
X/magenta {[1 0 1]}bind def
X/green {[0 1 0]}bind def
X/black {[0 0 0]}bind def
X/cyan {[0 1 1]}bind def
X/yellow {[1 1 0]}bind def
X/gray {[.5 .5 .5]}bind def
X/orange {[1 .66 0]}bind def
X/violet {[1 0 1]}bind def
X/currentColor /black store
Xend
X
X/markers 20 dict def markers begin
X/none{}bind def
X/off{}bind def
X/square{0 0 m 0 1 n 1 1 n 1 -1 n -1 -1 n -1 1 n 0 1 n s}bind def
X/diamond{0 0 m 0 1.41 n 1.41 0 n 0 -1.41 n -1.41 0 n 0 1.41 n s}bind def
X/triangle{0 0 m 0 1 n 1 -0.73 n -1 -0.73 n 0 1 n s}bind def
X/up{triangle}bind def
X/down{0 0 m 0 -1 n 1 0.73 n -1 0.73 n 0 -1 n s}bind def
X/right{0 0 m 1 0 n -0.73 1 n -0.73 -1 n 1 0 n s}bind def
X/left{0 0 m -1 0 n 0.73 1 n 0.73 -1 n -1 0 n s}bind def
X/circle{0 1 m 0 0 n 1 c s}bind def
X/x{1 1 m -1 -1 n -1 1 m 1 -1 n s}bind def
X/plus{0 1 m 0 -1 n -1 0 m 1 0 n s}bind def
X/cross{plus}bind def
X/circle-x{1 c .707 .707 m -.707 -.707 n -.707 .707 m .707 -.707 n s}bind def
X/circle-plus{1 c 0 1 m 0 -1 n -1 0 m 1 0 n s}bind def
X/filledsquare{0 1 m 1 1 nf 1 -1 nf -1 -1 nf -1 1 nf 0 1 nf fl}bind def
X/filleddiamond{0 1.41 m 1.41 0 nf 0 -1.41 nf -1.41 0 nf 0 1.41 nf fl}bind def
X/filledtriangle{0 1 m 1 -0.73 nf -1 -0.73 nf 0 1 nf fl}bind def
X/filledcircle{0 0 m 1 cf}bind def
X/marker{}def
Xend
X/ms 1.0 def
X/mg 0 def
X/sm{dup markers exch known
X    {markers begin load /marker exch def end}
X    {gs C 20 string cvs (No such marker type: )e gr unC/off sm}ifelse}bind def
X/mk{gs translate /solid f
X    mg 0.0 ne {mg setgray} if
X    ms .04 mul dup scale markers begin marker end gr}bind def
X% end fixed prolog
END_OF_FILE
if test 4169 -ne `wc -c <'psgraph.pro'`; then
    echo shar: \"'psgraph.pro'\" unpacked with wrong size!
fi
# end of 'psgraph.pro'
fi
if test -f 'psgsimp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'psgsimp.c'\"
else
echo shar: Extracting \"'psgsimp.c'\" \(4333 characters\)
sed "s/^X//" >'psgsimp.c' <<'END_OF_FILE'
X/*
X * psgsimp.c
X *
X * Simplify a psgraph-style plot file, removing graph points closer
X * together than a specified threshold.
X *
X * Jeffrey Mogul	DECWRL		10 January 1992
X * 
X *               Copyright (c) 1992 Digital Equipment Corporation
X *                          All Rights Reserved
X * 
X * 
X * Permission to use, copy, and modify this software and its documentation
X * is hereby granted only under the following terms and conditions.  Both
X * the above copyright notice and this permission notice must appear in
X * all copies of the software, derivative works or modified versions, and
X * any portions threof, and both notices must appear in supporting
X * documentation.
X * 
X * Users of this software agree to the terms and conditions set forth
X * herein, and hereby grant back to Digital a non-exclusive, unrestricted,
X * royalty-free right and license under any changes, enhancements or
X * extensions made to the core functions of the software, including but
X * not limited to those affording compatibility with other hardware or
X * software environments, but excluding applications which incorporate
X * this software.  Users further agree to use their best efforts to return
X * to Digital any such changes, enhancements or extensions that they make
X * and inform Digital of noteworthy uses of this software.  Correspondence
X * should be provided to Digital at:
X * 
X *                       Director of Licensing
X *                       Western Research Laboratory
X *                       Digital Equipment Corporation
X *                       250 University Avenue
X *                       Palo Alto, California  94301  
X * 
X * This software may be distributed (but not offered for sale or
X * transferred for compensation) to third parties, provided such third
X * parties agree to abide by the terms and conditions of this notice.
X * 
X * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS
X * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
X * WARRANTIES OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL
X * EQUIPMENT CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
X * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
X * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X */
X
X#include <stdio.h>
X#include <math.h>
X
X#ifndef	HUGE_VAL
X#define	HUGE_VAL	HUGE
X#endif
X
XUsage()
X{
X	fprintf(stderr, "Usage: psgsimp thresh-pct <infile >outfile\n");
X}
X
Xmain(argc, argv)
Xint argc;
Xchar **argv;
X{
X	double thresh;
X	static char linebuf[1024];
X	static char lasthidden[1024];
X	float lastx, lasty;
X	float thisx, thisy;	/* sscanf() deals in floats, not doubles */
X	float deltax, deltay;
X	static char otherstuff[1024];
X
X	if (argc != 2) {
X	    Usage();
X	    exit(1);
X	}
X	
X	thresh = atof(argv[1]);
X	
X	lastx = HUGE_VAL;
X	lasty = HUGE_VAL;
X
X	lasthidden[0] = '\0';
X
X	while (gets(linebuf)) {
X	    if (sscanf(linebuf, "%f %f %s", &thisx, &thisy, otherstuff) == 2) {
X		/* only x, y value on this line */
X
X		/* compute deltax ratio */
X		if ((thisx == 0.0) && (lastx == 0.0)) {
X		    deltax = 0.0;
X		}
X		else if (thisx == 0.0) {
X		    deltax = (thisx - lastx)/lastx;
X		}
X		else {
X		    deltax = (thisx - lastx)/thisx;
X		}
X		if (deltax < 0.0)
X		    deltax = -deltax;
X		
X		/* compute deltay ratio */
X		if ((thisy == 0.0) && (lasty == 0.0)) {
X		    deltay = 0.0;
X		}
X		else if (thisy == 0.0) {
X		    deltay = (thisy - lasty)/lasty;
X		}
X		else {
X		    deltay = (thisy - lasty)/thisy;
X		}
X		if (deltay < 0.0)
X		    deltay = -deltay;
X		
X#ifdef	DEBUG
X		printf("# x %f -> %f (%f), y %f -> %f (%f)\n",
X			lastx, thisx, deltax,
X			lasty, thisy, deltay);
X#endif	DEBUG
X		
X		if ((deltax < thresh) && (deltay < thresh)) {
X		    printf("##%s\n", linebuf);
X		    strcpy(lasthidden, linebuf);
X		    continue;
X		}
X
X		lastx = thisx;
X		lasty = thisy;
X		if (lasthidden[0] != '\0') {
X		    printf("%s\n", lasthidden);
X		}
X		printf("%s\n", linebuf);
X		lasthidden[0] = '\0';
X	    }
X	    else {
X		if (lasthidden[0] != '\0') {
X		    printf("%s\n", lasthidden);
X		}
X		printf("%s\n", linebuf);
X		lasthidden[0] = '\0';
X		if (linebuf[0] != '#') {
X		    /* if non-comment, ensure next point is not suppressed */
X		    lastx = HUGE_VAL;
X		    lasty = HUGE_VAL;
X		}
X	    }
X	}
X}
END_OF_FILE
if test 4333 -ne `wc -c <'psgsimp.c'`; then
    echo shar: \"'psgsimp.c'\" unpacked with wrong size!
fi
# end of 'psgsimp.c'
fi
if test -f 'psgsimp.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'psgsimp.man'\"
else
echo shar: Extracting \"'psgsimp.man'\" \(2347 characters\)
sed "s/^X//" >'psgsimp.man' <<'END_OF_FILE'
X.TH PSGSIMP 1.0 "12 March 1992" DECWRL
X.SH NAME
Xpsgsimp \- simplify an input file for psgraph
X.SH SYNOPSIS
X.B psgsimp 
X.I threshold-pcnt
X.SH DESCRIPTION
X.I Psgsimp
Xis a filter that reads a
X.I psgraph
Xinput file from the standard input, and writes a simplified version
Xof the file to the standard output.  The program takes exactly one
Xargument,
X.IR threshold-pcnt ,
Xwhich specifies the amount of simplification.
X.PP
XThe intent of
X.I psgsimp
Xis to remove excessive detail from an automatically-generated
Xinput file before plotting it with
X.IR psgraph .
XThis can significantly reduce the amount of time it takes to print
Xthe resulting PostScript file, without much affecting the final output.
X.PP
XThe meaning of
X.I threshold-pct
Xis that
X.I psgsimp
Xshould suppress
Xany point which differs from its predecessor by less than
Xthis value in both the X and Y directions.  For example, if
X.I threshold-pct
Xis 1.0, then any change of less than one per cent is suppressed.
XLables, markers, and the end points of lines are always plotted; only the
Xintermediate points are ever suppressed.
X.PP
XThe time reduction can be quite dramatic; for example, one graph that
Xcontains 37,000 points took over 16 minutes to plot on an LPS-20.
XUsing a simplification threshold of 1.0, which eliminates details too
Xsmall to be seen on the final plot,
X.I psgsimp
Xreduced the size of the input file to about 6,000 points.  The resulting
XPostScript file took about two minutes to print, and was indistinguishable
Xfrom the unsimplified version.
X.PP
XNote that you may have to experiment somewhat with different
Xvalues for
X.IR threshold-pct ,
Xsince some graphs will suffer more from simplification than others.
X.PP
XThe output file contains all the removed input points as comments;
Xthis allows you to add back any points you want if you think the result
Xwill look better.  To remove these comments (and perhaps reclaim some 
Xdisk space) use ``grep -v "##"''.
X.SH EXAMPLES
XYou can use the program in a pipeline, e.g.:
X.nf
X.RS
Xgraph-generator | psgsimp 1.0 | psgraph -P | lpr \-h
X.RE
X.fi
Xor you can use it to generate an intermediate file, without comments:
X.nf
X.RS
Xgraph-generator >figure-1.plot
Xpsgsimp 1.0 <figure-1.plot | grep -v "##" >figure-1.simp
Xpsgraph -P figure-1.simp >figure-1.psf
Xlpr \-h figure-1.psf
X.RE
X.fi
X.SH "SEE ALSO"
Xpsgraph(1)
X.SH AUTHOR
XJeffrey Mogul, DECWRL
X
X
END_OF_FILE
if test 2347 -ne `wc -c <'psgsimp.man'`; then
    echo shar: \"'psgsimp.man'\" unpacked with wrong size!
fi
# end of 'psgsimp.man'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
