Newsgroups: comp.sources.unix
From: mogul@dec.com (Jeff Mogul)
Subject: v26i073: psgraph - generate graph in Postscript, Part02/03
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: mogul@dec.com (Jeff Mogul)
Posting-Number: Volume 26, Issue 73
Archive-Name: psgraph/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 3)."
# Contents:  examples/long.plot grid.c output.c
# Wrapped by tp@cognition.pa.dec.com on Mon Sep  7 16:47:35 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'examples/long.plot' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/long.plot'\"
else
echo shar: Extracting \"'examples/long.plot'\" \(17579 characters\)
sed "s/^X//" >'examples/long.plot' <<'END_OF_FILE'
X# Plot generated by plotsubs.c
Xx size 6
Xy size 4
Xgrid 2
Xmarker off
Xtransparent
Xline solid
Xy label "SEQ number (bytes)"
Xx label "time (seconds since start of connection)"
X
X# line starts
Xbreak
Xcolor orange
Xmarker x
X21.180183 3899392
Xbreak
Xmarker off
Xcolor black
X21.180183 3899392
X21.181413 3900852
X21.182853 3902312
X21.184083 3903772
X21.185313 3905232
X21.186765 3906692
X21.187995 3908152
X21.189225 3909612
X21.189225 3909612
Xbreak
Xcolor orange
Xmarker x
X21.189225 3909612
Xbreak
Xmarker off
Xcolor black
X21.189225 3909612
X21.190612 3911072
X21.402146 3912532
X21.405647 3913992
X21.407374 3915452
X21.409519 3916912
X21.411925 3918372
X21.413293 3919832
X21.416427 3921292
X21.417181 3922752
X21.418411 3923400
X21.421282 3924860
X21.425050 3926320
X21.427492 3927780
X21.428878 3929240
X21.431234 3930700
X21.812760 3899392
X22.458742 3909612
X22.558578 3932160
X22.560061 3933620
X22.659903 3935080
X22.661608 3936540
X22.662838 3938000
X22.770121 3939460
X22.771914 3940920
X22.813915 3942380
X22.877405 3943840
X22.879399 3945300
X22.999478 3946760
X23.001056 3948220
X23.002286 3949680
X23.011295 3951140
X23.107490 3952600
X23.109185 3954060
X23.165342 3955520
X23.206334 3956980
X23.209303 3958440
X23.210967 3959900
X23.212197 3961360
X23.267716 3962820
X23.352653 3964280
X23.358423 3965740
X23.359820 3967200
X23.361186 3968660
X23.406872 3970120
X23.456990 3971580
X23.458403 3973040
X23.474585 3974500
X23.476551 3975960
X23.477781 3977420
X23.561891 3978880
X23.563290 3980340
X23.585395 3981800
X23.588110 3983260
X23.589525 3984720
X23.591976 3986180
X23.695819 3987640
X23.697049 3989100
X23.698279 3990560
X23.699509 3992020
X23.709532 3993480
X23.711105 3994940
X23.712448 3996400
X23.811072 3997860
X23.812888 3999320
X23.814423 4000780
X23.825513 4002240
X23.827103 4003700
X23.872973 4005160
X23.874458 4006620
X23.953133 4008080
X23.954719 4009540
X23.956515 4011000
X23.957745 4012460
X23.986112 4013920
X23.987597 4015380
X24.060934 4016840
X24.063791 4018300
X24.089147 4019760
X24.090577 4021220
X24.126116 4022680
X24.129941 4024140
X24.131171 4025600
X24.132401 4027060
X24.203333 4028520
X24.206473 4029980
X24.248887 4031440
X24.250874 4032900
X24.252232 4034360
X24.253462 4035820
X24.304962 4037280
X24.306327 4038740
X24.364485 4040200
X24.366859 4041660
X24.369896 4043120
X24.372329 4044580
X24.373559 4046040
X24.390397 4047500
X24.392166 4048960
X24.443463 4050420
X24.556810 4051880
X24.558074 4053340
Xbreak
X24.558074 4053340
X24.560759 4054800
X24.562051 4056260
X24.566017 4057720
X24.567752 4059180
X24.594698 4060640
X24.596043 4062100
X24.604353 4063560
X24.680708 4065020
X24.683671 4066480
X24.684901 4067940
X24.768843 4069400
X24.770598 4070860
X24.773096 4072320
X24.774326 4073780
X24.777569 4075240
X24.788789 4076700
X24.790536 4078160
X24.791838 4079620
X24.796148 4081080
X24.797679 4082540
X24.880004 4084000
X24.882203 4085460
X24.886988 4086920
X24.888584 4088380
X24.906504 4089840
X24.908291 4091300
X24.930031 4092760
X24.932538 4094220
X24.937454 4095680
X24.939007 4097140
X24.991307 4098600
X24.993493 4100060
X24.998609 4101520
X25.000368 4102980
X25.001598 4104440
X25.018169 4105900
X25.019817 4107360
X25.036365 4108820
X25.038844 4110280
X25.049387 4111740
X25.050784 4113200
X25.103672 4114660
X25.106256 4116120
X25.110274 4117580
X25.112188 4119040
X25.130100 4120500
X25.132647 4121960
X25.147042 4123420
X25.154875 4124880
X25.156742 4126340
X25.158104 4127800
X25.201390 4129260
X25.215541 4130720
X25.217330 4132180
X25.223456 4133640
X25.225211 4135100
X25.226441 4136560
X25.243855 4138020
X25.246538 4139480
X25.253444 4140940
X25.255191 4142400
X25.271626 4143860
X25.273549 4145320
X25.317417 4146780
X25.318741 4148240
X25.334938 4149700
X25.336373 4151160
X25.352751 4152620
X25.354443 4154080
X25.356275 4155540
X25.358390 4157000
X25.379415 4158460
X25.381109 4159920
X25.387971 4161380
X25.391963 4162840
X25.419355 4164300
X25.424156 4165760
X25.437667 4167220
X25.439513 4168680
X25.474046 4170140
X25.476507 4171600
X25.480568 4173060
X25.482119 4174520
X25.486027 4175980
X25.499929 4177440
X25.501422 4178900
X25.512902 4180360
X25.514519 4181820
X25.519887 4183280
X25.522305 4184740
X25.540890 4186200
X25.542363 4187660
X25.585718 4189120
X25.587159 4190580
X25.593652 4192040
X25.596180 4193500
X25.614171 4194960
X25.615456 4196420
X25.626053 4197880
X25.628097 4199340
X25.644217 4200800
Xbreak
X25.644217 4200800
X25.645524 4202260
X25.659099 4203720
X25.660623 4205180
X25.690408 4206640
X25.691819 4208100
X25.702001 4209560
X25.703410 4211020
X25.718505 4212480
X25.719886 4213940
X25.730324 4215400
X25.732372 4216860
X25.733648 4218320
X25.749787 4219780
X25.751258 4221240
X25.758938 4222700
X25.760358 4224160
X25.797037 4225620
X25.798467 4227080
X25.803343 4228540
X25.815693 4230000
X25.817222 4231460
X25.835079 4232920
X25.837497 4234380
X25.844396 4235840
X25.845746 4237300
X25.875440 4238760
X25.877919 4240220
X25.879224 4241680
X25.881878 4243140
X25.895158 4244600
X25.897905 4246060
X25.909284 4247520
X25.910666 4248980
X25.927940 4250440
X25.929246 4251900
X25.942388 4253360
X25.951368 4254820
X25.962926 4256280
X25.964440 4257740
X26.010936 4259200
X26.012403 4260660
X26.013935 4262120
X26.015744 4263580
X26.016974 4265040
X26.018652 4266500
X26.019882 4267960
X26.030770 4269420
X26.032140 4270880
X26.041210 4272340
X26.042735 4273800
X26.056294 4275260
X26.059029 4276720
X26.070460 4278180
X26.073005 4279640
X26.123387 4281100
X26.124825 4282560
X26.146761 4284020
X26.148708 4285480
X26.150059 4286940
X26.151706 4288400
X26.167186 4289860
X26.169566 4291320
X26.177128 4292780
X26.178686 4294240
X26.196715 4295700
X26.198222 4297160
X26.208103 4298620
X26.210828 4300080
X26.267886 4301540
X26.269854 4303000
X26.271084 4304460
X26.272425 4305920
X26.273655 4307380
X26.275249 4308840
X26.276515 4310300
X26.288470 4311760
X26.294675 4313220
X26.296494 4314680
X26.297724 4316140
X26.315149 4317600
X26.316506 4319060
X26.320797 4320520
X26.322208 4321980
X26.375401 4323440
X26.376900 4324900
X26.379282 4326360
X26.380733 4327820
X26.406604 4329280
X26.408289 4330740
X26.409935 4332200
X26.427050 4333660
X26.428585 4335120
X26.435415 4336580
X26.436896 4338040
X26.450107 4339500
X26.451519 4340960
X26.465896 4342420
X26.467307 4343880
X26.527582 4345340
X26.530276 4346800
X26.563675 4348260
Xbreak
X26.563675 4348260
X26.565894 4349720
X26.568764 4351180
X26.570093 4352640
X26.575103 4354100
X26.576333 4355560
X26.577176 4357020
X26.579773 4357668
X26.581173 4359128
X26.588899 4360588
X26.591246 4362048
X26.614952 4363508
X26.650127 4364968
X26.651357 4366428
X26.653040 4367888
X26.654270 4369348
X26.681057 4370808
X26.682766 4372268
X26.684394 4373728
X26.685624 4375188
X26.696920 4376648
X26.698538 4378108
X26.699925 4379568
X26.737806 4381028
X26.739430 4382488
X26.741258 4383948
X26.742488 4385408
X26.745833 4386868
X26.747244 4388328
X26.799749 4389788
X26.801317 4391248
X26.881212 4392708
X26.882784 4394168
X26.884519 4395628
X26.885749 4397088
X26.887200 4398548
X26.887998 4400008
X26.892574 4400656
X26.897903 4402116
X26.899133 4403576
X26.900366 4405036
X26.901625 4406496
X26.903213 4407956
X26.905806 4409416
X26.915238 4410876
X26.916468 4412336
X26.918157 4413796
X26.919387 4415256
X26.985012 4416716
X26.986406 4418176
X26.998998 4419636
X27.004035 4421096
X27.005646 4422556
X27.049207 4424016
X27.052013 4425476
X27.053296 4426936
X27.063555 4428396
X27.065501 4429856
X27.066731 4431316
X27.067961 4432776
X27.125993 4434236
X27.128736 4435696
X27.134237 4437156
X27.136783 4438616
X27.207924 4440076
X27.209533 4441536
X27.211308 4442996
X27.214146 4444456
X27.220997 4445916
X27.222327 4446564
X27.224019 4447688
X27.225249 4449148
X27.226855 4450608
X27.228085 4452068
X27.229315 4453528
X27.230545 4454988
X27.231775 4456448
X27.233005 4457908
X27.266738 4459368
X27.268389 4460828
X27.270980 4462288
X27.279005 4463748
X27.279808 4465208
X27.337731 4465544
X27.339301 4467004
X27.341034 4468464
X27.342264 4469924
X27.357913 4471384
X27.359445 4472844
X27.362213 4474304
X27.363865 4475764
X27.365497 4477224
X27.387357 4478684
X27.389127 4480144
X27.390393 4481604
X27.390811 4483064
X27.444573 4483376
X27.446095 4484836
X27.447817 4486296
X27.449047 4487756
X27.452404 4489216
X27.454064 4490676
Xbreak
X27.454064 4490676
X27.455698 4492136
X27.521343 4493596
X27.523829 4495056
X27.545149 4496516
X27.546756 4497976
X27.548052 4499436
X27.548497 4500896
X27.553337 4501232
X27.556189 4502692
X27.557624 4504152
X27.560070 4505612
X27.561449 4507072
X27.562679 4508532
X27.563909 4509992
X27.575002 4511452
X27.576726 4512912
X27.619364 4514372
X27.621030 4515832
X27.622482 4517292
X27.622948 4518752
X27.625275 4519064
X27.672628 4520524
X27.674422 4521984
X27.705370 4523444
X27.724313 4524904
X27.726371 4526364
X27.727601 4527824
X27.728831 4529284
X27.730206 4530744
X27.731436 4532204
X27.732666 4533664
X27.734303 4535124
X27.735533 4536584
X27.736763 4538044
X27.738089 4539504
X27.739319 4540964
X27.739319 4540964
Xbreak
Xcolor orange
Xmarker x
X27.739319 4540964
Xbreak
Xmarker off
Xcolor black
X27.739319 4540964
X27.761375 4542424
X27.763024 4543884
X27.763584 4545344
X27.764090 4545680
X27.766948 4545992
X27.825077 4547452
X27.826307 4548912
X27.827730 4550372
X27.829483 4551832
X27.841838 4553292
X27.844337 4554752
X27.846202 4556212
X27.847444 4557672
X27.863141 4559132
X27.864517 4560592
X27.909757 4562052
X27.911552 4563512
X27.912782 4564972
X27.914015 4566432
X27.915245 4567892
X27.916475 4569352
X28.458592 4540964
X28.560915 4570812
X28.562344 4572272
X28.662031 4573732
X28.663672 4575192
X28.664902 4576652
X28.768024 4578112
X28.769693 4579572
X28.770923 4581032
X28.820042 4582492
X28.821289 4583952
X28.879204 4585412
X28.880760 4586872
X28.881990 4588332
X28.935995 4589792
X28.937636 4591252
X28.938866 4592712
X28.975232 4594172
X28.978184 4595632
X28.979414 4597092
X28.986860 4598552
X28.988671 4600012
X28.995843 4601472
X28.997640 4602932
X29.059831 4604392
X29.061570 4605852
X29.063455 4607312
X29.095877 4608772
X29.097569 4610232
X29.099132 4611692
X29.101406 4613152
X29.105077 4614612
X29.106393 4616072
X29.117041 4617532
X29.118742 4618992
X29.176136 4620452
X29.177631 4621912
X29.220433 4623372
X29.222223 4624832
X29.223540 4626292
X29.248426 4627752
X29.250480 4629212
X29.252060 4630672
X29.254486 4632132
X29.301786 4633592
X29.303551 4635052
X29.317197 4636512
X29.319012 4637972
X29.342030 4639432
X29.343952 4640892
X29.345182 4642352
X29.385772 4643812
X29.387546 4645272
X29.389138 4646732
X29.391555 4648192
X29.413796 4649652
X29.422328 4651112
X29.424639 4652572
X29.453153 4654032
X29.455638 4655492
X29.458329 4656952
X29.459606 4658412
X29.487579 4659872
X29.489686 4661332
X29.502429 4662792
X29.504020 4664252
X29.564908 4665712
X29.566439 4667172
X29.568198 4668632
X29.569520 4670092
X29.598943 4671552
X29.600709 4673012
X29.602394 4674472
X29.606584 4675932
X29.609033 4677392
X29.610286 4678852
X29.654302 4680312
X29.657226 4681772
X29.659653 4683232
X29.683268 4684692
Xbreak
X29.683268 4684692
X29.684693 4686152
X29.725728 4687612
X29.727528 4689072
X29.728758 4690532
X29.730304 4691992
X29.731534 4693452
X29.732764 4694912
X29.785407 4696372
X29.786796 4697832
X29.813566 4699292
X29.814975 4700752
X29.816205 4702212
X29.817435 4703672
X29.827697 4705132
X29.829110 4706592
X29.843338 4708052
X29.844751 4709512
X29.856754 4710972
X29.862815 4712432
X29.902156 4713892
X29.904947 4715352
X29.907402 4716812
X29.931270 4718272
X29.933741 4719732
X29.936133 4721192
X29.941800 4722652
X29.977276 4724112
X29.984095 4725572
X29.985884 4727032
X29.987146 4728492
X29.988376 4729952
X29.989606 4731412
X30.022565 4732872
X30.025250 4734332
X30.075735 4735792
X30.077320 4737252
X30.079019 4738712
X30.080249 4740172
X30.105227 4741632
X30.108082 4743092
X30.110545 4744552
X30.111886 4746012
X30.117022 4747472
X30.118481 4748932
X30.144285 4750392
X30.145698 4751852
X30.198955 4753312
X30.200445 4754772
X30.202278 4756232
X30.203508 4757692
X30.242136 4759152
X30.243791 4760612
X30.245319 4762072
X30.247423 4763532
X30.249215 4764992
X30.250805 4766452
X30.252035 4767912
X30.287516 4769372
X30.290026 4770832
X30.349562 4772292
X30.351248 4773752
X30.352884 4775212
X30.354114 4776672
X30.355732 4778132
X30.356962 4779592
X30.358508 4781052
X30.359088 4782512
X30.361727 4783160
X30.399847 4784620
X30.408191 4786080
X30.409809 4787540
X30.413565 4789000
X30.414869 4790460
X30.416387 4791920
X30.417617 4793380
X30.503428 4794840
X30.504812 4796300
X30.506612 4797760
X30.507842 4799220
X30.510234 4800680
X30.512600 4802140
X30.526424 4803600
X30.527654 4805060
X30.528884 4806520
X30.539686 4807980
X30.541148 4809440
X30.555330 4810900
X30.558373 4812360
X30.592561 4813820
X30.594010 4815280
X30.668304 4816740
X30.670129 4818200
X30.673284 4819660
X30.675213 4821120
X30.677745 4822580
X30.679121 4824040
X30.680351 4825500
X30.681277 4826960
X30.693949 4827608
X30.696426 4829068
X30.702624 4830528
Xbreak
X30.702624 4830528
X30.704405 4831988
X30.705970 4833448
X30.708327 4834908
X30.717114 4836368
X30.718541 4837828
X30.809751 4839288
X30.812458 4840748
X30.814896 4842208
X30.818859 4843668
X30.823564 4845128
X30.867355 4846588
X30.868941 4848048
X30.871956 4849508
X30.873186 4850968
X30.875177 4852428
X30.876407 4853888
X30.878280 4855348
X30.879654 4856808
X30.881351 4858268
X30.883020 4859728
X30.884369 4861188
X30.984395 4862648
X30.986629 4864108
X30.988417 4865568
X30.992566 4867028
X30.996184 4868488
X30.997845 4869948
X30.999617 4871408
X31.001097 4872868
X31.002949 4874328
X31.003529 4875788
X31.054185 4876436
X31.056158 4877896
X31.057388 4879356
X31.059566 4880816
X31.062124 4882276
X31.063354 4883736
X31.105917 4885196
X31.132693 4886656
X31.134662 4888116
X31.135947 4889576
X31.137177 4891036
X31.167856 4892496
X31.170394 4893956
X31.180074 4895416
X31.182847 4896876
X31.184077 4898336
X31.185307 4899796
X31.210451 4901256
X31.212799 4902716
X31.216798 4904176
X31.218857 4905636
X31.289523 4907096
X31.291101 4908556
X31.292331 4910016
X31.312673 4911476
X31.314305 4912936
X31.316007 4914396
X31.317652 4915856
X31.338657 4917316
X31.340103 4918776
X31.343450 4920236
X31.345068 4921696
X31.346997 4923156
X31.348252 4924616
X31.348832 4926076
X31.351389 4926724
X31.371386 4928184
X31.372772 4929644
X31.401947 4931104
X31.404201 4932564
X31.406022 4934024
X31.407252 4935484
X31.484043 4936944
X31.487131 4938404
X31.490140 4939864
X31.491375 4941324
X31.525822 4942784
X31.528314 4944244
X31.534564 4945704
X31.544507 4947164
X31.546351 4948624
X31.547581 4950084
X31.548811 4951544
X31.617329 4953004
X31.621544 4954464
X31.638539 4955924
X31.642422 4957384
X31.643866 4958844
X31.645096 4960304
X31.645676 4961764
X31.664007 4962412
X31.665504 4963872
X31.666925 4965332
X31.673845 4966792
X31.684253 4968252
X31.686098 4969712
X31.686981 4971172
X31.688211 4971976
X31.735365 4973436
X31.737199 4974896
Xbreak
X31.737199 4974896
X31.738429 4976356
X31.739060 4977816
X31.740290 4978472
X31.741520 4979932
X31.788794 4981392
X31.803095 4982852
X31.805202 4984312
X31.806432 4985772
X31.807683 4987232
X31.808913 4988692
X31.810143 4990152
X31.811810 4991612
X31.813040 4993072
X31.813040 4993072
Xbreak
Xcolor orange
Xmarker x
X31.813040 4993072
Xbreak
Xmarker off
Xcolor black
X31.813040 4993072
X31.830372 4994532
X31.832131 4995992
X31.836501 4997452
X31.838867 4998912
X31.840295 5000372
X31.844398 5001832
X31.847478 5003292
X31.871018 5004752
X31.872402 5006212
X31.887136 5007672
X31.911570 5009132
X31.913454 5010592
X31.914684 5012052
X31.924733 5013512
X31.925963 5014972
X31.937701 5016432
X31.939133 5017892
X31.974662 5019352
X32.959439 4993072
X33.060622 5020812
X33.063063 5022272
X33.162110 5023732
X33.163839 5025192
X33.165069 5026652
X33.268478 5028112
X33.269952 5029572
X33.271228 5031032
X33.369814 5032492
X33.373572 5033952
X33.387930 5035412
X33.390698 5036872
X33.392965 5038332
X33.470099 5039792
X33.472934 5041252
X33.479845 5042712
X33.491500 5044172
X33.493015 5045632
X33.494391 5047092
X33.543102 5048552
X33.544698 5050012
X33.546361 5051472
X33.599365 5052932
X33.601057 5054392
X33.602851 5055852
X33.604081 5057312
X33.605607 5058772
X33.607379 5060232
X33.608760 5061692
X33.662300 5063152
X33.665314 5064612
X33.722446 5066072
X33.723960 5067532
X33.725845 5068992
X33.728333 5070452
X33.735470 5071912
X33.743101 5073372
X33.781906 5074832
X33.783512 5076292
X33.785241 5077752
X33.786471 5079212
X33.837037 5080672
X33.838467 5082132
X33.847616 5083592
X33.849029 5085052
X33.922117 5086512
X33.924380 5087972
X33.925669 5089432
X33.927950 5090892
X33.929232 5092352
X33.973485 5093812
X33.976127 5095272
X33.987932 5096732
X33.989707 5098192
X33.990937 5099652
X34.037661 5101112
X34.039429 5102572
X34.040659 5104032
X34.041951 5105492
X34.127166 5106952
X34.129208 5108412
X34.133945 5109872
X34.135334 5111332
X34.145631 5112792
X34.147118 5114252
X34.153588 5115712
X34.156545 5117172
X34.173646 5118632
X34.175032 5120092
X34.193376 5121552
X34.194906 5123012
X34.247829 5124472
X34.249498 5125932
X34.250728 5127392
X34.251958 5128852
X34.311708 5130312
X34.313253 5131772
X34.333933 5133232
X34.335163 5134692
X34.336629 5136152
X34.338063 5137612
X34.383383 5139072
Xbreak
X34.383383 5139072
X34.385932 5140532
X34.393667 5141992
X34.394897 5143452
X34.396127 5144912
X34.422524 5146372
X34.425135 5147832
X34.466405 5149292
X34.469321 5150752
X34.470551 5152212
X34.472887 5153672
X34.524271 5155132
X34.527542 5156592
X34.528772 5158052
X34.530002 5159512
X34.532339 5160972
X34.558145 5162432
X34.559828 5163892
X34.591312 5165352
X34.603573 5166812
X34.605002 5168272
X34.606232 5169732
X34.642327 5171192
X34.644006 5172652
X34.645663 5174112
X34.646893 5175572
X34.650684 5177032
X34.652064 5178492
X34.701857 5179952
X34.703938 5181412
X34.745956 5182872
X34.747186 5184332
X34.749514 5185792
X34.751322 5187252
X34.795021 5188712
X34.797865 5190172
X34.800564 5191632
X34.802056 5193092
X34.803286 5194552
X34.804666 5196012
X34.839035 5197472
X34.841689 5198932
X34.886768 5200392
X34.888920 5201852
X34.890150 5203312
X35.112314 5207692
X35.112314 5207692
Xbreak
Xcolor orange
Xmarker x
X35.112314 5207692
Xbreak
Xmarker off
Xcolor black
X35.112314 5207692
X35.112314 5207692
Xbreak
Xcolor magenta
Xmarker circle
X35.112314 5207692
Xbreak
Xmarker off
Xcolor black
X35.112314 5207692
X35.113544 5209152
X35.114774 5210612
X35.116116 5212072
X35.117346 5213532
X35.118576 5214992
X35.136432 5216452
X35.144966 5217912
X35.146196 5219372
X35.162142 5220832
X35.163372 5222292
Xbreak
END_OF_FILE
if test 17579 -ne `wc -c <'examples/long.plot'`; then
    echo shar: \"'examples/long.plot'\" unpacked with wrong size!
fi
# end of 'examples/long.plot'
fi
if test -f 'grid.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'grid.c'\"
else
echo shar: Extracting \"'grid.c'\" \(18865 characters\)
sed "s/^X//" >'grid.c' <<'END_OF_FILE'
X/* $Header: grid.c,v 1.12 92/08/04 17:55:02 mogul Exp $ */
X
X/*
X *               Copyright 1989, 1992 Digital Equipment Corporation
X *                          All Rights Reserved
X * 
X * 
X * Permission to use, copy, and modify this software and its documentation
X * is hereby granted only under the following terms and conditions.  Both
X * the above copyright notice and this permission notice must appear in
X * all copies of the software, derivative works or modified versions, and
X * any portions threof, and both notices must appear in supporting
X * documentation.
X * 
X * Users of this software agree to the terms and conditions set forth
X * herein, and hereby grant back to Digital a non-exclusive, unrestricted,
X * royalty-free right and license under any changes, enhancements or
X * extensions made to the core functions of the software, including but
X * not limited to those affording compatibility with other hardware or
X * software environments, but excluding applications which incorporate
X * this software.  Users further agree to use their best efforts to return
X * to Digital any such changes, enhancements or extensions that they make
X * and inform Digital of noteworthy uses of this software.  Correspondence
X * should be provided to Digital at:
X * 
X *                       Director of Licensing
X *                       Western Research Laboratory
X *                       Digital Equipment Corporation
X *                       250 University Avenue
X *                       Palo Alto, California  94301  
X * 
X * This software may be distributed (but not offered for sale or
X * transferred for compensation) to third parties, provided such third
X * parties agree to abide by the terms and conditions of this notice.
X * 
X * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS
X * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
X * WARRANTIES OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL
X * EQUIPMENT CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
X * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
X * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X */
X
X/* 
X * grid.c - Compute and generate grids and axes
X * 
X * Author:	Christopher A. Kent
X * 		Western Research Laboratory
X * 		Digital Equipment Corporation
X * Date:	Wed Jan  4 1989
X */
X
X/*
X * $Log:	grid.c,v $
X * Revision 1.12  92/08/04  17:55:02  mogul
X * undo RCS botch
X * 
X * Revision 1.11  1992/06/17  22:14:41  kent
X * Make axis specs with max < min work, fix some bugs with centering
X * and multiple args.
X *
X * Revision 1.10  1992/06/16  01:48:11  kent
X * Make y positioning and centering and such work right.
X *
X * Revision 1.9  1992/06/16  00:41:35  kent
X * Hokey fix for a bug where min and max of a scale end up the same.
X *
X * Revision 1.8  1992/04/15  22:24:34  kent
X * log Y label was being placed incorrectly
X *
X * Revision 1.7  1992/04/07  18:11:09  kent
X * Made log scales support datalabels.
X *
X * Revision 1.6  1992/04/07  18:01:19  kent
X * Can't draw the title until after the ticks are labelled, or the
X * placement isn't right.
X *
X * Revision 1.5  1992/04/02  00:45:01  kent
X * Changes to handle lots of points; when using dataticks, the axis
X * routines could get too big and overflow the operand stack. As
X * a result, the output PostScript code is even uglier.
X *
X * Revision 1.4  1992/04/01  23:27:34  kent
X * Added datalabel verb, fixed a bug in handling blank input lines.
X *
X * Revision 1.3  1992/03/31  23:13:12  kent
X * Added "dataticks" verb.
X *
X * Revision 1.2  1992/03/30  23:33:47  kent
X * Added halfopen, halfticks grid styles, range frames, and gray.
X *
X * Revision 1.1  1992/03/20  21:25:43  kent
X * Initial revision
X *
X * Revision 1.9  92/02/21  17:13:20  mogul
X * Added Digital license info
X * 
X * Revision 1.8  91/02/04  16:46:25  mogul
X * set variable "font" before using it, even when not labelling axes.
X * 
X * Revision 1.7  90/11/05  11:09:51  reid
X * Checking in Chris Kent's changes before I start making some.
X * 
X * Revision 1.6  89/01/27  15:54:19  kent
X * lint.
X * 
X * Revision 1.5  89/01/11  09:22:56  kent
X * Use floor() to properly handle axis limit computations.
X * 
X * Revision 1.4  89/01/09  22:18:24  kent
X * Added log scales.
X * 
X * Revision 1.3  89/01/04  17:30:24  kent
X * Made command line arguments override compiled-in defaults for
X * all plots in a run, not just the first one. 
X * 
X * Revision 1.2  89/01/04  15:21:52  kent
X * Massive renaming. No functional change.
X * 
X * Revision 1.1  89/01/04  13:57:40  kent
X * Initial revision
X * 
X */
X
Xstatic char rcs_ident[] = "$Header: grid.c,v 1.12 92/08/04 17:55:02 mogul Exp $";
X
X#include <stdio.h>
X
X#include "psgraph.h"
X
Xgrid_t
Xgridval(cp)
Xchar *cp;
X{
X	if ( isdigit(*cp)) {
X		switch(atoi(cp)) {
X		case 0: return NONE;
X		case 1:	return OPEN;
X		case 2: return TICKS;
X		case 3: return FULL;
X		case 4: return HALFOPEN;
X		case 5: return HALFTICKS;
X		default: return FULL;
X		}
X	} else if ( strcmp(cp,"none")==0 )
X		return NONE;
X	else if ( strcmp(cp,"open")==0 )
X		return OPEN;
X	else if ( strncmp(cp,"tick",4)==0 )
X		return TICKS;
X	else if ( strcmp(cp,"full")==0 )
X		return FULL;
X	else if ( strcmp(cp,"halfopen")==0 )
X		return HALFOPEN;
X	else if ( strncmp(cp,"halftick",8)==0 )
X		return HALFTICKS;
X	return FULL;
X}
X
Xlimargs(p,argc,argv,arg)
Xlimit_t	*p;
Xint	argc, arg;
Xchar	**argv;
X{
X	if ( arg < argc ** argv[arg] == 'l' ) {
X		p->tform = LOG10;
X		arg++;
X	}
X	if ( isfloat(argv[arg]) ) {
X		p->minflag = TRUE;
X		p->min = atof(argv[arg++]);
X		if ( isfloat(argv[arg]) ) {
X			p->maxflag = TRUE;
X			p->max = atof(argv[arg++]);
X			if ( isfloat(argv[arg]) ) {
X				p->distf = TRUE;
X				p->dist = atof(argv[arg++]);
X			}
X		}
X	}
X	return arg;
X}
X
X/*
X * draw the axes - define routines to draw the plot axes based on the
X * parameters.  Because we may want to do a translate (to center the graph)
X * based on the max and min, we can't just emit the commands here; because this
X * could get arbitrarily large and overflow the operand stack, we use a hack to
X * collapse that stack, at the cost of more obscure code.
X */
X
XsetupAxes()
X{
X	minX = 0;
X	minY = 0;
X	maxX = MAX(maxX, sx(Xaxis.gmax));
X	maxY = MAX(maxY, sy(Yaxis.gmax));
X}
X
XdoXaxis()
X{
X    	int i, startTemp = CurrentTemp;
X	
X	startGridTemp();
X	
X	if (Xaxis.tform == IDENT)
X		linearX();
X	else
X		logX();
X
X	endGridTemp();
X	printf("/drawXaxis {\n");	/* hack hack */
X	for (i = startTemp; i < CurrentTemp; i++)
X	    printf("\tgt%03d\n", i);
X	printf("}def\n");
X}
X
XdoYaxis()
X{
X    	int i, startTemp = CurrentTemp;
X	
X	startGridTemp();
X	
X	if (Yaxis.tform == IDENT)
X		linearY();
X	else
X		logY();
X
X	endGridTemp();
X	printf("/drawYaxis {\n");	/* hack hack */
X	for (i = startTemp; i < CurrentTemp; i++)
X	    printf("\tgt%03d\n", i);
X	printf("}def\n");
X}
X
XdoTitle()
X{
X	if (Title.title != NULL)
X		axisText(Title.title, NORTH, 
X			Title.font ? Title.font : TextFont);
X}
X
X#define	GT(a,b)		(argp->distg>0 ? ((a)-(b))>0 : ((a)-(b))<0)
X#define LT(a,b)		(argp->distg>0 ? ((a)-(b))<0 : ((a)-(b))>0)
X
XlinearX()
X{
X	register axis_t *argp;
X	char *font;
X	float x;
X	float amin, amax;
X	float agray, tgray;
X	int i;
X
X	argp = &Xaxis;
X	agray = argp->axisgray;
X	tgray = argp->tickgray;
X	font = argp->font ? argp->font : TextFont;
X	amin = argp->gmin; amax = argp->gmax;
X
X	/*
X	 * Determine how much of the frame to draw
X	 */
X	if (argp->rangeframe) {
X	    amin = argp->min; amax = argp->max;
X	}
X	
X	/*
X	 * Draw the frame 
X	 */
X	if ( argp->gridtype != NONE ) {
X		gridLine(amin, Yaxis.gmin, amax, Yaxis.gmin, agray);
X		if (!argp->halfgrid)
X		    gridLine(amin, Yaxis.gmax, amax, Yaxis.gmax, agray);
X	}
X
X	/*
X	 * Label the endpoints
X	 */
X	if (DoAxisLabels) {
X		tickText(Xaxis.gmin, Yaxis.gmin, Xaxis.gmin, SOUTH, font);
X		tickText(Xaxis.gmax, Yaxis.gmin, Xaxis.gmax, SOUTH, font);
X	}
X
X	/*
X	 * Do data-only ticks
X	 */
X	if (argp->datatick) {
X	    for (i = 0; i < NumTokens; i++) {
X		if (Token[i].type != POINT)
X		    continue;
X		x = Token[i].val[0];
X		if (argp->gridtype == FULL)
X		    gridLine(x, Yaxis.gmin, x, Yaxis.gmax, tgray);
X		else {
X		    tick(x, Yaxis.gmin, NORTH, TRUE, tgray);
X		    if (!argp->halfgrid)
X			tick(x, Yaxis.gmax, SOUTH, TRUE, tgray);
X		}
X		if (argp->datalabel)
X		    tickText(x, Yaxis.gmin, x, SOUTH, font);
X	    }
X	}
X
X	/*
X	 * Draw the ticks that will have labels on them (or just the labels
X	 * in the case of dataticks, ugh)
X	 */
X	x = argp->gmin;
X
X	while ( LT(x, argp->gmax) ) {
X	    if ( GT(x, argp->gmin) ) {
X		if (!argp->datatick)
X		    if ( argp->gridtype==FULL )
X			gridLine(x, Yaxis.gmin, x, Yaxis.gmax, tgray);
X		    else if ( argp->gridtype==TICKS ) {
X			tick(x, Yaxis.gmin, NORTH, TRUE, tgray);
X			if (!argp->halfgrid)
X			    tick(x, Yaxis.gmax, SOUTH, TRUE, tgray);
X		    }
X		if ( DoAxisLabels )
X		    tickText(x, Yaxis.gmin, x, SOUTH, font);
X	    }
X	    x += argp->distg;
X	}
X
X	/*
X	 * Draw the "title" of the axis
X	 */
X	if ( argp->label != NULL )
X		axisText(argp->label, SOUTH, font);
X
X	if (argp->datatick)
X	    return;
X
X	/*
X	 * Draw the ticks for the endpoints
X	 */
X	if ( argp->gridtype == FULL ) {
X	    gridLine(Xaxis.gmin, Yaxis.gmin, Xaxis.gmin, Yaxis.gmax, agray);
X	    gridLine(Xaxis.gmax, Yaxis.gmin, Xaxis.gmax, Yaxis.gmax, agray);
X	} else if ( argp->gridtype==TICKS ) {
X	    tick(Xaxis.gmin, Yaxis.gmin, NORTH, TRUE, tgray);
X	    tick(Xaxis.gmax, Yaxis.gmin, NORTH, TRUE, tgray);
X	    if (!argp->halfgrid) {
X		tick(Xaxis.gmin, Yaxis.gmax, SOUTH, TRUE, tgray);
X		tick(Xaxis.gmax, Yaxis.gmax, SOUTH, TRUE, tgray);
X	    }
X	}
X
X	/*
X	 * Draw the secondary ticks
X	 */
X	if ( argp->tickflag ) {
X		if (argp->minflag && argp->distf)
X			x = argp->gmin;
X		else
X			x = argp->pmin;
X		while ( LT(x, argp->gmax) ) {
X			if ( GT(x, argp->gmin) ) {
X				tick(x, Yaxis.gmin, NORTH, FALSE, tgray);
X				if (!argp->halfgrid)
X				    tick(x, Yaxis.gmax, SOUTH, FALSE, tgray);
X			}
X			x += argp->tick;
X		}
X	}
X}
X
XlogX()
X{
X	register axis_t *argp;
X	char	*font;
X	float	x, d1, d2, dist;
X	float	amin, amax;
X	float agray, tgray;
X	int i;
X
X	argp = &Xaxis;
X	agray = argp->axisgray;
X	tgray = argp->tickgray;
X	font = argp->font ? argp->font : TextFont;
X	amin = argp->gmin; amax = argp->gmax;
X
X	if (argp->rangeframe) {
X	    amin = argp->min; amax = argp->max;
X	}
X
X	if ( argp->gridtype != NONE ) {
X		gridLine(amin, Yaxis.gmin, amax, Yaxis.gmin, agray);
X		if (!argp->halfgrid)
X		    gridLine(amin, Yaxis.gmax, amax, Yaxis.gmax, agray);
X	}
X	if (DoAxisLabels) {
X		tickText(argp->gmin, Yaxis.gmin, argp->gmin, SOUTH, font);
X		tickText(argp->gmax, Yaxis.gmin, argp->gmax, SOUTH, font);
X	}
X
X	if ( argp->gridtype == FULL ) {
X	    gridLine(Xaxis.gmin, Yaxis.gmin, Xaxis.gmin, Yaxis.gmax, agray);
X	    gridLine(Xaxis.gmax, Yaxis.gmin, Xaxis.gmax, Yaxis.gmax, agray);
X	} else if ( argp->gridtype==TICKS ) {
X	    tick(Xaxis.gmin, Yaxis.gmin, NORTH, TRUE, tgray);
X	    tick(Xaxis.gmax, Yaxis.gmin, NORTH, TRUE, tgray);
X	    if (!argp->halfgrid) {
X		tick(Xaxis.gmin, Yaxis.gmax, SOUTH, TRUE, tgray);
X		tick(Xaxis.gmax, Yaxis.gmax, SOUTH, TRUE, tgray);
X	    }
X	}
X
X	if (argp->datatick) {
X	    for (i = 0; i < NumTokens; i++) {
X		if (Token[i].type != POINT)
X		    continue;
X		x = Token[i].val[0];
X		if (argp->gridtype == FULL)
X		    gridLine(x, Yaxis.gmin, x, Yaxis.gmax, tgray);
X		else {
X		    tick(x, Yaxis.gmin, NORTH, TRUE, tgray);
X		    if (!argp->halfgrid)
X			tick(x, Yaxis.gmax, SOUTH, TRUE, tgray);
X		}
X		if (argp->datalabel)
X		    tickText(x, Yaxis.gmin, x, SOUTH, font);
X	    }
X	}
X
X	if ( argp->label != NULL )
X		axisText(argp->label, SOUTH, font);
X
X	x = argp->gmin;
X
X	d1 = ipow(10.0, (int)floor(log10(x)));
X	while ( LT(d1, argp->gmax) ) {
X	    d2 = (argp->distg > 0) ? 10.0 * d1 : d1 / 10.0;
X	    if ( GT(d1, argp->gmin) ) {
X		if (!argp->datatick)
X		    if ( argp->gridtype==FULL )
X			gridLine(d1, Yaxis.gmin, d1, Yaxis.gmax, tgray);
X		    else if ( argp->gridtype==TICKS ) {
X			tick(d1, Yaxis.gmin, NORTH, TRUE, tgray);
X			if (!argp->halfgrid)
X			    tick(d1, Yaxis.gmax, SOUTH, TRUE, tgray);
X		    }
X		if ( DoAxisLabels )
X		    tickText(d1, Yaxis.gmin, d1, SOUTH, font);
X	    }
X	    if ( argp->intervals && !argp->datatick ) {
X		dist = copysign(d2 / argp->intervals, argp->distg);
X		x = d1;
X		while (LT(x, d2) && LT(x, argp->gmax)) {
X		    if ( GT(x, argp->gmin) ) {
X			tick(x, Yaxis.gmin, NORTH, FALSE, tgray);
X			if (!argp->halfgrid)
X			    tick(x, Yaxis.gmax, SOUTH, FALSE, tgray);
X		    }
X		    x += dist;
X		}
X	    }
X	    d1 = d2;
X	}
X}
X
XlinearY()
X{
X	register axis_t *argp;
X	char *font;
X	float y;
X	float amin, amax;
X	float agray, tgray;
X	int i;
X
X	argp = &Yaxis;
X	font = argp->font ? argp->font : TextFont;
X	agray = argp->axisgray;
X	tgray = argp->tickgray;
X	amin = argp->gmin; amax = argp->gmax;
X
X	if (argp->rangeframe) {
X	    amin = argp->min; amax = argp->max;
X	}
X
X	if ( argp->gridtype != NONE ) {
X		gridLine(Xaxis.gmin, amin, Xaxis.gmin, amax, agray);
X		if (!argp->halfgrid)
X		    gridLine(Xaxis.gmax, amin, Xaxis.gmax, amax, agray);
X	}
X
X	if (DoAxisLabels) {
X		tickText(Xaxis.gmin, Yaxis.gmin, Yaxis.gmin, WEST, font);
X		tickText(Xaxis.gmin, Yaxis.gmax, Yaxis.gmax, WEST, font);
X	}
X
X	if (argp->datatick) {
X	    for (i = 0; i < NumTokens; i++) {
X		if (Token[i].type != POINT)
X		    continue;
X		y = Token[i].val[1];
X		if (argp->gridtype == FULL)
X		    gridLine(Xaxis.gmin, y, Xaxis.gmax, y, tgray);
X		else {
X		    tick(Xaxis.gmin, y, EAST, TRUE, tgray);
X		    if (!argp->halfgrid)
X			tick(Xaxis.gmax, y, WEST, TRUE, tgray);
X		}
X		if (argp->datalabel)
X		    tickText(Xaxis.gmin, y, y, WEST, font);
X	    }
X	}
X
X	y = argp->gmin;
X	
X	while ( LT(y, argp->gmax) ) {
X	    if ( GT(y, argp->gmin) ) {
X		if (!argp->datatick)
X		    if ( argp->gridtype==FULL )
X			gridLine(Xaxis.gmin, y, Xaxis.gmax, y, tgray);
X		    else if ( argp->gridtype==TICKS ) {
X			tick(Xaxis.gmin, y, EAST, TRUE, tgray);
X			if (!argp->halfgrid)
X			    tick(Xaxis.gmax, y, WEST, TRUE, tgray);
X		    }
X		if ( DoAxisLabels )
X		    tickText(Xaxis.gmin, y, y, WEST, font);
X	    }
X	    y += argp->distg;
X	}
X
X	if (argp->label != NULL)
X		axisText(argp->label, WEST, font);
X	
X	if (argp->datatick)
X	    return;
X
X	if ( argp->gridtype == FULL ) {
X	    gridLine(Xaxis.gmin, Yaxis.gmin, Xaxis.gmax, Yaxis.gmin, agray);
X	    gridLine(Xaxis.gmin, Yaxis.gmax, Xaxis.gmax, Yaxis.gmax, agray);
X	} else if ( argp->gridtype==TICKS ) {
X	    tick(Xaxis.gmin, Yaxis.gmin, EAST, TRUE, tgray);
X	    tick(Xaxis.gmin, Yaxis.gmax, EAST, TRUE, tgray);
X	    if (!argp->halfgrid) {
X		tick(Xaxis.gmax, Yaxis.gmin, WEST, TRUE, tgray);
X		tick(Xaxis.gmax, Yaxis.gmax, WEST, TRUE, tgray);
X	    }
X	}
X	    
X	if ( argp->tickflag ) {
X		if ( argp->minflag && argp->distf )
X			y = argp->gmin;
X		else
X			y = argp->pmin;
X		while ( LT(y, argp->gmax) ) {
X			if ( GT(y, argp->gmin) ) {
X				tick(Xaxis.gmin, y, EAST, FALSE, tgray);
X				if (!argp->halfgrid)
X				    tick(Xaxis.gmax, y, WEST, FALSE, tgray);
X			}
X			y += argp->tick;
X		}
X	}
X}
X
XlogY()
X{
X	register axis_t *argp;
X	char *font;
X	float y, d1, d2, dist;
X	float	amin, amax;
X	float agray, tgray;
X	int i;
X
X	argp = &Yaxis;
X	agray = argp->axisgray;
X	tgray = argp->tickgray;
X	font = argp->font ? argp->font : TextFont;
X	amin = argp->gmin; amax = argp->gmax;
X
X	if (argp->rangeframe) {
X	    amin = argp->min; amax = argp->max;
X	}
X
X	if ( argp->gridtype != NONE ) {
X		gridLine(Xaxis.gmin, amin, Xaxis.gmin, amax, agray);
X		if (!argp->halfgrid)
X		    gridLine(Xaxis.gmax, amin, Xaxis.gmax, amax, agray);
X	}
X	if (DoAxisLabels) {
X		tickText(Xaxis.gmin, Yaxis.gmin, Yaxis.gmin, WEST, font);
X		tickText(Xaxis.gmin, Yaxis.gmax, Yaxis.gmax, WEST, font);
X	}
X
X	if ( argp->gridtype == FULL ) {
X	    gridLine(Xaxis.gmin, Yaxis.gmin, Xaxis.gmax, Yaxis.gmin, agray);
X	    gridLine(Xaxis.gmin, Yaxis.gmax, Xaxis.gmax, Yaxis.gmax, agray);
X	} else if ( argp->gridtype==TICKS ) {
X	    tick(Xaxis.gmin, Yaxis.gmin, EAST, TRUE, tgray);
X	    tick(Xaxis.gmin, Yaxis.gmax, EAST, TRUE, tgray);
X	    if (!argp->halfgrid) {
X		tick(Xaxis.gmax, Yaxis.gmin, WEST, TRUE, tgray);
X		tick(Xaxis.gmax, Yaxis.gmax, WEST, TRUE, tgray);
X	    }
X	}
X
X	if (argp->datatick) {
X	    for (i = 0; i < NumTokens; i++) {
X		if (Token[i].type != POINT)
X		    continue;
X		y = Token[i].val[1];
X		if (argp->gridtype == FULL)
X 		    gridLine(Xaxis.gmin, y, Xaxis.gmax, y, tgray);
X		else {
X		    tick(Xaxis.gmin, y, EAST, TRUE, tgray);
X		    if (!argp->halfgrid)
X			tick(Xaxis.gmax, y, WEST, TRUE, tgray);
X		}
X		if (argp->datalabel)
X		    tickText(Xaxis.gmin, y, y, WEST, font);
X	    }
X	}
X
X	if ( argp->label != NULL )
X		axisText(argp->label, WEST, font);
X
X	y = argp->gmin;
X		
X	d1 = ipow(10.0, (int)floor(log10(y)));
X	while (LT(d1, argp->gmax)) {
X	    d2 = (argp->distg > 0) ? 10.0 * d1 : d1 / 10.0;
X	    if ( GT(d1, argp->gmin) ) {
X		if (!argp->datatick)
X		    if ( argp->gridtype==FULL )
X			gridLine(Xaxis.gmin, d1, Xaxis.gmax, d1, tgray);
X		    else if ( argp->gridtype==TICKS ) {
X			tick(Xaxis.gmin, d1, EAST, TRUE, tgray);
X			if (!argp->halfgrid)
X			    tick(Xaxis.gmax, d1, WEST, TRUE, tgray);
X		    }
X		if ( DoAxisLabels )
X		    tickText(Xaxis.gmin, d1, d1, WEST, font);
X	    }
X	    if ( argp->intervals && !argp->datatick ) {
X		dist = copysign(d2 / argp->intervals, argp->distg);
X		y = d1;
X		while ( LT(y, d2) && LT(y, argp->gmax)) {
X		    if ( GT(y, argp->gmin) ) {
X			tick(Xaxis.gmin, y, EAST, FALSE, tgray);
X			if (!argp->halfgrid)
X			    tick(Xaxis.gmax, y, WEST, FALSE, tgray);
X		    }
X		    y += dist;
X		}
X	    }
X	    d1 = d2;
X	}
X}
X
X/*
X *----------------------------------------------------------------------
X *
X * GRID COMPUTATION ROUTINES
X *
X * These routines are from ACM Collected Algorithms, Number 463.
X *
X * Author: C.R.Lewart
X */
X
Xfloat ipow(x,i)
Xfloat x;
Xint i;
X{
X	float	res;
X	
X	res = 1.0;
X	if ( i > 0 )
X		while ( i-- > 0 )
X			res *= x;
X	else
X		while ( i++ < 0 )
X			res /= x;
X	return res;
X}			
X
X/*
X * scale1
X *
X * Given data extremes xmin and xmax, and number of desired grid lines n
X * (advisory only), compute plot minimum and maximum xpmin and xpmax with
X * distance between grid lines dist.
X *
X * Translated from FORTRAN to C by Bob Brown.
X */
X
Xscale1(xmin, xmax, n, xpmin, xpmax, dist)
Xfloat	xmin, xmax;
Xint	n;
Xfloat	*xpmin, *xpmax, *dist;
X{
X	static float vint[] = { 1.0, 2.0, 5.0, 10.0 };
X	static float sqr[] = { 1.414213562373, 3.162277660168, 7.071067811865 };
X	static float del = 0.000001;
X	float a, al, b, fm;
X	int nal, m, i;
X
X	if (xmax == xmin)
X	    xmax += 1.0;
X	a = fabs((xmax-xmin)/(float)n);
X	al = log10(a);
X	nal = (int)al;
X	if ( a < 1.0 )
X		nal -= 1;
X	b = a/ipow(10.0, nal);
X	for ( i=0 ; i<3 ; i++ )
X		if ( b < sqr[i] )
X			break;
X	*dist = copysign(vint[i] * ipow(10.0, nal), (xmax - xmin));
X	fm = xmin / *dist;
X	m = fm < 0.0 ? (int)fm - 1 : (int)fm;
X	if ( fabs((float)m+1.0-fm) < del )
X		m += 1;
X	*xpmin = *dist * (float)m;
X	fm = xmax / *dist;
X	m = fm < -1.0 ? (int)fm : (int)fm + 1;
X	if ( fabs(fm+1.0-(float)m) < del )
X		m -= 1;
X	*xpmax = *dist * (float)m;
X	if ( *xpmin > xmin )
X		*xpmin = xmin;
X	if ( *xpmax < xmax )
X		*xpmax = xmax;
X}
END_OF_FILE
if test 18865 -ne `wc -c <'grid.c'`; then
    echo shar: \"'grid.c'\" unpacked with wrong size!
fi
# end of 'grid.c'
fi
if test -f 'output.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'output.c'\"
else
echo shar: Extracting \"'output.c'\" \(20906 characters\)
sed "s/^X//" >'output.c' <<'END_OF_FILE'
X/* $Header: output.c,v 1.10 92/08/04 17:55:10 mogul Exp $ */
X
X/*
X *               Copyright 1989, 1992 Digital Equipment Corporation
X *                          All Rights Reserved
X * 
X * 
X * Permission to use, copy, and modify this software and its documentation
X * is hereby granted only under the following terms and conditions.  Both
X * the above copyright notice and this permission notice must appear in
X * all copies of the software, derivative works or modified versions, and
X * any portions threof, and both notices must appear in supporting
X * documentation.
X * 
X * Users of this software agree to the terms and conditions set forth
X * herein, and hereby grant back to Digital a non-exclusive, unrestricted,
X * royalty-free right and license under any changes, enhancements or
X * extensions made to the core functions of the software, including but
X * not limited to those affording compatibility with other hardware or
X * software environments, but excluding applications which incorporate
X * this software.  Users further agree to use their best efforts to return
X * to Digital any such changes, enhancements or extensions that they make
X * and inform Digital of noteworthy uses of this software.  Correspondence
X * should be provided to Digital at:
X * 
X *                       Director of Licensing
X *                       Western Research Laboratory
X *                       Digital Equipment Corporation
X *                       250 University Avenue
X *                       Palo Alto, California  94301  
X * 
X * This software may be distributed (but not offered for sale or
X * transferred for compensation) to third parties, provided such third
X * parties agree to abide by the terms and conditions of this notice.
X * 
X * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS
X * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
X * WARRANTIES OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL
X * EQUIPMENT CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
X * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
X * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X */
X
X/* 
X * output.c - Spit out the PostScript
X * 
X * Author:	Christopher A. Kent
X * 		Western Research Laboratory
X * 		Digital Equipment Corporation
X * Date:	Wed Jan  4 1989
X */
X
X/*
X * $Log:	output.c,v $
X * Revision 1.10  92/08/04  17:55:10  mogul
X * undo RCS botch
X * 
X * Revision 1.9  1992/07/16  20:07:09  cak
X * Fix markergray implementation so it doesn't blow away the effects of color.
X *
X * Revision 1.8  1992/06/17  22:14:41  kent
X * Make axis specs with max < min work, fix some bugs with centering
X * and multiple args.
X *
X * Revision 1.7  1992/06/16  01:48:11  kent
X * Make y positioning and centering and such work right.
X *
X * Revision 1.6  1992/04/06  21:14:03  kent
X * Broke the bounding box computation last time 'round. Fixed.
X *
X * Revision 1.5  1992/04/02  00:45:01  kent
X * Changes to handle lots of points; when using dataticks, the axis
X * routines could get too big and overflow the operand stack. As
X * a result, the output PostScript code is even uglier.
X *
X * Revision 1.4  1992/03/31  02:31:34  kent
X * Added markergray verb and fixed inverted gray values.
X *
X * Revision 1.3  1992/03/31  00:07:39  kent
X * Added markerscale verb.
X *
X * Revision 1.2  1992/03/30  23:33:47  kent
X * Added halfopen, halfticks grid styles, range frames, and gray.
X *
X * Revision 1.1  1992/03/20  21:25:43  kent
X * Initial revision
X *
X * Revision 1.16  92/02/21  17:13:23  mogul
X * Added Digital license info
X * 
X * Revision 1.15  91/02/04  17:03:22  mogul
X * Break up long sets of text commands to avoid producing
X * PostScript with excessively long lines (hard to email).
X * 
X * 
X * Revision 1.14  91/02/04  16:48:27  mogul
X * Don't emit color changes when not necessary (saves space in
X * output file).
X * 
X * Revision 1.13  91/02/04  16:31:05  mogul
X * fixed color support for text, markers
X * 
X * Revision 1.12  90/12/11  20:41:55  reid
X * Added support for new "color" and "linewidth" options.
X * 
X * Revision 1.11  90/11/05  11:11:44  reid
X * Checking in Chris Kent's changes of June 1989
X * 
X * Revision 1.10  89/03/01  10:44:40  kent
X * NORTH and WEST axis text must be adjusted based on point size, since the
X * code in the prologue "unadjusts" it based on the point size.
X * 
X * Revision 1.9  89/02/03  09:33:23  kent
X * Make splines work on log scales.
X * 
X * Revision 1.8  89/01/27  15:56:15  kent
X * Line style "off" has to be handled in code, since there's no way I can
X * cleanly use setdash to draw an "empty" line. Also fixed problems with
X * axisText on axes with non-zero origins.
X * 
X * Revision 1.7  89/01/11  09:14:27  kent
X * Removed some internal knowledge about the semantics of line types. This
X * is all in the PostScript now.
X * 
X * Revision 1.6  89/01/10  18:19:55  kent
X * Moved marker code to prolog, added error checking and messages.
X * 
X * Revision 1.5  89/01/09  22:18:45  kent
X * Added log scales.
X * 
X * Revision 1.4  89/01/04  17:40:56  kent
X * Moved font stuff from main.c to output.c.
X * newfont() sets PS fontsize variable so white background is the right size.
X * 
X * Revision 1.3  89/01/04  17:30:31  kent
X * Made command line arguments override compiled-in defaults for
X * all plots in a run, not just the first one. 
X * 
X * Revision 1.2  89/01/04  15:22:08  kent
X * Massive renaming. No functional change.
X * 
X * Revision 1.1  89/01/04  13:57:59  kent
X * Initial revision
X * 
X */
X
Xstatic char rcs_ident[] = "$Header: output.c,v 1.10 92/08/04 17:55:10 mogul Exp $";
X
X#include <stdio.h>
X#include <assert.h>
X
X#include "psgraph.h"
X
Xtypedef struct _plotpoint {
X	float x, y;
X}plotpoint_t;
X
X/*
X * doplot - generate all the output text for the plot.
X *
X * BUG: leaks storage if called multiple times.
X */
X
Xdoplot()
X{
X	int	 i, numpoints, sizeofpoints;
X	plotpoint_t	*points;
X
X	CurrentPage++;
X	printf("%%%%Page: %d %d\n", CurrentPage, CurrentPage);
X	printf("StartPSGraph\n");
X	printf("/saveIt save def\ngsave\n/solid f\n");
X	TextFont = TEXTFONT;
X	CurrentFont = NULL;
X	newfont(TextFont);
X
X/**/
X
X	setupAxes();
X
X	doXaxis();
X
X	doYaxis();
X
X	printf("/drawTitle [\n");
X	doTitle();
X	printf("] cvx bind def\n");
X
X	if (Preview)
X		printf("1 1 translate\n");
X
X	if (Xcenter != 0.0) {		/* do centering */
X		printf("%f %f sub 2 div 0 translate\n", 
X			Xcenter, Xaxis.size);
X		/* must adjust bbox */
X		minX += (Xcenter - Xaxis.size) / 2.0;
X		maxX += (Xcenter - Xaxis.size) / 2.0;
X		/* move Y origin to 0 */
X		printf("0 %f translate\n", -minY);
X		maxY -= minY; minY = 0.0;
X	} else {
X		printf("%f %f translate\n",	/* move origin to 0,0 */
X			-minX, -minY);
X		maxX -= minX; minX = 0.0;
X		maxY -= minY; minY = 0.0;
X	}
X	printf("drawXaxis drawYaxis drawTitle\n");
X
X	MinX = MIN(minX, MinX);
X	MinY = MIN(minY, MinY);
X	MaxX = MAX(maxX, MaxX);
X	MaxY = MAX(maxY, MaxY);
X
X	sizeofpoints = 10;
X	points=(plotpoint_t *)calloc(10,sizeof(plotpoint_t));
X	numpoints = 0;
X	cliplimits(Xaxis.gmin-ClipDist/Xaxis.size*(Xaxis.gmax-Xaxis.gmin),
X		   Yaxis.gmin-ClipDist/Yaxis.size*(Yaxis.gmax-Yaxis.gmin),
X		   Xaxis.gmax+ClipDist/Xaxis.size*(Xaxis.gmax-Xaxis.gmin),
X		   Yaxis.gmax+ClipDist/Yaxis.size*(Yaxis.gmax-Yaxis.gmin),
X		   Xaxis.distg < 0, Yaxis.distg < 0);
X	for(i=0 ; i<NumTokens; i++) {
X		switch(Token[i].type) {
X		case TRANS:
X			if (numpoints > 0) {
X				dumppoints(points, numpoints);
X				numpoints = 0;
X			}
X			TransparentLabels = Token[i].ival;
X			break;
X		case BREAK:
X			if ( numpoints > 0 ) {
X				dumppoints(points,numpoints);
X				numpoints = 0;
X			}
X			break;
X		case LINETYPE:
X			if ( numpoints > 0 ) {
X				dumppoints(points,numpoints);
X				numpoints = 0;
X				UseSpline = FALSE;
X			}
X			if ( Token[i].label != NULL )
X				LineType = Token[i].label;
X			break;
X		case LINECOLOR:
X			if ( numpoints > 0 ) {
X				dumppoints(points,numpoints);
X				numpoints = 0;
X				UseSpline = FALSE;
X			}
X			if ( Token[i].label != NULL ) {
X				LineColor = Token[i].label;
X				TextColor = Token[i].label;
X				MarkColor = Token[i].label;
X				graymarker(0.0);
X			}
X			break;
X		case LINEWIDTH:
X			if ( numpoints > 0 ) {
X				dumppoints(points,numpoints);
X				numpoints = 0;
X				UseSpline = FALSE;
X			}
X			if ( Token[i].label != NULL )
X				LineWidth = Token[i].label;
X			break;
X		case MARKER:
X			UseMarker = Token[i].label;
X			setmarker(UseMarker);
X			break;
X		case MARKERSCALE:
X			scalemarker(Token[i].val[0]);
X			break;
X		case MARKERGRAY:
X			graymarker(Token[i].val[0]);
X			break;
X		case FONT:
X			if ( numpoints > 0 ) {
X				dumppoints(points,numpoints);
X				points[0] = points[numpoints-1];
X				numpoints = 1;
X			}
X			if ( Token[i].label != NULL ) {
X				newfont(Token[i].label);
X				TextFont = Token[i].label;
X			}
X			break;
X		case TEXT:
X			if ( numpoints > 0 ) {
X				dumppoints(points,numpoints);
X				numpoints = 0;
X			}
X			if ( code(Token[i].xval,Token[i].yval)==0 )
X				text(Token[i].label,sx(Token[i].xval),sy(Token[i].yval),"ljust");
X			break;
X		case SPLINE:
X			dumppoints(points,numpoints);
X			numpoints = 0;
X			UseSpline = TRUE;
X			break;
X		case POINT:
X			if ( numpoints >= sizeofpoints ) {
X				sizeofpoints += 10;
X				points = (plotpoint_t *)realloc((char *)points,sizeofpoints*sizeof(plotpoint_t));
X			}
X			points[numpoints].x = Token[i].val[0];
X			points[numpoints++].y = Token[i].val[1];
X			if ( Token[i].label != NULL ) {
X				if ( code(Token[i].xval,Token[i].yval)==0 )
X					if (TransparentLabels)
X					    text(Token[i].label,
X						sx(Token[i].val[0])+0.1,
X						sy(Token[i].val[1]),"ljust");
X					else
X					    wtext(Token[i].label,
X						sx(Token[i].val[0])+0.1,
X						sy(Token[i].val[1]),"ljust");
X				if (BreakAfterLabel && numpoints > 0) {
X					dumppoints(points,numpoints);
X					numpoints = 0;
X				}
X			}
X			if ( UseMarker != NULL )
X				domarker(Token[i].val[0],Token[i].val[1]);
X			break;
X		}
X	}
X	dumppoints(points,numpoints);
X	printf("grestore saveIt restore\n");
X	if (Preview)
X/*	    printf("gsave showpage grestore\n");*/
X	    printf("showpage\n");
X	/*
X	 * bah ... these can be supplied with command line arguments, but
X	 * they shouldn't leak through to a second graph...
X	 */
X	
X	Title.title = NULL;
X	Title.font = NULL;
X}
X
X/*
X * dumppoints - generate the commands for the data stored in the points array.
X */
X
Xdumppoints(points, numpoints)
Xplotpoint_t *points;
Xint numpoints;
X{
X	int i;
X	float xs, ys, xe, ye;
X	float dxi, dyi, dxi1, dyi1;
X
X	if (numpoints < 2 ||
X	    strcmp(LineType, "off") == 0 ||
X	    strcmp(LineType, "none") == 0)
X		return;
X	if ( UseSpline ) {
X		i = 1;
X		while (!clip(points[i-1].x, points[i-1].y,
X				points[i].x, points[i].y,
X				&xs, &ys, &xe, &ye)) 
X			i++;		/* remove invisibles at beginning */
X
X		startline(xs, ys);
X		printf(" %f %f rlineto\n",
X			(SX(xe) - SX(xs))/2, (SY(ye) - SY(ys))/2);
X
X		for (; i < numpoints - 1; i++){
X			if ( clip(points[i-1].x, points[i-1].y,
X				  points[i].x, points[i].y,
X				  &xs, &ys, &xe, &ye)) {
X				dxi = SX(xe) - SX(xs);
X				dyi = SY(ye) - SY(ys);
X			} else {/* handle intermediate clipping */}
X			if ( clip(points[i].x, points[i].y,
X				  points[i+1].x, points[i+1].y,
X				  &xs, &ys, &xe, &ye)) {
X				dxi1 = SX(xe) - SX(xs);
X				dyi1 = SY(ye) - SY(ys);
X			} else {/* ditto. it's ugly */}
X			printf(" %f %f %f %f %f %f rcurveto\n",
X				dxi/3, dyi/3,
X				(3*dxi+dxi1)/6, (3*dyi+dyi1)/6,
X				(dxi+dxi1)/2, (dyi+dyi1)/2);
X		}
X		contline(xe, ye);		
X	} else for ( i=1 ; i<numpoints ; i++ ) {
X		if ( clip(points[i-1].x, points[i-1].y,
X			  points[i].x,points[i].y, &xs, &ys, &xe, &ye)) {
X			if ( i==1 || xs!=points[i-1].x && ys!=points[i-1].y) {
X				if ( i != 1 )
X					printf("\n");
X				startline(xs,ys);
X			}
X			contline(xe,ye);
X		}
X	}
X}
X
XstartGridTemp()
X{
X    assert(!TempOpen);
X    printf("/gt%03d[\n", CurrentTemp++);
X    TempOpen = TRUE;
X    LinesInTemp = 0;
X}
X
XendGridTemp()
X{
X    assert(TempOpen);
X    printf("]cvx bind def\n");
X    TempOpen = FALSE;
X}
X
XgridLine(x1, y1, x2, y2, g)
Xfloat	x1, y1, x2, y2, g;
X{
X    	if (LinesInTemp > 50) { endGridTemp(); startGridTemp(); }
X	LinesInTemp++;
X	    
X	putchar('{');
X	if (g != 0.0)
X	    printf("gsave %f setgray ", g);
X	stroke(sx(x1), sy(y1), sx(x2), sy(y2));
X	if (g != 0.0)
X	    printf("grestore");
X	printf("\t}EX\n");
X}
X
Xtick(x, y, d, big, g)
Xfloat	x, y, g;
Xdir_t	d;
Xbool	big;
X{
X	float	len;
X
X    	if (LinesInTemp > 50) { endGridTemp(); startGridTemp(); }
X	LinesInTemp++;
X
X	len = big ? TickLen : Tick2Len;
X	printf("{ ");
X	if (g != 0.0)
X	    printf("gsave %f setgray ", g);
X	switch(d) {
X	case	NORTH:
X		stroke(sx(x), sy(y), sx(x), sy(y) + len);
X		break;
X	case	EAST:
X		stroke(sx(x), sy(y), sx(x) + len, sy(y));
X		break;
X	case	SOUTH:
X		stroke(sx(x), sy(y) - len, sx(x), sy(y));
X		break;
X	case	WEST:
X		stroke(sx(x) - len, sy(y), sx(x), sy(y));
X		break;
X	}
X	if (g != 0.0)
X	    printf("grestore");
X	printf("\t}EX\n");
X}
X
Xstatic int	maxWest = 0;	/* most char positions west */
X
XtickText(x, y, val, d, font)
Xfloat	x, y;
Xfloat	val;
Xdir_t	d;
Xchar	*font;
X{
X	char	buf[32];
X	int	len;
X
X    	if (LinesInTemp > 50) { endGridTemp(); startGridTemp(); }
X	LinesInTemp++;
X
X	sprintf(buf, "%g", val);
X	printf("{ ");
X	newfont(font);
X	switch(d){
X	case SOUTH:
X		text(buf, sx(x), sy(y) - (0.8 * PointSize/72.0), "");
X		minY = MIN(minY, sy(Yaxis.gmin)-(0.8*PointSize/72.0));
X		break;
X	case WEST:
X		text(buf, sx(x) - 0.05, sy(y), "rjust");
X		len = strlen(buf);
X		maxWest = MAX(len, maxWest);
X		minX = MIN(minX, -(0.75 * len*PointSize/72.0));
X		break;
X	}
X	printf("\t}EX\n");
X}
X
XaxisText(buf, d, font)
Xchar	*buf;
Xdir_t	d;
Xchar	*font;
X{
X	float	xc, yc;
X
X	xc = sx(Xaxis.gmin) + (SX(Xaxis.gmax) - SX(Xaxis.gmin)) / 2.0;
X	yc = sy(Yaxis.gmin) + (SY(Yaxis.gmax) - SY(Yaxis.gmin)) / 2.0;
X
X	printf("{ ");
X	newfont(font);
X	switch(d) {
X	case NORTH:
X		printf("%f %f m (%s) /cjust t ", 
X			xc, sy(Yaxis.gmax) + 0.1 + 0.3 * PointSize/72.0,
X			buf);
X		maxY = MAX(maxY, sy(Yaxis.gmax) + 0.1 + 1.3*PointSize/72.0);
X		break;
X
X	case SOUTH:
X		printf("%f %f m (%s) /cjust t ",
X			xc, sy(Yaxis.gmin) - 1.8*PointSize/72.0, buf);
X		minY = MIN(minY, sy(Yaxis.gmin) - 2.0*PointSize/72.0);
X		break;
X
X	case WEST:
X		printf("%f %f m (%s) /vjust t ", 
X			sx(Xaxis.gmin) - (0.75*maxWest * PointSize/72.0
X					  + 0.1 + 0.3 * PointSize/72.0),
X			yc, 
X			buf);
X		minX = MIN(minX, sx(Xaxis.gmin) - 
X			(0.75*maxWest*PointSize/72.0 
X			 + 0.1 + 1.3 * PointSize/72.0));
X		break;		
X	}
X	printf("\t}EX\n");
X}
X
X/*
X * Plot routines -
X *
X * These routines all assume that their input is already scaled to inches
X */
X
Xstroke(x1,y1,x2,y2)
Xfloat x1,y1,x2,y2;
X{
X	printf("%f %f %f %f l ", x1, y1, x2, y2);
X}
X
Xstartline(x,y)
Xfloat x,y;
X{
X	setcolor(LineColor);
X	if (LineType != NULL && strlen(LineType)>0)
X		printf("/%s f ", LineType);
X	else
X		printf("/solid f ");
X	if (LineWidth != NULL && strlen(LineType)>0)
X		printf(" %s fw ", LineWidth);
X	else
X		printf(" 0.6 setlinewidth ");
X	printf("%f %f m\n",sx(x),sy(y));
X}
X
Xcontline(x,y)
Xfloat x,y;
X{
X	printf(" %f %f n\n",sx(x),sy(y));
X}
X
Xtext(s,x,y,mod)
Xfloat x,y;
Xchar *s, *mod;
X{
X	setcolor(TextColor);
X	printf("%f %f m (%s) ", x, y, s);
X	if ((strlen(mod) == 0) || (mod == NULL))
X		printf("/cjust ");
X	else 
X		printf ("/%s ", mod);
X	printf("t\n");
X}
X
Xwtext(s,x,y,mod)
Xfloat x,y;
Xchar *s, *mod;
X{
X	setcolor(TextColor);
X	printf("%f %f m (%s) ", x, y, s);
X	if ((strlen(mod) == 0) || (mod == NULL))
X		printf("/cjust ");
X	else 
X		printf ("/%s ", mod);
X	printf("w\n");
X}
X
Xnewfont(font)
Xregister char *font;
X{
X	char name[100];
X	int size;
X	register char *np = name;
X	register char *s = font;
X	register fontName_t *fp;
X
X	while (isascii(*s) && (isalpha(*s) || (*s == '-')))
X		*np++ = *s++;
X	*np++ = NULL;
X	if (isascii(*s) && isdigit(*s)) {
X		size = 0;
X		do
X			size = size * 10 + *s++ - '0';
X		while ('0' <= *s && *s <= '9');
X	}
X	if (*s || !size || !name[0]) {
X		fprintf (stderr, "Poorly formed font name: \"%s\"\n", name);
X		return;
X	}
X	if (CurrentFont)
X		if (size == PointSize && !strcmp(CurrentFont->name, name))
X			return;		/* no change */
X	printf("/%s findfont %d scalefont setfont ", name, size);
X	printf("/fontsize %d def\n", size);
X	PointSize = size;
X
X	for (fp = FontList; fp; fp = fp->next)
X		if (!strcmp(fp->name, name)) {
X			CurrentFont = fp;
X			return;		/* already there */
X		}
X	fp = (fontName_t *) malloc(sizeof (fontName_t));
X	fp->name = newstr(name);
X	fp->next = FontList;
X	FontList = fp;
X	CurrentFont = fp;
X}
X
X/*
X * setmarker - set the current marker type
X */
X
Xsetmarker(m)
Xchar	*m;
X{
X	printf("/%s sm\n", m);
X}
X
X/*
X * domarker - print the marker at the given point.
X */
X
Xdomarker(x,y)
Xfloat	x,y;
X{
X    if ( code(x,y) )
X	return;
X    /*
X     * note that the marker gray stuff is done inside mk (in PS), so
X     * the color may not actually take effect.
X     */
X    setcolor(MarkColor);
X    printf("%f %f mk\n", sx(x), sy(y));
X}
X
X/*
X * graymarker - set the marker gray value
X */
X
Xgraymarker(s)
Xfloat s;
X{
X    printf("/mg %f def\n", s);
X}
X
X/*
X * scalemarker - set the marker scale value
X */
X
Xscalemarker(s)
Xfloat	s;
X{
X    printf("/ms %f def\n", s);
X}
X
X/*
X * setcolor - set current color; remembers what is already set
X */
X
Xchar *curColor = NULL;
X
Xsetcolor(color)
Xchar *color;
X{
X	if (curColor && color && (strcmp(curColor, color) == 0))
X		return;
X	curColor = color;
X	if (color != NULL && strlen(color)>0)
X		printf("/%s fc\n",color);
X	else
X		printf("/black fc\n");
X}
X
X/*
X *----------------------------------------------------------------------
X *
X * DATA CLIPPING ROUTINES
X *
X *	2D clipper 	Cohen-Sutherland clipper from Newman and Sproull(pg 67).
X *
X */
X
X#define LEFT	0x1
X#define RIGHT   0x2
X#define BOTTOM  0x4
X#define TOP     0x8
X
Xfloat   Clipxl, Clipxr, Clipyb, Clipyt;
Xint	Clipxf, Clipyf;
Xunsigned int c;
X
X
Xcliplimits( xmin, ymin, xmax, ymax, xflip, yflip)
Xfloat xmin, ymin, xmax, ymax;
Xint   xflip, yflip;
X{
X	extern float Clipxl, Clipxr, CLipyb, Clipyt;
X
X	Clipxl = xmin;
X	Clipxr = xmax;
X	Clipxf = xflip;
X	Clipyb = ymin;
X	Clipyt = ymax;
X	Clipyf = yflip;
X}
X
X
Xcode( x, y )
Xfloat x,y; /* point to encode */
X
X{
X
X	c = 0;
X
X	if ( Clipxf ? x > Clipxl : x < Clipxl )
X		c = LEFT;
X	else if ( Clipxf ? x < Clipxr : x > Clipxr )
X		c = RIGHT;
X
X	if ( Clipyf ? y > Clipyb : y < Clipyb )
X		c = c | BOTTOM;
X	else if ( Clipyf ? y < Clipyt : y > Clipyt )
X		c = c | TOP;
X
X	return c;
X
X}
X
X
Xclip( x1, y1, x2, y2, xs, ys, xe, ye )
Xfloat x1, y1, x2, y2;      /* line to test against box */
Xfloat *xs, *ys, *xe, *ye;  /* returned line within region */ 
X/*
X *	Description:	Clips a line against the rectangular clipping region set by
X *			Cliplimits. 
X *
X *	Input:
X *			endpoints of a line to be tested. No order assumed.
X *
X *	Output:
X *			Returns the new endpoints of the line clipped to the edges
X *			of the box in xs, ys, xe, ye.
X *
X *	    RETURNS:    0  if the the line does not pass through the clipping region.
X *		        1  if the line passes through the clipping region.
X *
X */
X
X{
X	unsigned int c1,c2;
X	float x,y;
X
X	c1 = code( x1,y1 );
X	c2 = code( x2,y2 );
X
X	/*  if both c = 0, then both within window : trivial accept */
X	while ( (c1 != 0) || (c2 != 0) ) {
X			
X
X		/* if intersection of c1 and c2 is non-zero, then the line lies
X		   completely off of the screen */
X		if ( c1 & c2 ) {
X			*xs = x1;
X			*ys = y1;
X			*xe = x2;
X			*ye = y2;
X			return FALSE;
X		}
X
X		c = c1;
X		if ( c == 0 ) c = c2;
X
X
X		if ( c & LEFT ) { /* crosses left edge */
X			y = y1 + (y2-y1) * (Clipxl - x1) / (x2-x1);
X			x = Clipxl;
X		} else if ( c & RIGHT ) { /* crosses right edge */
X			y = y1 + (y2-y1) * (Clipxr - x1) / (x2-x1);
X			x = Clipxr;
X		} else if ( c & BOTTOM ) { /* crosses bottom edge */
X			x = x1 + (x2-x1) * ( Clipyb - y1 ) / (y2-y1);
X			y = Clipyb;
X		} else if ( c & TOP ) { /* crosses top edge */
X			x = x1 + (x2-x1) * ( Clipyt - y1 ) / (y2-y1);		
X			y = Clipyt;
X		}
X
X		if ( c = c1 ) {
X			x1 = x;
X			y1 = y;
X			c1 = code(x,y);	
X		} else {
X			x2 = x;
X			y2 = y;
X			c2 = code(x,y);
X		}
X
X	} /* end while */
X
X	/* line is visible */
X
X	*xs = x1;
X	*ys = y1;
X	*xe = x2;
X	*ye = y2;
X	return TRUE;
X}
X
X/*
X * Scaling routines - these convert user data into inches
X */
X
Xfloat 
Xsx(x)
Xfloat x;
X{
X	register axis_t *argp = &Xaxis;
X
X	if (argp->tform == IDENT)
X		return (x-argp->gmin)/(argp->gmax-argp->gmin)*argp->size
X			+ argp->offset;
X	else
X		return (log10(x)-argp->lgmin)/(argp->lgmax - argp->lgmin)
X			* argp->size + argp->offset;
X}
Xfloat
Xsy(y)
Xfloat y;
X{
X	register axis_t *argp = &Yaxis;
X
X	if (argp->tform == IDENT)
X		return (y-argp->gmin)/(argp->gmax-argp->gmin)*argp->size
X			+ argp->offset;
X	else
X		return (log10(y)-argp->lgmin)/(argp->lgmax - argp->lgmin)
X			* argp->size + argp->offset;
X}
X
X/* these just scale, don't translate */
X
Xfloat 
XSX(x)
Xfloat x;
X{
X	register axis_t *argp = &Xaxis;
X
X	if (argp->tform == IDENT)
X		return (x)/(argp->gmax-argp->gmin)*argp->size;
X	else
X		return (log10(x)-argp->lgmin)/(argp->lgmax - argp->lgmin)
X			* argp->size;
X}
Xfloat 
XSY(y)
Xfloat y;
X{
X	register axis_t *argp = &Yaxis;
X
X	if (argp->tform == IDENT)
X		return (y)/(argp->gmax-argp->gmin)*argp->size;
X	else
X		return (log10(y)-argp->lgmin)/(argp->lgmax - argp->lgmin)
X			* argp->size;
X}
X
END_OF_FILE
if test 20906 -ne `wc -c <'output.c'`; then
    echo shar: \"'output.c'\" unpacked with wrong size!
fi
# end of 'output.c'
fi
echo shar: End of archive 2 \(of 3\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
