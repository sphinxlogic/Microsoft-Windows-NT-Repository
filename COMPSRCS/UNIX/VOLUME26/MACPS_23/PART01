Newsgroups: comp.sources.unix
From: edmoy@violet.Berkeley.EDU (Edward Moy)
Subject: v26i243: macps-2.3 - Print Mac files on UNIX, Part01/01
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: edmoy@violet.Berkeley.EDU (Edward Moy)
Posting-Number: Volume 26, Issue 243
Archive-Name: macps-2.3/part01

Well, here is the long-overdue System 7 compatible version of macps and
prepfix, version 2.3, in shar format.  Following are some excerpts from
the included ReadMe file.

Edward Moy				Principal Programmer - Macintosh & Unix
Workstation Support Services		Workstation Software Support Group
University of California
Berkeley, CA  94720

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 1)."
# Contents:  Installation MANIFEST Makefile ReadMe macaux.c macps.1
#   macps.c macps.config prepfix.1 prepfix.c str.h ucbwhich.c
#   ucbwhich.h
# Wrapped by vixie@gw.home.vix.com on Sun Jun 20 12:17:16 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Installation' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Installation'\"
else
echo shar: Extracting \"'Installation'\" \(4025 characters\)
sed "s/^X//" >'Installation' <<'END_OF_FILE'
XInstallation Instructions (SCCSid = "@(#)Installation	2.3 7/1/92")
X
X1) Look at the Makefile.  There are three CFLAGS options that you can
Xuse.  Setting SYSV should allow macps and prepfix to compile on System
XV machines (I've only tried it under A/UX).  Setting CONFIGDIR will
Xcause macps to look for macps.config in that directory.  Setting SAVE
Xwill cause macps to enclose the entire print job is a PostScript
Xsave/restore context.  Normally you don't need SAVE, since most
Xspooling software will automatically do an EOF between print jobs,
Xwhich effectively does a restore of memory for you, but some spooling
Xsoftware does require the save/restore.  Note that defining SAVE will
Xcause printing to fail on a NeXT laser printer, while it is harmless on
Xmost other systems.
X
XThe options will look something like:
X
XCFLAGS = -O -DSYSV -DCONFIGDIR=\"/usr/new/lib\" -DSAVE
X
Xif you defined all the options.
X
X2) Type "make".  If all goes well, macps and prepfix will be created.
X
X3) For pre-System 7 systems, to create the unprocessed LaserPrep file
Xon the Mac, as well as creating the raw PostScript files that you want
Xto print, make sure that either you're not running MultiFinder, or if
Xyou are, go to the Chooser under the Apple menu, click on the
XLaserWriter icon and then turn off Background Printing.  (No special
Xsetting need to be made under System 7.)
X
X4a) Under a pre-System 7 system, for each version of LaserPrep on the
XMac that you want to include, install that version in the System
XFolder.  Then, open an empty document in some simple application (one
Xthat doesn't have its own ProcSet to download).  Choose Print from the
XFile menu and the LaserWriter print dialog will appear.  Click on the
XOK button and IMMEDIATELY press and hold Command-K.  When a dialog box
Xappears telling you that it is creating a PostScript file, you can
Xrelease Command-K.  The unprocessed LaserPrep file will usually be
Xfound in one of three places, in the System Folder, in the same folder
Xas the application or at the top level of the disk.
X
X4b) Under a System 7 system, make sure that the LaserWriter driver is
Xinstalled in the System Folder.  Then, open an empty document in some
Xsimple application (one that doesn't have its own ProcSet to
Xdownload).  Choose Print from the File menu and the LaserWriter print
Xdialog will appear.  Click on the PostScript File radio button, and
Xthen click on the Save button.  When the standard file dialog box
Xappears, specify a name and folder for the PostScript file, and click
Xon the Save button.
X
X5) Upload the PostScript file(s) to Unix, using some file transfer
Xprogram like MacTerminal, Versaterm, Red Ryder, MacKermit or ftp.
X
X6) Run prepfix on each unprocessed file, diverting the standard output
Xto an appropriataly named file (like LaserPrep5.2).  If you want to
Xallow bit smoothing on a non-Apple PostScript printer, specify the -l
Xoption to prepfix (you can specify as many printer names as you want,
Xeach with a separate -l flag).  If you aren't sure the your printer can
Xdo smoothing, you can try it and see if it works (if it doesn't, you
Xcan always re-run prepfix on the unprocessed file(s), leaving off the
Xprinter that doesn't work).  If you don't know the product name for you
Xprinter, you can use the following PostScript code to print it:
X
X%!
X/in {72 mul} def
X/Courier findfont 18 scalefont setfont
X1 in 8 in moveto
Xstatusdict /product get show
Xshowpage
X
X7) Put the modified LaserPrep file(s) in some directory and modify the
Xmacps.config file to point to these LaserPrep files.  Then put the
Xmacps.config file in a "lib" subdirectory to where you install macps
X(or in the directory CONFIGDIR if you used that option).
X
X8) Now when you want to print something, do the same thing as in step 4
Xabove with the LaserWriter print dialog, except for pre-System 7
Xsystem, press and hold Command-F (this cause LaserPrep not to be
Xincluded in the PostScript file).
X
X9) Upload the PostScript file and run macps on it, sending the output
Xto your printer, as in:
X
X	% macps psfile | lpr
END_OF_FILE
if test 4025 -ne `wc -c <'Installation'`; then
    echo shar: \"'Installation'\" unpacked with wrong size!
fi
# end of 'Installation'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(517 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Installation               1	
X MANIFEST                   1	This shipping list
X Makefile                   1	
X ReadMe                     1	
X macaux.c                   1	
X macps.1                    1	
X macps.c                    1	
X macps.config               1	
X prepfix.1                  1	
X prepfix.c                  1	
X str.h                      1	
X ucbwhich.c                 1	
X ucbwhich.h                 1	
END_OF_FILE
if test 517 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(1251 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Copyright (c) 1988, 1992, The Regents of the University of California.
X# Edward Moy, Workstation Software Support Group, Workstation Support Serices,
X# Information Systems and Technology.
X#
X# Permission is granted to any individual or institution to use, copy,
X# or redistribute this software so long as it is not sold for profit,
X# provided that this notice and the original copyright notices are
X# retained.  The University of California makes no representations about the
X# suitability of this software for any purpose.  It is provided "as is"
X# without express or implied warranty.
X#
X# SCCSid = "@(#)Makefile	2.3 7/1/92"
X#
X# For System V, include -DSYSV in CFLAGS below.
X# To specify a fixed path for macps.config, include -DCONFIGDIR=\"path\"
X# in CFLAGS below (path is the full pathname of the directory).
X# To do save/restore context, include -DSAVE in CFLAGS below.
X#
XCFLAGS = -O
XMACPS = macps.o macaux.o ucbwhich.o
XPREPFIX = prepfix.o macaux.o
X
Xall : macps prepfix
X
Xmacps : $(MACPS)
X	cc -o macps $(CFLAGS) $(MACPS)
X
Xprepfix : $(PREPFIX)
X	cc -o prepfix $(CFLAGS) $(PREPFIX)
X
Xmacps.o : macps.c str.h ucbwhich.h
X
Xmacaux.o : macaux.c str.h
X
Xprepfix.o : prepfix.c str.h
X
Xucbwhich.o : ucbwhich.c ucbwhich.h
X
Xclean :
X	/bin/rm -f *.o macps prepfix
END_OF_FILE
if test 1251 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'ReadMe' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ReadMe'\"
else
echo shar: Extracting \"'ReadMe'\" \(5897 characters\)
sed "s/^X//" >'ReadMe' <<'END_OF_FILE'
XCOPYRIGHT NOTICE (SCCSid = "@(#)ReadMe	2.3 7/3/92")
X
XCopyright (C) 1988, 1992, The Regents of the University of California.
XEdward Moy, Workstation Software Support Group, Workstation Support
XSerices, Information Systems and Technology.
X
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as it is not sold for profit,
Xprovided that this notice and the original copyright notices are
Xretained.  The University of California makes no representations about
Xthe suitability of this software for any purpose.  It is provided "as
Xis" without express or implied warranty.
X
XWHAT IS MACPS?
X
XMacps is a Unix program that takes an uploaded PostScript file created
Xon a Macintosh (see macps.1 for more details) and includes an
Xappropriately modified LaserPrep file so that the result can be sent to
Xa PostScript printer from Unix.  The LaserPrep file contains macros
Xused by the PostScript generator on the Macintosh.
X
XWHY IS MACPS NEEDED?
X
XThis is how Mac printing works.  When a Mac talks to a LaserWriter, it
Xasks if the LaserWriter has had a LaserPrep file downloaded to it.  A
XLaserWriter that is first powered up, has no such LaserPrep file, and
Xso the Mac downloads it and makes the LaserPrep file resident in
Xmemory.  Then the actual print file is sent to the LaserWriter.
XSubsequent print requests need not download the LaserPrep file, unless
Xit is a different version.
X
XSince a LaserWriter connected to a Unix system usually does things
Xother than Mac printing, it is unwise to make LaserPrep files resident
Xin memory so that other PostScript jobs have less memory to work with.
XWhat prepfix does is to modify a LaserPrep file so that, among other
Xthings, it does not make itself resident in memory.  Thus, the
XLaserPrep file must be downloaded for each Mac print job.  This is the
Xfunction of macps, to automatically append the appropriate LaserPrep
Xfile.
X
XSince System 7, the LaserPrep is no longer downloaded to the printer.
XSome people have had success printing a System 7-generated PostScript
Xfile directly, but using macps should make printing more reliable and
Xavailable to non-Apple PostScript printers.
X
XWHICH VERSION OF THE LASERPREP WILL BE USED?
X
XMacps interprets the %%IncludeProcSet directive found in the PostScript
Xgenerated by LaserWriter driver 4.0 and greater.  It takes the ProcSet
Xid and looks it up in a file "macps.config", to get the pathname of the
Xprep file, and thus macps can convert PostScript generated by different
Xversions of the LaserWriter driver.
X
XHOW ARE THE LASERPREP FILES GENERATED?
X
XSince the Apple LaserPrep files are copyrighted, I've included a
Xprogram, prepfix, that reads version 4.0 and up LaserPrep files, and
Xedits them so that they are (mostly) compatible with Unix (See
Xprepfix.1 for more details).
X
XWHERE IS THE MACPS.CONFIG FILE LOCATED?
X
XMacps has some special code that is able to figure out from which
Xdirectory it was called from.  It will then look in a "lib" subdiretory
Xfor the macps.config file.
X
XWHAT ABOUT BIT-SMOOTHING ON NON-LASERWRITER PRINTERS?
X
XFor PostScript printers using Motorola 680x0 processors and Adobe
XPostScript firmware other than LaserWriters, there is an option that
Xwill allow these printers to do bit-smoothing, just like LaserWriters.
X
XCHANGES IN VERSION 2.3
X
XVersion 2.3 of prepfix now support LaserPrep 7.x (System 7).  Resulting
XLaserPrep files are slightly smaller, since some extraneous comments
Xhave been removed.  Version 2.3 of macps works with System 7-generated
XPostScript files, replacing the included LaserPrep with the modified
Xversion.  Because of the way this change was made, macps can now work
Xon either a Command-F or Command-K (pre-System 7) PostScript file.
X
XCreating a PostScript file under System 7 will cause all fonts used in
Xa document to be downloaded.  Downloaded fonts, especially TrueType
Xfonts, tend to make the resulting PostScript file very large.  Both the
Xsize of the PostScript file and the complexity of a downloadable
XTrueType font can cause some printers to fail to print, even when the
Xprinter already contains the requested fonts.  Software like H.M.
XAyala's Trimmer CDEV (available from most Macintosh ftp sites and
Xbulletin board systems) can prevents selected fonts (those already
Xresident in the printer) from being downloaded.
X
XCHANGES IN VERSION 2.2
X
XVersion 2.2 of prepfix now supports LaserPrep 6.0.  The PostScript
Xsave/restore context is now a compile-time option, since it caused
Xprinting to fail on a NeXT printer (though it was harmless on most
Xother printers).  This save/restore is now more intelligent about
Xclearing the stacks.
X
XCHANGES IN VERSION 2.1
X
XVersion 2.1 of prepfix uses a safer method for turning on bit-smoothing
Xfor non-Apple printers.  This should get around some of the problems
Xpeople have been having with specialized macros in the LaserPreps that
Xare Apple printer specific.  The -l and -p options in version 1.1 have
Xbeen replaced with the single -l option, and the limit on the number
Xof printers you can specify has been removed.
X
XAlso, prepfix removes some other various macros that cause
Xunpredictable problems, and a problem with Apple LaserWriter II/NTs
X(but not other Apple printers).
X
XVersion 2.1 macps has several new options.  The -c option allow you to
Xspecify the number of copies to generate (overriding any multiple copy
Xoption that was specified on the Macintosh).  The -d option allows an
Xalternate directory to look for the macps.config file.  Finally, the -r
X(raw) option suppresses the conversion of 8-bit binary into ASCII, and
Xis useful for some graphics programs that manipulate gray-scale images,
Xand produce 8-bit binary PostScript output.
X
XMacps will even work with a NeXT laser printer, but (at least the 0.8
Xversion of the operating system) will not do bit smoothing.  Beware,
Xthough, that if you print Macintosh patterns at 400 dpi, they will
Xlook funny.
END_OF_FILE
if test 5897 -ne `wc -c <'ReadMe'`; then
    echo shar: \"'ReadMe'\" unpacked with wrong size!
fi
# end of 'ReadMe'
fi
if test -f 'macaux.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'macaux.c'\"
else
echo shar: Extracting \"'macaux.c'\" \(3608 characters\)
sed "s/^X//" >'macaux.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1988, 1992, The Regents of the University of California.
X * Edward Moy, Workstation Software Support Group, Workstation Support Serices,
X * Information Systems and Technology.
X *
X * Permission is granted to any individual or institution to use, copy,
X * or redistribute this software so long as it is not sold for profit,
X * provided that this notice and the original copyright notices are
X * retained.  The University of California makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X */
X
X#ifndef lint
Xstatic char *SCCSid = "@(#)macaux.c	2.3 7/1/92";
X#endif lint
X
X#include <ctype.h>
X#include <stdio.h>
X#include "str.h"
X
X#define	FALSE		0
X#define	TRUE		1
X
Xextern char *myname;
Xint rawmode = FALSE;
X
XSTR *
XSTRalloc()
X{
X	register STR *str;
X	char *malloc();
X
X	if((str = (STR *)malloc(sizeof(STR))) == NULL ||
X	 (str->bufptr = (byte *)malloc(STRSIZE)) == NULL) {
X		fprintf(stderr, "%s: STRalloc: Out of memory\n", myname);
X		exit(1);
X	}
X	str->curendptr = str->bufptr;
X	str->realendptr = str->bufptr + STRSIZE;
X	return(str);
X}
X
XSTRfree(str)
XSTR *str;
X{
X	free((char *)str->bufptr);
X	free((char *)str);
X}
X
XSTRexpand(str)
Xregister STR *str;
X{
X	register int curend, realend;
X	char *realloc();
X
X	curend = str->curendptr - str->bufptr;
X	realend = (str->realendptr - str->bufptr) + STRSIZEDELTA;
X	if((str->bufptr = (byte *)realloc((char *)str->bufptr,
X	 realend)) == NULL) {
X		fprintf(stderr, "%s: STRexpand: Out of memory\n", myname);
X		exit(1);
X	}
X	str->curendptr = str->bufptr + curend;
X	str->realendptr = str->bufptr + realend;
X}
X
XSTRgets(str, fp)
Xregister STR *str;
Xregister FILE *fp;
X{
X	register int c;
X
X	str->curendptr = str->bufptr;
X	for( ; ; ) {
X		if((c = getc(fp)) == EOF)
X			return(str->curendptr > str->bufptr);
X		if(str->curendptr >= str->realendptr)
X			STRexpand(str);
X		*str->curendptr++ = c;
X		if(c == '\n' || c == '\r') {
X			if(str->curendptr >= str->realendptr)
X				STRexpand(str);
X			*str->curendptr = 0;
X			return(TRUE);
X		}
X	}
X}
X
XSTRputsptr(str, cp, fp)
Xregister STR *str;
Xregister byte *cp;
Xregister FILE *fp;
X{
X	if(rawmode) {
X		for( ; cp < str->curendptr ; cp++)
X			putc(*cp, fp);
X		return;
X	}
X	for( ; cp < str->curendptr ; cp++) {
X		if(!isascii(*cp))
X			fprintf(fp, "\\%03o", *cp);
X		else if(isprint(*cp))
X			putc(*cp, fp);
X		else {
X			switch(*cp) {
X			 case '\n':
X			 case '\r':
X				putc('\n', fp);
X				continue;
X			 case '\t':
X				putc('\t', fp);
X				continue;
X			 default:
X				fprintf(fp, "\\%03o", *str);
X				continue;
X			}
X		}
X	}
X}
X
XSTRcompareptr(str, cp, sp)
Xregister STR *str;
Xregister byte *cp, *sp;
X{
X	register int comp;
X
X	for( ; ; ) {
X		if(*sp == 0)
X			return(cp >= str->curendptr ? 0 : 1);
X		if(cp >= str->curendptr)
X			return(-1);
X		if(*sp == '\n') {
X			if(*cp != '\n' && *cp != '\r')
X				return((int)*cp - (int)*sp);
X		} else if((comp = (int)*cp - (int)*sp) != 0)
X			return(comp);
X		cp++;
X		sp++;
X	}
X}
X
XSTRheadcmpptr(str, cp, sp)
Xregister STR *str;
Xregister byte *cp, *sp;
X{
X	register int comp;
X
X	for( ; ; ) {
X		if(*sp == 0)
X			return(0);
X		if(cp >= str->curendptr)
X			return(-1);
X		if(*sp == '\n') {
X			if(*cp != '\n' && *cp != '\r')
X				return((int)*cp - (int)*sp);
X		} else if((comp = (int)*cp - (int)*sp) != 0)
X			return(comp);
X		cp++;
X		sp++;
X	}
X}
X
Xbyte *
XSTRmatch(str, sp)
Xregister STR *str;
Xregister byte *sp;
X{
X	register byte *mp, *last;
X	register int firstchar;
X
X	firstchar = *sp;
X	last = str->curendptr - strlen(sp);
X	mp = str->bufptr;
X	while(mp <= last) {
X		if(*mp == firstchar && STRheadcmpptr(str, mp, sp) == 0)
X			return(mp);
X		mp++;
X	}
X	return(NULL);
X}
END_OF_FILE
if test 3608 -ne `wc -c <'macaux.c'`; then
    echo shar: \"'macaux.c'\" unpacked with wrong size!
fi
# end of 'macaux.c'
fi
if test -f 'macps.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'macps.1'\"
else
echo shar: Extracting \"'macps.1'\" \(4288 characters\)
sed "s/^X//" >'macps.1' <<'END_OF_FILE'
X.\" SCCSid = "@(#)macps.1	2.3 7/3/92"
X.TH MACPS 1 "1 July 1992"
X.UC 4
X.SH NAME
Xmacps \- print Macintosh-created PostScript file on Unix
X.SH SYNOPSIS
X.B macps
X[
X\-c copies
X]
X[
X\-d directory
X]
X[
X\-r
X]
X[
Xfile
X]
X.SH DESCRIPTION
X.I Macps
Xtakes the command-line file (or the standard input if no filename is given),
Xand prepends the appropriate Macintosh LaserPrep file (e.g., those generated
Xby
X.IR prepfix (1)).
XThe standard output can then be directed to a PostScript printer, via
X.IR lpr (1),
Xfor example.
X.PP
XThe input PostScript file is generated on a Macintosh in one of two ways.
XOn pre-System 7 systems, this PostScript file is created by typing (and
Xholding) Command-F immediately after clicking the OK button of the LaserWriter
XPrint dialog box.
XAnother dialog will appear, confirming that a file named ``PostScript'' is
Xbeing created (the Command-F keys can be released now).
XDepending on the application, the created PostScript file can be found in the
XSystem Folder, the application folder or the top level of the disk.
X.PP
XOn System 7 systems, the Print dialog box allows the selection of the
Xdestination of the output.
XClicking on the PostScript File radio button and then clicking the Save button
Xwill cause a standard file dialog box to appear, allowing the user to specify
Xthe name and location of the resultant PostScript file.
X.PP
XThe PostScript file can then be uploaded via some file transfer program, such
Xas MacTerminal/VersaTerm and
X.IR macget (1),
XMacKermit/Red Ryder and
X.IR kermit (1)
Xor
X.IR ftp (1).
X.PP
XNormally, you would specify the number of copies in the LaserWriter
XPrint dialog box on the Macintosh.
XHowever, you can override that after uploading the PostScript file by
Xspecifying the
X.B \-c
Xoption, followed by the number of copies.
X.PP
XIn a Macintosh PostScript file, the line beginning with ``%%IncludeProcSet:''
Xis a request to include a LaserPrep with the internal name that follows on
Xthe same line as the ``%%IncludeProcSet:'' directive.
XThis internal name corresponds to the name in a LaserPrep file that follows
Xon the same line as the ``%%BeginProcSet:'' directive.
X.PP
XTo specify where a LaserPrep file with a certain internal name is stored, a
Xfile named
X.B macps.config
Xis used.
XThis file is composed of one of more lines; one for each LaserPrep file.
XEach line contains the internal name followed a tab character followed by
Xthe name of file containing the corresponding LaserPrep.
XThe file name can be either a full pathname or a pathname relative
Xto the directory that
X.B macps.config
Xresides.
X.PP
XThe
X.B macps.config
Xfile is normally located in a `lib' subdirectory of the directory
X.I macps
Xis located.
XThe
X.B \-d
Xoption allow you to specify an alternate directory in which the
X.B macps.config
Xfile can be found.
X.PP
XMost Macintosh applications produce normal ASCII PostScript files.
XHowever, some graphics programs that manipulate gray-scale images will
Xproduce PostScript files that contain 8-bit binary data.
XSince
X.I macps
Xnormally converts this binary data, these PostScript files will not work
Xproperly.
XThe
X.B \-r
X(raw) option suppresses this binary conversion.
X(Note: Depending on how the printer is physically connected, it may not be
Xable to handle 8-bit binary data properly, and results may be disappointing.)
X.SH FILES
X.TP "\w'lib/macps.config     'u"
Xlib/macps.config
XMaps ProcSet internal names to LaserPrep filenames
X.SH "SEE ALSO"
Xlpr(1), macget(1), kermit(1), prepfix(1)
X.SH BUGS
X.I Macps
Xonly works with version 4.0 and up of the Macintosh LaserPrep files.
X.PP
XBecause of the way bit smoothing is implemented by the LaserWriter driver,
Xsome PostScript printers other than the Apple LaserWriters may not be able to
Xbit smooth.
X.PP
XCreating a PostScript file under System 7 will cause all fonts used in
Xa document to be downloaded.
XDownloaded fonts, especially TrueType fonts, tend to make the resulting
XPostScript file very large.
XBoth the size of the PostScript file and the complexity of a downloadable
XTrueType font can cause some printers to fail to print, even when the
Xprinter already contains the requested fonts.
XSoftware like H.M. Ayala's Trimmer CDEV (available from most Macintosh ftp
Xsites and bulletin board systems) can prevents selected fonts (those already
Xresident in the printer) from being downloaded.
END_OF_FILE
if test 4288 -ne `wc -c <'macps.1'`; then
    echo shar: \"'macps.1'\" unpacked with wrong size!
fi
# end of 'macps.1'
fi
if test -f 'macps.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'macps.c'\"
else
echo shar: Extracting \"'macps.c'\" \(7130 characters\)
sed "s/^X//" >'macps.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1988, 1992, The Regents of the University of California.
X * Edward Moy, Workstation Software Support Group, Workstation Support Serices,
X * Information Systems and Technology.
X *
X * Permission is granted to any individual or institution to use, copy,
X * or redistribute this software so long as it is not sold for profit,
X * provided that this notice and the original copyright notices are
X * retained.  The University of California makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X */
X
X#ifndef lint
Xstatic char *SCCSid = "@(#)macps.c	2.3 7/1/92";
X#endif lint
X
X#include <ctype.h>
X#include <stdio.h>
X#ifdef SYSV
X#include <string.h>
X#else SYSV
X#include <strings.h>
X#endif SYSV
X#include <sys/types.h>
X#include <sys/file.h>
X#include "str.h"
X#include "ucbwhich.h"
X
X#define	BEGINPROC	1
X#define	CONFIG		"macps.config"
X#define	INCLUDEPROC	0
X#define	PS_INCLUDED	0x1
X
X#ifdef SYSV
X#define	index		strchr
X#define	rindex		strrchr
X#endif SYSV
X
Xtypedef struct procset_str {
X	struct procset_str *next;
X	char *procset;
X	char *path;
X	short flags;
X} ProcSet;
X
XProcSet *firstprocset;
X#ifdef SAVE
Xchar *finale = "clear countdictstack 2 sub{end}repeat macps restore\n";
Xchar intro[] = "\
X%%! *** Created by macps: %s\
X/macps save def\n\
X";
X#else SAVE
Xchar intro[] = "\
X%%! *** Created by macps: %s\
X";
X#endif SAVE
XProcSet *lastprocset;
Xchar *myname;
Xint ncopies = 0;
X#ifdef CONFIGDIR
Xchar ucblib[UCBMAXPATHLEN] = CONFIGDIR;
X#else CONFIGDIR
Xint ucbalternate;
Xchar ucbpath[UCBMAXPATHLEN];
Xchar ucblib[UCBMAXPATHLEN];
X#endif CONFIGDIR
X
Xvoid copyproc();
XProcSet *findprocset();
Xvoid insertproc();
Xchar *newstring();
Xvoid newprocset();
Xvoid readprocfile();
Xvoid Usage();
X
Xmain(argc, argv)
Xint argc;
Xchar **argv;
X{
X	register STR *str;
X	register char *cp;
X	long ltime;
X	char *ctime();
X
X#ifndef CONFIGDIR
X	ucbwhich(*argv);
X#endif CONFIGDIR
X	strcat(ucblib, "/");
X	if(myname = rindex(*argv, '/'))
X		myname++;
X	else
X		myname = *argv;
X	cp = NULL;
X	for(argc--, argv++ ; argc > 0 && **argv == '-' ; argc--, argv++) {
X		switch((*argv)[1]) {
X		 case 'c':	/* multiple copies */
X			if((*argv)[2])
X				ncopies = atoi(&(*argv[2]));
X			else {
X				if(argc < 2)
X					Usage();	/* never returns */
X				argc--;
X				ncopies = atoi(*++argv);
X			}
X			if(ncopies <= 0)
X				Usage();	/* never returns */
X			break;
X		 case 'd':	/* alternate directory for config file */
X			if((*argv)[2])
X				cp = &(*argv[2]);
X			else {
X				if(argc < 2)
X					Usage();	/* never returns */
X				argc--;
X				cp = *++argv;
X			}
X			strcpy(ucblib, cp);
X			break;
X		 case 'r':	/* raw mode */
X			rawmode++;
X			break;
X		 default:
X			Usage();	/* never returns */
X		}
X	}
X	if(argc > 1)
X		Usage();	/* never returns */
X	if(argc == 1 && freopen(*argv, "r", stdin) == NULL) {
X		fprintf(stderr, "%s: can't open %s\n", myname, *argv);
X		exit(1);
X	}
X	readprocfile();
X	str = STRalloc();
X	if(!STRgets(str, stdin)) {
X		fprintf(stderr, "%s: Null input\n", myname);
X		exit(1);
X	}
X	time(&ltime);
X	printf(intro, ctime(&ltime));
X	do {
X		if(ncopies != 0 && STRheadcompare(str, "userdict /#copies ")
X		 == 0)
X			continue;
X		if(STRcompare(str, "%%EOF\n") == 0) {
X#ifdef SAVE
X			if(finale) {
X				fputs(finale, stdout);
X				finale = NULL;
X			}
X#endif SAVE
X			STRputs(str, stdout);
X			continue;
X		}
X		if(STRheadcompare(str, "%%IncludeProcSet:") == 0) {
X			insertproc(str, INCLUDEPROC);
X			continue;
X		}
X		if(STRheadcompare(str, "%%BeginProcSet:") == 0) {
X			insertproc(str, BEGINPROC);
X			continue;
X		}
X		STRputs(str, stdout);
X		if(ncopies > 1 && isascii(*str->bufptr) &&
X		 isdigit(*str->bufptr)) {
X			cp = (char *)str->bufptr;
X			while(cp < (char *)str->curendptr && isascii(*cp)
X			 && isdigit(*cp))
X				cp++;
X			if((char *)str->curendptr - cp == 4 &&
X			 STRcompareptr(str, cp, " mf\n") == 0) {
X				printf("userdict /#copies %d put\n", ncopies);
X				ncopies = -1;
X			}
X		}
X	} while(STRgets(str, stdin));
X#ifdef SAVE
X	if(finale)
X		fputs(finale, stdout);
X#endif SAVE
X	exit(0);
X}
X
Xvoid
Xinsertproc(str, beginproc)
Xregister STR *str;
Xint beginproc;
X{
X	register char *cp, *pp;
X	register int i, n, fd;
X	register ProcSet *ps;
X	char buf[BUFSIZ];
X
X	cp = index((char *)str->bufptr, ':') + 1;
X	strcpy(buf, cp);
X	cp = buf;
X	for( ; ; cp++) {
X		if(!*cp) {
X			fprintf(stderr,
X		 "%s: Syntax error on IncludeProcSet/BeginProcSet line\n",
X			 myname);
X			exit(1);
X		}
X		if(!isascii(*cp) || !isspace(*cp))
X			break;
X	}
X	pp = cp + strlen(cp);
X	while(--pp >= cp) {
X		if(!isascii(*pp) || !isspace(*pp))
X			break;
X		*pp = 0;
X	}
X	if((ps = findprocset(cp)) == NULL) {
X		if(beginproc) {
X			STRputs(str, stdout);
X			copyproc(str, stdout);
X			return;
X		}
X		fprintf(stderr, "%s: Unknown IncludeProcSet %s\n",
X		 myname, cp);
X		exit(1);
X	}
X	if(ps->flags & PS_INCLUDED)
X		return;
X	ps->flags |= PS_INCLUDED;
X	if(*(ps->path) == '/')
X		strcpy(buf, ps->path);
X	else {
X		strcpy(buf, ucblib);
X		strcat(buf, ps->path);
X	}
X	fflush(stdout);
X	if((fd = open(buf, O_RDONLY, 0)) < 0) {
X		fprintf(stderr, "%s: Can't open %s\n", myname, buf);
X		exit(1);
X	}
X	if(beginproc)
X		copyproc(str, NULL);
X	while((i = read(fd, buf, BUFSIZ)) > 0) {
X		do {
X			if((n = write(1, buf, i)) < 0) {
X				fprintf(stderr, "%s: Write error\n", myname);
X				exit(1);
X			}
X		} while((i -= n) > 0);
X	}
X	close(fd);
X}
X
Xvoid
Xreadprocfile()
X{
X	register FILE *fp;
X	register char *pp;
X	register int linenum;
X	char buf[BUFSIZ];
X
X	strcpy(buf, ucblib);
X	strcat(buf, CONFIG);
X	if((fp = fopen(buf, "r")) == NULL) {
X		fprintf(stderr, "%s: Can't open %s\n", myname, buf);
X		exit(1);
X	}
X	linenum = 0;
X	while(fgets(buf, BUFSIZ, fp)) {
X		linenum++;
X		if(*buf == '#')
X			continue;
X		if(pp = index(buf, '\n')) {
X			if(pp == buf)
X				continue;
X			*pp = 0;
X		}
X		if(!(pp = index(buf, '\t'))) {
X			fprintf(stderr,
X			 "%s: Syntax error in macps.config, line %d\n",
X			 myname, linenum);
X			exit(1);
X		}
X		*pp++ = 0;
X		newprocset(buf, pp);
X	}
X	fclose(fp);
X}
X
Xvoid
Xcopyproc(str, fp)
Xregister STR *str;
Xregister FILE *fp;
X{
X	for( ; ; ) {
X		if(!STRgets(str, stdin)) {
X			fprintf(stderr, "%s: End of file copying ProcSet\n",
X			 myname);
X			exit(1);
X		}
X		if(fp)
X			STRputs(str, fp);
X		if(STRheadcompare(str, "%%EndProcSet") == 0)
X			return;
X	}
X}
X
Xvoid
Xnewprocset(procset, path)
Xchar *procset, *path;
X{
X	register ProcSet *ps;
X	char *calloc();
X
X	if((ps = (ProcSet *)calloc(1, sizeof(ProcSet))) == NULL) {
X		fprintf(stderr, "%s: Out of memory allocating ProcSet\n",
X		 myname);
X		exit(1);
X	}
X	if(firstprocset) {
X		lastprocset->next = ps;
X		lastprocset = ps;
X	} else
X		firstprocset = lastprocset = ps;
X	ps->procset = newstring(procset);
X	ps->path = newstring(path);
X}
X
XProcSet *
Xfindprocset(procset)
Xregister char *procset;
X{
X	register ProcSet *ps;
X
X	for(ps = firstprocset ; ps ; ps = ps->next) {
X		if(strcmp(procset, ps->procset) == 0)
X			return(ps);
X	}
X	return(NULL);
X}
X
Xchar *
Xnewstring(str)
Xregister char *str;
X{
X	register char *cp;
X	char *malloc();
X
X	if((cp = malloc(strlen(str) + 1)) == NULL) {
X		fprintf(stderr, "%s: Out of memory allocating string\n",
X		 myname);
X		exit(1);
X	}
X	strcpy(cp, str);
X	return(cp);
X}
X
Xvoid
XUsage()
X{
X	fputs("Usage: macps [-c #] [-d directory] [-r] [file]\n", stderr);
X	exit(1);
X}
END_OF_FILE
if test 7130 -ne `wc -c <'macps.c'`; then
    echo shar: \"'macps.c'\" unpacked with wrong size!
fi
# end of 'macps.c'
fi
if test -f 'macps.config' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'macps.config'\"
else
echo shar: Extracting \"'macps.config'\" \(578 characters\)
sed "s/^X//" >'macps.config' <<'END_OF_FILE'
X# This is the config file read by macps.
X# SCCSid = "@(#)macps.config	2.3 7/1/92"
X#
X# Each line is composed of the %%IncludeProcSet id, a tab and the file
X# containing the ProcSet.  If the file doesn't begin with a slash, the
X# the name is taken to be relative to the directory in which this config file
X# resides.
X
X"(AppleDict md)" 65 0	ProcSets/LaserPrep4.0
X"(AppleDict md)" 66	ProcSets/LaserPrep5.0
X"(AppleDict md)" 67 0	ProcSets/LaserPrep5.1
X"(AppleDict md)" 68 0	ProcSets/LaserPrep5.2
X"(AppleDict md)" 70 0	ProcSets/LaserPrep6.0
X"(AppleDict md)" 71 0	ProcSets/LaserPrep7.0
END_OF_FILE
if test 578 -ne `wc -c <'macps.config'`; then
    echo shar: \"'macps.config'\" unpacked with wrong size!
fi
# end of 'macps.config'
fi
if test -f 'prepfix.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prepfix.1'\"
else
echo shar: Extracting \"'prepfix.1'\" \(2344 characters\)
sed "s/^X//" >'prepfix.1' <<'END_OF_FILE'
X.\" SCCSid = "@(#)prepfix.1	2.3 7/1/92"
X.TH PREPFIX 1 "1 Jul 1992"
X.UC 4
X.SH NAME
Xprepfix \- converts Apple LaserPrep files to form useable on Unix
X.SH SYNOPSIS
X.B prepfix
X[
X\-l
Xprinter_name1
X[
X\-l
Xprinter_name2
X]...
X]
X[
Xfile
X]
X.SH DESCRIPTION
X.I Prepfix
Xtakes the command-line LaserPrep file (or the standard input if no filename is
Xgiven), and converts it into a form that is useable on Unix with the
X.IR macps (1).
X.PP
XTo use
X.IR prepfix ,
Xcreate the input LaserPrep file on a Macintosh by opening an empty
Xdocument in some application, and selecting
X.B Print
Xfrom the
X.B File
Xmenu.
XOn a pre-System 7 system, typing (and holding) Command-K immediately after
Xclicking the
X.B OK
Xbutton in the LaserWriter print dialog box will cause
Xanother dialog to appear, confirming that a file named ``PostScript'' is
Xbeing created (the Command-K keys can be released now).
XDepending on the application, the created PostScript file can be found in the
XSystem Folder, the application folder or the top level of the disk.
X.PP
XOn a System 7 system, clicking on the
X.B "PostScript File"
Xradio button and then clicking on the
X.B Save
Xbutton will cause a standard file dialog to appear, requesting the name
Xand location to save the PostScript file.
X.PP
XThis PostScript file can then be uploaded via some file transfer program,
Xsuch as MacTerminal/VersaTerm and
X.IR macget (1),
XMacKermit/Red Ryder and
X.IR kermit (1)
Xor
X.IR ftp (1).
X.PP
XNormally, only Apple LaserWriters can take advantage of the bit smoothing
Xfeature of the LaserPrep file.
XHowever, other PostScript laser printer using the Motorola 680x0 processor
Xand the Adobe PostScript firmware can be made to do bit smoothing by
Xspecifying for each printer the
X.B \-l
Xoption and the printer's name, as returned by the PostScript
X.B product
Xcommand in
X.B statusdict
X(remember to quote the printer name if it contains blanks).
XThe resulting LaserPrep file will be modified so that for LaserWriters and for
Xprinters specified in the
X.B \-l
Xoption, bit smoothing will be allowed (smoothing must still be selected in the
XPrint Dialog box when saving the PostScript to disk).
XMore than one printer name can be specified using additional
X.B \-l
Xand printer name pairs.
X.SH "SEE ALSO"
Xftp(1), macps(1), macget(1), kermit(1)
X.SH BUGS
X.I Prepfix
Xonly works with version 4.0 and up of the Macintosh LaserPrep files.
END_OF_FILE
if test 2344 -ne `wc -c <'prepfix.1'`; then
    echo shar: \"'prepfix.1'\" unpacked with wrong size!
fi
# end of 'prepfix.1'
fi
if test -f 'prepfix.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prepfix.c'\"
else
echo shar: Extracting \"'prepfix.c'\" \(6274 characters\)
sed "s/^X//" >'prepfix.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1988, 1992, The Regents of the University of California.
X * Edward Moy, Workstation Software Support Group, Workstation Support Serices,
X * Information Systems and Technology.
X *
X * Permission is granted to any individual or institution to use, copy,
X * or redistribute this software so long as it is not sold for profit,
X * provided that this notice and the original copyright notices are
X * retained.  The University of California makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X */
X
X#ifndef lint
Xstatic char *SCCSid = "@(#)prepfix.c	2.3 7/1/92";
X#endif lint
X
X#include <ctype.h>
X#include <stdio.h>
X#ifdef SYSV
X#include <string.h>
X#else SYSV
X#include <strings.h>
X#endif SYSV
X#include "str.h"
X
X#define	CLEARTOMARK	12
X#define EEXECLEN	80
X#define EXTRA		(NZEROLINE * ZEROLINE + CLEARTOMARK)
X#define LINELEN		256
X#define	NPRODUCTS	32
X#define NZEROLINE	7
X#define ZEROLINE	65
X#ifdef SYSV
X#define	index		strchr
X#define	rindex		strrchr
X#endif SYSV
X
Xchar exstr[] = "\
X%ck userdict/%s known not and{currentfile eexec}{%d{currentfile read\n\
Xpop pop}repeat}ifelse\n\
X";
Xchar *match();
Xchar *myname;
Xint maxproducts = NPRODUCTS;
Xint nproducts = 0;
Xchar Ok[] = "\
X/Ok{ok{true}{save /Pd statusdict /product get def false 0 1 ProdArr length\n\
X1 sub{Pd exch ProdArr exch get anchorsearch exch pop{pop pop true exit}if}for\n\
Xexch restore}ifelse}bind def\n\
X";
Xchar ProdArr0[] = "/ProdArr [\n";
Xchar ProdArr1[] = "] def\n";
Xchar **products;
Xchar tempname[] = "/tmp/prepfixXXXXXX";
X
Xmain(argc, argv)
Xint argc;
Xchar **argv;
X{
X	register STR *str;
X	register FILE *tp;
X	register int i;
X	register byte *lp;
X	char buf[BUFSIZ];
X	char *malloc(), *realloc();
X
X	if(myname = rindex(*argv, '/'))
X		myname++;
X	else
X		myname = *argv;
X	for(argc--, argv++ ; argc > 0 && **argv == '-' ; argc--, argv++) {
X		switch((*argv)[1]) {
X		 case 'h':
X			usage();
X		 case 'l':
X			if(nproducts <= 0 && (products =
X			 (char **)malloc(maxproducts*sizeof(char *))) == NULL) {
X				fprintf(stderr,
X				 "%s: Out of memory creating products array\n",
X				 myname);
X				exit(1);
X			} else if(nproducts >= maxproducts - 1 && (products =
X			 (char **)realloc(products, (maxproducts += NPRODUCTS)
X			 * sizeof(char *))) == NULL) {
X				fprintf(stderr,
X				 "%s: Out of memory expanding products array\n",
X				 myname);
X				exit(1);
X			}
X			if((*argv)[2])
X				products[nproducts++] = &(*argv)[2];
X			else {
X				if(argc < 2) {
X					fprintf(stderr,
X					 "%s: No argument for -l\n", myname);
X					exit(1);
X				}
X				argc--;
X				argv++;
X				products[nproducts++] = *argv;
X			}
X			break;
X		}
X	}
X	if(argc > 1)
X		usage();
X	if(argc > 0 && freopen(*argv, "r", stdin) == NULL) {
X		fprintf(stderr, "%s: Can't open %s\n", myname, *argv);
X		exit(1);
X	}
X	mktemp(tempname);
X	if((tp = fopen(tempname, "w+")) == NULL) {
X		fprintf(stderr, "%s: Can't create temp file %s\n",
X		 myname, tempname);
X		exit(1);
X	}
X	unlink(tempname);
X	str = STRalloc();
X	if(!STRgets(str, stdin)) {
X		fprintf(stderr, "%s: Null input\n", myname);
X		exit(1);
X	}
X	for( ; ; ) {
X		if(STRheadcompare(str, "% \251") == 0) {
X			fputs("% ", tp);
X			str->bufptr[0] = '(';
X			str->bufptr[1] = 'C';
X			str->bufptr[2] = ')';
X			STRputs(str, tp);
X		} else if(STRheadcompare(str, "%% \251") == 0) {
X			fputs("%%", tp);
X			str->bufptr[0] = ' ';
X			str->bufptr[1] = '(';
X			str->bufptr[2] = 'C';
X			str->bufptr[3] = ')';
X			STRputs(str, tp);
X		} else if(STRheadcompare(str, "%%BeginProcSet:") == 0) {
X			STRputs(str, stdout);
X			rewind(tp);
X			while((i = fread(buf, 1, BUFSIZ, tp)) > 0)
X				fwrite(buf, 1, i, stdout);
X			fclose(tp);
X			break;
X		} else if(STRheadcompare(str, "%{appledict") == 0)
X			STRputs(str, tp);
X		if(!STRgets(str, stdin)) {
X			fprintf(stderr, "%s: No BeginProcSet\n", myname);
X			exit(1);
X		}
X	}
X	while(STRgets(str, stdin)) {
X		if(nproducts > 0 && STRmatch(str, "/ok{")) {
X			STRputs(str, stdout);
X			fputs(ProdArr0, stdout);
X			for(i = 0 ; i < nproducts ; i++)
X				printf("(%s)\n", products[i]);
X			fputs(ProdArr1, stdout);
X			fputs(Ok, stdout);
X			continue;
X		} else if(STRmatch(str, "setdefaulttimeouts")
X		 || STRmatch(str, "setsccinteractive"))
X			continue;
X		else if(STRmatch(str, " checkload")) {
X			checkload(str);
X			continue;
X		} else if(STRmatch(str, "/stretch") && STRmatch(str, "eexec")) {
X			eexec("stretch", str);
X			continue;
X		} else if(STRmatch(str, "/smooth4") && STRmatch(str, "eexec")) {
X			eexec("smooth4", str);
X			continue;
X		} else if(STRmatch(str, "(LaserWriter II NT)")) {
X			while(STRgets(str, stdin) && STRheadcompare(str, "35de")
X			 != 0)
X				{ /* ignore line */ }
X			while(STRgets(str, stdin) && isxdigit(*str->bufptr))
X				{ /* ignore line */ }
X		} else if(lp = STRmatch(str, "scaleby96{ppr")) {
X			STRputsptr(str, lp, stdout);
X			continue;
X		} else if(STRmatch(str, "waittimeout"))
X			continue;
X		else if(STRheadcompare(str, "%%EndProcSet") == 0) {
X			STRputs(str, stdout);
X			break;
X		}
X		STRputs(str, stdout);
X	}
X	exit(0);
X}
X
Xeexec(name, str)
Xchar *name;
Xregister STR *str;
X{
X	register int len;
X
X	if(!STRgets(str, stdin)) {
X		fprintf(stderr, "%s: EOF during reading eexec\n", myname);
X		exit(1);
X	}
X	len = (str->curendptr - str->bufptr) - 1;
X	printf(exstr, nproducts > 0 ? 'O' : 'o', name, len + (len / EEXECLEN)
X	 + (len % EEXECLEN ? 1 : 0) + EXTRA);
X	spliteexec(str);
X}
X
Xcheckload(str)
Xregister STR *str;
X{
X	register byte *cp;
X
X	if(nproducts > 0 && (cp = STRmatch(str, "ok ")))
X		*cp = 'O';
X	STRputs(str, stdout);
X	if(!STRgets(str, stdin)) {
X		fprintf(stderr, "%s: EOF during reading eexec\n", myname);
X		exit(1);
X	}
X	spliteexec(str);
X}
X
Xspliteexec(str)
Xregister STR *str;
X{
X	register int len;
X	register byte *bp;
X
X	bp = str->bufptr;
X	len = (str->curendptr - bp) - 1;
X	while(len >= 80) {
X		fwrite(bp, 80, 1, stdout);
X		putchar('\n');
X		bp += 80;
X		len -= 80;
X	}
X	if(len > 0) {
X		fwrite(bp, len, 1, stdout);
X		putchar('\n');
X	}
X	for( ; ; ) {
X		if(!STRgets(str, stdin)) {
X			fprintf(stderr, "%s: EOF reached before cleartomark\n",
X			 myname);
X			exit(1);
X		}
X		STRputs(str, stdout);
X		if(STRheadcompare(str, "cleartomark") == 0)
X			return;
X	}
X}
X
Xusage()
X{
X	fprintf(stderr,
X	 "Usage: %s [-l product_name1 [-l product_name2]...] [file]\n",
X	 myname);
X	fprintf(stderr, "       %s -help\n", myname);
X	exit(1);
X}
END_OF_FILE
if test 6274 -ne `wc -c <'prepfix.c'`; then
    echo shar: \"'prepfix.c'\" unpacked with wrong size!
fi
# end of 'prepfix.c'
fi
if test -f 'str.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'str.h'\"
else
echo shar: Extracting \"'str.h'\" \(1156 characters\)
sed "s/^X//" >'str.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1988, 1992, The Regents of the University of California.
X * Edward Moy, Workstation Software Support Group, Workstation Support Serices,
X * Information Systems and Technology.
X *
X * Permission is granted to any individual or institution to use, copy,
X * or redistribute this software so long as it is not sold for profit,
X * provided that this notice and the original copyright notices are
X * retained.  The University of California makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X */
X
X/*
X * SCCSid = "@(#)str.h	2.3 7/1/92"
X */
X
X#define	STRSIZEDELTA	1024
X#define	STRSIZE		1024
X
X#define	STRcompare(str,fp)	STRcompareptr((str), (str)->bufptr, (fp))
X#define	STRheadcompare(str,fp)	STRheadcmpptr((str), (str)->bufptr, (fp))
X#define	STRputs(str,fp)		STRputsptr((str), (str)->bufptr, (fp))
X
Xtypedef unsigned char byte;
Xtypedef struct {
X	byte *bufptr;
X	byte *curendptr;
X	byte *realendptr;
X} STR;
X
Xextern int rawmode;
X
XSTR *STRalloc();
Xint STRcompareptr();
Xint STRfree();
Xint STRgets();
Xint STRheadcmpptr();
Xbyte *STRmatch();
Xint STRputsptr();
END_OF_FILE
if test 1156 -ne `wc -c <'str.h'`; then
    echo shar: \"'str.h'\" unpacked with wrong size!
fi
# end of 'str.h'
fi
if test -f 'ucbwhich.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ucbwhich.c'\"
else
echo shar: Extracting \"'ucbwhich.c'\" \(3277 characters\)
sed "s/^X//" >'ucbwhich.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1988, 1992, The Regents of the University of California.
X * Edward Moy, Workstation Software Support Group, Workstation Support Serices,
X * Information Systems and Technology.
X *
X * Permission is granted to any individual or institution to use, copy,
X * or redistribute this software so long as it is not sold for profit,
X * provided that this notice and the original copyright notices are
X * retained.  The University of California makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X */
X
X#ifndef CONFIGDIR
X#ifndef lint
Xstatic char *SCCSid = "@(#)ucbwhich.c	2.3 7/1/92";
X#endif lint
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include "ucbwhich.h"
X
X#define	F_OK		0	/* does file exist */
X#define	X_OK		1	/* is it executable by caller */
X#define	W_OK		2	/* writable by caller */
X#define	R_OK		4	/* readable by caller */
X
X#define	LIBLEN		4
X#ifdef SYSV
X#define	index		strchr
X#define	rindex		strrchr
X#endif SYSV
X
Xstatic char lib[] = "/lib";
X
Xchar ucblib[UCBMAXPATHLEN];
Xint ucbalternate = 0;
Xchar ucbpath[UCBMAXPATHLEN];
X
Xucbwhich(str)
Xchar *str;
X{
X	register char *dir, *name, *cp, *tp;
X	register int len;
X	char dirbuf[UCBMAXPATHLEN], namebuf[UCBMAXPATHLEN];
X	struct stat sbuf;
X	char *index(), *rindex(), *getwd(), *getenv();
X
X	strcpy(name = namebuf, str);
X	if(*name == '/')	/* absolute pathname */
X		*(rindex(dir = name, '/')) = 0 ; /* remove tail */
X	else {
X		if(cp = index(name, '/')) { /* relative pathname */
X			if((dir = getwd(dirbuf)) == NULL)
X				return(0);
X			 /* if any errors occurs assume standard version */
X			*cp++ = 0;
X			for( ; ; ) {
X				if(*name != 0) { /* multiple slashes */
X					if(strcmp(name, "..") == 0) {
X						/* parent directory */
X						if((tp = rindex(dir, '/')) ==
X						 NULL)
X						 	return(0);
X						if(tp == dir)
X							tp++;
X						 /* root directory */
X						*tp = 0;
X						 /* remove last component */
X					} else if(strcmp(name, ".") != 0) {
X						/* subdirectory */
X						strcat(dir, "/");
X						strcat(dir, name);
X					}
X				}
X				name = cp;
X				if((cp = index(name, '/')) == NULL) break;
X				/* ignore last component */
X				*cp++ = 0;
X			}
X		} else { /* look through $PATH variable */
X			if((tp = getenv("PATH")) == NULL)
X				return(0);
X			for(name = namebuf ; ; ) {
X				if(*tp == 0)
X					return(0);
X				else if(*tp == ':')
X					tp++;
X				if((cp = index(tp, ':')) == NULL)
X					cp = tp + strlen(tp);
X				 /* positioned on null */
X				for(dir = dirbuf ; tp < cp ; )
X					*dir++ = *tp++;
X				*dir = 0;
X				strcpy(name, dir = dirbuf);
X				strcat(name, "/");
X				strcat(name, str);
X				if(stat(name, &sbuf) < 0 || (sbuf.st_mode &
X				 S_IFMT) != S_IFREG)
X					continue;
X				if(access(name, X_OK) == 0) {
X					if(strcmp(dir, ".") == 0 &&
X					 (dir = getwd(dirbuf)) == NULL)
X						return(0);
X					break;
X				}
X			}
X		}
X	}
X	strcpy(ucbpath, dir);
X	strcpy(ucblib, dir);
X	if((len = strlen(dir)) < LIBLEN || strcmp(&dir[len - LIBLEN], lib)
X	 != 0)
X		strcat(ucblib, lib);
X	else
X		ucbpath[len - LIBLEN] = 0;
X	ucbalternate = (strcmp(ucbpath, UCBSTANDARD) != 0);
X#ifdef EBUG
X	fprintf(stderr, "ucbwhich: alt=%d path=%s lib=%s\n", ucbalternate,
X	 ucbpath, ucblib);
X#endif EBUG
X	return(ucbalternate);
X}
X#endif CONFIGDIR
END_OF_FILE
if test 3277 -ne `wc -c <'ucbwhich.c'`; then
    echo shar: \"'ucbwhich.c'\" unpacked with wrong size!
fi
# end of 'ucbwhich.c'
fi
if test -f 'ucbwhich.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ucbwhich.h'\"
else
echo shar: Extracting \"'ucbwhich.h'\" \(782 characters\)
sed "s/^X//" >'ucbwhich.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1988, 1992, The Regents of the University of California.
X * Edward Moy, Workstation Software Support Group, Workstation Support Serices,
X * Information Systems and Technology.
X *
X * Permission is granted to any individual or institution to use, copy,
X * or redistribute this software so long as it is not sold for profit,
X * provided that this notice and the original copyright notices are
X * retained.  The University of California makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X */
X
X/*
X * SCCSid = "@(#)ucbwhich.h	2.3 7/1/92"
X */
X
X#define	UCBMAXPATHLEN	128
X#define	UCBSTANDARD	"/usr/ucb"
X
Xextern char ucblib[];
Xextern int ucbalternate;
Xextern char ucbpath[];
END_OF_FILE
if test 782 -ne `wc -c <'ucbwhich.h'`; then
    echo shar: \"'ucbwhich.h'\" unpacked with wrong size!
fi
# end of 'ucbwhich.h'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
