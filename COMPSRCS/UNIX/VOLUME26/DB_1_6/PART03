Newsgroups: comp.sources.unix
From: bostic@cs.berkeley.edu (Keith Bostic)
Subject: v26i282: db-1.6 - A New Hashing Package for UNIX(tm) (updates dbm/ndbm), Part03/09
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: bostic@cs.berkeley.edu (Keith Bostic)
Posting-Number: Volume 26, Issue 282
Archive-Name: db-1.6/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 9)."
# Contents:  PORT/include/compat.h PORT/include/db.h PORT/sys/compat.h
#   PORT/sys/db.h btree/bt_get.c btree/bt_overflow.c btree/bt_utils.c
#   man/btree.3 man/mpool.3 man/recno.3 recno/rec_get.c
#   recno/rec_open.c recno/rec_put.c
# Wrapped by vixie@gw.home.vix.com on Mon Jul  5 15:27:22 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'PORT/include/compat.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PORT/include/compat.h'\"
else
echo shar: Extracting \"'PORT/include/compat.h'\" \(6332 characters\)
sed "s/^X//" >'PORT/include/compat.h' <<'END_OF_FILE'
X/*-
X * Copyright (c) 1991, 1993
X *	The Regents of the University of California.  All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X *
X *	@(#)compat.h	8.1 (Berkeley) 6/2/93
X */
X
X#ifndef	_COMPAT_H_
X#define	_COMPAT_H_
X
X/*
X * If your system doesn't typedef u_long, u_short, or u_char, change
X * the 0 to a 1.
X */
X#if 0
Xtypedef unsigned long	u_long;
Xtypedef unsigned short	u_short;
Xtypedef unsigned char	u_char;
X#endif
X
X/* If your system doesn't typedef size_t, change the 0 to a 1. */
X#if 0
Xtypedef unsigned int	size_t;
X#define	SIZE_T_MAX	UINT_MAX
X#endif
X
X/*
X * If your system doesn't specify a max size for a SIZE_T, check
X * to make sure this is the right one.
X */
X#ifndef SIZE_T_MAX
X#define	SIZE_T_MAX	UINT_MAX
X#endif
X
X/*
X * If your system doesn't have the POSIX type for a signal mask,
X * change the 0 to a 1.
X */
X#if 0
Xtypedef unsigned int	sigset_t;
X#endif
X
X/*
X * If your system's vsprintf returns a char *, not an int,
X * change the 0 to a 1.
X */
X#if 0
X#define	VSPRINTF_CHARSTAR
X#endif
X
X/*
X * If you don't have POSIX 1003.1 signals, the signal code surrounding the 
X * temporary file creation is intended to block all of the possible signals
X * long enough to create the file and unlink it.  All of this stuff is
X * intended to use old-style BSD calls to fake POSIX 1003.1 calls.
X */
X#ifdef NO_POSIX_SIGNALS
X#define sigemptyset(set)	(*(set) = 0)
X#define sigfillset(set)		(*(set) = ~(sigset_t)0, 0)
X#define sigaddset(set,signo)	(*(set) |= sigmask(signo), 0)
X#define sigdelset(set,signo)	(*(set) &= ~sigmask(signo), 0)
X#define sigismember(set,signo)	((*(set) & sigmask(signo)) != 0)
X
X#define SIG_BLOCK	1
X#define SIG_UNBLOCK	2
X#define SIG_SETMASK	3
X
Xstatic int __sigtemp;		/* For the use of sigprocmask */
X
X#define sigprocmask(how,set,oset) \
X	((__sigtemp = (((how) == SIG_BLOCK) ? \
X	sigblock(0) | *(set) : (((how) == SIG_UNBLOCK) ? \
X	sigblock(0) & ~(*(set)) : ((how) == SIG_SETMASK ? \
X	*(set) : sigblock(0))))), ((oset) ? \
X	(*(oset) = sigsetmask(__sigtemp)) : sigsetmask(__sigtemp)), 0)
X#endif
X
X/*
X * If realloc(3) of a NULL pointer on your system isn't the same as
X * a malloc(3) call, change the 0 to a 1, and add realloc.o to the
X * MISC line in your Makefile.
X */
X#if 0
X#define	realloc	__fix_realloc
X#endif
X
X/*
X * If your system doesn't have an include file with the appropriate
X * byte order set, make sure you specify the correct one.
X */
X#ifndef BYTE_ORDER
X#define LITTLE_ENDIAN	1234		/* LSB first: i386, vax */
X#define BIG_ENDIAN	4321		/* MSB first: 68000, ibm, net */
X#define BYTE_ORDER	BIG_ENDIAN	/* Set for your system. */
X#endif
X
X#if defined(SYSV) || defined(SYSTEM5)
X#define	index(a, b)		strchr(a, b)
X#define	rindex(a, b)		strrchr(a, b)
X#define	bzero(a, b)		memset(a, 0, b)
X#define	bcmp(a, b, n)		memcmp(a, b, n)
X#define	bcopy(a, b, n)		memmove(b, a, n)
X#endif
X
X#if defined(BSD) || defined(BSD4_3)
X#define	strchr(a, b)		index(a, b)
X#define	strrchr(a, b)		rindex(a, b)
X#define	memcmp(a, b, n)		bcmp(a, b, n)
X#define	memmove(a, b, n)	bcopy(b, a, n)
X#endif
X
X/*
X * 32-bit machine.  The db routines are theoretically independent of
X * the size of u_shorts and u_longs, but I don't know that anyone has
X * ever actually tried it.  At a minimum, change the following #define's
X * if you are trying to compile on a different type of system.
X */
X#ifndef USHRT_MAX
X#define	USHRT_MAX		0xFFFF
X#define	ULONG_MAX		0xFFFFFFFF
X#endif
X
X/* POSIX 1003.1 access mode mask. */
X#ifndef O_ACCMODE
X#define	O_ACCMODE	(O_RDONLY|O_WRONLY|O_RDWR)
X#endif
X
X/* POSIX 1003.2 RE limit. */
X#ifndef	_POSIX2_RE_DUP_MAX
X#define	_POSIX2_RE_DUP_MAX	255
X#endif
X
X/*
X * If you can't provide lock values in the open(2) call.  Note, this
X * allows races to happen.
X */
X#ifndef O_EXLOCK
X#define	O_EXLOCK	0
X#endif
X
X#ifndef O_SHLOCK
X#define	O_SHLOCK	0
X#endif
X
X#ifndef EFTYPE
X#define	EFTYPE		EINVAL		/* POSIX 1003.1 format errno. */
X#endif
X
X#ifndef	WCOREDUMP			/* 4.4BSD extension */
X#define	WCOREDUMP(a)	0
X#endif
X
X#ifndef	STDERR_FILENO
X#define	STDIN_FILENO	0		/* ANSI C #defines */
X#define	STDOUT_FILENO	1
X#define	STDERR_FILENO	2
X#endif
X
X#ifndef SEEK_END
X#define	SEEK_SET	0		/* POSIX 1003.1 seek values */
X#define	SEEK_CUR	1
X#define	SEEK_END	2
X#endif
X
X#ifndef S_ISLNK				/* BSD POSIX 1003.1 extensions */
X#define S_ISLNK(m)      ((m & 0170000) == 0120000)
X#define S_ISSOCK(m)     ((m & 0170000) == 0140000)
X#endif
X
X#ifndef _POSIX2_RE_DUP_MAX
X#define	_POSIX2_RE_DUP_MAX	255
X#endif
X
X#ifndef NULL				/* ANSI C #defines NULL everywhere. */
X#define	NULL		0
X#endif
X
X#ifndef	MAX
X#define	MAX(_a,_b)	((_a)<(_b)?(_b):(_a))
X#endif
X#ifndef	MIN
X#define	MIN(_a,_b)	((_a)<(_b)?(_a):(_b))
X#endif
X
X#ifndef _BSD_VA_LIST_
X#define	_BSD_VA_LIST_	char *
X#endif
X
X#endif /* !_COMPAT_H_ */
END_OF_FILE
if test 6332 -ne `wc -c <'PORT/include/compat.h'`; then
    echo shar: \"'PORT/include/compat.h'\" unpacked with wrong size!
fi
# end of 'PORT/include/compat.h'
fi
if test -f 'PORT/include/db.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PORT/include/db.h'\"
else
echo shar: Extracting \"'PORT/include/db.h'\" \(6767 characters\)
sed "s/^X//" >'PORT/include/db.h' <<'END_OF_FILE'
X/*-
X * Copyright (c) 1990, 1993
X *	The Regents of the University of California.  All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X *
X *	@(#)db.h	8.1 (Berkeley) 6/2/93
X */
X
X#ifndef _DB_H_
X#define	_DB_H_
X
X#include <sys/types.h>
X#include <sys/cdefs.h>
X
X#include "compat.h"
X
X#define	RET_ERROR	-1		/* Return values. */
X#define	RET_SUCCESS	 0
X#define	RET_SPECIAL	 1
X
X#define	MAX_PAGE_NUMBER	ULONG_MAX	/* >= # of pages in a file */
Xtypedef u_long	pgno_t;
X#define	MAX_PAGE_OFFSET	USHRT_MAX	/* >= # of bytes in a page */
Xtypedef u_short	indx_t;
X#define	MAX_REC_NUMBER	ULONG_MAX	/* >= # of records in a tree */
Xtypedef u_long	recno_t;
X
X/* Key/data structure -- a Data-Base Thang. */
Xtypedef struct {
X	void	*data;			/* data */
X	size_t	 size;			/* data length */
X} DBT;
X
X/* Routine flags. */
X#define	R_CURSOR	1		/* del, put, seq */
X#define	__R_UNUSED	2		/* UNUSED */
X#define	R_FIRST		3		/* seq */
X#define	R_IAFTER	4		/* put (RECNO) */
X#define	R_IBEFORE	5		/* put (RECNO) */
X#define	R_LAST		6		/* seq (BTREE, RECNO) */
X#define	R_NEXT		7		/* seq */
X#define	R_NOOVERWRITE	8		/* put */
X#define	R_PREV		9		/* seq (BTREE, RECNO) */
X#define	R_SETCURSOR	10		/* put (RECNO) */
X#define	R_RECNOSYNC	11		/* sync (RECNO) */
X
Xtypedef enum { DB_BTREE, DB_HASH, DB_RECNO } DBTYPE;
X
X#define	__USE_OPEN_FLAGS \
X	(O_CREAT|O_EXCL|O_EXLOCK|O_RDONLY|O_RDWR|O_SHLOCK|O_TRUNC)
X
X/* Access method description structure. */
Xtypedef struct __db {
X	DBTYPE type;			/* underlying db type */
X	int (*close)	__P((struct __db *));
X	int (*del)	__P((const struct __db *, const DBT *, u_int));
X	int (*fd)	__P((const struct __db *));
X	int (*get)	__P((const struct __db *, const DBT *, DBT *, u_int));
X	int (*put)	__P((const struct __db *, DBT *, const DBT *, u_int));
X	int (*seq)	__P((const struct __db *, DBT *, DBT *, u_int));
X	int (*sync)	__P((const struct __db *, u_int));
X	void *internal;			/* access method private */
X} DB;
X
X#define	BTREEMAGIC	0x053162
X#define	BTREEVERSION	3
X
X/* Structure used to pass parameters to the btree routines. */
Xtypedef struct {
X#define	R_DUP		0x01	/* duplicate keys */
X	u_long	 flags;
X	int	 cachesize;	/* bytes to cache */
X	int	 maxkeypage;	/* maximum keys per page */
X	int	 minkeypage;	/* minimum keys per page */
X	int	 psize;		/* page size */
X				/* comparison, prefix functions */
X	int	 (*compare)	__P((const DBT *, const DBT *));
X	int	 (*prefix)	__P((const DBT *, const DBT *));
X	int	 lorder;	/* byte order */
X} BTREEINFO;
X
X#define	HASHMAGIC	0x061561
X#define	HASHVERSION	2
X
X/* Structure used to pass parameters to the hashing routines. */
Xtypedef struct {
X	int	 bsize;		/* bucket size */
X	int	 ffactor;	/* fill factor */
X	int	 nelem;		/* number of elements */
X	int	 cachesize;	/* bytes to cache */
X				/* hash function */
X	int	 (*hash) __P((const void *, size_t));
X	int	 lorder;	/* byte order */
X} HASHINFO;
X
X/* Structure used to pass parameters to the record routines. */
Xtypedef struct {
X#define	R_FIXEDLEN	0x01	/* fixed-length records */
X#define	R_NOKEY		0x02	/* key not required */
X#define	R_SNAPSHOT	0x04	/* snapshot the input */
X	u_long	 flags;
X	int	 cachesize;	/* bytes to cache */
X	int	 psize;		/* page size */
X	int	 lorder;	/* byte order */
X	size_t	 reclen;	/* record length (fixed-length records) */
X	u_char	 bval;		/* delimiting byte (variable-length records */
X	char	*bfname;	/* btree file name */ 
X} RECNOINFO;
X
X/*
X * Little endian <==> big endian long swap macros.
X *	BLSWAP		swap a memory location
X *	BLPSWAP		swap a referenced memory location
X *	BLSWAP_COPY	swap from one location to another
X */
X#define BLSWAP(a) { \
X	u_long _tmp = a; \
X	((char *)&a)[0] = ((char *)&_tmp)[3]; \
X	((char *)&a)[1] = ((char *)&_tmp)[2]; \
X	((char *)&a)[2] = ((char *)&_tmp)[1]; \
X	((char *)&a)[3] = ((char *)&_tmp)[0]; \
X}
X#define	BLPSWAP(a) { \
X	u_long _tmp = *(u_long *)a; \
X	((char *)a)[0] = ((char *)&_tmp)[3]; \
X	((char *)a)[1] = ((char *)&_tmp)[2]; \
X	((char *)a)[2] = ((char *)&_tmp)[1]; \
X	((char *)a)[3] = ((char *)&_tmp)[0]; \
X}
X#define	BLSWAP_COPY(a, b) { \
X	((char *)&(b))[0] = ((char *)&(a))[3]; \
X	((char *)&(b))[1] = ((char *)&(a))[2]; \
X	((char *)&(b))[2] = ((char *)&(a))[1]; \
X	((char *)&(b))[3] = ((char *)&(a))[0]; \
X}
X
X/*
X * Little endian <==> big endian short swap macros.
X *	BSSWAP		swap a memory location
X *	BSPSWAP		swap a referenced memory location
X *	BSSWAP_COPY	swap from one location to another
X */
X#define BSSWAP(a) { \
X	u_short _tmp = a; \
X	((char *)&a)[0] = ((char *)&_tmp)[1]; \
X	((char *)&a)[1] = ((char *)&_tmp)[0]; \
X}
X#define BSPSWAP(a) { \
X	u_short _tmp = *(u_short *)a; \
X	((char *)a)[0] = ((char *)&_tmp)[1]; \
X	((char *)a)[1] = ((char *)&_tmp)[0]; \
X}
X#define BSSWAP_COPY(a, b) { \
X	((char *)&(b))[0] = ((char *)&(a))[1]; \
X	((char *)&(b))[1] = ((char *)&(a))[0]; \
X}
X
X__BEGIN_DECLS
XDB *dbopen __P((const char *, int, int, DBTYPE, const void *));
X
X#ifdef __DBINTERFACE_PRIVATE
XDB	*__bt_open __P((const char *, int, int, const BTREEINFO *));
XDB	*__hash_open __P((const char *, int, int, const HASHINFO *));
XDB	*__rec_open __P((const char *, int, int, const RECNOINFO *));
Xvoid	 __dbpanic __P((DB *dbp));
X#endif
X__END_DECLS
X#endif /* !_DB_H_ */
END_OF_FILE
if test 6767 -ne `wc -c <'PORT/include/db.h'`; then
    echo shar: \"'PORT/include/db.h'\" unpacked with wrong size!
fi
# end of 'PORT/include/db.h'
fi
if test -f 'PORT/sys/compat.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PORT/sys/compat.h'\"
else
echo shar: Extracting \"'PORT/sys/compat.h'\" \(6332 characters\)
sed "s/^X//" >'PORT/sys/compat.h' <<'END_OF_FILE'
X/*-
X * Copyright (c) 1991, 1993
X *	The Regents of the University of California.  All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X *
X *	@(#)compat.h	8.1 (Berkeley) 6/2/93
X */
X
X#ifndef	_COMPAT_H_
X#define	_COMPAT_H_
X
X/*
X * If your system doesn't typedef u_long, u_short, or u_char, change
X * the 0 to a 1.
X */
X#if 0
Xtypedef unsigned long	u_long;
Xtypedef unsigned short	u_short;
Xtypedef unsigned char	u_char;
X#endif
X
X/* If your system doesn't typedef size_t, change the 0 to a 1. */
X#if 0
Xtypedef unsigned int	size_t;
X#define	SIZE_T_MAX	UINT_MAX
X#endif
X
X/*
X * If your system doesn't specify a max size for a SIZE_T, check
X * to make sure this is the right one.
X */
X#ifndef SIZE_T_MAX
X#define	SIZE_T_MAX	UINT_MAX
X#endif
X
X/*
X * If your system doesn't have the POSIX type for a signal mask,
X * change the 0 to a 1.
X */
X#if 0
Xtypedef unsigned int	sigset_t;
X#endif
X
X/*
X * If your system's vsprintf returns a char *, not an int,
X * change the 0 to a 1.
X */
X#if 0
X#define	VSPRINTF_CHARSTAR
X#endif
X
X/*
X * If you don't have POSIX 1003.1 signals, the signal code surrounding the 
X * temporary file creation is intended to block all of the possible signals
X * long enough to create the file and unlink it.  All of this stuff is
X * intended to use old-style BSD calls to fake POSIX 1003.1 calls.
X */
X#ifdef NO_POSIX_SIGNALS
X#define sigemptyset(set)	(*(set) = 0)
X#define sigfillset(set)		(*(set) = ~(sigset_t)0, 0)
X#define sigaddset(set,signo)	(*(set) |= sigmask(signo), 0)
X#define sigdelset(set,signo)	(*(set) &= ~sigmask(signo), 0)
X#define sigismember(set,signo)	((*(set) & sigmask(signo)) != 0)
X
X#define SIG_BLOCK	1
X#define SIG_UNBLOCK	2
X#define SIG_SETMASK	3
X
Xstatic int __sigtemp;		/* For the use of sigprocmask */
X
X#define sigprocmask(how,set,oset) \
X	((__sigtemp = (((how) == SIG_BLOCK) ? \
X	sigblock(0) | *(set) : (((how) == SIG_UNBLOCK) ? \
X	sigblock(0) & ~(*(set)) : ((how) == SIG_SETMASK ? \
X	*(set) : sigblock(0))))), ((oset) ? \
X	(*(oset) = sigsetmask(__sigtemp)) : sigsetmask(__sigtemp)), 0)
X#endif
X
X/*
X * If realloc(3) of a NULL pointer on your system isn't the same as
X * a malloc(3) call, change the 0 to a 1, and add realloc.o to the
X * MISC line in your Makefile.
X */
X#if 0
X#define	realloc	__fix_realloc
X#endif
X
X/*
X * If your system doesn't have an include file with the appropriate
X * byte order set, make sure you specify the correct one.
X */
X#ifndef BYTE_ORDER
X#define LITTLE_ENDIAN	1234		/* LSB first: i386, vax */
X#define BIG_ENDIAN	4321		/* MSB first: 68000, ibm, net */
X#define BYTE_ORDER	BIG_ENDIAN	/* Set for your system. */
X#endif
X
X#if defined(SYSV) || defined(SYSTEM5)
X#define	index(a, b)		strchr(a, b)
X#define	rindex(a, b)		strrchr(a, b)
X#define	bzero(a, b)		memset(a, 0, b)
X#define	bcmp(a, b, n)		memcmp(a, b, n)
X#define	bcopy(a, b, n)		memmove(b, a, n)
X#endif
X
X#if defined(BSD) || defined(BSD4_3)
X#define	strchr(a, b)		index(a, b)
X#define	strrchr(a, b)		rindex(a, b)
X#define	memcmp(a, b, n)		bcmp(a, b, n)
X#define	memmove(a, b, n)	bcopy(b, a, n)
X#endif
X
X/*
X * 32-bit machine.  The db routines are theoretically independent of
X * the size of u_shorts and u_longs, but I don't know that anyone has
X * ever actually tried it.  At a minimum, change the following #define's
X * if you are trying to compile on a different type of system.
X */
X#ifndef USHRT_MAX
X#define	USHRT_MAX		0xFFFF
X#define	ULONG_MAX		0xFFFFFFFF
X#endif
X
X/* POSIX 1003.1 access mode mask. */
X#ifndef O_ACCMODE
X#define	O_ACCMODE	(O_RDONLY|O_WRONLY|O_RDWR)
X#endif
X
X/* POSIX 1003.2 RE limit. */
X#ifndef	_POSIX2_RE_DUP_MAX
X#define	_POSIX2_RE_DUP_MAX	255
X#endif
X
X/*
X * If you can't provide lock values in the open(2) call.  Note, this
X * allows races to happen.
X */
X#ifndef O_EXLOCK
X#define	O_EXLOCK	0
X#endif
X
X#ifndef O_SHLOCK
X#define	O_SHLOCK	0
X#endif
X
X#ifndef EFTYPE
X#define	EFTYPE		EINVAL		/* POSIX 1003.1 format errno. */
X#endif
X
X#ifndef	WCOREDUMP			/* 4.4BSD extension */
X#define	WCOREDUMP(a)	0
X#endif
X
X#ifndef	STDERR_FILENO
X#define	STDIN_FILENO	0		/* ANSI C #defines */
X#define	STDOUT_FILENO	1
X#define	STDERR_FILENO	2
X#endif
X
X#ifndef SEEK_END
X#define	SEEK_SET	0		/* POSIX 1003.1 seek values */
X#define	SEEK_CUR	1
X#define	SEEK_END	2
X#endif
X
X#ifndef S_ISLNK				/* BSD POSIX 1003.1 extensions */
X#define S_ISLNK(m)      ((m & 0170000) == 0120000)
X#define S_ISSOCK(m)     ((m & 0170000) == 0140000)
X#endif
X
X#ifndef _POSIX2_RE_DUP_MAX
X#define	_POSIX2_RE_DUP_MAX	255
X#endif
X
X#ifndef NULL				/* ANSI C #defines NULL everywhere. */
X#define	NULL		0
X#endif
X
X#ifndef	MAX
X#define	MAX(_a,_b)	((_a)<(_b)?(_b):(_a))
X#endif
X#ifndef	MIN
X#define	MIN(_a,_b)	((_a)<(_b)?(_a):(_b))
X#endif
X
X#ifndef _BSD_VA_LIST_
X#define	_BSD_VA_LIST_	char *
X#endif
X
X#endif /* !_COMPAT_H_ */
END_OF_FILE
if test 6332 -ne `wc -c <'PORT/sys/compat.h'`; then
    echo shar: \"'PORT/sys/compat.h'\" unpacked with wrong size!
fi
# end of 'PORT/sys/compat.h'
fi
if test -f 'PORT/sys/db.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PORT/sys/db.h'\"
else
echo shar: Extracting \"'PORT/sys/db.h'\" \(6767 characters\)
sed "s/^X//" >'PORT/sys/db.h' <<'END_OF_FILE'
X/*-
X * Copyright (c) 1990, 1993
X *	The Regents of the University of California.  All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X *
X *	@(#)db.h	8.1 (Berkeley) 6/2/93
X */
X
X#ifndef _DB_H_
X#define	_DB_H_
X
X#include <sys/types.h>
X#include <sys/cdefs.h>
X
X#include "compat.h"
X
X#define	RET_ERROR	-1		/* Return values. */
X#define	RET_SUCCESS	 0
X#define	RET_SPECIAL	 1
X
X#define	MAX_PAGE_NUMBER	ULONG_MAX	/* >= # of pages in a file */
Xtypedef u_long	pgno_t;
X#define	MAX_PAGE_OFFSET	USHRT_MAX	/* >= # of bytes in a page */
Xtypedef u_short	indx_t;
X#define	MAX_REC_NUMBER	ULONG_MAX	/* >= # of records in a tree */
Xtypedef u_long	recno_t;
X
X/* Key/data structure -- a Data-Base Thang. */
Xtypedef struct {
X	void	*data;			/* data */
X	size_t	 size;			/* data length */
X} DBT;
X
X/* Routine flags. */
X#define	R_CURSOR	1		/* del, put, seq */
X#define	__R_UNUSED	2		/* UNUSED */
X#define	R_FIRST		3		/* seq */
X#define	R_IAFTER	4		/* put (RECNO) */
X#define	R_IBEFORE	5		/* put (RECNO) */
X#define	R_LAST		6		/* seq (BTREE, RECNO) */
X#define	R_NEXT		7		/* seq */
X#define	R_NOOVERWRITE	8		/* put */
X#define	R_PREV		9		/* seq (BTREE, RECNO) */
X#define	R_SETCURSOR	10		/* put (RECNO) */
X#define	R_RECNOSYNC	11		/* sync (RECNO) */
X
Xtypedef enum { DB_BTREE, DB_HASH, DB_RECNO } DBTYPE;
X
X#define	__USE_OPEN_FLAGS \
X	(O_CREAT|O_EXCL|O_EXLOCK|O_RDONLY|O_RDWR|O_SHLOCK|O_TRUNC)
X
X/* Access method description structure. */
Xtypedef struct __db {
X	DBTYPE type;			/* underlying db type */
X	int (*close)	__P((struct __db *));
X	int (*del)	__P((const struct __db *, const DBT *, u_int));
X	int (*fd)	__P((const struct __db *));
X	int (*get)	__P((const struct __db *, const DBT *, DBT *, u_int));
X	int (*put)	__P((const struct __db *, DBT *, const DBT *, u_int));
X	int (*seq)	__P((const struct __db *, DBT *, DBT *, u_int));
X	int (*sync)	__P((const struct __db *, u_int));
X	void *internal;			/* access method private */
X} DB;
X
X#define	BTREEMAGIC	0x053162
X#define	BTREEVERSION	3
X
X/* Structure used to pass parameters to the btree routines. */
Xtypedef struct {
X#define	R_DUP		0x01	/* duplicate keys */
X	u_long	 flags;
X	int	 cachesize;	/* bytes to cache */
X	int	 maxkeypage;	/* maximum keys per page */
X	int	 minkeypage;	/* minimum keys per page */
X	int	 psize;		/* page size */
X				/* comparison, prefix functions */
X	int	 (*compare)	__P((const DBT *, const DBT *));
X	int	 (*prefix)	__P((const DBT *, const DBT *));
X	int	 lorder;	/* byte order */
X} BTREEINFO;
X
X#define	HASHMAGIC	0x061561
X#define	HASHVERSION	2
X
X/* Structure used to pass parameters to the hashing routines. */
Xtypedef struct {
X	int	 bsize;		/* bucket size */
X	int	 ffactor;	/* fill factor */
X	int	 nelem;		/* number of elements */
X	int	 cachesize;	/* bytes to cache */
X				/* hash function */
X	int	 (*hash) __P((const void *, size_t));
X	int	 lorder;	/* byte order */
X} HASHINFO;
X
X/* Structure used to pass parameters to the record routines. */
Xtypedef struct {
X#define	R_FIXEDLEN	0x01	/* fixed-length records */
X#define	R_NOKEY		0x02	/* key not required */
X#define	R_SNAPSHOT	0x04	/* snapshot the input */
X	u_long	 flags;
X	int	 cachesize;	/* bytes to cache */
X	int	 psize;		/* page size */
X	int	 lorder;	/* byte order */
X	size_t	 reclen;	/* record length (fixed-length records) */
X	u_char	 bval;		/* delimiting byte (variable-length records */
X	char	*bfname;	/* btree file name */ 
X} RECNOINFO;
X
X/*
X * Little endian <==> big endian long swap macros.
X *	BLSWAP		swap a memory location
X *	BLPSWAP		swap a referenced memory location
X *	BLSWAP_COPY	swap from one location to another
X */
X#define BLSWAP(a) { \
X	u_long _tmp = a; \
X	((char *)&a)[0] = ((char *)&_tmp)[3]; \
X	((char *)&a)[1] = ((char *)&_tmp)[2]; \
X	((char *)&a)[2] = ((char *)&_tmp)[1]; \
X	((char *)&a)[3] = ((char *)&_tmp)[0]; \
X}
X#define	BLPSWAP(a) { \
X	u_long _tmp = *(u_long *)a; \
X	((char *)a)[0] = ((char *)&_tmp)[3]; \
X	((char *)a)[1] = ((char *)&_tmp)[2]; \
X	((char *)a)[2] = ((char *)&_tmp)[1]; \
X	((char *)a)[3] = ((char *)&_tmp)[0]; \
X}
X#define	BLSWAP_COPY(a, b) { \
X	((char *)&(b))[0] = ((char *)&(a))[3]; \
X	((char *)&(b))[1] = ((char *)&(a))[2]; \
X	((char *)&(b))[2] = ((char *)&(a))[1]; \
X	((char *)&(b))[3] = ((char *)&(a))[0]; \
X}
X
X/*
X * Little endian <==> big endian short swap macros.
X *	BSSWAP		swap a memory location
X *	BSPSWAP		swap a referenced memory location
X *	BSSWAP_COPY	swap from one location to another
X */
X#define BSSWAP(a) { \
X	u_short _tmp = a; \
X	((char *)&a)[0] = ((char *)&_tmp)[1]; \
X	((char *)&a)[1] = ((char *)&_tmp)[0]; \
X}
X#define BSPSWAP(a) { \
X	u_short _tmp = *(u_short *)a; \
X	((char *)a)[0] = ((char *)&_tmp)[1]; \
X	((char *)a)[1] = ((char *)&_tmp)[0]; \
X}
X#define BSSWAP_COPY(a, b) { \
X	((char *)&(b))[0] = ((char *)&(a))[1]; \
X	((char *)&(b))[1] = ((char *)&(a))[0]; \
X}
X
X__BEGIN_DECLS
XDB *dbopen __P((const char *, int, int, DBTYPE, const void *));
X
X#ifdef __DBINTERFACE_PRIVATE
XDB	*__bt_open __P((const char *, int, int, const BTREEINFO *));
XDB	*__hash_open __P((const char *, int, int, const HASHINFO *));
XDB	*__rec_open __P((const char *, int, int, const RECNOINFO *));
Xvoid	 __dbpanic __P((DB *dbp));
X#endif
X__END_DECLS
X#endif /* !_DB_H_ */
END_OF_FILE
if test 6767 -ne `wc -c <'PORT/sys/db.h'`; then
    echo shar: \"'PORT/sys/db.h'\" unpacked with wrong size!
fi
# end of 'PORT/sys/db.h'
fi
if test -f 'btree/bt_get.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'btree/bt_get.c'\"
else
echo shar: Extracting \"'btree/bt_get.c'\" \(6264 characters\)
sed "s/^X//" >'btree/bt_get.c' <<'END_OF_FILE'
X/*-
X * Copyright (c) 1990, 1993
X *	The Regents of the University of California.  All rights reserved.
X *
X * This code is derived from software contributed to Berkeley by
X * Mike Olson.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#if defined(LIBC_SCCS) && !defined(lint)
Xstatic char sccsid[] = "@(#)bt_get.c	8.1 (Berkeley) 6/4/93";
X#endif /* LIBC_SCCS and not lint */
X
X#include <sys/types.h>
X
X#include <errno.h>
X#include <stddef.h>
X#include <stdio.h>
X
X#include <db.h>
X#include "btree.h"
X
X/*
X * __BT_GET -- Get a record from the btree.
X *
X * Parameters:
X *	dbp:	pointer to access method
X *	key:	key to find
X *	data:	data to return
X *	flag:	currently unused
X *
X * Returns:
X *	RET_ERROR, RET_SUCCESS and RET_SPECIAL if the key not found.
X */
Xint
X__bt_get(dbp, key, data, flags)
X	const DB *dbp;
X	const DBT *key;
X	DBT *data;
X	u_int flags;
X{
X	BTREE *t;
X	EPG *e;
X	int exact, status;
X
X	if (flags) {
X		errno = EINVAL;
X		return (RET_ERROR);
X	}
X	t = dbp->internal;
X	if ((e = __bt_search(t, key, &exact)) == NULL)
X		return (RET_ERROR);
X	if (!exact) {
X		mpool_put(t->bt_mp, e->page, 0);
X		return (RET_SPECIAL);
X	}
X
X	/*
X	 * A special case is if we found the record but it's flagged for
X	 * deletion.  In this case, we want to find another record with the
X	 * same key, if it exists.  Rather than look around the tree we call
X	 * __bt_first and have it redo the search, as __bt_first will not
X	 * return keys marked for deletion.  Slow, but should never happen.
X	 */
X	if (ISSET(t, B_DELCRSR) && e->page->pgno == t->bt_bcursor.pgno &&
X	    e->index == t->bt_bcursor.index) {
X		mpool_put(t->bt_mp, e->page, 0);
X		if ((e = __bt_first(t, key, &exact)) == NULL)
X			return (RET_ERROR);
X		if (!exact)
X			return (RET_SPECIAL);
X	}
X
X	status = __bt_ret(t, e, NULL, data);
X	mpool_put(t->bt_mp, e->page, 0);
X	return (status);
X}
X
X/*
X * __BT_FIRST -- Find the first entry.
X *
X * Parameters:
X *	t:	the tree
X *	key:	the key
X *
X * Returns:
X *	The first entry in the tree greater than or equal to key.
X */
XEPG *
X__bt_first(t, key, exactp)
X	BTREE *t;
X	const DBT *key;
X	int *exactp;
X{
X	register PAGE *h;
X	register EPG *e;
X	EPG save;
X	pgno_t cpgno, pg;
X	indx_t cindex;
X	int found;
X
X	/*
X	 * Find any matching record; __bt_search pins the page.  Only exact
X	 * matches are tricky, otherwise just return the location of the key
X	 * if it were to be inserted into the tree.
X	 */
X	if ((e = __bt_search(t, key, exactp)) == NULL)
X		return (NULL);
X	if (!*exactp)
X		return (e);
X
X	if (ISSET(t, B_DELCRSR)) {
X		cpgno = t->bt_bcursor.pgno;
X		cindex = t->bt_bcursor.index;
X	} else {
X		cpgno = P_INVALID;
X		cindex = 0;		/* GCC thinks it's uninitialized. */
X	}
X
X	/*
X	 * Walk backwards, skipping empty pages, as long as the entry matches
X	 * and there are keys left in the tree.  Save a copy of each match in
X	 * case we go too far.  A special case is that we don't return a match
X	 * on records that the cursor references that have already been flagged
X	 * for deletion.
X	 */
X	save = *e;
X	h = e->page;
X	found = 0;
X	do {
X		if (cpgno != h->pgno || cindex != e->index) {
X			if (save.page->pgno != e->page->pgno) {
X				mpool_put(t->bt_mp, save.page, 0);
X				save = *e;
X			} else
X				save.index = e->index;
X			found = 1;
X		}
X		/*
X		 * Make a special effort not to unpin the page the last (or
X		 * original) match was on, but also make sure it's unpinned
X		 * if an error occurs.
X		 */
X		while (e->index == 0) {
X			if (h->prevpg == P_INVALID)
X				goto done1;
X			if (h->pgno != save.page->pgno)
X				mpool_put(t->bt_mp, h, 0);
X			if ((h = mpool_get(t->bt_mp, h->prevpg, 0)) == NULL) {
X				if (h->pgno == save.page->pgno)
X					mpool_put(t->bt_mp, save.page, 0);
X				return (NULL);
X			}
X			e->page = h;
X			e->index = NEXTINDEX(h);
X		}
X		--e->index;
X	} while (__bt_cmp(t, key, e) == 0);
X
X	/*
X	 * Reach here with the last page that was looked at pinned, which may
X	 * or may not be the same as the last (or original) match page.  If
X	 * it's not useful, release it.
X	 */
Xdone1:	if (h->pgno != save.page->pgno)
X		mpool_put(t->bt_mp, h, 0);
X
X	/*
X	 * If still haven't found a record, the only possibility left is the
X	 * next one.  Move forward one slot, skipping empty pages and check.
X	 */
X	if (!found) {
X		h = save.page;
X		if (++save.index == NEXTINDEX(h)) {
X			do {
X				pg = h->nextpg;
X				mpool_put(t->bt_mp, h, 0);
X				if (pg == P_INVALID) {
X					*exactp = 0;
X					return (e);
X				}
X				if ((h = mpool_get(t->bt_mp, pg, 0)) == NULL)
X					return (NULL);
X			} while ((save.index = NEXTINDEX(h)) == 0);
X			save.page = h;
X		}
X		if (__bt_cmp(t, key, &save) != 0) {
X			*exactp = 0;
X			return (e);
X		}
X	}
X	*e = save;
X	*exactp = 1;
X	return (e);
X}
END_OF_FILE
if test 6264 -ne `wc -c <'btree/bt_get.c'`; then
    echo shar: \"'btree/bt_get.c'\" unpacked with wrong size!
fi
# end of 'btree/bt_get.c'
fi
if test -f 'btree/bt_overflow.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'btree/bt_overflow.c'\"
else
echo shar: Extracting \"'btree/bt_overflow.c'\" \(5854 characters\)
sed "s/^X//" >'btree/bt_overflow.c' <<'END_OF_FILE'
X/*-
X * Copyright (c) 1990, 1993
X *	The Regents of the University of California.  All rights reserved.
X *
X * This code is derived from software contributed to Berkeley by
X * Mike Olson.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#if defined(LIBC_SCCS) && !defined(lint)
Xstatic char sccsid[] = "@(#)bt_overflow.c	8.1 (Berkeley) 6/4/93";
X#endif /* LIBC_SCCS and not lint */
X
X#include <sys/param.h>
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X
X#include <db.h>
X#include "btree.h"
X
X/*
X * Big key/data code.
X *
X * Big key and data entries are stored on linked lists of pages.  The initial
X * reference is byte string stored with the key or data and is the page number
X * and size.  The actual record is stored in a chain of pages linked by the
X * nextpg field of the PAGE header.
X *
X * The first page of the chain has a special property.  If the record is used
X * by an internal page, it cannot be deleted and the P_PRESERVE bit will be set
X * in the header.
X *
X * XXX
X * A single DBT is written to each chain, so a lot of space on the last page
X * is wasted.  This is a fairly major bug for some data sets.
X */
X
X/*
X * __OVFL_GET -- Get an overflow key/data item.
X *
X * Parameters:
X *	t:	tree
X *	p:	pointer to { pgno_t, size_t }
X *	buf:	storage address
X *	bufsz:	storage size
X *
X * Returns:
X *	RET_ERROR, RET_SUCCESS
X */
Xint
X__ovfl_get(t, p, ssz, buf, bufsz)
X	BTREE *t;
X	void *p;
X	size_t *ssz;
X	char **buf;
X	size_t *bufsz;
X{
X	PAGE *h;
X	pgno_t pg;
X	size_t nb, plen, sz;
X
X	memmove(&pg, p, sizeof(pgno_t));
X	memmove(&sz, (char *)p + sizeof(pgno_t), sizeof(size_t));
X	*ssz = sz;
X
X#ifdef DEBUG
X	if (pg == P_INVALID || sz == 0)
X		abort();
X#endif
X	/* Make the buffer bigger as necessary. */
X	if (*bufsz < sz) {
X		if ((*buf = realloc(*buf, sz)) == NULL)
X			return (RET_ERROR);
X		*bufsz = sz;
X	}
X
X	/*
X	 * Step through the linked list of pages, copying the data on each one
X	 * into the buffer.  Never copy more than the data's length.
X	 */
X	plen = t->bt_psize - BTDATAOFF;
X	for (p = *buf;; p = (char *)p + nb, pg = h->nextpg) {
X		if ((h = mpool_get(t->bt_mp, pg, 0)) == NULL)
X			return (RET_ERROR);
X
X		nb = MIN(sz, plen);
X		memmove(p, (char *)h + BTDATAOFF, nb);
X		mpool_put(t->bt_mp, h, 0);
X
X		if ((sz -= nb) == 0)
X			break;
X	}
X	return (RET_SUCCESS);
X}
X
X/*
X * __OVFL_PUT -- Store an overflow key/data item.
X *
X * Parameters:
X *	t:	tree
X *	data:	DBT to store
X *	pgno:	storage page number
X *
X * Returns:
X *	RET_ERROR, RET_SUCCESS
X */
Xint
X__ovfl_put(t, dbt, pg)
X	BTREE *t;
X	const DBT *dbt;
X	pgno_t *pg;
X{
X	PAGE *h, *last;
X	void *p;
X	pgno_t npg;
X	size_t nb, plen, sz;
X
X	/*
X	 * Allocate pages and copy the key/data record into them.  Store the
X	 * number of the first page in the chain.
X	 */
X	plen = t->bt_psize - BTDATAOFF;
X	for (last = NULL, p = dbt->data, sz = dbt->size;;
X	    p = (char *)p + plen, last = h) {
X		if ((h = __bt_new(t, &npg)) == NULL)
X			return (RET_ERROR);
X
X		h->pgno = npg;
X		h->nextpg = h->prevpg = P_INVALID;
X		h->flags = P_OVERFLOW;
X		h->lower = h->upper = 0;
X
X		nb = MIN(sz, plen);
X		memmove((char *)h + BTDATAOFF, p, nb);
X
X		if (last) {
X			last->nextpg = h->pgno;
X			mpool_put(t->bt_mp, last, MPOOL_DIRTY);
X		} else
X			*pg = h->pgno;
X
X		if ((sz -= nb) == 0) {
X			mpool_put(t->bt_mp, h, MPOOL_DIRTY);
X			break;
X		}
X	}
X	return (RET_SUCCESS);
X}
X
X/*
X * __OVFL_DELETE -- Delete an overflow chain.
X *
X * Parameters:
X *	t:	tree
X *	p:	pointer to { pgno_t, size_t }
X *
X * Returns:
X *	RET_ERROR, RET_SUCCESS
X */
Xint
X__ovfl_delete(t, p)
X	BTREE *t;
X	void *p;
X{
X	PAGE *h;
X	pgno_t pg;
X	size_t plen, sz;
X
X	memmove(&pg, p, sizeof(pgno_t));
X	memmove(&sz, (char *)p + sizeof(pgno_t), sizeof(size_t));
X
X#ifdef DEBUG
X	if (pg == P_INVALID || sz == 0)
X		abort();
X#endif
X	if ((h = mpool_get(t->bt_mp, pg, 0)) == NULL)
X		return (RET_ERROR);
X
X	/* Don't delete chains used by internal pages. */
X	if (h->flags & P_PRESERVE) {
X		mpool_put(t->bt_mp, h, 0);
X		return (RET_SUCCESS);
X	}
X
X	/* Step through the chain, calling the free routine for each page. */
X	for (plen = t->bt_psize - BTDATAOFF;; sz -= plen) {
X		pg = h->nextpg;
X		__bt_free(t, h);
X		if (sz <= plen)
X			break;
X		if ((h = mpool_get(t->bt_mp, pg, 0)) == NULL)
X			return (RET_ERROR);
X	}
X	return (RET_SUCCESS);
X}
END_OF_FILE
if test 5854 -ne `wc -c <'btree/bt_overflow.c'`; then
    echo shar: \"'btree/bt_overflow.c'\" unpacked with wrong size!
fi
# end of 'btree/bt_overflow.c'
fi
if test -f 'btree/bt_utils.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'btree/bt_utils.c'\"
else
echo shar: Extracting \"'btree/bt_utils.c'\" \(5835 characters\)
sed "s/^X//" >'btree/bt_utils.c' <<'END_OF_FILE'
X/*-
X * Copyright (c) 1990, 1993
X *	The Regents of the University of California.  All rights reserved.
X *
X * This code is derived from software contributed to Berkeley by
X * Mike Olson.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#if defined(LIBC_SCCS) && !defined(lint)
Xstatic char sccsid[] = "@(#)bt_utils.c	8.1 (Berkeley) 6/4/93";
X#endif /* LIBC_SCCS and not lint */
X
X#include <sys/param.h>
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X
X#include <db.h>
X#include "btree.h"
X
X/*
X * __BT_RET -- Build return key/data pair as a result of search or scan.
X *
X * Parameters:
X *	t:	tree
X *	d:	LEAF to be returned to the user.
X *	key:	user's key structure (NULL if not to be filled in)
X *	data:	user's data structure
X *
X * Returns:
X *	RET_SUCCESS, RET_ERROR.
X */
Xint
X__bt_ret(t, e, key, data)
X	BTREE *t;
X	EPG *e;
X	DBT *key, *data;
X{
X	register BLEAF *bl;
X	register void *p;
X
X	bl = GETBLEAF(e->page, e->index);
X
X	if (bl->flags & P_BIGDATA) {
X		if (__ovfl_get(t, bl->bytes + bl->ksize,
X		    &data->size, &t->bt_dbuf, &t->bt_dbufsz))
X			return (RET_ERROR);
X	} else {
X		/* Use +1 in case the first record retrieved is 0 length. */
X		if (bl->dsize + 1 > t->bt_dbufsz) {
X			if ((p = realloc(t->bt_dbuf, bl->dsize + 1)) == NULL)
X				return (RET_ERROR);
X			t->bt_dbuf = p;
X			t->bt_dbufsz = bl->dsize + 1;
X		}
X		memmove(t->bt_dbuf, bl->bytes + bl->ksize, bl->dsize);
X		data->size = bl->dsize;
X	}
X	data->data = t->bt_dbuf;
X
X	if (key == NULL)
X		return (RET_SUCCESS);
X
X	if (bl->flags & P_BIGKEY) {
X		if (__ovfl_get(t, bl->bytes,
X		    &key->size, &t->bt_kbuf, &t->bt_kbufsz))
X			return (RET_ERROR);
X	} else {
X		if (bl->ksize > t->bt_kbufsz) {
X			if ((p = realloc(t->bt_kbuf, bl->ksize)) == NULL)
X				return (RET_ERROR);
X			t->bt_kbuf = p;
X			t->bt_kbufsz = bl->ksize;
X		}
X		memmove(t->bt_kbuf, bl->bytes, bl->ksize);
X		key->size = bl->ksize;
X	}
X	key->data = t->bt_kbuf;
X	return (RET_SUCCESS);
X}
X
X/*
X * __BT_CMP -- Compare a key to a given record.
X *
X * Parameters:
X *	t:	tree
X *	k1:	DBT pointer of first arg to comparison
X *	e:	pointer to EPG for comparison
X *
X * Returns:
X *	< 0 if k1 is < record
X *	= 0 if k1 is = record
X *	> 0 if k1 is > record
X */
Xint
X__bt_cmp(t, k1, e)
X	BTREE *t;
X	const DBT *k1;
X	EPG *e;
X{
X	BINTERNAL *bi;
X	BLEAF *bl;
X	DBT k2;
X	PAGE *h;
X	void *bigkey;
X
X	/*
X	 * The left-most key on internal pages, at any level of the tree, is
X	 * guaranteed by the following code to be less than any user key.
X	 * This saves us from having to update the leftmost key on an internal
X	 * page when the user inserts a new key in the tree smaller than
X	 * anything we've yet seen.
X	 */
X	h = e->page;
X	if (e->index == 0 && h->prevpg == P_INVALID && !(h->flags & P_BLEAF))
X		return (1);
X
X	bigkey = NULL;
X	if (h->flags & P_BLEAF) {
X		bl = GETBLEAF(h, e->index);
X		if (bl->flags & P_BIGKEY)
X			bigkey = bl->bytes;
X		else {
X			k2.data = bl->bytes;
X			k2.size = bl->ksize;
X		}
X	} else {
X		bi = GETBINTERNAL(h, e->index);
X		if (bi->flags & P_BIGKEY)
X			bigkey = bi->bytes;
X		else {
X			k2.data = bi->bytes;
X			k2.size = bi->ksize;
X		}
X	}
X
X	if (bigkey) {
X		if (__ovfl_get(t, bigkey,
X		    &k2.size, &t->bt_dbuf, &t->bt_dbufsz))
X			return (RET_ERROR);
X		k2.data = t->bt_dbuf;
X	}
X	return ((*t->bt_cmp)(k1, &k2));
X}
X
X/*
X * __BT_DEFCMP -- Default comparison routine.
X *
X * Parameters:
X *	a:	DBT #1
X *	b: 	DBT #2
X *
X * Returns:
X *	< 0 if a is < b
X *	= 0 if a is = b
X *	> 0 if a is > b
X */
Xint
X__bt_defcmp(a, b)
X	const DBT *a, *b;
X{
X	register u_char *p1, *p2;
X	register int diff, len;
X
X	len = MIN(a->size, b->size);
X	for (p1 = a->data, p2 = b->data; len--; ++p1, ++p2)
X		if (diff = *p1 - *p2)
X			return (diff);
X	return (a->size - b->size);
X}
X
X/*
X * __BT_DEFPFX -- Default prefix routine.
X *
X * Parameters:
X *	a:	DBT #1
X *	b: 	DBT #2
X *
X * Returns:
X *	Number of bytes needed to distinguish b from a.
X */
Xint
X__bt_defpfx(a, b)
X	const DBT *a, *b;
X{
X	register u_char *p1, *p2;
X	register int len;
X	int cnt;
X
X	cnt = 1;
X	len = MIN(a->size, b->size);
X	for (p1 = a->data, p2 = b->data; len--; ++p1, ++p2, ++cnt)
X		if (*p1 != *p2)
X			return (cnt);
X
X	/* a->size must be <= b->size, or they wouldn't be in this order. */
X	return (a->size < b->size ? a->size + 1 : a->size);
X}
END_OF_FILE
if test 5835 -ne `wc -c <'btree/bt_utils.c'`; then
    echo shar: \"'btree/bt_utils.c'\" unpacked with wrong size!
fi
# end of 'btree/bt_utils.c'
fi
if test -f 'man/btree.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/btree.3'\"
else
echo shar: Extracting \"'man/btree.3'\" \(8129 characters\)
sed "s/^X//" >'man/btree.3' <<'END_OF_FILE'
X.\" Copyright (c) 1990, 1993
X.\"	The Regents of the University of California.  All rights reserved.
X.\"
X.\" Redistribution and use in source and binary forms, with or without
X.\" modification, are permitted provided that the following conditions
X.\" are met:
X.\" 1. Redistributions of source code must retain the above copyright
X.\"    notice, this list of conditions and the following disclaimer.
X.\" 2. Redistributions in binary form must reproduce the above copyright
X.\"    notice, this list of conditions and the following disclaimer in the
X.\"    documentation and/or other materials provided with the distribution.
X.\" 3. All advertising materials mentioning features or use of this software
X.\"    must display the following acknowledgement:
X.\"	This product includes software developed by the University of
X.\"	California, Berkeley and its contributors.
X.\" 4. Neither the name of the University nor the names of its contributors
X.\"    may be used to endorse or promote products derived from this software
X.\"    without specific prior written permission.
X.\"
X.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X.\" SUCH DAMAGE.
X.\"
X.\"	@(#)btree.3	8.1 (Berkeley) 6/4/93
X.\"
X.TH BTREE 3
X.\".UC 7
X.SH NAME
Xbtree \- btree database access method
X.SH SYNOPSIS
X.nf
X.ft B
X#include <sys/types.h>
X#include <db.h>
X.ft R
X.fi
X.SH DESCRIPTION
XThe routine
X.IR dbopen
Xis the library interface to database files.
XOne of the supported file formats is btree files.
XThe general description of the database access methods is in
X.IR dbopen (3),
Xthis manual page describes only the btree specific information.
X.PP
XThe btree data structure is a sorted, balanced tree structure storing
Xassociated key/data pairs.
X.PP
XThe btree access method specific data structure provided to
X.I dbopen
Xis defined in the <db.h> include file as follows:
X.PP
Xtypedef struct {
X.RS
Xu_long flags;
X.br
Xu_int cachesize;
X.br
Xindex_t psize;
X.br
Xint lorder;
X.\" .br
X.\" int maxkeypage;
X.br
Xint minkeypage;
X.br
Xint (*compare)(const DBT *key1, const DBT *key2);
X.br
Xint (*prefix)(const DBT *key1, const DBT *key2);
X.RE
X} BTREEINFO;
X.PP
XThe elements of this structure are as follows:
X.TP
Xflags
XThe flag value is specified by
X.IR or 'ing
Xany of the following values:
X.RS
X.TP
XR_DUP
XPermit duplicate keys in the tree, i.e. permit insertion if the key to be
Xinserted already exists in the tree.
XThe default behavior, as described in
X.IR dbopen (3),
Xis to overwrite a matching key when inserting a new key or to fail if
Xthe R_NOOVERWRITE flag is specified.
XThe R_DUP flag is overridden by the R_NOOVERWRITE flag, and if the
XR_NOOVERWRITE flag is specified, attempts to insert duplicate keys into
Xthe tree will fail.
X.IP
XIf the database contains duplicate keys, the order of retrieval of
Xkey/data pairs is undefined if the
X.I get
Xroutine is used, however,
X.I seq
Xroutine calls with the R_CURSOR flag set will always return the logical
X``first'' of any group of duplicate keys.
X.RE
X.TP
Xcachesize
XA suggested maximum size (in bytes) of the memory cache.
XThis value is
X.B only
Xadvisory, and the access method will allocate more memory rather than fail.
XSince every search examines the root page of the tree, caching the most
Xrecently used pages substantially improves access time.
XIn addition, physical writes are delayed as long as possible, so a moderate
Xcache can reduce the number of I/O operations significantly.
XObviously, using a cache increases (but only increases) the likelihood of
Xcorruption or lost data if the system crashes while a tree is being modified.
XIf
X.I cachesize
Xis 0 (no size is specified) a default cache is used.
X.TP
Xpsize
XPage size is the size (in bytes) of the pages used for nodes in the tree.
XThe minimum page size is 512 bytes and the maximum page size is 64K.
XIf
X.I psize
Xis 0 (no page size is specified) a page size is chosen based on the
Xunderlying file system I/O block size.
X.TP
Xlorder
XThe byte order for integers in the stored database metadata.
XThe number should represent the order as an integer; for example, 
Xbig endian order would be the number 4,321.
XIf
X.I lorder
Xis 0 (no order is specified) the current host order is used.
X.\" .TP
X.\" maxkeypage
X.\" The maximum number of keys which will be stored on any single page.
X.\" Because of the way the btree data structure works,
X.\" .I maxkeypage
X.\" must always be greater than or equal to 2.
X.\" If
X.\" .I maxkeypage
X.\" is 0 (no maximum number of keys is specified) the page fill factor is
X.\" made as large as possible (which is almost invariably what is wanted).
X.TP
Xminkeypage
XThe minimum number of keys which will be stored on any single page.
XThis value is used to determine which keys will be stored on overflow
Xpages, i.e. if a key or data item is longer than the pagesize divided
Xby the minkeypage value, it will be stored on overflow pages instead
Xof in the page itself.
XIf
X.I minkeypage
Xis 0 (no minimum number of keys is specified) a value of 2 is used.
X.TP
Xcompare
XCompare is the key comparison function.
XIt must return an integer less than, equal to, or greater than zero if the
Xfirst key argument is considered to be respectively less than, equal to,
Xor greater than the second key argument.
XThe same comparison function must be used on a given tree every time it
Xis opened.
XIf
X.I compare
Xis NULL (no comparison function is specified), the keys are compared
Xlexically, with shorter keys considered less than longer keys.
X.TP
Xprefix
XPrefix is the prefix comparison function.
XIf specified, this routine must return the number of bytes of the second key
Xargument which are necessary to determine that it is greater than the first
Xkey argument.
XIf the keys are equal, the key length should be returned.
XNote, the usefulness of this routine is very data dependent, but, in some
Xdata sets can produce significantly reduced tree sizes and search times.
XIf
X.I prefix
Xis NULL (no prefix function is specified),
X.B and
Xno comparison function is specified, a default lexical comparison routine
Xis used.
XIf
X.I prefix
Xis NULL and a comparison routine is specified, no prefix comparison is
Xdone.
X.PP
XIf the file already exists (and the O_TRUNC flag is not specified), the
Xvalues specified for the parameters flags, lorder and psize are ignored
Xin favor of the values used when the tree was created.
X.PP
XForward sequential scans of a tree are from the least key to the greatest.
X.PP
XSpace freed up by deleting key/data pairs from the tree is never reclaimed,
Xalthough it is normally made available for reuse.
XThis means that the btree storage structure is grow-only.
XThe only solutions are to avoid excessive deletions, or to create a fresh
Xtree periodically from a scan of an existing one.
X.PP
XSearches, insertions, and deletions in a btree will all complete in
XO lg base N where base is the average fill factor.
XOften, inserting ordered data into btrees results in a low fill factor.
XThis implementation has been modified to make ordered insertion the best
Xcase, resulting in a much better than normal page fill factor.
X.SH "SEE ALSO"
X.IR dbopen (3),
X.IR hash (3),
X.IR mpool (3),
X.IR recno (3)
X.sp
X.IR "The Ubiquitous B-tree" ,
XDouglas Comer, ACM Comput. Surv. 11, 2 (June 1979), 121-138.
X.sp
X.IR "Prefix B-trees" ,
XBayer and Unterauer, ACM Transactions on Database Systems, Vol. 2, 1
X(March 1977), 11-26.
X.sp
X.IR "The Art of Computer Programming Vol. 3: Sorting and Searching" , 
XD.E. Knuth, 1968, pp 471-480.
X.SH BUGS
XOnly big and little endian byte order is supported.
END_OF_FILE
if test 8129 -ne `wc -c <'man/btree.3'`; then
    echo shar: \"'man/btree.3'\" unpacked with wrong size!
fi
# end of 'man/btree.3'
fi
if test -f 'man/mpool.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/mpool.3'\"
else
echo shar: Extracting \"'man/mpool.3'\" \(6026 characters\)
sed "s/^X//" >'man/mpool.3' <<'END_OF_FILE'
X.\" Copyright (c) 1990, 1993
X.\"	The Regents of the University of California.  All rights reserved.
X.\"
X.\" Redistribution and use in source and binary forms, with or without
X.\" modification, are permitted provided that the following conditions
X.\" are met:
X.\" 1. Redistributions of source code must retain the above copyright
X.\"    notice, this list of conditions and the following disclaimer.
X.\" 2. Redistributions in binary form must reproduce the above copyright
X.\"    notice, this list of conditions and the following disclaimer in the
X.\"    documentation and/or other materials provided with the distribution.
X.\" 3. All advertising materials mentioning features or use of this software
X.\"    must display the following acknowledgement:
X.\"	This product includes software developed by the University of
X.\"	California, Berkeley and its contributors.
X.\" 4. Neither the name of the University nor the names of its contributors
X.\"    may be used to endorse or promote products derived from this software
X.\"    without specific prior written permission.
X.\"
X.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X.\" SUCH DAMAGE.
X.\"
X.\"	@(#)mpool.3	8.1 (Berkeley) 6/4/93
X.\"
X.TH MPOOL 3 "June 4, 1993"
X.UC 7
X.SH NAME
Xmpool \- shared memory buffer pool
X.SH SYNOPSIS
X.nf
X.ft B
X#include <db.h>
X#include <mpool.h>
X
XMPOOL *
Xmpool_open (DBT *key, int fd, pgno_t pagesize, pgno_t maxcache);
X
Xvoid
Xmpool_filter (MPOOL *mp, void (*pgin)(void *, pgno_t, void *),
X.ti +5
Xvoid (*pgout)(void *, pgno_t, void *), void *pgcookie);
X
Xvoid *
Xmpool_new (MPOOL *mp, pgno_t *pgnoaddr);
X
Xvoid *
Xmpool_get (MPOOL *mp, pgno_t pgno, u_int flags);
X
Xint
Xmpool_put (MPOOL *mp, void *pgaddr, u_int flags);
X
Xint
Xmpool_sync (MPOOL *mp);
X
Xint
Xmpool_close (MPOOL *mp);
X.ft R
X.fi
X.SH DESCRIPTION
X.IR Mpool
Xis the library interface intended to provide page oriented buffer management
Xof files.
XThe buffers may be shared between processes.
X.PP
XThe function
X.I mpool_open
Xinitializes a memory pool.
XThe
X.I key
Xargument is the byte string used to negotiate between multiple
Xprocesses wishing to share buffers.
XIf the file buffers are mapped in shared memory, all processes using
Xthe same key will share the buffers.
XIf
X.I key
Xis NULL, the buffers are mapped into private memory.
XThe
X.I fd
Xargument is a file descriptor for the underlying file, which must be seekable.
XIf
X.I key
Xis non-NULL and matches a file already being mapped, the
X.I fd
Xargument is ignored.
X.PP
XThe
X.I pagesize
Xargument is the size, in bytes, of the pages into which the file is broken up.
XThe
X.I maxcache
Xargument is the maximum number of pages from the underlying file to cache
Xat any one time.
XThis value is not relative to the number of processes which share a file's
Xbuffers, but will be the largest value specified by any of the processes
Xsharing the file.
X.PP
XThe
X.I mpool_filter
Xfunction is intended to make transparent input and output processing of the
Xpages possible.
XIf the
X.I pgin
Xfunction is specified, it is called each time a buffer is read into the memory
Xpool from the backing file.
XIf the
X.I pgout
Xfunction is specified, it is called each time a buffer is written into the
Xbacking file.
XBoth functions are are called with the
X.I pgcookie
Xpointer, the page number and a pointer to the page to being read or written.
X.PP
XThe function
X.I mpool_new
Xtakes an MPOOL pointer and an address as arguments.
XIf a new page can be allocated, a pointer to the page is returned and
Xthe page number is stored into the
X.I pgnoaddr
Xaddress.
XOtherwise, NULL is returned and errno is set.
X.PP
XThe function
X.I mpool_get
Xtakes a MPOOL pointer and a page number as arguments.
XIf the page exists, a pointer to the page is returned.
XOtherwise, NULL is returned and errno is set.
XThe flags parameter is not currently used.
X.PP
XThe function
X.I mpool_put
Xunpins the page referenced by
X.IR pgaddr .
X.I Pgaddr
Xmust be an address previously returned by
X.I mpool_get
Xor
X.IR mpool_new .
XThe flag value is specified by
X.IR or 'ing
Xany of the following values:
X.TP
XMPOOL_DIRTY
XThe page has been modified and needs to be written to the backing file.
X.PP
X.I Mpool_put
Xreturns 0 on success and -1 if an error occurs.
X.PP
XThe function
X.I mpool_sync
Xwrites all modified pages associated with the MPOOL pointer to the
Xbacking file.
X.I Mpool_sync
Xreturns 0 on success and -1 if an error occurs.
X.PP
XThe
X.I mpool_close
Xfunction free's up any allocated memory associated with the memory pool
Xcookie.
XModified pages are
X.B not
Xwritten to the backing file.
X.I Mpool_close
Xreturns 0 on success and -1 if an error occurs.
X.SH ERRORS
XThe
X.I mpool_open
Xfunction may fail and set
X.I errno
Xfor any of the errors specified for the library routine
X.IR malloc (3).
X.PP
XThe
X.I mpool_get
Xfunction may fail and set
X.I errno
Xfor the following:
X.TP 15
X[EINVAL]
XThe requested record doesn't exist.
X.PP
XThe
X.I mpool_new
Xand
X.I mpool_get
Xfunctions may fail and set
X.I errno
Xfor any of the errors specified for the library routines
X.IR read (2) ,
X.IR write (2) ,
Xand
X.IR malloc (3).
X.PP
XThe
X.I mpool_sync
Xfunction may fail and set
X.I errno
Xfor any of the errors specified for the library routine
X.IR write (2).
X.PP
XThe
X.I mpool_close
Xfunction may fail and set
X.I errno
Xfor any of the errors specified for the library routine
X.IR free (3).
X.SH "SEE ALSO"
X.IR dbopen (3),
X.IR btree (3),
X.IR hash (3),
X.IR recno (3)
END_OF_FILE
if test 6026 -ne `wc -c <'man/mpool.3'`; then
    echo shar: \"'man/mpool.3'\" unpacked with wrong size!
fi
# end of 'man/mpool.3'
fi
if test -f 'man/recno.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/recno.3'\"
else
echo shar: Extracting \"'man/recno.3'\" \(6295 characters\)
sed "s/^X//" >'man/recno.3' <<'END_OF_FILE'
X.\" Copyright (c) 1990, 1993
X.\"	The Regents of the University of California.  All rights reserved.
X.\"
X.\" Redistribution and use in source and binary forms, with or without
X.\" modification, are permitted provided that the following conditions
X.\" are met:
X.\" 1. Redistributions of source code must retain the above copyright
X.\"    notice, this list of conditions and the following disclaimer.
X.\" 2. Redistributions in binary form must reproduce the above copyright
X.\"    notice, this list of conditions and the following disclaimer in the
X.\"    documentation and/or other materials provided with the distribution.
X.\" 3. All advertising materials mentioning features or use of this software
X.\"    must display the following acknowledgement:
X.\"	This product includes software developed by the University of
X.\"	California, Berkeley and its contributors.
X.\" 4. Neither the name of the University nor the names of its contributors
X.\"    may be used to endorse or promote products derived from this software
X.\"    without specific prior written permission.
X.\"
X.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X.\" SUCH DAMAGE.
X.\"
X.\"	@(#)recno.3	8.1 (Berkeley) 6/4/93
X.\"
X.TH RECNO 3 "June 4, 1993"
X.UC 7
X.SH NAME
Xrecno \- record number database access method
X.SH SYNOPSIS
X.nf
X.ft B
X#include <sys/types.h>
X#include <db.h>
X.ft R
X.fi
X.SH DESCRIPTION
XThe routine
X.IR dbopen
Xis the library interface to database files.
XOne of the supported file formats is record number files.
XThe general description of the database access methods is in
X.IR dbopen (3),
Xthis manual page describes only the recno specific information.
X.PP
XThe record number data structure is either variable or fixed-length
Xrecords stored in a flat-file format, accessed by the logical record
Xnumber.
XThe existence of record number five implies the existence of records
Xone through four, and the deletion of record number one causes
Xrecord number five to be renumbered to record number four, as well
Xas the cursor, if positioned after record number one, to shift down
Xone record.
X.PP
XThe recno access method specific data structure provided to
X.I dbopen
Xis defined in the <db.h> include file as follows:
X.PP
Xtypedef struct {
X.RS
Xu_char bval;
X.br
Xu_int cachesize;
X.br
Xindex_t psize;
X.br
Xu_long flags;
X.br
Xint lorder;
X.br
Xsize_t reclen;
X.br
Xchar *bfname;
X.RE
X} RECNOINFO;
X.PP
XThe elements of this structure are defined as follows:
X.TP
Xbval
XThe delimiting byte to be used to mark the end of a record for
Xvariable-length records, and the pad character for fixed-length
Xrecords.
XIf no value is specified, newlines (``\en'') are used to mark the end
Xof variable-length records and fixed-length records are padded with
Xspaces.
X.TP
Xcachesize
XA suggested maximum size, in bytes, of the memory cache.
XThis value is
X.B only
Xadvisory, and the access method will allocate more memory rather than fail.
XIf
X.I cachesize
Xis  0 (no size is specified) a default cache is used.
X.TP
Xpsize
XThe recno access method stores the in-memory copies of its records
Xin a btree.
XThis value is the size (in bytes) of the pages used for nodes in that tree.
XIf
X.I psize
Xis 0 (no page size is specified) a page size is chosen based on the
Xunderlying file system I/O block size.
XSee
X.IR btree (3)
Xfor more information.
X.TP
Xbfname
XThe recno access method stores the in-memory copies of its records
Xin a btree.
XIf bfname is non-NULL, it specifies the name of the btree file,
Xas if specified as the file name for a dbopen of a btree file.
X.TP
Xflags
XThe flag value is specified by
X.IR or 'ing
Xany of the following values:
X.RS
X.TP
XR_FIXEDLEN
XThe records are fixed-length, not byte delimited.
XThe structure element
X.I reclen
Xspecifies the length of the record, and the structure element
X.I bval
Xis used as the pad character.
X.TP
XR_NOKEY
XIn the interface specified by
X.IR dbopen ,
Xthe sequential record retrieval fills in both the caller's key and
Xdata structures.
XIf the R_NOKEY flag is specified, the
X.I cursor
Xroutines are not required to fill in the key structure.
XThis permits applications to retrieve records at the end of files without
Xreading all of the intervening records.
X.TP
XR_SNAPSHOT
XThis flag requires that a snapshot of the file be taken when
X.I dbopen
Xis called, instead of permitting any unmodified records to be read from
Xthe original file.
X.RE
X.TP
Xlorder
XThe byte order for integers in the stored database metadata.
XThe number should represent the order as an integer; for example,
Xbig endian order would be the number 4,321.
XIf
X.I lorder
Xis 0 (no order is specified) the current host order is used.
X.TP
Xreclen
XThe length of a fixed-length record.
X.PP
XThe data part of the key/data pair used by the recno access method
Xis the same as other access methods.
XThe key is different.
XThe
X.I data
Xfield of the key should be a pointer to a memory location of type
X.IR recno_t ,
Xas defined in the <db.h> include file.
XThis type is normally the largest unsigned integral type available to
Xthe implementation.
XThe
X.I size
Xfield of the key should be the size of that type.
X.PP
XIn the interface specified by
X.IR dbopen ,
Xusing the
X.I put
Xinterface to create a new record will cause the creation of multiple,
Xempty records if the record number is more than one greater than the
Xlargest record currently in the database.
X.SH "SEE ALSO"
X.IR dbopen (3),
X.IR hash (3),
X.IR mpool (3),
X.IR recno (3)
X.sp
X.IR "Document Processing in a Relational Database System" ,
XMichael Stonebraker, Heidi Stettner, Joseph Kalash, Antonin Guttman,
XNadene Lynn, Memorandum No. UCB/ERL M82/32, May 1982.
X.SH BUGS
XOnly big and little endian byte order is supported.
END_OF_FILE
if test 6295 -ne `wc -c <'man/recno.3'`; then
    echo shar: \"'man/recno.3'\" unpacked with wrong size!
fi
# end of 'man/recno.3'
fi
if test -f 'recno/rec_get.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'recno/rec_get.c'\"
else
echo shar: Extracting \"'recno/rec_get.c'\" \(6484 characters\)
sed "s/^X//" >'recno/rec_get.c' <<'END_OF_FILE'
X/*-
X * Copyright (c) 1990, 1993
X *	The Regents of the University of California.  All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#if defined(LIBC_SCCS) && !defined(lint)
Xstatic char sccsid[] = "@(#)rec_get.c	8.1 (Berkeley) 6/4/93";
X#endif /* LIBC_SCCS and not lint */
X
X#include <sys/types.h>
X
X#include <errno.h>
X#include <stddef.h>
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X#include <unistd.h>
X
X#include <db.h>
X#include "recno.h"
X
X/*
X * __REC_GET -- Get a record from the btree.
X *
X * Parameters:
X *	dbp:	pointer to access method
X *	key:	key to find
X *	data:	data to return
X *	flag:	currently unused
X *
X * Returns:
X *	RET_ERROR, RET_SUCCESS and RET_SPECIAL if the key not found.
X */
Xint
X__rec_get(dbp, key, data, flags)
X	const DB *dbp;
X	const DBT *key;
X	DBT *data;
X	u_int flags;
X{
X	BTREE *t;
X	EPG *e;
X	recno_t nrec;
X	int status;
X
X	if (flags || (nrec = *(recno_t *)key->data) == 0) {
X		errno = EINVAL;
X		return (RET_ERROR);
X	}
X
X	/*
X	 * If we haven't seen this record yet, try to find it in the
X	 * original file.
X	 */
X	t = dbp->internal;
X	if (nrec > t->bt_nrecs) {
X		if (ISSET(t, R_EOF | R_INMEM))
X			return (RET_SPECIAL);
X		if ((status = t->bt_irec(t, nrec)) != RET_SUCCESS)
X			return (status);
X	}
X
X	--nrec;
X	if ((e = __rec_search(t, nrec, SEARCH)) == NULL)
X		return (RET_ERROR);
X
X	status = __rec_ret(t, e, 0, NULL, data);
X	mpool_put(t->bt_mp, e->page, 0);
X	return (status);
X}
X
X/*
X * __REC_FPIPE -- Get fixed length records from a pipe.
X *
X * Parameters:
X *	t:	tree
X *	cnt:	records to read
X *
X * Returns:
X *	RET_ERROR, RET_SUCCESS
X */
Xint
X__rec_fpipe(t, top)
X	BTREE *t;
X	recno_t top;
X{
X	DBT data;
X	recno_t nrec;
X	size_t len;
X	int ch;
X	char *p;
X
X	data.data = t->bt_dbuf;
X	data.size = t->bt_reclen;
X
X	if (t->bt_dbufsz < t->bt_reclen) {
X		if ((t->bt_dbuf = realloc(t->bt_dbuf, t->bt_reclen)) == NULL)
X			return (RET_ERROR);
X		t->bt_dbufsz = t->bt_reclen;
X	}
X	for (nrec = t->bt_nrecs; nrec < top; ++nrec) {
X		len = t->bt_reclen;
X		for (p = t->bt_dbuf;; *p++ = ch)
X			if ((ch = getc(t->bt_rfp)) == EOF || !len--) {
X				if (__rec_iput(t, nrec, &data, 0)
X				    != RET_SUCCESS)
X					return (RET_ERROR);
X				break;
X			}
X		if (ch == EOF)
X			break;
X	}
X	if (nrec < top) {
X		SET(t, R_EOF);
X		return (RET_SPECIAL);
X	}
X	return (RET_SUCCESS);
X}
X
X/*
X * __REC_VPIPE -- Get variable length records from a pipe.
X *
X * Parameters:
X *	t:	tree
X *	cnt:	records to read
X *
X * Returns:
X *	RET_ERROR, RET_SUCCESS
X */
Xint
X__rec_vpipe(t, top)
X	BTREE *t;
X	recno_t top;
X{
X	DBT data;
X	recno_t nrec;
X	indx_t len;
X	size_t sz;
X	int bval, ch;
X	char *p;
X
X	bval = t->bt_bval;
X	for (nrec = t->bt_nrecs; nrec < top; ++nrec) {
X		for (p = t->bt_dbuf, sz = t->bt_dbufsz;; *p++ = ch, --sz) {
X			if ((ch = getc(t->bt_rfp)) == EOF || ch == bval) {
X				data.data = t->bt_dbuf;
X				data.size = p - t->bt_dbuf;
X				if (ch == EOF && data.size == 0)
X					break;
X				if (__rec_iput(t, nrec, &data, 0)
X				    != RET_SUCCESS)
X					return (RET_ERROR);
X				break;
X			}
X			if (sz == 0) {
X				len = p - t->bt_dbuf;
X				t->bt_dbufsz += (sz = 256);
X				if ((t->bt_dbuf =
X				    realloc(t->bt_dbuf, t->bt_dbufsz)) == NULL)
X					return (RET_ERROR);
X				p = t->bt_dbuf + len;
X			}
X		}
X		if (ch == EOF)
X			break;
X	}
X	if (nrec < top) {
X		SET(t, R_EOF);
X		return (RET_SPECIAL);
X	}
X	return (RET_SUCCESS);
X}
X
X/*
X * __REC_FMAP -- Get fixed length records from a file.
X *
X * Parameters:
X *	t:	tree
X *	cnt:	records to read
X *
X * Returns:
X *	RET_ERROR, RET_SUCCESS
X */
Xint
X__rec_fmap(t, top)
X	BTREE *t;
X	recno_t top;
X{
X	DBT data;
X	recno_t nrec;
X	caddr_t sp, ep;
X	size_t len;
X	char *p;
X
X	sp = t->bt_cmap;
X	ep = t->bt_emap;
X	data.data = t->bt_dbuf;
X	data.size = t->bt_reclen;
X
X	if (t->bt_dbufsz < t->bt_reclen) {
X		if ((t->bt_dbuf = realloc(t->bt_dbuf, t->bt_reclen)) == NULL)
X			return (RET_ERROR);
X		t->bt_dbufsz = t->bt_reclen;
X	}
X	for (nrec = t->bt_nrecs; nrec < top; ++nrec) {
X		if (sp >= ep) {
X			SET(t, R_EOF);
X			return (RET_SPECIAL);
X		}
X		len = t->bt_reclen;
X		for (p = t->bt_dbuf; sp < ep && len--; *p++ = *sp++);
X		memset(p, t->bt_bval, len);
X		if (__rec_iput(t, nrec, &data, 0) != RET_SUCCESS)
X			return (RET_ERROR);
X	}
X	t->bt_cmap = sp;
X	return (RET_SUCCESS);
X}
X
X/*
X * __REC_VMAP -- Get variable length records from a file.
X *
X * Parameters:
X *	t:	tree
X *	cnt:	records to read
X *
X * Returns:
X *	RET_ERROR, RET_SUCCESS
X */
Xint
X__rec_vmap(t, top)
X	BTREE *t;
X	recno_t top;
X{
X	DBT data;
X	caddr_t sp, ep;
X	recno_t nrec;
X	int bval;
X
X	sp = t->bt_cmap;
X	ep = t->bt_emap;
X	bval = t->bt_bval;
X
X	for (nrec = t->bt_nrecs; nrec < top; ++nrec) {
X		if (sp >= ep) {
X			SET(t, R_EOF);
X			return (RET_SPECIAL);
X		}
X		for (data.data = sp; sp < ep && *sp != bval; ++sp);
X		data.size = sp - (caddr_t)data.data;
X		if (__rec_iput(t, nrec, &data, 0) != RET_SUCCESS)
X			return (RET_ERROR);
X		++sp;
X	}
X	t->bt_cmap = sp;
X	return (RET_SUCCESS);
X}
END_OF_FILE
if test 6484 -ne `wc -c <'recno/rec_get.c'`; then
    echo shar: \"'recno/rec_get.c'\" unpacked with wrong size!
fi
# end of 'recno/rec_get.c'
fi
if test -f 'recno/rec_open.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'recno/rec_open.c'\"
else
echo shar: Extracting \"'recno/rec_open.c'\" \(6244 characters\)
sed "s/^X//" >'recno/rec_open.c' <<'END_OF_FILE'
X/*-
X * Copyright (c) 1990, 1993
X *	The Regents of the University of California.  All rights reserved.
X *
X * This code is derived from software contributed to Berkeley by
X * Mike Olson.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#if defined(LIBC_SCCS) && !defined(lint)
Xstatic char sccsid[] = "@(#)rec_open.c	8.1 (Berkeley) 6/4/93";
X#endif /* LIBC_SCCS and not lint */
X
X#include <sys/types.h>
X#include <sys/mman.h>
X#include <sys/stat.h>
X
X#include <errno.h>
X#include <fcntl.h>
X#include <limits.h>
X#include <stddef.h>
X#include <stdio.h>
X#include <unistd.h>
X
X#include <db.h>
X#include "recno.h"
X
XDB *
X__rec_open(fname, flags, mode, openinfo)
X	const char *fname;
X	int flags, mode;
X	const RECNOINFO *openinfo;
X{
X	BTREE *t;
X	BTREEINFO btopeninfo;
X	DB *dbp;
X	PAGE *h;
X	struct stat sb;
X	int rfd, sverrno;
X
X	/* Open the user's file -- if this fails, we're done. */
X	if (fname != NULL && (rfd = open(fname, flags, mode)) < 0)
X		return (NULL);
X
X	/* Create a btree in memory (backed by disk). */
X	dbp = NULL;
X	if (openinfo) {
X		if (openinfo->flags & ~(R_FIXEDLEN | R_NOKEY | R_SNAPSHOT))
X			goto einval;
X		btopeninfo.flags = 0;
X		btopeninfo.cachesize = openinfo->cachesize;
X		btopeninfo.maxkeypage = 0;
X		btopeninfo.minkeypage = 0;
X		btopeninfo.psize = openinfo->psize;
X		btopeninfo.compare = NULL;
X		btopeninfo.prefix = NULL;
X		btopeninfo.lorder = openinfo->lorder;
X		dbp = __bt_open(openinfo->bfname,
X		    O_RDWR, S_IRUSR | S_IWUSR, &btopeninfo);
X	} else
X		dbp = __bt_open(NULL, O_RDWR, S_IRUSR | S_IWUSR, NULL);
X	if (dbp == NULL)
X		goto err;
X
X	/*
X	 * Some fields in the tree structure are recno specific.  Fill them
X	 * in and make the btree structure look like a recno structure.  We
X	 * don't change the bt_ovflsize value, it's close enough and slightly
X	 * bigger.
X	 */
X	t = dbp->internal;
X	if (openinfo) {
X		if (openinfo->flags & R_FIXEDLEN) {
X			SET(t, R_FIXLEN);
X			t->bt_reclen = openinfo->reclen;
X			if (t->bt_reclen == 0)
X				goto einval;
X		}
X		t->bt_bval = openinfo->bval;
X	} else
X		t->bt_bval = '\n';
X
X	SET(t, R_RECNO);
X	if (fname == NULL)
X		SET(t, R_EOF | R_INMEM);
X	else
X		t->bt_rfd = rfd;
X	t->bt_rcursor = 0;
X
X	/*
X	 * In 4.4BSD stat(2) returns true for ISSOCK on pipes.  Until
X	 * then, this is fairly close.  Pipes are read-only.
X	 */
X	if (fname != NULL) {
X		if (lseek(rfd, (off_t)0, SEEK_CUR) == -1 && errno == ESPIPE) {
X			switch (flags & O_ACCMODE) {
X			case O_RDONLY:
X				SET(t, R_RDONLY);
X				break;
X			default:
X				goto einval;
X			}
Xslow:			if ((t->bt_rfp = fdopen(rfd, "r")) == NULL)
X				goto err;
X			SET(t, R_CLOSEFP);
X			t->bt_irec =
X			    ISSET(t, R_FIXLEN) ? __rec_fpipe : __rec_vpipe;
X		} else {
X			switch (flags & O_ACCMODE) {
X			case O_RDONLY:
X				SET(t, R_RDONLY);
X				break;
X			case O_RDWR:
X				break;
X			default:
X				goto einval;
X			}
X
X			if (fstat(rfd, &sb))
X				goto err;
X			/*
X			 * Kluge -- we'd like to test to see if the file is too
X			 * big to mmap.  Since, we don't know what size or type
X			 * off_t's or size_t's are, what the largest unsigned
X			 * integral type is, or what random insanity the local
X			 * C compiler will perpetrate, doing the comparison in
X			 * a portable way is flatly impossible.  Hope that mmap
X			 * fails if the file is too large.
X			 */
X			if (sb.st_size == 0)
X				SET(t, R_EOF);
X			else {
X				t->bt_msize = sb.st_size;
X				if ((t->bt_smap =
X				    mmap(NULL, t->bt_msize, PROT_READ, 0, rfd,
X				    (off_t)0)) == (caddr_t)-1)
X					goto slow;
X				t->bt_cmap = t->bt_smap;
X				t->bt_emap = t->bt_smap + sb.st_size;
X				t->bt_irec = ISSET(t, R_FIXLEN) ?
X				    __rec_fmap : __rec_vmap;
X				SET(t, R_MEMMAPPED);
X			}
X		}
X	}
X
X	/* Use the recno routines. */
X	dbp->close = __rec_close;
X	dbp->del = __rec_delete;
X	dbp->fd = __rec_fd;
X	dbp->get = __rec_get;
X	dbp->put = __rec_put;
X	dbp->seq = __rec_seq;
X	dbp->sync = __rec_sync;
X
X	/* If the root page was created, reset the flags. */
X	if ((h = mpool_get(t->bt_mp, P_ROOT, 0)) == NULL)
X		goto err;
X	if ((h->flags & P_TYPE) == P_BLEAF) {
X		h->flags = h->flags & ~P_TYPE | P_RLEAF;
X		mpool_put(t->bt_mp, h, MPOOL_DIRTY);
X	} else
X		mpool_put(t->bt_mp, h, 0);
X
X	if (openinfo && openinfo->flags & R_SNAPSHOT &&
X	    !ISSET(t, R_EOF | R_INMEM) &&
X	    t->bt_irec(t, MAX_REC_NUMBER) == RET_ERROR)
X                goto err;
X	return (dbp);
X
Xeinval:	errno = EINVAL;
Xerr:	sverrno = errno;
X	if (dbp != NULL)
X		(void)__bt_close(dbp);
X	if (fname != NULL)
X		(void)close(rfd);
X	errno = sverrno;
X	return (NULL);
X}
X
Xint
X__rec_fd(dbp)
X	const DB *dbp;
X{
X	BTREE *t;
X
X	t = dbp->internal;
X
X	if (ISSET(t, R_INMEM)) {
X		errno = ENOENT;
X		return (-1);
X	}
X	return (t->bt_rfd);
X}
END_OF_FILE
if test 6244 -ne `wc -c <'recno/rec_open.c'`; then
    echo shar: \"'recno/rec_open.c'\" unpacked with wrong size!
fi
# end of 'recno/rec_open.c'
fi
if test -f 'recno/rec_put.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'recno/rec_put.c'\"
else
echo shar: Extracting \"'recno/rec_put.c'\" \(6135 characters\)
sed "s/^X//" >'recno/rec_put.c' <<'END_OF_FILE'
X/*-
X * Copyright (c) 1990, 1993
X *	The Regents of the University of California.  All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#if defined(LIBC_SCCS) && !defined(lint)
Xstatic char sccsid[] = "@(#)rec_put.c	8.1 (Berkeley) 6/4/93";
X#endif /* LIBC_SCCS and not lint */
X
X#include <sys/types.h>
X
X#include <errno.h>
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X
X#include <db.h>
X#include "recno.h"
X
X/*
X * __REC_PUT -- Add a recno item to the tree.
X *
X * Parameters:
X *	dbp:	pointer to access method
X *	key:	key
X *	data:	data
X *	flag:	R_CURSOR, R_IAFTER, R_IBEFORE, R_NOOVERWRITE
X *
X * Returns:
X *	RET_ERROR, RET_SUCCESS and RET_SPECIAL if the key is
X *	already in the tree and R_NOOVERWRITE specified.
X */
Xint
X__rec_put(dbp, key, data, flags)
X	const DB *dbp;
X	DBT *key;
X	const DBT *data;
X	u_int flags;
X{
X	BTREE *t;
X	DBT tdata;
X	recno_t nrec;
X	int status;
X
X	t = dbp->internal;
X
X	switch (flags) {
X	case R_CURSOR:
X		if (!ISSET(t, B_SEQINIT))
X			goto einval;
X		nrec = t->bt_rcursor;
X		break;
X	case R_SETCURSOR:
X		if ((nrec = *(recno_t *)key->data) == 0)
X			goto einval;
X		break;
X	case R_IAFTER:
X		if ((nrec = *(recno_t *)key->data) == 0) {
X			nrec = 1;
X			flags = R_IBEFORE;
X		}
X		break;
X	case 0:
X	case R_IBEFORE:
X		if ((nrec = *(recno_t *)key->data) == 0)
X			goto einval;
X		break;
X	case R_NOOVERWRITE:
X		if ((nrec = *(recno_t *)key->data) == 0)
X			goto einval;
X		if (nrec <= t->bt_nrecs)
X			return (RET_SPECIAL);
X		break;
X	default:
Xeinval:		errno = EINVAL;
X		return (RET_ERROR);
X	}
X
X	/*
X	 * Make sure that records up to and including the put record are
X	 * already in the database.  If skipping records, create empty ones.
X	 */
X	if (nrec > t->bt_nrecs) {
X		if (!ISSET(t, R_EOF | R_INMEM) &&
X		    t->bt_irec(t, nrec) == RET_ERROR)
X			return (RET_ERROR);
X		if (nrec > t->bt_nrecs + 1) {
X			tdata.data = NULL;
X			tdata.size = 0;
X			while (nrec > t->bt_nrecs + 1)
X				if (__rec_iput(t,
X				    t->bt_nrecs, &tdata, 0) != RET_SUCCESS)
X					return (RET_ERROR);
X		}
X	}
X
X	if ((status = __rec_iput(t, nrec - 1, data, flags)) != RET_SUCCESS)
X		return (status);
X
X	if (flags == R_SETCURSOR)
X		t->bt_rcursor = nrec;
X	
X	SET(t, R_MODIFIED);
X	return (__rec_ret(t, NULL, nrec, key, NULL));
X}
X
X/*
X * __REC_IPUT -- Add a recno item to the tree.
X *
X * Parameters:
X *	t:	tree
X *	nrec:	record number
X *	data:	data
X *
X * Returns:
X *	RET_ERROR, RET_SUCCESS
X */
Xint
X__rec_iput(t, nrec, data, flags)
X	BTREE *t;
X	recno_t nrec;
X	const DBT *data;
X	u_int flags;
X{
X	DBT tdata;
X	EPG *e;
X	PAGE *h;
X	indx_t index, nxtindex;
X	pgno_t pg;
X	size_t nbytes;
X	int dflags, status;
X	char *dest, db[NOVFLSIZE];
X
X	/*
X	 * If the data won't fit on a page, store it on indirect pages.
X	 *
X	 * XXX
X	 * If the insert fails later on, these pages aren't recovered.
X	 */
X	if (data->size > t->bt_ovflsize) {
X		if (__ovfl_put(t, data, &pg) == RET_ERROR)
X			return (RET_ERROR);
X		tdata.data = db;
X		tdata.size = NOVFLSIZE;
X		*(pgno_t *)db = pg;
X		*(size_t *)(db + sizeof(pgno_t)) = data->size;
X		dflags = P_BIGDATA;
X		data = &tdata;
X	} else
X		dflags = 0;
X
X	/* __rec_search pins the returned page. */
X	if ((e = __rec_search(t, nrec,
X	    nrec > t->bt_nrecs || flags == R_IAFTER || flags == R_IBEFORE ?
X	    SINSERT : SEARCH)) == NULL)
X		return (RET_ERROR);
X
X	h = e->page;
X	index = e->index;
X
X	/*
X	 * Add the specified key/data pair to the tree.  The R_IAFTER and
X	 * R_IBEFORE flags insert the key after/before the specified key.
X	 *
X	 * Pages are split as required.
X	 */
X	switch (flags) {
X	case R_IAFTER:
X		++index;
X		break;
X	case R_IBEFORE:
X		break;
X	default:
X		if (nrec < t->bt_nrecs &&
X		    __rec_dleaf(t, h, index) == RET_ERROR) {
X			mpool_put(t->bt_mp, h, 0);
X			return (RET_ERROR);
X		}
X		break;
X	}
X
X	/*
X	 * If not enough room, split the page.  The split code will insert
X	 * the key and data and unpin the current page.  If inserting into
X	 * the offset array, shift the pointers up.
X	 */
X	nbytes = NRLEAFDBT(data->size);
X	if (h->upper - h->lower < nbytes + sizeof(indx_t)) {
X		status = __bt_split(t, h, NULL, data, dflags, nbytes, index);
X		if (status == RET_SUCCESS)
X			++t->bt_nrecs;
X		return (status);
X	}
X
X	if (index < (nxtindex = NEXTINDEX(h)))
X		memmove(h->linp + index + 1, h->linp + index,
X		    (nxtindex - index) * sizeof(indx_t));
X	h->lower += sizeof(indx_t);
X
X	h->linp[index] = h->upper -= nbytes;
X	dest = (char *)h + h->upper;
X	WR_RLEAF(dest, data, dflags);
X
X	++t->bt_nrecs;
X	SET(t, B_MODIFIED);
X	mpool_put(t->bt_mp, h, MPOOL_DIRTY);
X
X	return (RET_SUCCESS);
X}
END_OF_FILE
if test 6135 -ne `wc -c <'recno/rec_put.c'`; then
    echo shar: \"'recno/rec_put.c'\" unpacked with wrong size!
fi
# end of 'recno/rec_put.c'
fi
echo shar: End of archive 3 \(of 9\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 9 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
