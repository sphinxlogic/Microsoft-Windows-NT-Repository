Newsgroups: comp.sources.unix
From: bostic@cs.berkeley.edu (Keith Bostic)
Subject: v26i284: db-1.6 - A New Hashing Package for UNIX(tm) (updates dbm/ndbm), Part05/09
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: bostic@cs.berkeley.edu (Keith Bostic)
Posting-Number: Volume 26, Issue 284
Archive-Name: db-1.6/part05

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 9)."
# Contents:  btree/btree.h doc/mpool.3.ps doc/recno.3.ps man/dbopen.3
#   test/dbtest.c test/run.test
# Wrapped by vixie@gw.home.vix.com on Mon Jul  5 15:27:26 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'btree/btree.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'btree/btree.h'\"
else
echo shar: Extracting \"'btree/btree.h'\" \(12888 characters\)
sed "s/^X//" >'btree/btree.h' <<'END_OF_FILE'
X/*-
X * Copyright (c) 1991, 1993
X *	The Regents of the University of California.  All rights reserved.
X *
X * This code is derived from software contributed to Berkeley by
X * Mike Olson.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X *
X *	@(#)btree.h	8.1 (Berkeley) 6/4/93
X */
X
X#include <mpool.h>
X
X#define	DEFMINKEYPAGE	(2)		/* Minimum keys per page */
X#define	MINCACHE	(5)		/* Minimum cached pages */
X#define	MINPSIZE	(512)		/* Minimum page size */
X
X/*
X * Page 0 of a btree file contains a copy of the meta-data.  This page is also
X * used as an out-of-band page, i.e. page pointers that point to nowhere point
X * to page 0.  Page 1 is the root of the btree.
X */
X#define	P_INVALID	 0		/* Invalid tree page number. */
X#define	P_META		 0		/* Tree metadata page number. */
X#define	P_ROOT		 1		/* Tree root page number. */
X
X/*
X * There are five page layouts in the btree: btree internal pages (BINTERNAL),
X * btree leaf pages (BLEAF), recno internal pages (RINTERNAL), recno leaf pages
X * (RLEAF) and overflow pages.  All five page types have a page header (PAGE).
X * This implementation requires that longs within structures are NOT padded.
X * (ANSI C permits random padding.)  If your compiler pads randomly you'll have
X * to do some work to get this package to run.
X */
Xtypedef struct PAGE {
X	pgno_t	pgno;			/* this page's page number */
X	pgno_t	prevpg;			/* left sibling */
X	pgno_t	nextpg;			/* right sibling */
X
X#define	P_BINTERNAL	0x01		/* btree internal page */
X#define	P_BLEAF		0x02		/* leaf page */
X#define	P_OVERFLOW	0x04		/* overflow page */
X#define	P_RINTERNAL	0x08		/* recno internal page */
X#define	P_RLEAF		0x10		/* leaf page */
X#define P_TYPE		0x1f		/* type mask */
X
X#define	P_PRESERVE	0x20		/* never delete this chain of pages */
X	u_long	flags;
X
X	indx_t	lower;			/* lower bound of free space on page */
X	indx_t	upper;			/* upper bound of free space on page */
X	indx_t	linp[1];		/* long-aligned VARIABLE LENGTH DATA */
X} PAGE;
X
X/* First and next index. */
X#define	BTDATAOFF	(sizeof(pgno_t) + sizeof(pgno_t) + sizeof(pgno_t) + \
X			    sizeof(u_long) + sizeof(indx_t) + sizeof(indx_t))
X#define	NEXTINDEX(p)	(((p)->lower - BTDATAOFF) / sizeof(indx_t))
X
X/*
X * For pages other than overflow pages, there is an array of offsets into the
X * rest of the page immediately following the page header.  Each offset is to
X * an item which is unique to the type of page.  The h_lower offset is just
X * past the last filled-in index.  The h_upper offset is the first item on the
X * page.  Offsets are from the beginning of the page.
X *
X * If an item is too big to store on a single page, a flag is set and the item
X * is a { page, size } pair such that the page is the first page of an overflow
X * chain with size bytes of item.  Overflow pages are simply bytes without any
X * external structure.
X *
X * The size and page number fields in the items are long aligned so they can be
X * manipulated without copying.
X */
X#define	LALIGN(n)	(((n) + sizeof(u_long) - 1) & ~(sizeof(u_long) - 1))
X#define	NOVFLSIZE	(sizeof(pgno_t) + sizeof(size_t))
X
X/*
X * For the btree internal pages, the item is a key.  BINTERNALs are {key, pgno}
X * pairs, such that the key compares less than or equal to all of the records
X * on that page.  For a tree without duplicate keys, an internal page with two
X * consecutive keys, a and b, will have all records greater than or equal to a
X * and less than b stored on the page associated with a.  Duplicate keys are
X * somewhat special and can cause duplicate internal and leaf page records and
X * some minor modifications of the above rule.
X */
Xtypedef struct BINTERNAL {
X	size_t	ksize;			/* key size */
X	pgno_t	pgno;			/* page number stored on */
X#define	P_BIGDATA	0x01		/* overflow data */
X#define	P_BIGKEY	0x02		/* overflow key */
X	u_char	flags;
X	char	bytes[1];		/* data */
X} BINTERNAL;
X
X/* Get the page's BINTERNAL structure at index indx. */
X#define	GETBINTERNAL(pg, indx) \
X	((BINTERNAL *)((char *)(pg) + (pg)->linp[indx]))
X
X/* Get the number of bytes in the entry. */
X#define NBINTERNAL(len) \
X	LALIGN(sizeof(size_t) + sizeof(pgno_t) + sizeof(u_char) + (len))
X
X/* Copy a BINTERNAL entry to the page. */
X#define	WR_BINTERNAL(p, size, pgno, flags) { \
X	*(size_t *)p = size; \
X	p += sizeof(size_t); \
X	*(pgno_t *)p = pgno; \
X	p += sizeof(pgno_t); \
X	*(u_char *)p = flags; \
X	p += sizeof(u_char); \
X}
X
X/*
X * For the recno internal pages, the item is a page number with the number of
X * keys found on that page and below.
X */
Xtypedef struct RINTERNAL {
X	recno_t	nrecs;			/* number of records */
X	pgno_t	pgno;			/* page number stored below */
X} RINTERNAL;
X
X/* Get the page's RINTERNAL structure at index indx. */
X#define	GETRINTERNAL(pg, indx) \
X	((RINTERNAL *)((char *)(pg) + (pg)->linp[indx]))
X
X/* Get the number of bytes in the entry. */
X#define NRINTERNAL \
X	LALIGN(sizeof(recno_t) + sizeof(pgno_t))
X
X/* Copy a RINTERAL entry to the page. */
X#define	WR_RINTERNAL(p, nrecs, pgno) { \
X	*(recno_t *)p = nrecs; \
X	p += sizeof(recno_t); \
X	*(pgno_t *)p = pgno; \
X}
X
X/* For the btree leaf pages, the item is a key and data pair. */
Xtypedef struct BLEAF {
X	size_t	ksize;			/* size of key */
X	size_t	dsize;			/* size of data */
X	u_char	flags;			/* P_BIGDATA, P_BIGKEY */
X	char	bytes[1];		/* data */
X} BLEAF;
X
X/* Get the page's BLEAF structure at index indx. */
X#define	GETBLEAF(pg, indx) \
X	((BLEAF *)((char *)(pg) + (pg)->linp[indx]))
X
X/* Get the number of bytes in the entry. */
X#define NBLEAF(p)	NBLEAFDBT((p)->ksize, (p)->dsize)
X
X/* Get the number of bytes in the user's key/data pair. */
X#define NBLEAFDBT(ksize, dsize) \
X	LALIGN(sizeof(size_t) + sizeof(size_t) + sizeof(u_char) + \
X	    (ksize) + (dsize))
X
X/* Copy a BLEAF entry to the page. */
X#define	WR_BLEAF(p, key, data, flags) { \
X	*(size_t *)p = key->size; \
X	p += sizeof(size_t); \
X	*(size_t *)p = data->size; \
X	p += sizeof(size_t); \
X	*(u_char *)p = flags; \
X	p += sizeof(u_char); \
X	memmove(p, key->data, key->size); \
X	p += key->size; \
X	memmove(p, data->data, data->size); \
X}
X
X/* For the recno leaf pages, the item is a data entry. */
Xtypedef struct RLEAF {
X	size_t	dsize;			/* size of data */
X	u_char	flags;			/* P_BIGDATA */
X	char	bytes[1];
X} RLEAF;
X
X/* Get the page's RLEAF structure at index indx. */
X#define	GETRLEAF(pg, indx) \
X	((RLEAF *)((char *)(pg) + (pg)->linp[indx]))
X
X/* Get the number of bytes in the entry. */
X#define NRLEAF(p)	NRLEAFDBT((p)->dsize)
X
X/* Get the number of bytes from the user's data. */
X#define	NRLEAFDBT(dsize) \
X	LALIGN(sizeof(size_t) + sizeof(u_char) + (dsize))
X
X/* Copy a RLEAF entry to the page. */
X#define	WR_RLEAF(p, data, flags) { \
X	*(size_t *)p = data->size; \
X	p += sizeof(size_t); \
X	*(u_char *)p = flags; \
X	p += sizeof(u_char); \
X	memmove(p, data->data, data->size); \
X}
X
X/*
X * A record in the tree is either a pointer to a page and an index in the page
X * or a page number and an index.  These structures are used as a cursor, stack
X * entry and search returns as well as to pass records to other routines.
X *
X * One comment about searches.  Internal page searches must find the largest
X * record less than key in the tree so that descents work.  Leaf page searches
X * must find the smallest record greater than key so that the returned index
X * is the record's correct position for insertion.
X *
X * One comment about cursors.  The cursor key is never removed from the tree,
X * even if deleted.  This is because it is quite difficult to decide where the
X * cursor should be when other keys have been inserted/deleted in the tree;
X * duplicate keys make it impossible.  This scheme does require extra work
X * though, to make sure that we don't perform an operation on a deleted key.
X */
Xtypedef struct EPGNO {
X	pgno_t	pgno;			/* the page number */
X	indx_t	index;			/* the index on the page */
X} EPGNO;
X
Xtypedef struct EPG {
X	PAGE	*page;			/* the (pinned) page */
X	indx_t	 index;			/* the index on the page */
X} EPG;
X
X/*
X * The metadata of the tree.  The m_nrecs field is used only by the RECNO code.
X * This is because the btree doesn't really need it and it requires that every
X * put or delete call modify the metadata.
X */
Xtypedef struct BTMETA {
X	u_long	m_magic;		/* magic number */
X	u_long	m_version;		/* version */
X	u_long	m_psize;		/* page size */
X	u_long	m_free;			/* page number of first free page */
X	u_long	m_nrecs;		/* R: number of records */
X#define	SAVEMETA	(B_NODUPS | R_RECNO)
X	u_long	m_flags;		/* bt_flags & SAVEMETA */
X	u_long	m_unused;		/* unused */
X} BTMETA;
X
X/* The in-memory btree/recno data structure. */
Xtypedef struct BTREE {
X	MPOOL	*bt_mp;			/* memory pool cookie */
X
X	DB	*bt_dbp;		/* pointer to enclosing DB */
X
X	EPGNO	bt_bcursor;		/* B: btree cursor */
X	recno_t	bt_rcursor;		/* R: recno cursor (1-based) */
X
X#define	BT_POP(t)	(t->bt_sp ? t->bt_stack + --t->bt_sp : NULL)
X#define	BT_CLR(t)	(t->bt_sp = 0)
X	EPGNO	*bt_stack;		/* stack of parent pages */
X	u_int	bt_sp;			/* current stack pointer */
X	u_int	bt_maxstack;		/* largest stack */
X
X	char	*bt_kbuf;		/* key buffer */
X	size_t	bt_kbufsz;		/* key buffer size */
X	char	*bt_dbuf;		/* data buffer */
X	size_t	bt_dbufsz;		/* data buffer size */
X
X	int	bt_fd;			/* tree file descriptor */
X
X	pgno_t	bt_free;		/* next free page */
X	u_long	bt_psize;		/* page size */
X	indx_t	bt_ovflsize;		/* cut-off for key/data overflow */
X	int	bt_lorder;		/* byte order */
X					/* sorted order */
X	enum { NOT, BACK, FORWARD, } bt_order;
X	EPGNO	bt_last;		/* last insert */
X
X					/* B: key comparison function */
X	int	(*bt_cmp) __P((const DBT *, const DBT *));
X					/* B: prefix comparison function */
X	int	(*bt_pfx) __P((const DBT *, const DBT *));
X					/* R: recno input function */
X	int	(*bt_irec) __P((struct BTREE *, recno_t));
X
X	FILE	*bt_rfp;		/* R: record FILE pointer */
X	int	bt_rfd;			/* R: record file descriptor */
X
X	caddr_t	bt_cmap;		/* R: current point in mapped space */
X	caddr_t	bt_smap;		/* R: start of mapped space */
X	caddr_t bt_emap;		/* R: end of mapped space */
X	size_t	bt_msize;		/* R: size of mapped region. */
X
X	recno_t	bt_nrecs;		/* R: number of records */
X	size_t	bt_reclen;		/* R: fixed record length */
X	u_char	bt_bval;		/* R: delimiting byte/pad character */
X
X/*
X * NB:
X * B_NODUPS and R_RECNO are stored on disk, and may not be changed.
X */
X#define	B_DELCRSR	0x00001		/* cursor has been deleted */
X#define	B_INMEM		0x00002		/* in-memory tree */
X#define	B_METADIRTY	0x00004		/* need to write metadata */
X#define	B_MODIFIED	0x00008		/* tree modified */
X#define	B_NEEDSWAP	0x00010		/* if byte order requires swapping */
X#define	B_NODUPS	0x00020		/* no duplicate keys permitted */
X#define	B_RDONLY	0x00040		/* read-only tree */
X#define	B_SEQINIT	0x00100		/* sequential scan initialized */
X
X#define	R_CLOSEFP	0x00200		/* opened a file pointer */
X#define	R_EOF		0x00400		/* end of input file reached. */
X#define	R_FIXLEN	0x00800		/* fixed length records */
X#define	R_MEMMAPPED	0x01000		/* memory mapped file. */
X#define	R_RECNO		0x00080		/* record oriented tree */
X#define	R_INMEM		0x02000		/* in-memory file */
X#define	R_MODIFIED	0x04000		/* modified file */
X#define	R_RDONLY	0x08000		/* read-only file */
X
X	u_long		bt_flags;	/* btree state */
X} BTREE;
X
X#define	SET(t, f)	((t)->bt_flags |= (f))
X#define	CLR(t, f)	((t)->bt_flags &= ~(f))
X#define	ISSET(t, f)	((t)->bt_flags & (f))
X
X#include "extern.h"
END_OF_FILE
if test 12888 -ne `wc -c <'btree/btree.h'`; then
    echo shar: \"'btree/btree.h'\" unpacked with wrong size!
fi
# end of 'btree/btree.h'
fi
if test -f 'doc/mpool.3.ps' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/mpool.3.ps'\"
else
echo shar: Extracting \"'doc/mpool.3.ps'\" \(13311 characters\)
sed "s/^X//" >'doc/mpool.3.ps' <<'END_OF_FILE'
X%!PS-Adobe-3.0
X%%Creator: groff version 1.08
X%%DocumentNeededResources: font Times-Roman
X%%+ font Times-Bold
X%%+ font Times-Italic
X%%DocumentSuppliedResources: procset grops 1.08 0
X%%Pages: 2
X%%PageOrder: Ascend
X%%Orientation: Portrait
X%%EndComments
X%%BeginProlog
X%%BeginResource: procset grops 1.08 0
X/setpacking where{
Xpop
Xcurrentpacking
Xtrue setpacking
X}if
X/grops 120 dict dup begin
X/SC 32 def
X/A/show load def
X/B{0 SC 3 -1 roll widthshow}bind def
X/C{0 exch ashow}bind def
X/D{0 exch 0 SC 5 2 roll awidthshow}bind def
X/E{0 rmoveto show}bind def
X/F{0 rmoveto 0 SC 3 -1 roll widthshow}bind def
X/G{0 rmoveto 0 exch ashow}bind def
X/H{0 rmoveto 0 exch 0 SC 5 2 roll awidthshow}bind def
X/I{0 exch rmoveto show}bind def
X/J{0 exch rmoveto 0 SC 3 -1 roll widthshow}bind def
X/K{0 exch rmoveto 0 exch ashow}bind def
X/L{0 exch rmoveto 0 exch 0 SC 5 2 roll awidthshow}bind def
X/M{rmoveto show}bind def
X/N{rmoveto 0 SC 3 -1 roll widthshow}bind def
X/O{rmoveto 0 exch ashow}bind def
X/P{rmoveto 0 exch 0 SC 5 2 roll awidthshow}bind def
X/Q{moveto show}bind def
X/R{moveto 0 SC 3 -1 roll widthshow}bind def
X/S{moveto 0 exch ashow}bind def
X/T{moveto 0 exch 0 SC 5 2 roll awidthshow}bind def
X/SF{
Xfindfont exch
X[exch dup 0 exch 0 exch neg 0 0]makefont
Xdup setfont
X[exch/setfont cvx]cvx bind def
X}bind def
X/MF{
Xfindfont
X[5 2 roll
X0 3 1 roll 
Xneg 0 0]makefont
Xdup setfont
X[exch/setfont cvx]cvx bind def
X}bind def
X/level0 0 def
X/RES 0 def
X/PL 0 def
X/LS 0 def
X/PLG{
Xgsave newpath clippath pathbbox grestore
Xexch pop add exch pop
X}bind def
X/BP{
X/level0 save def
X1 setlinecap
X1 setlinejoin
X72 RES div dup scale
XLS{
X90 rotate
X}{
X0 PL translate
X}ifelse
X1 -1 scale
X}bind def
X/EP{
Xlevel0 restore
Xshowpage
X}bind def
X/DA{
Xnewpath arcn stroke
X}bind def
X/SN{
Xtransform
X.25 sub exch .25 sub exch
Xround .25 add exch round .25 add exch
Xitransform
X}bind def
X/DL{
XSN
Xmoveto
XSN
Xlineto stroke
X}bind def
X/DC{
Xnewpath 0 360 arc closepath
X}bind def
X/TM matrix def
X/DE{
XTM currentmatrix pop
Xtranslate scale newpath 0 0 .5 0 360 arc closepath
XTM setmatrix
X}bind def
X/RC/rcurveto load def
X/RL/rlineto load def
X/ST/stroke load def
X/MT/moveto load def
X/CL/closepath load def
X/FL{
Xcurrentgray exch setgray fill setgray
X}bind def
X/BL/fill load def
X/LW/setlinewidth load def
X/RE{
Xfindfont
Xdup maxlength 1 index/FontName known not{1 add}if dict begin
X{
X1 index/FID ne{def}{pop pop}ifelse
X}forall
X/Encoding exch def
Xdup/FontName exch def
Xcurrentdict end definefont pop
X}bind def
X/DEFS 0 def
X/EBEGIN{
Xmoveto
XDEFS begin
X}bind def
X/EEND/end load def
X/CNT 0 def
X/level1 0 def
X/PBEGIN{
X/level1 save def
Xtranslate
Xdiv 3 1 roll div exch scale
Xneg exch neg exch translate
X0 setgray
X0 setlinecap
X1 setlinewidth
X0 setlinejoin
X10 setmiterlimit
X[]0 setdash
X/setstrokeadjust where{
Xpop
Xfalse setstrokeadjust
X}if
X/setoverprint where{
Xpop
Xfalse setoverprint
X}if
Xnewpath
X/CNT countdictstack def
Xuserdict begin
X/showpage{}def
X}bind def
X/PEND{
Xclear
Xcountdictstack CNT sub{end}repeat
Xlevel1 restore
X}bind def
Xend def
X/setpacking where{
Xpop
Xsetpacking
X}if
X%%EndResource
X%%IncludeResource: font Times-Roman
X%%IncludeResource: font Times-Bold
X%%IncludeResource: font Times-Italic
Xgrops begin/DEFS 1 dict def DEFS begin/u{.001 mul}bind def end/RES 72 def/PL
X792 def/LS false def/ENC0[/asciicircum/asciitilde/Scaron/Zcaron/scaron/zcaron
X/Ydieresis/trademark/quotesingle/.notdef/.notdef/.notdef/.notdef/.notdef
X/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
X/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/space
X/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright/parenleft
X/parenright/asterisk/plus/comma/hyphen/period/slash/zero/one/two/three/four
X/five/six/seven/eight/nine/colon/semicolon/less/equal/greater/question/at/A/B/C
X/D/E/F/G/H/I/J/K/L/M/N/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash
X/bracketright/circumflex/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q
X/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/tilde/.notdef/quotesinglbase
X/guillemotleft/guillemotright/bullet/florin/fraction/perthousand/dagger
X/daggerdbl/endash/emdash/ff/fi/fl/ffi/ffl/dotlessi/dotlessj/grave/hungarumlaut
X/dotaccent/breve/caron/ring/ogonek/quotedblleft/quotedblright/oe/lslash
X/quotedblbase/OE/Lslash/.notdef/exclamdown/cent/sterling/currency/yen/brokenbar
X/section/dieresis/copyright/ordfeminine/guilsinglleft/logicalnot/minus
X/registered/macron/degree/plusminus/twosuperior/threesuperior/acute/mu
X/paragraph/periodcentered/cedilla/onesuperior/ordmasculine/guilsinglright
X/onequarter/onehalf/threequarters/questiondown/Agrave/Aacute/Acircumflex/Atilde
X/Adieresis/Aring/AE/Ccedilla/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute
X/Icircumflex/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis
X/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute/Thorn/germandbls
X/agrave/aacute/acircumflex/atilde/adieresis/aring/ae/ccedilla/egrave/eacute
X/ecircumflex/edieresis/igrave/iacute/icircumflex/idieresis/eth/ntilde/ograve
X/oacute/ocircumflex/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex
X/udieresis/yacute/thorn/ydieresis]def/Times-Italic@0 ENC0/Times-Italic RE
X/Times-Bold@0 ENC0/Times-Bold RE/Times-Roman@0 ENC0/Times-Roman RE
X%%EndProlog
X%%Page: 1 1
X%%BeginPageSetup
XBP
X%%EndPageSetup
X/F0 10/Times-Roman@0 SF 174.84(MPOOL\(3\) 1991 MPOOL\(3\))72 48 R/F1 9
X/Times-Bold@0 SF -.18(NA)72 84 S(ME).18 E F0(mpool \255 shared memory b)108 96
XQ(uf)-.2 E(fer pool)-.25 E F1(SYNOPSIS)72 112.8 Q/F2 10/Times-Bold@0 SF
X(#include <db)108 124.8 Q(.h>)-.4 E(#include <mpool.h>)108 136.8 Q(MPOOL *)108
X160.8 Q(mpool_open \(DBT *k)108 172.8 Q(ey)-.1 E 2.5(,i)-.55 G
X(nt fd, pgno_t pagesize, pgno_t maxcache\);)216.25 172.8 Q -.1(vo)108 196.8 S
X(id).1 E(mpool_\214lter \(MPOOL *mp, v)108 208.8 Q(oid \(*pgin\)\(v)-.1 E
X(oid *, pgno_t, v)-.1 E(oid *\),)-.1 E -.1(vo)158 220.8 S(id \(*pgout\)\(v).1 E
X(oid *, pgno_t, v)-.1 E(oid *\), v)-.1 E(oid *pgcookie\);)-.1 E -.1(vo)108
X244.8 S(id *).1 E(mpool_new \(MPOOL *mp, pgno_t *pgnoaddr\);)108 256.8 Q -.1
X(vo)108 280.8 S(id *).1 E(mpool_get \(MPOOL *mp, pgno_t pgno, u_int \215ags\);)
X108 292.8 Q(int)108 316.8 Q(mpool_put \(MPOOL *mp, v)108 328.8 Q(oid *pgaddr)
X-.1 E 2.5(,u)-.92 G(_int \215ags\);)290.62 328.8 Q(int)108 352.8 Q
X(mpool_sync \(MPOOL *mp\);)108 364.8 Q(int)108 388.8 Q
X(mpool_close \(MPOOL *mp\);)108 400.8 Q F1(DESCRIPTION)72 417.6 Q/F3 10
X/Times-Italic@0 SF(Mpool)108 429.6 Q F0 1.013(is the library interf)3.513 F
X1.013(ace intended to pro)-.1 F 1.013(vide page oriented b)-.15 F(uf)-.2 E
X1.012(fer management of \214les.)-.25 F 1.012(The b)6.012 F(uf)-.2 E(fers)-.25
XE(may be shared between processes.)108 441.6 Q .416(The function)108 458.4 R F3
X(mpool_open)2.916 E F0 .417(initializes a memory pool.)2.917 F(The)5.417 E F3
X-.1(ke)2.917 G(y)-.2 E F0(ar)2.917 E .417(gument is the byte string used to ne)
X-.18 F(gotiate)-.15 E .697(between multiple processes wishing to share b)108
X470.4 R(uf)-.2 E 3.196(fers. If)-.25 F .696(the \214le b)3.196 F(uf)-.2 E .696
X(fers are mapped in shared memory)-.25 F 3.196(,a)-.65 G(ll)534.44 470.4 Q .894
X(processes using the same k)108 482.4 R 1.194 -.15(ey w)-.1 H .894
X(ill share the b).15 F(uf)-.2 E 3.394(fers. If)-.25 F F3 -.1(ke)3.394 G(y)-.2 E
XF0 .895(is NULL, the b)3.395 F(uf)-.2 E .895(fers are mapped into pri)-.25 F
X-.25(va)-.25 G(te).25 E(memory)108 494.4 Q 5.116(.T)-.65 G(he)154.406 494.4 Q
XF3(fd)2.616 E F0(ar)2.616 E .115(gument is a \214le descriptor for the underly\
Xing \214le, which must be seekable.)-.18 F(If)5.115 E F3 -.1(ke)2.615 G(y)-.2 E
XF0 .115(is non-)2.615 F(NULL and matches a \214le already being mapped, the)108
X506.4 Q F3(fd)2.5 E F0(ar)2.5 E(gument is ignored.)-.18 E(The)108 523.2 Q F3
X(pa)3.328 E -.1(ge)-.1 G(size).1 E F0(ar)3.329 E .829
X(gument is the size, in bytes, of the pages into which the \214le is brok)-.18
XF .829(en up.)-.1 F(The)5.829 E F3(maxcac)3.329 E(he)-.15 E F0(ar)108 535.2 Q
X.153(gument is the maximum number of pages from the underlying \214le to cache\
X at an)-.18 F 2.653(yo)-.15 G .153(ne time.)451.308 535.2 R .153(This v)5.153 F
X.153(alue is)-.25 F .099(not relati)108 547.2 R .399 -.15(ve t)-.25 H 2.599(ot)
X.15 G .099(he number of processes which share a \214le')168.727 547.2 R 2.6(sb)
X-.55 G(uf)350.39 547.2 Q .1(fers, b)-.25 F .1(ut will be the lar)-.2 F .1
X(gest v)-.18 F .1(alue speci\214ed by)-.25 F(an)108 559.2 Q 2.5(yo)-.15 G 2.5
X(ft)129.79 559.2 S(he processes sharing the \214le.)138.4 559.2 Q(The)108 576 Q
XF3(mpool_\214lter)3.254 E F0 .754(function is intended to mak)3.254 F 3.254(et)
X-.1 G .754(ransparent input and output processing of the pages possi-)301.778
X576 R 3.095(ble. If)108 588 R(the)3.095 E F3(pgin)3.095 E F0 .596
X(function is speci\214ed, it is called each time a b)3.095 F(uf)-.2 E .596
X(fer is read into the memory pool from the)-.25 F .125(backing \214le.)108 600
XR .125(If the)5.125 F F3(pgout)2.625 E F0 .125
X(function is speci\214ed, it is called each time a b)2.625 F(uf)-.2 E .125
X(fer is written into the backing \214le.)-.25 F .276
X(Both functions are are called with the)108 612 R F3(pgcookie)2.777 E F0
X(pointer)2.777 E 2.777(,t)-.4 G .277
X(he page number and a pointer to the page to being)337.27 612 R
X(read or written.)108 624 Q .124(The function)108 640.8 R F3(mpool_ne)2.624 E
X(w)-.15 E F0(tak)2.624 E .123(es an MPOOL pointer and an address as ar)-.1 F
X2.623(guments. If)-.18 F 2.623(an)2.623 G .623 -.25(ew p)457.568 640.8 T .123
X(age can be allo-).25 F .944(cated, a pointer to the page is returned and the \
Xpage number is stored into the)108 652.8 R F3(pgnoaddr)3.445 E F0 3.445
X(address. Other)3.445 F(-)-.2 E(wise, NULL is returned and errno is set.)108
X664.8 Q 1.167(The function)108 681.6 R F3(mpool_g)3.667 E(et)-.1 E F0(tak)3.667
XE 1.167(es a MPOOL pointer and a page number as ar)-.1 F 3.666(guments. If)-.18
XF 1.166(the page e)3.666 F 1.166(xists, a)-.15 F .686
X(pointer to the page is returned.)108 693.6 R .687
X(Otherwise, NULL is returned and errno is set.)5.686 F .687
X(The \215ags parameter is not)5.687 F(currently used.)108 705.6 Q 1.463
X(The function)108 722.4 R F3(mpool_put)3.963 E F0 1.462
X(unpins the page referenced by)3.962 F F3(pgaddr)3.962 E F0(.).73 E F3(Pgaddr)
X6.462 E F0 1.462(must be an address pre)3.962 F(viously)-.25 E 197.615
X(12, September)72 768 R(1)535 768 Q EP
X%%Page: 2 2
X%%BeginPageSetup
XBP
X%%EndPageSetup
X/F0 10/Times-Roman@0 SF 174.84(MPOOL\(3\) 1991 MPOOL\(3\))72 48 R(returned by)
X108 84 Q/F1 10/Times-Italic@0 SF(mpool_g)2.5 E(et)-.1 E F0(or)2.5 E F1
X(mpool_ne)2.5 E(w)-.15 E F0 5(.T).31 G(he \215ag v)271.65 84 Q
X(alue is speci\214ed by)-.25 E F1(or)2.5 E F0('ing an).73 E 2.5(yo)-.15 G 2.5
X(ft)434.74 84 S(he follo)443.35 84 Q(wing v)-.25 E(alues:)-.25 E(MPOOL_DIR)108
X100.8 Q(TY)-.6 E
X(The page has been modi\214ed and needs to be written to the backing \214le.)
X144 112.8 Q F1(Mpool_put)108 129.6 Q F0
X(returns 0 on success and -1 if an error occurs.)2.5 E .247(The function)108
X146.4 R F1(mpool_sync)2.747 E F0 .247(writes all modi\214ed pages associated w\
Xith the MPOOL pointer to the backing \214le.)2.747 F F1(Mpool_sync)108 158.4 Q
XF0(returns 0 on success and -1 if an error occurs.)2.5 E(The)108 175.2 Q F1
X(mpool_close)2.698 E F0 .198(function free')2.698 F 2.698(su)-.55 G 2.698(pa)
X245.432 175.2 S .498 -.15(ny a)257.57 175.2 T .198
X(llocated memory associated with the memory pool cookie.).15 F(Modi-)5.197 E
X(\214ed pages are)108 187.2 Q/F2 10/Times-Bold@0 SF(not)2.5 E F0
X(written to the backing \214le.)2.5 E F1(Mpool_close)5 E F0
X(returns 0 on success and -1 if an error occurs.)2.5 E/F3 9/Times-Bold@0 SF
X(ERR)72 204 Q(ORS)-.27 E F0(The)108 216 Q F1(mpool_open)2.938 E F0 .438
X(function may f)2.938 F .438(ail and set)-.1 F F1(errno)2.938 E F0 .438(for an)
X2.938 F 2.938(yo)-.15 G 2.938(ft)344.87 216 S .439
X(he errors speci\214ed for the library routine)353.918 216 R F1(mal-)2.939 E
X(loc)108 228 Q F0(\(3\).).31 E(The)108 244.8 Q F1(mpool_g)2.5 E(et)-.1 E F0
X(function may f)2.5 E(ail and set)-.1 E F1(errno)2.5 E F0(for the follo)2.5 E
X(wing:)-.25 E([EINV)108 261.6 Q 29.98(AL] The)-1.35 F(requested record doesn')
X2.5 E 2.5(te)-.18 G(xist.)305.96 261.6 Q(The)108 278.4 Q F1(mpool_ne)4.073 E(w)
X-.15 E F0(and)4.073 E F1(mpool_g)4.073 E(et)-.1 E F0 1.573(functions may f)
X4.073 F 1.573(ail and set)-.1 F F1(errno)4.073 E F0 1.573(for an)4.073 F 4.073
X(yo)-.15 G 4.073(ft)421.336 278.4 S 1.573(he errors speci\214ed for the)431.519
X278.4 R(library routines)108 290.4 Q F1 -.37(re)2.5 G(ad).37 E F0(\(2\)).77 E
XF1 2.5(,w).54 G(rite)214.48 290.4 Q F0(\(2\)).18 E F1(,).54 E F0(and)2.5 E F1
X(malloc)2.5 E F0(\(3\).).31 E(The)108 307.2 Q F1(mpool_sync)4.287 E F0 1.787
X(function may f)4.287 F 1.787(ail and set)-.1 F F1(errno)4.288 E F0 1.788
X(for an)4.288 F 4.288(yo)-.15 G 4.288(ft)356.694 307.2 S 1.788
X(he errors speci\214ed for the library routine)367.092 307.2 R F1(write)108
X319.2 Q F0(\(2\).).18 E(The)108 336 Q F1(mpool_close)4.125 E F0 1.624
X(function may f)4.125 F 1.624(ail and set)-.1 F F1(errno)4.124 E F0 1.624
X(for an)4.124 F 4.124(yo)-.15 G 4.124(ft)357.842 336 S 1.624
X(he errors speci\214ed for the library routine)368.076 336 R F1(fr)108 348 Q
X(ee)-.37 E F0(\(3\).).18 E F3(SEE ALSO)72 364.8 Q F1(dbopen)108 376.8 Q F0
X(\(3\),).24 E F1(btr)2.5 E(ee)-.37 E F0(\(3\),).18 E F1(hash)2.5 E F0(\(3\),)
X.28 E F1 -.37(re)2.5 G(cno).37 E F0(\(3\)).18 E 197.615(12, September)72 768 R
X(2)535 768 Q EP
X%%Trailer
Xend
X%%EOF
END_OF_FILE
if test 13311 -ne `wc -c <'doc/mpool.3.ps'`; then
    echo shar: \"'doc/mpool.3.ps'\" unpacked with wrong size!
fi
# end of 'doc/mpool.3.ps'
fi
if test -f 'doc/recno.3.ps' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/recno.3.ps'\"
else
echo shar: Extracting \"'doc/recno.3.ps'\" \(12881 characters\)
sed "s/^X//" >'doc/recno.3.ps' <<'END_OF_FILE'
X%!PS-Adobe-3.0
X%%Creator: groff version 1.08
X%%DocumentNeededResources: font Times-Roman
X%%+ font Times-Bold
X%%+ font Times-Italic
X%%DocumentSuppliedResources: procset grops 1.08 0
X%%Pages: 2
X%%PageOrder: Ascend
X%%Orientation: Portrait
X%%EndComments
X%%BeginProlog
X%%BeginResource: procset grops 1.08 0
X/setpacking where{
Xpop
Xcurrentpacking
Xtrue setpacking
X}if
X/grops 120 dict dup begin
X/SC 32 def
X/A/show load def
X/B{0 SC 3 -1 roll widthshow}bind def
X/C{0 exch ashow}bind def
X/D{0 exch 0 SC 5 2 roll awidthshow}bind def
X/E{0 rmoveto show}bind def
X/F{0 rmoveto 0 SC 3 -1 roll widthshow}bind def
X/G{0 rmoveto 0 exch ashow}bind def
X/H{0 rmoveto 0 exch 0 SC 5 2 roll awidthshow}bind def
X/I{0 exch rmoveto show}bind def
X/J{0 exch rmoveto 0 SC 3 -1 roll widthshow}bind def
X/K{0 exch rmoveto 0 exch ashow}bind def
X/L{0 exch rmoveto 0 exch 0 SC 5 2 roll awidthshow}bind def
X/M{rmoveto show}bind def
X/N{rmoveto 0 SC 3 -1 roll widthshow}bind def
X/O{rmoveto 0 exch ashow}bind def
X/P{rmoveto 0 exch 0 SC 5 2 roll awidthshow}bind def
X/Q{moveto show}bind def
X/R{moveto 0 SC 3 -1 roll widthshow}bind def
X/S{moveto 0 exch ashow}bind def
X/T{moveto 0 exch 0 SC 5 2 roll awidthshow}bind def
X/SF{
Xfindfont exch
X[exch dup 0 exch 0 exch neg 0 0]makefont
Xdup setfont
X[exch/setfont cvx]cvx bind def
X}bind def
X/MF{
Xfindfont
X[5 2 roll
X0 3 1 roll 
Xneg 0 0]makefont
Xdup setfont
X[exch/setfont cvx]cvx bind def
X}bind def
X/level0 0 def
X/RES 0 def
X/PL 0 def
X/LS 0 def
X/PLG{
Xgsave newpath clippath pathbbox grestore
Xexch pop add exch pop
X}bind def
X/BP{
X/level0 save def
X1 setlinecap
X1 setlinejoin
X72 RES div dup scale
XLS{
X90 rotate
X}{
X0 PL translate
X}ifelse
X1 -1 scale
X}bind def
X/EP{
Xlevel0 restore
Xshowpage
X}bind def
X/DA{
Xnewpath arcn stroke
X}bind def
X/SN{
Xtransform
X.25 sub exch .25 sub exch
Xround .25 add exch round .25 add exch
Xitransform
X}bind def
X/DL{
XSN
Xmoveto
XSN
Xlineto stroke
X}bind def
X/DC{
Xnewpath 0 360 arc closepath
X}bind def
X/TM matrix def
X/DE{
XTM currentmatrix pop
Xtranslate scale newpath 0 0 .5 0 360 arc closepath
XTM setmatrix
X}bind def
X/RC/rcurveto load def
X/RL/rlineto load def
X/ST/stroke load def
X/MT/moveto load def
X/CL/closepath load def
X/FL{
Xcurrentgray exch setgray fill setgray
X}bind def
X/BL/fill load def
X/LW/setlinewidth load def
X/RE{
Xfindfont
Xdup maxlength 1 index/FontName known not{1 add}if dict begin
X{
X1 index/FID ne{def}{pop pop}ifelse
X}forall
X/Encoding exch def
Xdup/FontName exch def
Xcurrentdict end definefont pop
X}bind def
X/DEFS 0 def
X/EBEGIN{
Xmoveto
XDEFS begin
X}bind def
X/EEND/end load def
X/CNT 0 def
X/level1 0 def
X/PBEGIN{
X/level1 save def
Xtranslate
Xdiv 3 1 roll div exch scale
Xneg exch neg exch translate
X0 setgray
X0 setlinecap
X1 setlinewidth
X0 setlinejoin
X10 setmiterlimit
X[]0 setdash
X/setstrokeadjust where{
Xpop
Xfalse setstrokeadjust
X}if
X/setoverprint where{
Xpop
Xfalse setoverprint
X}if
Xnewpath
X/CNT countdictstack def
Xuserdict begin
X/showpage{}def
X}bind def
X/PEND{
Xclear
Xcountdictstack CNT sub{end}repeat
Xlevel1 restore
X}bind def
Xend def
X/setpacking where{
Xpop
Xsetpacking
X}if
X%%EndResource
X%%IncludeResource: font Times-Roman
X%%IncludeResource: font Times-Bold
X%%IncludeResource: font Times-Italic
Xgrops begin/DEFS 1 dict def DEFS begin/u{.001 mul}bind def end/RES 72 def/PL
X792 def/LS false def/ENC0[/asciicircum/asciitilde/Scaron/Zcaron/scaron/zcaron
X/Ydieresis/trademark/quotesingle/.notdef/.notdef/.notdef/.notdef/.notdef
X/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
X/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/space
X/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright/parenleft
X/parenright/asterisk/plus/comma/hyphen/period/slash/zero/one/two/three/four
X/five/six/seven/eight/nine/colon/semicolon/less/equal/greater/question/at/A/B/C
X/D/E/F/G/H/I/J/K/L/M/N/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash
X/bracketright/circumflex/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q
X/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/tilde/.notdef/quotesinglbase
X/guillemotleft/guillemotright/bullet/florin/fraction/perthousand/dagger
X/daggerdbl/endash/emdash/ff/fi/fl/ffi/ffl/dotlessi/dotlessj/grave/hungarumlaut
X/dotaccent/breve/caron/ring/ogonek/quotedblleft/quotedblright/oe/lslash
X/quotedblbase/OE/Lslash/.notdef/exclamdown/cent/sterling/currency/yen/brokenbar
X/section/dieresis/copyright/ordfeminine/guilsinglleft/logicalnot/minus
X/registered/macron/degree/plusminus/twosuperior/threesuperior/acute/mu
X/paragraph/periodcentered/cedilla/onesuperior/ordmasculine/guilsinglright
X/onequarter/onehalf/threequarters/questiondown/Agrave/Aacute/Acircumflex/Atilde
X/Adieresis/Aring/AE/Ccedilla/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute
X/Icircumflex/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis
X/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute/Thorn/germandbls
X/agrave/aacute/acircumflex/atilde/adieresis/aring/ae/ccedilla/egrave/eacute
X/ecircumflex/edieresis/igrave/iacute/icircumflex/idieresis/eth/ntilde/ograve
X/oacute/ocircumflex/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex
X/udieresis/yacute/thorn/ydieresis]def/Times-Italic@0 ENC0/Times-Italic RE
X/Times-Bold@0 ENC0/Times-Bold RE/Times-Roman@0 ENC0/Times-Roman RE
X%%EndProlog
X%%Page: 1 1
X%%BeginPageSetup
XBP
X%%EndPageSetup
X/F0 10/Times-Roman@0 SF 175.95(RECNO\(3\) 1993 RECNO\(3\))72 48 R/F1 9
X/Times-Bold@0 SF -.18(NA)72 84 S(ME).18 E F0
X(recno \255 record number database access method)108 96 Q F1(SYNOPSIS)72 112.8
XQ/F2 10/Times-Bold@0 SF(#include <sys/types.h>)108 124.8 Q(#include <db)108
X136.8 Q(.h>)-.4 E F1(DESCRIPTION)72 153.6 Q F0 1.158(The routine)108 165.6 R/F3
X10/Times-Italic@0 SF(dbopen)3.658 E F0 1.158(is the library interf)3.658 F
X1.158(ace to database \214les.)-.1 F 1.157
X(One of the supported \214le formats is record)6.158 F 1.159(number \214les.)
X108 177.6 R 1.159(The general description of the database access methods is in)
X6.159 F F3(dbopen)3.66 E F0 1.16(\(3\), this manual page).24 F
X(describes only the recno speci\214c information.)108 189.6 Q 1.944
X(The record number data structure is either v)108 206.4 R 1.944
X(ariable or \214x)-.25 F 1.944
X(ed-length records stored in a \215at-\214le format,)-.15 F 2.04
X(accessed by the logical record number)108 218.4 R 7.04(.T)-.55 G 2.04(he e)
X286.31 218.4 R 2.04(xistence of record number \214v)-.15 F 4.54(ei)-.15 G 2.04
X(mplies the e)442.1 218.4 R 2.04(xistence of)-.15 F .876
X(records one through four)108 230.4 R 3.376(,a)-.4 G .875
X(nd the deletion of record number one causes record number \214v)219.684 230.4
XR 3.375(et)-.15 G 3.375(ob)489.93 230.4 S 3.375(er)503.305 230.4 S(enum-)514.45
X230.4 Q .282(bered to record number four)108 242.4 R 2.782(,a)-.4 G 2.782(sw)
X231.19 242.4 S .283(ell as the cursor)245.082 242.4 R 2.783(,i)-.4 G 2.783(fp)
X316.633 242.4 S .283(ositioned after record number one, to shift do)327.746
X242.4 R .283(wn one)-.25 F(record.)108 254.4 Q .373
X(The recno access method speci\214c data structure pro)108 271.2 R .373
X(vided to)-.15 F F3(dbopen)2.873 E F0 .373(is de\214ned in the <db)2.873 F .373
X(.h> include \214le as)-.4 F(follo)108 283.2 Q(ws:)-.25 E(typedef struct {)108
X300 Q(u_char b)144 312 Q -.25(va)-.15 G(l;).25 E(u_int cachesize;)144 324 Q
X(inde)144 336 Q(x_t psize;)-.15 E(u_long \215ags;)144 348 Q(int lorder;)144 360
XQ(size_t reclen;)144 372 Q(char *bfname;)144 384 Q 2.5(}R)108 396 S(ECNOINFO;)
X121.97 396 Q(The elements of this structure are de\214ned as follo)108 412.8 Q
X(ws:)-.25 E -.15(bv)108 429.6 S 16.68(al The)-.1 F .182
X(delimiting byte to be used to mark the end of a record for v)2.682 F .183
X(ariable-length records, and the pad)-.25 F .809(character for \214x)144 441.6
XR .809(ed-length records.)-.15 F .809(If no v)5.809 F .809
X(alue is speci\214ed, ne)-.25 F .809(wlines \(`)-.25 F(`\\n')-.74 E .808
X('\) are used to mark the)-.74 F(end of v)144 453.6 Q
X(ariable-length records and \214x)-.25 E
X(ed-length records are padded with spaces.)-.15 E(cachesize)108 470.4 Q 3.159
X(As)144 482.4 S .659(uggested maximum size, in bytes, of the memory cache.)
X158.269 482.4 R .66(This v)5.659 F .66(alue is)-.25 F F2(only)3.16 E F0
X(advisory)3.16 E 3.16(,a)-.65 G .66(nd the)514.62 482.4 R
X(access method will allocate more memory rather than f)144 494.4 Q(ail.)-.1 E
X12.95(psize The)108 511.2 R .715
X(recno access method stores the in-memory copies of its records in a btree.)
X3.216 F .715(This v)5.715 F .715(alue is the)-.25 F
X(size \(in bytes\) of the pages used for nodes in that tree.)144 523.2 Q(See)5
XE F3(btr)2.5 E(ee)-.37 E F0(\(3\) for more information.).18 E 3.51(bfname The)
X108 540 R .505
X(recno access method stores the in-memory copies of its records in a btree.)
X3.005 F .506(If bfname is non-)5.506 F .065(NULL, it speci\214es the name of t\
Xhe btree \214le, as if speci\214ed as the \214le name for a dbopen of a btree)
X144 552 R(\214le.)144 564 Q 14.61(\215ags The)108 580.8 R(\215ag v)2.5 E
X(alue is speci\214ed by)-.25 E F3(or)2.5 E F0('ing an).73 E 2.5(yo)-.15 G 2.5
X(ft)313.2 580.8 S(he follo)321.81 580.8 Q(wing v)-.25 E(alues:)-.25 E
X(R_FIXEDLEN)144 597.6 Q .962(The records are \214x)180 609.6 R .963
X(ed-length, not byte delimited.)-.15 F .963(The structure element)5.963 F F3
X-.37(re)3.463 G(clen).37 E F0(speci\214es)3.463 E
X(the length of the record, and the structure element)180 621.6 Q F3(bval)2.5 E
XF0(is used as the pad character)2.5 E(.)-.55 E(R_NOKEY)144 638.4 Q 2.34
X(In the interf)180 650.4 R 2.34(ace speci\214ed by)-.1 F F3(dbopen)4.84 E F0
X4.84(,t).24 G 2.34(he sequential record retrie)344.98 650.4 R -.25(va)-.25 G
X4.84<6c8c>.25 G 2.34(lls in both the)478.25 650.4 R(caller')180 662.4 Q 3.556
X(sk)-.55 G 1.357 -.15(ey a)217.336 662.4 T 1.057(nd data structures.).15 F
X1.057(If the R_NOKEY \215ag is speci\214ed, the)6.057 F F3(cur)3.557 E(sor)-.1
XE F0(routines)3.557 E .029(are not required to \214ll in the k)180 674.4 R .329
X-.15(ey s)-.1 H 2.529(tructure. This).15 F .028(permits applications to retrie)
X2.529 F .328 -.15(ve r)-.25 H .028(ecords at).15 F
X(the end of \214les without reading all of the interv)180 686.4 Q
X(ening records.)-.15 E(R_SN)144 703.2 Q(APSHO)-.35 E(T)-.4 E .964
X(This \215ag requires that a snapshot of the \214le be tak)180 715.2 R .965
X(en when)-.1 F F3(dbopen)3.465 E F0 .965(is called, instead of)3.465 F
X(permitting an)180 727.2 Q 2.5(yu)-.15 G
X(nmodi\214ed records to be read from the original \214le.)245.96 727.2 Q
X209.835(16, May)72 768 R(1)535 768 Q EP
X%%Page: 2 2
X%%BeginPageSetup
XBP
X%%EndPageSetup
X/F0 10/Times-Roman@0 SF 175.95(RECNO\(3\) 1993 RECNO\(3\))72 48 R 9.62
X(lorder The)108 84 R 1.597(byte order for inte)4.097 F 1.596
X(gers in the stored database metadata.)-.15 F 1.596
X(The number should represent the)6.596 F .688(order as an inte)144 96 R .689
X(ger; for e)-.15 F .689(xample, big endian order w)-.15 F .689
X(ould be the number 4,321.)-.1 F(If)5.689 E/F1 10/Times-Italic@0 SF(lor)3.189 E
X(der)-.37 E F0 .689(is 0 \(no)3.189 F
X(order is speci\214ed\) the current host order is used.)144 108 Q 9.07
X(reclen The)108 124.8 R(length of a \214x)2.5 E(ed-length record.)-.15 E .972
X(The data part of the k)108 141.6 R -.15(ey)-.1 G .971(/data pair used by the \
Xrecno access method is the same as other access methods.).15 F .198(The k)108
X153.6 R .498 -.15(ey i)-.1 H 2.698(sd).15 G(if)157.504 153.6 Q 2.698
X(ferent. The)-.25 F F1(data)2.698 E F0 .198(\214eld of the k)2.698 F .499 -.15
X(ey s)-.1 H .199(hould be a pointer to a memory location of type).15 F F1 -.37
X(re)2.699 G(cno_t).37 E F0 2.699(,a).68 G(s)536.11 153.6 Q .506
X(de\214ned in the <db)108 165.6 R .506(.h> include \214le.)-.4 F .506
X(This type is normally the lar)5.506 F .506(gest unsigned inte)-.18 F .506
X(gral type a)-.15 F -.25(va)-.2 G .505(ilable to the).25 F 2.5
X(implementation. The)108 177.6 R F1(size)2.5 E F0(\214eld of the k)2.5 E .3
X-.15(ey s)-.1 H(hould be the size of that type.).15 E .064(In the interf)108
X194.4 R .064(ace speci\214ed by)-.1 F F1(dbopen)2.564 E F0 2.564(,u).24 G .064
X(sing the)261.544 194.4 R F1(put)2.564 E F0(interf)2.564 E .064
X(ace to create a ne)-.1 F 2.564(wr)-.25 G .065
X(ecord will cause the creation of)414.436 194.4 R .755(multiple, empty records\
X if the record number is more than one greater than the lar)108 206.4 R .754
X(gest record currently in)-.18 F(the database.)108 218.4 Q/F2 9/Times-Bold@0 SF
X(SEE ALSO)72 235.2 Q F1(dbopen)108 247.2 Q F0(\(3\),).24 E F1(hash)2.5 E F0
X(\(3\),).28 E F1(mpool)2.5 E F0(\(3\),).51 E F1 -.37(re)2.5 G(cno).37 E F0
X(\(3\)).18 E F1 2.754(Document Pr)108 271.2 R 2.754
X(ocessing in a Relational Database System)-.45 F F0 5.255(,M).32 G 2.755
X(ichael Stonebrak)362.13 271.2 R(er)-.1 E 5.255(,H)-.4 G 2.755(eidi Stettner)
X454.06 271.2 R 5.255(,J)-.4 G(oseph)516.67 271.2 Q
X(Kalash, Antonin Guttman, Nadene L)108 283.2 Q
X(ynn, Memorandum No. UCB/ERL M82/32, May 1982.)-.55 E F2 -.09(BU)72 300 S(GS)
X.09 E F0(Only big and little endian byte order is supported.)108 312 Q 209.835
X(16, May)72 768 R(2)535 768 Q EP
X%%Trailer
Xend
X%%EOF
END_OF_FILE
if test 12881 -ne `wc -c <'doc/recno.3.ps'`; then
    echo shar: \"'doc/recno.3.ps'\" unpacked with wrong size!
fi
# end of 'doc/recno.3.ps'
fi
if test -f 'man/dbopen.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man/dbopen.3'\"
else
echo shar: Extracting \"'man/dbopen.3'\" \(12751 characters\)
sed "s/^X//" >'man/dbopen.3' <<'END_OF_FILE'
X.\" Copyright (c) 1990, 1993
X.\"	The Regents of the University of California.  All rights reserved.
X.\"
X.\" Redistribution and use in source and binary forms, with or without
X.\" modification, are permitted provided that the following conditions
X.\" are met:
X.\" 1. Redistributions of source code must retain the above copyright
X.\"    notice, this list of conditions and the following disclaimer.
X.\" 2. Redistributions in binary form must reproduce the above copyright
X.\"    notice, this list of conditions and the following disclaimer in the
X.\"    documentation and/or other materials provided with the distribution.
X.\" 3. All advertising materials mentioning features or use of this software
X.\"    must display the following acknowledgement:
X.\"	This product includes software developed by the University of
X.\"	California, Berkeley and its contributors.
X.\" 4. Neither the name of the University nor the names of its contributors
X.\"    may be used to endorse or promote products derived from this software
X.\"    without specific prior written permission.
X.\"
X.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X.\" SUCH DAMAGE.
X.\"
X.\"	@(#)dbopen.3	8.1 (Berkeley) 6/4/93
X.\"
X.TH DBOPEN 3 "June 4, 1993"
X.UC 7
X.SH NAME
Xdbopen \- database access methods
X.SH SYNOPSIS
X.nf
X.ft B
X#include <sys/types.h>
X#include <limits.h>
X#include <db.h>
X
XDB *
Xdbopen(const char *file, int flags, int mode, DBTYPE type,
X.ti +5
Xconst void *openinfo);
X.ft R
X.fi
X.SH DESCRIPTION
X.IR Dbopen
Xis the library interface to database files.
XThe supported file formats are btree, hashed and UNIX file oriented.
XThe btree format is a representation of a sorted, balanced tree structure.
XThe hashed format is an extensible, dynamic hashing scheme.
XThe flat-file format is a byte stream file with fixed or variable length
Xrecords.
XThe formats and file format specific information are described in detail
Xin their respective manual pages
X.IR btree (3),
X.IR hash (3)
Xand
X.IR recno (3).
X.PP
XDbopen opens
X.I file
Xfor reading and/or writing.
XFiles never intended to be preserved on disk may be created by setting
Xthe file parameter to NULL.
X.PP
XThe
X.I flags
Xand
X.I mode arguments
Xare as specified to the
X.IR open (2)
Xroutine, however, only the O_CREAT, O_EXCL, O_EXLOCK, O_RDONLY, O_RDWR,
XO_SHLOCK and O_TRUNC flags are meaningful.
X(Note, opening a database file O_WRONLY is not possible.)
X.PP
XThe
X.I type
Xargument is of type DBTYPE (as defined in the <db.h> include file) and
Xmay be set to DB_BTREE, DB_HASH or DB_RECNO.
X.PP
XThe
X.I openinfo
Xargument is a pointer to an access method specific structure described
Xin the access method's manual page.
XIf
X.I openinfo
Xis NULL, each access method will use defaults appropriate for the system
Xand the access method.
X.PP
X.I Dbopen
Xreturns a pointer to a DB structure on success and NULL on error.
XThe DB structure is defined in the <db.h> include file, and contains at
Xleast the following fields:
X.sp
X.nf
Xtypedef struct {
X.RS
XDBTYPE type;
Xint (*close)(const DB *db);
Xint (*del)(const DB *db, const DBT *key, u_int flags);
Xint (*fd)(const DB *db);
Xint (*get)(const DB *db, DBT *key, DBT *data, u_int flags);
Xint (*put)(const DB *db, DBT *key, const DBT *data,
X.ti +5
Xu_int flags);
Xint (*sync)(const DB *db, u_int flags);
Xint (*seq)(const DB *db, DBT *key, DBT *data, u_int flags);
X.RE
X} DB;
X.fi
X.PP
XThese elements describe a database type and a set of functions performing
Xvarious actions.
XThese functions take a pointer to a structure as returned by
X.IR dbopen ,
Xand sometimes one or more pointers to key/data structures and a flag value.
X.TP
Xtype
XThe type of the underlying access method (and file format).
X.TP
Xclose
XA pointer to a routine to flush any cached information to disk, free any
Xallocated resources, and close the underlying file(s).
XSince key/data pairs may be cached in memory, failing to sync the file
Xwith a
X.I close
Xor
X.I sync
Xfunction may result in inconsistent or lost information.
X.I Close
Xroutines return -1 on error (setting
X.IR errno )
Xand 0 on success.
X.TP
Xdel
XA pointer to a routine to remove key/data pairs from the database.
X.IP
XThe parameter
X.I flag
Xmay be set to the following value:
X.RS
X.TP
XR_CURSOR
XDelete the record referenced by the cursor.
XThe cursor must have previously been initialized.
X.RE
X.IP
X.I Delete
Xroutines return -1 on error (setting
X.IR errno ),
X0 on success, and 1 if the specified
X.I key
Xwas not in the file.
X.TP
Xfd
XA pointer to a routine which returns a file descriptor representative
Xof the underlying database.
XA file descriptor referencing the same file will be returned to all
Xprocesses which call
X.I dbopen
Xwith the same
X.I file
Xname.
XThis file descriptor may be safely used as a argument to the
X.IR fcntl (2)
Xand
X.IR flock (2)
Xlocking functions.
XThe file descriptor is not necessarily associated with any of the
Xunderlying files used by the access method.
XNo file descriptor is available for in memory databases.
X.I Fd
Xroutines return -1 on error (setting
X.IR errno ),
Xand the file descriptor on success.
X.TP
Xget
XA pointer to a routine which is the interface for keyed retrieval from
Xthe database.
XThe address and length of the data associated with the specified
X.I key
Xare returned in the structure referenced by
X.IR data .
X.I Get
Xroutines return -1 on error (setting
X.IR errno ),
X0 on success, and 1 if the
X.I key
Xwas not in the file.
X.TP
Xput
XA pointer to a routine to store key/data pairs in the database.
X.IP
XThe parameter
X.I flag
Xmay be set to one of the following values:
X.RS
X.TP
XR_CURSOR
XReplace the key/data pair referenced by the cursor.
XThe cursor must have previously been initialized.
X.TP
XR_IAFTER
XAppend the data immediately after the data referenced by
X.IR key ,
Xcreating a new key/data pair.
XThe record number of the appended key/data pair is returned in the
X.I key
Xstructure.
X(Applicable only to the DB_RECNO access method.)
X.TP
XR_IBEFORE
XInsert the data immediately before the data referenced by
X.IR key ,
Xcreating a new key/data pair.
XThe record number of the inserted key/data pair is returned in the
X.I key
Xstructure.
X(Applicable only to the DB_RECNO access method.)
X.TP
XR_NOOVERWRITE
XEnter the new key/data pair only if the key does not previously exist.
X.TP
XR_SETCURSOR
XStore the key/data pair, setting or initializing the position of the
Xcursor to reference it.
X(Applicable only to the DB_BTREE and DB_RECNO access methods.)
X.RE
X.IP
XR_SETCURSOR is available only for the DB_BTREE and DB_RECNO access
Xmethods because it implies that the keys have an inherent order
Xwhich does not change.
X.IP
XR_IAFTER and R_IBEFORE are available only for the DB_RECNO
Xaccess method because they each imply that the access method is able to
Xcreate new keys.
XThis is only true if the keys are ordered and independent, record numbers
Xfor example.
X.IP
XThe default behavior of the
X.I put
Xroutines is to enter the new key/data pair, replacing any previously
Xexisting key.
X.IP
X.I Put
Xroutines return -1 on error (setting
X.IR errno ),
X0 on success, and 1 if the R_NOOVERWRITE
X.I flag
Xwas set and the key already exists in the file.
X.TP
Xseq
XA pointer to a routine which is the interface for sequential
Xretrieval from the database.
XThe address and length of the key are returned in the structure
Xreferenced by
X.IR key ,
Xand the address and length of the data are returned in the
Xstructure referenced
Xby
X.IR data .
X.IP
XSequential key/data pair retrieval may begin at any time, and the
Xposition of the ``cursor'' is not affected by calls to the
X.IR del ,
X.IR get ,
X.IR put ,
Xor
X.I sync
Xroutines.
XModifications to the database during a sequential scan will be reflected
Xin the scan, i.e. records inserted behind the cursor will not be returned
Xwhile records inserted in front of the cursor will be returned.
X.IP
XThe flag value
X.B must
Xbe set to one of the following values:
X.RS
X.TP
XR_CURSOR
XThe data associated with the specified key is returned.
XThis differs from the
X.I get
Xroutines in that it sets or initializes the cursor to the location of
Xthe key as well.
X(Note, for the DB_BTREE access method, the returned key is not necessarily an
Xexact match for the specified key.
XThe returned key is the smallest key greater than or equal to the specified
Xkey, permitting partial key matches and range searches.)
X.TP
XR_FIRST
XThe first key/data pair of the database is returned, and the cursor
Xis set or initialized to reference it.
X.TP
XR_LAST
XThe last key/data pair of the database is returned, and the cursor
Xis set or initialized to reference it.
X(Applicable only to the DB_BTREE and DB_RECNO access methods.)
X.TP
XR_NEXT
XRetrieve the key/data pair immediately after the cursor.
XIf the cursor is not yet set, this is the same as the R_FIRST flag.
X.TP
XR_PREV
XRetrieve the key/data pair immediately before the cursor.
XIf the cursor is not yet set, this is the same as the R_LAST flag.
X(Applicable only to the DB_BTREE and DB_RECNO access methods.)
X.RE
X.IP
XR_LAST and R_PREV are available only for the DB_BTREE and DB_RECNO
Xaccess methods because they each imply that the keys have an inherent
Xorder which does not change.
X.IP
X.I Seq
Xroutines return -1 on error (setting
X.IR errno ),
X0 on success and 1 if there are no key/data pairs less than or greater
Xthan the specified or current key.
XIf the DB_RECNO access method is being used, and if the database file
Xis a character special file and no complete key/data pairs are currently
Xavailable, the
X.I seq
Xroutines return 2.
X.TP
Xsync
XA pointer to a routine to flush any cached information to disk.
XIf the database is in memory only, the
X.I sync
Xroutine has no effect and will always succeed.
X.IP
XThe flag value may be set to the following value:
X.RS
X.TP
XR_RECNOSYNC
XIf the DB_RECNO access method is being used, this flag causes
Xthe sync routine to apply to the btree file which underlies the
Xrecno file, not the recno file itself.
X(See the
X.I bfname
Xfield of the
X.IR recno (3)
Xmanual page for more information.)
X.RE
X.IP
X.I Sync
Xroutines return -1 on error (setting
X.IR errno )
Xand 0 on success.
X.SH "KEY/DATA PAIRS"
XAccess to all file types is based on key/data pairs.
XBoth keys and data are represented by the following data structure:
X.PP
Xtypedef struct {
X.RS
Xvoid *data;
X.br
Xsize_t size;
X.RE
X} DBT;
X.PP
XThe elements of the DBT structure are defined as follows:
X.TP
Xdata
XA pointer to a byte string.
X.TP
Xsize
XThe length of the byte string.
X.PP
XKey and data byte strings may reference strings of essentially unlimited
Xlength although any two of them must fit into available memory at the same
Xtime.
XIt should be noted that the access methods provide no guarantees about
Xbyte string alignment.
X.SH ERRORS
XThe
X.I dbopen
Xroutine may fail and set
X.I errno
Xfor any of the errors specified for the library routines
X.IR open (2)
Xand
X.IR malloc (3)
Xor the following:
X.TP
X[EFTYPE]
XA file is incorrectly formatted.
X.TP
X[EINVAL]
XA parameter has been specified (hash function, pad byte etc.) that is
Xincompatible with the current file specification or which is not
Xmeaningful for the function (for example, use of the cursor without
Xprior initialization) or there is a mismatch between the version
Xnumber of file and the software.
X.PP
XThe
X.I close
Xroutines may fail and set
X.I errno
Xfor any of the errors specified for the library routines
X.IR close (2),
X.IR read (2),
X.IR write (2),
X.IR free (3),
Xor
X.IR fsync (2).
X.PP
XThe
X.IR del ,
X.IR get ,
X.I put
Xand
X.I seq
Xroutines may fail and set
X.I errno
Xfor any of the errors specified for the library routines
X.IR read (2),
X.IR write (2),
X.IR free (3)
Xor
X.IR malloc (3).
X.PP
XThe
X.I fd
Xroutines will fail and set
X.I errno
Xto ENOENT for in memory databases.
X.PP
XThe
X.I sync
Xroutines may fail and set
X.I errno
Xfor any of the errors specified for the library routine
X.IR fsync (2).
X.SH "SEE ALSO"
X.IR btree (3),
X.IR hash (3),
X.IR mpool (3),
X.IR recno (3)
X.SH BUGS
XThe typedef DBT is a mnemonic for ``data base thang'', and was used
Xbecause noone could think of a reasonable name that wasn't already used.
X.PP
XThe file descriptor interface is a kluge and will be deleted in a
Xfuture version of the interface.
X.PP
XNone of the access methods provide any form of concurrent access,
Xlocking, or transactions.
END_OF_FILE
if test 12751 -ne `wc -c <'man/dbopen.3'`; then
    echo shar: \"'man/dbopen.3'\" unpacked with wrong size!
fi
# end of 'man/dbopen.3'
fi
if test -f 'test/dbtest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test/dbtest.c'\"
else
echo shar: Extracting \"'test/dbtest.c'\" \(14197 characters\)
sed "s/^X//" >'test/dbtest.c' <<'END_OF_FILE'
X/*-
X * Copyright (c) 1992, 1993
X *	The Regents of the University of California.  All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#ifndef lint
Xstatic char copyright[] =
X"@(#) Copyright (c) 1992, 1993\n\
X	The Regents of the University of California.  All rights reserved.\n";
X#endif /* not lint */
X
X#ifndef lint
Xstatic char sccsid[] = "@(#)dbtest.c	8.1 (Berkeley) 6/4/93";
X#endif /* not lint */
X
X#include <sys/param.h>
X#include <sys/stat.h>
X
X#include <ctype.h>
X#include <errno.h>
X#include <fcntl.h>
X#include <limits.h>
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X#include <unistd.h>
X
X#include <db.h>
X
Xenum S { COMMAND, COMPARE, GET, PUT, REMOVE, SEQ, SEQFLAG, KEY, DATA };
X
Xvoid	 compare __P((DBT *, DBT *));
XDBTYPE	 dbtype __P((char *));
Xvoid	 dump __P((DB *, int));
Xvoid	 err __P((const char *, ...));
Xvoid	 get __P((DB *, DBT *));
Xvoid	 getdata __P((DB *, DBT *, DBT *));
Xvoid	 put __P((DB *, DBT *, DBT *));
Xvoid	 rem __P((DB *, DBT *));
Xvoid	*rfile __P((char *, size_t *));
Xvoid	 seq __P((DB *, DBT *));
Xu_int	 setflags __P((char *));
Xvoid	*setinfo __P((DBTYPE, char *));
Xvoid	 usage __P((void));
Xvoid	*xmalloc __P((char *, size_t));
X
XDBTYPE type;
Xvoid *infop;
Xu_long lineno;
Xu_int flags;
Xint ofd = STDOUT_FILENO;
X
XDB *XXdbp;				/* Global for gdb. */
X
Xint
Xmain(argc, argv)
X	int argc;
X	char *argv[];
X{
X	extern int optind;
X	extern char *optarg;
X	enum S command, state;
X	DB *dbp;
X	DBT data, key, keydata;
X	size_t len;
X	int ch;
X	char *fname, *infoarg, *p, buf[8 * 1024];
X
X	infoarg = NULL;
X	fname = NULL;
X	while ((ch = getopt(argc, argv, "f:i:o:")) != EOF)
X		switch(ch) {
X		case 'f':
X			fname = optarg;
X			break;
X		case 'i':
X			infoarg = optarg;
X			break;
X		case 'o':
X			if ((ofd = open(optarg,
X			    O_WRONLY|O_CREAT|O_TRUNC, 0666)) < 0)
X				err("%s: %s", optarg, strerror(errno));
X			break;
X		case '?':
X		default:
X			usage();
X		}
X	argc -= optind;
X	argv += optind;
X
X	if (argc != 2)
X		usage();
X
X	/* Set the type. */
X	type = dbtype(*argv++);
X
X	/* Open the descriptor file. */
X	if (freopen(*argv, "r", stdin) == NULL)
X		err("%s: %s", *argv, strerror(errno));
X
X	/* Set up the db structure as necessary. */
X	if (infoarg == NULL)
X		infop = NULL;
X	else
X		for (p = strtok(infoarg, ",\t "); p != NULL;
X		    p = strtok(0, ",\t "))
X			if (*p != '\0')
X				infop = setinfo(type, p);
X
X	/* Open the DB. */
X	if (fname == NULL) {
X		p = getenv("TMPDIR");
X		if (p == NULL)
X			p = "/var/tmp";
X		(void)sprintf(buf, "%s/__dbtest", p);
X		fname = buf;
X		(void)unlink(buf);
X	}
X	if ((dbp = dbopen(fname,
X	    O_CREAT | O_RDWR, S_IRUSR | S_IWUSR, type, infop)) == NULL)
X		err("dbopen: %s", strerror(errno));
X	XXdbp = dbp;
X
X	state = COMMAND;
X	for (lineno = 1;
X	    (p = fgets(buf, sizeof(buf), stdin)) != NULL; ++lineno) {
X		len = strlen(buf);
X		switch(*p) {
X		case 'c':			/* compare */
X			if (state != COMMAND)
X				err("line %lu: not expecting command", lineno);
X			state = KEY;
X			command = COMPARE;
X			break;
X		case 'e':			/* echo */
X			if (state != COMMAND)
X				err("line %lu: not expecting command", lineno);
X			/* Don't display the newline, if CR at EOL. */
X			if (p[len - 2] == '\r')
X				--len;
X			if (write(ofd, p + 1, len - 1) != len - 1)
X				err("write: %s", strerror(errno));
X			break;
X		case 'g':			/* get */
X			if (state != COMMAND)
X				err("line %lu: not expecting command", lineno);
X			state = KEY;
X			command = GET;
X			break;
X		case 'p':			/* put */
X			if (state != COMMAND)
X				err("line %lu: not expecting command", lineno);
X			state = KEY;
X			command = PUT;
X			break;
X		case 'r':			/* remove */
X			if (state != COMMAND)
X				err("line %lu: not expecting command", lineno);
X			state = KEY;
X			command = REMOVE;
X			break;
X		case 's':			/* seq */
X			if (state != COMMAND)
X				err("line %lu: not expecting command", lineno);
X			if (flags == R_CURSOR) {
X				state = KEY;
X				command = SEQ;
X			} else
X				seq(dbp, &key);
X			break;
X		case 'f':
X			flags = setflags(p + 1);
X			break;
X		case 'D':			/* data file */
X			if (state != DATA)
X				err("line %lu: not expecting data", lineno);
X			data.data = rfile(p + 1, &data.size);
X			goto ldata;
X		case 'd':			/* data */
X			if (state != DATA)
X				err("line %lu: not expecting data", lineno);
X			data.data = xmalloc(p + 1, len - 1);
X			data.size = len - 1;
Xldata:			switch(command) {
X			case COMPARE:
X				compare(&keydata, &data);
X				break;
X			case PUT:
X				put(dbp, &key, &data);
X				break;
X			default:
X				err("line %lu: command doesn't take data",
X				    lineno);
X			}
X			if (type != DB_RECNO)
X				free(key.data);
X			free(data.data);
X			state = COMMAND;
X			break;
X		case 'K':			/* key file */
X			if (state != KEY)
X				err("line %lu: not expecting a key", lineno);
X			if (type == DB_RECNO)
X				err("line %lu: 'K' not available for recno",
X				    lineno);
X			key.data = rfile(p + 1, &key.size);
X			goto lkey;
X		case 'k':			/* key */
X			if (state != KEY)
X				err("line %lu: not expecting a key", lineno);
X			if (type == DB_RECNO) {
X				static recno_t recno;
X				recno = strtol(p + 1, NULL, 0);
X				key.data = &recno;
X				key.size = sizeof(recno);
X			} else {
X				key.data = xmalloc(p + 1, len - 1);
X				key.size = len - 1;
X			}
Xlkey:			switch(command) {
X			case COMPARE:
X				getdata(dbp, &key, &keydata);
X				state = DATA;
X				break;
X			case GET:
X				get(dbp, &key);
X				if (type != DB_RECNO)
X					free(key.data);
X				state = COMMAND;
X				break;
X			case PUT:
X				state = DATA;
X				break;
X			case REMOVE:
X				rem(dbp, &key);
X				if (type != DB_RECNO)
X					free(key.data);
X				state = COMMAND;
X				break;
X			case SEQ:
X				seq(dbp, &key);
X				if (type != DB_RECNO)
X					free(key.data);
X				state = COMMAND;
X				break;
X			default:
X				err("line %lu: command doesn't take a key",
X				    lineno);
X			}
X			break;
X		case 'o':
X			dump(dbp, p[1] == 'r');
X			break;
X		default:
X			err("line %lu: %s: unknown command character",
X			    p, lineno);
X		}
X	}
X	if (dbp->close(dbp))
X		err("db->close: %s", strerror(errno));
X	(void)close(ofd);
X	exit(0);
X}
X
X#define	NOOVERWRITE	"put failed, would overwrite key\n"
X#define	NOSUCHKEY	"get failed, no such key\n"
X
Xvoid
Xcompare(db1, db2)
X	DBT *db1, *db2;
X{
X	register size_t len;
X	register u_char *p1, *p2;
X
X	if (db1->size != db2->size)
X		printf("compare failed: key->data len %lu != data len %lu\n",
X		    db1->size, db2->size);
X
X	len = MIN(db1->size, db2->size);
X	for (p1 = db1->data, p2 = db2->data; len--;)
X		if (*p1++ != *p2++) {
X			printf("compare failed at offset %d\n",
X			    p1 - (u_char *)db1->data);
X			break;
X		}
X}
X
Xvoid
Xget(dbp, kp)
X	DB *dbp;
X	DBT *kp;
X{
X	DBT data;
X
X	switch(dbp->get(dbp, kp, &data, flags)) {
X	case 0:
X		(void)write(ofd, data.data, data.size);
X		break;
X	case -1:
X		err("line %lu: get: %s", lineno, strerror(errno));
X		/* NOTREACHED */
X	case 1:
X		(void)write(ofd, NOSUCHKEY, sizeof(NOSUCHKEY) - 1);
X		(void)fprintf(stderr, "%d: %.*s: %s\n", 
X		    lineno, kp->size, kp->data, NOSUCHKEY);
X		break;
X	}
X}
X
Xvoid
Xgetdata(dbp, kp, dp)
X	DB *dbp;
X	DBT *kp, *dp;
X{
X	switch(dbp->get(dbp, kp, dp, flags)) {
X	case 0:
X		return;
X	case -1:
X		err("line %lu: getdata: %s", lineno, strerror(errno));
X		/* NOTREACHED */
X	case 1:
X		err("line %lu: get failed, no such key", lineno);
X		/* NOTREACHED */
X	}
X}
X
Xvoid
Xput(dbp, kp, dp)
X	DB *dbp;
X	DBT *kp, *dp;
X{
X	switch(dbp->put(dbp, kp, dp, flags)) {
X	case 0:
X		break;
X	case -1:
X		err("line %lu: put: %s", lineno, strerror(errno));
X		/* NOTREACHED */
X	case 1:
X		(void)write(ofd, NOOVERWRITE, sizeof(NOOVERWRITE) - 1);
X		break;
X	}
X}
X
Xvoid
Xrem(dbp, kp)
X	DB *dbp;
X	DBT *kp;
X{
X	switch(dbp->del(dbp, kp, flags)) {
X	case 0:
X		break;
X	case -1:
X		err("line %lu: get: %s", lineno, strerror(errno));
X		/* NOTREACHED */
X	case 1:
X		(void)write(ofd, NOSUCHKEY, sizeof(NOSUCHKEY) - 1);
X		break;
X	}
X}
X
Xvoid
Xseq(dbp, kp)
X	DB *dbp;
X	DBT *kp;
X{
X	DBT data;
X
X	switch(dbp->seq(dbp, kp, &data, flags)) {
X	case 0:
X		(void)write(ofd, data.data, data.size);
X		break;
X	case -1:
X		err("line %lu: seq: %s", lineno, strerror(errno));
X		/* NOTREACHED */
X	case 1:
X		(void)write(ofd, NOSUCHKEY, sizeof(NOSUCHKEY) - 1);
X		break;
X	}
X}
X
Xvoid
Xdump(dbp, rev)
X	DB *dbp;
X	int rev;
X{
X	DBT key, data;
X	int flags, nflags;
X
X	if (rev) {
X		flags = R_LAST;
X		nflags = R_PREV;
X	} else {
X		flags = R_FIRST;
X		nflags = R_NEXT;
X	}
X	for (;; flags = nflags)
X		switch(dbp->seq(dbp, &key, &data, flags)) {
X		case 0:
X			(void)write(ofd, data.data, data.size);
X			break;
X		case 1:
X			goto done;
X		case -1:
X			err("line %lu: (dump) seq: %s",
X			    lineno, strerror(errno));
X			/* NOTREACHED */
X		}
Xdone:	return;
X}
X	
Xu_int
Xsetflags(s)
X	char *s;
X{
X	char *p;
X
X	for (; isspace(*s); ++s);
X	if (*s == '\n')
X		return (0);
X	if ((p = index(s, '\n')) != NULL)
X		*p = '\0';
X	if (!strcmp(s, "R_CURSOR"))
X		return (R_CURSOR);
X	if (!strcmp(s, "R_FIRST"))
X		return (R_FIRST);
X	if (!strcmp(s, "R_IAFTER"))
X		return (R_IAFTER);
X	if (!strcmp(s, "R_IBEFORE"))
X		return (R_IBEFORE);
X	if (!strcmp(s, "R_LAST"))
X		return (R_LAST);
X	if (!strcmp(s, "R_NEXT"))
X		return (R_NEXT);
X	if (!strcmp(s, "R_NOOVERWRITE"))
X		return (R_NOOVERWRITE);
X	if (!strcmp(s, "R_PREV"))
X		return (R_PREV);
X	if (!strcmp(s, "R_SETCURSOR"))
X		return (R_SETCURSOR);
X	err("line %lu: %s: unknown flag", lineno, s);
X	/* NOTREACHED */
X}
X	
XDBTYPE
Xdbtype(s)
X	char *s;
X{
X	if (!strcmp(s, "btree"))
X		return (DB_BTREE);
X	if (!strcmp(s, "hash"))
X		return (DB_HASH);
X	if (!strcmp(s, "recno"))
X		return (DB_RECNO);
X	err("%s: unknown type (use btree, hash or recno)", s);
X	/* NOTREACHED */
X}
X
Xvoid *
Xsetinfo(type, s)
X	DBTYPE type;
X	char *s;
X{
X	static BTREEINFO ib;
X	static HASHINFO ih;
X	static RECNOINFO rh;
X	char *eq;
X
X	if ((eq = index(s, '=')) == NULL)
X		err("%s: illegal structure set statement", s);
X	*eq++ = '\0';
X	if (!isdigit(*eq))
X		err("%s: structure set statement must be a number", s);
X		
X	switch(type) {
X	case DB_BTREE:
X		if (!strcmp("flags", s)) {
X			ib.flags = strtoul(eq, NULL, 0);
X			return (&ib);
X		}
X		if (!strcmp("cachesize", s)) {
X			ib.cachesize = strtoul(eq, NULL, 0);
X			return (&ib);
X		}
X		if (!strcmp("maxkeypage", s)) {
X			ib.maxkeypage = strtoul(eq, NULL, 0);
X			return (&ib);
X		}
X		if (!strcmp("minkeypage", s)) {
X			ib.minkeypage = strtoul(eq, NULL, 0);
X			return (&ib);
X		}
X		if (!strcmp("lorder", s)) {
X			ib.lorder = strtoul(eq, NULL, 0);
X			return (&ib);
X		}
X		if (!strcmp("psize", s)) {
X			ib.psize = strtoul(eq, NULL, 0);
X			return (&ib);
X		}
X		break;
X	case DB_HASH:
X		if (!strcmp("bsize", s)) {
X			ih.bsize = strtoul(eq, NULL, 0);
X			return (&ih);
X		}
X		if (!strcmp("ffactor", s)) {
X			ih.ffactor = strtoul(eq, NULL, 0);
X			return (&ih);
X		}
X		if (!strcmp("nelem", s)) {
X			ih.nelem = strtoul(eq, NULL, 0);
X			return (&ih);
X		}
X		if (!strcmp("cachesize", s)) {
X			ih.cachesize = strtoul(eq, NULL, 0);
X			return (&ih);
X		}
X		if (!strcmp("lorder", s)) {
X			ih.lorder = strtoul(eq, NULL, 0);
X			return (&ih);
X		}
X		break;
X	case DB_RECNO:
X		if (!strcmp("flags", s)) {
X			rh.flags = strtoul(eq, NULL, 0);
X			return (&rh);
X		}
X		if (!strcmp("cachesize", s)) {
X			rh.cachesize = strtoul(eq, NULL, 0);
X			return (&rh);
X		}
X		if (!strcmp("lorder", s)) {
X			rh.lorder = strtoul(eq, NULL, 0);
X			return (&rh);
X		}
X		if (!strcmp("reclen", s)) {
X			rh.reclen = strtoul(eq, NULL, 0);
X			return (&rh);
X		}
X		if (!strcmp("bval", s)) {
X			rh.bval = strtoul(eq, NULL, 0);
X			return (&rh);
X		}
X		if (!strcmp("psize", s)) {
X			rh.psize = strtoul(eq, NULL, 0);
X			return (&rh);
X		}
X		break;
X	}
X	err("%s: unknown structure value", s);
X	/* NOTREACHED */
X}
X
Xvoid *
Xrfile(name, lenp)
X	char *name;
X	size_t *lenp;
X{
X	struct stat sb;
X	void *p;
X	int fd;
X	char *np;
X
X	for (; isspace(*name); ++name);
X	if ((np = index(name, '\n')) != NULL)
X		*np = '\0';
X	if ((fd = open(name, O_RDONLY, 0)) < 0 ||
X	    fstat(fd, &sb))
X		err("%s: %s\n", name, strerror(errno));
X	if (sb.st_size > (off_t)SIZE_T_MAX)
X		err("%s: %s\n", name, strerror(E2BIG));
X	if ((p = malloc((u_int)sb.st_size)) == NULL)
X		err("%s", strerror(errno));
X	(void)read(fd, p, (int)sb.st_size);
X	*lenp = sb.st_size;
X	(void)close(fd);
X	return (p);
X}
X
Xvoid *
Xxmalloc(text, len)
X	char *text;
X	size_t len;
X{
X	void *p;
X
X	if ((p = malloc(len)) == NULL)
X		err("%s", strerror(errno));
X	memmove(p, text, len);
X	return (p);
X}
X
Xvoid
Xusage()
X{
X	(void)fprintf(stderr,
X	    "usage: dbtest [-f file] [-i info] [-o file] type script\n");
X	exit(1);
X}
X
X#if __STDC__
X#include <stdarg.h>
X#else
X#include <varargs.h>
X#endif
X
Xvoid
X#if __STDC__
Xerr(const char *fmt, ...)
X#else
Xerr(fmt, va_alist)
X	char *fmt;
X        va_dcl
X#endif
X{
X	va_list ap;
X#if __STDC__
X	va_start(ap, fmt);
X#else
X	va_start(ap);
X#endif
X	(void)fprintf(stderr, "dbtest: ");
X	(void)vfprintf(stderr, fmt, ap);
X	va_end(ap);
X	(void)fprintf(stderr, "\n");
X	exit(1);
X	/* NOTREACHED */
X}
END_OF_FILE
if test 14197 -ne `wc -c <'test/dbtest.c'`; then
    echo shar: \"'test/dbtest.c'\" unpacked with wrong size!
fi
# end of 'test/dbtest.c'
fi
if test -f 'test/run.test' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test/run.test'\"
else
echo shar: Extracting \"'test/run.test'\" \(13894 characters\)
sed "s/^X//" >'test/run.test' <<'END_OF_FILE'
X#!/bin/sh -
X#
X#	@(#)run.test	8.1 (Berkeley) 6/4/93
X#
X
X# db regression tests
X
Xmain()
X{
X	DICT=/usr/share/dict/words
X	PROG=obj/dbtest
X	TMP1=t1
X	TMP2=t2
X	TMP3=t3
X
X	test1
X	test2
X	test3
X	test4
X	test5
X	test6
X	test7
X	test8
X	test9
X	test10
X	test11
X	test12
X	test13
X	test20
X	rm -f $TMP1 $TMP2 $TMP3
X	exit 0
X}
X
X# Take the first hundred entries in the dictionary, and make them
X# be key/data pairs.
Xtest1()
X{
X	printf "Test 1: btree, hash: small key, small data pairs\n"
X	sed 200q $DICT > $TMP1
X	for type in btree hash; do
X		rm -f $TMP2 $TMP3
X		for i in `sed 200q $DICT`; do
X			printf "p\nk%s\nd%s\ng\nk%s\n" $i $i $i
X		done > $TMP2
X		$PROG -o $TMP3 $type $TMP2
X		if (cmp -s $TMP1 $TMP3) ; then :
X		else
X			printf "test1: type %s: failed\n" $type
X			exit 1
X		fi
X	done
X	printf "Test 1: recno: small key, small data pairs\n"
X	rm -f $TMP2 $TMP3
X	sed 200q $DICT |
X	awk '{ 
X		++i;
X		printf("p\nk%d\nd%s\ng\nk%d\n", i, $0, i);
X	}' > $TMP2
X	$PROG -o $TMP3 recno $TMP2
X	if (cmp -s $TMP1 $TMP3) ; then :
X	else
X		printf "test1: type recno: failed\n"
X		exit 1
X	fi
X}
X
X# Take the first 200 entries in the dictionary, and give them
X# each a medium size data entry.
Xtest2()
X{
X	printf "Test 2: btree, hash: small key, medium data pairs\n"
X	mdata=abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz
X	echo $mdata |
X	awk '{ for (i = 1; i < 201; ++i) print $0 }' > $TMP1
X	for type in hash btree; do
X		rm -f $TMP2 $TMP3
X		for i in `sed 200q $DICT`; do
X			printf "p\nk%s\nd%s\ng\nk%s\n" $i $mdata $i
X		done > $TMP2
X		$PROG -o $TMP3 $type $TMP2
X		if (cmp -s $TMP1 $TMP3) ; then :
X		else
X			printf "test2: type %s: failed\n" $type
X			exit 1
X		fi
X	done
X	printf "Test 2: recno: small key, medium data pairs\n"
X	rm -f $TMP2 $TMP3
X	echo $mdata | 
X	awk '{  for (i = 1; i < 201; ++i)
X		printf("p\nk%d\nd%s\ng\nk%d\n", i, $0, i);
X	}' > $TMP2
X	$PROG -o $TMP3 recno $TMP2
X	if (cmp -s $TMP1 $TMP3) ; then :
X	else
X		printf "test2: type recno: failed\n"
X		exit 1
X	fi
X}
X
X# Insert the programs in /bin with their paths as their keys.
Xtest3()
X{
X	printf "Test 3: hash: small key, big data pairs\n"
X	rm -f $TMP1
X	(find /bin -type f -print | xargs cat) > $TMP1
X	for type in hash; do
X		rm -f $TMP2 $TMP3
X		for i in `find /bin -type f -print`; do
X			printf "p\nk%s\nD%s\ng\nk%s\n" $i $i $i
X		done > $TMP2
X		$PROG -o $TMP3 $type $TMP2
X		if (cmp -s $TMP1 $TMP3) ; then :
X		else
X			printf "test3: %s: page size %d: failed\n" \
X			    $type $psize
X			exit 1
X		fi
X	done
X	printf "Test 3: btree: small key, big data pairs\n"
X	for psize in 512 16384 65536; do
X		printf "\tpage size %d\n" $psize
X		for type in btree; do
X			rm -f $TMP2 $TMP3
X			for i in `find /bin -type f -print`; do
X				printf "p\nk%s\nD%s\ng\nk%s\n" $i $i $i
X			done > $TMP2
X			$PROG -i psize=$psize -o $TMP3 $type $TMP2
X			if (cmp -s $TMP1 $TMP3) ; then :
X			else
X				printf "test3: %s: page size %d: failed\n" \
X				    $type $psize
X				exit 1
X			fi
X		done
X	done
X	printf "Test 3: recno: big data pairs\n"
X	rm -f $TMP2 $TMP3
X	find /bin -type f -print | 
X	awk '{
X		++i;
X		printf("p\nk%d\nD%s\ng\nk%d\n", i, $0, i);
X	}' > $TMP2
X	for psize in 512 16384 65536; do
X		printf "\tpage size %d\n" $psize
X		$PROG -i psize=$psize -o $TMP3 recno $TMP2
X		if (cmp -s $TMP1 $TMP3) ; then :
X		else
X			printf "test3: recno: page size %d: failed\n" $psize
X			exit 1
X		fi
X	done
X}
X
X# Do random recno entries.
Xtest4()
X{
X	printf "Test 4: recno: random entries\n"
X	echo "abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg" |
X	awk '{
X		for (i = 37; i <= 37 + 88 * 17; i += 17)
X			printf("input key %d: %.*s\n", i, i % 41, $0);
X		for (i = 1; i <= 15; ++i)
X			printf("input key %d: %.*s\n", i, i % 41, $0);
X		for (i = 19234; i <= 19234 + 61 * 27; i += 27)
X			printf("input key %d: %.*s\n", i, i % 41, $0);
X		exit
X	}' > $TMP1
X	rm -f TMP2 $TMP3
X	cat $TMP1 |
X	awk 'BEGIN {
X			i = 37;
X			incr = 17;
X		}
X		{
X			printf("p\nk%d\nd%s\n", i, $0);
X			if (i == 19234 + 61 * 27)
X				exit;
X			if (i == 37 + 88 * 17) {
X				i = 1;
X				incr = 1;
X			} else if (i == 15) {
X				i = 19234;
X				incr = 27;
X			} else
X				i += incr;
X		}
X		END {
X			for (i = 37; i <= 37 + 88 * 17; i += 17)
X				printf("g\nk%d\n", i);
X			for (i = 1; i <= 15; ++i)
X				printf("g\nk%d\n", i);
X			for (i = 19234; i <= 19234 + 61 * 27; i += 27)
X				printf("g\nk%d\n", i);
X		}' > $TMP2
X	$PROG -o $TMP3 recno $TMP2
X	if (cmp -s $TMP1 $TMP3) ; then :
X	else
X		printf "test4: type recno: failed\n"
X		exit 1
X	fi
X}
X
X# Do reverse order recno entries.
Xtest5()
X{
X	printf "Test 5: recno: reverse order entries\n"
X	echo "abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg" |
X	awk ' {
X		for (i = 1500; i; --i)
X			printf("input key %d: %.*s\n", i, i % 34, $0);
X		exit;
X	}' > $TMP1
X	rm -f TMP2 $TMP3
X	cat $TMP1 |
X	awk 'BEGIN {
X			i = 1500;
X		}
X		{
X			printf("p\nk%d\nd%s\n", i, $0);
X			--i;
X		}
X		END {
X			for (i = 1500; i; --i) 
X				printf("g\nk%d\n", i);
X		}' > $TMP2
X	$PROG -o $TMP3 recno $TMP2
X	if (cmp -s $TMP1 $TMP3) ; then :
X	else
X		printf "test5: type recno: failed\n"
X		exit 1
X	fi
X}
X		
X# Do alternating order recno entries.
Xtest6()
X{
X	printf "Test 6: recno: alternating order entries\n"
X	echo "abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg" |
X	awk ' {
X		for (i = 1; i < 1200; i += 2)
X			printf("input key %d: %.*s\n", i, i % 34, $0);
X		for (i = 2; i < 1200; i += 2)
X			printf("input key %d: %.*s\n", i, i % 34, $0);
X		exit;
X	}' > $TMP1
X	rm -f TMP2 $TMP3
X	cat $TMP1 |
X	awk 'BEGIN {
X			i = 1;
X			even = 0;
X		}
X		{
X			printf("p\nk%d\nd%s\n", i, $0);
X			i += 2;
X			if (i >= 1200) {
X				if (even == 1)
X					exit;
X				even = 1;
X				i = 2;
X			}
X		}
X		END {
X			for (i = 1; i < 1200; ++i) 
X				printf("g\nk%d\n", i);
X		}' > $TMP2
X	$PROG -o $TMP3 recno $TMP2
X	sort -o $TMP1 $TMP1
X	sort -o $TMP3 $TMP3
X	if (cmp -s $TMP1 $TMP3) ; then :
X	else
X		printf "test6: type recno: failed\n"
X		exit 1
X	fi
X}
X
X# Delete cursor record
Xtest7()
X{
X	printf "Test 7: btree, recno: delete cursor record\n"
X	echo "abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg" |
X	awk '{
X		for (i = 1; i <= 120; ++i)
X			printf("%05d: input key %d: %s\n", i, i, $0);
X		printf("%05d: input key %d: %s\n", 120, 120, $0);
X		printf("get failed, no such key\n");
X		printf("%05d: input key %d: %s\n", 1, 1, $0);
X		printf("%05d: input key %d: %s\n", 2, 2, $0);
X		exit;
X	}' > $TMP1
X	rm -f TMP2 $TMP3
X
X	for type in btree recno; do
X		cat $TMP1 |
X		awk '{
X			if (i == 120)
X				exit;
X			printf("p\nk%d\nd%s\n", ++i, $0);
X		}
X		END {
X			printf("fR_NEXT\n");
X			for (i = 1; i <= 120; ++i)
X				printf("s\n");
X			printf("fR_CURSOR\ns\nk120\n");
X			printf("r\nk120\n");
X			printf("fR_NEXT\ns\n");
X			printf("fR_CURSOR\ns\nk1\n");
X			printf("r\nk1\n");
X			printf("fR_FIRST\ns\n");
X		}' > $TMP2
X		$PROG -o $TMP3 recno $TMP2
X		if (cmp -s $TMP1 $TMP3) ; then :
X		else
X			printf "test7: type $type: failed\n"
X			exit 1
X		fi
X	done
X}
X
X# Make sure that overflow pages are reused.
Xtest8()
X{
X	printf "Test 8: btree, hash: repeated small key, big data pairs\n"
X	rm -f $TMP1
X	awk 'BEGIN {
X		for (i = 1; i <= 10; ++i) {
X			printf("p\nkkey1\nD/bin/sh\n");
X			printf("p\nkkey2\nD/bin/csh\n");
X			if (i % 8 == 0) {
X				printf("c\nkkey2\nD/bin/csh\n");
X				printf("c\nkkey1\nD/bin/sh\n");
X				printf("e\t%d of 10 (comparison)\r\n", i);
X			} else
X				printf("e\t%d of 10             \r\n", i);
X			printf("r\nkkey1\nr\nkkey2\n");
X		}
X		printf("e\n");
X		printf("eend of test8 run\n");
X	}' > $TMP1
X	$PROG btree $TMP1
X	$PROG hash $TMP1
X	# No explicit test for success.
X}
X
X# Test btree duplicate keys
Xtest9()
X{
X	printf "Test 9: btree: duplicate keys\n"
X	echo "abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg" |
X	awk '{
X		for (i = 1; i <= 543; ++i)
X			printf("%05d: input key %d: %s\n", i, i, $0);
X		exit;
X	}' > $TMP1
X	rm -f TMP2 $TMP3
X
X	for type in btree; do
X		cat $TMP1 | 
X		awk '{
X			if (i++ % 2)
X				printf("p\nkduplicatekey\nd%s\n", $0);
X			else
X				printf("p\nkunique%dkey\nd%s\n", i, $0);
X		}
X		END {
X				printf("o\n");
X		}' > $TMP2
X		$PROG -iflags=1 -o $TMP3 $type $TMP2
X		sort -o $TMP3 $TMP3
X		if (cmp -s $TMP1 $TMP3) ; then :
X		else
X			printf "test9: type $type: failed\n"
X			exit 1
X		fi
X	done
X}
X
X# Test use of cursor flags without initialization
Xtest10()
X{
X	printf "Test 10: btree, recno: test cursor flag use\n"
X	echo "abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg" |
X	awk '{
X		for (i = 1; i <= 20; ++i)
X			printf("%05d: input key %d: %s\n", i, i, $0);
X		exit;
X	}' > $TMP1
X	rm -f TMP2 $TMP3
X
X	# Test that R_CURSOR doesn't succeed before cursor initialized
X	for type in btree recno; do
X		cat $TMP1 |
X		awk '{
X			if (i == 10)
X				exit;
X			printf("p\nk%d\nd%s\n", ++i, $0);
X		}
X		END {
X			printf("fR_CURSOR\nr\nk1\n");
X			printf("eR_CURSOR SHOULD HAVE FAILED\n");
X		}' > $TMP2
X		$PROG -o $TMP3 $type $TMP2 > /dev/null 2>&1
X		if [ -s $TMP3 ] ; then
X			printf "Test 10: delete: R_CURSOR SHOULD HAVE FAILED\n"
X			exit 1
X		fi
X	done
X	for type in btree recno; do
X		cat $TMP1 |
X		awk '{
X			if (i == 10)
X				exit;
X			printf("p\nk%d\nd%s\n", ++i, $0);
X		}
X		END {
X			printf("fR_CURSOR\np\nk1\ndsome data\n");
X			printf("eR_CURSOR SHOULD HAVE FAILED\n");
X		}' > $TMP2
X		$PROG -o $TMP3 $type $TMP2 > /dev/null 2>&1
X		if [ -s $TMP3 ] ; then
X			printf "Test 10: put: R_CURSOR SHOULD HAVE FAILED\n"
X			exit 1
X		fi
X	done
X}
X
X# Test insert in reverse order.
Xtest11()
X{
X	printf "Test 11: recno: reverse order insert\n"
X	echo "abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg" |
X	awk '{
X		for (i = 1; i <= 779; ++i)
X			printf("%05d: input key %d: %s\n", i, i, $0);
X		exit;
X	}' > $TMP1
X	rm -f TMP2 $TMP3
X
X	for type in recno; do
X		cat $TMP1 |
X		awk '{
X			if (i == 0) {
X				i = 1;
X				printf("p\nk1\nd%s\n", $0);
X				printf("%s\n", "fR_IBEFORE");
X			} else
X				printf("p\nk1\nd%s\n", $0);
X		}
X		END {
X				printf("or\n");
X		}' > $TMP2
X		$PROG -o $TMP3 $type $TMP2
X		if (cmp -s $TMP1 $TMP3) ; then :
X		else
X			printf "test11: type $type: failed\n"
X			exit 1
X		fi
X	done
X}
X
X# Take the first 20000 entries in the dictionary, reverse them, and give
X# them each a small size data entry.  Use a small page size to make sure
X# the btree split code gets hammered.
Xtest12()
X{
X	printf "Test 12: btree: lots of keys, small page size\n"
X	mdata=abcdefghijklmnopqrstuvwxy
X	echo $mdata |
X	awk '{ for (i = 1; i < 20001; ++i) print $0 }' > $TMP1
X	for type in btree; do
X		rm -f $TMP2 $TMP3
X		for i in `sed 20000q $DICT | rev`; do
X			printf "p\nk%s\nd%s\ng\nk%s\n" $i $mdata $i
X		done > $TMP2
X		$PROG -i psize=512 -o $TMP3 $type $TMP2
X		if (cmp -s $TMP1 $TMP3) ; then :
X		else
X			printf "test12: type %s: failed\n" $type
X			exit 1
X		fi
X	done
X}
X
X# Test different byte orders.
Xtest13()
X{
X	printf "Test 13: btree, hash: differing byte orders\n"
X	sed 50q $DICT > $TMP1
X	for order in 1234 4321; do
X		for type in btree hash; do
X			rm -f byte.file $TMP2 $TMP3
X			for i in `sed 50q $DICT`; do
X				printf "p\nk%s\nd%s\ng\nk%s\n" $i $i $i
X			done > $TMP2
X			$PROG -ilorder=$order -f byte.file -o $TMP3 $type $TMP2
X			if (cmp -s $TMP1 $TMP3) ; then :
X			else
X				printf "test13: %s/%s put failed\n" $type $order
X				exit 1
X			fi
X			for i in `sed 50q $DICT`; do
X				printf "g\nk%s\n" $i
X			done > $TMP2
X			$PROG -ilorder=$order -f byte.file -o $TMP3 $type $TMP2
X			if (cmp -s $TMP1 $TMP3) ; then :
X			else
X				printf "test13: %s/%s get failed\n" $type $order
X				exit 1
X			fi
X		done
X	done
X	rm -f byte.file
X}
X
X# Try a variety of bucketsizes and fill factors for hashing
Xtest20()
X{
X	printf\
X    "Test 20: hash: bucketsize, fill factor; nelem 25000 cachesize 65536\n"
X	awk 'BEGIN {
X		for (i = 1; i <= 10000; ++i)
X			printf("%.*s\n", i % 34,
X		    "abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg");
X	}' > $TMP1
X	sed 10000q $DICT |
X	awk '{
X		++i;
X		printf("p\nk%s\nd%.*s\n", $0, i % 34,
X		    "abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg");
X	}' > $TMP2
X	sed 10000q $DICT |
X	awk '{
X		++i;
X		printf("g\nk%s\n", $0);
X	}' >> $TMP2
X	bsize=256
X	for ffactor in 11 14 21; do
X		printf "\tbucketsize %d, fill factor %d\n" $bsize $ffactor
X		$PROG -o$TMP3 \
X		    -ibsize=$bsize,ffactor=$ffactor,nelem=25000,cachesize=65536\
X		    hash $TMP2
X		if (cmp -s $TMP1 $TMP3) ; then :
X		else
X			printf "test20: type hash:\
Xbsize=$bsize ffactor=$ffactor nelem=25000 cachesize=65536 failed\n"
X			exit 1
X		fi
X	done
X	bsize=512
X	for ffactor in 21 28 43; do
X		printf "\tbucketsize %d, fill factor %d\n" $bsize $ffactor
X		$PROG -o$TMP3 \
X		    -ibsize=$bsize,ffactor=$ffactor,nelem=25000,cachesize=65536\
X		    hash $TMP2
X		if (cmp -s $TMP1 $TMP3) ; then :
X		else
X			printf "test20: type hash:\
Xbsize=$bsize ffactor=$ffactor nelem=25000 cachesize=65536 failed\n"
X			exit 1
X		fi
X	done
X	bsize=1024
X	for ffactor in 43 57 85; do
X		printf "\tbucketsize %d, fill factor %d\n" $bsize $ffactor
X		$PROG -o$TMP3 \
X		    -ibsize=$bsize,ffactor=$ffactor,nelem=25000,cachesize=65536\
X		    hash $TMP2
X		if (cmp -s $TMP1 $TMP3) ; then :
X		else
X			printf "test20: type hash:\
Xbsize=$bsize ffactor=$ffactor nelem=25000 cachesize=65536 failed\n"
X			exit 1
X		fi
X	done
X	bsize=2048
X	for ffactor in 85 114 171; do
X		printf "\tbucketsize %d, fill factor %d\n" $bsize $ffactor
X		$PROG -o$TMP3 \
X		    -ibsize=$bsize,ffactor=$ffactor,nelem=25000,cachesize=65536\
X		    hash $TMP2
X		if (cmp -s $TMP1 $TMP3) ; then :
X		else
X			printf "test20: type hash:\
Xbsize=$bsize ffactor=$ffactor nelem=25000 cachesize=65536 failed\n"
X			exit 1
X		fi
X	done
X	bsize=4096
X	for ffactor in 171 228 341; do
X		printf "\tbucketsize %d, fill factor %d\n" $bsize $ffactor
X		$PROG -o$TMP3 \
X		    -ibsize=$bsize,ffactor=$ffactor,nelem=25000,cachesize=65536\
X		    hash $TMP2
X		if (cmp -s $TMP1 $TMP3) ; then :
X		else
X			printf "test20: type hash:\
Xbsize=$bsize ffactor=$ffactor nelem=25000 cachesize=65536 failed\n"
X			exit 1
X		fi
X	done
X	bsize=8192
X	for ffactor in 341 455 683; do
X		printf "\tbucketsize %d, fill factor %d\n" $bsize $ffactor
X		$PROG -o$TMP3 \
X		    -ibsize=$bsize,ffactor=$ffactor,nelem=25000,cachesize=65536\
X		    hash $TMP2
X		if (cmp -s $TMP1 $TMP3) ; then :
X		else
X			printf "test20: type hash:\
Xbsize=$bsize ffactor=$ffactor nelem=25000 cachesize=65536 failed\n"
X			exit 1
X		fi
X	done
X}
X
Xmain
END_OF_FILE
if test 13894 -ne `wc -c <'test/run.test'`; then
    echo shar: \"'test/run.test'\" unpacked with wrong size!
fi
# end of 'test/run.test'
fi
echo shar: End of archive 5 \(of 9\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 9 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
