Newsgroups: comp.sources.unix
From: ross@zooid.guild.org (Ross Ridge)
Subject: v26i078: mytinfo - a replacement for terminfo and termcap, Part02/03
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: ross@zooid.guild.org (Ross Ridge)
Posting-Number: Volume 26, Issue 78
Archive-Name: mytinfo/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 3)."
# Contents:  DIFFS-moderator INSTALL Makefile cap_list findterm.c
#   gettcap.c gettinfo.c qsort.c sprintf.c tcapconv.c ttest.c tty.c
# Wrapped by vixie@cognition.pa.dec.com on Sun Dec 27 14:45:19 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'DIFFS-moderator' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'DIFFS-moderator'\"
else
echo shar: Extracting \"'DIFFS-moderator'\" \(5496 characters\)
sed "s/^X//" >'DIFFS-moderator' <<'END_OF_FILE'
These were the changes I made to this package to make it easier to build
and install.  The files I edited are present as *.orig.  --vix, 27dec92
X
Only in ../../../New/mytinfo: MANIFEST.BAK
diff -r -c ./Makefile ../../../New/mytinfo/Makefile
X*** ./Makefile	Sun Dec 27 14:14:24 1992
X--- ../../../New/mytinfo/Makefile	Fri Jul 10 03:42:25 1992
X***************
X*** 12,22 ****
X  
X  SHELL = /bin/sh
X  
X- DESTROOT =
X- DESTPATH = $(DESTROOT)/usr/local
X- DESTLIB = $(DESTPATH)/lib
X- DESTINC = $(DESTPATH)/include
X- 
X  #
X  # Your generic Unix C compiler.
X  #
X--- 12,17 ----
X***************
X*** 45,51 ****
X  #
X  #RANLIB = :
X  
X! LINKLIB = libmytinfo.a
X  OTHERLIB =
X  #
X  # Set LINKLIB and OTHERLIB to libmytinfo.so for ELF dynamic libs.
X--- 40,46 ----
X  #
X  #RANLIB = :
X  
X! LINKLIB = mytinfo.a
X  OTHERLIB =
X  #
X  # Set LINKLIB and OTHERLIB to libmytinfo.so for ELF dynamic libs.
X***************
X*** 86,116 ****
X  
X  DEFS_H = defs.h config.h fake_stdio.h
X  
X! all: $(LINKLIB) $(OTHERLIB) term.h tconv cap2info tic clear tset tput
X  
X! install: $(LINKLIB) term.h
X! 	cp $(LINKLIB) $(DESTLIB); $(RANLIB) $(DESTLIB)/$(LINKLIB)
X! 	cp term.h $(DESTINC)
X! 
X! it: $(LINKLIB) $(OTHERLIB)
X  	
X! libmytinfo.a: $(OBJS)
X! 	rm -f libmytinfo.a
X! 	$(AR) $(ARFLAGS) libmytinfo.a $(OBJS)
X! 	$(RANLIB) libmytinfo.a
X  
X  libmytinfo.so: $(OBJS)
X  	ld -G -o libmytinfo.so $(OBJS)
X  
X! libmytinfo_g.a: $(OBJS)
X! 	rm -f libmytinfo_g.a
X! 	$(AR) $(ARFLAGS) libmytinfo_g.a $(OBJS)
X! 	$(RANLIB) libmytinfo_g.a
X  
X! libmytinfo_p.a: $(OBJS)
X! 	rm -f libmytinfo_p.a
X! 	$(AR) $(ARFLAGS) ligmytinfo_p.a $(OBJS)
X! 	$(RANLIB) libmytinfo_p.a
X  
X  debug: 
X  	$(MAKE) DFLAGS=$(DEBUG) mytinfo_g.a
X--- 81,107 ----
X  
X  DEFS_H = defs.h config.h fake_stdio.h
X  
X! it: mytinfo.a $(OTHERLIB)
X  
X! all: mytinfo.a $(OTHERLIB) term.h tconv cap2info tic clear tset tput
X  	
X! mytinfo.a: $(OBJS)
X! 	rm -f mytinfo.a
X! 	$(AR) $(ARFLAGS) mytinfo.a $(OBJS)
X! 	$(RANLIB) mytinfo.a
X  
X  libmytinfo.so: $(OBJS)
X  	ld -G -o libmytinfo.so $(OBJS)
X  
X! mytinfo_g.a: $(OBJS)
X! 	rm -f mytinfo_g.a
X! 	$(AR) $(ARFLAGS) mytinfo_g.a $(OBJS)
X! 	$(RANLIB) mytinfo_g.a
X  
X! mytinfo_p.a: $(OBJS)
X! 	rm -f mytinfo_p.a
X! 	$(AR) $(ARFLAGS) mytinfo_p.a $(OBJS)
X! 	$(RANLIB) mytinfo_p.a
X  
X  debug: 
X  	$(MAKE) DFLAGS=$(DEBUG) mytinfo_g.a
Only in .: cap2info
Only in .: clear.tcap
Only in .: clear.tinfo
diff -r -c ./config.h ../../../New/mytinfo/config.h
X*** ./config.h	Sun Dec 27 13:58:50 1992
X--- ../../../New/mytinfo/config.h	Fri Jul 10 03:42:19 1992
X***************
X*** 20,40 ****
X  
X  #define USE_TERMIO		/* use termio (SysIII, SysV) */
X  #undef USE_SGTTY		/* use sgtty (v7, BSD) */
X! #define USE_WINSZ		/* get window size from the tty driver */
X  #undef USE_STRINGS		/* include <strings.h> instead of <string.h> */
X  #define USE_MYBSEARCH		/* your library doesn't have bsearch */
X! #define USE_MYSTRTOK		/* your library doesn't have strtok */
X! #define USE_MYQSORT		/* your library doesn't have qsort */
X! #define USE_MYMKDIR		/* your library doesn't have mkdir */
X  #define USE_MEMORY		/* you have an <memory.h> header */
X  #define USE_FAKE_STDIO		/* don't use real stdio */
X  #undef USE_DOPRNT		/* no vfprintf, use _doprnt */
X  
X! #define USE_SHORT_BSEARCH	/* speeds up MYBSEARCH on most machines */
X  
X! #define USE_SMALLMEM 		/* save some memory */
X  
X! #undef USE_UPBC_KLUDGE		/* do tgoto like real togo */
X  #undef USE_EXTERN_UPBC		/* get cuu1 and cub1 from externs UP and BC */
X  #undef USE_LITOUT_KLUDGE	/* an alternate tgoto kludge, not recommened */
X  
X--- 20,40 ----
X  
X  #define USE_TERMIO		/* use termio (SysIII, SysV) */
X  #undef USE_SGTTY		/* use sgtty (v7, BSD) */
X! #undef USE_WINSZ		/* get window size from the tty driver */
X  #undef USE_STRINGS		/* include <strings.h> instead of <string.h> */
X  #define USE_MYBSEARCH		/* your library doesn't have bsearch */
X! #undef USE_MYSTRTOK		/* your library doesn't have strtok */
X! #undef USE_MYQSORT		/* your library doesn't have qsort */
X! #undef USE_MYMKDIR		/* your library doesn't have mkdir */
X  #define USE_MEMORY		/* you have an <memory.h> header */
X  #define USE_FAKE_STDIO		/* don't use real stdio */
X  #undef USE_DOPRNT		/* no vfprintf, use _doprnt */
X  
X! #undef USE_SHORT_BSEARCH	/* speeds up MYBSEARCH on most machines */
X  
X! #undef USE_SMALLMEM 		/* save some memory */
X  
X! #define USE_UPBC_KLUDGE		/* do tgoto like real togo */
X  #undef USE_EXTERN_UPBC		/* get cuu1 and cub1 from externs UP and BC */
X  #undef USE_LITOUT_KLUDGE	/* an alternate tgoto kludge, not recommened */
X  
diff -r -c ./fake_stdio.h ../../../New/mytinfo/fake_stdio.h
X*** ./fake_stdio.h	Sun Dec 27 14:10:12 1992
X--- ../../../New/mytinfo/fake_stdio.h	Fri Jul 10 03:42:22 1992
X***************
X*** 58,64 ****
X  FILE *fdopen();
X  #endif
X  
X! #if !defined(NULL) && !defined(USE_STRINGS)
X  #define NULL ((anyptr) 0)
X  #endif
X  
X--- 58,64 ----
X  FILE *fdopen();
X  #endif
X  
X! #ifndef NULL
X  #define NULL ((anyptr) 0)
X  #endif
X  
Only in .: libmytinfo.a
Only in .: mytinfo.a
Only in .: tconv
Only in .: term.h
diff -r -c ./term.tail ../../../New/mytinfo/term.tail
X*** ./term.tail	Sun Dec 27 14:11:31 1992
X--- ../../../New/mytinfo/term.tail	Fri Jul 10 03:42:17 1992
X***************
X*** 8,14 ****
X  #ifndef ICANON
X  #include <termio.h>
X  #endif
X! #if defined(_USE_WINSZ) && defined(xenix)
X  #include <sys/stream.h>
X  #include <sys/ptem.h>
X  #endif
X--- 8,14 ----
X  #ifndef ICANON
X  #include <termio.h>
X  #endif
X! #ifdef _USE_WINSZ
X  #include <sys/stream.h>
X  #include <sys/ptem.h>
X  #endif
Only in .: tic
Only in .: tput
Only in .: tset
END_OF_FILE
if test 5496 -ne `wc -c <'DIFFS-moderator'`; then
    echo shar: \"'DIFFS-moderator'\" unpacked with wrong size!
fi
# end of 'DIFFS-moderator'
fi
if test -f 'INSTALL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'INSTALL'\"
else
echo shar: Extracting \"'INSTALL'\" \(7255 characters\)
sed "s/^X//" >'INSTALL' <<'END_OF_FILE'
Compiling this package requires a fair bit of knowledge about your system.
There are no automatic configuration programmes or prepared configuration
files for different type of systems.  You will need to edit the Makefile
to specify things like which compiler to use and any options it needs.
The file config.h needs to be edited to reflect the system you are
using and to enable and/or disable certain features.
X
Defines in config.h
X===================
X
USE_ANSIC 
X
Normally this will be defined automaticly if __STDC__ is defined, but
if your compile isn't truly ANSI C compliant you may need to undefine this.
X
USE_TERMIO
X
Define this if your system uses the termio tty driver.  System III and
System V use termio. 
X
USE_SGTTY
X
Define this if your system uses the "sgtty" tty driver.  V7 Unix and BSD
use sgtty.
X
USE_WINSZ
X
If you defined USE_SGTTY you can define this if your system supports
SIGWINSZ and the accompaning ioctls.  If this is defined the library
will get number of columns and lines from the tty driver not the
terminal description.  BSD 4.3 supports SIGWINSZ.  This will also work
if USE_TERMIO is defined on some hybrid System V machines such as Release 4.
X
Do not define both USE_TERMIO and USE_SGTTY.  If your system supports both
you'd probably be better of defining USE_TERMIO.  If your system supports
neither termio or sgtty you can leave USE_TERMIO and USE_SGTTY undefined,
but this is only recommended for use with micomputers.
X
USE_STRINGS
X
If you define this then the header file <strings.h> will be included
and BSD type string library assumed (index instead of strchr), otherwise
X<string.h> will included.  If you have a BSD type system define this.
If you have an ANSI C, System III, or System V type of system leave it
undefined.
X
USE_MYBSEARCH
X
If your system's C library doesn't include bsearch, define this.
Most System V systems have bsearch.  However even your C library has this
function you still may want to define USE_MYBSEARCH, see USE_SHORT_BSEARCH
below.  ("MYBSEARCH" is misnomer, I didn't write this routine.)
X
USE_SHORT_BSEARCH
X
If you define USE_MYBSEARCH you can define this so that the bsearch
routine that library uses the type short instead of size_t (usually long)
for it's arguments.  This results a large speedup on 68000 based machines
and possibly a significant speedup on others as well.  However on some CPU's
defining this will only make things slower.
X
USE_MYSTRTOK 
X
If your system's C library doesn't include strtok, define this.
Most ANSI C, System III, and System V systems have this.
X
USE_MYQSORT
X
If your system's C library doesn't include qsort, define this.
All most all systems should have this function, if it doesn't complain
to your vendor.  The qsort routine comes from the GNU Emacs distribution.
X
USE_MYMKDIR
X
Define this if your system doesn't have the mkdir library function call.  
My routine simply calls the system command mkdir, you may have to
edit mkdir.c if the pathname of that command isn't "/bin/mkdir". 
X
USE_MEMORY
X
If your system has a <memory.h> header define this.  If USE_MEMORY
is not defined bcopy will used instead of memcpy.
X
USE_SMALLMEM 
X
Use you can define use this to save some memory, but it doesn't
save much at moment, and will only slow the library down.
X
USE_FAKE_STDIO
X
If you define this then the library won't use the real stdio but a
fake one instead.  This is for compatiblity with termcap and vi which
don't use stdio.
X
USE_DOPRNT
X
If you don't have a vfprintf function, but you have a _doprnt function
define this.  If you don't have either than you can compile the library
but not the support programmes.  System V has vfprintf and most Unixes
have a _doprnt (but probably not documented).  BSD has released a freely
distributable vfprintf for BSD Unixes.
X
USE_UPBC_KLUDGE
X
Define this if you want the library's tgoto to work like termcap's tgoto
and avoid putting ^D, and \n into an output string by using the cursor up
and backspace strings.
X
USE_EXTERN_UPBC
X
If you defined USE_UPBC_KLUDGE you can define this so tgoto will,
like termcap's tgoto, get the cursor up and backspace strings from the
externs UP and BC instead from the library's internal record.
X
USE_LITOUT_KLUDGE
X
Don't define this.  It's another kludge for tgoto.
X
If neither USE_UPBC_KLUDGE or USE_LITOUT_KLUDGE is defined then tgoto
won't worry about putting ^D, and \n in a string.
X
USE_PROTOTYPES
X
Define this if your compiler supports ANSI C style prototypes.
X
USE_STDLIB
X
Define this if your system has an <stdlib.h> header.
X
USE_STDARG
X
Define this if your system has an <stdarg.h> header.  If this isn't
defined <varargs.h> will be included instead.
X
USE_STDDEF
X
Define this if your system has an <stddef.h> header.  If this isn't
defined <sys/types.h> will be included instead.
X
typedef char *anyptr;
X
You should change the typedef to a type that any pointer can be assigned
to or from.  ANSI C compilers can use "typedef void *anyptr", most
other compilers should use "typedef char *anyptr".
X
X#define mysize_t unsigned
X
X"mysize_t" needs to defined as the type of the size of an object, or
the type of the sizeof operator.  Traditional usage is "unsigned", for
ANSI C you should define mysize_t as "size_t".
X
TERMCAPFILE
X
Define this to a string containing the default termcap file(s) to look
for terminal descriptions in.  Multiple filenames should be seperated
by spaces and environment variables can be specfied by prefixing them
with dolar signs ($).  eg:
X	#define TERMCAPFILE "$TERMCAPFILE $HOME/.termcap /etc/termcap"
X
TERMINFOSRC
X
Define this to a string containing the default terminfo source file to
look for terminal descriptions in.
X
TERMINFODIR
X
Define this as the directory containing the default terminfo database,
usually "/usr/lib/terminfo".
X
Any of TERMCAPFILE, TERMINFOSRC or TERMINFODIR can be left undefined.
X
X
defs.h
X======
X
You may also need to edit defs.h and change the definitions of MAX_BUF,
MAX_LINE, and MAX_NAME.  Unless you are seriously starved for memory I
don't recomend making them smaller.
X
X
cap_list
X========
X
You can add new capabilities to the file cap_list.  You must provide
a type, terminfo variable name, terminfo capname, and termcap name for
all capabilities and you must make sure they are all unique.
X
X
Making in the library
X=====================
X
Once you've configured the package you can just type "make" and it
will build the library and the "term.h" header.  You can enter
X"make all" to make the library and the support programmes, tconv,
cap2info, tic, clear, tput and tset.  If you want a profiled library
you can enter "make profiled".  You can remove all the intermediate
files with "make clean".  "make spotless" will remove the target
files as well.
X
X
Installing the library
X======================
X
As for installing it, that's up to you.  Depending on how much you
plan to use the libraries and whether or not you have termcap and/or
terminfo already you can install them "standard" places (ie. /usr/lib,
X/usr/include, /usr/bin), in local directories, or just leave them in
the source directory.  However if you are compiling programmes that
use terminfo and linking it with this library you must make sure that
this library's term.h file is included in your programme and not the
system supplied one.
END_OF_FILE
if test 7255 -ne `wc -c <'INSTALL'`; then
    echo shar: \"'INSTALL'\" unpacked with wrong size!
fi
# end of 'INSTALL'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(8696 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#
X# Makefile
X#
X# By Ross Ridge
X# Public Domain
X# 92/06/04 11:43:09
X#
X# make the terminfo/termcap library
X#
X# @(#) mytinfo Makefile 3.7 92/06/04 public domain, By Ross Ridge
X#
X
SHELL = /bin/sh
X
DESTROOT =
DESTPATH = $(DESTROOT)/usr/local
DESTLIB = $(DESTPATH)/lib
DESTINC = $(DESTPATH)/include
X
X#
X# Your generic Unix C compiler.
X#
CC = cc
CFLAGS = $(DFLAGS)
X#
X# For the GNU C compiler.
X#
X#CC = gcc
X#CFLAGS = $(DFLAGS) -O -Wall -fstrength-reduce -I.
X#
X# For the Xenix compiler
X#
X#CC = cc
X#CFLAGS = $(DFLAGS) -W1 -Ox
X
LDFLAGS = $(DFLAGS)
DEBUG = -g
X
X#
X# For systems that need their libraries ranlib'ed
X#
RANLIB = ranlib
X#
X# For systems that don't (most System V's)
X#
X#RANLIB = :
X
LINKLIB = libmytinfo.a
OTHERLIB =
X#
X# Set LINKLIB and OTHERLIB to libmytinfo.so for ELF dynamic libs.
X#
X#LINKLIB = libmytinfo.so
X#OTHERLIB = libmytinfo.so
X
AR = ar
ARFLAGS = qcv
X
CAPS = 1000
X
ALLCSRCS = addstr.c buildpath.c caps.c clear.c compar.c fake_stdio.c\
fillterm.c findcap.c findterm.c getother.c gettbin.c gettcap.c gettinfo.c\
mkbinorder.c mkcaplist.c mkcapsort.c mktermhead.c mkversion.c\
quit.c readcaps.c sprintf.c tcapconv.c tcapvars.c tconv.c\
termcap.c terminfo.c tgoto.c tiget.c tmatch.c tparm.c tput.c tputs.c\
tset.c ttest.c tty.c
X
ALLSRCS = $(ALLCSRCS) qsort.c bsearch.c strtok.c mkdir.c \
term.tail defs.h config.h cap_list terminfo.src bin_order fake_stdio.h tconv.1
X
ALLOTHERS = Makefile TODO README README.doc INSTALL DECL version.h
X
ALL = $(ALLSRCS) $(ALLOTHERS)
X
SRCS = addstr.c binorder.c buildpath.c caplist.c capsort.c compar.c\
fake_stdio.c fillterm.c findcap.c findterm.c getother.c gettbin.c\
gettcap.c gettinfo.c sprintf.c tcapconv.c tcapvars.c termcap.c\
terminfo.c tgoto.c tiget.c tmatch.c tparm.c tputs.c tty.c version.c
X
OBJS = addstr.o binorder.o buildpath.o caplist.o capsort.o compar.o\
fake_stdio.o fillterm.o findcap.o findterm.o getother.o gettbin.o\
gettcap.o gettinfo.o sprintf.o tcapconv.o tcapvars.o termcap.o\
terminfo.o tgoto.o tiget.o tmatch.o tparm.o tputs.o tty.o version.o
X
LINTFLAGS = 
X
DEFS_H = defs.h config.h fake_stdio.h
X
all: $(LINKLIB) $(OTHERLIB) term.h tconv cap2info tic clear tset tput
X
install: $(LINKLIB) term.h
X	cp $(LINKLIB) $(DESTLIB); $(RANLIB) $(DESTLIB)/$(LINKLIB)
X	cp term.h $(DESTINC)
X
it: $(LINKLIB) $(OTHERLIB)
X	
libmytinfo.a: $(OBJS)
X	rm -f libmytinfo.a
X	$(AR) $(ARFLAGS) libmytinfo.a $(OBJS)
X	$(RANLIB) libmytinfo.a
X
libmytinfo.so: $(OBJS)
X	ld -G -o libmytinfo.so $(OBJS)
X
libmytinfo_g.a: $(OBJS)
X	rm -f libmytinfo_g.a
X	$(AR) $(ARFLAGS) libmytinfo_g.a $(OBJS)
X	$(RANLIB) libmytinfo_g.a
X
libmytinfo_p.a: $(OBJS)
X	rm -f libmytinfo_p.a
X	$(AR) $(ARFLAGS) ligmytinfo_p.a $(OBJS)
X	$(RANLIB) libmytinfo_p.a
X
debug: 
X	$(MAKE) DFLAGS=$(DEBUG) mytinfo_g.a
X
profiled:
X	rm -f $(OBJS)
X	$(MAKE) mktermhead mkcaplist mkcapsort mkbinorder mkversion
X	$(MAKE) DFLAGS="-p" mytinfo_p.a
X	rm -f $(OBJS)
X
rm:
X	rm -f $(OBJS)
X
mv:
X	-mv -f $(OBJS) Objs 2> /dev/null
X
test: ttest tputs.test tparm.test readcaps.test caps sprintf.test
X
ttest: ttest.o quit.o debug
X	$(CC) -o ttest $(DEBUG) $(LDFLAGS) ttest.o quit.o mytinfo_g.a 
X
ttest.o: ttest.c # $(DEFS_H) term.h
X	$(CC) -c $(DEBUG) $(CFLAGS) ttest.c
X
caps: caps.o quit.o debug
X	$(CC) -o caps $(DEBUG) $(LDFLAGS) caps.o quit.o mytinfo_g.a
X
caps.o: ttest.c # $(DEFS_H) term.h
X	$(CC) -c $(DEBUG) $(CFLAGS) caps.c
X
X.SUFFIXES: .test
X
X.c.test:
X	$(CC) -DTEST $(DEBUG) $(LDFLAGS) $(CFLAGS) $< -o $@
X
tputs.test: tputs.c term.h $(DEFS_H)
X
tparm.test: tparm.c term.h $(DEFS_H)
X
readcaps.test: readcaps.c $(DEFS_H)
X
sprintf.test: sprintf.c $(DEFS_H)
X
capsort.c: mkcapsort
X	./mkcapsort > capsort.c
X
mkcapsort: mkcapsort.o caplist.o compar.o
X	$(CC) $(LDFLAGS) -o mkcapsort mkcapsort.o caplist.o compar.o 
X
binorder.c: mkbinorder bin_order
X	./mkbinorder bin_order > binorder.c
X
mkbinorder: mkbinorder.o capsort.o caplist.o compar.o findcap.o
X	$(CC) $(LDFLAGS) -o mkbinorder mkbinorder.o capsort.o \
caplist.o compar.o findcap.o
X
version.c: mkversion
X	./mkversion > version.c
X
mkversion: mkversion.o
X	$(CC) $(LDFLAGS) -o mkversion mkversion.o
X
term.h: term.head term.tail
X	cat term.head term.tail > term.h
X
term.head: mktermhead cap_list
X	./mktermhead -n $(CAPS) cap_list > term.head
X
caplist.c: mkcaplist cap_list
X	./mkcaplist -n $(CAPS) cap_list > caplist.c
X
mktermhead: mktermhead.o readcaps.o
X	$(CC) $(LDFLAGS) -o mktermhead mktermhead.o readcaps.o
X
mkcaplist: mkcaplist.o readcaps.o
X	$(CC) $(LDFLAGS) -o mkcaplist mkcaplist.o readcaps.o
X
cap2info: tconv
X	rm -f cap2info
X	ln tconv cap2info
X
tic: tconv
X	rm -f tic
X	ln tconv tic
X
tconv: tconv.o quit.o version.o $(LINKLIB)
X	$(CC) $(LDFLAGS) -o tconv tconv.o quit.o version.o $(LINKLIB)
X
clear: clear.tcap clear.tinfo
X
clear.tcap: clear.c $(LINKLIB) $(DEFS_H)
X	$(CC) $(LDFLAGS) $(CFLAGS) -o clear.tcap clear.c $(LINKLIB)
X
clear.tinfo: clear.c $(LINKLIB) $(DEFS_H) term.h
X	$(CC) $(LDFLAGS) $(CFLAGS) -DUSE_TERMINFO -o clear.tinfo clear.c $(LINKLIB)
X
tset: tset.o quit.o version.o $(LINKLIB)
X	$(CC) $(LDFLAGS) -o tset tset.o quit.o version.o $(LINKLIB)
X
tput: tput.o quit.o $(LINKLIB)
X	$(CC) $(LDFLAGS) -o tput tput.o quit.o version.o $(LINKLIB)
X
printf.o: sprintf.c $(DEFS_H)
X	-mv -f sprintf.o sprintf..o 
X	$(CC) $(CFLAGS) -c -DUSE_FAKE_STDIO -DPRINTF sprintf.c
X	-mv -f sprintf.o printf.o
X	-mv -f sprintf..o sprintf.o
X
print: $(ALL)
X	pr $(ALL) | lpr
X
X#lint: $(SRCS) term.h $(DEFS_H)
X#	lint $(LINTFLAGS) $(SRCS)
X
llib-ltinfo.ln: $(SRCS) $(DEFS_H) term.h
X	lint -x $(LINTFLAGS) -otinfo $(SRCS)
X
lint: llib-ltinfo.ln quit.c tconv.c tset.c tput.c $(DEFS_H) term.h
X	lint -L. -ltinfo $(LINTFLAGS) tconv.c quit.c
X	lint -L. -ltinfo $(LINTFLAGS) tset.c quit.c
X	lint -L. -ltinfo $(LINTFLAGS) tput.c quit.c
X
clean:
X	rm -f *.o mkcapsort capsort.c term.head caplist.c version.c
X	rm -f mkbinorder binorder.c mkcaplist mktermhead mkversion
X	rm -f Debug/*.o Profile/*.o Objs/*.o
X
spotless: clean
X	rm -f libmytinfo.so mytinfo.a term.h tparm.test tputs.test mytinfo_g.a
X	rm -f mytinfo_p.a ttest sprintf.test clear.tcap clear.tinfo
X	rm -f readcaps.test caps cap2info tconv tic tset tput
X	rm -f core a.out 
X	rm -rf Dist
X
lorder: $(OBJS)
X	rm -f mytinfo.a
X	$(AR) $(ARFLAGS) `lorder $(OBJS) | tsort`
X	$(RANLIB) mytinfo.a
X
X#.DEFAULT: $(ALLSRCS)
X#	test -f SCCS/s.$< && get SCCS/s.$<
X#
X#get:
X#	get SCCS
X#
X#edit:
X#	get -e SCCS
X#
X#nuke: spotless
X#	-mv -f $(ALLSRCS) Backup 2> /dev/null
X#	rm -f makerrs
X#
X#dist: $(ALLOTHERS)
X#	test -d Dist || mkdir Dist
X#	cp $(ALLOTHERS) Dist
X#	cd Dist && rm -f $(ALLSRCS)
X#	(cd Dist; for i in $(ALLSRCS); do echo "$$i:"; test -f $$i || get -r3 ../SCCS/s.$$i;done)
X##	rm -f Dist/config.h
X##	get -r2.2 -p SCCS/s.config.h > Dist/config.h
X#	rm -f Dist/Makefile
X#	get -r3 -p s.Makefile | sed '/^.DEFAULT/,/^# YOW.$$/s/^/#/' > Dist/Makefile
X#	chmod u+w Dist/*
X#
X#shar: dist
X#	(cd Dist; shar -l50 -o"part" -c -v -w -n"mytinfo" $(ALL))
X#
X#dist-tar: dist
X#	cd Dist && tar cvf mytinfo.tar $(ALL) && compress mytinfo.tar
X#
X#dist-zip: dist
X#	cd Dist && rm -f mytinfo.zip && zip -9 mytinfo.zip $(ALL)
X#
X#zip: $(ALL)
X#	zip -9 mytinfo.zip $(ALL)
X#
X#diff: $(ALL)
X#	-for i in $(ALL); do echo Index: $$i; diff Old/$$i $$i; done
X#
X#depend: $(ALLCSRCS) term.h $(DEFS_H) qsort.c strtok.c bsearch.c mkdir.c version.h
X#	(sed '/^# YOW.$$/,$$d' Makefile; echo "# YOW."; gcc -MM $(ALLCSRCS) | sed -e 's/defs.h/$$(DEFS_H)/' -e 's/[ ]*config.h//' -e 's/[ ]*fake_stdio.h//' -e 's/ : /: /') > Makefile.new
X#
X## The usual stuff about not deleting this line or anything after it...
X## YOW.
addstr.o: addstr.c $(DEFS_H) term.h 
buildpath.o: buildpath.c $(DEFS_H) strtok.c 
caps.o: caps.c $(DEFS_H) term.h 
clear.o: clear.c $(DEFS_H) 
compar.o: compar.c $(DEFS_H) 
fake_stdio.o: fake_stdio.c $(DEFS_H) 
fillterm.o: fillterm.c $(DEFS_H) term.h 
findcap.o: findcap.c $(DEFS_H) term.h bsearch.c 
findterm.o: findterm.c $(DEFS_H) 
getother.o: getother.c $(DEFS_H) term.h 
gettbin.o: gettbin.c $(DEFS_H) term.h 
gettcap.o: gettcap.c $(DEFS_H) term.h 
gettinfo.o: gettinfo.c $(DEFS_H) term.h 
mkbinorder.o: mkbinorder.c $(DEFS_H) term.h 
mkcaplist.o: mkcaplist.c $(DEFS_H) 
mkcapsort.o: mkcapsort.c $(DEFS_H) term.h qsort.c 
mktermhead.o: mktermhead.c $(DEFS_H) 
mkversion.o: mkversion.c $(DEFS_H) version.h 
quit.o: quit.c $(DEFS_H) 
readcaps.o: readcaps.c $(DEFS_H) 
sprintf.o: sprintf.c $(DEFS_H) 
tcapconv.o: tcapconv.c $(DEFS_H) term.h 
tcapvars.o: tcapvars.c $(DEFS_H) term.h 
tconv.o: tconv.c $(DEFS_H) term.h strtok.c mkdir.c 
termcap.o: termcap.c $(DEFS_H) term.h 
terminfo.o: terminfo.c $(DEFS_H) term.h 
tgoto.o: tgoto.c $(DEFS_H) term.h 
tiget.o: tiget.c $(DEFS_H) term.h 
tmatch.o: tmatch.c $(DEFS_H) 
tparm.o: tparm.c $(DEFS_H) term.h 
tput.o: tput.c $(DEFS_H) term.h 
tputs.o: tputs.c $(DEFS_H) term.h 
tset.o: tset.c $(DEFS_H) term.h 
ttest.o: ttest.c $(DEFS_H) term.h 
tty.o: tty.c $(DEFS_H) term.h 
END_OF_FILE
if test 8696 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'cap_list' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cap_list'\"
else
echo shar: Extracting \"'cap_list'\" \(12854 characters\)
sed "s/^X//" >'cap_list' <<'END_OF_FILE'
X cap_list
X
X By Ross Ridge
X Public Domain
X 92/02/01 07:29:44
X
X @(#) mytinfo cap_list 3.2 92/02/01 public domain, By Ross Ridge
X
types: ! = boolean, # = number, $ = string, $G = string with parameters,
X       $K = string that never is outputed (with tputs).
X
type	variable		capname termcap 
X
Standard terminfo capabilities:
X
X!	auto_left_margin	bw	bw
X!	auto_right_margin	am	am
X!	ceol_standout_glitch	xhp	xs
X!	dest_tabs_magic_smso	xt	xt
X!	eat_newline_glitch	xenl	xn
X!	erase_overstrike	eo	eo
X!	generic_type		gn	gn
X!	hard_copy		hc	hc
X!	hard_cursor		chts	HC
X!	has_meta_key		km	km
X!	has_status_line		hs	hs
X!	insert_null_glitch	in	in
X!	memory_above		da	da
X!	memory_below		db	db
X!	move_insert_mode	mir	mi
X!	move_standout_mode	msgr	ms
X!	needs_xon_xoff		nxon	nx
X!	no_esc_ctlc		xsb	xb
X!	no_pad_char		npc	NP
X!	non_rev_rmcup		nrrmc	NR
X!	over_strike		os	os
X!	prtr_silent		mc5i	5i
X!	status_line_esc_ok	eslok	es
X!	tilde_glitch		hz	hz
X!	transparent_underline	ul	ul
X!	xon_xoff		xon	xo
X#	columns			cols	co
X#	init_tabs		it	it
X#	label_height		lh	lh
X#	label_width		lw	lw
X#	lines			lines	li
X#	lines_of_memory		lm	lm
X#	magic_cookie_glitch	xmc	sg
X#	num_labels		nlab	Nl
X#	padding_baud_rate	pb	pb
X#	virtual_terminal	vt	vt
X#	width_status_line	wsl	ws
X$K	acs_chars		acsc	ac
X$	back_tab		cbt	bt
X$	bell			bel	bl
X$	carriage_return		cr	cr
X$G	change_scroll_region	csr	cs
X$	char_padding		rmp	rP
X$	clear_all_tabs		tbc	ct
X$	clear_margins		mgc	MC
X$	clear_screen		clear	cl
X$	clr_bol			el1	cb
X$	clr_eol			el	ce
X$	clr_eos			ed	cd
X$G	column_address		hpa	ch
X$K	command_character	cmdch	CC
X$G	cursor_address		cup	cm
X$	cursor_down		cud1	do
X$	cursor_home		home	ho
X$	cursor_invisible	civis	vi
X$	cursor_left		cub1	le
X$G	cursor_mem_address	mrcup	CM
X$	cursor_normal		cnorm	ve
X$	cursor_right		cuf1	nd
X$	cursor_to_ll		ll	ll
X$	cursor_up		cuu1	up
X$	cursor_visible		cvvis	vs
X$	delete_character	dch1	dc
X$	delete_line		dl1	dl
X$	dis_status_line		dsl	ds
X$	down_half_line		hd	hd
X$	ena_acs			enacs	eA
X$	enter_alt_charset_mode	smacs	as
X$	enter_am_mode		smam	SA
X$	enter_blink_mode	blink	mb
X$	enter_bold_mode		bold	md
X$	enter_ca_mode		smcup	ti
X$	enter_delete_mode	smdc	dm
X$	enter_dim_mode		dim	mh
X$	enter_insert_mode	smir	im
X$	enter_protected_mode	prot	mp
X$	enter_reverse_mode	rev	mr
X$	enter_secure_mode	invis	mk
X$	enter_standout_mode	smso	so
X$	enter_underline_mode	smul	us
X$	enter_xon_mode		smxon	SX
X$G	erase_chars		ech	ec
X$	exit_alt_charset_mode	rmacs	ae
X$	exit_am_mode		rmam	RA
X$	exit_attribute_mode	sgr0	me
X$	exit_ca_mode		rmcup	te
X$	exit_delete_mode	rmdc	ed
X$	exit_insert_mode	rmir	ei
X$	exit_standout_mode	rmso	se
X$	exit_underline_mode	rmul	ue
X$	exit_xon_mode		rmxon	RX
X$	flash_screen		flash	vb
X$	form_feed		ff	ff
X$	from_status_line	fsl	fs
X$ 	init_1string		is1	i1
X$ 	init_2string		is2	is
X$ 	init_3string		is3	i3
X$K	init_file		if	if
X$K	init_prog		iprog	iP
X$	insert_character	ich1	ic
X$	insert_line		il1	al
X$	insert_padding		ip	ip
X$K	key_a1			ka1	K1
X$K	key_a3			ka3	K3
X$K	key_b2			kb2	K2
X$K	key_backspace		kbs	kb
X$K	key_beg			kbeg	@1
X$K	key_btab		kcbt	kB
X$K	key_c1			kc1	K4
X$K	key_c3			kc3	K5
X$K	key_cancel		kcan	@2
X$K	key_catab		ktbc	ka
X$K	key_clear		kclr	kC
X$K	key_close		kclo	@3
X$K	key_command		kcmd	@4
X$K	key_copy		kcpy	@5
X$K	key_create		kcrt	@6
X$K	key_ctab		kctab	kt
X$K	key_dc			kdch1	kD
X$K	key_dl			kdl1	kL
X$K	key_down		kcud1	kd
X$K	key_eic			krmir	kM
X$K	key_end			kend	@7
X$K	key_enter		kent	@8
X$K	key_eol			kel	kE
X$K	key_eos			ked	kS
X$K	key_exit		kext	@9
X$K	key_f0			kf0	k0
X$K	key_f1			kf1	k1
X$K	key_f10			kf10	k;
X$K	key_f11			kf11	F1
X$K	key_f12			kf12	F2
X$K	key_f13			kf13	F3
X$K	key_f14			kf14	F4
X$K	key_f15			kf15	F5
X$K	key_f16			kf16	F6
X$K	key_f17			kf17	F7
X$K	key_f18			kf18	F8
X$K	key_f19			kf19	F9
X$K	key_f2			kf2	k2
X$K	key_f20			kf20	FA
X$K	key_f21			kf21	FB
X$K	key_f22			kf22	FC
X$K	key_f23			kf23	FD
X$K	key_f24			kf24	FE
X$K	key_f25			kf25	FF
X$K	key_f26			kf26	FG
X$K	key_f27			kf27	FH
X$K	key_f28			kf28	FI
X$K	key_f29			kf29	FJ
X$K	key_f3			kf3	k3
X$K	key_f30			kf30	FK
X$K	key_f31			kf31	FL
X$K	key_f32			kf32	FM
X$K	key_f33			kf33	FN
X$K	key_f34			kf34	FO
X$K	key_f35			kf35	FP
X$K	key_f36			kf36	FQ
X$K	key_f37			kf37	FR
X$K	key_f38			kf38	FS
X$K	key_f39			kf39	FT
X$K	key_f4			kf4	k4
X$K	key_f40			kf40	FU
X$K	key_f41			kf41	FV
X$K	key_f42			kf42	FW
X$K	key_f43			kf43	FX
X$K	key_f44			kf44	FY
X$K	key_f45			kf45	FZ
X$K	key_f46			kf46	Fa
X$K	key_f47			kf47	Fb
X$K	key_f48			kf48	Fc
X$K	key_f49			kf49	Fd
X$K	key_f5			kf5	k5
X$K	key_f50			kf50	Fe
X$K	key_f51			kf51	Ff
X$K	key_f52			kf52	Fg
X$K	key_f53			kf53	Fh
X$K	key_f54			kf54	Fi
X$K	key_f55			kf55	Fj
X$K	key_f56			kf56	Fk
X$K	key_f57			kf57	Fl
X$K	key_f58			kf58	Fm
X$K	key_f59			kf59	Fn
X$K	key_f6			kf6	k6
X$K	key_f60			kf60	Fo
X$K	key_f61			kf61	Fp
X$K	key_f62			kf62	Fq
X$K	key_f63			kf63	Fr
X$K	key_f7			kf7	k7
X$K	key_f8			kf8	k8
X$K	key_f9			kf9	k9
X$K	key_find		kfnd	@0
X$K	key_help		khlp	%1
X$K	key_home		khome	kh
X$K	key_ic			kich1	kI
X$K	key_il			kil1	kA
X$K	key_left		kcub1	kl
X$K	key_ll			kll	kH
X$K	key_mark		kmrk	%2
X$K	key_message		kmsg	%3
X$K	key_move		kmov	%4
X$K	key_next		knxt	%5
X$K	key_npage		knp	kN
X$K	key_open		kopn	%6
X$K	key_options		kopt	%7
X$K	key_ppage		kpp	kP
X$K	key_previous		kprv	%8
X$K	key_print		kprt	%9
X$K	key_redo		krdo	%0
X$K	key_reference		kref	&1
X$K	key_refresh		krfr	&2
X$K	key_replace		krpl	&3
X$K	key_restart		krst	&4
X$K	key_resume		kres	&5
X$K	key_right		kcuf1	kr
X$K	key_save		ksav	&6
X$K	key_sbeg		kBEG	&9
X$K	key_scancel		kCAN	&0
X$K	key_scommand		kCMD	*1
X$K	key_scopy		kCPY	*2
X$K	key_screate		kCRT	*3
X$K	key_sdc			kDC	*4
X$K	key_sdl			kDL	*5
X$K	key_select		kslt	*6
X$K	key_send		kEND	*7
X$K	key_seol		kEOL	*8
X$K	key_sexit		kEXT	*9
X$K	key_sf			kind	kF
X$K	key_sfind		kFND	*0
X$K	key_shelp		kHLP	#1
X$K	key_shome		kHOM	#2
X$K	key_sic			kIC	#3
X$K	key_sleft		kLFT	#4
X$K	key_smessage		kMSG	%a
X$K	key_smove		kMOV	%b
X$K	key_snext		kNXT	%c
X$K	key_soptions		kOPT	%d
X$K	key_sprevious		kPRV	%e
X$K	key_sprint		kPRT	%f
X$K	key_sr			kri	kR
X$K	key_sredo		kRDO	%g
X$K	key_sreplace		kRPL	%h
X$K	key_sright		kRIT	%i
X$K	key_srsume		kRES	%j
X$K	key_ssave		kSAV	!1
X$K	key_ssuspend		kSPD	!2
X$K	key_stab		khts	kT
X$K	key_sundo		kUND	!3
X$K	key_suspend		kspd	&7
X$K	key_undo		kund	&8
X$K	key_up			kcuu1	ku
X$	keypad_local		rmkx	ke
X$	keypad_xmit		smkx	ks
X$K	lab_f0			lf0	l0
X$K	lab_f1			lf1	l1
X$K	lab_f10			lf10	la
X$K	lab_f2			lf2	l2
X$K	lab_f3			lf3	l3
X$K	lab_f4			lf4	l4
X$K	lab_f5			lf5	l5
X$K	lab_f6			lf6	l6
X$K	lab_f7			lf7	l7
X$K	lab_f8			lf8	l8
X$K	lab_f9			lf9	l9
X$	label_off		rmln	LF
X$	label_on		smln	LO
X$	meta_off		rmm	mo
X$	meta_on			smm	mm
X$	newline			nel	nw
X$K	pad_char		pad	pc
X$G	parm_dch		dch	DC
X$G	parm_delete_line	dl	DL
X$G	parm_down_cursor	cud	DO
X$G	parm_ich		ich	IC
X$G	parm_index		indn	SF
X$G	parm_insert_line	il	AL
X$G	parm_left_cursor	cub	LE
X$G	parm_right_cursor	cuf	RI
X$G	parm_rindex		rin	SR
X$G	parm_up_cursor		cuu	UP
X$G	pkey_key		pfkey	pk
X$G	pkey_local		pfloc	pl
X$G	pkey_xmit		pfx	px
X$G	plab_norm		pln	pn
X$	print_screen		mc0	ps
X$G	prtr_non		mc5p	pO
X$	prtr_off		mc4	pf
X$	prtr_on			mc5	po
X$G	repeat_char		rep	rp
X$	req_for_input		rfi	RF
X$ 	reset_1string		rs1	r1
X$ 	reset_2string		rs2	r2
X$ 	reset_3string		rs3	r3
X$K	reset_file		rf	rf
X$	restore_cursor		rc	rc
X$G	row_address		vpa	cv
X$	save_cursor		sc	sc
X$	scroll_forward		ind	sf
X$	scroll_reverse		ri	sr
X$G	set_attributes		sgr	sa
X$	set_left_margin		smgl	ML
X$	set_right_margin	smgr	MR
X$	set_tab			hts	st
X$G	set_window		wind	wi
X$	tab			ht	ta
X$G	to_status_line		tsl	ts
X$	underline_char		uc	uc
X$	up_half_line		hu	hu
X$ 	xoff_character		xoffc	XF
X$ 	xon_character		xonc	XN
X
Release 3.2 and 4 capabilities (AMIX)
X(some of the string attributes are guesses...)
X
X!	back_color_erase		bce	ut
X!	can_change			ccc	cc
X!	col_addr_glitch			xhpa	YA
X!	cpi_changes_res			cpix	YF
X!	cr_cancels_micro_mode		crxm	YB
X!	has_print_wheel			daisy	YC
X!	hue_lightness_saturation	hls	hl
X!	lpi_changes_res			lpix	YG
X!	non_dest_scroll_region		ndscr	ND
X!	row_addr_glitch			xvpa	YD
X!	semi_auto_right_margin		sam	YE
X#	bit_image_entwining		bitwin	Yo
X#	bit_image_type			bitype	Yp
X#	buffer_capacity			bufsz	Ya
X#	buttons				btns	BT
X#	dot_horz_spacing		spinh	Yc
X#	dot_vert_spacing		spinv	Yb
X#	max_attributes			ma	ma
X#	max_colors			colors	Co
X#	max_micro_address		maddr	Yd
X#	max_micro_jump			mjump	Ye
X#	max_pairs			pairs	pa
X#	maximum_windows			wnum	MW
X#	micro_char_size			mcs	Yf
X#	micro_line_size			mls	Yg
X#	no_color_video			ncv	NC
X#	number_of_pins			npins	Yh
X#	output_res_char			orc	Yi
X#	output_res_horz_inch		orhi	Yk
X#	output_res_line			orl	Yj
X#	output_res_vert_inch		orvi	Yl
X#	print_rate			cps	Ym
X#	wide_char_size			widcs	Yn
X$	alt_scancode_esc		scesa	S8
X$G	bit_image_carriage_return	bicr	Yv
X$G	bit_image_newline		binel	Zz
X$G	bit_image_repeat		birep	Xy
X$G	change_char_pitch		cpi	ZA
X$G	change_line_pitch		lpi	ZB
X$G	change_res_horz			chr	ZC
X$G	change_res_vert			cvr	ZD
X$G	char_set_names			csnm	Zy
X$	code_set_init			csin	ci
X$G	color_names			colornm	Yw
X$G	create_window			cwin	CW
X$G	define_bit_image_region		defbi	Yx
X$G	define_char			defc	ZE
X$	device_type			devt	dv
X$G	dial_phone			dial	DI
X$	display_clock			dclk	DK
X$	display_pc_char			dispc	S1
X$	end_bit_image_region		endbi	Yy
X$	enter_doublewide_mode		swidm	ZF
X$	enter_draft_quality		sdrfq	ZG
X$	enter_italics_mode		sitm	ZH
X$	enter_leftward_mode		slm	ZI
X$	enter_micro_mode		smicm	ZJ
X$	enter_near_letter_quality	snlq	ZK
X$	enter_normal_quality		snrmq	ZL
X$	enter_pc_charset_mode		smpch	S2
X$	enter_scancode_mode		smsc	S4
X$	enter_shadow_mode		sshm	ZM
X$	enter_subscript_mode		ssubm	ZN
X$	enter_superscript_mode		ssupm	ZO
X$	enter_upward_mode		sum	ZP
X$	exit_doublewide_mode		rwidm	ZQ
X$	exit_italics_mode		ritm	ZR
X$	exit_leftward_mode		rlm	ZS
X$	exit_micro_mode			rmicm	ZT
X$	exit_pc_charset_mode		rmpch	S3
X$	exit_scancode_mode		rmsc	S5
X$	exit_shadow_mode		rshm	ZU
X$	exit_subscript_mode		rsubm	ZV
X$	exit_superscript_mode		rsupm	ZW
X$	exit_upward_mode		rum	ZX
X$	fixed_pause			pause	PA
X$	flash_hook			hook	fh
X$	get_mouse			getm	Gm
X$G	goto_window			wingo	WG
X$	hangup				hup	HU
X$G	initialize_color		initc	Ic
X$G	initialize_pair			initp	Ip
X$	key_mouse			kmous	Km
X$	label_format			fln	Lf
X$G	micro_column_address		mhpa	ZY
X$	micro_down			mcud1	ZZ
X$	micro_left			mcub1	Za
X$	micro_right			mcuf1	Zb
X$G	micro_row_address		mvpa	Zc
X$	micro_up			mcuu1	Zd
X$	mouse_info			minfo	Mi
X$K	order_of_pins			porder	Ze
X$	orig_colors			oc	oc
X$	orig_pair			op	op
X$G	parm_down_micro			mcud	Zf
X$G	parm_left_micro			mcub	Zg
X$G	parm_right_micro		mcuf	Zh
X$G	parm_up_micro			mcuu	Zi
X$	pc_term_options			pctrm	S6
X$G	pkey_plab			pfxl	xl
X$	pulse				pulse	PU
X$	quick_dial			qdial	QD
X$	remove_clock			rmclk	RC
X$	req_mouse_pos			reqmp	RQ
X$	scancode_escape			scesc	S7
X$G	select_char_set			scs	Zj
X$	set0_des_seq			s0ds	s0
X$	set1_des_seq			s1ds	s1
X$	set2_des_seq			s2ds	s2
X$	set3_des_seq			s3ds	s3
X$G	set_a_background		setab	AB
X$G	set_a_foreground		setaf	AF
X$G	set_background			setb	Sb
X$	set_bottom_margin		smgb	Zk
X$G	set_bottom_margin_parm		smgbp	Zl
X$G	set_clock			sclk	SC
X$G	set_color_band			setcolor Yz
X$G	set_color_pair			scp	sp
X$G	set_foreground			setf	Sf
X$G	set_left_margin_parm		smglp	Zm
X$G	set_lr_margin			smglr	ML
X$G	set_page_length			slines	YZ
X$G	set_right_margin_parm		smgrp	Zn
X$G	set_tb_margin			smgtb	MT
X$	set_top_margin			smgt	Zo
X$G	set_top_margin_parm		smgtp	Zp
X$G	start_bit_image			sbim	Zq
X$G	start_char_set_def		scsd	Zr
X$	stop_bit_image			rbim	Zs
X$G	stop_char_set_def		rcsd	Zt
X$K	subscript_characters		subcs	Zu
X$K	superscript_characters		supcs	Zv
X$K	these_cause_cr			docr	Zw
X$	tone				tone	TO
X$	user0				u0	u0
X$	user1				u1	u1
X$	user2				u2	u2
X$	user3				u3	u3
X$	user4				u4	u4
X$	user5				u5	u5
X$	user6				u6	u6
X$	user7				u7	u7
X$	user8				u8	u8
X$	user9				u9	u9
X$	wait_tone			wait	WA
X$	zero_motion			zerom	Zx
X
X"Obsolete" termcap capabilities (variable and terminfo names are mine)
X
X$	backspace_if_not_bs	OTbc	bc
X!	backspaces_with_bs	OTbs	bs
X#	backspace_delay		OTdB	dB
X#	carriage_return_delay	OTdC	dC
X#	form_feed_delay		OTdF	dF
X#	new_line_delay		OTdN	dN
X#	horizontal_tab_delay	OTdT	dT
X#	vertical_tab_delay	OTdV	dV
X!	even_parity		OTEP	EP
X!	half_duplex		OTHD	HD
X#	number_of_function_keys	OTkn	kn
X$K	other_non_function_keys	OTko	ko
X!	lower_case_only		OTLC	LC
X$K	arrow_key_map		OTma	ma
X$	memory_lock_above	OTml	ml
X$	memory_unlock		OTmu	mu
X!	no_correctly_working_cr	OTnc	nc
X!	linefeed_is_newline	OTNL	NL
X$	linefeed_if_not_lf	OTnl	nl
X!	crt_without_scrolling	OTns	ns
X!	odd_parity		OTOP	OP
X!	has_hardware_tabs	OTpt	pt
X!	uppercase_only		OTUC	UC
X!	return_does_clr_eol	OTxr	xr
X!	tek_4025_insert_line	OTxx	xx
X#	magic_cookie_glitch_ul	OTug	ug
X
Caps used by the University of Waterloo (variable and terminfo names are mine)
X
X$K	key_interrupt_char	UWki	ki
X$K	key_kill_char		UWkk	kk
X$K	key_suspend_char	UWkz	kz
X!	initialization_messy	UWxc	xc
X!	index_at_bottom_does_cr	UWxl	xl
X
X!	rind_only_at_top	OTxq	xq
X
Different names for existing terminfo caps used by GNU Emacs:
X!	GNU_has_meta_key	GNUMT	MT
X#	GNU_tab_width		GNUtw	tw
X
Non standard capabilities:
X
X$	scroll_left		sl1	Sl
X$	scroll_right		sr1	Sr
X$G	parm_scroll_left	sl	SL
X$G	parm_scroll_right	sr	SR
X
Dummy (must be present and last):
X
X$K	_get_other		use	tc
END_OF_FILE
if test 12854 -ne `wc -c <'cap_list'`; then
    echo shar: \"'cap_list'\" unpacked with wrong size!
fi
# end of 'cap_list'
fi
if test -f 'findterm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'findterm.c'\"
else
echo shar: Extracting \"'findterm.c'\" \(4667 characters\)
sed "s/^X//" >'findterm.c' <<'END_OF_FILE'
X/* findterm.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:29:56
X *
X */
X
X#include "defs.h"
X
X#include <ctype.h>
X#include <fcntl.h>
X#ifdef USE_STDDEF
X#include <sys/types.h>
X#endif
X#include <sys/stat.h>
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo findterm.c 3.2 92/02/01 public domain, By Ross Ridge";
X#endif
static int linecnt;
X
static int
getln(f, buf, len)
XFILE *f;
register char *buf;
int len; {
X	register int c, i = 0;
X
X	while((c = getc(f)) == '#') {
X		linecnt++;
X		while((c = getc(f)) != '\n')
X			if (c == EOF)
X				return -1;
X	}
X
X	while(c != '\n') {
X		if (c == EOF)
X			return -1;
X		if (i < len) {
X			i++;
X			*buf++ = c;
X		}
X		c = getc(f);
X	}
X
X	while(isspace(*(buf-1))) {
X		buf--;
X		i--;
X	}
X
X	*buf = '\0';
X	return i;
X}
X
static int
X_findterm2(name, file, buf)
char *name, *buf;
char *file; {
X	char line[MAX_LINE];
X	FILE *f;
X	register char *sp, *dp;
X	int c;
X	int l;
X	int cont;
X	int fd;
X	struct stat st;
X
X	linecnt = 0;
X
X#ifdef DEBUG
X	printf("open: %s\n", file);
X#endif
X	fd = open(file, O_RDONLY);
X	if (fd == -1)
X		return -1;
X	if (fstat(fd, &st) == -1) {
X		close(fd);
X		return -1;
X	}
X	if ((st.st_mode & 0170000) == 0040000) {
X		sprintf(buf, "%s/%c/%s", file, name[0], name);
X		close(fd);
X		fd = open(buf, O_RDONLY);
X		if (fd == -1)
X			return -1;
X		if (read(fd, buf, MAX_BUF) < 12
X		    || buf[0] != 032 || buf[1] != 1) {
X			close(fd);
X			return -1;
X		}
X		close(fd);
X		return 3;
X	}
X	f = fdopen(fd, "r");
X	if (f == NULL) {
X		close(fd);
X		return -1;
X	}
X
X	while ((l = getln(f, buf, MAX_LINE)) != -1) {
X		linecnt++;
X		if (!isspace(buf[0]) && l != 0) {
X			sp = buf + l - 1;
X			cont = 0;
X			switch(*sp) {
X			case '\\':
X				cont = 1;
X				*sp = '\0';
X				/* FALLTHROUGH */
X			case ':':
X				sp = buf;
X				dp = line;
X				while (*sp != ':') {
X					if (*sp == '\0' && cont &&
X					    (l = getln(f, buf, MAX_LINE))
X					     != -1) {
X						linecnt++;
X						sp = buf;
X						if (l > 0 && buf[l-1] == '\\')
X							cont = 1;
X						else
X							cont = 0;
X						continue;
X					}
X					if (*sp == '\0') {
X#ifdef DEBUG
X						printf("bad line (%d)\n",
X						       linecnt);
X						fclose(f);
X						return -2;
X#else
X						goto err;
X#endif
X					}
X					*dp++ = *sp++;
X				}
X				*dp = '\0';
X				if (!_tmatch(line, name))
X					break;
X				if (!cont) {
X					fclose(f);
X					return 1;
X				}
X				l = strlen(buf);
X				dp = buf + l;
X				while((c = getc(f)) != EOF && l < MAX_BUF) {
X					if (c == '\n')
X						break;
X					if (c == '\\') {
X						c = getc(f);
X						if (c == EOF)
X							break;
X						if (c == '\n') {
X							c = getc(f);
X							if (c == EOF)
X								break;
X							if (c == '#') {
X								while((c = getc(f)) != EOF && c != '\n');
X								if (c == EOF)
X									break;
X								continue;
X							}
X							*dp++ = c;
X							continue;
X						}
X						*dp++ = '\\';
X						*dp++ = c;
X						continue;
X					} 
X					*dp++ = c;
X				}
X				*dp = '\0';
X				fclose(f);
X				return 1;
X			case ',':
X				sp = buf;
X				dp = line;
X				while(*sp != ',')
X					*dp++ = *sp++;
X				*dp = '\0';
X				if (!_tmatch(line, name))
X					break;
X				dp = buf + l;
X				while ((c = getc(f)) != EOF && l < MAX_BUF) {
X					if (c == '\n') {
X						c = getc(f);
X						if (isspace(c))
X							continue;
X						if (c == '\n') {
X							ungetc(c, f);
X							continue;
X						}
X						if (c == '#') {
X							while((c = getc(f)) != EOF)
X								if (c == '\n')
X									break;
X							if (c == EOF)
X								break;
X							ungetc(c, f);
X							continue;
X						}
X						break;
X					}
X					*dp++ = c;
X					l++;
X				}
X				*dp = '\0';
X				fclose(f);
X				return 2;
X			default:
X			err:
X#ifdef DEBUG
X				printf("strange line (%d)\n", linecnt);
X#endif
X				break;
X			}
X		}
X	}
X	fclose(f);
X	return 0;
X}
X
int
X_findterm(name, path, buf)
char *name;
struct term_path *path;
char *buf; {
X	register char *s, *d;
X	int r = 0;
X	while(path->file != NULL) {
X		switch(path->type) {
X		case 0:
X			r = _findterm2(name, path->file, buf);
X			break;
X		case 1:
X			if (path->file[0] == '/') {
X				r = _findterm2(name, path->file, buf);
X			} else {
X				s = path->file;
X				d = buf;
X				while(*s != '\0' && *s != ':')
X					*d++ = *s++;
X				*d = '\0';
X				if (_tmatch(buf, name)) {
X					while(*s != '\0')
X						*d++ = *s++;
X					return 1;
X				}
X				r = 0;
X			}
X			break;
X		case 2:
X			if (path->file[0] == '/') {
X				r = _findterm2(name, path->file, buf);
X			} else {
X				s = path->file;
X				d = buf;
X				while(*s != '\0' && *s != ',')
X					*d++ = *s++;
X				*d = '\0';
X				if (_tmatch(buf, name)) {
X					while(*s != '\0')
X						*d++ = *s++;
X					return 2;
X				}
X				r = 0;
X			}
X			break;
X		default:
X			r = 0;
X			break;
X		}
X		if (r == 1 || r == 2 || r == 3) {
X#ifdef DEBUG
X			printf("found in %s\n", path->file);
X#endif
X			break;
X		}
X		path++;
X	}
X	return r;
X}
END_OF_FILE
if test 4667 -ne `wc -c <'findterm.c'`; then
    echo shar: \"'findterm.c'\" unpacked with wrong size!
fi
# end of 'findterm.c'
fi
if test -f 'gettcap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gettcap.c'\"
else
echo shar: Extracting \"'gettcap.c'\" \(5172 characters\)
sed "s/^X//" >'gettcap.c' <<'END_OF_FILE'
X/*
X * gettcap.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:30:00
X *
X */
X
X#include "defs.h"
X#include "term.h"
X
X#include <ctype.h>
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo gettcap.c 3.2 92/02/01 public domain, By Ross Ridge";
X#endif
X
int
X_gettcap(sp, cur, path)
register char *sp;
TERMINAL *cur;
struct term_path *path; {
X	static char name[MAX_NAME];
X	static char entry[MAX_LINE];
X	register char *dp;
X	register TERMINAL *ct = cur;
X	int i, pad, fract, mul, ind;
X	char c, flag;
X
X	dp = entry;
X	while(*sp != ':' && *sp != '\0')
X		*dp++ = *sp++;
X	if (ct->name_all == NULL) {
X		*dp = '\0';
X		if ((ct->name_all = _addstr(entry)) == NULL)
X			return 1;
X		while(dp > entry && *--dp != '|');
X		ct->name_long = ct->name_all + (dp - entry) + 1;
X	}
X
X 	while(*sp != '\0') {
X		while(*sp == ':')
X			sp++;
X		while(isspace(*sp))
X			sp++;
X		if (*sp == ':')
X			continue;
X		if (*sp == '\0')
X			break;
X		dp = name;
X		while (*sp != ':' && *sp != '#' && *sp != '=' &&
X		       !isspace(*sp) && *sp != '\0')
X			*dp++ = *sp++;
X		*dp = '\0';
X#ifdef DEBUG
X		printf(" %s", name);
X#endif
X		switch(*sp) {
X		case '=':
X#ifdef DEBUG
X			putchar('$');
X#endif
X			ind = _findstrcode(name);
X			if (ind != -1)
X				flag = _strflags[ind];
X			else
X				flag = 'K';
X			dp = entry;
X			fract = pad = 0;
X			sp++;
X			if (isdigit(*sp) && flag != 'K') {
X				pad = *sp++ - '0';
X				while(isdigit(*sp))
X					pad = pad * 10 + (*sp++ - '0');
X				if (*sp == '.' && isdigit(sp[1])) {
X					sp++;
X					fract = (*sp++ - '0');
X				}
X				if (*sp == '*') {
X					mul = 1;
X					sp++;
X				} else
X					mul = 0;
X	
X			}
X			while(*sp != '\0' && *sp != ':') {
X				switch(*sp) {
X				case '\\':
X					switch(*++sp) {
X					case 'e':
X					case 'E': *dp++ = '\033'; break;
X					case 'l': *dp++ = '\012'; break;
X					case 'n': *dp++ = '\n'; break;
X					case 'r': *dp++ = '\r'; break;
X					case 't': *dp++ = '\t'; break;
X					case 'b': *dp++ = '\b'; break;
X					case 'f': *dp++ = '\f'; break;
X					case 's': *dp++ = ' '; break;
X
X					case '^': 
X					case '\\':
X					case ',':
X					case ':':
X						*dp++ = *sp;
X						break;
X
X					case '0':
X						if (!isdigit(*(sp + 1))) {
X							*dp++ = '\200';
X							break;
X						}
X						;/* FALLTHROUGH */
X					case '1':
X					case '2':
X					case '3':
X					case '4':
X					case '5':
X					case '6':
X					case '7':
X						c = *sp - '0';
X						if (sp[1] >= '0'
X						    && sp[1] <= '8')
X							c = c * 8
X							    + (*++sp - '0');
X						if (sp[1] >= '0'
X						    && sp[1] <= '8')
X							c = c * 8
X							    + (*++sp - '0');
X						switch((char)c) {
X						case 0:
X							if (flag == 'K')
X								*dp++ = '\200';
X							else {
X								*dp++ = '\\';
X								*dp++ = '0';
X								*dp++ = '0';
X								*dp++ = '0';
X							}
X							break;
X						case '$':
X						case '\'':
X						case '\\':
X							if (flag != 'K')
X								*dp++ = '\\';
X							/* FALLTHROUGH */
X						default:
X							if (flag == 'G'
X							    && c == '%')
X								*dp++ = '\\';
X							*dp++ = c;
X							break;
X						}
X						break;
X					default:
X						*dp++ = '\\';
X						*dp++ = *sp;
X						break;
X					}
X					sp++;
X					break;
X				case '^':
X					if (*++sp >= 'A' && *sp <= '_') {
X						*dp++ = *sp++ - '@';
X					} else if (*sp >= 'a' && *sp <= 'z') {
X						*dp++ = *sp++ - 'a' + 1;
X					} else if (*sp == '@') {
X						if (flag == 'K')
X							*dp++ = '\200';
X						else {
X							*dp++ = '\\';
X							*dp++ = '0';
X							*dp++ = '0';
X							*dp++ = '0';
X						}
X						sp++;
X					} else 
X						*dp++ = '^';
X					break;
X				case '$':
X					if (flag != 'K')
X						*dp++ = '\\';
X					/* FALLTHROUGH */
X				default:
X					*dp++ = *sp++;
X					break;
X				}
X			}
X			if (pad != 0 || fract != 0) {
X				if (fract == 0)
X					sprintf(dp, "$<%d", pad);
X				else
X					sprintf(dp, "$<%d.%d", pad, fract);
X				dp += strlen(dp);
X				if (mul) 
X					*dp++ = '*';
X				*dp++ = '>';
X			}
X			*dp++ = '\0';
X			if(name[0] == 't' && name[1] == 'c' && name[2] == '\0'){
X				if (_getother(entry, path, ct))
X					return 1;
X				break;
X			}
X			if (ind == -1)
X				break;
X			if (ct->strs[ind] != (char *) -1)
X				break;
X			if ((ct->strs[ind] = _addstr(entry)) == NULL)
X				return 1;
X			break;	
X		case '#':
X#ifdef DEBUG
X			putchar('#');
X#endif
X			i = atoi(++sp);
X			while(*sp != '\0' && *sp++ != ':');
X			ind = _findnumcode(name);
X			if (ind == -1)
X				break;
X			if (ct->nums[ind] != -2)
X				break;
X			ct->nums[ind] = i;
X			break;
X		default:
X			while(*sp != '\0' && *sp++ != ':');
X			if (*(dp - 1) == '@') {
X#ifdef DEBUG
X				putchar('@');
X#endif
X				*(dp - 1) = '\0';
X				ind = _findboolcode(name);
X				if (ind != -1) {
X#ifdef DEBUG
X					putchar('!');
X#endif
X					if (ct->bools[ind] == -1)
X						ct->bools[ind] = 0;
X					break;
X				}
X				ind = _findnumcode(name);
X				if (ind != -1) {
X#ifdef DEBUG
X					putchar('#');
X#endif
X					if (ct->nums[ind] == -2)
X						ct->nums[ind] = -1;
X					break;
X				}
X				ind = _findstrcode(name);
X				if (ind != -1) {
X#ifdef DEBUG
X					putchar('$');
X#endif
X					if (ct->strs[ind] == (char *) -1)
X						ct->strs[ind] = NULL;
X					break;
X				}
X				break;
X			}
X#ifdef DEBUG
X			putchar('!');
X#endif
X			ind = _findboolcode(name);
X			if (ind == -1)
X				break;
X			if (ct->bools[ind] != -1)
X				break;
X			ct->bools[ind] = 1;
X		}
X	}
X	return 0;
X}
END_OF_FILE
if test 5172 -ne `wc -c <'gettcap.c'`; then
    echo shar: \"'gettcap.c'\" unpacked with wrong size!
fi
# end of 'gettcap.c'
fi
if test -f 'gettinfo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gettinfo.c'\"
else
echo shar: Extracting \"'gettinfo.c'\" \(5541 characters\)
sed "s/^X//" >'gettinfo.c' <<'END_OF_FILE'
X/*
X * gettinfo.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:30:02
X *
X */
X
X#include "defs.h"
X#include "term.h"
X
X#include <ctype.h>
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo gettinfo.c 3.2 92/02/01 public domain, By Ross Ridge";
X#endif
X
int _gettinfo(sp, cur, path)
register char *sp;
struct term_path *path;
TERMINAL *cur; {
X	static char name[MAX_NAME];
X	static char entry[MAX_LINE];
X	register char *dp;
X	register TERMINAL *ct = cur;
X	int ind, i, base;
X	char c, flag;
X
X	dp = entry;
X	while(*sp != ',' && *sp != '\0')
X		*dp++ = *sp++;
X	if (ct->name_all == NULL) {
X		*dp = '\0';
X		if ((ct->name_all = _addstr(entry)) == NULL)
X			return 1;
X		while(dp > entry && *--dp != '|');
X		ct->name_long = ct->name_all + (dp - entry) + 1;
X	}
X
X 	while(*sp != '\0') {
X		while(*sp == ',')
X			sp++;
X		while(isspace(*sp))
X			sp++;
X		if (*sp == ',')
X			continue;
X		if (*sp == '\0')
X			break;
X		dp = name;
X		while (*sp != ',' && *sp != '#' && *sp != '=' && !isspace(*sp) && *sp != '\0')
X			*dp++ = *sp++;
X		*dp = '\0';
X#ifdef DEBUG
X		printf(" %s", name);
X#endif
X		switch(*sp) {
X		case '=':
X#ifdef DEBUG
X			putchar('$');
X#endif
X			dp = entry;
X			sp++;
X			ind = _findstrname(name);
X			if (ind != -1)
X				flag = _strflags[ind];
X			else {
X				ind = _findstrfname(name);
X				if (ind != -1)
X					flag = _strflags[ind];
X				else
X					flag = 'K';
X			}
X			while(*sp != '\0' && *sp != ',') {
X				switch(*sp) {
X				case '%':
X					*dp++ = *sp++;
X					if (*sp == '^' && flag == 'G')
X						*dp++ = *sp++;
X					break;
X				case '\\':
X					switch(*++sp) {
X					case 'e':
X					case 'E': *dp++ = '\033'; break;
X					case 'l': *dp++ = '\012'; break;
X					case 'n': *dp++ = '\n'; break;
X					case 'r': *dp++ = '\r'; break;
X					case 't': *dp++ = '\t'; break;
X					case 'b': *dp++ = '\b'; break;
X					case 'f': *dp++ = '\f'; break;
X					case 's': *dp++ = ' '; break;
X
X					case '^': 
X					case '\\':
X					case ',':
X					case ':':
X						*dp++ = *sp; break;
X
X					case '0':
X						if (!isdigit(*(sp + 1))) {
X							*dp++ = '\200';
X							break;
X						}
X						/* FALLTHROUGH */
X					case '1':
X					case '2':
X					case '3':
X					case '4':
X					case '5':
X					case '6':
X					case '7':
X						c = *sp - '0';
X						if (isdigit(sp[1]))
X							c = c * 8 + (*++sp-'0');
X						if (isdigit(sp[1]))
X							c = c * 8 + (*++sp-'0');
X						switch((char)c) {
X						case 0:
X							if (flag == 'K') 
X								*dp++ = '\200';
X							else {
X								*dp++ = '\\';
X								*dp++ = '0';
X								*dp++ = '0';
X								*dp++ = '0';
X							}
X							break;
X						case '$':
X						case '\'':
X						case '\\':
X							if (flag != 'K')
X								*dp++ = '\\';
X							/* FALLTHROUGH */
X						default:
X							if (flag == 'G'
X							    && c == '%')
X								*dp++ = '\\';
X							*dp++ = c;
X							break;
X						}
X						break;
X					default:
X						*dp++ = '\\';
X						*dp++ = *sp;
X						break;
X					}
X					sp++;
X					break;
X				case '^':
X					if (*++sp >= 'A' && *sp <= '_') {
X						*dp++ = *sp++ - '@';
X					} else if (*sp >= 'a' && *sp <= 'z') {
X						*dp++ = *sp++ - 'a' + 1;
X					} else if (*sp == '@') {
X						if (flag == 'K')
X							*dp++ = '\200';
X						else {
X							*dp++ = '\\';
X							*dp++ = '0';
X							*dp++ = '0';
X							*dp++ = '0';
X						}
X						sp++;
X					} else 
X						*dp++ = '^';
X					break;
X				default:
X					*dp++ = *sp++;
X					break;
X				}
X			}
X			*dp++ = '\0';
X			if (strcmp(name, "use") == 0) {
X				if (_getother(entry, path, ct))
X					return 1;
X				break;
X			}
X			if (ind == -1)
X				break;
X			if (ct->strs[ind] != (char *) -1)
X				break;
X			if ((ct->strs[ind] = _addstr(entry)) == NULL)
X				return 1;
X			break;	
X		case '#':
X#ifdef DEBUG
X			putchar('#');
X#endif
X#if 0
X			i = atoi(++sp);
X#else
X			sp++;
X			if (*sp == '0') {
X				sp++;
X				if (*sp == 'x' || *sp == 'X') {
X					sp++;
X					base = 16;
X				} else
X					base = 8;
X			} else
X				base = 10;
X			i = 0;
X			while(1) {
X				if (isdigit(*sp))
X					i = i * base + *sp - '0';
X				else if (base == 16 && isxdigit(*sp))
X					i = i * base + tolower(*sp) - 'a' + 10;
X				else
X					break;
X				sp++;
X			}
X#endif
X			while(*sp != '\0' && *sp != ',')
X				sp++;
X
X			ind = _findnumname(name);
X			if (ind != -1) {
X				if (ct->nums[ind] != -2)
X					break;
X				ct->nums[ind] = i;
X			} else {
X				ind = _findnumfname(name);
X				if (ind != -1) {
X					if (ct->nums[ind] != -2)
X						break;
X					ct->nums[ind] = i;
X				}
X			}
X			break;
X		default:
X			while(*sp != '\0' && *sp++ != ',');
X			if (*(dp - 1) == '@') {
X#ifdef DEBUG
X				putchar('@');
X#endif
X				*(dp - 1) = '\0';
X				ind = _findboolname(name);
X				if (ind != -1) {
X#ifdef DEBUG
X					putchar('!');
X#endif
X					ct->bools[ind] = 0;
X					break;
X				}
X				ind = _findnumname(name);
X				if (ind != -1) {
X#ifdef DEBUG
X					putchar('#');
X#endif
X					ct->nums[ind] = -1;
X					break;
X				}
X				ind = _findstrname(name);
X				if (ind != -1) {
X#ifdef DEBUG
X					putchar('$');
X#endif
X					ct->strs[ind] = NULL;
X					break;
X				}
X				ind = _findboolfname(name);
X				if (ind != -1) {
X#ifdef DEBUG
X					putchar('!');
X#endif
X					ct->bools[ind] = 0;
X					break;
X				}
X				ind = _findnumfname(name);
X				if (ind != -1) {
X#ifdef DEBUG
X					putchar('#');
X#endif
X					ct->nums[ind] = -1;
X					break;
X				}
X				ind = _findstrfname(name);
X				if (ind != -1) {
X#ifdef DEBUG
X					putchar('$');
X#endif
X					ct->strs[ind] = NULL;
X					break;
X				}
X				break;
X			}
X#ifdef DEBUG
X			putchar('!');
X#endif
X			ind = _findboolname(name);
X			if (ind == -1) {
X				ind = _findboolfname(name);
X				if (ind == -1)
X					break;
X			}
X			if (ct->bools[ind] != -1)
X				break;
X			ct->bools[ind] = 1;
X			break;
X		}
X	}
X	return 0;
X}
END_OF_FILE
if test 5541 -ne `wc -c <'gettinfo.c'`; then
    echo shar: \"'gettinfo.c'\" unpacked with wrong size!
fi
# end of 'gettinfo.c'
fi
if test -f 'qsort.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'qsort.c'\"
else
echo shar: Extracting \"'qsort.c'\" \(6250 characters\)
sed "s/^X//" >'qsort.c' <<'END_OF_FILE'
X/*
X * qsort.c
X *
X * This came from the GNU Emacs (18.55) tape.
X * Modified by Ross Ridge for use in mytinfo
X * 92/06/04 11:39:25
X *
X */
X
X#ifdef USE_MYQSORT
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo qsort.c 3.3 92/06/04 public domain, By Ross Ridge";
X#endif
X
X/*
X * qsort.c:
X * Our own version of the system qsort routine which is faster by an average
X * of 25%, with lows and highs of 10% and 50%.
X * The THRESHold below is the insertion sort threshold, and has been adjusted
X * for records of size 48 bytes.
X * The MTHREShold is where we stop finding a better median.
X */
X
X#define		THRESH		4		/* threshold for insertion */
X
X#define		MTHRESH		6		/* threshold for median */
X
X
X
static  int		qsz;			/* size of each record */
static  compar_fn	qcmp;			/* the comparison routine */
X
static  int		thresh;			/* THRESHold in chars */
static  int		mthresh;		/* MTHRESHold in chars */
X
X/*
X * qst:
X * Do a quicksort
X * First, find the median element, and put that one in the first place as the
X * discriminator.  (This "median" is just the median of the first, last and
X * middle elements).  (Using this median instead of the first element is a big
X * win).  Then, the usual partitioning/swapping, followed by moving the
X * discriminator into the right place.  Then, figure out the sizes of the two
X * partions, do the smaller one recursively and the larger one via a repeat of
X * this code.  Stopping when there are less than THRESH elements in a partition
X * and cleaning up with an insertion sort (in our caller) is a huge win.
X * All data swaps are done in-line, which is space-losing but time-saving.
X * (And there are only three places where this is done).
X */
static void
qst (base, max)
X     char *base; char *max;
X{
X  register char *i, *j, *jj, *mid;
X  register int ii, c;
X  char *tmp;
X  int lo, hi;
X
X  lo = max - base;	/* number of elements as chars */
X  do
X    {
X      /*
X       * At the top here, lo is the number of characters of elements in the
X       * current partition.  (Which should be max - base).
X       * Find the median of the first, last, and middle element and make that the
X       * middle element.  Set j to largest of first and middle.  If max is larger
X       * than that guy, then it's that guy, else compare max with loser of first
X       * and take larger.  Things are set up to prefer the middle, then the first
X       * in case of ties.
X       */
X      mid = i = base + qsz * ((lo/qsz) >> 1);
X      if (lo >= mthresh)
X	{
X	  j = ((*qcmp) ((anyptr)(jj = base), (anyptr)i) > 0 ? jj : i);
X	  if ((*qcmp) ((anyptr)j, (anyptr)(tmp = max - qsz)) > 0)
X	    {
X	      j = (j == jj ? i : jj);	/* switch to first loser */
X	      if ((*qcmp) ((anyptr)j, (anyptr)tmp) < 0)
X		j = tmp;
X	    }
X	  if (j != i)
X	    {
X	      ii = qsz;
X	      do
X		{
X		  c = *i;
X		  *i++ = *j;
X		  *j++ = c;
X		}
X	      while(  --ii  );
X	    }
X	}
X      /*
X       * Semi-standard quicksort partitioning/swapping
X       */
X      for (i = base, j = max - qsz; ;)
X	{
X	  while (i < mid && (*qcmp) ((anyptr)i, (anyptr)mid) <= 0)
X	    i += qsz;
X	  while (j > mid)
X	    {
X	      if ((*qcmp) ((anyptr)mid, (anyptr)j) <= 0)
X		{
X		  j -= qsz;
X		  continue;
X		}
X	      tmp = i + qsz;		/* value of i after swap */
X	      if (i == mid)
X		{	/* j <-> mid, new mid is j */
X		  mid = jj = j;
X		}
X	      else
X		{			/* i <-> j */
X		  jj = j;
X		  j -= qsz;
X		}
X	      goto  swap;
X	    }
X	  if (i == mid)
X	    {
X	      break;
X	    }
X	  else
X	    {				/* i <-> mid, new mid is i */
X	      jj = mid;
X	      tmp = mid = i;		/* value of i after swap */
X	      j -= qsz;
X	    }
X	swap:
X	  ii = qsz;
X	  do
X	    {
X	      c = *i;
X	      *i++ = *jj;
X	      *jj++ = c;
X	    }
X	  while (--ii);
X	  i = tmp;
X	}
X      /*
X       * Look at sizes of the two partitions, do the smaller one first by
X       * recursion, then do the larger one by making sure lo is its size,
X       * base and max are update correctly, and branching back.
X       * But only repeat (recursively or by branching) if the partition is
X       * of at least size THRESH.
X       */
X      i = (j = mid) + qsz;
X      if ((lo = j - base) <= (hi = max - i))
X	{
X	  if (lo >= thresh)
X	    qst (base, j);
X	  base = i;
X	  lo = hi;
X	}
X      else
X	{
X	  if (hi >= thresh)
X	    qst (i, max);
X	  max = j;
X	}
X    }
X  while (lo >= thresh);
X}
X
X
X/*
X * qsort:
X * First, set up some global parameters for qst to share.  Then, quicksort
X * with qst(), and then a cleanup insertion sort ourselves.  Sound simple?
X * It's not...
X */
static void
qsort (base, n, size, compar)
X     anyptr base;
X     unsigned n;
X     mysize_t size;
X     compar_fn compar;
X{
X  register char *i, *j, *lo, *hi, *min;
X  register int c;
X  char *max;
X
X  if (n <= 1)  return;
X  qsz = size / sizeof(char); /* of course if sizeof(char) aint one it had
X				better be an even divisor of size 	 */
X  qcmp = compar;
X  thresh = qsz*THRESH;
X  mthresh = qsz*MTHRESH;
X  max = (char *)base + n*qsz;
X  if (n >= THRESH)
X    {
X      qst ((char *)base, max);
X      hi = (char *)base + thresh;
X    }
X  else
X    {
X      hi = max;
X    }
X  /*
X   * First put smallest element, which must be in the first THRESH, in
X   * the first position as a sentinel.  This is done just by searching
X   * the first THRESH elements (or the first n if n < THRESH), finding
X   * the min, and swapping it into the first position.
X   */
X  for (j = lo = (char *)base; (lo += qsz) < hi; )
X    {
X      if ((*qcmp) ((anyptr)j, (anyptr)lo) > 0)
X	j = lo;
X    }
X  if (j != (char *)base)
X    {			/* swap j into place */
X      for (i = (char *)base, hi = (char *)base + qsz; i < hi;)
X	{
X	  c = *j;
X	  *j++ = *i;
X	  *i++ = c;
X	}
X    }
X  /*
X   * With our sentinel in place, we now run the following hyper-fast
X   * insertion sort.  For each remaining element, min, from [1] to [n-1],
X   * set hi to the index of the element AFTER which this one goes.
X   * Then, do the standard insertion sort shift on a character at a time
X   * basis for each element in the frob.
X   */
X  for (min = (char *)base; (hi = min += qsz) < max;)
X    {
X      while ( (*qcmp) ((anyptr)(hi -= qsz), (anyptr) min) > 0);
X      if ((hi += qsz) != min)
X	{
X	  for (lo = min + qsz; --lo >= min;)
X	    {
X	      c = *lo;
X	      for (i = j = lo; (j -= qsz) >= hi; i = j)
X		*i = *j;
X	      *i = c;
X	    }
X	}
X    }
X}
X
X
X#endif /* USE_MYQSORT */
END_OF_FILE
if test 6250 -ne `wc -c <'qsort.c'`; then
    echo shar: \"'qsort.c'\" unpacked with wrong size!
fi
# end of 'qsort.c'
fi
if test -f 'sprintf.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sprintf.c'\"
else
echo shar: Extracting \"'sprintf.c'\" \(8590 characters\)
sed "s/^X//" >'sprintf.c' <<'END_OF_FILE'
X/*
X * sprintf.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:30:16
X *
X */
X
X#include "defs.h"
X
X#include <ctype.h>
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo sprintf.c 3.2 92/02/01 public domain, By Ross Ridge";
X#endif
X
X#ifdef TEST
X#define USE_FAKE_STDIO
X#undef PRINTF
X#define sprintf _sprintf
X#endif
X
X#ifdef USE_FAKE_STDIO
X
X#ifdef PRINTF
X#undef putchar
X#define PUTCHAR(c) (cnt++, putchar(c))
X#else
X#define PUTCHAR(c) (*s++ = c)
X#endif
X
X#ifdef PRINTF
X#ifdef USE_STDARG
X#ifdef USE_PROTOTYPES
int
printf(char *fmt, ...) {
X#else
int printf(fmt)
char *fmt; {
X#endif
X#else
int printf(va_alist)
va_dcl {
X	register char *fmt;
X#endif
X	register int cnt;
X#else /* PRINTF */
X#ifdef lint
X/* VARARGS1 */
int
sprintf(str, fmt)
char *str;
char *fmt; {
X#else /* lint */
X#ifdef USE_STDARG
X#ifdef USE_PROTOTYPES
int sprintf(char *str, char *fmt, ...) {
X#else /* USE_PROTOTYPES */
int sprintf(str, fmt)
char *str;
char *fmt; {
X#endif /* else USE_PROTOTYPES */
X#else /* USE_STDARG */
int sprintf(va_alist)
va_dcl {
X	register char *fmt;
X	char *str;
X#endif /* else USE_STDARG */
X#endif /* else lint */
X	register char *s;
X#endif /* else PRINTF */
X	int minus;
X	int sharp;
X	int space;
X	int plus;
X	int zero;
X	int ell;
X	int prec;
X	int width;
X	int sign;
X	int pad;
X	char buf[100];
X	register long n;
X	register unsigned long u;
X	register char *d;
X	int l;
X	int k;
X	va_list args;
X
X#ifdef lint
X	args = (va_list) 0;
X#else
X#ifdef USE_STDARG
X	va_start(args, fmt);
X#else
X	va_start(args);
X#ifndef PRINTF
X	str = va_arg(args, char *);
X#endif
X	fmt = va_arg(args, char *);
X#endif
X#endif /* else lint */
X	
X
X#ifdef PRINTF
X	cnt = 0;
X#else
X	s = str;
X#endif
X
X	while(*fmt != '\0') {
X		if (*fmt == '%') {
X			fmt++;
X			if (*fmt == '%' || *fmt == '\0') {
X				PUTCHAR('%');
X				fmt++;
X				continue;
X			}
X			minus = plus = sharp = space = zero = ell = 0;
X			width = 0;
X			prec = -1;
X			do {
X				switch(*fmt) {
X				case '-': minus = 1; continue;
X				case '+': plus = 1; continue;
X				case ' ': space = 1; continue;
X				case '#': sharp = 1; continue;
X				}
X				break;
X			} while (*++fmt != '\0');
X			if (*fmt == '0') {
X				zero = 1;
X				fmt++;
X			}
X			if (*fmt == '*') {
X				width = va_arg(args, int);
X				fmt++;
X			} else if (isdigit(*fmt)) {
X				width = *fmt++ - '0';
X				while(isdigit(*fmt))
X					width = 10 * width + *fmt++ - '0';
X			}
X			if (*fmt == '.') {
X				prec = 0;
X				fmt++;
X				if (*fmt == '*') {
X					prec = va_arg(args, int);
X					fmt++;
X				} else {
X					while(isdigit(*fmt))
X						prec = 10 * prec + *fmt++ - '0';
X				}
X			}
X			if (*fmt == 'l') {
X				ell = 1;
X				fmt++;
X			}
X			sign = 0;
X			l = 0;
X			d = buf;
X			switch(*fmt) {
X			case 'd':
X			case 'i':
X				if (ell)
X					n = va_arg(args, long);
X				else
X					n = va_arg(args, int);
X				if (n < 0) {
X					sign = -1;
X					n = -n;
X				} else {
X					sign = 1;
X				}
X				while(n != 0) {
X					*d++ = (n % 10) + '0';
X					n /= 10;
X				}
X				break;
X			case 'o':
X				if (ell)
X					u = va_arg(args, unsigned long);
X				else
X					u = va_arg(args, unsigned );
X				while(u != 0) {
X					*d++ = (u & 7) + '0';
X					u >>= 3;
X				}
X				if (sharp)
X					l = 1;
X				break;
X			case 'u':
X				if (ell)
X					u = va_arg(args, unsigned long);
X				else
X					u = va_arg(args, unsigned );
X				while(u != 0) {
X					*d++ = (u % 10) + '0';
X					u /= 10;
X				}
X				break;
X			case 'x':
X				if (ell)
X					u = va_arg(args, unsigned long);
X				else
X					u = va_arg(args, unsigned );
X				while(u != 0) {
X					*d++ = "0123456789abcdef"[u & 15];
X					u >>= 4;
X				}
X				if (sharp)
X					l += 2;
X				break;
X			case 'X':
X				if (ell)
X					u = va_arg(args, unsigned long);
X				else
X					u = va_arg(args, unsigned );
X				while(u != 0) {
X					/* just to be silly... */
X					*d++ = (u & 15)["0123456789ABCDEF"];
X					u >>= 4;
X				}
X				if (sharp)
X					l += 2;
X				break;
X			case 's':
X				d = va_arg(args, char *);
X				l = strlen(d);
X				break;
X			case 'c':
X				buf[0] = va_arg(args, int);
X				l = 1;
X				break;
X			default:
X				PUTCHAR(*fmt++);
X				continue;
X			}
X			if (*fmt == 's' || *fmt == 'c') {
X				if (prec != -1 && l > prec) 
X					l = prec;
X				pad = width - l;
X				if (zero) 
X					while(pad-- > 0)
X						PUTCHAR('0');
X				else if (!minus)
X					while(pad-- > 0)
X						PUTCHAR(' ');
X				while(l-- > 0)
X					PUTCHAR(*d++);
X				if (minus)
X					while(pad-- > 0)
X						PUTCHAR(' ');
X			} else {
X				if (prec == -1)
X					prec = 1;
X				k = d - buf;
X				if (k < prec)
X					l += prec;
X				else
X					l += k;
X				if (sign == -1)
X					l++;
X				else if (sign == 1 && (space || plus))
X					l++;
X				pad = width - l;
X				if (zero)
X					while(pad-- > 0)
X						PUTCHAR('0');
X				else if (!minus)
X					while(pad-- > 0)
X						PUTCHAR(' ');
X				if (*fmt == 'x' && sharp) {
X					PUTCHAR('0');
X					PUTCHAR('x');
X				} else if (*fmt == 'X' && sharp) {
X					PUTCHAR('0');
X					PUTCHAR('X');
X				} else if (*fmt == 'o' && sharp) {
X					PUTCHAR('0');
X				} else if (sign == -1) {
X					PUTCHAR('-');
X				} else if (sign == 1 && space) {
X					PUTCHAR(' ');
X				} else if (sign == 1 && plus) {
X					PUTCHAR('+');
X				}
X				while(k++ < prec)
X					PUTCHAR('0');
X				while(d > buf)
X					PUTCHAR(*--d);
X				if (!zero && minus)
X					while(pad-- > 0)
X						PUTCHAR(' ');
X			}
X			fmt++;
X		} else {
X			PUTCHAR(*fmt++);
X		}
X	}
X#ifdef PRINTF
X	return cnt;
X#else
X	*s = '\0';
X	return s - str;
X#endif
X}
X
X#endif /* USE_FAKE_STDIO */
X
X#ifdef TEST
X#ifndef PRINTF
X#undef sprintf
main(argc, argv)
int argc;
char *argv; {
X	char buf[256];
X
X	_sprintf(buf, "%d", 2);
X	printf("'%s'\n", buf);
X	sprintf(buf, "%d", 2);
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%05d", 2);
X	printf("'%s'\n", buf);
X	sprintf(buf, "%05d", 2);
X	printf("'%s'\n", buf);
X	_sprintf(buf, "% 5d", 2);
X	printf("'%s'\n", buf);
X	sprintf(buf, "% 5d", 2);
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%-5d", 2);
X	printf("'%s'\n", buf);
X	sprintf(buf, "%-5d", 2);
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%5.3d", 2);
X	printf("'%s'\n", buf);
X	sprintf(buf, "%5.3d", 2);
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%+d", 2);
X	printf("'%s'\n", buf);
X	sprintf(buf, "%+d", 2);
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%#-1.2d", 2);
X	printf("'%s'\n", buf);
X	sprintf(buf, "%#-1.2d", 2);
X	printf("'%s'\n", buf);
X	_sprintf(buf, "% 5d", -2);
X	printf("'%s'\n", buf);
X	sprintf(buf, "% 5d", -2);
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%-5d", -2);
X	printf("'%s'\n", buf);
X	sprintf(buf, "%-5d", -2);
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%5.3d", -2);
X	printf("'%s'\n", buf);
X	sprintf(buf, "%5.3d", -2);
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%%:%o:%x:%X:%ld:%u:%i", 10, 22, 333, -456L, 50000, 6);
X	printf("'%s'\n", buf);
X	sprintf(buf, "%%:%o:%x:%X:%ld:%u:%i", 10, 22, 333, -456L, 50000, 6);
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%06o:%#6x:%#012.4X:%-5ld:%*u:%*.*i",
X		10, 22, 333, -456L, 8, 50000, 4, 2, 6);
X	printf("'%s'\n", buf);
X	sprintf(buf, "%06o:%#6x:%#012.4X:%-5ld:%*u:%*.*i",
X		10, 22, 333, -456L, 8, 50000, 4, 2, 6);
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%s", "abcdefghi");
X	printf("'%s'\n", buf);
X	sprintf(buf, "%s", "abcdefghi");
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%.4s", "abcdefghi");
X	printf("'%s'\n", buf);
X	sprintf(buf, "%.4s", "abcdefghi");
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%4.4s", "abcdefghi");
X	printf("'%s'\n", buf);
X	sprintf(buf, "%4.4s", "abcdefghi");
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%20s", "abcdefghi");
X	printf("'%s'\n", buf);
X	sprintf(buf, "%20s", "abcdefghi");
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%-20s", "abcdefghi");
X	printf("'%s'\n", buf);
X	sprintf(buf, "%-20s", "abcdefghi");
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%-20.20s", "abcdefghi");
X	printf("'%s'\n", buf);
X	sprintf(buf, "%-20.20s", "abcdefghi");
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%#-0.20s", "abcdefghi");
X	printf("'%s'\n", buf);
X	sprintf(buf, "%#-0.20s", "abcdefghi");
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%5s", "abcdefghi");
X	printf("'%s'\n", buf);
X	sprintf(buf, "%5s", "abcdefghi");
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%015s", "abcdefghi");
X	printf("'%s'\n", buf);
X	sprintf(buf, "%015s", "abcdefghi");
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%c", 'C');
X	printf("'%s'\n", buf);
X	sprintf(buf, "%c", 'C');
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%5c", 'C');
X	printf("'%s'\n", buf);
X	sprintf(buf, "%5c", 'C');
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%-5c", 'C');
X	printf("'%s'\n", buf);
X	sprintf(buf, "%-5c", 'C');
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%d", 0);
X	printf("'%s'\n", buf);
X	sprintf(buf, "%d", 0);
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%.d", 0);
X	printf("'%s'\n", buf);
X	sprintf(buf, "%.d", 0);
X	printf("'%s'\n", buf);
X	_sprintf(buf, "%5.0d", 0);
X	printf("'%s'\n", buf);
X	sprintf(buf, "%5.0d", 0);
X	printf("'%s'\n", buf);
X}
X#endif /* !PRINTF */
X#endif /* TEST */
END_OF_FILE
if test 8590 -ne `wc -c <'sprintf.c'`; then
    echo shar: \"'sprintf.c'\" unpacked with wrong size!
fi
# end of 'sprintf.c'
fi
if test -f 'tcapconv.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tcapconv.c'\"
else
echo shar: Extracting \"'tcapconv.c'\" \(4663 characters\)
sed "s/^X//" >'tcapconv.c' <<'END_OF_FILE'
X/*
X * tcapconv.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:30:20
X *
X */
X
X#include "defs.h"
X#define SINGLE
X#include "term.h"
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo tcapconv.c 3.2 92/02/01 public domain, By Ross Ridge";
X#endif
X
extern char **_sstrcodes[], **_sstrnames[];
X
static char *C_CR = "\r";
static char *C_LF = "\n";
static char *C_BS = "\b";
X/* static char *C_FF = "\f"; */
static char *C_HT = "\t";
X/* static char *C_VT = "\013"; */
X/* static char *C_NL = "\r\n"; */
X
X#define DEF(s) ((s) != (char *) -1 && (s) != NULL)
X#define NOTSET(s) ((s) == (char *) -1)
X
X/*
X * This routine fills in caps that either had defaults under termcap or
X * can be manufactured from obsolete termcap capabilities. 
X */
X
void
X_tcapdefault() {
X	char buf[MAX_LINE * 2 + 2];
X
X	if (NOTSET(carriage_return)) {
X		if (carriage_return_delay > 0) {
X			sprintf(buf, "%s$<%d>", C_CR, carriage_return_delay);
X			carriage_return = _addstr(buf);
X		} else
X			carriage_return = _addstr(C_CR);
X	}
X	if (NOTSET(cursor_left)) {
X		if (backspace_delay > 0) {
X			sprintf(buf, "%s$<%d>", C_BS, backspace_delay);
X			cursor_left = _addstr(buf);
X		} else if (backspaces_with_bs == 1)
X			cursor_left = _addstr(C_BS);
X		else if (DEF(backspace_if_not_bs))
X			cursor_left = _addstr(backspace_if_not_bs);
X	}
X/* vi doesn't use "do", but it does seems to use nl (or '\n') instead */
X	if (NOTSET(cursor_down)) {
X		if (DEF(linefeed_if_not_lf)) 
X			cursor_down = _addstr(linefeed_if_not_lf);
X		else if (linefeed_is_newline != 1) {
X			if (new_line_delay > 0) {
X				sprintf(buf, "%s$<%d>", C_LF, new_line_delay);
X				cursor_down = _addstr(buf);
X			} else
X				cursor_down = _addstr(C_LF);
X		}
X	}
X	if (NOTSET(scroll_forward) && crt_without_scrolling != 1) {
X		if (DEF(linefeed_if_not_lf)) 
X			cursor_down = _addstr(linefeed_if_not_lf);
X		else if (linefeed_is_newline != 1) {
X			if (new_line_delay > 0) {
X				sprintf(buf, "%s$<%d>", C_LF, new_line_delay);
X				scroll_forward = _addstr(buf);
X			} else
X				scroll_forward = _addstr(C_LF);
X		}
X	}
X	if (NOTSET(newline)) {
X		if (linefeed_is_newline == 1) {
X			if (new_line_delay > 0) {
X				sprintf(buf, "%s$<%d>", C_LF, new_line_delay);
X				newline = _addstr(buf);
X			} else
X				newline = _addstr(C_LF);
X		} else if (DEF(carriage_return) && DEF(scroll_forward)) {
X			strncpy(buf, carriage_return, MAX_LINE-2);
X			buf[MAX_LINE-1] = '\0';
X			strncat(buf, scroll_forward, MAX_LINE-strlen(buf)-1);
X			buf[MAX_LINE] = '\0';
X			newline = _addstr(buf);
X		} else if (DEF(carriage_return) && DEF(cursor_down)) {
X			strncpy(buf, carriage_return, MAX_LINE-2);
X			buf[MAX_LINE-1] = '\0';
X			strncat(buf, cursor_down, MAX_LINE-strlen(buf)-1);
X			buf[MAX_LINE] = '\0';
X			newline = _addstr(buf);
X		}
X	}
X
X/*
X * We wait until know to decide if we've got a working cr because even
X * one that doesn't work can be used for newline. Unfortunately the
X * space allocated for it is wasted.
X */
X	if (return_does_clr_eol == 1 || no_correctly_working_cr == 1)
X		carriage_return = NULL;
X
X/*
X * supposedly most termcap entries have ta now and '\t' is no longer a
X * default, but it doesn't seem to be true...
X */
X	if (NOTSET(tab)) {
X		if (horizontal_tab_delay > 0) {
X			sprintf(buf, "%s$<%d>", C_HT, horizontal_tab_delay);
X			tab = _addstr(buf);
X		} else
X			tab = _addstr(C_HT);
X	}
X#if 0
X/* probably not needed and might confuse some programmes */
X	if (NOTSET(form_feed)) {
X		if (form_feed_delay > 0) {
X			sprintf(buf, "%s$<%d>", C_FF, form_feed_delay);
X			form_feed = _addstr(buf);
X		} else
X			form_feed = _addstr(C_FF);
X	}
X#endif
X	if (init_tabs == -1 && has_hardware_tabs == 1)
X		init_tabs = 8;
X
X	if (NOTSET(key_backspace))
X		key_backspace = _addstr(C_BS);
X	if (NOTSET(key_left))
X		key_left = _addstr(C_BS);
X	if (NOTSET(key_down))
X		key_down = _addstr(C_LF);
X}
X
void
X_tcapconv() {
X	char buf[MAX_LINE+1];
X
X	if (GNU_tab_width > 0 && init_tabs == -1)
X		init_tabs = GNU_tab_width;
X
X	if (GNU_has_meta_key == 1 && has_meta_key == -1)
X		has_meta_key = 1;
X
X/*
X * this is some what a kludge, but should work unless someone breaks
X * conventions.
X */
X	if (DEF(other_non_function_keys)) {
X		register char *s;
X		static char *o;
X		static char name[MAX_NAME] = "k";
X		char *str;
X		int ind;
X
X		s = strcpy(buf, other_non_function_keys);
X		while(*s != '\0') {
X			o = s;
X			while(*s != ',' && *s != '\0')
X				s++;
X			if (*s != '\0')
X				*s++ = '\0';
X			ind = _findstrcode(o);
X			if (ind == -1)
X				continue;
X			str = _term_buf.strs[ind];
X			if (!DEF(str))
X				continue;
X			strncpy(name + 1, strnames[ind], MAX_NAME - 2);
X			ind = _findstrname(name);
X			if (ind == -1)
X				continue;
X			if (!NOTSET(_term_buf.strs[ind]))
X				continue;
X			_term_buf.strs[ind] = _addstr(str);
X		}
X	}
X}
END_OF_FILE
if test 4663 -ne `wc -c <'tcapconv.c'`; then
    echo shar: \"'tcapconv.c'\" unpacked with wrong size!
fi
# end of 'tcapconv.c'
fi
if test -f 'ttest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ttest.c'\"
else
echo shar: Extracting \"'ttest.c'\" \(5057 characters\)
sed "s/^X//" >'ttest.c' <<'END_OF_FILE'
X/*
X * ttest.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:30:47
X *
X */
X 
X#define NOTLIB
X#include "defs.h"
X#include "term.h"
X
static const char SCCSid[] = "@(#) mytinfo ttest.c 3.2 92/02/01 public domain, By Ross Ridge";
X
int
cup(x,y)
int x, y; {
X	if (columns < 2 || lines < 2)
X		return -1;
X	if (cursor_address != NULL) 
X		putp(tparm(cursor_address, y, x));
X	else if (cursor_home != NULL && cursor_down != NULL
X		 && cursor_right != NULL) {
X		putp(cursor_home);
X		if (parm_down_cursor != NULL)
X			putp(tparm(parm_down_cursor, y));
X		else
X			for(; y > 0; y--)
X				putp(cursor_down);
X		if (parm_right_cursor != NULL)
X			putp(tparm(parm_right_cursor, y));
X		else
X			for(; y > 0; y--)
X				putp(cursor_right);
X	} else if (cursor_to_ll != NULL && cursor_up != NULL
X		   && cursor_right != NULL) {
X		putp(cursor_to_ll);
X		if (parm_up_cursor != NULL)
X			putp(tparm(parm_up_cursor, y));
X		else
X			for(y++; y < columns ; y++)
X				putp(cursor_up);
X		if (parm_right_cursor != NULL)
X			putp(tparm(parm_right_cursor, y));
X		else
X			for(; y > 0; y--)
X				putp(cursor_right);
X	} else
X		return 1;
X	return 0;
X}
X
int
clear() {
X	int r;
X	if (clear_screen != NULL)
X		putp(clear_screen);
X	else if (clr_eos != NULL) {
X		r = cup(0,0);
X		if (r != 0)
X			return r;
X		putp(clr_eos);
X	} else
X		return -2;
X	return 0;
X}
X
void
nl() {
X	if (newline != NULL) 
X		putp(newline);
X	else if (carriage_return != NULL && cursor_down != NULL) {
X		putp(cursor_down);
X		putp(carriage_return);
X	} else 
X		quit(-1, "can't do a newline");
X	return;
X}
X
void
putln(s)
char *s; {
X	int i;
X
X	if (columns < 2 || auto_right_margin)
X		fputs(s, stdout);
X	else {
X		i = 0;
X		while(*s) {
X			putchar(*s);
X			s++;
X			if (++i == columns) {
X				nl();
X				i = 0;
X			}
X		}
X	}
X	nl();
X}
X
void
anykey() {
X	fputs("-- press any key --", stdout);
X	fflush(stdout);
X	getchar();
X	nl();
X}
X
void
do_cleanup(e)
int e; {
X	fflush(stdout);
X	fflush(stderr);
X	reset_shell_mode();
X	fprintf(stderr, "\n");
X}
X
X#ifdef USE_SGTTY
struct sgttyb new_tty;
X#else
struct termio new_tty;
X#endif
X
int
main(argc, argv)
int argc;
char **argv; {
X	int r;
X	register int i;
X
X	prg_name = argv[0];
X	cleanup = do_cleanup;
X
X	if (argc == 1)
X		setupterm(NULL, 1, (int *) 0);
X	else if (argc == 2)
X		setupterm(argv[1], 1, (int *) 0);
X	else {
X		fprintf(stderr, "usage: %s [terminal]\n", argv[0]);
X		return 1;
X	}
X	fflush(stderr);
X	fflush(stdout);
X#ifdef USE_SGTTY
X	ioctl(1, TIOCGETP, &new_tty);
X	new_tty.sg_flags &= ~(CRMOD | ECHO | XTABS);
X#ifdef CBREAK
X	new_tty.sg_flags |= CBREAK;
X#else
X	new_tty.sg_flags |= RAW;
X#endif
X	ioctl(1, TIOCSETP, &new_tty);
X#endif
X#ifdef USE_TERMIO
X	ioctl(1, TCGETA, &new_tty);
X	new_tty.c_lflag &= ~(ICANON | ECHO);
X	new_tty.c_oflag &= ~(OPOST);
X	new_tty.c_cc[VMIN] = 1;
X	new_tty.c_cc[VTIME] = 1;
X	ioctl(1, TCSETA, &new_tty);
X#endif
X	def_prog_mode();
X	
X	clear();
X	printf("columns = %d", columns);
X	nl();
X	printf("lines = %d", lines);
X	if (columns < 2)
X		quit(-1, "columns must be > 1");
X	nl();
X	anykey();
X	nl();
X	if (auto_right_margin) {
X		putln("auto_right_margin = TRUE");
X		nl();
X		for(i = 0; i < columns; i++)
X			putchar('1');
X		for(i = 0; i < columns / 2; i++)
X			putchar('2');
X		nl();
X	} else {
X		putln("auto_right_margin = FALSE");
X		nl();
X		for(i = 0; i < columns + columns / 2; i++)
X			putchar('1');
X		nl();
X		for(i = 0; i < columns / 2; i++)
X			putchar('2');
X		nl();
X	}
X	nl();
X	putln("***a line of 1's followed by a line of 2's");
X	nl();
X	anykey();
X	nl();
X
X	if (over_strike) {
X		putln("over_strike = TRUE");
X		if (cursor_left != NULL) {
X			for(i = 0; i < columns / 4 + 1; i++) {
X				putchar('/');
X				putp(cursor_left);
X				putchar('\\');
X			}
X		} else if (carriage_return != NULL) {
X			for(i = 0; i < columns / 4 + 1; i++) 
X				putchar('/');
X			putp(carriage_return);
X			for(i = 0; i < columns / 4 + 1; i++) 
X				putchar('\\');
X		}
X		nl();
X		nl();
X		putln("*** X's made from \\'s overstriking /'s");
X		nl();
X		anykey();
X		nl();
X	}
X
X	if (cup(0,0) == 0) {
X		clear();
X		putln("cup test");
X		for(i = 1; i < columns; i++)
X			putp(tparm(cursor_address, 0, i));
X		for(i = 0; i < lines; i++)
X			putp(tparm(cursor_address, i, columns - 1));
X		for(i = columns; i--;)
X			putp(tparm(cursor_address, lines - 1, i));
X		for(i = lines; i--;)
X			putp(tparm(cursor_address, i, 0));
X		nl();
X		anykey();
X	}
X	clear();
X
X	putln("Attribute test");
X	nl();
X	if (enter_blink_mode != NULL) {
X		putp(enter_blink_mode);
X		printf("blink");
X		putp(exit_attribute_mode);
X		nl();
X	}
X	if (enter_bold_mode != NULL) {
X		putp(enter_bold_mode);
X		printf("bold");
X		putp(exit_attribute_mode);
X		nl();
X	}
X	if (enter_dim_mode != NULL) {
X		putp(enter_dim_mode);
X		printf("dim");
X		putp(exit_attribute_mode);
X		nl();
X	}
X	if (enter_reverse_mode != NULL) {
X		putp(enter_reverse_mode);
X		printf("reverse");
X		putp(exit_attribute_mode);
X		nl();
X	}
X	if (enter_standout_mode != NULL) {
X		putp(enter_standout_mode);
X		printf("standout");
X		putp(exit_standout_mode);
X		nl();
X	}
X	if (enter_underline_mode != NULL) {
X		putp(enter_underline_mode);
X		printf("underline");
X		putp(exit_underline_mode);
X		nl();
X	}
X	nl();
X	anykey();
X
X	clear();
X	reset_shell_mode();
X	
X	return (0);
X}
END_OF_FILE
if test 5057 -ne `wc -c <'ttest.c'`; then
    echo shar: \"'ttest.c'\" unpacked with wrong size!
fi
# end of 'ttest.c'
fi
if test -f 'tty.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tty.c'\"
else
echo shar: Extracting \"'tty.c'\" \(7701 characters\)
sed "s/^X//" >'tty.c' <<'END_OF_FILE'
X/*
X * tty.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:30:49
X *
X * Do some tty related things
X *
X */
X
X#include "defs.h"
X#include "term.h"
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo tty.c 3.2 92/02/01 public domain, By Ross Ridge";
X#endif
X#ifndef EXTA_IS
X#define EXTA_IS 19200
X#endif
X
X#ifndef EXTB_IS
X#define EXTB_IS 38400
X#endif
X
X#ifdef lint
X#define ioctl _ioctl
X/* shutup lint */
X/* ARGSUSED */
X/* VARARGS1 */
static int ioctl(a, b, p) int a; long b; anyptr *p;  { return 0; }
X#endif
X
X#ifdef USE_TERMIO
X
X#ifdef USE_SMALLMEM
unsigned short _baud_tbl[] = {0, 50, 75, 110, 134, 150, 200, 300, 600, 1200,
X			      1800, 2400, 4800, 9600, EXTA_IS, EXTB_IS};
X#else
long _baud_tbl[] = {0, 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800,
X		    2400, 4800, 9600, EXTA_IS, EXTB_IS};
X#endif
X
static struct termio old;
X
int
X_lit_output() {
X	struct termio tmp;
X	if (ioctl(cur_term->fd, TCGETA, &old) == -1)
X		return 0;
X	if (!(old.c_oflag & OPOST) || !(old.c_oflag & ONLCR)) 
X		return 0;
X	memcpy((anyptr)&tmp, (anyptr)&old, sizeof(old));
X	tmp.c_oflag &= ~OPOST;
X	ioctl(cur_term->fd, TCSETA, &tmp);
X	return 1;
X}
X
void
X_norm_output() {
X	ioctl(cur_term->fd, TCSETA, &old);
X}
X	
int
X_check_tty() {
X	if ((cur_term->prog_mode.c_iflag & IXON) && cur_term->xon)
X		cur_term->pad = 0;
X	else
X		cur_term->pad = 1;
X	cur_term->baudrate = _baud_tbl[cur_term->prog_mode.c_cflag & CBAUD];
X	return OK;
X}
X
int
def_prog_mode() {
X#ifdef USE_WINSZ
X#ifdef TIOCGWINSZ
X	if (ioctl(cur_term->fd, TIOCGWINSZ, &cur_term->prog_winsz) < 0)
X		return ERR;
X#endif
X#endif
X	if (ioctl(cur_term->fd, TCGETA, &cur_term->prog_mode) == 0
X            && _check_tty() == OK)
X		return OK;
X	return ERR;
X}
X
int
def_shell_mode() {
X	cur_term->termcap = 0;
X#ifdef USE_WINSZ
X#ifdef TIOCGWINSZ
X	if (ioctl(cur_term->fd, TIOCGWINSZ, &cur_term->shell_winsz) < 0)
X		return ERR;
X#endif
X#endif
X	return ioctl(cur_term->fd, TCGETA, &cur_term->shell_mode)==0 ? OK : ERR;
X}
X
int
reset_prog_mode() {
X	return ioctl(cur_term->fd, TCSETA, &cur_term->prog_mode)==0 ? OK : ERR;
X}
X
int
reset_shell_mode() {
X	return ioctl(cur_term->fd, TCSETA, &cur_term->shell_mode)==0 ? OK : ERR;
X}
X
int
X_init_tty() {
X	cur_term->true_lines = lines;
X	cur_term->true_columns = columns;
X	if (pad_char == NULL)
X		cur_term->padch = '\000';
X	else
X		cur_term->padch = pad_char[0];
X	if (def_shell_mode() == ERR || def_prog_mode() == ERR) {
X		cur_term->pad = 0;
X		cur_term->baudrate = 1;
X		cur_term->xon = 0;
X		return OK;
X	}
X	cur_term->xon = (xoff_character == NULL || xoff_character[0] == '\021')
X			&& (xon_character == NULL || xon_character[0] == '\023')
X			&& xon_xoff;
X#ifdef USE_WINSZ
X#ifdef TIOCGWINSZ
X	if (cur_term->prog_winsz.ws_row != 0
X	    && cur_term->prog_winsz.ws_col != 0) {
X		lines = cur_term->prog_winsz.ws_row;
X		columns = cur_term->prog_winsz.ws_col;
X	}
X#endif
X#endif
X	return OK;
X}
X
X#else
X
X#ifdef USE_SGTTY
X
X#ifdef USE_SMALLMEM
unsigned short _baud_tbl[] = {0, 50, 75, 110, 134, 150, 200, 300, 600, 1200,
X			      1800, 2400, 4800, 9600, EXTA_IS, EXTB_IS};
X#else
long _baud_tbl[] = {0, 50, 75, 110, 134, 150, 200, 300, 600, 1200,
X		    1800, 2400, 4800, 9600, EXTA_IS, EXTB_IS};
X#endif
X
X
X#ifdef TIOCLGET
X
static int old;
X
int
X_lit_output() {
X	struct sgttyb buf;
X	int tmp;
X
X	ioctl(cur_term->fd, TIOCGETP, &buf);
X	if (buf.sg_flags & RAW)
X		return 0;
X	ioctl(cur_term->fd, TIOCLGET, &old);
X	if (old & LLITOUT)
X		return 0;
X	tmp = old | LLITOUT;
X	ioctl(cur_term->fd, TIOCLSET, &tmp);
X	return 1;
X}
X
void
X_norm_output() {
X	ioctl(cur_term->fd, TIOCLSET, &old);
X}
X
X#else
X
static struct sgttyb old;
X
int
X_lit_output() {
X	struct sgttyb tmp;
X	ioctl(cur_term->fd, TIOCGETP, &old);
X	if (old.sg_flags & RAW)
X		return 0;
X	memcpy((anyptr)&tmp, (anyptr)&old, sizeof(old));
X	tmp.sg_flags |= RAW;
X	ioctl(cur_term->fd, TIOCSETP, &tmp);
X	return 1;
X}
X
void
X_norm_output() {
X	ioctl(cur_term->fd, TIOCSETP, &old);
X}
X
X#endif 
X
int
X_check_tty() {
X	if (!(cur_term->prog_mode.v6.sg_flags & RAW) && cur_term->xon)
X		cur_term->pad = 0;
X	else
X		cur_term->pad = 1;
X	cur_term->baudrate = _baud_tbl[cur_term->prog_mode.v6.sg_ospeed & 0xf];
X	return OK;
X}
X
int
def_shell_mode() {
X	if (ioctl(cur_term->fd, TIOCGETP, &cur_term->shell_mode.v6) < 0)
X		return ERR;
X#ifdef TIOCGETC
X	if (ioctl(cur_term->fd, TIOCGETC, &cur_term->shell_mode.v7) < 0)
X		return ERR;
X#endif
X#ifdef TIOCLGET
X	if (ioctl(cur_term->fd, TIOCLGET, &cur_term->shell_mode.bsd) < 0)
X		return ERR;
X#endif
X#ifdef TIOCGLTC
X	if (ioctl(cur_term->fd, TIOCGLTC, &cur_term->shell_mode.bsd_new) < 0)
X		return ERR;
X#endif
X#ifdef USE_WINSZ
X#ifdef TIOCGWINSZ
X	if (ioctl(cur_term->fd, TIOCGWINSZ, &cur_term->shell_winsz)<0)
X		return ERR;
X#endif
X#endif
X	cur_term->termcap = 0;
X	return OK;
X}
X
int
def_prog_mode() {
X	if (ioctl(cur_term->fd, TIOCGETP, &cur_term->prog_mode.v6) < 0)
X		return ERR;
X#ifdef TIOCGETC
X	if (ioctl(cur_term->fd, TIOCGETC, &cur_term->prog_mode.v7) < 0)
X		return ERR;
X#endif
X#ifdef TIOCLGET
X	if (ioctl(cur_term->fd, TIOCLGET, &cur_term->prog_mode.bsd) < 0)
X		return ERR;
X#endif
X#ifdef TIOCGLTC
X	if (ioctl(cur_term->fd, TIOCGLTC, &cur_term->prog_mode.bsd_new) < 0)
X		return ERR;
X#endif
X#ifdef USE_WINSZ
X#ifdef TIOCGWINSZ
X	if (ioctl(cur_term->fd, TIOCGWINSZ, &cur_term->prog_winsz)<0)
X		return ERR;
X#endif
X#endif
X	return _check_tty();
X}
X
int
reset_shell_mode() {
X	if (ioctl(cur_term->fd, TIOCSETP, &cur_term->shell_mode.v6) < 0)
X		return ERR;
X#ifdef TIOCGETC
X	if (ioctl(cur_term->fd, TIOCSETC, &cur_term->shell_mode.v7) < 0)
X		return ERR;
X#endif
X#ifdef TIOCLGET
X	if (ioctl(cur_term->fd, TIOCLSET, &cur_term->shell_mode.bsd) < 0)
X		return ERR;
X#endif
X#ifdef TIOCGLTC
X	if (ioctl(cur_term->fd, TIOCSLTC, &cur_term->shell_mode.bsd_new) < 0)
X		return ERR;
X#endif
X	return OK;
X}
X
int
reset_prog_mode() {
X	if (ioctl(cur_term->fd, TIOCSETP, &cur_term->prog_mode.v6) < 0)
X		return ERR;
X#ifdef TIOCGETC
X	if (ioctl(cur_term->fd, TIOCSETC, &cur_term->prog_mode.v7) < 0)
X		return ERR;
X#endif
X#ifdef TIOCLGET
X	if (ioctl(cur_term->fd, TIOCLSET, &cur_term->prog_mode.bsd) < 0)
X		return ERR;
X#endif
X#ifdef TIOCGLTC
X	if (ioctl(cur_term->fd, TIOCSLTC, &cur_term->prog_mode.bsd_new) < 0)
X		return ERR;
X#endif
X	return OK;
X}
X
int
X_init_tty() {
X	cur_term->true_lines = lines;
X	cur_term->true_columns = columns;
X	if (pad_char == NULL)
X		cur_term->padch = '\000';
X	else
X		cur_term->padch = pad_char[0];
X	if (def_shell_mode() == ERR || def_prog_mode() == ERR) {
X		cur_term->pad = 0;
X		cur_term->baudrate = 1;
X		cur_term->xon = 0;
X		return OK;
X	}
X#ifndef TIOCGETC
X	cur_term->xon = (xoff_character == NULL || xoff_character[0] == '\021')
X			&& (xon_character == NULL || xon_character[0] == '\023')
X		        && xon_xoff;
X#else
X	if (xon_xoff) {
X		if (xon_character != NULL) {
X			cur_term->prog_mode.v7.t_startc = xon_character[0];
X			if (ioctl(cur_term->fd, TIOCSETC,
X			    &cur_term->prog_mode.v7) < 0)
X				return ERR;
X		}
X		if (xoff_character != NULL) {
X			cur_term->prog_mode.v7.t_stopc = xoff_character[0];
X			if (ioctl(cur_term->fd, TIOCSETC,
X			          &cur_term->prog_mode.v7) < 0)
X				return ERR;
X		}
X	}
X	cur_term->xon = xon_xoff;
X#endif
X#ifdef USE_WINSZ
X#ifdef TIOCGWINSZ
X	if (cur_term->prog_winsz.ws_row != 0
X	    && cur_term->prog_winsz.ws_col != 0) {
X		lines = cur_term->prog_winsz.ws_row;
X		columns = cur_term->prog_winsz.ws_col;
X	}
X#endif
X#endif
X	return OK;
X}
X
X#else
X
int
X_lit_output() {
X	return 0;
X}
X
void
X_norm_output() {
X	return;
X}
X
int
X_check_tty() {
X	return OK;
X}
X
int
def_prog_mode() {
X	return OK;
X}
X
int
reset_prog_mode() {
X	return OK;
X}
X
int
def_shell_mode() {
X	return OK;
X}
X
int
reset_shell_mode() {
X	return OK;
X}
X
int
X_init_tty() {
X	cur_term->pad = 1;
X	cur_term->padch = 0;
X	cur_term->baudrate = 1200;
X	cur_term->xon = 0;
X	cur_term->termcap = 0;
X	cur_term->true_lines = lines;
X	cur_term->true_columns = columns;
X}
X
X#endif
X
X#endif
END_OF_FILE
if test 7701 -ne `wc -c <'tty.c'`; then
    echo shar: \"'tty.c'\" unpacked with wrong size!
fi
# end of 'tty.c'
fi
echo shar: End of archive 2 \(of 3\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
