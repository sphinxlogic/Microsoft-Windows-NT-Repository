Newsgroups: comp.sources.unix
From: ross@zooid.guild.org (Ross Ridge)
Subject: v26i077: mytinfo - a replacement for terminfo and termcap, Part01/03
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: ross@zooid.guild.org (Ross Ridge)
Posting-Number: Volume 26, Issue 77
Archive-Name: mytinfo/part01

Mytinfo is Public Domain and comes with no guarantees.
By Ross Ridge (ross@zooid.guild.org).

Mytinfo is a single library that combines the functionality of the
standard Unix termcap and terminfo libraries.  It has the special
ability of being able to fetch terminal descriptions from both
termcap and terminfo databases regardless of which set of functions,
termcap or terminfo, are used.  It can even read terminal descriptions
from terminfo source files. 

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 3)."
# Contents:  DECL MANIFEST README README.doc TODO addstr.c bin_order
#   bsearch.c buildpath.c caps.c clear.c compar.c config.h defs.h
#   fake_stdio.c fake_stdio.h fillterm.c findcap.c getother.c
#   gettbin.c mkbinorder.c mkcaplist.c mkcapsort.c mkdir.c
#   mktermhead.c mkversion.c quit.c readcaps.c strtok.c tcapvars.c
#   tconv.1 term.tail termcap.c terminfo.c terminfo.src tgoto.c
#   tiget.c tmatch.c tput.c tputs.c version.h
# Wrapped by vixie@cognition.pa.dec.com on Sun Dec 27 14:45:19 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'DECL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'DECL'\"
else
echo shar: Extracting \"'DECL'\" \(483 characters\)
sed "s/^X//" >'DECL' <<'END_OF_FILE'
int setupterm(char *, int, int *);
int set_curterm(TERMINAL *);
int del_curterm(TERMINAL *);
char *tparm(char *, ...);
int tputs(char *, int, int (*)());
int putp(char *);
int def_prog_mode(void);
int def_shell_mode(void);
int reset_prog_mode(void);
int reset_shell_mode(void);
int tigetnum(char *);
int tigetflag(char *);
char *tigetstr(char *);
int tgetent(char *, char *);
int tgetnum(char *);
int tgetflag(char *);
char *tgetstr(char *, char * *);
char *tgoto(char *, int, int);
END_OF_FILE
if test 483 -ne `wc -c <'DECL'`; then
    echo shar: \"'DECL'\" unpacked with wrong size!
fi
# end of 'DECL'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1832 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X DECL                       1	
X DIFFS-moderator            2	
X INSTALL                    2	
X MANIFEST                   1	
X Makefile                   2	
X README                     1	
X README.doc                 1	
X TODO                       1	
X addstr.c                   1	
X bin_order                  1	
X bsearch.c                  1	
X buildpath.c                1	
X cap_list                   2	
X caps.c                     1	
X clear.c                    1	
X compar.c                   1	
X config.h                   1	
X defs.h                     1	
X fake_stdio.c               1	
X fake_stdio.h               1	
X fillterm.c                 1	
X findcap.c                  1	
X findterm.c                 2	
X getother.c                 1	
X gettbin.c                  1	
X gettcap.c                  2	
X gettinfo.c                 2	
X mkbinorder.c               1	
X mkcaplist.c                1	
X mkcapsort.c                1	
X mkdir.c                    1	
X mktermhead.c               1	
X mkversion.c                1	
X qsort.c                    2	
X quit.c                     1	
X readcaps.c                 1	
X sprintf.c                  2	
X strtok.c                   1	
X tcapconv.c                 2	
X tcapvars.c                 1	
X tconv.1                    1	
X tconv.c                    3	
X term.tail                  1	
X termcap.c                  1	
X terminfo.c                 1	
X terminfo.src               1	
X tgoto.c                    1	
X tiget.c                    1	
X tmatch.c                   1	
X tparm.c                    3	
X tput.c                     1	
X tputs.c                    1	
X tset.c                     3	
X ttest.c                    2	
X tty.c                      2	
X version.h                  1	
END_OF_FILE
if test 1832 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(4032 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
Mytinfo is Public Domain and comes with no guarantees.
By Ross Ridge (ross@zooid.guild.org).
X
Mytinfo is a single library that combines the functionality of the
standard Unix termcap and terminfo libraries.  It has the special
ability of being able to fetch terminal descriptions from both
termcap and terminfo databases regardless of which set of functions,
termcap or terminfo, are used.  It can even read terminal descriptions
from terminfo source files. 
X
You should be able to compile this library on almost all versions of Unix.
Much of it's development was done on '386 Xenix, but I've sucessfuly built
mytinfo under BSD 4.3, HP-UX 2.1 (System III), SunOS 3.5, and Amix
X(System V R4).  There hasn't been a large amount of testing of the support
programmes that come with the library, but the library itself has been in
use on a couple of public access Unix sites for over two years.  It has
successfully linked and run with many programmes such as rn, vi and nethack.
X
Included in the package is tconv, an "all-in-one" programme that will
compile terminfo sources to binary format and also translate termcap to
either terminfo source or binary.  tic and cap2info are just links
to the tconv programme.  I've also written replacement for tset,
that uses the mytinfo library, in case tset doesn't come with your
system or if you aren't too pleased with the one that did.  Since this
is the newest part of the package it probably still has a few bugs.
You'll also find tput, as well two versions of clear, one that uses
termcap and the other that uses terminfo.
X
The environment variables TERMCAP and TERMINFO can have multiple
filenames separated by a space, a feature not in terminfo and not in
most termcaps.  This is very handy for users that maintain their own
private databases, as they don't have to have a copy the entire
database.  Eg:
X	TERMCAP="$HOME/.termcap /etc/termcap"
X	TERMINFO="$HOME/terminfo /usr/lib/terminfo"
X	export TERMCAP TERMINFO
The library will also check compiled-in default locations for terminal
descriptions.  Like most termcaps, the TERMCAP variable can also
contain the complete termcap terminal description, usually supplied
from tset at login.  The TERMINFO variable can also contain a complete
terminfo description, but there is no programme like tset to supply it.
X
Unlike termcap, this library can only use capabilities that it knows about.
However it does knows about all the standard ones, and you can easily
add your own to it's list.  Included in the list are all terminfo
capabilities to Release 4 of System V, obsolete termcap capabilities, a
few caps used from the University of Waterloo (UW), a couple from GNU Emacs,
and a few I made up myself. Two extensions to the standard termcap % codes
are supported, GNU's %a, %m, %b, and %f, and UW's %-, %a, and %s.
X
Termcap and terminfo source descriptions can be mixed in one file, but
because of this termcap databases must be in a certain style.  All
continuation lines of a termcap entry must be indented from the left
margin by white space.  This shouldn't be a problem with most sites
since this is the style that most termcap files are distributed, but local
additions may not adhere to this style.  Another possible problem is
that termcap entries should end with a colon (:), but in most
distributed termcaps there are entries that don't.  If a one line
termcap entry doesn't end with a colon, it will be ignored.  A quick
way to find these is "tconv -c /etc/termcap > /dev/null".
X
See the file INSTALL for instructions on configuring and installing
this library. The file README.doc lists the functions supported by the
library, and gives short description of the tconv programme.  tconv.1 is
a simple man page for tconv.  terminfo.src contains a few sample
terminal descriptions in terminfo source format.  TODO is a list of
possible enhancements too the library, your comments and additions
are welcome.
X
Please let me know of any bugs you find, as well as any ideas you have
for improvement.
X
Ross Ridge
X
ross@zooid.guild.org
END_OF_FILE
if test 4032 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'README.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README.doc'\"
else
echo shar: Extracting \"'README.doc'\" \(4738 characters\)
sed "s/^X//" >'README.doc' <<'END_OF_FILE'
X----------------------------------------------------------------------------
tconv [-b] [-c [-OUGd]] [-i] [-B [-D dir]] [-I] [-k] [-t term] [file]
tic [file]
cap2info [-t term] [-OUGdk] [file]
X
X-c		convert from termcap
X-i		convert from terminfo source
X-b		convert from terminfo binary
X-B		convert to terminfo binary
X-I		convert to terminfo source
X
The following switches are available when converting from termcap:
X-d		don't supply any defaults for missing capabilities
X-O		include obsolete termcap capabilities
X-G		include GNU capabilities
X-U		include UW capabilities
X
X-k		keep comments
X-D dir		directory to put terminfo binaries in
X
X-t term		name of terminal to translate
file		filename of termcap/terminfo database to use 
X
If a file is specifed and no terminal is given the entire file we be translated.
If no terminal and no file is specified then the terminal name will be taken
from the environment varible TERM. Unless compiling to a terminfo binary,
output is to stdout.
X----------------------------------------------------------------------------
X
char *tparm(char *str, ...);	/* up to nine parameters */
char *tgoto(char *str, int column, int row);
X
tparm and tgoto support the following termcap and terminfo % codes:
X
Terminfo % Codes
X
X	%%	output a '%'
X	%[[:][-+# ][width][.precision]][doxXs]
X		output pop according to the printf format
X	%c	output pop as a char
X	%'c'	push character constant c.
X	%{n}	push decimal constant n.
X	%p[1-9] push paramter [1-9]
X	%g[a-z] push variable [a-z]
X	%P[a-z] put pop in variable [a-z]
X	%l	push the length of pop (a string)
X	%+	add pop to pop and push the result
X	%-	subtract pop from pop and push the result
X	%*	multiply pop and pop and push the result
X	%&	bitwise and pop and pop and push the result
X	%|	bitwise or pop and pop and push the result
X	%^	bitwise xor pop and pop and push the result
X	%~	push the bitwise not of pop
X	%=	compare if pop and pop are equal and push the result
X	%>	compare if pop is less than pop and push the result
X	%<	compare if pop is greater than pop and push the result
X	%A	logical and pop and pop and push the result
X	%O	logical or pop and pop and push the result
X	%!	push the logical not of pop
X	%? condition %t if_true [%e if_false] %;
X		if condtion evaulates as true then evaluate if_true,
X		else evaluate if_false. elseif's can be done:
X%? cond %t true [%e cond2 %t true2] ... [%e condN %t trueN] [%e false] %;
X	%i	add one to parameters 1 and 2. (ANSI)
X
Termcap Codes
X
X	%%	output a %
X	%.	output parameter as a character
X	%d	output parameter as a decimal number
X	%2	output parameter in printf format %02d
X	%3	output parameter in printf format %03d
X	%+x	add the character x to parameter and output it as a character
X(UW)	%-x	subtract parameter FROM the character x and output it as a char
X(UW)	%ax	add the character x to parameter
X(GNU)	%a[+*-/=][cp]x
X		GNU arithmetic. 
X(UW)	%sx	subtract parameter FROM the character x
X	%>xy	if parameter > character x then add character y to parameter
X	%B	convert to BCD (parameter = (parameter/10)*16 + parameter%16)
X	%D	Delta Data encode (parameter = parameter - 2*(paramter%16))
X	%i	increment the first two parameters by one
X	%n	xor the first two parameters by 0140
X(GNU)	%m	xor the first two parameters by 0177
X	%r	swap the first two parameters
X(GNU)	%b	backup to previous parameter
X(GNU)	%f	skip this parameter
X
X(GNU) used by GNU Emacs termcap libraries
X(UW) used by the University of Waterloo (MFCF) termcap libraries
X
Note the two definitions of %a, the GNU defintion is used if the characters
after the 'a' are valid for it, otherwise the UW definition is used.
X----------------------------------------------------------------------------
X
int setupterm(char *term; int fd; int *err);
int set_curterm(TERMINAL *new);
int del_curterm(TERMINAL *old);
char *tparm(char *str, ...);		/* see above */
int tputs(char *str, int count, int (*putc)());
int putp(str);
int tigetflag(char *cap);
int tigetnum(char *cap);
char *tigetstr(char *cap);
int def_prog_mode();
int def_shell_mode();
int reset_prog_mode();
int reset_shell_mode();
char *boolnames[], *boolcodes[], *boolfnames[];
char *numnames[], *numcodes[], *numfnames[];
char *strnames[], *strcodes[], *strfnames[];
X
These functions work just like the terminfo functions. Note restartterm(),
vidputs(), vidattr(), and mvcur() are not available.
X----------------------------------------------------------------------------
X
int tgetent(char *buf, char *term);
int tgetflag(char *cap);
int tgetnum(char *cap);
char *tgetstr(char *cap, char **area);
char *tgoto(char *cap, int column, int row);
int tputs(char *str, int count, int (*putc)());
X
These functions work just like termcap functions.
X----------------------------------------------------------------------------
END_OF_FILE
if test 4738 -ne `wc -c <'README.doc'`; then
    echo shar: \"'README.doc'\" unpacked with wrong size!
fi
# end of 'README.doc'
fi
if test -f 'TODO' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'TODO'\"
else
echo shar: Extracting \"'TODO'\" \(85 characters\)
sed "s/^X//" >'TODO' <<'END_OF_FILE'
X- docs, docs, docs
X- rewrite tparm so it's no so disgusting
X- better string handling
END_OF_FILE
if test 85 -ne `wc -c <'TODO'`; then
    echo shar: \"'TODO'\" unpacked with wrong size!
fi
# end of 'TODO'
fi
if test -f 'addstr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'addstr.c'\"
else
echo shar: Extracting \"'addstr.c'\" \(1523 characters\)
sed "s/^X//" >'addstr.c' <<'END_OF_FILE'
X/*
X * addstr.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:34:01
X *
X */
X
X#include "defs.h"
X#include "term.h"
X
X#include <ctype.h>
X
X#ifdef USE_SCCS_IDS
static char const SCCSid[] = "@(#) mytinfo addstr.c 3.2 92/02/01 public domain, By Ross Ridge";
X#endif
X/*
X * I think this routine could be improved, as it is now it searches a
X * linked list of strbufs for one that has enough room left for the
X * string. The only thing else I can think of doing would be to 
X * expand a buffer by realloc and then fix the string pointers if it
X * moves.
X */
X
static struct strbuf *strbuf = NULL;
X   
struct strbuf *
X_endstr() {
X	register struct strbuf *p;
X
X	p = strbuf;
X	strbuf = NULL;
X	return p;
X}
X
char *
X_addstr(s)
register char *s; {
X	register struct strbuf *p;
X	register int l;
X
X	if (s == NULL) {
X		strbuf = NULL;
X		return NULL;
X	}
X
X	if (strbuf == NULL) {
X		strbuf = (struct strbuf *) malloc(sizeof(struct strbuf));
X		if (strbuf == NULL)
X			return NULL;
X		strbuf->len = 0;
X		strbuf->next = NULL;
X	}
X	l = strlen(s) + 1;
X	if (l > MAX_CHUNK)
X		return NULL;
X	p = strbuf;
X	while (l + p->len > MAX_CHUNK) {
X		if (p->next == NULL) {
X			p->next = (struct strbuf *)
X					malloc(sizeof(struct strbuf));
X			p = p->next;
X			if (p == NULL)
X				return NULL;
X			p->len = 0;
X			p->next = NULL;
X			break;
X		}
X		p = p->next;
X	}
X	s = strcpy(p->buf + p->len, s);
X	p->len += l;
X	return s;
X}
X
void
X_del_strs(p)
TERMINAL *p; {
X	struct strbuf *q;
X
X	q = p->strbuf;
X	while(q != NULL) {
X		p->strbuf = q->next; 
X		free((anyptr) q);
X		q = p->strbuf;
X	}
X}
END_OF_FILE
if test 1523 -ne `wc -c <'addstr.c'`; then
    echo shar: \"'addstr.c'\" unpacked with wrong size!
fi
# end of 'addstr.c'
fi
if test -f 'bin_order' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bin_order'\"
else
echo shar: Extracting \"'bin_order'\" \(2353 characters\)
sed "s/^X//" >'bin_order' <<'END_OF_FILE'
X bin_order
X
X By Ross Ridge
X Public Domain
X 92/02/01 07:29:39
X
X Order of entries in a terminfo binary
X
X @(#) mytinfo bin_order 3.2 92/02/01 public domain, By Ross Ridge
X
X
X!
bw am xsb xhp xenl eo gn hc km hs in da db mir msgr os eslok xt hz ul
xon nxon mc5i chts nrrmc npc ndscr ccc bce hls xhpa crxm daisy xvpa sam
cpix lpix
X
X#
cols it lines lm xmc pb vt wsl nlab lh lw ma wnum colors pairs ncv bufsz
spinv spinh maddr mjump mcs mls npins orc orl orhi orvi cps widcs btns
bitwin bitype
X
X$
cbt bel cr csr tbc clear el ed hpa cmdch cup cud1 home civis cub1 mrcup cnorm
cuf1 ll cuu1 cvvis dch1 dl1 dsl hd smacs blink bold smcup smdc dim smir invis
prot rev smso smul ech rmacs sgr0 rmcup rmdc rmir rmso rmul flash ff fsl is1
is2 is3 if ich1 il1 ip kbs ktbc kclr kctab kdch1 kdl1 kcud1 krmir kel ked
kf0 kf1 kf10 kf2 kf3 kf4 kf5 kf6 kf7 kf8 kf9 khome kich1 kil1 kcub1 kll
knp kpp kcuf1 kind kri khts kcuu1 rmkx smkx lf0 lf1 lf10 lf2 lf3 lf4 lf5
lf6 lf7 lf8 lf9 rmm smm nel pad dch dl cud ich indn il cub cuf rin cuu pfkey
pfloc pfx mc0 mc4 mc5 rep rs1 rs2 rs3 rf rc vpa sc ind ri sgr hts wind ht
tsl uc hu iprog ka1 ka3 kb2 kc1 kc3 mc5p rmp acsc pln kcbt smxon rmxon
smam rmam xonc xoffc enacs smln rmln kbeg kcan kclo kcmd kcpy kcrt kend
kent kext kfnd khlp kmrk kmsg kmov knxt kopn kopt kprv kprt krdo kref
krfr krpl krst kres ksav kspd kund kBEG kCAN kCMD kCPY kCRT kDC kDL kslt
kEND kEOL kEXT kFND kHLP kHOM kIC kLFT kMSG kMOV kNXT kOPT kPRV kPRT kRDO
kRPL kRIT kRES kSAV kSPD kUND rfi kf11 kf12 kf13 kf14 kf15 kf16 kf17 kf18
kf19 kf20 kf21 kf22 kf23 kf24 kf25 kf26 kf27 kf28 kf29 kf30 kf31 kf32
kf33 kf34 kf35 kf36 kf37 kf38 kf39 kf40 kf41 kf42 kf43 kf44 kf45 kf46 kf47
kf48 kf49 kf50 kf51 kf52 kf53 kf54 kf55 kf56 kf57 kf58 kf59 kf60 kf61 kf62
kf63 el1 mgc smgl smgr fln sclk dclk rmclk cwin wingo hup dial qdial tone
pulse hook pause wait u0 u1 u2 u3 u4 u5 u6 u7 u8 u9 op oc initc initp scp
setf setb cpi lpi chr cvr defc swidm sdrfq sitm slm smicm snlq snrmq sshm
ssubm ssupm sum rwidm ritm rlm rmicm rshm rsubm rsupm rum mhpa mcud1 mcub1
mcuf1 mvpa mcuu1 porder mcud mcub mcuf mcuu scs smgb smgbp smglp smgrp smgt
smgtp sbim scsd rbim rcsd subcs supcs docr zerom csnm kmous minfo reqmp
getm setaf setab pfxl devt csin s0ds s1ds s2ds s3ds smglr smgtb birep binel
bicr colornm defbi endbi setcolor slines dispc smpch rmpch smsc rmsc pctrm
scesc scesa
END_OF_FILE
if test 2353 -ne `wc -c <'bin_order'`; then
    echo shar: \"'bin_order'\" unpacked with wrong size!
fi
# end of 'bin_order'
fi
if test -f 'bsearch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bsearch.c'\"
else
echo shar: Extracting \"'bsearch.c'\" \(2102 characters\)
sed "s/^X//" >'bsearch.c' <<'END_OF_FILE'
X/*
X * bsearch.c
X *
X * This is something I found on watmath. I've made some minor changes for use
X * in this package.
X *
X * 92/06/04 11:35:15
X */
X
X#if 0
X#ifndef lint
static char *RCSid = "$OHeader: /usr/mfcf/src/accounts/libuw/RCS/bsearch.c,v 1.1 88/06/11 20:41:48 root Exp $";
X#endif
X#endif
X
X#include "defs.h"
X
X#ifdef USE_MYBSEARCH
X
X#ifdef USE_SCCS_IDS
static char const SCCSid[] = "@(#) mytinfo bsearch.c 3.4 92/06/04 public domain, By Ross Ridge";
X#endif
X
X#ifdef USE_SHORT_BSEARCH
X#define fast_int short
X#else
X#define fast_int mysize_t
X#endif
X
X/*
X * bsearch - find an element of a sorted vector
X *
X *	found = bsearch(key, array, dimension, width, compare)
X *		returns a pointer to the specified element in the array,
X *		or (char*)0 if the element can't be found.
X *	key
X *		pointer to the element to be searched for in the array
X *	array
X *		address of an array of elements
X *	dimension
X *		number of elements in the array
X *	width
X *		sizeof(type) of each element
X *	compare
X *		pointer to a function taking (char *) pointers to two elements
X *		and returning <0, 0, or >0 as the first element comes before,
X *		at, or after the second element.  A compare function is provided
X *		for comparing strings.
X*/
X#if 0
X/*
X * $OLog:	bsearch.c,v $
X * Revision 1.1  88/06/11  20:41:48  root
X * Initial revision
X * 
X*/
X#endif
X
X	static anyptr
bsearch(key, array, dimension, iwidth, compare)
X	anyptr key;
X	anyptr array;
X	int dimension;
X	mysize_t iwidth;
X	compar_fn compare;
X{
X	register fast_int start;   /* offset to start of current interval */
X	register fast_int end;     /* offset to end+1 of current interval */
X	register fast_int middle;  /* offset to middle of current interval */
X	auto int status;
X	register fast_int width;
X
X	width = iwidth / sizeof(char);
X
X	start = 0;
X	middle = 0;
X	end = dimension;
X
X	while (start < end) {
X
X		middle = (start + end) / 2;
X
X		status = (*compare)(key, ((char *)array + middle*width));
X
X		if (status < 0)
X			end = middle;
X
X		else if (status > 0)
X			start = middle + 1;
X
X		else return (anyptr)(((char *)array) + middle*width);
X	}
X
X	return  0;
X}
X
X#endif /* USE_MYBSEARCH */
END_OF_FILE
if test 2102 -ne `wc -c <'bsearch.c'`; then
    echo shar: \"'bsearch.c'\" unpacked with wrong size!
fi
# end of 'bsearch.c'
fi
if test -f 'buildpath.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'buildpath.c'\"
else
echo shar: Extracting \"'buildpath.c'\" \(4092 characters\)
sed "s/^X//" >'buildpath.c' <<'END_OF_FILE'
X/*
X * buildpath.c
X * 
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:29:42
X *
X * _buildpath builds a list of file names and terminal descriprions extracted
X * from its arguments. It returns a pointer to a structure that is used by
X * other routines as the list of file names to search for terminal
X * descriptions.  It is passed a variable number of arguments consisting
X * of file name and type pairs. The file name can actually be a list of 
X * file names seperated by spaces and any environment variables specified
X * by a dollar sign ($) followed by its name are substituted in. A type
X * of 1 indicates that the file name may actually be termcap description
X * and a type of 2 indicates it may be a terminfo description. A type of 0
X * indicates that the file name can only be a file name (or list of them).
X *
X */
X
X#include "defs.h"
X
X#include <ctype.h>
X
X#include "strtok.c"
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo buildpath.c 3.2 92/02/01 public domain, By Ross Ridge";
X#endif
X
X/* more memory is allocated for file names every HUNK file names */
X#define HUNK 32	
X
X/* characters that seperate file names in a list */
X#define SEPERATORS " :"
X
static struct term_path *path = NULL;	/* the list of files */
static int files = 0;			/* # of files in the list */
static int size = 0;			/* # of files there is space for */
X
X/* add a file name, type pair to the list */
static int
addfile(file, type)
char *file;
int type; {
X	int l;
X	char *s;
X
X	if (file == NULL) {
X		if (type != -1)
X			return -1;
X	} else if (file[0] == '\0')
X		return -1;
X
X#ifdef DEBUG
X	if (file != NULL)
X		printf("addfile: %s\n", file);
X#endif
X
X	if (files >= size) {
X		size += HUNK;
X		if (path == NULL)
X			path = (struct term_path *) 
X				malloc(size * sizeof(struct term_path));
X		else
X			path = (struct term_path *)
X				realloc((anyptr) path,
X					size * sizeof(struct term_path));
X		if (path == NULL)
X			return 0;
X	}
X	if (file == NULL) {
X		path[files].file = file;
X	} else {
X		l = strlen(file) + 1;
X		s = (char *) malloc(l * sizeof(char));
X		if (s == NULL)
X			return 0;
X		path[files].file = strcpy(s, file);
X	}
X	path[files].type = type;
X	
X	return ++files;
X}
X
X/* deallocate space used by the path list */
void
X_delpath(ppath)
struct term_path *ppath; {
X	struct term_path *p;
X
X	p = ppath;
X	while(p->file != NULL) {
X		free((anyptr)p->file);
X		p++;
X	}
X
X	free((anyptr)ppath);
X}
X
X/* build a list of paths. see above */
X#ifdef lint
X/*VARARGS2*/
struct term_path *
X_buildpath(file, type)
char *file;
int type;
X#else
X#ifdef USE_STDARG
X#ifdef USE_PROTOTYPES
struct term_path *_buildpath(char *file, int type, ...)
X#else
struct term_path *_buildpath(file, type)
char *file;
int type;
X#endif /* USE_PROTOTYPES */
X#else /* USE_STDARG */
struct term_path *_buildpath(va_alist)
va_dcl
X#endif /* USE_STDARG */
X#endif /* lint */
X{
X#ifndef lint
X#ifndef USE_STDARG
X	char *file;
X	int type;
X#endif
X#endif
X	va_list ap;
X	register char *s, *d, *e;
X	char line[MAX_BUF+1];
X	char name[MAX_NAME+1];
X	int i,j;
X
X	size = 0;
X	files = 0;
X	path = NULL;
X
X#ifdef lint
X	ap = NULL;
X#else
X#ifdef USE_STDARG
X	va_start(ap, type);
X#else
X	va_start(ap);
X	file = va_arg(ap, char *);
X	type = va_arg(ap, int);
X#endif
X#endif
X
X	while (type >= 0 && type <= 2) {
X		s = file;
X		d = line;
X		i = 0;
X		while(*s != '\0') {
X			if (*s == '$') {
X				s++;
X				j = 0;
X				while(*s != '\0' && (*s == '_' || isalnum(*s))) 
X					if (j < MAX_NAME) {
X						name[j] = *s++;
X						j++;
X					} else
X						break;
X				name[j] = '\0';
X				e = getenv(name);
X				if (e != NULL) {
X					while(*e != '\0') {
X						if (i < MAX_BUF) {
X							*d++ = *e++;
X							i++;
X						} else
X							break;
X					}
X				} else if (*s == '/') 
X					s++;
X			} else {
X				if (i < MAX_BUF) {
X					*d++ = *s++;
X					i++;
X				} else
X					break;
X			}
X		}
X		*d = '\0';
X		if (type == 0 || line[0] == '/') {
X			s = strtok(line, SEPERATORS);
X			while(s != NULL) {
X				if (addfile(s, 0) == 0)
X					return NULL;
X				s = strtok(NULL, SEPERATORS);
X			}
X		} else 
X			if (addfile(line, type) == 0)
X				return NULL;
X		file = va_arg(ap, char *);
X		type = va_arg(ap, int);
X	}
X	addfile(NULL, -1);
X	return path;
X}
END_OF_FILE
if test 4092 -ne `wc -c <'buildpath.c'`; then
    echo shar: \"'buildpath.c'\" unpacked with wrong size!
fi
# end of 'buildpath.c'
fi
if test -f 'caps.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'caps.c'\"
else
echo shar: Extracting \"'caps.c'\" \(3316 characters\)
sed "s/^X//" >'caps.c' <<'END_OF_FILE'
X/*
X * caps.c
X * 
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:29:45
X *
X * caps [-c | -t] [term]
X *
X * -c		use termcap names instead of terminfo variable names
X * -t		use terminfo capnames instead of variables names
X * term 	name of terminal to use
X *
X * prints out all the capabilities given the specified terminal. If no
X * terminal is given, it is taken from the environment variable TERM.
X *
X */
X
X#define NOTLIB
X#include "defs.h"
X#include "term.h"
X
static const char SCCSid[] = "@(#) mytinfo caps.c 3.2 92/02/01 public domain, By Ross Ridge";
X
X/* output a string in a human readable format */
void
putstr(s)
char *s; {
X	while(*s != '\0') {
X		switch(*s) {
X		case '\n': printf("\\n"); break;
X		case '\b': printf("\\b"); break;
X		case '\t': printf("\\t"); break;
X		case '\r': printf("\\r"); break;
X		case '\f': printf("\\f"); break;
X		case ' ': printf("\\s"); break;
X		case '\177': printf("^?"); break;
X		case '\200': printf("\\0"); break;
X		default:
X			if (*s > 0 && *s < 32)
X				printf("^%c", *s + 64);
X			else if (*s < 0 || *s > 127)
X				printf("\\%03o", *s & 0xff);
X			else
X				putchar(*s);
X			break;
X		}
X		s++;
X	}
X}
X
void
do_cleanup(e)
int e; {
X	fprintf(stderr, "usage: %s [-c | -t ] [terminal]\n", prg_name);
X	return;
X}
X
int
main(argc, argv)
int argc;
char **argv; {
X	int names = 0;
X	register int i;
X	int flag, num;
X	char *str;
X
X	prg_name = argv[0];
X	cleanup = do_cleanup;
X
X	if (argc > 3)
X		quit(-1, "argument count");
X
X	if (argc == 1)
X		setupterm(NULL, 2, (int *) 0);
X	else if (argc == 2)
X		setupterm(argv[1], 2, (int *) 0);
X	else {
X		if (argv[1][0] != '-')
X			quit(-1, "bad switch");
X		if (argv[1][1] == 'c')
X			names = 2;
X		else if (argv[1][1] == 't')
X			names = 1;
X		else
X			quit(-1, "unknown switch '%c'", argv[1][1]);
X		setupterm(argv[2], 2, (int *) 0);
X
X	}
X
X	fflush(stderr);
X	fflush(stdout);
X	printf("\n");
X#ifdef _CUR_TERM
X	printf("%s: %s\n", cur_term->name, cur_term->name_all);
X	printf("pad: %d xon: %d termcap: %d\n",
X	        cur_term->pad, cur_term->xon, cur_term->termcap);
X	printf("true_columns: %d true_lines: %d baudrate: %d\n",
X		cur_term->true_columns, cur_term->true_lines,
X		cur_term->baudrate);
X	printf("\n");
X#endif
X
X	printf("Booleans:\n");
X	for(i = 0; boolnames[i] != NULL; i++) {
X#ifdef _CUR_TERM
X		flag = cur_term->bools[i];
X#else
X		flag = tigetflag(boolnames[i]);
X#endif
X		if (flag != -1 && flag != 0) {
X			switch(names) {
X			case 0:
X				printf("  %s\n", boolfnames[i]);
X				break;
X			case 1:
X				printf("  %s\n", boolnames[i]);
X				break;
X			case 2:
X				printf("  %s\n", boolcodes[i]);
X				break;
X			}
X		}
X	}
X
X	printf("\nNumerics:\n");
X	for(i = 0; numnames[i] != NULL; i++) {
X		num = tigetnum(numnames[i]);
X		if (num != -2 && num != -1) {
X			switch(names) {
X			case 0:
X				printf("  %-32s: %d\n", numfnames[i], num);
X				break;
X			case 1:
X				printf("  %-5s: %d\n", numnames[i], num);
X				break;
X			case 2:
X				printf("  %-2s: %d\n", numcodes[i], num);
X				break;
X			}
X		}
X	}
X	printf("\nStrings:\n");
X	for(i = 0; strnames[i] != NULL; i++) {
X		str = tigetstr(strnames[i]);
X		if (str != (char *) -1 && str != (char *) 0) {
X			switch(names) {
X			case 0:
X				printf("  %-32s: ", strfnames[i]);
X				break;
X			case 1:
X				printf("  %-5s: ", strnames[i]);
X				break;
X			case 2:
X				printf("  %-2s: ", strcodes[i]);
X				break;
X			}
X			putstr(str);
X			putchar('\n');
X		}
X	}
X	return 0;
X}
END_OF_FILE
if test 3316 -ne `wc -c <'caps.c'`; then
    echo shar: \"'caps.c'\" unpacked with wrong size!
fi
# end of 'caps.c'
fi
if test -f 'clear.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'clear.c'\"
else
echo shar: Extracting \"'clear.c'\" \(1388 characters\)
sed "s/^X//" >'clear.c' <<'END_OF_FILE'
X/*
X * clear.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:29:47
X *
X * clear
X * 
X * clears the terminal's screen
X *
X */
X
X#include "defs.h"
X
static const char SCCSid[] = "@(#) mytinfo clear.c 3.2 92/02/01 public domain, By Ross Ridge";
X
X#ifndef USE_TERMINFO
X
X#ifdef USE_SGTTY
X#include <sgtty.h>
X#endif
X#ifdef USE_TERMIO
X#include <termio.h>
X#endif
X
char PC;
short ospeed;
X
int
putch(c)
int c; {
X	return putchar(c);
X}
X
int
main(argc, argv)
int argc;
char **argv; {
X#ifdef USE_PROTYPES
X	char *tgetstr(char *, char **);
X#else
X	char *tgetstr();
X#endif
X	char *term;
X	char buf[MAX_BUF];
X	char CL[MAX_LINE];
X	char *s, *pc;
X
X#ifdef USE_SGTTY
X	struct sgttyb tty;
X
X	gtty(1, &tty);
X	ospeed = tty.sg_ospeed;
X#else
X#ifdef USE_TERMIO
X	struct termio tty;
X
X	ioctl(1, TCGETA, &tty);
X	ospeed = tty.c_cflag & CBAUD;
X#else
X	ospeed = 0;
X#endif
X#endif
X
X	term = getenv("TERM");
X	if (term == NULL)
X		exit(1);
X
X	if (tgetent(buf, term) != 1)
X		exit(1);
X
X	s = CL;
X	pc = tgetstr("pc", &s);
X	if (pc != NULL)
X		PC = *pc;
X
X	s = CL;
X	tgetstr("cl", &s);
X
X	if (CL != NULL) {
X		tputs(CL, tgetnum("li"), putch);
X		exit(1);
X	}
X
X	return 0;
X}
X
X#else /* USE_TERMINFO */
X
X#include "term.h"
X
int
putch(c)
int c; {
X	return putchar(c);
X}
X
int
main() {
X	setupterm((char *) 0, 1, (int *) 0); 
X	if (clear_screen == (char *) 0)
X		exit(1);
X	tputs(clear_screen, lines > 0 ? lines : 1, putch);
X	return 0;
X}
X
X#endif /* USE_TERMINFO */
END_OF_FILE
if test 1388 -ne `wc -c <'clear.c'`; then
    echo shar: \"'clear.c'\" unpacked with wrong size!
fi
# end of 'clear.c'
fi
if test -f 'compar.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'compar.c'\"
else
echo shar: Extracting \"'compar.c'\" \(735 characters\)
sed "s/^X//" >'compar.c' <<'END_OF_FILE'
X/*
X * compar.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/06/04 11:36:24
X *
X */
X
X#include "defs.h"
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo compar.c 3.3 92/06/04 public domain, By Ross Ridge";
X#endif
X
X/* compare two elements a sorted list of pointers to strings */
int
X_compar(a, b)
X#ifdef USE_ANSIC
void const *a;
void const *b; {
X#else
anyptr a, b; {
X#endif
X	register char *aa = **(char ***)a;
X	register char *bb = **(char ***)b;
X
X	/* An optimization trick from C News, compare the first
X	 * two chars of the string here to avoid a the overhead of a
X	 * call to strcmp.
X	 */
X
X#ifdef __GNUC__
X	return ((*aa - *bb) ? : strcmp(aa, bb));
X#else
X	if (*aa != *bb)
X		return *aa - *bb;
X	return strcmp(aa, bb);
X#endif
X}
END_OF_FILE
if test 735 -ne `wc -c <'compar.c'`; then
    echo shar: \"'compar.c'\" unpacked with wrong size!
fi
# end of 'compar.c'
fi
if test -f 'config.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config.h'\"
else
echo shar: Extracting \"'config.h'\" \(2141 characters\)
sed "s/^X//" >'config.h' <<'END_OF_FILE'
X/*
X * config.h
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/19 18:56:28
X *
X * @(#) mytinfo config.h 3.3 92/02/19 public domain, By Ross Ridge
X *
X * Read the file INSTALL for more information on configuring mytinfo
X *
X */
X
X#ifndef _CONFIG_H_
X#define _CONFIG_H_
X
X#ifdef __STDC__
X#define USE_ANSIC		/* undefine this if your compiler lies */
X#endif
X
X#define USE_TERMIO		/* use termio (SysIII, SysV) */
X#undef USE_SGTTY		/* use sgtty (v7, BSD) */
X#define USE_WINSZ		/* get window size from the tty driver */
X#undef USE_STRINGS		/* include <strings.h> instead of <string.h> */
X#define USE_MYBSEARCH		/* your library doesn't have bsearch */
X#define USE_MYSTRTOK		/* your library doesn't have strtok */
X#define USE_MYQSORT		/* your library doesn't have qsort */
X#define USE_MYMKDIR		/* your library doesn't have mkdir */
X#define USE_MEMORY		/* you have an <memory.h> header */
X#define USE_FAKE_STDIO		/* don't use real stdio */
X#undef USE_DOPRNT		/* no vfprintf, use _doprnt */
X
X#define USE_SHORT_BSEARCH	/* speeds up MYBSEARCH on most machines */
X
X#define USE_SMALLMEM 		/* save some memory */
X
X#undef USE_UPBC_KLUDGE		/* do tgoto like real togo */
X#undef USE_EXTERN_UPBC		/* get cuu1 and cub1 from externs UP and BC */
X#undef USE_LITOUT_KLUDGE	/* an alternate tgoto kludge, not recommened */
X
X
X#ifndef USE_ANSIC
X
X#undef USE_PROTOTYPES		/* use ANSI C prototypes */
X#undef USE_STDLIB		/* you have a <stdlib.h> */
X#undef USE_STDARG		/* you have a <stdarg.h> */
X#undef USE_STDDEF		/* you have a <stddef.h> */
X
X#define const 
X#define volatile
X#define noreturn		/* a function that doesn't return */
X
typedef char *anyptr;		/* a type that any pointer can be assigned to */
X
X#define mysize_t unsigned	/* size_t, the size of an object */
X
X#else /* USE_ANSIC */
X
X#define USE_PROTOTYPES
X#define USE_STDLIB
X#define USE_STDARG
X#define USE_STDDEF
X
typedef void *anyptr;
X
X#define mysize_t size_t
X
X#ifdef __GNUC__
X#define noreturn volatile
X#else
X#define noreturn
X#endif
X
X#endif /* USE_ANSIC */
X
X#define TERMCAPFILE "$TERMCAPFILE $HOME/.termcap /etc/termcap"
X
X#define TERMINFOSRC "/usr/lib/terminfo/terminfo.src"
X
X#define TERMINFODIR "/usr/lib/terminfo"
X
X#endif 
END_OF_FILE
if test 2141 -ne `wc -c <'config.h'`; then
    echo shar: \"'config.h'\" unpacked with wrong size!
fi
# end of 'config.h'
fi
if test -f 'defs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'defs.h'\"
else
echo shar: Extracting \"'defs.h'\" \(3946 characters\)
sed "s/^X//" >'defs.h' <<'END_OF_FILE'
X/*
X * defs.h
X *
X * By Ross Ridge
X * Public Domain
X * 92/06/04 11:37:02
X *
X * @(#) mytinfo defs.h 3.3 92/06/04 public domain, By Ross Ridge
X */
X
X#ifndef _DEFS_H_
X#define _DEFS_H_
X
X#ifdef TEST
X#undef NOTLIB
X#define NOTLIB
X#endif
X
X#include "config.h"
X
X#ifdef NOTLIB
X#undef USE_FAKE_STDIO
X#endif
X
X#ifdef USE_STDDEF
X#include <stddef.h>
X#else
X#include <sys/types.h>
X#endif
X
X#ifdef USE_STDLIB
X#include <stdlib.h>
X#else
X#ifdef USE_PROTOTYPES
anyptr malloc(mysize_t);
anyptr realloc(anyptr, mysize_t);
char *getenv(char const *);
X#else
anyptr malloc();
anyptr realloc();
char *getenv();
X#endif
X#endif
X
X#ifdef USE_STDARG
X#include <stdarg.h>
X#else
X#include <varargs.h>
X#endif
X
X#ifndef _VA_LIST
X#define _VA_LIST
X#endif
X
X#ifdef USE_FAKE_STDIO
X#include "fake_stdio.h"
X#define sprintf _fake_sprintf
X#ifdef USE_PROTOTYPES
int sprintf(char *, char *, ...);
X#else
int sprintf();
X#endif
X#else /* USE_FAKE_STDIO */
X#if 0
X#include <stdio.h>
X#else
X#undef NULL
X#include <stdio.h>
X#endif
X#endif /* !USE_FAKE_STDIO */
X
X#ifdef USE_STRINGS
X#include <strings.h>
X#define strchr(s, c) index(s, c)
X#define strrchr(s, c) rindex(s, c)
X#ifndef USE_MYSTRTOK
X#ifdef USE_PROTOTYPES
char *strtok(char *, char *);
X#else
char *strtok();
X#endif
X#endif
X#else
X#include <string.h>
X#endif
X
X#ifdef USE_MEMORY
X#include <memory.h>
X#else
X#define memcpy(b, a, n) bcopy(a, b, n)
X#endif
X
X#include <errno.h>
X
X#define MAX_BUF	4096
X#define MAX_LINE 640
X#define MAX_NAME 128
X
X#define MAX_CHUNK MAX_LINE
X
X#define MAX_DEPTH 32
X
X#define MAX_VARNAME	32
X#define MAX_TINFONAME	5
X#define MAX_TCAPNAME	2
X
struct caplist {
X	char	type;
X	char	flag;
X	char	var[MAX_VARNAME + 1];
X	char	tinfo[MAX_TINFONAME + 1];
X	char	tcap[MAX_TCAPNAME + 1];
X};
X
struct term_path {
X	char *file;
X	int type;	/* 0 = file, 1 = TERMCAP env, 2 = TERMINFO env */
X};
X
struct _terminal;
X
X#ifdef USE_PROTOTYPES
X
int _gettcap(char *, struct _terminal *, struct term_path *);
int _gettinfo(char *, struct _terminal *, struct term_path *);
int _fillterm(char *, struct term_path *, char *);
int _findterm(char *, struct term_path *, char *);
int _init_tty(void), _lit_output(void), _check_tty(void);
void _figure_termcap(void);
int _tmatch(char *, char *);
void _norm_output(void);
int readcaps(FILE *, struct caplist *, int);
noreturn void quit(int, char *, ...);
X#ifdef lint
extern void (*cleanup)();
X#else
extern void (*cleanup)(int);
X#endif
struct term_path *_buildpath(char *, int, ...);
void _delpath(struct term_path *);
char *_addstr(char *);
struct strbuf *_endstr(void);
void _del_strs(struct _terminal *);
void _tcapconv(void);
void _tcapdefault(void);
int _getother(char *, struct term_path *, struct _terminal *);
int _gettbin(char *, struct _terminal *);
int _findboolcode(char *), _findnumcode(char *), _findstrcode(char *);
int _findboolname(char *), _findnumname(char *), _findstrname(char *);
int _findboolfname(char *), _findnumfname(char *), _findstrfname(char *);
X
X#ifdef USE_ANSIC
int _compar(void const *, void const *);
typedef int (*compar_fn)(void const *, void const *);
X#else
int _compar(anyptr, anyptr);
typedef int (*compar_fn)(anyptr, anyptr);
X#endif
X
X#else /* USE_PROTOTYPES */
X
int _gettcap(), _gettinfo(), _fillterm(), _findterm(), _init_tty();
int _lit_output(), _check_tty();
void _figure_termcap();
int _tmatch();
void _norm_output();
int readcaps();
noreturn void /* GOTO */ quit(/*FORMAT2*/);
extern void (*cleanup)();
struct term_path *_buildpath();
void _delpath();
char *_addstr();
struct strbuf *_endstr();
void _del_strs();
void _tcapconv();
void _tcapdefault();
int _getother();
int _gettbin();
int _findboolcode(), _findnumcode(), _findstrcode();
int _findboolname(), _findnumname(), _findstrname();
int _findboolfname(), _findnumfname(), _findstrfname();
int _compar();
typedef int (*compar_fn)();
X
X#endif /* USE_PROTOTYPES */
X
extern char _strflags[];
X
extern char _mytinfo_version[];
X
X/* for quit.c */
extern int sys_nerr;
extern char *sys_errlist[];
extern char *prg_name;
X
X#endif /* _DEFS_H_ */
END_OF_FILE
if test 3946 -ne `wc -c <'defs.h'`; then
    echo shar: \"'defs.h'\" unpacked with wrong size!
fi
# end of 'defs.h'
fi
if test -f 'fake_stdio.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fake_stdio.c'\"
else
echo shar: Extracting \"'fake_stdio.c'\" \(1803 characters\)
sed "s/^X//" >'fake_stdio.c' <<'END_OF_FILE'
X/*
X * fake_stdio.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:29:52
X *
X * fake some stdio functions
X *
X */
X
X#include "defs.h"
X
X#include <fcntl.h>
X
X#ifdef USE_FAKE_STDIO
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo fake_stdio.c 3.2 92/02/01 public domain, By Ross Ridge";
X#endif
X#include "fake_stdio.h"
X
static FILE _fake_files[] = {
X	{NULL, NULL, -1, {'\0'}},
X	{NULL, NULL, -1, {'\0'}},
X	{NULL, NULL, -1, {'\0'}},
X	{NULL, NULL, -1, {'\0'}},
X	{NULL, NULL, -1, {'\0'}}
X};
X
int
X_fillbuf(f)
register FILE *f; {
X	register int r;
X
X	r = read(f->fd, f->buf, FAKE_BUF_SIZE);
X	if (r == -1 || r == 0) {
X		f->pos = f->end = f->buf;
X		return EOF;
X	}
X	f->pos = f->buf + 1;
X	f->end = f->buf + r;
X
X	return f->buf[0];
X}
X
int
fgetc(f)
register FILE *f; {
X	return getc(f);
X}
X
char *
fgets(s, n, f)
char *s;
int n;
register FILE *f; {
X	register char *d;
X	register int l;
X	register int c;
X
X	d = s;
X	l = 1;
X	while(l < n) {
X		if ((c = getc(f)) == EOF) {
X			if (l == 0)
X				return NULL;
X			break;
X		}
X		*d++ = c;
X		if (c == '\n') 
X			break;
X		l++;
X	}
X	*d = '\0';
X	return s;
X}
X
static FILE *
X_fdopen(fd)
int fd; {
X	register FILE *f;
X	int i, r;
X
X	for(f = _fake_files, i = 0; i < FILES; i++, f++) {
X		if (f->fd == -1) {
X			f->fd = fd;
X			r = read(fd, f->buf, FAKE_BUF_SIZE);
X			if (r == -1) {
X				f->pos = f->end = f->buf;
X				return NULL;
X			}
X			f->pos = f->buf;
X			f->end = f->buf + r;
X			return f;
X		}
X	}
X	return NULL;
X}
X
XFILE *
fopen(name, type)
char *name;
char *type; {
X	FILE *f;
X	int fd;
X
X	if (strcmp(type, "r") != 0)
X		return NULL;
X	fd = open(name, O_RDONLY);
X	if (fd == -1)
X		return NULL;
X	f = _fdopen(fd);
X	if (f == NULL)
X		close(fd);
X	return f;
X}
X
XFILE *
fdopen(fd, type)
int fd;
char *type; {
X	if (strcmp(type, "r") != 0)
X		return NULL;
X	return _fdopen(fd);
X}
X
X#endif /* USE_FAKE_STDIO */
END_OF_FILE
if test 1803 -ne `wc -c <'fake_stdio.c'`; then
    echo shar: \"'fake_stdio.c'\" unpacked with wrong size!
fi
# end of 'fake_stdio.c'
fi
if test -f 'fake_stdio.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fake_stdio.h'\"
else
echo shar: Extracting \"'fake_stdio.h'\" \(1257 characters\)
sed "s/^X//" >'fake_stdio.h' <<'END_OF_FILE'
X/*
X * fake_stdio.h
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:29:53
X *
X * A fake stdio.h for a fake stdio (read only)
X *
X * @(#) mytinfo fake_stdio.h 3.2 92/02/01 public domain, By Ross Ridge
X */
X
X#ifndef _FAKE_STDIO_H_
X
X#define _FAKE_STDIO_H_
X
X#if 1
X#define getc _fake_getc
X#define fgetc _fake_fgetc
X#define fgets _fake_fgets
X#define fclose _fake_fclose
X#define _fillbuf _fake_fillbuf
X#define ungetc _fake_ungetc
X#define fopen _fake_fopen
X#define fdopen _fake_fdopen
X#endif
X
X#define FILES	5
X#define FAKE_BUF_SIZE	512
X
struct _fake_file {
X	char *pos;
X	char *end;
X	int fd;
X	char buf[FAKE_BUF_SIZE];
X};
X
X#undef FILE
X#define FILE struct _fake_file
X#undef EOF
X#define EOF (-1)
X
X#define _fake_getc(f) ((f)->pos >= (f)->end ? _fillbuf(f) : *((f)->pos)++)
X#define _fake_fclose(f) (close((f)->fd) == -1 ? EOF : ((f)->fd = -1, 0))
X#define _fake_ungetc(c, f) ((f)->pos > (f)->buf ? (*--((f)->pos) = c) : EOF)
X
X#ifdef USE_PROTOYPES
int fgetc(FILE *);
int _fillbuf(FILE *);
char *fgets(char *, int, FILE *);
XFILE *fopen(char *, char *);
XFILE *fdopen(int, char *);
X#else
int fgetc();
int _fillbuf();
char *fgets();
XFILE *fopen();
XFILE *fdopen();
X#endif
X
X#if !defined(NULL) && !defined(USE_STRINGS)
X#define NULL ((anyptr) 0)
X#endif
X
X#endif /* !_FAKE_STDIO_H_ */
END_OF_FILE
if test 1257 -ne `wc -c <'fake_stdio.h'`; then
    echo shar: \"'fake_stdio.h'\" unpacked with wrong size!
fi
# end of 'fake_stdio.h'
fi
if test -f 'fillterm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fillterm.c'\"
else
echo shar: Extracting \"'fillterm.c'\" \(1523 characters\)
sed "s/^X//" >'fillterm.c' <<'END_OF_FILE'
X/*
X * fillterm.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:29:54
X *
X */
X
X#include "defs.h"
X#include "term.h"
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo fillterm.c 3.2 92/02/01 public domain, By Ross Ridge";
X#endif
X
TERMINAL _term_buf;
TERMINAL *cur_term;
X
int
X_fillterm(name, path, buf)
char *name, *buf;
struct term_path *path; {
X	register int i, r;
X
X	r = -1;
X
X	for(i = NUM_OF_BOOLS; i;)
X		_term_buf.bools[--i] = -1;
X	for(i = NUM_OF_NUMS; i;)
X		_term_buf.nums[--i] = -2;
X	for(i = NUM_OF_STRS; i;)
X		_term_buf.strs[--i] = (char *) -1;
X
X	_term_buf.name_all = NULL;
X	
X	r = _findterm(name, path, buf);
X	switch(r) {
X	case 1:
X		if (_gettcap(buf, &_term_buf, path) != 0)
X			return -3;
X		_tcapconv(); 
X		_tcapdefault();
X		break;
X	case 2:
X		if (_gettinfo(buf, &_term_buf, path) != 0)
X			return -3;
X		break;
X	case 3:
X		if (_gettbin(buf, &_term_buf) != 0)
X			return -3;
X		break;
X	default:
X		return r;
X	}
X
X	if ((_term_buf.name = _addstr(name)) == NULL)
X		return -3;
X
X	for(i = NUM_OF_BOOLS; i;)
X		if (_term_buf.bools[--i] == -1)
X			_term_buf.bools[i] = 0;
X	for(i = NUM_OF_NUMS; i;)
X		if (_term_buf.nums[--i] == -2)
X			_term_buf.nums[i] = -1;
X	for(i = NUM_OF_STRS; i;)
X		if (_term_buf.strs[--i] == (char *) -1)
X			_term_buf.strs[i] = NULL;
X
X	_term_buf.fd = 1;
X	_term_buf.pad = 1;
X	_term_buf.baudrate = 0;
X	_term_buf.strbuf = _endstr();
X
X	cur_term = (TERMINAL *) malloc(sizeof(_term_buf));
X	if (cur_term == NULL)
X		return -3;
X	memcpy((anyptr)cur_term, (anyptr)&_term_buf, sizeof(_term_buf));
X
X	return r;
X}
END_OF_FILE
if test 1523 -ne `wc -c <'fillterm.c'`; then
    echo shar: \"'fillterm.c'\" unpacked with wrong size!
fi
# end of 'fillterm.c'
fi
if test -f 'findcap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'findcap.c'\"
else
echo shar: Extracting \"'findcap.c'\" \(2619 characters\)
sed "s/^X//" >'findcap.c' <<'END_OF_FILE'
X/*
X * findcap.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:29:55
X *
X */
X
X#include "defs.h"
X#include "term.h"
X
X#include "bsearch.c"
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo findcap.c 3.2 92/02/01 public domain, By Ross Ridge";
X#endif
X
extern char **_sboolcodes[], **_snumcodes[], **_sstrcodes[];
extern char **_sboolnames[], **_snumnames[], **_sstrnames[];
extern char **_sboolfnames[], **_snumfnames[], **_sstrfnames[];
X
static char **p2p2c;
X
int
X_findboolcode(s)
char *s; {
X	char ***match;
X
X	p2p2c = &s;
X
X	match = (char ***) bsearch((anyptr) &p2p2c, (anyptr) _sboolcodes,
X				   NUM_OF_BOOLS, sizeof(p2p2c), _compar);
X	if (match == NULL)
X		return -1;
X	return *match - boolcodes;
X}
X
int
X_findboolname(s)
char *s; {
X	char ***match;
X
X	p2p2c = &s;
X
X	match = (char ***) bsearch((anyptr) &p2p2c, (anyptr) _sboolnames,
X				   NUM_OF_BOOLS, sizeof(p2p2c), _compar);
X	if (match == NULL)
X		return -1;
X	return *match - boolnames;
X}
X
int
X_findboolfname(s)
char *s; {
X	char ***match;
X
X	p2p2c = &s;
X
X	match = (char ***) bsearch((anyptr) &p2p2c, (anyptr) _sboolfnames,
X				   NUM_OF_BOOLS, sizeof(p2p2c), _compar);
X	if (match == NULL)
X		return -1;
X	return *match - boolfnames;
X}
X
int
X_findnumcode(s)
char *s; {
X	char ***match;
X
X	p2p2c = &s;
X
X	match = (char ***) bsearch((anyptr) &p2p2c, (anyptr) _snumcodes,
X				   NUM_OF_NUMS, sizeof(p2p2c), _compar);
X	if (match == NULL)
X		return -1;
X	return *match - numcodes;
X}
X
int
X_findnumname(s)
char *s; {
X	char ***match;
X
X	p2p2c = &s;
X
X	match = (char ***) bsearch((anyptr) &p2p2c, (anyptr) _snumnames,
X				   NUM_OF_NUMS, sizeof(p2p2c), _compar);
X	if (match == NULL)
X		return -1;
X	return *match - numnames;
X}
X
int
X_findnumfname(s)
char *s; {
X	char ***match;
X
X	p2p2c = &s;
X
X	match = (char ***) bsearch((anyptr) &p2p2c, (anyptr) _snumfnames,
X				   NUM_OF_NUMS, sizeof(p2p2c), _compar);
X	if (match == NULL)
X		return -1;
X	return *match - numfnames;
X}
X
int
X_findstrcode(s)
char *s; {
X	char ***match;
X
X	p2p2c = &s;
X
X	match = (char ***) bsearch((anyptr) &p2p2c, (anyptr) _sstrcodes,
X				   NUM_OF_STRS, sizeof(p2p2c), _compar);
X	if (match == NULL)
X		return -1;
X	return *match - strcodes;
X}
X
int
X_findstrname(s)
char *s; {
X	char ***match;
X
X	p2p2c = &s;
X
X	match = (char ***) bsearch((anyptr) &p2p2c, (anyptr) _sstrnames,
X				   NUM_OF_STRS, sizeof(p2p2c), _compar);
X	if (match == NULL)
X		return -1;
X	return *match - strnames;
X}
X
int
X_findstrfname(s)
char *s; {
X	char ***match;
X
X	p2p2c = &s;
X
X	match = (char ***) bsearch((anyptr) &p2p2c, (anyptr) _sstrfnames,
X				   NUM_OF_STRS, sizeof(p2p2c), _compar);
X	if (match == NULL)
X		return -1;
X	return *match - strfnames;
X}
END_OF_FILE
if test 2619 -ne `wc -c <'findcap.c'`; then
    echo shar: \"'findcap.c'\" unpacked with wrong size!
fi
# end of 'findcap.c'
fi
if test -f 'getother.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getother.c'\"
else
echo shar: Extracting \"'getother.c'\" \(724 characters\)
sed "s/^X//" >'getother.c' <<'END_OF_FILE'
X/*
X * getother.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:29:58
X *
X */
X
X#include "defs.h"
X#include "term.h"
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo getother.c 3.2 92/02/01 public domain, By Ross Ridge";
X#endif
X
int
X_getother(name, path, ct)
char *name;
struct term_path *path;
TERMINAL *ct; {
X	static int depth = 0;
X	int r;
X	char buf[MAX_BUF];
X
X	if (depth >= MAX_DEPTH)
X		return 1;		/* infinite loop */
X
X#ifdef DEBUG
X	printf("\ngetother: %s\n", name);
X#endif
X
X	switch(_findterm(name, path, buf)) {
X	case -3:
X		return 1;
X	case 1:
X		depth++;
X		r = _gettcap(buf, ct, path);
X		break;
X	case 2:
X		depth++;
X		r = _gettinfo(buf, ct, path);
X		break;
X	default:
X		return 0;
X	}
X	depth--;
X	return r;
X}
END_OF_FILE
if test 724 -ne `wc -c <'getother.c'`; then
    echo shar: \"'getother.c'\" unpacked with wrong size!
fi
# end of 'getother.c'
fi
if test -f 'gettbin.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gettbin.c'\"
else
echo shar: Extracting \"'gettbin.c'\" \(2573 characters\)
sed "s/^X//" >'gettbin.c' <<'END_OF_FILE'
X/*
X * gettbin.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:29:59
X *
X * Get a terminfo binary entry
X *
X */
X
X#include "defs.h"
X#include "term.h"
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo gettbin.c 3.2 92/02/01 public domain, By Ross Ridge";
X#endif
X
extern int _boolorder[], _numorder[], _strorder[];
X
X#ifdef TRUE_BYTE_ORDERING 
X/* 8 bit char, 16 bit short, lsb first, twos complement */
X#define convshort(s) (*(short *)(s))
X
X#else
X
X#ifdef TWOS_COPLEMENT 
X/* 8 bit char, 16 bit short, lsb last, twos complement */
X#define convshort(s) ((short)(((s[0] & 0377) << 8) | (s[1] & 0377)))
X
X#else
X
X/* anything else... */
X
static short
convshort(s)
char *s; {
X	register int a,b;
X
X	a = (int) s[0] & 0377;
X	b = (int) s[1] & 0377;
X
X	if (a == 0377 && b == 0377)
X		return -1;
X	if (a == 0376 && b == 0377)
X		return -2;
X
X	return a + b * 256;
X}
X#endif
X#endif
X
int
X_gettbin(buf, cur)
char *buf;
TERMINAL *cur; {
X	register char *s;
X	int i;
X	int sz_names, sz_bools, sz_nums, sz_offs, sz_strs;
X	int n_bools, n_nums, n_strs;
X	char *strtbl;
X
X	buf[MAX_BUF-1] = '\0';
X	s = buf;
X
X	if (convshort(s) != 0432)
X		return 1;
X	sz_names = convshort(s + 2);
X	sz_bools = convshort(s + 4);
X	n_nums = convshort(s + 6);
X	n_strs = convshort(s + 8);
X	sz_strs = convshort(s + 10);
X
X	n_bools = sz_bools;
X	sz_nums = n_nums * 2;
X	sz_offs = n_strs * 2;
X
X	if ((sz_names + sz_bools) & 1)
X		sz_bools++;
X
X	if (12 + sz_names + sz_bools + sz_nums + sz_offs + sz_strs >= MAX_BUF)
X		return 1;
X
X	s += 12;
X	if ((cur->name_all = _addstr(s)) == NULL)
X		return 1;
X	s += sz_names;
X	while(--s >= buf + 12) {
X		if (*s == '|') {
X			if ((cur->name_long = _addstr(s + 1)) == NULL)
X				return 1;
X			break;
X		}
X	}
X
X	s = buf + 12 + sz_names;
X	for(i = 0; i < n_bools && _boolorder[i] != -1; i++, s++) {
X		if (cur->bools[_boolorder[i]] == -1 && *s == 1)
X			cur->bools[_boolorder[i]] = 1;
X	}
X
X	s = buf + 12 + sz_names + sz_bools;
X	for(i = 0; i < n_nums && _numorder[i] != -1; i++, s += 2) {
X		if (convshort(s) == -2) 
X			cur->nums[_numorder[i]] = -1;
X		else if (cur->nums[_numorder[i]] == -2 && convshort(s) != -1)
X			cur->nums[_numorder[i]] = convshort(s);
X	}
X
X	s = buf + 12 + sz_names + sz_bools + sz_nums;
X	strtbl = s + sz_offs;
X	for(i = 0; i < n_strs && _strorder[i] != -1; i++, s += 2) {
X		if (convshort(s) == -2)
X			cur->strs[_strorder[i]] = NULL;
X		else if (cur->strs[_strorder[i]] == (char *) -1
X			 && convshort(s) != -1) {
X#ifdef DEBUG
X			printf("$%s ", strnames[_strorder[i]]);
X#endif
X			if ((cur->strs[_strorder[i]]
X			     = _addstr(strtbl + convshort(s))) == NULL)
X				return 1;
X		} 
X	}
X
X	return 0;
X}
END_OF_FILE
if test 2573 -ne `wc -c <'gettbin.c'`; then
    echo shar: \"'gettbin.c'\" unpacked with wrong size!
fi
# end of 'gettbin.c'
fi
if test -f 'mkbinorder.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mkbinorder.c'\"
else
echo shar: Extracting \"'mkbinorder.c'\" \(1960 characters\)
sed "s/^X//" >'mkbinorder.c' <<'END_OF_FILE'
X/*
X * mkbinorder.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:30:04
X *
X */
X
X#define NOTLIB
X#include "defs.h"
X#include "term.h"
X
static const char SCCSid[] = "@(#) mytinfo mkbinorder.c 3.2 92/02/01 public domain, By Ross Ridge";
X
char cap[MAX_NAME];
char *p2c = cap;
char **p2p2c = &p2c;
X
int
main(argc, argv)
int argc;
char **argv; {
X	int r;
X	int ind;
X	FILE *f;
X
X	if (argc == 1)
X		f = stdin;
X	else if (argc == 2) {
X		f = fopen(argv[1], "r");
X		if (f == NULL) {
X			fprintf(stderr, "can't open %s\n", argv[1]);
X			exit(1);
X		}
X	} else {
X		fprintf(stderr, "argument count\n");
X		exit(1);
X	}
X
X	do {
X		r = fscanf(f, "%s", cap);
X	} while(r == 1 && strcmp(cap, "!") != 0);
X	if (r != 1) {
X		fprintf(stderr, "expected '!'\n");
X		exit(1);
X	}
X
X	puts("/*");
X	puts(" * binorder.c");
X	puts(" *");
X	puts(" * This file was generated automatically");
X	puts(" *");
X	puts(" */\n");
X
X	puts("int _boolorder[] = {");
X
X	while(1) {
X		r = fscanf(f, "%s", cap);
X		cap[MAX_TINFONAME] = '\0';
X		if (r != 1) {
X			fprintf(stderr, "unexpected EOF\n");
X			exit(1);
X		}
X		if (strcmp(cap, "#") == 0)
X			break;
X		ind = _findboolname(cap);
X		if (ind == -1) {
X			fprintf(stderr, "unknown bool name '%s'\n", cap);
X			continue;
X		}
X		printf("\t%d,\n", ind);
X	}
X	puts("\t-1");
X	puts("};\n");
X
X	puts("int _numorder[] = {");
X
X	while(1) {
X		r = fscanf(f, "%s", cap);
X		cap[MAX_TINFONAME] = '\0';
X		if (r != 1) {
X			fprintf(stderr, "unexpected EOF\n");
X			exit(1);
X		}
X		if (strcmp(cap, "$") == 0)
X			break;
X		ind = _findnumname(cap);
X		if (ind == -1) {
X			fprintf(stderr, "unknown num name '%s'\n", cap);
X			continue;
X		}
X		printf("\t%d,\n", ind);
X	}
X	puts("\t-1");
X	puts("};\n");
X
X	puts("int _strorder[] = {");
X
X	while(1) {
X		r = fscanf(f, "%s", cap);
X		cap[MAX_TINFONAME] = '\0';
X		if (r != 1)
X			break;
X		ind = _findstrname(cap);
X		if (ind == -1) {
X			fprintf(stderr, "unknown str name '%s'\n", cap);
X			continue;
X		}
X		printf("\t%d,\n", ind);
X	}
X	puts("\t-1");
X	puts("};\n");
X
X	return 0;
X}
END_OF_FILE
if test 1960 -ne `wc -c <'mkbinorder.c'`; then
    echo shar: \"'mkbinorder.c'\" unpacked with wrong size!
fi
# end of 'mkbinorder.c'
fi
if test -f 'mkcaplist.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mkcaplist.c'\"
else
echo shar: Extracting \"'mkcaplist.c'\" \(3333 characters\)
sed "s/^X//" >'mkcaplist.c' <<'END_OF_FILE'
X/*
X * mkcaplist.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:30:05
X *
X * mkcaplist [-n caps] [file]
X *
X * makes caplist.c from the cap_list file
X *
X */
X
X#define NOTLIB
X#include "defs.h"
X
static const char SCCSid[] = "@(#) mytinfo mkcaplist.c 3.2 92/02/01 public domain, By Ross Ridge";
X
X#define DEFAULT_CAPS	1000
X
struct caplist *list;
X
int
main(argc, argv)
int argc;
char **argv; {
X	FILE *f;
X	int caps = DEFAULT_CAPS;
X	int n;
X	register int i;
X
X	if (argc > 2 && argv[1][0] == '-' && argv[1][1] == 'n') {
X		caps = atoi(argv[2]);
X		argv += 2;
X		argc -= 2;
X	}
X
X	if (argc == 1) {
X		f = stdin;
X	} else if (argc == 2) {
X		f = fopen(argv[1], "r");
X		if (f == NULL) {
X			fprintf(stderr, "%s: can't open '%s'\n", argv[0],
X				argv[1]);
X			return 1;
X		}
X	} else {
X		fprintf(stderr, "%s: too many arguments\n", argv[0]);
X		fprintf(stderr, "usage: %s [-n caps] [file]\n", argv[0]);
X		return 1;
X	}
X
X	list = (struct caplist *) malloc(caps * sizeof(struct caplist));
X	if (list == NULL) {
X		fprintf(stderr, "%s: malloc failed.\n", argv[0]);
X		return 1;
X	}
X
X	n = readcaps(f, list, caps);
X	if (n > caps) {
X		fprintf(stderr, "%s: too many caps, use -n.\n", argv[0]);
X		return 1;
X	}
X	if (n == 0) {
X		fprintf(stderr, "%s: no caps in file.\n", argv[0]);
X		return 1;
X	}
X	if (n == -1) {
X		fprintf(stderr, "%s: bad caps line.\n", argv[0]);
X		return 1;
X	}
X	if (n == -2) {
X		fprintf(stderr, "%s: unexpected EOF.\n", argv[0]);
X		return 1;
X	}
X
X	puts("/*");
X	puts(" * caplist.c ");
X	puts(" *");
X	puts(" * This file was generated automatically.");
X	puts(" *");
X	puts(" */");
X	putchar('\n');
X
X	puts("char *boolnames[] = {");
X	for (i = 0; i < n; i++)
X		if (list[i].type == '!')
X			printf("\t\"%s\",\n", list[i].tinfo);
X	puts("\t(char *)0");
X	puts("};");
X	putchar('\n');
X
X	puts("char *boolcodes[] = {");
X	for (i = 0; i < n; i++)
X		if (list[i].type == '!')
X			printf("\t\"%s\",\n", list[i].tcap);
X	puts("\t(char *)0");
X	puts("};");
X	putchar('\n');
X
X	puts("char *boolfnames[] = {");
X	for (i = 0; i < n; i++)
X		if (list[i].type == '!')
X			printf("\t\"%s\",\n", list[i].var);
X	puts("\t(char *)0");
X	puts("};");
X	putchar('\n');
X
X	puts("char *numnames[] = {");
X	for (i = 0; i < n; i++)
X		if (list[i].type == '#')
X			printf("\t\"%s\",\n", list[i].tinfo);
X	puts("\t(char *)0");
X	puts("};");
X	putchar('\n');
X
X	puts("char *numcodes[] = {");
X	for (i = 0; i < n; i++)
X		if (list[i].type == '#')
X			printf("\t\"%s\",\n", list[i].tcap);
X	puts("\t(char *)0");
X	puts("};");
X	putchar('\n');
X
X	puts("char *numfnames[] = {");
X	for (i = 0; i < n; i++)
X		if (list[i].type == '#')
X			printf("\t\"%s\",\n", list[i].var);
X	puts("\t(char *)0");
X	puts("};");
X	putchar('\n');
X
X	puts("char *strnames[] = {");
X	for (i = 0; i < n; i++)
X		if (list[i].type == '$')
X			printf("\t\"%s\",\n", list[i].tinfo);
X	puts("\t(char *)0");
X	puts("};");
X	putchar('\n');
X
X	puts("char *strcodes[] = {");
X	for (i = 0; i < n; i++)
X		if (list[i].type == '$')
X			printf("\t\"%s\",\n", list[i].tcap);
X	puts("\t(char *)0");
X	puts("};");
X	putchar('\n');
X
X	puts("char *strfnames[] = {");
X	for (i = 0; i < n; i++)
X		if (list[i].type == '$')
X			printf("\t\"%s\",\n", list[i].var);
X	puts("\t(char *)0");
X	puts("};");
X	putchar('\n');
X
X	puts("char _strflags[] = {");
X	for (i = 0; i < n; i++)
X		if (list[i].type == '$')
X			printf("\t'%c',\n", list[i].flag);
X	puts("\t'\\0'");
X	puts("};");
X	putchar('\n');
X
X	return 0;
X}
END_OF_FILE
if test 3333 -ne `wc -c <'mkcaplist.c'`; then
    echo shar: \"'mkcaplist.c'\" unpacked with wrong size!
fi
# end of 'mkcaplist.c'
fi
if test -f 'mkcapsort.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mkcapsort.c'\"
else
echo shar: Extracting \"'mkcapsort.c'\" \(3687 characters\)
sed "s/^X//" >'mkcapsort.c' <<'END_OF_FILE'
X/*
X * mkcapsort.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/06/04 11:38:02
X *
X * mkcapsort
X *
X * make the sorted lists of pointers to strins
X *
X */
X
X#define NOTLIB
X#include "defs.h"
X#include "term.h"
X
X#ifdef USE_MYQSORT
X#include "qsort.c"
X#endif
X
static const char SCCSid[] = "@(#) mytinfo mkcapsort.c 3.3 92/06/04 public domain, By Ross Ridge";
X
char **sboolnames[NUM_OF_BOOLS], **sboolcodes[NUM_OF_BOOLS], **sboolfnames[NUM_OF_BOOLS];
char **snumnames[NUM_OF_NUMS], **snumcodes[NUM_OF_NUMS], **snumfnames[NUM_OF_NUMS];
char **sstrnames[NUM_OF_STRS], **sstrcodes[NUM_OF_STRS], **sstrfnames[NUM_OF_STRS];
X
X
int
main() {
X	register int i;
X	
X	i = NUM_OF_BOOLS;
X	while(i) {
X		i--;
X		sboolnames[i] = &boolnames[i];
X		sboolcodes[i] = &boolcodes[i];
X		sboolfnames[i] = &boolfnames[i];
X	}
X	
X	i = NUM_OF_NUMS;
X	while(i) {
X		i--;
X		snumnames[i] = &numnames[i];
X		snumcodes[i] = &numcodes[i];
X		snumfnames[i] = &numfnames[i];
X	}
X
X	i = NUM_OF_STRS;
X	while(i) {
X		i--;
X		sstrnames[i] = &strnames[i];
X		sstrcodes[i] = &strcodes[i];
X		sstrfnames[i] = &strfnames[i];
X	}
X
X	qsort((anyptr) sboolnames, NUM_OF_BOOLS, sizeof(*sboolnames), _compar);
X	qsort((anyptr) sboolcodes, NUM_OF_BOOLS, sizeof(*sboolcodes), _compar);
X	qsort((anyptr) sboolfnames, NUM_OF_BOOLS, sizeof(*sboolfnames),_compar);
X	qsort((anyptr) snumnames, NUM_OF_NUMS, sizeof(*snumnames), _compar);
X	qsort((anyptr) snumcodes, NUM_OF_NUMS, sizeof(*snumcodes), _compar);
X	qsort((anyptr) snumfnames, NUM_OF_NUMS, sizeof(*snumfnames), _compar);
X	qsort((anyptr) sstrnames, NUM_OF_STRS, sizeof(*sstrnames), _compar);
X	qsort((anyptr) sstrcodes, NUM_OF_STRS, sizeof(*sstrcodes), _compar);
X	qsort((anyptr) sstrfnames, NUM_OF_STRS, sizeof(*sstrfnames), _compar);
X
X	printf("/*\n");
X	printf(" * capsort.c\n");
X	printf(" *\n");
X	printf(" * This file was generated automatically.\n");
X	printf(" *\n");
X	printf(" */\n\n");
X
X	puts("extern char *boolnames[], *boolcodes[], *boolfnames[];");
X	puts("extern char *numnames[], *numcodes[], *numfnames[];");
X	puts("extern char *strnames[], *strcodes[], *strfnames[];");
X	putchar('\n');
X
X	printf("char **_sboolnames[] = {\n");
X	for(i = 0; i < NUM_OF_BOOLS; i++)
X		printf("\tboolnames + %d,\n", sboolnames[i] - boolnames);
X	printf("	(char **) 0\n");
X	printf("};\n\n");
X
X	printf("char **_sboolcodes[] = {\n");
X	for(i = 0; i < NUM_OF_BOOLS; i++)
X		printf("\tboolcodes + %d,\n", sboolcodes[i] - boolcodes);
X	printf("	(char **) 0\n");
X	printf("};\n\n");
X
X	printf("char **_sboolfnames[] = {\n");
X	for(i = 0; i < NUM_OF_BOOLS; i++)
X		printf("\tboolfnames + %d,\n", sboolfnames[i] - boolfnames);
X	printf("	(char **) 0\n");
X	printf("};\n\n");
X
X	printf("char **_snumnames[] = {\n");
X	for(i = 0; i < NUM_OF_NUMS; i++)
X		printf("\tnumnames + %d,\n", snumnames[i] - numnames);
X	printf("	(char **) 0\n");
X	printf("};\n\n");
X
X	printf("char **_snumcodes[] = {\n");
X	for(i = 0; i < NUM_OF_NUMS; i++)
X		printf("\tnumcodes + %d,\n", snumcodes[i] - numcodes);
X	printf("	(char **) 0\n");
X	printf("};\n\n");
X
X	printf("char **_snumfnames[] = {\n");
X	for(i = 0; i < NUM_OF_NUMS; i++)
X		printf("\tnumfnames + %d,\n", snumfnames[i] - numfnames);
X	printf("	(char **) 0\n");
X	printf("};\n\n");
X
X	printf("char **_sstrnames[] = {\n");
X	for(i = 0; i < NUM_OF_STRS; i++)
X		printf("\tstrnames + %d,\n", sstrnames[i] - strnames);
X	printf("	(char **) 0\n");
X	printf("};\n\n");
X
X	printf("char **_sstrcodes[] = {\n");
X	for(i = 0; i < NUM_OF_STRS; i++) 
X		printf("\tstrcodes + %d,\n", sstrcodes[i] - strcodes);
X	printf("	(char **) 0\n");
X	printf("};\n\n");
X
X	printf("char **_sstrfnames[] = {\n");
X	for(i = 0; i < NUM_OF_STRS; i++)
X		printf("\tstrfnames + %d,\n", sstrfnames[i] - strfnames);
X	printf("	(char **) 0\n");
X	printf("};\n\n");
X
X	return 0;
X}
END_OF_FILE
if test 3687 -ne `wc -c <'mkcapsort.c'`; then
    echo shar: \"'mkcapsort.c'\" unpacked with wrong size!
fi
# end of 'mkcapsort.c'
fi
if test -f 'mkdir.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mkdir.c'\"
else
echo shar: Extracting \"'mkdir.c'\" \(570 characters\)
sed "s/^X//" >'mkdir.c' <<'END_OF_FILE'
X/*
X * mkdir.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/06/04 11:38:33
X */
X
X#ifdef USE_MYMKDIR
X
X#define MKDIR_COMMAND "/bin/mkdir"
X
X#ifdef USE_SCCS_IDS
static char const SCCSid[] = "@(#) mytinfo mkdir.c 3.2 92/06/04 public domain, By Ross Ridge";
X#endif
X
static int
mkdir(name, perms) 
char *name;
int perms; {
X	static const char cmd[] = MKDIR_COMMAND;
X	char *s;
X
X	s = malloc(strlen(name) + sizeof(cmd) + 1);
X	if (s == NULL) {
X		return -1;
X	}
X	sprintf(s, "%s %s", cmd, name);
X	if (system(s)) {
X		free(s);
X		return -1;
X	}
X	free(s);
X	return chmod(name, perms);
X}
X
X#endif
END_OF_FILE
if test 570 -ne `wc -c <'mkdir.c'`; then
    echo shar: \"'mkdir.c'\" unpacked with wrong size!
fi
# end of 'mkdir.c'
fi
if test -f 'mktermhead.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mktermhead.c'\"
else
echo shar: Extracting \"'mktermhead.c'\" \(2916 characters\)
sed "s/^X//" >'mktermhead.c' <<'END_OF_FILE'
X/*
X * mktermhead.c
X *
X * By Ross Ridge
X * Public Domain 
X * 92/06/04 11:38:57
X *
X * mktermhead [-n caps] file
X *
X * generates term.head
X *
X */
X
X#define NOTLIB
X#include "defs.h"
X
static const char SCCSid[] = "@(#) mytinfo mktermhead.c 3.3 92/06/04 public domain, By Ross Ridge";
X
X#define DEFAULT_CAPS	1000
X
X
int
main(argc, argv)
int argc;
char **argv; {
X	FILE *f;
X	int caps = DEFAULT_CAPS;
X	int n;
X	register int i;
X	int nb, ns, nn;
X	struct caplist *list;
X
X	if (argc > 2 && argv[1][0] == '-' && argv[1][1] == 'n') {
X		caps = atoi(argv[2]);
X		argv += 2;
X		argc -= 2;
X	}
X
X	if (argc == 1) {
X		f = stdin;
X	} else if (argc == 2) {
X		f = fopen(argv[1], "r");
X		if (f == NULL) {
X			fprintf(stderr, "%s: can't open '%s'\n", argv[0],
X				argv[1]);
X			return 1;
X		}
X	} else {
X		fprintf(stderr, "%s: too many arguments\n", argv[0]);
X		fprintf(stderr, "usage: %s [-n caps] [file]\n", argv[0]);
X		return 1;
X	}
X
X	list = (struct caplist *) malloc(caps * sizeof(struct caplist));
X	if (list == NULL) {
X		fprintf(stderr, "%s: malloc failed.\n", argv[0]);
X		return 1;
X	}
X
X	n = readcaps(f, list, caps);
X	if (n > caps) {
X		fprintf(stderr, "%s: too many caps, use -n.\n", argv[0]);
X		return 1;
X	}
X	switch(n) {
X	case 0:
X		fprintf(stderr, "%s: no caps in file.\n", argv[0]);
X		return 1;
X	case -1:
X		fprintf(stderr, "%s: bad caps line.\n", argv[0]);
X		return 1;
X	case -2:
X		fprintf(stderr, "%s: unexpected EOF.\n", argv[0]);
X		return 1;
X	}
X
X	puts("/*");
X	puts(" * term.h ");
X	puts(" *");
X	puts(" * This file was generated automatically.");
X	puts(" *");
X	puts(" */");
X	putchar('\n');
X	puts("#ifndef _TERM_H_");
X	puts("#define _TERM_H_");
X	putchar('\n');
X	nb = 0;
X	for (i = 0; i < n; i++) {
X		if (list[i].type == '!') {
X			printf("#define %-*s (_CUR_TERM.bools[%d])\n",
X			       MAX_VARNAME, list[i].var, nb);
X			nb++;
X		}
X	}
X
X	nn = 0;
X	for (i = 0; i < n; i++) {
X		if (list[i].type == '#') {
X			printf("#define %-*s (_CUR_TERM.nums[%d])\n",
X			       MAX_VARNAME, list[i].var, nn);
X			nn++;
X		}
X	}
X
X	ns = 0;
X	for (i = 0; i < n; i++) {
X		if (list[i].type == '$') {
X			printf("#define %-*s (_CUR_TERM.strs[%d])\n",
X			       MAX_VARNAME, list[i].var, ns);
X			ns++;
X		}
X	}
X
X	putchar('\n');
X
X	printf ("#define NUM_OF_BOOLS\t%d\n", nb);
X	printf ("#define NUM_OF_NUMS\t%d\n", nn);
X	printf ("#define NUM_OF_STRS\t%d\n", ns);
X
X	putchar('\n');
X	puts("#ifndef OVERRIDE");
X	puts("#undef _USE_SGTTY");
X#ifdef USE_SGTTY
X	puts("#define _USE_SGTTY");
X#endif
X	puts("#undef _USE_TERMIO");
X#ifdef USE_TERMIO
X	puts("#define _USE_TERMIO");
X#endif
X	puts("#undef _USE_SMALLMEM");
X#ifdef USE_SMALLMEM
X	puts("#define _USE_SMALLMEM");
X#endif
X#if 0
X	puts("#undef _USE_PROTOTYPES");
X#ifdef USE_PROTOTYPES
X	puts("#define _USE_PROTOTYPES");
X#endif
X#endif
X	puts("#undef _USE_WINSZ");
X#ifdef USE_WINSZ
X	puts("#define _USE_WINSZ");
X#endif
X	puts("#undef _MAX_CHUNK");
X	printf("#define _MAX_CHUNK %d\n", MAX_CHUNK);
X	puts("#endif /* OVERRIDE */");
X	putchar('\n');
X
X	return 0;
X}
END_OF_FILE
if test 2916 -ne `wc -c <'mktermhead.c'`; then
    echo shar: \"'mktermhead.c'\" unpacked with wrong size!
fi
# end of 'mktermhead.c'
fi
if test -f 'mkversion.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mkversion.c'\"
else
echo shar: Extracting \"'mkversion.c'\" \(588 characters\)
sed "s/^X//" >'mkversion.c' <<'END_OF_FILE'
X/*
X * mkversion.c
X *
X * By Ross Ridge
X * Public Domain 
X * 92/02/01 07:30:09
X *
X * generates version.c
X *
X */
X
X#define NOTLIB
X#include "defs.h"
X
X#include "version.h"
X
static const char SCCSid[] = "@(#) mytinfo mkversion.c 3.2 92/02/01 public domain, By Ross Ridge";
X
int
main(argc, argv)
int argc;
char **argv; {
X	puts("/*");
X	puts(" * version.c ");
X	puts(" *");
X	puts(" * This file was generated automatically.");
X	puts(" *");
X	puts(" */");
X	putchar('\n');
X
X	printf("char _mytinfo_version[] = \"@(#) mytinfo: Release %d, Patchlevel %d.\";\n",
X	       RELEASE, PATCHLEVEL);
X
X	return 0;
X}
END_OF_FILE
if test 588 -ne `wc -c <'mkversion.c'`; then
    echo shar: \"'mkversion.c'\" unpacked with wrong size!
fi
# end of 'mkversion.c'
fi
if test -f 'quit.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'quit.c'\"
else
echo shar: Extracting \"'quit.c'\" \(1053 characters\)
sed "s/^X//" >'quit.c' <<'END_OF_FILE'
X/*
X * quit.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:30:14
X *
X * quit with a diagnostic message printed on stderr
X *
X */
X
X#define NOTLIB
X#include "defs.h"
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo quit.c 3.2 92/02/01 public domain, By Ross Ridge";
X#endif
X
char *prg_name;
X
X#if defined(USE_PROTOTYPES) && !defined(lint)
void (*cleanup)(int);
X#else
void (*cleanup)();
X#endif
X
X/* PRINTFLIKE2 */
X#ifdef USE_STDARG
X#ifdef USE_PROTOTYPES
void
quit(int e, char *fmt, ...)
X#else
void quit(e, fmt)
int e;
char *fmt;
X#endif
X#else
void quit(va_alist)
va_dcl
X#endif
X{
X#ifndef USE_STDARG
X	int e;
X	char *fmt;
X#endif
X	va_list ap;
X
X#ifdef USE_STDARG
X	va_start(ap, fmt);
X#else
X	va_start(ap);
X	e = va_arg(ap, int);
X	fmt = va_arg(ap, char *);
X#endif
X
X	(*cleanup)(e);
X
X	if (e != 0)
X		fprintf(stderr, "%s: ", prg_name);
X#ifdef USE_DOPRNT
X	_doprnt(fmt, ap, stderr);
X#else
X	vfprintf(stderr, fmt, ap);
X#endif
X	putc('\n', stderr);
X	if (e > 0 && e < sys_nerr) {
X		fprintf(stderr, "%d - %s\n", e, sys_errlist[e]);
X	}
X	fflush(stderr);
X	exit(e);
X}
END_OF_FILE
if test 1053 -ne `wc -c <'quit.c'`; then
    echo shar: \"'quit.c'\" unpacked with wrong size!
fi
# end of 'quit.c'
fi
if test -f 'readcaps.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'readcaps.c'\"
else
echo shar: Extracting \"'readcaps.c'\" \(2264 characters\)
sed "s/^X//" >'readcaps.c' <<'END_OF_FILE'
X/*
X * readcaps.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:30:15
X *
X * Read in the cap_list file
X *
X */
X
X#define NOTLIB
X#include "defs.h"
X
X#include <ctype.h>
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo readcaps.c 3.2 92/02/01 public domain, By Ross Ridge";
X#endif
X
X#ifdef __GNUC__
X__inline__
X#endif
static int
skipline(f)
register FILE *f; {
X	register int c;
X
X	do {
X		c = getc(f);
X		if (c == EOF)
X			return EOF;
X#ifdef TEST
X		putchar(c);
X#endif
X	} while (c != '\n');
X
X	return 0;
X}
X
X#ifdef __GNUC__
X__inline__
X#endif
static int
getfield(f, s, len)
register FILE *f;
register char *s;
int len; {
X	register int c;
X	int i;
X#ifdef TEST
X	char *start = s;
X#endif
X
X	do {
X		c = getc(f);
X		if (c == EOF)
X			return EOF;
X	} while (c != '\n' && isspace(c));
X	if (c == '\n')
X		return 0;
X
X	i = 0;
X	while(!isspace(c)) {
X		if (i++ < len)
X			*s++ = c;
X		c = getc(f);
X		if (c == EOF)
X			return EOF;
X			
X	}
X	*s = '\0';
X#ifdef TEST
X	printf(" %s", start);
X#endif
X	return c;
X}
X
int
readcaps(f, buf, max)
XFILE *f;
register struct caplist *buf;
int max; {
X	int type;
X	register int count;
X	int c;
X	static char dummy;
X
X	count = 0;
X	type = getc(f);
X	while(type != EOF) {
X		if (type == '$' || type == '!' || type == '#') {
X			if (count >= max)
X				return count + 1;
X#ifdef TEST
X			putchar(type);
X#endif
X			buf[count].type = type;
X
X			if (type == '$') {
X				c = getc(f);
X				if (c == EOF)
X					break;
X				if (c == 'G')
X					buf[count].flag = 'G';
X				else if (c == 'K')
X					buf[count].flag = 'K';
X				else
X					buf[count].flag = ' ';
X			}
X	
X			c = getfield(f, buf[count].var, MAX_VARNAME);
X			if (c == EOF || c == '\n' || c == 0)
X				return -1;
X			c = getfield(f, buf[count].tinfo, MAX_TINFONAME);
X			if (c == EOF || c == '\n' || c == 0)
X				return -1;
X			c = getfield(f, buf[count].tcap, MAX_TCAPNAME);
X			if (c == EOF || c == 0)
X				return -1;
X			if (c != '\n')
X				if (getfield(f, &dummy, 1) != 0)
X					return -1;
X			count++;
X#ifdef TEST
X			putchar('\n');
X#endif
X		} else {
X#ifdef TEST
X			putchar(type);
X#endif
X			if (type != '\n' && skipline(f) == EOF)
X				return -1;
X		}
X		type = getc(f);
X	}
X	return count;
X}
X
X#ifdef TEST
struct caplist list[1000];
X
int
main() {
X	int ret;
X
X	ret = readcaps(stdin, list, 1000);
X	printf("ret = %d\n", ret);
X	return 0;
X}
X#endif
END_OF_FILE
if test 2264 -ne `wc -c <'readcaps.c'`; then
    echo shar: \"'readcaps.c'\" unpacked with wrong size!
fi
# end of 'readcaps.c'
fi
if test -f 'strtok.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'strtok.c'\"
else
echo shar: Extracting \"'strtok.c'\" \(1366 characters\)
sed "s/^X//" >'strtok.c' <<'END_OF_FILE'
X/*
X * strtok.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/06/04 11:40:12
X *
X */
X
X#ifdef TEST
X
X#ifndef LIBTEST
X#define USE_MYSTRTOK
X#endif
X#include <stdio.h>
X
X#else
X
X#include "defs.h"
X
X#endif
X
X#ifdef USE_MYSTRTOK
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo strtok.c 3.3 92/06/04 public domain, By Ross Ridge";
X#endif
X
static char *
strtok(s1, s2)
char *s1, *s2; {
X	static char *pos = NULL;
X	register char *s, *d;
X	char *start;
X
X	if (s1 == NULL) {
X		s = pos;
X		if (s == NULL)
X			return NULL;
X	} else {
X		s = s1;
X		while(*s != '\0') {
X			d = s2;
X			while(*d != *s) {
X				if (*d == '\0')
X					goto first; /* Oh, no! A goto! */
X				d++;
X			}
X			s++;
X		}
X		pos = NULL;
X		return NULL;
X	}
X
first:
X	start = s;
X	while(*s != '\0') {
X		d = s2;
X		while(*d != '\0') {
X			if (*s == *d) {
X				*s++ = '\0';
X				while(*s != '\0') {
X					d = s2;
X					while(*s != *d) {
X						if (*d == '\0') {
X							pos = s;
X							return start;
X						}
X						d++;
X					}
X					s++;
X				}
X				pos = NULL;
X				return start;
X			}
X			d++;
X		}
X		s++;
X	}
X	pos = NULL;
X	return start;
X}
X
X#endif
X
X#ifdef TEST
int main(argc, argv)
int argc;
char **argv; {
X	char *s;
X	char s1[100];
X	char *s2;
X
X	if (argc > 1)
X		s2 = argv[1];
X	else
X		s2 = " ";
X
X	while (gets(s1) != NULL) {
X		s = strtok(s1, s2);
X		while(s != NULL) {
X			printf("'%s'\n", s);
X			s = strtok(NULL, s2);
X		}
X	}
X
X	return 0;
X}
X#endif
END_OF_FILE
if test 1366 -ne `wc -c <'strtok.c'`; then
    echo shar: \"'strtok.c'\" unpacked with wrong size!
fi
# end of 'strtok.c'
fi
if test -f 'tcapvars.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tcapvars.c'\"
else
echo shar: Extracting \"'tcapvars.c'\" \(524 characters\)
sed "s/^X//" >'tcapvars.c' <<'END_OF_FILE'
X/*
X * tcapvars.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:30:21
X *
X */
X
X#include "defs.h"
X#include "term.h"
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo tcapvars.c 3.2 92/02/01 public domain, By Ross Ridge";
X#endif
X
char PC;
short ospeed;
char *UP, *BC;
X
void
X_figure_termcap() {
X#if defined(USE_SGTTY) || defined(USE_TERMIO)
X#ifdef USE_SMALLMEM
X	extern unsigned short _baud_tbl[];
X#else
X	extern long _baud_tbl[];
X#endif
X	cur_term->padch = PC;
X	cur_term->baudrate = _baud_tbl[ospeed];
X#endif
X}
END_OF_FILE
if test 524 -ne `wc -c <'tcapvars.c'`; then
    echo shar: \"'tcapvars.c'\" unpacked with wrong size!
fi
# end of 'tcapvars.c'
fi
if test -f 'tconv.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tconv.1'\"
else
echo shar: Extracting \"'tconv.1'\" \(3823 characters\)
sed "s/^X//" >'tconv.1' <<'END_OF_FILE'
X.\" @(#) mytinfo tconv.1 3.2 92/02/01 public domain, By Ross Ridge
X.TH CONV 1 "92/02/01" "tinfo"
X.SH NAME
tconv \- convert between termcap, terminfo source and terminfo binary
X.SH SYNOPSIS
X.B tconv
X[\fB\-b\fR]
X[\fB\-c\fR\ [\fB\-OUGd\fR]]
X[\fB\-i\fR]
X[\fB\-B\fR\ [\fB\-D\fR\ dir]]
X[\fB\-I\fR]
X[\fB\-k\fR]
X[\fB\-V\fR]
X[\fB\-t\fR\ term]
X[file]
X.br
X.B tic
X[file]
X.br
X.B cap2info
X[\fB\-t\fR\ term]
X[\fB\-OUGdk\fR]]
X[file]
X.SH DESCRIPTION
X.I tconv
converts between the three terminal descriptions,
termcap, terminfo source, and terminfo binary,
that the
X.I tinfo
library uses.
It performs the same functions of
X.IR captoinfo (1M)
and 
X.IR tic (1M)
of System V.
It also can be used to generate a terminfo source listing from a terminfo
binary, one of the functions of System V's
X.IR infocmp (1M).
X.SS Translation Options
X.PD 0
X.TP
X.B \-c
convert from termcap
X.TP
X.B \-i
convert from terminfo source
X.TP
X.B \-b
convert from terminfo binary
X.TP
X.B \-B
convert to terminfo binary
X.TP
X.B \-I
convert to terminfo source
X.PD
X.PP
If a file is specified, one of
X.B \-c
or
X.B \-i
must specified and the whole file while be translated.
If no file is specified then the input options will only restrict looking
for the terminal to be translated in places likely have descriptions
of the desired type
X(ie. with the
X.B -c
option in the
X.B TERMCAP
environment variable, and in
X.IR /etc/termcap ,
with the
X.B -i
option in the
X.B TERMINFO
environment variable, and in
X.IR /usr/lib/terminfo ),
otherwise
X.I tconv
will look in all available databases.
If neither 
X.B \-I
or
X.B \-B
are given the
X.B \-I
option will be assumed.
If the 
X.B \-B
option is used, the compiled output will be put in the the
terminfo database, otherwise standard output is used.
X.PP
You cannot translate from terminfo binary to terminfo binary.
Translating from terminfo source to terminfo source is possible, 
but not of much use in most cases, as 
X.B use=
fields will be followed and incorporated into the output terminal
description. 
X.PP
X.I tconv
should be able translate all standard termcap parameterized strings
terminfo format, but complex strings using GNU's %a code may be
too hard to translate.
If
X.I tconv
thinks a termcap string is already in terminfo format (if a %p
code appears in the string), it won't try to translate it.
String capabilities that don't take parameters won't be translated.
X.PP
X.B 
X.SS Termcap options
The following options are available when translating termcap entries 
X(\fB\-c\fR options is used).
X.PP
X.PD 0
X.TP 
X.B \-d
don't supply any defaults for missing capabilities
X.TP
X.B \-O
include obsolete termcap capabilities
X.TP
X.B \-G
include GNU capabilities
X.TP
X.B \-U
include UW capabilities
X.PD
X.SS Other Options
X.PD 0
X.TP
X.B \-k
keep comments when translating a file
X.TP
X.B \-V
print version information and exit
X.TP
X.BI \-D " " dir
directory to put terminfo binaries in
X.TP
X.BI \-t " " term
terminal name to translate
X.PD
X.PP
If no terminal specified with the
X.B \-t
option, then the terminal name to to translate will be taken from the
environment variable
X.BR TERM .
X.SH FILES
X.PD 0
X.TP 2i
X.B /usr/lib/terminfo
The default location to get and put terminfo binaries.
X.TP
X.B /usr/lib/terminfo/terminfo.src
The default filename of the terminfo source file.
X.TP
X.B /etc/termcap
The default filename of the termcap database.
X.PD
X.SH "SEE ALSO"
captoinfo(1M),
tic(1M),
infocmp(1M),
termcap(3),
curses(3X),
term(4),
termcap(4),
terminfo(4).
X.SH DIAGNOSTICS
The line number of a warning message when translating a file
may refer to the last line of an entry instead of the line in the entry 
that generated the warning.
X.SH BUGS
More warning messages could be generated.
X.I tconv
can't translate to termcap.  Binaries generated will have cancelled
capabilities marked as cancelled, which is incompatible with
System V Release 2.0 terminfo.
END_OF_FILE
if test 3823 -ne `wc -c <'tconv.1'`; then
    echo shar: \"'tconv.1'\" unpacked with wrong size!
fi
# end of 'tconv.1'
fi
if test -f 'term.tail' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'term.tail'\"
else
echo shar: Extracting \"'term.tail'\" \(2340 characters\)
sed "s/^X//" >'term.tail' <<'END_OF_FILE'
X/* 
X * 92/02/01 07:30:28
X * @(#) mytinfo term.tail 3.2 92/02/01 public domain, By Ross Ridge
X *
X */
X
X#ifdef _USE_TERMIO
X#ifndef ICANON
X#include <termio.h>
X#endif
X#if defined(_USE_WINSZ) && defined(xenix)
X#include <sys/stream.h>
X#include <sys/ptem.h>
X#endif
X#endif
X
X#ifdef _USE_SGTTY
X#ifndef CBREAK
X#include <sgtty.h>
X#endif
X#endif
X
typedef struct _terminal {
X	int fd;
X#ifdef _USE_SMALLMEM
X	unsigned short baudrate;
X	unsigned pad:1, xon:1, termcap:1;
X#else
X	int pad;
X	int xon;
X	int termcap;
X	long baudrate;
X#endif
X	char padch;
X	short true_lines, true_columns;
X	struct strbuf {
X		struct strbuf *next;
X#ifdef _USE_SMALLMEM
X		short len;
X#else
X		int len;
X#endif
X		char buf[_MAX_CHUNK];
X	} *strbuf;
X	char *name, *name_long, *name_all;
X#ifdef _USE_SGTTY
X	struct sgtty_str {
X		struct sgttyb v6;
X#ifdef TIOCGETC
X		struct tchars v7;
X#endif
X#ifdef TIOCLGET
X		int bsd;
X#endif
X#ifdef TIOCGLTC
X		struct ltchars bsd_new;
X#endif
X	} prog_mode, shell_mode;
X#else	/* _USE_SGTTY */
X#ifdef _USE_TERMIO
X	struct termio prog_mode, shell_mode;
X#endif 
X#endif	/* else _USE_SGTTY */
X#ifdef _USE_WINSZ
X#ifdef TIOCGWINSZ
X	struct winsize prog_winsz, shell_winsz;
X#endif
X#endif
X	char bools[NUM_OF_BOOLS];
X	short nums[NUM_OF_NUMS];
X	char *strs[NUM_OF_STRS];
X} TERMINAL;
X
X#ifndef _CUR_TERM
X#ifdef SINGLE
X#define _CUR_TERM _term_buf
X#else
X#define _CUR_TERM (*cur_term)
X#endif
X#endif
X
extern TERMINAL *cur_term;
extern TERMINAL _term_buf;
X
X#ifdef USE_PROTOTYPES
extern char *tparm(char *, ...);
extern int setupterm(char *, int, int *), set_curterm(TERMINAL *);
extern int del_curterm(TERMINAL *), tputs(char *, int, int (*)());
extern int putp(char *);
extern int tigetflag(char *), tigetnum(char *);
extern char *tigetstr(char *);
extern int def_prog_mode(void), def_shell_mode(void);
extern int reset_prog_mode(void), reset_shell_mode(void);
X#else
extern char *tparm();
extern int setupterm(), set_curterm();
extern int del_curterm(), tputs();
extern int putp();
extern int tigetflag(), tigetnum();
extern char *tigetstr();
extern int def_prog_mode(), def_shell_mode();
extern int reset_prog_mode(), reset_shell_mode();
X#endif
X
extern char *boolnames[], *boolcodes[], *boolfnames[];
extern char *numnames[], *numcodes[], *numfnames[];
extern char *strnames[], *strcodes[], *strfnames[];
X
X#ifndef OK
X#undef ERR
X#define OK (0)
X#define ERR (-1)
X#endif
X
X#endif /* _TERM_H_ */
END_OF_FILE
if test 2340 -ne `wc -c <'term.tail'`; then
    echo shar: \"'term.tail'\" unpacked with wrong size!
fi
# end of 'term.tail'
fi
if test -f 'termcap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'termcap.c'\"
else
echo shar: Extracting \"'termcap.c'\" \(2255 characters\)
sed "s/^X//" >'termcap.c' <<'END_OF_FILE'
X/*
X * termcap.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/06/01 07:43:08
X *
X * termcap compatibility functions
X *
X */
X
X#include "defs.h"
X#include "term.h"
X
static const char SCCSid[] = "@(#) mytinfo termcap.c 3.3 92/06/01 public domain, By Ross Ridge";
X
extern char _mytinfo_version[];
static char *force = _mytinfo_version;
X
int
tgetent(buf, term)
char *term, *buf; {
X	char *s;
X	struct term_path *path;
X	int r = -1;
X	int fd;
X
X	if (term == NULL) 
X		term = getenv("TERM");
X	if (term == NULL)
X		return 0;
X
X	path = _buildpath("$MYTERMINFO", 2,
X			  "$TERMINFO", 2,
X			  "$TERMCAP", 1,
X#ifdef TERMINFODIR
X			  TERMINFODIR, 0,
X#endif
X#ifdef TERMCAPFILE
X			  TERMCAPFILE, 0,
X#endif
X#ifdef TERMINFOSRC
X			  TERMINFOSRC, 0,
X#endif
X			  NULL, -1);
X
X	if (path == NULL)
X		return -1;
X
X#if 1
X	{
X		char buf1[MAX_BUF];
X		r = _fillterm(term, path, buf1);
X	}
X#else
X	r = _fillterm(term, path, buf);
X#endif
X
X	_delpath(path);
X
X	switch(r) {
X	case -3:
X	case -2:
X	case -1:
X		return -1;
X	case 0:
X		return 0;
X	case 1:
X	case 2:
X	case 3:
X		if (isatty(1))
X			fd = 1;
X		else if (isatty(2))
X			fd = 2;
X		else if (isatty(3))	/* V10 /dev/tty ?? */
X			fd = 3;
X		else if (isatty(0))
X			fd = 0;
X		else
X			fd = 1;
X
X		cur_term->fd = fd;
X		_term_buf.fd = fd;
X
X		if (_init_tty() == ERR)
X			return 0;
X		if ((s = getenv("LINES")) != NULL && atoi(s) > 0) 
X			lines = atoi(s);
X		if ((s = getenv("COLUMNS")) != NULL && atoi(s) > 0)
X			columns = atoi(s);
X		cur_term->termcap = 1;
X		return 1;
X	default:
X		return -1;
X	}
X}
X
static char cap2[3];
X
int
tgetnum(cap)
char *cap; {
X	int ind;
X
X	cap2[0] = cap[0]; 
X	cap2[1] = cap[1];
X	cap2[2] = '\0';
X
X	ind = _findnumcode(cap2);
X	if (ind == -1)
X		return -1;
X	return cur_term->nums[ind];
X}
X
int
tgetflag(cap)
char *cap; {
X	int ind;
X
X	cap2[0] = cap[0]; 
X	cap2[1] = cap[1];
X	cap2[2] = '\0';
X
X	ind = _findboolcode(cap2);
X	if (ind == -1)
X		return 0;
X	return cur_term->bools[ind];
X}
X
char *
tgetstr(cap, area)
char *cap;
char **area; {
X	register char *sp, *dp;
X	int ind;
X
X	cap2[0] = cap[0]; 
X	cap2[1] = cap[1];
X	cap2[2] = '\0';
X
X	ind = _findstrcode(cap2);
X	if (ind == -1)
X		return NULL;
X	sp = cur_term->strs[ind];
X	if (area == NULL || sp == NULL)
X		return sp;
X	dp = *area;
X	while (*sp != '\0')
X		*dp++ = *sp++;
X	*dp++ = '\0';
X	sp = *area;
X	*area = dp;
X	return sp;
X}
END_OF_FILE
if test 2255 -ne `wc -c <'termcap.c'`; then
    echo shar: \"'termcap.c'\" unpacked with wrong size!
fi
# end of 'termcap.c'
fi
if test -f 'terminfo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'terminfo.c'\"
else
echo shar: Extracting \"'terminfo.c'\" \(2068 characters\)
sed "s/^X//" >'terminfo.c' <<'END_OF_FILE'
X/*
X * terminfo.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:30:30
X *
X * terminfo compatible libary functions
X *
X */
X
X#include "defs.h"
X#include "term.h"
X
static const char SCCSid[] = "@(#) mytinfo terminfo.c 3.2 92/02/01 public domain, By Ross Ridge";
X
extern char _mytinfo_version[];
static char *force = _mytinfo_version;
X
X#ifdef USE_FAKE_STDIO
X
X#ifdef __GNUC__
X__inline__
X#endif
static int
printerr(msg)
char *msg; {
X	return write(2, msg, strlen(msg));
X}
X
X#define RETERR(e, msg)  { (err == NULL ? (printerr(msg), exit(1), 0) \
X				       : (*err = e)); return ERR; }
X
X#else
X
X#define RETERR(e, msg)  { (err == NULL ? (fprintf(stderr, msg), exit(1), 0) \
X				       : (*err = e)); return ERR; }
X
X#endif
X
int
setupterm(term, fd, err)
char *term;
int fd;
int *err; {
X	struct term_path *path;
X	char *s;
X	int r = -1;
X	char buf[MAX_BUF];
X
X
X	if (term == NULL) 
X		term = getenv("TERM");
X	if (term == NULL)
X		RETERR(0, "TERM not set\n")
X
X	path = _buildpath("$MYTERMINFO", 2,
X			  "$TERMINFO", 2,
X			  "$TERMCAP", 1,
X#ifdef TERMINFODIR
X			  TERMINFODIR, 0,
X#endif
X#ifdef TERMCAPFILE
X			  TERMCAPFILE, 0,
X#endif
X#ifdef TERMINFOSRC
X			  TERMINFOSRC, 0,
X#endif
X			  NULL, -1);
X
X	if (path == NULL)
X		RETERR(0, "malloc error\n");
X
X	r = _fillterm(term, path, buf);
X
X	_delpath(path);
X
X	switch(r) {
X	case -3:
X		RETERR(0, "malloc error\n");
X	case -2:
X		RETERR(-1, "bad format\n");
X	case -1:
X		RETERR(-1, "database not found\n");
X	case 0:
X		RETERR(0, "terminal not found\n");
X	case 1:
X	case 2:
X	case 3:
X		cur_term->fd = fd;
X		_term_buf.fd = fd;
X		if (_init_tty() == ERR)
X			RETERR(0, "problem initializing tty\n");
X		if ((s = getenv("LINES")) != NULL && atoi(s) > 0) 
X			lines = atoi(s);
X		if ((s = getenv("COLUMNS")) != NULL && atoi(s) > 0)
X			columns = atoi(s);
X		if (err != NULL)
X			*err = 1;
X		return OK;
X	default:
X		RETERR(0, "oops...\n");
X	}
X}
X
int
set_curterm(p)
TERMINAL *p; {
X	cur_term = p;
X	if (_init_tty() == ERR)
X		return ERR;
X	if (_check_tty() == ERR)
X		return ERR;
X	return OK;
X}
X
int
del_curterm(p)
TERMINAL *p; {
X	_del_strs(p);
X	free((anyptr) p);
X
X	return OK;
X}
END_OF_FILE
if test 2068 -ne `wc -c <'terminfo.c'`; then
    echo shar: \"'terminfo.c'\" unpacked with wrong size!
fi
# end of 'terminfo.c'
fi
if test -f 'terminfo.src' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'terminfo.src'\"
else
echo shar: Extracting \"'terminfo.src'\" \(4475 characters\)
sed "s/^X//" >'terminfo.src' <<'END_OF_FILE'
X# 
X# terminfo.src
X#
X# By Ross Ridge
X# Public Domain
X# 92/02/01 07:30:32
X#
X# Some sample terminfo definitions
X#
X# @(#) mytinfo terminfo.src 3.2 92/02/01 public domain, By Ross Ridge
X#
X#
dumb|dumb terminal, gn, co#80,
X#
X# Note not all ANSI terminals will support all of these capabilities.
X# This doesn't define any real terminal, and probably wouldn't work
X# with any real terminal either.
X#
ansi-all|ANS X3.64-1979 terminal,
X	cr=^M, cud1=^J, ind=^J, nel=^M^J, bell=^G, cub1=^H, 
X	cuu1=\EM, ff=^L, ht=^I,
X	.ind=\ED, .nel=\EE, hts=\EH, hd=\EK, hu=\EL, ri=\EM,
X	.ich1=\E[@, .ich=\E[%p1%d@, .cuu1=\E[A, cuu=\E[%p1%dA,
X	cud1=\E[B, .cud=\E[%p1%dB, cuf1=\E[C, cuf=\E[%p1%dC,
X	.cub1=\E[D, cub=\E[%p1%dD, .cnl=\E[%p1%dE, .cpl=\E[%p1%dF,
X	.hpa=\E[%i%p1%dG, cup=\E[%i%p1%d;%p2%dH, .cht=\E[%p1%dI,
X	ed=\E[J, el=\E[K, el1=\E[1K, il1=\E[L, il=\E[%p1%dL,
X	dl1=\E[M, dl=\E[%p1%dM, .ef=\E[N, .ea=\E[O,
X	dch1=\E[P, dch=\E[%p1%dP, .sem=\E[%p1%dQ,
X	.cpr=\E[%i%p1%d;%p2%dR, indn=\E[%p1%dS, .ind=\E[S,
X	rin=\E[%p1%dT, .ri=\E[T, .np=\E[%p1%dU, .pp=\E[%p1%dU,
X	.ctc=\E[%p1%dW, ech=\E[%p1%dX, .cvt=\E[%p1%dY,
X	cbt=\E[Z, hpa=\E[%i%p1%d`, .hpr=\E[%p1%da,
X	rep=%p1%c%?%p2%{1}%>%t\E[%p2%{1}%-%db%;,
X	.da=\E[c, vpa=\E[%i%p1%dd, .vpr=\E[%p1%e,
X	.hvp=\E[%i%p1%d;%p2%df, tbc=\E[3g,
X	mc=\E[0i, mc4=\E[4i, mc5=\E[5i,
X	sgr=\E[%?%p6%t;1%;%?%p5%p1%|%t;2%;%?%p2%t;4%;%?%p4%t;6%;%?%p3%p1%|%t;7%;%?%p7%t;8%;m,
X	smso=\E[1;7m, rmso=\E[m, smul=\E[4m, rmul=\E[m,
X	blink=\E[6m, bold=\E[1m, invis=\E[8m, rev=\E[7m,
X	sgr0=\E[m, .dsr=\E[%p1%dn, .daq=\E[%p1%do,
X	.sl=\E[%p1%d\s@, .sr=\E[%p1%d\sA, clear=\E[H\EJ, home=\E[H,
X	smir=\E[4h, rmir=\E[4l,
X	is2=\E[1Q\E[1;2;3;4;5;7;10;11;13;14;16;15;17;18;19;20l\E[6;12h\E[m,
X	rs2=\Ec\E[1Q\E[1;2;3;4;5;7;10;11;13;14;16;15;17;18;19;20l\E[6;12h\E[m\E[H\EJ,
ansi-all-8|ANS X3.64-1979 terminal (8 bit),
X	cr=^M, cud1=^J, ind=^J, nel=^M^J, bell=^G, cub1=^H, 
X	cuu1=\215, ff=^L, ht=^I,
X	.ind=\204, .nel=\205, hts=\207, hd=\213, hu=\214, ri=\215,
X	.ich1=\233@, .ich=\E%p1%d@, .cuu1=\233A, cuu=\233%p1%dA,
X	cud1=\233B, .cud=\233%p1%dB, cuf1=\233C, cuf=\233%p1%dC,
X	.cub1=\233D, cub=\233%p1%dD, .cnl=\233%p1%dE, .cpl=\233%p1%dF,
X	.hpa=\233%i%p1%dG, cup=\233%i%p1%d;%p2%dH, .cht=\233%p1%dI,
X	ed=\233J, el=\233K, el1=\2331K, il1=\233L, il=\233%p1%dL,
X	dl1=\233M, dl=\233%p1%dM, .ef=\233N, .ea=\233O,
X	dch1=\233P, dch=\233%p1%dP, .sem=\233%p1%dQ,
X	.cpr=\233%i%p1%d;%p2%dR, indn=\233%p1%dS, .ind=\233S,
X	rin=\233%p1%dT, .ri=\233T, .np=\233%p1%dU, .pp=\233%p1%dU,
X	.ctc=\233%p1%dW, ech=\233%p1%dX, .cvt=\233%p1%dY,
X	cbt=\233Z, hpa=\233%i%p1%d`, .hpr=\233%p1%da,
X	rep=%p1%c%?%p2%{1}%>%t\233%p2%{1}%-%db%;,
X	.da=\233c, vpa=\233%i%p1%dd, .vpr=\233%p1%e,
X	.hvp=\233%i%p1%d;%p2%df, tbc=\2333g,
X	mc=\2330i, mc4=\2334i, mc5=\2334i,
X	sgr=\233%?%p6%t;1%;%?%p5%p1%|%t;2%;%?%p2%t;4%;%?%p4%t;6%;%?%p3%p1%|%t;7%;%?%p7%t;8%;m,
X	smso=\2331;7m, rmso=\233m, smul=\2334m, rmul=\233m,
X	blink=\2336m, bold=\2331m, invis=\2338m, rev=\2337m,
X	sgr0=\233m, .dsr=\233%p1%dn, .daq=\233%p1%do,
X	.sl=\233%p1%d\s@, .sr=\233%p1%d\sA, clear=\233H\EJ, home=\233H,
X	smir=\2334h, rmir=\2334l,
X	is2=\2331Q\2331;2;3;4;5;7;10;11;13;14;16;15;17;18;19;20l\2336;12h\233m,
X	rs2=\Ec\2331Q\2331;2;3;4;5;7;10;11;13;14;16;15;17;18;19;20l\2336;12h\233m\233H\EJ,
X#
X# Not tested...
X#
vt100|dec vt100,
X	xon, UWxc, msgr, 
X	cols#80, lines#24, it#8, vt#3,
X	cr=\r, csr=^[[%i%p1%d;%p2%dr, tbc=^[[3g, clear=^[[;H^[[2J$<100>,
X	el=^[[K$<3>, ed=^[[J$<50>, cup=^[[%i%p1%d;%p2%dH$<5>, cud1=^[[B,
X	home=^[[H, cub1=^[[D, cuf1=^[[C$<2>, cuu1=^[[A$<2>, blink=^[[5m$<2>,
X	bold=^[[1m$<2>, rev=^[[7m$<2>, smso=^[[7m$<2>, smul=^[[4m$<2>,
X	sgr0=^[[m^N$<2>, rmso=^[[m$<2>, rmul=^[[m$<2>, hts=^[H, ht=^I,
X	is2=^[[1;24r^[[?1l^[[?3l^[[30h^[[?7h^[>, bell=^G,
X	kbs=\b, kcud1=^[[B, kf0=^[OP, kf1=^[OQ, kf2=^[OR, kf3=^[OS,
X	kcub1=^[[D, kcuf1=^[[C, kcuu1=^[[A, lf0=PF1, lf1=PF2,
X	lf2=PF3, lf3=PF4, nel=\r^[D, cud=^[[%p1%dB, cub=^[[%p1%dD,
X	cuf=^[[%p1%dC, cuu=^[[%p1%dA, rc=^[8, sc=^[7, ind=^[D, ri=^[M$<5>,
X	sgr=^[[0;%?%p4%t;5%;%?%p6%t;1%;%?%p3%p1%|%t;7%;%?%p2%t;4%;m%?%p1%t^N%e^O%;$<2>,
X	smacs=^O, rmacs=^N,
vt100-am|vt100 with automatic margins,
X	am, xenl, @el, @ed,
X	use=vt100,
vt102|dec vt102,
X	is=\E<\E[1;24r\E[?1l\E[?3l\E[?5l\E[?7h\E>,
X	il=\E[%p1%dL, dch=\E[%p1%dP, dl=\E[%p1%dM,
X	il1=\E[L, dch1=\E[P, dl1=\E[M,
X	mir, rmir=\E[4l, smir=\E[4h,
X	use=vt100,
vt200|vt220|vt200-js|vt220-js|dec vt200 series with jump scroll,
X	clear=\E[H\E[J, rmso=\E[27m, rmul=\E[24m,
X	is2=\E>\E[?3l\E[?4l\E[?5l\E[?7h\E[?8h\E[1;24r\E[24;1H,
X	rs2=\E>\E[?3l\E[?4l\E[?5l\E[?7h\E[?8h,
X	use=vt102, 
END_OF_FILE
if test 4475 -ne `wc -c <'terminfo.src'`; then
    echo shar: \"'terminfo.src'\" unpacked with wrong size!
fi
# end of 'terminfo.src'
fi
if test -f 'tgoto.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tgoto.c'\"
else
echo shar: Extracting \"'tgoto.c'\" \(2489 characters\)
sed "s/^X//" >'tgoto.c' <<'END_OF_FILE'
X/*
X * tgoto.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:30:33
X *
X * A few kludged attempts to worry outputing ^D's and NL's...
X * My advice is to get a decent terminal.
X *
X */
X
X#include "defs.h"
X#include "term.h"
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo tgoto.c 3.2 92/02/01 public domain, By Ross Ridge";
X#endif
X
X#ifdef USE_LITOUT_KLUDGE
X
X/*
X * This kludge works by telling tputs to switch the tty driver to
X * "literal output" when printing the string so we don't have worry
X * about newlines and EOTs. The problem is that ioctls used to
X * switch modes might flush buffers and cause other problems.
X */
X
X
char *
tgoto(str, x, y)
char *str;
int x,y; {
X	register char *sp;
X	
X	static char buf[MAX_LINE] = {'\\', '@'};
X
X	sp = str = tparm(str, y, x);
X
X	while (*sp != '\0') {
X		if (*sp == '\004' || *sp == '\n') {
X			strncpy(buf + 2, str, MAX_LINE - 2);
X			buf[MAX_LINE - 2] = '\0';
X			return buf;
X		}
X		sp++;
X	}
X	return sp;
X}
X#else
X
X#ifdef USE_UPBC_KLUDGE
X
X#ifdef USE_EXTERN_UPBC
extern char *BC, *UP;
X#else
X#define BC	cursor_left
X#define UP	cursor_right
X#endif
X
X#ifdef __GNUC__
X__inline__
X#endif
static int
checkit(s)
register char *s; {
X	while(*s != '\0') {
X		if (*s == '\004' || *s == '\n')
X			return 1;
X		s++;
X	}
X	return 0;
X}
X
X/*
X * Major kludge, basically we just change the parmeters until we get
X * a string that doesn't contain a newline or EOT.
X */
X
char *
tgoto(str, x, y)
char *str;
int x,y; {
X	static char buf[MAX_LINE];
X	register char *orig, *s;
X	int l;
X
X	orig = tparm(str, y, x);
X
X	if (!checkit(orig))
X		return orig;
X
X	s = tparm(str, y + 1, x);
X
X	if (!checkit(s)) {
X		if (BC == NULL)
X			return s;
X		l = strlen(s);
X		strncpy(buf, s, MAX_LINE - 1);
X		if (l < MAX_LINE - 1)
X			strncpy(buf + l, BC, MAX_LINE - 1 - l);
X		return s;
X	}
X
X	s = tparm(str, y, x + 1);
X
X	if (!checkit(s)) {
X		if (UP == NULL)
X			return s;
X		l = strlen(s);
X		strncpy(buf, s, MAX_LINE - 1);
X		if (l < MAX_LINE - 1)
X			strncpy(buf + l, UP, MAX_LINE - 1 - l);
X		return s;
X	}
X
X	s = tparm(str, y + 1, x + 1);
X
X	if (!checkit(s)) {
X		if (UP == NULL || BC == NULL)
X			return s;
X		l = strlen(s);
X		strncpy(buf, s, MAX_LINE - 1);
X		if (l < MAX_LINE - 1)
X			strncpy(buf + l, UP, MAX_LINE - 1 - l);
X		l += strlen(UP);
X		if (l < MAX_LINE - 1)
X			strncpy(buf + l, BC, MAX_LINE - 1 - l);
X		return s;
X	}
X
X	return orig;
X}
X
X#else
X
X/* the simple tgoto, don't worry about any of this newline/EOT crap */
X
char *
tgoto(str, x, y)
char *str;
int x,y; {
X	return tparm(str, y, x);
X}
X
X#endif
X
X#endif
END_OF_FILE
if test 2489 -ne `wc -c <'tgoto.c'`; then
    echo shar: \"'tgoto.c'\" unpacked with wrong size!
fi
# end of 'tgoto.c'
fi
if test -f 'tiget.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tiget.c'\"
else
echo shar: Extracting \"'tiget.c'\" \(684 characters\)
sed "s/^X//" >'tiget.c' <<'END_OF_FILE'
X/*
X * tiget.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:30:34
X *
X * The various tiget terminfo functions.
X */
X
X#include "defs.h"
X#include "term.h"
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo tiget.c 3.2 92/02/01 public domain, By Ross Ridge";
X#endif
X
int
tigetnum(cap)
char *cap; {
X	int ind;
X
X	ind = _findnumname(cap);
X	if (ind == -1)
X		return -2;
X	return cur_term->nums[ind];
X}
X
int
tigetflag(cap)
char *cap; {
X	int ind;
X
X	ind = _findboolname(cap);
X	if (ind == -1)
X		return -1;
X	return cur_term->bools[ind];
X}
X
char *
tigetstr(cap)
char *cap; {
X	int ind;
X
X	ind = _findstrname(cap);
X	if (ind == -1)
X		return (char *) -1;
X	return cur_term->strs[ind];
X}
X
X
END_OF_FILE
if test 684 -ne `wc -c <'tiget.c'`; then
    echo shar: \"'tiget.c'\" unpacked with wrong size!
fi
# end of 'tiget.c'
fi
if test -f 'tmatch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tmatch.c'\"
else
echo shar: Extracting \"'tmatch.c'\" \(604 characters\)
sed "s/^X//" >'tmatch.c' <<'END_OF_FILE'
X/*
X * tmatch.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:30:35
X *
X * See if a terminal name matches a list of terminal names from a
X * terminal description
X *
X */
X
X#include "defs.h"
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo tmatch.c 3.2 92/02/01 public domain, By Ross Ridge";
X#endif
X
int
X_tmatch(line, name)
char *line, *name; {
X	char term[MAX_LINE];
X	char *sp, *dp;
X
X	sp = line;
X	while (*sp != '\0') {
X		dp = term;
X		while (*sp != '\0' && *sp != '|')
X			*dp++ = *sp++;
X		*dp = '\0';
X		if (strcmp(term, name) == 0)
X			return 1;
X		if (*sp == '|')
X			sp++;
X	}
X	return 0;
X}
END_OF_FILE
if test 604 -ne `wc -c <'tmatch.c'`; then
    echo shar: \"'tmatch.c'\" unpacked with wrong size!
fi
# end of 'tmatch.c'
fi
if test -f 'tput.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tput.c'\"
else
echo shar: Extracting \"'tput.c'\" \(3436 characters\)
sed "s/^X//" >'tput.c' <<'END_OF_FILE'
X/*
X * tput.c
X * 
X * By Ross Ridge
X * Public Domain
X * 92/02/01 07:30:39
X *
X */
X
X#define NOTLIB
X
X#include "defs.h"
X
static const char SCCSid[] = "@(#) mytinfo tput.c 3.2 92/02/01 public domain, By Ross Ridge";
X
X#define SINGLE
X#include "term.h"
X
X#include <ctype.h>
X
X#define PUTS(s)		putp(s)
X#define PUTCHAR(c)	putchar(c)
X#define FLUSH		fflush(stdout)
X
extern void (*cleanup)();
X
static void
clean(e)
int e; {
X	return;
X}
X
static void
usage(e)
int e; {
X	fprintf(stderr, "usage: %s [-T term] capname\n", prg_name);
X	return;
X}
X
int
main(argc, argv)
int argc;
char **argv; {
X	char *s;
X	int i, j, c;
X	int reset;
X	FILE *f;
X	char *term;
X
X	prg_name = argv[0];
X	s = strrchr(prg_name, '/');
X	if (s != NULL && *++s != '\0') {
X		prg_name = s;
X	}
X
X	term = getenv("TERM");
X
X	cleanup = usage;
X
X	if (argc > 2 && argv[1][0] == '-' && argv[1][1] == 'T') {
X		if (argv[1][2] == '\0' && argc > 3) {
X			term = argv[2];
X			argc--;
X			argv++;
X		} else {
X			term = argv[1] + 2;
X		}
X		argc--;
X		argv++;
X	}
X
X	if (argc != 2) {
X		quit(-1, "arg count");
X	}
X
X	cleanup = clean;
X
X	setupterm(term, 1, (int *)0);
X
X	reset = 0;
X	if (strcmp(argv[1], "reset") == 0) {
X		reset = 1;
X	}
X	if (reset || strcmp(argv[1], "init") == 0) {
X
X		if (init_prog != NULL) {
X			system(init_prog);
X		}
X		FLUSH;
X
X		if (reset && reset_1string != NULL) {
X			PUTS(reset_1string);
X		} else if (init_1string != NULL) {
X			PUTS(init_1string);
X		}
X		FLUSH;
X
X		if (reset && reset_2string != NULL) {
X			PUTS(reset_2string);
X		} else if (init_2string != NULL) {
X			PUTS(init_2string);
X		}
X		FLUSH;
X
X		if (set_lr_margin != NULL) {
X			PUTS(tparm(set_lr_margin, 0, columns - 1));
X		} else if (set_left_margin_parm != NULL
X			   && set_right_margin_parm != NULL) {
X			PUTS(tparm(set_left_margin_parm, 0));
X			PUTS(tparm(set_right_margin_parm, columns - 1));
X		} else if (clear_margins != NULL && set_left_margin != NULL
X			   && set_right_margin != NULL) {
X			PUTS(clear_margins);
X			if (carriage_return != NULL) {
X				PUTS(carriage_return);
X			} else {
X				PUTCHAR('\r');
X			}
X			PUTS(set_left_margin);
X			if (parm_right_cursor) {
X				PUTS(tparm(parm_right_cursor, columns - 1));
X			} else {
X				for(i = 0; i < columns - 1; i++) {
X					PUTCHAR(' ');
X				}
X			}
X			PUTS(set_right_margin);
X			if (carriage_return != NULL) {
X				PUTS(carriage_return);
X			} else {
X				PUTCHAR('\r');
X			}
X		}
X		FLUSH;
X
X		if (init_tabs != 8) {
X			if (clear_all_tabs != NULL && set_tab != NULL) {
X				for(i = 0; i < columns - 1; i += 8) {
X					if (parm_right_cursor) {
X						PUTS(tparm(parm_right_cursor,
X						     8));
X					} else {
X						for(j = 0; j < 8; j++) {
X							PUTCHAR(' ');
X						}
X					}
X					PUTS(set_tab);
X				}
X				FLUSH;
X			}
X		}
X
X		if (reset && reset_file != NULL) {
X			f = fopen(reset_file, "r");
X			if (f == NULL) {
X				quit(errno, "Can't open reset_file: '%s'",
X				     reset_file);
X			}
X			while((c = fgetc(f)) != EOF) {
X				PUTCHAR(c);
X			}
X			fclose(f);
X		} else if (init_file != NULL) {
X			f = fopen(init_file, "r");
X			if (f == NULL) {
X				quit(errno, "Can't open init_file: '%s'",
X				     init_file);
X			}
X			while((c = fgetc(f)) != EOF) {
X				PUTCHAR(c);
X			}
X			fclose(f);
X		}
X		FLUSH;
X
X		if (reset && reset_3string != NULL) {
X			PUTS(reset_3string);
X		} else if (init_2string != NULL) {
X			PUTS(init_3string);
X		}
X		FLUSH;
X		return 0;
X	}
X
X	s = tigetstr(argv[1]);
X
X	if (s == (char *) -1) {
X		quit(-1, "unknown capname '%s'", argv[1]);
X	} else if (s == NULL) {
X		return 0;
X	}
X
X	putp(s);
X
X	return 0;
X}
END_OF_FILE
if test 3436 -ne `wc -c <'tput.c'`; then
    echo shar: \"'tput.c'\" unpacked with wrong size!
fi
# end of 'tput.c'
fi
if test -f 'tputs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tputs.c'\"
else
echo shar: Extracting \"'tputs.c'\" \(4288 characters\)
sed "s/^X//" >'tputs.c' <<'END_OF_FILE'
X/*
X * tputs.c
X *
X * By Ross Ridge
X * Public Domain
X * 92/06/04 11:41:15
X *
X * Output a terminal capability string with any needed padding
X *
X */
X
X#include "defs.h"
X#include "term.h"
X
X#include <ctype.h>
X
X#ifdef USE_SCCS_IDS
static const char SCCSid[] = "@(#) mytinfo tputs.c 3.3 92/06/04 public domain, By Ross Ridge";
X#endif
X
X#ifdef TEST
X#define def_prog_mode()	(OK)
X#define _norm_output()	((void)(0))
X#define _lit_output()	(1)
X#endif
X
X/*
X * BITSPERCHAR (as actually transmitted over a serial line) is usually 10
X * (not 8). 1 stop bit, 1 start bit, 7 data bits, and one parity bit.
X */
X
X#define BITSPERCHAR	10
X
X#ifdef USE_FAKE_STDIO
X#undef putchar
X#endif
X
X#define PUTCHAR(c) (outc == (int (*)()) 0 ? (putchar(c)):(*outc)(c))
X
int
tputs(sp, count, outc)
register char *sp;
int count;
register int (*outc)();
X{
X	register int l;
X	register long cnt;
X	int must_pad, multiply_pad;
X	int forced_lit = 0;
X
X	/* some programmes expect this behaviour from tputs */
X	if (sp == NULL) {
X#ifdef DEBUG
X		fprintf(stderr, "tputs: NULL\n");	
X#endif
X		return 0;
X	}
X
X	if (cur_term->termcap) {
X		_figure_termcap();
X	}
X
X	while(*sp != '\0') {
X		switch(*sp) {
X		case '\\':
X			switch(*++sp) {
X			case 'n': PUTCHAR('\n'); sp++; break;
X			case 'b': PUTCHAR('\b'); sp++; break;
X			case 't': PUTCHAR('\t'); sp++; break;
X			case 'r': PUTCHAR('\r'); sp++; break;
X			case 'f': PUTCHAR('\f'); sp++; break;
X			case 'l': PUTCHAR('\012'); sp++; break;
X			case 's': PUTCHAR(' '); sp++; break;
X			case 'e': case 'E': PUTCHAR('\033'); sp++; break;
X
X			case '^':
X			case '\\':
X			case ',':
X			case ':':
X			case '\'':
X			case '$':
X				PUTCHAR(*sp++);
X				break;
X
X			case '0':
X				if (*(sp + 1) < '0' || *(sp + 1) > '7') {
X					PUTCHAR('\200'); /* I'd prefer \0 */
X					sp++;
X					break;
X				}
X				;/* FALLTHROUGH */
X			case '1': case '2': case '3': case '4':
X			case '5': case '6': case '7':
X				l = *sp++ - '0';
X				if (*sp >= '0' && *sp <= '7') {
X					l = l * 8 + (*sp++ - '0');
X					if (*sp >= '0' && *sp <= '7')
X						l = l * 8 + (*sp++ - '0');
X				}
X				PUTCHAR(l);
X				break;
X
X			case '\0':
X				PUTCHAR('\\');
X				break;
X
X			case '@':
X				if (!forced_lit)
X					forced_lit = _lit_output();
X				sp++;
X				break;
X
X			default:
X				PUTCHAR('\\');
X				PUTCHAR(*sp++);
X				break;
X			}
X			break;
X		case '^':
X			if (*++sp == '\0')
X				break;
X			l = *sp - '@';
X			if (l > 31)
X				l -= 32;
X			if (l < 0 || l > 31) {
X				PUTCHAR('^');
X				PUTCHAR(*sp++);
X			} else {
X				PUTCHAR(l);
X				sp++;
X			}
X			break;
X		case '$':
X			if (*++sp != '<') {
X				PUTCHAR('$');
X				break;
X			}
X			must_pad = 0;
X			multiply_pad = 0;
X			l = 0;
X			sp++;
X			while (isdigit(*sp))
X				l = l * 10 + (*sp++ - '0');
X			l *= 10;
X			if (*sp == '.') {
X				sp++;
X				if (isdigit(*sp))
X					l += *sp++ - '0';
X			}
X			if (*sp == '/') {
X				must_pad = 1;
X				if (*++sp == '*') {
X					multiply_pad = 1;
X					sp++;
X				}
X			} else if (*sp == '*') {
X				multiply_pad = 1;
X				if (*++sp == '/') {
X					must_pad = 1;
X					sp++;
X				}
X			}
X			if (*sp != '>') {
X				PUTCHAR('p');
X				PUTCHAR('a');
X				PUTCHAR('d');
X				PUTCHAR('?');
X				break;
X			}
X			sp++;
X#ifdef TEST
X			printf("\nl = %d", l);
X#endif
X			if (cur_term->pad || must_pad) {
X				cnt = ((long) l * cur_term->baudrate
X				       * (multiply_pad ? count : 1) 
X				       + (10000L * BITSPERCHAR / 2L))
X				      / (10000L * BITSPERCHAR);
X#ifdef TEST
X				printf("; cnt = %d\n", cnt);
X#endif
X				while(cnt--)
X					PUTCHAR(cur_term->padch);
X			}
X#ifdef TEST
X			printf("\n");
X#endif
X			break;
X		default:
X			PUTCHAR(*sp++);
X		}
X	}
X	if (forced_lit)
X		_norm_output();
X	return OK;
X}
X
int
putp(str)
char *str; {
X	return(tputs(str, 1,(int (*)()) 0));
X}
X
X#ifdef TEST
X
TERMINAL test_term, *cur_term = &test_term;
X
void
putch(c)
int c; {
X	c &= 0xff;
X	if (c > 127 || c < 0) {
X		printf("\\%03o", c);
X	} else if (c < 32) {
X		printf("^%c", c + '@');
X	} else if (c == 127) {
X		printf("^?");
X	} else {
X		putchar(c);
X	}
X}
X
char line[MAX_LINE];
X
int
main(argc, argv)
int argc;
char **argv; {
X	test_term.termcap = 0;
X	test_term.baudrate = 1200;
X	test_term.pad = 0;
X	test_term.padch = 0;
X	if (argc > 1) 
X		test_term.baudrate = atoi(argv[1]);
X	if (argc > 2)
X		test_term.padch = argv[2][0];
X	if (argc > 3)
X		test_term.pad = 1;
X
X	putchar('\n');
X
X	while(gets(line) != NULL) {
X		tputs(line, 7, putch);
X		putchar('\n');
X	}
X	return 0;
X}
X#endif
END_OF_FILE
if test 4288 -ne `wc -c <'tputs.c'`; then
    echo shar: \"'tputs.c'\" unpacked with wrong size!
fi
# end of 'tputs.c'
fi
if test -f 'version.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'version.h'\"
else
echo shar: Extracting \"'version.h'\" \(101 characters\)
sed "s/^X//" >'version.h' <<'END_OF_FILE'
X/*
X * version.h
X *
X * By Ross Ridge
X * Public Domain
X *
X */
X
X#define RELEASE		3
X#define PATCHLEVEL	0
END_OF_FILE
if test 101 -ne `wc -c <'version.h'`; then
    echo shar: \"'version.h'\" unpacked with wrong size!
fi
# end of 'version.h'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
