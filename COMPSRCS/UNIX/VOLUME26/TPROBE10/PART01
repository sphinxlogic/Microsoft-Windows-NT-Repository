Newsgroups: comp.sources.unix
From: thad@btr.com (Thad Floryan)
Subject: v26i084: tprobe-1.0 - tape saveset analyzer and duplicator, Part01/01
Sender: unix-sources-moderator@pa.dec.com
Approved: vixie@pa.dec.com

Submitted-By: thad@btr.com (Thad Floryan)
Posting-Number: Volume 26, Issue 84
Archive-Name: tprobe-1.0/part01

			     T P R O B E

		 Tape Saveset Analyzer and Duplicator

     @(#)README V1.0, 12-Feb-1992, Thad Floryan [ thad@btr.com ]


tprobe is a utility which succeeds duplicating boot/install tapes that are not
easily copied by other means.  One of its features is operation over a pipeline
utilizing multiple tape drives whereever they exist on a network or a system.

tprobe can also (indirectly) perform media conversions, though the only
verified conversions have been from QIC-120 and QIC-150 to QIC-24 and vice
versa; there is no inherent limitation, so other conversions are definitely
possible.

Another feature is that a tape may be processed without disk space being
usurped for intermediate staging.  Thus, a full 150MB tape can be duplicated
even if one's system has only, say, 20MB free.

tprobe's basic operation reveals a tape's existing saveset layout and stored
capacity, and requires only a single tape drive for this analysis.

tprobe was intended to be a one-time-only program, but it is useful in its
present incarnation and does solve immediate and present problems.

tprobe was conceived when it was realized the SunOS 4.1.1 Sun-3 SUNBIN install
tape was to be the last ever from Sun for that architecture and that a backup
was essential to prevent disaster if the tape should be "bad" when most needed
to boot into a miniroot.

Complete nroff-/troff-ready documentation accompanies this distribution.
Additional notes and anecdotes not appropriate for the "man" page follow.

tprobe began as a Kwik'N'Dirty program to ascertain the saveset layout of
tapes to discover why "obvious" means of tape duplication were not successful;
varying record sizes were found to be the problem whose solution (for my
purposes) is the present release.

An obvious but often neglected fact is that tape drives need to be kept clean.
Many tape subsystem enclosures are poorly-designed, with fans sucking in dust
and atmospheric contaminants over the heads and operating parts.  It's my
opinion that tape drive housings should be constructed with fan(s) blowing
filtered air IN to maintain a positive pressure inside the enclosure as a
barrier to pollution (per the guidelines of clean rooms used in semiconductor
manufacture).  Systems with externally-replaceable filters are the best.

For optimum performance and reliability, tapes should also be retensioned
prior to use.  Retensioning (one high speed rewind cycle from end to end)
assures a even tape pack and facilitates accurate tape handling by the tape
drive transport.

Always, ALWAYS write-protect a tape after removing it from a drive.  All QIC
and 1/2" cartridges have a tab that can be turned or flipped to a "SAFE"
position; DO IT!  The number of laments posted to Usenet after someone
overwrites a crucial backup is increasing; be SAFE, not SORRY.

Remember: the most dangerous command on UNIX, or any system for that matter,
is the RETURN.  Very few commands are retractable.  Be careful!

Accompanying this README are extracts from some of my recent Usenet postings
concerning tapes, their formats, their setup and their handling per:

README.qic	concerning QIC compatibility
README.2150	concerning Archive 2060S/2150S jumper settings
README.5945	concerning Archive 5945C, SCSI, and Emulex MT02 setup
README.exb	concerning Exabyte EXB-8200 capacities and setup
README.tzk10	concerning DEC's TZK10 and Archive's ST525 drives

Thad Floryan [ thad@btr.com (OR) {decwrl, mips, fernwood}!btr!thad ]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 1)."
# Contents:  MANIFEST Makefile Makefile.3b1 README README.2150
#   README.5945 README.exb README.qic README.tzk10 tprobe.c tprobe.man
# Wrapped by vixie@cognition.pa.dec.com on Wed Dec 30 11:36:20 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(437 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	
X Makefile                   1	
X Makefile.3b1               1	
X README                     1	
X README.2150                1	
X README.5945                1	
X README.exb                 1	
X README.qic                 1	
X README.tzk10               1	
X tprobe.c                   1	
X tprobe.man                 1	
END_OF_FILE
if test 437 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(1211 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Generic Makefile for tprobe
X#
X# make		will create the tprobe executable in the current directory
X# make catman	will create catman-style documentation in the current directory
X# make install	will mv(1) the executable to the specified $(DEST) directory
X# make clean	will tidy-up the current directory after a link or install
X# make lint	will check the source for programming irregularities
X# make lintp	will check the source for portability considerations
X#
X# Several options can be uncommented for configuration on your system.
X
CC	=	cc
X
X# Uncomment or change as appropriate for your system:
X#
COPT	=	-O
X#CDBG	=	-g
X#CPROF	=	-p -g
X#
CFLAGS	=	$(COPT) $(CDBG) $(CPROF)
X
LDFLAGS =	-s
X
X# Uncomment or change as appropriate for your system:
X#
X#LSVR3	=	-lc_s
X#
LIBS	=	$(LSVR3)
X
NAME	=	tprobe
OBJS	=	tprobe.o
SRCS	=	tprobe.c
MANF	=	tprobe.man
MANEXT	=	1
X
DEST	=	/usr/local/bin
XFMODE	=	555
X
X$(NAME)	:	$(OBJS)
X		$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(OBJS) $(LIBS)
X
install :	$(NAME)
X		mv    $(NAME)  $(DEST)/
X		chmod $(FMODE) $(DEST)/$(NAME)
X
catman	:	$(NAME).$(MANEXT)
X
X$(NAME).$(MANEXT) : $(MANF)
X		nroff -man $(MANF) > $(NAME).$(MANEXT)
X
clean	:
X		rm -f core *~ $(OBJS)
X
lint	:
X		lint $(SRCS)
X
lintp	:
X		lint -p $(SRCS)
END_OF_FILE
if test 1211 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'Makefile.3b1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.3b1'\"
else
echo shar: Extracting \"'Makefile.3b1'\" \(1140 characters\)
sed "s/^X//" >'Makefile.3b1' <<'END_OF_FILE'
X# 3B1 Makefile for tprobe
X#
X# make		will create the tprobe executable in the current directory
X# make cat	will create catman-style documentation in the current directory
X# make install	will mv(1) the executable to the specified $(DEST) directory
X# make clean	will tidy-up the current directory after a link or install
X# make lint	will check the source for programming irregularities
X# make lintp	will check the source for portability considerations
X#
X# Several options can be uncommented for configuration on your system.
X
CC	=	gcc
X
X# Uncomment or change as appropriate for your system:
X#
COPT	=	-O
X#CDBG	=	-g
X#CPROF	=	-p -g
X#
CFLAGS	=	$(COPT) $(CDBG) $(CPROF)
X
LDFLAGS =	-s
X
LIBS	=	/lib/crt0s.o /lib/shlib.ifile
X
NAME	=	tprobe
OBJS	=	tprobe.o
SRCS	=	tprobe.c
MANF	=	tprobe.man
MANEXT	=	1
X
DEST	=	/usr/local/bin
XFMODE	=	555
X
X$(NAME)	:	$(OBJS)
X		$(LD) $(LDFLAGS) -o $@ $(OBJS) $(LIBS)
X
install :	$(NAME)
X		mv    $(NAME)  $(DEST)/
X		chmod $(FMODE) $(DEST)/$(NAME)
X
cat	:	$(NAME).$(MANEXT)
X
X$(NAME).$(MANEXT) : $(MANF)
X		nroff -man $(MANF) > $(NAME).$(MANEXT)
X
clean	:
X		rm -f core *~ $(OBJS)
X
lint	:
X		lint $(SRCS)
X
lintp	:
X		lint -p $(SRCS)
END_OF_FILE
if test 1140 -ne `wc -c <'Makefile.3b1'`; then
    echo shar: \"'Makefile.3b1'\" unpacked with wrong size!
fi
# end of 'Makefile.3b1'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(3465 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X			     T P R O B E
X
X		 Tape Saveset Analyzer and Duplicator
X
X     @(#)README V1.0, 12-Feb-1992, Thad Floryan [ thad@btr.com ]
X
X
tprobe is a utility which succeeds duplicating boot/install tapes that are not
easily copied by other means.  One of its features is operation over a pipeline
utilizing multiple tape drives whereever they exist on a network or a system.
X
tprobe can also (indirectly) perform media conversions, though the only
verified conversions have been from QIC-120 and QIC-150 to QIC-24 and vice
versa; there is no inherent limitation, so other conversions are definitely
possible.
X
Another feature is that a tape may be processed without disk space being
usurped for intermediate staging.  Thus, a full 150MB tape can be duplicated
even if one's system has only, say, 20MB free.
X
tprobe's basic operation reveals a tape's existing saveset layout and stored
capacity, and requires only a single tape drive for this analysis.
X
tprobe was intended to be a one-time-only program, but it is useful in its
present incarnation and does solve immediate and present problems.
X
tprobe was conceived when it was realized the SunOS 4.1.1 Sun-3 SUNBIN install
tape was to be the last ever from Sun for that architecture and that a backup
was essential to prevent disaster if the tape should be "bad" when most needed
to boot into a miniroot.
X
Complete nroff-/troff-ready documentation accompanies this distribution.
Additional notes and anecdotes not appropriate for the "man" page follow.
X
tprobe began as a Kwik'N'Dirty program to ascertain the saveset layout of
tapes to discover why "obvious" means of tape duplication were not successful;
varying record sizes were found to be the problem whose solution (for my
purposes) is the present release.
X
An obvious but often neglected fact is that tape drives need to be kept clean.
Many tape subsystem enclosures are poorly-designed, with fans sucking in dust
and atmospheric contaminants over the heads and operating parts.  It's my
opinion that tape drive housings should be constructed with fan(s) blowing
filtered air IN to maintain a positive pressure inside the enclosure as a
barrier to pollution (per the guidelines of clean rooms used in semiconductor
manufacture).  Systems with externally-replaceable filters are the best.
X
XFor optimum performance and reliability, tapes should also be retensioned
prior to use.  Retensioning (one high speed rewind cycle from end to end)
assures a even tape pack and facilitates accurate tape handling by the tape
drive transport.
X
Always, ALWAYS write-protect a tape after removing it from a drive.  All QIC
and 1/2" cartridges have a tab that can be turned or flipped to a "SAFE"
position; DO IT!  The number of laments posted to Usenet after someone
overwrites a crucial backup is increasing; be SAFE, not SORRY.
X
Remember: the most dangerous command on UNIX, or any system for that matter,
is the RETURN.  Very few commands are retractable.  Be careful!
X
Accompanying this README are extracts from some of my recent Usenet postings
concerning tapes, their formats, their setup and their handling per:
X
README.qic	concerning QIC compatibility
README.2150	concerning Archive 2060S/2150S jumper settings
README.5945	concerning Archive 5945C, SCSI, and Emulex MT02 setup
README.exb	concerning Exabyte EXB-8200 capacities and setup
README.tzk10	concerning DEC's TZK10 and Archive's ST525 drives
X
X
Thad Floryan [ thad@btr.com (OR) {decwrl, mips, fernwood}!btr!thad ]
END_OF_FILE
if test 3465 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'README.2150' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README.2150'\"
else
echo shar: Extracting \"'README.2150'\" \(1675 characters\)
sed "s/^X//" >'README.2150' <<'END_OF_FILE'
X		 Viper 2060S and 2150S hardware setup
X
X
Hardware setup amongst the 9 sets of jumpers includes:
X
X	SCSI ID:	3 sets of jumpers
X	Serial:		this should NOT be set
X	Diagnostic:	this should NOT be set
X	Parity Enable:	setting depends on your interface; either EVERYTHING
X			or NOTHING on the bus should be checking parity.
X	Buffer Disc:	3 sets of jumpers select 2, 4, 6, 8, 12, 16, 24 and
X			32K buffer sizes.  Factory default is 16K.  This is
X			the number of bytes transferred over the bus in a
X			single operation.  A mininum of 16K is required for
X			the SCSI "COPY" command.
X
X
Where to find all this at the back of the drive:
X
X	[OOOO]	TTTTTTTT TTTTTTTT TTTTTTTT
X	 [JJ]	SSSSSSSSSSSSSSSSSSSSSSSSSS
X
X	Where:	[OOOO]	is the power connector
X		 [JJ]	is the jumper block
X		TTTTTT	are the three 8-pin terminators
X		SSSSSS	is the 25x2 SCSI connector
X
X	The jumper block looks like this (in the orientation as above):
X
X	[ SERIAL ]	[  CF2	]	[  ID2	]
X	[  DIAG. ]	[  CF1	]	[  ID1	]
X	[ PARITY ]	[  CF0	]	[  ID0	]
X
X	SERIAL: no jumper
X	DIAG:	no jumper
X	PARITY: jumper to enable
X
X	============================= BUFFER ==============================
X
X	SIZE:	2K	4K	6K	8K	12K	16K	24K	32K
X
X	CF2:	o o	o o	o o	o o    [o=o]   [o=o]   [o=o]   [o=o]
X	CF1:	o o	o o    [o=o]   [o=o]	o o	o o    [o=o]   [o=o]
X	CF0:	o o    [o=o]	o o    [o=o]	o o    [o=o]	o o    [o=o]
X
X
X	============================= SCSI ID =============================
X
X	ID:	 0	 1	 2	 3	 4	 5	 6	 7
X
X	ID2:	o o	o o	o o	o o    [o=o]   [o=o]   [o=o]   [o=o]
X	ID1:	o o	o o    [o=o]   [o=o]	o o	o o    [o=o]   [o=o]
X	ID0:	o o    [o=o]	o o    [o=o]	o o    [o=o]	o o    [o=o]
X
X	===================================================================
END_OF_FILE
if test 1675 -ne `wc -c <'README.2150'`; then
    echo shar: \"'README.2150'\" unpacked with wrong size!
fi
# end of 'README.2150'
fi
if test -f 'README.5945' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README.5945'\"
else
echo shar: Extracting \"'README.5945'\" \(2440 characters\)
sed "s/^X//" >'README.5945' <<'END_OF_FILE'
X>I have a surplus Archive 5945C QIC tape drive intended for an
X>NCR Tower computer.  The drive assembly includes an interface
X>board of some kind.  The adapter board, which is separate from
X>the tape drive, has a 50 pin edge connector.
X>
X>Is this a SCSI assembly?
X
No, it is not a SCSI assembly.
X
I have identical drives/cards on my Britton-Lee/ShareBase boxes, and on
X3B1, CT MiniFrame, and CT MightyFrame systems.
X
The drive is QIC-02; the interface card accompanying it (assuming it's
mfd by Archive) is most likely a QIC-36 to QIC-02 adapter/translator.
X
On the 50-wire edge connector, not many of the "pins" are used.  In fact,
when used in external tape-drive-only shoeboxes, Archive has two interface
cards which adapt an external connector to the 50-wire edge connector per:
X
X	D-37 connector to 50-wire edge: 80332-001
X	DB25 connector to 50-wire edge: 80221-001
X
These connector-adapter cards are about 1" x 3", and are intended to be
mounted on the "wall" of an enclosure case.
X
When that tape-drive/card is (typically) mounted inside a computer, a 50-wire
ribbon connector is usually used to connect the drive to either a motherboard
or an internal expansion card.  This is why "pulls" (a surplussed drive from
an old computer) are often mistaken for being a SCSI drive.
X
If the accompanying card is an Emulex MT02 (as used on Sun3 systems, for
example), then you could use that drive on a SCSI bus.  The 25x2 SCSI connector
and the two 14-PIN 220/330 Ohm terminator sockets would be obvious; the ID
selection is not obvious (due to use of an unlabelled 8-pos'n DIP switch):
X
X	SW-1 thru SW-3 select SCSI ID per:
X		SW-3 is bit "2", SW-2 is bit "1", SW-1 is bit "0"
X
X	SW-4 is not used.
X
X	SW-5 must be ON ("tach" rate), SW-6 and SW-7 must be OFF
X
X	SW-8 enables parity checking
X
SUMMARY: if the card accompanying the drive is mfd by Archive, it's NOT SCSI,
and you risk damage attempting to adapt a cable to plug it into a SCSI-based
system.
X
WITHOUT EXCEPTION, of the 100's of HDs, tape drives, and other peripherals
I've seen, SCSI ones will have a 25x2 dual-row pin connector whose pins are
on 0.100" centers, and they'll also have an "obvious" location for SCSI
terminators (either 14-/16-pin DIP sockets, several SIP sockets, or one
large 24-DIP socket), and either a DIP switch or jumpers for selecting other
SCSI and mfr-specific parameters (such as parity, buffer sizes, delayed power-
on, "PIN 26" TERMPWR selections, etc.).
END_OF_FILE
if test 2440 -ne `wc -c <'README.5945'`; then
    echo shar: \"'README.5945'\" unpacked with wrong size!
fi
# end of 'README.5945'
fi
if test -f 'README.exb' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README.exb'\"
else
echo shar: Extracting \"'README.exb'\" \(1931 characters\)
sed "s/^X//" >'README.exb' <<'END_OF_FILE'
X>Could someone tell me if an Exabyte 8200 puts 2.3GB on
X>a 90 or 120 minute tape?
X
Depends what cartridge TYPE you're using, and whether you're operating the
drive in "international mode" or not.
X
XFrom Exabyte's "Product Specification" manual, they identify the P5 and P6
cartridges, and they list the track and total block capacities from which
the following table is an extract.  The block count represents the number
of 1024-byte blocks.  Their table is in hex, but I just happen to have my
Casio fx-451 calculator handy for conversions to decimal!
X
Cartridge	Blocks (LBOT to LEOT)
X
P5-15		 5C100H =   377,088	* 1024 =   386,138,112 bytes
P5-30		 BC2B8H =   770,744	* 1024 =   789,241,856 bytes
P5-60		172FF8H = 1,519,608	* 1024 = 1,556,078,592 bytes
P5-90		22C668H = 2,279,016	* 1024 = 2,333,712,384 bytes
X
P6-15		 407E0H =   264,160	* 1024 =   270,499,840 bytes
P6-30		 80FC0H =   528,320	* 1024 =   540,999,680 bytes
P6-60		102020H = 1,056,800	* 1024 = 1,082,163,200 bytes
P6-90		182EA0H = 1,584,800	* 1024 = 1,622,835,200 bytes
P6-120		1FF0E0H = 2,093,280	* 1024 = 2,143,518,720 bytes
X
X--------------------
X
So far I've seen two styles of EXB-8200 drives whose external option jumperings
do NOT resemble those depicted in the Exabyte manuals (various forms of the
XEXABYTE CORP EXB-8200 8MM Cartridge Tape Subsystem Product Specification,
part number MKT-015-03).
X
Another Exabyte manual is their "Interface User's Manual", MKT-016-04, which
on pages 115-117 show how to set (or check) parity, even/odd byte disconnect,
domestic/international cartridges, fixed/variable block modes, etc.) on an
INTERNAL (to the drive) PC card [ and it's a bear to open the drive's card
cage due to cheap tin (putty? :-) screws whose heads disintegrate even with a
proper ISO metric screwdriver (same problem with Japanese audio gear;
difficult to believe that with the world's most modern steel mills, their
steel is the worse (too soft)) ]
END_OF_FILE
if test 1931 -ne `wc -c <'README.exb'`; then
    echo shar: \"'README.exb'\" unpacked with wrong size!
fi
# end of 'README.exb'
fi
if test -f 'README.qic' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README.qic'\"
else
echo shar: Extracting \"'README.qic'\" \(2742 characters\)
sed "s/^X//" >'README.qic' <<'END_OF_FILE'
X[concerning QIC compatibility]
X
Seems some clarification is required here.  Irrespective of the drive's
interface (QIC-02, SCSI, etc.) there are several TRACK formats common to all
QIC (Quarter Inch Cartridge) tapes with several levels of upward-compatible
READ conformance.
X
All the QIC drives perform "serpentine" (hence Archive's Viper, Cobra, etc.)
recording meaning one track at a time is recorded in one direction, then the
heads move and subsequent recording occurs in the opposite direction, etc.
X
Much like the compatibility between {mono, stereo, quad} Philips "Compact
Cassettes" (tm) for audio, the QIC manufacturers have agreed upon:
X
QIC-11	4 tracks
X
QIC-24	9 tracks. 60MB with DC600A tape.
X	Tracks 0-3  are READ-compatible with the 4 tracks of QIC-11
X
QIC-120	15 (??) tracks [see below] 120MB with DC6150 tape.
X	Tracks 0-3  are READ-compatible with the 4 tracks of QIC-11
X	Tracks 0-8  are READ-compatible with the 9 tracks of QIC-24
X
HP	16 tracks.  Pre-formatted from H-P and incompatible with everything.
X
QIC-150	18 tracks. 150MB with DC6150 tape; 250MB with DC6250 tape.
X	Tracks 0-3  are READ-compatible with the  4 tracks of QIC-11
X	Tracks 0-8  are READ-compatible with the  9 tracks of QIC-24
X	Tracks 0-14 are READ-compatible with the 15 tracks of QIC-120
X
QIC-525	?? tracks. 525MB with DC6525 tape.
X	Tracks 0-8  are READ-compatible with the  9 tracks of QIC-24
X	Tracks 0-14 are READ-compatible with the 15 tracks of QIC-120
X	Tracks 0-17 are READ-compatible with the 18 tracks of QIC-150
X
NOTE that Sun publishes "A Tutorial on 1/4 Inch Tape Drives", Part Number
X800-1315-02, which describes all the operational characteristics of such
drives and graphically depicts the track layouts illustrating the WHY and
HOW of the read compatibilities.
X
NOTE the QIC-150 drive can write 250MB using a longer tape (DC6250) analogous
to the difference between C-90 and C-120 audio cassettes.
X
NOTE the QIC-525 drive is NOT read-compatible with QIC-11.
X
NOTE it wasn't made clear to me by Maynard (Archive's end-user and support
organization) the "true" differences between QIC-120 and QIC-150 drives; it's
either or both the number of tracks and/or the recording density, so take the
X"15-tracks of QIC-120" with a grain of salt until someone else posts the
definitive answer.
X
The newer drives are able to automatically sense the recording density and
make internal adjustments for read-compatibility.
X
But, whew, the extra calendaring of the tape's surface and the exotic coating
for the DC6525 media have pushed its list price (from Archive) up to $79 (this
from a price list at UniForum in January 1992) per cartridge.
X
If you want the info direct from THE manufacturer:
X
X	uunet!maynhbd!info (OR) info@maynhbd.UUCP
X	1-800-821-8782
END_OF_FILE
if test 2742 -ne `wc -c <'README.qic'`; then
    echo shar: \"'README.qic'\" unpacked with wrong size!
fi
# end of 'README.qic'
fi
if test -f 'README.tzk10' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README.tzk10'\"
else
echo shar: Extracting \"'README.tzk10'\" \(1657 characters\)
sed "s/^X//" >'README.tzk10' <<'END_OF_FILE'
X>[...]
X>DEC now offers a 1/4" tape drive - TZK10, which can be used
X>for backup, etc.  The tapes can hold up to 525Mb.  This is
X>significantly more than SUN tape drives, but I heard that the
X>drives are compatible, i.e. you can read SUN tapes on the TZK10 (tar).
X>Is this true?  Also, does anyone know the type of tapes that hold
X>up to 525Mb and their ballpark price.  I currently have a TK50 and
X>would like to move to something with more capacity and not too much $$.
X>[...]
X
What you're describing sounds much like Archive's new ST525 series which
use the QIC-525 "format" for 525MB.
X
If this IS, in fact, the situation, then the drive would be READ compatible
with QIC-24 (60MB with DC600A tape, 9 tracks), QIC-120, and QIC-150(150MB with
DC6150 tapes or 250MB with DC6250 tapes, 18 tracks) as used on Sun (and other)
systems.
X
XFrom Archive's latest pricing sheet (just received last week from Maynard,
Archive's end-user and support subsidiary):
X
X	90507	DC6250 media		$69.00
X	90509	DC6525 media		$79.00
X
Those prices are their "US Retail."  Given that 3M DC6250 tapes are < $29
locally (Silicon Valley: Fry's Electronics, a "consumer"-type store), you
should be able to adjust the (expected) price for 3M DC6525 accordingly.
X
Archive's/Maynard's "US Retail" pricing for a "raw" ST525 drive is $1,528
for their "ST525i internal 525MB SCSI drive kit" and $1,880 for their
X"ST525e external 525MB SCSI drive kit."
X
I dunno; as much as I like Archive drives (over 20 of them here), that
X"list" pricing is comparable to Exabyte EXB-8200 drives which can store
X4x more data (2.3GB on P5-90 cartridges).
X
X
X[ NOTE: prices quoted above are circa January 1992 ]
END_OF_FILE
if test 1657 -ne `wc -c <'README.tzk10'`; then
    echo shar: \"'README.tzk10'\" unpacked with wrong size!
fi
# end of 'README.tzk10'
fi
if test -f 'tprobe.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tprobe.c'\"
else
echo shar: Extracting \"'tprobe.c'\" \(11058 characters\)
sed "s/^X//" >'tprobe.c' <<'END_OF_FILE'
X/*
X *	tprobe	- tape analyzer and duplicator
X *
X *	usage: tprobe  [ -b N ] [ -r | -w ]  /dev/tapedevice
X *
X *	"-b N" specifies a buffersize N other than the default 65536 bytes.
X *
X *	"-r" reads tapedevice and writes to stdout in a special form designed
X *	to be piped to another tprobe process (even across a net) for writing
X *	(i.e. duplicating) a tape onto a second tape drive.
X *
X *	"-w" reads stdin specially formatted by another tprobe process and
X *	writes (i.e. duplicates) to tapedevice.
X *
X *	with no options (other than -b), tprobe reads tapedevice and writes
X *	a brief analysis its findings to stdout.
X *
X *	Adding switch "-d" for the read-side permits a file (instead of a tape)
X *	to be used for testing purposes; only works if compiled with -DDEBUG.
X *
X *	In general, the tape should be rewound before the first use of tprobe.
X *	And the tapedevice "should" be the no-rewind on close device; for
X *	example:
X *
X *		3B1:		/dev/rmt4
X *		CTIX:		/dev/rmt4
X *		SunOS 4.1.1:	/dev/nrst8
X *
X *	To rewind the tape (before and) after using tprobe:
X *
X *		3B1:		qrewind			(Thad's QIC-02 program)
X *		CTIX:		tsioctl -c rewind /dev/rmt0
X *		SunOS 4.1.1:	mt -f /dev/rst8 rewind
X *
X * REVISION HISTORY:
X *
X * 1991		----	T.Floryan, original Kwik'N'Dirty program for own use
X * 12-Feb-1992	V1.0	T.Floryan, release to Usenet after lint-fixing, etc.
X *			Comments, suggestions, complaints to thad@btr.com
X *
X */
X
X#include <stdio.h>
X#include <fcntl.h>
X#include <errno.h>
X#include <malloc.h>		/* added to suppress some of lint's whining */
X
extern	void	exit();
extern	char	*strncpy();
extern	int	open();
extern	int	read();
extern	int	write();
extern	int	atoi();
X
void	probe_tape();
void	read_tape();
void	write_tape();
void	usage();
X
typedef int		MWORD;
typedef int		LWORD;	/* sizeof(int) must be sizeof(long) */
typedef unsigned int	UWORD;
X
X#define STDIN	0		/* for read() device		*/
X#define STDOUT	1		/* for write() device		*/
X#define BLKSIZE	512		/* QIC tape physical blocking	*/
X#define TBUFSIZ	65536		/* default R/W buffer size	*/
X#define MINBUF	512		/* minimum R/W buffer size: 2^9	*/
X#define MAXBUF	1048576		/* maximum R/W buffer size: 2^20*/
X#define UMASK	0666		/* needed for creat(2) usage	*/
X#define VERSKIP	4		/* skip displacement in version string */
X
X
X/*	The following headers represent the control information passed
X *	by a tape reader process to a tape writer process
X */
X#define HDRSIZE	10		/* size of a control header	*/
X
X#define SCANSTR	"%8ld"
X#define BUFHDR	"B%08ld\n"
X#define DATHDR	"D%08ld\n"
X#define SIZHDR	"S%08ld\n"
X#define CLSHDR	"C00000000\n"
X#define ERRHDR	"E00000000\n"
X#define EOTHDR	"T00000000\n"
X
X
X#define STATSTR	"SS%4d: %7ld blocks, %10ld bytes\n"
X#define GTTLSTR	"GTotal: %7ld blocks, %10ld bytes\n"
X
X#ifdef DEBUG
int debug = 0;
char *cmd_options = "b:rwd?hH";
X#else
char *cmd_options = "b:rw?hH";
X#endif
X
LWORD	tbufsize = TBUFSIZ;
X
char *version =
X	"@(#)tprobe V1.0, 12-Feb-1992, Thad Floryan [ thad@btr.com ]";
X
char *usage_text[] = {
X	"usage:	tprobe [-b N] [-r] tapedev [ | tprobe [-b N] -w tapedev ]",
X	"where:	-b  sets buffer size to N (overriding the default 65536)",
X	"	-r  specifies \"this\" process to be the tape reader",
X	"	-w  designates \"this\" process to be a tape writer",
X	0
X};
X
X
main(argc, argv)
X	int	argc;
X	char	*argv[];
X{
X	extern int	 getopt();
X	extern int	 optind;
X	extern char	*optarg;
X
X	MWORD	mode = 0;	/* 0=analysis, 1=read, 2=write	*/
X	MWORD	bufset = 0;	/* non-zero if "-b" specified */
X	MWORD	optchr;
X
X
X/*
X *	Quick check to see if the program CAN run on this system due
X *	to various assumptions.
X */
X	if (sizeof(int) != sizeof(long)) {
X	    (void) fprintf(stderr, "Program won't run on this system\n");
X	    exit(1);
X	}
X/*
X *	Process options
X */
X
X	while ( ( optchr = getopt( argc, argv, cmd_options ) ) != EOF ) {
X
X	    switch (optchr) {
X
X	    case 'b':	if (bufset != 0) {
X			    (void) fprintf(stderr,
X				"%s: buffer size already set\n", argv[0]);
X			    usage();
X			}
X			++bufset;
X			tbufsize = atoi(optarg);
X			if ((tbufsize < MINBUF) || (tbufsize > MAXBUF)) {
X			    (void) fprintf(stderr,
X				"%s: unreasonable buffer size (%ld)\n",
X				argv[0], tbufsize);
X			    usage();
X			}
X			if ((tbufsize % BLKSIZE) != 0) {
X			    (void) fprintf(stderr,
X				"%s: buffer size (%ld) not multiple of 512\n",
X				argv[0], tbufsize);
X			    usage();
X			}
X			break;
X
X	    case 'r':	if (mode != 0) {
X			    (void) fprintf(stderr,"%s: too many options\n",
X				argv[0]);
X			    usage();
X			}
X			mode = 1;
X			break;
X
X	    case 'w':	if (mode != 0) {
X			    (void) fprintf(stderr,"%s: too many options\n",
X				argv[0]);
X			    usage();
X			}
X			mode = 2;
X			break;
X
X#ifdef DEBUG
X	    case 'd':	if (mode != 1) {	/* must be spec'd after "-r" */
X			    usage();
X			}
X			++debug;
X			break;
X#endif /* DEBUG */
X
X	    case '?':
X	    case 'h':
X	    case 'H':
X	    default:	usage();
X	    }
X	}
X
X	if ( optind == argc )
X	    usage();
X
X	if ( optind != (argc - 1)) {
X	    (void) fprintf(stderr,
X		"%s: extraneous data on command line ``%s''\n",
X		argv[0], argv[optind + 1]);
X	    usage();
X	}
X
X	switch (mode) {
X		case 0:	probe_tape(argv[optind]);
X			break;
X		case 1:	read_tape(argv[optind]);
X			break;
X		case 2:	write_tape(argv[optind]);
X			break;
X	}
X
X	return 0;
X}
X
X
void
probe_tape(tapedev)
X	char	*tapedev;
X{
X	LWORD	grandttl = 0;
X	LWORD	numread  = 0;
X	MWORD	ssno     = 0;
X	MWORD	td       = 0;
X	LWORD	ttlread;
X
X	char	*bptr;
X	char	errmsg[200];
X
X
X	bptr = (char *) malloc(tbufsize + 4);
X
X	while (td >= 0) {
X
X	    if ( (td = open(tapedev, O_RDONLY, 0)) < 0) {
X		(void) sprintf(errmsg, "Cannot open tape unit %s", tapedev);
X		perror(errmsg);
X		exit(1);
X	    }
X
X	    ttlread = 0;
X
X	    for (;;) {
X		numread = read(td, bptr, (UWORD) tbufsize);
X		if (numread != tbufsize) {
X			if (numread > 0) {
X			    ttlread += numread;
X			}
X			break;
X		}
X		ttlread += numread;
X	    }
X
X	    (void) printf(STATSTR, ssno, ttlread/BLKSIZE, ttlread);
X	    ++ssno;
X	    grandttl += ttlread;
X
X	    (void) close(td);
X
X	    if (numread < 0) {
X		(void) sprintf(errmsg, "Read error = %d", errno);
X		perror(errmsg);
X		td = -1;
X		break;
X	    }
X	    if ((ttlread == 0) || (numread == 0)) {
X		(void) printf("End of tape\n");
X		td = -1;
X		break;
X	    }
X	}
X
X	(void) free(bptr);
X
X	(void) printf(GTTLSTR, grandttl/BLKSIZE, grandttl);
X}
X
X
void
read_tape(tapedev)
X	char	*tapedev;
X{
X	LWORD	grandttl = 0;
X	LWORD	numread  = 0;
X	MWORD	td       = 0;
X	LWORD	ttlread;
X
X	char	*bptr;
X	char	*dataptr;
X	char	errmsg[200];
X	char	header[HDRSIZE + 2];
X
X
X	bptr = (char *) malloc(tbufsize + HDRSIZE + 2);
X
X	if (bptr == NULL) {
X	    (void) sprintf(errmsg,
X			"Cannot allocate requested buffer size: %ld",
X			tbufsize);
X	    perror(errmsg);
X	    exit(1);
X	}
X
X	dataptr = bptr + HDRSIZE;
X
X	(void) sprintf(header, BUFHDR, tbufsize);
X	(void) write(STDOUT, header, HDRSIZE);
X
X	while (td >= 0) {
X
X	    if ( (td = open(tapedev, O_RDONLY, 0)) < 0) {
X		(void) sprintf(errmsg, "Cannot open tape unit %s", tapedev);
X		perror(errmsg);
X		exit(1);
X	    }
X
X	    ttlread = 0;
X
X	    for (;;) {
X		numread = read(td, dataptr, (UWORD) tbufsize);
X		if (numread != tbufsize) {
X			if (numread > 0) {
X			    ttlread += numread;
X			    (void) sprintf(header, DATHDR, numread);
X			    (void) strncpy(bptr, header, HDRSIZE);
X			    (void) write(STDOUT, bptr,
X					 (UWORD) (numread + HDRSIZE));
X			}
X			break;
X		}
X		ttlread += numread;
X		(void) sprintf(header, DATHDR, numread);
X		(void) strncpy(bptr, header, HDRSIZE);
X		(void) write(STDOUT, bptr, (UWORD) (numread + HDRSIZE));
X	    }
X	    grandttl += ttlread;
X
X	    (void) close(td);
X	    (void) write(STDOUT, CLSHDR, HDRSIZE); /* close */
X
X#ifdef DEBUG
X	    if (debug)
X		td = (-1);
X#endif /* ifdef DEBUG */
X
X	    if (numread < 0) {
X		(void) write(STDOUT, ERRHDR, HDRSIZE); /* tape error */
X		td = -1;
X		break;
X	    }
X	    if ((ttlread == 0) || (numread == 0)) {
X		(void) write(STDOUT, EOTHDR, HDRSIZE); /* end of tape */
X		td = -1;
X		break;
X	    }
X	}
X	(void) sprintf(header, SIZHDR, grandttl/BLKSIZE);
X	(void) write(STDOUT, header, HDRSIZE);
X
X	(void) free(bptr);
X}
X
X
void
write_tape(tapedev)
X	char	*tapedev;
X{
X	LWORD	grandttl = 0;
X	LWORD	hdrvalue;
X	LWORD	numleft;
X	LWORD	numread  = 0;
X	LWORD	numwrote = 0;
X	MWORD	process  = 1;
X	MWORD	satis    = 0;
X	MWORD	td       = -1;
X	LWORD	ttlread  = 0;
X
X	char	*bptr;
X	char	*dataptr;
X	char	*readptr;
X	char	errmsg[200];
X
X
X
X	bptr = (char *) malloc(tbufsize + HDRSIZE + 2);
X
X	if (bptr == NULL) {
X	    (void) sprintf(errmsg,
X			"Cannot allocate requested buffer size: %ld",
X			tbufsize);
X	    perror(errmsg);
X	    exit(1);
X	}
X
X	numread = read(STDIN, bptr, HDRSIZE);
X
X	if (numread != HDRSIZE) {
X	    (void) sprintf(errmsg,
X			"We gotta problem; header size wrong: %ld",
X			numread);
X	    perror(errmsg);
X	    exit(1);
X	}
X
X	if (*bptr == 'B') {
X	    (void) sscanf(bptr + 1, SCANSTR, &hdrvalue);
X	    if (hdrvalue != tbufsize) {
X		(void) sprintf(errmsg, "Buffer disagreement: R=%ld, W=%ld",
X			hdrvalue, tbufsize);
X		perror(errmsg);
X		exit(1);
X	    }
X	} else {
X	    perror("First header not ``B''");
X	    exit(1);
X	}
X
X	dataptr = bptr + HDRSIZE;
X
X	while (process != 0) {
X
X	    numread = read(STDIN, bptr, HDRSIZE);
X
X	    if (numread != HDRSIZE) {
X		(void) sprintf(errmsg,
X				"We gotta problem; header size wrong: %ld",
X				numread);
X		perror(errmsg);
X		exit(1);
X	    }
X	    (void) sscanf(bptr + 1, SCANSTR, &hdrvalue);
X
X	    switch (*bptr) {
X	    case 'D':	if (td < 0) {
X			    if ( (td = creat(tapedev, UMASK)) < 0) {
X				(void) sprintf(errmsg,
X					       "Cannot open tape unit %s",
X					       tapedev);
X				perror(errmsg);
X				process = 0;
X			    }
X			}
X
X			numleft = hdrvalue;
X			readptr = dataptr;
X			satis   = 0;
X
X			while (satis == 0) {
X			    numread  = read(STDIN, readptr, (UWORD) numleft);
X			    if (numread != numleft) {
X				numleft -= numread;
X				readptr += numread;
X				ttlread += numread;
X			    } else {
X				ttlread += numread;
X				++satis;
X			    }
X			}
X
X			numwrote = write(td, dataptr, (UWORD) hdrvalue);
X			if (numwrote != hdrvalue) {
X			    (void) fprintf(stderr,
X				"Tape size error: %ld should be %ld\n",
X				numwrote, hdrvalue);
X			    (void) close(td);
X			    process = 0;
X			} else {
X			    grandttl += numwrote;
X			}
X			break;
X	    case 'C':	if (td < 0) {
X			    if ( (td = creat(tapedev, UMASK)) < 0) {
X				(void) sprintf(errmsg,
X					       "Cannot open tape unit %s",
X					       tapedev);
X				perror(errmsg);
X				process = 0;
X			    }
X			}
X			(void) close(td);
X			td = -1;
X			break;
X	    case 'T':	process = 0;	/* Remote End-Of-Tape; all done */
X			break;
X	    case 'S':	if (hdrvalue != (grandttl/BLKSIZE)) {
X			    (void) fprintf(stderr,
X				"Grand total mismatch: %ld should be %ld\n",
X				grandttl, ttlread);
X			}
X			td = -1;
X			process = 0;
X			break;
X	    case 'E':	(void) fprintf(stderr, "Remote error detected\n");
X			break;
X	    default:	(void) fprintf(stderr, "Header error: %c\n", *bptr);
X			if (td >= 0) {
X			    (void) close(td);
X			    td = -1;
X			}
X			process = 0;
X	    }
X	}
X
X	(void) free(bptr);
X}
X
void
usage()
X{
X	int	ndx = 0;
X
X	while ( usage_text[ndx] != 0 ) {
X
X	    (void) fprintf( stderr, "%s\n", usage_text[ndx++] );
X	}
X	(void) fprintf( stderr, "%s\n", version + VERSKIP );
X	exit(1);
X}
END_OF_FILE
if test 11058 -ne `wc -c <'tprobe.c'`; then
    echo shar: \"'tprobe.c'\" unpacked with wrong size!
fi
# end of 'tprobe.c'
fi
if test -f 'tprobe.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tprobe.man'\"
else
echo shar: Extracting \"'tprobe.man'\" \(9992 characters\)
sed "s/^X//" >'tprobe.man' <<'END_OF_FILE'
X.TH TPROBE L "12-Feb-1992"
X.\"@(#)tprobe.man V1.0, 12-Feb-1992, Thad Floryan [ thad@btr.com ]
X.SH NAME
tprobe \- tape saveset analyzer and duplicator
X.SH SYNOPSIS
tprobe [-b
X.I n]
X.I /dev/NRTD
X.LP
tprobe [-b
X.I n]
X-r
X.I /dev/NRTD0
X| tprobe [-b
X.I n]
X-w
X.I /dev/NRTD1
X.LP
X.I [host]
tprobe [-b
X.I n]
X-r
X.I /dev/NRTD0
X|
X.ti +23
X.I [host]
tprobe [-b
X.I n]
X-w
X.I /dev/NRTD1
X.sp
X.ta +0.3i
X.in +0.3i
X.ti -0.3i
X\(bu
X.I	``/dev/NRTDn''
is typically the "no-rewind-on-close" tape device [See
X.I OPERATING NOTES]
X.sp
X.ti -0.3i
X\(bu
X.I	``host''
is the system-dependent clause signifying remote tape
operation [See
X.I OPERATING NOTES]
X.in -0.3i
X.SH DESCRIPTION
X.I tprobe
is a utility which succeeds duplicating boot/install tapes that are not
easily copied by other means.  One of its features is operation over a
pipeline utilizing multiple tape drives whereever they exist on a network
or a system.
X.sp
X.I tprobe
can also (indirectly) perform media conversions, though the
only verified conversions have been from QIC-120 and QIC-150 to QIC-24
and vice versa; there is no inherent limitation, so other conversions
are definitely possible.
X.sp
Another feature is that a tape may be processed without disk space being
usurped for intermediate staging.  Thus, a full 150MB tape can be duplicated
even if one's system has only, say, 20MB free.
X.sp
X.I tprobe's
basic operation reveals a tape's existing saveset layout and stored capacity,
and requires only a single tape drive for this analysis.
X.sp
X.I tprobe
was intended to be a one-time-only program, but it is useful in its present
incarnation and does solve immediate and present problems.
XFor
X.I tprobe's
raison d'etre and anecdotes, see the
X.I BACKGROUND
section.
X.SH OPTIONS
X.TP 8
X.I -b
Specifies the buffering size to help maintain streaming operation.  The
default is 65536 bytes.  A value must be stated in bytes; no abbreviations
are recognized in this version.  The buffer must be the same size at both
ends of the pipe else the "write" process will diagnose the error and abort.
X.sp
XFor 8mm EXB-8200 drives, 262144 (256KB) appears to be an optimal size.
XExperiment!
X.TP 8
X.I -r
Designates "this" process to be the tape reader and head of the pipeline.
X.TP 8
X.I -w
Designates "this" process to be a tape writer and a tail of the pipeline
X(see
X.IB tee(1)).
X.SH OPERATING NOTES
With no options (other than -b),
X.I tprobe
reads a tape and writes a brief analysis of its findings to stdout.
X.sp
The tape device should be a "no-rewind-on-close" device per the following
examples:
X.sp
X.nf
X.RS
X/dev/nrst8      SunOS 4.1.1 with a SCSI tape
X.br
X/dev/rmt4       CTIX or 3B1 with a QIC-02 drive
X.RE
X.fi
X.sp
In general, a tape should be rewound before use.
Several examples of rewinding a tape on some systems are:
X.sp
X.nf
X.RS
SunOS 4.1.1:    mt -f /dev/rst8 rewind
X.br
CTIX:           tsioctl -c rewind /dev/rmt0
X.br
X3B1:            qrewind   # (Thad's QIC-02 program)
X.RE
X.fi
X.sp
The "[host]" as shown in the
X.I SYNOPSIS
takes the forms:
X.sp
X.RS
X[rsh | remsh | rcmd] hostname
X.RE
X.sp
as appropriate for the system on which the command is issued.
Specification simply as "hostname" is permitted if /usr/hosts/MAKEHOSTS has
been previously executed and "/usr/hosts" is present in $PATH.
X.sp
Note that for remote system operation, the /etc/hosts.equiv and/or
the ~/.rhosts authentication file(s) must be previously established.
X.I tprobe
must exist within the directories specified in all one's $PATH's, especially
so for remote operation.
X.sp
Note that not all systems' and/or applications' install tapes have two
consecutive file-marks to designate end-of-tape;
X.I tprobe
will still correctly duplicate such tapes.
X.SH EXAMPLES
To duplicate a tape mounted on a remote Sun named "faraway" onto the local
Sun, assuring that all tapes are rewound before and after the operation:
X.sp
X.in +0.5i
rsh faraway mt -f /dev/rst8 rewind
X.br
mt -f /dev/rst8 rewind
X.br
rsh faraway tprobe -r /dev/nrst8 | tprobe -w /dev/nrst8
X.br
rsh faraway mt -f /dev/rst8 rewind
X.br
mt -f /dev/rst8 rewind
X.in -0.5i
X.sp
To duplicate a tape on a local Sun having two tape drives:
X.sp
X.ti +0.5i
tprobe -r /dev/nrst8 | tprobe -w /dev/nrst9
X.sp
To duplicate a tape between two remote Sun systems ("proxy" mode)
where both remote systems have link entries in /usr/hosts:
X.sp
X.ti +0.5i
host1 tprobe -r /dev/nrst8 | host2 tprobe -w /dev/nrst8
X.SH BACKGROUND
It appears there's confusion surrounding the "difficulty" making [legally
permissible] backup copies of one's boot/install tapes to assure continued
operation of one's system(s).
X.sp
Many people's attempts with
X.IB dd(1),
X.IB cat(1),
etc. have failed (even though such
attempts have worked duplicating, say, "pure" tar- or cpio-written tapes).
X.sp
The reason for the difficulty is due to the varying record sizes typically
found on boot/install tapes.  In other words, it's difficult to specify an
X.I efficient
least-common-denominator (LCD) block/record size to
X.IB dd(1)
for a "raw" duplication [ although an intelligent shell script can get around
this, using
X.IB dd(1)'s
stats ]; note programs such as
X.IB cat(1)
tend to assume constantly-fixed record sizes.
X.sp
XFor the record, the LCD for QIC tapes is 512-bytes, which is the physical
blocking size.  But if you attempt to use that size, your data will be
X``Shoe Shined'' into oblivion!  :-)
X.sp
Three representative samplings of the beginning layout of boot tapes
analyzed by
X.I tprobe
for a Sun, a CTIX, and an AT&T boot/install tape are shown below.
X"SS n" is the save-set number (a save-set being the data
between file-marks on a tape).
X"blocks" are the 512-byte physical records as written on QIC tapes.
These examples show
X.I tprobe
operation from a Sun system console:
X.sp
X.RS
X% # SunOS 4.1.1 Sun-3 SUNBIN, tape 1 of 2
X.br
X% #
X.br
X% tprobe /dev/nrst8
X.br
SS   0:     64 blocks,     32768 bytes
X.br
SS   1:     16 blocks,      8192 bytes
X.br
SS   2:   1425 blocks,    729600 bytes
X.br
SS   3:   3200 blocks,   1638400 bytes
X.br
SS   4:  14000 blocks,   7168000 bytes
X.br
SS   5:    146 blocks,     74752 bytes
X.br
SS   6:  22674 blocks,  11609088 bytes
X.br
X[...]
X.sp
X% # CTIX 6.2 MightyFrame RUNTIME/INSTALL
X.br
X% #
X.br
X% tprobe /dev/nrst8
X.br
SS   0:    128 blocks,     65536 bytes
X.br
SS   1:    768 blocks,    393216 bytes
X.br
SS   2:   1888 blocks,    966656 bytes
X.br
SS   3:   2176 blocks,   1114112 bytes
X.br
SS   4:    320 blocks,    163840 bytes
X.br
SS   5:    384 blocks,    196608 bytes
X.br
SS   6:    256 blocks,    131072 bytes
X.br
X[...]
X.sp
X% # AT&T 3B2 SVR3.2.2 LOAD 19 OS & UTILS
X.br
X% #
X.br
X% tprobe /dev/nrst8
X.br
SS   0:   4099 blocks,   2098688 bytes
X.br
SS   1:   8610 blocks,   4408320 bytes
X.br
SS   2:      3 blocks,      1536 bytes
X.br
SS   3:   1422 blocks,    728064 bytes
X.br
SS   4:   1422 blocks,    728064 bytes
X.br
SS   5:   1422 blocks,    728064 bytes
X.br
SS   6:   1422 blocks,    728064 bytes
X.br
X[...]
X.RE
X.sp
X.I tprobe
was conceived when it was realized the SunOS 4.1.1 Sun-3 SUNBIN install tape
was to be the last ever from Sun for that architecture and that a backup was
essential to prevent disaster if the tape should be "bad" when most needed
to boot into a miniroot.
X.sp
X.I tprobe's
main purpose is to read one tape and write to another over Ethernet since
systems typically possess only one tape drive.
X.sp
X.I tprobe
duplicates tapes
X.I without consuming disk space
and, as a side benefit,
indirectly converts tape media between QIC-11/-24/-120/-150/-525 within
the storage capability of the output tape.
X.sp
The first test of
X.I tprobe
was the duplication of a SunOS install tape by reading the original on a 3B1
while writing the duplicate on a CT MightyFrame, then booting and
suninstall'ing from the duplicated tape on a Sun-3/60.
X.sp
Systems on which
X.I tprobe
has been installed and tested include 3B1, CTIX, Sun-3, Sun-4, and an AT&T 3B2.
X.SH AUTHOR
Thad Floryan
X.br
thad@btr.com (OR) {decwrl,mips,fernwood}!btr!thad
X.br
X.ne 3
X.SH VERSION
The present release of
X.I tprobe
is 1.0, dated 12-Feb-1992.
X.SH FUTURE DEVELOPMENT
X.ta +0.3i
X.in +0.3i
X.ti -0.3i
X\(bu	Add double buffering (for speed) along the lines of the
X.IB ddd(1)
program posted to comp.sources.unix/Volume15 by Tapani Lindgren, with two
child processes alternating pipe I/O with tape I/O.
X.sp
X.ti -0.3i
X\(bu	Devise a method of truly copying, say, a full 150MB tape onto
three 60MB tapes.  Would require more tape "smarts" to detect EOM (end
of media) and prompting for media change.  Not certain of feasibility
due to unknown source media's genesis (e.g. tar, cpio, whatever).
X.SH CAVEATS
X.PP
This program has functioned satisfactorily for the author, but no guarantees
or warrantees are given or implied that
X.I tprobe
will be suitable for your applications; this software is distributed
X.I AS IS.
X.sp
Any error detection and correction, such as may exist, is limited to that
available with the standard system I/O calls
X.IB open(2),
X.IB read(2)
and
X.IB write(2).
X.sp
By installing
X.I tprobe
on your system, you assume all risks and liabilities for its use.
X.SH BUGS
X.PP
Internal counters and statistics are kept as "long" data;
newer tape drives whose media capacity exceeds a system's ability to
retain a tally that large will definitely be troublesome.
X.sp
X.I tprobe
assumes the user has specified a tape device as its object; anything else
as
X.I tprobe's
object will probably trigger unknown and bizarre side-effects.
X.SH SEE ALSO
All pertinent tape, mt, mtio, tsioctl, etc. commands as appropriate for
your system(s) to ascertain the correct tape device syntax and semantics
for your drive(s) operated per "no-rewind-on-close."
X.sp
The
X.IB copytape(1)
program by David S. Hayes (April 1985/July 1986) is also
worthy of your consideration.   On a system with one tape drive, it
creates a specially-formatted intermediate file whose size reflects the
tape's contents; on a two-tape-drive system it can duplicate a tape in
one pass.  Because of its intermediate file,
X.IB copytape(1)
easily produces multiple copies after a single read of the master tape.
END_OF_FILE
if test 9992 -ne `wc -c <'tprobe.man'`; then
    echo shar: \"'tprobe.man'\" unpacked with wrong size!
fi
# end of 'tprobe.man'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
