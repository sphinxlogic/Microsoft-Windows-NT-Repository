Newsgroups: comp.sources.unix
From: fkk@stasys.sta.sub.org (Frank Kaefer)
Subject: v26i142: banners - a collection of banner programs, V1.1, Part02/07
Sender: unix-sources-moderator@vix.com
Approved: paul@vix.com

Submitted-By: fkk@stasys.sta.sub.org (Frank Kaefer)
Posting-Number: Volume 26, Issue 142
Archive-Name: banners-1.1/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 7)."
# Contents:  banner-01/banner.c banner-04/sysvbanner.c banner-05/kban.c
#   banner-05/lban.c banner-05/sban.c banner-07/banner.c
#   banner-11/MB_Font.uu banner-11/Read.Me banner-11/mb.c
#   banner-13/cyrban.c cursive-01/cursive.c cursive-02/cursive.c
# Wrapped by vixie@gw.home.vix.com on Sun Apr 11 23:19:19 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'banner-01/banner.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-01/banner.c'\"
else
echo shar: Extracting \"'banner-01/banner.c'\" \(5255 characters\)
sed "s/^X//" >'banner-01/banner.c' <<'END_OF_FILE'
X/*
X * The ultimative banner.
X *
X * Written in 1987 by Wolfgang Ocker, reccoware systems, Puchheim
X *
X * It's *not* fast, but nice ...
X *
X * Tested on OS-9/68000, SunOS
X */
X
X#include <stdio.h>
X#ifdef OSK
X#include <modes.h>
X#else
X#define S_IREAD 0
X#endif
X
X
X#define TRUE  1
X#define FALSE 0
X
extern unsigned char charset;      /* Zeichensatz */
extern int           errno;
X
X#ifdef OSK
X/*
X * Signal Handler (Dummy)
X */
int sighandler()
X{
X}
X#endif
X
X/*
X * m a i n
X */
main(argc, argv)
X  int  argc;
X  char *argv[];
X{
X  char          *str, strbuf[200];
X  int           linenum, chnum, i, j, k, count, strnum;
X  unsigned char ch;
X  int           ch_off;
X  unsigned char *ch_addr;
X  unsigned char *font;
X  int           italic, dblsize, samechar;
X  char          bannerchar;
X  FILE          *infp;  
X  char          *from, *plife;
X
X  italic     = dblsize = samechar = FALSE;
X  strnum     = 0;
X  from       = NULL;
X  bannerchar = '*';
X  plife      = NULL;
X
X  /*
X   * Get the arguments. I *hate* getopt(:-). This works nice (and is
X   * simpler).
X   */
X  for (i = 1; i < argc; i++)
X    if (argv[i][0] == '-')
X      for (j = 1; j < strlen(argv[i]); j++)
X        switch(tolower(argv[i][j])) {
X          case '?':
X            usage();
X            exit(1);
X            
X          case 'i':     /* italic printing */
X            italic = TRUE;
X            break;          
X
X          case 'd':     /* double sized characters */
X            dblsize = TRUE;
X            break;
X  
X          case 's':     /* use character to build large char, e.g.
X                         * c becomes
X                         *
X                         *  ccc
X                         * c   
X                         * c          (or so ...)
X                         *  ccc
X                         */
X            samechar = TRUE;
X            break;
X
X#ifdef OSK          
X          case 'l':
X            plife = argv[i] + j + (argv[i][j+1] == '=' ? 2 : 1);
X            j = strlen(argv[i]);
X            break;
X#endif
X  
X          case 'c':       /* character for banner */
X            j += argv[i][j+1] == '=' ? 2 : 1;
X            bannerchar = argv[i][j];
X            break;
X 
X          case 'z':       /* get text from ... */
X            if (from) {
X              usage();
X              fputs("multiple 'z' option not allowed\n", stderr);
X              exit(1);
X            }
X
X            from = argv[i] + j + (argv[i][j+1] == '=' ? 2 : 1);
X            j = strlen(argv[i]);
X            break;
X
X          default:
X            usage();
X            fprintf(stderr, "banner: unknown option '%c'\n", argv[i][j]);
X            exit(1);
X        }
X    else
X      strnum++;     /* count number of strings */
X
X  if (strnum == 0 && from == NULL) {
X    usage();
X#ifdef OSK
X    exit(_errmsg(1, "no string given\n"));
X#else
X    exit(fputs("no string given\n", stderr), 1);
X#endif
X  }
X
X  if (strnum && from) {
X    usage();
X#ifdef OSK
X    exit(_errmsg(1, "'z' option not allowed if string(s) given\n"));
X#else
X  exit(fputs("'z' option not allowed if string(s) given\n", stderr), 1);
X#endif
X  }
X
X  if (from) {
X    if (from[0]) {
X      if ((infp = fopen(from, "r")) == NULL)
X#ifdef OSK
X        exit(_errmsg(errno, "can't open '%s'\n", from));
X#else
X        exit(fprintf(stderr, "can't open '%s'\n", from), errno);
X#endif
X    }
X    else
X      infp = stdin;
X
X  }
X
X#ifdef OSK
X  if (plife && !strcmp(plife, "dont_kill_me"))
X    intercept(sighandler);
X#endif
X
X  font = &charset;
X  str  = strbuf;
X
X  i = 1;
X  while (TRUE) {
X    if (from) {     /* read strings from file/stdin */
X      if (fgets(strbuf, sizeof(strbuf)-1, infp) == NULL)
X        break;
X      strbuf[strlen(strbuf)-1] = '\0';
X    }
X    else {        /* get strings from argument line */
X      if ((str = argv[i++]) == NULL)
X        break;
X      if (str[0] == '-')
X        continue;
X    }
X       
X    for (linenum = 0; linenum < 8; linenum++) {     /* 8 lines per char */
X      for (j = 0; j < (dblsize ? 2 : 1); j++) {
X        putchar('\n');
X
X        if (italic)     /* shift for italics */
X          for (k = linenum; k < 7; k++)
X            fputs(dblsize ? "  " : " ", stdout);
X
X        for (chnum = 0; chnum < strlen(str); chnum++) {
X          ch      = str[chnum];
X          ch_off  = (int) ch * 8;
X          ch_addr = font + ch_off + linenum;
X          outline(ch, *ch_addr, dblsize, bannerchar, samechar);
X        }
X      } 
X    }
X  }
X
X  putchar('\n');
X}
X
X/*
X * o u t l i n e
X */
outline(outchar, outbyte, dblsize, bannerchar, samechar)
X  char outchar, outbyte, bannerchar;
X  int  dblsize, samechar;
X
X{
X  int bc, j;
X
X  for (bc = 7; bc >= 0; bc--)
X    for (j = 0; j < (dblsize ? 2 : 1); j++)
X      if (outbyte & (0x01 << bc))
X        putchar((samechar) ? outchar : bannerchar);
X      else
X        putchar(' ');
X}
X
X/*
X * u s a g e
X */
usage()
X{
X  fputs("Syntax: banner [<opts>] {<string>} [<opts>]\n", stderr);
X  fputs("Function: prints a banner to stdout\n", stderr);
X  fputs("Options:\n", stderr);
X  fputs("     -i          prints italic\n", stderr);
X  fputs("     -d          double size\n", stderr);
X  fputs("     -c=<char>   character\n", stderr);
X  fputs("     -s          use same character\n", stderr);
X  fputs("     -z          read strings from standard input\n", stderr);
X  fputs("     -z=<file>   read strings from <file>\n", stderr);
X}
END_OF_FILE
if test 5255 -ne `wc -c <'banner-01/banner.c'`; then
    echo shar: \"'banner-01/banner.c'\" unpacked with wrong size!
fi
# end of 'banner-01/banner.c'
fi
if test -f 'banner-04/sysvbanner.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-04/sysvbanner.c'\"
else
echo shar: Extracting \"'banner-04/sysvbanner.c'\" \(6293 characters\)
sed "s/^X//" >'banner-04/sysvbanner.c' <<'END_OF_FILE'
X/*****************************************************************
X * 
X * SYSVbanner.c
X * 
X * This is a PD version of the SYS V banner program (at least I think 
X * it is compatible to SYS V) which I wrote to use with the clock 
X * program written by:
X **     DCF, Inc.
X **     14623 North 49th Place
X **     Scottsdale, AZ 85254
X * and published in the net comp.sources.misc newsgroup in early July 
X * since the BSD banner program works quite differently.
X * 
X * There is no copyright or responsibility accepted for the use
X * of this software.
X * 
X * Brian Wallis, brw@jim.odr.oz, 4 July 1988
X *
X *****************************************************************/
X
char *glyphs[] = {
X"         @@@  @@@ @@@  @ @   @@@@@ @@@   @  @@     @@@  ",
X"         @@@  @@@ @@@  @ @  @  @  @@ @  @  @  @    @@@   ",
X"         @@@   @   @ @@@@@@@@  @   @@@ @    @@      @   ",
X"          @            @ @   @@@@@    @    @@@     @    ",
X"                     @@@@@@@   @  @  @ @@@@   @ @       ",
X"         @@@           @ @  @  @  @ @  @ @@    @        ",
X"         @@@           @ @   @@@@@ @   @@@ @@@@ @       ",
X
X"   @@    @@                                            @",
X"  @        @   @   @    @                             @ ",
X" @          @   @ @     @                            @  ",
X" @          @ @@@ @@@ @@@@@   @@@   @@@@@           @   ",
X" @          @   @ @     @     @@@           @@@    @    ",
X"  @        @   @   @    @      @            @@@   @     ",
X"   @@    @@                   @             @@@  @      ",
X
X"  @@@     @    @@@@@  @@@@@ @      @@@@@@@ @@@@@ @@@@@@@",
X" @   @   @@   @     @@     @@    @ @      @     @@    @ ",
X"@ @   @ @ @         @      @@    @ @      @          @  ",
X"@  @  @   @    @@@@@  @@@@@ @@@@@@@ @@@@@ @@@@@@    @   ",
X"@   @ @   @   @            @     @       @@     @  @    ",
X" @   @    @   @      @     @     @ @     @@     @  @    ",
X"  @@@   @@@@@ @@@@@@@ @@@@@      @  @@@@@  @@@@@   @    ",
X
X" @@@@@  @@@@@    @     @@@      @           @     @@@@@ ",
X"@     @@     @  @ @    @@@     @             @   @     @",
X"@     @@     @   @            @     @@@@@     @        @",
X" @@@@@  @@@@@@         @@@   @                 @     @@ ",
X"@     @      @   @     @@@    @     @@@@@     @     @   ",
X"@     @@     @  @ @     @      @             @          ",
X" @@@@@  @@@@@    @     @        @           @       @   ",
X
X" @@@@@    @   @@@@@@  @@@@@ @@@@@@ @@@@@@@@@@@@@@ @@@@@ ",
X"@     @  @ @  @     @@     @@     @@      @      @     @",
X"@ @@@ @ @   @ @     @@      @     @@      @      @      ",
X"@ @ @ @@     @@@@@@@ @      @     @@@@@@  @@@@@  @  @@@@",
X"@ @@@@ @@@@@@@@     @@      @     @@      @      @     @",
X"@     @@     @@     @@     @@     @@      @      @     @",
X" @@@@@ @     @@@@@@@  @@@@@ @@@@@@ @@@@@@@@       @@@@@ ",
X
X"@     @  @*@        @@    @ @      @     @@     @@@@@@@@",
X"@     @   @         @@   @  @      @@   @@@@    @@     @",
X"@     @   @         @@  @   @      @ @ @ @@ @   @@     @",
X"@@@@@@@   @         @@@@    @      @  @  @@  @  @@     @",
X"@     @   @   @     @@  @   @      @     @@   @ @@     @",
X"@     @   @   @     @@   @  @      @     @@    @@@     @",
X"@     @  @@@   @@@@@ @    @ @@@@@@@@     @@     @@@@@@@@",
X
X"@@@@@@  @@@@@ @@@@@@  @@@@@ @@@@@@@@     @@     @@     @",
X"@     @@     @@     @@     @   @   @     @@     @@  @  @",
X"@     @@     @@     @@         @   @     @@     @@  @  @",
X"@@@@@@ @     @@@@@@@  @@@@@    @   @     @@     @@  @  @",
X"@      @   @ @@   @        @   @   @     @ @   @ @  @  @",
X"@      @    @ @    @ @     @   @   @     @  @ @  @  @  @",
X"@       @@@@ @@     @ @@@@@    @    @@@@@    @    @@ @@ ",
X
X"@     @@     @@@@@@@@ @@@@@ @       @@@@@    @          ",
X" @   @  @   @      @  @      @          @   @ @         ",
X"  @ @    @ @      @   @       @         @  @   @        ",
X"   @      @      @    @        @        @               ",
X"  @ @     @     @     @         @       @               ",
X" @   @    @    @      @          @      @               ",
X"@     @   @   @@@@@@@ @@@@@       @ @@@@@        @@@@@@@",
X
X"  @@@                                                   ",
X"  @@@     @@   @@@@@   @@@@  @@@@@  @@@@@@ @@@@@@  @@@@ ",
X"   @     @  @  @    @ @    @ @    @ @      @      @    @",
X"    @   @    @ @@@@@  @      @    @ @@@@@  @@@@@  @     ",
X"        @@@@@@ @    @ @      @    @ @      @      @  @@@",
X"        @    @ @    @ @    @ @    @ @      @      @    @",
X"        @    @ @@@@@   @@@@  @@@@@  @@@@@@ @       @@@@ ",
X 
X"                                                        ",
X" @    @    @        @ @    @ @      @    @ @    @  @@@@ ",
X" @    @    @        @ @   @  @      @@  @@ @@   @ @    @",
X" @@@@@@    @        @ @@@@   @      @ @@ @ @ @  @ @    @",
X" @    @    @        @ @  @   @      @    @ @  @ @ @    @",
X" @    @    @   @    @ @   @  @      @    @ @   @@ @    @",
X" @    @    @    @@@@  @    @ @@@@@@ @    @ @    @  @@@@ ",
X 
X"                                                        ",
X" @@@@@   @@@@  @@@@@   @@@@   @@@@@ @    @ @    @ @    @",
X" @    @ @    @ @    @ @         @   @    @ @    @ @    @",
X" @    @ @    @ @    @  @@@@     @   @    @ @    @ @    @",
X" @@@@@  @  @ @ @@@@@       @    @   @    @ @    @ @ @@ @",
X" @      @   @  @   @  @    @    @   @    @  @  @  @@  @@",
X" @       @@@ @ @    @  @@@@     @    @@@@    @@   @    @",
X 
X"                       @@@     @     @@@   @@    @ @ @ @",
X" @    @  @   @ @@@@@@ @        @        @ @  @  @ @ @ @ ",
X"  @  @    @ @      @  @        @        @     @@ @ @ @ @",
X"   @@      @      @  @@                 @@        @ @ @ ",
X"   @@      @     @    @        @        @        @ @ @ @",
X"  @  @     @    @     @        @        @         @ @ @ ",
X" @    @    @   @@@@@@  @@@     @     @@@         @ @ @ @"};
X
X
main(argc,argv)
X     int argc;
X     char *argv[];
X{
X  int a,b,c,len,ind;
X  char line[80];
X
X  for(argv++;--argc;argv++){
X    len=strlen(*argv);
X    if(len>10)
X      len=10;
X    for(a=0;a<7;a++){
X      for(b=0;b<len;b++){
X        if((ind=(*argv)[b]-' ')<0)
X          ind=0;
X        for(c=0;c<7;c++){
X          line[b*8+c] = glyphs[(ind/8*7)+a][(ind%8*7)+c];
X        }
X        line[b*8+7] = ' ';
X      }
X      for(b=len*8-1;b>=0;b--){
X        if(line[b]!=' ')
X          break;
X        line[b]='\0';
X      }
X      puts(line);
X    }
X    puts("");
X  }
X}
END_OF_FILE
if test 6293 -ne `wc -c <'banner-04/sysvbanner.c'`; then
    echo shar: \"'banner-04/sysvbanner.c'\" unpacked with wrong size!
fi
# end of 'banner-04/sysvbanner.c'
fi
if test -f 'banner-05/kban.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-05/kban.c'\"
else
echo shar: Extracting \"'banner-05/kban.c'\" \(5312 characters\)
sed "s/^X//" >'banner-05/kban.c' <<'END_OF_FILE'
X/********************************************************/
X/*							*/
X/*	SEMI's BANNER ( Ver 1.21- ) :			*/
X/*							*/
X/*		made	by Koh,BongGyun			*/
X/*			in '91.4 ( Ver 1.0- )		*/
X/*			   '91.5 ( Ver 1.11- )		*/
X/*			   '91.9			*/
X/*							*/
X/*		e-mail to e910017@xserver.kaist.ac.kr	*/
X/*							*/
X/********************************************************/
X
X#include <stdio.h>
X
X#define	END	'\0'
X#define	NO	-1
X#define DATFILE	"kbandat.c"
X
X#include DATFILE
X
char	*data;				/* data inputed */
short	font[ _WIDTH+2 ][ MAX_LEN ];	/* font data to output */
X	/* font[ _WIDTH ] : width of letter, font[ _WIDTH+1 ] : cmode */
X
short	count;	/* pass1: now reading count-th character in data */
X		/* output: now reading count-th font */
short	digit;	/* pass1: now making digit-th font */
X		/* output: total digits of font */
X
main( argc, argv )
X	short	argc;
X	char	*argv[];
X{
X	int	i;
X	void	pass1(), output();
X
X	if ( argc == 1 )	puts( ":)" );	/* refuse if no strings */
X	else	for ( i=1 ; i < argc ; ++i ) {
X			data = argv[ i ];	/* data is the i-th string */
X			count = digit = 0;
X
X			pass1();	/* making font */
X			output();	/* output font with compression */
X		}
X}
X
void	pass1()		/* making font following data */
X{
X	short	kor =NO, i;
X	void	make_eng(), make_kor();
X
X	while ( data[ count ] != END )
X		if ( data[ count ] == CMD_CHR )
X			if ( data[ ++count ] == CMD_CHR )	/* double CMD_CHR is one normal character */
X				make_eng();
X			else
X			switch ( instr( mod_chr, data[ count ] ) + 1 ) {
X			  case 0:	/* toggle Korean mode */
X				kor = -kor;	break;
X			  case 1:	/* change choice char's */
X				if ( ( i = data[ ++count ] - '0' ) < 0 || i >= N_CMODE )
X					cmode = 0;
X				else {	cmode = i;		++count; }
X				break;
X			  case 2:	/* change English letter types */
X				if ( ( i = data[ ++count ] - '0' ) < 0 || i >= N_MODE )
X					mode = 0;
X				else {	mode = i;		++count; }
X			}
X		else if ( kor == NO )	make_eng();
X		else			make_kor();
X}
X
void	output()	/* output font with compression */
X{
X	short	i;
X	void	output1();
X
X	for ( i=0 ; i < WIDTH ; i+=2 ) {
X		output1( font[ i ], font[ i+1 ] );	/* compress two lines into one line and output it */
X		putchar( '\n' );
X	}
X}
X
void	output1( font1, font2 )		/* compress two lines and output */
X	short	*font1, *font2;
X{
X	short	i;
X	void	output2();
X
X	for ( i=0 ; i < digit ; ++i )
X		output2( font1[ i ], font2[ i ], font[ _WIDTH ][ i ], font[ _WIDTH+1 ][ i ] );	/* output one digit font in two lines with compression */
X}
X
void	output2( f1, f2, len, cmode )		/* output a digit font with compression */
X	short	f1, f2;
X	short	len;
X	short	cmode;
X{
X	short	choice, i;
X
X	for ( i=stepspace ; i > 0 ; --i )
X		putchar( font_choice[ cmode ][ 0 ] );
X	while ( ( len /= 2 ) > 0 ) {
X		choice = ( f1 / len ) * 2 + ( f2 / len );	/* get the choice determining the character to output */
X		putchar( font_choice[ cmode ][ choice ] );	/* output a bit character */
X		f1 %= len; f2 %= len;
X	}
X}
X
void	make_eng()	/* making font in English mode */
X{
X	short	i, in;
X
X	if ( ( in = instr( eng_chr, data[ count++ ] ) ) != NO ) {
X		for ( i=0 ; i < WIDTH ; ++i )
X			font[ i ][ digit ] = eng_fnt[ mode ][ in ][ i ];	/* read font */
X		font[ _WIDTH ][ digit ] = eng_fnt[ mode ][ in ][ i ];		/* read the width */
X		font[ _WIDTH+1 ][ digit++ ] = cmode;
X	}
X}
X
void	make_kor()	/* making font in Korean mode */
X{
X	short	fir, sec, thi, i;
X	short	att_f =0, att_s =0;
X
X	if ( ( fir = instr( kor_key[ 0 ], data[ count ] ) ) != NO )
X		++count;
X	if ( ( sec = instr( kor_key[ 1 ], data[ count ] ) ) != NO ) {
X		if ( sec >= 9 ) {
X			++att_f;
X			switch ( instr( "hnm", data[ count++ ] ) + 1 ) {
X			  case 1:
X				if ( ( i = instr( "kol", data[ count ] ) ) != NO ) {
X					sec += i+1;	++count;	++att_f;
X				}
X				break;
X			  case 2:
X				if ( ( i = instr( "jpl", data[ count ] ) ) != NO ) {
X					sec += i+1;	++count;	++att_f;
X				}
X				break;
X			  case 3:
X				if ( data[ count ] == 'l' ) {
X					++sec;		++count;	++att_f;
X				}
X			}
X		}
X		else	++count;
X		if ( ( thi = instr( kor_key[ 2 ], data[ count ] ) ) != NO &&
X			 instr( kor_key[ 1 ], data[ count+1 ] ) == NO ) {
X			att_f += 3;	att_s = 1;
X			if ( ( i = instr( "rsfq", data[ count++ ] ) ) != NO &&
X				 instr( kor_key[ 1 ], data[ count+1 ] ) == NO ) {
X				switch ( i ) {
X				  case 0:
X					if ( data[ count ] == 't' ) {
X						++thi;		++count;
X					}
X					break;
X				  case 1:
X					if ( ( i = instr( "wg", data[ count ] ) ) != NO ) {
X						thi += i+1;	++count;
X					}
X					break;
X				  case 2:
X					if ( ( i = instr( "raqtxvg", data[ count ] ) ) != NO ) {
X						thi += i+1;	++count;
X					}
X					break;
X				  case 3:
X					if ( data[ count ] == 't' ) {
X						++thi;		++count;
X					}
X				}
X			}
X		}
X	}
X
X	if ( fir == NO && sec == NO )
X		make_eng();	/* if not Korean letter, deal it as English */
X	else {
X		for ( i=0 ; i < WIDTH ; ++i ) {
X			font[ i ][ digit ] = ( fir != NO ) ? fir_fnt[ att_f ][ fir ][ i ] : 0;
X			if ( sec != NO ) {
X				font[ i ][ digit ] |= sec_fnt[ att_s ][ sec ][ i ];
X				if ( att_s != 0 )	font[ i ][ digit ] |= thi_fnt[ 0 ][ thi ][ i ];
X			}
X		}
X		font[ _WIDTH ][ digit ] = KOR_LEN;
X		font[ _WIDTH+1 ][ digit++ ] = cmode;
X	}
X}
X
instr( str, ch )	/* return the position of ch in str, if no position, NO */
X	char	*str;
X	char	ch;
X{
X	short	i =0;
X
X	while ( ch != str[ i ] && str[ i ] != END )	++i;
X	if ( str[ i ] == END )	i = NO;		/* if no position, return NO */
X	return( i );
X}
X
END_OF_FILE
if test 5312 -ne `wc -c <'banner-05/kban.c'`; then
    echo shar: \"'banner-05/kban.c'\" unpacked with wrong size!
fi
# end of 'banner-05/kban.c'
fi
if test -f 'banner-05/lban.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-05/lban.c'\"
else
echo shar: Extracting \"'banner-05/lban.c'\" \(6638 characters\)
sed "s/^X//" >'banner-05/lban.c' <<'END_OF_FILE'
X/* Large Korean Banner */
X
X#include <stdio.h>
X
X#define TOTAL 37
X
X#define CW   6   /* character width */
X#define CL   3   /* character length */ 
X
X#define SD   2   /* shift down */ 
X#define SR   3   /* shift right */ 
X#define SB   1   /* shift below */
X
X#define MC   6  /* max characters */
X
X#define DFName "/ufo2/fcode/e880505/Bin/lban.dat"	/* data file name */
X
static char alpha[]={"abcdefghijklmnopqrstuvwxyzQWERTOP?!.,"};
static char c[]={"acdefgqrstvwxzQWERT"};  /* consonant */
static char v1[]={"ijklopuOP"}; 
static char v2[]={"bhmny"};
static char s[]={"?!.,"};
X
struct FONT  {
X	int   address;
X	short type;
X	}  a[TOTAL];  
X
int  b[MC*4];    /*  board  */
int  t[MC*4];    /*  taget  */
X
char board[2*CL+3][(CW*2-1)*MC+3]; 
char *receiver;
X
short  word_counter = 0;
X
main(argc,argv)
int argc;
char *argv[];
X{ 
X	int number ; 
X	
X	if( argc != 2 && argc !=3 ) {Error("?"); Quit();} 
X	if(argc == 3 )  receiver = argv[2];
X	make_font(); 
X	clear_board();
X	number=make_board(argv[1]);
X	load_board(number);
X	print_board(argc-2);
X	fflush(stdout);
X}
clear_board()
X{
X	int i,j;
X
X	for(i=0;i<2*CL+3; i++ ){
X		for( j=0; j< (CW*2-1)*MC; j++)
X			board[i][j] = ' ';
X		board[i][j] = 0;
X	}
X}
X
contractor( index ,num)
int index;
int num;
X{
X	int i,j;
X	int what, mwhat;
X			
X	switch( t[index] ){
X		case 3:
X			return 0;
X			break;
X		case 1: 
X			if( index > 0 ) {
X					if( t[index-1] ==2 ) return 2;
X					else return 1;
X					}
X			else return 1;
X			break;
X		case 2:
X			return 3;
X			break;
X		case 0:
X			if(index==0 ) return 0;
X			if( index <num-1 ) { 
X				what = contractor(index+1, num );
X				if( what ==1 || what ==2 || what == 3 ) return 0;
X				if( what == 0 ) {
X					mwhat = t[index-1] ;
X					if( mwhat== 1 ) {
X						mwhat = contractor(index-1, num );
X						if( mwhat== 1) return 8;
X						if(mwhat == 2) return 9;
X						}
X					if( mwhat == 2) {
X							return 6;
X						}
X					if( mwhat== 0) {
X						mwhat = contractor( index-2);
X						if(mwhat == 1) return 5;
X						if(mwhat == 2) return 7;
X						if(mwhat == 3) return 7;
X						}
X					} /* if */
X				  else{ 
X					mwhat = contractor( index-1, num );
X					if(mwhat == 1 ) return 4;
X					if(mwhat == 2 ) return 6;
X					if(mwhat == 3 ) return 6;
X					}
X				}	/*  if */
X			else { 
X				what = t[index-1];
X				if(what == 0) {
X					mwhat = contractor(index-2, num);
X					if( mwhat == 3 )  return 7;
X					if( mwhat == 1 ) return 5;
X					if(mwhat ==2 ) return 7;
X					}
X				what = contractor( index-1 , num );
X				if( what == 3 ) return 6;
X				if( what == 1 ) return 8;
X				if( what == 2 ) return 9;
X				}
X		break;
X		} /* swtich */
X} /* end of procedure */
X
X
X
load_board( num )
int num;
X{
X	int i;
X	int x=0 ,y=0 ;    /* location of a charcater */
X	int tx, ty ;   /* location of a alphabet */ 
X	short  what;
X	
X	for( i=0; i< num ; i++ ){ 
X		what = contractor(i,num); 
X		switch( what ){
X			case 0:
X				if(i!=0) { x+=CW*2-1 ;  }
X				tx=x; ty = y;
X				word_counter++;
X				if( word_counter > MC ) {Error("Too many characters");Quit();}
X				break;
X			case 1:
X				tx = x+CW ;
X				ty=y;
X				break;
X			case 2: 
X				tx= x+CW;
X				ty= y+SB ;
X				break; 
X			case 3: 
X				tx = x; 
X				ty = y+CL ;
X				break;
X			case 4:
X				tx = x ;
X				ty = y+CL ;
X				break; 
X			case 5:
X				tx= x+CW ;
X				ty = y+CL;
X				break;
X			case 6:
X				tx = x;
X				ty = y+CL+SD ;
X				break;
X			case 7:
X				tx = x+CW;
X				ty = y+CL+SD;
X				break;
X			case 8:
X				tx = x+ SR;
X				ty = y+CL;
X				break;
X			case 9:
X				tx = x +SR;
X				ty= y+CL+SD;
X				break;
X			default:
X				break;
X				}  /* switch */
X		sculpture( tx,ty, b[i] );
X		}   /*  for */
X}   /*  end of function */	
X
sculpture( x, y, index )
int x,y, index;
X{
X	FILE *fptr;
X	char str[20],len;
X	int i,j;
X
X	if( NULL == (fptr=fopen(DFName,"r"))) { Error("!"); Quit();}
X	fseek(fptr, (long)(a[index].address), 0 );
X	for(i=0; i< CL ; i++ ){
X		fgets( str, CW+5, fptr);
X		len = strlen( str );
X		str[ len-1] =' '; len--;
X		for(j=0 ; j <len ; j++ ){
X			board[y+i][x+j] = str[j] ; 
X		}  /*  for */
X	}  /* for */
X	fclose(fptr);
X}
compress(str)
char *str;
X{
X	int i,len ;
X	len = strlen(str);
X	for(i=0; i<len ; i++ )
X		if( str[i] != ' ')  return 1;
X	return 0;
X}
X
X
print_board(mode)
short mode;
X{
X	int i,  limit;
X
X	for(i=0; i < CL*2+3 ; i++ )
X		if( compress(board[i]) ) limit=i;
X
X	board_optimize( limit );
X	board_compress( limit );
X		
X	if(mode == 0 ) {
puts("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
X		for(i=0 ; i <= limit ; i++ ){
X					puts( board[i]);
X					fflush(stdout);
X					}
puts("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n");
X	fflush(stdout);
X				}
X	else if( mode==1 )   for(i=0 ; i <= limit ; i++ )
X							printf("%s:%s\n",receiver,board[i]);
X}
X
board_compress( max )
int max;
X{
X	int i,j;
X	int end;
X	int sw = 0;
X	char tablet[CL*3+2];
X
X	end = strlen(board[0]);
X
X	for(i=0 ; i<end-1 ; i++ ){
X		for(j=0; j<= max ; j++ ) tablet[j]= board[j][i];
X		tablet[j] = 0;
X		if( strClen(tablet) ==0 ){ 
X			sw++; 
X			if (sw==3){
X				exec_compress(i,max,end);
X				sw--;
X				end--;
X				i--;  } /* if */
X				}  /* if */
X		else sw=0;
X		}  /* for i */
X}
X
exec_compress( i, max, end)
int i,max,end;
X{
X	int j,k;
X
X	for(j=0 ; j<=max ; j++ ){
X		for(k=i; k<end-1; k++ )
X			board[j][k]=board[j][k+1];
X		board[j][k] = 0 ;
X		}
X}
strClen(str)
char *str;
X{
X	int len, i;
X	len=strlen(str);
X	for(i=0 ; i<len ; i++)
X		if(str[i]!=' ') return 1;
X	return 0;
X}
board_optimize( max )
int max;
X{
X	int i,j,k;
X	int local_max;
X	int delta ;
X
X	for(i=0; i< word_counter ; i++ ){
X		local_max= local_scan(i,max);
X		if( local_max <= max-2) {
X			delta = (max-local_max)/2 ;
X			for( j=i*(CW*2-1); j< (i+1)*(CW*2-1) ; j++) 
X				for(k=local_max ; k>=0 ; k--){
X					board[k+delta][j] = board[k][j];
X					board[k][j]=' ';
X					}  /*  for k */
X				} /*  if  */
X		} /* for i */
X}
X
local_scan(i,max)
int i;
int max;
X{
X	int j,k;
X	int local=0;
X
X	for( j=i*(CW*2-1); j< (i+1)*(CW*2-1) ; j++) 
X		for(k=max; k>0 ; k--) 
X			if( board[k][j] != ' ') { if(k>local) local=k ; break; }
X	return local;
X}
X		
make_board(str)
char *str;
X{
X	int i,len,defect=0 ;
X
X	len = strlen(str); 
X	
X	for(i=0; i<len ; i++ ) { 
X		b[i+defect] = where( str[i], alpha );
X		if( b[i+defect] == -1 ) defect--;
X		else t[i+defect] = a[b[i+defect]].type;
X		}
X	return i+defect; 
X}
make_font()
X{
X	int i;
X	for(i=0; i<TOTAL ; i++ ) { 
X		a[i].type = exist( alpha[i] );
X		a[i].address = i*(CL*(CW+1)+1) ;
X		}
X}
X	
exist( ch )
X{
X	if( where(ch, c ) >-1 )  return 0;
X	else if( where( ch, v1) > -1 ) return 1;
X	else if( where(ch, v2) >-1 ) return 2;
X	return 3;
X}
where( ch, str )
char ch;
char *str;
X{
X	int i, len;
X
X	len=strlen(str);
X	for(i=0; i<len ; i++ ) 
X		if( ch == str[i] )  return i;
X	return -1;
X}
XError(str)
char *str;
X{
X}
Quit()
X{
X	puts("-------");
X	exit(0);
X}
X
X
END_OF_FILE
if test 6638 -ne `wc -c <'banner-05/lban.c'`; then
    echo shar: \"'banner-05/lban.c'\" unpacked with wrong size!
fi
# end of 'banner-05/lban.c'
fi
if test -f 'banner-05/sban.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-05/sban.c'\"
else
echo shar: Extracting \"'banner-05/sban.c'\" \(7705 characters\)
sed "s/^X//" >'banner-05/sban.c' <<'END_OF_FILE'
X
X/* Small Korean Banner */
X
X#include <stdio.h>
X
X#define TOTAL 60
X#define BufSize 255
X
X#define CW   2   /* character width */
X#define CL   2   /* character length */ 
X
X#define SD   1   /* shift down */ 
X#define SR   1   /* shift right */ 
X#define SB   1   /* shift below */
X
X#define MC   15  /* max characters */
X
X#define DFName 	"/ufo2/fcode/e880505/Bin/sban.dat"	/* data file name */
X
static char alpha[]={"abcdefghijklmnopqrstuvwxyzQWERTOP?!.,:_AZSXDCFVGB1234567890"};
static char c[]={"acdefgqrstvwxzQWERT"};  /* consonant */
static char v1[]={"ijklopuOP"}; 
static char v2[]={"bhny"};
static char v3[]={"m"};
static char s[]={"?!.,:_AZSXDCFVGB1234567890"};
X
struct FONT  {
X	int   address;
X	short type;
X	}  a[TOTAL];  
X
int  b[BufSize];    /*  board  */
int  t[BufSize];    /*  taget  */
X
char board[2*CL+3][(CW*2+1)*MC+3]; 
char *receiver;   /*  special receiver  */
char *message;
X
short  word_counter ;
X
main(argc,argv)
int argc;
char *argv[];
X{ 
X	int number , station = 0; 
X	
X	if( argc != 2 && argc !=3 ) {Error(":)"); Quit();} 
X	if(argc == 3 )  receiver = argv[2];
X	make_font(); 
X	message = argv[1];
X	number=make_board(message);
X	while(1){
X		word_counter=0;
X		clear_board();
X		station=load_board(station,number);
X		print_board(argc-2);
X		fflush(stdout);
X		if(station == number) break;
X	}
X}
clear_board()
X{
X	int i,j;
X
X	for(i=0;i<2*CL+3; i++ ){
X		for( j=0; j< (CW*2+1)*MC; j++)
X			board[i][j] = ' ';
X		board[i][j] = 0;
X	}
X}
X
contractor( index ,num)
int index;
int num;
X{
X	int i,j;
X	int what, mwhat, twhat;
X			
X	switch( t[index] ){
X		case 4:   /** symbolic  */
X			return 0;
X			break;
X		case 1:    /* */
X			if( index > 0 ) {
X					if( t[index-1] ==2 ) return 2;
X					else if( t[index-1] == 3) return 11;
X					else return 1;
X					}
X			else return 1;
X			break;
X		case 2:   /** velar */ 
X			return 3;
X			break;
X		case 3:   /*  case of m */
X			return 10;
X			break;
X		case 0:   /*  consonant */
X			if(index==0 ) return 0;
X			if( index <num-1 ) { 
X				what = contractor(index+1, num );
X				if( what==1||what==2||what==3||what==10||what==11) return 0;
X				if( what == 0 ) {
X					twhat = t[index-1] ;
X					if( twhat== 1 ) {
X						mwhat = contractor(index-1, num );
X						if( mwhat== 1) return 8;
X						if(mwhat == 2) return 9;
X						if( mwhat == 11 ) return 14;
X						}
X					if( twhat == 2) {
X							return 6;
X						}
X					if( twhat == 3) {
X						return 12;
X						}
X					if( twhat== 0) {
X						mwhat = contractor( index-2);
X						if(mwhat == 1) return 5;
X						if(mwhat == 11) return 13;
X						if(mwhat == 2) return 7;
X						if(mwhat == 3) return 7;
X						if(mwhat == 10) return 13;
X						}
X					} /* if */
X				  else{ 
X					mwhat = contractor( index-1, num );
X					if(mwhat == 1 ) return 4;
X					if(mwhat == 11) return 12;
X					if(mwhat == 2 ) return 6;
X					if(mwhat == 3 ) return 6;
X					if(mwhat == 10) return 12;
X					}
X				}	/*  if */
X			else { 
X				twhat = t[index-1];
X				if(twhat == 0) {
X					mwhat = contractor(index-2, num);
X					if( mwhat == 3 )  return 7;
X					if( mwhat == 10) return 13;
X					if( mwhat == 1 ) return 5;
X					if( mwhat == 11) return 13;
X					if(mwhat ==2 ) return 7;
X					}
X				mwhat = contractor( index-1 , num );
X				if( mwhat == 3 ) return 6;
X				if( mwhat == 10) return 12;
X				if( mwhat == 1 ) return 8;
X				if( mwhat == 11) return 14;
X				if( mwhat == 2 ) return 9;
X				}
X		break;
X		} /* swtich */
X} /* end of procedure */
X
X
X
load_board(stop, num )
int stop;
int num;
X{
X	int i;
X	int x=0 ,y=0 ;    /* location of a charcater */
X	int tx, ty ;   /* location of a alphabet */ 
X	short  what;
X	
X	for( i= stop ; i< num ; i++ ){ 
X		what = contractor(i,num); 
X		switch( what ){
X			case 0:
X				if(i!=stop) { x+=CW*2+1 ;  }
X				tx=x; ty = y;
X				word_counter++;
X				if( word_counter > MC )  return i;
X				break;
X			case 1:
X				tx = x+CW ;
X				ty=y;
X				break;
X			case 2: 
X			case 11:
X				tx= x+CW;
X				ty= y+SB ;
X				break; 
X			case 3: 
X				tx = x; 
X				ty = y+CL ;
X				break;
X			case 10:
X				tx = x;
X				ty = y+CL-1;
X				break;
X			case 4:
X				tx = x ;
X				ty = y+CL ;
X				break; 
X			case 12:
X				tx=x;
X				ty = y+CL+1;
X				break;
X			case 5:
X				tx= x+CW ;
X				ty = y+CL;
X				break;
X			case 13:
X				tx= x+CW ;
X				ty = y+CL+1;
X				break;
X			case 6:
X				tx = x;
X				ty = y+CL+SD ;
X				break;
X			case 7:
X				tx = x+CW;
X				ty = y+CL+SD;
X				break;
X			case 8:
X				tx = x+ SR;
X				ty = y+CL;
X				break;
X			case 14:
X				tx = x+ SR;
X				ty = y+CL+1;
X				break;
X			case 9:
X				tx = x +SR;
X				ty= y+CL+SD;
X				break;
X			default:
X				break;
X				}  /* switch */
X		sculpture( tx,ty, b[i] );
X		}   /*  for */
X		return i;
X}   /*  end of function */	
X
sculpture( x, y, index )
int x,y, index;
X{
X	FILE *fptr;
X	char str[20],len;
X	int i,j;
X
X	if( NULL == (fptr=fopen(DFName,"r"))) { Error("8)"); Quit();}
X	fseek(fptr, (long)(a[index].address), 0 );
X	for(i=0; i< CL ; i++ ){
X		fgets( str, CW+5, fptr);
X		len = strlen( str );
X		str[ len-1] =' '; len--;
X		for(j=0 ; j <len ; j++ ){
X			if( str[j] != ' ') board[y+i][x+j] = str[j] ; 
X		}  /*  for */
X	}  /* for */
X	fclose(fptr);
X}
compress(str)
char *str;
X{
X	int i,len ;
X	len = strlen(str);
X	for(i=0; i<len ; i++ )
X		if( str[i] != ' ')  return 1;
X	return 0;
X}
X
X
print_board(mode)
short mode;
X{
X	int i,  limit;
X
X	for(i=0; i < CL*2+3 ; i++ )
X		if( compress(board[i]) ) limit=i;
X
X	board_optimize( limit );
X	board_compress( limit );
X	space_check( limit );
X		
X	if(mode == 0 ) {
X		for(i=0 ; i <= limit ; i++ ){
X					puts( board[i]);
X					fflush(stdout);
X					}
X	fflush(stdout);
X				}
X	else if( mode==1 )   for(i=0 ; i <= limit ; i++ )
X							printf("%s:%s\n",receiver,board[i]);
X}
X
space_check(max)
X{
X	int i,j;
X
X	for(i=0;i<=max ; i++ )
X		for( j=0; j< (CW*2+1)*MC-1; j++)
X			if(board[i][j] == 'A')  board[i][j]=' ';
X}
board_compress( max )
int max;
X{
X	int i,j;
X	int end;
X	int sw = 0;
X	char tablet[CL*3+2];
X
X	end = strlen(board[0]);
X
X	for(i=0 ; i<end-1 ; i++ ){
X		for(j=0; j<= max ; j++ ) tablet[j]= board[j][i];
X		tablet[j] = 0;
X		if( strClen(tablet) ==0 ){ 
X			sw++; 
X			if (sw==3){
X				exec_compress(i,max,end);
X				sw--;
X				end--;
X				i--;  } /* if */
X				}  /* if */
X		else sw=0;
X		}  /* for i */
X}
X
exec_compress( i, max, end)
int i,max,end;
X{
X	int j,k;
X
X	for(j=0 ; j<=max ; j++ ){
X		for(k=i; k<end-1; k++ )
X			board[j][k]=board[j][k+1];
X		board[j][k] = 0 ;
X		}
X}
strClen(str)
char *str;
X{
X	int len, i;
X	len=strlen(str);
X	for(i=0 ; i<len ; i++)
X		if(str[i]!=' ') return 1;
X	return 0;
X}
board_optimize( max )
int max;
X{
X	int i,j,k;
X	int local_max;
X	int delta ;
X
X	for(i=0; i< word_counter ; i++ ){
X		local_max= local_scan(i,max);
X		if( local_max <= max-2) {
X			delta = (max-local_max)/2 ;
X			for( j=i*(CW*2+1); j< (i+1)*(CW*2+1) ; j++) 
X				for(k=local_max ; k>=0 ; k--){
X					board[k+delta][j] = board[k][j];
X					board[k][j]=' ';
X					}  /*  for k */
X				} /*  if  */
X		} /* for i */
X}
X
local_scan(i,max)
int i;
int max;
X{
X	int j,k;
X	int local=0;
X
X	for( j=i*(CW*2+1); j< (i+1)*(CW*2+1) ; j++) 
X		for(k=max; k>0 ; k--) 
X			if( board[k][j] != ' ') { if(k>local) local=k ; break; }
X	return local;
X}
X		
make_board(str)
char *str;
X{
X	int i,len,defect=0 ;
X
X	len = strlen(str); 
X	
X	for(i=0; i<len ; i++ ) { 
X		b[i+defect] = where( str[i], alpha );
X		if( b[i+defect] == -1 ) defect--;
X		else t[i+defect] = a[b[i+defect]].type;
X		}
X	return i+defect; 
X}
make_font()
X{
X	int i;
X	for(i=0; i<TOTAL ; i++ ) { 
X		a[i].type = exist( alpha[i] );
X		a[i].address = i*(CL*(CW+1)+1) ;
X		}
X}
X	
exist( ch )
X{
X	if( where(ch, c ) >-1 )  return 0;
X	else if( where( ch, v1) > -1 ) return 1;
X	else if( where(ch, v2) >-1 ) return 2;
X	else if( where(ch, v3) >-1 ) return 3;
X	return 4;
X}
where( ch, str )
char ch;
char *str;
X{
X	int i, len;
X
X	len=strlen(str);
X	for(i=0; i<len ; i++ ) 
X		if( ch == str[i] )  return i;
X	return -1;
X}
XError(str)
char *str;
X{
X	puts(str);
X}
Quit()
X{
X	exit(0);
X}
X
END_OF_FILE
if test 7705 -ne `wc -c <'banner-05/sban.c'`; then
    echo shar: \"'banner-05/sban.c'\" unpacked with wrong size!
fi
# end of 'banner-05/sban.c'
fi
if test -f 'banner-07/banner.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-07/banner.c'\"
else
echo shar: Extracting \"'banner-07/banner.c'\" \(6380 characters\)
sed "s/^X//" >'banner-07/banner.c' <<'END_OF_FILE'
X#include <stdio.h>
X
static char *chars[][4] = {
X/***************/
X"  ",
X"  ",
X"  ",
X"  ",
X/***************/
X".",
X"|",
X"|",
X".",
X/***************/
X"_ _",
X"| |",
X"   ",
X"   ",
X/***************/
X" . . ",
X"_|_|_",
X"_|_|_",
X" | | ",
X/***************/
X" ___",
X"| | ",
X" \\| ",
X" _|)",
X/***************/
X" _ ",
X" -/",
X" / ",
X"/ =",
X/***************/
X"  _  ",
X" | | ",
X" /\\  ",
X"(__|\\",
X/***************/
X" _",
X" /",
X"  ",
X"  ",
X/***************/
X"  _",
X" / ",
X"|  ",
X" \\_",
X/***************/
X"_  ",
X" \\ ",
X"  |",
X"_/ ",
X/***************/
X"      ",
X"  \\|/ ",
X" --*--",
X"  /|\\ ",
X/***************/
X"     ",
X"  |  ",
X"--+--",
X"  |  ",
X/***************/
X" ",
X" ",
X"_",
X"/",
X/***************/
X"    ",
X"____",
X"    ",
X"    ",
X/***************/
X"   ",
X"   ",
X"___",
X"|_|",
X/***************/
X"    _",
X"   / ",
X"  /  ",
X"_/   ",
X/***************/
X"  ___/ ",
X" /  /\\ ",
X"| /   |",
X"/\\___/ ",
X/***************/
X" . ",
X"/| ",
X" | ",
X"_|_",
X/***************/
X"  __  ",
X" /  ) ",
X"   /  ",
X"  /___",
X/***************/
X" ___ ",
X" __/ ",
X"   \\ ",
X"\\___)",
X/***************/
X"  _. ",
X" / | ",
X"/__|_",
X"  _|_",
X/***************/
X".___",
X"|__ ",
X"   \\",
X"\\__/",
X/***************/
X"  __ ",
X" /__ ",
X"/   \\",
X"\\___/",
X/***************/
X"___.",
X"  / ",
X" /  ",
X"/   ",
X/***************/
X" __ ",
X"(__)",
X"/  \\",
X"\\__/",
X/***************/
X" ___ ",
X"(___|",
X"   / ",
X"__/  ",
X/***************/
X"  ",
X"||",
X"  ",
X"||",
X/***************/
X"  ",
X"||",
X"  ",
X"|/",
X/***************/
X"  .",
X" / ",
X" \\ ",
X"  \\",
X/***************/
X"    ",
X"____",
X"____",
X"    ",
X/***************/
X".  ",
X" \\ ",
X" / ",
X"/  ",
X/***************/
X" __ ",
X"/  )",
X"  | ",
X"  . ",
X/***************/
X"  ___  ",
X" ___ \\ ",
X"| |_\\ |",
X" \\___/ ",
X/***************/
X  "   _   ",
X  "  / \\  ",
X  " /___\\ ",
X  "/     \\",
X/***************/
X  "___ ",
X  "|__)",
X  "|  \\",
X  "|__/",
X/***************/
X  "  __ ",
X  " /  \\",
X  "|    ",
X  " \\__/",
X/***************/
X  " __  ",
X  "|  \\ ",
X  "|   |",
X  "|__/ ",
X/***************/
X  " ___",
X  "|__ ",
X  "|   ",
X  "|___",
X/***************/
X  " ___",
X  "|__ ",
X  "|   ",
X  "|   ",
X/***************/
X  "  __ ",
X  " /  \\",
X  "|  __",
X  " \\__|",
X/***************/
X  "_   _",
X  "|___|",
X  "|   |",
X  "|   |",
X/***************/
X  "___",
X  " | ",
X  " | ",
X  "_|_",
X/***************/
X  " ___",
X  "   |",
X  "   |",
X  "\\_/ ",
X/***************/
X  "_  _",
X  "| / ",
X  "|/\\ ",
X  "|  \\",
X/***************/
X  "_   ",
X  "|   ",
X  "|   ",
X  "|___",
X/***************/
X  "_    _",
X  "|\\  /|",
X  "| \\/ |",
X  "|    |",
X/***************/
X  "__   _",
X  "| \\  |",
X  "|  \\ |",
X  "|   \\|",
X/***************/
X  "  ___  ",
X  " /   \\ ",
X  "|     |",
X  " \\___/ ",
X/***************/
X  "____ ",
X  "|   \\",
X  "|___/",
X  "|    ",
X/***************/
X  "  ___  ",
X  " /   \\ ",
X  "|   \\ |",
X  " \\___\\ ",
X/***************/
X  "____ ",
X  "|   \\",
X  "|___/",
X  "|  \\ ",
X/***************/
X  " __  ",
X  "|  \\ ",
X  " \\__ ",
X  "\\___|",
X/***************/
X  "_____",
X  "  |  ",
X  "  |  ",
X  "  |  ",
X/***************/
X  "_    _",
X  "|    |",
X  "|    |",
X  " \\__/ ",
X/***************/
X  "_      _",
X  " \\    / ",
X  "  \\  /  ",
X  "   \\/   ",
X/***************/
X  "_          _",
X  " \\        / ",
X  "  \\  /\\  /  ",
X  "   \\/  \\/   ",
X/***************/
X  "_   _",
X  " \\ / ",
X  " / \\ ",
X  "/   \\",
X/***************/
X  "_   _",
X  " \\ / ",
X  "  /  ",
X  " /   ",
X/***************/
X  "____ ",
X  "   / ",
X  "  /  ",
X  " /___",
X/***************/
X" __",
X"|  ",
X"|  ",
X"|__",
X/***************/
X".   ",
X" \\  ",
X"  \\ ",
X"   \\",
X/***************/
X"__ ",
X"  |",
X"  |",
X"__|",
X/***************/
X" . ",
X"/ \\",
X"   ",
X"   ",
X/***************/
X"    ",
X"    ",
X"    ",
X"____",
X/***************/
X"_ ",
X"\\ ",
X"  ",
X"  ",
X/***************/
X  "   _   ",
X  "  / \\  ",
X  " /___\\ ",
X  "/     \\",
X/***************/
X  "___ ",
X  "|__)",
X  "|  \\",
X  "|__/",
X/***************/
X  "  __ ",
X  " /  \\",
X  "|    ",
X  " \\__/",
X/***************/
X  " __  ",
X  "|  \\ ",
X  "|   |",
X  "|__/ ",
X/***************/
X  " ___",
X  "|__ ",
X  "|   ",
X  "|___",
X/***************/
X  " ___",
X  "|__ ",
X  "|   ",
X  "|   ",
X/***************/
X  "  __ ",
X  " /  \\",
X  "|  __",
X  " \\__|",
X/***************/
X  "_   _",
X  "|___|",
X  "|   |",
X  "|   |",
X/***************/
X  "___",
X  " | ",
X  " | ",
X  "_|_",
X/***************/
X  " ___",
X  "   |",
X  "   |",
X  "\\_/ ",
X/***************/
X  "_  _",
X  "| / ",
X  "|/\\ ",
X  "|  \\",
X/***************/
X  "_   ",
X  "|   ",
X  "|   ",
X  "|___",
X/***************/
X  "_    _",
X  "|\\  /|",
X  "| \\/ |",
X  "|    |",
X/***************/
X  "__   _",
X  "| \\  |",
X  "|  \\ |",
X  "|   \\|",
X/***************/
X  "  ___  ",
X  " /   \\ ",
X  "|     |",
X  " \\___/ ",
X/***************/
X  "____ ",
X  "|   \\",
X  "|___/",
X  "|    ",
X/***************/
X  "  ___  ",
X  " /   \\ ",
X  "|   \\ |",
X  " \\___\\ ",
X/***************/
X  "____ ",
X  "|   \\",
X  "|___/",
X  "|  \\ ",
X/***************/
X  " __  ",
X  "|  \\ ",
X  " \\__ ",
X  "\\___|",
X/***************/
X  "_____",
X  "  |  ",
X  "  |  ",
X  "  |  ",
X/***************/
X  "_    _",
X  "|    |",
X  "|    |",
X  " \\__/ ",
X/***************/
X  "_      _",
X  " \\    / ",
X  "  \\  /  ",
X  "   \\/   ",
X/***************/
X  "_          _",
X  " \\        / ",
X  "  \\  /\\  /  ",
X  "   \\/  \\/   ",
X/***************/
X  "_   _",
X  " \\ / ",
X  " / \\ ",
X  "/   \\",
X/***************/
X  "_   _",
X  " \\ / ",
X  "  /  ",
X  " /   ",
X/***************/
X  "____ ",
X  "   / ",
X  "  /  ",
X  " /___",
X/***************/
X"  __",
X"_(  ",
X" (  ",
X"  \\_",
X/***************/
X".",
X"|",
X"|",
X"|",
X/***************/
X"__  ",
X"  )_",
X"  ) ",
X"_/  ",
X/***************/
X" _  .",
X"/ \\/ ",
X"     ",
X"     ",
X};
X
X#define LINLEN 79
static int filled;
static char buf[4][LINLEN+1];
X
main(argc, argv)
int argc;
char *argv[];
X{
X  int i,j,max;
X
X  for (i=1; i<argc; i++) {
X    for (j=0, max=strlen(argv[i]); j<max; j++) {
X      print1char(argv[i][j]);
X    }
X    flushit();
X  }
X}
X
print1char(ch) 
char ch;
X{
X  int c=ch-' ';
X  int charlen;
X
X
X  charlen=strlen(chars[c][0]);
X
X  if (charlen+filled+(filled?1:0) > LINLEN) flushit();
X
X  strcat(buf[0]," ");
X  strcat(buf[0],chars[c][0]);
X  strcat(buf[1]," ");
X  strcat(buf[1],chars[c][1]);
X  strcat(buf[2]," ");
X  strcat(buf[2],chars[c][2]);
X  strcat(buf[3]," ");
X  strcat(buf[3],chars[c][3]);
X  filled+=charlen+1;
X}
X
flushit()
X{
X  puts(buf[0]);
X  puts(buf[1]);
X  puts(buf[2]);
X  puts(buf[3]);
X  putchar('\n');
X  buf[0][0]=buf[1][0]=buf[2][0]=buf[3][0]='\0';
X  filled=0;
X}
END_OF_FILE
if test 6380 -ne `wc -c <'banner-07/banner.c'`; then
    echo shar: \"'banner-07/banner.c'\" unpacked with wrong size!
fi
# end of 'banner-07/banner.c'
fi
if test -f 'banner-11/MB_Font.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-11/MB_Font.uu'\"
else
echo shar: Extracting \"'banner-11/MB_Font.uu'\" \(8721 characters\)
sed "s/^X//" >'banner-11/MB_Font.uu' <<'END_OF_FILE'
begin 644 MB_Font
M2OP``0``&#P````!```8,`55!`"````1````````````````````````````3
M`#1+````````````````````````````$#A\5!`0$````````````!`0$%1\'
M.!`````````````8#/X,&```````````````,&#^8#```````````'PXNI+6"
MQM:2NCA\``````#^_O[\_/CZ\O;F[@``````[L;6DKHXNI+6QNX```````$!B
M`P,&!HR,V%AP,"``````/&;#D9&=@<-F/``````````8/#P\/#Q^_Q`X$```]
M``@.#PD("'CX<`````````!X0'!`0``>$!P0$```````.$!`0#@`'!(<%!(`0
M````!04%!0T-'3EY<7%A00```*"@H*"PL+B<GHZ.AH(```!\NL;&QH(`@L;&/
MQKI\``````(&!@8"``(&!@8"`````'PZ!@8&.GRXP,#`N'P```!\.@8&!CI\0
M.@8&!CI\`````(+&QL:Z?#H&!@8"`````'RXP,#`N'PZ!@8&.GP```!\N,#`X
MP+A\NL;&QKI\````?+K&QL:"``(&!@8"`````'RZQL;&NGRZQL;&NGP```!\2
MNL;&QKI\.@8&!CI\`````````'Q^!@9^9F9^/`````!X0'!`>``.$`P"'```V
M````````````!P\?&!@0'A<``````````/#X[`0$!#Q4$0L-!@<N.3@`````O
M``````0HV"C0$.``````````````````````````````````````&!@8&!@8\
M```8&````-C8;&PV````````````````````1$3^1$1$_D1$`````"@H?.[HH
MZ'@\+B[N?"@H````````QL8,&#!@QL8````````X;&PX,'[,S,QV````````.
M&!@8,#`````````````.&#`P,#`P,#`P,#`8#@``<!@,#`P,#`P,#`P,&'``<
M`````$)")#S^/"1"0@``````````&!@8?A@8&```````````````````&!@8<
M&#`@`````````'X````````````````````````8&!@````````&!@P,&!@PR
M,&!@````````/&9F9F9F9F9F/````````!@X.!@8&!@8&'X````````\9F8,"
M#!@P,&!^````````?@8,&!@,#&9F/`````````P<'#PL;&Q^#`P```````!^:
M8&!\!@8&!F8\````````/&!@8'QF9F9F/````````'X&!@P,&!@P,#``````$
M```\9F9F/&9F9F8\````````/&9F9F8^!@8&/```````````&!@8```8&!@`N
M`````````!@8&````!@8&#`@````#A@P8,!@,!@.````````````?@```'X`(
M``````````#@,!@,!@P8,.``````````/&9F#`P8&``8&````````'S&PMK6B
MUMS`XGP```````!\QL;&QO[&QL;&````````_,;&QOS&QL;&_````````'S&:
MP,#`P,#`QGP```````#\QL;&QL;&QL;\````````_L#`P/S`P,#`_@``````B
M`/[`P,#XP,#`P,````````!^P,#`WL;&QL9^````````QL;&QO[&QL;&Q@``<
M`````'X8&!@8&!@8&'X```````!^!@8&!@8&QL9\````````QLS,V/#8S,S&"
MQ@```````,#`P,#`P,#`P/X```````#&[N[6UL;&QL;&````````QL;FYM;6T
MSL[&Q@```````'S&QL;&QL;&QGP```````#\QL;&QL;\P,#`````````?,;&N
MQL;&QM;<;@```````/S&QL;\V,S,QL8```````!\QL#`<!P&!L9\````````:
M?A@8&!@8&!@8&````````,;&QL;&QL;&QGP```````#&QL;&QL;&;#@0````F
M````QL;&QL;6_N[&@@```````,;&;'PX.'QLQL8```````!F9F8D/!@8&!@8*
M````````_@8&#!@P8,#`_@```````#XP,#`P,#`P,#X```````!@8#`P&!@,4
M#`8&````````?`P,#`P,#`P,?``````0.#AL;,;&````````````````````4
M`````````/X``&`P&`P``````````````````````'P&?L;&QGX```````#`"
MP,#\QL;&QL;\````````````?,;`P,#&?`````````8&!G[&QL;&QGX`````&
M``````!\QL;^P,!^````````#A@8?A@8&!@8&````````````'S&QL;&QGX&N
M!GP```#`P,#\QL;&QL;&````````&!@`>!@8&!@8?@````````P,`'P,#`P,$
M#`P,#/@```#`P,#&S-CPV,S&````````>!@8&!@8&!@8?@```````````&S^,
MUM;&QL8```````````#\QL;&QL;&````````````?,;&QL;&?```````````T
M`/S&QL;&QOS`P,````````!^QL;&QL9^!@8&````````_,;&P,#`P```````*
M`````'S&P'P&QGP`````````,##\,#`P,#`<````````````QL;&QL;&?@``0
M`````````,;&QFQL.#@```````````#&QL;6_N[&````````````QL9\.'S&V
MQ@```````````,;&QL;&QGX&!GP```````#^!@PX8,#^``````X8&!@8,.#@T
M,!@8&!@.```8&!@8&!@8&!@8&!@8&```X#`P,#`8#@X8,#`P,.````````!B<
M\KZ<`````````,"@H*#`."`P(#@$!`0$!P```````````````#8V;&S8``!LK
M;```QL;&QL;&?@```````#AL8#AL;#@,;#@`````&#QF`#P^!CY^9F9^/@``(
M``!F9@``?`9^QL;&?@````!@,!@`/#X&/GYF9GX^````'#8<`#P^!CY^9F9^\
M/@`````````\?&!@8&!@?CX,.``8/&8`/'YF9GY@8'X^`````&9F`#Q^9F9^@
M8&!^/@```&`P&``\?F9F?F!@?CX`````9F8`.#@8&!@8&#P\````&#QF`#@XZ
M&!@8&!@\/````&`P&``X.!@8&!@8/#P```!L;`!\QL;&_L;&QL8````\9CP8J
M/'YF9GY^9F9F9@``!@P8?GY@8'Q\8&!@?GX`````````=G\;>__8V/]_````,
M/G[XV-C>WOCXV-C>W@```!@\9@`\?F9F9F9F?CP`````;&P``'S&QL;&QGP`6
M````8#`8`#Q^9F9F9F9^/````!@\9@!F9F9F9F9F?CX```!@,!@`9F9F9F9FF
M9GX^`````&9F`&9F9F9F9GX^!GY\`&QL`'S&QL;&QL;&?`````!L;`#&QL;&X
MQL;&QGP``````!@8/'YF8&!F?CP8&```````.&Q@.&QL.`QL.```````9F9FB
M9GX\&'X8&!@8```````\9F9F?&9F9GQ@8&`````.'A@8&'X8&!@8&'!@`%6`=
M`8`!@`&``8`!@`&``:H````8&```&!@8&!@8````````$!!\UM#0T-9\$!``%
M`````!PB("#X("`@('X```````"!?F9F9F9F?H$`````````9F9F)#P8&'X8(
M&````!@8&!@8&!@``!@8&!@8&!@````X;&`X;&PX#&PX``````!L;```````\
M`````````````'[#O:6AH:6]PWX``````'P&?L;&QGX`_@```````````!(V>
M;-AL-A(``````````````````'X&!@8&`````````````!(\2```````````D
M?L.YI:6YJ:7#?@``````?@``````````````````&"0D&```````````````"
M```````8&!A^&!@8`'X``#QF!APP9GX```````````!XS`PX#,QX````````\
M``````8,&#```````````````````````,;&QL;&QGY@8,```#Q45%0T%!04D
M%!04```````````8&!@````````````````````````X.!@8,"`P<#`P,#!X,
M``````````````!\QL;&QL9\`/X```````````"0V&PV;-B0```````P<#`PR
M,#!['G#.'C9F?P8/,'`P,#`P>QYP_&8&'#!C?WC,##@,S'L><,X>-F9_!@\`)
M```8&``8&`P,9F8\````,!@`?,;&QL;^QL;&Q@```!@P`'S&QL;&_L;&QL8`D
M```0.&P`?,;&QO[&QL;&````8O*\F'S&QL;^QL;&Q@````!L;`!\QL;&_L;&4
MQL8````X1#@`?,;&QO[&QL;&````````#Q@8."]H2/B(CP```````'S&P,#`+
MP,#`QGP8#!@P&`#^P,#`_,#`P,#^````&#``_L#`P/S`P,#`_@```!`X;`#\N
MP,#`^,#`P/X`````;&P`_,#`P/C`P,#^````,!@,`'X8&!@8&!@8?@````P8<
M,`!^&!@8&!@8&'X````8/&8`_A@8&!@8&!C^`````&9F`'X8&!@8&!@8?@``B
M`````#XC(?DA(SX```````!B\KZ<`.;FUM;.SL;&````8#`8`'S&QL;&QL;&9
M?`````P8,`!\QL;&QL;&QGP````0.&P`?,;&QL;&QL9\````8O*^C'S&QL;&Z
MQL;&?`````!L;`!\QL;&QL;&QGP`````````QL9\.'S&Q@````````(&?,[.P
MSM[VYN;F?,"``&`P&`#&QL;&QL;&QGP````,&#``QL;&QL;&QL9\````$#AL8
M`,;&QL;&QL;&?`````!L;`#&QL;&QL;&QGP````,&#``9F8D/!@8&!@8````H
M````<"`X)#@@("`@<````````#QF9F9\9F9F?&!@8````#`8#`!\!G[&QL9^P
M```````,&#``?`9^QL;&?@``````$#AL`'P&?L;&QGX`````8O*^G`!\!G[&<
MQL9^``````!F9@``?`9^QL;&?@`````8)"08`'P&?L;&QGX```````````!^L
M&1E_3$P_````````````?,;`P,#&?!@,&```8#`8`'S&QO[`P'X```````P88
M,`!\QL;^P,!^```````0.&P`?,;&_L#`?@```````&QL`'S&QO[`P'X`````(
M`#`8#`!X&!@8&!A^```````,&#``>!@8&!@8?@``````$#AL`'@8&!@8&'X`F
M``````!L;`!X&!@8&!A^```````($"A$1@D)"08`````````8O*^G`#\QL;&M
MQL8``````&`P&`!\QL;&QL9\```````,&#``?,;&QL;&?```````$#AL`'S&J
MQL;&QGP``````&+ROIP`?,;&QL9\``````!L;```?,;&QL;&?````````````
M&!@`?@`8&````````````@9\SL[6YN9\P(````!@,!@`QL;&QL;&?@``````F
M#!@P`,;&QL;&QGX``````!`X;`#&QL;&QL9^``````!L;```QL;&QL;&?@``&
M````#!@P`,;&QL;&QGX&!GP`````<"`X)"0X("!P````````;&P`QL;&QL;&R
M?@8&?```````````?H&E@;V9@7Y^_]O_P^?_?FS^_OY\.!``$#A\_GPX$``XF
M?#C^_GPX?!`0.'S^?#A\```8/#P8``#__^?#P^?__P`\9D)"9CP`_\.9O;V90
MP_\/!P]]S,S,>#QF9F8\&'X8/S,_,#!P\.!_8W]C8V?FP)E:/.?G/%J9@.#XA
M_OC@@``"#C[^/@X"`!@\?A@8?CP89F9F9F8`9@!_V]M[&QL;`#YC.&QL.,QX6
M`````'Y^?@`8/'X8?CP8_Q@\?A@8&!@`&!@8&'X\&```&`S^#!@````P8/Y@-
M,`````#`P,#^````)&;_9B0````8/'[__P```/__?CP8`````````````#!X)
M>#`P`#``;&QL``````!L;/YL_FQL`#!\P'@,^#```,;,&#!FQ@`X;#AVW,QVR
M`&!@P```````&#!@8&`P&`!@,!@8&#!@``!F//\\9@```#`P_#`P````````7
M`#`P8````/P````````````P,``&#!@P8,"``'S&SM[VYGP`,'`P,#`P_`!XP
MS`PX8,S\`'C,##@,S'@`'#QLS/X,'@#\P/@,#,QX`#A@P/C,S'@`_,P,&#`P$
M,`!XS,QXS,QX`'C,S'P,&'```#`P```P,```,#```#`P8!@P8,!@,!@```#\4
M``#\``!@,!@,&#!@`'C,#!@P`#``?,;>WM[`>``P>,S,_,S,`/QF9GQF9OP`4
M/&;`P,!F/`#X;&9F9FSX`/YB:'AH8OX`_F)H>&A@\``\9L#`SF8^`,S,S/S,^
MS,P`>#`P,#`P>``>#`P,S,QX`.9F;'AL9N8`\&!@8&)F_@#&[O[^UL;&`,;F&
M]M[.QL8`.&S&QL9L.`#\9F9\8&#P`'C,S,S<>!P`_&9F?&QFY@!XS.!P',QXX
M`/RT,#`P,'@`S,S,S,S,_`#,S,S,S'@P`,;&QM;^[L8`QL9L.#ALQ@#,S,QX@
M,#!X`/[&C!@R9OX`>&!@8&!@>`#`8#`8#`8"`'@8&!@8&'@`$#ALQ@``````$
M````````_S`P&`````````!X#'S,=@#@8&!\9F;<````>,S`S'@`'`P,?,S,-
M=@```'C,_,!X`#AL8/!@8/````!VS,Q\#/C@8&QV9F;F`#``<#`P,'@`#``,T
M#`S,S'C@8&9L>&SF`'`P,#`P,'@```#,_O[6Q@```/C,S,S,````>,S,S'@`\
M``#<9F9\8/```';,S'P,'@``W'9F8/````!\P'@,^``0,'PP,#08````S,S,T
MS'8```#,S,QX,````,;6_OYL````QFPX;,8```#,S,Q\#/@``/R8,&3\`!PP"
M,.`P,!P`&!@8`!@8&`#@,#`<,##@`';<`````````!`X;,;&_@```````&QL@
MV`#,`,S,S'X`/F,X;&PXS'A^PSP&/F8_`,P`>`Q\S'X`X`!X#'S,?@`P,'@,]
M?,Q^````>,#`>`PX?L,\9GY@/`#,`'C,_,!X`.``>,S\P'@`S`!P,#`P>`!\3
MQC@8&!@\`.``<#`P,'@`QCALQO[&Q@`P,`!XS/S,`!P`_&!X8/P```!_#'_,B
M?P`^;,S^S,S.`'C,`'C,S'@``,P`>,S,>```X`!XS,QX`'C,`,S,S'X``.``G
MS,S,?@``S`#,S'P,^,,8/&9F/!@`S`#,S,S,>``8&'[`P'X8&#YC.&QL.,QXZ
MS,QX_##\,##XS,SZQL_&QPX;&#P8&-AP58`!@`&``:H`,``P,'AX,``0?-#07
M?!```!@D<"!\``"!?F9F9GZ!`,S,S'@P>#``&!@8```8&!@^8SAL;#C,>`#,!
M`````````#Q:4EH\``!X#'S,=O\````2)$@D$@``````?@8&`````")^1```A
M```\6GIF/````'X````````0*!`````````P,/PP,`#\8!`@<`````#`(&`@0
MP`````P,&`````````#,S,S,=L``/%0T%!04`````#`P``````````!P,&`@6
M8"!P`````'C,S,QX_````$@D$B1(```@8"1Z%B\"`"!@)'@<(@0.P"!$*M8O.
M`@``,``P&`S,>#``>,S\S,P`,`!XS/S,S``P`'C,_,S,`"A0>,S\S,P`QCAL<
MQO[&Q@`0.&S&_L;&`!X8*"YX2(X`/&;`P,!F/!C^8FAX:&+^`/YB:'AH8OX`:
M_F)H>&AB_@#^8FAX:&+^`'@P,#`P,'@`>#`P,#`P>`!X,#`P,#!X`'@P,#`PH
M,'@``#XA^2$^```4*/;>SL;&`#ALQL;&;#@`.&S&QL9L.``X;,;&QFPX`#AL[
MQL;&;#@`PQ@\9F8\&```QFPX;,8``#ILSM;F;+@`S,S,S,S,_`#,S,S,S,S\E
M`,S,S,S,S/P`S`#,S,S,>`#,S,QX,#!X``!P.#@@('```'C,^,SXP,```'@,`
M?,QV````>`Q\S'8```!X#'S,=@```'@,?,QV`,P`>`Q\S'X```!X#'S,=@``<
M9F9F9GQ@P```>,S`S'@P``!XS/S`>````'C,_,!X````>,S\P'@```!XS/S`4
M>``P`'`P,#!X`#``<#`P,'@`,`!P,#`P>`#8`'`P,#!X``````````````#XX
MS,S,S````'C,S,QX````>,S,S'@```!XS,S,>````'C,S,QX``#,`'C,S'@`4
M```8?A@``````GS,W.QX@```S,S,S'8```#,S,S,=@```,S,S,QV``#,`,S,.
GS'X`&#``S,Q\#/@`(#@D."```,P`S,S,?`SX:7-O9F]N=```TOCLF
X``
end
size 6204
END_OF_FILE
if test 8721 -ne `wc -c <'banner-11/MB_Font.uu'`; then
    echo shar: \"'banner-11/MB_Font.uu'\" unpacked with wrong size!
fi
# end of 'banner-11/MB_Font.uu'
fi
if test -f 'banner-11/Read.Me' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-11/Read.Me'\"
else
echo shar: Extracting \"'banner-11/Read.Me'\" \(5204 characters\)
sed "s/^X//" >'banner-11/Read.Me' <<'END_OF_FILE'
mb - and just another banner program.
X
No makefile, No manualpage included.
X
It's just another senseless program but I couldn't resist in writing
it. It should just compile ok under OS-9/68k, any *IX flavour and on
nearly every other system (with same small changes...). I could only
test it on OS-9/68k.
X
The main difference to other programs: It uses an external font-file,
so you can change this as you want. The format is very easy:
X256 characters each in a size of 16 byte, displaying in following
order
bit     7 6 5 4 3 2 1 0
byte 0  X X X X X X X X
byte 1  X X X X X X X X
byte 2  X X X X X X X X
byte 3  X X X X X X X X
byte 4  X X X X X X X X
byte 5  X X X X X X X X
byte 6  X X X X X X X X
byte 7  X X X X X X X X
byte 8  X X X X X X X X
byte 9  X X X X X X X X
byte 10 X X X X X X X X
byte 11 X X X X X X X X
byte 12 X X X X X X X X
byte 13 X X X X X X X X
byte 14 X X X X X X X X
byte 15 X X X X X X X X
X
Then 256 characters with a size of 8 bytes each follows, order is the
same as above (but only 8 lines).
X
This file may be prefixed by an OS-9/68k module header of 48 bytes
X(these font files are used on an OS-9 implementation for the Atari ST).
X
The format itself can be found in the Atari ST TOS world very often,
so it's easy to get other fonts (I haven't included any, 'cause I
don't if they are copyrighted, sigh).
X
There is no difference to other programs of the same type, the most
common options are available:
X-o=<file>  use this fontfile instead of $HOME/.font or
X           /dd/SYS/MB_Font (OS-9) / /etc/MB_Font (*IX) / \MB_FONT (DOS)
X-l         use the larger (16x8) font (default is 8x8 font)
X-w=<num>   width multiplicator
X-h=<num>   hight multiplicator
X-c         print the letters cursive (well not really cursive...)
X-C         make the banner cursive in other direction
X-i         invert the printing (exchange for- and background pattern)
X-f=<char>  use <char> as the forground (i.e. write) pattern
X           (default `*')
X-b=<char>  the background (default ` ')
X-s         use the character itself as the forground pattern
X
If no string is given, the strings are read in from stdin until
an EOF is detected.
X
You can print a leading `-' with a construct `--'
X
The included font file represents roughly the ISO 8859/1 character
set.
X
Bug: if a fontfile starts with the bytes 0x4a 0xfc then it is assumed
to be a OS-9 Module and the first 48 bytes are skipped...
X
Some expamples:
X% mb Foo Bar
X*******                 
X **   *                 
X ** *    ****    ****   
X ****   **  **  **  **  
X ** *   **  **  **  **  
X **     **  **  **  **  
X****     ****    ****   
X                        
X******                  
X **  **                 
X **  **  ****   ** ***  
X *****      **   *** ** 
X **  **  *****   **  ** 
X **  ** **  **   **     
X******   *** ** ****    
X                        
X
X$ mb "Foo Bar"
X*******                         ******                  
X **   *                          **  **                 
X ** *    ****    ****            **  **  ****   ** ***  
X ****   **  **  **  **           *****      **   *** ** 
X ** *   **  **  **  **           **  **  *****   **  ** 
X **     **  **  **  **           **  ** **  **   **     
X****     ****    ****           ******   *** ** ****    
X                                                        
X$ mb -lcfXb. "--Foo Bar"
X...............................................................................
X...............................................................................
X...............................................................................
X....................XXXXXXX.........................XXXXXX.....................
X...................XX..............................XX...XX.....................
X..................XX..............................XX...XX......................
X.................XX.......XXXXX...XXXXX..........XX...XX..XXXXX..XXXXXX........
X.........XXXXXX.XXXXX...XX...XX.XX...XX.........XXXXXX.......XX.XX...XX........
X...............XX......XX...XX.XX...XX.........XX...XX..XXXXXX.XX...XX.........
X..............XX......XX...XX.XX...XX.........XX...XX.XX...XX.XX...............
X.............XX......XX...XX.XX...XX.........XX...XX.XX...XX.XX................
X............XX......XX...XX.XX...XX.........XX...XX.XX...XX.XX.................
X...........XX.......XXXXX...XXXXX..........XXXXXX...XXXXXX.XX..................
X...............................................................................
X...............................................................................
X...............................................................................
X
X$ mb -w=3 Foo
X*********************                                                   
X   ******         ***                                                   
X   ******   ***            ************            ************         
X   ************         ******      ******      ******      ******      
X   ******   ***         ******      ******      ******      ******      
X   ******               ******      ******      ******      ******      
X************               ************            ************         
X                                                                        
END_OF_FILE
if test 5204 -ne `wc -c <'banner-11/Read.Me'`; then
    echo shar: \"'banner-11/Read.Me'\" unpacked with wrong size!
fi
# end of 'banner-11/Read.Me'
fi
if test -f 'banner-11/mb.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-11/mb.c'\"
else
echo shar: Extracting \"'banner-11/mb.c'\" \(7453 characters\)
sed "s/^X//" >'banner-11/mb.c' <<'END_OF_FILE'
X/*
X *	mb:	another banner program with external fontfiles
X *
X *	(C) Copyrighted 1992 by Ulrich Dessauer, Germering, Germany
X *
X *	You can copy, forward, redistribute the whole package as long
X *	as you make no profit and this copyright messages stays untouched!
X */
X# include	<stdio.h>
X# include	<errno.h>
X# ifdef		OSK
X# include	<modes.h>
X# include	<module.h>
X# define	R_OK		S_IREAD
X# define	MODHEADSIZ	sizeof (struct modhcom)
X# else		/* OSK */
X# include	<fcntl.h>
X# ifndef	R_OK
X# define	R_OK		O_RDONLY
X# endif		/* R_OK */
X# define	MODSYNC		((unsigned long) 0x4afc)
X# define	MODHEADSIZ	0x30
X# if		defined (USG) || defined (SYSV) || defined (SYS5) || defined (HAS_STRCHR)
X# define	index		strchr
X# endif		/* defined (USG) || defined (SYSV) || defined (SYS5) || defined (HAS_STRCHR) */
X# endif		/* OSK */
X
X	/* binary read for fopen */
X# if		defined (MSDOS) || defined (msdos) || defined (TOS)
X# define	READ_BINARY	"rb"
X# else		/* defined (MSDOS) || defined (msdos) || defined (TOS) */
X# define	READ_BINARY	"r"
X# endif		/* defined (MSDOS) || defined (msdos) || defined (TOS) */
X
X# define	FALSE		(0 == 1)
X# define	TRUE		(1 == 1)
X
X# ifdef		OSK
X# define	DEF_FONTFILE	"/dd/SYS/MB_Font"
X# else		/* OSK */
X# if		defined (MSDOS) || defined (msdos) || defined (TOS)
X# define	DEF_FONTFILE	"\\MB_FONT"
X# else		/* defined (MSDOS) || defined (msdos) || defined (TOS) */
X# define	DEF_FONTFILE	"/etc/MB_Font"
X# endif		/* defined (MSDOS) || defined (msdos) || defined (TOS) */
X# endif		/* OSK */
X
X# define	NO_MEM		exit (_errmsg (errno, "Out of memory!\n"));
X
extern char	*getenv ();
extern char	*index ();
extern char	*malloc ();
X
typedef unsigned char	byte;
X
static char		*fontfile;
static int		large;
static int		width;
static int		hight;
static int		cursive;
static int		backcursive;
static int		invers;
static char		forground;
static char		background;
X
X# ifndef	OSK
X/*
X *	Not very portable....
X */
int
X_errmsg (error, fmt, a, b, c)
int error;
char *fmt;
void *a, *b, *c;
X{
X	fputs ("mb: ", stderr);
X	fprintf (stderr, fmt, a, b, c);
X	return (error);
X}
X# endif		/* OSK */
X
static void
banner (s, cset)
char *s;
byte *cset;
X{
X	register byte	*ptr;
X	register int	n;
X	register int	t;
X	register byte	b;
X	register int	ch;
X	int		u, v;
X	int		max;
X	static char	*space = NULL;
X	static int	spcsiz = 0;
X
X	if (! space) {
X		spcsiz = (large ? 16 : 8) * hight;
X		if (! (space = malloc (spcsiz + 4)))
X			return;
X	}
X	if (cursive || backcursive) {
X		memset (space, invers ? forground : background, spcsiz);
X		space[spcsiz] = '\0';
X	}
X	max = (large ? 16 : 8) * hight;
X	for (n = 0; n < max; ++n) {
X		if (cursive) {
X			space[max - n - 1] = '\0';
X			fputs (space, stdout);
X		} else if (backcursive)
X			for (t = 0; t < n; ++t)
X				putchar (invers ? forground : background);
X		ptr = (byte *) s;
X		while (*ptr) {
X			b = cset[(*ptr << (large ? 4 : 3)) + (n / hight)];
X				for (t = 7; t >= 0; --t) {
X					if (((b & (1 << t)) != 0) ^ invers)
X						ch = forground ? forground : (int) *ptr;
X					else
X						ch = background;
X					for (u = 0; u < width; ++u)
X						putchar (ch);
X				}
X			++ptr;
X		}
X		if (cursive)
X			for (t = 0; t < n; ++t)
X				putchar (invers ? forground : background);
X		else if (backcursive) {
X			space[max - n - 1] = '\0';
X			fputs (space, stdout);
X		}
X		putchar ('\n');
X	}
X}
X
static char	*help[] = {
X	"Syntax: mb [<opts>] [<string(s)] [<opts>]\n",
X	"Function: prints a string in large letter\n",
X	"Options:\n",
X	"     -o=<file> Use <file> instead of default font-file\n",
X	"     -l        print an even larger banner than default\n",
X	"     -w=<num>  prints banner with <num> width\n",
X	"     -h=<num>  prints banner with <num> hight\n",
X	"     -c        make the banner cursive (eek, not real cursive...)\n",
X	"     -C        make the banner cursive in other direction\n",
X	"     -i        invert the characters\n",
X	"     -f=<char> use <char> as the forground pattern\n",
X	"     -b=<char> use <char> as the background pattern\n",
X	"     -s        use the printed character as the forground pattern\n",
X	NULL
X};
X
static void
usage ()
X{
X	register int	t;
X
X	for (t = 0; help[t]; ++t)
X		fputs (help[t], stderr);
X}
X
int
main (ac, av)
int ac;
char *av[];
X{
X	FILE	*fp;
X	byte	msync[2];
X	byte	*csetl, *csets;
X	int	t, err;
X	char	*ptr, *tmp;
X	int	use_char;
X	int	found_string;
X
X	fontfile = NULL;
X	large = FALSE;
X	width = 1;
X	hight = 1;
X	cursive = FALSE;
X	backcursive = FALSE;
X	invers = FALSE;
X	forground = '*';
X	background = ' ';
X	use_char = FALSE;
X	found_string = FALSE;
X	for (t = 1; t < ac; ++t)
X		if ((av[t][0] == '-') && (av[t][1] != '-')) {
X			ptr = av[t] + 1;
X			while (*ptr) {
X				switch (*ptr) {
X					case 'o':
X						ptr += *(ptr + 1) == '=' ? 2 : 1;
X						fontfile = ptr;
X						while (*ptr)
X							++ptr;
X						break;
X					case 'l':
X						large = TRUE;
X						break;
X					case 'w':
X						ptr += *(ptr + 1) == '=' ? 2 : 1;
X						if ((width = atoi (ptr)) < 1)
X							width = 1;
X						while (*ptr)
X							++ptr;
X						break;
X					case 'h':
X						ptr += *(ptr + 1) == '=' ? 2 : 1;
X						if ((hight = atoi (ptr)) < 1)
X							hight = 1;
X						while (*ptr)
X							++ptr;
X						break;
X					case 'c':
X						cursive = TRUE;
X						break;
X					case 'C':
X						backcursive = TRUE;
X						break;
X					case 'i':
X						invers = TRUE;
X						break;
X					case 'f':
X						ptr += *(ptr + 1) == '=' ? 2 : 1;
X						forground = *ptr;
X						break;
X					case 'b':
X						ptr += *(ptr + 1) == '=' ? 2 : 1;
X						background = *ptr;
X						break;
X					case 's':
X						use_char = TRUE;
X						break;
X					case '?':
X					default:
X						usage ();
X						exit (((*ptr == '?') || (*ptr == 'h')) ? 0 :
X							_errmsg (1, "Unknown option '%c'.\n", *ptr));
X				}
X				if (*ptr)
X					++ptr;
X			}
X		} else
X			found_string = TRUE;
X	if (use_char)
X		forground = '\0';
X	if (large) {
X		if (! (csetl = (byte *) malloc (256 * 16)))
X			NO_MEM
X		csets = NULL;
X	} else {
X		if (! (csets = (byte *) malloc (256 * 8)))
X			NO_MEM
X		csetl = NULL;
X	}
X	if (! fontfile) {
X		if (ptr = getenv ("HOME"))
X			if (tmp = malloc (strlen (ptr) + 16)) {
X				sprintf (tmp, "%s/.font", ptr);
X				if (access (tmp, R_OK) != -1)
X					fontfile = tmp;
X				else
X					free (tmp);
X			}
X		if (! fontfile)
X			fontfile = DEF_FONTFILE;
X	}
X	if (! (fp = fopen (fontfile, READ_BINARY)))
X		exit (_errmsg (errno, "Can't open %s.\n", fontfile));
X	if (fread (msync, sizeof (byte), 2, fp) != 2) {
X		fclose (fp);
X		exit (_errmsg (errno, "Can't read first %d byte%s.\n",
X			sizeof (short), sizeof (short) > 1 ? "s" : ""));
X	}
X	if ((msync[0] == (byte) ((MODSYNC >> 8) & 0xff)) && (msync[1] == (byte) (MODSYNC & 0xff)))
X		err = fseek (fp, MODHEADSIZ, 0);
X	else
X		err = fseek (fp, 0, 0);
X	if (err == -1) {
X		fclose (fp);
X		exit (_errmsg (errno, "Can't fseek to start of font data!\n"));
X	}
X	if (large) {
X		if (fread (csetl, sizeof (byte), 16 * 256, fp) != 16 * 256) {
X			fclose (fp);
X			exit (_errmsg (errno, "Can't read font data (large).\n"));
X		}
X	} else {
X		if (fseek (fp, 256 * 16, 1) == -1) {
X			fclose (fp);
X			exit (_errmsg (errno, "Can't fseek to font data.\n"));
X		}
X		if (fread (csets, sizeof (byte), 8 * 256, fp) != 8 * 256) {
X			fclose (fp);
X			exit (_errmsg (errno, "Can't read font data (small).\n"));
X		}
X	}
X	fclose (fp);
X	if (found_string) {
X		for (t = 1; t < ac; ++t)
X			if ((av[t][0] != '-') || (av[t][1] == '-'))
X				banner (av[t] + (av[t][0] == '-' ? 1 : 0), large ? csetl : csets);
X	} else if (ptr = malloc (130)) {
X		while (fgets (ptr, 128, stdin)) {
X			if (tmp = index (ptr, '\n'))
X				*tmp = '\0';
X			banner (ptr, large ? csetl : csets);
X		}
X		free (ptr);
X	}
X}
END_OF_FILE
if test 7453 -ne `wc -c <'banner-11/mb.c'`; then
    echo shar: \"'banner-11/mb.c'\" unpacked with wrong size!
fi
# end of 'banner-11/mb.c'
fi
if test -f 'banner-13/cyrban.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'banner-13/cyrban.c'\"
else
echo shar: Extracting \"'banner-13/cyrban.c'\" \(7519 characters\)
sed "s/^X//" >'banner-13/cyrban.c' <<'END_OF_FILE'
X/* 
X *  ####  #   #  ####   ####     #    #   # 
X * #      #  ##  #   #   #      # #   #   # 
X * #      # # #  ####    ####  #####  ##### 
X * #      ##  #  #       #  #  #   #  #   # 
X *  ####  #   #  #      #####  #   #  #   # 
X * 
X * cyrban.c by Matt Welsh: a big hack to do Cyrillic banners.
X * Handles all Cyrillic letters except Yo (because the dots won't fit--
X * Russians usu. don't use the dots anyway!).
X * The keyboard mapping is very straighforward, except:
X *  ~ = eh              / = myaknii znak    w = sha 
X *  ` = yoo             | = ih              x = scha
X *  \ = tvordnii zhak   q = tse             > = i-kratkoe
X *
X * Problems: doesn't do numbers and some punctuation, or
X * capital letters. This program can easily be generalized
X * into a 'multibanner' program to read in a BUAF character
X * file, however, this was a quickie to churn out alt.fan.warlord bait.
X *
X * v1.1  welshm@dg-rtp.dg.com
X * (c)1992 Matt Welsh
X * This program is free software.
X * You may distribute copies of the source and executable for this program
X * free of charge, as long as the copyright notice is kept intact and
X * any modifactions bear the original copyright notice.
X */
X
X#include <stdio.h>
X#include <string.h>
X
enum {lA=0, lB, lC, lD, lE, lF, lG, lH, lI, lJ, lK, lL, lM, lN, lO, lP,
X      lQ, lR, lS, lT, lU, lV, lW, lX, lY, lZ, 
X      lBS, lFS, lPI, lTL, lBQ, lGR, lSP};
X#define NUMLETTERS lSP           /* Keep lSP as last letter in series! */
char *letters[NUMLETTERS][5];
X
void printline(c,line) char c; int line; {
X  
X  if ((c<='z') && (c>='a')) {
X    printf("%s",letters[(int)(c-'a')][line]);
X  } else {
X    switch(c) {
X      case '\\': printf("%s",letters[lBS][line]); break;
X      case '/': printf("%s",letters[lFS][line]); break;
X      case '|': printf("%s",letters[lPI][line]); break;
X      case '~': printf("%s",letters[lTL][line]); break;
X      case '`': printf("%s",letters[lBQ][line]); break;
X      case ' ': printf("%s",letters[lSP][line]); break;
X      case '>': printf("%s",letters[lGR][line]); break;
X    }
X  }
X}
X
X
void printstring(s) char *s; { 
X  
X  int n,i,j,c;
X  n=strlen(s); if (n>11) n=11;
X  for (i=0; i<5; i++) {
X    for (j=0; j<n; j++) {
X      c=tolower(s[j]);
X      printline(c,i);
X    }
X   printf("\n");
X  }
X}
X
void initletters();
X
void main(argc,argv) int argc; char **argv; {
X  int i;
X  initletters();
X  if (argc<2) exit(1);
X  for (i=1; i<argc; i++) {
X    printstring(argv[i]);
X   printf("\n\n");
X  }
X}
X
X
void initletters() {      
X/* I know this is ugly and redundant. As I said, this can
X * easily be read into a file, but I didn't feel like messing
X * with it at 3 in the morning. 
X */ 
X  letters[lA][0]="   #   ";      
X  letters[lA][1]="  # #  ";
X  letters[lA][2]=" ##### ";
X  letters[lA][3]=" #   # ";
X  letters[lA][4]=" #   # ";
X 
X  letters[lB][0]=" ####  ";      
X  letters[lB][1]="  #    ";
X  letters[lB][2]="  #### ";
X  letters[lB][3]="  #  # ";
X  letters[lB][4]=" ##### ";
X
X  letters[lC][0]=" #   # ";      
X  letters[lC][1]=" #   # ";
X  letters[lC][2]="  #### ";
X  letters[lC][3]="     # ";
X  letters[lC][4]="     # ";
X  
X  letters[lD][0]=" ##### ";      
X  letters[lD][1]="  #  # ";
X  letters[lD][2]="  #  # ";
X  letters[lD][3]="  #### ";
X  letters[lD][4]=" #    #";
X  
X  letters[lE][0]=" ##### ";     
X  letters[lE][1]=" #     ";
X  letters[lE][2]=" ####  ";
X  letters[lE][3]=" #     ";
X  letters[lE][4]=" ##### ";
X  
X  letters[lF][0]="   #   ";      
X  letters[lF][1]="  ###  ";
X  letters[lF][2]=" # # # ";
X  letters[lF][3]="  ###  ";
X  letters[lF][4]="   #   ";
X  
X  letters[lG][0]=" ##### ";      
X  letters[lG][1]=" #   # ";
X  letters[lG][2]=" #     ";
X  letters[lG][3]=" #     ";
X  letters[lG][4]=" #     ";
X  
X  letters[lH][0]=" #   # ";      
X  letters[lH][1]="  # #  ";
X  letters[lH][2]="   #   ";
X  letters[lH][3]="  # #  ";
X  letters[lH][4]=" #   # ";
X  
X  letters[lI][0]=" #   # ";      
X  letters[lI][1]=" #  ## ";
X  letters[lI][2]=" # # # ";
X  letters[lI][3]=" ##  # ";
X  letters[lI][4]=" #   # ";
X  
X  letters[lJ][0]=" # # # ";      
X  letters[lJ][1]="  ###  ";
X  letters[lJ][2]="   #   ";
X  letters[lJ][3]="  ###  ";
X  letters[lJ][4]=" # # # ";
X  
X  letters[lK][0]=" #   # ";      
X  letters[lK][1]=" #  #  ";
X  letters[lK][2]=" ###   ";
X  letters[lK][3]=" #  #  ";
X  letters[lK][4]=" #   # ";
X  
X  letters[lL][0]=" ##### ";     
X  letters[lL][1]="  #  # ";
X  letters[lL][2]="  #  # ";
X  letters[lL][3]="  #  # ";
X  letters[lL][4]=" #   # ";
X  
X  letters[lM][0]=" #   # ";      
X  letters[lM][1]=" ## ## ";
X  letters[lM][2]=" # # # ";
X  letters[lM][3]=" #   # ";
X  letters[lM][4]=" #   # ";
X  
X  letters[lN][0]=" #   # ";     
X  letters[lN][1]=" #   # ";
X  letters[lN][2]=" ##### ";
X  letters[lN][3]=" #   # ";
X  letters[lN][4]=" #   # ";
X  
X  letters[lO][0]="  ###  ";     
X  letters[lO][1]=" #   # ";
X  letters[lO][2]=" #   # ";
X  letters[lO][3]=" #   # ";
X  letters[lO][4]="  ###  ";
X  
X  letters[lP][0]=" ##### ";     
X  letters[lP][1]=" #   # ";
X  letters[lP][2]=" #   # ";
X  letters[lP][3]=" #   # ";
X  letters[lP][4]=" #   # ";
X  
X  letters[lQ][0]=" #   # ";     
X  letters[lQ][1]=" #   # ";
X  letters[lQ][2]=" #   # ";
X  letters[lQ][3]=" ##### ";
X  letters[lQ][4]="     # ";
X  
X  letters[lR][0]=" ####  ";     
X  letters[lR][1]=" #   # ";
X  letters[lR][2]=" ####  ";
X  letters[lR][3]=" #     ";
X  letters[lR][4]=" #     ";
X  
X  letters[lS][0]="  #### ";     
X  letters[lS][1]=" #     ";
X  letters[lS][2]=" #     ";
X  letters[lS][3]=" #     ";
X  letters[lS][4]="  #### ";
X  
X  letters[lT][0]=" ##### ";     
X  letters[lT][1]="   #   ";
X  letters[lT][2]="   #   ";
X  letters[lT][3]="   #   ";
X  letters[lT][4]="   #   ";
X  
X  letters[lU][0]=" #   # ";     
X  letters[lU][1]="  # #  ";
X  letters[lU][2]="   #   ";
X  letters[lU][3]="  #    ";
X  letters[lU][4]=" #     ";
X  
X  letters[lV][0]=" ####  ";     
X  letters[lV][1]=" #   # ";
X  letters[lV][2]=" ####  ";
X  letters[lV][3]=" #   # ";
X  letters[lV][4]=" ####  ";
X  
X  letters[lW][0]=" #   # ";     
X  letters[lW][1]=" # # # ";
X  letters[lW][2]=" # # # ";
X  letters[lW][3]=" # # # ";
X  letters[lW][4]="  ###  ";
X  
X  letters[lX][0]=" #   # ";     
X  letters[lX][1]=" # # # ";
X  letters[lX][2]=" # # # ";
X  letters[lX][3]=" # # # ";
X  letters[lX][4]="  #####";
X  
X  letters[lY][0]="  #### ";     
X  letters[lY][1]=" #   # ";
X  letters[lY][2]="  #### ";
X  letters[lY][3]="  #  # ";
X  letters[lY][4]=" #   # ";
X  
X  letters[lZ][0]=" ####  ";     
X  letters[lZ][1]="     # ";
X  letters[lZ][2]="  ###  ";
X  letters[lZ][3]="     # ";
X  letters[lZ][4]=" ####  ";
X  
X  letters[lBS][0]=" ##  ";    
X  letters[lBS][1]=" #   ";
X  letters[lBS][2]=" ##  ";
X  letters[lBS][3]=" # # ";
X  letters[lBS][4]=" ##  ";
X  
X  letters[lFS][0]=" #   ";     
X  letters[lFS][1]=" #   ";
X  letters[lFS][2]=" ##  ";
X  letters[lFS][3]=" # # ";
X  letters[lFS][4]=" ##  ";
X  
X  letters[lPI][0]=" #   # ";     
X  letters[lPI][1]=" #   # ";
X  letters[lPI][2]=" ##  # ";
X  letters[lPI][3]=" # # # ";
X  letters[lPI][4]=" ##  # ";
X  
X  letters[lTL][0]=" ####  ";     
X  letters[lTL][1]="     # ";
X  letters[lTL][2]=" ##### ";
X  letters[lTL][3]="     # ";
X  letters[lTL][4]=" ####  ";
X  
X  letters[lBQ][0]=" #  ##  ";     
X  letters[lBQ][1]=" # #  # ";
X  letters[lBQ][2]=" ###  # ";
X  letters[lBQ][3]=" # #  # ";
X  letters[lBQ][4]=" #  ##  ";
X
X  letters[lGR][0]=" # # # ";
X  letters[lGR][1]=" #  ## ";
X  letters[lGR][2]=" # # # ";
X  letters[lGR][3]=" ##  # ";
X  letters[lGR][4]=" #   # ";
X
X  letters[lSP][0]="      ";
X  letters[lSP][1]="      ";
X  letters[lSP][2]="      ";
X  letters[lSP][3]="      ";
X  letters[lSP][4]="      ";
X}
END_OF_FILE
if test 7519 -ne `wc -c <'banner-13/cyrban.c'`; then
    echo shar: \"'banner-13/cyrban.c'\" unpacked with wrong size!
fi
# end of 'banner-13/cyrban.c'
fi
if test -f 'cursive-01/cursive.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cursive-01/cursive.c'\"
else
echo shar: Extracting \"'cursive-01/cursive.c'\" \(6630 characters\)
sed "s/^X//" >'cursive-01/cursive.c' <<'END_OF_FILE'
X/*		CURSIVE SIGNATURE PROGRAM		Version 0.10
X *              (c) 1985 - Jan Wolter
X *
X *  Purpose:	This program translates text into crude cursive script.
X *		It works on any terminal with a fairly normal character
X *		set (must have backslashes and underscores and suchlike).
X *		The font includes all upper and lower case letters, most
X *		punctuation, and a few symbols.  No numbers are included
X *		(It's difficult to make a nice italicized set of numbers).
X *		Cursive was originally written to generate fancy signatures
X *		for electronic mail messages, but other uses may occur to
X *		you.  The attractiveness of the font varies greatly with
X *		the display device.
X *
X *  Usage:	If no command line arguments are given, cursive reads the
X *		text to translate from standard input.  Otherwise the args
X *		are translated (e.g. "cursive Jan Wolter" prints my name).
X *		Output is always to standard output.  A couple command line
X *		arguments are recognized:
X *
X *		  -in	Sets the amount of space to insert between letters.
X *			The default is "-i1".  "-i0" gives interesting
X *			results.
X *		  -tn	Sets the length of the trailing line off the end
X *			of each word.  The default is "-t1".
X *
X *		One character in the text is treated in a special way:
X *
X *		  '_'   Can be inserted in text to slightly lengthen the
X *			the spacing between two letters, or add a longer
X *			tail to the end of a word.
X *
X *  Internals:	Unfortunately, the program is a kludge and the font is
X *		somewhat difficult to edit.  It should be easy to port
X *		though.  Systems with short integers or unsigned characters
X *		should be no problem.  You should probably run "xstr" on the
X *		font.c file, but if you haven't got "xstr", just compiling it
X *		the usual way works fine.
X *
X *  Copyright:	Both the cursive program and the font it generates are
X *		copyrighted by yours truly.  However, both may be used
X *		and distributed freely.  You even have my permission to
X *		sell it, or include in it a system that you sell.  I only
X *		ask that my name be retained on this program, or any direct
X *		decendents of this program with approximately the same
X *		visibility as in this posting.
X *
X *  Mail:	I'm interested in any comments you have on this program.
X *		I can be mailed at "janc@crim.eecs.umich.edu".  Better yet,
X *		if you are into teleconferencing, call M-Net at (313) 994-6333
X *		and type "newuser" at the "login:" prompt to give yourself an
X *		account.  Send mail to janc, or join the "ugames" conference.
X *
X *		Have fun,
X *				  ___                _     __  _
X *				 (   >              ' )   /   // _/_
X *				  __/___.  ____      / / / __|/  /  _  __
X *				 / / (_/|_/ / <__   (_(_/ (_) \_<__</_/ (__
X *				<_/
X */
X
X#include <stdio.h>
X#include "cursive.h"
X
char *buffer[6];	/* memory buffers to build up line in */
int c[6];		/* current index in each of the buffer lines */
int tail[6];		/* which buffer lines have tails in them */
int lasttail;		/* which line was the last letter's tail */
int space;		/* how much white space before the next letter */
int interspace = 1;	/* how much to spread adjacent letters out */
int taillen = 1;	/* how long the tails on ends of words should be */
char firstletter;	/* is this the first letter on the line? */
char message[256] = "";	/* message to print */
X
char *malloc();
X
main(argc,argv)
int argc;
char **argv;
X{
int i;
char *s,*m;
char ch;
X
X	m = message;
X	for (i = 1; i < argc; i++)
X	{
X		if (*argv[i] == '-')
X			switch(ch = argv[i][1])
X			{
X			case 'i':
X			case 't':
X				s = argv[i]+2;
X				if (*s == '\000')
X					if (++i < argc)
X						s = argv[i];
X				if (*s < '0' || *s > '9')
X				{
X					printf("%s: Illegal value %s\n",
X						argv[0],s);
X					exit(1);
X				}
X				if (ch == 'i')
X					interspace = atoi(s);
X				else
X					taillen = atoi(s);
X				break;
X			default:
X				printf("usage: %s [-tn] [-in] message\n",
X					argv[0]);
X				exit(1);
X			}
X		else
X		{
X			if (m != message)
X				*(m++) = ' ';
X			for (s=argv[i]; *s != '\000'; s++)
X				*(m++) = *s;
X		}
X	}
X	/* Do the deed */
X	if (m != message)
X	{
X		/* Message from the arg list */
X		*(m++) = 0;
X		prline(message);
X	}
X	else
X	{
X		/* Message from standard input */
X		while (gets(message) != NULL)
X			prline(message);
X	}
X}
X
X
X/* Add the given letter to the end of the current line */
X
place(let)
struct letter *let;
X{
int i,j,n;
int col;
int max = -10000;
char pad;
char *l;
X
X	if (firstletter)
X	{
X		col = space;		/* Leading spaces */
X		firstletter = 0;
X	}
X	else
X	{
X		/* Find the furthest left position we can place this letter */
X		for(i=0; i<6; i++)
X		{
X			if (let->line[i][0] != '\000' &&
X			    (col = c[i] - let->spcs[i]) > max)
X				max = col;
X		}
X
X		/* Insert some spaces between letters */
X		col = max + space + interspace;
X	}
X
X	for(i=0; i<6; i++)
X
X		/* If Nothing on this Line, Skip It */
X		if (let->line[i][0] != '\000')
X		{
X			/* Number of Spaces to Put on this Line? */
X			n = col - c[i] + let->spcs[i];
X
X			/* Flyers off Ends of Letters */
X			if (tail[i])
X				for (j = 0;
X				     j < 5 && n > space + 2; j++,n--)
X					buffer[i][c[i]++] = '_';
X
X			/* Connecting Lines Between Letters */
X			pad = (lasttail == i && let->tailin == i) ? '_' : ' ';
X
X			/* In the middle of the intersection of South and */
X			/* East University, someone is playing the piano. */
X			for ( ; n > 0; n--)
X				buffer[i][c[i]++] = pad;
X
X			/* Copy in the letter text */
X			for (l = let->line[i]; *l != '\000'; l++)
X				buffer[i][c[i]++] = *l;
X
X			tail[i] = (i == let->tailout);
X		}
X
X	lasttail = let->tailout;
X	space = 0;
X}
X
X/* Lengthen the last trailer by n */
tailer(n)
int n;
X{
int j;
X	if (lasttail >= 0)
X		for (j = 0; j < n; j++)
X			buffer[lasttail][c[lasttail]++] = '_';
X}
X
X/* Handle a line */
prline(s)
char *s;
X{
int l,i;
char *ch;
short lcode;
X
X	lasttail = -1;
X	firstletter = 1;
X	space = 0;
X	/* Get some memory to put the output into */
X	l = strlen(s) * (CHARWIDTH + interspace);
X	for (i=0;i<6;i++)
X	{
X		buffer[i] = malloc((unsigned)l);
X		tail[i] = c[i] = 0;
X	}
X
X	/* do each letter */
X	for (ch=s; *ch != '\000'; ch++)
X	{
X
X		*ch &= '\177';
X		/* Find the letter */
X		lcode = (lasttail != 2) ? code1[*ch] : code2[*ch];
X		if (lcode >= 0)
X			place(&list[lcode]);
X		else
X			/* Various Special characters */
X			switch(lcode)
X			{
X			case SP:
X				/* Insert white space before next letter */
X				tailer(taillen);
X				space += 3;
X				lasttail = -1;
X				break;
X			case ST:
X				/* Lengthen the last tail */
X				if (lasttail >= 0)
X					buffer[lasttail][c[lasttail]++] = '_';
X				break;
X			}
X	}
X	tailer(taillen);
X
X	/* print the line and release the memory */
X	for (i=0;i<6;i++)
X	{
X		buffer[i][c[i]++] = '\n';
X		write(1,buffer[i],c[i]);
X		free(buffer[i]);
X	}
X}
END_OF_FILE
if test 6630 -ne `wc -c <'cursive-01/cursive.c'`; then
    echo shar: \"'cursive-01/cursive.c'\" unpacked with wrong size!
fi
# end of 'cursive-01/cursive.c'
fi
if test -f 'cursive-02/cursive.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cursive-02/cursive.c'\"
else
echo shar: Extracting \"'cursive-02/cursive.c'\" \(7070 characters\)
sed "s/^X//" >'cursive-02/cursive.c' <<'END_OF_FILE'
X/*		CURSIVE SIGNATURE PROGRAM		Version 0.10
X *              (c) 1985 - Jan Wolter
X *
X *  Purpose:	This program translates text into crude cursive script.
X *		It works on any terminal with a fairly normal character
X *		set (must have backslashes and underscores and suchlike).
X *		The font includes all upper and lower case letters, most
X *		punctuation, and a few symbols.  No numbers are included
X *		(It's difficult to make a nice italicized set of numbers).
X *		Cursive was originally written to generate fancy signatures
X *		for electronic mail messages, but other uses may occur to
X *		you.  The attractiveness of the font varies greatly with
X *		the display device.
X *
X *  Usage:	If no command line arguments are given, cursive reads the
X *		text to translate from standard input.  Otherwise the args
X *		are translated (e.g. "cursive Jan Wolter" prints my name).
X *		Output is always to standard output.  A couple command line
X *		arguments are recognized:
X *
X *		  -in	Sets the amount of space to insert between letters.
X *			The default is "-i1".  "-i0" gives interesting
X *			results.
X *		  -tn	Sets the length of the trailing line off the end
X *			of each word.  The default is "-t1".
X *
X *		One character in the text is treated in a special way:
X *
X *		  '_'   Can be inserted in text to slightly lengthen the
X *			the spacing between two letters, or add a longer
X *			tail to the end of a word.
X *
X *  Internals:	Unfortunately, the program is a kludge and the font is
X *		somewhat difficult to edit.  It should be easy to port
X *		though.  Systems with short integers or unsigned characters
X *		should be no problem.  You should probably run "xstr" on the
X *		font.c file, but if you haven't got "xstr", just compiling it
X *		the usual way works fine.
X *
X *  Copyright:	Both the cursive program and the font it generates are
X *		copyrighted by yours truly.  However, both may be used
X *		and distributed freely.  You even have my permission to
X *		sell it, or include in it a system that you sell.  I only
X *		ask that my name be retained on this program, or any direct
X *		decendents of this program with approximately the same
X *		visibility as in this posting.
X *
X *  Mail:	I'm interested in any comments you have on this program.
X *		I can be mailed at "janc@crim.eecs.umich.edu".  Better yet,
X *		if you are into teleconferencing, call M-Net at (313) 994-6333
X *		and type "newuser" at the "login:" prompt to give yourself an
X *		account.  Send mail to janc, or join the "ugames" conference.
X *
X *		Have fun,
X *				  ___                _     __  _
X *				 (   >              ' )   /   // _/_
X *				  __/___.  ____      / / / __|/  /  _  __
X *				 / / (_/|_/ / <__   (_(_/ (_) \_<__</_/ (__
X *				<_/
X */
X
X/*
X * $Log:	cursive.c,v $
X * Revision 1.2  87/12/05  09:18:09  hyc
X * Added #ifdef's for MTS CBell, or Bell Labs C in MTS.
X * (The Michigan Terminal System, our homegrown IBM 370 OS. Funstuff.
X *  But hey, it was the first 370 OS with a real filesystem...  }-)
X * 
X */
X
X#include <stdio.h>
X#include "cursive.h"
X
char *buffer[6];	/* memory buffers to build up line in */
int c[6];		/* current index in each of the buffer lines */
int tail[6];		/* which buffer lines have tails in them */
int lasttail;		/* which line was the last letter's tail */
int space;		/* how much white space before the next letter */
int interspace = 1;	/* how much to spread adjacent letters out */
int taillen = 1;	/* how long the tails on ends of words should be */
char firstletter;	/* is this the first letter on the line? */
char message[256] = "";	/* message to print */
X
char *malloc();
X
main(argc,argv)
int argc;
char **argv;
X{
int i;
char *s,*m;
char ch;
X
X	m = message;
X	for (i = 1; i < argc; i++)
X	{
X		if (*argv[i] == '-')
X			switch(ch = argv[i][1])
X			{
X			case 'i':
X			case 't':
X				s = argv[i]+2;
X				if (*s == '\000')
X					if (++i < argc)
X						s = argv[i];
X				if (*s < '0' || *s > '9')
X				{
X					printf("%s: Illegal value %s\n",
X						argv[0],s);
X					exit(1);
X				}
X				if (ch == 'i')
X					interspace = atoi(s);
X				else
X					taillen = atoi(s);
X				break;
X			default:
X				printf("usage: %s [-tn] [-in] message\n",
X					argv[0]);
X				exit(1);
X			}
X		else
X		{
X			if (m != message)
X				*(m++) = ' ';
X			for (s=argv[i]; *s != '\000'; s++)
X				*(m++) = *s;
X		}
X	}
X	/* Do the deed */
X	if (m != message)
X	{
X		/* Message from the arg list */
X		*(m++) = 0;
X		prline(message);
X	}
X	else
X	{
X		/* Message from standard input */
X		while (gets(message) != NULL)
X			prline(message);
X	}
X}
X
X
X/* Add the given letter to the end of the current line */
X
place(let)
struct letter *let;
X{
int i,j,n;
int col;
int max = -10000;
char pad;
char *l;
X
X	if (firstletter)
X	{
X		col = space;		/* Leading spaces */
X		firstletter = 0;
X	}
X	else
X	{
X		/* Find the furthest left position we can place this letter */
X		for(i=0; i<6; i++)
X		{
X			if (let->line[i][0] != '\000' &&
X			    (col = c[i] - let->spcs[i]) > max)
X				max = col;
X		}
X
X		/* Insert some spaces between letters */
X		col = max + space + interspace;
X	}
X
X	for(i=0; i<6; i++)
X
X		/* If Nothing on this Line, Skip It */
X		if (let->line[i][0] != '\000')
X		{
X			/* Number of Spaces to Put on this Line? */
X			n = col - c[i] + let->spcs[i];
X
X			/* Flyers off Ends of Letters */
X			if (tail[i])
X				for (j = 0;
X				     j < 5 && n > space + 2; j++,n--)
X					buffer[i][c[i]++] = '_';
X
X			/* Connecting Lines Between Letters */
X			pad = (lasttail == i && let->tailin == i) ? '_' : ' ';
X
X			/* In the middle of the intersection of South and */
X			/* East University, someone is playing the piano. */
X			for ( ; n > 0; n--)
X				buffer[i][c[i]++] = pad;
X
X			/* Copy in the letter text */
X			for (l = let->line[i]; *l != '\000'; l++)
X				buffer[i][c[i]++] = *l;
X
X			tail[i] = (i == let->tailout);
X		}
X
X	lasttail = let->tailout;
X	space = 0;
X}
X
X/* Lengthen the last trailer by n */
tailer(n)
int n;
X{
int j;
X	if (lasttail >= 0)
X		for (j = 0; j < n; j++)
X			buffer[lasttail][c[lasttail]++] = '_';
X}
X
X/* Handle a line */
prline(s)
char *s;
X{
int l,i;
char *ch;
short lcode;
X
X#ifdef mts
X
int mode=&0x040, lnum=0;
X
X	etoa(s,strlen(s));
X#endif
X	lasttail = -1;
X	firstletter = 1;
X	space = 0;
X	/* Get some memory to put the output into */
X	l = strlen(s) * (CHARWIDTH + interspace);
X	for (i=0;i<6;i++)
X	{
X		buffer[i] = malloc((unsigned)l);
X		tail[i] = c[i] = 0;
X	}
X
X	/* do each letter */
X	for (ch=s; *ch != '\000'; ch++)
X	{
X
X		*ch &= '\177';
X		/* Find the letter */
X		lcode = (lasttail != 2) ? code1[*ch] : code2[*ch];
X		if (lcode >= 0)
X			place(&list[lcode]);
X		else
X			/* Various Special characters */
X			switch(lcode)
X			{
X			case SP:
X				/* Insert white space before next letter */
X				tailer(taillen);
X				space += 3;
X				lasttail = -1;
X				break;
X			case ST:
X				/* Lengthen the last tail */
X				if (lasttail >= 0)
X					buffer[lasttail][c[lasttail]++] = '_';
X				break;
X			}
X	}
X	tailer(taillen);
X
X	/* print the line and release the memory */
X	for (i=0;i<6;i++)
X	{
X#ifdef mts
X		lcode=(short)c[i];
X		mtswrite(buffer[i],&lcode,&mod,&lnum,"SPRINT  ");
X#else mts
X		buffer[i][c[i]++] = '\n';
X		write(1,buffer[i],c[i]);
X#endif mts
X		free(buffer[i]);
X	}
X}
END_OF_FILE
if test 7070 -ne `wc -c <'cursive-02/cursive.c'`; then
    echo shar: \"'cursive-02/cursive.c'\" unpacked with wrong size!
fi
# end of 'cursive-02/cursive.c'
fi
echo shar: End of archive 2 \(of 7\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
