Newsgroups: comp.sources.unix
From: davis@pacific.mps.ohio-state.edu (John E. Davis)
Subject: v26i149: most-3.2 -- more/less replacement, V3.2, Part02/02
Sender: unix-sources-moderator@vix.com
Approved: paul@vix.com

Submitted-By: davis@pacific.mps.ohio-state.edu (John E. Davis)
Posting-Number: Volume 26, Issue 149
Archive-Name: most-3.2/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 2)."
# Contents:  keym.c most.1 sysdep.c window.c
# Wrapped by vixie@gw.home.vix.com on Tue Apr 13 13:04:53 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'keym.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'keym.c'\"
else
echo shar: Extracting \"'keym.c'\" \(32690 characters\)
sed "s/^X//" >'keym.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "externs.h"  
X#include "keym.h"
X#include "sysdep.h"
X#include "display.h"
X#include "buffer.h"
X#include "window.h"
X#include "search.h"
X
int *DIGIT_ARG;
char LAST_CHAR;
int EDT_DIRECTION = 1;
X
void (*root_map[128])() =
X  {
X      beep_cmd,                 /* ^@ */
X      beep_cmd,                 /* ^A */
X      beep_cmd,                 /* ^B */
X      beep_cmd,                 /* ^C */
X      page_down_cmd,            /* ^D */
X      beep_cmd, /* ^E */
X      search_cmd,               /* ^F */
X      beep_cmd, /* ^G */
X      help_cmd,                 /* ^H */
X      page_right_cmd,           /* ^I */
X      next_line_cmd,            /* ^J */
X      ctrl_k_map_cmd,           /* ^K */
X      beep_cmd, /* ^L */
X      next_line_cmd,            /* ^M */
X      next_line_cmd,            /* ^N */
X      beep_cmd, /* ^O */
X      previous_line_cmd,        /* ^P */
X      beep_cmd, /* ^Q */
X      redraw_cmd,               /* ^R */
X      beep_cmd, /* ^S */
X      time_cmd,                 /* ^T */
X      page_up_cmd,              /* ^U */
X      page_down_cmd,            /* ^V */
X      ctrl_w_map_cmd,           /* ^W */
X      ctrl_x_map_cmd,           /* ^X */
X      beep_cmd, /* ^Y */
X      sys_spawn_cmd,            /* ^Z */
X      esc_map_cmd,              /* ^[ */
X      beep_cmd, /* ^\ */
X      beep_cmd, /* ^] */
X      beep_cmd, /* ^^ */
X      beep_cmd, /* ^_ */
X      page_down_cmd,            /*   */
X      beep_cmd, /* ! */
X      beep_cmd, /* " */
X      beep_cmd, /* # */
X      sys_spawn_cmd,            /* $ */
X      goto_percent_cmd,         /* % */
X      beep_cmd, /* & */
X      beep_cmd, /* ' */
X      beep_cmd, /* ( */
X      beep_cmd, /* ) */
X      beep_cmd, /* * */
X      beep_cmd, /* + */
X      goto_mark_cmd,            /* , */
X      digit_arg_cmd,            /* - */
X      beep_cmd, /* . */
X      search_cmd,               /* / */
X      digit_arg_cmd,            /* 0 */
X      digit_arg_cmd,            /* 1 */
X      digit_arg_cmd,            /* 2 */
X      digit_arg_cmd,            /* 3 */
X      digit_arg_cmd,            /* 4 */
X      digit_arg_cmd,            /* 5 */
X      digit_arg_cmd,            /* 6 */
X      digit_arg_cmd,            /* 7 */
X      digit_arg_cmd,            /* 8 */
X      digit_arg_cmd,            /* 9 */
X      extended_key_cmd,         /* : */
X      beep_cmd, /* ; */
X      page_left_cmd,            /* < */
X      beep_cmd, /* = */
X      page_right_cmd,           /* > */
X      search_back_cmd,          /* ? */
X      beep_cmd, /* @ */
X      beep_cmd, /* A */
X      end_of_buffer_cmd,        /* B */
X      beep_cmd, /* C */
X      page_down_cmd,            /* D */
X      edit_cmd, /* E */
X      search_cmd,               /* F */
X      goto_line_cmd,            /* G */
X      help_cmd,                 /* H */
X      beep_cmd, /* I */
X      goto_line_cmd,            /* J */
X      beep_cmd, /* K */
X      toggle_lock,              /* L */
X      set_mark_cmd,             /* M */
X      find_next_cmd,            /* N */
X      other_window_cmd,         /* O */
X      beep_cmd, /* P */
X      exit_cmd,                 /* Q */
X      redraw_cmd,               /* R */
X      beep_cmd, /* S */
X      top_of_buffer_cmd,        /* T */
X      page_up_cmd,              /* U */
X      next_line_cmd,            /* V */
X      toggle_width_cmd,         /* W */
X      exit_cmd, /* X */
X      beep_cmd, /* Y */
X      beep_cmd, /* Z */
X      beep_cmd, /* [ */
X      beep_cmd, /* \ */
X      beep_cmd, /* ] */
X      beep_cmd, /* ^ */
X      beep_cmd, /* _ */
X      beep_cmd, /* ` */
X      beep_cmd, /* a */
X      end_of_buffer_cmd,        /* b */
X      beep_cmd, /* c */
X      page_down_cmd,            /* d */
X      edit_cmd, /* e */
X      search_cmd,               /* f */
X      goto_line_cmd,            /* g */
X      help_cmd,                 /* h */
X      beep_cmd, /* i */
X      goto_line_cmd,            /* j */
X      beep_cmd, /* k */
X      toggle_lock,              /* l */
X      set_mark_cmd,             /* m */
X      find_next_cmd,            /* n */
X      other_window_cmd,         /* o */
X      beep_cmd, /* p */
X      exit_cmd,                 /* q */
X      redraw_cmd,               /* r */
X      beep_cmd, /* s */
X      top_of_buffer_cmd,        /* t */
X      page_up_cmd,              /* u */
X      next_line_cmd,            /* v */
X      toggle_width_cmd,         /* w */
X      exit_cmd, /* x */
X      beep_cmd, /* y */
X      beep_cmd, /* z */
X      beep_cmd, /* { */
X      beep_cmd, /* | */
X      beep_cmd, /* } */
X      beep_cmd, /* ~ */
X      page_up_cmd               /* ^? */
X    };
X
X/*  escape map  */
void (*escape_map[128])() =
X  {
X      beep_cmd, /* ^@ */
X      beep_cmd, /* ^A */
X      beep_cmd, /* ^B */
X      beep_cmd, /* ^C */
X      beep_cmd, /* ^D */
X      beep_cmd, /* ^E */
X      beep_cmd, /* ^F */
X      beep_cmd, /* ^G */
X      beep_cmd, /* ^H */
X      beep_cmd, /* ^I */
X      beep_cmd, /* ^J */
X      beep_cmd, /* ^K */
X      beep_cmd, /* ^L */
X      beep_cmd, /* ^M */
X      beep_cmd, /* ^N */
X      beep_cmd, /* ^O */
X      beep_cmd, /* ^P */
X      beep_cmd, /* ^Q */
X      beep_cmd, /* ^R */
X      beep_cmd, /* ^S */
X      beep_cmd, /* ^T */
X      beep_cmd, /* ^U */
X      beep_cmd, /* ^V */
X      beep_cmd, /* ^W */
X      beep_cmd, /* ^X */
X      beep_cmd, /* ^Y */
X      beep_cmd, /* ^Z */
X      beep_cmd, /* ^[ */
X      beep_cmd, /* ^\ */
X      beep_cmd, /* ^] */
X      beep_cmd, /* ^^ */
X      beep_cmd, /* ^_ */
X      beep_cmd, /*   */
X      beep_cmd, /* ! */
X      beep_cmd, /* " */
X      beep_cmd, /* # */
X      sys_spawn_cmd,            /* $ */
X      beep_cmd, /* % */
X      beep_cmd, /* & */
X      beep_cmd, /* ' */
X      beep_cmd, /* ( */
X      beep_cmd, /* ) */
X      beep_cmd, /* * */
X      beep_cmd, /* + */
X      beep_cmd, /* , */
X      digit_arg_cmd,            /* - */
X      beep_cmd, /* . */
X      beep_cmd, /* / */
X      beep_cmd, /* 0 */
X      digit_arg_cmd,            /* 1 */
X      digit_arg_cmd,            /* 2 */
X      digit_arg_cmd,            /* 3 */
X      digit_arg_cmd,            /* 4 */
X      digit_arg_cmd,            /* 5 */
X      digit_arg_cmd,            /* 6 */
X      digit_arg_cmd,            /* 7 */
X      digit_arg_cmd,            /* 8 */
X      digit_arg_cmd,            /* 9 */
X      beep_cmd, /* : */
X      beep_cmd, /* ; */
X      beep_cmd, /* < */
X      beep_cmd, /* = */
X      beep_cmd, /* > */
X      beep_cmd, /* ? */
X      beep_cmd, /* @ */
X      beep_cmd, /* A */
X      beep_cmd, /* B */
X      beep_cmd, /* C */
X      beep_cmd, /* D */
X      beep_cmd, /* E */
X      beep_cmd, /* F */
X      beep_cmd, /* G */
X      beep_cmd, /* H */
X      beep_cmd, /* I */
X      beep_cmd, /* J */
X      beep_cmd, /* K */
X      beep_cmd, /* L */
X      beep_cmd, /* M */
X      beep_cmd, /* N */
X      O_map_cmd,                /* O */
X      beep_cmd, /* P */
X      beep_cmd, /* Q */
X      beep_cmd, /* R */
X      beep_cmd, /* S */
X      beep_cmd, /* T */
X      beep_cmd, /* U */
X      beep_cmd, /* V */
X      beep_cmd, /* W */
X      extended_cmd_cmd,         /* X */
X      beep_cmd, /* Y */
X      beep_cmd, /* Z */
X      O_map_cmd,                /* [ */
X      beep_cmd, /* \ */
X      beep_cmd, /* ] */
X      beep_cmd, /* ^ */
X      beep_cmd, /* _ */
X      beep_cmd, /* ` */
X      beep_cmd, /* a */
X      beep_cmd, /* b */
X      beep_cmd, /* c */
X      beep_cmd, /* d */
X      beep_cmd, /* e */
X      beep_cmd, /* f */
X      beep_cmd, /* g */
X      beep_cmd, /* h */
X      beep_cmd, /* i */
X      beep_cmd, /* j */
X      beep_cmd, /* k */
X      beep_cmd, /* l */
X      beep_cmd, /* m */
X      beep_cmd, /* n */
X      beep_cmd, /* o */
X      beep_cmd, /* p */
X      beep_cmd, /* q */
X      beep_cmd, /* r */
X      beep_cmd, /* s */
X      beep_cmd, /* t */
X      beep_cmd, /* u */
X      beep_cmd, /* v */
X      beep_cmd, /* w */
X      extended_cmd_cmd,         /* x */
X      beep_cmd, /* y */
X      beep_cmd, /* z */
X      beep_cmd, /* { */
X      beep_cmd, /* | */
X      beep_cmd, /* } */
X      beep_cmd, /* ~ */
X      beep_cmd  /* ^? */
X  };
X
void (*ctrl_x_map[128])() =
X  {
X      beep_cmd, /* ^@ */
X      beep_cmd, /* ^A */
X      beep_cmd, /* ^B */
X      exit_cmd, /* ^C */
X      beep_cmd, /* ^D */
X      beep_cmd, /* ^E */
X      find_file_cmd,            /* ^F */
X      beep_cmd, /* ^G */
X      beep_cmd, /* ^H */
X      beep_cmd, /* ^I */
X      beep_cmd, /* ^J */
X      beep_cmd, /* ^K */
X      beep_cmd, /* ^L */
X      beep_cmd, /* ^M */
X      beep_cmd, /* ^N */
X      beep_cmd, /* ^O */
X      beep_cmd, /* ^P */
X      beep_cmd, /* ^Q */
X      beep_cmd, /* ^R */
X      beep_cmd, /* ^S */
X      beep_cmd, /* ^T */
X      beep_cmd, /* ^U */
X      beep_cmd, /* ^V */
X      beep_cmd, /* ^W */
X      beep_cmd, /* ^X */
X      beep_cmd, /* ^Y */
X      beep_cmd, /* ^Z */
X      beep_cmd, /* ^[ */
X      beep_cmd, /* ^\ */
X      beep_cmd, /* ^] */
X      beep_cmd, /* ^^ */
X      beep_cmd, /* ^_ */
X      beep_cmd, /*   */
X      beep_cmd, /* ! */
X      beep_cmd, /* " */
X      beep_cmd, /* # */
X      beep_cmd, /* $ */
X      beep_cmd, /* % */
X      beep_cmd, /* & */
X      beep_cmd, /* ' */
X      beep_cmd, /* ( */
X      beep_cmd, /* ) */
X      beep_cmd, /* * */
X      beep_cmd, /* + */
X      beep_cmd, /* , */
X      beep_cmd, /* - */
X      beep_cmd, /* . */
X      beep_cmd, /* / */
X      del_window_cmd,           /* 0 */
X      one_window_cmd,           /* 1 */
X      two_window_cmd,           /* 2 */
X      beep_cmd, /* 3 */
X      beep_cmd, /* 4 */
X      beep_cmd, /* 5 */
X      beep_cmd, /* 6 */
X      beep_cmd, /* 7 */
X      beep_cmd, /* 8 */
X      beep_cmd, /* 9 */
X      beep_cmd, /* : */
X      beep_cmd, /* ; */
X      beep_cmd, /* < */
X      beep_cmd, /* = */
X      beep_cmd, /* > */
X      beep_cmd, /* ? */
X      beep_cmd, /* @ */
X      beep_cmd, /* A */
X      beep_cmd, /* B */
X      beep_cmd, /* C */
X      beep_cmd, /* D */
X      beep_cmd, /* E */
X      beep_cmd, /* F */
X      beep_cmd, /* G */
X      beep_cmd, /* H */
X      beep_cmd, /* I */
X      beep_cmd, /* J */
X      beep_cmd, /* K */
X      beep_cmd, /* L */
X      beep_cmd, /* M */
X      beep_cmd, /* N */
X      other_window_cmd,         /* O */
X      beep_cmd, /* P */
X      beep_cmd, /* Q */
X      beep_cmd, /* R */
X      beep_cmd, /* S */
X      beep_cmd, /* T */
X      beep_cmd, /* U */
X      beep_cmd, /* V */
X      beep_cmd, /* W */
X      beep_cmd, /* X */
X      beep_cmd, /* Y */
X      beep_cmd, /* Z */
X      beep_cmd, /* [ */
X      beep_cmd, /* \ */
X      beep_cmd, /* ] */
X      beep_cmd, /* ^ */
X      beep_cmd, /* _ */
X      beep_cmd, /* ` */
X      beep_cmd, /* a */
X      beep_cmd, /* b */
X      beep_cmd, /* c */
X      beep_cmd, /* d */
X      beep_cmd, /* e */
X      beep_cmd, /* f */
X      beep_cmd, /* g */
X      beep_cmd, /* h */
X      beep_cmd, /* i */
X      beep_cmd, /* j */
X      beep_cmd, /* k */
X      beep_cmd, /* l */
X      beep_cmd, /* m */
X      beep_cmd, /* n */
X      other_window_cmd,         /* o */
X      beep_cmd, /* p */
X      beep_cmd, /* q */
X      beep_cmd, /* r */
X      beep_cmd, /* s */
X      beep_cmd, /* t */
X      beep_cmd, /* u */
X      beep_cmd, /* v */
X      beep_cmd, /* w */
X      beep_cmd, /* x */
X      beep_cmd, /* y */
X      beep_cmd, /* z */
X      beep_cmd, /* { */
X      beep_cmd, /* | */
X      beep_cmd, /* } */
X      beep_cmd, /* ~ */
X      beep_cmd  /* ^? */
X  };
X
void (*ctrl_w_map[128])() =
X  {
X      beep_cmd, /* ^@ */
X      beep_cmd, /* ^A */
X      beep_cmd, /* ^B */
X      beep_cmd, /* ^C */
X      beep_cmd, /* ^D */
X      beep_cmd, /* ^E */
X      beep_cmd, /* ^F */
X      beep_cmd, /* ^G */
X      beep_cmd, /* ^H */
X      beep_cmd, /* ^I */
X      beep_cmd, /* ^J */
X      beep_cmd, /* ^K */
X      beep_cmd, /* ^L */
X      beep_cmd, /* ^M */
X      beep_cmd, /* ^N */
X      beep_cmd, /* ^O */
X      beep_cmd, /* ^P */
X      beep_cmd, /* ^Q */
X      beep_cmd, /* ^R */
X      beep_cmd, /* ^S */
X      beep_cmd, /* ^T */
X      beep_cmd, /* ^U */
X      beep_cmd, /* ^V */
X      beep_cmd, /* ^W */
X      beep_cmd, /* ^X */
X      beep_cmd, /* ^Y */
X      beep_cmd, /* ^Z */
X      beep_cmd, /* ^[ */
X      beep_cmd, /* ^\ */
X      beep_cmd, /* ^] */
X      beep_cmd, /* ^^ */
X      beep_cmd, /* ^_ */
X      beep_cmd, /*   */
X      beep_cmd, /* ! */
X      beep_cmd, /* " */
X      beep_cmd, /* # */
X      beep_cmd, /* $ */
X      beep_cmd, /* % */
X      beep_cmd, /* & */
X      beep_cmd, /* ' */
X      beep_cmd, /* ( */
X      beep_cmd, /* ) */
X      beep_cmd, /* * */
X      beep_cmd, /* + */
X      beep_cmd, /* , */
X      beep_cmd, /* - */
X      beep_cmd, /* . */
X      beep_cmd, /* / */
X      del_window_cmd,           /* 0 */
X      one_window_cmd,           /* 1 */
X      two_window_cmd,           /* 2 */
X      beep_cmd, /* 3 */
X      beep_cmd, /* 4 */
X      beep_cmd, /* 5 */
X      beep_cmd, /* 6 */
X      beep_cmd, /* 7 */
X      beep_cmd, /* 8 */
X      beep_cmd, /* 9 */
X      beep_cmd, /* : */
X      beep_cmd, /* ; */
X      beep_cmd, /* < */
X      beep_cmd, /* = */
X      beep_cmd, /* > */
X      beep_cmd, /* ? */
X      beep_cmd, /* @ */
X      beep_cmd, /* A */
X      beep_cmd, /* B */
X      beep_cmd, /* C */
X      beep_cmd, /* D */
X      beep_cmd, /* E */
X      beep_cmd, /* F */
X      beep_cmd, /* G */
X      beep_cmd, /* H */
X      beep_cmd, /* I */
X      beep_cmd, /* J */
X      beep_cmd, /* K */
X      beep_cmd, /* L */
X      beep_cmd, /* M */
X      beep_cmd, /* N */
X      other_window_cmd,         /* O */
X      beep_cmd, /* P */
X      beep_cmd, /* Q */
X      beep_cmd, /* R */
X      beep_cmd, /* S */
X      beep_cmd, /* T */
X      beep_cmd, /* U */
X      beep_cmd, /* V */
X      beep_cmd, /* W */
X      beep_cmd, /* X */
X      beep_cmd, /* Y */
X      beep_cmd, /* Z */
X      beep_cmd, /* [ */
X      beep_cmd, /* \ */
X      beep_cmd, /* ] */
X      beep_cmd, /* ^ */
X      beep_cmd, /* _ */
X      beep_cmd, /* ` */
X      beep_cmd, /* a */
X      beep_cmd, /* b */
X      beep_cmd, /* c */
X      beep_cmd, /* d */
X      beep_cmd, /* e */
X      beep_cmd, /* f */
X      beep_cmd, /* g */
X      beep_cmd, /* h */
X      beep_cmd, /* i */
X      beep_cmd, /* j */
X      beep_cmd, /* k */
X      beep_cmd, /* l */
X      beep_cmd, /* m */
X      beep_cmd, /* n */
X      other_window_cmd, /* o */
X      beep_cmd, /* p */
X      beep_cmd, /* q */
X      beep_cmd, /* r */
X      beep_cmd, /* s */
X      beep_cmd, /* t */
X      beep_cmd, /* u */
X      beep_cmd, /* v */
X      beep_cmd, /* w */
X      beep_cmd, /* x */
X      beep_cmd, /* y */
X      beep_cmd, /* z */
X      beep_cmd, /* { */
X      beep_cmd, /* | */
X      beep_cmd, /* } */
X      beep_cmd, /* ~ */
X      beep_cmd  /* ^? */
X  };
X
void (*ctrl_k_map[128])() =
X  {
X      beep_cmd, /* ^@ */
X      beep_cmd, /* ^A */
X      set_mark_cmd,             /* ^B */
X      beep_cmd, /* ^C */
X      beep_cmd, /* ^D */
X      beep_cmd, /* ^E */
X      beep_cmd, /* ^F */
X      beep_cmd, /* ^G */
X      beep_cmd, /* ^H */
X      beep_cmd, /* ^I */
X      goto_mark_cmd,            /* ^J */
X      beep_cmd, /* ^K */
X      beep_cmd, /* ^L */
X      goto_mark_cmd,            /* ^M */
X      beep_cmd, /* ^N */
X      beep_cmd, /* ^O */
X      beep_cmd, /* ^P */
X      beep_cmd, /* ^Q */
X      beep_cmd, /* ^R */
X      beep_cmd, /* ^S */
X      beep_cmd, /* ^T */
X      beep_cmd, /* ^U */
X      beep_cmd, /* ^V */
X      beep_cmd, /* ^W */
X      beep_cmd, /* ^X */
X      beep_cmd, /* ^Y */
X      beep_cmd, /* ^Z */
X      beep_cmd, /* ^[ */
X      beep_cmd, /* ^\ */
X      beep_cmd, /* ^] */
X      beep_cmd, /* ^^ */
X      beep_cmd, /* ^_ */
X      beep_cmd, /*   */
X      beep_cmd, /* ! */
X      beep_cmd, /* " */
X      beep_cmd, /* # */
X      beep_cmd, /* $ */
X      beep_cmd, /* % */
X      beep_cmd, /* & */
X      beep_cmd, /* ' */
X      beep_cmd, /* ( */
X      beep_cmd, /* ) */
X      beep_cmd, /* * */
X      beep_cmd, /* + */
X      beep_cmd, /* , */
X      beep_cmd, /* - */
X      beep_cmd, /* . */
X      beep_cmd, /* / */
X      beep_cmd, /* 0 */
X      beep_cmd, /* 1 */
X      beep_cmd, /* 2 */
X      beep_cmd, /* 3 */
X      beep_cmd, /* 4 */
X      beep_cmd, /* 5 */
X      beep_cmd, /* 6 */
X      beep_cmd, /* 7 */
X      beep_cmd, /* 8 */
X      beep_cmd, /* 9 */
X      beep_cmd, /* : */
X      beep_cmd, /* ; */
X      beep_cmd, /* < */
X      beep_cmd, /* = */
X      beep_cmd, /* > */
X      beep_cmd, /* ? */
X      beep_cmd, /* @ */
X      beep_cmd, /* A */
X      beep_cmd, /* B */
X      beep_cmd, /* C */
X      extended_cmd_cmd,         /* D */
X      exit_cmd,                 /* E */
X      beep_cmd, /* F */
X      find_file_cmd,            /* G */
X      beep_cmd, /* H */
X      beep_cmd, /* I */
X      beep_cmd, /* J */
X      beep_cmd, /* K */
X      beep_cmd, /* L */
X      set_mark_cmd,             /* M */
X      beep_cmd, /* N */
X      beep_cmd, /* O */
X      beep_cmd, /* P */
X      beep_cmd, /* Q */
X      beep_cmd, /* R */
X      beep_cmd, /* S */
X      beep_cmd, /* T */
X      beep_cmd, /* U */
X      beep_cmd, /* V */
X      beep_cmd, /* W */
X      beep_cmd, /* X */
X      beep_cmd, /* Y */
X      beep_cmd, /* Z */
X      beep_cmd, /* [ */
X      beep_cmd, /* \ */
X      beep_cmd, /* ] */
X      beep_cmd, /* ^ */
X      beep_cmd, /* _ */
X      beep_cmd, /* ` */
X      beep_cmd, /* a */
X      beep_cmd, /* b */
X      beep_cmd, /* c */
X      extended_cmd_cmd,         /* d */
X      exit_cmd,                 /* e */
X      beep_cmd, /* f */
X      find_file_cmd,            /* g */
X      beep_cmd, /* h */
X      beep_cmd, /* i */
X      beep_cmd, /* j */
X      beep_cmd, /* k */
X      beep_cmd, /* l */
X      set_mark_cmd,             /* m */
X      beep_cmd, /* n */
X      beep_cmd, /* o */
X      beep_cmd, /* p */
X      beep_cmd, /* q */
X      beep_cmd, /* r */
X      beep_cmd, /* s */
X      beep_cmd, /* t */
X      beep_cmd, /* u */
X      beep_cmd, /* v */
X      beep_cmd, /* w */
X      beep_cmd, /* x */
X      beep_cmd, /* y */
X      beep_cmd, /* z */
X      beep_cmd, /* { */
X      beep_cmd, /* | */
X      beep_cmd, /* } */
X      beep_cmd, /* ~ */
X      beep_cmd  /* ^? */
X  };
X
void (*esc_O_map[128])() =
X  {
X      beep_cmd, /* ^@ */
X      beep_cmd, /* ^A */
X      beep_cmd, /* ^B */
X      beep_cmd, /* ^C */
X      beep_cmd, /* ^D */
X      beep_cmd, /* ^E */
X      beep_cmd, /* ^F */
X      beep_cmd, /* ^G */
X      beep_cmd, /* ^H */
X      beep_cmd, /* ^I */
X      beep_cmd, /* ^J */
X      beep_cmd, /* ^K */
X      beep_cmd, /* ^L */
X      beep_cmd, /* ^M */
X      beep_cmd, /* ^N */
X      beep_cmd, /* ^O */
X      beep_cmd, /* ^P */
X      beep_cmd, /* ^Q */
X      beep_cmd, /* ^R */
X      beep_cmd, /* ^S */
X      beep_cmd, /* ^T */
X      beep_cmd, /* ^U */
X      beep_cmd, /* ^V */
X      beep_cmd, /* ^W */
X      beep_cmd, /* ^X */
X      beep_cmd, /* ^Y */
X      beep_cmd, /* ^Z */
X      beep_cmd, /* ^[ */
X      beep_cmd, /* ^\ */
X      beep_cmd, /* ^] */
X      beep_cmd, /* ^^ */
X      beep_cmd, /* ^_ */
X      beep_cmd, /*   */
X      beep_cmd, /* ! */
X      beep_cmd, /* " */
X      beep_cmd, /* # */
X      beep_cmd, /* $ */
X      beep_cmd, /* % */
X      beep_cmd, /* & */
X      beep_cmd, /* ' */
X      beep_cmd, /* ( */
X      beep_cmd, /* ) */
X      beep_cmd, /* * */
X      beep_cmd, /* + */
X      beep_cmd, /* , */
X      beep_cmd, /* - */
X      beep_cmd, /* . */
X      beep_cmd, /* / */
X      dec_extended_map_cmd,     /* 0 */
X      dec_extended_map_cmd,     /* 1 */
X      dec_extended_map_cmd,     /* 2 */
X      dec_extended_map_cmd,     /* 3 */
X      dec_extended_map_cmd,     /* 4 */
X      dec_extended_map_cmd,     /* 5 */
X      dec_extended_map_cmd,     /* 6 */
X      dec_extended_map_cmd,     /* 7 */
X      dec_extended_map_cmd,     /* 8 */
X      dec_extended_map_cmd,     /* 9 */
X      beep_cmd, /* : */
X      beep_cmd, /* ; */
X      beep_cmd, /* < */
X      beep_cmd, /* = */
X      beep_cmd, /* > */
X      beep_cmd, /* ? */
X      beep_cmd, /* @ */
X      previous_line_cmd,        /* A */
X      next_line_cmd,            /* B */
X      page_right_cmd,           /* C */
X      page_left_cmd,            /* D */
X      beep_cmd, /* E */
X      beep_cmd, /* F */
X      beep_cmd, /* G */
X      beep_cmd, /* H */
X      beep_cmd, /* I */
X      beep_cmd, /* J */
X      beep_cmd, /* K */
X      beep_cmd, /* L */
X      next_line_cmd, /* M */
X      beep_cmd, /* N */
X      beep_cmd, /* O */
X      pf1_map_cmd, /* P */	/* PF1 */
X      help_cmd, /* Q */ /* PF2 */
X      edt_find_next_cmd, /* R */ /* PF3 */
X      beep_cmd, /* S */ /* PF4 */
X      beep_cmd, /* T */
X      beep_cmd, /* U */
X      beep_cmd, /* V */
X      beep_cmd, /* W */
X      beep_cmd, /* X */
X      beep_cmd, /* Y */
X      beep_cmd, /* Z */
X      beep_cmd, /* [ */
X      beep_cmd, /* \ */
X      beep_cmd, /* ] */
X      beep_cmd, /* ^ */
X      beep_cmd, /* _ */
X      beep_cmd, /* ` */
X      beep_cmd, /* a */
X      beep_cmd, /* b */
X      beep_cmd, /* c */
X      beep_cmd, /* d */
X      beep_cmd, /* e */
X      beep_cmd, /* f */
X      beep_cmd, /* g */
X      beep_cmd, /* h */
X      beep_cmd, /* i */
X      beep_cmd, /* j */
X      beep_cmd, /* k */
X      beep_cmd, /* l */
X      beep_cmd, /* m */
X      set_mark_cmd, /* n */
X      beep_cmd, /* o */
X      edt_line_cmd, /* p */ /* KP0 */
X      beep_cmd, /* q */ /* KP1 */
X      beep_cmd, /* r */ /* KP2 */
X      beep_cmd, /* s */ /* KP3 */
X      edt_forward_cmd, /* t */ /* KP4 */
X      edt_back_cmd, /* u */ /* KP5 */
X      beep_cmd, /* v */ /* KP6 */
X      beep_cmd, /* w */ /* KP7 */
X      edt_page_cmd, /* x */ /* KP8 */
X      beep_cmd, /* y */ /* KP9 */
X      beep_cmd, /* z */
X      beep_cmd, /* { */
X      beep_cmd, /* | */
X      beep_cmd, /* } */
X      beep_cmd, /* ~ */
X      beep_cmd  /* ^? */
X  };
X
void (*pf1_map[128])() =	/* Gold */
X  {
X      beep_cmd, /* ^@ */
X      beep_cmd, /* ^A */
X      beep_cmd, /* ^B */
X      beep_cmd, /* ^C */
X      beep_cmd, /* ^D */
X      beep_cmd, /* ^E */
X      beep_cmd, /* ^F */
X      beep_cmd, /* ^G */
X      beep_cmd, /* ^H */
X      beep_cmd, /* ^I */
X      beep_cmd, /* ^J */
X      beep_cmd, /* ^K */
X      beep_cmd, /* ^L */
X      beep_cmd, /* ^M */
X      beep_cmd, /* ^N */
X      beep_cmd, /* ^O */
X      beep_cmd, /* ^P */
X      beep_cmd, /* ^Q */
X      beep_cmd, /* ^R */
X      beep_cmd, /* ^S */
X      beep_cmd, /* ^T */
X      beep_cmd, /* ^U */
X      beep_cmd, /* ^V */
X      beep_cmd, /* ^W */
X      beep_cmd, /* ^X */
X      beep_cmd, /* ^Y */
X      beep_cmd, /* ^Z */
X      pf1_esc_map_cmd, /* ^[ */
X      beep_cmd, /* ^\ */
X      beep_cmd, /* ^] */
X      beep_cmd, /* ^^ */
X      beep_cmd, /* ^_ */
X      beep_cmd, /*   */
X      beep_cmd, /* ! */
X      beep_cmd, /* " */
X      beep_cmd, /* # */
X      beep_cmd, /* $ */
X      beep_cmd, /* % */
X      beep_cmd, /* & */
X      beep_cmd, /* ' */
X      beep_cmd, /* ( */
X      beep_cmd, /* ) */
X      beep_cmd, /* * */
X      beep_cmd, /* + */
X      beep_cmd, /* , */
X      beep_cmd, /* - */
X      beep_cmd, /* . */
X      beep_cmd, /* / */
X      digit_arg_cmd, /* 0 */
X      digit_arg_cmd, /* 1 */
X      digit_arg_cmd, /* 2 */
X      digit_arg_cmd, /* 3 */
X      digit_arg_cmd, /* 4 */
X      digit_arg_cmd, /* 5 */
X      digit_arg_cmd, /* 6 */
X      digit_arg_cmd, /* 7 */
X      digit_arg_cmd, /* 8 */
X      digit_arg_cmd, /* 9 */
X      beep_cmd, /* : */
X      beep_cmd, /* ; */
X      beep_cmd, /* < */
X      beep_cmd, /* = */
X      beep_cmd, /* > */
X      beep_cmd, /* ? */
X      beep_cmd, /* @ */
X      beep_cmd, /* A */
X      beep_cmd, /* B */
X      beep_cmd, /* C */
X      beep_cmd, /* D */
X      beep_cmd, /* E */
X      beep_cmd, /* F */
X      beep_cmd, /* G */
X      beep_cmd, /* H */
X      beep_cmd, /* I */
X      beep_cmd, /* J */
X      beep_cmd, /* K */
X      beep_cmd, /* L */
X      beep_cmd, /* M */
X      beep_cmd, /* N */
X      one_window_cmd, /* O */
X      beep_cmd, /* P */
X      exit_cmd, /* Q */
X      beep_cmd, /* R */
X      sys_spawn_cmd, /* S */
X      beep_cmd, /* T */
X      beep_cmd, /* U */
X      del_window_cmd, /* V */
X      beep_cmd, /* W */
X      two_window_cmd, /* X */
X      beep_cmd, /* Y */
X      beep_cmd, /* Z */
X      beep_cmd, /* [ */
X      beep_cmd, /* \ */
X      beep_cmd, /* ] */
X      beep_cmd, /* ^ */
X      beep_cmd, /* _ */
X      beep_cmd, /* ` */
X      beep_cmd, /* a */
X      beep_cmd, /* b */
X      beep_cmd, /* c */
X      beep_cmd, /* d */
X      beep_cmd, /* e */
X      beep_cmd, /* f */
X      beep_cmd, /* g */
X      beep_cmd, /* h */
X      beep_cmd, /* i */
X      beep_cmd, /* j */
X      beep_cmd, /* k */
X      beep_cmd, /* l */
X      beep_cmd, /* m */
X      beep_cmd, /* n */
X      one_window_cmd, /* o */
X      beep_cmd, /* p */
X      exit_cmd, /* q */
X      beep_cmd, /* r */
X      sys_spawn_cmd, /* s */
X      beep_cmd, /* t */
X      beep_cmd, /* u */
X      del_window_cmd, /* v */
X      beep_cmd, /* w */
X      two_window_cmd, /* x */
X      beep_cmd, /* y */
X      beep_cmd, /* z */
X      beep_cmd, /* { */
X      beep_cmd, /* | */
X      beep_cmd, /* } */
X      beep_cmd, /* ~ */
X      beep_cmd  /* ^? */
X  };
X
void execute_key()
X{
X    char ch;
X    int r,c;
X    c = CURS_COL - COLUMN + 1;
X    r = CURS_ROW;
X    if (MINI_BUF[0] != '\0') put_message();
X    if (r < 1) r = 1;
X    else if (r > (WIN->bot - WIN->top + 1))
X      r = WIN->bot - WIN->top + 1;
X    if (c > SCREEN_WIDTH) c = SCREEN_WIDTH;
X    else if (c < 1) c = 1;
X    goto_rc(r,c);
X    fflush(stdout);
X    DIGIT_ARG = (int *) NULL;
X    ch = getkey();
X    if (MINI_BUF[0] != '\0') clear_minibuffer();
X    LAST_CHAR = ch;
X    (*root_map[ (int) ch ])();
X}
X
void ctrl_x_map_cmd()
X{
X    char ch;
X
X    ch = getkey();
X    (*ctrl_x_map[ (int) ch ])();
X}
X
void ctrl_k_map_cmd()
X{
X    char ch;
X
X    ch = getkey();
X    (*ctrl_k_map[ (int) ch ])();
X}
X
void ctrl_w_map_cmd()
X{
X    char ch;
X
X    ch = getkey();
X    (*ctrl_w_map[ (int) ch ])();
X}
X
void O_map_cmd()
X{
X    char ch;
X
X    ch = getkey();
X    LAST_CHAR = ch;
X    (*esc_O_map[ (int) ch ])();
X}
X
void esc_map_cmd()
X{
X    char ch;
X
X    ch = getkey();
X    LAST_CHAR = ch;
X    (*escape_map[ (int) ch ])();
X}
X
X/* weird sequences of form ^[[n~ where n is an integer */
void dec_extended_map_cmd()
X{
X    char ch, numstr[5];
X    int i, num;
X    
X    ch = LAST_CHAR;  /* should be integer */
X    i = 0;
X    numstr[i++] = ch;
X 
X    while (ch = getkey(), isdigit(ch)) numstr[i++] = ch;
X    if (ch == '~')
X      {
X          numstr[i++] =  '\0';
X          sscanf(numstr,"%d",&num);
X          switch (num)
X            {
X              case 5:
X                page_up_cmd(); break; /* prev screen */
X              case 6:
X                page_down_cmd(); break; /* next screen */
X              case 1:
X                search_cmd(); break; /* find */
X              case 4:
X                set_mark_cmd(); break; /* select */
X              case 2:   
X                goto_mark_cmd(); break; /* insert here */
X              case 28:
X                help_cmd(); break; /* Help */
X              case 29:  /* do */
X                extended_cmd_cmd(); break;
X              default:
X                beep_cmd(); break;
X            }
X      }
X    else beep_cmd();
X}
X
X/* weird sequences of form ^[[n~ where n is an integer */
void pf1_esc_map_cmd()
X{
X    char ch, numstr[5];
X    int i, num;
X    
X    LAST_CHAR = ch = getkey();
X    switch (ch)
X	{
X	case 'O':
X	    LAST_CHAR = ch = getkey();
X	    switch (ch)
X		{
X		case 't': /* KP4 */
X		    end_of_buffer_cmd(); break;
X		case 'u': /* KP5 */
X		    top_of_buffer_cmd(); break;
X		case 'w': /* KP7 */
X		    extended_cmd_cmd(); break;
X		case 'n': /* KP7 */
X		    goto_mark_cmd(); break;
X		case 'R': /* PF3 */
X		    edt_find_cmd(); break;
X		default :
X		    beep_cmd(); break;
X		}
X	    break;
X	case '[':
X	    LAST_CHAR = ch = getkey();
X	    switch (ch)
X		{
X		case 'A':
X		    other_window_cmd(); break;
X		case 'B':
X		    other_window_cmd(); break;
X		case 'C':
X		    page_left_cmd(); break;
X		case 'D':
X		    page_right_cmd(); break;
X		default :
X		    beep_cmd(); break;
X		};
X	    break;
X	default :
X            beep_cmd(); break;
X	}
X}
X
void pf1_map_cmd()
X{
X    char ch;
X
X    ch = getkey();
X    LAST_CHAR = ch;
X    (*pf1_map[ (int) ch ])();
X}
X
void beep_cmd()
X{
X    fputc('\007',stdout);
X}
X
void page_down_cmd()
X{
X    int n = 1;
X    if (DIGIT_ARG != (int *) NULL) n = *DIGIT_ARG;
X    update_windows(C_LINE + n * (WIN->bot - WIN->top + 1));
X}
void page_up_cmd()
X{
X    int n = 1;
X    if (DIGIT_ARG != (int *) NULL) n = *DIGIT_ARG;
X    update_windows(C_LINE - n * (WIN->bot - WIN->top + 1));
X}
X
void page_right_cmd()
X{
X    int n = 1;
X    if (DIGIT_ARG != (int *) NULL) n = *DIGIT_ARG;
X    COLUMN = COLUMN + n * 59;
X    update_windows(C_LINE);
X}
X
void page_left_cmd()
X{
X    int n = 1;
X    if (DIGIT_ARG != (int *) NULL) n = *DIGIT_ARG;
X    COLUMN = COLUMN - n * 59;
X    update_windows(C_LINE);
X}
X
void next_line_cmd()
X{
X    int n = 1;
X    if (DIGIT_ARG != (int *) NULL) n = *DIGIT_ARG;
X    update_windows(C_LINE + n);
X}
X
void previous_line_cmd()
X{
X    int n = 1;
X    if (DIGIT_ARG != (int *) NULL) n = *DIGIT_ARG;
X    update_windows(C_LINE - n);
X}
X
void top_of_buffer_cmd()
X{
X    update_windows(1);
X}
X
void end_of_buffer_cmd()
X{
X    update_windows(NUM_LINES);
X}
X
extern void sys_spawn_cmd()
X{
X    int update = 0;
X    reset_tty();
X    reset_display();
X    fflush(stdout);
X#ifdef VMS
X    if (LAST_CHAR == '\032') exit(0);
X    if (do_shell_command()) update = 1; /* scroll region reset by message facility */
X#else                          
X    killpg(getpgrp(0),18);
X    update = 1;
X#endif
X    init_tty();
X    if (update) redraw_display();
X}
X
void redraw_cmd()
X{
X    redraw_display();
X}
X
void goto_line_cmd()
X{
X    int n = C_LINE;
X    if (DIGIT_ARG != (int *) NULL) n = *DIGIT_ARG;
X    else
X      {
X          MINI_BUF[0] = 0;
X          if (!read_from_minibuffer("Line: ", MINI_BUF)) return;
X          sscanf(MINI_BUF,"%d",&n);
X          MINI_BUF[0] = 0;
X      }
X    update_windows(n);
X}
X
void goto_percent_cmd()
X{
X    unsigned char *pos;
X    int n;
X    if (DIGIT_ARG != (int *) NULL) n = *DIGIT_ARG;
X    else
X      {
X          MINI_BUF[0] = 0;
X          if (!read_from_minibuffer("%: ", MINI_BUF)) return;
X          sscanf(MINI_BUF,"%d",&n);
X          MINI_BUF[0] = 0;
X      }
X    if (n < 0) n = 0; else if (n > 100) n = 100;
X    pos = BEG + (int) (n * (int) (EOB - BEG)) / 100;
X    n = what_line(pos);
X    update_windows(n);
X}
X
void extended_key_cmd()
X{
X    if (-1 == do_extended_key()) exit_cmd();
X}
X
void extended_cmd_cmd()
X{
X    if (-1 == do_extended_cmd()) exit_cmd();
X}
X
void set_mark_cmd()
X{
X    BUF->mark = C_LINE;
X    message("Mark Set.",0);
X}
X
void goto_mark_cmd()
X{
X    int mark = BUF->mark;
X    BUF->mark = C_LINE;
X    update_window(mark);
X    message("Mark Set.",0);
X}
X
void one_window_cmd()
X{
X    one_window();
X}
X
void two_window_cmd()
X{
X    two_windows();
X}
X
void del_window_cmd()
X{
X    delete_window();
X}
X
void other_window_cmd()
X{
X    int n = 1;
X    if (DIGIT_ARG != (int *) NULL) n = *DIGIT_ARG;
X    other_window(n);
X}
X
X
void find_next_cmd()
X{
X    int col, line, n = 1;
X    unsigned char *pos;
X    
X    if (DIGIT_ARG != NULL) n = *DIGIT_ARG;
X    line = search(CURS_POS + SEARCH_DIR, n, &col);
X    if (line < 1) return;
X    pos = CURS_POS;
X    if ((line < WIN->beg_line) || (line > WIN->beg_line + WIN->bot - WIN->top))
X      update_window(line);
X    CURS_POS = pos;
X    CURS_ROW = line - C_LINE + 1;
X    CURS_COL = col;
X}
X
void search_cmd()
X{
X    SEARCH_DIR = 1;
X    if (read_from_minibuffer("Search: ",SEARCH_STR) == -1)
X      return;
X    CURS_POS = C_POS;
X    find_next_cmd();
X}
X
void search_back_cmd()
X{
X    SEARCH_DIR = -1;
X    if (read_from_minibuffer("Search: ",SEARCH_STR) == -1)
X      return;
X    find_next_cmd();
X}
X
void help_cmd()
X{
X    do_help_command();
X}
X
void find_file_cmd()
X{
X    user_get_file();
X}
X
void time_cmd()
X{
X    message(get_time(),0);
X}
X
void exit_cmd()
X{
X    reset_tty();
X    reset_display();
X#ifndef  VMS
X    fputc('\n',stdout);
X#endif    
X    exit(0);
X}
X
void digit_arg_cmd()
X{
X    char num[15], ch;
X    int j = 0;
X    static int digits;
X    
X    num[j++] = LAST_CHAR;
X    ch = getkey();
X    while ((ch >= '0') && (ch <= '9'))
X      {
X          num[j++] = ch;
X          ch = getkey();
X      }
X    
X    if (((j == 1) && (LAST_CHAR != '-')) || (j > 1))
X      {
X          num[j] = '\0';
X          sscanf(num,"%d",&digits);
X          DIGIT_ARG = &digits;
X      }
X    LAST_CHAR = ch;
X    (*root_map[ (int) ch ])();
X}
X
X    
void toggle_width_cmd()
X{
X    if (SCREEN_WIDTH == 80)
X      {
X          if (!RESTORE_WIDTH_TO) RESTORE_WIDTH_TO = 80;
X          set_width(132, 1);
X      }          
X    else if (SCREEN_WIDTH == 132)
X      {
X          if (!RESTORE_WIDTH_TO) RESTORE_WIDTH_TO = 132;
X          set_width(80, 1);
X      }          
X}
X
void edt_forward_cmd()
X{
X    EDT_DIRECTION = 1;
X}
X
void edt_back_cmd()
X{
X    EDT_DIRECTION = 0;
X}
X
void edt_page_cmd()
X{
X    if (EDT_DIRECTION == 0)
X	{
X	    page_up_cmd();
X	}
X    else
X	{
X	    page_down_cmd();
X	}
X}
X
void edt_line_cmd()
X{
X    if (EDT_DIRECTION == 0)
X	{
X	    previous_line_cmd();
X	}
X    else
X	{
X	    next_line_cmd();
X	}
X}
X
void edt_find_cmd()
X{
X    if (EDT_DIRECTION == 0)
X	{
X	    search_back_cmd();
X	}
X    else
X	{
X	    search_cmd();
X	}
X}
X
void edt_find_next_cmd()
X{
X    if (EDT_DIRECTION == 0)
X	{
X	    SEARCH_DIR = -1;
X	}
X    else
X	{
X	    SEARCH_DIR = 1;
X	}
X    find_next_cmd();
X}
END_OF_FILE
if test 32690 -ne `wc -c <'keym.c'`; then
    echo shar: \"'keym.c'\" unpacked with wrong size!
fi
# end of 'keym.c'
fi
if test -f 'most.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'most.1'\"
else
echo shar: Extracting \"'most.1'\" \(12801 characters\)
sed "s/^X//" >'most.1' <<'END_OF_FILE'
X.\"--------------------------------------------------------------------
X.\" UX - UNIX macro, to append \(rg to the first usage
X.\"--------------------------------------------------------------------
X.de UX
X.ie \\n(UX \s-1UNIX\s0\\$1
X.el      \{\s-1UNIX\s0\\$1\*(Rg
X.          nr UX 1
X.\}
X..
X.\"--------------------------------------------------------------------
X.\" Ds - start indented display
X.\" De - end indented display
X.\"--------------------------------------------------------------------
X.de Ds
X.nf
X'in +0.5i
X..
X.de De
X'in
X.fi
X..
X.TH MOST 1 "1 June 1992"
X.SH NAME
most \- browse or page through a text file
X.SH SYNOPSIS
X.B most
X.RB [ \-bstvw ]
X.RB [ +\fIlineno\fB ]
X.RB [ +c ]
X.RB [ +d ]
X.RB [ +/\fIstring\fB ]
X.RI [ filename ...]
X.SH DESCRIPTION
X.I most
is a paging program that displays,
one windowful at a time,
the contents of a file on a
X.RI vt xxx
compatable terminal.
It pauses after each windowful and prints on the window status line
the screen the file name, current line number,
and the percentage of the file so far displayed.
X.PP
Unlike other paging programs,
X.I most
is capable of displaying an arbitrary number of windows
as long as each window occupies at least two screen lines.
XEach window may contain the same file or a different file.
In addition, each window has its own mode.
XFor example, one window may display a file with its lines wrapped while
another may be truncating the lines.
Windows may be `locked'
together in the sense that if one of the locked windows scrolls,
all locked windows will scroll.
X.I most
is also capable of ignoring lines
that are indented beyond a user specified value.
This is useful when viewing computer programs to pick out
gross features of the code.
See the
X.RB ` :o '
command for a description of this feature.
X.PP
In addition to displaying ordinary text files,
X.I most
can also display binary files as well as files with arbitrary ascii
characters.
When a file is read into a buffer,
X.I most
examines the first 32 bytes of
the file to determine if the file is a binary file and then switches
to the appropriate mode.
However, this feature may be disabled with the
X.B \-k
option.
See the description of the
X.BR \-b ,
X.BR \-k ,
X.BR \-v ,
and
X.B \-t
options for further details.
X.PP
Text files may contain combinations of underscore and backspace
characters causing a printer to underline or overstrike.
When
X.I most
recognizes this,
it inserts the appropriate escape sequences to
achieve these the desired effect on
X.RI vt xxx
compatable terminals.
In addition,
some files cause the printer to overstrike some characters
by embedding carriage return characters in the middle of a line.
When this occurs,
X.I most
displays the overstruck character with a bold
attribute.
This feature facilitates the reading of
X.UX
man pages or a document produced by
X.IR runoff .
In particular,
viewing this document with
X.I most
should illustrate this behavior provided that the
underline characters have not been stripped.
This may be turned off with the
X.B \-v
option.
X.PP
By default, lines with more characters than the terminal width are
not wrapped but are instead truncated.
When truncation occurs, this
is indicated by a `$' in the far right column of the terminal
screen.
The RIGHT and LEFT arrow keys may be used to view lines
which extend past the margins of the screen.
The
X.B \-w
option may be used to override this feature.
When a window is wrapped,
the character `\e' will appear at the right edge of the window.
X.PP
Commands are listed below.
X.SH OPTIONS
X.TP
X.B \-b
Binary mode.
Use this switch when you want to view files
containing 8 bit characters.
X.I most
will display the file 16 bytes per line in hexidecimal notation.
A typical line looks like:
X.IP
X.Ds
X01000000 40001575 9C23A020 4000168D     ....@..u.#. @...
X.De
X.IP
When used with the
X.B \-v
option, the same line looks like:
X.IP
X.Ds
X^A^@^@^@  @^@^U u 9C #A0    @^@^V8D     ....@..u.#. @...
X.De
X.TP
X.B \-k
X`Kanji' option.
Ordinarily,
X.I most
will go into binary mode if the file consists of non-ascii characters.
Sometimes this feature is not desirable since some
terminals have a special interpretation for eight bit
characters.
The
X.B \-k
option turns off the automatic sensing.
X.TP
X.B \-s
Squeeze.
Replace multiple blank lines with a single blank line.
X.TP
X.B \-v
Display control characters as in `^A' for control A.
Normally
X.I most
does not interpret control characters.
X.TP
X.B \-t
Display tabs as `^I'.
This option is meaningful only when used with the
X.B \-v
option.
X.BI + lineno
Start up at
X.IR lineno .
X.TP
X.B +c
Make search case sensitive.
By default, they are not.
X.TP
X.B +d
This switch should only be used if you want the option to
delete a file while viewing it.
This makes it easier to
clean unwanted files out of a directory.
The file is
deleted with the interactive key sequence
X.RB ` :D '
and then confirming with
X.RB ` y '.
X.TP
X.BI +/ string
Start up at the line containing the first occurrence of
X.IR string .
X.SH "COMMAND USAGE"
The commands take effect immediately; it is not necessary to type a
carriage return.
X.PP
In the following commands,
X.I i
is a numerical argument
X(1 by default).
X.TP
X.BR SPACE ", " CTRL-D ", " NEXT_SCREEN
Display another windowful, or jump
X.I i
windowfuls if
X.I i
is specified.
X.TP
X\fBRETURN\fR, \fBDOWN_ARROW\fR, \fBV\fR, \fBCTRL-N\fR
Display another line, or
X.I i
more lines, if specified.
X.TP
X.BR UP_ARROW ", " ^ ", " CTRL-P
Display previous line, or
X.I i
previous lines, if specified.
X.TP
X.BR T ", " ESCAPE <
Move to top of buffer.
X.TP
X.BR B ", " ESCAPE >
Move to bottom of buffer.
X.TP
X.BR RIGHT_ARROW ", " TAB ", " >
Scroll window left
X.RI 60 i
columns to view lines that are beyond the right margin of the window.
X.TP
X.BR LEFT_ARROW ", " CTRL-B ", " <
Scroll window right
X.RI 60 i
columns to view lines that are beyond the left margin of the window.
X.TP
X\fBU\fR, \fBCTRL-U\fR, \fBDELETE\fR, \fBPREV_SCREEN\fR
Skip back
X.I i
windowfuls and then print a windowful.
X.TP
X.BR R ", " CTRL-R
Redraw the window.
X.TP
X.BR J ", " G
If
X.I i
is not specified, then prompt for a line number then jump to that line
otherwise just jump to line
X.IR i .
X.TP
X.B %
If
X.I i
is not specified, then prompt for a
percent number then jump to that percent of the
file otherwise just jump to
X.I i
percent of the file.
X.TP
X.BR W ", " w
If the current screen width is 80, make it 132 and vice-versa.
XFor other values, this command is ignored.
X.TP
X\fBQ\fR, \fBCTRL-X CTRL-C\fR, \fBCTRL-K E\fR
XExit from
X.IR most .
On VMS, ^Z also exits.
X.TP
X.BR h ", " CTRL-H ", " HELP ", " PF2
Help.
Give a description of all the
X.I most
commands.
The
X.I most
environment variable
X.B MOST_HELP
must be set for this to be meaningful.
X.TP
X\fBf\fR, \fB/\fR, \fBCTRL-F\fR, \fBFIND\fR, \fBGOLD PF3\fr
Prompt for a string and search forward from the
current line for
X.IR i th
distinct line containing the string.
X.B CTRL-G
aborts.
X.TP
X.B ?
Prompt for a string and search backward for the
X.IR i th
distinct line containing the string.
X.B CTRL-G
aborts.
X.TP
X.B n
Search for the next
X.I i
lines containing an occurrence of the last search string in the
direction of the previous search.
X.\"-------
X.\" The '@' causes problems when included in a paragraph tag
X.\" in my system's -man macro set, so jump though some hoops to
X.\" avoid doing this.
X.\"-------
X.PP
X\fBm\fR, \fBSELECT\fR, \fBCTRL-@\fR, \fBCTRL-K M\fR, \fBPERIOD\fR
X.PD 0
X.IP
X.PD
Set a mark on the current line for later reference.
X.TP
X.BR "INSERT_HERE, CTRL-X CTRL-X, COMMA, CTRL-K RETURN, GOLD PERIOD"
Set a mark on the current line but return to previous mark.
This allows the user to toggle back and forth between two positions
in the file.
X.TP
X.BR l ", " L
Toggle locking for this window.
The window is locked if there is a `*' at the left edge
of the status line.
Windows locked together, scroll together.
X.TP
X.BR "CTRL-X 2" ", " "CTRL-W 2" ", " "GOLD X"
Split this window in half.
X.TP
X.BR "CTRL-X o" ", " "CTRL-W o" ", " o ", " GOLD UP ", " GOLD DOWN 
Move to other window.
X.TP
X.BR "CTRL-X 0" ", " "CTRL-W 0" ", " "GOLD V"
Delete this window.
X.TP
X.BR "CTRL-X 1" ", " "CTRL-W 1" ", " "GOLD O"
Delete all other windows, leaving only one window.
X.TP
X.BR E ", " e
XEdit this file.
This does not spawn an editor, rather
X.I most
uses callable EDT and TPU routines to perform the editing task.
In addition,
X.I most
can attach to a kept editor.
See the above discussion of the environment variable
X.BR MOST_EDITOR .
X.TP
X.BR $ ", " "ESC $"
This is system dependent.
On VMS, this causes
X.I most
to spawn a subprocess.
When the user exits the process,
X.I most
is resumed.
On
X.UX
systems,
X.I most
simply suspends itself.
X.TP
X.B :n
Skip to the next filename given in the command line.
Use the arrow keys to scroll forward or backward
through the file list.
X.RB ` Q '
quits
X.I most
and any other key selects the given file.
X.TP
X.B :c
Toggle case sensitive search.
X.TP
X.B :D
Delete current file.
This command is only meaningful with the
X.B +d
switch.
X.TP
X.BR :o ", " :O
Toggle various options.
With this key sequence,
X.I most
displays a prompt asking the user to hit
one of:
X.BR bdtvw .
The
X.RB ` b ',
X.RB ` t ',
X.RB ` v ',
and
X.RB ` w '
options have the same meaning as the command
line switches.
XFor example, the
X.RB ` w '
option will toggle wrapping on and off for the current window.
X.IP
The
X.RB ` d '
option must be used with a prefix integer
X.IR i .
All lines indented beyond
X.I i
columns will not be displayed.
XFor example, consider the fragment:
X.IP
X.Ds
X.ne 11
int main(int argc, char **argv)
X{
X	int i;
X
X	for (i = 0; i < argc, i++)
X	{
X		fprintf(stdout,"%i: %s\en",i,argv[i]);
X	}
X	return 0;
X}
X.De
X.IP
The key sequence
X.RB ` 1:od '
will cause
X.I most
to display the file ignoring all lines indented beyond the first column.
So for the example above,
X.I most
would display:
X.IP
X.Ds
X.ne 2
int main(int argc, char **argv)...
X}
X.De
X.IP
where the `...' indicates lines follow are not displayed.
X.SH HINTS
X.B CTRL-G
aborts the commands requiring the user to type something
in at a prompt.
The backquote key has a special meaning here.
It is used to quote certain characters.
This is useful when search for
the occurrence of a string with a control character or a string at
the beginning of a line.
In the latter case, to find the occurrence
of `The' at the beginning of a line, enter
X.B `^JThe
where
X.B `
quotes the
X.BR CTRL-J .
X.SH ENVIRONMENT
X.I most
uses the following environment variables:
X.TP
X.B MOST_SWITCHES
This variable sets commonly used switches.
XFor example,
some people prefer to use
X.I most
with the
X.B \-s
option so that excess blank lines are not displayed.
On VMS this is normally done done in the login.com through the line:
X.IP
X.Ds
X$ define MOST_SWITCHES "-s"
X.De
X.TP
X.BR MOST_EDITOR " (VMS only)"
Set this logical to one of three values: EDT, TPU, or EMACS.
The default is EDT.
X.I most
does not spawn an editor.
Rather, it uses callable EDT and TPU to perform the editing task.
Since VMS does not support callable EMACS,
X.I most
will attempt to attach to a kept EMACS.
XFor this case,
X.I most
looks for the logical name EMACS_PID and attaches to the process with
that pid.
It then defines the logicals EMACS_FILE_NAME and
XEMACS_FILE_LINE which EMACS can check upon attaching to it.
X.TP
X.B MOST_HELP
This variable must be setup to point to the
X.I most
helpfile.
Without this
X.I most
will not be able to provide online help.
However, this behavior may be changed at compile time.
See the Makefile for more information.
X.SH BUGS
Almost all of the known bugs or limitations of
X.I most
are due to a desire to read and interpret control characters in files.
One problem concerns the use of backspace characters to underscore or
overstrike other characters.
X.I most
makes an attempt to use terminal
escape sequences to simulate this behavior.
One side effect is the
one does not always get what one expects when scrolling right and
left through a file.
When in doubt, use the
X.B \-v
and
X.B \-b
options of
X.IR most .
X.PP
String may not work properly with binary files.
X.PP
At this time,
X.I most
only works well with terminals understanding
vt100 escape sequences.
X.I most
does not seem to have any problem with
X.IR xterm .
X.PP
X.IR malloc (3)
failures are not checked.
X.I most
may crash if there is not
enough room to hold the file.
X.SH AUTHOR
John E. Davis
X.br
The Ohio State University
X.br
Department of Physics
X.br
davis@pacific.mps.ohio-state.edu
X.SH ACKNOWLEDGEMENTS
I would like to thank the users of
X.I most
for valuable comments and criticisms.
I would especially like to thank those individuals
who have contributed code to
X.IR most :
X.PP
Mats Akerberg, Henk D. Davids, Rex O. Livingston, and Mark Pizzolato
X.PP
I would also like to thank Shinichi Hama for his valuable criticisms of
X.IR most .
X.PP
Thanks to David W. Sanderson (dws@cs.wisc.edu) for adapting the
documentation to nroff man page source format.
END_OF_FILE
if test 12801 -ne `wc -c <'most.1'`; then
    echo shar: \"'most.1'\" unpacked with wrong size!
fi
# end of 'most.1'
fi
if test -f 'sysdep.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sysdep.c'\"
else
echo shar: Extracting \"'sysdep.c'\" \(11684 characters\)
sed "s/^X//" >'sysdep.c' <<'END_OF_FILE'
X/*
X * HISTORY
X * {1}	19-Mar-91  Henk D. Davids <hdavids@mswe.dnet.ms.philips.nl>
X * 	History started. Added default input file name so you do not
X *	have to specify name or type if you want it to be *.
X * 	Changes indicated by "-hdd" in comment.
X * 
X *  2.  4/4/91  John E. Davis
X *      I added code to read the teminal size for unix systems-- at least it
X *      works on a sun4 (BSD ?).  In addition I have also recently added file
X *      deletion code for both unix and vms.
X */
X#include "sysdep.h"
X
X
X/* 
X *  
X *  
X *                          SHELL COMMANDS
X *  
X */
X  
X#ifdef VMS
X
X/* these two from emacs source */  
void define_logical_name (char *varname, char *string)
X{
X    struct dsc$descriptor_s strdsc =
X      {strlen (string), DSC$K_DTYPE_T, DSC$K_CLASS_S, string};
X    struct dsc$descriptor_s envdsc =
X      {strlen (varname), DSC$K_DTYPE_T, DSC$K_CLASS_S, varname};
X    struct dsc$descriptor_s lnmdsc =
X      {7, DSC$K_DTYPE_T, DSC$K_CLASS_S, "LNM$JOB"};
X
X    LIB$SET_LOGICAL (&envdsc, &strdsc, &lnmdsc, 0, 0);
X}
X
void delete_logical_name (char *varname)
X{
X    struct dsc$descriptor_s envdsc =
X      {strlen (varname), DSC$K_DTYPE_T, DSC$K_CLASS_S, varname};
X    struct dsc$descriptor_s lnmdsc =
X      {7, DSC$K_DTYPE_T, DSC$K_CLASS_S, "LNM$JOB"};
X    
X    LIB$DELETE_LOGICAL (&envdsc, &lnmdsc);
X}
X
X
int do_emacs_command()
X{
X    unsigned long pid;
X    char *pidstr;
X    
X    if((pidstr = getenv("EMACS_PID")) != NULL)
X      {
X	  (void) sscanf(pidstr,"%X",&pid);
X	  if (lib$attach(&pid) == SS$_NORMAL) /* we attach to emacs */
X            return(1);
X          else
X            return(0);
X          /* 	    printf("Can't attach to pid %X\n",pid); */
X      }
X    else return(0);
X}
X
unsigned long SHELL_PID = 0;  
X
X/* returns 0 on success */
int do_shell_command()
X{
X    /* here we try to attach to the parent otherwise just spawn a new one */
X    unsigned long parent_pid;
X    unsigned long status = 0;
X    char str[80];
X    
X    
X    parent_pid = getppid();
X    
X    if (parent_pid && parent_pid != 0xffffffff)  
X      /* we attach to parent */
X      status = lib$attach(&parent_pid);
X
X    else if (SHELL_PID && SHELL_PID != 0xffffffff)
X      /* try to attach to previous shell */
X      status = lib$attach (&SHELL_PID);
X      
X    if (status != SS$_NORMAL)		/* others fail so spawn a new shell */
X      {
X          status = 0;
X	  fputs("Spawning Subprocess...",stdout);
X          fflush(stdout);
X	  lib$spawn(0,0,0,0,0,&SHELL_PID,&status);
X          /* if we attach back, status may come back unchanged */
X          if ((status != 0) && (status != SS$_NORMAL))
X            {
X                sprintf(str,"Unable to spawn subprocess. Error = %X", status);
X                message(str,1);
X                return(0);
X            }
X      }
X    return(1);
X}
X
X
X#endif /* VMS */
X
X/* 
X *                            FILE IO
X *  
X */
X
X#ifdef VMS
int expand_file_name(char *file,char *expanded_file)
X{
X    unsigned long status;
X    static int context = 0;
X    static char inputname[255] = "";
X    $DESCRIPTOR(file_desc,inputname);
X    $DESCRIPTOR(default_dsc,"SYS$DISK:[]*.*;");
X    static struct dsc$descriptor_s  result = 
X	    {0, DSC$K_DTYPE_T, DSC$K_CLASS_D, NULL};
X
X    if (strcmp(inputname, file))
X      {
X	  if (context)
X	    {
X		lib$find_file_end(&context);
X	    }
X	  context = 0;
X	  strcpy(inputname, file);
X	  file_desc.dsc$w_length = strlen(inputname);
X      }
X    
X    if (RMS$_NORMAL == lib$find_file(&file_desc,&result,&context,
X	           		     &default_dsc,0,0,&0))
X      {
X	  memcpy(expanded_file, result.dsc$a_pointer, result.dsc$w_length);
X	  expanded_file[result.dsc$w_length] = '\0';
X          return (1);
X      }
X    else
X      {
X          expanded_file[0] = '\0';       /* so file comes back as zero width */
X          return(0);
X      }
X}
X#endif /* VMS */
X
X/* 
X *  
X *  
X *         Terminal IO
X *  
X */
X
X#ifdef VMS
X/*
X *      Exit Handler Control Block
X */
static struct argument_block
X    {
X    int forward_link;
X    int (*exit_routine)();
X    int arg_count;
X    int *status_address;
X    int exit_status;
X    } exit_block
X      = {
X        0,
X        NULL,
X        1,
X        &exit_block.exit_status,
X        0
X        };
X#endif
void init_tty()
X{
X#ifdef VMS
X    $DESCRIPTOR ( Term, "SYS$ERROR");
X    if (sys$assign ( &Term, &TTY_CHANNEL_GLOBAL, 0, 0 )
X        != SS$_NORMAL)
X      {
X          fprintf(stderr,"Unable to assign input channel\n");
X          exit(0);
X      }
X    if (NULL == exit_block.exit_routine)
X	{
X	void reset_tty();
X
X	exit_block.exit_routine = reset_tty;
X	SYS$DCLEXH(&exit_block);
X	}
X#else    
X#ifdef BSD
X    struct sgttyb  newtty;
X    struct tchars tc;
X    struct ltchars lc;
X
X    ioctl(TTY_DESCR, TIOCGLTC,&OLDTTY_LC);
X    ioctl(TTY_DESCR, TIOCGETC,&OLDTTY_TC);
X    ioctl(TTY_DESCR, TIOCGETP, &OLDTTY);
X    newtty = OLDTTY;
X    newtty.sg_flags |= CBREAK;
X    newtty.sg_flags &= ~(ECHO | XTABS);
X    newtty.sg_erase = 0;
X    newtty.sg_kill = 0;
X    tc.t_intrc = 0;
X    tc.t_quitc = 0;
X    tc.t_eofc = 0;
X    tc.t_brkc = 0;
X    lc.t_suspc = 0;
X    lc.t_dsuspc = 0;
X    ioctl(TTY_DESCR, TIOCSETP, &newtty);
X    ioctl(TTY_DESCR, TIOCSLTC,&lc);
X    ioctl(TTY_DESCR, TIOCSETC,&tc);
X#else /* other unix */    
X    struct termio newtty;
X	  
X    ioctl(TTY_DESCR, TCGETA, &OLDTTY);
X    ioctl(TTY_DESCR, TCGETA, &newtty);
X    newtty.c_iflag &= ~(ECHO);  
X    newtty.c_iflag &= ~(INLCR);  
X    newtty.c_iflag &= ~(ICRNL);  
X    newtty.c_lflag = 00000000; 
X    newtty.c_cc[VMIN] = 1; 
X    newtty.c_cc[VTIME] = 0;
X    newtty.c_cc[VEOF] = 1;          
X    ioctl(TTY_DESCR, TCSETA, &newtty);
X
X#endif  /* other unix */
X#endif
X    fputs("\033=", stdout);  /* Enable the Application Keypad */
X}
X
sys_flush(int fd)
X{
X#ifdef BSD
X    ioctl(fd, TIOCFLUSH, (char *) NULL);
X#else
X#ifndef VMS    
X    ioctl(fd, TCFLSH, (char *) NULL);
X#endif    
X#endif    
X}
X
void reset_tty()
X{
X    fputs("\033=", stdout);  /* Enable the Numeric Keypad */
X#ifndef VMS
X#ifdef BSD
X	ioctl(TTY_DESCR, TIOCSETP, &OLDTTY);
X	ioctl(TTY_DESCR, TIOCSLTC, &OLDTTY_LC);
X	ioctl(TTY_DESCR, TIOCSETC, &OLDTTY_TC);
X#else        
X    	ioctl(TTY_DESCR, TCSETA, &OLDTTY);
X#endif /* BSD */
X#endif /* not vms*/
X}
X
int INPUT_BUFFER_LEN = 0;
char INPUT_BUFFER[80];
X
char sys_getkey()
X{
X    char c;
X    
X#ifndef VMS
X    if (read(TTY_DESCR, &c, 1) < 0)
X      {
X          fprintf(stderr,"getkey():  read failed.\n");
X          reset_tty();
X          exit(0);
X      }
X    
X#else
X    /* VMS */
X    /* see Guide to Programming VAX/VMS */
X    int status;
X    static int trmmsk [2] = { 0, 0 };
X    short iosb [4];
X	
X    status = sys$qiow ( 0, TTY_CHANNEL_GLOBAL,
X                       IO$_READVBLK + IO$M_NOECHO | IO$_TTYREADALL,
X                       iosb, 0, 0,
X                       &c, 1, 0, trmmsk, 0, 0 );
X
X#endif  /* VMS */
X	
X    return(c); 
X}
X
char getkey()
X{
X    int i;
X    char ch;
X    if (!INPUT_BUFFER_LEN) return(sys_getkey());
X    ch = INPUT_BUFFER[0];
X    INPUT_BUFFER_LEN--;
X    for (i = 0; i < INPUT_BUFFER_LEN; i++)
X      {
X          INPUT_BUFFER[i] = INPUT_BUFFER[i + 1];
X      }
X    return(ch);
X}
X
void ungetkey(char ch)
X{
X    int i;
X    for (i = 0; i < INPUT_BUFFER_LEN; i++)
X      {
X          INPUT_BUFFER[i+1] = INPUT_BUFFER[i];
X      }
X    INPUT_BUFFER[0] = ch;
X    INPUT_BUFFER_LEN++;
X}
X
X
X/* 
X *  
X *      Misc Termial stuff  
X *  
X *  
X */
X
X
X/*  This is to get the size of the terminal  */
void get_term_dimensions(int *cols, int *rows)
X{
X#ifdef VMS
X    int status;
X    iosb iostatus;
X    $DESCRIPTOR(devnam, "SYS$ERROR");
X    struct
X	{
X	short row_buflen;
X	short row_itmcod;
X	int *row_bufadr;
X	short *row_retlen;
X	short col_buflen;
X	short col_itmcod;
X	int *col_bufadr;
X	short *col_retlen;
X	int listend;
X	} itmlst =
X	{
X	sizeof(*rows), DVI$_TT_PAGE, rows, 0,
X	sizeof(*cols), DVI$_DEVBUFSIZ, cols, 0,
X	0
X	};
X    
X    /* Get current terminal characteristics */
X    status = sys$getdviw(0,           /* Wait on event flag zero  */
X                         0,           /* Channel to input terminal  */
X                         &devnam,     /* device name */
X			 &itmlst,	  /* Item descriptor List */
X                         &iostatus,   /* Status after operation */
X                         0, 0,        /* No AST service   */
X                         0);          /* nullarg */
X    if (status&1)
X	status = iostatus.i_cond;
X    /* Jump out if bad status */
X    if ((status & 1) == 0)
X      exit(status);
X#else    /* this may need work on other unix-- works for sun4 */
X    struct winsize wind_struct;
X      
X    ioctl(2,TIOCGWINSZ,&wind_struct);
X    *cols = (int) wind_struct.ws_col;
X    *rows = (int) wind_struct.ws_row;
X    
X#endif /* VMS */
X}
X
X/* returns 0 on failure, 1 on sucess */
int sys_delete_file(char *filename)
X{
X#ifdef VMS
X    return (1 + delete(filename));   /* 0: sucess; -1 failure */
X#else  /* unix not ready yet */
X    return(1 + unlink(filename));
X#endif
X}
X
X
X/* This routine converts unix type names to vms names */
X#ifdef VMS
int locate(char ch, char *string)
X{
X    int i;
X    char c;
X
X    i = 0;
X    while (c = string[i++], (c != ch) && (c != '\0'));
X    if (c == ch) return(i); else return (0);
X}
X
char *unix2vms(char *file)
X{
X    int i,device,j,first,last;
X    static char vms_name[80];
X    char ch;
X
X    if (locate('[',file)) return(file); /* vms_name syntax */
X    if (!locate('/',file)) return(file); /* vms_name syntax */
X
X    /* search for the ':' which means a device is present */
X    device = locate(':',file);
X
X    i = 0;
X    if (device)
X      {
X          while (ch = file[i], i < device) vms_name[i++] = ch;
X      }
X    j = i;
X    
X    /* go from the  end looking for a '/' and mark it */
X    i = strlen(file) - 1;
X    while(ch = file[i], ch != '/' && i-- >= 0);
X    if (ch == '/')
X      {
X          file[i] = ']';
X          last = 0;
X      }
X    else last = 1;
X
X    i = j;
X    vms_name[j++] = '[';
X    vms_name[j++] = '.';
X    first = 0;
X    while(ch = file[i++], ch != '\0')
X      {
X          switch (ch)
X            {
X              case '.':
X                if (last) vms_name[j++] = '.';
X                if (last) break;
X                ch = file[i++];
X                if (ch == '.')
X                  {
X                      if (!first) j--;  /* overwrite the dot */
X                      vms_name[j++] = '-';
X                  }
X                else if (ch == '/'); /*  './' combinations-- do nothing */
X                else if (ch == ']')
X                  {
X                      last = 1;
X                      if (vms_name[j-1] == '.') j--;
X                      vms_name[j++] = ']';
X                  }
X                
X                else vms_name[j++] = '.';
X                break;
X              case '/':
X                if (first)
X                  {
X                      vms_name[j++] = '.';
X                  }
X                else
X                  {
X                      first = 1;
X                      /* if '/' is first char or follows a colon do nothing */
X                      if ((i!=1) && (file[i-2] != ':'))
X                        {
X                            vms_name[j++] = '.';
X                        }
X                      else j--; /* overwrite the '.' following '[' */
X                  }
X                break;
X              case ']':
X                last = 1;
X                if (vms_name[j-1] == '.') j--;
X                vms_name[j++] = ']';
X                break;
X              default:
X                vms_name[j++] = ch;
X            }
X      }
X    return (vms_name);
X}
X
X/*
main(int argc, char **argv)
X{
X    puts(unix2vms(argv[1]));
X}
X*/     
X
X#endif /* VMS */
X
X#include <time.h>
X
char *get_time()
X{ 
X    time_t clock;
X    char *the_time;
X
X    clock = time((long *) 0);
X    the_time = ctime(&clock); /* returns the form Sun Sep 16 01:03:52 1985\n\0 */
X    the_time[24] = '\0';
X    return(the_time);
X}
END_OF_FILE
if test 11684 -ne `wc -c <'sysdep.c'`; then
    echo shar: \"'sysdep.c'\" unpacked with wrong size!
fi
# end of 'sysdep.c'
fi
if test -f 'window.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'window.c'\"
else
echo shar: Extracting \"'window.c'\" \(18308 characters\)
sed "s/^X//" >'window.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "externs.h"
X#include "window.h"
X#include "line.h"
X#include "display.h"
X
Window *WIN;
Window *TOP_WIN;
int COLUMN = 1;
int BEEP_MINI_B = 0;
int MINIBUFFER_SELECTED = 0;
int CURS_ROW;
int CURS_COL;
int RESTORE_WIDTH_TO = 0;
unsigned char *CURS_POS;
X
int read_string(char *str)
X{
X    char ch;
X    int i;
X
X    i = strlen(str);
X    do 
X      {
X          ch = getkey();
X          if ((ch == '\b') || (ch == 127))
X            {
X                if (i > 0)
X                  {
X                      if (str[--i] < 32) fputs("\b \b",stdout); /* erase the ^ */
X                      fputs("\b \b",stdout);
X                  }
X                else fputc('\007',stdout);
X            }
X          else if ((ch < 32) && (ch != 10) && (ch != 13))
X            {
X		if ((ch == '\007') || (ch == '\025')) /* ^G or ^U aborts */
X		   {
X		      fputc('\007',stdout);
X		      return(-1);    /* ^G quits */
X		   }
X		if (ch == '\033')  /* Allow KP ENTER as a terminator */
X		   {
X		      ch = getkey();
X		      if (ch == 'O')
X			 {
X			    ch = getkey();
X			    if (ch == 'M')
X			       {
X				  str[i] = '\0';
X				  return(i);
X			       }
X			    else
X			       {
X			       fputc('^',stdout);
X			       fputc('[',stdout);
X			       fputc(str[i++] = 'O', stdout);
X			       fputc(str[i++] = ch, stdout);
X			       }
X			 }
X		      else
X			 {
X			    fputc('^',stdout);
X			    fputc('[',stdout);
X			    fputc(str[i++] = ch, stdout);
X			 }
X		   }
X		else
X		   {
X		      str[i++] = ch;
X		      fputc('^',stdout);
X		      fputc(ch + '@',stdout);
X		   }
X            }
X          else if (ch == '`')   /* quoted insert */
X            {
X                ch = getkey();
X                str[i++] = ch;
X                if ((ch < ' ') || (ch == 127)) 
X                  {
X                      if (ch == 127) ch = '?'; else ch = ch + '@';
X                      fputc('^',stdout);
X                  }
X                fputc(ch,stdout);
X            }
X	  else if ((ch != 10) && (ch != 13))
X            {
X                str[i++] = ch;
X                fputc(ch,stdout);
X            }
X          
X          fflush(stdout);
X      }
X    while ((ch != 10) && (ch != 13));
X      
X    str[i] = '\0';
X    return(i);
X}
X
X
void message(char *what, int how)
X{
X    strcpy(MINI_BUF,what);
X    if (how) BEEP_MINI_B = 1; else BEEP_MINI_B = 0;
X}
X
void select_minibuffer()
X{
X    if (MINIBUFFER_SELECTED) return;
X    MINIBUFFER_SELECTED = 1;
X    set_scroll_region(1,SCREEN_HEIGHT);
X    goto_rc(SCREEN_HEIGHT,1);
X    fflush(stdout);
X}
X
void exit_minibuffer()
X{
X    if (!MINIBUFFER_SELECTED) return;
X    MINIBUFFER_SELECTED = 0;
X    set_scroll_region(WIN->top,WIN->bot);
X    fflush(stdout);
X}
X
X/* put out string, expanding control chars */
void nicely_puts(char *str, FILE *fp)
X{
X    while (*str != '\0')
X      {
X          if ((*str < ' ') || (*str == 127))
X            {
X                fputc('^',fp);
X                if (*str != 127) fputc(*str + '@',fp); else fputc('?',fp);
X            }
X          else fputc(*str,fp);
X          str++;
X      }
X}
X
void put_message()
X{
X    select_minibuffer();
X    delete_line(1);
X    if (BEEP_MINI_B) fputc('\007',stdout);
X    BEEP_MINI_B = 0;
X    if (*MINI_BUF != '\0') nicely_puts((char *) MINI_BUF, stdout);
X    exit_minibuffer();
X}
X
X/* puts 'what in the minibuffer to be edited. */
X/* returns number of chars read */
int read_from_minibuffer(char *prompt, char *what)
X{
X    int i;
X    char str[132];
X    
X    select_minibuffer();
X    fputs(prompt,stdout);
X    if (*what != '\0')
X      nicely_puts(what,stdout);
X    fflush(stdout);
X    strcpy(str,what);
X    i = read_string(str);
X    if (i > 0) strcpy(what,str);
X    delete_line(1);
X    exit_minibuffer();
X    return(i);
X}
X
X    
void clear_minibuffer()
X{
X    MINI_BUF[0] = '\0';
X    BEEP_MINI_B = 0;
X    put_message();
X}
X
X
int get_scroll(int *line)
X{
X    /* line is the line we want at the topo of the window if possible */
X    int dtop, dbot,n,top,bot,wsize;
X
X    top = WIN->beg_line;
X    wsize = WIN->bot - WIN->top; /* actually 1 less than window size */
X    bot = top + wsize;
X
X    if ((*line == 1) && (top == 1))
X      {
X          message("Top of Buffer.",1);
X          return(0);
X      }
X    
X    /* handles endof file in a window */
X    if ((bot > NUM_LINES) && *line > C_LINE)
X      {
X          *line = top;
X          message("End of Buffer.",1);
X          return(0);
X      }
X    
X    if (NUM_LINES <= wsize)     /* short file */
X      {
X          *line = 1;
X          return(0);
X      }
X
X    dtop = top - 1;
X    dbot = NUM_LINES - bot;
X    n = *line - top;
X
X    if ((n>0) && (dbot < n))
X      {
X          n = dbot;
X          *line = top + n;
X          if (!n) message("End of buffer.",1);
X      }
X    else if ((n < 0) && (dtop + n < 0))
X      {
X          n = -dtop;
X          if (!n) message("Top of buffer.",1);
X          *line = n + top;
X      }
X    return(n);
X}
X
X
void update_window(int line)
X{
X    int n,max_n, save_line, save_col, npos;
X    unsigned char *save_pos;
X
X    if (COLUMN != WIN->col)
X      {
X          if (COLUMN < 1) COLUMN = 1;
X          if (COLUMN != WIN->col)
X            {
X                save_pos = CURS_POS; save_line = CURS_ROW; save_col = CURS_COL;
X                redraw_window();
X                update_status(0);
X                WIN->curs_pos = CURS_POS = save_pos;
X                WIN->curs_line = CURS_ROW = save_line;
X                WIN->curs_col = CURS_COL = save_col;
X            }
X          return;
X      }
X
X    
X    n = get_scroll(&line);
X    max_n = WIN->bot - WIN->top;
X    if (abs(n) > max_n)
X      {
X          goto_line(line);
X          redraw_window();
X          update_status(0);
X          return;
X      }
X    if (!n) return;
X
X    goto_rc(1,1);
X    forward_line(n);
X    WIN->beg_pos = C_POS;
X    WIN->beg_line = C_LINE;
X
X    if (n>0)
X      {
X          npos = 1;
X          delete_nlines(n);
X          goto_rc(WIN->bot - WIN->top - n + 2,1);
X          forward_line(max_n - n + 1);
X      }
X    else
X      {
X          npos = 0;
X          CURS_ROW = 1; CURS_COL = 1; CURS_POS = C_POS;
X          n = -n;
X          reverse_index(n);
X      }
X    n = n - 1;
X    display_line();
X    while(n--)
X      {
X          forward_line(1);
X          fputc('\n',stdout);
X          display_line();
X      }
X    if (npos) 
X      {
X          
X          CURS_ROW = C_LINE - WIN->beg_line + 1;
X          CURS_COL = 1; CURS_POS = C_POS;
X      }
X    
X    C_POS = WIN->beg_pos;
X    C_LINE = WIN->beg_line;
X    update_status(0);
X    fflush(stdout);
X}
X
X/* updates current window as well as scroll lock ones */
X/* Although current window is update in an absolute fashion, scroll locked
X   ones are updated in a relative fashion */
void update_windows(int line)
X{
X    int dline,flg;
X    Window *w;
X    
X    dline = line - C_LINE;
X    update_window(line);
X    if (!WIN->lock) return;
X    flg = 0;
X    w = WIN;
X    while(WIN = WIN->next, WIN != w)
X      {
X          if (WIN->lock)
X            {
X                flg = 1;
X                set_window(WIN);
X                line = C_LINE + dline;
X                update_window(line);
X            }
X      }
X    WIN = w;
X    if (flg) set_window(WIN);
X}
X
X
void redraw_window()
X{
X    int n,t;
X    t = WIN->top;
X    if (t == 1) clear_window();
X    goto_rc(1, 1);
X    n = WIN->bot - WIN->top;
X    if ((C_LINE + n) > NUM_LINES) goto_line(NUM_LINES - n);
X    WIN->curs_pos = CURS_POS = WIN->beg_pos = C_POS;
X    WIN->beg_line = C_LINE;
X    WIN->col = COLUMN;
X    WIN->curs_col = CURS_COL = 1;
X    WIN->curs_line = CURS_ROW = 1;
X    if (t != 1) delete_line(1);
X    display_line();
X    while(n--)
X      {
X          fputc('\n',stdout);
X          if (t != 1) delete_line(1);
X          if (forward_line(1)) display_line();
X      }
X    
X        
X    C_POS = WIN->beg_pos;
X    C_LINE = WIN->beg_line;
X}
X
X/* associates current window with current buffer */
void save_win_flags(Window *w)
X{
X    w->flags = 0;
X    if (MOST_V_OPT) w->flags |= _MOST_V_OPT;
X    if (MOST_B_OPT) w->flags |= _MOST_B_OPT;
X    if (MOST_T_OPT) w->flags |= _MOST_T_OPT;
X    if (MOST_W_OPT) w->flags |= _MOST_W_OPT;
X    if (SQUEEZE_LINES) w->flags |= _MOST_SQ_OPT;
X    w->n_lines = NUM_LINES;
X    w->display = MOST_S_OPT;
X}
X
void window_buffer()
X{
X    WIN->beg_line = C_LINE;
X    WIN->beg_pos = C_POS;
X    WIN->col = COLUMN;
X    WIN->buf = BUF;
X    MOST_S_OPT = 0;
X    save_win_flags(WIN);
X}
X
void clear_window()
X{
X    int i,n;
X    i = WIN->top;
X    n = WIN->bot - WIN->top;
X    if (i == 1)
X      {
X          goto_rc(WIN->bot - WIN->top + 1,SCREEN_WIDTH);
X          clr_bos();
X      }
X    else
X      {
X          goto_rc(i - WIN->top + 1,1);
X          delete_line(1);
X          while(n--)
X            {
X                fputc('\n',stdout);
X                delete_line(1);
X            }
X      }
X    
X    goto_rc(i - WIN->top + 1,1);
X    fflush(stdout);
X}
X
void restore_win_flags()
X{
X    MOST_V_OPT = WIN->flags & _MOST_V_OPT;
X    MOST_B_OPT = WIN->flags & _MOST_B_OPT;
X    MOST_T_OPT = WIN->flags & _MOST_T_OPT;
X    MOST_W_OPT = WIN->flags & _MOST_W_OPT;
X    SQUEEZE_LINES = WIN->flags & _MOST_SQ_OPT;
X    NUM_LINES = WIN->n_lines;
X    MOST_S_OPT = WIN->display;
X}
X
X
Window *make_window(int r1,int r2)
X{
X    int i;
X    Window *new;
X    new = (Window *) malloc(sizeof(Window));
X    new->status = (char *) malloc(135);
X    for (i = 0; i <= SCREEN_WIDTH; i++) new->status[i] = '\0';
X    new->col = COLUMN;
X    new->top = r1;
X    new->bot = r2;
X    new->lock = 0;
X    save_win_flags(new);
X    return(new);
X}
X
void init_display()
X{
X    int i;
X    fputs("\033[?6h",stdout);
X    TOP_WIN = WIN = make_window(1,SCREEN_HEIGHT - 2);
X    WIN->prev = WIN->next = WIN;
X    cls();
X    set_scroll_region(WIN->top, WIN->bot);
X    goto_rc(1,1);
X    fflush(stdout);
X}
X
void reset_display()
X{
X    set_scroll_region(1,SCREEN_HEIGHT);
X    fputs("\033[?6l",stdout);   /* normal origin mode */
X    goto_rc(SCREEN_HEIGHT,1);
X    if (RESTORE_WIDTH_TO)
X      {
X          set_width(RESTORE_WIDTH_TO, 0);
X          RESTORE_WIDTH_TO = 0;
X      }
X    
X    fflush(stdout);
X}
X
update_status1(int new_status)
X{
X    char str[30], ch, *strp;
X    static char new[135];
X    int i,ii,r,x,line_p = 60;
X
X    r = WIN->bot + 1;
X    goto_rc(r,1);
X
X    i = ii = 0;
X    new[ii++] = '-';
X    if (WIN->lock) new[ii++] = '*'; else new[ii++] = '-';
X    strp = " MOST: ";
X    while(*strp != '\0') new[ii++] = *strp++;
X    
X    while(ch = WIN->buf->file[i++], ch != '\0') new[ii++] = ch;
X
X    while(ii < line_p) new[ii++] = ' ';
X
X    x = (C_LINE + WIN->bot - WIN->top) * 100; x = x / NUM_LINES;
X
X    /* for files with end of file above the bottom row (due to window manipulations) */
X    if (x > 100) x = 100;
X    sprintf(str,"(%d,%d) %d%%",C_LINE,COLUMN,x);
X    i = 0; while(ch = str[i++], ch != '\0') new[ii++] = ch;
X
X    while(ii < SCREEN_WIDTH) new[ii++] = '-';
X    new[SCREEN_WIDTH] = '\0';
X    set_attribute(7);
X    if (new_status)
X      fputs(new,stdout);
X    else
X      smart_puts(new,WIN->status,stdout);
X    set_attribute(0);
X    strcpy(WIN->status,new);
X}
X
void update_status(int new_status)
X{
X
X    C_LINE = WIN->beg_line;
X    C_POS = WIN->beg_pos;
X    set_scroll_region(1,SCREEN_HEIGHT);
X    update_status1(new_status);
X    set_scroll_region(WIN->top,WIN->bot);
X    fflush(stdout);
X}
X
X/* splits window-- no screen update, does not affect scrolling region */
int split_window()
X{
X    Window *new, *old;
X    int b2,t2,b1, line;
X
X    b2 = WIN->bot;
X    b1 = (WIN->bot + WIN->top) / 2 - 1;
X    t2 = b1 + 2;
X    if ((b1 == WIN->top) || (t2 == b2)) return(0);
X
X    /* line is top line of new window. */
X    line = WIN->beg_line + t2 - WIN->top;
X    old = WIN;
X    WIN->bot = b1;
X    new = make_window(t2,b2);
X    /* add to ring */
X    WIN->next->prev = new;
X    new->next = WIN->next;
X    new->prev = WIN;
X    WIN->next = new;
X
X    new->beg_line = line;
X    new->buf = BUF;
X    /* new window status line is at same position as old */
X    strcpy(new->status,WIN->status);
X    return(1);
X}
X
X    
void two_windows()
X{
X    int line;
X    Window *new, *old;
X    if (!split_window()) return;
X
X    old = WIN;
X    new = WIN->next;
X    line = new->beg_line;
X    if (line + new->bot - new->top > NUM_LINES)
X      {
X          other_window(1);
X          /* since split window left new window undefined... */
X          C_POS = old->beg_pos;
X          C_LINE = old->beg_line;
X          if (NUM_LINES <= new->bot - new->top + 1)
X            {
X                C_LINE = new->beg_line = 1;
X                C_POS = new->beg_pos = BUF->beg;
X                redraw_window();
X                update_status(0);
X            }
X          else if (line > NUM_LINES)
X            {
X                goto_line(NUM_LINES - new->bot + new->top);
X                WIN->beg_pos = C_POS;
X                WIN->beg_line = C_LINE;
X                redraw_window();
X                update_status(0);
X            }    
X          else
X            {
X                goto_line(line);
X                WIN->beg_pos = C_POS;
X                WIN->beg_line = C_LINE;
X                update_window(NUM_LINES - new->bot + new->top);
X            }
X          WIN->curs_line = 1;
X          WIN->curs_col = COLUMN;
X          WIN->curs_pos = C_POS;
X          other_window(-1);
X      }
X    else
X      {
X          WIN = new;
X          (void) forward_line(line - old->beg_line);
X          new->beg_pos = C_POS;
X          new->beg_line = C_LINE;
X          new->curs_line = 1;
X          new->curs_col = COLUMN;
X          new->curs_pos = C_POS;
X          update_status(0);
X          WIN = old;
X      }    
X    update_status(1);
X}
X
void expand_window1(int dn)
X{
X    int l, save_top, save_line;
X    unsigned char *save_pos;
X
X    /* l is line after last line of current window (where status line is) */
X    l = WIN->beg_line + WIN->bot - WIN->top + 1;
X    save_top = WIN->top;
X    WIN->top = WIN->bot + 1;
X    WIN->bot = WIN->bot + dn;
X    set_scroll_region(WIN->top, WIN->bot);
X    if (l > NUM_LINES)
X      {
X          clear_window();
X      }
X    else
X      {
X          /* should add something here for smarter scrolling...
X             if ((WIN->next->BUF == BUF) && (l >= WIN->next->beg_line)
X             && (l <= (WIN->next->beg_line + WIN->next)
X             */
X                
X          save_line = C_LINE;
X          save_pos = C_POS;
X          goto_line(l);
X          redraw_window();
X          WIN->beg_line = C_LINE = save_line;
X          WIN->beg_pos = C_POS = save_pos;
X      }
X    WIN->top = save_top;
X    set_scroll_region(WIN->top, WIN->bot);
X}
X
void one_window()
X{
X    Window *w, *tmp;
X    int diff;
X    
X    if (WIN->next == WIN) return;
X    w = WIN;
X    WIN = WIN->next;
X    /* delete other windows preserving the ring! */
X    while(WIN != w)
X      {
X          free_window_buffer(); /* needs a ring */
X          tmp = WIN->next;
X          /* if this is the bottom window, save its status line */
X          if (tmp == TOP_WIN) strcpy(w->status,WIN->status);
X          tmp->prev = WIN->prev;
X          WIN->prev->next = tmp;
X          free(WIN);
X          WIN = tmp;
X      }
X    WIN = w;
X    /* slide the window to the top and expand it */
X    diff = WIN->top - 1;
X    if (diff)
X      {
X          set_scroll_region(1,SCREEN_HEIGHT - 2);
X          goto_rc(1,1);
X          delete_nlines(diff);
X          WIN->top = 1;
X          WIN->bot -=  diff;
X          TOP_WIN = WIN;
X      }
X    expand_window1(SCREEN_HEIGHT - 2 - WIN->bot);
X    update_status(0);
X}
X
X          
void set_window(Window *w)
X{
X    WIN = w;
X    CURS_ROW = WIN->curs_line;
X    CURS_COL = WIN->curs_col;
X    CURS_POS = WIN->curs_pos;
X    C_LINE = WIN->beg_line;
X    C_POS = WIN->beg_pos;
X    COLUMN = WIN->col;
X    BUF = WIN->buf;
X    switch_to_buffer(BUF);
X    set_scroll_region(WIN->top,WIN->bot);
X    restore_win_flags();
X    fflush(stdout);
X}
X
void other_window(int n)
X{
X    if (!n) return;
X    WIN->beg_pos = C_POS;
X    WIN->curs_pos = CURS_POS;
X    WIN->curs_line = CURS_ROW;
X    WIN->curs_col = CURS_COL;
X    WIN->beg_line = C_LINE;
X    save_win_flags(WIN);
X    if (n < 0)
X      while (n++) WIN = WIN->prev;
X    else
X      while (n--) WIN = WIN->next;
X    set_window(WIN);
X}
X
X
X
X/* kills window by moving lower window up */
delete_as_top_window()
X{
X    int t1,t2,b1,b2;
X    t1 = WIN->top;
X    t2 = WIN->next->top;
X    b1 = WIN->bot;
X    b2 = WIN->next->bot;
X    WIN->prev->next = WIN->next;
X    WIN->next->prev = WIN->prev;
X
X    /* scroll contents of window below to top */
X    set_scroll_region(t1,b2);
X    goto_rc(1,1);
X    delete_nlines(t2 - t1);
X    other_window(1);
X    WIN->top = t1;
X    WIN->bot = b2 - t2 + t1;
X    expand_window1(b2 - WIN->bot);
X    update_status(0);
X}
X
X/* free buffer for this window if no other windows are viewing it. */
free_window_buffer()
X{
X    Window *w;
X    int f = 1;
X    w = WIN;
X    WIN = w->next;
X    while((WIN != w) && f)
X      {
X          if (!strcmp(WIN->buf->file,w->buf->file)) f = 0;
X          WIN = WIN->next;
X      }
X    WIN = w;
X    if (f) free(WIN->buf);
X}
X
X
delete_window()
X{
X    int new_b, old_b;
X    Window *w;
X    
X    w = WIN;
X    if (WIN->next == WIN) return;
X    free_window_buffer();
X    if (WIN->next != TOP_WIN)
X      {
X          if (WIN == TOP_WIN)
X            {
X                delete_as_top_window();
X                TOP_WIN = WIN;  /* not anymore, this one is */
X            }
X          else
X            delete_as_top_window();
X          
X          free(w);
X          return;
X      }
X    old_b = WIN->top - 2;
X    new_b = WIN->bot;
X    other_window(-1);
X    expand_window1(new_b - old_b);
X    strcpy(WIN->status,w->status); /* share the same line */
X    
X    WIN->next = w->next;
X    WIN->next->prev = WIN;
X    free(w);
X    update_status(0);
X}
X
void redraw_display()
X{
X    Window *w;
X    int n,t;
X    fputs("\033[?6h",stdout);   /* relative origins */
X    set_scroll_region(1,SCREEN_HEIGHT);
X    cls();
X    save_win_flags(WIN);
X    w = WIN;
X    do
X      {
X          WIN = WIN->next;
X          t = WIN->top;
X          goto_rc(t, 1);
X          C_POS = WIN->beg_pos;
X          C_LINE = WIN->beg_line;
X          COLUMN = WIN->col;
X          switch_to_buffer(WIN->buf);
X          restore_win_flags();
X          n = WIN->bot - WIN->top;
X          display_line();
X          while(n--)
X            {
X                fputc('\n',stdout);
X                if (forward_line(1)) display_line();
X            }
X          C_LINE = WIN->beg_line;
X          C_POS = WIN->beg_pos;
X          update_status1(1);
X      }
X    while(WIN != w);
X    set_window(w);
X}
X
void toggle_lock()
X{
X    WIN->lock = !(WIN->lock);
X    update_status(0);
X}
END_OF_FILE
if test 18308 -ne `wc -c <'window.c'`; then
    echo shar: \"'window.c'\" unpacked with wrong size!
fi
# end of 'window.c'
fi
echo shar: End of archive 2 \(of 2\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
