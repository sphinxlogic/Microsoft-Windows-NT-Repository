Newsgroups: comp.sources.unix
From: davis@pacific.mps.ohio-state.edu (John E. Davis)
Subject: v26i148: most-3.2 -- more/less replacement, V3.2, Part01/02
Sender: unix-sources-moderator@vix.com
Approved: paul@vix.com

Submitted-By: davis@pacific.mps.ohio-state.edu (John E. Davis)
Posting-Number: Volume 26, Issue 148
Archive-Name: most-3.2/part01

[ I renamed the aa_readme.doc file to README and I removed the preformatted
  man page since there's an NROFF-style man page included.		--vix ]

MOST version 3.2 is now ready.  It is a more/less type program which runs on
both VMS and unix systems.  In particular it runs on Ultrix and SunOS versions
of unix.  I have also ported it to unix system 5 but due to time constraints,
I removed some of the functionality.  Hence, the present version compiles only
under BSD type unix systems (and, of course, VMS).  Strictly speaking, the
program works only for VTxxx compatable terminals.  However, this is not as
restrictive as it might at first seem since many terminals, including xterm,
understand the vtxxx escape sequences.

New Features in MOST version 3.2   (June 1, 1992)

1.  Some Bugs fixed.
2.  EDT editor keypad keymappings now available (Thanks to Mark Pizzolato)
3.  New most.1 man page (Thanks to David W. Sanderson)

     AUTHOR
          John E. Davis
          The Ohio State University
          Department of Physics
          davis@pacific.mps.ohio-state.edu

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 2)."
# Contents:  MANIFEST README buffer.c buffer.h changes.txt cmd.c dir.c
#   display.c display.h edit.c externs.h file.c file.h help.c keym.h
#   line.c line.h main.c make.com makecom.com makefile most.c most.h
#   rtl.opt search.c search.h sysdep.h window.h
# Wrapped by vixie@gw.home.vix.com on Tue Apr 13 13:04:52 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1088 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	
X README                     1	
X buffer.c                   1	
X buffer.h                   1	
X changes.txt                1	
X cmd.c                      1	
X dir.c                      1	
X display.c                  1	
X display.h                  1	
X edit.c                     1	
X externs.h                  1	
X file.c                     1	
X file.h                     1	
X help.c                     1	
X keym.c                     2	
X keym.h                     1	
X line.c                     1	
X line.h                     1	
X main.c                     1	
X make.com                   1	
X makecom.com                1	
X makefile                   1	
X most.1                     2	
X most.c                     1	
X most.h                     1	
X rtl.opt                    1	
X search.c                   1	
X search.h                   1	
X sysdep.c                   2	
X sysdep.h                   1	
X window.c                   2	
X window.h                   1	
END_OF_FILE
if test 1088 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(2347 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
The following files should be present in this distribution:
X
X    aaa_read.me   ---  This file (called README in the comp.sources.unix relse)
X
X    most.c main.c buffer.c file.c window.c display.c sysdep.c keym.c
X    search.c help.c edit.c dir.c cmd.c line.c --- C files
X
X    most.h buffer.h file.h window.h display.h sysdep.h keym.h
X    search.h externs.h  --- Header files
X
X    makefile      --  makefile for unix systems
X    make.com      --  `makefile' for VMS
X    rtl.opt       --  options file for VMS linking
X    changes.txt   --  summary of recent changes
X    most.doc      --  main documentation for most
X    most.1        --  nroff source
X
X
To make MOST requires an ansi compatable c compiler.  It compiles fine with
X`cc most.c' on Ultrix and VMS, and `CC +V most.c -o most' on a sun4.
Other than this, I do not know what else to say.
X
X                          INSTALLATION INSTRUCTIONS
X
On VMS, type `@make' at the DCL prompt to build most.  On unix, `make' should
work--- if not, the makefile may need edited.
X                          
Then to run most, just type `most "filename"' (eg. `most login.com').
X
MOST has online help which is invoked with the `h' key.  To get online help
functioning properly, the logical name `MOST_HELP' must be defined to point
the correct doc file.  To do this, put the following in your .cshrc (or equiv)
file:
X
setenv MOST_HELP <directory of most.help>most.doc
X
and if you are on VMS put
X
X$ define/nolog MOST_HELP <directory of most.help>MOST.DOC
X
XFor example, I have
X
setenv MOST_HELP /u2/davis/most/most.doc
X
in my .cshrc on a unix host.
X
The other logical that most reads is `MOST_SWITCHES'.  This allows the user to
run MOST with whatever switches are defined by this logical.  I use most with
the -s and -c switches so I have
X
setenv MOST_SWITCHES "-sca"
X
in my .cshrc file for unix and
X
X$ define/nolog MOST_SWITCHES "-sca"
X
in my login.com file on VMS.
X
X
I suggest that you first build MOST then view the doc file using MOST (`most
most.doc').  If you need help, hit the `h' key from within MOST.  The `h' key
simply locates the part of the doc file that describes what the various key
do.  One person has suggested that I use a one page help screen.  However, I
chose not to do this.  Most has very few key sequences to memorize and the one
page help screen will quickly outgrow it usefulness.
END_OF_FILE
if test 2347 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'buffer.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'buffer.c'\"
else
echo shar: Extracting \"'buffer.c'\" \(9310 characters\)
sed "s/^X//" >'buffer.c' <<'END_OF_FILE'
X#include "buffer.h"
X#include "externs.h"
X#include "display.h"
X#include "line.h"
X  
int MOST_W_OPT = 0;
X
unsigned char *BEG;             /* beginning of current buffer */
unsigned char *EOB;             /* end of current buffer */
unsigned char MINI_BUF[132];
X
Buffer *BUF;
X
extern int SQUEEZE_LINES;
int NUM_LINES;
int ACTUAL_LINES;
X
unsigned char *C_POS;
int C_LINE;
X
unsigned char *beg_of_line1()
X{
X    unsigned char *pos;
X    
X    if (C_POS == BEG) return BEG;
X
X    pos = C_POS;
X    if (pos == EOB) pos--;
X
X    if ((*pos != '\n') && (*(pos-1) == '\n')) return(pos);
X    
X    if ((*pos == '\n') && (pos == BEG)) return(BEG);
X    /* suppose BEG[] is "....\nabcde\n\n\n\n\n..." and we are somwhere in
X       the middle of the \n's.  Then we want to return the 2nd \n if the
X       SQUEEZE is on otherwise just return where we are. */
X    if ((*pos-- == '\n') && (*pos == '\n'))
X      {
X          if (SQUEEZE_LINES)
X            {
X                /* if we are between '\n's then skip past all of them. */
X                while ((pos > BEG) && (*pos == '\n')) pos--;
X                if ((pos == BEG) && (*pos == '\n')) return (BEG);
X                pos++;
X            }
X          return (++pos);
X      }      
X    
X    while((pos > BEG) && (*pos != '\n')) pos--;
X    if (pos != BEG) pos++;
X    else if ((pos == BEG) && (*pos == '\n')) pos++;
X    return pos;
X}
X
unsigned char *beg_of_line()
X{
X    unsigned char *b;
X    int d,n;
X    
X    if (!MOST_W_OPT) return beg_of_line1();
X    b = beg_of_line1();
X    d = C_POS - b;
X    n = d / SCREEN_WIDTH_M1;
X    return(b +  (int) (n * SCREEN_WIDTH_M1));
X}
X
X/* does not move point */
unsigned char *end_of_line1()
X{
X    unsigned char *pos;
X
X    pos = C_POS;
X    if (pos >= EOB)  return(EOB);
X    /*     if ((pos == BEG) && (*pos == '\n')) return (BEG); */
X    
X    /* find the first '\n' */
X    if (*pos != '\n')
X      {
X          while ((pos < EOB) && (*pos != '\n')) pos++;
X          return(pos);
X      }
X    
X    if (!SQUEEZE_LINES) return (pos);
X
X    /* if BEG = "....abc\n\n\n\n\ndef..." then we are at some first \n.  We
X       want to return the last '\n' unless we wre at the first '\n'. */
X
X    if ((pos > BEG) && ( pos--, *pos++ != '\n')) return (pos); 
X    
X    while ((pos < EOB) && (*pos == '\n')) pos++;
X    if (pos-- == EOB) return (pos);
X    if (pos < BEG) pos = BEG;
X    return pos;
X}
X
unsigned char *end_of_line()
X{
X    unsigned char *b, *e;
X    int n;
X    
X    if (!MOST_W_OPT) return end_of_line1();
X
X    b = beg_of_line();
X    e = end_of_line1();
X    n = (e - b) / SCREEN_WIDTH_M1;
X    if (n) return(b + SCREEN_WIDTH_M1);
X    return (e);
X}
X
int forward_line(int n)
X{
X    int m, ok;
X    int save = n;
X    unsigned char *p;
X    if (n > 0) 
X      {
X          if (MOST_B_OPT)
X            {
X                m = (EOB - C_POS)/16;
X                if (n > m) n = m;
X                C_POS += n * 16;
X                C_LINE += n;
X                return n;
X            }
X          else while (n--)
X            {
X                C_POS = end_of_line();
X                /* next step handles newline at the EOB */
X                if ((C_POS == EOB) || ((C_POS == EOB - 1) && (*C_POS == '\n'))) return (save - n - 1);
X                C_LINE++;
X                C_POS++;
X                if (MOST_S_OPT)
X                  {
X                      p = C_POS;
X                      ok = 1;
X                      while ((*p <= ' ') && ok)
X                        {
X                            if (*p != '\n') p++;
X                            if (p >= EOB) break;
X                            if ((*p == '\n') || (apparant_distance(p) >= MOST_S_OPT))
X                              {
X                                  ok = 0;
X                                  C_LINE--;
X                                  n++;
X                              }
X                        }
X                  } /* MOST_S_OPT */
X            }
X      }
X    else
X      {
X          if (MOST_B_OPT)
X            {
X                m = (BEG - C_POS)/16;
X                if (n < m) n = m;
X                C_POS += n * 16;
X                C_LINE += n;
X                return n;
X            }
X          else while (n++)
X            {
X                C_POS = beg_of_line();
X                if (C_POS == BEG) return (n - save - 1);
X                C_POS--;
X                C_LINE--;
X                if (MOST_S_OPT)
X                  {
X                      C_POS = beg_of_line();
X                      p = C_POS;
X                      ok = 1;
X                      while ((*p <= ' ') && ok)
X                        {
X                            if (*p != '\n') p++;
X                            if (p >= EOB) break;
X                            if ((*p == '\n') || (apparant_distance(p) >= MOST_S_OPT))
X                              {
X                                  ok = 0;
X                                  C_LINE++;
X                                  n--;
X                              }
X                        }
X                  } /* MOST_S_OPT */
X            }
X      }
X    return(save);
X}
X
int count_lines(unsigned char *beg, unsigned char *end)
X{
X    int save_line = C_LINE, n;
X    unsigned char *save_beg = beg, *save_eob = EOB, *save_pos = C_POS;
X
X    if (MOST_B_OPT) return((int)(end - beg) / 16);
X    BEG = C_POS = beg;
X    EOB = end;
X    n = 1;
X    while(forward_line(1)) n++;
X    if (*end ==  '\n') n--;
X    if (!n) n = 1;
X    C_POS = save_pos;
X    EOB = save_eob;
X    BEG = save_beg;
X    C_LINE = save_line;
X    return(n);
X}
X
void goto_line(int line)
X{
X    register int i,j;
X    unsigned char *pos;
X    int dif_c, dif_b,dif_t;
X
X    if (line < 1) line = 1;
X    if (line > NUM_LINES) line = NUM_LINES;
X
X    if (MOST_B_OPT)
X      {
X          C_POS = BEG + (16 * (line - 1));
X          C_LINE = line;
X          return;
X      }
X    
X    dif_c = line - C_LINE;
X    dif_b = line - NUM_LINES;
X    dif_t = line - 1;
X
X    /* 4 possibilites */
X    if (dif_c <= 0)
X      {
X          if (dif_t < -dif_c) /* go from top */
X            {
X                C_LINE = 1;
X                C_POS = BEG;
X                (void) forward_line(dif_t);
X            }
X          else  /* from curr back */
X            {
X                (void) forward_line(dif_c);
X            }
X      }
X    else if (dif_c > 0)
X      {
X          if ((dif_c + dif_b) < 0) /* go from curr */
X            {
X                (void) forward_line(dif_c);
X            }
X          else
X            {
X                C_LINE = NUM_LINES;
X                C_POS = EOB;
X                (void) forward_line(dif_b);
X            }
X      }
X}       
X
X/* return line the point is on without the final '\n's
X    unless beg = end in which case we take care of it later ...
X
X    returns 1 if the line should be wrapped */
int extract_line(unsigned char **beg, unsigned char **end)
X{
X    *beg = beg_of_line();
X    *end = end_of_line();
X    if (**end != '\n') return(1);
X    while ((*end > BEG) && (**end == '\n')) *end = *end - 1;
X    return(0);
X}    
X
int what_line(unsigned char *pos)
X{
X    
X    unsigned char *save_pos;
X    int save_line, dir;
X    register int dif_c, dif_b,dif_t;
X    int ret;
X
X    if (MOST_B_OPT)
X      {
X          return (1 + (pos - BEG)/16);
X      }
X    
X        
X    save_pos = C_POS;
X    save_line = C_LINE;
X    
X    dif_c = pos - C_POS;
X    dif_b = pos - EOB;
X    dif_t = pos - BEG;
X
X    /* 4 possibilites */
X    if (dif_c <= 0)
X      {
X          if (dif_t < -dif_c) /* go from top */
X            {
X                C_LINE = 1;
X                C_POS = BEG;
X                dir = 1;
X            }
X          else  /* from curr back */
X            {
X                dir = -1;
X            }
X      }
X    else if (dif_c > 0)
X      {
X          if ((dif_c + dif_b) < 0) /* go from curr */
X            {
X                dir = 1;
X            }
X          else
X            {
X                C_LINE = NUM_LINES;
X                C_POS = EOB;
X                dir = -1;
X            }
X      }
X    if (dir == 1)
X      {
X          while(C_POS = end_of_line(), C_POS < pos)
X            {
X                C_POS++;
X                C_LINE++;
X            }
X      }
X    else
X      {
X          while(C_POS = beg_of_line(), pos < C_POS)
X            {
X                C_LINE--;
X                C_POS--;
X            }
X      }
X
X    ret = C_LINE;
X    C_POS = save_pos;
X    C_LINE = save_line;
X    return(ret);
X}
X
X/* given a buffer position, find the line and column */
void find_row_column(unsigned char *pos, int *r, int *c)
X{
X    unsigned char *beg, *save_pos;
X    int save_line;
X
X
X    if (pos <= BEG)
X      {
X          *r = 1;
X          *c = 1;
X          return;
X      }
X
X    save_line = C_LINE;
X    save_pos = C_POS;
X    *r = what_line(pos);
X    
X    if (MOST_B_OPT)
X      {
X          *c = (int) (pos - BEG) - *r * 16 + 1;
X          return;
X      }
X    C_LINE = *r;
X    C_POS = pos;
X    
X    /* Now we have found the line it is on so.... */
X    beg = beg_of_line();
X    *c = 1;
X    while (beg++ < pos) *c = *c + 1;
X    C_LINE = save_line;
X    C_POS = save_pos;
X}       
X
Buffer *switch_to_buffer(Buffer *new)
X{
X    Buffer *old;
X    old = BUF;
X    BUF = new;
X    BEG = BUF->beg;
X    EOB = BUF->end;
X    return(old);
X}
X
void delete_buffer(Buffer *old)
X{
X    (void) free(BUF);
X    BUF = old;
X    BEG = BUF->beg;
X    EOB = BUF->end;
X}
X
Buffer *create_buffer(char *file)
X{
X    Buffer *buf;
X
X    buf = (Buffer *) malloc(sizeof(Buffer));
X    strcpy(buf->file,file);
X    return(buf);
X}
END_OF_FILE
if test 9310 -ne `wc -c <'buffer.c'`; then
    echo shar: \"'buffer.c'\" unpacked with wrong size!
fi
# end of 'buffer.c'
fi
if test -f 'buffer.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'buffer.h'\"
else
echo shar: Extracting \"'buffer.h'\" \(2037 characters\)
sed "s/^X//" >'buffer.h' <<'END_OF_FILE'
X#ifndef _DAVIS_BUFFER_H_
X#define _DAVIS_BUFFER_H_
X
typedef struct
X  {
X      char file[80];            /* filename */
X      unsigned char *beg;       /* beginning of buffer */
X      unsigned char *end;       /* end of buffer */
X      int mark;                 /* marked line in buffer */
X  } Buffer;
X
X
extern int NUM_LINES;
extern Buffer *BUF;
extern unsigned char *BEG, *EOB;
extern unsigned char MINI_BUF[132];
X/* The buffer.
X
X   The beginning of the first character is at BUF.  The last character
X   in the file is located at position EOB-1.  So if we are at position EOB,
X   then we can insert a character past the last point.  EOB = BUF + BUF_SIZE;
X.
X*/
X  
extern unsigned char *C_POS;
X/* 
X *  current position of point.  Considered to be between the previous
X *  character and the next character.  There is no current character.
X *  If we are at the beginning of the buffer BUF, then its value is BUF.
X *  If we are at the end of the buffer it is BUF + BUF_SIZE = EOB.
X */
X
extern int C_LINE;
X/* 
X *  Current line number.  If at the beginning of the buffer, it is 1.  If
X *  we are at the last point of the buffer it is the number of lines.
X */
X
X/* These two routines do not move the point */  
extern unsigned char *beg_of_line();
extern unsigned char *end_of_line();
X
extern int forward_line(int);
X/* This routine moves the point forward n lines. n can be negative. 
X   It returns the number moved. */
X
extern void goto_line(int);
X/* Move the point somewhere on the nth line of the buffer returning
X   C_POS */
X
extern int what_line(unsigned char *);
X/* return the line number of position 'argument'. Does not move point */
X
X/* count the number of lines in the region delimited by beg and end.
X   Counts lines from beg up to end but does not count end.
X   Does not move point. */
extern int count_lines(unsigned char *, unsigned char *);
extern int extract_line(unsigned char **, unsigned char **);
X
extern Buffer *switch_to_buffer(Buffer *);
extern void delete_buffer(Buffer *);
extern Buffer *create_buffer(char *);
X
X
X#endif
X  
END_OF_FILE
if test 2037 -ne `wc -c <'buffer.h'`; then
    echo shar: \"'buffer.h'\" unpacked with wrong size!
fi
# end of 'buffer.h'
fi
if test -f 'changes.txt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'changes.txt'\"
else
echo shar: Extracting \"'changes.txt'\" \(264 characters\)
sed "s/^X//" >'changes.txt' <<'END_OF_FILE'
New Features in MOST version 3.2   (June 1, 1992)
X
X1.  Some Bugs fixed.
X2.  EDT editor keypad keymappings now available (Thanks to Mark Pizzolato)
X3.  New most.1 man page (Thanks to David W. Sanderson)
X
John E. Davis
davis@amy.tch.harvard.edu
davis@ohstpy.bitnet
X
END_OF_FILE
if test 264 -ne `wc -c <'changes.txt'`; then
    echo shar: \"'changes.txt'\" unpacked with wrong size!
fi
# end of 'changes.txt'
fi
if test -f 'cmd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cmd.c'\"
else
echo shar: Extracting \"'cmd.c'\" \(3985 characters\)
sed "s/^X//" >'cmd.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <string.h>
X#include "sysdep.h"
X#include "search.h"
X#include "window.h"
X#include "file.h"
X#include "keym.h"
X#include "externs.h"
X
X/* returns zero if not quit */
X  
int do_extended_key()
X{
X    char ch;
X    static int next = 1;
X    int quit = 0, n;
X    unsigned char *save;
X    
X    select_minibuffer();  putc(':',stdout); fflush(stdout);
X    ch = getkey();
X    putc(ch,stdout); fflush(stdout);
X    if (ch == 'n')
X      {
X          if (!NUM_FILES)
X            {
X                message("File ring is empty.",1);
X            }
X          quit = next_file(&next);
X          if (next == -1) quit = 1;
X      }
X    else if ((ch == 'c') || (ch == 'C'))   /* toggle case sensitive search */
X      {
X          CASE_SENSITIVE = !CASE_SENSITIVE;
X          if (CASE_SENSITIVE)
X            message("Searches now respect case.",0);
X          else
X            message("Searches nolonger respect case.",0);
X      }
X    else if ((ch == 'D') && MOST_D_OPT) /* delete file */
X      {
X          /* notice the missing D. */
X          fprintf(stdout,"elete %s? [n]:", BUF->file);
X          fflush(stdout);
X          ch = getkey();
X          if (ch == 'y')
X            {
X                if (!sys_delete_file(BUF->file))
X                  message("File could not be deleted.",1);
X                else
X                  message("File deleted.",0);
X            }
X          else
X            message("File not deleted.",0);
X      }
X    else if (ch == 'o')
X      {
X          fputs("\rToggle option: b d t v w",stdout); fflush(stdout);
X          ch = getkey();
X          if ((ch == 'd') || (ch == 'w') || (ch == 'b') || (ch == 't') || (ch == 'v') || (ch == 's'))
X            {
X                if (ch == 'b')
X                  {
X                      MOST_B_OPT = !MOST_B_OPT;
X                      NUM_LINES = count_lines(BEG,EOB);
X                  }
X                else if (ch == 'd')
X                  {
X                      if (DIGIT_ARG == NULL)
X                        {
X                            message("Selective Display off.",0);
X                            n = 0;
X                        }
X                      else n = abs( *DIGIT_ARG );
X                      if (MOST_S_OPT != n)
X                        {
X                            MOST_S_OPT = n;
X                            NUM_LINES = count_lines(BEG,EOB);
X                        }
X                  }
X                else if ((ch == 's') && !MOST_B_OPT)
X                  {
X                      SQUEEZE_LINES = !SQUEEZE_LINES;
X                      NUM_LINES = count_lines(BEG,EOB);
X                  }
X                else if (ch == 'w')
X                  {
X                      MOST_W_OPT = !MOST_W_OPT;
X                      NUM_LINES = count_lines(BEG,EOB);
X                  }
X                else if (ch == 'v') MOST_V_OPT = !MOST_V_OPT;
X                else if (ch == 't') MOST_T_OPT = !MOST_T_OPT;
X
X                if (!NUM_LINES) NUM_LINES = 1;
X                
X                save_win_flags(WIN);
X                save = C_POS;
X                C_POS = BEG;
X                C_LINE = 1;
X                C_LINE = what_line(save);
X                C_POS = save;
X                WIN->beg_line = C_LINE;
X                delete_line(1);
X                exit_minibuffer();
X                redraw_window();
X                update_status(0);
X                return(quit);
X            }
X      }
X    else
X      {
X          putc('\007',stdout);
X          delete_line(1);
X      }
X    fflush(stdout);
X    
X    exit_minibuffer();
X    return(quit);
X}
X
X/* returns zero if not quit */
X
int do_extended_cmd()
X{
X    char cmd[80];
X    int quit = 0;
X    cmd[0] = 0;
X    if (!read_from_minibuffer("Cmd:",cmd)) return 0;
X    
X    if (!strcmp(cmd,"cd"))
X      {
X          cd();
X      }
X    else if ((!strncmp(cmd,"quit",strlen(cmd))) || 
X	     (!strncmp(cmd,"exit",strlen(cmd))))
X      {
X          quit = -1;
X      }
X    else
X      {
X          strcat(cmd," not understood.");
X          message(cmd,1);
X      }
X    return(quit);
X}
END_OF_FILE
if test 3985 -ne `wc -c <'cmd.c'`; then
    echo shar: \"'cmd.c'\" unpacked with wrong size!
fi
# end of 'cmd.c'
fi
if test -f 'dir.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dir.c'\"
else
echo shar: Extracting \"'dir.c'\" \(2665 characters\)
sed "s/^X//" >'dir.c' <<'END_OF_FILE'
X/* directory functions-- mainly unix stuff, needs work for VMS */
X#ifndef VMS
X#include <sys/types.h>
X#include <sys/dir.h>
X#endif
X
X#include "buffer.h"
X#include "window.h"
X#include "file.h"
X
void get_cdir(char *dir)
X{
X    int i;
X#ifndef VMS
X    getwd(dir);
X    i = strlen(dir); dir[i] = '/'; dir[i] = '\0';
X#else
X    getcwd(dir,80);
X#endif
X}
X
X
X#ifndef VMS
X/* This is a cheap routine-- should be replaced!!!! */
bubble_sort()
X{
X    unsigned char *this, *next, *save;
X    char tmp[80], *t;
X    int change;
X    
X    change = 1;
X    while(change)
X      {
X          next = this = BEG;
X          while((next < EOB) && (*next++ != 0));
X          if (next == EOB) return;
X          change = 0;
X          while(next < EOB)
X            {
X                if (strcmp((char *)this,(char *) next) > 0)
X                  {
X                      change = 1;
X                      strcpy(tmp,(char *) this);
X                      t = tmp;
X                      while(*next != 0) *this++ = *next++;
X                      *this++ = 0;
X                      save = this;
X                      /* now next points at a null */
X                      next++;
X                      while(*t != 0) *this++ = *t++;
X                      *this = 0;
X                      this = save;
X                  }
X                else
X                  {
X                      this = next;
X                      while(next < EOB && *next++ != 0);
X                  }
X            }
X      }
X}
X
void get_dir(char *dir)
X{
X    DIR *dirp;
X    struct direct *dp;
X    char *p;
X    unsigned char *pos;
X    int dsize, len, size = 4096, i;
X    
X    if (*dir == 0)
X      dirp = opendir(".");
X    else
X      dirp = opendir(dir);
X
X    if (dirp == NULL)
X      {
X          message("Unable to open directory.",1);
X          return;
X      }
X    
X          
X    BEG = (unsigned char *) malloc(size);
X    strcpy(BUF->file,dir);
X    pos = BEG;
X    dsize = size;
X    EOB = BEG + size;
X    
X    for(dp = readdir(dirp); dp != NULL; dp = readdir(dirp))
X      {
X          p = dp->d_name;
X          len = dp->d_namlen;
X          if (pos + len >= EOB - 1)
X            {
X                size += dsize;
X                BEG = (unsigned char *) realloc(BEG,size);
X                
X                EOB = BEG + size;
X                pos = EOB - dsize;
X            }
X          strcpy(pos,p);
X          pos += len;
X          /*           *pos++ = '\n'; */
X          *pos++ = '\0';
X      }
X
X    BUF->end = EOB = pos;
X    BUF->beg = BEG;
X    closedir(dirp);
X    bubble_sort();
X    i = 0;
X    for (pos = BEG; pos < EOB; pos++)
X      if (*pos == '\0')
X        {
X            if (i = !i, i) *pos = '\t'; else *pos = '\n';
X        }
X    
X}
X#endif
X
END_OF_FILE
if test 2665 -ne `wc -c <'dir.c'`; then
    echo shar: \"'dir.c'\" unpacked with wrong size!
fi
# end of 'dir.c'
fi
if test -f 'display.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'display.c'\"
else
echo shar: Extracting \"'display.c'\" \(7762 characters\)
sed "s/^X//" >'display.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "buffer.h"  
X#include "display.h"  
X#include "sysdep.h"  
X
int SCREEN_WIDTH = 80;
int SCREEN_WIDTH_M1 = 79;
int SCREEN_HEIGHT = 24;
int SCREEN_ROWS = 23; /* height - 1 */
X
extern int MOST_L_OPT;
X
char *INS_MODE_STR = "\033[4h";   /* ins mode (im) */
char *EINS_MODE_STR = "\033[4l";  /* end ins mode (ei) */
char *SCROLL_R_STR = "\033[%d;%dr"; /* scroll region */
char *CLS_STR = "\033[2J\033[H";  /* cl termcap STR  for ansi terminals */
char *CLR_BOS_STR = "\033[1J";   /* erase to beg of screen */
char *REV_INDEX_STR = "\033M";     /* sr termcap string */
char *REV_VID_STR = "\033[7m";    /* mr,so termcap string */
char *BOLD_VID_STR = "\033[1m";    /**/
char *UNDL_VID_STR = "\033[4m";    /**/
char *NORM_VID_STR = "\033[m";   /* me,se termcap string */
char *DEL_BOL_STR = "\033[1K\r";  /* cb termcap entry */
char *DEL_EOL_STR = "\033[K"; 
char *HOME_CURS_STR = "\033[H";   /* ho termcap string */
char *DEL_LINE_STR = "\r\033[K";   /* dl termcap string except cursor at bol */
char *DEL_CHAR_STR = "\033[P";   /* dc */
char *DEL_N_LINES_STR = "\033[%dM";  /* DL */
char *ADD_N_LINES_STR = "\033[%dL";  /* AL */
char *CURS_F_STR = "\033[%dC";    /* RI termcap string */
char *CURS_B_STR = "\033[%dD";    /* RI termcap string */
char *CURS_U_STR = "\033[%dA";    /* RI termcap string */
char *CURS_D_STR = "\033[%dB";    /* RI termcap string */
X/* cm string has %i%d since termcap numbers columns from 0 */
X/* char *CURS_POS_STR = "\033[%d;%df";  ansi-- hor and vert pos */
char *CURS_POS_STR = "\033[%d;%dH";   /* cm termcap string */
X
X
void set_scroll_region(int r1, int r2)
X{
X    fprintf(stdout,SCROLL_R_STR,r1,r2);
X}
X
void goto_rc(int r, int c)
X{
X    fprintf(stdout,CURS_POS_STR,r,c);
X}
void curs_bol()
X{
X    fputc('\015',stdout);
X}
X
void cursor_forward(int n)
X{
X    fprintf(stdout,CURS_F_STR,n);
X}
X
void cursor_backward(int n)
X{
X    fprintf(stdout,CURS_B_STR,n);
X}
X
void cursor_up(int n)
X{
X    fprintf(stdout,CURS_U_STR,n);
X}
X
void cursor_down(int n)
X{
X    fprintf(stdout,CURS_D_STR,n);
X}
X
void begin_insert()
X{
X    fputs(INS_MODE_STR,stdout);
X}
X
void end_insert()
X{
X    fputs(EINS_MODE_STR,stdout);
X}
X
void delete_char()
X{
X    fputs(DEL_CHAR_STR,stdout);
X}
X
void delete_line(int n)
X{
X      fprintf(stdout,DEL_LINE_STR);
X}
X
void delete_nlines(int n)
X{
X    if (n) fprintf(stdout,DEL_N_LINES_STR,n);
X}
X
void clr_bos()   /* delete to beg of screen */
X{
X    fputs(CLR_BOS_STR,stdout);
X}
X
void set_attribute(int attr)
X{
X    fprintf(stdout,"\033[%dm",attr);
X}
X
void cls()
X{
X    fputs(CLS_STR,stdout);
X}
X
void reverse_index(int n)
X{
X    while(n--)
X      fputs(REV_INDEX_STR,stdout);
X}
X
X/* assumes both old and new are the same length */
smart_puts(char *new,char *old,FILE *fp)
X{
X    char out[250], ch, ch1;
X    int ii,max_len,i,mark;
X
X    i = 0;
X    ii = 0;
X    while(ch = *new++, ch1 = *old++, (ch == ch1) && (ch != '\0')) i++;
X    if (ch == '\0') return;
X
X    max_len = strlen(CURS_F_STR);
X    if (i) fprintf(fp, CURS_F_STR, i);
X
X    while(1)
X      {
X          i = 1; ii = 0;
X          out[ii++] = ch;
X          while (ch = *new++, ch1 = *old++, ch != ch1 && ch != '\0') out[ii++] = ch;
X          mark = ii;
X          out[ii++] = ch;
X          while (ch = *new++, ch1 = *old++, ch == ch1 && ch != '\0')
X            {
X                i++;
X                out[ii++] = ch;
X            }
X          out[ii] = '\0';
X          if (ii > max_len)
X            {
X                out[mark] = '\0';
X                fputs(out,fp);
X                if (ch == '\0') return;
X                if (i) fprintf(fp, CURS_F_STR, i);
X            }
X          else
X            {
X                fputs(out,fp);
X                if (ch == '\0') return;
X            }          
X      }    
X}    
X    
X
X#ifndef VMS
X/*  This routine may be problematic when there are more windows than
X    the new screen size can support.  Until I think of what to do,
X    I  have not touched this routine. */
void resize_display()
X{
X    char c;
X
X    get_term_dimensions(&SCREEN_WIDTH, &SCREEN_HEIGHT);
X    if (SCREEN_WIDTH == 0) SCREEN_WIDTH = 80;
X    if (SCREEN_HEIGHT == 0) SCREEN_HEIGHT = 24;
X    SCREEN_ROWS = SCREEN_HEIGHT - 1;
X    SCREEN_WIDTH_M1 = SCREEN_WIDTH - 1;
X    c = 'R';   /* force a redraw of screen */
X    ioctl(0,TIOCSTI,&c);
X}
X#endif
X
void get_terminfo()
X{
X
X#ifndef VMS
X    (void) signal(SIGWINCH,resize_display); 
X#endif
X    
X    get_term_dimensions(&SCREEN_WIDTH, &SCREEN_HEIGHT); 
X    if (SCREEN_WIDTH == 0) SCREEN_WIDTH = 80;
X    if (SCREEN_HEIGHT == 0) SCREEN_HEIGHT = 24;
X    SCREEN_ROWS = SCREEN_HEIGHT - 1;
X    SCREEN_WIDTH_M1 = SCREEN_WIDTH - 1;
X
X    /* someday I will add something here for non-dec terminals
X       perhaps a 'most-cap' terminal entry :^)
X
X       For the time being we do it in this rather primitive manner */
X
X    if (MOST_L_OPT)   /* dumb terminal */
X      {
X          CLS_STR = "\014";  /* a formfeed */
X          REV_INDEX_STR = "";
X          REV_VID_STR = "";
X          BOLD_VID_STR = "";    /**/
X          UNDL_VID_STR = "";    /**/
X          NORM_VID_STR = "";
X          HOME_CURS_STR = "";
X          DEL_LINE_STR = "";
X          DEL_BOL_STR = DEL_LINE_STR;  /* for our purposes */
X          CURS_F_STR = "";
X          CURS_POS_STR = "";
X      }
X    
X}
X
X
X
void narrow_width()
X{
X    fputs("\033[?3l",stdout);
X}
X
void wide_width()
X{
X    fputs("\033[?3h",stdout);
X}
X
X
void set_width(int width, int redraw)
X{
X#ifdef VMS
X    short fd;
X    int status;
X    iosb iostatus;
X    static termchar tc; /* Terminal characteristics   */
X    $DESCRIPTOR( devnam, "SYS$ERROR");
X#else
X    struct winsize wind_struct;
X#endif      
X
X    /* Switching physical terminal to narrow/wide mode.*/
X          
X    if(width<=80)
X      {
X          width = 80;
X          narrow_width();
X      }
X    else
X      {
X          width = 132;
X          wide_width();
X      }
X    SCREEN_WIDTH = width;
X    SCREEN_WIDTH_M1 = width - 1;
X    
X#ifdef VMS
X    /* Assign input to a channel */
X    status = sys$assign(&devnam, &fd, 0, 0);
X    if ((status & 1) == 0)
X      exit(status);
X    /* Get current terminal characteristics */
X    status = sys$qiow(          /* Queue and wait   */
X                      0,        /* Wait on event flag zero  */
X                      fd,       /* Channel to input terminal  */
X                      IO$_SENSEMODE, /* Get current characteristic */
X                      &iostatus, /* Status after operation */
X                      0, 0,     /* No AST service   */
X                      &tc,      /* Terminal characteristics buf */
X                      sizeof(tc), /* Size of the buffer   */
X                      0, 0, 0, 0); /* P3-P6 unused     */
X    
X    /*set terminal characteristics */
X    tc.t_width=width;
X    status = sys$qiow(           /* Queue and wait   */
X                      0,           /* Wait on event flag zero  */
X                      fd,           /* Channel to input terminal  */
X                      IO$_SETMODE,   /* Get current characteristic */
X                      &iostatus,       /* Status after operation */
X                      0, 0,            /* No AST service   */
X                      &tc,             /* Terminal characteristics buf */
X                      sizeof(tc),      /* Size of the buffer   */
X                      0, 0, 0, 0);     /* P3-P6 unused     */
X    
X    if( (sys$dassgn(fd)  & 1)==0)
X      exit(status);
X
X    /* here we redraw the screen, on unix, we assume that the terminal
X       driver sends the appropriate signal that most catches to redraw so we
X       do not redraw because it is likely that screen will be redrawn twice */
X
X    if (redraw) redraw_display();
X#else
X    /* this may need work on other unix-- works for sun4 */
X    ioctl(2,TIOCGWINSZ,&wind_struct);
X    wind_struct.ws_col = width;
X    ioctl(2,TIOCSWINSZ,&wind_struct);
X    
X#endif /* VMS */
X}
X
X
END_OF_FILE
if test 7762 -ne `wc -c <'display.c'`; then
    echo shar: \"'display.c'\" unpacked with wrong size!
fi
# end of 'display.c'
fi
if test -f 'display.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'display.h'\"
else
echo shar: Extracting \"'display.h'\" \(688 characters\)
sed "s/^X//" >'display.h' <<'END_OF_FILE'
X  
X#ifndef VMS
X#include <signal.h>
X#endif
X
extern int SCREEN_WIDTH;
extern int SCREEN_WIDTH_M1;
extern  int SCREEN_HEIGHT;
extern  int SCREEN_ROWS; /* height - 1 */
X
extern void set_scroll_region(int, int);
extern void goto_rc(int, int);
extern void curs_bol();
extern void cursor_forward(int);
extern void cursor_backward(int);
extern void cursor_up(int);
extern void cursor_down(int);
extern void begin_insert();
extern void end_insert();
extern void delete_char();
extern void delete_line(int);
extern void set_attribute(int);
extern void cls();
extern void reverse_index();
extern void set_width(int, int);
extern void get_terminfo();
X#ifndef VMS
extern void resize_display();
X#endif
END_OF_FILE
if test 688 -ne `wc -c <'display.h'`; then
    echo shar: \"'display.h'\" unpacked with wrong size!
fi
# end of 'display.h'
fi
if test -f 'edit.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'edit.c'\"
else
echo shar: Extracting \"'edit.c'\" \(1935 characters\)
sed "s/^X//" >'edit.c' <<'END_OF_FILE'
X/* editor functions */
X
X#include "externs.h"
X#include "window.h"
X#include "sysdep.h"
X
X#ifdef VMS
X
int call_edt_tpu(char *file, int line, int what)
X{
X    char the_file[100];
X    extern void edt$edit();
X    extern void tpu$tpu();
X    struct dsc$descriptor_s  file_desc;
X    if (what == 1)  /* tpu */
X      strcpy(the_file,"TPU ");
X    else
X      the_file[0] = '\0';
X    
X    strcat(the_file,file);
X    
X    file_desc.dsc$w_length = strlen(the_file);
X    file_desc.dsc$a_pointer = the_file;
X    file_desc.dsc$b_class = DSC$K_CLASS_S; /* scalar, string type */
X    file_desc.dsc$b_dtype = DSC$K_DTYPE_T; /* ascii string */
X
X    if (what == 1)
X      tpu$tpu(&file_desc);
X    else
X      edt$edit(&file_desc);
X
X    return(1);
X}
X
int call_emacs(char *file, int line)
X{
X    int status;
X    char lstr[40];
X    (void) sprintf(lstr,"%d",line);
X    define_logical_name("EMACS_FILE_LINE",lstr);
X    define_logical_name("EMACS_FILE_NAME",file);
X    status = do_emacs_command();
X    delete_logical_name("EMACS_FILE_NAME");
X    delete_logical_name("EMACS_FILE_LINE");
X    return(status);
X}
X
void edit_cmd()
X{
X    char *editor, file[80], *strp;
X    int status;
X    
X    if ((editor = getenv("MOST_EDITOR")) == NULL)  editor = "EDT";
X          
X    strcpy(file,WIN->buf->file);
X    strp = file;
X    /*  lose the version number */
X    while((*strp != '\0') && (*strp != ';')) strp++;
X    *strp = '\0';
X    
X    reset_tty();
X    reset_display();
X    fflush(stdout);
X    
X    if (!strcmp(editor,"EMACS"))
X      {
X          status = call_emacs(file,C_LINE);
X      }
X    else if (!strcmp(editor,"EDT"))
X      {
X          status = call_edt_tpu(file,C_LINE,0);
X      }
X    else if (!strcmp(editor,"TPU"))
X      {
X          status = call_edt_tpu(file,C_LINE,1);
X      }
X    else message("Unknown editor.",1);
X    if (status)
X      {
X          redraw_display();
X      }
X    else message("Unable to edit.",1);
X}
X    
X#else
X
void edit_cmd()
X  {
X      ;
X  }
X
X#endif
END_OF_FILE
if test 1935 -ne `wc -c <'edit.c'`; then
    echo shar: \"'edit.c'\" unpacked with wrong size!
fi
# end of 'edit.c'
fi
if test -f 'externs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'externs.h'\"
else
echo shar: Extracting \"'externs.h'\" \(987 characters\)
sed "s/^X//" >'externs.h' <<'END_OF_FILE'
extern char SEARCH_STR[80];
extern int SEARCH_DIRECTION;
extern int STARTING_LINE;   /*  begin at this line upon startup of most */
extern int CASE_SENSITIVE;
X
extern int NUM_LINES;
extern int ACTUAL_LINES;
extern int CURS_ROW;
extern int CURS_COL;
extern unsigned char *CURS_POS;
X
extern int SQUEEZE_LINES;          /* switch parameters */
extern int MOST_L_OPT;             /* use ^L (formfeed) to clear screen */
extern int MOST_V_OPT;             /* display control chars */
extern int MOST_B_OPT;             /* display Binary File */
extern int MOST_T_OPT;             /* display tab as ^I-- valid only with V option */
extern int MOST_W_OPT;             /* wrap lines if true */
extern int MOST_S_OPT;             /* selective display */
extern int MOST_K_OPT;             /* Kanji option */
X
extern int MOST_D_OPT;             /* delete file mode  (see ':D')  */
X
X#define _MOST_V_OPT  1
X#define _MOST_T_OPT  2
X#define _MOST_B_OPT  4
X#define _MOST_SQ_OPT 8
X#define _MOST_W_OPT 16
END_OF_FILE
if test 987 -ne `wc -c <'externs.h'`; then
    echo shar: \"'externs.h'\" unpacked with wrong size!
fi
# end of 'externs.h'
fi
if test -f 'file.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'file.c'\"
else
echo shar: Extracting \"'file.c'\" \(7456 characters\)
sed "s/^X//" >'file.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <string.h>
X#ifndef VMS
X#include <fcntl.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#else
X#include <unixio.h>
X#include <types.h>
X#include <stat.h>
X#endif
X
X#ifndef O_RDONLY
X#define O_RDONLY 0
X#endif
X  
X#include "externs.h"
X#include "file.h"
X#include "keym.h"  
X#include "buffer.h"
X#include "window.h"
X
char *FILE_RING[500];
char C_DIR[80];                 /* current working dir */
int NUM_FILES;
X
extern int SCREEN_WIDTH;
X
int insert_file(char *file)
X{
X    struct stat st;
X    int i,n,size, fd, dsize;
X    unsigned char *pos;
X
X    if (file[0] == '\0')        /* assume stdin */
X      {
X          fd = 0;
X          strcpy(BUF->file,"(Standard Input)");
X      }
X    else
X      {
X          stat(file, &st);
X          if (st.st_mode & S_IFDIR)  /* S_IFDIR = 0040000 */
X            {
X#ifndef VMS
X                get_dir(file);
X#endif                
X                return(1);
X            }
X          size = st.st_size;
X#ifdef VMS          
X          /* VMS share options (shr=put) suggested by Henk D. Davids <hdavids@mswe.dnet.ms.philips.nl> */
X          /* VMS share options (shr=upi,get,put) suggested by Mark Pizzolato <mark@infocomm.com> */
X          fd = open(file,O_RDONLY,"ctx=rec","mbf=8","mbc=16","rop=RAH","shr=upi,get,put");
X#else
X          fd = open(file,O_RDONLY);
X#endif          
X      }
X    
X    
X    if (fd >= 0)
X      {
X          if (!fd) size = 16384;
X          BEG = BUF->beg = (unsigned char *) malloc(size);
X          n = 0;
X          pos = BUF->beg;
X          dsize = size;
X          while ((i = read(fd, (char *) pos, size - n)) > 0 )
X            {
X                n += i;
X                if ((fd == 0) && (size == n))
X                  {
X                      size += dsize;
X                      BEG = (unsigned char *) realloc(BEG,size * sizeof(char));
X                      pos = BEG + n;
X                  }
X                else pos += i;
X            }
X          BUF->end = pos;
X          BUF->beg = BEG;
X          close(fd);
X          return (1);
X      }
X    return(0);
X}
X
int find_file(char *file)
X{
X    Buffer *new_buf, *old_buf;
X    int a,n;
X    unsigned char *pos;
X    
X    
X    new_buf = create_buffer(file);
X    old_buf = switch_to_buffer(new_buf);
X    
X    if (insert_file(file) == 0)
X      {
X          message("File could not be opened.",1);
X          BUF->beg = (unsigned char *) "File could Not be opened.";
X          BUF->end = BUF->beg + strlen((char *) BUF->beg);
X      }
X    BEG = BUF->beg;
X    EOB = BUF->end;
X    if (!MOST_B_OPT && !MOST_K_OPT)
X      for (pos = BEG; (pos < (BEG + 32)) && (pos < EOB); pos++)
X      {
X          if ((*pos == 0) || (*pos > 127)) MOST_B_OPT = 1;
X      }
X    
X    n = count_lines(BEG,EOB);
X    
X    NUM_LINES = n;
X    C_POS = BEG;
X    C_LINE = 1;
X    COLUMN = 1;
X    return(1);
X}
X
X/* if the file is visible in a window, move to the window and return 1
X   else return 0 */
int file_visible(char *file)
X{
X    Window *w;
X    w = WIN;
X    WIN = TOP_WIN;
X    do
X      {
X          if (!strcmp(WIN->buf->file,file))
X            {
X                set_window(WIN);
X                return(1);
X            }
X          WIN = WIN->next;
X      }
X    while (WIN != TOP_WIN);
X    WIN = w;
X    return(0);
X}
X
X
void find_file_in_window(char *file)
X{
X    if (file_visible(file)) return;
X    
X    if (-1 == access(file,0))        /* does it exist? */
X      message("File not found.",1);
X    else if (-1 == access(file,4))   /* can we read it? */
X      message("File exists but not readable.",1);
X    else 
X      {
X          free_window_buffer();
X          (void) find_file(file);
X
X          window_buffer();
X          CURS_ROW = WIN->curs_line = 1;
X          CURS_POS = WIN->curs_pos = C_POS;
X          CURS_COL = WIN->curs_col = 1;
X
X          redraw_window();
X          update_status(0);
X      }
X}
X
X
X
int next_file(int *j)
X{
X    char mbuf[132], ch, *curr_file;
X    int i;
X    
X    mbuf[0] = '\0';
X    select_minibuffer();
X    delete_line(1);
X
X    for (i = 0; i < SCREEN_WIDTH; i++) MINI_BUF[i] = ' ';
X
X    if (*j >= NUM_FILES) *j = 0;
X    curr_file = FILE_RING[*j];
X    strcat(mbuf,"Next file: ");
X    strcat(mbuf, curr_file);
X    fputs(mbuf,stdout);
X    fputc('\r',stdout);
X    fflush(stdout);
X    while(ch = mbuf[i], ch != '\0') i++;
X    while(i < SCREEN_WIDTH) mbuf[i++] = ' ';
X    mbuf[i] = '\0';
X    strcpy((char *) MINI_BUF,mbuf);
X    while (1)
X      {
X          ch = getkey();
X          if (ch != '\033') break;
X          if (ch = getkey(), (ch != 'O') && (ch != '[')) continue;
X          if (ch = getkey(), (ch != 'A') && (ch != 'B')) continue;
X          
X          if (ch == 'B')
X            {
X                if (*j == 0) *j = NUM_FILES;
X                (*j)--;
X            }
X          else  /* ch == 'A' */
X            {
X                (*j)++;
X                if (*j == NUM_FILES) *j = 0;
X            }
X          curr_file = FILE_RING[*j];
X          mbuf[0] = '\0';
X          strcat(mbuf,"Next file: ");
X          strcat(mbuf, curr_file);
X          i = 0;
X          while(ch = mbuf[i], ch != '\0') i++;
X          while(i < SCREEN_WIDTH) mbuf[i++] = ' ';
X          mbuf[i] = '\0';
X          
X          smart_puts(mbuf,MINI_BUF,stdout);
X          fputc('\r',stdout);
X          strcpy((char *) MINI_BUF,mbuf);
X          fflush(stdout);
X      }
X    delete_line(1);
X    exit_minibuffer();
X    MINI_BUF[0] = 0;
X    (*j)++;
X    if ((ch == 'Q') || (ch == 'q')) return(-1);
X    
X    find_file_in_window(curr_file);
X    return(0);
X}
X
X/* extracts directory from file string, returns false if no dir */
int head(char *file, char *dir)
X{
X    int n;
X    (void) strcpy(dir,file);
X    n = strlen(file) - 1;
X#ifdef VMS    
X    while((n > -1) && (file[n] != ']') && (file[n] != ':')) n--;
X#else    
X    while((n > -1) && file[n] != '/') n--;
X#endif
X    n++;
X    dir[n] = '\0';
X    return(n);
X}
X
X/* returns a pointer to the tail of file */
int tail(char *filed, char **filep)
X{
X    int n;
X    n = strlen(filed) - 1;
X#ifdef VMS    
X    while((n > -1) && (filed[n] != ']') || (filed[n] != ':')) n--;
X#else    
X    while((n > -1) && filed[n] != '/') n--;
X#endif
X    n++;
X    *filep = (filed + n);
X    return(n);
X}
X
X/* assume path is big enough to hold new expanded version */
int expand_path(char *path)
X{
X    int n;
X    /* really cheat here-- let system do it.  The path must exist!! */
X    if (chdir(path))
X      {
X          message(path,1);
X          return(0);
X      }
X    else
X      {
X          get_cdir(path);
X          chdir(C_DIR);
X#ifndef VMS
X          n = strlen(path);
X          if (path[n-1] == '/') return(1);
X          path[n++] = '/'; path[n] = 0;
X#endif
X      }
X    return(1);
X}
X
X
X
void cd()
X{
X    char tmp_dir[80];
X    int n;
X    
X    strcpy(tmp_dir,C_DIR);
X    if (read_from_minibuffer("cd: ",C_DIR) == -1) return;
X    if (!chdir(C_DIR))
X      {
X          get_cdir(C_DIR);         /* expands ../ etc... */
X          n = strlen(C_DIR);
X#ifndef VMS
X          if (C_DIR[n-1] == '/') return;
X          C_DIR[n++] = '/'; C_DIR[n] = 0;
X#endif          
X          return;
X      }
X    strcpy(C_DIR,tmp_dir);
X    chdir(C_DIR);
X    message("Unable to change directory.",1);
X}
X
void user_get_file()
X{
X    char path[80], file[80], *name;
X    
X    if (!head(WIN->buf->file,file))
X      strcpy(file,C_DIR);
X
X    if (read_from_minibuffer("Find File: ",file) == -1) return;
X
X    if (head(file,path))
X      {
X          expand_path(path);
X          tail(file,&name);
X          strcat(path,name);
X          name = path;
X      }
X    else name = file;
X    find_file_in_window(name);
X}
X
END_OF_FILE
if test 7456 -ne `wc -c <'file.c'`; then
    echo shar: \"'file.c'\" unpacked with wrong size!
fi
# end of 'file.c'
fi
if test -f 'file.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'file.h'\"
else
echo shar: Extracting \"'file.h'\" \(177 characters\)
sed "s/^X//" >'file.h' <<'END_OF_FILE'
extern int insert_file(char *);
extern int find_file(char *);
extern void find_file_in_window(char *);
extern char *FILE_RING[500];
extern char C_DIR[80];
extern int NUM_FILES;
END_OF_FILE
if test 177 -ne `wc -c <'file.h'`; then
    echo shar: \"'file.h'\" unpacked with wrong size!
fi
# end of 'file.h'
fi
if test -f 'help.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help.c'\"
else
echo shar: Extracting \"'help.c'\" \(3219 characters\)
sed "s/^X//" >'help.c' <<'END_OF_FILE'
X#include <stdio.h>
X#ifdef VMS
X#include <stat.h>
X#else
X#include <sys/types.h>
X#include <sys/stat.h>
X#endif
X#include "window.h"
X#include "file.h"  
X#include "display.h"  
X#include "line.h"
X#include "most.h"  
X  
X#ifndef MOST_HELP_USE_DOC
X/* This section provided by Mats Akerberg (mats@efd.lth.se) */
X  
static char *help[] = {
X"SPACE,^D,D,d        *Scroll down one Screen.",
X"RETURN, DOWN        *Move forward one line.",
X"u,U,^U, DELETE      *Move Up one screen.",
X"UP                  *Move up one line.",
X"R, r, ^R             Redraw Screen.",
X"T,t                  Top of File.",
X"B,b                  Bottom of file.",
X"RIGHT                Scroll Screen Left (to view lines right of right margin)",
X"LEFT                 Scroll Screen Right (To view lines left of left margin)",
X"F,f,/               *Find forward",
X"?                   *Find Backward",
X"n,N                 *Find next in current search direction.",
X"J,j,g,G              Goto line.",
X"%                    Goto percent.",
X"q,Q                  Quit MOST.",
X":N,:n                Quit this file and view next.",
X" *Note:  This command may be repeated `n' times By entering a number then",
X"        the command key, e.g.,  '5 SPACE' moves 5 screens forward.",
NULL };
X
void do_help_command()
X{
X    int i,ct;
X    char *beg, *end;
X    char line[80];
X    char attr[80];
X    
X    i = 1;
X    ct = 0;
X    set_scroll_region(1,SCREEN_HEIGHT);
X    cls();
X    while( i<SCREEN_ROWS)
X      {
X          if( help[ct]!=NULL)
X            {
X                beg = help[ct];
X                end = (help[ct] + strlen(help[ct++]));
X                analyse_line((unsigned char *) beg, (unsigned char *) end, line, attr);
X                output(line,end - beg,attr,'$');
X                fputc('\n',stdout);
X                i++;
X            }
X          else
X            {
X		set_attribute(7);
X                fputs("Press any key to continue.",stdout);
X		set_attribute(0);
X                fflush(stdout);
X		getkey();
X                redraw_display();
X		return;
X            }
X          fflush(stdout);
X      }
X}
X
X#else
void do_help_command()
X{
X    int fd, n_lines,s_lines,v_opt,b_opt,t_opt, sd, a_lines, fsize, c_line;
X    char *helpfile ,*buf_name,f_name[80],s_str[80];
X    unsigned char *beg, *c_pos, *e_pos;
X    extern char *getenv(char *);
X
X    buf_name = "*help*";
X    helpfile = getenv("MOST_HELP");
X    if (helpfile == NULL)
X      {
X      static char tempname[L_tmpnam];
X      struct stat statb;
X
X	  head(MOST_PROGRAM, tempname);
X	  strcat(tempname, "most.doc");
X	  if (0 == stat(tempname, &statb))
X	    {
X	        helpfile = tempname;
X	    }
X      }
X    if (helpfile != NULL)
X      {
X          if (file_visible(buf_name)) return;
X          if (!split_window())
X            {
X                message("Two many windows.",1);
X                return;
X            }
X          update_status(1);  /* create status line of prev. window */
X          other_window(1);
X          (void) find_file(helpfile);
X          strcpy(BUF->file,buf_name);
X          window_buffer();
X          redraw_window();
X          update_status(1);
X      }
X    else
X      {
X          message("You must set the environment variable 'MOST_HELP' to point to the help file.",1);
X      }
X}       
X#endif
END_OF_FILE
if test 3219 -ne `wc -c <'help.c'`; then
    echo shar: \"'help.c'\" unpacked with wrong size!
fi
# end of 'help.c'
fi
if test -f 'keym.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'keym.h'\"
else
echo shar: Extracting \"'keym.h'\" \(1444 characters\)
sed "s/^X//" >'keym.h' <<'END_OF_FILE'
X  
extern void beep_cmd();
extern void ctrl_x_map_cmd();
extern void ctrl_k_map_cmd();
extern void ctrl_w_map_cmd();
extern void pf1_map_cmd();
extern void pf1_esc_map_cmd();
extern void dec_extended_map_cmd();
extern void esc_map_cmd();
extern void page_down_cmd();
extern void search_cmd();
extern void help_cmd();
extern void next_line_cmd();
extern void previous_line_cmd();
extern void extended_cmd_cmd();
extern void redraw_cmd();
extern void goto_line_cmd();
extern void time_cmd();
extern void page_up_cmd();
extern void page_left_cmd();
extern void page_right_cmd();
extern void sys_spawn_cmd();
extern void set_mark_cmd();
extern void top_of_buffer_cmd();
extern void goto_mark_cmd();
extern void extended_key_cmd();
extern void search_back_cmd();
extern void find_next_cmd();
extern void end_of_buffer_cmd();
extern void exit_cmd();
extern void one_window_cmd();
extern void two_window_cmd();
extern void del_window_cmd();
extern void other_window_cmd();
extern void O_map_cmd();
extern void find_file_cmd();
extern void digit_arg_cmd();
extern void edit_cmd();
extern void toggle_width_cmd();
extern void goto_percent_cmd();
extern void edt_page_cmd();
extern void edt_forward_cmd();
extern void edt_back_cmd();
extern void edt_line_cmd();
extern void edt_find_cmd();
extern void edt_find_next_cmd();
X
extern int *DIGIT_ARG;
X
X#ifdef VMS
X#ifndef isdigit
X#define isdigit(x) \
X      (((x >= '0') && (x <= '9')) ? 1 : 0)
X#endif
X#endif
X
END_OF_FILE
if test 1444 -ne `wc -c <'keym.h'`; then
    echo shar: \"'keym.h'\" unpacked with wrong size!
fi
# end of 'keym.h'
fi
if test -f 'line.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'line.c'\"
else
echo shar: Extracting \"'line.c'\" \(10420 characters\)
sed "s/^X//" >'line.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "buffer.h"
X#include "externs.h"
X#include "display.h"
X#include "line.h"
X  
extern int COLUMN;
X
X#define MAX_LINE_LEN 500
int MOST_S_OPT = 0;
X/* take 16 binary characters and put them in displayable form */
int ascii_format_line(char *buff, char *str)
X{
X    int i,ii,j,k,ch,di,flag;
X    char num_str[4];
X
X    ii = 0;
X    di = 40;
X    flag = 1;
X
X    for (i = 35;i<=di;i++) str[i] = ' ';  /* a gap */
X    
X    for (j = 0; j < 4; j++)
X      {
X          
X          for (k = 0; k < 4; k++)
X            {
X                i = 4 * j + k;
X                ch = buff[i];
X                if (MOST_V_OPT)
X                  {
X                      if (((ch < 32) && (ch >= 0)) || (ch == 127))
X                        {
X                            str[ii++] = '^';
X                            if (ch == 127)
X                              str[ii++] = '?';
X                            else
X                              str[ii++] = ch + 'A' - 1;
X                            str[i + di] = '.';
X                        }
X                      else if (ch < 0)
X                        {
X                            ch = ch + 256; 
X                            sprintf(num_str,"%02X", ch);
X                            str[ii++] = num_str[0];
X                            str[ii++] = num_str[1];
X                            str[i + di] = '.';
X                        }
X                      else
X                        {
X                            str[ii++] = ' ';
X                            str[ii++] = ch;
X                            str[i + di] = ch;
X                        }
X                  }
X                else
X                  {
X                      if (ch < 32)
X                        {
X                            if (ch < 0) ch = ch + 256;
X                            str[i + di] = '.';
X                        }
X                      else str[i+di] = ch;
X                      
X                      sprintf(num_str,"%02X", ch);
X                      str[ii++] = num_str[0];
X                      str[ii++] = num_str[1];
X                  }
X                
X            } /* k */
X          str[ii++] = ' ';
X      }
X    di += 16;
X    str[di] = '\0';
X    return(di);
X}
X    
X
int analyse_line(unsigned char *beg, unsigned char *end, char *out, char *attributes)
X{
X    int test, ii, fold, ii_max, j, ok;
X    unsigned char ch,attr;
X
X    test = 0;
X    ii = 0;
X    ii_max = 0;
X    fold = 0;
X    while(ch = *beg, (beg <= end) && (ch != '\n') && (ch != '\0'))
X      {
X          beg++;
X          if (ii > ii_max) fold = 0;  /* beyond previous high */
X          attr = ' ';
X          if (!MOST_V_OPT && ch == '\015')                   /* ^M */
X            {
X                if (beg <= end)
X                  {
X                      fold = 1;
X                      if (ii > ii_max) ii_max = ii - 1; /* ^M contributes nil */
X                      ii = 0;
X                  }
X            }
X          else if (!MOST_V_OPT && ch == '\b')
X            {
X                test = 1;
X                ii--;
X            }
X          else if (test || fold)
X            {
X                test = 0;
X                if (ch == out[ii])
X                  attr = 'b';
X                else if (out[ii] == '_')
X                  attr = 'u';
X
X                if (fold && ch == ' ')
X                  ii++;
X                else
X                  {
X                      attributes[ii] = attr;
X                      out[ii++] = ch;
X                  }
X                
X            }
X          else if (!MOST_T_OPT && ch == '\t')
X            {
X                j = 8 * (ii/8 + 1) - ii;  /* 8 column tabs */
X                while(j--)
X                  {
X                      out[ii] = ' ';
X                      attributes[ii++] = attr;
X                  }
X            }
X          else
X            {
X                out[ii] = ch;
X                attributes[ii++] = attr;
X            }
X      }
X    if (fold) ii = ii_max + 1;
X    if ((beg > end) && MOST_S_OPT && !MOST_W_OPT)
X      {
X          ok = 1;
X          if (*beg == '\n') beg++;
X          while ((*beg <= ' ') && ok)
X            {
X                if (*beg != '\n') beg++;
X                if (beg >= EOB) break;
X                if ((*beg == '\n') || (apparant_distance(beg) >= MOST_S_OPT))
X                  {
X                      ok = 0;
X                  }
X            }
X          if (!ok)
X            {
X                ok = 3;
X                while(ok--)
X                  {
X                      out[ii] = '.'; 
X                      attributes[ii++] = ' ';
X                  }
X            }
X          
X      } /* MOST_S_OPT */
X    out[ii] = '\0';
X    return(ii);
X}
X
X
void output(char *line, int len, char *attr, char d_char)
X{
X    int
X      i,ii,k, bold,b_len,n_len, s_len, u_len, work_len, j, mark, ok, quit,
X      count, max_col, save, dollar;
X    char ch, at, out[500], *n_str, *b_str, *s_str, *u_str, work[20];
X
X    b_str = "\033[1m"; n_str = "\033[0m"; s_str = "\033[%dC"; u_str = "\033[4m";
X    b_len = strlen(b_str);
X    n_len = strlen(n_str);
X    u_len = strlen(u_str);
X    s_len = strlen(s_str);
X    i = 0;
X    ii = 0;
X    bold = 0;
X    quit = 0;
X    ok = 0;  /* 1 if ok to start filling the out line */
X    max_col = COLUMN + SCREEN_WIDTH - 1;
X    count = 0;
X    dollar = 0;
X    while (ch = line[i], (i <= len) && ch != '\0' && ch != '\n' && !quit)
X      {
X          count++;
X          if (MOST_V_OPT && ((ch < ' ') || (ch > 126))) count++;
X          
X          if (count >= COLUMN) ok = 1;
X          if (count > max_col) break;
X          
X          if (!MOST_V_OPT)
X            {
X                at = attr[i];
X                if ((at != ' ') && !bold)
X                  {
X                      bold = 1;
X                      /* u and b have same length */
X                      if (ok) for (j = 0; j < b_len; j++)
X                        {
X                            if (at == 'b') out[ii++] = b_str[j];
X                            else out[ii++] = u_str[j];
X                        }
X                      
X                  }
X                else if ((at == ' ') && bold)
X                  {
X                      bold = 0;
X                      if (ok) for (j = 0; j < n_len; j++) out[ii++] = n_str[j];
X                  }
X            }
X          
X          if (ch == ' ')
X            {
X                j = 0;
X                mark = ii;
X                /* we always make this loop once */
X                while ((i <= len) && (line[i++] == ' '))
X                  {
X                      j++;
X                      if (ok) out[ii++] = ' ';
X                  }
X                if (i > len) quit = 1;
X                i = i - 2;
X                save = count;
X                count += j - 1;  /* counted one at top of while */
X
X                if (!ok)
X                  {
X                      if (count >= COLUMN)
X                        {
X                            ok = 1;
X                            j = count - COLUMN + 1;
X                            k = j;
X                            while (k--) out[ii++] = ' ';
X                        }
X                  }
X                
X                if (count >= max_col)
X                  {
X                      quit = 1;
X                      j = max_col - save;
X                  }
X                
X                if (ok && (j > s_len)) 
X                  {
X                      ii = mark;
X                      sprintf(work,s_str,j);
X                      work_len = strlen(work);
X                      for (j = 0; j < work_len; j++) out[ii++] = work[j];
X                      if (count >= max_col) dollar = ii++;
X                  }
X                else if (count >= max_col)
X                  {
X                      dollar = mark + j;
X                  }
X                
X            }
X          else if (ok && ((ch == '\014') || ((ch < ' ') && MOST_V_OPT)))
X            {
X                out[ii++] = '^';
X                out[ii++] = ch + 'A' - 1;
X            }
X          else if (ok) 
X            {
X                out[ii++] = ch;
X            }
X          
X          i++;
X      }
X    if (dollar) out[ii = dollar, ii++] = d_char;
X    else if (ok && count >= max_col) out[ii - 1] = d_char;
X    out[ii] = '\0';
X    if (ii) fputs(out,stdout);
X    
X    if (ok && bold) fputs(n_str,stdout);
X}
X
X
void display_line()
X{
X    unsigned char *beg, *end;
X    int i, len, v, t;
X    char buff[16];
X    char the_line[MAX_LINE_LEN],  *p, the_attr[MAX_LINE_LEN], *line,*attr, ch;
X    line = the_line;
X    attr = the_attr;
X    /* This needs fixed for files with really big lines */
X    if (!MOST_B_OPT)
X      {
X          if(extract_line(&beg, &end) && MOST_W_OPT) ch = '\\'; else ch = '$';
X          
X          len = end - beg + 1;
X          if (len > MAX_LINE_LEN)
X            {
X                v = MOST_V_OPT;
X                t = MOST_T_OPT;
X                MOST_V_OPT = 1;
X                MOST_T_OPT = 1;
X                line = (char *) beg;
X            }
X          else len = analyse_line(beg, end, line, attr);
X      }
X    else
X      {
X          ch = '$';
X          i = 0;
X          beg = C_POS;
X          end = C_POS + 16;
X          if (end > EOB) end = EOB;
X          while(beg < end) buff[i++] = (char) *beg++;
X          while(i < 15) buff[i++] = 0;
X          len = ascii_format_line(buff,the_line);
X          i = 0; while(i<80) attr[i++] = ' ';
X      }
X    
X    
X    output(line,len,attr, ch);
X    if (len > MAX_LINE_LEN)
X      {
X          MOST_V_OPT = v;
X          MOST_T_OPT = t;
X      }
X}
X
X
X/* given a position in a line, return apparant distance from bol
X   expanding tabs, etc... up to pos */
int apparant_distance(unsigned char *pos)
X{
X    int i;
X    unsigned char *cur_pos, *save_pos, ch;
X    cur_pos = C_POS;
X    save_pos = pos;
X    C_POS = pos;
X    pos = beg_of_line();
X    C_POS = cur_pos;
X
X    i = 1;
X    while(ch = *pos, pos++ < save_pos)
X      {
X          if (!MOST_V_OPT && ch == '\b')
X            {
X                if (i > 1) i--;
X            }
X          else if (!MOST_V_OPT && ch == '\015') /* ^M */
X            {
X                if (i != 1) i = 1;
X            }
X          else if (!MOST_T_OPT && ch == '\t')
X            {
X                i = 8 * ((i - 1)/8 + 1) + 1;  /* 8 column tabs */
X            }
X          else if (ch < ' ' || ch > 126)
X            {
X                if (ch == '\012' || MOST_V_OPT)  /* ^L */
X                  {
X                      i += 2;
X                  }             /* otherwise they have no width */
X            }
X          else i++;
X      }
X    return (i);
X}
X
X
X
END_OF_FILE
if test 10420 -ne `wc -c <'line.c'`; then
    echo shar: \"'line.c'\" unpacked with wrong size!
fi
# end of 'line.c'
fi
if test -f 'line.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'line.h'\"
else
echo shar: Extracting \"'line.h'\" \(337 characters\)
sed "s/^X//" >'line.h' <<'END_OF_FILE'
X#ifndef _DAVIS_LINE_H_
X#define _DAVIS_LINE_H_
extern int ascii_format_line(char *, char *);
extern void expand_tabs(char *, char *);
extern int analyse_line(unsigned char *, unsigned char *, char *, char *);
extern void output(char *, int, char *, char);
extern void display_line();
extern int apparant_distance(unsigned char *);
X#endif
END_OF_FILE
if test 337 -ne `wc -c <'line.h'`; then
    echo shar: \"'line.h'\" unpacked with wrong size!
fi
# end of 'line.h'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
echo shar: Extracting \"'main.c'\" \(10070 characters\)
sed "s/^X//" >'main.c' <<'END_OF_FILE'
X#define __MOST_VERSION__ "3.2"
X#define __MOST_USAGE__ "most [-bstvw] [+line] [+/string] [+[C][D]] filename"
X/*
X               Most ---- a more/less paging type program.
X
X    Copyright (C) 1991 by John E. Davis. (davis@pacific.ms.ohio-state.edu)
X
X                   The following disclaimer from GNU emacs.
X
X                                 NO WARRANTY
X
X  BECAUSE THIS PROGRAM IS LICENSED FREE OF CHARGE, WE PROVIDE ABSOLUTELY NO
WARRANTY, TO THE EXTENT PERMITTED BY APPLICABLE STATE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING, JOHN E. DAVIS AND/OR OTHER PARTIES PROVIDE THIS
PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
XFITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND
PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE,
YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
X
X IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW WILL JOHN E. DAVIS, AND/OR ANY
OTHER PARTY WHO MAY MODIFY AND REDISTRIBUTE THIS PROGRAM AS PERMITTED BELOW,
BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY LOST PROFITS, LOST MONIES, OR
OTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
INABILITY TO USE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD PARTIES OR A FAILURE OF THE
PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS) THIS PROGRAM, EVEN IF YOU HAVE
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY OTHER
PARTY.
X
X                        GENERAL PUBLIC LICENSE TO COPY
X
X  1. You may copy and distribute verbatim copies of this source file as you
receive it, in any medium, provided that you conspicuously and appropriately
publish on each copy a valid copyright notice "Copyright (C) 1990 John E.
Davis"; and include following the copyright notice a verbatim copy of the
above disclaimer of warranty and of this License.  You may charge a
distribution fee for the physical act of transferring a copy.
X
X  2. You may modify your copy or copies of this source file or
any portion of it, and copy and distribute such modifications under
the terms of Paragraph 1 above, provided that you also do the following:
X
X    a) cause the modified files to carry prominent notices stating
X    that you changed the files and the date of any change; and
X
X    b) cause the whole of any work that you distribute or publish,
X    that in whole or in part contains or is a derivative of this
X    program or any part thereof, to be licensed at no charge to all
X    third parties on terms identical to those contained in this
X    License Agreement (except that you may choose to grant more extensive
X    warranty protection to some or all third parties, at your option).
X
X    c) You may charge a distribution fee for the physical act of
X    transferring a copy, and you may at your option offer warranty
X    protection in exchange for a fee.
X
Mere aggregation of another unrelated program with this program (or its
derivative) on a volume of a storage or distribution medium does not bring
the other program under the scope of these terms.
X
X  3. You may copy and distribute this program (or a portion or derivative
of it, under Paragraph 2) in object code or executable form under the terms
of Paragraphs 1 and 2 above provided that you also do one of the following:
X
X    a) accompany it with the complete corresponding machine-readable
X    source code, which must be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    b) accompany it with a written offer, valid for at least three
X    years, to give any third party free (except for a nominal
X    shipping charge) a complete machine-readable copy of the
X    corresponding source code, to be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    c) accompany it with the information you received as to where the
X    corresponding source code may be obtained.  (This alternative is
X    allowed only for noncommercial distribution and only if you
X    received the program in object code or executable form alone.)
X
XFor an executable file, complete source code means all the source code for
all modules it contains; but, as a special exception, it need not include
source code for modules which are standard libraries that accompany the
operating system on which the executable file runs.
X
X  4. You may not copy, sublicense, distribute or transfer this program
except as expressly provided under this License Agreement.  Any attempt
otherwise to copy, sublicense, distribute or transfer this program is void and
your rights to use the program under this License agreement shall be
automatically terminated.  However, parties who have received computer
software programs from you with this License Agreement will not have
their licenses terminated so long as such parties remain in full compliance.
X
In other words, you are welcome to use, share and improve this program.
You are forbidden to forbid anyone else to use, share and improve
what you give them.   Help stamp out software-hoarding!  */
X
char *MOST_VERSION = __MOST_VERSION__ ;
X#include <stdio.h>
X#include "externs.h"
X#include "window.h"
X#include "buffer.h"
X#include "file.h"
X#include "sysdep.h"
X#include "most.h"
X
int MOST_K_OPT = 0;    /* Display 8 bit unformatted (Kanji) */
int  CASE_SENSITIVE, STARTING_LINE;
char SEARCH_STR[80];
char *MOST_PROGRAM;	/* Program Name (argv[0]) */
X
X#ifdef VMS
X#ifndef isalpha
X#define isalpha(x) \
X      (((x >= 'A') && (x <= 'Z'))||((x >= 'a') && (x <= 'z')) ? 1 : 0)
X#endif
X#endif
X
void do_extended_switches(char *str)
X{
X    int i;
X    char ch,numstr[7];
X    
X    i = 0;
X    ch = *(++str);
X    if ( ch == '/')
X      {
X          strcpy(SEARCH_STR,++str);
X      }
X    else if (ch >= '0' && ch <= '9')
X      {
X          while (ch >= '0' && ch <= '9')
X            {
X                numstr[i++] = ch;
X                ch = *(++str);
X            }
X          numstr[i] = '\0';
X          (void) sscanf(numstr,"%d",&STARTING_LINE);
X      }
X    else if (isalpha(ch))
X      {
X          while (isalpha(ch))
X            {
X                if ((ch == 'C') || (ch == 'c'))
X                  CASE_SENSITIVE = 1;
X                else if ((ch == 'D') || (ch == 'd'))
X                  MOST_D_OPT = 1;   /* delete file mode */
X                ch = *(++str);
X            }
X      }
X    
X    else
X      {
X          fprintf(stdout,"switch '+%s' not valid.\n",str);
X          exit(0);
X      }
X}
X
X
X
void do_switches(char *str)
X{
X
X    while (*str != '\0')
X      {
X          switch (*str++)
X            {
X              case 'a':
X              case 'A':
X                MOST_A_OPT = 1; break;  /* check to see if file is binary */
X              case 's':
X              case 'S':
X                SQUEEZE_LINES = 1; break;
X              case 'c':
X              case 'C':
X                MOST_C_OPT = 1; break;
X              case 'V':
X              case 'v':
X                MOST_V_OPT = 1;  /* verbose-- convert control chars to '^' 'ch' */
X                break;
X              case 'W':
X              case 'w':  MOST_W_OPT = 1; break;
X              case 'K':
X              case 'k':  MOST_K_OPT = 1; break;
X              case 'B':
X              case 'b':
X                MOST_B_OPT = 1;  /* Binary display 8 bit */
X                break;
X              case 't':
X              case 'T': /* expand tabs to '^I'; meaningful only with 'v' */
X                MOST_T_OPT = 1;
X                break;
X              case 'L':
X              case 'l':
X                MOST_L_OPT = 1;  /* use ^L to clear screen */
X                break;
X            }
X      }
X}
X   
int main(int argc, char *argv[])
X{
X    char file[80],ch, *switches,outstr[180], *curr_file,filename[80];
X    int file_i, quit,i,piped,a_opt, j;
X    unsigned long context;
X    extern char *getenv(char *);
X    extern int isatty(int);
X    extern void sysinit(void);
X
X    MOST_PROGRAM = argv[0];
X    piped = 0;
X    switches = getenv("MOST_SWITCHES");
X    if (switches !=  NULL)  do_switches(switches);
X          
X    i = 1;
X    if (argc > 1)
X      {
X          quit = 0;
X          while ((!quit) && (i < argc))
X            {
X                if (argv[i][0] == '-')
X                  do_switches(argv[i++]);
X                else if (argv[i][0] == '+')
X                  do_extended_switches(argv[i++]);
X                else quit = 1;
X            }
X      }
X
X    
X    if (i == argc)
X      {
X          if (isatty(0))   /* 1 if stdin is a terminal, 0 otherwise */
X            {
X                fprintf(stderr,"MOST(%s) Usage: %s\n",MOST_VERSION,__MOST_USAGE__);
X                        exit(0);
X            }
X          /* assume input is from stdin */
X          file[0] = '\0';  /* tells most this is stdin */
X          piped = 1;
X          MOST_A_OPT = 0;  /* in this version since we cannot do an fseek */
X      }
X    else
X      strcpy(file,argv[i]);
X
X    NUM_FILES = 0;
X    context = 0;
X
X    get_terminfo();           /* set up esc sequences etc... */
X    init_tty(); 
X    if (MOST_B_OPT) MOST_A_OPT = 0;   /* explicit b overrides a */
X    a_opt = MOST_A_OPT;
X
X    if (!piped)
X      {
X          file_i = i;
X#ifdef VMS
X          while(i < argc)
X            {
X                if (argv[i][0] == '.') strcpy(file,"*"); else *file = 0;
X                strcat(file,unix2vms(argv[i++]));
X                while (expand_file_name(file,filename))
X                  {
X                      FILE_RING[NUM_FILES] = (char*) malloc(strlen(filename) + 1);
X                      strcpy(FILE_RING[NUM_FILES++], filename);
X                  }
X            }
X          if (NUM_FILES) strcpy(file,FILE_RING[0]);
X    
X#else
X          j = 0;
X          NUM_FILES = argc - i;
X          while (i < argc)
X            {
X                FILE_RING[j++] = argv[i++];
X            }
X#endif
X      }
X
X    if (NUM_FILES) quit = 0; else quit = 1;
X    if (!quit || piped) most(file,STARTING_LINE);
X    if (quit) fprintf(stderr,"File %s not found\n", argv[file_i]);
X
X    reset_tty();
X    reset_display();
X#ifndef  VMS
X    fputc('\n',stdout);
X#endif    
X    exit(0);
X    return (0);
X}
END_OF_FILE
if test 10070 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
fi
# end of 'main.c'
fi
if test -f 'make.com' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'make.com'\"
else
echo shar: Extracting \"'make.com'\" \(1346 characters\)
sed "s/^X//" >'make.com' <<'END_OF_FILE'
X$ files = ""
X$ files = files + ",main.c" - ".c"
X$ files = files + ",buffer.c" - ".c"
X$ files = files + ",file.c" - ".c"
X$ files = files + ",window.c" - ".c"
X$ files = files + ",line.c" - ".c"
X$ files = files + ",display.c" - ".c"
X$ files = files + ",sysdep.c" - ".c"
X$ files = files + ",keym.c" - ".c"
X$ files = files + ",most.c" - ".c"
X$ files = files + ",search.c" - ".c"
X$ files = files + ",help.c" - ".c"
X$ files = files + ",dir.c" - ".c"
X$ files = files + ",cmd.c" - ".c"
X$ files = files + ",edit.c" - ".c"
X$ files = files - ","
X$!
X$! if you do not want the doc file used as help, but want a short one page
X$! help summary then comment out the following line:
X$ cc := cc/define=MOST_HELP_USE_DOC
X$!
X$  if (p1 .eqs. "LINK") then goto do_link
X$  write sys$output "Compiling..."
X$  cc 'files'
X$  do_link:
X$  write sys$output "Linking..."
X$  link/exec = most  'files',sys$input/opt
SYS$LIBRARY:VAXCRTL/SHARE
X$  write sys$output "Setting up MOST...
X$  curr_dir = f$environment("DEFAULT")
X$  most = "$" + curr_dir + "most.exe"
X$  most :== 'most'
X$  most_h = curr_dir + "most.doc"
X$  define MOST_HELP 'most_h'
X$  type := type
X$  type sys$input
X         
X        MOST is now setup for this login session.  
X        
X        Type 'most filename' to view the file 'filename'.
X        In particular, type 'most most.doc' to read the doc file.
X
X$  exit
END_OF_FILE
if test 1346 -ne `wc -c <'make.com'`; then
    echo shar: \"'make.com'\" unpacked with wrong size!
fi
# end of 'make.com'
fi
if test -f 'makecom.com' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makecom.com'\"
else
echo shar: Extracting \"'makecom.com'\" \(812 characters\)
sed "s/^X//" >'makecom.com' <<'END_OF_FILE'
X$!
X$! if you do not want the doc file used as help, but want a short one page
X$! help summary then comment out the following line:
X$ cc := cc/define=MOST_HELP_USE_DOC
X$!
X$  if (p1 .eqs. "LINK") then goto do_link
X$  write sys$output "Compiling..."
X$  cc 'files'
X$  do_link:
X$  write sys$output "Linking..."
X$  link/exec = most  'files',sys$input/opt
SYS$LIBRARY:VAXCRTL/SHARE
X$  write sys$output "Setting up MOST...
X$  curr_dir = f$environment("DEFAULT")
X$  most = "$" + curr_dir + "most.exe"
X$  most :== 'most'
X$  most_h = curr_dir + "most.doc"
X$  define MOST_HELP 'most_h'
X$  type := type
X$  type sys$input
X         
X        MOST is now setup for this login session.  
X        
X        Type 'most filename' to view the file 'filename'.
X        In particular, type 'most most.doc' to read the doc file.
X
X$  exit
END_OF_FILE
if test 812 -ne `wc -c <'makecom.com'`; then
    echo shar: \"'makecom.com'\" unpacked with wrong size!
fi
# end of 'makecom.com'
fi
if test -f 'makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile'\"
else
echo shar: Extracting \"'makefile'\" \(1227 characters\)
sed "s/^X//" >'makefile' <<'END_OF_FILE'
X# if you do not want the foc file used as help, but want a short one page
X# help summary then comment out the following line:
HELP = -DMOST_HELP_USE_DOC
X# and uncomment the next line:
X#  HELP =
X
CFILES = main.c buffer.c file.c window.c line.c display.c \
X          sysdep.c keym.c most.c search.c help.c dir.c cmd.c edit.c
OBJS = main.o buffer.o file.o window.o line.o display.o \
X          sysdep.o keym.o most.o search.o help.o dir.o cmd.o edit.o
HFILES = buffer.h file.h window.h line.h display.h \
X          sysdep.h keym.h most.h search.h externs.h
MISC  = most.1 most.doc make.com aaa_read.me rtl.opt changes.txt makefile\
X          makecom.com
X
CC = cc 
CFLAGS = -g $(HELP)
XEXEC = m
X
X$(EXEC): $(OBJS)
X	$(CC) $(CFLAGS) $(OBJS) -o $(EXEC)
X
unix:
X	shar -b $(CFILES) $(HFILES) $(MISC) > most.shar
X
most.doc:	most.1
X		nroff -man $? > $@
X
vms:
X	(echo  "\$$ files = \"\"" ) > make.com
X	for file in $(CFILES); do\
X	       (echo  "\$$ files = files + \",$$file\" - \".c\"")\
X                 >> make.com; \
X	done
X	(echo  "\$$ files = files - \",\"" ) >> make.com
X	(cat makecom.com) >> make.com
X	pack $(CFILES) $(HFILES) $(MISC) -o most.com
X
lpr:
X	for file in $(CFILES) $(HFILES); do\
X		pprint north $$file -l c -p; \
X	done
X
X
X
X
X
X
END_OF_FILE
if test 1227 -ne `wc -c <'makefile'`; then
    echo shar: \"'makefile'\" unpacked with wrong size!
fi
# end of 'makefile'
fi
if test -f 'most.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'most.c'\"
else
echo shar: Extracting \"'most.c'\" \(1478 characters\)
sed "s/^X//" >'most.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "externs.h"
X#include "window.h"
X#include "buffer.h"
X#include "file.h"
X#include "sysdep.h"
X#include "keym.h"
X#include "most.h"
X#include "search.h"  
X
int SQUEEZE_LINES = 0;          /* switch parameters */
int MOST_A_OPT = 0;             /* automatically choose -b if necessary */
int MOST_C_OPT = 0;             /* begin pages at top of screen */
int MOST_V_OPT = 0;             /* display control chars */
int MOST_B_OPT = 0;             /* display Binary File */
int MOST_T_OPT = 0;             /* display tab as ^I-- valid only with V option */
int MOST_D_OPT = 0;             /* delete file mode  (see ':D')  */
int MOST_L_OPT = 0;             /* use ^L (formfeed) to clear screen */
X
void most(char *file, int start)
X{
X    char input_s[20],ch,outstr[80], *strp;
X    int line, update, quit, j, repeat, mark, piped, next, row, col, r;
X    
X    init_display();
X    get_cdir(C_DIR);
X
X    row = col = 0;
X    if (file[0] == '\0') piped = 1; else piped = 0;
X    
X    find_file(file);
X    goto_line(start);
X    CURS_POS = C_POS;
X    if (*SEARCH_STR != '\0' && (row = search(C_POS,1,&col), row > 0))
X      {
X          goto_line(row);
X      }
X    else
X      {
X          row = C_LINE;
X          col = 1;
X      }
X    
X    window_buffer();
X    CURS_ROW = WIN->curs_line = row - C_LINE + 1;
X    WIN->curs_pos = CURS_POS;
X    CURS_COL = WIN->curs_col = col;
X    redraw_window();
X    update_status(1);
X
X    while (1)
X      {
X          execute_key();
X      } 
X}
END_OF_FILE
if test 1478 -ne `wc -c <'most.c'`; then
    echo shar: \"'most.c'\" unpacked with wrong size!
fi
# end of 'most.c'
fi
if test -f 'most.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'most.h'\"
else
echo shar: Extracting \"'most.h'\" \(655 characters\)
sed "s/^X//" >'most.h' <<'END_OF_FILE'
extern int SQUEEZE_LINES;          /* switch parameters */
extern int MOST_A_OPT;             /* automatically choose -b if necessary */
extern int MOST_C_OPT;             /* begin pages at top of screen */
extern int MOST_V_OPT;             /* display control chars */
extern int MOST_B_OPT;             /* display Binary File */
extern int MOST_T_OPT;             /* display tab as ^I-- valid only with V option */
extern int MOST_D_OPT;             /* delete file mode  (see ':D')  */
extern int MOST_L_OPT;             /* use ^L (formfeed) to clear screen */
X
extern char *MOST_PROGRAM;	   /* Program Name (argv[0]) */
extern void most( char *, int);
END_OF_FILE
if test 655 -ne `wc -c <'most.h'`; then
    echo shar: \"'most.h'\" unpacked with wrong size!
fi
# end of 'most.h'
fi
if test -f 'rtl.opt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rtl.opt'\"
else
echo shar: Extracting \"'rtl.opt'\" \(26 characters\)
sed "s/^X//" >'rtl.opt' <<'END_OF_FILE'
SYS$LIBRARY:VAXCRTL/SHARE
END_OF_FILE
if test 26 -ne `wc -c <'rtl.opt'`; then
    echo shar: \"'rtl.opt'\" unpacked with wrong size!
fi
# end of 'rtl.opt'
fi
if test -f 'search.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'search.c'\"
else
echo shar: Extracting \"'search.c'\" \(5318 characters\)
sed "s/^X//" >'search.c' <<'END_OF_FILE'
X#include "most.h"
X#include "externs.h"
X#include "buffer.h"
X#include "line.h"
X
int CASE_SENSITIVE = 0;
char SEARCH_STR[80];
int SEARCH_DIR = 1;
X
X#define upcase(ch) ((!CASE_SENSITIVE && (ch <= 'z') && (ch >= 'a')) ? ch &= 0xDF : ch)
X
X/* This routine returns the 1 + position of first match of key in str.
X   key is modified to match the case of str. */
X/* We should try to optimize this routine */
X/* searches from beg up to but not including end */
unsigned char *forw_search_region(unsigned char *beg,unsigned char *end, unsigned char *key)
X{
X    char ch, ch2,char1,work[80];
X    unsigned char *pos;
X    int key_len,j, str_len;
X
X    if (CASE_SENSITIVE)
X      {
X          strcpy(work,key);
X          key_len = strlen(key);
X      }
X    else
X      {
X          /* upcase key */
X          key_len = 0;
X          while (ch = key[key_len],ch != '\0')
X            {
X                ch = upcase(ch);
X                work[key_len++] = ch;        /* null char is ok */
X            }
X      }
X    
X    str_len = (int) (end - beg);
X    if (str_len < key_len) return (EOB);
X    str_len = str_len - key_len; /* effective length */
X    end -= key_len;
X          
X    char1 = work[0];
X    
X    while(1)
X      {
X          while (ch = *beg, ch = upcase(ch), ch != char1)
X            {
X                if (beg > end) return(EOB);
X                beg++;
X            }
X          beg++;
X          /* so we have a position of possible match */
X
X          j = 1;
X          pos = beg;  /* save this position so we start from here again */
X          while(ch = *beg++, ch = upcase(ch),
X                ch2 = work[j++], (ch == ch2) && (j <= key_len));
X
X          if (j > key_len)
X            {
X                /* make key match 'key' in beg */
X                beg = pos - 1;  /* skip back to beginning of match */
X                for (j = 0; j < key_len; j++) key[j] = *beg++;
X                return(pos - 1);
X            }
X          
X          else beg = pos;
X      }
X}
X
X
unsigned char *back_search_region(unsigned char *beg,unsigned char *end, unsigned char *key)
X{
X    char ch, ch2,char1,work[80];
X    unsigned char *pos;
X    int key_len,j, str_len;
X
X    if (CASE_SENSITIVE)
X      {
X          strcpy(work,key);
X          key_len = strlen(key);
X      }
X    else
X      {
X          /* upcase key */
X          key_len = 0;
X          while (ch = key[key_len],ch != '\0')
X            {
X                ch = upcase(ch);
X                work[key_len++] = ch;        /* null char is ok */
X            }
X      }
X    
X    str_len = (int) (end - beg);
X    if (str_len < key_len) return (EOB);
X    str_len = str_len - key_len; /* effective length */
X    beg += key_len;
X          
X    char1 = work[key_len - 1];
X    
X    while(1)
X      {
X          while (ch = *end, ch = upcase(ch), ch != char1)
X            {
X                if (beg > end) return(EOB);
X                end--;
X            }
X          end--;
X          /* so we have a position of possible match */
X
X          j = key_len - 2;
X          pos = end;  /* save this position so we start from here again */
X          while(ch = *end--, ch = upcase(ch),
X                ch2 = work[j], (ch == ch2) && (j >= 0)) j--;
X
X          if (j < 0)
X            {
X                /* make key match 'key' in beg */
X                end = pos +  1;  /* skip back to beginning of match */
X                for (j = key_len; j > 0; j--) key[j - 1] = *end--;
X                return(end + 1);
X            }
X          
X          else end = pos;
X      }
X}
X
X
X
int search(unsigned char *from, int repeat, int *col)
X{
X    /* return the line match was found as well as line number,
X       search from i on; assume that line_array match the i so we need
X       no initial lookup */
X
X    int test,j,save_line, the_col, row;
X    char ch, string[80];
X    unsigned char *pos, *save_pos, *found_at;
X
X    if ((from < BEG) || (from > EOB)) return(-1);
X    save_pos = C_POS;
X    save_line = C_LINE;
X    found_at = EOB;
X    *col = 0;
X
X    pos = from;
X    if (SEARCH_STR[0] != '\0')
X      {
X          test = repeat && (pos < EOB) && (pos >= BEG);
X          while(test)
X            {
X                if (SEARCH_DIR == 1)
X                  pos = forw_search_region(pos,EOB,(unsigned char*) SEARCH_STR);
X                else
X                  pos = back_search_region(BEG,pos,(unsigned char*) SEARCH_STR);
X                
X                
X                if (pos < EOB)
X                  {
X                      repeat--;
X                      found_at = pos;
X                      if (SEARCH_DIR == 1)
X                        pos += strlen(SEARCH_STR);
X                      else pos--;
X                  }
X                test = repeat && (pos < EOB) && (pos >= BEG);
X            }
X      }
X    
X    if (repeat) /* not found */
X      {
X          *col = 0;
X          if (SEARCH_STR[0] == '\0')
X            message("Search string not specified.",1);
X          else
X            {
X                (void) sprintf(string,"%s NOT FOUND.",SEARCH_STR);
X                message(string,1);
X            }
X          
X          row = -1;
X      }
X    else /* if ( !MOST_T_OPT && !MOST_B_OPT) */   /* expand tabs to get col correct */
X      {
X          find_row_column(found_at,&row,&the_col);
X          *col = apparant_distance(found_at);
X      }
X    C_POS = save_pos;
X    C_LINE = save_line;
X    if (row > 0) CURS_POS = found_at;
X    return( row );
X}
END_OF_FILE
if test 5318 -ne `wc -c <'search.c'`; then
    echo shar: \"'search.c'\" unpacked with wrong size!
fi
# end of 'search.c'
fi
if test -f 'search.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'search.h'\"
else
echo shar: Extracting \"'search.h'\" \(208 characters\)
sed "s/^X//" >'search.h' <<'END_OF_FILE'
X#ifndef _DAVIS_SEARCH_H_
X#define _DAVIS_SEARCH_H_
X#include <stdio.h>
X#include <string.h>
X
extern int SEARCH_DIR;
X
extern int search(unsigned char *, int, int *);
extern int substring(char *, char *);
X#endif
X
END_OF_FILE
if test 208 -ne `wc -c <'search.h'`; then
    echo shar: \"'search.h'\" unpacked with wrong size!
fi
# end of 'search.h'
fi
if test -f 'sysdep.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sysdep.h'\"
else
echo shar: Extracting \"'sysdep.h'\" \(1876 characters\)
sed "s/^X//" >'sysdep.h' <<'END_OF_FILE'
X#ifndef __DAVIS_SYSDEP_H__
X#define __DAVIS_SYSDEP_H__
X
X#include <stdio.h>
X  
X#ifdef VMS
X#include <ssdef.h>
X#include <rmsdef.h>
X#include <dvidef.h>
X#include <jpidef.h>
X#include <libdef.h>
X#include <descrip.h>
X#include <iodef.h>
X#include <ttdef.h>
X#include <unixlib.h>
X#else
extern char *getenv( char *);
extern int read (int,  char *, int);
extern int unlink( char *);
extern int sleep(unsigned);
X#endif  
X  
X#ifdef VMS
extern unsigned long SHELL_PID;  
X
extern int do_shell_command();
extern int expand_file_name(char *,char *);
extern char *unix2vms(char *);
X
X#endif /* VMS */
X
X#ifdef VMS
typedef struct {                /* I/O status block     */
X        short i_cond;           /* Condition value      */
X        short i_xfer;           /* Transfer count     */
X        long  i_info;           /* Device information     */
X} iosb;
X 
typedef struct {                /* Terminal characteristics   */
X        char  t_class;          /* Terminal class     */
X        char  t_type;           /* Terminal type      */
X        short t_width;          /* Terminal width in characters   */
X        long  t_mandl;          /* Terminal's mode and length   */
X        long  t_extend;         /* Extended terminal characteristics  */
X}  termchar;                    
X
short TTY_CHANNEL_GLOBAL;
X
X#else
X#define TTY_DESCR 2
extern int ioctl(int, int, ...);
X
X#ifdef BSD
X#include <sgtty.h>
X     struct ltchars  OLDTTY_LC;
X     struct tchars   OLDTTY_TC;
X     struct sgttyb   OLDTTY;
X#else
X#include <sys/termio.h>
X     struct termio OLDTTY;
X#endif
X#endif /* VMS */
X
extern int INPUT_BUFFER_LEN;
extern char INPUT_BUFFER[80];
X
extern void init_tty();
extern void reset_tty();
extern char getkey();
extern void ungetkey(char);
extern void sys_resume();
extern void get_term_dimensions(int *, int *);
extern int sys_delete_file(char *);
X
extern char *get_time();
X#endif /* __DAVIS_SYSDEP_H__ */
END_OF_FILE
if test 1876 -ne `wc -c <'sysdep.h'`; then
    echo shar: \"'sysdep.h'\" unpacked with wrong size!
fi
# end of 'sysdep.h'
fi
if test -f 'window.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'window.h'\"
else
echo shar: Extracting \"'window.h'\" \(1726 characters\)
sed "s/^X//" >'window.h' <<'END_OF_FILE'
X#ifndef _DAVIS_WINDOW_H_
X#define _DAVIS_WINDOW_H_
X#include "buffer.h"
X
struct Window_Type
X  {
X      unsigned char *beg_pos;   /* buffer pos of top line */
X      int beg_line;             /* line number of top */
X      int curs_line;            /* line number of curs pos */
X      int curs_col;             /* column number of curs pos */
X      unsigned char *curs_pos;  /* pos of curs pos */
X      int col;                  /* column offset */
X      int n_lines;              /* number of lines of buffer (mode dependent) */
X      int top;                  /* screen location of top */
X      int bot;                  /* screen location of bot */
X      int display;              /* value of MOST_S_OPT for selective display */
X      char *status;             /* status line */
X      Buffer *buf;              /* buffer structure in window */
X      struct Window_Type *next; /* next window */
X      struct Window_Type *prev; /* prev window */
X      int flags;                /* Squeeze lines, etc.. */
X      int lock;                 /* true if locked */
X  };
typedef struct Window_Type Window;
X
extern Window *WIN;
extern Window *TOP_WIN;
extern int COLUMN;
extern int CURS_ROW;
extern int CURS_COL;
extern unsigned char *CURS_POS;
extern int RESTORE_WIDTH_TO;
extern void update_window(int); /* moves window to have arg lines on the top */
extern void update_status();
extern void redraw_window();    /* redraws window updating the structure */
extern void clear_window();
extern void window_buffer();
extern void init_display();
extern void reset_display();
extern void other_window(int);
extern void toggle_lock();
extern void set_window(Window *);
X
extern void message(char *, int);
extern void clear_minibuffer();
X#endif
END_OF_FILE
if test 1726 -ne `wc -c <'window.h'`; then
    echo shar: \"'window.h'\" unpacked with wrong size!
fi
# end of 'window.h'
fi
echo shar: End of archive 1 \(of 2\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
