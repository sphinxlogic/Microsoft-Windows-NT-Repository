Newsgroups: comp.sources.unix
From: screen@uni-erlangen.de (Juergen & Michael)
Subject: v27i014: screen-3.5.1 - full-screen window manager/multiplexor, Part01/10
Message-id: <1.744844979.5722@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: screen@uni-erlangen.de (Juergen & Michael)
Posting-Number: Volume 27, Issue 14
Archive-Name: screen-3.5.1/part01

            ---------------------------------
             Screen version 3.5 patchlevel 1
            ---------------------------------

Screen is a full-screen window manager that multiplexes a physical
terminal between several processes (typically interactive shells).


Why you should update from 3.5.0 to 3.5.1:

- a nasty bug in the margin handling code was fixed.

- Screen won't set the SHELL variable to the executed program anymore.

- IRIX V5.x patches by Paul Close.

- Should work on OSF1 and sony platforms... If not, disable
  MIPS and flame us...

- Supports now the --srcdir configure option.

- Fixed a bug in the writelock code (only for multiuser mode).

- configure.in is now compatible to autoconf1.5.

- A new mechanism was added to prevent redeclarations of the
  os functions. If you have problems with that, try an empty
  osdef.h file.

- New things in screen:
  + The user struct now contains some useful things (last window,
    copybuffer) which will therefore survive detach/reatach.

  + The paste function can now have one argument. Look in the
    .iscreenrc file for an example.

  + A wall function for multiuser mode was added.

A note to Ultrix users. If you have problems, try to toggle
the #define POSIX in config.h (and send us mail).

And here is something for MicroVax II with Ultrix-32 v3.1. If
you cannot reattach to a screen session, try to define
NOREUID in config.h. Can somebody send me an explanation of what
is wrong with the setreuid call on a Microvax?

Thanks to all people who provided us with lots of patches.

Thats all for now. Have fun,
  Juergen & Michael (screen@uni-erlangen.de)

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 10)."
# Contents:  .iscreenrc INSTALL MANIFEST NEWS README acl.h ansi.h
#   comm.c comm.h.dist comm.sh display.h doc doc/Makefile.in
#   etcscreenrc input.c loadav.c mark.h misc.c newsyntax osdef.h.in
#   osdef.sh overlay.h pty.c putenv.c rcs.h screen.h term.c
#   term.h.dist term.sh terminfo terminfo/8bits terminfo/README
#   terminfo/checktc.c terminfo/screen-sco.mail terminfo/screencap
#   terminfo/screeninfo.src terminfo/tetris.c window.h
# Wrapped by vixie@gw.home.vix.com on Sun Aug  8 14:18:53 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f '.iscreenrc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'.iscreenrc'\"
else
echo shar: Extracting \"'.iscreenrc'\" \(2083 characters\)
sed "s/^X//" >'.iscreenrc' <<'END_OF_FILE'
X#password ODSJQf.4IJN7E    # "1234"
X
Xvbell on
Xautodetach on
Xstartup_message off
X
X# Extend the vt100 desciption with some sequences.
Xtermcap  vt100* ms:AL=\E[%dL:DL=\E[%dM:UP=\E[%dA:DO=\E[%dB:LE=\E[%dD:RI=\E[%dC
Xterminfo vt100* ms:AL=\E[%p1%dL:DL=\E[%p1%dM:UP=\E[%p1%dA:DO=\E[%p1%dB:LE=\E[%p1%dD:RI=\E[%p1%dC
X
X#xterm understands both im/ic and doesn't have a status line.
X#Note: Do not specify im and ic in the real termcap/info file as
X#some programs (e.g. vi) will not work anymore.
Xtermcap  xterm hs@:cs=\E[%i%d;%dr:im=\E[4h:ei=\E[4l
Xterminfo xterm hs@:cs=\E[%i%p1%d;%p2%dr:im=\E[4h:ei=\E[4l
X
X#80/132 column switching must be enabled for Z0/Z1 to work
Xtermcap  xterm Z0=\E[?3h:Z1=\E[?3l
Xterminfo xterm Z0=\E[?3h:Z1=\E[?3l
X
X#xterms is xterm with status line in title bar
Xtermcap  xterms 'hs:ts=\E]0;:fs=\007:ds=\E]0;iScreen\007:cs=\E[%i%d;%dr:LP:G0:im=\E[4h:ei=\E[4l'
Xterminfo xterms 'hs:ts=\E]0;:fs=\007:ds=\E]0;iScreen\007:cs=\E[%i%p1%d;%p2%dr:LP:G0:im=\E[4h:ei=\E[4l'
X
X#make hp700 termcap/info better
Xtermcap  hp700 'Z0=\E[?3h:Z1=\E[?3l:hs:ts=\E[62"p\E[0$~\E[2$~\E[1$}:fs=\E[0}\E[61"p:ds=\E[62"p\E[1$~\E[61"p:ic@'
Xterminfo hp700 'Z0=\E[?3h:Z1=\E[?3l:hs:ts=\E[62"p\E[0$~\E[2$~\E[1$}:fs=\E[0}\E[61"p:ds=\E[62"p\E[1$~\E[61"p:ic@'
X
X#wyse-75-42 must have flow control (xo = "terminal uses xon/xoff")
X#essential to have it here, as this is a slow terminal.
Xtermcap wy75-42 xo
Xterminfo wy75-42 xo
X
X# New termcap sequences for cursor application mode.
Xtermcap wy* CS=\E[?1h:CE=\E[?1l
Xterminfo wy* CS=\E[?1h:CE=\E[?1l
X
X# Make the output buffer large for (fast) xterms.
Xtermcap xterm* OL=10000
Xterminfo xterm* OL=10000
X
X#remove some stupid / dangerous key bindings
Xbind k
Xbind ^k
Xbind .
Xbind ^\
Xbind \\
Xbind ^h
Xbind h
X#make them better
Xbind '\\' quit
Xbind 'K' kill
Xbind 'I' login on
Xbind 'O' login off
Xbind '}' history
X
Xpow_detach_msg "Screen session of \$LOGNAME \$:cr:\$:nl:ended."
X
X# Yet another hack:
X# Prepend/append register [/] to the paste if ^a^] is pressed.
X# This lets me have autoindent mode in vi.
Xregister [ "\033:se noai\015a"
Xregister ] "\033:se ai\015a"
Xbind ^] paste [.]
END_OF_FILE
if test 2083 -ne `wc -c <'.iscreenrc'`; then
    echo shar: \"'.iscreenrc'\" unpacked with wrong size!
fi
# end of '.iscreenrc'
fi
if test -f 'INSTALL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'INSTALL'\"
else
echo shar: Extracting \"'INSTALL'\" \(2080 characters\)
sed "s/^X//" >'INSTALL' <<'END_OF_FILE'
XInstallation of screen3.3
X
X0.)
XUnpack. Screen comes as a compressed tar archive. You need gzip to uncompress.
XBut... you probably already managed that step, when you are reading this.
X
X1.)
XRun configure. This should create a Makefile and a config.h file
Xsuited for your machine. Rename config.status to reflect the architecture 
X(hostname) where it was built. To reconfigure quickly for that architecture
Xjust run that config.status file.
XIf this process fails, try to find out what configure did do and what it
Xshould have checked. Mail me.
X
X2.)
XLook through the Makefile & user configuration section in config.h and check the
Xpathnames. Change them to suit your installation requirements.
X
X3.)
XYou may well run screen from your private binary directory and with a 
Xprivate socket directory like $HOME/.screen. But to have a full featured
Xscreen and (from a users point of view) more secure pty's you should
Xconsult a system administrator and discuss installing screen setuid-root
Xin some globally accessible directory like /usr/local/bin.
X
XConsider this, when deciding whether you install screen setuid-root:
X- On some machines root priviliges are required to open pty's. 
X- Pty's should be owned by the user, so that she can do chmod to prevent
X  intrudor attacks.
X- The ^At feature may need to lseek and read the kernel file to retrieve 
X  the load average.
X- On most machines utmp slots can only be created/manipulated with root
X  privileges. 
X
X4.)
XThe man page screen.1 should go to /usr/local/man/man1, or some similar
Xdirectory. It should format nicely with nroff -man. If it does not, then
Xtry removing extra dots with: sed -e 's/^\.\././' < screen.1 | nroff -man 
XLook through the etcscreenrc file for system wide defaults that you like to 
Xset. e.g. autodetach off, startup_message off, ... 
XInstall it to match the pathname specified in config.h
X
X5.)
XSince version 3.2.15 the screenrc file syntax changed slightly. All rc files
Xfrom previous versions should be run through the newsyntax script that comes 
Xwith this package.
X
XJuergen Weigert. (screen@uni-erlangen.de)
END_OF_FILE
if test 2080 -ne `wc -c <'INSTALL'`; then
    echo shar: \"'INSTALL'\" unpacked with wrong size!
fi
# end of 'INSTALL'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(2222 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X .iscreenrc                 1	
X COPYING                    3	
X ChangeLog                  2	
X INSTALL                    1	
X MANIFEST                   1	This shipping list
X Makefile.in                2	
X NEWS                       1	
X README                     1	
X acl.c                      2	
X acl.h                      1	
X ansi.c                     5	
X ansi.h                     1	
X attacher.c                 3	
X comm.c                     1	
X comm.h.dist                1	
X comm.sh                    1	
X config.h.in                2	
X configure                  6	
X configure.in               3	
X display.c                  4	
X display.h                  1	
X doc                        1	
X doc/Makefile.in            1	
X doc/fdpat.ps               8	
X doc/screen.1               9	
X doc/screen.texinfo        10	
X etcscreenrc                1	
X extern.h                   2	
X fileio.c                   3	
X help.c                     2	
X input.c                    1	
X loadav.c                   1	
X mark.c                     4	
X mark.h                     1	
X misc.c                     1	
X newsyntax                  1	
X os.h                       2	
X osdef.h.in                 1	
X osdef.sh                   1	
X overlay.h                  1	
X patchlevel.h               2	
X process.c                  7	
X pty.c                      1	
X putenv.c                   1	
X rcs.h                      1	
X resize.c                   2	
X screen.c                   6	
X screen.h                   1	
X search.c                   2	
X socket.c                   4	
X term.c                     1	
X term.h.dist                1	
X term.sh                    1	
X termcap.c                  2	
X terminfo                   1	
X terminfo/8bits             1	
X terminfo/README            1	
X terminfo/checktc.c         1	
X terminfo/screen-sco.mail   1	
X terminfo/screencap         1	
X terminfo/screeninfo.src    1	
X terminfo/test.txt          5	
X terminfo/tetris.c          1	
X tty.c.dist                 4	
X tty.sh                     3	
X utmp.c                     3	
X window.c                   4	
X window.h                   1	
END_OF_FILE
if test 2222 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'NEWS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'NEWS'\"
else
echo shar: Extracting \"'NEWS'\" \(4444 characters\)
sed "s/^X//" >'NEWS' <<'END_OF_FILE'
X
X                  ----------------------------
X                   What's new in screen-3.5 ?
X                  ----------------------------
X
X
X* Texinfo manpage! Thanks to Jason Merrill.
X
X* Screen now has a very large 'configure' script. If you have
X  problems with the resulting configuration please send mail to
X  screen@uni-erlangen.de.
X
X* Stackable overlay planes.
X  All commands are available even if you work with an overlay. Thus
X  you can be in copy/paste mode on several windows!
X
X* Unification of key bindings and screen commands. All keys now generate
X  commands.
X
X* Screen now reads/writes only in asyncronous mode.
X
X* Ansi parser speedup code resulting in much faster output of text.
X
X* Changed the rc file syntax. Commands now directly affect the current
X  window. The default settings are changed with 'def...' commands.
X  The 'set' keyword no longer exists.
X  Please run the 'newsyntax' script on your old screenrc files!
X
X* Emacs style isearch added to copy mode. Try ^A ESC ^R screen ^R ^R
X  to locate the last three occurences of the word 'screen' in the
X  history buffer.
X
X* New command 'silence'. Alarms the user whenever there was inactivity
X  for a specified amount of time on a certain window.
X  Useful if you want to wait for a compilation to end.
X
X* Much better margin handling:
X  Screen now handles autowrapped lines correctly in the redisplay and
X  copy/paste functions.
X
X* New commands for pastebuffer management:
X  'copy_reg' copies the pastebuffer to a register,
X  'ins_reg' pastes a register,
X  'register' fills a register with a string,
X  'process' stuffs a register into strings input queue.
X
X* Autonuke feature. Flush the output buffer if the window gets
X  cleared. Enable this with 'autonuke on'.
X
X* Modifications to save memory: Empty attribute and font lines don't
X  get allocated. This is very useful if you have a lage scrollback.
X
X* Multi display support:
X  You can now attach from more than one terminal to a session with
X  the '-x' option.
X
X* New option '-S' to specify socket name.
X
X* Experimental multiuser support added:
X  You can start screen in multiuser Mode by prepending the socket
X  name with a '/' (or by the command 'multiuser on').
X  If another user wants to attach to the screen session, he can do
X  this by prepending the socketname with 'screenuser/'.
X  Of course he must be in the access control list for a successful
X  attach (see the acladd/acldel command).
X  
X* Extension to the 'screen' command: You can now specify tty lines
X  instead of programs. This can be used for console management.
X  Added the command 'break' to send a break to the tty line.
X  Not really a new feature, but terminal initialisation  now works
X  on suns.
X
X* Input/output filters added. This has been implemented to allow the
X  user to configure an open tty line, but got soon exended to allow
X  all sorts of filters. For more information read the explanation
X  of the 'exec' command in the man page and check the 'fdpat.ps'
X  document.
X
X* Screen can now be started detached (screen -d -m -S sockname).
X  This is usefull if you want to start screen in your /etc/rc file
X  (e.g. as a console multiplexer)
X
X* Console grabbing added ('console on' command). 
X
X* Windows can now be selected by akas, too. (Per default bound to the
X  >'< key.)
X
X* New terminal capabiliteise CS/CE for cursorkey control.
X
X* setenv/unsetenv commands added.
X
X* Expansion of environment variables ($VAR) and terminal capabilities
X  ($:TC:) in the screenrc files and detach messages.
X  Example: pow_detach_msg "Session of \$LOGNAME \$:cr:\$:nl:ended."
X   
X* New commands:
X  'hardcopydir' and 'logdir' to change the output directories,
X  'partial' and 'allpartial' to make screen only refresh the line
X  containing the cursor if a window is selected (useful for slow
X  modem connections).
X
X* Cleanup of the provided termcap/terminfo file. Please install
X  the new one!
X
X* The program 'terminfo/checktc.c' does a visual check of a
X  termcap/terminfo entry. Please try it before calling screen and
X  in a screen session.
X
X* LOTS of bugfixes and code cleanup.
X
XThanks to all the beta testers who helped porting screen to at least
Xthe following platforms: Ultrix, SunOS, Solaris, BSD43, linux, NEWSOS,
XIrix, OSF/1, Harris CX/UX, hpux, dynix/ptx, AIX.
XAnd even more thanks to the brave who attempted to use the 'exec'
Xcommand features.
X
X    Donnate patches, bugreports, suggestions, money, beer & pizza to
X            screen@uni-erlangen.de
X
END_OF_FILE
if test 4444 -ne `wc -c <'NEWS'`; then
    echo shar: \"'NEWS'\" unpacked with wrong size!
fi
# end of 'NEWS'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(3230 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X
XShort introduction to screen                                  jw 7.9.91
X
X [note that this intro only describes the most common screen features]
XSend bugreports, fixes, enhancements, t-shirts, money, beer & pizza to 
X                          screen@uni-erlangen.de
X
X
Xscreen 
X  provides you with an ansi/vt100 terminal emulator, which can multiplex
X  up to 10 pseudo-terminals. On startup, it executes $SHELL in window 0.
X  Then it reads $HOME/.screenrc to learn configuration, keybindings, 
X  and may open more windows.
X
X  C-A C		Create new windows.
X
X  C-A SPACE	Advance from window to window (with wraparound)
X
X  C-A C-A	Toggle between two windows.
X
X  C-A 0
X   ...
X  C-A 9		Switch to window nr. 0 ... 9.
X
X  C-A w		Show a list of windows in the Statusline.
X
X  C-A a		(Think of goto-start-of-line in emacs or tcsh).
X  C-A s		(Think of i-search in emacs).
X  C-A q		Send a literal C-A/C-S/C-Q to the process in the window.
X
X  C-A l		Redraw this window.
X
X  C-A W		Toggle between 80 & 132 columns mode. 
X
X  C-A L		Try to toggle the utmp-slot for this window.
X
X  C-A A		Prompt for a new name for this window. (see C-A w).
X
X  C-A z		Suspend the whole screen.
X
X  C-A x		Execute /usr/bin/lock or $LOCKCMD or a builtin terminallock.
X
X  C-A C-[	Start copy&paste mode. Move cursor with h,j,k,l. Set 2 marks
X		with SPACE or y. Abort with ESC. Note that "C-[" is ESC.
X		NOTE: there is a userdefined amount of scrollback history.
X                The history buffer is entered, when the cursor hits the top
X		of the window.
X
X  C-A C-]	paste in current window's stdin. see C-A C-[.
X
X  C-A <
X  C-A >		Read or write the copybuffer from/to the exchange file.
X		Multiple screen users on the same host may thus transfer text.
X
X  C-A d		Detach screen. All processes continue and may spool output
X		to their pty's, but screen disconnects from your terminal.
X		reattach with "screen -r".
X
X  C-A D D	Power detach. Disconnect like C-A d and kill the parent shell.
X
X  C-A K		Kill a window and send SIGHUP to its processgroup. Per default
X		this would be C-A C-k. But it is redefined in the demo .screenrc
X		(think of killing a whole line in emacs).
X
X  C-A :set all  Show all keybindings. The above list is not at all complete and
X		may even be wrong, as keys can be redefined in .screenrc or
X		with "C-A :bind 'X' keyname [arguments]".
X
X  C-A : ....  Online configuration change.
X
X
Xscreen -r [host.tty]
X  Reattach a detached screen session. The terminal emulator reconfigures
X  according to your $TERMCAP or $TERM settings. '-R' brings up a detached
X  session or (if none) creates a new session. You should specify a socket
X  when there you have multiple screens detached. 
X
Xscreen -d [host.tty]
X  Detach a screen session from remote. Has the same effect as typing 'C-A d'
X  on the controlling terminal. '-D' will power-detach.
X
Xscreen -list
Xscreen -ls
X  Show all available sockets. If there are (DEAD???) sockets, you may consider 
X  removing them. If there are sockets missing, you may send a SIGCHLD to its
X  process 'SCREEN' and the process will re-establish the socket. (think of 
X  someone cleaning /tmp thoroughly).
X
Xscreen -h 200
X  Starts a new screen session and sets the number of lines in the scrollback
X  buffer to 200. The default is 50 lines.
END_OF_FILE
if test 3230 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'acl.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'acl.h'\"
else
echo shar: Extracting \"'acl.h'\" \(2514 characters\)
sed "s/^X//" >'acl.h' <<'END_OF_FILE'
X/* Copyright (c) 1993
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X ****************************************************************
X * RCS_ID("$Id: acl.h,v 1.7 1993/07/30 01:24:06 jnweiger Exp $ FAU")
X */
X
X#ifdef MULTIUSER
X
X/* three known bits: */
X#define ACL_EXEC 0		
X#define ACL_WRITE 1
X#define ACL_READ 2
X
X#define ACL_BITS_PER_CMD 1	/* for comm.h */
X#define ACL_BITS_PER_WIN 3	/* for window.h */
X
X#define USER_CHUNK 8
X
X#define ACLBYTE(data, w)   ((data)[(w) >> 3])
X#define ACLBIT(w)   (0x80 >> ((w) & 7))
X
Xtypedef unsigned char * AclBits;
X
X/* a bitfield for windows and one for commands */
Xtypedef struct
X{
X  char name[20 + 1];
X  AclBits wins, cmds;
X} AclGroup;
X
X/* 
X * An AclGroupList is a chaind list of pointers to AclGroups.
X * Each user has such a list to reference groups he is in.
X * The aclgrouproot anchors all AclGroups. Delete and create
X * groups there.
X */
Xtypedef struct grouplist
X{
X  AclGroup *group;
X  struct grouplist *next;
X} AclGroupList;
X
X#endif
X
X/***************
X *  ==> user.h
X */
X
X/*
X * A User has a list of groups, and points to other users.  
X * users is the User entry of the session owner (creator)
X * and anchors all other users. Add/Delete users there.
X */
Xtypedef struct user
X{
X  struct user *u_next;
X  char u_name[20+1];		/* login name how he showed up */
X  char u_password[20+1];	/* his password (may be zero length). */
X  int  u_detachwin;		/* the window where he last detached */
X  char u_Esc, u_MetaEsc;	/* the users screen escape character */
X#ifdef COPY_PASTE
X  char  *u_copybuffer;
X  int   u_copylen;
X#endif
X#ifdef MULTIUSER
X  int id;			/* a uniq index in the bitfields. */
X#endif
X} User;
X
Xextern char DefaultEsc, DefaultMetaEsc;
X
END_OF_FILE
if test 2514 -ne `wc -c <'acl.h'`; then
    echo shar: \"'acl.h'\" unpacked with wrong size!
fi
# end of 'acl.h'
fi
if test -f 'ansi.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ansi.h'\"
else
echo shar: Extracting \"'ansi.h'\" \(2506 characters\)
sed "s/^X//" >'ansi.h' <<'END_OF_FILE'
X/* Copyright (c) 1993
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X ****************************************************************
X * $Id: ansi.h,v 1.3 1993/07/30 01:24:14 jnweiger Exp $ FAU
X */
X
X#define NATTR		6
X
X#define ATTR_DI		0	/* Dim mode */
X#define ATTR_US		1	/* Underscore mode */
X#define ATTR_BD		2	/* Bold mode */
X#define ATTR_RV		3	/* Reverse mode */
X#define ATTR_SO		4	/* Standout mode */
X#define ATTR_BL		5	/* Blinking */
X
X#define A_DI	(1<<ATTR_DI)
X#define A_US	(1<<ATTR_US)
X#define A_BD	(1<<ATTR_BD)
X#define A_RV	(1<<ATTR_RV)
X#define A_SO	(1<<ATTR_SO)
X#define A_BL	(1<<ATTR_BL)
X#define A_MAX	(1<<(NATTR-1))
X
X/*
X *  Parser state
X */
Xenum state_t 
X{
X  LIT,				/* Literal input */
X  ESC,				/* Start of escape sequence */
X  ASTR,				/* Start of control string */
X  STRESC,			/* ESC seen in control string */
X  CSI,				/* Reading arguments in "CSI Pn ;...*/
X  PRIN,				/* Printer mode */
X  PRINESC,			/* ESC seen in printer mode */
X  PRINCSI,			/* CSI seen in printer mode */
X  PRIN4				/* CSI 4 seen in printer mode */
X};
X
Xenum string_t 
X{
X  NONE,
X  DCS,				/* Device control string */
X  OSC,				/* Operating system command */
X  APC,				/* Application program command */
X  PM,				/* Privacy message */
X  AKA,				/* title for current screen */
X  GM				/* Global message to every display */
X};
X
X/*
X *  Types of movement used by GotoPos()
X */
Xenum move_t {
X	M_NONE,
X	M_UP,
X	M_CUP,
X	M_DO,
X	M_CDO,
X	M_LE,
X	M_CLE,
X	M_RI,
X	M_CRI,
X	M_RW,
X	M_CR	/* CR and rewrite */
X};
X
X#define EXPENSIVE	 1000
X
X#define G0			 0
X#define G1			 1
X#define G2			 2
X#define G3			 3
X
X#define ASCII		 0
X
X#ifdef TOPSTAT
X#define STATLINE	 (0)
X#else
X#define STATLINE	 (d_height-1)
X#endif
X
END_OF_FILE
if test 2506 -ne `wc -c <'ansi.h'`; then
    echo shar: \"'ansi.h'\" unpacked with wrong size!
fi
# end of 'ansi.h'
fi
if test -f 'comm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'comm.c'\"
else
echo shar: Extracting \"'comm.c'\" \(5784 characters\)
sed "s/^X//" >'comm.c' <<'END_OF_FILE'
X/* Copyright (c) 1993
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X ****************************************************************
X */
X
X#include "rcs.h"
XRCS_ID("$Id: comm.c,v 1.8 1993/08/05 14:23:32 mlschroe Exp $ FAU")
X
X#include "config.h"
X#include "acl.h"
X#include "comm.h"
X
X/* Must be in alpha order ! */
X
Xstruct comm comms[RC_LAST + 1] =
X{
X#ifdef MULTIUSER
X  { "acladd",		ARGS_ONE },
X  { "aclchg",		ARGS_THREE },
X  { "acldel",		ARGS_ONE },
X  { "aclgrp",		ARGS_ONE },
X#endif
X  { "activity",		ARGS_ONE },
X  { "aka",		NEED_FORE|ARGS_ZEROONE },	/* TO BE REMOVED */
X  { "allpartial",	ARGS_ONE },
X  { "at",		ARGS_TWO|ARGS_ORMORE },
X  { "autodetach",	ARGS_ONE },
X#ifdef AUTO_NUKE
X  { "autonuke",		NEED_DISPLAY|ARGS_ONE },
X#endif
X  { "bell",		ARGS_ONE },
X  { "bind",		ARGS_ONE|ARGS_ORMORE },
X  { "break",		NEED_FORE|ARGS_ZEROONE },
X#ifdef COPY_PASTE
X  { "bufferfile",	ARGS_ZEROONE },
X#endif
X  { "chdir",		ARGS_ZEROONE },
X  { "clear",		NEED_FORE|ARGS_ZERO },
X#ifdef MULTI
X  { "clone",		NEED_DISPLAY|ARGS_ONE|ARGS_ORMORE },
X#endif
X  { "colon",		NEED_DISPLAY|ARGS_ZERO },
X  { "console",		NEED_FORE|ARGS_ZEROONE },
X#ifdef COPY_PASTE
X  { "copy",		NEED_FORE|ARGS_ZERO },
X  { "copy_reg",		ARGS_ZEROONE },
X  { "crlf",		ARGS_ONE },
X#endif
X  { "debug",		ARGS_ZEROONE },
X#ifdef AUTO_NUKE
X  { "defautonuke",	ARGS_ONE },
X#endif
X  { "defflow",		ARGS_ONETWO },
X#if defined(UTMPOK) && defined(LOGOUTOK)
X  { "deflogin",		ARGS_ONE },
X#endif
X  { "defmode",		ARGS_ONE },
X  { "defmonitor",	ARGS_ONE },
X  { "defobuflimit",	ARGS_ONE },
X#ifdef COPY_PASTE
X  { "defscrollback",	ARGS_ONE },
X#endif
X  { "defwrap",		ARGS_ONE },
X  { "detach",		NEED_DISPLAY|ARGS_ZERO },
X  { "displays",		NEED_DISPLAY|ARGS_ZERO },
X  { "dumptermcap",	ARGS_ZERO },
X  { "duplicate",	ARGS_ZERO|ARGS_ORMORE },
X  { "echo",		ARGS_ONETWO },
X  { "escape",		ARGS_ONE },
X#ifdef PSEUDOS
X  { "exec", 		NEED_FORE|ARGS_ZERO|ARGS_ORMORE },
X#endif
X  { "flow",		NEED_FORE|ARGS_ZEROONE },
X  { "hardcopy",		NEED_FORE|ARGS_ZERO },
X  { "hardcopy_append",	ARGS_ONE },
X  { "hardcopydir",	ARGS_ONE },
X  { "hardstatus",	ARGS_ZEROONE },
X  { "height",		NEED_DISPLAY|ARGS_ZEROONE },
X  { "help",		NEED_DISPLAY|ARGS_ZERO },
X#ifdef COPY_PASTE
X  { "history",		NEED_FORE|ARGS_ZERO },
X#endif
X  { "info",		NEED_DISPLAY|ARGS_ZERO },
X#ifdef COPY_PASTE
X  { "ins_reg",		NEED_DISPLAY|ARGS_ZEROONE },
X#endif
X  { "kill",		NEED_FORE|ARGS_ZERO },
X  { "lastmsg",		NEED_DISPLAY|ARGS_ZERO },
X  { "license",		NEED_DISPLAY|ARGS_ZERO },
X#ifdef LOCK
X  { "lockscreen",	NEED_DISPLAY|ARGS_ZERO },
X#endif
X  { "log",		ARGS_ZEROONE },
X  { "logdir",		ARGS_ONE },
X#if defined(UTMPOK) && defined(LOGOUTOK)
X  { "login",		NEED_FORE|ARGS_ZEROONE },
X#endif
X#ifdef COPY_PASTE
X  { "markkeys",		ARGS_ONE },
X#endif
X  { "meta",		NEED_DISPLAY|ARGS_ZERO },
X  { "monitor",		NEED_FORE|ARGS_ZEROONE },
X  { "msgminwait",	ARGS_ONE },
X  { "msgwait",		ARGS_ONE },
X#ifdef MULTIUSER
X  { "multiuser",	ARGS_ONE },
X#endif
X#ifdef NETHACK
X  { "nethack",		ARGS_ONE },
X#endif
X  { "next",		ARGS_ZERO },
X  { "number",		NEED_FORE|ARGS_ZEROONE },
X  { "obuflimit",	NEED_DISPLAY|ARGS_ZEROONE },
X  { "other",		NEED_DISPLAY|ARGS_ZERO },
X  { "partial",		NEED_FORE|ARGS_ZEROONE },
X#ifdef PASSWORD
X  { "password",		ARGS_ZEROONE },
X#endif
X#ifdef COPY_PASTE
X  { "paste",		NEED_DISPLAY|ARGS_ZEROONE },
X#endif
X  { "pow_break",	NEED_FORE|ARGS_ZEROONE },
X#ifdef POW_DETACH
X  { "pow_detach",	NEED_DISPLAY|ARGS_ZERO },
X  { "pow_detach_msg",	ARGS_ONE },
X#endif
X  { "prev",		ARGS_ZERO },
X  { "process",		NEED_DISPLAY|ARGS_ZEROONE },
X  { "quit",		ARGS_ZERO },
X#ifdef COPY_PASTE
X  { "readbuf",		NEED_DISPLAY|ARGS_ZERO },
X#endif
X  { "redisplay",	ARGS_ZERO },
X  { "register",		ARGS_TWO },
X#ifdef COPY_PASTE
X  { "removebuf",	ARGS_ZERO },
X#endif
X  { "reset",		NEED_FORE|ARGS_ZERO },
X  { "screen",		ARGS_ZERO|ARGS_ORMORE },
X#ifdef COPY_PASTE
X  { "scrollback",	NEED_FORE|ARGS_ONE },
X#endif
X  { "select",		ARGS_ZEROONE },
X  { "sessionname",	ARGS_ZEROONE },
X  { "setenv",		ARGS_ZEROONETWO },
X  { "shell",		ARGS_ONE },
X  { "shellaka",		ARGS_ONE },			/* TO BE REMOVED */
X  { "shelltitle",	ARGS_ONE },
X  { "silence",		NEED_FORE|ARGS_ZEROONE },
X  { "silencewait",	ARGS_ONE },
X  { "sleep",		ARGS_ONE },
X  { "slowpaste",	ARGS_ONE },
X  { "startup_message",	ARGS_ONE },
X#ifdef BSDJOBS
X  { "suspend",		NEED_DISPLAY|ARGS_ZERO },
X#endif
X  { "term",		ARGS_ONE },
X  { "termcap",		ARGS_TWOTHREE },
X  { "terminfo",		ARGS_TWOTHREE },
X  { "time",		ARGS_ZERO },
X  { "title",		NEED_FORE|ARGS_ZEROONE },
X  { "unsetenv",		ARGS_ONE },
X  { "vbell",		ARGS_ZEROONE },
X  { "vbell_msg",	ARGS_ONE },
X  { "vbellwait",	ARGS_ONE },
X  { "version",		ARGS_ZERO },
X  { "wall",		NEED_DISPLAY|ARGS_ONE|ARGS_ORMORE },
X  { "width",		NEED_DISPLAY|ARGS_ZEROONE },
X  { "windows",		ARGS_ZERO },
X  { "wrap",		NEED_FORE|ARGS_ZEROONE },
X#ifdef COPY_PASTE
X  { "writebuf",		NEED_DISPLAY|ARGS_ZERO },
X#endif
X  { "writelock",	NEED_FORE|ARGS_ZEROONE },
X  { "xoff",		NEED_DISPLAY|ARGS_ZERO },
X  { "xon",		NEED_DISPLAY|ARGS_ZERO },
X  { "zombie",		ARGS_ZEROONE }
X};
END_OF_FILE
if test 5784 -ne `wc -c <'comm.c'`; then
    echo shar: \"'comm.c'\" unpacked with wrong size!
fi
# end of 'comm.c'
fi
if test -f 'comm.h.dist' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'comm.h.dist'\"
else
echo shar: Extracting \"'comm.h.dist'\" \(3328 characters\)
sed "s/^X//" >'comm.h.dist' <<'END_OF_FILE'
X/*
X * This file is automagically created from comm.c -- DO NOT EDIT
X */
X
Xstruct comm
X{
X  char *name;
X  int flags;
X#ifdef MULTIUSER
X  AclBits userbits[ACL_BITS_PER_CMD];
X#endif
X};
X
X#define ARGS_MASK	(3)
X
X#define ARGS_ZERO	(0)
X#define ARGS_ONE	(1)
X#define ARGS_TWO	(2)
X#define ARGS_THREE	(3)
X
X#define ARGS_PLUSONE	(1<<2)
X#define ARGS_PLUSTWO	(1<<3)
X#define ARGS_ORMORE	(1<<4)
X
X#define NEED_FORE	(1<<5)	/* this command needs a fore window */
X#define NEED_DISPLAY	(1<<6)	/* this command needs a display */
X
X#define ARGS_ZEROONE	(ARGS_ZERO|ARGS_PLUSONE)
X#define ARGS_ONETWO	(ARGS_ONE |ARGS_PLUSONE)
X#define ARGS_TWOTHREE	(ARGS_TWO |ARGS_PLUSONE)
X#define ARGS_ZEROTWO	(ARGS_ZERO|ARGS_PLUSTWO)
X#define ARGS_ZEROONETWO	(ARGS_ONE |ARGS_PLUSONE|ARGS_PLUSTWO)
X
Xstruct action
X{
X  int nr;
X  char **args;
X};
X
X#define RC_ILLEGAL -1
X
X#define RC_ACLADD 0
X#define RC_ACLCHG 1
X#define RC_ACLDEL 2
X#define RC_ACLGRP 3
X#define RC_ACTIVITY 4
X#define RC_AKA 5
X#define RC_ALLPARTIAL 6
X#define RC_AT 7
X#define RC_AUTODETACH 8
X#define RC_AUTONUKE 9
X#define RC_BELL 10
X#define RC_BIND 11
X#define RC_BREAK 12
X#define RC_BUFFERFILE 13
X#define RC_CHDIR 14
X#define RC_CLEAR 15
X#define RC_CLONE 16
X#define RC_COLON 17
X#define RC_CONSOLE 18
X#define RC_COPY 19
X#define RC_COPY_REG 20
X#define RC_CRLF 21
X#define RC_DEBUG 22
X#define RC_DEFAUTONUKE 23
X#define RC_DEFFLOW 24
X#define RC_DEFLOGIN 25
X#define RC_DEFMODE 26
X#define RC_DEFMONITOR 27
X#define RC_DEFOBUFLIMIT 28
X#define RC_DEFSCROLLBACK 29
X#define RC_DEFWRAP 30
X#define RC_DETACH 31
X#define RC_DISPLAYS 32
X#define RC_DUMPTERMCAP 33
X#define RC_DUPLICATE 34
X#define RC_ECHO 35
X#define RC_ESCAPE 36
X#define RC_EXEC 37
X#define RC_FLOW 38
X#define RC_HARDCOPY 39
X#define RC_HARDCOPY_APPEND 40
X#define RC_HARDCOPYDIR 41
X#define RC_HARDSTATUS 42
X#define RC_HEIGHT 43
X#define RC_HELP 44
X#define RC_HISTORY 45
X#define RC_INFO 46
X#define RC_INS_REG 47
X#define RC_KILL 48
X#define RC_LASTMSG 49
X#define RC_LICENSE 50
X#define RC_LOCKSCREEN 51
X#define RC_LOG 52
X#define RC_LOGDIR 53
X#define RC_LOGIN 54
X#define RC_MARKKEYS 55
X#define RC_META 56
X#define RC_MONITOR 57
X#define RC_MSGMINWAIT 58
X#define RC_MSGWAIT 59
X#define RC_MULTIUSER 60
X#define RC_NETHACK 61
X#define RC_NEXT 62
X#define RC_NUMBER 63
X#define RC_OBUFLIMIT 64
X#define RC_OTHER 65
X#define RC_PARTIAL 66
X#define RC_PASSWORD 67
X#define RC_PASTE 68
X#define RC_POW_BREAK 69
X#define RC_POW_DETACH 70
X#define RC_POW_DETACH_MSG 71
X#define RC_PREV 72
X#define RC_PROCESS 73
X#define RC_QUIT 74
X#define RC_READBUF 75
X#define RC_REDISPLAY 76
X#define RC_REGISTER 77
X#define RC_REMOVEBUF 78
X#define RC_RESET 79
X#define RC_SCREEN 80
X#define RC_SCROLLBACK 81
X#define RC_SELECT 82
X#define RC_SESSIONNAME 83
X#define RC_SETENV 84
X#define RC_SHELL 85
X#define RC_SHELLAKA 86
X#define RC_SHELLTITLE 87
X#define RC_SILENCE 88
X#define RC_SILENCEWAIT 89
X#define RC_SLEEP 90
X#define RC_SLOWPASTE 91
X#define RC_STARTUP_MESSAGE 92
X#define RC_SUSPEND 93
X#define RC_TERM 94
X#define RC_TERMCAP 95
X#define RC_TERMINFO 96
X#define RC_TIME 97
X#define RC_TITLE 98
X#define RC_UNSETENV 99
X#define RC_VBELL 100
X#define RC_VBELL_MSG 101
X#define RC_VBELLWAIT 102
X#define RC_VERSION 103
X#define RC_WALL 104
X#define RC_WIDTH 105
X#define RC_WINDOWS 106
X#define RC_WRAP 107
X#define RC_WRITEBUF 108
X#define RC_WRITELOCK 109
X#define RC_XOFF 110
X#define RC_XON 111
X#define RC_ZOMBIE 112
X
X#define RC_LAST 112
END_OF_FILE
if test 3328 -ne `wc -c <'comm.h.dist'`; then
    echo shar: \"'comm.h.dist'\" unpacked with wrong size!
fi
# end of 'comm.h.dist'
fi
if test -f 'comm.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'comm.sh'\"
else
echo shar: Extracting \"'comm.sh'\" \(1476 characters\)
sed "s/^X//" >'comm.sh' <<'END_OF_FILE'
X#!/bin/sh
X
Xif test -z "$AWK"; then
X  AWK=awk
Xfi
Xif test -z "$CC"; then
X  CC=cc
Xfi
Xif test -z "$srcdir"; then
X  srcdir=.
Xfi
X
Xrm -f comm.h
Xcat << EOF > comm.h
X/*
X * This file is automagically created from comm.c -- DO NOT EDIT
X */
X
Xstruct comm
X{
X  char *name;
X  int flags;
X#ifdef MULTIUSER
X  AclBits userbits[ACL_BITS_PER_CMD];
X#endif
X};
X
X#define ARGS_MASK	(3)
X
X#define ARGS_ZERO	(0)
X#define ARGS_ONE	(1)
X#define ARGS_TWO	(2)
X#define ARGS_THREE	(3)
X
X#define ARGS_PLUSONE	(1<<2)
X#define ARGS_PLUSTWO	(1<<3)
X#define ARGS_ORMORE	(1<<4)
X
X#define NEED_FORE	(1<<5)	/* this command needs a fore window */
X#define NEED_DISPLAY	(1<<6)	/* this command needs a display */
X
X#define ARGS_ZEROONE	(ARGS_ZERO|ARGS_PLUSONE)
X#define ARGS_ONETWO	(ARGS_ONE |ARGS_PLUSONE)
X#define ARGS_TWOTHREE	(ARGS_TWO |ARGS_PLUSONE)
X#define ARGS_ZEROTWO	(ARGS_ZERO|ARGS_PLUSTWO)
X#define ARGS_ZEROONETWO	(ARGS_ONE |ARGS_PLUSONE|ARGS_PLUSTWO)
X
Xstruct action
X{
X  int nr;
X  char **args;
X};
X
X#define RC_ILLEGAL -1
X
XEOF
X$AWK < ${srcdir}/comm.c >> comm.h '
X/^  [{] ".*/	{   if (old > $2) {
X		printf("***ERROR: %s <= %s !!!\n\n", $2, old);
X		exit 1;
X	    }
X	old = $2;
X	}
X'
X$CC -E -I. -I${srcdir} ${srcdir}/comm.c > comm.cpp
Xsed < comm.cpp \
X  -n \
X  -e '/^  { "/y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/' \
X  -e '/^  { "/s/^  { "\([^"]*\)".*/\1/p' \
X| $AWK '
X/.*/ {	printf "#define RC_%s %d\n",$0,i++;
X     }
XEND  {	printf "\n#define RC_LAST %d\n",i-1;
X     }
X' >> comm.h
Xchmod a-w comm.h
Xrm -f comm.cpp
END_OF_FILE
if test 1476 -ne `wc -c <'comm.sh'`; then
    echo shar: \"'comm.sh'\" unpacked with wrong size!
fi
# end of 'comm.sh'
fi
if test -f 'display.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'display.h'\"
else
echo shar: Extracting \"'display.h'\" \(6616 characters\)
sed "s/^X//" >'display.h' <<'END_OF_FILE'
X/* Copyright (c) 1993
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X ****************************************************************
X * $Id: display.h,v 1.4 1993/07/30 01:24:33 jnweiger Exp $ FAU
X */
X
Xstruct win;			/* forward declaration */
X
Xstruct display
X{
X  struct display *_d_next;	/* linked list */
X  struct user *_d_user;		/* user who owns that display */
X  struct LayFuncs *_d_layfn;	/* current layer functions */
X  struct layer *_d_lay;		/* layers on the display */
X  struct win *_d_fore;		/* pointer to fore window */
X  struct win *_d_other;		/* pointer to other window */
X  char  _d_termname[20 + 1];	/* $TERM */
X  char	_d_tentry[TERMCAP_BUFSIZE];	/* buffer for tgetstr */
X  int	_d_tcinited;		/* termcap inited flag */
X  int	_d_width, _d_height;	/* width/height of the screen */
X  int	_d_defwidth, _d_defheight;	/* default width/height of windows */
X  int	_d_top, _d_bot;		/* scrollregion start/end */
X  int	_d_x, _d_y;		/* cursor position */
X  char	_d_attr;		/* current attributes */
X  char	_d_font;		/* current font */
X  int	_d_insert;		/* insert mode flag */
X  int	_d_keypad;		/* application keypad flag */
X  int	_d_cursorkeys;		/* application cursorkeys flag */
X  int	_d_flow;		/* flow control on/off flag*/
X  int	_d_lp_missing;		/* last character on bot line missing */
X  int	_d_lp_image;		/* missing image */
X  int	_d_lp_attr;		/* missing attr */
X  int	_d_lp_font;		/* missing font */
X  int	_d_status;		/* is status displayed? */
X  time_t _d_status_time;	/* time of status display */
X  int	_d_status_bell;		/* is it only a vbell? */
X  int	_d_status_len;		/* length of status line */
X  char *_d_status_lastmsg;	/* last displayed message */
X  int   _d_status_buflen;	/* last message buffer len */
X  int	_d_status_lastx;	/* position of the cursor */
X  int	_d_status_lasty;	/*   before status was displayed */
X  int	_d_ESCseen;		/* Was the last char an ESC (^a) */
X  int	_d_userpid;		/* pid of attacher */
X  char	_d_usertty[MAXPATHLEN];	/* tty we are attached to */
X  int	_d_userfd;		/* fd of the tty */
X  struct mode _d_OldMode;	/* tty mode when screen was started */
X  struct mode _d_NewMode;	/* New tty mode */
X  char  *_d_obuf;		/* output buffer */
X  int   _d_obuflen;		/* len of buffer */
X  int	_d_obufmax;		/* len where we are blocking the pty */
X  char  *_d_obufp;		/* pointer in buffer */
X  int   _d_obuffree;		/* free bytes in buffer */
X#ifdef AUTO_NUKE
X  int	_d_auto_nuke;		/* autonuke flag */
X#endif
X  union	tcu _d_tcs[T_N];	/* terminal capabilities */
X  char	*_d_attrtab[NATTR];
X  short	_d_dospeed;		/* baudrate of tty */
X  char _d_c0_tab[256];		/* conversion for C0 */
X  int _d_UPcost, _d_DOcost, _d_LEcost, _d_NDcost;
X  int _d_CRcost, _d_IMcost, _d_EIcost, _d_NLcost;
X#ifdef UTMPOK
X  slot_t _d_loginslot;		/* offset, where utmp_logintty belongs */
X  struct utmp _d_utmp_logintty;	/* here the original utmp structure is stored */
X# ifdef _SEQUENT_
X  char _d_loginhost[100+1];
X# endif /* _SEQUENT_ */
X#endif
X};
X
X#ifdef MULTI
X# define DISPLAY(x) display->x
X#else
Xextern struct display TheDisplay;
X# define DISPLAY(x) TheDisplay.x
X#endif
X
X#define d_user		DISPLAY(_d_user)
X#define d_username	(DISPLAY(_d_user) ? DISPLAY(_d_user)->u_name : 0)
X#define d_layfn		DISPLAY(_d_layfn)
X#define d_lay		DISPLAY(_d_lay)
X#define d_fore		DISPLAY(_d_fore)
X#define d_other		DISPLAY(_d_other)
X#define d_termname	DISPLAY(_d_termname)
X#define d_tentry	DISPLAY(_d_tentry)
X#define d_tcinited	DISPLAY(_d_tcinited)
X#define d_width		DISPLAY(_d_width)
X#define d_height	DISPLAY(_d_height)
X#define d_defwidth	DISPLAY(_d_defwidth)
X#define d_defheight	DISPLAY(_d_defheight)
X#define d_top		DISPLAY(_d_top)
X#define d_bot		DISPLAY(_d_bot)
X#define d_x		DISPLAY(_d_x)
X#define d_y		DISPLAY(_d_y)
X#define d_attr		DISPLAY(_d_attr)
X#define d_font		DISPLAY(_d_font)
X#define d_insert	DISPLAY(_d_insert)
X#define d_keypad	DISPLAY(_d_keypad)
X#define d_cursorkeys	DISPLAY(_d_cursorkeys)
X#define d_flow		DISPLAY(_d_flow)
X#define d_lp_missing	DISPLAY(_d_lp_missing)
X#define d_lp_image	DISPLAY(_d_lp_image)
X#define d_lp_attr	DISPLAY(_d_lp_attr)
X#define d_lp_font	DISPLAY(_d_lp_font)
X#define d_status	DISPLAY(_d_status)
X#define d_status_time	DISPLAY(_d_status_time)
X#define d_status_bell	DISPLAY(_d_status_bell)
X#define d_status_len	DISPLAY(_d_status_len)
X#define d_status_lastmsg	DISPLAY(_d_status_lastmsg)
X#define d_status_buflen	DISPLAY(_d_status_buflen)
X#define d_status_lastx	DISPLAY(_d_status_lastx)
X#define d_status_lasty	DISPLAY(_d_status_lasty)
X#define d_ESCseen	DISPLAY(_d_ESCseen)
X#define d_userpid	DISPLAY(_d_userpid)
X#define d_usertty	DISPLAY(_d_usertty)
X#define d_userfd	DISPLAY(_d_userfd)
X#define d_OldMode	DISPLAY(_d_OldMode)
X#define d_NewMode	DISPLAY(_d_NewMode)
X#define d_obuf		DISPLAY(_d_obuf)
X#define d_obuflen	DISPLAY(_d_obuflen)
X#define d_obufmax	DISPLAY(_d_obufmax)
X#define d_obufp		DISPLAY(_d_obufp)
X#define d_obuffree	DISPLAY(_d_obuffree)
X#define d_auto_nuke	DISPLAY(_d_auto_nuke)
X#define d_tcs		DISPLAY(_d_tcs)
X#define d_attrtab	DISPLAY(_d_attrtab)
X#define d_dospeed	DISPLAY(_d_dospeed)
X#define d_c0_tab	DISPLAY(_d_c0_tab)
X#define d_UPcost	DISPLAY(_d_UPcost)
X#define d_DOcost	DISPLAY(_d_DOcost)
X#define d_LEcost	DISPLAY(_d_LEcost)
X#define d_NDcost	DISPLAY(_d_NDcost)
X#define d_CRcost	DISPLAY(_d_CRcost)
X#define d_IMcost	DISPLAY(_d_IMcost)
X#define d_EIcost	DISPLAY(_d_EIcost)
X#define d_NLcost	DISPLAY(_d_NLcost)
X#define d_loginslot	DISPLAY(_d_loginslot)
X#define d_utmp_logintty	DISPLAY(_d_utmp_logintty)
X#define d_loginhost	DISPLAY(_d_loginhost)
X
X
X#define GRAIN 4096  /* Allocation grain size for output buffer */
X#define OBUF_MAX 256
X   /* Maximum amount of buffered output before input is blocked */
X
X#define OUTPUT_BLOCK_SIZE 256  /* Block size of output to tty */
X
X#define AddChar(c) \
X  { \
X    if (--d_obuffree == 0) \
X      Resize_obuf(); \
X    *d_obufp++ = (c); \
X  }
X
END_OF_FILE
if test 6616 -ne `wc -c <'display.h'`; then
    echo shar: \"'display.h'\" unpacked with wrong size!
fi
# end of 'display.h'
fi
if test ! -d 'doc' ; then
    echo shar: Creating directory \"'doc'\"
    mkdir 'doc'
fi
if test -f 'doc/Makefile.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/Makefile.in'\"
else
echo shar: Extracting \"'doc/Makefile.in'\" \(917 characters\)
sed "s/^X//" >'doc/Makefile.in' <<'END_OF_FILE'
X# Makefile for Screen documentation
X
Xsrcdir = @srcdir@
XVPATH = @srcdir@
X
Xprefix = /usr/local
Xinfodir = $(prefix)/info
X
XINSTALL = @INSTALL@
XINSTALL_DATA = @INSTALL_DATA@
XMAKEINFO = makeinfo
XTEXI2DVI = texi2dvi
X
XSHELL = /bin/sh
X
Xall: 
X
Xdvi screen.dvi: screen.texinfo mostlyclean
X	$(TEXI2DVI) $(srcdir)/screen.texinfo
X
Xinfo screen.info: screen.texinfo
X	$(MAKEINFO) $(srcdir)/screen.texinfo -o screen.info
X
Xinstall: screen.info
X	-if test -f foo.info; then d=.; else d=$(srcdir); fi; \
X	-for f in $$d/screen.info*; do $(INSTALL_DATA) $$f $(infodir)/$$f;done \
X	if install-info --version >/dev/null 2>&1; then \
X	  install-info --infodir=$(infodir) $$d/foo.info; \
X	else true; fi
X	
Xuninstall:
X	rm -f $(infodir)/screen.info*
X
Xmostlyclean:
X	-rm -f *.cp *.cps *.fn *.fns *.ky *.kys *.pg *.tp *.vr
X	-rm -f *.log *.aux *.toc *~
X
Xclean distclean realclean clobber: mostlyclean
X	-rm -f *.dvi
X	-rm -f *.info*
X
Xcheck installcheck:
X
END_OF_FILE
if test 917 -ne `wc -c <'doc/Makefile.in'`; then
    echo shar: \"'doc/Makefile.in'\" unpacked with wrong size!
fi
# end of 'doc/Makefile.in'
fi
if test -f 'etcscreenrc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etcscreenrc'\"
else
echo shar: Extracting \"'etcscreenrc'\" \(4655 characters\)
sed "s/^X//" >'etcscreenrc' <<'END_OF_FILE'
X#3.3
X# This is a global screenrc file
X# Install this file as /usr/local/etc/screenrc. See config.h
X#
X# Flaws of termcap and standard settings are done here.
X# Note: This file should not be shared between different hosts.
X#       The 'termcap' lines are written in termcap syntax.
X#       The syntax for a terminfo based host is slightly different.
X#
X#echo "-----------------------------------------------------------------------"
X#echo ""
X#echo "     This is iScreen version 3.2.13  -- Enjoy :-)"
X#echo ""
X#echo "     Coredumps zu mir, Beschwerden nach /dev/null! "
X#echo "     Vorbeugend bitte schon mal alle screenrc files"
X#echo "     genau einmal mit ~jnweiger/trojan_horse/newsyntax bearbeiten!"
X#echo "     -- und in hartnaeckigen Faellen screen.old verwenden"
X#echo ""
X#echo "            Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)"
X#echo "-----------------------------------------------------------------------"
X#echo "       >>>>>>>>>>>> Press RETURN to continue <<<<<<<<<<<<"
X#sleep 5
X#startup_message off
X
X#defflow on # will force iScreen to process ^S/^Q
X
Xdeflogin on
X#autodetach off
X
X# 'vbell on' without the prepended 'set' keyword will change the default for 
X# subsequently opened windows. With the 'set' keyword we would change
X# the setting of the currently active window.
Xvbell on
Xvbell_msg "   Wuff  ----  Wuff!!  "
X
X# all termcap entries are now duplicated as terminfo entries.
X# only difference should be the slightly modified syntax, and check for
X# terminfo entries, that are already corected in the database.
X# 
X# G0 	we have a SEMI-GRAPHICS-CHARACTER-MODE
X# WS	this sequence resizes our window.
X# cs    this sequence changes the scrollregion
X# hs@	we have no hardware statusline. iScreen will only believe that
X#       there is a hardware status line if hs,ts,fs,ds are all set.
X# ts    to statusline
X# fs    from statusline
X# ds    delete statusline
X# al    add one line
X# AL    add multiple lines
X# dl    delete one line
X# DL    delete multiple lines
X# ic    insert one char (space)
X# IC    insert multiple chars
X# xo    terminal uses xon/xoff
X
Xtermcap  facit|vt100|xterm LP:G0
Xterminfo facit|vt100|xterm LP:G0
X
X#the vt100 description does not mention "dl". *sigh*
Xtermcap  vt100 dl=5\E[M
Xterminfo vt100 dl=5\E[M
X
X#facit's "al" / "dl"  are buggy if the current / last line
X#contain attributes...
Xtermcap  facit al=\E[L\E[K:AL@:dl@:DL@:cs=\E[%i%d;%dr:ic@
Xterminfo facit al=\E[L\E[K:AL@:dl@:DL@:cs=\E[%i%p1%d;%p2%dr:ic@
X
X#make sun termcap/info better
Xtermcap  sun 'up=^K:AL=\E[%dL:DL=\E[%dM:UP=\E[%dA:DO=\E[%dB:LE=\E[%dD:RI=\E[%dC:IC=\E[%d@:WS=1000\E[8;%d;%dt'
Xterminfo sun 'up=^K:AL=\E[%p1%dL:DL=\E[%p1%dM:UP=\E[%p1%dA:DO=\E[%p1%dB:LE=\E[%p1%dD:RI=\E[%p1%dC:IC=\E[%p1%d@:WS=\E[8;%p1%d;%p2%dt$<1000>'
X
X#xterm understands both im/ic and doesn't have a status line.
X#Note: Do not specify im and ic in the real termcap/info file as
X#some programs (e.g. vi) will not work anymore.
Xtermcap  xterm|fptwist hs@:cs=\E[%i%d;%dr:im=\E[4h:ei=\E[4l
Xterminfo xterm|fptwist hs@:cs=\E[%i%p1%d;%p2%dr:im=\E[4h:ei=\E[4l
X
X# xs is xterm's two letter name.
X# story ... in earlier versions I used xterms here ... buggy sequent termcap
X# routines allowes 32 :tc=...: references per lifetime.... gave lots of OOPS
X# at the 32. reattach. ... to avoid that, I added the name Xterm as an alias 
X# to xterm in our termcap file.
X# why I don't take the entry called xterm? well, I own a verion of xterm that
X# allows window resizing. My private .iscreenrc adds WS to this entry.
X
X# Anyway, here are all the definitions needed to access a hardstatus line
Xtermcap  xs 'hs:ts=\E]0;:fs=\007:ds=\E]0;Screen\007:cs=\E[%i%d;%dr:LP:G0:im=\E[4h:ei=\E[4l'
Xterminfo xs 'hs:ts=\E]0;:fs=\007:ds=\E]0;Screen\007:cs=\E[%i%p1%d;%p2%dr:LP:G0:im=\E[4h:ei=\E[4l'
Xtermcap  sun 'hs:ts=\E]l:fs=\E\\:ds=\E]lScreen\E\\'
Xterminfo  sun 'hs:ts=\E]l:fs=\E\\:ds=\E]lScreen\E\\'
Xtermcap  sun-cmd 'hs:ts=\E]l:fs=\E\\:ds=\E]lScreen\E\\'
Xterminfo  sun-cmd 'hs:ts=\E]l:fs=\E\\:ds=\E]lScreen\E\\'
X
X#make hp700 termcap/info better
Xtermcap  hp700 'Z0=\E[?3h:Z1=\E[?3l:hs:ts=\E[62"p\E[0$~\E[2$~\E[1$}:fs=\E[0}\E[61"p:ds=\E[62"p\E[1$~\E[61"p:ic@'
Xterminfo hp700 'Z0=\E[?3h:Z1=\E[?3l:hs:ts=\E[62"p\E[0$~\E[2$~\E[1$}:fs=\E[0}\E[61"p:ds=\E[62"p\E[1$~\E[61"p:ic@'
X
X#wyse-75-42 must have defflow control (xo = "terminal uses xon/xoff")
X#essential to have it here, as this is a slow terminal.
Xtermcap wy75-42 xo:Z0=\E[?3h\E[31h:Z1=\E[?3l\E[31h
Xterminfo wy75-42 xo:Z0=\E[?3h\E[31h:Z1=\E[?3l\E[31h
X
X#remove some stupid / dangerous key bindings
Xbind '-' prev
Xbind '^k'
X#bind 'L'
Xbind '^\'
X#make them better
Xbind '\\' quit
Xbind 'K' kill
Xbind 'I' login on
Xbind 'O' login off
Xbind '}' history
END_OF_FILE
if test 4655 -ne `wc -c <'etcscreenrc'`; then
    echo shar: \"'etcscreenrc'\" unpacked with wrong size!
fi
# end of 'etcscreenrc'
fi
if test -f 'input.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'input.c'\"
else
echo shar: Extracting \"'input.c'\" \(6219 characters\)
sed "s/^X//" >'input.c' <<'END_OF_FILE'
X/* Copyright (c) 1993
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X ****************************************************************
X */
X
X#include "rcs.h"
XRCS_ID("$Id: input.c,v 1.1.1.1 1993/06/16 23:51:12 jnweiger Exp $ FAU")
X
X#include <sys/types.h>
X#include "config.h"
X#include "screen.h"
X#include "extern.h"
X
Xstatic void InpProcess __P((char **, int *));
Xstatic void InpAbort __P((void));
Xstatic void InpRedisplayLine __P((int, int, int, int));
Xstatic void InpSetCursor __P((void));
X
Xextern struct display *display;
X
Xstruct inpdata
X{
X  char	inpbuf[101];
X  int	inplen;
X  int	inpmaxlen;
X  char	*inpstring;
X  int	inpstringlen;
X  int	inpmode;
X  void	(*inpfinfunc)();
X};
X
Xstatic struct LayFuncs InpLf =
X{
X  InpProcess,
X  InpAbort,
X  InpRedisplayLine,
X  DefClearLine,
X  DefRewrite,
X  InpSetCursor,
X  DefResize,
X  DefRestore
X};
X
X/*
X**   Here is the input routine
X*/
X
Xvoid
Xinp_setprompt(p, s)
Xchar *p, *s;
X{
X  struct inpdata *inpdata;
X  
X  inpdata = (struct inpdata *)d_lay->l_data;
X  if (p)
X    {
X      inpdata->inpstringlen = strlen(p);
X      inpdata->inpstring = p;
X    }
X  if (s)
X    {
X      strncpy(inpdata->inpbuf, s, sizeof(inpdata->inpbuf) - 1);
X      inpdata->inpbuf[sizeof(inpdata->inpbuf) - 1] = 0;
X      inpdata->inplen = strlen(inpdata->inpbuf);
X    }
X  RefreshLine(STATLINE, 0, d_width - 1, 0);
X}
X
X/*
X * We dont use HS status line with Input().
X * If we would use it, then we should check e_tgetflag("es") if
X * we are allowed to use esc sequences there.
X *
X * mode is an OR of
X * INP_NOECHO == suppress echoing of characters.
X * INP_RAW    == raw mode. call finfunc after each character typed.
X */
Xvoid
XInput(istr, len, finfunc, mode)
Xchar *istr;
Xint len;
Xvoid (*finfunc)();
Xint mode;
X{
X  int maxlen;
X  struct inpdata *inpdata;
X  
X  if (len > 100)
X    len = 100;
X  if (!(mode & INP_NOECHO))
X    {
X      maxlen = d_width - strlen(istr);
X      if (!CLP && STATLINE == d_bot)
X	maxlen--;
X      if (len > maxlen)
X	len = maxlen;
X    }
X  if (len < 0)
X    {
X      Msg(0, "Width %d chars too small", -len);
X      return;
X    }
X  if (InitOverlayPage(sizeof(*inpdata), &InpLf, 1))
X    return;
X  inpdata = (struct inpdata *)d_lay->l_data;
X  inpdata->inpmaxlen = len;
X  inpdata->inpfinfunc = finfunc;
X  inpdata->inplen = 0;
X  inpdata->inpmode = mode;
X  inp_setprompt(istr, (char *)NULL);
X}
X
Xstatic void
XInpSetCursor()
X{
X  struct inpdata *inpdata;
X  
X  inpdata = (struct inpdata *)d_lay->l_data;
X  GotoPos(inpdata->inpstringlen + (inpdata->inpmode & INP_NOECHO ? 0 : inpdata->inplen), STATLINE);
X}
X
Xstatic void
XInpProcess(ppbuf, plen)
Xchar **ppbuf;
Xint *plen;
X{
X  int len, x;
X  char *pbuf;
X  char ch;
X  struct inpdata *inpdata;
X  
X  inpdata = (struct inpdata *)d_lay->l_data;
X
X  GotoPos(inpdata->inpstringlen + (inpdata->inpmode & INP_NOECHO ? 0 : inpdata->inplen), STATLINE);
X  if (ppbuf == 0)
X    {
X      InpAbort();
X      return;
X    }
X  x = inpdata->inpstringlen + inpdata->inplen;
X  len = *plen;
X  pbuf = *ppbuf;
X  while (len)
X    {
X      ch = *pbuf++;
X      len--;
X      if (inpdata->inpmode & INP_RAW)
X	{
X          (*inpdata->inpfinfunc)(&ch, 1);	/* raw */
X	  if (ch)
X	    continue;
X	}
X      if ((unsigned char)ch >= ' ' && ch != 0177 && inpdata->inplen < inpdata->inpmaxlen)
X	{
X	  inpdata->inpbuf[inpdata->inplen++] = ch;
X	  if (!(inpdata->inpmode & INP_NOECHO))
X	    {
X	      GotoPos(x, STATLINE);
X	      SetAttrFont(A_SO, ASCII);
X	      PUTCHAR(ch);
X	      x++;
X	    }
X	}
X      else if ((ch == '\b' || ch == 0177) && inpdata->inplen > 0)
X	{
X	  inpdata->inplen--;
X	  if (!(inpdata->inpmode & 1))
X	    {
X	      x--;
X	      GotoPos(x, STATLINE);
X	      SetAttrFont(0, ASCII);
X	      PUTCHAR(' ');
X	      GotoPos(x, STATLINE);
X	    }
X	}
X      else if (ch == '\004' || ch == '\003' || ch == '\007' || ch == '\033' ||
X	       ch == '\000' || ch == '\n' || ch == '\r')
X	{
X          if (ch != '\033' && ch != '\n' && ch != '\r')
X	    inpdata->inplen = 0;
X	  inpdata->inpbuf[inpdata->inplen] = 0;
X	  
X  	  d_lay->l_data = 0;
X          InpAbort(); /* redisplays... */
X	  *ppbuf = pbuf;
X	  *plen = len;
X          if ((inpdata->inpmode & INP_RAW) == 0)
X            (*inpdata->inpfinfunc)(inpdata->inpbuf, inpdata->inplen);
X	  else
X            (*inpdata->inpfinfunc)(pbuf - 1, 0);
X	  free(inpdata);
X	  return;
X	}
X    }
X  *ppbuf = pbuf;
X  *plen = len;
X}
X
Xstatic void
XInpAbort()
X{
X  LAY_CALL_UP(RefreshLine(STATLINE, 0, d_width - 1, 0));
X  ExitOverlayPage();
X}
X
Xstatic void
XInpRedisplayLine(y, xs, xe, isblank)
Xint y, xs, xe, isblank;
X{
X  int q, r, s, l, v;
X  struct inpdata *inpdata;
X  
X  inpdata = (struct inpdata *)d_lay->l_data;
X
X  if (y != STATLINE)
X    {
X      LAY_CALL_UP(RefreshLine(y, xs, xe, isblank));
X      return;
X    }
X  inpdata->inpbuf[inpdata->inplen] = 0;
X  GotoPos(xs, y);
X  q = xs;
X  v = xe - xs + 1;
X  s = 0;
X  r = inpdata->inpstringlen;
X  if (v > 0 && q < r)
X    {
X      SetAttrFont(A_SO, ASCII);
X      l = v;
X      if (l > r-q)
X	l = r-q;
X      AddStrn(inpdata->inpstring + q - s, l);
X      q += l;
X      v -= l;
X    }
X  s = r;
X  r += inpdata->inplen;
X  if (!(inpdata->inpmode & INP_NOECHO) && v > 0 && q < r)
X    {
X      SetAttrFont(A_SO, ASCII);
X      l = v;
X      if (l > r-q)
X	l = r-q;
X      AddStrn(inpdata->inpbuf + q - s, l);
X      q += l;
X      v -= l;
X    }
X  s = r;
X  r = d_width;
X  if (!isblank && v > 0 && q < r)
X    {
X      SetAttrFont(0, ASCII);
X      l = v;
X      if (l > r-q)
X	l = r-q;
X      AddStrn("", l);
X      q += l;
X    }
X  SetLastPos(q, y);
X}
END_OF_FILE
if test 6219 -ne `wc -c <'input.c'`; then
    echo shar: \"'input.c'\" unpacked with wrong size!
fi
# end of 'input.c'
fi
if test -f 'loadav.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'loadav.c'\"
else
echo shar: Extracting \"'loadav.c'\" \(4640 characters\)
sed "s/^X//" >'loadav.c' <<'END_OF_FILE'
X/* Copyright (c) 1993
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X ****************************************************************
X */
X
X#include "rcs.h"
XRCS_ID("$Id: loadav.c,v 1.1.1.1 1993/06/16 23:51:13 jnweiger Exp $ FAU")
X
X#include <sys/types.h>
X#include <fcntl.h>
X
X#include "config.h"
X#include "screen.h"
X
X#include "extern.h"
X
X#ifdef LOADAV
X
Xstatic int GetLoadav __P((void));
X
Xstatic LOADAV_TYPE loadav[LOADAV_NUM];
Xstatic int loadok;
X
X
X
X/***************************************************************/
X
X#if defined(linux) && !defined(LOADAV_DONE)
X#define LOADAV_DONE
X/*
X * This is the easy way. It relies in /proc being mounted.
X * For the big and ugly way refer to previous screen version.
X */
Xvoid
XInitLoadav()
X{
X  loadok = 1;
X}
X
Xstatic int
XGetLoadav()
X{
X  FILE *fp;
X  double d[3];
X  int i;
X
X  if ((fp = secfopen("/proc/loadavg", "r")) == NULL)
X    return 0;
X  fscanf(fp, "%lf %lf %lf\n", d, d+1, d+2);
X  fclose(fp);
X  for (i = 0; i < LOADAV_NUM; i++)
X    loadav[i] = d[i];
X  return LOADAV_NUM;
X}
X#endif /* linux */
X
X/***************************************************************/
X
X#if defined(LOADAV_GETLOADAVG) && !defined(LOADAV_DONE)
X#define LOADAV_DONE
Xvoid
XInitLoadav()
X{
X  loadok = 1;
X}
X
Xstatic int
XGetLoadav()
X{
X  return getloadavg(loadav, LOADAV_NUM);
X}
X#endif
X
X/***************************************************************/
X
X#if defined(apollo) && !defined(LOADAV_DONE)
X#define LOADAV_DONE
Xvoid
XInitLoadav()
X{
X  loadok = 1;
X}
X
Xstatic int
XGetLoadav()
X{
X  proc1_$get_loadav(loadav);
X  return LOADAV_NUM;
X}
X#endif
X
X/***************************************************************/
X
X#if defined(NeXT) && !defined(LOADAV_DONE)
X#define LOADAV_DONE
X
X#include <mach.h>
X
Xstatic processor_set_t default_set;
X
Xvoid
XInitLoadav()
X{
X  kern_return_t error;
X
X  error = processor_set_default(host_self(), &default_set);
X  if (error != KERN_SUCCESS)
X    mach_error("Error calling processor_set_default", error);
X  else
X    loadok = 1;
X}
X
Xstatic int
XGetLoadav()
X{
X  unsigned int info_count;
X  struct processor_set_basic_info info;
X  host_t host;
X
X  info_count = PROCESSOR_SET_BASIC_INFO_COUNT;
X  if (processor_set_info(default_set, PROCESSOR_SET_BASIC_INFO, &host, (processor_set_info_t)&info, &info_count) != KERN_SUCCESS)
X    return 0;
X  loadav[0] = (float)info.load_average / LOAD_SCALE;
X  return 1;
X}
X#endif
X
X/***************************************************************/
X
X#if !defined(LOADAV_DONE)
X/*
X * The old fashion way: open kernel and read avenrun
X *
X * Header File includes
X */
X
X# ifdef NLIST_STRUCT
X#  include <nlist.h>
X# else
X#  include <a.out.h>
X# endif
X# ifndef NLIST_DECLARED
Xextern int nlist __P((char *, struct nlist *));
X# endif
X
Xstatic struct nlist nl[2];
Xstatic int kmemf;
X
Xvoid
XInitLoadav()
X{
X  debug("Init Kmem...\n");
X  kmemf = open("/dev/kmem", O_RDONLY);
X  if (kmemf == -1)
X    return;
X  debug("Kmem opened\n");
X# ifdef NLIST_NAME_UNION
X  nl[0].n_un.n_name = LOADAV_AVENRUN;
X# else
X  nl[0].n_name = LOADAV_AVENRUN;
X# endif
X  debug2("Searching in %s for %s\n", LOADAV_UNIX, nl[0].n_name);
X  nlist(LOADAV_UNIX, nl);
X  if (nl[0].n_value == 0)
X    {
X      close(kmemf);
X      return;
X    }
X# ifdef sgi
X  nl[0].n_value &= ~(1 << 31);	/* clear upper bit */
X# endif /* sgi */
X  debug1("AvenrunSym found (0x%lx)!!\n", nl[0].n_value);
X  loadok = 1;
X}
X
Xstatic int
XGetLoadav()
X{
X  if (lseek(kmemf, (off_t) nl[0].n_value, 0) == (off_t) - 1)
X    return 0;
X  if (read(kmemf, (char *) loadav, sizeof(loadav)) != sizeof(loadav))
X    return 0;
X  return LOADAV_NUM;
X}
X#endif
X
X/***************************************************************/
X
X
Xvoid
XAddLoadav(p)
Xchar *p;
X{
X  int i, j;
X  if (loadok == 0)
X    return;
X  j = GetLoadav();
X  for (i = 0; i < j; i++)
X    {
X      sprintf(p, " %2.2f", (double)loadav[i] / LOADAV_SCALE);
X      p += strlen(p);
X    }
X}
X
X#endif /* LOADAV */
END_OF_FILE
if test 4640 -ne `wc -c <'loadav.c'`; then
    echo shar: \"'loadav.c'\" unpacked with wrong size!
fi
# end of 'loadav.c'
fi
if test -f 'mark.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mark.h'\"
else
echo shar: Extracting \"'mark.h'\" \(1876 characters\)
sed "s/^X//" >'mark.h' <<'END_OF_FILE'
X/* Copyright (c) 1993
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X ****************************************************************
X * $Id: mark.h,v 1.1.1.1 1993/06/16 23:51:13 jnweiger Exp $ FAU
X */
X
Xstruct markdata
X{
X  int	cx, cy;		/* cursor Position in WIN coords*/
X  int	x1, y1;		/* first mark in WIN coords */
X  int	second;		/* first mark dropped flag */
X  int	left_mar, right_mar, nonl;
X  int	rep_cnt;	/* number of repeats */
X  int	append_mode;	/* shall we overwrite or append to copybuffer */
X  int	write_buffer;	/* shall we do a KEY_WRITE_EXCHANGE right away? */
X  int	hist_offset;	/* how many lines are on top of the screen */
X  char	isstr[100];	/* string we are searching for */
X  int	isstrl;
X  char	isistr[200];	/* string of chars user has typed */
X  int	isistrl;
X  int	isdir;		/* current search direction */
X  int	isstartpos;	/* position where isearch was started */
X  int	isstartdir;	/* direction when isearch was started */
X};
X
X
X#define W2D(y) ((y) - markdata->hist_offset)
X#define D2W(y) ((y) + markdata->hist_offset)
X
END_OF_FILE
if test 1876 -ne `wc -c <'mark.h'`; then
    echo shar: \"'mark.h'\" unpacked with wrong size!
fi
# end of 'mark.h'
fi
if test -f 'misc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc.c'\"
else
echo shar: Extracting \"'misc.c'\" \(5041 characters\)
sed "s/^X//" >'misc.c' <<'END_OF_FILE'
X/* Copyright (c) 1993
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X ****************************************************************
X */
X
X#include "rcs.h"
XRCS_ID("$Id: misc.c,v 1.3 1993/07/21 15:43:14 mlschroe Exp $ FAU")
X
X#include <sys/types.h>
X#include <signal.h>
X
X#include "config.h"
X#include "screen.h"
X#include "extern.h"
X
X#ifdef SVR4
X# include <sys/resource.h>
X#endif
X
Xextern char *blank;
Xextern struct display *display;
Xextern int eff_uid, real_uid;
Xextern int eff_gid, real_gid;
X
Xchar *
XSaveStr(str)
Xregister const char *str;
X{
X  register char *cp;
X
X  if ((cp = malloc(strlen(str) + 1)) == NULL)
X    Panic(0, strnomem);
X  else
X    strcpy(cp, str);
X  return cp;
X}
X
Xvoid
Xcenterline(str)
Xchar *str;
X{
X  int l, n;
X
X  n = strlen(str);
X  if (n > d_width - 1)
X    n = d_width - 1;
X  l = (d_width - 1 - n) / 2;
X  if (l > 0)
X    AddStrn("", l);
X  AddStrn(str, n);
X  AddStr("\r\n");
X}
X
Xchar *
XFilename(s)
Xchar *s;
X{
X  register char *p = s;
X
X  if (p)
X    while (*p)
X      if (*p++ == '/')
X        s = p;
X  return s;
X}
X
Xchar *
Xstripdev(nam)
Xchar *nam;
X{
X#ifdef apollo
X  char *p;
X  
X  if (nam == NULL)
X    return NULL;
X  if (p = strstr(nam,"/dev/"))
X    return p + 5;
X#else /* apollo */
X  if (nam == NULL)
X    return NULL;
X  if (strncmp(nam, "/dev/", 5) == 0)
X    return nam + 5;
X#endif /* apollo */
X  return nam;
X}
X
X#ifdef hpux
X/*
X * hpux has berkeley signal semantics if we use sigvector,
X * but not, if we use signal, so we define our own signal() routine.
X * (jw)
X */
Xvoid (*signal(sig, func)) ()
Xint sig;
Xvoid (*func) ();
X{
X  struct sigvec osv, sv;
X
X  sv.sv_handler = func;
X  sv.sv_mask = sigmask(sig);
X  sv.sv_flags = SV_BSDSIG;
X  if (sigvector(sig, &sv, &osv) < 0)
X    return (BADSIG);
X  return (osv.sv_handler);
X}
X#endif	/* hpux */
X
X#ifdef NEED_OWN_BCOPY
Xvoid
X#ifdef linux
Xbcopy(ss1, ss2, len)
Xregister const void *ss1;
Xregister void *ss2;
X#else
Xbcopy(s1, s2, len)
Xregister char *s1, *s2;
X#endif
X
Xregister int len;
X{
X#ifdef linux
X  register char *s1 = (char *)ss1;
X  register char *s2 = (char *)ss2;
X#endif
X  if (s1 < s2 && s2 < s1 + len)
X    {
X      s1 += len;
X      s2 += len;
X      while (len-- > 0)
X	*--s2 = *--s1;
X    }
X  else
X    while (len-- > 0)
X      *s2++ = *s1++;
X}
X#endif	/* NEED_OWN_BCOPY */
X
Xvoid
Xbclear(p, n)
Xchar *p;
Xint n;
X{
X  bcopy(blank, p, n);
X}
X
Xvoid
XKill(pid, sig)
Xint pid, sig;
X{
X  if (pid < 2)
X    return;
X  (void) kill(pid, sig);
X}
X
Xvoid
Xcloseallfiles(except)
Xint except;
X{
X  int f;
X#ifdef SVR4
X  int getrlimit __P((int, struct rlimit *));
X  struct rlimit rl;
X  
X  if ((getrlimit(RLIMIT_NOFILE, &rl) == 0) && rl.rlim_max != RLIM_INFINITY)
X    f = rl.rlim_max;
X  else
X#endif /* SVR4 */
X#if defined(SYSV) && !defined(ISC)
X  f = NOFILE;
X#else /* SYSV && !ISC */
X  f = getdtablesize();
X#endif /* SYSV && !ISC */
X  while (--f > 2)
X    if (f != except)
X      close(f);
X}
X
X
X#ifdef NOREUID
Xstatic int UserPID;
Xstatic sig_t (*Usersigcld)__P(SIGPROTOARG);
X#endif
Xstatic int UserSTAT;
X
Xint
XUserContext()
X{
X#ifdef NOREUID
X  if (eff_uid == real_uid)
X    return(1);
X  Usersigcld = signal(SIGCHLD, SIG_DFL);
X  debug("UserContext: forking.\n");
X  switch (UserPID = fork())
X    {
X    case -1:
X      Msg(errno, "fork");
X      return -1;
X    case 0:
X      signal(SIGHUP, SIG_DFL);
X      signal(SIGINT, SIG_IGN);
X      signal(SIGQUIT, SIG_DFL);
X      signal(SIGTERM, SIG_DFL);
X# ifdef BSDJOBS
X      signal(SIGTTIN, SIG_DFL);
X      signal(SIGTTOU, SIG_DFL);
X# endif
X      setuid(real_uid);
X      setgid(real_gid);
X      return 1;
X    default:
X      return 0;
X    }
X#else
X  setreuid(eff_uid, real_uid);
X  setregid(eff_gid, real_gid);
X  return 1;
X#endif
X}
X
Xvoid
XUserReturn(val)
Xint val;
X{
X#if defined(NOREUID)
X  if (eff_uid == real_uid)
X    UserSTAT = val;
X  else
X    exit(val);
X#else
X  setreuid(real_uid, eff_uid);
X  setregid(real_gid, eff_gid);
X  UserSTAT = val;
X#endif
X}
X
Xint
XUserStatus()
X{
X#ifdef NOREUID
X  int i;
X# ifdef BSDWAIT
X  union wait wstat;
X# else
X  int wstat;
X# endif
X
X  if (eff_uid == real_uid)
X    return UserSTAT;
X  if (UserPID < 0)
X    return -1;
X  while ((errno = 0, i = wait(&wstat)) != UserPID)
X    if (i < 0 && errno != EINTR)
X      break;
X  (void) signal(SIGCHLD, Usersigcld);
X  if (i == -1)
X    return -1;
X  return (WEXITSTATUS(wstat));
X#else
X  return UserSTAT;
X#endif
X}
END_OF_FILE
if test 5041 -ne `wc -c <'misc.c'`; then
    echo shar: \"'misc.c'\" unpacked with wrong size!
fi
# end of 'misc.c'
fi
if test -f 'newsyntax' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsyntax'\"
else
echo shar: Extracting \"'newsyntax'\" \(1923 characters\)
sed "s/^X//" >'newsyntax' <<'END_OF_FILE'
X#!/bin/sh
X#
X# newsyntax -- update a screenrc file from 3.2 to 3.3 syntax
X#
X# please check all comments after running this script and watch out 
X# for funny passages.
X#
Xif [ $# != 1 ]; then
X  echo "usage $0 screenrcfile"
X  exit 1;
Xfi
X
X#Ultrix 4.2 /bin/sh does not handle "read a < $1" 
X#Dean Gaudet <dgaudet@watdragon.uwaterloo.ca>
Xexec < $1
Xread a
X
Xif [ ."$a" = '.#3.3' ]; then
X  echo "$1 already updated"
X  exit 0
Xfi
X
Xcp $1 $1.old
Xecho "#3.3" > $1
Xecho "# Do not remove the above line. This screen rc file was updated" >> $1
Xecho "# by the newsyntax script." >> $1
Xsed < $1.old >> $1 \
X-e 's/\([	 #]\)flow/\1defflow/g' \
X-e 's/^flow/defflow/g' \
X-e 's/\([	 #]\)set[ 	]*defflow/\1flow/g' \
X-e 's/^set[ 	]*defflow/flow/g' \
X-e 's/\([	 #]\)mode/\1defmode/g' \
X-e 's/^mode/defmode/g' \
X-e 's/\([	 #]\)set[ 	]*defmode/\1defmode/g' \
X-e 's/^set[ 	]*defmode/defmode/g' \
X-e 's/\([	 #]\)monitor/\1defmonitor/g' \
X-e 's/^monitor/defmonitor/g' \
X-e 's/\([	 #]\)set[	 ]*defmonitor/\1monitor/g' \
X-e 's/^set[	 ]*defmonitor/monitor/g' \
X-e 's/\([	 #]\)login/\1deflogin/g' \
X-e 's/^login/deflogin/g' \
X-e 's/\([	 #]\)set[	 ]*deflogin/\1login/g' \
X-e 's/^set[	 ]*deflogin/login/g' \
X-e 's/\([	 #]\)wrap/\1defwrap/g' \
X-e 's/^wrap/defwrap/g' \
X-e 's/\([	 #]\)set[	 ]*defwrap/\1wrap/g' \
X-e 's/^set[	 ]*defwrap/wrap/g' \
X-e 's/\([	 #]\)scrollback/\1defscrollback/g' \
X-e 's/^scrollback/defscrollback/g' \
X-e 's/\([	 #]\)set[	 ]*defscrollback/\1scrollback/g' \
X-e 's/^set[	 ]*defscrollback/scrollback/g' \
X-e 's/\([	 #]\)refresh/\1allPARtial/g' \
X-e 's/^refresh/allPARtial/g' \
X-e 's/\([	 #]\)redraw/\1allPARtial/g' \
X-e 's/^redraw/allPARtial/g' \
X-e 's/\([	 #]\)set[	 ]*allPARtial/\1PARtial/g' \
X-e 's/^set[	 ]*allPARtial/PARtial/g' \
X-e 's/\([	 #]\)visualbell/\1vbell/g' \
X-e 's/^visualbell/vbell/g' \
X-e 's/PARtial\([ 	]*\)on/partial\1off/g' \
X-e 's/PARtial\([ 	]*\)off/partial\1on/g' \
X-e 's/allPARtial/refresh/g' \
X-e 's/^set[ 	]//g'
X
END_OF_FILE
if test 1923 -ne `wc -c <'newsyntax'`; then
    echo shar: \"'newsyntax'\" unpacked with wrong size!
fi
chmod +x 'newsyntax'
# end of 'newsyntax'
fi
if test -f 'osdef.h.in' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'osdef.h.in'\"
else
echo shar: Extracting \"'osdef.h.in'\" \(4905 characters\)
sed "s/^X//" >'osdef.h.in' <<'END_OF_FILE'
X/* Copyright (c) 1993
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X ****************************************************************
X * $Id: osdef.h.in,v 1.1 1993/08/04 00:42:39 mlschroe Exp $ FAU
X */
X
X/****************************************************************
X * Thanks to Christos S. Zoulas (christos@ee.cornell.edu) who 
X * mangled the screen source through 'gcc -Wall'.
X ****************************************************************
X */
X
X#ifdef SYSV
Xextern char *strchr __P((char *, int));
Xextern char *strrchr __P((char *, int));
Xextern char *memset __P((char *, int, int));
Xextern int   memcmp __P((char *, char *, int));
X#else
Xextern char *index __P((char *, int));
Xextern char *rindex __P((char *, int));
Xextern void  bzero __P((char *, int));
Xextern int   bcmp __P((char *, char *, int));
Xextern int   killpg __P((int, int));
X#endif
X
X#ifndef USEBCOPY
X# ifdef USEMEMCPY
Xextern void  memcpy __P((char *, char *, int));
X# else
X#  ifdef USEMEMMOVE
Xextern void  memmove __P((char *, char *, int));
X#  else
Xextern void  bcopy __P((char *, char *, int));
X#  endif
X# endif
X#else
Xextern void  bcopy __P((char *, char *, int));
X#endif
X
X#ifdef BSDWAIT
Xstruct rusage;
Xunion wait;
Xextern int   wait3 __P((union wait *, int, struct rusage *));
X#else
Xextern int   waitpid __P((int, int *, int));
X#endif
X
Xextern int   getdtablesize __P((void));
X
X#ifndef NOREUID
X# ifdef hpux
Xextern int   setresuid __P((int, int, int));
Xextern int   setresgid __P((int, int, int));
X# else
Xextern int   setreuid __P((int, int));
Xextern int   setregid __P((int, int));
X# endif
X#endif
X
Xextern char *crypt __P((char *, char *));
Xextern int   putenv __P((char *));
X
Xextern int   tgetent __P((char *, char *));
Xextern int   tgetnum __P((char *));
Xextern int   tgetflag __P((char *));
Xextern void  tputs __P((char *, int, void (*)(int)));
Xextern char *tgoto __P((char *, int, int));
X
X#ifdef POSIX
Xextern int   setsid __P((void));
Xextern int   setpgid __P((int, int));
Xextern int   tcsetpgrp __P((int, int));
X#endif
Xextern int   ioctl __P((int, int, char *));
X
Xextern int   getpgrp __P((int));
Xextern int   kill __P((int, int));
X
Xextern int   getpid __P((void));
Xextern int   getuid __P((void)); 
Xextern int   geteuid __P((void));
Xextern int   getgid __P((void)); 
Xextern int   getegid __P((void));
Xextern struct passwd *getpwuid __P((int));
Xextern struct passwd *getpwnam __P((char *));
Xextern int   isatty __P((int)); 
Xextern int   chown __P((char *, int, int)); 
Xextern int   rename __P((char *, char *));
X
Xextern int   gethostname __P((char *, int));
Xextern int   lseek __P((int, int, int));
Xextern void  exit __P((int));
Xextern char *getwd __P((char *));
Xextern char *getenv __P((char *));
Xextern time_t time __P((time_t *));
X
Xextern char *getpass __P((char *));
Xextern char *getlogin __P((void));
Xextern char *ttyname __P((int));
X
Xextern int   fputs __P((char *, FILE *)); 
Xextern int   fwrite __P((char *, int, int, FILE *));
Xextern int   fflush __P((FILE *)); 
Xextern int   fclose __P((FILE *)); 
X
Xextern char *malloc __P((int));
Xextern char *realloc __P((char *, int));
Xextern void  free __P((char *));
X
X#ifdef NAMEDPIPE
Xextern int   mknod __P((char *, int, int));
X#else
Xstruct sockaddr;
Xextern int   socket __P((int, int, int));
Xextern int   connect __P((int, struct sockaddr *, int));
Xextern int   bind __P((int, struct sockaddr *, int));
Xextern int   listen __P((int, int));
Xextern int   accept __P((int, struct sockaddr *, int *));
X#endif
X
X#if defined(UTMPOK) && defined(GETUTENT)
Xextern void  setutent __P((void));
X#endif
X
X#if defined(sequent) || defined(_SEQUENT_)
Xextern int   getpseudotty __P((char **, char **));
X#ifdef _SEQUENT_
Xextern int   fvhangup __P((char *));
X#endif
X#endif
X
X#ifdef USEVARARGS
Xextern int   vsprintf __P((char *, char *, va_list));
X#endif
Xstruct timeval;
Xextern int   select __P((int, fd_set *, fd_set *, fd_set *, struct timeval *));
X
Xextern void  unsetenv __P((char *));
X
X# if defined(GETTTYENT) && !defined(GETUTENT) && !defined(UTNOKEEP)
Xstruct ttyent;
Xextern void  setttyent __P((void));
Xextern struct ttyent *getttyent __P((void));
X# endif
END_OF_FILE
if test 4905 -ne `wc -c <'osdef.h.in'`; then
    echo shar: \"'osdef.h.in'\" unpacked with wrong size!
fi
# end of 'osdef.h.in'
fi
if test -f 'osdef.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'osdef.sh'\"
else
echo shar: Extracting \"'osdef.sh'\" \(778 characters\)
sed "s/^X//" >'osdef.sh' <<'END_OF_FILE'
X#!/bin/sh
X
Xif test -z "$CC"; then
X  CC=cc
Xfi
Xif test -z "$srcdir"; then
X  srcdir=.
Xfi
X
Xsed < $srcdir/osdef.h.in -n -e '/^extern/s@.*[)* 	][)* 	]*\([^ ]*\) __P.*@/[)*, 	]\1[ 	(]/s/.*/\\/\1 __P\\/d/p@p' > osdef1.sed
Xcat << EOF > osdef0.c
X#include "config.h"
X#include <sys/types.h>
X#include <stdio.h>
X#include <signal.h>
X#include <sys/stat.h>
X#include <pwd.h>
X#ifdef SHADOWPW
X#include <shadow.h>
X#endif
X#ifndef sun
X#include <sys/ioctl.h>
X#endif
X#ifndef NAMEDPIPE
X#include <sys/socket.h>
X#endif
X#include "os.h"
XEOF
Xcat << EOF > osdef2.sed
X1i\\
X/*
X1i\\
X * This file is automagically created from osdef.sh -- DO NOT EDIT
X1i\\
X */
XEOF
X$CC -I. -I$srcdir -E osdef0.c | sed -n -f osdef1.sed >> osdef2.sed
Xsed -f osdef2.sed < $srcdir/osdef.h.in > osdef.h
Xrm osdef0.c osdef1.sed osdef2.sed
END_OF_FILE
if test 778 -ne `wc -c <'osdef.sh'`; then
    echo shar: \"'osdef.sh'\" unpacked with wrong size!
fi
# end of 'osdef.sh'
fi
if test -f 'overlay.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'overlay.h'\"
else
echo shar: Extracting \"'overlay.h'\" \(2149 characters\)
sed "s/^X//" >'overlay.h' <<'END_OF_FILE'
X/* Copyright (c) 1993
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X ****************************************************************
X * $Id: overlay.h,v 1.2 1993/06/23 22:49:11 mlschroe Exp $ FAU
X */
X
X/*
X * This is the overlay structure. It is used to create a seperate
X * layer over the current windows.
X */
X
Xstruct LayFuncs
X{
X  void	(*LayProcess) __P((char **, int *));
X  void	(*LayAbort) __P((void));
X  void	(*LayRedisplayLine) __P((int, int, int, int));
X  void	(*LayClearLine) __P((int, int, int));
X  int	(*LayRewrite) __P((int, int, int, int));
X  void	(*LaySetCursor) __P((void));
X  int	(*LayResize) __P((int, int));
X  void	(*LayRestore) __P((void));
X};
X
Xstruct layer
X{
X  struct layer *l_next;
X  int	l_block;
X  struct LayFuncs *l_layfn;
X  char	*l_data;		/* should be void * */
X};
X
X#define Process		(*d_layfn->LayProcess)
X#define Abort		(*d_layfn->LayAbort)
X#define RedisplayLine	(*d_layfn->LayRedisplayLine)
X#define ClearLine	(*d_layfn->LayClearLine)
X#define Rewrite		(*d_layfn->LayRewrite)
X#define SetCursor	(*d_layfn->LaySetCursor)
X#define Resize		(*d_layfn->LayResize)
X#define Restore		(*d_layfn->LayRestore)
X
X#define LAY_CALL_UP(fn) \
X	{ \
X	  struct layer *oldlay = d_lay; \
X	  d_lay = d_lay->l_next; \
X	  d_layfn = d_lay->l_layfn; \
X	  fn; \
X	  d_lay = oldlay; \
X	  d_layfn = d_lay->l_layfn; \
X	}
X
END_OF_FILE
if test 2149 -ne `wc -c <'overlay.h'`; then
    echo shar: \"'overlay.h'\" unpacked with wrong size!
fi
# end of 'overlay.h'
fi
if test -f 'pty.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pty.c'\"
else
echo shar: Extracting \"'pty.c'\" \(6085 characters\)
sed "s/^X//" >'pty.c' <<'END_OF_FILE'
X/* Copyright (c) 1993
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X ****************************************************************
X */
X
X#include "rcs.h"
XRCS_ID("$Id: pty.c,v 1.3 1993/08/04 00:42:48 mlschroe Exp $ FAU")
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <fcntl.h>
X#include <signal.h>
X
X#include "config.h"
X#include "screen.h"
X
X#ifndef sun
X#include <sys/ioctl.h>
X#endif
X
X#if defined(sun) && defined(LOCKPTY) && !defined(TIOCEXCL)
X#include <sys/ttold.h>
X#endif
X
X#ifdef ISC
X# include <sys/tty.h>
X# include <sys/sioctl.h>
X# include <sys/pty.h>
X#endif
X
X#include "extern.h"
X
X/*
X * if no PTYRANGE[01] is in the config file, we pick a default
X */
X#ifndef PTYRANGE0
X# define PTYRANGE0 "qpr"
X#endif
X#ifndef PTYRANGE1
X# define PTYRANGE1 "0123456789abcdef"
X#endif
X
Xextern int eff_uid;
X
X/* used for opening a new pty-pair: */
Xstatic char PtyName[32], TtyName[32];
X
X#if !(defined(sequent) || defined(_SEQUENT_) || defined(SVR4))
X# ifdef hpux
Xstatic char PtyProto[] = "/dev/ptym/ptyXY";
Xstatic char TtyProto[] = "/dev/pty/ttyXY";
X# else
Xstatic char PtyProto[] = "/dev/ptyXY";
Xstatic char TtyProto[] = "/dev/ttyXY";
X# endif /* hpux */
X#endif
X
X
X#if defined(sequent) || defined(_SEQUENT_)
X
Xint
XOpenPTY(ttyn)
Xchar **ttyn;
X{
X  char *m, *s;
X  register int f;
X
X  if ((f = getpseudotty(&s, &m)) < 0)
X    return -1;
X#ifdef _SEQUENT_
X  fvhangup(s);
X#endif
X  strncpy(PtyName, m, sizeof(PtyName));
X  strncpy(TtyName, s, sizeof(TtyName));
X#ifdef POSIX
X  tcflush(f, TCIOFLUSH);
X#else
X# ifdef TIOCFLUSH
X  (void) ioctl(f, TIOCFLUSH, (char *) 0);
X# endif
X#endif
X#ifdef LOCKPTY
X  (void) ioctl(f, TIOCEXCL, (char *) 0);
X#endif
X  *ttyn = TtyName;
X  return f;
X}
X
X#else
X# ifdef MIPS
X#  ifdef __sgi /* __sgi -> IRIX 4.0 */
X
Xint
XOpenPTY(ttyn)
Xchar **ttyn;
X{
X  int f;
X  char *name; 
X  sig_t (*sigcld)__P(SIGPROTOARG);
X
X  /*
X   * SIGCHLD set to SIG_DFL for _getpty() because it may fork() and
X   * exec() /usr/adm/mkpts
X   */
X  sigcld = signal(SIGCHLD, SIG_DFL);
X  name = _getpty(&f, O_RDWR | O_NDELAY, 0600, 0);
X  signal(SIGCHLD, sigcld);
X
X  if (name == NULL)
X    return -1;
X#ifdef LOCKPTY
X  (void) ioctl(f, TIOCEXCL, (char *) 0);
X#endif
X  *ttyn = name;
X  return f;
X}
X
X#  else /* __sgi */
X
Xint
XOpenPTY(ttyn)
Xchar **ttyn;
X{
X  register int f;
X  register int my_minor;
X  struct stat buf;
X   
X  strcpy(PtyName, "/dev/ptc");
X  f = open(PtyName, O_RDWR | O_NDELAY);
X  if (f < 0)
X    return -1;
X  if (fstat(f, &buf) < 0)
X    {
X      close(f);
X      return -1;
X    }
X  my_minor = minor(buf.st_rdev);
X  sprintf(TtyName, "/dev/ttyq%d", my_minor);
X#ifdef LOCKPTY
X  (void) ioctl(f, TIOCEXCL, (char *) 0);
X#endif
X  *ttyn = TtyName;
X  return f;
X}
X
X#  endif /* __sgi */
X# else /* MIPS */
X#  ifdef SVR4
X
Xint
XOpenPTY(ttyn)
Xchar **ttyn;
X{
X  char *m;
X  register int f;
X  char *ptsname();
X  int unlockpt __P((int)), grantpt __P((int));
X  sig_t (*sigcld)__P(SIGPROTOARG);
X
X  if ((f = open("/dev/ptmx", O_RDWR)) == -1)
X    return -1;
X
X  /*
X   * SIGCHLD set to SIG_DFL for grantpt() because it fork()s and
X   * exec()s pt_chmod
X   */
X  sigcld = signal(SIGCHLD, SIG_DFL);
X       
X  if ((m = ptsname(f)) == NULL || unlockpt(f) || grantpt(f))
X    {
X      signal(SIGCHLD, sigcld);
X      close(f);
X      return -1;
X    } 
X  signal(SIGCHLD, sigcld);
X  strncpy(TtyName, m, sizeof(TtyName));
X#ifdef POSIX
X  tcflush(f, TCIOFLUSH);
X#else
X# ifdef TIOCFLUSH
X  (void) ioctl(f, TIOCFLUSH, (char *) 0);
X# endif
X#endif
X#ifdef LOCKPTY
X  (void) ioctl(f, TIOCEXCL, (char *) 0);
X#endif
X  *ttyn = TtyName;
X  return f;
X}
X
X#  else /* not SVR4 */
X#   ifdef _AIX /* RS6000 */
X
Xint
XOpenPTY(ttyn)
Xchar **ttyn;
X{
X  register int f;
X
X  /* a dumb looking loop replaced by mycrofts code: */
X  strcpy (PtyName, "/dev/ptc");
X  if ((f = open (PtyName, O_RDWR)) < 0)
X    return -1;
X  strcpy (TtyName, ttyname(f));
X  strcpy (PtyName, TtyName);
X  PtyName [7] = 'c'; 
X  if (eff_uid && access(TtyName, R_OK | W_OK))
X    {
X      close(f);
X      return -1;
X    }
X#ifdef LOCKPTY
X  if (ioctl (f, TIOCEXCL, (char *) 0) == -1)
X    return -1;
X#endif /* LOCKPTY */
X  *ttyn = TtyName;
X  return f;
X}
X
X#   else /* _AIX, RS6000 */
X
Xint
XOpenPTY(ttyn)
Xchar **ttyn;
X{
X  register char *p, *q, *l, *d;
X  register int f;
X
X  debug("OpenPTY: Using BSD style ptys.\n");
X  strcpy(PtyName, PtyProto);
X  strcpy(TtyName, TtyProto);
X  for (p = PtyName; *p != 'X'; ++p)
X    ;
X  for (q = TtyName; *q != 'X'; ++q)
X    ;
X  for (l = PTYRANGE0; (*p = *l) != '\0'; ++l)
X    {
X      for (d = PTYRANGE1; (p[1] = *d) != '\0'; ++d)
X	{
X	  debug1("OpenPTY tries '%s'\n", PtyName);
X	  if ((f = open(PtyName, O_RDWR)) == -1)
X	    continue;
X	  q[0] = *l;
X	  q[1] = *d;
X	  if (eff_uid && access(TtyName, R_OK | W_OK))
X	    {
X	      close(f);
X	      continue;
X	    }
X#if defined(sun) && defined(TIOCGPGRP) && !defined(SUNOS3)
X	  /* Hack to ensure that the slave side of the pty is
X	   * unused. May not work in anything other than SunOS4.1
X	   */
X	    {
X	      int pgrp;
X
X	      /* tcgetpgrp does not work (uses TIOCGETPGRP)! */
X	      if (ioctl(f, TIOCGPGRP, (char *)&pgrp) != -1 || errno != EIO)
X		{
X		  close(f);
X		  continue;
X		}
X	    }
X#endif
X#ifdef LOCKPTY
X	  (void) ioctl(f, TIOCEXCL, (char *) 0);
X#endif
X	  *ttyn = TtyName;
X	  return f;
X	}
X    }
X  return -1;
X}
X
X#   endif /* _AIX, RS6000 */
X#  endif /* SVR4 */
X# endif /* MIPS */
X#endif /* sequent || SEQUENT */
END_OF_FILE
if test 6085 -ne `wc -c <'pty.c'`; then
    echo shar: \"'pty.c'\" unpacked with wrong size!
fi
# end of 'pty.c'
fi
if test -f 'putenv.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'putenv.c'\"
else
echo shar: Extracting \"'putenv.c'\" \(5413 characters\)
sed "s/^X//" >'putenv.c' <<'END_OF_FILE'
X/* Copyright (c) 1993
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X ****************************************************************
X */
X
X/*
X *  putenv  --  put value into environment
X *
X *  Usage:  i = putenv (string)
X *    int i;
X *    char  *string;
X *
X *  where string is of the form <name>=<value>.
X *  If "value" is 0, then "name" will be deleted from the environment.
X *  Putenv returns 0 normally, -1 on error (not enough core for malloc).
X *
X *  Putenv may need to add a new name into the environment, or to
X *  associate a value longer than the current value with a particular
X *  name.  So, to make life simpler, putenv() copies your entire
X *  environment into the heap (i.e. malloc()) from the stack
X *  (i.e. where it resides when your process is initiated) the first
X *  time you call it.
X *
X *  HISTORY
X *  3-Sep-91 Michael Schroeder (mlschroe). Modified to behave as
X *    as putenv.
X * 16-Aug-91 Tim MacKenzie (tym) at Monash University. Modified for
X *    use in screen (iScreen) (ignores final int parameter)
X * 14-Oct-85 Michael Mauldin (mlm) at Carnegie-Mellon University
X *      Ripped out of CMU lib for Rob-O-Matic portability
X * 20-Nov-79  Steven Shafer (sas) at Carnegie-Mellon University
X *    Created for VAX.  Too bad Bell Labs didn't provide this.  It's
X *    unfortunate that you have to copy the whole environment onto the
X *    heap, but the bookkeeping-and-not-so-much-copying approach turns
X *    out to be much hairier.  So, I decided to do the simple thing,
X *    copying the entire environment onto the heap the first time you
X *    call putenv(), then doing realloc() uniformly later on.
X */
X#include "rcs.h"
XRCS_ID("$Id: putenv.c,v 1.1.1.1 1993/06/16 23:51:15 jnweiger Exp $ FAU")
X
X#include "config.h"
X
X#if defined(NEEDPUTENV)
X
X#define EXTRASIZE 5        /* increment to add to env. size */
X
Xchar *malloc(), *realloc();
X
Xstatic int  envsize = -1;    /* current size of environment */
Xextern char **environ;        /* the global which is your env. */
X
Xstatic int  findenv();        /* look for a name in the env. */
Xstatic int  newenv();        /* copy env. from stack to heap */
Xstatic int  moreenv();        /* incr. size of env. */
X
Xint
Xunsetenv(name)
Xchar *name;
X{
X  register int i;
X  
X  if (envsize < 0)
X    {				/* first time putenv called */
X      if (newenv() < 0)		/* copy env. to heap */
X	return -1;
X    }
X  i = findenv(name);
X  if (i < 0)
X    return 0;			/* Already here */
X  
X  free(environ[i]);
X  if (envsize > 0)
X    envsize--;
X  for (; environ[i]; i++)
X    environ[i] = environ[i+1];
X  return 0;			/* Already here */
X}
X
Xint
Xputenv(string)
Xchar *string;
X{ 
X  register int  i;
X  register char *p;
X  
X  if (envsize < 0)
X    {				/* first time putenv called */
X      if (newenv() < 0)		/* copy env. to heap */
X	return -1;
X    }
X  
X  i = findenv(string);		/* look for name in environment */
X
X  if (i < 0)
X    {			/* name must be added */
X      for (i = 0; environ[i]; i++);
X      if (i >= (envsize - 1))
X	{			/* need new slot */
X	  if (moreenv() < 0)
X	    return -1;
X	}
X      p = malloc(strlen(string) + 1);
X      if (p == 0)		/* not enough core */
X	return -1;
X      environ[i + 1] = 0;	/* new end of env. */
X    }
X  else
X    {			/* name already in env. */
X      p = realloc(environ[i], strlen(string) + 1);
X      if (p == 0)
X	return -1;
X    }
X  sprintf(p, "%s", string); /* copy into env. */
X  environ[i] = p;
X  
X  return 0;
X}
X
Xstatic int
Xfindenv(name)
Xchar *name;
X{
X  register char *namechar, *envchar;
X  register int  i, found;
X  
X  found = 0;
X  for (i = 0; environ[i] && !found; i++)
X    { 
X      envchar = environ[i];
X      namechar = name;
X      while (*namechar && *namechar != '=' && (*namechar == *envchar))
X        { 
X	  namechar++;
X	  envchar++;
X        }
X      found = ((*namechar == '\0' || *namechar == '=') && *envchar == '=');
X    }
X  return found ? i - 1 : -1;
X}
X
Xstatic int
Xnewenv()
X{ 
X  register char **env, *elem;
X  register int i, esize;
X
X  for (i = 0; environ[i]; i++)
X    ;
X  esize = i + EXTRASIZE + 1;
X  env = (char **)malloc(esize * sizeof (elem));
X  if (env == 0)
X    return -1;
X
X  for (i = 0; environ[i]; i++)
X    { 
X      elem = malloc(strlen(environ[i]) + 1);
X      if (elem == 0)
X	return (-1);
X      env[i] = elem;
X      strcpy(elem, environ[i]);
X    }
X   
X  env[i] = 0;
X  environ = env;
X  envsize = esize;
X  return 0;
X}
X
Xstatic int
Xmoreenv()
X{ 
X  register int  esize;
X  register char **env;
X  
X  esize = envsize + EXTRASIZE;
X  env = (char **)realloc(environ, esize * sizeof (*env));
X  if (env == 0)
X    return -1;
X  environ = env;
X  envsize = esize;
X  return 0;
X}
X
X#endif /* NEEDPUTENV */
X
X
END_OF_FILE
if test 5413 -ne `wc -c <'putenv.c'`; then
    echo shar: \"'putenv.c'\" unpacked with wrong size!
fi
# end of 'putenv.c'
fi
if test -f 'rcs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rcs.h'\"
else
echo shar: Extracting \"'rcs.h'\" \(1516 characters\)
sed "s/^X//" >'rcs.h' <<'END_OF_FILE'
X/* Copyright (c) 1993
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X ****************************************************************
X * $Id: rcs.h,v 1.1.1.1 1993/06/16 23:51:16 jnweiger Exp $ FAU
X */
X
X/*
X * rcs.h
X *
X * jw 9.2.92
X **************************************************
X * RCS_ID("$Id: rcs.h,v 1.1.1.1 1993/06/16 23:51:16 jnweiger Exp $ FAU");
X */
X
X#ifndef __RCS_H__
X# define __RCS_H__
X
X# if !defined(lint)
X#  ifdef __GNUC__
X#   define RCS_ID(id) static char *rcs_id() { return rcs_id(id); }
X#  else
X#   define RCS_ID(id) static char *rcs_id = id;
X#  endif /* !__GNUC__ */
X# else
X#  define RCS_ID(id)      /* Nothing */
X# endif /* !lint */
X
X#endif /* __RCS_H__ */
END_OF_FILE
if test 1516 -ne `wc -c <'rcs.h'`; then
    echo shar: \"'rcs.h'\" unpacked with wrong size!
fi
# end of 'rcs.h'
fi
if test -f 'screen.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screen.h'\"
else
echo shar: Extracting \"'screen.h'\" \(6046 characters\)
sed "s/^X//" >'screen.h' <<'END_OF_FILE'
X/* Copyright (c) 1993
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X ****************************************************************
X * $Id: screen.h,v 1.8 1993/08/04 00:42:57 mlschroe Exp $ FAU
X */
X
X#include "os.h"
X
X#if defined(__STDC__)
X# ifndef __P
X#  define __P(a) a
X# endif
X#else
X# ifndef __P
X#  define __P(a) ()
X# endif
X# define const
X#endif
X
X#include "osdef.h"
X
X#include "ansi.h"
X#include "acl.h"
X#include "comm.h"
X#include "overlay.h"
X#include "term.h"
X
X
X#ifdef DEBUG
X#	define DEBUGDIR "/tmp/debug"
X#	define debug(x) {if(dfp){fprintf(dfp,x);fflush(dfp);}}
X#	define debug1(x,a) {if(dfp){fprintf(dfp,x,a);fflush(dfp);}}
X#	define debug2(x,a,b) {if(dfp){fprintf(dfp,x,a,b);fflush(dfp);}}
X#	define debug3(x,a,b,c) {if(dfp){fprintf(dfp,x,a,b,c);fflush(dfp);}}
X	extern FILE *dfp;
X#else
X#	define debug(x) {}
X#	define debug1(x,a) {}
X#	define debug2(x,a,b) {}
X#	define debug3(x,a,b,c) {}
X#endif
X
X#ifndef DEBUG
X# define NOASSERT
X#endif
X
X#ifndef NOASSERT
X# if defined(__STDC__)
X#  define ASSERT(lousy_cpp) {if (!(lousy_cpp)) {debug2("ASSERT("#lousy_cpp")ion failed file %s line %d\n", __FILE__, __LINE__);abort();}}
X# else
X#  define ASSERT(lousy_cpp) {if (!(lousy_cpp)) {debug2("ASSERT(lousy_cpp)ion failed file %s line %d\n", __FILE__, __LINE__);abort();}}
X# endif
X#else
X# define ASSERT(lousy_cpp) {;}
X#endif
X
X/* here comes my own Free: jw. */
X#define Free(a) {if ((a) == 0) abort(); else free((void *)(a)); (a)=0;}
X
X#define Ctrl(c) ((c)&037)
X
X#define MAXSTR		256
X#define MAXARGS 	64
X#define MSGWAIT 	5
X#define MSGMINWAIT 	1
X#define SILENCEWAIT	30
X
X/*
X * if a nasty user really wants to try a history of 3000 lines on all 10
X * windows, he will allocate 8 MegaBytes of memory, which is quite enough.
X */
X#define MAXHISTHEIGHT		3000
X#define DEFAULTHISTHEIGHT	100
X#define DEFAULT_BUFFERFILE	"/tmp/screen-exchange"
X
X#define	TTY_FLAG_PLAIN		0x01
X
Xstruct tty_attr
X{
X  int flags;			/* a PLAIN tty or a process behind */
X};
X
Xstruct mode
X{
X#ifdef POSIX
X  struct termios tio;
X# ifdef hpux
X  struct ltchars m_ltchars;
X# endif /* hpux */
X#else /* POSIX */
X# ifdef TERMIO
X  struct termio tio;
X# else /* TERMIO */
X  struct sgttyb m_ttyb;
X  struct tchars m_tchars;
X  struct ltchars m_ltchars;
X  int m_ldisc;
X  int m_lmode;
X# endif /* TERMIO */
X#endif /* POSIX */
X};
X
X#include "display.h"
X#include "window.h"
X
X/*
X * Parameters for the Detach() routine
X */
X#define D_DETACH	0
X#define D_STOP		1
X#define D_REMOTE	2
X#define D_POWER 	3
X#define D_REMOTE_POWER	4
X#define D_LOCK		5
X
X/*
X * Here are the messages the attacher sends to the backend
X */
X#define MSG_CREATE	0
X#define MSG_ERROR	1
X#define MSG_ATTACH	2
X#define MSG_CONT	3
X#define MSG_DETACH	4
X#define MSG_POW_DETACH	5
X#define MSG_WINCH	6
X#define MSG_HANGUP	7
X
Xstruct msg
X{
X  int type;
X  char m_tty[MAXPATHLEN];	/* ttyname */
X  union
X    {
X      struct
X	{
X	  int lflag;
X	  int aflag;
X	  int flowflag;
X	  int hheight;		/* size of scrollback buffer */
X	  int nargs;
X	  char line[MAXPATHLEN];
X	  char dir[MAXPATHLEN];
X	  char screenterm[20];	/* is screen really "screen" ? */
X	}
X      create;
X      struct
X	{
X	  char auser[20 + 1];	/* username */
X	  int apid;		/* pid of frontend */
X	  int adaptflag;	/* adapt window size? */
X	  int lines, columns;	/* display size */
X	  char password[20];
X	  char envterm[20 + 1];	/* terminal type */
X	}
X      attach;
X      struct 
X	{
X	  char duser[20 + 1];	/* username */
X	  char password[20];
X	  int dpid;		/* pid of frontend */
X	}
X      detach;
X      char message[MAXPATHLEN * 2];
X    } m;
X};
X
X/*
X * And the signals the attacher receives from the backend
X */
X#define SIG_BYE		SIGHUP
X#define SIG_POWER_BYE	SIGUSR1
X#define SIG_LOCK	SIGUSR2
X#define SIG_STOP	SIGTSTP
X#define SIG_PW_OK	SIGUSR1
X#define SIG_PW_FAIL	SIG_BYE
X
X
X#define BELL		(Ctrl('g'))
X#define VBELLWAIT	1 /* No. of seconds a vbell will be displayed */
X
X#define BELL_OFF	0 /* No bell has occurred in the window */
X#define BELL_ON 	1 /* A bell has occurred, but user not yet notified */
X#define BELL_MSG	2 /* A bell has occured, user sees a message */
X#define BELL_DONE	3 /* A bell has occured, user has been notified */
X#define BELL_VISUAL     4 /* A bell has occured in fore win, notify him visually */
X
X#define MON_OFF 	0 /* Monitoring is off in the window */
X#define MON_ON		1 /* No activity has occurred in the window */
X#define MON_FOUND	2 /* Activity has occured, but user not yet notified */
X#define MON_MSG		3 /* Activity has occured, user sees a message */
X#define MON_DONE	4 /* Activity has occured, user has been notified */
X
X#define DUMP_TERMCAP	0 /* WriteFile() options */
X#define DUMP_HARDCOPY	1
X#define DUMP_EXCHANGE	2
X
Xextern char strnomem[];
X
X
Xstruct NewWindow
X{
X  int	StartAt;	/* where to start the search for the slot */
X  char	*aka;		/* aka string */
X  char	**args;		/* argv vector */
X  char	*dir;		/* directory for chdir */
X  char	*term;		/* TERM to be set instead of "screen" */
X  int	aflag;
X  int	flowflag;
X  int	lflag;
X  int	histheight;
X  int	monitor;
X};
X
X/*
X * line modes used by Input()
X */
X#define INP_COOKED	0
X#define INP_NOECHO	1
X#define INP_RAW		2
X
X
X#ifdef MULTIUSER
Xstruct acl
X{
X  struct acl *next;
X  char *name;
X};
X#endif
X
X/* register list */
X#define MAX_PLOP_DEFS 256
Xstruct plop
X{
X  char *buf;
X  int len;
X};
X
X#define PRSTART '['
X#define PREND ']'
END_OF_FILE
if test 6046 -ne `wc -c <'screen.h'`; then
    echo shar: \"'screen.h'\" unpacked with wrong size!
fi
# end of 'screen.h'
fi
if test -f 'term.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'term.c'\"
else
echo shar: Extracting \"'term.c'\" \(4399 characters\)
sed "s/^X//" >'term.c' <<'END_OF_FILE'
X/* Copyright (c) 1993
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X ****************************************************************
X */
X
X#include "rcs.h"
XRCS_ID("$Id: term.c,v 1.1.1.1 1993/06/16 23:51:18 jnweiger Exp $ FAU")
X
X#include "term.h"
X
Xstruct term term[T_N] =
X{
X/* display size */
X  { "li", T_NUM  },
X  { "co", T_NUM  },
X
X/* terminal types*/
X  { "hc", T_FLG  },
X  { "os", T_FLG  },
X  { "ns", T_FLG  },
X/* cursor movement */
X  { "cm", T_STR  },
X  { "ho", T_STR  },
X  { "cr", T_STR  },
X  { "up", T_STR  },
X  { "UP", T_STR  },
X  { "do", T_STR  },
X  { "DO", T_STR  },
X  { "bs", T_FLG  },
X  { "bc", T_STR  },
X  { "le", T_STR  },
X  { "LE", T_STR  },
X  { "nd", T_STR  },
X  { "RI", T_STR  },
X
X/* scroll */
X  { "cs", T_STR  },
X  { "nl", T_STR  },
X  { "sf", T_STR  },
X  { "sr", T_STR  },
X  { "al", T_STR  },
X  { "AL", T_STR  },
X  { "dl", T_STR  },
X  { "DL", T_STR  },
X
X/* insert/delete */
X  { "in", T_FLG  },
X  { "im", T_STR  },
X  { "ei", T_STR  },
X  { "ic", T_STR  },
X  { "IC", T_STR  },
X  { "dc", T_STR  },
X  { "DC", T_STR  },
X
X/* erase */
X  { "cl", T_STR  },
X  { "cd", T_STR  },
X  { "ce", T_STR  },
X  { "cb", T_STR  },
X
X/* initialise */
X  { "is", T_STR  },
X  { "ti", T_STR  },
X  { "te", T_STR  },
X
X/* bell */
X  { "bl", T_STR  },
X  { "vb", T_STR  },
X
X/* resizing */
X  { "WS", T_STR  },
X  { "Z0", T_STR  },
X  { "Z1", T_STR  },
X
X/* attributes */
X/* define T_ATTR */
X  { "mh", T_STR  },
X  { "us", T_STR  },
X  { "md", T_STR  },
X  { "mr", T_STR  },
X  { "so", T_STR  },
X  { "mb", T_STR  },
X  { "ue", T_STR  },
X  { "se", T_STR  },
X  { "me", T_STR  },
X  { "ms", T_FLG  },
X  { "sg", T_FLG  },
X  { "ug", T_FLG  },
X
X/* keypad/cursorkeys */
X  { "ks", T_STR  },
X  { "ke", T_STR  },
X  { "CS", T_STR  },
X  { "CE", T_STR  },
X
X/* printer */
X  { "po", T_STR  },
X  { "pf", T_STR  },
X
X/* status line */
X  { "hs", T_FLG  },
X  { "ws", T_NUM  },
X  { "ts", T_STR  },
X  { "fs", T_STR  },
X  { "ds", T_STR  },
X
X/* cursor visibility */
X  { "vi", T_STR  },
X  { "ve", T_STR  },
X  { "vs", T_STR  },
X
X/* margin handling */
X  { "am", T_FLG  },
X  { "xv", T_FLG  },
X  { "xn", T_FLG  },
X  { "OP", T_FLG  },
X  { "LP", T_FLG  },
X
X/* special settings */
X  { "NF", T_FLG  },
X  { "xo", T_FLG  },
X  { "AN", T_FLG  },
X  { "OL", T_NUM  },
X
X/* d_font setting */
X  { "G0", T_FLG  },
X  { "S0", T_STR  },
X  { "E0", T_STR  },
X  { "C0", T_STR  },
X  { "as", T_STR  },
X  { "ae", T_STR  },
X  { "ac", T_STR  },
X  { "B8", T_STR  },
X
X/* keycaps */
X/* define T_CAPS */
X/* nolist */
X  { "km", T_FLG  },
X  { "k0", T_STR  },
X  { "k1", T_STR  },
X  { "k2", T_STR  },
X  { "k3", T_STR  },
X  { "k4", T_STR  },
X  { "k5", T_STR  },
X  { "k6", T_STR  },
X  { "k7", T_STR  },
X  { "k8", T_STR  },
X  { "k9", T_STR  },
X  { "k;", T_STR  },
X  { "kb", T_STR  },
X  { "kd", T_STR  },
X  { "kh", T_STR  },
X  { "kl", T_STR  },
X  { "ko", T_STR  },
X  { "kr", T_STR  },
X  { "ku", T_STR  },
X  { "K1", T_STR  },
X  { "K2", T_STR  },
X  { "K3", T_STR  },
X  { "K4", T_STR  },
X  { "K5", T_STR  },
X  { "l0", T_STR  },
X  { "l1", T_STR  },
X  { "l2", T_STR  },
X  { "l3", T_STR  },
X  { "l4", T_STR  },
X  { "l5", T_STR  },
X  { "l6", T_STR  },
X  { "l7", T_STR  },
X  { "l8", T_STR  },
X  { "l9", T_STR  },
X  { "la", T_STR  },
X/* more keys for Andrew A. Chernov (ache@astral.msk.su) */
X  { "kA", T_STR  },
X  { "ka", T_STR  },
X  { "kC", T_STR  },
X  { "kD", T_STR  },
X  { "kE", T_STR  },
X  { "kF", T_STR  },
X  { "kH", T_STR  },
X  { "kI", T_STR  },
X  { "kL", T_STR  },
X  { "kM", T_STR  },
X  { "kN", T_STR  },
X  { "kP", T_STR  },
X  { "kR", T_STR  },
X  { "kS", T_STR  },
X  { "kT", T_STR  },
X  { "kt", T_STR  },
X/* list */
X/* define T_ECAPS */
X/* define T_N */
X};
END_OF_FILE
if test 4399 -ne `wc -c <'term.c'`; then
    echo shar: \"'term.c'\" unpacked with wrong size!
fi
# end of 'term.c'
fi
if test -f 'term.h.dist' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'term.h.dist'\"
else
echo shar: Extracting \"'term.h.dist'\" \(2680 characters\)
sed "s/^X//" >'term.h.dist' <<'END_OF_FILE'
X/*
X * This file is automagically created from term.c -- DO NOT EDIT
X */
X
X#define T_FLG 0
X#define T_NUM 1
X#define T_STR 2
X
Xstruct term
X{
X  char *tcname;
X  int type;
X};
X
Xunion tcu
X{
X  int flg;
X  int num;
X  char *str;
X};
X
X#define LI (d_tcs[0].num)
X#define CO (d_tcs[1].num)
X#define HC (d_tcs[2].flg)
X#define OS (d_tcs[3].flg)
X#define NS (d_tcs[4].flg)
X#define CM (d_tcs[5].str)
X#define HO (d_tcs[6].str)
X#define CR (d_tcs[7].str)
X#define UP (d_tcs[8].str)
X#define CUP (d_tcs[9].str)
X#define DO (d_tcs[10].str)
X#define CDO (d_tcs[11].str)
X#define BS (d_tcs[12].flg)
X#define BC (d_tcs[13].str)
X#define LE (d_tcs[14].str)
X#define CLE (d_tcs[15].str)
X#define ND (d_tcs[16].str)
X#define CRI (d_tcs[17].str)
X#define CS (d_tcs[18].str)
X#define NL (d_tcs[19].str)
X#define SF (d_tcs[20].str)
X#define SR (d_tcs[21].str)
X#define AL (d_tcs[22].str)
X#define CAL (d_tcs[23].str)
X#define DL (d_tcs[24].str)
X#define CDL (d_tcs[25].str)
X#define IN (d_tcs[26].flg)
X#define IM (d_tcs[27].str)
X#define EI (d_tcs[28].str)
X#define IC (d_tcs[29].str)
X#define CIC (d_tcs[30].str)
X#define DC (d_tcs[31].str)
X#define CDC (d_tcs[32].str)
X#define CL (d_tcs[33].str)
X#define CD (d_tcs[34].str)
X#define CE (d_tcs[35].str)
X#define CB (d_tcs[36].str)
X#define IS (d_tcs[37].str)
X#define TI (d_tcs[38].str)
X#define TE (d_tcs[39].str)
X#define BL (d_tcs[40].str)
X#define VB (d_tcs[41].str)
X#define CWS (d_tcs[42].str)
X#define CZ0 (d_tcs[43].str)
X#define CZ1 (d_tcs[44].str)
X#define T_ATTR 45
X#define MH (d_tcs[45].str)
X#define US (d_tcs[46].str)
X#define MD (d_tcs[47].str)
X#define MR (d_tcs[48].str)
X#define SO (d_tcs[49].str)
X#define MB (d_tcs[50].str)
X#define UE (d_tcs[51].str)
X#define SE (d_tcs[52].str)
X#define ME (d_tcs[53].str)
X#define MS (d_tcs[54].flg)
X#define SG (d_tcs[55].flg)
X#define UG (d_tcs[56].flg)
X#define KS (d_tcs[57].str)
X#define KE (d_tcs[58].str)
X#define CCS (d_tcs[59].str)
X#define CCE (d_tcs[60].str)
X#define PO (d_tcs[61].str)
X#define PF (d_tcs[62].str)
X#define HS (d_tcs[63].flg)
X#define WS (d_tcs[64].num)
X#define TS (d_tcs[65].str)
X#define FS (d_tcs[66].str)
X#define DS (d_tcs[67].str)
X#define VI (d_tcs[68].str)
X#define VE (d_tcs[69].str)
X#define VS (d_tcs[70].str)
X#define AM (d_tcs[71].flg)
X#define XV (d_tcs[72].flg)
X#define XN (d_tcs[73].flg)
X#define COP (d_tcs[74].flg)
X#define CLP (d_tcs[75].flg)
X#define CNF (d_tcs[76].flg)
X#define XO (d_tcs[77].flg)
X#define CAN (d_tcs[78].flg)
X#define COL (d_tcs[79].num)
X#define CG0 (d_tcs[80].flg)
X#define CS0 (d_tcs[81].str)
X#define CE0 (d_tcs[82].str)
X#define CC0 (d_tcs[83].str)
X#define AS (d_tcs[84].str)
X#define AE (d_tcs[85].str)
X#define AC (d_tcs[86].str)
X#define CB8 (d_tcs[87].str)
X#define T_CAPS 88
X#define T_ECAPS 139
X#define T_N 139
END_OF_FILE
if test 2680 -ne `wc -c <'term.h.dist'`; then
    echo shar: \"'term.h.dist'\" unpacked with wrong size!
fi
# end of 'term.h.dist'
fi
if test -f 'term.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'term.sh'\"
else
echo shar: Extracting \"'term.sh'\" \(788 characters\)
sed "s/^X//" >'term.sh' <<'END_OF_FILE'
X#!/bin/sh
X
Xif test -z "$AWK"; then
X  AWK=awk
Xfi
Xif test -z "$srcdir"; then
X  srcdir=.
Xfi
X
Xrm -f term.h
Xcat << EOF > term.h
X/*
X * This file is automagically created from term.c -- DO NOT EDIT
X */
X
X#define T_FLG 0
X#define T_NUM 1
X#define T_STR 2
X
Xstruct term
X{
X  char *tcname;
X  int type;
X};
X
Xunion tcu
X{
X  int flg;
X  int num;
X  char *str;
X};
X
XEOF
X
Xsed < ${srcdir}/term.c \
X  -e '/"[A-Z]."/s/"/"C/' \
X  -e '/"/y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/' \
X| $AWK '
X/^  [{] ".*$/{
Xa=substr($2,2,length($2)-3);
Xb=substr($3,3,3);
Xif (nolist == 0)
X  printf "#define %s (d_tcs[%d].%s)\n",a,s,b
Xs++;
X}
X/\/* define/{
Xprintf "#define %s %d\n",$3,s
X}
X/\/* nolist/{
Xnolist = 1;
X}
X/\/* list/{
Xnolist = 0;
X}
X' | sed -e s/NUM/num/ -e s/STR/str/ -e s/FLG/flg/ \
X>> term.h
Xchmod a-w term.h
X
END_OF_FILE
if test 788 -ne `wc -c <'term.sh'`; then
    echo shar: \"'term.sh'\" unpacked with wrong size!
fi
# end of 'term.sh'
fi
if test ! -d 'terminfo' ; then
    echo shar: Creating directory \"'terminfo'\"
    mkdir 'terminfo'
fi
if test -f 'terminfo/8bits' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'terminfo/8bits'\"
else
echo shar: Extracting \"'terminfo/8bits'\" \(720 characters\)
sed "s/^X//" >'terminfo/8bits' <<'END_OF_FILE'
X
XWe test some umlauts and other characters coded in
Xthe ISO 8859-1 (Latin 1) standard:
X
Xumlaut A                            umlaut a          
Xumlaut O                            umlaut o          
Xumlaut U                            umlaut u          
Xsharp s                             paragraph         
Xe + /                               e + \             
Xe + ^                               a + \             
Xu + \                               degree            
Xlog. not                            + over -          
X<<                                  >>                
Xfraction 1/2                        fraction 1/4      
Xpower of 2                          middle dot        
X
X---
END_OF_FILE
echo shar: 22 control characters may be missing from \"'terminfo/8bits'\"
if test 720 -ne `wc -c <'terminfo/8bits'`; then
    echo shar: \"'terminfo/8bits'\" unpacked with wrong size!
fi
# end of 'terminfo/8bits'
fi
if test -f 'terminfo/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'terminfo/README'\"
else
echo shar: Extracting \"'terminfo/README'\" \(444 characters\)
sed "s/^X//" >'terminfo/README' <<'END_OF_FILE'
X
XThis directory contains various file for termcap/terminfo installation
Xand testing:
X
Xscreencap		Termcap entry for screen. Add to /etc/termcap.
X
Xscreeninfo.src		Terminfo entry. Use 'tic screeninfo.src'
X			to install (Sun: /usr/5bin/tic).
X
Xchecktc.c		Termcap/info test program. Checks margin
X			handling and other things.
X
X8bits			Some chars from the ISO 8859-1 charset.
X
Xtest.txt		Test file for alternate charset.
X
Xtetris.c		The popular game.
X
END_OF_FILE
if test 444 -ne `wc -c <'terminfo/README'`; then
    echo shar: \"'terminfo/README'\" unpacked with wrong size!
fi
# end of 'terminfo/README'
fi
if test -f 'terminfo/checktc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'terminfo/checktc.c'\"
else
echo shar: Extracting \"'terminfo/checktc.c'\" \(4448 characters\)
sed "s/^X//" >'terminfo/checktc.c' <<'END_OF_FILE'
X#include <stdio.h>
X
Xchar *CL, *CM, *CS, *SR;
Xint CO, LI, AM, XN;
X
Xchar *tgetstr(), *getenv();
Xvoid PutStr(), CPutStr(), CCPutStr(), GotoPos(), RETURN();
X
Xmain()
X{
X  char *term, *s;
X  char tcbuf[1024];
X  char tcstr[1024], *tp;
X
X  if ((term = getenv("TERM")) == 0)
X    {
X      fprintf(stderr, "No $TERM set\n");
X      exit(1);
X    }
X  switch (tgetent(tcbuf, term))
X    {
X    case -1:
X      fprintf(stderr, "Could not open termcap file\n");
X      exit(1);
X    case 0:
X      fprintf(stderr, "I don't know what a '%s' terminal is.\n", term);
X      exit(1);
X    }
X  tp = tcstr;
X  if ((CL = tgetstr("cl", &tp)) == 0)
X    {
X      fprintf(stderr, "cl capability required\n");
X      exit(1);
X    }
X  if ((CM = tgetstr("cm", &tp)) == 0)
X    {
X      fprintf(stderr, "cm capability required\n");
X      exit(1);
X    }
X  
X  if (s = getenv("COLUMNS"))
X      CO = atoi(s);
X  if (s = getenv("LINES"))
X      LI = atoi(s);
X  if (CO == 0)
X      CO = tgetnum("co");
X  if (LI == 0)
X      LI = tgetnum("li");
X  if (CO == 0)
X      CO = 80;
X  if (LI == 0)
X      LI = 24;
X  GotoPos(5, 1);
X  printf("******* cl capability does not work !!! *******");
X  GotoPos(5, 2);
X  PutStr(CL);
X  printf("******* cl capability does not home cursor *******");
X  GotoPos(0, 0);
X  printf("                                                  ");
X  GotoPos(5, 4);
X  printf("******* cm capability does not work !!! *******");
X  GotoPos(5, 4);
X  printf("                                               ");
X  GotoPos(CO/2-12, LI/2);
X  printf("Your terminal size is");
X  GotoPos(CO/2-3, LI/2+1);
X  printf("%dx%d", CO, LI);
X  GotoPos(CO/2-2, 0);
X  printf("top");
X  GotoPos(CO/2-3, LI-1);
X  printf("bottom");
X  GotoPos(0, LI/2-2);printf("l");
X  GotoPos(0, LI/2-1);printf("e");
X  GotoPos(0, LI/2+0);printf("f");
X  GotoPos(0, LI/2+1);printf("t");
X  GotoPos(CO-1, LI/2-2);printf("r");
X  GotoPos(CO-1, LI/2-1);printf("i");
X  GotoPos(CO-1, LI/2+0);printf("g");
X  GotoPos(CO-1, LI/2+1);printf("h");
X  GotoPos(CO-1, LI/2+2);printf("t");
X  GotoPos(CO/2-15, LI/2+3);
X  RETURN();
X  AM = tgetflag("am");
X  printf("Termcap: terminal does %sauto-wrap", AM ? "" : "not ");
X  GotoPos(0, 5);
X  if (AM)
X    {
X      printf(" am capability set, but terminal does not wrap");
X      GotoPos(CO-1, 3);
X    }
X  else
X    {
X      printf(" am capability not set, but terminal does wrap");
X      GotoPos(CO-1, 4);
X    }
X  printf("  \n                                                  ");
X  GotoPos(0, 10);
X  RETURN();
X  if (AM)
X    {
X      XN = tgetflag("xn");
X      printf("Termcap: terminal has %smagic margins", XN ? "" : "no ");
X      GotoPos(0, 5);
X      if (XN = tgetflag("xn"))
X	{
X	  printf(" xn capability set, but terminal has no magic-margins");
X	  GotoPos(CO-1, 4);
X	}
X      else
X	{
X	  printf(" xn capability not set, but terminal has magic-margins");
X	  GotoPos(CO-1, 3);
X	}
X      printf(" \n");
X      printf("                                                       ");
X      GotoPos(0, 10);
X      RETURN();
X      if (XN)
X        {
X          GotoPos(0, 6);
X	  printf(" last col in last row is not usable");
X          GotoPos(CO-1, LI-1);
X	  printf(" ");
X          GotoPos(0, 6);
X	  printf("                                          ");
X	  GotoPos(0, 0);
X	  printf("testing magic margins in last row");
X	  GotoPos(0, 10);
X	  RETURN();
X        }
X    }
X  if (CS = tgetstr("cs", &tp))
X    {
X      printf("Termcap: terminal has scrollregions");
X      GotoPos(0, 5);
X      printf(" cs capability set, but doesn't work");
X      CCPutStr(CS, 4, 5);
X      GotoPos(0, 5);
X      printf("\n\n");
X      CCPutStr(CS, 0, LI-1);
X      GotoPos(0, 10);
X      RETURN();
X    }
X  if (SR = tgetstr("sr", &tp))
X    {
X      GotoPos(0, 5);
X      printf(" sr capability set, but doesn't work");
X      GotoPos(0, 0);
X      PutStr(SR);
X      GotoPos(0, 6);
X      printf("                                    ");
X      GotoPos(0, 0);
X      printf("Termcap: terminal can scroll backwards");
X      GotoPos(0, 10);
X      RETURN();
X    }
X}
X
Xvoid
Xputcha(c)
Xchar c;
X{
X  putchar(c);
X}
X
Xvoid
XPutStr(s)
Xchar *s;
X{
X  tputs(s, 1, putcha);
X  fflush(stdout);
X}
X
Xvoid CPutStr(s, c)
Xchar *s;
Xint c;
X{
X  tputs(tgoto(s, 0, c), 1, putcha);
X  fflush(stdout);
X}
X
Xvoid CCPutStr(s, x, y)
Xchar *s;
Xint x, y;
X{
X  tputs(tgoto(s, y, x), 1, putcha);
X  fflush(stdout);
X}
X
Xvoid GotoPos(x,y)
Xint x,y;
X{
X  tputs(tgoto(CM, x, y), 1, putcha);
X  fflush(stdout);
X}
X
Xvoid
XRETURN()
X{
X  printf("Press <RETURN> to continue");
X  fflush(stdout);
X  while(getchar() != '\n');
X  PutStr(CL);
X}
END_OF_FILE
if test 4448 -ne `wc -c <'terminfo/checktc.c'`; then
    echo shar: \"'terminfo/checktc.c'\" unpacked with wrong size!
fi
# end of 'terminfo/checktc.c'
fi
if test -f 'terminfo/screen-sco.mail' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'terminfo/screen-sco.mail'\"
else
echo shar: Extracting \"'terminfo/screen-sco.mail'\" \(3056 characters\)
sed "s/^X//" >'terminfo/screen-sco.mail' <<'END_OF_FILE'
XFrom root%mjbtn.UUCP@uunet.UU.NET Tue Oct 22 03:09:14 1991
XReceived: from relay2.UU.NET by immd4.informatik.uni-erlangen.de  with SMTP (5.64+/7.3a-FAU)
X	id AA10018; Tue, 22 Oct 91 03:09:04 +0100
XReceived: from uunet.uu.net (via LOCALHOST.UU.NET) by relay2.UU.NET with SMTP 
X	(5.61/UUNET-internet-primary) id AA09640; Mon, 21 Oct 91 22:09:07 -0400
XReceived: from mjbtn.UUCP by uunet.uu.net with UUCP/RMAIL
X	(queueing-rmail) id 220830.17203; Mon, 21 Oct 1991 22:08:30 EDT
XReceived: by mjbtn.jobsoft.com (/\==/\ Smail3.1.21.1); Mon, 21 Oct 91 20:49 CDT
XMessage-Id: <m0kZBFd-0007XHC@mjbtn.jobsoft.com>
XFrom: root@mjbtn.jobsoft.com (Mark J. Bailey [ADMIN])
XSubject: Re: oh yes
XTo: jnweiger%immd4.informatik.uni-erlangen.de%uunet.UUCP@uunet.UU.NET (Juergen Weigert)
XDate: Mon, 21 Oct 91 20:49:49 CDT
XIn-Reply-To: <9110212148.AA01737@faui43.informatik.uni-erlangen.de>; from "Juergen Weigert" at Oct 21, 91 10:48 pm
XX-Mailer: ELM [version 2.3 PL11]
XStatus: OR
X
XHi,
X
XWell, more playing and finally some progress!  :-)
X
XThis is my .screenrc:
X
Xterminfo ansi G0:hs@:am:LP@:OP
X
XNow, I am not worried about its total accurracy, but I just wanted to show
Xyou what I tried.  I also fixed a screen-25 terminfo entry:
X
Xscreen-25|VT 100/ANSI X3.64 virtual terminal,
X	am, msgr, xon,
X	cols#80, it#8, lines#25,
X	bel=^G, blink=\E[5m, bold=\E[1m, cbt=\E[Z,
X	clear=\E[H\E[J, cr=\r, csr=\E[%i%p1%d;%p2%dr,
X	cub=\E[%p1%dD, cub1=\b, cud=\E[%p1%dB, cud1=\n,
X	cuf=\E[%p1%dC, cuf1=\E[C, cup=\E[%i%p1%d;%p2%dH,
X	cuu=\E[%p1%dA, cuu1=\EM, dl=\E[%p1%dM, dl1=\E[M,
X	ed=\E[J, el=\E[K, home=\E[H, ht=\t, hts=\EH,
X	il=\E[%p1%dL, il1=\E[L, ind=\n, is2=\E)0, kbs=\b,
X	kcub1=\EOD, kcud1=\EOB, kcuf1=\EOC, kcuu1=\EOA,
X	kf1=\EOP, kf2=\EOQ, kf3=\EOR, kf4=\EOS, khome=\E?,
X	ll=\E[25H, nel=\EE, rc=\E8, rev=\E[7m, ri=\EM,
X	rmkx=\E>, rmso=\E[23m, rmul=\E[24m, rs2=\Ec, sc=\E7,
X	sgr0=\E[m, smkx=\E=, smso=\E[3m, smul=\E[4m,
X	tbc=\E[3g,
X
XAnd notice for SCO Unix that I added 'am' to the entry for screen-25.  Even
Xthough the external (login shell) type 'ansi' was modified with the .screenrc,
Xwhen I added 'am' to the screen window term screen-25, it functioned flawlessly
Xand I am not sure why.  Anyway, vi and all the others seem to work great 
Xnow.  Next, I need to work on the G0 -> C0 graphics character mappings.  I 
Xdon't fully understand that yet.  Anyway, this should be of help to others
Xunder SCO.  BTW, that copy of the message you got from me that I sent to
XRonald Khoo -- I applied SCO SLS patch xnx141 (for xenix) to fix the bug 
Xin select() when dealing with pipes, and it solved my problems on xenix.
X
XMark.
X
X-- 
XMark J. Bailey, N4XHX                              _______/====X11====\_______
XUSMAIL: 511 Memorial Blvd., Murfreesboro, TN 37129 |         JobSoft         |
XVOICE:  +1 615 893 0098                            | Design & Development Co.|
XUUCP:   ...!uunet!mjbtn!mjb, ...!raider!mjbtn!mjb  |  Murfreesboro, TN  USA  |
XDOMAIN: mjb@mjbtn.JOBSOFT.COM      CIS: 76314,160  ---------------------------
X<KA9Q-UNIX-USERS Mailing List-Subscribe: ka9q-unix-requests@mjbtn.jobsoft.com>
X
END_OF_FILE
if test 3056 -ne `wc -c <'terminfo/screen-sco.mail'`; then
    echo shar: \"'terminfo/screen-sco.mail'\" unpacked with wrong size!
fi
# end of 'terminfo/screen-sco.mail'
fi
if test -f 'terminfo/screencap' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'terminfo/screencap'\"
else
echo shar: Extracting \"'terminfo/screencap'\" \(685 characters\)
sed "s/^X//" >'terminfo/screencap' <<'END_OF_FILE'
XSC|screen|VT 100/ANSI X3.64 virtual terminal:\
X	:DO=\E[%dB:LE=\E[%dD:RI=\E[%dC:UP=\E[%dA:bs:bt=\E[Z:\
X	:cd=\E[J:ce=\E[K:cl=\E[H\E[J:cm=\E[%i%d;%dH:ct=\E[3g:\
X	:do=^J:nd=\E[C:pt:rc=\E8:rs=\Ec:sc=\E7:st=\EH:up=\EM:\
X	:le=^H:bl=^G:cr=^M:it#8:ho=\E[H:nw=\EE:ta=^I:is=\E)0:xv:\
X	:li#24:co#80:LP:us=\E[4m:ue=\E[24m:so=\E[3m:se=\E[23m:\
X	:mb=\E[5m:md=\E[1m:mr=\E[7m:me=\E[m:ms:sr=\EM:al=\E[L:\
X	:AL=\E[%dL:dl=\E[M:DL=\E[%dM:cs=\E[%i%d;%dr:dc=\E[P:\
X	:DC=\E[%dP:im=\E[4h:ei=\E[4l:mi:IC=\E[%d@:\
X	:ks=\E=:ke=\E>:G0:\
X        :ku=\EOA:kd=\EOB:kr=\EOC:kl=\EOD:kb=^H:km:\
X        :k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:
XSW|screen-w|VT 100/ANSI X3.64 virtual terminal with 132 cols:\
X	:co#132:tc=screen:
END_OF_FILE
if test 685 -ne `wc -c <'terminfo/screencap'`; then
    echo shar: \"'terminfo/screencap'\" unpacked with wrong size!
fi
# end of 'terminfo/screencap'
fi
if test -f 'terminfo/screeninfo.src' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'terminfo/screeninfo.src'\"
else
echo shar: Extracting \"'terminfo/screeninfo.src'\" \(1492 characters\)
sed "s/^X//" >'terminfo/screeninfo.src' <<'END_OF_FILE'
Xscreen|VT 100/ANSI X3.64 virtual terminal,
X	mir, msgr, xon, km,
X	cols#80, it#8, lines#24,
X	bel=^G, blink=\E[5m, bold=\E[1m, cbt=\E[Z,
X	clear=\E[H\E[J, cr=\r, csr=\E[%i%p1%d;%p2%dr,
X	cub=\E[%p1%dD, cub1=\b, cud=\E[%p1%dB, cud1=\n,
X	cuf=\E[%p1%dC, cuf1=\E[C, cup=\E[%i%p1%d;%p2%dH,
X	cuu=\E[%p1%dA, cuu1=\EM, dch=\E[%p1%dP, dch1=\E[P,
X	dl=\E[%p1%dM, dl1=\E[M, ed=\E[J, el=\E[K, home=\E[H,
X	ht=\t, hts=\EH, ich=\E[%p1%d@,
X	il=\E[%p1%dL, il1=\E[L, ind=\n, is2=\E)0, kbs=\b,
X	kcub1=\EOD, kcud1=\EOB, kcuf1=\EOC, kcuu1=\EOA,
X	kf1=\EOP, kf2=\EOQ, kf3=\EOR, kf4=\EOS, nel=\EE,
X	rc=\E8, rev=\E[7m, ri=\EM, rmir=\E[4l, rmkx=\E>,
X	rmso=\E[23m, rmul=\E[24m, rs2=\Ec, sc=\E7, sgr0=\E[m,
X	smir=\E[4h, smkx=\E=, smso=\E[3m, smul=\E[4m,
X	tbc=\E[3g,
Xscreen-w|VT 100/ANSI X3.64 virtual terminal with 132 cols,
X	mir, msgr, xon, km,
X	cols#132, it#8, lines#24,
X	bel=^G, blink=\E[5m, bold=\E[1m, cbt=\E[Z,
X	clear=\E[H\E[J, cr=\r, csr=\E[%i%p1%d;%p2%dr,
X	cub=\E[%p1%dD, cub1=\b, cud=\E[%p1%dB, cud1=\n,
X	cuf=\E[%p1%dC, cuf1=\E[C, cup=\E[%i%p1%d;%p2%dH,
X	cuu=\E[%p1%dA, cuu1=\EM, dch=\E[%p1%dP, dch1=\E[P,
X	dl=\E[%p1%dM, dl1=\E[M, ed=\E[J, el=\E[K, home=\E[H,
X	ht=\t, hts=\EH, ich=\E[%p1%d@, ich1=\E[@,
X	il=\E[%p1%dL, il1=\E[L, ind=\n, is2=\E)0, kbs=\b,
X	kcub1=\EOD, kcud1=\EOB, kcuf1=\EOC, kcuu1=\EOA,
X	kf1=\EOP, kf2=\EOQ, kf3=\EOR, kf4=\EOS, nel=\EE,
X	rc=\E8, rev=\E[7m, ri=\EM, rmir=\E[4l, rmkx=\E>,
X	rmso=\E[23m, rmul=\E[24m, rs2=\Ec, sc=\E7, sgr0=\E[m,
X	smir=\E[4h, smkx=\E=, smso=\E[3m, smul=\E[4m,
X	tbc=\E[3g,
END_OF_FILE
if test 1492 -ne `wc -c <'terminfo/screeninfo.src'`; then
    echo shar: \"'terminfo/screeninfo.src'\" unpacked with wrong size!
fi
# end of 'terminfo/screeninfo.src'
fi
if test -f 'terminfo/tetris.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'terminfo/tetris.c'\"
else
echo shar: Extracting \"'terminfo/tetris.c'\" \(1468 characters\)
sed "s/^X//" >'terminfo/tetris.c' <<'END_OF_FILE'
Xlong h[4];t(){h[3]-=h[3]/3000;setitimer(0,h,0);}c,d,l,v[]={(int)t,0,2},w,s,I,K
X=0,i=276,j,k,q[276],Q[276],*n=q,*m,x=17,f[]={7,-13,-12,1,8,-11,-12,-1,9,-1,1,
X12,3,-13,-12,-1,12,-1,11,1,15,-1,13,1,18,-1,1,2,0,-12,-1,11,1,-12,1,13,10,-12,
X1,12,11,-12,-1,1,2,-12,-1,12,13,-12,12,13,14,-11,-1,1,4,-13,-12,12,16,-11,-12,
X12,17,-13,1,-1,5,-12,12,11,6,-12,12,24};u(){for(i=11;++i<264;)if((k=q[i])-Q[i]
X){Q[i]=k;if(i-++I||i%12<1)printf("\033[%d;%dH",(I=i)/12,i%12*2+28);printf(
X"\033[%dm  "+(K-k?0:5),k);K=k;}Q[263]=c=getchar();}G(b){for(i=4;i--;)if(q[i?b+
Xn[i]:b])return 0;return 1;}g(b){for(i=4;i--;q[i?x+n[i]:x]=b);}main(C,V,a)char*
X*V,*a;{h[3]=1000000/(l=C>1?atoi(V[1]):2);for(a=C>2?V[2]:"jkl pq";i;i--)*n++=i<
X25||i%12<2?7:0;srand(getpid());system("stty cbreak -echo stop u");sigvec(14,v,
X0);t();puts("\033[H\033[J");for(n=f+rand()%7*4;;g(7),u(),g(0)){if(c<0){if(G(x+
X12))x+=12;else{g(7);++w;for(j=0;j<252;j=12*(j/12+1))for(;q[++j];)if(j%12==10){
Xfor(;j%12;q[j--]=0);u();for(;--j;q[j+12]=q[j]);u();}n=f+rand()%7*4;G(x=17)||(c
X=a[5]);}}if(c==*a)G(--x)||++x;if(c==a[1])n=f+4**(m=n),G(x)||(n=m);if(c==a[2])G
X(++x)||--x;if(c==a[3])for(;G(x+12);++w)x+=12;if(c==a[4]||c==a[5]){s=sigblock(
X8192);printf("\033[H\033[J\033[0m%d\n",w);if(c==a[5])break;for(j=264;j--;Q[j]=
X0);while(getchar()-a[4]);puts("\033[H\033[J\033[7m");sigsetmask(s);}}d=popen(
X"stty -cbreak echo stop \023;sort -mnr -o HI - HI;cat HI","w");fprintf(d,
X"%4d from level %1d by %s\n",w,l,getlogin());pclose(d);}
X
END_OF_FILE
if test 1468 -ne `wc -c <'terminfo/tetris.c'`; then
    echo shar: \"'terminfo/tetris.c'\" unpacked with wrong size!
fi
# end of 'terminfo/tetris.c'
fi
if test -f 'window.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'window.h'\"
else
echo shar: Extracting \"'window.h'\" \(6792 characters\)
sed "s/^X//" >'window.h' <<'END_OF_FILE'
X/* Copyright (c) 1993
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X ****************************************************************
X * $Id: window.h,v 1.9 1993/08/05 14:24:19 mlschroe Exp $ FAU
X */
X
X#ifndef MAXWIN
X# define MAXWIN	10
X#endif
X
Xstruct win;
X
X#ifdef PSEUDOS
X
Xstruct pseudowin
X{
X  int fdpat;
X  int p_pid;
X  int p_ptyfd;
X  char p_cmd[MAXSTR];
X  char p_tty[MAXSTR];
X  char p_inbuf[IOSIZE];		/* buffered writing to p_ptyfd */
X  int p_inlen;
X};
X
X/* bits for fdpat: */
X#define F_PMASK 	0x0003
X#define F_PSHIFT	2
X#define F_PFRONT	0x0001			/* . */
X#define F_PBACK 	0x0002			/* ! */
X#define F_PBOTH 	(F_PFRONT | F_PBACK)	/* : */
X
X#define F_UWP		0x1000			/* | */
X
X/* The screen process ...)
X * ... wants to write to pseudo */
X#define W_WP(w) ((w)->w_pwin && ((w)->w_pwin->fdpat & F_PFRONT))
X
X/* ... wants to write to window: user writes to window 
X * or stdout/stderr of pseudo are duplicated to window */
X#define W_WW(w) (!((w)->w_pwin) || \
X(((w)->w_pwin->fdpat & F_PMASK) == F_PBACK) || \
X((((w)->w_pwin->fdpat >> F_PSHIFT) & F_PMASK) == F_PBOTH) || \
X((((w)->w_pwin->fdpat >> (F_PSHIFT * 2)) & F_PMASK) == F_PBOTH))
X
X/* ... wants to read from pseudowin */
X#define W_RP(w) ((w)->w_pwin && ((w)->w_pwin->fdpat & \
X((F_PFRONT << (F_PSHIFT * 2)) | (F_PFRONT << F_PSHIFT)) ))
X
X/* ... wants to read from window */
X#define W_RW(w) (!((w)->w_pwin) || ((w)->w_pwin->fdpat & F_PFRONT))
X
X/* user input is written to pseudo */
X#define W_UWP(w) ((w)->w_pwin && ((w)->w_pwin->fdpat & F_UWP))
X
X/* pseudo output has to be stuffed in window */
X#define W_PTOW(w) (\
X((w)->w_pwin->fdpat & F_PMASK << F_PSHIFT) == F_PBOTH << F_PSHIFT || \
X((w)->w_pwin->fdpat & F_PMASK << F_PSHIFT * 2) == F_PBOTH << F_PSHIFT * 2 )
X
X/* window output has to be stuffed in pseudo */
X#define W_WTOP(w) (((w)->w_pwin->fdpat & F_PMASK) == F_PBOTH)
X
X#endif /* PSEUDOS */
X
X
Xstruct win 
X{
X  struct win *w_next;		/* next window */
X#ifdef PSEUDOS
X  struct pseudowin *w_pwin;	/* ptr to pseudo */
X#endif
X  struct display *w_display;	/* pointer to our display */
X  int	 w_number;		/* window number */
X  int	 w_active;		/* is window fore ? */
X  struct layer *w_lay;		/* the layer of the window */
X  struct layer w_winlay;	/* the layer of the window */
X  int	 w_pid;			/* process at the other end of ptyfd */	
X  int	 w_ptyfd;		/* fd of the master pty */
X  int	 w_aflag;		/* (used for DUMP_TERMCAP) */
X  char	 w_inbuf[IOSIZE];
X  int	 w_inlen;
X  char	 w_outbuf[IOSIZE];
X  int	 w_outlen;
X  char  *w_title;		/* name of the window */
X  char  *w_akachange;		/* autoaka hack */
X  int	 w_autoaka;		/* autoaka hack */
X  char	 w_akabuf[MAXSTR];	/* aka buffer */
X  char	 w_tty[MAXSTR];
X  struct tty_attr w_t;
X  int	 w_intermediate;	/* char used while parsing ESC-seq */
X  int	 w_args[MAXARGS];
X  int	 w_NumArgs;
X  slot_t w_slot;		/* utmp slot */
X#if defined (UTMPOK)
X  struct utmp w_savut;		/* utmp entry of this window */
X#endif
X  char **w_image;
X  char **w_attr;
X  char **w_font;
X  int	 w_x, w_y;		/* Cursor position */
X  int	 w_width, w_height;	/* window size */
X  char	 w_Attr;		/* character attributes */
X  char	 w_Font;		/* character font */
X  int	 w_Charset;		/* charset number */
X  int	 w_charsets[4];		/* Font = charsets[Charset] */
X  int	 w_ss;		
X  int	 w_saved;
X  int	 w_Saved_x, w_Saved_y;
X  char	 w_SavedAttr;
X  int	 w_SavedCharset;
X  int	 w_SavedCharsets[4];
X  int	 w_top, w_bot;		/* scrollregion */
X  int	 w_wrap;		/* autowrap */
X  int	 w_origin;		/* origin mode */
X  int	 w_insert;		/* window is in insert mode */
X  int	 w_keypad;		/* keypad mode */
X  int	 w_cursorkeys;		/* appl. cursorkeys mode */
X#ifdef COPY_PASTE
X  char	*w_pastebuf;		/* this gets pasted in the window */
X  char	*w_pasteptr;		/* pointer in pastebuf */
X  int	 w_pastelen;		/* bytes left to paste */
X  int	 w_histheight;		/* all histbases are malloced with width * histheight */
X  int	 w_histidx;		/* 0 <= histidx < histheight; where we insert lines */
X  char **w_ihist; 		/* the history buffer image */
X  char **w_ahist; 		/* attributes */
X  char **w_fhist; 		/* fonts */
X#endif
X  enum state_t w_state;		/* parser state */
X  enum string_t w_StringType;
X  char	 w_string[MAXSTR];
X  char	*w_stringp;
X  char	*w_tabs;		/* line with tabs */
X  int	 w_bell;		/* bell status of this window */
X  int	 w_flow;		/* flow flags */
X  FILE	*w_logfp;		/* log to file */
X  int	 w_monitor;		/* monitor status */
X  struct lastio_s
X    {
X      time_t lastio;		/* timestamp of last filedescriptor activity */
X      int seconds;		/* tell us when lastio + seconds < time() */
X    } w_tstamp;
X  int    w_dupto;		/* duplicate the output to this window */
X  char	 w_vbwait;            
X  char	 w_cursor_invisible;
X  char	 w_norefresh;		/* dont redisplay when switching to that win */
X  char   w_wlock;		/* WLOCK_AUTO, WLOCK_OFF, WLOCK_ON */
X  struct user *w_wlockuser;	/* NULL when unlocked or user who writes */
X#ifdef MULTIUSER
X  AclBits w_userbits[ACL_BITS_PER_WIN];
X#endif
X};
X
X/* definitions for wlocktype */
X#define WLOCK_OFF	0	/* all who are in w_userbits can write */
X#define WLOCK_AUTO	1	/* who selects first, can write */
X#define WLOCK_ON	2	/* w_wlockuser writes even if deselected */
X
X/*
X * Definitions for flow
X *   000  -(-)
X *   001  +(-)
X *   010  -(+)
X *   011  +(+)
X *   100  -(a)
X *   111  +(a)
X */
X#define FLOW_NOW	(1<<0)
X#define FLOW_AUTO	(1<<1)
X#define FLOW_AUTOFLAG	(1<<2)
X
X
X/*
X * iWIN gives us a reference to line y of the *whole* image
X * where line 0 is the oldest line in our history.
X * y must be in WIN coordinate system, not in display.
X */
X#define iWIN(y) ((y < fore->w_histheight) ? fore->w_ihist[(fore->w_histidx + y)\
X                % fore->w_histheight] : fore->w_image[y - fore->w_histheight])
X#define aWIN(y) ((y < fore->w_histheight) ? fore->w_ahist[(fore->w_histidx + y)\
X                % fore->w_histheight] : fore->w_attr[y - fore->w_histheight])
X#define fWIN(y) ((y < fore->w_histheight) ? fore->w_fhist[(fore->w_histidx + y)\
X                % fore->w_histheight] : fore->w_font[y - fore->w_histheight])
X
END_OF_FILE
if test 6792 -ne `wc -c <'window.h'`; then
    echo shar: \"'window.h'\" unpacked with wrong size!
fi
# end of 'window.h'
fi
echo shar: End of archive 1 \(of 10\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 10 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
