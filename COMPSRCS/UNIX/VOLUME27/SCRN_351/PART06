Newsgroups: comp.sources.unix
From: screen@uni-erlangen.de (Juergen & Michael)
Subject: v27i019: screen-3.5.1 - full-screen window manager/multiplexor, Part06/10
References: <1.744844979.5722@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: screen@uni-erlangen.de (Juergen & Michael)
Posting-Number: Volume 27, Issue 19
Archive-Name: screen-3.5.1/part06

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 10)."
# Contents:  configure screen.c
# Wrapped by vixie@gw.home.vix.com on Sun Aug  8 14:19:06 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'configure' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'configure'\"
else
echo shar: Extracting \"'configure'\" \(53616 characters\)
sed "s/^X//" >'configure' <<'END_OF_FILE'
X#!/bin/sh
X# Guess values for system-dependent variables and create Makefiles.
X# Generated automatically using autoconf.
X# Copyright (C) 1991, 1992, 1993 Free Software Foundation, Inc.
X
X# This program is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation; either version 2, or (at your option)
X# any later version.
X
X# This program is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X
X# You should have received a copy of the GNU General Public License
X# along with this program; if not, write to the Free Software
X# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
X# Usage: configure [--srcdir=DIR] [--host=HOST] [--gas] [--nfp] [--no-create]
X#        [--prefix=PREFIX] [--exec-prefix=PREFIX] [--with-PACKAGE] [TARGET]
X# Ignores all args except --srcdir, --prefix, --exec-prefix, --no-create, and
X# --with-PACKAGE unless this script has special code to handle it.
X
X
Xfor arg
Xdo
X  # Handle --exec-prefix with a space before the argument.
X  if test x$next_exec_prefix = xyes; then exec_prefix=$arg; next_exec_prefix=
X  # Handle --host with a space before the argument.
X  elif test x$next_host = xyes; then next_host=
X  # Handle --prefix with a space before the argument.
X  elif test x$next_prefix = xyes; then prefix=$arg; next_prefix=
X  # Handle --srcdir with a space before the argument.
X  elif test x$next_srcdir = xyes; then srcdir=$arg; next_srcdir=
X  else
X    case $arg in
X     # For backward compatibility, also recognize exact --exec_prefix.
X     -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* | --exec=* | --exe=* | --ex=* | --e=*)
X	exec_prefix=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- | --exec | --exe | --ex | --e)
X	next_exec_prefix=yes ;;
X
X     -gas | --gas | --ga | --g) ;;
X
X     -host=* | --host=* | --hos=* | --ho=* | --h=*) ;;
X     -host | --host | --hos | --ho | --h)
X	next_host=yes ;;
X
X     -nfp | --nfp | --nf) ;;
X
X     -no-create | --no-create | --no-creat | --no-crea | --no-cre | --no-cr | --no-c | --no- | --no)
X        no_create=1 ;;
X
X     -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
X	prefix=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
X	next_prefix=yes ;;
X
X     -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=* | --s=*)
X	srcdir=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -srcdir | --srcdir | --srcdi | --srcd | --src | --sr | --s)
X	next_srcdir=yes ;;
X
X     -with-* | --with-*)
X       package=`echo $arg|sed 's/-*with-//'`
X       # Delete all the valid chars; see if any are left.
X       if test -n "`echo $package|sed 's/[-a-zA-Z0-9_]*//g'`"; then
X         echo "configure: $package: invalid package name" >&2; exit 1
X       fi
X       eval "with_`echo $package|sed s/-/_/g`=1" ;;
X
X     -v | -verbose | --verbose | --verbos | --verbo | --verb | --ver | --ve | --v)
X       verbose=yes ;;
X
X     *) ;;
X    esac
X  fi
Xdone
X
Xtrap 'rm -fr conftest* core; exit 1' 1 3 15
X
X# NLS nuisances.
X# These must not be set unconditionally because not all systems understand
X# e.g. LANG=C (notably SCO).
Xif test "${LC_ALL+set}" = 'set' ; then LC_ALL=C; export LC_ALL; fi
Xif test "${LANG+set}"   = 'set' ; then LANG=C;   export LANG;   fi
X
Xrm -f conftest*
Xcompile='${CC-cc} $CFLAGS $DEFS conftest.c -o conftest $LIBS >/dev/null 2>&1'
X
X# A filename unique to this package, relative to the directory that
X# configure is in, which we can look for to find out if srcdir is correct.
Xunique_file=screen.c
X
X# Find the source files, if location was not specified.
Xif test -z "$srcdir"; then
X  srcdirdefaulted=yes
X  # Try the directory containing this script, then `..'.
X  prog=$0
X  confdir=`echo $prog|sed 's%/[^/][^/]*$%%'`
X  test "X$confdir" = "X$prog" && confdir=.
X  srcdir=$confdir
X  if test ! -r $srcdir/$unique_file; then
X    srcdir=..
X  fi
Xfi
Xif test ! -r $srcdir/$unique_file; then
X  if test x$srcdirdefaulted = xyes; then
X    echo "configure: Can not find sources in \`${confdir}' or \`..'." 1>&2
X  else
X    echo "configure: Can not find sources in \`${srcdir}'." 1>&2
X  fi
X  exit 1
Xfi
X# Preserve a srcdir of `.' to avoid automounter screwups with pwd.
X# But we can't avoid them for `..', to make subdirectories work.
Xcase $srcdir in
X  .|/*|~*) ;;
X  *) srcdir=`cd $srcdir; pwd` ;; # Make relative path absolute.
Xesac
X
X# Save the original args to write them into config.status later.
Xconfigure_args="$*"
X
X
X
X
Xrev=`sed < ${srcdir}/patchlevel.h -n -e '/#define REV/s/#define REV  *//p'`
Xvers=`sed < ${srcdir}/patchlevel.h -n -e '/#define VERS/s/#define VERS  *//p'`
Xpat=`sed < ${srcdir}/patchlevel.h -n -e '/#define PATCHLEVEL/s/#define PATCHLEVEL  *//p'`
XVERSION="$rev.$vers.$pat"
Xecho "this is screen version $VERSION"
X
X
Xif test -z "$CC"; then
X  # Extract the first word of `gcc', so it can be a program name with args.
X  set dummy gcc; word=$2
X  echo checking for $word
X  IFS="${IFS= 	}"; saveifs="$IFS"; IFS="${IFS}:"
X  for dir in $PATH; do
X    test -z "$dir" && dir=.
X    if test -f $dir/$word; then
X      CC="gcc"
X      break
X    fi
X  done
X  IFS="$saveifs"
Xfi
Xtest -z "$CC" && CC="cc"
Xtest -n "$CC" -a -n "$verbose" && echo "	setting CC to $CC"
X
X# Find out if we are using GNU C, under whatever name.
Xcat > conftest.c <<EOF
X#ifdef __GNUC__
X  yes
X#endif
XEOF
X${CC-cc} -E conftest.c > conftest.out 2>&1
Xif egrep yes conftest.out >/dev/null 2>&1; then
X  GCC=1 # For later tests.
Xfi
Xrm -f conftest*
X
Xecho checking how to run the C preprocessor
Xif test -z "$CPP"; then
X  # This must be in double quotes, not single quotes, because CPP may get
X  # substituted into the Makefile and ``${CC-cc}'' will simply confuse
X  # make.  It must be expanded now.
X  CPP="${CC-cc} -E"
X  cat > conftest.c <<EOF
X#include <stdio.h>
XSyntax Error
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  :
Xelse
X  CPP=/lib/cpp
Xfi
Xrm -f conftest*
Xfi
Xtest ".${verbose}" != "." && echo "	setting CPP to $CPP"
X
Xif test -n "$GCC"; then
X  echo checking whether -traditional is needed
X  pattern="Autoconf.*'x'"
X  prog='#include <sgtty.h>
XAutoconf TIOCGETP'
X  cat > conftest.c <<EOF
X$prog
XEOF
Xeval "$CPP \$DEFS conftest.c > conftest.out 2>&1"
Xif egrep "$pattern" conftest.out >/dev/null 2>&1; then
X  need_trad=1
Xfi
Xrm -f conftest*
X
X
X  if test -z "$need_trad"; then
X    prog='#include <termio.h>
XAutoconf TCGETA'
X    cat > conftest.c <<EOF
X$prog
XEOF
Xeval "$CPP \$DEFS conftest.c > conftest.out 2>&1"
Xif egrep "$pattern" conftest.out >/dev/null 2>&1; then
X  need_trad=1
Xfi
Xrm -f conftest*
X
X  fi
X  test -n "$need_trad" && CC="$CC -traditional"
Xfi
X
Xecho checking for POSIXized ISC
Xif test -d /etc/conf/kconfig.d &&
X  grep _POSIX_VERSION /usr/include/sys/unistd.h >/dev/null 2>&1
Xthen
X  ISC=1 # If later tests want to check for ISC.
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining _POSIX_SOURCE"
XDEFS="$DEFS -D_POSIX_SOURCE=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}_POSIX_SOURCE\${SEDdB}_POSIX_SOURCE\${SEDdC}1\${SEDdD}
X\${SEDuA}_POSIX_SOURCE\${SEDuB}_POSIX_SOURCE\${SEDuC}1\${SEDuD}
X\${SEDeA}_POSIX_SOURCE\${SEDeB}_POSIX_SOURCE\${SEDeC}1\${SEDeD}
X"
X}
X
X  if test -n "$GCC"; then
X    CC="$CC -posix"
X  else
X    CC="$CC -Xp"
X  fi
Xfi
X
X
X
Xcat > conftest.c <<EOF
Xmain(){exit(0);}
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  :
Xelse
X  echo "Can't run the compiler - sorry";exit
Xfi
Xrm -f conftest*
Xfor p in mawk gawk nawk awk
Xdo
Xif test -z "$AWK"; then
X  # Extract the first word of `$p', so it can be a program name with args.
X  set dummy $p; word=$2
X  echo checking for $word
X  IFS="${IFS= 	}"; saveifs="$IFS"; IFS="${IFS}:"
X  for dir in $PATH; do
X    test -z "$dir" && dir=.
X    if test -f $dir/$word; then
X      AWK="$p"
X      break
X    fi
X  done
X  IFS="$saveifs"
Xfi
X
Xtest -n "$AWK" -a -n "$verbose" && echo "	setting AWK to $AWK"
X
Xtest -n "$AWK" && break
Xdone
X
X
X# Make sure to not get the incompatible SysV /etc/install and
X# /usr/sbin/install, which might be in PATH before a BSD-like install,
X# or the SunOS /usr/etc/install directory, or the AIX /bin/install,
X# or the AFS install, which mishandles nonexistent args, or
X# /usr/ucb/install on SVR4, which tries to use the nonexistent group
X# `staff'.  On most BSDish systems install is in /usr/bin, not /usr/ucb
X# anyway.  Sigh.
Xif test "z${INSTALL}" = "z" ; then
X  echo checking for install
X  IFS="${IFS= 	}"; saveifs="$IFS"; IFS="${IFS}:"
X  for dir in $PATH; do
X    test -z "$dir" && dir=.
X    case $dir in
X    /etc|/usr/sbin|/usr/etc|/usr/afsws/bin|/usr/ucb) ;;
X    *)
X      if test -f $dir/installbsd; then
X	INSTALL="$dir/installbsd -c" # OSF1
X	INSTALL_PROGRAM='$(INSTALL)'
X	INSTALL_DATA='$(INSTALL) -m 644'
X	break
X      fi
X      if test -f $dir/install; then
X	if grep dspmsg $dir/install >/dev/null 2>&1; then
X	  : # AIX
X	else
X	  INSTALL="$dir/install -c"
X	  INSTALL_PROGRAM='$(INSTALL)'
X	  INSTALL_DATA='$(INSTALL) -m 644'
X	  break
X	fi
X      fi
X      ;;
X    esac
X  done
X  IFS="$saveifs"
Xfi
XINSTALL=${INSTALL-cp}
XINSTALL_PROGRAM=${INSTALL_PROGRAM-'$(INSTALL)'}
XINSTALL_DATA=${INSTALL_DATA-'$(INSTALL)'}
X
X
Xif test -n "$ISC"; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining ISC"
XDEFS="$DEFS -DISC=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}ISC\${SEDdB}ISC\${SEDdC}1\${SEDdD}
X\${SEDuA}ISC\${SEDuB}ISC\${SEDuC}1\${SEDuD}
X\${SEDeA}ISC\${SEDeB}ISC\${SEDeC}1\${SEDeD}
X"
X}
X LIBS="$LIBS -linet"
Xfi
X
Xecho checking for OSF1
Xif test -f /bin/uname ; then
Xif test `/bin/uname` = OSF1 || test -f /osf_boot; then
X
X{
Xtest -n "$verbose" && \
Xecho "	defining OSF1"
XDEFS="$DEFS -DOSF1=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}OSF1\${SEDdB}OSF1\${SEDdC}1\${SEDdD}
X\${SEDuA}OSF1\${SEDuB}OSF1\${SEDuC}1\${SEDuD}
X\${SEDeA}OSF1\${SEDeB}OSF1\${SEDeC}1\${SEDeD}
X"
X}
X	# this disables MIPS again....
Xfi
Xfi
X
Xecho checking for MIPS
Xif test -f /lib/libmld.a || test -f /usr/lib/libmld.a || test -f /usr/lib/cmplrs/cc/libmld.a; then
XLIBS="$LIBS -lmld" # for nlist.
Xif test -c /dev/ptc; then
X
X{
Xtest -n "$verbose" && \
Xecho "	defining MIPS"
XDEFS="$DEFS -DMIPS=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}MIPS\${SEDdB}MIPS\${SEDdC}1\${SEDdD}
X\${SEDuA}MIPS\${SEDuB}MIPS\${SEDuC}1\${SEDuD}
X\${SEDeA}MIPS\${SEDeB}MIPS\${SEDeC}1\${SEDeD}
X"
X}
X
Xecho checking for wait3
Xcat > conftest.c <<EOF
X
Xint main() { exit(0); }
Xint t() { wait3(); }
XEOF
Xif eval $compile; then
X  :
Xelse
X  echo checking for wait2
Xcat > conftest.c <<EOF
X
Xint main() { exit(0); }
Xint t() { wait2(); }
XEOF
Xif eval $compile; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining USE_WAIT2"
XDEFS="$DEFS -DUSE_WAIT2=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}USE_WAIT2\${SEDdB}USE_WAIT2\${SEDdC}1\${SEDdD}
X\${SEDuA}USE_WAIT2\${SEDuB}USE_WAIT2\${SEDuC}1\${SEDuD}
X\${SEDeA}USE_WAIT2\${SEDeB}USE_WAIT2\${SEDeC}1\${SEDeD}
X"
X}
X LIBS="$LIBS -lbsd" ; CC="$CC -I/usr/include/bsd"
X
Xfi
Xrm -f conftest*
X
Xfi
Xrm -f conftest*
X
Xfi
Xfi
X
Xecho checking for Ultrix
Xcat > conftest.c <<EOF
X#if defined(ultrix) || defined(__ultrix)
X  yes
X#endif
X
XEOF
Xeval "$CPP \$DEFS conftest.c > conftest.out 2>&1"
Xif egrep "yes" conftest.out >/dev/null 2>&1; then
X  ULTRIX=1
Xfi
Xrm -f conftest*
X
X
Xecho checking for butterfly
Xcat > conftest.c <<EOF
X#if defined(butterfly)
X  yes
X#endif
X
XEOF
Xeval "$CPP \$DEFS conftest.c > conftest.out 2>&1"
Xif egrep "yes" conftest.out >/dev/null 2>&1; then
X  butterfly=1
Xfi
Xrm -f conftest*
X
X
Xif test -z "$butterfly"; then
Xif test -n "$ULTRIX"; then
X  test -z "$GCC" && CC="$CC -YBSD"
Xfi
Xecho checking for POSIX.1
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <unistd.h>
Xmain () {
X#ifdef _POSIX_VERSION
X  yes
X#endif
X
XEOF
Xeval "$CPP \$DEFS conftest.c > conftest.out 2>&1"
Xif egrep "yes" conftest.out >/dev/null 2>&1; then
X  echo "- you have a POSIX system";
X{
Xtest -n "$verbose" && \
Xecho "	defining POSIX"
XDEFS="$DEFS -DPOSIX=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}POSIX\${SEDdB}POSIX\${SEDdC}1\${SEDdD}
X\${SEDuA}POSIX\${SEDuB}POSIX\${SEDuC}1\${SEDuD}
X\${SEDeA}POSIX\${SEDeB}POSIX\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
Xfi
X
Xecho checking for System V
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <signal.h>
X#include <fcntl.h>
Xint main() { exit(0); }
Xint t() { int x = SIGCHLD | FNDELAY; }
XEOF
Xif eval $compile; then
X  :
Xelse
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining SYSV"
XDEFS="$DEFS -DSYSV=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SYSV\${SEDdB}SYSV\${SEDdC}1\${SEDdD}
X\${SEDuA}SYSV\${SEDuB}SYSV\${SEDuC}1\${SEDuD}
X\${SEDeA}SYSV\${SEDeB}SYSV\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
X
Xecho checking for sequent/ptx
Xcat > conftest.c <<EOF
X#ifdef _SEQUENT_
X  yes
X#endif
X
XEOF
Xeval "$CPP \$DEFS conftest.c > conftest.out 2>&1"
Xif egrep "yes" conftest.out >/dev/null 2>&1; then
X  LIBS="$LIBS -lsocket -linet";seqptx=1
Xfi
Xrm -f conftest*
X
X
Xoldlibs="$LIBS"
XLIBS="$LIBS -lelf"
Xecho checking for SVR4
Xcat > conftest.c <<EOF
X
Xint main() { exit(0); }
Xint t() {  }
XEOF
Xif eval $compile; then
X  echo checking for dwarf.h
Xcat > conftest.c <<EOF
X#include <dwarf.h>
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining SVR4"
XDEFS="$DEFS -DSVR4=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SVR4\${SEDdB}SVR4\${SEDdC}1\${SEDdD}
X\${SEDuA}SVR4\${SEDuB}SVR4\${SEDuC}1\${SEDuD}
X\${SEDeA}SVR4\${SEDeB}SVR4\${SEDeC}1\${SEDeD}
X"
X}
X 
X{
Xtest -n "$verbose" && \
Xecho "	defining BUGGYGETLOGIN"
XDEFS="$DEFS -DBUGGYGETLOGIN=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}BUGGYGETLOGIN\${SEDdB}BUGGYGETLOGIN\${SEDdC}1\${SEDdD}
X\${SEDuA}BUGGYGETLOGIN\${SEDuB}BUGGYGETLOGIN\${SEDuC}1\${SEDuD}
X\${SEDeA}BUGGYGETLOGIN\${SEDeB}BUGGYGETLOGIN\${SEDeC}1\${SEDeD}
X"
X}
X LIBS="$LIBS -lelf"
Xelse
X  echo checking for elf.h
Xcat > conftest.c <<EOF
X#include <elf.h>
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining SVR4"
XDEFS="$DEFS -DSVR4=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SVR4\${SEDdB}SVR4\${SEDdC}1\${SEDdD}
X\${SEDuA}SVR4\${SEDuB}SVR4\${SEDuC}1\${SEDuD}
X\${SEDeA}SVR4\${SEDeB}SVR4\${SEDeC}1\${SEDeD}
X"
X}
X 
X{
Xtest -n "$verbose" && \
Xecho "	defining BUGGYGETLOGIN"
XDEFS="$DEFS -DBUGGYGETLOGIN=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}BUGGYGETLOGIN\${SEDdB}BUGGYGETLOGIN\${SEDdC}1\${SEDdD}
X\${SEDuA}BUGGYGETLOGIN\${SEDuB}BUGGYGETLOGIN\${SEDuC}1\${SEDuD}
X\${SEDeA}BUGGYGETLOGIN\${SEDeB}BUGGYGETLOGIN\${SEDeC}1\${SEDeD}
X"
X}
X LIBS="$LIBS -lelf"
Xfi
Xrm -f conftest*
X
Xfi
Xrm -f conftest*
X
X
Xelse
X  LIBS="$oldlibs"
Xfi
Xrm -f conftest*
X
X
X
Xecho checking for pid_t
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X
XEOF
Xeval "$CPP \$DEFS conftest.c > conftest.out 2>&1"
Xif egrep "pid_t" conftest.out >/dev/null 2>&1; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining PID_T_DEFINED"
XDEFS="$DEFS -DPID_T_DEFINED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}PID_T_DEFINED\${SEDdB}PID_T_DEFINED\${SEDdC}1\${SEDdD}
X\${SEDuA}PID_T_DEFINED\${SEDuB}PID_T_DEFINED\${SEDuC}1\${SEDuD}
X\${SEDeA}PID_T_DEFINED\${SEDeB}PID_T_DEFINED\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
X
Xecho checking for sig_t
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <signal.h>
X
XEOF
Xeval "$CPP \$DEFS conftest.c > conftest.out 2>&1"
Xif egrep "sig_t" conftest.out >/dev/null 2>&1; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining SIG_T_DEFINED"
XDEFS="$DEFS -DSIG_T_DEFINED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SIG_T_DEFINED\${SEDdB}SIG_T_DEFINED\${SEDdC}1\${SEDdD}
X\${SEDuA}SIG_T_DEFINED\${SEDuB}SIG_T_DEFINED\${SEDuC}1\${SEDuD}
X\${SEDeA}SIG_T_DEFINED\${SEDeB}SIG_T_DEFINED\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
X
Xecho checking for uid_t
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X
XEOF
Xeval "$CPP \$DEFS conftest.c > conftest.out 2>&1"
Xif egrep "uid_t" conftest.out >/dev/null 2>&1; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining UID_T_DEFINED"
XDEFS="$DEFS -DUID_T_DEFINED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}UID_T_DEFINED\${SEDdB}UID_T_DEFINED\${SEDdC}1\${SEDdD}
X\${SEDuA}UID_T_DEFINED\${SEDuB}UID_T_DEFINED\${SEDuC}1\${SEDuD}
X\${SEDeA}UID_T_DEFINED\${SEDeB}UID_T_DEFINED\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
X
X
Xecho checking for BSD job control
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <sys/ioctl.h>
X
Xint main() { exit(0); }
Xint t() { 
X#ifdef POSIX
Xtcsetpgrp(0, 0);
X#else
Xint x = TIOCSPGRP;
X#ifdef SYSV
Xsetpgrp();
X#else
Xint y = TIOCNOTTY;
X#endif
X#endif
X }
XEOF
Xif eval $compile; then
X  echo "- you have jobcontrol" 
X{
Xtest -n "$verbose" && \
Xecho "	defining BSDJOBS"
XDEFS="$DEFS -DBSDJOBS=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}BSDJOBS\${SEDdB}BSDJOBS\${SEDdC}1\${SEDdD}
X\${SEDuA}BSDJOBS\${SEDuB}BSDJOBS\${SEDuC}1\${SEDuD}
X\${SEDeA}BSDJOBS\${SEDeB}BSDJOBS\${SEDeC}1\${SEDeD}
X"
X}
X
Xelse
X  echo "- you don't have jobcontrol"
Xfi
Xrm -f conftest*
X
X
Xecho checking for setreuid
Xcat > conftest.c <<EOF
X
Xint main() { exit(0); }
Xint t() { 
X#ifdef hpux
Xsetresuid(0, 0, 0);
X#else
Xsetreuid(0, 0);
X#endif
X }
XEOF
Xif eval $compile; then
X  :
Xelse
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining NOREUID"
XDEFS="$DEFS -DNOREUID=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}NOREUID\${SEDdB}NOREUID\${SEDdC}1\${SEDdD}
X\${SEDuA}NOREUID\${SEDuB}NOREUID\${SEDuC}1\${SEDuD}
X\${SEDeA}NOREUID\${SEDeB}NOREUID\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
X
X
X
Xecho checking for select
Xcat > conftest.c <<EOF
X
Xint main() { exit(0); }
Xint t() { select(0, 0, 0, 0, 0); }
XEOF
Xif eval $compile; then
X  :
Xelse
X  LIBS="$LIBS -lnet -lnsl"
Xecho checking for select with $LIBS
Xcat > conftest.c <<EOF
X
Xint main() { exit(0); }
Xint t() { select(0, 0, 0, 0, 0); }
XEOF
Xif eval $compile; then
X  :
Xelse
X  echo '!!! no select - no screen';exit
Xfi
Xrm -f conftest*
X
X
Xfi
Xrm -f conftest*
X
X
Xecho checking fifos
Xcat > conftest.c <<EOF
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <fcntl.h>
X
X#ifndef O_NDELAY
X#define O_NDELAY O_NONBLOCK
X#endif
X#ifndef S_IFIFO
X#define S_IFIFO 0010000
X#endif
X
Xchar *fin = "/tmp/conftest$$";
X
Xmain()
X{
X  struct stat stb;
X  int f;
X
X  (void)alarm(5);
X  if (mknod(fin, S_IFIFO|0777, 0))
X    exit(1);
X  if (stat(fin, &stb) || (stb.st_mode & S_IFIFO) != S_IFIFO)
X    exit(1);
X  close(0);
X  if (open(fin, O_RDWR | O_NDELAY))
X    exit(1);
X  if (write(0, "TEST", 4) == -1)
X    exit(1);
X  f = 1;
X  if (select(1, &f, 0, 0, 0) == -1)
X    exit(1);
X  exit(0);
X}
X
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  echo "- your fifos are usable"; fifo=1
Xelse
X  echo "- your fifos are not usable"
Xfi
Xrm -f conftest*
Xrm -f /tmp/conftest*
X
Xif test -n "$fifo"; then
Xecho "checking for broken fifo implementation"
Xcat > conftest.c <<EOF
X
X#include <sys/types.h>
X#include <fcntl.h>
X#include <sys/time.h>
X#include <sys/stat.h>
X
X#ifndef O_NDELAY
X#define O_NDELAY O_NONBLOCK
X#endif
X#ifndef S_IFIFO
X#define S_IFIFO 0010000
X#endif
X
Xchar *fin = "/tmp/conftest$$";
X
Xmain()
X{
X  struct timeval tv;
X  int r, x;
X
X  if (mknod(fin, S_IFIFO|0600, 0))
X    exit(1);
X  close(0);
X  if (open(fin, O_RDONLY|O_NDELAY))
X    exit(1);
X  r = 1;
X  tv.tv_sec = 1;
X  tv.tv_usec = 0;
X  if (select(1, &r, 0, 0, &tv))
X    exit(1);
X  exit(0);
X}
X
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  echo "- your implementation is ok"
Xelse
X  echo "- you have a broken implementation" 
X{
Xtest -n "$verbose" && \
Xecho "	defining BROKEN_PIPE"
XDEFS="$DEFS -DBROKEN_PIPE=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}BROKEN_PIPE\${SEDdB}BROKEN_PIPE\${SEDdC}1\${SEDdD}
X\${SEDuA}BROKEN_PIPE\${SEDuB}BROKEN_PIPE\${SEDuC}1\${SEDuD}
X\${SEDeA}BROKEN_PIPE\${SEDeB}BROKEN_PIPE\${SEDeC}1\${SEDeD}
X"
X}
X fifobr=1
Xfi
Xrm -f conftest*
Xrm -f /tmp/conftest*
Xfi
X
X
Xecho checking sockets
Xcat > conftest.c <<EOF
X
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/un.h>
X#include <fcntl.h>
X
X#ifndef O_NDELAY
X#define O_NDELAY O_NONBLOCK
X#endif
X#ifndef FNDELAY
X#define FNDELAY O_NDELAY
X#endif
X
Xchar *son = "/tmp/conftest$$";
X
Xmain()
X{
X  int s1, s2, s3, l;
X  struct sockaddr_un a;
X
X  (void)alarm(5);
X  if ((s1 = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
X    exit(1);
X  a.sun_family = AF_UNIX;
X  strcpy(a.sun_path, son);
X  (void) unlink(son);
X  if (bind(s1, (struct sockaddr *) &a, strlen(son)+2) == -1)
X    exit(1);
X  if (listen(s1, 2))
X    exit(1);
X  if (fork() == 0)
X    {
X      if ((s2 = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
X	kill(getppid(), 3);
X      (void)connect(s2, (struct sockaddr *)&a, strlen(son) + 2);
X      if (write(s2, "HELLO", 5) == -1)
X	kill(getppid(), 3);
X      exit(0);
X    }
X  l = sizeof(a);
X  close(0);
X  if (accept(s1, &a, &l))
X    exit(1);
X  l = 1;
X  if (select(1, &l, 0, 0, 0) == -1)
X    exit(1);
X  exit(0);
X}
X
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  echo "- your sockets are usable"; sock=1
Xelse
X  echo "- your sockets are not usable"
Xfi
Xrm -f conftest*
Xrm -f /tmp/conftest*
X
Xif test -n "$sock"; then
Xecho "checking socket implementation"
Xcat > conftest.c <<EOF
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <sys/socket.h>
X#include <sys/un.h>
X
Xchar *son = "/tmp/conftest$$";
X
Xmain()
X{
X  int s;
X  struct stat stb;
X  struct sockaddr_un a;
X  if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
X    exit(0);
X  a.sun_family = AF_UNIX;
X  strcpy(a.sun_path, son);
X  (void) unlink(son);
X  if (bind(s, (struct sockaddr *) &a, strlen(son)+2) == -1)
X    exit(0);
X  if (stat(son, &stb))
X    exit(1);
X  close(s);
X  exit(0);
X}
X
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  echo "- you are normal"
Xelse
X  echo "- unix domain sockets are not kept in the filesystem"
X
X{
Xtest -n "$verbose" && \
Xecho "	defining SOCK_NOT_IN_FS"
XDEFS="$DEFS -DSOCK_NOT_IN_FS=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SOCK_NOT_IN_FS\${SEDdB}SOCK_NOT_IN_FS\${SEDdC}1\${SEDdD}
X\${SEDuA}SOCK_NOT_IN_FS\${SEDuB}SOCK_NOT_IN_FS\${SEDuC}1\${SEDuD}
X\${SEDeA}SOCK_NOT_IN_FS\${SEDeB}SOCK_NOT_IN_FS\${SEDeC}1\${SEDeD}
X"
X}
X socknofs=1
Xfi
Xrm -f conftest*
Xrm -f /tmp/conftest*
Xfi
X
X
Xif test -n "$fifo"; then
X  if test -n "$sock"; then
X    if test -n "$nore"; then
X      echo "- hmmm... better take the fifos"
X      
X{
Xtest -n "$verbose" && \
Xecho "	defining NAMEDPIPE"
XDEFS="$DEFS -DNAMEDPIPE=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}NAMEDPIPE\${SEDdB}NAMEDPIPE\${SEDdC}1\${SEDdD}
X\${SEDuA}NAMEDPIPE\${SEDuB}NAMEDPIPE\${SEDuC}1\${SEDuD}
X\${SEDeA}NAMEDPIPE\${SEDeB}NAMEDPIPE\${SEDeC}1\${SEDeD}
X"
X}
X
X    elif test -n "$fifobr"; then
X      echo "- as your fifos are broken lets use the sockets."
X    else
X      echo "- both sockets and fifos usable. let's take fifos."
X      
X{
Xtest -n "$verbose" && \
Xecho "	defining NAMEDPIPE"
XDEFS="$DEFS -DNAMEDPIPE=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}NAMEDPIPE\${SEDdB}NAMEDPIPE\${SEDdC}1\${SEDdD}
X\${SEDuA}NAMEDPIPE\${SEDuB}NAMEDPIPE\${SEDuC}1\${SEDuD}
X\${SEDeA}NAMEDPIPE\${SEDeB}NAMEDPIPE\${SEDeC}1\${SEDeD}
X"
X}
X
X    fi
X  else
X    echo "- using named pipes, of course"
X    
X{
Xtest -n "$verbose" && \
Xecho "	defining NAMEDPIPE"
XDEFS="$DEFS -DNAMEDPIPE=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}NAMEDPIPE\${SEDdB}NAMEDPIPE\${SEDdC}1\${SEDdD}
X\${SEDuA}NAMEDPIPE\${SEDuB}NAMEDPIPE\${SEDuC}1\${SEDuD}
X\${SEDeA}NAMEDPIPE\${SEDeB}NAMEDPIPE\${SEDeC}1\${SEDeD}
X"
X}
X
X  fi
Xelif test -n "$sock"; then
X  echo "- using unix-domain sockets, of course"
Xelse
X  echo "!!! you have neither usable sockets nor usable pipes -> no screen"
X  exit
Xfi
X
X
Xecho "checking select return value"
Xcat > conftest.c <<EOF
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <fcntl.h>
X
Xchar *nam = "/tmp/conftest$$";
X
X#ifdef NAMEDPIPE
X
X#ifndef O_NDELAY
X#define O_NDELAY O_NONBLOCK
X#endif
X#ifndef S_IFIFO
X#define S_IFIFO 0010000
X#endif
X
X
Xmain()
X{
X  int l;
X
X  (void)alarm(5);
X  if (mknod(nam, S_IFIFO|0777, 0))
X    exit(1);
X  close(0);
X  if (open(nam, O_RDWR | O_NDELAY))
X    exit(1);
X  if (write(0, "TEST", 4) == -1)
X    exit(1);
X
X#else
X
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/un.h>
X
Xmain()
X{
X  int s1, s2, s3, l;
X  struct sockaddr_un a;
X
X  (void)alarm(5);
X  if ((s1 = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
X    exit(1);
X  a.sun_family = AF_UNIX;
X  strcpy(a.sun_path, nam);
X  (void) unlink(nam);
X  if (bind(s1, (struct sockaddr *) &a, strlen(nam)+2) == -1)
X    exit(1);
X  if (listen(s1, 2))
X    exit(1);
X  if (fork() == 0)
X    {
X      if ((s2 = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
X	kill(getppid(), 3);
X      (void)connect(s2, (struct sockaddr *)&a, strlen(nam) + 2);
X      if (write(s2, "HELLO", 5) == -1)
X	kill(getppid(), 3);
X      exit(0);
X    }
X  l = sizeof(a);
X  close(0);
X  if (accept(s1, (struct sockaddr *)&a, &l))
X    exit(1);
X#endif
X
X
X  l = 1;
X  if (select(1, &l, 0, 0, 0) == -1)
X    exit(1);
X  if (select(1, &l, &l, 0, 0) != 2)
X    exit(1);
X  exit(0);
X}
X
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  echo "- select is ok"
Xelse
X  echo "- it is not usable"
X
X{
Xtest -n "$verbose" && \
Xecho "	defining SELECT_BROKEN"
XDEFS="$DEFS -DSELECT_BROKEN=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SELECT_BROKEN\${SEDdB}SELECT_BROKEN\${SEDdC}1\${SEDdD}
X\${SEDuA}SELECT_BROKEN\${SEDuB}SELECT_BROKEN\${SEDuC}1\${SEDuD}
X\${SEDeA}SELECT_BROKEN\${SEDeB}SELECT_BROKEN\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
Xecho searching for tgetent
Xolibs="$LIBS"
XLIBS="-ltermcap $LIBS"
Xecho checking for libtermcap
Xcat > conftest.c <<EOF
X
Xint main() { exit(0); }
Xint t() { tgetent((char *)0, (char *)0); }
XEOF
Xif eval $compile; then
X  :
Xelse
X  LIBS="-lcurses $olibs"
Xecho checking for libcurses
Xcat > conftest.c <<EOF
X
Xint main() { exit(0); }
Xint t() { tgetent((char *)0, (char *)0); }
XEOF
Xif eval $compile; then
X  :
Xelse
X  echo "!!! no tgetent - no screen";exit
Xfi
Xrm -f conftest*
X
X
Xfi
Xrm -f conftest*
X
XTERMCAP="xx|scrdumm:xx:"
XTERM=scrdumm
Xexport TERMCAP
Xexport TERM
Xcat > conftest.c <<EOF
X
Xmain()
X{
X  char buf[1024];
X  if (tgetent(buf, "scrdumm") != 1)
X    exit(1);
X  exit(0);
X}
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  echo "- you use the termcap database"
Xelse
X  echo "- you use the terminfo database"
X
X{
Xtest -n "$verbose" && \
Xecho "	defining TERMINFO"
XDEFS="$DEFS -DTERMINFO=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}TERMINFO\${SEDdB}TERMINFO\${SEDdC}1\${SEDdD}
X\${SEDuA}TERMINFO\${SEDuB}TERMINFO\${SEDuC}1\${SEDuD}
X\${SEDeA}TERMINFO\${SEDeB}TERMINFO\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
Xecho checking for ospeed
Xcat > conftest.c <<EOF
Xextern short ospeed;
Xint main() { exit(0); }
Xint t() { ospeed=5; }
XEOF
Xif eval $compile; then
X  :
Xelse
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining NEED_OSPEED"
XDEFS="$DEFS -DNEED_OSPEED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}NEED_OSPEED\${SEDdB}NEED_OSPEED\${SEDdC}1\${SEDdD}
X\${SEDuA}NEED_OSPEED\${SEDuB}NEED_OSPEED\${SEDuC}1\${SEDuD}
X\${SEDeA}NEED_OSPEED\${SEDeB}NEED_OSPEED\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
X
Xecho checking for ptyranges
Xif test -d /dev/ptym ; then
Xpdir='/dev/ptym'
Xelse
Xpdir='/dev'
Xfi
Xptys=`echo $pdir/pty??`
Xif test "$ptys" != "$pdir/pty??" ; then
Xp0=`echo $ptys | tr ' ' '\012' | sed -e 's/^.*\(.\).$/\1/g' | tr ' ' '\012' | sort -u | sed -n -e H -e g -e 's/\n//g' -e '$p'`
Xp1=`echo $ptys | tr ' ' '\012' | sed -e 's/^.*\(.\)$/\1/g' | tr ' ' '\012' | sort -u | sed -n -e H -e g -e 's/\n//g' -e '$p'`
X
X{
Xtest -n "$verbose" && \
Xecho "	defining PTYRANGE0 to be \"$p0\""
XDEFS="$DEFS -DPTYRANGE0=\"$p0\""
XSEDDEFS="${SEDDEFS}\${SEDdA}PTYRANGE0\${SEDdB}PTYRANGE0\${SEDdC}\"$p0\"\${SEDdD}
X\${SEDuA}PTYRANGE0\${SEDuB}PTYRANGE0\${SEDuC}\"$p0\"\${SEDuD}
X\${SEDeA}PTYRANGE0\${SEDeB}PTYRANGE0\${SEDeC}\"$p0\"\${SEDeD}
X"
X}
X
X
X{
Xtest -n "$verbose" && \
Xecho "	defining PTYRANGE1 to be \"$p1\""
XDEFS="$DEFS -DPTYRANGE1=\"$p1\""
XSEDDEFS="${SEDDEFS}\${SEDdA}PTYRANGE1\${SEDdB}PTYRANGE1\${SEDdC}\"$p1\"\${SEDdD}
X\${SEDuA}PTYRANGE1\${SEDuB}PTYRANGE1\${SEDuC}\"$p1\"\${SEDuD}
X\${SEDeA}PTYRANGE1\${SEDeB}PTYRANGE1\${SEDeC}\"$p1\"\${SEDeD}
X"
X}
X
Xfi
X
X
Xecho checking for getutent
Xcat > conftest.c <<EOF
X#include <time.h> /* to get time_t on SCO */
X#include <sys/types.h>
X#ifdef SVR4
X#include <utmpx.h>
X#else
X#include <utmp.h>
X#endif
X#ifdef hpux
X#define pututline _pututline
X#endif
X
Xint main() { exit(0); }
Xint t() { int x = DEAD_PROCESS; struct utmp *y = pututline((struct utmp *)0); getutent(); }
XEOF
Xif eval $compile; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining GETUTENT"
XDEFS="$DEFS -DGETUTENT=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}GETUTENT\${SEDdB}GETUTENT\${SEDdC}1\${SEDdD}
X\${SEDuA}GETUTENT\${SEDuB}GETUTENT\${SEDuC}1\${SEDuD}
X\${SEDeA}GETUTENT\${SEDeB}GETUTENT\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
Xecho checking for ut_host
Xcat > conftest.c <<EOF
X#include <time.h>
X#include <sys/types.h>
X#ifdef SVR4
X#include <utmpx.h>
X#else
X#include <utmp.h>
X#endif
X
Xint main() { exit(0); }
Xint t() { struct utmp u; u.ut_host[0] = 0; }
XEOF
Xif eval $compile; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining UTHOST"
XDEFS="$DEFS -DUTHOST=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}UTHOST\${SEDdB}UTHOST\${SEDdC}1\${SEDdD}
X\${SEDuA}UTHOST\${SEDuB}UTHOST\${SEDuC}1\${SEDuD}
X\${SEDeA}UTHOST\${SEDeB}UTHOST\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
X
X
Xecho "checking for libutil(s)"
Xtest -f /usr/lib/libutils.a && LIBS="$LIBS -lutils"
Xtest -f /usr/lib/libutil.a && LIBS="$LIBS -lutil"
X
Xecho checking for getloadavg
Xcat > conftest.c <<EOF
X
Xint main() { exit(0); }
Xint t() { getloadavg((double *)0, 0); }
XEOF
Xif eval $compile; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining LOADAV_GETLOADAVG"
XDEFS="$DEFS -DLOADAV_GETLOADAVG=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}LOADAV_GETLOADAVG\${SEDdB}LOADAV_GETLOADAVG\${SEDdC}1\${SEDdD}
X\${SEDuA}LOADAV_GETLOADAVG\${SEDuB}LOADAV_GETLOADAVG\${SEDuC}1\${SEDuD}
X\${SEDeA}LOADAV_GETLOADAVG\${SEDeB}LOADAV_GETLOADAVG\${SEDeC}1\${SEDeD}
X"
X}
X load=1
Xfi
Xrm -f conftest*
X
Xif test -z "$load" ; then
Xcat > conftest.c <<EOF
X#if defined(NeXT) || defined(apollo) || defined(linux)
X  yes
X#endif
X
XEOF
Xeval "$CPP \$DEFS conftest.c > conftest.out 2>&1"
Xif egrep "yes" conftest.out >/dev/null 2>&1; then
X  load=1
Xfi
Xrm -f conftest*
X
Xfi
Xif test -z "$load" ; then
Xecho "searching for kernelfile"
Xfor core in /unix /vmunix /dynix /hp-ux /xelos /386bsd /kernel/unix ; do
X  if test -f $core ; then
X    break
X  fi
Xdone
Xif test ! -f $core ; then
X  echo "- no kernelfile found"
Xelse
X  echo "- using kernelfile '$core'"
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining LOADAV_UNIX to be \"$core\""
XDEFS="$DEFS -DLOADAV_UNIX=\"$core\""
XSEDDEFS="${SEDDEFS}\${SEDdA}LOADAV_UNIX\${SEDdB}LOADAV_UNIX\${SEDdC}\"$core\"\${SEDdD}
X\${SEDuA}LOADAV_UNIX\${SEDuB}LOADAV_UNIX\${SEDuC}\"$core\"\${SEDuD}
X\${SEDeA}LOADAV_UNIX\${SEDeB}LOADAV_UNIX\${SEDeC}\"$core\"\${SEDeD}
X"
X}
X
X  echo checking for nlist.h
Xcat > conftest.c <<EOF
X#include <nlist.h>
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining NLIST_STRUCT"
XDEFS="$DEFS -DNLIST_STRUCT=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}NLIST_STRUCT\${SEDdB}NLIST_STRUCT\${SEDdC}1\${SEDdD}
X\${SEDuA}NLIST_STRUCT\${SEDuB}NLIST_STRUCT\${SEDuC}1\${SEDuD}
X\${SEDeA}NLIST_STRUCT\${SEDeB}NLIST_STRUCT\${SEDeC}1\${SEDeD}
X"
X}
X
X     echo checking for n_un in struct nlist
Xcat > conftest.c <<EOF
X#include <nlist.h>
Xint main() { exit(0); }
Xint t() { struct nlist n; n.n_un.n_name = 0; }
XEOF
Xif eval $compile; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining NLIST_NAME_UNION"
XDEFS="$DEFS -DNLIST_NAME_UNION=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}NLIST_NAME_UNION\${SEDdB}NLIST_NAME_UNION\${SEDdC}1\${SEDdD}
X\${SEDuA}NLIST_NAME_UNION\${SEDuB}NLIST_NAME_UNION\${SEDuC}1\${SEDuD}
X\${SEDeA}NLIST_NAME_UNION\${SEDeB}NLIST_NAME_UNION\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
Xfi
Xrm -f conftest*
X
X
X  echo checking for nlist declaration
X  cat > conftest.c <<EOF
X
X#ifdef NLIST_STRUCT
X# include <nlist.h>
X#else
X# include <a.out.h>
X#endif
X
XEOF
Xeval "$CPP \$DEFS conftest.c > conftest.out 2>&1"
Xif egrep "nlist( |	|\()" conftest.out >/dev/null 2>&1; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining NLIST_DECLARED"
XDEFS="$DEFS -DNLIST_DECLARED=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}NLIST_DECLARED\${SEDdB}NLIST_DECLARED\${SEDdC}1\${SEDdD}
X\${SEDuA}NLIST_DECLARED\${SEDuB}NLIST_DECLARED\${SEDuC}1\${SEDuD}
X\${SEDeA}NLIST_DECLARED\${SEDeB}NLIST_DECLARED\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
X
X  echo searching for avenrun symbol
X  for av in avenrun _avenrun _Loadavg ; do
X  cat > conftest.c <<EOF
X
X#include <sys/types.h>
X#ifdef NLIST_STRUCT
X#include <nlist.h>
X#else
X#include <a.out.h>
X#endif
X
Xstruct nlist nl[2];
X
Xmain()
X{
X#ifdef NLIST_NAME_UNION
X  nl[0].n_un.n_name = "$av";
X#else
X  nl[0].n_name = "$av";
X#endif
X  nlist(LOADAV_UNIX, nl);
X  if (nl[0].n_value == 0)
X    exit(1);
X  exit(0);
X}
X  
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  avensym=$av;break
Xfi
Xrm -f conftest*
X  done
X  if test -z "$avensym" ; then
X    echo "- no avenrun symbol found"
X  else
X    echo "- using avenrun symbol '$avensym'"
X    
X{
Xtest -n "$verbose" && \
Xecho "	defining LOADAV_AVENRUN to be \"$avensym\""
XDEFS="$DEFS -DLOADAV_AVENRUN=\"$avensym\""
XSEDDEFS="${SEDDEFS}\${SEDdA}LOADAV_AVENRUN\${SEDdB}LOADAV_AVENRUN\${SEDdC}\"$avensym\"\${SEDdD}
X\${SEDuA}LOADAV_AVENRUN\${SEDuB}LOADAV_AVENRUN\${SEDuC}\"$avensym\"\${SEDuD}
X\${SEDeA}LOADAV_AVENRUN\${SEDeB}LOADAV_AVENRUN\${SEDeC}\"$avensym\"\${SEDeD}
X"
X}
X
X    load=1
X  fi
Xfi
Xfi
X
Xcat > conftest.c <<EOF
X
X#include <sys/types.h>
X#include <sys/param.h>
X
X_CUT_HERE_
X
X#if ((defined(hp300) && !defined(hpux)) || defined(sun) || (defined(ultrix) && defined(mips)) || defined(_SEQUENT_) || defined(sgi) || defined(SVR4) || defined(sony_news) || defined(__alpha))
Xloadtype=long
X# ifdef apollo
Xloadscale=65536
X# else
X#  ifdef FSCALE
X#   undef FSCALE
Xloadscale=FSCALE
X#  else
X#   ifdef sgi
Xloadscale=1024
X#   else
X#    if defined(MIPS) || defined(SVR4)
Xloadscale=256
X#    else /* not MIPS */
Xloadscale=1000 	/* our default value */
X#    endif /* MIPS */
X#   endif /* sgi */
X#  endif /* not FSCALE */
X# endif /* not apollo */
X#else
Xloadtype=double
Xloadscale=1
X#endif
X#ifdef alliant
Xloadnum=4
X#else
Xloadnum=3
X#endif
X
XEOF
Xeval "$CPP $DEFS conftest.c 2>/dev/null | sed -e '1,/_CUT_HERE_/d' > conftest.out"
X. ./conftest.out
Xrm -f conftest*
X
X
Xif test -n "$load" ; then 
X{
Xtest -n "$verbose" && \
Xecho "	defining LOADAV"
XDEFS="$DEFS -DLOADAV=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}LOADAV\${SEDdB}LOADAV\${SEDdC}1\${SEDdD}
X\${SEDuA}LOADAV\${SEDuB}LOADAV\${SEDuC}1\${SEDuD}
X\${SEDeA}LOADAV\${SEDeB}LOADAV\${SEDeC}1\${SEDeD}
X"
X}
X fi
Xif test -n "$loadtype" ; then 
X{
Xtest -n "$verbose" && \
Xecho "	defining LOADAV_TYPE to be $loadtype"
XDEFS="$DEFS -DLOADAV_TYPE=$loadtype"
XSEDDEFS="${SEDDEFS}\${SEDdA}LOADAV_TYPE\${SEDdB}LOADAV_TYPE\${SEDdC}$loadtype\${SEDdD}
X\${SEDuA}LOADAV_TYPE\${SEDuB}LOADAV_TYPE\${SEDuC}$loadtype\${SEDuD}
X\${SEDeA}LOADAV_TYPE\${SEDeB}LOADAV_TYPE\${SEDeC}$loadtype\${SEDeD}
X"
X}
X fi
Xif test -n "$loadnum" ; then 
X{
Xtest -n "$verbose" && \
Xecho "	defining LOADAV_NUM to be $loadnum"
XDEFS="$DEFS -DLOADAV_NUM=$loadnum"
XSEDDEFS="${SEDDEFS}\${SEDdA}LOADAV_NUM\${SEDdB}LOADAV_NUM\${SEDdC}$loadnum\${SEDdD}
X\${SEDuA}LOADAV_NUM\${SEDuB}LOADAV_NUM\${SEDuC}$loadnum\${SEDuD}
X\${SEDeA}LOADAV_NUM\${SEDeB}LOADAV_NUM\${SEDeC}$loadnum\${SEDeD}
X"
X}
X fi
Xif test -n "$loadscale" ; then 
X{
Xtest -n "$verbose" && \
Xecho "	defining LOADAV_SCALE to be $loadscale"
XDEFS="$DEFS -DLOADAV_SCALE=$loadscale"
XSEDDEFS="${SEDDEFS}\${SEDdA}LOADAV_SCALE\${SEDdB}LOADAV_SCALE\${SEDdC}$loadscale\${SEDdD}
X\${SEDuA}LOADAV_SCALE\${SEDuB}LOADAV_SCALE\${SEDuC}$loadscale\${SEDuD}
X\${SEDeA}LOADAV_SCALE\${SEDeB}LOADAV_SCALE\${SEDeC}$loadscale\${SEDeD}
X"
X}
X fi
X
X
Xecho '#include <signal.h>' > conftest.c
Xeval "$CPP \$DEFS conftest.c > conftest.out 2>&1"
Xif egrep "(void|sighandler_t).*signal" conftest.out >/dev/null 2>&1; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining SIGVOID"
XDEFS="$DEFS -DSIGVOID=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SIGVOID\${SEDdB}SIGVOID\${SEDdC}1\${SEDdD}
X\${SEDuA}SIGVOID\${SEDuB}SIGVOID\${SEDuC}1\${SEDuD}
X\${SEDeA}SIGVOID\${SEDeB}SIGVOID\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
Xecho checking for sigset
Xcat > conftest.c <<EOF
X
X#include <sys/types.h>
X#include <signal.h>
X
Xint main() { exit(0); }
Xint t() { 
X#ifdef SIGVOID
Xsigset(0, (void (*)())0);
X#else
Xsigset(0, (int (*)())0);
X#endif
X }
XEOF
Xif eval $compile; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining USESIGSET"
XDEFS="$DEFS -DUSESIGSET=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}USESIGSET\${SEDdB}USESIGSET\${SEDdC}1\${SEDdD}
X\${SEDuA}USESIGSET\${SEDuB}USESIGSET\${SEDuC}1\${SEDuD}
X\${SEDeA}USESIGSET\${SEDeB}USESIGSET\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
Xecho checking signal implementation
Xcat > conftest.c <<EOF
X
X#include <sys/types.h>
X#include <signal.h>
X
X#ifndef SIGCHLD
X#define SIGCHLD SIGCLD
X#endif
X#ifdef USESIGSET
X#define signal sigset
X#endif
X
Xint got;
X
X#ifdef SIGVOID
Xvoid
X#endif
Xhand()
X{
X  got++;
X}
X
Xmain()
X{
X  (void)signal(SIGCHLD, hand);
X  kill(getpid(), SIGCHLD);
X  kill(getpid(), SIGCHLD);
X  if (got < 2)
X    exit(1);
X  exit(0);
X}
X
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  :
Xelse
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining SYSVSIGS"
XDEFS="$DEFS -DSYSVSIGS=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SYSVSIGS\${SEDdB}SYSVSIGS\${SEDdC}1\${SEDdD}
X\${SEDuA}SYSVSIGS\${SEDuB}SYSVSIGS\${SEDuC}1\${SEDuD}
X\${SEDeA}SYSVSIGS\${SEDeB}SYSVSIGS\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
X
Xecho checking for crypt and sec libraries
Xtest -f /lib/libcrypt_d.a || test -f /usr/lib/libcrypt_d.a && LIBS="$LIBS -lcrypt_d"
Xtest -f /lib/libcrypt.a || test -f /usr/lib/libcrypt.a && LIBS="$LIBS -lcrypt"
Xtest -f /lib/libsec.a || test -f /usr/lib/libsec.a && LIBS="$LIBS -lsec"
X
Xoldlibs="$LIBS"
XLIBS="$LIBS -lsun"
Xecho checking for IRIX sun library
Xcat > conftest.c <<EOF
X
Xint main() { exit(0); }
Xint t() {  }
XEOF
Xif eval $compile; then
X  :
Xelse
X  LIBS="$oldlibs"
Xfi
Xrm -f conftest*
X
X
X
Xecho checking for wait union
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <sys/wait.h>
X
Xint main() { exit(0); }
Xint t() { 
X  union wait x;
X  int y;
X#ifdef WEXITSTATUS
X  y = WEXITSTATUS(x);
X#endif
X }
XEOF
Xif eval $compile; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining BSDWAIT"
XDEFS="$DEFS -DBSDWAIT=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}BSDWAIT\${SEDdB}BSDWAIT\${SEDdC}1\${SEDdD}
X\${SEDuA}BSDWAIT\${SEDuB}BSDWAIT\${SEDuC}1\${SEDuD}
X\${SEDeA}BSDWAIT\${SEDeB}BSDWAIT\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
X
Xif test -z "$butterfly"; then
Xecho checking for termio or termios
Xcat > conftest.c <<EOF
X#include <termios.h>
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining TERMIO"
XDEFS="$DEFS -DTERMIO=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}TERMIO\${SEDdB}TERMIO\${SEDdC}1\${SEDdD}
X\${SEDuA}TERMIO\${SEDuB}TERMIO\${SEDuC}1\${SEDuD}
X\${SEDeA}TERMIO\${SEDeB}TERMIO\${SEDeC}1\${SEDeD}
X"
X}
X
Xelse
X  cat > conftest.c <<EOF
X#include <termio.h>
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining TERMIO"
XDEFS="$DEFS -DTERMIO=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}TERMIO\${SEDdB}TERMIO\${SEDdC}1\${SEDdD}
X\${SEDuA}TERMIO\${SEDuB}TERMIO\${SEDuC}1\${SEDuD}
X\${SEDeA}TERMIO\${SEDeB}TERMIO\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
Xfi
Xrm -f conftest*
Xfi
X
Xecho checking for getspnam
Xcat > conftest.c <<EOF
X#include <shadow.h>
Xint main() { exit(0); }
Xint t() { getspnam("x"); }
XEOF
Xif eval $compile; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining SHADOWPW"
XDEFS="$DEFS -DSHADOWPW=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SHADOWPW\${SEDdB}SHADOWPW\${SEDdC}1\${SEDdD}
X\${SEDuA}SHADOWPW\${SEDuB}SHADOWPW\${SEDuC}1\${SEDuD}
X\${SEDeA}SHADOWPW\${SEDeB}SHADOWPW\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
X
Xecho checking for getttyent
Xcat > conftest.c <<EOF
X
Xint main() { exit(0); }
Xint t() { getttyent(); }
XEOF
Xif eval $compile; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining GETTTYENT"
XDEFS="$DEFS -DGETTTYENT=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}GETTTYENT\${SEDdB}GETTTYENT\${SEDdC}1\${SEDdD}
X\${SEDuA}GETTTYENT\${SEDuB}GETTTYENT\${SEDuC}1\${SEDuD}
X\${SEDeA}GETTTYENT\${SEDeB}GETTTYENT\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
X
Xecho checking whether memcpy/memmove/bcopy handles overlapping arguments
Xcat > conftest.c <<EOF
X
Xmain() {
X  char buf[10];
X  strcpy(buf, "abcdefghi");
X  bcopy(buf, buf + 2, 3);
X  if (strncmp(buf, "ababcf", 6))
X    exit(1);
X  strcpy(buf, "abcdefghi");
X  bcopy(buf + 2, buf, 3);
X  if (strncmp(buf, "cdedef", 6))
X    exit(1);
X  exit(0); /* libc version works properly.  */
X}
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining USEBCOPY"
XDEFS="$DEFS -DUSEBCOPY=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}USEBCOPY\${SEDdB}USEBCOPY\${SEDdC}1\${SEDdD}
X\${SEDuA}USEBCOPY\${SEDuB}USEBCOPY\${SEDuC}1\${SEDuD}
X\${SEDeA}USEBCOPY\${SEDeB}USEBCOPY\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
Xcat > conftest.c <<EOF
X
X#define bcopy(s,d,l) memmove(d,s,l)
Xmain() {
X  char buf[10];
X  strcpy(buf, "abcdefghi");
X  bcopy(buf, buf + 2, 3);
X  if (strncmp(buf, "ababcf", 6))
X    exit(1);
X  strcpy(buf, "abcdefghi");
X  bcopy(buf + 2, buf, 3);
X  if (strncmp(buf, "cdedef", 6))
X    exit(1);
X  exit(0); /* libc version works properly.  */
X}
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining USEMEMMOVE"
XDEFS="$DEFS -DUSEMEMMOVE=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}USEMEMMOVE\${SEDdB}USEMEMMOVE\${SEDdC}1\${SEDdD}
X\${SEDuA}USEMEMMOVE\${SEDuB}USEMEMMOVE\${SEDuC}1\${SEDuD}
X\${SEDeA}USEMEMMOVE\${SEDeB}USEMEMMOVE\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
X
Xcat > conftest.c <<EOF
X
X#define bcopy(s,d,l) memcpy(d,s,l)
Xmain() {
X  char buf[10];
X  strcpy(buf, "abcdefghi");
X  bcopy(buf, buf + 2, 3);
X  if (strncmp(buf, "ababcf", 6))
X    exit(1);
X  strcpy(buf, "abcdefghi");
X  bcopy(buf + 2, buf, 3);
X  if (strncmp(buf, "cdedef", 6))
X    exit(1);
X  exit(0); /* libc version works properly.  */
X}
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining USEMEMCPY"
XDEFS="$DEFS -DUSEMEMCPY=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}USEMEMCPY\${SEDdB}USEMEMCPY\${SEDdC}1\${SEDdD}
X\${SEDuA}USEMEMCPY\${SEDuB}USEMEMCPY\${SEDuC}1\${SEDuD}
X\${SEDeA}USEMEMCPY\${SEDeB}USEMEMCPY\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
Xecho checking for long file names
X(echo 1 > /tmp/conftest9012345) 2>/dev/null
X(echo 2 > /tmp/conftest9012346) 2>/dev/null
Xval=`cat /tmp/conftest9012345 2>/dev/null`
Xif test -f /tmp/conftest9012345 && test "$val" = 1; then :
Xelse 
X{
Xtest -n "$verbose" && \
Xecho "	defining NAME_MAX to be 14"
XDEFS="$DEFS -DNAME_MAX=14"
XSEDDEFS="${SEDDEFS}\${SEDdA}NAME_MAX\${SEDdB}NAME_MAX\${SEDdC}14\${SEDdD}
X\${SEDuA}NAME_MAX\${SEDuB}NAME_MAX\${SEDuC}14\${SEDuD}
X\${SEDeA}NAME_MAX\${SEDeB}NAME_MAX\${SEDeC}14\${SEDeD}
X"
X}
X
Xfi
Xrm -f /tmp/conftest*
X
Xecho checking for vsprintf
Xcat > conftest.c <<EOF
X#include <varargs.h>
X#include <stdio.h>
Xint main() { exit(0); }
Xint t() { vsprintf(); }
XEOF
Xif eval $compile; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining USEVARARGS"
XDEFS="$DEFS -DUSEVARARGS=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}USEVARARGS\${SEDdB}USEVARARGS\${SEDdC}1\${SEDdD}
X\${SEDuA}USEVARARGS\${SEDuB}USEVARARGS\${SEDuC}1\${SEDuD}
X\${SEDeA}USEVARARGS\${SEDeB}USEVARARGS\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
X
Xecho checking for directory library header
Xdirheader=
Xif test -z "$dirheader"; then
X  echo checking for dirent.h
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <dirent.h>
Xint main() { exit(0); }
Xint t() { DIR *dirp = opendir ("/"); }
XEOF
Xif eval $compile; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining DIRENT"
XDEFS="$DEFS -DDIRENT=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}DIRENT\${SEDdB}DIRENT\${SEDdC}1\${SEDdD}
X\${SEDuA}DIRENT\${SEDuB}DIRENT\${SEDuC}1\${SEDuD}
X\${SEDeA}DIRENT\${SEDeB}DIRENT\${SEDeC}1\${SEDeD}
X"
X}
X dirheader=dirent.h
Xfi
Xrm -f conftest*
Xfi
Xif test -z "$dirheader"; then
X  echo checking for sys/ndir.h
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <sys/ndir.h>
Xint main() { exit(0); }
Xint t() { DIR *dirp = opendir ("/"); }
XEOF
Xif eval $compile; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining SYSNDIR"
XDEFS="$DEFS -DSYSNDIR=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SYSNDIR\${SEDdB}SYSNDIR\${SEDdC}1\${SEDdD}
X\${SEDuA}SYSNDIR\${SEDuB}SYSNDIR\${SEDuC}1\${SEDuD}
X\${SEDeA}SYSNDIR\${SEDeB}SYSNDIR\${SEDeC}1\${SEDeD}
X"
X}
X dirheader=sys/ndir.h
Xfi
Xrm -f conftest*
Xfi
Xif test -z "$dirheader"; then
X  echo checking for sys/dir.h
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <sys/dir.h>
Xint main() { exit(0); }
Xint t() { DIR *dirp = opendir ("/"); }
XEOF
Xif eval $compile; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining SYSDIR"
XDEFS="$DEFS -DSYSDIR=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}SYSDIR\${SEDdB}SYSDIR\${SEDdC}1\${SEDdD}
X\${SEDuA}SYSDIR\${SEDuB}SYSDIR\${SEDuC}1\${SEDuD}
X\${SEDeA}SYSDIR\${SEDeB}SYSDIR\${SEDeC}1\${SEDeD}
X"
X}
X dirheader=sys/dir.h
Xfi
Xrm -f conftest*
Xfi
Xif test -z "$dirheader"; then
X  echo checking for ndir.h
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <ndir.h>
Xint main() { exit(0); }
Xint t() { DIR *dirp = opendir ("/"); }
XEOF
Xif eval $compile; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining NDIR"
XDEFS="$DEFS -DNDIR=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}NDIR\${SEDdB}NDIR\${SEDdC}1\${SEDdD}
X\${SEDuA}NDIR\${SEDuB}NDIR\${SEDuC}1\${SEDuD}
X\${SEDeA}NDIR\${SEDeB}NDIR\${SEDeC}1\${SEDeD}
X"
X}
X dirheader=ndir.h
Xfi
Xrm -f conftest*
Xfi
X
Xecho checking for closedir return value
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <$dirheader>
Xint closedir(); main() { exit(closedir(opendir(".")) != 0); }
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  :
Xelse
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining VOID_CLOSEDIR"
XDEFS="$DEFS -DVOID_CLOSEDIR=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}VOID_CLOSEDIR\${SEDdB}VOID_CLOSEDIR\${SEDdC}1\${SEDdD}
X\${SEDuA}VOID_CLOSEDIR\${SEDuB}VOID_CLOSEDIR\${SEDuC}1\${SEDuD}
X\${SEDeA}VOID_CLOSEDIR\${SEDeB}VOID_CLOSEDIR\${SEDeC}1\${SEDeD}
X"
X}
X
Xfi
Xrm -f conftest*
X
Xecho checking for Xenix
Xcat > conftest.c <<EOF
X#if defined(M_XENIX) && !defined(M_UNIX)
X  yes
X#endif
X
XEOF
Xeval "$CPP \$DEFS conftest.c > conftest.out 2>&1"
Xif egrep "yes" conftest.out >/dev/null 2>&1; then
X  XENIX=1
Xfi
Xrm -f conftest*
X
Xif test -n "$XENIX"; then
X  LIBS="$LIBS -lx"
X  case "$DEFS" in
X  *SYSNDIR*) ;;
X  *) LIBS="-ldir $LIBS" ;; # Make sure -ldir precedes any -lx.
X  esac
Xfi
X
X
Xecho checking for setenv
Xcat > conftest.c <<EOF
X
Xint main() { exit(0); }
Xint t() { setenv((char *)0,(char *)0);unsetenv((char *)0); }
XEOF
Xif eval $compile; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining USESETENV"
XDEFS="$DEFS -DUSESETENV=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}USESETENV\${SEDdB}USESETENV\${SEDdC}1\${SEDdD}
X\${SEDuA}USESETENV\${SEDuB}USESETENV\${SEDuC}1\${SEDuD}
X\${SEDeA}USESETENV\${SEDeB}USESETENV\${SEDeC}1\${SEDeD}
X"
X}
X
Xelse
X  echo checking for putenv
Xcat > conftest.c <<EOF
X
Xint main() { exit(0); }
Xint t() { putenv((char *)0);unsetenv((char *)0); }
XEOF
Xif eval $compile; then
X  :
Xelse
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining NEEDPUTENV"
XDEFS="$DEFS -DNEEDPUTENV=1"
XSEDDEFS="${SEDDEFS}\${SEDdA}NEEDPUTENV\${SEDdB}NEEDPUTENV\${SEDdC}1\${SEDdD}
X\${SEDuA}NEEDPUTENV\${SEDuB}NEEDPUTENV\${SEDuC}1\${SEDuD}
X\${SEDeA}NEEDPUTENV\${SEDeB}NEEDPUTENV\${SEDeC}1\${SEDeD}
X"
X}
X
X
Xfi
Xrm -f conftest*
X
Xfi
Xrm -f conftest*
X
X
Xtest -n "$seqptx" && LIBS="-ltermcap -lc -lsocket -linet -lsec -lseq"
X
Xcat > conftest.c <<EOF
Xmain(){exit(0);}
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  :
Xelse
X  echo "Can't run the compiler - internal error. Sorry.";exit
Xfi
Xrm -f conftest*
Xif test -n "$prefix"; then
X
X{
Xtest -n "$verbose" && \
Xecho "	defining ETCSCREENRC to be \"$prefix/etc/screenrc\""
XDEFS="$DEFS -DETCSCREENRC=\"$prefix/etc/screenrc\""
XSEDDEFS="${SEDDEFS}\${SEDdA}ETCSCREENRC\${SEDdB}ETCSCREENRC\${SEDdC}\"$prefix/etc/screenrc\"\${SEDdD}
X\${SEDuA}ETCSCREENRC\${SEDuB}ETCSCREENRC\${SEDuC}\"$prefix/etc/screenrc\"\${SEDuD}
X\${SEDeA}ETCSCREENRC\${SEDeB}ETCSCREENRC\${SEDeC}\"$prefix/etc/screenrc\"\${SEDeD}
X"
X}
X
Xfi
X
Xif test -n "$prefix"; then
X  test -z "$exec_prefix" && exec_prefix='${prefix}'
X  prsub="s%^prefix\\([ 	]*\\)=\\([ 	]*\\).*$%prefix\\1=\\2$prefix%"
Xfi
Xif test -n "$exec_prefix"; then
X  prsub="$prsub
Xs%^exec_prefix\\([ 	]*\\)=\\([ 	]*\\).*$%exec_prefix\\1=\\2$exec_prefix%"
Xfi
Xcat >conftest.def <<EOF
X$DEFS
XEOF
Xescape_ampersand_and_backslash='s%[&\\]%\\&%g'
XDEFS=`sed "$escape_ampersand_and_backslash" <conftest.def`
Xrm -f conftest.def
X
Xtrap 'rm -f config.status; exit 1' 1 3 15
Xecho creating config.status
Xrm -f config.status
Xcat > config.status <<EOF
X#!/bin/sh
X# Generated automatically by configure.
X# Run this file to recreate the current configuration.
X# This directory was configured as follows,
X# on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
X#
X# $0 $configure_args
X
Xfor arg
Xdo
X  case "\$arg" in
X    -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
X    exec /bin/sh $0 $configure_args ;;
X    *) echo "Usage: config.status --recheck" 2>&1; exit 1 ;;
X  esac
Xdone
X
Xtrap 'rm -fr Makefile doc/Makefile config.h conftest*; exit 1' 1 3 15
XVERSION='$VERSION'
XCC='$CC'
XCPP='$CPP'
XAWK='$AWK'
XINSTALL='$INSTALL'
XINSTALL_PROGRAM='$INSTALL_PROGRAM'
XINSTALL_DATA='$INSTALL_DATA'
XLIBS='$LIBS'
Xsrcdir='$srcdir'
Xprefix='$prefix'
Xexec_prefix='$exec_prefix'
Xprsub='$prsub'
XEOF
Xcat >> config.status <<\EOF
X
Xtop_srcdir=$srcdir
X
X# Allow make-time overrides of the generated file list.
Xtest -n "$gen_files" || gen_files="Makefile doc/Makefile"
X
Xfor file in .. $gen_files; do if [ "x$file" != "x.." ]; then
X  srcdir=$top_srcdir
X  # Remove last slash and all that follows it.  Not all systems have dirname.
X  dir=`echo $file|sed 's%/[^/][^/]*$%%'`
X  if test "$dir" != "$file"; then
X    test "$top_srcdir" != . && srcdir=$top_srcdir/$dir
X    test ! -d $dir && mkdir $dir
X  fi
X  echo creating $file
X  rm -f $file
X  echo "# Generated automatically from `echo $file|sed 's|.*/||'`.in by configure." > $file
X  sed -e "
X$prsub
Xs%@VERSION@%$VERSION%g
Xs%@CC@%$CC%g
Xs%@CPP@%$CPP%g
Xs%@AWK@%$AWK%g
Xs%@INSTALL@%$INSTALL%g
Xs%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g
Xs%@INSTALL_DATA@%$INSTALL_DATA%g
Xs%@LIBS@%$LIBS%g
Xs%@srcdir@%$srcdir%g
Xs%@DEFS@%-DHAVE_CONFIG_H%" $top_srcdir/${file}.in >> $file
Xfi; done
Xtest -n "$gen_config" || gen_config=config.h
Xecho creating $gen_config
X# These sed commands are put into SEDDEFS when defining a macro.
X# They are broken into pieces to make the sed script easier to manage.
X# They are passed to sed as "A NAME B NAME C VALUE D", where NAME
X# is the cpp macro being defined and VALUE is the value it is being given.
X# Each defining turns into a single global substitution command.
X#
X# SEDd sets the value in "#define NAME VALUE" lines.
XSEDdA='s@^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
XSEDdB='\([ 	][ 	]*\)[^ 	]*@\1#\2'
XSEDdC='\3'
XSEDdD='@g'
X# SEDu turns "#undef NAME" with trailing blanks into "#define NAME VALUE".
XSEDuA='s@^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
XSEDuB='\([ 	]\)@\1#\2define\3'
XSEDuC=' '
XSEDuD='\4@g'
X# SEDe turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
XSEDeA='s@^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
XSEDeB='$@\1#\2define\3'
XSEDeC=' '
XSEDeD='@g'
Xrm -f conftest.sed
XEOF
X# Turn off quoting long enough to insert the sed commands.
Xrm -f conftest.sh
Xcat > conftest.sh <<EOF
X$SEDDEFS
XEOF
X
X# Maximum number of lines to put in a single here document.
Xmaxshlines=9
X
X# Break up $SEDDEFS (now in conftest.sh) because some shells have a limit
X# on the size of here documents.
X
Xwhile :
Xdo
X  lines=`grep -c . conftest.sh`
X  if test -z "$lines" || test "$lines" -eq 0; then break; fi
X  rm -f conftest.s1 conftest.s2
X  sed ${maxshlines}q conftest.sh > conftest.s1 # Like head -20.
X  sed 1,${maxshlines}d conftest.sh > conftest.s2 # Like tail +21.
X  # Write a limited-size here document to append to conftest.sed.
X  echo 'cat >> conftest.sed <<CONFEOF' >> config.status
X  cat conftest.s1 >> config.status
X  echo 'CONFEOF' >> config.status
X  rm -f conftest.s1 conftest.sh
X  mv conftest.s2 conftest.sh
Xdone
Xrm -f conftest.sh
X
X# Now back to your regularly scheduled config.status.
Xcat >> config.status <<\EOF
X# This sed command replaces #undef's with comments.  This is necessary, for
X# example, in the case of _POSIX_SOURCE, which is predefined and required
X# on some systems where configure will not decide to define it in
X# config.h.
Xcat >> conftest.sed <<\CONFEOF
Xs,^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*,/* & */,
XCONFEOF
Xrm -f conftest.h
X# Break up the sed commands because old seds have small limits.
Xmaxsedlines=20
Xcp $top_srcdir/$gen_config.in conftest.h1
Xwhile :
Xdo
X  lines=`grep -c . conftest.sed`
X  if test -z "$lines" || test "$lines" -eq 0; then break; fi
X  rm -f conftest.s1 conftest.s2 conftest.h2
X  sed ${maxsedlines}q conftest.sed > conftest.s1 # Like head -20.
X  sed 1,${maxsedlines}d conftest.sed > conftest.s2 # Like tail +21.
X  sed -f conftest.s1 < conftest.h1 > conftest.h2
X  rm -f conftest.s1 conftest.h1 conftest.sed
X  mv conftest.h2 conftest.h1
X  mv conftest.s2 conftest.sed
Xdone
Xrm -f conftest.sed conftest.h
Xecho "/* $gen_config.  Generated automatically by configure.  */" > conftest.h
Xcat conftest.h1 >> conftest.h
Xrm -f conftest.h1
Xif cmp -s $gen_config conftest.h 2>/dev/null; then
X  # The file exists and we would not be changing it.
X  rm -f conftest.h
Xelse
X  rm -f $gen_config
X  mv conftest.h $gen_config
Xfi
X
X
Xexit 0
XEOF
Xchmod +x config.status
Xtest -n "$no_create" || ./config.status
X
X
X# a hook for preserving undef directive in config.h
Xif test -z "$no_create" ; then
Xmv config.h conftest
Xsed -e 's@^\(.*\)defin.\( .*\) .*/\*\(.*KEEP_UNDEF_HERE\)@\1undef\2	/\*\3@' < conftest > config.h
Xrm -f conftest
Xfi
Xcat >> config.status << EOF
Xmv config.h conftest
Xsed -e 's@^\(.*\)defin.\( .*\) .*/\*\(.*KEEP_UNDEF_HERE\)@\1undef\2	/\*\3@' < conftest > config.h
Xrm -f conftest
XEOF
X
Xecho ""
Xif test -z "$AWK"; then
Xecho "!!! Since you have no awk you must copy the files 'comm.h.dist'"
Xecho "!!! and 'term.h.dist' to 'comm.h' and 'term.h'."
Xecho "!!! Do _not_ change the user configuration section in config.h!"
Xecho "Please check the pathnames in the Makefile."
Xelse
Xecho "Now please check the pathnames in the Makefile and the user"
Xecho "configuration section in config.h."
Xfi
Xecho "Then type 'make' to make screen. Good luck."
Xecho ""
END_OF_FILE
if test 53616 -ne `wc -c <'configure'`; then
    echo shar: \"'configure'\" unpacked with wrong size!
fi
chmod +x 'configure'
# end of 'configure'
fi
if test -f 'screen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screen.c'\"
else
echo shar: Extracting \"'screen.c'\" \(50735 characters\)
sed "s/^X//" >'screen.c' <<'END_OF_FILE'
X/* Copyright (c) 1993
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X ****************************************************************
X */
X
X#include "rcs.h"
XRCS_ID("$Id: screen.c,v 1.15 1993/08/05 14:24:06 mlschroe Exp $ FAU")
X
X
X#include <ctype.h>
X#ifdef __sgi
X# include <stdio.h> /* needed before pwd.h to avoid ansi compiler whining */
X#endif /* __sgi */
X
X#include <pwd.h>
X#include <fcntl.h>
X#ifdef sgi
X# include <sys/sysmacros.h>
X#endif /* sgi */
X
X#include <sys/types.h>
X#ifdef ISC
X# include <sys/bsdtypes.h>
X#endif
X#include <sys/stat.h>
X#ifndef sgi
X# include <sys/file.h>
X#endif /* sgi */
X#ifndef sun
X# include <sys/ioctl.h>
X#endif /* sun */
X
X#include <signal.h>
X
X#include "config.h"
X
X#ifdef SHADOWPW
X# include <shadow.h>
X#endif /* SHADOWPW */
X
X#ifdef SVR4
X# include <sys/stropts.h>
X#endif
X
X#ifdef SYSV
X# include <sys/utsname.h>
X#endif
X
X#if defined(sequent) || defined(SVR4)
X# include <sys/resource.h>
X#endif /* sequent || SVR4 */
X
X#ifdef ISC
X# include <sys/tty.h>
X# include <sys/sioctl.h>
X# include <sys/pty.h>
X#endif /* ISC */
X
X#include "screen.h"
X
X#include "patchlevel.h"
X
X
X#ifdef DEBUG
XFILE *dfp;
X#endif
X
X
Xextern char *blank, *null, Term[], screenterm[], **environ, Termcap[];
Xint force_vt = 1, assume_LP = 0;
Xint VBellWait, MsgWait, MsgMinWait, SilenceWait;
X
Xextern struct plop plop_tab[];
Xextern struct user *users;
Xextern struct display *displays, *display; 
Xextern struct layer BlankLayer;
X
X/* tty.c */
Xextern int intrc;
X
X
Xextern int use_hardstatus;
X#ifdef COPY_PASTE
Xextern char mark_key_tab[];
X#endif
Xextern char version[];
Xextern char DefaultShell[];
X
X
Xchar *ShellProg;
Xchar *ShellArgs[2];
X
Xextern struct NewWindow nwin_undef, nwin_default, nwin_options;
X
Xstatic char *MakeWinMsg __P((char *, int));
Xstatic void  SigChldHandler __P((void));
Xstatic sig_t SigChld __P(SIGPROTOARG);
Xstatic sig_t SigInt __P(SIGPROTOARG);
Xstatic sig_t CoreDump __P((int));
Xstatic void  DoWait __P((void));
X
X
X#ifdef PASSWORD
Xextern char Password[];
X#endif
X
X
X/* the attacher */
Xstruct passwd *ppp;
Xchar *attach_tty;
Xchar *attach_term;
Xchar *LoginName;
Xstruct mode attach_Mode;
X
X
X#ifdef SOCKDIR
Xchar *SockDir = SOCKDIR;
X#else
Xchar *SockDir = ".iscreen";
X#endif
Xextern char SockPath[], *SockNamePtr, *SockName;
Xint ServerSocket = -1;
Xchar **NewEnv = NULL;
X
Xchar *RcFileName = NULL;
Xextern char Esc;
Xchar *home;
X
Xchar *screenlogdir = NULL;
Xchar *hardcopydir = NULL;
Xchar *BellString;
Xchar *VisualBellString;
Xchar *ActivityString;
X#ifdef COPY_PASTE
Xchar *BufferFile;
X#endif
X#ifdef POW_DETACH
Xchar *PowDetachString;
X#endif
Xint auto_detach = 1;
Xint iflag, rflag, dflag, lsflag, quietflag, wipeflag, xflag;
Xint adaptflag;
X
Xtime_t Now;
X
X#ifdef MULTIUSER
Xchar *multi;
Xchar *multi_home;
Xint multi_uid;
Xint own_uid;
Xint multiattach;
Xint tty_mode;
Xint tty_oldmode = -1;
X#endif
X
Xchar HostName[MAXSTR];
Xint MasterPid;
Xint real_uid, real_gid, eff_uid, eff_gid;
Xint default_startup;
Xint slowpaste;
Xint ZombieKey;
X
X#ifdef NETHACK
Xint nethackflag = 0;
X#endif
X
X
Xstruct win *fore = NULL;
Xstruct win *windows = NULL;
Xstruct win *console_window;
X
X
X
X/*
X * Do this last
X */
X#include "extern.h"
X
X
X#ifdef NETHACK
Xchar strnomem[] = "Who was that Maude person anyway?";
X#else
Xchar strnomem[] = "Out of memory.";
X#endif
X
X
Xstatic int InterruptPlease = 0;
Xstatic int GotSigChld;
X
X
Xstatic void
Xmkfdsets(rp, wp)
Xfd_set *rp, *wp;
X{
X  register struct win *p;
X
X  FD_ZERO(rp);
X  FD_ZERO(wp);
X  for (display = displays; display; display = display->_d_next)
X    {
X      if (d_obufp != d_obuf)
X	FD_SET(d_userfd, wp);
X
X      FD_SET(d_userfd, rp);	/* Do that always */
X
X      /* read from terminal if there is room in the destination buffer
X       *
X       * Removed, so we can always input a command sequence
X       *
X       * if (d_fore == 0)
X       *   continue;
X       * if (W_UWP(d_fore))
X       *   {
X       *      check pseudowin buffer
X       *      if (d_fore->w_pwin->p_inlen < sizeof(d_fore->w_pwin->p_inbuf))
X       *      FD_SET(d_userfd, rp);
X       *   }
X       * else
X       *   {
X       *     check window buffer
X       *     if (d_fore->w_inlen < sizeof(d_fore->w_inbuf))
X       *     FD_SET(d_userfd, rp);
X       *   }
X       */
X    }
X  for (p = windows; p; p = p->w_next)
X    {
X      if (p->w_ptyfd < 0)
X        continue;
X#ifdef COPY_PASTE
X      if (p->w_pastelen)
X        {
X	  /* paste to win/pseudo */
X# ifdef PSEUDOS
X	  FD_SET(W_UWP(p) ? p->w_pwin->p_ptyfd : p->w_ptyfd, wp);
X# else
X	  FD_SET(p->w_ptyfd, wp);
X# endif
X	}
X#endif
X      /* query window buffer */
X      if (p->w_inlen > 0)
X	FD_SET(p->w_ptyfd, wp);
X#ifdef PSEUDOS
X      /* query pseudowin buffer */
X      if (p->w_pwin && p->w_pwin->p_inlen > 0)
X        FD_SET(p->w_pwin->p_ptyfd, wp);
X#endif
X
X      display = p->w_display;
X      if (p->w_active && d_status && !d_status_bell && !(use_hardstatus && HS))
X	continue;
X      if (p->w_outlen > 0)
X	continue;
X      if (p->w_lay->l_block)
X	continue;
X    /* 
X     * Don't accept input from window or pseudowin if there is to much 
X     * output pending on display .
X     */
X      if (p->w_active && (d_obufp - d_obuf) > d_obufmax)
X	{
X	  debug1("too much output pending, window %d\n", p->w_number);
X	  continue;  
X	}
X#ifdef PSEUDOS
X      if (W_RW(p))
X	{
X	  /* Check free space if we stuff window output in pseudo */
X	  if (p->w_pwin && W_WTOP(p) && (p->w_pwin->p_inlen >= sizeof(p->w_pwin->p_inbuf)))
X	    {
X	      debug2("pseudowin %d buffer full (%d bytes)\n", p->w_number, p->w_pwin->p_inlen);
X	    }
X	  else
X            FD_SET(p->w_ptyfd, rp);
X	}
X      if (W_RP(p))
X	{
X	  /* Check free space if we stuff pseudo output in window */
X	  if (W_PTOW(p) && p->w_inlen >= sizeof(p->w_inbuf))
X	    {
X	      debug2("window %d buffer full (%d bytes)\n", p->w_number, p->w_inlen);
X	    }
X	  else
X            FD_SET(p->w_pwin->p_ptyfd, rp);
X	}
X#else /* PSEUDOS */
X      FD_SET(p->w_ptyfd, rp);
X#endif /* PSEUDOS */
X    }
X  FD_SET(ServerSocket, rp);
X}
X
Xvoid
Xmain(ac, av)
Xint ac;
Xchar **av;
X{
X  register int n, len;
X  register struct win *p;
X  char *ap;
X  char *av0;
X  char socknamebuf[2 * MAXSTR];
X  fd_set r, w;
X  int mflag = 0;
X  struct timeval tv;
X  int nsel;
X  char buf[IOSIZE], *myname = (ac == 0) ? "screen" : av[0];
X  struct stat st;
X  int buflen, tmp;
X#ifdef _MODE_T			/* (jw) */
X  mode_t oumask;
X#else
X  int oumask;
X#endif
X#ifdef SYSV
X  struct utsname utsnam;
X#endif
X  struct NewWindow nwin;
X  int detached = 0;		/* start up detached */
X  struct display *ndisplay;
X#ifdef MULTIUSER
X  char *sockp;
X#endif
X
X  /*
X   *  First, close all unused descriptors
X   *  (otherwise, we might have problems with the select() call)
X   */
X  closeallfiles(0);
X#ifdef DEBUG
X    {
X      char buf[255];
X
X      sprintf(buf, "%s/screen.%d", DEBUGDIR, getpid());
X      (void) mkdir(DEBUGDIR, 0777);
X      if ((dfp = fopen(buf, "w")) == NULL)
X	dfp = stderr;
X      else
X	(void) chmod(buf, 0666);
X    }
X#endif
X  sprintf(version, "%d.%.2d.%.2d%s (%s) %s", REV, VERS,
X	  PATCHLEVEL, STATE, ORIGIN, DATE);
X  debug2("-- screen debug started %s (%s)\n", *av, version);
X#ifdef POSIX
X  debug("POSIX\n");
X#endif
X#ifdef TERMIO
X  debug("TERMIO\n");
X#endif
X#ifdef SYSV
X  debug("SYSV\n");
X#endif
X#ifdef SYSVSIGS
X  debug("SYSVSIGS\n");
X#endif
X#ifdef NAMEDPIPE
X  debug("NAMEDPIPE\n");
X#endif
X#if defined(SIGWINCH) && defined(TIOCGWINSZ)
X  debug("Window changing enabled\n");
X#endif
X#ifdef NOREUID
X  debug("NOREUID\n");
X#endif
X#ifdef hpux
X  debug("hpux\n");
X#endif
X#ifdef USEBCOPY
X  debug("USEBCOPY\n");
X#endif
X#ifdef UTMPOK
X  debug("UTMPOK\n");
X#endif
X#ifdef LOADAV
X  debug("LOADAV\n");
X#endif
X#ifdef NETHACK
X  debug("NETHACK\n");
X#endif
X#ifdef TERMINFO
X  debug("TERMINFO\n");
X#endif
X#ifdef SHADOWPW
X  debug("SHADOWPW\n");
X#endif
X#ifdef NAME_MAX
X  debug1("NAME_MAX = %d\n", NAME_MAX);
X#endif
X
X  BellString = SaveStr("Bell in window %");
X  VisualBellString = SaveStr("   Wuff,  Wuff!!  ");
X  ActivityString = SaveStr("Activity in window %");
X#ifdef COPY_PASTE
X  BufferFile = SaveStr(DEFAULT_BUFFERFILE);
X#endif
X  ShellProg = NULL;
X#ifdef POW_DETACH
X  PowDetachString = 0;
X#endif
X  default_startup = (ac > 1) ? 0 : 1;
X  adaptflag = 0;
X  slowpaste = 0;
X  VBellWait = VBELLWAIT;
X  MsgWait = MSGWAIT;
X  MsgMinWait = MSGMINWAIT;
X  SilenceWait = SILENCEWAIT;
X#ifdef COPY_PASTE
X  CompileKeys((char *)NULL, mark_key_tab);
X#endif
X  nwin = nwin_undef;
X  nwin_options = nwin_undef;
X
X  av0 = *av;
X  /* if this is a login screen, assume -R */
X  if (*av0 == '-')
X    {
X      rflag = 2;
X#ifdef MULTI
X      xflag = 1;
X#endif
X      ShellProg = SaveStr(DefaultShell); /* to prevent nasty circles */
X    }
X  while (ac > 0)
X    {
X      ap = *++av;
X      if (--ac > 0 && *ap == '-')
X	{
X	  switch (ap[1])
X	    {
X	    case 'a':
X	      nwin_options.aflag = 1;
X	      break;
X	    case 'A':
X	      adaptflag = 1;
X	      break;
X	    case 'c':
X	      if (ap[2])
X		RcFileName = ap + 2;
X	      else
X		{
X		  if (--ac == 0)
X		    exit_with_usage(myname);
X		  RcFileName = *++av;
X		}
X	      break;
X	    case 'e':
X	      if (ap[2])
X		ap += 2;
X	      else
X		{
X		  if (--ac == 0)
X		    exit_with_usage(myname);
X		  ap = *++av;
X		}
X	      if (ParseEscape(NULL, ap))
X		Panic(0, "Two characters are required with -e option.");
X	      break;
X	    case 'f':
X	      switch (ap[2])
X		{
X		case 'n':
X		case '0':
X		  nwin_options.flowflag = FLOW_NOW * 0;
X		  break;
X		case 'y':
X		case '1':
X		case '\0':
X		  nwin_options.flowflag = FLOW_NOW * 1;
X		  break;
X		case 'a':
X		  nwin_options.flowflag = FLOW_AUTOFLAG;
X		  break;
X		default:
X		  exit_with_usage(myname);
X		}
X	      break;
X            case 'h':
X	      if (ap[2])
X		nwin_options.histheight = atoi(ap + 2);
X	      else
X		{
X		  if (--ac == 0)
X		    exit_with_usage(myname);
X		  nwin_options.histheight = atoi(*++av);
X		}
X	      if (nwin_options.histheight < 0)
X		exit_with_usage(myname);
X	      break;
X	    case 'i':
X	      iflag = 1;
X	      break;
X	    case 't': /* title is a synonym for AkA */
X	    case 'k':
X	      if (ap[2])
X		nwin_options.aka = ap + 2;
X	      else
X		{
X		  if (--ac == 0)
X		    exit_with_usage(myname);
X		  nwin_options.aka = *++av;
X		}
X	      break;
X	    case 'l':
X	      switch (ap[2])
X		{
X		case 'n':
X		case '0':
X		  nwin_options.lflag = 0;
X		  break;
X		case 'y':
X		case '1':
X		case '\0':
X		  nwin_options.lflag = 1;
X		  break;
X		case 's':
X		case 'i':
X		  lsflag = 1;
X		  if (ac > 1)
X		    {
X		      SockName = *++av;
X		      ac--;
X		    }
X		  break;
X		default:
X		  exit_with_usage(myname);
X		}
X	      break;
X	    case 'w':
X	      lsflag = 1;
X	      wipeflag = 1;
X	      break;
X	    case 'L':
X	      assume_LP = 1;
X	      break;
X	    case 'm':
X	      mflag = 1;
X	      break;
X	    case 'O':
X	      force_vt = 0;
X	      break;
X	    case 'T':
X              if (ap[2])
X		{
X		  if (strlen(ap+2) < 20)
X                    strcpy(screenterm, ap + 2);
X		}
X              else
X                {
X                  if (--ac == 0)
X                    exit_with_usage(myname);
X		  if (strlen(*++av) < 20)
X                    strcpy(screenterm, *av);
X                }
X	      nwin_options.term = screenterm;
X              break;
X	    case 'q':
X	      quietflag = 1;
X	      break;
X	    case 'r':
X	    case 'R':
X#ifdef MULTI
X	    case 'x':
X#endif
X	      if (ap[2])
X		{
X		  SockName = ap + 2;
X		  if (ac != 1)
X		    exit_with_usage(myname);
X		}
X	      else if (ac > 1 && *av[1] != '-')
X		{
X		  SockName = *++av;
X		  ac--;
X		}
X#ifdef MULTI
X	      if (ap[1] == 'x')
X		xflag = 1;
X	      else
X#endif
X	        rflag = (ap[1] == 'r') ? 1 : 2;
X	      break;
X#ifdef REMOTE_DETACH
X	    case 'd':
X	      dflag = 1;
X	      /* FALLTHROUGH */
X	    case 'D':
X	      if (!dflag)
X		dflag = 2;
X	      if (ap[2])
X		SockName = ap + 2;
X	      if (ac == 2)
X		{
X		  if (*av[1] != '-')
X		    {
X		      SockName = *++av;
X		      ac--;
X		    }
X		}
X	      break;
X#endif
X	    case 's':
X	      if (ap[2])
X		{
X		  if (ShellProg)
X		    free(ShellProg);
X		  ShellProg = SaveStr(ap + 2);
X		}
X	      else
X		{
X		  if (--ac == 0)
X		    exit_with_usage(myname);
X		  if (ShellProg)
X		    free(ShellProg);
X		  ShellProg = SaveStr(*++av);
X		}
X	      debug1("ShellProg: '%s'\n", ShellProg);
X	      break;
X	    case 'S':
X	      if (ap[2])
X		SockName = ap + 2;
X	      else
X		{
X		  if (--ac == 0)
X		    exit_with_usage(myname);
X		  SockName = *++av;
X		  if (!*SockName)
X		    exit_with_usage(myname);
X		}
X	      break;
X	    case 'v':
X	      Panic(0, "Screen version %s", version);
X	      /* NOTREACHED */
X	    default:
X	      exit_with_usage(myname);
X	    }
X	}
X      else
X	break;
X    }
X  if (dflag && mflag && SockName && !(rflag || xflag))
X    detached = 1;
X  nwin = nwin_options;
X  if (ac)
X    nwin.args = av;
X  real_uid = getuid();
X  real_gid = getgid();
X  eff_uid = geteuid();
X  eff_gid = getegid();
X  if (eff_uid != real_uid)
X    {		
X      /* if running with s-bit, we must install a special signal
X       * handler routine that resets the s-bit, so that we get a
X       * core file anyway.
X       */
X#ifdef SIGBUS /* OOPS, linux has no bus errors ??? */
X      signal(SIGBUS, CoreDump);
X#endif /* SIGBUS */
X      signal(SIGSEGV, CoreDump);
X    }
X  if (!ShellProg)
X    {
X      register char *sh;
X
X      sh = getenv("SHELL");
X      ShellProg = SaveStr(sh ? sh : DefaultShell);
X    }
X  ShellArgs[0] = ShellProg;
X#ifdef NETHACK
X  nethackflag = (getenv("NETHACKOPTIONS") != NULL);
X#endif
X#ifdef MULTIUSER
X  own_uid = multi_uid = real_uid;
X  if (SockName && (sockp = index(SockName, '/')))
X    {
X      if (eff_uid)
X        Panic(0, "Must run suid root for multi support.");
X      *sockp = 0;
X      multi = SockName;
X      SockName = sockp + 1;
X      if (*multi)
X	{
X	  struct passwd *mppp;
X	  if ((mppp = getpwnam(multi)) == (struct passwd *) 0)
X	    Panic(0, "Cannot identify account '%s'.", multi);
X	  multi_uid = mppp->pw_uid;
X	  multi_home = SaveStr(mppp->pw_dir);
X#ifdef MULTI
X	  if (rflag || lsflag)
X	    {
X	      xflag = 1;
X	      rflag = 0;
X	    }
X#endif
X	  detached = 0;
X	  multiattach = 1;
X	}
X    }
X  if (SockName && *SockName == 0)
X    SockName = 0;
X#endif
X  if ((LoginName = getlogin()) && LoginName[0] != '\0')
X    {
X      if ((ppp = getpwnam(LoginName)) != (struct passwd *) 0)
X	if (ppp->pw_uid != real_uid)
X	  ppp = (struct passwd *) 0;
X    }
X  if (ppp == 0)
X    {
X      if ((ppp = getpwuid(real_uid)) == 0)
X        {
X#ifdef NETHACK
X          if (nethackflag)
X	    Panic(0, "An alarm sounds through the dungeon...\nWarning, the kops are coming.");
X	  else
X#endif
X	  Panic(0, "getpwuid() can't identify your account!");
X	  exit(1);
X        }
X      LoginName = ppp->pw_name;
X    }
X  home = getenv("HOME");	/* may or may not return a result. jw. */
X#if !defined(SOCKDIR) && defined(MULTIUSER)
X  if (multi && !multiattach)
X    {
X      if (home && strcmp(home, ppp->pw_dir))
X        Panic(0, "$HOME must match passwd entry for multi screens");
X    }
X#endif
X  if (home == 0 || *home == '\0')
X    home = ppp->pw_dir;
X  if (strlen(LoginName) > 20)
X    Panic(0, "LoginName too long - sorry.");
X  if (strlen(home) > MAXPATHLEN - 25)
X    Panic(0, "$HOME too long - sorry.");
X#ifdef PASSWORD
X  strcpy(Password, ppp->pw_passwd);
X#endif
X
X  if (!detached && !lsflag)
X    {
X      /* ttyname implies isatty */
X      if (!(attach_tty = ttyname(0)))
X	{
X#ifdef NETHACK
X	  if (nethackflag)
X	    Panic(0, "You must play from a terminal.");
X	  else
X#endif
X	  Panic(0, "Must be connected to a terminal.");
X	  exit(1);
X	}
X      if (strlen(attach_tty) >= MAXPATHLEN)
X	Panic(0, "TtyName too long - sorry.");
X      if (stat(attach_tty, &st))
X	Panic(errno, "Cannot access '%s'", attach_tty);
X#ifdef MULTIUSER
X      tty_mode = st.st_mode & 0777;
X#endif
X      if ((n = secopen(attach_tty, O_RDWR, 0)) < 0)
X	Panic(0, "Cannot open '%s' - please check.", attach_tty);
X      close(n);
X      debug1("attach_tty is %s\n", attach_tty);
X      if ((attach_term = getenv("TERM")) == 0)
X	Panic(0, "Please set a terminal type.");
X      if (strlen(attach_term) > sizeof(d_termname) - 1)
X	Panic(0, "$TERM too long - sorry.");
X      GetTTY(0, &attach_Mode);
X#ifdef DEBUGGGGGGGGGGGGGGG
X      DebugTTY(&attach_Mode);
X#endif /* DEBUG */
X    }
X  
X#ifdef _MODE_T
X  oumask = umask(0);		/* well, unsigned never fails? jw. */
X#else
X  if ((oumask = umask(0)) == -1)
X    Panic(errno, "Cannot change umask to zero");
X#endif
X  if ((SockDir = getenv("ISCREENDIR")) == NULL)
X    SockDir = getenv("SCREENDIR");
X  if (SockDir)
X    {
X      if (strlen(SockDir) >= MAXPATHLEN - 1)
X	Panic(0, "Ridiculously long $(I)SCREENDIR - try again.");
X#ifdef MULTIUSER
X      if (multi)
X	Panic(0, "No $(I)SCREENDIR with multi screens, please.");
X#endif
X    }
X#ifdef MULTIUSER
X  if (multiattach)
X    {
X# ifndef SOCKDIR
X      sprintf(SockPath, "%s/.iscreen", multi_home);
X      SockDir = SockPath;
X# else
X      SockDir = SOCKDIR;
X      sprintf(SockPath, "%s/S-%s", SockDir, multi);
X# endif
X    }
X  else
X#endif
X    {
X#ifndef SOCKDIR
X      if (SockDir == 0)
X	{
X	  sprintf(SockPath, "%s/.iscreen", home);
X	  SockDir = SockPath;
X	}
X#endif
X      if (SockDir)
X	{
X	  if (access(SockDir, F_OK))
X	    {
X	      debug1("SockDir '%s' missing ...\n", SockDir);
X	      if (UserContext() > 0)
X		{
X		  if (mkdir(SockDir, 0700))
X		    UserReturn(0);
X		  UserReturn(1);
X		}
X	      if (UserStatus() <= 0)
X		Panic(0, "Cannot make directory '%s'.", SockDir);
X	    }
X	  if (SockDir != SockPath)
X	    strcpy(SockPath, SockDir);
X	}
X#ifdef SOCKDIR
X      else
X	{
X	  SockDir = SOCKDIR;
X	  if (stat(SockDir, &st))
X	    {
X	      if (mkdir(SockDir, eff_uid ? 0777 : 0755) == -1)
X		Panic(errno, "Cannot make directory '%s'", SockDir);
X	    }
X	  else
X	    {
X	      n = eff_uid ? 0777 : 0755;
X	      if ((st.st_mode & 0777) != n)
X		Panic(0, "Directory '%s' must have mode %03o.", SockDir, n);
X	    }
X	  sprintf(SockPath, "%s/S-%s", SockDir, LoginName);
X	  if (access(SockPath, F_OK))
X	    {
X	      if (mkdir(SockPath, 0700) == -1)
X		Panic(errno, "Cannot make directory '%s'", SockPath);
X	      (void) chown(SockPath, real_uid, real_gid);
X	    }
X	}
X#endif
X    }
X
X  if (stat(SockPath, &st) == -1)
X    {
X      Panic(errno, "Cannot access %s", SockPath);
X    }
X  else
X    {
X#ifdef _POSIX_SOURCE
X      if (S_ISDIR(st.st_mode) == 0)
X#else
X      if ((st.st_mode & S_IFMT) != S_IFDIR)
X#endif
X	Panic(0, "%s is not a directory.", SockPath);
X#ifdef MULTIUSER
X      if (multi)
X	{
X	  if (st.st_uid != multi_uid)
X	    Panic(0, "%s is not the owner of %s.", multi, SockPath);
X	}
X      else
X#endif
X	{
X	  if (st.st_uid != real_uid)
X	    Panic(0, "You are not the owner of %s.", SockPath);
X	}
X      if ((st.st_mode & 0777) != 0700)
X	Panic(0, "Directory %s must have mode 700.", SockPath);
X    }
X  strcat(SockPath, "/");
X  SockNamePtr = SockPath + strlen(SockPath);
X  (void) umask(oumask);
X  debug2("SockPath: %s  SockName: %s\n", SockPath, SockName ? SockName : "NULL");
X
X#if defined(SYSV) && !defined(ISC)
X  if (uname(&utsnam) == -1)
X    Panic(0, "uname() failed, errno = %d.", errno);
X  else
X    {
X      strncpy(HostName, utsnam.nodename, MAXSTR);
X      HostName[(sizeof(utsnam.nodename) <= MAXSTR) ? 
X               sizeof(utsnam.nodename) : MAXSTR] = '\0';
X    }
X#else
X  (void) gethostname(HostName, MAXSTR);
X#endif
X  HostName[MAXSTR - 1] = '\0';
X  if ((ap = index(HostName, '.')) != NULL)
X    *ap = '\0';
X
X  if (lsflag)
X    {
X      int i;
X
X#ifdef MULTIUSER
X      if (multi)
X	real_uid = multi_uid;
X      setuid(real_uid);
X      setgid(real_gid);
X      eff_uid = real_uid;
X      eff_gid = real_gid;
X#endif
X      i = FindSocket(0, (int *)NULL);
X      /* MakeClientSocket appended the last (Sock)Name there: */
X      *SockNamePtr = '\0';
X      if (i == 0)
X	{
X#ifdef NETHACK
X          if (nethackflag)
X	    Panic(0, "This room is empty (%s).\n", SockPath);
X          else
X#endif /* NETHACK */
X          Panic(0, "No Sockets found in %s.\n", SockPath);
X        }
X      Panic(0, "%d Socket%s in %s.\n", i, i > 1 ? "s" : "", SockPath);
X      /* NOTREACHED */
X    }
X  signal(SIG_BYE, AttacherFinit);	/* prevent races */
X  if (rflag || xflag)
X    {
X      debug("screen -r: - is there anybody out there?\n");
X#ifdef SHADOWPW
X      setspent();  /* open shadow file while we are still root */
X#endif /* SHADOWPW */
X      if (Attach(MSG_ATTACH))
X	{
X	  Attacher();
X	  /* NOTREACHED */
X	}
X      debug("screen -r: backend not responding -- still crying\n");
X    }
X  else if (dflag && !mflag)
X    {
X      (void) Attach(MSG_DETACH);
X      Msg(0, "[%s %sdetached.]\n", SockName, (dflag > 1 ? "power " : ""));
X      eexit(0);
X      /* NOTREACHED */
X    }
X  if (!SockName && !mflag)
X    {
X      register char *sty;
X      int s;
X
X      if ((sty = getenv("STY")) != 0 && *sty != '\0')
X	{
X	  setuid(real_uid);
X	  setgid(real_gid);
X	  eff_uid = real_uid;
X	  eff_gid = real_gid;
X	  if ((s = MakeClientSocket(1, sty)) > 0)
X	    {
X	      nwin_options.args = av;
X	      SendCreateMsg(s, &nwin);
X	      close(s);
X	    }
X	  exit(0);
X	  /* NOTREACHED */
X	}
X    }
X  nwin_compose(&nwin_default, &nwin_options, &nwin_default);
X  if (SockName && !*SockName)
X    SockName = NULL;
X  switch (MasterPid = fork())
X    {
X    case -1:
X      Panic(errno, "fork");
X      /* NOTREACHED */
X#ifdef FORKDEBUG
X    default:
X      break;
X    case 0:
X      MasterPid = getppid();
X#else
X    case 0:
X      break;
X    default:
X#endif
X      if (detached)
X        exit(0);
X      if (SockName)
X	{
X	  /* user started us with -S option */
X	  sprintf(socknamebuf, "%d.%s", MasterPid, SockName);
X	}
X      else
X	{
X	  sprintf(socknamebuf, "%d.%s.%s", MasterPid, stripdev(attach_tty),
X		  HostName);
X	}
X      for (ap = socknamebuf; *ap; ap++)
X	if (*ap == '/')
X	  *ap = '-';
X      SockName = socknamebuf;
X#ifdef SHADOWPW
X      setspent();  /* open shadow file while we are still root */
X#endif /* SHADOWPW */
X      setuid(real_uid);
X      setgid(real_gid);
X      eff_uid = real_uid;
X      eff_gid = real_gid;
X      Attacher();
X      /* NOTREACHED */
X    }
X
X  ap = av0 + strlen(av0) - 1;
X  while (ap >= av0)
X    {
X      if (!strncmp("screen", ap, 6))
X	{
X	  strncpy(ap, "SCREEN", 6); /* name this process "SCREEN-BACKEND" */
X	  break;
X	}
X      ap--;
X    }
X  if (ap < av0)
X    *av0 = 'S';
X
X#ifdef DEBUG
X  {
X    char buf[256];
X
X    if (dfp && dfp != stderr)
X      fclose(dfp);
X    sprintf(buf, "%s/SCREEN.%d", DEBUGDIR, getpid());
X    if ((dfp = fopen(buf, "w")) == NULL)
X      dfp = stderr;
X    else
X      (void) chmod(buf, 0666);
X  }
X#endif
X  if (!detached)
X    n = dup(0);
X  else
X    n = -1;
X  freopen("/dev/null", "r", stdin);
X  freopen("/dev/null", "w", stdout);
X#ifdef DEBUG
X  if (dfp != stderr)
X#endif
X  freopen("/dev/null", "w", stderr);
X  debug("-- screen.back debug started\n");
X
X  if (!detached)
X    {
X#ifdef FORKDEBUG
X      if (MakeDisplay(LoginName, attach_tty, attach_term, n, MasterPid, &attach_Mode) == 0)
X#else
X      if (MakeDisplay(LoginName, attach_tty, attach_term, n, getppid(), &attach_Mode) == 0)
X#endif
X	Panic(0, "Could not alloc display");
X    }
X
X  if (SockName)
X    {
X      /* user started us with -S option */
X      sprintf(socknamebuf, "%d.%s", getpid(), SockName);
X    }
X  else
X    {
X      sprintf(socknamebuf, "%d.%s.%s", getpid(), stripdev(attach_tty),
X	      HostName);
X    }
X  for (ap = socknamebuf; *ap; ap++)
X    if (*ap == '/')
X      *ap = '-';
X  SockName = socknamebuf;
X  ServerSocket = MakeServerSocket();
X#ifdef ETCSCREENRC
X# ifdef ALLOW_SYSSCREENRC
X  if ((ap = getenv("SYSSCREENRC")))
X    StartRc(ap);
X  else
X# endif
X    StartRc(ETCSCREENRC);
X#endif
X  StartRc(RcFileName);
X# ifdef UTMPOK
X#  ifndef UTNOKEEP
X  InitUtmp(); 
X#  endif /* UTNOKEEP */
X# endif /* UTMPOK */
X  if (display)
X    {
X      if (InitTermcap(0, 0))
X	{
X	  debug("Could not init termcap - exiting\n");
X	  fcntl(d_userfd, F_SETFL, 0);	/* Flush sets NDELAY */
X	  freetty();
X	  if (d_userpid)
X	    Kill(d_userpid, SIG_BYE);
X	  eexit(1);
X	}
X      InitTerm(0);
X#ifdef UTMPOK
X      RemoveLoginSlot();
X#endif
X    }
X  else
X    {
X      MakeTermcap(1);
X    }
X#ifdef LOADAV
X  InitLoadav();
X#endif /* LOADAV */
X  MakeNewEnv();
X  signal(SIGHUP, SigHup);
X  signal(SIGINT, Finit);
X  signal(SIGQUIT, Finit);
X  signal(SIGTERM, Finit);
X#ifdef BSDJOBS
X  signal(SIGTTIN, SIG_IGN);
X  signal(SIGTTOU, SIG_IGN);
X#endif
X  InitKeytab();
X  if (display)
X    {
X      brktty(d_userfd);
X      SetMode(&d_OldMode, &d_NewMode);
X      /* Note: SetMode must be called _before_ FinishRc. */
X      SetTTY(d_userfd, &d_NewMode);
X      if (fcntl(d_userfd, F_SETFL, FNDELAY))
X	Msg(errno, "Warning: NDELAY fcntl failed");
X    }
X  else
X    brktty(-1);		/* just try */
X#ifdef ETCSCREENRC
X# ifdef ALLOW_SYSSCREENRC
X  if ((ap = getenv("SYSSCREENRC")))
X    FinishRc(ap);
X  else
X# endif
X    FinishRc(ETCSCREENRC);
X#endif
X  FinishRc(RcFileName);
X
X  debug2("UID %d  EUID %d\n", getuid(), geteuid());
X  if (windows == NULL)
X    {
X      debug("We open one default window, as screenrc did not specify one.\n");
X      if (MakeWindow(&nwin) == -1)
X	{
X	  AddStr("Sorry, could not find a PTY.");
X	  sleep(2);
X	  Finit(0);
X	  /* NOTREACHED */
X	}
X    }
X  if (default_startup)
X    display_copyright();
X  signal(SIGCHLD, SigChld);
X  signal(SIGINT, SigInt);
X  tv.tv_usec = 0;
X  if (rflag == 2)
X    {
X#ifdef NETHACK
X      if (nethackflag)
X        Msg(0, "I can't seem to find a... Hey, wait a minute!  Here comes a screen now.");
X      else
X#endif
X      Msg(0, "New screen...");
X      rflag = 0;
X    }
X
X  Now = time((time_t *)0);
X
X  for (;;)
X    {
X      tv.tv_sec = 0;
X      /*
X       * check for silence
X       */
X      for (p = windows; p; p = p->w_next)
X        {
X	  int time_left;
X
X	  if (p->w_tstamp.seconds == 0)
X	    continue;
X	  debug1("checking silence win %d\n", p->w_number);
X	  time_left = p->w_tstamp.lastio + p->w_tstamp.seconds - Now;
X	  if (time_left > 0)
X	    {
X	      if (tv.tv_sec == 0 || time_left < tv.tv_sec)
X	        tv.tv_sec = time_left;
X	    }
X	  else
X	    {
X	      for (display = displays; display; display = display->_d_next)
X	        if (p != d_fore)
X		  Msg(0, "Window %d: silence for %d seconds", 
X		      p->w_number, p->w_tstamp.seconds);
X	      p->w_tstamp.lastio = Now;
X	    }
X	}
X
X      /*
X       * check to see if message line should be removed
X       */
X      for (display = displays; display; display = display->_d_next)
X	{
X	  int time_left;
X
X	  if (d_status == 0)
X	    continue;
X	  debug("checking status...\n");
X	  time_left = d_status_time + (d_status_bell?VBellWait:MsgWait) - Now;
X	  if (time_left > 0)
X	    {
X	      if (tv.tv_sec == 0 || time_left < tv.tv_sec)
X	        tv.tv_sec = time_left;
X	      debug(" not yet.\n");
X	    }
X	  else
X	    {
X	      debug(" removing now.\n");
X	      RemoveStatus();
X	    }
X	}
X      /*
X       * check for I/O on all available I/O descriptors
X       */
X#ifdef DEBUG
X      if (tv.tv_sec)
X        debug1("select timeout %d seconds\n", tv.tv_sec);
X#endif
X      mkfdsets(&r, &w);
X      if (GotSigChld && !tv.tv_sec)
X	{
X	  SigChldHandler();
X	  continue;
X	}
X      if ((nsel = select(FD_SETSIZE, &r, &w, (fd_set *)0, tv.tv_sec ? &tv : (struct timeval *) 0)) < 0)
X	{
X	  debug1("Bad select - errno %d\n", errno);
X	  if (errno != EINTR)
X	    Panic(errno, "select");
X	  errno = 0;
X	  nsel = 0;
X	}
X#ifdef SELECT_BROKEN
X      /* 
X       * Sequents select emulation counts an descriptor which is
X       * readable and writeable only as one. waaaaa.
X       */
X      if (nsel)
X	nsel = 2 * FD_SETSIZE;
X#endif
X      if (GotSigChld && !tv.tv_sec)
X	{
X	  SigChldHandler();
X	  continue;
X	}
X      if (InterruptPlease)
X	{
X	  debug("Backend received interrupt\n");
X	  if (fore)
X	    {
X	      char ibuf;
X	      ibuf = intrc;
X#ifdef PSEUDOS
X	      write(W_UWP(fore) ? fore->w_pwin->p_ptyfd : fore->w_ptyfd, 
X		    &ibuf, 1);
X	      debug1("Backend wrote interrupt to %d", fore->w_number);
X	      debug1("%s\n", W_UWP(fore) ? " (pseudowin)" : "");
X#else
X	      write(fore->w_ptyfd, &ibuf, 1);
X	      debug1("Backend wrote interrupt to %d\n", fore->w_number);
X#endif
X	    }
X	  InterruptPlease = 0;
X	}
X
X      /*
X       *   Process a client connect attempt and message
X       */
X      if (nsel && FD_ISSET(ServerSocket, &r))
X	{
X          nsel--;
X	  debug("Knock - knock!\n");
X	  ReceiveMsg();
X	  continue;
X	}
X
X      /*
X       * Write the (already processed) user input to the window
X       * descriptors first. We do not want to choke, if he types fast.
X       */
X      if (nsel)
X	{
X	  for (p = windows; p; p = p->w_next)
X	    {
X	      int pastefd = -1;
X
X	      if (p->w_ptyfd < 0)
X	        continue;
X#ifdef COPY_PASTE
X	      if (p->w_pastelen)
X		{
X		  /*
X		   *  Write the copybuffer contents first, if any.
X		   */
X#ifdef PSEUDOS
X		  pastefd = W_UWP(p) ? p->w_pwin->p_ptyfd : p->w_ptyfd;
X#else
X		  pastefd = p->w_ptyfd;
X#endif
X		  if (FD_ISSET(pastefd, &w))
X		    {
X		      debug1("writing pastebuffer (%d)\n", p->w_pastelen);
X		      len = write(pastefd, p->w_pasteptr, 
X				  (slowpaste > 0) ? 1 :
X				  (p->w_pastelen > IOSIZE ? 
X				   IOSIZE : p->w_pastelen));
X		      if (len < 0)	/* Problems... window is dead */
X			p->w_pastelen = 0;
X		      if (len > 0)
X			{
X			  p->w_pasteptr += len;
X			  p->w_pastelen -= len;
X			}
X		      debug1("%d bytes pasted\n", len);
X		      if (p->w_pastelen == 0)
X			{
X			  if (p->w_pastebuf)
X			    free(p->w_pastebuf);
X			  p->w_pasteptr = 0;
X			  pastefd = -1;
X			}
X		      if (slowpaste > 0)
X			{
X			  struct timeval t;
X
X			  debug1("slowpaste %d\n", slowpaste);
X			  t.tv_sec = (long) (slowpaste / 1000);
X			  t.tv_usec = (long) ((slowpaste % 1000) * 1000);
X			  select(0, (fd_set *)0, (fd_set *)0, (fd_set *)0, &t);
X			}
X		      if (--nsel == 0)
X		        break;
X		    }
X		}
X#endif
X
X#ifdef PSEUDOS
X	      if (p->w_pwin && p->w_pwin->p_inlen > 0)
X	        {
X		  /* stuff w_pwin->p_inbuf into pseudowin */
X		  tmp = p->w_pwin->p_ptyfd;
X		  if (tmp != pastefd && FD_ISSET(tmp, &w))
X		    {
X		      if ((len = write(tmp, p->w_pwin->p_inbuf, 
X				       p->w_pwin->p_inlen)) > 0)
X		        {
X			  if ((p->w_pwin->p_inlen -= len))
X			    bcopy(p->w_pwin->p_inbuf + len, p->w_pwin->p_inbuf,
X			    	  p->w_pwin->p_inlen);
X			}
X		      if (--nsel == 0)
X		        break;
X		    }
X		}
X#endif
X	      if (p->w_inlen > 0)
X		{
X		  /* stuff w_inbuf buffer into window */
X		  tmp = p->w_ptyfd;
X		  if (tmp != pastefd && FD_ISSET(tmp, &w))
X		    {
X		      if ((len = write(tmp, p->w_inbuf, p->w_inlen)) > 0)
X			{
X			  if ((p->w_inlen -= len))
X			    bcopy(p->w_inbuf + len, p->w_inbuf, p->w_inlen);
X			}
X		      if (--nsel == 0)
X			break;
X		    }
X		}
X	    }
X	}
X      
X      Now = time((time_t *)0);
X
X      if (nsel)
X	{
X	  for (display = displays; display; display = ndisplay)
X	    {
X	      int maxlen;
X
X	      ndisplay = display->_d_next;
X	      /* 
X	       * stuff d_obuf into user's tty
X	       */
X	      if (FD_ISSET(d_userfd, &w)) 
X		{
X		  int size = OUTPUT_BLOCK_SIZE;
X
X		  len = d_obufp - d_obuf;
X		  if (len < size)
X		    size = len;
X		  ASSERT(len >= 0);
X		  size = write(d_userfd, d_obuf, size);
X		  if (size >= 0) 
X		    {
X		      len -= size;
X		      if (len)
X		        {
X			  bcopy(d_obuf + size, d_obuf, len);
X		          debug2("ASYNC: wrote %d - remaining %d\n", size, len);
X			}
X		      d_obufp -= size;
X		      d_obuffree += size;
X		    } 
X		  else
X		    {
X		      if (errno != EINTR)
X# ifdef EWOULDBLOCK
X			if (errno != EWOULDBLOCK)
X# endif
X			Msg(errno, "Error writing output to display");
X		    }
X		  if (--nsel == 0)
X		    break;
X		}
X	      /*
X	       * O.k. All streams are fed, now look what comes back
X	       * to us. First of all: user input.
X	       */
X	      if (! FD_ISSET(d_userfd, &r))
X		continue;
X	      if (d_status && !(use_hardstatus && HS))
X		RemoveStatus();
X	      if (d_fore == 0)
X		maxlen = IOSIZE;
X	      else
X		{
X#ifdef PSEUDOS
X		  if (W_UWP(d_fore))
X		    maxlen = sizeof(d_fore->w_pwin->p_inbuf) - d_fore->w_pwin->p_inlen;
X		  else
X#endif
X		    maxlen = sizeof(d_fore->w_inbuf) - d_fore->w_inlen;
X		}
X	      if (maxlen > IOSIZE)
X		maxlen = IOSIZE;
X	      if (maxlen <= 0)
X		maxlen = 1;	/* Allow one char for command keys */
X	      if (d_ESCseen)
X		{
X		  if (maxlen == 1)
X		    maxlen = 2;	/* Allow one char for command keys */
X		  buf[0] = d_user->u_Esc;
X		  buflen = read(d_userfd, buf + 1, maxlen - 1) + 1;
X		  d_ESCseen = 0;
X		}
X	      else
X		buflen = read(d_userfd, buf, maxlen);
X	      if (buflen < 0)
X		{
X		  if (errno == EINTR)
X		    continue;
X		  debug1("Read error: %d - SigHup()ing!\n", errno);
X		  SigHup(SIGARG);
X		  sleep(1);
X		}
X	      else if (buflen == 0)
X		{
X		  debug("Found EOF - SigHup()ing!\n");
X		  SigHup(SIGARG);
X		  sleep(1);
X		}
X	      else
X		{
X	          /* This refills inbuf or p_inbuf */
X	          ProcessInput(buf, buflen);
X		}
X	      if (--nsel == 0)
X		break;
X	    }
X	}
X	
X      /* 
X       * Read and process the output from the window descriptors 
X       */ 
X      for (p = windows; p; p = p->w_next) 
X	{
X	  if (p->w_lay->l_block)
X	    continue;
X	  display = p->w_display;
X	  if (p->w_outlen)
X	    WriteString(p, p->w_outbuf, p->w_outlen);
X	  else if (p->w_ptyfd >= 0)
X	    {
X#ifdef PSEUDOS
X	      /* gather pseudowin output */
X	      if (W_RP(p) && nsel && FD_ISSET(p->w_pwin->p_ptyfd, &r))
X	        {
X		  nsel--;
X		  n = 0;
X		  if (W_PTOW(p))
X		    {
X		      /* Window wants a copy of the pseudowin output */
X		      tmp = sizeof(p->w_inbuf) - p->w_inlen;
X		      ASSERT(tmp > 0);
X		      n++;
X		    }
X		  else
X		    tmp = IOSIZE;
X		  if ((len = read(p->w_pwin->p_ptyfd, buf, tmp)) <= 0)
X		    {
X		      if (errno != EINTR)
X#ifdef EWOULDBLOCK
X		        if (errno != EWOULDBLOCK)
X#endif
X			  {
X			    debug2("Window %d: pseudowin read error (errno %d) -- removing pseudowin\n", p->w_number, len ? errno : 0);
X			    FreePseudowin(p);
X			  }
X		    }
X/* HERE WE ASSUME THAT THERE IS NO PACKET MODE ON PSEUDOWINS */
X		  else
X		    {
X		      if (n)
X			{
X			  bcopy(buf, p->w_inbuf + p->w_inlen, len);
X			  p->w_inlen += len;
X			}
X		      WriteString(p, buf, len);
X		    }
X		}
X#endif /* PSEUDOS */
X	      /* gather window output */
X	      if (nsel && FD_ISSET(p->w_ptyfd, &r))
X		{
X		  nsel--;
X#ifdef PSEUDOS
X		  n = 0;
X		  ASSERT(W_RW(p));
X		  if (p->w_pwin && W_WTOP(p))
X		    {
X		      /* Pseudowin wants a copy of the window output */
X		      tmp = sizeof(p->w_pwin->p_inbuf) - p->w_pwin->p_inlen;
X		      ASSERT(tmp > 0);
X		      n++;
X		    }
X		  else
X#endif
X		    tmp = IOSIZE;
X		  if ((len = read(p->w_ptyfd, buf, tmp)) <= 0)
X		    {
X		      if (errno == EINTR)
X			continue;
X#ifdef EWOULDBLOCK
X		      if (errno == EWOULDBLOCK)
X			continue;
X#endif
X		      debug2("Window %d: read error (errno %d) - killing window\n", p->w_number, len ? errno : 0);
X		      if (ZombieKey)
X			{
X			  debug3("window %d (%s) going into zombie state fd %d",
X				 p->w_number, p->w_title, p->w_ptyfd);
X			  p->w_ptyfd = -1;
X			  debug("changed to -1\n");
X			}
X		      else
X		        KillWindow(p);
X		      nsel = 0;	/* KillWindow may change window order */
X		      break;	/* so we just break */
X		    }
X#ifdef TIOCPKT
X		  if ((p->w_t.flags & TTY_FLAG_PLAIN) == 0)
X		    {
X		      if (buf[0])
X			{
X			  debug1("PAKET %x\n", buf[0]);
X			  if (buf[0] & TIOCPKT_NOSTOP)
X			    NewAutoFlow(p, 0);
X			  if (buf[0] & TIOCPKT_DOSTOP)
X			    NewAutoFlow(p, 1);
X			}
X		      if (len > 1)
X			{
X#ifdef PSEUDOS
X			  if (n)
X			    {
X			      bcopy(buf + 1, 
X				    p->w_pwin->p_inbuf + p->w_pwin->p_inlen,
X				    len - 1);
X			      p->w_pwin->p_inlen += len - 1;
X			    }
X#endif
X			  WriteString(p, buf + 1, len - 1);
X			}
X		    }
X		  else
X#endif /* TIOCPKT */
X		    {
X		      if (len > 0)
X			{
X#ifdef PSEUDOS
X			  if (n)
X			    {
X			      bcopy(buf, p->w_pwin->p_inbuf + p->w_pwin->p_inlen,
X				    len);
X			      p->w_pwin->p_inlen += len;
X			    }
X#endif
X			  WriteString(p, buf, len);
X			}
X		    }
X		}
X	    }
X	  if (p->w_bell == BELL_ON)
X	    {
X	      p->w_bell = BELL_MSG;
X	      for (display = displays; display; display = display->_d_next)
X	        Msg(0, MakeWinMsg(BellString, p->w_number));
X	      if (p->w_monitor == MON_FOUND)
X		p->w_monitor = MON_DONE;
X	    }
X	  else if (p->w_bell == BELL_VISUAL)
X	    {
X	      if (display && !d_status_bell)
X		{
X		  /*
X		   * Stop the '!' appearing in the ^A^W display if it is an 
X		   * active at the time of the bell. (Tim MacKenzie)
X		   */
X		  p->w_bell = BELL_OFF; 
X		  Msg(0, VisualBellString);
X		  if (d_status)
X		    d_status_bell = 1;
X		}
X	    }
X	  if (p->w_monitor == MON_FOUND)
X	    {
X	      p->w_monitor = MON_MSG;
X	      for (display = displays; display; display = display->_d_next)
X	        Msg(0, MakeWinMsg(ActivityString, p->w_number));
X	    }
X	}
X#if defined(DEBUG) && !defined(_SEQUENT_)
X      if (nsel)
X	debug1("*** Left over nsel: %d\n", nsel);
X#endif
X    }
X  /* NOTREACHED */
X}
X
Xstatic void
XSigChldHandler()
X{
X  struct stat st;
X  while (GotSigChld)
X    {
X      GotSigChld = 0;
X      DoWait();
X#ifdef SYSVSIGS
X      signal(SIGCHLD, SigChld);
X#endif
X    }
X  if (stat(SockPath, &st) == -1)
X    {
X      debug1("SigChldHandler: Yuck! cannot stat '%s'\n", SockPath);
X      if (!RecoverSocket())
X	{
X	  debug("SCREEN cannot recover from corrupt Socket, bye\n");
X	  Finit(1);
X	}
X      else
X	debug1("'%s' reconstructed\n", SockPath);
X    }
X  else
X    debug2("SigChldHandler: stat '%s' o.k. (%03o)\n", SockPath, st.st_mode);
X}
X
Xstatic sig_t
XSigChld(SIGDEFARG)
X{
X  debug("SigChld()\n");
X  GotSigChld = 1;
X#ifndef SIGVOID
X  return((sig_t) 0);
X#endif
X}
X
Xsig_t
XSigHup(SIGDEFARG)
X{
X  if (display == 0)
X    return;
X  debug("SigHup()\n");
X  if (d_userfd >= 0)
X    {
X      close(d_userfd);
X      d_userfd = -1;
X    }
X  if (auto_detach || displays->_d_next)
X    Detach(D_DETACH);
X  else
X    Finit(0);
X#ifndef SIGVOID
X  return((sig_t) 0);
X#endif
X}
X
X/* 
X * the backend's Interrupt handler
X * we cannot d_insert the intrc directly, as we never know
X * if fore is valid.
X */
Xstatic sig_t
XSigInt(SIGDEFARG)
X{
X#if HAZARDOUS
X  char buf[1];
X
X  debug("SigInt()\n");
X  *buf = (char) intrc;
X  if (fore)
X    fore->w_inlen = 0;
X  if (fore)
X    write(fore->w_ptyfd, buf, 1);
X#else
X  signal(SIGINT, SigInt);
X  debug("SigInt() careful\n");
X  InterruptPlease = 1;
X#endif
X#ifndef SIGVOID
X  return((sig_t) 0);
X#endif
X}
X
Xstatic sig_t
XCoreDump(sig)
Xint sig;
X{
X  struct display *disp;
X  char buf[80];
X
X#ifdef SYSVSIGS
X  signal(sig, SIG_IGN);
X#endif /* SYSV */
X  setgid(getgid());
X  setuid(getuid());
X  unlink("core");
X  sprintf(buf, "\r\n[screen caught signal %d.%s]\r\n", sig,
X#if defined(SHADOWPW) && !defined(DEBUG) && !defined(DUMPSHADOW)
X              ""
X#else /* SHADOWPW  && !DEBUG */
X              " (core dumped)"
X#endif /* SHADOWPW  && !DEBUG */
X              );
X  for (disp = displays; disp; disp = disp->_d_next)
X    {
X      fcntl(disp->_d_userfd, F_SETFL, 0);
X      write(disp->_d_userfd, buf, strlen(buf));
X      Kill(disp->_d_userpid, SIG_BYE);
X    }
X#if defined(SHADOWPW) && !defined(DEBUG) && !defined(DUMPSHADOW)
X  eexit(sig);
X#else /* SHADOWPW && !DEBUG */
X  abort();
X#endif /* SHADOWPW  && !DEBUG */
X#ifndef SIGVOID
X  return((sig_t) 0);
X#endif
X}
X
Xstatic void
XDoWait()
X{
X  register int pid;
X  struct win *p, *next;
X#ifdef BSDWAIT
X  union wait wstat;
X#else
X  int wstat;
X#endif
X
X#ifdef BSDJOBS
X# ifndef BSDWAIT
X  while ((pid = waitpid(-1, &wstat, WNOHANG | WUNTRACED)) > 0)
X# else
X# ifdef USE_WAIT2
X  /* 
X   * From: rouilj@sni-usa.com (John Rouillard) 
X   * note that WUNTRACED is not documented to work, but it is defined in
X   * /usr/include/sys/wait.h, so it may work 
X   */
X  while ((pid = wait2(&wstat, WNOHANG | WUNTRACED )) > 0)
X#  else /* USE_WAIT2 */
X  while ((pid = wait3(&wstat, WNOHANG | WUNTRACED, (struct rusage *) 0)) > 0)
X#  endif /* USE_WAIT2 */
X# endif
X#else	/* BSDJOBS */
X  while ((pid = wait(&wstat)) < 0)
X    if (errno != EINTR)
X      break;
X  if (pid > 0)
X#endif	/* BSDJOBS */
X    {
X      for (p = windows; p; p = next)
X	{
X	  next = p->w_next;
X	  if (pid == p->w_pid)
X	    {
X#ifdef BSDJOBS
X	      if (WIFSTOPPED(wstat))
X		{
X		  debug3("Window %d pid %d: WIFSTOPPED (sig %d)\n", p->w_number, p->w_pid, WSTOPSIG(wstat));
X#ifdef SIGTTIN
X		  if (WSTOPSIG(wstat) == SIGTTIN)
X		    {
X		      Msg(0, "Suspended (tty input)");
X		      continue;
X		    }
X#endif
X#ifdef SIGTTOU
X		  if (WSTOPSIG(wstat) == SIGTTOU)
X		    {
X		      Msg(0, "Suspended (tty output)");
X		      continue;
X		    }
X#endif
X		  /* Try to restart process */
X# ifdef NETHACK	
X                  if (nethackflag)
X		    Msg(0, "You regain consciousness.");
X		  else
X# endif /* NETHACK */
X		  Msg(0, "Child has been stopped, restarting.");
X		  if (killpg(p->w_pid, SIGCONT))
X		    kill(p->w_pid, SIGCONT);
X		}
X	      else
X#endif
X		{
X		  if (ZombieKey)
X		    {
X		      debug3("window %d (%s) going into zombie state fd %d",
X		             p->w_number, p->w_title, p->w_ptyfd);
X		      p->w_ptyfd = -1;
X		      debug("changed to -1\n");
X		    }
X		  else
X		    KillWindow(p);
X		}
X	      break;
X	    }
X#ifdef PSEUDOS
X	  if (p->w_pwin && pid == p->w_pwin->p_pid)
X	    {
X	      debug2("pseudo of win Nr %d died. pid == %d\n", p->w_number, p->w_pwin->p_pid);
X	      FreePseudowin(p);
X	      break;
X	    }
X#endif
X	}
X      if (p == 0)
X	{
X	  debug1("pid %d not found - hope that's ok\n", pid);
X	}
X    }
X}
X
X
Xsig_t
XFinit(i)
Xint i;
X{
X  struct win *p, *next;
X
X  signal(SIGCHLD, SIG_IGN);
X  signal(SIGHUP, SIG_IGN);
X  debug1("Finit(%d);\n", i);
X  for (p = windows; p; p = next)
X    {
X      next = p->w_next;
X      FreeWindow(p);
X    }
X  if (ServerSocket != -1)
X    {
X      debug1("we unlink(%s)\n", SockPath);
X#ifndef NOREUID
X      setreuid(eff_uid, real_uid);
X      setregid(eff_gid, real_gid);
X#endif
X      (void) unlink(SockPath);
X#ifndef NOREUID
X      setreuid(real_uid, eff_uid);
X      setregid(real_gid, eff_gid);
X#endif
X    }
X  for (display = displays; display; display = display->_d_next)
X    {
X      if (d_status)
X	RemoveStatus();
X      FinitTerm();
X#ifdef UTMPOK
X      RestoreLoginSlot();
X#endif
X      AddStr("[screen is terminating]\r\n");
X      Flush();
X      SetTTY(d_userfd, &d_OldMode);
X      fcntl(d_userfd, F_SETFL, 0);
X      freetty();
X      Kill(d_userpid, SIG_BYE);
X    }
X  /*
X   * we _cannot_ call eexit(i) here, 
X   * instead of playing with the Socket above. Sigh.
X   */
X  exit(i);
X#ifndef SIGVOID
X  return((sig_t) 0);
X#endif
X}
X
Xvoid
Xeexit(e)
Xint e;
X{
X  if (ServerSocket != -1)
X    {
X      debug1("we unlink(%s)\n", SockPath);
X      setuid(real_uid);
X      setgid(real_gid);
X      (void) unlink(SockPath);
X    }
X  exit(e);
X}
X
X
X/*
X * Detach now has the following modes:
X *	D_DETACH	SIG_BYE		detach backend and exit attacher
X *	D_STOP		SIG_STOP	stop attacher (and detach backend)
X *	D_REMOTE	SIG_BYE		remote detach -- reattach to new attacher
X *	D_POWER 	SIG_POWER_BYE 	power detach -- attacher kills his parent
X *	D_REMOTE_POWER	SIG_POWER_BYE	remote power detach -- both
X *	D_LOCK		SIG_LOCK	lock the attacher
X * (jw)
X * we always remove our utmp slots. (even when "lock" or "stop")
X * Note: Take extra care here, we may be called by interrupt!
X */
Xvoid
XDetach(mode)
Xint mode;
X{
X  int sign = 0, pid;
X#ifdef UTMPOK
X  struct win *p;
X#endif
X
X  if (display == 0)
X    return;
X  signal(SIGHUP, SIG_IGN);
X  debug1("Detach(%d)\n", mode);
X  if (d_status)
X    RemoveStatus();
X  FinitTerm();
X  switch (mode)
X    {
X    case D_DETACH:
X      AddStr("[detached]\r\n");
X      sign = SIG_BYE;
X      break;
X#ifdef BSDJOBS
X    case D_STOP:
X      sign = SIG_STOP;
X      break;
X#endif
X#ifdef REMOTE_DETACH
X    case D_REMOTE:
X      AddStr("[remote detached]\r\n");
X      sign = SIG_BYE;
X      break;
X#endif
X#ifdef POW_DETACH
X    case D_POWER:
X      AddStr("[power detached]\r\n");
X      if (PowDetachString) 
X	{
X	  AddStr(expand_vars(PowDetachString));
X	  AddStr("\r\n");
X	}
X      sign = SIG_POWER_BYE;
X      break;
X#ifdef REMOTE_DETACH
X    case D_REMOTE_POWER:
X      AddStr("[remote power detached]\r\n");
X      if (PowDetachString) 
X	{
X	  AddStr(expand_vars(PowDetachString));
X	  AddStr("\r\n");
X	}
X      sign = SIG_POWER_BYE;
X      break;
X#endif
X#endif
X    case D_LOCK:
X      ClearDisplay();
X      sign = SIG_LOCK;
X      /* tell attacher to lock terminal with a lockprg. */
X      break;
X    }
X#ifdef UTMPOK
X  if (displays->_d_next == 0)
X    {
X      for (p = windows; p; p = p->w_next)
X	if (p->w_slot != (slot_t) -1)
X	  {
X	    RemoveUtmp(p);
X	    /*
X	     * Set the slot to 0 to get the window
X	     * logged in again.
X	     */
X	    p->w_slot = (slot_t) 0;
X	  }
X      if (console_window)
X	{
X	  if (TtyGrabConsole(console_window->w_ptyfd, 0, "detach"))
X	    {
X	      debug("could not release console - killing window\n");
X	      KillWindow(console_window);
X	      display = displays;
X	    }
X	}
X    }
X  RestoreLoginSlot();
X#endif
X  if (d_fore)
X    {
X      ReleaseAutoWritelock(display, d_fore);
X      if (d_fore->w_tstamp.seconds)
X        d_fore->w_tstamp.lastio = Now;
X      d_fore->w_active = 0;
X      d_fore->w_display = 0;
X      d_lay = &BlankLayer;
X      d_layfn = d_lay->l_layfn;
X      d_user->u_detachwin = d_fore->w_number;
X    }
X  while (d_lay != &BlankLayer)
X    ExitOverlayPage();
X  if (d_userfd >= 0)
X    {
X      Flush();
X      SetTTY(d_userfd, &d_OldMode);
X      fcntl(d_userfd, F_SETFL, 0);
X    }
X  freetty();
X  pid = d_userpid;
X  debug2("display: %#x displays: %#x\n", (unsigned int)display, (unsigned int)displays);
X  FreeDisplay();
X  if (displays == 0)
X    /* Flag detached-ness */
X    (void) chsock();
X  /*
X   * tell father to father what to do. We do that after we
X   * freed the tty, thus getty feels more comfortable on hpux
X   * if it was a power detach.
X   */
X  Kill(pid, sign);
X  debug2("Detach: Signal %d to Attacher(%d)!\n", sign, pid);
X  debug("Detach returns, we are successfully detached.\n");
X  signal(SIGHUP, SigHup);
X}
X
Xstatic int
XIsSymbol(e, s)
Xregister char *e, *s;
X{
X  register int l;
X
X  l = strlen(s);
X  return strncmp(e, s, l) == 0 && e[l] == '=';
X}
X
Xvoid
XMakeNewEnv()
X{
X  register char **op, **np;
X  static char stybuf[MAXSTR];
X
X  for (op = environ; *op; ++op)
X    ;
X  if (NewEnv)
X    free(NewEnv);
X  NewEnv = np = (char **) malloc((unsigned) (op - environ + 7 + 1) * sizeof(char **));
X  if (!NewEnv)
X    Panic(0, strnomem);
X  SockName = SockNamePtr;
X  if (strlen(SockNamePtr) > MAXSTR - 5)
X    SockName = "?";
X  sprintf(stybuf, "STY=%s", SockNamePtr);
X  *np++ = stybuf;	                /* NewEnv[0] */
X  *np++ = Term;	                /* NewEnv[1] */
X  np++;		/* room for SHELL */
X#ifdef TIOCSWINSZ
X  np += 2;	/* room for TERMCAP and WINDOW */
X#else
X  np += 4;	/* room for TERMCAP WINDOW LINES COLUMNS */
X#endif
X
X  for (op = environ; *op; ++op)
X    {
Xdebug1("MakeNewEnv: %s\n", *op);
X      if (!IsSymbol(*op, "TERM") && !IsSymbol(*op, "TERMCAP")
X	  && !IsSymbol(*op, "STY") && !IsSymbol(*op, "WINDOW")
X	  && !IsSymbol(*op, "SCREENCAP") && !IsSymbol(*op, "SHELL")
X	  && !IsSymbol(*op, "LINES") && !IsSymbol(*op, "COLUMNS")
X	 )
X	*np++ = *op;
X    }
X  *np = 0;
X}
X
Xvoid
X#ifdef USEVARARGS
X/*VARARGS2*/
X# if defined(__STDC__)
XMsg(int err, char *fmt, ...)
X# else /* __STDC__ */
XMsg(err, fmt, va_alist)
Xint err;
Xchar *fmt;
Xva_dcl
X# endif /* __STDC__ */
X{
X  static va_list ap;
X#else /* USEVARARRGS */
X/*VARARGS2*/
XMsg(err, fmt, p1, p2, p3, p4, p5, p6)
Xint err;
Xchar *fmt;
Xunsigned long p1, p2, p3, p4, p5, p6;
X{
X#endif /* USEVARARRGS */
X  char buf[MAXPATHLEN*2];
X  char *p = buf;
X
X#ifdef USEVARARGS
X# if defined(__STDC__)
X  va_start(ap, fmt);
X# else /* __STDC__ */
X  va_start(ap);
X# endif /* __STDC__ */
X  (void) vsprintf(p, fmt, ap);
X  va_end(ap);
X#else /* USEVARARRGS */
X  sprintf(p, fmt, p1, p2, p3, p4, p5, p6);
X#endif /* USEVARARRGS */
X  if (err)
X    {
X      p += strlen(p);
X      if (err > 0 && err < sys_nerr)
X	sprintf(p, ": %s", sys_errlist[err]);
X      else
X	sprintf(p, ": Error %d", err);
X    }
X  debug2("Msg('%s') (%#x);\n", buf, (unsigned int)display);
X  if (display)
X    MakeStatus(buf);
X  else if (displays)
X    {
X      for (display = displays; display; display = display->_d_next)
X	MakeStatus(buf);
X    }
X  else
X    printf("%s\r\n", buf);
X}
X
Xvoid
X#ifdef USEVARARGS
X/*VARARGS2*/
X# if defined(__STDC__)
XPanic(int err, char *fmt, ...)
X# else /* __STDC__ */
XPanic(err, fmt, va_alist)
Xint err;
Xchar *fmt;
Xva_dcl
X# endif /* __STDC__ */
X{
X  static va_list ap;
X#else /* USEVARARRGS */
X/*VARARGS2*/
XPanic(err, fmt, p1, p2, p3, p4, p5, p6)
Xint err;
Xchar *fmt;
Xunsigned long p1, p2, p3, p4, p5, p6;
X{
X#endif /* USEVARARRGS */
X  char buf[MAXPATHLEN*2];
X  char *p = buf;
X
X#ifdef USEVARARGS
X# if defined(__STDC__)
X  va_start(ap, fmt);
X# else /* __STDC__ */
X  va_start(ap);
X# endif /* __STDC__ */
X  (void) vsprintf(p, fmt, ap);
X  va_end(ap);
X#else /* USEVARARRGS */
X  sprintf(p, fmt, p1, p2, p3, p4, p5, p6);
X#endif /* USEVARARRGS */
X  if (err)
X    {
X      p += strlen(p);
X      if (err > 0 && err < sys_nerr)
X	sprintf(p, ": %s", sys_errlist[err]);
X      else
X	sprintf(p, ": Error %d", err);
X    }
X  debug1("Panic('%s');\n", buf);
X  if (displays == 0)
X    printf("%s\r\n", buf);
X  else
X    for (display = displays; display; display = display->_d_next)
X      {
X        if (d_status)
X	  RemoveStatus();
X        FinitTerm();
X        Flush();
X#ifdef UTMPOK
X        RestoreLoginSlot();
X#endif
X        SetTTY(d_userfd, &d_OldMode);
X        fcntl(d_userfd, F_SETFL, 0);
X        write(d_userfd, buf, strlen(buf));
X        write(d_userfd, "\n", 1);
X        freetty();
X	if (d_userpid)
X	  Kill(d_userpid, SIG_BYE);
X      }
X#ifdef MULTIUSER
X  if (tty_oldmode >= 0)
X    {
X# ifdef NOREUID
X      setuid(eff_uid);
X# else
X      setreuid(real_uid, eff_uid);
X# endif
X      debug1("Panic: changing back modes from %s\n", attach_tty);
X      chmod(attach_tty, tty_oldmode);
X    }
X#endif
X  eexit(1);
X}
X
X
X/*
X * '^' is allowed as an escape mechanism for control characters. jw.
X */
Xstatic char *
XMakeWinMsg(s, n)
Xregister char *s;
Xint n;
X{
X  static char buf[MAXSTR];
X  register char *p = buf;
X  register int ctrl;
X
X  ctrl = 0;
X  for (; *s && p < buf + MAXSTR - 1; s++, p++)
X    if (ctrl)
X      {
X        ctrl = 0;
X        if (*s == '^' || *s < 64)
X          *p = *s;
X        else 
X          *p = *s - 64;
X      }
X    else
X      {
X        switch (*s)
X          {
X          case '%':
X	    sprintf(p, "%d", n);
X	    p += strlen(p) - 1;
X	    break;
X          case '~':
X	    *p = BELL;
X	    break;
X	  case '^':
X	    ctrl = 1;
X	    *p-- = '^';
X	    break;
X          default:
X	    *p = *s;
X	    break;
X          }
X      }
X  *p = '\0';
X  return buf;
X}
X
Xvoid
XDisplaySleep(n)
Xint n;
X{
X  char buf;
X  fd_set r;
X  struct timeval t;
X
X  if (!display)
X    {
X      debug("DisplaySleep has no display sigh\n");
X      sleep(n);
X      return;
X    }
X  t.tv_usec = 0;
X  t.tv_sec = n;
X  FD_ZERO(&r);
X  FD_SET(d_userfd, &r);
X  if (select(FD_SETSIZE, &r, (fd_set *)0, (fd_set *)0, &t) > 0)
X    {
X      debug("display activity stopped sleep\n");
X      read(d_userfd, &buf, 1);
X    }
X  debug1("DisplaySleep(%d) ending\n", n);
X}
END_OF_FILE
if test 50735 -ne `wc -c <'screen.c'`; then
    echo shar: \"'screen.c'\" unpacked with wrong size!
fi
# end of 'screen.c'
fi
echo shar: End of archive 6 \(of 10\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 10 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
