Newsgroups: comp.sources.unix
From: screen@uni-erlangen.de (Juergen & Michael)
Subject: v27i020: screen-3.5.1 - full-screen window manager/multiplexor, Part07/10
References: <1.744844979.5722@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: screen@uni-erlangen.de (Juergen & Michael)
Posting-Number: Volume 27, Issue 20
Archive-Name: screen-3.5.1/part07

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 10)."
# Contents:  process.c
# Wrapped by vixie@gw.home.vix.com on Sun Aug  8 14:19:09 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'process.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'process.c'\"
else
echo shar: Extracting \"'process.c'\" \(60864 characters\)
sed "s/^X//" >'process.c' <<'END_OF_FILE'
X/* Copyright (c) 1993
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 2, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X ****************************************************************
X */
X
X#include "rcs.h"
XRCS_ID("$Id: process.c,v 1.18 1993/08/05 14:24:01 mlschroe Exp $ FAU")
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <signal.h>
X#include <fcntl.h>
X#if !defined(sun) && !defined(B43) && !defined(ISC) && !defined(pyr) && !defined(_CX_UX)
X# include <time.h>
X#endif
X#include <sys/time.h>
X#ifndef sun
X#include <sys/ioctl.h>
X#endif
X
X
X#include "config.h"
X#include "screen.h"
X#include "extern.h"
X
X#if defined(sun) && defined(SVR4)
X# include <sys/stropts.h>
X#endif
X
Xextern struct comm comms[];
Xextern char *rc_name;
Xextern char *RcFileName, *home, *extra_incap, *extra_outcap;
Xextern char *BellString, *ActivityString, *ShellProg, *ShellArgs[];
Xextern char *hardcopydir, *screenlogdir;
Xextern char *VisualBellString;
Xextern int VBellWait, MsgWait, MsgMinWait, SilenceWait;
Xextern char SockPath[], *SockNamePtr;
Xextern int TtyMode, auto_detach;
Xextern int iflag;
Xextern int default_wrap;
Xextern int use_hardstatus, visual_bell, default_monitor;
Xextern int default_startup;
Xextern int slowpaste, defobuflimit;
Xextern int ZombieKey;
X#ifdef AUTO_NUKE
Xextern int defautonuke;
X#endif
Xextern int intrc, origintrc; /* display? */
Xextern struct NewWindow nwin_default, nwin_undef;
X#ifdef COPY_PASTE
Xextern int join_with_cr;
Xextern char mark_key_tab[];
Xextern char *BufferFile;
X#endif
X#ifdef POW_DETACH
Xextern char *BufferFile, *PowDetachString;
X#endif
Xextern time_t Now;
X
Xstatic int  CheckArgNum __P((int, char **));
Xstatic void FreeKey __P((int));
Xstatic int  NextWindow __P((void));
Xstatic int  PreviousWindow __P((void));
Xstatic int  MoreWindows __P((void));
Xstatic void LogToggle __P((int));
Xstatic void ShowTime __P((void));
Xstatic void ShowInfo __P((void));
Xstatic void SwitchWindow __P((int));
Xstatic char **SaveArgs __P((char **));
Xstatic struct win *WindowByName __P((char *));
Xstatic int  WindowByNumber __P((char *));
Xstatic void DoAction  __P((struct action *, int));
Xstatic int  ParseSwitch __P((struct action *, int *));
Xstatic int  ParseOnOff __P((struct action *, int *));
Xstatic int  ParseSaveStr __P((struct action *act, char **));
Xstatic int  ParseNum __P((struct action *act, int *));
Xstatic int  ParseWinNum __P((struct action *act, int *));
Xstatic int  ParseOct __P((struct action *act, int *));
Xstatic char *ParseChar __P((char *, char *));
Xstatic int  IsNum __P((char *, int));
Xstatic int  IsNumColon __P((char *, int, char *, int));
Xstatic void InputColon __P((void));
Xstatic void Colonfin __P((char *, int));
Xstatic void InputSelect __P((void));
Xstatic void InputSetenv __P((char *));
Xstatic void InputAKA __P((void));
Xstatic void AKAfin __P((char *, int));
X#ifdef COPY_PASTE
Xstatic void copy_reg_fn __P((char *, int));
Xstatic void ins_reg_fn __P((char *, int));
X#endif
Xstatic void process_fn __P((char *, int));
X#ifdef PASSWORD
Xstatic void pass1 __P((char *, int));
Xstatic void pass2 __P((char *, int));
X#endif
X#ifdef POW_DETACH
Xstatic void pow_detach_fn __P((char *, int));
X#endif
X
X
X
Xextern struct display *display, *displays;
Xextern struct win *fore, *console_window, *windows;
Xextern struct user *users;
X
Xextern char screenterm[], HostName[], version[];
Xextern struct NewWindow nwin_undef, nwin_default;
Xextern struct LayFuncs WinLf;
Xextern struct layer BlankLayer;
X
Xextern int Z0width, Z1width;
Xextern int real_uid, real_gid;
X
X#ifdef NETHACK
Xextern int nethackflag;
X#endif
X
X
Xstruct win *wtab[MAXWIN];	/* window table */
Xstruct action ktab[256];	/* command key translation table */
X
X
X#ifdef MULTIUSER
Xextern char *multi;
X#endif
X#ifdef PASSWORD
Xint CheckPassword;
Xchar Password[20];
X#endif
X
Xstruct plop plop_tab[MAX_PLOP_DEFS];
X
X#ifdef PTYMODE
Xint TtyMode = PTYMODE;
X#else
Xint TtyMode = 0622;
X#endif
Xint hardcopy_append = 0;
Xint all_norefresh = 0;
X
X
Xchar *noargs[1];
X
Xvoid
XInitKeytab()
X{
X  register unsigned int i;
X
X  for (i = 0; i < sizeof(ktab)/sizeof(*ktab); i++)
X    {
X      ktab[i].nr = RC_ILLEGAL;
X      ktab[i].args = noargs;
X    }
X
X  ktab['h'].nr = RC_HARDCOPY;
X#ifdef BSDJOBS
X  ktab['z'].nr = ktab[Ctrl('z')].nr = RC_SUSPEND;
X#endif
X  ktab['c'].nr = ktab[Ctrl('c')].nr = RC_SCREEN;
X  ktab[' '].nr = ktab[Ctrl(' ')].nr =
X    ktab['n'].nr = ktab[Ctrl('n')].nr = RC_NEXT;
X  ktab['N'].nr = RC_NUMBER;
X  ktab[Ctrl('h')].nr = ktab[0177].nr = ktab['p'].nr = ktab[Ctrl('p')].nr = RC_PREV;
X  ktab['k'].nr = ktab[Ctrl('k')].nr = RC_KILL;
X  ktab['l'].nr = ktab[Ctrl('l')].nr = RC_REDISPLAY;
X  ktab['w'].nr = ktab[Ctrl('w')].nr = RC_WINDOWS;
X  ktab['v'].nr = ktab[Ctrl('v')].nr = RC_VERSION;
X  ktab['q'].nr = ktab[Ctrl('q')].nr = RC_XON;
X  ktab['s'].nr = ktab[Ctrl('s')].nr = RC_XOFF;
X  ktab['t'].nr = ktab[Ctrl('t')].nr = RC_TIME;
X  ktab['i'].nr = ktab[Ctrl('i')].nr = RC_INFO;
X  ktab['m'].nr = ktab[Ctrl('m')].nr = RC_LASTMSG;
X  ktab['A'].nr = RC_TITLE;
X#if defined(UTMPOK) && defined(LOGOUTOK)
X  ktab['L'].nr = RC_LOGIN;
X#endif
X  ktab[','].nr = RC_LICENSE;
X  ktab['W'].nr = RC_WIDTH;
X  ktab['.'].nr = RC_DUMPTERMCAP;
X  ktab[Ctrl('\\')].nr = RC_QUIT;
X  ktab['d'].nr = ktab[Ctrl('d')].nr = RC_DETACH;
X  ktab['r'].nr = ktab[Ctrl('r')].nr = RC_WRAP;
X  ktab['f'].nr = ktab[Ctrl('f')].nr = RC_FLOW;
X  ktab['C'].nr = RC_CLEAR;
X  ktab['Z'].nr = RC_RESET;
X  ktab['H'].nr = RC_LOG;
X  ktab[(int)(unsigned char)DefaultEsc].nr = RC_OTHER;
X  ktab[(int)(unsigned char)DefaultMetaEsc].nr = RC_META;
X  ktab['M'].nr = RC_MONITOR;
X  ktab['?'].nr = RC_HELP;
X  for (i = 0; i < ((MAXWIN < 10) ? MAXWIN : 10); i++)
X    {
X      char *args[2], arg1[10];
X      args[0] = arg1;
X      args[1] = 0;
X      sprintf(arg1, "%d", i);
X      ktab['0' + i].nr = RC_SELECT;
X      ktab['0' + i].args = SaveArgs(args);
X    }
X  ktab[Ctrl('G')].nr = RC_VBELL;
X  ktab[':'].nr = RC_COLON;
X#ifdef COPY_PASTE
X  ktab['['].nr = ktab[Ctrl('[')].nr = RC_COPY;
X  ktab[']'].nr = ktab[Ctrl(']')].nr = RC_PASTE;
X  ktab['{'].nr = RC_HISTORY;
X  ktab['}'].nr = RC_HISTORY;
X  ktab['>'].nr = RC_WRITEBUF;
X  ktab['<'].nr = RC_READBUF;
X  ktab['='].nr = RC_REMOVEBUF;
X  ktab['\''].nr = ktab['"'].nr = RC_SELECT; /* calling a window by name */
X#endif
X#ifdef POW_DETACH
X  ktab['D'].nr = RC_POW_DETACH;
X#endif
X#ifdef LOCK
X  ktab['x'].nr = ktab[Ctrl('x')].nr = RC_LOCKSCREEN;
X#endif
X  ktab['b'].nr = ktab[Ctrl('b')].nr = RC_BREAK;
X  ktab['B'].nr = RC_POW_BREAK;
X  ktab['_'].nr = RC_SILENCE;
X}
X
Xstatic void
XFreeKey(key)
Xint key;
X{
X  char **p;
X
X  struct action *act = &ktab[key];
X  if (act->nr == RC_ILLEGAL)
X    return;
X  act->nr = RC_ILLEGAL;
X  if (act->args == noargs)
X    return;
X  for (p = act->args; *p; p++)
X    free(*p);
X  free(act->args);
X  act->args = noargs;
X}
X
Xvoid
XProcessInput(ibuf, ilen)
Xchar *ibuf;
Xint ilen;
X{
X  char *s;
X  int slen;
X
X  while (display)
X    {
X      fore = d_fore;
X      slen = ilen;
X      s = ibuf;
X      while (ilen > 0)
X	{
X	  if (*s++ == d_user->u_Esc)
X	    break;
X	  ilen--;
X	}
X      slen -= ilen;
X      while (slen)
X	Process(&ibuf, &slen);
X      if (--ilen == 0)
X	d_ESCseen = 1;
X      if (ilen <= 0)
X	return;
X      DoAction(&ktab[(int)(unsigned char)*s], (int)(unsigned char)*s);
X      ibuf = s + 1;
X      ilen--;
X    }
X}
X
Xint
XFindCommnr(str)
Xchar *str;
X{
X  int x, m, l = 0, r = RC_LAST;
X  while (l <= r)
X    {
X      m = (l + r) / 2;
X      x = strcmp(str, comms[m].name);
X      if (x > 0)
X	l = m + 1;
X      else if (x < 0)
X	r = m - 1;
X      else
X	return m;
X    }
X  return RC_ILLEGAL;
X}
X
Xstatic int
XCheckArgNum(nr, args)
Xint nr;
Xchar **args;
X{
X  int i, n;
X  static char *argss[] = {"no", "one", "two", "three"};
X
X  n = comms[nr].flags & ARGS_MASK;
X  for (i = 0; args[i]; i++)
X    ;
X  if (comms[nr].flags & ARGS_ORMORE)
X    {
X      if (i < n)
X	{
X	  Msg(0, "%s: %s: at least %s argument%s required", rc_name, comms[nr].name, argss[n], n != 1 ? "s" : "");
X	  return -1;
X	}
X    }
X  else if ((comms[nr].flags & ARGS_PLUSONE) && (comms[nr].flags & ARGS_PLUSTWO))
X    {
X      if (i != n && i != n + 1 && i != n + 2)
X        {
X	  Msg(0, "%s: %s: %s, %s or %s argument%s required", rc_name,
X	      comms[nr].name, argss[n], argss[n + 1], argss[n + 2], 
X	      n != 0 ? "s" : "");
X	  return -1;
X	}
X    }
X  else if (comms[nr].flags & ARGS_PLUSONE)
X    {
X      if (i != n && i != n + 1)
X	{
X	  Msg(0, "%s: %s: %s or %s argument%s required", rc_name, comms[nr].name, argss[n], argss[n + 1], n != 0 ? "s" : "");
X          return -1;
X	}
X    }
X  else if (comms[nr].flags & ARGS_PLUSTWO)
X    {
X      if (i != n && i != n + 2)
X        {
X	  Msg(0, "%s: %s: %s or %s argument%s required", rc_name, 
X	      comms[nr].name, argss[n], argss[n + 2], n != 0 ? "s" : "");
X	  return -1;
X	}
X    }
X  else if (i != n)
X    {
X      Msg(0, "%s: %s: %s argument%s required", rc_name, comms[nr].name, argss[n], n != 1 ? "s" : "");
X      return -1;
X    }
X  return 0;
X}
X
X/*ARGSUSED*/
Xstatic void
XDoAction(act, key)
Xstruct action *act;
Xint key;
X{
X  int nr = act->nr;
X  char **args = act->args;
X  struct win *p;
X  int i, n, msgok;
X  char *s;
X  char ch;
X
X  if (nr == RC_ILLEGAL)
X    {
X      debug1("key '%c': No action\n", key);
X      return;
X    }
X  n = comms[nr].flags;
X  if ((n & NEED_DISPLAY) && display == 0)
X    {
X      Msg(0, "%s: %s: display required", rc_name, comms[nr].name);
X      return;
X    }
X  if ((n & NEED_FORE) && fore == 0)
X    {
X      Msg(0, "%s: %s: window required", rc_name, comms[nr].name);
X      return;
X    }
X  if (CheckArgNum(nr, args))
X    return;
X#ifdef MULTIUSER
X  if (multi && display)
X    {
X      if (AclCheckPermCmd(d_user, ACL_EXEC, &comms[nr]))
X	return;
X    }
X#endif /* MULTIUSER */
X  msgok = display && !*rc_name;
X  switch(nr)
X    {
X    case RC_SELECT:
X      if (!*args)
X        InputSelect();
X      else if (ParseWinNum(act, &n) == 0)
X        SwitchWindow(n);
X      break;
X#ifdef AUTO_NUKE
X    case RC_DEFAUTONUKE:
X      if (ParseOnOff(act, &defautonuke) == 0 && msgok)
X	Msg(0, "Default autonuke turned %s", defautonuke ? "on" : "off");
X      if (display && *rc_name)
X	d_auto_nuke = defautonuke;
X      break;
X    case RC_AUTONUKE:
X      if (ParseOnOff(act, &d_auto_nuke) == 0 && msgok)
X	Msg(0, "Autonuke turned %s", d_auto_nuke ? "on" : "off");
X      break;
X#endif
X    case RC_DUPLICATE:
X      if (!*args)
X	{
X	  if (fore->w_dupto >= 0)
X	    Msg(0, "Duplicating output to window %d", fore->w_dupto);
X	  else
X	    Msg(0, "No duplicate from here\n");
X	  break;
X	}
X      if (!strcmp(*args, "off"))
X        {
X	  fore->w_dupto = -1;
X	  break;
X	}
X      while (*args)
X        {
X	  n = WindowByNoN(*args++);
X          if (n < 0)
X	    {
X	      Msg(0, "Invalid window description");
X	      continue;
X	    }
X	  if ((p = wtab[n]) == 0)
X	    {
X	      Msg(0, "Window %d does not exist", n);
X	      continue;
X	    }
X	  for (nr = fore->w_number; wtab[nr] && wtab[nr]->w_dupto >= 0;nr = wtab[nr]->w_dupto)
X	    {
X	      if (wtab[nr]->w_dupto == n)
X		{
X		  Msg(0, "Cyclic dup detected\n");
X		  return;
X		}
X	    }
X	  wtab[n]->w_dupto = fore->w_number;
X	}
X      break;
X    case RC_DEFOBUFLIMIT:
X      if (ParseNum(act, &defobuflimit) == 0 && msgok)
X	Msg(0, "Default limit set to %d", defobuflimit);
X      if (display && *rc_name)
X	d_obufmax = defobuflimit;
X      break;
X    case RC_OBUFLIMIT:
X      if (*args == 0)
X	Msg(0, "Limit is %d, current buffer size is %d", d_obufmax, d_obuflen);
X      else if (ParseNum(act, &d_obufmax) == 0 && msgok)
X	Msg(0, "Limit set to %d", d_obufmax);
X      break;
X    case RC_DUMPTERMCAP:
X      WriteFile(DUMP_TERMCAP);
X      break;
X    case RC_HARDCOPY:
X      WriteFile(DUMP_HARDCOPY);
X      break;
X    case RC_LOG:
X      n = fore->w_logfp ? 1 : 0;
X      ParseSwitch(act, &n);
X      LogToggle(n);
X      break;
X#ifdef BSDJOBS
X    case RC_SUSPEND:
X      Detach(D_STOP);
X      break;
X#endif
X    case RC_NEXT:
X      if (MoreWindows())
X	SwitchWindow(NextWindow());
X      break;
X    case RC_PREV:
X      if (MoreWindows())
X	SwitchWindow(PreviousWindow());
X      break;
X    case RC_KILL:
X      {
X	char *name;
X
X	n = fore->w_number;
X#ifdef PSEUDOS
X	if (fore->w_pwin)
X	  {
X	    FreePseudowin(fore);
X#ifdef NETHACK
X	    if (nethackflag)
X	      Msg(0, "You have a sad feeling for a moment...");
X	    else
X#endif
X	    Msg(0, "Filter removed.");
X	    break;
X	  }
X#endif
X	name = SaveStr(fore->w_title);
X	KillWindow(fore);
X#ifdef NETHACK
X	if (nethackflag)
X	  Msg(0, "You destroy poor window %d (%s).", n, name);
X	else
X#endif
X	Msg(0, "Window %d (%s) killed.", n, name);
X	if (name)
X	  free(name);
X	break;
X      }
X    case RC_QUIT:
X      Finit(0);
X      /* NOTREACHED */
X    case RC_DETACH:
X      Detach(D_DETACH);
X      break;
X#ifdef POW_DETACH
X    case RC_POW_DETACH:
X      if (key >= 0)
X	{
X	  static char buf[2];
X
X	  buf[0] = key;
X	  Input(buf, 1, pow_detach_fn, INP_RAW);
X	}
X      else
X        Detach(D_POWER); /* detach and kill Attacher's parent */
X      break;
X#endif
X    case RC_DEBUG:
X#ifdef DEBUG
X      if (!*args)
X        {
X	  if (dfp)
X	    Msg(0, "debugging info is written to %s/", DEBUGDIR);
X	  else
X	    Msg(0, "debugging is currently off. Use 'debug on' to enable.");
X	  break;
X	}
X      if (dfp)
X        {
X	  debug("debug: closing debug file.\n");
X	  fflush(dfp);
X	  fclose(dfp);
X	  dfp = NULL;
X	}
X      if (strcmp("off", *args))
X        {
X	  char buf[255];
X
X	  sprintf(buf, "%s/SCREEN.%d", DEBUGDIR, getpid());
X	  if ((dfp = fopen(buf, "a")) == NULL)
X	    dfp = stderr;
X	  debug("debug: opening debug file.\n");
X	}
X#else
X      Msg(0, "Sorry, screen was compiled without -DDEBUG option.");
X#endif
X      break;
X    case RC_ZOMBIE:
X      if (!(s = *args))
X        {
X	  ZombieKey = 0;
X	  break;
X	}
X      if (!(s = ParseChar(s, &ch)) || *s)
X        {
X	  Msg(0, "%s:zombie: one character expected.", rc_name);
X	  break;
X	}
X      ZombieKey = ch;
X      break;
X    case RC_WALL:
X      for (n = 0, s = *args; args[n]; n++)
X        {
X	  /* glue the vector together again. Brute force method. */
X	  while (*s)
X	    s++;
X	  while (s < args[n+1])
X	    *s++ = ' ';
X	}
X#ifdef MULTIUSER
X      s = d_user->u_name;
X#else
X      s = d_usertty;
X#endif
X      display = NULL;	/* a message without display will cause a broadcast */
X      Msg(0, "%s: %s", s, *args);
X      break;
X    case RC_AT:
X#ifdef MULTIUSER
X      s = SaveStr(d_user->u_name);
X#else
X      s = SaveStr(d_usertty);
X#endif
X      n = strlen(args[0]);
X      if (n) n--;
X      /*
X       * the windows/displays loops are quite dangerous here, take extra
X       * care not to trigger landmines. Things may appear/disappear while
X       * we are walking along.
X       */
X      switch (args[0][n])
X        {
X	case '*':
X	  {
X	    struct display *nd;
X	    struct user *u;
X
X	    args[0][n] = '\0';
X	    if (!*args[0])
X	      u = d_user;
X	    else
X	      for (u = users; u; u = u->u_next)
X	        if (!strncmp(s, u->u_name, n))
X		  break;
X	    debug1("at all displays of user %s\n", u->u_name);
X	    for (display = displays; display; display = nd)
X	      {
X		nd = display->_d_next;
X		fore = d_fore;
X	        if (d_user != u)
X		  continue;
X		debug1("AT display %s\n", d_usertty);
X		DoCommand(args + 1);
X		if (display)
X		  Msg(0, "command from %s: %s %s", 
X		      s, args[1], args[2] ? args[2] : "");
X		display = NULL;
X		fore = NULL;
X	      }
X	    free(s);
X	    return;
X	  }
X	case '%':
X	  {
X	    struct display *nd;
X
X	    args[0][n] = '\0';
X	    debug1("at display matching '%s'\n", args[0]);
X	    for (display = displays; display; display = nd)
X	      {
X	        nd = display->_d_next;
X		fore = d_fore;
X	        if (strncmp(args[0], d_usertty, n) && 
X		    (strncmp("/dev/", d_usertty, 5) || 
X		     strncmp(args[0], d_usertty + 5, n)) &&
X		    (strncmp("/dev/tty", d_usertty, 8) ||
X		     strncmp(args[0], d_usertty + 8, n)))
X		  continue;
X		debug1("AT display %s\n", d_usertty);
X		DoCommand(args + 1);
X		if (display)
X		  Msg(0, "command from %s: %s %s", 
X		      s, args[1], args[2] ? args[2] : "");
X		display = NULL;
X		fore = NULL;
X	      }
X	    free(s);
X	    return;
X	  }
X	case '#':
X	  args[0][n--] = '\0';
X	  /* FALLTHROUGH */
X	default:
X	  {
X	    struct win *nw;
X
X	    n++; 
X	    if (!*args[0] || (i = WindowByNumber(args[0])) < 0)
X	      {
X	        /* try looping over titles */
X		for (fore = windows; fore; fore = nw)
X		  {
X		    nw = fore->w_next;
X		    if (strncmp(args[0], fore->w_title, n))
X		      continue;
X		    debug2("AT window %d(%s)\n", fore->w_number, fore->w_title);
X		    i++;
X		    DoCommand(args + 1);
X		    if ((display = fore->w_display))
X		      Msg(0, "command from %s: %s %s", 
X			  s, args[1], args[2] ? args[2] : "");
X		  }
X		display = NULL;
X		fore = NULL;
X		if (i < 0)
X		  Msg(0, "%s: at '%s': no such window.\n", rc_name, args[0]);
X		free(s);
X		return;
X	      }
X	    else if (i < MAXWIN && (fore = wtab[i]))
X	      {
X	        debug2("AT window %d (%s)\n", fore->w_number, fore->w_title);
X		DoCommand(args + 1);
X		if ((display = fore->w_display))
X		  Msg(0, "command from %s: %s %s", 
X		      s, args[1], args[2] ? args[2] : "");
X		display = NULL;
X		fore = NULL;
X		free(s);
X		return;
X	      }
X	  }
X	}
X      Msg(0, "%s: at [identifier][%%|*|#] command [args]", rc_name);
X      free(s);
X      break;
X#ifdef COPY_PASTE
X    case RC_COPY_REG:
X      if ((s = *args) == NULL)
X	{
X	  Input("Copy to register:", 1, copy_reg_fn, INP_RAW);
X	  break;
X	}
X      if ((s = ParseChar(s, &ch)) == NULL || *s)
X	{
X	  Msg(0, "%s: copy_reg: character, ^x, or (octal) \\032 expected.",
X	      rc_name);
X	  break;
X	}
X      copy_reg_fn(&ch, 0);
X      break;
X    case RC_INS_REG:
X      if ((s = *args) == NULL)
X	{
X	  Input("Insert from register:", 1, ins_reg_fn, INP_RAW);
X	  break;
X	}
X      if ((s = ParseChar(s, &ch)) == NULL || *s)
X	{
X	  Msg(0, "%s: ins_reg: character, ^x, or (octal) \\032 expected.",
X	      rc_name);
X	  break;
X	}
X      ins_reg_fn(&ch, 0);
X      break;
X#endif
X    case RC_REGISTER:
X      if ((s = ParseChar(*args, &ch)) == NULL || *s)
X	Msg(0, "%s: register: character, ^x, or (octal) \\032 expected.",
X	    rc_name);
X      else
X	{
X	  struct plop *plp = plop_tab + (int)(unsigned char)ch;
X
X	  if (plp->buf)
X	    free(plp->buf);
X	  plp->buf = SaveStr(expand_vars(args[1]));
X	  plp->len = strlen(plp->buf);
X	}
X      break;
X    case RC_PROCESS:
X      if ((s = *args) == NULL)
X	{
X	  Input("Process register:", 1, process_fn, INP_RAW);
X	  break;
X	}
X      if ((s = ParseChar(s, &ch)) == NULL || *s)
X	{
X	  Msg(0, "%s: process: character, ^x, or (octal) \\032 expected.",
X	      rc_name);
X	  break;
X	}
X      process_fn(&ch, 0);
X      break;
X    case RC_REDISPLAY:
X      Activate(-1);
X      break;
X    case RC_WINDOWS:
X      ShowWindows();
X      break;
X    case RC_VERSION:
X      Msg(0, "screen %s", version);
X      break;
X    case RC_TIME:
X      ShowTime();
X      break;
X    case RC_INFO:
X      ShowInfo();
X      break;
X    case RC_OTHER:
X      if (MoreWindows())
X	SwitchWindow(d_other ? d_other->w_number : NextWindow());
X      break;
X    case RC_META:
X      ch = d_user->u_Esc;
X      s = &ch;
X      n = 1;
X      Process(&s, &n);
X      break;
X    case RC_XON:
X      ch = Ctrl('q');
X      s = &ch;
X      n = 1;
X      Process(&s, &n);
X      break;
X    case RC_XOFF:
X      ch = Ctrl('s');
X      s = &ch;
X      n = 1;
X      Process(&s, &n);
X      break;
X    case RC_POW_BREAK:
X    case RC_BREAK:
X      n = 0;
X      if (*args && ParseNum(act, &n))
X	break;
X      SendBreak(fore, n, nr == RC_POW_BREAK);
X      break;
X#ifdef LOCK
X    case RC_LOCKSCREEN:
X      Detach(D_LOCK);
X      break;
X#endif
X    case RC_WIDTH:
X      if (*args)
X	{
X	  if (ParseNum(act, &n))
X	    break;
X	}
X      else
X	{
X	  if (d_width == Z0width)
X	    n = Z1width;
X	  else if (d_width == Z1width)
X	    n = Z0width;
X	  else if (d_width > (Z0width + Z1width) / 2)
X	    n = Z0width;
X	  else
X	    n = Z1width;
X	}
X      if (n <= 0)
X        {
X	  Msg(0, "Illegal width");
X	  break;
X	}
X      if (n == d_width)
X	break;
X      if (ResizeDisplay(n, d_height) == 0)
X	{
X	  DoResize(d_width, d_height);
X	  Activate(d_fore ? d_fore->w_norefresh : 0);
X	}
X      else
X	Msg(0, "Your termcap does not specify how to change the terminal's width to %d.", n);
X      break;
X    case RC_HEIGHT:
X      if (*args)
X	{
X	  if (ParseNum(act, &n))
X	    break;
X	}
X      else
X	{
X#define H0height 42
X#define H1height 24
X	  if (d_height == H0height)
X	    n = H1height;
X	  else if (d_height == H1height)
X	    n = H0height;
X	  else if (d_height > (H0height + H1height) / 2)
X	    n = H0height;
X	  else
X	    n = H1height;
X	}
X      if (n <= 0)
X        {
X	  Msg(0, "Illegal height");
X	  break;
X	}
X      if (n == d_height)
X	break;
X      if (ResizeDisplay(d_width, n) == 0)
X	{
X	  DoResize(d_width, d_height);
X	  Activate(d_fore ? d_fore->w_norefresh : 0);
X	}
X      else
X	Msg(0, "Your termcap does not specify how to change the terminal's height to %d.", n);
X      break;
X    case RC_AKA:
X    case RC_TITLE:
X      if (*args == 0)
X	InputAKA();
X      else
X	ChangeAKA(fore, *args, 20);
X      break;
X    case RC_COLON:
X      InputColon();
X      break;
X    case RC_LASTMSG:
X      if (d_status_lastmsg)
X	Msg(0, "%s", d_status_lastmsg);
X      break;
X    case RC_SCREEN:
X      DoScreen("key", args);
X      break;
X    case RC_WRAP:
X      if (ParseSwitch(act, &fore->w_wrap) == 0 && msgok)
X        Msg(0, "%cwrap", fore->w_wrap ? '+' : '-');
X      break;
X    case RC_FLOW:
X      if (*args)
X	{
X	  if (args[0][0] == 'a')
X	    {
X	      fore->w_flow = (fore->w_flow & FLOW_AUTO) ? FLOW_AUTOFLAG |FLOW_AUTO|FLOW_NOW : FLOW_AUTOFLAG;
X	    }
X	  else
X	    {
X	      if (ParseOnOff(act, &n))
X		break;
X	      fore->w_flow = (fore->w_flow & FLOW_AUTO) | n;
X	    }
X	}
X      else
X	{
X	  if (fore->w_flow & FLOW_AUTOFLAG)
X	    fore->w_flow = (fore->w_flow & FLOW_AUTO) | FLOW_NOW;
X	  else if (fore->w_flow & FLOW_NOW)
X	    fore->w_flow &= ~FLOW_NOW;
X	  else
X	    fore->w_flow = fore->w_flow ? FLOW_AUTOFLAG|FLOW_AUTO|FLOW_NOW : FLOW_AUTOFLAG;
X	}
X      SetFlow(fore->w_flow & FLOW_NOW);
X      if (msgok)
X	Msg(0, "%cflow%s", (fore->w_flow & FLOW_NOW) ? '+' : '-',
X	    (fore->w_flow & FLOW_AUTOFLAG) ? "(auto)" : "");
X      break;
X    case RC_WRITELOCK:
X      if (*args)
X	{
X	  if (args[0][0] == 'a')
X	    {
X	      fore->w_wlock = WLOCK_AUTO;
X	    }
X	  else
X	    {
X	      if (ParseOnOff(act, &n))
X		break;
X	      fore->w_wlock = n ? WLOCK_ON : WLOCK_OFF;
X	    }
X	}
X      fore->w_wlockuser = d_user;
X      Msg(0, "writelock %s", (fore->w_wlock == WLOCK_AUTO) ? "auto" :
X	  ((fore->w_wlock == WLOCK_OFF) ? "off" : "on"));
X      break;
X    case RC_CLEAR:
X      if (fore->w_state == LIT)
X	WriteString(fore, "\033[H\033[J", 6);
X      break;
X    case RC_RESET:
X      if (fore->w_state == LIT)
X	WriteString(fore, "\033c", 2);
X      break;
X    case RC_MONITOR:
X      n = fore->w_monitor == MON_ON;
X      if (ParseSwitch(act, &n))
X	break;
X      if (n)
X	{
X	  fore->w_monitor = MON_ON;
X#ifdef NETHACK
X	  if (nethackflag)
X	    Msg(0, "You feel like someone is watching you...");
X	  else
X#endif
X	    Msg(0, "Window %d (%s) is now being monitored for all activity.", 
X		fore->w_number, fore->w_title);
X	}
X      else
X	{
X	  fore->w_monitor = MON_OFF;
X#ifdef NETHACK
X	  if (nethackflag)
X	    Msg(0, "You no longer sense the watcher's presence.");
X	  else
X#endif
X	    Msg(0, "Window %d (%s) is no longer being monitored for activity.", 
X		fore->w_number, fore->w_title);
X	}
X      break;
X    case RC_DISPLAYS:
X      display_displays();
X      break;
X    case RC_HELP:
X      display_help();
X      break;
X    case RC_LICENSE:
X      display_copyright();
X      break;
X#ifdef COPY_PASTE
X    case RC_COPY:
X      if (d_layfn != &WinLf)
X	{
X	  Msg(0, "Must be on a window layer");
X	  break;
X	}
X      MarkRoutine();
X      break;
X    case RC_HISTORY:
X      if (d_layfn != &WinLf)
X	{
X	  Msg(0, "Must be on a window layer");
X	  break;
X	}
X      if (GetHistory() == 0)
X        break;
X      if (d_user->u_copybuffer == NULL)
X        break;
X      /*FALLTHROUGH*/
X    case RC_PASTE:
X      {
X        char *ss;
X        int l = 0;
X
X        if ((s = *args) == 0)
X          s = ".";
X        for (ss = s; (ch = *ss); ss++)
X          {
X	    if (ch == '.')
X              l += d_user->u_copylen;
X	    else
X              l += plop_tab[(int)(unsigned char)ch].len;
X          }
X        if (l == 0)
X	  {
X#ifdef NETHACK
X	    if (nethackflag)
X	      Msg(0, "Nothing happens.");
X	    else
X#endif
X	    Msg(0, "empty buffer");
X	    break;
X	  }
X        fore->w_pasteptr = 0;
X        fore->w_pastelen = 0;
X        if (fore->w_pastebuf)
X          free(fore->w_pastebuf);
X        fore->w_pastebuf = 0;
X        if (s[1] == 0)
X          {
X            if (*s == '.')
X	      fore->w_pasteptr = d_user->u_copybuffer;
X            else
X	      fore->w_pasteptr = plop_tab[(int)(unsigned char)ch].buf;
X	    fore->w_pastelen = l;
X	    break;
X          }
X        if ((fore->w_pastebuf = (char *)malloc(l)) == 0)
X          {
X	    Msg(0, strnomem);
X	    break;
X          }
X        l = 0;
X        for (ss = s; (ch = *ss); ss++)
X          {
X	    if (ch == '.')
X	      {
X		bcopy(d_user->u_copybuffer, fore->w_pastebuf + l, d_user->u_copylen);
X                l += d_user->u_copylen;
X              }
X	    else
X	      {
X		bcopy(plop_tab[(int)(unsigned char)ch].buf, fore->w_pastebuf + l, plop_tab[(int)(unsigned char)ch].len);
X                l += plop_tab[(int)(unsigned char)ch].len;
X              }
X          }
X        fore->w_pasteptr = fore->w_pastebuf;
X        fore->w_pastelen = l;
X        break;
X      }
X    case RC_WRITEBUF:
X      if (d_user->u_copybuffer == NULL)
X	{
X#ifdef NETHACK
X	  if (nethackflag)
X	    Msg(0, "Nothing happens.");
X	  else
X#endif
X	  Msg(0, "empty buffer");
X	  break;
X	}
X      WriteFile(DUMP_EXCHANGE);
X      break;
X    case RC_READBUF:
X      ReadFile();
X      break;
X    case RC_REMOVEBUF:
X      KillBuffers();
X      break;
X#endif				/* COPY_PASTE */
X    case RC_ESCAPE:
X      FreeKey((int)(unsigned char)d_user->u_Esc);
X      FreeKey((int)(unsigned char)d_user->u_MetaEsc);
X      if (ParseEscape(d_user, *args))
X	{
X	  Msg(0, "%s: two characters required after escape.", rc_name);
X	  break;
X	}
X      FreeKey((int)(unsigned char)d_user->u_Esc);
X      FreeKey((int)(unsigned char)d_user->u_MetaEsc);
X      ktab[(int)(unsigned char)d_user->u_Esc].nr = RC_OTHER;
X      ktab[(int)(unsigned char)d_user->u_MetaEsc].nr = RC_META;
X      break;
X    case RC_CHDIR:
X      s = *args ? *args : home;
X      if (chdir(s) == -1)
X	Msg(errno, "%s", s);
X      break;
X    case RC_SHELL:
X      if (ParseSaveStr(act, &ShellProg) == 0)
X        ShellArgs[0] = ShellProg;
X      break;
X    case RC_HARDCOPYDIR:
X      (void)ParseSaveStr(act, &hardcopydir);
X      break;
X    case RC_LOGDIR:
X      (void)ParseSaveStr(act, &screenlogdir);
X      break;
X    case RC_SHELLTITLE:
X    case RC_SHELLAKA:
X      (void)ParseSaveStr(act, &nwin_default.aka);
X      break;
X    case RC_SLEEP:
X    case RC_TERMCAP:
X    case RC_TERMINFO:
X      break;			/* Already handled */
X    case RC_TERM:
X      s = NULL;
X      if (ParseSaveStr(act, &s))
X	break;
X      if (strlen(s) >= 20)
X	{
X	  Msg(0,"%s: term: argument too long ( < 20)", rc_name);
X	  free(s);
X	  break;
X	}
X      strcpy(screenterm, s);
X      free(s);
X      debug1("screenterm set to %s\n", screenterm);
X      MakeTermcap(display == 0);
X      debug("new termcap made\n");
X      break;
X    case RC_ECHO:
X      if (msgok)
X	{
X	  /*
X	   * d_user typed ^A:echo... well, echo isn't FinishRc's job,
X	   * but as he wanted to test us, we show good will
X	   */
X	  if (*args && (args[1] == 0 || (strcmp(args[1], "-n") == 0 && args[2] == 0)))
X	    Msg(0, "%s", args[1] ? args[1] : *args);
X	  else
X 	    Msg(0, "%s: 'echo [-n] \"string\"' expected.", rc_name);
X	}
X      break;
X    case RC_BELL:
X      (void)ParseSaveStr(act, &BellString);
X      break;
X#ifdef COPY_PASTE
X    case RC_BUFFERFILE:
X      if (*args == 0)
X	BufferFile = SaveStr(DEFAULT_BUFFERFILE);
X      else if (ParseSaveStr(act, &BufferFile))
X        break;
X      if (msgok)
X        Msg(0, "Bufferfile is now '%s'\n", BufferFile);
X      break;
X#endif
X    case RC_ACTIVITY:
X      (void)ParseSaveStr(act, &ActivityString);
X      break;
X#ifdef POW_DETACH
X    case RC_POW_DETACH_MSG:
X      (void)ParseSaveStr(act, &PowDetachString);
X      break;
X#endif
X#if defined(UTMPOK) && defined(LOGOUTOK)
X    case RC_DEFLOGIN:
X      (void)ParseOnOff(act, &nwin_default.lflag);
X      break;
X    case RC_LOGIN:
X      n = fore->w_slot != (slot_t)-1;
X      if (ParseSwitch(act, &n) == 0)
X        SlotToggle(n);
X      break;
X#endif
X    case RC_DEFFLOW:
X      if (args[0] && args[1] && args[1][0] == 'i')
X	{
X	  iflag = 1;
X	  if ((intrc == VDISABLE) && (origintrc != VDISABLE))
X	    {
X#if defined(TERMIO) || defined(POSIX)
X	      intrc = d_NewMode.tio.c_cc[VINTR] = origintrc;
X	      d_NewMode.tio.c_lflag |= ISIG;
X#else /* TERMIO || POSIX */
X	      intrc = d_NewMode.m_tchars.t_intrc = origintrc;
X#endif /* TERMIO || POSIX */
X
X	      if (display)
X		SetTTY(d_userfd, &d_NewMode);
X	    }
X	}
X      if (args[0] && args[0][0] == 'a')
X	nwin_default.flowflag = FLOW_AUTOFLAG;
X      else
X	(void)ParseOnOff(act, &nwin_default.flowflag);
X      break;
X    case RC_DEFWRAP:
X      (void)ParseOnOff(act, &default_wrap);
X      break;
X    case RC_HARDSTATUS:
X      RemoveStatus();
X      (void)ParseSwitch(act, &use_hardstatus);
X      break;
X    case RC_DEFMONITOR:
X      if (ParseOnOff(act, &n) == 0)
X        default_monitor = (n == 0) ? MON_OFF : MON_ON;
X      break;
X    case RC_CONSOLE:
X      n = (console_window != 0);
X      if (ParseSwitch(act, &n))
X        break;
X      if (TtyGrabConsole(fore->w_ptyfd, n, rc_name))
X	break;
X      if (n == 0)
X	  Msg(0, "%s: releasing console %s", rc_name, HostName);
X      else if (console_window)
X	  Msg(0, "%s: stealing console %s from window %d (%s)", rc_name, 
X	      HostName, console_window->w_number, console_window->w_title);
X      else
X	  Msg(0, "%s: grabbing console %s", rc_name, HostName);
X      console_window = n ? fore : 0;
X      break;
X    case RC_ALLPARTIAL:
X      if (ParseOnOff(act, &all_norefresh))
X	break;
X      if (!all_norefresh && fore)
X	Activate(-1);
X      if (msgok)
X        Msg(0, all_norefresh ? "No refresh on window change!\n" :
X			       "Window specific refresh\n");
X      break;
X    case RC_PARTIAL:
X      (void)ParseSwitch(act, &n);
X      fore->w_norefresh = n;
X      break;
X    case RC_VBELL:
X      if (ParseSwitch(act, &visual_bell) || !msgok)
X        break;
X      if (visual_bell == 0)
X	{
X#ifdef NETHACK
X	  if (nethackflag)
X	    Msg(0, "Suddenly you can't see your bell!");
X	  else
X#endif
X	  Msg(0, "switched to audible bell.");
X	}
X      else
X	{
X#ifdef NETHACK
X	  if (nethackflag)
X	    Msg(0, "Your bell is no longer invisible.");
X	  else
X#endif
X	  Msg(0, "switched to visual bell.");
X	}
X      break;
X    case RC_VBELLWAIT:
X      if (ParseNum(act, &VBellWait) == 0 && msgok)
X        Msg(0, "vbellwait set to %d seconds", VBellWait);
X      break;
X    case RC_MSGWAIT:
X      if (ParseNum(act, &MsgWait) == 0 && msgok)
X        Msg(0, "msgwait set to %d seconds", MsgWait);
X      break;
X    case RC_MSGMINWAIT:
X      if (ParseNum(act, &MsgMinWait) == 0 && msgok)
X        Msg(0, "msgminwait set to %d seconds", MsgMinWait);
X      break;
X    case RC_SILENCEWAIT:
X      if ((ParseNum(act, &SilenceWait) == 0) && msgok)
X        {
X	  if (SilenceWait < 1)
X	    SilenceWait = 1;
X	  for (p = windows; p; p = p->w_next)
X	    if (p->w_tstamp.seconds)
X	      p->w_tstamp.seconds = SilenceWait;
X	  Msg(0, "silencewait set to %d seconds", SilenceWait);
X	}
X      break;
X    case RC_NUMBER:
X      if (*args == 0)
X        Msg(0, "This is window %d (%s).\n", fore->w_number, fore->w_title);
X      else
X        {
X	  int old = fore->w_number;
X
X	  if (ParseNum(act, &n) || n >= MAXWIN)
X	    break;
X	  p = wtab[n];
X	  wtab[n] = fore;
X	  fore->w_number = n;
X	  wtab[old] = p;
X	  if (p)
X	    p->w_number = old;
X#ifdef MULTIUSER
X	  AclWinSwap(old, n);
X#endif
X	}
X      break;
X    case RC_SILENCE:
X      n = fore->w_tstamp.seconds != 0;
X      i = SilenceWait;
X      if (args[0] && 
X          (args[0][0] == '-' || (args[0][0] >= '0' && args[0][0] <= '9')))
X        {
X	  if (ParseNum(act, &i))
X	    break;
X	  n = i;
X	}
X      else if (ParseSwitch(act, &n))
X        break;
X      if (n)
X        {
X	  fore->w_tstamp.lastio = time(0);
X	  fore->w_tstamp.seconds = i;
X	  if (!msgok)
X	    break;
X#ifdef NETHACK
X	  if (nethackflag)
X	    Msg(0, "You feel like someone is waiting for %d sec. silence...",
X	        fore->w_tstamp.seconds);
X	  else
X#endif
X	    Msg(0, "Window %d (%s) is now being monitored for %d sec. silence.",
X	    	fore->w_number, fore->w_title, fore->w_tstamp.seconds);
X	}
X      else
X        {
X	  fore->w_tstamp.lastio = (time_t)0;
X	  fore->w_tstamp.seconds = 0;
X	  if (!msgok)
X	    break;
X#ifdef NETHACK
X	  if (nethackflag)
X	    Msg(0, "You no longer sense the watcher's silence.");
X	  else
X#endif
X	    Msg(0, "Window %d (%s) is no longer being monitored for silence.", 
X		fore->w_number, fore->w_title);
X	}
X      break;
X#ifdef COPY_PASTE
X    case RC_DEFSCROLLBACK:
X      (void)ParseNum(act, &nwin_default.histheight);
X      break;
X    case RC_SCROLLBACK:
X      (void)ParseNum(act, &n);
X      ChangeScrollback(fore, n, d_width);
X      if (msgok)
X	Msg(0, "scrollback set to %d", fore->w_histheight);
X      break;
X#endif
X    case RC_SESSIONNAME:
X      if (*args == 0)
X	Msg(0, "This session is named '%s'\n", SockNamePtr);
X      else
X	{
X	  char buf[MAXPATHLEN];
X
X	  s = NULL;
X	  if (ParseSaveStr(act, &s))
X	    break;
X	  if (!*s || strlen(s) > MAXPATHLEN - 13)
X	    {
X	      Msg(0, "%s: bad session name '%s'\n", rc_name, s);
X	      free(s);
X	      break;
X	    }
X	  sprintf(buf, "%s", SockPath);
X	  sprintf(buf + (SockNamePtr - SockPath), "%d.%s", getpid(), s); 
X	  free(s);
X	  if ((access(buf, F_OK) == 0) || (errno != ENOENT))
X	    {
X	      Msg(0, "%s: inappropriate path: '%s'.", rc_name, buf);
X	      break;
X	    }
X	  if (rename(SockPath, buf))
X	    {
X	      Msg(errno, "%s: failed to rename(%s, %s)", rc_name, SockPath, buf);
X	      break;
X	    }
X	  debug2("rename(%s, %s) done\n", SockPath, buf);
X	  sprintf(SockPath, "%s", buf);
X	  MakeNewEnv();
X	}
X      break;
X    case RC_SETENV:
X      if (!args[0] || !args[1])
X        {
X	  debug1("RC_SETENV arguments missing: %s\n", args[0] ? args[0] : "");
X          InputSetenv(args[0]);
X	}
X      else
X#ifndef USESETENV
X	{
X	  char *buf;
X	  int l;
X
X	  if ((buf = (char *)malloc((l = strlen(args[0])) + 
X				     strlen(args[1]) + 2)) == NULL)
X	    {
X	      Msg(0, strnomem);
X	      break;
X	    }
X	  strcpy(buf, args[0]);
X	  buf[l] = '=';
X	  strcpy(buf + l + 1, args[1]);
X	  putenv(buf);
X# ifdef NEEDPUTENV
X	  /*
X	   * we use our own putenv(), knowing that it does a malloc()
X	   * the string space, we can free our buf now. 
X	   */
X	  free(buf);
X# else /* NEEDSETENV */
X	  /*
X	   * For all sysv-ish systems that link a standard putenv() 
X	   * the string-space buf is added to the environment and must not
X	   * be freed, or modified.
X	   * We are sorry to say that memory is lost here, when setting 
X	   * the same variable again and again.
X	   */
X# endif /* NEEDSETENV */
X	}
X#else /* USESETENV */
X# if defined(linux) || defined(__386BSD__) || defined(BSDI)
X      setenv(args[0], args[1], 0);
X# else
X      setenv(args[0], args[1]);
X# endif /* linux || __386BSD__ || BSDI */
X#endif /* USESETENV */
X      MakeNewEnv();
X      break;
X    case RC_UNSETENV:
X      unsetenv(*args);
X      MakeNewEnv();
X      break;
X    case RC_SLOWPASTE:
X      if (ParseNum(act, &slowpaste) == 0 && msgok)
X	Msg(0, "slowpaste set to %d milliseconds", slowpaste);
X      break;
X#ifdef COPY_PASTE
X    case RC_MARKKEYS:
X      s = NULL;
X      if (ParseSaveStr(act, &s))
X        break;
X      if (CompileKeys(s, mark_key_tab))
X	{
X	  Msg(0, "%s: markkeys: syntax error.", rc_name);
X	  free(s);
X	  break;
X	}
X      debug1("markkeys %s\n", *args);
X      free(s);
X      break;
X#endif
X#ifdef NETHACK
X    case RC_NETHACK:
X      (void)ParseOnOff(act, &nethackflag);
X      break;
X#endif
X    case RC_HARDCOPY_APPEND:
X      (void)ParseOnOff(act, &hardcopy_append);
X      break;
X    case RC_VBELL_MSG:
X      (void)ParseSaveStr(act, &VisualBellString);
X      debug1(" new vbellstr '%s'\n", VisualBellString);
X      break;
X    case RC_DEFMODE:
X      if (ParseOct(act, &n))
X        break;
X      if (n < 0 || n > 0777)
X	{
X	  Msg(0, "%s: mode: Invalid tty mode %o", rc_name, n);
X          break;
X	}
X      TtyMode = n;
X      if (msgok)
X	Msg(0, "Ttymode set to %03o", TtyMode);
X      break;
X#ifdef COPY_PASTE
X    case RC_CRLF:
X      (void)ParseOnOff(act, &join_with_cr);
X      break;
X#endif
X    case RC_AUTODETACH:
X      (void)ParseOnOff(act, &auto_detach);
X      break;
X    case RC_STARTUP_MESSAGE:
X      (void)ParseOnOff(act, &default_startup);
X      break;
X#ifdef PASSWORD
X    case RC_PASSWORD:
X      CheckPassword = 1;
X      if (*args)
X	{
X	  strncpy(Password, *args, sizeof(Password) - 1);
X	  if (!strcmp(Password, "none"))
X	    CheckPassword = 0;
X	}
X      else
X	{
X	  if (display == 0)
X	    {
X	      debug("prompting for password on no display???\n");
X	      break;
X	    }
X	  Input("New screen password:", sizeof(Password) - 1, pass1, 
X		INP_NOECHO);
X	}
X      break;
X#endif				/* PASSWORD */
X    case RC_BIND:
X      if ((s = ParseChar(*args, &ch)) == NULL || *s)
X	{
X	  Msg(0, "%s: bind: character, ^x, or (octal) \\032 expected.",
X	      rc_name);
X	  break;
X	}
X      n = (unsigned char)ch;
X      FreeKey(n);
X      if (args[1])
X	{
X	  if ((i = FindCommnr(args[1])) == RC_ILLEGAL)
X	    {
X	      Msg(0, "%s: bind: unknown command '%s'", rc_name, args[1]);
X	      break;
X	    }
X	  if (CheckArgNum(i, args + 2))
X	    break;
X	  ktab[n].nr = i;
X	  if (args[2])
X	    ktab[n].args = SaveArgs(args + 2);
X	}
X      break;
X#ifdef MULTIUSER
X    case RC_ACLCHG:
X    case RC_ACLADD:
X	{
X	  struct user **u;
X	  
X	  u = FindUserPtr(args[0]);
X	  UserAdd(args[0], NULL, u);
X	  if (args[1] && args[2])
X	    AclSetPerm(*u, args[1], args[2]);
X	  else
X	    AclSetPerm(*u, "+rwx", "#?"); 
X	  break;
X	}
X    case RC_ACLDEL:
X        {
X	  if (UserDel(args[0], NULL))
X	    break;
X	  if (msgok)
X	    Msg(0, "%s removed from acl database", args[0]);
X	  break;
X        }
X    case RC_ACLGRP:
X        {
X	  break;
X	}
X    case RC_MULTIUSER:
X      if (ParseOnOff(act, &n))
X	break;
X      multi = n ? "" : 0;
X      chsock();
X      if (msgok)
X	Msg(0, "Multiuser mode %s", multi ? "enabled" : "disabled");
X      break;
X#endif /* MULTIUSER */
X#ifdef PSEUDOS
X    case RC_EXEC:
X      winexec(args);
X      break;
X#endif
X#ifdef MULTI
X    case RC_CLONE:
X      execclone(args);
X      break;
X#endif
X    default:
X      break;
X    }
X}
X
Xvoid
XDoCommand(argv) 
Xchar **argv;
X{
X  struct action act;
X
X  if ((act.nr = FindCommnr(*argv)) == RC_ILLEGAL)  
X    {
X      Msg(0, "%s: unknown command '%s'", rc_name, *argv);
X      return;
X    }
X  act.args = argv + 1;
X  DoAction(&act, -1);
X}
X
Xstatic char **
XSaveArgs(args)
Xchar **args;
X{
X  register char **ap, **pp;
X  register int argc = 0;
X
X  while (args[argc])
X    argc++;
X  if ((pp = ap = (char **) malloc((unsigned) (argc + 1) * sizeof(char **))) == 0)
X    Panic(0, strnomem);
X  while (argc--)
X    {
X      *pp++ = SaveStr(*args++);
X    }
X  *pp = 0;
X  return ap;
X}
X
Xint 
XParse(buf, args)
Xchar *buf, **args;
X{
X  register char *p = buf, **ap = args;
X  register int delim, argc;
X
X  argc = 0;
X  for (;;)
X    {
X      while (*p && (*p == ' ' || *p == '\t'))
X	++p;
X      if (argc == 0)
X	{
X	  /* 
X	   * Expand hardcoded shortcuts.
X	   * This should not be done here, cause multiple commands per
X	   * line or prefixed commands won't be recognized.
X	   * But as spaces between shortcut character and arguments
X	   * can be ommited this expansion affects tokenisation and
X	   * should be done here. Hmmm. jw.
X	   */
X	  switch (*p)
X	    {
X	    case '@':
X	      *ap++ = "at";
X	      while (*(++p) == ' ' || *p == '\t')
X	        ;
X	      argc++;
X	      break;
X#ifdef PSEUDOS
X	    case '!':
X	    case '|':
X	      *ap++ = "exec";
X	      if (*p == '!')
X		p++;
X	      while (*p == ' ' || *p == '\t')
X		p++;
X	      argc++;
X	      break;
X#endif
X	    }
X        }
X      if (*p == '\0' || *p == '#')
X	{
X	  *p = '\0';
X	  args[argc] = 0;
X	  return argc;
X	}
X      if (++argc >= MAXARGS)
X	{
X	  Msg(0, "%s: too many tokens.", rc_name);
X	  return 0;
X	}
X      delim = 0;
X      if (*p == '"' || *p == '\'')
X	delim = *p++;
X      *ap++ = p;
X      while (*p && !(delim ? *p == delim : (*p == ' ' || *p == '\t')))
X	++p;
X      if (*p == '\0')
X	{
X	  if (delim)
X	    {
X	      Msg(0, "%s: Missing quote.", rc_name);
X	      return 0;
X	    }
X	}
X      else
X        *p++ = '\0';
X    }
X}
X
Xint 
XParseEscape(u, p)
Xstruct user *u;
Xchar *p;
X{
X  if ((p = ParseChar(p, u ? &u->u_Esc : &DefaultEsc)) == NULL ||
X      (p = ParseChar(p, u ? &u->u_MetaEsc : &DefaultMetaEsc)) == NULL || *p)
X    return -1;
X  return 0;
X}
X
Xstatic int
XParseSwitch(act, var)
Xstruct action *act;
Xint *var;
X{
X  if (*act->args == 0)
X    {
X      *var ^= 1;
X      return 0;
X    }
X  return ParseOnOff(act, var);
X}
X
Xstatic int
XParseOnOff(act, var)
Xstruct action *act;
Xint *var;
X{
X  register int num = -1;
X  char **args = act->args;
X
X  if (args[1] == 0)
X    {
X      if (strcmp(args[0], "on") == 0)
X	num = 1;
X      else if (strcmp(args[0], "off") == 0)
X	num = 0;
X    }
X  if (num < 0)
X    {
X      Msg(0, "%s: %s: invalid argument. Give 'on' or 'off'", rc_name, comms[act->nr].name);
X      return -1;
X    }
X  *var = num;
X  return 0;
X}
X
Xstatic int
XParseSaveStr(act, var)
Xstruct action *act;
Xchar **var;
X{
X  char **args = act->args;
X  if (*args == 0 || args[1])
X    {
X      Msg(0, "%s: %s: one argument required.", rc_name, comms[act->nr].name);
X      return -1;
X    }
X  if (*var)
X    free(*var);
X  *var = SaveStr(*args);
X  return 0;
X}
X
Xstatic int
XParseNum(act, var)
Xstruct action *act;
Xint *var;
X{
X  int i;
X  char *p, **args = act->args;
X
X  p = *args;
X  if (p == 0 || *p == 0 || args[1])
X    {
X      Msg(0, "%s: %s: invalid argument. Give one argument.",
X          rc_name, comms[act->nr].name);
X      return -1;
X    }
X  i = 0; 
X  while (*p)
X    {
X      if (*p >= '0' && *p <= '9')
X	i = 10 * i + (*p - '0');
X      else
X	{
X	  Msg(0, "%s: %s: invalid argument. Give numeric argument.",
X	      rc_name, comms[act->nr].name);
X	  return -1;
X	}    
X      p++;
X    }
X  debug1("ParseNum got %d\n", i);
X  *var = i;
X  return 0;
X}
X
Xstatic struct win *
XWindowByName(s)
Xchar *s;
X{
X  struct win *p;
X
X  for (p = windows; p; p = p->w_next)
X    if (!strncmp(p->w_title, s, strlen(s)))
X      return p;
X  return NULL;
X}
X
Xstatic int
XWindowByNumber(str)
Xchar *str;
X{
X  int i;
X  char *s;
X
X  for (i = 0, s = str; *s; s++)
X    {
X      if (*s < '0' || *s > '9')
X        break;
X      i = i * 10 + (*s - '0');
X    }
X  return *s ? -1 : i;
X}
X
X/* 
X * Get window number from Name or Number string.
X * Numbers are tried first, then names, a prefix match suffices.
X * Be careful when assigning numeric strings as WindowTitles.
X */
Xint
XWindowByNoN(str)
Xchar *str;
X{
X  int i;
X  struct win *p;
X  
X  if ((i = WindowByNumber(str)) < 0 || i >= MAXWIN)
X    {
X      if ((p = WindowByName(str)))
X	return p->w_number;
X      return -1;
X    }
X  return i;
X}
X
Xstatic int
XParseWinNum(act, var)
Xstruct action *act;
Xint *var;
X{
X  char **args = act->args;
X  int i = 0;
X
X  if (*args == 0 || args[1])
X    {
X      Msg(0, "%s: %s: one argument required.", rc_name, comms[act->nr].name);
X      return -1;
X    }
X  
X  i = WindowByNoN(*args);
X  if (i < 0)
X    {
X      Msg(0, "%s: %s: invalid argument. Give window number or name.",
X          rc_name, comms[act->nr].name);
X      return -1;
X    }
X  debug1("ParseWinNum got %d\n", i);
X  *var = i;
X  return 0;
X}
X
Xstatic int
XParseOct(act, var)
Xstruct action *act;
Xint *var;
X{
X  char *p, **args = act->args;
X  int i = 0; 
X
X  p = *args;
X  if (p == 0 || *p == 0 || args[1])
X    {
X      Msg(0, "%s: %s: invalid argument. Give one octal argument.",
X          rc_name, comms[act->nr].name);
X      return -1;
X    }
X  while (*p)
X    {
X      if (*p >= '0' && *p <= '7')
X	i = 8 * i + (*p - '0');
X      else
X	{
X	  Msg(0, "%s: %s: invalid argument. Give octal argument.",
X	      rc_name, comms[act->nr].name);
X	  return -1;
X	}    
X      p++;
X    }
X  debug1("ParseOct got %d\n", i);
X  *var = i;
X  return 0;
X}
X
Xstatic char *
XParseChar(p, cp)
Xchar *p, *cp;
X{
X  if (*p == 0)
X    return 0;
X  if (*p == '^')
X    {
X      if (*++p == '?')
X        *cp = '\177';
X      else if (*p >= '@')
X        *cp = Ctrl(*p);
X      else
X        return 0;
X      ++p;
X    }
X  else if (*p == '\\' && *++p <= '7' && *p >= '0')
X    {
X      *cp = 0;
X      do
X        *cp = *cp * 8 + *p - '0';
X      while (*++p <= '7' && *p >= '0');
X    }
X  else
X    *cp = *p++;
X  return p;
X}
X
X
Xstatic
Xint IsNum(s, base)
Xregister char *s;
Xregister int base;
X{
X  for (base += '0'; *s; ++s)
X    if (*s < '0' || *s > base)
X      return 0;
X  return 1;
X}
X
Xstatic int
XIsNumColon(s, base, p, psize)
Xint base, psize;
Xchar *s, *p;
X{
X  char *q;
X  if ((q = rindex(s, ':')) != NULL)
X    {
X      strncpy(p, q + 1, psize - 1);
X      p[psize - 1] = '\0';
X      *q = '\0';
X    }
X  else
X    *p = '\0';
X  return IsNum(s, base);
X}
X
Xstatic void
XSwitchWindow(n)
Xint n;
X{
X  struct win *p;
X
X  debug1("SwitchWindow %d\n", n);
X  if (display == 0)
X    return;
X  if (n < 0 || n >= MAXWIN || (p = wtab[n]) == 0)
X    {
X      ShowWindows();
X      return;
X    }
X  if (p == d_fore)
X    {
X      Msg(0, "This IS window %d (%s).", n, p->w_title);
X      return;
X    }
X  if (p->w_display)
X    {
X      Msg(0, "Window %d (%s) is on another display (%s@%s).", n, p->w_title,
X          p->w_display->_d_user->u_name, p->w_display->_d_usertty);
X      return;
X    }
X  SetForeWindow(p);
X  Activate(fore->w_norefresh);  
X}  
X
X/* 
X * returns 0, if the lock really has been released 
X */
Xint
XReleaseAutoWritelock(dis, w)
Xstruct display *dis;
Xstruct win *w;
X{
X  /* release auto writelock when user has no other display here */
X  if (w->w_wlock == WLOCK_AUTO && w->w_wlockuser == d_user)
X    {
X      struct display *d;
X
X      for (d = displays; d; d = d->_d_next)
X	if (( d != display) && (d->_d_fore == w))
X	  break;
X      debug3("%s %s autolock on win %d\n", 
X	     d_user->u_name, d?"keeps":"releases", w->w_number);
X      if (!d)
X        {
X	  w->w_wlockuser = NULL;
X	  return 0;
X	}
X    }
X  return 1;
X}
X
Xvoid
XSetForeWindow(wi)
Xstruct win *wi;
X{
X  struct win *p, **pp;
X  struct layer *l;
X  /*
X   * If we come from another window, make it inactive.
X   */
X  if (display)
X    {
X      fore = d_fore;
X      if (fore)
X	{
X	  ReleaseAutoWritelock(display, fore);
X	  /* deactivate old window. */
X	  if (fore->w_tstamp.seconds)
X	    fore->w_tstamp.lastio = Now;
X	  d_other = fore;
X	  fore->w_active = 0;
X	  fore->w_display = 0;
X	}
X      else
X	{
X	  /* put all the display layers on the window. */
X	  for (l = d_lay; l; l = l->l_next)
X	    if (l->l_next == &BlankLayer)
X	      {
X		l->l_next = wi->w_lay;
X		wi->w_lay = d_lay;
X		for (l = d_lay; l != wi->w_lay; l = l->l_next)
X		  l->l_block |= wi->w_lay->l_block;
X		break;
X	      }
X	}
X      d_fore = wi;
X      if (d_other == wi)
X	d_other = 0;
X      d_lay = wi->w_lay;
X      d_layfn = d_lay->l_layfn;
X      if ((wi->w_wlock == WLOCK_AUTO) && !wi->w_wlockuser)
X        {
X	  debug2("%s obtained auto writelock for window %d\n",
X	  	 d_user->u_name, wi->w_number);
X          wi->w_wlockuser = d_user;
X        }
X    }
X  fore = wi;
X  fore->w_display = display;
X  if (!fore->w_lay)
X    fore->w_active = 1;
X  /*
X   * Place the window at the head of the most-recently-used list.
X   */
X  for (pp = &windows; (p = *pp); pp = &p->w_next)
X    if (p == wi)
X      break;
X  ASSERT(p);
X  *pp = p->w_next;
X  p->w_next = windows;
X  windows = p;
X}
X
Xstatic int
XNextWindow()
X{
X  register struct win **pp;
X  int n = fore ? fore->w_number : 0;
X
X  for (pp = wtab + n + 1; pp != wtab + n; pp++)
X    {
X      if (pp == wtab + MAXWIN)
X	pp = wtab;
X      if (*pp)
X	break;
X    }
X  return pp - wtab;
X}
X
Xstatic int
XPreviousWindow()
X{
X  register struct win **pp;
X  int n = fore ? fore->w_number : MAXWIN - 1;
X
X  for (pp = wtab + n - 1; pp != wtab + n; pp--)
X    {
X      if (pp < wtab)
X	pp = wtab + MAXWIN - 1;
X      if (*pp)
X	break;
X    }
X  return pp - wtab;
X}
X
Xstatic int
XMoreWindows()
X{
X  if (windows && windows->w_next)
X    return 1;
X  if (fore == 0)
X    {
X      Msg(0, "No window available");
X      return 0;
X    }
X#ifdef NETHACK
X  if (nethackflag)
X    Msg(0, "You cannot escape from window %d!", fore->w_number);
X  else
X#endif
X  Msg(0, "No other window.");
X  return 0;
X}
X
Xvoid
XKillWindow(wi)
Xstruct win *wi;
X{
X  struct win **pp, *p;
X
X  display = wi->w_display;
X  if (display)
X    {
X      if (wi == d_fore)
X	{
X	  RemoveStatus();
X	  if (d_lay != &wi->w_winlay)
X	    ExitOverlayPage();
X	  d_fore = 0;
X	  d_lay = &BlankLayer;
X	  d_layfn = BlankLayer.l_layfn;
X	}
X    }
X
X  for (pp = &windows; (p = *pp); pp = &p->w_next)
X    if (p == wi)
X      break;
X  ASSERT(p);
X  *pp = p->w_next;
X  /*
X   * Remove window from linked list.
X   */
X  wi->w_inlen = 0;
X  wtab[wi->w_number] = 0;
X  FreeWindow(wi);
X  /*
X   * If the foreground window disappeared check the head of the linked list
X   * of windows for the most recently used window. If no window is alive at
X   * all, exit.
X   */
X  if (display && d_fore)
X    return;
X  if (windows == 0)
X    Finit(0);
X  SwitchWindow(windows->w_number);
X}
X
Xstatic void
XLogToggle(on)
Xint on;
X{
X  char buf[1024];
X
X  if ((fore->w_logfp != 0) == on)
X    {
X      if (display && !*rc_name)
X	Msg(0, "You are %s logging.", on ? "already" : "not");
X      return;
X    }
X  if (screenlogdir)
X    sprintf(buf, "%s/screenlog.%d", screenlogdir, fore->w_number);
X  else
X    sprintf(buf, "screenlog.%d", fore->w_number);
X  if (fore->w_logfp != NULL)
X    {
X#ifdef NETHACK
X      if (nethackflag)
X	Msg(0, "You put away your scroll of logging named \"%s\".", buf);
X      else
X#endif
X      Msg(0, "Logfile \"%s\" closed.", buf);
X      fclose(fore->w_logfp);
X      fore->w_logfp = NULL;
X      return;
X    }
X  if ((fore->w_logfp = secfopen(buf, "a")) == NULL)
X    {
X#ifdef NETHACK
X      if (nethackflag)
X	Msg(0, "You don't seem to have a scroll of logging named \"%s\".", buf);
X      else
X#endif
X      Msg(errno, "Error opening logfile \"%s\"", buf);
X      return;
X    }
X#ifdef NETHACK
X  if (nethackflag)
X    Msg(0, "You %s your scroll of logging named \"%s\".",
X	ftell(fore->w_logfp) ? "add to" : "start writing on", buf);
X  else
X#endif
X  Msg(0, "%s logfile \"%s\"", ftell(fore->w_logfp) ? "Appending to" : "Creating", buf);
X}
X
Xvoid
XShowWindows()
X{
X  char buf[1024];
X  register char *s, *ss;
X  register struct win **pp, *p;
X  register char *cmd;
X
X  ASSERT(display);
X  s = ss = buf;
X  for (pp = wtab; pp < wtab + MAXWIN; pp++)
X    {
X      if ((p = *pp) == 0)
X	continue;
X
X      cmd = p->w_title;
X      if (s - buf + strlen(cmd) > sizeof(buf) - 6)
X	break;
X      if (s > buf)
X	{
X	  *s++ = ' ';
X	  *s++ = ' ';
X	}
X      sprintf(s, "%d", p->w_number);
X      s += strlen(s);
X      if (p == fore)
X	{
X	  ss = s;
X	  *s++ = '*';
X	}
X      else if (p == d_other)
X	*s++ = '-';
X      if (p->w_display && p->w_display != display)
X	*s++ = '&';
X      if (p->w_monitor == MON_DONE || p->w_monitor == MON_MSG)
X	*s++ = '@';
X      if (p->w_bell == BELL_DONE || p->w_bell == BELL_MSG)
X	*s++ = '!';
X#ifdef UTMPOK
X      if (p->w_slot != (slot_t) 0 && p->w_slot != (slot_t) -1)
X	*s++ = '$';
X#endif
X      if (p->w_logfp != NULL)
X	{
X	  strcpy(s, "(L)");
X	  s += 3;
X	}
X      if (p->w_ptyfd < 0)
X        *s++ = 'Z';
X      *s++ = ' ';
X      strcpy(s, cmd);
X      s += strlen(s);
X      if (p == fore)
X	{
X	  /* 
X	   * this is usually done by Activate(), but when looking
X	   * on your current window, you may get annoyed, as there is still
X	   * that temporal '!' and '@' displayed.
X	   * So we remove that after displaying it once.
X	   */
X	  p->w_bell = BELL_OFF;
X	  if (p->w_monitor != MON_OFF)
X	    p->w_monitor = MON_ON;
X	}
X    }
X  *s++ = ' ';
X  *s = '\0';
X  if (ss - buf > d_width / 2)
X    {
X      ss -= d_width / 2;
X      if (s - ss < d_width)
X	{
X	  ss = s - d_width;
X	  if (ss < buf)
X	    ss = buf;
X	}
X    }
X  else
X    ss = buf;
X  Msg(0, "%s", ss);
X}
X
X
Xstatic void
XShowTime()
X{
X  char buf[512];
X  struct tm *tp;
X  time_t now;
X
X  (void) time(&now);
X  tp = localtime(&now);
X  sprintf(buf, "%2d:%02d:%02d %s", tp->tm_hour, tp->tm_min, tp->tm_sec,
X	  HostName);
X#ifdef LOADAV
X  AddLoadav(buf + strlen(buf));
X#endif /* LOADAV */
X  Msg(0, "%s", buf);
X}
X
Xstatic void
XShowInfo()
X{
X  char buf[512], *p;
X  register struct win *wp = fore;
X  register int i;
X
X  if (wp == 0)
X    {
X      Msg(0, "(%d,%d)/(%d,%d) no window", d_x + 1, d_y + 1, d_width, d_height);
X      return;
X    }
X#ifdef COPY_PASTE
X  sprintf(buf, "(%d,%d)/(%d,%d)+%d %c%sflow %cins %corg %cwrap %capp %clog %cmon %cr",
X#else
X  sprintf(buf, "(%d,%d)/(%d,%d) %c%sflow %cins %corg %cwrap %capp %clog %cmon %cr",
X#endif
X	  wp->w_x + 1, wp->w_y + 1, wp->w_width, wp->w_height,
X#ifdef COPY_PASTE
X	  wp->w_histheight,
X#endif
X	  (wp->w_flow & FLOW_NOW) ? '+' : '-',
X	  (wp->w_flow & FLOW_AUTOFLAG) ? "" : ((wp->w_flow & FLOW_AUTO) ? "(+)" : "(-)"),
X	  wp->w_insert ? '+' : '-', wp->w_origin ? '+' : '-',
X	  wp->w_wrap ? '+' : '-', wp->w_keypad ? '+' : '-',
X	  (wp->w_logfp != NULL) ? '+' : '-',
X	  (wp->w_monitor != MON_OFF) ? '+' : '-',
X	  wp->w_norefresh ? '-' : '+');
X  if (CG0)
X    {
X      p = buf + strlen(buf);
X      sprintf(p, " G%1d [", wp->w_Charset);
X      for (i = 0; i < 4; i++)
X	p[i + 5] = wp->w_charsets[i] ? wp->w_charsets[i] : 'B';
X      p[9] = ']';
X      p[10] = '\0';
X    }
X  Msg(0, "%s", buf);
X}
X
X
Xstatic void
XAKAfin(buf, len)
Xchar *buf;
Xint len;
X{
X  ASSERT(display);
X  if (len && fore)
X    ChangeAKA(fore, buf, 20);
X}
X
Xstatic void
XInputAKA()
X{
X  Input("Set window's title to: ", 20, AKAfin, INP_COOKED);
X}
X
Xstatic void
XColonfin(buf, len)
Xchar *buf;
Xint len;
X{
X  if (len)
X    RcLine(buf);
X}
X
Xstatic void
XInputColon()
X{
X  Input(":", 100, Colonfin, INP_COOKED);
X}
X
Xstatic void
XSelectFin(buf, len)
Xchar *buf;
Xint len;
X{
X  int n;
X
X  if (!len || !display)
X    return;
X  if ((n = WindowByNoN(buf)) < 0)
X    return;
X  SwitchWindow(n);
X}
X    
Xstatic void
XInputSelect()
X{
X  Input("Switch to window: ", 20, SelectFin, INP_COOKED);
X}
X
Xstatic char setenv_var[31];
X
X
Xstatic void
XSetenvFin1(buf, len)
Xchar *buf;
Xint len;
X{
X  if (!len || !display)
X    return;
X  InputSetenv(buf);
X}
X  
Xstatic void
XSetenvFin2(buf, len)
Xchar *buf;
Xint len;
X{
X  struct action act;
X  char *args[3];
X
X  if (!len || !display)
X    return;
X  act.nr = RC_SETENV;
X  args[0] = setenv_var;
X  args[1] = buf;
X  args[2] = NULL;
X  act.args = args;
X  debug2("SetenvFin2: setenv '%s' '%s'\n", setenv_var, buf);
X  DoAction(&act, -1);
X}
X
Xstatic void
XInputSetenv(arg)
Xchar *arg;
X{
X  static char setenv_buf[80];	/* need to be static here, cannot be freed */
X
X  if (arg)
X    {
X      strncpy(setenv_var, arg, 30);
X      sprintf(setenv_buf, "Enter value for %s: ", arg);
X      Input(setenv_buf, 30, SetenvFin2, INP_COOKED);
X    }
X  else
X    Input("Setenv: Enter variable name: ", 30, SetenvFin1, INP_COOKED);
X}
X
Xvoid
XDoScreen(fn, av)
Xchar *fn, **av;
X{
X  struct NewWindow nwin;
X  register int num;
X  char buf[20];
X  char termbuf[25];
X
X  nwin = nwin_undef;
X  termbuf[0] = '\0';
X  while (av && *av && av[0][0] == '-')
X    {
X      switch (av[0][1])
X	{
X	case 'f':
X	  switch (av[0][2])
X	    {
X	    case 'n':
X	    case '0':
X	      nwin.flowflag = FLOW_NOW * 0;
X	      break;
X	    case 'y':
X	    case '1':
X	    case '\0':
X	      nwin.flowflag = FLOW_NOW * 1;
X	      break;
X	    case 'a':
X	      nwin.flowflag = FLOW_AUTOFLAG;
X	      break;
X	    default:
X	      break;
X	    }
X	  break;
X	case 'k':
X	case 't':
X	  if (av[0][2])
X	    nwin.aka = &av[0][2];
X	  else if (*++av)
X	    nwin.aka = *av;
X	  else
X	    --av;
X	  break;
X	case 'T':
X	  if (av[0][2])
X	    nwin.term = &av[0][2];
X	  else if (*++av)
X	    nwin.term = *av;
X	  else
X	    --av;
X	  break;
X	case 'h':
X	  if (av[0][2])
X	    nwin.histheight = atoi(av[0] + 2);
X	  else if (*++av)
X	    nwin.histheight = atoi(*av);
X	  else 
X	    --av;
X	  break;
X#ifdef LOGOUTOK
X	case 'l':
X	  switch (av[0][2])
X	    {
X	    case 'n':
X	    case '0':
X	      nwin.lflag = 0;
X	      break;
X	    case 'y':
X	    case '1':
X	    case '\0':
X	      nwin.lflag = 1;
X	      break;
X	    default:
X	      break;
X	    }
X	  break;
X#endif
X	case 'a':
X	  nwin.aflag = 1;
X	  break;
X	case 'M':
X	  nwin.monitor = MON_ON;
Xdebug("nwin.monitor = MON_ON;\n");
X	  break;
X	default:
X	  Msg(0, "%s: screen: invalid option -%c.", fn, av[0][1]);
X	  break;
X	}
X      ++av;
X    }
X  num = 0;
X  if (av && *av && IsNumColon(*av, 10, buf, sizeof(buf)))
X    {
X      if (*buf != '\0')
X	nwin.aka = buf;
X      num = atoi(*av);
X      if (num < 0 || num > MAXWIN - 1)
X	{
X	  Msg(0, "%s: illegal screen number %d.", fn, num);
X	  num = 0;
X	}
X      nwin.StartAt = num;
X      ++av;
X    }
X  if (av && *av)
X    {
X      nwin.args = av;
X      if (!nwin.aka)
X        nwin.aka = Filename(*av);
X    }
X  MakeWindow(&nwin);
X}
X
X#ifdef COPY_PASTE
X/*
X * CompileKeys must be called before Markroutine is first used.
X * to initialise the keys with defaults, call CompileKeys(NULL, mark_key_tab);
X *
X * s is an ascii string in a termcap-like syntax. It looks like
X *   "j=u:k=d:l=r:h=l: =.:" and so on...
X * this example rebinds the cursormovement to the keys u (up), d (down),
X * l (left), r (right). placing a mark will now be done with ".".
X */
Xint
XCompileKeys(s, array)
Xchar *s, *array;
X{
X  int i;
X  unsigned char key, value;
X
X  if (!s || !*s)
X    {
X      for (i = 0; i < 256; i++)
X        array[i] = i;
X      return 0;
X    }
X  debug1("CompileKeys: '%s'\n", s);
X  while (*s)
X    {
X      s = ParseChar(s, (char *) &key);
X      if (*s != '=')
X	return -1;
X      do 
X	{
X          s = ParseChar(++s, (char *) &value);
X	  array[value] = key;
X	}
X      while (*s == '=');
X      if (!*s) 
X	break;
X      if (*s++ != ':')
X	return -1;
X    }
X  return 0;
X}
X#endif /* COPY_PASTE */
X
X/*
X *  Asynchronous input functions
X */
X
X#ifdef POW_DETACH
Xstatic void
Xpow_detach_fn(buf, len)
Xchar *buf;
Xint len;
X{
X  if (len)
X    {
X      *buf = 0;
X      return;
X    }
X  if (ktab[(int)(unsigned char)*buf].nr != RC_POW_DETACH)
X    {
X      if (display)
X        write(d_userfd, "\007", 1);
X#ifdef NETHACK
X      if (nethackflag)
X	 Msg(0, "The blast of disintegration whizzes by you!");
X#endif
X    }
X  else
X    Detach(D_POWER);
X}
X#endif /* POW_DETACH */
X
X#ifdef COPY_PASTE
Xstatic void
Xcopy_reg_fn(buf, len)
Xchar *buf;
Xint len;
X{
X  struct plop *pp = plop_tab + (int)(unsigned char)*buf;
X
X  if (len)
X    {
X      *buf = 0;
X      return;
X    }
X  if (pp->buf)
X    free(pp->buf);
X  if ((pp->buf = (char *)malloc(d_user->u_copylen)) == NULL)
X    {
X      Msg(0, strnomem);
X      return;
X    }
X  bcopy(d_user->u_copybuffer, pp->buf, d_user->u_copylen);
X  pp->len = d_user->u_copylen;
X  Msg(0, "Copied %d characters into register %c", d_user->u_copylen, *buf);
X}
X
Xstatic void
Xins_reg_fn(buf, len)
Xchar *buf;
Xint len;
X{
X  struct plop *pp = plop_tab + (int)(unsigned char)*buf;
X
X  if (len)
X    {
X      *buf = 0;
X      return;
X    }
X  if (pp->buf)
X    {
X      if (fore->w_pastebuf)
X        free(fore->w_pastebuf);
X      fore->w_pastebuf = 0;
X      fore->w_pasteptr = pp->buf;
X      fore->w_pastelen = pp->len;
X      return;
X    }
X#ifdef NETHACK
X  if (nethackflag)
X    Msg(0, "Nothing happens.");
X  else
X#endif
X  Msg(0, "Empty register.");
X}
X#endif /* COPY_PASTE */
X
Xstatic void
Xprocess_fn(buf, len)
Xchar *buf;
Xint len;
X{
X  struct plop *pp = plop_tab + (int)(unsigned char)*buf;
X
X  if (len)
X    {
X      *buf = 0;
X      return;
X    }
X  if (pp->buf)
X    {
X      ProcessInput(pp->buf, pp->len);
X      return;
X    }
X#ifdef NETHACK
X  if (nethackflag)
X    Msg(0, "Nothing happens.");
X  else
X#endif
X  Msg(0, "Empty register.");
X}
X
X
X#ifdef PASSWORD
X
X/* ARGSUSED */
Xstatic void
Xpass1(buf, len)
Xchar *buf;
Xint len;
X{
X  strncpy(Password, buf, sizeof(Password) - 1);
X  Input("Retype new password:", sizeof(Password) - 1, pass2, 1);
X}
X
X/* ARGSUSED */
Xstatic void
Xpass2(buf, len)
Xchar *buf;
Xint len;
X{
X  int st;
X  char salt[2];
X
X  if (buf == 0 || strcmp(Password, buf))
X    {
X#ifdef NETHACK
X      if (nethackflag)
X	Msg(0, "[ Passwords don't match - your armor crumbles away ]");
X      else
X#endif /* NETHACK */
X        Msg(0, "[ Passwords don't match - checking turned off ]");
X      CheckPassword = 0;
X    }
X  if (Password[0] == '\0')
X    {
X      Msg(0, "[ No password - no secure ]");
X      CheckPassword = 0;
X    }
X  for (st = 0; st < 2; st++)
X    salt[st] = 'A' + (int)((time(0) >> 6 * st) % 26);
X  strncpy(Password, crypt(Password, salt), sizeof(Password));
X  if (CheckPassword)
X    {
X#ifdef COPY_PASTE
X      if (d_user->u_copybuffer)
X	UserFreeCopyBuffer(d_user);
X      d_user->u_copylen = strlen(Password);
X      if ((d_user->u_copybuffer = (char *) malloc(d_user->u_copylen + 1)) == NULL)
X	{
X	  Msg(0, strnomem);
X          d_user->u_copylen = 0;
X	}
X      else
X	{
X	  strcpy(d_user->u_copybuffer, Password);
X	  Msg(0, "[ Password moved into copybuffer ]");
X	}
X#else				/* COPY_PASTE */
X      Msg(0, "[ Crypted password is \"%s\" ]", Password);
X#endif				/* COPY_PASTE */
X    }
X  if (buf)
X    bzero(buf, strlen(buf));
X}
X#endif /* PASSWORD */
X
END_OF_FILE
if test 60864 -ne `wc -c <'process.c'`; then
    echo shar: \"'process.c'\" unpacked with wrong size!
fi
# end of 'process.c'
fi
echo shar: End of archive 7 \(of 10\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 10 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
