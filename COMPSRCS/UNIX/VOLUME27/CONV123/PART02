Newsgroups: comp.sources.unix
From: greg@brooktree.com (Gregory Santos)
Subject: v27i032: conv123 - convert ASCII files to Lotus-123 format, Part02/02
References: <1.747292168.20241@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: greg@brooktree.com (Gregory Santos)
Posting-Number: Volume 27, Issue 32
Archive-Name: conv123/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 2)."
# Contents:  conv123.c grph123.c
# Wrapped by vixie@gw.home.vix.com on Sun Sep  5 22:08:57 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'conv123.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'conv123.c'\"
else
echo shar: Extracting \"'conv123.c'\" \(33229 characters\)
sed "s/^X//" >'conv123.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <fcntl.h>
X#include <string.h>
X#include <stdlib.h>
X
X#include "lotus.h"
X#include "swapb.h"
X
X
X#define MAXHEADLINES 2	/* number of header lines allowed above dash line */
X#define MAXROWS 8192	/* max rows, dependent on 12-bit maximum value */
X#define MAXCOLS 124	/* maximum number of columns in the spreadsheet */
X#define MAXCOLWD 36	/* maximum column width */
X#define MAXINRECLEN (MAXCOLS * MAXCOLWD + 5 * MAXCOLS)
X#define COLEXTEND 1	/* makes cell this much bigger than definition */
X
Xvoid int2s();		/* routine to stuff int bits into char representation */
X
XFILE *infile, *outfile;
X
Xshort current_row;	/* input file record */
Xlong current_offset;	/* output file offset */
X
Xshort col_width[MAXCOLS], col_pos[MAXCOLS], col_type[MAXCOLS];
Xshort formula_start_row[MAXCOLS], formula_end_row[MAXCOLS];
Xshort formula_start_col, formula_end_col;
Xshort decimals(), dec_pl, col_dec_pl[MAXCOLS], row_dec_pl;
X
X/***********************************/
X/* declare lotus record structures */
X/***********************************/
X
XBOF BOFr;
X
XRANGE RANGEr;
XCALCCOUNT CALCCOUNTr;
XCALCMODE CALCMODEr;
XCALCORDER CALCORDERr;
XSPLIT SPLITr;
XSYNC SYNCr;
XWINDOW1 WINDOW1r;
XCOLW1 COLW1r;
XTABLE TABLEr;
XQRANGE QRANGEr;
XPRANGE PRANGEr;
XLABEL LABELr;
X/*  INTEGER INTEGERr; */
XNUMBER NUMBERr;
XFORMULA FORMULAr;    
XLEOF LEOFr;
X
X
X
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X{
X
X/**********************/
X/* main declarations  */
X/**********************/
X
X    int fstat;
X    char *p, *bp, *fp, *sstat;
X    char headerbuf[MAXHEADLINES + 1][MAXINRECLEN + 1];
X    char inbuf[MAXINRECLEN + 1], util_buf[256];
X    char infilename[96];
X    char outfilename[96];
X    char blank_buf[80];
X
X    int i, j, l, debug, fs, us;
X
X    unsigned short i1, j1, l1;
X
X    short number_of_cols, header_lines;
X
X    double dbl_value;
X
X    long RANGE_offset;
X
X/**************************************/
X/* initialize lotus record structures */
X/**************************************/
X
X    int2s(swapb(BOF_op),BOFr.opcode);
X    int2s(swapb(BOF_len),BOFr.record_length);
X    int2s(swapb((unsigned short)1030),BOFr.ff_version);
X
X    int2s(swapb(RANGE_op),RANGEr.opcode);
X    int2s(swapb(RANGE_len),RANGEr.record_length);
X    int2s(swapb((unsigned short)0),RANGEr.start_column);
X    int2s(swapb((unsigned short)0),RANGEr.start_row);
X    int2s(swapb((unsigned short)0),RANGEr.end_column);
X    int2s(swapb((unsigned short)0),RANGEr.end_row);
X
X    int2s(swapb(CALCCOUNT_op),CALCCOUNTr.opcode);
X    int2s(swapb(CALCCOUNT_len),CALCCOUNTr.record_length);
X    *CALCCOUNTr.iteration_count = 1;
X
X    int2s(swapb(CALCMODE_op),CALCMODEr.opcode);
X    int2s(swapb(CALCMODE_len),CALCMODEr.record_length);
X    *CALCMODEr.recalculation = 0xFF;	/* automatic recalc */
X
X    int2s(swapb(CALCORDER_op),CALCORDERr.opcode);
X    int2s(swapb(CALCORDER_len),CALCORDERr.record_length);
X    *CALCORDERr.calc_order = 0x00;	/* natural order */
X
X    int2s(swapb(SPLIT_op),SPLITr.opcode);
X    int2s(swapb(SPLIT_len),SPLITr.record_length);
X    *SPLITr.window_split = 0x00;	/* no window split */
X
X    int2s(swapb(SYNC_op),SYNCr.opcode);
X    int2s(swapb(SYNC_len),SYNCr.record_length);
X    *SYNCr.window_sync = 0xFF;		/* window synchronized */
X
X    int2s(swapb(WINDOW1_op),WINDOW1r.opcode);
X    int2s(swapb(WINDOW1_len),WINDOW1r.record_length);
X    int2s(swapb((unsigned short)0),WINDOW1r.cc_column);
X    int2s(swapb((unsigned short)0),WINDOW1r.cc_row);
X    *WINDOW1r.cell_format = 2;	/* two decimal places */
X    *WINDOW1r.unused1 = 0;
X    int2s(swapb((unsigned short)9),WINDOW1r.column_width);
X    int2s(swapb((unsigned short)8),WINDOW1r.ncol_on_screen);
X    int2s(swapb((unsigned short)20),WINDOW1r.nrow_on_screen);
X    int2s(swapb((unsigned short)0),WINDOW1r.leftmost_column);
X    int2s(swapb((unsigned short)0),WINDOW1r.top_row);
X    int2s(swapb((unsigned short)0),WINDOW1r.ntitle_col);
X    int2s(swapb((unsigned short)0),WINDOW1r.ntitle_row);
X    int2s(swapb((unsigned short)0),WINDOW1r.ltitle_col);
X    int2s(swapb((unsigned short)0),WINDOW1r.ttitle_row);
X    int2s(swapb((unsigned short)4),WINDOW1r.borderwd_col);
X    int2s(swapb((unsigned short)4),WINDOW1r.borderwd_row);
X    int2s(swapb((unsigned short)72),WINDOW1r.window_width);
X    *WINDOW1r.unused2 = 0;
X    *WINDOW1r.unused3 = 0;
X
X    /* there are multiple of these, so just init basic elements for now */
X    int2s(swapb(COLW1_op),COLW1r.opcode);
X    int2s(swapb(COLW1_len),COLW1r.record_length);
X
X
X    int2s(swapb(TABLE_op),TABLEr.opcode);
X    int2s(swapb(TABLE_len),TABLEr.record_length);
X    *TABLEr.table_ind = 0x00;		/* no table */
X    int2s(swapb((unsigned short)0xFFFF),TABLEr.table_start_column);
X    int2s(swapb((unsigned short)0),TABLEr.table_start_row);
X    int2s(swapb((unsigned short)0xFFFF),TABLEr.table_end_column);
X    int2s(swapb((unsigned short)0),TABLEr.table_end_row);
X    int2s(swapb((unsigned short)0xFFFF),TABLEr.cell1_start_column);
X    int2s(swapb((unsigned short)0),TABLEr.cell1_start_row);
X    int2s(swapb((unsigned short)0xFFFF),TABLEr.cell1_end_column);
X    int2s(swapb((unsigned short)0),TABLEr.cell1_end_row);
X    int2s(swapb((unsigned short)0xFFFF),TABLEr.cell2_start_column);
X    int2s(swapb((unsigned short)0),TABLEr.cell2_start_row);
X    int2s(swapb((unsigned short)0xFFFF),TABLEr.cell2_end_column);
X    int2s(swapb((unsigned short)0),TABLEr.cell2_end_row);
X
X
X    int2s(swapb(QRANGE_op),QRANGEr.opcode);
X    int2s(swapb(QRANGE_len),QRANGEr.record_length);
X    int2s(swapb((unsigned short)0xFFFF),QRANGEr.input_start_column);
X    int2s(swapb((unsigned short)0),QRANGEr.input_start_row);
X    int2s(swapb((unsigned short)0xFFFF),QRANGEr.input_end_column);
X    int2s(swapb((unsigned short)0),QRANGEr.input_end_row);
X    int2s(swapb((unsigned short)0xFFFF),QRANGEr.output_start_column);
X    int2s(swapb((unsigned short)0),QRANGEr.output_start_row);
X    int2s(swapb((unsigned short)0xFFFF),QRANGEr.output_end_column);
X    int2s(swapb((unsigned short)0),QRANGEr.output_end_row);
X    int2s(swapb((unsigned short)0xFFFF),QRANGEr.criteria_start_column);
X    int2s(swapb((unsigned short)0),QRANGEr.criteria_start_row);
X    int2s(swapb((unsigned short)0xFFFF),QRANGEr.criteria_end_column);
X    int2s(swapb((unsigned short)0),QRANGEr.criteria_end_row);
X    *QRANGEr.command = 0;		/* no command */
X
X    int2s(swapb(PRANGE_op),PRANGEr.opcode);
X    int2s(swapb(PRANGE_len),PRANGEr.record_length);
X    int2s(swapb((unsigned short)0xFFFF),PRANGEr.start_column);
X    int2s(swapb((unsigned short)0),PRANGEr.start_row);
X    int2s(swapb((unsigned short)0xFFFF),PRANGEr.end_column);
X    int2s(swapb((unsigned short)0),PRANGEr.end_row);
X
X    int2s(swapb(LABEL_op),LABELr.opcode);
X    *LABELr.format = 0xFF;	/* lotus default */
X    *LABELr.position = 0x27;	/* single quote ('), left justified */
X
X
X    int2s(swapb(NUMBER_op),NUMBERr.opcode);
X    int2s(swapb(NUMBER_len),NUMBERr.record_length);
X    *NUMBERr.format = 0xFF;	/* lotus default */
X
X    int2s(swapb(FORMULA_op),FORMULAr.opcode);
X    *FORMULAr.format = 0xFF;	/* lotus default */
X    
X
X    int2s(swapb(LEOF_op),LEOFr.opcode);
X    int2s(swapb(LEOF_len),LEOFr.record_length);
X
X/************************************/
X/* Now some ordinary initialization */
X/************************************/
X
X    current_offset = 0L;
X    current_row = -1;
X
X/*******************************/
X/* assign files                */
X/*******************************/
X
X    infile = stdin;		/* typical input is stdin */
X    outfile = stdout;		/* typical output is stdout */
X
X    debug = 0;			/* don't do it */
X
X/* Make sure blank_buf is initialized */
X
X    for (i = 0; i < 80; i++)
X	blank_buf[i] = ' ';
X
X/************************************/
X/* if there are input parameters,   */
X/* deal with them.                  */
X/************************************/
X
X    if (argc > 3) {
X 	fprintf(stderr,"Allowed parameters are input and output filenames.\n");
X	return(1);
X    }
X
X/* open main data input file as a stream (maybe) */
X    if (argc > 1) {
X        fclose(infile);
X	strcpy(infilename,argv[1]);
X	if ((infile = fopen(infilename,"r")) == NULL) {
X	    fprintf(stderr,"Open of input data file %s failed.\n",infilename);
X	    return(1);
X	}
X    }
X
X/* create and open output file directly (maybe) */
X    if (argc > 2) {
X        fclose(outfile);
X	strcpy(outfilename,argv[2]);
X	if ((outfile = fopen(outfilename,"w+")) == NULL) {
X	    fprintf(stderr,"open of output data file %s failed.\n",outfilename);
X	    fclose(infile);
X	    return;
X	}
X    }
X
X/************************************/
X/* now get to work translating it   */
X/************************************/
X
X    if (get_header_info(headerbuf,&number_of_cols,&header_lines))
X	return(1);
X
X#ifdef DEBUG
X    for (i = 0; i < number_of_cols; i++)
X	fprintf(stderr,"%d %d %d %d\n",i,col_width[i],col_type[i],col_pos[i]);
X    fprintf(stderr,"total columns: %d header lines: %d\n",number_of_cols,header_lines);
X#endif
X
X/************************************/
X/* we've got SOMETHING, so go ahead */
X/* and start the 123 output!        */
X/************************************/
X
X    p = (char *)(&BOFr);
X    fs = output_lotus_record(p);
X
X#ifdef DEBUG
X    fprintf(stderr,"Offset after BOF: %d\n",current_offset);
X#endif
X
X/** might as well set the number of columns now, since we know it **/
X    RANGE_offset = current_offset;
X    int2s(swapb((unsigned short)(number_of_cols - 1)),RANGEr.end_column);
X    p = (char *)(&RANGEr);
X    output_lotus_record(p);
X
X#ifdef DEBUG
X    fprintf(stderr,"Offset after RANGE: %d\n",current_offset);
X#endif
X
X/************************************/
X/* and how about the column widths  */
X/************************************/
X
X    p = (char *)(&COLW1r);
X    for (j = 0; j < number_of_cols; j++) {
X	int2s(swapb(j),COLW1r.column_number);
X	j1 = col_width[j] + COLEXTEND;
X	int2s(swapb(j1),COLW1r.column_width);
X	output_lotus_record(p);
X    }
X
X#ifdef DEBUG
X    fprintf(stderr,"Column width records added...\n");
X#endif
X
X/**********************************/
X/* create header labels, if there */
X/*  are any to create             */
X/**********************************/
X
X    if (header_lines) {
X	p = (char *)(&LABELr);
X
X	current_row = -1;
X	for (i = 0; i <= header_lines; i++) {
X		current_row++;
X		for (j = 0; j < number_of_cols; j++) {
X		    int2s(swapb(j),LABELr.column);
X		    int2s(swapb((unsigned short)current_row),LABELr.row);
X		    *LABELr.string = '\0';
X		    strncat(LABELr.string,(headerbuf[i] + col_pos[j]),col_width[j]);
X		    int2s(swapb((unsigned short)(strlen(LABELr.string) + 7)),
X				LABELr.record_length);
X		    output_lotus_record(p);
X		}
X
X	}
X    }
X
X#ifdef DEBUG
X    fprintf(stderr,"Offset after LABELS: %d\n",current_offset);
X#endif
X
X/* end of header processing */
X
X/*******************************/
X/* process remaining lines     */
X/*******************************/
X
X
X    while ((fs = getline(inbuf,MAXINRECLEN,infile)) != EOF) {
X
X	formula_start_col = -1;		/* start out pessimistic */
X	formula_end_col = -1;
X	row_dec_pl = 0;
X
X	for (j = 0; j < number_of_cols; j++) {
X	  if (col_pos[j] < fs) {	/* get paranoid about short lines */
X	    *util_buf = '\0';
X	    strncat(util_buf,(inbuf + col_pos[j]),col_width[j]);
X	    us = trim(util_buf);
X	    if (us > 0) {
X	    if (sscanf(util_buf," %lf%n",&dbl_value,&l) && (us == l)) {
X#ifdef DEBUG
X	      fprintf(stderr,"%d %d %s|\n",us,l,util_buf);
X#endif
X		/*** just a number; keep track of start/end values ***/
X		if (formula_start_row[j] < 0)
X		    formula_start_row[j] = current_row;
X		formula_end_row[j] = current_row;
X		if (formula_start_col < 0)
X		    formula_start_col = j;
X		formula_end_col = j;
X
X		if ((dec_pl = decimals(util_buf)) > col_dec_pl[j])
X		    col_dec_pl[j] = dec_pl;
X		if (dec_pl > row_dec_pl)
X		    row_dec_pl = dec_pl;
X
X		p = (char *)(&NUMBERr);
X
X		*NUMBERr.format = (char)(0x80 + dec_pl);
X		int2s(swapb(j),NUMBERr.column);
X		int2s(swapb((unsigned short)current_row),NUMBERr.row);
X		stdbl(dbl_value,NUMBERr.value);
X		output_lotus_record(p);
X
X	    } else if (*util_buf == '@') {  /* test for formula */
X		if (fstat = create_formula_record(util_buf,j)) {
X		    fprintf(stderr,"Bad formula at line %d, error %d\n",current_row,fstat);
X		    return(1);
X		}
X		if (!strcmp(util_buf,"@NUL")) {	/* it's a placeholder */
X		    if (formula_start_row[j] < 0)
X			formula_start_row[j] = current_row;
X		    formula_end_row[j] = current_row;
X		    if (formula_start_col < 0)
X			formula_start_col = j;
X		    formula_end_col = j;
X		}
X		    
X	      } else {		/* OK, so it's just a plain-old string  */
X				/* check for string override characters */
X		if (us > 1 && (*util_buf == '\'' || *util_buf == '"')) {
X			*LABELr.position = *util_buf;
X			*util_buf = ' ';
X			us = trim(util_buf);
X		}
X		p = (char *)(&LABELr);
X		col_type[j] = 0;	/* non_numeric column */
X		formula_start_row[j] = formula_end_row[j] = -1;
X		formula_start_col = formula_end_col = -1;
X		col_dec_pl[j] = row_dec_pl = 0;
X		int2s(swapb(j),LABELr.column);
X		int2s(swapb((unsigned short)current_row),LABELr.row);
X		strcpy(LABELr.string,util_buf);
X		int2s(swapb((unsigned short)(strlen(LABELr.string) + 7)),
X			    LABELr.record_length);
X		output_lotus_record(p);
X		*LABELr.position = 0x27; /* single quote, left-justified */
X	    }
X	  }
X	 }
X	}
X    }
X
X
X/*********************/
X/* end of lotus file */
X/*********************/
X
X    p = (char *)(&LEOFr);
X    output_lotus_record(p);
X
X}
X
X/*****************************************/
X/* scan input record for column widths   */
X/* and return values                     */
X/*****************************************/
X
Xint
Xget_header_info(bufp,cols,hlines)
Xchar bufp[][MAXINRECLEN + 1];
Xshort *cols, *hlines;
X{
X    int  i, j, count = -1;
X    char c;
X
X    for (i = 0; i < MAXHEADLINES; i++)
X	bufp[i][0] = '\0';
X    *hlines = -1;
X
X    do {
X	if (++(*hlines) > MAXHEADLINES || !getline(bufp[*hlines],MAXINRECLEN,infile)) {
X	    fprintf(stderr,"Could not locate column definition within %d lines in input file.\n",MAXHEADLINES);
X	    return(1);
X	}
X    } while (bufp[*hlines][0] != '-');
X
X/*** now find out the number of columns and their widths ***/
X
X    count = j = 0;
X    while (bufp[*hlines][j]) {
X	i = 0;
X	while (bufp[*hlines][j + i] == '-') {
X	    i++;
X	}
X	col_width[count] = i;
X	col_pos[count] = j;
X	col_type[count] = 1;		/* just initialization */
X	formula_start_row[count] = -1;	/* just initialization */
X	formula_end_row[count] = -1;	/* just initialization */
X	col_dec_pl[count] = 0;		/* just initialization */
X	count++;
X	j += i;
X	while (bufp[*hlines][j] && (bufp[*hlines][j] != '-')) {
X		j++;
X	}
X    }
X    *cols = count;
X
X    return(0);
X}
X
X/*************************************************/
X/* create a lotus formula - uses a couple of     */
X/* other routines, returns zero if successful    */
X/*************************************************/
X
Xint
Xcreate_formula_record(formbuf,c_col)
Xchar *formbuf;
Xshort c_col;	/* current column; current row is global (Emerson) */
X{
X    short dec_pl, s_col, s_row, e_col, e_row;
X    short s2_col, s2_row, e2_col, e2_row;
X    short rvalue, bfunction = 0;
X    char *bp, util_buf[256];
X    char *bnamebuf = "+-*/%";
X    int ichar;
X
X/****************************************************/
X/* If formbuf is a binary function, normalize the   */
X/* formula buffer -- ranges are already normalized, */
X/* so just copy                                     */
X/****************************************************/
X
X    bp = util_buf;
X    *bp = '\0';
X    if (strchr(bnamebuf,*(formbuf + 2)) != NULL) { /* binary function */
X	bfunction++;
X	strncat(bp,formbuf,3);
X	strcat(bp,"  ");
X	strcat(bp,(formbuf + 3));
X    } else
X	strcat(bp,formbuf);
X
X/* now for any trailing number */
X
X    rvalue = atoi(bp + 5) - 1;
X#ifdef DEBUG
X  fprintf(stderr,"range override value: %d\n",rvalue);
X#endif
X
X/****************************************/
X/* Figure out if all the ranges are     */
X/* valid in their context, i.e.,        */
X/* column-wise or row-wise; then do it, */
X/* then reset.                          */
X/****************************************/
X
X    ichar = *(++bp);
X    switch (ichar) {
X
X    case 'B':		/* column-wise + one row value formula; uses   */
X			/* default ranges for column, override for row */
X
X/***********/
X/* R stuff -- determine start and end columns; row is known */
X/***********/
X
X	s2_row = current_row;
X	e2_row = current_row;
X
X/*************************************************/
X/* decide whether to override the default start  */
X/* column; note: decimal places are not affected */
X/*************************************************/
X
X	s2_col = formula_start_col;	/* start out optimistic */
X
X/* if it's a binary function, back up one step for start */
X
X	if (bfunction)
X	    s2_col = formula_end_col - 1;
X
X/* if there's an override, try to use it */
X
X	if ((rvalue > -1) && (rvalue <= formula_end_col))
X	    s2_col = rvalue;
X	else
X	    rvalue = -1;
X
X/* if all has failed, just use current location for start AND end */
X
X	if (s2_col < 0) {
X	    s2_col = c_col;
X	    e2_col = c_col;
X	} else
X	e2_col = formula_end_col;
X
X/***********/
X/* C stuff -- determine start and end rows; column is known */
X/***********/
X
X	if ((s_row = formula_start_row[c_col]) < 0) {
X	    s_row = current_row;
X	    e_row = current_row;
X	} else
X	    e_row = formula_end_row[c_col];
X
X/* B stuff -- number of decimal places */
X
X	dec_pl = (row_dec_pl > col_dec_pl[c_col]) ? row_dec_pl : col_dec_pl[c_col];
X
X	if (create_lotus_multiple(bp,dec_pl,c_col,c_col,s_row,c_col,e_row,s2_col,s2_row,e2_col,e2_row,rvalue))
X	    return(3);
X
X	/* reset default row range and dec, set default column range, end */
X	formula_start_col = -1;
X	formula_end_col = -1;
X	row_dec_pl = 0;
X
X	if (formula_start_row[c_col] < 0)
X	    formula_start_row[c_col] = current_row;
X	formula_end_row[c_col] = current_row;
X	if (dec_pl > col_dec_pl[c_col])
X	    col_dec_pl[c_col] = dec_pl;
X
X	/* reset default column range and dec, set row default range, end */
X	formula_start_row[c_col] = -1;
X	formula_end_row[c_col] = -1;
X	col_dec_pl[c_col] = 0;
X
X	if (formula_start_col < 0)
X	    formula_start_col = c_col;
X	formula_end_col = c_col;
X	if (dec_pl > row_dec_pl)
X	    row_dec_pl = dec_pl;
X
X	break;
X
X    case 'C':		/* column-wise formulae; just uses default ranges */
X
X	dec_pl = col_dec_pl[c_col];
X
X	if ((s_row = formula_start_row[c_col]) < 0) {
X	    s_row = current_row;
X	    e_row = current_row;
X	} else
X	    e_row = formula_end_row[c_col];
X
X	/* if it's a binary function, force the back up one step */
X	if (bfunction && (current_row > 2)) {
X	  s_row = current_row - 2;
X	  e_row = current_row - 1;
X	}
X
X	if (create_lotus_formula(bp,dec_pl,c_col,c_col,s_row,c_col,e_row,rvalue))
X	    return(3);
X
X	/* reset default column range and dec, set row default range, end */
X	formula_start_row[c_col] = -1;
X	formula_end_row[c_col] = -1;
X	col_dec_pl[c_col] = 0;
X
X	if (formula_start_col < 0)
X	    formula_start_col = c_col;
X	formula_end_col = c_col;
X	if (dec_pl > row_dec_pl)
X	    row_dec_pl = dec_pl;
X
X	break;
X
X    case 'R':		/* row-wise formula - check also for specified range */
X
X	s_row = current_row;
X	e_row = current_row;
X	dec_pl = row_dec_pl;
X
X/*************************************************/
X/* decide whether to override the default start  */
X/* column; note: decimal places are not affected */
X/*************************************************/
X
X	s_col = formula_start_col;	/* start out optimistic */
X
X/* if it's a binary function, back up one step for start */
X
X	if (bfunction)
X	    s_col = formula_end_col - 1;
X
X/* if there's an override, try to use it */
X
X	if ((rvalue > -1) && (rvalue <= formula_end_col))
X	    s_col = rvalue;
X	else
X	    rvalue = -1;
X
X/* if all has failed, just use current location for start AND end */
X
X	if (s_col < 0) {
X	    s_col = c_col;
X	    e_col = c_col;
X	} else
X	e_col = formula_end_col;
X
X	if (create_lotus_formula(bp,dec_pl,c_col,s_col,s_row,e_col,e_row,rvalue))
X	    return(3);
X
X	/* reset default row range and dec, set default column range, end */
X	formula_start_col = -1;
X	formula_end_col = -1;
X	row_dec_pl = 0;
X
X	if (formula_start_row[c_col] < 0)
X	    formula_start_row[c_col] = current_row;
X	formula_end_row[c_col] = current_row;
X	if (dec_pl > col_dec_pl[c_col])
X	    col_dec_pl[c_col] = dec_pl;
X	break;
X
X    case 'N':		/* null function; just return, increment counters */
X	break;
X
X    default:
X	return(4);
X	break;
X    }
X
X    return(0);
X}
X
X/*****************************************************/
X/* The decisions made in create_formula_record       */
X/* are carried out here, or in create_lotus_multiple */
X/*****************************************************/
X
Xint
Xcreate_lotus_formula(formbuf,dec_pl,c_col,s_col,s_row,e_col,e_row,rvalue)
Xchar *formbuf;
Xshort dec_pl, c_col, s_col, s_row, e_col, e_row;
Xshort rvalue;
X{
X    int i;
X    char *fc, *fp, *findex, *lrp, util_buf[256];
X    double mult = 0.0;
X
X    char *namebuf = "~~~SUMAVGCNTMINMAXVARSTD+  -  *  /  %  NUL";
X    unsigned short opcodes[14];/* = { 0xFF, 0x50, 0x51, 0x52, 0x53, 0x54, 0x57,
X				 0x58, 0x09, 0x0A, 0x0B, 0x0C, 0x0C, 0xFF }; */
X
X    opcodes[0] = 0xFF; opcodes[1] = 0x50; opcodes[2] = 0x51; opcodes[3] = 0x52;
X    opcodes[4] = 0x53; opcodes[5] = 0x54; opcodes[6] = 0x57; opcodes[7] = 0x58;
X    opcodes[8] = 0x09; opcodes[9] = 0x0A; opcodes[10] = 0x0B;
X    opcodes[11] = 0x0C; opcodes[12] = 0x0C; opcodes[13] = 0xFF;
X
X    /*** find which formula ***/
X    fp = ++formbuf;
X    *util_buf = '\0';
X    strncat(util_buf,fp,3);
X#ifdef DEBUG
X
X    fprintf(stderr,"util_buf holds formula string |%s|\n",util_buf);
X#endif
X    if ((findex = strstr(namebuf,util_buf)) == NULL) {
X#ifdef DEBUG
X      fprintf(stderr,"findex returns null!\n");
X#endif
X	return(4);
X	}
X
X    lrp = (char *)(&FORMULAr);
X
X    *FORMULAr.format = (char)(0x80 + dec_pl);
X    int2s(swapb(c_col),FORMULAr.column);
X    int2s(swapb((unsigned short)current_row),FORMULAr.row);
X    fc = FORMULAr.formula_code;
X
X    /** fill in the actual lotus formula **/
X
X    i = findex - namebuf;
X    i = i / 3;
X
X    switch (i) {
X
X    case 1:		/* summation */
X    case 2:		/* average */
X    case 3:		/* count */
X    case 4:		/* minimum */
X    case 5:		/* maximum */
X    case 6:		/* variance */
X    case 7:		/* standard deviation */
X
X	    *(fc++) = 0x02;		/* range */
X	    create_formula_range(fc,c_col,s_col,s_row,e_col,e_row,1);
X	    fc += 8;
X	    *(fc++) = opcodes[i];	/* lotus opcode */
X	    *(fc++) = 0x01;		/* make it a variable? */
X	    *(fc++) = 0x03;		/* end of formula - return */
X	    int2s(swapb((unsigned short)(fc - FORMULAr.formula_code)),FORMULAr.formula_size);
X	    int2s(swapb((unsigned short)(fc - FORMULAr.formula_code + 15)),FORMULAr.record_length);
X	    output_lotus_record(lrp);
X	    break;
X
X    case 8:		/* addition */
X    case 10:		/* multiplication */
X
X	    *(fc++) = 0x01;		/* variable */
X	    create_formula_range(fc,c_col,s_col,s_row,0,0,0);
X	    fc += 4;
X	    *(fc++) = 0x01;		/* variable */
X	    create_formula_range(fc,c_col,e_col,e_row,0,0,0);
X	    fc += 4;
X	    *(fc++) = opcodes[i];	/* lotus opcode */
X	    *(fc++) = 0x04;		/* parentheses? */
X	    *(fc++) = 0x03;		/* end of formula - return */
X	    int2s(swapb((unsigned short)(fc - FORMULAr.formula_code)),FORMULAr.formula_size);
X	    int2s(swapb((unsigned short)(fc - FORMULAr.formula_code + 15)),FORMULAr.record_length);
X	    output_lotus_record(lrp);
X	    break;
X
X    case 12:		/* percent (not a lotus function) */
X	    mult = 100.00;
X	    if (dec_pl < 1)
X		*FORMULAr.format = (char)(0x80 + 2);
X    case 9:		/* subtraction */
X    case 11:		/* division */
X
X	    *(fc++) = 0x01;		/* variable */
X	    if (rvalue > -1)
X		create_formula_range(fc,c_col,e_col,e_row,0,0,0);
X	    else
X		create_formula_range(fc,c_col,s_col,s_row,0,0,0);
X	    fc += 4;
X	    *(fc++) = 0x01;		/* variable */
X	    if (rvalue > -1)
X		create_formula_range(fc,c_col,s_col,s_row,0,0,0);
X	    else
X		create_formula_range(fc,c_col,e_col,e_row,0,0,0);
X	    fc += 4;
X	    *(fc++) = opcodes[i];	/* lotus opcode */
X	    if (mult != 0.0) {
X		*(fc++) = 0x00;		/* constant */
X		stdbl(mult,fc);
X		fc += 8;
X		*(fc++) = 0x0B;		/* multiply */
X	    }
X	    *(fc++) = 0x04;		/* parentheses? */
X	    *(fc++) = 0x03;		/* end of formula - return */
X	    int2s(swapb((unsigned short)(fc - FORMULAr.formula_code)),FORMULAr.formula_size);
X	    int2s(swapb((unsigned short)(fc - FORMULAr.formula_code + 15)),FORMULAr.record_length);
X	    output_lotus_record(lrp);
X	    break;
X    case 13:		/* null - do nothing */
X	    ;
X	    break;
X
X    default:
X	    return(1);
X	    break;
X    }
X
X    return(0);
X}
X
X/*************************************************/
X/* create a multiple formula (addition of two    */
X/* formulae, row and column)                     */
X/*************************************************/
X
Xint
Xcreate_lotus_multiple(formbuf,dec_pl,c_col,s_col,s_row,e_col,e_row,
X                                 s2_col,s2_row,e2_col,e2_row,rvalue)
Xchar *formbuf;
Xshort dec_pl, c_col, s_col, s_row, e_col, e_row;
Xshort s2_col, s2_row, e2_col, e2_row;
Xshort rvalue;
X{
X    int i;
X    char *fc, *fp, *findex, *lrp, util_buf[256];
X    double mult = 0.0;
X
X    char *namebuf = "~~~SUMAVGCNTMINMAXVARSTD+  -  *  /  %  NUL";
X    unsigned short opcodes[14];/* = { 0xFF, 0x50, 0x51, 0x52, 0x53, 0x54, 0x57,
X				 0x58, 0x09, 0x0A, 0x0B, 0x0C, 0x0C, 0xFF }; */
X
X    opcodes[0] = 0xFF; opcodes[1] = 0x50; opcodes[2] = 0x51; opcodes[3] = 0x52;
X    opcodes[4] = 0x53; opcodes[5] = 0x54; opcodes[6] = 0x57; opcodes[7] = 0x58;
X    opcodes[8] = 0x09; opcodes[9] = 0x0A; opcodes[10] = 0x0B;
X    opcodes[11] = 0x0C; opcodes[12] = 0x0C; opcodes[13] = 0xFF;
X
X    /*** find which formula ***/
X    fp = ++formbuf;
X    *util_buf = '\0';
X    strncat(util_buf,fp,3);
X#ifdef DEBUG
X    fprintf(stderr,"util_buf holds formula string |%s|\n",util_buf);
X#endif
X    if ((findex = strstr(namebuf,util_buf)) == NULL) {
X#ifdef DEBUG
X      fprintf(stderr,"findex returns null!\n");
X#endif
X	return(4);
X	}
X
X    lrp = (char *)(&FORMULAr);
X
X    *FORMULAr.format = (char)(0x80 + dec_pl);
X    int2s(swapb(c_col),FORMULAr.column);
X    int2s(swapb((unsigned short)current_row),FORMULAr.row);
X    fc = FORMULAr.formula_code;
X
X    /** fill in the actual lotus formula **/
X
X    i = findex - namebuf;
X    i = i / 3;
X
X    switch (i) {
X
X    case 1:		/* summation */
X    case 2:		/* average */
X    case 3:		/* count */
X    case 4:		/* minimum */
X    case 5:		/* maximum */
X    case 6:		/* variance */
X    case 7:		/* standard deviation */
X
X	    *(fc++) = 0x02;		/* range */
X	    create_formula_range(fc,c_col,s_col,s_row,e_col,e_row,1);
X	    fc += 8;
X	    *(fc++) = opcodes[i];	/* lotus opcode */
X	    *(fc++) = 0x01;		/* make it a variable? */
X	    *(fc++) = 0x02;		/* range */
X	    create_formula_range(fc,c_col,s2_col,s2_row,e2_col,e2_row,1);
X	    fc += 8;
X	    *(fc++) = opcodes[i];	/* lotus opcode */
X	    *(fc++) = 0x01;		/* make it another variable? */
X	    *(fc++) = 0x09;		/* addition of two ranges */
X	    *(fc++) = 0x04;		/* parentheses? */
X	    *(fc++) = 0x03;		/* end of formula - return */
X	    int2s(swapb((unsigned short)(fc - FORMULAr.formula_code)),FORMULAr.formula_size);
X	    int2s(swapb((unsigned short)(fc - FORMULAr.formula_code + 15)),FORMULAr.record_length);
X	    output_lotus_record(lrp);
X	    break;
X
X    case 8:		/* addition */
X    case 10:		/* multiplication */
X
X	    *(fc++) = 0x01;		/* variable */
X	    create_formula_range(fc,c_col,s_col,s_row,0,0,0);
X	    fc += 4;
X	    *(fc++) = 0x01;		/* variable */
X	    create_formula_range(fc,c_col,e_col,e_row,0,0,0);
X	    fc += 4;
X	    *(fc++) = opcodes[i];	/* lotus opcode */
X	    *(fc++) = 0x04;		/* parentheses? */
X	    *(fc++) = 0x03;		/* end of formula - return */
X	    int2s(swapb((unsigned short)(fc - FORMULAr.formula_code)),FORMULAr.formula_size);
X	    int2s(swapb((unsigned short)(fc - FORMULAr.formula_code + 15)),FORMULAr.record_length);
X	    output_lotus_record(lrp);
X	    break;
X
X    case 12:		/* percent (not a lotus function) */
X	    mult = 100.00;
X	    if (dec_pl < 1)
X		*FORMULAr.format = (char)(0x80 + 2);
X    case 9:		/* subtraction */
X    case 11:		/* division */
X
X	    *(fc++) = 0x01;		/* variable */
X	    if (rvalue > -1)
X		create_formula_range(fc,c_col,e_col,e_row,0,0,0);
X	    else
X		create_formula_range(fc,c_col,s_col,s_row,0,0,0);
X	    fc += 4;
X	    *(fc++) = 0x01;		/* variable */
X	    if (rvalue > -1)
X		create_formula_range(fc,c_col,s_col,s_row,0,0,0);
X	    else
X		create_formula_range(fc,c_col,e_col,e_row,0,0,0);
X	    fc += 4;
X	    *(fc++) = opcodes[i];	/* lotus opcode */
X	    if (mult != 0.0) {
X		*(fc++) = 0x00;		/* constant */
X		stdbl(mult,fc);
X		fc += 8;
X		*(fc++) = 0x0B;		/* multiply */
X	    }
X	    *(fc++) = 0x04;		/* parentheses? */
X	    *(fc++) = 0x03;		/* end of formula - return */
X	    int2s(swapb((unsigned short)(fc - FORMULAr.formula_code)),FORMULAr.formula_size);
X	    int2s(swapb((unsigned short)(fc - FORMULAr.formula_code + 15)),FORMULAr.record_length);
X	    output_lotus_record(lrp);
X	    break;
X    case 13:		/* null - do nothing */
X	    ;
X	    break;
X
X    default:
X	    return(1);
X	    break;
X    }
X
X    return(0);
X}
X
X/*****************************************/
X/* output a lotus record -- note that    */
X/* the length of the record is contained */
X/* in the record itself (bytes 2-3)      */
X/* minus the 4 bytes of opcode+length    */
X/*****************************************/
X
Xint
Xoutput_lotus_record(record_pointer)
Xchar *record_pointer;
X{
X    int i, fstatus;
X    unsigned short total_length = 0;
X
X    total_length = swapb((unsigned short)s2int(record_pointer + 2)) + 4;
X
X    for (i = 0; i < total_length; i++)
X	fstatus = putc(*record_pointer++,outfile);
X
X    current_offset += (long)total_length;
X
X    return(fstatus);
X
X}
X
X/***********************************/
X/* our own getline -- like fgets,  */
X/* just returns null-term string   */
X/* instead of newline, and length  */
X/* instead of pointer              */
X/***********************************/
X
Xint
Xgetline(s,lim,stream)
Xchar s[];
Xint lim;
Xregister FILE *stream;
X{
X    int c, i;
X
X    i = 0;
X    while (--lim > 0 && (c = getc(stream)) != EOF && c != '\n')
X      s[i++] = c;
X
X    if (c == EOF)
X	return(c);
X
X    s[i] = '\0';
X    current_row++;
X
X    return(i);
X
X}
X
X/******************************/
X/* machine dependent routines */
X/******************************/
X
Xint
Xstdbl(value,ptr)
Xdouble value;
Xchar *ptr;
X{
X    int i = 7;
X    char *dp;
X
X    dp = (char *)&value;
X    while (i > -1)
X	*ptr++ = *(dp + (i--));
X}
X
X/*****************************************/
X/* return a new string, with the first   */
X/* character non-whitespace.  Look out;  */
X/* it does clobber the passed contents,  */
X/* but returns the length of the result .*/
X/*****************************************/
X
Xint
Xtrim(p)
Xregister char *p;
X{
X    int i;
X    char *hp, *np;
X
X    hp = np = p;
X
X    while(*p && (*p == ' ' || *p == '\t'))
X	p++;
X    while (*p)
X	*np++ = *p++;
X
X    *np = '\0';
X    for (i = strlen(hp) - 1; (i > 0) && (*(hp+i) == ' '); i--)
X	*(--np) = '\0';
X
X    return((int)(np - hp));
X}
X
X/**********************************************************************/
X/* create a lotus formula range...lotus cell addresses are of two     */
X/* types, absolute and relative.  Absolute address place 0,0 at the   *
X/* upper left corner of the spreadsheet.  Relative address are        */
X/* "circular" relative, and are all negative.  The current cell is    */
X/* address -32768 (the maximum 16-bit signed negative).  The cell     */
X/* position immediately "above" or "left" of the current cell is      */
X/* -1, decreasing as you "decrease" your position.  The cell position */
X/* immediately "below" or "right" of the current cell is -32767,      */
X/* increasing as you "increase" your position.                        */
X/*                                                                    */
X/* The "type" parameter is simply a flag to indicate whether the      */
X/* range is a true range, all four parameters (type = 1), or whether  */
X/* it is just a column position (type = 0).  In the latter case, only */
X/* the start column and start row are done.                           */
X/*                                                                    */
X/* Oh, by the way;  don't forget to byte-swap each 16-bits if your    */
X/* computer is a big-endian!                                          */
X/**********************************************************************/
X
Xint
Xcreate_formula_range(range_ptr,c_col,s_col,s_row,e_col,e_row,type)
Xchar *range_ptr;
Xshort c_col, s_col, s_row, e_col, e_row;
Xint type;
X{
X    short rel_ptr;
X    char *p;
X
X    p = range_ptr;
X
X	rel_ptr = (s_col < c_col) ? (s_col - c_col - 8192) : (s_col - c_col - 32768);
X	int2s(swapb((unsigned short)rel_ptr),p);
X	p += 2;
X	rel_ptr = (s_row < current_row) ? (s_row - current_row - 8192) : (s_row - current_row - 32768);
X	int2s(swapb((unsigned short)rel_ptr),p);
X    if (type) {
X	p += 2;
X	rel_ptr = (e_col < c_col) ? (e_col - c_col - 8192) : (e_col - c_col - 32768);
X	int2s(swapb((unsigned short)rel_ptr),p);
X	p += 2;
X	rel_ptr = (e_row < current_row) ? (e_row - current_row - 8192) : (e_row - current_row - 32768);
X	int2s(swapb((unsigned short)rel_ptr),p);
X    }
X
X    return(0);
X
X}
X
X
X/**********************************************/
X/* Routine to count number of decimal places  */
X/* assumes that numbuf is already "trimmed"   */
X/* (i.e., no leading white space).            */
X/**********************************************/
X
Xshort
Xdecimals(numbuf)
Xchar	*numbuf;
X{
X	char *c, *p;
X
X	if ((p = strchr(numbuf,'.')) == NULL)
X	    return((short)0);
X
X	c = ++p;
X	while (*c && isdigit(*c))
X	    c++;
X
X	return((short)(c - p));
X}
END_OF_FILE
if test 33229 -ne `wc -c <'conv123.c'`; then
    echo shar: \"'conv123.c'\" unpacked with wrong size!
fi
# end of 'conv123.c'
fi
if test -f 'grph123.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'grph123.c'\"
else
echo shar: Extracting \"'grph123.c'\" \(29598 characters\)
sed "s/^X//" >'grph123.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <fcntl.h>
X#include <string.h>
X#include <stdlib.h>
X
X#include "lotus.h"
X#include "swapb.h"
X
X
X#define MAXHEADLINES 2
X#define MAXROWS 8192	/* dependent on 12-bit maximum value */
X#define MAXCOLS 53	/* arbitrary */
X#define MAXCOLWD 39	/* used only to calculate max input rec length */
X			/* and x data value length                     */
X#define MAXINRECLEN (MAXCOLS * MAXCOLWD + 5 * MAXCOLS)
X#define COLEXTEND 2	/* amount to widen columns for 123 */
X
XFILE *infile, *outfile;
X
Xshort current_row, current_graph;
Xlong current_offset;	/* output file offset */
X
Xshort col_width[MAXCOLS], col_pos[MAXCOLS], col_type[MAXCOLS];
Xshort formula_start_row[MAXCOLS], formula_end_row[MAXCOLS];
Xshort formula_start_col, formula_end_col;
Xshort decimals(), dec_pl, col_dec_pl[MAXCOLS], row_dec_pl;
X
Xint  y_decpl[6];
Xchar *qtstr();
X
X/***********************************/
X/* declare lotus record structures */
X/***********************************/
X
XBOF BOFr;
X
XRANGE RANGEr;
XCALCCOUNT CALCCOUNTr;
XCALCMODE CALCMODEr;
XCALCORDER CALCORDERr;
XSPLIT SPLITr;
XSYNC SYNCr;
XWINDOW1 WINDOW1r;
XCOLW1 COLW1r;
XNGRAPH NGRAPHr;
XTABLE TABLEr;
XQRANGE QRANGEr;
XPRANGE PRANGEr;
XLABEL LABELr;
X/*  INTEGER INTEGERr; */
XNUMBER NUMBERr;
XFORMULA FORMULAr;    
XLEOF LEOFr;
X
X/* now for the main data structure, which has limits -- this  */
X/* monster is (somewhat) necessary in order to allow the      */
X/* flexibility of getting all the data (and labels) in before */
X/* writing the NGRAPH record...                               */
X
Xstruct {
X    char	x_item[MAXCOLWD+1];
X    double	y_item[6];
X    short	number_of_labels;
X    char	y_label[6][20];
X} graph_data[MAXCOLS];
X
X/*****************************/
X/* finally, we begin         */
X/*****************************/
X
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X{
X
X/**********************/
X/* main declarations  */
X/**********************/
X
X    int fstat;
X    char c;
X    char *p, *bp, *cp, *fp, *sp, *sstat;
X    char inbuf[MAXINRECLEN + 1], util_buf[MAXINRECLEN + 1], util_buf2[100];
X    char infilename[96];
X    char outfilename[96];
X    char blank_buf[80];
X
X    int i, j, k, l, debug, fs, us, type_ind, label_ready;
X
X    unsigned short i1, j1, l1;
X
X    short number_of_cols, number_of_rows;
X    short number_of_graphs, header_lines, max_title;
X    char   str_value[6][41];
X    double dbl_value[6];
X
X    long RANGE_offset;
X
X/**************************************/
X/* initialize lotus record structures */
X/**************************************/
X
X    int2s(swapb(BOF_op),BOFr.opcode);
X    int2s(swapb(BOF_len),BOFr.record_length);
X    int2s(swapb((unsigned short)1030),BOFr.ff_version);
X
X    int2s(swapb(RANGE_op),RANGEr.opcode);
X    int2s(swapb(RANGE_len),RANGEr.record_length);
X    int2s(swapb((unsigned short)0),RANGEr.start_column);
X    int2s(swapb((unsigned short)0),RANGEr.start_row);
X    int2s(swapb((unsigned short)0),RANGEr.end_column);
X    int2s(swapb((unsigned short)0),RANGEr.end_row);
X
X    int2s(swapb(CALCCOUNT_op),CALCCOUNTr.opcode);
X    int2s(swapb(CALCCOUNT_len),CALCCOUNTr.record_length);
X    *CALCCOUNTr.iteration_count = 1;
X
X    int2s(swapb(CALCMODE_op),CALCMODEr.opcode);
X    int2s(swapb(CALCMODE_len),CALCMODEr.record_length);
X    *CALCMODEr.recalculation = 0xFF;	/* automatic recalc */
X
X    int2s(swapb(CALCORDER_op),CALCORDERr.opcode);
X    int2s(swapb(CALCORDER_len),CALCORDERr.record_length);
X    *CALCORDERr.calc_order = 0x00;	/* natural order */
X
X    int2s(swapb(SPLIT_op),SPLITr.opcode);
X    int2s(swapb(SPLIT_len),SPLITr.record_length);
X    *SPLITr.window_split = 0x00;	/* no window split */
X
X    int2s(swapb(SYNC_op),SYNCr.opcode);
X    int2s(swapb(SYNC_len),SYNCr.record_length);
X    *SYNCr.window_sync = 0xFF;		/* window synchronized */
X
X    int2s(swapb(WINDOW1_op),WINDOW1r.opcode);
X    int2s(swapb(WINDOW1_len),WINDOW1r.record_length);
X    int2s(swapb((unsigned short)0),WINDOW1r.cc_column);
X    int2s(swapb((unsigned short)0),WINDOW1r.cc_row);
X    *WINDOW1r.cell_format = 2;	/* two decimal places */
X    *WINDOW1r.unused1 = 0;
X    int2s(swapb((unsigned short)9),WINDOW1r.column_width);
X    int2s(swapb((unsigned short)8),WINDOW1r.ncol_on_screen);
X    int2s(swapb((unsigned short)20),WINDOW1r.nrow_on_screen);
X    int2s(swapb((unsigned short)0),WINDOW1r.leftmost_column);
X    int2s(swapb((unsigned short)0),WINDOW1r.top_row);
X    int2s(swapb((unsigned short)0),WINDOW1r.ntitle_col);
X    int2s(swapb((unsigned short)0),WINDOW1r.ntitle_row);
X    int2s(swapb((unsigned short)0),WINDOW1r.ltitle_col);
X    int2s(swapb((unsigned short)0),WINDOW1r.ttitle_row);
X    int2s(swapb((unsigned short)4),WINDOW1r.borderwd_col);
X    int2s(swapb((unsigned short)4),WINDOW1r.borderwd_row);
X    int2s(swapb((unsigned short)72),WINDOW1r.window_width);
X    *WINDOW1r.unused2 = 0;
X    *WINDOW1r.unused3 = 0;
X
X    /* there are multiple of these, so just init basic elements for now */
X    int2s(swapb(COLW1_op),COLW1r.opcode);
X    int2s(swapb(COLW1_len),COLW1r.record_length);
X
X
X    /* there are multiple of these, so just init basic elements for now */
X    int2s(swapb(NGRAPH_op),NGRAPHr.opcode);
X    int2s(swapb(NGRAPH_len),NGRAPHr.record_length);
X
X
X    int2s(swapb(TABLE_op),TABLEr.opcode);
X    int2s(swapb(TABLE_len),TABLEr.record_length);
X    *TABLEr.table_ind = 0x00;		/* no table */
X    int2s(swapb((unsigned short)0xFFFF),TABLEr.table_start_column);
X    int2s(swapb((unsigned short)0),TABLEr.table_start_row);
X    int2s(swapb((unsigned short)0xFFFF),TABLEr.table_end_column);
X    int2s(swapb((unsigned short)0),TABLEr.table_end_row);
X    int2s(swapb((unsigned short)0xFFFF),TABLEr.cell1_start_column);
X    int2s(swapb((unsigned short)0),TABLEr.cell1_start_row);
X    int2s(swapb((unsigned short)0xFFFF),TABLEr.cell1_end_column);
X    int2s(swapb((unsigned short)0),TABLEr.cell1_end_row);
X    int2s(swapb((unsigned short)0xFFFF),TABLEr.cell2_start_column);
X    int2s(swapb((unsigned short)0),TABLEr.cell2_start_row);
X    int2s(swapb((unsigned short)0xFFFF),TABLEr.cell2_end_column);
X    int2s(swapb((unsigned short)0),TABLEr.cell2_end_row);
X
X
X    int2s(swapb(QRANGE_op),QRANGEr.opcode);
X    int2s(swapb(QRANGE_len),QRANGEr.record_length);
X    int2s(swapb((unsigned short)0xFFFF),QRANGEr.input_start_column);
X    int2s(swapb((unsigned short)0),QRANGEr.input_start_row);
X    int2s(swapb((unsigned short)0xFFFF),QRANGEr.input_end_column);
X    int2s(swapb((unsigned short)0),QRANGEr.input_end_row);
X    int2s(swapb((unsigned short)0xFFFF),QRANGEr.output_start_column);
X    int2s(swapb((unsigned short)0),QRANGEr.output_start_row);
X    int2s(swapb((unsigned short)0xFFFF),QRANGEr.output_end_column);
X    int2s(swapb((unsigned short)0),QRANGEr.output_end_row);
X    int2s(swapb((unsigned short)0xFFFF),QRANGEr.criteria_start_column);
X    int2s(swapb((unsigned short)0),QRANGEr.criteria_start_row);
X    int2s(swapb((unsigned short)0xFFFF),QRANGEr.criteria_end_column);
X    int2s(swapb((unsigned short)0),QRANGEr.criteria_end_row);
X    *QRANGEr.command = 0;		/* no command */
X
X    int2s(swapb(PRANGE_op),PRANGEr.opcode);
X    int2s(swapb(PRANGE_len),PRANGEr.record_length);
X    int2s(swapb((unsigned short)0xFFFF),PRANGEr.start_column);
X    int2s(swapb((unsigned short)0),PRANGEr.start_row);
X    int2s(swapb((unsigned short)0xFFFF),PRANGEr.end_column);
X    int2s(swapb((unsigned short)0),PRANGEr.end_row);
X
X    int2s(swapb(LABEL_op),LABELr.opcode);
X    *LABELr.format = 0xFF;	/* lotus default */
X    *LABELr.position = 0x27;	/* single quote ('), left justified */
X
X
X    int2s(swapb(NUMBER_op),NUMBERr.opcode);
X    int2s(swapb(NUMBER_len),NUMBERr.record_length);
X    *NUMBERr.format = 0xFF;	/* lotus default */
X
X    int2s(swapb(FORMULA_op),FORMULAr.opcode);
X    *FORMULAr.format = 0xFF;	/* lotus default */
X    
X
X    int2s(swapb(LEOF_op),LEOFr.opcode);
X    int2s(swapb(LEOF_len),LEOFr.record_length);
X
X/************************************/
X/* Now some ordinary initialization */
X/************************************/
X
X    current_offset = 0L;
X    current_graph = 0;
X    type_ind = 0;
X
X    number_of_cols = 0;
X    number_of_rows = 0;
X    label_ready = 0;
X    max_title = 18;
X
X/*******************************/
X/* assign files                */
X/*******************************/
X
X    infile = stdin;			/* typical input is stdin (filter) */
X    outfile = stdout;			/* typical output is stdout (filter) */
X
X    debug = 0;				/* don't do it */
X
X/* Make sure blank_buf is initialized */
X
X    for (i = 0; i < 80; i++)
X	blank_buf[i] = ' ';
X
X/************************************/
X/* if there are input parameters,   */
X/* deal with them.                  */
X/************************************/
X
X    if (argc > 3) {
X 	fprintf(stderr,"Allowed parameters are input and output filenames.\n");
X	return(1);
X    }
X
X/* open main data input file as a stream (maybe) */
X    if (argc > 1) {
X        fclose(infile);
X	strcpy(infilename,argv[1]);
X	if ((infile = fopen(infilename,"r")) == NULL) {
X	    fprintf(stderr,"Open of input data file %s failed.\n",infilename);
X	    return(1);
X	}
X    }
X
X/* create and open output file directly (maybe) */
X    if (argc > 2) {
X        fclose(outfile);
X	strcpy(outfilename,argv[2]);
X	if ((outfile = fopen(outfilename,"w+")) == NULL) {
X	    fprintf(stderr,"open of output data file %s failed.\n",outfilename);
X	    fclose(infile);
X	    return;
X	}
X    }
X
X/************************************/
X/* now get to work translating it   */
X/************************************/
X
X    if (get_header_info(inbuf,&number_of_graphs,&header_lines))
X	return(1);
X    if (number_of_graphs < 1) {
X	fprintf(stderr,"No graphs were detected...check input file.");
X	exit(1);
X    }
X
X    current_row = number_of_graphs + 6;	/* leave room for titles & stuff */
X
X/* fprintf(stderr,"Number of graphs: %d\n",number_of_graphs); */
X
X/************************************/
X/* we've got SOMETHING, so go ahead */
X/* and start the 123 output!        */
X/************************************/
X
X    p = (char *)(&BOFr);
X    fs = output_lotus_record(p);
X
X    p = (char *)(&CALCMODEr);
X    fs = output_lotus_record(p);
X
X#ifdef DEBUG
X    fprintf(stderr,"Offset after RANGE: %d\n",current_offset);
X#endif
X
X/**********************************/
X/* create header labels           */
X/**********************************/
X
X    create_lotus_label("Brooktree Corp. Confidential",0,0);
X    *LABELr.format = 0x7F;
X    create_lotus_label("Graph Name",0,2);
X    create_lotus_label("Graph Title",1,2);
X    create_lotus_label("================",0,3);
X    create_lotus_label("==============================",1,3);
X    *LABELr.format = 0xFF;
X
X/**********************************/
X/* do the real work, and process  */
X/* all lines in the file          */
X/**********************************/
X
X    while ((fs = getline(inbuf,MAXINRECLEN,infile)) != EOF) {
X
X/**	formula_start_col = -1;		/* start out pessimistic */
X/**	formula_end_col = -1; **/
X	row_dec_pl = 0;
X
X      if (trim(inbuf) > 0) {
X	type_ind = (int)(*inbuf);
X/* fprintf(stderr,"Now doing type: %c\n",*inbuf); */
X	switch (type_ind) {
X	    case 'N':
X	    case 'n':				/* graph name */
X/************************************/
X/* initialize named graph structure */
X/************************************/
X
X    sp = (char *)&NGRAPHr;
X    sp = sp + 4;				/* skip over opcode & size */
X    for (i = 0; i < (sizeof(NGRAPHr) - 4); i++)
X	*sp++ = '\0';
X    *NGRAPHr.graph_type = (char)(0x04);		/* line graph */
X    *NGRAPHr.x_format = (char)(0x71);
X    *NGRAPHr.y_format = (char)(0x71);
X    int2s(swapb((unsigned short)(0x01)),NGRAPHr.skip_factor);
X    for (i = 0; i < 6; i++) {
X	int2s((unsigned short)(0xFFFF),NGRAPHr.yd_range[i].y_start_col);
X	int2s((unsigned short)(0xFFFF),NGRAPHr.yd_range[i].y_end_col);
X	int2s((unsigned short)(0xFFFF),NGRAPHr.yl_range[i].y_start_col);
X	int2s((unsigned short)(0xFFFF),NGRAPHr.yl_range[i].y_end_col);
X	NGRAPHr.y_lformat[i] = (char)(0x03);
X	y_decpl[i] = 2;
X    }
X
X		strcpy(util_buf,&inbuf[1]);
X		us = trim(util_buf);
X		if (us > 0) {
X		    sp = qtstr(util_buf,util_buf,15);
X		    strcpy(NGRAPHr.graph_name,util_buf);
X		}
X		break;
X	    case 'T':				/* First title */
X		strcpy(util_buf,&inbuf[1]);
X		us = trim(util_buf);
X		if (us > 0) {
X		    sp = qtstr(util_buf,util_buf,39);
X		    strcpy(NGRAPHr.first_title,util_buf);
X		}
X		break;
X	    case 't':				/* Second title */
X		strcpy(util_buf,&inbuf[1]);
X		us = trim(util_buf);
X		if (us > 0) {
X		    sp = qtstr(util_buf,util_buf,39);
X		    strcpy(NGRAPHr.second_title,util_buf);
X		}
X		break;
X	    case 'B':
X	    case 'b':				/* x (bottom) title */
X		strcpy(util_buf,&inbuf[1]);
X		us = trim(util_buf);
X		if (us > 0) {
X		    sp = qtstr(util_buf,util_buf,39);
X		    strcpy(NGRAPHr.x_title,util_buf);
X		    if (max_title < strlen(util_buf))
X			max_title = strlen(util_buf);
X		}
X		break;
X	    case 'S':
X	    case 's':				/* y (side) title */
X		strcpy(util_buf,&inbuf[1]);
X		us = trim(util_buf);
X		if (us > 0) {
X		    sp = qtstr(util_buf,util_buf,39);
X		    strcpy(NGRAPHr.y_title,util_buf);
X		}
X		break;
X	    case 'G':
X	    case 'g':
X		strcpy(util_buf,&inbuf[1]);
X		us = trim(util_buf);
X		if (us > 0) {
X		    for (i = 0; i < 4; i++)
X			*str_value[i] = '\0';
X		    us = sscanf(util_buf,"%s%s%s%s",str_value[0],
X						    str_value[1],
X						    str_value[2],
X						    str_value[3]);
X		    if (us > 0) {
X			c = toupper((char)(*str_value[0]));
X			if (c == 'L')
X			  *NGRAPHr.graph_type = (char)(0x04); /* line */
X			else
X			if (c == 'B')
X			  *NGRAPHr.graph_type = (char)(0x01); /* bar */
X			else
X			if (c == 'P')
X			  *NGRAPHr.graph_type = (char)(0x02); /* pie */
X			else
X			if (c == 'X')
X			  *NGRAPHr.graph_type = (char)(0x00); /* xy */
X			else
X			if (c == 'S')
X			  *NGRAPHr.graph_type = (char)(0x05); /* stacked bar */
X		    }
X		    if (us > 1) {
X			c = toupper((char)(*str_value[1]));
X			if (c == 'N')
X			  *NGRAPHr.grid = (char)(0x00); /* none */
X			else
X			if (c == 'H')
X			  *NGRAPHr.grid = (char)(0x01); /* horizontal */
X			else
X			if (c == 'V')
X			  *NGRAPHr.grid = (char)(0x02); /* vertical */
X			else
X			if (c == 'B')
X			  *NGRAPHr.grid = (char)(0x03); /* both horz & vert */
X		    }
X		    if (us > 2) {
X			c = toupper((char)(*str_value[2]));
X			if (c == 'B')
X			  *NGRAPHr.color = (char)(0x00); /* black & white */
X			else
X			if (c == 'C')
X			  *NGRAPHr.color = (char)(0xFF); /* color */
X		    }
X		    if (us > 3) {
X			sscanf(str_value[3],"%d",&i);
X			if (!i)
X			    i = 1;
X			if (i > 256)
X			    i = 256;
X			int2s(swapb((unsigned short)i),NGRAPHr.skip_factor);
X		    }
X		}
X		break;
X	    case 'l':					/* legends */
X		strcpy(util_buf,&inbuf[1]);
X		us = trim(util_buf);
X		if (us > 0) {
X		    sp = util_buf;
X		    for (i = 0; *sp && (i < 6); i++) {
X			sp = qtstr(sp,util_buf2,19);
X			strcpy(NGRAPHr.y_legend[i],util_buf2);
X		    }
X		}
X		break;
X	    case 'P':
X	    case 'p':
X		strcpy(util_buf,&inbuf[1]);
X		us = trim(util_buf);
X		if (us <= 0)
X		    break;
X		us = sscanf(util_buf,"%d%d%d%d%d%d",&(y_decpl[0]),
X						    &(y_decpl[1]),
X						    &(y_decpl[2]),
X						    &(y_decpl[3]),
X						    &(y_decpl[4]),
X						    &(y_decpl[5]));
X                for (i = 0; i < us; i++) {
X                    if (y_decpl[i] < 0) y_decpl[i] = 0;
X                    if (y_decpl[6] > 6) y_decpl[i] = 6;
X		}
X/* fprintf(stderr,"decpl: %d %d %d %d %d %d\n",y_decpl[0],y_decpl[1],y_decpl[2],
X					y_decpl[3],y_decpl[4],y_decpl[5]); */
X		break;
X	    case 'D':
X	    case 'd':
X		strcpy(util_buf,&inbuf[1]);
X		us = trim(util_buf);
X		if (us <= 0)
X		    break;
X		sp = util_buf;
X		sp = qtstr(sp,util_buf2,39);
X		if (strlen(util_buf2) > 0) {
X		    number_of_rows++;
X		    if (number_of_rows > MAXCOLS) {
X			fprintf(stderr,
X                                  "Maximum number of data points exceeded.");
X			exit(3);
X		    }
X		    i = number_of_rows - 1;
X		    strcpy(graph_data[i].x_item,util_buf2);
X		    for (j = 0; j < 6; j++) {
X			graph_data[i].y_item[j] = -2000000000.0;
X			*(graph_data[i].y_label[j]) = '\0';
X		    }
X		    us = sscanf(sp,"%lf%lf%lf%lf%lf%lf",
X			    &(graph_data[i].y_item[0]),
X			    &(graph_data[i].y_item[1]),
X			    &(graph_data[i].y_item[2]),
X			    &(graph_data[i].y_item[3]),
X			    &(graph_data[i].y_item[4]),
X			    &(graph_data[i].y_item[5]));
X		    number_of_cols = us > number_of_cols ? us : number_of_cols;
X		    graph_data[i].number_of_labels = 0;
X		    label_ready = 1;
X		}		    
X		break;
X	    case 'L':					/* labels */
X		strcpy(util_buf,&inbuf[1]);
X		us = trim(util_buf);
X		if (us <= 0)
X		    break;
X		if (!label_ready)
X		    break;
X		i = number_of_rows - 1;
X		sp = util_buf;
X		for (j = 0; *sp && (j < 6); j++) {
X		    sp = qtstr(sp,util_buf2,19);
X		    strcpy(graph_data[i].y_label[j],util_buf2);
X		    (graph_data[i].number_of_labels)++;
X		}
X		label_ready = 0;
X
X		break;
X	    case 'X':
X	    case 'x':
X		strcpy(util_buf,&inbuf[1]);
X		us = trim(util_buf);
X		if (us > 0) {
X		    us = sscanf(util_buf,"%lf%lf",&dbl_value[0],&dbl_value[1]);
X		    if (us > 0) stdbl(dbl_value[0],NGRAPHr.x_low_limit);
X		    if (us > 1) stdbl(dbl_value[1],NGRAPHr.x_up_limit);
X		    *NGRAPHr.x_scale = (char)(0xFF);
X		}
X		break;
X	    case 'Y':
X	    case 'y':
X		strcpy(util_buf,&inbuf[1]);
X		us = trim(util_buf);
X		if (us > 0) {
X		    us = sscanf(util_buf,"%lf%lf",&dbl_value[0],&dbl_value[1]);
X		    if (us > 0) stdbl(dbl_value[0],NGRAPHr.y_low_limit);
X		    if (us > 1) stdbl(dbl_value[1],NGRAPHr.y_up_limit);
X		    *NGRAPHr.y_scale = (char)(0xFF);
X		}
X		break;
X	    case 'F':
X	    case 'f':
X		strcpy(util_buf,&inbuf[1]);
X		us = trim(util_buf);
X		if (us > 0) {
X		    us = sscanf(util_buf,"%s%s%s%s%s%s",str_value[0],
X						  str_value[1],
X						  str_value[2],
X						  str_value[3],
X						  str_value[4],
X						  str_value[5]);
X		    for (i = 0; i < us; i++) {
X			c = toupper((char)(*str_value[i]));
X			if (c == 'N')
X			  NGRAPHr.y_lformat[i] = (char)(0x00); /* none */
X			else
X			if (c == 'L')
X			  NGRAPHr.y_lformat[i] = (char)(0x01); /* line */
X			else
X			if (c == 'S')
X			  NGRAPHr.y_lformat[i] = (char)(0x02); /* symbol */
X			else
X			if (c == 'B')
X			  NGRAPHr.y_lformat[i] = (char)(0x03); /* both l & s */
X		    }
X		  }
X		break;
X	    case 'A':
X	    case 'a':
X		strcpy(util_buf,&inbuf[1]);
X		us = trim(util_buf);
X		if (us > 0) {
X		    us = sscanf(util_buf,"%s%s%s%s%s%s",str_value[0],
X						  str_value[1],
X						  str_value[2],
X						  str_value[3],
X						  str_value[4],
X						  str_value[5]);
X		    for (i = 0; i < us; i++) {
X			c = toupper((char)(*str_value[i]));
X			if (c == 'C')
X			  NGRAPHr.y_dlalign[i] = (char)(0x00); /* none */
X			else
X			if (c == 'R')
X			  NGRAPHr.y_dlalign[i] = (char)(0x01); /* line */
X			else
X			if (c == 'B')
X			  NGRAPHr.y_dlalign[i] = (char)(0x02); /* symbol */
X			else
X			if (c == 'L')
X			  NGRAPHr.y_dlalign[i] = (char)(0x03); /* both l & s */
X			else
X			if (c == 'A')
X			  NGRAPHr.y_dlalign[i] = (char)(0x04); /* both l & s */
X		    }
X		  }
X		break;
X	    case 'E':
X	    case 'e':
X
X		if (number_of_cols <= 0)	/* if there's no y-data, */
X		    break;			/* just bail out         */
X
X		/* how about setting the first (0) column width  */
X
X		p = (char *)(&COLW1r);
X		int2s(swapb((unsigned short)0),COLW1r.column_number);
X		int2s(swapb(max_title),COLW1r.column_width);
X		output_lotus_record(p);
X
X		/* now let's put out the table of contents info */
X		*LABELr.position = 0x27;	/* single quote ('), lj  */
X
X		p = (char *)(&LABELr);
X		j1 = 0; i1 = ++current_graph + 3;
X 		create_lotus_label(NGRAPHr.graph_name,j1,i1);
X		j1 = 1;
X		create_lotus_label(NGRAPHr.first_title,j1,i1);
X
X		/* Data values header */
X		j1 = 0; i1 = current_row++;
X		sprintf(util_buf,"Data for graph: %s (%s)",
X				  NGRAPHr.graph_name,NGRAPHr.first_title);
X		*LABELr.format = 0x7F;	/* lotus default */
X		create_lotus_label(util_buf,j1,i1);
X		*LABELr.format = 0xFF;	/* lotus default */
X
X
X		/* the x-value and y-value legends and ranges comes next */
X		j1 = 0; i1 = current_row;
X		create_lotus_label(NGRAPHr.x_title,j1,i1);
X
X		int2s(swapb((unsigned short)1),NGRAPHr.x_start_col);
X		int2s(swapb(i1),NGRAPHr.x_start_row);
X		int2s(swapb(number_of_rows),NGRAPHr.x_end_col);
X		int2s(swapb(i1),NGRAPHr.x_end_row);
X
X		for (j = 0; j < number_of_cols; j++) {
X		    i1 = current_row + j + 1;
X		    create_lotus_label(NGRAPHr.y_legend[j],j1,i1);
X		}
X
X		for (j = 0; j < number_of_cols; j++) {
X		    i1 = current_row + j + 1;
X
X		    int2s(swapb((unsigned short)1),
X					      NGRAPHr.yd_range[j].y_start_col);
X		    int2s(swapb(i1),NGRAPHr.yd_range[j].y_start_row);
X		    int2s(swapb(number_of_rows),NGRAPHr.yd_range[j].y_end_col);
X		    int2s(swapb(i1),NGRAPHr.yd_range[j].y_end_row);
X
X		/* the data-label range comes next; even if no labels */
X		/* note that this limits a graph to 127 data points   */
X		    int2s(swapb((unsigned short)(number_of_rows + 2)),
X					      NGRAPHr.yl_range[j].y_start_col);
X		    int2s(swapb(i1),NGRAPHr.yl_range[j].y_start_row);
X		    int2s(swapb((unsigned short)((2 * number_of_rows) + 2)),
X						NGRAPHr.yl_range[j].y_end_col);
X		    int2s(swapb(i1),NGRAPHr.yl_range[j].y_end_row);
X
X		}
X
X		/* let's write that graph record! */
X		p = (char *)(&NGRAPHr);
X		output_lotus_record(p);
X
X		/*******************************************************/
X		/* now for the data values (at last!)                  */
X		/*******************************************************/
X		*LABELr.position = 0x22;	/* double quote ("), rj */
X
X		for (i = 0; i < number_of_rows; i++) {
X		    /* set column width, hard-coded for now */
X		    p = (char *)(&COLW1r);
X		    j1 = i + 1;
X		    i1 = 11 + COLEXTEND;
X		    int2s(swapb(j1),COLW1r.column_number);
X		    int2s(swapb(i1),COLW1r.column_width);
X		    output_lotus_record(p);
X
X		    /* now for the independent data value (x-value) */
X		    j1 = i + 1; i1 = current_row;
X		    if (*NGRAPHr.graph_type)
X			create_lotus_label(graph_data[i].x_item,j1,i1);
X		    else {
X			us = sscanf(graph_data[i].x_item,"%lf",&dbl_value[0]);
X			if (us && (dbl_value[0] > -2000000000.0))
X			    create_lotus_number(dbl_value[0],j1,i1,2);
X		    }
X
X		    /* now for the dependent data values (y-values) */
X		    /* put out the numbers, and labels if any       */
X		    *LABELr.position = 0x27;	/* single quote ('), lj */
X		    j1 = i + 1;
X		    for (j = 0; j < number_of_cols; j++) {
X			dec_pl = y_decpl[j];
X			i1 = current_row + j + 1;
X			if (graph_data[i].y_item[j] > -2000000000.0)
X			  create_lotus_number(graph_data[i].y_item[j],
X								j1,i1,dec_pl);
X			if (graph_data[i].number_of_labels >= j) {
X			    l1 = j1 + number_of_rows + 1;
X			    create_lotus_label(graph_data[i].y_label[j],l1,i1);
X			}
X		    }
X		    *LABELr.position = 0x22;	/* double quote ("), rj */
X		}
X
X		current_row += number_of_cols + 2;
X
X		number_of_cols = 0;
X		number_of_rows = 0;
X		label_ready = 0;
X/*		max_title = 18;  */
X
X		break;
X	    case '#':
X		break;
X	    default:
X		fprintf(stderr,"Unknown record type!\n");
X		break;
X	}
X      }
X    } /* end while */
X
X/*********************/
X/* end of lotus file */
X/*********************/
X
X    p = (char *)(&LEOFr);
X    output_lotus_record(p);
X
X}
X
X/*****************************************/
X/* scan input file for number of graphs, */
X/* column widths, etc.                   */
X/*****************************************/
X
Xint
Xget_header_info(bufp,graphs,hlines)
Xchar *bufp;
Xshort *graphs, *hlines;
X{
X    int  i, j, count = -1;
X    char c;
X
X    *bufp = '\0';
X    *graphs = 0;
X    while (getline(bufp,MAXINRECLEN,infile) != EOF) {
X	j = trim(bufp);
X	if ('E' == toupper(*bufp))
X	    ++(*graphs);
X      }
X    rewind(infile);
X    return(0);
X}
X
X
X/*****************************************/
X/* create and output a lotus label       */
X/*****************************************/
X
Xint
Xcreate_lotus_label(label,lcol,lrow)
Xchar *label;
Xshort lcol;
Xshort lrow;
X{
X    int i,j;
X    short c1, r1;
X    char *p;
X
X    p = (char *)(&LABELr);
X    int2s(swapb(lcol),LABELr.column);
X    int2s(swapb(lrow),LABELr.row);
X    *LABELr.string = '\0';
X    strcat(LABELr.string,label);
X/* fprintf(stderr,"x: %s\n",LABELr.string); */
X    int2s(swapb((unsigned short)(strlen(LABELr.string) + 7)),
X					LABELr.record_length);
X    output_lotus_record(p);
X    return(0);
X}
X
X/*****************************************/
X/* create and output a lotus number      */
X/*****************************************/
X
Xint
Xcreate_lotus_number(number,ncol,nrow,ndp)
Xdouble number;
Xshort ncol;
Xshort nrow;
Xshort ndp;
X{
X    int i,j;
X    short c1, r1;
X    char *p;
X
X    p = (char *)(&NUMBERr);
X    int2s(swapb(ncol),NUMBERr.column);
X    int2s(swapb(nrow),NUMBERr.row);
X    *NUMBERr.format = (char)(0x80 + ndp);
X    stdbl(number,NUMBERr.value);
X    output_lotus_record(p);
X    return(0);
X}
X
X/*****************************************/
X/* output a lotus record -- note that    */
X/* the length of the record is contained */
X/* in the record itself (bytes 2-3)      */
X/* minus the 4 bytes of opcode+length    */
X/*****************************************/
X
Xint
Xoutput_lotus_record(record_pointer)
Xchar *record_pointer;
X{
X    int i, fstatus;
X    unsigned short total_length = 0;
X
X    total_length = swapb((unsigned short)s2int(record_pointer + 2)) + 4;
X
X    for (i = 0; i < total_length; i++)
X	fstatus = putc(*record_pointer++,outfile);
X
X    current_offset += (long)total_length;
X
X    return(fstatus);
X
X}
X
X/***********************************/
X/* our own getline -- like fgets,  */
X/* just returns null-term string   */
X/* instead of newline, and length  */
X/* instead of pointer              */
X/***********************************/
X
Xint
Xgetline(s,lim,stream)
Xchar s[];
Xint lim;
Xregister FILE *stream;
X{
X    int c, i;
X
X    i = 0;
X    while (--lim > 0 && (c = getc(stream)) != EOF && c != '\n')
X      s[i++] = c;
X
X    if (c == EOF)
X	return(c);
X
X    s[i] = '\0';
X/*    current_row++; */
X
X    return(i);
X
X}
X
Xint
Xstdbl(value,ptr)
Xdouble value;
Xchar *ptr;
X{
X    int i = 7;
X    char *dp;
X
X    dp = (char *)&value;
X    while (i > -1)
X	*ptr++ = *(dp + (i--));
X}
X
X/*****************************************/
X/* return a new string, with the first   */
X/* character non-whitespace.  Look out;  */
X/* it does clobber the passed contents,  */
X/* but returns the length of the result .*/
X/*****************************************/
X
Xint
Xtrim(p)
Xregister char *p;
X{
X    char *hp, *np;
X
X    if (*p != ' ' && *p != '\t')
X	return(strlen(p));
X
X    hp = np = p;
X
X    while(*p && (*p == ' ' || *p == '\t'))
X	p++;
X    while (*p)
X	*np++ = *p++;
X
X    *np = '\0';
X    return((int)(np - hp));
X}
X
X/*****************************************/
X/* fix a string, with the double quotes  */
X/* removed, and to a maximum length (not */
X/* including eos) NOTE: this routine     */
X/* may alter 'instr'.                    */
X/*****************************************/
X
Xchar *
Xqtstr(instr,outstr,maxlen)
Xchar *instr;
Xchar *outstr;
Xint  maxlen;
X{
X    int i, q;
X    char *isp, *osp;
X
X    q = 0;
X    i = trim(instr); /* it may be altered right here */
X    isp = instr;
X    osp = outstr;
X    if (*isp == '"') {
X	++isp;
X	q++;
X    }
X    for (i = 0; ((i < maxlen) && *isp && ((q && *isp != '"') || (!q && *isp != ' '))); i++)
X	    *osp++ = *isp++;
X    *osp = '\0';
X
X    if (i >= maxlen)
X	while (*isp && *isp != ' ' && *isp != '\t' && *isp != '"')
X	    isp++;
X    return(*isp ? ++isp : isp);
X}
X
X/**********************************************************************/
X/* create a lotus formula range...lotus cell addresses are of two     */
X/* types, absolute and relative.  Absolute address place 0,0 at the   *
X/* upper left corner of the spreadsheet.  Relative address are        */
X/* "circular" relative, and are all negative.  The current cell is    */
X/* address -32768 (the maximum 16-bit signed negative).  The cell     */
X/* position immediately "above" or "left" of the current cell is      */
X/* -1, decreasing as you "decrease" your position.  The cell position */
X/* immediately "below" or "right" of the current cell is -32767,      */
X/* increasing as you "increase" your position.                        */
X/*                                                                    */
X/* c_col ("current" column) and c_row ("current" row) are actually    */
X/* just relative starting points for the addresses that follow them.  */
X/* The "type" parameter is simply a flag to indicate whether the      */
X/* range is a true range, all four parameters (type = 1), or whether  */
X/* it is just a column position (type = 0).  In the latter case, only */
X/* the start column and start row are done.                           */
X/*                                                                    */
X/* Oh, by the way;  don't forget to byte-swap each 16-bits if your    */
X/* computer is a big-endian!                                          */
X/**********************************************************************/
X
Xint
Xcreate_formula_range(range_ptr,c_col,c_row,s_col,s_row,e_col,e_row,type)
Xchar *range_ptr;
Xshort c_col, c_row, s_col, s_row, e_col, e_row;
Xint type;
X{
X    short rel_ptr;
X    char *p;
X
X    p = range_ptr;
X
X	rel_ptr = (s_col < c_col) ? (s_col - c_col - 8192) : (s_col - c_col - 32768);
X	int2s(swapb((unsigned short)rel_ptr),p);
X	p += 2;
X	rel_ptr = (s_row < c_row) ? (s_row - c_row - 8192) : (s_row - c_row - 32768);
X	int2s(swapb((unsigned short)rel_ptr),p);
X    if (type) {
X	p += 2;
X	rel_ptr = (e_col < c_col) ? (e_col - c_col - 8192) : (e_col - c_col - 32768);
X	int2s(swapb((unsigned short)rel_ptr),p);
X	p += 2;
X	rel_ptr = (e_row < c_row) ? (e_row - c_row - 8192) : (e_row - c_row - 32768);
X	int2s(swapb((unsigned short)rel_ptr),p);
X    }
X
X    return(0);
X
X}
X
X
X/**********************************************/
X/* Routine to count number of decimal places  */
X/* assumes that numbuf is already "trimmed"   */
X/* (i.e., no leading white space).            */
X/**********************************************/
X
Xshort
Xdecimals(numbuf)
Xchar	*numbuf;
X{
X	char *c, *p;
X
X	if ((p = strchr(numbuf,'.')) == NULL)
X	    return((short)0);
X
X	c = ++p;
X	while (*c && isdigit(*c))
X	    c++;
X
X	return((short)(c - p));
X}
END_OF_FILE
if test 29598 -ne `wc -c <'grph123.c'`; then
    echo shar: \"'grph123.c'\" unpacked with wrong size!
fi
# end of 'grph123.c'
fi
echo shar: End of archive 2 \(of 2\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
