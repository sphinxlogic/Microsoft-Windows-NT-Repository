Newsgroups: comp.sources.unix
From: envbvs@epb12.lbl.gov (Brian V. Smith)
Subject: v27i059: transfig-2.1.8 - a set of tools for creating TeX documents with graphics, Part05/07
References: <1.749903574.10622@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: envbvs@epb12.lbl.gov (Brian V. Smith)
Posting-Number: Volume 27, Issue 59
Archive-Name: transfig-2.1.8/part05

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 7)."
# Contents:  fig2dev/dev/genlatex.c fig2dev/dev/gentpic.c
# Wrapped by envbvs@epb12.lbl.gov.lbl.gov on Fri Oct  1 14:55:49 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'fig2dev/dev/genlatex.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fig2dev/dev/genlatex.c'\"
else
echo shar: Extracting \"'fig2dev/dev/genlatex.c'\" \(23356 characters\)
sed "s/^X//" >'fig2dev/dev/genlatex.c' <<'END_OF_FILE'
X/*
X * TransFig: Facility for Translating Fig code
X * Copyright (c) 1985 Supoj Sutantavibul
X * Copyright (c) 1991 Micah Beck
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation. The authors make no representations about the suitability 
X * of this software for any purpose.  It is provided "as is" without express 
X * or implied warranty.
X *
X * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
X * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
X * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X *
X */
X
X/* 
X *	genlatex.c : LaTeX driver for fig2dev
X *
X *	Author: Frank Schmuck, Cornell University 6/88
X * 	Converted from fig2latex 5/89 by Micah Beck
X * 	Color, rotated text and ISO-chars added by Herbert Bauer 11/91
X *
X */
X#if defined(hpux) || defined(SYSV)
X#include <sys/types.h>
X#endif
X#include <sys/file.h>
X#include <stdio.h>
X#include <math.h>
X#include "object.h"
X#include "fig2dev.h"
X#include "texfonts.h"
X#include "pi.h"
X
X#ifndef fabs
Xextern double fabs();
X#endif
X#ifndef sin
Xextern double sin();
X#endif
X#ifndef cos
Xextern double cos();
X#endif
X#ifndef acos
Xextern double acos();
X#endif
X#ifndef atan
Xextern double atan();
X#endif
Xextern double rad2deg;
Xextern void unpsfont();
X
X#define rint(a) floor((a)+0.5)     /* close enough? */
X
X/* 
X *  Installation dependent constants:
X *
X *  THINDOT	latex command for generating a dot if line width = \thinlines
X *  THICKDOT	latex command for generating a dot if line width = \thicklines
X *  MIN_LEN	shortest slanted line that latex can produce; shorter lines will
X *		we translated into a sequence of dots generated by \multiput.
X *  THICK_LDOT	latex command for generating the dot for making short slanted
X *		lines if line width = \thinlines
X *  THIN_LDOT	...  if line width = \thicklines
X */
X#define THICKDOT	"\\SetFigFont{10}{12}{rm}."
X#define THINDOT		"\\SetFigFont{7}{8.4}{rm}."
Xdouble	THIN_XOFF =	(0.1/72.0);
Xdouble	THIN_YOFF =	(0.7/72.0);
Xdouble	THICK_XOFF =	(0.4/72.0);
Xdouble	THICK_YOFF =	(0.6/72.0);
X#define THICK_LDOT	"\\SetFigFont{7}{8.4}{rm}."
X#define THIN_LDOT	"\\SetFigFont{5}{6}{rm}."
Xdouble	THIN_LXOFF =	(0.1/72.0);
Xdouble	THIN_LYOFF =	(0.7/72.0);
Xdouble	THICK_LXOFF =	(0.4/72.0);
Xdouble	THICK_LYOFF =	(0.6/72.0);
X#define MIN_LEN		(13.0/72.0)	/* 13  points */
X
X/*
X *  other constants and macros
X */
X#define TOP		840
X#define THINLINES	1
X#define THICKLINES	2
X
X#define MAXCIRCLEDIA	80
X#define MAXCIRCLERAD	((MAXCIRCLEDIA-0.5)/(2*72.27))
X
X#define	SWAP(x,y)	{tmp=x; x=y; y=tmp;}
X#define TRANS(x,y)		(*translate_coordinates)(&x,&y)
X#define TRANS2(x1,y1,x2,y2)	(*translate_coordinates)(&x1,&y1); \
X				(*translate_coordinates)(&x2,&y2)
X#define TRANSD(x,y)		(*translate_coordinates_d)(&x,&y)
X#ifndef MIN
X#define	MIN(x,y)	(((x) <= (y))? (x): (y))
X#endif
X#ifndef MAX
X#define	MAX(x,y)	(((x) >= (y))? (x): (y))
X#endif
X#define	ABS(x)		(((x) >= 0)? (x): -(x))
X#define round4(x)	((round(10000.0*(x))/10000.0))
X#define round6(x)	((round(1000000.0*(x))/1000000.0))
X
Xchar		thindot [] = THINDOT;
Xchar		thickdot[] = THICKDOT;
Xchar		thin_ldot [] = THIN_LDOT;
Xchar		thick_ldot[] = THICK_LDOT;
X
Xstatic	int	coord_system;
Xint		verbose = 0;
Xdouble		dash_mag = 1.0;
Xint		thick_width = 2;
Xdouble		tolerance = 2.0;
Xdouble		arc_tolerance = 1.0;
Xint		(*translate_coordinates)() = NULL;
Xint		(*translate_coordinates_d)() = NULL;
Xdouble		unitlength;
Xstatic int	cur_thickness = -1;
Xdouble		ldot_diameter = 1.0/72.0;
Xchar		*dot_cmd = thindot;
Xchar		*ldot_cmd = thin_ldot;
Xdouble		dot_xoffset;
Xdouble		dot_yoffset;
Xdouble		ldot_xoffset;
Xdouble		ldot_yoffset;
X
Xextern char *ISOtoTeX[];
X
Xstatic translate1(xp, yp)
Xint	*xp, *yp;
X{
X	*xp = *xp + 1;
X	*yp = *yp + 1;
X	}
X
Xstatic translate2(xp, yp)
Xint	*xp, *yp;
X{
X	*xp = *xp + 1;
X	*yp = TOP - *yp -1;
X	}
X
Xstatic translate1_d(xp, yp)
Xdouble	*xp, *yp;
X{
X	*xp = *xp + 1.0;
X	*yp = *yp + 1.0;
X	}
X
Xstatic translate2_d(xp, yp)
Xdouble	*xp, *yp;
X{
X	*xp = *xp + 1.0;
X	*yp = (double)TOP - *yp -1.0;
X	}
X
Xvoid genlatex_option(opt, optarg)
Xchar opt, *optarg;
X{
X    int i;
X
X    switch (opt) {
X	case 'a':
X	    fprintf(stderr, "warning: latex option -a obsolete");
X	    break;
X
X	case 'd':
X	    dash_mag = atof(optarg);	/* set dash magnification */
X	    break;
X
X
X	case 'f':		/* set default text font */
X	    for ( i = 1; i <= MAX_FONT; i++ )
X		if ( !strcmp(optarg, texfontnames[i]) ) break;
X
X	    if ( i > MAX_FONT)
X		fprintf(stderr,
X			"warning: non-standard font name %s\n", optarg);
X		
X	    texfontnames[0] = texfontnames[1] = optarg;
X	    break;
X
X	case 'l':		/* set thin/thick line threshold */
X	    thick_width = atoi(optarg);
X	    break;
X
X	case 's':
X	    if (font_size <= 0 || font_size > MAXFONTSIZE) {
X		fprintf(stderr,
X			"warning: font size %d out of bounds\n", font_size);
X	    }
X	    break;
X
X	case 'v':
X	    verbose = 1;		/* verbose mode */
X	    break;
X
X	case 'm':
X	case 'L':
X	    break;
X
X	default:
X	    put_msg(Err_badarg, opt, "latex");
X	    exit(1);
X	    break;
X	}
X}
X
Xvoid genlatex_start(objects)
XF_compound	*objects;
X{
X	int tmp;
X
X	texfontsizes[0] = texfontsizes[1] = TEXFONTSIZE(font_size);
X
X	coord_system = objects->nwcorner.y;
X 	unitlength = mag/objects->nwcorner.x;
X
X	switch (coord_system) {
X	    case 1:
X		translate_coordinates = translate1;
X		translate_coordinates_d = translate1_d;
X		break;
X	    case 2:
X		translate_coordinates = translate2;
X		translate_coordinates_d = translate2_d;
X		break;
X	    default:
X		fprintf(stderr, "Wrong coordinate system; cannot continue\n");
X		return;
X	    }
X
X	TRANS2(llx, lly, urx, ury);
X	if (llx > urx) SWAP(llx, urx)
X	if (lly > ury) SWAP(lly, ury)
X
X	/* LaTeX start */
X	fprintf(tfp, "\\setlength{\\unitlength}{%.6fin}%%\n",
X						round6(unitlength));
X	/* define the SetFigFont macro */
X	define_setfigfont(tfp);
X	fprintf(tfp, "\\begin{picture}(%d,%d)(%d,%d)\n",
X	 				 urx-llx, ury-lly, llx, lly);
X}
X
Xvoid genlatex_end()
X{
X	/* LaTeX ending */
X	fprintf(tfp, "\\end{picture}\n");
X}
X
Xstatic set_linewidth(w)
Xint	w;
X{
X	int		latex_w;
X
X	if (w == 0) return;
X	/* latex only knows thin lines or thick lines */
X	latex_w = (w >= thick_width)? THICKLINES: THINLINES;
X	if (latex_w != cur_thickness) {
X	    cur_thickness = latex_w;
X	    if (cur_thickness == THICKLINES) {
X		fprintf(tfp, "\\thicklines\n");
X		dot_cmd = thickdot;
X		dot_xoffset = round4(THICK_XOFF/unitlength);
X		dot_yoffset = round4(THICK_YOFF/unitlength);
X		ldot_cmd = thick_ldot;
X		ldot_xoffset = round4(THICK_LXOFF/unitlength);
X		ldot_yoffset = round4(THICK_LYOFF/unitlength);
X		}
X	    else {
X		fprintf(tfp, "\\thinlines\n");
X		dot_cmd = thin_ldot;
X		dot_xoffset = round4(THIN_XOFF/unitlength);
X		dot_yoffset = round4(THIN_YOFF/unitlength);
X		ldot_cmd = thin_ldot;
X		ldot_xoffset = round4(THIN_LXOFF/unitlength);
X		ldot_yoffset = round4(THIN_LYOFF/unitlength);
X		}
X	    }
X	}
X
Xvoid genlatex_line(l)
XF_line	*l;
X{
X	F_point		*p, *q;
X	int		x, y, llx, lly, urx, ury, arrow;
X
X	if (verbose) fprintf(tfp, "%%\n%% Fig POLYLINE object\n%%\n");
X
X	set_linewidth(l->thickness);
X	set_color(l->color);
X
X	p = l->points;
X	q = p->next;
X
X	if (q == NULL) { /* A single point line */
X	    x = p->x; y = p->y;
X	    TRANS(x, y);
X	    fprintf(tfp, "\\put(%3d,%3d){\\makebox(%.4f,%.4f){%s}}\n",
X	      x, y, dot_xoffset, dot_yoffset, dot_cmd);
X	    return;
X	    }
X
X	if (l->type == T_ARC_BOX) { /* A box with rounded corners */
X	  fprintf(stderr, "Arc box not implemented; substituting box.\n");
X	  l->type = T_BOX;
X	}
X
X	if (l->type == T_BOX) { /* A box */
X	    x = p->x; y = p->y;
X	    TRANS(x, y);
X	    llx = urx = x;
X	    lly = ury = y;
X	    while (q != NULL) {
X		x = q->x; y = q->y;
X		TRANS(x, y);
X		if (x < llx) llx = x;
X		if (y < lly) lly = y;
X		if (x > urx) urx = x;
X		if (y > ury) ury = y;
X		q = q->next;
X		}
X	    put_box (llx, lly, urx, ury, l->style, l->style_val);
X	    return;
X	    }
X
X	while (q != NULL) {
X	    arrow = 0;
X	    if (l->for_arrow  &&  q->next == NULL)
X		arrow = 1;
X	    if (l->back_arrow  &&  p == l->points)
X		arrow = (arrow)? 2: -1;
X	    single_line(p->x, p->y, q->x, q->y, arrow, l->style, l->style_val);
X	    p = q;
X	    q = q->next;
X	    }
X
X	if (l->area_fill && (int)l->area_fill != DEFAULT)
X		fprintf(stderr, "Line area fill not implemented\n");
X	reset_color(l->color);
X	}
X
Xstatic single_line (x1, y1, x2, y2, arrow, style, val)
Xint	x1, y1, x2, y2, arrow, style;
Xdouble	val;
X{
X	int    dx, dy, sx, sy;
X	double l, m, deviation;
X
X	TRANS2(x1, y1, x2, y2);
X	dx = x2-x1;
X	dy = y2-y1;
X	/*** compute direction vector ***/
X	get_slope(dx, dy, &sx, &sy, arrow);
X	/*** compute line length in x-direction ***/
X	if (sx == 0) {
X	    l = (double)abs(dy);
X	} else {
X	    m = (double)abs(sy) / (double)abs(sx);
X	    l = ((double)abs(dx) + m*(double)abs(dy)) / (1.0 + m*m);
X	    deviation = fabs(l-abs(dx)) + fabs(m*l-abs(dy));
X	    if (deviation > tolerance)
X		fprintf(stderr,
X		  "Not a LaTeX slope (%d, %d), deviation %.1f pixels\n",
X		  dx, dy, deviation);
X	}
X	l = round4(l);
X	/*** output letex command ***/
X	switch (style) {
X	    case SOLID_LINE:
X		put_solidline(x1, y1, sx, sy, l, arrow);
X		break;
X	    case DASH_LINE:
X		put_dashline(x1, y1, sx, sy, l, arrow, val);
X		break;
X	    case DOTTED_LINE:
X		put_dotline(x1, y1, sx, sy, l, arrow, val);
X		break;
X	    }
X	}
X
X
X/*
X * draw box
X */
Xstatic put_box (llx, lly, urx, ury, style, val)
Xint	llx, lly, urx, ury, style;
Xdouble	val;
X{
X	int	dlen;
X
X	switch (style) {
X	    case SOLID_LINE:
X		fprintf(tfp, "\\put(%3d,%3d){\\framebox(%d,%d){}}\n",
X		  llx, lly, urx-llx, ury-lly);
X		break;
X	    case DASH_LINE:
X		dlen = round(val*dash_mag);
X		fprintf(tfp, "\\put(%3d,%3d){\\dashbox{%d}(%d,%d){}}\n",
X		  llx, lly, dlen, urx-llx, ury-lly);
X		break;
X	    case DOTTED_LINE:
X		put_dotline (llx, lly, 1, 0, (double)(urx-llx), 0, val);
X		put_dotline (llx, ury, 1, 0, (double)(urx-llx), 0, val);
X		put_dotline (llx, lly, 0, 1, (double)(ury-lly), 0, val);
X		put_dotline (urx, lly, 0, 1, (double)(ury-lly), 0, val);
X		break;
X	    }
X	return;
X	}
X
X/*
X * draw a solid line given latex slope
X */
Xstatic put_solidline (x, y, sx, sy, l, arrow)
Xint	x, y, sx, sy, arrow;
Xdouble	l;
X{
X	double	cosine;		/* cosine of line angle */
X	double	dx, dy;
X	int	x2, y2, n;
X
X	if (sx) {
X	    cosine = (double)abs(sx) / sqrt((double)(sx*sx)+(double)(sy*sy));
X	    x2 = (sx >= 0)? x + round(l): x - round(l);
X	    y2 = y + round( ((sx>=0)? l: -l) * (double)sy / (double)sx);
X	    }
X	else {
X	    cosine = 1.0;
X	    x2 = x;
X	    y2 = (sy >= 0)? y + round(l): y - round(l);
X	    }
X	if (sx == 0  ||  sy == 0  ||  (l/cosine)*unitlength >= MIN_LEN) {
X	    switch (arrow) {
X	    case 0:  /* simple line */
X		fprintf(tfp, "\\put(%3d,%3d){\\line(%2d,%2d)", x, y, sx,sy);
X		break;
X	    case 1:  /* forward arrow */
X		fprintf(tfp, "\\put(%3d,%3d){\\vector(%2d,%2d)", x, y, sx,sy);
X		break;
X	    case -1: /* backward arrow */
X		fprintf(tfp, "\\put(%3d,%3d){\\vector(%2d,%2d)", x2, y2, -sx,-sy);
X		break;
X	    case 2:  /* double arrow */
X		fprintf(tfp, "\\put(%3d,%3d){\\vector(%2d,%2d){  0}}\n", x,y,-sx,-sy);
X		fprintf(tfp, "\\put(%3d,%3d){\\vector(%2d,%2d)", x, y, sx, sy);
X		break;
X		}
X	    if (l == floor(l))
X		fprintf(tfp, "{%3.0f}}\n", l);
X	    else
X		fprintf(tfp, "{%7.3f}}\n", l);
X	    }
X	else {
X	    n = 2 * (l/cosine) / (ldot_diameter/unitlength);
X	    fprintf(stderr, "Line too short; will do %d dots\n", n);
X	    dx = l / (double)n;
X	    if (sx < 0) dx = -dx;
X	    dy = dx * (double)sy / (double)sx;
X	    fprintf(tfp, 
X	      "\\multiput(%3d,%3d)(%.5f,%.5f){%d}{\\makebox(%.4f,%.4f){%s}}\n",
X	      x, y, dx, dy, n+1, ldot_xoffset, ldot_yoffset, ldot_cmd);
X	    if (arrow == 1  ||  arrow == 2)  /* forward arrow */
X		fprintf(tfp, "\\put(%3d,%3d){\\vector(%2d,%2d){0}}\n", x2,y2, sx,sy);
X	    if (arrow == -1  ||  arrow == 2) /* backward arrow */
X		fprintf(tfp, "\\put(%3d,%3d){\\vector(%2d,%2d){0}}\n", x,y, -sx,-sy);
X	    }
X	}
X
X/*
X * draw a dashed line given latex slope
X */
Xstatic put_dashline (x, y, sx, sy, l, arrow, val)
Xint	x, y, sx, sy, arrow;
Xdouble	l;
Xdouble	val;
X{
X	double	cosine;		/* cosine of line angle */
X	double	nd;		/* number of dashes and gaps fitting on line */
X	int	n;		/* nd rounded to the nearest odd integer */
X	double	dl;		/* actual x-length of each dash */
X	double	dg;		/* actual x-length of each gap */
X	double	dx, dy;		/* step between dashes */
X	int	x2, y2;
X
X	if (sx) {
X	    cosine = (double)abs(sx) / sqrt((double)(sx*sx)+(double)(sy*sy));
X	    x2 = (sx >= 0)? x + round(l): x - round(l);
X	    y2 = y + round( ((sx>=0)? l: -l) * (double)sy / (double)sx );
X	    }
X	else {
X	    cosine = 1.0;
X	    x2 = x;
X	    y2 = (sy >= 0)? y + round(l): y - round(l);
X	    }
X	/*** compute number of dashes, length of dashes and gaps ***/
X	nd = l / (val*dash_mag*cosine);
X	n = (int) (rint((nd + 1.0)/2.0)*2 - 1);
X	dl = l / (double)n;
X	if (sx  &&  sy  &&  (dl/cosine)*unitlength < MIN_LEN) {
X	    fprintf(stderr, "Dash too small; using larger dash\n");
X	    dl = MIN_LEN/unitlength * cosine;
X	    nd = l / dl;
X	    n = (int) (rint((nd + 1.0)/2.0)*2 - 1);
X	    }
X	if (2*dl >= l  ||  (sx  &&  sy  &&  (l/cosine)*unitlength < MIN_LEN)) {
X	    fprintf(stderr, "Dashed line too short; drawing solid line\n");
X	    put_solidline (x, y, sx, sy, l, arrow);
X	    return;
X	    }
X	dg = (l - (n/2+1)*dl) / (double)(n/2);
X	if (sx) {
X	    dx = dl+dg;
X	    if (sx < 0) dx = -dx;
X	    dy = dx * (double)sy / (double)sx;
X	    }
X	else {
X	    dx = 0.0;
X	    dy = dl+dg;
X	    if (sy < 0) dy = -dy;
X	    }
X	/*** draw dashed line ***/
X	fprintf(tfp, "\\multiput(%3d,%3d)(%.5f,%.5f){%d}{\\line(%2d,%2d){%7.3f}}\n",
X	    x, y, dx, dy, n/2+1, sx, sy, dl);
X	/*** draw arrow heads ***/
X	if (arrow == 1  ||  arrow == 2)
X	    fprintf(tfp, "\\put(%3d,%3d){\\vector(%2d,%2d){0}}\n", x2, y2, sx, sy);
X	if (arrow == -1  ||  arrow == 2)
X	    fprintf(tfp, "\\put(%3d,%3d){\\vector(%2d,%2d){0}}\n", x, y, -sx, -sy);
X	}
X
X/*
X * draw a dotted line given latex slope
X */
Xstatic put_dotline (x, y, sx, sy, l, arrow, val)
Xint	x, y, sx, sy, arrow;
Xdouble	l;
Xdouble	val;
X{
X	double	cosine;		/* cosine of line angle */
X	double	nd;		/* number of dots fitting on line */
X	int	n;		/* nd rounded to the nearest integer */
X	double	dx, dy;		/* step between dashes */
X	int	x2, y2;
X
X
X	cosine = (sx)? (double)abs(sx) / sqrt((double)(sx*sx)+(double)(sy*sy)): 1.0;
X	/*** compute step width ***/
X	nd = l / (3*val*cosine);
X	n = rint(nd);
X	dx = l / (double)n;
X	if (sx) {
X	    dx = l / (double)n;
X	    if (sx < 0) dx = -dx;
X	    dy = dx * (double)sy / (double)sx;
X	    }
X	else {
X	    dx = 0.0;
X	    dy = l / (double)n;
X	    if (sy < 0) dy = -dy;
X	    }
X	/*** draw arrow heads ***/
X	if (arrow == 1  ||  arrow == 2) {
X	    /* forward arrow */
X	    if (sx) {
X		x2 = (sx >= 0)? x + round(l): x - round(l);
X		y2 = y + round( ((sx>=0)? l: -l) * (double)sy / (double)sx );
X		}
X	    else {
X		x2 = x;
X		y2 = (sy >= 0)? y + round(l): y - round(l);
X		}
X	    fprintf(tfp, "\\put(%3d,%3d){\\vector(%2d,%2d){0}}\n", x2, y2, sx, sy);
X	    n--;
X	    }
X	if (arrow == -1  ||  arrow == 2) {
X	    fprintf(tfp, "\\put(%3d,%3d){\\vector(%2d,%2d){0}}\n", x, y, -sx, -sy);
X	    x = round(x + dx);
X	    y = round(y + dy);
X	    n--;
X	    }
X	/*** draw dotted line ***/
X	fprintf(tfp, "\\multiput(%3d,%3d)(%.5f,%.5f){%d}{\\makebox(%.4f,%.4f){%s}}\n",
X	    x, y, dx, dy, n+1, dot_xoffset, dot_yoffset, dot_cmd);
X	}
X
Xvoid genlatex_spline(s)
XF_spline	*s;
X{
X	fprintf(stderr, "Can't generate spline; omitting object\n");
X	}
X
Xvoid genlatex_ellipse(e)
XF_ellipse	*e;
X{
X	int  x, y, d, dx, dy;
X
X	if (verbose) fprintf(tfp, "%%\n%% Fig ELLIPSE\n%%\n");
X
X	set_linewidth(e->thickness);
X	switch (e->style) {
X	    case SOLID_LINE:
X		break;
X	    case DASH_LINE:
X		fprintf(stderr, "Dashed circles and elipses not supported\n");
X		break;
X	    case DOTTED_LINE:
X		fprintf(stderr, "Dotted circles and elipses not supported\n");
X		break;
X	    }
X
X	x = e->center.x;
X	y = e->center.y;
X	TRANS(x, y);
X	if ((e->type == T_CIRCLE_BY_RAD || e->type == T_CIRCLE_BY_DIA)
X			&& e->radiuses.x*unitlength <= MAXCIRCLERAD) {
X
X	    d = 2 * e->radiuses.x;
X	    if (e->area_fill == BLACK_FILL)
X	    	fprintf(tfp, "\\put(%3d,%3d){\\circle*{%d}}\n", x, y, d);
X	    else {
X	      	fprintf(tfp, "\\put(%3d,%3d){\\circle{%d}}\n", x, y, d);
X		if (e->area_fill && (int)e->area_fill != DEFAULT)
X			fprintf(stderr, "Circle area fill not implemented\n");
X	    }
X
X	} else {	    
X	    dx = 2 * e->radiuses.x;
X	    dy = 2 * e->radiuses.y;
X	    fprintf(tfp, "\\put(%3d,%3d){\\oval(%d,%d)}\n", x, y, dx, dy);
X	    if (e->area_fill && (int)e->area_fill != DEFAULT)
X		fprintf(stderr, "Ellipse area fill not implemented\n");
X	}
X      }
X
Xvoid genlatex_text(t)
XF_text	*t;
X{
X	int   	x, y;
X	char	*tpos;
X	unsigned char	*cp;
X
X	if (verbose) fprintf(tfp, "%%\n%% Fig TEXT object\n%%\n");
X
X	x = t->base_x;
X	y = t->base_y;
X	TRANS(x, y);
X
X	switch (t->type) {
X
X	    case T_LEFT_JUSTIFIED:
X	    case DEFAULT:
X	    	tpos = "[lb]";
X		break;
X
X	    case T_CENTER_JUSTIFIED:
X	    	tpos = "[b]";
X		break;
X
X	    case T_RIGHT_JUSTIFIED:
X	    	tpos = "[rb]";
X		break;
X
X	    default:
X		fprintf(stderr, "Text incorrectly positioned\n");
X	    }
X
X	/* smash is used to position text at baseline */
X	unpsfont(t);
X	fprintf(tfp, 
X	  "\\put(%3d,%3d){\\makebox(0,0)%s{\\smash{",
X	  x, y, tpos);
X
X#ifdef DVIPS
X        if(t->angle && t->type == T_LEFT_JUSTIFIED)
X          fprintf(tfp, "\\special{ps:gsave currentpoint currentpoint translate\n%.1f rotate neg exch neg exch translate}", -t->angle*180/M_PI);
X#endif
X
X        { int texsize;
X          double baselineskip;
X
X	  texsize = TEXFONTMAG(t);
X	  baselineskip = (texsize * 1.2);
X
X 	  fprintf(tfp, "\\SetFigFont{%d}{%.1f}{%s}",
X		texsize, baselineskip, TEXFONT(t->font));
X	}
X
X	set_color(t->color);
X
X	if (!special_text(t))
X
X		/* this loop escapes characters "$&%#_{}" */
X		/* and deleted characters "~^\" */
X		for(cp = (unsigned char*)t->cstring; *cp; cp++) {
X	      	    if (strchr("$&%#_{}", *cp)) (void)fputc('\\', tfp);
X	      	    if (strchr("~^\\", *cp))
X			fprintf(stderr,
X				"Bad character in text object '%c'\n" ,*cp);
X		    else
X			(void)fputc(*cp, tfp);
X	      	}
X	else 
X		for(cp = (unsigned char*)t->cstring; *cp; cp++) {
X		    if (*cp >= 0xa0)
X			 fprintf(tfp, "%s", ISOtoTeX[(int)*cp-0xa0]);
X		else
X		    fputc(*cp, tfp);
X		}
X
X	reset_color(t->color);
X
X#ifdef DVIPS
X        if(t->angle)
X	{
X	  if (t->type == T_LEFT_JUSTIFIED)
X             fprintf(tfp, "\\special{ps:currentpoint grestore moveto}");
X	  else
X	     fprintf(stderr, "Rotated Text only for left justified text\n");
X	}
X#endif
X 	fprintf(tfp, "}}}\n");
X	}
X
Xvoid genlatex_arc(a)
XF_arc	*a;
X/*
X *  Approximates an arc by a sequence of quarter ovals.
X *
X *  Example:
X *
X *	Arc with center at (0,0) and radius 10 from +45 degree to +225 degree
X *	(arc from p1 = (7.07, 7.07) to p2 = (-7.07, -7.07) counterclockwise).
X *	This arc is approximated by three quarter ovals, one for each quadrant
X *	through which the arc goes:
X *
X *	 1. quarter oval from p1 to the intersection of arc and y-axis,
X *	    i.e., from (7.07, 7.07) to (0, 10) in quadrant 0
X *
X *		\put(0, 7.07){\oval(14.14, 5.86)[tr]}
X *
X *	 2. quarter oval from intersection arc/y-axis to intersection arc/x-axis
X *	    i.e., from (0, 10) to (-10, 0) in quadrant 1
X *
X *		\put(0, 0){\oval(20,20)[tl]}
X *
X *	 3. quarter oval from p1 to the intersection of arc and y-axis,
X *	    i.e., from (-10, 0) to (-7.07, -7.07) in quadrant 2
X *
X *		\put(-7.07, 0){\oval(5.86, 14.14)[bl]}
X */
X{
X	F_pos		p1, p2, pq[4];
X	double		cx, cy;
X	double		v1x, v1y, v2x, v2y;
X	double		r, angle1, angle2;
X	int		q1, q2;
X	int		p1_arrow, p2_arrow;
X	static char	*ad1[4] = { " 0,-1", " 1, 0", " 0, 1", "-1, 0" };
X	static char	*ad2[4] = { "-1, 0", " 0,-1", " 1, 0", " 0, 1" };
X
X	set_linewidth(a->thickness);
X	set_color(a->color);
X	switch (a->style) {
X	    case SOLID_LINE:
X		break;
X	    case DASH_LINE:
X		fprintf(stderr, "Dashed arcs not supported\n");
X		break;
X	    case DOTTED_LINE:
X		fprintf(stderr, "Dotted arcs not supported\n");
X		break;
X	    }
X	if (a->direction == 1) {
X	    p1 = a->point[0];
X	    p2 = a->point[2];
X	    p1_arrow = (a->back_arrow != NULL);
X	    p2_arrow = (a->for_arrow != NULL);
X	    }
X	else {
X	    p1 = a->point[2];
X	    p2 = a->point[0];
X	    p1_arrow = (a->for_arrow != NULL);
X	    p2_arrow = (a->back_arrow != NULL);
X	    }
X	cx = a->center.x;
X	cy = a->center.y;
X	TRANS2(p1.x, p1.y, p2.x, p2.y);
X	TRANSD(cx, cy);
X	/*** compute vectors and angles from arc center to p1, p2 ***/
X	v1x = (double)p1.x - cx;
X	v1y = (double)p1.y - cy;
X	v2x = (double)p2.x - cx;
X	v2y = (double)p2.y - cy;
X	angle1 = atan2(v1y, v1x) * rad2deg;
X	angle2 = atan2(v2y, v2x) * rad2deg;
X	if (angle1 < 0.0)
X	    angle1 += 360.0; 
X	if (angle2 < 0.0)
X	    angle2 += 360.0; 
X	/* compute arc radius */
X	r = sqrt(v1x*v1x+v1y*v1y);
X	/*** compute intersection of arc with x and y axis (origin at cx, cy) */
X	pq[0].x = round(cx);
X	pq[0].y = round(cy + r);
X	pq[1].x = round(cx - r);
X	pq[1].y = round(cy);
X	pq[2].x = round(cx);
X	pq[2].y = round(cy - r);
X	pq[3].x = round(cx + r);
X	pq[3].y = round(cy);
X	/*** compute in which quadrants p1 and p2 are located ***/
X	q1 = (int)(angle1/90.0);
X	q2 = (int)(angle2/90.0);
X	if (fabs(angle1 - 90.0*q1) > arc_tolerance 
X	 || fabs(angle2 - 90.0*q2) > arc_tolerance)
X	    fprintf(stderr, "Approximating arc by ovals\n");
X	/*** Draw arc ***/
X	if (p1_arrow)
X	    fprintf(tfp, "\\put(%3d,%3d){\\vector(%s){0}}\n", p1.x, p1.y, ad1[q1]);
X	while (q1 != q2) {
X	    put_quarter(p1, pq[q1], q1);
X	    p1 = pq[q1];
X	    q1 = (q1 + 1) % 4;
X	    }
X	put_quarter(p1, p2, q1);
X	if (p2_arrow)
X	    fprintf(tfp, "\\put(%3d,%3d){\\vector(%s){0}}\n", p2.x, p2.y, ad2[q2]);
X
X	if (a->area_fill && (int)a->area_fill != DEFAULT)
X		fprintf(stderr, "Arc area fill not implemented\n");
X	reset_color(a->color);
X	}
X
Xstatic put_quarter(p1, p2, q)
XF_pos	p1, p2;
Xint	q;
X/*
X *  Draw quarter oval from p1 to p2 in quadrant q
X */
X{
X	char	*opt;
X	int	px, py, dx, dy;
X
X	dx = 2*ABS(p1.x - p2.x);
X	dy = 2*ABS(p1.y - p2.y);
X	if (dx == 0  &&  dy == 0)
X	    return;
X	switch (q) {
X	    case 0:
X		px = MIN(p1.x, p2.x);
X		py = MIN(p1.y, p2.y);
X		opt = "tr";
X		break;
X	    case 1:
X		px = MAX(p1.x, p2.x);
X		py = MIN(p1.y, p2.y);
X		opt = "tl";
X		break;
X	    case 2:
X		px = MAX(p1.x, p2.x);
X		py = MAX(p1.y, p2.y);
X		opt = "bl";
X		break;
X	    case 3:
X		px = MIN(p1.x, p2.x);
X		py = MAX(p1.y, p2.y);
X		opt = "br";
X		break;
X	    }
X	fprintf(tfp, "\\put(%3d,%3d){\\oval(%3d,%3d)[%s]}\n", px, py, dx, dy, opt);
X	}
X
X#define  MAXCOLORS 8
X
Xset_color(col)
Xint col;
X{
X   static char *colors[] = {
X   "0 0 0",    /* black */
X   "0 0 1",    /* blue */
X   "0 1 0",    /* green */
X   "0 1 1",    /* cyan */
X   "1 0 0",    /* red */
X   "1 0 1",    /* magenta */
X   "1 1 0",    /* yellow */
X   "1 1 1",    /* white */
X   };
X   
X#ifdef DVIPS
X   if (col != -1 && col < MAXCOLORS)
X      fprintf(tfp, "\\special{ps: gsave %s setrgbcolor}", colors[col]);
X#endif
X   return;
X}
X
Xreset_color(col)
Xint col;
X{
X#ifdef DVIPS
X   if (col != -1 && col < MAXCOLORS)
X      fprintf(tfp, "\\special{ps: grestore}");
X#endif
X   return;
X}
X
X
Xstruct driver dev_latex = {
X     	genlatex_option,
X	genlatex_start,
X	genlatex_arc,
X	genlatex_ellipse,
X	genlatex_line,
X	genlatex_spline,
X	genlatex_text,
X	genlatex_end,
X	EXCLUDE_TEXT
X};
END_OF_FILE
if test 23356 -ne `wc -c <'fig2dev/dev/genlatex.c'`; then
    echo shar: \"'fig2dev/dev/genlatex.c'\" unpacked with wrong size!
fi
# end of 'fig2dev/dev/genlatex.c'
fi
if test -f 'fig2dev/dev/gentpic.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fig2dev/dev/gentpic.c'\"
else
echo shar: Extracting \"'fig2dev/dev/gentpic.c'\" \(22577 characters\)
sed "s/^X//" >'fig2dev/dev/gentpic.c' <<'END_OF_FILE'
X/*
X * TransFig: Facility for Translating Fig code
X * Copyright (c) 1985 Supoj Sutantavibul
X * Copyright (c) 1991 Micah Beck
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation. The authors make no representations about the suitability 
X * of this software for any purpose.  It is provided "as is" without express 
X * or implied warranty.
X *
X * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
X * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
X * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X *
X */
X
X/* 
X *	gentpic : TPIC driver for fig2dev
X *
X *	Author: Conrad Kwok, UC Davis, 12/88
X *      Modified: Richard Auletta, George Mason Univ., 6/21/89
X *		Added code comments are marked with "rja".
X *      	Added: Support for native pic arrowheads.
X *      	Added: Support for arrowheads at both ends of lines, arc, splines.
X *	Modified: Modified from pic to tpic. Baron Grey, UCLA. 10/2/90.
X *
X *		This driver supports TeX's virtual font mechanism. Any Fig
X *		font whose ordinal number is greater than 6 is treated as
X *		a TeX virtual PostScript font. Virtual PostScript font
X *		names are defined in tpicfonts.h (you should define
X *		corresponding names in Fig in file change.c). Customize to
X *		suit your virtual font availability or your name preferences.
X *
X *		There are no restrictions on font sizes in this driver, but
X *		keep in mind that TeX only supports fonts up to 2048 points!
X *		Since PostScript fonts are scaleable, virtual PS fonts can have
X *		any point size within the limits imposed by TeX or by your
X *		PostScript interpreter. If you are using
X *		standard predefined LaTeX fonts (assumed to be the first
X *		6 positions in Fig's ordinal font numbering scheme), font
X *		sizes are mapped into the nearest valid normally-available
X *		LaTeX font sizes -- look at tpicfonts.h to see how this is
X *		done; you can modify it for fonts at your site.
X *
X *		Additional features of this driver are:
X *		1) Support for all Fig features except text at nonzero
X *		   angles.  (In fact, any limitations of this driver are
X *		   actually tpic limitations.)
X *		2) Boxes with rounded corners are supported in two ways.
X *		   If (when) tpic is extended to use the "radius" attribute
X *		   with a "box" specification, the driver will generate the
X *		   appropriate box specification. Otherwise, it creates
X *		   rounded-corner boxes from line and arc segments using
X *		   existing tpic primitives. In the former case, rounded-
X *		   corner boxes can be shaded; in the latter, they can't.
X *		   Define TPIC_ARC_BOX for the first case (the default);
X *		   undefine it otherwise.
X *		3) Supports Fig's ability to texture (shade) objects.
X *		   Bitmapped PostScript texture patterns are supported;
X *		   they are defined in "tpicfonts.h". The tpic ".tx"
X *		   primitive is used for this. Your dvi-to-PostScript
X *		   driver must be adapted to support them.
X *		4) If an object's line "thickness" is 0, it is given tpic's
X *		   `invis' attribute. That is, tpic will treat it as an
X *		   invisible object in the normal tpic sense.
X *		5) This driver supports tpic 2.0. It will work with tpic 1.0,
X *		   but some object attributes will not be available.
X *		6) The default line thickness is 8 milli inches (in tpic
X *		   units). This corresponds to 1 pixel width in Fig. The
X *		   formula is: line_thickness = Fig_line_thickness *
X *		   default_tpic_line_thickness.
X *		7) The default font size is (assumed to be) 10 points!
X */
X
X#include <stdio.h>
X#include <math.h>
X#include "object.h"
X#include "fig2dev.h"
X#include "tpicfonts.h"
X
X/*
X * Define TPIC_ARC_BOX if your tpic supports rounded-corner boxes
X * via a "radius" attribute of a box specification.
X */
X#define TPIC_ARC_BOX
X
X#define			TOP	10.5	/* top of page is 10.5 inch */
Xstatic double		ppi;
Xstatic int		CONV = 0;
Xstatic int		line_width = 8;	/* milli-inches */
Xstatic int		vfont = 0; /* true if using a virtual TeX font */
X
Xvoid gentpic_ctl_spline(), gentpic_itp_spline();
Xvoid gentpic_open_spline(), gentpic_closed_spline();
Xvoid gentpic_spline(), gentpic_ellipse(), gentpic_text();
Xvoid gentpic_arc(), gentpic_line(), newline();
X
Xvoid gentpic_option(opt, optarg)
Xchar opt, *optarg;
X{
X	switch (opt) {
X
X	case 'f':		/* set default text font */
X	        {   int i;
X
X		    for ( i = 1; i <= MAX_TPICFONT; i++ )
X			if ( !strcmp(optarg, texfontnames[i]) ) break;
X
X		    if ( i > MAX_FONT)
X			    vfont = 1; /* assume a virtual font */
X		}
X		
X		texfontnames[0] = optarg;
X		break;
X
X	case 's':
X	case 'm':
X	case 'L':
X		break;
X
X 	default:
X		put_msg(Err_badarg, opt, "tpic");
X		exit(1);
X	}
X}
X
Xstatic double convy(a)
Xdouble	a;
X{
X	return((double)(CONV ? TOP-a : a));
X}
X
Xvoid gentpic_start(objects)
XF_compound	*objects;
X{
X	int		coord_system;
X
X	ppi = objects->nwcorner.x/mag;
X	coord_system = objects->nwcorner.y;
X	if (coord_system == 2) CONV = 1;
X
X	fprintf(tfp, ".PS\n");	/* PIC preamble */
X
X}
X
Xvoid gentpic_end()
X{
X  	fprintf(tfp, ".PE\n");				/* PIC ending */
X}
X
X/*
X * tpic's line thickness is given in milli-inches with a default of 8
X * milli-inches. We simply multiply this default with the Fig pixel width.
X */
Xstatic set_linewidth(w)
Xint	w;
X{
X	static int	cur_thickness = -1;
X
X	if (w == 0) return;
X	if (w != cur_thickness) {
X	    cur_thickness = w;
X	    fprintf(tfp, ".ps %d\n", cur_thickness * line_width);
X	    }
X	}
X
Xstatic set_style(s, v)
Xint	s;
Xfloat	v;
X{
X	static float	style_val = -1;
X
X	if (s == DASH_LINE || s == DOTTED_LINE) {
X	    if (v == style_val || v == 0.0) return;
X	    style_val = v;
X	    fprintf(tfp, "dashwid = %.3fi\n", style_val/ppi);
X	    }
X	}
X
Xstatic set_baseline(b)
Xint	b;
X{
X	static int	cur_baseline = -1;
X
X	if (b != cur_baseline) {
X		fprintf(tfp, ".baseline %d\n", b);
X		cur_baseline = b;
X	}
X}
X
Xstatic set_texture(cur_texture)
Xint	cur_texture;
X{
X	/*
X	 * This applies only to bitmapped texture patterns defined in
X	 * tpicfonts.h. See set_fill() below for normal shading.
X	 */
X	if (cur_texture <= BLACK_FILL || cur_texture > MAXPATTERNS + BLACK_FILL)
X		return;
X	fprintf(tfp, ".tx 16 %s\n",
X		texture_patterns[cur_texture - BLACK_FILL - 1]);
X}
X
X/*
X * Set the shade for filling an object. Your dvi-to-postscript driver must
X * distinguish between a "shaded" attribute with or without a parameter.
X * If there is no parameter, then it should do a bitmap texture fill;
X * otherwise, it should do a normal gray-scale fill. Note that the gray-
X * scale fill parameter is wired for fig2.X (the constant 0.05).
X */
Xstatic set_fill(cur_fill)
Xint	cur_fill;
X{
X	if(cur_fill < WHITE_FILL ||
X	   cur_fill > BLACK_FILL + MAXPATTERNS)
X		return;
X	switch(cur_fill) {
X	case BLACK_FILL:
X		fprintf(tfp, " black");
X		break;
X	case WHITE_FILL:
X		fprintf(tfp, " white");
X		break;
X	default:
X		if (cur_fill > BLACK_FILL)
X			fprintf (tfp, " shaded");
X		else
X			fprintf(tfp, " shaded %0.3f", (cur_fill-1)*0.05);
X		break;
X	}
X}
X
X#ifdef TPIC_ARC_BOX
Xvoid gentpic_line(l)
XF_line	*l;
X{
X	F_point		*p, *q;
X	int	llx, lly, urx, ury;
X
X	set_linewidth(l->thickness);
X	set_style(l->style, l->style_val);
X	set_texture(l->area_fill);
X	p = l->points;
X	q = p->next;
X	if (q == NULL) { /* A single point line */
X	    fprintf(tfp, "line from %.3f,%.3f to %.3f,%.3f",
X			p->x/ppi, convy(p->y/ppi), p->x/ppi, convy(p->y/ppi));
X	    newline();
X	    return;
X	    }
X
X	if (l->type == T_BOX || l->type == T_ARC_BOX) {
X		llx = urx = p->x;
X		lly = ury = p->y;
X		while (q != NULL) {
X			p = q;
X			if (p->x < llx) {
X				llx = p->x;
X			} else if (p->x > urx) {
X				urx = p->x;
X			}
X			if (p->y < lly) {
X				lly = p->y;
X			} else if (p->y > ury) {
X				ury = p->y;
X			}
X			q = q->next;
X		}
X		fprintf(tfp, "box height %.3f width %.3f", (ury-lly)/ppi,
X			(urx-llx)/ppi);
X		switch(l->style) {
X		case SOLID_LINE:
X			break;
X		case DASH_LINE:
X			fprintf(tfp, " dashed");
X			break;
X		case DOTTED_LINE:
X			fprintf(tfp, " dotted");
X			break;
X		default:
X			put_msg("Program error! No other line styles allowed.\n");
X			return;
X		}
X		if (l->thickness == 0)
X			fprintf(tfp, " invis");
X		fprintf(tfp, " radius %.3f", l->radius/ppi);
X		set_fill(l->area_fill);
X		fprintf(tfp, " with .nw at %.3f,%.3f", llx/ppi, convy(lly/ppi));
X		newline();
X		return;
X	}
X
X	if (l->style == DASH_LINE && l->style_val > 0.0)
X	    fprintf(tfp, "line dashed");
X	else if (l->style == DOTTED_LINE && l->style_val > 0.0)
X	    fprintf(tfp, "line dotted");
X	else
X	    fprintf(tfp, "line");
X
X	/*rja: Place arrowheads or lack there of on the line*/
X	if ((l->for_arrow) && (l->back_arrow))
X	    fprintf(tfp, " <-> from");
X	else if (l->back_arrow)
X	    fprintf(tfp, " <- from");
X	else if (l->for_arrow)
X	    fprintf(tfp, " -> from");
X        else
X	    fprintf(tfp, " from ");
X
X	fprintf(tfp, " %.3f,%.3f to", p->x/ppi, convy(p->y/ppi));
X	while (q->next != NULL) {
X	    p = q;
X	    q = q->next;
X	    fprintf(tfp, " %.3f,%.3f to", p->x/ppi, convy(p->y/ppi));
X	    }
X	fprintf(tfp, " %.3f,%.3f", q->x/ppi, convy(q->y/ppi));
X	if (l->thickness == 0)
X		fprintf(tfp, " invis");
X	if (l->type == T_POLYGON)
X		set_fill(l->area_fill);
X	newline();
X	}
X
X#else
Xvoid gentpic_line(l)
XF_line	*l;
X{
X	F_point		*p, *q;
X	int		radius = l->radius;
X	char		attr[80];
X
X	attr[0] = '\0';
X	set_linewidth(l->thickness);
X	set_style(l->style, l->style_val);
X	set_texture(l->area_fill);
X	p = l->points;
X	q = p->next;
X	if (q == NULL) { /* A single point line */
X	    fprintf(tfp, "line from %.3f,%.3f to %.3f,%.3f",
X			p->x/ppi, convy(p->y/ppi), p->x/ppi, convy(p->y/ppi));
X	    newline();
X	    return;
X	    }
X
X	if (l->style == DASH_LINE && l->style_val > 0.0)
X		strcat(attr, "dashed");
X	else if (l->style == DOTTED_LINE && l->style_val > 0.0)
X		strcat(attr, "dotted");
X	if (l->thickness == 0)
X		strcat(attr, " invis");
X
X	if (radius > 0) {	/* T_ARC_BOX */
X                register int xmin,xmax,ymin,ymax;
X
X                xmin = xmax = p->x;
X                ymin = ymax = p->y;
X                while (p->next != NULL) { /* find lower left and upper right corners */
X                        p=p->next;
X                        if (xmin > p->x)
X                                xmin = p->x;
X                        else if (xmax < p->x)
X                                xmax = p->x;
X                        if (ymin > p->y)
X                                ymin = p->y;
X                        else if (ymax < p->y)
X                                ymax = p->y;
X		}
X                fprintf(tfp, "line %s from  %.3f,%.3f to %.3f, %.3f\n", attr,
X			(xmin+radius)/ppi, convy(ymin/ppi),
X			(xmax-radius)/ppi, convy(ymin/ppi));
X                fprintf(tfp, "arc cw %s from %.3f, %.3f to %.3f,%.3f radius %.3f\n",
X			attr, (xmax-radius)/ppi, convy(ymin/ppi),
X			(xmax/ppi), convy((ymin+radius)/ppi), radius/ppi);
X                fprintf(tfp, "line %s from  %.3f,%.3f to %.3f, %.3f\n", attr,
X			xmax/ppi, convy((ymin+radius)/ppi),
X			xmax/ppi, convy((ymax-radius)/ppi));
X                fprintf(tfp, "arc cw %s from %.3f, %.3f to %.3f,%.3f radius %.3f\n",
X			attr, xmax/ppi, convy((ymax-radius)/ppi),
X			(xmax-radius)/ppi, convy(ymax/ppi), radius/ppi);
X                fprintf(tfp, "line %s from  %.3f,%.3f to %.3f, %.3f\n", attr,
X			(xmax-radius)/ppi, convy(ymax/ppi),
X			(xmin+radius)/ppi, convy(ymax/ppi));
X                fprintf(tfp, "arc cw %s from %.3f, %.3f to %.3f,%.3f radius %.3f\n",
X			attr, (xmin+radius)/ppi, convy(ymax/ppi),
X			xmin/ppi, convy((ymax-radius)/ppi), radius/ppi);
X                fprintf(tfp, "line %s from  %.3f,%.3f to %.3f, %.3f\n", attr,
X			xmin/ppi, convy((ymax-radius)/ppi),
X			xmin/ppi, convy((ymin+radius)/ppi));
X                fprintf(tfp, "arc cw %s from %.3f, %.3f to %.3f,%.3f radius %.3f",
X			attr, xmin/ppi, convy((ymin+radius)/ppi),
X			(xmin+radius)/ppi, convy(ymin/ppi), radius/ppi);
X	} else {
X		/*rja: Place arrowheads or lack there of on the line*/
X		fprintf(tfp, "line %s", attr);
X		if ((l->for_arrow) && (l->back_arrow))
X			fprintf(tfp, " <-> from");
X		else if (l->back_arrow)
X			fprintf(tfp, " <- from");
X		else if (l->for_arrow)
X			fprintf(tfp, " -> from");
X		else
X			fprintf(tfp, " from ");
X
X		fprintf(tfp, " %.3f,%.3f to", p->x/ppi, convy(p->y/ppi));
X		while (q->next != NULL) {
X			p = q;
X			q = q->next;
X			fprintf(tfp, " %.3f,%.3f to", p->x/ppi, convy(p->y/ppi));
X		}
X		fprintf(tfp, " %.3f,%.3f", q->x/ppi, convy(q->y/ppi));
X	}
X	if (l->type != T_POLYLINE)
X		set_fill(l->area_fill);
X	newline();
X	}
X#endif
X
Xvoid gentpic_spline(s)
XF_spline	*s;
X{
X	if (int_spline(s))
X	    gentpic_itp_spline(s);
X	else
X	    gentpic_ctl_spline(s);
X	}
X
Xvoid gentpic_ctl_spline(s)
XF_spline	*s;
X{
X	if (closed_spline(s))
X	    gentpic_closed_spline(s);
X	else
X	    gentpic_open_spline(s);
X	}
X
Xvoid gentpic_open_spline(s)
XF_spline	*s;
X{
X	double		x1, y1, x2, y2;
X	F_point		*p, *q;
X
X	p = s->points;
X	x1 = p->x/ppi; y1 = convy(p->y/ppi);
X	p = p->next;
X	x2 = p->x/ppi; y2 = convy(p->y/ppi);
X
X	set_style(s->style, s->style_val);
X	set_linewidth(s->thickness);
X
X	if (p->next == NULL) {
X	    fprintf(tfp, "line");
X	    if (s->style == DASH_LINE && s->style_val > 0.0)
X		    fprintf(tfp, " dashed");
X	    else if (s->style == DOTTED_LINE && s->style_val > 0.0)
X		    fprintf(tfp, " dotted");
X
X
X           /*rja: Attach arrowhead as required */
X	    if ((s->for_arrow) && (s->back_arrow))
X	       fprintf(tfp, " <->");
X	    else if (s->back_arrow)
X	       fprintf(tfp, " <-");
X	    else if (s->for_arrow)
X	       fprintf(tfp, " ->");
X
X	    fprintf(tfp, " from %.3f,%.3f to %.3f,%.3f", x1, y1, x2, y2);
X	    newline();
X	    return;
X	    }
X
X	fprintf(tfp, "spline"); 
X	if (s->style == DASH_LINE && s->style_val > 0.0)
X	    fprintf(tfp, " dashed");
X	else if (s->style == DOTTED_LINE && s->style_val > 0.0)
X	    fprintf(tfp, " dotted");
X
X
X           /*rja: Attach arrowhead as required */
X	    if ((s->for_arrow) && (s->back_arrow))
X	       fprintf(tfp, " <->");
X	    else if (s->back_arrow)
X	       fprintf(tfp, " <-");
X	    else if (s->for_arrow)
X	       fprintf(tfp, " ->");
X
X	fprintf(tfp, " from %.3f,%.3f to %.3f,%.3f", x1, y1, x2, y2);
X
X	for (q = p->next; q->next != NULL; p = q, q = q->next)
X	    fprintf(tfp, " to %.3f,%.3f", q->x/ppi, convy(q->y/ppi));
X	fprintf(tfp, " to %.3f,%.3f", (x2=q->x/ppi), (y2=convy(q->y/ppi)));
X
X	newline();
X	}
X
Xvoid gentpic_ellipse(e)
XF_ellipse	*e;
X{
X	set_linewidth(e->thickness);
X	set_texture(e->area_fill);
X	set_style(e->style, e->style_val);
X
X	fprintf(tfp, "ellipse");
X
X	if (e->style == DASH_LINE && e->style_val > 0.0)
X		fprintf(tfp, " dashed");
X	else if (e->style == DOTTED_LINE && e->style_val > 0.0)
X		fprintf(tfp, " dotted");
X
X	fprintf(tfp, " at %.3f,%.3f wid %.3f ht %.3f",
X		e->center.x/ppi, convy(e->center.y/ppi),
X		2 * e->radiuses.x/ppi, 2 * e->radiuses.y/ppi);
X	if (e->thickness == 0)
X		fprintf(tfp, " invis");
X	set_fill(e->area_fill);
X	newline();
X	}
X
X/*
XText is displayed on the screen with the base line starting at
X(base_x, base_y); some characters extend below this line.
XPic displays the center of the height of text at the given
Xcoordinate. HT_OFFSET is used to compensate all the above factors
Xso text position in fig should be at the same position on
Xthe screen as on the hard copy.
X
XTHIS IS A HACK. tpic should be modified to put text with its
Xbaseline at the given coordinates as does fig -- Baron.
X*/
X#define			HT_OFFSET	(0.25 / 72.0)
X
Xvoid gentpic_text(t)
XF_text	*t;
X{
X	float	y;
X        char	*tpos;
X	int	virtual_font = 0;
X
X	/*
X	 * If a font size is specified and the current text font size
X	 * is the default, then use the specified font size.
X	 */
X	if (t->size == 0 && font_size)
X		t->size = font_size;
X
X	/*
X	 * tpic is informed of the baseline spacing here. Not particularly
X	 * useful in this version of the driver.
X	 */
X	set_baseline((int)t->size);
X
X	unpsfont(t);
X
X	if (t->font > MAX_FONT || vfont)
X		virtual_font = 1;	/* must be a virtual font */
X
X	if (virtual_font)
X		/*
X		 * NOTE. Virtual fonts are defined dynamically using
X		 * TeX's font definition machinery.
X		 */
X		fprintf(tfp, "\"\\font\\fig%s=%s at %dpt \\fig%s ",
X			TEXFONT(t->font), TEXFONT(t->font), t->size,
X			TEXFONT(t->font));
X	else
X#ifdef FST
X		fprintf(tfp, "\"\\%spt\\%s ", TEXFONTMAG(t), TEXFONT(t->font));
X#else
X		fprintf(tfp, "\"\\%s%s ", TEXFONTMAG(t), TEXFONT(t->font));
X#endif
X
X        switch (t->type) {
X        case T_LEFT_JUSTIFIED:
X        case DEFAULT:
X            tpos = "ljust";
X            break;
X        case T_CENTER_JUSTIFIED:
X            tpos = "";
X            break;
X        case T_RIGHT_JUSTIFIED:
X            tpos = "rjust";
X            break;
X        default:
X            fprintf(stderr, "unknown text position type\n");
X            exit(1);
X        }    
X	y = convy(t->base_y/ppi) + (TEXFONTMAGINT(t)
X		* HT_OFFSET);
X
X	fprintf(tfp, "%s\" at %.3f,%.3f %s",
X		t->cstring, t->base_x/ppi, y, tpos);
X	newline();
X}
X
Xvoid gentpic_arc(a)
XF_arc	*a;
X{
X	double		x, y;
X	double		cx, cy, sx, sy, ex, ey;
X
X	cx = a->center.x/ppi; cy = convy(a->center.y/ppi);
X	sx = a->point[0].x/ppi; sy = convy(a->point[0].y/ppi);
X	ex = a->point[2].x/ppi; ey = convy(a->point[2].y/ppi);
X
X	set_texture(a->area_fill);
X	set_linewidth(a->thickness);
X	set_style(a->style, a->style_val);
X
X	fprintf(tfp, "arc");
X
X	if (a->style == DASH_LINE && a->style_val > 0.0)
X		fprintf(tfp, " dashed");
X	else if (a->style == DOTTED_LINE && a->style_val > 0.0)
X		fprintf(tfp, " dotted");
X
X	/*rja: Attach arrowhead as required */
X	if ((a->for_arrow) && (a->back_arrow))
X		fprintf(tfp, " <->");
X	else if (a->back_arrow)
X		fprintf(tfp, " <-");
X	else if (a->for_arrow)
X		fprintf(tfp, " ->");
X
X
X	if (a->direction)
X	    fprintf(tfp, " at %.3f,%.3f from %.3f,%.3f to %.3f,%.3f",
X			cx, cy, sx, sy, ex, ey);
X	else
X	    fprintf(tfp, " at %.3f,%.3f from %.3f,%.3f to %.3f,%.3f cw",
X			cx, cy, sx, sy, ex, ey);
X	if (a->thickness == 0)
X		fprintf(tfp, " invis");
X	set_fill(a->area_fill);
X	newline();
X
X	}
X
Xstatic arc_tangent(x1, y1, x2, y2, direction, x, y)
Xdouble	x1, y1, x2, y2, *x, *y;
Xint	direction;
X{
X	if (direction) { /* counter clockwise  */
X	    *x = x2 + (y2 - y1);
X	    *y = y2 - (x2 - x1);
X	    }
X	else {
X	    *x = x2 - (y2 - y1);
X	    *y = y2 + (x2 - x1);
X	    }
X	}
X
X#define		THRESHOLD	.05	/* inch */
X
Xstatic quadratic_spline(a1, b1, a2, b2, a3, b3, a4, b4)
Xdouble	a1, b1, a2, b2, a3, b3, a4, b4;
X{
X	double	x1, y1, x4, y4;
X	double	xmid, ymid;
X
X	x1 = a1; y1 = b1;
X	x4 = a4; y4 = b4;
X
X	xmid = (a2 + a3) / 2;
X	ymid = (b2 + b3) / 2;
X	if (fabs(x1 - xmid) < THRESHOLD && fabs(y1 - ymid) < THRESHOLD) {
X	    fprintf(tfp, "\tto %.3f,%.3f\\\n", xmid, ymid);
X	    }
X	else {
X	    quadratic_spline(x1, y1, ((x1+a2)/2), ((y1+b2)/2),
X			((3*a2+a3)/4), ((3*b2+b3)/4), xmid, ymid);
X	    }
X
X	if (fabs(xmid - x4) < THRESHOLD && fabs(ymid - y4) < THRESHOLD) {
X	    fprintf(tfp, "\tto %.3f,%.3f\\\n", x4, y4);
X	    }
X	else {
X	    quadratic_spline(xmid, ymid, ((a2+3*a3)/4), ((b2+3*b3)/4),
X			((a3+x4)/2), ((b3+y4)/2), x4, y4);
X	    }
X	}
X
Xvoid gentpic_closed_spline(s)
XF_spline	*s;
X{
X	F_point	*p;
X	double	cx1, cy1, cx2, cy2, cx3, cy3, cx4, cy4;
X	double	x1, y1, x2, y2;
X
X	p = s->points;
X	x1 = p->x/ppi;  y1 = convy(p->y/ppi);
X	p = p->next;
X	x2 = p->x/ppi;  y2 = convy(p->y/ppi);
X	cx1 = (x1 + x2) / 2;      cy1 = (y1 + y2) / 2;
X	cx2 = (x1 + 3 * x2) / 4;  cy2 = (y1 + 3 * y2) / 4;
X
X	set_linewidth(s->thickness);
X	set_texture(s->area_fill); /* probably won't work! */
X	set_style(s->style, s->style_val);
X
X	for (p = p->next; p != NULL; p = p->next) {
X	    fprintf(tfp, "line from %.3f,%.3f ", cx1, cy1);
X	    x1 = x2;  y1 = y2;
X	    x2 = p->x/ppi;  y2 = convy(p->y/ppi);
X	    cx3 = (3 * x1 + x2) / 4;  cy3 = (3 * y1 + y2) / 4;
X	    cx4 = (x1 + x2) / 2;      cy4 = (y1 + y2) / 2;
X	    quadratic_spline(cx1, cy1, cx2, cy2, cx3, cy3, cx4, cy4);
X	    newline();
X	    /* fprintf(tfp, "\n"); */
X	    cx1 = cx4;  cy1 = cy4;
X	    cx2 = (x1 + 3 * x2) / 4;  cy2 = (y1 + 3 * y2) / 4;
X	    }
X	x1 = x2;  y1 = y2;
X	p = s->points->next;
X	x2 = p->x/ppi;  y2 = convy(p->y/ppi);
X	cx3 = (3 * x1 + x2) / 4;  cy3 = (3 * y1 + y2) / 4;
X	cx4 = (x1 + x2) / 2;      cy4 = (y1 + y2) / 2;
X	fprintf(tfp, "line from %.3f,%.3f ", cx1, cy1);
X	quadratic_spline(cx1, cy1, cx2, cy2, cx3, cy3, cx4, cy4);
X	if (s->thickness == 0)
X		fprintf(tfp, " invis");
X	set_fill(s->area_fill);
X	newline();
X	/* fprintf(tfp, "\n"); */
X	}
X
Xvoid gentpic_itp_spline(s)
XF_spline	*s;
X{
X	F_point		*p1, *p2, *pfirst;
X	F_control	*cp1, *cp2;
X	double		x1, x2, y1, y2;
X
X	set_style(s->style, s->style_val);
X	set_texture(s->area_fill); /* probably won't work! */
X	set_linewidth(s->thickness);
X
X	p1 = s->points;
X	cp1 = s->controls;
X	cp2 = cp1->next;
X	x2 = p1->x/ppi; y2 = convy(p1->y/ppi);
X
X         pfirst = p1->next;/*save first to test in loop*/
X	for (p2 = p1->next, cp2 = cp1->next; p2 != NULL;
X		p1 = p2, cp1 = cp2, p2 = p2->next, cp2 = cp2->next) {
X
X	    fprintf(tfp, "line ");
X
X           /*rja: Attach arrowhead as required */
X
X	    if ((s->back_arrow) && (p2 == pfirst))
X	       fprintf(tfp, " <- ");
X	    else if ((s->for_arrow) && (p2->next == NULL))
X	       fprintf(tfp, " -> ");
X
X	    fprintf(tfp, " from %.3f,%.3f ", x2, y2);
X
X	    x1 = x2; y1 = y2;
X	    x2 = p2->x/ppi; y2 = convy(p2->y/ppi);
X	    bezier_spline(x1, y1, (double)cp1->rx/ppi, convy(cp1->ry/ppi),
X		(double)cp2->lx/ppi, convy(cp2->ly/ppi), x2, y2);
X	    /* fprintf(tfp, "\n"); */
X	    newline();
X	    }
X
X	}
X
Xstatic bezier_spline(a0, b0, a1, b1, a2, b2, a3, b3)
Xdouble	a0, b0, a1, b1, a2, b2, a3, b3;
X{
X	double	x0, y0, x3, y3;
X	double	sx1, sy1, sx2, sy2, tx, ty, tx1, ty1, tx2, ty2, xmid, ymid;
X
X	x0 = a0; y0 = b0;
X	x3 = a3; y3 = b3;
X	if (fabs(x0 - x3) < THRESHOLD && fabs(y0 - y3) < THRESHOLD) {
X	    fprintf(tfp, "\tto %.3f,%.3f\\\n", x3, y3);
X	    }
X	else {
X	    tx = (a1 + a2) / 2;		ty = (b1 + b2) / 2;
X	    sx1 = (x0 + a1) / 2;	sy1 = (y0 + b1) / 2;
X	    sx2 = (sx1 + tx) / 2;	sy2 = (sy1 + ty) / 2;
X	    tx2 = (a2 + x3) / 2;	ty2 = (b2 + y3) / 2;
X	    tx1 = (tx2 + tx) / 2;	ty1 = (ty2 + ty) / 2;
X	    xmid = (sx2 + tx1) / 2;	ymid = (sy2 + ty1) / 2;
X
X	    bezier_spline(x0, y0, sx1, sy1, sx2, sy2, xmid, ymid);
X	    bezier_spline(xmid, ymid, tx1, ty1, tx2, ty2, x3, y3);
X	    }
X	}
X
Xstatic void
Xnewline()
X{
X	/*
X	 * A vestige from another version of this driver.
X	 */
X	fprintf(tfp, "\n");
X}
X
Xstruct driver dev_tpic = {
X     	gentpic_option,
X	gentpic_start,
X	gentpic_arc,
X	gentpic_ellipse,
X	gentpic_line,
X	gentpic_spline,
X	gentpic_text,
X	gentpic_end,
X	INCLUDE_TEXT
X};
X
END_OF_FILE
if test 22577 -ne `wc -c <'fig2dev/dev/gentpic.c'`; then
    echo shar: \"'fig2dev/dev/gentpic.c'\" unpacked with wrong size!
fi
# end of 'fig2dev/dev/gentpic.c'
fi
echo shar: End of archive 5 \(of 7\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
