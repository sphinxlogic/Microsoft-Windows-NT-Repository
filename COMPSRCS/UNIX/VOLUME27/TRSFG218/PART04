Newsgroups: comp.sources.unix
From: envbvs@epb12.lbl.gov (Brian V. Smith)
Subject: v27i058: transfig-2.1.8 - a set of tools for creating TeX documents with graphics, Part04/07
References: <1.749903574.10622@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: envbvs@epb12.lbl.gov (Brian V. Smith)
Posting-Number: Volume 27, Issue 58
Archive-Name: transfig-2.1.8/part04

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 7)."
# Contents:  fig2dev/Makefile fig2dev/dev/genpic.c
#   fig2dev/dev/gentextyl.c fig2dev/read.c
# Wrapped by envbvs@epb12.lbl.gov.lbl.gov on Fri Oct  1 14:55:48 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'fig2dev/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fig2dev/Makefile'\"
else
echo shar: Extracting \"'fig2dev/Makefile'\" \(16232 characters\)
sed "s/^X//" >'fig2dev/Makefile' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
X#
X# The cpp used on this machine replaces all newlines and multiple tabs and
X# spaces in a macro expansion with a single space.  Imake tries to compensate
X# for this, but is not always successful.
X#
X
X# -------------------------------------------------------------------------
X# Makefile generated from "Imake.tmpl" and </tmp/IIf.a21005>
X# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
X#
X# Platform-specific parameters may be set in the appropriate <vendor>.cf
X# configuration files.  Site-specific parameters should be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor does not define any unique symbols, you will need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make World" the first time).
X#
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that need to come before
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X# -------------------------------------------------------------------------
X# platform-specific configuration parameters - edit sun.cf to change
X
X# platform:  $XConsortium: sun.cf,v 1.72.1.1 92/03/18 13:13:37 rws Exp $
X
X# operating system:  SunOS 4.1.2
X
X# $XConsortium: sunLib.rules,v 1.7 91/12/20 11:19:47 rws Exp $
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that go after
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = ../.
X      CURRENT_DIR = ./fig2dev
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -g kmem -m 2755
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS =
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X# -------------------------------------------------------------------------
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.138 91/09/10 09:02:12 rws Exp $
X
X# -------------------------------------------------------------------------
X# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/lib
X           BINDIR = /usr/bin/X11
X          INCROOT = /usr/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = l
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
X# $XConsortium: sunLib.tmpl,v 1.14.1.1 92/03/17 14:58:46 rws Exp $
X
XSHLIBLDFLAGS = -assert pure-text
XPICFLAGS = -pic
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sa.$(SOXMUREV)
X       XMULIBONLY = -lXmu
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sa.$(SOXTREV)
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sa.$(SOXAWREV)
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        SOXLIBREV = 4.10
X          SOXTREV = 4.10
X         SOXAWREV = 5.0
X        SOOLDXREV = 4.10
X         SOXMUREV = 4.10
X        SOXEXTREV = 4.10
X      SOXINPUTREV = 4.10
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X# -------------------------------------------------------------------------
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
X# -------------------------------------------------------------------------
X# start of Imakefile
X
X#	Fig2dev : General Fig code translation program
X#
X# TransFig: Facility for Translating Fig code
X# Copyright (c) 1985 Supoj Sutantavibul
X# Copyright (c) 1991 Micah Beck
X#
X# Permission to use, copy, modify, distribute, and sell this software and its
X# documentation for any purpose is hereby granted without fee, provided that
X# the above copyright notice appear in all copies and that both that
X# copyright notice and this permission notice appear in supporting
X# documentation. The authors make no representations about the suitability
X# of this software for any purpose.  It is provided "as is" without express
X# or implied warranty.
X#
X# THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN 0
X# EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X# CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
X# DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
X# TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X# PERFORMANCE OF THIS SOFTWARE.
X#
X#
X# to include drivers for the following languages,
X# add the corresponding symbol to the DEFINES list:
X#
X# -DEPIC -DIBMGL -DLATEX -DPIC -DPICTEX -DPS -DPSTEX -DTEXTYL -DTPIC
X#
XDEFINES = -DEPIC -DIBMGL -DLATEX -DPIC -DPICTEX -DPS -DPSTEX -DTEXTYL -DTPIC
XDEPLIBS =
X
XSUBDIRS = dev
X
XINCLUDES = -I..
X
XSRCS = fig2dev.c getopt.c psfonts.c iso2tex.c \
X	arrow.c bound.c free.c read.c read1_3.c latex_line.c $(STRSTRC)
XOBJS = fig2dev.o getopt.o psfonts.o iso2tex.o \
X	arrow.o bound.o free.o read.o read1_3.o latex_line.o $(STRSTRO) \
X	dev/libtransfig.a
X
XEXTRA_LIBRARIES = -lm
X
Xall::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "making" all "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) 'CDEBUGFLAGS=$(CDEBUGFLAGS)' all); \
X	done
X
Xdepend::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "depending" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS)  depend); \
X	done
X
X PROGRAM = fig2dev
X
Xall:: fig2dev
X
Xfig2dev: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
Xsaber_fig2dev:: $(SRCS)
X	# load $(ALLDEFINES) $(SRCS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xosaber_fig2dev:: $(OBJS)
X	# load $(ALLDEFINES) $(OBJS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xinstall:: fig2dev
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  fig2dev $(DESTDIR)$(BINDIR)
X
Xinstall.man:: fig2dev.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) fig2dev.man $(DESTDIR)$(MANDIR)/fig2dev.$(MANSUFFIX)
X
Xdepend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
Xlint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
Xlint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
Xclean::
X	$(RM) $(PROGRAM)
X
Xinstall:: fig2ps2tex.script
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTBINFLAGS) fig2ps2tex.script $(DESTDIR)$(BINDIR)/fig2ps2tex
X
Xinstall:: pic2tpic.script
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTBINFLAGS) pic2tpic.script $(DESTDIR)$(BINDIR)/pic2tpic
X
Xinstall.man:: fig2ps2tex.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) fig2ps2tex.man $(DESTDIR)$(MANDIR)/fig2ps2tex.$(MANSUFFIX)
X
Xinstall.man:: pic2tpic.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) pic2tpic.man $(DESTDIR)$(MANDIR)/pic2tpic.$(MANSUFFIX)
X
Xfig2dev.man: ../doc/fig2dev.1
X	ln -s ../doc/fig2dev.1 fig2dev.man
X
Xfig2ps2tex.man: ../doc/fig2ps2tex.1
X	ln -s ../doc/fig2ps2tex.1 fig2ps2tex.man
X
Xpic2tpic.man: ../doc/pic2tpic.1
X	ln -s ../doc/pic2tpic.1 pic2tpic.man
X
X# -------------------------------------------------------------------------
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) "#"*
X
XMakefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
Xsaber:
X	# load $(ALLDEFINES) $(SRCS)
X
Xosaber:
X	# load $(ALLDEFINES) $(OBJS)
X
X# -------------------------------------------------------------------------
X# rules for building in SUBDIRS - do not edit
X
Xinstall::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "installing" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) DESTDIR='$(DESTDIR)' install); \
X	done
X
Xinstall.man::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "installing man pages" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) DESTDIR='$(DESTDIR)' install.man); \
X	done
X
Xclean::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "cleaning" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) RM_CMD='$(RM_CMD)' clean); \
X	done
X
Xtags::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "tagging" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) TAGS='$(TAGS)' tags); \
X	done
X
XMakefiles::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	echo "making Makefiles in $(CURRENT_DIR)/$$i..."; \
X	case "$$i" in \
X	./?*/?*/?*/?*) newtop=../../../../ sub=subsubsubsub;; \
X	./?*/?*/?*) newtop=../../../ sub=subsubsub;; \
X	./?*/?*) newtop=../../ sub=subsub;; \
X	./?*) newtop=../ sub=sub;; \
X	*/?*/?*/?*) newtop=../../../../ sub=subsubsubsub;; \
X	*/?*/?*) newtop=../../../ sub=subsubsub;; \
X	*/?*) newtop=../../ sub=subsub;; \
X	*) newtop=../ sub=sub;; \
X	esac; \
X	case "$(TOP)" in \
X	/?*) newtop= upprefix= ;; \
X	*) upprefix=../ ;; \
X	esac; \
X	$(MAKE) $${sub}dirMakefiles UPPREFIX=$$upprefix NEWTOP=$$newtop \
X	MAKEFILE_SUBDIR=$$i NEW_CURRENT_DIR=$(CURRENT_DIR)/$$i;\
X	done
X
XsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then set -x; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
XsubsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then set -x; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
XsubsubsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then set -x; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(UPPREFIX)$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
XsubsubsubsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then set -x; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(UPPREFIX)$(UPPREFIX)$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
Xincludes::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo including "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS)  includes); \
X	done
X
X# -------------------------------------------------------------------------
X# dependencies generated by makedepend
X
END_OF_FILE
if test 16232 -ne `wc -c <'fig2dev/Makefile'`; then
    echo shar: \"'fig2dev/Makefile'\" unpacked with wrong size!
fi
# end of 'fig2dev/Makefile'
fi
if test -f 'fig2dev/dev/genpic.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fig2dev/dev/genpic.c'\"
else
echo shar: Extracting \"'fig2dev/dev/genpic.c'\" \(16429 characters\)
sed "s/^X//" >'fig2dev/dev/genpic.c' <<'END_OF_FILE'
X/*
X * TransFig: Facility for Translating Fig code
X * Copyright (c) 1985 Supoj Sutantavibul
X * Copyright (c) 1991 Micah Beck
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation. The authors make no representations about the suitability 
X * of this software for any purpose.  It is provided "as is" without express 
X * or implied warranty.
X *
X * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
X * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
X * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X *
X */
X
X/* 
X *	genpic : PIC driver for fig2dev
X *
X *	Author: Conrad Kwok, UC Davis, 12/88
X *      Modified: Richard Auletta, George Mason Univ., 6/21/89
X *	Added code comments are marked with "rja".
X *      Added: Support for native pic arrowheads.
X *      Added: Support for arrowheads at both ends of lines, arc, splines.
X *
X *      Modified: Stuart Kemp & Dave Bonnell, July, 1991
X *		  James Cook University,
X *		  Australia
X *      Changes:
X *		Added T_ARC_BOX to genpic_line()
X *		Added 'thickness' attribute all over
X *		Added 'fill' attribute to ellipse
X *		Cleaned up the code
X */
X
X#include <stdio.h>
X#include <math.h>
X#include "object.h"
X#include "fig2dev.h"
X#include "picfonts.h"
X#include "picpsfonts.h"
X
Xvoid genpic_ctl_spline(), genpic_itp_spline();
Xvoid genpic_open_spline(), genpic_closed_spline();
X
X#define			TOP	10.5	/* top of page is 10.5 inch */
Xstatic double		ppi;
Xstatic int		CONV = 0;
Xstatic int LineThickness = 0;
Xstatic int OptArcBox = 0;		/* Conditional use */
Xstatic int OptLineThick = 0;
Xstatic int OptEllipseFill = 0;
Xstatic int OptNoUnps = 0;    /* prohibit unpsfont() */
X
Xvoid
Xgenpic_option(opt, optarg)
Xchar opt, *optarg;
X{
X	switch (opt) {
X
X	case 'f':		/* set default text font */
X	        {   int i;
X
X		    for ( i = 1; i <= MAX_FONT; i++ )
X			if ( !strcmp(optarg, picfontnames[i]) ) break;
X
X		    if ( i > MAX_FONT)
X			fprintf(stderr,
X			"warning: non-standard font name %s\n", optarg);
X		}
X		
X		picfontnames[0] = picfontnames[1] = optarg;
X		break;
X
X	case 's':
X		if (font_size <= 0 || font_size > MAXFONTSIZE) {
X			fprintf(stderr,
X				"warning: font size %d out of bounds\n", font_size);
X		}
X		break;
X
X	case 'm':
X	case 'L':
X		break;
X
X	case 'p':
X		if (strcmp(optarg, "all") == 0)
X		  OptArcBox = OptLineThick = OptEllipseFill = 1;
X		else
X		  if (strcmp(optarg, "arc") == 0)
X		    OptArcBox = 1;
X		  else
X		    if (strcmp(optarg, "line") == 0)
X		      OptLineThick = 1;
X		    else
X		      if (strcmp(optarg, "fill") == 0)
X			OptEllipseFill = 1;
X		      else
X			if (strcmp(optarg, "psfont") == 0)
X			  OptNoUnps = 1;
X			else
X			  if (strcmp(optarg, "allps") == 0)
X			    OptArcBox =
X			      OptLineThick =
X				OptEllipseFill =
X				  OptNoUnps = 1;
X			  else
X			    { fprintf(stderr, "Invalid option: %s\n", optarg);
X			      exit(1);
X			    }
X		break;
X	      default:
X		put_msg(Err_badarg, opt, "pic");
X		exit(1);
X	}
X}
X
Xstatic
Xdouble convy(a)
Xdouble	a;
X{
X	return((double)(CONV ? TOP-a : a));
X}
X
Xvoid
Xgenpic_start(objects)
XF_compound	*objects;
X{
X	int		coord_system;
X
X	ppi = objects->nwcorner.x/mag;
X	coord_system = objects->nwcorner.y;
X	if (coord_system == 2) CONV = 1;
X
X	fprintf(tfp, ".PS\n.ps %d\n", font_size);	/* PIC preamble */
X}
X
Xvoid
Xgenpic_end()
X{
X  	fprintf(tfp, ".PE\n");				/* PIC ending */
X}
X
X/*
XThe line thickness is, unfortunately, multiple of pixel.
XOne pixel thickness is a little too thick on the hard copy
Xso I scale it with 0.7; i.e., it's a kludge.  The best way is
Xto allow thickness in fraction of pixel.
X
XNote that the current version of psdit (a ditroff to postcript filter)
Xwon't take the legitimate line thickness command.
X*/
Xstatic
Xset_linewidth(w)
Xint	w;
X{
X	static int	cur_thickness = -1;
X
X	LineThickness = w;
X
X	/*
X	if (w == 0) return;
X	if (w != cur_thickness) {
X	    cur_thickness = w;
X	    fprintf(tfp, "\"\\D't %.5fi'\"\n", 0.7 * cur_thickness / ppi);
X	    }
X	*/
X}
X
Xstatic void
XAddThickness()
X{
X  if (OptLineThick && LineThickness)
X    fprintf(tfp, " thickness %d", LineThickness);
X}
X
Xstatic void
Xset_style(s, v)
Xint	s;
Xfloat	v;
X{
X	static float	style_val = -1;
X
X	if (s == DASH_LINE || s == DOTTED_LINE) {
X	    if (v == style_val) return;
X	    if (v == 0.0) return;
X	    style_val = v;
X	    fprintf(tfp, "dashwid = %.3fi\n", style_val/ppi);
X	    }
X}
X
X/*
X * Makes use of the PIC 'box' command
X *
X * Returns 0 if command failed, else non-zero.
X *
X */
X
Xstatic int
Xgenpic_box(l)
XF_line *l;
X{
X  int count, minx, miny, maxx, maxy;
X  int Valid;		/* Valid box */
X  double width, height;
X  F_point *p, *q;
X	
X  p = l->points;
X  q = p->next;
X  count = 1;		/* Just a sanity check */
X  minx = maxx = p->x;
X  miny = maxy = p->y;
X
X  /* Find the boundaries */
X  while (q != NULL)
X  { count++;
X    if (q->x < minx) minx = q->x;
X    else
X      if (q->x > maxx) maxx = q->x;
X
X    if (q->y < miny) miny = q->y;
X    else
X      if (q->y > maxy) maxy = q->y;
X
X    q = q->next;
X  }
X
X  if (Valid = (count == 5))		/* Valid box? */
X  { fprintf(tfp, "box");
X    if (l->thickness == 0)
X      fprintf(tfp, " invis");
X    else
X      if (l->style_val > 0.0)
X      { if (l->style == DASH_LINE)
X	  fprintf(tfp, " dashed");
X	else if (l->style == DOTTED_LINE)
X	  fprintf(tfp, " dotted");
X      }
X
X    /* Should have a #define somewhere for the # of fill patterns */
X    if (l->area_fill > 0)
X      fprintf(tfp, " fill %.2f", ((double) (l->area_fill - 1)) / 20);
X
X    fprintf(tfp, " with .sw at (%.2f,%.2f) ",
X	    minx / ppi, convy(maxy / ppi));
X
X    width = (maxx - minx) / ppi;
X    if (width < 0.0) width = -width;
X    height = convy(maxy / ppi) - convy(miny / ppi);
X    if (height < 0.0) height = -height;
X
X    fprintf(tfp, "width %.2f height %.2f", width, height);
X
X    if (OptArcBox && l->type == T_ARC_BOX)
X      fprintf(tfp, " rad %.2f", l->radius/ppi);
X
X    AddThickness();
X
X    fprintf(tfp, "\n");
X  }
X
X  return(Valid);
X}
X
Xvoid
Xgenpic_line(l)
XF_line	*l;
X{
X	F_point		*p, *q;
X
X	if (l->type == T_ARC_BOX && !OptArcBox)
X	{ fprintf(stderr, "Arc box not implemented; substituting box.\n");
X	  l->type = T_BOX;
X	}
X
X	set_linewidth(l->thickness);
X	set_style(l->style, l->style_val);
X	p = l->points;
X	q = p->next;
X	if (q == NULL)	/* A single point line */
X	{   fprintf(tfp, "line from %.3f,%.3f to %.3f,%.3f",
X			p->x/ppi, convy(p->y/ppi), p->x/ppi, convy(p->y/ppi));
X	    AddThickness();
X	    fprintf(tfp, "\n");
X	    return;
X	}
X
X	if (l->type == T_BOX || l->type == T_ARC_BOX)
X	{ if (genpic_box(l)) return;
X	  fprintf(stderr, "Invalid T_BOX or T_ARC_BOX in fig file\n");
X          fprintf(stderr, "  Using 'line' instead\n");
X	}
X
X	fprintf(tfp, "line");
X
X	if (l->style_val > 0.0)
X	{ if (l->style == DASH_LINE)
X	    fprintf(tfp, " dashed");
X	  else
X	    if (l->style == DOTTED_LINE)
X	      fprintf(tfp, " dotted");
X	}
X
X	/*rja: Place arrowheads or lack there of on the line*/
X	if ((l->for_arrow) && (l->back_arrow))
X	    fprintf(tfp, " <->");
X	else if (l->back_arrow)
X	    fprintf(tfp, " <-");
X	else if (l->for_arrow)
X	    fprintf(tfp, " ->");
X
X	fprintf(tfp, " from %.3f,%.3f", p->x/ppi, convy(p->y/ppi));
X	do
X	{ fprintf(tfp, " to %.3f,%.3f", q->x/ppi, convy(q->y/ppi));
X	  q = q->next;
X	} while (q != NULL);
X
X	AddThickness();
X
X	fprintf(tfp, "\n");
X}
X
Xvoid
Xgenpic_spline(s)
XF_spline	*s;
X{
X	if (int_spline(s))
X	    genpic_itp_spline(s);
X	else
X	    genpic_ctl_spline(s);
X	}
X
Xvoid
Xgenpic_ctl_spline(s)
XF_spline	*s;
X{
X	if (closed_spline(s))
X	    genpic_closed_spline(s);
X	else
X	    genpic_open_spline(s);
X	}
X
Xvoid
Xgenpic_open_spline(s)
XF_spline	*s;
X{
X	double		x1, y1, x2, y2;
X	F_point		*p, *q;
X
X	p = s->points;
X	x1 = p->x/ppi; y1 = convy(p->y/ppi);
X	p = p->next;
X	x2 = p->x/ppi; y2 = convy(p->y/ppi);
X
X
X	/* Pic's spline supports only solid line style */
X	/* set_linewidth(s->thickness); */
X
X	if (p->next == NULL) {
X	    fprintf(tfp, "line");
X
X           /*rja: Attach arrowhead as required */
X	    if ((s->for_arrow) && (s->back_arrow))
X	       fprintf(tfp, " <->");
X	    else if (s->back_arrow)
X	       fprintf(tfp, " <-");
X	    else if (s->for_arrow)
X	       fprintf(tfp, " ->");
X
X	    fprintf(tfp, " from %.3f,%.3f to %.3f,%.3f", x1, y1, x2, y2);
X
X	    AddThickness();
X
X	    fprintf(tfp, "\n");
X
X	    return;
X	    }
X
X	fprintf(tfp, "spline"); 
X
X           /*rja: Attach arrowhead as required */
X	    if ((s->for_arrow) && (s->back_arrow))
X	       fprintf(tfp, " <->");
X	    else if (s->back_arrow)
X	       fprintf(tfp, " <-");
X	    else if (s->for_arrow)
X	       fprintf(tfp, " ->");
X
X	fprintf(tfp, " from %.3f,%.3f to %.3f,%.3f", x1, y1, x2, y2);
X
X	for (q = p->next; q->next != NULL; p = q, q = q->next)
X	    fprintf(tfp, " to %.3f,%.3f", q->x/ppi, convy(q->y/ppi));
X	fprintf(tfp, " to %.3f,%.3f", q->x/ppi, convy(q->y/ppi));
X
X	AddThickness();
X
X	fprintf(tfp, "\n");
X}
X
Xvoid
Xgenpic_ellipse(e)
XF_ellipse	*e;
X{
X	set_linewidth(e->thickness);
X	if (e->type == 3 || e->type == 4)
X	  fprintf(tfp, "circle at %.3f,%.3f rad %.3f",
X		e->center.x/ppi, convy(e->center.y/ppi),
X		e->radiuses.x/ppi);
X	else
X	  fprintf(tfp, "ellipse at %.3f,%.3f wid %.3f ht %.3f",
X		e->center.x/ppi, convy(e->center.y/ppi),
X		2 * e->radiuses.x/ppi, 2 * e->radiuses.y/ppi);
X
X	if ( OptEllipseFill && e->area_fill > 0)
X	  fprintf(tfp, " fill %.2f", ((double)(e->area_fill - 1)) / 20);
X
X	AddThickness();
X
X	fprintf(tfp, "\n");
X}
X
X/*
XText is display on the screen with the base line starting at
X(base_x, base_y); some characters extend below this line.
XPic displays the center of the height of text at the given
Xcoordinate. HT_OFFSET is use to compensate all the above factors
Xso text position in fig 1.4 should be at the same position on
Xthe screen as on the hard copy.
X*/
X#define			HT_OFFSET	(0.2 / 72.0)
X
Xvoid
Xgenpic_text(t)
XF_text	*t;
X{
X	float	y;
X        char *tpos;
X
X	if (!OptNoUnps) {
X	  unpsfont(t);
X	  fprintf(tfp, "\"\\s%d\\f%s", PICFONTMAG(t) ,
X		  PICFONT(t->font) );
X	} else {
X	  fprintf(tfp, ".ps\n.ps %d\n", PICFONTMAG(t) );
X	  fprintf(tfp, ".ft\n.ft %s\n", PICPSFONT(t) );
X	}
X
X        switch (t->type) {
X        case T_LEFT_JUSTIFIED:
X        case DEFAULT:
X            tpos = "ljust";
X            break;
X        case T_CENTER_JUSTIFIED:
X            tpos = "";
X            break;
X        case T_RIGHT_JUSTIFIED:
X            tpos = "rjust";
X            break;
X        default:
X            fprintf(stderr, "unknown text position type\n");
X            exit(1);
X        }    
X 	y = convy(t->base_y/ppi) +
X 	    PICFONTMAG(t) *
X             HT_OFFSET;
X 	if (!OptNoUnps)
X 	    fprintf(tfp, "%s\\fP\" at %.3f,%.3f %s\n",
X 			t->cstring, t->base_x/ppi, y, tpos);
X 	else
X 	    fprintf(tfp, "\"%s\" at %.3f,%.3f %s\n.ft \n.ps \n",
X			t->cstring, t->base_x/ppi, y, tpos);
X	}
X
Xvoid
Xgenpic_arc(a)
XF_arc	*a;
X{
X	double		x, y;
X	double		cx, cy, sx, sy, ex, ey;
X
X	cx = a->center.x/ppi; cy = convy(a->center.y/ppi);
X	sx = a->point[0].x/ppi; sy = convy(a->point[0].y/ppi);
X	ex = a->point[2].x/ppi; ey = convy(a->point[2].y/ppi);
X
X	set_linewidth(a->thickness);
X
X	fprintf(tfp, "arc ");
X
X	/*rja: Attach arrowhead as required */
X	if ((a->for_arrow) && (a->back_arrow))
X	  fprintf(tfp, " <->");
X	else if (a->back_arrow)
X	  fprintf(tfp, " <-");
X	else if (a->for_arrow)
X	  fprintf(tfp, " ->");
X
X
X	fprintf(tfp, " at %.3f,%.3f from %.3f,%.3f to %.3f,%.3f",
X		cx, cy, sx, sy, ex, ey);
X
X	if (!a->direction)
X	  fprintf(tfp, " cw");
X
X	if (a->area_fill > 0.0)
X	  fprintf(stderr, "PIC does not support filled arcs ... ignoring 'fill' directive\n");
X
X	AddThickness();
X	fprintf(tfp, "\n");
X}
X
Xvoid
Xarc_tangent(x1, y1, x2, y2, direction, x, y)
Xdouble	x1, y1, x2, y2, *x, *y;
Xint	direction;
X{
X	if (direction)	/* counter clockwise  */
X	{   *x = x2 + (y2 - y1);
X	    *y = y2 - (x2 - x1);
X	}
X	else
X	{   *x = x2 - (y2 - y1);
X	    *y = y2 + (x2 - x1);
X	}
X}
X
X/*	draw arrow heading from (x1, y1) to (x2, y2)	*/
X
Xdraw_arrow_head(x1, y1, x2, y2, arrowht, arrowwid)
Xdouble	x1, y1, x2, y2, arrowht, arrowwid;
X{
X	double	x, y, xb, yb, dx, dy, l, sina, cosa;
X	double	xc, yc, xd, yd;
X
X	dx = x2 - x1;  dy = y1 - y2;
X	l = sqrt((dx*dx + dy*dy));
X	if (l == 0) {
X	     return;
X	}
X	else {
X	     sina = dy / l;  cosa = dx / l;
X	}
X	xb = x2*cosa - y2*sina;
X	yb = x2*sina + y2*cosa;
X	x = xb - arrowht;
X	y = yb - arrowwid / 2;
X	xc = x*cosa + y*sina;
X	yc = -x*sina + y*cosa;
X	y = yb + arrowwid / 2;
X	xd = x*cosa + y*sina;
X	yd = -x*sina + y*cosa;
X	fprintf(tfp, "line from %.3f,%.3f to %.3f,%.3f to %.3f,%.3f\n",
X		xc, yc, x2, y2, xd, yd);
X	}
X
X#define		THRESHOLD	.05	/* inch */
X
Xquadratic_spline(a1, b1, a2, b2, a3, b3, a4, b4)
Xdouble	a1, b1, a2, b2, a3, b3, a4, b4;
X{
X	double	x1, y1, x4, y4;
X	double	xmid, ymid;
X
X	x1 = a1; y1 = b1;
X	x4 = a4; y4 = b4;
X
X	xmid = (a2 + a3) / 2;
X	ymid = (b2 + b3) / 2;
X	if (fabs(x1 - xmid) < THRESHOLD && fabs(y1 - ymid) < THRESHOLD)
X	{ fprintf(tfp, " to %.3f,%.3f", xmid, ymid);
X	}
X	else {
X	    quadratic_spline(x1, y1, ((x1+a2)/2), ((y1+b2)/2),
X			((3*a2+a3)/4), ((3*b2+b3)/4), xmid, ymid);
X	    }
X
X	if (fabs(xmid - x4) < THRESHOLD && fabs(ymid - y4) < THRESHOLD)
X	{ fprintf(tfp, " to %.3f,%.3f", x4, y4);
X	}
X	else {
X	    quadratic_spline(xmid, ymid, ((a2+3*a3)/4), ((b2+3*b3)/4),
X			((a3+x4)/2), ((b3+y4)/2), x4, y4);
X	    }
X	}
X
Xvoid
Xgenpic_closed_spline(s)
XF_spline	*s;
X{
X	F_point	*p;
X	double	cx1, cy1, cx2, cy2, cx3, cy3, cx4, cy4;
X	double	x1, y1, x2, y2;
X
X	p = s->points;
X	x1 = p->x/ppi;  y1 = convy(p->y/ppi);
X	p = p->next;
X	x2 = p->x/ppi;  y2 = convy(p->y/ppi);
X	cx1 = (x1 + x2) / 2;      cy1 = (y1 + y2) / 2;
X	cx2 = (x1 + 3 * x2) / 4;  cy2 = (y1 + 3 * y2) / 4;
X
X	for (p = p->next; p != NULL; p = p->next) {
X	    fprintf(tfp, "line from %.3f,%.3f ", cx1, cy1);
X	    x1 = x2;  y1 = y2;
X	    x2 = p->x/ppi;  y2 = convy(p->y/ppi);
X	    cx3 = (3 * x1 + x2) / 4;  cy3 = (3 * y1 + y2) / 4;
X	    cx4 = (x1 + x2) / 2;      cy4 = (y1 + y2) / 2;
X	    quadratic_spline(cx1, cy1, cx2, cy2, cx3, cy3, cx4, cy4);
X	    AddThickness();
X	    fprintf(tfp, "\n");
X	    cx1 = cx4;  cy1 = cy4;
X	    cx2 = (x1 + 3 * x2) / 4;  cy2 = (y1 + 3 * y2) / 4;
X	    }
X	x1 = x2;  y1 = y2;
X	p = s->points->next;
X	x2 = p->x/ppi;  y2 = convy(p->y/ppi);
X	cx3 = (3 * x1 + x2) / 4;  cy3 = (3 * y1 + y2) / 4;
X	cx4 = (x1 + x2) / 2;      cy4 = (y1 + y2) / 2;
X	fprintf(tfp, "line from %.3f,%.3f ", cx1, cy1);
X	quadratic_spline(cx1, cy1, cx2, cy2, cx3, cy3, cx4, cy4);
X	AddThickness();
X	fprintf(tfp, "\n");
X}
X
Xvoid
Xgenpic_itp_spline(s)
XF_spline	*s;
X{
X	F_point		*p1, *p2, *pfirst;
X	F_control	*cp1, *cp2;
X	double		x1, x2, y1, y2;
X
X	p1 = s->points;
X	cp1 = s->controls;
X	cp2 = cp1->next;
X	x2 = p1->x/ppi; y2 = convy(p1->y/ppi);
X
X         pfirst = p1->next;/*save first to test in loop*/
X	for (p2 = p1->next, cp2 = cp1->next; p2 != NULL;
X		p1 = p2, cp1 = cp2, p2 = p2->next, cp2 = cp2->next) {
X
X	    fprintf(tfp, "line ");
X
X           /*rja: Attach arrowhead as required */
X
X	    if ((s->back_arrow) && (p2 == pfirst))
X	       fprintf(tfp, " <- ");
X	    else if ((s->for_arrow) && (p2->next == NULL))
X	       fprintf(tfp, " -> ");
X
X	    fprintf(tfp, " from %.3f,%.3f", x2, y2);
X
X	    x1 = x2; y1 = y2;
X	    x2 = p2->x/ppi; y2 = convy(p2->y/ppi);
X	    bezier_spline(x1, y1, (double)cp1->rx/ppi, convy(cp1->ry/ppi),
X		(double)cp2->lx/ppi, convy(cp2->ly/ppi), x2, y2);
X	    AddThickness();
X	    fprintf(tfp, "\n");
X	    }
X
X	}
X
Xbezier_spline(a0, b0, a1, b1, a2, b2, a3, b3)
Xdouble	a0, b0, a1, b1, a2, b2, a3, b3;
X{
X	double	x0, y0, x3, y3;
X	double	sx1, sy1, sx2, sy2, tx, ty, tx1, ty1, tx2, ty2, xmid, ymid;
X
X	x0 = a0; y0 = b0;
X	x3 = a3; y3 = b3;
X	if (fabs(x0 - x3) < THRESHOLD && fabs(y0 - y3) < THRESHOLD)
X	{ fprintf(tfp, " to %.3f,%.3f", x3, y3);
X	}
X	else {
X	    tx = (a1 + a2) / 2;		ty = (b1 + b2) / 2;
X	    sx1 = (x0 + a1) / 2;	sy1 = (y0 + b1) / 2;
X	    sx2 = (sx1 + tx) / 2;	sy2 = (sy1 + ty) / 2;
X	    tx2 = (a2 + x3) / 2;	ty2 = (b2 + y3) / 2;
X	    tx1 = (tx2 + tx) / 2;	ty1 = (ty2 + ty) / 2;
X	    xmid = (sx2 + tx1) / 2;	ymid = (sy2 + ty1) / 2;
X
X	    bezier_spline(x0, y0, sx1, sy1, sx2, sy2, xmid, ymid);
X	    bezier_spline(xmid, ymid, tx1, ty1, tx2, ty2, x3, y3);
X	    }
X	}
X
Xstruct driver dev_pic = {
X     	genpic_option,
X	genpic_start,
X	genpic_arc,
X	genpic_ellipse,
X	genpic_line,
X	genpic_spline,
X	genpic_text,
X	genpic_end,
X	INCLUDE_TEXT
X};
END_OF_FILE
if test 16429 -ne `wc -c <'fig2dev/dev/genpic.c'`; then
    echo shar: \"'fig2dev/dev/genpic.c'\" unpacked with wrong size!
fi
# end of 'fig2dev/dev/genpic.c'
fi
if test -f 'fig2dev/dev/gentextyl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fig2dev/dev/gentextyl.c'\"
else
echo shar: Extracting \"'fig2dev/dev/gentextyl.c'\" \(14413 characters\)
sed "s/^X//" >'fig2dev/dev/gentextyl.c' <<'END_OF_FILE'
X/*
X * TransFig: Facility for Translating Fig code
X * Copyright (c) 1985 Supoj Sutantavibul
X * Copyright (c) 1991 Micah Beck
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation. The authors make no representations about the suitability 
X * of this software for any purpose.  It is provided "as is" without express 
X * or implied warranty.
X *
X * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
X * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
X * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X *
X */
X
X/* 
X *	gentextyl.c : TeXtyl driver for fig2dev
X *
X * 	Author: Gary Beihl, MCC 8/90
X *	(beihl@mcc.com)
X *
X *      Based on the pictex driver by Micah Beck
X *
X */
X
X#if defined(hpux) || defined(SYSV)
X#include <sys/types.h>
X#endif
X#include <sys/file.h>
X#include <stdio.h>
X#include <math.h>
X#include "pi.h"
X#include "object.h"
X#include "fig2dev.h"
X#include "texfonts.h"
X
X#ifndef sin
Xextern double sin();
X#endif
X#ifndef cos
Xextern double cos();
X#endif
X#ifndef acos
Xextern double acos();
X#endif
X#ifndef fabs
Xextern double fabs();
X#endif
X
Xvoid gentextyl_ctl_spline(), gentextyl_itp_spline();
X
Xstatic int		coord_system;
Xstatic double		dash_length = -1;
Xstatic int		line_style = 0; /* Textyl solid line style */
Xstatic int 		linethick = 2;  /* Range is 1-12 `pixels' */
X 
X
Xstatic void gentextyl_option(opt, optarg)
Xchar opt, *optarg;
X{
X	switch (opt) {
X		case 'a':
X		    /* capfonts = 1; */
X		    break;
X
X		case 'f':			/* set default text font */
X		    texfontnames[0] = texfontnames[1] = optarg;
X		    break;
X
X		case 'l':			/* set line thickness */
X		    linethick = atoi(optarg);
X                    if (linethick < 1 || linethick > 12) {
X                      put_msg(Err_badarg, opt, "textyl");
X                      exit(1);
X                    }
X		    break;
X
X		case 'p':
X		case 's':
X		case 'm':
X		case 'L':
X		    break;
X
X	default:
X		put_msg(Err_badarg, opt, "textyl");
X		exit(1);
X		break;
X	}
X}
X
X#define			TOP	(10.5)	/* top of page is 10.5 inch */
X#define SCALE (65536.0*72.27)
Xstatic double		ppi;
Xstatic int		CONV = 0;
X#define measure 'S'
X
Xconvy(a)
Xdouble a;
X{
X   return (int)(((ury - a) * SCALE) / ppi);
X}
X
Xconvx(a)
Xdouble a; {
X  float f;
X  f = a * SCALE;
X  return (int)(f / ppi);
X}
X
Xvoid gentextyl_start(objects)
XF_compound	*objects;
X{
X
X	texfontsizes[0] = texfontsizes[1] = texfontsizes[font_size+1];
X	coord_system = objects->nwcorner.y;
X	ppi = objects->nwcorner.x;
X
X	if (coord_system == 2) CONV = 1;
X	/* Textyl start */
X	fprintf(tfp, "\\begintyl{%fsp}\n",ury/ppi*SCALE);
X}
X
Xvoid gentextyl_end()
X{
X  fprintf(tfp,"\\endtyl\n");
X}
X
X
Xstatic set_linewidth(w)
Xint	w;
X{
X/* Nop */
X}
X
Xvoid gentextyl_line(l)
XF_line	*l;
X{
X	F_point		*p, *q;
X
X	fprintf(tfp, "%%\n%% Fig POLYLINE object\n%%\n");
X
X	set_linewidth(l->thickness);
X	set_style(l->style, l->style_val);
X
X	p = l->points;
X	q = p->next;
X        
X
X	if (q == NULL) { /* A single point line */
X	    fprintf(tfp, "\\special{tyl line %c %d L %d %u %u; %u %u}\n", 
X               measure,linethick,line_style,
X			convx((double)p->x), convy((double)p->y), 
X                        convx((double)p->x), convy((double)p->y));
X	    return;
X	    }
X	if (l->back_arrow)
X	    draw_arrow_head((double)q->x, (double)q->y, (double)p->x,
X		(double)p->y, l->back_arrow->ht, l->back_arrow->wid);
X	set_style(l->style, l->style_val);
X
X	while (q->next != NULL) {
X
X	    putline(p->x, p->y, q->x, q->y);
X	    p = q;
X	    q = q->next;
X	    }
X
X	putline(p->x, p->y, q->x, q->y);
X	if (l->for_arrow)
X	    draw_arrow_head((double)p->x, (double)p->y, (double)q->x,
X		(double)q->y, l->for_arrow->ht, l->for_arrow->wid);
X
X	if (l->area_fill && (int)l->area_fill != DEFAULT)
X		fprintf(stderr, "Line area fill not implemented\n");
X	}
X
X/* 
X * set_style - issue style commands as appropriate
X */
Xstatic set_style(style, dash_len)
X     int style;
X     double dash_len;
X{
X  
X  switch (style) {
X  case SOLID_LINE:
X    line_style = 0;
X    break;
X    
X  case DASH_LINE:
X    line_style = 2;
X    break;
X    
X  case DOTTED_LINE:
X    line_style = 1;
X    break;
X  }
X}
X
X/*
X * putline
X */
Xstatic putline (start_x, start_y, end_x, end_y)
Xint	start_x, start_y, end_x, end_y;
X{
X
X   fprintf(tfp, "\\special{tyl line %c %d L %d %u %u; %u %u}\n", 
X        measure, linethick,line_style,
X	convx((double)start_x), convy((double)start_y), 
X        convx((double)end_x), convy((double)end_y));
X
X}
X
X
Xvoid gentextyl_spline(s)
XF_spline	*s;
X{
X
X	set_linewidth(s->thickness);
X	set_style(s->style, s->style_val);
X
X	if (int_spline(s))
X	    gentextyl_itp_spline(s);
X	else
X	    gentextyl_ctl_spline(s);
X
X	if (s->area_fill && (int)s->area_fill != DEFAULT)
X		fprintf(stderr, "Spline area fill not implemented\n");
X}
X
Xvoid gentextyl_ellipse(e)
XF_ellipse	*e;
X{
X   int sx, sy;
X   int radius;
X	fprintf(tfp, "%%\n%% Fig ELLIPSE\n%%\n");
X
X	set_linewidth(e->thickness);
X	set_style(e->style, e->style_val);
X
X	if (e->radiuses.x == e->radiuses.y) {
X          fprintf(tfp, "\\special{tyl arc %c %d L 0 %u @ %u,%u 0 360}\n",
X            measure,linethick,convx((double)e->radiuses.x),
X            convx((double)e->center.x),convy((double)e->center.y));
X        }
X	else {
X          if (e->radiuses.x > e->radiuses.y) {
X            sy = 100;
X            sx = ((float)e->radiuses.x/(float)e->radiuses.y) * 100.0;
X            radius = e->radiuses.y;
X          }
X          else {
X            sx = 100;
X            sy = ((float)e->radiuses.y/(float)e->radiuses.x) * 100.0;
X            radius = e->radiuses.x;            
X          }
X                fprintf(tfp, 
X                 "\\special{tyl arc %c T %u %u 0 0 0 %d L 0 %u @ %u,%u 0 360}\n",
X                  measure,sx,sy,linethick,convx((double)radius),
X            convx((double)e->center.x),convy((double)e->center.y));
X		if (e->area_fill && (int)e->area_fill != DEFAULT)
X			fprintf(stderr, "Ellipse area fill not implemented\n");
X		}
X	}
X
X#define			HT_OFFSET	(0.2 / 72.0)
X
Xvoid gentextyl_text(t)
XF_text	*t;
X{
X	double	x, y;
X	char *cp;
X
X        fprintf(tfp, "%%\n%% Fig TEXT object\n%%\n");
X
X	x = t->base_x;
X	y = t->base_y;
X
X	switch (t->type) {
X
X	    case T_LEFT_JUSTIFIED:
X	    case DEFAULT:
X		break;
X	    default:
X		fprintf(stderr, "Warning: Text incorrectly positioned\n");
X	        break;
X	    }
X
X        fprintf(tfp,"\\special{tyl label %c 1 %u %u \"%s\"}\n",
X          measure,convx(x),convy(y),t->cstring);
X
X}
X
Xvoid gentextyl_arc(a)
XF_arc	*a;
X{
X	double		x, y;
X	double		cx, cy, sx, sy, ex, ey;
X	double		dx1, dy1, dx2, dy2, r1, r2, th1, th2, theta;
X
X	set_linewidth(a->thickness);
X	set_style(a->style, a->style_val);
X
X	cx = a->center.x; cy = a->center.y;
X	sx = a->point[0].x; sy = a->point[0].y;
X	ex = a->point[2].x; ey = a->point[2].y;
X
X	if (a->for_arrow) {
X	    arc_tangent(cx, cy, ex, ey, !a->direction, &x, &y);
X	    draw_arrow_head(x, y, ex, ey,
X			a->for_arrow->ht, a->for_arrow->wid);
X	    }
X	if (a->back_arrow) {
X	    arc_tangent(cx, cy, sx, sy, a->direction, &x, &y);
X	    draw_arrow_head(x, y, sx, sy,
X			a->back_arrow->ht, a->back_arrow->wid);
X	    }
X
X
X	cy = ury - a->center.y;
X	sy = ury - a->point[0].y;
X	ey = ury - a->point[2].y;
X
X	dx1 = sx - cx;
X	dy1 = sy - cy;
X	dx2 = ex - cx;
X	dy2 = ey - cy;
X
X	cy = a->center.y;
X	sy = a->point[0].y;
X	ey = a->point[2].y;
X	    
X	rtop(dx1, dy1, &r1, &th1);
X	rtop(dx2, dy2, &r2, &th2);
X	theta = th2 - th1;
X	if (theta > 0) theta -= 2*M_PI;
X
X	set_linewidth(a->thickness);
X
X	if (a->direction) { /* Counterclockwise */
X              fprintf(tfp,"\\special{tyl arc %c %d L 0 %u @ %u,%u %d %d}\n",
X                measure,linethick,convx(r1),convx(cx),convy(cy),
X                (int)(180/M_PI * th1), (int)(180/M_PI * th2));
X	      }
X	else {
X              fprintf(tfp,"\\special{tyl arc %c %d L 0 %u @ %u,%u %d %d}\n",
X                measure,linethick,convx(r1),convx(cx),convy(cy),
X                (int)(180/M_PI * th2), (int)(180/M_PI * th1));
X	      }
X
X	if (a->area_fill && (int)a->area_fill != DEFAULT)
X		fprintf(stderr, "Arc area fill not implemented\n");
X	}
X
X
X
X/*
X * rtop - rectangular to polar conversion
X */
Xstatic rtop(x, y, r, th)
Xdouble x, y, *r, *th;
X{
X	*r = sqrt(x*x+y*y);
X	*th = acos(x/(*r));
X
X	if (y < 0) *th = 2*M_PI - *th;
X}
X
Xstatic arc_tangent(x1, y1, x2, y2, direction, x, y)
Xdouble	x1, y1, x2, y2, *x, *y;
Xint	direction;
X{
X	if (direction) { /* counter clockwise  */
X	    *x = x2 + (y2 - y1);
X	    *y = y2 - (x2 - x1);
X	    }
X	else {
X	    *x = x2 - (y2 - y1);
X	    *y = y2 + (x2 - x1);
X	    }
X	}
X
X/*	draw arrow heading from (x1, y1) to (x2, y2)	*/
X
Xstatic draw_arrow_head(x1, y1, x2, y2, arrowht, arrowwid)
Xdouble	x1, y1, x2, y2;
Xdouble  arrowht, arrowwid;
X{
X	double	x, y, xb, yb, dx, dy, l, sina, cosa;
X	double	xc, yc, xd, yd;
X	int style;
X	double dash;
X
X	dx = x2 - x1;  dy = y1 - y2;
X	l = sqrt(dx*dx+dy*dy);
X	if (l == 0) {
X	     return;
X	}
X	else {
X	     sina = dy / l;  cosa = dx / l;
X	}
X	xb = x2*cosa - y2*sina;
X	yb = x2*sina + y2*cosa;
X	x = xb - arrowht;
X	y = yb - arrowwid / 2;
X	xc = x*cosa + y*sina;
X	yc = -x*sina + y*cosa;
X	y = yb + arrowwid / 2;
X	xd = x*cosa + y*sina;
X	yd = -x*sina + y*cosa;
X
X        fprintf(tfp, "%%\n%% arrow head\n%%\n");
X
X	fprintf(tfp, "\\special{tyl line %c %d %u %u; %u %u}\n",measure,linethick,
X		convx(xc), convy(yc), convx(x2), convy(y2));
X	fprintf(tfp, "\\special{tyl line %c %d %u %u; %u %u}\n",measure,linethick,
X                convx(x2), convy(y2), convx(xd), convy(yd));
X
X	}
X
X#define THRESHOLD (10.0)
Xdouble last_x, last_y;
X
Xstatic quadratic_spline(a1, b1, a2, b2, a3, b3, a4, b4)
Xdouble	a1, b1, a2, b2, a3, b3, a4, b4;
X{
X	double	x1, y1, x4, y4;
X	double	xmid, ymid;
X
X	x1 = a1; y1 = b1;
X	x4 = a4; y4 = b4;
X	xmid = (a2 + a3) / 2;
X	ymid = (b2 + b3) / 2;
X	if (fabs(x1 - xmid) < THRESHOLD && fabs(y1 - ymid) < THRESHOLD) {
X	    fprintf(tfp, "\\special{tyl line %c %d %u %u; %u %u}\n", 
X              measure, linethick,convx(last_x),convy(last_y),
X              convx(xmid), convy(ymid));
X            last_x = xmid; last_y = ymid;
X	}
X
X	else {
X	    quadratic_spline(x1, y1, ((x1+a2)/2), ((y1+b2)/2),
X			((3*a2+a3)/4), ((3*b2+b3)/4), xmid, ymid);
X	    }
X
X	if (fabs(xmid - x4) < THRESHOLD && fabs(ymid - y4) < THRESHOLD) {
X	    fprintf(tfp, "\\special{tyl line %c %d %u %u; %u %u}\n", 
X              measure, linethick,convx(last_x),convy(last_y),convx(x4), convy(y4));
X            last_x = x4; last_y = y4;
X	}
X
X	else {
X	    quadratic_spline(xmid, ymid, ((a2+3*a3)/4), ((b2+3*b3)/4),
X			((a3+x4)/2), ((b3+y4)/2), x4, y4);
X	    }
X	}
X
Xstatic void gentextyl_ctl_spline(s)
XF_spline	*s;
X{
X	F_point	*p;
X	double	cx1, cy1, cx2, cy2, cx3, cy3, cx4, cy4;
X	double	x1, y1, x2, y2;
X
X    	fprintf(tfp, "%%\n%% Fig CONTROL PT SPLINE\n%%\n");
X
X	p = s->points;
X	x1 = p->x;  y1 = p->y;
X	p = p->next;
X	x2 = p->x;  y2 = p->y;
X	cx1 = (x1 + x2) / 2;      cy1 = (y1 + y2) / 2;
X	cx2 = (x1 + 3 * x2) / 4;  cy2 = (y1 + 3 * y2) / 4;
X
X	if (closed_spline(s)) {
X	    fprintf(tfp, "%% closed spline\n%%\n");
X            last_x = cx1; last_y = cy1;
X	    }
X	else {
X	    fprintf(tfp, "%% open spline\n%%\n");
X	    if (s->back_arrow)
X	        draw_arrow_head(cx1, cy1, x1, y1,
X			s->back_arrow->ht, s->back_arrow->wid);
X            fprintf(tfp, "\\special{tyl line %c %d %u %u;%u %u}\n",
X              measure,linethick,
X              convx(x1),convy(y1),convx(cx1),convy(cy1));
X            last_x = cx1; last_y = cy1;
X	    }
X
X	for (p = p->next; p != NULL; p = p->next) {
X	    x1 = x2;  y1 = y2;
X	    x2 = p->x;  y2 = p->y;
X	    cx3 = (3 * x1 + x2) / 4;  cy3 = (3 * y1 + y2) / 4;
X	    cx4 = (x1 + x2) / 2;      cy4 = (y1 + y2) / 2;
X	    quadratic_spline(cx1, cy1, cx2, cy2, cx3, cy3, cx4, cy4);
X	    cx1 = cx4;  cy1 = cy4;
X	    cx2 = (x1 + 3 * x2) / 4;  cy2 = (y1 + 3 * y2) / 4;
X	    }
X	x1 = x2;  y1 = y2;
X	p = s->points->next;
X	x2 = p->x;  y2 = p->y;
X	cx3 = (3 * x1 + x2) / 4;  cy3 = (3 * y1 + y2) / 4;
X	cx4 = (x1 + x2) / 2;      cy4 = (y1 + y2) / 2;
X	if (closed_spline(s)) {
X	    quadratic_spline(cx1, cy1, cx2, cy2, cx3, cy3, cx4, cy4);
X	    }
X	else {
X            fprintf(tfp,"\\special{tyl line %c %d %u %u;%u %u}\n",
X              measure,linethick,
X              convx(cx1),convy(cy1),convx(x1),convy(y1));
X	    if (s->for_arrow)
X	    	draw_arrow_head(cx1, cy1, x1, y1,
X			s->for_arrow->ht, s->for_arrow->wid);
X	    }
X
X	}
X
Xstatic void gentextyl_itp_spline(s)
XF_spline	*s;
X{
X  F_point		*p1, *p2;
X  F_control	*cp1, *cp2;
X  double		x1, x2, y1, y2;
X  
X  
X  p1 = s->points;
X  cp1 = s->controls;
X  x2 = p1->x; y2 = p1->y;
X  
X  if (s->back_arrow)
X    draw_arrow_head(cp1->rx, cp1->ry, x2, y2,
X		    s->back_arrow->ht, s->back_arrow->wid);
X  
X  last_x = x2; last_y = y2;
X  
X  fprintf(tfp, "%%\n%% Fig INTERPOLATED SPLINE\n%%\n");
X  for (p2 = p1->next, cp2 = s->controls->next; 
X       p2 != NULL; 
X       cp1 = cp2, p2 = p2->next, cp2 = cp2->next) {
X    x1 = x2; y1 = y2; x2 = p2->x; y2 = p2->y;
X    bezier_spline(x1,y1,cp1->rx,cp1->ry,
X		  cp2->lx,cp2->ly,x2,y2);
X  }
X  
X  if (s->for_arrow)
X    draw_arrow_head(cp1->lx, cp1->ly, x2, y2,
X		    s->for_arrow->ht, s->for_arrow->wid);
X}
X
Xstatic bezier_spline(a0, b0, a1, b1, a2, b2, a3, b3)
Xdouble	a0, b0, a1, b1, a2, b2, a3, b3;
X{
X  double	x0, y0, x3, y3;
X  double	sx1, sy1, sx2, sy2, tx, ty, tx1, ty1, tx2, ty2, xmid, ymid;
X  
X  x0 = a0; y0 = b0;
X  x3 = a3; y3 = b3;
X  if (fabs(x0 - x3) < THRESHOLD && fabs(y0 - y3) < THRESHOLD)  {
X    fprintf(tfp,"\\special{tyl line %c %d %u %u ; %u %u}\n",measure,linethick,
X	    convx(last_x),convy(last_y),convx(x3),convy(y3));
X    last_x = x3; last_y = y3; 
X  }
X  
X  else {
X    tx = (a1 + a2) / 2;		ty = (b1 + b2) / 2;
X    sx1 = (x0 + a1) / 2;	sy1 = (y0 + b1) / 2;
X    sx2 = (sx1 + tx) / 2;	sy2 = (sy1 + ty) / 2;
X    tx2 = (a2 + x3) / 2;	ty2 = (b2 + y3) / 2;
X    tx1 = (tx2 + tx) / 2;	ty1 = (ty2 + ty) / 2;
X    xmid = (sx2 + tx1) / 2;	ymid = (sy2 + ty1) / 2;
X    
X    bezier_spline(x0, y0, sx1, sy1, sx2, sy2, xmid, ymid);
X    bezier_spline(xmid, ymid, tx1, ty1, tx2, ty2, x3, y3);
X  }
X}
X
Xstruct driver dev_textyl = {
X     	gentextyl_option,
X	gentextyl_start,
X	gentextyl_arc,
X	gentextyl_ellipse,
X	gentextyl_line,
X	gentextyl_spline,
X	gentextyl_text,
X	gentextyl_end,
X	EXCLUDE_TEXT
X};
X
END_OF_FILE
if test 14413 -ne `wc -c <'fig2dev/dev/gentextyl.c'`; then
    echo shar: \"'fig2dev/dev/gentextyl.c'\" unpacked with wrong size!
fi
# end of 'fig2dev/dev/gentextyl.c'
fi
if test -f 'fig2dev/read.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fig2dev/read.c'\"
else
echo shar: Extracting \"'fig2dev/read.c'\" \(20800 characters\)
sed "s/^X//" >'fig2dev/read.c' <<'END_OF_FILE'
X/*
X * TransFig: Facility for Translating Fig code
X * Copyright (c) 1985 Supoj Sutantavibul
X * Copyright (c) 1991 Micah Beck
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation. The authors make no representations about the suitability 
X * of this software for any purpose.  It is provided "as is" without express 
X * or implied warranty.
X *
X * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
X * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
X * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X *
X */
X
X/* 
X *	FIG : Facility for Interactive Generation of figures
X *
X *	Copyright (c) 1985, 1988 by Supoj Sutanthavibul (supoj@sally.UTEXAS.EDU)
X *	January 1985.
X *	1st revision : August 1985.
X *	2nd revision : March 1988.
X *
X *	%W%	%G%
X*/
X#include <stdio.h>
X#include <ctype.h>
X#include <errno.h>
X#include "alloc.h"
X#include "object.h"
X
X#if defined(hpux) || defined(SYSV)
X#define bzero(s,n) memset((s),'\0',(n))
X#endif
X
Xextern int            errno;
X
Xextern F_arrow		*make_arrow();
Xextern char		*calloc();
Xextern double            floor(), ceil();
X
Xstatic F_ellipse	*read_ellipseobject();
Xstatic F_line		*read_lineobject();
Xstatic F_text		*read_textobject();
Xstatic F_spline		*read_splineobject();
Xstatic F_arc		*read_arcobject();
Xstatic F_compound	*read_compoundobject();
X
X#define			FILL_CONVERT(f) \
X				((v2_flag || (f) < WHITE_FILL) \
X					? (f) : 21 - ((f)-1)*5)
X
X#define			BUF_SIZE		1024
X
Xchar			buf[BUF_SIZE];
Xint			line_no = 0;
Xint			num_object;
Xint			v2_flag;	/* Protocol V2.0 or V2.1 */
Xint			v21_flag;	/* Protocol V2.1 */
X
Xread_fail_message(file, err)
Xchar	*file;
Xint	err;
X{
X	extern char	*sys_errlist[];
X
X	if (err == 0)		/* Successful read */
X	    return;
X#if !defined(hpux) && !defined(SYSV)
X	else if (err == ENAMETOOLONG)
X	    put_msg("File name \"%s\" is too long", file);
X#endif
X	else if (err == ENOENT)
X	    put_msg("File \"%s\" does not exist", file);
X	else if (err == ENOTDIR)
X	    put_msg("A name in the path \"%s\" is not a directory", file);
X	else if (err == EACCES)
X	    put_msg("Read access to file \"%s\" is blocked", file);
X	else if (err == EISDIR)
X	    put_msg("File \"%s\" is a directory", file);
X	else if (err == -2) {
X	    put_msg("File \"%s\" is empty", file);
X	    }
X	else if (err == -1) {
X	    /* Format error; relevant error message is already delivered */
X	    }
X	else
X	    put_msg("File \"%s\" is not accessable; %s", file, sys_errlist[err]);
X	}
X
X/**********************************************************
XRead_fig returns :
X
X     0 : successful read.
X    -1 : File is in incorrect format
X    -2 : File is empty
Xerr_no : if file can not be read for various reasons
X
XThe resolution (ppi) and the cooridnate system (coord_sys) are
Xstored in obj->nwcorner.x and obj->nwcorner.x respectively.
X**********************************************************/
X
Xread_fig(file_name, obj)
Xchar		*file_name;
XF_compound	*obj;
X{
X	FILE		*fp;
X
X	if ((fp = fopen(file_name, "r")) == NULL)
X	    return(errno);
X	else
X	    return(readfp_fig(fp, obj));
X	}
X
Xreadfp_fig(fp, obj)
XFILE	*fp;
XF_compound	*obj;
X{
X	char		c;
X	int		status;
X
X	num_object = 0;
X	c = fgetc(fp);
X	if (feof(fp)) return(-2);
X	ungetc(c, fp);
X	bzero((char*)obj, COMOBJ_SIZE);
X	if (c == '#')
X	    status = read_objects(fp, obj);
X	else
X	    status = read_1_3_objects(fp, obj);
X	(void)fclose(fp);
X	return(status);
X	}
X	
Xint
Xread_objects(fp, obj)
XFILE		*fp;
XF_compound	*obj;
X{
X	F_ellipse	*e, *le = NULL;
X	F_line		*l, *ll = NULL;
X	F_text		*t, *lt = NULL;
X	F_spline	*s, *ls = NULL;
X	F_arc		*a, *la = NULL;
X	F_compound	*c, *lc = NULL;
X	int		object, ppi, coord_sys;
X
X	bzero((char*)obj, COMOBJ_SIZE);
X	(void)fgets(buf, BUF_SIZE, fp);	/* get the version line */
X
X	v2_flag = (!strncmp(buf, "#FIG 2", 6));
X	v21_flag = (!strncmp(buf, "#FIG 2.1", 8));
X
X	line_no++;
X	if (get_line(fp) < 0) {
X	    put_msg("File is truncated");
X	    return(-1);
X	    }
X	if (2 != sscanf(buf,"%d%d\n", &ppi, &coord_sys)) {
X	    put_msg("Incomplete data at line %d", line_no);
X	    return(-1);
X	    }
X
X	obj->nwcorner.x = ppi;
X	obj->nwcorner.y = coord_sys;
X	while (get_line(fp) > 0) {
X	    if (1 != sscanf(buf, "%d", &object)) {
X		put_msg("Incorrect format at line %d", line_no);
X		return(-1);
X		}
X	    switch (object) {
X		case O_POLYLINE :
X		    if ((l = read_lineobject(fp)) == NULL) return(-1);
X		    if (ll)
X			ll = (ll->next = l);
X		    else 
X			ll = obj->lines = l;
X		    num_object++;
X		    break;
X		case O_SPLINE :
X		    if ((s = read_splineobject(fp)) == NULL) return(-1);
X		    if (ls)
X			ls = (ls->next = s);
X		    else 
X			ls = obj->splines = s;
X		    num_object++;
X		    break;
X		case O_ELLIPSE :
X		    if ((e = read_ellipseobject()) == NULL) return(-1);
X		    if (le)
X			le = (le->next = e);
X		    else 
X			le = obj->ellipses = e;
X		    num_object++;
X		    break;
X		case O_ARC :
X		    if ((a = read_arcobject(fp)) == NULL) return(-1);
X		    if (la)
X			la = (la->next = a);
X		    else 
X			la = obj->arcs = a;
X		    num_object++;
X		    break;
X		case O_TEXT :
X		    if ((t = read_textobject(fp)) == NULL) return(-1);
X		    if (lt)
X			lt = (lt->next = t);
X		    else 
X			lt = obj->texts = t;
X		    num_object++;
X		    break;
X		case O_COMPOUND :
X		    if ((c = read_compoundobject(fp)) == NULL) return(-1);
X		    if (lc)
X			lc = (lc->next = c);
X		    else 
X			lc = obj->compounds = c;
X		    num_object++;
X		    break;
X		default :
X		    put_msg("Incorrect object code at line %d", line_no);
X		    return(-1);
X		} /*  switch */
X	    } /*  while */
X	if (feof(fp))
X	    return(0);
X	else
X	    return(errno);
X	} /*  read_objects */
X
Xstatic F_arc *
Xread_arcobject(fp)
XFILE	*fp;
X{
X	F_arc	*a;
X	int	n, fa, ba;
X	int	type, style;
X	double	thickness, wid, ht;
X
X	if (NULL == (Arc_malloc(a))) {
X	    put_msg(Err_mem);
X	    return(NULL);
X	    }
X	a->pen = 0;
X	a->area_fill = 0;
X	a->for_arrow = NULL;
X	a->back_arrow = NULL;
X	a->next = NULL;
X	n = sscanf(buf, "%*d%d%d%d%d%d%d%d%lf%d%d%d%lf%lf%d%d%d%d%d%d\n",
X		&a->type, &a->style, &a->thickness, 
X		&a->color, &a->depth, &a->pen, &a->area_fill, 
X		&a->style_val, &a->direction, &fa, &ba,
X		&a->center.x, &a->center.y, 
X		&a->point[0].x, &a->point[0].y, 
X		&a->point[1].x, &a->point[1].y, 
X		&a->point[2].x, &a->point[2].y);
X	if (n != 19) {
X	    put_msg(Err_incomp, "arc", line_no);
X	    free((char*)a);
X	    return(NULL);
X	    }
X	a->area_fill = FILL_CONVERT(a->area_fill);
X	skip_comment(fp);
X	if (fa) {
X	    line_no++;
X	    if (5 != fscanf(fp, "%d%d%lf%lf%lf", &type, &style, &thickness, &wid, &ht)) {
X		fprintf(stderr, Err_incomp, "arc", line_no);
X		return(NULL);
X		}
X	    skip_line(fp);
X	    a->for_arrow = make_arrow(type, style, thickness, wid, ht);
X	    skip_comment(fp);
X	    }
X	skip_comment(fp);
X	if (ba) {
X	    line_no++;
X	    if (5 != fscanf(fp, "%d%d%lf%lf%lf", &type, &style, &thickness, &wid, &ht)) {
X		fprintf(stderr, Err_incomp, "arc", line_no);
X		return(NULL);
X		}
X	    skip_line(fp);
X	    a->back_arrow = make_arrow(type, style, thickness, wid, ht);
X	    }
X	return(a);
X	}
X
Xstatic F_compound *
Xread_compoundobject(fp)
XFILE	*fp;
X{
X	F_arc		*a, *la = NULL;
X	F_ellipse	*e, *le = NULL;
X	F_line		*l, *ll = NULL;
X	F_spline	*s, *ls = NULL;
X	F_text		*t, *lt = NULL;
X	F_compound	*com, *c, *lc = NULL;
X	int		n, object;
X
X	Compound_malloc(com);
X	com->arcs = NULL;
X	com->ellipses = NULL;
X	com->lines = NULL;
X	com->splines = NULL;
X	com->texts = NULL;
X	com->compounds = NULL;
X	com->next = NULL;
X	n = sscanf(buf, "%*d%d%d%d%d\n", &com->nwcorner.x, &com->nwcorner.y,
X		&com->secorner.x, &com->secorner.y);
X	if (4 != n) {
X	    put_msg(Err_incomp, "compound", line_no);
X	    free((char*)com);
X	    return(NULL);
X	    }
X	while (get_line(fp) > 0) {
X	    if (1 != sscanf(buf, "%d", &object)) {
X		put_msg(Err_incomp, "compound", line_no);
X		free_compound(&com);
X		return(NULL);
X		}
X	    switch (object) {
X		case O_POLYLINE :
X		    if ((l = read_lineobject(fp)) == NULL) { 
X			free_line(&l);
X			return(NULL);
X			}
X		    if (ll)
X			ll = (ll->next = l);
X		    else 
X			ll = com->lines = l;
X		    break;
X		case O_SPLINE :
X		    if ((s = read_splineobject(fp)) == NULL) { 
X			free_spline(&s);
X			return(NULL);
X			}
X		    if (ls)
X			ls = (ls->next = s);
X		    else 
X			ls = com->splines = s;
X		    break;
X		case O_ELLIPSE :
X		    if ((e = read_ellipseobject()) == NULL) { 
X			free_ellipse(&e);
X			return(NULL);
X			}
X		    if (le)
X			le = (le->next = e);
X		    else 
X			le = com->ellipses = e;
X		    break;
X		case O_ARC :
X		    if ((a = read_arcobject(fp)) == NULL) { 
X			free_arc(&a);
X			return(NULL);
X			}
X		    if (la)
X			la = (la->next = a);
X		    else 
X			la = com->arcs = a;
X		    break;
X		case O_TEXT :
X		    if ((t = read_textobject(fp)) == NULL) { 
X			free_text(&t);
X			return(NULL);
X			}
X		    if (lt)
X			lt = (lt->next = t);
X		    else 
X			lt = com->texts = t;
X		    break;
X		case O_COMPOUND :
X		    if ((c = read_compoundobject(fp)) == NULL) { 
X			free_compound(&c);
X			return(NULL);
X			}
X		    if (lc)
X			lc = (lc->next = c);
X		    else 
X			lc = com->compounds = c;
X		    break;
X		case O_END_COMPOUND :
X		    return(com);
X		default :
X		    put_msg("Wrong object code at line %d", line_no);
X		    return(NULL);
X		} /*  switch */
X	    }
X	if (feof(fp))
X	    return(com);
X	else
X	    return(NULL);
X	}
X
Xstatic F_ellipse *
Xread_ellipseobject()
X{
X	F_ellipse	*e;
X	int		n;
X
X	Ellipse_malloc(e);
X	e->area_fill = 0;
X	e->pen = 0;
X	e->next = NULL;
X	n = sscanf(buf, "%*d%d%d%d%d%d%d%d%lf%d%lf%d%d%d%d%d%d%d%d\n",
X		&e->type, &e->style, &e->thickness,
X		&e->color, &e->depth, &e->pen, &e->area_fill,
X		&e->style_val, &e->direction, &e->angle,
X		&e->center.x, &e->center.y, 
X		&e->radiuses.x, &e->radiuses.y, 
X		&e->start.x, &e->start.y, 
X		&e->end.x, &e->end.y);
X	if (n != 18) {
X	    put_msg(Err_incomp, "ellipse", line_no);
X	    free((char*)e);
X	    return(NULL);
X	    }
X	e->area_fill = FILL_CONVERT(e->area_fill);
X	return(e);
X	}
X
Xstatic F_line *
Xread_lineobject(fp)
XFILE	*fp;
X{
X	F_line	*l;
X	F_point	*p, *q;
X	int	n, x, y, fa, ba;
X	int	type, style, radius_flag;
X	double	thickness, wid, ht;
X
X	Line_malloc(l);
X	l->points = NULL;
X	l->pen = 0;
X	l->area_fill = 0;
X	l->for_arrow = NULL;
X	l->back_arrow = NULL;
X	l->next = NULL;
X
X	sscanf(buf,"%*d%d",&l->type);	/* get the line type */
X
X	radius_flag = v21_flag || (v2_flag && l->type == T_ARC_BOX);
X	if (radius_flag)
X	    {
X	    n = sscanf(buf, "%*d%d%d%d%d%d%d%d%lf%d%d%d",
X	    &l->type, &l->style, &l->thickness, &l->color,
X	    &l->depth, &l->pen, &l->area_fill, &l->style_val, &l->radius, &fa, &ba);
X	    }
X	/* old format uses pen for radius of arc-box corners */
X	else
X	    {
X	    n = sscanf(buf, "%*d%d%d%d%d%d%d%d%lf%d%d",
X		&l->type, &l->style, &l->thickness, &l->color,
X		&l->depth, &l->pen, &l->area_fill, &l->style_val, &fa, &ba);
X	    if (l->type == T_ARC_BOX)
X		{
X		l->radius = (int) l->pen;
X		l->pen = 0;
X		}
X	    else
X		l->radius = 0;
X	    }
X	if ((!radius_flag && n!=10) || (radius_flag && n!=11)) {
X	    put_msg(Err_incomp, "line", line_no);
X	    free((char*)l);
X	    return(NULL);
X	    }
X	l->area_fill = FILL_CONVERT(l->area_fill);
X	skip_comment(fp);
X	if (fa) {
X	    line_no++;
X	    if (5 != fscanf(fp, "%d%d%lf%lf%lf", &type, &style, &thickness, &wid, &ht)) {
X		fprintf(stderr, Err_incomp, "line", line_no);
X		return(NULL);
X		}
X	    skip_line(fp);
X	    l->for_arrow = make_arrow(type, style, thickness, wid, ht);
X	    skip_comment(fp);
X	    }
X	if (ba) {
X	    line_no++;
X	    if (5 != fscanf(fp, "%d%d%lf%lf%lf", &type, &style, &thickness, &wid, &ht)) {
X		fprintf(stderr, Err_incomp, "line", line_no);
X		return(NULL);
X		}
X	    skip_line(fp);
X	    l->back_arrow = make_arrow(type, style, thickness, wid, ht);
X	    skip_comment(fp);
X	    }
X    	if (l->type == T_EPS_BOX) {
X		line_no++;
X		Eps_malloc(l->eps);
X		if (l->eps  == NULL) {
X		    free((char *) l);
X		    return (NULL);
X		}
X		if (2 != fscanf(fp, "%d %s", &l->eps->flipped, l->eps->file)) {
X	    		put_msg(Err_incomp,
X				"Encapsulated Postscript", line_no);
X	    		fprintf(stderr, Err_incomp,
X				"Encapsulated Postscript", line_no);
X	    	return (NULL);
X		}
X		read_epsf(l->eps);
X    	} else
X		l->eps = NULL;
X
X	if (NULL == (l->points = Point_malloc(p))) {
X	    put_msg(Err_mem);
X	    return(NULL);
X	    }
X	p->next = NULL;
X	if (fscanf(fp, "%d%d", &p->x, &p->y) != 2) {
X	    put_msg(Err_incomp, "line", line_no);
X	    free_linestorage(l);
X	    return(NULL);
X	    }
X	for (;;) {
X	    if (fscanf(fp, "%d%d", &x, &y) != 2) {
X		put_msg(Err_incomp, "line", line_no);
X		free_linestorage(l);
X		return(NULL);
X		}
X	    if (x == 9999) break;
X	    if (NULL == (Point_malloc(q))) {
X		put_msg(Err_mem);
X		free_linestorage(l);
X		return(NULL);
X		}
X	    q->x = x;
X	    q->y = y;
X	    q->next = NULL;
X	    p->next = q;
X	    p = q;
X	    }
X	skip_line(fp);
X	return(l);
X	}
X
Xstatic F_spline *
Xread_splineobject(fp)
XFILE	*fp;
X{
X	F_spline	*s;
X	F_point		*p, *q;
X	F_control	*cp, *cq;
X	int		c, n, x, y, fa, ba;
X	int		type, style;
X	double		thickness, wid, ht;
X	double		lx, ly, rx, ry;
X
X	Spline_malloc(s);
X	s->points = NULL;
X	s->controls = NULL;
X	s->pen = 0;
X	s->area_fill = 0;
X	s->for_arrow = NULL;
X	s->back_arrow = NULL;
X	s->next = NULL;
X
X	n = sscanf(buf, "%*d%d%d%d%d%d%d%d%lf%d%d",
X	    	&s->type, &s->style, &s->thickness, &s->color,
X		&s->depth, &s->pen, &s->area_fill, &s->style_val, &fa, &ba);
X	if (n != 10) {
X	    put_msg(Err_incomp, "spline", line_no);
X	    free((char*)s);
X	    return(NULL);
X	    }
X	s->area_fill = FILL_CONVERT(s->area_fill);
X	skip_comment(fp);
X	if (fa) {
X	    line_no++;
X	    if (5 != fscanf(fp, "%d%d%lf%lf%lf", &type, &style, &thickness, &wid, &ht)) {
X		fprintf(stderr, Err_incomp, "spline", line_no);
X		return(NULL);
X		}
X	    skip_line(fp);
X	    s->for_arrow = make_arrow(type, style, thickness, wid, ht);
X	    skip_comment(fp);
X	    }
X	if (ba) {
X	    line_no++;
X	    if (5 != fscanf(fp, "%d%d%lf%lf%lf", &type, &style, &thickness, &wid, &ht)) {
X		fprintf(stderr, Err_incomp, "spline", line_no);
X		return(NULL);
X		}
X	    skip_line(fp);
X	    s->back_arrow = make_arrow(type, style, thickness, wid, ht);
X	    skip_comment(fp);
X	    }
X
X	/* Read points */
X	if ((n = fscanf(fp, "%d%d", &x, &y)) != 2) {
X	    put_msg(Err_incomp, "spline", line_no);
X	    free_splinestorage(s);
X	    return(NULL);
X	    };
X	if (NULL == (s->points = Point_malloc(p))) {
X	    put_msg(Err_mem);
X	    free_splinestorage(s);
X	    return(NULL);
X	    }
X	p->x = x; p->y = y;
X	for (c = 1;;) {
X	    if (fscanf(fp, "%d%d", &x, &y) != 2) {
X		put_msg(Err_incomp, "spline", line_no);
X		p->next = NULL;
X		free_splinestorage(s);
X		return(NULL);
X		};
X	    if (x == 9999) break;
X	    if (NULL == (Point_malloc(q))) {
X		put_msg(Err_mem);
X		free_splinestorage(s);
X		return(NULL);
X		}
X	    q->x = x;
X	    q->y = y;
X	    p->next = q;
X	    p = q;
X	    c++;
X	    }
X	p->next = NULL;
X	skip_line(fp);
X
X	if (normal_spline(s)) return(s);
X
X	skip_comment(fp);
X	/* Read controls */
X	if ((n = fscanf(fp, "%lf%lf%lf%lf", &lx, &ly, &rx, &ry)) != 4) {
X	    put_msg(Err_incomp, "spline", line_no);
X	    free_splinestorage(s);
X	    return(NULL);
X	    };
X	if (NULL == (s->controls = Control_malloc(cp))) {
X	    put_msg(Err_mem);
X	    free_splinestorage(s);
X	    return(NULL);
X	    }
X	cp->lx = lx; cp->ly = ly;
X	cp->rx = rx; cp->ry = ry;
X	while (--c) {
X	    if (fscanf(fp, "%lf%lf%lf%lf", &lx, &ly, &rx, &ry) != 4) {
X		put_msg(Err_incomp, "spline", line_no);
X		cp->next = NULL;
X		free_splinestorage(s);
X		return(NULL);
X		};
X	    if (NULL == (Control_malloc(cq))) {
X		put_msg(Err_mem);
X		cp->next = NULL;
X		free_splinestorage(s);
X		return(NULL);
X		}
X	    cq->lx = lx; cq->ly = ly;
X	    cq->rx = rx; cq->ry = ry;
X	    cp->next = cq;
X	    cp = cq;
X	    }
X	cp->next = NULL;
X
X	skip_line(fp);
X	return(s);
X	}
X
Xstatic F_text *
Xread_textobject(fp)
XFILE	*fp;
X{
X	F_text	*t;
X	int	n, ignore = 0;
X	char	s[BUF_SIZE], s_temp[BUF_SIZE], junk[2];
X
X	Text_malloc(t);
X	t->font = 0;
X	t->size = 0.0;
X	t->next = NULL;
X	/* The text object is terminated by a CONTROL-A, so we read
X	   everything up to the CONTROL-A and then read that character.
X	   If we do not find the CONTROL-A on this line then this must
X	   be a multi-line text object and we will have to read more. */
X	n = sscanf(buf,"%*d%d%d%lf%d%d%d%lf%d%lf%lf%d%d%[^\1]%[\1]",
X		&t->type, &t->font, &t->size, &t->pen,
X		&t->color, &t->depth, &t->angle,
X		&t->flags, &t->height, &t->length, 
X		&t->base_x, &t->base_y, s, junk);
X	if ((n != 14) && (n != 13)) {
X	  put_msg(Err_incomp, "text", line_no);
X	  free((char*)t);
X/* 	  return(NULL); */
X	}
X	if (n == 13) {
X	  /* Read in the remainder of the text object. */
X	  do {
X	    fgets(buf, BUF_SIZE, fp);
X	    line_no++;  /* As is done in get_line */
X	    n = sscanf(buf,"%[^\1]%[\1]", s_temp, junk);
X	    /* Safety check */
X	    if (strlen(s)+1 + strlen(s_temp)+1 > BUF_SIZE) {
X	      /* Too many characters.  Ignore the rest. */
X	      ignore = 1;
X	    }
X	    if (!ignore)
X	      strcat(s, s_temp);
X	  } while (n == 1);
X	}
X	if (strlen(s) == 0) (void)strcpy(s, " ");
X	t->cstring = (char*)calloc((unsigned)(strlen(s)), sizeof(char));
X	if (NULL == t->cstring) {
X	    put_msg(Err_mem);
X	    free((char*)t);
X	    return(NULL);
X	    }
X	(void)strcpy(t->cstring, s+1);
X
X	if (!v21_flag && (t->font == 0 || t->font == DEFAULT))
X		t->flags = ((t->flags != DEFAULT) ? t->flags : 0)
X				| SPECIAL_TEXT;
X
X	if (v2_flag && !v21_flag && !special_text(t)) 
X		t->flags = ((t->flags != DEFAULT) ? t->flags : 0)
X				| PSFONT_TEXT;
X
X	return(t);
X      }
X
Xget_line(fp)
XFILE	*fp;
X{
X	while (1) {
X	    if (NULL == fgets(buf, BUF_SIZE, fp)) {
X		return(-1);
X		}
X	    line_no++;
X	    if (*buf != '\n' && *buf != '#') return(1);
X			/* Skip empty and comment lines */
X	    }
X	}
X
Xskip_comment(fp)
XFILE	*fp;
X{
X	char c;
X
X	while ((c = fgetc(fp)) == '#') skip_line(fp);
X	if (c != '#') ungetc(c, fp);
X	}
X
Xskip_line(fp)
XFILE	*fp;
X{
X	while (fgetc(fp) != '\n') {
X	    if (feof(fp)) return;
X	    }
X	}
X
Xread_epsf(eps)
X    F_eps          *eps;
X{
X    int             nbitmap;
X    int             bitmapz;
X    char           *cp;
X    unsigned char  *mp;
X    int             n;
X    int             flag;
X    char            buf[300];
X    int             llx, lly, urx, ury;
X    FILE           *epsf;
X    register unsigned char *last;
X    double          fllx, flly, furx, fury;
X
X    epsf = fopen(eps->file, "r");
X    if (epsf == NULL) {
X	put_msg("Cannot open file: %s", eps->file);
X	return 0;
X    }
X    while (fgets(buf, 300, epsf) != NULL) {
X	lower(buf);
X	if (!strncmp(buf, "%%boundingbox", 13)) {
X	    if (sscanf(buf, "%%%%boundingbox: %lf %lf %lf %lf",
X		       &fllx, &flly, &furx, &fury) < 4) {
X		put_msg("Bad EPS bitmap file: %s", eps->file);
X		fclose(epsf);
X		return 0;
X	    }
X          llx= floor(fllx);
X          lly= floor(flly);
X          urx= ceil(furx);
X          ury= ceil(fury);
X	    break;
X	}
X    }
X
X    eps->hw_ratio = (float) (ury - lly) / (float) (urx - llx);
X
X    eps->bitmap = NULL;
X    eps->bit_size.x = 0;
X    eps->bit_size.y = 0;
X
X    eps->pix_rotation = 0;
X    eps->pix_width = 0;
X    eps->pix_height = 0;
X
X    if (ury - lly <= 0 || urx - llx <= 0) {
X	put_msg("Bad values in EPS bitmap bounding box");
X    }
X    bitmapz = 0;
X
X    /* look for a preview bitmap */
X    while (fgets(buf, 300, epsf) != NULL) {
X	lower(buf);
X	if (!strncmp(buf, "%%beginpreview", 14)) {
X	    sscanf(buf, "%%%%beginpreview: %d %d %d",
X		   &eps->bit_size.x, &eps->bit_size.y, &bitmapz);
X	    break;
X	}
X    }
X
X    if (eps->bit_size.x > 0 && eps->bit_size.y > 0 && bitmapz == 1) {
X	nbitmap = (eps->bit_size.x + 7) / 8 * eps->bit_size.y;
X	eps->bitmap = (unsigned char *) malloc(nbitmap);
X	if (eps->bitmap == NULL)
X	    fprintf(stderr, "could not allocate %d bytes of memory\n", nbitmap);
X    }
X    /* read for a preview bitmap */
X    if (eps->bitmap != NULL) {
X	mp = eps->bitmap;
X	bzero(mp, nbitmap);	/* init bitmap to zero */
X	last = eps->bitmap + nbitmap;
X	flag = 1;
X	while (fgets(buf, 300, epsf) != NULL && mp < last) {
X	    lower(buf);
X	    if (!strncmp(buf, "%%endpreview", 12) ||
X		!strncmp(buf, "%%endimage", 10))
X		break;
X	    cp = buf;
X	    if (*cp != '%')
X		break;
X	    cp++;
X	    while (*cp != '\0') {
X		if (isxdigit(*cp)) {
X		    n = hex(*cp);
X		    if (flag) {
X			flag = 0;
X			*mp = n << 4;
X		    } else {
X			flag = 1;
X			*mp = *mp + n;
X			mp++;
X			if (mp >= last)
X			    break;
X		    }
X		}
X		cp++;
X	    }
X	}
X    }
X    fclose(epsf);
X    return 1;
X}
X
Xint
Xhex(c)
X    char            c;
X{
X    if (isdigit(c))
X	return (c - 48);
X    else
X	return (c - 87);
X}
X
Xlower(buf)
X    char           *buf;
X{
X    while (*buf) {
X	if (isupper(*buf))
X	    *buf = (char) tolower(*buf);
X	buf++;
X    }
X}
END_OF_FILE
if test 20800 -ne `wc -c <'fig2dev/read.c'`; then
    echo shar: \"'fig2dev/read.c'\" unpacked with wrong size!
fi
# end of 'fig2dev/read.c'
fi
echo shar: End of archive 4 \(of 7\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
