Newsgroups: comp.sources.unix
From: envbvs@epb12.lbl.gov (Brian V. Smith)
Subject: v27i056: transfig-2.1.8 - a set of tools for creating TeX documents with graphics, Part02/07
References: <1.749903574.10622@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: envbvs@epb12.lbl.gov (Brian V. Smith)
Posting-Number: Volume 27, Issue 56
Archive-Name: transfig-2.1.8/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 7)."
# Contents:  doc/tpic.spec fig2dev/dev/Makefile fig2dev/dev/genpstex.c
#   fig2dev/dev/tpicfonts.h fig2dev/fig2dev.c fig2dev/getopt.c
#   fig2dev/latex_line.c fig2dev/object.h fig2dev/psfonts.c
#   transfig/mkfile.c transfig/transfig.c
# Wrapped by envbvs@epb12.lbl.gov.lbl.gov on Fri Oct  1 14:55:45 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'doc/tpic.spec' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tpic.spec'\"
else
echo shar: Extracting \"'doc/tpic.spec'\" \(8799 characters\)
sed "s/^X//" >'doc/tpic.spec' <<'END_OF_FILE'
X\section{Output Specification}
X 
XThis section defines the output language which is generated by
X\tpic/.  It is intended only for use by writers of
X{\sc dvi} device drivers.  The first lines of output will
Xexecute a \tcom{newbox} command to define \tcom{graph} if it
Xhas not already been defined.  Each picture is enclosed in a \tcom{vtop}
Xwhich is assigned to \tcom{graph}.  The width and height of this box are
Xthe size of the picture as known to \tpic/ (text doesn't count because
X\tpic/ can't know how wide it may be).  Inside this box are a
Xsequence of \tcom{special} commands which define all the graphics,
Xalong with \tcom{hbox} commands setting the text left, right, or center
Xof a given point.
X 
XEach graphical element is placed relative to \TeX's idea of the location
Xof this \tcom{special} on the page.  Each \tcom{special} is set at the
Xtop left corner of the \tcom{graph} box.  This point is considered the
Xorigin of the graph.  The $x$ axis is positive to the right, and the $y$
Xaxis is positive moving down the page.  Thus the coordinates in the
Xgraphics commands are in terms of a virtual page with axes oriented the
Xsame as on many printers and workstation screens, like this:
X 
X.PS
X"0,0" at (0,0) above
Xarrow from (0,0) to (0.5,0)
X"\ $+x$" at (0.5,0) ljust
Xarrow from (0,0) to (0,-0.5)
X"$+y$" at end of last arrow below
X.PE
X\centerline{\box\graph}
X 
XAngles are measured in the conventional way, from $+x$ towards $+y$.
XUnfortunately, that reverses the meaning of "counterclockwise" from
Xwhat you see in the output.  Angle measurements are in radians, from
X0 to $2\pi$.  A complete circle or ellipse will have
X$\hbox{\it start angle}=0$ and $\hbox{\it end angle} \ge 2\pi$.
XThus, each distance (expressed in milli-inches) will be a positive number,
Xsince the box encloses all of the graphical elements.
X 
XThe possible \tcom{special} commands which must be implemented are
Xas follows.  All numbers which represent distances
Xare integers except where noted.  Angles are always measured in radians,
Xand they are measured in the conventional way from $+x$ towards $+y$.
XNormally, this would be ``counterclockwise''.
XUnfortunately, since the $y$ axis points down
Xinstead of up, this turns out to be backwards.
XThis is especially confusing because in the input language, $+y$
Xpoint upwards.  Device driver writers should beware of this point.
XIt is best to do all arithmetic in the coordinates of \tpic/'s output,
Xthen convert the resulting endpoints to the device's coordinates
Xfor printing; this should produce correct results in all cases.
X 
X\begin{description}
X\item[pn $s$]           Sets the pen size to $s$ milli-inches.
X\item[pa $x$ $y$]       Add point $(x,y)$ to a ``path'' which is
X                        being stored in the {\sc dvi} interpreter.
X                        The values of $x$ and $y$ are in milli-inches.
X\item[fp]               Flush (i.e., print using the current pen size)
X                        a previously defined path.  The number of path
X                        elements is reset to zero.  If shading has been
X                        specified, and if the path is closed, then the
X                        enclosed area should be shaded.  Currently,
X                        \tpic/ can only specify closed regions which are
X                        rectangles using the {\tt pa} command, and
X                        circles/ellipses are specified with the {\tt ar}
X                        command; however, device driver writers should
X                        not rely on this restriction.  Someday, \tpic/
X                        may be able to specify arbitrary closed areas
X                        using {\tt pa} commands.  Currently, the only
X                        example of this is the shading of arrowheads,
X                        which are triangular.
X\item[ip]               This is the same as {\tt fp} except that the
X                        path is not actually drawn.  Shading of the defined
X                        region is performed if it has been specified.
X\item[da $f$]           This is the same as {\tt fp} except that the line
X                        is drawn as a dashed line with $f$ inches per dash
X                        ($f$ is a real number).
X\item[dt $f$]           This is the same as {\tt da} except that a dotted
X                        line is drawn, with $f$ inches between each
X                        dot ($f$ is a real number).
X\item[sp $d$]           This is the same as {\tt fp} except that a spline
X                        is drawn through the points.  The spline is guaranteed
X                        to go through only the first and last points,
X                        depending on the relative positions of any
X                        intermediate points.  The argument $d$ is an
X                        optional real value.  If $d=0$ or the argument
X                        is omitted,
X                        the spline is drawn normally, as a solid line.
X                        If $d>0$, it is dashed with $d$ as the dashwid, else
X                        if $d<0$, the spline is dotted with $-d$ as the dotwid.
X\item[ar $x$ $y$ $r_x$ $r_y$ $s$ $e$]
X                        Draw an arc with center at $(x,y)$, from
X                        starting angle $s$ to ending angle $e$.
X                        If it's a complete circle or ellipse, then
X                        $r_x$ and $r_y$ determine the $x$ and $y$ radii,
X                        respectively.  Otherwise, $r_x=r_y$ will hold,
X                        and an arc from $s$ to $e$ should be drawn.
X\item[ia $x$ $y$ $r_x$ $r_y$ $s$ $e$] The {\tt ia} command is to {\tt ar} what
X                        {\tt ip} is to {\tt fp}.
X\end{description}
X 
XThe following command is optional in {\sc dvi} driver implementations
Xof \tpic/.  Drivers which do not implement it should silently ignore it.
X 
X\begin{description}
X\item[sh $s$]           Shade the interior of the next closed figure defined
X                        with three or more {\tt pa} commands followed
X                        by a {\tt fp} or {\tt ip} command, or by an
X                        {\tt ar} or {\tt ia} command.  The value $s$ is
X                        a floating point number from 0 to 1.  Zero implies
X                        a completely white interior (including erasing
X                        anything underneath), while 1 implies completely
X                        black.  A value of 0.5 is a default
X                        ``normal'' gray shading.  If $s$ is not specified,
X                        a value of 0.5 should be used.  NB: Shading applies
X                        to the interior of the object only; the borders of
X                        the object are still drawn using the current pen,
X                        which is particularly important for dvi drivers
X                        which do not support the {\tt sh} command.  The
X                        pixels generated by the shading value should be
X                        ``ANDed'' with the pixels already in the area.
X                        Subsequent text pixels should be ``ORed''.  Thus,
X                        text {\it followed\/} by a ``{\tt sh 0}'' command
X                        covering the same area will disappear.  Any shading
X                        value greater than zero should add the shading
X                        to the existing text, with the text remaining
X                        visible.  Of course, a shading value of one will
X                        be completely black, so any text that is there
X                        won't be distinguishable.
X\end{description}
X 
XThe following two opcodes are considered obsolete, but they probably should be
Ximplemented for backwards compatibility:
X 
X\begin{description}
X\item[wh]               This is the same as ``{\tt sh 0}''.
X\item[bk]               This is the same as ``{\tt sh 1}''.
X\item[tx]               This command was used to specify a texture
X                        to be used in shading instead of the default
X                        one.  Its use was limited to
X                        only one particular Imagen device driver,
X                        and it was very device-specific.  Its
X                        implementation is discouraged in favor of
X                        support for the argument to the {\tt sh} command.
X\end{description}
X 
X-----------------,------------------------------,------------------------------
XMichael N. Lipp  !  Institut fuer Datentechnik  !  Phone: 49-6151-163776
X                 !  Merckstr. 25     ,----------'  Fax:   49-6151-164976
X                 !  D-6100 Darmstadt ! E-Mail:        xdatmnlx@ddathd21.bitnet
X                 !  (Germany)        !    mnl@idtsun.e-technik.th-darmstadt.de
X-----------------'-------------------'-----------------------------------------
END_OF_FILE
if test 8799 -ne `wc -c <'doc/tpic.spec'`; then
    echo shar: \"'doc/tpic.spec'\" unpacked with wrong size!
fi
# end of 'doc/tpic.spec'
fi
if test -f 'fig2dev/dev/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fig2dev/dev/Makefile'\"
else
echo shar: Extracting \"'fig2dev/dev/Makefile'\" \(9932 characters\)
sed "s/^X//" >'fig2dev/dev/Makefile' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
X#
X# The cpp used on this machine replaces all newlines and multiple tabs and
X# spaces in a macro expansion with a single space.  Imake tries to compensate
X# for this, but is not always successful.
X#
X
X# -------------------------------------------------------------------------
X# Makefile generated from "Imake.tmpl" and </tmp/IIf.a21026>
X# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
X#
X# Platform-specific parameters may be set in the appropriate <vendor>.cf
X# configuration files.  Site-specific parameters should be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor does not define any unique symbols, you will need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make World" the first time).
X#
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that need to come before
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X# -------------------------------------------------------------------------
X# platform-specific configuration parameters - edit sun.cf to change
X
X# platform:  $XConsortium: sun.cf,v 1.72.1.1 92/03/18 13:13:37 rws Exp $
X
X# operating system:  SunOS 4.1.2
X
X# $XConsortium: sunLib.rules,v 1.7 91/12/20 11:19:47 rws Exp $
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that go after
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = ../../.
X      CURRENT_DIR = ./fig2dev/dev
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -g kmem -m 2755
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS =
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X# -------------------------------------------------------------------------
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.138 91/09/10 09:02:12 rws Exp $
X
X# -------------------------------------------------------------------------
X# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/lib
X           BINDIR = /usr/bin/X11
X          INCROOT = /usr/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = l
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
X# $XConsortium: sunLib.tmpl,v 1.14.1.1 92/03/17 14:58:46 rws Exp $
X
XSHLIBLDFLAGS = -assert pure-text
XPICFLAGS = -pic
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sa.$(SOXMUREV)
X       XMULIBONLY = -lXmu
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sa.$(SOXTREV)
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sa.$(SOXAWREV)
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        SOXLIBREV = 4.10
X          SOXTREV = 4.10
X         SOXAWREV = 5.0
X        SOOLDXREV = 4.10
X         SOXMUREV = 4.10
X        SOXEXTREV = 4.10
X      SOXINPUTREV = 4.10
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X# -------------------------------------------------------------------------
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
X# -------------------------------------------------------------------------
X# start of Imakefile
X
X#
X#	Fig2dev Driver Library Makefile
X#
X# to set paper size to A4 			add -DA4d	to DEFINES list
X# to set IBM Graphics Enhancement Cartridge	add -DIBMGEC	to DEFINES list
X# to set DVI-to-PostScript driver to dvips	add -DDVIPS	to DEFINES list
X#
XDEFINES = -DDVIPS
XDEPLIBS =
XINCLUDES = -I..
X
XSRCS =  genbox.c genepic.c genibmgl.c genlatex.c genpic.c genpictex.c \
X	genps.c genpstex.c gentextyl.c gentpic.c setfigfont.c
XLIBOBJS = genbox.o genepic.o genibmgl.o genlatex.o genpic.o genpictex.o \
X	genps.o genpstex.o gentextyl.o gentpic.o setfigfont.o
X
XLIB = transfig
X
Xall:: lib$(LIB).a
X
Xlib$(LIB).a: $(LIBOBJS)
X	$(RM) $@
X	$(AR) $@ $(LIBOBJS)
X	$(RANLIB) $@
X
Xdepend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
X# -------------------------------------------------------------------------
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) "#"*
X
XMakefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
Xsaber:
X	# load $(ALLDEFINES) $(SRCS)
X
Xosaber:
X	# load $(ALLDEFINES) $(OBJS)
X
X# -------------------------------------------------------------------------
X# empty rules for directories that do not have SUBDIRS - do not edit
X
Xinstall::
X	@echo "install in $(CURRENT_DIR) done"
X
Xinstall.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
XMakefiles::
X
Xincludes::
X
X# -------------------------------------------------------------------------
X# dependencies generated by makedepend
X
END_OF_FILE
if test 9932 -ne `wc -c <'fig2dev/dev/Makefile'`; then
    echo shar: \"'fig2dev/dev/Makefile'\" unpacked with wrong size!
fi
# end of 'fig2dev/dev/Makefile'
fi
if test -f 'fig2dev/dev/genpstex.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fig2dev/dev/genpstex.c'\"
else
echo shar: Extracting \"'fig2dev/dev/genpstex.c'\" \(3764 characters\)
sed "s/^X//" >'fig2dev/dev/genpstex.c' <<'END_OF_FILE'
X/*
X * TransFig: Facility for Translating Fig code
X * Copyright (c) 1985 Supoj Sutantavibul
X * Copyright (c) 1991 Micah Beck
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation. The authors make no representations about the suitability 
X * of this software for any purpose.  It is provided "as is" without express 
X * or implied warranty.
X *
X * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
X * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
X * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X *
X */
X
X/* 
X *	genpstex.c : psTeX and psTeX_t drivers for fig2dev
X *
X *	Author: Jose Alberto Fernandez R /Maryland CP 9/90
X * 	It uses the LaTeX and PostScript drivers to generate 
X *      LaTeX processed text for a Postscript figure.
X *
X * The pstex_t driver is like a latex driver that only translates 
X * text defined in the defaul font.
X *
X * The pstex driver is like a PostScript driver that translates 
X * everything except for text in the default font.
X *
X * The option '-p file' added to the pstex_t translator specifies
X * the name of the PostScript file to be called in the psfig macro.
X * If not set or its value is null then no PS file will be inserted.
X *
X * Jose Alberto.
X */
X
X#if defined(hpux) || defined(SYSV)
X#include <sys/types.h>
X#endif
X#include <sys/file.h>
X#include <stdio.h>
X#include <math.h>
X#include "object.h"
X#include "fig2dev.h"
X#include "texfonts.h"
X
X#ifndef fabs
Xextern double fabs();
X#endif
X#ifndef sin
Xextern double sin();
X#endif
X#ifndef cos
Xextern double cos();
X#endif
X#ifndef acos
Xextern double acos();
X#endif
X#ifndef atan
Xextern double atan();
X#endif
Xextern double rad2deg;
X
X#ifdef hpux
X#define rint(a) floor((a)+0.5)     /* close enough? */
X#endif
X
X#ifdef gould
X#define rint(a) floor((a)+0.5)     /* close enough? */
X#endif
X
Xextern void genlatex_start (),
X	gendev_null (),
X	genlatex_end (),
X     	genps_option (),
X	genps_start (),
X	genps_arc (),
X	genps_ellipse (),
X	genps_line (),
X	genps_spline (),
X	genps_end (),
X        genlatex_option (),
X        genlatex_text (),
X        genps_text ();
X
Xstatic char pstex_file[1000] = "";
X
Xvoid genpstex_t_option(opt, optarg)
Xchar opt, *optarg;
X{
X       if (opt == 'p') strcpy(pstex_file, optarg);
X       else genlatex_option(opt, optarg);
X}
X
X
Xvoid genpstex_t_start(objects)
XF_compound	*objects;
X{
X	/* Put PostScript Image if any*/
X        if (pstex_file[0] != '\0')
X        {
X		fprintf(tfp, "\\begin{picture}(0,0)%%\n");
X		fprintf(tfp, "\\special{psfile=%s}%%\n",pstex_file);
X		fprintf(tfp, "\\end{picture}%%\n");
X	}
X        genlatex_start(objects);
X
X}
X
Xvoid genpstex_t_text(t)
XF_text	*t;
X{
X
X	if (!special_text(t))
X	  gendev_null(t);
X	else genlatex_text(t);
X}
X
Xvoid genpstex_text(t)
XF_text	*t;
X{
X
X	if (!special_text(t))
X	  genps_text(t);
X	else gendev_null(t);
X}
X
Xvoid genpstex_option(opt, optarg)
Xchar opt, *optarg;
X{
X       if (opt != 'p') genlatex_option(opt, optarg);
X}
X
Xstruct driver dev_pstex_t = {
X     	genpstex_t_option,
X	genpstex_t_start,
X	gendev_null,
X	gendev_null,
X	gendev_null,
X	gendev_null,
X	genpstex_t_text,
X	genlatex_end,
X	EXCLUDE_TEXT
X};
X
Xstruct driver dev_pstex = {
X     	genpstex_option,
X	genps_start,
X	genps_arc,
X	genps_ellipse,
X	genps_line,
X	genps_spline,
X	genpstex_text,
X	genps_end,
X	INCLUDE_TEXT
X};
X
X
END_OF_FILE
if test 3764 -ne `wc -c <'fig2dev/dev/genpstex.c'`; then
    echo shar: \"'fig2dev/dev/genpstex.c'\" unpacked with wrong size!
fi
# end of 'fig2dev/dev/genpstex.c'
fi
if test -f 'fig2dev/dev/tpicfonts.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fig2dev/dev/tpicfonts.h'\"
else
echo shar: Extracting \"'fig2dev/dev/tpicfonts.h'\" \(4655 characters\)
sed "s/^X//" >'fig2dev/dev/tpicfonts.h' <<'END_OF_FILE'
X/*
X * TransFig: Facility for Translating Fig code
X * Copyright (c) 1985 Supoj Sutantavibul
X * Copyright (c) 1991 Micah Beck
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation. The authors make no representations about the suitability 
X * of this software for any purpose.  It is provided "as is" without express 
X * or implied warranty.
X *
X * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
X * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
X * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X *
X */
X
Xstatic char		*texfontnames[] = {
X			"rm",			/* default */
X			"rm",			/* roman */
X			"bf",			/* bold */
X			"it",			/* italic */
X			"sf", 			/* sans serif */
X			"sl",			/* slanted */
X			"tt",			/* typewriter */
X			/* Virtual fonts from here on */
X			"avant",
X			"avantcsc",
X			"avantd",
X			"avantdi",
X			"avanti",
X			"bookd",
X			"bookdi",
X			"bookl",
X			"booklcsc",
X			"bookli",
X			"chanc",
X			"cour",
X			"courb",
X			"courbi",
X			"couri",
X			"helv",
X			"helvb",
X			"helvbi",
X			"helvc",
X			"helvcb",
X			"helvcbi",
X			"helvci",
X			"helvcsc",
X			"helvi",
X			"pal",
X			"palb",
X			"palbi",
X			"palbu",
X			"palc",
X			"palcsc",
X			"pali",
X			"palsl",
X			"palu",
X			"palx",
X			"times",
X			"timesb",
X			"timesbi",
X			"timesc",
X			"timescsc",
X			"timesi",
X			"timessl",
X			"timesx"
X		};
X
X#define	MAX_TPICFONT	48
X
X/* The selection of font names may be site dependent.
X * Not all fonts are preloaded at all sizes.
X */
X
Xstatic char		*texfontsizes[] = {
X			"ten",			/* default */
X			"fiv", "fiv", "fiv", "fiv", 	/* small fonts */
X			"fiv",			/* five point font */
X			"six", "sev", "egt",	/* etc */
X			"nin", "ten", "elv",
X			"twl", "twl", "frtn",	
X			"frtn", "frtn", "svtn",
X			"svtn", "svtn", "twty",
X			"twty", "twty", "twty", "twty", "twfv"
X			};
X
Xstatic int		TeXfontsizes[] = {
X			10,		/* default */
X			5, 5, 5, 5, 	/* small fonts */
X			5,			/* five point font */
X			6, 7, 8,	/* etc */
X			9, 10, 11,
X			12, 12, 14,	
X			14, 14, 17,
X			17, 17, 20,
X			20, 20, 20, 20, 25
X			};
X
X
X#define MAXFONTSIZE 25
X
X#define TEXFONT(F)	(texfontnames[((F) <= MAX_TPICFONT) ? (F) : MAX_TPICFONT])
X#define TEXFONTSIZE(S)	(texfontsizes[((S) <= MAXFONTSIZE) ? (S) : MAXFONTSIZE])
X#define TEXFONTMAG(T)	TEXFONTSIZE((int)(T->size*(rigid_text(T) ? 1.0 : mag)))
X#define TEXFONTSIZEINT(S)	(TeXfontsizes[((S) <= MAXFONTSIZE) ? (S) : MAXFONTSIZE])
X#define TEXFONTMAGINT(T)	TEXFONTSIZEINT((int)(T->size*(rigid_text(T) ? 1.0 : mag)))
X
Xstatic char	*texture_patterns[] = {
X	"8 0 8 0 4 1 3 e 0 8 0 8 1 4 e 3",	/* scales */
X	"f f 8 0 8 0 8 0 f f 0 8 0 8 0 8",	/* bricks */
X	"8 1 4 2 2 4 1 8 8 1 4 2 2 4 1 8",	/* waves */
X	"8 0 4 0 2 0 1 0 0 8 0 4 0 2 0 1",	/* light backslash alternating */
X	"e 0 7 0 3 8 1 c 0 e 0 7 8 3 c 1",	/* heavy backslash alternating */
X	"7 7 b b d d e e 7 7 b b d d e e",	/* heavy backslash */
X	"8 8 4 4 2 2 1 1 8 8 4 4 2 2 1 1",	/* light backslash */
X	"9 9 c c 6 6 3 3 9 9 c c 6 6 3 3",	/* medium backslash */
X	"2 0 4 0 8 0 0 0 0 8 0 4 0 2 0 0",	/* light hash */
X	"f f 0 0 f f 0 0 f f 0 0 f f 0 0",	/* horizontal lines */
X	"f f 0 0 0 0 0 0 f f 0 0 0 0 0 0",	/* spaced horizontal lines */
X	"c c 0 0 0 0 0 0 3 3 0 0 0 0 0 0",	/* spaced horizontal dashed lines */
X	"f 0 f 0 f 0 f 0 0 f 0 f 0 f 0 f",	/* chessboard */
X	"f f 8 8 8 8 8 8 f f 8 8 8 8 8 8",	/* light meshed lines */
X	"a a 4 4 a a 1 1 a a 4 4 a a 1 1",	/* hashed dotted lines */
X	"0 1 0 2 0 4 0 8 1 0 2 0 4 0 8 0",	/* spaced light frontslash */
X	"8 3 0 7 0 e 1 c 3 8 7 0 e 0 c 1",	/* spaced heavy frontslash */
X	"e e d d b b 7 7 e e d d b b 7 7",	/* heavy frontslash */
X	"1 1 2 2 4 4 8 8 1 1 2 2 4 4 8 8",	/* light frontslash */
X	"3 3 6 6 c c 9 9 3 3 6 6 c c 9 9",	/* medium frontslash */
X	"4 0 a 0 0 0 0 0 0 4 0 a 0 0 0 0",	/* wallpaper - birds */
X	"a a a a a a a a a a a a a a a a",	/* vertical lines */
X	"8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8",	/* spaced vertical lines */
X	"0 1 0 1 1 0 1 0 0 1 0 1 1 0 1 0",	/* vertical dashed lines */
X	"0 0 0 8 1 4 2 a 5 5 2 a 1 4 0 8",	/* hashed diamonds */
X	"f f 8 0 8 0 8 0 8 0 8 0 8 0 8 0",	/* spaced meshed lines */
X	"8 2 4 4 2 8 1 0 2 8 4 4 8 2 0 1"	/* hashed dotted lines */
X};
X
X#define	MAXPATTERNS	27
END_OF_FILE
if test 4655 -ne `wc -c <'fig2dev/dev/tpicfonts.h'`; then
    echo shar: \"'fig2dev/dev/tpicfonts.h'\" unpacked with wrong size!
fi
# end of 'fig2dev/dev/tpicfonts.h'
fi
if test -f 'fig2dev/fig2dev.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fig2dev/fig2dev.c'\"
else
echo shar: Extracting \"'fig2dev/fig2dev.c'\" \(7009 characters\)
sed "s/^X//" >'fig2dev/fig2dev.c' <<'END_OF_FILE'
X/*
X * TransFig: Facility for Translating Fig code
X * Copyright (c) 1985 Supoj Sutantavibul
X * Copyright (c) 1991 Micah Beck
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation. The authors make no representations about the suitability 
X * of this software for any purpose.  It is provided "as is" without express 
X * or implied warranty.
X *
X * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
X * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
X * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X *
X */
X
X/* 
X *	Fig2dev : General Fig code translation program
X *
X*/
X#if defined(hpux) || defined(SYSV)
X#include <sys/types.h>
X#endif
X#include <sys/file.h>
X#include <stdio.h>
X#include <ctype.h>
X#include "patchlevel.h"
X#include "object.h"
X#include "fig2dev.h"
X#include "drivers.h"
X
Xextern int getopt();
Xextern char *optarg;
Xextern int optind;
X
X#define DEFAULT_FONT_SIZE 11
X
Xstruct driver *dev = NULL;
X
Xchar		Usage[] = "Usage: %s [-L language] [-f font] [-s size] [-m scale] [input [output]]\n";
Xchar		Err_badarg[] = "Argument -%c unkown to %s driver.";
Xchar		Err_incomp[] = "Incomplete %s object at line %d.";
Xchar		Err_mem[] = "Running out of memory.";
X
Xchar		*prog;
Xchar		*from = NULL, *to = NULL;
Xint		font_size = 0;
Xdouble		mag = 1.0;
XFILE		*tfp = NULL;
Xint		llx = 0, lly = 0, urx = 0, ury = 0;
X
Xstruct obj_rec {
X	void (*gendev)();
X	char *obj;
X	int depth;
X};
X
Xput_msg(format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
Xchar   *format, *arg1, *arg2, *arg3, *arg4, *arg5, *arg6, *arg7, *arg8;
X{
X	fprintf(stderr, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
X	fprintf(stderr, "\n");
X	}
X
Xget_args(argc, argv)
Xint	 argc;
Xchar	*argv[];
X{
X  	int	c, i;
X	double	atof();
X
X	prog = *argv;
X/* add :? */
X	while ((c = getopt(argc, argv, "acd:f:l:L:m:Pp:s:S:vVwW?")) != EOF) {
X
X	  /* generic option handling */
X	  switch (c) {
X
X		case 'V': 
X			fprintf(stderr, "TransFig Version %s Patchlevel %s\n",
X							VERSION, PATCHLEVEL);
X			exit(0);
X			break;
X
X		case 'L':			/* set output language */
X		    for (i=0; *drivers[i].name; i++) 
X			if (!strcmp(optarg, drivers[i].name))
X				dev = drivers[i].dev;
X		    if (!dev) {
X			fprintf(stderr,
X				"Unknown graphics language %s\n", optarg);
X			fprintf(stderr,"Known languages are:\n");
X			/* display available languages - 23/01/90 */
X			for (i=0; *drivers[i].name; i++)
X				fprintf(stderr,"%s ",drivers[i].name);
X			fprintf(stderr,"\n");
X			exit(1);
X		    }
X		    break;
X
X		case 's':			/* set default font size */
X		    font_size = atoi(optarg);
X		    break;
X
X		case 'm':			/* set magnification */
X		    mag = atof(optarg);
X		    break;
X
X		case '?':			/* usage 		*/
X			fprintf(stderr,Usage,prog);
X			exit(1);
X	    }
X
X	    /* pass options through to driver */
X	    if (!dev) {
X		fprintf(stderr, "No graphics language specified.\n");
X		exit(1);
X	    }
X	    dev->option(c, optarg);
X      	}
X      	if (!dev) {
X		fprintf(stderr, "No graphics language specified.\n");
X		exit(1);
X      	}
X
X	/* default font size is scaled if not specified */
X	if (!font_size) font_size = DEFAULT_FONT_SIZE*mag + 0.5;
X
X	if (optind < argc) from = argv[optind++];  /*  from file  */
X	if (optind < argc) to   = argv[optind];  /*  to file    */
X}
X
Xmain(argc, argv)
Xint	 argc;
Xchar	*argv[];
X{
X	F_compound	objects;
X	int		status;
X
X	get_args(argc, argv);
X
X	if (from)
X	    status = read_fig(from, &objects);
X	else	/* read from stdin */
X	    status = readfp_fig(stdin, &objects);
X
X	if (status != 0) {
X	    if (from) read_fail_message(from, status);
X	    exit(1);
X	    }
X
X	if (to == NULL)
X	    tfp = stdout;
X	else if ((tfp = fopen(to, "w")) == NULL) {
X	    fprintf(stderr, "Couldn't open %s", to);
X	    fprintf(stderr, Usage, prog);
X	    exit(1);
X	    }
X
X	gendev_objects(&objects, dev);
X	if (tfp != stdout) (void)fclose(tfp);
X	exit(0);
X	}
X
X/* count primitive objects & create pointer array */
Xstatic int compound_dump(com, array, count, dev)
XF_compound *com;
Xstruct obj_rec *array;
Xint count;
Xstruct driver *dev;
X{
X  	F_arc		*a;
X	F_compound	*c;
X	F_ellipse	*e;
X	F_line		*l;
X	F_spline	*s;
X	F_text		*t;
X
X	for (c = com->compounds; c != NULL; c = c->next)
X	  count = compound_dump(c, array, count, dev);
X	for (a = com->arcs; a != NULL; a = a->next) {
X	  if (array) {
X		array[count].gendev = dev->arc;
X		array[count].obj = (char *)a;
X		array[count].depth = a->depth;
X	  }
X	  count += 1;
X	}
X	for (e = com->ellipses; e != NULL; e = e->next) {
X	  if (array) {
X		array[count].gendev = dev->ellipse;
X		array[count].obj = (char *)e;
X		array[count].depth = e->depth;
X	  }
X	  count += 1;
X	}
X	for (l = com->lines; l != NULL; l = l->next) {
X	  if (array) {
X		array[count].gendev = dev->line;
X		array[count].obj = (char *)l;
X		array[count].depth = l->depth;
X	  }
X	  count += 1;
X	}
X	for (s = com->splines; s != NULL; s = s->next) {
X	  if (array) {
X		array[count].gendev = dev->spline;
X		array[count].obj = (char *)s;
X		array[count].depth = s->depth;
X	  }
X	  count += 1;
X	}
X	for (t = com->texts; t != NULL; t = t->next) {
X	  if (array) {
X		array[count].gendev = dev->text;
X		array[count].obj = (char *)t;
X		array[count].depth = t->depth;
X	  }
X	  count += 1;
X	}
X	return count;
X}
X
Xgendev_objects(objects, dev)
XF_compound	*objects;
Xstruct driver *dev;
X{
X	F_arc		*a;
X	F_compound	*c;
X	F_ellipse	*e;
X	F_line		*l;
X	F_spline	*s;
X	F_text		*t;
X
X	int obj_count, rec_comp();
X	struct obj_rec *rec_array, *r; 
X
X	if (0 == (double)objects->nwcorner.x) {
X	    fprintf(stderr, "Resolution is zero!! default to 80 ppi\n");
X	    objects->nwcorner.x = 80;
X	    }
X	if (objects->nwcorner.y != 1 && objects->nwcorner.y != 2) {
X	    fprintf(stderr, "Wrong coordinate system; cannot continue\n");
X	    return;
X	    }
X
X	/* Compute bounding box of objects, supressing texts if indicated */
X	compound_bound(objects, &llx, &lly, &urx, &ury, dev->text_include);
X
X	/* dump object pointers to an array */
X	obj_count = compound_dump(objects, 0, 0, dev);
X	if (!obj_count) {
X	    fprintf(stderr, "No object");
X	    return;
X	    }
X	rec_array = (struct obj_rec *)malloc(obj_count*sizeof(struct obj_rec));
X	(void)compound_dump(objects, rec_array, 0, dev);
X
X	/* sort object array by depth */
X	qsort(rec_array, obj_count, sizeof(struct obj_rec), rec_comp);
X
X	/* generate header */
X	(*dev->start)(objects);
X
X	/* generate objects in sorted order */
X	for (r = rec_array; r<rec_array+obj_count; r++)
X		(*(r->gendev))(r->obj);
X
X	/* generate trailer */
X	(*dev->end)();
X}
X
Xint rec_comp(r1, r2)
Xstruct obj_rec *r1, *r2;
X{
X	return (r2->depth - r1->depth);
X}
X
X/* null operation */
Xvoid gendev_null() {};
END_OF_FILE
if test 7009 -ne `wc -c <'fig2dev/fig2dev.c'`; then
    echo shar: \"'fig2dev/fig2dev.c'\" unpacked with wrong size!
fi
# end of 'fig2dev/fig2dev.c'
fi
if test -f 'fig2dev/getopt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fig2dev/getopt.c'\"
else
echo shar: Extracting \"'fig2dev/getopt.c'\" \(4071 characters\)
sed "s/^X//" >'fig2dev/getopt.c' <<'END_OF_FILE'
X/*
X * TransFig: Facility for Translating Fig code
X * Copyright (c) 1985 Supoj Sutantavibul
X * Copyright (c) 1991 Micah Beck
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation. The authors make no representations about the suitability 
X * of this software for any purpose.  It is provided "as is" without express 
X * or implied warranty.
X *
X * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
X * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
X * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X *
X */
X
X/*
X	I got this off net.sources from Henry Spencer.
X	It is a public domain getopt(3) like in System V.
X	I have made the following modifications:
X
X	index(s,c) was added because too many people could
X	not compile getopt without it.
X
X	A test main program was added, ifdeffed by GETOPT.
X	This main program is a public domain implementation
X	of the getopt(1) program like in System V.  The getopt
X	program can be used to standardize shell option handling.
X		e.g.  cc -DGETOPT getopt.c -o getopt
X*/
X#include <stdio.h>
X
X#ifndef lint
Xstatic	char	sccsfid[] = "@(#) getopt.c 5.0 (UTZoo) 1985";
X#endif
X
X#define	ARGCH    (int)':'
X#define BADCH	 (int)'?'
X#define EMSG	 ""
X#define	ENDARGS  "--"
X
X/* this is included because index is not on some UNIX systems */
Xstatic
Xchar *
Xindex (s, c)
Xregister	char	*s;
Xregister	int 	c;
X	{
X	while (*s)
X		if (c == *s) return (s);
X		else s++;
X	return (NULL);
X	}
X
X/*
X * get option letter from argument vector
X */
Xint	opterr = 1,		/* useless, never set or used */
X	optind = 1,		/* index into parent argv vector */
X	optopt;			/* character checked for validity */
Xchar	*optarg;		/* argument associated with option */
X
X#define tell(s)	fputs(*nargv,stderr);fputs(s,stderr); \
X		fputc(optopt,stderr);fputc('\n',stderr);return(BADCH);
X
X
Xgetopt(nargc,nargv,ostr)
Xint	nargc;
Xchar	**nargv,
X	*ostr;
X{
X	static char	*place = EMSG;	/* option letter processing */
X	register char	*oli;		/* option letter list index */
X	char	*index();
X
X	if(!*place) {			/* update scanning pointer */
X		if(optind >= nargc || *(place = nargv[optind]) != '-' || !*++place) return(EOF);
X		if (*place == '-') {	/* found "--" */
X			++optind;
X			return(EOF);
X		}
X	}				/* option letter okay? */
X	if ((optopt = (int)*place++) == ARGCH || !(oli = index(ostr,optopt))) {
X		if(!*place) ++optind;
X		tell(": illegal option -- ");
X	}
X	if (*++oli != ARGCH) {		/* don't need argument */
X		optarg = NULL;
X		if (!*place) ++optind;
X	}
X	else {				/* need an argument */
X		if (*place) optarg = place;	/* no white space */
X		else if (nargc <= ++optind) {	/* no arg */
X			place = EMSG;
X			tell(": option requires an argument -- ");
X		}
X	 	else optarg = nargv[optind];	/* white space */
X		place = EMSG;
X		++optind;
X	}
X	return(optopt);			/* dump back option letter */
X}
X
X
X#ifdef GETOPT
X
X#ifndef lint
Xstatic	char	sccspid[] = "@(#) getopt.c 5.1 (WangInst) 6/15/85";
X#endif
X
Xmain (argc, argv) char **argv;
X	{
X	char	*optstring = argv[1];
X	char	*argv0 = argv[0];
X	extern	int 	optind;
X	extern	char	*optarg;
X	int 	opterr = 0;
X	int 	C;
X	char	*opi;
X	if (argc == 1)
X		{
X		fprintf (stderr, "Usage: %s optstring args\n", argv0);
X		exit (1);
X		}
X	argv++;
X	argc--;
X	argv[0] = argv0;
X	while ((C = getopt (argc, argv, optstring)) != EOF)
X		{
X		if (C == BADCH) opterr++;
X		printf ("-%c ", C);
X		opi = index (optstring, C);
X		if (opi && opi[1] == ARGCH)
X			if (optarg)
X				printf ("\"%s\" ", optarg);
X			else opterr++;
X		}
X	printf ("%s", ENDARGS);
X	while (optind < argc)
X		printf (" \"%s\"", argv[optind++]);
X	putchar ('\n');
X	exit (opterr);
X	}
X
X#endif
END_OF_FILE
if test 4071 -ne `wc -c <'fig2dev/getopt.c'`; then
    echo shar: \"'fig2dev/getopt.c'\" unpacked with wrong size!
fi
# end of 'fig2dev/getopt.c'
fi
if test -f 'fig2dev/latex_line.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fig2dev/latex_line.c'\"
else
echo shar: Extracting \"'fig2dev/latex_line.c'\" \(5574 characters\)
sed "s/^X//" >'fig2dev/latex_line.c' <<'END_OF_FILE'
X/*
X * TransFig: Facility for Translating Fig code
X * Copyright (c) 1985 Supoj Sutantavibul
X * Copyright (c) 1991 Micah Beck
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation. The authors make no representations about the suitability 
X * of this software for any purpose.  It is provided "as is" without express 
X * or implied warranty.
X *
X * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
X * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
X * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X *
X */
X
X#include <stdio.h>
X#include <math.h>
X/* 
X *	latex_line.c: 
X *	    Subroutines for drawing and translating lines for the LaTeX
X *	    picture environment.
X *	Written by Frank Schmuck (schmuck@svax.cs.cornell.edu)
X *	June 1988
X *
X *	The LaTeX picture environment allows generating pictures in standard
X *	LaTeX.  However, some restrictions apply:  lines and vectors (a vector
X *	is a line with an arrow at the end) can only be drawn with a finite
X *	number of slopes.  The available slopes are given by dy/dx where
X *	dx and dy must be integers <= 6 for lines and <= 4 for vectors.
X *
X *	The subroutines in this file are used in fig2latex to approximate
X *	an arbitrary line or vector by a LaTeX line/vector, and in fig to 
X *	restrict line drawing to slopes supported by LaTeX.
X */
X
X/*
X * Constant for converting from radian to degrees
X */
Xdouble rad2deg = 57.295779513082320877;
X
Xint  pgcd(a,b)
X    int a, b;
X/*
X *  compute greatest common divisor, assuming 0 < a <= b
X */
X{
X    b = b % a;
X    return (b)? gcd(b, a): a;
X}
X
Xint  gcd(a, b)
X    int a, b;
X/*
X *  compute greatest common divisor
X */
X{
X    if (a < 0) a = -a;
X    if (b < 0) b = -b;
X    return (a <= b)? pgcd(a, b): pgcd(b, a);
X}
X
Xint  lcm(a, b)
X    int a, b;
X/*
X *  Compute least common multiple
X */
X{
X    return abs(a*b)/gcd(a,b);
X}
X
X/*
X *  Tables of line and vector slopes supported by LaTeX
X */
X 
Xstruct angle_table {
X    int    x, y;
X    double angle;
X};
X
X#define N_LINE 25
X
Xstruct angle_table line_angles[N_LINE] =
X  { {0, 1, 90.0}, 
X    {1, 0,  0.0},
X    {1, 1, 45.0}, 
X    {1, 2, 63.434948822922010648},
X    {1, 3, 71.565051177077989351},
X    {1, 4, 75.963756532073521417},
X    {1, 5, 78.690067525979786913},
X    {1, 6, 80.537677791974382609},
X    {2, 1, 26.565051177077989351},
X    {2, 3, 56.309932474020213086},
X    {2, 5, 68.198590513648188229}, 
X    {3, 1, 18.434948822922010648},
X    {3, 2, 33.690067525979786913},
X    {3, 4, 53.130102354155978703},
X    {3, 5, 59.036243467926478582},
X    {4, 1, 14.036243467926478588},
X    {4, 3, 36.869897645844021297},
X    {4, 5, 51.340191745909909396},
X    {5, 1, 11.309932474020213086},
X    {5, 2, 21.801409486351811770},
X    {5, 3, 30.963756532073521417},
X    {5, 4, 38.659808254090090604},
X    {5, 6, 50.194428907734805993},
X    {6, 1, 9.4623222080256173906},
X    {6, 5, 39.805571092265194006}
X  };
X
X#define N_ARROW 13
X
Xstruct angle_table arrow_angles[N_ARROW] =
X  { {0, 1, 90.0}, 
X    {1, 0,  0.0},
X    {1, 1, 45.0}, 
X    {1, 2, 63.434948822922010648},
X    {1, 3, 71.565051177077989351},
X    {1, 4, 75.963756532073521417},
X    {2, 1, 26.565051177077989351},
X    {2, 3, 56.309932474020213086},
X    {3, 1, 18.434948822922010648},
X    {3, 2, 33.690067525979786913},
X    {3, 4, 53.130102354155978703},
X    {4, 1, 14.036243467926478588},
X    {4, 3, 36.869897645844021297},
X  };
X
Xget_slope(dx, dy, sxp, syp, arrow)
X    int  dx, dy, *sxp, *syp, arrow;
X/*
X *  Find the LaTeX line slope that is closest to the one given by dx, dy.
X *  Result is returned in *sxp, *syp.  If (arrow != 0) the closest LaTeX
X *  vector slope is selected.
X */
X{
X    double angle;
X    int    i, s, max;
X    double d, d1;
X    struct angle_table *st;
X
X    if (dx == 0) {
X	*sxp = 0;
X	*syp = (dy < 0)? -1: 1;
X	return;
X    }
X    angle = atan((double)abs(dy) / (double)abs(dx)) * rad2deg;
X    if (arrow) {
X	st = arrow_angles;
X	max = N_ARROW;
X    } else {
X	st = line_angles;
X	max = N_LINE;
X    }
X    s = 0;
X    d = 9.9e9;
X    for (i = 0; i < max; i++) {
X	d1 = fabs(angle - st[i].angle);
X	if (d1 < d) {
X	    s = i;
X	    d = d1;
X	} 
X    }
X    *sxp = st[s].x;
X    if (dx < 0) *sxp = -*sxp;
X    *syp = st[s].y;
X    if (dy < 0) *syp = -*syp;
X}
X
Xlatex_endpoint(x1, y1, x2, y2, xout, yout, arrow, magnet)
X    int  x1, y1, x2, y2;
X    int  *xout, *yout;
X    int  arrow, magnet;
X/*
X *  Computes a point "close" to (x2,y2) that is reachable from (x1,y1)
X *  by a LaTeX line (LaTeX vector if arrow != 0).  The result is returned
X *  in *xout, *yout.  If (magnet > 1) the point returned is selected such that
X *  (*xout - x1) and (*yout - y1) are both multiples of magnet.
X */
X{
X    int    dx, dy, sx, sy, ds, dsx, dsy;
X
X    dx = x2-x1;
X    dy = y2-y1;
X    get_slope(dx, dy, &sx, &sy, arrow);
X    if (abs(sx) >= abs(sy)) {
X	ds = lcm(sx, magnet*gcd(sx,magnet));
X	dsx = (2*abs(dx)/ds + 1)/2;
X	dsx = (dx >= 0)? dsx*ds: -dsx*ds;
X	*xout = x1 + dsx;
X	*yout = y1 + dsx*sy/sx;
X    } else {
X	ds = lcm(sy, magnet*gcd(sy,magnet));
X	dsy = (2*abs(dy)/ds + 1)/2;
X	dsy = (dy >= 0)? dsy*ds: -dsy*ds;
X	*yout = y1 + dsy;
X	*xout = x1 + dsy*sx/sy;
X    }
X}
END_OF_FILE
if test 5574 -ne `wc -c <'fig2dev/latex_line.c'`; then
    echo shar: \"'fig2dev/latex_line.c'\" unpacked with wrong size!
fi
# end of 'fig2dev/latex_line.c'
fi
if test -f 'fig2dev/object.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fig2dev/object.h'\"
else
echo shar: Extracting \"'fig2dev/object.h'\" \(6541 characters\)
sed "s/^X//" >'fig2dev/object.h' <<'END_OF_FILE'
X/*
X * TransFig: Facility for Translating Fig code
X * Copyright (c) 1985 Supoj Sutantavibul
X * Copyright (c) 1991 Micah Beck
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation. The authors make no representations about the suitability 
X * of this software for any purpose.  It is provided "as is" without express 
X * or implied warranty.
X *
X * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
X * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
X * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X *
X */
X
X#define		DEFAULT				(-1)
X
Xtypedef		struct f_point {
X			int			x, y;
X			struct f_point		*next;
X			}
X		F_point;
X
Xtypedef		struct f_pos {
X			int			x, y;
X			}
X		F_pos;
X
Xtypedef		struct f_arrow {
X			int			type;
X			int			style;
X			double			thickness;
X			double			wid;
X			double			ht;
X			}
X		F_arrow;
X
Xtypedef		struct f_ellipse {
X			int			type;
X#define					T_ELLIPSE_BY_RAD	1
X#define					T_ELLIPSE_BY_DIA	2
X#define					T_CIRCLE_BY_RAD		3
X#define					T_CIRCLE_BY_DIA		4
X			int			style;
X			int			thickness;
X			int			color;
X#define 	 			BLACK_COLOR		0
X#define					BLUE_COLOR		1
X#define					GREEN_COLOR		2
X#define					CYAN_COLOR		3
X#define					RED_COLOR		4
X#define					MAGENTA_COLOR		5
X#define					YELLOW_COLOR		6
X#define					WHITE_COLOR		7
X			int			depth;
X			int			direction;
X			double			style_val;
X			double			angle;
X			int			pen;
X			int			area_fill;
X#define		       			UNFILLED	0
X#define		       			WHITE_FILL	1
X#define		       			BLACK_FILL	21
X			struct f_pos		center;
X			struct f_pos		radiuses;
X			struct f_pos		start;
X			struct f_pos		end;
X			struct f_ellipse	*next;
X			}
X		F_ellipse;
X
Xtypedef		struct f_arc {
X			int			type;
X#define					T_3_POINTS_ARC		1
X			int			style;
X			int			thickness;
X			int			color;
X			int			depth;
X			int			pen;
X			int			area_fill;
X			double			style_val;
X			int			direction;
X			struct f_arrow		*for_arrow;
X			struct f_arrow		*back_arrow;
X			struct {double x, y;}	center;
X			struct f_pos		point[3];
X			struct f_arc		*next;
X			}
X		F_arc;
X
Xtypedef		struct f_line {
X			int			type;
X#define					T_POLYLINE	1
X#define					T_BOX		2
X#define					T_POLYGON	3
X#define	                                T_ARC_BOX       4
X#define	                                T_EPS_BOX       5 
X
X			int			style;
X			int			thickness;
X			int			color;
X			int			depth;
X			double			style_val;
X			int			pen;
X 			int			area_fill;
X			int			radius;	/* for T_ARC_BOX */
X			struct f_arrow		*for_arrow;
X			struct f_arrow		*back_arrow;
X			struct f_point		*points;
X		    	struct f_eps   		*eps;
X			struct f_line		*next;
X			}
X		F_line;
X
Xtypedef struct f_eps {
X    char            file[256];
X    int             flipped;
X    unsigned char  *bitmap;
X    float	    hw_ratio;
X    struct f_pos    bit_size;
X    int             pix_rotation, pix_width, pix_height, pix_flipped;
X}
X		F_eps;
X
Xextern char EMPTY_EPS[];
X
Xtypedef		struct f_text {
X			int			type;
X#define					T_LEFT_JUSTIFIED	0
X#define					T_CENTER_JUSTIFIED	1
X#define					T_RIGHT_JUSTIFIED	2
X			int			font;
X#define					DEFAULT_FONT		0
X#define					ROMAN_FONT		1
X#define					BOLD_FONT		2
X#define					ITALIC_FONT		3
X#define					MODERN_FONT		4
X#define					TYPEWRITER_FONT		5
X#define					MAX_FONT		5
X			double			size;	/* point size */
X			int			color;
X			int			depth;
X			double			angle;	/* in radian */
X			int			flags;
X#define					RIGID_TEXT	1	
X#define					SPECIAL_TEXT	2
X#define					PSFONT_TEXT	4
X			double			height;	/* pixels */
X			double			length;	/* pixels */
X			int			base_x;
X			int			base_y;
X			int			pen;
X			char			*cstring;
X			struct f_text		*next;
X			}
X		F_text;
X
X#define MAX_PSFONT	35
X#define MAXFONT(T) (psfont_text(T) ? MAX_PSFONT : MAX_FONT)
X
X#define		rigid_text(t) \
X			(t->flags == DEFAULT \
X				|| (t->flags & RIGID_TEXT))
X
X#define		special_text(t) \
X			((t->flags != DEFAULT \
X				&& (t->flags & SPECIAL_TEXT)))
X
X#define		psfont_text(t) \
X			(t->flags != DEFAULT \
X				&& (t->flags & PSFONT_TEXT))
X
Xtypedef		struct f_control {
X			double			lx, ly, rx, ry;
X			struct f_control	*next;
X			}
X		F_control;
X
X#define		int_spline(s)		(s->type & 0x2)
X#define		normal_spline(s)	(!(s->type & 0x2))
X#define		closed_spline(s)	(s->type & 0x1)
X#define		open_spline(s)		(!(s->type & 0x1))
X
Xtypedef		struct f_spline {
X			int			type;
X#define					T_OPEN_NORMAL		0
X#define					T_CLOSED_NORMAL		1
X#define					T_OPEN_INTERPOLATED	2
X#define					T_CLOSED_INTERPOLATED	3
X			int			style;
X			int			thickness;
X			int			color;
X			int			depth;
X			double			style_val;
X			int			pen;
X			int			area_fill;
X			struct f_arrow		*for_arrow;
X			struct f_arrow		*back_arrow;
X			/*
X			For T_OPEN_NORMAL and T_CLOSED_NORMAL points
X			are control points while they are knots for
X			T_OPEN_INTERPOLATED and T_CLOSED_INTERPOLTED
X			whose control points are stored in controls.
X			*/
X			struct f_point		*points;
X			struct f_control	*controls;
X			struct f_spline		*next;
X			}
X		F_spline;
X
Xtypedef		struct f_compound {
X			struct f_pos		nwcorner;
X			struct f_pos		secorner;
X			struct f_line		*lines;
X			struct f_ellipse	*ellipses;
X			struct f_spline		*splines;
X			struct f_text		*texts;
X			struct f_arc		*arcs;
X			struct f_compound	*compounds;
X			struct f_compound	*next;
X			}
X		F_compound;
X
X#define		ARROW_SIZE		sizeof(struct f_arrow)
X#define		POINT_SIZE		sizeof(struct f_point)
X#define		CONTROL_SIZE		sizeof(struct f_control)
X#define		ELLOBJ_SIZE		sizeof(struct f_ellipse)
X#define		ARCOBJ_SIZE		sizeof(struct f_arc)
X#define		LINOBJ_SIZE		sizeof(struct f_line)
X#define		EPS_SIZE		sizeof(struct f_eps)
X#define		TEXOBJ_SIZE		sizeof(struct f_text)
X#define		SPLOBJ_SIZE		sizeof(struct f_spline)
X#define		COMOBJ_SIZE		sizeof(struct f_compound)
X
X/**********************  object codes  **********************/
X
X#define		O_ELLIPSE		1
X#define		O_POLYLINE		2
X#define		O_SPLINE		3
X#define		O_TEXT			4
X#define		O_ARC			5
X#define		O_COMPOUND		6
X#define		O_END_COMPOUND		(-O_COMPOUND)
X#define		O_ALL_OBJECT		99
X
X/************  object styles (except for f_text)  ************/
X
X#define		SOLID_LINE		0
X#define		DASH_LINE		1
X#define		DOTTED_LINE		2
X
X#define		CLOSED_PATH		0
X#define		OPEN_PATH		1
END_OF_FILE
if test 6541 -ne `wc -c <'fig2dev/object.h'`; then
    echo shar: \"'fig2dev/object.h'\" unpacked with wrong size!
fi
# end of 'fig2dev/object.h'
fi
if test -f 'fig2dev/psfonts.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fig2dev/psfonts.c'\"
else
echo shar: Extracting \"'fig2dev/psfonts.c'\" \(6461 characters\)
sed "s/^X//" >'fig2dev/psfonts.c' <<'END_OF_FILE'
X/*
X * TransFig: Facility for Translating Fig code
X * Copyright (c) 1985 Supoj Sutantavibul
X * Copyright (c) 1991 Micah Beck
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation. The authors make no representations about the suitability 
X * of this software for any purpose.  It is provided "as is" without express 
X * or implied warranty.
X *
X * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
X * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
X * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X *
X */
X
X/* 
X *	psfont.c : PostScript font mappings
X *
X*/
X#include <stdio.h>
X#include "object.h"
X
Xchar			*PSfontnames[] = {
X			"Times-Roman", "Times-Roman",	/* default */
X			"Times-Italic",			/* italic */
X			"Times-Bold",			/* bold */
X			"Times-BoldItalic",
X			"AvantGarde-Book",
X			"AvantGarde-BookOblique",
X			"AvantGarde-Demi",
X			"AvantGarde-DemiOblique",
X			"Bookman-Light",
X			"Bookman-LightItalic",
X			"Bookman-Demi",
X			"Bookman-DemiItalic",
X			"Courier",	
X			"Courier-Oblique",
X			"Courier-Bold",
X			"Courier-BoldOblique",
X			"Helvetica",
X			"Helvetica-Oblique",
X			"Helvetica-Bold",
X			"Helvetica-BoldOblique",
X			"Helvetica-Narrow",
X			"Helvetica-Narrow-Oblique",
X			"Helvetica-Narrow-Bold",
X			"Helvetica-Narrow-BoldOblique",
X			"NewCenturySchlbk-Roman",
X			"NewCenturySchlbk-Italic",
X			"NewCenturySchlbk-Bold",
X			"NewCenturySchlbk-BoldItalic",
X			"Palatino-Roman",
X			"Palatino-Italic",
X			"Palatino-Bold",
X			"Palatino-BoldItalic",
X			"Symbol",
X			"ZapfChancery-MediumItalic",
X			"ZapfDingbats"
X		};
X
Xstatic int	PSfontmap[] = {
X		ROMAN_FONT, ROMAN_FONT,		/* Times-Roman */
X		ITALIC_FONT,			/* Times-Italic */
X		BOLD_FONT,			/* Times-Bold */
X		BOLD_FONT,			/* Times-BoldItalic */
X		ROMAN_FONT,			/* AvantGarde */
X		ROMAN_FONT,			/* AvantGarde-BookOblique */
X		ROMAN_FONT,			/* AvantGarde-Demi */
X		ROMAN_FONT,			/* AvantGarde-DemiOblique */
X		ROMAN_FONT,			/* Bookman-Light */
X		ITALIC_FONT,			/* Bookman-LightItalic */
X		ROMAN_FONT,			/* Bookman-Demi */
X		ITALIC_FONT,			/* Bookman-DemiItalic */
X		TYPEWRITER_FONT,		/* Courier */
X		TYPEWRITER_FONT,		/* Courier-Oblique */
X		BOLD_FONT,			/* Courier-Bold */
X		BOLD_FONT,			/* Courier-BoldItalic */
X		MODERN_FONT,			/* Helvetica */
X		MODERN_FONT,			/* Helvetica-Oblique */
X		BOLD_FONT,			/* Helvetica-Bold */
X		BOLD_FONT,			/* Helvetica-BoldOblique */
X		MODERN_FONT,			/* Helvetica-Narrow */
X		MODERN_FONT,			/* Helvetica-Narrow-Oblique */
X		BOLD_FONT,			/* Helvetica-Narrow-Bold */
X		BOLD_FONT,		/* Helvetica-Narrow-BoldOblique */
X		ROMAN_FONT,			/* NewCenturySchlbk-Roman */
X		ITALIC_FONT,			/* NewCenturySchlbk-Italic */
X		BOLD_FONT,			/* NewCenturySchlbk-Bold */
X		BOLD_FONT,		/* NewCenturySchlbk-BoldItalic */
X		ROMAN_FONT,			/* Palatino-Roman */
X		ITALIC_FONT,			/* Palatino-Italic */
X		BOLD_FONT,			/* Palatino-Bold */
X		BOLD_FONT,			/* Palatino-BoldItalic */
X		ROMAN_FONT,			/* Symbol */
X		ROMAN_FONT,			/* ZapfChancery-MediumItalic */
X		ROMAN_FONT			/* ZapfDingbats */
X		};
X
X#define	NO	2
X#define	FALSE	0
X#define	TRUE	1
X
Xstatic int	PSmapwarn[] = {
X		FALSE, FALSE,			/* Times-Roman */
X		FALSE,				/* Times-Italic */
X		FALSE,				/* Times-Bold */
X		FALSE,				/* Times-BoldItalic */
X		TRUE,				/* AvantGarde */
X		TRUE,				/* AvantGarde-BookOblique */
X		TRUE,				/* AvantGarde-Demi */
X		TRUE,				/* AvantGarde-DemiOblique */
X		TRUE,				/* Bookman-Light */
X		TRUE,				/* Bookman-LightItalic */
X		TRUE,				/* Bookman-Demi */
X		TRUE,				/* Bookman-DemiItalic */
X		FALSE,				/* Courier */
X		TRUE,				/* Courier-Oblique */
X		TRUE,				/* Courier-Bold */
X		TRUE,				/* Courier-BoldItalic */
X		FALSE,				/* Helvetica */
X		TRUE,				/* Helvetica-Oblique */
X		TRUE,				/* Helvetica-Bold */
X		TRUE,				/* Helvetica-BoldOblique */
X		TRUE,				/* Helvetica-Narrow */
X		TRUE,				/* Helvetica-Narrow-Oblique */
X		TRUE,				/* Helvetica-Narrow-Bold */
X		TRUE,			/* Helvetica-Narrow-BoldOblique */
X		TRUE,				/* NewCenturySchlbk-Roman */
X		TRUE,				/* NewCenturySchlbk-Italic */
X		TRUE,				/* NewCenturySchlbk-Bold */
X		TRUE,			/* NewCenturySchlbk-BoldItalic */
X		TRUE,				/* Palatino-Roman */
X		TRUE,				/* Palatino-Italic */
X		TRUE,				/* Palatino-Bold */
X		TRUE,				/* Palatino-BoldItalic */
X		TRUE,				/* Symbol */
X		TRUE,				/* ZapfChancery-MediumItalic */
X		TRUE				/* ZapfDingbats */
X		};
X
Xint	        PSisomap[] = {
X		FALSE, FALSE,			/* Times-Roman */
X		FALSE,				/* Times-Italic */
X		FALSE,				/* Times-Bold */
X		FALSE,				/* Times-BoldItalic */
X		FALSE,				/* AvantGarde */
X		FALSE,				/* AvantGarde-BookOblique */
X		FALSE,				/* AvantGarde-Demi */
X		FALSE,				/* AvantGarde-DemiOblique */
X		FALSE,				/* Bookman-Light */
X		FALSE,				/* Bookman-LightItalic */
X		FALSE,				/* Bookman-Demi */
X		FALSE,				/* Bookman-DemiItalic */
X		FALSE,				/* Courier */
X		FALSE,				/* Courier-Oblique */
X		FALSE,				/* Courier-Bold */
X		FALSE,				/* Courier-BoldItalic */
X		FALSE,				/* Helvetica */
X		FALSE,				/* Helvetica-Oblique */
X		FALSE,				/* Helvetica-Bold */
X		FALSE,				/* Helvetica-BoldOblique */
X		FALSE,				/* Helvetica-Narrow */
X		FALSE,				/* Helvetica-Narrow-Oblique */
X		FALSE,				/* Helvetica-Narrow-Bold */
X		FALSE,			/* Helvetica-Narrow-BoldOblique */
X		FALSE,				/* NewCenturySchlbk-Roman */
X		FALSE,				/* NewCenturySchlbk-Italic */
X		FALSE,				/* NewCenturySchlbk-Bold */
X		FALSE,			/* NewCenturySchlbk-BoldItalic */
X		FALSE,				/* Palatino-Roman */
X		FALSE,				/* Palatino-Italic */
X		FALSE,				/* Palatino-Bold */
X		FALSE,				/* Palatino-BoldItalic */
X		NO,				/* Symbol */
X		FALSE,				/* ZapfChancery-MediumItalic */
X		NO				/* ZapfDingbats */
X		};
X
Xstatic char *figfontnames[] = {
X		"Roman", "Roman",
X		"Roman", 
X		"Bold",
X		"Italic",
X		"Modern",
X		"Typewriter"
X		};
X
Xvoid unpsfont(t)
XF_text	*t;
X{
X	if (!psfont_text(t)) return;
X	if (PSmapwarn[t->font+1])
X	  fprintf(stderr, "PS fonts not supported; substituting %s for %s\n",
X		figfontnames[PSfontmap[t->font+1]+1], PSfontnames[t->font+1]);
X	t->font = PSfontmap[t->font+1];
X}
X
END_OF_FILE
if test 6461 -ne `wc -c <'fig2dev/psfonts.c'`; then
    echo shar: \"'fig2dev/psfonts.c'\" unpacked with wrong size!
fi
# end of 'fig2dev/psfonts.c'
fi
if test -f 'transfig/mkfile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'transfig/mkfile.c'\"
else
echo shar: Extracting \"'transfig/mkfile.c'\" \(5471 characters\)
sed "s/^X//" >'transfig/mkfile.c' <<'END_OF_FILE'
X/*
X * TransFig: Facility for Translating Fig code
X * Copyright (c) 1985 Supoj Sutantavibul
X * Copyright (c) 1991 Micah Beck
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation. The authors make no representations about the suitability 
X * of this software for any purpose.  It is provided "as is" without express 
X * or implied warranty.
X *
X * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
X * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
X * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X *
X */
X
X#include <stdio.h>
X#include "transfig.h"
X
X/*
X * create an appropriate makefile
X */
Xmakefile(mk, altfonts, arg_list)
XFILE *mk;
Xint  altfonts;
Xargument *arg_list;
X{
X  argument *a;
X  char *i;
X  enum language to;
X  int needps, needpic, needfig;
X  
X
X  fprintf(mk, "#\n# TransFig makefile\n#\n");
X
X  fprintf(mk, "\nall: ");
X  for (a = arglist; a; a = a->next)
X    	fprintf(mk, "%s.tex ", a->name);
X  fprintf(mk, "\n");
X
X  for (a = arglist; a; a = a->next)
X  {
X	i = a->name;
X	to = a->tolang;
X
X	needps = needpic = needfig = 0;
X
X	fprintf(mk, "\n# translation into %s\n\n", lname[(int)to]);
X
X	switch (to)
X	{
X	case box:
X		putfig(mk, box, altfonts, NULL, NULL, a->m, NULL, i, "tex");
X		needfig = 1;
X		break;
X
X	case eepicemu:
X	case epic:
X	case eepic:
X		putfig(mk, to, altfonts, a->f, a->s, a->m, a->o, i, "tex");
X		needfig = 1;
X		break;
X
X	case latex:
X		putfig(mk, latex, altfonts, a->f, a->s, a->m, a->o, i, "tex");
X		needfig = 1;
X		break;
X
X	case pictex:
X		putfig(mk, pictex, altfonts, a->f, a->s, a->m, a->o, i, "tex");
X		needfig = 1;
X		break;
X
X	case postscript:
X                puttarget(mk, i, "tex", "ps");
X                fprintf(mk, "\tfig2ps2tex %s.ps >%s.tex\n", i, i);
X		needps = 1;
X                break;
X
X        case psfig:
X                puttarget(mk, i, "tex", "ps");
X		fprintf(mk,"\techo '\\strut\\psfig{figure=%s.ps}' >%s.tex\n",
X                          i, i);
X		needps = 1;
X                break;
X
X	case pstex:
X
X		/*
X		 * The makefile for the pstex need to update two files.
X		 * file.ps with is created using fig2dev -L texps file.fig
X		 * and
X		 * file.tex with fig2dev -L pstex -p file.ps file.fig
X		 * 
X		 */
X		puttarget(mk, i, "tex", "ps");
X		fprintf(mk, "\tfig2dev -L pstex_t -p %s.ps ", i);
X		putoptions(mk, altfonts, a->f, a->s, a->m, a->o, i, "tex");
X		needps = 1;
X		break;
X
X	case textyl:
X		putfig(mk, textyl, altfonts, a->f, a->s, a->m, a->o, i, "tex");
X		needfig = 1;
X		break;
X
X	case tpic:
X		puttarget(mk, i, "tex", "pic");
X		/* fprintf(mk, "\ttpic %s.pic\n", i); */
X		fprintf(mk, "\tpic2tpic %s.pic | tpic > %s.tex\n", i, i);
X		fprintf(mk, "\techo \'\\strut\\box\\graph\' >>%s.tex\n", i);
X		needpic = 1;
X		break;
X
X	}
X
X	putclean(mk, i, "tex" );
X
X	/* conversion to postscript */
X	if (needps && a->type != ps) {
X		if ( a->tops ) {
X		    puttarget(mk, i, "ps", iname[(int)a->type]);
X		    fprintf(mk, "\t%s %s.%s > %s.ps\n", a->tops, i, iname[(int)a->type], i);
X		}
X		else {
X                    putfig(mk, (to == pstex ? pstex : postscript), 
X			   altfonts, a->f, a->s, a->m, a->o, i, "ps");
X                    a->interm = mksuff(i, ".ps");
X		    needfig = 1;
X		}
X		putclean(mk, i, "ps" );
X	}
X
X	/* conversion to pic */
X	if (needpic && a->type != pic) {
X		if ( a->topic ) {
X		    puttarget(mk, i, "pic", iname[(int)a->type]);
X		    fprintf(mk, "\t%s %s.%s > %s.pic\n", a->topic, i, iname[(int)a->type],i);
X		}
X		else {
X		    putfig(mk, tpic, altfonts, a->f, a->s, a->m, a->o, i, "pic");
X
X		    needfig = 1;
X		}
X		putclean(mk, i, "pic" );
X	}
X
X	/* conversion to fig */
X	if (needfig && a->type != fig) {
X		if ( a->tofig ) {
X		    puttarget(mk, i, "fig", iname[(int)a->type]);
X		    fprintf(mk, "\t%s %s.%s > %s.fig\n", a->tofig, i, iname[(int)a->type],i);
X		    a->interm = mksuff(i, ".fig");
X		}
X		else {
X		    fprintf(stderr, "transfig: warning: don't now how to make %s\n", mksuff(i, ".fig") );
X		}
X		putclean(mk, i, "fig" );
X	}
X  }
X}
X
Xputtarget(mk, i, suf1, suf2)
XFILE *mk;
Xchar *i, *suf1, *suf2;
X{
X    fprintf(mk, "%s.%s: %s.%s %s\n", i, suf1, i, suf2, mkfile);
X}
X
Xputfig(mk, to, altfonts, f, s, m, o, i, suf)
XFILE *mk;
Xenum language to;
Xint altfonts;
Xchar *f, *s, *m, *o, *i, *suf;
X{
X  fprintf(mk, "%s%s%s: %s.fig %s\n",
X	       i, (suf ? "." : ""), (suf ? suf : ""), i, mkfile);
X
X  if ( to == tpic )
X	  fprintf(mk, "\tfig2dev -L pic ");
X  else
X	  fprintf(mk, "\tfig2dev -L %s ", lname[(int)to]);
X
X  putoptions(mk, altfonts, f, s, m, o, i, suf);
X}
X
Xputoptions(mk, altfonts, f, s, m, o, i, suf)
XFILE *mk;
Xint altfonts;
Xchar *f, *s, *m, *o, *i, *suf;
X{
X  if (altfonts==1) fprintf(mk, "-a ");
X  if (f && *f) fprintf(mk, "-f %s ", f);
X  if (s && *s) fprintf(mk, "-s %s ", s);
X  if (m && *m) fprintf(mk, "-m %s ", m);
X  if (o && *o) fprintf(mk, "%s ", o);
X
X  fprintf(mk, "%s.fig > %s%s%s\n", i, i, (suf ? "." : ""), (suf ? suf : ""));
X}
X
Xputclean(mk, i, suf)
XFILE *mk;
Xchar *i, *suf;
X{
X   fprintf(mk, "clean::\n");
X   fprintf(mk, "\trm -f %s.%s\n", i, suf);
X   fprintf(mk, "\n");
X}
END_OF_FILE
if test 5471 -ne `wc -c <'transfig/mkfile.c'`; then
    echo shar: \"'transfig/mkfile.c'\" unpacked with wrong size!
fi
# end of 'transfig/mkfile.c'
fi
if test -f 'transfig/transfig.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'transfig/transfig.c'\"
else
echo shar: Extracting \"'transfig/transfig.c'\" \(4940 characters\)
sed "s/^X//" >'transfig/transfig.c' <<'END_OF_FILE'
X/*
X * TransFig: Facility for Translating Fig code
X * Copyright (c) 1985 Supoj Sutantavibul
X * Copyright (c) 1991 Micah Beck
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation. The authors make no representations about the suitability 
X * of this software for any purpose.  It is provided "as is" without express 
X * or implied warranty.
X *
X * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
X * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
X * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X *
X */
X
X/*
X * transfig: 	figure translation setup program
X *		creates TeX macro file and makefile
X *
X * usage: transfig <option> ... [[<flag> ... ] [<figure>] ... ] ...
X *
X * where:	<option> = -L <language> | -M <makefile> | -T <texfile>
X *		<flag>	 = -f <font> | -s <size> | -m <scale>
X */
X
X#include <stdio.h>
X#include "patchlevel.h"
X#include "transfig.h"
X
X
Xargument *parse_arg(), *arglist = NULL, *lastarg = NULL;
Xchar *strip();
X
Xchar *mkfile = "Makefile";
Xchar *txfile = "transfig.tex";
Xchar *input = "";
Xint  altfonts = 0;
X
Xchar *lname[] = {
X	"box",
X	"epic",
X	"eepic",
X	"eepicemu",
X	"latex",
X	"pictex",
X	"ps",
X	"psfig",
X	"pstex",
X	"textyl",
X	"tpic"};
X
X/* enum input {apg, fig, pic, ps}; */
Xchar *iname[] = {
X	"apg",
X	"fig",
X  	"pic",
X	"ps"};
X 
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X  FILE *mk, *tx;
X  enum language tolang = epic;
X  argument *a;
X  char c, *cp; 
X  char *arg_f = NULL, *arg_s = NULL, *arg_m = NULL, *arg_o = NULL, *argbuf;
X
X  for ( optind = 1; optind < argc; optind++ ) {
X    cp = argv[optind];
X    if (*cp == '-')
X    {
X  	if (!cp[1])
X	{
X		fprintf(stderr, "transfig: bad option format '-'\n");
X		exit(1);
X	}
X	if (cp[1] == 'V') 
X	{
X		fprintf(stderr, "TransFig Version %s Patchlevel %s\n",
X							VERSION, PATCHLEVEL);
X		exit(0);
X	}
X	if (cp[2])
X	{
X		optarg = &cp[2];
X	} else
X	{
X		if (cp[1] != 'a') {
X			optind += 1;
X			if (optind == argc)
X			{
X				fprintf(stderr,
X					"transfig: no value for '%c' arg\n", cp[1]);
X				exit(1);
X			}
X			optarg = argv[optind];
X		}
X	}
X 	switch (cp[1]) {
X
X	case 'I':
X		input = optarg;
X		break;
X
X  	case 'L':
X		tolang = str2lang(optarg);
X		break;
X  	case 'M':
X		mkfile = optarg;
X		break;
X  	case 'T':
X		txfile = optarg;
X		break;
X	case 'a':
X		altfonts = 1;
X		break;
X	case 'f':
X		arg_f = optarg;
X		break;
X	case 's':
X		arg_s = optarg;	
X		break;
X	case 'm':
X		arg_m = optarg;	
X		break;
X
X	case 'o':
X		arg_o = optarg;
X		break;
X
X  	default:
X		fprintf(stderr, "transfig: illegal option -- '%c'\n", cp[1]);
X		exit(1);
X  	}
X    } else
X    {
X	a = parse_arg(tolang, arg_f, arg_s, arg_m, arg_o, argv[optind]);
X
X	if ( !lastarg )
X		arglist = a;
X	else
X		lastarg->next = a; 
X	lastarg = a;
X    }
X  }
X
X  /* no files specified -> all files */
X  if (!arglist)
X  {
X	argbuf = sysls();
X	while (cp = strchr(argbuf, '\n'))
X	{
X		*cp = '\0';
X		a = parse_arg(tolang, arg_f, arg_s, arg_m, arg_o, argbuf);
X		if ( !lastarg )
X			arglist = a;
X		else
X			lastarg->next = a; 
X		lastarg = a;
X		argbuf = cp+1;
X	}
X  }
X
X  sysmv(txfile);
X  tx = fopen(txfile, "w");
X  texfile(tx, input, altfonts, arglist);
X
X  sysmv(mkfile);
X  mk = fopen(mkfile, "w");
X  makefile(mk, altfonts, arglist);
X  exit(0);
X}
X
Xenum language str2lang(s)
Xchar *s;
X{
X  int i;
X
X  /* aliases */
X  if (!strcmp(s, "pic")) return tpic;
X  if (!strcmp(s, "postscript")) return postscript;
X  if (!strcmp(s, "latexps")) return pstex;
X  if (!strcmp(s, "null")) return box;
X
X  /* real names*/
X  for (i = 0; i <= (int)MAXLANG; i++)
X	if (!strcmp(lname[i], s)) return (enum language)i;
X
X  /* other strings */
X  fprintf(stderr, "Unknown output language \"%s\"\n", s);
X  exit(1);
X}
X
Xargument *parse_arg(tolang, arg_f, arg_s, arg_m, arg_o, arg)
Xenum language tolang;
Xchar *arg_f, *arg_s, *arg_m, *arg_o, *arg;
X{
X  argument *a;
X
X  a = (argument *)malloc(sizeof(argument));
X  a->f = arg_f;
X  a->s = arg_s;
X  a->m = arg_m;
X  a->o = arg_o;
X  a->next = NULL;
X  a->tofig = NULL;
X  a->topic = NULL;
X  a->tops = NULL;
X  a->tolang = tolang;
X  
X  /* PIC */
X  if (strip(arg, ".pic"))
X  {
X  	a->name = mksuff(arg, "");
X  	a->type = pic;
X	a->tofig = PIC2FIG;
X	return a;
X  }
X
X  /* PS format */
X  if (strip(arg, ".ps"))
X  {
X  	a->name = mksuff(arg, "");
X  	a->type = ps;
X 	return a;
X  }
X
X  /* ApGraph format */
X  if (strip(arg, ".apg"))
X  {
X  	a->name = mksuff(arg, "");
X  	a->type = apg;
X	a->tofig = APG2FIG;
X 	return a;
X  }
X
X  /* Fig format */
X  strip(arg, ".fig");
X  a->name = mksuff(arg, "");
X  a->type = fig;
X  return a;
X}
END_OF_FILE
if test 4940 -ne `wc -c <'transfig/transfig.c'`; then
    echo shar: \"'transfig/transfig.c'\" unpacked with wrong size!
fi
# end of 'transfig/transfig.c'
fi
echo shar: End of archive 2 \(of 7\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
