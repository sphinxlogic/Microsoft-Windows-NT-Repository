Newsgroups: comp.sources.unix
From: envbvs@epb12.lbl.gov (Brian V. Smith)
Subject: v27i061: transfig-2.1.8 - a set of tools for creating TeX documents with graphics, Part07/07
References: <1.749903574.10622@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: envbvs@epb12.lbl.gov (Brian V. Smith)
Posting-Number: Volume 27, Issue 61
Archive-Name: transfig-2.1.8/part07

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 7)."
# Contents:  fig2dev/dev/genepic.c fig2dev/dev/genps.c
# Wrapped by envbvs@epb12.lbl.gov.lbl.gov on Fri Oct  1 14:55:51 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'fig2dev/dev/genepic.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fig2dev/dev/genepic.c'\"
else
echo shar: Extracting \"'fig2dev/dev/genepic.c'\" \(30473 characters\)
sed "s/^X//" >'fig2dev/dev/genepic.c' <<'END_OF_FILE'
X/*
X * TransFig: Facility for Translating Fig code
X * Copyright (c) 1985 Supoj Sutantavibul
X * Copyright (c) 1991 Micah Beck
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation. The authors make no representations about the suitability 
X * of this software for any purpose.  It is provided "as is" without express 
X * or implied warranty.
X *
X * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
X * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
X * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X *
X */
X
X/*
X * genepic.c: (E)EPIC driver for fig2dev
X *
X * Converted from fig2epic 5/89 by Micah Beck
X */
X/*==================================================================*/
X/*	fig2epic (Fig to EPIC converter) 			    */
X/*	     Version 1.1d <March 30, 1988>			    */
X/*								    */
X/*	Written by Conrad Kwok, Division of Computer Science, UCD   */
X/*								    */
X/*	Permission is granted for freely distribution of this file  */
X/*		provided that this message is included.		    */
X/*==================================================================*/
X
X/*====================================================================
X  Changes:
X
X  Version 1.0d:<September 18, 1988>
X  1. Add the option -P for Page mode. Two more configurable parameter---
X     Preamble and Postamble.
X
X  Version 1.1a: <January 18, 1989>
X  1. Fix the bug in closed control splines. The routine convertCS(p) is being
X     called once too often.
X
X  2. Add supports to Variable line width
X  3. Add supports to black, white or shaded area fill.
X
X  Version 1.1b: <Febrary 2, 1989>
X  1. Draw outline for area-filled figures when using dvips.
X
X  Version 1.1c: <Febrary 7, 1989>
X  1. Supports all 5 gray level in area fill.
X
X  Version 1.1d: <March 30, 1989>
X  1. Add supports for Gould NP1 (Bsd4.3) (Recieve the changes from
X		mcvax!presto.irisa.fr!hleroy@uunet.uu.net. Sorry
X		I don't have his/her name)
X  2. Add exit(0) before exit in the main.
X====================================================================*/
X
X  
X#include <stdio.h>
X#include <math.h>
X#include <varargs.h>
X#include <ctype.h>
X#include "object.h"
X#include "fig2dev.h"
X#include "texfonts.h"
X#include "pi.h"
X
X#ifdef MSDOS
X#define getopt egetopt
X#define M_PI 3.14159265358979324
X#endif
X
X#define DrawOutLine
X#ifdef DrawOutLine
Xint OutLine=0;
X#endif
X
X#define TopCoord 840		/* 10.5 in * 80 (DPI)            */
X				/* Actually, it can be any value */
X#define PtPerLine 3
X#define ThinLines 0
X#define ThickLines 1
X#define FALSE 0
X#define TRUE 1
X#define Epic 0
X#define EEpic_emu 1
X#define EEpic 2
X#define None 0
X#define SolidLineBox 1
X#define DashLineBox 2
X#define BothBoxType 3
X#define Normal 0
X#define Economic 1
X#define DottedDash 2
X
Xvoid genepic_ctl_spline(), genepic_int_spline(); 
Xvoid genepic_open_spline(), genepic_closed_spline(); 
X
X/* Structure for Point with "double" values */
Xstruct fp_struct {
X    double x,y;
X};
X
Xtypedef struct fp_struct FPoint;
X
X/* Local to the file only */
Xstatic int coord_system;
Xstatic int CoordSys = 2;
Xstatic double Threshold;
Xstatic int DPI;
Xstatic int CurWidth = 0;
Xstatic int LineStyle = SOLID_LINE;
Xstatic int LLX = 0, LLY = 0;
Xstatic char *LnCmd;
Xstatic int MaxCircleRadius;
Xstatic double DashLen;
Xstatic int PageMode = FALSE;
Xstatic int PatternType=UNFILLED;
Xstatic struct {
X    double mag;
X    int size;
X} ScaleTbl[5] = {
X    { 0.6667, 8 },
X    { 0.75  , 9 },
X    { 0.8333, 10 },
X    { 0.9167, 11 },
X    { 1.0   , 12 }
X};
X
X/* Definition of Keywords for some of the configurable parameter */
Xchar *Tlangkw[] = { /* The order must match the definition of corr. constants */
X    "Epic", "EEpicemu", "EEpic", NULL
X};
X
Xchar *EllCmdkw[] = {
X    "ellipse", "oval", NULL
X};
X
Xchar *EllCmdstr[] = {
X    "\\%s%s{%d}{%d}}\n", "\\%s%s(%d,%d)}\n"
X};
X
Xchar *FillCommands[] = {
X    "", "\\whiten",
X    "\\shade", "\\shade", "\\shade",
X    "\\shade", "\\shade", "\\shade",
X    "\\shade", "\\shade", "\\shade",
X    "\\shade", "\\shade", "\\shade",
X    "\\shade", "\\shade", "\\shade",
X    "\\shade", "\\shade", "\\shade",
X    "\\shade", "\\blacken"
X};
X
X#define TEXT_LINE_SEP '\n'
X/* The following two arrays are used to translate characters which
X   are special to LaTeX into characters that print as one would expect.
X   Note that the <> characters aren't really special LaTeX characters
X   but they will not print as themselves unless one is using a font
X   like tt. */
Xchar latex_text_specials[] = "\\{}><^~$&#_%";
Xchar *latex_text_mappings[] = {
X  "$\\backslash$",
X  "$\\{$",
X  "$\\}$",
X  "$>$",
X  "$<$",
X  "\\^{}",
X  "\\~{}",
X  "\\$",
X  "\\&",
X  "\\#",
X  "\\_",
X  "\\%"};
X
X
X/* Configurable parameters */
Xint LowerLeftX=0, LowerLeftY=0;
Xdouble SegLen = 0.0625; /* inch */
Xint Verbose = FALSE;
Xint TopMargin = 5;
Xint BottomMargin = 10;
Xint DotDist = 5;
Xint LineThick = 2;
Xint TeXLang = EEpic;
Xdouble DashScale=1;
Xint EllipseCmd=0;
Xint UseBox=None;
Xint DashType=Normal;
Xchar *Preamble="\\documentstyle[epic,eepic]{article}\n\\begin{document}\n\\begin{center}\n";
Xchar *Postamble="\\end{center}\n\\end{document}\n";
Xint VarWidth=FALSE;
X
Xvoid genepic_option(opt, optarg)
Xchar opt, *optarg;
X{
X  	int loop, i;
X
X        switch (opt) {
X	case 'a':
X	    fprintf(stderr, "warning: genepic option -a obsolete");
X	    break;
X
X	case 'f':
X	    for ( i = 1; i <= MAX_FONT; i++ )
X		if ( !strcmp(optarg, texfontnames[i]) ) break;
X
X	    if ( i > MAX_FONT)
X		fprintf(stderr,
X			"warning: non-standard font name %s\n", optarg);
X	
X    	    texfontnames[0] = texfontnames[1] = optarg;
X	    break;
X
X        case 'l':
X            LineThick = atoi(optarg);
X            break;
X
X	case 'L':
X	    for (loop=0; loop < 3; loop++) {
X	    	if (stricmp(optarg, Tlangkw[loop]) == 0) break;
X	    }
X	    TeXLang = loop;
X	    break;
X
X
X	case 'm':
X	    break;
X
X	case 'P':
X	    PageMode = 1;
X	    break;
X
X	case 's':
X	    font_size = atoi(optarg);
X	    if (font_size <= 0 || font_size > MAXFONTSIZE) {
X		fprintf(stderr,
X			"warning: font size %d out of bounds\n", font_size);
X	    }
X	    break;
X
X        case 'S':
X            loop = atoi(optarg);
X            if (loop < 8 || loop > 12) {
X            	put_msg("Scale must be between 8 and 12 inclusively\n");
X            	exit(1);
X            }
X            loop -= 8;
X            mag = ScaleTbl[loop].mag;
X            font_size = ScaleTbl[loop].size;
X            break;
X
X        case 'v':
X            Verbose = TRUE;
X            break;
X
X	case 'w':
X	case 'W':
X	    VarWidth = opt=='W';
X	    break;
X
X	default:
X	    put_msg(Err_badarg, opt, "epic");
X	    exit(1);
X	    break;
X        }
X}
X
Xstatic fconvertCS(fpt)
XFPoint *fpt;
X{
X    if (CoordSys) {
X        fpt->y = TopCoord - fpt->y;
X    }
X    fpt->x -= LLX;
X    fpt->y -= LLY;
X}
X
XconvertCS(pt)
XF_point *pt;
X{
X    if (CoordSys) {
X        pt->y = TopCoord - pt->y;
X    }
X    pt->x -= LLX;
X    pt->y -= LLY;
X}
X
Xvoid genepic_start(objects)
XF_compound *objects;
X{
X    int temp;
X    F_point pt1, pt2;
X    F_arc *arc;
X    F_compound *comp;
X    F_ellipse *ell;
X    F_line *line;
X    F_spline *spl;
X    F_text *text;
X
X    texfontsizes[0] = texfontsizes[1] = TEXFONTSIZE(font_size);
X
X    switch (TeXLang) {
X    case Epic:
X        EllipseCmd = 1; /* Oval */
X        LnCmd = "drawline";
X        break;
X    case EEpic_emu:
X    case EEpic:
X        LnCmd = "path";
X        break;
X    default:
X        put_msg("Program error in main\n");
X        break;
X    }
X    if (PageMode) {
X        fputs(Preamble, stdout);
X    }
X
X    DPI = objects->nwcorner.x;
X    if (DPI <= 0) {
X        put_msg("Resolution has to be positive. Default to 80!\n");
X        DPI = 80;
X    }
X    coord_system = objects->nwcorner.y;
X    switch (coord_system) {
X    case 1:
X        CoordSys = 0;
X        break;
X    case 2:
X        CoordSys = 1;
X        break;
X    default:
X        put_msg("Unknown Coordinate system -- %d\n", coord_system);
X        exit(1);
X    }
X    pt1.x = llx;
X    pt1.y = lly;
X    pt2.x = urx;
X    pt2.y = ury;
X    convertCS(&pt1);
X    convertCS(&pt2);
X    if (pt1.x > pt2.x) {
X        temp = pt1.x;
X        pt1.x = pt2.x;
X        pt2.x = temp;
X    }
X    if (pt1.y > pt2.y) {
X        temp = pt1.y;
X        pt1.y = pt2.y;
X        pt2.y = temp;
X    }
X    LLX = pt1.x - LowerLeftX;
X    LLY = pt1.y - LowerLeftY;
X    if (Verbose) {
X        fprintf(tfp, "%%\n%% Language in use is %s\n%%\n", Tlangkw[TeXLang]);
X    }
X    Threshold = 1.0 / DPI * mag;
X    fprintf(tfp, "\\setlength{\\unitlength}{%.4fin}\n", Threshold);
X    MaxCircleRadius = (int) (40 / 72.27 / Threshold);
X    Threshold = SegLen / Threshold;
X    define_setfigfont(tfp);
X    fprintf(tfp, "\\begin{picture}(%d,%d)(%d,%d)\n",
X           pt2.x-pt1.x, pt2.y-pt1.y + TopMargin + BottomMargin,
X           LowerLeftX, LowerLeftY-BottomMargin);
X}
X
Xvoid genepic_end()
X{
X    fprintf(tfp, "\\end{picture}\n");
X    if (PageMode)
X        fputs(Postamble, stdout);
X}
X
Xstatic set_linewidth(w)
Xint w;
X{
X    int old_width;
X
X    if (w < 0) return;
X    old_width=CurWidth;
X    CurWidth = (w >= LineThick) ? (VarWidth ? w : ThickLines) : ThinLines;
X    if (old_width != CurWidth) {
X	if (CurWidth==ThinLines) {
X	    fprintf(tfp, "\\thinlines\n");
X	} else if (VarWidth) {
X	    fprintf(tfp, "\\allinethickness{%d}%%\n",w);
X	} else {
X	    fprintf(tfp, "\\thicklines\n");
X	}
X    }
X}
X
Xset_pattern(type)
Xint type;
X{
X    static unsigned long patterns[3][32] = {
X	{ 0xc0c0c0c0, 0, 0, 0, 0, 0, 0, 0,
X	  0xc0c0c0c0, 0, 0, 0, 0, 0, 0, 0,
X	  0xc0c0c0c0, 0, 0, 0, 0, 0, 0, 0,
X	  0xc0c0c0c0, 0, 0, 0, 0, 0, 0, 0},
X	{ 0xcccccccc, 0, 0, 0, 0xcccccccc, 0, 0, 0,
X	  0xcccccccc, 0, 0, 0, 0xcccccccc, 0, 0, 0,
X	  0xcccccccc, 0, 0, 0, 0xcccccccc, 0, 0, 0,
X	  0xcccccccc, 0, 0, 0, 0xcccccccc, 0, 0, 0},
X	{ 0x55555555, 0, 0x55555555, 0, 0x55555555, 0, 0x55555555, 0,
X	  0x55555555, 0, 0x55555555, 0, 0x55555555, 0, 0x55555555, 0,
X	  0x55555555, 0, 0x55555555, 0, 0x55555555, 0, 0x55555555, 0,
X	  0x55555555, 0, 0x55555555, 0, 0x55555555, 0, 0x55555555, 0}};
X    int count, loop1, loop2, i;
X
X    if (type <= WHITE_FILL || type >= BLACK_FILL) return;
X    if (type != PatternType) {
X	PatternType=type;
X	i = ((int) PatternType - WHITE_FILL - 1) / 6;
X	fprintf(tfp, "\\texture{");
X	count=0;
X	for (loop1=4; loop1>0;) {
X	    for (loop2=8; loop2>0; loop2--) 
X		fprintf(tfp, "%lx ", patterns[i][count++]);
X	    if (--loop1 > 0)
X		fprintf(tfp, "\n\t");
X	    else
X		fprintf(tfp, "}%\n");
X	}
X    }
X}
X
Xvoid genepic_line(line)
XF_line *line;
X{
X    F_point *p, *q;
X    int pt_count = 0, temp;
X    int boxflag = FALSE, llx, lly, urx, ury;
X    double dtemp;
X
X    set_linewidth(line->thickness);
X    set_style(line->style, line->style_val);
X    p = line->points;
X    q = p->next;
X    convertCS(p);
X    if (q == NULL) {
X	fprintf(tfp, "\\drawline(%d,%d)(%d,%d)\n", p->x, p->y, p->x, p->y);
X	return;
X    }
X    if (line->type == T_ARC_BOX) { /* A box with rounded corners */
X	  fprintf(stderr, "Arc box not implemented; substituting box.\n");
X	  line->type = T_BOX;
X    }
X    if (line->type == T_BOX) {
X	if (Verbose) {
X	    fprintf(tfp, "%%\n%% A box\n%%\n");
X	}
X	switch (LineStyle) {
X	case SOLID_LINE:
X	    if (UseBox == BothBoxType || UseBox == SolidLineBox) {
X	        boxflag = TRUE;
X	    }
X	    break;
X	case DASH_LINE:
X	    if (UseBox == BothBoxType || UseBox == DashLineBox) {
X	        boxflag = TRUE;
X	    }
X	    break;
X	}
X	if (boxflag) {
X	    llx = urx = p->x;
X	    lly = ury = p->y;
X	    while (q != NULL) {
X	        convertCS(q);
X	        if (q->x < llx) {
X	            llx = q->x;
X	        } else if (q->x > urx) {
X	            urx = q->x;
X	        }
X	        if (q->y < lly) {
X	            lly = q->y;
X	        } else if (q->y > ury) {
X	            ury = q->y;
X	        }
X	        q = q->next;
X	    }
X	    switch(LineStyle) {
X	    case SOLID_LINE:
X	        fprintf(tfp, "\\put(%d,%d){\\framebox(%d,%d){}}\n",
X	            llx, lly, urx-llx, ury-lly);
X	        break;
X	    case DASH_LINE:
X		temp = (int) ((urx-llx) / DashLen);
X		dtemp = (double) (urx-llx) / temp;
X	        fprintf(tfp, "\\put(%d,%d){\\dashbox{%4.3f}(%d,%d){}}\n",
X	            llx, lly, dtemp , urx-llx, ury-lly);
X	        break;
X	    default:
X	        put_msg("Program Error! No other line styles allowed.\n");
X	        break;
X	    }
X	    return;
X	  }
X    }
X    set_pattern(line->area_fill);
X    convertCS(q);
X    if (line->back_arrow) {
X	draw_arrow_head(q, p, line->back_arrow->ht, line->back_arrow->wid);
X    	if (Verbose) fprintf(tfp, "%%\n");
X    }
X    switch (LineStyle) {
X    case SOLID_LINE:
X	if (q->next != NULL && strcmp(LnCmd,"path")==0) {
X	    if (line->area_fill < UNFILLED) line->area_fill = UNFILLED;
X	    fprintf(tfp, "%s", FillCommands[line->area_fill]);
X	}
X	fprintf(tfp, "\\%s", LnCmd);
X#ifdef DrawOutLine
X	if (line->area_fill != UNFILLED && OutLine == 0) OutLine=1;
X#endif
X	break;
X    case DASH_LINE:
X        if ((TeXLang==Epic || TeXLang ==EEpic_emu) && DashType == Economic) {
X            fprintf(tfp, "\\drawline[-50]");
X        } else {
X	    fprintf(tfp, "\\dashline{%4.3f}", DashLen);
X	}
X	break;
X    case DOTTED_LINE:
X	fprintf(tfp, "\\dottedline{%d}", DotDist);
X	break;
X    default:
X	fprintf(stderr,"Unknown Style\n");
X	exit(1);
X    }
X    fprintf(tfp, "(%d,%d)", p->x, p->y);
X    pt_count++;
X    while(q->next != NULL) {
X	if (++pt_count > PtPerLine) {
X	    pt_count=1;
X	    fprintf(tfp, "\n\t");
X	}
X	fprintf(tfp, "(%d,%d)", q->x, q->y);
X	p=q;
X	q = q->next;
X	convertCS(q);
X    }
X    fprintf(tfp, "(%d,%d)\n", q->x, q->y);
X#ifdef DrawOutLine
X    if (OutLine == 1) {
X	OutLine=0;
X	fprintf(tfp, "\\%s", LnCmd);
X	p=line->points;
X	pt_count=0;
X	q=p->next;
X	fprintf(tfp, "(%d,%d)", p->x, p->y);
X	pt_count++;
X	while(q->next != NULL) {
X	    if (++pt_count > PtPerLine) {
X		pt_count=1;
X		fprintf(tfp, "\n\t");
X	    }
X	    fprintf(tfp, "(%d,%d)", q->x, q->y);
X	    p=q;
X	    q = q->next;
X	}
X	fprintf(tfp, "(%d,%d)\n", q->x, q->y);
X    }
X#endif
X    if (line->for_arrow) {
X	draw_arrow_head(p, q, line->for_arrow->ht, line->for_arrow->wid);
X    	if (Verbose) fprintf(tfp, "%%\n");
X    }
X}
X
Xset_style(style, dash_len)
Xint style;
Xfloat dash_len;
X{
X    LineStyle = style;
X    if (LineStyle == DASH_LINE) {
X        switch (DashType) {
X        case DottedDash:
X            LineStyle = DOTTED_LINE;
X            break;
X        default:
X            DashLen = dash_len * DashScale;
X            break;
X        }
X    }
X}
X
X
Xvoid genepic_spline(spl)
XF_spline *spl;
X{
X    set_linewidth(spl->thickness);
X    set_style(SOLID_LINE, 0.0);
X    if (int_spline(spl)) {
X	genepic_itp_spline(spl);
X    } else {
X	genepic_ctl_spline(spl);
X    }
X}
X
Xvoid genepic_ctl_spline(spl)
XF_spline *spl;
X{
X    if (closed_spline(spl)) {
X	genepic_closed_spline(spl);
X    } else {
X	genepic_open_spline(spl);
X    }
X}
X
Xstatic void genepic_open_spline(spl)
XF_spline *spl;
X{
X    F_point *p, *q, *r;
X    FPoint first, mid;
X    int pt_count = 0;
X
X    p = spl->points;
X    q = p->next;
X    convertCS(p);
X    convertCS(q);
X    if (spl->back_arrow) {
X	draw_arrow_head(q, p, spl->back_arrow->ht, spl->back_arrow->wid);
X    	if (Verbose) fprintf(tfp, "%%\n");
X    }
X    if (q->next == NULL) {
X	fprintf(tfp, "\\%s(%d,%d)(%d,%d)\n", LnCmd,
X	       p->x, p->y, q->x, q->y);
X	return;
X    }
X    if (TeXLang == EEpic || TeXLang == EEpic_emu) {
X        fprintf(tfp, "\\spline(%d,%d)\n", p->x, p->y);
X        pt_count++;
X        while(q->next != NULL) {
X             if (++pt_count > PtPerLine) {
X                 pt_count=1;
X                 fprintf(tfp, "\n\t");
X             }
X             fprintf(tfp, "(%d,%d)", q->x, q->y);
X             p=q;
X             q = q->next;
X             convertCS(q);
X        }
X        fprintf(tfp, "(%d,%d)\n", q->x, q->y);
X    } else {
X        fprintf(tfp, "\\%s(%d,%d)\n", LnCmd, p->x, p->y);
X        r = q->next;
X        convertCS(r);
X        first.x = p->x;
X        first.y = p->y;
X        while (r->next != NULL) {
X            mid.x = (q->x + r->x) / 2.0;
X            mid.y = (q->y + r->y) / 2.0;
X            chaikin_curve(first.x, first.y, (double) q->x, (double) q->y,
X                            mid.x, mid.y);
X            first = mid;
X            q=r;
X            r = r->next;
X            convertCS(r);
X        }
X        chaikin_curve(first.x, first.y, (double) q->x, (double) q->y,
X                        (double) r->x, (double) r->y);
X        p=q;
X        q=r;
X	fprintf(tfp, "\n");
X    }
X    if (spl->for_arrow) {
X	draw_arrow_head(p, q, spl->for_arrow->ht, spl->for_arrow->wid);
X    	if (Verbose) fprintf(tfp, "%%\n");
X    }
X}
X
Xstatic void genepic_closed_spline(spl)
XF_spline *spl;
X{
X    F_point *p;
X    double cx1, cy1, cx2, cy2, cx3, cy3, cx4, cy4;
X    double x1, y1, x2, y2;
X
X    p = spl->points;
X    convertCS(p);
X    x1 = p->x;  y1 = p->y;
X    p = p->next;
X    convertCS(p);
X    x2 = p->x;  y2 = p->y;
X    cx1 = (x1 + x2) / 2;      cy1 = (y1 + y2) / 2;
X    cx2 = (x1 + 3 * x2) / 4;  cy2 = (y1 + 3 * y2) / 4;
X    for (p = p->next; p != NULL; p = p->next) {
X	fprintf(tfp, "\\%s(%.3f,%.3f)", LnCmd, cx1, cy1);
X	x1 = x2;  y1 = y2;
X	convertCS(p);
X	x2 = p->x;  y2 = p->y;
X	cx3 = (3 * x1 + x2) / 4;  cy3 = (3 * y1 + y2) / 4;
X	cx4 = (x1 + x2) / 2;      cy4 = (y1 + y2) / 2;
X	quadratic_spline(cx1, cy1, cx2, cy2, cx3, cy3, cx4, cy4);
X	fprintf(tfp, "\n");
X	cx1 = cx4;  cy1 = cy4;
X	cx2 = (x1 + 3 * x2) / 4;  cy2 = (y1 + 3 * y2) / 4;
X    }
X    x1 = x2;  y1 = y2;
X    p = spl->points->next;
X    x2 = p->x;  y2 = p->y;
X    cx3 = (3 * x1 + x2) / 4;  cy3 = (3 * y1 + y2) / 4;
X    cx4 = (x1 + x2) / 2;      cy4 = (y1 + y2) / 2;
X    fprintf(tfp, "\\%s(%.3f,%.3f)", LnCmd, cx1, cy1);
X    quadratic_spline(cx1, cy1, cx2, cy2, cx3, cy3, cx4, cy4);
X    fprintf(tfp, "\n");
X}
X
Xchaikin_curve(a1, b1, a2, b2, a3, b3)
Xdouble a1, b1, a2, b2, a3, b3;
X{
X    double xm1, xmid, xm2, ym1, ymid, ym2;
X
X    if (fabs(a1-a3) < Threshold && fabs(b1-b3) < Threshold) {
X        fprintf(tfp, "\t(%.3f,%.3f)\n", a3, b3);
X    } else {
X        xm1 = (a1 + a2) / 2;
X        ym1 = (b1 + b2) / 2;
X        xm2 = (a2 + a3) / 2;
X        ym2 = (b2 + b3) / 2;
X        xmid = (xm1 + xm2) / 2;
X        ymid = (ym1 + ym2) / 2;
X        chaikin_curve(a1, b1, xm1, ym1, xmid, ymid);
X        chaikin_curve(xmid, ymid, xm2, ym2, a3, b3);
X    }
X}
X
Xstatic quadratic_spline(a1, b1, a2, b2, a3, b3, a4, b4)
Xdouble	a1, b1, a2, b2, a3, b3, a4, b4;
X{
X    double	x1, y1, x4, y4;
X    double	xmid, ymid;
X
X    x1 = a1; y1 = b1;
X    x4 = a4; y4 = b4;
X
X    xmid = (a2 + a3) / 2;
X    ymid = (b2 + b3) / 2;
X    if (fabs(x1 - xmid) < Threshold && fabs(y1 - ymid) < Threshold) {
X	fprintf(tfp, "\t(%.3f,%.3f)\n", xmid, ymid);
X    } else {
X	quadratic_spline(x1, y1, ((x1+a2)/2), ((y1+b2)/2),
X			 ((3*a2+a3)/4), ((3*b2+b3)/4), xmid, ymid);
X    }
X
X    if (fabs(xmid - x4) < Threshold && fabs(ymid - y4) < Threshold) {
X	fprintf(tfp, "\t(%.3f,%.3f)\n", x4, y4);
X    } else {
X	quadratic_spline(xmid, ymid, ((a2+3*a3)/4), ((b2+3*b3)/4),
X			 ((a3+x4)/2), ((b3+y4)/2), x4, y4);
X    }
X}
X
Xgenepic_itp_spline(spl)
XF_spline *spl;
X{
X    F_point *p1, *p2;
X    FPoint pt1l, pt1r, pt2l, pt2r, tmpfpt;
X    F_control *cp1, *cp2;
X
X    p1 = spl->points;
X    convertCS(p1);
X    cp1 = spl->controls;
X    pt1l.x = cp1->lx;
X    pt1l.y = cp1->ly;
X    pt1r.x = cp1->rx;
X    pt1r.y = cp1->ry;
X    fconvertCS(&pt1l);
X    fconvertCS(&pt1r);
X
X    if (spl->back_arrow) {
X	tmpfpt.x = p1->x;
X	tmpfpt.y = p1->y;
X	fdraw_arrow_head(&pt1r, &tmpfpt, 
X		spl->back_arrow->ht, spl->back_arrow->wid);
X    	if (Verbose) fprintf(tfp, "%%\n");
X    }
X
X    for (p2 = p1->next, cp2 = cp1->next; p2 != NULL;
X	 p1 = p2, pt1r = pt2r, p2 = p2->next, cp2 = cp2->next) {
X	fprintf(tfp, "\\%s(%d,%d)", LnCmd, p1->x, p1->y);
X	convertCS(p2);
X	pt2l.x = cp2->lx;
X	pt2l.y = cp2->ly;
X	pt2r.x = cp2->rx;
X	pt2r.y = cp2->ry;
X	fconvertCS(&pt2l);
X	fconvertCS(&pt2r);
X	bezier_spline((double) p1->x, (double) p1->y,
X		      pt1r.x, pt1r.y,
X		      pt2l.x, pt2l.y,
X		      (double) p2->x, (double) p2->y);
X	fprintf(tfp, "\n");
X    }
X
X    if (spl->for_arrow) {
X	tmpfpt.x = p1->x;
X	tmpfpt.y = p1->y;
X	fdraw_arrow_head(&pt2l, &tmpfpt, 
X			 spl->for_arrow->ht, spl->for_arrow->wid);
X	if (Verbose) fprintf(tfp, "%%\n");
X    }
X}
X
Xstatic bezier_spline(a0, b0, a1, b1, a2, b2, a3, b3)
Xdouble	a0, b0, a1, b1, a2, b2, a3, b3;
X{
X    double	x0, y0, x3, y3;
X    double	sx1, sy1, sx2, sy2, tx, ty, tx1, ty1, tx2, ty2, xmid, ymid;
X
X    x0 = a0; y0 = b0;
X    x3 = a3; y3 = b3;
X    if (fabs(x0 - x3) < Threshold && fabs(y0 - y3) < Threshold) {
X	fprintf(tfp, "\t(%.3f,%.3f)\n", x3, y3);
X    } else {
X	tx = (a1 + a2) / 2;		ty = (b1 + b2) / 2;
X	sx1 = (x0 + a1) / 2;	sy1 = (y0 + b1) / 2;
X	sx2 = (sx1 + tx) / 2;	sy2 = (sy1 + ty) / 2;
X	tx2 = (a2 + x3) / 2;	ty2 = (b2 + y3) / 2;
X	tx1 = (tx2 + tx) / 2;	ty1 = (ty2 + ty) / 2;
X	xmid = (sx2 + tx1) / 2;	ymid = (sy2 + ty1) / 2;
X
X	bezier_spline(x0, y0, sx1, sy1, sx2, sy2, xmid, ymid);
X	bezier_spline(xmid, ymid, tx1, ty1, tx2, ty2, x3, y3);
X    }
X}
X
Xvoid genepic_ellipse(ell)
XF_ellipse *ell;
X{
X    F_point pt;
X
X    set_linewidth(ell->thickness);
X    pt.x = ell->center.x;
X    pt.y = ell->center.y;
X    convertCS(&pt);
X    if (TeXLang == EEpic || TeXLang == EEpic_emu ||
X	  ell->radiuses.x != ell->radiuses.y ||
X          ell->radiuses.x > MaxCircleRadius) {
X	set_pattern(ell->area_fill);
X        fprintf(tfp, "\\put(%d,%d){", pt.x, pt.y );
X#ifndef OLDCODE
X        if (EllipseCmd == 0) {
X	    if (ell->area_fill < UNFILLED) ell->area_fill = UNFILLED;
X	    fprintf(tfp, "%s", FillCommands[ell->area_fill]);
X#  ifdef DrawOutLine
X	    if (ell->area_fill != UNFILLED && OutLine == 0) OutLine = 1;
X#  endif
X        }
X 	fprintf(tfp, EllCmdstr[EllipseCmd],EllCmdkw[EllipseCmd], "",
X	       2 * ell->radiuses.x, 2 * ell->radiuses.y);
X#  ifdef DrawOutLine
X	if (OutLine == 1) {
X	    OutLine=0;
X            fprintf(tfp, "\\put(%d,%d){", pt.x, pt.y );
X	    fprintf(tfp, EllCmdstr[EllipseCmd],EllCmdkw[EllipseCmd], "",
X		   2 * ell->radiuses.x, 2 * ell->radiuses.y);
X	}
X#  endif
X#else
X	fprintf(tfp, EllCmdstr[EllipseCmd], EllCmdkw[EllipseCmd],
X	       (EllipseCmd==0 && ell->area_fill==BLACK_FILL ? "*" : ""),
X	       2 * ell->radiuses.x, 2 * ell->radiuses.y);
X#endif
X    } else {
X        fprintf(tfp, "\\put(%d,%d){\\circle", pt.x, pt.y);
X        if (ell->area_fill == BLACK_FILL) {
X            fputc('*', tfp);
X        }
X        fprintf(tfp, "{%d}}\n", 2*ell->radiuses.x);
X    }
X}
X
Xextern char *ISOtoTeX[];
Xvoid genepic_text(text)
XF_text *text;
X{
X    F_point pt;
X    char *tpos, *esc_cp, *special_index;
X    unsigned char   *cp;
X
X    pt.x=text->base_x;
X    pt.y=text->base_y;
X    convertCS(&pt);
X    switch (text->type) {
X    case T_LEFT_JUSTIFIED:
X    case DEFAULT:
X	tpos = "[lb]";
X	break;
X    case T_CENTER_JUSTIFIED:
X	tpos = "[b]";
X	break;
X    case T_RIGHT_JUSTIFIED:
X	tpos = "[rb]";
X	break;
X    default:
X	fprintf(stderr, "unknown text position type\n");
X	exit(1);
X    }
X    fprintf(tfp, "\\put(%d,%d){\\makebox(0,0)%s{\\smash{",
X           pt.x, pt.y, tpos);
X    /* Output a shortstack in case there are multiple lines. */
X    for(cp = (unsigned char*)text->cstring; *cp; cp++) {
X      if (*cp == TEXT_LINE_SEP) {
X    fprintf(tfp, "\\shortstack" );
X    /* Output the justification for the shortstack. */
X    switch (text->type) {
X    case T_LEFT_JUSTIFIED:
X    case DEFAULT:
X	fprintf(tfp, "[l]");
X	break;
X    case T_CENTER_JUSTIFIED:
X	break;
X    case T_RIGHT_JUSTIFIED:
X	fprintf(tfp, "[r]");
X	break;
X    default:
X	fprintf(stderr, "unknown text position type\n");
X	exit(1);
X	}
X	break;
X      }
X    }
X
X    unpsfont(text);
X    { int texsize;
X      double baselineskip;
X
X      texsize = TEXFONTMAG(text);
X      baselineskip = (texsize * 1.2);
X
X      fprintf(tfp, "{{\\SetFigFont{%d}{%.1f}{%s}",
X	      texsize, baselineskip, TEXFONT(text->font));
X    }
X
X    if (!special_text(text))
X	/* This loop escapes special LaTeX characters. */
X	for(cp = (unsigned char*)text->cstring; *cp; cp++) {
X      	    if (special_index=strchr(latex_text_specials, *cp)) {
X	      /* Write out the replacement.  Implementation note: we can't
X		 use puts since that will output an additional newline. */
X	      esc_cp=latex_text_mappings[special_index-latex_text_specials];
X	      while (*esc_cp)
X		fputc(*esc_cp++, tfp);
X	    }
X	    else if (*cp == TEXT_LINE_SEP) {
X	      /* Handle multi-line text strings. The problem being addressed here
X		 is a LaTeX bug where LaTeX is unable to handle a font which
X		 spans multiple lines.  What we are doing here is closing off
X		 the current font, starting a new line, and then resuming with
X		 the current font. */
X	      fprintf(tfp, "} \\\\\n");
X
X 	      { int texsize;
X 		double baselineskip;
X 
X 		texsize = TEXFONTMAG(text);
X 		baselineskip = (texsize * 1.2);
X 		
X 		fprintf(tfp, "{\\SetFigFont{%d}{%.1f}{%s}",
X 			texsize, baselineskip, TEXFONT(text->font));
X  	      }
X	    }
X	    else
X		fputc(*cp, tfp);
X      	}
X    else 
X	for(cp = (unsigned char*)text->cstring; *cp; cp++) {
X	  if (*cp == TEXT_LINE_SEP) {
X	      /* Handle multi-line text strings. */
X	      fprintf(tfp, "} \\\\\n");
X
X	      { int texsize;
X		double baselineskip;
X
X		texsize = TEXFONTMAG(text);
X		baselineskip = (texsize * 1.2);
X		
X		fprintf(tfp, "{\\SetFigFont{%d}{%.1f}{%s}",
X			texsize, baselineskip, TEXFONT(text->font));
X	      }
X	    }
X	    else
X	        if (*cp >= 0xa0)	/* we escape 8-bit char */
X	    		fprintf(tfp, "%s", ISOtoTeX[(int)*cp-0xa0]);
X		else
X			fputc(*cp, tfp);
X	  }
X    fprintf(tfp, "}}}}}\n");
X}
X
Xvoid genepic_arc(arc)
XF_arc *arc;
X{
X    FPoint pt1, pt2, ctr, tmp;
X    double r1, r2, th1, th2, theta;
X    double dx1, dy1, dx2, dy2;
X    double arrowfactor;
X
X    ctr.x = arc->center.x;
X    ctr.y = arc->center.y;
X    pt1.x = arc->point[0].x;
X    pt1.y = arc->point[0].y;
X    pt2.x = arc->point[2].x;
X    pt2.y = arc->point[2].y;
X    fconvertCS(&ctr);
X    fconvertCS(&pt1);
X    fconvertCS(&pt2);
X
X    dx1 = pt1.x - ctr.x;
X    dy1 = pt1.y - ctr.y;
X    dx2 = pt2.x - ctr.x;
X    dy2 = pt2.y - ctr.y;
X
X    rtop(dx1, dy1, &r1, &th1);
X    rtop(dx2, dy2, &r2, &th2);
X    arrowfactor = (r1+r2) / 30.0;
X    if (arrowfactor > 1) arrowfactor = 1;
X    set_linewidth(arc->thickness);
X    if (arc->for_arrow) {
X	arc_tangent(&ctr, &pt2, arc->direction, &tmp);
X	fdraw_arrow_head(&tmp, &pt2,
X			 arc->for_arrow->ht*arrowfactor,
X			 arc->for_arrow->wid*arrowfactor);
X    	if (Verbose) fprintf(tfp, "%%\n");
X    }
X    if (arc->back_arrow) {
X	arc_tangent(&ctr, &pt1, !arc->direction, &tmp);
X	fdraw_arrow_head(&tmp, &pt1,
X			 arc->back_arrow->ht*arrowfactor,
X			 arc->back_arrow->wid*arrowfactor);
X    	if (Verbose) fprintf(tfp, "%%\n");
X    }
X    if (TeXLang == EEpic) {
X	set_pattern(arc->area_fill);
X        fprintf(tfp, "\\put(%4.3lf,%4.3lf){", ctr.x, ctr.y);
X    } else {
X	fprintf(tfp, "\\drawline");
X    }
X    if (TeXLang == EEpic) {
X	if (arc->area_fill < UNFILLED) arc->area_fill = UNFILLED;
X	fprintf(tfp, "%s", FillCommands[arc->area_fill]);
X#ifdef DrawOutLine
X	if (arc->area_fill != UNFILLED && OutLine==0) OutLine=1;
X#endif
X    }
X    if (arc->direction) {
X	theta = th2 - th1;
X	if (theta < 0) theta += 2 * M_PI;
X	th2 = 2*M_PI-th2;
X	if (TeXLang == EEpic) {
X	    fprintf(tfp, "\\arc{%4.3f}{%2.4f}{%2.4f}}\n", 2*r1, th2, th2+theta);
X#ifdef DrawOutLine
X	    if (OutLine==1) {
X		OutLine=0;
X	        fprintf(tfp, "\\put(%4.3lf,%4.3lf){", ctr.x, ctr.y);
X		fprintf(tfp, "\\arc{%4.3f}{%2.4f}{%2.4f}}\n", 2*r1, th2, th2+theta);
X	    }
X#endif
X        } else {
X            drawarc(&ctr, r1, 2*M_PI - th2 - theta, theta);
X        }
X    } else {
X	theta = th1 - th2;
X	if (theta < 0) theta += 2 * M_PI;
X	th1 = 2*M_PI-th1;
X	if (TeXLang == EEpic) {
X	    fprintf(tfp, "\\arc{%4.3f}{%2.4f}{%2.4f}}\n", 2*r2, th1, th1+theta);
X#ifdef DrawOutLine
X	    if (OutLine==1) {
X		OutLine=0;
X	        fprintf(tfp, "\\put(%4.3lf,%4.3lf){", ctr.x, ctr.y);
X		fprintf(tfp, "\\arc{%4.3f}{%2.4f}{%2.4f}}\n", 2*r2, th1, th1+theta);
X	    }
X#endif
X	} else {
X            drawarc(&ctr, r2, 2*M_PI - th1 - theta, theta);
X        }
X    }
X}
X
Xdrawarc(ctr, r, th1, angle)
XFPoint *ctr;
Xdouble r, th1, angle;
X{
X    double arclength, delta;
X    int division, pt_count = 0;
X
X
X    division = angle * r / Threshold;
X    delta = angle / division;
X    division++;
X    while (division-- > 0) {
X        if (++pt_count > PtPerLine) {
X            fprintf(tfp, "\n\t");
X            pt_count = 1;
X        }
X        fprintf(tfp, "(%.3lf,%.3lf)", ctr->x + cos(th1) * r,
X                                ctr->y + sin(th1) * r);
X        th1 += delta;
X    }
X    fprintf(tfp, "\n");
X}
X
Xstatic arc_tangent(pt1, pt2, direction, pt3)
XFPoint *pt1, *pt2, *pt3;
Xint direction;
X{
X    if (direction) {
X	pt3->x = pt2->x + (pt2->y - pt1->y);
X	pt3->y = pt2->y - (pt2->x - pt1->x);
X    } else {
X	pt3->x = pt2->x - (pt2->y - pt1->y);
X	pt3->y = pt2->y + (pt2->x - pt1->x);
X    }
X}
X
Xrtop(x, y, r, th)
Xdouble x, y, *r, *th;
X{
X    *r = sqrt(x*x+y*y);
X    *th = acos(x/(*r));
X    if (*th < 0) *th = M_PI + *th;
X    if (y < 0) *th = 2*M_PI - *th;
X}
X
Xstatic draw_arrow_head(pt1, pt2, arrowht, arrowwid)
XF_point *pt1, *pt2;
Xdouble arrowht, arrowwid;
X{
X    FPoint fpt1, fpt2;
X
X    fpt1.x = pt1->x;
X    fpt1.y = pt1->y;
X    fpt2.x = pt2->x;
X    fpt2.y = pt2->y;
X    fdraw_arrow_head(&fpt1, &fpt2, arrowht, arrowwid);
X}
X
Xfdraw_arrow_head(pt1, pt2, arrowht, arrowwid)
XFPoint *pt1, *pt2;
Xdouble arrowht, arrowwid;
X{
X    double x1, y1, x2, y2;
X    double x,y, xb,yb,dx,dy,l,sina,cosa;
X    double xc, yc, xd, yd;
X
X    x1 = pt1->x;
X    y1 = pt1->y;
X    x2 = pt2->x;
X    y2 = pt2->y;
X
X    dx = x2 - x1;  dy = y1 - y2;
X    l = sqrt(dx*dx+dy*dy);
X    if (l == 0) {
X	 return;
X    }
X    else {
X	 sina = dy / l;  cosa = dx / l;
X    }
X    xb = x2*cosa - y2*sina;
X    yb = x2*sina + y2*cosa;
X    x = xb - arrowht;
X    y = yb - arrowwid / 2;
X    xc = x*cosa + y*sina;
X    yc = -x*sina + y*cosa;
X    y = yb + arrowwid / 2;
X    xd = x*cosa + y*sina;
X    yd = -x*sina + y*cosa;
X
X    if (Verbose) fprintf(tfp, "%%\n%% arrow head\n%%\n");
X
X    fprintf(tfp, "\\%s(%4.3f,%4.3f)(%4.3f,%4.3f)(%4.3f,%4.3f)\n", LnCmd,
X		xc, yc, x2, y2, xd, yd);
X}
X
X#ifndef MSDOS
Xstricmp(s, t)
Xchar *s, *t;
X{
X    char a, b;
X
X    for (;;) {
X        a= *s++; b= *t++;
X        a = islower(a) ? toupper(a) : a;
X        b = islower(b) ? toupper(b) : b;
X        if (a != b) break;
X        if (a == '\0') return(0);
X    }
X    return(a - b);
X}
X#endif
X
Xstruct driver dev_epic = {
X     	genepic_option,
X	genepic_start,
X	genepic_arc,
X	genepic_ellipse,
X	genepic_line,
X	genepic_spline,
X	genepic_text,
X	genepic_end,
X	INCLUDE_TEXT
X};
END_OF_FILE
if test 30473 -ne `wc -c <'fig2dev/dev/genepic.c'`; then
    echo shar: \"'fig2dev/dev/genepic.c'\" unpacked with wrong size!
fi
# end of 'fig2dev/dev/genepic.c'
fi
if test -f 'fig2dev/dev/genps.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fig2dev/dev/genps.c'\"
else
echo shar: Extracting \"'fig2dev/dev/genps.c'\" \(28838 characters\)
sed "s/^X//" >'fig2dev/dev/genps.c' <<'END_OF_FILE'
X/*
X * TransFig: Facility for Translating Fig code
X * Copyright (c) 1985 Supoj Sutantavibul
X * Copyright (c) 1991 Micah Beck
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation. The authors make no representations about the suitability 
X * of this software for any purpose.  It is provided "as is" without express 
X * or implied warranty.
X *
X * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
X * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
X * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X *
X */
X
X/* 
X *	genps.c: PostScript driver for fig2dev
X *
X *	Modified by Herbert Bauer to support ISO-Characters,
X *	multiple page output, color mode etc.
X *	heb@regent.e-technik.tu-muenchen.de
X *
X *	Modified by Eric Picheral to support the whole set of ISO-Latin-1
X *	Modified by Herve Soulard to allow non-iso coding on special fonts
X *	Herve.Soulard@inria.fr (8 Apr 1993)
X
X*/
X
X#include <sys/param.h>
X#if defined(hpux) || defined(SYSV) || defined(BSD4_3)
X#include <sys/types.h>
X#endif
X#include <sys/file.h>
X#include <stdio.h>
X#include <math.h>
X#include <pwd.h>
X#include <errno.h>
Xextern char *sys_errlist[];
X#include "pi.h"
X#include "object.h"
X#include "fig2dev.h"
X#include "psfonts.h"
X#include <string.h>
X#include <time.h>
X
X/* for the version nubmer */
X#include "../../patchlevel.h"
X
X#ifdef A4
X#define		PAGE_WIDTH		595	/* points; 21cm */
X#define		PAGE_HEIGHT		842	/* points; 29.7cm */
X#else
X#define		PAGE_WIDTH		612	/* points; 8.5" */
X#define		PAGE_HEIGHT		792	/* points; 11" */
X#endif
X#define		TRUE			1
X#define		FALSE			0
X#define		POINT_PER_INCH		72
X#define		ULIMIT_FONT_SIZE	300
X#define 	MAXCOLORS 		16
X
Xint		pagewidth = PAGE_WIDTH;
Xint		pageheight = PAGE_HEIGHT;
Xstatic int	coord_system;
Xint		show_page = 0;
Xstatic int	cur_thickness;
Xint		center = 0;
Xint		landscape = 0;
Xint		pages;
Xint		no_obj = 0;
Xint		multi_page = FALSE;
X
Xextern	int	v2_flag, v21_flag;
X
Xstatic	arc_tangent();
Xstatic	draw_arrow_head();
Xstatic	fill_area();
Xstatic	iso_text_exist();
Xstatic	encode_all_fonts();
Xstatic	ellipse_exist();
Xstatic	normal_spline_exist();
X
X#define GRAYVAL(F)	((F) <= 21 ? ((F)-1)/20.0 : 1.0)
X
X#define		BEGIN_PROLOG	"\
X/$F2psDict 200 dict def \n\
X$F2psDict begin\n\
X$F2psDict /mtrx matrix put\n\
X/l {lineto} bind def\n\
X/m {moveto} bind def\n\
X/s {stroke} bind def\n\
X/n {newpath} bind def\n\
X/gs {gsave} bind def\n\
X/gr {grestore} bind def\n\
X/clp {closepath} bind def\n\
X/graycol {dup dup currentrgbcolor 4 -2 roll mul 4 -2 roll mul\n\
X4 -2 roll mul setrgbcolor} bind def\n\
X/col-1 {} def\n\
X/col0 {0 0 0 setrgbcolor} bind def\n\
X/col1 {0 0 1 setrgbcolor} bind def\n\
X/col2 {0 1 0 setrgbcolor} bind def\n\
X/col3 {0 1 1 setrgbcolor} bind def\n\
X/col4 {1 0 0 setrgbcolor} bind def\n\
X/col5 {1 0 1 setrgbcolor} bind def\n\
X/col6 {1 1 0 setrgbcolor} bind def\n\
X/col7 {1 1 1 setrgbcolor} bind def\n\
X/col8 {.68 .85 .9 setrgbcolor} bind def\n\
X/col9 {0 .39 0 setrgbcolor} bind def\n\
X/col10 {.65 .17 .17 setrgbcolor} bind def\n\
X/col11 {1 .51 0 setrgbcolor} bind def\n\
X/col12 {.63 .13 .94 setrgbcolor} bind def\n\
X/col13 {1 .75 .8 setrgbcolor} bind def\n\
X/col14 {.7 .13 .13 setrgbcolor} bind def\n\
X/col15 {1 .84 0 setrgbcolor} bind def\n\
X"
X
X#define		SPECIAL_CHAR_1	"\
X/reencdict 12 dict def /ReEncode { reencdict begin\n\
X/newcodesandnames exch def /newfontname exch def /basefontname exch def\n\
X/basefontdict basefontname findfont def /newfont basefontdict maxlength dict def\n\
Xbasefontdict { exch dup /FID ne { dup /Encoding eq\n\
X{ exch dup length array copy newfont 3 1 roll put }\n\
X{ exch newfont 3 1 roll put } ifelse } { pop pop } ifelse } forall\n\
Xnewfont /FontName newfontname put newcodesandnames aload pop\n\
X128 1 255 { newfont /Encoding get exch /.notdef put } for\n\
Xnewcodesandnames length 2 idiv { newfont /Encoding get 3 1 roll put } repeat\n\
Xnewfontname newfont definefont pop end } def\n\
X/isovec [ \n\
X"
X#define		SPECIAL_CHAR_2	"\
X8#200 /grave 8#201 /acute 8#202 /circumflex 8#203 /tilde\n\
X8#204 /macron 8#205 /breve 8#206 /dotaccent 8#207 /dieresis\n\
X8#210 /ring 8#211 /cedilla 8#212 /hungarumlaut 8#213 /ogonek 8#214 /caron\n\
X8#220 /dotlessi 8#240 /space 8#241 /exclamdown 8#242 /cent 8#243 /sterling\n\
X8#244 /currency 8#245 /yen 8#246 /brokenbar 8#247 /section 8#250 /dieresis\n\
X8#251 /copyright 8#252 /ordfeminine 8#253 /guillemotleft 8#254 /logicalnot\n\
X8#255 /endash 8#256 /registered 8#257 /macron 8#260 /degree 8#261 /plusminus\n\
X8#262 /twosuperior 8#263 /threesuperior 8#264 /acute 8#265 /mu 8#266 /paragraph\n\
X8#267 /periodcentered 8#270 /cedilla 8#271 /onesuperior 8#272 /ordmasculine\n\
X8#273 /guillemotright 8#274 /onequarter 8#275 /onehalf \n\
X8#276 /threequarters 8#277 /questiondown 8#300 /Agrave 8#301 /Aacute\n\
X8#302 /Acircumflex 8#303 /Atilde 8#304 /Adieresis 8#305 /Aring\n\
X"
X#define		SPECIAL_CHAR_3	"\
X8#306 /AE 8#307 /Ccedilla 8#310 /Egrave 8#311 /Eacute\n\
X8#312 /Ecircumflex 8#313 /Edieresis 8#314 /Igrave 8#315 /Iacute\n\
X8#316 /Icircumflex 8#317 /Idieresis 8#320 /Eth 8#321 /Ntilde 8#322 /Ograve\n\
X8#323 /Oacute 8#324 /Ocircumflex 8#325 /Otilde 8#326 /Odieresis 8#327 /multiply\n\
X8#330 /Oslash 8#331 /Ugrave 8#332 /Uacute 8#333 /Ucircumflex\n\
X8#334 /Udieresis 8#335 /Yacute 8#336 /Thorn 8#337 /germandbls 8#340 /agrave\n\
X8#341 /aacute 8#342 /acircumflex 8#343 /atilde 8#344 /adieresis 8#345 /aring\n\
X8#346 /ae 8#347 /ccedilla 8#350 /egrave 8#351 /eacute\n\
X8#352 /ecircumflex 8#353 /edieresis 8#354 /igrave 8#355 /iacute\n\
X8#356 /icircumflex 8#357 /idieresis 8#360 /eth 8#361 /ntilde 8#362 /ograve\n\
X8#363 /oacute 8#364 /ocircumflex 8#365 /otilde 8#366 /odieresis 8#367 /divide\n\
X8#370 /oslash 8#371 /ugrave 8#372 /uacute 8#373 /ucircumflex\n\
X8#374 /udieresis 8#375 /yacute 8#376 /thorn 8#377 /ydieresis \
X] def\n\
X"
X
X#define		ELLIPSE_PS	" \
X/DrawEllipse {\n\
X	/endangle exch def\n\
X	/startangle exch def\n\
X	/yrad exch def\n\
X	/xrad exch def\n\
X	/y exch def\n\
X	/x exch def\n\
X	/savematrix mtrx currentmatrix def\n\
X	x y translate xrad yrad scale 0 0 1 startangle endangle arc\n\
X	savematrix setmatrix\n\
X	} def\n\
X"
X/* The original PostScript definition for adding a spline section to the
X * current path uses recursive bisection.  The following definition using the
X * curveto operator is more efficient since it executes at compiled rather
X * than interpreted code speed.  The Bezier control points are 2/3 of the way
X * from z1 (and z3) to z2.
X *
X * ---Rene Llames, 21 July 1988.
X */
X#define		SPLINE_PS	" \
X/DrawSplineSection {\n\
X	/y3 exch def\n\
X	/x3 exch def\n\
X	/y2 exch def\n\
X	/x2 exch def\n\
X	/y1 exch def\n\
X	/x1 exch def\n\
X	/xa x1 x2 x1 sub 0.666667 mul add def\n\
X	/ya y1 y2 y1 sub 0.666667 mul add def\n\
X	/xb x3 x2 x3 sub 0.666667 mul add def\n\
X	/yb y3 y2 y3 sub 0.666667 mul add def\n\
X	x1 y1 lineto\n\
X	xa ya xb yb x3 y3 curveto\n\
X	} def\n\
X"
X#define		END_PROLOG	"\
X	end\n\
X/$F2psBegin {$F2psDict begin /$F2psEnteredState save def} def\n\
X/$F2psEnd {$F2psEnteredState restore end} def\n\
X%%EndProlog\n\
X"
X
Xstatic double		tx, scalex, scaley;
Xstatic double		dx, dy, origx, origy;
X
Xvoid genps_option(opt, optarg)
Xchar opt;
Xchar *optarg;
X{
X	int i;
X
X	switch (opt) {
X
X	case 'f':
X		for ( i = 1; i <= MAX_PSFONT + 1; i++ )
X			if ( !strcmp(optarg, PSfontnames[i]) ) break;
X
X		if ( i > MAX_PSFONT + 1 )
X			fprintf(stderr,
X			    "warning: non-standard font name %s\n", optarg);
X
X	    	psfontnames[0] = psfontnames[1] = optarg;
X	    	PSfontnames[0] = PSfontnames[1] = optarg;
X	    	break;
X
X	case 'c':
X	    	center = 1;
X		break;
X
X	case 's':
X		if (font_size <= 0 || font_size > ULIMIT_FONT_SIZE) {
X			fprintf(stderr,
X				"warning: font size %d out of bounds\n", font_size);
X		}
X		break;
X
X	case 'P':
X		show_page = 1;
X		break;
X
X      	case 'm':
X      	case 'L':
X		break;
X
X      	case 'l':
X		landscape = 1;
X		break;
X
X	default:
X		put_msg(Err_badarg, opt, "ps");
X		exit(1);
X		break;
X	}
X}
X
Xvoid genps_start(objects)
XF_compound	*objects;
X{
X	char		host[256];
X	struct passwd	*who;
X	time_t		when;
X	int		itmp;
X	int		resolution;
X
X	resolution = objects->nwcorner.x;
X	coord_system = objects->nwcorner.y;
X	scalex = scaley = mag * POINT_PER_INCH / (double)resolution;
X	/* convert to point unit */
X	llx = (int)ceil(llx * scalex); lly = (int)ceil(lly * scaley);
X	urx = (int)ceil(urx * scalex); ury = (int)ceil(ury * scaley);
X
X
X	if (landscape)
X	{
X	   itmp = pageheight; pageheight = pagewidth; pagewidth = itmp;
X	   itmp = llx; llx = lly; lly = itmp;
X	   itmp = urx; urx = ury; ury = itmp;
X	}
X	if (show_page)
X	{
X	   if (center)
X	   {
X	      if (landscape)
X	      {
X		 origx = (pageheight - urx - llx)/2.0;
X		 origy = (pagewidth - ury - lly)/2.0;
X	      }
X	      else
X	      {
X		 origx = (pagewidth - urx - llx)/2.0;
X		 origy = (pageheight + ury + lly)/2.0;
X	      }
X	   }
X	   else
X	   {
X	      origx = 0.0;
X	      origy = landscape ? 0.0 : pageheight;
X	   }
X	}
X	else
X	{
X	   origx = -llx;
X	   origy = landscape ? -lly : ury;
X	}
X
X	if (coord_system == 2) scaley = -scaley;
X
X	if (show_page)
X	    fprintf(tfp, "%%!PS-Adobe-2.0\n");		/* PostScript magic strings */
X	else
X	    fprintf(tfp, "%%!PS-Adobe-2.0 EPSF-2.0\n");	/* Encapsulated PostScript */
X	who = getpwuid(getuid());
X	if (-1 == gethostname(host, sizeof(host)))
X	    (void)strcpy(host, "unknown-host!?!?");
X	(void) time(&when);
X	fprintf(tfp, "%%%%Title: %s\n", ((from) ? from : "stdin"));
X	fprintf(tfp, "%%%%Creator: %s Version %s Patchlevel %s\n", 
X		prog, VERSION, PATCHLEVEL);
X	fprintf(tfp, "%%%%CreationDate: %s", ctime(&when));
X	if (who)
X	   fprintf(tfp, "%%%%For: %s@%s (%s)\n",
X			who->pw_name, host, who->pw_gecos);
X
X	if (!center)
X	   if (landscape)
X		pages = (urx/pageheight+1)*(ury/pagewidth+1);
X	   else
X		pages = (urx/pagewidth+1)*(ury/pageheight+1);
X	else
X	   pages = 1;
X	if (landscape) {
X	   fprintf(tfp, "%%%%Orientation: Landscape\n");
X	   fprintf(tfp, "%%%%BoundingBox: %d %d %d %d\n", 
X	      (int)origx+llx, (int)origy+lly, (int)origx+urx, (int)origy+ury);
X	} else {
X	   fprintf(tfp, "%%%%Orientation: Portrait\n");
X	   fprintf(tfp, "%%%%BoundingBox: %d %d %d %d\n", 
X	      (int)origx+llx, (int)origy-ury, (int)origx+urx, (int)origy-lly);
X	}
X	fprintf(tfp, "%%%%Pages: %d\n", show_page ? pages : 0 );
X
X	fprintf(tfp, "%%%%EndComments\n");
X	fprintf(tfp, "%s", BEGIN_PROLOG);
X	if (iso_text_exist(objects))
X	{
X	   fprintf(tfp, "%s%s%s", SPECIAL_CHAR_1,SPECIAL_CHAR_2,SPECIAL_CHAR_3);
X	   encode_all_fonts(objects);
X	}
X	if (ellipse_exist(objects)) fprintf(tfp, "%s\n", ELLIPSE_PS);
X	if (normal_spline_exist(objects)) fprintf(tfp, "%s\n", SPLINE_PS);
X	fprintf(tfp, "%s\n", END_PROLOG);
X	fprintf(tfp, "$F2psBegin\n");
X 	fprintf(tfp, "0 setlinecap 0 setlinejoin\n");
X  
X 	if ( pages > 1 && show_page && !center )
X	    multi_page = TRUE;
X 	else
X 	{
X	    fprintf (tfp, "%.1f %.1f translate", origx, origy);
X	    if (landscape)
X	    {
X	       fprintf (tfp, " 90 rotate");
X	    }
X	    fprintf (tfp, " %.3f %.3f scale\n", scalex, scaley );
X	}
X}
X
Xvoid genps_end()
X{
X    double dx,dy;
X    int i, page;
X    int h,w;
X  
X    if (multi_page)
X    {
X       page = 1;
X       h = (landscape? pagewidth: pageheight);
X       w = (landscape? pageheight: pagewidth);
X       for (dy=0; dy < (ury-h*0.1); dy += h*0.9)
X       {
X	 for (dx=0; dx < (urx-w*0.1); dx += w*0.9)
X	 {
X	    fprintf (tfp, "%%%%Page: %d %d\n%.1f %.1f translate", 
X		page,page,
X		-(origx+dx), (origy+(landscape?-dy:dy)));
X	    if (landscape)
X	    {
X	       fprintf(tfp, " 90 rotate");
X	    }
X	    fprintf (tfp, " %.3f %.3f scale\n", scalex, scaley);
X	    for (i=0; i<no_obj; i++)
X	    {
X	       fprintf(tfp, "o%d ", i);
X	       if (!(i%20)) fprintf(tfp, "\n", i);
X	    }
X	    fprintf(tfp, "showpage\n");
X	    page++;
X	 }
X       }
X    }
X    else
X       if (show_page) fprintf(tfp, "showpage\n");
X    fprintf(tfp, "$F2psEnd\n");
X}
X 
Xstatic set_style(s, v)
Xint	s;
Xdouble	v;
X{
X	if (s == DASH_LINE) {
X	    if (v > 0.0) fprintf(tfp, "\t[%f] 0 setdash\n", v);
X	    }
X	else if (s == DOTTED_LINE) {
X	    if (v > 0.0) fprintf(tfp, "\t1 setlinecap [1 %f] %f setdash\n", v, v);
X	    }
X	}
X
Xstatic reset_style(s, v)
Xint	s;
Xdouble	v;
X{
X	if (s == DASH_LINE) {
X	    if (v > 0.0) fprintf(tfp, "\t[] 0 setdash\n");
X	    }
X	else if (s == DOTTED_LINE) {
X	    if (v > 0.0) fprintf(tfp, "\t[] 0 setdash 0 setlinecap\n");
X	    }
X	}
X
Xstatic set_linewidth(w)
Xint	w;
X{
X	extern int	cur_thickness;
X
X	if (w != cur_thickness) {
X	    cur_thickness = w;
X	    fprintf(tfp, "%.3f setlinewidth\n", cur_thickness <= 1 ? 0.5* cur_thickness : cur_thickness -1.0);
X	    }
X	}
X
Xvoid genps_line(l)
XF_line	*l;
X{
X	F_point		*p, *q;
X	/* JNT */
X	int		radius, i = 0;
X	FILE		*epsf;
X	char		buf[512];
X	char		*cp;
X	int		xmin,xmax,ymin,ymax;
X	int		eps_w, eps_h;
X	double		fllx, flly, furx, fury;
X	
X	if (multi_page)
X	   fprintf(tfp, "/o%d {", no_obj++);
X	if (l->type != T_EPS_BOX)  /* eps object has no line thickness */
X		set_linewidth(l->thickness);
X	radius = l->radius;		/* radius of rounded-corner boxes */
X	p = l->points;
X	q = p->next;
X	if (q == NULL) { /* A single point line */
X	    fprintf(tfp, "n %d %d m %d %d l gs col%d s gr\n",
X			p->x, p->y, p->x, p->y, l->color > MAXCOLORS ? -1 : l->color);
X	    if (multi_page)
X	       fprintf(tfp, "} bind def\n");
X	    return;
X	    }
X	if (l->back_arrow && l->thickness > 0)
X	    draw_arrow_head((double)q->x, (double)q->y, (double)p->x,
X			(double)p->y, l->back_arrow->ht, l->back_arrow->wid,
X			l->color);
X	if (l->type != T_EPS_BOX)  /* eps object has no line style */
X		set_style(l->style, l->style_val);
X	fprintf(tfp, "%% Polyline\n");
X
X	xmin = xmax = p->x;
X	ymin = ymax = p->y;
X	while (p->next != NULL) /* find lower left and upper right corne
Xrs */
X	{
X		p=p->next;
X		if (xmin > p->x)
X			xmin = p->x;
X		else if (xmax < p->x)
X			xmax = p->x;
X		if (ymin > p->y)
X			ymin = p->y;
X		else if (ymax < p->y)
X			ymax = p->y;
X		}
X
X	if (l->type == T_ARC_BOX)
X	{
X	    fprintf(tfp, "n %d %d m",xmin+radius, ymin);
X	    fprintf(tfp, " %d %d %d %d %d arcto 4 {pop} repeat",
X				xmin, ymin, xmin, ymax-radius, radius);
X	    fprintf(tfp, " %d %d %d %d %d arcto 4 {pop} repeat", /* arc through bl to br */
X				xmin, ymax, xmax-radius, ymax, radius);
X	    fprintf(tfp, " %d %d %d %d %d arcto 4 {pop} repeat", /* arc through br to tr */
X				xmax, ymax, xmax, ymin+radius, radius);
X	    fprintf(tfp, " %d %d %d %d %d arcto 4 {pop} repeat", /* arc through tr to tl */
X				xmax, ymin, xmin+radius, ymin, radius);
X	}
X	else if (l->type == T_EPS_BOX)  /* encapsulated postscript (eps) file */
X	{
X		int             dx, dy, rotation;
X		int		llx, lly, urx, ury;
X		double          fllx, flly, furx, fury;
X
X		dx = l->points->next->next->x - l->points->x;
X		dy = l->points->next->next->y - l->points->y;
X		rotation = 0;
X		if (dx < 0 && dy < 0)
X			   rotation = 180;
X		else if (dx < 0 && dy >= 0)
X			   rotation = 270;
X		else if (dy < 0 && dx >= 0)
X			   rotation = 90;
X
X		fprintf(tfp, "%%\n");
X		fprintf(tfp, "%% Begin Imported EPS File: %s\n", l->eps->file);
X		fprintf(tfp, "%%\n");
X		epsf = fopen(l->eps->file, "r");
X		if (epsf == NULL) {
X			fprintf (stderr, "Unable to open eps file: %s, error: (%d)\n",
X				l->eps->file, sys_errlist[errno],errno);
X			return;
X		}
X		while (fgets(buf, 512, epsf) != NULL) {
X		  lower(buf);
X		  if (!strncmp(buf, "%%boundingbox", 13)) {
X			if (sscanf(buf, "%%%%boundingbox: %lf %lf %lf %lf",
X					   &fllx, &flly, &furx, &fury) < 4) {
X			  fprintf(stderr,"Bad EPS bitmap file: %s", l->eps->file);
X			  fclose(epsf);
X			  return;
X			}
X			llx= floor(fllx);
X			lly= floor(flly);
X			urx= ceil(furx);
X			ury= ceil(fury);
X			break;
X		  }
X		}
X		fclose(epsf);
X
X		fprintf(tfp, "n gs\n");
X		if (((rotation == 90 || rotation == 270) && !l->eps->flipped) ||
X		    (rotation != 90 && rotation != 270 && l->eps->flipped)) {
X			eps_h = urx - llx;
X			eps_w = ury - lly;
X		} else {
X			eps_w = urx - llx;
X			eps_h = ury - lly;
X		}
X
X		/* translate the eps stuff to the right spot on the page */
X		fprintf(tfp, "%d %d translate\n", xmin, ymin);
X
X		/* scale the eps stuff to fit into the bounding box */
X		/* Note: the origin for fig is in the upper-right corner;
X		 *       for postscript its in the lower right hand corner.
X		 *       To fix it, we use a "negative"-y scale factor, then
X		 *       translate the image up on the page */
X		fprintf(tfp, "%f %f scale\n",
X			fabs((double)(xmax-xmin)/eps_w), -1.0*(double)(ymax-ymin)/eps_h);
X		fprintf(tfp, "0 %d translate\n", -eps_h);
X
X		/* flip the eps stuff */
X		/* always translate it back so that the lower-left corner is at the origin */
X		if (l->eps->flipped && rotation==90) {
X			fprintf(tfp, "0 %d translate\n", eps_h);
X			fprintf(tfp, "1 -1 scale\n");
X		}
X		if (l->eps->flipped && rotation==270) {
X			fprintf(tfp, "%d 0 translate\n", eps_w);
X			fprintf(tfp, "-1 1 scale\n");
X		}
X
X		/* note: fig measures rotation clockwise; postscript is counter-clockwise */
X		/* always translate it back so that the lower-left corner is at the origin */
X		switch (rotation) {
X		   case 0:
X			break;
X		   case 90:
X			if (l->eps->flipped) break;
X			fprintf(tfp, "%d %d translate\n", 0, eps_h);
X			fprintf(tfp, "%d rotate\n", 270);
X			break;
X		   case 180:
X			fprintf(tfp, "%d %d translate\n", eps_w, eps_h);
X			fprintf(tfp, "%d rotate\n", 180);
X			break;
X		   case 270:
X			if (l->eps->flipped) break;
X			fprintf(tfp, "%d %d translate\n", eps_w, 0);
X			fprintf(tfp, "%d rotate\n", 90);
X			break;
X		}
X
X		/* translate the eps stuff so that the lower-left corner is at the origin */
X		fprintf(tfp, "%d %d translate\n", -llx, -lly);
X		/* save vm so eps file won't change anything */
X		fprintf(tfp, "save\n");
X		fprintf(tfp, "%% EPS file follows:\n");
X		epsf = fopen(l->eps->file, "r");
X		if (epsf == NULL) {
X			fprintf (stderr, "Unable to open eps file: %s, error: (%d)\n",
X				l->eps->file, sys_errlist[errno],errno);
X			fprintf(tfp, "gr\n");
X			return;
X		}
X		while (fgets(buf, sizeof(buf), epsf) != NULL) {
X			if (*buf == '%')		/* skip comment lines */
X				continue;
X			if ((cp=strstr(buf, "showpage")) != NULL)
X				strcpy (cp, cp+8);	/* remove showpage */
X			fputs(buf, tfp);
X		}
X		fclose (epsf);
X		/* restore vm and gsave */
X		fprintf(tfp, "restore gr\n");
X		fprintf(tfp, "%%\n");
X		fprintf(tfp, "%% End Imported EPS File: %s\n", l->eps->file);
X		fprintf(tfp, "%%\n");
X	}
X	else
X	{
X		p = l->points;
X		q = p->next;
X		fprintf(tfp, "n %d %d m", p->x, p->y);
X		while (q->next != NULL) {
X		    p = q;
X		    q = q->next;
X		    fprintf(tfp, " %d %d l ", p->x, p->y);
X 	    	    if (!((++i)%5)) 
X			fprintf(tfp, "\n");
X		}
X	}
X	if (l->type != T_EPS_BOX) {
X		if (l->type == T_POLYLINE)
X		    fprintf(tfp, " %d %d l ", q->x, q->y);
X		else 
X		    fprintf(tfp, " clp ");
X		if (l->area_fill && (int)l->area_fill != DEFAULT)
X		    fill_area(l->area_fill, l->color);
X		if (l->thickness > 0)
X		     fprintf(tfp, "gs col%d s gr\n",
X				l->color > MAXCOLORS ? -1 : l->color);
X
X		reset_style(l->style, l->style_val);
X		if (l->for_arrow && l->thickness > 0)
X		    draw_arrow_head((double)p->x, (double)p->y, (double)q->x,
X				(double)q->y, l->for_arrow->ht, l->for_arrow->wid,
X				l->color);
X	}
X	if (multi_page)
X	   fprintf(tfp, "} bind def\n");
X	}
X
Xvoid genps_spline(s)
XF_spline	*s;
X{
X	if (multi_page)
X	   fprintf(tfp, "/o%d {", no_obj++);
X	if (int_spline(s))
X	    genps_itp_spline(s);
X	else
X	    genps_ctl_spline(s);
X	if (multi_page)
X	   fprintf(tfp, "} bind def\n");
X	}
X
Xgenps_itp_spline(s)
XF_spline	*s;
X{
X	F_point		*p, *q;
X	F_control	*a, *b;
X
X	set_linewidth(s->thickness);
X	a = s->controls;
X	p = s->points;
X	if (s->back_arrow && s->thickness > 0)
X	    draw_arrow_head(a->rx, a->ry, (double)p->x,
X			(double)p->y, s->back_arrow->ht, s->back_arrow->wid,
X			s->color);
X
X	set_style(s->style, s->style_val);
X	fprintf(tfp, "%% Interpolated spline\n");
X	fprintf(tfp, "n %d %d m\n", p->x, p->y);
X	for (q = p->next; q != NULL; p = q, q = q->next) {
X	    b = a->next;
X	    fprintf(tfp, "\t%.3f %.3f %.3f %.3f %d %d curveto\n",
X			a->rx, a->ry, b->lx, b->ly, q->x, q->y);
X	    a = b;
X	    }
X	if (closed_spline(s)) fprintf(tfp, " clp ");
X	if (s->area_fill && (int)s->area_fill != DEFAULT)
X	    fill_area(s->area_fill, s->color);
X	if (s->thickness > 0)
X	    fprintf(tfp, "gs col%d s gr\n", s->color > MAXCOLORS ? -1 : s->color);
X	reset_style(s->style, s->style_val);
X
X	if (s->for_arrow && s->thickness > 0)
X	    draw_arrow_head(a->lx, a->ly, (double)p->x,
X			(double)p->y, s->for_arrow->ht, s->for_arrow->wid,
X			s->color);
X	}
X
Xgenps_ctl_spline(s)
XF_spline	*s;
X{
X	double		a, b, c, d, x1, y1, x2, y2, x3, y3;
X	F_point		*p, *q;
X
X	/*
X	if (first) {
X	    first = FALSE;
X	    fprintf(tfp, "%s\n", SPLINE_PS);
X	    }
X	*/
X
X	p = s->points;
X	x1 = p->x; y1 = p->y;
X	p = p->next;
X	c = p->x; d = p->y;
X	set_linewidth(s->thickness);
X	x3 = a = (x1 + c) / 2;
X	y3 = b = (y1 + d) / 2;
X	if (s->back_arrow && s->thickness > 0) {
X	    draw_arrow_head(c, d, x1, y1, s->back_arrow->ht, s->back_arrow->wid,
X			    s->color);
X	    }
X	set_style(s->style, s->style_val);
X	if (! closed_spline(s)) {
X	    fprintf(tfp, "%% Open spline\n");
X	    fprintf(tfp, "n %.3f %.3f m %.3f %.3f l\n",
X			x1, y1, x3, y3);
X	    }
X	else {
X	    fprintf(tfp, "%% Closed spline\n");
X	    fprintf(tfp, "n %.3f %.3f m\n", a, b);
X	    }
X	for (q = p->next; q != NULL; p = q, q = q->next) {
X	    x1 = x3; y1 = y3;
X	    x2 = c;  y2 = d;
X	    c = q->x; d = q->y;
X	    x3 = (x2 + c) / 2;
X	    y3 = (y2 + d) / 2;
X	    fprintf(tfp, "\t%.3f %.3f %.3f %.3f %.3f %.3f DrawSplineSection\n",
X			x1, y1, x2, y2, x3, y3);
X	    }
X	/*
X	* At this point, (x2,y2) and (c,d) are the position of the 
X	* next-to-last and last point respectively, in the point list
X	*/
X	if (closed_spline(s)) {
X	    fprintf(tfp, "\t%.3f %.3f %.3f %.3f %.3f %.3f DrawSplineSection closepath ",
X			x3, y3, c, d, a, b);
X	    }
X	else {
X	    fprintf(tfp, "\t%.3f %.3f l ", c, d);
X	    }
X	if (s->area_fill && (int)s->area_fill != DEFAULT)
X	    fill_area(s->area_fill, s->color);
X	if (s->thickness > 0)
X	    fprintf(tfp, "gs col%d s gr\n", s->color > MAXCOLORS ? -1 : s->color);
X	reset_style(s->style, s->style_val);
X	if (s->for_arrow && s->thickness > 0) {
X	    draw_arrow_head(x2, y2, c, d, s->for_arrow->ht,
X				s->for_arrow->wid, s->color);
X	    }
X	}
X
Xvoid genps_ellipse(e)
XF_ellipse	*e;
X{
X	if (multi_page)
X	   fprintf(tfp, "/o%d {", no_obj++);
X	set_linewidth(e->thickness);
X	set_style(e->style, e->style_val);
X	if (e->angle == 0)
X	{
X	    fprintf(tfp, "%% Ellipse\n");
X	    fprintf(tfp, "n %d %d %d %d 0 360 DrawEllipse ",
X		  e->center.x, e->center.y, e->radiuses.x, e->radiuses.y);
X	}
X	else
X	{
X	    fprintf(tfp, "%% Rotated Ellipse\n");
X	    fprintf(tfp, "gs\n");
X	    fprintf(tfp, "%d %d translate\n",e->center.x, e->center.y);
X	    fprintf(tfp, "%6.3f rotate\n",-e->angle*180/M_PI);
X	    fprintf(tfp, "n 0 0 %d %d 0 360 DrawEllipse ",
X		 e->radiuses.x, e->radiuses.y);
X	}
X	if (e->area_fill && (int)e->area_fill != DEFAULT)
X	    fill_area(e->area_fill, e->color);
X	if (e->thickness > 0)
X	    fprintf(tfp, "gs col%d s gr\n", e->color > MAXCOLORS ? -1 : e->color);
X	if (e->angle != 0)
X	    fprintf(tfp, "gr\n");
X	reset_style(e->style, e->style_val);
X	if (multi_page)
X	   fprintf(tfp, "} bind def\n");
X	}
X
X#define	TEXT_PS		"\
X/%s%s findfont %.2f scalefont setfont\n\
X"
Xvoid genps_text(t)
XF_text	*t;
X{
X	unsigned char		*cp;
X
X	if (multi_page)
X	   fprintf(tfp, "/o%d {", no_obj++);
X	if (PSisomap[t->font+1] == TRUE)
X	   fprintf(tfp, TEXT_PS, PSFONT(t), "-iso", PSFONTMAG(t));
X	else
X	   fprintf(tfp, TEXT_PS, PSFONT(t), "", PSFONTMAG(t));
X
X	fprintf(tfp, "%d %d m \ngs ", t->base_x,  t->base_y);
X	if (coord_system == 2) fprintf(tfp, "1 -1 scale ");
X
X	if (t->angle != 0)
X	   fprintf(tfp, " %.1f rotate ", t->angle*180/M_PI);
X	/* this loop escapes characters '(', ')', and '\' */
X	fputc('(', tfp);
X	for(cp = (unsigned char *)t->cstring; *cp; cp++) {
X	    if (strchr("()\\", *cp)) 
X		fputc('\\', tfp);
X	    if (*cp>=0x80)
X		fprintf(tfp,"\\%o", *cp);
X	    else
X		fputc(*cp, tfp);
X		}
X	fputc(')', tfp);
X
X	if ((t->type == T_CENTER_JUSTIFIED) || (t->type == T_RIGHT_JUSTIFIED)){
X
X	  	fprintf(tfp, " dup stringwidth pop ");
X		if (t->type == T_CENTER_JUSTIFIED) fprintf(tfp, "2 div ");
X		fprintf(tfp, "neg 0 rmoveto ");
X		}
X
X	else if ((t->type != T_LEFT_JUSTIFIED) && (t->type != DEFAULT))
X		fprintf(stderr, "Text incorrectly positioned\n");
X
X	fprintf(tfp, " col%d show gr\n", t->color > MAXCOLORS ? -1 : t->color);
X
X	if (multi_page)
X	   fprintf(tfp, "} bind def\n");
X	}
X
Xvoid genps_arc(a)
XF_arc	*a;
X{
X	double		angle1, angle2, dx, dy, radius, x, y;
X	double		cx, cy, sx, sy, ex, ey;
X	int		direction;
X
X	if (multi_page)
X	   fprintf(tfp, "/o%d {", no_obj++);
X	cx = a->center.x; cy = a->center.y;
X	sx = a->point[0].x; sy = a->point[0].y;
X	ex = a->point[2].x; ey = a->point[2].y;
X
X	if (coord_system == 2)
X	    direction = !a->direction;
X	else
X	    direction = a->direction;
X	set_linewidth(a->thickness);
X	if (a->for_arrow && a->thickness > 0) {
X	    arc_tangent(cx, cy, ex, ey, direction, &x, &y);
X	    draw_arrow_head(x, y, ex, ey, a->for_arrow->ht, a->for_arrow->wid, a->color);
X	    }
X	if (a->back_arrow && a->thickness > 0) {
X	    arc_tangent(cx, cy, sx, sy, !direction, &x, &y);
X	    draw_arrow_head(x, y, sx, sy, a->back_arrow->ht, a->back_arrow->wid, a->color);
X	    }
X	dx = cx - sx;
X	dy = cy - sy;
X	radius = sqrt(dx*dx+dy*dy);
X	angle1 = atan2(sy-cy, sx-cx) * 180 / M_PI;
X	angle2 = atan2(ey-cy, ex-cx) * 180 / M_PI;
X	/* direction = 1 -> Counterclockwise */
X	set_style(a->style, a->style_val);
X	fprintf(tfp, "n %.3f %.3f %.3f %.3f %.3f %s\n",
X		cx, cy, radius, angle1, angle2,
X		((direction == 1) ? "arc" : "arcn"));
X	if (a->area_fill && (int)a->area_fill != DEFAULT)
X	    fill_area(a->area_fill, a->color);
X	if (a->thickness > 0)
X	    fprintf(tfp, "gs col%d s gr\n", a->color > MAXCOLORS ? -1 : a->color);
X	reset_style(a->style, a->style_val);
X	if (multi_page)
X	   fprintf(tfp, "} bind def\n");
X	}
X
Xstatic arc_tangent(x1, y1, x2, y2, direction, x, y)
Xdouble	x1, y1, x2, y2, *x, *y;
Xint	direction;
X{
X	if (direction) { /* counter clockwise  */
X	    *x = x2 + (y2 - y1);
X	    *y = y2 - (x2 - x1);
X	    }
X	else {
X	    *x = x2 - (y2 - y1);
X	    *y = y2 + (x2 - x1);
X	    }
X	}
X
X/*	draw arrow heading from (x1, y1) to (x2, y2)	*/
X
Xstatic draw_arrow_head(x1, y1, x2, y2, arrowht, arrowwid, col)
Xdouble	x1, y1, x2, y2, arrowht, arrowwid;
Xint col;
X{
X	double	x, y, xb, yb, dx, dy, l, sina, cosa;
X	double	xc, yc, xd, yd;
X
X	dx = x2 - x1;  dy = y1 - y2;
X	l = sqrt(dx*dx+dy*dy);
X	if (l == 0) {
X	     return;
X	}
X	else {
X	     sina = dy / l;  cosa = dx / l;
X	}
X	xb = x2*cosa - y2*sina;
X	yb = x2*sina + y2*cosa;
X	x = xb - arrowht;
X	y = yb - arrowwid / 2;
X	xc = x*cosa + y*sina;
X	yc = -x*sina + y*cosa;
X	y = yb + arrowwid / 2;
X	xd = x*cosa + y*sina;
X	yd = -x*sina + y*cosa;
X	fprintf(tfp, "n %.3f %.3f m %.3f %.3f l %.3f %.3f l gs 2 setlinejoin col%d s gr\n", xc, yc, x2, y2, xd, yd, col > MAXCOLORS ? -1 : col);
X	}
X
Xstatic fill_area(fill, color)
Xint fill, color;
X{
X   if (color < 1)   /* use gray levels for default and black */
X	fprintf(tfp, "gs %.2f setgray fill gr\n", 1.0 - GRAYVAL(fill));
X   else
X	fprintf(tfp, "gs col%d %.2f graycol fill gr ",
X		color > MAXCOLORS ? -1 : color, GRAYVAL(fill));
X}
X
Xstatic iso_text_exist(ob)
XF_compound      *ob;
X{
X   F_compound	*c;
X   F_text          *t;
X   unsigned char   *s;
X
X   if (ob->texts != NULL)
X   {
X      for (t = ob->texts; t != NULL; t = t->next)
X      {
X	 for (s = (unsigned char*)t->cstring; *s != '\0'; s++)
X	 {
X	    /* look for characters >= 128 */
X	    if (*s>127) return(1);
X	 }
X      }
X   }
X
X   for (c = ob->compounds; c != NULL; c = c->next) {
X       if (iso_text_exist(c)) return(1);
X       }
X   return(0);
X}
X
Xstatic encode_all_fonts(ob)
XF_compound	*ob;
X{
X   F_compound *c;
X   F_text     *t;
X
X   if (ob->texts != NULL)
X   {
X	for (t = ob->texts; t != NULL; t = t->next)
X	    if (PSisomap[t->font+1] == FALSE)
X	    {
X		fprintf(tfp, "/%s /%s-iso isovec ReEncode\n", PSFONT(t), PSFONT(t));
X		PSisomap[t->font+1] = TRUE;
X	    }
X   }
X
X   for (c = ob->compounds; c != NULL; c = c->next) 
X   {
X	encode_all_fonts(c);
X   }
X}
X
Xstatic ellipse_exist(ob)
XF_compound	*ob;
X{
X	F_compound	*c;
X
X	if (NULL != ob->ellipses) return(1);
X
X	for (c = ob->compounds; c != NULL; c = c->next) {
X	    if (ellipse_exist(c)) return(1);
X	    }
X
X	return(0);
X	}
X
Xstatic normal_spline_exist(ob)
XF_compound	*ob;
X{
X	F_spline	*s;
X	F_compound	*c;
X
X	for (s = ob->splines; s != NULL; s = s->next) {
X	    if (normal_spline(s)) return(1);
X	    }
X
X	for (c = ob->compounds; c != NULL; c = c->next) {
X	    if (normal_spline_exist(c)) return(1);
X	    }
X
X	return(0);
X	}
X
Xstruct driver dev_ps = {
X     	genps_option,
X	genps_start,
X	genps_arc,
X	genps_ellipse,
X	genps_line,
X	genps_spline,
X	genps_text,
X	genps_end,
X	INCLUDE_TEXT
X};
END_OF_FILE
if test 28838 -ne `wc -c <'fig2dev/dev/genps.c'`; then
    echo shar: \"'fig2dev/dev/genps.c'\" unpacked with wrong size!
fi
# end of 'fig2dev/dev/genps.c'
fi
echo shar: End of archive 7 \(of 7\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
