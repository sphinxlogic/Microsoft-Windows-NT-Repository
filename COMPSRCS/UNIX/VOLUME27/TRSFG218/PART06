Newsgroups: comp.sources.unix
From: envbvs@epb12.lbl.gov (Brian V. Smith)
Subject: v27i060: transfig-2.1.8 - a set of tools for creating TeX documents with graphics, Part06/07
References: <1.749903574.10622@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: envbvs@epb12.lbl.gov (Brian V. Smith)
Posting-Number: Volume 27, Issue 60
Archive-Name: transfig-2.1.8/part06

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 7)."
# Contents:  fig2dev/dev/genibmgl.c fig2dev/dev/genpictex.c
# Wrapped by envbvs@epb12.lbl.gov.lbl.gov on Fri Oct  1 14:55:50 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'fig2dev/dev/genibmgl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fig2dev/dev/genibmgl.c'\"
else
echo shar: Extracting \"'fig2dev/dev/genibmgl.c'\" \(26109 characters\)
sed "s/^X//" >'fig2dev/dev/genibmgl.c' <<'END_OF_FILE'
X/*
X * TransFig: Facility for Translating Fig code
X * Copyright (c) 1985 Supoj Sutantavibul
X * Copyright (c) 1991 Micah Beck
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation. The authors make no representations about the suitability 
X * of this software for any purpose.  It is provided "as is" without express 
X * or implied warranty.
X *
X * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
X * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
X * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X *
X */
X
X/* 
X *	genibmgl.c :	IBMGL driver for fig2dev
X *			IBM 6180 Color Plotter with
X *			IBM Graphics Enhancement Cartridge
X * 	Author E. Robert Tisdale, University of California, 1/92
X *	(edwin@cs.ucla.edu)
X *
X *		adapted from:
X *
X *	genpictex.c :	PiCTeX driver for fig2dev
X *
X * 	Author Micah Beck, Cornell University, 4/88
X *	Color, rotated text and ISO-chars added by Herbert Bauer 11/91
X*/
X
X#if defined(hpux) || defined(SYSV)
X#include <sys/types.h>
X#endif
X#include <sys/file.h>
X#ifdef SYSV
X#include <string.h>
X#else
X#include <strings.h>
X#endif
X#include <stdio.h>
X#include <math.h>
X#include "object.h"
X#include "fig2dev.h"
X#include "pi.h"
X
X#define		FALSE			0
X#define		TRUE			1
X#define		FONTS 			35
X#define		COLORS 			8
X#define		PATTERNS 		21
X#define		DPR	 	180.0/M_PI	/*       degrees/radian	*/
X#define		DELTA	 	M_PI/36.0	/* radians		*/
X#define		DEFAULT_FONT_SIZE	11	/* points		*/
X#define		POINT_PER_INCH		72.27	/*	  points/inch	*/
X#define		CMPP		254.0/7227.0	/*   centimeters/point	*/
X#define		UNITS_PER_INCH		 1016.0	/* plotter units/inch	*/
X#define		HEIGHT			 7650.0	/* plotter units	*/
X#define		ISO_A4			10900.0	/* plotter units	*/
X#define		ANSI_A			10300.0	/* plotter units	*/
X#define		SPEED_LIMIT		128.0	/* centimeters/second	*/
X
X#ifdef IBMGEC
Xstatic	int	ibmgec		 = TRUE;
X#else
Xstatic	int	ibmgec		 = FALSE;
X#endif
Xstatic	int	portrait	 = FALSE;
Xstatic	int	reflected	 = FALSE;
Xstatic	int	fonts		 = FONTS;
Xstatic	int	colors		 = COLORS;
Xstatic	int	patterns	 = PATTERNS;
Xstatic	int	line_color	 = DEFAULT;
Xstatic	int	line_style	 = SOLID_LINE;
Xstatic	int	fill_pattern	 = DEFAULT;
Xstatic	double	dash_length	 = DEFAULT;	/* in pixels		*/
X#ifdef A4
Xstatic	double	pagelength	 = ISO_A4/UNITS_PER_INCH;
X#else
Xstatic	double	pagelength	 = ANSI_A/UNITS_PER_INCH;
X#endif
Xstatic	double	pageheight	 = HEIGHT/UNITS_PER_INCH;
Xstatic	double	pen_speed	 = SPEED_LIMIT;
Xstatic	double	xz		 =  0.0;	/* inches		*/
Xstatic	double	yz		 =  0.0;	/* inches		*/
Xstatic	double	xl		 =  0.0;	/* inches		*/
Xstatic	double	yl		 =  0.0;	/* inches		*/
Xstatic	double	xu		 = 32.25;	/* inches		*/
Xstatic	double	yu		 = 32.25;	/* inches		*/
X
Xstatic	int	pen_number[]	 = { 1, 2, 3, 4, 5, 6, 7, 8, 1};
Xstatic	double	pen_thickness[]	 = {.3,.3,.3,.3,.3,.3,.3,.3,.3};
X
Xstatic	int	line_type[]	 =
X	   {-1, 1, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6,-1,-1,-1,-1,-1,-1,-1,-1};
Xstatic	double	line_space[]	 =
X	   {.3,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.5,.3,.3};
Xstatic	int	fill_type[]	 =
X	   { 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 1, 2};
Xstatic	double	fill_space[]	 =
X	   {.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1,.1};
Xstatic	double	fill_angle[]	 =
X	   { 0, 0,-45,0,45,90,-45,0,45,90,-45,0,45,90,-45,0,45,90, 0, 0, 0, 0};
X
Xstatic	int	standard[]	 = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
X	     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
Xstatic	int	alternate[]	 = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
X	     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
Xstatic	double	slant[]		 = { 0,10, 0,10, 0,10, 0,10, 0,10, 0,10, 0,10,
X	     0,10, 0,10, 0,10, 0,10, 0,10, 0,10, 0,10, 0,10, 0,10, 0,10, 0, 0};
Xstatic	double	wide[]		 = {.6,.6,.6,.6,.6,.6,.6,.6,.6,.6,.6,.6,.6,.6,
X	    .6,.6,.6,.6,.6,.6,.6,.6,.6,.6,.6,.6,.6,.6,.6,.6,.6,.6,.6,.6,.6,.6};
Xstatic	double	high[]		 = {.8,.8,.8,.8,.8,.8,.8,.8,.8,.8,.8,.8,.8,.8,
X	    .8,.8,.8,.8,.8,.8,.8,.8,.8,.8,.8,.8,.8,.8,.8,.8,.8,.8,.8,.8,.8,.8};
X
Xstatic void genibmgl_option(opt, optarg)
Xchar opt, *optarg;
X{
X	switch (opt) {
X
X	    case 'a':				/* paper size		*/
X#ifdef A4
X		pagelength	 = ANSI_A/UNITS_PER_INCH;
X#else
X		pagelength	 = ISO_A4/UNITS_PER_INCH;
X#endif
X		break;
X
X	    case 'c':				/* Graphics Enhancement	*/
X		ibmgec		 = !ibmgec;	/* Cartridge emulation	*/
X		break;
X
X	    case 'd':				/* position and window	*/
X		sscanf(optarg, "%lf,%lf,%lf,%lf", &xl,&yl,&xu,&yu);
X						/* inches		*/
X		break;
X
X	    case 'f':				/* user's characters	*/
X		{
X		    FILE	*ffp;
X		    int		font;
X		    if ((ffp = fopen(optarg, "r")) == NULL)
X			fprintf(stderr, "Couldn't open %s\n", optarg);
X		    else
X			for (font = 0; font <= fonts; font++)
X			    fscanf(ffp, "%d%d%lf%lf%lf",
X				&standard[font],	/* 0-4 6-9 30-39*/
X				&alternate[font],	/* 0-4 6-9 30-39*/
X				&slant[font],		/*   degrees	*/
X				&wide[font],		/*	~1.0	*/
X				&high[font]);		/*	~1.0	*/
X		    fclose(ffp);
X		}
X		break;
X
X	    case 'l':				/* user's fill patterns	*/
X		{
X		    FILE	*ffp;
X		    int		pattern;
X		    if ((ffp = fopen(optarg, "r")) == NULL)
X			fprintf(stderr, "Couldn't open %s\n", optarg);
X		    else
X			for (pattern = 1; pattern <= patterns; pattern++)
X			    fscanf(ffp, "%d%lf%d%lf%lf",
X				&line_type[pattern],	/*    -1-6	*/
X				&line_space[pattern],	/*   inches	*/
X				&fill_type[pattern],	/*     1-5	*/
X				&fill_space[pattern],	/*   inches	*/
X				&fill_angle[pattern]);	/*   degrees	*/
X		    fclose(ffp);
X		}
X		break;
X
X	    case 'L':				/* language		*/
X		break;
X
X	    case 'm':				/* magnify and offset	*/
X		sscanf(optarg, "%lf,%lf,%lf", &mag,&xz,&yz);
X						/* inches		*/
X		break;
X
X	    case 'p':				/* user's colors	*/
X		{
X		    FILE	*ffp;
X		    int		color;
X		    if ((ffp = fopen(optarg, "r")) == NULL)
X			fprintf(stderr, "Couldn't open %s\n", optarg);
X		    else
X			for (color = 0; color <= colors; color++)
X			    fscanf(ffp, "%d%lf",
X				&pen_number[color],	/*     1-8	*/
X				&pen_thickness[color]);	/* millimeters	*/
X		    fclose(ffp);
X		}
X		break;
X
X	    case 'P':				/* portrait mode	*/
X		portrait	 = TRUE;
X		break;
X
X	    case 's':				/* set default font size */
X		font_size	 = atoi(optarg) ?
X			atoi(optarg): DEFAULT_FONT_SIZE;
X		break;
X
X	    case 'S':				/* select pen velocity	*/
X		pen_speed	 = atof(optarg);
X		break;
X
X	    case 'v':
X		reflected	 = TRUE;	/* mirror image		*/
X		break;
X
X	    default:
X		put_msg(Err_badarg, opt, "ibmgl");
X		exit(1);
X		break;
X	}
X}
X
Xstatic double		ppi;			/*     pixels/inch	*/
Xstatic double		cpi;			/*       cent/inch	*/
Xstatic double		cpp;			/*       cent/pixel	*/
Xstatic double		wcmpp	 = CMPP;	/* centimeter/point	*/
Xstatic double		hcmpp	 = CMPP;	/* centimeter/point	*/
Xstatic int		flipped	 = FALSE;	/* flip Y coordinate	*/
X
Xvoid genibmgl_start(objects)
XF_compound	*objects;
X{
X	int	 P1x, P1y, P2x, P2y;
X	int	 Xll, Yll, Xur, Yur;
X	double	Xmin,Xmax,Ymin,Ymax;
X	double	height, length;
X
X	if (fabs(mag) < 1.0/2048.0){
X	    fprintf(stderr, "|mag| < 1/2048\n");
X	    exit(1);
X	    }
X
X	if (xl < xu)
X	    if (0.0 < xu)
X		if (xl < pagelength) {
X		    xl	 = (0.0 < xl) ? xl: 0.0;
X		    xu	 = (xu < pagelength) ? xu: pagelength;
X		    }
X		else {
X		    fprintf(stderr, "xll >= %.2f\n", pagelength);
X		    exit(1);
X		    }
X	    else {
X		fprintf(stderr, "xur <= 0.0\n");
X		exit(1);
X		}
X	else {
X	    fprintf(stderr, "xur <= xll\n");
X	    exit(1);
X	    }
X
X	if (yl < yu)
X	    if (0.0 < yu)
X		if (yl < pageheight) {
X		    yl	 = (0.0 < yl) ? yl: 0.0;
X		    yu	 = (yu < pageheight) ? yu: pageheight;
X		    }
X		else {
X		    fprintf(stderr, "yll >= %.2f\n", pageheight);
X		    exit(1);
X		    }
X	    else {
X		fprintf(stderr, "yur <= 0.0\n");
X		exit(1);
X		}
X	else {
X	    fprintf(stderr, "yur <= yll\n");
X	    exit(1);
X	    }
X
X	ppi	 = objects->nwcorner.x;
X	cpi	 = mag*100.0/sqrt((xu-xl)*(xu-xl) + (yu-yl)*(yu-yl));
X	cpp	 = cpi/ppi;
X	if (objects->nwcorner.y == 2)
X	    flipped	 = TRUE;
X
X	/* IBMGL start */
X	fprintf(tfp, "IN;\n");			/* initialize plotter	*/
X
X	if (portrait) {				/* portrait mode	*/
X	    fprintf(tfp, "RO90;\n");		/* rotate 90 degrees	*/
X	    Xll	 = yl*UNITS_PER_INCH;
X	    Xur	 = yu*UNITS_PER_INCH;
X	    Yll	 = (pagelength - xu)*UNITS_PER_INCH;
X	    Yur	 = (pagelength - xl)*UNITS_PER_INCH;
X	    length	 = yu - yl;
X	    height	 = xu - xl;
X	    P1x	 	 = Xll;
X	    P2x		 = Xur;
X	    if (reflected)			/* upside-down text	*/
X		hcmpp	 = -hcmpp;
X	    if (reflected^flipped) {		/* reflected or flipped */
X		P1y	 = Yur;			/* but not both		*/
X		P2y	 = Yll;
X		}
X	    else {				/* normal		*/
X		P1y	 = Yll;
X		P2y	 = Yur;
X		}
X	    Xmin	 =  xz;
X	    Xmax	 =  xz + (yu - yl)/mag;
X	    Ymin	 =  yz;
X	    Ymax	 =  yz + (xu - xl)/mag;
X	    }
X	else {					/* landscape mode	*/
X	    Xll	 = xl*UNITS_PER_INCH;
X	    Yll	 = yl*UNITS_PER_INCH;
X	    Yur	 = yu*UNITS_PER_INCH;
X	    Xur	 = xu*UNITS_PER_INCH;
X	    length	 = xu - xl;
X	    height	 = yu - yl;
X	    if (reflected) {			/* flipped   or not	*/
X		wcmpp	 = -wcmpp;		/* backward text	*/
X		P1x	 = Xur;
X		P2x	 = Xll;
X		}
X	    else {				/* normal		*/
X		P1x	 = Xll;
X		P2x	 = Xur;
X		}
X	    if (flipped) {			/* reflected or not	*/
X		P1y	 = Yur;
X		P2y	 = Yll;
X		}
X	    else {
X		P1y 	 = Yll;
X		P2y 	 = Yur;
X		}
X	    }
X
X	Xmin	 = xz;
X	Ymin	 = yz;
X	Xmax	 = xz + length/mag;
X	Ymax	 = yz + height/mag;
X
X	fprintf(tfp, "IP%d,%d,%d,%d;\n",
X		P1x, P1y, P2x, P2y);
X	fprintf(tfp, "IW%d,%d,%d,%d;\n",
X		Xll, Yll, Xur, Yur);
X	fprintf(tfp, "SC%.4f,%.4f,%.4f,%.4f;\n",
X		Xmin,Xmax,Ymin,Ymax);
X	if (0.0 < pen_speed && pen_speed < SPEED_LIMIT)
X	    fprintf(tfp, "VS%.2f;\n", pen_speed);
X}
X
Xstatic arc_tangent(x1, y1, x2, y2, direction, x, y)
Xdouble	x1, y1, x2, y2, *x, *y;
Xint	direction;
X{
X	if (direction) { /* counter clockwise  */
X	    *x = x2 - (y2 - y1);
X	    *y = y2 + (x2 - x1);
X	    }
X	else {
X	    *x = x2 + (y2 - y1);
X	    *y = y2 - (x2 - x1);
X	    }
X	}
X
X/*	draw arrow heading from (x1, y1) to (x2, y2)	*/
X
Xstatic draw_arrow_head(x1, y1, x2, y2, arrowht, arrowwid)
Xdouble	x1, y1, x2, y2, arrowht, arrowwid;
X{
X	double	x, y, xb, yb, dx, dy, l, sina, cosa;
X	double	xc, yc, xd, yd;
X	int style;
X	double length;
X
X	dx	 = x2 - x1;
X	dy	 = y1 - y2;
X	l	 = sqrt(dx*dx+dy*dy);
X	sina	 = dy/l;
X	cosa	 = dx/l;
X	xb	 = x2*cosa - y2*sina;
X	yb	 = x2*sina + y2*cosa;
X	x	 = xb - arrowht;
X	y	 = yb - arrowwid/2.0;
X	xc	 =  x*cosa + y*sina;
X	yc	 = -x*sina + y*cosa;
X	y	 = yb + arrowwid/2.0;
X	xd	 =  x*cosa + y*sina;
X	yd	 = -x*sina + y*cosa;
X
X	/* save line style and set to solid */
X	style	 = line_style;
X	length	 = dash_length;
X	set_style(SOLID_LINE, 0.0);
X
X	fprintf(tfp, "PA%.4f,%.4f;PD%.4f,%.4f,%.4f,%.4f;PU\n",
X		xc, yc, x2, y2, xd, yd);
X
X	/* restore line style */
X	set_style(style, length);
X	}
X
X/* 
X * set_style - issue line style commands as appropriate
X */
Xstatic set_style(style, length)
Xint	style;
Xdouble	length;
X{
X	if (style == line_style)
X	    switch (line_style) {
X		case SOLID_LINE:
X		    break;
X
X		case DASH_LINE:
X		    if (dash_length != length && length > 0.0) {
X			dash_length  = length;
X			fprintf(tfp, "LT2,%.4f;\n", dash_length*2.0*cpp);
X			}
X		    break;
X
X		case DOTTED_LINE:
X		    if (dash_length != length && length > 0.0) {
X			dash_length  = length;
X			fprintf(tfp, "LT1,%.4f;\n", dash_length*2.0*cpp);
X			}
X		    break;
X		}
X	else {
X	    line_style = style;
X	    switch (line_style) {
X		case SOLID_LINE:
X		    fprintf(tfp, "LT;\n");
X		    break;
X
X		case DASH_LINE:
X		    if (dash_length != length && length > 0.0)
X			dash_length  = length;
X		    if (dash_length > 0.0)
X			fprintf(tfp, "LT2,%.4f;\n", dash_length*2.0*cpp);
X		    else
X			fprintf(tfp, "LT2,-1.0;\n");
X		    break;
X
X		case DOTTED_LINE:
X		    if (dash_length != length && length > 0.0)
X			dash_length  = length;
X		    if (dash_length > 0.0)
X			fprintf(tfp, "LT1,%.4f;\n", dash_length*2.0*cpp);
X		    else
X			fprintf(tfp, "LT1,-1.0;\n");
X		    break;
X		}
X	    }
X    }
X
X/* 
X * set_width - issue line width commands as appropriate
X */
Xstatic set_width(w)
Xint	w;
X{
Xstatic	int	line_width	 = DEFAULT;	/* in pixels		 */
X	line_width  = w;
X	}
X
X/* 
X * set_color - issue line color commands as appropriate
X */
Xstatic set_color(color)
Xint	color;
X{
Xstatic	int	number		 = 0;	/* 1 <= number <= 8		*/
Xstatic	double	thickness	 = 0.3;	/* pen thickness in millimeters	*/
X	if (line_color != color) {
X	    line_color  = color;
X	    color	= (colors + color)%colors;
X	    if (number != pen_number[color]) {
X		number  = pen_number[color];
X		fprintf(tfp, "SP%d;\n", pen_number[color]);
X		}
X	    if (thickness != pen_thickness[color]) {
X		thickness  = pen_thickness[color];
X		fprintf(tfp, "PT%.4f;\n", pen_thickness[color]);
X		}
X	    }
X	}
X
Xstatic fill_polygon(pattern)
Xint	pattern;
X{
X	if (1 < pattern && pattern <= patterns) {
X	    int		style;
X	    double	length;
X	    if (fill_pattern != pattern) {
X		fill_pattern  = pattern;
X		fprintf(tfp, "FT%d,%.4f,%.4f;", fill_type[pattern],
X			fill_space[pattern],
X			reflected ? -fill_angle[pattern]: fill_angle[pattern]);
X		}
X	    /*    save line style */
X	    style	 = line_style;
X	    length	 = dash_length;
X	    fprintf(tfp, "LT%d,%.4f;FP;\n",
X		    line_type[pattern], line_space[pattern]*cpi);
X	    /* restore line style */
X	    line_style	 = DEFAULT;
X	    dash_length	 = DEFAULT;
X	    set_style(style, length);
X	    }
X	}
X	
Xvoid arc(sx, sy, cx, cy, theta, delta)
Xdouble	sx, sy, cx, cy, theta, delta;
X{
X	if (ibmgec)
X	    if (delta == M_PI/36.0)		/* 5 degrees		*/
X		fprintf(tfp, "AA%.4f,%.4f,%.4f;",
X			cx, cy, theta*DPR);
X	    else
X		fprintf(tfp, "AA%.4f,%.4f,%.4f,%.4f;",
X			cx, cy, theta*DPR, delta*DPR);
X	else {
X	    double	alpha;
X	    if (theta < 0.0)
X		delta = -fabs(delta);
X	    else
X		delta = fabs(delta);
X	    for (alpha = delta; fabs(alpha) < fabs(theta); alpha += delta) {
X		fprintf(tfp, "PA%.4f,%.4f;\n",
X	    		cx + (sx - cx)*cos(alpha) - (sy - cy)*sin(alpha),
X	    		cy + (sy - cy)*cos(alpha) + (sx - cx)*sin(alpha));
X		}
X	    fprintf(tfp, "PA%.4f,%.4f;\n",
X	    	    cx + (sx - cx)*cos(theta) - (sy - cy)*sin(theta),
X	    	    cy + (sy - cy)*cos(theta) + (sx - cx)*sin(theta));
X	    }
X	}
X
Xvoid genibmgl_arc(a)
XF_arc	*a;
X{
X	if (a->thickness != 0 ||
X		ibmgec && 1 <= a->area_fill && a->area_fill <= patterns) {
X	    double	x, y;
X	    double	cx, cy, sx, sy, ex, ey;
X	    double	dx1, dy1, dx2, dy2, theta;
X
X	    set_style(a->style, a->style_val);
X	    set_width(a->thickness);
X	    set_color(a->color);
X
X	    cx		 = a->center.x/ppi;
X	    cy		 = a->center.y/ppi;
X	    sx		 = a->point[0].x/ppi;
X	    sy		 = a->point[0].y/ppi;
X	    ex		 = a->point[2].x/ppi;
X	    ey		 = a->point[2].y/ppi;
X
X	    dx1		 = sx - cx;
X	    dy1		 = sy - cy;
X	    dx2		 = ex - cx;
X	    dy2		 = ey - cy;
X	    
X	    theta	 = atan2(dy2, dx2) - atan2(dy1, dx1);
X	    if (a->direction^flipped) {
X		if (theta < 0.0)
X		    theta	+= 2.0*M_PI;
X		}
X	    else {
X		if (theta > 0.0)
X		    theta	-= 2.0*M_PI;
X		}
X
X	    if (a->thickness != 0 && a->back_arrow) {
X		arc_tangent(cx, cy, sx, sy, a->direction^flipped, &x, &y);
X		draw_arrow_head(x, y, sx, sy,
X		a->back_arrow->ht/ppi, a->back_arrow->wid/ppi);
X		}
X
X	    fprintf(tfp, "PA%.4f,%.4f;PM;PD;", sx, sy);
X	    arc(sx, sy, cx, cy, theta, DELTA);
X	    fprintf(tfp, "PU;PM2;\n");
X
X	    if (a->thickness != 0)
X		fprintf(tfp, "EP;\n");
X
X	    if (a->thickness != 0 && a->for_arrow) {
X		arc_tangent(cx, cy, ex, ey, !a->direction^flipped, &x, &y);
X		draw_arrow_head(x, y, ex, ey,
X			a->for_arrow->ht/ppi, a->for_arrow->wid/ppi);
X		}
X
X	    if (1 < a->area_fill && a->area_fill <= patterns)
X		fill_polygon(a->area_fill);
X	    }
X	}
X
Xvoid genibmgl_ellipse(e)
XF_ellipse	*e;
X{
X	if (e->thickness != 0 ||
X		ibmgec && 1 <= e->area_fill && e->area_fill <= patterns) {
X	    int		j;
X	    double	alpha	 = 0.0;
X	    double	angle;
X	    double	delta;
X	    double	x0, y0;
X	    double	a,  b;
X	    double	x,  y;
X
X	    set_style(e->style, e->style_val);
X	    set_width(e->thickness);
X	    set_color(e->color);
X
X	    a		 = e->radiuses.x/ppi;
X	    b		 = e->radiuses.y/ppi;
X	    x0		 = e->center.x/ppi;
X	    y0		 = e->center.y/ppi;
X	    angle	 = (flipped ? -e->angle: e->angle);
X	    delta	 = (flipped ? -DELTA: DELTA);
X
X	    x		 = x0 + cos(angle)*a;
X	    y		 = y0 + sin(angle)*a;
X	    fprintf(tfp, "PA%.4f,%.4f;PM;PD;\n", x, y);
X	    for (j = 1; j <= 72; j++) { alpha	 = j*delta;
X		x	 = x0 + cos(angle)*a*cos(alpha)
X	    		 - sin(angle)*b*sin(alpha);
X		y	 = y0 + sin(angle)*a*cos(alpha)
X	    		 + cos(angle)*b*sin(alpha);
X		fprintf(tfp, "PA%.4f,%.4f;\n", x, y);
X		}
X	    fprintf(tfp, "PU;PM2;\n");
X
X	    if (e->thickness != 0)
X		fprintf(tfp, "EP;\n");
X
X	    if (1 < e->area_fill && e->area_fill <= patterns)
X		fill_polygon((int)e->area_fill);
X	    }
X	}
X
Xvoid swap(i, j)
Xint	*i, *j;
X{	int	t; t = *i; *i = *j; *j = t; }
X
Xvoid genibmgl_line(l)
XF_line	*l;
X{
X	if (l->thickness != 0 ||
X		ibmgec && 1 <= l->area_fill && l->area_fill <= patterns) {
X	    F_point	*p, *q;
X
X	    set_style(l->style, l->style_val);
X	    set_width(l->thickness);
X	    set_color(l->color);
X
X	    p	 = l->points;
X	    q	 = p->next;
X
X	    switch (l->type) {
X		case	T_POLYLINE:
X		case	T_BOX:
X		case	T_POLYGON:
X		    if (q == NULL)		/* A single point line */
X			fprintf(tfp, "PA%.4f,%.4f;PD;PU;\n",
X				p->x/ppi, p->y/ppi);
X		    else {
X			if (l->thickness != 0 && l->back_arrow)
X			    draw_arrow_head(q->x/ppi, q->y/ppi,
X		    		    p->x/ppi, p->y/ppi,
X				    l->back_arrow->ht/ppi,
X				    l->back_arrow->wid/ppi);
X
X			fprintf(tfp, "PA%.4f,%.4f;PM;PD%.4f,%.4f;\n",
X				p->x/ppi, p->y/ppi,
X				q->x/ppi, q->y/ppi);
X			while (q->next != NULL) {
X			    p	 = q;
X			    q	 = q->next;
X			    fprintf(tfp, "PA%.4f,%.4f;\n",
X				    q->x/ppi, q->y/ppi);
X			    }
X			fprintf(tfp, "PU;PM2;\n");
X
X			if (l->thickness != 0)
X			    fprintf(tfp, "EP;\n");
X
X			if (l->thickness != 0 && l->for_arrow)
X		    	    draw_arrow_head(p->x/ppi, p->y/ppi,
X				    q->x/ppi, q->y/ppi,
X				    l->for_arrow->ht/ppi,
X				    l->for_arrow->wid/ppi);
X
X			if (1 < l->area_fill && l->area_fill <= patterns)
X			    fill_polygon((int)l->area_fill);
X			}
X		    break;
X
X		case	T_ARC_BOX: {
X		    int		llx, lly, urx, ury;
X		    double	 x0,  y0,  x1,  y1;
X		    double	dx, dy, angle;
X
X		    llx	 = urx	= p->x;
X		    lly	 = ury	= p->y;
X		    while ((p = p->next) != NULL) {
X			if (llx > p->x)
X			    llx = p->x;
X			if (urx < p->x)
X			    urx = p->x;
X			if (lly > p->y)
X			    lly = p->y;
X			if (ury < p->y)
X			    ury = p->y;
X			}
X
X		    x0	 = llx/ppi;
X		    x1	 = urx/ppi;
X		    dx	 = l->radius/ppi;
X		    if (flipped) {
X			y0	 = ury/ppi;
X			y1	 = lly/ppi;
X			dy	 = -dx;
X			angle	 = -M_PI/2.0;
X			}
X		    else {
X			y0	 = lly/ppi;
X			y1	 = ury/ppi;
X			dy	 =  dx;
X			angle	 =  M_PI/2.0;
X			}
X
X		    fprintf(tfp, "PA%.4f,%.4f;PM;PD;\n",  x0, y0 + dy);
X		    arc(x0, y0 + dy, x0 + dx, y0 + dy, angle, DELTA);
X		    fprintf(tfp, "PA%.4f,%.4f;\n", x1 - dx, y0);
X		    arc(x1 - dx, y0, x1 - dx, y0 + dy, angle, DELTA);
X		    fprintf(tfp, "PA%.4f,%.4f;\n", x1, y1 - dy);
X		    arc(x1, y1 - dy, x1 - dx, y1 - dy, angle, DELTA);
X		    fprintf(tfp, "PA%.4f,%.4f;\n", x0 + dx, y1);
X		    arc(x0 + dx, y1, x0 + dx, y1 - dy, angle, DELTA);
X		    fprintf(tfp, "PA%.4f,%.4f;PU;PM2;\n", x0, y0 + dy);
X
X		    if (l->thickness != 0)
X			fprintf(tfp, "EP;\n");
X
X		    if (1 < l->area_fill && l->area_fill <= patterns)
X			fill_polygon((int)l->area_fill);
X		    }
X		    break;
X
X		case	T_EPS_BOX:
X		    break;
X		}
X	    }
X	}
X
X#define		THRESHOLD	.05	/* inch */
X
Xstatic bezier_spline(a0, b0, a1, b1, a2, b2, a3, b3)
Xdouble	a0, b0, a1, b1, a2, b2, a3, b3;
X{
X	double	x0, y0, x3, y3;
X	double	sx1, sy1, sx2, sy2, tx, ty, tx1, ty1, tx2, ty2, xmid, ymid;
X
X	x0 = a0; y0 = b0;
X	x3 = a3; y3 = b3;
X	if (fabs(x0 - x3) < THRESHOLD && fabs(y0 - y3) < THRESHOLD)
X	    fprintf(tfp, "PA%.4f,%.4f;\n", x3, y3);
X
X	else {
X	    tx   = (a1  + a2 )/2.0;	ty   = (b1  + b2 )/2.0;
X	    sx1  = (x0  + a1 )/2.0;	sy1  = (y0  + b1 )/2.0;
X	    sx2  = (sx1 + tx )/2.0;	sy2  = (sy1 + ty )/2.0;
X	    tx2  = (a2  + x3 )/2.0;	ty2  = (b2  + y3 )/2.0;
X	    tx1  = (tx2 + tx )/2.0;	ty1  = (ty2 + ty )/2.0;
X	    xmid = (sx2 + tx1)/2.0;	ymid = (sy2 + ty1)/2.0;
X
X	    bezier_spline(x0, y0, sx1, sy1, sx2, sy2, xmid, ymid);
X	    bezier_spline(xmid, ymid, tx1, ty1, tx2, ty2, x3, y3);
X	    }
X	}
X
Xstatic void genibmgl_itp_spline(s)
XF_spline	*s;
X{
X	F_point		*p1, *p2;
X	F_control	*cp1, *cp2;
X	double		x1, x2, y1, y2;
X
X	p1 = s->points;
X	cp1 = s->controls;
X	x2 = p1->x/ppi; y2 = p1->y/ppi;
X
X	if (s->thickness != 0 && s->back_arrow)
X	    draw_arrow_head(cp1->rx/ppi, cp1->ry/ppi, x2, y2,
X		    s->back_arrow->ht/ppi, s->back_arrow->wid/ppi);
X
X	fprintf(tfp, "PA%.4f,%.4f;PD;\n", x2, y2);
X	for (p2 = p1->next, cp2 = cp1->next; p2 != NULL;
X		p1 = p2, cp1 = cp2, p2 = p2->next, cp2 = cp2->next) {
X	    x1	 = x2;
X	    y1	 = y2;
X	    x2	 = p2->x/ppi;
X	    y2	 = p2->y/ppi;
X	    bezier_spline(x1, y1, (double)cp1->rx/ppi, cp1->ry/ppi,
X		(double)cp2->lx/ppi, cp2->ly/ppi, x2, y2);
X	    }
X	fprintf(tfp, "PU;\n");
X
X	if (s->thickness != 0 && s->for_arrow)
X	    draw_arrow_head(cp1->lx/ppi, cp1->ly/ppi, x2, y2,
X		    s->for_arrow->ht/ppi, s->for_arrow->wid/ppi);
X	}
X
Xstatic quadratic_spline(a1, b1, a2, b2, a3, b3, a4, b4)
Xdouble	a1, b1, a2, b2, a3, b3, a4, b4;
X{
X	double	x1, y1, x4, y4;
X	double	xmid, ymid;
X
X	x1	 = a1; y1 = b1;
X	x4	 = a4; y4 = b4;
X	xmid	 = (a2 + a3)/2.0;
X	ymid	 = (b2 + b3)/2.0;
X	if (fabs(x1 - xmid) < THRESHOLD && fabs(y1 - ymid) < THRESHOLD)
X	    fprintf(tfp, "PA%.4f,%.4f;\n", xmid, ymid);
X	else {
X	    quadratic_spline(x1, y1, ((x1+a2)/2.0), ((y1+b2)/2.0),
X		((3.0*a2+a3)/4.0), ((3.0*b2+b3)/4.0), xmid, ymid);
X	    }
X
X	if (fabs(xmid - x4) < THRESHOLD && fabs(ymid - y4) < THRESHOLD)
X	    fprintf(tfp, "PA%.4f,%.4f;\n", x4, y4);
X	else {
X	    quadratic_spline(xmid, ymid, ((a2+3.0*a3)/4.0), ((b2+3.0*b3)/4.0),
X			((a3+x4)/2.0), ((b3+y4)/2.0), x4, y4);
X	    }
X	}
X
Xstatic void genibmgl_ctl_spline(s)
XF_spline	*s;
X{
X	F_point	*p;
X	double	cx1, cy1, cx2, cy2, cx3, cy3, cx4, cy4;
X	double	x1, y1, x2, y2;
X
X	p	 = s->points;
X	x1	 = p->x/ppi;
X	y1	 = p->y/ppi;
X	p	 = p->next;
X	x2	 = p->x/ppi;
X	y2	 = p->y/ppi;
X	cx1	 = (x1 + x2)/2.0;
X	cy1	 = (y1 + y2)/2.0;
X	cx2	 = (x1 + 3.0*x2)/4.0;
X	cy2	 = (y1 + 3.0*y2)/4.0;
X
X	if (closed_spline(s))
X	    fprintf(tfp, "PA%.4f,%.4f;PD;\n ", cx1, cy1);
X	else {
X	    if (s->thickness != 0 && s->back_arrow)
X		draw_arrow_head(cx1, cy1, x1, y1,
X			s->back_arrow->ht/ppi, s->back_arrow->wid/ppi);
X	    fprintf(tfp, "PA%.4f,%.4f;PD%.4f,%.4f;\n",
X		    x1, y1, cx1, cy1);
X	    }
X
X	for (p = p->next; p != NULL; p = p->next) {
X	    x1	 = x2;
X	    y1	 = y2;
X	    x2	 = p->x/ppi;
X	    y2	 = p->y/ppi;
X	    cx3	 = (3.0*x1 + x2)/4.0;
X	    cy3	 = (3.0*y1 + y2)/4.0;
X	    cx4	 = (x1 + x2)/2.0;
X	    cy4	 = (y1 + y2)/2.0;
X	    quadratic_spline(cx1, cy1, cx2, cy2, cx3, cy3, cx4, cy4);
X	    cx1	 = cx4;
X	    cy1	 = cy4;
X	    cx2	 = (x1 + 3.0*x2)/4.0;
X	    cy2	 = (y1 + 3.0*y2)/4.0;
X	    }
X	x1	 = x2; 
X	y1	 = y2;
X	p	 = s->points->next;
X	x2	 = p->x/ppi;
X	y2	 = p->y/ppi;
X	cx3	 = (3.0*x1 + x2)/4.0;
X	cy3	 = (3.0*y1 + y2)/4.0;
X	cx4	 = (x1 + x2)/2.0;
X	cy4	 = (y1 + y2)/2.0;
X	if (closed_spline(s)) {
X	    quadratic_spline(cx1, cy1, cx2, cy2, cx3, cy3, cx4, cy4);
X	    fprintf(tfp, "PU;\n");
X	    }
X	else {
X	    fprintf(tfp, "PA%.4f,%.4f;PU;\n", x1, y1);
X	    if (s->thickness != 0 && s->for_arrow)
X	    	draw_arrow_head(cx1, cy1, x1, y1,
X			s->for_arrow->ht/ppi, s->for_arrow->wid/ppi);
X	    }
X	}
X
Xvoid genibmgl_spline(s)
XF_spline	*s;
X{
X	if (s->thickness != 0) {
X	    set_style(s->style, s->style_val);
X	    set_width(s->thickness);
X	    set_color(s->color);
X
X	    if (int_spline(s))
X		genibmgl_itp_spline(s);
X	    else
X		genibmgl_ctl_spline(s);
X
X	    }
X	if (1 < s->area_fill && s->area_fill <= patterns)
X	    fprintf(stderr, "Spline area fill not implemented\n");
X}
X
X#define	FONT(T) ((-1 < (T) && (T) < fonts) ? (T): fonts)
Xvoid genibmgl_text(t)
XF_text	*t;
X{
Xstatic	int	font	 = DEFAULT;	/* font				*/
Xstatic	int	size	 = DEFAULT;	/* font size	    in points	*/
Xstatic	int	rigid	 = 0;		/* rigid text			*/
Xstatic	int	cs	 = 0;		/* standard  character set	*/
Xstatic	int	ca	 = 0;		/* alternate character set	*/
Xstatic	double	theta	 = 0.0;		/* character slant  in degrees	*/
Xstatic	double	angle	 = 0.0;		/* label direction  in radians	*/
X	double	width;			/* character width  in centimeters */
X	double	height;			/* character height in centimeters */
X
X	if (font != FONT(t->font)) {
X	    font  = FONT(t->font);
X	    if (cs != standard[font]) {
X		cs  = standard[font];
X		fprintf(tfp, "CS%d;", cs);
X		}
X	    if (ca != alternate[font]) {
X		ca  = alternate[font];
X		fprintf(tfp, "CA%d;", ca);
X		}
X	    if (theta != slant[font]) {
X		theta  = slant[font];
X		fprintf(tfp, "SL%.4f;", tan(theta*M_PI/180.0));
X		}
X	    }
X	if (size != t->size || rigid != t->flags&RIGID_TEXT) {
X	    size  = t->size ? t->size: font_size;
X	    rigid  = (t->flags&RIGID_TEXT);
X	    width	 = size*wcmpp*wide[font];
X	    height	 = size*hcmpp*high[font];
X	    rigid	 = (t->flags&RIGID_TEXT);
X	    if (rigid)
X		fprintf(tfp, "SI%.4f,%.4f;", width, height);
X	    else
X		fprintf(tfp, "SI%.4f,%.4f;", width*mag, height*mag);
X	    }
X	if (angle != t->angle) {
X	    angle  = t->angle;
X	    fprintf(tfp, "DI%.4f,%.4f;",
X		    cos(angle), sin(reflected ? -angle: angle));
X	    }
X	set_color(t->color);
X
X	fprintf(tfp, "PA%.4f,%.4f;\n",
X		t->base_x/ppi, t->base_y/ppi);
X
X	switch (t->type) {
X	    case DEFAULT:
X	    case T_LEFT_JUSTIFIED:
X		break;
X	    case T_CENTER_JUSTIFIED:
X		fprintf(tfp, "CP%.4f,0.0;", -(double)(strlen(t->cstring)/2.0));
X		break;
X	    case T_RIGHT_JUSTIFIED:
X		fprintf(tfp, "CP%.4f,0.0;", -(double)(strlen(t->cstring)));
X		break;
X	    default:
X		fprintf(stderr, "unknown text position type\n");
X		exit(1);
X	    }    
X
X	fprintf(tfp, "LB%s\003\n", t->cstring);
X	}
X
Xvoid genibmgl_end()
X{
X	/* IBMGL ending */
X	fprintf(tfp, "PU;SP;IN;\n");
X}
X
Xstruct driver dev_ibmgl = {
X     	genibmgl_option,
X	genibmgl_start,
X	genibmgl_arc,
X	genibmgl_ellipse,
X	genibmgl_line,
X	genibmgl_spline,
X	genibmgl_text,
X	genibmgl_end,
X	EXCLUDE_TEXT
X	};
END_OF_FILE
if test 26109 -ne `wc -c <'fig2dev/dev/genibmgl.c'`; then
    echo shar: \"'fig2dev/dev/genibmgl.c'\" unpacked with wrong size!
fi
# end of 'fig2dev/dev/genibmgl.c'
fi
if test -f 'fig2dev/dev/genpictex.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fig2dev/dev/genpictex.c'\"
else
echo shar: Extracting \"'fig2dev/dev/genpictex.c'\" \(25452 characters\)
sed "s/^X//" >'fig2dev/dev/genpictex.c' <<'END_OF_FILE'
X/*
X * TransFig: Facility for Translating Fig code
X * Copyright (c) 1985 Supoj Sutantavibul
X * Copyright (c) 1991 Micah Beck
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation. The authors make no representations about the suitability 
X * of this software for any purpose.  It is provided "as is" without express 
X * or implied warranty.
X *
X * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
X * EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
X * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X *
X */
X
X/* 
X *	genpictex.C : PiCTeX driver for fig2dev
X *
X * 	Author Micah Beck, Cornell University, 4/88
X *    Color, rotated text and ISO-chars added by Herbert Bauer 11/91
X*/
X#if defined(hpux) || defined(SYSV)
X#include <sys/types.h>
X#endif
X#include <sys/file.h>
X#include <stdio.h>
X#include <math.h>
X#include "pi.h"
X#include "object.h"
X#include "fig2dev.h"
X#include "texfonts.h"
X
X#define UNIT "cm"       /* dip */
X#define CONVUNIT 2.54   /* dip */
X
X#ifndef fabs
Xextern double fabs();
X#endif
X#ifndef sin
Xextern double sin();
X#endif
X#ifndef cos
Xextern double cos();
X#endif
X#ifndef acos
Xextern double acos();
X#endif
Xextern char *ISOtoTeX[];
X
Xvoid genpictex_ctl_spline(), genpictex_itp_spline();
X
Xstatic int		coord_system;
Xstatic double		dash_length = -1;
Xstatic int		line_style = SOLID_LINE;
Xstatic char 		*linethick = "1pt";
Xstatic char		*plotsymbol = "\\makebox(0,0)[l]{\\tencirc\\symbol{'160}}";
Xstatic int		cur_thickness = -1;
X
Xstatic void genpictex_option(opt, optarg)
Xchar opt, *optarg;
X{
X        int i;
X
X	switch (opt) {
X
X		case 'a':
X		    fprintf(stderr, "warning: pictex option -a obsolete\n");
X		    break;
X
X		case 'f':			/* set default text font */
X		    for ( i = 1; i <= MAX_FONT; i++ )
X			if ( !strcmp(optarg, texfontnames[i]) ) break;
X
X		    if ( i > MAX_FONT)
X			fprintf(stderr,
X			"warning: non-standard font name %s\n", optarg);
X		
X		    texfontnames[0] = texfontnames[1] = optarg;
X		    break;
X
X		case 'l':			/* set line thickness */
X		    linethick = optarg;
X		    break;
X
X		case 'p':			/* set plot symbol */
X		    plotsymbol = optarg;
X		    break;
X
X		case 's':
X		    if (font_size <= 0 || font_size > MAXFONTSIZE) {
X			fprintf(stderr,
X				"warning: font size %d out of bounds\n", font_size);
X		    }
X		    break;
X
X		case 'm':
X		case 'L':
X		    break;
X
X	default:
X		put_msg(Err_badarg, opt, "pictex");
X		exit(1);
X		break;
X	}
X}
X
X#define			TOP	10.5	/* top of page is 10.5 inch */
Xstatic double		ppi;
Xstatic int		CONV = 0;
X
Xstatic double convy(a)
Xdouble	a;
X{
X	return((double)(CONV ? TOP-a : a));
X}
X
Xvoid genpictex_start(objects)
XF_compound	*objects;
X{
X	texfontsizes[0] = texfontsizes[1] = TEXFONTSIZE(font_size);
X
X	coord_system = objects->nwcorner.y;
X	ppi = objects->nwcorner.x;
X	if (coord_system == 2) CONV = 1;
X
X	/* PiCTeX start */
X	fprintf(tfp, "\\font\\thinlinefont=cmr5\n");
X	define_setfigfont(tfp);
X	fprintf(tfp, "\\mbox{\\beginpicture\n");
X	fprintf(tfp, "\\setcoordinatesystem units <%6.3f%s,%6.3f%s>\n",
X			mag, UNIT, mag, UNIT);
X	fprintf(tfp, "\\unitlength=%6.3f%s\n", mag, UNIT);
X	fprintf(tfp, "\\linethickness=%s\n", linethick);
X	fprintf(tfp, "\\setplotsymbol ({%s})\n", plotsymbol);
X	fprintf(tfp, "\\setshadesymbol ({\\thinlinefont .})\n");
X	fprintf(tfp, "\\setlinear\n");
X}
X
Xvoid genpictex_end()
X{
X	/* PiCTeX ending */
X	fprintf(tfp, "\\linethickness=0pt\n");
X        fprintf(tfp, "\\putrectangle corners at %6.3f %6.3f and %6.3f %6.3f\n",
X		(llx/ppi)*CONVUNIT, (convy(lly/ppi))*CONVUNIT, (urx/ppi)*CONVUNIT, (convy(ury/ppi))*CONVUNIT);
X	fprintf(tfp, "\\endpicture}\n");
X}
X
Xstatic set_linewidth(w)
Xint	w;
X{
X/*	static int	cur_thickness = -1;*/
X
X/*	if (w == 0) return;*/
X/*	if (w != cur_thickness) {*/
X	    if (!w) {
X		fprintf(tfp, "\\linethickness=0pt\n");
X		cur_thickness = 0;
X		}
X	    else {
X		cur_thickness = round(w*mag);
X
X		if (!cur_thickness || cur_thickness == 1) {
X		    cur_thickness = 1;
X		    fprintf(tfp, "\\linethickness=%6.3fpt\n", 0.5*cur_thickness);
X		    }
X		else {
X		    fprintf(tfp, "\\linethickness=%dpt\n", cur_thickness-1);
X		    }
X		}
X	    switch (cur_thickness) {
X		    case 0:
X                        fprintf(tfp, "\\setplotsymbol ({%s})\n", "\\thinlinefont \\ ");
X			    break;
X		    case 1:
X                        fprintf(tfp, "\\setplotsymbol ({%s})\n", "\\thinlinefont .");
X			    break;
X		    case 2:
X                        fprintf(tfp, "\\setplotsymbol ({%s})\n", "\\makebox(0,0)[l]{\\tencirc\\symbol{'160}}");
X			    break;
X		    case 3:
X                        fprintf(tfp, "\\setplotsymbol ({%s})\n", "\\makebox(0,0)[l]{\\tencirc\\symbol{'161}}");
X			    break;
X		    case 4:
X                        fprintf(tfp, "\\setplotsymbol ({%s})\n", "\\makebox(0,0)[l]{\\tencirc\\symbol{'162}}");
X			    break;
X		    case 5:
X                        fprintf(tfp, "\\setplotsymbol ({%s})\n", "\\makebox(0,0)[l]{\\tencirc\\symbol{'163}}");
X			    break;
X		    case 6:
X                        fprintf(tfp, "\\setplotsymbol ({%s})\n", "\\makebox(0,0)[l]{\\tencirc\\symbol{'164}}");
X			    break;
X		    case 7:
X                        fprintf(tfp, "\\setplotsymbol ({%s})\n", "\\makebox(0,0)[l]{\\tencirc\\symbol{'165}}");
X			    break;
X		    case 8:
X                        fprintf(tfp, "\\setplotsymbol ({%s})\n", "\\makebox(0,0)[l]{\\tencirc\\symbol{'166}}");
X			    break;
X		    case 9:
X                        fprintf(tfp, "\\setplotsymbol ({%s})\n", "\\makebox(0,0)[l]{\\tencirc\\symbol{'167}}");
X			    break;
X		    case 10:
X                        fprintf(tfp, "\\setplotsymbol ({%s})\n", "\\makebox(0,0)[l]{\\tencirc\\symbol{'170}}");
X			    break;
X		    case 11:
X                        fprintf(tfp, "\\setplotsymbol ({%s})\n", "\\makebox(0,0)[l]{\\tencirc\\symbol{'171}}");
X			    break;
X		    case 12:
X                        fprintf(tfp, "\\setplotsymbol ({%s})\n", "\\makebox(0,0)[l]{\\tencirc\\symbol{'172}}");
X			    break;
X		    case 13:
X                        fprintf(tfp, "\\setplotsymbol ({%s})\n", "\\makebox(0,0)[l]{\\tencirc\\symbol{'173}}");
X			    break;
X		    case 14:
X                        fprintf(tfp, "\\setplotsymbol ({%s})\n", "\\makebox(0,0)[l]{\\tencirc\\symbol{'174}}");
X			    break;
X		    case 15:
X                        fprintf(tfp, "\\setplotsymbol ({%s})\n", "\\makebox(0,0)[l]{\\tencirc\\symbol{'175}}");
X			    break;
X		    case 16:
X                        fprintf(tfp, "\\setplotsymbol ({%s})\n", "\\makebox(0,0)[l]{\\tencirc\\symbol{'176}}");
X			    break;
X		    default:
X			    fprintf(tfp, "\\setplotsymbol ({%s})\n", "\\makebox(0,0)[l]{\\tencirc\\symbol{'176}}");
X			    break;
X	    }
X/* PIC  fprintf(tfp, "\"D't %.3fi'\"\n", 0.7 * cur_thickness);*/
X/*    }*/
X}
X
Xvoid genpictex_line(l)
XF_line	*l;
X{
X	F_point		*p, *q;
X	int		x, y, llx, lly, urx, ury;
X
X	fprintf(tfp, "%%\n%% Fig POLYLINE object\n%%\n");
X
X	if (l->type == T_ARC_BOX) { /* A box with rounded corners */
X	  fprintf(stderr, "Arc box not implemented; substituting box.\n");
X	  l->type = T_BOX;
X	}
X
X	set_linewidth(l->thickness);
X	set_style(l->style, l->style_val);
X	set_color(l->color);
X
X	p = l->points;
X	q = p->next;
X
X	if (q == NULL) { /* A single point line */
X	    fprintf(tfp, "\\plot %6.3f %6.3f %6.3f %6.3f /\n",
X			(p->x/ppi)*CONVUNIT, (convy(p->y/ppi))*CONVUNIT, (p->x/ppi)*CONVUNIT, (convy(p->y/ppi))*CONVUNIT);
X	    return;
X	    }
X
X	if (l->type == T_BOX || l->type == T_ARC_BOX) /* A (rounded corner) box */
X	{
X	    x = p->x; y=p->y;
X	    llx =urx = x;
X	    lly =ury = y;
X	    while ( q!= NULL )
X	    {
X		x = q->x; y=q->y;
X		if (x < llx) llx = x;
X		if (y < lly) lly = y;
X		if (x > urx) urx = x;
X		if (y > ury) ury = y;
X		q = q->next;
X	    }
X	    put_box (llx, lly, urx, ury, l);
X	    return; 
X	}
X
X	if (l->back_arrow)
X	    draw_arrow_head(q->x/ppi, convy(q->y/ppi), p->x/ppi,
X		convy(p->y/ppi), l->back_arrow->ht/ppi, l->back_arrow->wid/ppi);
X	set_style(l->style, l->style_val);
X
X	while (q->next != NULL) {
X
X	    putline(p->x, p->y, (double) q->x, (double) q->y,
X		    (q->next)->x, (q->next)->y, -1, -1, -1, -1);
X	    p = q;
X	    q = q->next;
X	    }
X
X	putline(p->x, p->y, (double) q->x, (double) q->y, -1, -1,
X		l->points->x, l->points->y,
X		l->points->next->x,l->points->next->y);
X	if (l->for_arrow)
X	    draw_arrow_head(p->x/ppi, convy(p->y/ppi), q->x/ppi,
X		convy(q->y/ppi), l->for_arrow->ht/ppi, l->for_arrow->wid/ppi);
X
X	if (l->area_fill && (int)l->area_fill != DEFAULT)
X		fprintf(stderr, "Line area fill not implemented\n");
X	reset_color(l->color);
X	}
X
X
X/*
X * draw box
X */
Xstatic put_box (llx, lly, urx, ury, l)
Xint	llx, lly, urx, ury;
XF_line	*l;
X{
X	int radius;
X
X	set_color(l->color);
X	if (l->type == T_BOX)
X	{
X	   if (l->area_fill && l->area_fill == BLACK_FILL)
X	   {
X	       fprintf(tfp,"\\linethickness=%6.3f%s\n", 
X	   	    ((convy(lly/ppi))-(convy(ury/ppi)))*CONVUNIT*mag, UNIT);
X	       fprintf(tfp,"{\\setsolid"); 
X	       fprintf(tfp,"\\putrule from %6.3f %6.3f to %6.3f %6.3f }%%\n",
X	   	    (llx/ppi)*CONVUNIT,
X	   	    ((convy(lly/ppi)+convy(ury/ppi))/2)*CONVUNIT,
X	   	    (urx/ppi)*CONVUNIT,
X	   	    ((convy(lly/ppi)+convy(ury/ppi))/2)*CONVUNIT);
X	       fprintf(tfp,"\\linethickness=%dpt\n", l->thickness);
X	   }
X	   else if (l->area_fill && l->area_fill > 15)
X	   {
X	       fprintf(tfp,"\\setshadegrid span <1pt>\n");
X	       fprintf(tfp,"\\shaderectangleson\n");
X	   }
X	   else if (l->area_fill && l->area_fill > 10)
X	   {
X	       fprintf(tfp,"\\setshadegrid span <2pt>\n");
X	       fprintf(tfp,"\\shaderectangleson\n");
X	   }
X	   else if (l->area_fill && l->area_fill > 5)
X	   {
X	       fprintf(tfp,"\\setshadegrid span <4pt>\n");
X	       fprintf(tfp,"\\shaderectangleson\n");
X	   }
X	   else if (l->area_fill && l->area_fill == WHITE_FILL)
X	   {
X	       fprintf(stderr,"WHITE_FILL not implemeted for boxes\n");
X	   }
X
X	   fprintf(tfp,"\\putrectangle corners at %6.3f %6.3f and %6.3f %6.3f\n",
X	   	(llx/ppi)*CONVUNIT, (convy(lly/ppi))*CONVUNIT,
X	   	(urx/ppi)*CONVUNIT, (convy(ury/ppi))*CONVUNIT);
X
X	   if (l->area_fill
X		&& l->area_fill != WHITE_FILL && l->area_fill != BLACK_FILL)
X	   {
X	       fprintf(tfp,"\\setshadegrid span <5pt>\n");
X	       fprintf(tfp,"\\shaderectanglesoff\n");
X	   }
X	}
X	else if (l->type == T_ARC_BOX)
X	{
X	   radius = l->radius;
X
X	   if (l->area_fill)
X	   {
X	       fprintf(stderr,"area fill not implemeted for rounded corner boxes\n");
X	   }
X
X	   fprintf(tfp,"\\putrule from %6.3f %6.3f to %6.3f %6.3f\n",
X		   ((llx+radius)/ppi)*CONVUNIT, (convy(lly/ppi))*CONVUNIT,
X		   ((urx-radius)/ppi)*CONVUNIT, (convy(lly/ppi))*CONVUNIT);
X	   fprintf(tfp,"\\putrule from %6.3f %6.3f to %6.3f %6.3f\n",
X		   (urx/ppi)*CONVUNIT, (convy((lly+radius)/ppi))*CONVUNIT,
X		   (urx/ppi)*CONVUNIT, (convy((ury-radius)/ppi))*CONVUNIT);
X	   fprintf(tfp,"\\putrule from %6.3f %6.3f to %6.3f %6.3f\n",
X		   ((urx-radius)/ppi)*CONVUNIT, (convy(ury/ppi))*CONVUNIT,
X		   ((llx+radius)/ppi)*CONVUNIT, (convy(ury/ppi))*CONVUNIT);
X	   fprintf(tfp,"\\putrule from %6.3f %6.3f to %6.3f %6.3f\n",
X		   (llx/ppi)*CONVUNIT, (convy((ury-radius)/ppi))*CONVUNIT,
X		   (llx/ppi)*CONVUNIT, (convy((lly+radius)/ppi))*CONVUNIT);
X	   fprintf(tfp,"\\circulararc -90 degrees from %6.3f %6.3f center at %6.3f %6.3f\n",
X		   ((urx-radius)/ppi)*CONVUNIT, (convy(lly/ppi))*CONVUNIT,
X		   ((urx-radius)/ppi)*CONVUNIT, (convy((lly+radius)/ppi))*CONVUNIT);
X	   fprintf(tfp,"\\circulararc -90 degrees from %6.3f %6.3f center at %6.3f %6.3f\n",
X		   (urx/ppi)*CONVUNIT, (convy((ury-radius)/ppi))*CONVUNIT,
X		   ((urx-radius)/ppi)*CONVUNIT, (convy((ury-radius)/ppi))*CONVUNIT);
X	   fprintf(tfp,"\\circulararc -90 degrees from %6.3f %6.3f center at %6.3f %6.3f\n",
X		   ((llx+radius)/ppi)*CONVUNIT, (convy(ury/ppi))*CONVUNIT,
X		   ((llx+radius)/ppi)*CONVUNIT, (convy((ury-radius)/ppi))*CONVUNIT);
X	   fprintf(tfp,"\\circulararc -90 degrees from %6.3f %6.3f center at %6.3f %6.3f\n",
X		   (llx/ppi)*CONVUNIT, (convy((lly+radius)/ppi))*CONVUNIT,
X		   ((llx+radius)/ppi)*CONVUNIT, (convy((lly+radius)/ppi))*CONVUNIT);
X	}
X	reset_color(l->color);
X}
X
X
X
X
X
X
X
X
X
X/* 
X * set_style - issue style commands as appropriate
X */
Xstatic set_style(style, dash_len)
Xint style;
Xdouble dash_len;
X{
X    switch (style) {
X	 case SOLID_LINE:
X	    if (line_style == SOLID_LINE) break;
X	    fprintf(tfp, "\\setsolid\n");
X	    break;
X
X	case DASH_LINE:
X	    if (line_style == DASH_LINE && dash_length == dash_len)
X		break;
X	    fprintf(tfp, "\\setdashes <%7.4f%s>\n", (0.5*dash_len*(cur_thickness+1)/ppi)*CONVUNIT, UNIT);
X	    break;
X
X	case DOTTED_LINE:
X	    if (line_style == DOTTED_LINE)
X		break;
X	    fprintf(tfp, "\\setdots <%7.4f%s>\n", (0.5*dash_len*(cur_thickness+1)/ppi)*CONVUNIT, UNIT);
X	    break;
X	    }
X
X	line_style = style;
X	dash_length = dash_len;
X    }
X
X/*
X * putline - use rules if possible
X */
Xstatic putline (start_x, start_y, end_x, end_y, next_x, next_y,
X                first_start_x, first_start_y, first_end_x, first_end_y)
Xint	start_x, start_y, next_x, next_y;
Xint	first_start_x, first_start_y, first_end_x, first_end_y;
Xdouble	end_x, end_y;
X{
X    if (line_style == SOLID_LINE &&
X	    ((start_x == end_x) || (start_y == end_y))) {
X	if (next_x != -1) {
X	    if (start_x == end_x && end_y == next_y) {
X		if (end_y > start_y)
X		    end_y += 0.5*ppi*(cur_thickness-1)/72/mag;
X		else
X		    end_y -= 0.5*ppi*(cur_thickness-1)/72/mag;
X		}
X	    else if (start_y == end_y && end_x == next_x) {
X		if (end_x > start_x)
X		    end_x += 0.5*ppi*(cur_thickness-1)/72/mag;
X		else
X		    end_x -= 0.5*ppi*(cur_thickness-1)/72/mag;
X		}
X	    }
X	else if (end_x == first_start_x && end_y == first_start_y) {
X	    if (start_x == end_x && first_start_y == first_end_y) {
X		if (end_y > start_y)
X		    end_y += 0.5*ppi*(cur_thickness-1)/72/mag;
X		else
X		    end_y -= 0.5*ppi*(cur_thickness-1)/72/mag;
X		}
X	    else if (start_y == end_y && first_start_x == first_end_x) {
X		if (end_x > start_x)
X		    end_x += 0.5*ppi*(cur_thickness-1)/72/mag;
X		else
X		    end_x -= 0.5*ppi*(cur_thickness-1)/72/mag;
X		}
X	    }
X
X	fprintf(tfp, "\\putrule from %6.3f %6.3f to %6.3f %6.3f\n",
X		(start_x/ppi)*CONVUNIT, (convy(start_y/ppi))*CONVUNIT, (end_x/ppi)*CONVUNIT, (convy(end_y/ppi))*CONVUNIT);
X	}
X    else {
X	fprintf(tfp, "\\plot %6.3f %6.3f %6.3f %6.3f /\n",
X		(start_x/ppi)*CONVUNIT, (convy(start_y/ppi))*CONVUNIT, (end_x/ppi)*CONVUNIT, (convy(end_y/ppi))*CONVUNIT);
X	}
X}
X
X
Xvoid genpictex_spline(s)
XF_spline	*s;
X{
X	set_linewidth(s->thickness);
X	set_style(s->style, s->style_val);
X	set_color(s->color);
X
X	if (int_spline(s))
X	    genpictex_itp_spline(s);
X	else
X	    genpictex_ctl_spline(s);
X
X	if (s->area_fill && (int)s->area_fill != DEFAULT)
X		fprintf(stderr, "Spline area fill not implemented\n");
X	reset_color(s->color);
X}
X
X#define MAXBLACKDIAM 15 /* pt */
X
Xvoid genpictex_ellipse(e)
XF_ellipse	*e;
X{
X	fprintf(tfp, "%%\n%% Fig ELLIPSE\n%%\n");
X
X	set_linewidth(e->thickness);
X	set_style(e->style, e->style_val);
X	set_color(e->color);
X
X	if ((e->area_fill == BLACK_FILL) && (e->radiuses.x == e->radiuses.y)) {
X		if (mag*e->radiuses.x > 0.5*ppi/72*MAXBLACKDIAM)
X			fprintf(stderr, "Too big black filled circle substituted by a diameter of %dpt\n", MAXBLACKDIAM);
X 		fprintf(tfp, "\\put{\\makebox(0,0)[l]{\\circle*{%6.3f}}} at %6.3f %6.3f\n",
X		    (2*e->radiuses.x/ppi)*CONVUNIT,
X		    ((e->center.x)/ppi)*CONVUNIT, (convy(e->center.y/ppi))*CONVUNIT);
X
X	    }
X	else {
X
X		fprintf(tfp, "\\ellipticalarc axes ratio %6.3f:%-6.3f 360 degrees \n",
X		    (e->radiuses.x/ppi)*CONVUNIT, (e->radiuses.y/ppi)*CONVUNIT);
X		fprintf(tfp, "\tfrom %6.3f %6.3f center at %6.3f %6.3f\n",
X		    ((e->center.x+e->radiuses.x)/ppi)*CONVUNIT, (convy(e->center.y/ppi))*CONVUNIT,
X		    (e->center.x/ppi)*CONVUNIT, (convy(e->center.y/ppi))*CONVUNIT);
X		if (e->area_fill && (int)e->area_fill != DEFAULT)
X			fprintf(stderr, "Ellipse area fill not implemented\n");
X		}
X	reset_color(e->color);
X	}
X
X#define			HT_OFFSET	(0.2 / 72.0)
X
Xvoid genpictex_text(t)
XF_text	*t;
X{
X	double	x, y;
X	char *tpos;
X	unsigned char *cp;
X
X        fprintf(tfp, "%%\n%% Fig TEXT object\n%%\n");
X
X	x = t->base_x/ppi;
X	y = convy(t->base_y/ppi);
X
X	switch (t->type) {
X
X	    case T_LEFT_JUSTIFIED:
X	    case DEFAULT:
X	    	tpos = "[lB]";
X		break;
X
X	    case T_CENTER_JUSTIFIED:
X	    	tpos = "[B]";
X		break;
X
X	    case T_RIGHT_JUSTIFIED:
X	    	tpos = "[rB]";
X		break;
X
X	    default:
X		fprintf(stderr, "Text incorrectly positioned\n");
X		return;
X	    }
X
X	unpsfont(t);
X        { int texsize;
X          double baselineskip;
X
X	  texsize = TEXFONTMAG(t);
X	  baselineskip = (texsize * 1.2);
X
X 	  fprintf(tfp, "\\put{\\SetFigFont{%d}{%.1f}{%s}",
X		texsize, baselineskip, TEXFONT(t->font));
X	}
X
X#ifdef DVIPS
X	if(t->angle && t->type == T_LEFT_JUSTIFIED)
X	  fprintf(tfp, "\\special{ps:gsave currentpoint currentpoint translate\n-%.1f rotate neg exch neg exch translate}", t->angle*180/M_PI);
X#endif
X
X	set_color(t->color);
X
X	if (!special_text(t))
X
X		/* this loop escapes characters "$&%#_{}" */
X		/* and deleted characters "~^\" */
X		for(cp = (unsigned char*)t->cstring; *cp; cp++) {
X	      	    if (strchr("$&%#_{}", *cp)) (void)fputc('\\', tfp);
X	      	    if (strchr("~^\\", *cp))
X			fprintf(stderr,
X				"Bad character in text object '%c'\n" ,*cp);
X		    else
X			(void)fputc(*cp, tfp);
X	      	}
X	else 
X		for(cp = (unsigned char*)t->cstring; *cp; cp++) {
X		    if (*cp >= 0xa0)
X		         fprintf(tfp, "%s", ISOtoTeX[(int)*cp-0xa0]);
X		else
X		    fputc(*cp, tfp);
X		}
X
X	reset_color(t->color);
X
X#ifdef DVIPS
X	if(t->angle)
X	{
X	  if (t->type == T_LEFT_JUSTIFIED)
X	       fprintf(tfp, "\\special{ps:currentpoint grestore moveto}");
X	  else
X	     fprintf(stderr, "Rotated Text only for left justified text\n");
X	}
X#endif
X 	fprintf(tfp, "} %s at %6.3f %6.3f\n",
X	    tpos, (x)*CONVUNIT, (y)*CONVUNIT);
X	}
X
Xvoid genpictex_arc(a)
XF_arc	*a;
X{
X	double		x, y;
X	double		cx, cy, sx, sy, ex, ey;
X	double		dx1, dy1, dx2, dy2, r1, r2, th1, th2, theta;
X
X        fprintf(tfp, "%%\n%% Fig CIRCULAR ARC object\n%%\n");
X
X	set_linewidth(a->thickness);
X	set_style(a->style, a->style_val);
X	set_color(a->color);
X
X	cx = a->center.x/ppi; cy = convy(a->center.y/ppi);
X	sx = a->point[0].x/ppi; sy = convy(a->point[0].y/ppi);
X	ex = a->point[2].x/ppi; ey = convy(a->point[2].y/ppi);
X
X	if (a->for_arrow) {
X	    arc_tangent(cx, cy, ex, ey, a->direction, &x, &y);
X	    draw_arrow_head(x, y, ex, ey,
X			a->for_arrow->ht/ppi, a->for_arrow->wid/ppi);
X	    }
X	if (a->back_arrow) {
X	    arc_tangent(cx, cy, sx, sy, !a->direction, &x, &y);
X	    draw_arrow_head(x, y, sx, sy,
X			a->back_arrow->ht/ppi, a->back_arrow->wid/ppi);
X	    }
X
X	dx1 = sx - cx;
X	dy1 = sy - cy;
X	dx2 = ex - cx;
X	dy2 = ey - cy;
X	    
X	rtop(dx1, dy1, &r1, &th1);
X	rtop(dx2, dy2, &r2, &th2);
X	theta = th2 - th1;
X	if (theta > 0) theta -= 2*M_PI;
X
X/*	set_linewidth(a->thickness); */
X
X	if (a->direction)
X		fprintf(tfp, "\\circulararc %6.3f degrees from %6.3f %6.3f center at %6.3f %6.3f\n",
X			360+(180/M_PI * theta), (sx)*CONVUNIT, (sy)*CONVUNIT, (cx)*CONVUNIT, (cy)*CONVUNIT);
X	else
X		fprintf(tfp, "\\circulararc %6.3f degrees from %6.3f %6.3f center at %6.3f %6.3f\n",
X			-180/M_PI * theta, (ex)*CONVUNIT, (ey)*CONVUNIT, (cx)*CONVUNIT, (cy)*CONVUNIT);
X
X	if (a->area_fill && (int)a->area_fill != DEFAULT)
X		fprintf(stderr, "Arc area fill not implemented\n");
X	reset_color(a->color);
X	}
X
X
X
X/*
X * rtop - rectangular to polar conversion
X */
Xstatic rtop(x, y, r, th)
Xdouble x, y, *r, *th;
X{
X	*r = sqrt(x*x+y*y);
X	*th = acos(x/(*r));
X
X	if (y < 0) *th = 2*M_PI - *th;
X}
X
Xstatic arc_tangent(x1, y1, x2, y2, direction, x, y)
Xdouble	x1, y1, x2, y2, *x, *y;
Xint	direction;
X{
X	if (direction) { /* counter clockwise  */
X	    *x = x2 + (y2 - y1);
X	    *y = y2 - (x2 - x1);
X	    }
X	else {
X	    *x = x2 - (y2 - y1);
X	    *y = y2 + (x2 - x1);
X	    }
X	}
X
X/*	draw arrow heading from (x1, y1) to (x2, y2)	*/
X
Xstatic draw_arrow_head(x1, y1, x2, y2, arrowht, arrowwid)
Xdouble	x1, y1, x2, y2, arrowht, arrowwid;
X{
X	double	x, y, xb, yb, dx, dy, l, sina, cosa;
X	double	xc, yc, xd, yd;
X	int style;
X	double dash;
X
X	dx = x2 - x1;  dy = y1 - y2;
X
X	if (!dx && !dy)
X	    return ;
X
X	l = sqrt(dx*dx+dy*dy);
X	if (l == 0) {
X	     return;
X	}
X	else {
X	     sina = dy / l;  cosa = dx / l;
X	}
X	xb = x2*cosa - y2*sina;
X	yb = x2*sina + y2*cosa;
X	x = xb - arrowht;
X	y = yb - arrowwid / 2;
X	xc = x*cosa + y*sina;
X	yc = -x*sina + y*cosa;
X	y = yb + arrowwid / 2;
X	xd = x*cosa + y*sina;
X	yd = -x*sina + y*cosa;
X
X	/* save line style and set to solid */
X	style = line_style;
X	dash = dash_length;
X	set_style(SOLID_LINE, 0.0);
X
X        fprintf(tfp, "%%\n%% arrow head\n%%\n");
X
X	fprintf(tfp, "\\plot %6.3f %6.3f %6.3f %6.3f %6.3f %6.3f /\n%%\n",
X		(xc)*CONVUNIT, (yc)*CONVUNIT, (x2)*CONVUNIT, (y2)*CONVUNIT, (xd)*CONVUNIT, (yd)*CONVUNIT);
X
X	/* restore line style */
X	set_style(style, dash);
X	}
X
X#define		THRESHOLD	.05	/* inch */
X
Xstatic quadratic_spline(a1, b1, a2, b2, a3, b3, a4, b4)
Xdouble	a1, b1, a2, b2, a3, b3, a4, b4;
X{
X	double	x1, y1, x4, y4;
X	double	xmid, ymid;
X
X	x1 = a1; y1 = b1;
X	x4 = a4; y4 = b4;
X	xmid = (a2 + a3) / 2;
X	ymid = (b2 + b3) / 2;
X	if (fabs(x1 - xmid) < THRESHOLD && fabs(y1 - ymid) < THRESHOLD)
X	    fprintf(tfp, "\t%6.3f %6.3f\n", (xmid)*CONVUNIT, (ymid)*CONVUNIT);
X
X	else {
X	    quadratic_spline(x1, y1, ((x1+a2)/2), ((y1+b2)/2),
X			((3*a2+a3)/4), ((3*b2+b3)/4), xmid, ymid);
X	    }
X
X	if (fabs(xmid - x4) < THRESHOLD && fabs(ymid - y4) < THRESHOLD)
X	    fprintf(tfp, "\t%6.3f %6.3f\n", (x4)*CONVUNIT, (y4)*CONVUNIT);
X
X	else {
X	    quadratic_spline(xmid, ymid, ((a2+3*a3)/4), ((b2+3*b3)/4),
X			((a3+x4)/2), ((b3+y4)/2), x4, y4);
X	    }
X	}
X
Xstatic void genpictex_ctl_spline(s)
XF_spline	*s;
X{
X	F_point	*p;
X	double	cx1, cy1, cx2, cy2, cx3, cy3, cx4, cy4;
X	double	x1, y1, x2, y2;
X
X    	fprintf(tfp, "%%\n%% Fig CONTROL PT SPLINE\n%%\n");
X
X	p = s->points;
X	x1 = p->x/ppi;  y1 = convy(p->y/ppi);
X	p = p->next;
X	x2 = p->x/ppi;  y2 = convy(p->y/ppi);
X	cx1 = (x1 + x2) / 2;      cy1 = (y1 + y2) / 2;
X	cx2 = (x1 + 3 * x2) / 4;  cy2 = (y1 + 3 * y2) / 4;
X
X	if (closed_spline(s)) {
X	    fprintf(tfp, "%% closed spline\n%%\n");
X	    fprintf(tfp, "\\plot\t%6.3f %6.3f \n ", (cx1)*CONVUNIT, (cy1)*CONVUNIT);
X	    }
X	else {
X	    fprintf(tfp, "%% open spline\n%%\n");
X	    if (s->back_arrow)
X	        draw_arrow_head(cx1, cy1, x1, y1,
X			s->back_arrow->ht/ppi, s->back_arrow->wid/ppi);
X	    fprintf(tfp, "\\plot\t%6.3f %6.3f %6.3f %6.3f\n ",
X		(x1)*CONVUNIT, (y1)*CONVUNIT, (cx1)*CONVUNIT, (cy1)*CONVUNIT);
X	    }
X
X	for (p = p->next; p != NULL; p = p->next) {
X	    x1 = x2;  y1 = y2;
X	    x2 = p->x/ppi;  y2 = convy(p->y/ppi);
X	    cx3 = (3 * x1 + x2) / 4;  cy3 = (3 * y1 + y2) / 4;
X	    cx4 = (x1 + x2) / 2;      cy4 = (y1 + y2) / 2;
X	    quadratic_spline(cx1, cy1, cx2, cy2, cx3, cy3, cx4, cy4);
X	    cx1 = cx4;  cy1 = cy4;
X	    cx2 = (x1 + 3 * x2) / 4;  cy2 = (y1 + 3 * y2) / 4;
X	    }
X	x1 = x2;  y1 = y2;
X	p = s->points->next;
X	x2 = p->x/ppi;  y2 = convy(p->y/ppi);
X	cx3 = (3 * x1 + x2) / 4;  cy3 = (3 * y1 + y2) / 4;
X	cx4 = (x1 + x2) / 2;      cy4 = (y1 + y2) / 2;
X	if (closed_spline(s)) {
X	    quadratic_spline(cx1, cy1, cx2, cy2, cx3, cy3, cx4, cy4);
X	    fprintf(tfp, "\t/\n");
X	    }
X	else {
X	    fprintf(tfp, "\t /\n\\plot %6.3f %6.3f %6.3f %6.3f /\n",
X		(cx1)*CONVUNIT, (cy1)*CONVUNIT, (x1)*CONVUNIT, (y1)*CONVUNIT);
X	    if (s->for_arrow)
X	    	draw_arrow_head(cx1, cy1, x1, y1,
X			s->for_arrow->ht/ppi, s->for_arrow->wid/ppi);
X	    }
X
X	}
X
Xstatic void genpictex_itp_spline(s)
XF_spline	*s;
X{
X	F_point		*p1, *p2;
X	F_control	*cp1, *cp2;
X	double		x1, x2, y1, y2;
X
X    	fprintf(tfp, "%%\n%% Fig INTERPOLATED PT SPLINE\n%%\n");
X
X	p1 = s->points;
X	cp1 = s->controls;
X	x2 = p1->x/ppi; y2 = convy(p1->y/ppi);
X
X	if (s->back_arrow)
X	    draw_arrow_head(cp1->rx/ppi, convy(cp1->ry/ppi), x2, y2,
X		s->back_arrow->ht/ppi, s->back_arrow->wid/ppi);
X
X	fprintf(tfp, "\\plot %6.3f %6.3f ", (x2)*CONVUNIT, (y2)*CONVUNIT);
X	for (p2 = p1->next, cp2 = cp1->next; p2 != NULL;
X		p1 = p2, cp1 = cp2, p2 = p2->next, cp2 = cp2->next) {
X	    x1 = x2; y1 = y2;
X	    x2 = p2->x/ppi; y2 = convy(p2->y/ppi);
X	    bezier_spline(x1, y1, (double)cp1->rx/ppi, convy(cp1->ry/ppi),
X		(double)cp2->lx/ppi, convy(cp2->ly/ppi), x2, y2);
X	    }
X	fprintf(tfp, "\t/\n");
X
X	if (s->for_arrow)
X	    draw_arrow_head(cp1->lx/ppi, convy(cp1->ly/ppi), x2, y2,
X		s->for_arrow->ht/ppi, s->for_arrow->wid/ppi);
X	}
X
Xstatic bezier_spline(a0, b0, a1, b1, a2, b2, a3, b3)
Xdouble	a0, b0, a1, b1, a2, b2, a3, b3;
X{
X	double	x0, y0, x3, y3;
X	double	sx1, sy1, sx2, sy2, tx, ty, tx1, ty1, tx2, ty2, xmid, ymid;
X
X	x0 = a0; y0 = b0;
X	x3 = a3; y3 = b3;
X	if (fabs(x0 - x3) < THRESHOLD && fabs(y0 - y3) < THRESHOLD)
X	    fprintf(tfp, "\t%6.3f %6.3f\n", (x3)*CONVUNIT, (y3)*CONVUNIT);
X
X	else {
X	    tx = (a1 + a2) / 2;		ty = (b1 + b2) / 2;
X	    sx1 = (x0 + a1) / 2;	sy1 = (y0 + b1) / 2;
X	    sx2 = (sx1 + tx) / 2;	sy2 = (sy1 + ty) / 2;
X	    tx2 = (a2 + x3) / 2;	ty2 = (b2 + y3) / 2;
X	    tx1 = (tx2 + tx) / 2;	ty1 = (ty2 + ty) / 2;
X	    xmid = (sx2 + tx1) / 2;	ymid = (sy2 + ty1) / 2;
X
X	    bezier_spline(x0, y0, sx1, sy1, sx2, sy2, xmid, ymid);
X	    bezier_spline(xmid, ymid, tx1, ty1, tx2, ty2, x3, y3);
X	    }
X	}
X
Xstruct driver dev_pictex = {
X     	genpictex_option,
X	genpictex_start,
X	genpictex_arc,
X	genpictex_ellipse,
X	genpictex_line,
X	genpictex_spline,
X	genpictex_text,
X	genpictex_end,
X	EXCLUDE_TEXT
X};
X
END_OF_FILE
if test 25452 -ne `wc -c <'fig2dev/dev/genpictex.c'`; then
    echo shar: \"'fig2dev/dev/genpictex.c'\" unpacked with wrong size!
fi
# end of 'fig2dev/dev/genpictex.c'
fi
echo shar: End of archive 6 \(of 7\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
