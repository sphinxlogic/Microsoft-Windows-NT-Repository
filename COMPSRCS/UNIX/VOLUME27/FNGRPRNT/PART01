Newsgroups: comp.sources.unix
From: djb@silverton.berkeley.edu (D. J. Bernstein)
Subject: v27i079: fingerprint-0.60 - a universal hash/checksum package, Part01/02
Message-id: <1.752229646.7906@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: djb@silverton.berkeley.edu (D. J. Bernstein)
Posting-Number: Volume 27, Issue 79
Archive-Name: fingerprint/part01

	fingerprint 0.60: the universal hash/checksum package
	931101
	Daniel J. Bernstein, djb@silverton.berkeley.edu

	Do you want a powerful, uniform interface to MD5, a standard CRC-32,
	Snefru-8, and a combined universal fingerprint, in highly efficient
	library form or as easy-to-use programs? That's what this package
	provides. The code is freely reusable so you can distribute it along
	with your own applications. Have fun.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 2)."
# Contents:  BINARIES BLURB FILES FORMLETTER MANIFEST Makefile OBJECTS
#   README TIMINGS cksum.1 cksum.c cksum.tests crc32file.3 crc32file.c
#   crc32file.h fingerprint.1 fingerprint.c fingerprint.tests
#   fprintfile.3 fprintfile.c fprintfile.h fprintfmt.c fptocksum.c
#   fptomd5.c fptosnefru.c getopt.c getopt.h md5.1 md5.c md5.tests
#   md5file.3 md5file.c md5file.h snefru.1 snefru.c snefru.tests
#   snefru512.3 snefru512.h snefrufile.3 snefrufile.c snefrufile.h
#   summain.1 summain.c
# Wrapped by vixie@gw.home.vix.com on Tue Nov  2 00:39:49 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'BINARIES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'BINARIES'\"
else
echo shar: Extracting \"'BINARIES'\" \(58 characters\)
sed "s/^X//" >'BINARIES' <<'END_OF_FILE'
Xcksum
Xfingerprint
Xfptocksum
Xfptomd5
Xfptosnefru
Xmd5
Xsnefru
END_OF_FILE
if test 58 -ne `wc -c <'BINARIES'`; then
    echo shar: \"'BINARIES'\" unpacked with wrong size!
fi
# end of 'BINARIES'
fi
if test -f 'BLURB' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'BLURB'\"
else
echo shar: Extracting \"'BLURB'\" \(420 characters\)
sed "s/^X//" >'BLURB' <<'END_OF_FILE'
Xfingerprint 0.60: the universal hash/checksum package
X931101
XDaniel J. Bernstein, djb@silverton.berkeley.edu
X
XDo you want a powerful, uniform interface to MD5, a standard CRC-32,
XSnefru-8, and a combined universal fingerprint, in highly efficient
Xlibrary form or as easy-to-use programs? That's what this package
Xprovides. The code is freely reusable so you can distribute it along
Xwith your own applications. Have fun.
END_OF_FILE
if test 420 -ne `wc -c <'BLURB'`; then
    echo shar: \"'BLURB'\" unpacked with wrong size!
fi
# end of 'BLURB'
fi
if test -f 'FILES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'FILES'\"
else
echo shar: Extracting \"'FILES'\" \(456 characters\)
sed "s/^X//" >'FILES' <<'END_OF_FILE'
XBLURB
XREADME
XFORMLETTER
XFILES
XOBJECTS
XBINARIES
XMakefile
Xfprintfile.3
Xfprintfile.h
Xfprintfile.c
Xfprintfmt.c
Xcrc32file.3
Xcrc32file.h
Xcrc32file.c
Xmd5file.3
Xmd5file.h
Xmd5file.c
Xsnefrufile.3
Xsnefrufile.h
Xsnefrufile.c
Xsnefru512.3
Xsnefru512.h
Xsnefru512.c
Xsnefru.1
Xsnefru.c
Xmd5.1
Xmd5.c
Xcksum.1
Xcksum.c
Xfptocksum.c
Xfptomd5.c
Xfptosnefru.c
Xfingerprint.1
Xfingerprint.c
Xsummain.1
Xsummain.c
Xgetopt.h
Xgetopt.c
XTIMINGS
Xfingerprint.tests
Xmd5.tests
Xsnefru.tests
Xcksum.tests
END_OF_FILE
if test 456 -ne `wc -c <'FILES'`; then
    echo shar: \"'FILES'\" unpacked with wrong size!
fi
# end of 'FILES'
fi
if test -f 'FORMLETTER' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'FORMLETTER'\"
else
echo shar: Extracting \"'FORMLETTER'\" \(817 characters\)
sed "s/^X//" >'FORMLETTER' <<'END_OF_FILE'
XTo: djb@silverton.berkeley.edu (Dan Bernstein)
XFrom: 
XDate: 
XSubject: fingerprint 0.60 FORMLETTER
X
XPackage: fingerprint 0.60, gamma, 931101 release
XObtained from (e.g., uunet.uu.net): 
XObtained by (e.g., ftp): 
X
X1. Machine architecture (e.g., Sun 4/280): 
X2. Operating system (e.g., SunOS 4.1): 
X3. OS vendor (e.g., Sun): 
X4. Does fingerprint work on your machine so far (yes/no)?
X5. What's CC in your Makefile?
X   CC=
X
X6. Describe any problems you've had with fingerprint.
X
X
X
X7. If you've timed the programs (make speedtest), how fast were they?
X
X
X
X8. Do you have any suggestions for a standard fingerprint library
X   organization? Should all the library routines be in -lfprint?
X   Or should they be split among -lfprint, -lmd5, -lsnefru, -lcrc?
X
X
X
X9. Any further questions, comments, or suggestions?
X
X
X
XYour name:
END_OF_FILE
if test 817 -ne `wc -c <'FORMLETTER'`; then
    echo shar: \"'FORMLETTER'\" unpacked with wrong size!
fi
# end of 'FORMLETTER'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1478 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X BINARIES                   1	
X BLURB                      1	
X FILES                      1	
X FORMLETTER                 1	
X MANIFEST                   1	This shipping list
X Makefile                   1	
X OBJECTS                    1	
X README                     1	
X TIMINGS                    1	
X cksum.1                    1	
X cksum.c                    1	
X cksum.tests                1	
X crc32file.3                1	
X crc32file.c                1	
X crc32file.h                1	
X fingerprint.1              1	
X fingerprint.c              1	
X fingerprint.tests          1	
X fprintfile.3               1	
X fprintfile.c               1	
X fprintfile.h               1	
X fprintfmt.c                1	
X fptocksum.c                1	
X fptomd5.c                  1	
X fptosnefru.c               1	
X getopt.c                   1	
X getopt.h                   1	
X md5.1                      1	
X md5.c                      1	
X md5.tests                  1	
X md5file.3                  1	
X md5file.c                  1	
X md5file.h                  1	
X snefru.1                   1	
X snefru.c                   1	
X snefru.tests               1	
X snefru512.3                1	
X snefru512.c                2	
X snefru512.h                1	
X snefrufile.3               1	
X snefrufile.c               1	
X snefrufile.h               1	
X summain.1                  1	
X summain.c                  1	
END_OF_FILE
if test 1478 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(3064 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
XCC=cc -O
XTIME=time
XCOMPRESS=compress
X
Xall: fingerprint fptocksum fptosnefru fptomd5 snefru md5 cksum
X
Xsnefru: snefru.o snefrufile.o snefru512.o summain.o getopt.o
X	$(CC) -o snefru snefru.o snefrufile.o snefru512.o summain.o getopt.o
X
Xcksum: cksum.o crc32file.o summain.o getopt.o
X	$(CC) -o cksum cksum.o crc32file.o summain.o getopt.o
X
Xmd5: md5.o md5file.o summain.o getopt.o
X	$(CC) -o md5 md5.o md5file.o summain.o getopt.o
X
Xfptosnefru: fptosnefru.o fprintfmt.o
X	$(CC) -o fptosnefru fptosnefru.o fprintfmt.o
X
Xfptomd5: fptomd5.o fprintfmt.o
X	$(CC) -o fptomd5 fptomd5.o fprintfmt.o
X
Xfptocksum: fptocksum.o fprintfmt.o
X	$(CC) -o fptocksum fptocksum.o fprintfmt.o
X
Xfingerprint: fingerprint.o crc32file.o md5file.o snefrufile.o \
Xsnefru512.o fprintfile.o fprintfmt.o getopt.o summain.o
X	$(CC) -o fingerprint fingerprint.o crc32file.o md5file.o \
X	snefrufile.o snefru512.o fprintfile.o fprintfmt.o getopt.o summain.o
X
Xfptosnefru.o: fptosnefru.c
X	$(CC) -c fptosnefru.c
X
Xfptomd5.o: fptomd5.c
X	$(CC) -c fptomd5.c
X
Xfptocksum.o: fptocksum.c
X	$(CC) -c fptocksum.c
X
Xcksum.o: cksum.c crc32file.h
X	$(CC) -c cksum.c
X
Xmd5.o: md5.c md5file.h
X	$(CC) -c md5.c
X
Xsnefru.o: snefru.c snefrufile.h
X	$(CC) -c snefru.c
X
Xfprintfmt.o: fprintfmt.c fprintfile.h
X	$(CC) -c fprintfmt.c
X
Xfprintfile.o: fprintfile.c fprintfile.h
X	$(CC) -c fprintfile.c
X
Xcrc32file.o: crc32file.c crc32file.h
X	$(CC) -c crc32file.c
X
Xmd5file.o: md5file.c md5file.h
X	$(CC) -c md5file.c
X
Xsnefrufile.o: snefrufile.c snefrufile.h snefru512.h
X	@echo You should get three warnings for snefrufile.c.
X	@echo This is my reminder that the code there is not portable.
X	$(CC) -c snefrufile.c
X
Xsnefru512.o: snefru512.c snefru512.h
X	$(CC) -c snefru512.c
X
Xfingerprint.o: fingerprint.c crc32file.h md5file.h snefrufile.h \
Xfprintfile.h getopt.h
X	$(CC) -c fingerprint.c
X
Xsummain.o: summain.c getopt.h
X	$(CC) -c summain.c
X
Xgetopt.o: getopt.c getopt.h
X	$(CC) -c getopt.c
X
Xtest:
X	@echo 'Trying canned tests... No output (other than seven ./commands) if successful.'
X	./fingerprint -c < fingerprint.tests
X	./snefru -c < snefru.tests
X	./md5 -c < md5.tests
X	./cksum -c < cksum.tests
X	./fptosnefru < fingerprint.tests | cmp - snefru.tests
X	./fptomd5 < fingerprint.tests | cmp - md5.tests
X	./fptocksum < fingerprint.tests | cmp - cksum.tests
X
Xshar:
X	shar `cat FILES` > fingerprint.shar
X	chmod 400 fingerprint.shar
X
Xclean: OBJECTS BINARIES
X	rm -f `cat OBJECTS BINARIES`
X
Xspeedtest.1M:
X	@echo 'Making a one-megabyte file for speed tests...'
X	cat `cat FILES` > speedtest.tmp
X	dd bs=8k count=8 < speedtest.tmp > speedtest.64k
X	cat speedtest.64k speedtest.64k speedtest.64k speedtest.64k > speedtest.256k
X	cat speedtest.256k speedtest.256k speedtest.256k speedtest.256k > speedtest.1M
X	rm -f speedtest.tmp speedtest.64k speedtest.256k
X
Xspeedtest: speedtest.1M fingerprint snefru md5 cksum
X	@echo 'Trying speed tests...'
X	$(TIME) ./fingerprint < speedtest.1M > /dev/null
X	$(TIME) ./snefru < speedtest.1M > /dev/null
X	$(TIME) ./md5 < speedtest.1M > /dev/null
X	$(TIME) ./cksum < speedtest.1M > /dev/null
X	$(TIME) $(COMPRESS) < speedtest.1M > /dev/null
END_OF_FILE
if test 3064 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'OBJECTS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'OBJECTS'\"
else
echo shar: Extracting \"'OBJECTS'\" \(176 characters\)
sed "s/^X//" >'OBJECTS' <<'END_OF_FILE'
Xcksum.o
Xcrc32file.o
Xfingerprint.o
Xfprintfile.o
Xfprintfmt.o
Xfptocksum.o
Xfptomd5.o
Xfptosnefru.o
Xgetopt.o
Xmd5.o
Xmd5file.o
Xsnefru.o
Xsnefru512.o
Xsnefrufile.o
Xsummain.o
Xspeedtest.1M
END_OF_FILE
if test 176 -ne `wc -c <'OBJECTS'`; then
    echo shar: \"'OBJECTS'\" unpacked with wrong size!
fi
# end of 'OBJECTS'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(2629 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XThis is the fingerprint 0.60 package, gamma.
X931101
XDaniel J. Bernstein, djb@silverton.berkeley.edu.
X
XThe fingerprint program produces a base-64-sanely-encoded fingerprint of
Xits input. I imagine this fingerprint as something universal and
Xpermanent, which people will use forever. If the fingerprint is ever
Xbroken, I'd rather make an entirely new version than try to extend this
Xone.
X
XA fingerprint is 76 characters long. What does it contain? Here's a list:
X
X1. A Snefru-8 (version 2.5, 8 passes, 512->256) hash.
X   (Code derived from the Xerox Secure Hash Function.)
X2. An MD5 hash, as per RFC 1321.
X   (Code derived from the RSADSI MD5 Message-Digest Algorithm.)
X3. A CRC checksum, as in the new cksum utility.
X4. Length modulo 2^40.
X
XThe output format is not expected to be compatible with anything.
XHowever, I have helper utilities which take a fingerprint and produce 
Xthe purported output of Merkle's snefru program (fptosnefru), the 
Xpurported output of RSADSI's mddriver -x (fptomd5), or the purported 
Xoutput of the POSIX cksum program (fptocksum).
X
XAlso included: (1) a clone of the snefru program, with some extra 
Xfeatures; (2) a cksum implementation; (3) an md5 driver; (4) libraries
Xwith a uniform interface for calculating these hashes; (5) some 
Xdocumentation.
X
XTo compile, just make. To try a few simple tests, make test. To see how
Xfast the various hash functions can handle a megabyte of data on your
Xmachine, make speedtest.
X
XI've written this because I want to set up a global database which maps
Xfingerprints to network locations. Thanks to the tripwire authors for
Xunknowingly giving this project a push, and thanks of course to the
Xhash function designers and implementors.
X
XThanks to the alpha testers for their comments and criticism:
X
X  Eric Backus <ericb@lsid.hp.com>
X  Alan Barrett <barrett@daisy.ee.und.ac.za>
X  Paul Haahr <haahr@mv.us.adobe.com>
X  Mark C. Henderson <mch@wimsey.bc.ca>
X  Stephan Neuhaus <neuhaus@informatik.uni-kl.de>
X  Danny Padwa <padwad@gs.com>
X  Eric Rescorla <ekr@eitech.com>
X  Icarus Sparry <I.Sparry@ss1.bath.ac.uk>
X
XNo thanks to the beta testers---there weren't any, as far as I can tell.
XThis package is essentially unchanged since beta version 0.50, which I
Xposted to alt.sources in early August 1993.
X
XContinuing worries: I still have to make sure I'm giving all appropriate
Xcredit here. Also, I haven't tested *_addn properly. I'm not too happy
Xwith the man pages, which were to a large extent mechanically produced;
XI'd appreciate any suggestions for improvement.
X
Xecho hi | fingerprint:
XJoXEhdflGxZdS89tDd5zpFx0JRJyX0k67EH0Jod7aet4hIjB.hGhon0veN0BZRfi058HZQ06U0JD	
END_OF_FILE
if test 2629 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'TIMINGS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'TIMINGS'\"
else
echo shar: Extracting \"'TIMINGS'\" \(1319 characters\)
sed "s/^X//" >'TIMINGS' <<'END_OF_FILE'
XTimings are based on a few trials. More accurate timings would be nice.
X
X386/40, BSDI 1.0, cc -O, 64k (?) cache
Xfingerprint: 38.9K/sec
Xsnefru: 51.6K/sec
Xmd5: 323.7K/sec
Xcksum: 589.7K/sec
X/usr/ucb/compress: 104.5K/sec
X
XSPARC, Sun 4, SunOS 4.1.3, cc -O4, ? cache
Xfingerprint: 127K/sec
Xsnefru: 139K/sec
Xmd5: 2304K/sec
Xcksum: 3585K/sec
X/usr/ucb/compress: 190K/sec
X
XSPARC, Sun 4, SunOS 4.1.3, gcc -O, ? cache
Xfingerprint: 138K/sec
Xsnefru: 150K/sec
Xmd5: 2300K/sec
Xcksum: 4600K/sec
X/usr/ucb/compress: 190K/sec
X
XSPARC, Sun 4, SunOS 4.1.1, cc -O4, ? cache
Xfingerprint: 95K/sec
Xsnefru: 115K/sec
Xmd5: 913K/sec
Xcksum: 1644K/sec
X/usr/ucb/compress: 153K/sec
X
Xvangogh (HP?), cc -O
Xfingerprint: 61.6K/sec
Xsnefru: 72.5K/sec
Xmd5: 580K/sec
Xcksum: 1200K/sec
X/usr/bin/compress: 99.5K/sec
X
XSGI, ?, cc -O2 -cckr
Xfingerprint: 157K/sec
Xsnefru: 188K/sec
Xmd5: 1309K/sec
Xcksum: 2216K/sec
X/usr/bsd/compress: 139.4K/sec
X
XNeXT, ?, cc -O
Xfingerprint: 60.5K/sec
Xsnefru: 72.3K/sec
Xmd5: 528K/sec
Xcksum: 1300K/sec
X/usr/ucb/compress: 130K/sec
X
XMIPS, DECstation 5000, Ultrix 4.2A (47), cc -O2, ? cache
Xfingerprint: 121K/sec
Xsnefru: 148K/sec
Xmd5: 1128K/sec
Xcksum: 1812K/sec
X/usr/ucb/compress: 157K/sec
X
XMIPS, DECstation 5000, Ultrix 4.2A (47), gcc -O, ? cache
Xfingerprint: 110K/sec
Xsnefru: 144K/sec
Xmd5: 927K/sec
Xcksum: 2098K/sec
X/usr/ucb/compress: 157K/sec
END_OF_FILE
if test 1319 -ne `wc -c <'TIMINGS'`; then
    echo shar: \"'TIMINGS'\" unpacked with wrong size!
fi
# end of 'TIMINGS'
fi
if test -f 'cksum.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cksum.1'\"
else
echo shar: Extracting \"'cksum.1'\" \(622 characters\)
sed "s/^X//" >'cksum.1' <<'END_OF_FILE'
X.TH cksum 1
X.SH NAME
Xcksum \- calculate a CRC-32 of the input
X.SH SYNTAX
X.B cksum
X.SH DESCRIPTION
X.B cksum
Xcalculates a CRC-32 checksum of its input.
X
X.B cksum
Xconforms to the
X.I summain
Xinterface.
XSee
X.B summain(1)
Xfor a description of
X.B cksum\fP's
Xoptions.
X.SH COMPATIBILITY
XThis program is intended to
Xbe backwards compatible with
Xthe POSIX
X.B cksum
Xprogram.
X.SH VERSION
Xcksum 1.0, 13 July 1993.
X.SH AUTHOR
XMost of the work is done in
Xthe
X.B crc32file
Xlibrary,
Xwhich is
Xprimarily code written by
XGary S. Brown.
XWrapper code
Xplaced into the public domain by Daniel J. Bernstein.
X.SH "SEE ALSO"
Xsummain(1),
Xcrc32file(3)
END_OF_FILE
if test 622 -ne `wc -c <'cksum.1'`; then
    echo shar: \"'cksum.1'\" unpacked with wrong size!
fi
# end of 'cksum.1'
fi
if test -f 'cksum.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cksum.c'\"
else
echo shar: Extracting \"'cksum.c'\" \(457 characters\)
sed "s/^X//" >'cksum.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "crc32file.h"
X
Xstatic unsigned char h[CRC32FILE_HASHLEN];
Xstatic unsigned char input[1024];
X
Xvoid sum(fi,out)
XFILE *fi;
Xchar *out;
X{
X crc32file s;
X int i;
X int len;
X
X crc32file_clear(&s);
X len = 0;
X while (i = fread(input,1,sizeof(input),fi))
X  {
X   crc32file_addn(&s,input,i);
X   len += i;
X  }
X crc32file_hash(&s,h);
X
X sprintf(out,"%10lu %8lu"
X   ,h[0] + 256 * (h[1] + 256 * (h[2] + 256 * (unsigned long) h[3]))
X   ,len
X   );
X}
END_OF_FILE
if test 457 -ne `wc -c <'cksum.c'`; then
    echo shar: \"'cksum.c'\" unpacked with wrong size!
fi
# end of 'cksum.c'
fi
if test -f 'cksum.tests' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cksum.tests'\"
else
echo shar: Extracting \"'cksum.tests'\" \(32 characters\)
sed "s/^X//" >'cksum.tests' <<'END_OF_FILE'
X3188261980    60030	snefru512.c
END_OF_FILE
if test 32 -ne `wc -c <'cksum.tests'`; then
    echo shar: \"'cksum.tests'\" unpacked with wrong size!
fi
# end of 'cksum.tests'
fi
if test -f 'crc32file.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'crc32file.3'\"
else
echo shar: Extracting \"'crc32file.3'\" \(1527 characters\)
sed "s/^X//" >'crc32file.3' <<'END_OF_FILE'
X.TH crc32file 3
X.SH NAME
Xcrc32file \- apply the standard CRC-32 hash function to a stream
X.SH SYNTAX
X.B #include <crc32file.h>
X
Xvoid \fBcrc32file_clear(\fIm\fB)\fR;
X.br
Xvoid \fBcrc32file_add(\fIm,c\fB)\fR;
X.br
Xvoid \fBcrc32file_addn(\fIm,b,len\fB)\fR;
X.br
Xvoid \fBcrc32file_hash(\fIm,h\fB)\fR;
X
Xcrc32file *\fIm\fP;
X.br
Xunsigned char \fIc\fP;
X.br
Xunsigned char \fIh\fP[CRC32FILE_HASHLEN];
X.br
Xunsigned char *\fIb\fP;
X.br
Xint \fIlen\fR;
X.SH DESCRIPTION
X.B crc32file
Xapplies the standard CRC-32 hash function
Xto a stream of unsigned characters.
X
X.I m
Xpoints to an crc32file structure,
Xwhich accumulates the hash as
Xdata is fed in.
XBefore feeding in any data you must
Xcall
X.B crc32file_clear(\fIm\fB)\fR.
XThen, for each unsigned character
X.I c
Xfrom the stream,
Xcall
X.B crc32file_add(\fIm\fB,\fIc\fB)\fR.
X
XTo process an array
X.I b
Xof
X.I len
Xunsigned characters,
Xcall
X.B crc32file_addn(\fIm\fB,\fIb\fB,\fIlen\fB)\fR.
XThis is faster than calling
X.B crc32file_add
Xon each character in turn.
X
X.B crc32file_hash(\fIm\fB,\fIh\fB)\fR
Xplaces the resulting hash into
X.I h\fP,
Xan array of bytes of
Xlength CRC32FILE_HASHLEN.
XYou may not use
X.I m
Xafter that without
Xagain calling
X.B crc32file_clear(\fIm\fB)\fR.
X
XCRC32FILE_HASHLEN equals 4.
X.SH COMPATIBILITY
XThe
X.B crc32file
Xlibrary was designed for compatibility with
XBSD 4.4
X.B cksum\fR.
X.SH DEFINITION
XSee the POSIX specification for
X.B cksum\fR.
X.SH VERSION
Xcrc32file 0.95, 8 July 1993.
X.SH AUTHOR
XInterface by Daniel J. Bernstein
Xto code written by Gary S. Brown.
X.SH "SEE ALSO"
Xcksum(1)
END_OF_FILE
if test 1527 -ne `wc -c <'crc32file.3'`; then
    echo shar: \"'crc32file.3'\" unpacked with wrong size!
fi
# end of 'crc32file.3'
fi
if test -f 'crc32file.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'crc32file.c'\"
else
echo shar: Extracting \"'crc32file.c'\" \(5058 characters\)
sed "s/^X//" >'crc32file.c' <<'END_OF_FILE'
X/* a few improvements by DJB 930708 */
X/* nonreverse table included by DJB 930622 */
X/* interface mods by DJB 930529 */
X  /*  COPYRIGHT (C) 1986 Gary S. Brown.  You may use this program, or       */
X  /*  code or tables extracted from it, as desired without restriction.     */
X  /*  X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0   */
X  /*      polynomial $edb88320                                              */
X
X#include "crc32file.h"
X
Xstatic unsigned long crc_32_tab[] = {
X	0x0,
X	0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
X	0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6,
X	0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
X	0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac,
X	0x5bd4b01b, 0x569796c2, 0x52568b75, 0x6a1936c8, 0x6ed82b7f,
X	0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a,
X	0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
X	0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58,
X	0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033,
X	0xa4ad16ea, 0xa06c0b5d, 0xd4326d90, 0xd0f37027, 0xddb056fe,
X	0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
X	0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4,
X	0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,
X	0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5,
X	0x2ac12072, 0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
X	0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca, 0x7897ab07,
X	0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c,
X	0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1,
X	0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
X	0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b,
X	0xbb60adfc, 0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698,
X	0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d,
X	0x94ea7b2a, 0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
X	0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2, 0xc6bcf05f,
X	0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,
X	0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80,
X	0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
X	0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a,
X	0x58c1663d, 0x558240e4, 0x51435d53, 0x251d3b9e, 0x21dc2629,
X	0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c,
X	0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
X	0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e,
X	0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65,
X	0xeba91bbc, 0xef68060b, 0xd727bbb6, 0xd3e6a601, 0xdea580d8,
X	0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
X	0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2,
X	0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,
X	0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74,
X	0x857130c3, 0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
X	0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c, 0x7b827d21,
X	0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a,
X	0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e, 0x18197087,
X	0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
X	0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d,
X	0x2056cd3a, 0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce,
X	0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb,
X	0xdbee767c, 0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
X	0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4, 0x89b8fd09,
X	0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,
X	0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf,
X	0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
X};
X
Xvoid crc32file_clear(c)
Xcrc32file *c;
X{
X c->c = 0;
X c->len[0] = c->len[1] = c->len[2] = c->len[3] =
X c->len[4] = c->len[5] = c->len[6] = c->len[7] = 0;
X}
X
Xvoid crc32file_addn(c,s,n)
Xcrc32file *c;
Xregister unsigned char *s;
Xint n;
X{
X register unsigned long x;
X unsigned char newc;
X register int i;
X
X i = n;
X while (i >= 256)
X  {
X   if (!++c->len[1]) if (!++c->len[2]) if (!++c->len[3])
X   if (!++c->len[4]) if (!++c->len[5]) if (!++c->len[6]) if (!++c->len[7])
X     ;
X   i -= 256;
X  }
X newc = i;
X if ((c->len[0] += newc) < newc)
X   if (!++c->len[1]) if (!++c->len[2]) if (!++c->len[3])
X   if (!++c->len[4]) if (!++c->len[5]) if (!++c->len[6]) if (!++c->len[7])
X     ;
X 
X i = n;
X x = c->c;
X while (i--)
X   x = crc_32_tab[(int) ((x >> 24) ^ *s++) & 0xff] ^ (x << 8);
X c->c = x;
X}
X
Xvoid crc32file_add(c,ch)
Xcrc32file *c;
Xunsigned char ch;
X{
X register unsigned long x;
X
X x = c->c;
X c->c = crc_32_tab[(int) ((x >> 24) ^ ch) & 0xff] ^ (x << 8);
X if (!++c->len[0]) if (!++c->len[1]) if (!++c->len[2]) if (!++c->len[3])
X if (!++c->len[4]) if (!++c->len[5]) if (!++c->len[6]) if (!++c->len[7])
X   ;
X}
X
Xvoid crc32file_hash(c,h)
Xcrc32file *c;
Xunsigned char *h;
X{
X register unsigned long x;
X unsigned char len[8];
X int i;
X
X for (i = 0;i < 8;++i) len[i] = c->len[i];
X for (i = 7;i >= 0;--i) if (len[i]) break;
X crc32file_addn(c,len,i + 1);
X
X x = ~c->c;
X h[0] = x & 255; x /= 256;
X h[1] = x & 255; x /= 256;
X h[2] = x & 255; x /= 256;
X h[3] = x & 255;
X}
END_OF_FILE
if test 5058 -ne `wc -c <'crc32file.c'`; then
    echo shar: \"'crc32file.c'\" unpacked with wrong size!
fi
# end of 'crc32file.c'
fi
if test -f 'crc32file.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'crc32file.h'\"
else
echo shar: Extracting \"'crc32file.h'\" \(268 characters\)
sed "s/^X//" >'crc32file.h' <<'END_OF_FILE'
X#ifndef CRC32FILE_H
X#define CRC32FILE_H
X
Xtypedef struct { unsigned long c; unsigned char len[8]; } crc32file;
X
X#define CRC32FILE_HASHLEN 4
X
Xextern void crc32file_clear();
Xextern void crc32file_add();
Xextern void crc32file_addn();
Xextern void crc32file_hash();
X
X#endif
END_OF_FILE
if test 268 -ne `wc -c <'crc32file.h'`; then
    echo shar: \"'crc32file.h'\" unpacked with wrong size!
fi
# end of 'crc32file.h'
fi
if test -f 'fingerprint.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fingerprint.1'\"
else
echo shar: Extracting \"'fingerprint.1'\" \(388 characters\)
sed "s/^X//" >'fingerprint.1' <<'END_OF_FILE'
X.TH fingerprint 1
X.SH NAME
Xfingerprint \- the universal fingerprint program
X.SH SYNTAX
X.B fingerprint
X.SH DESCRIPTION
X.B fingerprint
Xcalculates a cryptographically strong one-way hash of its input.
X
X.B fingerprint
Xconforms to the
X.I summain
Xinterface.
XSee
X.B summain(1)
Xfor a description of
X.B fingerprint\fP's
Xoptions.
X.SH VERSION
Xfingerprint 1.0, 7 July 1993.
X.SH "SEE ALSO"
Xsummain(1)
END_OF_FILE
if test 388 -ne `wc -c <'fingerprint.1'`; then
    echo shar: \"'fingerprint.1'\" unpacked with wrong size!
fi
# end of 'fingerprint.1'
fi
if test -f 'fingerprint.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fingerprint.c'\"
else
echo shar: Extracting \"'fingerprint.c'\" \(377 characters\)
sed "s/^X//" >'fingerprint.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "fprintfile.h"
X
Xstatic unsigned char h[FINGERPRINTFILE_HASHLEN];
Xstatic unsigned char input[1024];
X
Xvoid sum(fi,out)
XFILE *fi;
Xchar *out;
X{
X fingerprintfile f;
X int i;
X
X fingerprintfile_clear(&f);
X while (i = fread(input,1,sizeof(input),fi))
X   fingerprintfile_addn(&f,input,i);
X fingerprintfile_hash(&f,h);
X
X out[fingerprintfile_fmt(out,h)] = 0;
X}
END_OF_FILE
if test 377 -ne `wc -c <'fingerprint.c'`; then
    echo shar: \"'fingerprint.c'\" unpacked with wrong size!
fi
# end of 'fingerprint.c'
fi
if test -f 'fingerprint.tests' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fingerprint.tests'\"
else
echo shar: Extracting \"'fingerprint.tests'\" \(89 characters\)
sed "s/^X//" >'fingerprint.tests' <<'END_OF_FILE'
X9hX04ha9c7F23oV5wWEtGIVWUt:pH07srkl0QOfGsxbensg6BNEd:g8VQIDhn:QZ00VtVu05Kipu	snefru512.c
END_OF_FILE
if test 89 -ne `wc -c <'fingerprint.tests'`; then
    echo shar: \"'fingerprint.tests'\" unpacked with wrong size!
fi
# end of 'fingerprint.tests'
fi
if test -f 'fprintfile.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fprintfile.3'\"
else
echo shar: Extracting \"'fprintfile.3'\" \(2826 characters\)
sed "s/^X//" >'fprintfile.3' <<'END_OF_FILE'
X.TH fingerprintfile 3
X.SH NAME
Xfingerprintfile \- compute the fingerprint of a stream
X.SH SYNTAX
X.B #include <fprintfile.h>
X
Xvoid \fBfingerprintfile_clear(\fIf\fB)\fR;
X.br
Xvoid \fBfingerprintfile_addn(\fIm,b,len\fB)\fR;
X.br
Xvoid \fBfingerprintfile_add(\fIf\fB,\fIc\fB)\fR;
X.br
Xvoid \fBfingerprintfile_hash(\fIf\fB,\fIh\fB)\fR;
X
Xunsigned int \fBfingerprintfile_fmt(\fIs\fB,\fIh\fB)\fR;
X.br
Xunsigned int \fBfingerprintfile_scan(\fIs\fB,\fIh\fB)\fR;
X
Xfingerprintfile *\fIf\fP;
X.br
Xunsigned char \fIc\fP;
X.br
Xunsigned char \fIh\fP[FINGERPRINTFILE_HASHLEN];
X.br
Xunsigned char *\fIb\fP;
X.br
Xint \fIlen\fR;
X
Xchar *\fIs\fP;
X.SH DESCRIPTION
X.B fingerprintfile
Xcomputes the fingerprint
Xof a stream of unsigned characters.
X
XNobody knows how to create two files with the same fingerprint.
X
X.I f
Xpoints to an fingerprintfile structure,
Xwhich accumulates the fingerprint as
Xdata is fed in.
XBefore feeding in any data you must
Xcall
X.B fingerprintfile_clear(\fIf\fB)\fR.
XThen, for each unsigned character
X.I c
Xfrom the stream,
Xcall
X.B fingerprintfile_add(\fIf\fB,\fIc\fB)\fR.
X
XTo process an array
X.I b
Xof
X.I len
Xunsigned characters,
Xcall
X.B fingerprintfile_addn(\fIm\fB,\fIb\fB,\fIlen\fB)\fR.
XThis is faster than calling
X.B fingerprintfile_add
Xon each character in turn.
X
X.B fingerprintfile_hash(\fIf\fB,\fIh\fB)\fR
Xplaces the resulting fingerprint into
X.I h\fP,
Xan array of bytes of
Xlength FINGERPRINTFILE_HASHLEN.
XYou may not use
X.I f
Xafter that without
Xagain calling
X.B fingerprintfile_clear(\fIf\fB)\fR.
X
XFINGERPRINTFILE_HASHLEN equals 57.
X
X.B fingerprintfile_fmt(\fIs\fB,\fIh\fB)\fR
Xplaces a readable version of the hash
X.I h
Xinto the character array
X.I s\fP.
XIt returns the number of characters written.
XIf
X.I s
Xis zero,
X.B fingerprintfile_fmt
Xwill not write anything,
Xbut it will return the number of characters it would have written.
X
X.B fingerprintfile_scan(\fIs\fB,\fIh\fB)\fR
Xattempts to decipher a readable hash
Xappearing in the character array
X.I s\fP.
XIf it fails it returns 0.
XIf it succeeds it places the hash
Xinto
X.I h\fP,
Xand returns the number of characters read
Xfrom
X.I s\fP.
X
XThe readable version of a hash
Xtakes up exactly 76 characters.
X.SH VERSION
Xfingerprintfile 0.95, 8 July 1993.
X.SH DEFINITION
XThe fingerprint contains four pieces of information:
Xthe result of
X.B snefrufile\fR,
Xwhich
X(through
X.B snefru512\fR)
Xcomputes the Snefru-8 function
Xwith code derived from the Xerox Secure Hash Function;
Xthe result of
X.B md5file\fR,
Xwhich computes the
XRSADSI MD5 Message-Digest Algorithm;
Xthe result of
X.B crc32file\fR,
Xwhich computes a standard CRC-32;
Xand the number of bytes of the stream, modulo terabytes.
X.SH AUTHOR
XPlaced into the public domain by Daniel J. Bernstein.
XNote that the libraries used by
X.B fingerprintfile
Xare not public-domain.
X.SH "SEE ALSO"
Xfingerprint(1),
Xcrc32file(3),
Xmd5file(3),
Xsnefrufile(3)
END_OF_FILE
if test 2826 -ne `wc -c <'fprintfile.3'`; then
    echo shar: \"'fprintfile.3'\" unpacked with wrong size!
fi
# end of 'fprintfile.3'
fi
if test -f 'fprintfile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fprintfile.c'\"
else
echo shar: Extracting \"'fprintfile.c'\" \(1507 characters\)
sed "s/^X//" >'fprintfile.c' <<'END_OF_FILE'
X/* fprintfile.c, fprintfmt.c, fprintfile.h: fingerprint library
XDaniel J. Bernstein, brnstnd@nyu.edu.
XDepends on snefrufile.h, md5file.h, crc32file.h.
XNo environment requirements.
X930708: fprintfile 0.95. Public domain.
X930708: Added fingerprintfile_addn.
X930622: Split off fprintfmt.c.
X930601: Baseline, fprintfile 0.8. Public domain.
XNo known patent problems.
X
XDocumentation in fprintfile.3.
X*/
X
X#include "fprintfile.h"
X
Xvoid fingerprintfile_clear(f)
Xfingerprintfile *f;
X{
X snefrufile_clear(&f->s);
X md5file_clear(&f->m);
X crc32file_clear(&f->c);
X f->len[0] = f->len[1] = f->len[2] = f->len[3] = f->len[4] = 0;
X}
X
Xvoid fingerprintfile_addn(f,s,n)
Xfingerprintfile *f;
Xunsigned char *s;
Xint n;
X{
X unsigned char newlen;
X
X snefrufile_addn(&f->s,s,n);
X md5file_addn(&f->m,s,n);
X crc32file_addn(&f->c,s,n);
X while (n >= 256)
X  {
X   if(!++f->len[1])if(!++f->len[2])if(!++f->len[3])++f->len[4];
X   n -= 256;
X  }
X newlen = n;
X if ((f->len[0] += newlen) < newlen)
X   if(!++f->len[1])if(!++f->len[2])if(!++f->len[3])++f->len[4];
X}
X
Xvoid fingerprintfile_add(f,c)
Xfingerprintfile *f;
Xunsigned char c;
X{
X snefrufile_add(&f->s,c);
X md5file_add(&f->m,c);
X crc32file_add(&f->c,c);
X if(!++f->len[0])if(!++f->len[1])if(!++f->len[2])if(!++f->len[3])++f->len[4];
X}
X
Xvoid fingerprintfile_hash(f,h)
Xfingerprintfile *f;
Xunsigned char h[57];
X{
X snefrufile_hash(&f->s,h);
X md5file_hash(&f->m,h + 32);
X crc32file_hash(&f->c,h + 48);
X h[52] = f->len[0]; h[53] = f->len[1]; h[54] = f->len[2];
X h[55] = f->len[3]; h[56] = f->len[4];
X}
END_OF_FILE
if test 1507 -ne `wc -c <'fprintfile.c'`; then
    echo shar: \"'fprintfile.c'\" unpacked with wrong size!
fi
# end of 'fprintfile.c'
fi
if test -f 'fprintfile.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fprintfile.h'\"
else
echo shar: Extracting \"'fprintfile.h'\" \(504 characters\)
sed "s/^X//" >'fprintfile.h' <<'END_OF_FILE'
X#ifndef FINGERPRINTFILE_H
X#define FINGERPRINTFILE_H
X
X#include "snefrufile.h"
X#include "md5file.h"
X#include "crc32file.h"
X
Xtypedef struct
X {
X  snefrufile s;
X  md5file m;
X  crc32file c;
X  unsigned char len[5];
X }
Xfingerprintfile;
X
X#define FINGERPRINTFILE_HASHLEN 57
X
Xextern void fingerprintfile_clear();
Xextern void fingerprintfile_add();
Xextern void fingerprintfile_addn();
Xextern void fingerprintfile_hash();
Xextern unsigned int fingerprintfile_fmt();
Xextern unsigned int fingerprintfile_scan();
X
X#endif
END_OF_FILE
if test 504 -ne `wc -c <'fprintfile.h'`; then
    echo shar: \"'fprintfile.h'\" unpacked with wrong size!
fi
# end of 'fprintfile.h'
fi
if test -f 'fprintfmt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fprintfmt.c'\"
else
echo shar: Extracting \"'fprintfmt.c'\" \(1660 characters\)
sed "s/^X//" >'fprintfmt.c' <<'END_OF_FILE'
X/* fprintfile.c, fprintfmt.c, fprintfile.h: fingerprint library
XDaniel J. Bernstein, brnstnd@nyu.edu.
XDepends on snefrufile.h, md5file.h, crc32file.h.
XNo environment requirements.
X930708: fprintfile 0.95. Public domain.
X930708: Changed slash to colon in base64sane.
X930622: Split off fprintfmt.c.
X930601: Baseline, fprintfile 0.8. Public domain.
XNo known patent problems.
X
XDocumentation in fprintfile.3.
X*/
X
X#include "fprintfile.h"
X
Xstatic char base64sane[]
X= "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ:.";
X
Xunsigned int fingerprintfile_fmt(s,h)
Xchar *s;
Xunsigned char *h;
X{
X if (s)
X  {
X   int i;
X   unsigned long x;
X
X   for (i = 0;i < 19;++i)
X    {
X     x = h[3 * i] + 256 * (h[3 * i + 1] + 256 * (long) h[3 * i + 2]);
X     s[(12 * i) % 76] = base64sane[x & 63]; x /= 64;
X     s[(12 * i + 41) % 76] = base64sane[x & 63]; x /= 64;
X     s[(12 * i + 6) % 76] = base64sane[x & 63]; x /= 64;
X     s[(12 * i + 47) % 76] = base64sane[x & 63];
X    }
X  }
X return 76;
X}
X
Xstatic int unbase64(c)
Xchar c;
X{
X int i;
X
X /* XXX: efficiency? */
X
X for (i = 0;i < 64;++i)
X   if (base64sane[i] == c)
X     return i;
X return -1;
X}
X
Xunsigned int fingerprintfile_scan(s,h)
Xchar *s;
Xunsigned char h[57];
X{
X int i;
X unsigned long x;
X
X for (i = 0;i < 76;++i)
X   if (unbase64(s[i]) == -1) /* XXX: great, calling it twice! */
X     return 0;
X for (i = 0;i < 19;++i)
X  {
X   x = unbase64(s[(12 * i + 47) % 76]); x *= 64;
X   x += unbase64(s[(12 * i + 6) % 76]); x *= 64;
X   x += unbase64(s[(12 * i + 41) % 76]); x *= 64;
X   x += unbase64(s[(12 * i) % 76]);
X   h[3 * i] = x & 255; x = x / 256;
X   h[3 * i + 1] = x & 255; x = x / 256;
X   h[3 * i + 2] = x;
X  }
X return 76;
X}
END_OF_FILE
if test 1660 -ne `wc -c <'fprintfmt.c'`; then
    echo shar: \"'fprintfmt.c'\" unpacked with wrong size!
fi
# end of 'fprintfmt.c'
fi
if test -f 'fptocksum.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fptocksum.c'\"
else
echo shar: Extracting \"'fptocksum.c'\" \(478 characters\)
sed "s/^X//" >'fptocksum.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "fprintfile.h"
X
Xchar line[200];
Xunsigned char h[57];
X
Xmain()
X{
X int i;
X
X while (fgets(line,sizeof(line),stdin))
X  {
X   if (!(i = fingerprintfile_scan(line,h)))
X     printf("bad fingerprint\n");
X   else
X     printf("%10lu %8lu%s"
X       ,h[48] + 256 * (h[49] + 256 * (h[50] + 256 * (unsigned long) h[51]))
X       ,h[52] + 256 * (h[53] + 256 * (h[54] +
X          256 * (h[55] + 256 * (unsigned long) h[56])))
X       ,line + i
X       );
X  }
X exit(0);
X}
END_OF_FILE
if test 478 -ne `wc -c <'fptocksum.c'`; then
    echo shar: \"'fptocksum.c'\" unpacked with wrong size!
fi
# end of 'fptocksum.c'
fi
if test -f 'fptomd5.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fptomd5.c'\"
else
echo shar: Extracting \"'fptomd5.c'\" \(356 characters\)
sed "s/^X//" >'fptomd5.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "fprintfile.h"
X
Xchar line[200];
Xunsigned char h[57];
X
Xmain()
X{
X int i;
X int len;
X
X while (fgets(line,sizeof(line),stdin))
X  {
X   if (!(len = fingerprintfile_scan(line,h)))
X     printf("bad fingerprint\n");
X   else
X    {
X     for (i = 32;i < 48;++i) printf("%02x",(int) h[i]);
X     printf("%s",line + len);
X    }
X  }
X exit(0);
X}
END_OF_FILE
if test 356 -ne `wc -c <'fptomd5.c'`; then
    echo shar: \"'fptomd5.c'\" unpacked with wrong size!
fi
# end of 'fptomd5.c'
fi
if test -f 'fptosnefru.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fptosnefru.c'\"
else
echo shar: Extracting \"'fptosnefru.c'\" \(374 characters\)
sed "s/^X//" >'fptosnefru.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "fprintfile.h"
X
Xchar line[200];
Xunsigned char h[57];
X
Xmain()
X{
X int i;
X int len;
X
X while (fgets(line,sizeof(line),stdin))
X  {
X   if (!(len = fingerprintfile_scan(line,h)))
X     printf("bad fingerprint\n");
X   else
X    {
X     for(i=0;i<32;++i){if(!(i&3))printf(" "); printf("%02x",(int) h[i]);}
X     printf("%s",line + len);
X    }
X  }
X exit(0);
X}
END_OF_FILE
if test 374 -ne `wc -c <'fptosnefru.c'`; then
    echo shar: \"'fptosnefru.c'\" unpacked with wrong size!
fi
# end of 'fptosnefru.c'
fi
if test -f 'getopt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getopt.c'\"
else
echo shar: Extracting \"'getopt.c'\" \(3276 characters\)
sed "s/^X//" >'getopt.c' <<'END_OF_FILE'
X/* getopt.c, getopt.h: (yet another) improved getopt clone
XDaniel J. Bernstein, brnstnd@nyu.edu.
XNo dependencies.
XRequires stdio.
X10/20/91: Removed -DGETOPT_SHUT_UP. [sigh]
X8/26/91: Added -DGETOPT_SHUT_UP.
X8/25/91: Changed getopt to not skip blank arguments.
X7/6/91: Baseline. getopt 1.0, public domain.
XNo known patent problems.
X
XThis is a clone of the usual getopt() functions. It includes opterr so
Xthat you can turn off error handling, optpos so that you can find out
Xexactly where the processing is up to (instead of just which argument),
Xoptproblem so that you can accurately diagnose errors yourself, and
Xoptprogname so that you can set the program name for getopt-generated
Xerrors. getopt() takes much more care to ensure that all the variables
Xstill make sense upon errors and EOF. (optproblem is a character. If
Xargv[optind] is 0, the problem is a missing argument; otherwise it's an
Xillegal option character.) Unless you define GETOPTORIGDEF, the header
Xfile redefines all names so that you don't have to worry about conflicts
Xwith libc. Finally, the code is public-domain, so you should feel free
Xto use these extra features in your own programs and just attach a copy
Xof this.
X
XNote that optind and optpos can be read (or set) any time, but the
Xofficial getopt interface only defines optind when getopt() returns EOF.
XWe define optproblem only when getopt() returns '?', optarg all the
Xtime, and optprogram only after getopt() has been called at least once.
X
X*/
X
X#include <stdio.h> /* for EOF and stderr---talk about immodularity! */
X#include "getopt.h"
X
Xint optind = 1;
Xint optpos = 0;
Xint opterr = 1;
Xchar *optarg = 0;
Xint optproblem = 0;
Xchar *optprogname = 0;
Xint opteof = EOF;
X
Xint getopt(argc,argv,opts)
Xint argc;
Xchar **argv;
Xchar *opts;
X{
X int c;
X char *s;
X
X optarg = 0;
X if (!optprogname)
X  {
X   optprogname = *argv;
X   if (!optprogname) /* oh boy */
X     optprogname = ""; /*XXX*/
X   for (s = optprogname;*s;++s)
X     if (*s == '/')
X       optprogname = s + 1;
X  }
X if (!argv || (optind >= argc) || !argv[optind])
X   return opteof;
X while (optpos && !argv[optind][optpos])
X  {
X   /* we simply skip blank arguments... not any more */
X   ++optind;
X   optpos = 0;
X   if ((optind >= argc) || !argv[optind])
X     return opteof;
X  }
X if (!optpos)
X  {
X   if (argv[optind][0] != '-')
X     return opteof;
X   ++optpos;
X   c = argv[optind][1];
X   if ((c == '-') || (c == 0))
X    {
X     /* XXX: this behavior of "-" is stupid */
X     if (c)
X       ++optind;
X     optpos = 0;
X     return opteof;
X    }
X   /* otherwise c is reassigned below */
X  }
X c = argv[optind][optpos];
X ++optpos;
X s = opts;
X while (*s)
X  {
X   if (c == *s)
X    {
X     if (s[1] == ':')
X      {
X       optarg = argv[optind] + optpos;
X       ++optind;
X       optpos = 0;
X       if (!*optarg)
X        {
X         optarg = argv[optind];
X         if ((optind >= argc) || !optarg) /* argument past end */
X          {
X           optproblem = c;
X           if (opterr)
X             fprintf(stderr,"%s: option requires an argument -- %c\n"
X               ,optprogname,c);
X           return '?';
X          }
X	 ++optind;
X        }
X      }
X     return c;
X    }
X   ++s;
X   if (*s == ':')
X     ++s;
X  }
X optproblem = c;
X if (opterr)
X   fprintf(stderr,"%s: illegal option -- %c\n",optprogname,c);
X return '?';
X}
END_OF_FILE
if test 3276 -ne `wc -c <'getopt.c'`; then
    echo shar: \"'getopt.c'\" unpacked with wrong size!
fi
# end of 'getopt.c'
fi
if test -f 'getopt.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getopt.h'\"
else
echo shar: Extracting \"'getopt.h'\" \(459 characters\)
sed "s/^X//" >'getopt.h' <<'END_OF_FILE'
X#ifndef GETOPT_H
X#define GETOPT_H
X
X#ifndef GETOPTORIGDEF
X#define getopt getoptmine
X#define optarg getoptarg
X#define optind getoptind
X#define opterr getopterr
X#define optpos getoptpos
X#define optproblem getoptproblem
X#define optprogname getoptprogname
X#define opteof getopteof
X#endif
X
Xextern int getopt();
Xextern char *optarg;
Xextern int optind;
Xextern int opterr;
Xextern int optpos;
Xextern int optproblem;
Xextern char *optprogname;
Xextern int opteof;
X
X#endif
END_OF_FILE
if test 459 -ne `wc -c <'getopt.h'`; then
    echo shar: \"'getopt.h'\" unpacked with wrong size!
fi
# end of 'getopt.h'
fi
if test -f 'md5.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'md5.1'\"
else
echo shar: Extracting \"'md5.1'\" \(566 characters\)
sed "s/^X//" >'md5.1' <<'END_OF_FILE'
X.TH md5 1
X.SH NAME
Xmd5 \- the RSADSI MD5 Message-Digest Algorithm
X.SH SYNTAX
X.B md5
X.SH DESCRIPTION
X.B md5
Xcalculates a cryptographically strong one-way hash of its input.
X
X.B md5
Xconforms to the
X.I summain
Xinterface.
XSee
X.B summain(1)
Xfor a description of
X.B md5\fP's
Xoptions.
X.SH VERSION
Xmd5 1.0, 7 July 1993.
X.SH AUTHOR
XMost of the work is done in
Xthe
X.B md5file
Xlibrary,
Xwhich is derived from the
XRSADSI MD5 Message-Digest Algorithm
Xdesigned by
XRon Rivest.
XWrapper code
Xplaced into the public domain by Daniel J. Bernstein.
X.SH "SEE ALSO"
Xsummain(1),
Xmd5file(3)
END_OF_FILE
if test 566 -ne `wc -c <'md5.1'`; then
    echo shar: \"'md5.1'\" unpacked with wrong size!
fi
# end of 'md5.1'
fi
if test -f 'md5.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'md5.c'\"
else
echo shar: Extracting \"'md5.c'\" \(422 characters\)
sed "s/^X//" >'md5.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "md5file.h"
X
Xstatic unsigned char h[MD5FILE_HASHLEN];
Xstatic unsigned char input[1024];
X
Xvoid sum(fi,out)
XFILE *fi;
Xchar *out;
X{
X md5file s;
X int i;
X char *x;
X
X md5file_clear(&s);
X while (i = fread(input,1,sizeof(input),fi))
X   md5file_addn(&s,input,i);
X md5file_hash(&s,h);
X
X x = out;
X for (i = 0;i < MD5FILE_HASHLEN;++i)
X  {
X   sprintf(x,"%02x",(int) h[i]);
X   x += strlen(x);
X  }
X *x = 0;
X}
END_OF_FILE
if test 422 -ne `wc -c <'md5.c'`; then
    echo shar: \"'md5.c'\" unpacked with wrong size!
fi
# end of 'md5.c'
fi
if test -f 'md5.tests' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'md5.tests'\"
else
echo shar: Extracting \"'md5.tests'\" \(45 characters\)
sed "s/^X//" >'md5.tests' <<'END_OF_FILE'
X16344b673995a9049736209bf7ab5779	snefru512.c
END_OF_FILE
if test 45 -ne `wc -c <'md5.tests'`; then
    echo shar: \"'md5.tests'\" unpacked with wrong size!
fi
# end of 'md5.tests'
fi
if test -f 'md5file.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'md5file.3'\"
else
echo shar: Extracting \"'md5file.3'\" \(1557 characters\)
sed "s/^X//" >'md5file.3' <<'END_OF_FILE'
X.TH md5file 3
X.SH NAME
Xmd5file \- apply the RSADSI MD5 Message-Digest Algorithm to a stream
X.SH SYNTAX
X.B #include <md5file.h>
X
Xvoid \fBmd5file_clear(\fIm\fB)\fR;
X.br
Xvoid \fBmd5file_add(\fIm,c\fB)\fR;
X.br
Xvoid \fBmd5file_addn(\fIm,b,len\fB)\fR;
X.br
Xvoid \fBmd5file_hash(\fIm,h\fB)\fR;
X
Xmd5file *\fIm\fP;
X.br
Xunsigned char \fIc\fP;
X.br
Xunsigned char \fIh\fP[MD5FILE_HASHLEN];
X.br
Xunsigned char *\fIb\fP;
X.br
Xint \fIlen\fR;
X.SH DESCRIPTION
X.B md5file
Xapplies the MD5 hash function
Xto a stream of unsigned characters.
X
X.I m
Xpoints to an md5file structure,
Xwhich accumulates the hash as
Xdata is fed in.
XBefore feeding in any data you must
Xcall
X.B md5file_clear(\fIm\fB)\fR.
XThen, for each unsigned character
X.I c
Xfrom the stream,
Xcall
X.B md5file_add(\fIm\fB,\fIc\fB)\fR.
X
XTo process an array
X.I b
Xof
X.I len
Xunsigned characters,
Xcall
X.B md5file_addn(\fIm\fB,\fIb\fB,\fIlen\fB)\fR.
XThis is faster than calling
X.B md5file_add
Xon each character in turn.
X
X.B md5file_hash(\fIm\fB,\fIh\fB)\fR
Xplaces the resulting hash into
X.I h\fP,
Xan array of bytes of
Xlength MD5FILE_HASHLEN.
XYou may not use
X.I m
Xafter that without
Xagain calling
X.B md5file_clear(\fIm\fB)\fR.
X
XMD5FILE_HASHLEN equals 16.
X.SH COMPATIBILITY
XExcept for minor interface differences
Xthis should be completely compatible
Xwith Rivest's MD5 library.
X.SH DEFINITION
XSee RFC 1321.
X.SH VERSION
Xmd5file 0.95, 8 July 1993.
X.SH AUTHOR
XDerived from the RSA Data Security Incorporated
XMD5 Message-Digest Function,
Xdesigned by Ron Rivest.
XThis adaptation created by Daniel J. Bernstein.
X.SH "SEE ALSO"
Xmddriver(1)
END_OF_FILE
if test 1557 -ne `wc -c <'md5file.3'`; then
    echo shar: \"'md5file.3'\" unpacked with wrong size!
fi
# end of 'md5file.3'
fi
if test -f 'md5file.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'md5file.c'\"
else
echo shar: Extracting \"'md5file.c'\" \(10262 characters\)
sed "s/^X//" >'md5file.c' <<'END_OF_FILE'
X/* derived from RSADSI MD5 Message-Digest Algorithm */
X
X/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
Xrights reserved.
X
XLicense to copy and use this software is granted provided that it
Xis identified as the "RSA Data Security, Inc. MD5 Message-Digest
XAlgorithm" in all material mentioning or referencing this software
Xor this function.
X
XLicense is also granted to make and use derivative works provided
Xthat such works are identified as "derived from the RSA Data
XSecurity, Inc. MD5 Message-Digest Algorithm" in all material
Xmentioning or referencing the derived work.
X
XRSA Data Security, Inc. makes no representations concerning either
Xthe merchantability of this software or the suitability of this
Xsoftware for any particular purpose. It is provided "as is"
Xwithout express or implied warranty of any kind.
X
XThese notices must be retained in any copies of any part of this
Xdocumentation and/or software.
X */
X
X#include "md5file.h"
X
Xtypedef unsigned char *POINTER;
X
X/* Constants for MD5Transform routine.
X */
X
X#define S11 7
X#define S12 12
X#define S13 17
X#define S14 22
X#define S21 5
X#define S22 9
X#define S23 14
X#define S24 20
X#define S31 4
X#define S32 11
X#define S33 16
X#define S34 23
X#define S41 6
X#define S42 10
X#define S43 15
X#define S44 21
X
Xstatic void MD5Transform ();
Xstatic void Encode ();
Xstatic void Decode ();
Xstatic void MD5_memcpy ();
Xstatic void MD5_memset ();
X
Xstatic unsigned char PADDING[64] = {
X  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
X  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
X  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
X};
X
X/* F, G, H and I are basic MD5 functions.
X */
X#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
X#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
X#define H(x, y, z) ((x) ^ (y) ^ (z))
X#define I(x, y, z) ((y) ^ ((x) | (~z)))
X
X/* ROTATE_LEFT rotates x left n bits.
X */
X#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
X
X/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
XRotation is separate from addition to prevent recomputation.
X */
X#define FF(a, b, c, d, x, s, ac) { \
X (a) += F ((b), (c), (d)) + (x) + (md5file_word)(ac); \
X (a) = ROTATE_LEFT ((a), (s)); \
X (a) += (b); \
X  }
X#define GG(a, b, c, d, x, s, ac) { \
X (a) += G ((b), (c), (d)) + (x) + (md5file_word)(ac); \
X (a) = ROTATE_LEFT ((a), (s)); \
X (a) += (b); \
X  }
X#define HH(a, b, c, d, x, s, ac) { \
X (a) += H ((b), (c), (d)) + (x) + (md5file_word)(ac); \
X (a) = ROTATE_LEFT ((a), (s)); \
X (a) += (b); \
X  }
X#define II(a, b, c, d, x, s, ac) { \
X (a) += I ((b), (c), (d)) + (x) + (md5file_word)(ac); \
X (a) = ROTATE_LEFT ((a), (s)); \
X (a) += (b); \
X  }
X
X/* MD5 initialization. Begins an MD5 operation, writing a new context.
X */
Xvoid md5file_clear (context)
Xmd5file *context;
X{
X  context->count[0] = context->count[1] = 0;
X  /* Load magic initialization constants.  */
X  context->state[0] = 0x67452301;
X  context->state[1] = 0xefcdab89;
X  context->state[2] = 0x98badcfe;
X  context->state[3] = 0x10325476;
X}
X
X/* MD5 block update operation. Continues an MD5 message-digest
X  operation, processing another message block, and updating the
X  context.
X */
Xvoid md5file_addn (context, input, inputLen)
Xmd5file *context;
Xunsigned char *input;                                /* input block */
Xint inputLen;                     /* length of input block */
X{
X  unsigned int i, index, partLen;
X
X  /* Compute number of bytes mod 64 */
X  index = (unsigned int)((context->count[0] >> 3) & 0x3F);
X
X  /* Update number of bits */
X  if ((context->count[0] += ((md5file_word)inputLen << 3))
X   < ((md5file_word)inputLen << 3))
X context->count[1]++;
X  context->count[1] += ((md5file_word)inputLen >> 29);
X
X  partLen = 64 - index;
X
X  /* Transform as many times as possible.
X*/
X  if (inputLen >= partLen) {
X MD5_memcpy
X   ((POINTER)&context->buffer[index], (POINTER)input, partLen);
X MD5Transform (context->state, context->buffer);
X
X for (i = partLen; i + 63 < inputLen; i += 64)
X   MD5Transform (context->state, &input[i]);
X
X index = 0;
X  }
X  else
X i = 0;
X
X  /* Buffer remaining input */
X  MD5_memcpy
X ((POINTER)&context->buffer[index], (POINTER)&input[i],
X  inputLen-i);
X}
X
Xvoid md5file_add(context,c)
Xmd5file *context;
Xunsigned char c;
X{
X md5file_addn(context,&c,1);
X}
X
X/* MD5 finalization. Ends an MD5 message-digest operation, writing
X  the message digest and zeroizing the context.
X */
Xvoid md5file_hash (context,digest)
Xmd5file *context;
Xunsigned char digest[16];                         /* message digest */
X{
X  unsigned char bits[8];
X  unsigned int index, padLen;
X
X  /* Save number of bits */
X  Encode (bits, context->count, 8);
X
X  /* Pad out to 56 mod 64.  */
X  index = (unsigned int)((context->count[0] >> 3) & 0x3f);
X  padLen = (index < 56) ? (56 - index) : (120 - index);
X  md5file_addn (context, PADDING, padLen);
X
X  /* Append length (before padding) */
X  md5file_addn (context, bits, 8);
X  /* Store state in digest */
X  Encode (digest, context->state, 16);
X
X  /* Zeroize sensitive information.  */
X  MD5_memset ((POINTER)context, 0, sizeof (*context));
X}
X
X/* MD5 basic transformation. Transforms state based on block.
X */
Xstatic void MD5Transform (state, block)
Xmd5file_word state[4];
Xunsigned char block[64];
X{
X  md5file_word a = state[0], b = state[1], c = state[2], d = state[3], x[16];
X
X  Decode (x, block, 64);
X
X  /* Round 1 */
X  FF (a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */
X  FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */
X  FF (c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */
X  FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */
X  FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */
X  FF (d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */
X  FF (c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */
X  FF (b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */
X  FF (a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */
X  FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */
X  FF (c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
X  FF (b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
X  FF (a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
X  FF (d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
X  FF (c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
X  FF (b, c, d, a, x[15], S14, 0x49b40821); /* 16 */
X
X /* Round 2 */
X  GG (a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */
X  GG (d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */
X  GG (c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
X  GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */
X  GG (a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */
X  GG (d, a, b, c, x[10], S22,  0x2441453); /* 22 */
X  GG (c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
X  GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */
X  GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */
X  GG (d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
X  GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */
X  GG (b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */
X  GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
X  GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
X  GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
X  GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
X
X  /* Round 3 */
X  HH (a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */
X  HH (d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */
X  HH (c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
X  HH (b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
X  HH (a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */
X  HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
X  HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
X  HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
X  HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
X  HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
X  HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */
X  HH (b, c, d, a, x[ 6], S34,  0x4881d05); /* 44 */
X  HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */
X  HH (d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
X  HH (c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
X  HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */
X
X  /* Round 4 */
X  II (a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
X  II (d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
X  II (c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
X  II (b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */
X  II (a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
X  II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */
X  II (c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
X  II (b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */
X  II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */
X  II (d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
X  II (c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */
X  II (b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
X  II (a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */
X  II (d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
X  II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */
X  II (b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */
X
X  state[0] += a;
X  state[1] += b;
X  state[2] += c;
X  state[3] += d;
X
X  /* Zeroize sensitive information.
X*/
X  MD5_memset ((POINTER)x, 0, sizeof (x));
X}
X
X/* Encodes input (md5file_word) into output (unsigned char). Assumes len is
X  a multiple of 4.
X */
Xstatic void Encode (output, input, len)
Xunsigned char *output;
Xmd5file_word *input;
Xunsigned int len;
X{
X  unsigned int i, j;
X
X  for (i = 0, j = 0; j < len; i++, j += 4) {
X output[j] = (unsigned char)(input[i] & 0xff);
X output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
X output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
X output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
X  }
X}
X
X/* Decodes input (unsigned char) into output (md5file_word). Assumes len is
X  a multiple of 4.
X */
Xstatic void Decode (output, input, len)
Xmd5file_word *output;
Xunsigned char *input;
Xunsigned int len;
X{
X  unsigned int i, j;
X
X  for (i = 0, j = 0; j < len; i++, j += 4)
X output[i] = ((md5file_word)input[j]) | (((md5file_word)input[j+1]) << 8) |
X   (((md5file_word)input[j+2]) << 16) | (((md5file_word)input[j+3]) << 24);
X}
X
X/* Note: Replace "for loop" with standard memcpy if possible.
X */
X
Xstatic void MD5_memcpy (output, input, len)
XPOINTER output;
XPOINTER input;
Xunsigned int len;
X{
X  unsigned int i;
X
X  for (i = 0; i < len; i++)
X output[i] = input[i];
X}
X
X/* Note: Replace "for loop" with standard memset if possible.
X */
Xstatic void MD5_memset (output, value, len)
XPOINTER output;
Xint value;
Xunsigned int len;
X{
X  unsigned int i;
X
X  for (i = 0; i < len; i++)
X ((char *)output)[i] = (char)value;
X}
END_OF_FILE
if test 10262 -ne `wc -c <'md5file.c'`; then
    echo shar: \"'md5file.c'\" unpacked with wrong size!
fi
# end of 'md5file.c'
fi
if test -f 'md5file.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'md5file.h'\"
else
echo shar: Extracting \"'md5file.h'\" \(339 characters\)
sed "s/^X//" >'md5file.h' <<'END_OF_FILE'
X#ifndef MD5FILE_H
X#define MD5FILE_H
X
Xtypedef unsigned long md5file_word;
X
Xtypedef struct md5file
X {
X  md5file_word state[4];
X  md5file_word count[2];
X  unsigned char buffer[64];
X }
Xmd5file;
X
X#define MD5FILE_HASHLEN 16
X
Xextern void md5file_clear();
Xextern void md5file_add();
Xextern void md5file_addn();
Xextern void md5file_hash();
X
X#endif
END_OF_FILE
if test 339 -ne `wc -c <'md5file.h'`; then
    echo shar: \"'md5file.h'\" unpacked with wrong size!
fi
# end of 'md5file.h'
fi
if test -f 'snefru.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'snefru.1'\"
else
echo shar: Extracting \"'snefru.1'\" \(865 characters\)
sed "s/^X//" >'snefru.1' <<'END_OF_FILE'
X.TH snefru 1
X.SH NAME
Xsnefru \- the Xerox Secure Hash Function, version 2.5a
X.SH SYNTAX
X.B snefru
X.SH DESCRIPTION
X.B snefru
Xcalculates a cryptographically strong one-way hash of its input.
X
X.B snefru
Xconforms to the
X.I summain
Xinterface.
XSee
X.B summain(1)
Xfor a description of
X.B snefru\fP's
Xoptions.
X.SH COMPATIBILITY
XThis is a clone of
XRalph Merkle's
X.B snefru
Xprogram.
XIf you find two inputs which produce the same output,
Xplease
Xverify first that
XMerkle's version produces the same output,
Xand then contact
Xhim at
Xmerkle@parc.xerox.com.
X.SH VERSION
Xsnefru 1.2, 7 July 1993.
X.SH AUTHOR
XMost of the work is done in
Xthe
X.B snefrufile
Xand
X.B snefru512
Xlibraries,
Xwhich are
Xderived from the Xerox Secure Hash Function
Xas implemented by Merkle.
XWrapper code
Xplaced into the public domain by Daniel J. Bernstein.
X.SH "SEE ALSO"
Xsummain(1),
Xsnefrufile(3),
Xsnefru512(3)
END_OF_FILE
if test 865 -ne `wc -c <'snefru.1'`; then
    echo shar: \"'snefru.1'\" unpacked with wrong size!
fi
# end of 'snefru.1'
fi
if test -f 'snefru.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'snefru.c'\"
else
echo shar: Extracting \"'snefru.c'\" \(477 characters\)
sed "s/^X//" >'snefru.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "snefrufile.h"
X
Xstatic unsigned char h[SNEFRUFILE_HASHLEN];
Xstatic unsigned char input[1024];
X
Xvoid sum(fi,out)
XFILE *fi;
Xchar *out;
X{
X snefrufile s;
X int i;
X char *x;
X
X snefrufile_clear(&s);
X while (i = fread(input,1,sizeof(input),fi))
X   snefrufile_addn(&s,input,i);
X snefrufile_hash(&s,h);
X
X x = out;
X for (i = 0;i < SNEFRUFILE_HASHLEN;++i)
X  {
X   if (!(i & 3))
X     *x++ = ' ';
X   sprintf(x,"%02x",(int) h[i]);
X   x += strlen(x);
X  }
X *x = 0;
X}
END_OF_FILE
if test 477 -ne `wc -c <'snefru.c'`; then
    echo shar: \"'snefru.c'\" unpacked with wrong size!
fi
# end of 'snefru.c'
fi
if test -f 'snefru.tests' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'snefru.tests'\"
else
echo shar: Extracting \"'snefru.tests'\" \(85 characters\)
sed "s/^X//" >'snefru.tests' <<'END_OF_FILE'
X 49a81803 84463870 1474b424 25867457 9773aebc 3b4c9ce7 aaef779b f400d781	snefru512.c
END_OF_FILE
if test 85 -ne `wc -c <'snefru.tests'`; then
    echo shar: \"'snefru.tests'\" unpacked with wrong size!
fi
# end of 'snefru.tests'
fi
if test -f 'snefru512.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'snefru512.3'\"
else
echo shar: Extracting \"'snefru512.3'\" \(1580 characters\)
sed "s/^X//" >'snefru512.3' <<'END_OF_FILE'
X.TH snefru512 3
X.SH NAME
Xsnefru512 \- apply the Xerox Secure Hash Function to a 512-bit block
X.SH SYNTAX
X.B #include <snefru512.h>
X
Xvoid \fBsnefru512_setup()\fR;
X
Xvoid \fBsnefru512(\fIout\fB,\fIin\fB,\fIlev\fB)\fR;
X
Xsnefru512_word \fIout\fP[8];
X.br
Xsnefru512_word \fIin\fP[16];
X.br
Xint \fIlev\fP;
X.SH DESCRIPTION
X.B snefru512
Xis derived from the Xerox Secure Hash Function.
XIt hashes a 512-bit block
X.I in
Xinto a 256-bit block
X.I out\fP.
XThe hash function is cryptographically strong.
X
XTo hash
X.I in
Xinto
X.I out\fP,
Xcall
X.B snefru512(\fIout\fB,\fIin\fB,\fIlev\fB)\fR.
X.I out
Xand
X.I in
Xare arrays of
X8 and 16
Xsnefru512_words respectively.
Xsnefru512_word
Xis a 32-bit unsigned integer type.
X
X.I lev
Xis the Snefru security level,
Xany number from 2 through 8.
XSnefru-2 is fast but insecure.
XSnefru-4 might not be safe against
Xattacks by powerful future computers.
XSnefru-8 is very strong and not too slow for most applications.
X
XBefore calling
X.B snefru512
Xyou must call
X.B snefru512_setup()\fR.
XYou may call
X.B snefru512_setup()
Xany number of times.
X
XThe
XSnefru algorithm
Xwas designed by Ralph C. Merkle.
XIt is named after a Pharaoh of ancient Egypt.
XMerkle is offering a large cash reward to anyone who
Xcan break Snefru-4.
X.SH DEFINITION
XSee Ralph C. Merkle,
X.I A Fast Software One-Way Hash Function\fP.
X.SH VERSION
Xsnefru512 1.0, 1 June 1993.
X.SH AUTHOR
XThis code is essentially the same as
XMerkle's reference Snefru 2.0 implementation,
Xas modified by Rich Salz,
Xtogether with the Snefru 2.5 S boxes.
XThis adaptation was created by Daniel J. Bernstein.
X.SH "SEE ALSO"
Xsnefrufile(3)
END_OF_FILE
if test 1580 -ne `wc -c <'snefru512.3'`; then
    echo shar: \"'snefru512.3'\" unpacked with wrong size!
fi
# end of 'snefru512.3'
fi
if test -f 'snefru512.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'snefru512.h'\"
else
echo shar: Extracting \"'snefru512.h'\" \(247 characters\)
sed "s/^X//" >'snefru512.h' <<'END_OF_FILE'
X#ifndef SNEFRU512_H
X#define SNEFRU512_H
X
Xtypedef unsigned long snefru512_word;
X
Xextern snefru512_word snefru512_sboxes[16][256];
Xextern snefru512_word snefru512_rotated[4][16][256];
X
Xextern void snefru512_setup();
Xextern void snefru512();
X
X#endif
END_OF_FILE
if test 247 -ne `wc -c <'snefru512.h'`; then
    echo shar: \"'snefru512.h'\" unpacked with wrong size!
fi
# end of 'snefru512.h'
fi
if test -f 'snefrufile.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'snefrufile.3'\"
else
echo shar: Extracting \"'snefrufile.3'\" \(1638 characters\)
sed "s/^X//" >'snefrufile.3' <<'END_OF_FILE'
X.TH snefrufile 3
X.SH NAME
Xsnefrufile \- apply the Xerox Secure Hash Function to a stream
X.SH SYNTAX
X.B #include <snefrufile.h>
X
Xvoid \fBsnefrufile_clear(\fIs\fB)\fR;
X.br
Xvoid \fBsnefrufile_add(\fIs,c\fB)\fR;
X.br
Xvoid \fBsnefrufile_addn(\fIm,b,len\fB)\fR;
X.br
Xvoid \fBsnefrufile_hash(\fIs,h\fB)\fR;
X
Xsnefrufile *\fIs\fP;
X.br
Xunsigned char \fIc\fP;
X.br
Xunsigned char \fIh\fP[SNEFRUFILE_HASHLEN];
X.br
Xunsigned char *\fIb\fP;
X.br
Xint \fIlen\fR;
X.SH DESCRIPTION
X.B snefrufile
Xprovides a standard way to apply
XMerkle's
XSnefru-8 hash function
Xto a stream of unsigned characters.
X
X.I s
Xpoints to a snefrufile structure,
Xwhich accumulates the hash as
Xdata is fed in.
XBefore feeding in any data you must
Xcall
X.B snefrufile_clear(\fIs\fB)\fR.
XThen, for each unsigned character
X.I c
Xfrom the stream,
Xcall
X.B snefrufile_add(\fIs\fB,\fIc\fB)\fR.
X
XTo process an array
X.I b
Xof
X.I len
Xunsigned characters,
Xcall
X.B snefrufile_addn(\fIm\fB,\fIb\fB,\fIlen\fB)\fR.
XThis is faster than calling
X.B snefrufile_add
Xon each character in turn.
X
X.B snefrufile_hash(\fIs\fB,\fIh\fB)\fR
Xplaces the resulting hash into
X.I h\fP,
Xan array of bytes of
Xlength SNEFRUFILE_HASHLEN.
XYou may not use
X.I s
Xafter that without
Xagain calling
X.B snefrufile_clear(\fIs\fB)\fR.
X
XSNEFRUFILE_HASHLEN equals 32.
X.SH COMPATIBILITY
XThe
X.B snefrufile
Xlibrary
Xwas designed for compatibility
Xwith Merkle's original
X.B snefru
Xutility.
X.SH VERSION
Xsnefrufile 0.95, 8 July 1993.
X.SH AUTHOR
XPlaced into the public domain by Daniel J. Bernstein.
X.B snefrufile
Xis simply a wrapper around
X.B snefru512\fR,
Xwhich is derived from the Xerox Secure Hash Function.
X.SH "SEE ALSO"
Xsnefru(1),
Xsnefru512(3)
END_OF_FILE
if test 1638 -ne `wc -c <'snefrufile.3'`; then
    echo shar: \"'snefrufile.3'\" unpacked with wrong size!
fi
# end of 'snefrufile.3'
fi
if test -f 'snefrufile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'snefrufile.c'\"
else
echo shar: Extracting \"'snefrufile.c'\" \(2639 characters\)
sed "s/^X//" >'snefrufile.c' <<'END_OF_FILE'
X/* snefrufile.c, snefrufile.h: Snefru stream hashing library
XDaniel J. Bernstein, brnstnd@nyu.edu.
XDepends on snefru512.h.
XNo environment requirements.
X930708: snefrufile 0.95. Public domain.
X930708: Added snefrufile_addn.
X930708: Moved wm, wl, ctr out to static globals.
X930601: Baseline, snefrufile 0.8. Public domain.
XNo known patent problems.
X
XDocumentation in snefrufile.3.
X*/
X
X#include "snefru512.h"
X#include "snefrufile.h"
X
Xstatic snefru512_word tr[16] =
X/* backwards, for compatibility with Merkle's implementation */
X {
X  66051, 67438087, 134810123, 202182159, 269554195, 336926231,
X  404298267, 471670303, 539042339, 606414375, 673786411, 741158447,
X  808530483, 875902519, 943274555, 1010646591
X } ;
X
Xvoid snefrufile_clear(s)
Xsnefrufile *s;
X{
X int i;
X
X snefru512_setup(); /* XXX: called multiple times unnecessarily */
X
X for (i = 0;i < 64;++i) s->c[i] = 0;
X for (i = 0;i < 8;++i) s->len[i] = 0;
X s->n = 32;
X}
X
Xstatic unsigned char l[64];
Xstatic unsigned char m[32];
Xstatic snefru512_word *wm = &m[0];
Xstatic snefru512_word *wl = &l[0];
Xstatic unsigned char *ctr = &tr[0];
X
Xvoid snefrufile_addn(s,t,len)
Xsnefrufile *s;
Xregister unsigned char *t;
Xint len;
X{
X register int n;
X register int i;
X unsigned char newlen;
X
X i = len;
X while (i >= 32)
X  {
X   if (!++s->len[1]) if (!++s->len[2]) if (!++s->len[3]) if (!++s->len[4])
X   if (!++s->len[5]) if (!++s->len[6]) if (!++s->len[7]) ; /* too bad */
X   i -= 32;
X  }
X newlen = i << 3;
X if ((s->len[0] += newlen) < newlen)
X   if (!++s->len[1]) if (!++s->len[2]) if (!++s->len[3]) if (!++s->len[4])
X   if (!++s->len[5]) if (!++s->len[6]) if (!++s->len[7]) ; /* too bad */
X n = s->n;
X while (len--)
X  {
X   s->c[n++] = *t++;
X   if (n == 64)
X    {
X     for (i = 0;i < 64;++i) l[ctr[i]] = s->c[i];
X     snefru512(wm,wl,8);
X     for (i = 0;i < 32;++i) s->c[i] = m[ctr[i]];
X     n = 32;
X    }
X  }
X s->n = n;
X}
X
Xvoid snefrufile_add(s,c)
Xsnefrufile *s;
Xunsigned char c;
X{
X int n;
X register int i;
X
X n = s->n;
X s->c[n++] = c;
X if (!(s->len[0] += 8))
X   if (!++s->len[1]) if (!++s->len[2]) if (!++s->len[3]) if (!++s->len[4])
X   if (!++s->len[5]) if (!++s->len[6]) if (!++s->len[7]) ; /* too bad */
X if (n == 64)
X  {
X   for (i = 0;i < 64;++i) l[ctr[i]] = s->c[i];
X   snefru512(wm,wl,8);
X   for (i = 0;i < 32;++i) s->c[i] = m[ctr[i]];
X   n = 32;
X  }
X s->n = n;
X}
X
Xvoid snefrufile_hash(s,h)
Xsnefrufile *s;
Xunsigned char *h;
X{
X int len[8];
X int i;
X
X for (i = 0;i < 8;++i) len[i] = s->len[i];
X while (s->n != 32) snefrufile_add(s,(unsigned char) 0);
X while (s->n != 56) snefrufile_add(s,(unsigned char) 0);
X for (i = 0;i < 8;++i) snefrufile_add(s,len[7 - i]);
X for (i = 0;i < 32;++i) h[i] = s->c[i];
X}
END_OF_FILE
if test 2639 -ne `wc -c <'snefrufile.c'`; then
    echo shar: \"'snefrufile.c'\" unpacked with wrong size!
fi
# end of 'snefrufile.c'
fi
if test -f 'snefrufile.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'snefrufile.h'\"
else
echo shar: Extracting \"'snefrufile.h'\" \(307 characters\)
sed "s/^X//" >'snefrufile.h' <<'END_OF_FILE'
X#ifndef SNEFRUFILE_H
X#define SNEFRUFILE_H
X
Xtypedef struct snefrufile
X {
X  unsigned char c[64];
X  int n;
X  unsigned char len[8];
X }
Xsnefrufile;
X
X#define SNEFRUFILE_HASHLEN 32
X
Xextern void snefrufile_clear();
Xextern void snefrufile_add();
Xextern void snefrufile_addn();
Xextern void snefrufile_hash();
X
X#endif
END_OF_FILE
if test 307 -ne `wc -c <'snefrufile.h'`; then
    echo shar: \"'snefrufile.h'\" unpacked with wrong size!
fi
# end of 'snefrufile.h'
fi
if test -f 'summain.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'summain.1'\"
else
echo shar: Extracting \"'summain.1'\" \(2354 characters\)
sed "s/^X//" >'summain.1' <<'END_OF_FILE'
X.TH summain 1
X.SH NAME
Xsummain \- generic checksum program interface
X.SH SYNTAX
X.I summain
X[
X\fB\-cgfFiIbB\fP
X] [
X\fIfile ...\fP
X]
X.SH DESCRIPTION
X.I summain
Xis a generic interface for programs which compute checksums.
XThere is no actual
X.B summain
Xprogram.
XInstead, several other programs,
Xsuch as
X.B cksum
Xand
X.B fingerprint\fP,
Xall conform to
Xthe
X.I summain
Xinterface.
X
X.I summain
Xcomputes checksums for some number of files.
XNormally it takes the filenames as arguments,
Xopens the files in binary mode,
Xcomputes their checksums,
Xand prints the checksums (with filenames) on standard output.
X
XA checksum never contains the characters tab, space, newline, or null.
XOther features of a checksum depend on the particular program.
X
X.I summain
Xfollows the
X.B getopt
Xstandard.
XIts options are summarized here.
X.TP
X.B \-b
XOpen files in binary mode (default).
X.TP
X.B \-B
XOpen files in text mode.
X.TP
X.B \-i
XRead filenames from input, and ignore any filename arguments.
X.TP
X.B \-I
XUse arguments as filenames (default).
XIf no arguments are given,
X.I summain
Xreads the standard input as a file.
XOtherwise it ignores
Xthe input.
X.TP
X.B \-f
XWhen the
X.B \-i
Xoption is in effect,
Xread input lines with the
Xsame format as the usual output
Xof
X.I summain\fP.
XIn other words, look for the first tab on each input line,
Xand use the filename following that tab.
X.TP
X.B \-F
XWhen the
X.B \-i
Xoption is in effect,
Xread filenames as entire input lines (default).
X.TP
X.B \-g
XGenerate checksums (default).
X.I summain
Xwill print each checksum, followed by a tab and the
Xname of the file,
Xas a separate line on standard output.
XThe checksum of the standard input is printed with a tab
Xbut no filename.
X.TP
X.B \-c
XCheck checksums.
XThis option forces
X.B \-fi\fP.
X.I summain
Xwill read any number of input lines,
Xeach containing a purported checksum, a tab, and a filename.
X.I summain
Xwill open each file, compute its checksum, and compare the
Xchecksum to the purported checksum.
X.SH "EXIT VALUE"
X0 normally.
X1 for usage messages.
X2 if a file could not be opened for reading.
X3 with option
X.B \-c
Xif any checksums failed to match.
X(Exit value 3 overrides exit value 2.)
X.SH BUGS
XNone known.
X.SH VERSION
Xsummain version 0.9, 13 July 1993.
X.SH AUTHOR
XPlaced into the public domain by Daniel J. Bernstein.
X.SH "SEE ALSO"
X.B cksum(1)\fP,
X.B fingerprint(1)\fP,
X.B md5(1)\fP,
X.B snefru(1)\fP
END_OF_FILE
if test 2354 -ne `wc -c <'summain.1'`; then
    echo shar: \"'summain.1'\" unpacked with wrong size!
fi
# end of 'summain.1'
fi
if test -f 'summain.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'summain.c'\"
else
echo shar: Extracting \"'summain.c'\" \(2101 characters\)
sed "s/^X//" >'summain.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <errno.h>
Xextern int errno;
X#include "getopt.h"
X
X#define TAB '	' /*XXX*/
X
Xint flagcheck = 0;
Xint flagin = 0;
Xint flaghin = 0;
Xint flagbinary = 1;
X
Xint flagallmatch = 1;
Xint flagreaderr = 0;
X
Xchar *oldhash; /* defined for the duration of doit, if flagcheck */
X
Xvoid doit(fi,fn)
XFILE *fi;
Xchar *fn;
X{
X static char out[100];
X
X sum(fi,out);
X
X if (flagcheck)
X  {
X   if (strcmp(oldhash,out))
X    {
X     fprintf(stderr,"%s: warning: %s hash does not match\n"
X       ,optprogname,fn);
X     flagallmatch = 0;
X    }
X  }
X else
X  {
X   fputs(out,stdout);
X   putchar(TAB);
X   puts(fn);
X  }
X}
X
Xvoid handle(x)
Xchar *x;
X{
X FILE *fi;
X
X fi = fopen(x,flagbinary ? "rb" : "r");
X if (!fi)
X  {
X   int errnobak;
X   errnobak = errno;
X   fprintf(stderr,"%s: warning: cannot open %s for "
X     ,optprogname,x);
X   errno = errnobak;
X   perror("reading");
X   flagreaderr = 1;
X  }
X else
X  {
X   doit(fi,x);
X   fclose(fi);
X  }
X}
X
Xchar line[1000];
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X{
X int opt;
X
X while ((opt = getopt(argc,argv,"cgfFiIbB")) != opteof)
X   switch(opt)
X    {
X     case 'c': flagcheck = 1; break;
X     case 'g': flagcheck = 0; break;
X     case 'f': flaghin = 0; break;
X     case 'F': flaghin = 1; break;
X     case 'i': flagin = 1; break;
X     case 'I': flagin = 0; break;
X     case 'b': flagbinary = 1; break;
X     case 'B': flagbinary = 0; break;
X     case '?': default: exit(1);
X    }
X argc -= optind;
X argv += optind;
X
X if (flagcheck)
X   flagin = flaghin = 1;
X
X if (flagin)
X   while (fgets(line,sizeof(line),stdin))
X    {
X     char *x;
X     int len;
X     x = line;
X     if (flaghin)
X      {
X       while (*x && (*x != '\n') && (*x != TAB)) ++x;
X       if (*x == TAB) *x++ = 0;
X      }
X     if (!*x) continue; /*XXX*/
X     len = strlen(x);
X     if (x[len - 1] == '\n') x[len - 1] = 0;
X     if (!*x) continue; /*XXX*/
X     if (flagcheck)
X       oldhash = line;
X     handle(x);
X    }
X else
X   if (*argv)
X     while (*argv)
X      {
X       handle(*argv);
X       ++argv;
X      }
X   else
X     doit(stdin,""); /*XXX*/
X
X if (!flagallmatch)
X   exit(3);
X if (flagreaderr)
X   exit(2);
X exit(0);
X}
END_OF_FILE
if test 2101 -ne `wc -c <'summain.c'`; then
    echo shar: \"'summain.c'\" unpacked with wrong size!
fi
# end of 'summain.c'
fi
echo shar: End of archive 1 \(of 2\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
