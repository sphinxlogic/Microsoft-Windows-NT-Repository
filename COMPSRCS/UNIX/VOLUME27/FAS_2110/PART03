Newsgroups: comp.sources.unix
From: fas@geminix.in-berlin.de (FAS Support Account)
Subject: v27i069: FAS-2.11.0 - asynch serial driver for System V, Part03/08
References: <1.750471074.20539@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: fas@geminix.in-berlin.de (FAS Support Account)
Posting-Number: Volume 27, Issue 69
Archive-Name: fas-2.11.0/part03

#!/bin/sh
# this is fas211pl0.03 (part 3 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file fas.7 continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 3; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping fas.7'
else
echo 'x - continuing file fas.7'
sed 's/^X//' << 'SHAR_EOF' >> 'fas.7' &&
XIf at this time there are still characters in the output
Xbuffer the last process closing this port can't terminate
Xuntil the buffer has drained.
XBut as \fBDSR\fP will also go low if you switch off the device
Xthe blocking of the output will be prevented.
X.LP
XIn short:
XHardware output handshake is only used if the connected
Xdevice sets \fBDSR\fP high, that is, the device is switched
Xon and is ready.
XSo make sure that you keep this in mind when you make
Xserial cables and when you configure your serial devices.
X\fBDSR\fP must be on if you want \fBCTS\fP handshake.
X.LP
XThe other advantage of this \fBCTS\fP/\fBDSR\fP mechanismn
Xis that you can still connect "dumb" serial devices to an
X\fIFAS\fP hardware handshake port using a minimal 3\-wire cable.
XAs an unconnected \fBDSR\fP line is automatically low, hardware
Xoutput handshake is disabled, which is just what you
Xwant in this case.
XHowever, it's safer to use a minor device number of
X\fB0\fP + device # for 3\-wire cables (see section \fBCABLING\fP).
X.LP
XThe CLOCAL flag doesn't affect this mode.
X.IP "Note:" 6
XIf you use a minor device number where hardware handshake
Xis disabled (see ``First mode'' below) you can, if you have
XSCO UNIX 3.2.4, enable full duplex hardware flow control
Xby setting the CRTSFL \fItermio\fP(M) flag.
XThis works, however, only if neither
XCTSFLOW/RTSFLOW nor CLOCAL are set.
X.IP "" 6
XIn SCO UNIX 3.2.4.2 the meaning of CTSFLOW/RTSFLOW has changed.
XThese flags enable full duplex hardware flow control.
XFor backward compatibility there is the ORTSFL flag which
Xenables, when set together with CTSFLOW and/or RTSFLOW,
Xhalf duplex flow control.
XThese flags only work if CLOCAL is \fBnot\fP set.
X.SS "Half duplex mode"
XThere are actually three half duplex modes selected by
Xthe minor device number:
X.RS 3
X.IP "First mode" 3
XIf the RTSFLOW \fItermio\fP(M) flag is set and the CLOCAL flag
Xis \fBnot\fP set the \fBRTS\fP line is used to signal the connected
Xdevice that there is data in the output buffer.
XAs long as there is output data to come the \fBRTS\fP line stays high.
XIf the output buffer has drained \fBRTS\fP drops to low until there
Xis more data to be sent to the connected device.
X.IP "" 3
XIf the CTSFLOW \fItermio\fP(M) flag is set and the CLOCAL flag
Xis \fBnot\fP set the \fBCTS\fP line is used to control the
Xoutput character flow.
XThis works as in full duplex mode.
X.IP "" 3
XIf neither CTSFLOW nor RTSFLOW are set hardware flow control
Xis disabled.
XBut see the description of the CRTSFL/ORTSFL \fItermio\fP(M) flags
Xat the end of the section \fBFull duplex mode\fP.
X.RS 3
X.IP "Note:" 6
XSetting the CTSFLOW and RTSFLOW flags (and CRTSFL/ORTSFL,
Xif available) only applies to SCO UNIX and Xenix.
XTo my knowledge, other UNIX flavors don't have these flags.
XFor them, hardware flow control is always disabled in this mode.
X.RE
X.IP "Second mode" 3
XThis mode overrides the RTSFLOW, CTSFLOW, CRTSFL and ORTSFL
Xflags and works as if the CTSFLOW flag is set permanently
X(all UNIX flavors).
XThe CLOCAL flag doesn't affect this mode.
X.IP "Third mode" 3
XThis mode overrides the RTSFLOW, CTSFLOW, CRTSFL and ORTSFL flags
Xand works as if both the RTSFLOW and CTSFLOW flags (in SCO UNIX
Xprior to 3.2.4.2 and SCO Xenix) are set permanently
X(all UNIX flavors).
XThe CLOCAL flag doesn't affect this mode.
X.RE
X.IP "Note:" 6
XUnder SCO UNIX prior to 3.2.4.2 and Xenix the \fItermio\fP(M) RTSFLOW
Xflag is intended for half duplex hardware flow control devices.
XSetting it when the connected device does \fBfull\fP duplex
Xhardware flow control is a configuration error!
XThe \fBRTS\fP signalling for half duplex devices has a
Xcompletely different meaning than for full duplex devices.
XSo you should either set only CTSFLOW (or CRTSFL, if available),
Xor you should select hardware flow control via the
Xminor device number.
XIf you set RTSFLOW for full duplex hardware flow control
Xdevices it is likely that the port won't work.
XThis is in line with SCO's \fIsio\fP driver implementation.
X.SS "Direct control"
XOn UNIX flavors where the RTS_TOG \fIioctl\fP(2|S) command is
Xavailable the hardware handshake output (\fBRTS\fP by default)
Xcan be set under program control.
XAn \fIioctl\fP(2|S) argument of \fB0\fP sets the output to
Xlow and an argument of \fB1\fP sets it to high.
XHowever, this only works if the hardware handshake modes
Xas well as \fIVP/ix\fP DOS mode are disabled.
XIf one of these modes is enabled \fIFAS\fP needs the hardware
Xhandshake output for its own flow control.
X.LP
XOn the other hand, even if one of these modes is in use
Xand \fIFAS\fP gets an RTS_TOG command, the state of the
Xhandware handshake output that this command tries to set
Xis stored and the output is set to the state of the last
XRTS_TOG command as soon as both hardware handshake mode
Xand DOS mode are disabled.
X.LP
XIn other words, \fIFAS\fP doesn't ignore the RTS_TOG command
Xif hardware handshake modes or DOS mode are set but rather
Xoverrides the hardware handshake output with the appropriate
Xstate computed internally.
X.SH "\fIVP/ix\fP SUPPORT"
X\fIFAS\fP allows DOS programs running under \fIVP/ix\fP
Xto access serial ports.
XYou simply need to modify your personal \fIVP/ix\fP
Xconfiguration file (\fIvpix.cnf\fP) to tell the DOS emulator
Xwhich \fIFAS\fP devices to use for COM1
X(or COM1MOUSE) and COM2.
X.LP
XNote that \fIVP/ix\fP opens these devices at startup time,
Xso you better make sure that the desired devices aren't
Xused by other processes when you start \fIVP/ix\fP as
X\fIVP/ix\fP wants to use them exclusively.
X.LP
XThere are some special features with the handling of the
X\fBRTS\fP and \fBDTR\fP lines you should know about.
XIf your DOS program asserts the \fBDTR\fP line this will
Xactually cause action on the modem enable line you
Xconfigured in \fIspace.c\fP.
XLikewise, \fBRTS\fP asserts the half duplex hardware
Xhandshake line configured in \fIspace.c\fP.
X.LP
XIf the used \fIFAS\fP device has full duplex hardware handshake
Xenabled, asserting \fBRTS\fP from DOS actually stops the
Xcharacter flow from \fIFAS\fP to \fIVP/ix\fP.
XThis prevents input buffers of interrupt driven
XDOS programs from overflowing.
X\fIFAS\fP, on the other hand, uses its hardware handshake
Xto prevent an overflow of its own input buffer.
XTherefore, you can use DOS telecommunication programs
Xeven at high baud rates without losing characters,
Xprovided your DOS programs are configured to use
Xfull duplex \fBRTS\fP/\fBCTS\fP flow control.
X.LP
XAll this virtual handling has the advantage that
Xthe DOS program doesn't need to know certain details
Xabout your actual port setup.
XReading the modem status register, on the other hand,
Xdoesn't cause any translation of the register value.
X.LP
XTo enable \fIVP/ix\fP support, the HAVE_VPIX define
Xin \fIfas.h\fP has to be uncommented.
X.SH "MODIFYING A PORT'S DEFAULT BEHAVIOUR"
XThere are some flags that you can set in the \fIfas_modify\fP[]
Xarray (\fIspace.c\fP) for each port independently.
XYou have to relink the kernel before these
Xflags have any effect.
XHere is a description:
X.RS 3
X.IP "\fBNO_TEST\fP" 3
XIf for some reason a UART doesn't pass the functionallity
Xtest \fIFAS\fP makes at boot time you can override the test
Xresult and use this port, anyway.
XHowever, you do this on your own risk.
XDon't be surprised if ports get hung
Xor your machine crashes.
XI won't support \fIFAS\fP installations
Xwhere this flag is used.
XIt is intended as a last resort.
X.IP "" 3
XThere is one exception to this, though.
XIf the \fBNO_TEST\fP flag is already set in the sample
Xconfig files for certain serial cards and provided that
Xthese sample files are part of the original \fIFAS\fP
Xdistribution, you won't lose my support because in this
Xcase I've tested the respective product myself and decided
Xthat it is safe to use the \fBNO_TEST\fP flag with it.
X.IP "\fBNO_HUP_PROTECT\fP" 3
XNormally, with modem control enabled, after the carrier
Xis lost the carrier is ignored and assumed to be missing
Xeven if the physical carrier line is asserted again.
X.IP "" 3
XAdditionally, as the device can't accept a call in this
Xstate, anyway, the modem enable line is set to low so
Xthat the modem won't answer calls.
XThis prevents users from getting the shell of a
Xprevious user in case that the shell doesn't react
Xto SIGHUP for some reason.
XSo the modem port is dead until this
Xsituation is dealt with.
X.IP "" 3
XThis adds some security to modem ports.
XHowever, if this feature breaks one of your applications
Xfor some reason, just set \fBNO_HUP_PROTECT\fP and
Xthe hangup protection is disabled for this port.
X.IP "\fBNO_OVERRUN\fP" 3
XThe device has some sort of receiver overrun protection.
XFor instance, it may be used with certain internal modems
Xthat use a \fINS16x50\fP UART emulation and have their own
Xreceiver buffer.
XThis flag only affects the position of the device
Xin the interrupt users chain, that is, because the device
Xcan't overrun it is serviced only after all devices that
Xdon't have an overrun protection have been taken care of.
X.IP "\fBNEW_CTSRTS\fP" 3
XSome "intelligent" serial cards from third party vendors
Xhave the meaning of the RTSFLOW \fItermio\fP(M)
Xflag redefined.
XIt is used, together with CTSFLOW, to enable
Xfull duplex hardware flow control, whereas SCO
Xintroduced RTSFLOW for the more traditional half
Xduplex hardware flow control that is implemented
Xin their \fIsio\fP driver.
XBy default, \fIFAS\fP emulates the \fIsio\fP driver
Xfor compatibility reasons.
X.IP "" 3
XHowever, if you like to use CTSFLOW/RTSFLOW for
Xfull duplex hardware flow control in a way that
Xis compatible with the above mentioned "intelligent"
Xcards, you can do this by setting \fBNEW_CTSRTS\fP.
XAlso, CTSFLOW/RTSFLOW are no longer affected by
XCLOCAL if \fBNEW_CTSRTS\fP is set.
XIn this mode CTSFLOW enables the output flow control
Xand RTSFLOW enables the input flow control.
XBoth flags are independent from each other.
X.IP "" 3
XNote that under SCO UNIX 3.2.4.2 the
XCTSFLOW/RTSFLOW flags have changed their meaning in
Xthat they enable full duplex hardware flow control.
X.RE
X.LP
XThese flags are defined in \fIfas.h\fP.
XFor example, if you want to use the meaning
Xof RTSFLOW that is compatible to some of the
X"intelligent" serial cards you would write
X.nf
X.IP
XNEW_CTSRTS
X.fi
X.LP
Xat the appropriate position in \fIfas_modify\fP[].
XIf you additionally want to skip the test routine
Xfor this port you would write
X.nf
X.IP
XNO_TEST | NEW_CTSRTS
X.fi
X.SH "UART FIFO CONTROL"
XIn order to control the operating modes of UARTs that
Xhave built\-in FIFOs you can select the desired mode
Xfor each port independently by modifying the
X\fIfas_fifo_ctl\fP[] array (\fIspace.c\fP).
XYou have to relink the kernel before these
Xchanges have any effect.
XThere are a number of predefined, mutually exclusive
Xsymbols available:
X.RS 3
X.IP "\fBFIFO_DEFAULT\fP" 3
XAll UART types with FIFOs.
X.br
XThe FIFOs are enabled and in case that an \fINS16550A\fP
Xwas detected, the receiver FIFO trigger level is set to
X4 or 8 characters (depending on the UNIX flavour,
Xsee the description of LOW_INT_LAT in section
X\fBTROUBLE\-SHOOTING\fP, subsection \fBCharacter loss\fP).
X.IP "\fBFIFO_OFF\fP" 3
XAll UART types with FIFOs.
X.br
XThe FIFOs are disabled and the UART works in the
X\fINS16450\fP compatible mode.
X.IP "\fBFIFO_EMUL_NS16450\fP" 3
XAll UART types with FIFOs.
X.br
XThe FIFOs are enabled and in case that an \fINS16550A\fP
Xwas detected, the receiver FIFO trigger level is set to
X1 character.
XThe transmitter FIFO is filled with only 1 character
Xper transmitter interrupt.
XThis emulates the \fINS16450\fP UART and additionally gives
Xyou the overrun protection provided by the receiver FIFO.
X.IP "\fBFIFO_POINTER_DEV\fP" 3
X\fINS16550A\fP, only.
X.br
XThe FIFOs are enabled and the receiver FIFO trigger level
Xis set to 1 character.
XThis should be used for pointer devices like mice
Xor trackballs because it prevents the short receiver FIFO
Xtimeout delay that could lead to jerky pointer movement.
X.IP "\fBFIFO_TRIGGER_1\fP" 3
X\fINS16550A\fP, only.
X.br
XThe FIFOs are enabled and the receiver FIFO trigger level
Xis set to 1 character.
X.IP "\fBFIFO_TRIGGER_4\fP" 3
X\fINS16550A\fP, only.
X.br
XThe FIFOs are enabled and the receiver FIFO trigger level
Xis set to 4 characters.
X.IP "\fBFIFO_TRIGGER_8\fP" 3
X\fINS16550A\fP, only.
X.br
XThe FIFOs are enabled and the receiver FIFO trigger level
Xis set to 8 characters.
X.IP "\fBFIFO_TRIGGER_14\fP" 3
X\fINS16550A\fP, only.
X.br
XThe FIFOs are enabled and the receiver FIFO trigger level
Xis set to 14 characters.
X.RE
X.LP
XNote that you can set these values even if the respective
XUART doesn't have FIFOs, in which case they are ignored.
XIf you later upgrade to a UART with FIFOs the FIFO control
Xvalues automatically become active without having
Xto build a new kernel.
X.SH "SELECTING ALTERNATIVE BAUD RATES"
XThe UNIX \fItermio\fP(7|M) interface only supports
Xbaud rates of up to 38400 bps.
XHowever, with the advent of V32bis and faster modems with
Xcompression ratios of up to 4:1 (V.42bis) this
Xupper baud rate boundary isn't adequate anymore.
XBaud rates of 57600 or even 115200 are necessary to
Xmake full use of these modems.
X.LP
X\fIFAS\fP provides these high baud rates even though
Xthe \fItermio\fP(7|M) interface doesn't know them.
XTo make this work, \fIFAS\fP has one or more baud rate
Xtables in \fIspace.c\fP (\fIfas_baud\fP[][]) which
Xcontain the baud rate base and the 15 baud rates that
Xcorrespond to B50 to B38400.
XArbitrary baud rates can be assigned to these
Xbaud rate symbols.
XBaud rate table 0 by default contains the standard
Xbaud rates that coincide with the standard
X\fItermio\fP(7|M) baud rates.
XTable 1 contains the same values for the first
X13 baud rates.
XHowever, B19200 is assigned to a baudrate of 57600
Xand B38400 is assigned to 115200 bps.
XThese values are the default in the \fIFAS\fP distribution,
Xand you can change these tables to whatever values you need.
X.LP
XNote, however, that the baud rate base in this table has
Xto be dividable by all 15 baud rate values without remainder,
Xor at least with a very small remainder.
XOtherwise there would be a noticeable deviation between
Xthe requested and the actually used baud rate.
XIt helps a little that \fIFAS\fP rounds the result
Xof this division to minimize the deviation.
X.LP
XNote also that it isn't advisable to use the B50
Xand B75 symbols for 57600 and 115200 bps.
XThis has two reasons.
X.LP
XIn the worst case (SCO UNIX and Xenix) \fIFAS\fP transfers
Xthe characters between its ring buffers and the
XUNIX CLIST buffers only every 17 milliseconds.
XThis optimizes performance and reduces the CPU load.
XNow, there are certain baud rate dependent threshold
Xvalues that limit the number of characters the
XCLIST buffers can hold.
XThis is to reduce the drain time of the output buffers.
XSo, at low baud rates these thresholds are very low,
Xand because \fIFAS\fP transfers characters only
X60 times a second, the maximum throughput for
Xtransmitted characters is threshold * 60.
XOne can easily calculate that the threshold has to be
Xat least 192 characters for 115200 bps (11520 cps).
XA sufficient threshold is only provided
Xfor baud rates >= B9600.
X.LP
XBecause the threshold table in the UNIX kernel is a
Xglobal object that is also used by other drivers,
X\fIFAS\fP can't simply override these values.
XSo max. throughput is only possible with baud rate
Xtable positions of B9600 or better.
X.LP
XThe other reason not to use B50 etc. is that
Xprograms like \fIvi\fP and \fIemacs\fP make their
Xbehaviour dependent on the baud rate
Xof the tty they run on.
XAnd this behaviour clearly wouldn't fit baud
Xrates like 57600 and 115200.
X.LP
XTherefore, even if it looks tempting to use
Xbaud rate symbols that aren't in use anymore
Xtoday (like B50 and B75), just don't do it.
XIt won't work very well.
X.LP
XSo we have two or more baud rate tables in
X\fIspace.c\fP, one for the standard \fItermio\fP(7|M)
Xassignment and the others for non\-standard
Xbaud rates.
XYou can select which table to use for each port
Xby simply putting the table number in the
X\fIfas_bt_select\fP[] array in \fIspace.c\fP.
XProvided you use the default baud rate table values
Xyou would use a table selector value of \fB0\fP
Xfor ports that should have the standard \fItermio\fP(7|M)
Xbaud rate assignment, and a value of \fB1\fP to have
X57600 and 115200 bps available instead of 19200 and
X38400 bps.
X.IP "Note:" 6
XAt speeds of more than 38400 bps it is likely that
Xeven an \fINS16550A\fP will lose incoming characters
Xbecause in many UNIX flavors the worst case interrupt
Xlatency is rather high.
XIt has to be <= 1 ms or you are in trouble.
XThis problem is caused by the UNIX kernel design.
X\fIFAS\fP can't do anything about it.
XISC UNIX 3.0, for instance, on a 486/33 works
Xfine at this speed.
XOn the other hand, ISC UNIX 2.x can't handle it.
XYou may want to look at the description of LOW_INT_LAT
Xin section \fBTROUBLE\-SHOOTING\fP,
Xsubsection \fBCharacter loss\fP.
X.LP
XAdditionally to having higher baud rates available,
Xthis table based baud rate selection mechanism can
Xbe used to support serial cards that don't use the
Xstandard 1.8432 MHz oscillator frequency.
XFor instance, if you have a card that is equiped with
Xa 3.6864 MHz oscillator you would have the additional
Xbaud rates of 57600, 76800, 96000 and 115200 available
X(you shouldn't use more than 115200 because that loads
Xthe CPU too much).
XJust enter the baud rate base (3686400 / 16 = 230400)
Xand the 15 baud rates into one of the baud rate tables
Xin \fIfas_baud\fP[][] and select the respective
Xtable in \fIfas_bt_select\fP[].
X.LP
XNote that \fIVP/ix\fP programs which use serial
Xports will select wrong baud rates on ports that
Xare driven by a non\-standard oscillator, unless
Xthey know about the different oscillator frequency.
X.LP
XNote also that whatever baud rate is actually used,
Xthe UNIX application programs still know only the
Xstandard \fItermio\fP(7|M) baud rates.
XSo don't wonder if \fIstty\fP shows you 38400 bps
Xon a port that in fact runs at 115200 bps.
X\fIFAS\fP hides the real baud rate from the rest of
Xthe UNIX kernel and the application programs.
XThat's the only way these additional baud
Xrates can work at all.
X.SH "CABLING"
XCabling depends on the serial card and the
Xdevice that you want to connect.
X.SS "Connecting a modem"
XThe most common case is connecting a modem to a computer.
X"Dumb"\-port cards in an IBM\-AT compatible computer
Xusually act as a DTE device and have a male connector
Xwhile modems are DCE devices and have a female connector.
XSo all you need is an extension cable with a male connector
Xon one side and a female connector on the other side.
X.LP
XThe cable has to have wires for at least the signals
X\fBTD\fP, \fBRD\fP, \fBRTS\fP, \fBCTS\fP, \fBDSR\fP,
X\fBDCD\fP, \fBDTR\fP, \fBRI\fP and \fBGND\fP.
XOn a D\-Sub 25 RS232C connector these are the
Xpin numbers \fB2\fP, \fB3\fP, \fB4\fP, \fB5\fP, \fB6\fP,
X\fB8\fP, \fB20\fP, \fB22\fP and \fB7\fP,
Xrespectively, and the wireing scheme has to be
X"straight through", that is, none of the wires
Xare crossed.
XFor the cabling of less common devices please look
Xat the manuals for further details.
X.LP
XIn all cases, though, use shielded cables wherever
Xyou can, especially with high baud rates!
XShielded cables are better protected against
Xelectromagnetic interferences and therefore help
Xto prevent data corruption during transmission.
XAlso, make the cables as short as possible.
X.LP
XHowever, don't leave unused input lines
X(\fBCTS\fP, \fBDCD\fP, \fBDSR\fP, \fBRI\fP) open!
XDue to crosstalking from other lines these input
Xlines might change their logic level, resulting
Xin all sorts of problems (bad throughput,
Xblocked character output etc.).
XTherefore, you should connect any unused input line
Xto \fBGND\fP (pin \fB7\fP on the D\-Sub 25 RS232C connector).
X.LP
XAdditionally, you should use the proper operating
Xmode (via the minor device number) for your
Xapplication, for instance, if the connected
Xdevice doesn't have hardware flow control,
Xyou should use a mode where hardware flow
Xcontrol is disabled.
XThe same is true for modem control.
X.SS "Connecting two UNIX systems"
XIf you want to connect two UNIX systems (both using
X\fIFAS\fP) via a null modem cable, and if you want
Xto run a \fIgetty\fP on both ends you need to modify
Xthe \fIspace.c\fP file to prevent both \fIgetty\fPs from
Xchatting with each other, wasting valuable CPU time.
X.LP
XRemove the \fBEI_DTR\fP macro for the desired port from
Xthe initializer part of the \fIfas_modem\fP[] array.
XThis will cause \fBDTR\fP to be asserted only on dialout.
XTherefore, the \fIgetty\fP will become alive only if
Xa dialout on the other side is in progress.
X.LP
XAlso, replace the \fBHO_CTS_ON_DSR\fP macro in the
X\fIfas_flow\fP[] array with \fBHO_CTS\fP.
XThis will cause \fBCTS\fP to be used for hardware output
Xflow control regardless of the state of \fBDSR\fP.
X.LP
XThe required null modem cable needs to cross
X\fBTD\fP/\fBRD\fP, \fBRTS\fP/\fBCTS\fP and \fBDTR\fP/\fBDCD\fP.
XThe following diagram shows the wireing scheme for
XDTE D\-Sub 25 connectors on both sides.
X.nf
X.IP
XD\-Sub 25   System A                System B
X========   ========                ========
X    2        TD  \-\-\-\-\-\-\-\-\\ /\-\-\-\-\-\-\-\- TD
X                          X
X    3        RD  \-\-\-\-\-\-\-\-/ \\\-\-\-\-\-\-\-\- RD
X
X    4        RTS \-\-\-\-\-\-\-\-\\ /\-\-\-\-\-\-\-\- RTS
X                          X
X    5        CTS \-\-\-\-\-\-\-\-/ \\\-\-\-\-\-\-\-\- CTS
X
X   20        DTR \-\-\-\-\-\-\-\-\\ /\-\-\-\-\-\-\-\- DTR
X                          X
X    8        DCD \-\-\-\-\-\-\-\-/ \\\-\-\-\-\-\-\-\- DCD
X
X    6        DSR \-\-\\             /\-\- DSR
X                    >\-\\       /\-<
X   22        RI  \-\-/   \\     /   \\\-\- RI
X                        >\-\-\-<
X    7        GND \-\-\-\-\-\-/     \\\-\-\-\-\-\- GND
X.fi
X.LP
XNote that \fBDSR\fP and \fBRI\fP are directly connected
Xto \fBGND\fP on each side so that they can't catch
Xelectromagnetic interferences.
X.SS "Connecting a mouse"
XAnother caveat is connecting a mouse or some other
Xpointer device to an \fIFAS\fP port.
XThere are many mice on the market that don't handle the
Xmodem and hardware flow control lines in a proper way.
XTherefore, they should be connected to a port with a
Xminor device number of \fB0\fP + device #.
XThis disables any modem or hardware flow control and prevents
Xthe device from locking up under certain circumstances.
X.LP
XYou may also want to refer to the section \fBUART FIFO CONTROL\fP
Xif your mouse is connected to a port driven by a UART with FIFOs.
X.SH "MODEM SETUP"
X\fIFAS\fP has certain requirements for the
Xmodem setup that must be met in order to avoid
Xproblems during operation.
X.LP
XIf modem control should be used (carrier sensing
Xwith \fBDCD\fP and hangup control with \fBDTR\fP),
Xyou need to program the modem in the following way:
X.RS 3
X.LP
X\fBDTR\fP high\->low causes the modem to drop
Xthe connection (hangup) and resets the modem to
Xits power\-on default setup.
XAdditionally, when the modem is in answer mode (for
Xdialin) it shouldn't answer calls if \fBDTR\fP is low.
X.LP
X\fBDCD\fP is set high when there is a carrier
Xdetected or rather, to be precise, when the
Xconnection procedure between the two modems is
Xfinished and the modems are ready to transfer
Xuser data.
X\fBDCD\fP is dropped to low if the modem senses
Xthat the connection to the other modem is lost
X(e.g. no carrier).
X.RE
X.LP
XIf hardware flow control should be used (\fBCTS\fP
Xfor output direction and \fBRTS\fP for input
Xdirection), you need this setup:
X.RS 3
X.LP
X\fBRTS\fP signals to the modem whether the DTE
X(e.g. the computer) can accept data or not.
XHigh means the DTE can accept data while low
Xmeans that the modem should stop sending data
Xto the DTE.
X.LP
X\fBCTS\fP signals to the DTE whether the modem
Xcan accept data or not.
XHigh means the modem can accept data while low
Xmeans that the DTE should stop sending data.
X.LP
X\fBDSR\fP is always on.
XThis line acts as a gate for the \fBCTS\fP signal.
X\fIFAS\fP ignores \fBCTS\fP if \fBDSR\fP is low,
Xso \fBDSR\fP has to be always high to make sure that
X\fIFAS\fP always pays attention to \fBCTS\fP.
X.LP
XNote that the behaviour of \fBRTS\fP and \fBCTS\fP
X(as described above) is called bidirectional or
Xfull duplex hardware flow control.
XDon't select half duplex hardware flow control
Xwith modern highspeed modems!
X.RE
X.LP
XBy default, \fIFAS\fP uses both modem and hardware
Xflow control so you have to make sure that in your
Xmodem \fBDTR\fP, \fBDCD\fP, \fBRTS\fP, \fBCTS\fP and
X\fBDSR\fP work the way described above.
X.LP
XIf your modem can't handle modem and/or hardware
Xflow control you have to use a different minor
Xdevice number for this device that disables
Xthe respective feature.
XOtherwise lockups and malfunctions could occure.
XLook at section \fBOPERATING MODES AND MINOR DEVICE NUMBERS\fP
Xfor a description of possible operating
Xmodes (minor device numbers).
X.LP
XHere are a few additional hints for the modem setup:
X.RS 3
X.LP
XIf you program the modem to answer calls (dialin mode)
Xyou should make sure that the modem escape code character
Xwhich allows online access to the modem command mode is
Xdisabled.
XOtherwise, the escape code sequence typed in at the
Xremote side is echoed by the local computer and causes
Xthe local modem to switch to command mode as well.
XAt this stage, only a hangup will reactivate
Xthe modem port.
XModems with an AT command set disable the escape
Xcode with
X.nf
X.IP
XAT S2=128
X.fi
X.LP
XIf you want to dial in and out on the same modem port
Xthe modem's power\-on default setup should be tailored
Xfor dialin mode (incl. auto answer \fBenable\fP).
XWhen a dialout takes place the dialout application
Xprovides the necessary modem commands to switch the
Xmodem to dialout mode (incl. auto answer \fBdisable\fP)
Xand then does the actual dialout.
XAfter the dialout is finished \fIFAS\fP makes sure
Xthat \fBDTR\fP is dropped for a second which resets
Xthe modem to its power\-on defaults so that the modem
Xis in dialin mode, again.
X.RE
X.SH "TROUBLE\-SHOOTING"
XThere are a number of know problems that you might encounter
Xwhen you are using \fIFAS\fP.
XThey are usually caused either by a configuration error or
Xby limitations of the hard\- and software environment
X\fIFAS\fP has to work in.
X.SS "Character loss"
XA common problem with fast serial data transmission is
Xthat the receiving side occasionally drops characters.
XThe reason for this lies in the ancient UART
Xdevices used in many 286/386 systems:
Xthe \fI8250\fP (not supported by \fIFAS\fP) and
Xthe \fINS16450\fP.
X.LP
XThey have only one receiver character buffer.
XThis implies that the operating system must read
Xa character from this buffer before the next one
Xarrives from the UART's shift register.
XFor the old IBM PC with DOS this was sufficient.
XBut for UNIX and with baud rates as high as 115200
Xthis is just a bad joke.
X.LP
XUNIX is not a real\-time operating system.
XThis means that its kernel isn't optimized for
Xfast interrupt response.
XWith properly designed hardware that buffers data until
Xthe OS has time to fetch it this is no problem.
XBut since UNIX for PCs has to work with the
Xstandard hardware found in 286/386 systems,
Xserial driver developers have to cope with the
X\fINS16450\fP UARTs which are in there simply to
Xbe compatible with IBM PCs, XTs and ATs under DOS.
X.LP
XWith this hardware it is impossible to make it work
Xat high baud rates without a major redesign of the
XUSL supplied UNIX kernel.
XBut then it wouldn't be UNIX SYSV any more.
X.LP
XFortunately, there is a pin\-to\-pin replacement
Xavailable from National Semiconductors:
Xthe \fINS16550A\fP.
X.LP
XThis device has separate 16 character FIFOs
Xfor the receiver and the transmitter.
XWith these FIFOs the interrupt latency of
Xthe kernel can be quite high without losing
Xcharacters.
XAnd because with most interrupts several
Xcharacters are processed at once the
XCPU is loaded much less.
X.LP
XSo, as \fIFAS\fP supports \fINS16550A\fP UARTs, all
Xyou have to do to fix the character loss problem is
Xto either buy a serial card with \fINS16550A\fP chips
Xon it or replace the UARTs on the card that you
Xalready have.
X.LP
XIf for some reason you can't get the \fINS16550A\fP
Xchips you could use the \fIi82510\fP
Xchips from Intel.
XAlthough they are much less efficient they are
Xstill better than the \fINS16450\fP.
X.LP
XThere are, however, some conditions under which
Xeven the receiver FIFO in the \fINS16550A\fP UART
Xcan't prevent character loss:
X.RS 3
X.IP "Other kernel drivers" 3
XSome kernel drivers may disable interrupts for too long.
XOne culprit is the disk cache flush routine.
XIf you configure your kernel with too many
Xcache buffers (\fINBUF\fP parameter for USL
Xderived UNIX) you may still lose characters
X(at least at 38400 bps and above).
X.IP "" 3
XAnother candidate is \fIVP/ix\fP, or rather the
Xkernel functions to support \fIVP/ix\fP.
XThis may also lead to lost characters
Xat very high input speeds.
X.IP "Bus master controllers" 3
XThere are some bus master disk controllers
X(like the Adaptec 1540/1542 SCSI controller)
Xon the market that slow down the CPU so much
Xduring data transfer that it isn't fast
Xenough to process characters coming in
Xat high baud rates.
X.IP "" 3
XTherefore, if you can configure your disk
Xcontroller, don't use values that will bring
Xthe CPU down to its knees.
XOtherwise, \fIFAS\fP will lose incoming
Xcharacters during disk I/O.
X.RE
X.LP
XIf your operating system has a low interrupt
Xlatency you can define LOW_INT_LAT in the
X\fIMakefile\fP in order to set the receiver FIFO
Xtrigger level from 4 (default) to 8 characters.
XThis cuts the receiver interrupt frequency in half
Xand therefore saves a lot of CPU time.
XThat pays off especially at very high baud rates.
X.LP
XIf you set this flag you should do some rigid
Xtests (receiving characters at the highest baud
Xrate while the system is heavily loaded with disk
Xand network I/O) to make sure that there are really
Xno lost characters due to interrupt latency.
XISC UNIX 3.0 is known to have a low tty interrupt
Xlatency, therefore LOW_INT_LAT is defined in
X\fIMakefile.ISC3\fP.
XOn the other hand, ISC UNIX 2.x has a rather high
Xinterrupt latency and shouldn't have this flag set.
XFor other UNIX flavors you have to find out yourself
Xwhether this flag is applicable.
X.SS "Device lockups"
XThere are certain conditions under which a device
Xcan lock up, that is, at least one process that
Xuses this device waits for a tty I/O related event
Xthat apparently doesn't occure.
X.LP
XThe most common case is that there are still
Xcharacters in the output buffer, but the output
Xis disabled for some reason.
XThen the last process that closes the tty device
Xhangs in the \fIclose\fP(2|S) function until the
Xoutput buffer has drained.
X.LP
XTty output may be stopped by the software
X(XON/XOFF) or hardware (\fBRTS\fP/\fBCTS\fP,
Xby default) flow control.
XIn this case something seems to be wrong with
Xthe cabling or the connected device.
XPlease check this first out before you blame \fIFAS\fP.
XSometimes it helps to switch the device off and on a
Xfew times to unblock the tty output.
X.LP
XIf this doesn't help the last resort would be to
Xkill the process that hangs on the \fIFAS\fP device,
Xand if it still hangs, to open the respective device
Xwith the O_APPEND flag.
XThis flushes the output buffers and therefore
Xreleases the hanging process.
XTo do that, you simply type
X.nf
X.IP
Xecho '\\c' >> /dev/ttyF00
X.fi
X.LP
Xif, for instance, the process is hanging on \fBttyF00\fP.
XDon't omit the backslash before the \fBc\fP!
X.LP
XAnother reason for a blocked output could be a
Xlost transmitter interrupt.
XIf this isn't caused by a configuration error
Xthis usually indicates a hardware problem in
Xyour computer which should be fixed as
Xsoon as possible.
XOtherwise, you can't run this system unattended
Xbecause it is too unreliable.
XAll you can do after a transmitter interrupt is
Xlost is to reboot the machine in order to use the
Xblocked \fIFAS\fP device, again.
X.LP
XIf interrupts are lost on IRQ2 this might have
Xto do with an EGA or VGA video card using this
XIRQ line for the vertical retrace interrupt.
XThis interrupt isn't used at all these days,
Xneither under DOS nor UNIX.
XIt's simply there for compatibility.
X.LP
XOn some video cards (the more expensive ones)
Xthere is a jumper or dip switch to disable
Xthe vertical retrace interrupt.
XOn the rest you have to cut the trace to the
Xbus contact B4 with a sharp knife.
XThis contact is on the solder side of the
Xvideo card, the fourth bus contact counted
Xfrom the side where the 9 or 15 pin D\-SUB
Xconnector to the monitor is located.
XCutting this trace has the same effect as
Xpulling the IRQ2 jumper on other cards.
X.LP
XNote that cutting the trace will void
Xyour video card's warranty.
X.LP
XNow IRQ2 should be available for use with \fIFAS\fP.
XLook at the \fIINSTALLATION\fP file for details on
Xhow to configure \fIFAS\fP for IRQ2.
XThis is operating system dependent.
X.LP
XAnd there is a rare case which has to do with the
Xnumber of available CLIST buffers in the UNIX kernel.
XThe UNIX output and input buffers are 256 bytes
Xeach (by default).
XIf for some reason the output of a tty device is
Xstopped but a process continues to send data one
Xcharacter at a time this uses up one CLIST
Xbuffer for every charcacter.
XIf the number of CLIST buffers in the kernel is less
Xthan \fB256\fP all CLIST buffers will be busy eventually.
X.LP
XThe dangerous thing here is that the pool of CLIST
Xbuffers is used by all tty devices of the system.
XTherefore, if one single tty device manages to eat up
Xall available CLIST buffers all tty in\- and output
Xcomes to a halt.
XIf this happens you can't access your machine any
Xmore, not even from the operator console.
XAlthough the system is still alive internally.
X.LP
XUnfortunately, many UNIX vendors have put a negligently
Xlow number\-of\-CLIST\-buffers parameter into
Xtheir kernel tune files.
XYou should increase it to a value that makes it
Ximpossible that one device alone can occupy all
XCLIST buffers (it's the \fINCLIST\fP parameter
Xunder USL derived UNIX SVR[34].x).
XA value of \fB400\fP should be sufficient.
X.SS "Background processes and \fIgetty\fP problems"
XDue to the design of the SysV kernel there might
Xbe problems with \fIgetty\fP when the previous
Xdialup user on the respective port was using
Xbackground processes.
XUnfortunaley, \fIFAS\fP can't do much about it.
X.LP
XThe reason for these problems is that when a
Xdevice is held open by some process there can be
Xno \fIgetty\fP waiting for carrier on this device.
XNotice that we are talking about the \fBsame\fP logical
Xdevice for both the offending process and \fIgetty\fP.
XThis has nothing to do with the built\-in modem line
Xsharing for dialin and dialout.
X.LP
XThere are two problematic situations:
X.RS 3
X.IP "1." 3
X\fIgetty\fP has already blocked in the \fIopen\fP(2|S) function
Xand is waiting for the carrier.
XAnother process now opens the device with O_NDELAY.
XBecause the device is open after this there is no way
Xfor \fIgetty\fP to remain in the carrier waiting state.
XTherefore \fIgetty\fP is waked up and completes its
X\fIopen\fP(2|S) call as if the carrier were present.
XOf course, as the carrier isn't really there, subsequent
X\fIread\fP(2|S) and \fIwrite\fP(2|S) calls will return
Ximmediately with an EOF condition.
X\fIgetty\fP just exits in this case.
X.IP "2." 3
XA background process holds the device open when
X\fIgetty\fP is respawned by \fIinit\fP.
X\fIgetty\fP's \fIopen\fP(2|S) call succeedes immediately
Xbecause it can't block and wait for the carrier due to
Xthe device already being held open by the background process.
XAgain, subsequent \fIread\fP(2|S) and \fIwrite\fP(2|S) calls
Xreturn EOF (provided that the carrier is missing) and
X\fIgetty\fP exits.
X.RE
X.LP
XIn both cases \fIinit\fP will immediately respawn new
X\fIgetty\fPs and eventually gives up with a ``respawning
Xtoo rapidly'' message on the console.
XThis disables dialins on this port for at least a couple
Xof minutes.
X.LP
XIn this state you may notice that the \fBDTR\fP line is
Xlow although it should be high as the port is held open
Xby the background process.
XThis is caused by the \fIFAS\fP security feature that
Xprevents modems from accepting calls when the port
Xisn't ready for logins.
XThis can save frequently calling UUCP sites a
Xlot of money.
XHowever, the security feature only makes the symptoms
Xmore visible, but it isn't the cause of the
X\fIgetty\fP problems.
X.LP
XWhile the first case above happens rarely (usually
Xdue to a configuration error) the second case is
Xmore common.
XThe reason is that dialup users start background
Xprocesses and then log off or drop the line.
XIf the background process was started by a job
Xcontrol shell it runs in its own process group
Xand therefore doesn't receive the SIGHUP signal
Xsent by \fIFAS\fP on carrier loss.
XIt is the responsibility of the shell to notice
Xeither the SIGHUP or the EOF condition and to
Xthen kill its child (background) processes
Xbefore exiting.
XUnfortunately, not all job control shells
Xdo this reliably.
X.LP
XAnother problem is that under some UNIX flavors
Xthe \fIcsh\fP automatically disables SIGHUP
Xfor all background processes it starts.
XSo these processes have no chance to terminate
Xwhen the carrier drops.
X.LP
XWhatever causes the background processes to survive
Xthe logoff or carrier drop, it causes massive problems
Xwith \fIgetty\fP as described above.
XIf you see these effects on your machine, and it
Xcan't be cured by using a better (in this respect)
Xshell, your only option is to convince your dialup
Xusers to either not use any background processes or
Xto redirect \fBstdin\fP, \fBstdout\fP and \fBstderr\fP
Xto some files so that the processes don't hold the
Xdevice open.
XIf you or your users can't live without background
Xprocesses on dialup lines you may want to install the
X\fIscreen\fP virtual tty multiplexer which allows
Xseveral independent screens to run programs even while
Xyou are logged off.
X\fIscreen\fP or \fIiscreen\fP should be available
Xon every GNU archive server.
X.SS "Crashes or video problems at boot time"
XSeveral vendors of video cards with the S3 chip set
X(maybe with other chip sets as well) were stupid enough
Xto use the I/O address \fB0x2e8\fP for their own purpose.
XThis address, however, has been used, at least inofficially,
Xfor the COM4 port since the days the IBM AT came out.
X.LP
XSo what happens if you have such a video card in your
Xcomputer together with an enabled COM4 port is that
X\fIFAS\fP writes to the port at boot time (in order to detect
Xit) and actually writes to the video card as well,
Xbecause of the overlayed I/O addresses.
XThis confuses the video card so that, for instance, the
Xscreen gets dark, or it even manages to crash the system.
X.LP
XThe only thing you can do in this situation is to physically
Xdisable the COM4 port (usually by some DIP switch or jumper)
Xand to tell \fIFAS\fP (via its config files) not to use COM4.
X.SH "FILES"
X.IP "\fI/dev/ttyF??\fP" 3
XDialout device with modem and hardware flow control (by default).
X.IP "\fI/dev/ttyFM??\fP" 3
XDialin device with modem and hardware flow control (by default).
X.SH "SEE ALSO"
X\fItermio\fP(7|M),
X\fIsignal\fP(2|S),
X\fIopen\fP(2|S),
X\fIclose\fP(2|S),
X\fIread\fP(2|S),
X\fIwrite\fP(2|S),
X\fIfcntl\fP(2|S),
X\fIioctl\fP(2|S),
X\fIgetty\fP(1M|M),
X\fIcu\fP(1C|C),
X\fIuucico\fP(1M|C)
X.SH "BUGS"
X\fIFAS\fP is not yet ported to SVR4 STREAMS and therefore
Xits functionality is limited under SVR4.
X.LP
XDosMerge's virtual COM ports are unsupported.
X.SH "COPYRIGHT"
XCopyright (C) 1990\-1993 Uwe Doering
X.br
XSee the file \fICOPYING\fP (distributed with the source code)
Xfor distribution rights and restrictions associated with
Xthis software.
SHAR_EOF
echo 'File fas.7 is complete' &&
true || echo 'restore of fas.7 failed'
rm -f _shar_wnt_.tmp
fi
# ============= fas.7.cat ==============
if test -f 'fas.7.cat' -a X"$1" != X"-c"; then
	echo 'x - skipping fas.7.cat (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting fas.7.cat (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'fas.7.cat' &&
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X	  NAME
X	       fas - asynchronous serial character device driver
X
X	  DESCRIPTION
X	       _F_A_S, which is an	acronym	for _Final _Async	_Solution, is a
X	       "dumb"-port character device driver for 286/386 based UNIX
X	       systems that adds several features that are often not pro-
X	       vided by	vendors	drivers.
X
X	       It supports
X
X		  -  the _N_S_1_6_4_5_0 and _u_m_8_2_4_5_0 UART chips.
X		  -  the _N_S_1_6_5_5_0_A and _i_8_2_5_1_0 UART chips	in FIFO	mode.
X		  -  up	to 115200 bps with _N_S_1_6_5_5_0_A.
X		  -  built-in modem line sharing for dialin and	dialout.
X		  -  modem control on both dialin and dialout devices.
X		  -  full and half duplex hardware flow	control.
X		  -  concurrent	hardware and software (XON/XOFF) flow control.
X		  -  shared interrupts.
X		  -  multiplexed UART registers	(_H_U_B-_6 card etc.).
X		  -  any mix of	up to 16 UARTs.
X		  -  any I/O address, any IRQ.
X		  -  _V_P/_i_x, the	ISC DOS	emulator.
X
X	       _F_A_S was successfully tested under the following operating
X	       systems:
X
X		  ISC UNIX 2.0.2 and later
X		  SCO UNIX 3.2.2 and later
X		  SCO XENIX 286	2.3.2 and later
X		  SCO XENIX 386	2.3.2 and later
X		  Microport SVR3.0
X		  ESIX SVR3.2 Rev. C & D
X		  Bell Tech/Intel SVR3.2
X		  AT&T SVR3.2 V	2.1
X		  SVR4.0 (with tty compatibility drivers)
X
X	       This driver should work with most of the	UNIX SVR[34].x fla-
X	       vors currently available.  You can have both this and the
X	       original	vendor driver in the same kernel (if you really
X	       like to,	but I wouldn't know why).  Each	driver controls	its
X	       own separate set	of serial ports.  The only restriction here
X	       is that each interrupt vector must not be used by more than
X	       one of the drivers.  The	kernel config program will complain
X	       otherwise.
X
X	  WHICH	SERIAL CARDS ARE SUPPORTED ?
X	       _F_A_S supports and	has been tested	on many	async serial
X	       "dumb"-port cards.  It can handle most combinations of
X	       shared interrupts.  The current version can be used with
X	       _N_S_1_6_4_5_0,	_N_S_1_6_5_5_0_A, _u_m_8_2_4_5_0 and _i_8_2_5_1_0 UARTs.  _8_2_5_0 chips	are
X	       not supported due to various bugs and speed problems in
X	       these parts.  They have no place	in any 286/386 or other
X
X
X	  Rev. Release 2.11.0					     Page 1
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X	       high performance	system.	 Replace them with one of the sup-
X	       ported chips.  They are pin-to-pin compatible.
X
X	       IMPORTANT: Don't	use _N_S_1_6_5_5_0 (without the trailing AAAA) or	any
X			  chips	from a second source manufacturer!  They
X			  have a reputation of being buggy and might not
X			  work with _F_A_S.  Some aren't even recognized by
X			  the FIFO auto-detect code in _F_A_S.  The quality of
X			  the second source chips might	have improved
X			  lately but there is no way to	know for sure.
X			  Therefore, even if they are cheaper, don't buy
X			  them.
X
X	       Take a look at the _s_p_a_c_e-* files	for details on how to set
X	       up for various devices.	Sample config files are	provided
X	       for the following cards:
X
X		  *-_a_s_t_4_c_1_2   _A_S_T 4-port card plus COM1	and COM2
X		  *-_a_s_t_8_c_1_2   Two _A_S_T 4-port cards plus	COM1 and COM2
X		  *-_c_1_2_3      COM1, COM2 and COM3
X		  *-_g_e_n_8_c_1_2   Generic 8-port card plus COM1 and	COM2 (you can
X			      use these	files for the _D_i_g_i_C_h_a_n_n_e_l _P_C/_8,
X			      _A_P_T _H_S_S_0_8, _H_o_s_t_e_s_s, _B_o_c_a and _A_r_n_e_t 8-port	cards)
X		  *-_h_u_b_6_c_1_2   _B_e_l_l _T_e_c_h	_H_U_B-_6 card plus	COM1 and COM2
X		  *-_u_s_e_4_c_1_2   _U_S_E_N_E_T _I_I	4-port card plus COM1 and COM2
X
X	       Internal	modems are also	supported.  Some of them, however,
X	       use a UART emulation instead of a genuine UART chip.  These
X	       types of	internal modems	usually	don't pass the UART test at
X	       boot time.  Therefore, you may want to set the NNNNOOOO____TTTTEEEESSSSTTTT flag
X	       in the _f_a_s__m_o_d_i_f_y[] array (_s_p_a_c_e._c) to skip the UART test.
X	       On the other hand, most of the internal modems with a UART
X	       emulation have a	receiver overrun protection so that charac-
X	       ters can't be lost at high baud rates.  For these modems, it
X	       is advisable to set the NNNNOOOO____OOOOVVVVEEEERRRRRRRRUUUUNNNN flag in the _f_a_s__m_o_d_i_f_y[]
X	       array (_s_p_a_c_e._c).	 If an internal	modem with overrun protec-
X	       tion emulates an	_N_S_1_6_5_5_0_A UART, you should additionally use
X	       the FFFFIIIIFFFFOOOO____TTTTRRRRIIIIGGGGGGGGEEEERRRR____11114444 symbol in the _f_a_s__f_i_f_o__c_t_l[]	array
X	       (_s_p_a_c_e._c).  This	sets the receiver FIFO size to the highest
X	       possible	trigger	level in order to reduce the interrupt fre-
X	       quency.	Please refer to	the sections MMMMOOOODDDDIIIIFFFFYYYYIIIINNNNGGGG AAAA PPPPOOOORRRRTTTT''''SSSS
X	       DDDDEEEEFFFFAAAAUUUULLLLTTTT BBBBEEEEHHHHAAAAVVVVIIIIOOOOUUUURRRR and UUUUAAAARRRRTTTT FFFFIIIIFFFFOOOO CCCCOOOONNNNTTTTRRRROOOOLLLL for further details.
X
X	       There are serial	cards on the market that emulate an
X	       _N_S_1_6_5_5_0_A	UART and have receiver overrun protection due to an
X	       additional character buffer.  They look like an ordinary	COM
X	       port from the software side but have their own CPU, RAM,	ROM
X	       etc. on-board.  The special considerations for internal
X	       modems pointed out above	apply to these serial cards as
X	       well.  One example is the _Q_u_e_u_e_C_O_M-_1_1_5 card for which you
X	       should set the NNNNOOOO____TTTTEEEESSSSTTTT and NNNNOOOO____OOOOVVVVEEEERRRRRRRRUUUUNNNN flags and use the
X	       FFFFIIIIFFFFOOOO____TTTTRRRRIIIIGGGGGGGGEEEERRRR____11114444 symbol.
X
X
X
X	  Rev. Release 2.11.0					     Page 2
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X	  BOOT TIME STATUS MESSAGE
X	       At boot time you	will see a status message on the screen
X	       with symbols that show the init state of	each port.  The
X	       symbols are as follows:
X
X		  ----	not defined in the _f_a_s__p_o_r_t[] array
X		  ????	can't initialize port
X		  1111-9999	error during UART test phase indicated by number
X		  !!!!	configuration error (check _s_p_a_c_e._c and _f_a_s._h)
X		  ****	port is	initialized (_N_S_1_6_4_5_0)
X		  ++++	port is	initialized and	has FIFOs forced off
X		  ffff	port is	initialized and	has FIFOs (_i_8_2_5_1_0)
X		  FFFF	port is	initialized and	has FIFOs (_N_S_1_6_5_5_0_A)
X
X	       This is convenient to check whether you have entered the
X	       proper port base	addresses in _s_p_a_c_e._c.
X
X	  SHARED INTERRUPTS
X	       Many multi-port cards have jumpers or dip switches that let
X	       you assign more than one	port to	the same interrupt (IRQ)
X	       line.  This alone is nnnnoooo guaranty	that they really support
X	       shared interrupts!  These cards may be designed for the DOS
X	       world where you may want	two or more serial ports but don't
X	       need to run them	concurrently, that is, no more than one	of
X	       those ports assigned to the same	IRQ line is allowed to be
X	       in use at a time.  For DOS this is sufficient as	DOS is no
X	       multitasking operating system.  For UNIX	this won't work
X	       because in the worst case all serial ports may be in use	at
X	       the same	time.
X
X	       The basic problem is that the PC	(and AT) I/O bus can't han-
X	       dle shared interrupts itself.  This is due to a brain-dead
X	       hardware	design.	 Therefore, there must be some special
X	       logic on	the serial card	to provide shared interrupts.  And
X	       those cards are quite rare (and usually more expensive).
X
X	       Therefore, you have the choice to give every port on the
X	       card its	own IRQ	line or	to buy a multi-port card that
X	       really has shared interrupts.  But in the latter	case you
X	       better ask your vendor twice to make sure that it has this
X	       functionality because from the card's manuals it	often isn't
X	       obvious which type of card it is.  One well-known shared
X	       interrupts card is the _A_S_T 4-port card.	There are many com-
X	       patible clones available	that are usually much cheaper than
X	       the original.  You can even buy _A_S_T compatible 8-port cards
X	       where two _A_S_T 4-port blocks are on the same board.
X
X	  DIALIN/DIALOUT ON THE	SAME PORT
X	       This driver supports shared line	usage by having	two logical
X	       devices sharing one physical device.  Each logical device
X	       has its own name.
X
X	       For example, for	the first port the names are ttttttttyyyyFFFF00000000 (minor
X
X
X	  Rev. Release 2.11.0					     Page 3
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X	       device 0000) and ttttttttyyyyFFFFMMMM00000000 (minor device 111199992222).  The ttttttttyyyyFFFF00000000 device
X	       is used for _c_u, _k_e_r_m_i_t, _u_u_c_i_c_o and other	programs that want
X	       to dial out.  It	ignores	the modem signals and therefore
X	       doesn't care about whether the modem provides the carrier
X	       detect signal or	not.  The ttttttttyyyyFFFFMMMM00000000 device, on the other
X	       hand, is	strictly for dialin processes, usually _g_e_t_t_y.
X
X	       When _g_e_t_t_y opens	ttttttttyyyyFFFFMMMM00000000	the driver blocks the _o_p_e_n(2|S)
X	       call until the modem asserts the	carrier	detect signal and
X	       then lets the open complete.  If	_c_u opens ttttttttyyyyFFFF00000000	while _g_e_t_t_y
X	       is waiting for its own open to complete the device is given
X	       to _c_u and the _g_e_t_t_y open	must wait for _c_u to finish and will
X	       then wait for the carrier, again.
X
X	       If _c_u tries to open the ttttttttyyyyFFFF00000000 device while _g_e_t_t_y has
X	       ttttttttyyyyFFFFMMMM00000000 open _c_u will get	an EBUSY error.	 If _g_e_t_t_y tries	to
X	       open ttttttttyyyyFFFFMMMM00000000 while _c_u has ttttttttyyyyFFFF00000000	open the _g_e_t_t_y open will
X	       just block and wait for _c_u to close the device and will then
X	       wait for	the carrier.
X
X	       So in short, you	should put up a	_g_e_t_t_y on ttttttttyyyyFFFFMMMM00000000 with a
X	       `-t 60' and use ttttttttyyyyFFFF00000000 for _c_u, _u_u_c_i_c_o and other dialout pro-
X	       grams.
X
X	       Note: In	the description	above the rrrreeeeaaaallll _g_e_t_t_y is	meant.
X		     With _F_A_S you don't	need hacks like	_u_u_g_e_t_t_y	to dial	in
X		     and out on	the same port.
X
X	  OPERATING MODES AND MINOR DEVICE NUMBERS
X	       In the example in the previous section ttttttttyyyyFFFF00000000 had a minor
X	       device number of	0000 and ttttttttyyyyFFFFMMMM00000000 one of 111199992222.  But there are
X	       several other possible minor device numbers for each port.
X
X	       The higher four bits of the 8-bit minor device number con-
X	       trol the	operating mode of the device.  A physical device
X	       can't be	opened with two	or more	different minor	device
X	       numbers at the same time.
X
X	       Minor device numbers are	built according	to the following
X	       description:
X
X		  Bitmap:   _m _m	_f _f _x _x	_x _x
X
X		  _m _m are the mode bits	as follows:
X
X		  0 0	This is	a dialout device.  The carrier signal is
X			totally	ignored.  With carrier high->low nnnnoooo SIGHUP
X			signal is generated.  The device does nnnnooootttt block	on
X			open if	there is no carrier.
X
X		  0 1	This is	a dialout device.  After an initial open,
X			the actual carrier is ignored and is assumed to	be
X			present.  However, as soon as there is a low->high
X
X
X	  Rev. Release 2.11.0					     Page 4
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X			carrier	transition, this device	switches to carrier
X			controlled behaviour until the last process has
X			closed the device.  This includes sending a SIGHUP
X			signal on carrier loss.
X
X			Note that after	a carrier loss an _i_o_c_t_l(2|S) call
X			with a TCSETA* command that sets and again clears
X			the CLOCAL flag	resets the device to ignore the
X			actual carrier again and to assume that	it is
X			present	until the next carrier low->high.  Then	the
X			device switches	to the carrier controlled mode,
X			again.	Without	this command sequence the device
X			would ignore the actual	carrier	and assume that	it
X			is missing after the first carrier loss.
X
X			Additionally, after the	carrier	loss, as long as
X			the carrier is ignored and assumed to be missing,
X			the modem enable output	is held	low to prevent the
X			modem from answering calls.  The device	does nnnnooootttt
X			block on open if there is no carrier.
X
X		  1 0	This is	a dialin device.  It is	carrier	controlled
X			and blocks on open if there is no carrier.
X
X			Note that after	a carrier loss an _i_o_c_t_l(2|S) call
X			with a TCSETA* command that sets and again clears
X			the CLOCAL flag	reactivates the	device if there	is
X			a carrier present at this time.	 Without this com-
X			mand sequence the device would ignore the actual
X			carrier	and assume that	it is missing after the
X			first carrier loss.
X
X			Additionally, after the	carrier	loss, as long as
X			the carrier is ignored and assumed to be missing,
X			the modem enable output	is held	low to prevent the
X			modem from answering calls.
X
X		  1 1	This is	a dialin device.  Same as mode `1 0', but a
X			parallel non-blocking dialout open is possible
X			while waiting for carrier.
X
X		  _f _f are the hardware flow control bits as follows:
X
X		  0 0	The RTSFLOW, CTSFLOW, CRTSFL and ORTSFL	_t_e_r_m_i_o(M)
X			flags (if available) enable half duplex	(for output
X			direction, only) or full duplex	(for input and out-
X			put direction) hardware	flow control according to
X			SCO's specifications.  If these	flags are not
X			available no hardware flow control is used by this
X			device.
X
X		  0 1	The device uses	full duplex hardware flow control
X			(for input and output direction).
X
X
X	  Rev. Release 2.11.0					     Page 5
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X		  1 0	The device uses	half duplex hardware flow control
X			(for output direction, only).
X
X		  1 1	Same as	mode `1	0', but	additionally the output
X			buffer state is	signaled to the	connected device.
X
X		  Refer	to the _s_p_a_c_e._c and _f_a_s._h files to determine which
X		  port signals are actually used for modem and hardware
X		  flow control.
X
X		  _x _x _x	_x
X			This is	the physical device number.  _F_A_S supports
X			up to 16 ports.	 If you	need more, you should use
X			an "intelligent" serial	card because more than 16
X			devices	will eat up too	much CPU time with this
X			"dumb"-port approach.
X
X			In a configuration with	_n UARTs	the valid device
X			number range would be 0	to _n-1.	 The device number
X			is an index into the _f_a_s__p_o_r_t[]	etc. arrays in
X			_s_p_a_c_e._c.  Trying to open an unconfigured and there-
X			fore invalid device gives an ENXIO error.
X
X	       Note: If	a device is carrier controlled,	this implies the
X		     generation	of a SIGHUP signal with	every carrier
X		     high->low.	 This is of course only	true if	the CLOCAL
X		     flag is nnnnooootttt set.
X
X		     On	my own system I	prefer a minor device number of
X		     0000111100001111xxxxxxxxxxxxxxxx (88880000 + device #) for the non-blocking tty
X		     nodes and 1111111100001111xxxxxxxxxxxxxxxx	(222200008888 + device #) for the blocking
X		     tty nodes.	 This gives me the SIGHUP signal on carrier
X		     loss and full duplex hardware flow	control	on both
X		     logical devices.  Dialout while a dialin open is wait-
X		     ing for the carrier is also possible with this setup.
X		     These numbers are the defaults in the _n__f_a_s-* sample
X		     files.
X
X	  HARDWARE FLOW	CONTROL
X	       _F_A_S supports both full and half duplex hardware flow con-
X	       trol, using the RS232C RRRRTTTTSSSS/CCCCTTTTSSSS control lines (by	default).
X
X	       Full duplex flow	control	is a method to control character
X	       flow in both input and output directions	while in half
X	       duplex flow control mode	only the output	direction is con-
X	       trolled.
X
X	       You can select between full and half duplex flow	control	via
X	       the minor device	number of the device.  In full duplex mode
X	       the RRRRTTTTSSSS line controls the input direction and the CCCCTTTTSSSS line
X	       is responsible for the output direction.	 In half duplex
X	       mode RRRRTTTTSSSS	tells the connected device whether there is data in
X	       the output buffer (optional), and the CCCCTTTTSSSS line has the same
X
X
X	  Rev. Release 2.11.0					     Page 6
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X	       function	as in full duplex mode.
X
X	     Full duplex mode
X	       As long as the _F_A_S input	buffer hasn't reached a	certain
X	       threshold the RRRRTTTTSSSS line is set high to signal the	connected
X	       device that it may send characters.  If the input buffer
X	       level rises beyond this threshold RRRRTTTTSSSS will go low and the
X	       device is supposed to stop sending characters.  As soon as
X	       there is	sufficient space in the	input buffer RRRRTTTTSSSS will go
X	       high again and the character flow may continue.
X
X	       The CCCCTTTTSSSS line works the other way	round.	If the connected
X	       device sets CCCCTTTTSSSS to high the _F_A_S character output	is enabled.
X	       If CCCCTTTTSSSS is low, the output is stopped.  There is a special
X	       feature for the CCCCTTTTSSSS part	of the handshake.  CCCCTTTTSSSS is only
X	       looked at if the	DDDDSSSSRRRR line is high.  If DDDDSSSSRRRR is low or not
X	       connected, hardware output handshake is disabled, that is,
X	       _F_A_S sends characters regardless of the state of CCCCTTTTSSSS.
X
X	       This has	two advantages.	 At first, if you switch off a
X	       serial device connected to an _F_A_S port with hardware flow
SHAR_EOF
true || echo 'restore of fas.7.cat failed'
fi
echo 'End of  part 3'
echo 'File fas.7.cat is continued in part 4'
echo 4 > _shar_seq_.tmp
exit 0
