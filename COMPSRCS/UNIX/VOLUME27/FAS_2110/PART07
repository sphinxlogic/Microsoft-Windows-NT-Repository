Newsgroups: comp.sources.unix
From: fas@geminix.in-berlin.de (FAS Support Account)
Subject: REPOST v27i072: FAS-2.11.0 - asynch serial driver for System V, Part07/08
References: <1.750471074.20539@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: fas@geminix.in-berlin.de (FAS Support Account)
Posting-Number: Volume 27, Issue 72
Archive-Name: fas-2.11.0/part07

#!/bin/sh
# this is fas211pl0.07 (part 7 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file fas.h continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 7; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping fas.h'
else
echo 'x - continuing file fas.h'
sed 's/^X//' << 'SHAR_EOF' >> 'fas.h' &&
X	uint	flow_flags;	/* flags about the flow control state */
X	uint	event_flags;	/* flags about scheduled events */
X	uint	o_state;	/* current open state */
X	uint	po_state;	/* previous open state */
X	uint	iflag;		/* current terminal input flags */
X	uint	cflag;		/* current terminal hardware control flags */
X	union {			/* modem control masks */
X		struct {
X			unchar	di;	/* mask for modem disable */
X			unchar	eo;	/* mask for modem enable (dialout) */
X			unchar	ei;	/* mask for modem enable (dialin) */
X			unchar	ca;	/* mask for carrier detect */
X		} m;
X		ulong	l;
X	} modem;
X	union {			/* hardware flow control masks */
X		struct {
X			unchar	ic;	/* control mask for inp. flow ctrl */
X			unchar	oc;	/* control mask for outp. flow ctrl */
X			unchar	oe;	/* enable mask for outp. flow ctrl */
X			unchar	hc;	/* control mask for hdx flow ctrl */
X		} m;
X		ulong	l;
X	} flow;
X	union {			/* muliplexer control port */
X		uint	addr;
X		struct {
X			ushort	addr;
X			unchar	val1;
X			unchar	val2;
X		} p;
X	} ctl_port;
X	union {			/* uart port addresses and control values */
X		uint	addr;
X		struct {
X			ushort	addr;
X			unchar	ctl;
X			unchar	val;
X		} p;
X	} port [NUM_UART_REGS];
X	int	timeout_idx;	/* timeout index for untimeout () */
X	uint	rxfer_timeout;	/* timeout counter for recv char transfer */
X	unchar	start_char;	/* start character for software flow control */
X	unchar	stop_char;	/* stop character for software flow control */
X#if defined (HAVE_VPIX)
X	unchar	v86_intmask;	/* VP/ix pseudorupt mask */
X	v86_t	*v86_proc;	/* VP/ix v86proc pointer for pseudorupts */
X#endif
X	uint	recv_ring_cnt;	/* receiver ring buffer counter */
X	unchar	*recv_ring_put_ptr;	/* recv ring buf put ptr */
X	unchar	*recv_ring_take_ptr;	/* recv ring buf take ptr */
X	uint	xmit_fifo_size;	/* transmitter FIFO size */
X	uint	xmit_ring_size;	/* transmitter ring buffer size */
X	uint	xmit_ring_cnt;	/* transmitter ring buffer counter */
X	unchar	*xmit_ring_put_ptr;	/* xmit ring buf put ptr */
X	unchar	*xmit_ring_take_ptr;	/* xmit ring buf take ptr */
X	unchar	recv_buffer [RECV_BUFF_SIZE];	/* recv ring buf */
X	unchar	xmit_buffer [XMIT_BUFF_SIZE];	/* xmit ring buf */
X};
SHAR_EOF
echo 'File fas.h is complete' &&
true || echo 'restore of fas.h failed'
rm -f _shar_wnt_.tmp
fi
# ============= i_fas-ast4c12 ==============
if test -f 'i_fas-ast4c12' -a X"$1" != X"-c"; then
	echo 'x - skipping i_fas-ast4c12 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting i_fas-ast4c12 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'i_fas-ast4c12' &&
XF0:23:off:/etc/getty -t 60 ttyFM00 9600
XF1:23:off:/etc/getty -t 60 ttyFM01 9600
XF2:23:off:/etc/getty -t 60 ttyFM02 9600
XF3:23:off:/etc/getty -t 60 ttyFM03 9600
XF4:23:off:/etc/getty -t 60 ttyFM04 9600
XF5:23:off:/etc/getty -t 60 ttyFM05 9600
SHAR_EOF
true || echo 'restore of i_fas-ast4c12 failed'
rm -f _shar_wnt_.tmp
fi
# ============= i_fas-ast8c12 ==============
if test -f 'i_fas-ast8c12' -a X"$1" != X"-c"; then
	echo 'x - skipping i_fas-ast8c12 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting i_fas-ast8c12 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'i_fas-ast8c12' &&
XF0:23:off:/etc/getty -t 60 ttyFM00 9600
XF1:23:off:/etc/getty -t 60 ttyFM01 9600
XF2:23:off:/etc/getty -t 60 ttyFM02 9600
XF3:23:off:/etc/getty -t 60 ttyFM03 9600
XF4:23:off:/etc/getty -t 60 ttyFM04 9600
XF5:23:off:/etc/getty -t 60 ttyFM05 9600
XF6:23:off:/etc/getty -t 60 ttyFM06 9600
XF7:23:off:/etc/getty -t 60 ttyFM07 9600
XF8:23:off:/etc/getty -t 60 ttyFM08 9600
XF9:23:off:/etc/getty -t 60 ttyFM09 9600
SHAR_EOF
true || echo 'restore of i_fas-ast8c12 failed'
rm -f _shar_wnt_.tmp
fi
# ============= i_fas-c123 ==============
if test -f 'i_fas-c123' -a X"$1" != X"-c"; then
	echo 'x - skipping i_fas-c123 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting i_fas-c123 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'i_fas-c123' &&
XF0:23:off:/etc/getty -t 60 ttyFM00 9600
XF1:23:off:/etc/getty -t 60 ttyFM01 9600
XF2:23:off:/etc/getty -t 60 ttyFM02 9600
SHAR_EOF
true || echo 'restore of i_fas-c123 failed'
rm -f _shar_wnt_.tmp
fi
# ============= i_fas-gen8c12 ==============
if test -f 'i_fas-gen8c12' -a X"$1" != X"-c"; then
	echo 'x - skipping i_fas-gen8c12 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting i_fas-gen8c12 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'i_fas-gen8c12' &&
XF0:23:off:/etc/getty -t 60 ttyFM00 9600
XF1:23:off:/etc/getty -t 60 ttyFM01 9600
XF2:23:off:/etc/getty -t 60 ttyFM02 9600
XF3:23:off:/etc/getty -t 60 ttyFM03 9600
XF4:23:off:/etc/getty -t 60 ttyFM04 9600
XF5:23:off:/etc/getty -t 60 ttyFM05 9600
XF6:23:off:/etc/getty -t 60 ttyFM06 9600
XF7:23:off:/etc/getty -t 60 ttyFM07 9600
XF8:23:off:/etc/getty -t 60 ttyFM08 9600
XF9:23:off:/etc/getty -t 60 ttyFM09 9600
SHAR_EOF
true || echo 'restore of i_fas-gen8c12 failed'
rm -f _shar_wnt_.tmp
fi
# ============= i_fas-hub6c12 ==============
if test -f 'i_fas-hub6c12' -a X"$1" != X"-c"; then
	echo 'x - skipping i_fas-hub6c12 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting i_fas-hub6c12 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'i_fas-hub6c12' &&
XF0:23:off:/etc/getty -t 60 ttyFM00 9600
XF1:23:off:/etc/getty -t 60 ttyFM01 9600
XF2:23:off:/etc/getty -t 60 ttyFM02 9600
XF3:23:off:/etc/getty -t 60 ttyFM03 9600
XF4:23:off:/etc/getty -t 60 ttyFM04 9600
XF5:23:off:/etc/getty -t 60 ttyFM05 9600
XF6:23:off:/etc/getty -t 60 ttyFM06 9600
XF7:23:off:/etc/getty -t 60 ttyFM07 9600
SHAR_EOF
true || echo 'restore of i_fas-hub6c12 failed'
rm -f _shar_wnt_.tmp
fi
# ============= i_fas-use4c12 ==============
if test -f 'i_fas-use4c12' -a X"$1" != X"-c"; then
	echo 'x - skipping i_fas-use4c12 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting i_fas-use4c12 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'i_fas-use4c12' &&
XF0:23:off:/etc/getty -t 60 ttyFM00 9600
XF1:23:off:/etc/getty -t 60 ttyFM01 9600
XF2:23:off:/etc/getty -t 60 ttyFM02 9600
XF3:23:off:/etc/getty -t 60 ttyFM03 9600
XF4:23:off:/etc/getty -t 60 ttyFM04 9600
XF5:23:off:/etc/getty -t 60 ttyFM05 9600
SHAR_EOF
true || echo 'restore of i_fas-use4c12 failed'
rm -f _shar_wnt_.tmp
fi
# ============= m_fas ==============
if test -f 'm_fas' -a X"$1" != X"-c"; then
	echo 'x - skipping m_fas (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting m_fas (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'm_fas' &&
Xfas	Iocrwi	iHct		fas	0	3	1	16	-1
SHAR_EOF
true || echo 'restore of m_fas failed'
rm -f _shar_wnt_.tmp
fi
# ============= n_fas-ast4c12 ==============
if test -f 'n_fas-ast4c12' -a X"$1" != X"-c"; then
	echo 'x - skipping n_fas-ast4c12 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting n_fas-ast4c12 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'n_fas-ast4c12' &&
Xfas	ttyF00	c	80
Xfas	ttyF01	c	81
Xfas	ttyF02	c	82
Xfas	ttyF03	c	83
Xfas	ttyF04	c	84
Xfas	ttyF05	c	85
Xfas	ttyFM00	c	208
Xfas	ttyFM01	c	209
Xfas	ttyFM02	c	210
Xfas	ttyFM03	c	211
Xfas	ttyFM04	c	212
Xfas	ttyFM05	c	213
SHAR_EOF
true || echo 'restore of n_fas-ast4c12 failed'
rm -f _shar_wnt_.tmp
fi
# ============= n_fas-ast8c12 ==============
if test -f 'n_fas-ast8c12' -a X"$1" != X"-c"; then
	echo 'x - skipping n_fas-ast8c12 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting n_fas-ast8c12 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'n_fas-ast8c12' &&
Xfas	ttyF00	c	80
Xfas	ttyF01	c	81
Xfas	ttyF02	c	82
Xfas	ttyF03	c	83
Xfas	ttyF04	c	84
Xfas	ttyF05	c	85
Xfas	ttyF06	c	86
Xfas	ttyF07	c	87
Xfas	ttyF08	c	88
Xfas	ttyF09	c	89
Xfas	ttyFM00	c	208
Xfas	ttyFM01	c	209
Xfas	ttyFM02	c	210
Xfas	ttyFM03	c	211
Xfas	ttyFM04	c	212
Xfas	ttyFM05	c	213
Xfas	ttyFM06	c	214
Xfas	ttyFM07	c	215
Xfas	ttyFM08	c	216
Xfas	ttyFM09	c	217
SHAR_EOF
true || echo 'restore of n_fas-ast8c12 failed'
rm -f _shar_wnt_.tmp
fi
# ============= n_fas-c123 ==============
if test -f 'n_fas-c123' -a X"$1" != X"-c"; then
	echo 'x - skipping n_fas-c123 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting n_fas-c123 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'n_fas-c123' &&
Xfas	ttyF00	c	80
Xfas	ttyF01	c	81
Xfas	ttyF02	c	82
Xfas	ttyFM00	c	208
Xfas	ttyFM01	c	209
Xfas	ttyFM02	c	210
SHAR_EOF
true || echo 'restore of n_fas-c123 failed'
rm -f _shar_wnt_.tmp
fi
# ============= n_fas-gen8c12 ==============
if test -f 'n_fas-gen8c12' -a X"$1" != X"-c"; then
	echo 'x - skipping n_fas-gen8c12 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting n_fas-gen8c12 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'n_fas-gen8c12' &&
Xfas	ttyF00	c	80
Xfas	ttyF01	c	81
Xfas	ttyF02	c	82
Xfas	ttyF03	c	83
Xfas	ttyF04	c	84
Xfas	ttyF05	c	85
Xfas	ttyF06	c	86
Xfas	ttyF07	c	87
Xfas	ttyF08	c	88
Xfas	ttyF09	c	89
Xfas	ttyFM00	c	208
Xfas	ttyFM01	c	209
Xfas	ttyFM02	c	210
Xfas	ttyFM03	c	211
Xfas	ttyFM04	c	212
Xfas	ttyFM05	c	213
Xfas	ttyFM06	c	214
Xfas	ttyFM07	c	215
Xfas	ttyFM08	c	216
Xfas	ttyFM09	c	217
SHAR_EOF
true || echo 'restore of n_fas-gen8c12 failed'
rm -f _shar_wnt_.tmp
fi
# ============= n_fas-hub6c12 ==============
if test -f 'n_fas-hub6c12' -a X"$1" != X"-c"; then
	echo 'x - skipping n_fas-hub6c12 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting n_fas-hub6c12 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'n_fas-hub6c12' &&
Xfas	ttyF00	c	80
Xfas	ttyF01	c	81
Xfas	ttyF02	c	82
Xfas	ttyF03	c	83
Xfas	ttyF04	c	84
Xfas	ttyF05	c	85
Xfas	ttyF06	c	86
Xfas	ttyF07	c	87
Xfas	ttyFM00	c	208
Xfas	ttyFM01	c	209
Xfas	ttyFM02	c	210
Xfas	ttyFM03	c	211
Xfas	ttyFM04	c	212
Xfas	ttyFM05	c	213
Xfas	ttyFM06	c	214
Xfas	ttyFM07	c	215
SHAR_EOF
true || echo 'restore of n_fas-hub6c12 failed'
rm -f _shar_wnt_.tmp
fi
# ============= n_fas-use4c12 ==============
if test -f 'n_fas-use4c12' -a X"$1" != X"-c"; then
	echo 'x - skipping n_fas-use4c12 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting n_fas-use4c12 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'n_fas-use4c12' &&
Xfas	ttyF00	c	80
Xfas	ttyF01	c	81
Xfas	ttyF02	c	82
Xfas	ttyF03	c	83
Xfas	ttyF04	c	84
Xfas	ttyF05	c	85
Xfas	ttyFM00	c	208
Xfas	ttyFM01	c	209
Xfas	ttyFM02	c	210
Xfas	ttyFM03	c	211
Xfas	ttyFM04	c	212
Xfas	ttyFM05	c	213
SHAR_EOF
true || echo 'restore of n_fas-use4c12 failed'
rm -f _shar_wnt_.tmp
fi
# ============= optim_att.awk ==============
if test -f 'optim_att.awk' -a X"$1" != X"-c"; then
	echo 'x - skipping optim_att.awk (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting optim_att.awk (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'optim_att.awk' &&
X# optim_att.awk
X#
X# filter AT&T assembler file format
X#
X# Replace all calls to outb(), inb() and fas_mem_copy() with the necessary
X# assembler mnemonics and do some optimizations for bit tests.
X
XBEGIN {
X	nl = 0
X	prevline = ""
X}
X
X{
X	if ($1 == "popl") {
X	    print prevline
X	    if ($2 == "%ecx" && split(prevline, argsp) > 0 \
X			&& argsp[1] == "call") {
X		prevline = "\taddl\t$4,%esp"
X	    } else {
X		prevline = $0
X	    }
X	    next
X	} else if ($1 == "pushl") {
X	    if ($2 == "%eax" && split(prevline, argsp) == 2 \
X			&& argsp[1] == "movl" && argsp[2] == "%esp,%ebp") {
X		print prevline
X		prevline = "\tsubl\t$4,%esp"
X		next
X	    }
X	    lines[nl++] = $0
X	    getline
X	    if ($1 == "pushl") {
X		lines[nl++] = $0
X		getline
X		if ($1 == "call" && $2 == "outb") {
X		    lines[nl++] = $0
X		    getline
X		    if ($1 == "addl" && $2 == "$8,%esp") {
X			split(lines[0], args0)
X			split(lines[1], args1)
X			if (args1[2] == "%eax") {
X			    print prevline
X			    if (args0[2] == "%edx") {
X				print "\tmovl\t%eax,%ecx"
X				print "\tmovl\t%edx,%eax"
X				print "\tmovl\t%ecx,%edx"
X			    } else {
X				print "\tmovl\t%eax,%edx"
X				print "\tmovl\t" args0[2] ",%eax"
X			    }
X			} else {
X			    if (args0[2] == "%eax") {
X				res = 0
X				if (prevline ~ /,%eax$/) {
X				    argsline = substr(prevline, 1, \
X							length(prevline) - 5) \
X						" %eax"
X				    split(argsline, argsp)
X				    res = 1
X				}
X				if (res && argsp[3] == "%eax") {
X				    if (argsp[1] == "movzbl" \
X						|| argsp[1] == "movsbl") {
X					if (argsp[2] != "%al") {
X					    print "\tmovb\t" argsp[2] ",%al"
X					}
X				    } else if (argsp[1] == "movzwl" \
X						|| argsp[1] == "movswl") {
X					if (argsp[2] != "%ax") {
X					    if (argsp[2] ~ /^%/) {
X						print "\tmovw\t" argsp[2] ",%ax"
X					    } else {
X						print "\tmovb\t" argsp[2] ",%al"
X					    }
X					}
X				    } else {
X					print prevline
X				    }
X				} else {
X				    print prevline
X				}
X			    } else {
X				print prevline
X				if (args0[2] ~ /^%/) {
X				    print "\tmovl\t" args0[2] ",%eax"
X				} else {
X				    print "\tmovb\t" args0[2] ",%al"
X				}
X			    }
X			    if (args1[2] != "%edx") {
X				print "\tmovl\t" args1[2] ",%edx"
X			    }
X			}
X			prevline = "\toutb\t(%dx)"
X			nl = 0
X			next
X		    }
X		} else if ($1 == "pushl") {
X		    lines[nl++] = $0
X		    getline
X		    if ($1 == "call" && $2 == "fas_mem_copy") {
X			lines[nl++] = $0
X			getline
X			if ($1 == "addl" && $2 == "$12,%esp") {
X			    split(lines[0], args0)
X			    split(lines[1], args1)
X			    split(lines[2], args2)
X			    print prevline
X			    print "\tmovl\t" args2[2] ",%edi"
X			    print "\tmovl\t" args1[2] ",%esi"
X			    reg = ""
X			    if (args0[2] != "%ecx") {
X				if (args0[2] ~ /^[%$]/) {
X				    reg = args0[2]
X				}
X				print "\tmovl\t" args0[2] ",%ecx"
X			    }
X			    print "\tcld"
X			    if (reg == "") {
X				reg = "%eax"
X				print "\tmovl\t%ecx,%eax"
X			    }
X			    print "\tshrl\t$2,%ecx"
X			    print "\trep"
X			    print "\tmovsl"
X			    print "\tmovl\t" reg ",%ecx"
X			    print "\tandl\t$3,%ecx"
X			    print "\trep"
X			    prevline = "\tmovsb"
X			    nl = 0
X			    next
X			}
X		    }
X		}
X	    } else if ($1 == "call" && $2 == "inb") {
X		lines[nl++] = $0
X		getline
X		if ($1 == "popl" || ($1 == "addl" && $2 == "$4,%esp")) {
X		    split(lines[0], args0)
X		    print prevline
X		    if (args0[2] != "%edx") {
X			print "\tmovl\t" args0[2] ",%edx"
X		    }
X		    print "\txorl\t%eax,%eax"
X		    prevline = "\tinb\t(%dx)"
X		    nl = 0
X		    next
X		}
X	    }
X
X	    print prevline
X	    prevline = $0
X
X	    for (i = 0; i < nl; i++) {
X		print lines[i]
X	    }
X	    nl = 0
X	} else {
X	    print prevline
X	    prevline = $0
X	}
X
X	cmd = substr($1, 1, length($1) - 1)
X	class = substr($1, length($1))
X
X	if (cmd == "test" && (class == "l" || class == "w") && $2 ~ /^\$/) {
X	    split($2, args, ",")
X	    args[2] = substr($2, length(args[1]) + 2)
X	    if (args[2] ~ /^%.*x$/) {
X		reg = substr(args[2], length(args[2]) - 1, 1)
X	    } else {
X		reg = ""
X	    }
X	    if (reg != "" || args[2] !~ /^%/) {
X		val = substr(args[1], 2) + 0
X		if (class == "w" && val <= -1 && val >= -65536) {
X		    val += 65536
X		}
X		if (val >= 0 && val <= 255) {
X		    if (reg != "") {
X			prevline = "\t" cmd "b\t" args[1] ",%" reg "l"
X		    } else {
X			prevline = "\t" cmd "b\t" args[1] "," args[2]
X		    }
X		} else if (val >= 0 && val <= 65535 && (val % 256) == 0) {
X		    if (reg != "") {
X			prevline = "\t" cmd "b\t$" val / 256 ",%" reg "h"
X		    } else if (args[2] ~ /^[-(]/) {
X			prevline = "\t" cmd "b\t$" val / 256 ",1" args[2]
X		    } else {
X			prevline = "\t" cmd "b\t$" val / 256 ",1+" args[2]
X		    }
X		}
X	    }
X	}
X}
X
XEND {
X	    print prevline
X}
SHAR_EOF
true || echo 'restore of optim_att.awk failed'
rm -f _shar_wnt_.tmp
fi
# ============= os_dep_update ==============
if test -f 'os_dep_update' -a X"$1" != X"-c"; then
	echo 'x - skipping os_dep_update (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting os_dep_update (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'os_dep_update' &&
X# update OS dependent defines
X
Xif [ $# -lt 1 ]
Xthen
X	echo 'illegal numer of parameters' >&2
X	exit 1
Xfi
X
Xfname=$1
Xshift
X
Xfor flag in $*
Xdo
X	echo "#undef ${flag}"
X	echo "#define ${flag}"
Xdone > ${fname}.upd
X
Xsed -e '1,/@@OS_DEP_BEGIN@@/d;/@@OS_DEP_END@@/,$d' ${fname} > ${fname}.cur
Xcmp -s ${fname}.cur ${fname}.upd
Xres=$?
X
Xif [ ${res} -ne 1 ]
Xthen
X	rm -f ${fname}.cur ${fname}.upd
X	exit ${res}
Xfi
X
Xsed -e '1,/@@OS_DEP_BEGIN@@/{
X		/@@OS_DEP_BEGIN@@/r '${fname}.upd'
X		b
X	}
X	/@@OS_DEP_END@@/,$b
X	d' ${fname} > ${fname}.tmp
X
Xmv -f ${fname}.tmp ${fname}
Xrm -f ${fname}.cur ${fname}.upd
X
Xexit 0
SHAR_EOF
true || echo 'restore of os_dep_update failed'
rm -f _shar_wnt_.tmp
fi
# ============= s_fas-ast4c12 ==============
if test -f 's_fas-ast4c12' -a X"$1" != X"-c"; then
	echo 'x - skipping s_fas-ast4c12 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting s_fas-ast4c12 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 's_fas-ast4c12' &&
Xfas	Y	4	7	1	5	2a0	2bf	0	0
Xfas	Y	1	7	1	4	3f8	3ff	0	0
Xfas	Y	1	7	1	3	2f8	2ff	0	0
SHAR_EOF
true || echo 'restore of s_fas-ast4c12 failed'
rm -f _shar_wnt_.tmp
fi
# ============= s_fas-ast8c12 ==============
if test -f 's_fas-ast8c12' -a X"$1" != X"-c"; then
	echo 'x - skipping s_fas-ast8c12 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting s_fas-ast8c12 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 's_fas-ast8c12' &&
Xfas	Y	4	7	1	5	2a0	2bf	0	0
Xfas	Y	4	7	1	9	1a0	1bf	0	0
Xfas	Y	1	7	1	4	3f8	3ff	0	0
Xfas	Y	1	7	1	3	2f8	2ff	0	0
SHAR_EOF
true || echo 'restore of s_fas-ast8c12 failed'
rm -f _shar_wnt_.tmp
fi
# ============= s_fas-c123 ==============
if test -f 's_fas-c123' -a X"$1" != X"-c"; then
	echo 'x - skipping s_fas-c123 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting s_fas-c123 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 's_fas-c123' &&
Xfas	Y	1	7	1	4	3f8	3ff	0	0
Xfas	Y	1	7	1	3	2f8	2ff	0	0
Xfas	Y	1	7	1	5	3e8	3ef	0	0
SHAR_EOF
true || echo 'restore of s_fas-c123 failed'
rm -f _shar_wnt_.tmp
fi
# ============= s_fas-gen8c12 ==============
if test -f 's_fas-gen8c12' -a X"$1" != X"-c"; then
	echo 'x - skipping s_fas-gen8c12 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting s_fas-gen8c12 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 's_fas-gen8c12' &&
Xfas	Y	8	7	1	5	100	13f	0	0
Xfas	Y	1	7	1	4	3f8	3ff	0	0
Xfas	Y	1	7	1	3	2f8	2ff	0	0
SHAR_EOF
true || echo 'restore of s_fas-gen8c12 failed'
rm -f _shar_wnt_.tmp
fi
# ============= s_fas-hub6c12 ==============
if test -f 's_fas-hub6c12' -a X"$1" != X"-c"; then
	echo 'x - skipping s_fas-hub6c12 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting s_fas-hub6c12 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 's_fas-hub6c12' &&
Xfas	Y	6	7	1	5	302	308	0	0
Xfas	Y	1	7	1	4	3f8	3ff	0	0
Xfas	Y	1	7	1	3	2f8	2ff	0	0
SHAR_EOF
true || echo 'restore of s_fas-hub6c12 failed'
rm -f _shar_wnt_.tmp
fi
# ============= s_fas-use4c12 ==============
if test -f 's_fas-use4c12' -a X"$1" != X"-c"; then
	echo 'x - skipping s_fas-use4c12 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting s_fas-use4c12 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 's_fas-use4c12' &&
Xfas	Y	4	7	1	15	2c0	2df	0	0
Xfas	Y	1	7	1	4	3f8	3ff	0	0
Xfas	Y	1	7	1	3	2f8	2ff	0	0
SHAR_EOF
true || echo 'restore of s_fas-use4c12 failed'
rm -f _shar_wnt_.tmp
fi
# ============= space-ast4c12 ==============
if test -f 'space-ast4c12' -a X"$1" != X"-c"; then
	echo 'x - skipping space-ast4c12 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting space-ast4c12 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'space-ast4c12' &&
X/* Device configuration file for the FAS async driver. */
X
X/* This version is for the AST 4-port card in shared interrupts mode plus
X   the standard COM1 and COM2 ports.
X*/
X 
X/* FAS was developed by
XUwe Doering <fas@geminix.in-berlin.de>
XBillstedter Pfad 17 b
X13591 Berlin
XGermany
X*/
X
X#if !defined (M_I286)
X#ident	"@(#)space.c	2.11"
X#endif
X
X#if defined (LOCAL_INCLUDE)
X#include "fas.h"
X#else
X#include <sys/fas.h>
X#endif
X
X/* This is the number of devices to be handled by this driver.
X   If it is changed, make sure that the initializer parts of all arrays
X   dimensioned with `NUM_PHYSICAL_UNITS' have a corresponding number of
X   entries. You may define up to 16 devices.
X*/
X#define NUM_PHYSICAL_UNITS	6
X
X#if NUM_PHYSICAL_UNITS > MAX_UNITS
X#undef NUM_PHYSICAL_UNITS
X#define NUM_PHYSICAL_UNITS	MAX_UNITS
X#endif
X
X/* array of base port addresses
X   These values are the base i/o addresses of the UART chips.
X*/
Xuint	fas_port [NUM_PHYSICAL_UNITS] =
X{
X	0x2a0,	0x2a8,	0x2b0,	0x2b8,
X	0x3f8,	0x2f8
X};
X
X/* array of interrupt vectors (SCO UNIX and Xenix, only)
X   FAS doesn't need informations about interrupt vectors during normal
X   operation. Therefore, the only function of these values is to be
X   displayed by the FAS boot message. So if you want vector infos at
X   boot time you can enter the vector numbers here. But make sure that
X   the values correspond with the entries in the kernel config files.
X   A value of `-1' means that no vector number is displayed for the
X   respective port.
X   Users of other UNIX flavors can savely ignore this array.
X*/
Xint	fas_vec [NUM_PHYSICAL_UNITS] =
X{
X	-1,	-1,	-1,	-1,
X	-1,	-1
X};
X
X/* array of modifier flags
X   You can modify certain features of each port. See fas.h for possible
X   names and values.
X*/
Xuint	fas_modify [NUM_PHYSICAL_UNITS] =
X{
X	0,	0,	0,	0,
X	0,	0
X};
X
X/* array of FIFO operating mode values
X   These values select the mode to which the UART FIFOs are set when
X   a port is activated. For device types that don't have FIFOs the
X   respective value is ignored, so you can set up this array for
X   FIFO operation now and add the FIFO UARTs later. There are several
X   operating modes predefined. See fas.h for possible names and values.
X*/
Xuint	fas_fifo_ctl [NUM_PHYSICAL_UNITS] =
X{
X	FIFO_DEFAULT,
X	FIFO_DEFAULT,
X	FIFO_DEFAULT,
X	FIFO_DEFAULT,
X	FIFO_DEFAULT,
X	FIFO_DEFAULT
X};
X
X/* initialization sequence for serial cards
X   This array contains pairs of values of the form:
X
X        portaddress, value,
X              :
X              :
X        portaddress, value,
X        0
X
X   For every line `value' will be written to `portaddress'. If
X   `value' is replaced with the macro `READ_PORT' then a value
X   is read from `portaddress' instead. The value itself will be
X   discarded. Therefore, this makes only sense if the read access
X   to the port has a side effect like setting or resetting
X   certain flags.
X
X   NOTE: This array *must* be terminated with a value of 0
X         in the portaddress column!
X*/
Xuint	fas_init_seq [] =
X{
X	0x2bf,	0x80,
X	0
X};
X
X/* interrupt acknowledge sequence for serial cards
X   This sequence is executed by the fasintr () function after all pending
X   interrupts on all serial cards have been processed. The contents of this
X   array has the same form as in the fas_init_seq [] array above.
X*/
Xuint	fas_int_ack_seq [] =
X{
X	0
X};
X
X/* initial modem control port info
X   This value is ored into the modem control value for each UART. This is
X   normaly used to force out2 which is used to enable the interrupts of
X   the standard com1 and com2 ports. Several brands of cards have modes
X   that allow them to work in compatible mode like com1 and com2 or as a
X   shared interrupts card. One of these cards is the AST 4-port card. When
X   this card is used in shared interrupts mode out2 must _not_ be set.
X
X   Note: This is one of the major trouble-spots with shared interrupts
X   cards. Check your manual.
X*/
Xuint	fas_mcb [NUM_PHYSICAL_UNITS] =
X{
X	0,	0,	0,	0,
X	MC_SET_OUT2,	MC_SET_OUT2
X};
X
X/* array of modem control flags
X   You can choose which signals to use for modem control. See fas.h
X   for possible names and values. Whether or not modem control is
X   used is determined by the minor device number at open time.
X*/
Xulong	fas_modem [NUM_PHYSICAL_UNITS] =
X{
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD
X};
X
X/* array of hardware flow control flags
X   You can choose which signals to use for hardware handshake. See fas.h
X   for possible names and values. Whether or not hardware handshake is
X   used is determined by the minor device number at open time and by the
X   RTSFLOW/CTSFLOW termio(7) flags.
X*/
Xulong	fas_flow [NUM_PHYSICAL_UNITS] =
X{
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS
X};
X
X/* array of control register addresses
X   There are serial boards available that have all serial ports
X   multiplexed to one address location in order to save I/O address
X   space (Bell Tech HUB-6 card etc.). This multiplexing is controlled
X   by a special register that needs to be written to before the actual
X   port registers can be accessed. This array contains the addresses
X   of these special registers.
X   Enter the addresses on a per unit base. An address of zero
X   disables this feature.
X*/
Xuint	fas_ctl_port [NUM_PHYSICAL_UNITS] =
X{
X	0,	0,	0,	0,
X	0,	0
X};
X
X/* array of control register values
X   These values are written to the corresponding control register
X   before the first access to the actual port registers. If not only
X   entire UART chips (blocks of 8 contiguous addresses) but even the
X   single registers of the UART chips need to be multiplexed to one
X   address you have to "or" a bit mask (shifted 8 times to the left)
X   to the control register value. This mask determines at which bit
X   locations the UART chip register number is "xored" into the control
X   register value at runtime. This implies that you can also use
X   negative logic by setting the bits in the control register value
X   to 1 at the locations corresponding to the bit mask.
X*/
Xuint	fas_ctl_val [NUM_PHYSICAL_UNITS] =
X{
X	0,	0,	0,	0,
X	0,	0
X};
X
X/* This is the number of available port layout tables.
X   If this number is changed the arrays below must be filled
X   in accordingly.
X*/
X#define NUM_PORT_LAYOUTS	1
X
X/* array of port layout table selection values
X   These values select the port layout table in fas_layout [] []
X   that is used for the respective port.
X*/
Xuint	fas_pl_select [NUM_PHYSICAL_UNITS] =
X{
X	0,	0,	0,	0,
X	0,	0
X};
X
X/* array of port layout tables
X   This two-dimensional array contains the base port offsets of the
X   seven UART registers used by FAS. There are one or more port layout
X   tables that are selected by the values in fas_pl_select [].
X
X   Each port layout table is arranged like this (the position of the values
X   corresponds to the respective UART register acronym):
X
X	RBR/THR, IER,	IIR/FCR, LCR,	MCR,	LSR,	MSR
X*/
Xuint	fas_layout [NUM_PORT_LAYOUTS] [NUM_UART_REGS] =
X{
X  {	/* table 0 */
X	0,	1,	2,	3,	4,	5,	6
X  }
X};
X
X/* This is the number of available baud rate tables.
X   You may define up to 256 tables.  If this number is changed
X   the arrays below must be filled in accordingly.
X*/
X#define NUM_BAUD_TABLES	2
X
X#if NUM_BAUD_TABLES > MAX_BAUD_TABLES
X#undef NUM_BAUD_TABLES
X#define NUM_BAUD_TABLES	MAX_BAUD_TABLES
X#endif
X
X/* array of baud rate table selection values
X   These values select the baud rate table in fas_baud [] []
X   that is used for the respective port.
X*/
Xuint	fas_bt_select [NUM_PHYSICAL_UNITS] =
X{
X	0,	0,	0,	0,
X	0,	0
X};
X
X/* array of baud rate tables
X   This two-dimensional array contains the 15 possible UNIX baud rates
X   plus the baud rate base that these 15 baud rates are derived from. There
X   are one or more baud rate tables that are selected by the values in
X   fas_bt_select [].
X
X   The values in the baud rate tables are multiplied by ten to allow an
X   accuracy of 0.1 baud. The baud rate base can be computed by dividing the
X   external oscillator frequency (fed to the UART) by 16, and afterwards it
X   is also mutiplied by ten to make its scale match the scale of the baud
X   rate values.
X
X   Each baud rate table is arranged like this (the position of the values
X   corresponds to the respective baud rate symbol):
X
X	BASE,		B50,		B75,		B110,
X	B134,		B150,		B200,		B300,
X	B600,		B1200,		B1800,		B2400,
X	B4800,		B9600,		B19200,		B38400
X*/
Xulong	fas_baud [NUM_BAUD_TABLES] [CBAUD + 1] =
X{
X  {	/* table 0 */
X	1152000,	500,		750,		1100,
X	1345,		1500,		2000,		3000,
X	6000,		12000,		18000,		24000,
X	48000,		96000,		192000,		384000
X  },
X  {	/* table 1 */
X	1152000,	500,		750,		1100,
X	1345,		1500,		2000,		3000,
X	6000,		12000,		18000,		24000,
X	48000,		96000,		576000,		1152000
X  }
X};
X
X/* NOTHING NEEDS TO BE CHANGED BELOW THIS LINE.
X   ============================================
X*/
X
X/* let the driver know the number of devices */
Xuint	fas_physical_units = NUM_PHYSICAL_UNITS;
X
X/* let the driver know the number of port layout tables */
Xuint	fas_port_layouts = NUM_PORT_LAYOUTS;
X
X/* let the driver know the number of baud rate tables */
Xuint	fas_baud_tables = NUM_BAUD_TABLES;
X
X/* array of structures to hold all info for a physical minor device */
Xstruct fas_internals	fas_internals [NUM_PHYSICAL_UNITS];
X
X/* array of tty structures for logical devices */
Xstruct tty	fas_tty [NUM_PHYSICAL_UNITS * 2];
X
X/* array of fas_speed structure arrays that contain baud rate dependent
X   informations
X*/
Xstruct fas_speed	fas_speed [NUM_BAUD_TABLES] [CBAUD + 1];
X
X/* array of pointers to fas_internals structures
X   this prevents time consuming multiplications for index calculation
X*/
Xstruct fas_internals	*fas_internals_ptr [NUM_PHYSICAL_UNITS];
X
X/* array of pointers to tty structures
X   this prevents time consuming multiplications for index calculation
X*/
Xstruct tty	*fas_tty_ptr [NUM_PHYSICAL_UNITS * 2];
X
X/* array of pointers to fas_speed structure arrays
X   this prevents time consuming multiplications for index calculation
X*/
Xstruct fas_speed	*fas_speed_ptr [NUM_BAUD_TABLES];
X
X/* array of pointers to the baud rate tables in fas_baud [] []
X   this prevents time consuming multiplications for index calculation
X*/
Xulong	*fas_baud_ptr [NUM_BAUD_TABLES];
SHAR_EOF
true || echo 'restore of space-ast4c12 failed'
rm -f _shar_wnt_.tmp
fi
# ============= space-ast8c12 ==============
if test -f 'space-ast8c12' -a X"$1" != X"-c"; then
	echo 'x - skipping space-ast8c12 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting space-ast8c12 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'space-ast8c12' &&
X/* Device configuration file for the FAS async driver. */
X
X/* This version is for two AST 4-port cards (or a card with two AST 4-port
X   blocks on a single PCB) in shared interrupts mode plus the standard COM1
X   and COM2 ports.
X*/
X 
X/* FAS was developed by
XUwe Doering <fas@geminix.in-berlin.de>
XBillstedter Pfad 17 b
X13591 Berlin
XGermany
X*/
X
X#if !defined (M_I286)
X#ident	"@(#)space.c	2.11"
X#endif
X
X#if defined (LOCAL_INCLUDE)
X#include "fas.h"
X#else
X#include <sys/fas.h>
X#endif
X
X/* This is the number of devices to be handled by this driver.
X   If it is changed, make sure that the initializer parts of all arrays
X   dimensioned with `NUM_PHYSICAL_UNITS' have a corresponding number of
X   entries. You may define up to 16 devices.
X*/
X#define NUM_PHYSICAL_UNITS	10
X
X#if NUM_PHYSICAL_UNITS > MAX_UNITS
X#undef NUM_PHYSICAL_UNITS
X#define NUM_PHYSICAL_UNITS	MAX_UNITS
X#endif
X
X/* array of base port addresses
X   These values are the base i/o addresses of the UART chips.
X*/
Xuint	fas_port [NUM_PHYSICAL_UNITS] =
X{
X	0x2a0,	0x2a8,	0x2b0,	0x2b8,
X	0x1a0,	0x1a8,	0x1b0,	0x1b8,
X	0x3f8,	0x2f8
X};
X
X/* array of interrupt vectors (SCO UNIX and Xenix, only)
X   FAS doesn't need informations about interrupt vectors during normal
X   operation. Therefore, the only function of these values is to be
X   displayed by the FAS boot message. So if you want vector infos at
X   boot time you can enter the vector numbers here. But make sure that
X   the values correspond with the entries in the kernel config files.
X   A value of `-1' means that no vector number is displayed for the
X   respective port.
X   Users of other UNIX flavors can savely ignore this array.
X*/
Xint	fas_vec [NUM_PHYSICAL_UNITS] =
X{
X	-1,	-1,	-1,	-1,
X	-1,	-1,	-1,	-1,
X	-1,	-1
X};
X
X/* array of modifier flags
X   You can modify certain features of each port. See fas.h for possible
X   names and values.
X*/
Xuint	fas_modify [NUM_PHYSICAL_UNITS] =
X{
X	0,	0,	0,	0,
X	0,	0,	0,	0,
X	0,	0
X};
X
X/* array of FIFO operating mode values
X   These values select the mode to which the UART FIFOs are set when
X   a port is activated. For device types that don't have FIFOs the
X   respective value is ignored, so you can set up this array for
X   FIFO operation now and add the FIFO UARTs later. There are several
X   operating modes predefined. See fas.h for possible names and values.
X*/
Xuint	fas_fifo_ctl [NUM_PHYSICAL_UNITS] =
X{
X	FIFO_DEFAULT,
X	FIFO_DEFAULT,
X	FIFO_DEFAULT,
X	FIFO_DEFAULT,
X	FIFO_DEFAULT,
X	FIFO_DEFAULT,
X	FIFO_DEFAULT,
X	FIFO_DEFAULT,
X	FIFO_DEFAULT,
X	FIFO_DEFAULT
X};
X
X/* initialization sequence for serial cards
X   This array contains pairs of values of the form:
X
X        portaddress, value,
X              :
X              :
X        portaddress, value,
X        0
X
X   For every line `value' will be written to `portaddress'. If
X   `value' is replaced with the macro `READ_PORT' then a value
X   is read from `portaddress' instead. The value itself will be
X   discarded. Therefore, this makes only sense if the read access
X   to the port has a side effect like setting or resetting
X   certain flags.
X
X   NOTE: This array *must* be terminated with a value of 0
X         in the portaddress column!
X*/
Xuint	fas_init_seq [] =
X{
X	0x2bf,	0x80,
X	0x1bf,	0x80,
X	0
X};
X
X/* interrupt acknowledge sequence for serial cards
X   This sequence is executed by the fasintr () function after all pending
X   interrupts on all serial cards have been processed. The contents of this
X   array has the same form as in the fas_init_seq [] array above.
X*/
Xuint	fas_int_ack_seq [] =
X{
X	0
X};
X
X/* initial modem control port info
X   This value is ored into the modem control value for each UART. This is
X   normaly used to force out2 which is used to enable the interrupts of
X   the standard com1 and com2 ports. Several brands of cards have modes
X   that allow them to work in compatible mode like com1 and com2 or as a
X   shared interrupts card. One of these cards is the AST 4-port card. When
X   this card is used in shared interrupts mode out2 must _not_ be set.
X
X   Note: This is one of the major trouble-spots with shared interrupts
X   cards. Check your manual.
X*/
Xuint	fas_mcb [NUM_PHYSICAL_UNITS] =
X{
X	0,	0,	0,	0,
X	0,	0,	0,	0,
X	MC_SET_OUT2,	MC_SET_OUT2
X};
X
X/* array of modem control flags
X   You can choose which signals to use for modem control. See fas.h
X   for possible names and values. Whether or not modem control is
X   used is determined by the minor device number at open time.
X*/
Xulong	fas_modem [NUM_PHYSICAL_UNITS] =
X{
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD
X};
X
X/* array of hardware flow control flags
X   You can choose which signals to use for hardware handshake. See fas.h
X   for possible names and values. Whether or not hardware handshake is
X   used is determined by the minor device number at open time and by the
X   RTSFLOW/CTSFLOW termio(7) flags.
X*/
Xulong	fas_flow [NUM_PHYSICAL_UNITS] =
X{
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS
X};
X
X/* array of control register addresses
X   There are serial boards available that have all serial ports
X   multiplexed to one address location in order to save I/O address
X   space (Bell Tech HUB-6 card etc.). This multiplexing is controlled
X   by a special register that needs to be written to before the actual
X   port registers can be accessed. This array contains the addresses
X   of these special registers.
X   Enter the addresses on a per unit base. An address of zero
X   disables this feature.
X*/
Xuint	fas_ctl_port [NUM_PHYSICAL_UNITS] =
X{
X	0,	0,	0,	0,
X	0,	0,	0,	0,
X	0,	0
X};
X
X/* array of control register values
X   These values are written to the corresponding control register
X   before the first access to the actual port registers. If not only
X   entire UART chips (blocks of 8 contiguous addresses) but even the
X   single registers of the UART chips need to be multiplexed to one
X   address you have to "or" a bit mask (shifted 8 times to the left)
X   to the control register value. This mask determines at which bit
X   locations the UART chip register number is "xored" into the control
X   register value at runtime. This implies that you can also use
X   negative logic by setting the bits in the control register value
X   to 1 at the locations corresponding to the bit mask.
X*/
Xuint	fas_ctl_val [NUM_PHYSICAL_UNITS] =
X{
X	0,	0,	0,	0,
X	0,	0,	0,	0,
X	0,	0
X};
X
X/* This is the number of available port layout tables.
X   If this number is changed the arrays below must be filled
X   in accordingly.
X*/
X#define NUM_PORT_LAYOUTS	1
X
X/* array of port layout table selection values
X   These values select the port layout table in fas_layout [] []
X   that is used for the respective port.
X*/
Xuint	fas_pl_select [NUM_PHYSICAL_UNITS] =
X{
X	0,	0,	0,	0,
X	0,	0,	0,	0,
X	0,	0
X};
X
X/* array of port layout tables
X   This two-dimensional array contains the base port offsets of the
X   seven UART registers used by FAS. There are one or more port layout
X   tables that are selected by the values in fas_pl_select [].
X
X   Each port layout table is arranged like this (the position of the values
X   corresponds to the respective UART register acronym):
X
X	RBR/THR, IER,	IIR/FCR, LCR,	MCR,	LSR,	MSR
X*/
Xuint	fas_layout [NUM_PORT_LAYOUTS] [NUM_UART_REGS] =
X{
X  {	/* table 0 */
X	0,	1,	2,	3,	4,	5,	6
X  }
X};
X
X/* This is the number of available baud rate tables.
X   You may define up to 256 tables.  If this number is changed
X   the arrays below must be filled in accordingly.
X*/
X#define NUM_BAUD_TABLES	2
X
X#if NUM_BAUD_TABLES > MAX_BAUD_TABLES
X#undef NUM_BAUD_TABLES
X#define NUM_BAUD_TABLES	MAX_BAUD_TABLES
X#endif
X
X/* array of baud rate table selection values
X   These values select the baud rate table in fas_baud [] []
X   that is used for the respective port.
X*/
Xuint	fas_bt_select [NUM_PHYSICAL_UNITS] =
X{
X	0,	0,	0,	0,
X	0,	0,	0,	0,
X	0,	0
X};
X
X/* array of baud rate tables
X   This two-dimensional array contains the 15 possible UNIX baud rates
X   plus the baud rate base that these 15 baud rates are derived from. There
X   are one or more baud rate tables that are selected by the values in
X   fas_bt_select [].
X
X   The values in the baud rate tables are multiplied by ten to allow an
X   accuracy of 0.1 baud. The baud rate base can be computed by dividing the
X   external oscillator frequency (fed to the UART) by 16, and afterwards it
X   is also mutiplied by ten to make its scale match the scale of the baud
X   rate values.
X
X   Each baud rate table is arranged like this (the position of the values
X   corresponds to the respective baud rate symbol):
X
X	BASE,		B50,		B75,		B110,
X	B134,		B150,		B200,		B300,
X	B600,		B1200,		B1800,		B2400,
X	B4800,		B9600,		B19200,		B38400
X*/
Xulong	fas_baud [NUM_BAUD_TABLES] [CBAUD + 1] =
X{
X  {	/* table 0 */
X	1152000,	500,		750,		1100,
X	1345,		1500,		2000,		3000,
X	6000,		12000,		18000,		24000,
X	48000,		96000,		192000,		384000
X  },
X  {	/* table 1 */
X	1152000,	500,		750,		1100,
X	1345,		1500,		2000,		3000,
X	6000,		12000,		18000,		24000,
X	48000,		96000,		576000,		1152000
X  }
X};
X
X/* NOTHING NEEDS TO BE CHANGED BELOW THIS LINE.
X   ============================================
X*/
X
X/* let the driver know the number of devices */
Xuint	fas_physical_units = NUM_PHYSICAL_UNITS;
X
X/* let the driver know the number of port layout tables */
Xuint	fas_port_layouts = NUM_PORT_LAYOUTS;
X
X/* let the driver know the number of baud rate tables */
Xuint	fas_baud_tables = NUM_BAUD_TABLES;
X
X/* array of structures to hold all info for a physical minor device */
Xstruct fas_internals	fas_internals [NUM_PHYSICAL_UNITS];
X
X/* array of tty structures for logical devices */
Xstruct tty	fas_tty [NUM_PHYSICAL_UNITS * 2];
X
X/* array of fas_speed structure arrays that contain baud rate dependent
X   informations
X*/
Xstruct fas_speed	fas_speed [NUM_BAUD_TABLES] [CBAUD + 1];
X
X/* array of pointers to fas_internals structures
X   this prevents time consuming multiplications for index calculation
X*/
Xstruct fas_internals	*fas_internals_ptr [NUM_PHYSICAL_UNITS];
X
X/* array of pointers to tty structures
X   this prevents time consuming multiplications for index calculation
X*/
Xstruct tty	*fas_tty_ptr [NUM_PHYSICAL_UNITS * 2];
X
X/* array of pointers to fas_speed structure arrays
X   this prevents time consuming multiplications for index calculation
X*/
Xstruct fas_speed	*fas_speed_ptr [NUM_BAUD_TABLES];
X
X/* array of pointers to the baud rate tables in fas_baud [] []
X   this prevents time consuming multiplications for index calculation
X*/
Xulong	*fas_baud_ptr [NUM_BAUD_TABLES];
SHAR_EOF
true || echo 'restore of space-ast8c12 failed'
rm -f _shar_wnt_.tmp
fi
# ============= space-c123 ==============
if test -f 'space-c123' -a X"$1" != X"-c"; then
	echo 'x - skipping space-c123 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting space-c123 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'space-c123' &&
X/* Device configuration file for the FAS async driver. */
X
X/* This version is for the standard COM1 and COM2 and additional COM3
X   ports.
X*/
X 
X/* FAS was developed by
XUwe Doering <fas@geminix.in-berlin.de>
XBillstedter Pfad 17 b
X13591 Berlin
XGermany
X*/
X
X#if !defined (M_I286)
X#ident	"@(#)space.c	2.11"
X#endif
X
X#if defined (LOCAL_INCLUDE)
X#include "fas.h"
X#else
X#include <sys/fas.h>
X#endif
X
X/* This is the number of devices to be handled by this driver.
X   If it is changed, make sure that the initializer parts of all arrays
X   dimensioned with `NUM_PHYSICAL_UNITS' have a corresponding number of
X   entries. You may define up to 16 devices.
X*/
X#define NUM_PHYSICAL_UNITS	3
X
X#if NUM_PHYSICAL_UNITS > MAX_UNITS
X#undef NUM_PHYSICAL_UNITS
X#define NUM_PHYSICAL_UNITS	MAX_UNITS
X#endif
X
X/* array of base port addresses
X   These values are the base i/o addresses of the UART chips.
X*/
Xuint	fas_port [NUM_PHYSICAL_UNITS] =
X{
X	0x3f8,	0x2f8,	0x3e8
X};
X
X/* array of interrupt vectors (SCO UNIX and Xenix, only)
X   FAS doesn't need informations about interrupt vectors during normal
X   operation. Therefore, the only function of these values is to be
X   displayed by the FAS boot message. So if you want vector infos at
X   boot time you can enter the vector numbers here. But make sure that
X   the values correspond with the entries in the kernel config files.
X   A value of `-1' means that no vector number is displayed for the
X   respective port.
X   Users of other UNIX flavors can savely ignore this array.
X*/
Xint	fas_vec [NUM_PHYSICAL_UNITS] =
X{
X	-1,	-1,	-1
X};
X
X/* array of modifier flags
X   You can modify certain features of each port. See fas.h for possible
X   names and values.
X*/
Xuint	fas_modify [NUM_PHYSICAL_UNITS] =
X{
X	0,	0,	0
X};
X
X/* array of FIFO operating mode values
X   These values select the mode to which the UART FIFOs are set when
X   a port is activated. For device types that don't have FIFOs the
X   respective value is ignored, so you can set up this array for
X   FIFO operation now and add the FIFO UARTs later. There are several
X   operating modes predefined. See fas.h for possible names and values.
X*/
Xuint	fas_fifo_ctl [NUM_PHYSICAL_UNITS] =
X{
X	FIFO_DEFAULT,
X	FIFO_DEFAULT,
X	FIFO_DEFAULT
X};
X
X/* initialization sequence for serial cards
X   This array contains pairs of values of the form:
X
X        portaddress, value,
X              :
X              :
X        portaddress, value,
X        0
X
X   For every line `value' will be written to `portaddress'. If
X   `value' is replaced with the macro `READ_PORT' then a value
X   is read from `portaddress' instead. The value itself will be
X   discarded. Therefore, this makes only sense if the read access
X   to the port has a side effect like setting or resetting
X   certain flags.
X
X   NOTE: This array *must* be terminated with a value of 0
X         in the portaddress column!
X*/
Xuint	fas_init_seq [] =
X{
X	0
X};
X
X/* interrupt acknowledge sequence for serial cards
X   This sequence is executed by the fasintr () function after all pending
X   interrupts on all serial cards have been processed. The contents of this
X   array has the same form as in the fas_init_seq [] array above.
X*/
Xuint	fas_int_ack_seq [] =
X{
X	0
X};
X
X/* initial modem control port info
X   This value is ored into the modem control value for each UART. This is
X   normaly used to force out2 which is used to enable the interrupts of
X   the standard com1 and com2 ports. Several brands of cards have modes
X   that allow them to work in compatible mode like com1 and com2 or as a
X   shared interrupts card. One of these cards is the AST 4-port card. When
X   this card is used in shared interrupts mode out2 must _not_ be set.
X
X   Note: This is one of the major trouble-spots with shared interrupts
X   cards. Check your manual.
X*/
Xuint	fas_mcb [NUM_PHYSICAL_UNITS] =
X{
X	MC_SET_OUT2,	MC_SET_OUT2,	MC_SET_OUT2
X};
X
X/* array of modem control flags
X   You can choose which signals to use for modem control. See fas.h
X   for possible names and values. Whether or not modem control is
X   used is determined by the minor device number at open time.
X*/
Xulong	fas_modem [NUM_PHYSICAL_UNITS] =
X{
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD
X};
X
X/* array of hardware flow control flags
X   You can choose which signals to use for hardware handshake. See fas.h
X   for possible names and values. Whether or not hardware handshake is
X   used is determined by the minor device number at open time and by the
X   RTSFLOW/CTSFLOW termio(7) flags.
X*/
Xulong	fas_flow [NUM_PHYSICAL_UNITS] =
X{
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS
X};
X
X/* array of control register addresses
X   There are serial boards available that have all serial ports
X   multiplexed to one address location in order to save I/O address
X   space (Bell Tech HUB-6 card etc.). This multiplexing is controlled
X   by a special register that needs to be written to before the actual
X   port registers can be accessed. This array contains the addresses
X   of these special registers.
X   Enter the addresses on a per unit base. An address of zero
X   disables this feature.
X*/
Xuint	fas_ctl_port [NUM_PHYSICAL_UNITS] =
X{
X	0,	0,	0
X};
X
X/* array of control register values
X   These values are written to the corresponding control register
X   before the first access to the actual port registers. If not only
X   entire UART chips (blocks of 8 contiguous addresses) but even the
X   single registers of the UART chips need to be multiplexed to one
X   address you have to "or" a bit mask (shifted 8 times to the left)
X   to the control register value. This mask determines at which bit
X   locations the UART chip register number is "xored" into the control
X   register value at runtime. This implies that you can also use
X   negative logic by setting the bits in the control register value
X   to 1 at the locations corresponding to the bit mask.
X*/
Xuint	fas_ctl_val [NUM_PHYSICAL_UNITS] =
X{
X	0,	0,	0
X};
X
X/* This is the number of available port layout tables.
X   If this number is changed the arrays below must be filled
X   in accordingly.
X*/
X#define NUM_PORT_LAYOUTS	1
X
X/* array of port layout table selection values
X   These values select the port layout table in fas_layout [] []
X   that is used for the respective port.
X*/
Xuint	fas_pl_select [NUM_PHYSICAL_UNITS] =
X{
X	0,	0,	0
X};
X
X/* array of port layout tables
X   This two-dimensional array contains the base port offsets of the
X   seven UART registers used by FAS. There are one or more port layout
X   tables that are selected by the values in fas_pl_select [].
X
X   Each port layout table is arranged like this (the position of the values
X   corresponds to the respective UART register acronym):
X
X	RBR/THR, IER,	IIR/FCR, LCR,	MCR,	LSR,	MSR
X*/
Xuint	fas_layout [NUM_PORT_LAYOUTS] [NUM_UART_REGS] =
X{
X  {	/* table 0 */
X	0,	1,	2,	3,	4,	5,	6
X  }
X};
X
X/* This is the number of available baud rate tables.
X   You may define up to 256 tables.  If this number is changed
X   the arrays below must be filled in accordingly.
X*/
X#define NUM_BAUD_TABLES	2
X
X#if NUM_BAUD_TABLES > MAX_BAUD_TABLES
X#undef NUM_BAUD_TABLES
X#define NUM_BAUD_TABLES	MAX_BAUD_TABLES
X#endif
X
X/* array of baud rate table selection values
X   These values select the baud rate table in fas_baud [] []
X   that is used for the respective port.
X*/
Xuint	fas_bt_select [NUM_PHYSICAL_UNITS] =
X{
X	0,	0,	0
X};
X
X/* array of baud rate tables
X   This two-dimensional array contains the 15 possible UNIX baud rates
X   plus the baud rate base that these 15 baud rates are derived from. There
X   are one or more baud rate tables that are selected by the values in
X   fas_bt_select [].
X
X   The values in the baud rate tables are multiplied by ten to allow an
X   accuracy of 0.1 baud. The baud rate base can be computed by dividing the
X   external oscillator frequency (fed to the UART) by 16, and afterwards it
X   is also mutiplied by ten to make its scale match the scale of the baud
X   rate values.
X
X   Each baud rate table is arranged like this (the position of the values
X   corresponds to the respective baud rate symbol):
X
X	BASE,		B50,		B75,		B110,
X	B134,		B150,		B200,		B300,
X	B600,		B1200,		B1800,		B2400,
X	B4800,		B9600,		B19200,		B38400
X*/
Xulong	fas_baud [NUM_BAUD_TABLES] [CBAUD + 1] =
X{
X  {	/* table 0 */
X	1152000,	500,		750,		1100,
X	1345,		1500,		2000,		3000,
X	6000,		12000,		18000,		24000,
X	48000,		96000,		192000,		384000
X  },
X  {	/* table 1 */
X	1152000,	500,		750,		1100,
X	1345,		1500,		2000,		3000,
X	6000,		12000,		18000,		24000,
X	48000,		96000,		576000,		1152000
X  }
X};
X
X/* NOTHING NEEDS TO BE CHANGED BELOW THIS LINE.
X   ============================================
X*/
X
X/* let the driver know the number of devices */
Xuint	fas_physical_units = NUM_PHYSICAL_UNITS;
X
X/* let the driver know the number of port layout tables */
Xuint	fas_port_layouts = NUM_PORT_LAYOUTS;
X
X/* let the driver know the number of baud rate tables */
Xuint	fas_baud_tables = NUM_BAUD_TABLES;
X
X/* array of structures to hold all info for a physical minor device */
Xstruct fas_internals	fas_internals [NUM_PHYSICAL_UNITS];
X
X/* array of tty structures for logical devices */
Xstruct tty	fas_tty [NUM_PHYSICAL_UNITS * 2];
X
X/* array of fas_speed structure arrays that contain baud rate dependent
X   informations
X*/
Xstruct fas_speed	fas_speed [NUM_BAUD_TABLES] [CBAUD + 1];
X
X/* array of pointers to fas_internals structures
X   this prevents time consuming multiplications for index calculation
X*/
Xstruct fas_internals	*fas_internals_ptr [NUM_PHYSICAL_UNITS];
X
X/* array of pointers to tty structures
X   this prevents time consuming multiplications for index calculation
X*/
Xstruct tty	*fas_tty_ptr [NUM_PHYSICAL_UNITS * 2];
X
X/* array of pointers to fas_speed structure arrays
X   this prevents time consuming multiplications for index calculation
X*/
Xstruct fas_speed	*fas_speed_ptr [NUM_BAUD_TABLES];
X
X/* array of pointers to the baud rate tables in fas_baud [] []
X   this prevents time consuming multiplications for index calculation
X*/
Xulong	*fas_baud_ptr [NUM_BAUD_TABLES];
SHAR_EOF
true || echo 'restore of space-c123 failed'
rm -f _shar_wnt_.tmp
fi
# ============= space-gen8c12 ==============
if test -f 'space-gen8c12' -a X"$1" != X"-c"; then
	echo 'x - skipping space-gen8c12 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting space-gen8c12 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'space-gen8c12' &&
X/* Device configuration file for the FAS async driver. */
X
X/* This is a generic version for 8-port cards plus the standard
X   COM1 and COM2 ports.
X*/
X 
X/* FAS was developed by
XUwe Doering <fas@geminix.in-berlin.de>
XBillstedter Pfad 17 b
X13591 Berlin
XGermany
X*/
X
X#if !defined (M_I286)
X#ident	"@(#)space.c	2.11"
X#endif
X
X#if defined (LOCAL_INCLUDE)
X#include "fas.h"
X#else
X#include <sys/fas.h>
X#endif
X
X/* This is the number of devices to be handled by this driver.
X   If it is changed, make sure that the initializer parts of all arrays
X   dimensioned with `NUM_PHYSICAL_UNITS' have a corresponding number of
X   entries. You may define up to 16 devices.
X*/
X#define NUM_PHYSICAL_UNITS	10
X
X#if NUM_PHYSICAL_UNITS > MAX_UNITS
X#undef NUM_PHYSICAL_UNITS
X#define NUM_PHYSICAL_UNITS	MAX_UNITS
X#endif
X
X/* array of base port addresses
X   These values are the base i/o addresses of the UART chips.
X*/
Xuint	fas_port [NUM_PHYSICAL_UNITS] =
X{
X	0x100,	0x108,	0x110,	0x118,
X	0x120,	0x128,	0x130,	0x138,
X	0x3f8,	0x2f8
X};
X
X/* array of interrupt vectors (SCO UNIX and Xenix, only)
X   FAS doesn't need informations about interrupt vectors during normal
X   operation. Therefore, the only function of these values is to be
X   displayed by the FAS boot message. So if you want vector infos at
X   boot time you can enter the vector numbers here. But make sure that
X   the values correspond with the entries in the kernel config files.
X   A value of `-1' means that no vector number is displayed for the
X   respective port.
X   Users of other UNIX flavors can savely ignore this array.
X*/
Xint	fas_vec [NUM_PHYSICAL_UNITS] =
X{
X	-1,	-1,	-1,	-1,
X	-1,	-1,	-1,	-1,
X	-1,	-1
X};
X
X/* array of modifier flags
X   You can modify certain features of each port. See fas.h for possible
X   names and values.
X*/
Xuint	fas_modify [NUM_PHYSICAL_UNITS] =
X{
X	0,	0,	0,	0,
X	0,	0,	0,	0,
X	0,	0
X};
X
X/* array of FIFO operating mode values
X   These values select the mode to which the UART FIFOs are set when
X   a port is activated. For device types that don't have FIFOs the
X   respective value is ignored, so you can set up this array for
X   FIFO operation now and add the FIFO UARTs later. There are several
X   operating modes predefined. See fas.h for possible names and values.
X*/
Xuint	fas_fifo_ctl [NUM_PHYSICAL_UNITS] =
X{
X	FIFO_DEFAULT,
X	FIFO_DEFAULT,
X	FIFO_DEFAULT,
X	FIFO_DEFAULT,
X	FIFO_DEFAULT,
X	FIFO_DEFAULT,
X	FIFO_DEFAULT,
X	FIFO_DEFAULT,
X	FIFO_DEFAULT,
X	FIFO_DEFAULT
X};
X
X/* initialization sequence for serial cards
X   This array contains pairs of values of the form:
X
X        portaddress, value,
X              :
X              :
X        portaddress, value,
X        0
X
X   For every line `value' will be written to `portaddress'. If
X   `value' is replaced with the macro `READ_PORT' then a value
X   is read from `portaddress' instead. The value itself will be
X   discarded. Therefore, this makes only sense if the read access
X   to the port has a side effect like setting or resetting
X   certain flags.
X
X   NOTE: This array *must* be terminated with a value of 0
X         in the portaddress column!
X*/
Xuint	fas_init_seq [] =
X{
X	0
X};
X
X/* interrupt acknowledge sequence for serial cards
X   This sequence is executed by the fasintr () function after all pending
X   interrupts on all serial cards have been processed. The contents of this
X   array has the same form as in the fas_init_seq [] array above.
X*/
Xuint	fas_int_ack_seq [] =
X{
X	0
X};
X
X/* initial modem control port info
X   This value is ored into the modem control value for each UART. This is
X   normaly used to force out2 which is used to enable the interrupts of
X   the standard com1 and com2 ports. Several brands of cards have modes
X   that allow them to work in compatible mode like com1 and com2 or as a
X   shared interrupts card. One of these cards is the AST 4-port card. When
X   this card is used in shared interrupts mode out2 must _not_ be set.
X
X   Note: This is one of the major trouble-spots with shared interrupts
X   cards. Check your manual.
X*/
Xuint	fas_mcb [NUM_PHYSICAL_UNITS] =
X{
X	MC_SET_OUT2,	MC_SET_OUT2,	MC_SET_OUT2,	MC_SET_OUT2,
X	MC_SET_OUT2,	MC_SET_OUT2,	MC_SET_OUT2,	MC_SET_OUT2,
X	MC_SET_OUT2,	MC_SET_OUT2
X};
X
X/* array of modem control flags
X   You can choose which signals to use for modem control. See fas.h
X   for possible names and values. Whether or not modem control is
X   used is determined by the minor device number at open time.
X*/
Xulong	fas_modem [NUM_PHYSICAL_UNITS] =
X{
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD,
X	EO_DTR | EI_DTR | CA_DCD
X};
X
X/* array of hardware flow control flags
X   You can choose which signals to use for hardware handshake. See fas.h
X   for possible names and values. Whether or not hardware handshake is
X   used is determined by the minor device number at open time and by the
X   RTSFLOW/CTSFLOW termio(7) flags.
X*/
Xulong	fas_flow [NUM_PHYSICAL_UNITS] =
X{
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS,
X	HI_RTS | HO_CTS_ON_DSR | HX_RTS
X};
X
X/* array of control register addresses
X   There are serial boards available that have all serial ports
X   multiplexed to one address location in order to save I/O address
X   space (Bell Tech HUB-6 card etc.). This multiplexing is controlled
X   by a special register that needs to be written to before the actual
X   port registers can be accessed. This array contains the addresses
X   of these special registers.
X   Enter the addresses on a per unit base. An address of zero
X   disables this feature.
X*/
Xuint	fas_ctl_port [NUM_PHYSICAL_UNITS] =
X{
X	0,	0,	0,	0,
X	0,	0,	0,	0,
X	0,	0
X};
X
X/* array of control register values
X   These values are written to the corresponding control register
X   before the first access to the actual port registers. If not only
X   entire UART chips (blocks of 8 contiguous addresses) but even the
X   single registers of the UART chips need to be multiplexed to one
X   address you have to "or" a bit mask (shifted 8 times to the left)
X   to the control register value. This mask determines at which bit
X   locations the UART chip register number is "xored" into the control
X   register value at runtime. This implies that you can also use
X   negative logic by setting the bits in the control register value
X   to 1 at the locations corresponding to the bit mask.
X*/
Xuint	fas_ctl_val [NUM_PHYSICAL_UNITS] =
X{
X	0,	0,	0,	0,
X	0,	0,	0,	0,
X	0,	0
X};
X
X/* This is the number of available port layout tables.
X   If this number is changed the arrays below must be filled
X   in accordingly.
X*/
X#define NUM_PORT_LAYOUTS	1
X
X/* array of port layout table selection values
X   These values select the port layout table in fas_layout [] []
X   that is used for the respective port.
X*/
Xuint	fas_pl_select [NUM_PHYSICAL_UNITS] =
X{
X	0,	0,	0,	0,
X	0,	0,	0,	0,
X	0,	0
X};
SHAR_EOF
true || echo 'restore of space-gen8c12 failed'
fi
echo 'End of  part 7'
echo 'File space-gen8c12 is continued in part 8'
echo 8 > _shar_seq_.tmp
exit 0
