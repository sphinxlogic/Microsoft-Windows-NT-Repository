Newsgroups: comp.sources.unix
From: fas@geminix.in-berlin.de (FAS Support Account)
Subject: v27i070: FAS-2.11.0 - asynch serial driver for System V, Part04/08
References: <1.750471074.20539@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: fas@geminix.in-berlin.de (FAS Support Account)
Posting-Number: Volume 27, Issue 70
Archive-Name: fas-2.11.0/part04

#!/bin/sh
# this is fas211pl0.04 (part 4 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file fas.7.cat continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 4; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping fas.7.cat'
else
echo 'x - continuing file fas.7.cat'
sed 's/^X//' << 'SHAR_EOF' >> 'fas.7.cat' &&
X	       control CCCCTTTTSSSS will	go low and therefore the output	gets
X	       blocked.	 If at this time there are still characters in the
X	       output buffer the last process closing this port	can't ter-
X	       minate until the	buffer has drained.  But as DDDDSSSSRRRR	will also
X	       go low if you switch off	the device the blocking	of the out-
X	       put will	be prevented.
X
X	       In short:  Hardware output handshake is only used if the
X	       connected device	sets DDDDSSSSRRRR high, that is,	the device is
X	       switched	on and is ready.  So make sure that you	keep this
X	       in mind when you	make serial cables and when you	configure
X	       your serial devices.  DDDDSSSSRRRR must be on if you want	CCCCTTTTSSSS
X	       handshake.
X
X	       The other advantage of this CCCCTTTTSSSS/DDDDSSSSRRRR mechanismn is that you
X	       can still connect "dumb"	serial devices to an _F_A_S hardware
X	       handshake port using a minimal 3-wire cable.  As	an uncon-
X	       nected DDDDSSSSRRRR line is automatically	low, hardware output
X	       handshake is disabled, which is just what you want in this
X	       case.  However, it's safer to use a minor device	number of 0000
X	       + device	# for 3-wire cables (see section CCCCAAAABBBBLLLLIIIINNNNGGGG).
X
X	       The CLOCAL flag doesn't affect this mode.
X
X	       Note: If	you use	a minor	device number where hardware
X		     handshake is disabled (see	``First	mode'' below) you
X		     can, if you have SCO UNIX 3.2.4, enable full duplex
X		     hardware flow control by setting the CRTSFL _t_e_r_m_i_o(M)
X		     flag.  This works,	however, only if neither
X		     CTSFLOW/RTSFLOW nor CLOCAL	are set.
X
X		     In	SCO UNIX 3.2.4.2 the meaning of	CTSFLOW/RTSFLOW	has
X
X
X	  Rev. Release 2.11.0					     Page 7
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X		     changed.  These flags enable full duplex hardware flow
X		     control.  For backward compatibility there	is the
X		     ORTSFL flag which enables,	when set together with
X		     CTSFLOW and/or RTSFLOW, half duplex flow control.
X		     These flags only work if CLOCAL is	nnnnooootttt set.
X
X	     Half duplex mode
X	       There are actually three	half duplex modes selected by the
X	       minor device number:
X
X		  First	mode
X		     If	the RTSFLOW _t_e_r_m_i_o(M) flag is set and the CLOCAL
X		     flag is nnnnooootttt set the RRRRTTTTSSSS line is used to signal the
X		     connected device that there is data in the	output
X		     buffer.  As long as there is output data to come the
X		     RRRRTTTTSSSS line stays high.  If the output buffer	has drained
X		     RRRRTTTTSSSS drops to low until there is more data to be sent
X		     to	the connected device.
X
X		     If	the CTSFLOW _t_e_r_m_i_o(M) flag is set and the CLOCAL
X		     flag is nnnnooootttt set the CCCCTTTTSSSS line is used to control the
X		     output character flow.  This works	as in full duplex
X		     mode.
X
X		     If	neither	CTSFLOW	nor RTSFLOW are	set hardware flow
X		     control is	disabled.  But see the description of the
X		     CRTSFL/ORTSFL _t_e_r_m_i_o(M) flags at the end of the sec-
X		     tion FFFFuuuullllllll dddduuuupppplllleeeexxxx mmmmooooddddeeee.
X
X		     Note: Setting the CTSFLOW and RTSFLOW flags (and
X			   CRTSFL/ORTSFL, if available)	only applies to	SCO
X			   UNIX	and Xenix.  To my knowledge, other UNIX
X			   flavors don't have these flags.  For	them,
X			   hardware flow control is always disabled in this
X			   mode.
X
X		  Second mode
X		     This mode overrides the RTSFLOW, CTSFLOW, CRTSFL and
X		     ORTSFL flags and works as if the CTSFLOW flag is set
X		     permanently (all UNIX flavors).  The CLOCAL flag
X		     doesn't affect this mode.
X
X		  Third	mode
X		     This mode overrides the RTSFLOW, CTSFLOW, CRTSFL and
X		     ORTSFL flags and works as if both the RTSFLOW and
X		     CTSFLOW flags (in SCO UNIX	prior to 3.2.4.2 and SCO
X		     Xenix) are	set permanently	(all UNIX flavors).  The
X		     CLOCAL flag doesn't affect	this mode.
X
X	       Note: Under SCO UNIX prior to 3.2.4.2 and Xenix the
X		     _t_e_r_m_i_o(M) RTSFLOW flag is intended	for half duplex
X		     hardware flow control devices.  Setting it	when the
X		     connected device does ffffuuuullllllll	duplex hardware	flow
X
X
X	  Rev. Release 2.11.0					     Page 8
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X		     control is	a configuration	error!	The RRRRTTTTSSSS	signalling
X		     for half duplex devices has a completely different
X		     meaning than for full duplex devices.  So you should
X		     either set	only CTSFLOW (or CRTSFL, if available),	or
X		     you should	select hardware	flow control via the minor
X		     device number.  If	you set	RTSFLOW	for full duplex
X		     hardware flow control devices it is likely	that the
X		     port won't	work.  This is in line with SCO's _s_i_o
X		     driver implementation.
X
X	     Direct control
X	       On UNIX flavors where the RTS_TOG _i_o_c_t_l(2|S) command is
X	       available the hardware handshake	output (RRRRTTTTSSSS by default)	can
X	       be set under program control.  An _i_o_c_t_l(2|S) argument of	0000
X	       sets the	output to low and an argument of 1111 sets	it to high.
X	       However,	this only works	if the hardware	handshake modes	as
X	       well as _V_P/_i_x DOS mode are disabled.  If	one of these modes
X	       is enabled _F_A_S needs the	hardware handshake output for its
X	       own flow	control.
X
X	       On the other hand, even if one of these modes is	in use and
X	       _F_A_S gets	an RTS_TOG command, the	state of the handware
X	       handshake output	that this command tries	to set is stored
X	       and the output is set to	the state of the last RTS_TOG com-
X	       mand as soon as both hardware handshake mode and	DOS mode
X	       are disabled.
X
X	       In other	words, _F_A_S doesn't ignore the RTS_TOG command if
X	       hardware	handshake modes	or DOS mode are	set but	rather
X	       overrides the hardware handshake	output with the	appropriate
X	       state computed internally.
X
X	  _V_P/_i_x	SUPPORT
X	       _F_A_S allows DOS programs running under _V_P/_i_x to access serial
X	       ports.  You simply need to modify your personal _V_P/_i_x confi-
X	       guration	file (_v_p_i_x._c_n_f)	to tell	the DOS	emulator which _F_A_S
X	       devices to use for COM1 (or COM1MOUSE) and COM2.
X
X	       Note that _V_P/_i_x opens these devices at startup time, so you
X	       better make sure	that the desired devices aren't	used by
X	       other processes when you	start _V_P/_i_x as _V_P/_i_x wants to use
X	       them exclusively.
X
X	       There are some special features with the	handling of the	RRRRTTTTSSSS
X	       and DDDDTTTTRRRR lines you should	know about.  If	your DOS program
X	       asserts the DDDDTTTTRRRR line this will actually cause action on the
X	       modem enable line you configured	in _s_p_a_c_e._c.  Likewise, RRRRTTTTSSSS
X	       asserts the half	duplex hardware	handshake line configured
X	       in _s_p_a_c_e._c.
X
X	       If the used _F_A_S device has full duplex hardware handshake
X	       enabled,	asserting RRRRTTTTSSSS from DOS actually	stops the character
X	       flow from _F_A_S to	_V_P/_i_x.	This prevents input buffers of
X
X
X	  Rev. Release 2.11.0					     Page 9
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X	       interrupt driven	DOS programs from overflowing.	_F_A_S, on	the
X	       other hand, uses	its hardware handshake to prevent an over-
X	       flow of its own input buffer.  Therefore, you can use DOS
X	       telecommunication programs even at high baud rates without
X	       losing characters, provided your	DOS programs are configured
X	       to use full duplex RRRRTTTTSSSS/CCCCTTTTSSSS flow control.
X
X	       All this	virtual	handling has the advantage that	the DOS
X	       program doesn't need to know certain details about your
X	       actual port setup.  Reading the modem status register, on
X	       the other hand, doesn't cause any translation of	the regis-
X	       ter value.
X
X	       To enable _V_P/_i_x support,	the HAVE_VPIX define in	_f_a_s._h has
X	       to be uncommented.
X
X	  MODIFYING A PORT'S DEFAULT BEHAVIOUR
X	       There are some flags that you can set in	the _f_a_s__m_o_d_i_f_y[]
X	       array (_s_p_a_c_e._c) for each	port independently.  You have to
X	       relink the kernel before	these flags have any effect.  Here
X	       is a description:
X
X		  NNNNOOOO____TTTTEEEESSSSTTTT
X		     If	for some reason	a UART doesn't pass the	functional-
X		     lity test _F_A_S makes at boot time you can override the
X		     test result and use this port, anyway.  However, you
X		     do	this on	your own risk.	Don't be surprised if ports
X		     get hung or your machine crashes.	I won't	support	_F_A_S
X		     installations where this flag is used.  It	is intended
X		     as	a last resort.
X
X		     There is one exception to this, though.  If the
X		     NNNNOOOO____TTTTEEEESSSSTTTT flag is already set in the	sample config files
X		     for certain serial	cards and provided that	these sam-
X		     ple files are part	of the original	_F_A_S distribution,
X		     you won't lose my support because in this case I've
X		     tested the	respective product myself and decided that
X		     it	is safe	to use the NNNNOOOO____TTTTEEEESSSSTTTT flag	with it.
X
X		  NNNNOOOO____HHHHUUUUPPPP____PPPPRRRROOOOTTTTEEEECCCCTTTT
X		     Normally, with modem control enabled, after the car-
X		     rier is lost the carrier is ignored and assumed to	be
X		     missing even if the physical carrier line is asserted
X		     again.
X
X		     Additionally, as the device can't accept a	call in
X		     this state, anyway, the modem enable line is set to
X		     low so that the modem won't answer	calls.	This
X		     prevents users from getting the shell of a	previous
X		     user in case that the shell doesn't react to SIGHUP
X		     for some reason.  So the modem port is dead until this
X		     situation is dealt	with.
X
X
X
X	  Rev. Release 2.11.0					    Page 10
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X		     This adds some security to	modem ports.  However, if
X		     this feature breaks one of	your applications for some
X		     reason, just set NNNNOOOO____HHHHUUUUPPPP____PPPPRRRROOOOTTTTEEEECCCCTTTT and the hangup protec-
X		     tion is disabled for this port.
X
X		  NNNNOOOO____OOOOVVVVEEEERRRRRRRRUUUUNNNN
X		     The device	has some sort of receiver overrun protec-
X		     tion.  For	instance, it may be used with certain
X		     internal modems that use a	_N_S_1_6_x_5_0	UART emulation and
X		     have their	own receiver buffer.  This flag	only
X		     affects the position of the device	in the interrupt
X		     users chain, that is, because the device can't overrun
X		     it	is serviced only after all devices that	don't have
X		     an	overrun	protection have	been taken care	of.
X
X		  NNNNEEEEWWWW____CCCCTTTTSSSSRRRRTTTTSSSS
X		     Some "intelligent"	serial cards from third	party ven-
X		     dors have the meaning of the RTSFLOW _t_e_r_m_i_o(M) flag
X		     redefined.	 It is used, together with CTSFLOW, to
X		     enable full duplex	hardware flow control, whereas SCO
X		     introduced	RTSFLOW	for the	more traditional half
X		     duplex hardware flow control that is implemented in
X		     their _s_i_o driver.	By default, _F_A_S	emulates the _s_i_o
X		     driver for	compatibility reasons.
X
X		     However, if you like to use CTSFLOW/RTSFLOW for full
X		     duplex hardware flow control in a way that	is compati-
X		     ble with the above	mentioned "intelligent"	cards, you
X		     can do this by setting NNNNEEEEWWWW____CCCCTTTTSSSSRRRRTTTTSSSS.	 Also,
X		     CTSFLOW/RTSFLOW are no longer affected by CLOCAL if
X		     NNNNEEEEWWWW____CCCCTTTTSSSSRRRRTTTTSSSS	is set.	 In this mode CTSFLOW enables the
X		     output flow control and RTSFLOW enables the input flow
X		     control.  Both flags are independent from each other.
X
X		     Note that under SCO UNIX 3.2.4.2 the CTSFLOW/RTSFLOW
X		     flags have	changed	their meaning in that they enable
X		     full duplex hardware flow control.
X
X	       These flags are defined in _f_a_s._h.  For example, if you want
X	       to use the meaning of RTSFLOW that is compatible	to some	of
X	       the "intelligent" serial	cards you would	write
X
X		    NEW_CTSRTS
X
X	       at the appropriate position in _f_a_s__m_o_d_i_f_y[].  If	you addi-
X	       tionally	want to	skip the test routine for this port you
X	       would write
X
X		    NO_TEST | NEW_CTSRTS
X
X	  UART FIFO CONTROL
X	       In order	to control the operating modes of UARTs	that have
X	       built-in	FIFOs you can select the desired mode for each port
X
X
X	  Rev. Release 2.11.0					    Page 11
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X	       independently by	modifying the _f_a_s__f_i_f_o__c_t_l[] array
X	       (_s_p_a_c_e._c).  You have to relink the kernel before	these
X	       changes have any	effect.	 There are a number of predefined,
X	       mutually	exclusive symbols available:
X
X		  FFFFIIIIFFFFOOOO____DDDDEEEEFFFFAAAAUUUULLLLTTTT
X		     All UART types with FIFOs.
X		     The FIFOs are enabled and in case that an _N_S_1_6_5_5_0_A	was
X		     detected, the receiver FIFO trigger level is set to 4
X		     or	8 characters (depending	on the UNIX flavour, see
X		     the description of	LOW_INT_LAT in section
X		     TTTTRRRROOOOUUUUBBBBLLLLEEEE----SSSSHHHHOOOOOOOOTTTTIIIINNNNGGGG, subsection CCCChhhhaaaarrrraaaacccctttteeeerrrr lllloooossssssss).
X
X		  FFFFIIIIFFFFOOOO____OOOOFFFFFFFF
X		     All UART types with FIFOs.
X		     The FIFOs are disabled and	the UART works in the
X		     _N_S_1_6_4_5_0 compatible	mode.
X
X		  FFFFIIIIFFFFOOOO____EEEEMMMMUUUULLLL____NNNNSSSS11116666444455550000
X		     All UART types with FIFOs.
X		     The FIFOs are enabled and in case that an _N_S_1_6_5_5_0_A	was
X		     detected, the receiver FIFO trigger level is set to 1
X		     character.	 The transmitter FIFO is filled	with only 1
X		     character per transmitter interrupt.  This	emulates
X		     the _N_S_1_6_4_5_0 UART and additionally gives you the over-
X		     run protection provided by	the receiver FIFO.
X
X		  FFFFIIIIFFFFOOOO____PPPPOOOOIIIINNNNTTTTEEEERRRR____DDDDEEEEVVVV
X		     _N_S_1_6_5_5_0_A, only.
X		     The FIFOs are enabled and the receiver FIFO trigger
X		     level is set to 1 character.  This	should be used for
X		     pointer devices like mice or trackballs because it
X		     prevents the short	receiver FIFO timeout delay that
X		     could lead	to jerky pointer movement.
X
X		  FFFFIIIIFFFFOOOO____TTTTRRRRIIIIGGGGGGGGEEEERRRR____1111
X		     _N_S_1_6_5_5_0_A, only.
X		     The FIFOs are enabled and the receiver FIFO trigger
X		     level is set to 1 character.
X
X		  FFFFIIIIFFFFOOOO____TTTTRRRRIIIIGGGGGGGGEEEERRRR____4444
X		     _N_S_1_6_5_5_0_A, only.
X		     The FIFOs are enabled and the receiver FIFO trigger
X		     level is set to 4 characters.
X
X		  FFFFIIIIFFFFOOOO____TTTTRRRRIIIIGGGGGGGGEEEERRRR____8888
X		     _N_S_1_6_5_5_0_A, only.
X		     The FIFOs are enabled and the receiver FIFO trigger
X		     level is set to 8 characters.
X
X		  FFFFIIIIFFFFOOOO____TTTTRRRRIIIIGGGGGGGGEEEERRRR____11114444
X		     _N_S_1_6_5_5_0_A, only.
X		     The FIFOs are enabled and the receiver FIFO trigger
X
X
X	  Rev. Release 2.11.0					    Page 12
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X		     level is set to 14	characters.
X
X	       Note that you can set these values even if the respective
X	       UART doesn't have FIFOs,	in which case they are ignored.	 If
X	       you later upgrade to a UART with	FIFOs the FIFO control
X	       values automatically become active without having to build a
X	       new kernel.
X
X	  SELECTING ALTERNATIVE	BAUD RATES
X	       The UNIX	_t_e_r_m_i_o(7|M) interface only supports baud rates of
X	       up to 38400 bps.	 However, with the advent of V32bis and
X	       faster modems with compression ratios of	up to 4:1 (V.42bis)
X	       this upper baud rate boundary isn't adequate anymore.  Baud
X	       rates of	57600 or even 115200 are necessary to make full	use
X	       of these	modems.
X
X	       _F_A_S provides these high baud rates even though the
X	       _t_e_r_m_i_o(7|M) interface doesn't know them.	 To make this work,
X	       _F_A_S has one or more baud	rate tables in _s_p_a_c_e._c
X	       (_f_a_s__b_a_u_d[][]) which contain the	baud rate base and the 15
X	       baud rates that correspond to B50 to B38400.  Arbitrary baud
X	       rates can be assigned to	these baud rate	symbols.  Baud rate
X	       table 0 by default contains the standard	baud rates that
X	       coincide	with the standard _t_e_r_m_i_o(7|M) baud rates.  Table 1
X	       contains	the same values	for the	first 13 baud rates.  How-
X	       ever, B19200 is assigned	to a baudrate of 57600 and B38400
X	       is assigned to 115200 bps.  These values	are the	default	in
X	       the _F_A_S distribution, and you can change	these tables to
X	       whatever	values you need.
X
X	       Note, however, that the baud rate base in this table has	to
X	       be dividable by all 15 baud rate	values without remainder,
X	       or at least with	a very small remainder.	 Otherwise there
X	       would be	a noticeable deviation between the requested and
X	       the actually used baud rate.  It	helps a	little that _F_A_S
X	       rounds the result of this division to minimize the devia-
X	       tion.
X
X	       Note also that it isn't advisable to use	the B50	and B75
X	       symbols for 57600 and 115200 bps.  This has two reasons.
X
X	       In the worst case (SCO UNIX and Xenix) _F_A_S transfers the
X	       characters between its ring buffers and the UNIX	CLIST
X	       buffers only every 17 milliseconds.  This optimizes perfor-
X	       mance and reduces the CPU load.	Now, there are certain baud
X	       rate dependent threshold	values that limit the number of
X	       characters the CLIST buffers can	hold.  This is to reduce
X	       the drain time of the output buffers.  So, at low baud rates
X	       these thresholds	are very low, and because _F_A_S transfers
X	       characters only 60 times	a second, the maximum throughput
X	       for transmitted characters is threshold * 60.  One can
X	       easily calculate	that the threshold has to be at	least 192
X	       characters for 115200 bps (11520	cps).  A sufficient
X
X
X	  Rev. Release 2.11.0					    Page 13
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X	       threshold is only provided for baud rates >= B9600.
X
X	       Because the threshold table in the UNIX kernel is a global
X	       object that is also used	by other drivers, _F_A_S can't simply
X	       override	these values.  So max. throughput is only possible
X	       with baud rate table positions of B9600 or better.
X
X	       The other reason	not to use B50 etc. is that programs like
X	       _v_i and _e_m_a_c_s make their behaviour dependent on the baud rate
X	       of the tty they run on.	And this behaviour clearly wouldn't
X	       fit baud	rates like 57600 and 115200.
X
X	       Therefore, even if it looks tempting to use baud	rate sym-
X	       bols that aren't	in use anymore today (like B50 and B75),
X	       just don't do it.  It won't work	very well.
X
X	       So we have two or more baud rate	tables in _s_p_a_c_e._c, one for
X	       the standard _t_e_r_m_i_o(7|M)	assignment and the others for
X	       non-standard baud rates.	 You can select	which table to use
X	       for each	port by	simply putting the table number	in the
X	       _f_a_s__b_t__s_e_l_e_c_t[] array in	_s_p_a_c_e._c.  Provided you use the
X	       default baud rate table values you would	use a table selec-
X	       tor value of 0000 for ports	that should have the standard
X	       _t_e_r_m_i_o(7|M) baud	rate assignment, and a value of	1111 to have
X	       57600 and 115200	bps available instead of 19200 and 38400
X	       bps.
X
X	       Note: At	speeds of more than 38400 bps it is likely that
X		     even an _N_S_1_6_5_5_0_A will lose	incoming characters because
X		     in	many UNIX flavors the worst case interrupt latency
X		     is	rather high.  It has to	be <= 1	ms or you are in
X		     trouble.  This problem is caused by the UNIX kernel
X		     design.  _F_A_S can't	do anything about it.  ISC UNIX
X		     3.0, for instance,	on a 486/33 works fine at this
X		     speed.  On	the other hand,	ISC UNIX 2.x can't handle
X		     it.  You may want to look at the description of
X		     LOW_INT_LAT in section TTTTRRRROOOOUUUUBBBBLLLLEEEE----SSSSHHHHOOOOOOOOTTTTIIIINNNNGGGG, subsection
X		     CCCChhhhaaaarrrraaaacccctttteeeerrrr lllloooossssssss.
X
X	       Additionally to having higher baud rates	available, this
X	       table based baud	rate selection mechanism can be	used to
X	       support serial cards that don't use the standard	1.8432 MHz
X	       oscillator frequency.  For instance, if you have	a card that
X	       is equiped with a 3.6864	MHz oscillator you would have the
X	       additional baud rates of	57600, 76800, 96000 and	115200
X	       available (you shouldn't	use more than 115200 because that
X	       loads the CPU too much).	 Just enter the	baud rate base
X	       (3686400	/ 16 = 230400) and the 15 baud rates into one of
X	       the baud	rate tables in _f_a_s__b_a_u_d[][] and	select the respec-
X	       tive table in _f_a_s__b_t__s_e_l_e_c_t[].
X
X	       Note that _V_P/_i_x programs	which use serial ports will select
X	       wrong baud rates	on ports that are driven by a non-standard
X
X
X	  Rev. Release 2.11.0					    Page 14
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X	       oscillator, unless they know about the different	oscillator
X	       frequency.
X
X	       Note also that whatever baud rate is actually used, the UNIX
X	       application programs still know only the	standard
X	       _t_e_r_m_i_o(7|M) baud	rates.	So don't wonder	if _s_t_t_y	shows you
X	       38400 bps on a port that	in fact	runs at	115200 bps.  _F_A_S
X	       hides the real baud rate	from the rest of the UNIX kernel
X	       and the application programs.  That's the only way these
X	       additional baud rates can work at all.
X
X	  CABLING
X	       Cabling depends on the serial card and the device that you
X	       want to connect.
X
X	     Connecting	a modem
X	       The most	common case is connecting a modem to a computer.
X	       "Dumb"-port cards in an IBM-AT compatible computer usually
X	       act as a	DTE device and have a male connector while modems
X	       are DCE devices and have	a female connector.  So	all you
X	       need is an extension cable with a male connector	on one side
X	       and a female connector on the other side.
X
X	       The cable has to	have wires for at least	the signals TTTTDDDD,	RRRRDDDD,
X	       RRRRTTTTSSSS, CCCCTTTTSSSS, DDDDSSSSRRRR, DDDDCCCCDDDD, DDDDTTTTRRRR,	RRRRIIII and GGGGNNNNDDDD.  On	a D-Sub	25 RS232C
X	       connector these are the pin numbers 2222, 3333, 4444, 5555, 6666, 8888, 22220000, 22222222
X	       and 7777, respectively, and	the wireing scheme has to be
X	       "straight through", that	is, none of the	wires are crossed.
X	       For the cabling of less common devices please look at the
X	       manuals for further details.
X
X	       In all cases, though, use shielded cables wherever you can,
X	       especially with high baud rates!	 Shielded cables are better
X	       protected against electromagnetic interferences and there-
X	       fore help to prevent data corruption during transmission.
X	       Also, make the cables as	short as possible.
X
X	       However,	don't leave unused input lines (CCCCTTTTSSSS, DDDDCCCCDDDD, DDDDSSSSRRRR, RRRRIIII)
X	       open!  Due to crosstalking from other lines these input
X	       lines might change their	logic level, resulting in all sorts
X	       of problems (bad	throughput, blocked character output etc.).
X	       Therefore, you should connect any unused	input line to GGGGNNNNDDDD
X	       (pin 7777 on the D-Sub 25 RS232C connector).
X
X	       Additionally, you should	use the	proper operating mode (via
X	       the minor device	number)	for your application, for instance,
X	       if the connected	device doesn't have hardware flow control,
X	       you should use a	mode where hardware flow control is dis-
X	       abled.  The same	is true	for modem control.
X
X	     Connecting	two UNIX systems
X	       If you want to connect two UNIX systems (both using _F_A_S)	via
X	       a null modem cable, and if you want to run a _g_e_t_t_y on both
X
X
X	  Rev. Release 2.11.0					    Page 15
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X	       ends you	need to	modify the _s_p_a_c_e._c file	to prevent both
X	       _g_e_t_t_ys from chatting with each other, wasting valuable CPU
X	       time.
X
X	       Remove the EEEEIIII____DDDDTTTTRRRR macro for the desired port from the ini-
X	       tializer	part of	the _f_a_s__m_o_d_e_m[]	array.	This will cause	DDDDTTTTRRRR
X	       to be asserted only on dialout.	Therefore, the _g_e_t_t_y will
X	       become alive only if a dialout on the other side	is in pro-
X	       gress.
X
X	       Also, replace the HHHHOOOO____CCCCTTTTSSSS____OOOONNNN____DDDDSSSSRRRR macro in	the _f_a_s__f_l_o_w[]
X	       array with HHHHOOOO____CCCCTTTTSSSS.  This	will cause CCCCTTTTSSSS to be used for
X	       hardware	output flow control regardless of the state of DDDDSSSSRRRR.
X
X	       The required null modem cable needs to cross TTTTDDDD/RRRRDDDD, RRRRTTTTSSSS/CCCCTTTTSSSS
X	       and DDDDTTTTRRRR/DDDDCCCCDDDD.  The following diagram shows the wireing scheme
X	       for DTE D-Sub 25	connectors on both sides.
X
X		    D-Sub 25   System A		       System B
X		    ========   ========		       ========
X			2	 TD  --------\ /-------- TD
X					      X
X			3	 RD  --------/ \-------- RD
X
X			4	 RTS --------\ /-------- RTS
X					      X
X			5	 CTS --------/ \-------- CTS
X
X		       20	 DTR --------\ /-------- DTR
X					      X
X			8	 DCD --------/ \-------- DCD
X
X			6	 DSR --\	     /-- DSR
X					>-\	  /-<
X		       22	 RI  --/   \	 /   \-- RI
X					    >---<
X			7	 GND ------/	 \------ GND
X
X	       Note that DDDDSSSSRRRR and RRRRIIII are	directly connected to GGGGNNNNDDDD on each
X	       side so that they can't catch electromagnetic interferences.
X
X	     Connecting	a mouse
X	       Another caveat is connecting a mouse or some other pointer
X	       device to an _F_A_S	port.  There are many mice on the market
X	       that don't handle the modem and hardware	flow control lines
X	       in a proper way.	 Therefore, they should	be connected to	a
X	       port with a minor device	number of 0000 + device #.	 This dis-
X	       ables any modem or hardware flow	control	and prevents the
X	       device from locking up under certain circumstances.
X
X	       You may also want to refer to the section UUUUAAAARRRRTTTT FFFFIIIIFFFFOOOO CCCCOOOONNNNTTTTRRRROOOOLLLL
X	       if your mouse is	connected to a port driven by a	UART with
X	       FIFOs.
X
X
X	  Rev. Release 2.11.0					    Page 16
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X	  MODEM	SETUP
X	       _F_A_S has certain requirements for	the modem setup	that must
X	       be met in order to avoid	problems during	operation.
X
X	       If modem	control	should be used (carrier	sensing	with DDDDCCCCDDDD
X	       and hangup control with DDDDTTTTRRRR), you need to program the modem
X	       in the following	way:
X
X		  DDDDTTTTRRRR high->low	causes the modem to drop the connection
X		  (hangup) and resets the modem	to its power-on	default
X		  setup.  Additionally,	when the modem is in answer mode
X		  (for dialin) it shouldn't answer calls if DDDDTTTTRRRR	is low.
X
X		  DDDDCCCCDDDD is set high when there is	a carrier detected or
X		  rather, to be	precise, when the connection procedure
X		  between the two modems is finished and the modems are
X		  ready	to transfer user data.	DDDDCCCCDDDD is dropped to low if
X		  the modem senses that	the connection to the other modem
X		  is lost (e.g.	no carrier).
X
X	       If hardware flow	control	should be used (CCCCTTTTSSSS for	output
X	       direction and RRRRTTTTSSSS for input direction), you need	this setup:
X
X		  RRRRTTTTSSSS signals to the modem whether the DTE (e.g. the com-
X		  puter) can accept data or not.  High means the DTE can
X		  accept data while low	means that the modem should stop
X		  sending data to the DTE.
X
X		  CCCCTTTTSSSS signals to the DTE whether the modem can accept data
X		  or not.  High	means the modem	can accept data	while low
X		  means	that the DTE should stop sending data.
X
X		  DDDDSSSSRRRR is always	on.  This line acts as a gate for the CCCCTTTTSSSS
X		  signal.  _F_A_S ignores CCCCTTTTSSSS if DDDDSSSSRRRR is low, so DDDDSSSSRRRR has to	be
X		  always high to make sure that	_F_A_S always pays	attention
X		  to CCCCTTTTSSSS.
X
X		  Note that the	behaviour of RRRRTTTTSSSS and CCCCTTTTSSSS (as described
X		  above) is called bidirectional or full duplex	hardware
X		  flow control.	 Don't select half duplex hardware flow
X		  control with modern highspeed	modems!
X
X	       By default, _F_A_S uses both modem and hardware flow control so
X	       you have	to make	sure that in your modem	DDDDTTTTRRRR, DDDDCCCCDDDD, RRRRTTTTSSSS, CCCCTTTTSSSS
X	       and DDDDSSSSRRRR work the	way described above.
X
X	       If your modem can't handle modem	and/or hardware	flow con-
X	       trol you	have to	use a different	minor device number for
X	       this device that	disables the respective	feature.  Otherwise
X	       lockups and malfunctions	could occure.  Look at section
X	       OOOOPPPPEEEERRRRAAAATTTTIIIINNNNGGGG MMMMOOOODDDDEEEESSSS AAAANNNNDDDD MMMMIIIINNNNOOOORRRR DDDDEEEEVVVVIIIICCCCEEEE	NNNNUUUUMMMMBBBBEEEERRRRSSSS	for a description
X	       of possible operating modes (minor device numbers).
X
X
X
X	  Rev. Release 2.11.0					    Page 17
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X	       Here are	a few additional hints for the modem setup:
X
X		  If you program the modem to answer calls (dialin mode)
X		  you should make sure that the	modem escape code character
X		  which	allows online access to	the modem command mode is
X		  disabled.  Otherwise,	the escape code	sequence typed in
X		  at the remote	side is	echoed by the local computer and
X		  causes the local modem to switch to command mode as well.
X		  At this stage, only a	hangup will reactivate the modem
X		  port.	 Modems	with an	AT command set disable the escape
X		  code with
X
X		       AT S2=128
X
X		  If you want to dial in and out on the	same modem port	the
X		  modem's power-on default setup should	be tailored for
X		  dialin mode (incl. auto answer eeeennnnaaaabbbblllleeee).  When	a dialout
X		  takes	place the dialout application provides the neces-
X		  sary modem commands to switch	the modem to dialout mode
X		  (incl. auto answer ddddiiiissssaaaabbbblllleeee) and then does the	actual
X		  dialout.  After the dialout is finished _F_A_S makes sure
X		  that DDDDTTTTRRRR is dropped for a second which resets	the modem
X		  to its power-on defaults so that the modem is	in dialin
X		  mode,	again.
X
X	  TROUBLE-SHOOTING
X	       There are a number of know problems that	you might encounter
X	       when you	are using _F_A_S.	They are usually caused	either by a
X	       configuration error or by limitations of	the hard- and
X	       software	environment _F_A_S	has to work in.
X
X	     Character loss
X	       A common	problem	with fast serial data transmission is that
X	       the receiving side occasionally drops characters.  The rea-
X	       son for this lies in the	ancient	UART devices used in many
X	       286/386 systems:	 the _8_2_5_0 (not supported by _F_A_S) and the
X	       _N_S_1_6_4_5_0.
X
X	       They have only one receiver character buffer.  This implies
X	       that the	operating system must read a character from this
X	       buffer before the next one arrives from the UART's shift
X	       register.  For the old IBM PC with DOS this was sufficient.
X	       But for UNIX and	with baud rates	as high	as 115200 this is
X	       just a bad joke.
X
X	       UNIX is not a real-time operating system.  This means that
X	       its kernel isn't	optimized for fast interrupt response.
X	       With properly designed hardware that buffers data until the
X	       OS has time to fetch it this is no problem.  But	since UNIX
X	       for PCs has to work with	the standard hardware found in
X	       286/386 systems,	serial driver developers have to cope with
X	       the _N_S_1_6_4_5_0 UARTs which are in there simply to be compatible
X	       with IBM	PCs, XTs and ATs under DOS.
X
X
X	  Rev. Release 2.11.0					    Page 18
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X	       With this hardware it is	impossible to make it work at high
X	       baud rates without a major redesign of the USL supplied UNIX
X	       kernel.	But then it wouldn't be	UNIX SYSV any more.
X
X	       Fortunately, there is a pin-to-pin replacement available
X	       from National Semiconductors:  the _N_S_1_6_5_5_0_A.
X
X	       This device has separate	16 character FIFOs for the receiver
X	       and the transmitter.  With these	FIFOs the interrupt latency
X	       of the kernel can be quite high without losing characters.
X	       And because with	most interrupts	several	characters are pro-
X	       cessed at once the CPU is loaded	much less.
X
X	       So, as _F_A_S supports _N_S_1_6_5_5_0_A UARTs, all you have	to do to
X	       fix the character loss problem is to either buy a serial
X	       card with _N_S_1_6_5_5_0_A chips	on it or replace the UARTs on the
X	       card that you already have.
X
X	       If for some reason you can't get	the _N_S_1_6_5_5_0_A chips you
X	       could use the _i_8_2_5_1_0 chips from Intel.  Although	they are
X	       much less efficient they	are still better than the _N_S_1_6_4_5_0.
X
X	       There are, however, some	conditions under which even the
X	       receiver	FIFO in	the _N_S_1_6_5_5_0_A UART can't	prevent	character
X	       loss:
X
X		  Other	kernel drivers
X		     Some kernel drivers may disable interrupts	for too
X		     long.  One	culprit	is the disk cache flush	routine.
X		     If	you configure your kernel with too many	cache
X		     buffers (_N_B_U_F parameter for USL derived UNIX) you may
X		     still lose	characters (at least at	38400 bps and
X		     above).
X
X		     Another candidate is _V_P/_i_x, or rather the kernel func-
X		     tions to support _V_P/_i_x.  This may also lead to lost
X		     characters	at very	high input speeds.
X
X		  Bus master controllers
X		     There are some bus	master disk controllers	(like the
X		     Adaptec 1540/1542 SCSI controller)	on the market that
X		     slow down the CPU so much during data transfer that it
X		     isn't fast	enough to process characters coming in at
X		     high baud rates.
X
X		     Therefore,	if you can configure your disk controller,
X		     don't use values that will	bring the CPU down to its
X		     knees.  Otherwise,	_F_A_S will lose incoming characters
X		     during disk I/O.
X
X	       If your operating system	has a low interrupt latency you	can
X	       define LOW_INT_LAT in the _M_a_k_e_f_i_l_e in order to set the
X	       receiver	FIFO trigger level from	4 (default) to 8
X
X
X	  Rev. Release 2.11.0					    Page 19
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X	       characters.  This cuts the receiver interrupt frequency in
X	       half and	therefore saves	a lot of CPU time.  That pays off
X	       especially at very high baud rates.
X
X	       If you set this flag you	should do some rigid tests (receiv-
X	       ing characters at the highest baud rate while the system	is
X	       heavily loaded with disk	and network I/O) to make sure that
X	       there are really	no lost	characters due to interrupt
X	       latency.	 ISC UNIX 3.0 is known to have a low tty interrupt
X	       latency,	therefore LOW_INT_LAT is defined in _M_a_k_e_f_i_l_e._I_S_C_3.
X	       On the other hand, ISC UNIX 2.x has a rather high interrupt
X	       latency and shouldn't have this flag set.  For other UNIX
X	       flavors you have	to find	out yourself whether this flag is
X	       applicable.
X
X	     Device lockups
X	       There are certain conditions under which	a device can lock
X	       up, that	is, at least one process that uses this	device
X	       waits for a tty I/O related event that apparently doesn't
X	       occure.
X
X	       The most	common case is that there are still characters in
X	       the output buffer, but the output is disabled for some rea-
X	       son.  Then the last process that	closes the tty device hangs
X	       in the _c_l_o_s_e(2|S) function until	the output buffer has
X	       drained.
X
X	       Tty output may be stopped by the	software (XON/XOFF) or
X	       hardware	(RRRRTTTTSSSS/CCCCTTTTSSSS, by default) flow control.  In	this case
X	       something seems to be wrong with	the cabling or the con-
X	       nected device.  Please check this first out before you blame
X	       _F_A_S.  Sometimes it helps	to switch the device off and on	a
X	       few times to unblock the	tty output.
X
X	       If this doesn't help the	last resort would be to	kill the
X	       process that hangs on the _F_A_S device, and if it still hangs,
X	       to open the respective device with the O_APPEND flag.  This
X	       flushes the output buffers and therefore	releases the hang-
X	       ing process.  To	do that, you simply type
X
X		    echo '\c' >> /dev/ttyF00
X
X	       if, for instance, the process is	hanging	on ttttttttyyyyFFFF00000000.  Don't
X	       omit the	backslash before the cccc!
X
X	       Another reason for a blocked output could be a lost
X	       transmitter interrupt.  If this isn't caused by a configura-
X	       tion error this usually indicates a hardware problem in your
X	       computer	which should be	fixed as soon as possible.  Other-
X	       wise, you can't run this	system unattended because it is	too
X	       unreliable.  All	you can	do after a transmitter interrupt is
X	       lost is to reboot the machine in	order to use the blocked
X	       _F_A_S device, again.
X
X
X	  Rev. Release 2.11.0					    Page 20
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X	       If interrupts are lost on IRQ2 this might have to do with an
X	       EGA or VGA video	card using this	IRQ line for the vertical
X	       retrace interrupt.  This	interrupt isn't	used at	all these
X	       days, neither under DOS nor UNIX.  It's simply there for
X	       compatibility.
X
X	       On some video cards (the	more expensive ones) there is a
X	       jumper or dip switch to disable the vertical retrace inter-
X	       rupt.  On the rest you have to cut the trace to the bus con-
X	       tact B4 with a sharp knife.  This contact is on the solder
X	       side of the video card, the fourth bus contact counted from
X	       the side	where the 9 or 15 pin D-SUB connector to the moni-
X	       tor is located.	Cutting	this trace has the same	effect as
X	       pulling the IRQ2	jumper on other	cards.
X
X	       Note that cutting the trace will	void your video	card's war-
X	       ranty.
X
X	       Now IRQ2	should be available for	use with _F_A_S.  Look at the
X	       _I_N_S_T_A_L_L_A_T_I_O_N file for details on	how to configure _F_A_S for
X	       IRQ2.  This is operating	system dependent.
X
X	       And there is a rare case	which has to do	with the number	of
X	       available CLIST buffers in the UNIX kernel.  The	UNIX output
X	       and input buffers are 256 bytes each (by	default).  If for
X	       some reason the output of a tty device is stopped but a pro-
X	       cess continues to send data one character at a time this
X	       uses up one CLIST buffer	for every charcacter.  If the
X	       number of CLIST buffers in the kernel is	less than 222255556666 all
X	       CLIST buffers will be busy eventually.
X
X	       The dangerous thing here	is that	the pool of CLIST buffers
X	       is used by all tty devices of the system.  Therefore, if	one
X	       single tty device manages to eat	up all available CLIST
X	       buffers all tty in- and output comes to a halt.	If this
X	       happens you can't access	your machine any more, not even
X	       from the	operator console.  Although the	system is still
X	       alive internally.
X
X	       Unfortunately, many UNIX	vendors	have put a negligently low
X	       number-of-CLIST-buffers parameter into their kernel tune
X	       files.  You should increase it to a value that makes it
X	       impossible that one device alone	can occupy all CLIST
X	       buffers (it's the _N_C_L_I_S_T	parameter under	USL derived UNIX
X	       SVR[34].x).  A value of 444400000000 should be sufficient.
X
X	     Background	processes and _g_e_t_t_y problems
X	       Due to the design of the	SysV kernel there might	be problems
X	       with _g_e_t_t_y when the previous dialup user	on the respective
X	       port was	using background processes.  Unfortunaley, _F_A_S
X	       can't do	much about it.
X
X	       The reason for these problems is	that when a device is held
X
X
X	  Rev. Release 2.11.0					    Page 21
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X	       open by some process there can be no _g_e_t_t_y waiting for car-
X	       rier on this device.  Notice that we are	talking	about the
X	       ssssaaaammmmeeee logical device for both the	offending process and
X	       _g_e_t_t_y.  This has	nothing	to do with the built-in	modem line
X	       sharing for dialin and dialout.
X
X	       There are two problematic situations:
X
X		  1. _g_e_t_t_y has already blocked in the _o_p_e_n(2|S)	function
X		     and is waiting for	the carrier.  Another process now
X		     opens the device with O_NDELAY.  Because the device is
X		     open after	this there is no way for _g_e_t_t_y to remain in
X		     the carrier waiting state.	 Therefore _g_e_t_t_y is waked
X		     up	and completes its _o_p_e_n(2|S) call as if the carrier
X		     were present.  Of course, as the carrier isn't really
X		     there, subsequent _r_e_a_d(2|S) and _w_r_i_t_e(2|S)	calls will
X		     return immediately	with an	EOF condition.	_g_e_t_t_y just
X		     exits in this case.
X
X		  2. A background process holds	the device open	when _g_e_t_t_y
X		     is	respawned by _i_n_i_t.  _g_e_t_t_y's _o_p_e_n(2|S) call suc-
X		     ceedes immediately	because	it can't block and wait	for
X		     the carrier due to	the device already being held open
X		     by	the background process.	 Again,	subsequent
X		     _r_e_a_d(2|S) and _w_r_i_t_e(2|S) calls return EOF (provided
X		     that the carrier is missing) and _g_e_t_t_y exits.
X
X	       In both cases _i_n_i_t will immediately respawn new _g_e_t_t_ys and
X	       eventually gives	up with	a ``respawning too rapidly'' mes-
X	       sage on the console.  This disables dialins on this port	for
X	       at least	a couple of minutes.
X
X	       In this state you may notice that the DDDDTTTTRRRR line is low
X	       although	it should be high as the port is held open by the
X	       background process.  This is caused by the _F_A_S security
X	       feature that prevents modems from accepting calls when the
X	       port isn't ready	for logins.  This can save frequently cal-
X	       ling UUCP sites a lot of	money.	However, the security
X	       feature only makes the symptoms more visible, but it isn't
X	       the cause of the	_g_e_t_t_y problems.
X
X	       While the first case above happens rarely (usually due to a
X	       configuration error) the	second case is more common.  The
X	       reason is that dialup users start background processes and
X	       then log	off or drop the	line.  If the background process
X	       was started by a	job control shell it runs in its own pro-
X	       cess group and therefore	doesn't	receive	the SIGHUP signal
X	       sent by _F_A_S on carrier loss.  It	is the responsibility of
X	       the shell to notice either the SIGHUP or	the EOF	condition
X	       and to then kill	its child (background) processes before
X	       exiting.	 Unfortunately,	not all	job control shells do this
X	       reliably.
X
X
X
X	  Rev. Release 2.11.0					    Page 22
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X	       Another problem is that under some UNIX flavors the _c_s_h
X	       automatically disables SIGHUP for all background	processes
X	       it starts.  So these processes have no chance to	terminate
X	       when the	carrier	drops.
X
X	       Whatever	causes the background processes	to survive the log-
X	       off or carrier drop, it causes massive problems with _g_e_t_t_y
X	       as described above.  If you see these effects on	your
X	       machine,	and it can't be	cured by using a better	(in this
X	       respect)	shell, your only option	is to convince your dialup
X	       users to	either not use any background processes	or to
X	       redirect	ssssttttddddiiiinnnn, ssssttttddddoooouuuutttt and ssssttttddddeeeerrrrrrrr to some files so that the
X	       processes don't hold the	device open.  If you or	your users
X	       can't live without background processes on dialup lines you
X	       may want	to install the _s_c_r_e_e_n virtual tty multiplexer which
X	       allows several independent screens to run programs even
X	       while you are logged off.  _s_c_r_e_e_n or _i_s_c_r_e_e_n should be
X	       available on every GNU archive server.
X
X	     Crashes or	video problems at boot time
X	       Several vendors of video	cards with the S3 chip set (maybe
X	       with other chip sets as well) were stupid enough	to use the
X	       I/O address 0000xxxx2222eeee8888 for their own purpose.	 This address, how-
X	       ever, has been used, at least inofficially, for the COM4
X	       port since the days the IBM AT came out.
X
X	       So what happens if you have such	a video	card in	your com-
X	       puter together with an enabled COM4 port	is that	_F_A_S writes
X	       to the port at boot time	(in order to detect it)	and actu-
X	       ally writes to the video	card as	well, because of the over-
X	       layed I/O addresses.  This confuses the video card so that,
X	       for instance, the screen	gets dark, or it even manages to
X	       crash the system.
X
X	       The only	thing you can do in this situation is to physically
X	       disable the COM4	port (usually by some DIP switch or jumper)
X	       and to tell _F_A_S (via its	config files) not to use COM4.
X
X	  FILES
X	       /_d_e_v/_t_t_y_F??
X		  Dialout device with modem and	hardware flow control (by
X		  default).
X
X	       /_d_e_v/_t_t_y_F_M??
X		  Dialin device	with modem and hardware	flow control (by
X		  default).
X
X	  SEE ALSO
X	       _t_e_r_m_i_o(7|M), _s_i_g_n_a_l(2|S), _o_p_e_n(2|S), _c_l_o_s_e(2|S),	_r_e_a_d(2|S),
X	       _w_r_i_t_e(2|S), _f_c_n_t_l(2|S), _i_o_c_t_l(2|S), _g_e_t_t_y(1M|M),	_c_u(1C|C),
X	       _u_u_c_i_c_o(1M|C)
X
X	  BUGS
X
X
X	  Rev. Release 2.11.0					    Page 23
X
X
X
X
X
X
X	  FAS(7)		    UNIX System	V		     FAS(7)
X
X
X
X	       _F_A_S is not yet ported to	SVR4 STREAMS and therefore its
X	       functionality is	limited	under SVR4.
X
X	       DosMerge's virtual COM ports are	unsupported.
X
X	  COPYRIGHT
X	       Copyright (C) 1990-1993 Uwe Doering
X	       See the file _C_O_P_Y_I_N_G (distributed with the source code) for
X	       distribution rights and restrictions associated with this
X	       software.
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X	  Rev. Release 2.11.0					    Page 24
X
X
X
SHAR_EOF
echo 'File fas.7.cat is complete' &&
true || echo 'restore of fas.7.cat failed'
rm -f _shar_wnt_.tmp
fi
# ============= fas.c ==============
if test -f 'fas.c' -a X"$1" != X"-c"; then
	echo 'x - skipping fas.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting fas.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'fas.c' &&
X/* FAS Final Async Solution driver for 286/386 versions of System V UNIX */
X
X/* FAS was developed by
XUwe Doering <fas@geminix.in-berlin.de>
XBillstedter Pfad 17 b
X13591 Berlin
XGermany
X*/
X
X#if !defined (M_I286)
X#ident	"@(#)fas.c	2.11"
X#endif
X
X/* Note: This source code has been quite heavily optimized for speed.
X         You may wonder that register variables aren't used everywhere.
X         This is because there is an overhead in memory accesses
X         when using register variables. As you may know data accesses
X         usually need much more wait states on the memory bus than
X         code accesses (because of page or cache misses). Therefore,
X         saving some data accesses has higher priority than saving
X         code accesses.
X
X         You may also note some not very elegant constructions that
X         may be intentional because they are faster. If you want to
X         make style improvements you should check the assembler output
X         whether this wouldn't slow things down.
X
X         Decisions for speed optimization were based on assembler
X         listings produced by the standard UNIX V [34].X/386 C compiler.
X
X   IMPORTANT: On systems where FAS is to be compiled with the standard
X              UNIX C compiler the assembler output file is optimized
X              by an AWK script. That is, outb(), inb() and fas_mem_copy()
X              calls are substituted with inline i/o mnemonics. As the
X              intelligence of this script is limited it is necessary that
X              the port address argument of outb() and inb() is a simple
X              expression that allows the compiler to produce code that
X              fetches the address with a single load operation. Look at
X              the assembler output if you are in doubt about an expression.
X
X              This is a kludge but it is the method that produces the
X              fastest code with the standard UNIX C compiler.
X*/
X
X#include "fas.h"
X
X#if defined (__GNUC__) && !defined (NO_ASM)
X#if defined (XENIX)
X#define OUTB(port,val) \
X({\
X	__asm__ volatile ("outb %%al,%%dx" : : "d" ((uint) (port)), "a" ((unchar) (val)));\
X})
X
X#define INB(port) \
X({\
X	unchar __val;\
X	__asm__ volatile ("inb %%dx,%%al" : "=a" (__val) : "d" ((uint) (port)));\
X	__val;\
X})
X#else	/* XENIX */
X#define OUTB(port,val) \
X({\
X	__asm__ volatile ("outb (%%dx)" : : "d" ((uint) (port)), "a" ((unchar) (val)));\
X})
X
X#define INB(port) \
X({\
X	unchar __val;\
X	__asm__ volatile ("inb (%%dx)" : "=a" (__val) : "d" ((uint) (port)));\
X	__val;\
X})
X#endif	/* XENIX */
X
X#define FAS_MEM_COPY(dst,src,n) \
X({\
X	__asm__ volatile ("movl %2,%%ecx\n"\
X			"\tcld\n"\
X			"\tshrl $2,%%ecx\n"\
X			"\trep\n"\
X			"\tmovsl\n"\
X			"\tmovl %2,%%ecx\n"\
X			"\tandl $3,%%ecx\n"\
X			"\trep\n"\
X			"\tmovsb" : : "D" ((unchar *) (dst)),\
X						"S" ((unchar *) (src)),\
X						"r" ((uint) (n))\
X					: "D", "S", "c", "cc");\
X})
X
X/* We know better than gcc which variables should be in hard registers.
X   This seems to be the only method to force gcc to use a hard register
X   for a variable.
X*/
X#define REG_SI __asm__ ("%esi")
X#define REG_DI __asm__ ("%edi")
X#define REG_BX __asm__ ("%ebx")
X#define REG_CX __asm__ ("%ecx")
X#endif	/* __GNUC__ && !NO_ASM */
X
X#if !defined (__GNUC__) && !defined (NO_ASM) && !defined (XENIX)
X/* fas_mem_copy () is expanded to inline assembler code by the optimizing
X   AWK script (see above).
X*/
X#define FAS_MEM_COPY(dst,src,n) fas_mem_copy (dst, src, n)
Xextern void	fas_mem_copy ();
X
X/* Define `OPTIM' for uPort, ISC doesn't know about `.optim', but has turned
X   on optimization by default, so we don't need it there anyway.
X*/
X#if defined (OPTIM)
X/* This function inserts the address optimization assembler pseudo-op
X   wherever called.
X*/
X
Xasm	void optim ()
X{
X	.optim
X}
X
X/* This dummy function has nothing to do but to call optim so that
X   the `.optim' assembler pseudo-op will be included in the assembler
X   file. This must be the first of all functions.
X*/
X
Xstatic void
Xdummy ()
X{
X	optim ();
X}
X#endif	/* OPTIM */
X#endif	/* !__GNUC__ && !NO_ASM && !XENIX */
X
X#if !defined (REG_SI)
X#define REG_SI
X#endif
X#if !defined (REG_DI)
X#define REG_DI
X#endif
X#if !defined (REG_BX)
X#define REG_BX
X#endif
X#if !defined (REG_CX)
X#define REG_CX
X#endif
X
X#if defined (NEED_PUT_GETCHAR)
X#if defined (SCO) || defined (XENIX)
X#define FASPUTCHAR sioputchar
X#define FASGETCHAR siogetchar
X#else
X#define FASPUTCHAR asyputchar
X#define FASGETCHAR asygetchar
X#endif
X#endif
X
X#if defined (PROFILE)
X#define STATIC
X#else
X#define STATIC static
X#endif
X
X/* The following defines are used to access multiplexed ports. */
X#define FAS_FIRST_CTL(fip,port) \
X	((void) (((fip)->device_flags & DF_CTL_FIRST)\
X			? OUTB (CTL_PORT.addr, (port).p.ctl)\
X			: 0))
X
X#define FAS_EVERY_CTL(fip,port) \
X	((void) (((fip)->device_flags & DF_CTL_EVERY)\
X			? OUTB (CTL_PORT.addr, (port).p.ctl)\
X			: 0))
X
X#define FAS_CTL(fip,port) \
X	((void) (((fip)->device_flags & (DF_CTL_FIRST | DF_CTL_EVERY))\
X			? OUTB (CTL_PORT.addr, (port).p.ctl)\
X			: 0))
X
X#define FAS_FIRST_OUTB(fip,port,val) \
X	((void) (((fip)->device_flags & (DF_CTL_FIRST | DF_CTL_EVERY))\
X			? OUTB (CTL_PORT.addr, (port).p.ctl)\
X			: 0),\
X		(void) OUTB ((port).addr, (val)))
X
X#define FAS_OUTB(fip,port,val) \
X	((void) (((fip)->device_flags & DF_CTL_EVERY)\
X			? OUTB (CTL_PORT.addr, (port).p.ctl)\
X			: 0),\
X		(void) OUTB ((port).addr, (val)))
X
X#define FAS_SAME_OUTB(fip,port,val) \
X	((void) OUTB ((port).addr, (val)))
X
X#define FAS_FIRST_INB(fip,port) \
X	((void) (((fip)->device_flags & (DF_CTL_FIRST | DF_CTL_EVERY))\
X			? OUTB (CTL_PORT.addr, (port).p.ctl)\
X			: 0),\
X		INB ((port).addr))
X
X#define FAS_INB(fip,port) \
X	((void) (((fip)->device_flags & DF_CTL_EVERY)\
X			? OUTB (CTL_PORT.addr, (port).p.ctl)\
X			: 0),\
X		INB ((port).addr))
X
X#define FAS_SAME_INB(fip,port) \
X	(INB ((port).addr))
X
X/* The following defines are used to take apart the minor device numbers. */
X#define GET_UNIT(dev)		((dev) & 0x0f)
X#define GET_OPEN_MODE(dev)	(fas_open_modes [((dev) >> 4) & 0x0f])
X
X/* Lock device against concurrent use. */
X#define GET_DEVICE_LOCK(fip,prio) \
X{\
X	/* sleep while device is used by an other process */\
X	while ((fip)->device_flags & DF_DEVICE_LOCKED)\
X		(void) sleep ((caddr_t) &(fip)->tty, (prio));\
X	(fip)->device_flags |= DF_DEVICE_LOCKED;\
X}
X
X/* Release device. */
X#define RELEASE_DEVICE_LOCK(fip) \
X{\
X	(fip)->device_flags &= ~DF_DEVICE_LOCKED;\
X	/* wakeup the process that may wait for this device */\
X	(void) wakeup ((caddr_t) &(fip)->tty);\
X}
X
X/* Schedule event. */
X#define EVENT_SCHED(fip,event) \
X{\
X	(fip)->event_flags |= (event);\
X	if (!event_scheduled)\
X	{\
X		event_scheduled = TRUE;\
X		(void) timeout (fas_event, (caddr_t) NULL, 1);\
X	}\
X}
X
X/* Put character into receiver ring buffer. */
X#define PUT_RECV_BUFFER(fip,ring_ptr,c) \
X{\
X	*(ring_ptr) = (c);\
X	if (++(ring_ptr) == &(fip)->recv_buffer [RECV_BUFF_SIZE])\
X		(ring_ptr) = &(fip)->recv_buffer [0];\
X}
X
X#if !defined (FAS_MEM_COPY)
X/* Define the base 2 logarithm of x in the range of 1 to 16 (for shifting). */
X#define LOG2(x) \
X((x) == 1 ? 0 :\
X (x) == 2 ? 1 :\
X (x) == 4 ? 2 :\
X (x) == 8 ? 3 :\
X (x) == 16 ? 4 : 0)
X
X/* This is the generic version. */
X#define FAS_MEM_COPY(dst,src,n) \
X{\
X	register unchar	*srcptr REG_SI;\
X	register unchar	*destptr REG_DI;\
X	register uint	num_to_xfer REG_BX;\
X\
X	num_to_xfer = num_save;\
X	srcptr = tmp_srcptr;\
X	destptr = tmp_destptr;\
X\
X	/* do the transfer */\
X	if (num_to_xfer >= sizeof (uint) * 2)\
X	{\
X		/* do multi-byte transfers */\
X		num_to_xfer >>= LOG2 (sizeof (uint));\
X		do\
X		{\
X			*((uint *) destptr) = *((uint *) srcptr);\
X			srcptr += sizeof (uint);\
X			destptr += sizeof (uint);\
X		} while (--num_to_xfer);\
X\
X		num_to_xfer = num_save;\
X		if (num_to_xfer &= sizeof (uint) - 1)\
X		{\
X			/* do the rest with single-byte transfers */\
X			do\
X			{\
X				*destptr = *srcptr;\
X				++srcptr;\
X				++destptr;\
X			} while (--num_to_xfer);\
X		}\
X	}\
X	else\
X	{\
X		/* do single-byte transfers */\
X		do\
X		{\
X			*destptr = *srcptr;\
X			++srcptr;\
X			++destptr;\
X		} while (--num_to_xfer);\
X	}\
X}
X#endif
X
X/* Functions provided by this driver. */
Xvoid		fasinit P((void));
Xvoid		fasopen P((dev_t dev, int flag, int otyp));
Xvoid		fasclose P((dev_t dev, int flag, int otyp));
Xvoid		fasread P((dev_t dev));
Xvoid		faswrite P((dev_t dev));
Xvoid		fasproc P((struct tty *ttyp, int cmd));
Xvoid		fasioctl P((dev_t dev, int cmd, union ioctl_arg arg, int mode));
Xvoid		fasintr P((int vect));
XSTATIC n_unchar	fas_rproc P((struct fas_internals *fip, n_unchar line_status));
XSTATIC void	fas_xproc P((struct fas_internals *fip));
XSTATIC void	fas_open_device P((struct fas_internals *fip));
XSTATIC void	fas_close_device P((struct fas_internals *fip));
XSTATIC void	fas_param P((struct fas_internals *fip, int init_type));
XSTATIC void	fas_pos_by_speed P((struct fas_internals *fipp));
XSTATIC void	fas_event P((void *dummy));
XSTATIC void	fas_mproc P((struct fas_internals *fip));
XSTATIC bool	fas_rxfer P((struct fas_internals *fipp));
SHAR_EOF
true || echo 'restore of fas.c failed'
fi
echo 'End of  part 4'
echo 'File fas.c is continued in part 5'
echo 5 > _shar_seq_.tmp
exit 0
