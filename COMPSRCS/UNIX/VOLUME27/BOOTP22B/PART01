Newsgroups: comp.sources.unix
From: gwr@mc.com (Gordon W. Ross)
Subject: v27i063: bootp-2.2.B - RFC 1048 "bootp" server (w/ vendor extensions), Part01/02
Message-id: <1.750376278.23845@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: gwr@mc.com (Gordon W. Ross)
Posting-Number: Volume 27, Issue 63
Archive-Name: bootp-2.2.B/part01

This is an enhanced version of the CMU BOOTP server (2.2 alpha)
developed by Walter L. Wimer and Drew D. Perkins.

The original BOOTP server was designed and implemented by Bill Croft
at Stanford.  Much of the credit for the ideas and code goes to him.
Walter L. Wimer and Drew D. Perkins implemented all of the code
in this version except for the function dovend_rfc1048() which
I redesigned to make it preserve the client's option template.

I tried several times to reach the authors of this program, but
have not been able to contact them.  (Help would be appreciated.)
Therefore, I have decided to make this version of the BOOTP server
available and will maintain it unless WLW or DDP want to do so.

New features in version 2.2.B that were not in version 2.2:

o  The server now handles clients that need the server to honor the
   format of the options area in the request packet (by sending the
   response with options in exactly the same layout).

o  The server now supports clients that use an extended option area
   (by extending the existing option area to the end of the packet).

o  Source compatibility with SVR4 (and Solaris 2.X) thanks to
   changes graciously contributed by db@sunbim.be (Danny Backx).

Please direct questions, comments, and bug reports to:

	Gordon W. Ross  		Mercury Computer Systems
	gwr@mc.com      		199 Riverneck Road
	508-256-1300			Chelmsford, MA 01824-2820

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 2)."
# Contents:  Announce-2.0 Announce-2.1 Announce-2.2 Announce-2.2.B
#   MANIFEST Makefile README ToDo Version.c bootp.h bootpd.8 bootpd.h
#   bootptab bootptab.5 gmods hash.c hash.h newvers.sh
# Wrapped by vixie@gw.home.vix.com on Mon Oct 11 14:48:25 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Announce-2.0' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Announce-2.0'\"
else
echo shar: Extracting \"'Announce-2.0'\" \(1719 characters\)
sed "s/^X//" >'Announce-2.0' <<'END_OF_FILE'
XSubject: RFC-1048 compatible BOOTP server now available
X
X
XAn RFC-1048 (BOOTP Vendor Information Extensions) compatible BOOTP (RFC-951)
Xserver is now available for anonymous FTP from lancaster.andrew.cmu.edu
X(128.2.13.21).  The new server can be found in pub/bootp.2.0.tar.  This is
Xan enhanced version of the existing CMU BOOTP server which was derived from
Xthe original BOOTP server created by Bill Croft at Stanford.
X
XNew features and changes in version 2.0 include:
X
Xo  Full support for the vendor information extensions described in RFC-1048.
Xo  Faster response time (host lookup via hash table instead of linear search).
Xo  New termcap-like configuration file format which allows greater flexibility
X   in specifying the variable vendor information of RFC-1048.  Host entries
X   may refer to other hosts as templates so that redundant information need
X   be specified only once.
Xo  Continued support for the CMU vendor information format.  The server may
X   be configured on a per-host basis to always reply with a certain vendor
X   information format or to reply based on the client's request.
Xo  Expanded logging.
Xo  The server may now be run by inetd or as a standalone program like the
X   old version.
Xo  The configuration and debugging dump files may be specified on the command
X   line.
X
X
XThe server has been successfully tested on the following machines:
X
X    IBM RT PC running ACIS 4.3 (4.3 BSD)
X    Sun 3/50 running SunOS 3.5
X    DEC MicroVAX II running Ultrix 1.1
X    DEC MicroVAX II running Ultrix 2.2
X
X
X
XPlease direct questions, comments, and bug reports to
XWalt Wimer <ww0n@andrew.cmu.edu> or Drew Perkins <ddp@andrew.cmu.edu>.
X
X
X
XSincerely,
X
XWalt Wimer
XNetwork Development
XCarnegie Mellon University
END_OF_FILE
if test 1719 -ne `wc -c <'Announce-2.0'`; then
    echo shar: \"'Announce-2.0'\" unpacked with wrong size!
fi
# end of 'Announce-2.0'
fi
if test -f 'Announce-2.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Announce-2.1'\"
else
echo shar: Extracting \"'Announce-2.1'\" \(1534 characters\)
sed "s/^X//" >'Announce-2.1' <<'END_OF_FILE'
XSubject: Updated RFC1048 BOOTP server now available
X
XWell, no surprise, bootpd 2.0 had a few bugs.  A new improved version,
Xbootpd 2.1, is now available for anonymous FTP from lancaster.andrew.cmu.edu
X(128.2.13.21).  The new server can be found in pub/bootp.2.1.tar.
X
XBug fixes and improvements in version 2.1 include:
X
Xo  The definition of "access to the bootfile" has been changed to require the
X   public read access bit to be set.  This is required by tftpd(8), so the
X   server will not reply with a file which a client cannot obtain via TFTP.
Xo  The RFC1084 bootfile size tag has been implemented.  It allows either
X   automatic or manual specification of the bootfile size in 512-octet blocks.
Xo  Generic tags now work as advertised.
Xo  A subtle bug which caused strange parsing behavior under certain conditions
X   has been fixed.
Xo  The RFC1048 vendor information now has the correct byte order on
X   little-endien machines such as the VAX.
Xo  Failure to specify the bootfile home directory and/or default bootfile in
X   the configuration file no longer causes server crashes.  The server now
X   makes a reasonably intelligent choice if this configuration information is
X   missing.  This is documented in the man page.
Xo  BOOTP requests from clients which already know their IP addresses no longer
X   cause server crashes.
X
X
X
XPlease direct questions, comments, and bug reports to
XWalt Wimer <ww0n@andrew.cmu.edu> or Drew Perkins <ddp@andrew.cmu.edu>.
X
X
X
XGood luck,
X
XWalt Wimer
XNetwork Development
XCarnegie Mellon University
END_OF_FILE
if test 1534 -ne `wc -c <'Announce-2.1'`; then
    echo shar: \"'Announce-2.1'\" unpacked with wrong size!
fi
# end of 'Announce-2.1'
fi
if test -f 'Announce-2.2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Announce-2.2'\"
else
echo shar: Extracting \"'Announce-2.2'\" \(2101 characters\)
sed "s/^X//" >'Announce-2.2' <<'END_OF_FILE'
X
XNew features in version 2.2 include:
X
Xo  A new "td" tag allows the specification of a "TFTP directory" for use
X   with so-called "secure" implementations of tftpd which chroot(2) to a
X   particular directory.
X
Xo  A new "sa" tag allows the explicit specification of the TFTP
X   "server address."  Formerly, the 'siaddr' field of the BOOTREPLY was
X   always filled with the IP address of the BOOTP server.  The "sa" tag
X   now allows the BOOTP server and the TFTP server to be two different
X   machines, if desired.
X
Xo  The server now automatically determines whether it is running as a
X   standalone program (e.g. invoked by hand from a shell) or as a child of
X   /etc/inetd.  The -s option and a new -i option are provided to force
X   standalone or inetd mode if necessary.
X
Xo  When the vendor magic cookie is zero, BOOTP replies now default to the
X   RFC 1084 vendor format, rather than the old CMU format.  This helps
X   interoperability with uncooperative BOOTP clients which want RFC 1084
X   format but don't bother filling in the magic cookie properly to tell
X   the server... *sigh*  (This makes the ":vm=rfc1048:" tag unnecessary
X   in most cases now.  Oh, the "vm" tag now accepts "rfc1084" as well as
X   "rfc1048" -- they mean the same thing.)
X
Xo  Log messages now include the specific network type.  For example, rather
X   than saying "request from hardware address ABCDEF012345", the message is
X   now "request from Ethernet address ABCEDF012345", or "request from
X   IEEE802 address 4000A1B2C3D4".
X
X
XBug fixes in this version include:
X
Xo  The automatic bootfile-size calculation now works correctly when the
X   file size is an exact multiple of 512 octets.  It used to return a number
X   which was one 512-octet unit greater than necessary.
X
Xo  A bug in comparing subnet masks has been fixed.
X
Xo  A bug in calculating the size of the vendor information area when
X   inserting the hostname has been fixed.
X
X
XOther changes:
X
Xo  The man page has been split into two man pages.  One covers the server
X   itself (bootpd.8) and the other covers the configuration file format
X   (bootptab.5).
X
X
END_OF_FILE
if test 2101 -ne `wc -c <'Announce-2.2'`; then
    echo shar: \"'Announce-2.2'\" unpacked with wrong size!
fi
# end of 'Announce-2.2'
fi
if test -f 'Announce-2.2.B' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Announce-2.2.B'\"
else
echo shar: Extracting \"'Announce-2.2.B'\" \(1813 characters\)
sed "s/^X//" >'Announce-2.2.B' <<'END_OF_FILE'
XSubject: Enhanced RFC-1048 compatible BOOTP server now available
X
XAn RFC-1048 (BOOTP Vendor Information Extensions) compatible
XBOOTP (RFC-951) server is now available for anonymous FTP from
Xfirewall.mc.com (192.148.197.15).  A test program (BOOTP client)
Xis also available at the same location.  The file names are:
X	/outgoing/bootp-2.2.B.tar.Z	(BOOTP server)
X	/outgoing/bootptest-1.1.tar.Z	(BOOTP test program)
XThis is an enhanced version of the CMU BOOTP server (2.2 alpha)
Xdeveloped by Walter L. Wimer and Drew D. Perkins.
X
XThe original BOOTP server was designed and implemented by Bill Croft
Xat Stanford.  Much of the credit for the ideas and code goes to him.
XWalter L. Wimer and Drew D. Perkins implemented all of the code
Xin this version except for the function dovend_rfc1048() which
XI redesigned to make it preserve the client's option template.
X
XI tried several times to reach the authors of this program, but
Xhave not been able to contact them.  (Help would be appreciated.)
XTherefore, I have decided to make this version of the BOOTP server
Xavailable and will maintain it unless WLW or DDP want to do so.
X
XNew features in version 2.2.B that were not in version 2.2:
X
Xo  The server now handles clients that need the server to honor the
X   format of the options area in the request packet (by sending the
X   response with options in exactly the same layout).
X
Xo  The server now supports clients that use an extended option area
X   (by extending the existing option area to the end of the packet).
X
Xo  Source compatibility with SVR4 (and Solaris 2.X) thanks to
X   changes graciously contributed by db@sunbim.be (Danny Backx).
X
XPlease direct questions, comments, and bug reports to:
X
XGordon W. Ross  		Mercury Computer Systems
Xgwr@mc.com      		199 Riverneck Road
X508-256-1300			Chelmsford, MA 01824-2820
END_OF_FILE
if test 1813 -ne `wc -c <'Announce-2.2.B'`; then
    echo shar: \"'Announce-2.2.B'\" unpacked with wrong size!
fi
# end of 'Announce-2.2.B'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(734 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Announce-2.0               1	
X Announce-2.1               1	
X Announce-2.2               1	
X Announce-2.2.B             1	
X MANIFEST                   1	This shipping list
X Makefile                   1	
X README                     1	
X ToDo                       1	
X Version.c                  1	
X bootp.h                    1	
X bootpd.8                   1	
X bootpd.c                   2	
X bootpd.h                   1	
X bootptab                   1	
X bootptab.5                 1	
X gmods                      1	
X hash.c                     1	
X hash.h                     1	
X newvers.sh                 1	
X readfile.c                 2	
END_OF_FILE
if test 734 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(1296 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#
X# bootpd   - BOOTP server daemon
X#
X# $Header: /afs/andrew.cmu.edu/netdev/src/cmu/bootp-public/RCS/Makefile,v 1.1 1991/10/31 19:15:12 ww0n Exp ww0n $
X#
X
X# FILE DEFinitions:
X# The next few lines may be uncommented and changed to alter the default
X# filenames bootpd uses for its configuration and dump files.
X#CONFFILE= -DCONFIG_FILE=\"/usr/etc/bootptab\"
X#DUMPFILE= -DDUMP_FILE=\"/usr/etc/bootpd.dump\"
X#FILEDEFS= ${CONFFILE} ${DUMPFILE}
X
X# OPTion DEFinitions:
X# Remove the -DVEND_CMU if you don't wish to support the "CMU vendor format"
X# in addition to the RFC1048 format.
XOPTDEFS= -DSYSLOG -DVEND_CMU
X
X# SYStem DEFinitions:
X# Uncomment these lines for SunOS 4.X
XSYSDEFS= -DSUNOS4
X# Uncomment these lines for SVR4 (or Solaris 2.X)
X# SYSDEFS= -DSVR4 # -Dsparc -Dsun -Dunix ?XXX?
X# SYSLIBS= -lsocket -lnsl
X
XINSTALL=/usr/bin/install
XDESTDIR=
XETCDIR=/etc
XOBJS=bootpd.o readfile.o hash.o
XCFLAGS= ${FILEDEFS} ${OPTDEFS} ${SYSDEFS}
X
Xall: bootpd
X
Xbootpd:	${OBJS} Version.c
X	sh newvers.sh Version.c
X	${CC} ${CFLAGS} -o bootpd version.c ${OBJS} ${SYSLIBS}
X
Xbootpd.o: bootpd.c bootpd.h bootp.h
Xreadfile.o: readfile.c bootpd.h bootp.h
Xhash.o: hash.c hash.h
X
Xsystem: install
X
Xinstall: all
X	${INSTALL} -c -s bootpd ${DESTDIR}${ETCDIR}/bootpd
X
Xclean:
X	@rm -f core bootpd *.BAK *.CKP *~ .emacs* *.o version.c
END_OF_FILE
if test 1296 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(4154 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XThis is a MODIFIED VERSION of the CMU BOOTP server written by
XWalter L. Wimer and Drew D. Perkins and made available as
Xbootp-2.2alpha at CMU.  I tried several times to reach the
Xauthors of this program, and have since decided to make this
Xversion available directly.  I would be happy to maintain it.
X
XMy modifications allow this BOOTP server to handle clients that
Xexpect the server to honor the format of the options area in
Xthe request packet.  Such clients fill in all the option tag and
Xlength bytes in the request packet (using a fixed structure) and
Xexpect the server to fill in the missing data while preserving
Xthe layout of all the tag and length bytes.
X
XThe README from the CMU bootp-2.2alpha follows (edited slightly).
X
XGordon W. Ross  		Mercury Computer Systems
Xgwr@mc.com      		199 Riverneck Road
X508-256-1300			Chelmsford, MA 01824-2820
X
XThis directory contains the source for the CMU BOOTP server.
XThe files include:
X
XREADME		This file
XToDo		Things not yet done
Xbootpd.8	The manual page
Xbootp.h		The protocol header file
Xbootpd.h	The server header file
Xbootpd.c	The main server module
Xreadfile.c	The configuration file-reading routines
Xhash.h		The hash table header file
Xhash.c		The hash table module
XVersion.c	The version module
Xnewvers.sh	A shell script to generate new version numbers
XMakefile	The makefile
Xbootptab	An example database file for the server
Xbootptab.5	A manual describing the bootptab format
Xgmods		Text describing optional gateway modifications
X
X
XNotes:
X1) BOOTP was originally designed and implemented by Bill Croft at Stanford.
X   Much of the credit for the ideas and the code goes to him.  We've added
X   code to support the vendor specific area of the packet as specified in
X   RFC1048.  We've also improved the host lookup algorithm and added some
X   extra logging.
X
X2) The server now uses syslog to do logging.  Specifically it uses the 4.3bsd
X   version.  I've #ifdef'd all of these calls.  If you are running 4.2 you
X   should compile without the -DSYSLOG switch.
X
X3) You must update your /etc/services file to contain the following two lines:
X    bootps		67/udp		bootp		# bootp server
X    bootpc		68/udp				# bootp client
X
X4) Edit the bootptab.  It has some explanitory comments, and there
X   is a manual entry describing its format (bootptab.5)
X   If you have any questions, just let us know.
X
XConstruction:
X    Make sure all of the files exist first.  If anything is missing,
X    please contact either Walt Wimer or Drew Perkins by E-mail or phone.
X    Addresses and phone numbers are listed below.
X[ Or contact me at the address above. -gwr ]
X
X    Type 'make'.  The options at present are: -DSYSLOG which enables logging
X    code, -DDEBUG which enables table dumping via signals, and -DVEND_CMU
X    which enables the CMU extensions for CMU PC/IP.
X
X    Edit the bootptab.  The man page and the comments in the file should
X    explain how to go about doing so.  If you have any problems, let me know.
X
X    Type 'make install'.  This should put all of the files in the right place.
X
X    Edit your /etc/rc.local or /etc/inetd.conf file to start up bootpd upon
X    reboot.  [ The following is a sample entry for /etc/inetd.conf -gwr ]
X	# BOOTP server
X	bootps dgram udp wait root /usr/etc/bootpd bootpd -i
X
XCare and feeding:
X    If you change the interface cards on your host or add new hosts you will
X    need to update /etc/bootptab.  Just edit it as before.  Once you write
X    it back out, bootpd will notice that there is a new copy and will
X    reread it the next time it gets a request.
X
X    If your bootp clients don't get a response then several things might be
X    wrong.  Most often, the entry for that host is not in the database.
X    Check the hardware address and then check the entry and make sure
X    everything is right.  Other problems include the server machine crashing,
X    bad cables, and the like.  If your network is very congested you should
X    try making your bootp clients send additional requests before giving up.
X
X
XNovember 7, 1988
X
X
XWalter L. Wimer			Drew D. Perkins
Xww0n@andrew.cmu.edu		ddp@andrew.cmu.edu
X(412) 268-6252			(412) 268-8576
X
X4910 Forbes Ave
XPittsburgh, PA  15213
X
END_OF_FILE
if test 4154 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'ToDo' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ToDo'\"
else
echo shar: Extracting \"'ToDo'\" \(1222 characters\)
sed "s/^X//" >'ToDo' <<'END_OF_FILE'
X
XOptions in responses:
X
XRFC951 says:
X      The 'vend' field can be filled in by the client with
X      vendor-specific strings or structures.  For example the machine
X      hardware type or serial number may be placed here.  However the
X      operation of the BOOTP server should not DEPEND on this
X      information existing.
X
XTherefore:
X
XThe bootpd should honor any vendor data structure set up by the client
Xbefore trying to stuff in what it thinks the client wants.  This part
Xis done, but we need a way to tell the bootp server which options to
Xappend to the options area when the client provides no template.
XPerhaps the server should first fill in all the options specifically
Xasked for by the client (in its template), and then append all other
Xoption values known by the server as option space permits.
X
XResponse policy:
X
XVersion 2.2 does not respond to a bootp client if it does not see
Xa file name corresponding to the :bf=" record.  This can lead to
Xsome confusion if one forgets to install the boot file.  It might
Xbe less confusing if bootp just responded whenever it has a boot
Xrecord for that client, and let the client report failure reading
Xthe boot file when TFTP fails.  This is how bootpd-1.2 did it.
X
END_OF_FILE
if test 1222 -ne `wc -c <'ToDo'`; then
    echo shar: \"'ToDo'\" unpacked with wrong size!
fi
# end of 'ToDo'
fi
if test -f 'Version.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Version.c'\"
else
echo shar: Extracting \"'Version.c'\" \(2040 characters\)
sed "s/^X//" >'Version.c' <<'END_OF_FILE'
X#ifndef _BLURB_
X#define _BLURB_
X/************************************************************************
X          Copyright 1988, 1991 by Carnegie Mellon University
X
X                          All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted, provided
Xthat the above copyright notice appear in all copies and that both that
Xcopyright notice and this permission notice appear in supporting
Xdocumentation, and that the name of Carnegie Mellon University not be used
Xin advertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.
X
XCARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
XSOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
XIN NO EVENT SHALL CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
XDAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
XPROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
XACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X************************************************************************/
X#endif /* _BLURB_ */
X
X
X/*
X * Version.c (this file):
X *
X * Copyright (c) 1986, 1987 Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that this notice is preserved and that due credit is given
X * to the University of California at Berkeley. The name of the University
X * may not be used to endorse or promote products derived from this
X * software without specific prior written permission. This software
X * is provided ``as is'' without express or implied warranty.
X *
X *	@(#)Version.c	4.8 (Berkeley) 4/7/88
X */
X
X#ifndef lint
Xchar sccsid[] = "@(#)bootpd 2.2.B %VERSION% %WHOANDWHERE%\n";
Xchar rcsid[] = "$Header: Version 2.2.B from gwr@mc.com $";
X#endif /* not lint */
X
Xchar Version[] = "bootpd 2.2.B %VERSION%\n\t%WHOANDWHERE%\n";
END_OF_FILE
if test 2040 -ne `wc -c <'Version.c'`; then
    echo shar: \"'Version.c'\" unpacked with wrong size!
fi
# end of 'Version.c'
fi
if test -f 'bootp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bootp.h'\"
else
echo shar: Extracting \"'bootp.h'\" \(4479 characters\)
sed "s/^X//" >'bootp.h' <<'END_OF_FILE'
X#ifndef _BLURB_
X#define _BLURB_
X/************************************************************************
X          Copyright 1988, 1991 by Carnegie Mellon University
X
X                          All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted, provided
Xthat the above copyright notice appear in all copies and that both that
Xcopyright notice and this permission notice appear in supporting
Xdocumentation, and that the name of Carnegie Mellon University not be used
Xin advertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.
X
XCARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
XSOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
XIN NO EVENT SHALL CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
XDAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
XPROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
XACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X************************************************************************/
X#endif /* _BLURB_ */
X
X
X/*
X * Bootstrap Protocol (BOOTP).  RFC951 and RFC1048.
X *
X * $Header: /afs/andrew.cmu.edu/netdev/src/cmu/bootp-public/RCS/bootp.h,v 1.3 1991/11/01 10:02:29 ww0n Exp ww0n $
X *
X *
X * This file specifies the "implementation-independent" BOOTP protocol
X * information which is common to both client and server.
X *
X */
X
X
X#define BP_CHADDR_LEN	 16
X#define BP_SNAME_LEN	 64
X#define BP_FILE_LEN	128
X#define BP_VEND_LEN	 64
X
Xstruct bootp {
X    unsigned char    bp_op;			/* packet opcode type */
X    unsigned char    bp_htype;			/* hardware addr type */
X    unsigned char    bp_hlen;			/* hardware addr length */
X    unsigned char    bp_hops;			/* gateway hops */
X    unsigned long    bp_xid;			/* transaction ID */
X    unsigned short   bp_secs;			/* seconds since boot began */
X    unsigned short   bp_unused;
X    struct in_addr   bp_ciaddr;			/* client IP address */
X    struct in_addr   bp_yiaddr;			/* 'your' IP address */
X    struct in_addr   bp_siaddr;			/* server IP address */
X    struct in_addr   bp_giaddr;			/* gateway IP address */
X    unsigned char    bp_chaddr[BP_CHADDR_LEN];	/* client hardware address */
X    unsigned char    bp_sname[BP_SNAME_LEN];	/* server host name */
X    unsigned char    bp_file[BP_FILE_LEN];	/* boot file name */
X    unsigned char    bp_vend[BP_VEND_LEN];	/* vendor-specific area */
X};
X
X/*
X * UDP port numbers, server and client.
X */
X#define	IPPORT_BOOTPS		67
X#define	IPPORT_BOOTPC		68
X
X#define BOOTREPLY		2
X#define BOOTREQUEST		1
X
X
X/*
X * Hardware types from Assigned Numbers RFC.
X */
X#define HTYPE_ETHERNET		  1
X#define HTYPE_EXP_ETHERNET	  2
X#define HTYPE_AX25		  3
X#define HTYPE_PRONET		  4
X#define HTYPE_CHAOS		  5
X#define HTYPE_IEEE802		  6
X#define HTYPE_ARCNET		  7
X
X
X
X/*
X * Vendor magic cookie (v_magic) for CMU
X */
X#define VM_CMU		"CMU"
X
X/*
X * Vendor magic cookie (v_magic) for RFC1048
X */
X#define VM_RFC1048	{ 99, 130, 83, 99 }
X
X
X
X/*
X * RFC1048 tag values used to specify what information is being supplied in
X * the vendor field of the packet.
X */
X
X#define TAG_PAD			((unsigned char)   0)
X#define TAG_SUBNET_MASK		((unsigned char)   1)
X#define TAG_TIME_OFFSET		((unsigned char)   2)
X#define TAG_GATEWAY		((unsigned char)   3)
X#define TAG_TIME_SERVER		((unsigned char)   4)
X#define TAG_NAME_SERVER		((unsigned char)   5)
X#define TAG_DOMAIN_SERVER	((unsigned char)   6)
X#define TAG_LOG_SERVER		((unsigned char)   7)
X#define TAG_COOKIE_SERVER	((unsigned char)   8)
X#define TAG_LPR_SERVER		((unsigned char)   9)
X#define TAG_IMPRESS_SERVER	((unsigned char)  10)
X#define TAG_RLP_SERVER		((unsigned char)  11)
X#define TAG_HOSTNAME		((unsigned char)  12)
X#define TAG_BOOTSIZE		((unsigned char)  13)
X#define TAG_END			((unsigned char) 255)
X
X
X
X/*
X * "vendor" data permitted for CMU bootp clients.
X */
X
Xstruct cmu_vend {
X	unsigned char	v_magic[4];	/* magic number */
X	unsigned long	v_flags;	/* flags/opcodes, etc. */
X	struct in_addr 	v_smask;	/* Subnet mask */
X	struct in_addr 	v_dgate;	/* Default gateway */
X	struct in_addr	v_dns1, v_dns2; /* Domain name servers */
X	struct in_addr	v_ins1, v_ins2; /* IEN-116 name servers */
X	struct in_addr	v_ts1, v_ts2;	/* Time servers */
X	unsigned long	v_unused[6];	/* currently unused */
X};
X
X
X/* v_flags values */
X#define VF_SMASK	1	/* Subnet mask field contains valid data */
END_OF_FILE
if test 4479 -ne `wc -c <'bootp.h'`; then
    echo shar: \"'bootp.h'\" unpacked with wrong size!
fi
# end of 'bootp.h'
fi
if test -f 'bootpd.8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bootpd.8'\"
else
echo shar: Extracting \"'bootpd.8'\" \(4357 characters\)
sed "s/^X//" >'bootpd.8' <<'END_OF_FILE'
X.\" Copyright (c) 1988, 1989, 1991 Carnegie Mellon University
X.\"
X.\"	$Header: /afs/andrew.cmu.edu/netdev/src/cmu/bootp-public/RCS/bootpd.8,v 1.1 1991/10/31 19:15:12 ww0n Exp ww0n $
X.\"
X.TH BOOTPD 8 "November 11, 1991" "Carnegie Mellon University"
X.UC 6
X
X.SH NAME
Xbootpd \- Internet Boot Protocol server
X.SH SYNOPSIS
X.B /etc/bootpd
X[
X.B \-i
X.B \-s
X.B \-t
Xtimeout
X.B \-d
Xlevel
X]
X[
X.I configfile
X[
X.I dumpfile
X] ]
X.SH DESCRIPTION
X.I Bootpd
Ximplements an Internet Bootstrap Protocol server as defined in RFC951,
XRFC1048, and RFC1084.  It is normally run by
X.I /etc/inetd
Xby including the following line in the file
X.IR /etc/inetd.conf :
X.PP
X.br
X	bootps	dgram	udp	wait	root	/etc/bootpd	bootpd
X.PP
XThis mode of operation is referred to as "inetd mode" and causes
X.I bootpd
Xto be started only when a boot request arrives.  If
X.I bootpd
Xdoes not receive another boot request within fifteen minutes of the last one
Xit received, it will exit to conserve system resources.  The
X.B \-t
Xswitch may be used to specify a different timeout value in minutes (e.g.
X-t 20).  A timeout value of zero means forever.
X.PP
XIt is also possible to run
X.I bootpd
Xin "standalone mode" (without
X.IR inetd )
Xby simply invoking it from a shell like any other regular command.
XStandalone mode is probably the desired mode of operation for large network
Xinstallations with many BOOTP clients.  (The greater the number of clients
Xlisted in the configuration database,
X.IR /etc/bootptab ,
Xthe longer it takes
X.I bootpd
Xto start up.  To ensure quick response to clients in a large network,
Xit is better to start
X.I bootpd
Xonce during the server machine's bootup sequence.  This can be done by invoking
X.I bootpd
Xfrom within
X.IR /etc/rc.local ,
Xfor example.)
X. 
XIn standalone mode, the
X.B \-t
Xswitch has no effect since
X.I bootpd
Xwill never exit.
X.PP
XThe server automatically detects whether it was invoked from inetd or from a
Xshell and automatically selects the appropriate mode.  For compatibility with
Xolder versions of
X.IR bootpd ,
Xthe
X.B \-s
Xswitch may be used to force standalone operation.  Similarly, the
X.B \-i
Xswitch may be used to force the inetd mode of operation.  Normally, though,
Xit should be unnecessary to use these switches.
X.PP
XThe
X.B \-d
Xswitch takes a numeric parameter which sets the level of debugging output.
XFor example, -d4 or -d 4 will set the debugging level to 4.
XFor compatibility with older versions of
X.IR bootpd ,
Xomitting the numeric parameter (i.e. just -d) will
Xsimply increment the debug level by one.
X.PP
XUpon startup,
X.I bootpd
Xfirst reads its configuration file,
X.IR /etc/bootptab ,
Xand then begins listening for BOOTREQUEST packets.
X.PP
X.I Bootpd
Xlooks in
X.I /etc/services
Xto find the UDP port numbers it should use.  Two entries are extracted:
X.BR bootps ,
Xthe bootp server listening port, and
X.BR bootpc ,
Xthe destination port used to reply to clients.  If the port numbers cannot
Xbe determined this way,
X.I bootpd
Xdefaults to using 67 for the server and 68 for the client.
X.PP
X.I Bootpd
Xcompletely reloads its configuration file when it receives a hangup signal,
XSIGHUP, or when it receives a BOOTREQUEST packet and detects that the file
Xhas been updated.  If
X.I bootpd
Xis compiled with the -DDEBUG option, receipt of a SIGUSR1 signal causes it
Xto dump its memory-resident database to
Xthe file
X.I /etc/bootpd.dump
Xor the command-line-specified dumpfile.
X
X.SH FILES
X/etc/bootptab
X.br
X/etc/bootpd.dump
X.br
X/etc/services
X
X.SH BUGS
XIndividual host entries must not exceed 1024 characters.
X
X.SH HISTORY
X.TP
X22-Jan-86  Bill Croft at Stanford University
X.br
XCreated.
X
X.TP
X30-Jul-86  David Kovar at Carnegie Mellon University
X.br
XModified to CMU specifications.
X
X.TP
X24-Jul-87  Drew D. Perkins at Carnegie Mellon University
X.br
XModified to use syslog.  Added debugging dumps.  Other bug fixes.
X
X.TP
X17-Jul-88  Walter L. Wimer at Carnegie Mellon University
X.br
XAdded vendor information to conform to RFC1048.
XAdopted termcap-like file format to allow variable data.
X
X.TP
X11-Nov-91  Walter L. Wimer at Carnegie Mellon University
X.br
XAdded TFTP directory- and server-specification features.  Added automatic
Xdetection of inetd/standalone mode, making -s switch no longer necessary.
XOther minor improvements and bug fixes.
X
X.SH "SEE ALSO"
X.br
Xbootptab(5), inetd(8), tftpd(8),
X.br
XDARPA Internet Request For Comments RFC951, RFC1048, RFC1084, Assigned Numbers
END_OF_FILE
if test 4357 -ne `wc -c <'bootpd.8'`; then
    echo shar: \"'bootpd.8'\" unpacked with wrong size!
fi
# end of 'bootpd.8'
fi
if test -f 'bootpd.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bootpd.h'\"
else
echo shar: Extracting \"'bootpd.h'\" \(5535 characters\)
sed "s/^X//" >'bootpd.h' <<'END_OF_FILE'
X#ifndef _BLURB_
X#define _BLURB_
X/************************************************************************
X          Copyright 1988, 1991 by Carnegie Mellon University
X
X                          All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted, provided
Xthat the above copyright notice appear in all copies and that both that
Xcopyright notice and this permission notice appear in supporting
Xdocumentation, and that the name of Carnegie Mellon University not be used
Xin advertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.
X
XCARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
XSOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
XIN NO EVENT SHALL CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
XDAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
XPROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
XACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X************************************************************************/
X#endif /* _BLURB_ */
X
X
X/*
X * bootpd.h -- common header file for all the modules of the bootpd program.
X */
X
X
X#ifndef TRUE
X#define TRUE	1
X#endif
X#ifndef FALSE
X#define FALSE	0
X#endif
X
X#ifndef PRIVATE
X#define PRIVATE static
X#endif
X
X#ifndef SIGUSR1
X#define SIGUSR1			 30	/* From 4.3 <signal.h> */
X#endif
X
X#define MAXHADDRLEN		  6	/* Max hw address length in bytes */
X#define MAXSTRINGLEN		 80	/* Max string length */
X
X/*
X * Return the length in bytes of a hardware address of the given type.
X * Return the canonical name of the network of the given type.
X */
X#define haddrlength(type)	((hwinfolist[(int) (type)]).hlen)
X#define netname(type)		((hwinfolist[(int) (type)]).name)
X
X
X/*
X * Return pointer to static string which gives full network error message.
X */
X#define get_network_errmsg get_errmsg
X
X
X/*
X * Variables shared among modules.
X */
X
Xextern int debug;
Xextern char *bootptab;
X
Xextern struct hwinfo hwinfolist[];
Xextern int hwinfocnt;
X
Xextern hash_tbl *hwhashtable;
Xextern hash_tbl *iphashtable;
Xextern hash_tbl *nmhashtable;
Xextern unsigned char vm_cmu[4];
Xextern unsigned char vm_rfc1048[4];
X
X
X/*
X * Functions shared among modules
X */
X
Xextern void report();
Xextern char *get_errmsg();
Xextern char *haddrtoa();
Xextern void readtab();
X
X
X
X/*
X * Nice typedefs. . .
X */
X
Xtypedef int boolean;
Xtypedef unsigned char byte;
X
X
X/*
X * This structure holds information about a specific network type.  The
X * length of the network hardware address is stored in "hlen".
X * The string pointed to by "name" is the cononical name of the network.
X */
X
Xstruct hwinfo {
X    unsigned hlen;
X    char *name;
X};
X
X
X
X/*
X * Data structure used to hold an arbitrary-lengthed list of IP addresses.
X * The list may be shared among multiple hosts by setting the linkcount
X * appropriately.
X */
X
Xstruct in_addr_list {
X    unsigned		linkcount, addrcount;
X    struct in_addr	addr[1];		/* Dynamically extended */
X};
X
X
X/*
X * Data structures used to hold shared strings and shared binary data.
X * The linkcount must be set appropriately.
X */
X
Xstruct shared_string {
X    unsigned		linkcount;
X    char		string[1];		/* Dynamically extended */
X};
X
Xstruct shared_bindata {
X    unsigned		linkcount, length;
X    byte		data[1];		/* Dynamically extended */
X};
X
X
X/*
X * Flag structure which indicates which symbols have been defined for a
X * given host.  This information is used to determine which data should or
X * should not be reported in the bootp packet vendor info field.
X */
X
Xstruct flag {
X    unsigned	bootfile	:1,
X		bootserver	:1,
X		bootsize	:1,
X		bootsize_auto	:1,
X		cookie_server	:1,
X		domain_server	:1,
X		gateway		:1,
X		generic		:1,
X		haddr		:1,
X		homedir		:1,
X		htype		:1,
X		impress_server	:1,
X		iaddr		:1,
X		log_server	:1,
X		lpr_server	:1,
X		name_server	:1,
X		name_switch	:1,
X		rlp_server	:1,
X		send_name	:1,
X		subnet_mask	:1,
X		tftpdir		:1,
X		time_offset	:1,
X		timeoff_auto	:1,
X		time_server	:1,
X		vendor_magic	:1,
X		vm_auto		:1;
X};
X
X
X
X/*
X * The flags structure contains TRUE flags for all the fields which
X * are considered valid, regardless of whether they were explicitly
X * specified or indirectly inferred from another entry.
X *
X * The gateway and the various server fields all point to a shared list of
X * IP addresses.
X *
X * The hostname, home directory, and bootfile are all shared strings.
X *
X * The generic data field is a shared binary data structure.  It is used to
X * hold future RFC1048 vendor data until bootpd is updated to understand it.
X *
X * The vm_cookie field specifies the four-octet vendor magic cookie to use
X * if it is desired to always send the same response to a given host.
X *
X * Hopefully, the rest is self-explanatory.
X */
X
Xstruct host {
X    struct flag		    flags;		/* ALL valid fields */
X    struct in_addr_list	    *cookie_server,
X			    *domain_server,
X			    *gateway,
X			    *impress_server,
X			    *log_server,
X			    *lpr_server,
X			    *name_server,
X			    *rlp_server,
X			    *time_server;
X    struct shared_string    *bootfile,
X			    *hostname,
X			    *homedir,
X			    *tftpdir;
X    struct shared_bindata   *generic;
X    byte		    vm_cookie[4],
X			    htype,  /* RFC826 says this should be 16-bits but
X				       RFC951 only allocates 1 byte. . . */
X			    haddr[MAXHADDRLEN];
X    long		    time_offset;
X    unsigned int	    bootsize;
X    struct in_addr	    bootserver,
X			    iaddr,
X			    subnet_mask;
X};
END_OF_FILE
if test 5535 -ne `wc -c <'bootpd.h'`; then
    echo shar: \"'bootpd.h'\" unpacked with wrong size!
fi
# end of 'bootpd.h'
fi
if test -f 'bootptab' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bootptab'\"
else
echo shar: Extracting \"'bootptab'\" \(2073 characters\)
sed "s/^X//" >'bootptab' <<'END_OF_FILE'
X# /etc/bootptab: database for bootp server (/etc/bootpd)
X# Last update: gwr, Tue Jun  8 09:53:46 EDT 1993
X# Blank lines and lines beginning with '#' are ignored.
X#
X# Legend:	(see bootptab.5)
X#
X#	first field -- hostname
X#			(may be full domain name and probably should be)
X#
X#	hd -- home directory (dir relative to /tftpboot)
X#	hn -- send the client its host name (does this work?)
X#	bf -- bootfile
X#	cs -- cookie servers
X#	ds -- domain name servers
X#	gw -- gateways
X#	ha -- hardware address
X#	ht -- hardware type
X#	im -- impress servers
X#	ip -- host IP address
X#	lg -- log servers
X#	lp -- LPR servers
X#	ns -- IEN-116 name servers
X#	rl -- resource location protocol servers
X#	sm -- subnet mask
X#	tc -- template host (points to similar host entry)
X#	to -- time offset (seconds)
X#	ts -- time servers
X
X#
X# Be careful about including backslashes where they're needed.  Weird (bad)
X# things can happen when a backslash is omitted where one is intended.
X#
X
X
X# First, we define a global entry which specifies the stuff every host uses.
X
Xglobal.dummy:\
X	:td=/tftpboot:\
X	:hd=/tftpboot:\
X	:hn:bf=null:
X
X# Next, we can define different master entries for each subnet. . .
X
Xsubnet16.dummy:\
X	:tc=global.dummy:\
X	:sm=255.255.255.0:\
X	:gw=192.233.16.15:\
X	:ds=192.233.16.4:
X
Xsubnet17.dummy:\
X	:tc=global.dummy:\
X	:sm=255.255.255.0:\
X	:gw=192.233.17.32:\
X	:ds=192.233.17.28:
X
X#
X# We should be able to use as many levels of indirection as desired.  Use
X# your imagination. . .
X#
X
X# Individual entries (could also have different servers for some/all of these
X# hosts, but we don't really use this feature at CMU):
X
X# This is for testing the arbitrary tag option:
X# T14 is the NIS domain name
X# T15 is the NIS server list
Xwalnut:tc=subnet16.dummy:ht=ethernet:ha=08.00.20.0E.FF.30:\
X	:ip=192.233.16.24:bf=boot.sun4c:\
X	:T14="mc.com":T15=192.233.16.4:
X
X# Tadpole 885 board.
Xtp885:tc=subnet17.dummy:ht=ethernet:ha=08.00.4C.00.2F.74:\
X	:ip=192.233.17.42:bf=tp885sys1.cfe:
X
X# MVME147 VxWorks board.
Xmvme147:tc=subnet17.dummy:ht=ethernet:ha=08.00.3e.20.da.47:\
X	:ip=192.233.17.41:bf=mv147vxw.st:
X
END_OF_FILE
if test 2073 -ne `wc -c <'bootptab'`; then
    echo shar: \"'bootptab'\" unpacked with wrong size!
fi
# end of 'bootptab'
fi
if test -f 'bootptab.5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bootptab.5'\"
else
echo shar: Extracting \"'bootptab.5'\" \(10623 characters\)
sed "s/^X//" >'bootptab.5' <<'END_OF_FILE'
X.\" Copyright (c) 1988, 1989, 1991 Carnegie Mellon University
X.\"
X.\"	$Header: /afs/andrew.cmu.edu/netdev/src/cmu/bootp-public/RCS/bootpd.8,v 1.1 1991/10/31 19:15:12 ww0n Exp ww0n $
X.\"
X.TH BOOTPTAB 5 "October 31, 1991" "Carnegie Mellon University"
X.UC 6
X
X.SH NAME
Xbootptab \- Internet Bootstrap Protocol server database
X.SH DESCRIPTION
XThe
X.I bootptab
Xfile is the configuration database file for
X.IR bootpd ,
Xthe Internet Bootstrap Protocol server.
XIt's format is similar to that of
X.IR termcap (5)
Xin which two-character case-sensitive tag symbols are used to
Xrepresent host parameters.  These parameter declarations are separated by
Xcolons (:), with a general format of:
X.PP
X.I "	hostname:tg=value. . . :tg=value. . . :tg=value. . . ."
X.PP
Xwhere
X.I hostname
Xis the actual name of a bootp client and
X.I tg
Xis a two-character tag symbol.  Most tags must be followed by an equals-sign
Xand a value as above.  Some may also appear in a boolean form with no
Xvalue (i.e.
X.RI : tg :).
XThe currently recognized tags are:
X.PP
X.br
X	bf	Bootfile
X.br
X	bs	Bootfile size in 512-octet blocks
X.br
X	cs	Cookie server address list
X.br
X	ds	Domain name server address list
X.br
X	gw	Gateway address list
X.br
X	ha	Host hardware address
X.br
X	hd	Bootfile home directory
X.br
X	hn	Send client's hostname to client
X.br
X	ht	Host hardware type (see Assigned Numbers RFC)
X.br
X	im	Impress server address list
X.br
X	ip	Host IP address
X.br
X	lg	Log server address list
X.br
X	lp	LPR server address list
X.br
X	ns	IEN-116 name server address list
X.br
X	rl	Resource location protocol server address list
X.br
X	sa	TFTP server address client should use
X.br
X	sm	Host subnet mask
X.br
X	tc	Table continuation (points to similar "template" host entry)
X.br
X	td	TFTP root directory used by "secure" TFTP servers
X.br
X	to	Time offset in seconds from UTC
X.br
X	ts	Time server address list
X.br
X	vm	Vendor magic cookie selector
X
X.PP
XThere is also a generic tag,
X.RI T n ,
Xwhere
X.I n
Xis an RFC1084 vendor field tag number.  Thus it is possible to immediately
Xtake advantage of future extensions to RFC1084 without being forced to modify
X.I bootpd
Xfirst.  Generic data may be represented as either a stream of hexadecimal
Xnumbers or as a quoted string of ASCII characters.  The length of the generic
Xdata is automatically determined and inserted into the proper field(s) of the
XRFC1084-style bootp reply.
X.PP
XThe following tags take a whitespace-separated list of IP addresses:
X.BR cs ,
X.BR ds ,
X.BR gw ,
X.BR im ,
X.BR lg ,
X.BR lp ,
X.BR ns ,
X.BR rl ,
Xand
X.BR ts .
XThe
X.BR ip ,
X.BR sa ,
Xand
X.B sm
Xtags each take a single IP address.
XAll IP addresses are specified in standard Internet "dot" notation and may use
Xdecimal, octal, or hexadecimal numbers (octal numbers begin with 0,
Xhexadecimal numbers begin with '0x' or '0X').
X.PP
XThe
X.B ht
Xtag specifies the hardware type code as either an unsigned decimal, octal, or
Xhexadecimal integer or one of the following symbolic names:
X.B ethernet
Xor
X.B ether
Xfor 10Mb Ethernet,
X.B ethernet3
Xor
X.B ether3
Xfor 3Mb experimental Ethernet,
X.BR ieee802 ,
X.BR tr ,
Xor
X.B token-ring
Xfor IEEE 802 networks,
X.B pronet
Xfor Proteon ProNET Token Ring, or
X.BR chaos ,
X.BR arcnet ,
Xor
X.B ax.25
Xfor Chaos, ARCNET, and AX.25 Amateur Radio networks, respectively.
XThe
X.B ha
Xtag takes a hardware address which
X.I must
Xbe specified in hexadecimal; optional periods and/or a leading '0x' may be
Xincluded for readability.  The
X.B ha
Xtag must be preceded by the
X.B ht
Xtag (either explicitly or implicitly; see
X.B tc
Xbelow).
X.PP
XThe hostname, home directory, and bootfile are ASCII strings which may be
Xoptionally surrounded by double quotes (").  The client's request and the
Xvalues of the
X.B hd
Xand
X.B bf
Xsymbols determine how the server fills in the bootfile field of the bootp
Xreply packet.
X.PP
XIf the client specifies an absolute pathname and that file exists on the
Xserver machine, that pathname is returned in the reply packet.  If the file
Xcannot be found, the request is discarded; no reply is sent.  If the client
Xspecifies a relative pathname, a full pathname is formed by prepending the
Xvalue of the
X.B hd
Xtag and testing for existence of the file.  If the
X.B hd
Xtag is not supplied in the configuration file or if the resulting boot file
Xcannot be found, then the request is discarded.
X.PP
XClients which specify null boot files will always elicit a reply from the
Xserver.  The exact reply will again depend upon the
X.B hd
Xand
X.B bf
Xtags.  If the
X.B bf
Xtag gives an absolute pathname and the file exists, that pathname is returned
Xin the reply packet.  Otherwise, if the
X.B hd
Xand
X.B bf
Xtags together specify an accessible file, that filename is returned in the
Xreply.  If a complete filename cannot be determined or the file does not
Xexist, the reply will contain a zeroed-out bootfile field.
X.PP
XIn all these cases, existence of the file means that, in addition to actually
Xbeing present, the file must have its public read access bit set, since this
Xis required by
X.IR tftpd (8)
Xto permit the file transfer.  Also, all filenames are first tried as
X.I filename.hostname
Xand then simply as
X.IR filename ,
Xthus providing for individual per-host bootfiles.
X.PP
XSome newer versions of
X.I tftpd
Xprovide a security feature to change their root directory using
Xthe
X.IR chroot (2)
Xsystem call.
XThe
X.B td
Xtag may be used to inform
X.I bootpd
Xof this special root directory used by
X.IR tftpd .
XThe
X.B hd
Xtag is actually relative to the root directory specified by the
X.B td
Xtag.
XFor example, if the real absolute path to your BOOTP client bootfile is
X/tftpboot/bootfiles/bootimage, and
X.IR tftpd
Xuses /tftpboot as its "secure" directory, then specify the following in
X.IR bootptab :
X.PP
X.br
X	:td=/tftpboot:hd=/bootfiles:bf=bootimage:
X.PP
XIf your bootfiles are located directly in /tftpboot, use:
X.PP
X.br
X	:td=/tftpboot:hd=/:bf=bootimage:
X.PP
XThe
X.B sa
Xtag may be used to specify the IP address of the particular TFTP server
Xyou wish the client to use.  In the absence of this tag,
X.I bootpd
Xwill tell the client to perform TFTP to the same machine
X.I bootpd
Xis running on.
X.PP
XThe time offset
X.B to
Xmay be either a signed decimal integer specifying the client's
Xtime zone offset in seconds from UTC, or the keyword
X.B auto
Xwhich uses the server's time zone offset.  Specifying the
X.B to
Xsymbol as a boolean has the same effect as specifying
X.B auto
Xas its value.
X.PP
XThe bootfile size
X.B bs
Xmay be either a decimal, octal, or hexadecimal integer specifying the size of
Xthe bootfile in 512-octet blocks, or the keyword
X.B auto
Xwhich causes the server to automatically calculate the bootfile size at each
Xrequest.  As with the time offset, specifying the
X.B bs
Xsymbol as a boolean has the same effect as specifying
X.B auto
Xas its value.
X.PP
XThe vendor magic cookie selector (the
X.B vm
Xtag) may take one of the following keywords:
X.B auto
X(indicating that vendor information is determined by the client's request),
X.B rfc1048
Xor
X.B rfc1084
X(which always forces an RFC1084-style reply), or
X.B cmu
X(which always forces a CMU-style reply).
X.PP
XThe
X.B hn
Xtag is strictly a boolean tag; it does not take the usual equals-sign and
Xvalue.  It's presence indicates that the hostname should be sent to RFC1084
Xclients.
X.I Bootpd
Xattempts to send the entire hostname as it is specified in the configuration
Xfile; if this will not fit into the reply packet, the name is shortened to
Xjust the host field (up to the first period, if present) and then tried.
XIn no case is an arbitrarily-truncated hostname sent (if nothing reasonable
Xwill fit, nothing is sent).
X.PP
XOften, many host entries share common values for certain tags (such as name
Xservers, etc.).  Rather than repeatedly specifying these tags, a full
Xspecification can be listed for one host entry and shared by others via the
X.B tc
X(table continuation) mechanism.
XOften, the template entry is a dummy host which doesn't actually exist and
Xnever sends bootp requests.  This feature is similar to the
X.B tc
Xfeature of
X.IR termcap (5)
Xfor similar terminals.  Note that
X.I bootpd
Xallows the
X.B tc
Xtag symbol to appear anywhere in the host entry, unlike
X.I termcap
Xwhich requires it to be the last tag.  Information explicitly specified for a
Xhost always overrides information implied by a
X.B tc
Xtag symbol, regardless of its location within the entry.  The
Xvalue of the
X.B tc
Xtag may be the hostname or IP address of any host entry
Xpreviously listed in the configuration file.
X.PP
XSometimes it is necessary to delete a specific tag after it has been inferred
Xvia
X.BR tc .
XThis can be done using the construction
X.IB tag @
Xwhich removes the effect of
X.I tag
Xas in
X.IR termcap (5).
XFor example, to completely undo an IEN-116 name server specification, use
X":ns@:" at an appropriate place in the configuration entry.  After removal
Xwith
X.BR @ ,
Xa tag is eligible to be set again through the
X.B tc
Xmechanism.
X.PP
XBlank lines and lines beginning with "#" are ignored in the configuration
Xfile.  Host entries are separated from one another by newlines; a single host
Xentry may be extended over multiple lines if the lines end with a backslash
X(\\).  It is also acceptable for lines to be longer than 80 characters.  Tags
Xmay appear in any order, with the following exceptions:  the hostname must be
Xthe very first field in an entry, and the hardware type must precede the
Xhardware address.
X.PP
XAn example
X.I /etc/bootptab
Xfile follows:
X.PP
X
X.br
X	# Sample bootptab file
X
X.br
X	default1:\\
X.br
X		:hd=/usr/boot:bf=null:\\
X.br
X		:ds=128.2.35.50 128.2.13.21:\\
X.br
X		:ns=0x80020b4d 0x80020ffd:\\
X.br
X		:ts=0x80020b4d 0x80020ffd:\\
X.br
X		:sm=255.255.0.0:gw=0x8002fe24:\\
X.br
X		:hn:vm=auto:to=-18000:\\
X.br
X		:T37=0x12345927AD3BCF:T99="Special ASCII string":
X
X.br
X	carnegie:ht=6:ha=7FF8100000AF:ip=128.2.11.1:tc=default1:
X.br
X	baldwin:ht=1:ha=0800200159C3:ip=128.2.11.10:tc=default1:
X.br
X	wylie:ht=1:ha=00DD00CADF00:ip=128.2.11.100:tc=default1:
X.br
X	arnold:ht=1:ha=0800200102AD:ip=128.2.11.102:tc=default1:
X.br
X	bairdford:ht=1:ha=08002B02A2F9:ip=128.2.11.103:tc=default1:
X.br
X	bakerstown:ht=1:ha=08002B0287C8:ip=128.2.11.104:tc=default1:
X
X.br
X	# Special domain name server for next host
X.br
X	butlerjct:ht=1:ha=08002001560D:ip=128.2.11.108:ds=128.2.13.42:tc=default1:
X
X.br
X	gastonville:ht=6:ha=7FFF81000A47:ip=128.2.11.115:tc=default1:
X.br
X	hahntown:ht=6:ha=7FFF81000434:ip=128.2.11.117:tc=default1:
X.br
X	hickman:ht=6:ha=7FFF810001BA:ip=128.2.11.118:tc=default1:
X.br
X	lowber:ht=1:ha=00DD00CAF000:ip=128.2.11.121:tc=default1:
X.br
X	mtoliver:ht=1:ha=00DD00FE1600:ip=128.2.11.122:tc=default1:
X
X
X.SH FILES
X/etc/bootptab
X
X.SH "SEE ALSO"
X.br
Xbootpd(8), tftpd(8),
X.br
XDARPA Internet Request For Comments RFC951, RFC1048, RFC1084, Assigned Numbers
END_OF_FILE
if test 10623 -ne `wc -c <'bootptab.5'`; then
    echo shar: \"'bootptab.5'\" unpacked with wrong size!
fi
# end of 'bootptab.5'
fi
if test -f 'gmods' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gmods'\"
else
echo shar: Extracting \"'gmods'\" \(5070 characters\)
sed "s/^X//" >'gmods' <<'END_OF_FILE'
XFolks,
X
XHere is a summary of the gateway mods needed for BOOTP (to allow
Xcross gateway booting), and some pseudo-code.  First the
XBOOTP packet (which is enclosed in an IP/UDP):
X
X====
X
X/*
X * Bootstrap Protocol (BOOTP).  RFC 951.
X */
X
Xstruct bootp {
X	u_char	bp_op;		/* packet opcode type */
X#define	BOOTREQUEST	1
X#define	BOOTREPLY	2
X	u_char	bp_htype;	/* hardware addr type */
X	u_char	bp_hlen;	/* hardware addr length */
X	u_char	bp_hops;	/* gateway hops */
X	u_long	bp_xid;		/* transaction ID */
X	u_short	bp_secs;	/* seconds since boot began */	
X	u_short	bp_unused;
X	iaddr_t	bp_ciaddr;	/* client IP address */
X	iaddr_t	bp_yiaddr;	/* 'your' IP address */
X	iaddr_t	bp_siaddr;	/* server IP address */
X	iaddr_t	bp_giaddr;	/* gateway IP address */
X	u_char	bp_chaddr[16];	/* client hardware address */
X	u_char	bp_sname[64];	/* server host name */
X	u_char	bp_file[128];	/* boot file name */
X	u_char	bp_vend[64];	/* vendor-specific area */
X};
X
X#define	IPPORT_BOOTPS		67
X#define	IPPORT_BOOTPC		68
X
X====
X
XNext, here is the section from [sri-nic]<rfc>rfc951.txt that has
Xmost to do with gateway issues.  However you will probably want to
Xhardcopy the entire document.
X
X====
X
X
XRFC 951                                                   September 1985
XBootstrap Protocol						[Page 9]
X
X
X8. Booting Through Gateways
X
X   This part of the protocol is optional and requires some additional
X   code in cooperating gateways and servers, but it allows cross-gateway
X   booting.  This is mainly useful when gateways are diskless machines.
X   Gateways containing disks (e.g. a UNIX machine acting as a gateway),
X   might as well run their own BOOTP/TFTP servers.
X
X   Gateways listening to broadcast BOOTREQUESTs may decide to forward or
X   rebroadcast these requests 'when appropriate'.  For example, the
X   gateway could have, as part of his configuration tables, a list of
X   other networks or hosts to receive a copy of any broadcast
X   BOOTREQUESTs.  Even though a 'hops' field exists, it is a poor idea
X   to simply globally rebroadcast the requests, since broadcast loops
X   will almost certainly occur.
X
X   The forwarding could begin immediately, or wait until the 'secs'
X   (seconds client has been trying) field passes a certain threshold.
X
X   If a gateway does decide to forward the request, it should look at
X   the 'giaddr' (gateway IP address) field.  If zero, it should plug its
X   own IP address (on the receiving cable) into this field.  It may also
X   use the 'hops' field to optionally control how far the packet is
X   reforwarded. Hops should be incremented on each forwarding.  For
X   example, if hops passes '3', the packet should probably be discarded.
X
X====
X
XAnd here is some pseudo-code:
X
X
X/*
X * Each gateway will probably have a locally configured table
X * that lists the addresses of hosts (or gateways)
X * (or net numbers) to which BOOTP's can be
X * forwarded.  Assume this table is called 'bootplist'.  It
X * can be initialized at compile time, or via a config file.
X *
X * The easiest case will be to use specific host (or gateway)
X * addresses; if net addresses (e.g. 36.45.0.0) 
X * are used, that will probably require implementing IP directed
X * broadcasts.  It is probably best to start with the simple case
X * of a host list.
X */
Xxxxxxxx	bootplist[] = { , , , };
X
X
X/*
X * "ipreceive" is called with each incoming IP datagram.
X *
X * Packet headers for the respective layers are in: ether,ip,udp,bootp.
X */
Xipreceive()
X{
X	if (ether.dst == broadcast && ether.src == from_our_interfaces)
X		goto discard;
X	if (ipchecksum == bad || --ip.ttl <= 0)
X		goto discard;
X	if (ip.proto != UDP || udp.port != IPPORT_BOOTPS) 
X		goto forward;
X	if (ip.dst != broadcast && ip.dst != one_of_my_interfaces)
X		goto forward;
X	/*
X	 * We now have a UDP for the BOOTP Server port.
X	 */
X	switch (bootp.bp_op) {
X	case BOOTREQUEST:
X		if (bootp.bp_secs <= 5 || ++bootp.bp_hops > 5)
X			goto discard;
X		if (bootp.bp_giaddr == 0)
X			ip.src = bootp.bp_giaddr = my IP address;
X			/* of incoming interface, if possible */
X		for (each host in bootplist) {
X			copy_packet_into_new_buffer;
X			ip.dst = host address;
X			send_ip;
X		}
X		goto discard;	/* discard original packet */
X
X	case BOOTREPLY:
X		if (bootp.bp_yiaddr != directly_accessable)
X			goto discard;	/* if not 0 hops from me */
X		/*
X		 * At this point, we need to use one of the methods
X		 * described in RFC951, section 4, to send the reply
X		 * to the client.  Usually this will be: setup a
X		 * temporary arp cache entry for bp_yiaddr at
X		 * hardware address bp_chaddr.
X		 */
X		set_arp_cache(bootp.bp_yiaddr, bootp.bp_chaddr);
X		ip.dst = bootp.bp_yiaddr;
X		udp.port = IPPORT_BOOTPC;	/* for client only now */
X		goto forward;
X
X	default:
X		goto discard;	/* bad opcode */
X	}
X
Xforward:
X	if (ether.dst == broadcast || ip.dst == broadcast)
X		goto discard;
X	forward_ip;	/* recomputes ip checksum if needed */
X	return;
Xdiscard:
X	discard_packet;
X	return;
X}
X
X
X====
X
XNotes:
X
XThe "if (xxx == broadcast)" tests can use 4 or 6 bytes of all ones
X(currently).  However if directed broadcasts are eventually implemented,
Xthe test would be a little different.
END_OF_FILE
if test 5070 -ne `wc -c <'gmods'`; then
    echo shar: \"'gmods'\" unpacked with wrong size!
fi
# end of 'gmods'
fi
if test -f 'hash.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hash.c'\"
else
echo shar: Extracting \"'hash.c'\" \(10269 characters\)
sed "s/^X//" >'hash.c' <<'END_OF_FILE'
X#ifndef _BLURB_
X#define _BLURB_
X/************************************************************************
X          Copyright 1988, 1991 by Carnegie Mellon University
X
X                          All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted, provided
Xthat the above copyright notice appear in all copies and that both that
Xcopyright notice and this permission notice appear in supporting
Xdocumentation, and that the name of Carnegie Mellon University not be used
Xin advertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.
X
XCARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
XSOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
XIN NO EVENT SHALL CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
XDAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
XPROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
XACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X************************************************************************/
X#endif /* _BLURB_ */
X
X
X#ifndef lint
Xstatic char rcsid[] = "$Header: /afs/andrew.cmu.edu/netdev/src/cmu/bootp-public/RCS/hash.c,v 1.3 1991/11/01 10:02:29 ww0n Exp ww0n $";
X#endif
X
X
X/*
X * Generalized hash table ADT
X *
X * Provides multiple, dynamically-allocated, variable-sized hash tables on
X * various data and keys.
X *
X * This package attempts to follow some of the coding conventions suggested
X * by Bob Sidebotham and the AFS Clean Code Committee of the
X * Information Technology Center at Carnegie Mellon.
X */
X
X
X#include "hash.h"
X
X#ifdef SVR4
X#define bcopy(a,b,c)    memcpy(b,a,c)
X#define bzero(p,l)      memset(p,0,l)
X#define bcmp(a,b,c)     memcmp(a,b,c)
X#endif
X
X#define TRUE		1
X#define FALSE		0
X#define NULL		0
X
X/*
X * This can be changed to make internal routines visible to debuggers, etc.
X */
X#define PRIVATE static
X
X
X
X/*
X * Hash table initialization routine.
X *
X * This routine creates and intializes a hash table of size "tablesize"
X * entries.  Successful calls return a pointer to the hash table (which must
X * be passed to other hash routines to identify the hash table).  Failed
X * calls return NULL.
X */
X
Xhash_tbl *hash_Init(tablesize)
Xunsigned tablesize;
X{
X    register hash_tbl *hashtblptr;
X    register unsigned totalsize;
X
X    if (tablesize > 0) {
X	totalsize = sizeof(hash_tbl)
X			+ sizeof(hash_member *) * (tablesize - 1);
X	hashtblptr = (hash_tbl *) malloc(totalsize);
X	if (hashtblptr) {
X	    bzero((char *) hashtblptr, totalsize);
X	    hashtblptr->size = tablesize;		/* Success! */
X	    hashtblptr->bucketnum = 0;
X	    hashtblptr->member = (hashtblptr->table)[0];
X	}
X    } else {
X	hashtblptr = NULL;	/* Disallow zero-length tables */
X    }
X    return hashtblptr;		/* NULL if failure */
X}
X
X
X
X/*
X * Recursively frees an entire linked list of bucket members (used in the open
X * hashing scheme).  Does nothing if the passed pointer is NULL.
X */
X
XPRIVATE void hashi_FreeMember(bucketptr, free_data)
Xhash_member *bucketptr;
Xvoid (*free_data)();
X{
X    if (bucketptr) {
X	/*
X	 * Free next member if necessary
X	 */
X	hashi_FreeMember(bucketptr->next, free_data);
X	(*free_data)(bucketptr->data);
X	free((char *) bucketptr);
X    }
X}
X
X
X
X
X/*
X * This routine re-initializes the hash table.  It frees all the allocated
X * memory and resets all bucket pointers to NULL.
X */
X
Xvoid hash_Reset(hashtable, free_data)
Xhash_tbl *hashtable;
Xvoid (*free_data)();
X{
X    hash_member **bucketptr;
X    unsigned i;
X
X    bucketptr = hashtable->table;
X    for (i = 0; i < hashtable->size; i++) {
X	hashi_FreeMember(*bucketptr, free_data);
X	*bucketptr++ = NULL;
X    }	
X    hashtable->bucketnum = 0;
X    hashtable->member = (hashtable->table)[0];
X}
X
X
X
X/*
X * Generic hash function to calculate a hash code from the given string.
X *
X * For each byte of the string, this function left-shifts the value in an
X * accumulator and then adds the byte into the accumulator.  The contents of
X * the accumulator is returned after the entire string has been processed.
X * It is assumed that this result will be used as the "hashcode" parameter in
X * calls to other functions in this package.  These functions automatically
X * adjust the hashcode for the size of each hashtable.
X *
X * This algorithm probably works best when the hash table size is a prime
X * number.
X *
X * Hopefully, this function is better than the previous one which returned
X * the sum of the squares of all the bytes.  I'm still open to other
X * suggestions for a default hash function.  The programmer is more than
X * welcome to supply his/her own hash function as that is one of the design
X * features of this package.
X */
X
Xunsigned hash_HashFunction(string, len)
Xunsigned char *string;
Xregister unsigned len;
X{
X    register unsigned accum;
X
X    accum = 0;
X    for (; len > 0; len--) {
X	accum <<= 1;
X	accum += (unsigned) (*string++ & 0xFF);
X    }
X    return accum;
X}
X
X
X
X/*
X * Returns TRUE if at least one entry for the given key exists; FALSE
X * otherwise.
X */
X
Xint hash_Exists(hashtable, hashcode, compare, key)
Xhash_tbl *hashtable;
Xunsigned hashcode;
Xint (*compare)();
Xhash_datum *key;
X{
X    register hash_member *memberptr;
X
X    memberptr = (hashtable->table)[hashcode % (hashtable->size)];
X    while (memberptr) {
X	if ((*compare)(key, memberptr->data)) {
X	    return TRUE;		/* Entry does exist */
X	}
X	memberptr = memberptr->next;
X    }
X    return FALSE;			/* Entry does not exist */
X}
X
X
X
X/*
X * Insert the data item "element" into the hash table using "hashcode"
X * to determine the bucket number, and "compare" and "key" to determine
X * its uniqueness.
X *
X * If the insertion is successful 0 is returned.  If a matching entry
X * already exists in the given bucket of the hash table, or some other error
X * occurs, -1 is returned and the insertion is not done.
X */
X
Xint hash_Insert(hashtable, hashcode, compare, key, element)
Xhash_tbl *hashtable;
Xunsigned hashcode;
Xint (*compare)();
Xhash_datum *key, *element;
X{
X    hash_member *memberptr, *temp;
X    
X    hashcode %= hashtable->size;
X    if (hash_Exists(hashtable, hashcode, compare, key)) {
X	return -1;	/* At least one entry already exists */
X    }
X    memberptr = (hashtable->table)[hashcode];
X    temp = (hash_member *) malloc(sizeof(hash_member));
X    if (temp) {
X	(hashtable->table)[hashcode] = temp;
X	temp->data = element;
X	temp->next = memberptr;
X	return 0;	/* Success */
X    } else {
X	return -1;	/* malloc failed! */
X    }
X}
X
X
X
X/*
X * Delete all data elements which match the given key.  If at least one
X * element is found and the deletion is successful, 0 is returned.
X * If no matching elements can be found in the hash table, -1 is returned.
X */
X
Xint hash_Delete(hashtable, hashcode, compare, key, free_data)
Xhash_tbl *hashtable;
Xunsigned hashcode;
Xint (*compare)();
Xhash_datum *key;
Xvoid (*free_data)();
X{
X    hash_member *memberptr, *previous, *tempptr;
X    int retval;
X
X    retval = -1;
X    hashcode %= hashtable->size;
X
X    /*
X     * Delete the first member of the list if it matches.  Since this moves
X     * the second member into the first position we have to keep doing this
X     * over and over until it no longer matches.
X     */
X    memberptr = (hashtable->table)[hashcode];
X    while (memberptr && (*compare)(key, memberptr->data)) {
X	(hashtable->table)[hashcode] = memberptr->next;
X	/*
X	 * Stop hashi_FreeMember() from recursively deleting the whole list!
X	 */
X	memberptr->next = NULL;
X	hashi_FreeMember(memberptr, free_data);
X	memberptr = (hashtable->table)[hashcode];
X	retval = 0;
X    }
X
X    /*
X     * Now traverse the rest of the list
X     */
X    if (memberptr) {
X	previous = memberptr;
X	memberptr = memberptr->next;
X    }
X    while (memberptr) {
X	if ((*compare)(key, memberptr->data)) {
X	    tempptr = memberptr;
X	    previous->next = memberptr = memberptr->next;
X	    /*
X	     * Put the brakes on hashi_FreeMember(). . . .
X	     */
X	    tempptr->next = NULL;
X	    hashi_FreeMember(tempptr, free_data);
X	    retval = 0;
X	} else {
X	    previous = memberptr;
X	    memberptr = memberptr->next;
X	}
X    }
X    return retval;
X}
X
X
X
X/*
X * Locate and return the data entry associated with the given key.
X *
X * If the data entry is found, a pointer to it is returned.  Otherwise,
X * NULL is returned.
X */
X
Xhash_datum *hash_Lookup(hashtable, hashcode, compare, key)
Xhash_tbl *hashtable;
Xunsigned hashcode;
Xint (*compare)();
Xhash_datum *key;
X{
X    hash_member *memberptr;
X
X    memberptr = (hashtable->table)[hashcode % (hashtable->size)];
X    while (memberptr) {
X	if ((*compare)(key, memberptr->data)) {
X	    return (memberptr->data);
X	}
X	memberptr = memberptr->next;
X    }
X    return NULL;
X}
X
X
X
X/*
X * Return the next available entry in the hashtable for a linear search
X */
X
Xhash_datum *hash_NextEntry(hashtable)
Xhash_tbl *hashtable;
X{
X    register unsigned bucket;
X    register hash_member *memberptr;
X
X    /*
X     * First try to pick up where we left off.
X     */
X    memberptr = hashtable->member;
X    if (memberptr) {
X	hashtable->member = memberptr->next;	/* Set up for next call */
X	return memberptr->data;			/* Return the data */
X    }
X
X    /*
X     * We hit the end of a chain, so look through the array of buckets
X     * until we find a new chain (non-empty bucket) or run out of buckets.
X     */
X    bucket = hashtable->bucketnum + 1;
X    while ((bucket < hashtable->size) && 
X	   !(memberptr = (hashtable->table)[bucket])) {
X	bucket++;
X    }
X
X    /*
X     * Check to see if we ran out of buckets.
X     */
X    if (bucket >= hashtable->size) {
X	/*
X	 * Reset to top of table for next call.
X	 */
X	hashtable->bucketnum = 0;
X	hashtable->member = (hashtable->table)[0];
X	/*
X	 * But return end-of-table indication to the caller this time.
X	 */
X	return NULL;
X    }
X
X    /*
X     * Must have found a non-empty bucket.
X     */
X    hashtable->bucketnum = bucket;
X    hashtable->member = memberptr->next;	/* Set up for next call */
X    return memberptr->data;			/* Return the data */
X}
X
X
X
X/*
X * Return the first entry in a hash table for a linear search
X */
X
Xhash_datum *hash_FirstEntry(hashtable)
Xhash_tbl *hashtable;
X{
X    hashtable->bucketnum = 0;
X    hashtable->member = (hashtable->table)[0];
X    return hash_NextEntry(hashtable);
X}
END_OF_FILE
if test 10269 -ne `wc -c <'hash.c'`; then
    echo shar: \"'hash.c'\" unpacked with wrong size!
fi
# end of 'hash.c'
fi
if test -f 'hash.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hash.h'\"
else
echo shar: Extracting \"'hash.h'\" \(4406 characters\)
sed "s/^X//" >'hash.h' <<'END_OF_FILE'
X#ifndef _BLURB_
X#define _BLURB_
X/************************************************************************
X          Copyright 1988, 1991 by Carnegie Mellon University
X
X                          All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted, provided
Xthat the above copyright notice appear in all copies and that both that
Xcopyright notice and this permission notice appear in supporting
Xdocumentation, and that the name of Carnegie Mellon University not be used
Xin advertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.
X
XCARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
XSOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
XIN NO EVENT SHALL CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
XDAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
XPROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
XACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X************************************************************************/
X#endif /* _BLURB_ */
X
X
X/*
X * Generalized hash table ADT
X *
X * Provides multiple, dynamically-allocated, variable-sized hash tables on
X * various data and keys.
X *
X * This package attempts to follow some of the coding conventions suggested
X * by Bob Sidebotham and the AFS Clean Code Committee.
X */
X
X
X/*
X * The user must supply the following:
X *
X *	1.  A comparison function which is declared as:
X *
X *		int compare(data1, data2)
X *		hash_datum *data1, *data2;
X *
X *	    This function must compare the desired fields of data1 and
X *	    data2 and return TRUE (1) if the data should be considered
X *	    equivalent (i.e. have the same key value) or FALSE (0)
X *	    otherwise.  This function is called through a pointer passed to
X *	    the various hashtable functions (thus pointers to different
X *	    functions may be passed to effect different tests on different
X *	    hash tables).
X *
X *	    Internally, all the functions of this package always call the
X *	    compare function with the "key" parameter as the first parameter,
X *	    and a full data element as the second parameter.  Thus, the key
X *	    and element arguments to functions such as hash_Lookup() may
X *	    actually be of different types and the programmer may provide a
X *	    compare function which compares the two different object types
X *	    as desired.
X *
X *	    Example:
X *
X *		int compare(key, element)
X *		char *key;
X *		struct some_complex_structure *element;
X *		{
X *		    return !strcmp(key, element->name);
X *		}
X *
X *		key = "John C. Doe"
X *		element = &some_complex_structure
X *		hash_Lookup(table, hashcode, compare, key);
X *
X *	2.  A hash function yielding an unsigned integer value to be used
X *	    as the hashcode (index into the hashtable).  Thus, the user
X *	    may hash on whatever data is desired and may use several
X *	    different hash functions for various different hash tables.
X *	    The actual hash table index will be the passed hashcode modulo
X *	    the hash table size.
X *
X *	    A generalized hash function, hash_HashFunction(), is included
X *	    with this package to make things a little easier.  It is not
X *	    guarenteed to use the best hash algorithm in existence. . . .
X */
X
X
X
X/*
X * Various hash table definitions
X */
X
X
X#ifndef __HASHXYZ973__
X
X#define __HASHXYZ973__
X
X/*
X * Define "hash_datum" as a universal data type
X */
X#ifdef __STDC__
Xtypedef void hash_datum;
X#else
Xtypedef char hash_datum;
X#endif
X
Xtypedef struct hash_memberstruct  hash_member;
Xtypedef struct hash_tblstruct     hash_tbl;
Xtypedef struct hash_tblstruct_hdr hash_tblhdr;
X
Xstruct hash_memberstruct {
X    hash_member *next;
X    hash_datum  *data;
X};
X
Xstruct hash_tblstruct_hdr {
X    unsigned	size, bucketnum;
X    hash_member *member;
X};
X
Xstruct hash_tblstruct {
X    unsigned	size, bucketnum;
X    hash_member *member;		/* Used for linear dump */
X    hash_member	*table[1];		/* Dynamically extended */
X};
X
Xextern hash_tbl	  *hash_Init();
Xextern void	   hash_Reset();
Xextern unsigned	   hash_HashFunction();
Xextern int	   hash_Exists();
Xextern int	   hash_Insert();
Xextern int	   hash_Delete();
Xextern hash_datum *hash_Lookup();
Xextern hash_datum *hash_FirstEntry();
Xextern hash_datum *hash_NextEntry();
X
X#endif
END_OF_FILE
if test 4406 -ne `wc -c <'hash.h'`; then
    echo shar: \"'hash.h'\" unpacked with wrong size!
fi
# end of 'hash.h'
fi
if test -f 'newvers.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newvers.sh'\"
else
echo shar: Extracting \"'newvers.sh'\" \(824 characters\)
sed "s/^X//" >'newvers.sh' <<'END_OF_FILE'
X#!/bin/sh -
X#
X# Copyright (c) 1987 Regents of the University of California.
X# All rights reserved.
X#
X# Redistribution and use in source and binary forms are permitted
X# provided that this notice is preserved and that due credit is given
X# to the University of California at Berkeley. The name of the University
X# may not be used to endorse or promote products derived from this
X# software without specific prior written permission. This software
X# is provided ``as is'' without express or implied warranty.
X#
X#	@(#)newvers.sh	4.4 (Berkeley) 3/28/88
X#
Xif [ ! -r version ]
Xthen
X	echo 0 > version
Xfi
Xtouch version
Xrm -f version.[oc]
Xv=`cat version` u=${USER-root} d=`pwd` h=`hostname` t=`date`
Xsed -e "s|%VERSION%|#${v}: ${t}|" -e "s|%WHOANDWHERE%|${u}@${h}:${d}|" \
X	< Version.c >version.c
X/bin/echo `expr ${v} + 1` > version
END_OF_FILE
if test 824 -ne `wc -c <'newvers.sh'`; then
    echo shar: \"'newvers.sh'\" unpacked with wrong size!
fi
# end of 'newvers.sh'
fi
echo shar: End of archive 1 \(of 2\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
