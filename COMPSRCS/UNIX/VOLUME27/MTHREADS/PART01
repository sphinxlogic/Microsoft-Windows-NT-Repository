Newsgroups: comp.sources.unix
From: davison@borland.com (Wayne Davison)
Subject: v27i090: mthreads - netnews database generator/manager, V3.1, Part01/04
Message-id: <1.753873779.13611@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: davison@borland.com (Wayne Davison)
Posting-Number: Volume 27, Issue 90
Archive-Name: mthreads/part01

[ Tomorrow i'm going to post trn-3.3, and this package is a prerequisite
  for any site who wishes to use TRN in thread mode and does not have INN.
  The text below is from the README file.				--vix ]

What is mthreads?
-------------------
Mthreads is a news database manager that processes one or more newsgroups
into a tree-structured list of articles related by their References and
Subject lines.  The result for each group you enable is a .thread file
that trn (i.e. Threaded Read News) can read in to get a quick summary of
the articles in the group and how they are releated.  Mthreads takes up
about 3 - 5% of your news-spool if you enable all groups.

Where to send bug reports
-------------------------
Mail your bug reports to Wayne Davison <davison@borland.com>.  If you type
"mthreads -V" you will be reminded of this address should you forget.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 4)."
# Contents:  EXTERN.h INSTALL INTERN.h MANIFEST Makefile.SH NEW README
#   common.h config.h.SH dependencies hints hints/aix_rs.sh
#   hints/altos486.sh hints/convexos.sh hints/dec_osf1.sh
#   hints/dgux.sh hints/domainos.sh hints/dynix.sh hints/hp9000_800.sh
#   hints/hpux.sh hints/i386.sh hints/isc_2_2_1.sh hints/isc_3_2_2.sh
#   hints/isc_3_2_3.sh hints/mc6000.sh hints/mips.sh hints/next.sh
#   hints/osf1.sh hints/sco_3.sh hints/sco_3_2_4.sh hints/sco_xenix.sh
#   hints/sgi.sh hints/solaris_2_0.sh hints/solaris_2_1.sh
#   hints/solaris_2_2.sh hints/sunos_4_1.sh hints/svr4.sh
#   makedepend.SH makedir.SH mt-misc.c mt-write.c mt.check.SH
#   mthreads.h ndir.c ndir.h nntpclient.c nntpclient.h nntpinit.c
#   patchlevel.h thread.h unipatch.c
# Wrapped by vixie@gw.home.vix.com on Sun Nov 21 01:11:59 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'EXTERN.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'EXTERN.h'\"
else
echo shar: Extracting \"'EXTERN.h'\" \(725 characters\)
sed "s/^X//" >'EXTERN.h' <<'END_OF_FILE'
X/* $Id: EXTERN.h,v 3.0 1991/09/09 20:18:23 davison Trn $
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#undef EXT
X#define EXT extern
X
X#undef INIT
X#define INIT(x)
X
X#undef DOINIT
END_OF_FILE
if test 725 -ne `wc -c <'EXTERN.h'`; then
    echo shar: \"'EXTERN.h'\" unpacked with wrong size!
fi
# end of 'EXTERN.h'
fi
if test -f 'INSTALL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'INSTALL'\"
else
echo shar: Extracting \"'INSTALL'\" \(2142 characters\)
sed "s/^X//" >'INSTALL' <<'END_OF_FILE'
XInstallation Instructions for mthreads 3.0:
X
X1)  Run Configure.  This will figure out various things about your system.
X    Some things Configure will figure out for itself, other things it will
X    ask you about.  It will then proceed to make config.h, config.sh, the
X    Makefile, and a few shell scripts.  You might possibly have to trim
X    # comments from the front of Configure if your sh doesn't handle them,
X    but all other # comments will be taken care of.
X
X2)  Glance through config.h and common.h to make sure system dependencies
X    are correct.  Most of them should have been taken care of by running
X    the Configure script.
X
X    If you have any additional changes to make to the C definitions, they
X    can be done in the Makefile, in config.h, or in common.h.
X
X3)  make
X
X    This will attempt to make mthreads in the current directory.
X
X4)  make install
X
X    This will put mthreads and its support files into the directory
X    of your choosing.  It also tries to put the mthreads man page in
X    a reasonable place.
X
X5)  Read the manual entry before running mthreads to familiarize yourself
X    with its operation and options.
X
X6)  IMPORTANT!  Help save the world!  Communicate any problems and suggested
X    patches to Wayne Davison <davison@borland.com> so we can keep the world
X    in sync.  If you have a problem, there's someone else out there who
X    either has had or will have the same problem.
X
X    If possible, send in patches such that the patch program will apply them.
X    Unified or regular context diffs are the best, then normal diffs.  Don't
X    send ed scripts--I've probably changed my copy since the version you have.
X
X    Watch for mthreads patches in news.software.readers.  Patches will be
X    in the unified context diff format, for application by the patch program.
X    If you don't have a patch program that handles unified context diffs,
X    you'll probably want to get one (such as patch version 12g8).  Otherwise,
X    you can use the (included) filter "unipatch", which can be generated with
X    the command "make unipatch".  To apply patches, use the command:
X
X	unipatch <patchfile | patch -p
END_OF_FILE
if test 2142 -ne `wc -c <'INSTALL'`; then
    echo shar: \"'INSTALL'\" unpacked with wrong size!
fi
# end of 'INSTALL'
fi
if test -f 'INTERN.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'INTERN.h'\"
else
echo shar: Extracting \"'INTERN.h'\" \(768 characters\)
sed "s/^X//" >'INTERN.h' <<'END_OF_FILE'
X/* $Id: INTERN.h,v 3.0 1991/09/09 20:18:23 davison Trn $
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#undef EXT
X#define EXT
X
X#undef INIT
X#ifdef xenix
X#define INIT(x) =x
X#else
X#define INIT(x) = x
X#endif
X
X#define DOINIT
END_OF_FILE
if test 768 -ne `wc -c <'INTERN.h'`; then
    echo shar: \"'INTERN.h'\" unpacked with wrong size!
fi
# end of 'INTERN.h'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1863 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Configure                  4	
X EXTERN.h                   1	
X INSTALL                    1	
X INTERN.h                   1	
X MANIFEST                   1	
X Makefile.SH                1	
X NEW                        1	
X README                     1	
X common.h                   1	
X config.h.SH                1	
X dependencies               1	
X hints                      1	
X hints/aix_rs.sh            1	
X hints/altos486.sh          1	
X hints/convexos.sh          1	
X hints/dec_osf1.sh          1	
X hints/dgux.sh              1	
X hints/domainos.sh          1	
X hints/dynix.sh             1	
X hints/hp9000_800.sh        1	
X hints/hpux.sh              1	
X hints/i386.sh              1	
X hints/isc_2_2_1.sh         1	
X hints/isc_3_2_2.sh         1	
X hints/isc_3_2_3.sh         1	
X hints/mc6000.sh            1	
X hints/mips.sh              1	
X hints/next.sh              1	
X hints/osf1.sh              1	
X hints/sco_3.sh             1	
X hints/sco_3_2_4.sh         1	
X hints/sco_xenix.sh         1	
X hints/sgi.sh               1	
X hints/solaris_2_0.sh       1	
X hints/solaris_2_1.sh       1	
X hints/solaris_2_2.sh       1	
X hints/sunos_4_1.sh         1	
X hints/svr4.sh              1	
X makedepend.SH              1	
X makedir.SH                 1	
X mt-misc.c                  1	
X mt-process.c               3	
X mt-read.c                  2	
X mt-write.c                 1	
X mt.check.SH                1	
X mthreads.8                 2	
X mthreads.c                 2	
X mthreads.h                 1	
X ndir.c                     1	
X ndir.h                     1	
X nntpclient.c               1	
X nntpclient.h               1	
X nntpinit.c                 1	
X parsedate.y                2	
X patchlevel.h               1	
X thread.h                   1	
X unipatch.c                 1	
END_OF_FILE
if test 1863 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.SH'\"
else
echo shar: Extracting \"'Makefile.SH'\" \(2482 characters\)
sed "s/^X//" >'Makefile.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X    '') . ./config.sh ;;
Xesac
Xecho "Extracting Makefile (with variable substitutions)"
X$cat >Makefile <<!GROK!THIS!
X# $Id: Makefile.SH,v 3.0 1992/03/01 02:13:32 davison Trn $
X
XCC = $cc
Xmtlib = $installprivlib
Xmansrc = $installmansrc
Xmanext = $manext
XCFLAGS = $optimize $ccflags
XLDFLAGS = $ldflags
X#NNTPNNTPFLAGS = $nntpflags
Xndirc = $ndirc
Xndiro = $ndiro
X
Xlibs = $libndir $jobslib -lm $libs
X!GROK!THIS!
X$cat >>Makefile <<'!NO!SUBS!'
X
Xpublic = mthreads mt.check
Xprivate = makedir filexp
Xmanpages = mthreads.8
Xutil = Makefile makedepend
X#NNTPnntpsrc=nntpinit.c nntpclient.c
X#NNTPnntpobj=nntpinit.o nntpclient.o
X
Xh = common.h mthreads.h threads.h
X
Xc = mthreads.c mt-read.c mt-process.c mt-write.c mt-misc.c $(ndirc) $(nntpsrc)
X
Xobj = mthreads.o mt-read.o mt-process.o mt-write.o mt-misc.o parsedate.o \
X	$(ndiro) $(nntpobj)
X
Xaddedbymake = Makefile.old mt.check config.h makedepend makedir mthreads all
X
X# grrr
XSHELL = /bin/sh
X
X.c.o:
X	$(CC) -c $(CFLAGS) $*.c
X
Xall: $(public) $(private) $(util)
X	touch all
X
Xmthreads: $(obj)
X	$(CC) $(LDFLAGS) $(obj) $(libs) -o mthreads
X#NNTP
X#NNTPnntpinit.o:
X#NNTP	$(CC) -c $(CFLAGS) $(NNTPFLAGS) $*.c
X
Xunipatch: unipatch.o
X	$(CC) $(LDFLAGS) unipatch.o -o unipatch
X
X# if a .h file depends on another .h file...
X$(h):
X	-touch $@
X
Xinstall: $(public) $(private) $(manpages)
X# won't work with csh
X	export PATH || exit 1
X	- ./makedir `./filexp $(mtlib)`
X	- cd `./filexp $(mtlib)`; mv mthreads mthreads.old
X	- if test `pwd` != `./filexp $(mtlib)`; then cp $(public) `./filexp $(mtlib)`; fi
X	- if test `pwd` != `./filexp $(mtlib)`; then cp $(private) `./filexp $(mtlib)`; fi
X	- if test `pwd` != `./filexp $(mtlib)`; then strip `./filexp $(mtlib)`/mthreads ; fi
X	- if test "X$(mansrc)" != "X" -a "X`pwd`" != X$(mansrc); then \
Xfor page in $(manpages); do \
Xdest=$(mansrc)/`basename $$page .8`.$(manext); \
Xrm -f $$dest; cp $$page $$dest; chmod 444 $$dest; \
Xdone; \
Xfi
X
Xclean:
X	@ echo 'Use "make realclean" to remove the executables and Configure droppings.'
X	@ echo 'Use "make spotless" to also remove config.sh'
X	rm -f *.o
X
Xrealclean: clean
X	rm -f core $(addedbymake)
X
Xspotless: realclean
X	rm -f config.sh
X
Xdepend: config.h Makefile
X	./makedepend
X
X# AUTOMATICALLY GENERATED MAKE DEPENDENCIES--PUT NOTHING BELOW THIS LINE
X!NO!SUBS!
X$cat dependencies >>Makefile
Xcase "$d_nntp" in
Xdefine)	sed < Makefile -e '/^#NNTP/s/^#NNTP//' > Makefile.new ;;
X*)	sed < Makefile -e '/^#NNTP/d' > Makefile.new ;;
Xesac
Xmv Makefile.new Makefile
X$eunicefix Makefile
END_OF_FILE
if test 2482 -ne `wc -c <'Makefile.SH'`; then
    echo shar: \"'Makefile.SH'\" unpacked with wrong size!
fi
# end of 'Makefile.SH'
fi
if test -f 'NEW' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'NEW'\"
else
echo shar: Extracting \"'NEW'\" \(320 characters\)
sed "s/^X//" >'NEW' <<'END_OF_FILE'
XThe only major differences between mthreads 2.5 and mthreads 3.0 is the
Xseparation of the mthreads package from the trn package and the use of
Xthe new Configure and nntp client library routines from trn 3.0.
X
XNew for mthreads 3.1, a better Configure script, easier installation, and
Xmore forgiving NNTP server handling.
END_OF_FILE
if test 320 -ne `wc -c <'NEW'`; then
    echo shar: \"'NEW'\" unpacked with wrong size!
fi
# end of 'NEW'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(1147 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X			Mthreads Kit, Version 3.1
X
X		    Copyright (c) 1993, Wayne Davison
X
XYou may copy the mthreads kit in whole or in part as long as you don't try
Xto make money off it, or pretend that you wrote it.
X--------------------------------------------------------------------------
X
XSee the file INSTALL for installation instructions.  Failure to do so
Xmay void your warranty. :-)
X
XAfter you have unpacked your kit, you should have all the files listed
Xin MANIFEST (Configure checks this for you).
X
X
XWhat is mthreads?
X-------------------
XMthreads is a news database manager that processes one or more newsgroups
Xinto a tree-structured list of articles related by their References and
XSubject lines.  The result for each group you enable is a .thread file
Xthat trn (i.e. Threaded Read News) can read in to get a quick summary of
Xthe articles in the group and how they are releated.  Mthreads takes up
Xabout 3 - 5% of your news-spool if you enable all groups.
X
XWhere to send bug reports
X-------------------------
XMail your bug reports to Wayne Davison <davison@borland.com>.  If you type
X"mthreads -V" you will be reminded of this address should you forget.
END_OF_FILE
if test 1147 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'common.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common.h'\"
else
echo shar: Extracting \"'common.h'\" \(4804 characters\)
sed "s/^X//" >'common.h' <<'END_OF_FILE'
X/* $Id: common.h,v 3.0 1992/02/23 21:25:39 davison $
X */
X/* The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <ctype.h>
X#include "config.h"	/* generated by installation script */
X
X#include <errno.h>
X#include <signal.h>
X#ifdef I_VFORK
X#  include <vfork.h>
X#endif
X
X#ifdef I_UNISTD
X#include <unistd.h>
X#endif
X#ifdef I_STDLIB
X#include <stdlib.h>
X#else
Xchar	*malloc();
Xchar	*realloc();
Xchar	*getenv();
X#endif
X
X#ifdef I_STRING
X#include <string.h>
X#else
X#include <strings.h>
X#endif
X
X#ifdef I_TIME
X#include <time.h>
X#endif
X#ifdef I_SYS_TIME
X#include <sys/time.h>
X#endif
X
X#define BITSPERBYTE 8
X#define LBUFLEN 1024	/* line buffer length */
X#define MAXFILENAME 512
X
X/* some handy defs */
X
X#define bool char
X#define bool_int int
X#define char_int int
X#ifndef TRUE
X#define TRUE (1)
X#endif
X#ifndef FALSE
X#define FALSE (0)
X#endif
X#define Null(t) ((t)0)
X#define Nullch Null(char *)
X#define Nullfp Null(FILE *)
X
X#define Ctl(ch) (ch & 037)
X
X#define strNE(s1,s2) (strcmp(s1,s2))
X#define strEQ(s1,s2) (!strcmp(s1,s2))
X#define strnNE(s1,s2,l) (strncmp(s1,s2,l))
X#define strnEQ(s1,s2,l) (!strncmp(s1,s2,l))
X
X/* Things we can figure out ourselves */
X
X#ifdef EUNICE
X#   define LINKART		/* add 1 level of possible indirection */
X#   define UNLINK(victim) while (!unlink(victim))
X#else
X#   define UNLINK(victim) unlink(victim)
X#endif
X
X/* *** System Dependent Stuff *** */
X
X#define MAKEDIR		/* use our makedir() instead of shell script */
X
X/* NOTE: many of these are defined in the config.h file */
X
X#ifdef NORMSIG
X#   define sigset signal
X#endif
X
X/* news library */
X#ifndef NEWSLIB		/* ~ and %l only ("~%l" is permissable) */
X#   define NEWSLIB "/usr/lib/news"
X#endif
X
X/* path to private executables */
X#ifndef PRIVLIB		/* ~, %x and %l only */
X#   define PRIVLIB "%x/trn"
X#endif
X
X/* where to find news files */
X#ifndef NEWSSPOOL		/* % and ~ */
X#   define NEWSSPOOL "/usr/spool/news"
X#endif
X
X# ifndef NEW_THREAD
X#   define NEW_THREAD ".new"
X# endif
X
X/* file containing list of active newsgroups and max article numbers */
X#ifndef ACTIVE			/* % and ~ */
X#   define ACTIVE "%x/active"
X#endif
X#ifdef USE_NNTP
X#   ifndef ACTIVE1
X#	define ACTIVE1 "%X/active1"
X#   endif
X#endif
X#ifndef ACTIVE2
X#   define ACTIVE2 "%X/active2"
X#endif
X#ifndef DBINIT
X#   define DBINIT "%W/db.init"
X#endif
X#ifndef MTPRELOCK
X#   define MTPRELOCK "%X/LOCK"
X#endif
X#ifndef MTLOCK
X#   define MTLOCK "%X/LOCKmthreads"
X#endif
X#ifndef MTDLOCK
X#   define MTDLOCK "%X/LOCKmtdaemon"
X#endif
X#ifndef MTLOG
X#   define MTLOG "%X/mt.log"
X#endif
X
X/* path to fastest starting shell */
X#ifndef SH
X#   define SH "/bin/sh"
X#endif
X
X#ifndef MAKEDIR
X/* shell script to make n-deep subdirectories */
X#   ifndef DIRMAKER		/* % and ~ */
X#	define DIRMAKER "%X/makedir"
X#   endif
X#endif
X
X/* how to open binary format files */
X#ifndef FOPEN_RB
X#   define FOPEN_RB "r"
X#endif
X#ifndef FOPEN_WB
X#   define FOPEN_WB "w"
X#endif
X
X/* what to do with ansi prototypes -- '()' == ignore, 'x' == use */
X#ifndef _
X#   ifdef __STDC__
X#	define _(x) x
X#   else
X#	define _(x) ()
X#   endif
X#endif
X
X/* some important types */
X
Xtypedef long		ART_NUM;	/* article number */
Xtypedef unsigned int	MEM_SIZE;	/* for passing to malloc */
X
X/* some slight-of-hand for compatibility issues */
X
X#ifdef HAS_STRCHR
X# ifndef index
X#   define index strchr
X# endif
X# ifndef rindex
X#   define rindex strrchr
X# endif
X#endif
X#ifdef HAS_MEMCMP
X# ifndef bcmp
X#   define bcmp(s,d,l) memcmp((s),(d),(l))
X# endif
X#endif
X#ifdef HAS_MEMCPY
X# ifndef bcopy
X#   define bcopy(s,d,l) memcpy((d),(s),(l))
X# endif
X#endif
X#ifdef HAS_MEMSET
X# ifndef bzero
X#   define bzero(s,l) memset((s),0,(l))
X# endif
X#endif
X
X#ifndef HAS_VFORK
X#   define vfork fork
X#endif
X
X/* *** end of the machine dependent stuff *** */
X
X/* GLOBAL THINGS */
X
X/* file statistics area */
X
XEXT struct stat filestat;
X
X/* various things of type char */
X
X#ifdef SUPPLEMENT_STRING_H
Xchar	*index();
Xchar	*rindex();
Xchar	*strcat();
Xchar	*strcpy();
X#endif
X
XEXT char buf[LBUFLEN+1];	/* general purpose line buffer */
X
X/* miscellania */
X
X#ifndef __STDC__
Xint fseek();
Xlong atol(), ftell();
Xextern int errno;
X#endif
X
XEXT char nullstr[1] INIT("");
X
X/* if subscripting is faster than shifting on your machine, define this */
X#undef USESUBSCRIPT
X#ifdef USESUBSCRIPT
XEXT char powerof2[] INIT({1,2,4,8,16,32,64,128});
X#define pow2(x) powerof2[x]
X#else
X#define pow2(x) (1 << (x))
X#endif
X#define OFFSET(a) ((a)-absfirst)
X
X#define ctl_set(a) (ctlarea[(OFFSET(a)) / BITSPERBYTE] |= pow2((OFFSET(a)) % BITSPERBYTE))
X#define ctl_check(a) ((ctlarea[(OFFSET(a)) / BITSPERBYTE] & pow2((OFFSET(a)) % BITSPERBYTE)) != 0)
X
X#define advise(str)
X#define report_error(str) log_entry(str)
END_OF_FILE
if test 4804 -ne `wc -c <'common.h'`; then
    echo shar: \"'common.h'\" unpacked with wrong size!
fi
# end of 'common.h'
fi
if test -f 'config.h.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config.h.SH'\"
else
echo shar: Extracting \"'config.h.SH'\" \(6750 characters\)
sed "s/^X//" >'config.h.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X'') . ./config.sh ;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting config.h (with variable substitutions)"
Xsed <<!GROK!THIS! >config.h -e 's!^#undef!/\*#define!'
X/*
X * This file was produced by running the config.h.SH script, which
X * gets its values from config.sh, which is generally produced by
X * running Configure.
X *
X * Feel free to modify any of this as the need arises.  Note, however,
X * that running config.h.SH again will wipe out any changes you've made.
X * For a more permanent change edit config.sh and rerun config.h.SH.
X *
X * \$Id: Config_h.U,v 3.0.1.2 1993/08/24 12:13:20 ram Exp $
X */
X
X/* Configuration time: $cf_time
X * Configured by: $cf_by
X * Target system: $myuname
X */
X
X#ifndef _config_h_
X#define _config_h_
X
X/* EUNICE:
X *	This symbol, if defined, indicates that the program is being compiled
X *	under the EUNICE package under VMS.  The program will need to handle
X *	things like files that don't go away the first time you unlink them,
X *	due to version numbering.  It will also need to compensate for lack
X *	of a respectable link() command.
X */
X#$d_eunice EUNICE		/**/
X
X/* HAS_CHSIZE:
X *	This symbol, if defined, indicates that the chsize routine is available
X *	to truncate files.  You might need a -lx to get this routine.
X */
X#$d_chsize	HAS_CHSIZE		/**/
X
X/* HAS_FTRUNCATE:
X *	This symbol, if defined, indicates that the ftruncate() subroutine
X *	exists.
X */
X#$d_ftrncate HAS_FTRUNCATE	/**/
X
X/* HAS_MEMCMP:
X *	This symbol, if defined, indicates that the memcmp routine is available
X *	to compare blocks of memory.
X */
X#$d_memcmp HAS_MEMCMP	/**/
X
X/* HAS_MEMCPY:
X *	This symbol, if defined, indicates that the memcpy routine is available
X *	to copy blocks of memory.
X */
X#$d_memcpy HAS_MEMCPY	/**/
X
X/* HAS_MEMSET:
X *	This symbol, if defined, indicates that the memset routine is available
X *	to set blocks of memory.
X */
X#$d_memset HAS_MEMSET	/**/
X
X/* NORMSIG:
X *	This symbol, if defined, indicates that normal signal handling routines
X *	should be used, as opposed to the ones in 4.1bsd (sigset, etc.).
X */
X#$d_normsig NORMSIG		/**/
X
X/* HAS_RENAME:
X *	This symbol, if defined, indicates that the rename routine is available
X *	to rename files.  Otherwise you should do the unlink(), link(), unlink()
X *	trick.
X */
X#$d_rename HAS_RENAME	/**/
X
X/* HAS_SIGHOLD:
X *	This symbol, if defined, indicates that the sighold routine is
X *	available to hold signals.
X */
X#$d_sighold HAS_SIGHOLD	/**/
X
X/* HAS_STRCHR:
X *	This symbol is defined to indicate that the strchr()/strrchr()
X *	functions are available for string searching. If not, try the
X *	index()/rindex() pair.
X */
X#$d_strchr HAS_STRCHR	/**/
X
X/* HAS_USLEEP:
X *	This symbol, if defined, indicates that the usleep routine is
X *	available to let the process sleep on a sub-second accuracy.
X */
X#$d_usleep HAS_USLEEP		/**/
X
X/* HAS_VFORK:
X *	This symbol, if defined, indicates that vfork() exists.
X */
X#$d_vfork HAS_VFORK	/**/
X
X/* Signal_t:
X *	This symbol's value is either "void" or "int", corresponding to the
X *	appropriate return type of a signal handler.  Thus, you can declare
X *	a signal handler using "Signal_t (*handler)()", and define the
X *	handler using "Signal_t handler(sig)".
X */
X#define Signal_t $signal_t	/* Signal handler's return type */
X
X/* I_DIRENT:
X *	This symbol, if defined, indicates to the C program that it should
X *	include <dirent.h>.
X */
X#$i_dirent I_DIRENT		/**/
X
X/* I_STDLIB:
X *	This symbol, if defined, indicates that <stdlib.h> exists and should
X *	be included.
X */
X#$i_stdlib I_STDLIB		/**/
X
X/* I_STRING:
X *	This symbol, if defined, indicates to the C program that it should
X *	include <string.h> (USG systems) instead of <strings.h> (BSD systems).
X */
X#$i_string I_STRING		/**/
X
X/* I_SYS_DIR:
X *	This symbol, if defined, indicates to the C program that it should
X *	include <sys/dir.h>.
X */
X#$i_sysdir I_SYS_DIR		/**/
X
X/* I_SYS_NDIR:
X *	This symbol, if defined, indicates to the C program that it should
X *	include <sys/ndir.h>.
X */
X#$i_sysndir I_SYS_NDIR	/**/
X
X/* I_UNISTD:
X *	This symbol, if defined, indicates to the C program that it should
X *	include <unistd.h>.
X */
X#$i_unistd I_UNISTD		/**/
X
X/* I_VFORK:
X *	This symbol, if defined, indicates to the C program that it should
X *	include vfork.h.
X */
X#$i_vfork I_VFORK	/**/
X
X/* ACTIVE:
X *	The name of the active file for the news system.  This file contains
X *	the list of active newsgroups.  The name may have ~ on the front.
X */
X/* ACTIVE_TIMES:
X *	The name of the active.times file for the news system.
X */
X#define ACTIVE "$active"		/**/
X#$d_acttimes ACTIVE_TIMES "$acttimes"		/**/
X
X/* USE_NNTP:
X *	This symbol, if defined, indicates that NNTP should be used.
X */
X/* SERVER_NAME:
X *	When using NNTP, this symbol indicates the server name or a
X *	file to open to read the server name.
X */
X#$d_nntp	USE_NNTP	/**/
X#define SERVER_NAME "$servername"  	/**/
X
X/* void:
X *	This symbol is used for void functions.  On implementations which
X *	support void appropriately, its value is "void".  Otherwise, its
X *	value should be set to "int".
X */
X#$d_novoid void int	/**/
X
X/* USE_SYSLOG:
X *	This symbol, if defined, indicates that syslog should be used.
X */
X/* SYSLOG_PRIORITY:
X *	This symbol defines the syslog priority when using syslog.
X */
X#$d_syslog USE_SYSLOG	/**/
X#$d_syslog SYSLOG_PRIORITY $syslog	/**/
X
X/* EMULATE_NDIR:
X *	This symbol, if defined, indicates that the program should compile
X *	the ndir.c code provided with the package.
X */
X/* I_NDIR:
X *	This symbol, if defined, indicates that the program should include the
X *	system's version of ndir.h, rather than the one with this package.
X */
X#$d_usendir	EMULATE_NDIR		/**/
X#$d_libndir	I_NDIR		/**/
X
X/* I_TIME:
X *	This symbol, if defined, indicates to the C program that it should
X *	include <time.h>.
X */
X/* I_SYS_TIME:
X *	This symbol, if defined, indicates to the C program that it should
X *	include <sys/time.h>.
X */
X#$i_time I_TIME		/**/
X#$i_systime I_SYS_TIME		/**/
X
X/* NEWSLIB:
X *	This symbol contains the name of the directory serving as the news
X *	library.  The program must be prepared to do ~ expansion on it.
X */
X#define NEWSLIB "$newslib"		/**/
X
X/* NEWSSPOOL:
X *	This symbol contains the directory name where news articles are
X *	spooled.  The program must be prepared to do ~ expansion on it.
X */
X#define NEWSSPOOL "$newsspool"		/**/
X
X/* PRIVLIB:
X *	This symbol contains the name of the private library for this package.
X *	The library is private in the sense that it needn't be in anyone's
X *	execution path, but it should be accessible by the world.  The program
X *	should be prepared to do ~ expansion.
X */
X#define PRIVLIB "$privlib"		/**/
X
X/* THREAD_DIR:
X *	This symbol indicates where the thread files go.
X */
X#define THREAD_DIR	"$threaddir"		/**/
X
X#endif
X!GROK!THIS!
END_OF_FILE
if test 6750 -ne `wc -c <'config.h.SH'`; then
    echo shar: \"'config.h.SH'\" unpacked with wrong size!
fi
# end of 'config.h.SH'
fi
if test -f 'dependencies' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dependencies'\"
else
echo shar: Extracting \"'dependencies'\" \(1479 characters\)
sed "s/^X//" >'dependencies' <<'END_OF_FILE'
Xmt-misc.o: EXTERN.h
Xmt-misc.o: common.h
Xmt-misc.o: config.h
Xmt-misc.o: mt-misc.c
Xmt-misc.o: mthreads.h
Xmt-misc.o: thread.h
Xmt-process.o: EXTERN.h
Xmt-process.o: common.h
Xmt-process.o: config.h
Xmt-process.o: mt-process.c
Xmt-process.o: mthreads.h
Xmt-process.o: ndir.h
Xmt-process.o: nntpclient.h
Xmt-process.o: thread.h
Xmt-read.o: EXTERN.h
Xmt-read.o: common.h
Xmt-read.o: config.h
Xmt-read.o: mt-read.c
Xmt-read.o: mthreads.h
Xmt-read.o: thread.h
Xmt-write.o: EXTERN.h
Xmt-write.o: common.h
Xmt-write.o: config.h
Xmt-write.o: mt-write.c
Xmt-write.o: mthreads.h
Xmt-write.o: thread.h
Xmthreads.o: EXTERN.h
Xmthreads.o: INTERN.h
Xmthreads.o: common.h
Xmthreads.o: config.h
Xmthreads.o: mthreads.c
Xmthreads.o: mthreads.h
Xmthreads.o: nntpclient.h
Xmthreads.o: patchlevel.h
Xmthreads.o: thread.h
Xndir.o: EXTERN.h
Xndir.o: INTERN.h
Xndir.o: common.h
Xndir.o: config.h
Xndir.o: ndir.c
Xndir.o: ndir.h
Xnntpclient.o: EXTERN.h
Xnntpclient.o: common.h
Xnntpclient.o: config.h
Xnntpclient.o: nntpclient.c
Xnntpinit.o: EXTERN.h
Xnntpinit.o: common.h
Xnntpinit.o: config.h
Xnntpinit.o: nntpclient.h
Xnntpinit.o: nntpinit.c
Xparsedate.o: config.h
Xparsedate.o: parsedate.y
Xunipatch.o: unipatch.c
XMakefile: Makefile.SH config.sh ; /bin/sh Makefile.SH
Xconfig.h: config.h.SH config.sh ; /bin/sh config.h.SH
Xmakedepend: makedepend.SH config.sh ; /bin/sh makedepend.SH
Xmakedir: makedir.SH config.sh ; /bin/sh makedir.SH
Xmt.check: mt.check.SH config.sh ; /bin/sh mt.check.SH
X# WARNING: Put nothing here or make depend will gobble it up!
END_OF_FILE
if test 1479 -ne `wc -c <'dependencies'`; then
    echo shar: \"'dependencies'\" unpacked with wrong size!
fi
# end of 'dependencies'
fi
if test ! -d 'hints' ; then
    echo shar: Creating directory \"'hints'\"
    mkdir 'hints'
fi
if test -f 'hints/aix_rs.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/aix_rs.sh'\"
else
echo shar: Extracting \"'hints/aix_rs.sh'\" \(58 characters\)
sed "s/^X//" >'hints/aix_rs.sh' <<'END_OF_FILE'
Xcppstdin='/lib/cpp -D_AIX -D_IBMR2 -U__STR__'
Xcppminus=''
END_OF_FILE
if test 58 -ne `wc -c <'hints/aix_rs.sh'`; then
    echo shar: \"'hints/aix_rs.sh'\" unpacked with wrong size!
fi
# end of 'hints/aix_rs.sh'
fi
if test -f 'hints/altos486.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/altos486.sh'\"
else
echo shar: Extracting \"'hints/altos486.sh'\" \(111 characters\)
sed "s/^X//" >'hints/altos486.sh' <<'END_OF_FILE'
X: have heard of problems with -lc_s on Altos 486
Xset `echo " $libswanted " | sed "s/ c_s / /"`
Xlibswanted="$*"
END_OF_FILE
if test 111 -ne `wc -c <'hints/altos486.sh'`; then
    echo shar: \"'hints/altos486.sh'\" unpacked with wrong size!
fi
# end of 'hints/altos486.sh'
fi
if test -f 'hints/convexos.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/convexos.sh'\"
else
echo shar: Extracting \"'hints/convexos.sh'\" \(139 characters\)
sed "s/^X//" >'hints/convexos.sh' <<'END_OF_FILE'
Xi_sgtty=undef
Xi_termios=define
Xccflags="-D__STDC__ -ext -tm c1"
Xd_voidsig='define'
Xsignal_t='void'
Xd_strchr='undef'
Xlibc='/usr/lib/libc.a'
END_OF_FILE
if test 139 -ne `wc -c <'hints/convexos.sh'`; then
    echo shar: \"'hints/convexos.sh'\" unpacked with wrong size!
fi
# end of 'hints/convexos.sh'
fi
if test -f 'hints/dec_osf1.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/dec_osf1.sh'\"
else
echo shar: Extracting \"'hints/dec_osf1.sh'\" \(132 characters\)
sed "s/^X//" >'hints/dec_osf1.sh' <<'END_OF_FILE'
Xlibpth="$libpth /usr/shlib" # Use the shared libraries if possible
Xlibc='/usr/shlib/libc.so'   # The archive version is /lib/libc.a
END_OF_FILE
if test 132 -ne `wc -c <'hints/dec_osf1.sh'`; then
    echo shar: \"'hints/dec_osf1.sh'\" unpacked with wrong size!
fi
# end of 'hints/dec_osf1.sh'
fi
if test -f 'hints/dgux.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/dgux.sh'\"
else
echo shar: Extracting \"'hints/dgux.sh'\" \(60 characters\)
sed "s/^X//" >'hints/dgux.sh' <<'END_OF_FILE'
Xcppstdin='/lib/cpp'
Xlibs='-ldgc'
Xd_strchr='define'
Xcc='gcc'
END_OF_FILE
if test 60 -ne `wc -c <'hints/dgux.sh'`; then
    echo shar: \"'hints/dgux.sh'\" unpacked with wrong size!
fi
# end of 'hints/dgux.sh'
fi
if test -f 'hints/domainos.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/domainos.sh'\"
else
echo shar: Extracting \"'hints/domainos.sh'\" \(40 characters\)
sed "s/^X//" >'hints/domainos.sh' <<'END_OF_FILE'
Xccflags='-A nansi'
Xd_ignoreorg='define'
END_OF_FILE
if test 40 -ne `wc -c <'hints/domainos.sh'`; then
    echo shar: \"'hints/domainos.sh'\" unpacked with wrong size!
fi
# end of 'hints/domainos.sh'
fi
if test -f 'hints/dynix.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/dynix.sh'\"
else
echo shar: Extracting \"'hints/dynix.sh'\" \(69 characters\)
sed "s/^X//" >'hints/dynix.sh' <<'END_OF_FILE'
Xlibswanted=`echo $libswanted | sed -e 's/socket /socket seq inet /'`
END_OF_FILE
if test 69 -ne `wc -c <'hints/dynix.sh'`; then
    echo shar: \"'hints/dynix.sh'\" unpacked with wrong size!
fi
# end of 'hints/dynix.sh'
fi
if test -f 'hints/hp9000_800.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/hp9000_800.sh'\"
else
echo shar: Extracting \"'hints/hp9000_800.sh'\" \(66 characters\)
sed "s/^X//" >'hints/hp9000_800.sh' <<'END_OF_FILE'
Xlibswanted=`echo $libswanted | sed -e 's/malloc //' -e 's/BSD //`
END_OF_FILE
if test 66 -ne `wc -c <'hints/hp9000_800.sh'`; then
    echo shar: \"'hints/hp9000_800.sh'\" unpacked with wrong size!
fi
# end of 'hints/hp9000_800.sh'
fi
if test -f 'hints/hpux.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/hpux.sh'\"
else
echo shar: Extracting \"'hints/hpux.sh'\" \(114 characters\)
sed "s/^X//" >'hints/hpux.sh' <<'END_OF_FILE'
Xcase `(uname -r) 2>/dev/null` in
X*2.1*) libswanted=`echo $libswanted | sed 's/malloc //'` ;;
Xesac
Xd_strchr=define
END_OF_FILE
if test 114 -ne `wc -c <'hints/hpux.sh'`; then
    echo shar: \"'hints/hpux.sh'\" unpacked with wrong size!
fi
# end of 'hints/hpux.sh'
fi
if test -f 'hints/i386.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/i386.sh'\"
else
echo shar: Extracting \"'hints/i386.sh'\" \(24 characters\)
sed "s/^X//" >'hints/i386.sh' <<'END_OF_FILE'
Xldflags='-L/usr/ucblib'
END_OF_FILE
if test 24 -ne `wc -c <'hints/i386.sh'`; then
    echo shar: \"'hints/i386.sh'\" unpacked with wrong size!
fi
# end of 'hints/i386.sh'
fi
if test -f 'hints/isc_2_2_1.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/isc_2_2_1.sh'\"
else
echo shar: Extracting \"'hints/isc_2_2_1.sh'\" \(14 characters\)
sed "s/^X//" >'hints/isc_2_2_1.sh' <<'END_OF_FILE'
Xd_ftime=undef
END_OF_FILE
if test 14 -ne `wc -c <'hints/isc_2_2_1.sh'`; then
    echo shar: \"'hints/isc_2_2_1.sh'\" unpacked with wrong size!
fi
# end of 'hints/isc_2_2_1.sh'
fi
if test -f 'hints/isc_3_2_2.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/isc_3_2_2.sh'\"
else
echo shar: Extracting \"'hints/isc_3_2_2.sh'\" \(86 characters\)
sed "s/^X//" >'hints/isc_3_2_2.sh' <<'END_OF_FILE'
Xset `echo $libswanted | sed -e 's/ x//' -e 's/malloc //'`
Xlibswanted="inet malloc $*"
END_OF_FILE
if test 86 -ne `wc -c <'hints/isc_3_2_2.sh'`; then
    echo shar: \"'hints/isc_3_2_2.sh'\" unpacked with wrong size!
fi
# end of 'hints/isc_3_2_2.sh'
fi
if test -f 'hints/isc_3_2_3.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/isc_3_2_3.sh'\"
else
echo shar: Extracting \"'hints/isc_3_2_3.sh'\" \(69 characters\)
sed "s/^X//" >'hints/isc_3_2_3.sh' <<'END_OF_FILE'
Xset `echo $libswanted | sed -e 's/ socket / inet /'`
Xlibswanted="$*"
END_OF_FILE
if test 69 -ne `wc -c <'hints/isc_3_2_3.sh'`; then
    echo shar: \"'hints/isc_3_2_3.sh'\" unpacked with wrong size!
fi
# end of 'hints/isc_3_2_3.sh'
fi
if test -f 'hints/mc6000.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/mc6000.sh'\"
else
echo shar: Extracting \"'hints/mc6000.sh'\" \(87 characters\)
sed "s/^X//" >'hints/mc6000.sh' <<'END_OF_FILE'
X# defaults for the masscomp (concurrent) 6000 series running RTU 5.0
Xcppstdin=/lib/cpp
END_OF_FILE
if test 87 -ne `wc -c <'hints/mc6000.sh'`; then
    echo shar: \"'hints/mc6000.sh'\" unpacked with wrong size!
fi
# end of 'hints/mc6000.sh'
fi
if test -f 'hints/mips.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/mips.sh'\"
else
echo shar: Extracting \"'hints/mips.sh'\" \(19 characters\)
sed "s/^X//" >'hints/mips.sh' <<'END_OF_FILE'
Xcc=cc
Xnm_opts='-B'
END_OF_FILE
if test 19 -ne `wc -c <'hints/mips.sh'`; then
    echo shar: \"'hints/mips.sh'\" unpacked with wrong size!
fi
# end of 'hints/mips.sh'
fi
if test -f 'hints/next.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/next.sh'\"
else
echo shar: Extracting \"'hints/next.sh'\" \(19 characters\)
sed "s/^X//" >'hints/next.sh' <<'END_OF_FILE'
Xlibswanted='sys_s'
END_OF_FILE
if test 19 -ne `wc -c <'hints/next.sh'`; then
    echo shar: \"'hints/next.sh'\" unpacked with wrong size!
fi
# end of 'hints/next.sh'
fi
if test -f 'hints/osf1.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/osf1.sh'\"
else
echo shar: Extracting \"'hints/osf1.sh'\" \(13 characters\)
sed "s/^X//" >'hints/osf1.sh' <<'END_OF_FILE'
Xlibswanted=m
END_OF_FILE
if test 13 -ne `wc -c <'hints/osf1.sh'`; then
    echo shar: \"'hints/osf1.sh'\" unpacked with wrong size!
fi
# end of 'hints/osf1.sh'
fi
if test -f 'hints/sco_3.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/sco_3.sh'\"
else
echo shar: Extracting \"'hints/sco_3.sh'\" \(72 characters\)
sed "s/^X//" >'hints/sco_3.sh' <<'END_OF_FILE'
Xlibswanted=`echo $libswanted | sed 's/ x//'`
Xcppminus=''
Xd_rename=undef
END_OF_FILE
if test 72 -ne `wc -c <'hints/sco_3.sh'`; then
    echo shar: \"'hints/sco_3.sh'\" unpacked with wrong size!
fi
# end of 'hints/sco_3.sh'
fi
if test -f 'hints/sco_3_2_4.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/sco_3_2_4.sh'\"
else
echo shar: Extracting \"'hints/sco_3_2_4.sh'\" \(62 characters\)
sed "s/^X//" >'hints/sco_3_2_4.sh' <<'END_OF_FILE'
Xxlibpth=''
Xmailer='/usr/lib/mail/execmail'
Xlibc='/lib/libc.a'
END_OF_FILE
if test 62 -ne `wc -c <'hints/sco_3_2_4.sh'`; then
    echo shar: \"'hints/sco_3_2_4.sh'\" unpacked with wrong size!
fi
# end of 'hints/sco_3_2_4.sh'
fi
if test -f 'hints/sco_xenix.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/sco_xenix.sh'\"
else
echo shar: Extracting \"'hints/sco_xenix.sh'\" \(60 characters\)
sed "s/^X//" >'hints/sco_xenix.sh' <<'END_OF_FILE'
Xi_dirent=undef
Xlibswanted=`echo $libswanted | sed 's/ x//'`
END_OF_FILE
if test 60 -ne `wc -c <'hints/sco_xenix.sh'`; then
    echo shar: \"'hints/sco_xenix.sh'\" unpacked with wrong size!
fi
# end of 'hints/sco_xenix.sh'
fi
if test -f 'hints/sgi.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/sgi.sh'\"
else
echo shar: Extracting \"'hints/sgi.sh'\" \(48 characters\)
sed "s/^X//" >'hints/sgi.sh' <<'END_OF_FILE'
Xd_voidsig=define
Xd_vfork=undef
Xd_sigblock=undef
END_OF_FILE
if test 48 -ne `wc -c <'hints/sgi.sh'`; then
    echo shar: \"'hints/sgi.sh'\" unpacked with wrong size!
fi
# end of 'hints/sgi.sh'
fi
if test -f 'hints/solaris_2_0.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/solaris_2_0.sh'\"
else
echo shar: Extracting \"'hints/solaris_2_0.sh'\" \(14 characters\)
sed "s/^X//" >'hints/solaris_2_0.sh' <<'END_OF_FILE'
Xd_vfork=undef
END_OF_FILE
if test 14 -ne `wc -c <'hints/solaris_2_0.sh'`; then
    echo shar: \"'hints/solaris_2_0.sh'\" unpacked with wrong size!
fi
# end of 'hints/solaris_2_0.sh'
fi
if test -f 'hints/solaris_2_1.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/solaris_2_1.sh'\"
else
echo shar: Extracting \"'hints/solaris_2_1.sh'\" \(96 characters\)
sed "s/^X//" >'hints/solaris_2_1.sh' <<'END_OF_FILE'
X#d_vfork=undef
Xi_dirent=define
Xi_sysdir=undef
Xlibs='-lmalloc -lsocket -lnls -lnsl -lintl -lucb'
END_OF_FILE
if test 96 -ne `wc -c <'hints/solaris_2_1.sh'`; then
    echo shar: \"'hints/solaris_2_1.sh'\" unpacked with wrong size!
fi
# end of 'hints/solaris_2_1.sh'
fi
if test -f 'hints/solaris_2_2.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/solaris_2_2.sh'\"
else
echo shar: Extracting \"'hints/solaris_2_2.sh'\" \(97 characters\)
sed "s/^X//" >'hints/solaris_2_2.sh' <<'END_OF_FILE'
Xd_sigblock='undef'
Xd_getcwd='define'
Xd_getwd='undef'
Xlibs='-lmalloc -lsocket -lnls -lnsl -lintl'
END_OF_FILE
if test 97 -ne `wc -c <'hints/solaris_2_2.sh'`; then
    echo shar: \"'hints/solaris_2_2.sh'\" unpacked with wrong size!
fi
# end of 'hints/solaris_2_2.sh'
fi
if test -f 'hints/sunos_4_1.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/sunos_4_1.sh'\"
else
echo shar: Extracting \"'hints/sunos_4_1.sh'\" \(31 characters\)
sed "s/^X//" >'hints/sunos_4_1.sh' <<'END_OF_FILE'
Xi_sgtty=define
Xi_termios=undef
END_OF_FILE
if test 31 -ne `wc -c <'hints/sunos_4_1.sh'`; then
    echo shar: \"'hints/sunos_4_1.sh'\" unpacked with wrong size!
fi
# end of 'hints/sunos_4_1.sh'
fi
if test -f 'hints/svr4.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hints/svr4.sh'\"
else
echo shar: Extracting \"'hints/svr4.sh'\" \(125 characters\)
sed "s/^X//" >'hints/svr4.sh' <<'END_OF_FILE'
Xcc='/bin/cc'
Xtest -f $cc || cc='/usr/ccs/bin/cc'
Xmansrc='/usr/share/man/man1'
Xlibswanted='malloc socket nsl'
Xd_strchr=define
END_OF_FILE
if test 125 -ne `wc -c <'hints/svr4.sh'`; then
    echo shar: \"'hints/svr4.sh'\" unpacked with wrong size!
fi
# end of 'hints/svr4.sh'
fi
if test -f 'makedepend.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makedepend.SH'\"
else
echo shar: Extracting \"'makedepend.SH'\" \(2446 characters\)
sed "s/^X//" >'makedepend.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X    '') . ./config.sh ;;
Xesac
Xecho "Extracting makedepend (with variable substitutions)"
X$spitshell >makedepend <<!GROK!THIS!
X$startsh
X# $Id: makedepend.SH,v 3.0 1991/09/09 20:23:31 davison Trn $
X# 
X# This software is Copyright 1991 by Stan Barber. 
X#
X# Permission is hereby granted to copy, reproduce, redistribute or otherwise
X# use this software as long as: there is no monetary profit gained
X# specifically from the use or reproduction of this software, it is not
X# sold, rented, traded or otherwise marketed, and this copyright notice is
X# included prominently in any copy made. 
X#
X# The author make no claims as to the fitness or correctness of this software
X# for any use whatsoever, and it is provided as is. Any use of this software
X# is at the user's own risk. 
Xexport PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
X
X$cat /dev/null >.deptmp
X$echo "(Note: this is going to take a while.)"
Xfor file in *.[cy]; do
X    case "\$file" in
X    *.c) filebase=\`basename \$file .c\`;;
X    *.y) filebase=\`basename \$file .y\`;;
X    esac
X    $echo "Finding dependencies for \$filebase.o."
X    $sed -n <\$file \\
X	-e "/^\${filebase}_init(/q" \\
X	-e '/^#/{' \\
X	-e 's|/\*.*$||' \\
X	-e 's/\\\\[ 	]*$//' \\
X	-e p \\
X	-e '}' | $cppstdin -I/usr/local/include | $sed \\
X	-e '/^# *line/s/line//' \
X	-e '/^# *[0-9]/!d' \\
X	-e 's/^.*"\(.*\)".*\$/'\$filebase'.o: \1/' \\
X	-e 's|: \./|: |' \\
X	-e 's/: .*\.c/: '\$file'/' | \\
X	$uniq | $sort | $uniq >> .deptmp
Xdone
X
Xfor file in *.SH; do
X    $echo \`basename \$file .SH\`: \$file config.sh \; /bin/sh \$file >> .deptmp
Xdone
X
X$sed <Makefile >Makefile.new -e '1,/^# AUTOMATICALLY/!d'
X
Xif $test -s .deptmp; then
X    echo "Updating Makefile..."
X    $sed -e 's/\\\$/\$\$/g' .deptmp | $egrep -v $usrinc >dependencies
Xelse
X    $echo "You don't seem to have a proper C preprocessor.  Using grep instead."
X    $egrep '^#include ' *.[cyh] ?.[cyh] >.deptmp
X    echo "Updating Makefile..."
X    <.deptmp $sed -n 's|c:#include "\(.*\)".*\$\$|o: \1|p' > dependencies
X    <.deptmp $sed -n 's|y:#include "\(.*\)".*\$\$|o: \1|p' >> dependencies
X    <.deptmp $sed -n 's|h:#include "\(.*\)".*\$\$|h: \1|p' >> dependencies
Xfi
X$echo "# WARNING: Put nothing here or make depend will gobble it up!" >> dependencies
X$mv Makefile Makefile.old
X$mv Makefile.new Makefile
X$cat dependencies >>Makefile
Xrm .deptmp
X!GROK!THIS!
X$eunicefix makedepend
Xchmod 755 makedepend
END_OF_FILE
if test 2446 -ne `wc -c <'makedepend.SH'`; then
    echo shar: \"'makedepend.SH'\" unpacked with wrong size!
fi
chmod +x 'makedepend.SH'
# end of 'makedepend.SH'
fi
if test -f 'makedir.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makedir.SH'\"
else
echo shar: Extracting \"'makedir.SH'\" \(1082 characters\)
sed "s/^X//" >'makedir.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X'') . ./config.sh ;;
Xesac
Xecho "Extracting makedir (with variable substitutions)"
X$spitshell >makedir <<!GROK!THIS!
X$startsh
X# $Id: makedir.SH,v 2.11 90/09/17 17:03:55 hokey Exp Locker: hokey $
X# 
X# $Log:	makedir.SH,v $
X# Revision 2.11  90/09/17  17:03:55  hokey
X# 2.11 alpha baseline
X# 
X
Xexport PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
X
Xcase \$# in
X  0)
X    $echo "makedir pathname filenameflag"
X    exit 1
X    ;;
Xesac
X
X: guarantee one slash before 1st component
Xcase \$1 in
X  /*) ;;
X  *)  set ./\$1 \$2 ;;
Xesac
X
X: strip last component if it is to be a filename
Xcase X\$2 in
X  X1) set \`$echo \$1 | $sed 's:\(.*\)/[^/]*\$:\1:'\` ;;
X  *)  set \$1 ;;
Xesac
X
X: return reasonable status if nothing to be created
Xif $test -d "\$1" ; then
X    exit 0
Xfi
X
Xlist=''
Xwhile true ; do
X    case \$1 in
X    */*)
X	list="\$1 \$list"
X	set \`echo \$1 | $sed 's:\(.*\)/:\1 :'\`
X	;;
X    *)
X	break
X	;;
X    esac
Xdone
X
Xset \$list
X
Xfor dir do
X    $mkdir \$dir >/dev/null 2>&1
Xdone
X!GROK!THIS!
X$eunicefix makedir
Xchmod +x makedir
END_OF_FILE
if test 1082 -ne `wc -c <'makedir.SH'`; then
    echo shar: \"'makedir.SH'\" unpacked with wrong size!
fi
chmod +x 'makedir.SH'
# end of 'makedir.SH'
fi
if test -f 'mt-misc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mt-misc.c'\"
else
echo shar: Extracting \"'mt-misc.c'\" \(7528 characters\)
sed "s/^X//" >'mt-misc.c' <<'END_OF_FILE'
X/* $Id: mt-misc.c,v 3.0 1993/10/01 00:14:02 davison Trn $
X*/
X/* The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "thread.h"
X#include "mthreads.h"
X
Xchar *newslib, *privlib, *spool, *threaddir, *homedir;
Xint locked = 0, cron_locking = 0;
X
Xvoid
Xmt_init()
X{
X    /* Set up a nice friendly umask. */
X    umask(002);
X
X    /* Init the directory strings, possibly translating them into real paths */
X    homedir = getenv("HOME");
X    if (homedir == Nullch) {
X	homedir = getenv("LOGDIR");
X    }
X    spool = savestr(file_exp(NEWSSPOOL));
X    newslib = savestr(file_exp(NEWSLIB));
X    privlib = savestr(file_exp(PRIVLIB));
X    threaddir = file_exp(THREAD_DIR);
X    if (strEQ(threaddir,spool))
X	threaddir = spool;
X    else
X	threaddir = savestr(threaddir);
X}
X
X/* Make sure we're not already running by creating a lock file. */
Xlong
Xmt_lock(which_lock, sig)
Xint which_lock;
Xint sig;
X{
X    char buff[LBUFLEN], *filename;
X    FILE *fp;
X
X    sprintf(buff, "%s.%ld", file_exp(MTPRELOCK), (long)getpid());
X    if ((fp = fopen(buff, "w")) == Nullfp) {
X	log_entry("Unable to create lock temporary `%s'.\n", buff);
X	wrap_it_up(1);
X    }
X    fprintf(fp, "%s%ld\n", which_lock == DAEMON_LOCK ? "pid " : nullstr,
X	(long)getpid());
X    fclose(fp);
X
X    /* Try to link to lock file. */
X    if (which_lock == DAEMON_LOCK) {
X	filename = file_exp(MTDLOCK);
X    } else {
X	filename = file_exp(MTLOCK);
X    }
X  dolink:
X    while (link(buff, filename) < 0) {
X      long otherpid;
X	if ((fp = fopen(filename, "r")) == Nullfp) {
X	    log_entry("unable to open %s\n", filename);
X	    if (cron_locking) {
X		goto Sleep;
X	    }
X	    unlink(buff);
X	    wrap_it_up(1);
X	}
X	if (fscanf(fp, "%ld", &otherpid) != 1) { 
X	    log_entry("unable to read pid from %s\n", filename);
X	    fclose(fp);
X	    if (cron_locking) {
X		goto Sleep;
X	    }
X	    unlink(buff);
X	    wrap_it_up(1);
X	}
X	fclose(fp);
X	if (kill(otherpid, sig) == -1 && errno == ESRCH) {
X	    if (unlink(filename) == -1) {
X		log_entry("unable to unlink lockfile %s\n", filename);
X		unlink(buff);
X		wrap_it_up(1);
X	    }
X	    goto dolink;
X	}
X	if (cron_locking) {
X	  Sleep:
X	    sleep(60);
X	    continue;
X	}
X	unlink(buff);
X	return otherpid;
X    }
X    unlink(buff);			/* remove temporary LOCK.<pid> file */
X    locked |= which_lock;
X    return 0;				/* return success */
X}
X
Xvoid
Xmt_unlock(which_lock)
Xint which_lock;
X{
X    which_lock &= locked;
X    if (which_lock & PASS_LOCK) {
X	unlink(file_exp(MTLOCK));		/* remove single-pass lock */
X    }
X    if (which_lock & DAEMON_LOCK) {
X	unlink(file_exp(MTDLOCK));		/* remove daemon lock */
X    }
X    locked &= ~which_lock;
X}
X
X/* Interpret rn's %x prefixes and ~name expansions without including tons
X** of useless source.  NOTE:  names that don't start with '/', '%' or '~'
X** are prefixed with the SPOOL directory.  (Note that ~'s don't work yet.)
X*/
Xchar *
Xfile_exp(name)
Xchar *name;
X{
X    static char namebuf[MAXFILENAME];
X
X    if (*name == '/') {	/* fully qualified names are left alone */
X	return name;
X    }
X    switch (name[0]) {
X    case '%':			/* interpret certain %x values */
X	switch (name[1]) {
X	case 'P':
X	    strcpy(namebuf, spool);
X	    break;
X	case 'W':
X	    strcpy(namebuf, threaddir);
X	    break;
X	case 'x':
X	    strcpy(namebuf, newslib);
X	    break;
X	case 'X':
X	    strcpy(namebuf, privlib);
X	    break;
X	default:
X	    log_entry("Unknown expansion: %s\n", name);
X	    wrap_it_up(1);
X	}
X	strcat(namebuf, name+2);
X	break;
X    case '~':
X    {
X	char *s = name + 1;
X
X	if (!*s || *s == '/') {
X	    sprintf(namebuf, "%s%s", homedir, s);
X	} else {
X	    log_entry("~name expansions not implemented.");
X	    wrap_it_up(1);
X	}
X	break;
X    }
X    default:			/* all "normal" names are relative to SPOOL */
X	sprintf(namebuf, "%s/%s", spool, name);
X	break;
X    }
X    return namebuf;
X}
X
X/* Change a newsgroup name into the name of the thread data file.  We
X** subsitute any '.'s in the group name into '/'s (unless LONG_THREAD_NAMES
X** is defined), prepend the path, and append the '/.thread' (or '.th') on to
X** the end.
X*/
Xchar *
Xthread_name(group)
Xchar *group;
X{
X    static char name_buf[MAXFILENAME];
X#ifdef LONG_THREAD_NAMES
X    sprintf(name_buf, "%s/%s", threaddir, group);
X#else
X    register char *cp;
X
X    cp = strcpy(name_buf, threaddir) + strlen(threaddir);
X    *cp++ = '/';
X    strcpy(cp, group);
X    while ((cp = index(cp, '.')))
X	*cp = '/';
X    if (threaddir == spool)
X	strcat(name_buf, "/.thread");
X    else
X	strcat(name_buf, ".th");
X#endif
X    return name_buf;
X}
X
X#ifndef lint
X/* A malloc that bombs-out when memory is exhausted. */
Xchar *
Xsafemalloc(amount)
XMEM_SIZE amount;
X{
X    register char *cp;
X
X    if ((cp = malloc(amount)) == Nullch) {
X	log_error("malloc(%ld) failed.\n", (long)amount);
X	wrap_it_up(1);
X    }
X    return cp;
X}
X
X/* paranoid version of realloc */
Xchar *
Xsaferealloc(where,size)
Xchar *where;
XMEM_SIZE size;
X{
X    char *ptr;
X
X    ptr = realloc(where,size?size:1);	/* realloc(0) is NASTY on our system */
X    if (ptr == Nullch) {
X	log_error("realloc(..., %ld) failed.\n", (long)size);
X	wrap_it_up(1);
X    }
X    return ptr;
X}
X#endif
X
X/* Create a malloc'ed copy of a string. */
Xchar *
Xsavestr(str)
Xchar *str;
X{
X    register MEM_SIZE len = strlen(str) + 1;
X    register char *newaddr = safemalloc(len);
X
X    bcopy(str, newaddr, (int)len);
X
X    return newaddr;
X}
X
X#ifndef lint
X/* Free some memory if it hasn't already been freed. */
Xvoid
Xsafefree(pp)
Xchar **pp;
X{
X    if (*pp) {
X	free(*pp);
X	*pp = Nullch;
X    }
X}
X#endif
X
X/* Determine this machine's byte map for WORDs and LONGs.  A byte map is an
X** array of BYTEs (sizeof (WORD) or sizeof (LONG) of them) with the 0th BYTE
X** being the byte number of the high-order byte in my <type>, and so forth.
X*/
Xvoid
Xmybytemap(map)
XBMAP *map;
X{
X    union {
X	BYTE b[sizeof (LONG)];
X	WORD w;
X	LONG l;
X    } u;
X    register BYTE *mp;
X    register int i, j;
X
X    mp = &map->w[sizeof (WORD)];
X    u.w = 1;
X    for (i = sizeof (WORD); i > 0; i--) {
X	for (j = 0; j < sizeof (WORD); j++) {
X	    if (u.b[j] != 0) {
X		break;
X	    }
X	}
X	if (j == sizeof (WORD)) {
X	    goto bad_news;
X	}
X	*--mp = j;
X	while (u.b[j] != 0 && u.w) {
X	    u.w <<= 1;
X	}
X    }
X
X    mp = &map->l[sizeof (LONG)];
X    u.l = 1;
X    for (i = sizeof (LONG); i > 0; i--) {
X	for (j = 0; j < sizeof (LONG); j++) {
X	    if (u.b[j] != 0) {
X		break;
X	    }
X	}
X	if (j == sizeof (LONG)) {
X	  bad_news:
X	    /* trouble -- set both to *something* consistent */
X	    for (j = 0; j < sizeof (WORD); j++) {
X		map->w[j] = j;
X	    }
X	    for (j = 0; j < sizeof (LONG); j++) {
X		map->l[j] = j;
X	    }
X	    return;
X	}
X	*--mp = j;
X	while (u.b[j] != 0 && u.l) {
X	    u.l <<= 1;
X	}
X    }
X}
X
X/* Transform each WORD's byte-ordering in a buffer of the designated length.
X*/
Xvoid
Xwp_bmap(buf, len)
XWORD *buf;
Xint len;
X{
X    union {
X	BYTE b[sizeof (WORD)];
X	WORD w;
X    } in, out;
X    register int i;
X
X    if (word_same) {
X	return;
X    }
X    while (len--) {
X	in.w = *buf;
X	for (i = 0; i < sizeof (WORD); i++) {
X	    out.b[my_bmap.w[i]] = in.b[mt_bmap.w[i]];
X	}
X	*buf++ = out.w;
X    }
X}
X
X/* Transform each LONG's byte-ordering in a buffer of the designated length.
X*/
Xvoid
Xlp_bmap(buf, len)
XLONG *buf;
Xint len;
X{
X    union {
X	BYTE b[sizeof (LONG)];
X	LONG l;
X    } in, out;
X    register int i;
X
X    if (long_same) {
X	return;
X    }
X    while (len--) {
X	in.l = *buf;
X	for (i = 0; i < sizeof (LONG); i++) {
X	    out.b[my_bmap.l[i]] = in.b[mt_bmap.l[i]];
X	}
X	*buf++ = out.l;
X    }
X}
END_OF_FILE
if test 7528 -ne `wc -c <'mt-misc.c'`; then
    echo shar: \"'mt-misc.c'\" unpacked with wrong size!
fi
# end of 'mt-misc.c'
fi
if test -f 'mt-write.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mt-write.c'\"
else
echo shar: Extracting \"'mt-write.c'\" \(9773 characters\)
sed "s/^X//" >'mt-write.c' <<'END_OF_FILE'
X/* $Id: mt-write.c,v 3.0 1990/10/01 00:14:05 davison Trn $
X*/
X/* The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "thread.h"
X#include "mthreads.h"
X
Xstatic FILE *fp_out;
Xstatic int seq;
Xstatic int article_seq;
X
Xstatic int failure;
X
Xvoid write_subjects(), write_authors(), write_roots(), write_ids();
Xvoid write_articles(), write_thread(), write_item();
Xvoid enumerate_articles(), enumerate_thread();
Xvoid free_leftovers();
Xint ensure_path _((char *));
X
X/* Write out all the data in a packed format that is easy for our newsreader
X** to use.  We free things as we go, when we don't need them any longer.  If
X** we encounter any write errors, the write_item routine sets a failure flag
X** to halt our writing of the file, but we keep on plugging away to free
X** everything up.
X*/
Xint
Xwrite_data(filename)
Xchar *filename;
X{
X    if (filename == Nullch) {
X	failure = 2;	/* A NULL filename indicates just free the data */
X    } else if ((fp_out = fopen(filename, FOPEN_WB)) == Nullfp) {
X	if (ensure_path(filename)) {
X	    if ((fp_out = fopen(filename, FOPEN_WB)) == Nullfp) {
X		log_error("Unable to create file: `%s'.\n", filename);
X		failure = 2;
X	    }
X	} else {
X	    log_error("Unable to create path: `%s'.\n", filename);
X	    failure = 2;
X	}
X    } else {
X	failure = 0;
X#ifdef SETBUFFER
X	setbuffer(fp_out, rwbuf, RWBUFSIZ);
X#else
X# ifdef SETVBUF
X	setvbuf(fp_out, rwbuf, _IOFBF, RWBUFSIZ);
X# endif
X#endif
X    }
X
X    /* If there's no roots, there's no data.  Leave the file with no length. */
X    if (!failure && total.last < total.first) {
X	failure = -1;
X    }
X
X    write_item(&total, sizeof (TOTAL));
X
X    enumerate_articles();
X
X    write_authors();
X    write_subjects();
X    write_roots();
X    write_articles();
X    write_ids();
X    free_leftovers();
X    bzero(&total, sizeof (TOTAL));
X
X    if (failure != 2) {
X	fclose(fp_out);
X    }
X    if (failure == 1) {
X	log_error("Write failed!  Removing `%s'.\n", filename);
X	unlink(filename);
X    }
X    return failure <= 0;
X}
X
X/* Recursively descend the article tree, enumerating the articles as we go.
X** This way we can output the article sequence numbers into the data file.
X*/
Xvoid
Xenumerate_articles()
X{
X    register ROOT *root;
X
X    seq = article_seq = 0;
X
X    for (root = root_root; root; root = root->link) {
X	root->seq = seq++;
X	if (!root->articles) {
X	    log_error("** No articles on this root??\n");
X	    continue;
X	}
X	enumerate_thread(root->articles);
X    }
X    if (seq != total.root) {
X	log_error("** Wrote %d roots instead of %d **\n", seq, total.root);
X    }
X    if (article_seq != total.article) {
X	log_error("** Wrote %d articles instead of %d **\n", article_seq, total.article);
X    }
X}
X
X/* Recursive routine for above-mentioned enumeration. */
Xvoid
Xenumerate_thread(article)
XARTICLE *article;
X{
X    while (article) {
X	article->seq = article_seq++;
X	if (article->children) {
X	    enumerate_thread(article->children);
X	}
X	article = article->siblings;
X    }
X}
X
X#define write_and_free(str_ptr)	/* Comment for makedepend to	 \
X					** ignore the backslash above */ \
X{\
X    register int len = strlen(str_ptr) + 1;\
X    write_item(str_ptr, len);\
X    free(str_ptr);\
X    string_offset += len;\
X}
X
XMEM_SIZE string_offset;
X
X/* Write out the author information:  first the use-counts, then the
X** name strings all packed together.
X*/
Xvoid
Xwrite_authors()
X{
X    register AUTHOR *author;
X
X    seq = 0;
X    for (author = author_root; author; author = author->link) {
X	write_item(&author->count, sizeof (WORD));
X	author->seq = seq++;
X    }
X    if (seq != total.author) {
X	log_error("** Wrote %d authors instead of %d **\n",
X		seq, total.author);
X    }
X
X    string_offset = 0;
X
X    for (author = author_root; author; author = author->link) {
X	write_and_free(author->name);
X    }
X}
X
X/* Write out the subject information: first the packed string data, then
X** the use-counts.  The order is important -- it is the order required
X** by the roots for their subject structures.
X*/
Xvoid
Xwrite_subjects()
X{
X    register ROOT *root;
X    register SUBJECT *subject;
X
X    for (root = root_root; root; root = root->link) {
X	for (subject = root->subjects; subject; subject = subject->link) {
X	    write_and_free(subject->str);
X	}
X    }
X    if (string_offset != total.string1) {
X	log_error("** Author/subject strings were %ld bytes instead of %ld **\n",
X		string_offset, total.string1);
X    }
X
X    seq = 0;
X    for (root = root_root; root; root = root->link) {
X	for (subject = root->subjects; subject; subject = subject->link) {
X	    write_item(&subject->count, sizeof (WORD));
X	    subject->seq = seq++;
X	}
X    }
X    if (seq != total.subject) {
X	log_error("** Wrote %d subjects instead of %d **\n",
X		seq, total.subject);
X    }
X}
X
X/* Write the roots in a packed format.  Interpret the pointers into
X** sequence numbers as we go.
X*/
Xvoid
Xwrite_roots()
X{
X    register ROOT *root;
X
X    for (root = root_root; root; root = root->link) {
X	p_root.articles = root->articles->seq;
X	p_root.root_num = root->root_num;
X	p_root.thread_cnt = root->thread_cnt;
X	p_root.subject_cnt = root->subject_cnt;
X	write_item(&p_root, sizeof (PACKED_ROOT));
X    }
X}
X
X#define rel_article(article, rseq)	((article)? (article)->seq - (rseq) : 0)
X#define valid_seq(ptr)		((ptr)? (ptr)->seq : -1)
X
X/* Write all the articles in the same order that we sequenced them. */
Xvoid
Xwrite_articles()
X{
X    register ROOT *root;
X
X    for (root = root_root; root; root = root->link) {
X	write_thread(root->articles);
X    }
X}
X
X/* Recursive routine to write the articles in thread order.  We depend on
X** the fact that our first child is the very next article written (if we
X** have children).
X*/
Xvoid
Xwrite_thread(article)
Xregister ARTICLE *article;
X{
X    while (article) {
X	p_article.num = article->num;
X	p_article.date = article->date;
X	p_article.subject = valid_seq(article->subject);
X	p_article.author = valid_seq(article->author);
X	p_article.flags = article->flags;
X	p_article.child_cnt = article->child_cnt;
X	p_article.parent = rel_article(article->parent, article->seq);
X	p_article.siblings = rel_article(article->siblings, article->seq);
X	p_article.root = article->root->seq;
X	write_item(&p_article, sizeof (PACKED_ARTICLE));
X	if (article->children) {
X	    write_thread(article->children);
X	}
X	article = article->siblings;
X    }
X}
X
XWORD minus_one = -1;
X
X/* Write the message-id strings:  each domain name (not including the
X** ".unknown." domain) followed by all of its associated unique ids.
X** Then output the article sequence numbers they belong to.  This stuff
X** is last because the newsreader doesn't need to read it.
X*/
Xvoid
Xwrite_ids()
X{
X    register DOMAIN *domain;
X    register ARTICLE *id;
X    register DOMAIN *next_domain;
X    register ARTICLE *next_id;
X
X    string_offset = 0;
X
X    for (domain = &unk_domain; domain; domain = domain->link) {
X	if (domain != &unk_domain) {
X	    write_and_free(domain->name);
X	    if (!domain->ids) {
X		log_error("** Empty domain name!! **\n");
X	    }
X	}
X	for (id = domain->ids; id; id = id->id_link) {
X	    write_and_free(id->id);
X	}
X    }
X    if (string_offset != total.string2) {
X	log_error("** Message-id strings were %ld bytes (%ld) **\n",
X		string_offset, total.string2);
X    }
X    for (domain = &unk_domain; domain; domain = next_domain) {
X	next_domain = domain->link;
X	for (id = domain->ids; id; id = next_id) {
X	    next_id = id->id_link;
X	    write_item(&id->seq, sizeof (WORD));
X	    free(id);
X	}
X	write_item(&minus_one, sizeof (WORD));
X	if (domain != &unk_domain) {
X	    free(domain);
X	}
X    }
X    unk_domain.ids = Nullart;
X    unk_domain.link = Null(DOMAIN*);
X}
X
X/* Free everything that's left to free.
X*/
Xvoid
Xfree_leftovers()
X{
X    register ROOT *root, *next_root;
X    register SUBJECT *subj, *next_subj;
X    register AUTHOR *author, *next_author;
X
X    for (root = root_root; root; root = next_root) {
X	next_root = root->link;
X	for (subj = root->subjects; subj; subj = next_subj) {
X	    next_subj = subj->link;
X	    free(subj);
X	}
X	free(root);
X    }
X    for (author = author_root; author; author = next_author) {
X	next_author = author->link;
X	free(author);
X    }
X    root_root = Null(ROOT*);
X    author_root = Null(AUTHOR*);
X}
X
X/* This routine will check to be sure that the required path exists for
X** the data file, and if not it will attempt to create it.
X*/
Xint
Xensure_path(filename)
Xregister char *filename;
X{
X    int status, pid, w;
X    char tmpbuf[1024];
X#ifdef MAKEDIR
X    register char *cp, *last;
X    register char *tbptr = tmpbuf+5;
X
X    if (!(last = rindex(filename, '/'))) {	/* find filename portion */
X	return 1;				/* no path, we're fine */
X    }
X    *last = '\0';				/* truncate path at filename */
X    strcpy(tmpbuf, "mkdir");
X
X    for (cp = last;;) {
X	if (stat(filename, &filestat) >= 0 && (filestat.st_mode & S_IFDIR)) {
X	    *cp = '/';
X	    break;
X	}
X	if (!(cp = rindex(filename, '/'))) {/* find something that exists */
X	    break;
X	}
X	*cp = '\0';
X    }
X    
X    for (cp = filename; cp <= last; cp++) {
X	if (!*cp) {
X	    sprintf(tbptr, " %s", filename);
X	    tbptr += strlen(tbptr);		/* set up for mkdir call */
X	    *cp = '/';
X	}
X    }
X    if (tbptr == tmpbuf+5) {
X	return 1;
X    }
X#else
X    sprintf(tmpbuf,"%s %s %d", file_exp(DIRMAKER), filename, 1);
X#endif
X
X    if ((pid = vfork()) == 0) {
X	execl(SH, SH, "-c", tmpbuf, Nullch);
X	_exit(127);
X    }
X    while ((w = wait(&status)) != pid && w != -1) {
X	;
X    }
X    if (w == -1) {
X	status = -1;
X    }
X    return !status;
X}
X
X/* A simple routine to output some data only if we haven't failed any
X** previous writes.
X*/
Xvoid
Xwrite_item(buff, len)
Xchar *buff;
Xint len;
X{
X    if (!failure) {
X	if (fwrite(buff, 1, len, fp_out) < len) {
X	    failure = 1;
X	}
X    }
X}
END_OF_FILE
if test 9773 -ne `wc -c <'mt-write.c'`; then
    echo shar: \"'mt-write.c'\" unpacked with wrong size!
fi
# end of 'mt-write.c'
fi
if test -f 'mt.check.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mt.check.SH'\"
else
echo shar: Extracting \"'mt.check.SH'\" \(1287 characters\)
sed "s/^X//" >'mt.check.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X    '') . ./config.sh ;;
Xesac
Xecho "Extracting mt.check (with variable substitutions)"
Xset `cat patchlevel.h`
Xversion=$4
X$spitshell >mt.check <<!GROK!THIS!
X$startsh
X# $Id: mt.check.SH,v 3.0 1993/09/22 04:11:10 davison Trn $
X#
X# mt.check - daily maintenance for mt.log
X#
X# Check mt.log for earth-shattering errors, and mail them to \$gurus if found.
X# Then move the mt.log file into a week-long history chain.
X#
X# Usage: mt.check
X#
X
Xgurus="$newsadmin"
Xtmp="/tmp/mt.c\$\$"
X
XPATH=/bin:/usr/bin
Xexport PATH
X
Xumask 002
X
Xtrap "rm -f \$tmp ; exit 0" 0 1 2 15
X
Xcd $privlib
X
X$egrep " \\*\\*\$" mt.log >\$tmp
X
Xif test -s \$tmp ; then
X	(cat <<EOT
XTo: \$gurus
XSubject: mthreads error!
X
XThe following errors were reported in mt.log.  If the error pertains to
Xthe active file,  you should lock down your news system and fix it.  If
Xit is a thread-releated bug and it persists, please report this fact to
XWayne Davison (davison@borland.com).  Mention version "$version".
X
XEOT
X	cat \$tmp) | mail \$gurus
Xfi
X
Xtest -f mt.log.6 && mv mt.log.6 mt.log.7
Xtest -f mt.log.5 && mv mt.log.5 mt.log.6
Xtest -f mt.log.4 && mv mt.log.4 mt.log.5
Xtest -f mt.log.3 && mv mt.log.3 mt.log.4
Xtest -f mt.log.2 && mv mt.log.2 mt.log.3
Xtest -f mt.log   && mv mt.log   mt.log.2
Xtouch mt.log
X
Xexit 0
X!GROK!THIS!
END_OF_FILE
if test 1287 -ne `wc -c <'mt.check.SH'`; then
    echo shar: \"'mt.check.SH'\" unpacked with wrong size!
fi
# end of 'mt.check.SH'
fi
if test -f 'mthreads.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mthreads.h'\"
else
echo shar: Extracting \"'mthreads.h'\" \(1797 characters\)
sed "s/^X//" >'mthreads.h' <<'END_OF_FILE'
X/* $Id: mthreads.h,v 3.0 1993/10/01 00:14:07 davison Trn $
X*/
X/* The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#define RWBUFSIZ 8192
X
X#define PASS_LOCK 1
X#define DAEMON_LOCK 2
X
X#define NO_LISTGROUP	0
X#define GOOD_LISTGROUP	1
X#define BAD_LISTGROUP	2
X#define CHECK_LISTGROUP	3
X
XEXT char rwbuf[RWBUFSIZ];
X
XEXT TOTAL total;
X
XEXT int added_articles INIT(0);
XEXT int expired_articles INIT(0);
XEXT int added_count;
XEXT int expired_count;
XEXT bool extra_expire INIT(FALSE);
X
XEXT char *strings INIT(0);
XEXT WORD *subject_cnts INIT(0);
XEXT WORD *author_cnts INIT(0);
XEXT WORD *ids INIT(0);
X
XEXT SUBJECT **subject_array;
XEXT ROOT **root_array;
XEXT AUTHOR **author_array;
XEXT ARTICLE **article_array;
X
XEXT PACKED_ROOT p_root;
XEXT PACKED_ARTICLE p_article;
X
XEXT ROOT *root_root;
XEXT AUTHOR *author_root;
X
X#ifndef DOINIT
XEXT DOMAIN unk_domain;
X#else
XDOMAIN unk_domain = {
X    ".unknown.", NULL, NULL
X};
X#endif
X
XEXT bool word_same, long_same;
XEXT BMAP my_bmap, mt_bmap;
X
Xchar *thread_name _((char *));
Xvoid mybytemap _((BMAP *));
Xvoid wp_bmap(), lp_bmap(), swap_bmaps();
X
Xint ngmatch _((char *,char *));
Xint onepatmatch _((char *,char *));
X
Xvoid mt_init _((void));
Xlong mt_lock _((int, int));
Xvoid mt_unlock _((int));
Xvoid wrap_it_up _((int));
Xvoid log_entry();
Xvoid log_error();
X
Xint init_data _((char *));
Xint read_data _((void));
Xint write_data _((char *));
Xvoid dont_read_data _((int));
X
Xvoid process_articles _((ART_NUM,ART_NUM));
X
Xchar *file_exp _((char *));
Xchar *savestr _((char *));
X
Xtime_t parsedate _((char *));
X
X#ifndef lint
Xchar *safemalloc _((MEM_SIZE));
Xvoid safefree();
X#endif
X
Xtime_t get_date _((char *,time_t,long));
X
X#define Nullart Null(ARTICLE*)
END_OF_FILE
if test 1797 -ne `wc -c <'mthreads.h'`; then
    echo shar: \"'mthreads.h'\" unpacked with wrong size!
fi
# end of 'mthreads.h'
fi
if test -f 'ndir.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ndir.c'\"
else
echo shar: Extracting \"'ndir.c'\" \(2375 characters\)
sed "s/^X//" >'ndir.c' <<'END_OF_FILE'
X/* $Id: ndir.c,v 3.0 1991/09/09 20:23:31 davison Trn $
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "INTERN.h"
X#include "ndir.h"
X
X#ifdef EMULATE_NDIR
X/*
X * support for Berkeley directory reading routine on a V7 file system
X */
X
X/*
X * open a directory.
X */
XDIR *
Xopendir(name)
Xchar *name;
X{
X	register DIR *dirp;
X	register int fd;
X	char *malloc();
X
X	if ((fd = open(name, 0)) == -1)
X		return NULL;
X	if ((dirp = (DIR *)malloc(sizeof(DIR))) == NULL) {
X		close (fd);
X		return NULL;
X	}
X	dirp->dd_fd = fd;
X	dirp->dd_loc = 0;
X	return dirp;
X}
X
X/*
X * read an old style directory entry and present it as a new one
X */
X#ifndef pyr
X#define	ODIRSIZ	14
X
Xstruct	olddirect {
X	ino_t	od_ino;
X	char	od_name[ODIRSIZ];
X};
X#else	/* an Pyramid in the ATT universe */
X#define	ODIRSIZ	248
X
Xstruct	olddirect {
X	long	od_ino;
X	short	od_fill1, od_fill2;
X	char	od_name[ODIRSIZ];
X};
X#endif
X
X/*
X * get next entry in a directory.
X */
Xstruct direct *
Xreaddir(dirp)
Xregister DIR *dirp;
X{
X	register struct olddirect *dp;
X	static struct direct dir;
X
X	for (;;) {
X		if (dirp->dd_loc == 0) {
X			dirp->dd_size = read(dirp->dd_fd, dirp->dd_buf,
X			    DIRBLKSIZ);
X			if (dirp->dd_size <= 0)
X				return NULL;
X		}
X		if (dirp->dd_loc >= dirp->dd_size) {
X			dirp->dd_loc = 0;
X			continue;
X		}
X		dp = (struct olddirect *)(dirp->dd_buf + dirp->dd_loc);
X		dirp->dd_loc += sizeof(struct olddirect);
X		if (dp->od_ino == 0)
X			continue;
X		dir.d_ino = dp->od_ino;
X		strncpy(dir.d_name, dp->od_name, ODIRSIZ);
X		dir.d_name[ODIRSIZ] = '\0'; /* insure null termination */
X		dir.d_namlen = strlen(dir.d_name);
X		dir.d_reclen = DIRSIZ(&dir);
X		return (&dir);
X	}
X}
X
X/*
X * close a directory.
X */
Xvoid
Xclosedir(dirp)
Xregister DIR *dirp;
X{
X	close(dirp->dd_fd);
X	dirp->dd_fd = -1;
X	dirp->dd_loc = 0;
X	free(dirp);
X}
X
X#endif /* EMULATE_NDIR */
END_OF_FILE
if test 2375 -ne `wc -c <'ndir.c'`; then
    echo shar: \"'ndir.c'\" unpacked with wrong size!
fi
# end of 'ndir.c'
fi
if test -f 'ndir.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ndir.h'\"
else
echo shar: Extracting \"'ndir.h'\" \(2045 characters\)
sed "s/^X//" >'ndir.h' <<'END_OF_FILE'
X/* $Id: ndir.h,v 3.0 1991/09/09 20:23:31 davison Trn $
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#ifdef I_NDIR
X#include <ndir.h>
X#else
X#ifdef I_DIRENT
X#include <dirent.h>
X#ifndef direct
X#define direct dirent
X#endif
X#else
X#ifdef I_SYS_NDIR
X#include <sys/ndir.h>
X#else
X#ifdef I_SYS_DIR
X#include <sys/dir.h>
X#else
X
X#ifndef DEV_BSIZE
X#define	DEV_BSIZE	512
X#endif
X#define DIRBLKSIZ	DEV_BSIZE
X#define	MAXNAMLEN	255
X
Xstruct	direct {
X	long	d_ino;			/* inode number of entry */
X	short	d_reclen;		/* length of this record */
X	short	d_namlen;		/* length of string in d_name */
X	char	d_name[MAXNAMLEN + 1];	/* name must be no longer than this */
X};
X
X/*
X * The DIRSIZ macro gives the minimum record length which will hold
X * the directory entry.  This requires the amount of space in struct direct
X * without the d_name field, plus enough space for the name with a terminating
X * null byte (dp->d_namlen+1), rounded up to a 4 byte boundary.
X */
X#undef DIRSIZ
X#define DIRSIZ(dp)     ((sizeof (struct direct) - (MAXNAMLEN+1)) + (((dp)->d_namlen+1 + 3) &~ 3))
X
X/*
X * Definitions for library routines operating on directories.
X */
Xtypedef struct _dirdesc {
X	int	dd_fd;
X	long	dd_loc;
X	long	dd_size;
X	char	dd_buf[DIRBLKSIZ];
X} DIR;
X#ifndef NULL
X#define NULL 0
X#endif
Xextern	DIR *opendir _((char*));
Xextern	struct direct *readdir _((DIR*));
Xextern	long telldir _((DIR*));
Xextern	void seekdir _((DIR*));
X#define rewinddir(dirp)	seekdir((dirp), (long)0)
Xextern	void closedir _((DIR*));
X
X#endif
X#endif
X#endif
X#endif
END_OF_FILE
if test 2045 -ne `wc -c <'ndir.h'`; then
    echo shar: \"'ndir.h'\" unpacked with wrong size!
fi
# end of 'ndir.h'
fi
if test -f 'nntpclient.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nntpclient.c'\"
else
echo shar: Extracting \"'nntpclient.c'\" \(3661 characters\)
sed "s/^X//" >'nntpclient.c' <<'END_OF_FILE'
X/* $Id: nntpclient.c,v 3.0 1991/11/22 04:12:21 davison Trn $
X*/
X/* The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X
X#ifdef USE_NNTP
X
X#include "INTERN.h"
X#include "nntpclient.h"
X
X#define CANTPOST	\
X	"NOTE:  This machine does not have permission to post articles.\n"
X#define CANTUSE		\
X	"This machine does not have permission to use the %s news server.\n"
X
Xint
Xnntp_connect()
X{
X    char *server, filebuf[128];
X    int response;
X
X    if ((server = getenv("NNTPSERVER")) == Nullch)
X	server = SERVER_NAME;
X    if (server[0] == '/') {
X	register FILE *fp;
X	if ((fp = fopen(server, "r")) != Nullfp) {
X	    server = Nullch;
X	    while (fgets(filebuf, sizeof filebuf, fp) != Nullch) {
X		if (*filebuf == '\n' || *filebuf == '#')
X		    continue;
X		if ((server = index(filebuf, '\n')) != Nullch)
X		    *server = '\0';
X		server = filebuf;
X		break;
X	    }
X	    fclose(fp);
X	} else
X	    server = Nullch;
X	if (server == Nullch) {
X	    sprintf(ser_line, "\
XCouldn't get name of news server from %s\n\
XEither fix this file, or put NNTPSERVER in your environment.\n", SERVER_NAME);
X	    report_error(ser_line);
X	    return 0;
X	}
X    }
X
X    switch (response = server_init(server)) {
X    case NNTP_GOODBYE_VAL:
X	if (atoi(ser_line) == response) {
X	    char tmpbuf[LBUFLEN];
X	    sprintf(tmpbuf,"News server %s unavailable: %s\n",server,&ser_line[4]);
X	    report_error(tmpbuf);
X	    return 0;
X	}
X    case -1:
X	sprintf(ser_line,"News server %s unavailable, try again later.\n",server);
X	report_error(ser_line);
X	return 0;
X    case NNTP_ACCESS_VAL:
X	sprintf(ser_line,CANTUSE,server);
X	report_error(ser_line);
X	return 0;
X    case NNTP_NOPOSTOK_VAL:
X	advise(CANTPOST);
X	/* FALL THROUGH */
X    case NNTP_POSTOK_VAL:
X	break;
X    default:
X	sprintf(ser_line,"Unknown response code %d from %s.\n", response, server);
X	report_error(ser_line);
X	return 0;
X    }
X    return 1;
X}
X
Xvoid
Xnntp_command(buf)
Xchar *buf;
X{
X#if defined(DEBUG) && defined(FLUSH)
X    if (debug & DEB_NNTP)
X	printf(">%s\n", buf) FLUSH;
X#endif
X    fprintf(ser_wr_fp, "%s\r\n", buf);
X    fflush(ser_wr_fp);
X}
X
Xchar
Xnntp_check(strict)
Xbool_int strict;
X{
X    int n;
X
X#ifdef HAS_SIGHOLD
X    sighold(SIGINT);
X#endif
X    n = (fgets(ser_line, sizeof ser_line, ser_rd_fp) == NULL)? -1 : 0;
X#ifdef HAS_SIGHOLD
X    sigrelse(SIGINT);
X#endif
X    if (n < 0)
X#ifdef fatal_error
X	fatal_error("\nUnexpected close of server socket.\n");
X#else
X	return NNTP_CLASS_FATAL;
X#endif
X    n = strlen(ser_line);
X    if (n >= 2 && ser_line[n-1] == '\n' && ser_line[n-2] == '\r')
X	ser_line[n-2] = '\0';
X#if defined(DEBUG) && defined(FLUSH)
X    if (debug & DEB_NNTP)
X	printf("<%s\n", ser_line) FLUSH;
X#endif
X#ifdef fatal_error
X    if (strict && *ser_line == NNTP_CLASS_FATAL) {	/* Fatal error */
X	char tmpbuf[LBUFLEN];
X	sprintf(tmpbuf,"\n%s\n",ser_line);
X	fatal_error(tmpbuf);
X    }
X#endif
X    return *ser_line;
X}
X
Xint
Xnntp_gets(buf, len)
Xchar *buf;
Xint  len;
X{
X    int n;
X
X#ifdef HAS_SIGHOLD
X    sighold(SIGINT);
X#endif
X    n = (fgets(buf, len, ser_rd_fp) == NULL)? -1 : 0;
X#ifdef HAS_SIGHOLD
X    sigrelse(SIGINT);
X#endif
X    if (n < 0)
X#ifdef fatal_error
X	fatal_error("\nUnexpected close of server socket.\n");
X#else
X	return -1;
X#endif
X    n = strlen(buf);
X    if (n >= 2 && buf[n-1] == '\n' && buf[n-2] == '\r')
X	buf[n-2] = '\0';
X    return 0;
X}
X
Xvoid
Xnntp_close()
X{
X    if (ser_wr_fp != NULL && ser_rd_fp != NULL) {
X	nntp_command("QUIT");
X	fclose(ser_wr_fp);
X	ser_wr_fp = NULL;
X
X	nntp_check(FALSE);
X	fclose(ser_rd_fp);
X	ser_rd_fp = NULL;
X    }
X}
X
X#endif /* USE_NNTP */
END_OF_FILE
if test 3661 -ne `wc -c <'nntpclient.c'`; then
    echo shar: \"'nntpclient.c'\" unpacked with wrong size!
fi
# end of 'nntpclient.c'
fi
if test -f 'nntpclient.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nntpclient.h'\"
else
echo shar: Extracting \"'nntpclient.h'\" \(1475 characters\)
sed "s/^X//" >'nntpclient.h' <<'END_OF_FILE'
X/* $Id: nntpclient.h,v 3.0 1992/12/14 00:14:55 davison Trn $
X*/ 
X/* The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#ifdef USE_NNTP
X
Xint	server_init _((char*));
X
Xint	nntp_connect _((void));
Xvoid	nntp_command _((char*));
Xchar	nntp_check _((bool_int));
Xint	nntp_gets _((char*, int));
Xvoid	nntp_close _((void));
X
X/* RFC 977 defines these, so don't change them */
X
X#define	NNTP_CLASS_INF  	'1'
X#define NNTP_CLASS_OK   	'2'
X#define	NNTP_CLASS_CONT 	'3'
X#define	NNTP_CLASS_ERR  	'4'
X#define	NNTP_CLASS_FATAL	'5'
X
X#define	NNTP_POSTOK_VAL 	200	/* Hello -- you can post */
X#define	NNTP_NOPOSTOK_VAL	201	/* Hello -- you can't post */
X
X#define NNTP_GOODBYE_VAL	400	/* Have to hang up for some reason */
X#define	NNTP_NOSUCHGROUP_VAL	411	/* No such newsgroup */
X
X#define	NNTP_AUTH_NEEDED_VAL 	480	/* Authorization Failed */
X#define	NNTP_AUTH_REJECT_VAL	482	/* Authorization data rejected */
X
X#define	NNTP_BAD_COMMAND_VAL	500	/* Command not recognized */
X#define	NNTP_SYNTAX_VAL		501	/* Command syntax error */
X#define	NNTP_ACCESS_VAL 	502	/* Access to server denied */
X#define	NNTP_TMPERR_VAL  	503	/* Program fault, command not performed */
X#define	NNTP_AUTH_BAD_VAL 	580	/* Authorization Failed */
X
X#define	NNTP_STRLEN	512
X
XEXT FILE *ser_rd_fp INIT(NULL);
XEXT FILE *ser_wr_fp INIT(NULL);
XEXT char ser_line[NNTP_STRLEN];
X
X#endif /* USE_NNTP */
END_OF_FILE
if test 1475 -ne `wc -c <'nntpclient.h'`; then
    echo shar: \"'nntpclient.h'\" unpacked with wrong size!
fi
# end of 'nntpclient.h'
fi
if test -f 'nntpinit.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nntpinit.c'\"
else
echo shar: Extracting \"'nntpinit.c'\" \(9720 characters\)
sed "s/^X//" >'nntpinit.c' <<'END_OF_FILE'
X/* $Id: nntpinit.c,v 3.0 1991/11/22 04:12:21 davison Trn $
X*/
X/* This software is Copyright 1992 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction or this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#undef	DECNET    /* If you want decnet support */
X#undef	EXCELAN   /* Excelan EXOS 205 support */
X#undef	NONETDB	  /* Define if you're missing netdb.h */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "nntpclient.h"
X
X#ifdef USE_NNTP
X
X#include <sys/socket.h>
X#include <netinet/in.h>
X#ifdef NONETDB
X# define IPPORT_NNTP	((unsigned short) 119)
X#else
X# include <netdb.h>
X#endif /* !EXCELAN */
X
X#ifdef EXCELAN
Xint connect _((int, struct sockaddr *));
Xunsigned short htons _((unsigned short));
Xunsigned long rhost _((char **));
Xint rresvport p((int));
Xint socket _((int, struct sockproto *, struct sockaddr_in *, int));
X#endif /* EXCELAN */
X
X#ifdef DECNET
X#include <netdnet/dn.h>
X#include <netdnet/dnetdb.h>
X#endif /* DECNET */
X
Xunsigned long inet_addr _((char *x));
Xint get_tcp_socket _((char *machine));
X
Xint
Xserver_init(server)
Xchar *server;
X{
X    char line2[NNTP_STRLEN];
X    int sockt_rd, sockt_wr;
X#ifdef DECNET
X    char *cp;
X
X    cp = index(server, ':');
X
X    if (cp && cp[1] == ':') {
X	*cp = '\0';
X	sockt_rd = get_dnet_socket(server);
X    } else
X	sockt_rd = get_tcp_socket(server);
X#else /* !DECNET */
X    sockt_rd = get_tcp_socket(server);
X#endif
X
X    if (sockt_rd < 0)
X	return -1;
X    sockt_wr = dup(sockt_rd);
X
X    /* Now we'll make file pointers (i.e., buffered I/O) out of
X    ** the socket file descriptor.  Note that we can't just
X    ** open a fp for reading and writing -- we have to open
X    ** up two separate fp's, one for reading, one for writing. */
X    if ((ser_rd_fp = fdopen(sockt_rd, "r")) == NULL) {
X	perror("server_init: fdopen #1");
X	return -1;
X    }
X    if ((ser_wr_fp = fdopen(sockt_wr, "w")) == NULL) {
X	perror("server_init: fdopen #2");
X	ser_rd_fp = NULL;
X	return -1;
X    }
X
X    /* Now get the server's signon message */
X    nntp_check(FALSE);
X
X    if (*ser_line == NNTP_CLASS_OK) {
X	/* Send a MODE READER command in case we're talking to innd.
X	** If understood, use that reply. */
X	nntp_command("MODE READER");
X	nntp_gets(line2, sizeof line2);
X	if (atoi(line2) != NNTP_BAD_COMMAND_VAL)
X	    strcpy(ser_line, line2);
X    }
X    return atoi(ser_line);
X}
X
Xint
Xget_tcp_socket(server)
Xchar *server;
X{
X    int portno;	
X    int s;
X    struct sockaddr_in sin;
X#ifdef __hpux
X    int socksize = 0;
X    int socksizelen = sizeof socksize;
X#endif
X#ifdef NONETDB
X    bzero((char *) &sin, sizeof(sin));
X    sin.sin_family = AF_INET;
X#else
X    struct servent *getservbyname(), *sp;
X    struct hostent *gethostbyname(), *hp;
X#ifdef h_addr
X    int x = 0;
X    register char **cp;
X    static char *alist[1];
X#endif /* h_addr */
X    static struct hostent def;
X    static struct in_addr defaddr;
X    static char namebuf[ 256 ];
X
X    if ((sp = getservbyname("nntp", "tcp")) ==  NULL) {
X	fprintf(stderr, "nntp/tcp: Unknown service.\n");
X	return -1;
X    }
X    portno = sp->s_port;
X    /* If not a raw ip address, try nameserver */
X    if (!isdigit(*server)
X     || (long)(defaddr.s_addr = inet_addr(server)) == -1)
X	hp = gethostbyname(server);
X    else {
X	/* Raw ip address, fake  */
X	(void) strcpy(namebuf, server);
X	def.h_name = namebuf;
X#ifdef h_addr
X	def.h_addr_list = alist;
X#endif
X	def.h_addr = (char *)&defaddr;
X	def.h_length = sizeof(struct in_addr);
X	def.h_addrtype = AF_INET;
X	def.h_aliases = 0;
X	hp = &def;
X    }
X    if (hp == NULL) {
X	fprintf(stderr, "%s: Unknown host.\n", server);
X	return -1;
X    }
X
X    bzero((char *) &sin, sizeof(sin));
X    sin.sin_family = hp->h_addrtype;
X    sin.sin_port = portno;
X#endif /* !NONETDB */
X
X    /* The following is kinda gross.  The name server under 4.3
X    ** returns a list of addresses, each of which should be tried
X    ** in turn if the previous one fails.  However, 4.2 hostent
X    ** structure doesn't have this list of addresses.
X    ** Under 4.3, h_addr is a #define to h_addr_list[0].
X    ** We use this to figure out whether to include the NS specific
X    ** code... */
X#ifdef h_addr
X    /* get a socket and initiate connection -- use multiple addresses */
X    for (cp = hp->h_addr_list; cp && *cp; cp++) {
X	s = socket(hp->h_addrtype, SOCK_STREAM, 0);
X	if (s < 0) {
X	    perror("socket");
X	    return -1;
X	}
X        bcopy(*cp, (char *)&sin.sin_addr, hp->h_length);
X		
X	if (x < 0)
X	    fprintf(stderr, "trying %s\n", inet_ntoa(sin.sin_addr));
X	x = connect(s, (struct sockaddr *)&sin, sizeof (sin));
X	if (x == 0)
X	    break;
X        fprintf(stderr, "connection to %s: ", inet_ntoa(sin.sin_addr));
X	perror("");
X	(void) close(s);
X    }
X    if (x < 0) {
X	fprintf(stderr, "giving up...\n");
X	return -1;
X    }
X#else /* no name server */
X#ifdef EXCELAN
X    s = socket(SOCK_STREAM, (struct sockproto *)NULL, &sin, SO_KEEPALIVE);
X    if (s < 0) {
X	/* Get the socket */
X	perror("socket");
X	return -1;
X    }
X    bzero((char *) &sin, sizeof(sin));
X    sin.sin_family = AF_INET;
X    sin.sin_port = htons(IPPORT_NNTP);
X
X    /* set up addr for the connect */
X    if ((sin.sin_addr.s_addr = rhost(&server)) == -1) {
X	fprintf(stderr, "%s: Unknown host.\n", server);
X	return -1;
X    }
X
X    /* And then connect */
X    if (connect(s, (struct sockaddr *)&sin) < 0) {
X	perror("connect");
X	(void) close(s);
X	return -1;
X    }
X#else /* not EXCELAN */
X    if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
X	perror("socket");
X	return -1;
X    }
X
X    /* And then connect */
X
X    bcopy(hp->h_addr, (char *) &sin.sin_addr, hp->h_length);
X    if (connect(s, (struct sockaddr *) &sin, sizeof(sin)) < 0) {
X	perror("connect");
X	(void) close(s);
X	return -1;
X    }
X
X#endif /* !EXCELAN */
X#endif /* !h_addr */
X#ifdef __hpux	/* recommended by raj@cup.hp.com */
X#define	HPSOCKSIZE 0x8000
X    getsockopt(s, SOL_SOCKET, SO_SNDBUF, (caddr_t)&socksize, (caddr_t)&socksizelen);
X    if (socksize < HPSOCKSIZE) {
X	socksize = HPSOCKSIZE;
X	setsockopt(s, SOL_SOCKET, SO_SNDBUF, (caddr_t)&socksize, sizeof(socksize));
X    }
X    socksize = 0;
X    socksizelen = sizeof(socksize);
X    getsockopt(s, SOL_SOCKET, SO_RCVBUF, (caddr_t)&socksize, (caddr_t)&socksizelen);
X    if (socksize < HPSOCKSIZE) {
X	socksize = HPSOCKSIZE;
X	setsockopt(s, SOL_SOCKET, SO_RCVBUF, (caddr_t)&socksize, sizeof(socksize));
X    }
X#endif
X    return s;
X}
X
X#ifdef DECNET
Xint
Xget_dnet_socket(server)
Xchar *server;
X{
X    int s, area, node;
X    struct sockaddr_dn sdn;
X    struct nodeent *getnodebyname(), *np;
X
X    bzero((char *) &sdn, sizeof(sdn));
X
X    switch (s = sscanf(server, "%d%*[.]%d", &area, &node)) {
X    case 1: 
X	node = area;
X	area = 0;
X    case 2: 
X	node += area*1024;
X	sdn.sdn_add.a_len = 2;
X	sdn.sdn_family = AF_DECnet;
X	sdn.sdn_add.a_addr[0] = node % 256;
X	sdn.sdn_add.a_addr[1] = node / 256;
X	break;
X    default:
X	if ((np = getnodebyname(server)) == NULL) {
X	    fprintf(stderr, "%s: Unknown host.\n", server);
X	    return -1;
X	} else {
X	    bcopy(np->n_addr, (char *) sdn.sdn_add.a_addr, np->n_length);
X	    sdn.sdn_add.a_len = np->n_length;
X	    sdn.sdn_family = np->n_addrtype;
X	}
X	break;
X    }
X    sdn.sdn_objnum = 0;
X    sdn.sdn_flags = 0;
X    sdn.sdn_objnamel = strlen("NNTP");
X    bcopy("NNTP", &sdn.sdn_objname[0], sdn.sdn_objnamel);
X
X    if ((s = socket(AF_DECnet, SOCK_STREAM, 0)) < 0) {
X	nerror("socket");
X	return -1;
X    }
X
X    /* And then connect */
X    if (connect(s, (struct sockaddr *) &sdn, sizeof(sdn)) < 0) {
X	nerror("connect");
X	close(s);
X	return -1;
X    }
X    return s;
X}
X#endif /* DECNET */
X
X#ifdef EXCELAN
X/*
X * inet_addr for EXCELAN (which does not have it!)
X *
X */
Xunsigned long
Xinet_addr(cp)
Xregister char   *cp;
X{
X	unsigned long val, base, n;
X	register char c;
X	unsigned long octet[4], *octetptr = octet;
X#ifndef htonl
X	extern  unsigned long   htonl();
X#endif  /* htonl */
Xagain:
X	/*
X	 * Collect number up to ``.''.
X	 * Values are specified as for C:
X	 * 0x=hex, 0=octal, other=decimal.
X	 */
X	val = 0; base = 10;
X	if (*cp == '0')
X		base = 8, cp++;
X	if (*cp == 'x' || *cp == 'X')
X		base = 16, cp++;
X	while (c = *cp) {
X		if (isdigit(c)) {
X			val = (val * base) + (c - '0');
X			cp++;
X			continue;
X		}
X		if (base == 16 && isxdigit(c)) {
X			val = (val << 4) + (c + 10 - (islower(c) ? 'a' : 'A'));
X			cp++;
X			continue;
X		}
X		break;
X	}
X	if (*cp == '.') {
X		/*
X		 * Internet format:
X		 *      a.b.c.d
X		 *      a.b.c   (with c treated as 16-bits)
X		 *      a.b     (with b treated as 24 bits)
X		 */
X		if (octetptr >= octet + 4)
X			return (-1);
X		*octetptr++ = val, cp++;
X		goto again;
X	}
X	/*
X	 * Check for trailing characters.
X	 */
X	if (*cp && !isspace(*cp))
X		return (-1);
X	*octetptr++ = val;
X	/*
X	 * Concoct the address according to
X	 * the number of octet specified.
X	 */
X	n = octetptr - octet;
X	switch (n) {
X
X	case 1:                         /* a -- 32 bits */
X		val = octet[0];
X		break;
X
X	case 2:                         /* a.b -- 8.24 bits */
X		val = (octet[0] << 24) | (octet[1] & 0xffffff);
X		break;
X
X	case 3:                         /* a.b.c -- 8.8.16 bits */
X		val = (octet[0] << 24) | ((octet[1] & 0xff) << 16) |
X			(octet[2] & 0xffff);
X		break;
X
X	case 4:                         /* a.b.c.d -- 8.8.8.8 bits */
X		val = (octet[0] << 24) | ((octet[1] & 0xff) << 16) |
X		      ((octet[2] & 0xff) << 8) | (octet[3] & 0xff);
X		break;
X
X	default:
X		return (-1);
X	}
X	val = htonl(val);
X	return (val);
X}
X#endif /* EXCELAN */
X
X#endif /* USE_NNTP */
END_OF_FILE
if test 9720 -ne `wc -c <'nntpinit.c'`; then
    echo shar: \"'nntpinit.c'\" unpacked with wrong size!
fi
# end of 'nntpinit.c'
fi
if test -f 'patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patchlevel.h'\"
else
echo shar: Extracting \"'patchlevel.h'\" \(35 characters\)
sed "s/^X//" >'patchlevel.h' <<'END_OF_FILE'
X#define PATCHLEVEL "Version: 3.1 "
END_OF_FILE
if test 35 -ne `wc -c <'patchlevel.h'`; then
    echo shar: \"'patchlevel.h'\" unpacked with wrong size!
fi
# end of 'patchlevel.h'
fi
if test -f 'thread.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'thread.h'\"
else
echo shar: Extracting \"'thread.h'\" \(2045 characters\)
sed "s/^X//" >'thread.h' <<'END_OF_FILE'
X/* $Id: thread.h,v 3.0 1993/10/01 00:14:09 davison Trn $
X*/
X/* The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#define DB_VERSION	2
X
Xtypedef char		BYTE;
Xtypedef short		WORD;
X#ifndef __alpha
Xtypedef long		LONG;
X#else
Xtypedef int		LONG;
X#endif
X
X#define ROOT_ARTICLE	0x0001		/* article flag definitions */
X#define HAS_XREFS	0x0004		/* article has an xref line */
X
Xtypedef struct Article {
X    ART_NUM num;
X    char *id;
X    struct Domain *domain;
X    struct Subject *subject;
X    struct Author *author;
X    struct Article *parent, *children, *siblings;
X    struct Root *root;
X    struct Article *id_link;
X    time_t date;
X    WORD child_cnt;
X    WORD flags;
X    WORD seq;
X} ARTICLE;
X
Xtypedef struct Domain {
X    char *name;
X    ARTICLE *ids;
X    struct Domain *link;
X} DOMAIN;
X
Xtypedef struct Author {
X    struct Author *link;		/* this link MUST be first */
X    char *name;
X    WORD seq;
X    WORD count;
X} AUTHOR;
X
Xtypedef struct Subject {
X    struct Subject *link;		/* this link MUST be first */
X    char *str;
X    WORD seq;
X    WORD count;
X} SUBJECT;
X
Xtypedef struct Root {
X    struct Root *link;			/* this link MUST be first */
X    ARTICLE *articles;
X    SUBJECT *subjects;
X    ART_NUM root_num;
X    WORD thread_cnt;
X    WORD subject_cnt;
X    WORD seq;
X} ROOT;
X
Xtypedef struct {
X    LONG root_num;
X    WORD articles;
X    WORD thread_cnt;
X    WORD subject_cnt;
X    WORD pad_hack;
X} PACKED_ROOT;
X
Xtypedef struct {
X    LONG num;
X    LONG date;
X    WORD subject, author;
X    WORD flags;
X    WORD child_cnt;
X    WORD parent;
X    WORD padding;
X    WORD siblings;
X    WORD root;
X} PACKED_ARTICLE;
X
Xtypedef struct Total {
X    LONG first, last;
X    LONG string1;
X    LONG string2;
X    WORD root;
X    WORD article;
X    WORD subject;
X    WORD author;
X    WORD domain;
X    WORD pad_hack;
X} TOTAL;
X
Xtypedef struct {
X    BYTE l[sizeof (LONG)];
X    BYTE w[sizeof (WORD)];
X    BYTE version;
X    BYTE pad_hack;
X} BMAP;
END_OF_FILE
if test 2045 -ne `wc -c <'thread.h'`; then
    echo shar: \"'thread.h'\" unpacked with wrong size!
fi
# end of 'thread.h'
fi
if test -f 'unipatch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'unipatch.c'\"
else
echo shar: Extracting \"'unipatch.c'\" \(1507 characters\)
sed "s/^X//" >'unipatch.c' <<'END_OF_FILE'
X/*
XA filter to turn a unified diff into a degenerate context diff (no '!'s)
Xfor patch. Version 1.1. Author: davison@borland.com
X*/
X#include <stdio.h>
X#define ERR(a) {fputs(a,stderr);exit(1);}
X#define NUM(x) {for(x=0;*cp<='9'&&*cp>='0';)x=x*10+*cp++-'0';ch= *cp++;}
Xstruct Ln {struct Ln *lk; char t; char s[1];} r,*h,*ln;
Xchar bf[2048],*cp,ch,*malloc();
Xlong os,ol,ns,nl,ne,lncnt;
Xmain()
X{
X for(;;){
X  for(;;){
X   if(!fgets(bf,sizeof bf,stdin)) exit(0);
X   lncnt++;
X   if(!strncmp(bf,"@@ -",4)) break;
X   fputs(bf,stdout);
X  }
X  ol=nl=1, cp=bf+4;
X  NUM(os)
X  if(ch==',') NUM(ol)
X  if(*cp++!='+') goto bad;
X  NUM(ns)
X  if(ch==',') NUM(nl)
X  if(*cp!='@') goto bad;
X  r.lk=0, h= &r, ne=ns+nl-1;
X  printf("***************\n*** %ld,%ld ****\n",os,os+ol-(os>0));
X  while(ol||nl){
X   if(!fgets(bf,sizeof bf,stdin)){
X    if(nl>2) ERR("Unexpected end of file.\n")
X    strcpy(bf," \n");
X   }
X   lncnt++;
X   if(*bf=='\t'||*bf=='\n') ch=' ', cp=bf;
X   else ch= *bf, cp=bf+1;
X   switch(ch){
X   case'-':if(!ol--) goto bad;
X	printf("- %s",cp);
X	break;
X   case'=':ch=' ';
X   case' ':if(!ol--) goto bad;
X	printf("  %s",cp);
X   case'+':if(!nl--) goto bad;
X	ln = (struct Ln*)malloc(sizeof(*ln)+strlen(cp));
X	if(!ln) ERR("Out of memory!\n")
X	ln->lk=0, ln->t=ch, strcpy(ln->s,cp);
X	h->lk=ln, h=ln;
X	break;
X   default:
Xbad:	fprintf(stderr,"Malformed unified diff at line %ld: ",lncnt);
X	ERR(bf)
X   }
X  }
X  printf("--- %ld,%ld ----\n",ns,ne);
X  for(ln=r.lk;ln;ln=h){
X   printf("%c %s",ln->t,ln->s);
X   h=ln->lk; free(ln);
X  }
X }
X}
END_OF_FILE
if test 1507 -ne `wc -c <'unipatch.c'`; then
    echo shar: \"'unipatch.c'\" unpacked with wrong size!
fi
# end of 'unipatch.c'
fi
echo shar: End of archive 1 \(of 4\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
