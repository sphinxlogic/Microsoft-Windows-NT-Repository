Newsgroups: comp.sources.unix
From: spaf@cs.purdue.edu (Gene Spafford)
Subject: v27i166: tripwire-1.1 - security integrity monitor, V1.1, Part20/26
References: <1.756157401.21864@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: spaf@cs.purdue.edu (Gene Spafford)
Posting-Number: Volume 27, Issue 166
Archive-Name: tripwire-1.1/part20

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 20 (of 25)."
# Contents:  tripwire-1.1 tripwire-1.1/docs tripwire-1.1/man
#   tripwire-1.1/sigs tripwire-1.1/sigs/crc32 tripwire-1.1/sigs/md4
#   tripwire-1.1/sigs/md4/md4.c tripwire-1.1/docs/designaf
#   tripwire-1.1/man/tw.config.5 tripwire-1.1/sigs/crc32/crc32.c
# Wrapped by spaf@uther.cs.purdue.edu on Thu Dec 16 11:42:47 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test ! -d 'tripwire-1.1' ; then
    echo shar: Creating directory \"'tripwire-1.1'\"
    mkdir 'tripwire-1.1'
fi
if test ! -d 'tripwire-1.1/docs' ; then
    echo shar: Creating directory \"'tripwire-1.1/docs'\"
    mkdir 'tripwire-1.1/docs'
fi
if test ! -d 'tripwire-1.1/man' ; then
    echo shar: Creating directory \"'tripwire-1.1/man'\"
    mkdir 'tripwire-1.1/man'
fi
if test ! -d 'tripwire-1.1/sigs' ; then
    echo shar: Creating directory \"'tripwire-1.1/sigs'\"
    mkdir 'tripwire-1.1/sigs'
fi
if test ! -d 'tripwire-1.1/sigs/crc32' ; then
    echo shar: Creating directory \"'tripwire-1.1/sigs/crc32'\"
    mkdir 'tripwire-1.1/sigs/crc32'
fi
if test ! -d 'tripwire-1.1/sigs/md4' ; then
    echo shar: Creating directory \"'tripwire-1.1/sigs/md4'\"
    mkdir 'tripwire-1.1/sigs/md4'
fi
if test -f 'tripwire-1.1/sigs/md4/md4.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tripwire-1.1/sigs/md4/md4.c'\"
else
echo shar: Extracting \"'tripwire-1.1/sigs/md4/md4.c'\" \(9890 characters\)
sed "s/^X//" >'tripwire-1.1/sigs/md4/md4.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char rcsid[] = "$Id: md4.c,v 1.4 1993/12/15 16:50:10 genek Exp $";
X#endif
X
X/* 
X** **************************************************************************
X** md4.c -- Implementation of MD4 Message Digest Algorithm                 **
X** Updated: 2/16/90 by Ronald L. Rivest                                    **
X** (C) 1990 RSA Data Security, Inc.                                        **
X** **************************************************************************
X*/
X
X/* 
X** To use MD4:
X**   -- Include md4.h in your program
X**   -- Declare an MDstruct MD to hold the state of the digest computation.
X**   -- Initialize MD using MDbegin(&MD)
X**   -- For each full block (64 bytes) X you wish to process, call
X**          MDupdate(&MD,X,512)
X**      (512 is the number of bits in a full block.)
X**   -- For the last block (less than 64 bytes) you wish to process,
X**          MDupdate(&MD,X,n)
X**      where n is the number of bits in the partial block. A partial
X**      block terminates the computation, so every MD computation should
X**      terminate by processing a partial block, even if it has n = 0.
X**   -- The message digest is available in MD.buffer[0] ... MD.buffer[3].
X**      (Least-significant byte of each word should be output first.)
X**   -- You can print out the digest using MDprint(&MD)
X*/
X
X/* Implementation notes:
X** This implementation assumes that ints are 32-bit quantities.
X** If the machine stores the least-significant byte of an int in the
X** least-addressed byte (eg., VAX and 8086), then LOWBYTEFIRST should be
X** set to TRUE.  Otherwise (eg., SUNS), LOWBYTEFIRST should be set to
X** FALSE.  Note that on machines with LOWBYTEFIRST FALSE the routine
X** MDupdate modifies has a side-effect on its input array (the order of bytes
X** in each word are reversed).  If this is undesired a call to MDreverse(X) can
X** reverse the bytes of X back into order after each call to MDupdate.
X*/
X#define TRUE  1
X#define FALSE 0
X
X
X/* Compile-time includes 
X*/
X#include "../../include/config.h"
X#include <stdio.h>
X#ifdef STDLIBH
X#include <stdlib.h>
X#endif
X#include "../../include/byteorder.h"
X#include "md4.h"
X
X/* Compile-time declarations of MD4 ``magic constants''.
X*/
X#define I0  0x67452301       /* Initial values for MD buffer */
X#define I1  0xefcdab89
X#define I2  0x98badcfe
X#define I3  0x10325476
X#define C2  013240474631     /* round 2 constant = sqrt(2) in octal */
X#define C3  015666365641     /* round 3 constant = sqrt(3) in octal */
X/* C2 and C3 are from Knuth, The Art of Programming, Volume 2
X** (Seminumerical Algorithms), Second Edition (1981), Addison-Wesley.
X** Table 2, page 660.
X*/
X#define fs1  3               /* round 1 shift amounts */
X#define fs2  7   
X#define fs3 11  
X#define fs4 19  
X#define gs1  3               /* round 2 shift amounts */
X#define gs2  5   
X#define gs3  9   
X#define gs4 13  
X#define hs1  3               /* round 3 shift amounts */
X#define hs2  9 
X#define hs3 11 
X#define hs4 15
X
X
X/* Compile-time macro declarations for MD4.
X** Note: The ``rot'' operator uses the variable ``tmp''.
X** It assumes tmp is declared as unsigned int, so that the >>
X** operator will shift in zeros rather than extending the sign bit.
X*/
X#define	f(X,Y,Z)             ((X&Y) | ((~X)&Z))
X#define	g(X,Y,Z)             ((X&Y) | (X&Z) | (Y&Z))
X#define h(X,Y,Z)             (X^Y^Z)
X#define rot(X,S)             (tmp=X,(tmp<<S) | (tmp>>(32-S)))
X#define ff(A,B,C,D,i,s)      A = rot((A + f(B,C,D) + X[i]),s)
X#define gg(A,B,C,D,i,s)      A = rot((A + g(B,C,D) + X[i] + C2),s)
X#define hh(A,B,C,D,i,s)      A = rot((A + h(B,C,D) + X[i] + C3),s)
X
X/* MDprint(MDp)
X** Print message digest buffer MDp as 32 hexadecimal digits.
X** Order is from low-order byte of buffer[0] to high-order byte of buffer[3].
X** Each byte is printed with high-order hexadecimal digit first.
X** This is a user-callable routine.
X*/
Xvoid 
XMDprint(MDp)
XMDptr MDp;
X{ int i,j;
X  for (i=0;i<4;i++)
X    for (j=0;j<32;j=j+8)
X      printf("%02x",(MDp->buffer[i]>>j) & 0xFF);
X}
X
Xlong lbuf[4];
Xvoid 
XMDsprint(dest, MDp)
Xchar *dest;
XMDptr MDp;
X{ int i,j;
X  char s[200], *pc;
X  long l;
X  for (i=0;i<4;i++) {
X    pc = s;
X    for (j=0;j<32;j=j+8) {
X      sprintf(pc, "%02x",(MDp->buffer[i]>>j) & 0xFF);
X      pc += 2;
X    }
X    sscanf(s, "%lx", &lbuf[i]);
X  }
X  for (i = 0, pc = dest; i < 4; i++, pc += 8) {
X      sprintf(pc, "%08lx", lbuf[i]);
X  }
X}
X
Xvoid
XMDsprint64(dest, MDp)
Xchar *dest;
XMDptr MDp;
X{ 
X  pltob64(MDp->buffer, dest, 4);
X}
X
X/* MDbegin(MDp)
X** Initialize message digest buffer MDp. 
X** This is a user-callable routine.
X*/
Xvoid 
XMDbegin(MDp)
XMDptr MDp;
X{ int i;
X  MDp->buffer[0] = I0;  
X  MDp->buffer[1] = I1;  
X  MDp->buffer[2] = I2;  
X  MDp->buffer[3] = I3; 
X  for (i=0;i<8;i++) MDp->count[i] = 0;
X  MDp->done = 0;
X}
X
X/* MDreverse(X)
X** Reverse the byte-ordering of every int in X.
X** Assumes X is an array of 16 ints.
X** The macro revx reverses the byte-ordering of the next word of X.
X*/
X#define revx { t = (*X << 16) | (*X >> 16); \
X	       *X++ = ((t & 0xFF00FF00) >> 8) | ((t & 0x00FF00FF) << 8); }
Xvoid
XMDreverse(X)
Xunsigned int *X;
X{ register unsigned int t;
X  revx; revx; revx; revx; revx; revx; revx; revx;
X  revx; revx; revx; revx; revx; revx; revx; revx;
X}
X
X/* MDblock(MDp,X)
X** Update message digest buffer MDp->buffer using 16-word data block X.
X** Assumes all 16 words of X are full of data.
X** Does not update MDp->count.
X** This routine is not user-callable. 
X*/
Xstatic void
XMDblock(MDp,X)
XMDptr MDp;
Xunsigned int *X;
X{ 
X  register unsigned int tmp, A, B, C, D;
X#if BYTEORDER == 0x4321
X  MDreverse(X);
X#endif
X  A = MDp->buffer[0];
X  B = MDp->buffer[1];
X  C = MDp->buffer[2];
X  D = MDp->buffer[3];
X  /* Update the message digest buffer */
X  ff(A , B , C , D ,  0 , fs1); /* Round 1 */
X  ff(D , A , B , C ,  1 , fs2); 
X  ff(C , D , A , B ,  2 , fs3); 
X  ff(B , C , D , A ,  3 , fs4); 
X  ff(A , B , C , D ,  4 , fs1); 
X  ff(D , A , B , C ,  5 , fs2); 
X  ff(C , D , A , B ,  6 , fs3); 
X  ff(B , C , D , A ,  7 , fs4); 
X  ff(A , B , C , D ,  8 , fs1); 
X  ff(D , A , B , C ,  9 , fs2); 
X  ff(C , D , A , B , 10 , fs3); 
X  ff(B , C , D , A , 11 , fs4); 
X  ff(A , B , C , D , 12 , fs1); 
X  ff(D , A , B , C , 13 , fs2); 
X  ff(C , D , A , B , 14 , fs3); 
X  ff(B , C , D , A , 15 , fs4); 
X  gg(A , B , C , D ,  0 , gs1); /* Round 2 */
X  gg(D , A , B , C ,  4 , gs2); 
X  gg(C , D , A , B ,  8 , gs3); 
X  gg(B , C , D , A , 12 , gs4); 
X  gg(A , B , C , D ,  1 , gs1); 
X  gg(D , A , B , C ,  5 , gs2); 
X  gg(C , D , A , B ,  9 , gs3); 
X  gg(B , C , D , A , 13 , gs4); 
X  gg(A , B , C , D ,  2 , gs1); 
X  gg(D , A , B , C ,  6 , gs2); 
X  gg(C , D , A , B , 10 , gs3); 
X  gg(B , C , D , A , 14 , gs4); 
X  gg(A , B , C , D ,  3 , gs1); 
X  gg(D , A , B , C ,  7 , gs2); 
X  gg(C , D , A , B , 11 , gs3); 
X  gg(B , C , D , A , 15 , gs4);  
X  hh(A , B , C , D ,  0 , hs1); /* Round 3 */
X  hh(D , A , B , C ,  8 , hs2); 
X  hh(C , D , A , B ,  4 , hs3); 
X  hh(B , C , D , A , 12 , hs4); 
X  hh(A , B , C , D ,  2 , hs1); 
X  hh(D , A , B , C , 10 , hs2); 
X  hh(C , D , A , B ,  6 , hs3); 
X  hh(B , C , D , A , 14 , hs4); 
X  hh(A , B , C , D ,  1 , hs1); 
X  hh(D , A , B , C ,  9 , hs2); 
X  hh(C , D , A , B ,  5 , hs3); 
X  hh(B , C , D , A , 13 , hs4); 
X  hh(A , B , C , D ,  3 , hs1); 
X  hh(D , A , B , C , 11 , hs2); 
X  hh(C , D , A , B ,  7 , hs3); 
X  hh(B , C , D , A , 15 , hs4);
X  MDp->buffer[0] += A; 
X  MDp->buffer[1] += B;
X  MDp->buffer[2] += C;
X  MDp->buffer[3] += D; 
X}
X
X/* MDupdate(MDp,X,count)
X** Input: MDp -- an MDptr
X**        X -- a pointer to an array of unsigned characters.
X**        count -- the number of bits of X to use.
X**                 (if not a multiple of 8, uses high bits of last byte.)
X** Update MDp using the number of bits of X given by count.
X** This is the basic input routine for an MD4 user.
X** The routine completes the MD computation when count < 512, so
X** every MD computation should end with one call to MDupdate with a
X** count less than 512.  A call with count 0 will be ignored if the
X** MD has already been terminated (done != 0), so an extra call with count
X** 0 can be given as a ``courtesy close'' to force termination if desired.
X*/
Xvoid 
XMDupdate(MDp,X,count)
XMDptr MDp;
Xunsigned char *X;
Xunsigned int count;
X{ unsigned int i, tmp, bit, byte, mask;
X  unsigned char XX[64];
X  unsigned char *p;
X  /* return with no error if this is a courtesy close with count
X  ** zero and MDp->done is true.
X  */
X  if (count == 0 && MDp->done) return;
X  /* check to see if MD is already done and report error */
X  if (MDp->done) { printf("\nError: MDupdate MD already done."); return; }
X  /* Add count to MDp->count */
X  tmp = count;
X  p = MDp->count;
X  while (tmp)
X    { tmp += *p;
X      *p++ = tmp;
X      tmp = tmp >> 8;
X    }
X  /* Process data */
X  if (count == 512) 
X    { /* Full block of data to handle */
X      MDblock(MDp,(unsigned int *)X);
X    }
X  else if (count > 512) /* Check for count too large */
X    { printf("\nError: MDupdate called with illegal count value %d.",count);
X      return;
X    }
X  else /* partial block -- must be last block so finish up */
X    { /* Find out how many bytes and residual bits there are */
X      byte = count >> 3;
X      bit =  count & 7;
X      /* Copy X into XX since we need to modify it */
X      for (i=0;i<=byte;i++)   XX[i] = X[i];
X      for (i=byte+1;i<64;i++) XX[i] = 0;
X      /* Add padding '1' bit and low-order zeros in last byte */
X      mask = 1 << (7 - bit);
X      XX[byte] = (XX[byte] | mask) & ~( mask - 1);
X      /* If room for bit count, finish up with this block */
X      if (byte <= 55)
X	{ for (i=0;i<8;i++) XX[56+i] = MDp->count[i];
X	  MDblock(MDp,(unsigned int *)XX);
X	}
X      else /* need to do two blocks to finish up */
X	{ MDblock(MDp,(unsigned int *)XX);
X	  for (i=0;i<56;i++) XX[i] = 0;
X	  for (i=0;i<8;i++)  XX[56+i] = MDp->count[i];
X	  MDblock(MDp,(unsigned int *)XX);
X	}
X      /* Set flag saying we're done with MD computation */
X      MDp->done = 1;
X    }
X}
END_OF_FILE
if test 9890 -ne `wc -c <'tripwire-1.1/sigs/md4/md4.c'`; then
    echo shar: \"'tripwire-1.1/sigs/md4/md4.c'\" unpacked with wrong size!
fi
# end of 'tripwire-1.1/sigs/md4/md4.c'
fi
if test -f 'tripwire-1.1/docs/designaf' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tripwire-1.1/docs/designaf'\"
else
echo shar: Extracting \"'tripwire-1.1/docs/designaf'\" \(9101 characters\)
sed "s/^X//" >'tripwire-1.1/docs/designaf' <<'END_OF_FILE'
X
X/arrowheadpath {
Xnewpath
XarrowHeight neg arrowWidth 2 div moveto
X0 0 lineto
XarrowHeight neg arrowWidth 2 div neg lineto
X} def
X
X/leftarrow {
X0 begin
Xy exch get /taily exch def
Xx exch get /tailx exch def
Xy exch get /tipy exch def
Xx exch get /tipx exch def
XbrushLeftArrow { tipx tipy tailx taily arrowhead } if
Xend
X} dup 0 4 dict put def
X
X/rightarrow {
X0 begin
Xy exch get /tipy exch def
Xx exch get /tipx exch def
Xy exch get /taily exch def
Xx exch get /tailx exch def
XbrushRightArrow { tipx tipy tailx taily arrowhead } if
Xend
X} dup 0 4 dict put def
X
X
X/arrowHeight 10 def
X/arrowWidth 5 def
X
X/IdrawDict 51 dict def
XIdrawDict begin
X
X/reencodeISO {
Xdup dup findfont dup length dict begin
X{ 1 index /FID ne { def }{ pop pop } ifelse } forall
X/Encoding ISOLatin1Encoding def
Xcurrentdict end definefont
X} def
X
X/ISOLatin1Encoding [
X/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
X/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
X/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
X/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
X/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
X/parenleft/parenright/asterisk/plus/comma/minus/period/slash
X/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
X/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N
X/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
X/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
X/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde
X/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
X/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
X/.notdef/dotlessi/grave/acute/circumflex/tilde/macron/breve
X/dotaccent/dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut
X/ogonek/caron/space/exclamdown/cent/sterling/currency/yen/brokenbar
X/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot
X/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior
X/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine
X/guillemotright/onequarter/onehalf/threequarters/questiondown
X/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
X/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex
X/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis
X/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute
X/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis
X/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave
X/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex
X/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis
X/yacute/thorn/ydieresis
X] def
X/Helvetica reencodeISO def
X
X/none null def
X/numGraphicParameters 17 def
X/stringLimit 65535 def
X
X/Begin {
Xsave
XnumGraphicParameters dict begin
X} def
X
X/End {
Xend
Xrestore
X} def
X
X/SetB {
Xdup type /nulltype eq {
Xpop
Xfalse /brushRightArrow idef
Xfalse /brushLeftArrow idef
Xtrue /brushNone idef
X} {
X/brushDashOffset idef
X/brushDashArray idef
X0 ne /brushRightArrow idef
X0 ne /brushLeftArrow idef
X/brushWidth idef
Xfalse /brushNone idef
X} ifelse
X} def
X
X/SetCFg {
X/fgblue idef
X/fggreen idef
X/fgred idef
X} def
X
X/SetCBg {
X/bgblue idef
X/bggreen idef
X/bgred idef
X} def
X
X/SetF {
X/printSize idef
X/printFont idef
X} def
X
X/SetP {
Xdup type /nulltype eq {
Xpop true /patternNone idef
X} {
Xdup -1 eq {
X/patternGrayLevel idef
X/patternString idef
X} {
X/patternGrayLevel idef
X} ifelse
Xfalse /patternNone idef
X} ifelse
X} def
X
X/BSpl {
X0 begin
Xstorexyn
Xnewpath
Xn 1 gt {
X0 0 0 0 0 0 1 1 true subspline
Xn 2 gt {
X0 0 0 0 1 1 2 2 false subspline
X1 1 n 3 sub {
X/i exch def
Xi 1 sub dup i dup i 1 add dup i 2 add dup false subspline
X} for
Xn 3 sub dup n 2 sub dup n 1 sub dup 2 copy false subspline
X} if
Xn 2 sub dup n 1 sub dup 2 copy 2 copy false subspline
XpatternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
XbrushNone not { istroke } if
X0 0 1 1 leftarrow
Xn 2 sub dup n 1 sub dup rightarrow
X} if
Xend
X} dup 0 4 dict put def
X
X/Circ {
Xnewpath
X0 360 arc
XpatternNone not { ifill } if
XbrushNone not { istroke } if
X} def
X
X/CBSpl {
X0 begin
Xdup 2 gt {
Xstorexyn
Xnewpath
Xn 1 sub dup 0 0 1 1 2 2 true subspline
X1 1 n 3 sub {
X/i exch def
Xi 1 sub dup i dup i 1 add dup i 2 add dup false subspline
X} for
Xn 3 sub dup n 2 sub dup n 1 sub dup 0 0 false subspline
Xn 2 sub dup n 1 sub dup 0 0 1 1 false subspline
XpatternNone not { ifill } if
XbrushNone not { istroke } if
X} {
XPoly
X} ifelse
Xend
X} dup 0 4 dict put def
X
X/Elli {
X0 begin
Xnewpath
X4 2 roll
Xtranslate
Xscale
X0 0 1 0 360 arc
XpatternNone not { ifill } if
XbrushNone not { istroke } if
Xend
X} dup 0 1 dict put def
X
X/Line {
X0 begin
X2 storexyn
Xnewpath
Xx 0 get y 0 get moveto
Xx 1 get y 1 get lineto
XbrushNone not { istroke } if
X0 0 1 1 leftarrow
X0 0 1 1 rightarrow
Xend
X} dup 0 4 dict put def
X
X/MLine {
X0 begin
Xstorexyn
Xnewpath
Xn 1 gt {
Xx 0 get y 0 get moveto
X1 1 n 1 sub {
X/i exch def
Xx i get y i get lineto
X} for
XpatternNone not brushLeftArrow not brushRightArrow not and and { ifill } if
XbrushNone not { istroke } if
X0 0 1 1 leftarrow
Xn 2 sub dup n 1 sub dup rightarrow
X} if
Xend
X} dup 0 4 dict put def
X
X/Poly {
X3 1 roll
Xnewpath
Xmoveto
X-1 add
X{ lineto } repeat
Xclosepath
XpatternNone not { ifill } if
XbrushNone not { istroke } if
X} def
X
X/Rect {
X0 begin
X/t exch def
X/r exch def
X/b exch def
X/l exch def
Xnewpath
Xl b moveto
Xl t lineto
Xr t lineto
Xr b lineto
Xclosepath
XpatternNone not { ifill } if
XbrushNone not { istroke } if
Xend
X} dup 0 4 dict put def
X
X/Text {
Xishow
X} def
X
X/idef {
Xdup where { pop pop pop } { exch def } ifelse
X} def
X
X/ifill {
X0 begin
Xgsave
XpatternGrayLevel -1 ne {
Xfgred bgred fgred sub patternGrayLevel mul add
Xfggreen bggreen fggreen sub patternGrayLevel mul add
Xfgblue bgblue fgblue sub patternGrayLevel mul add setrgbcolor
Xeofill
X} {
Xeoclip
XoriginalCTM setmatrix
Xpathbbox /t exch def /r exch def /b exch def /l exch def
X/w r l sub ceiling cvi def
X/h t b sub ceiling cvi def
X/imageByteWidth w 8 div ceiling cvi def
X/imageHeight h def
Xbgred bggreen bgblue setrgbcolor
Xeofill
Xfgred fggreen fgblue setrgbcolor
Xw 0 gt h 0 gt and {
Xl w add b translate w neg h scale
Xw h true [w 0 0 h neg 0 h] { patternproc } imagemask
X} if
X} ifelse
Xgrestore
Xend
X} dup 0 8 dict put def
X
X/istroke {
Xgsave
XbrushDashOffset -1 eq {
X[] 0 setdash
X1 setgray
X} {
XbrushDashArray brushDashOffset setdash
Xfgred fggreen fgblue setrgbcolor
X} ifelse
XbrushWidth setlinewidth
XoriginalCTM setmatrix
Xstroke
Xgrestore
X} def
X
X/ishow {
X0 begin
Xgsave
Xfgred fggreen fgblue setrgbcolor
X/fontDict printFont printSize scalefont dup setfont def
X/descender fontDict begin 0 [FontBBox] 1 get FontMatrix end
Xtransform exch pop def
X/vertoffset 1 printSize sub descender sub def {
X0 vertoffset moveto show
X/vertoffset vertoffset printSize sub def
X} forall
Xgrestore
Xend
X} dup 0 3 dict put def
X/patternproc {
X0 begin
X/patternByteLength patternString length def
X/patternHeight patternByteLength 8 mul sqrt cvi def
X/patternWidth patternHeight def
X/patternByteWidth patternWidth 8 idiv def
X/imageByteMaxLength imageByteWidth imageHeight mul
XstringLimit patternByteWidth sub min def
X/imageMaxHeight imageByteMaxLength imageByteWidth idiv patternHeight idiv
XpatternHeight mul patternHeight max def
X/imageHeight imageHeight imageMaxHeight sub store
X/imageString imageByteWidth imageMaxHeight mul patternByteWidth add string def
X0 1 imageMaxHeight 1 sub {
X/y exch def
X/patternRow y patternByteWidth mul patternByteLength mod def
X/patternRowString patternString patternRow patternByteWidth getinterval def
X/imageRow y imageByteWidth mul def
X0 patternByteWidth imageByteWidth 1 sub {
X/x exch def
XimageString imageRow x add patternRowString putinterval
X} for
X} for
XimageString
Xend
X} dup 0 12 dict put def
X
X/min {
Xdup 3 2 roll dup 4 3 roll lt { exch } if pop
X} def
X
X/max {
Xdup 3 2 roll dup 4 3 roll gt { exch } if pop
X} def
X
X/midpoint {
X0 begin
X/y1 exch def
X/x1 exch def
X/y0 exch def
X/x0 exch def
Xx0 x1 add 2 div
Xy0 y1 add 2 div
Xend
X} dup 0 4 dict put def
X
X/thirdpoint {
X0 begin
X/y1 exch def
X/x1 exch def
X/y0 exch def
X/x0 exch def
Xx0 2 mul x1 add 3 div
Xy0 2 mul y1 add 3 div
Xend
X} dup 0 4 dict put def
X
X/subspline {
X0 begin
X/movetoNeeded exch def
Xy exch get /y3 exch def
Xx exch get /x3 exch def
Xy exch get /y2 exch def
Xx exch get /x2 exch def
Xy exch get /y1 exch def
Xx exch get /x1 exch def
Xy exch get /y0 exch def
Xx exch get /x0 exch def
Xx1 y1 x2 y2 thirdpoint
X/p1y exch def
X/p1x exch def
Xx2 y2 x1 y1 thirdpoint
X/p2y exch def
X/p2x exch def
Xx1 y1 x0 y0 thirdpoint
Xp1x p1y midpoint
X/p0y exch def
X/p0x exch def
Xx2 y2 x3 y3 thirdpoint
Xp2x p2y midpoint
X/p3y exch def
X/p3x exch def
XmovetoNeeded { p0x p0y moveto } if
Xp1x p1y p2x p2y p3x p3y curveto
Xend
X} dup 0 17 dict put def
X
X/storexyn {
X/n exch def
X/y n array def
X/x n array def
Xn 1 sub -1 0 {
X/i exch def
Xy i 3 2 roll put
Xx i 3 2 roll put
X} for
X} def
X
X/SSten {
Xfgred fggreen fgblue setrgbcolor
Xdup true exch 1 0 0 -1 0 6 -1 roll matrix astore
X} def
X
X/FSten {
Xdup 3 -1 roll dup 4 1 roll exch
Xnewpath
X0 0 moveto
Xdup 0 exch lineto
Xexch dup 3 1 roll exch lineto
X0 lineto
Xclosepath
Xbgred bggreen bgblue setrgbcolor
Xeofill
XSSten
X} def
X
X/Rast {
Xexch dup 3 1 roll 1 0 0 -1 0 6 -1 roll matrix astore
X} def
X
X
X
X
XBegin
X[ 0.796717 0 0 0.796717 0 0 ] concat
END_OF_FILE
if test 9101 -ne `wc -c <'tripwire-1.1/docs/designaf'`; then
    echo shar: \"'tripwire-1.1/docs/designaf'\" unpacked with wrong size!
fi
# end of 'tripwire-1.1/docs/designaf'
fi
if test -f 'tripwire-1.1/man/tw.config.5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tripwire-1.1/man/tw.config.5'\"
else
echo shar: Extracting \"'tripwire-1.1/man/tw.config.5'\" \(8971 characters\)
sed "s/^X//" >'tripwire-1.1/man/tw.config.5' <<'END_OF_FILE'
X.\" $Id: tw.config.5,v 1.9 1993/12/15 16:50:04 genek Exp $
X.\"
X.TH TW.CONFIG 5 "October 5, 1992"
X.SH NAME
Xtw.config \- configuration file for Tripwire
X.SH SYNOPSIS
Xtw.config
X.SH DESCRIPTION
XThe \fItw.config\fP file contains the list of files and
Xdirectories to be scanned by Tripwire.  Information on these
Xfiles is collected and stored in the \fItw.db\fP database file.
XStored with each \fItw.config\fP entry is a \fIselection-mask\fP
Xthat describes what changes Tripwire can safely ignore without
Xreporting to the user (e.g., access timestamp).
X.LP
XThe first section in this manual page describes the entry format in
X\fItw.config\fP for the files monitored by Tripwire.  The second
Xsection describes the proprocessing directives that Tripwire
Xprovides.  These directives, which provide functionality similar to
Xthe C preprocessor and M4 macro processor, allow Tripwire to make
Xbindings at run-time.  This allows system administrators to use common
X\fItw.config\fP files across multiple machines \- or even across an
Xentire site.
X.SH ENTRY FORMAT
X.LP
XEach entry in \fItw.config\fP is a single line in the following form:
X.sp
X.RS
X\fBFormat\fP: 	\fI[!|=] entry [select-flags | template] [# comment]\fP
X.RE
X.RS
X.TP 12
X.I entry
XAn \fIentry\fP is the absolute pathname of a file or a directory. 
XWithout any prefixes, the \fIentry\fP is added to the list of files
Xto be scanned.
X.RS
X.TP 
X.I !
XInclusive prune.  Prunes \fIentry\fP from the list of files to be
Xscanned.  If \fIentry\fP is a file, the file is removed from the list of
Xfiles.  If \fIentry\fP is a directory, the directory and all of
Xits children are removed from the list of files.
X.TP
X.I =
XExclusive prune.  Does not prune \fIentry\fP, but does prune its
Xchildren.  This has no effect if \fIentry\fP is a file.  This
Xoption is useful for monitoring directories with transient files
X(e.g., /tmp and /var/tmp).
X.RE
X.TP
X.I select-flags
X\fIselect-flags\fP describe inode and file attributes.  \fIselect-flags\fP
Xeither specifies Tripwire to ignore changes in a specific attribute, or to
Xreport them.  \fIselect-flags\fP are provided in the form:
X.I
X[ [+|-][pinugsam123456789] ... ]
X.RS
X.TP 4
X.I -
Xignore the following attributes 	
X.TP
X.I +
Xrecord and check the following attributes
X.TP
X.I p
Xpermission and file mode bits 	
X.TP
X.I i
Xinode number			
X.TP
X.I n
Xnumber of links (i.e., inode reference count)	
X.TP
X.I u
Xuser id of owner			
X.TP
X.I g
Xgroup id of owner			
X.TP
X.I s
Xsize of file
X.TP
X.I a
Xaccess timestamp
X.TP
X.I m
Xmodification timestamp
X.TP
X.I c
Xinode creation/modification timestamp
X.TP
X.I 0
Xsignature 0 \- null signature
X.TP
X.I 1
Xsignature 1 \- MD5, the RSA Data Security, Inc. Message Digesting Algorithm.
X.TP
X.I 2
Xsignature 2 \- Snefru, the Xerox Secure Hash Function.
X.TP
X.I 3
Xsignature 3 \- CRC-32, POSIX 1003.2 compliant 32-bit Cyclic Redundancy Check.
X.TP
X.I 4
Xsignature 4 \- CRC-16, the standard (non-CCITT) 16-bit Cyclic Redundancy Check.
X.TP
X.I 5
Xsignature 5 \- MD4, the RSA Data Security, Inc. Message Digesting Algorithm.
X.TP
X.I 6
Xsignature 6 \- MD2, the RSA Data Security, Inc. Message Digesting Algorithm.
X.TP
X.I 7
Xsignature 7 \- SHA, the NIST Secure Hash Algorithm
X.TP
X.I 8
Xsignature 8 \- null signature (reserved for future expansion)
X.TP
X.I 9
Xsignature 9 \- null signature (reserved for future expansion)
X.RE
X.TP
X.I templates
X\fItemplate\fP are predefined sets of \fIselect-flags\fP that are
Xcommonly used by system administrators.
X.RE
X.LP
XThe following templates have been pre-defined to make these long 
X\fIselect-masks\fP descriptions unnecessary.
X.RS
X.nf
X.TP 6
X.I R 
X[R]ead-only (+pinugsm12-a3456789) \fI(default)\fP
X.TP
X.I L 
X[L]og file (+pinug-sam123456789)
X.TP
X.I N
Xignore [N]othing (+pinusgsamc123456789)
X.TP
X.I E
Xignore [E]verything (-pinusgsamc123456789)
X.TP
X.I >
Xmonotonically growing file (+pinug>-samc1233456789) \- the ``>'' indicates
Xthat file changes are ignored only when the file is smaller than the last
Xrecorded size.  This is useful for log files that are expected to grow.
X.fi
X.RE
X.LP
XBy default, Tripwire uses the R template.  Because it applies the
Xset of \fIselect-flags\fP {+pinugsm12-a3456789}, Tripwire ignores
Xthose changed files where only the access timestamp changed.
X.LP
XYou can combine the use of templates with \fIselect-flag\fP modifiers.
XThe following entry monitors only changes in user-id and group-id
Xinformation.
X.RS
X/etc/lp	E+ug
X.RE
X.SH ENTRY EXAMPLES
X.LP
XThe following entry will scan all the files in /etc, and report
Xany changes in mode bits, inode number, reference count, uid,
Xgid, modification and creation timestamp, and the signatures.
XHowever, it will ignore any changes in the access timestamp.
X.RS
X/etc	+pinugsm12-a
X.RE
X.LP
XIt is equivalent to:
X.RS
X/etc	R
X.RE
X.LP
XThe following example shows a very simple \fItw.config\fP file that 
Xmonitors selected directories.
X.RS
X.nf
X/etc		R	# all system files
X!/etc/lp		R	# ...but not those logs
X=/tmp		N	# just the directory, not its files
X.fi
X.RE
X.LP
XNote the difference between pruning (via "!") and ignoring everything
X(via "N" template):  ignoring everything in a directory still monitors
Xfor added and deleted files, but pruning a directory will prevent Tripwire
Xfrom even looking in the specified directory for any changes.
X.LP
X.I Hint: 
XIs Tripwire running too slowly?  Modify your \fItw.config\fP entries
Xto use only a few signatues (e.g., signatures 1 and 5) when this
Xcomputationally-exorbitant protection is not needed.  (See README and
Xdesign document for further details.)
X.SH PREPROCESSOR
X.LP
XTripwire incorporates a general purpose preprocessor that parses
Xthe \fItw.config\fP file in one-pass.  Available preprocessing directives
Xinclude file inclusion, macro defines, conditionals based upon
Xhostname or macros, and on-the-fly macro substitution.  These directives
Xprovide C-preprocessor and m4-like capabilities.
X.LP
XThe Tripwire preprocessor was included to allow its scalable use at 
Xlarge sites, allowing system administrators to reuse \fItw.config\fP files
Xby either including component files or having multiple machines share a
Xcommon \fItw.config\fI file.
X.RS
X.TP 30
X.I @@ifhost HOSTNAME	
Xincludes text until matching \fI@@endif\fP if the machine
Xhostname matches the specified \fIHOSTNAME\fP.  Remember that you must use
Xthe exact hostname that \fIuname(1)\fP or \fIhostname(1)\fP returns.  
XThis usually implies that you must use the fully qualified hostname
X(e.g., mentor.cc.purdue.edu).
X.TP
X.I @@ifnhost HOSTNAME
Xincludes text until matching \fI@@endif\fP if the machine
Xhostname does not match the specified \fIHOSTNAME\fP.
X.TP
X.I @@else 
Xprovides if-else semantics to preprocessor.
X.TP
X.I @@define VAR STRING
Xdefines variable \fIVAR\fP to \fISTRING\fP.  If the second argument
Xis not provided, then a null-string is assigned to \fIVAR\fP.
X.TP
X.I @@undef VAR
Xclears the definition associated with variable \fIVAR\fP.
X.TP
X.I @@ifdef VAR
Xincludes text until the matching \fI@@endif\fP or \fI@@else\fP if the
Xvariable \fIVAR\fP has been defined.
X.TP
X.I @@ifndef VAR
Xincludes text until matching \fI@@endif\fP or \fI@@else\fP if the
Xvariable \fIVAR\fP has not been defined.
X.TP
X.I @@endif
Xcloses up \fI@@ifhost\fP, \fI@@ifnhost\fP, \fI@@ifdef\fP, and
X\fI@@ifndef\fP.
X.TP
X.I @@include ``PATHNAME''
Xreads in the specified source file.  The double-quotes are optional.
X.TP
X.I @@VAR
Xsubstitutes the definition of \fIVAR\fP with the \fI@@define\fP'ed
Xvalue.
X.TP
X.I @@{VAR}
Xsubstitutes the definition of \fIVAR\fP with the \fI@@define\fP'ed
Xvalue.
X.RE
X.LP
X.I Example:
XA host-dependent inclusion can be specified many ways so \fItw.config\fP
Xfiles can be shared among multiple machines.  So, if the machine 
X"mentor.cc.purdue.edu" is the only machine that has a certain file,
Xyou could use:
X.RS
X.nf
X@@ifhost mentor.cc.purdue.edu
X/etc/tw.log.mentor	R
X@@endif
X
X@@define ARCHIVE	R
X/etc/tw.log		@@ARCHIVE
X.fi
X.RE
X.SH CAVEATS
X.LP
XAlthough Tripwire provides hooks for ten different
Xsignature routines, using all ten would certainly be overkill in
Xalmost any imaginable situation.  However, having up to ten
Xsignature routines in your signature arsenal allows system
Xadministrators considerable flexibility in finding the balance
Xbetween performance and security for their specific site.  This
Xis the reason for supplying CRC-16 and CRC-32, which are trivially
Xsimple to spoof.  These routines are not secure, but they are
Xfaster than the message-digesting routines.
X.SH DATABASE VERSIONS
X.LP
XTripwire v1.0 used database version 1.  Database version 2 changed the
Xbase-64 alphabet so that ``0'' retained its traditional value.  Database
Xversion 3 changed the base-64 encoding so that all the bits were packed,
Xreducing the size of 160-bit signatures from 30 characters to 27
Xcharacters.
X.LP
XTripwire v1.1 uses database version 3.  The program
X\fItwconvert\fP is provided to convert from the older database formats
Xto version 3.
X.SH SEE ALSO
Xtripwire(8), twconvert(8)
X.SH AUTHOR
X.nf
XGene Kim
XPurdue University
Xgkim@cs.purdue.edu
X
XEugene Spafford
XPurdue University
Xspaf@cs.purdue.edu
X.fi
X
END_OF_FILE
if test 8971 -ne `wc -c <'tripwire-1.1/man/tw.config.5'`; then
    echo shar: \"'tripwire-1.1/man/tw.config.5'\" unpacked with wrong size!
fi
# end of 'tripwire-1.1/man/tw.config.5'
fi
if test -f 'tripwire-1.1/sigs/crc32/crc32.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tripwire-1.1/sigs/crc32/crc32.c'\"
else
echo shar: Extracting \"'tripwire-1.1/sigs/crc32/crc32.c'\" \(6928 characters\)
sed "s/^X//" >'tripwire-1.1/sigs/crc32/crc32.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char rcsid[] = "$Id: crc32.c,v 1.8 1993/12/15 16:50:08 genek Exp $";
X#endif
X
X/*-
X * Copyright (c) 1991, 1993
X *	The Regents of the University of California.  All rights reserved.
X *
X * This code is derived from software contributed to Berkeley by
X * James W. Williams of NASA Goddard Space Flight Center.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X/*
X * crc32.c
X *
X *	signature function hook for CRC32.
X *
X * Gene Kim
X * Purdue University
X * August 31, 1993
X */
X
X#include "../../include/config.h"
X#include <stdio.h>
X#include <sys/types.h>
X#ifdef STDLIBH
X#include <stdlib.h>
X#include <unistd.h>
X#endif
X#include "../../include/sigs.h"
X#include "crc32.h"
X#define BUFSIZE 4096
X
Xstatic unsigned long crctab[] = {
X	0x0,
X	0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
X	0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6,
X	0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
X	0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9, 0x5f15adac,
X	0x5bd4b01b, 0x569796c2, 0x52568b75, 0x6a1936c8, 0x6ed82b7f,
X	0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3, 0x709f7b7a,
X	0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
X	0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58,
X	0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033,
X	0xa4ad16ea, 0xa06c0b5d, 0xd4326d90, 0xd0f37027, 0xddb056fe,
X	0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
X	0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1, 0xe13ef6f4,
X	0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,
X	0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5,
X	0x2ac12072, 0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
X	0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca, 0x7897ab07,
X	0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb, 0x6f52c06c,
X	0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1,
X	0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
X	0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b,
X	0xbb60adfc, 0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698,
X	0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044, 0x902b669d,
X	0x94ea7b2a, 0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
X	0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2, 0xc6bcf05f,
X	0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,
X	0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80,
X	0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
X	0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f, 0x5c007b8a,
X	0x58c1663d, 0x558240e4, 0x51435d53, 0x251d3b9e, 0x21dc2629,
X	0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5, 0x3f9b762c,
X	0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
X	0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e,
X	0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65,
X	0xeba91bbc, 0xef68060b, 0xd727bbb6, 0xd3e6a601, 0xdea580d8,
X	0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
X	0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7, 0xae3afba2,
X	0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,
X	0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74,
X	0x857130c3, 0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
X	0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c, 0x7b827d21,
X	0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd, 0x6c47164a,
X	0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e, 0x18197087,
X	0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
X	0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d,
X	0x2056cd3a, 0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce,
X	0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb,
X	0xdbee767c, 0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
X	0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4, 0x89b8fd09,
X	0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,
X	0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf,
X	0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
X};
X
X/*
X * Compute a POSIX 1003.2 checksum.  This routine has been broken out so that
X * other programs can use it.  It takes a file descriptor to read from and
X * locations to store the crc and the number of bytes read.  It returns 0 on
X * success and 1 on failure.  Errno is set on failure.
X */
Xunsigned long crc_total = ~0;			/* The crc over a number of files. */
X
Xint
Xsig_crc32_get(fd_in, ps_signature, siglen)
X    int fd_in;
X    char *ps_signature;
X    int siglen;
X{
X	register unsigned char *p;
X	register int nr;
X	register unsigned long crc, len;
X	unsigned char buf[BUFSIZE];
X	char *pc, scratch[100];
X
X	/* rewind the file descriptor */
X	if (lseek(fd_in, 0, SEEK_SET) < 0) {
X	    perror("sig_crc_get: lseek()");
X	    exit(1);
X	}
X
X
X#define	COMPUTE(var, ch)	(var) = (var) << 8 ^ crctab[(var) >> 24 ^ (ch)]
X
X	crc = len = 0;
X	crc_total = ~crc_total;
X	while ((nr = read(fd_in, buf, BUFSIZE)) > 0)
X		for (len += nr, p = buf; nr--; ++p) {
X			COMPUTE(crc, *p);
X			COMPUTE(crc_total, *p);
X		}
X	if (nr < 0)
X		return (-1);
X
X	/* Include the length of the file. */
X	for (; len != 0; len >>= 8) {
X		COMPUTE(crc, len & 0xff);
X		COMPUTE(crc_total, len & 0xff);
X	}
X
X	/*
X	*cval = ~crc;
X	*/
X	crc_total = ~crc_total;
X
X	/* output in ascii */
X	if (printhex)
X	    sprintf(ps_signature, "%08lx", crc);
X	else {
X	    unsigned long l = crc;
X	    sprintf(ps_signature, "%6s", pltob64(&l, scratch, 1));
X	}
X
X	return (0);
X}
END_OF_FILE
if test 6928 -ne `wc -c <'tripwire-1.1/sigs/crc32/crc32.c'`; then
    echo shar: \"'tripwire-1.1/sigs/crc32/crc32.c'\" unpacked with wrong size!
fi
# end of 'tripwire-1.1/sigs/crc32/crc32.c'
fi
echo shar: End of archive 20 \(of 25\).
cp /dev/null ark20isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    echo "Now read tripwire-1.1/README.kits"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
