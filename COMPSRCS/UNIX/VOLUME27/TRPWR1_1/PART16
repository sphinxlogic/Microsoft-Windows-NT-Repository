Newsgroups: comp.sources.unix
From: spaf@cs.purdue.edu (Gene Spafford)
Subject: v27i162: tripwire-1.1 - security integrity monitor, V1.1, Part16/26
References: <1.756157401.21864@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: spaf@cs.purdue.edu (Gene Spafford)
Posting-Number: Volume 27, Issue 162
Archive-Name: tripwire-1.1/part16

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 16 (of 25)."
# Contents:  tripwire-1.1 tripwire-1.1/sigs tripwire-1.1/sigs/crc32
#   tripwire-1.1/src tripwire-1.1/src/preen.c tripwire-1.1/src/utils.c
#   tripwire-1.1/sigs/crc32/crc32.h
# Wrapped by spaf@uther.cs.purdue.edu on Thu Dec 16 11:42:45 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test ! -d 'tripwire-1.1' ; then
    echo shar: Creating directory \"'tripwire-1.1'\"
    mkdir 'tripwire-1.1'
fi
if test ! -d 'tripwire-1.1/sigs' ; then
    echo shar: Creating directory \"'tripwire-1.1/sigs'\"
    mkdir 'tripwire-1.1/sigs'
fi
if test ! -d 'tripwire-1.1/sigs/crc32' ; then
    echo shar: Creating directory \"'tripwire-1.1/sigs/crc32'\"
    mkdir 'tripwire-1.1/sigs/crc32'
fi
if test ! -d 'tripwire-1.1/src' ; then
    echo shar: Creating directory \"'tripwire-1.1/src'\"
    mkdir 'tripwire-1.1/src'
fi
if test -f 'tripwire-1.1/src/preen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tripwire-1.1/src/preen.c'\"
else
echo shar: Extracting \"'tripwire-1.1/src/preen.c'\" \(18680 characters\)
sed "s/^X//" >'tripwire-1.1/src/preen.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char rcsid[] = "$Id: preen.c,v 1.24 1993/12/15 16:50:20 genek Exp $";
X#endif
X
X/*
X * preen.c
X *
X *	preen the filesystems in preen.config against the data stored in
X *	in preen.database.
X *
X * Gene Kim
X * Purdue University
X */
X
X#include "../include/config.h"
X#include <stdio.h>
X#ifdef STDLIBH
X#include <stdlib.h>
X#include <unistd.h>
X#endif
X#include <sys/param.h>
X#ifdef STRINGH
X#include <string.h>
X#else
X#include <strings.h>
X#endif
X#include <sys/types.h>
X#include <sys/stat.h>
X#if (defined(SYSV) && (SYSV < 3))
X# include <limits.h>
X#endif	/* SVR2 */
X#include <assert.h>
X#include "../include/list.h"
X#include "../include/tripwire.h"
X
Xstatic struct list *newdbase_list = NULL;
Xstatic int numentriesread = 0;		/* running count of @@contents */
X
X/* prototypes */
Xchar *mktemp();
Xstatic void olddbasefile_load();
X
Xchar *updatemodes[] = {
X	"invalid update",
X	"add file",
X	"delete file", 
X	"update file",
X	"entry not found",
X	"add entry",
X	"delete entry",
X	"update entry",
X};
X
X/*
X * update_gather()
X *
X *	routine that calls all the other functions for preening
X *	in interactive mode.  (this is a wrapper around the functions
X *	of integrity checking mode and then update.)
X */
X
Xvoid
Xupdate_gather(interactive, ppp_updateentries)
X    int interactive;
X    char ***ppp_updateentries;
X{
X    FILE *fp_in;
X    struct list *configentry_list = (struct list *) NULL;
X
X    SPDEBUG(3) printf("*** entering update_gather()\n");
X
X    /* build the filelist (newdbase_list) from the preen.config file
X     * 		it will create the linked list of files
X     */
X    configfile_read(&newdbase_list, &configentry_list);
X
X    /* if we're simply using as a preprocessor, then quit */
X    if (printpreprocess)
X	exit(0);
X
X    /* preen ourselves:
X     * 		build a temporary database, then check for diffs
X     */
X    database_build(&newdbase_list, DBASE_TEMPORARY, &configentry_list);
X
X    /* read in the old database */
X    olddbasefile_load(&configentry_list);
X
X    /* database_build() rewound the descriptor, so it's ready to use */
X    fp_in = fptempdbase;
X
X    /* build the diff_xxx_lists of ADDED, CHANGED, DELETED */
X    preen_interp(fp_in);
X
X    /* now build the report */
X    preen_report(interactive, ppp_updateentries);
X    (void) fclose(fp_in);
X
X    /* remove the temporary database file */
X    (void) unlink(tempdatabase_file);
X
X    SPDEBUG(3) printf("*** leaving update_gather()\n");
X
X    list_reset(&configentry_list);
X
X    free(configentry_list);
X
X
X    return;
X}
X
X/*
X * update_mark(char **ppentries, int numentries)
X *
X *	build the filelist (newdbase_list) from tw.config file.
X *	check if each (updateentry) in the (ppentries) vector is an entry
X *		if it is, update all entries with the same entrynum
X *		else if (updateentry) exists
X *			if so, update, w/same entrynum
X *			else append to database, w/entrynum = -1
X */
X
Xvoid
Xupdate_mark(ppentries, numentries)
X    char **ppentries;
X    int numentries;
X{
X    struct list *configentry_list = (struct list *) NULL;
X    char *entry;
X    int i, numskipped = 0;		/* number of entries not found */
X
X    /* build the filelist (newdbase_list) from the tw.config file
X     * 		it will create the linked list of files
X     */
X
X    list_reset(&newdbase_list);
X    list_reset(&configentry_list);
X
X    assert(!newdbase_list);
X    assert(!configentry_list);
X    assert(!olddbase_list);
X
X    configfile_read(&newdbase_list, &configentry_list);
X
X    /* read in the old database */
X    olddbasefile_load(&configentry_list);
X
XSPDEBUG(20) {
Xprintf("===== configentry_list ===\n");
Xlist_print(&configentry_list);
Xprintf("===== newdbase_list ===\n");
Xlist_print(&newdbase_list);
Xprintf("===== olddbase_list ===\n");
Xlist_print(&olddbase_list);
X}
X
X
X    /* iterate through the entries */
X    for (i = 0; i < numentries; i++) {
X
X	char eentry[2048];		/* entry filename with escapes */
X	int isentry, isold, isnew;
X	int whichcase;
X
X	entry = ppentries[i];
X    	/* check to see if filename is fully-qualified! */
X	if (entry[0] != '/') {
X	    fprintf(stderr, 
X"%s: file '%s' is not fully qualified!  Skipping...\n", progname, entry);
X	    numskipped++;
X	    continue;
X	}
X
X	/*
X	 *			tw.config	old dbase	new dbase
X	 *			=========	========	========
X	 *		0.	-		-		-
X	 *		1.	-		-		y
X	 *		2.	-		y		-
X	 *		3.	-		y		y
X	 *		4.	y		-		-
X	 *		5.	y		-		y
X	 *		6.	y		y		-
X	 *		7.	y		y		y
X	 *
X	 *
X	 *	(0) xxx -- can't happen
X	 *		skip, invalid filename
X	 *
X	 *	(1) add file -- adds the single file to the database
X	 *	(what contents number do we give it?  what ignore flags?)
X	 *
X	 *	(2) delete file -- removes the single file from the database.
X	 *
X	 *	(3) update file -- updates the single file in the database.
X	 *		(inherit new ignore mask)
X	 *
X	 *	(4) xxx -- the entry doesn't resolve to any files on the system.
X	 *		(no change)
X	 *
X	 *	(5) add entry -- recurses down the specified entry and adds all
X	 *		the resulting files to the database.
X	 *		(ignore mask comes from "closest" tw.config entry)
X	 *
X	 *	(6) delete entry -- the files disappeared since the last 
X	 *		dbase snapshot so, delete the entire entry
X	 *
X	 *	(7) update entry -- recurses down the specified entry and 
X	 *		updates all those entries in the database
X	 *		(inherit new ignore mask)
X    	 */
X
X	strcpy(eentry, filename_escape(entry));
X
X	isentry = list_isthere(entry, &configentry_list);
X	isnew = list_isthere(entry, &newdbase_list);
X	isold = list_isthere(eentry, &olddbase_list);
X
X	/* our case number is the vector of true/false bits */
X	whichcase = (isentry << 2) | (isold << 1) | (isnew);
X	if (!quietmode) { 
X	    fprintf(stderr, "Updating: %s: %s\n", updatemodes[whichcase], 
X		    entry); 
X	}
X
X	switch(whichcase) {
X	case UPDATE_INVALID:
X	case UPDATE_NOTFOUND:
X	    if (!quietmode) {
X	    fprintf(stderr, "update: %s: invalid entry!  skipping...\n",
X				entry);
X	    }
X	    continue;
X	case UPDATE_ADDFILE:
X	{
X	    char entry_ignorevec[64]; 
X	    char number[64];
X	    char ignorestring[64];
X	    char *pc;
X	    int entrynum;
X	    char entryname[1024];
X
X	    if (verbosity)
X		fprintf(stderr, "Adding file %s\n", entry);
X
X	    dbase_entry_howclose(entry, &configentry_list, entryname, 
X		&entrynum);
X
X	    /* we use the default ignore-string.  XXX.  Must be definable */
X	    if (!(pc = list_lookup(entry, &newdbase_list))) {
X		strcpy(ignorestring, defaultignore);
X		ignore_configvec_to_dvec(ignorestring);
X	    } else {
X		char tmpignore[64];
X		int j, err;
X
X		if ((err = sscanf(pc, "%d %s", &j, tmpignore)) != 2) {
X		fprintf(stderr, "update_mark: newdbase_list parse error (nfields=%d, %s:%d)!\n", err, __FILE__, __LINE__);
X		    fprintf(stderr, "%s>> %s\n", entry, pc);
X		    exit(1);
X		}
X
X		strcpy(ignorestring, tmpignore);
X	    }
X
X	    sprintf(entry_ignorevec, "%d %s", entrynum, ignorestring);
X	    list_set(eentry, entry_ignorevec, 0, &olddbase_list);
X	    list_setflag(eentry, FLAG_UPDATE, &olddbase_list);
X
X	}
X	    break;
X	case UPDATE_DELETEFILE:
X	    if (verbosity)
X		fprintf(stderr, "Deleting file %s\n", entry);
X	    list_unset(eentry, &olddbase_list);
X	    break;
X	case UPDATE_UPDATEFILE:
X	{
X	    char oldignore[64], newignore[64], *pc, 
X			oldrest[1024], newrest[1024];
X	    char newvalue[1024];
X	    int err, newentry, oldentry;
X
X	    if (verbosity)
X		fprintf(stderr, "Updating file %s\n", entry);
X
X	    /* we know that the entry exists the the new dbaselist, otherwise,
X	     * we couldn't be in this case!
X	     */
X
X	    pc = list_lookup(entry, &newdbase_list);
X	    assert(pc != NULL);
X
X	    /* parse the new dbase entry */
X	    if ((err = sscanf(pc, "%d %s", &newentry, newignore)) != 2) {
X		fprintf(stderr, "update_mark: newdbase_list parse error (nfields=%d, %s:%d)!\n", err, __FILE__, __LINE__);
X		fprintf(stderr, "%s>> %s\n", entry, pc);
X		exit(1);
X	    }
X
X	    /* parse the old dbase entry */
X	    pc = list_lookup(eentry, &olddbase_list);
X	    assert(pc != NULL);
X
X	    /* parse the old dbase entry */
X	    if ((err = sscanf(pc, "%d %s %[^\n]", &oldentry, oldignore, 
X			oldrest)) != 3) {
X		if (list_getflag(entry, &olddbase_list) & 
X				    FLAG_UPDATE) {
X		    SPDEBUG(3) printf("\t(it's already a newly file...)\n");
X		    break;
X		}
X		fprintf(stderr, "update_mark: olddbase_list parse error (nfields=%d, %s:%d)!\n", err, __FILE__, __LINE__);
X		fprintf(stderr, "%s>> %s\n", eentry, pc);
X		exit(1);
X	    }
X
X	    /* splice the new ignore flag into the old dbase list */
X	    sprintf(newvalue, "%d %s %s\n", oldentry, newignore, oldrest);
X
X	    /* check to make sure we're not overflowing bounds */
X	    /*	why?  the ignore mask is the only thing that changed,
X	     * 	so the length of the entire string should also remain
X	     * 	unchanged.
X	     */
X	    assert(strlen(newvalue) == strlen(pc));
X
X	    list_set(eentry, newvalue, 0, &olddbase_list);
X	    list_setflag(eentry, FLAG_UPDATE, &olddbase_list);
X	}
X	    break;
X	case UPDATE_ADDENTRY:
X	{
X	    struct list_elem *p;
X	    int entrynum;
X	    char ignorevec[128];
X	    int number;
X	    char *pc;
X	    int err;
X
X	    if (verbosity)
X		fprintf(stderr, "Adding entry %s\n", entry);
X
X	    if (!(pc = list_lookup(entry, &configentry_list))) {
X		fprintf(stderr, "%s: Can't find entry '%s'.  Skipping...\n",
X			progname, entry);
X		continue;
X	    }
X	    if ((err = sscanf(pc, "%d %s", &number, ignorevec)) != 2) {
X		fprintf(stderr, "update_mark: configentry_list parse error (nfields=%d, %s:%d)!\n", err, __FILE__, __LINE__);
X		    fprintf(stderr, "%s>> %s\n", entry, pc);
X		    exit(1);
X	    }
X
X	    list_open(&newdbase_list);
X	    while ((p = list_get(&newdbase_list))) {
X		int thisentry;
X		char escapedname[2048];
X
X		/* escape the name before inserting in olddbase_list */
X		strcpy(escapedname, filename_escape(p->varname));
X
X		if (sscanf(p->varvalue, "%d", &thisentry) != 1) {
X		    fprintf(stderr, "update_mark: newdbase_list parse error (nfields=%d, %s:%d)!\n", err, __FILE__, __LINE__);
X		    fprintf(stderr, "%s>> %s\n", p->varname, p->varvalue);
X		    exit(1);
X		}
X		/* does it match the entry we're adding? */
X		if (thisentry == number) {
X		    SPDEBUG(6) { printf("--(adding entry)--> %s\n", 
X			p->varname); }
X		    list_set(escapedname, p->varvalue, 0, &olddbase_list);
X		    list_setflag(escapedname, FLAG_UPDATE, &olddbase_list);
X		}
X	    }
X	    list_close(&olddbase_list);
X	}
X	    break;
X	case UPDATE_DELETEENTRY:
X	case UPDATE_UPDATEENTRY:
X	    if (verbosity) {
X		switch(whichcase) {
X		case UPDATE_DELETEENTRY:
X		    fprintf(stderr, "Deleting entry %s\n", entry);
X		    break;
X		case UPDATE_UPDATEENTRY:
X		    fprintf(stderr, "Updating entry %s\n", entry);
X		break;
X		}
X	    }
X	{
X	    struct list_elem *p, *q = (struct list_elem *) NULL;
X	    char s[2048];
X	    int entrynum;
X	    char newignore[1024];
X	    int err;
X
X	    /* get entry number and new ignore mask */
X	    (void) strcpy(s, list_lookup(entry, &configentry_list));
X	    if ((err = sscanf(s, "%d %s", &entrynum, newignore)) != 2) {
X		fprintf(stderr, "update_mark: configentry_list parse error (nfields=%d, %s:%d)!\n", err, __FILE__, __LINE__);
X		fprintf(stderr, "%s>> %s\n", entry, s);
X		exit(1);
X	    }
X
X	    /* we're updating entries */
X	    if (whichcase == UPDATE_UPDATEENTRY) {
X		dbase_entry_flag(&olddbase_list, entrynum, FLAG_UPDATE, 
X			(char *) newignore);
X	    }
X	    /* else we're deleting entries */
X	    else {
X		int flags;
X
X		dbase_entry_flag(&olddbase_list, entrynum, FLAG_DELETE, NULL);
X		SPDEBUG(20) list_print(&olddbase_list);
X
X		list_open(&olddbase_list);
X		while (p = list_get(&olddbase_list)) {
X		    if (q) {
X			list_unset(q->varname, &olddbase_list);
X			q = (struct list_elem *) NULL;
X		    }
X		    if ((flags = list_getflag(p->varname, &olddbase_list)) 
X					& FLAG_DELETE) {
X			q = p;
X		    }
X		}
X		if (q) {
X		    list_unset(q->varname, &olddbase_list);
X		    q = (struct list_elem *) NULL;
X		}
X		    
X		list_close(&olddbase_list);
X		list_unset(entry, &configentry_list);
X		SPDEBUG(20) { list_print(&configentry_list); }
X	    }
X	}
X	    break;
X	default:
X	    fprintf(stderr, "update_mark: invalid case %d!\n", whichcase);
X	    exit(1);
X	}
X
X    }
X    
X    /* did we skip all the files, thus a no-op? */
X    if (numskipped == numentries) {
X        printf("%s: No updated entries.  Database remains unchanged.\n",
X			progname);
X	exit(1);
X    }
X
X    /* we used to print the backup warning banner here -- now it's in 
X     * dbase.build.c 
X     */
X
X    /* preen ourselves:
X     * 		build a temporary database, then check for diffs
X     */
X    database_build(&olddbase_list, DBASE_UPDATE, &configentry_list);
X
X    return;
X}
X
X/*
X * void
X * olddbasefile_load(ppentrylist)
X *
X *	load in the old database file into the global list (olddbase_list).
X *	(ppentrylist) is the list of entries.
X */
X
Xstatic void
Xolddbasefile_load(ppentrylist)
X    struct list **ppentrylist;
X{
X    char filename[MAXPATHLEN+256];
X    FILE *fp;
X    char s[MAXPATHLEN+512];
X    char key[MAXPATHLEN+256], value[512];
X    static struct list *replace_list = (struct list *) NULL;
X
X    SPDEBUG(3) printf("*** entering olddbasefile_load()\n");
X
X    if (specified_dbasefile == NULL)
X	sprintf(filename, "%s/%s", database_path, database_file);
X    else
X	(void) strcpy(filename, specified_dbasefile);
X
X    /* check if we are to read from stdin */
X    if (strcmp(filename, "-") == 0) {
X	fp = stdin;
X    }
X    /* else open the file */
X    else {
X	if ((fp = fopen(filename, "r")) == NULL)
X	    die_with_err("%s: Couldn't open database file '%s'",
X			    filename);
X    }
X
X    /* first make sure that none of the entry numbers changed */
X    while (fgets(s, sizeof(s), fp) != NULL) {
X	char entryname[2048], *pc;
X	int oldentrynum, newentrynum;
X	char tmp[128];
X	static int countlines;
X
X	countlines++;
X	if (string_split_space(s, key, value) < 0) {
X	    fprintf(stderr, 
X		"%s: database='%s': parse error: space not found in line %d!\n",
X		progname, filename, countlines);
X	    exit(1);
X	}
X
X	/* build table of contents */
X	if (strcmp(key, "@@contents") != 0) {
X	    continue;
X	}
X
X	/* check to see if entrynums match */
X	if (sscanf(value, "%s %d", entryname, &oldentrynum) != 2) {
X	    fprintf(stderr, 
X		"olddbasefile_load: parse error at %s: %d\n>>%s", __FILE__,
X		__LINE__, s);
X	    exit(1);
X	}
X	if (!list_isthere(entryname, ppentrylist))
X	    continue;
X	pc = list_lookup(entryname, ppentrylist);
X	newentrynum = atoi(pc);
X
X	/* if discrepency, then store in replace_list */
X	if (oldentrynum != newentrynum) {
X	    char oldent[100], newent[100];
X	    /* gotta do some chopping up of the contents information */
X	    sprintf(oldent, "%d", oldentrynum);
X	    sprintf(newent, "%d", newentrynum);
X	    list_set(oldent, newent, 0, &replace_list);
X	}
X    }
X
X    rewind(fp);
X
X    /* read in entire file */
X    while (fgets(s, sizeof(s), fp) != NULL) {
X    	static int countlines = 0;
X
X	countlines++;
X
X	/* skip comments */
X	if (s[0] == '#')
X	    continue;
X	
X	if (string_split_space(s, key, value) < 0) {
X	    fprintf(stderr, 
X		"%s: database='%s': parse error: space not found in line %d!\n",
X		progname, filename, countlines);
X	    exit(1);
X	}
X
X	/* build table of contents */
X	if (strcmp(key, "@@contents") == 0) {
X	    numentriesread++;
X	    continue;
X	}
X	/* skip database version */
X	else if (strcmp(key, "@@dbaseversion") == 0) {
X	    int version, err;
X	    char trash[1024];
X	    if ((err = sscanf(value, "%d", &version)) != 1) {
X		fprintf(stderr, "olddbasefile_load: @@dbaseversion parse error (nfields=%d, %s:%d)!\n", err, __FILE__, __LINE__);
X		    fprintf(stderr, ">> %s\n", key);
X		    exit(1);
X	    }
X
X	    if (version != DB_VERSION_NUM) {
X		fprintf(stderr,
X"error: %s: version error\n", filename);
X		fprintf(stderr,
X"\tdatabase format %d is no longer supported (expecting %d)!\n",
X			version, db_version_num);
X		fprintf(stderr,
X"\tSee tw.config(5) manual page for details\n");
X		exit(1);
X	    }
X	    continue;
X	}
X	/* else it's a file */
X	else {
X	    int mode;
X	    char pcentry[512], pcignore[512], pcrest[1024];
X	    char newvalue[1024];
X	    int err;
X
XSPDEBUG(10)
Xprintf("olddbasefile_load: %s: %s", key, value);
X
X	    /* check to see if it's a special file */
X	    if ((err = sscanf(value, "%s %s %o %[^\n]", pcentry, pcignore, &mode,
X			pcrest)) != 4) {
X		fprintf(stderr, "olddbasefile_load: parse error (nfields=%d)!", 
X				err);
X		fprintf(stderr, ">> %s", value);
X		exit(1);
X	    }
X
X	    /* do we need to replace the entry number? */
X	    if (list_isthere(pcentry, &replace_list)) {
X		char tmp[100];
X		/* splice the new value in */
X		sprintf(newvalue, "%s %s %o %s\n", 
X		    list_lookup(pcentry, &replace_list), 
X		    pcignore, mode, pcrest);
X		list_set(key, newvalue, 0, &olddbase_list);
X	    }
X	    /* otherwise the entry number was fine */
X	    else {
X		list_set(key, value, 0, &olddbase_list);
X	    }
X
X	    switch (mode & S_IFMT) {
X	      case S_IFIFO:
X	      case S_IFCHR:
X	      case S_IFDIR:
X	      case S_IFBLK:
X#if !defined(SYSV) || (SYSV > 3)
X	      case S_IFSOCK:
X	      case S_IFLNK:
X#endif
X		(void) list_setflag(key, FLAG_NOOPEN, &olddbase_list);
X	    }
X
X	}
X    }
X
X    /* close the file descriptor */
X    if (fp != stdin) {
X	(void) fclose(fp);
X    }
X
X    SPDEBUG(3) printf("*** leaving olddbasefile_load()\n");
X
X    list_reset(&replace_list);
X
X    return;
X}
X
X/*
X * dbase_entry_closest()
X *
X * 	given a (filename), choose the "closest" entry in the tw.config
X *	file.
X *
X *		Ex: 	filename = "/etc/foo/bar"
X *
X *		entry:		score:
X *		/etc		1
X *		/etc/foo	2
X *		/etc/foo/bar	3
X *
X */
X
Xvoid
Xdbase_entry_howclose(filename, ppentrylist, entry, pentrynum)
X    char *filename;
X    struct list **ppentrylist;
X    char *entry;
X    int *pentrynum;
X{
X    struct list_elem *p;
X    int maxscore = 0, maxentrynum;
X
X    if (list_open(ppentrylist) < 0) {
X	fprintf(stderr, "%s: dbase_entry_howclose: list_open() failed!\n",
X		progname);
X	exit(1);
X    }
X
X    while ((p = list_get(ppentrylist))) {
X	char *p1, *p2;
X	int score = 0;
X	char trash[1024];
X	int entrynum = 0;
X	char *pold;
X
X	p1 = p->varname;
X	p2 = filename;
X
X	/* walk through the filenames */
X	for (; *p1 && *p2; p1++, p2++) {
X	    if (*p1 != *p2)
X		break;
X	    if (*p2 == '/')		/* increment score */
X		score++;
X	}
X	/* correct score if comparison failed */
X	if ((p1 != p->varname) && *(p1-1) == '/')
X	    score--;
X
XSPDEBUG(6) 
Xprintf("dbase_entry_howclose: %d: (%s,%s)\n", score, filename, p->varname);
X
X	if (score > maxscore) {
X	    maxscore = score;
X	    maxentrynum = entrynum;
X	    strcpy(entry, p->varname);
X	    /* grab the entry number */
X	    if ((pold = list_lookup(p->varname, &olddbase_list))) {
X		if (sscanf(pold, "%d %s", &entrynum, trash) != 2) {
X		   die_with_err("dbase_entry_howclose: sscanf() parsing error!\n",
X							(char *) NULL);
X		}
X	    }
X	    *pentrynum = entrynum;
X	}
X    }
X
X    if (list_close(ppentrylist) < 0) {
X	fprintf(stderr, "%s: dbase_entry_howclose: list_close() failed!\n",
X		progname);
X	exit(1);
X    }
X
XSPDEBUG(6) 
Xprintf("dbase_entry_howclose: ancestor: %s\n", entry);
X
X}
X
END_OF_FILE
if test 18680 -ne `wc -c <'tripwire-1.1/src/preen.c'`; then
    echo shar: \"'tripwire-1.1/src/preen.c'\" unpacked with wrong size!
fi
# end of 'tripwire-1.1/src/preen.c'
fi
if test -f 'tripwire-1.1/src/utils.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tripwire-1.1/src/utils.c'\"
else
echo shar: Extracting \"'tripwire-1.1/src/utils.c'\" \(16201 characters\)
sed "s/^X//" >'tripwire-1.1/src/utils.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char rcsid[] = "$Id: utils.c,v 1.14 1993/12/15 16:58:28 genek Exp $";
X#endif
X
X/*
X * utils.c
X *
X *	miscellaneous utilities for Tripwire
X *
X * Gene Kim
X * Purdue University
X */
X
X#include "../include/config.h"
X#include "../include/byteorder.h"
X#include <stdio.h>
X#include <assert.h>
X#ifdef STDLIBH
X#include <stdlib.h>
X#endif
X#include <ctype.h>
X#ifdef STRINGH
X#include <string.h>
X#else
X#include <strings.h>
X# if (!defined(strchr) && !defined(index))
X#  define strchr(s, c) index(s, c)
X# endif
X# if (!defined(memcpy) && !defined(bcopy))
X#  define memcpy(to, from, n) bcopy(from, to, n)
X# endif
X#endif
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <pwd.h>
X#include <grp.h>
X#include <sys/param.h>
X#include <ctype.h>
X#include <sys/param.h>
X#ifndef MAXHOSTNAMELEN
X#define MAXHOSTNAMELEN 64
X#endif
X#ifndef XENIX
X# include <sys/time.h>
X#else
X# include <time.h>
X#endif 	/* XENIX */
X#ifndef GETHOSTNAME
X# include <sys/utsname.h>
X#endif
X#if (defined(SYSV) && (SYSV < 3))
X# include <limits.h>
X#endif	/* SVR2 */
X#include "../include/list.h"
X#include "../include/tripwire.h"
X
Xstatic void print_perm();
X
X#ifndef S_IRGRP
X#define S_IRGRP	(S_IREAD >> 3)
X#define S_IWGRP (S_IWRITE >> 3)
X#define S_IXGRP (S_IEXEC >> 3)
X#define S_IROTH (S_IREAD >> 6)
X#define S_IWOTH (S_IWRITE >> 6)
X#define S_IXOTH (S_IEXEC >> 6)
X#endif
X
Xvoid warn_with_err(format, name)
X   char *format, *name;
X{
X    extern int  errno;
X    int real_errno = errno;
X    char *string;
X
X    if (!name)
X      string = format;
X    else {
X	string = (char *) malloc((unsigned) (strlen(format)+strlen(name)+1));
X	if (!string) {
X	    fputs("Unexpected malloc() failure in 'warn_with_err'!\n", stderr);
X	    exit(-1);
X	}
X	sprintf(string, format, name);
X	errno = real_errno;
X    }
X
X    perror(string);
X}
X
Xvoid
Xdie_with_err(format, name)
X    char *format, *name;
X{
X    warn_with_err(format, name);
X    exit(1);
X}
X
X/*
X * filename_hostname_expand(char **ps)
X *
X *	expand any '@'s in the specified string to the hostname.
X *
X *	Ex:   "xxx_@_xxx"  ---> "xxx_mentor.cc.purdue.edu_xxx"
X */
X
Xstatic char hostname[MAXHOSTNAMELEN];
X
Xvoid
Xfilename_hostname_expand(ps)
X    char **ps;
X{
X    char *s = *ps;
X    char outpath[MAXPATHLEN+256];
X    char *pc;
X
X    if (! *hostname) {   /* we only need to do this once */
X#ifndef GETHOSTNAME
X    struct utsname sysinfo;
X
X    if (uname(&sysinfo) < 0)
X	die_with_err("filename_hostname_expand: uname()", (char *) NULL);
X
X    (void) strcpy(hostname, sysinfo.nodename);
X
X#else 	/* GETHOSTNAME */
X
X    /* get the hostname */
X    if (gethostname(hostname, sizeof(hostname)) < 0)
X	die_with_err("filename_hostname_expand: gethostname()", (char *) NULL);
X
X#endif 	/* GETHOSTNAME */
X    }
X
X    /* is there a '@' in the filename? */
X    if ((pc = strchr(s, '@')) == NULL) {
X	return;
X    }
X
X    /* copy the first part of the string */
X    (void) strncpy(outpath, s, pc-s);
X
X    /* strncpy() doesn't guarantee null-terminated strings! */
X    outpath[pc-s] = '\0';
X
X    /* expand the '@' and copy the rest of the string */
X    (void) strcat(outpath, hostname);
X    (void) strcat(outpath, pc+1);
X
X    /* make our pointer point to the expanded string */
X    if ((pc = (char *) malloc((unsigned int) (strlen(outpath) + 1))) == NULL)
X	die_with_err("filename_hostname_expand: malloc()", (char *) NULL);
X
X    (void) strcpy(pc, outpath);
X
X    *ps = pc;
X
X    return;
X}
X
X/*
X * slash_count(char *pathname)
X *
X *	count the number of slashes in a given pathname.  This is used
X * 	to determine the priority of a given file entry when generating
X * 	the list of files.
X */
X
Xint
Xslash_count (pathname)
X    char *pathname;
X{
X	register int count = 0;
X	register char *pc;
X
X	for (pc = pathname; *pc; pc++ )
X		if (*pc == '/')
X			count++;
X	return count;
X}
X
X/*
X * string_split_space(char *string, char *s, char *t)
X *
X * 	given (string), place the first word into (s), and the rest of
X *	into (t).
X *
X *	returns zero on success, -1 on failure.
X */
X
Xint
Xstring_split_space (string, s, t)
X    char *string;
X    char *s;
X    char *t;
X{
X    char *sp;
X
X    /*
X     * (char *sp) = the first space.  	s = {string[0..(sp-s-1)]}
X     *			      		t = {sp[1..end]}
X     */
X
X    if ((sp = strchr(string, ' ')) == NULL) {
XSPDEBUG(10) 
Xfprintf(stderr, "string_split_space: string doesn't contain space!\n");
X	return -1;
X    }
X
X    /* don't forget to null-terminate the string w/strncpy() */
X    (void) strncpy(s, string, sp-string);
X    s[sp-string] = '\0';
X
X    (void) strcpy(t, sp+1);
X    return 0;
X}
X
X/*
X * int
X * string_split_ch(char *string, char *s, char *t, char ch)
X *
X * 	given (string), place the first word into (s), and the rest of
X *	into (t), using (ch) as the field separator.  (ala perl).
X */
X
Xint
Xstring_split_ch (string, s, t, ch)
X    char *string;
X    char *s;
X    char *t;
X    char ch;
X{
X    char *sp;
X
X    /*
X     * (char *sp) = the first space.  	s = {string[0..(sp-s-1)]}
X     *			      		t = {sp[1..end]}
X     */
X
X    if ((sp = strchr(string, ch)) == NULL) {
X	(void) strcpy(s, string);
X	t[0] = '\0';
X	return -1;
X    }
X
X    /* don't forget to null-terminate the string w/strncpy() */
X    (void) strncpy(s, string, sp-string);
X    s[sp-string] = '\0';
X
X    (void) strcpy(t, sp+1);
X    return 0;
X}
X
X/*
X * chop (char *s)
X *
X *	chop off the last character in a string, ala Perl.
X */
X
Xvoid
Xchop (s)
X    char *s;
X{
X	int slen;
X
X	slen = strlen(s);
X	s[slen-1] = '\0';
X	return;
X}
X
X/*
X * filename_escape_expand(char *filename)
X *
X *	expand \xxx octal characters, metachacters, and known
X *	C escape sequences.
X */
X
Xvoid
Xfilename_escape_expand (filename)
X    char *filename;
X{
X    int i = 0;
X    char filetmp[MAXPATHLEN+256];
X    int octal;
X    register char *pcin = filename, *pcout = filetmp;
X
X    /*
X     * case I:	it's not escaped
X     * case II: 	it's a three digit octal number
X     * case III:	it's a standard C escape sequence
X     *				(\n, \r, \', \", \t, \b, \f)
X     *			(from Johnson, Stephen C.,
X     *				"Yacc: Yet Another Compiler-Compiler")
X     * case IV:	it's one of our metacharacters {@#!|&()= }
X     */
X
X    while (*pcin) {
X
X	/* case I: it's not an escape */
X	if (*pcin != '\\') {
X		*pcout++ = *pcin++;
X	}
X
X	/* case II: it's a three digit octal number */
X	else if (isdigit(*++pcin)) {
X	    /* read in the three characters */
X	    for (octal = i = 0; i < 3 ; i++, pcin++) {
X		octal *= 8;
X		
X		if (*pcin > '7' || *pcin < '0') {
X		    fprintf(stderr,
X			    "filename_escape_expand: bogus octal character (%c) in file `%s'!\n",
X			    *pcin, filename);
X		    exit(1);
X		}
X		else
X		  octal += *pcin-'0';
X	    }
X
X	    /* warn of filenames with null's in them */
X	    if (octal == 0) {
X		fprintf(stderr, "tripwire: warning: null character in file `%s'!\n",  filename);
X		exit(1);
X	    }
X
X	    *pcout++ = octal & 0xff;
X	}
X
X	/* case III: it's a standard C escape sequence */
X	/* case IV: it's one of our escape characters */
X	else
X	    switch(*pcin) {
X	    case 'n':		{ *pcout++ = '\n'; break; }
X	    case 'r':		{ *pcout++ = '\r'; break; }
X	    case 't':		{ *pcout++ = '\t'; break; }
X	    case 'b':		{ *pcout++ = '\b'; break; }
X	    case 'f':		{ *pcout++ = '\f'; break; }
X	    case '\'':		
X	    case '"':		
X	    case '@':
X	    case '!':
X	    case '#':
X	    case '=':
X	    case ' ':
X	    case ')':
X	    case '(':
X	    case '&':
X	    case '|':
X	    case '\\':
X	      /* same as our default case... it's the character itself */
X	    default: 		{ *pcout++ = *pcin++; break; }
X	  }
X    }
X
X
X    /* null terminate the string */
X    *pcout++ = '\0';
X
X    (void) memcpy(filename, filetmp, pcout - filetmp);
X    return;
X}
X
X/*
X * char *
X * filename_escape(char *filename)
X *
X *	find any characters that must be escaped in the file name.
X */
X
Xchar *
Xfilename_escape (filename)
X    char *filename;
X{
X    char filetmp[MAXPATHLEN+256];
X    register char *pcin = filename, *pcout = filetmp;
X    static char *octal_array[] = {
X	"000", "001", "002", "003", "004", "005", "006", "007",
X	"010", "011", "012", "013", "014", "015", "016", "017",
X	"020", "021", "022", "023", "024", "025", "026", "027",
X	"030", "031", "032", "033", "034", "035", "036", "037",
X	"040", "041", "042", "043", "044", "045", "046", "047",
X	"050", "051", "052", "053", "054", "055", "056", "057",
X	"060", "061", "062", "063", "064", "065", "066", "067",
X	"070", "071", "072", "073", "074", "075", "076", "077",
X	"100", "101", "102", "103", "104", "105", "106", "107",
X	"110", "111", "112", "113", "114", "115", "116", "117",
X	"120", "121", "122", "123", "124", "125", "126", "127",
X	"130", "131", "132", "133", "134", "135", "136", "137",
X	"140", "141", "142", "143", "144", "145", "146", "147",
X	"150", "151", "152", "153", "154", "155", "156", "157",
X	"160", "161", "162", "163", "164", "165", "166", "167",
X	"170", "171", "172", "173", "174", "175", "176", "177",
X    };
X    register char *pccopy;
X
X    /* these only matter if they are the first character */
X    if (*pcin == '!' || *pcin == '=' || *pcin == '#')	
X	{ *pcout++ = '\\'; *pcout++ = *pcin++; }
X
X    /* these must be replace everywhere in the filename */
X    while (*pcin) {
X	if (isalnum(*pcin))
X	    *pcout++ = *pcin;
X	else
X	    switch(*pcin) {
X	      case '\\':
X	      case '\n':
X	      case '\r':
X	      case '\t':
X	      case '\b':
X	      case '\f':
X	      case '\'':
X	      case '\"':
X	      case '@':
X	      case ' ':
X	      case '(':
X	      case ')':
X	      case '&':
X	      case '|':
X	      case '#':
X		*pcout++ = '\\';
X		*pcout++ = *(pccopy = octal_array[(int)(*pcin)]);
X		*pcout++ = *++pccopy;
X		*pcout++ = *++pccopy;
X		break;
X	    default:
X		*pcout++ = *pcin;
X		break;
X	    }
X	pcin++;
X    }
X
X    /* null terminate the string */
X    *pcout++ = '\0';
X
X    return filetmp;
X}
X
X#define NEWBASE64
X#ifdef NEWBASE64
Xstatic char base64vec[] =
X  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz:.";
X#else
Xstatic char base64vec[] =
X  "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
X#endif
X
X/* pltob64 -- walk through a vector of longs, convert them to 
X *	network byte ordering, and then convert to base 64
X *
X *	this is the preferred interface to btob64.
X */
X
X#define NUMTMPLONGS	1000
Xchar *
Xpltob64(pl, pcout, numlongs)
X    unsigned long *pl;
X    char *pcout;
X    int numlongs;
X{
X    register int i;
X    register unsigned long *plto;
X    unsigned long larray[NUMTMPLONGS];
X    static int n = 0;
X
X    assert(numlongs < NUMTMPLONGS);
X    /* we use our own ntohl() routines, but we have to do it in-place */
X    memcpy((char *) larray, (char *) pl, numlongs*sizeof(unsigned long));
X
X    for (i = 0, plto = larray; i < numlongs; i++) {
X	htonl(*plto++);
X    }
X
X    return btob64((unsigned char *) larray, (char *) pcout, numlongs*sizeof(unsigned long)*8);
X}
X
X/* btob64  -- convert arbitrary bits to base 64 string
X *
X * Input: bit array (represented as u_char array)
X *        number of bits in the array
X *        ptr-to-str for return string val
X *
X *  This is high magic.  Trust me.  --spaf
X */
X
X
Xchar *
Xbtob64(pcbitvec, pcout, numbits)
X    register unsigned char *pcbitvec;
X    register char  *pcout;
X    int numbits;
X{
X    register unsigned int val;
X    register int offset;
X    unsigned char *pcorig = (unsigned char *) pcout;
X
X    assert(sizeof(unsigned char) == 1);	/* everything breaks otherwise */
X    assert(numbits > 0);
X
X    val = *pcbitvec;
X
X    offset = numbits % 6;   /* how many bits initially? */
X    if (offset) 
X    {
X	val >>= (8 - offset);
X	*pcout++ = base64vec[val & 0x1f];
X    }
X
X    for ( numbits -= offset; numbits > 0; offset += 6, numbits -= 6)
X    {
X	val = *pcbitvec;
X	if (offset > 2) 
X	{
X	    offset -= 8;
X	    val <<= 8;
X	    val |= *++pcbitvec;
X	}
X	val >>= (2-offset);
X
X	*pcout++ =  base64vec[val & 0x3f];
X    }
X
X    *pcout = '\0';
X
X    return (char *) pcorig;
X}
X
X#ifdef FOO
Xchar *
Xltob64(num, vec64)
X    register unsigned long num;
X    char *vec64;
X{
X    register char *p1 = vec64;
X    register int i;
X
X
X    /* build lsb -> msb */
X    for (i = 5; i >= 0; i--) {
X        p1[i] = base64vec[num & 0x3f];
X	num >>= 6;
X    }
X
X    vec64[6] = 0;
X
X    return vec64;
X}
X#endif
X
X/*
X * long
X * b64toi(char *vec)
X *
X *	given a base-64 string, convert to a long.
X */
X
Xlong
Xb64tol(vec)
X    char *vec;
X{
X    register char *pc;
X    register long num = 0L;
X
X/* we use a different base-64 vector now to preseve zero's traditional
X * value.
X */
X
X#ifdef NEWBASE64
X    for (pc = vec; *pc; pc++) {
X	num <<= 6;
X	
X	/* 0 - 9 */
X	if (*pc >= '0' && *pc <= '9')
X	  num += (*pc - '0');		/* 0..9 = '0' .. '0' */
X	else if (*pc >= 'A' && *pc <= 'Z')
X	  num += (*pc - 'A' + 10);	/* 10..35 = '65-55' .. '90-55' */
X	else if (*pc >= 'a' && *pc <= 'z')
X	  num += (*pc - 'a' + 36);	/* 36..61 = '97-35' .. '122-61' */
X	else if (*pc == ':')
X	  num += 62;
X	else if (*pc == '.')
X	  num += 63;
X	else {
X	  fprintf(stderr, "b64tol: fatal error: unknown character '%c'.\n",
X		*pc);
X	  exit(1);
X	}
X    }
X
X    return num;
X#else
X    for (pc = vec; *pc; pc++) {
X	num <<= 6;
X	
X	num += *pc;
X	if (*pc <= '9') 	
X	  num -= '.';
X	else if (*pc <= 'Z')
X	  num -= '5';  /* '5' == 'A' - 12 */
X	else
X	  num -= ';';  /* ';' == 'a' - 38 */
X    }
X
X    return num;
X#endif
X}
X
Xlong
Xoldb64tol(vec)
X    char *vec;
X{
X    register char *pc;
X    register long num = 0L;
X
X    for (pc = vec; *pc; pc++) {
X	num <<= 6;
X	
X	num += *pc;
X	if (*pc <= '9') 	
X	  num -= '.';
X	else if (*pc <= 'Z')
X	  num -= '5';  /* '5' == 'A' - 12 */
X	else
X	  num -= ';';  /* ';' == 'a' - 38 */
X    }
X
X    return num;
X}
X
X/*
X * direntry_print(char *name, struct stat stabuf))
X *
X *	print out a pretty directory entry for the specified file
X *
X *	this routine was taken from crc_check.c, written by Jon Zeeff
X *	(zeeff@b-tech.ann-arbor.mi.us)
X *
X *	hacked for use in Tripwire by Gene Kim (genek@mentor.cc.purdue.edu).
X */
X
Xvoid
Xdirentry_print (name, statbuf, mode)
X    char *name;
X    struct stat statbuf;
X    int mode;
X{
X	struct passwd *entry;
X	static char owner[20];
X	char    a_time[50];
X
X	static int prev_uid = -9999;
X
X	switch(mode) {
X	case DIFF_ADDED:
X		printf("added:   "); break;
X	case DIFF_CHANGED:
X		printf("changed: "); break;
X	case DIFF_DELETED:
X		printf("deleted: "); break;
X	}
X
X	if (statbuf.st_uid != prev_uid) {
X		entry = (struct passwd *)getpwuid((int) statbuf.st_uid);
X		if (entry)
X			(void) strcpy(owner, entry->pw_name);
X		else
X			(void) sprintf(owner, "%d", statbuf.st_uid);
X		prev_uid = statbuf.st_uid;
X	}
X	/*
X	if (statbuf.st_gid != prev_gid) {
X		group_entry = getgrgid((int) statbuf.st_gid);
X		if (group_entry)
X			(void) strcpy(group, group_entry->gr_name);
X		else
X			(void) sprintf(group, "%d", statbuf.st_gid);
X		prev_gid = statbuf.st_gid;
X	}
X	*/
X
X	(void) strcpy(a_time, ctime(&statbuf.st_mtime));
X	a_time[24] = '\0';
X
X	print_perm((unsigned long)statbuf.st_mode);
X
X	(void) printf(" %-9.9s %7d %s", owner, statbuf.st_size,
X						a_time + 4);
X	printf(" %s\n", name);
X
X}
X
X/*	
X *	This routine was taken from crc_check.c, written by Jon Zeeff
X *	(zeeff@b-tech.ann-arbor.mi.us)
X *
X *	hacked for use in Tripwire by Gene Kim (genek@mentor.cc.purdue.edu).
X */
X
Xstatic void
Xprint_perm(perm)
X    unsigned long perm;
X{
X
X	char    string[20];
X
X	(void) strcpy(string, "----------");
X
X	switch (perm & S_IFMT) {
X
X	case S_IFDIR:
X		string[0] = 'd';
X		break;
X
X	case S_IFBLK:
X		string[0] = 'b';
X		break;
X
X	case S_IFCHR:
X		string[0] = 'c';
X		break;
X
X	case S_IFIFO:
X		string[0] = 'p';
X		break;
X#if !defined(SYSV) || (SYSV > 3)
X	case S_IFLNK:
X		string[0] = 'l';
X#endif
X	}
X	if (perm & S_IREAD)
X		string[1] = 'r';
X	if (perm & S_IWRITE)
X		string[2] = 'w';
X	if (perm & S_ISUID && perm & S_IEXEC)
X		string[3] = 's';
X	else if (perm & S_IEXEC)
X		string[3] = 'x';
X	else if (perm & S_ISUID)
X		string[3] = 'S';
X
X	if (perm & S_IRGRP)
X		string[4] = 'r';
X	if (perm & S_IWGRP)
X		string[5] = 'w';
X	if (perm & S_ISUID && perm & S_IXGRP)
X		string[6] = 's';
X	else if (perm & S_IXGRP)
X		string[6] = 'x';
X	else if (perm & S_ISUID)
X		string[6] = 'l';
X
X	if (perm & S_IROTH)
X		string[7] = 'r';
X	if (perm & S_IWOTH)
X		string[8] = 'w';
X	if (perm & S_ISVTX && perm & S_IXOTH)
X		string[9] = 't';
X	else if (perm & S_IXOTH)
X		string[9] = 'x';
X	else if (perm & S_ISVTX)
X		string[9] = 'T';
X
X	(void) printf("%s", string);
X}
X
X#ifdef TEST
Xint debuglevel;
Xmain() {
X    int i;
X    char s[64][1024];
X
X    for (i = 0; i < 64; i++) {
X	ltob64((long) i, s[i]);
X	printf("%d --> %s\n", i, s[i]);
X    }
X
X    for (i = 0; i < 64; i++) {
X	long l;
X	l = b64tol(s[i]);
X	printf("%ld\n", l);
X
X    }
X
X}
X#endif
END_OF_FILE
if test 16201 -ne `wc -c <'tripwire-1.1/src/utils.c'`; then
    echo shar: \"'tripwire-1.1/src/utils.c'\" unpacked with wrong size!
fi
# end of 'tripwire-1.1/src/utils.c'
fi
if test -f 'tripwire-1.1/sigs/crc32/crc32.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tripwire-1.1/sigs/crc32/crc32.h'\"
else
echo shar: Extracting \"'tripwire-1.1/sigs/crc32/crc32.h'\" \(79 characters\)
sed "s/^X//" >'tripwire-1.1/sigs/crc32/crc32.h' <<'END_OF_FILE'
X/* $Id: crc32.h,v 1.2 1993/08/19 05:27:49 genek Exp $ */
X
Xint sig_crc32_get();
END_OF_FILE
if test 79 -ne `wc -c <'tripwire-1.1/sigs/crc32/crc32.h'`; then
    echo shar: \"'tripwire-1.1/sigs/crc32/crc32.h'\" unpacked with wrong size!
fi
# end of 'tripwire-1.1/sigs/crc32/crc32.h'
fi
echo shar: End of archive 16 \(of 25\).
cp /dev/null ark16isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    echo "Now read tripwire-1.1/README.kits"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
