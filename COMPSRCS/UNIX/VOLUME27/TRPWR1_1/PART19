Newsgroups: comp.sources.unix
From: spaf@cs.purdue.edu (Gene Spafford)
Subject: v27i165: tripwire-1.1 - security integrity monitor, V1.1, Part19/26
References: <1.756157401.21864@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: spaf@cs.purdue.edu (Gene Spafford)
Posting-Number: Volume 27, Issue 165
Archive-Name: tripwire-1.1/part19

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 19 (of 25)."
# Contents:  tripwire-1.1 tripwire-1.1/sigs tripwire-1.1/sigs/crc
#   tripwire-1.1/sigs/md5 tripwire-1.1/src tripwire-1.1/tests
#   tripwire-1.1/src/dbase.build.c tripwire-1.1/WHATSNEW
#   tripwire-1.1/sigs/md5/md5.c tripwire-1.1/tests/tw.conf.test
#   tripwire-1.1/sigs/crc/crc.h
# Wrapped by spaf@uther.cs.purdue.edu on Thu Dec 16 11:42:46 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test ! -d 'tripwire-1.1' ; then
    echo shar: Creating directory \"'tripwire-1.1'\"
    mkdir 'tripwire-1.1'
fi
if test ! -d 'tripwire-1.1/sigs' ; then
    echo shar: Creating directory \"'tripwire-1.1/sigs'\"
    mkdir 'tripwire-1.1/sigs'
fi
if test ! -d 'tripwire-1.1/sigs/crc' ; then
    echo shar: Creating directory \"'tripwire-1.1/sigs/crc'\"
    mkdir 'tripwire-1.1/sigs/crc'
fi
if test ! -d 'tripwire-1.1/sigs/md5' ; then
    echo shar: Creating directory \"'tripwire-1.1/sigs/md5'\"
    mkdir 'tripwire-1.1/sigs/md5'
fi
if test ! -d 'tripwire-1.1/src' ; then
    echo shar: Creating directory \"'tripwire-1.1/src'\"
    mkdir 'tripwire-1.1/src'
fi
if test ! -d 'tripwire-1.1/tests' ; then
    echo shar: Creating directory \"'tripwire-1.1/tests'\"
    mkdir 'tripwire-1.1/tests'
fi
if test -f 'tripwire-1.1/src/dbase.build.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tripwire-1.1/src/dbase.build.c'\"
else
echo shar: Extracting \"'tripwire-1.1/src/dbase.build.c'\" \(12312 characters\)
sed "s/^X//" >'tripwire-1.1/src/dbase.build.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char rcsid[] = "$Id: dbase.build.c,v 1.23 1993/12/15 16:58:27 genek Exp $";
X#endif
X
X/*
X * dbase.build.c
X *
X *	build the preen.database file with the list of files that
X *	was generated by config.parse.c
X *
X * Gene Kim
X * Purdue University
X * September 27, 1992
X */
X
X#include "../include/config.h"
X#include <stdio.h>
X#ifdef STDLIBH
X#include <stdlib.h>
X#include <unistd.h>
X#endif
X#include <fcntl.h>
X#include <sys/param.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#ifndef NOGETTIMEOFDAY
X# include <sys/time.h>
X#else
X# include <time.h>
X#endif 	/* NOGETTIMEOFDAY */
X#ifdef DIRENT
X# include <dirent.h>
X#else
X# ifndef XENIX
X#  include <sys/dir.h>
X# else		/* XENIX */
X#  include <sys/ndir.h>
X# endif		/* XENIX */
X#endif	/* DIRENT */
X#if (defined(SYSV) && (SYSV < 3))
X# include <limits.h>
X#endif	/* SVR2 */
X#ifdef STRINGH
X#include <string.h>
X#else
X#include <strings.h>
X#endif
X#include "../include/list.h"
X#include "../include/tripwire.h"
X
X#if defined(SYSV) && (SYSV < 4)
X#ifndef HAVE_LSTAT
X#  define lstat(x,y) stat(x,y)
X#endif
X#endif		/* SYSV */
X
Xint files_scanned_num = 0;
X
X/* prototypes */
Xchar *mktemp();
Xstatic void database_record_write();
X
Xchar backupfile[MAXPATHLEN+256];
X
X/*
X * database_build(struct list **pp_list, int tempdatabaseflag)
X *
X *	take the list of file elements from the list and store all of
X *	the pertinent inode and signature information in the database
X *	file.
X *
X *	if (tempdatabaseflag) is set, then we write to a private file
X *	in the /tmp directory.
X */
X
Xextern int numinterupdated;
X
Xvoid
Xdatabase_build (pp_list, mode, pp_entry_list)
X    struct list **pp_list;
X    int mode;
X    struct list **pp_entry_list;
X{
X    struct list_elem *p_fileentry;
X    struct list_elem *p_configentry;
X    FILE *fpw;
X    char database[MAXPATHLEN+256], olddatabase[MAXPATHLEN+256];
X    int entrynum,
X        oldumask;
X    extern int  errno;
X
X
X#ifndef NOGETTIMEOFDAY
X    struct timezone tzone;
X    struct timeval tval;
X#else
X    long tval;
X#endif	/* XENIX */
X
X    if (!quietmode) {
X	fprintf(stderr, "### Phase 3:   %s file information database\n",
X		mode == DBASE_UPDATE ? "Updating" : "Creating");
X    }
X
X
X    /* create the database file
X     * 		if we are making the permanent database, then we write
X     *		to the specified file.
X     *
X     *		else, we create a temporary file, and save the name of it.
X     */
X
X    /* XXX - we should use open() so we can set the modes */
X
X    oldumask = umask(077);
X
X    if (mode == DBASE_TEMPORARY) {
X	char *tmpfilename = (char *) malloc(strlen(TEMPFILE_TEMPLATE)+1);
X	if (tmpfilename == NULL)
X	    die_with_err("malloc() failed in database_build", (char *) NULL);
X	(void) strcpy(tmpfilename, TEMPFILE_TEMPLATE);
X
X	if ((char *) mktemp(tmpfilename) == NULL)
X	    die_with_err("database_build: mktemp()", (char *) NULL);
X
X	(void) strcpy(tempdatabase_file, tmpfilename);
X	(void) strcpy(database, tempdatabase_file);
X	free(tmpfilename);
X    }					/* end if temporary database */
X    else if (mode == DBASE_UPDATE) {
X	sprintf(database, "./databases/%s", database_file);
X	/* specified file */
X	if (specified_dbasefile) {
X	    strcpy(olddatabase, specified_dbasefile);
X	}
X	/* regular file */
X	else {
X	    sprintf(olddatabase, "%s/%s", database_path, database_file);
X	}
X    }					/* end if update mode */
X    else {			
X	sprintf(database, "%s/%s", database_path, database_file);
X    }					/* end if non-temporary database */
X
X    /* back up any existing database */
X    if (mode == DBASE_UPDATE) {
X	FILE *fpin, *fpout;
X	char backup[MAXPATHLEN+256];
X        register int ctemp;
X
X	/* we hard code this, since we always want the new diretory placed
X	 * relative to our position 
X	 */
X	sprintf(backupfile, "%s.old", database_file);
X
X	/* make sure we stay underneath maximum file length */
X
X	if ((int)(strlen(database_file) + 4) > MAXNAMLEN) {
X
X	    /* tack on .old as well as it fits */
X	    (void) strcpy(backup + (MAXNAMLEN - 4), ".old");
X	}
X	/* so we can reference it later */
X	(void) sprintf(backup, "./databases/%s", backupfile);
X	/* (void) strcpy(backupfile, backup);  strlen(./Databases/) == 12 */
X
XSPDEBUG(3) 
Xprintf("---> olddatabase = (%s)\n", olddatabase);
X
X	if (strcmp(olddatabase, "-") == 0) {
X	    fpin = stdin;
X	}
X	else if ((fpin = fopen(olddatabase, "r")) == NULL) {
X		die_with_err("database_build: Couldn't open database `%s':", 
X			    olddatabase);
X	}
X
X	if ((fpout = fopen(backup, "w")) == NULL)
X	    die_with_err("Couldn't open '%s'!\n", backup);
X
X	/* make the backup file */
X	while ((ctemp = getc(fpin)) != EOF)
X	    putc((char) ctemp, fpout);
X
X	(void) fclose(fpin);
X	(void) fclose(fpout);
X
X	/* print banner (in case user stops program during database update) */
X	if (!quietmode) {
X	    fputs("###\n", stderr);
X	    fprintf(stderr,
X"### Old database file will be moved to `%s'\n", backupfile);
X	    fputs("###            in ./databases.\n", stderr);
X	    fputs("###\n", stderr);
X	    fprintf(stderr, 
X"### Updated database will be stored in '%s'\n", database);
X	    fprintf(stderr,
X"###            (Tripwire expects it to be moved to '%s'.)\n", database_path);
X	    fputs("###\n", stderr);
X
X	}
X    }
X
X    /* rebuild the database */
X    if ((fpw = fopen(database, "w")) == NULL)
X	die_with_err("Hint: Maybe the database directory '%s' doesn't exist?  fopen()", database);
X
X    (void) umask(oldumask);
X
X
X    /* get time information for banner */
X
X#ifndef NOGETTIMEOFDAY
X    if (gettimeofday(&tval, &tzone) < 0)
X        die_with_err("gettimeofday()", (char *) NULL);
X#else
X    tval = time((long *) 0);
X#endif	/* XENIX */
X
X
X    /* add a banner to the top of the database file */
X    /*		note that the newline comes from date  */
X    {
X	char timestring[30];
X	strncpy(timestring, ctime((time_t *)&tval), 26);
X	fprintf(fpw, "# Generated by Tripwire, version %s on %s",
X				    version_num, timestring);
X	fprintf(fpw, "@@dbaseversion %d\n", db_version_num);
X    }
X
X    /* we use &filelist as the key */
X    if (list_open(pp_list) < 0)
X	die_with_err("database_build: list_open() failed!\n", (char *) NULL);
X
X    while ((p_fileentry = list_get(pp_list)) != NULL) {
X
X	struct stat statbuf;
X	char filename[2048], ignorevec[512];
X
X	/* if we're in a debugging mood, print out the entries */
X
XSPDEBUG(10)
Xprintf("--(%3d)--> %s\n", files_scanned_num, p_fileentry->varname);
X
X	/*
X	 * if we're in UPDATE mode, we simply copy entries unless
X	 * FLAG_UPDATE is set.
X	 */
X
X	if (mode == DBASE_UPDATE) {
X	    char s[MAXPATHLEN+256];
X
X	    if (! (list_getflag(p_fileentry->varname, pp_list) & FLAG_UPDATE)) {
X		sprintf(s, "%s %s", p_fileentry->varname,
X						p_fileentry->varvalue);
X		fputs(s, fpw);
X		continue;
X	    }
X	}
X
X	/* get the stat information on it */
X	strcpy(filename, p_fileentry->varname);
X	filename_escape_expand(filename);
X
X	if (sscanf(p_fileentry->varvalue, "%d %s", &entrynum, ignorevec) != 2)
X           die_with_err("database_build: sscanf() parsing error!\n",
X						(char *) NULL);
X
X	if (lstat(filename, &statbuf) < 0) {
X	    if (errno == ENOENT) {
X		fprintf(stderr,
X		    "%s: %s: disappeared.  Skipping...\n", progname, filename);
X		continue;
X	    }
X	    else
X	      die_with_err("database_build: lstat()", filename);
X	}
X
X	/* pick up NO_OPEN flag if we're in UPDATE mode
X	 *
X	 * if it is a special file or device, add it to the list, but
X	 * make sure we don't open it and read from it!
X	 */
X	if (mode == DBASE_UPDATE)
X	    switch (statbuf.st_mode & S_IFMT) {
X	      case S_IFIFO:
X	      case S_IFCHR:
X	      case S_IFDIR:
X	      case S_IFLNK:
X	      case S_IFBLK:
X#if !defined(SYSV) || (SYSV > 3)
X	      case S_IFSOCK:
X#endif
X		(void) list_setflag(filename, FLAG_NOOPEN, pp_list);
X	    }
X
X	database_record_write(fpw, filename, p_fileentry->flag, ignorevec,
X					&statbuf, entrynum);
X
X	files_scanned_num++;
X    }					/* end while list_read() */
X
X    /* cleanup */
X    if (list_close(pp_list) < 0)
X      die_with_err("database_build: list_close() failed!\n", (char *) NULL);
X
X    /* print out table of contents in permanent database */
X    if (mode != DBASE_TEMPORARY) {
X	/* we use &pp_entry_list as the key */
X	if (list_open(pp_entry_list) < 0)
X	  die_with_err("database_build: list_open() failed!\n", (char *) NULL);
X
X	/* print out the contents */
X	while ((p_configentry = list_get(pp_entry_list)) != NULL) {
X	    char entry[2048];
X	    int err;
X	    if ((err = sscanf(p_configentry->varvalue, "%s", entry)) != 1) {
X		fprintf(stderr, "database_build: parse error (nfields=%d)!\n", err);
X		fprintf(stderr, ">> %s\n", p_configentry->varvalue);
X		exit(1);
X
X	    }
X	    /* skip those reverse index entries */
X	    if (p_configentry->flag)
X		continue;
X
X	    fprintf(fpw, "@@contents %s %s\n", p_configentry->varname,
X				entry);
XSPDEBUG(10) 
Xprintf("--(contents)-->%s\n", entry); 
X	}
X
X	/* close the list */
X	if (list_close(pp_entry_list) < 0)
X	  die_with_err("database_build: list_close() failed!\n", (char *) NULL);
X    }
X
X    /* we don't want to allow anyone to spoof the temporary file in /tmp */
X    if (mode == DBASE_TEMPORARY) {
X	if ((fptempdbase = freopen(database, "r", fpw)) == NULL)
X	    die_with_err("temporary database file disappeared?!?", database);
X	rewind(fptempdbase);
X    } else {
X	fclose(fpw);
X    }
X
X    return;
X}
X
X/*
X * database_record_write(FILE *fpw, char *filename, int flags,
X *                              char *ignorevec, struct stat *statbuf,
X *				int entrynum)
X *
X * 	write out the pertinent information of the specifed file to the
X *	database.
X *
X * 	gather the signatures, and include that in the info going to
X *		to the database.
X *
X *	(entrynum) is the unique entry number tag from tw.config.
X */
X
Xstatic void
Xdatabase_record_write (fpw, filename, flags, ignorevec, statbuf, entrynum)
X    FILE *fpw;
X    char *filename;
X    int flags;
X    char *ignorevec;
X    struct stat *statbuf;
X    int entrynum;
X{
X    char 	sigs[NUM_SIGS][SIG_MAX_LEN];
X    int		fd, i;
X    int		ignoremask;
X    char	vec64_a[50];
X    char	vec64_c[50];
X    char	vec64_m[50];
X    char	sigs_concat[1024];
X    /* filename, entrynum, ignore, mode, inode, nlinks, uid, gid, size,
X     *		access, modify, ctime, {sig0, sig1, ..., sig9}
X     */
X    static char *format = "%s %ld %s %lo %ld %ld %ld %ld %ld %s %s %s %s\n";
X
X    if (verbosity) {
X	fprintf(stderr, "scanning: %s\n", filename);
X    }
X
X    /*
X     * check for NOOPEN flag (for special files that shouldn't be
X     * 		read from, like devices)
X     *
X     * if it's a symlink, then we collect the stat info on the link
X     * 		itself.  remember, we never traverse symlinks!
X     *
X     * so, we make up null signatures.
X     */
X    if ((flags & FLAG_NOOPEN) || (flags & FLAG_SYMLINK)) {
X	for (i = 0; i < NUM_SIGS; i++) {
X	    register char *pc = sigs[i];
X	    *pc++ = '0';
X	    *pc++ = ' ';
X	    *pc++ = '\0';
X	}
X
X	goto SKIPPED_SIGS;
X    }
X
X    /* descriptor for signature functions */
X    if ((fd = open(filename, O_RDONLY)) < 0) {
X	/* skip it if we had an error */
X	warn_with_err("Trying to open %s for signature", filename);
X	return;
X    }
X
X    /* first find out which signatures we don't need to collect */
X    ignoremask = ignore_vec_to_scalar(ignorevec);
X
X    /* collect signatures */
X    for (i = 0; i < NUM_SIGS; i++) {
X	char *pc = sigs[i];
X
X	/* do we skip this signature? */
X	if ((ignoremask & (IGNORE_0 << i)) || (runtimeignore & (IGNORE_0 << i)))
X	    (void) strcpy(pc, "0 ");
X	else {
X	    (*pf_signatures[i])(fd, pc, SIG_MAX_LEN);
X	    (void) strcat(pc, " ");
X	}
X    }
X
X    /* close up the descriptor, since we're done */
X    (void) close(fd);
X
XSKIPPED_SIGS:
X
X    /* concatenate all the signature */
X    sigs_concat[0] = '\0';
X    for (i = 0; i < NUM_SIGS; i++)
X	strcat(sigs_concat, sigs[i]);
X
X    /* escape any special characters in the filename */
X    strcpy(filename, filename_escape(filename));
X
X    /* filename, ignore, mode, inode, nlinks, uid, gid, size, access, modify,
X     * 		ctime, sig0, sig1, ..., sig9
X     */
X
X    SPDEBUG(6) printf("--(database_record_write)--> %s\n", filename);
X
X
X    {
X	unsigned long va = statbuf->st_atime,
X		 vm = statbuf->st_mtime,
X		 vc = statbuf->st_ctime;
X
X	fprintf(fpw, format, filename, (long)entrynum, ignorevec,
X	    (long)statbuf->st_mode, (long)statbuf->st_ino,
X	    (long)statbuf->st_nlink, (long)statbuf->st_uid,
X	    (long)statbuf->st_gid, (long)statbuf->st_size,
X	    pltob64(&va, (char *) vec64_a, 1),
X	    pltob64(&vm, (char *) vec64_m, 1),
X	    pltob64(&vc, (char *) vec64_c, 1),
X	    sigs_concat);
X    }
X
X    return;
X
X}
END_OF_FILE
if test 12312 -ne `wc -c <'tripwire-1.1/src/dbase.build.c'`; then
    echo shar: \"'tripwire-1.1/src/dbase.build.c'\" unpacked with wrong size!
fi
# end of 'tripwire-1.1/src/dbase.build.c'
fi
if test -f 'tripwire-1.1/WHATSNEW' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tripwire-1.1/WHATSNEW'\"
else
echo shar: Extracting \"'tripwire-1.1/WHATSNEW'\" \(10366 characters\)
sed "s/^X//" >'tripwire-1.1/WHATSNEW' <<'END_OF_FILE'
X## $Id: WHATSNEW,v 1.8 1993/12/15 18:28:02 genek Exp $
X##
X## WHATSNEW for Tripwire v1.1
X##
X## Gene Kim & Gene Spafford
X## The COAST Project
X## Department of Computer Sciences
X## Purdue University
X##
X
XIntroduction:
X=============
X
X    Version 1.1 considerably upgrades the functionality of Tripwire.
XAll known bugs have been fixed, and many selected features have been
Xadded at the request of Tripwire users.
X
X    Among the major changes are:
X
X	- rewrite of the "-update" command.  
X	- addition of an "-interactive" command that prompts the user
X		whether a changed file's database entry should be 
X		updated.
X	- addition of a "-loosedir" command for quieter Tripwire runs.
X	- support for monotonically growing files in tw.config.
X	- addition of comprehensive test suite to test Tripwire
X		functionalities.
X	- hooks for external services (i.e., compression, encryption, 
X		networking) through "-cfd" and "-dfd" options.
X	- addition of the new NIST SHA/SHS signature algorithm.
X	- corrections and changes in the MD2, MD4, MD5, CRC32, 
X		and Snefru signature routines.
X	- addition of a more rigorous signature test suite.
X	- more error checking in tw.config @@directives.
X	- siggen replaces sigfetch.
X	- addition of a tw.config file for Solaris v2.2 (SVR4).
X	- change of base-64 alphabet to conform to standards.
X	- preprocessor macro fixes.
X
X
XNew Tripwire database format:
X=============================
X
X    The Tripwire database format has changed since v1.0, using a
Xdifferent base-64 alphabet and encoding scheme.  Use the twconvert
Xprogram to convert v1.0 databases to v1.1 databases (located in the
X./src directory).
X
X    If you have been using an older version of Tripwire, you will
Xneed to use twconvert convert your databases to the new format.
X
X
XUpdating the Tripwire database:
X===============================
X
X    There has been a major rewrite/rethink of the "tripwire -update"
Xcommand, as well as the addition of a "tripwire -interactive" command
Xwhich allows the user to interactively select which database entries
Xshould be updated.  No vestiges of the "-add" or "-delete" command
Xremain, since the "-update" command now automatically deletes and adds
Xfiles.
X
X    However, the preferred way of keeping Tripwire databases in sync
Xwith the filesystems is using the "-interactive" command.  A Tripwire
Xsession using Interactive mode might look like:
X
X    6:25am (flounder) tw/src 1006 %% tripwire -interactive
X    ### Phase 1:   Reading configuration file
X    ### Phase 2:   Generating file list
X    ### Phase 3:   Creating file information database
X    ### Phase 4:   Searching for inconsistencies
X    ###
X    ###                     Total files scanned:            49
X    ###                           Files added:              0
X    ###                           Files deleted:            0
X    ###                           Files changed:            49
X    ###
X    ###                     After applying rules:
X    ###                           Changes discarded:        47
X    ###                           Changes remaining:        2
X    ###
X    changed: drwx------ genek        1024 May  3 06:25:37 1993 /homes/genek/research/tw/src
X    changed: -rw------- genek        7978 May  3 06:24:19 1993 /homes/genek/research/tw/src/databases/tw.db_flounder.Eng.Sun.COM.old
X    ### Phase 5:   Generating observed/expected pairs for changed files
X    ###
X    ### Attr        Observed (what it is)         Expected (what it should be)
X    ### =========== ============================= =============================
X    /homes/genek/research/tw/src
X          st_mtime: Mon May  3 06:25:37 1993      Mon May  3 06:11:39 1993      
X          st_ctime: Mon May  3 06:25:37 1993      Mon May  3 06:11:39 1993      
X    ---> File: '/homes/genek/research/tw/src'
X    ---> Update entry?  [YN(y)nh?] y
X    
X    ### Updating database...
X    ###
X    ### Phase 1:   Reading configuration file
X    ### Phase 2:   Generating file list
X    ### Phase 3:   Updating file information database
X    ###
X    ### Warning:   Old database file will be moved to `tw.db_flounder.Eng.Sun.COM.old'
X    ###            in ./databases.
X    ###
X    6:25am (flounder) tw/src 1007 %% 
X
X    Tripwire prompts the user whether the database entry of the
Xcurrent file should be updated to match the current file information.
XPressing either 'y' or 'n' either updates the current file or skips to
Xthe next file.  Pressing 'Y' or 'N' applies your answer to the entire
Xentry.  (I.e., if /etc is changed, typing 'Y' will not only update /etc,
Xbut it will also files update all the files in /etc.)
X
X
XTripwire exit codes:
X====================
X
X    Tripwire exit status can be interpreted by the following mask:
X
X	1:	run-time error.  aborted.
X	2:	files added
X	4:	files deleted
X	8:	files changed
X
X    For example, if Tripwire exits with status code 10, then files
Xwere found added and changed.  (i.e., 8 + 2 = 10.)
X
X
XTripwire quiet option:
X======================
X
X    When run with -q option, Tripwire really is quiet, printing only
Xone-line reports for each added, deleted, or changed file.  The output
Xis more suitable for parsing with awk or perl.
X
X
XMonotonically growing files:
X============================
X
X    The ">" template is now supported in the tw.config files.  This
Xtemplate allows files to grow without being reported.  However, if the
Xfile is deleted or is smaller than the size recorded in the database,
Xit is reported as changed.
X
X
X
XLoose directory checking:
X=========================
X
X    This option was prompted by complaints that Tripwire in Integrity
XChecking and Interactive mode unnecessarily complains about
Xdirectories whose nlink, ctime, mtime, or size have changed.  When
XTripwire is run with the "-loosedir" option, directories automatically
Xhave these attributes included in their ignore-mask, thus quieting
Xthese complaints.
X
X    Note that this is option is not enabled by default, making normal
XTripwire behavior no different than previous releases.  However,
Xrunning with this option enabled considerably decreases "noise" in
XTripwire reports.  
X
X    (Ideally, this "loose directory checking" should be offered on
Xa per-file basis in the tw.config file.  However, adding another field
Xto the tw.config file was too extensive a change to be considered for
Xthis release.  A later release of Tripwire may rectify this.)
X
X
XHooks for external services:
X============================
X
X    Tripwire now supports the "-cfd" and "-dfd" option that allows the
Xuser to specify an open file descriptor for reading the configuration
Xfile and database file, respectively.  Using these options, an
Xexternal program can feed Tripwire both input files through open file
Xdescriptors.  This external program could supply services not provided
Xthough Tripwire, such as encryption, data compression, or a
Xcentralized network server.
X
X    This program might do the following:  Open the database and
Xconfiguration files, process or decode (i.e., uncompress the file),
Xand then write out the reguarly formatted file to a temporary file.
XOpen file descriptors to these files are then passed to Tripwire by
Xcommand-line arguments though execl().
X
X    An example of using a shell script to compress and encrypt your
Xfiles is given in ./contrib/zcatcrypt.  It is a four line Bourne shell
Xscript that encrypts and compresses the database and configuration
Xfiles.
X
X
XSHA/SHS signature routines:
X===========================
X
X    Tripwire now includes SHA/SHS, the proposed NIST Digital Signature
XStandard.  See the README file for details on this algorithm.
X
X    Please note that the SHA code in ./sigs/sha seems to be poorly
Xhandled by many optimizing C compilers.  For example, the stock C
Xcompiler included with SunOS 4.x takes almost two minutes to compile
Xthis file with the -O option on a Sparcstation10.
X
X    Other compilers (such as GCC) do not have this problem.
X
X
XChange in tw.config preprocessor:
X=================================
X
X    The tw.config preprocessor has been changed to allow the proper
Xexpansion of @@variables in filenames.  The following use of @@define
Xnow works as expected:
X
X	@@define DOMAIN_NAME    my_main_nis_domain
X	/var/yp/@@DOMAIN_NAME   L
X	@@DOMAIN_NAME/FOO	L
X
X    (This is the third attempt at getting this working correctly.  We
Xfinally fixed this by moving the macro expansion routines into the
Xlexical analyzer.)
X
X
XExpanded test suite:
X====================
X
X    The Tripwire test suite now includes runs a more standard
Xsignature test suite.  This was prompted by discovery of several
Ximplementation errors in the MD2, MD4, and MD5 signature routines that
Xwas introduced right before the official release of Tripwire.  (Thanks
XEugene Zaustinsky.)
X
X    Two more test suites have been added.  One iterates through all
Xthe Tripwire reporting functionalities, and exercises all the database
Xupdate cases.  The other test suite checks for proper Tripwire
Xpreprocessor macro expansions.
X
XCRC32 changes:
X==============
X
X    Furthermore, the CRC32 signature routine is now POSIX 1003.2 
Xcompliant.  (Thanks Dan Bernstein.)
X
X
X"siggen" replaces "sigfetch":
X=============================
X
X    As a tester noted, "sigfetch" was a misnomer since nothing was
Xactually being fetched.  Consequently, it was easy to (incorrectly)
Xconclude that "sigfetch" retrieved signatures from the database.
X
X    The "siggen" command is the current incarnation of "sigfetch".
XThe manual pages reflect this change.
X
X
XSource code cleanup:
X====================
X
X    The authors went through the sources, doing generic cleanups aid
Xin code comprehension.
X
X
XBug fixes:
X==========
X
X    This release fixes all known bugs.  The TODO list, however, gives a
Xwishlist of features that may be included in future releases.
X
X
XList of thanks:
X===============
X
X    Special thanks go to the testers of disappearing v1.0.3.  Reports
Xof critical bug fixes go to (in no special order):  E. Clinton
XArbaugh, Pat Macdonald, Eric Demerling, John Rouillard, Bob
XCunningham, and Neil Todd.
X
X    Sam Gassel, Edward DeHart, Drew Gonczi, Rik Farrow, Jim Napier,
XDrew Jolliffe, John Rouillard, Alain Brossard, Eric Bergren, Patrick
XSullivan, Nora Hermida, Juergen Schmidt, Debbie Pomerance, Michael
XHines, Tim Ramsey, Georges Tomazi, Mitchell Marks, Philip Cox, Kevin
XDupre', Chris Kern, and Eugene Zaustinsky helped in getting the
XTripwire v1.1 release in shape for our December 1993 release.
X
XGene & Gene
XKim  & Spafford
X
X
END_OF_FILE
if test 10366 -ne `wc -c <'tripwire-1.1/WHATSNEW'`; then
    echo shar: \"'tripwire-1.1/WHATSNEW'\" unpacked with wrong size!
fi
# end of 'tripwire-1.1/WHATSNEW'
fi
if test -f 'tripwire-1.1/sigs/md5/md5.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tripwire-1.1/sigs/md5/md5.c'\"
else
echo shar: Extracting \"'tripwire-1.1/sigs/md5/md5.c'\" \(10289 characters\)
sed "s/^X//" >'tripwire-1.1/sigs/md5/md5.c' <<'END_OF_FILE'
X/* $Id: md5.c,v 1.3 1993/11/22 06:38:18 genek Exp $ */
X
X/***********************************************************************
X ** md5.c -- the source code for MD5 routines                         **
X ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
X ** Created: 2/17/90 RLR                                              **
X ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                   **
X ** Revised (for MD5): RLR 4/27/91                                    **
X ***********************************************************************
X ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
X ** License to copy and use this software is granted provided that    **
X ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
X ** Digest Algorithm" in all material mentioning or referencing this  **
X ** software or this function.                                        **
X ** License is also granted to make and use derivative works          **
X ** provided that such works are identified as "derived from the RSA  **
X ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
X ** material mentioning or referencing the derived work.              **
X ** RSA Data Security, Inc. makes no representations concerning       **
X ** either the merchantability of this software or the suitability    **
X ** of this software for any particular purpose.  It is provided "as  **
X ** is" without express or implied warranty of any kind.              **
X ** These notices must be retained in any copies of any part of this  **
X ** documentation and/or software.                                    **
X **********************************************************************/
X
X#include "md5.h"
X
X/* forward declaration */
Xstatic void Transform ();
X
Xstatic unsigned char PADDING[64] = {
X  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
X};
X
X/* F, G, H and I are basic MD5 functions */
X#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
X#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
X#define H(x, y, z) ((x) ^ (y) ^ (z))
X#define I(x, y, z) ((y) ^ ((x) | (~z)))
X
X/* ROTATE_LEFT rotates x left n bits */
X#ifdef UNICOS
X# define ROTATE_LEFT(x,n) (((x) << (n)) | (((x) & 0xffffffff) >> (32-(n))))
X#else
X# define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
X#endif 
X
X/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
X/* Rotation is separate from addition to prevent recomputation */
X#define FF(a, b, c, d, x, s, ac) \
X  {(a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
X   (a) = ROTATE_LEFT ((a), (s)); \
X   (a) += (b); \
X  }
X#define GG(a, b, c, d, x, s, ac) \
X  {(a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
X   (a) = ROTATE_LEFT ((a), (s)); \
X   (a) += (b); \
X  }
X#define HH(a, b, c, d, x, s, ac) \
X  {(a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
X   (a) = ROTATE_LEFT ((a), (s)); \
X   (a) += (b); \
X  }
X#define II(a, b, c, d, x, s, ac) \
X  {(a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
X   (a) = ROTATE_LEFT ((a), (s)); \
X   (a) += (b); \
X  }
X
X/* The routine MD5Init initializes the message-digest context
X   mdContext. All fields are set to zero.  */
Xvoid MD5Init (mdContext)
XMD5_CTX *mdContext;
X{
X  mdContext->i[0] = mdContext->i[1] = (UINT4)0;
X
X  /* Load magic initialization constants.
X   */
X  mdContext->buf[0] = (UINT4)0x67452301;
X  mdContext->buf[1] = (UINT4)0xefcdab89;
X  mdContext->buf[2] = (UINT4)0x98badcfe;
X  mdContext->buf[3] = (UINT4)0x10325476;
X}
X
X/* The routine MD5Update updates the message-digest context to
X   account for the presence of each of the characters inBuf[0..inLen-1]
X   in the message whose digest is being computed.  */
Xvoid MD5Update (mdContext, inBuf, inLen)
XMD5_CTX *mdContext;
Xunsigned char *inBuf;
Xunsigned int inLen;
X{
X  UINT4 in[16];
X  int mdi;
X  unsigned int i, ii;
X
X  /* compute number of bytes mod 64 */
X  mdi = (int)((mdContext->i[0] >> 3) & 0x3F);
X
X  /* update number of bits */
X#ifndef UNICOS
X  if ((mdContext->i[0] + ((UINT4)inLen << 3)) < mdContext->i[0])
X#else
X  if (((mdContext->i[0]+((UINT4)inLen << 3)) & 0xffffffff) < mdContext->i[0])
X#endif
X
X    mdContext->i[1]++;
X
X  mdContext->i[0] += ((UINT4)inLen << 3);
X  mdContext->i[1] += ((UINT4)inLen >> 29);
X
X  while (inLen--) {
X    /* add new character to buffer, increment mdi */
X    mdContext->in[mdi++] = *inBuf++;
X
X    /* transform if necessary */
X    if (mdi == 0x40) {
X      for (i = 0, ii = 0; i < 16; i++, ii += 4)
X        in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
X                (((UINT4)mdContext->in[ii+2]) << 16) |
X                (((UINT4)mdContext->in[ii+1]) << 8) |
X                ((UINT4)mdContext->in[ii]);
X      Transform (mdContext->buf, in);
X      mdi = 0;
X    }
X  }
X}
X
X/* The routine MD5Final terminates the message-digest computation and
X   ends with the desired message digest in mdContext->digest[0...15].  */
Xvoid MD5Final (mdContext)
XMD5_CTX *mdContext;
X{
X  UINT4 in[16];
X  int mdi;
X  unsigned int i, ii;
X  unsigned int padLen;
X
X  /* save number of bits */
X  in[14] = mdContext->i[0];
X  in[15] = mdContext->i[1];
X
X  /* compute number of bytes mod 64 */
X  mdi = (int)((mdContext->i[0] >> 3) & 0x3F);
X
X  /* pad out to 56 mod 64 */
X  padLen = (mdi < 56) ? (56 - mdi) : (120 - mdi);
X  MD5Update (mdContext, PADDING, padLen);
X
X  /* append length in bits and transform */
X  for (i = 0, ii = 0; i < 14; i++, ii += 4)
X    in[i] = (((UINT4)mdContext->in[ii+3]) << 24) |
X            (((UINT4)mdContext->in[ii+2]) << 16) |
X            (((UINT4)mdContext->in[ii+1]) << 8) |
X            ((UINT4)mdContext->in[ii]);
X  Transform (mdContext->buf, in);
X
X  /* store buffer in digest */
X  for (i = 0, ii = 0; i < 4; i++, ii += 4) {
X    mdContext->digest[ii] = (unsigned char)(mdContext->buf[i] & 0xFF);
X    mdContext->digest[ii+1] =
X      (unsigned char)((mdContext->buf[i] >> 8) & 0xFF);
X    mdContext->digest[ii+2] =
X      (unsigned char)((mdContext->buf[i] >> 16) & 0xFF);
X    mdContext->digest[ii+3] =
X      (unsigned char)((mdContext->buf[i] >> 24) & 0xFF);
X  }
X}
X
X/* Basic MD5 step. Transforms buf based on in.  */
Xstatic void Transform (buf, in)
XUINT4 *buf;
XUINT4 *in;
X{
X  UINT4 a = buf[0], b = buf[1], c = buf[2], d = buf[3];
X
X  /* Round 1 */
X#define S11 7
X#define S12 12
X#define S13 17
X#define S14 22
X  FF ( a, b, c, d, in[ 0], S11, 0xd76aa478); /* 1 */
X  FF ( d, a, b, c, in[ 1], S12, 0xe8c7b756); /* 2 */
X  FF ( c, d, a, b, in[ 2], S13, 0x242070db); /* 3 */
X  FF ( b, c, d, a, in[ 3], S14, 0xc1bdceee); /* 4 */
X  FF ( a, b, c, d, in[ 4], S11, 0xf57c0faf); /* 5 */
X  FF ( d, a, b, c, in[ 5], S12, 0x4787c62a); /* 6 */
X  FF ( c, d, a, b, in[ 6], S13, 0xa8304613); /* 7 */
X  FF ( b, c, d, a, in[ 7], S14, 0xfd469501); /* 8 */
X  FF ( a, b, c, d, in[ 8], S11, 0x698098d8); /* 9 */
X  FF ( d, a, b, c, in[ 9], S12, 0x8b44f7af); /* 10 */
X  FF ( c, d, a, b, in[10], S13, 0xffff5bb1); /* 11 */
X  FF ( b, c, d, a, in[11], S14, 0x895cd7be); /* 12 */
X  FF ( a, b, c, d, in[12], S11, 0x6b901122); /* 13 */
X  FF ( d, a, b, c, in[13], S12, 0xfd987193); /* 14 */
X  FF ( c, d, a, b, in[14], S13, 0xa679438e); /* 15 */
X  FF ( b, c, d, a, in[15], S14, 0x49b40821); /* 16 */
X
X  /* Round 2 */
X#define S21 5
X#define S22 9
X#define S23 14
X#define S24 20
X  GG ( a, b, c, d, in[ 1], S21, 0xf61e2562); /* 17 */
X  GG ( d, a, b, c, in[ 6], S22, 0xc040b340); /* 18 */
X  GG ( c, d, a, b, in[11], S23, 0x265e5a51); /* 19 */
X  GG ( b, c, d, a, in[ 0], S24, 0xe9b6c7aa); /* 20 */
X  GG ( a, b, c, d, in[ 5], S21, 0xd62f105d); /* 21 */
X  GG ( d, a, b, c, in[10], S22,  0x2441453); /* 22 */
X  GG ( c, d, a, b, in[15], S23, 0xd8a1e681); /* 23 */
X  GG ( b, c, d, a, in[ 4], S24, 0xe7d3fbc8); /* 24 */
X  GG ( a, b, c, d, in[ 9], S21, 0x21e1cde6); /* 25 */
X  GG ( d, a, b, c, in[14], S22, 0xc33707d6); /* 26 */
X  GG ( c, d, a, b, in[ 3], S23, 0xf4d50d87); /* 27 */
X  GG ( b, c, d, a, in[ 8], S24, 0x455a14ed); /* 28 */
X  GG ( a, b, c, d, in[13], S21, 0xa9e3e905); /* 29 */
X  GG ( d, a, b, c, in[ 2], S22, 0xfcefa3f8); /* 30 */
X  GG ( c, d, a, b, in[ 7], S23, 0x676f02d9); /* 31 */
X  GG ( b, c, d, a, in[12], S24, 0x8d2a4c8a); /* 32 */
X
X  /* Round 3 */
X#define S31 4
X#define S32 11
X#define S33 16
X#define S34 23
X  HH ( a, b, c, d, in[ 5], S31, 0xfffa3942); /* 33 */
X  HH ( d, a, b, c, in[ 8], S32, 0x8771f681); /* 34 */
X  HH ( c, d, a, b, in[11], S33, 0x6d9d6122); /* 35 */
X  HH ( b, c, d, a, in[14], S34, 0xfde5380c); /* 36 */
X  HH ( a, b, c, d, in[ 1], S31, 0xa4beea44); /* 37 */
X  HH ( d, a, b, c, in[ 4], S32, 0x4bdecfa9); /* 38 */
X  HH ( c, d, a, b, in[ 7], S33, 0xf6bb4b60); /* 39 */
X  HH ( b, c, d, a, in[10], S34, 0xbebfbc70); /* 40 */
X  HH ( a, b, c, d, in[13], S31, 0x289b7ec6); /* 41 */
X  HH ( d, a, b, c, in[ 0], S32, 0xeaa127fa); /* 42 */
X  HH ( c, d, a, b, in[ 3], S33, 0xd4ef3085); /* 43 */
X  HH ( b, c, d, a, in[ 6], S34,  0x4881d05); /* 44 */
X  HH ( a, b, c, d, in[ 9], S31, 0xd9d4d039); /* 45 */
X  HH ( d, a, b, c, in[12], S32, 0xe6db99e5); /* 46 */
X  HH ( c, d, a, b, in[15], S33, 0x1fa27cf8); /* 47 */
X  HH ( b, c, d, a, in[ 2], S34, 0xc4ac5665); /* 48 */
X
X  /* Round 4 */
X#define S41 6
X#define S42 10
X#define S43 15
X#define S44 21
X  II ( a, b, c, d, in[ 0], S41, 0xf4292244); /* 49 */
X  II ( d, a, b, c, in[ 7], S42, 0x432aff97); /* 50 */
X  II ( c, d, a, b, in[14], S43, 0xab9423a7); /* 51 */
X  II ( b, c, d, a, in[ 5], S44, 0xfc93a039); /* 52 */
X  II ( a, b, c, d, in[12], S41, 0x655b59c3); /* 53 */
X  II ( d, a, b, c, in[ 3], S42, 0x8f0ccc92); /* 54 */
X  II ( c, d, a, b, in[10], S43, 0xffeff47d); /* 55 */
X  II ( b, c, d, a, in[ 1], S44, 0x85845dd1); /* 56 */
X  II ( a, b, c, d, in[ 8], S41, 0x6fa87e4f); /* 57 */
X  II ( d, a, b, c, in[15], S42, 0xfe2ce6e0); /* 58 */
X  II ( c, d, a, b, in[ 6], S43, 0xa3014314); /* 59 */
X  II ( b, c, d, a, in[13], S44, 0x4e0811a1); /* 60 */
X  II ( a, b, c, d, in[ 4], S41, 0xf7537e82); /* 61 */
X  II ( d, a, b, c, in[11], S42, 0xbd3af235); /* 62 */
X  II ( c, d, a, b, in[ 2], S43, 0x2ad7d2bb); /* 63 */
X  II ( b, c, d, a, in[ 9], S44, 0xeb86d391); /* 64 */
X
X  buf[0] += a;
X  buf[1] += b;
X  buf[2] += c;
X  buf[3] += d;
X}
X
END_OF_FILE
if test 10289 -ne `wc -c <'tripwire-1.1/sigs/md5/md5.c'`; then
    echo shar: \"'tripwire-1.1/sigs/md5/md5.c'\" unpacked with wrong size!
fi
# end of 'tripwire-1.1/sigs/md5/md5.c'
fi
if test -f 'tripwire-1.1/tests/tw.conf.test' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tripwire-1.1/tests/tw.conf.test'\"
else
echo shar: Extracting \"'tripwire-1.1/tests/tw.conf.test'\" \(1935 characters\)
sed "s/^X//" >'tripwire-1.1/tests/tw.conf.test' <<'END_OF_FILE'
X/tmp/genek/tripwire-1.1				R+0123456789-ugpmci
X/tmp/genek/tripwire-1.1/tests 			E
X!/tmp/genek/tripwire-1.1/databases 		E
X!/tmp/genek/tripwire-1.1/tests/databases 		E
X
X!/tmp/genek/tripwire-1.1/src/config.parse.o
X!/tmp/genek/tripwire-1.1/src/main.o
X!/tmp/genek/tripwire-1.1/src/list.o
X!/tmp/genek/tripwire-1.1/src/ignorevec.o
X!/tmp/genek/tripwire-1.1/src/dbase.build.o
X!/tmp/genek/tripwire-1.1/src/utils.o
X!/tmp/genek/tripwire-1.1/src/preen.o
X!/tmp/genek/tripwire-1.1/src/preen.interp.o
X!/tmp/genek/tripwire-1.1/src/preen.report.o
X!/tmp/genek/tripwire-1.1/src/nullsig.o
X!/tmp/genek/tripwire-1.1/src/config.prim.o
X!/tmp/genek/tripwire-1.1/src/dbase.update.o
X!/tmp/genek/tripwire-1.1/src/sigfetch
X!/tmp/genek/tripwire-1.1/src/siggen
X!/tmp/genek/tripwire-1.1/src/tripwire
X!/tmp/genek/tripwire-1.1/src/twconvert
X!/tmp/genek/tripwire-1.1/src/twconvert.o
X!/tmp/genek/tripwire-1.1/src/siggen.o
X!/tmp/genek/tripwire-1.1/src/config.pre.o
X!/tmp/genek/tripwire-1.1/sigs/crc/crc.o
X!/tmp/genek/tripwire-1.1/sigs/crc32/crc32.o
X!/tmp/genek/tripwire-1.1/sigs/md2/md2wrapper.o
X!/tmp/genek/tripwire-1.1/sigs/md2/md2.o
X!/tmp/genek/tripwire-1.1/sigs/md4/md4.o
X!/tmp/genek/tripwire-1.1/sigs/md4/md4wrapper.o
X!/tmp/genek/tripwire-1.1/sigs/md5/md5.o
X!/tmp/genek/tripwire-1.1/sigs/md5/md5wrapper.o
X!/tmp/genek/tripwire-1.1/sigs/snefru/snefru.o
X!/tmp/genek/tripwire-1.1/sigs/sha/sha.o
X!/tmp/genek/tripwire-1.1/sigs/sha/shawrapper.o
X
X!/tmp/genek/tripwire-1.1/aux/types
X!/tmp/genek/tripwire-1.1/aux/byteorder
X
X!/tmp/genek/tripwire-1.1/tests/createfiles
X!/tmp/genek/tripwire-1.1/tests/testfiles
X!/tmp/genek/tripwire-1.1/tests/OKSIGS
X
X!/tmp/genek/tripwire-1.1/src/config.lex.c
X!/tmp/genek/tripwire-1.1/src/config.pre.c
X!/tmp/genek/tripwire-1.1/Makefile
X#/tmp/genek/tripwire-1.1/include/config.h		# for show
X!/tmp/genek/tripwire-1.1/include/byteorder.h
X!/tmp/genek/tripwire-1.1/include/inode.h
X
X!/tmp/genek/tripwire-1.1/src/help.o
X!/tmp/genek/tripwire-1.1/src/help.c
END_OF_FILE
if test 1935 -ne `wc -c <'tripwire-1.1/tests/tw.conf.test'`; then
    echo shar: \"'tripwire-1.1/tests/tw.conf.test'\" unpacked with wrong size!
fi
# end of 'tripwire-1.1/tests/tw.conf.test'
fi
if test -f 'tripwire-1.1/sigs/crc/crc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tripwire-1.1/sigs/crc/crc.h'\"
else
echo shar: Extracting \"'tripwire-1.1/sigs/crc/crc.h'\" \(75 characters\)
sed "s/^X//" >'tripwire-1.1/sigs/crc/crc.h' <<'END_OF_FILE'
X/* $Id: crc.h,v 1.2 1993/08/19 05:27:44 genek Exp $ */
X
Xint sig_crc_get();
END_OF_FILE
if test 75 -ne `wc -c <'tripwire-1.1/sigs/crc/crc.h'`; then
    echo shar: \"'tripwire-1.1/sigs/crc/crc.h'\" unpacked with wrong size!
fi
# end of 'tripwire-1.1/sigs/crc/crc.h'
fi
echo shar: End of archive 19 \(of 25\).
cp /dev/null ark19isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    echo "Now read tripwire-1.1/README.kits"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
