Newsgroups: comp.sources.unix
From: gwr@mc.com (Gordon W. Ross)
Subject: v27i065: bootptest-1.1 - utility for testing a bootp server, Part01/01
Message-id: <2.750376278.23845@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: gwr@mc.com (Gordon W. Ross)
Posting-Number: Volume 27, Issue 65
Archive-Name: bootptest-1.1/part01

bootptest is a program for testing a BOOTP server.

This simple program was put together from pieces taken from
various places, including the CMU BOOTP client and server.
The packet printing routine is from the Berkeley "tcpdump"
program with some enhancements I added.  The print-bootp.c
file is shared with my copy of "tcpdump" and therefore uses
some unusual utility routines that would normally be provided
by various parts of the tcpdump program.

	Gordon W. Ross  		Mercury Computer Systems
	gwr@mc.com      		199 Riverneck Road
	508-256-1300			Chelmsford, MA 01824-2820

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 1)."
# Contents:  MANIFEST Makefile README addrtoname.h bootp.h bootptest.c
#   bootptest.man interface.h print-bootp.c util.c vdgencmu.c
#   vdgenstd.c
# Wrapped by vixie@gw.home.vix.com on Mon Oct 11 14:48:33 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(486 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	This shipping list
X Makefile                   1	
X README                     1	
X addrtoname.h               1	
X bootp.h                    1	
X bootptest.c                1	
X bootptest.man              1	
X interface.h                1	
X print-bootp.c              1	
X util.c                     1	
X vdgencmu.c                 1	
X vdgenstd.c                 1	
END_OF_FILE
if test 486 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(355 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X
XCFLAGS=-g
X
Xall: bootptest vdstd
X
XOBJS= bootptest.o print-bootp.o util.o
Xbootptest: $(OBJS)
X	$(CC) -o $@ $(OBJS)
X
X$(OBJS) : interface.h bootp.h
X
Xbootptest.cat : bootptest.man
X	nroff -man $? > $@
X
Xvdcmu : vdgencmu
X	./vdgencmu > $@
X
Xvdstd : vdgenstd
X	./vdgenstd > $@
X
Xclean :
X	-rm -f *.o
X	-rm -f core bootptest
X	-rm -f vdcmu vdgencmu
X	-rm -f vdstd vdgenstd
END_OF_FILE
if test 355 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(1073 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X
Xbootptest is a program for testing a BOOTP server.
X
XThis simple program was put together from pieces taken from
Xvarious places, including the CMU BOOTP client and server.
XThe packet printing routine is from the Berkeley "tcpdump"
Xprogram with some enhancements I added.  The print-bootp.c
Xfile is shared with my copy of "tcpdump" and therefore uses
Xsome unusual utility routines that would normally be provided
Xby various parts of the tcpdump program.
X
XBoilerplate:
X
XThis product includes software developed by the University of
XCalifornia, Lawrence Berkeley Laboratory and its contributors.
X(See the copyright notice in print-bootp.c)
X
XThe remainder of this program is public domain.  You may do
Xwhatever you like with it except claim that you wrote it.
X
XTHIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
XWARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
XMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X
XGordon W. Ross  		Mercury Computer Systems
Xgwr@mc.com      		199 Riverneck Road
X508-256-1300			Chelmsford, MA 01824-2820
END_OF_FILE
if test 1073 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'addrtoname.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'addrtoname.h'\"
else
echo shar: Extracting \"'addrtoname.h'\" \(1577 characters\)
sed "s/^X//" >'addrtoname.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1988, 1990 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that: (1) source code distributions
X * retain the above copyright notice and this paragraph in its entirety, (2)
X * distributions including binary code include the above copyright notice and
X * this paragraph in its entirety in the documentation or other materials
X * provided with the distribution, and (3) all advertising materials mentioning
X * features or use of this software display the following acknowledgement:
X * ``This product includes software developed by the University of California,
X * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
X * the University nor the names of its contributors may be used to endorse
X * or promote products derived from this software without specific prior
X * written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
X * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
X * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X *
X * @(#) $Header: addrtoname.h,v 1.5 92/03/17 13:41:37 mccanne Exp $ (LBL)
X */
X
X/* Name to address translation routines. */
X
Xextern char *etheraddr_string();
Xextern char *etherproto_string();
Xextern char *tcpport_string();
Xextern char *udpport_string();
Xextern char *getname();
Xextern char *intoa();
X
Xextern void init_addrtoname();
Xextern void no_foreign_names();
X
X#define ipaddr_string(p) getname((u_char *)(p))
END_OF_FILE
if test 1577 -ne `wc -c <'addrtoname.h'`; then
    echo shar: \"'addrtoname.h'\" unpacked with wrong size!
fi
# end of 'addrtoname.h'
fi
if test -f 'bootp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bootp.h'\"
else
echo shar: Extracting \"'bootp.h'\" \(4479 characters\)
sed "s/^X//" >'bootp.h' <<'END_OF_FILE'
X#ifndef _BLURB_
X#define _BLURB_
X/************************************************************************
X          Copyright 1988, 1991 by Carnegie Mellon University
X
X                          All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted, provided
Xthat the above copyright notice appear in all copies and that both that
Xcopyright notice and this permission notice appear in supporting
Xdocumentation, and that the name of Carnegie Mellon University not be used
Xin advertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.
X
XCARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
XSOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
XIN NO EVENT SHALL CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
XDAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
XPROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
XACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X************************************************************************/
X#endif /* _BLURB_ */
X
X
X/*
X * Bootstrap Protocol (BOOTP).  RFC951 and RFC1048.
X *
X * $Header: /afs/andrew.cmu.edu/netdev/src/cmu/bootp-public/RCS/bootp.h,v 1.3 1991/11/01 10:02:29 ww0n Exp ww0n $
X *
X *
X * This file specifies the "implementation-independent" BOOTP protocol
X * information which is common to both client and server.
X *
X */
X
X
X#define BP_CHADDR_LEN	 16
X#define BP_SNAME_LEN	 64
X#define BP_FILE_LEN	128
X#define BP_VEND_LEN	 64
X
Xstruct bootp {
X    unsigned char    bp_op;			/* packet opcode type */
X    unsigned char    bp_htype;			/* hardware addr type */
X    unsigned char    bp_hlen;			/* hardware addr length */
X    unsigned char    bp_hops;			/* gateway hops */
X    unsigned long    bp_xid;			/* transaction ID */
X    unsigned short   bp_secs;			/* seconds since boot began */
X    unsigned short   bp_unused;
X    struct in_addr   bp_ciaddr;			/* client IP address */
X    struct in_addr   bp_yiaddr;			/* 'your' IP address */
X    struct in_addr   bp_siaddr;			/* server IP address */
X    struct in_addr   bp_giaddr;			/* gateway IP address */
X    unsigned char    bp_chaddr[BP_CHADDR_LEN];	/* client hardware address */
X    unsigned char    bp_sname[BP_SNAME_LEN];	/* server host name */
X    unsigned char    bp_file[BP_FILE_LEN];	/* boot file name */
X    unsigned char    bp_vend[BP_VEND_LEN];	/* vendor-specific area */
X};
X
X/*
X * UDP port numbers, server and client.
X */
X#define	IPPORT_BOOTPS		67
X#define	IPPORT_BOOTPC		68
X
X#define BOOTREPLY		2
X#define BOOTREQUEST		1
X
X
X/*
X * Hardware types from Assigned Numbers RFC.
X */
X#define HTYPE_ETHERNET		  1
X#define HTYPE_EXP_ETHERNET	  2
X#define HTYPE_AX25		  3
X#define HTYPE_PRONET		  4
X#define HTYPE_CHAOS		  5
X#define HTYPE_IEEE802		  6
X#define HTYPE_ARCNET		  7
X
X
X
X/*
X * Vendor magic cookie (v_magic) for CMU
X */
X#define VM_CMU		"CMU"
X
X/*
X * Vendor magic cookie (v_magic) for RFC1048
X */
X#define VM_RFC1048	{ 99, 130, 83, 99 }
X
X
X
X/*
X * RFC1048 tag values used to specify what information is being supplied in
X * the vendor field of the packet.
X */
X
X#define TAG_PAD			((unsigned char)   0)
X#define TAG_SUBNET_MASK		((unsigned char)   1)
X#define TAG_TIME_OFFSET		((unsigned char)   2)
X#define TAG_GATEWAY		((unsigned char)   3)
X#define TAG_TIME_SERVER		((unsigned char)   4)
X#define TAG_NAME_SERVER		((unsigned char)   5)
X#define TAG_DOMAIN_SERVER	((unsigned char)   6)
X#define TAG_LOG_SERVER		((unsigned char)   7)
X#define TAG_COOKIE_SERVER	((unsigned char)   8)
X#define TAG_LPR_SERVER		((unsigned char)   9)
X#define TAG_IMPRESS_SERVER	((unsigned char)  10)
X#define TAG_RLP_SERVER		((unsigned char)  11)
X#define TAG_HOSTNAME		((unsigned char)  12)
X#define TAG_BOOTSIZE		((unsigned char)  13)
X#define TAG_END			((unsigned char) 255)
X
X
X
X/*
X * "vendor" data permitted for CMU bootp clients.
X */
X
Xstruct cmu_vend {
X	unsigned char	v_magic[4];	/* magic number */
X	unsigned long	v_flags;	/* flags/opcodes, etc. */
X	struct in_addr 	v_smask;	/* Subnet mask */
X	struct in_addr 	v_dgate;	/* Default gateway */
X	struct in_addr	v_dns1, v_dns2; /* Domain name servers */
X	struct in_addr	v_ins1, v_ins2; /* IEN-116 name servers */
X	struct in_addr	v_ts1, v_ts2;	/* Time servers */
X	unsigned long	v_unused[6];	/* currently unused */
X};
X
X
X/* v_flags values */
X#define VF_SMASK	1	/* Subnet mask field contains valid data */
END_OF_FILE
if test 4479 -ne `wc -c <'bootp.h'`; then
    echo shar: \"'bootp.h'\" unpacked with wrong size!
fi
# end of 'bootp.h'
fi
if test -f 'bootptest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bootptest.c'\"
else
echo shar: Extracting \"'bootptest.c'\" \(8202 characters\)
sed "s/^X//" >'bootptest.c' <<'END_OF_FILE'
X/*
X * bootptest.c - Test out a bootp server.
X *
X *
X */
Xchar *usage = "bootptest server-name [vendor-data-template-file]";
X
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/ioctl.h>
X#include <sys/file.h>
X#include <sys/time.h>
X#include <sys/stat.h>
X#include <net/if.h>
X#ifdef sun
X#include <sys/sockio.h>
X#include <net/if_arp.h>
X#endif
X#include <netinet/in.h>
X#include <netinet/if_ether.h>
X#include <signal.h>
X#include <stdio.h>
X#include <strings.h>
X#include <errno.h>
X#include <ctype.h>
X#include <netdb.h>
X
Xextern int sys_nerr;
Xextern char *sys_errlist[];
X
X#include "bootp.h"
X#include "interface.h"
X
X#define get_network_errmsg get_errmsg
X#define LOG_ERR 1
X#define BUFLEN 1024
X
Xint vflag = 1;
Xint tflag = 0;
Xint thiszone;
Xchar *program_name;
Xunsigned char *packetp;
Xunsigned char *snapend;
Xint snaplen;
X
X
X/*
X * IP port numbers for client and server obtained from /etc/services
X */
X
Xu_short bootps_port, bootpc_port;
X
X
X/*
X * Internet socket and interface config structures
X */
X
Xstruct sockaddr_in sin_server;
Xstruct sockaddr_in sin_client;
Xstruct sockaddr_in sin_from;	/* Packet source */
Xstruct ifreq ifreq[10];		/* Holds interface configuration */
Xstruct ifconf ifconf;		/* Int. config ioctl block (pnts to ifreq) */
Xstruct arpreq arpreq;		/* Arp request ioctl block */
Xstruct ether_addr eaddr;
X
X/*
X * General
X */
X
Xint debug = 0;			    /* Debugging flag (level) */
Xint s;				    /* Socket file descriptor */
Xchar hostname[64];
Xunsigned char buf[BUFLEN];	    /* Receive packet buffer */
Xstruct timezone tzp;		    /* Time zone offset for clients */
Xstruct timeval tp;		    /* Time (extra baggage) */
Xlong secondswest;		    /* Time zone offset in seconds */
X
X/*
X * Vendor magic cookies for CMU and RFC1048
X */
X
Xunsigned char vm_cmu[4]	    = VM_CMU;
Xunsigned char vm_rfc1048[4] = VM_RFC1048;
X
Xvoid report();
Xchar * get_errmsg();
Xextern void bootp_print();
Xextern struct ether_addr *ether_hostton();
X
X/*
X * Initialization such as command-line processing is done, then
X * the receiver loop is started.  Die when interrupted.
X */
X
Xmain(argc, argv)
X    int argc;
X    char **argv;
X{
X    struct timeval timenow;
X    struct bootp *bp = (struct bootp *) buf;
X    struct servent *sep;
X    struct hostent *hep;
X    
X    int n, tolen, fromlen;
X    int nfound, readfds;
X    char *servername = NULL;
X    char *vendor_file = NULL;
X    long server_addr = INADDR_ANY;
X    
X    program_name = argv[0];
X    
X    /* Get my Ethernet address for the query. */
X    gethostname(hostname, sizeof(hostname));
X    if (ether_hostton(hostname, &eaddr)) {
X	printf("Can not get my ethernet address\n");
X	exit(1);
X    }
X    
X    /* If server name given, query there, otherwise use broadcast. */
X    if (argc <= 1) {
X	printf("missing server name.\n");
X	puts(usage);
X	exit(1);
X    }
X    servername = argv[1];
X    
X    /* vendor-data-template-file */
X    if (argc > 2) vendor_file = argv[2];
X    
X    /*
X     * Create a socket.
X     */
X    if ((s = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
X	report(LOG_ERR, "socket: %s\n", get_network_errmsg());
X	exit(1);
X    }
X    
X    /*
X     * Determine network configuration.
X     */
X    ifconf.ifc_len = sizeof(ifreq);
X    ifconf.ifc_req = ifreq;
X    if ((ioctl(s, SIOCGIFCONF, (caddr_t) &ifconf) < 0) ||
X	(ifconf.ifc_len <= 0)) {
X	report(LOG_ERR, "ioctl: %s\n", get_network_errmsg());
X	exit(1);
X    }
X    /* Find the appropriate interface to use? */
X    
X    /*
X     * Get server's listening port number
X     */
X    sep = getservbyname("bootps", "udp");
X    if (sep) {
X	bootps_port = ntohs((u_short) sep->s_port);
X    } else {
X	report(LOG_ERR,
X	       "udp/bootps: unknown service -- assuming port %d\n",
X	       IPPORT_BOOTPS);
X	bootps_port = (u_short) IPPORT_BOOTPS;
X    }
X    
X    /*
X     * Set up server socket address.
X     */
X    if (servername) {
X	hep = gethostbyname(servername);
X	if (!hep) {
X	    report(LOG_ERR, "gethostbyname(%s)", servername);
X	    exit(1);
X	}
X	bcopy(hep->h_addr, &sin_server.sin_addr, sizeof(struct in_addr));
X    } else {
X	/* Get broadcast address */
X	/* XXX - not yet */
X	sin_server.sin_addr.s_addr = INADDR_ANY;
X    }
X    sin_server.sin_family = AF_INET;
X    sin_server.sin_port = htons(bootps_port);
X    
X    /*
X     * Get client's listening port number
X     */
X    sep = getservbyname("bootpc", "udp");
X    if (sep) {
X	bootpc_port = ntohs(sep->s_port);
X    } else {
X	report(LOG_ERR,
X	       "udp/bootpc: unknown service -- assuming port %d\n",
X	       IPPORT_BOOTPC);
X	bootpc_port = (u_short) IPPORT_BOOTPC;
X    }
X    
X    /*
X     * Set up client socket address.
X     */
X    sin_client.sin_family = AF_INET;
X    sin_client.sin_addr.s_addr = INADDR_ANY;
X    sin_client.sin_port = htons(bootpc_port);
X    
X    /*
X     * Bind client socket to BOOTPC port.
X     */
X    if (bind(s, &sin_client, sizeof(sin_client)) < 0) {
X	perror("bind BOOTPC port");
X	fprintf(stderr, "You need to run this as root\n");
X	exit(1);
X    }
X    
X    /*
X     * Build a request.
X     */
X    bzero(bp, sizeof(*bp));
X    bp->bp_op = BOOTREQUEST;
X    bp->bp_htype = 1;
X    bp->bp_hlen = 6;
X    bp->bp_xid = 2; 	/* arbitrary */
X    bp->bp_secs = 4;
X    
X    /*
X     * Make the request look like a broadcast type.
X     * (supply the hardware address, not the client IP address.)
X     */
X    bcopy(&eaddr, bp->bp_chaddr, sizeof(eaddr));
X    bp->bp_siaddr.s_addr = -1;	/* broadcast address */
X
X    /*
X     * Read in the "options" part of the request.
X     * This also determines the size of the packet.
X     */
X    snaplen = sizeof(*bp);
X    if (vendor_file) {
X	int fd = open(vendor_file, 0);
X	if (fd < 0) {
X	    perror(vendor_file);
X	    exit(1);
X	}
X	/* Compute actual space for options. */
X	n = BUFLEN - sizeof(*bp) + BP_VEND_LEN;
X	n = read(fd, bp->bp_vend, n);
X	close(fd);
X	if (n < 0) {
X	    perror(vendor_file);
X	    exit(1);
X	}
X	printf("read %d bytes of vendor template\n", n);
X	if (n > BP_VEND_LEN) {
X	    printf("warning: extended options in use (len > %d)\n",	
X		   BP_VEND_LEN);
X	    snaplen += (n - BP_VEND_LEN);
X	}
X    }
X    /* Set the end pointer for bootp_print() */
X    snapend = buf + snaplen;
X    
X    /* This is used by bootp_print() */
X    packetp = (unsigned char*) &eaddr;
X    
X    /* Print the request packet. */
X    printf("Request to %s", inet_ntoa(sin_server.sin_addr));
X    printf(" (port:%d)", bootps_port);
X    bootp_print(bp, snaplen, sin_from.sin_port, 0);
X    putchar('\n');
X    
X    if (sendto(s, buf, snaplen, 0,
X	       &sin_server, sizeof(sin_server)) < 0)
X    {
X	perror("sendto server");
X	exit(1);
X    }
X    
X    printf("Receiving...\n");
X    alarm(5);	/* XXX - OK? */
X    
X    while (1) {
X	
X	fromlen = sizeof(sin_from);
X	n = recvfrom(s, buf, sizeof(buf), 0, &sin_from, &fromlen);
X	if (n <= 0) {
X	    continue;
X	}
X	
X	if (n < sizeof(struct bootp)) {
X	    report(LOG_ERR, "received short packet\n");
X	    continue;
X	}
X	
X	/* Print the received packet. */
X	printf("Packet from %s", inet_ntoa(sin_from.sin_addr));
X	printf(" (port:%d)", ntohs(sin_from.sin_port));
X	snaplen = n;
X	snapend = buf + snaplen;
X	bootp_print(bp, n, sin_from.sin_port, 0);
X	putchar('\n');
X    }
X}
X
X
X
X/*
X * This routine reports errors and such via stderr and syslog() if
X * appopriate.  It just helps avoid a lot of "#ifdef SYSLOG" constructs
X * from being scattered throughout the code.
X *
X * The syntax is identical to syslog(3), but %m is not considered special
X * for output to stderr (i.e. you'll see "%m" in the output. . .).  Also,
X * control strings should normally end with \n since newlines aren't
X * automatically generated for stderr output (whereas syslog strips out all
X * newlines and adds its own at the end).
X */
X
X/*VARARGS2*/
Xvoid report(priority, fmt, p0, p1, p2, p3, p4)
X    int priority;
X    char *fmt;
X{
X    fprintf(stderr, "bootpd(pri=%d): ", priority);
X    fprintf(stderr, fmt, p0, p1, p2, p3, p4);
X}
X
X
X/*
X * Return pointer to static string which gives full filesystem error message.
X */
X
Xchar *get_errmsg()
X{
X    static char errmsg[80];
X    
X    if (errno < sys_nerr) {
X	return sys_errlist[errno];
X    } else {
X	sprintf(errmsg, "Error %d", errno);
X	return errmsg;
X    }
X}
X
X#ifndef etheraddr_string
Xchar *etheraddr_string(p)
X    char *p;
X{
X    static char buf[32];
X    sprintf(buf, "%x:%x:%x:%x:%x:%x",
X	    p[0],p[1],p[2],p[3],p[4],p[5]);
X    return(buf);
X}
X#endif
END_OF_FILE
if test 8202 -ne `wc -c <'bootptest.c'`; then
    echo shar: \"'bootptest.c'\" unpacked with wrong size!
fi
# end of 'bootptest.c'
fi
if test -f 'bootptest.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bootptest.man'\"
else
echo shar: Extracting \"'bootptest.man'\" \(1066 characters\)
sed "s/^X//" >'bootptest.man' <<'END_OF_FILE'
X.\" bootptest.1
X.TH BOOTPTEST 8 "10 June 1993" "MAINTENANCE COMMANDS"
X.SH NAME
Xbootptest \- send BOOTP queries and print responses
X.SH SYNOPSIS
X.LP
X.B bootptest
X.I server\-name
X.RI [ template-file ]
X.SH DESCRIPTION
X.B bootptest
Xsends a BOOTP query to the host specified as
X.I server\-name
Xand then waits for and prints out all responses
Xuntil an interrupt terminates the program.
X.LP
XThe
X.I template-file
Xmay be specified, in which case
X.B bootptest
Xuses the (binary) contents of this file to initialize the
X.I options
Xarea of the request packet.  This feature may be used to
Xverify that the BOOTP server correctly honors the format
Xof any option template provided in request packets.
X(All response packets should have exactly the same option
Xformat as the request packet if a template was provided.)
X.SH "SEE ALSO"
Xbootpd
X.SH REFERENCES
X.TP
XRFC951
XBOOTSTRAP PROTOCOL (BOOTP)
X.TP
XRFC1048
XBOOTP Vendor Information Extensions
X.TP
XIETF\-DHC\-BOOTP
XClarifications and Extensions for the Bootstrap Protocol
X.TP
XIETF\-DHC\-OPTIONS
XDHCP Options and BOOTP Vendor Extensions
END_OF_FILE
if test 1066 -ne `wc -c <'bootptest.man'`; then
    echo shar: \"'bootptest.man'\" unpacked with wrong size!
fi
# end of 'bootptest.man'
fi
if test -f 'interface.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'interface.h'\"
else
echo shar: Extracting \"'interface.h'\" \(845 characters\)
sed "s/^X//" >'interface.h' <<'END_OF_FILE'
X/* interface.h */
X
X/*
X * This is quite unusual, but allows bootptest to borrow print-bootp.c
X * from the tcpdump program without any changes whatsoever.
X *
X * This has been tested on SunOS 4.1.3 only.
X */
X
X#ifndef NTOHL
X#define NTOHL(x) x=ntohl(x)
X#define NTOHS(x) x=ntohs(x)
X#define HTONL(x) x=htonl(x)
X#define HTONS(x) x=htons(x)
X#endif
X
X#define inline /*sorry*/
X
X#define getname(p) inet_ntoa(p)
X#define etheraddr_string(p) ether_ntoa(p)
X
X/* We do not really have both Ethernet addresses. */
X#define ESRC(p) (p)
X#define EDST(p) (p)
X
Xextern int vflag, tflag;
Xextern int thiszone;
X
Xextern char *program_name; /* used to generate self-identifying messages */
X
Xextern int snaplen;
X
X/* global pointers to beginning and end of current packet (during printing) */
Xextern unsigned char *packetp;
Xextern unsigned char *snapend;
X
Xextern char *malloc();
END_OF_FILE
if test 845 -ne `wc -c <'interface.h'`; then
    echo shar: \"'interface.h'\" unpacked with wrong size!
fi
# end of 'interface.h'
fi
if test -f 'print-bootp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'print-bootp.c'\"
else
echo shar: Extracting \"'print-bootp.c'\" \(12363 characters\)
sed "s/^X//" >'print-bootp.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1988-1990 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that: (1) source code distributions
X * retain the above copyright notice and this paragraph in its entirety, (2)
X * distributions including binary code include the above copyright notice and
X * this paragraph in its entirety in the documentation or other materials
X * provided with the distribution, and (3) all advertising materials mentioning
X * features or use of this software display the following acknowledgement:
X * ``This product includes software developed by the University of California,
X * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
X * the University nor the names of its contributors may be used to endorse
X * or promote products derived from this software without specific prior
X * written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
X * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
X * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X *
X * Format and print bootp packets.
X */
X#ifndef lint
Xstatic char rcsid[] =
X    "@(#) $Header: print-bootp.c,v 1.17 91/11/14 22:21:34 leres Exp $ (LBL)";
X#endif
X
X#include <stdio.h>
X
X#include <sys/param.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <net/if.h>
X#include <netinet/in.h>
X#include <netinet/if_ether.h>
X#include <strings.h>
X#include <ctype.h>
X
X#include "interface.h"
X#include "addrtoname.h"
X#include "bootp.h"
X
X/* These decode the vendor data. */
Xstatic void rfc1048_print();
Xstatic void cmu_print();
Xstatic void other_print();
X
X/*
X * Print bootp requests
X */
Xvoid
Xbootp_print(bp, length, sport, dport)
X	register struct bootp *bp;
X	int length;
X	u_short sport, dport;
X{
X	static char tstr[] = " [|bootp]";
X	static unsigned char vm_cmu[4] = VM_CMU;
X	static unsigned char vm_rfc1048[4] = VM_RFC1048;
X	u_char *ep;
X	int vdlen;
X
X#define TCHECK(var, l) if ((u_char *)&(var) > ep - l) goto trunc
X
X	/* Note funny sized packets */
X	if (length != sizeof(struct bootp))
X		(void)printf(" [len=%d]", length);
X
X	/* 'ep' points to the end of avaible data. */
X	ep = (u_char *)snapend;
X
X	switch (bp->bp_op) {
X
X	case BOOTREQUEST:
X		/* Usually, a request goes from a client to a server */
X		if (sport != IPPORT_BOOTPC || dport != IPPORT_BOOTPS)
X			printf(" (request)");
X		break;
X
X	case BOOTREPLY:
X		/* Usually, a reply goes from a server to a client */
X		if (sport != IPPORT_BOOTPS || dport != IPPORT_BOOTPC)
X			printf(" (reply)");
X		break;
X
X	default:
X		printf(" bootp-#%d", bp->bp_op);
X	}
X
X	NTOHL(bp->bp_xid);
X	NTOHS(bp->bp_secs);
X
X	/* The usual hardware address type is 1 (10Mb Ethernet) */
X	if (bp->bp_htype != 1)
X		printf(" htype-#%d", bp->bp_htype);
X
X	/* The usual length for 10Mb Ethernet address is 6 bytes */
X	if (bp->bp_htype != 1 || bp->bp_hlen != 6)
X		printf(" hlen:%d", bp->bp_hlen);
X
X	/* Only print interesting fields */
X	if (bp->bp_hops)
X		printf(" hops:%d", bp->bp_hops);
X	if (bp->bp_xid)
X		printf(" xid:0x%x", bp->bp_xid);
X	if (bp->bp_secs)
X		printf(" secs:%d", bp->bp_secs);
X
X	/* Client's ip address */
X	TCHECK(bp->bp_ciaddr, sizeof(bp->bp_ciaddr));
X	if (bp->bp_ciaddr.s_addr)
X		printf(" C:%s", ipaddr_string(&bp->bp_ciaddr));
X
X	/* 'your' ip address (bootp client) */
X	TCHECK(bp->bp_yiaddr, sizeof(bp->bp_yiaddr));
X	if (bp->bp_yiaddr.s_addr)
X		printf(" Y:%s", ipaddr_string(&bp->bp_yiaddr));
X
X	/* Server's ip address */
X	TCHECK(bp->bp_siaddr, sizeof(bp->bp_siaddr));
X	if (bp->bp_siaddr.s_addr)
X		printf(" S:%s", ipaddr_string(&bp->bp_siaddr));
X
X	/* Gateway's ip address */
X	TCHECK(bp->bp_giaddr, sizeof(bp->bp_giaddr));
X	if (bp->bp_giaddr.s_addr)
X		printf(" G:%s", ipaddr_string(&bp->bp_giaddr));
X
X	/* Client's Ethernet address */
X	if (bp->bp_htype == 1 && bp->bp_hlen == 6) {
X		register struct ether_header *eh;
X		register char *e;
X
X		TCHECK(bp->bp_chaddr[0], 6);
X		eh = (struct ether_header *)packetp;
X		if (bp->bp_op == BOOTREQUEST)
X			e = (char *)ESRC(eh);
X		else if (bp->bp_op == BOOTREPLY)
X			e = (char *)EDST(eh);
X		else
X			e = 0;
X		if (e == 0 || bcmp((char *)bp->bp_chaddr, e, 6) != 0)
X			printf(" ether %s", etheraddr_string(bp->bp_chaddr));
X	}
X
X	TCHECK(bp->bp_sname[0], sizeof(bp->bp_sname));
X	if (*bp->bp_sname) {
X		printf(" sname ");
X		if (printfn(bp->bp_sname, ep)) {
X			fputs(tstr + 1, stdout);
X			return;
X		}
X	}
X	TCHECK(bp->bp_file[0], sizeof(bp->bp_file));
X	if (*bp->bp_file) {
X		printf(" file ");
X		if (printfn(bp->bp_file, ep)) {
X			fputs(tstr + 1, stdout);
X			return;
X		}
X	}
X
X	/* Don't try to decode the vendor buffer unless we're verbose */
X	if (vflag <= 0)
X		return;
X
X	vdlen = sizeof(bp->bp_vend);
X	/* Vendor data can extend to the end of the packet. */
X	if (vdlen < (ep - bp->bp_vend))
X		vdlen = (ep - bp->bp_vend);
X
X	TCHECK(bp->bp_vend[0], vdlen);
X	printf(" vend");
X	if (!bcmp(bp->bp_vend, vm_rfc1048, sizeof(u_long)))
X		rfc1048_print(bp->bp_vend, vdlen);
X	else if (!bcmp(bp->bp_vend, vm_cmu, sizeof(u_long)))
X		cmu_print(bp->bp_vend, vdlen);
X	else
X		other_print(bp->bp_vend, vdlen);
X
X	return;
Xtrunc:
X	fputs(tstr, stdout);
X#undef TCHECK
X}
X
Xstruct rfc1048dscr {
X    int fmt;	/* option data format (see below). */
X    char *name;
X};
X/* Flags used in the format descriptor field: */
X#define ODF_LIST	0x100	/* multiples of size allowed */
X#define ODF_CHAR	0x200	/* interpret as ASCII */
X#define ODF_INET	0x400	/* interpret as INET address */
X/* Values for the option data format:  */
X#define ODF_OTHER	1|ODF_LIST	/* unknown data format */
X#define ODF_BYTE	1			/* exactly 1 byte */
X#define ODF_STRING	1|ODF_CHAR|ODF_LIST
X#define ODF_SHORT	2			/* short (2 bytes) */
X#define ODF_SLIST	2|ODF_LIST	/* list of shorts */
X#define ODF_LONG	4			/* long (4 bytes) */
X#define ODF_INADDR	4|ODF_INET	/* inet address (just one) */
X#define ODF_INALST	4|ODF_INET|ODF_LIST /* list of addresses */
X
X/*
X * These come from RFC-1048 and the IETF draft:
X *	DHCP Options and BOOTP Vendor Extensions
X */
Xstruct rfc1048dscr
Xrfc1048_opts[] = {
X    /* These come from RFC-1048: */
X    ODF_OTHER,	"PAD",	/*  0: Padding - special, no data. */
X    ODF_INADDR,	"SM",	/*  1: subnet mask (RFC950)*/
X    ODF_LONG,	"TZ",	/*  2: time offset, seconds from UTC */
X    ODF_INALST,	"GW",	/*  3: gateways (or routers) */
X    ODF_INALST,	"TS",	/*  4: time servers (RFC868) */
X    ODF_INALST,	"INS",	/*  5: IEN name servers (IEN116) */
X    ODF_INALST,	"DNS",	/*  6: domain name servers (RFC1035) */
X    ODF_INALST,	"LOG",	/*  7: MIT log servers */
X    ODF_INALST,	"CS",	/*  8: cookie servers (RFC865) */
X    ODF_INALST,	"LPR",	/*  9: lpr server (RFC1179) */
X    ODF_INALST,	"IPS",	/* 10: impress servers (Imagen) */
X    ODF_INALST,	"RLP",	/* 11: resource location servers (RFC887) */
X    ODF_STRING,	"HN",	/* 12: host name (ASCII) */
X    ODF_SHORT,	"BFS",	/* 13: boot file size (in 512 byte blocks) */
X    /*
X     * These come from the IETF draft:
X     * DHCP Options and BOOTP Vendor Extensions
X     */
X    ODF_STRING,	"YPD",  /* 14: NIS domain name (Sun YP) */
X    ODF_INALST,	"YPS",  /* 15: NIS servers (Sun YP) */
X    ODF_INALST,	"NTP",	/* 16: Network Time Protocol servers */
X
X#if 0	/* The rest are not worth recognizing by name. */
X
X    /* IP parameters, per-host */
X    ODF_BYTE,	"IP-forward",	/* 17: IP Forwarding flag */
X    ODF_BYTE,	"IP-srcroute",	/* 18: IP Source Routing Enable flag */
X    ODF_INALST,	"IP-filters",	/* 19: IP Policy Filter (addr pairs) */
X    ODF_SHORT,	"IP-maxudp",	/* 20: IP Max-UDP reassembly size */
X    ODF_BYTE,	"IP-ttlive",	/* 21: IP Time to Live */
X    ODF_LONG,	"IP-pmtuage",	/* 22: IP Path MTU aging timeout */
X    ODF_SLIST,	"IP-pmtutab",	/* 23: IP Path MTU size table */
X
X    /* IP parameters, per-interface */
X    ODF_SHORT,	"IP-mtu-sz",	/* 24: IP MTU size */
X    ODF_BYTE,	"IP-mtu-sl",	/* 25: IP MTU all subnets local */
X    ODF_BYTE,	"IP-brc1",	/* 26: IP Broadcast Addr ones flag */
X    ODF_BYTE,	"IP-mask-d",	/* 27: IP do mask discovery */
X    ODF_BYTE,	"IP-mask-s",	/* 28: IP do mask supplier */
X    ODF_BYTE,	"IP-rt-disc",	/* 29: IP do router discovery */
X    ODF_INADDR,	"IP-rt-sa",	/* 30: IP router solicitation addr */
X    ODF_INALST,	"IP-routes",	/* 31: IP static routes (dst,router) */
X
X    /* Link Layer parameters, per-interface */
X    ODF_BYTE,	"LL-trailer",	/* 32: do tralier encapsulation */
X    ODF_LONG,	"LL-arp-tmo",	/* 33: ARP cache timeout */
X    ODF_BYTE,	"LL-ether2",	/* 34: Ethernet version 2 (IEEE 802.3) */
X
X    /* TCP parameters */
X    ODF_BYTE,	"TCP-def-ttl",	/* 35: default time to live */
X    ODF_LONG,	"TCP-KA-tmo",	/* 36: keepalive time interval */
X    ODF_BYTE,	"TCP-KA-junk",	/* 37: keepalive sends extra junk */
X
X    /* Dynamic Host Configuration Protocol (DHCP) extensions */
X    /* todo... */
X#endif
X};
X#define	KNOWN_OPTIONS (sizeof(rfc1048_opts) / sizeof(rfc1048_opts[0]))
X
Xstatic void
Xrfc1048_print(bp, length)
X	register u_char *bp;
X	int length;
X{
X	u_char tag;
X	u_char *ep;
X	register int len, j;
X	u_long ul;
X	u_short us;
X	int fmt;
X
X	printf("-rfc1048");
X
X	/* Step over magic cookie */
X	bp += sizeof(long);
X	/* Setup end pointer */
X	ep = bp + length;
X	while (bp < ep) {
X		tag = *bp++;
X		/* Check for tags with no data first. */
X		if (tag == TAG_PAD)
X			continue;
X		if (tag == TAG_END)
X			return;
X		if (tag < KNOWN_OPTIONS) {
X			printf(" %s", rfc1048_opts[tag].name);
X			fmt = rfc1048_opts[tag].fmt;
X		} else {
X			printf(" opt%d", tag);
X			fmt = ODF_OTHER;
X		}
X		/* Now scan the length byte. */
X		len = *bp++;
X		if (bp + len > ep) {
X			/* truncated option */
X			printf(" |(%d>%d)", len, ep-bp);
X			return;
X		}
X		while (len > 0) {
X			switch (rfc1048_opts[tag].fmt & 3) {
X			case 1:
X			case 3:
X				/* Byte formats */
X				if (len > 1) printf("(L=%d)", len);
X				if (fmt & ODF_CHAR) {
X					printfn(bp, bp + len);
X					bp += len;
X					len = 0;
X					break;
X				}
X				printf(":%d", *bp++); len--;
X				if (fmt & ODF_LIST) {
X					while (len--) printf(".%d", *bp++);
X				}
X				break;
X
X			case 2:
X				/* Word formats */
X				while (len >= 2) {
X					bcopy((char*)bp, (char*)&us, 2);
X					printf(":%d", ntohs(us));
X					bp += 2;
X					len -= 2;
X					/* break if not list? */
X				}
X				break;
X
X			case 0:
X				/* Longword formats */
X				while (len >= 4) {
X					bcopy((char*)bp, (char*)&ul, 4);
X					if (fmt & ODF_INET)
X						printf(":%s", ipaddr_string(&ul));
X					else
X						printf(":%d", ntohs(us));
X					bp += 4;
X					len -= 4;
X					/* break if not list? */
X				}
X				break;
X
X			} /* switch (fmt & 3) */
X
X			if (len) {
X				printf("(junk)");
X				bp += len;
X				len = 0;
X			}
X
X		} /* while len > 0 */
X	} /* while bp < ep */
X}
X
Xstatic void
Xcmu_print(bp, length)
X	register u_char *bp;
X	int length;
X{
X	struct cmu_vend *v;
X	u_char *ep;
X
X	printf("-cmu");
X
X	v = (struct cmu_vend *) bp;
X	if (length < sizeof(*v)) {
X		printf(" |L=%d", length);
X		return;
X	}
X
X	/* Setup end pointer */
X	ep = bp + length;
X
X	/* Subnet mask */
X	if (v->v_flags & VF_SMASK) {
X		printf(" SM:%s", ipaddr_string(&v->v_smask.s_addr));
X	}
X
X	/* Default gateway */
X	if (v->v_dgate.s_addr)
X		printf(" GW:%s", ipaddr_string(&v->v_dgate.s_addr));
X
X	/* Domain name servers */
X	if (v->v_dns1.s_addr)
X		printf(" DNS1:%s", ipaddr_string(&v->v_dns1.s_addr));
X	if (v->v_dns2.s_addr)
X		printf(" DNS2:%s", ipaddr_string(&v->v_dns2.s_addr));
X
X	/* IEN-116 name servers */
X	if (v->v_ins1.s_addr)
X		printf(" INS1:%s", ipaddr_string(&v->v_ins1.s_addr));
X	if (v->v_ins2.s_addr)
X		printf(" INS2:%s", ipaddr_string(&v->v_ins2.s_addr));
X
X	/* Time servers */
X	if (v->v_ts1.s_addr)
X		printf(" TS1:%s", ipaddr_string(&v->v_ts1.s_addr));
X	if (v->v_ts2.s_addr)
X		printf(" TS2:%s", ipaddr_string(&v->v_ts2.s_addr));
X
X}
X
X
X/*
X * Print out arbitrary, unknown vendor data.
X */
X
Xstatic void
Xother_print(bp, length)
X	register u_char *bp;
X	int length;
X{
X	u_char *ep;		/* end pointer */
X	u_char *zp; 	/* points one past last non-zero byte */
X	register int i, j;
X
X	/* Setup end pointer */
X	ep = bp + length;
X
X	/* Find the last non-zero byte. */
X	for (zp = ep; zp > bp; zp--) {
X		if (zp[-1] != 0) break;
X	}
X
X	/* Print the all-zero case in a compact representation. */
X	if (zp == bp) {
X		printf("-all-zero");
X		return;
X	}
X
X	printf("-unknown");
X
X	/* Are there enough trailing zeros to make "00..." worthwhile? */
X	if (zp + 2 > ep)
X		zp = ep; /* print them all normally */
X
X	/* Now just print all the non-zero data. */
X	while (bp < zp) {
X		printf(".%02X", *bp);
X		bp++;
X	}
X
X	if (zp < ep)
X		printf(".00...");
X
X	return;
X}
X		
END_OF_FILE
if test 12363 -ne `wc -c <'print-bootp.c'`; then
    echo shar: \"'print-bootp.c'\" unpacked with wrong size!
fi
# end of 'print-bootp.c'
fi
if test -f 'util.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util.c'\"
else
echo shar: Extracting \"'util.c'\" \(5053 characters\)
sed "s/^X//" >'util.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1988-1990 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that: (1) source code distributions
X * retain the above copyright notice and this paragraph in its entirety, (2)
X * distributions including binary code include the above copyright notice and
X * this paragraph in its entirety in the documentation or other materials
X * provided with the distribution, and (3) all advertising materials mentioning
X * features or use of this software display the following acknowledgement:
X * ``This product includes software developed by the University of California,
X * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of
X * the University nor the names of its contributors may be used to endorse
X * or promote products derived from this software without specific prior
X * written permission.
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
X * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
X * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X
X#ifndef lint
Xstatic char rcsid[] =
X    "@(#) $Header: util.c,v 1.12 91/10/28 22:09:31 mccanne Exp $ (LBL)";
X#endif
X
X#include <stdio.h>
X#ifdef __STDC__
X#include <stdlib.h>
X#endif
X#include <sys/types.h>
X#include <sys/time.h>
X#include <ctype.h>
X#include <varargs.h>
X#include <sys/file.h>
X#include <sys/stat.h>
X
X#include "interface.h"
X
X/* Hex digit to integer. */
Xstatic inline int
Xxdtoi(c)
X{
X	if (isdigit(c))
X		return c - '0';
X	else if (islower(c))
X		return c - 'a' + 10;
X	else
X		return c - 'A' + 10;
X}
X
X/*
X * Convert string to integer.  Just like atoi(), but checks for 
X * preceding 0x or 0 and uses hex or octal instead of decimal.
X */
Xint
Xstoi(s)
X	char *s;
X{
X	int base = 10;
X	int n = 0;
X
X	if (*s == '0') {
X		if (s[1] == 'x' || s[1] == 'X') {
X			s += 2;
X			base = 16;
X		}
X		else {
X			base = 8;
X			s += 1;
X		}
X	}
X	while (*s)
X		n = n * base + xdtoi(*s++);
X
X	return n;
X}
X
X/*
X * Print out a filename (or other ascii string).
X * Return true if truncated.
X */
Xint
Xprintfn(s, ep)
X	register u_char *s, *ep;
X{
X	register u_char c;
X
X	putchar('"');
X	while (c = *s++) {
X		if (s > ep) {
X			putchar('"');
X			return(1);
X		}
X		if (!isascii(c)) {
X			c = toascii(c);
X			putchar('M');
X			putchar('-');
X		}
X		if (!isprint(c)) {
X			c ^= 0x40;	/* DEL to ?, others to alpha */
X			putchar('^');
X		}
X		putchar(c);
X	}
X	putchar('"');
X	return(0);
X}
X
X/*
X * Print the timestamp
X */
Xvoid
Xts_print(tvp)
X	register struct timeval *tvp;
X{
X	register int i;
X
X	if (tflag > 0) {
X		/* Default */
X		i = (tvp->tv_sec + thiszone) % 86400;
X		(void)printf("%02d:%02d:%02d.%06d ",
X		    i / 3600, (i % 3600) / 60, i % 60, tvp->tv_usec);
X	} else if (tflag < 0) {
X		/* Unix timeval style */
X		(void)printf("%d.%06d ", tvp->tv_sec, tvp->tv_usec);
X	}
X}
X
X#ifdef NOVFPRINTF
X/*
X * Stock 4.3 doesn't have vfprintf. 
X * This routine is due to Chris Torek.
X */
Xvfprintf(f, fmt, args)
X	FILE *f;
X	char *fmt;
X	va_list args;
X{
X	int ret;
X
X	if ((f->_flag & _IOWRT) == 0) {
X		if (f->_flag & _IORW)
X			f->_flag |= _IOWRT;
X		else
X			return EOF;
X	}
X	ret = _doprnt(fmt, args, f);
X	return ferror(f) ? EOF : ret;
X}
X#endif
X
Xstatic char *
Xstripdir(s)
X	register char *s;
X{
X	register char *cp;
X	char *rindex();
X
X	cp = rindex(s, '/');
X	return (cp != 0) ? cp + 1 : s;
X}
X
X/* VARARGS */
Xvoid
Xerror(va_alist)
X	va_dcl
X{
X	register char *cp;
X	va_list ap;
X
X	(void)fprintf(stderr, "%s: ", stripdir(program_name));
X
X	va_start(ap);
X	cp = va_arg(ap, char *);
X	(void)vfprintf(stderr, cp, ap);
X	va_end(ap);
X	if (*cp) {
X		cp += strlen(cp);
X		if (cp[-1] != '\n')
X			(void)fputc('\n', stderr);
X	}
X	exit(1);
X	/* NOTREACHED */
X}
X
X/* VARARGS */
Xvoid
Xwarning(va_alist)
X	va_dcl
X{
X	register char *cp;
X	va_list ap;
X
X	(void)fprintf(stderr, "%s: warning: ", stripdir(program_name));
X
X	va_start(ap);
X	cp = va_arg(ap, char *);
X	(void)vfprintf(stderr, cp, ap);
X	va_end(ap);
X	if (*cp) {
X		cp += strlen(cp);
X		if (cp[-1] != '\n')
X			(void)fputc('\n', stderr);
X	}
X}
X
X
X/*
X * Copy arg vector into a new buffer, concatenating arguments with spaces.
X */
Xchar *
Xcopy_argv(argv)
X	register char **argv;
X{
X	register char **p;
X	register int len = 0;
X	char *buf;
X	char *src, *dst;
X
X	p = argv;
X	if (*p == 0)
X		return 0;
X
X	while (*p)
X		len += strlen(*p++) + 1;
X
X	buf = malloc(len);
X
X	p = argv;
X	dst = buf;
X	while (src = *p++) {
X		while (*dst++ = *src++)
X			;
X		dst[-1] = ' ';
X	}
X	dst[-1] = '\0';
X
X	return buf;
X}
X
Xchar *
Xread_infile(fname)
X	char *fname;
X{
X	struct stat buf;
X	int fd;
X	char *p;
X
X	fd = open(fname, O_RDONLY);
X	if (fd < 0)
X		error("can't open '%s'", fname);
X
X	if (fstat(fd, &buf) < 0)
X		error("can't state '%s'", fname);
X
X	p = malloc((unsigned)buf.st_size);
X	if (read(fd, p, (int)buf.st_size) != buf.st_size)
X		error("problem reading '%s'", fname);
X	
X	return p;
X}
X
X/*
X * Left justify 'addr' and return its resulting network mask.
X */
Xu_long
Xnet_mask(addr)
X	u_long *addr;
X{
X	register u_long m = 0xffffffff;
X
X	if (*addr)
X		while ((*addr & 0xff000000) == 0)
X			*addr <<= 8, m <<= 8;
X
X	return m;
X}
END_OF_FILE
if test 5053 -ne `wc -c <'util.c'`; then
    echo shar: \"'util.c'\" unpacked with wrong size!
fi
# end of 'util.c'
fi
if test -f 'vdgencmu.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vdgencmu.c'\"
else
echo shar: Extracting \"'vdgencmu.c'\" \(248 characters\)
sed "s/^X//" >'vdgencmu.c' <<'END_OF_FILE'
X
X/* This program creates an option template file in CMU format. */
X
Xstruct in_addr { long s_addr; };
X
X#include "bootp.h"
X
Xstruct cmu_vend vend = {
X	"CMU",	/* magic number for CMU data */
X	0
X};
X
X
Xmain() {
X	write(1, &vend, sizeof(vend));
X	exit(0);
X}
END_OF_FILE
if test 248 -ne `wc -c <'vdgencmu.c'`; then
    echo shar: \"'vdgencmu.c'\" unpacked with wrong size!
fi
# end of 'vdgencmu.c'
fi
if test -f 'vdgenstd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vdgenstd.c'\"
else
echo shar: Extracting \"'vdgenstd.c'\" \(665 characters\)
sed "s/^X//" >'vdgenstd.c' <<'END_OF_FILE'
X
X/* This program creates an option template file in RFC 1048 format. */
X
Xstruct in_addr { long s_addr; };
X
X#include "bootp.h"
X
X/* Note that this template uses padding to keep data aligned. */
Xchar vend[] = {
X	/* magic number for RFC1048 data */
X	99, 130, 83, 99,
X
X	/* netmask */
X	0,0,1,4,
X	0,0,0,0,
X
X	/* gateway list */
X	0,0,3,4,
X	0,0,0,0,
X
X	/* hostname */
X	0,0, 12, 16,
X	0,0,0,0,
X	0,0,0,0,
X	0,0,0,0,
X	0,0,0,0,
X
X	/* DNS list */
X	0,0,6,8,
X	0,0,0,0,
X	0,0,0,0,
X
X#if 1
X
X	/* NIS server list */
X	0,0, 15, 4,
X	0,0,0,0,
X
X	/* NIS domain name */
X	0,0, 14, 12,
X	0,0,0,0,
X	0,0,0,0,
X	0,0,0,0,
X
X#endif
X
X	/* end */
X	255, 0
X};
X
X
Xmain() {
X	write(1, vend, sizeof(vend));
X	exit(0);
X}
END_OF_FILE
if test 665 -ne `wc -c <'vdgenstd.c'`; then
    echo shar: \"'vdgenstd.c'\" unpacked with wrong size!
fi
# end of 'vdgenstd.c'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
