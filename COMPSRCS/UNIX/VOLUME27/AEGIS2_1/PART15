Newsgroups: comp.sources.unix
From: pmiller@bmr.gov.au (Peter Miller)
Subject: v27i050: aegis - project change supervisor (V2.1), Part15/19
References: <1.748951883.12788@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: pmiller@bmr.gov.au (Peter Miller)
Posting-Number: Volume 27, Issue 50
Archive-Name: aegis-2.1/part15

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 15 (of 19)."
# Contents:  Makefile aegis/sub.c doc/c2.1.so
# Wrapped by vixie@gw.home.vix.com on Sat Sep 25 03:00:52 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(46616 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#
X# You may need to change this for your system.
X# The ``h'' directory supplements your system, not replacing it.
X# The first variation is for gcc when it isn't the native complier,
X# the second variation is for systems with missing ANSI C include files,
X# the third variation is for conforming ANSI C implementations.
X#
X# H = -I/usr/local/lib/gcc-include -I/usr/include -Ih
X# H = -I/usr/include -Ih
XH =
X# H =				# SunOS
X# H =				# ConvexOS
X# H =				# dgux
X# H =				# dcosx (pyramid)
X# H =				# ULTRIX
X# H =				# hpux
X# H =				# SCO
X# H =				# IRIX
X
X#
X# the name of the compiler to use
X#
XCC = cc
X# CC = gcc
X# CC = cc			# SunOS
X# CC = cc			# ConvexOS
X# CC = cc			# dgux
X# CC = /usr/ucb/cc		# dcosx (pyramid)
X# CC = cc			# ULTRIX
X# CC = cc			# hpux
X# CC = rcc			# SCO
X# CC = cc			# IRIX
X
X#
X# The compiler flags to use, except for include path.
X#
XCFLAGS = -O
X# CFLAGS = -g
X# CFLAGS = -O			# SunOS
X# CFLAGS = -O			# ConvexOS
X# CFLAGS = -O			# dgux
X# CFLAGS = -O -Wall -ansi	# gcc
X# CFLAGS = -O -Xt -U__STDC__	# dcosx (pyramid /usr/ucb/cc is brain-dead)
X# CFLAGS = -O			# ULTRIX
X# CFLAGS = -O			# hpux
X# CFLAGS = -O			# SCO
X# CFLAGS = -O			# IRIX
X
X#
X# which yacc to use
X#
XYACC = yacc
X# YACC = byacc			# Berkeley
X# YACC = bison -y		# GNU
X
X#
X# where to put the library directory
X#	(not used in testing mode)
X#
XLIB = /usr/local/lib/aegis
X
X#
X# where to put the executables
X#
XBIN = /usr/local/bin
X
X#
X# where to put the manual entries
X#
XMAN = /usr/local/man
X
X#
X# extra libraries required for your system
X#
XLIBRARIES =
X# LIBRARIES = -lbsd
X# LIBRARIES =			# SunOS
X# LIBRARIES =			# ConvexOS
X# LIBRARIES =			# dgux
X# LIBRARIES = -lucb		# dcosx (pyramid)
X# LIBRARIES =			# ULTRIX
X# LIBRARIES =			# hpux
X# LIBRARIES = -lsocket		# SCO
X# LIBRARIES =			# IRIX
X
X#
X# shell to use to run the tests
X#	make sure there are no spaces after the definition,
X#	many flavours of make(1) can't cope with them.
X#
XSHELL = /bin/sh
X# SHELL = /bin/sh		# SunOS
X# SHELL = /bin/sh		# ConvexOS
X# SHELL = /bin/sh		# dgux
X# SHELL = /bin/sh		# dcosx (pyramid)
X# SHELL = /bin/sh5		# ULTRIX
X# SHELL = /bin/ksh		# apollo
X# SHELL = /bin/sh		# hpux
X# SHELL = /bin/sh		# SCO
X# SHELL = /bin/sh		# IRIX
X
X# You should not need to alter anything below this point.
X#------------------------------------------------------------
X
Xall: bin/aegis
X
X
Xaegis/aeb.o: aegis/aeb.c aegis/aeb.h common/main.h aegis/ael.h \
X		aegis/arglex2.h common/arglex.h aegis/col.h \
X		aegis/commit.h common/str.h common/s-v-arg.h \
X		common/conf.h aegis/change.h aegis/cstate.h \
X		aegis/type.h aegis/parse.h aegis/pconf.h common/error.h \
X		aegis/help.h aegis/lock.h aegis/log.h common/option.h \
X		aegis/os.h aegis/project.h aegis/pstate.h aegis/pattr.h \
X		aegis/sub.h common/trace.h aegis/user.h aegis/ustate.h \
X		aegis/uconf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aeb.c
X	mv aeb.o aegis/aeb.o
X
Xaegis/aeca.o: aegis/aeca.c aegis/aeca.h aegis/cattr.h common/main.h \
X		aegis/type.h common/str.h common/s-v-arg.h \
X		common/conf.h aegis/parse.h aegis/arglex2.h \
X		common/arglex.h aegis/commit.h aegis/change.h \
X		aegis/cstate.h aegis/pconf.h common/error.h \
X		aegis/help.h aegis/lock.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h common/option.h aegis/os.h \
X		common/trace.h aegis/user.h aegis/ustate.h \
X		aegis/uconf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aeca.c
X	mv aeca.o aegis/aeca.o
X
Xaegis/aecd.o: aegis/aecd.c aegis/aecd.h common/main.h aegis/ael.h \
X		aegis/arglex2.h common/arglex.h aegis/change.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h common/error.h aegis/help.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h common/trace.h \
X		aegis/user.h aegis/ustate.h aegis/uconf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aecd.c
X	mv aecd.o aegis/aecd.o
X
Xaegis/aecp.o: aegis/aecp.c aegis/aecp.h common/main.h aegis/ael.h \
X		aegis/arglex2.h common/arglex.h aegis/commit.h \
X		common/str.h common/s-v-arg.h common/conf.h \
X		aegis/change.h aegis/cstate.h aegis/type.h \
X		aegis/parse.h aegis/pconf.h common/error.h aegis/file.h \
X		aegis/help.h aegis/lock.h aegis/log.h common/option.h \
X		aegis/os.h aegis/project.h aegis/pstate.h aegis/pattr.h \
X		common/trace.h aegis/undo.h aegis/user.h aegis/ustate.h \
X		aegis/uconf.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aecp.c
X	mv aecp.o aegis/aecp.o
X
Xaegis/aecpu.o: aegis/aecpu.c aegis/aecpu.h common/main.h aegis/ael.h \
X		aegis/arglex2.h common/arglex.h aegis/commit.h \
X		common/str.h common/s-v-arg.h common/conf.h \
X		aegis/change.h aegis/cstate.h aegis/type.h \
X		aegis/parse.h aegis/pconf.h common/error.h aegis/file.h \
X		aegis/help.h aegis/lock.h aegis/log.h common/option.h \
X		aegis/os.h aegis/project.h aegis/pstate.h aegis/pattr.h \
X		common/trace.h aegis/undo.h aegis/user.h aegis/ustate.h \
X		aegis/uconf.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aecpu.c
X	mv aecpu.o aegis/aecpu.o
X
Xaegis/aed.o: aegis/aed.c aegis/aed.h common/main.h aegis/ael.h \
X		aegis/arglex2.h common/arglex.h aegis/change.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h aegis/col.h aegis/commit.h common/error.h \
X		aegis/help.h aegis/lock.h aegis/log.h common/option.h \
X		aegis/os.h aegis/project.h aegis/pstate.h aegis/pattr.h \
X		aegis/sub.h common/trace.h aegis/undo.h aegis/user.h \
X		aegis/ustate.h aegis/uconf.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aed.c
X	mv aed.o aegis/aed.o
X
Xaegis/aedb.o: aegis/aedb.c aegis/aedb.h common/main.h aegis/ael.h \
X		aegis/arglex2.h common/arglex.h aegis/change.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h aegis/col.h aegis/commit.h aegis/common.h \
X		aegis/dir.h common/error.h aegis/help.h aegis/lock.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h aegis/sub.h common/trace.h \
X		aegis/undo.h aegis/user.h aegis/ustate.h aegis/uconf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aedb.c
X	mv aedb.o aegis/aedb.o
X
Xaegis/aedbu.o: aegis/aedbu.c aegis/aedbu.h common/main.h aegis/ael.h \
X		aegis/arglex2.h common/arglex.h aegis/change.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h aegis/col.h aegis/commit.h aegis/common.h \
X		aegis/dir.h common/error.h aegis/help.h aegis/lock.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h aegis/sub.h common/trace.h \
X		aegis/undo.h aegis/user.h aegis/ustate.h aegis/uconf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aedbu.c
X	mv aedbu.o aegis/aedbu.o
X
Xaegis/aede.o: aegis/aede.c aegis/aede.h common/main.h aegis/ael.h \
X		aegis/arglex2.h common/arglex.h aegis/change.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h aegis/col.h aegis/commit.h aegis/common.h \
X		aegis/dir.h common/error.h aegis/help.h aegis/lock.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h aegis/sub.h common/trace.h \
X		aegis/undo.h aegis/user.h aegis/ustate.h aegis/uconf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aede.c
X	mv aede.o aegis/aede.o
X
Xaegis/aedeu.o: aegis/aedeu.c aegis/aedeu.h common/main.h aegis/ael.h \
X		aegis/arglex2.h common/arglex.h aegis/change.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h aegis/col.h aegis/commit.h aegis/common.h \
X		aegis/dir.h common/error.h aegis/help.h aegis/lock.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h aegis/sub.h common/trace.h \
X		aegis/undo.h aegis/user.h aegis/ustate.h aegis/uconf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aedeu.c
X	mv aedeu.o aegis/aedeu.o
X
Xaegis/aeib.o: aegis/aeib.c aegis/aeib.h common/main.h aegis/ael.h \
X		aegis/arglex2.h common/arglex.h aegis/commit.h \
X		common/str.h common/s-v-arg.h common/conf.h \
X		aegis/change.h aegis/cstate.h aegis/type.h \
X		aegis/parse.h aegis/pconf.h aegis/dir.h common/error.h \
X		aegis/file.h aegis/help.h aegis/lock.h aegis/log.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h aegis/sub.h common/trace.h \
X		aegis/undo.h aegis/user.h aegis/ustate.h aegis/uconf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aeib.c
X	mv aeib.o aegis/aeib.o
X
Xaegis/aeibu.o: aegis/aeibu.c aegis/aeibu.h common/main.h aegis/ael.h \
X		aegis/arglex2.h common/arglex.h aegis/commit.h \
X		common/str.h common/s-v-arg.h common/conf.h \
X		aegis/change.h aegis/cstate.h aegis/type.h \
X		aegis/parse.h aegis/pconf.h aegis/dir.h common/error.h \
X		aegis/file.h aegis/help.h aegis/lock.h aegis/log.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h aegis/sub.h common/trace.h \
X		aegis/undo.h aegis/user.h aegis/ustate.h aegis/uconf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aeibu.c
X	mv aeibu.o aegis/aeibu.o
X
Xaegis/aeif.o: aegis/aeif.c aegis/aeif.h common/main.h aegis/ael.h \
X		aegis/arglex2.h common/arglex.h aegis/commit.h \
X		common/str.h common/s-v-arg.h common/conf.h \
X		aegis/change.h aegis/cstate.h aegis/type.h \
X		aegis/parse.h aegis/pconf.h aegis/dir.h common/error.h \
X		aegis/file.h aegis/help.h aegis/lock.h aegis/log.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h aegis/sub.h common/trace.h \
X		aegis/undo.h aegis/user.h aegis/ustate.h aegis/uconf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aeif.c
X	mv aeif.o aegis/aeif.o
X
Xaegis/aeip.o: aegis/aeip.c aegis/aeip.h common/main.h aegis/ael.h \
X		aegis/arglex2.h common/arglex.h aegis/commit.h \
X		common/str.h common/s-v-arg.h common/conf.h \
X		aegis/change.h aegis/cstate.h aegis/type.h \
X		aegis/parse.h aegis/pconf.h aegis/dir.h common/error.h \
X		aegis/file.h aegis/help.h aegis/lock.h aegis/log.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h aegis/sub.h common/trace.h \
X		aegis/undo.h aegis/user.h aegis/ustate.h aegis/uconf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aeip.c
X	mv aeip.o aegis/aeip.o
X
Xaegis/ael.o: aegis/ael.c aegis/ael.h common/main.h aegis/arglex2.h \
X		common/arglex.h aegis/col.h aegis/change.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h common/error.h aegis/gonzo.h \
X		aegis/gstate.h aegis/help.h aegis/lock.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h common/trace.h \
X		aegis/user.h aegis/ustate.h aegis/uconf.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/ael.c
X	mv ael.o aegis/ael.o
X
Xaegis/aemv.o: aegis/aemv.c aegis/ael.h common/main.h aegis/aemv.h \
X		aegis/arglex2.h common/arglex.h aegis/change.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h aegis/commit.h common/error.h \
X		aegis/file.h aegis/help.h aegis/lock.h aegis/log.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h common/trace.h \
X		aegis/user.h aegis/ustate.h aegis/uconf.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aemv.c
X	mv aemv.o aegis/aemv.o
X
Xaegis/aena.o: aegis/aena.c aegis/aena.h common/main.h aegis/ael.h \
X		aegis/arglex2.h common/arglex.h aegis/commit.h \
X		common/str.h common/s-v-arg.h common/conf.h \
X		common/error.h aegis/help.h aegis/lock.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/type.h aegis/parse.h aegis/pattr.h \
X		common/trace.h aegis/user.h aegis/ustate.h \
X		aegis/uconf.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aena.c
X	mv aena.o aegis/aena.o
X
Xaegis/aenc.o: aegis/aenc.c aegis/aeca.h aegis/cattr.h common/main.h \
X		aegis/type.h common/str.h common/s-v-arg.h \
X		common/conf.h aegis/parse.h aegis/aenc.h aegis/ael.h \
X		aegis/arglex2.h common/arglex.h aegis/change.h \
X		aegis/cstate.h aegis/pconf.h aegis/col.h aegis/commit.h \
X		aegis/common.h common/error.h aegis/help.h aegis/lock.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h common/trace.h \
X		aegis/user.h aegis/ustate.h aegis/uconf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aenc.c
X	mv aenc.o aegis/aenc.o
X
Xaegis/aencu.o: aegis/aencu.c aegis/aeca.h aegis/cattr.h common/main.h \
X		aegis/type.h common/str.h common/s-v-arg.h \
X		common/conf.h aegis/parse.h aegis/ael.h aegis/aencu.h \
X		aegis/arglex2.h common/arglex.h aegis/change.h \
X		aegis/cstate.h aegis/pconf.h aegis/col.h aegis/commit.h \
X		aegis/common.h common/error.h aegis/help.h aegis/lock.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h common/trace.h \
X		aegis/user.h aegis/ustate.h aegis/uconf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aencu.c
X	mv aencu.o aegis/aencu.o
X
Xaegis/aend.o: aegis/aend.c aegis/ael.h common/main.h aegis/aend.h \
X		aegis/arglex2.h common/arglex.h aegis/commit.h \
X		common/str.h common/s-v-arg.h common/conf.h \
X		common/error.h aegis/help.h aegis/lock.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/type.h aegis/parse.h aegis/pattr.h \
X		common/trace.h aegis/user.h aegis/ustate.h \
X		aegis/uconf.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aend.c
X	mv aend.o aegis/aend.o
X
Xaegis/aenf.o: aegis/aenf.c aegis/ael.h common/main.h aegis/aenf.h \
X		aegis/arglex2.h common/arglex.h aegis/change.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h aegis/col.h aegis/commit.h common/error.h \
X		aegis/glue.h aegis/help.h aegis/lock.h aegis/log.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h common/trace.h \
X		aegis/user.h aegis/ustate.h aegis/uconf.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aenf.c
X	mv aenf.o aegis/aenf.o
X
Xaegis/aenfu.o: aegis/aenfu.c aegis/ael.h common/main.h aegis/aenfu.h \
X		aegis/arglex2.h common/arglex.h aegis/change.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h aegis/col.h aegis/commit.h common/error.h \
X		aegis/glue.h aegis/help.h aegis/lock.h aegis/log.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h common/trace.h \
X		aegis/user.h aegis/ustate.h aegis/uconf.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aenfu.c
X	mv aenfu.o aegis/aenfu.o
X
Xaegis/aeni.o: aegis/aeni.c aegis/aeni.h common/main.h aegis/ael.h \
X		aegis/arglex2.h common/arglex.h aegis/commit.h \
X		common/str.h common/s-v-arg.h common/conf.h \
X		common/error.h aegis/help.h aegis/lock.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/type.h aegis/parse.h aegis/pattr.h \
X		common/trace.h aegis/user.h aegis/ustate.h \
X		aegis/uconf.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aeni.c
X	mv aeni.o aegis/aeni.o
X
Xaegis/aenpr.o: aegis/aenpr.c aegis/ael.h common/main.h aegis/aenpr.h \
X		aegis/arglex2.h common/arglex.h aegis/commit.h \
X		common/str.h common/s-v-arg.h common/conf.h \
X		common/error.h aegis/gonzo.h aegis/gstate.h \
X		aegis/type.h aegis/parse.h aegis/help.h aegis/lock.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h common/trace.h \
X		aegis/undo.h aegis/user.h aegis/ustate.h aegis/uconf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aenpr.c
X	mv aenpr.o aegis/aenpr.o
X
Xaegis/aenrls.o: aegis/aenrls.c aegis/ael.h common/main.h aegis/aenrls.h \
X		aegis/arglex2.h common/arglex.h aegis/change.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h aegis/commit.h aegis/dir.h common/error.h \
X		aegis/file.h aegis/gonzo.h aegis/gstate.h aegis/help.h \
X		aegis/lock.h aegis/log.h common/mem.h common/option.h \
X		aegis/os.h aegis/project.h aegis/pstate.h aegis/pattr.h \
X		aegis/sub.h common/trace.h aegis/undo.h aegis/user.h \
X		aegis/ustate.h aegis/uconf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aenrls.c
X	mv aenrls.o aegis/aenrls.o
X
Xaegis/aenrv.o: aegis/aenrv.c aegis/ael.h common/main.h aegis/aenrv.h \
X		aegis/arglex2.h common/arglex.h aegis/commit.h \
X		common/str.h common/s-v-arg.h common/conf.h \
X		common/error.h aegis/help.h aegis/lock.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/type.h aegis/parse.h aegis/pattr.h \
X		common/trace.h aegis/user.h aegis/ustate.h \
X		aegis/uconf.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aenrv.c
X	mv aenrv.o aegis/aenrv.o
X
Xaegis/aent.o: aegis/aent.c aegis/ael.h common/main.h aegis/aent.h \
X		aegis/arglex2.h common/arglex.h aegis/change.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h aegis/col.h aegis/commit.h common/error.h \
X		aegis/glue.h aegis/help.h aegis/lock.h common/option.h \
X		aegis/os.h aegis/project.h aegis/pstate.h aegis/pattr.h \
X		common/trace.h aegis/user.h aegis/ustate.h \
X		aegis/uconf.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aent.c
X	mv aent.o aegis/aent.o
X
Xaegis/aentu.o: aegis/aentu.c aegis/ael.h common/main.h aegis/aentu.h \
X		aegis/arglex2.h common/arglex.h aegis/change.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h aegis/col.h aegis/commit.h common/error.h \
X		aegis/glue.h aegis/help.h aegis/lock.h common/option.h \
X		aegis/os.h aegis/project.h aegis/pstate.h aegis/pattr.h \
X		common/trace.h aegis/user.h aegis/ustate.h \
X		aegis/uconf.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aentu.c
X	mv aentu.o aegis/aentu.o
X
Xaegis/aepa.o: aegis/aepa.c aegis/aepa.h common/main.h aegis/arglex2.h \
X		common/arglex.h aegis/commit.h common/str.h \
X		common/s-v-arg.h common/conf.h common/error.h \
X		aegis/help.h aegis/lock.h common/option.h aegis/os.h \
X		aegis/pattr.h aegis/type.h aegis/parse.h \
X		aegis/project.h aegis/pstate.h common/trace.h \
X		aegis/user.h aegis/ustate.h aegis/uconf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aepa.c
X	mv aepa.o aegis/aepa.o
X
Xaegis/aera.o: aegis/aera.c aegis/aera.h common/main.h aegis/ael.h \
X		aegis/arglex2.h common/arglex.h aegis/commit.h \
X		common/str.h common/s-v-arg.h common/conf.h \
X		common/error.h aegis/help.h aegis/lock.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/type.h aegis/parse.h aegis/pattr.h \
X		common/trace.h aegis/user.h aegis/ustate.h \
X		aegis/uconf.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aera.c
X	mv aera.o aegis/aera.o
X
Xaegis/aerd.o: aegis/aerd.c aegis/ael.h common/main.h aegis/aerd.h \
X		aegis/arglex2.h common/arglex.h aegis/commit.h \
X		common/str.h common/s-v-arg.h common/conf.h \
X		common/error.h aegis/help.h aegis/lock.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/type.h aegis/parse.h aegis/pattr.h \
X		common/trace.h aegis/user.h aegis/ustate.h \
X		aegis/uconf.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aerd.c
X	mv aerd.o aegis/aerd.o
X
Xaegis/aerf.o: aegis/aerf.c aegis/ael.h common/main.h aegis/aerf.h \
X		aegis/arglex2.h common/arglex.h aegis/change.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h aegis/commit.h aegis/dir.h common/error.h \
X		aegis/file.h aegis/help.h aegis/lock.h common/mem.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h aegis/sub.h common/trace.h \
X		aegis/undo.h aegis/user.h aegis/ustate.h aegis/uconf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aerf.c
X	mv aerf.o aegis/aerf.o
X
Xaegis/aeri.o: aegis/aeri.c aegis/ael.h common/main.h aegis/aeri.h \
X		aegis/arglex2.h common/arglex.h aegis/commit.h \
X		common/str.h common/s-v-arg.h common/conf.h \
X		common/error.h aegis/help.h aegis/lock.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/type.h aegis/parse.h aegis/pattr.h \
X		common/trace.h aegis/user.h aegis/ustate.h \
X		aegis/uconf.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aeri.c
X	mv aeri.o aegis/aeri.o
X
Xaegis/aerm.o: aegis/aerm.c aegis/ael.h common/main.h aegis/aerm.h \
X		aegis/arglex2.h common/arglex.h aegis/change.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h aegis/commit.h common/error.h \
X		aegis/help.h aegis/lock.h aegis/log.h common/option.h \
X		aegis/os.h aegis/project.h aegis/pstate.h aegis/pattr.h \
X		common/trace.h aegis/user.h aegis/ustate.h \
X		aegis/uconf.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aerm.c
X	mv aerm.o aegis/aerm.o
X
Xaegis/aermpr.o: aegis/aermpr.c aegis/ael.h common/main.h aegis/aermpr.h \
X		aegis/arglex2.h common/arglex.h aegis/change.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h aegis/commit.h common/error.h \
X		aegis/gonzo.h aegis/gstate.h aegis/help.h aegis/lock.h \
X		common/option.h aegis/project.h aegis/pstate.h \
X		aegis/pattr.h common/trace.h aegis/user.h \
X		aegis/ustate.h aegis/uconf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aermpr.c
X	mv aermpr.o aegis/aermpr.o
X
Xaegis/aermu.o: aegis/aermu.c aegis/ael.h common/main.h aegis/aermu.h \
X		aegis/arglex2.h common/arglex.h aegis/change.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h aegis/commit.h common/error.h \
X		aegis/help.h aegis/lock.h aegis/log.h common/option.h \
X		aegis/os.h aegis/project.h aegis/pstate.h aegis/pattr.h \
X		common/trace.h aegis/user.h aegis/ustate.h \
X		aegis/uconf.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aermu.c
X	mv aermu.o aegis/aermu.o
X
Xaegis/aerp.o: aegis/aerp.c aegis/ael.h common/main.h aegis/aerp.h \
X		aegis/arglex2.h common/arglex.h aegis/change.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h aegis/commit.h aegis/dir.h common/error.h \
X		aegis/file.h aegis/help.h aegis/lock.h common/mem.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h aegis/sub.h common/trace.h \
X		aegis/undo.h aegis/user.h aegis/ustate.h aegis/uconf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aerp.c
X	mv aerp.o aegis/aerp.o
X
Xaegis/aerpu.o: aegis/aerpu.c aegis/ael.h common/main.h aegis/aerpu.h \
X		aegis/arglex2.h common/arglex.h aegis/change.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h aegis/commit.h aegis/dir.h common/error.h \
X		aegis/file.h aegis/help.h aegis/lock.h common/mem.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h aegis/sub.h common/trace.h \
X		aegis/undo.h aegis/user.h aegis/ustate.h aegis/uconf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aerpu.c
X	mv aerpu.o aegis/aerpu.o
X
Xaegis/aerrv.o: aegis/aerrv.c aegis/ael.h common/main.h aegis/aerrv.h \
X		aegis/arglex2.h common/arglex.h aegis/commit.h \
X		common/str.h common/s-v-arg.h common/conf.h \
X		common/error.h aegis/help.h aegis/lock.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/type.h aegis/parse.h aegis/pattr.h \
X		common/trace.h aegis/user.h aegis/ustate.h \
X		aegis/uconf.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aerrv.c
X	mv aerrv.o aegis/aerrv.o
X
Xaegis/aet.o: aegis/aet.c aegis/ael.h common/main.h aegis/aet.h \
X		aegis/arglex2.h common/arglex.h aegis/change.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h aegis/commit.h common/error.h \
X		aegis/help.h aegis/lock.h aegis/log.h common/option.h \
X		aegis/os.h aegis/project.h aegis/pstate.h aegis/pattr.h \
X		common/trace.h aegis/user.h aegis/ustate.h \
X		aegis/uconf.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/aet.c
X	mv aet.o aegis/aet.o
X
Xaegis/cattr.c aegis/cattr.h: aegis/cattr.def bin/fmtgen aegis/common.def
X	bin/fmtgen -Iaegis aegis/cattr.def aegis/cattr.c aegis/cattr.h
X
Xaegis/cattr.o: aegis/cattr.c aegis/cattr.h common/main.h aegis/type.h \
X		common/str.h common/s-v-arg.h common/conf.h \
X		aegis/parse.h common/error.h aegis/indent.h aegis/io.h \
X		common/mem.h aegis/os.h common/trace.h 
X	$(CC) $(CFLAGS) -Iaegis -Icommon $(H) -c aegis/cattr.c
X	mv cattr.o aegis/cattr.o
X
Xaegis/change.o: aegis/change.c aegis/change.h common/main.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h aegis/commit.h common/error.h \
X		aegis/lock.h common/mem.h common/option.h aegis/os.h \
X		aegis/project.h aegis/pstate.h aegis/pattr.h \
X		aegis/sub.h common/trace.h aegis/undo.h aegis/user.h \
X		aegis/ustate.h aegis/uconf.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/change.c
X	mv change.o aegis/change.o
X
Xaegis/col.o: aegis/col.c aegis/col.h common/main.h common/error.h \
X		aegis/glue.h common/conf.h common/mem.h common/option.h \
X		aegis/os.h common/str.h common/s-v-arg.h aegis/pager.h \
X		common/trace.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/col.c
X	mv col.o aegis/col.o
X
Xaegis/commit.o: aegis/commit.c aegis/commit.h common/str.h \
X		common/s-v-arg.h common/conf.h common/main.h \
X		aegis/dir.h common/mem.h aegis/os.h common/trace.h \
X		aegis/undo.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/commit.c
X	mv commit.o aegis/commit.o
X
Xaegis/common.c aegis/common.h: aegis/common.def bin/fmtgen
X	bin/fmtgen -Iaegis aegis/common.def aegis/common.c aegis/common.h
X
Xaegis/common.o: aegis/common.c aegis/common.h common/main.h \
X		aegis/type.h common/str.h common/s-v-arg.h \
X		common/conf.h aegis/parse.h common/error.h \
X		aegis/indent.h aegis/io.h common/mem.h aegis/os.h \
X		common/trace.h 
X	$(CC) $(CFLAGS) -Iaegis -Icommon $(H) -c aegis/common.c
X	mv common.o aegis/common.o
X
Xaegis/cstate.c aegis/cstate.h: aegis/cstate.def bin/fmtgen \
X		aegis/cattr.def aegis/common.def 
X	bin/fmtgen -Iaegis aegis/cstate.def aegis/cstate.c aegis/cstate.h
X
Xaegis/cstate.o: aegis/cstate.c aegis/cstate.h common/main.h \
X		aegis/type.h common/str.h common/s-v-arg.h \
X		common/conf.h aegis/parse.h common/error.h \
X		aegis/indent.h aegis/io.h common/mem.h aegis/os.h \
X		common/trace.h 
X	$(CC) $(CFLAGS) -Iaegis -Icommon $(H) -c aegis/cstate.c
X	mv cstate.o aegis/cstate.o
X
Xaegis/dir.o: aegis/dir.c aegis/dir.h common/main.h common/str.h \
X		common/s-v-arg.h common/conf.h common/error.h \
X		aegis/glue.h common/trace.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/dir.c
X	mv dir.o aegis/dir.o
X
Xaegis/file.o: aegis/file.c aegis/file.h common/main.h common/str.h \
X		common/s-v-arg.h common/conf.h common/error.h \
X		aegis/glue.h common/mem.h aegis/os.h common/trace.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/file.c
X	mv file.o aegis/file.o
X
Xaegis/glue.o: aegis/glue.c common/error.h common/main.h aegis/glue.h \
X		common/conf.h common/mem.h aegis/os.h common/str.h \
X		common/s-v-arg.h common/trace.h aegis/undo.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/glue.c
X	mv glue.o aegis/glue.o
X
Xaegis/gonzo.o: aegis/gonzo.c aegis/commit.h common/str.h \
X		common/s-v-arg.h common/conf.h common/main.h \
X		common/error.h aegis/gonzo.h aegis/gstate.h \
X		aegis/type.h aegis/parse.h aegis/lock.h common/mem.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h common/trace.h \
X		aegis/undo.h aegis/user.h aegis/ustate.h aegis/uconf.h \
X		common/word.h 
X	$(CC) $(CFLAGS) -D'LIB="$(LIB)"' -Iaegis -Icommon $(H) -c aegis/gonzo.c
X	mv gonzo.o aegis/gonzo.o
X
Xaegis/gram.gen.c aegis/gram.gen.h: aegis/gram.y
X	$(YACC) -d aegis/gram.y
X	sed "s/[yY][yY]/gram_/g" < y.tab.c > aegis/gram.gen.c
X	rm y.tab.c
X	sed "s/[yY][yY]/gram_/g" < y.tab.h > aegis/gram.gen.h
X	rm y.tab.h
X
Xaegis/gram.gen.o: aegis/gram.gen.c aegis/gram.h common/main.h \
X		aegis/lex.h common/mem.h aegis/parse.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/type.h 
X	$(CC) $(CFLAGS) -Iaegis -Icommon $(H) -c aegis/gram.gen.c
X	mv gram.gen.o aegis/gram.gen.o
X
Xaegis/gstate.c aegis/gstate.h: aegis/gstate.def bin/fmtgen
X	bin/fmtgen -Iaegis aegis/gstate.def aegis/gstate.c aegis/gstate.h
X
Xaegis/gstate.o: aegis/gstate.c aegis/gstate.h common/main.h \
X		aegis/type.h common/str.h common/s-v-arg.h \
X		common/conf.h aegis/parse.h common/error.h \
X		aegis/indent.h aegis/io.h common/mem.h aegis/os.h \
X		common/trace.h 
X	$(CC) $(CFLAGS) -Iaegis -Icommon $(H) -c aegis/gstate.c
X	mv gstate.o aegis/gstate.o
X
Xaegis/help.o: aegis/help.c aegis/arglex2.h common/arglex.h \
X		common/main.h common/error.h aegis/gonzo.h \
X		aegis/gstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/help.h common/option.h aegis/pager.h \
X		common/patchlevel.h common/trace.h aegis/undo.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/help.c
X	mv help.o aegis/help.o
X
Xaegis/indent.o: aegis/indent.c common/error.h common/main.h \
X		aegis/glue.h common/conf.h aegis/indent.h \
X		common/s-v-arg.h common/trace.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/indent.c
X	mv indent.o aegis/indent.o
X
Xaegis/io.o: aegis/io.c aegis/indent.h common/main.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/io.h aegis/type.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/io.c
X	mv io.o aegis/io.o
X
Xaegis/lex.o: aegis/lex.c common/error.h common/main.h aegis/glue.h \
X		common/conf.h aegis/lex.h common/s-v-arg.h common/str.h \
X		aegis/gram.gen.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/lex.c
X	mv lex.o aegis/lex.o
X
Xaegis/lock.o: aegis/lock.c common/error.h common/main.h aegis/glue.h \
X		common/conf.h aegis/gonzo.h aegis/gstate.h aegis/type.h \
X		common/str.h common/s-v-arg.h aegis/parse.h \
X		aegis/lock.h common/mem.h aegis/os.h common/trace.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/lock.c
X	mv lock.o aegis/lock.o
X
Xaegis/log.o: aegis/log.c common/error.h common/main.h aegis/log.h \
X		aegis/os.h common/str.h common/s-v-arg.h common/conf.h \
X		common/trace.h aegis/undo.h aegis/user.h aegis/ustate.h \
X		aegis/type.h aegis/parse.h aegis/uconf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/log.c
X	mv log.o aegis/log.o
X
Xaegis/main.o: aegis/main.c aegis/aeb.h common/main.h aegis/aeca.h \
X		aegis/cattr.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/aecd.h aegis/aecp.h aegis/aecpu.h aegis/aed.h \
X		aegis/aedb.h aegis/aedbu.h aegis/aede.h aegis/aedeu.h \
X		aegis/aeib.h aegis/aeibu.h aegis/aeif.h aegis/aeip.h \
X		aegis/ael.h aegis/aemv.h aegis/aena.h aegis/aenc.h \
X		aegis/aencu.h aegis/aend.h aegis/aenf.h aegis/aenfu.h \
X		aegis/aeni.h aegis/aenpr.h aegis/aenrls.h aegis/aenrv.h \
X		aegis/aent.h aegis/aentu.h aegis/aepa.h aegis/aera.h \
X		aegis/aerd.h aegis/aerf.h aegis/aeri.h aegis/aerm.h \
X		aegis/aermpr.h aegis/aermu.h aegis/aerp.h aegis/aerpu.h \
X		aegis/aerrv.h aegis/aet.h aegis/arglex2.h \
X		common/arglex.h common/error.h aegis/help.h aegis/log.h \
X		common/option.h aegis/os.h common/trace.h aegis/undo.h \
X		aegis/version.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/main.c
X	mv main.o aegis/main.o
X
Xaegis/os.o: aegis/os.c common/conf.h aegis/dir.h common/main.h \
X		common/str.h common/s-v-arg.h common/error.h \
X		aegis/file.h aegis/glue.h common/mem.h common/option.h \
X		aegis/os.h common/trace.h aegis/undo.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/os.c
X	mv os.o aegis/os.o
X
Xaegis/pager.o: aegis/pager.c common/error.h common/main.h \
X		common/option.h aegis/os.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/pager.h \
X		common/trace.h aegis/undo.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/pager.c
X	mv pager.o aegis/pager.o
X
Xaegis/parse.o: aegis/parse.c common/error.h common/main.h aegis/gram.h \
X		aegis/lex.h common/mem.h aegis/parse.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/type.h \
X		common/trace.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/parse.c
X	mv parse.o aegis/parse.o
X
Xaegis/pattr.c aegis/pattr.h: aegis/pattr.def bin/fmtgen aegis/common.def
X	bin/fmtgen -Iaegis aegis/pattr.def aegis/pattr.c aegis/pattr.h
X
Xaegis/pattr.o: aegis/pattr.c aegis/pattr.h common/main.h aegis/type.h \
X		common/str.h common/s-v-arg.h common/conf.h \
X		aegis/parse.h common/error.h aegis/indent.h aegis/io.h \
X		common/mem.h aegis/os.h common/trace.h 
X	$(CC) $(CFLAGS) -Iaegis -Icommon $(H) -c aegis/pattr.c
X	mv pattr.o aegis/pattr.o
X
Xaegis/pconf.c aegis/pconf.h: aegis/pconf.def bin/fmtgen aegis/common.def
X	bin/fmtgen -Iaegis aegis/pconf.def aegis/pconf.c aegis/pconf.h
X
Xaegis/pconf.o: aegis/pconf.c aegis/pconf.h common/main.h aegis/type.h \
X		common/str.h common/s-v-arg.h common/conf.h \
X		aegis/parse.h common/error.h aegis/indent.h aegis/io.h \
X		common/mem.h aegis/os.h common/trace.h 
X	$(CC) $(CFLAGS) -Iaegis -Icommon $(H) -c aegis/pconf.c
X	mv pconf.o aegis/pconf.o
X
Xaegis/project.o: aegis/project.c aegis/change.h common/main.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h aegis/commit.h common/error.h \
X		aegis/gonzo.h aegis/gstate.h aegis/lock.h common/mem.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h common/trace.h \
X		aegis/user.h aegis/ustate.h aegis/uconf.h aegis/undo.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/project.c
X	mv project.o aegis/project.o
X
Xaegis/pstate.c aegis/pstate.h: aegis/pstate.def bin/fmtgen \
X		aegis/pattr.def aegis/common.def 
X	bin/fmtgen -Iaegis aegis/pstate.def aegis/pstate.c aegis/pstate.h
X
Xaegis/pstate.o: aegis/pstate.c aegis/pstate.h common/main.h \
X		aegis/type.h common/str.h common/s-v-arg.h \
X		common/conf.h aegis/parse.h common/error.h \
X		aegis/indent.h aegis/io.h common/mem.h aegis/os.h \
X		common/trace.h 
X	$(CC) $(CFLAGS) -Iaegis -Icommon $(H) -c aegis/pstate.c
X	mv pstate.o aegis/pstate.o
X
Xaegis/sub.o: aegis/sub.c common/arglex.h common/main.h aegis/change.h \
X		aegis/cstate.h aegis/type.h common/str.h \
X		common/s-v-arg.h common/conf.h aegis/parse.h \
X		aegis/pconf.h common/error.h common/mem.h \
X		common/option.h aegis/os.h aegis/project.h \
X		aegis/pstate.h aegis/pattr.h aegis/sub.h common/trace.h \
X		common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/sub.c
X	mv sub.o aegis/sub.o
X
Xaegis/type.o: aegis/type.c aegis/type.h common/main.h common/str.h \
X		common/s-v-arg.h common/conf.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/type.c
X	mv type.o aegis/type.o
X
Xaegis/uconf.c aegis/uconf.h: aegis/uconf.def bin/fmtgen
X	bin/fmtgen -Iaegis aegis/uconf.def aegis/uconf.c aegis/uconf.h
X
Xaegis/uconf.o: aegis/uconf.c aegis/uconf.h common/main.h aegis/type.h \
X		common/str.h common/s-v-arg.h common/conf.h \
X		aegis/parse.h common/error.h aegis/indent.h aegis/io.h \
X		common/mem.h aegis/os.h common/trace.h 
X	$(CC) $(CFLAGS) -Iaegis -Icommon $(H) -c aegis/uconf.c
X	mv uconf.o aegis/uconf.o
X
Xaegis/undo.o: aegis/undo.c common/error.h common/main.h common/mem.h \
X		common/option.h aegis/os.h common/str.h \
X		common/s-v-arg.h common/conf.h common/trace.h \
X		aegis/undo.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/undo.c
X	mv undo.o aegis/undo.o
X
Xaegis/user.o: aegis/user.c aegis/commit.h common/str.h common/s-v-arg.h \
X		common/conf.h common/main.h common/error.h \
X		aegis/gonzo.h aegis/gstate.h aegis/type.h aegis/parse.h \
X		aegis/lock.h common/mem.h common/option.h aegis/os.h \
X		aegis/project.h aegis/pstate.h aegis/pattr.h \
X		common/trace.h aegis/user.h aegis/ustate.h \
X		aegis/uconf.h aegis/undo.h common/word.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/user.c
X	mv user.o aegis/user.o
X
Xaegis/ustate.c aegis/ustate.h: aegis/ustate.def bin/fmtgen
X	bin/fmtgen -Iaegis aegis/ustate.def aegis/ustate.c aegis/ustate.h
X
Xaegis/ustate.o: aegis/ustate.c aegis/ustate.h common/main.h \
X		aegis/type.h common/str.h common/s-v-arg.h \
X		common/conf.h aegis/parse.h common/error.h \
X		aegis/indent.h aegis/io.h common/mem.h aegis/os.h \
X		common/trace.h 
X	$(CC) $(CFLAGS) -Iaegis -Icommon $(H) -c aegis/ustate.c
X	mv ustate.o aegis/ustate.o
X
Xaegis/version.o: aegis/version.c aegis/arglex2.h common/arglex.h \
X		common/main.h common/error.h aegis/help.h \
X		common/option.h common/str.h common/s-v-arg.h \
X		common/conf.h common/trace.h aegis/version.h 
X	$(CC) $(CFLAGS)  -Iaegis -Icommon $(H) -c aegis/version.c
X	mv version.o aegis/version.o
X
Xcommon/ansi.o: common/ansi.c common/main.h common/conf.h
X	$(CC) $(CFLAGS) -Icommon $(H) -c common/ansi.c
X	mv ansi.o common/ansi.o
X
Xcommon/arglex.o: common/arglex.c common/arglex.h common/main.h \
X		common/error.h common/option.h common/str.h \
X		common/s-v-arg.h common/conf.h common/trace.h 
X	$(CC) $(CFLAGS) -Icommon $(H) -c common/arglex.c
X	mv arglex.o common/arglex.o
X
Xcommon/error.o: common/error.c common/arglex.h common/main.h \
X		common/error.h common/option.h common/s-v-arg.h \
X		common/conf.h 
X	$(CC) $(CFLAGS) -Icommon $(H) -c common/error.c
X	mv error.o common/error.o
X
Xcommon/mem.o: common/mem.c common/main.h common/mem.h common/error.h
X	$(CC) $(CFLAGS) -Icommon $(H) -c common/mem.c
X	mv mem.o common/mem.o
X
Xcommon/option.o: common/option.c common/error.h common/main.h \
X		common/option.h common/trace.h 
X	$(CC) $(CFLAGS) -Icommon $(H) -c common/option.c
X	mv option.o common/option.o
X
Xcommon/str.o: common/str.c common/error.h common/main.h common/mem.h \
X		common/s-v-arg.h common/conf.h common/str.h 
X	$(CC) $(CFLAGS) -Icommon $(H) -c common/str.c
X	mv str.o common/str.o
X
Xcommon/trace.o: common/trace.c common/error.h common/main.h \
X		common/mem.h common/option.h common/s-v-arg.h \
X		common/conf.h common/str.h common/trace.h 
X	$(CC) $(CFLAGS) -Icommon $(H) -c common/trace.c
X	mv trace.o common/trace.o
X
Xcommon/word.o: common/word.c common/main.h common/word.h common/str.h \
X		common/s-v-arg.h common/conf.h common/error.h \
X		common/mem.h 
X	$(CC) $(CFLAGS) -Icommon $(H) -c common/word.c
X	mv word.o common/word.o
X
Xfmtgen/id.o: fmtgen/id.c common/main.h fmtgen/id.h common/str.h \
X		common/s-v-arg.h common/conf.h common/word.h \
X		common/mem.h common/error.h 
X	$(CC) $(CFLAGS) -Ifmtgen -Icommon $(H) -c fmtgen/id.c
X	mv id.o fmtgen/id.o
X
Xfmtgen/indent.o: fmtgen/indent.c common/error.h common/main.h \
X		fmtgen/indent.h common/s-v-arg.h common/conf.h \
X		common/trace.h 
X	$(CC) $(CFLAGS) -Ifmtgen -Icommon $(H) -c fmtgen/indent.c
X	mv indent.o fmtgen/indent.o
X
Xfmtgen/lex.o: fmtgen/lex.c common/error.h common/main.h fmtgen/id.h \
X		common/str.h common/s-v-arg.h common/conf.h \
X		common/word.h fmtgen/lex.h common/mem.h fmtgen/type.h \
X		fmtgen/parse.gen.h 
X	$(CC) $(CFLAGS) -Ifmtgen -Icommon $(H) -c fmtgen/lex.c
X	mv lex.o fmtgen/lex.o
X
Xfmtgen/main.o: fmtgen/main.c common/arglex.h common/main.h \
X		common/error.h fmtgen/id.h common/str.h \
X		common/s-v-arg.h common/conf.h common/word.h \
X		fmtgen/lex.h common/option.h fmtgen/parse.h \
X		common/trace.h 
X	$(CC) $(CFLAGS) -Ifmtgen -Icommon $(H) -c fmtgen/main.c
X	mv main.o fmtgen/main.o
X
Xfmtgen/parse.gen.c fmtgen/parse.gen.h: fmtgen/parse.y
X	$(YACC) -d fmtgen/parse.y
X	sed "s/[yY][yY]/parse_/g" < y.tab.c > fmtgen/parse.gen.c
X	rm y.tab.c
X	sed "s/[yY][yY]/parse_/g" < y.tab.h > fmtgen/parse.gen.h
X	rm y.tab.h
X
Xfmtgen/parse.gen.o: fmtgen/parse.gen.c common/error.h common/main.h \
X		fmtgen/id.h common/str.h common/s-v-arg.h common/conf.h \
X		common/word.h fmtgen/indent.h fmtgen/lex.h common/mem.h \
X		fmtgen/parse.h common/trace.h fmtgen/type.h 
X	$(CC) $(CFLAGS) -Ifmtgen -Icommon $(H) -c fmtgen/parse.gen.c
X	mv parse.gen.o fmtgen/parse.gen.o
X
Xfmtgen/type.o: fmtgen/type.c fmtgen/type.h common/main.h fmtgen/lex.h \
X		common/str.h common/s-v-arg.h common/conf.h 
X	$(CC) $(CFLAGS) -Ifmtgen -Icommon $(H) -c fmtgen/type.c
X	mv type.o fmtgen/type.o
X
Xfmtgen/type_enum.o: fmtgen/type_enum.c fmtgen/type.h common/main.h \
X		fmtgen/lex.h common/str.h common/s-v-arg.h \
X		common/conf.h fmtgen/indent.h fmtgen/id.h common/word.h \
X		common/mem.h 
X	$(CC) $(CFLAGS) -Ifmtgen -Icommon $(H) -c fmtgen/type_enum.c
X	mv type_enum.o fmtgen/type_enum.o
X
Xfmtgen/type_integ.o: fmtgen/type_integ.c fmtgen/type.h common/main.h \
X		fmtgen/lex.h common/str.h common/s-v-arg.h \
X		common/conf.h fmtgen/indent.h common/mem.h 
X	$(CC) $(CFLAGS) -Ifmtgen -Icommon $(H) -c fmtgen/type_integ.c
X	mv type_integ.o fmtgen/type_integ.o
X
Xfmtgen/type_list.o: fmtgen/type_list.c fmtgen/type.h common/main.h \
X		fmtgen/lex.h common/str.h common/s-v-arg.h \
X		common/conf.h fmtgen/indent.h common/mem.h fmtgen/id.h \
X		common/word.h 
X	$(CC) $(CFLAGS) -Ifmtgen -Icommon $(H) -c fmtgen/type_list.c
X	mv type_list.o fmtgen/type_list.o
X
Xfmtgen/type_ref.o: fmtgen/type_ref.c fmtgen/type.h common/main.h \
X		fmtgen/lex.h common/str.h common/s-v-arg.h \
X		common/conf.h fmtgen/indent.h common/mem.h fmtgen/id.h \
X		common/word.h common/error.h 
X	$(CC) $(CFLAGS) -Ifmtgen -Icommon $(H) -c fmtgen/type_ref.c
X	mv type_ref.o fmtgen/type_ref.o
X
Xfmtgen/type_strin.o: fmtgen/type_strin.c fmtgen/type.h common/main.h \
X		fmtgen/lex.h common/str.h common/s-v-arg.h \
X		common/conf.h fmtgen/indent.h common/mem.h 
X	$(CC) $(CFLAGS) -Ifmtgen -Icommon $(H) -c fmtgen/type_strin.c
X	mv type_strin.o fmtgen/type_strin.o
X
Xfmtgen/type_struc.o: fmtgen/type_struc.c fmtgen/type.h common/main.h \
X		fmtgen/lex.h common/str.h common/s-v-arg.h \
X		common/conf.h fmtgen/indent.h common/mem.h fmtgen/id.h \
X		common/word.h common/error.h 
X	$(CC) $(CFLAGS) -Ifmtgen -Icommon $(H) -c fmtgen/type_struc.c
X	mv type_struc.o fmtgen/type_struc.o
X
Xt0001a: all test/00/t0001a.sh
X	$(SHELL) test/00/t0001a.sh
X
Xt0002a: all test/00/t0002a.sh
X	$(SHELL) test/00/t0002a.sh
X
Xt0003a: all test/00/t0003a.sh
X	$(SHELL) test/00/t0003a.sh
X
Xt0004a: all test/00/t0004a.sh
X	$(SHELL) test/00/t0004a.sh
X
Xt0005a: all test/00/t0005a.sh
X	$(SHELL) test/00/t0005a.sh
X
Xt0006a: all test/00/t0006a.sh
X	$(SHELL) test/00/t0006a.sh
X
Xt0007a: all test/00/t0007a.sh
X	$(SHELL) test/00/t0007a.sh
X
Xt0008a: all test/00/t0008a.sh
X	$(SHELL) test/00/t0008a.sh
X
Xt0009a: all test/00/t0009a.sh
X	$(SHELL) test/00/t0009a.sh
X
Xt0010a: all test/00/t0010a.sh
X	$(SHELL) test/00/t0010a.sh
X
Xt0011a: all test/00/t0011a.sh
X	$(SHELL) test/00/t0011a.sh
X
Xt0012a: all test/00/t0012a.sh
X	$(SHELL) test/00/t0012a.sh
X
Xt0013a: all test/00/t0013a.sh
X	$(SHELL) test/00/t0013a.sh
X
Xt0014a: all test/00/t0014a.sh
X	$(SHELL) test/00/t0014a.sh
X
Xt0015a: all test/00/t0015a.sh
X	$(SHELL) test/00/t0015a.sh
X
Xt0016a: all test/00/t0016a.sh
X	$(SHELL) test/00/t0016a.sh
X
Xt0017a: all test/00/t0017a.sh
X	$(SHELL) test/00/t0017a.sh
X
Xt0018a: all test/00/t0018a.sh
X	$(SHELL) test/00/t0018a.sh
X
Xclean:
X	rm -f core bin/fmtgen aegis/aeb.o aegis/aeca.o aegis/aecd.o \
X		aegis/aecp.o aegis/aecpu.o aegis/aed.o aegis/aedb.o \
X		aegis/aedbu.o aegis/aede.o aegis/aedeu.o aegis/aeib.o \
X		aegis/aeibu.o aegis/aeif.o aegis/aeip.o aegis/ael.o \
X		aegis/aemv.o aegis/aena.o aegis/aenc.o aegis/aencu.o \
X		aegis/aend.o aegis/aenf.o aegis/aenfu.o aegis/aeni.o \
X		aegis/aenpr.o aegis/aenrls.o aegis/aenrv.o aegis/aent.o \
X		aegis/aentu.o aegis/aepa.o aegis/aera.o aegis/aerd.o \
X		aegis/aerf.o aegis/aeri.o aegis/aerm.o aegis/aermpr.o \
X		aegis/aermu.o aegis/aerp.o aegis/aerpu.o aegis/aerrv.o \
X		aegis/aet.o aegis/cattr.c aegis/cattr.h aegis/cattr.o \
X		aegis/change.o aegis/col.o aegis/commit.o \
X		aegis/common.c aegis/common.h aegis/common.o \
X		aegis/cstate.c aegis/cstate.h aegis/cstate.o \
X		aegis/dir.o aegis/file.o aegis/glue.o aegis/gonzo.o \
X		aegis/gram.gen.c aegis/gram.gen.h aegis/gram.gen.o \
X		aegis/gstate.c aegis/gstate.h aegis/gstate.o \
X		aegis/help.o aegis/indent.o aegis/io.o aegis/lex.o \
X		aegis/lock.o aegis/log.o aegis/main.o aegis/os.o \
X		aegis/pager.o aegis/parse.o aegis/pattr.c aegis/pattr.h \
X		aegis/pattr.o aegis/pconf.c aegis/pconf.h aegis/pconf.o \
X		aegis/project.o aegis/pstate.c aegis/pstate.h \
X		aegis/pstate.o aegis/sub.o aegis/type.o aegis/uconf.c \
X		aegis/uconf.h aegis/uconf.o aegis/undo.o aegis/user.o \
X		aegis/ustate.c aegis/ustate.h aegis/ustate.o \
X		aegis/version.o common/ansi.o common/arglex.o \
X		common/error.o common/mem.o common/option.o \
X		common/str.o common/trace.o common/word.o fmtgen/id.o \
X		fmtgen/indent.o fmtgen/lex.o fmtgen/main.o \
X		fmtgen/parse.gen.c fmtgen/parse.gen.h \
X		fmtgen/parse.gen.o fmtgen/type.o fmtgen/type_enum.o \
X		fmtgen/type_integ.o fmtgen/type_list.o \
X		fmtgen/type_ref.o fmtgen/type_strin.o \
X		fmtgen/type_struc.o 
X
Xrealclean: clean
X	rm -f bin/aegis
X
Xclobber: realclean
X	rm -f common/conf.h
X
Xcommon/conf.h:
X	echo "#include <../conf/`uname -s`-`uname -r`>" > common/conf.h
X
XFmtgenFiles = common/ansi.o common/arglex.o common/error.o common/mem.o \
X		common/option.o common/str.o common/trace.o \
X		common/word.o fmtgen/id.o fmtgen/indent.o fmtgen/lex.o \
X		fmtgen/main.o fmtgen/parse.gen.o fmtgen/type.o \
X		fmtgen/type_enum.o fmtgen/type_integ.o \
X		fmtgen/type_list.o fmtgen/type_ref.o \
X		fmtgen/type_strin.o fmtgen/type_struc.o 
X
Xbin/fmtgen: $(FmtgenFiles)
X	if test ! -d bin; then mkdir bin; fi; exit 0
X	$(CC) -o bin/fmtgen $(FmtgenFiles) $(LIBRARIES)
X
XAegisFiles = aegis/aeb.o aegis/aeca.o aegis/aecd.o aegis/aecp.o \
X		aegis/aecpu.o aegis/aed.o aegis/aedb.o aegis/aedbu.o \
X		aegis/aede.o aegis/aedeu.o aegis/aeib.o aegis/aeibu.o \
X		aegis/aeif.o aegis/aeip.o aegis/ael.o aegis/aemv.o \
X		aegis/aena.o aegis/aenc.o aegis/aencu.o aegis/aend.o \
X		aegis/aenf.o aegis/aenfu.o aegis/aeni.o aegis/aenpr.o \
X		aegis/aenrls.o aegis/aenrv.o aegis/aent.o aegis/aentu.o \
X		aegis/aepa.o aegis/aera.o aegis/aerd.o aegis/aerf.o \
X		aegis/aeri.o aegis/aerm.o aegis/aermpr.o aegis/aermu.o \
X		aegis/aerp.o aegis/aerpu.o aegis/aerrv.o aegis/aet.o \
X		aegis/cattr.o aegis/change.o aegis/col.o aegis/commit.o \
X		aegis/common.o aegis/cstate.o aegis/dir.o aegis/file.o \
X		aegis/glue.o aegis/gonzo.o aegis/gram.gen.o \
X		aegis/gstate.o aegis/help.o aegis/indent.o aegis/io.o \
X		aegis/lex.o aegis/lock.o aegis/log.o aegis/main.o \
X		aegis/os.o aegis/pager.o aegis/parse.o aegis/pattr.o \
X		aegis/pconf.o aegis/project.o aegis/pstate.o \
X		aegis/sub.o aegis/type.o aegis/uconf.o aegis/undo.o \
X		aegis/user.o aegis/ustate.o aegis/version.o \
X		common/ansi.o common/arglex.o common/error.o \
X		common/mem.o common/option.o common/str.o \
X		common/trace.o common/word.o 
X
Xbin/aegis: $(AegisFiles)
X	if test ! -d bin; then mkdir bin; fi; exit 0
X	$(CC) -o bin/aegis $(AegisFiles) $(LIBRARIES)
X
Xsure: t0001a t0002a t0003a t0004a t0005a t0006a t0007a t0008a t0009a \
X		t0010a t0011a t0012a t0013a t0014a t0015a t0016a t0017a \
X		t0018a 
X	@echo Passed All Tests
X
Xinstall: all
X	cp bin/aegis $(BIN)
X	chown root $(BIN)/aegis
X	chmod a+x,u+s $(BIN)/aegis
X	-mkdir $(LIB)
X	chmod 0755 $(LIB)
X	cp lib/* $(LIB)
X	chmod a+r $(LIB)/*
X	chmod a+x $(LIB)/*.sh
X	chown bin $(LIB)
X	chgrp bin $(LIB)
X	$(SHELL) man1/install.sh $(MAN)/man1
X	$(SHELL) man5/install.sh $(MAN)/man5
END_OF_FILE
if test 46616 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'aegis/sub.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aegis/sub.c'\"
else
echo shar: Extracting \"'aegis/sub.c'\" \(43195 characters\)
sed "s/^X//" >'aegis/sub.c' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to perform command substitutions
X */
X
X#include <ctype.h>
X
X#include <arglex.h>
X#include <change.h>
X#include <error.h>
X#include <mem.h>
X#include <option.h>
X#include <os.h>
X#include <project.h>
X#include <sub.h>
X#include <trace.h>
X#include <word.h>
X
Xtypedef string_ty *(*fp)_((wlist *));
X
Xtypedef struct table_ty table_ty;
Xstruct table_ty
X{
X	char		*name;
X	fp		func;
X	string_ty	*value;
X};
X
Xtypedef struct diversion_ty diversion_ty;
Xstruct diversion_ty
X{
X	long		pos;
X	string_ty	*text;
X	diversion_ty	*prev;
X};
X
X
Xstatic	diversion_ty	*diversion;
Xstatic	char		*collect_buf;
Xstatic	size_t		collect_size;
Xstatic	size_t		collect_pos;
Xstatic	table_ty	*sub_var_list;
Xstatic	size_t		sub_var_size;
Xstatic	size_t		sub_var_pos;
Xstatic	change_ty	*cp;
Xstatic	project_ty	*pp;
Xstatic	char		*suberr;
X
X
X/*
X * NAME
X *	sub_administrator_list - the administrator_list substitution
X *
X * SYNOPSIS
X *	string_ty *sub_administrator_list(wlist *arg);
X *
X * DESCRIPTION
X *	The sub_administrator_list function implements the administrator_list
X * 	substitution.  The administrator_list substitution is replaced by
X *	a space separated list of project administrators.
X *
X * ARGUMENTS
X *	arg	- list of arguments, including the function name as [0]
X *
X * RETURNS
X *	a pointer to a string in dynamic memory;
X *	or NULL on error, setting suberr appropriately.
X */
X
Xstatic string_ty *sub_administrator_list _((wlist *));
X
Xstatic string_ty *
Xsub_administrator_list(arg)
X	wlist		*arg;
X{
X	string_ty	*result;
X	pstate		pstate_data;
X	long		j;
X
X	trace(("sub_administrator_list()\n{\n"/*}*/));
X	if (arg->wl_nwords != 1)
X	{
X		suberr = "requires zero arguments";
X		result = 0;
X	}
X	else
X	{
X		/*
X		 * build a string containing all of the project administrators
X		 */
X		assert(pp);
X		pstate_data = project_pstate_get(pp);
X		assert(pstate_data->administrator);
X		switch (pstate_data->administrator->length)
X		{
X		case 0:
X			result = str_from_c("");
X			break;
X	
X		case 1:
X			result = str_copy(pstate_data->administrator->list[0]);
X			break;
X	
X		default:
X			assert(pstate_data->administrator->length >= 2);
X			result = str_copy(pstate_data->administrator->list[0]);
X			for (j = 1; j < pstate_data->administrator->length; ++j)
X			{
X				string_ty	*s;
X	
X				s =
X					str_format
X					(
X						"%S %S",
X						result,
X						pstate_data->administrator->
X							list[j]
X					);
X				str_free(result);
X				result = s;
X			}
X			break;
X		}
X	}
X	trace(("return \"%s\";\n", result ? result->str_text : suberr));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_baseline - the baseline substitution
X *
X * SYNOPSIS
X *	string_ty *sub_baseline(wlist *arg);
X *
X * DESCRIPTION
X *	The sub_baseline function implements the baseline substitution.
X *	The baseline substitution is used to insert the absolute path
X *	of the baseline.
X *
X * ARGUMENTS
X *	arg	- list of arguments, including the function name as [0]
X *
X * RETURNS
X *	a pointer to a string in dynamic memory;
X *	or NULL on error, setting suberr appropriately.
X */
X
Xstatic string_ty *sub_baseline _((wlist *));
X
Xstatic string_ty *
Xsub_baseline(arg)
X	wlist		*arg;
X{
X	string_ty	*result;
X
X	trace(("sub_baseline()\n{\n"/*}*/));
X	if (arg->wl_nwords != 1)
X	{
X		suberr = "requires zero arguments";
X		result = 0;
X	}
X	else
X		result = str_copy(project_baseline_path_get(pp, 0));
X	trace(("return \"%s\";\n", result ? result->str_text : suberr));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_basename - the basename substitution
X *
X * SYNOPSIS
X *	string_ty *sub_basename(wlist *arg);
X *
X * DESCRIPTION
X *	The sub_basename function implements the basename substitution.
X *	The basename substitution is replaced by the basename of
X *	the argument path, similar to the basename(1) command.
X *
X * ARGUMENTS
X *	arg	- list of arguments, including the function name as [0]
X *
X * RETURNS
X *	a pointer to a string in dynamic memory;
X *	or NULL on error, setting suberr appropriately.
X */
X
Xstatic string_ty *sub_basename _((wlist *));
X
Xstatic string_ty *
Xsub_basename(arg)
X	wlist		*arg;
X{
X	string_ty	*result;
X	string_ty	*suffix;
X	string_ty	*s;
X	long		len;
X
X	trace(("sub_basename()\n{\n"/*}*/));
X	switch (arg->wl_nwords)
X	{
X	default:
X		suberr = "requires one or two arguments";
X		result = 0;
X		break;
X	
X	case 2:
X		change_become(cp);
X		result = os_entryname(arg->wl_word[1]);
X		change_become_undo();
X		break;
X	
X	case 3:
X		change_become(cp);
X		s = os_entryname(arg->wl_word[1]);
X		change_become_undo();
X		suffix = arg->wl_word[2];
X		len = s->str_length - suffix->str_length;
X		if
X		(
X			len > 0
X		&&
X			!memcmp
X			(
X				s->str_text + len,
X				suffix->str_text,
X				suffix->str_length
X			)
X		)
X		{
X			result = str_n_from_c(s->str_text, len);
X			str_free(s);
X		}
X		else
X			result = s;
X		break;
X	}
X	trace(("return \"%s\";\n", result ? result->str_text : suberr));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_change - the change substitution
X *
X * SYNOPSIS
X *	string_ty *sub_change(wlist *arg);
X *
X * DESCRIPTION
X *	The sub_change function implements the change substitution.
X *	The change substitution is replaced by the change number.
X *
X * ARGUMENTS
X *	arg	- list of arguments, including the function name as [0]
X *
X * RETURNS
X *	a pointer to a string in dynamic memory;
X *	or NULL on error, setting suberr appropriately.
X */
X
Xstatic string_ty *sub_change _((wlist *));
X
Xstatic string_ty *
Xsub_change(arg)
X	wlist		*arg;
X{
X	string_ty	*result;
X
X	trace(("sub_change()\n{\n"/*}*/));
X	if (arg->wl_nwords != 1)
X	{
X		suberr = "requires zero arguments";
X		result = 0;
X	}
X	else
X		result = str_format("%ld", cp->number);
X	trace(("return \"%s\";\n", result ? result->str_text : suberr));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_date - the date substitution
X *
X * SYNOPSIS
X *	string_ty *sub_date(wlist *arg);
X *
X * DESCRIPTION
X *	The sub_date function implements the date substitution.
X *	The date substitution is replaced by the current date.
X *	The optional arguments may construct format string,
X *	similar to the date(1) command.
X *
X * ARGUMENTS
X *	arg	- list of arguments, including the function name as [0]
X *
X * RETURNS
X *	a pointer to a string in dynamic memory;
X *	or NULL on error, setting suberr appropriately.
X */
X
Xstatic string_ty *sub_date _((wlist *));
X
Xstatic string_ty *
Xsub_date(arg)
X	wlist		*arg;
X{
X	string_ty	*result;
X	time_t		now;
X
X	trace(("sub_date()\n{\n"/*}*/));
X	assert(cp);
X	time(&now);
X	if (arg->wl_nwords < 2)
X	{
X		char	*cp;
X
X		cp = ctime(&now);
X		result = str_n_from_c(cp, 24);
X	}
X	else
X	{
X		struct tm	*tm;
X		char		buf[1000];
X		size_t		nbytes;
X		string_ty	*fmt;
X		extern size_t strftime _((char *, size_t, char *, struct tm *));
X
X		fmt = wl2str(arg, 1, 32767);
X		tm = localtime(&now);
X		nbytes = strftime(buf, sizeof(buf) - 1, fmt->str_text, tm);
X		if (!nbytes && fmt->str_length)
X		{
X			suberr = "strftime output too large";
X			result = 0;
X		}
X		else
X			result = str_n_from_c(buf, nbytes);
X		str_free(fmt);
X	}
X	trace(("return \"%s\";\n", result ? result->str_text : suberr));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_delta - the delta substitution
X *
X * SYNOPSIS
X *	string_ty *sub_delta(wlist *arg);
X *
X * DESCRIPTION
X *	The sub_delta function implements the delta substitution.
X *	The delta substitution is replaced by the delta number of the project.
X *
X * ARGUMENTS
X *	arg	- list of arguments, including the function name as [0]
X *
X * RETURNS
X *	a pointer to a string in dynamic memory;
X *	or NULL on error, setting suberr appropriately.
X */
X
Xstatic string_ty *sub_delta _((wlist *));
X
Xstatic string_ty *
Xsub_delta(arg)
X	wlist		*arg;
X{
X	string_ty	*result;
X	cstate		cstate_data;
X
X	trace(("sub_delta()\n{\n"/*}*/));
X	assert(cp);
X	cstate_data = change_cstate_get(cp);
X	if (arg->wl_nwords != 1)
X	{
X		suberr = "requires zero arguments";
X		result = 0;
X	}
X	else if (cstate_data->state != cstate_state_being_integrated)
X	{
X		suberr = "not meaningful in current state";
X		result = 0;
X	}
X	else
X		result = str_format("%ld", cstate_data->delta_number);
X	trace(("return \"%s\";\n", result ? result->str_text : suberr));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_developer - the developer substitution
X *
X * SYNOPSIS
X *	string_ty *sub_developer(wlist *arg);
X *
X * DESCRIPTION
X *	The sub_developer function implements the developer substitution.
X *	The developer substitution is replaced by the name of the developer
X *	of the project.
X *
X * ARGUMENTS
X *	arg	- list of arguments, including the function name as [0]
X *
X * RETURNS
X *	a pointer to a string in dynamic memory;
X *	or NULL on error, setting suberr appropriately.
X */
X
Xstatic string_ty *sub_developer _((wlist *arg));
X
Xstatic string_ty *
Xsub_developer(arg)
X	wlist		*arg;
X{
X	string_ty	*result;
X	string_ty	*s;
X
X	trace(("sub_developer()\n{\n"/*}*/));
X	assert(cp);
X	if (arg->wl_nwords != 1)
X	{
X		suberr = "requires zero arguments";
X		result = 0;
X	}
X	else
X	{
X		s = change_developer_name(cp);
X		if (!s)
X		{
X			suberr = "not meaningful in current state";
X			result = 0;
X		}
X		else
X			result = str_copy(s);
X	}
X	trace(("return \"%s\";\n", result ? result->str_text : suberr));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_developer_list - the developer_list substitution
X *
X * SYNOPSIS
X *	string_ty *sub_developer_list(wlist *arg);
X *
X * DESCRIPTION
X *	The sub_developer_list function implements the developer_list substitution.
X *	The developer_list substitution is replaced by a space separated list
X *	of the project's developers.
X *
X * ARGUMENTS
X *	arg	- list of arguments, including the function name as [0]
X *
X * RETURNS
X *	a pointer to a string in dynamic memory;
X *	or NULL on error, setting suberr appropriately.
X */
X
Xstatic string_ty *sub_developer_list _((wlist *));
X
Xstatic string_ty *
Xsub_developer_list(arg)
X	wlist		*arg;
X{
X	string_ty	*result;
X	pstate		pstate_data;
X	long		j;
X
X	trace(("sub_developer_list()\n{\n"/*}*/));
X	if (arg->wl_nwords != 1)
X	{
X		suberr = "requires zero arguments";
X		result = 0;
X	}
X	else
X	{
X		/*
X		 * build a string containing all of the project developers
X		 */
X		assert(pp);
X		pstate_data = project_pstate_get(pp);
X		assert(pstate_data->developer);
X		switch (pstate_data->developer->length)
X		{
X		case 0:
X			result = str_from_c("");
X			break;
X	
X		case 1:
X			result = str_copy(pstate_data->developer->list[0]);
X			break;
X	
X		default:
X			assert(pstate_data->developer->length >= 2);
X			result = str_copy(pstate_data->developer->list[0]);
X			for (j = 1; j < pstate_data->developer->length; ++j)
X			{
X				string_ty	*s;
X	
X				s =
X					str_format
X					(
X						"%S %S",
X						result,
X						pstate_data->developer->list[j]
X					);
X				str_free(result);
X				result = s;
X			}
X			break;
X		}
X	}
X	trace(("return \"%s\";\n", result ? result->str_text : suberr));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_development_directory - the development_directory substitution
X *
X * SYNOPSIS
X *	string_ty *sub_development_directory(wlist *arg);
X *
X * DESCRIPTION
X *	The sub_development_directory function implements the development_directory substitution.
X *	The development_directory substitution is used to insert the absolute path
X *	of the development_directory.
X *
X * ARGUMENTS
X *	arg	- list of arguments, including the function name as [0]
X *
X * RETURNS
X *	a pointer to a string in dynamic memory;
X *	or NULL on error, setting suberr appropriately.
X */
X
Xstatic string_ty *sub_development_directory _((wlist *));
X
Xstatic string_ty *
Xsub_development_directory(arg)
X	wlist		*arg;
X{
X	string_ty	*result;
X	cstate		cstate_data;
X
X	trace(("sub_development_directory()\n{\n"/*}*/));
X	assert(cp);
X	cstate_data = change_cstate_get(cp);
X	if (arg->wl_nwords != 1)
X	{
X		suberr = "requires zero arguments";
X		result = 0;
X	}
X	else if
X	(
X		cstate_data->state < cstate_state_being_developed
X	||
X		cstate_data->state > cstate_state_being_integrated
X	)
X	{
X		suberr = "not meaningful in current state";
X		result = 0;
X	}
X	else
X		result = str_copy(change_development_directory_get(cp, 0));
X	trace(("return \"%s\";\n", result ? result->str_text : suberr));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_dirname - the dirname substitution
X *
X * SYNOPSIS
X *	string_ty *sub_dirname(wlist *arg);
X *
X * DESCRIPTION
X *	The sub_dirname function implements the dirname substitution.
X *	The dirname substitution is replaced by the dirname of
X *	the argument path, similar to the dirname(1) command.
X *
X * ARGUMENTS
X *	arg	- list of arguments, including the function name as [0]
X *
X * RETURNS
X *	a pointer to a string in dynamic memory;
X *	or NULL on error, setting suberr appropriately.
X */
X
Xstatic string_ty *sub_dirname _((wlist *));
X
Xstatic string_ty *
Xsub_dirname(arg)
X	wlist		*arg;
X{
X	string_ty	*result;
X
X	trace(("sub_dirname()\n{\n"/*}*/));
X	if (arg->wl_nwords != 2)
X	{
X		suberr = "requires one argument";
X		result = 0;
X	}
X	else
X	{
X		change_become(cp);
X		result = os_dirname(arg->wl_word[1]);
X		change_become_undo();
X	}
X	trace(("return \"%s\";\n", result ? result->str_text : suberr));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_downcase - the downcase substitution
X *
X * SYNOPSIS
X *	string_ty *sub_downcase(wlist *arg);
X *
X * DESCRIPTION
X *	The sub_downcase function implements the downcase substitution.
X *	The downcase substitution is replaced by the single argument
X *	mapped to lower case.
X *
X *	Requires exactly one argument.
X *
X * ARGUMENTS
X *	arg	- list of arguments, including the function name as [0]
X *
X * RETURNS
X *	a pointer to a string in dynamic memory;
X *	or NULL on error, setting suberr appropriately.
X */
X
Xstatic string_ty *sub_downcase _((wlist *arg));
X
Xstatic string_ty *
Xsub_downcase(arg)
X	wlist		*arg;
X{
X	string_ty	*result;
X
X	trace(("sub_downcase()\n{\n"/*}*/));
X	if (arg->wl_nwords != 2)
X	{
X		suberr = "requires one argument";
X		result = 0;
X	}
X	else
X		result = str_downcase(arg->wl_word[1]);
X	trace(("return \"%s\";\n", result ? result->str_text : suberr));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_identifier - the identifier substitution
X *
X * SYNOPSIS
X *	string_ty *sub_identifier(wlist *arg);
X *
X * DESCRIPTION
X *	The sub_identifier function implements the identifier substitution.
X *	The identifier substitution is replaced by the single argument
X *	mapped to a C identifier.  All characters which are not legal in
X *	a C identifier are replaced by an underscore.
X *
X *	Requires exactly one argument.
X *
X * ARGUMENTS
X *	arg	- list of arguments, including the function name as [0]
X *
X * RETURNS
X *	a pointer to a string in dynamic memory;
X *	or NULL on error, setting suberr appropriately.
X */
X
Xstatic string_ty *sub_identifier _((wlist *arg));
X
Xstatic string_ty *
Xsub_identifier(arg)
X	wlist		*arg;
X{
X	string_ty	*result;
X
X	trace(("sub_identifier()\n{\n"/*}*/));
X	if (arg->wl_nwords != 2)
X	{
X		suberr = "requires one argument";
X		result = 0;
X	}
X	else if (arg->wl_word[1]->str_length == 0)
X		result = str_from_c("_");
X	else
X	{
X		string_ty	*s;
X		size_t		len;
X		char		*tmp;
X		char		*cp1;
X		char		*cp2;
X
X		s = arg->wl_word[1];
X		len = s->str_length;
X		tmp = mem_alloc(len);
X		for
X		(
X			cp1 = s->str_text, cp2 = tmp;
X			cp1 < s->str_text + len;
X			++cp1, ++cp2
X		)
X		{
X			if (isalnum(*cp1))
X				*cp2 = *cp1;
X			else
X				*cp2 = '_';
X		}
X		if (isdigit(tmp[0]))
X			tmp[0] = '_';
X		result = str_n_from_c(tmp, len);
X		mem_free(tmp);
X	}
X	trace(("return \"%s\";\n", result ? result->str_text : suberr));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_integration_directory - the integration_directory substitution
X *
X * SYNOPSIS
X *	string_ty *sub_integration_directory(wlist *arg);
X *
X * DESCRIPTION
X *	The sub_integration_directory function implements the integration_directory substitution.
X *	The integration_directory substitution is used to insert the absolute path
X *	of the integration_directory.
X *
X * ARGUMENTS
X *	arg	- list of arguments, including the function name as [0]
X *
X * RETURNS
X *	a pointer to a string in dynamic memory;
X *	or NULL on error, setting suberr appropriately.
X */
X
Xstatic string_ty *sub_integration_directory _((wlist *));
X
Xstatic string_ty *
Xsub_integration_directory(arg)
X	wlist		*arg;
X{
X	string_ty	*result;
X	cstate		cstate_data;
X
X	trace(("sub_integration_directory()\n{\n"/*}*/));
X	assert(cp);
X	cstate_data = change_cstate_get(cp);
X	if (arg->wl_nwords != 1)
X	{
X		suberr = "requires zero arguments";
X		result = 0;
X	}
X	else if (cstate_data->state != cstate_state_being_integrated)
X	{
X		suberr = "not meaningful in current state";
X		result = 0;
X	}
X	else
X		result = str_copy(change_integration_directory_get(cp, 0));
X	trace(("return \"%s\";\n", result ? result->str_text : suberr));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_integrator - the integrator substitution
X *
X * SYNOPSIS
X *	string_ty *sub_integrator(wlist *arg);
X *
X * DESCRIPTION
X *	The sub_integrator function implements the integrator substitution.
X *	The integrator substitution is replaced by the name of the integrator
X *	of the project.
X *
X * ARGUMENTS
X *	arg	- list of arguments, including the function name as [0]
X *
X * RETURNS
X *	a pointer to a string in dynamic memory;
X *	or NULL on error, setting suberr appropriately.
X */
X
Xstatic string_ty *sub_integrator _((wlist *arg));
X
Xstatic string_ty *
Xsub_integrator(arg)
X	wlist		*arg;
X{
X	string_ty	*result;
X	string_ty	*s;
X
X	trace(("sub_integrator()\n{\n"/*}*/));
X	assert(cp);
X	if (arg->wl_nwords != 1)
X	{
X		suberr = "requires zero arguments";
X		result = 0;
X	}
X	else
X	{
X		s = change_integrator_name(cp);
X		if (!s)
X		{
X			suberr = "not meaningful in current state";
X			result = 0;
X		}
X		else
X			result = str_copy(s);
X	}
X	trace(("return \"%s\";\n", result ? result->str_text : suberr));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_integrator_list - the integrator_list substitution
X *
X * SYNOPSIS
X *	string_ty *sub_integrator_list(wlist *arg);
X *
X * DESCRIPTION
X *	The sub_integrator_list function implements the integrator_list substitution.
X *	The integrator_list substitution is replaced by a space separated list
X *	of the project's integrators.
X *
X * ARGUMENTS
X *	arg	- list of arguments, including the function name as [0]
X *
X * RETURNS
X *	a pointer to a string in dynamic memory;
X *	or NULL on error, setting suberr appropriately.
X */
X
Xstatic string_ty *sub_integrator_list _((wlist *));
X
Xstatic string_ty *
Xsub_integrator_list(arg)
X	wlist		*arg;
X{
X	string_ty	*result;
X	pstate		pstate_data;
X	long		j;
X
X	trace(("sub_integrator_list()\n{\n"/*}*/));
X	if (arg->wl_nwords != 1)
X	{
X		suberr = "requires zero arguments";
X		result = 0;
X	}
X	else
X	{
X		/*
X		 * build a string containing all of the project integrators
X		 */
X		assert(pp);
X		pstate_data = project_pstate_get(pp);
X		assert(pstate_data->integrator);
X		switch (pstate_data->integrator->length)
X		{
X		case 0:
X			result = str_from_c("");
X			break;
X	
X		case 1:
X			result = str_copy(pstate_data->integrator->list[0]);
X			break;
X	
X		default:
X			assert(pstate_data->integrator->length >= 2);
X			result = str_copy(pstate_data->integrator->list[0]);
X			for (j = 1; j < pstate_data->integrator->length; ++j)
X			{
X				string_ty	*s;
X	
X				s =
X					str_format
X					(
X						"%S %S",
X						result,
X						pstate_data->integrator->list[j]
X					);
X				str_free(result);
X				result = s;
X			}
X			break;
X		}
X	}
X	trace(("return \"%s\";\n", result ? result->str_text : suberr));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_project - the project substitution
X *
X * SYNOPSIS
X *	string_ty *sub_project(wlist *arg);
X *
X * DESCRIPTION
X *	The sub_project function implements the project substitution.
X *	The project substitution is replaced by the project name.
X *
X * ARGUMENTS
X *	arg	- list of arguments, including the function name as [0]
X *
X * RETURNS
X *	a pointer to a string in dynamic memory;
X *	or NULL on error, setting suberr appropriately.
X */
X
Xstatic string_ty *sub_project _((wlist *));
X
Xstatic string_ty *
Xsub_project(arg)
X	wlist		*arg;
X{
X	string_ty	*result;
X
X	trace(("sub_project()\n{\n"/*}*/));
X	if (arg->wl_nwords != 1)
X	{
X		suberr = "requires zero arguments";
X		result = 0;
X	}
X	else
X		result = str_copy(project_name_get(pp));
X	trace(("return \"%s\";\n", result ? result->str_text : suberr));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_reviewer - the reviewer substitution
X *
X * SYNOPSIS
X *	string_ty *sub_reviewer(wlist *arg);
X *
X * DESCRIPTION
X *	The sub_reviewer function implements the reviewer substitution.
X *	The reviewer substitution is replaced by the name of the reviewer
X *	of the project.
X *
X * ARGUMENTS
X *	arg	- list of arguments, including the function name as [0]
X *
X * RETURNS
X *	a pointer to a string in dynamic memory;
X *	or NULL on error, setting suberr appropriately.
X */
X
Xstatic string_ty *sub_reviewer _((wlist *arg));
X
Xstatic string_ty *
Xsub_reviewer(arg)
X	wlist		*arg;
X{
X	string_ty	*result;
X	string_ty	*s;
X
X	trace(("sub_reviewer()\n{\n"/*}*/));
X	assert(cp);
X	if (arg->wl_nwords != 1)
X	{
X		suberr = "requires zero arguments";
X		result = 0;
X	}
X	else
X	{
X		s = change_reviewer_name(cp);
X		if (!s)
X		{
X			suberr = "not meaningful in current state";
X			result = 0;
X		}
X		else
X			result = str_copy(s);
X	}
X	trace(("return \"%s\";\n", result ? result->str_text : suberr));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_reviewer_list - the reviewer_list substitution
X *
X * SYNOPSIS
X *	string_ty *sub_reviewer_list(wlist *arg);
X *
X * DESCRIPTION
X *	The sub_reviewer_list function implements the reviewer_list substitution.
X *	The reviewer_list substitution is replaced by a space separated list
X *	of the project's reviewers.
X *
X * ARGUMENTS
X *	arg	- list of arguments, including the function name as [0]
X *
X * RETURNS
X *	a pointer to a string in dynamic memory;
X *	or NULL on error, setting suberr appropriately.
X */
X
Xstatic string_ty *sub_reviewer_list _((wlist *));
X
Xstatic string_ty *
Xsub_reviewer_list(arg)
X	wlist		*arg;
X{
X	string_ty	*result;
X	pstate		pstate_data;
X	long		j;
X
X	trace(("sub_reviewer_list()\n{\n"/*}*/));
X	if (arg->wl_nwords != 1)
X	{
X		suberr = "requires zero arguments";
X		result = 0;
X	}
X	else
X	{
X		/*
X		 * build a string containing all of the project reviewers
X		 */
X		assert(pp);
X		pstate_data = project_pstate_get(pp);
X		assert(pstate_data->reviewer);
X		switch (pstate_data->reviewer->length)
X		{
X		case 0:
X			result = str_from_c("");
X			break;
X	
X		case 1:
X			result = str_copy(pstate_data->reviewer->list[0]);
X			break;
X	
X		default:
X			assert(pstate_data->reviewer->length >= 2);
X			result = str_copy(pstate_data->reviewer->list[0]);
X			for (j = 1; j < pstate_data->reviewer->length; ++j)
X			{
X				string_ty	*s;
X	
X				s =
X					str_format
X					(
X						"%S %S",
X						result,
X						pstate_data->reviewer->list[j]
X					);
X				str_free(result);
X				result = s;
X			}
X			break;
X		}
X	}
X	trace(("return \"%s\";\n", result ? result->str_text : suberr));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_source - the source substitution
X *
X * SYNOPSIS
X *	string_ty *sub_source(wlist *arg);
X *
X * DESCRIPTION
X *	The sub_source function implements the source substitution.
X *	The source substitution is replaced by the path of the source file,
X *	depending on wether it is in the baseline or the change.
X *	If the file named in the argument is in the change,
X *	the name will be left unchanged,
X *	but if the file is in the baseline, an absolute path will resiult.
X *	If the change is being integrated, it will always be left untouched.
X *
X *	Requires exactly one argument.
X *
X * ARGUMENTS
X *	arg	- list of arguments, including the function name as [0]
X *
X * RETURNS
X *	a pointer to a string in dynamic memory;
X *	or NULL on error, setting suberr appropriately.
X */
X
Xstatic string_ty *sub_source _((wlist *arg));
X
Xstatic string_ty *
Xsub_source(arg)
X	wlist		*arg;
X{
X	string_ty	*result;
X	cstate		cstate_data;
X
X	trace(("sub_source()\n{\n"/*}*/));
X	cstate_data = change_cstate_get(cp);
X	if (arg->wl_nwords != 2)
X	{
X		suberr = "requires one argument";
X		result = 0;
X	}
X	else if (cstate_data->state == cstate_state_awaiting_development)
X	{
X		suberr = "not meaningful in current state";
X		result = 0;
X	}
X	else
X	{
X		/*
X		 * Make sure the named file exists
X		 * either in the change or in the project.
X		 */
X		if (!change_src_find(cp, arg->wl_word[1]))
X		{
X			if (project_src_find(cp->pp, arg->wl_word[1]))
X			{
X				/*
X				 * if the project is is the 'being
X				 * developed' state, need to qualify
X				 * the file name with the baseline
X				 * directory name.
X				 *
X				 * If the change is in the 'being
X				 * integrated' state, don't do
X				 * anything, as files in the
X				 * project AND files in the change
X				 * are below the current directory.
X				 */
X				if
X				(
X					cstate_data->state
X				<
X					cstate_state_being_integrated
X				)
X				{
X					result =
X						str_format
X						(
X							"%S/%S",
X					project_baseline_path_get(cp->pp, 0),
X							arg->wl_word[1]
X						);
X				}
X				else
X					result = str_copy(arg->wl_word[1]);
X			}
X			else
X			{
X				suberr = "source file unknown";
X				result = 0;
X			}
X		}
X		else
X			result = str_copy(arg->wl_word[1]);
X	}
X	trace(("return \"%s\";\n", result ? result->str_text : suberr));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_upcase - the upcase substitution
X *
X * SYNOPSIS
X *	string_ty *sub_upcase(wlist *arg);
X *
X * DESCRIPTION
X *	The sub_upcase function implements the upcase substitution.
X *	The upcase substitution is replaced by the single argument
X *	mapped to upper case.
X *
X *	Requires exactly one argument.
X *
X * ARGUMENTS
X *	arg	- list of arguments, including the function name as [0]
X *
X * RETURNS
X *	a pointer to a string in dynamic memory;
X *	or NULL on error, setting suberr appropriately.
X */
X
Xstatic string_ty *sub_upcase _((wlist *arg));
X
Xstatic string_ty *
Xsub_upcase(arg)
X	wlist		*arg;
X{
X	string_ty	*result;
X
X	trace(("sub_upcase()\n{\n"/*}*/));
X	if (arg->wl_nwords != 2)
X	{
X		suberr = "requires one argument";
X		result = 0;
X	}
X	else
X		result = str_upcase(arg->wl_word[1]);
X	trace(("return \"%s\";\n", result ? result->str_text : suberr));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_version - the version substitution
X *
X * SYNOPSIS
X *	string_ty *sub_version(wlist *arg);
X *
X * DESCRIPTION
X *	The sub_version function implements the version substitution.
X *	The version substitution is replaced by the version of the chnage.
X *
X *	If the change is not in the being_integrated or completed states,
X *	the version will be major.minor.Cnumber, where
X *	"major" is the project major version number,
X *	"minor" is the project minor version number, and
X *	"change" is a 3 digit change number, possibly zero padded.
X *
X *	If the change is in the being_integrated or completed state,
X *	the version will be major.minor.Cdelta, where
X *	"delta" is a 3 digit delta number, possibly zero padded.
X *
X * ARGUMENTS
X *	arg	- list of arguments, including the function name as [0]
X *
X * RETURNS
X *	a pointer to a string in dynamic memory;
X *	or NULL on error, setting suberr appropriately.
X */
X
Xstatic string_ty *sub_version _((wlist *arg));
X
Xstatic string_ty *
Xsub_version(arg)
X	wlist		*arg;
X{
X	string_ty	*result;
X	pstate		pstate_data;
X	cstate		cstate_data;
X
X	trace(("sub_version()\n{\n"/*}*/));
X	assert(cp);
X	if (arg->wl_nwords != 1)
X	{
X		suberr = "requires zero arguments";
X		result = 0;
X	}
X	else
X	{
X		pstate_data = project_pstate_get(pp);
X		cstate_data = change_cstate_get(cp);
X		if (cstate_data->state < cstate_state_being_integrated)
X		{
X			result =
X				str_format
X				(
X					"%ld.%ld.C%3.3ld",
X					pstate_data->version_major,
X					pstate_data->version_minor,
X					cp->number
X				);
X		}
X		else
X		{
X			result =
X				str_format
X				(
X					"%ld.%ld.D%3.3ld",
X					pstate_data->version_major,
X					pstate_data->version_minor,
X					cstate_data->delta_number
X				);
X		}
X	}
X	trace(("return \"%s\";\n", result ? result->str_text : suberr));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
Xstatic table_ty	table[] =
X{
X	{ "Administrator_List",		sub_administrator_list,		},
X	{ "BaseLine",			sub_baseline,			},
X	{ "Basename",			sub_basename,			},
X	{ "Change",			sub_change,			},
X	{ "DAte",			sub_date,			},
X	{ "DELta",			sub_delta,			},
X	{ "DEVeloper",			sub_developer,			},
X	{ "DEVeloper_List",		sub_developer_list,		},
X	{ "Development_Directory",	sub_development_directory,	},
X	{ "Dirname",			sub_dirname,			},
X	{ "DownCase",			sub_downcase,			},
X	/* Edit								*/
X	/* File_Name							*/
X	/* History							*/
X	/* Input							*/
X	{ "IDentifier",			sub_identifier,			},
X	{ "INTegration_Directory",	sub_integration_directory,	},
X	{ "INTegrator",			sub_integrator,			},
X	{ "INTegrator_List",		sub_integrator_list,		},
X	/* Most_Recent							*/
X	/* Output							*/
X	/* ORiginal							*/
X	{ "Project",			sub_project,			},
X	{ "Reviewer",			sub_reviewer,			},
X	{ "Reviewer_List",		sub_reviewer_list,		},
X	{ "Source",			sub_source,			},
X	{ "UpCase",			sub_upcase,			},
X	{ "Version",			sub_version,			},
X};
X
X
X/*
X * NAME
X *	sub_diversion
X *
X * SYNOPSIS
X *	void sub_diversion(string_ty *s);
X *
X * DESCRIPTION
X *	The sub_diversion function is used to divert input
X *	to a string, until that string is exhausted.
X *	When the string is exhausted, input will resume
X *	from the previous string.
X *
X * ARGUMENTS
X *	s - string to take as input
X */
X
Xstatic void sub_diversion _((string_ty *));
X
Xstatic void
Xsub_diversion(s)
X	string_ty	*s;
X{
X	diversion_ty	*dp;
X
X	trace(("sub_diversion(\"%s\")\n{\n"/*}*/, s->str_text));
X	dp = (diversion_ty *)mem_alloc(sizeof(diversion_ty));
X	dp->text = str_copy(s);
X	dp->pos = 0;
X	dp->prev = diversion;
X	diversion = dp;
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	sub_diversion_close
X *
X * SYNOPSIS
X *	void sub_diversion_close(void);
X *
X * DESCRIPTION
X *	The sub_diversion_close function is used to
X *	release a diversion when it has been exhausted.
X */
X
Xstatic void sub_diversion_close _((void));
X
Xstatic void
Xsub_diversion_close()
X{
X	diversion_ty	*dp;
X
X	trace(("sub_diversion_close()\n{\n"/*}*/));
X	assert(diversion);
X	dp = diversion;
X	diversion = dp->prev;
X	assert(dp->pos == dp->text->str_length);
X	str_free(dp->text);
X	mem_free((char *)dp);
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	execute
X *
X * SYNOPSIS
X *	void execute(wlist *args);
X *
X * DESCRIPTION
X *	The execute function is used to perform the substitution
X *	described by the argument list.
X *
X * ARGUMENTS
X *	args - the name and arguments of the substitution
X */
X
Xstatic void execute _((wlist *));
X
Xstatic void
Xexecute(arg)
X	wlist		*arg;
X{
X	char		*cmd;
X	string_ty	*s;
X	table_ty	*hit[20];
X	int		nhits;
X	table_ty	*tp;
X	long		j;
X
X	trace(("execute()\n{\n"/*}*/));
X	if (arg->wl_nwords == 0)
X		fatal("empty ${} substitution");
X	
X	/*
X	 * scan the variables
X	 */
X	nhits = 0;
X	cmd = arg->wl_word[0]->str_text;
X	for (j = 0; j < sub_var_pos; ++j)
X	{
X		tp = &sub_var_list[j];
X		if (arglex_compare(tp->name, cmd))
X		{
X			if (nhits < SIZEOF(hit))
X				hit[nhits++] = tp;
X		}
X	}
X
X	/*
X	 * scan the functions
X	 */
X	for (tp = table; tp < ENDOF(table); ++tp)
X	{
X		if (arglex_compare(tp->name, cmd))
X		{
X			if (nhits < SIZEOF(hit))
X				hit[nhits++] = tp;
X		}
X	}
X
X	/*
X	 * figure what to do
X	 */
X	switch (nhits)
X	{
X	case 0:
X		suberr = "unknown substitution name";
X		s = 0;
X		break;
X
X	case 1:
X		tp = hit[0];
X		if (tp->value)
X		{
X			s = str_copy(tp->value);
X			if (isdigit(tp->name[0]))
X			{
X				error
X				(
X       "warning: the %%%s substitution has been replaced by %s in this context",
X					tp->name,
X					s->str_text
X				);
X			}
X			trace(("%s -> %s\n", tp->name, s->str_text));
X		}
X		else
X		{
X			str_free(arg->wl_word[0]);
X			arg->wl_word[0] = str_from_c(tp->name);
X			s = tp->func(arg);
X		}
X		break;
X
X	default:
X		suberr = "ambiguous substitution name";
X		s = 0;
X		break;
X	}
X
X	/*
X	 * deal with the result
X	 */
X	if (s)
X	{
X		sub_diversion(s);
X		str_free(s);
X	}
X	else
X	{
X		string_ty	*s2;
X
X		s2 = wl2str(arg, 0, 32767);
X		fatal
X		(
X			"substitution ${%s} failed: %s",
X			s2->str_text,
X			suberr
X		);
X		str_free(s2);
X	}
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	sub_getc_meta
X *
X * SYNOPSIS
X *	void sub_getc_meta(void);
X *
X * DESCRIPTION
X *	The sub_getc_meta function is used to get a character from
X *	the current input string.  When the current string is exhaused,
X *	the previous string is resumed.
X *
X * RETURNS
X *	int - the chacater, or NUL to indicate end of input
X */
X
Xstatic int sub_getc_meta _((void));
X
Xstatic int
Xsub_getc_meta()
X{
X	int		result;
X	diversion_ty	*dp;
X
X	trace(("sub_getc_meta()\n{\n"/*}*/));
X	dp = diversion;
X	if (!dp)
X		result = 0;
X	else if (dp->pos >= dp->text->str_length)
X		result = 0;
X	else
X		result = dp->text->str_text[dp->pos++];
X	trace(("return '%c';\n", result ? result : 0x80));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_getc_meta_undo
X *
X * SYNOPSIS
X *	void sub_getc_meta_undo(int c);
X *
X * DESCRIPTION
X *	The sub_getc_meta_undo function is used to give back
X *	a character output by sub_getc_meta.
X *
X * ARGUMENTS
X *	c - character being given back
X *
X * CAVEAT
X *	Only push back what was read.
X */
X
Xstatic void sub_getc_meta_undo _((int));
X
Xstatic void
Xsub_getc_meta_undo(c)
X	int		c;
X{
X	diversion_ty	*dp;
X
X	trace(("sub_getc_meta_undo('%c')\n{\n"/*}*/, c ? c : 0x80));
X	dp = diversion;
X	assert(dp);
X	if (!c)
X	{
X		assert(dp->pos == dp->text->str_length);
X	}
X	else
X	{
X		assert(dp->pos >= 1);
X		dp->pos--;
X		assert(c == dp->text->str_text[dp->pos]);
X	}
X	trace((/*{*/"}\n"));
X}
X
X
X/*
X * NAME
X *	collect
X *
X * SYNOPSIS
X *	void collect(int c);
X *
X * DESCRIPTION
X *	The collect function is used to accumulate a string
X *	one character at a time.  No size limit.
X *
X * ARGUMENTS
X *	c - the character being collected
X */
X
Xstatic void collect _((int));
X
Xstatic void
Xcollect(c)
X	int	c;
X{
X	if (collect_pos >= collect_size)
X	{
X		collect_size += (1L << 10);
X		if (!collect_buf)
X			collect_buf = mem_alloc(collect_size);
X		else
X			mem_change_size(&collect_buf, collect_size);
X	}
X	collect_buf[collect_pos++] = c;
X}
X
X
X/*
X * NAME
X *	collect_end
X *
X * SYNOPSIS
X *	string_ty *collect_end(void);
X *
X * DESCRIPTION
X *	The collect_end function is used to fetch the string
X *	accumulated with the collect function.
X *	The bufferer for the collect function is cleared.
X *
X * RETURNS
X *	string_ty *; pointer to the string in dynamic memory.
X */
X
Xstatic string_ty *collect_end _((void));
X
Xstatic string_ty *
Xcollect_end()
X{
X	string_ty	*result;
X
X	result = str_n_from_c(collect_buf, collect_pos);
X	collect_pos = 0;
X	return result;
X}
X
X
X/*
X * NAME
X *	percent
X *
X * SYNOPSIS
X *	int percent(void);
X *
X * DESCRIPTION
X *	The percent function is used to perform percent (%) substitutions.
X *	On entry, the % is expected to have been consumed.
X *
X *	The substitution is usually achieved as a side-effect,
X *	by using the sub_diversion function.
X *
X * RETURNS
X *	int	a character to deliver as output,
X *		or NUL if none.
X */
X
Xstatic int percent _((void));
X
Xstatic int
Xpercent()
X{
X	int		c;
X	int		result;
X	int		c2;
X	string_ty	*s;
X	static int	warned;
X	string_ty	*s2;
X
X	trace(("percent()\n{\n"/*}*/));
X	result = 0;
X	c = sub_getc_meta();
X	switch (c)
X	{
X	case 'P':
X		c2 = sub_getc_meta();
X		if (!isdigit(c2))
X		{
X			sub_getc_meta_undo(c2);
X			sub_getc_meta_undo(c);
X			result = '%';
X			break;
X		}
X		s = str_format("${dirname ${%c}}", c2);
X		sub_diversion(s);
X		str_free(s);
X		break;
X
X	case 'F':
X		c2 = sub_getc_meta();
X		if (!isdigit(c2))
X		{
X			sub_getc_meta_undo(c2);
X			sub_getc_meta_undo(c);
X			result = '%';
X			break;
X		}
X		s = str_format("${basename ${%c}}", c2);
X		sub_diversion(s);
X		str_free(s);
X		break;
X
X	case '0': case '1': case '2': case '3': case '4':
X	case '5': case '6': case '7': case '8': case '9':
X		s = str_format("${%c}", c);
X		sub_diversion(s);
X		str_free(s);
X		break;
X
X	case '('/*)*/:
X		for (;;)
X		{
X			c = sub_getc_meta();
X			if (!c)
X				fatal("unterminated %%() substitution");
X			if (c == /*(*/')')
X				break;
X			collect(c);
X		}
X		s2 = collect_end();
X		s = str_format("${source %S}", s2);
X		str_free(s2);
X		sub_diversion(s);
X		str_free(s);
X		break;
X
X	default:
X		sub_getc_meta_undo(c);
X		result = '%';
X		break;
X	}
X	if (!result && !warned)
X	{
X		error
X		(
X"warning: the percent (%%) substitutions are obsolescent, \
Xplease use the equivalent dollar ($) substitution"
X		);
X		warned = 1;
X	}
X	trace(("return '%c'\n", result ? result : 0x80));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	dollar
X *
X * SYNOPSIS
X *	void dollar(void);
X *
X * DESCRIPTION
X *	The dollar function is used to perform dollar ($) substitutions.
X *	On entry, the $ is expected to have been consumed.
X *
X *	The substitution is usually achieved as a side-effect,
X *	by using the sub_diversion function.
X *
X * RETURNS
X *	int	a character to deliver as output,
X *		or NUL if none.
X */
X
Xstatic int sub_getc _((void)); /* forward */
X
Xstatic int dollar _((void));
X
Xstatic int
Xdollar()
X{
X	wlist		arg;
X	int		result;
X	int		c;
X	string_ty	*s;
X
X	trace(("dollar()\n{\n"/*}*/));
X	wl_zero(&arg);
X	result = 0;
X	c = sub_getc_meta();
X	switch (c)
X	{
X	case '0': case '1': case '2': case '3': case '4':
X	case '5': case '6': case '7': case '8': case '9': 
X		for (;;)
X		{
X			collect(c);
X			c = sub_getc_meta();
X			if (!isdigit(c))
X			{
X				sub_getc_meta_undo(c);
X				break;
X			}
X		}
X		s = collect_end();
X		wl_append(&arg, s);
X		str_free(s);
X		execute(&arg);
X		wl_free(&arg);
X		break;
X
X	case 'a': case 'b': case 'c': case 'd': case 'e':
X	case 'f': case 'g': case 'h': case 'i': case 'j':
X	case 'k': case 'l': case 'm': case 'n': case 'o':
X	case 'p': case 'q': case 'r': case 's': case 't':
X	case 'u': case 'v': case 'w': case 'x': case 'y': case 'z': 
X	case 'A': case 'B': case 'C': case 'D': case 'E':
X	case 'F': case 'G': case 'H': case 'I': case 'J':
X	case 'K': case 'L': case 'M': case 'N': case 'O':
X	case 'P': case 'Q': case 'R': case 'S': case 'T':
X	case 'U': case 'V': case 'W': case 'X': case 'Y': case 'Z': 
X		for (;;)
X		{
X			collect(c);
X			c = sub_getc_meta();
X			if (!isalnum(c) && c != '_' && c != '-')
X			{
X				sub_getc_meta_undo(c);
X				break;
X			}
X		}
X		s = collect_end();
X		wl_append(&arg, s);
X		str_free(s);
X		execute(&arg);
X		wl_free(&arg);
X		break;
X
X	case '{'/*}*/:
X		c = sub_getc();
X		for (;;)
X		{
X			/*
X			 * look for terminator
X			 */
X			if (c == /*{*/'}')
X				break;
X
X			/*
X			 * watch out for unterminated substitutions
X			 */
X			if (!c)
X			{
X				fatal("unterminated ${} substitution");
X				break;
X			}
X
X			/*
X			 * skip white space separating the arguments
X			 */
X			if (isspace(c))
X			{
X				c = sub_getc();
X				continue;
X			}
X
X			/*
X			 * collect the argument
X			 *	any run of non-white-space characters
X			 */
X			for (;;)
X			{
X				collect(c);
X				c = sub_getc();
X				if (!c || isspace(c) || c == /*{*/'}')
X					break;
X			}
X			s = collect_end();
X			wl_append(&arg, s);
X			str_free(s);
X		}
X		execute(&arg);
X		wl_free(&arg);
X		break;
X
X	case '$':
X		result = '$';
X		break;
X
X	default:
X		sub_getc_meta_undo(c);
X		result = '$';
X		break;
X	}
X	trace(("return '%c';\n", result ? result : 0x80));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_getc
X *
X * SYNOPSIS
X *	int sub_getc(void);
X *
X * DESCRIPTION
X *	The sub_getc function is used to get a character from
X *	the substitution stream.  This is used both for the final output
X *	and for fetching arguments to dollar ($) substitutions.
X *
X * RETURNS
X *	int	a character from the stream,
X *		or NUL to indicate end of input.
X */
X
Xstatic int sub_getc _((void));
X
Xstatic int
Xsub_getc()
X{
X	int	c;
X
X	trace(("sub_getc()\n{\n"/*}*/));
X	for (;;)
X	{
X		c = sub_getc_meta();
X		switch (c)
X		{
X		default:
X			break;
X
X		case 0:
X			if (!diversion)
X				break;
X			sub_diversion_close();
X			continue;
X
X		case '%':
X			c = percent();
X			if (!c)
X				continue;
X			break;
X
X		case '$':
X			c = dollar();
X			if (!c)
X				continue;
X			break;
X		}
X		break;
X	}
X	trace(("return '%c';\n", c ? c : 0x80));
X	trace((/*{*/"}\n"));
X	return c;
X}
X
X
X/*
X * NAME
X *	substitute
X *
X * SYNOPSIS
X *	string_ty *substitute(change_ty *cp, string_ty *s);
X *
X * DESCRIPTION
X *	The substitute function is used to perform substitutions on
X *	strings.  Usually command strings, but not always.
X *
X *	The format of substitutions, and the commonly available
X *	substitutions, are described in aesub(5).
X *
X * ARGUMENTS
X *	cp	- the aegis change involved with the command
X *		  This may never be NULL.
X *	s	- the string to be substituted.
X *
X * RETURNS
X *	string_ty *; pointer to string in dynamic memory
X */
X
Xstring_ty *
Xsubstitute(acp, s)
X	change_ty	*acp;
X	string_ty	*s;
X{
X	static char	*buffer;
X	static size_t	buflen;
X	size_t		pos;
X	int		c;
X	string_ty	*result;
X
X	trace(("substitute(acp = %08lX, s = \"%s\")\n{\n"/*}*/,
X		(long)acp, s->str_text));
X	assert(acp);
X	cp = acp;
X	pp = acp->pp;
X
X	sub_diversion(s);
X	pos = 0;
X	if (!buffer)
X	{
X		buflen = (1L << 10);
X		buffer = mem_alloc(buflen);
X	}
X	for (;;)
X	{
X		/*
X		 * get the next character
X		 */
X		c = sub_getc();
X		if (!c)
X			break;
X
X		/*
X		 * make sure there is room
X		 */
X		if (pos >= buflen)
X		{
X			buflen += (1L << 10);
X			mem_change_size(&buffer, buflen);
X		}
X
X		/*
X		 * save the character
X		 */
X		buffer[pos++] = c;
X	}
X	sub_var_clear();
X	cp = 0;
X	pp = 0;
X	result = str_n_from_c(buffer, pos);
X	trace(("return \"%s\";\n", result->str_text));
X	trace((/*{*/"}\n"));
X	return result;
X}
X
X
X/*
X * NAME
X *	sub_var_clear
X *
X * SYNOPSIS
X *	void sub_var_clear(void);
X *
X * DESCRIPTION
X *	The sub_var_clear function is used to clear all of
X *	the substitution variables.  Not usually needed manually,
X *	as this is done automatically at the end of every substitute().
X */
X
Xvoid
Xsub_var_clear()
X{
X	size_t	j;
X
X	for (j = 0; j < sub_var_pos; ++j)
X		str_free(sub_var_list[j].value);
X	sub_var_pos = 0;
X}
X
X
X/*
X * NAME
X *	sub_var_set
X *
X * SYNOPSIS
X *	void sub_var_set(char *name, char *fmt, ...);
X *
X * DESCRIPTION
X *	The sub_var_set function is used to set the value of a
X *	substitution variable.  These variables are command specific,
X *	as opposed to the functions which are always present.
X *	The user documentation does NOT make this distinction by
X *	using the names "variable" and "function", they are always referred
X *	to as "substitutions".
X *
X * ARGUMENTS
X *	name	- the name of the variable
X *	fmt,...	- a format string and arguments to construct the value.
X *		  Handed to str_vformat to make a (string_ty *) out of it.
X *
X * CAVEAT
X *	remains in scope until the next invokation of sub_var_clear,
X *	or until the end of the next invokation of substitute.
X */
X
Xvoid
Xsub_var_set(name, fmt sva_last)
X	char		*name;
X	char		*fmt;
X	sva_last_decl
X{
X	va_list		ap;
X	string_ty	*s;
X	table_ty	*svp;
X
X	sva_init(ap, fmt);
X	s = str_vformat(fmt, ap);
X	va_end(ap);
X
X	if (sub_var_pos >= sub_var_size)
X	{
X		size_t	nbytes;
X
X		sub_var_size += 10;
X		nbytes = sub_var_size * sizeof(table_ty);
X		if (!sub_var_list)
X			sub_var_list = (table_ty *)mem_alloc(nbytes);
X		else
X			mem_change_size((char **)&sub_var_list, nbytes);
X	}
X	svp = &sub_var_list[sub_var_pos++];
X	svp->name = name;
X	svp->value = s;
X}
END_OF_FILE
if test 43195 -ne `wc -c <'aegis/sub.c'`; then
    echo shar: \"'aegis/sub.c'\" unpacked with wrong size!
fi
# end of 'aegis/sub.c'
fi
if test -f 'doc/c2.1.so' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/c2.1.so'\"
else
echo shar: Extracting \"'doc/c2.1.so'\" \(44300 characters\)
sed "s/^X//" >'doc/c2.1.so' <<'END_OF_FILE'
X.\"
X.\"	aegis - project change supervisor
X.\"	Copyright (C) 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: User Guide, The Change Development Cycle, The Developer
X.\"
X.nh 2 "The Developer"
X.LP
XThe developer role is the coal face.
XThis is where new software is written,
Xand bugs are fixed.
XThis example shows only the addition of new functionality,
Xbut usually as modifications of existing code,
Xsimilar to bug-fixing activity.
X.nh 3 "The First Change"
X.LP
XWhile the units of change, unoriginally, are called "changes",
Xthis also applies to the start of a project - a change to nothing, if you like.
XThe developer of this first change will be Pat.
X.LP
XFirst, Pat has been told by the project administrator
Xthat the change has been created.
XHow Alex created this change will be detailed in the "Administrator" section,
Xlater in this chapter.
XPat then acquires the change and starts work.
X.E(
Xpat% \f(CBaedb -l -p example\fP
XProject "example"
XList of Changes
X.E)
X.E(
XChange  State           Description
X------- -------         -------------
X   1    awaiting_       Create initial skeleton.
X        development
Xpat% \f(CBaedb example 1\fP
Xaegis: project "example": change 1: development directory "/u/pat/
X        example.001"
Xaegis: project "example": change 1: user "pat" has begun development
Xpat% \f(CBaecd\fP
Xaegis: project "example": change 1: /u/pat/example.001
Xpat%
X.E)
X.LP
XAt this point aegis has created a development directory for the change
Xand Pat has changed directory to the development directory\**.
X.FS
XThe default directory in which to place new development directories
Xis configurable for each user.
X.FE
X.LP
XFive files will be created by this change.
X.E(
Xpat% \f(CBaenf config Howto.cook gram.y lex.l main.c\fP
Xaegis: project "example": change 1: file "Howto.cook" added
Xaegis: project "example": change 1: file "config" added
Xaegis: project "example": change 1: file "gram.y" added
Xaegis: project "example": change 1: file "lex.l" added
Xaegis: project "example": change 1: file "main.c" added
Xpat%
X.fi
X.E)
X.LP
XThe contents of the
X.I config
Xfile will not be described in this section,
Xas it is covered in the
X.I "Project Configuration File"
Xchapter.
XThe contents of the
X.I Howto.cook
Xfile will not be described in this section,
Xas it is covered in the
X.I "Dependency Maintenance Tool"
Xchapter.
X.LP
XThe file
X.I main.c
Xwill have been created by aegis
Xas an empty file.
XPat edits it to look like this
X.E(
X#include <stdio.h>
X.E)
X.E(
Xstatic void
Xusage()
X{
X        fprintf(stderr, "usage: example\en");
X        exit(1);
X}
X.E)
X.E(
Xvoid
Xmain(argc, argv)
X        int     argc;
X        char    **argv;
X{
X        if (argc != 1)
X                usage();
X        yyparse();
X        exit(0);
X}
X.E)
X.LP
XThe file
X.I gram.y
Xdescribes the grammar accepted by the calculator.
XThis file was also created empty by aegis,
Xand Pat edits it to look like this:
X.E(
X%token  DOUBLE
X%token  NAME
X.E)
X.E(
X%union
X{
X        int     lv_int;
X        double  lv_double;
X}
X.E)
X.E(
X%type <lv_double> DOUBLE expr
X%type <lv_int> NAME
X.E)
X.E(
X%prec '+' '-'
X%prec '*' '/'
X%prec UNARY
X.E)
X.E(
X%%
X.E)
X.E(
Xexample
X        : /* empty */
X        | example command
Xcommand
X        : expr
X        | error
Xexpr
X        : DOUBLE
X                { $$ = $1; }
X        | '(' expr ')'
X                { $$ = $2; }
X        | '-' expr
X                %prec UNARY
X                { $$ = -$2; }
X        | expr '*' expr
X                { $$ = $1 * $3; }
X        | expr '/' expr
X                { $$ = $1 / $3; }
X        | expr '+' expr
X                { $$ = $1 + $3; }
X        | expr '-' expr
X                { $$ = $1 - $3; }
X.E)
X.LP
XThe file
X.I lex.l
Xdescribes a simple lexical analyzer.
XIt will be processed by \fIlex\fP(1) to produce C code
Ximplementing the lexical analyzer.
XThis kind of simple lexer is usually  hand crafted,
Xbut using lex allows the example to be far smaller.
XPat edits the file to look like this:
X.E(
X%{
X#include <math.h>
X#include <gram.h>
X%}
X%%
X[ \et\en]+      ;
X[0-9]+(\e.[0-9]*)?([eE][+-]?[0-9]+)?    {
X                yylval.lv_double = atof(yytext);
X                return DOUBLE;
X        }
X[a-z]   {
X                yylval.lv_int = yytext[0] - 'a';
X                return NAME;
X        }
X\&.       return yytext[0];
X.E)
X.LP
XNote how the
X.I gram.h
Xfile is included using the
X\fC#include <\f(CIfilename\fC>\fR
Xform.
XThis is very important for builds in later changes,
Xand is discussed more fully in the
X.I "Tips and Traps"
Xchapter.
X.LP
XThe files are processed, compiled and linked together using the
X.I aeb
Xcommand;
Xthis is known as
X.I building
Xa change.
XThis is done through aegis
Xso that aegis can know the success or failure of the build.
X(Build success is a precondition for a change to leave
Xthe
X.I "being developed"
Xstate.)
XThe build command is in the
X.I config
Xfile so vaguely described earlier.
XIn this example it will use the \fIcook\fP(1) command
Xwhich in turn will use the
X.I Howto.cook
Xfile,
Xalso alluded to earlier.
XThis file describes the commands and dependencies for the various
Xprocessing, compiling and linking.
X.E(
Xpat% \f(CBaeb\fP
Xaegis: project "example": change 1: development build started
Xaegis: cook -b Howto.cook project=example change=1
X        version=1.0.C001 -nl
Xcook: yacc -d gram.y
Xcook: mv y.tab.c gram.c
Xcook: mv y.tab.h gram.h
Xcook: cc -I. -I/projects/example/baseline -O -c gram.c
Xcook: lex lex.l
Xcook: mv lex.yy.c lex.c
Xcook: cc -I. -I/projects/example/baseline -O -c lex.c
Xcook: cc -I. -I/projects/example/baseline -O -c main.c
Xcook: cc -o example gram.o lex.o main.o -ll -ly
Xaegis: project "example": change 1: development build complete
Xpat%
X.E)
X.LP
XThe example program is built, and Pat could even try it out:
X.E(
Xpat% \f(CBexample\fP
X\f(CB1 + 2\fP
X3
X\f(CB^D\fP
Xpat%
X.E)
X.LP
XAt this point the change is apparently finished.
XThe command to tell aegis this is the
X.I "develop end"
Xcommand:
X.E(
Xpat% \f(CBaede\fP
Xaegis: project "example": change 1: no current 'aegis -DIFFerence'
X        registration
Xpat%
X.E)
X.LP
XIt didn't work, because aegis thinks you have missed the difference step.
X.LP
XThe difference step is used to produce files useful for reviewing changes,
Xmostly in the form of context difference files between the project baseline
Xand the development directory.
XContext differences allow reviewers to see exactly what has changed,
Xand not have to try to track them down and inevitably miss obscure
Xbut important edits to large or complex files.
X.E(
Xpat% \f(CBaed\fP
Xaegis: set +e; diff -c /dev/null /u/pat/example.001/Howto.cook >
X        /u/pat/example.001/Howto.cook,D; test $? -eq 0 -o $? -eq 1
Xaegis: set +e; diff -c /dev/null /u/pat/example.001/config >
X        /u/pat/example.001/config,D; test $? -eq 0 -o $? -eq 1
Xaegis: set +e; diff -c /dev/null /u/pat/example.001/gram.y >
X        /u/pat/example.001/gram.y,D; test $? -eq 0 -o $? -eq 1
Xaegis: set +e; diff -c /dev/null /u/pat/example.001/lex.l >
X        /u/pat/example.001/lex.l,D; test $? -eq 0 -o $? -eq 1
Xaegis: set +e; diff -c /dev/null /u/pat/example.001/main.c >
X        /u/pat/example.001/main.c,D; test $? -eq 0 -o $? -eq 1
Xaegis: project "example": change 1: difference complete
Xpat%
X.E)
X.LP
XDoing a difference for a new file may appear a little pedantic,
Xbut when a change consists of tens of files,
Xso modifications of existing files and some new,
Xthere is a temptation for reviewers to use "more *,D"
Xand thus completely miss the new files if it were not for this pedanticism\**.
X.FS
XThis is especially true when you use a tool
Xsuch as \fIfcomp\fP(1)
Xwhich gives a complete file listing with the
Xinserts and deletes marked in the margin.
XThis tool is also available from the author of aegis.
X.FE
X.LP
XSo that reviewers,
Xand conscientious developers,
Xmay locate and view all of these difference files,
Xthe command
X.E(
Xpat% \f(CBmore `find . -name "*,D" -print | sort`\fP
X\fI\&.\&.\&.examines each file.\&.\&.\fP
Xpat%
X.E)
Xcould be used,
Xhowever this is a little too long winded for most users,
Xand so the
X.I aedmore
Xalias does exactly this.
XThere is a similar
X.I aedless
Xalias for those who prefer the
X.I less (1)
Xcommand.
X.LP
XSo now Pat is done, let's try to sign off again:
X.E(
Xpat% \f(CBaede\fP
Xaegis: project "example": change 1: no current 'aegis -Test'
X        registration
Xpat%
X.E)
X.LP
XIt didn't work, again.
XThis time aegis is reminding Pat that
Xevery change must be accompanied by at least one test.
XThis is so that the project team can be confident at all times
Xthat a project works\**.
X.FS
XAs discussed in the
X.I "Tips and Traps"
Xchapter,
Xaegis has the objective of ensuring that projects always work,
Xwhere "works" is defined as passing all tests in the project's baseline.
XA change "works" if it passes all of its accompanying tests.
X.FE
XMaking this a precondition to leave the
X.I "being developed"
Xstate means that
Xa reviewer can be sure that a change builds and passes its tests
Xbefore it can ever be reviewed.
XPat adds the truant test:
X.E(
Xpat% \f(CBaent\fP
Xaegis: project "example": change 1: file "test/00/t0001a.sh" new
X        test
Xpat%
X.E)
X.LP
XThe test file is in a weird place, eh?
XThis is because many flavours of
X.UX
Xare slow at searching
Xdirectories, and so aegis limits itself to 100 tests per directory.
XWhatever the name, Pat edits the test file to look like this:
X.E(
X#!/bin/sh
X#
X# test simple arithmetic
X#
Xtmp=/tmp/$$
Xhere=`pwd`
Xif [ $? -ne 0 ]; then exit 1; fi
X.E)
X.E(
Xfail()
X{
X        echo FAILED 1>&2
X        cd $here
X        rm -rf $tmp
X        exit 1
X}
X.E)
X.E(
Xpass()
X{
X        cd $here
X        rm -rf $tmp
X        exit 0
X}
Xtrap "fail" 1 2 3 15
X.E)
X.E(
Xmkdir $tmp
Xif [ $? -ne 0 ]; then exit 1; fi
Xcd $tmp
Xif [ $? -ne 0 ]; then fail; fi
X.E)
X.E(
X#
X# with input like this
X#
Xcat > test.in << 'foobar'
X1
X(24 - 22)
X-(4 - 7)
X2 * 2
X10 / 2
X4 + 2
X10 - 3
Xfoobar
Xif [ $? -ne 0 ]; then fail; fi
X.E)
X.E(
X#
X# the output should look like this
X#
Xcat > test.ok << 'foobar'
X1
X2
X3
X4
X5
X6
X7
Xfoobar
Xif [ $? -ne 0 ]; then fail; fi
X.E)
X.E(
X#
X# run the calculator
X# and see if the results match
X#
X$here/example < test.in > test.out
Xif [ $? -ne 0 ]; then fail; fi
Xdiff test.ok test.out
Xif [ $? -ne 0 ]; then fail; fi
X.E)
X.E(
X#
X# this much worked
X#
Xpass
X.E)
X.LP
XThere are several things to notice about this test file:
X.XP
X\(bu It is a Bourne shell script.
XAll test files are Bourne shell scripts because they are the most portable.\**
X.FS
XPortable for aegis' point of view:
XBourne shell is the most widely available shell.
XOf course,
Xif you are writing code to publish on USENET or for FTP,
Xportability
Xof the tests will be important from the developer's point of view also.
X.FE
X(Actually, aegis likes test files not to be executable,
Xit passes them to the Bourne shell explicitly when running them.)
X.XP
X\(bu It makes the assumption that the current directory is
Xeither the development directory or the baseline.
XThis is valid,
Xaegis always runs tests this way;
Xif you run one manually, you must take care of this yourself.
X.XP
X\(bu It checks the exit status of each and every command.
XIt is essential that even unexpected and impossible failures are handled.
X.XP
X\(bu A temporary directory is created for temporary files.
XIt cannot be assumed that a test will be run from a directory
Xwhich is writable;
Xit is also easier to clean up after strange errors,
Xsince you need only throw the directory away,
Xrather than track down individual temporary files.
XIt mostly protects against rogue programs scrambling files
Xin the current directory, too.
X.XP
X\(bu Every test is self-contained.
XThe test uses auxiliary files,
Xbut they are not separate source files
X(figuring where they are when some are in a change and some are in the baseline
Xcan be a nightmare).
XIf a test want an auxiliary file,
Xit must construct the file itself,
Xin a temporary directory.
X.XP
X\(bu Two functions have been defined, one for success and one for failure.
XBoth forms remove the temporary directory.
XA test is defined as passing if it returns a 0 exit status,
Xand failing if it returns anything else.
X.XP
X\(bu
XTests are treated just like any other source file,
Xand are subject to the same process.
XThey may be altered in another change,
Xor even deleted later if they are no longer useful.
X.LP
XThe most important feature to note about this test,
Xafter ignoring all of the trappings,
Xis that it doesn't do much you wouldn't do manually!
XTo test this program manually you would
Xfire it up,
Xjust as the test does,
Xyou would give it some input,
Xjust as the test does,
Xand you would compare the output against your expectations
Xof what it will do,
Xjust as the test does.
X.LP
XThe difference with using this test script and doing it manually
Xis that most development contains many iterations of
Xthe "build, test, \fIthink\fP, edit, build, test.\&.\&." cycle.
XAfter a couple of iterations,
Xthe manual testing,
Xthe constant re-typing,
Xbecomes obviously unergonomic.
XUsing a shell script is more efficient,
Xdoesn't forget to test things later,
Xand is preserved for posterity (i.e. adds to the regression test suite).
X.LP
XThis efficiency is especially evident when using commands\**
X.FS
XThis is a \fIcsh\fP specific example, unlike most others.
X.FE
Xsuch as
X.E(
Xpat% \f(CBaeb && aet ; vi aegis.log\fP
X\&.\&.\&.
Xpat% \f(CB!!\fP
X\&.\&.\&.
Xpat%
X.E)
X.LP
XIt is possible to talk to the shell extremely rarely,
Xand then only to re-issue the same command,
Xusing a work pattern such as this.
X.LP
XAs you have already guessed,
XPat now runs the test like this:
X.E(
Xpat% \f(CBaet\fP
Xaegis: sh /u/pat/example.001/test/00/t0001a.sh
Xaegis: project "example": change 1: test "test/00/t0001a.sh"
X        passed
Xaegis: project "example": change 1: passed 1 test
Xpat%
X.E)
X.LP
XFinally,
XPat has built the change,
Xprepared it for review
Xand tested it.
XIt is now ready for sign off.
X.E(
Xpat% \f(CBaede\fP
Xaegis: project "example": change1: no current 'aegis -Build'
X        registration
Xpat%
X.E)
X.LP
XSay what?
XThe problem is that the use of \fIaent\fP cancelled the
Xprevious build registration.
XThis was because aegis is decoupled from the dependency maintenance tool
X(\fIcook\fP in this case),
Xand thus has no way of knowing whether or not the new file in the
Xchange would affect the success or failure of a build\**.
X.FS
XExample:
Xin addition to the executable file "example" shown here,
Xthe build may also produce an archive file
Xof the project's source for export.
XThe addition of one more file may push the size of this archive beyond
Xa size limit;
Xthe build would thus fail because of the addition of a test.
X.FE
XAll that is required is to re-build,
Xre-test,
Xre-difference (yes, the test gets differenced, too)
Xand sign off.
X.E(
Xpat% \f(CBaeb\fP
Xaegis: logging to "/u/pat/example.001/aegis.log"
Xaegis: project "example": change 1: development build started
Xaegis: cook -b Howto.cook project=example change=1
X        version=1.0.C001 -nl
Xcook: "all" is up-to-date
Xaegis: project "example": change 1: development build complete
Xpat% \f(CBaet\fP
Xaegis: logging to "/u/pat/example.001/aegis.log"
Xaegis: sh /u/pat/example.001/test/00/t0001a.sh
Xaegis: project "example": change 1: test "test/00/t0001a.sh"
X        passed
Xaegis: project "example": change 1: passed 1 test
Xpat% \f(CBaed\fP
Xaegis: logging to "/u/pat/example.001/aegis.log"
Xaegis: set +e; diff -c /dev/null /u/pat/example.001/test/00/
X        t0001a.sh > /u/pat/example.001/test/00/t0001a.sh,D; test
X        $? -eq 0 -o $? -eq 1
Xaegis: project "example": change 1: difference complete
Xpat% \f(CBaede\fP
Xaegis: sh /usr/local/lib/aegis/de.sh example 1 pat
Xaegis: project "example": change 1: development completed
Xpat%
X.E)
X.LP
XThe change is now ready to be reviewed.
XThis section is about developers,
Xso we will have to leave this change at this point in its history.
XSome time in the next day or so
XPat receives electronic mail that this change has passed review,
Xand another later to say that it passed integration.
XPat is now free to develop another change,
Xpossibly for a different project.
X.nh 3 "The Second Change"
X.LP
XThe second change was created because someone wanted to
Xname input and output files on the command line,
Xand called the absence of this feature a bug.
XWhen Jan arrived for work,
Xand lists the changes awaiting development,
Xthe following list appeared:
X.E(
Xjan% \f(CBaedb -l -p example\fP
XProject "example"
XList of Changes
X.E)
X.E(
XChange  State           Description
X------  ------          ------------
X   2    awaiting_       Add input and output file names to the
X        development     command line.
X   3    awaiting_       add variables
X        development
X   4    awaiting_       add powers
X        development
Xjan%
X.E)
X.LP
XThe first on the list is chosen.
X.E(
Xjan% \f(CBaedb -c 2 -p example\fP
Xaegis: project "example": change 2: development directory "/u/
X        jan/example.002"
Xaegis: project "example": change 2: user "jan" has begun
X        development
Xjan% \f(CBaecd\fP
Xaegis: project "example": change 2: /u/jan/example.002
Xjan%
X.E)
X.LP
XThe best way to get details about a change is to used the "change details"
Xlisting.
X.E(
Xjan% \f(CBael cd\fP
XProject "example", Change 2
XChange Details
X.E)
X.E(
XNAME
X        Project "example", Change 2.
X.E)
X.E(
XSUMMARY
X        file names on command line
X.E)
X.E(
XDESCRIPTION
X        Optional input and output files may be specified on the
X        command line.
X.E)
X.E(
XCAUSE
X        This change was caused by internal_bug.
X.E)
X.E(
XSTATE
X        This change is in 'being_developed' state.
X.E)
X.E(
XFILES
X        Change has no files.
X.E)
X.E(
XHISTORY
X        What            When            Who     Comment
X        ------          ------          -----   ---------
X        new_change      Fri Dec 11      alex
X                        14:55:06 1992
X        develop_begin   Mon Dec 14      jan
X                        09:07:08 1992
Xjan%
X.E)
X.LP
XThrough one process or another,
XJan determines that the
X.I main.c
Xfile is the one to be modified.
XThis file is copied into the change:
X.E(
Xjan% \f(CBaecp main.c\fP
Xaegis: project "example": change 2: file "main.c" copied
Xjan%
X.E)
X.LP
XThis file is now extended to look like this:
X.E(
X#include <stdio.h>
X.E)
X.E(
Xstatic void
Xusage()
X{
X        fprintf(stderr, "usage: example [ <infile> [ <outfile> ]]\en");
X        exit(1);
X}
X.E)
X.E(
Xvoid
Xmain(argc, argv)
X        int     argc;
X        char    **argv;
X{
X        char    *in = 0;
X        char    *out = 0;
X        int     j;
X.E)
X.E(
X        for (j = 1; j < argc; ++j)
X        {
X                char *arg = argv[j];
X                if (arg[0] == '-')
X                        usage();
X                if (!in)
X                        in = arg;
X                else if (!out)
X                        out = arg;
X                else
X                        usage();
X        }
X.E)
X.E(
X        if (in && !freopen(in, "r", stdin))
X        {
X                perror(in);
X                exit(1);
X        }
X        if (out && !freopen(out, "w", stdout))
X        {
X                perror(out);
X                exit(1);
X        }
X.E)
X.E(
X        yyparse();
X        exit(0);
X}
X.E)
X.LP
XA new test is also required,
X.E(
Xjan% \f(CBaent\fP
Xaegis: project "example": change 2: file "test/00/t0002a.sh" new
X        test
Xjan%
X.E)
Xwhich is edited to look like this:
X.E(
X#!/bin/sh
X#
X# test command line arguments
X#
Xtmp=/tmp/$$
Xhere=`pwd`
Xif [ $? -ne 0 ]; then exit 1; fi
X.E)
X.E(
Xfail()
X{
X        echo FAILED 1>&2
X        cd $here
X        rm -rf $tmp
X        exit 1
X}
X.E)
X.E(
Xpass()
X{
X        cd $here
X        rm -rf $tmp
X        exit 0
X}
Xtrap "fail" 1 2 3 15
X.E)
X.E(
Xmkdir $tmp
Xif [ $? -ne 0 ]; then exit 1; fi
Xcd $tmp
Xif [ $? -ne 0 ]; then fail; fi
X.E)
X.E(
X#
X# with input like this
X#
Xcat > test.in << 'foobar'
X1
X(24 - 22)
X-(4 - 7)
X2 * 2
X10 / 2
X4 + 2
X10 - 3
Xfoobar
Xif [ $? -ne 0 ]; then fail; fi
X.E)
X.E(
X#
X# the output should look like this
X#
Xcat > test.ok << 'foobar'
X1
X2
X3
X4
X5
X6
X7
Xfoobar
Xif [ $? -ne 0 ]; then fail; fi
X.E)
X.E(
X#
X# run the calculator
X# and see if the results match
X#
X# (Use /dev/null for input in case input redirect fails;
X# don't want the test to hang!)
X#
X$here/example test.in test.out < /dev/null
Xif [ $? -ne 0 ]; then fail; fi
Xdiff test.ok test.out
Xif [ $? -ne 0 ]; then fail; fi
X$here/example test.in < /dev/null > test.out.2
Xif [ $? -ne 0 ]; then fail; fi
Xdiff test.ok test.out.2
Xif [ $? -ne 0 ]; then fail; fi
X.E)
X.E(
X#
X# make sure complains about rubbish
X# on the command line
X#
X$here/example -trash < test.in > test.out
Xif [ $? -ne 1 ]; then fail; fi
X.E)
X.E(
X#
X# this much worked
X#
Xpass
X.E)
X.LP
XNow it is time for Jan to build and test the change.
XThrough the magic of static documentation,
Xthis works first time,
Xand here is how it goes:
X.E(
Xjan% \f(CBaeb\fP
Xaegis: logging to "/u/pat/example.002/aegis.log"
Xaegis: project "example": change 2: development build started
Xaegis: cook -b /projects/example/baseline/Howto.cook
X        project=example change=2 version=1.0.C002 -nl
Xcook: cc -I. -I/projects/example/baseline -O -c main.c
Xcook: cc -o example main.o /projects/example/baseline/gram.o
X        /projects/example/baseline/lex.o -ll -ly
Xaegis: project "example": change 2: development build complete
Xjan% \f(CBaet\fP
Xaegis: logging to "/u/pat/example.002/aegis.log"
Xaegis: sh /u/jan/example.002/test/00/t0002a.sh
Xaegis: project "example": change 2: test "test/00/t0002a.sh"
X        passed
Xaegis: project "example": change 2: passed 1 test
Xjan%
X.E)
X.LP
XAll that remains if to difference the change and sign off.
X.E(
Xjan% \f(CBaed\fP
Xaegis: logging to "/u/pat/example.002/aegis.log"
Xaegis: set +e; diff -c /projects/example/main.c /u/jan/
X        example.002/main.c > /u/jan/example.002/main.c,D; test $?
X        -eq 0 -o $? -eq 1
Xaegis: project "example": change 2: difference complete
Xjan% \f(CBaedmore\fP
X\fI\&.\&.\&.examines the file.\&.\&.\fP
Xjan%
X.E)
XNote how the context difference shows exactly what has changed.
XAnd now the sign-off:
X.E(
Xjan% \f(CBaede\fP
Xaegis: project "example": change 2: no current 'aegis -Test
X        -BaseLine' registration
Xjan%
X.E)
X.LP
XNo,
Xit wasn't enough.
XTests must not only pass against a new change,
Xbut must fail against the project baseline.
XThis is to establish,
Xin the case of bug fixes,
Xthat the bug has been isolated
X.I and
Xfixed.
XNew functionality will usually fail against the baseline,
Xbecause the baseline can't do it
X(if it could, you wouldn't be adding it!).
XSo,
XJan needs to use a variant of the
X.I aet
Xcommand.
X.E(
Xjan% \f(CBaet -bl\fP
Xaegis: sh /u/jan/example.002/test/00/t0002a.sh
Xusage: example
XFAILED
Xaegis: project "example": change 2: test "test/00/t0002a.sh" on
X        baseline failed (as it should)
Xaegis: project "example": change 2: passed 1 test
Xjan%
X.E)
XRunning the regression tests is also a good idea
X.E(
Xjan% \f(CBaet -reg\fP
Xaegis: logging to "/u/pat/example.002/aegis.log"
Xaegis: sh /projects/example/baseline/test/00/t0001a.sh
Xaegis: project "example": change 2: test "test/00/t0001a.sh"
X        passed
Xaegis: project "example": change 2: passed 1 test
Xjan%
X.E)
X.LP
XNow aegis will be satisfied
X.E(
Xjan% \f(CBaede\fP
Xaegis: sh /usr/local/lib/aegis/de.sh example 2 jan
Xaegis: project "example": change 2: development completed
Xjan%
X.E)
X.LP
XLike Pat in the change before,
XJan will receive email that this change passed review,
Xand later that it passed integration.
X.nh 3 "The Third and Fourth Changes"
X.LP
XThis section will show two people performing two changes,
Xone each.
XThe twist is that they have a file in common.
X.LP
XFirst Sam looks for a change to work on and starts,
Xlike this:
X.E(
Xsam% \f(CBaedb -l\fP
XProject "example"
XList of Changes
X 
XChange  State           Description
X------- -------         -------------
X   3    awaiting_       add powers
X        development
X   4    awaiting_       add variables
X        development
Xsam% \f(CBaedb 3\fP
Xaegis: project "example": change 3: development directory "/u/
X        sam/example.003"
Xaegis: project "example": change 3: user "sam" has begun
X        development
Xsam% \f(CBaecd\fP
Xaegis: project "example": change 3: /u/sam/example.003
Xsam%
X.E)
X.LP
XA little sniffing around reveals that only the
X.I gram.y
Xgrammar file needs to be altered,
Xso it is copied into the change.
X.E(
Xsam% \f(CBaecp gram.y\fP
Xaegis: project "example": change 3: file "gram.y" copied
Xsam%
X.E)
X.LP
XThe grammar file is changed to look like this:
X.E(
X%token DOUBLE
X%token NAME
X%union
X{
X        double  lv_double;
X        int     lv_int;
X};
X.E)
X.E(
X%type <lv_double> DOUBLE expr
X%type <lv_int> NAME
X%left '+' '-'
X%left '*' '/'
X%right '^'
X%right UNARY
X.E)
X.E(
X%%
Xexample
X        : /* empty */
X        | example command '\n'
X                { yyerrflag = 0; fflush(stderr); fflush(stdout); }
X        ;
X.E)
X.E(
Xcommand
X        : expr
X                { printf("%g\n", $1); }
X        | error
X        ;
X.E)
X.E(
Xexpr
X        : DOUBLE
X        | '(' expr ')'
X                { $$ = $2; }
X        | '-' expr
X                %prec UNARY
X                { $$ = -$2; }
X        | expr '^' expr
X                { $$ = pow($1, $3); }
X        | expr '*' expr
X                { $$ = $1 * $3; }
X        | expr '/' expr
X                { $$ = $1 / $3; }
X        | expr '+' expr
X                { $$ = $1 + $3; }
X        | expr '-' expr
X                { $$ = $1 - $3; }
X        ;
X.E)
X.LP
XThe changes are very small.
XSam checks to make sure using the difference command:
X.E(
Xsam% \f(CBaed\fP
Xaegis: logging to "/u/sam/example.003/aegis.log"
Xaegis: set +e; diff -c /projects/example/baseline/gram.y /u/sam/
X        example.003/gram.y > /u/sam/example.003/gram.y,D; test $?
X        -eq 0 -o $? -eq 1
Xaegis: project "example": change 3: difference complete
Xsam% \f(CBaedmore\fP
X\fI\&.\&.\&.examines the file.\&.\&.\fP
Xsam%
X.E)
XThe difference file looks like this
X.E(
X*** /projects/example/baseline/gram.y
X--- /u/sam/example.003/gram.y
X***************
X*** 1,5 ****
X--- 1,6 ----
X  %{
X  #include <stdio.h>
X+ #include <math.h>
X  %}
X  %token DOUBLE
X  %token NAME
X.E)
X.E(
X***************
X*** 13,18 ****
X--- 14,20 ----
X  %type <lv_int> NAME
X  %left '+' '-'
X  %left '*' '/'
X+ %right '^'
X  %right UNARY
X  %%
X  example
X.E)
X.E(
X***************
X*** 32,37 ****
X--- 34,41 ----
X        | '-' expr
X                %prec UNARY
X                { $$ = -$2; }
X+       | expr '^' expr
X+               { $$ = pow($1, $3); }
X        | expr '*' expr
X                { $$ = $1 * $3; }
X        | expr '/' expr
X.E)
X.LP
XThese are the differences Sam expected to see.
X.LP
XAt this point Sam creates a test.
XAll good software developers create the tests first,
Xdon't they?
X.E(
Xsam% \f(CBaent\fP
Xaegis: project "example": change 3: file "test/00/t0003a.sh" new
X        test
Xsam%
X.E)
X.LP
XThe test is created empty,
Xand Sam edit it to look like this:
X.E(
X:
Xhere=`pwd`
Xif test $? -ne 0 ; then exit 1; fi
Xtmp=/tmp/$$
Xmkdir $tmp
Xif test $? -ne 0 ; then exit 1; fi
Xcd $tmp
Xif test $? -ne 0 ; then exit 1; fi
X.E)
X.E(
Xfail()
X{
X        echo FAILED 1>&2
X        cd $here
X        chmod u+w `find $tmp -type d -print`
X        rm -rf $tmp
X        exit 1
X}
X.E)
X.E(
Xpass()
X{
X        cd $here
X        chmod u+w `find $tmp -type d -print`
X        rm -rf $tmp
X        exit 0
X}
Xtrap "fail" 1 2 3 15
X.E)
X.E(
Xcat > test.in << 'end'
X5.3 ^ 0
X4 ^ 0.5
X27 ^ (1/3)
Xend
Xif test $? -ne 0 ; then fail; fi
X.E)
X.E(
Xcat > test.ok << 'end'
X1
X2
X3
Xend
Xif test $? -ne 0 ; then fail; fi
X.E)
X.E(
X$here/example test.in < /dev/null > test.out 2>&1
Xif test $? -ne 0 ; then fail; fi
X.E)
X.E(
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X.E)
X.E(
X$here/example test.in test.out.2 < /dev/null
Xif test $? -ne 0 ; then fail; fi
X.E)
X.E(
Xdiff test.ok test.out.2
Xif test $? -ne 0 ; then fail; fi
X.E)
X.E(
X# it probably worked
Xpass
X.E)
X.LP
XEverything is ready.
XNow the change cane be built and tested,
Xjust like the earlier changes.
X.E(
Xsam% \f(CBaeb\fP
Xaegis: logging to "/u/sam/example.003/aegis.log"
Xaegis: project "example": change 3: development build started
Xaegis: cook -b /projects/example/baseline/Howto.cook
X        project=example change=3 version=1.0.C003 -nl
Xcook: yacc -d gram.y
Xcook: mv y.tab.c gram.c
Xcook: mv y.tab.h gram.h
Xcook: cc -I. -I/projects/example/baseline -O -c gram.c
Xcook: cc -I. -I/projects/example/baseline -O -c /projects/
X        example/baseline/lex.c
Xcook: cc -o example gram.o lex.o /projects/example/baseline/
X        main.o -ll -ly -lm
Xaegis: project "example": change 3: development build complete
Xsam%
X.E)
X.LP
XNotice how the yacc run produces a 
X.I gram.h
Xwhich logically invalidates the
X.I lex.o
Xin the baseline,
Xand so the
X.I lex.c
Xfile in the baseline is recompiled,
Xusing the
X.I gram.h
Xinclude file from the development directory,
Xleaving a new
X.I lex.o
Xin the development directory.
XThis is the reason for the use of
X.E(
X#include <\f(CIfilename\fP>
X.E)
Xdirectives, rather then the double quote form.
X.PP
XNow the change is tested.
X.E(
Xsam% \f(CBaet\fP
Xaegis: logging to "/u/sam/example.003/aegis.log"
Xaegis: sh /u/sam/example.003/test/00/t0003a.sh
Xaegis: project "example": change 3: test "test/00/t0003a.sh"
X        passed
Xaegis: project "example": change 3: passed 1 test
Xsam%
X.E)
X.LP
XThe change must also be tested against the baseline, and fail.
XSam knows this, and does it here.
X.E(
Xsam% \f(CBaet -bl\fP
Xaegis: logging to "/u/sam/example.003/aegis.log"
Xaegis: sh /u/sam/example.003/test/00/t0003a.sh
X1,3c1,6
X< 1
X< 2
X< 3
X---
X> syntax error
X> 5.3
X> syntax error
X> 4
X> syntax error
X> 27
XFAILED
Xaegis: project "example": change 3: test "test/00/t0003a.sh" on
X        baseline failed (as it should)
Xaegis: project "example": change 3: passed 1 test
Xsam%
X.E)
X.LP
XRunning the regression tests
Xis also a good idea.
X.E(
Xsam% \f(CBaet -reg\fP
Xaegis: logging to "/u/sam/example.003/aegis.log"
Xaegis: sh /projects/example/baseline/test/00/t0001a.sh
Xaegis: project "example": change 3: test "test/00/t0001a.sh"
X        passed
Xaegis: sh /projects/example/baseline/test/00/t0002a.sh
Xaegis: project "example": change 3: test "test/00/t0002a.sh"
X        passed
Xaegis: project "example": change 3: passed 2 tests
Xsam%
X.E)
X.LP
XA this point Sam has just enough time to get to the lunchtime aerobics class in the staff common room.
X.LP
XEarlier the same day,
XPat arrived for work a little after Sam,
Xand also looked for a change to work on.
X.E(
Xpat% \f(CBaedb -l\fP
XProject "example"
XList of Changes
X 
XChange  State           Description
X------- -------         -------------
X   4    awaiting_       add variables
X        development
Xpat%
X.E)
X.LP
XWith such a wide choice,
XPat selected change 4.
X.E(
Xpat% \f(CBaedb 4\fP
Xaegis: project "example": change 4: development directory "/u/
X        pat/example.004"
Xaegis: project "example": change 4: user "pat" has begun
X        development
Xpat% \f(CBaecd\fP
Xaegis: project "example": change 4: /u/pat/example.004
Xpat%
X.E)
X.LP
XTo get more information about the change,
XPat then uses the "change details" listing:
X.E(
Xpat% \f(CBael cd\fP
XProject "example", Change 4
XChange Details
X.E)
X.E(
XNAME
X        Project "example", Change 4.
X.E)
X.E(
XSUMMARY
X        add variables
X.E)
X.E(
XDESCRIPTION
X        Enhance the grammar to allow variables. Only single
X        letter variable names are required.
X.E)
X.E(
XCAUSE
X        This change was caused by internal_enhancement.
X.E)
X.E(
XSTATE
X        This change is in 'being_developed' state.
X.E)
X.E(
XFILES
X        This change has no files.
X.E)
X.E(
XHISTORY
X        What            When            Who     Comment
X        ------          ------          -----   ---------
X        new_change      Mon Dec 14      alex
X                        13:08:52 1992
X        develop_begin   Tue Dec 15      pat
X                        13:38:26 1992
Xpat%
X.E)
X.LP
XTo add the variables the grammar needs to be extended to understand them,
Xand a new file for remembering and recalling the values of the
Xvariables needs to be added.
X.E(
Xpat% \f(CBaecp gram.y\fP
Xaegis: project "example": change 4: file "gram.y" copied
Xpat% \f(CBaenf var.c\fP
Xaegis: project "example": change 4: file "var.c" added
Xpat%
X.E)
X.LP
XNotice how aegis raises no objection to both Jan and Pat
Xhaving a copy of the
X.I gram.y
Xfile.
XResolving this contention is the subject of this section.
X.LP
XPat now edits the grammar file.
X.E(
Xpat% \f(CBvi gram.y\fP
X\fI\&.\&.\&.edit the file.\&.\&.\fP
Xpat% \f(CBaed\fP
Xaegis: logging to "/u/pat/example.004/aegis.log"
Xaegis: set +e; diff -c /projects/example/baseline/gram.y /u/pat/
X        example.004/gram.y > /u/pat/example.004/gram.y,D; test $?
X        -eq 0 -o $? -eq 1
Xaegis: project "example": change 4: difference complete
Xpat%
X.E)
X.LP
XThe difference file looks like this
X.E(
X\&...
X.E)
X.LP
XThe new
X.I var.c
Xfile was created empty by aegis,
Xand Pat edits it to look like this:
X.E(
Xstatic double memory[26];
X.E)
X.E(
Xvoid
Xassign(name, value)
X        int     name;
X        double  value;
X{
X        memory[name] = value;
X}
X.E)
X.E(
Xdouble
Xrecall(name)
X        int     name;
X{
X        return memory[name];
X}
X.E)
X.LP
XLittle remains except to build the change.
X.E(
Xpat% \f(CBaeb\fP
Xaegis: logging to "/u/pat/example.004/aegis.log"
Xaegis: cook -b /tmp/8508/example.proj/baseline/Howto.cook
X        project=example change=4 version=1.0.C004 -nl
Xcook: yacc -d gram.y
Xcook: mv y.tab.c gram.c
Xcook: mv y.tab.h gram.h
Xcook: cc -I. -I/projects/example/baseline -O -c gram.c
Xcook: cc -I. -I/projects/example/baseline -O -c /projects/
X        example/baseline/lex.c
Xcook: cc -I. -I/projects/example/baseline -O -c var.c
Xcook: cc -o example gram.o lex.o /projects/example/baseline/
X        main.o var.o -ll -ly -lm
Xaegis: project "example": change 4: development build complete
Xpat%
X.E)
X.LP
XA new test for the new functionality is required.
X.E(
X:
Xhere=`pwd`
Xif test $? -ne 0 ; then exit 1; fi
Xtmp=/tmp/$$
Xmkdir $tmp
Xif test $? -ne 0 ; then exit 1; fi
Xcd $tmp
Xif test $? -ne 0 ; then exit 1; fi
X.E)
X.E(
Xfail()
X{
X        echo FAILED 1>&2
X        cd $here
X        chmod u+w `find $tmp -type d -print`
X        rm -rf $tmp
X        exit 1
X}
Xpass()
X{
X        cd $here
X        chmod u+w `find $tmp -type d -print`
X        rm -rf $tmp
X        exit 0
X}
Xtrap "fail" 1 2 3 15
X.E)
X.E(
Xcat > test.in << 'end'
Xa = 1
Xa + 1
Xc = a * 40 + 5
Xc / (a + 4)
Xend
Xif test $? -ne 0 ; then fail; fi
X.E)
X.E(
Xcat > test.ok << 'end'
X2
X9
Xend
Xif test $? -ne 0 ; then fail; fi
X.E)
X.E(
X$here/example test.in < /dev/null > test.out 2>&1
Xif test $? -ne 0 ; then fail; fi
X.E)
X.E(
Xdiff test.ok test.out
Xif test $? -ne 0 ; then fail; fi
X.E)
X.E(
X$here/example test.in test.out.2 < /dev/null
Xif test $? -ne 0 ; then fail; fi
X.E)
X.E(
Xdiff test.ok test.out.2
Xif test $? -ne 0 ; then fail; fi
X.E)
X.E(
X# it probably worked
Xpass
X.E)
X.LP
XThe new files are then differenced:
X.E(
Xpat% \f(CBaed\fP
Xaegis: logging to "/u/pat/example.004/aegis.log"
Xaegis: set +e; diff -c /projects/example/baseline/gram.y /u/pat/
X        example.004/gram.y > /u/pat/example.004/gram.y,D; test $?
X        -eq 0 -o $? -eq 1
Xaegis: set +e; diff -c /dev/null /u/pat/example.004/test/00/
X        t0004a.sh > /u/pat/example.004/test/00/t0004a.sh,D; test
X        $? -eq 0 -o $? -eq 1
Xaegis: set +e; diff -c /dev/null /u/pat/example.004/var.c > /u/
X        pat/example.004/var.c,D; test $? -eq 0 -o $? -eq 1
Xaegis: project "example": change 4: difference complete
Xpat%
X.E)
X.LP
XNotice how the difference for the
X.I gram.y
Xfile is still current,
Xand so is not run again.
X.LP
XThe change is tested.
X.E(
Xpat% \f(CBaet\fP
Xaegis: logging to "/u/pat/example.004/aegis.log"
Xaegis: sh /u/pat/example.004/test/00/t0001a.sh
Xaegis: project "example": change 4: test "test/00/t0004a.sh"
X        passed
Xaegis: project "example": change 4: passed 2 tests
Xpat%
X.E)
X.LP
XThe change is tested against the baseline.
X.E(
Xpat% \f(CBaet\fP
Xaegis: logging to "/u/pat/example.004/aegis.log"
Xaegis: sh /u/pat/example.004/test/00/t0001a.sh
X1,2c1,4
X< 2
X< 9
X---
X> syntax error
X> syntax error
X> syntax error
X> syntax error
XFAILED
Xaegis: project "example": change 4: test "test/00/t0004a.sh" on
X        baseline failed (as it should)
Xpat%
X.E)
X.LP
XAnd the regression tests
X.E(
Xpat% \f(CBaet -reg\fP
Xaegis: logging to "/u/pat/example.004/aegis.log"
Xaegis: sh /projects/example/baseline/test/00/t0001a.sh
Xaegis: project "example": change 4: test "test/00/t0001a.sh"
X        passed
Xaegis: sh /projects/example/baseline/test/00/t0002a.sh
Xaegis: project "example": change 4: test "test/00/t0002a.sh"
X        passed
Xaegis: project "example": change 4: passed 2 tests
Xpat%
X.E)
X.LP
XNote how test 3 has not been run,
Xin any form of testing.
XThis is because test 3 is part of another change,
Xand is not yet integrated with the baseline.
X.LP
XAll is finished for this change,
X.E(
Xpat% \f(CBaede\fP
Xaegis: sh /usr/local/lib/aegis/de.sh example 4 pat
Xaegis: project "example": change 4: development completed
Xpat%
X.E)
X.LP
XAnxious to get this change into the baseline,
XPat now wanders down the hall in search of a reviewer,
Xbut more of that in the next section.
X.LP
XSome time later,
XJan returns from aerobics feeling much improved.
XAll that is required for change 3 is
Xto do develop end, or is it?
X.E(
Xjan% \f(CBaede\fP
Xaegis: project "example": change 3: file "gram.y" in baseline
X        has changed since last 'aegis -DIFFerence' command
Xjan%
X.E)
X.LP
XA little sleuthing on Jan's part with the aegis list command
Xwill reveal how this came about.
XThe way to resolve this problem is with the difference command.
X.E(
Xjan% \f(CBaed\fP
Xaegis: logging to "/u/pat/example.003/aegis.log"
Xaegis: co -u'1.1' -p /projects/example/history/gram.y,v > /tmp/
X        aegis.14594
X/projects/example/history/gram.y,v  -->  stdout revision 1.1 (unlocked)
Xaegis: (diff3 -e /projects/example/baseline/gram.y /tmp/
X        aegis.14594 /u/jan/example.003/gram.y | sed -e '/^w$/d'
X        -e '/^q$/d'; \techo '1,$p' ) | ed - /projects/example/
X        baseline/gram.y > /u/jan/example.003/gram.y,D
Xaegis: project "example": change 3: difference complete
Xaegis: project "example": change 3: file "gram.y" was out of
X        date, see "gram.y,D" for details
Xaegis: new 'aegis -Build' required
Xjan%
X.E)
X.LP
XThis was caused by the conflict between change 4,
Xwhich is now integrated,
Xand change 3;
Xboth of which are editing the
X.I gram.y
Xfile.
XJan examines the
X.I gram.y,D
Xfile,
Xand discovers that it contains an accurate merge of
Xthe edit done by change 4 and the edits for this change.
XThe difference file looks like this:
X.E(
X%{
X#include <stdio.h>
X#include <math.h>
X%}
X%token DOUBLE
X%token NAME
X%union
X{
X        double  lv_double;
X        int     lv_int;
X};
X.E)
X.E(
X%type <lv_double> DOUBLE expr
X%type <lv_int> NAME
X%left '+' '-'
X%left '*' '/'
X%right '^'
X%right UNARY
X.E)
X.E(
X%%
Xexample
X        : /* empty */
X        | example command '\en'
X                { yyerrflag = 0; fflush(stderr); fflush(stdout); }
X        ;
X.E)
X.E(
Xcommand
X        : expr
X                { printf("%g\n", $1); }
X        | NAME '=' expr
X                { assign($1, $3); }
X        | error
X        ;
X.E)
X.E(
Xexpr
X        : DOUBLE
X        | NAME
X                { extern double recall(); $$ = recall($1); }
X        | '(' expr ')'
X                { $$ = $2; }
X        | '-' expr
X                %prec UNARY
X                { $$ = -$2; }
X        | expr '^' expr
X                { $$ = pow($1, $3); }
X        | expr '*' expr
X                { $$ = $1 * $3; }
X        | expr '/' expr
X                { $$ = $1 / $3; }
X        | expr '+' expr
X                { $$ = $1 + $3; }
X        | expr '-' expr
X                { $$ = $1 - $3; }
X        ;
X.E)
XThis is because most such conflicts are actually working
Xon logically separate portions of the file.
XTwo different areas of the grammar in this case.
XIn practice,
Xthere is rarely a real conflict,
Xand it is usually small enough to detect fairly quickly.
XNotice that aegis did not automatically put the merge in
Xplace of your edited file,
Xfor just this reason.
X.LP
XJan simply copies the difference file on top of the
Xoriginal, and rebuilds:
X.E(
Xjan% \f(CBmv gram.y,D gram.y\fP
Xjan% \f(CBaeb\fP
Xaegis: logging to "/u/jan/example.003/aegis.log"
Xaegis: project "example": change 3: development build started
Xaegis: cook -b /tmp/13906/example.proj/baseline/Howto.cook
X        project=example change=3 version=1.0.C003 -nl
Xcook: rm gram.c
Xcook: rm gram.h
Xcook: yacc -d gram.y
Xcook: mv y.tab.c gram.c
Xcook: mv y.tab.h gram.h
Xcook: rm gram.o
Xcook: cc -I. -I/projects/example/baseline -O -c gram.c
Xcook: rm lex.o
Xcook: cc -I. -I/projects/example/baseline -O -c /projects/
X        example/baseline/lex.c
Xcook: rm example
Xcook: cc -o example gram.o lex.o /projects/example/baseline/
X        main.o /projects/example/baseline/var.o -ll -ly -lm
Xaegis: project "example": change 3: development build complete
Xjan%
X.E)
X.LP
XNotice how the list of object files linked has also adapted to the
Xaddition of another file in the baseline,
Xwithout any extra work by Jan.
X.LP
XAll that remains is to test the change again.
X.E(
Xjan% \f(CBaet\fP
Xaegis: /bin/sh /tmp/13906/example.chan.3/test/00/t0003a.sh
Xaegis: project "example": change 3: test "test/00/t0003a.sh"
X        passed
Xaegis: project "example": change 3: passed 1 test
Xjan%
X.E)
XAnd test against the baseline,
X.E(
Xjan% \f(CBaet -bl\fP
Xaegis: /bin/sh /tmp/13906/example.chan.3/test/00/t0003a.sh
X1,3c1,6
X< 1
X< 2
X< 3
X---
X> syntax error
X> 5.3
X> syntax error
X> 4
X> syntax error
X> 27
XFAILED
Xaegis: project "example": change 3: test "test/00/t0003a.sh" on
X        baseline failed (as it should)
Xaegis: project "example": change 3: passed 1 test
Xjan%
X.E)
X.LP
XPerform the regression tests, too.
XThis is important for a merged change,
Xto make sure you didn't break the functionality
Xyou merged with.
X.E(
Xjan% \f(CBaet -reg\fP
Xaegis: logging to "/u/jan/example.003/aegis.log"
Xaegis: /bin/sh /projects/example/baseline/test/00/
X        t0001a.sh
Xaegis: project "example": change 3: test "test/00/t0001a.sh"
X        passed
Xaegis: /bin/sh /projects/example/baseline/test/00/
X        t0002a.sh
Xaegis: project "example": change 3: test "test/00/t0002a.sh"
X        passed
Xaegis: /bin/sh /projects/example/baseline/test/00/
X        t0004a.sh
Xaegis: project "example": change 3: test "test/00/t0004a.sh"
X        passed
Xaegis: project "example": change 3: passed 3 tests
Xjan%
X.E)
XAll done, or are we?
X.E(
Xjan% \f(CBaede\fP
Xaegis: project "example": change 3: no current 'aegis -Diff'
X        registration
Xjan%
X.E)
XThe difference we did earlier,
Xwhich revealed that we were out of date,
Xdoes not show the differences since the two changes were
Xmerged, and possibly further edited.
X.E(
Xjan% \f(CBaed\fP
Xaegis: logging to "/u/jan/example.003/aegis.log"
Xaegis: set +e; diff /projects/example/baseline/gram.y /u/pat/
X        example.003/gram.y > /u/pat/example.003/gram.y,D; test $? -le 1
Xaegis: project "example": change 3: difference complete
Xjan%
X.E)
XThis time everything will run smoothly, 
X.E(
Xjan% \f(CBaede\fP
Xaegis: project "example": change 3: development completed
Xjan%
X.E)
XSome time soon
XJan will receive email that this change passed review,
Xand later that it passed integration.
X.LP
XWithin the scope of a limited example,
Xyou have seen most of what aegis can do.
XTo get a true feeling for the program
Xyou need to try it in a similarly simple case.
XYou could even try doing this example manually.
X.bp
X.nh 3 "Developer Command Summary"
X.LP
XOnly a few of the aegis commands available to developers
Xhave been used in the example.
XThe following table (very tersely) describes the aegis commands most
Xuseful to developers.
X.TS
Xcenter,tab(;);
Xl l.
XCommand;Description
X_
Xaeb;Build
Xaeca;edit Change Attributes
Xaecd;Change Directory
Xaecp;Copy File
Xaecpu;Copy File Undo
Xaed;Difference
Xaedb;Develop Begin
Xaedbu;Develop Begin Undo
Xaede;Develop End
Xaedeu;Develop End Undo
Xael;List Stuff
Xaenf;New File
Xaenfu;New File Undo
Xaent;New Test
Xaentu;New Test Undo
Xaerm;Remove File
Xaermu;Remove File Undo
Xaet;Test
X.TE
X.LP
XYou will want to read the manual entries for all of these commands.
XNote that all aegis commands have a
X.I \-Help
Xoption,
Xwhich will give a result very similar to the
Xcorresponding
X.I man (1)
Xoutput.
XMost aegis commands also have a
X.I \-List
Xoption,
Xwhich usually lists interesting context sensitive information.
END_OF_FILE
if test 44300 -ne `wc -c <'doc/c2.1.so'`; then
    echo shar: \"'doc/c2.1.so'\" unpacked with wrong size!
fi
# end of 'doc/c2.1.so'
fi
echo shar: End of archive 15 \(of 19\).
cp /dev/null ark15isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 19 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
