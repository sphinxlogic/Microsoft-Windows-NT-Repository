Newsgroups: comp.sources.unix
From: pmiller@bmr.gov.au (Peter Miller)
Subject: v27i047: aegis - project change supervisor (V2.1), Part12/19
References: <1.748951883.12788@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: pmiller@bmr.gov.au (Peter Miller)
Posting-Number: Volume 27, Issue 47
Archive-Name: aegis-2.1/part12

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 12 (of 19)."
# Contents:  Manifest aegis/aenrls.c aegis/aet.c aux/BUILDING.man
#   common/str.c test/00/t0011a.sh
# Wrapped by vixie@gw.home.vix.com on Sat Sep 25 03:00:47 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Manifest' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Manifest'\"
else
echo shar: Extracting \"'Manifest'\" \(21359 characters\)
sed "s/^X//" >'Manifest' <<'END_OF_FILE'
X
X
XREADME	Blurb about aegis
XBUILDING	Instructions how to build, test and install aegis
XCHANGES	Change history of this release of aegis
XLICENSE	GNU General Public License
XMANIFEST	This file
XMakefile	Instructions to make(1) how to build and test aegis
Xaegis/aeb.c	 functions to perform development and integration builds
Xaegis/aeb.h	 interface definition for aegis/aeb.c
Xaegis/aeca.c	 functions to list and modify change attributes
Xaegis/aeca.h	 interface definition for aegis/aeca.c
Xaegis/aecd.c	 functions to change directory or determine paths
Xaegis/aecd.h	 interface definition for aegis/aecd.c
Xaegis/aecp.c	 copy files into a change, and undo
Xaegis/aecp.h	 interface definition for aegis/aecp.c
Xaegis/aecpu.c	 copy files into a change, and undo
Xaegis/aecpu.h	 interface definition for aegis/aecpu.c
Xaegis/aed.c	 difference a change
Xaegis/aed.h	 interface definition for aegis/diff.c
Xaegis/aedb.c	 functions to implement develop begin
Xaegis/aedb.h	 interface definition for aegis/aedb.c
Xaegis/aedbu.c	 functions to implement develop begin undo
Xaegis/aedbu.h	 interface definition for aegis/aedbu.c
Xaegis/aede.c	 functions to implement develop end
Xaegis/aede.h	 interface definition for aegis/aede.c
Xaegis/aedeu.c	 functions to implement develop end undo
Xaegis/aedeu.h	 interface definition for aedeu.c
Xaegis/aeib.c	 functions for implementing integrate begin
Xaegis/aeib.h	 interface definition for aegis/aeib.c
Xaegis/aeibu.c	 functions for implementing integrate begin undo
Xaegis/aeibu.h	 interface definition for aeibu.c
Xaegis/aeif.c	 functions for implementing integrate fail
Xaegis/aeif.h	 interface definition for aegis/aeif.c
Xaegis/aeip.c	 functions for implementing integrate pass
Xaegis/aeip.h	 interface definition for aegis/aeip.c
Xaegis/ael.c	 list interesting things about changes and projects
Xaegis/ael.h	 interface definition for aegis/ael.c
Xaegis/aemv.c	 functions to manipulate mvs
Xaegis/aemv.h	 interface definition for aegis/aemv.c
Xaegis/aena.c	 functions to implement new administrator
Xaegis/aena.h	 interface definition for aegis/aena.c
Xaegis/aenc.c	 functions to implement new change
Xaegis/aenc.h	 interface definition for aegis/aenc.c
Xaegis/aencu.c	 functions to implement new change undo
Xaegis/aencu.h	 interface definition for aegis/aencu.c
Xaegis/aend.c	 functions to implement new developer
Xaegis/aend.h	 interface definition for aegis/aend.c
Xaegis/aenf.c	 functions to add or remove a new file to a change
Xaegis/aenf.h	 interface definition for aegis/aenf.c
Xaegis/aenfu.c	 functions to add or remove a new file to a change
Xaegis/aenfu.h	 interface definition for aegis/aenfu.c
Xaegis/aeni.c	 functions to implement new integrator
Xaegis/aeni.h	 interface definition for aegis/aeni.c
Xaegis/aenpr.c	 functions to implement new project
Xaegis/aenpr.h	 interface definition for aegis/npr.c
Xaegis/aenrls.c	 functions to implement new release
Xaegis/aenrls.h	 interface definition for aegis/aenrls.c
Xaegis/aenrv.c	 functions to implement new reviewer
Xaegis/aenrv.h	 interface definition for aegis/aenrv.c
Xaegis/aent.c	 functions to implement new test
Xaegis/aent.h	 interface definition for aegis/aent.c
Xaegis/aentu.c	 functions to implement new test undo
Xaegis/aentu.h	 interface definition for aegis/aentu.c
Xaegis/aepa.c	 functions to list and modify project attributes
Xaegis/aepa.h	 interface definition for aegis/aepa.c
Xaegis/aera.c	 functions to implement remove administrator
Xaegis/aera.h	 interface definition for aegis/aera.c
Xaegis/aerd.c	 functions to implement remove developer
Xaegis/aerd.h	 interface definition for aegis/aerd.c
Xaegis/aerf.c	 functions to impliment review fail
Xaegis/aerf.h	 interface definition for aegis/aerf.c
Xaegis/aeri.c	 functions to implement remove administrator
Xaegis/aeri.h	 interface definition for aegis/aeri.c
Xaegis/aerm.c	 functions to implement remove file
Xaegis/aerm.h	 interface definition for aegis/aerm.c
Xaegis/aermpr.c	 functions to implement remove project
Xaegis/aermpr.h	 interface definition for aegis/aermpr.c
Xaegis/aermu.c	 functions to implement remove file undo
Xaegis/aermu.h	 interface definition for aegis/aermu.c
Xaegis/aerp.c	 functions to implement review pass
Xaegis/aerp.h	 interface definition for aegis/aerp.c
Xaegis/aerpu.c	 functions to implement review pass undo
Xaegis/aerpu.h	 interface definition for aegis/aerpu.c
Xaegis/aerrv.c	 functions to implement remove reviewer
Xaegis/aerrv.h	 interface definition for aegis/aerrv.c
Xaegis/aet.c	 functions to implement test
Xaegis/aet.h	 interface definition for aegis/aet.c
Xaegis/arglex2.h	 definitions of command line tokens
Xaegis/cattr.def	 change state file contents definition
Xaegis/change.c	 functions to manipulate change state data
Xaegis/change.h	 interface definition for aegis/change.c
Xaegis/col.c	 functions for columnized output
Xaegis/col.h	 interface definition for aegis/col.c
Xaegis/commit.c	 functions to store and enact file manipulations for commit
Xaegis/commit.h	 interface definition for aegis/commit.c
Xaegis/common.def	 enumerations common to many aegis file contents
Xaegis/cstate.def	 change state file contents definition
Xaegis/dir.c	 functions to walk directory trees
Xaegis/dir.h	 interface definition for aegis/dir.c
Xaegis/file.c	 functions for pushing files around
Xaegis/file.h	 interface definition for aegis/file.c
Xaegis/glue.c	 functions to perform systems calls in subprocesses
Xaegis/glue.h	 interface definition for aegis/glue.c
Xaegis/gonzo.c	 functions for manipulating global state data
Xaegis/gonzo.h	 interface definition for aegis/gonzo.c
Xaegis/gram.h	 interface definition for aegis/gram.y
Xaegis/gram.y	 grammar and functions to parse aegis' data files
Xaegis/gstate.def	 global state file contents definition
Xaegis/help.c	 functions to provide consistent treatment of -Help options
Xaegis/help.h	 interface definition for aegis/help.c
Xaegis/indent.c	 functions to automatically indent output
Xaegis/indent.h	 interface definition for aegis/indent.c
Xaegis/io.c	 functions to parse and write fundamental data types
Xaegis/io.h	 interface definition for aegis/io.c
Xaegis/lex.c	 functions to perform lexical analysis on aegis' data files
Xaegis/lex.h	 interface definition for aegis/lex.c
Xaegis/lock.c	 functions to lock aegis' data
Xaegis/lock.h	 interface definition for aegis/lock.c
Xaegis/log.c	 functions to open and close log files
Xaegis/log.h	 interface definition for aegis/log.c
Xaegis/main.c	 the operating system start-up point
Xaegis/os.c	 wrappers around operating system functions
Xaegis/os.h	 interface definition for aegis/os.c
Xaegis/pager.c	 functions to pipe output through paginator
Xaegis/pager.h	 interface definition for aegis/pager.c
Xaegis/parse.c	 functions to parse aegis' data files
Xaegis/parse.h	 interface definition for aegis/parse.c
Xaegis/pattr.def	 project attributes file contents definition
Xaegis/pconf.def	 project config file contents definition
Xaegis/project.c	 functions to manipulate project state data
Xaegis/project.h	 interface definition for aegis/project.h
Xaegis/pstate.def	 project state file contents definition
Xaegis/sub.c	 functions to perform command substitutions
Xaegis/sub.h	 interface definition for aegis/sub.c
Xaegis/type.c	 functions to manipulate types in aegis' data files
Xaegis/type.h	 interface definition for aegis/type.c
Xaegis/uconf.def	 user config file contents definition
Xaegis/undo.c	 functions to store and enact file operations on transation abort
Xaegis/undo.h	 interface definition for aegis/undo.c
Xaegis/user.c	 functions to manage information about users
Xaegis/user.h	 interface definition for aegis/user.c
Xaegis/ustate.def	 user state file contents definition
Xaegis/version.c	 give version information
Xaegis/version.h	 interface definition for aegis/version.c
Xaux/BUILDING.man	 source for BUILDING file
Xaux/CHANGES.1.0	
Xaux/CHANGES.1.1	
Xaux/CHANGES.1.2	
Xaux/CHANGES.1.3	
Xaux/CHANGES.1.4	
Xaux/CHANGES.2.0	
Xaux/CHANGES.sh	 shell script to create the CHANGES file
Xaux/Howto.cook	 instructions to cook(1), how to build project
Xaux/MANIFEST.sh	 shell script to generate the MANIFEST file
Xaux/Makefile.awk	 helper file for generating the Makefile file
Xaux/Makefile.sh	 shell script to generate the Mafile file
Xaux/README.man	 source for the README file
Xaux/new.1.4.so	 document describing features new to version 1.4
Xaux/new.2.0.so	 document describing some of the features new to version 2.0
Xaux/new.2.1.so	 document describing new.2.1.so
Xaux/new.so	Include redirection for release notes.
Xaux/patches.sh	 shell script to generate the patch file
Xcommon/ansi.c	 missing ANSI C library functions
Xcommon/arglex.c	 lexical analysis of command line arguments
Xcommon/arglex.h	 interface definition for common/arglex.c
Xcommon/error.c	 functions to report errors
Xcommon/error.h	 interface definition for common/error.c
Xcommon/main.h	 common definitions, including DEBUG define
Xcommon/mem.c	 functions to manipulate dynamic memory
Xcommon/mem.h	 interface definition for common/mem.c
Xcommon/option.c	 functions to manipulate command line options
Xcommon/option.h	 interface definition for common/option.c
Xcommon/patchlevel.h	The patch level of this distribution.
Xcommon/s-v-arg.h	 insulation from varargs.h versus stdarg.h incompatibilities
Xcommon/str.c	 string manipulation functions
Xcommon/str.h	 interface definition for common/str.c
Xcommon/trace.c	 functions for execution trace
Xcommon/trace.h	 interface definition for common/trace.c
Xcommon/word.c	 functions to manipulate lists of strings
Xcommon/word.h	 interface definition for common/word.c
Xconf/AIX-3.2	 aegis configuration for AIX 3.2 system
Xconf/ConvexOS-10	 aegis configuration for ConvexOS 10
Xconf/IRIX-4.0	 aegis configuration for IRIX 4.0 (Silicon Graphics)
Xconf/Linux-0.99	 aegis configuration for Linux 0.99
Xconf/SCO-2.4	 aegis configuration for SCO 2.4
Xconf/SunOS-4.1.1	 aegis configuration for SunOS 4.1.1
Xconf/SunOS-4.1.2	 aegis configuration for SunOS 4.1.2
Xconf/SunOS-4.1.3	 aegis configuration for SunOS 4.1.3
Xconf/SunOS-5.1	 aegis configuration for SunOS 5.1 (Solaris 2.1)
Xconf/SysV-4.0	 aegis configuration for generic SVR4 system
Xconf/ULTRIX-4.2	 aegis configuration for ULTRIX version 4.2
Xconf/apollo	 aegis configuration for apollo domain
Xconf/dcosx	 aegis configuration for Pyramid SMP DC/OSx
Xconf/dgux-5.4.1	 aegis configuration for dgux 5.4.1
Xconf/hpux-8.07	 aegis configuration for HP/UX 8.07
Xconfig	 instructions to aegis, per-project configuration
Xdoc/aegis.ms	 User Guide
Xdoc/c1.0.so	 User Guide, Introduction
Xdoc/c1.1.so	 User Guide, Introduction, What does aegis do?
Xdoc/c1.2.so	 User Guide, Introduction, Why use aegis?
Xdoc/c1.3.so	 User Guide, How Aegis Works, When (not) to use Aegis
Xdoc/c1.4.so	 User Guide, Introduction, How to use this manual
Xdoc/c2.0.so	 User Guide, The Change Development Cycle
Xdoc/c2.1.so	 User Guide, The Change Development Cycle, The Developer
Xdoc/c2.2.so	 User Guide, The Change Development Cycle, The Reviewer
Xdoc/c2.3.so	 User Guide, The Change Development Cycle, The Integrator
Xdoc/c2.4.so	 User Guide, The Change Development Cycle, The Administrator
Xdoc/c2.5.so	 User Guide, The Change Development Cycle, What to do Next
Xdoc/c3.0.so	 User Guide, The History Tool"
Xdoc/c3.1.so	 User Guide, The History Tool, Using SCCS
Xdoc/c3.2.so	 User Guide, The History Tool, Using RCS
Xdoc/c3.3.so	 User Guide, The History Tool, Using fhist
Xdoc/c4.0.so	 User Guide, The Dependency Maintenance Tool
Xdoc/c4.1.so	 User Guide, The Dependency Maintenance Tool, Requirements
Xdoc/c4.2.so	 User Guide, The Dependency Maintenance Tool, Cook
Xdoc/c4.3.so	 User Guide, The Dependency Maintenance Tool, Other Packages
Xdoc/c5.0.so	 User Guide, The Project Attributes
Xdoc/c6.0.so	 User Guide, Tips and Traps
Xdoc/c7.0.so	 User Guide, How Aegis Works
Xdoc/c7.1.so	 User Guide, How Aegis Works, The Model
Xdoc/c7.2.so	 User Guide, How Aegis Works, Philosophy
Xdoc/c7.4.so	 User Guide, How Aegis Works, Further Work
Xdoc/c7.5.so	 User Guide, How Aegis Works, Security
Xdoc/c8.0.so	 User Guide, The Difference Tools
Xdoc/c8.1.so	 User Guide, The Difference Tools, Interfacing
Xdoc/c8.2.so	 User Guide, The Difference Tools, Using diff and diff3
Xdoc/c8.3.so	 User Guide, The Difference Tools, Using fhist
Xdoc/cA.0.so	 User Guide, Appendix A: New Project Quick Reference
Xdoc/cB.0.so	 User Guide, Appendix B: Glossary
Xdoc/cC.0.so	 User Guide, Appendix C, Product Comparisons
Xdoc/version.so	The patch level of this distribution.
Xfmtgen/id.c	 symbol table manipulation
Xfmtgen/id.h	 interface definition for fmtgen/id.c
Xfmtgen/indent.c	 functions to automatically indent output
Xfmtgen/indent.h	 interface definition for fmtgen/indent.c
Xfmtgen/lex.c	 lexical analyzer
Xfmtgen/lex.h	 interface definition for fmtgen/lex.c
Xfmtgen/main.c	 operating system start-up point
Xfmtgen/parse.h	 interface definition for fmtgen/parse.y
Xfmtgen/parse.y	 grammar and functions to parse aegis file contents definitions
Xfmtgen/type.c	 functions to manipulate data types
Xfmtgen/type.h	 interface definition for fmtgen/type.c
Xfmtgen/type_enum.c	 enumerated types functions gereation
Xfmtgen/type_integ.c	 functions to manipulate integer type
Xfmtgen/type_list.c	 list types function generation
Xfmtgen/type_ref.c	 functions to manipulate reference types
Xfmtgen/type_strin.c	 functions to manipluate string type
Xfmtgen/type_struc.c	 struct types function generation
Xh/dirent.h	 minimal replacement for dirent.h
Xh/stdarg.h-min	 minimal stdarg.h substitute
Xh/stddef.h	 minimal stddef.h substitute
Xh/stdlib.h	 minimal stdlib.h substitute
Xh/unistd.h	 minimal substitute for unistd.h
Xh/utime.h	 minimal replacement for utime.h
Xlib/aegis.icon	
Xlib/aegis.mask	
Xlib/aegis.pgm	 portable graymap of aegis icon
Xlib/cshrc	 csh user config for aegis
Xlib/de.inews.sh	 command used to notify by usenet that a change is ready for review
Xlib/de.sh	 command used to notify by email that a change is ready for review
Xlib/deu.inews.sh	 command used to notify by usenet that a change has been withdrawn from review
Xlib/deu.sh	 command used to notify by email that a change has been withdrawn from review
Xlib/if.inews.sh	 command used to notify by usenet that a change failed integration
Xlib/if.sh	 command used to notify by email that a change failed integration
Xlib/ip.inews.sh	 command used to notify by usenet that a change has passed integration
Xlib/ip.sh	 command used to notify by email that a change has passed integration
Xlib/profile	 Bourne shell user config for aegis
Xlib/rf.inews.sh	 command used to notify by usenet that a change failed review
Xlib/rf.sh	 command used to notify by email that a change failed review
Xlib/rp.inews.sh	 command used to notify by usenet that a change has passed review
Xlib/rp.sh	 command used to notify by email that a change has passed review
Xlib/rpu.inews.sh	 command used to notify by usenet that a change review passed is rescinded
Xlib/rpu.sh	 command used to notify by email that a change review passed is rescinded
Xman1/aeb.1	 manual entry for 'aegis -Build' command
Xman1/aeca.1	 manual entry for 'aegis -Change_Attributes' command
Xman1/aecd.1	 manual entry for 'aegis -Change_Directory' command
Xman1/aecp.1	 manual entry for aegis -CoPy_file
Xman1/aecpu.1	 manual entry for 'aegis -CoPy_file_Undo' command
Xman1/aed.1	 manual entry for 'aegis -DIFFerence' command
Xman1/aedb.1	 manual entry for 'aegis -Develop_Begin' command
Xman1/aedbu.1	 manual entry for 'aegis -Develop_Begin_Undo' command
Xman1/aede.1	 manual entry for 'aegis -Develop_End' command
Xman1/aedeu.1	 manual entry for 'aegis -Develop_End_Undo' command
Xman1/aegis.1	 manual entry for aegis
Xman1/aeib.1	 manual entry for 'aegis -Integrate_Begin' command
Xman1/aeibu.1	 manual entry for 'aegis -Integrate_Begin_Undo' command
Xman1/aeif.1	 manual entry for 'aegis -Integrate_Fail' command
Xman1/aeip.1	 manual entry for 'aegis -Integrate_Pass' command
Xman1/ael.1	 manual entry for 'aegis -List' command
Xman1/aemv.1	 manual entry for aegis -MoVe_file
Xman1/aena.1	 manual entry for 'aegis -New_Administrator' command
Xman1/aenc.1	 manual entry for 'aegis -New_Change' command
Xman1/aencu.1	 manual entry for 'aegis -New_Change_Undo' command
Xman1/aend.1	 manual entry for 'aegis -New_Developer' command
Xman1/aenf.1	 manual entry for 'aegis -New_File' command
Xman1/aenfu.1	 manual entry for 'aegis -New_File_Undo' command
Xman1/aeni.1	 manual entry for 'aegis -New_Integrator' command
Xman1/aenpr.1	 manual entry for 'aegis -New_PRoject' command
Xman1/aenrls.1	 manual entry for 'aegis -New_ReLeaSe' command
Xman1/aenrv.1	 manual entry for 'aegis -New_ReViewer' command
Xman1/aent.1	 manual entry for 'aegis -New_Test' command
Xman1/aentu.1	 manual entry for 'aegis -New_Test_Undo' command
Xman1/aepa.1	 manual entry for 'aegis -Project_Attributes' command
Xman1/aera.1	 manual entry for 'aegis -Remove_Administrator' command
Xman1/aerd.1	 manual entry for 'aegis -Remove_Developer' command
Xman1/aerf.1	 manual entry for 'aegis -Review_FAIL' command
Xman1/aeri.1	 manual entry for the 'aegis -Remove_Integrator' command
Xman1/aerm.1	 manual entry for the 'aegis -ReMove_file' command
Xman1/aermpr.1	 manual entry for the 'aegis -ReMove_PRoject' command
Xman1/aermu.1	 manual entry for the 'aegis -ReMove_file_Undo' command
Xman1/aerp.1	 manual entry for the 'aegis -Review_PASS' command
Xman1/aerpu.1	 manual entry for the 'aegis -Review_Pass_Undo' command
Xman1/aerrv.1	 manual entry for the 'aegis -Remove ReViewer' command
Xman1/aet.1	 manual entry for the 'aegis -Test' command
Xman1/aev.1	 manual entry for the 'aegis -VERSion' command
Xman1/install.sh	 shell script to install section 1 manual pages
Xman1/o__rules.so	 description of option up/down case convention
Xman1/o_anticip.so	 description of -ANticipate command line option
Xman1/o_auto.so	 description of -AUTOmatic command line option
Xman1/o_baselin.so	 description of -BaseLine command line option
Xman1/o_bld_lk.so	 manual section describing the build lock
Xman1/o_change.so	 description of -Change command line option
Xman1/o_devdir.so	 description of -Development_Directory command line option
Xman1/o_dir.so	 description of -DIRectory command line option
Xman1/o_edit.so	 document describing -Edit option
Xman1/o_help.so	 description of -Help command line option
Xman1/o_indep.so	 description of -INDependent command line option
Xman1/o_keep.so	 description of -Keep command line option
Xman1/o_lib.so	 description of -LIBrary command line option
Xman1/o_list.so	 description of -List command line option
Xman1/o_major.so	 description of -MAJor command line option
Xman1/o_manual.so	 description of -MINor command line option
Xman1/o_min.so	 description of -MINImum command line option
Xman1/o_minor.so	 description of -MINOr command line option
Xman1/o_nolog.so	 description of -Not_Logging command line option
Xman1/o_overw.so	 description of -OverWriting command line option
Xman1/o_page.so	 description of -Page_Length and -Page_Width command line options
Xman1/o_project.so	 description of -Project command line option
Xman1/o_terse.so	 description of -TERse command line option
Xman1/o_unforma.so	 document describing -UNFormatted option
Xman1/o_verbose.so	 description of -Verbose command line option
Xman1/z_cr.so	 copyright and author parts of section 1 manual entries
Xman1/z_exit.so	 exit status part of section 1 manual entries
Xman1/z_intuit.so	 description of how file names are interpreted on command line
Xman1/z_name.so	 common setup for section 1 manual entries
Xman5/aecattr.5	 description of aegis change attribute file format
Xman5/aecattr.so	 description of aegis change attribute file format
Xman5/aecstate.5	 description of aegis change state file format
Xman5/aedir.5	 description of aegis project directory structure
Xman5/aegis.5	 description of aegis file format general structure
Xman5/aegstate.5	 description of aegis global state file format
Xman5/aepattr.5	 description of aegis project attribute file format
Xman5/aepattr.so	 description of aegis project attribute file format
Xman5/aepconf.5	 description of aegis project config file format
Xman5/aepstate.5	 description of aegis project state file format
Xman5/aesub.5	 manual page describing command substitutions
Xman5/aeuconf.5	 description of aegis user config file format
Xman5/aeustate.5	 description of aegis user state file format
Xman5/install.sh	 shell script to install section 5 manual entries
Xman5/z_cr.so	 copyright and author parts of section 5 manual entries
Xman5/z_name.so	 common setup for section 5 manual entries
Xscript/aegis.synpic	 synpic program to generate aegis icon
Xscript/xaegis.tcl	 wish script to give aegis a GUI interface
Xtest/00/t0001a.sh	 test -Help for each function
Xtest/00/t0002a.sh	 Test core functionality.
Xtest/00/t0003a.sh	 Test 'aegis -VERSion'
Xtest/00/t0004a.sh	 Test the 'aegis -DIFFerence' command.
Xtest/00/t0005a.sh	 Test the 'aegis -DevEnd' command.
Xtest/00/t0006a.sh	 Test 'aegis -DIFFerence' when the edit number is out-of-date.
Xtest/00/t0007a.sh	 test for correct behaviour around symbolic links
Xtest/00/t0008a.sh	 Test command substitutions
Xtest/00/t0009a.sh	 Test -New_ReLeaSe functionality.
Xtest/00/t0010a.sh	 Test -Review_Pass_Undo functionality.
Xtest/00/t0011a.sh	 Test documentation example.
Xtest/00/t0012a.sh	 Test the aermpr functionality
Xtest/00/t0013a.sh	 Test the -New_Change_Undo functionality
Xtest/00/t0014a.sh	 Test the -Develop_Begin_Undo functionality
Xtest/00/t0015a.sh	 Test the -Integrate_Begin_Undo functionality
Xtest/00/t0016a.sh	 Test the aemv functionality
Xtest/00/t0017a.sh	 Test 'aegis -DIFFerence -ANticipate' variant
Xtest/00/t0018a.sh	 Test the 'aegis -NewFile -Build' command.
END_OF_FILE
if test 21359 -ne `wc -c <'Manifest'`; then
    echo shar: \"'Manifest'\" unpacked with wrong size!
fi
# end of 'Manifest'
fi
if test -f 'aegis/aenrls.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aegis/aenrls.c'\"
else
echo shar: Extracting \"'aegis/aenrls.c'\" \(22801 characters\)
sed "s/^X//" >'aegis/aenrls.c' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to implement new release
X */
X
X#include <ctype.h>
X#include <stdio.h>
X#include <string.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X
X#include <ael.h>
X#include <aenrls.h>
X#include <arglex2.h>
X#include <change.h>
X#include <commit.h>
X#include <dir.h>
X#include <error.h>
X#include <file.h>
X#include <gonzo.h>
X#include <help.h>
X#include <lock.h>
X#include <log.h>
X#include <mem.h>
X#include <option.h>
X#include <os.h>
X#include <project.h>
X#include <sub.h>
X#include <trace.h>
X#include <undo.h>
X#include <user.h>
X
X#define GIVEN -1
X#define NOT_GIVEN -2
X
X
Xstatic void new_release_usage _((void));
X
Xstatic void
Xnew_release_usage()
X{
X	char	*progname;
X
X	progname = option_progname_get();
X	fprintf(stderr, "usage: %s -New_ReLeaSe <name> [ <option>... ]\n", progname);
X	fprintf(stderr, "       %s -New_ReLeaSe -List [ <option>... ]\n", progname);
X	fprintf(stderr, "       %s -New_ReLeaSe -Help\n", progname);
X	quit(1);
X}
X
X
Xstatic void new_release_help _((void));
X
Xstatic void
Xnew_release_help()
X{
X	static char *text[] =
X	{
X"NAME",
X"	%s -New_ReLeaSe - create a new project from an existing",
X"	project.",
X"",
X"SYNOPSIS",
X"	%s -New_ReLeaSe <project-name> [ <new-project-name> ][ <option>... ]",
X"	%s -New_ReLeaSe -List [ <option>... ]",
X"	%s -New_ReLeaSe -Help",
X"",
X"DESCRIPTION",
X"	The %s -New_ReLeaSe command is used to create a new",
X"	project from an existing project.",
X"",
X"	If no new-project-name is specified, it will be derived",
X"	from the project given as follows: any minor version dot",
X"	suffix will be removed from the name, then any major",
X"	version dot suffix will be removed from the name.  A major",
X"	version dot suffix will be appended, and then a minor",
X"	version dot suffix will be appended.  As an example,",
X"	\"foo.1.0\" would become \"foo.1.1\" assuming the default",
X"	minor version incriment, and \"foo\" would become \"foo.1.1\"",
X"	assiming the same minor version incriment.",
X"",
X"	The entire project baseline will be copied.  The project",
X"	state will be as if change 1 had already been integrated,",
X"	naming every file (in the old project) as a new file.  The",
X"	history files will reflect this.  No build will be",
X"	necessary; it is assumed that the old baseline was built",
X"	sucessfully.  Change numbers will commence at 2, as will",
X"	build numbers.  Test numbers will commence where the old",
X"	project left off (because all the earlier test numbers",
X"	were used by the old project).",
X"",
X"	The default is for the minor version number to be",
X"	incrimented.  If the major version number is incrimented",
X"	or set, the minor version number will be set to zero if it",
X"	is not explicitly given.",
X"",
X"	The pointer to the new project will be added to the first",
X"	element of the search path, or /usr/local/lib/%s if",
X"	none is set.  If this is inappropriate, use the",
X"	-LIBrary option to explicitly set the desired location.",
X"	See the -LIBrary option for more information.",
X"",
X"	The project directory, under which the project baseline",
X"	and history and state and change data are kept, will be",
X"	created at this time.  If the -DIRectory option is not",
X"	given, the project directory will be created in the",
X"	directory specified by the default_project_directory field",
X"	of the project user's aeuconf(5), or if not set in project",
X"	user's home directory; in either case with the same name",
X"	as the project.",
X"",
X"	All staff will be copied from the old project to the new",
X"	project without change, as will all of the project",
X"	attributes.",
X"",
X"OPTIONS",
X"	The following options are understood:",
X"",
X"	-DIRectory <path>",
X"		This option may be used to specify which directory",
X"		is to be used.  It is an error if the current user",
X"		does not have appropriate permissions to create",
X"		the directory path given.  This must be an",
X"		absolute path.",
X"",
X"		Caution: If you are using an automounter do not",
X"		use `pwd` to make an absolute path, it usually",
X"		gives the wrong answer.",
X"",
X"	-Help",
X"		This option may be used to obtain more information",
X"		about how to use the %s program.",
X"",
X"	-LIBrary <abspath>",
X"		This option may be used to specify a directory to",
X"		be searched for global state files and user state",
X"		files.  (See aegstate(5) and aeustate(5) for more",
X"		information.)  Several library options may be",
X"		present on the command line, and are search in the",
X"		order given.  Appended to this explicit search",
X"		path are the directories specified by the AEGIS",
X"		enviroment variable (colon separated), and",
X"		finally, /usr/local/lib/%s is always searched.",
X"		All paths specified, either on the command line or",
X"		in the AEGIS environment variable, must be",
X"		absolute.",
X"",
X"	-List",
X"		This option may be used to obtain a list of",
X"		suitable subjects for this command.  The list may",
X"		be more general than expected.",
X"",
X"	-MAJor [ <number> ]",
X"		Specify that the major version number is to be",
X"		incrimented, or set to the given number if",
X"		specified.",
X"",
X"	-MINOr [ <number> ]",
X"		Specify that the minor version number is to be",
X"		incrimented, or set to the given number if",
X"		specified.",
X"",
X"	-Not_Logging",
X"		This option may be used to disable the automatic",
X"		logging of output and errors to a file.  This is",
X"		often useful when several %s commands are",
X"		combined in a shell script.",
X"",
X"	-TERse",
X"		This option may be used to cause listings to",
X"		produce the bare minimum of information.  It is",
X"		usually useful for shell scripts.",
X"",
X"	-Verbose",
X"		This option may be used to cause %s to produce",
X"		more output.  By default %s only produces",
X"		output on errors.  When used with the -List option",
X"		this option causes column headings to be added.",
X"",
X"	All options may be abbreviated; the abbreviation is",
X"	documented as the upper case letters, all lower case",
X"	letters and underscores (_) are optional.  You must use",
X"	consecutive sequences of optional letters.",
X"",
X"	All options are case insensitive, you may type them in",
X"	upper case or lower case or a combination of both, case",
X"	is not important.",
X"",
X"	For example: the arguments \"-project, \"-PROJ\" and \"-p\"",
X"	are all interpreted to mean the -Project option.  The",
X"	argument \"-prj\" will not be understood, because",
X"	consecutive optional characters were not supplied.",
X"",
X"	Options and other command line arguments may be mixed",
X"	arbitrarily on the command line, after the function",
X"	selectors.",
X"",
X"	The GNU long option names are understood.  Since all",
X"	option names for aegis are long, this means ignoring the",
X"	extra leading '-'.  The \"--option=value\" convention is",
X"	also understood.",
X"",
X"RECOMMENDED ALIAS",
X"	The recommended alias for this command is",
X"	csh%%	alias aenrls '%s -nrls \\!* -v'",
X"	sh$	aenrls(){%s -nrls $* -v}",
X"",
X"ERRORS",
X"	It is an error if the old project named does not exist.",
X"",
X"	It is an error if the old project named has not yet had",
X"	any changes integrated.",
X"",
X"	It is an error if the old project named has any changes",
X"	not in the completed state.",
X"",
X"	It is an error if the current user is not an administrator",
X"	of the old project.",
X"",
X"EXIT STATUS",
X"	The %s command will exit with a status of 1 on any",
X"	error.  The %s command will only exit with a status of",
X"	0 if there are no errors.",
X"",
X"COPYRIGHT",
X"	%C",
X"",
X"AUTHOR",
X"	%A",
X	};
X
X	help(text, SIZEOF(text), new_release_usage);
X}
X
X
Xstatic void new_release_list _((void));
X
Xstatic void
Xnew_release_list()
X{
X	arglex();
X	while (arglex_token != arglex_token_eoln)
X		generic_argument(new_release_usage);
X	list_projects(0, 0);
X}
X
X
Xstatic void remove_suffix _((char *, char *));
X
Xstatic void
Xremove_suffix(str, suf)
X	char	*str;
X	char	*suf;
X{
X	size_t	str_len;
X	size_t	suf_len;
X
X	str_len = strlen(str);
X	suf_len = strlen(suf);
X	if
X	(
X		str_len > suf_len + 1
X	&&
X		ispunct(str[str_len - suf_len - 1])
X	&&
X		!strcmp(str + str_len - suf_len, suf)
X	)
X		str[str_len - suf_len - 1] = 0;
X}
X
X
Xstatic string_ty *build_new_name _((string_ty *, long, long, long, long));
X
Xstatic string_ty *
Xbuild_new_name(s, major_old, minor_old, major_new, minor_new)
X	string_ty	*s;
X	long		major_old;
X	long		minor_old;
X	long		major_new;
X	long		minor_new;
X{
X	char		tmp[1000];
X	char		suffix[20];
X
X	strcpy(tmp, s->str_text);
X	sprintf(suffix, "%ld", minor_old);
X	remove_suffix(tmp, suffix);
X	sprintf(suffix, "%ld", major_old);
X	remove_suffix(tmp, suffix);
X	return str_format("%s.%ld.%ld", tmp, major_new, minor_new);
X}
X
X
Xtypedef struct copy_tree_arg_ty copy_tree_arg_ty;
Xstruct copy_tree_arg_ty
X{
X	string_ty	*from;
X	string_ty	*to;
X};
X
X
Xstatic void copy_tree_callback _((void *, dir_walk_message_ty, string_ty *,
X	struct stat *));
X
Xstatic void
Xcopy_tree_callback(arg, message, path, st)
X	void		*arg;
X	dir_walk_message_ty message;
X	string_ty	*path;
X	struct stat	*st;
X{
X	string_ty	*s1;
X	string_ty	*s2;
X	copy_tree_arg_ty	*info;
X
X	trace(("copy_tree_callback(arg = %08lX, message = %d, path = %08lX, st = %08lX)\n{\n"/*}*/, arg, message, path, st));
X	info = (copy_tree_arg_ty *)arg;
X	trace_string(path->str_text);
X	s1 = os_below_dir(info->from, path);
X	assert(s1);
X	trace_string(s1->str_text);
X	if (!s1->str_length)
X		s2 = str_copy(info->to);
X	else
X		s2 = str_format("%S/%S", info->to, s1);
X	trace_string(s2->str_text);
X	switch (message)
X	{
X	case dir_walk_dir_before:
X		if (s1->str_length)
X		{
X			os_mkdir(s2, st->st_mode & 07755);
X			undo_rmdir_errok(s2);
X		}
X		break;
X
X	case dir_walk_file:
X		/*
X		 * copy the file
X		 */
X		copy_whole_file(path, s2, 1);
X		undo_unlink_errok(s2);
X		os_chmod(s2, st->st_mode & 07755);
X		break;
X
X	case dir_walk_dir_after:
X	case dir_walk_special:
X	case dir_walk_symlink:
X		break;
X	}
X	str_free(s2);
X	str_free(s1);
X	trace((/*{*/"}\n"));
X}
X
X
Xstatic void new_release_main _((void));
X
Xstatic void
Xnew_release_main()
X{
X	string_ty	*ip;
X	string_ty	*bl;
X	string_ty	*hp;
X	long		major_new;
X	long		minor_new;
X	int		j;
X	pstate		pstate_data[2];
X	string_ty	*home;
X	string_ty	*s1;
X	string_ty	*s2;
X	string_ty	*project_name[2];
X	int		project_name_count;
X	project_ty	*pp[2];
X	change_ty	*cp;
X	cstate_history	chp;
X	pstate_history	php;
X	cstate		cstate_data;
X	copy_tree_arg_ty	info;
X	pconf		pconf_data;
X	int		nolog;
X	user_ty		*up;
X	user_ty		*pup;
X
X	trace(("new_release_main()\n{\n"/*}*/));
X	nolog = 0;
X	home = 0;
X	project_name_count = 0;
X	major_new = NOT_GIVEN;
X	minor_new = NOT_GIVEN;
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch (arglex_token)
X		{
X		default:
X			generic_argument(new_release_usage);
X			continue;
X
X		case arglex_token_project:
X			if (arglex() != arglex_token_string)
X				new_release_usage();
X			/* fall through... */
X
X		case arglex_token_string:
X			if (project_name_count >= 2)
X				fatal("too many project names given");
X			project_name[project_name_count++] =
X				str_from_c(arglex_value.alv_string);
X			break;
X
X		case arglex_token_directory:
X			if (arglex() != arglex_token_string)
X		  		new_release_usage();
X			if (home)
X			{
X				duplicate:
X				fatal("duplicate %s option", arglex_value.alv_string);
X			}
X			s1 = str_from_c(arglex_value.alv_string);
X			os_become_orig();
X			home = os_pathname(s1, 1);
X			os_become_undo();
X			str_free(s1);
X			break;
X
X		case arglex_token_major:
X			if (major_new != NOT_GIVEN)
X				goto duplicate;
X			if (arglex() != arglex_token_number)
X			{
X				major_new = GIVEN;
X				continue;
X			}
X			major_new = arglex_value.alv_number;
X			if (major_new < 1)
X				fatal("major version number out of range");
X			break;
X
X		case arglex_token_minor:
X			if (minor_new != NOT_GIVEN)
X				goto duplicate;
X			if (arglex() != arglex_token_number)
X			{
X				minor_new = GIVEN;
X				continue;
X			}
X			minor_new = arglex_value.alv_number;
X			if (minor_new < 0)
X				fatal("minor version number out of range");
X			break;
X
X		case arglex_token_nolog:
X			if (nolog)
X				goto duplicate;
X			nolog = 1;
X			break;
X		}
X		arglex();
X	}
X	if (!project_name_count)
X	{
X		fatal
X		(
X"You must name the project to be used as the basis for the new release.  \
XYou may optionally specify a second name as the name of the new project."
X		);
X	}
X
X	/*
X	 * locate OLD project data
X	 */
X	pp[0] = project_alloc(project_name[0]);
X	project_bind_existing(pp[0]);
X	pstate_data[0] = project_pstate_get(pp[0]);
X
X	/*
X	 * locate user data
X	 */
X	up = user_executing(pp[0]);
X
X	/*
X	 * it is an error if the current user is not an administrator
X	 * of the old project.
X	 */
X	if (!project_administrator_query(pp[0], user_name(up)))
X	{
X		project_fatal
X		(
X			pp[0],
X			"user \"%S\" is not an administrator",
X			user_name(up)
X		);
X	}
X
X	/*
X	 * figure the new version number
X	 */
X	switch (major_new)
X	{
X	case NOT_GIVEN:
X		major_new = pstate_data[0]->version_major;
X		major_not_given:
X		switch (minor_new)
X		{
X		case NOT_GIVEN:
X		case GIVEN:
X			minor_new = pstate_data[0]->version_minor + 1;
X			break;
X
X		default:
X			if (minor_new <= pstate_data[0]->version_minor)
X			{
X				fatal
X				(
X	      "minor version number too small (you gave %d, the default is %d)",
X					minor_new,
X					pstate_data[0]->version_minor + 1
X				);
X			}
X			break;
X		}
X		break;
X
X	case GIVEN:
X		major_new = pstate_data[0]->version_major + 1;
X		switch (minor_new)
X		{
X		case NOT_GIVEN:
X		case GIVEN:
X			minor_new = 0;
X			break;
X
X		default:
X			break;
X		}
X		break;
X
X	default:
X		if (major_new == pstate_data[0]->version_major)
X			goto major_not_given;
X		if (major_new <= pstate_data[0]->version_major)
X		{
X			fatal
X			(
X	      "major version number too small (you gave %d, the default is %d)",
X				major_new,
X				pstate_data[0]->version_major + 1
X			);
X		}
X		switch (minor_new)
X		{
X		case NOT_GIVEN:
X		case GIVEN:
X			minor_new = 0;
X			break;
X
X		default:
X			break;
X		}
X		break;
X	}
X
X	/*
X	 * build new project name if none given
X	 */
X	if (project_name_count < 2)
X	{
X		project_name[project_name_count++] =
X			build_new_name
X			(
X				project_name[0],
X				pstate_data[0]->version_major,
X				pstate_data[0]->version_minor,
X				major_new,
X				minor_new
X			);
X	}
X
X	/*
X	 * locate NEW project data
X	 */
X	pp[1] = project_alloc(project_name[1]);
X	project_bind_new(pp[1]);
X	pup = project_user(pp[0]);
X
X	/*
X	 * read in the table
X	 */
X	project_pstate_lock_prepare(pp[1]);
X	project_build_read_lock_prepare(pp[0]);
X	gonzo_gstate_lock_prepare_new();
X	lock_take();
X	pstate_data[0] = project_pstate_get(pp[0]);
X	pstate_data[1] = project_pstate_get(pp[1]);
X
X	/*
X	 * create a new release state file
X	 */
X	pstate_data[1] = project_pstate_get(pp[1]);
X	pstate_data[1]->description = str_copy(pstate_data[0]->description);
X	pstate_data[1]->next_change_number = 2;
X	pstate_data[1]->next_delta_number = 2;
X	pstate_data[1]->next_test_number = pstate_data[0]->next_test_number;
X	pstate_data[1]->version_major = major_new;
X	pstate_data[1]->version_minor = minor_new;
X	pstate_data[1]->owner_name = str_copy(project_owner(pp[0]));
X	pstate_data[1]->group_name = str_copy(project_group(pp[0]));
X	pstate_data[1]->version_previous = project_version_get(pp[0]);
X	pstate_data[1]->umask = pstate_data[0]->umask;
X	pstate_data[1]->default_test_exemption =
X		pstate_data[0]->default_test_exemption;
X	/* administrators */
X	for (j = 0; j < pstate_data[0]->administrator->length; ++j)
X	{
X		project_administrator_add
X		(
X			pp[1],
X			pstate_data[0]->administrator->list[j]
X		);
X	}
X	/* developers */
X	for (j = 0; j < pstate_data[0]->developer->length; ++j)
X	{
X		project_developer_add
X		(
X			pp[1],
X			pstate_data[0]->developer->list[j]
X		);
X	}
X	/* reviewers */
X	for (j = 0; j < pstate_data[0]->reviewer->length; ++j)
X	{
X		project_reviewer_add
X		(
X			pp[1],
X			pstate_data[0]->reviewer->list[j]
X		);
X	}
X	/* integrators */
X	for (j = 0; j < pstate_data[0]->integrator->length; ++j)
X	{
X		project_integrator_add
X		(
X			pp[1],
X			pstate_data[0]->integrator->list[j]
X		);
X	}
X	pstate_data[1]->developer_may_review =
X		pstate_data[0]->developer_may_review;
X	pstate_data[1]->developer_may_integrate =
X		pstate_data[0]->developer_may_integrate;
X	pstate_data[1]->reviewer_may_integrate =
X		pstate_data[0]->reviewer_may_integrate;
X	pstate_data[1]->developers_may_create_changes =
X		pstate_data[0]->developers_may_create_changes;
X
X	if (pstate_data[0]->develop_end_notify_command)
X		pstate_data[1]->develop_end_notify_command =
X			str_copy(pstate_data[0]->develop_end_notify_command);
X	if (pstate_data[0]->develop_end_undo_notify_command)
X		pstate_data[1]->develop_end_undo_notify_command =
X			str_copy(pstate_data[0]->develop_end_undo_notify_command);
X	if (pstate_data[0]->review_pass_notify_command)
X		pstate_data[1]->review_pass_notify_command =
X			str_copy(pstate_data[0]->review_pass_notify_command);
X	if (pstate_data[0]->review_pass_undo_notify_command)
X		pstate_data[1]->review_pass_undo_notify_command =
X			str_copy(pstate_data[0]->review_pass_undo_notify_command);
X	if (pstate_data[0]->review_fail_notify_command)
X		pstate_data[1]->review_fail_notify_command =
X			str_copy(pstate_data[0]->review_fail_notify_command);
X	if (pstate_data[0]->integrate_pass_notify_command)
X		pstate_data[1]->integrate_pass_notify_command =
X			str_copy(pstate_data[0]->integrate_pass_notify_command);
X	if (pstate_data[0]->integrate_fail_notify_command)
X		pstate_data[1]->integrate_fail_notify_command =
X			str_copy(pstate_data[0]->integrate_fail_notify_command);
X	if (pstate_data[0]->default_development_directory)
X		pstate_data[1]->default_development_directory =
X			str_copy(pstate_data[0]->default_development_directory);
X
X	/*
X	 * if no project directory was specified
X	 * create the directory in their home directory.
X	 */
X	if (!home)
X	{
X		s2 = user_default_project_directory(pup);
X		assert(s2);
X		home = str_format("%S/%S", s2, project_name[1]);
X		str_free(s2);
X	}
X	project_home_path_set(pp[1], home);
X	project_verbose(pp[1], "project directory \"%S\"", home);
X	str_free(home);
X
X	/*
X	 * create the diectory and subdirectories.
X	 * It is an error if the directories can't be created.
X	 *
X	 * Don't use the project_baseline_path_get function,
X	 * because it resolves any symlinks.
X	 */
X	s1 = project_home_path_get(pp[1]);
X	bl = project_baseline_path_get(pp[1], 0);
X	hp = project_history_path_get(pp[1]);
X	ip = project_info_path_get(pp[1]);
X	project_become(pp[1]);
X	os_mkdir(s1, 02755);
X	undo_rmdir_errok(s1);
X	os_mkdir(bl, 02755);
X	undo_rmdir_errok(bl);
X	os_mkdir(hp, 02755);
X	undo_rmdir_errok(hp);
X	os_mkdir(ip, 02755);
X	undo_rmdir_errok(ip);
X	os_become_undo();
X
X	/*
X	 * add a row to the table
X	 */
X	gonzo_project_add(pp[1]);
X
X	/*
X	 * the first change adds all of the files
X	 */
X	cp = change_alloc(pp[1], 1);
X	change_bind_new(cp);
X	cstate_data = change_cstate_get(cp);
X	cstate_data->brief_description =
X		str_format("New release derived from %S.", project_name[0]);
X	cstate_data->cause = change_cause_internal_enhancement;
X	cstate_data->test_exempt = 1;
X	cstate_data->test_baseline_exempt = 1;
X	project_change_append(pp[1], 1);
X
X	/*
X	 * lots of fake history so we don't confuse
X	 * anything later with otherwise illegal state transitions
X	 */
X	chp = change_history_new(cp, up);
X	chp->what = cstate_history_what_new_change;
X	chp = change_history_new(cp, up);
X	chp->what = cstate_history_what_develop_begin;
X	chp = change_history_new(cp, up);
X	chp->what = cstate_history_what_develop_end;
X	chp = change_history_new(cp, up);
X	chp->what = cstate_history_what_review_pass;
X	chp = change_history_new(cp, up);
X	chp->what = cstate_history_what_integrate_begin;
X	cstate_data->state = cstate_state_being_integrated;
X	cstate_data->integration_directory = str_copy(bl);
X
X	/*
X	 * add all of the files to the change
X	 */
X	for (j = 0; j < pstate_data[0]->src->length; ++j)
X	{
X		pstate_src	p_src_data;
X		pstate_src	p1_src_data;
X		cstate_src	c_src_data;
X
X		p_src_data = pstate_data[0]->src->list[j];
X		if (p_src_data->deleted_by)
X			continue;
X		if (p_src_data->about_to_be_created_by)
X			continue;
X
X		p1_src_data = project_src_new(pp[1], p_src_data->file_name);
X		p1_src_data->usage = p_src_data->usage;
X
X		c_src_data = change_src_new(cp);
X		c_src_data->file_name = str_copy(p_src_data->file_name);
X		c_src_data->action = file_action_create;
X		c_src_data->usage = p_src_data->usage;
X	}
X
X	/*
X	 * copy files from old baseline to new baseline
X	 */
X	info.from = project_baseline_path_get(pp[0], 1);
X	info.to = bl;
X	project_verbose(pp[1], "copy baseline");
X	project_become(pp[1]);
X	dir_walk(info.from, copy_tree_callback, &info);
X	os_become_undo();
X
X	/*
X	 * build history files
X	 */
X	if (!nolog)
X	{
X		user_ty	*pup;
X
X		s1 = str_format("%S/%s.log", bl, option_progname_get());
X		pup = project_user(pp[1]);
X		log_open(s1, pup);
X		user_free(pup);
X		str_free(s1);
X	}
X	pconf_data = change_pconf_get(cp);
X	for (j = 0; j < cstate_data->src->length; ++j)
X	{
X		cstate_src	c_src_data;
X		pstate_src	p_src_data;
X
X		c_src_data = cstate_data->src->list[j];
X		p_src_data = project_src_find(pp[1], c_src_data->file_name);
X		assert(p_src_data);
X
X		/*
X		 * create a new history file
X		 */
X		change_run_history_create_command(cp, c_src_data->file_name);
X		p_src_data->edit_number =
X			change_run_history_query_command
X			(
X				cp,
X				c_src_data->file_name
X			);
X		c_src_data->edit_number = str_copy(p_src_data->edit_number);
X	}
X
X	/*
X	 * some more history
X	 */
X	str_free(cstate_data->integration_directory);
X	cstate_data->integration_directory = 0;
X	chp = change_history_new(cp, up);
X	chp->what = cstate_history_what_integrate_pass;
X	php = project_history_new(pp[1]);
X	php->delta_number = 1;
X	php->change_number = 1;
X	cstate_data->state = cstate_state_completed;
X	cstate_data->delta_number = 1;
X
X	/*
X	 * write the project pointer back out
X	 * release locks
X	 */
X	change_cstate_write(cp);
X	project_pstate_write(pp[1]);
X	gonzo_gstate_write();
X	commit();
X	lock_release();
X
X	/*
X	 * verbose success message
X	 */
X	project_verbose(pp[1], "created");
X	str_free(project_name[0]);
X	project_free(pp[0]);
X	str_free(project_name[1]);
X	project_free(pp[1]);
X	change_free(cp);
X	user_free(up);
X	user_free(pup);
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xnew_release()
X{
X	trace(("new_release()\n{\n"/*}*/));
X	switch (arglex())
X	{
X	default:
X		new_release_main();
X		break;
X
X	case arglex_token_help:
X		new_release_help();
X		break;
X
X	case arglex_token_list:
X		new_release_list();
X		break;
X	}
X	trace((/*{*/"}\n"));
X}
END_OF_FILE
if test 22801 -ne `wc -c <'aegis/aenrls.c'`; then
    echo shar: \"'aegis/aenrls.c'\" unpacked with wrong size!
fi
# end of 'aegis/aenrls.c'
fi
if test -f 'aegis/aet.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aegis/aet.c'\"
else
echo shar: Extracting \"'aegis/aet.c'\" \(23376 characters\)
sed "s/^X//" >'aegis/aet.c' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to implement test
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X
X#include <ael.h>
X#include <aet.h>
X#include <arglex2.h>
X#include <change.h>
X#include <commit.h>
X#include <error.h>
X#include <help.h>
X#include <lock.h>
X#include <log.h>
X#include <option.h>
X#include <option.h>
X#include <os.h>
X#include <project.h>
X#include <trace.h>
X#include <user.h>
X#include <word.h>
X
X
Xstatic void test_usage _((void));
X
Xstatic void
Xtest_usage()
X{
X	char		*progname;
X
X	progname = option_progname_get();
X	fprintf(stderr, "usage: %s -Test [ <filename>... ][ <option>... ]\n", progname);
X	fprintf(stderr, "       %s -Test -List [ <option>... ]\n", progname);
X	fprintf(stderr, "       %s -Test -Help\n", progname);
X	quit(1);
X}
X
X
Xstatic void test_help _((void));
X
Xstatic void
Xtest_help()
X{
X	static char *text[] =
X	{
X"NAME",
X"	%s -Test - run tests",
X"",
X"SYNOPSIS",
X"	%s -Test [ <file-name>... ][ <option>... ]",
X"	%s -Test -INDependent [ <file-name>... ][ <option>... ]",
X"	%s -Test -List [ <option>... ]",
X"	%s -Test -Help",
X"",
X"DESCRIPTION",
X"	The %s -Test command is used to run tests.  If no",
X"	files are named, all relevant tests are run.  By default",
X"	both automatic and manual tests are run.",
X"",
X"	The %s program will attempt to intuit the file names",
X"	intended.  All file names are stored within %s as",
X"	relative to the root of the baseline directory tree.  The",
X"	development directory and the integration directory are",
X"	shadows of the baseline directory, and so these relative",
X"	names aply there, too.	Files named on the command line",
X"	are first converted to absolute paths if necessary.  They",
X"	are then compared with the baseline path, and the",
X"	development directory path, and the integration directory",
X"	path, to determine a root-relative name.  It is an error",
X"	if the file named is outside one of these directory",
X"	trees.",
X"",
X"	Tests are executed by the Bourne shell.  The current directory",
X"	will be the top of the appropriate directory tree.  If",
X"	tests require temporary files, they should create them in",
X"	/tmp, as a test cannot expect to have write permission in",
X"	the current directory.",
X"",
X"OPTIONS",
X"	The following options are understood:",
X"",
X"	-AUTOmatic",
X"		This option may be uset to specify manual tests.",
X"		Automatic tests require no human assitance.",
X"",
X"	-BaseLine",
X"		This option may be used to specify that the",
X"		project baseline is the subject of the command.",
X"",
X"	-Change <number>",
X"		This option may be used to specify a particular",
X"		change within a project.  When no -Change option is",
X"		specified, the AEGIS_CHANGE environment variable is",
X"		consulted.  If that does not exist, the user's",
X"		$HOME/.aegisrc file is examined for a default change",
X"		field (see aeuconf(5) for more information).  If",
X"		that does not exist, when the user is only working",
X"		on one change within a project, that is the default",
X"		change number.  Otherwise, it is an error.",
X"",
X"	-Development_Directory",
X"		This option is ised to specify that the",
X"		development directory is the subject of the",
X"		command.  This is only useful for a change which",
X"		is in the 'being_integrated' state, when the",
X"		default is the integration directory.",
X"",
X"	-Help",
X"		This option may be used to obtain more",
X"		information about how to use the %s program.",
X"",
X"	-List",
X"		This option may be used to obtain a list of",
X"		suitable subjects for this command.  The list may",
X"		be more general than expected.",
X"",
X"	-MANual",
X"		This option may be used to specify manual tests.",
X"		Manual tests require some human intervention,",
X"		e.g.:  confirmation of some screen behaviour",
X"		(X11, for instance), or some user action, \"unplug",
X"		ethernet cable now\".",
X"",
X"	-Project <name>",
X"		This option may be used to select the project of",
X"		interest.  When no -Project option is specified, the",
X"		AEGIS_PROJECT environment variable is consulted.  If",
X"		that does not exist, the user's $HOME/.aegisrc file",
X"		is examined for a default project field (see",
X"		aeuconf(5) for more information).  If that does not",
X"		exist, when the user is only working on changes",
X"		within a single project, the project name defaults",
X"		to that project.  Otherwise, it is an error.",
X"",
X"	-TERse",
X"		This option may be used to cause listings to",
X"		produce the bare minimum of information.  It is",
X"		usually useful for shell scripts.",
X"",
X"	-Verbose",
X"		This option may be used to cause %s to produce",
X"		more output.  By default %s only produces",
X"		output on errors.  When used with the -List",
X"		option this option causes column headings to be",
X"		added.",
X"",
X"	All options may be abbreviated; the abbreviation is",
X"	documented as the upper case letters, all lower case",
X"	letters and underscores (_) are optional.  You must use",
X"	consecutive sequences of optional letters.",
X"",
X"	All options are case insensitive, you may type them in",
X"	upper case or lower case or a combination of both, case",
X"	is not important.",
X"",
X"	For example: the arguments \"-project, \"-PROJ\" and \"-p\"",
X"	are all interpreted to mean the -Project option.  The",
X"	argument \"-prj\" will not be understood, because",
X"	consecutive optional characters were not supplied.",
X"",
X"	Options and other command line arguments may be mixed",
X"	arbitrarily on the command line, after the function",
X"	selectors.",
X"",
X"	The GNU long option names are understood.  Since all",
X"	option names for aegis are long, this means ignoring the",
X"	extra leading '-'.  The \"--option=value\" convention is",
X"	also understood.",
X"",
X"RECOMMENDED ALIAS",
X"	The recommended alias for this command is",
X"	csh%%	alias aet '%s -t \\!* -v'",
X"	sh$	aet(){%s -t $* -v}",
X"",
X"ERRORS",
X"	It is an error if the change is not in one of the",
X"	'being_developed' or 'being_integrated' states.",
X"	It is an error if the change is not assigned to the",
X"	current user.",
X"",
X"EXIT STATUS",
X"	The %s command will exit with a status of 1 on any",
X"	error.	The %s command will only exit with a status of",
X"	0 if there are no errors.",
X"",
X"COPYRIGHT",
X"	%C",
X"",
X"AUTHOR",
X"	%A",
X	};
X
X	help(text, SIZEOF(text), test_usage);
X}
X
X
Xstatic void test_list _((void));
X
Xstatic void
Xtest_list()
X{
X	string_ty	*project_name;
X	long		change_number;
X
X	trace(("test_list()\n{\n"/*}*/));
X	project_name = 0;
X	change_number = 0;
X	arglex();
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch (arglex_token)
X		{
X		default:
X			generic_argument(test_usage);
X			continue;
X
X		case arglex_token_change:
X			if (arglex() != arglex_token_number)
X				test_usage();
X			/* fall through... */
X
X		case arglex_token_number:
X			if (change_number)
X				fatal("duplicate -Change option");
X			change_number = arglex_value.alv_number;
X			if (change_number < 1)
X				fatal("change %ld out of range", change_number);
X			break;
X
X		case arglex_token_project:
X			if (arglex() != arglex_token_string)
X				test_usage();
X			if (project_name)
X				fatal("duplicate -Project option");
X			project_name = str_from_c(arglex_value.alv_string);
X			break;
X		}
X		arglex();
X	}
X	list_change_files(project_name, change_number);
X	if (project_name)
X		str_free(project_name);
X	trace((/*{*/"}\n"));
X}
X
X
Xstatic void test_main _((void));
X
Xstatic void
Xtest_main()
X{
X	string_ty	*bl;
X	string_ty	*top;
X	int		baseline_flag;
X	int		devdir_flag;
X	int		regression_flag;
X	int		manual_flag;
X	int		automatic_flag;
X	wlist		wl;
X	wlist		cfile;
X	wlist		pfile;
X	string_ty	*s1;
X	string_ty	*s2;
X	pstate		pstate_data;
X	pstate_src	p_src_data;
X	cstate		cstate_data;
X	cstate_src	c_src_data;
X	string_ty	*dir;
X	int		j;
X	int		npassed;
X	int		nfailed;
X	string_ty	*project_name;
X	project_ty	*pp;
X	long		change_number;
X	change_ty	*cp;
X	int		nolog;
X	user_ty		*up;
X
X	trace(("test_main()\n{\n"/*}*/));
X	project_name = 0;
X	change_number = 0;
X	baseline_flag = 0;
X	devdir_flag = 0;
X	regression_flag = 0;
X	manual_flag = 0;
X	automatic_flag = 0;
X	nolog = 0;
X	wl_zero(&wl);
X	wl_zero(&cfile);
X	wl_zero(&pfile);
X	dir = 0;
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch (arglex_token)
X		{
X		default:
X			generic_argument(test_usage);
X			continue;
X
X		case arglex_token_change:
X			if (arglex() != arglex_token_number)
X				test_usage();
X			/* fall through... */
X
X		case arglex_token_number:
X			if (change_number)
X				fatal("duplicate -Change option");
X			change_number = arglex_value.alv_number;
X			if (change_number < 1)
X				fatal("change %ld out of range", change_number);
X			break;
X
X		case arglex_token_regression:
X			if (regression_flag)
X			{
X				duplicate:
X				fatal("duplicate %s option", arglex_value.alv_string);
X			}
X			regression_flag = 1;
X			break;
X
X		case arglex_token_manual:
X			if (manual_flag)
X				goto duplicate;
X			manual_flag = 1;
X			break;
X
X		case arglex_token_automatic:
X			if (automatic_flag)
X				goto duplicate;
X			automatic_flag = 1;
X			break;
X
X		case arglex_token_string:
X			s1 = str_from_c(arglex_value.alv_string);
X			os_become_orig();
X			s2 = os_pathname(s1, 1);
X			os_become_undo();
X			if (wl_member(&wl, s1))
X			{
X				fatal
X				(
X					"file \"%s\" named more than once",
X					arglex_value.alv_string
X				);
X			}
X			wl_append(&wl, s2);
X			str_free(s1);
X			str_free(s2);
X			break;
X
X		case arglex_token_development_directory:
X			if (devdir_flag)
X				goto duplicate;
X			devdir_flag = 1;
X			break;
X
X		case arglex_token_baseline:
X			if (baseline_flag)
X				goto duplicate;
X			baseline_flag = 1;
X			break;
X
X		case arglex_token_project:
X			if (arglex() != arglex_token_string)
X				test_usage();
X			if (project_name)
X				fatal("duplicate -Project option");
X			project_name = str_from_c(arglex_value.alv_string);
X			break;
X
X		case arglex_token_nolog:
X			if (nolog)
X				goto duplicate;
X			nolog = 1;
X			break;
X		}
X		arglex();
X	}
X	if (wl.wl_nwords)
X	{
X		if (automatic_flag)
X			fatal("may not name files and use the -AUTOmatic option");
X		if (manual_flag)
X			fatal("may not name files and use the -MANual option");
X		if (regression_flag)
X			fatal("may not name files and use the -REGression option");
X	}
X	else
X	{
X		if (!manual_flag && !automatic_flag)
X		{
X			manual_flag = 1;
X			automatic_flag = 1;
X		}
X	}
X	trace_int(manual_flag);
X	trace_int(automatic_flag);
X
X	/*
X	 * locate project data
X	 */
X	if (!project_name)
X		project_name = user_default_project();
X	pp = project_alloc(project_name);
X	str_free(project_name);
X	project_bind_existing(pp);
X
X	/*
X	 * locate user data
X	 */
X	up = user_executing(pp);
X
X	/*
X	 * locate change data
X	 */
X	if (!change_number)
X		change_number = user_default_change(up);
X	cp = change_alloc(pp, change_number);
X	change_bind_existing(cp);
X
X	/*
X	 * take a lock on the change
X	 */
X	change_cstate_lock_prepare(cp);
X	lock_take();
X	pstate_data = project_pstate_get(pp);
X	cstate_data = change_cstate_get(cp);
X
X	/*
X	 * see if it is an appropriate thing to be doing
X	 */
X	bl = project_baseline_path_get(pp, 1);
X	switch (cstate_data->state)
X	{
X	case cstate_state_being_developed:
X		if (!str_equal(change_developer_name(cp), user_name(up)))
X		{
X			change_fatal
X			(
X				cp,
X				"user \"%S\" is not the developer",
X				user_name(up)
X			);
X		}
X		if (baseline_flag)
X			dir = bl;
X		else
X		{
X			dir = change_development_directory_get(cp, 1);
X			trace_string(dir->str_text);
X		}
X		break;
X
X	case cstate_state_being_integrated:
X		if (!str_equal(change_integrator_name(cp), user_name(up)))
X		{
X			change_fatal
X			(
X				cp,
X				"user \"%S\" is not the integrator",
X				user_name(up)
X			);
X		}
X		if (baseline_flag)
X			dir = bl;
X		else
X		{
X			if (devdir_flag)
X				dir = change_development_directory_get(cp, 1);
X			else
X				dir = change_integration_directory_get(cp, 1);
X		}
X		break;
X
X	default:
X		change_fatal(cp, "not in 'being_developed' state");
X	}
X	assert(dir);
X
X	/*
X	 * see if this is a complete change test.
X	 * If it is, we can update the relevant test time field.
X	 */
X	if (automatic_flag && manual_flag && !regression_flag && !wl.wl_nwords)
X	{
X		if (baseline_flag)
X			cstate_data->test_baseline_time = time((time_t *)0);
X		else
X			cstate_data->test_time = time((time_t *)0);
X	}
X	if (regression_flag)
X		cstate_data->regression_test_time = time((time_t *)0);
X
X	/*
X	 * check that the named files make sense
X	 * split the named files into two separate lists
X	 */
X	for (j = 0; j < wl.wl_nwords; ++j)
X	{
X		s1 = wl.wl_word[j];
X		assert(s1->str_text[0] == '/');
X		s2 = os_below_dir(bl, s1);
X		if (!s2 && cstate_data->state == cstate_state_being_integrated)
X			s2 = os_below_dir(change_integration_directory_get(cp, 1), s1);
X		if (!s2)
X			s2 = os_below_dir(change_development_directory_get(cp, 1), s1);
X		if (!s2)
X			change_fatal(cp, "path \"%S\" unrelated", s1);
X		c_src_data = change_src_find(cp, s2);
X		if (c_src_data)
X		{
X			if (c_src_data->action == file_action_remove)
X				change_fatal(cp, "file \"%S\" is being removed", s2);
X			if
X			(
X				c_src_data->usage != file_usage_test
X			&&
X				c_src_data->usage != file_usage_manual_test
X			)
X				change_fatal(cp, "file \"%S\" is not a test", s2);
X			wl_append(&cfile, s2);
X			if (c_src_data->usage == file_usage_manual_test)
X				nolog = 1;
X		}
X		else
X		{
X			p_src_data = project_src_find(pp, s2);
X			if
X			(
X				!p_src_data
X			||
X				p_src_data->deleted_by
X			||
X				p_src_data->about_to_be_created_by
X			)
X				change_fatal(cp, "file \"%S\" unknown", s2);
X			if
X			(
X				p_src_data->usage != file_usage_test
X			&&
X				p_src_data->usage != file_usage_manual_test
X			)
X				project_fatal(pp, "file \"%S\" is not a test", s2);
X			wl_append(&pfile, s2);
X			if (p_src_data->usage == file_usage_manual_test)
X				nolog = 1;
X		}
X		str_free(s2);
X	}
X
X	if (automatic_flag || manual_flag)
X	{
X		assert(!cfile.wl_nwords);
X		assert(!pfile.wl_nwords);
X		if (regression_flag)
X		{
X			/*
X			 * run through the project test files
X			 */
X			for (j = 0; j < pstate_data->src->length; ++j)
X			{
X				p_src_data = pstate_data->src->list[j];
X
X				/*
X				 * don't run the test if it does not exist
X				 */
X				if
X				(
X					p_src_data->deleted_by
X				||
X					p_src_data->about_to_be_created_by
X				)
X					continue;
X
X				/*
X				 * don't run the test if it is being
X				 * modified by the change
X				 */
X				if (change_src_find(cp, p_src_data->file_name))
X					continue;
X
X				/*
X				 * run the test if it satisfies the request
X				 */
X				if
X				(
X					(
X					    p_src_data->usage == file_usage_test
X					&&
X						automatic_flag
X					)
X				||
X					(
X				     p_src_data->usage == file_usage_manual_test
X					&&
X						manual_flag
X					)
X				)
X					wl_append(&pfile, p_src_data->file_name);
X			}
X		}
X		else
X		{
X			for (j = 0; j < cstate_data->src->length; ++j)
X			{
X				c_src_data = cstate_data->src->list[j];
X				if (c_src_data->action == file_action_remove)
X					continue;
X				if (baseline_flag && c_src_data->action != file_action_create)
X					continue;
X				if
X				(
X					(
X					    c_src_data->usage == file_usage_test
X					&&
X						automatic_flag
X					)
X				||
X					(
X				     c_src_data->usage == file_usage_manual_test
X					&&
X						manual_flag
X					)
X				)
X				{
X					wl_append(&cfile, c_src_data->file_name);
X					if (c_src_data->usage == file_usage_manual_test)
X						nolog = 1;
X				}
X			}
X		}
X	}
X
X	/*
X	 * make sure we are actually doing something
X	 */
X	if (!cfile.wl_nwords && !pfile.wl_nwords)
X		change_fatal(cp, "has no tests");
X
X	/*
X	 * Do each of the change's tests.
X	 * Log if no manual tests.
X	 */
X	if (!nolog)
X	{
X		/*
X		 * open the log file as the appropriate user
X		 */
X		if (cstate_data->state == cstate_state_being_integrated)
X		{
X			user_ty	*pup;
X
X			pup = project_user(pp);
X			log_open(change_logfile_get(cp), pup);
X			user_free(pup);
X		}
X		else
X			log_open(change_logfile_get(cp), up);
X	}
X	npassed = 0;
X	nfailed = 0;
X	trace_string(dir->str_text);
X	if (cstate_data->state == cstate_state_being_integrated)
X		top = change_integration_directory_get(cp, 1);
X	else
X		top = change_development_directory_get(cp, 1);
X	for (j = 0; j < cfile.wl_nwords; ++j)
X	{
X		int		result;
X		int		flags;
X
X		s1 = cfile.wl_word[j];
X		c_src_data = change_src_find(cp, s1);
X		assert(c_src_data);
X		s2 = str_format("%s %S/%S", os_shell(), top, s1);
X		if (c_src_data->usage == file_usage_manual_test)
X			flags = OS_EXEC_FLAG_INPUT;
X		else
X			flags = OS_EXEC_FLAG_NO_INPUT;
X		user_become(up);
X		result = os_execute_retcode(s2, flags, dir);
X		os_become_undo();
X		str_free(s2);
X		if (baseline_flag)
X		{
X			if (result)
X			{
X				change_verbose
X				(
X					cp,
X				"test \"%S\" on baseline failed (as it should)",
X					s1
X				);
X				++npassed;
X			}
X			else
X			{
X				change_verbose
X				(
X					cp,
X				"test \"%S\" on baseline passed (it must fail)",
X					s1
X				);
X				++nfailed;
X				cstate_data->test_baseline_time = 0;
X			}
X		}
X		else
X		{
X			if (result)
X			{
X				change_verbose(cp, "test \"%S\" failed", s1);
X				++nfailed;
X				cstate_data->test_time = 0;
X			}
X			else
X			{
X				change_verbose(cp, "test \"%S\" passed", s1);
X				++npassed;
X			}
X		}
X	}
X
X	/*
X	 * Do each of the project's tests.
X	 * Log if no manual tests.
X	 */
X	for (j = 0; j < pfile.wl_nwords; ++j)
X	{
X		int		result;
X		int		flags;
X
X		s1 = pfile.wl_word[j];
X		p_src_data = project_src_find(pp, s1);
X		assert(p_src_data);
X		s2 = str_format("%s %S/%S", os_shell(), bl, s1);
X		if (p_src_data->usage == file_usage_manual_test)
X			flags = OS_EXEC_FLAG_INPUT;
X		else
X			flags = OS_EXEC_FLAG_NO_INPUT;
X		user_become(up);
X		result = os_execute_retcode(s2, flags, dir);
X		os_become_undo();
X		str_free(s2);
X		if (result)
X		{
X			change_verbose(cp, "test \"%S\" failed", s1);
X			++nfailed;
X			cstate_data->test_time = 0;
X			cstate_data->regression_test_time = 0;
X		}
X		else
X		{
X			change_verbose(cp, "test \"%S\" passed", s1);
X			++npassed;
X		}
X	}
X	if (npassed)
X	{
X		change_verbose
X		(
X			cp,
X			"passed %d test%s",
X			npassed,
X			((npassed == 1) ? "" : "s")
X		);
X	}
X	if (nfailed)
X	{
X		change_fatal
X		(
X			cp,
X			"failed %d test%s",
X			nfailed,
X			((nfailed == 1) ? "" : "s")
X		);
X	}
X
X	/*
X	 * write out the data
X	 */
X	change_cstate_write(cp);
X	commit();
X	lock_release();
X	change_free(cp);
X	project_free(pp);
X	user_free(up);
X	trace((/*{*/"}\n"));
X}
X
X
Xstatic void test_independent _((void));
X
Xstatic void
Xtest_independent()
X{
X	string_ty	*bl;
X	int		automatic_flag;
X	int		manual_flag;
X	wlist		wl;
X	string_ty	*s1;
X	string_ty	*s2;
X	pstate		pstate_data;
X	pstate_src	src_data;
X	int		j;
X	int		npassed;
X	int		nfailed;
X	string_ty	*project_name;
X	project_ty	*pp;
X	user_ty		*pup;
X
X	trace(("test_independent()\n{\n"/*}*/));
X	project_name = 0;
X	automatic_flag = 0;
X	manual_flag = 0;
X	wl_zero(&wl);
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch (arglex_token)
X		{
X		default:
X			generic_argument(test_usage);
X			continue;
X
X		case arglex_token_manual:
X			if (manual_flag)
X			{
X				duplicate:
X				fatal("duplicate %s option", arglex_value.alv_string);
X			}
X			manual_flag = 1;
X			break;
X
X		case arglex_token_automatic:
X			if (automatic_flag)
X				goto duplicate;
X			automatic_flag = 1;
X			break;
X
X		case arglex_token_string:
X			s1 = str_from_c(arglex_value.alv_string);
X			os_become_orig();
X			s2 = os_pathname(s1, 1);
X			os_become_undo();
X			if (wl_member(&wl, s1))
X			{
X				fatal
X				(
X					"path \"%s\" named more than once",
X					arglex_value.alv_string
X				);
X			}
X			wl_append(&wl, s2);
X			str_free(s1);
X			str_free(s2);
X			break;
X
X		case arglex_token_project:
X			if (arglex() != arglex_token_string)
X				test_usage();
X			if (project_name)
X				fatal("duplicate -Project option");
X			project_name = str_from_c(arglex_value.alv_string);
X			break;
X		}
X		arglex();
X	}
X	if (wl.wl_nwords)
X	{
X		if (automatic_flag)
X			fatal("may not name files and use the -AUTOmatic option");
X		if (manual_flag)
X			fatal("may not name files and use the -MANual option");
X	}
X	else
X	{
X		if (!automatic_flag && !manual_flag)
X		{
X			automatic_flag = 1;
X			manual_flag = 1;
X		}
X	}
X
X	/*
X	 * locate project data
X	 */
X	if (!project_name)
X		project_name = user_default_project();
X	pp = project_alloc(project_name);
X	str_free(project_name);
X	project_bind_existing(pp);
X	pup = user_symbolic(pp, project_owner(pp));
X
X	/*
X	 * grab some info
X	 */
X	pstate_data = project_pstate_get(pp);
X
X	/*
X	 * make sure the paths make sense
X	 */
X	bl = project_baseline_path_get(pp, 1);
X	for (j = 0; j < wl.wl_nwords; ++j)
X	{
X		s1 = wl.wl_word[j];
X		assert(s1->str_text[0] == '/');
X		s2 = os_below_dir(bl, s1);
X		if (!s2)
X			project_fatal(pp, "path \"%S\" unrelated", s1);
X		src_data = project_src_find(pp, s2);
X		if
X		(
X			!src_data
X		||
X			src_data->deleted_by
X		||
X			src_data->about_to_be_created_by
X		)
X			project_fatal(pp, "file \"%S\" unknown", s2);
X		if
X		(
X			src_data->usage != file_usage_test
X		&&
X			src_data->usage != file_usage_manual_test
X		)
X			project_fatal(pp, "file \"%S\" not a test", s2);
X		wl.wl_word[j] = s2;
X		str_free(s1);
X	}
X
X	/*
X	 * snarf the test names from the project
X	 */
X	if (automatic_flag || manual_flag)
X	{
X		for (j = 0; j < pstate_data->src->length; ++j)
X		{
X			pstate_src	src_data;
X
X			src_data = pstate_data->src->list[j];
X			if
X			(
X				src_data->deleted_by
X			||
X				src_data->about_to_be_created_by
X			)
X				continue;
X			if
X			(
X				(
X					src_data->usage == file_usage_test
X				&&
X					automatic_flag
X				)
X			||
X				(
X				       src_data->usage == file_usage_manual_test
X				&&
X					manual_flag
X				)
X			)
X				wl_append(&wl, src_data->file_name);
X		}
X		if (!wl.wl_nwords)
X			project_fatal(pp, "has no tests");
X	}
X
X	/*
X	 * do each of the tests
X	 * (Logging is disabled, because there is no [logical] place
X	 * to put the log file; the user should redirect stdout and stderr.)
X	 */
X	npassed = 0;
X	nfailed = 0;
X	for (j = 0; j < wl.wl_nwords; ++j)
X	{
X		int		result;
X		pstate_src	src_data;
X		int		flags;
X
X		src_data = project_src_find(pp, wl.wl_word[j]);
X		assert(src_data);
X		if (src_data->usage == file_usage_manual_test)
X			flags = OS_EXEC_FLAG_INPUT;
X		else
X			flags = OS_EXEC_FLAG_NO_INPUT;
X		project_become(pp);
X		result =
X			os_execute_retcode
X			(
X				src_data->file_name,
X				flags,
X				bl
X			);
X		os_become_undo();
X		if (result)
X		{
X			project_verbose
X			(
X				pp,
X				"test \"%S\" failed",
X				src_data->file_name
X			);
X			++nfailed;
X		}
X		else
X		{
X			project_verbose
X			(
X				pp,
X				"test \"%S\" passed",
X				src_data->file_name
X			);
X			++npassed;
X		}
X	}
X	if (npassed)
X	{
X		project_verbose
X		(
X			pp,
X			"passed %d test%s",
X			npassed,
X			((npassed == 1) ? "" : "s")
X		);
X	}
X	if (nfailed)
X	{
X		project_fatal
X		(
X			pp,
X			"failed %d test%s",
X			nfailed,
X			((nfailed == 1) ? "" : "s")
X		);
X	}
X	project_free(pp);
X	user_free(pup);
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xtest()
X{
X	trace(("test()\n{\n"/*}*/));
X	switch (arglex())
X	{
X	default:
X		test_main();
X		break;
X
X	case arglex_token_help:
X		test_help();
X		break;
X
X	case arglex_token_list:
X		test_list();
X		break;
X
X	case arglex_token_independent:
X		test_independent();
X		break;
X	}
X	trace((/*{*/"}\n"));
X}
END_OF_FILE
if test 23376 -ne `wc -c <'aegis/aet.c'`; then
    echo shar: \"'aegis/aet.c'\" unpacked with wrong size!
fi
# end of 'aegis/aet.c'
fi
if test -f 'aux/BUILDING.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aux/BUILDING.man'\"
else
echo shar: Extracting \"'aux/BUILDING.man'\" \(22353 characters\)
sed "s/^X//" >'aux/BUILDING.man' <<'END_OF_FILE'
X'\" t
X.\"	aegis - project change supervisor
X.\"	Copyright (C) 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: source for BUILDING file
X.\"
X.TH build aegis
X.if n .hy 0
X.if n .ad l
X.if n .nr IN 8n
X.SH NAME
Xaegis \- project change supervisor
X.br
X.if t .ds C) \(co
X.if n .ds C) (C)
XCopyright \*(C) 1990, 1991, 1992, 1993 Peter Miller.
X.br
XAll rights reserved.
X.PP
XThe
X.I aegis
Xprogram is distributed under the terms of the
XGNU General Public License.
XSee the LICENSE section, below, for more details.
X.PP
X.B aegis
X(ee.j.iz)
X.I n.,
Xa protection,
Xa defence.
X.SH SPACE REQUIREMENTS
XYou will need up to 10MB to unpack and build the
X.I aegis
Xprogram.
X(This is the worst case seen so far,
Xmost systems have binaries about 60% as big as this,
X6MB is more typical.)
XYour mileage may vary.
X.SH SITE CONFIGURATION
XThe file
X.I common/conf.h
Xneeds to be created to match your site.
XSelect an appropriate file from the
X.I conf
Xdirectory.
XThe files in this directory are named for the various systems
Xencountered to date by the author.
XThe file most closely resembling your system should be copied into the
X.I common/conf.h
Xfile.
XYou can copy it or use a symbolic link;
Xcopying is recommended because you may need to edit.
X.PP
XThe
X.I common/conf.h
Xfile is extensively commented.
XRead the comments and change what you need to.
XPlease read this file carefully.
X.PP
XBe careful in changing the settings if you are using a conf file accurately
Xnamed for your system;
Xaegis exersizes functionality unfamiliar to many.
XThere are known cases where
Xsystems have the necessary facilities,
Xbut they are nowhere documented.
XIf you are unsure,
Xtry it unchanged first,
Xand then edit if you find that there are problems.
X.PP
XAnother file which may require editing is the
X.I Makefile
Xfile.
XThe first few lines contain comments describing what may require changing.
XIn general these changes will relate to the name of your favorite
XC compiler,
Xand where it keeps its include files.
X.PP
XThe top of the
X.I Makefile
Xfile is arranged as macro definitions,
Xwith alternatives for each known system in comments.
XSearch for your system's name,
Xediting the macro definition as required.
X.br
X.ne 1i
X.SH KNOWN SYSTEMS
XThis distribution of
X.I aegis
Xis known to build on the following systems:
X.TP 8n
XSunOS 4.1
X.br
XThe native
X.IR cc (1)
Xand also
X.IR gcc (1)
Xare known to work for Sun4s.
XThe appropriate configuration is contained in the
X.I conf/SunOS-4.1
Xfile.
XSun seem to be having chronic problems with locking;
Xyou may need to get the very latest set of locking patches and apply them.
XSee also the
X.I tmpfs
Xnote, below.
X.TP 8n
XConvexOS 10.0
X.br
XThe native
X.IR cc (1)
Xworks just fine.
XThe appropriate configuration is contained in the
X.I conf/ConvexOS-10
Xfile.
XNote that there is no "bin" user on ConvexOS,
Xso the owner of
X.I aegis "'"
Xlibrary files is "daemon";
Xyou will need to map user and group "bin" to "daemon"
Xin the instructions below.
X.TP 8n
XDG/UX 5.4.1
X.br
XThe native
X.IR cc (1)
Xworks just fine.
XThe appropriate configuration is contained in the
X.I conf/dgux-5.4.1
Xfile.
X.TP 8n
XULTRIX 4.2
X.br
XIt has the seteuid and setegid calls,
Xbut the shell has no functions!
XComplain to your vendor.
XYou will need to change the
X.I SHELL
Xmacro definition in the
X.I Makefile
Xfile to use
X.IR sh5 (1)
Xinstead.
XThe appropriate configuration is contained in the
X.I conf/ULTRIX-4.2
Xfile.
X.TP 8n
XPyramid SMP DC/OSx 1.0-92b023
X.RS 8n
XThis system is pretty horrendous.
XThe native
X.I cc
Xis known to work,
Xbut gives a staggering number of warnings, just ignore them.
X.I Gcc
Xis also known to work, 
Xand gives far fewer stupid warnings.
XThe appropriate configuration is contained in the
X.I conf/dcosx
Xfile.
X.RE
X.TP 8n
XHP-UX A.08.07
X.br
XThe author has been advised that the
X.I aegis
Xprogram works on this system.
XCould another person confirm this, please.
XThe appropriate configuration is contained in the
X.I conf/hpux-8.07
Xfile.
X.TP 8n
XSCO 2.4
X.br
XThe author has been advised that the
X.I aegis
Xprogram works on this system.
XCould another person confirm this, please.
XThe appropriate configuration is contained in the
X.I conf/SCO-2.4
Xfile.
X.TP 8n
XSun Solaris 2.1
X.br
XThe author has been advised that the
X.I aegis
Xprogram works on this system.
XCould another person confirm this, please;
Xand tell the author how they did it,
Xthere seems to be some black magic involved.
XThe appropriate configuration is contained in the
X.I conf/SunOS-5.1
Xfile.
X.TP 8n
XLinux 0.99
X.br
XThe author has been advised that the
X.I aegis
Xprograms works on this system.
XCould another person confirm this, please.
XThe appropriate configuration is contained in the
X.I conf/Linux-0.99
Xfile.
X.TP 8n
XSilicon Graphics IRIX 4.0.5G
X.br
XThe author has been advised that the
X.I aegis
Xprograms works on this system.
XCould another person confirm this, please.
XThe appropriate configuration is contained in the
X.I conf/IRIX-4.0
Xfile.
X.PP
XIf the instructions for any of the above systems do not work,
Xafter you have double-checked everything,
Xthe author would like to know.
X.SH UNKNOWN SYSTEMS
XPlease let the author know of any other systems you get
X.I aegis
Xworking on,
Xand the modifications necessary.
XPlease include the differences to the
X.I Makefile
Xfile,
Xand the whole
X.I common/conf.h
Xfile you used.
XIncluded any other files you edited or added.
XInclude the output of the "uname -rs" command,
Xif your flavour of UNIX has such a command.
X.PP
XWhile the
X.I aegis
Xprogram was developed using gcc,
Xthis is not the default in the
X.I Makefile
Xfile.
XThe code uses ANSI C features without compromising the ability
Xto be compiled on older C compilers.
XFunctions mandated by the ANSI C standard are used,
Xbecause many systems provided them, one way or another.
XPlease let the author know of any others you think should
Xbe added to the
X.I common/ansi.c
Xfile.
X.PP
XYou may need to use some ANSI C header files which the
X.I aegis
Xcode uses,
Xbut which some systems (as yet) fail to provide.
XYou will find lines at the top of the
X.I Makefile
Xfile similar to
X.RS
X.ft CW
XH = -I/usr/include -Ih
X.ft R
X.RE
XChange this to suit your system and your compiler.
XThe "h" directory must be searched last as it is
Xintended to supplement your system,
Xnot replace it.
X.PP
XYou will need to check the include files in the "h" directory
Xto see that they are suitable for your system.
XYou may want to delete any that your system already has.
X.br
X.ne 1i
X.SH BUILDING AEGIS
XAll you should need to do is use the
X.RS
X.ft CW
X.nf
X% make
X\fI\&...lots of output...\fP
X%
X.fi
X.ft R
X.RE
Xcommand and wait.
XWhen this finishes you should see a directory called
X.I bin
Xcontaining two files:
X.I aegis
Xand
X.IR fmtgen .
XThe
X.I fmtgen
Xfile is a program used in constructing
X.I aegis
Xand is not for general consumption.
X.br
X.ne 1i
X.SH OTHER USEFUL SOFTWARE
XBefore describing how to test
X.IR aegis ,
Xyou may need to grab some other free software,
Xbecause the tests require it in some cases,
Xand because it is generally useful in others.
X.TP 8n
X.B cook
X.br
XThis is a dependency maintenance tool (DMT).
XAn example of a well-known DMT is
X.IR make (1),
Xhowever this old faithful is not sufficiently capable
Xto meet the demands placed on it by the
X.IR aegis
Xprogram, but
X.IR cook
Xcertainly is.
XThe
X.I cook
Xpackage is written by the same author as
X.IR aegis .
XThe
X.I cook
Xpackage is necessary for test 11 to pass.
XIt is also used in the documentation.
XThe
X.I cook
Xprogram may be found at the same archive site as the
X.I aegis
Xprogram,
Xand in the same directory.
XThe
X.I cook
Xprogram is available under the terms of the GNU General Public License.
X.TP 8n
XRCS
X.br
XThis is a source control package,
Xand is available from any of the GNU archives.
XThe tests use RCS as the history mechanism,
Xso it is necessary to have RCS
Xfor most of the tests to pass.
X.TP 8n
XGNU diff
X.br
XIf the
X.IR diff (1)
Xutility supplied by your flavor of unix does not have the
X.B -c
Xoption,
Xyou will need GNU diff to make patch files,
Xif you want to publish software for FTP or on USENET.
XContext differences are also helpful for reviewing changes.
X.TP 8n
Xgroff
X.br
XThis GNU software replaces the
Xdocumentation tools which (sometimes)
Xcome with UNIX.
XThey produce superior error messages,
Xand support a wider range of functionality and fonts.
XThe
X.I aegis
XUser Guide was prepared with groff.
X.TP 8n
Xbison
X.br
XThis GNU software is a replacement for
X.IR yacc (1).
XSome systems have very sick yaccs,
Xand this may be necessary if your system include files
Xdisagree strongly with your system's yacc.
XThe
X.I Makefile
Xhas bison setup in comments.
X.TP 8n
Xfhist
X.br
XThis software,
Xavailable under the terms of the GNU General Public License,
Xis a set of file history and comparison utilities.
XIt was originally written by David I. Bell,
Xand is based on the minimal difference algorithm by Eugene W. Myers.
XThis copy is enhanced and maintained by the same author as
X.IR aegis ,
Xand may be found at the same archive site,
Xin the same directory.
X.br
X.ne 1i
X.SH TESTING AEGIS
XThe
X.I aegis
Xprogram comes with a test suite.
XTo run this test suite, use the command
X.RS
X.ft CW
X.nf
X% make sure
X\fI\&...lots of output...\fP
XPassed All Tests
X%
X.fi
X.ft R
X.RE
X.PP
XThe tests take a minute or two each,
Xwith a few very fast,
Xand a couple very slow,
Xbut it varies greatly depending on your CPU.
X.PP
XThe tests assume that the RCS commands "ci", "co", "rlog" and "rcs" are
Xsomewhere in the command search PATH.
X.PP
XThe
X.I test/00/t0011a.sh
Xfile assumes the
X.IR cook (1)
Xcommand by the author is somewhere in the command search path.
XThis test reproduces the example used in Chapter 3 of the User Guide.
X.PP
XIf you are using Sun's
X.I tmpfs
Xfile system as your
X.I /tmp
Xdirectory,
Xthe tests will fail.
XThis is because the
X.I tmpfs
Xfile system does not support file locking.
XSet the
X.I AEGIS_TMP
Xenvironment variable to somewhere else
Xbefore running the tests.
XSomething like
X.RS
X.ft CW
X.nf
X% setenv AEGIS_TMP /usr/tmp
X%
X.fi
X.ft R
X.RE
Xis usually sufficient if you are using C shell, or
X.RS
X.ft CW
X.nf
X$ AEGIS_TMP=/usr/tmp
X$ export AEGIS_TMP
X$
X.fi
X.ft R
X.RE
Xif you are using Bourne shell.
XRemember,
Xthis must be done before running the tests.
X.PP
XIf the tests fail due to errors complaining of "user too privileged"
Xyou will need to adjust the
X.I AEGIS_MIN_UID
Xdefine in the
X.I common/conf.h
Xfile.
XSimilarly for "group too privileged",
Xalthough this is rarer.
XThis error message will also occur if you run the tests as root:
Xthe tests must be run as a mortal each time.
X.br
X.ne 1i
X.SH TESTING SET-UID-ROOT
XIf the
X.I aegis
Xprogram is not set-uid-root then it runs in "test" mode
Xwhich gives you some confidence that
X.I aegis
Xis working before
Xbeing tested again when it is set-uid-root.
XTwo pass testing like this means that you need not trust your system
Xto a set-uid-root program which is not known to work.
X.PP
XYou will need to do a little of the install,
Xto create the directory which will contain
X.IR aegis "'"
Xlock file.
X.RS
X.ft CW
X.nf
X# mkdir /usr/local/lib/aegis
X# chmod 755 /usr/local/lib/aegis
X# chown bin /usr/local/lib/aegis
X# chgrp bin /usr/local/lib/aegis
X#
X.fi
X.ft R
X.RE
XYou will need to change
X.I aegis
Xto be set-uid-root.
XThis may be done with the following commands:
X.RS
X.ft CW
X.nf
X# chown root bin/aegis
X# chmod u+s bin/aegis
X#
X.fi
X.ft R
X.RE
XOnce
X.I aegis
Xis set-uid-root,
Xit is tested again,
Xin the same manner as before.
X.RS
X.nf
X.ft CW
X% make sure
X\fI\&...lots of output...\fP
XPassed All Tests
X%
X.fi
X.ft R
X.RE
X.PP
XYou should test
X.I aegis
Xas a mortal in both passes,
Xrather than as root,
Xto be sure the set-uid-root functionality is working correctly.
X.PP
XIt is required that
X.I aegis
Xrun set-uid-root for all of its functionality to be available.
XIt is
X.if n NOT
X.if t .B not
Xpossible to create an "aegis" account and make
X.I aegis
Xrun set-uid-aegis.
XThis is because
X.I aegis
Xdoes things as various different user IDs,
Xsometimes as many as 3 in the one command.
XThis allows
X.I aegis
Xto use UNIX security
Xrather than inventing its own,
Xand also allows
X.I aegis
Xto work across NFS.
XTo be able to do these things,
X.I aegis
Xmust be set-uid-root.
XBelieve me, folks, if I could have done it without set-uid-root, I would have!
X.br
X.ne 1i
X.SH INSTALLING AEGIS
XPut the
X.I aegis
Xprogram somewhere where users will automatically pick it up,
Xsuch as in the
X.I /usr/local/bin
Xdirectory.
XUse the command
X.RS
X.ft CW
X.nf
X# cp bin/aegis /usr/local/bin
X#
X.fi
X.ft R
X.RE
XDon't forget to make sure that the copy is set-uid-root,
Xsome versions of \fIcp\fP do not transfer the set-uid bit of the mode.
X.PP
XThe manuals can be installed using the commands
X.RS
X.ft CW
X.nf
X# sh man1/install.sh \fI/usr/local/man/man1\fP
X# sh man5/install.sh \fI/usr/local/man/man5\fP
X#
X.fi
X.ft R
X.RE
Xbut this is very site specific.
XYou can select a different path by changing the last argument.
X.PP
XBy default,
X.I aegis
Xis configured to use
X.I /usr/local/lib/aegis
Xas the place it stores the table containing the mapping
Xfrom project name to project directory,
Xand indexes into this table.
XThe
X.I aegis
Xprogram also has example
X.I .cshrc
Xand
X.I .profile
Xfiles,
Xand generic notification scripts.
XThese can be copied to this library as follows:
X.RS
X.ft CW
X.nf
X# mkdir /usr/local/lib/aegis
X# chmod 755 /usr/local/lib/aegis
X# chown bin /usr/local/lib/aegis
X# chgrp bin /usr/local/lib/aegis
X# cp lib/* /usr/local/lib/aegis
X# chmod a+r /usr/local/lib/aegis/*
X# chmod a+x /usr/local/lib/aegis/*.sh
X#
X.fi
X.ft R
X.RE
XThis is only an example,
Xand you may want to place this somewhere else.
XControl of the placement of this directory may be found in the first
Xfew lines of the
X.I Makefile
Xfile.
X.PP
XAll of the above install can be done automatically,
Xusing the "\f(CWmake install\fP" command as root.
XControl of the directories used may be found in the first
Xfew lines of the
X.I Makefile
Xfile.
X.br
X.ne 1i
X.SH USER CONFIGURATION
XThe
X.I aegis
Xcommand is assumed to be in a generally accessible place,
Xotherwise users will need to add the relevant directory to their PATH.
XUsers should add
X.RS
X.ft CW
Xsource /usr/local/lib/aegis/cshrc
X.ft R
X.RE
Xto the end of their
X.I .cshrc
Xfile for the recommended aliases.
X.PP
XThere is also a
X.I profile
Xfor users of the Bourne shell
X(it assumes you have a version of the Bourne shell which has functions).
XUsers should add
X.RS
X.ft CW
X\&. /usr/local/lib/aegis/profile
X.ft R
X.RE
Xto the end of their
X.I .profile
Xfile for the recommended aliases.
X.PP
XThe
X.I /usr/local/lib/aegis/state
Xfile contains pointers to "system" projects.
XUsers may add their own project pointers (to their own projects)
Xby putting a search path into the
X.I AEGIS
Xenvironment variable.
XThe system part is always automatically appended by
X.IR aegis .
XThe default,
Xalready set by the
X.I /usr/local/lib/\%aegis/cshrc
Xfile,
Xis
X.IR $HOME/lib/aegis .
XDo not create this directory,
X.I aegis
Xis finicky and wants to do this itself.
X.PP
XWhere projects reside is completely flexible,
Xbe they system projects or user projects.
XThey are not kept under the
X.I /usr/local/lib/aegis
Xdirectory,
Xthis directory only contains pointers.
X.br
X.ne 1i
X.SH PRINTED MANUALS
XThis distribution contains the sources to
Xall of the documentation for
X.IR aegis .
XThe author used the GNU groff package
Xand a postscript printer to prepare the documentation.
XIf you do not have this software,
Xyou will need to substitute commands appropriate to your site.
X.PP
XTo print copies of the
X.IR README
Xand
X.IR BUILDING
Xfiles,
Xthe following commands may be used
X.RS
X.ft CW
X.nf
X% groff -t -man aux/*.man | lpr
X%
X.fi
X.ft R
X.RE
XThis will produce about 12 pages.
XThe "-t" flag means preprocess with
X.IR tbl (1).
X.PP
XTo print copies of the manual entries,
Xthe following commands may be used
X.RS
X.ft CW
X.nf
X% cd man1
X% groff -s -t -man *.1 | lpr
X% cd ../man5
X% groff -s -t -man *.5 | lpr
X% cd ..
X%
X.fi
X.ft R
X.RE
XThis will produce about 60 pages.
XThe "-s" flag means preprocess with
X.IR soelim (1),
Xand the "-t" flag means preprocess with
X.IR tbl (1).
X.PP
XTo print a copy of the User Guide,
Xthe following commands may be used
X.RS
X.ft CW
X.nf
X% cd doc
X% groff -s -t -p -ms aegis.ms | lpr
X% cd ..
X%
X.fi
X.ft R
X.RE
XThis will produce about 90 pages.
XThe "-s" flag means preprocess with
X.IR soelim (1),
Xthe "-t" flag means preprocess with
X.IR tbl (1),
Xand the "-p" flag means preprocess with
X.IR pic (1).
XAlternatively,
Xyou could get a PostScript copy of the User Guide from the archive site.
X.PP
XPlease note the the User Guide is still in the process of being written.
XSome sections of the User Guide are incomplete.
XFeedback on the form and content of this document would be most welcome.
X.br
X.ne 1i
X.SH TIME SYNCHRONIZATION
XThe
X.I aegis
Xprogram uses time stamps to remember whether various events
Xhave happened and when.
XIf you are using
X.I aegis
Xin a networked environment,
Xtypically a server and dataless workstations,
Xyou need to make absolutely sure that all of the machines agree about the time.
X.PP
XIf possible,
Xuse the time daemon.
XOtherwise,
Xuse
X.IR rdate (8)
Xvia
X.IR cron (8)
Xevery hour or so.
X.SH GETTING HELP
XIf you need assistance with the
X.I aegis
Xprogram,
Xplease do not hesitate to contact the author at
X.RS
XPeter Miller <pmiller@bmr.gov.au>
X.RE
XAny and all feedback is welcome.
X.PP
XWhen reporting problems,
Xplease include the version number
Xgiven by the
X.RS
X.ft CW
X.nf
X% aegis -version
Xaegis version \fIa.b.cccc\fP
X\fI\&...\fP
X%
X.fi
X.ft R
X.RE
Xcommand.
X.SS Runtime Checking
XIn the
X.I common/main.h
Xfile, the is a define of
X.I DEBUG
Xin comments.
XIf the comments are removed,
Xextensive debugging is turned on.
XThis causes some performance loss,
Xbut performs much run-time checking
Xand adds the
X.B -TRace
Xcommand line option.
X.PP
XWhen the
X.B -TRace
Xcommand line option is followed by one or more file names,
Xit turns on execution traces in those source files.
XIt is usually best to place this on the end of the command line
Xso that names of the files to be traced are not confused
Xwith other file names or strings on the command line.
X.SS Problem Reports
XIf you send email to the author,
Xplease include the following information:
X.TP
X1. The type of UNIX
X.br
XThe author will need to know the brand and version of UNIX you are using,
Xor if it is not UNIX but something else.
XThe output of "uname -sr" is usually sufficient (but not all systems have it).
X.TP
X2. The Version Number
X.br
XIn any information you send,
Xplease include the version number
Xreported in the
X.I common/patchlevel.h
Xfile,
Xor \f(CW`aegis -vers`\fP if you can get it to compile.
X.TP
X3. The Archive Site
X.br
XWhen and where you obtained this version of
X.IR aegis .
XIf you tell me nothing else,
Xtell me this (and, hopefully, why you did nothing else).
X.TP
X4. Unpacking
X.br
XDid you have problems unpacking
X.IR aegis ?
XThis probably isn't a problem with the .tar.Z distribution,
Xbut you could have obtained a shar format copy.
X.TP
X5. Building
X.br
XDid you have problems building
X.IR aegis ?
XThis could have been the instructions included,
Xit could have been the Makefile,
Xit could have been problems configuring it,
Xor anything else.
X.TP
X6. Testing, Non-Set-Uid
X.br
XDid you have problems with the tests?
XYou could have had problems running them,
Xor some of them could have failed.
XIf some tests fail but not others,
Xplease let me know
X.I which
Xones failed.
X(The -k option to make can be usful in this case.)
X.TP
X7. Testing, Set-Uid-Root
X.br
XDid you have problems with the tests when
X.I aegis
Xwas set-uid-root?
XYou could have had problems running them,
Xor some of them could have failed.
XIf some tests fail but not others,
Xplease let me know
X.I which
Xones failed,
Xand include the fact that
X.I aegis
Xwas set-uid-root at the time.
X.TP
X8. Installation
X.br
XDid you have problems installing
X.IR aegis ?
XThis could have been the instructions,
Xor anything else.
X.PP
XAt this point it would probably be a very good idea to print out the
Xmanual entries and read them carefully.
XYou will also want to print a copy of the User Guide;
Xif you don't gave groff,
Xthere should be a PostScript copy at the archive site.
XIt is a known flaw that the User Guide is incomplete,
Xit is something the author is working on "at this moment".
X.TP
X9. The Example Project
X.br
XAfter reading the User Guide,
Xit is often useful to manually run through the example in chapter 3.
XYou will need to do more than one change, hopefully several;
Xthe first change is not representative of the system.
XDid you manually do the example?
XDid you find flaws in the User Guide or manual entries?
X.TP
X10. Using Aegis
X.br
XDid you have problems using
X.IR aegis ?
XThis is a whole can of worms.
XIf possible,
Xinclude a shell script similar to the tests which accompany
X.IR aegis ,
Xwhich reproduces the bug.
XExit code 1 on failure (bug),
Xexit code 0 on success (for when bug is fixed).
X.TP
X11. The Source Code
X.br
XDid you read the code?
XDid you write some code?
XIf you read the code and found problems,
Xfixed them,
Xor extended
X.IR aegis ,
Xthese contributions are most welcome.
XI reserve the right to modify or reject such contributions.
X.PP
XThe above list is inclusive,
Xnot exclusive.
XAny and all feedback is greatly appreciated,
Xas is the effort and interest required to produce it.
X.br
X.ne 1i
X.SH LICENSE
XThe
X.I aegis
Xprogram is free software;
Xyou can redistribute it and/or modify
Xit under the terms of the GNU General Public License as published by
Xthe Free Software Foundation;
Xeither version 2 of the License,
Xor (at your option) any later version.
X.PP
XThe
X.I aegis
Xprogram is distributed in the hope that it will be useful,
Xbut WITHOUT ANY WARRANTY;
Xwithout even the implied warranty of MERCHANTABILITY or
XFITNESS FOR A PARTICULAR PURPOSE.
XSee the GNU General Public License for more details.
X.PP
XIt should be in the
X.I LICENSE
Xfile included in this distribution.
X.br
X.ne 1i
X.SH AUTHOR
X.TS
Xtab(;);
Xl l l.
XPeter Miller;UUCP;uunet!munnari!bmr.gov.au!pmiller
X\f(CW/\e/\e*\fR;Internet;pmiller@bmr.gov.au
X.TE
END_OF_FILE
if test 22353 -ne `wc -c <'aux/BUILDING.man'`; then
    echo shar: \"'aux/BUILDING.man'\" unpacked with wrong size!
fi
# end of 'aux/BUILDING.man'
fi
if test -f 'common/str.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/str.c'\"
else
echo shar: Extracting \"'common/str.c'\" \(21462 characters\)
sed "s/^X//" >'common/str.c' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X *
X * MANIFEST: string manipulation functions
X *
X * A literal pool is maintained.  Each string has a reference count.  The
X * string stays in the literal pool for as long as it has a positive
X * reference count.  To determine if a string is already in the literal pool,
X * linear dynamic hashing is used to guarantee an O(1) search.  Making all equal
X * strings the same item in the literal pool means that string equality is
X * a pointer test, and thus very fast.
X */
X
X#include <stddef.h>
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X#include <ctype.h>
X
X#include <error.h>
X#include <mem.h>
X#include <s-v-arg.h>
X#include <str.h>
X
X
X/*
X * maximum conversion width for numbers
X */
X#define MAX_WIDTH 509
X
Xstatic	string_ty	**hash_table;
Xstatic	str_hash_ty	hash_modulus;
Xstatic	str_hash_ty	hash_cutover;
Xstatic	str_hash_ty	hash_cutover_mask;
Xstatic	str_hash_ty	hash_cutover_split_mask;
Xstatic	str_hash_ty	hash_split;
Xstatic	str_hash_ty	hash_load;
Xstatic	int		changed;
X
X#define MAX_HASH_LEN 20
X
X
X/*
X * NAME
X *	hash_generate - hash string to number
X *
X * SYNOPSIS
X *	str_hash_ty hash_generate(char *s, size_t n);
X *
X * DESCRIPTION
X *	The hash_generate function is used to make a number from a string.
X *
X * RETURNS
X *	str_hash_ty - the magic number
X *
X * CAVEAT
X *	Only the last MAX_HASH_LEN characters are used.
X *	It is important that str_hash_ty be unsigned (int or long).
X */
X
Xstatic str_hash_ty hash_generate _((char *, size_t));
X
Xstatic str_hash_ty
Xhash_generate(s, n)
X	char		*s;
X	size_t		n;
X{
X	str_hash_ty	retval;
X
X	if (n > MAX_HASH_LEN)
X	{
X		s += n - MAX_HASH_LEN;
X		n = MAX_HASH_LEN;
X	}
X
X	retval = 0;
X	while (n > 0)
X	{
X		retval = (retval + (retval << 1)) ^ *s++;
X		--n;
X	}
X	return retval;
X}
X
X
X/*
X * NAME
X *	str_initialize - start up string table
X *
X * SYNOPSIS
X *	void str_initialize(void);
X *
X * DESCRIPTION
X *	The str_initialize function is used to create the hash table and
X *	initialize it to empty.
X *
X * RETURNS
X *	void
X *
X * CAVEAT
X *	This function must be called before any other defined in this file.
X */
X
Xvoid
Xstr_initialize()
X{
X	str_hash_ty	j;
X
X	hash_modulus = 1<<8; /* MUST be a power of 2 */
X	hash_cutover = hash_modulus;
X	hash_split = hash_modulus - hash_cutover;
X	hash_cutover_mask = hash_cutover - 1;
X	hash_cutover_split_mask = (hash_cutover * 2) - 1;
X	hash_load = 0;
X	hash_table = (string_ty **)mem_alloc(hash_modulus * sizeof(string_ty *));
X	for (j = 0; j < hash_modulus; ++j)
X		hash_table[j] = 0;
X}
X
X
X/*
X * NAME
X *	split - reduce table loading
X *
X * SYNOPSIS
X *	void split(void);
X *
X * DESCRIPTION
X *	The split function is used to reduce the load factor on the hash table.
X *
X * RETURNS
X *	void
X *
X * CAVEAT
X *	A load factor of about 80% is suggested.
X */
X
Xstatic void split _((void));
X
Xstatic void
Xsplit()
X{
X	string_ty	*p;
X	string_ty	*p2;
X	str_hash_ty	index;
X
X	/*
X	 * get the list to be split across buckets
X	 */
X	p = hash_table[hash_split];
X	hash_table[hash_split] = 0;
X
X	/*
X	 * increase the modulus by one
X	 */
X	hash_modulus++;
X	mem_change_size((char **)&hash_table, hash_modulus * sizeof(string_ty*));
X	hash_table[hash_modulus - 1] = 0;
X	hash_split = hash_modulus - hash_cutover;
X	if (hash_split >= hash_cutover)
X	{
X		hash_cutover = hash_modulus;
X		hash_split = 0;
X		hash_cutover_mask = hash_cutover - 1;
X		hash_cutover_split_mask = (hash_cutover * 2) - 1;
X	}
X
X	/*
X	 * now redistribute the list elements
X	 */
X	while (p)
X	{
X		p2 = p;
X		p = p->str_next;
X
X		index = p2->str_hash & hash_cutover_mask;
X		if (index < hash_split)
X			index = p2->str_hash & hash_cutover_split_mask;
X		p2->str_next = hash_table[index];
X		hash_table[index] = p2;
X	}
X}
X
X
X/*
X * NAME
X *	str_from_c - make string from C string
X *
X * SYNOPSIS
X *	string_ty *str_from_c(char*);
X *
X * DESCRIPTION
X *	The str_from_c function is used to make a string from a null terminated
X *	C string.
X *
X * RETURNS
X *	string_ty* - a pointer to a string in dynamic memory.  Use str_free when
X *	finished with.
X *
X * CAVEAT
X *	The contents of the structure pointed to MUST NOT be altered.
X */
X
Xstring_ty *
Xstr_from_c(s)
X	char		*s;
X{
X	return str_n_from_c(s, strlen(s));
X}
X
X
X/*
X * NAME
X *	str_n_from_c - make string
X *
X * SYNOPSIS
X *	string_ty *str_n_from_c(char *s, size_t n);
X *
X * DESCRIPTION
X *	The str_n_from_c function is used to make a string from an array of
X *	characters.  No null terminator is assumed.
X *
X * RETURNS
X *	string_ty* - a pointer to a string in dynamic memory.  Use str_free when
X *	finished with.
X *
X * CAVEAT
X *	The contents of the structure pointed to MUST NOT be altered.
X */
X
Xstring_ty *
Xstr_n_from_c(s, length)
X	char		*s;
X	size_t		length;
X{
X	str_hash_ty	hash;
X	str_hash_ty	index;
X	string_ty	*p;
X
X	hash = hash_generate(s, length);
X
X	index = hash & hash_cutover_mask;
X	if (index < hash_split)
X		index = hash & hash_cutover_split_mask;
X
X	for (p = hash_table[index]; p; p = p->str_next)
X	{
X		if
X		(
X			p->str_hash == hash
X		&&
X			p->str_length == length
X		&&
X			!memcmp(p->str_text, s, length)
X		)
X		{
X			p->str_references++;
X			return p;
X		}
X	}
X
X	p = (string_ty *)mem_alloc(sizeof(string_ty) + length);
X	p->str_hash = hash;
X	p->str_length = length;
X	p->str_references = 1;
X	p->str_next = hash_table[index];
X	hash_table[index] = p;
X	memcpy(p->str_text, s, length);
X	p->str_text[length] = 0;
X
X	hash_load++;
X	while (hash_load * 10 > hash_modulus * 8)
X		split();
X	++changed;
X	return p;
X}
X
X
X/*
X * NAME
X *	str_copy - make a copy of a string
X *
X * SYNOPSIS
X *	string_ty *str_copy(string_ty *s);
X *
X * DESCRIPTION
X *	The str_copy function is used to make a copy of a string.
X *
X * RETURNS
X *	string_ty* - a pointer to a string in dynamic memory.  Use str_free when
X *	finished with.
X *
X * CAVEAT
X *	The contents of the structure pointed to MUST NOT be altered.
X */
X
Xstring_ty *
Xstr_copy(s)
X	string_ty	*s;
X{
X	s->str_references++;
X	return s;
X}
X
X
X/*
X * NAME
X *	str_free - release a string
X *
X * SYNOPSIS
X *	void str_free(string_ty *s);
X *
X * DESCRIPTION
X *	The str_free function is used to indicate that a string hash been
X *	finished with.
X *
X * RETURNS
X *	void
X *
X * CAVEAT
X *	This is the only way to release strings DO NOT use the free function.
X */
X
Xvoid
Xstr_free(s)
X	string_ty	*s;
X{
X	str_hash_ty	index;
X	string_ty	**spp;
X
X	if (!s)
X		return;
X	if (s->str_references > 1)
X	{
X		s->str_references--;
X		return;
X	}
X	++changed;
X
X	/*
X	 * find the hash bucket it was in,
X	 * and remove it
X	 */
X	index = s->str_hash & hash_cutover_mask;
X	if (index < hash_split)
X		index = s->str_hash & hash_cutover_split_mask;
X	for (spp = &hash_table[index]; *spp; spp = &(*spp)->str_next)
X	{
X		if (*spp == s)
X		{
X			*spp = s->str_next;
X			free(s);
X			--hash_load;
X			return;
X		}
X	}
X
X	/*
X	 * should never reach here!
X	 */
X	fatal("attempted to free non-existent string (bug)");
X}
X
X
X/*
X * NAME
X *	str_catenate - join two strings
X *
X * SYNOPSIS
X *	string_ty *str_catenate(string_ty *, string_ty *);
X *
X * DESCRIPTION
X *	The str_catenate function is used to concatenate two strings to form a
X *	new string.
X *
X * RETURNS
X *	string_ty* - a pointer to a string in dynamic memory.  Use str_free when
X *	finished with.
X *
X * CAVEAT
X *	The contents of the structure pointed to MUST NOT be altered.
X */
X
Xstring_ty *
Xstr_catenate(s1, s2)
X	string_ty	*s1;
X	string_ty	*s2;
X{
X	static char	*tmp;
X	static size_t	tmplen;
X	string_ty	*s;
X	size_t		length;
X
X	length = s1->str_length + s2->str_length;
X	if (!tmp)
X	{
X		tmplen = length;
X		if (tmplen < 16)
X			tmplen = 16;
X		tmp = mem_alloc(tmplen);
X	}
X	else
X	{
X		if (tmplen < length)
X		{
X			tmplen = length;
X			mem_change_size(&tmp, tmplen);
X		}
X	}
X	memcpy(tmp, s1->str_text, s1->str_length);
X	memcpy(tmp + s1->str_length, s2->str_text, s2->str_length);
X	s = str_n_from_c(tmp, length);
X	return s;
X}
X
X
X/*
X * NAME
X *	str_cat_three - join three strings
X *
X * SYNOPSIS
X *	string_ty *str_cat_three(string_ty *, string_ty *, string_ty *);
X *
X * DESCRIPTION
X *	The str_cat_three function is used to concatenate three strings to form
X *	a new string.
X *
X * RETURNS
X *	string_ty* - a pointer to a string in dynamic memory.  Use str_free when
X *	finished with.
X *
X * CAVEAT
X *	The contents of the structure pointed to MUST NOT be altered.
X */
X
Xstring_ty *
Xstr_cat_three(s1, s2, s3)
X	string_ty	*s1;
X	string_ty	*s2;
X	string_ty	*s3;
X{
X	static char	*tmp;
X	static size_t	tmplen;
X	string_ty	*s;
X	size_t		length;
X
X	length = s1->str_length + s2->str_length + s3->str_length;
X	if (!tmp)
X	{
X		tmplen = length;
X		if (tmplen < 16)
X			tmplen = 16;
X		tmp = mem_alloc(tmplen);
X	}
X	else
X	{
X		if (tmplen < length)
X		{
X			tmplen = length;
X			mem_change_size(&tmp, tmplen);
X		}
X	}
X	memcpy(tmp, s1->str_text, s1->str_length);
X	memcpy(tmp + s1->str_length, s2->str_text, s2->str_length);
X	memcpy
X	(
X		tmp + s1->str_length + s2->str_length,
X		s3->str_text,
X		s3->str_length
X	);
X	s = str_n_from_c(tmp, length);
X	return s;
X}
X
X
X/*
X * NAME
X *	str_equal - test equality of strings
X *
X * SYNOPSIS
X *	int str_equal(string_ty *, string_ty *);
X *
X * DESCRIPTION
X *	The str_equal function is used to test if two strings are equal.
X *
X * RETURNS
X *	int; zero if the strings are not equal, nonzero if the strings are
X *	equal.
X *
X * CAVEAT
X *	This function is implemented as a macro in strings.h
X */
X
X#ifndef str_equal
X
Xint
Xstr_equal(s1, s2)
X	string_ty	*s1;
X	string_ty	*s2;
X{
X	return (s1 == s2);
X}
X
X#endif
X
X
X/*
X * NAME
X *	str_upcase - upcase a string
X *
X * SYNOPSIS
X *	string_ty *str_upcase(string_ty *);
X *
X * DESCRIPTION
X *	The str_upcase function is used to form a string which is an upper case
X *	form of the supplied string.
X *
X * RETURNS
X *	string_ty* - a pointer to a string in dynamic memory.  Use str_free when
X *	finished with.
X *
X * CAVEAT
X *	The contents of the structure pointed to MUST NOT be altered.
X */
X
Xstring_ty *
Xstr_upcase(s)
X	string_ty	*s;
X{
X	static char	*tmp;
X	static size_t	tmplen;
X	string_ty	*retval;
X	char		*cp1;
X	char		*cp2;
X
X	if (!tmp)
X	{
X		tmplen = s->str_length;
X		if (tmplen < 16)
X			tmplen = 16;
X		tmp = mem_alloc(tmplen);
X	}
X	else
X	{
X		if (tmplen < s->str_length)
X		{
X			tmplen = s->str_length;
X			mem_change_size(&tmp, tmplen);
X		}
X	}
X	for (cp1 = s->str_text, cp2 = tmp; *cp1; ++cp1, ++cp2)
X	{
X		int c;
X
X		c = *cp1;
X		if (c >= 'a' && c <= 'z')
X			c += 'A' - 'a';
X		*cp2 = c;
X	}
X	retval = str_n_from_c(tmp, s->str_length);
X	return retval;
X}
X
X
X/*
X * NAME
X *	str_downcase - lowercase string
X *
X * SYNOPSIS
X *	string_ty *str_downcase(string_ty *);
X *
X * DESCRIPTION
X *	The str_downcase function is used to form a string which is a lowercase
X *	form of the supplied string.
X *
X * RETURNS
X *	string_ty* - a pointer to a string in dynamic memory.  Use str_free when
X *	finished with.
X *
X * CAVEAT
X *	The contents of the structure pointed to MUST NOT be altered.
X */
X
Xstring_ty *
Xstr_downcase(s)
X	string_ty	*s;
X{
X	static char	*tmp;
X	static size_t	tmplen;
X	string_ty	*retval;
X	char		*cp1;
X	char		*cp2;
X
X	if (!tmp)
X	{
X		tmplen = s->str_length;
X		if (tmplen < 16)
X			tmplen = 16;
X		tmp = mem_alloc(tmplen);
X	}
X	else
X	{
X		if (tmplen < s->str_length)
X		{
X			tmplen = s->str_length;
X			mem_change_size(&tmp, tmplen);
X		}
X	}
X	for (cp1 = s->str_text, cp2 = tmp; *cp1; ++cp1, ++cp2)
X	{
X		int c;
X
X		c = *cp1;
X		if (c >= 'A' && c <= 'Z')
X			c += 'a' - 'A';
X		*cp2 = c;
X	}
X	retval = str_n_from_c(tmp, s->str_length);
X	return retval;
X}
X
X
X/*
X * NAME
X *	str_bool - get boolean value
X *
X * SYNOPSIS
X *	int str_bool(string_ty *s);
X *
X * DESCRIPTION
X *	The str_bool function is used to determine the boolean value of the
X *	given string.  A "false" result is if the string is empty or
X *	0 or blank, and "true" otherwise.
X *
X * RETURNS
X *	int: zero to indicate a "false" result, nonzero to indicate a "true"
X *	result.
X */
X
Xint
Xstr_bool(s)
X	string_ty	*s;
X{
X	char		*cp;
X
X	cp = s->str_text;
X	while (*cp)
X	{
X		if (!isspace(*cp) && *cp != '0')
X			return 1;
X		++cp;
X	}
X	return 0;
X}
X
X
X/*
X * NAME
X *	str_field - extract a field from a string
X *
X * SYNOPSIS
X *	string_ty *str_field(string_ty *, char separator, int field_number);
X *
X * DESCRIPTION
X *	The str_field functipon is used to erxtract a field from a string.
X *	Fields of the string are separated by ``separator'' characters.
X *	Fields are numbered from 0.
X *
X * RETURNS
X *	Asking for a field off the end of the string will result in a null
X *	pointer return.  The null string is considered to have one empty field.
X */
X
Xstring_ty *
Xstr_field(s, sep, fldnum)
X	string_ty	*s;
X	int		sep;
X	int		fldnum;
X{
X	char		*cp;
X	char		*ep;
X
X	cp = s->str_text;
X	while (fldnum > 0)
X	{
X		ep = strchr(cp, sep);
X		if (!ep)
X			return 0;
X		cp = ep + 1;
X		--fldnum;
X	}
X	ep = strchr(cp, sep);
X	if (ep)
X		return str_n_from_c(cp, ep - cp);
X	return str_from_c(cp);
X}
X
X
Xvoid
Xslow_to_fast(in, out, length)
X	char		**in;
X	string_ty	**out;
X	size_t		length;
X{
X	size_t		j;
X
X	if (out[0])
X		return;
X	for (j = 0; j < length; ++j)
X		out[j] = str_from_c(in[j]);
X}
X
X
Xstring_ty *
Xstr_format(fmt sva_last)
X	char		*fmt;
X	sva_last_decl
X{
X	va_list		ap;
X	string_ty	*result;
X
X	sva_init(ap, fmt);
X	result = str_vformat(fmt, ap);
X	va_end(ap);
X	return result;
X}
X
X
Xstatic void build_fake _((char *fake, int flag, int width, int precision,
X	int qualifier, int specifier));
X
Xstatic void
Xbuild_fake(fake, flag, width, precision, qualifier, specifier)
X	char		*fake;
X	int		flag;
X	int		width;
X	int		precision;
X	int		qualifier;
X	int		specifier;
X{
X	char		*fp;
X
X	fp = fake;
X	*fp++ = '%';
X	if (flag)
X		*fp++ = flag;
X	if (width > 0)
X	{
X		sprintf(fp, "%d", width);
X		fp += strlen(fp);
X	}
X	*fp++ = '.';
X	sprintf(fp, "%d", precision);
X	fp += strlen(fp);
X	if (qualifier)
X		*fp++ = qualifier;
X	*fp++ = specifier;
X	*fp = 0;
X}
X
X
Xstring_ty *
Xstr_vformat(fmt, ap)
X	char		*fmt;
X	va_list		ap;
X{
X	size_t		length;
X	static size_t	tmplen;
X	static char	*tmp;
X	int		width;
X	int		width_set;
X	int		prec;
X	int		prec_set;
X	int		c;
X	char		*s;
X	int		qualifier;
X	int		flag;
X	char		fake[100];
X
X	/*
X	 * Build the result string in a temporary buffer.
X	 * Grow the temporary buffer as necessary.
X	 *
X	 * It is important to only make one pass across the variable argument
X	 * list.  Behaviour is undefined for more than one pass.
X	 */
X	if (!tmplen)
X	{
X		tmplen = 500;
X		tmp = mem_alloc(tmplen);
X	}
X	length = 0;
X	s = fmt;
X	while (*s)
X	{
X		c = *s++;
X		if (c != '%')
X		{
X			normal:
X			if (length >= tmplen)
X			{
X				tmplen += 100;
X				mem_change_size(&tmp, tmplen);
X			}
X			tmp[length++] = c;
X			continue;
X		}
X		c = *s++;
X
X		/*
X		 * get optional flag
X		 */
X		switch (c)
X		{
X		case '+':
X		case '-':
X		case '#':
X		case '0':
X		case ' ':
X			flag = c;
X			c = *s++;
X			break;
X
X		default:
X			flag = 0;
X			break;
X		}
X
X		/*
X		 * get optional width
X		 */
X		width = 0;
X		width_set = 0;
X		switch (c)
X		{
X		case '*':
X			width = va_arg(ap, int);
X			if (width < 0)
X			{
X				flag = '-';
X				width = -width;
X			}
X			c = *s++;
X			width_set = 1;
X			break;
X		
X		case '0': case '1': case '2': case '3': case '4':
X		case '5': case '6': case '7': case '8': case '9':
X			for (;;)
X			{
X				width = width * 10 + c - '0';
X				c = *s++;
X				switch (c)
X				{
X				default:
X					break;
X
X				case '0': case '1': case '2': case '3':
X				case '4': case '5': case '6': case '7':
X				case '8': case '9':
X					continue;
X				}
X				break;
X			}
X			width_set = 1;
X			break;
X
X		default:
X			break;
X		}
X
X		/*
X		 * get optional precision
X		 */
X		prec = 0;
X		prec_set = 0;
X		if (c == '.')
X		{
X			c = *s++;
X			switch (c)
X			{
X			default:
X				prec_set = 1;
X				break;
X
X			case '*':
X				c = *s++;
X				prec = va_arg(ap, int);
X				if (prec < 0)
X				{
X					prec = 0;
X					break;
X				}
X				prec_set = 1;
X				break;
X
X			case '0': case '1': case '2': case '3': case '4':
X			case '5': case '6': case '7': case '8': case '9':
X				for (;;)
X				{
X					prec = prec * 10 + c - '0';
X					c = *s++;
X					switch (c)
X					{
X					default:
X						break;
X
X					case '0': case '1': case '2': case '3':
X					case '4': case '5': case '6': case '7':
X					case '8': case '9':
X						continue;
X					}
X					break;
X				}
X				prec_set = 1;
X				break;
X			}
X		}
X
X		/*
X		 * get the optional qualifier
X		 */
X		switch (c)
X		{
X		default:
X			qualifier = 0;
X			break;
X
X		case 'l':
X		case 'h':
X		case 'L':
X			qualifier = c;
X			c = *s++;
X			break;
X		}
X
X		/*
X		 * get conversion specifier
X		 */
X		switch (c)
X		{
X		default:
X			fatal
X			(
X			      "in format string \"%s\", illegal specifier '%c'",
X				fmt,
X				c
X			);
X
X		case '%':
X			goto normal;
X
X		case 'c':
X			{
X				int	a;
X				char	num[MAX_WIDTH + 1];
X				size_t	len;
X
X				a = (unsigned char)va_arg(ap, int);
X				if (!prec_set)
X					prec = 1;
X				if (width > MAX_WIDTH)
X					width = MAX_WIDTH;
X				if (prec > MAX_WIDTH)
X					prec = MAX_WIDTH;
X				build_fake(fake, flag, width, prec, 0, c);
X				sprintf(num, fake, a);
X				len = strlen(num);
X				if (length + len > tmplen)
X				{
X					tmplen += len;
X					mem_change_size(&tmp, tmplen);
X				}
X				memcpy(tmp + length, num, len);
X				length += len;
X			}
X			break;
X
X		case 'd':
X		case 'i':
X			{
X				long	a;
X				char	num[MAX_WIDTH + 1];
X				size_t	len;
X
X				switch (qualifier)
X				{
X				case 'l':
X					a = va_arg(ap, long);
X					break;
X
X				case 'h':
X					a = (short)va_arg(ap, int);
X					break;
X
X				default:
X					a = va_arg(ap, int);
X					break;
X				}
X				if (!prec_set)
X					prec = 1;
X				if (width > MAX_WIDTH)
X					width = MAX_WIDTH;
X				if (prec > MAX_WIDTH)
X					prec = MAX_WIDTH;
X				build_fake(fake, flag, width, prec, 'l', c);
X				sprintf(num, fake, a);
X				len = strlen(num);
X				if (length + len > tmplen)
X				{
X					tmplen += len;
X					mem_change_size(&tmp, tmplen);
X				}
X				memcpy(tmp + length, num, len);
X				length += len;
X			}
X			break;
X
X		case 'e':
X		case 'f':
X		case 'g':
X		case 'E':
X		case 'F':
X		case 'G':
X			{
X				double	a;
X				char	num[MAX_WIDTH + 1];
X				size_t	len;
X
X				/*
X				 * Ignore "long double" for now,
X				 * traditional implementations no grok.
X				 */
X				a = va_arg(ap, double);
X				if (!prec_set)
X					prec = 6;
X				if (width > MAX_WIDTH)
X					width = MAX_WIDTH;
X				if (prec > MAX_WIDTH)
X					prec = MAX_WIDTH;
X				build_fake(fake, flag, width, prec, 0, c);
X				sprintf(num, fake, a);
X				len = strlen(num);
X				if (length + len > tmplen)
X				{
X					tmplen += len;
X					mem_change_size(&tmp, tmplen);
X				}
X				memcpy(tmp + length, num, len);
X				length += len;
X			}
X			break;
X
X		case 'n':
X			switch (qualifier)
X			{
X			case 'l':
X				{
X					long	*a;
X
X					a = va_arg(ap, long *);
X					*a = length;
X				}
X				break;
X
X			case 'h':
X				{
X					short	*a;
X
X					a = va_arg(ap, short *);
X					*a = length;
X				}
X				break;
X
X			default:
X				{
X					int	*a;
X
X					a = va_arg(ap, int *);
X					*a = length;
X				}
X				break;
X			}
X			break;
X
X		case 'u':
X		case 'o':
X		case 'x':
X		case 'X':
X			{
X				unsigned long	a;
X				char		num[MAX_WIDTH + 1];
X				size_t		len;
X
X				switch (qualifier)
X				{
X				case 'l':
X					a = va_arg(ap, unsigned long);
X					break;
X
X				case 'h':
X					a = (unsigned short)va_arg(ap, unsigned int);
X					break;
X
X				default:
X					a = va_arg(ap, unsigned int);
X					break;
X				}
X				if (!prec_set)
X					prec = 1;
X				if (prec > MAX_WIDTH)
X					prec = MAX_WIDTH;
X				if (width > MAX_WIDTH)
X					width = MAX_WIDTH;
X				build_fake(fake, flag, width, prec, 'l', c);
X				sprintf(num, fake, a);
X				len = strlen(num);
X				if (length + len > tmplen)
X				{
X					tmplen += len;
X					mem_change_size(&tmp, tmplen);
X				}
X				memcpy(tmp + length, num, len);
X				length += len;
X			}
X			break;
X
X		case 's':
X			{
X				char	*a;
X				size_t	len;
X
X				a = va_arg(ap, char *);
X				if (prec_set)
X				{
X					char	*ep;
X
X					ep = memchr(a, 0, prec);
X					if (ep)
X						len = ep - a;
X					else
X						len = prec;
X				}
X				else
X					len = strlen(a);
X				if (!prec_set || len < prec)
X					prec = len;
X				if (!width_set || width < prec)
X					width = prec;
X				len = width;
X				if (length + len > tmplen)
X				{
X					tmplen += len;
X					mem_change_size(&tmp, tmplen);
X				}
X				if (flag != '-')
X				{
X					while (width > prec)
X					{
X						tmp[length++] = ' ';
X						width--;
X					}
X				}
X				memcpy(tmp + length, a, prec);
X				length += prec;
X				width -= prec;
X				if (flag == '-')
X				{
X					while (width > 0)
X					{
X						tmp[length++] = ' ';
X						width--;
X					}
X				}
X			}
X			break;
X
X		case 'S':
X			{
X				string_ty	*a;
X				size_t		len;
X
X				a = va_arg(ap, string_ty *);
X				len = a->str_length;
X				if (!prec_set)
X					prec = len;
X				if (len < prec)
X					prec = len;
X				if (!width_set)
X					width = prec;
X				if (width < prec)
X					width = prec;
X				len = width;
X				if (length + len > tmplen)
X				{
X					tmplen += len;
X					mem_change_size(&tmp, tmplen);
X				}
X				if (flag != '-')
X				{
X					while (width > prec)
X					{
X						tmp[length++] = ' ';
X						width--;
X					}
X				}
X				memcpy(tmp + length, a->str_text, prec);
X				length += prec;
X				width -= prec;
X				if (flag == '-')
X				{
X					while (width > 0)
X					{
X						tmp[length++] = ' ';
X						width--;
X					}
X				}
X			}
X			break;
X		}
X	}
X
X	/*
X	 * make the string
X	 */
X	assert(length <= tmplen);
X	return str_n_from_c(tmp, length);
X}
END_OF_FILE
if test 21462 -ne `wc -c <'common/str.c'`; then
    echo shar: \"'common/str.c'\" unpacked with wrong size!
fi
# end of 'common/str.c'
fi
if test -f 'test/00/t0011a.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test/00/t0011a.sh'\"
else
echo shar: Extracting \"'test/00/t0011a.sh'\" \(22322 characters\)
sed "s/^X//" >'test/00/t0011a.sh' <<'END_OF_FILE'
X#! /bin/sh
X#
X#	aegis - project change supervisor
X#	Copyright (C) 1991, 1992, 1993 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: Test documentation example.
X#
X
Xunset AEGIS_PROJECT
Xunset AEGIS_CHANGE
Xumask 022
X
XUSER=${USER:-${LOGNAME:-`whoami`}}
X
XPAGER=cat
Xexport PAGER
XCOLS=65
Xexport COLS
Xwork=${AEGIS_TMP:-/tmp}/$$
X
Xfail()
X{
X	set +x
X	echo FAILED test of documentation example 1>&2
X	find $work -type d -user $USER -exec chmod u+w {} \;
X	rm -rf $work
X	exit 1
X}
Xpass()
X{
X	set +x
X	echo PASSED test of documentation example 1>&2
X	find $work -type d -user $USER -exec chmod u+w {} \;
X	rm -rf $work
X	exit 0
X}
Xtrap "fail" 1 2 3 15
X
X#
X# some variable to make things earier to read
X#
Xworklib=$work/lib
Xworkproj=$work/example.proj
Xworkchan=$work/example.chan
Xtmp=$work/tmp
X
X#
X# echo commands so we can tell what failed
X#
Xset -x
X
X#
X# make the directories
X#
Xmkdir $work
Xif test $? -ne 0 ; then fail; fi
Xhere=`pwd`
Xif test $? -ne 0 ; then fail; fi
X
XAEGIS=$worklib
Xexport AEGIS
XPATH=$here/bin:$PATH
Xexport PATH
XAEGIS_PROJECT=example
Xexport AEGIS_PROJECT
X
X#
X# make a new project
X#
X$here/bin/aegis -newpro example -dir $workproj -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# change project attributes
X#
Xcat > $tmp << 'TheEnd'
Xdescription = "aegis user's guide";
Xdeveloper_may_review = true;
Xdeveloper_may_integrate = true;
Xreviewer_may_integrate = true;
XTheEnd
Xif test $? -ne 0 ; then fail; fi
X
X$here/bin/aegis -proatt $tmp -proj example -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# create a new change
X#
Xcat > $tmp << 'TheEnd'
Xbrief_description = "Place under aegis";
Xdescription = "A simple calculator using native floating point precision.  \
XThe four basic arithmetic operators to be provided, \
Xusing conventional infix notation.  \
XParentheses and negation also required.";
Xcause = internal_enhancement;
XTheEnd
Xif test $? -ne 0 ; then fail; fi
X
X$here/bin/aegis -new_change $tmp -project example -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add a new developer
X#
X$here/bin/aegis -newdev $USER -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# begin development of the change
X#
X$here/bin/aegis -devbeg -l -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -devbeg 1 -dir $workchan -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add the new files to the change
X#
X$here/bin/aegis -new_file $workchan/Howto.cook $workchan/config $workchan/gram.y \
X	$workchan/lex.l $workchan/main.c -nl -v
Xif test $? -ne 0 ; then fail; fi
X
Xcat > $workchan/Howto.cook << 'TheEnd'
Xif [match_mask %1C%2 [version]] then
X{
X	baseline = [collect aegis -cd -bl -p [project]];
X	search_list = . [baseline];
X}
Xchange_files = [collect aegis -l chafil -ter -p [project] -c [change]];
Xproject_files = [collect aegis -l profil -ter -p [project] -c [change]];
Xsource_files = [sort [stringset [project_files] [change_files]]];
Xobj_files =
X	[fromto %.y %.o [match_mask %.y [source_files]]]
X	[fromto %.l %.o [match_mask %.l [source_files]]]
X	[fromto %.c %.o [match_mask %.c [source_files]]]
X	;
X
Xcc = cc;
Xcc_flags = -O;
Xcc_include_flags = ;
X
X%.o: %.c: [collect c_incl -nc -s [prepost "-I" "" [search_list]]
X	[cc_include_flags] [resolve %.c]]
X{
X	if [exists %.o] then
X		rm %.o
X			set clearstat;
X	[cc] [prepost "-I" "" [search_list]] [cc_include_flags] [cc_flags]
X		-c [resolve %.c];
X}
X
X
X/*
X * How to use yacc sources.
X */
Xyacc = yacc;
Xyacc_flags = ;
X
X%.c %.h: %.y
X{
X	if [exists %.list] then
X		rm %.list
X			set clearstat;
X	if [exists y.output] then
X		rm y.output
X			set clearstat;
X	if [exists %.c] then
X		rm %.c
X			set clearstat;
X	if [exists %.h] then
X		rm %.h
X			set clearstat;
X	[yacc] -d [yacc_flags] [resolve %.y];
X	mv y.tab.c %.c;
X	mv y.tab.h %.h;
X	if [exists y.output] then
X		mv y.output %.list
X			set clearstat;
X}
X
X
X/*
X * How to use lex sources.
X */
Xlex = lex;
Xlex_flags = ;
X
X%.c: %.l
X{
X	if [exists %.c] then
X		rm %.c
X			set clearstat;
X	[lex] [lex_flags] [resolve %.l];
X	mv lex.yy.c %.c;
X}
X
X
X/*
X * The default recipe
X */
Xall: example;
X
X/*
X * build the program from the objects
X */
X
Xexample: [obj_files]
X{
X	if [exists [target]] then
X		rm [target]
X			set clearstat;
X	[cc] -o [target] [resolve [obj_files]] -ll -lm;
X}
XTheEnd
Xif test $? -ne 0 ; then fail; fi
X
Xcat > $workchan/config << 'TheEnd'
Xbuild_command = "cook -b ${s Howto.cook} project=$p change=$c version=$v -nl";
Xlink_integration_directory = true;
X
Xhistory_get_command =
X	"co -u'$e' -p $h,v > $o";
Xhistory_create_command =
X	"ci -u -m/dev/null -t/dev/null $i $h,v; rcs -U $h,v";
Xhistory_put_command =
X	"ci -u -m/dev/null -t/dev/null $i $h,v; rcs -U $h,v";
Xhistory_query_command =
X	"rlog -r $h,v | awk '/^head:/ {print $$2}'";
X
Xdiff_command = "set +e; diff $orig $i > $out; test $$? -le 1";
X
Xdiff3_command = "(diff3 -e $mr $orig $i | sed -e '/^w$$/d' -e '/^q$$/d'; \
X	echo '1,$$p' ) | ed - $mr > $out";
XTheEnd
Xif test $? -ne 0 ; then fail; fi
X
Xcat > $workchan/lex.l << 'TheEnd'
X%{
X#include <math.h>
X#include <gram.h>
X%}
X%%
X[0-9]+(\.[0-9]*)?([eE][+-]?[0-9]+)? {
X		yylval.lv_double = atof(yytext);
X		return DOUBLE;
X	}
X[a-z]	{
X		yylval.lv_int = yytext[0] - 'a';
X		return NAME;
X	}
X[ \t]+	;
X\n	|
X.	{ return yytext[0]; }
XTheEnd
Xif test $? -ne 0 ; then fail; fi
X
Xcat > $workchan/gram.y << 'TheEnd'
X%{
X#include <stdio.h>
X%}
X%token DOUBLE
X%token NAME
X%union
X{
X	double	lv_double;
X	int	lv_int;
X};
X
X%type <lv_double> DOUBLE expr
X%type <lv_int> NAME
X%left '+' '-'
X%left '*' '/'
X%right UNARY
X%%
Xexample
X	: /* empty */
X	| example command '\n'
X		{ yyerrflag = 0; fflush(stderr); fflush(stdout); }
X	;
Xcommand
X	: expr
X		{ printf("%g\n", $1); }
X	| error
X	;
Xexpr
X	: DOUBLE
X	| '(' expr ')'
X		{ $$ = $2; }
X	| '-' expr
X		%prec UNARY
X		{ $$ = -$2; }
X	| expr '*' expr
X		{ $$ = $1 * $3; }
X	| expr '/' expr
X		{ $$ = $1 / $3; }
X	| expr '+' expr
X		{ $$ = $1 + $3; }
X	| expr '-' expr
X		{ $$ = $1 - $3; }
X	;
XTheEnd
Xif test $? -ne 0 ; then fail; fi
X
Xcat > $workchan/main.c << 'TheEnd'
X#include <stdio.h>
X
Xvoid
Xusage()
X{
X	fprintf(stderr, "usage: example\n");
X	exit(1);
X}
X
Xvoid
Xmain(argc, argv)
X	int	argc;
X	char	**argv;
X{
X	if (argc != 1)
X		usage();
X	yyparse();
X	exit(0);
X}
X
Xvoid
Xyyerror(s)
X	char	*s;
X{
X	fprintf(stderr, "%s\n", s);
X	exit(1);
X}
XTheEnd
Xif test $? -ne 0 ; then fail; fi
X
X#
X# create a new test
X#
X$here/bin/aegis -nt -v
Xif test $? -ne 0 ; then fail; fi
X
Xsed -e 's/^X//' > $workchan/test/00/t0001a.sh << 'TheEnd'
XX:
XXhere=`pwd`
XXif test $? -ne 0 ; then exit 1; fi
XXtmp=/tmp/$$
XXmkdir $tmp
XXif test $? -ne 0 ; then exit 1; fi
XXcd $tmp
XXif test $? -ne 0 ; then exit 1; fi
XX
XXfail()
XX{
XX	echo SHUZBUTT 1>&2
XX	cd $here
XX	chmod u+w `find $tmp -type d -print`
XX	rm -rf $tmp
XX	exit 1
XX}
XXpass()
XX{
XX	cd $here
XX	chmod u+w `find $tmp -type d -print`
XX	rm -rf $tmp
XX	exit 0
XX}
XXtrap "fail" 1 2 3 15
XX
XXcat > test.in << 'end'
XX1
XX(4 - 2)
XX-(3 - 6)
XX8 * 0.5
XX1.5 / 0.3
XX4.5 + 1.5
XX10.1 - 3.1
XXend
XXif test $? -ne 0 ; then fail; fi
XX
XXcat > test.ok << 'end'
XX1
XX2
XX3
XX4
XX5
XX6
XX7
XXend
XXif test $? -ne 0 ; then fail; fi
XX
XX$here/example < test.in > test.out 2>&1
XXif test $? -ne 0 ; then fail; fi
XX
XXdiff test.ok test.out
XXif test $? -ne 0 ; then fail; fi
XX
XX# it probably worked
XXpass
XTheEnd
Xif test $? -ne 0 ; then fail; fi
X
X#
X# let the clock tick over, so the build will be happy
X#
Xsleep 1
X
X#
X# build the change
X#
X$here/bin/aegis -build -nl -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# difference the change
X#
X$here/bin/aegis -diff -v -nl
Xif test $? -ne 0 ; then fail; fi
X
X#
X# test the change
X#
X$here/bin/aegis -test -nl -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# finish development of the change
X#
X$here/bin/aegis -dev_end -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add a new reviewer
X#
X$here/bin/aegis -newrev $USER -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# pass the review
X#
X$here/bin/aegis -review_pass -list -proj example -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -review_pass -chan 1 -proj example -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add an integrator
X#
X$here/bin/aegis -newint $USER -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# start integrating
X#
X$here/bin/aegis -intbeg -list -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -intbeg 1 -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -list cd -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# integrate build and test
X#
Xsleep 1
X$here/bin/aegis -build -nl -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -test -nl -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# pass the integration
X#
X$here/bin/aegis -intpass -nl -v
Xif test $? -ne 0 ; then fail; fi
X
X# -- 2 -----------------------------------------------------------------
X
X#
X# create the second and subsequent changes
X#
Xcat > $tmp << 'fubar'
Xbrief_description = "file names on command line";
Xdescription = "Optional input and output files may be \
Xspecified on the command line.";
Xcause = internal_bug;
Xfubar
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -new_change $tmp -project example -v
Xif test $? -ne 0 ; then fail; fi
X
Xcat > $tmp << 'fubar'
Xbrief_description = "add powers";
Xdescription = "Enhance the grammar to allow exponentiation.  \
XNo error checking required.";
Xcause = internal_enhancement;
Xfubar
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -new_change $tmp -project example -v
Xif test $? -ne 0 ; then fail; fi
X
Xcat > $tmp << 'fubar'
Xbrief_description = "add variables";
Xdescription = "Enhance the grammar to allow variables.  \
XOnly single letter variable names are required.";
Xcause = internal_enhancement;
Xfubar
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -new_change $tmp -project example -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# begin development of the change
X#
X$here/bin/aegis -devbeg -l -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -devbeg 2 -dir $workchan -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add the new files to the change
X#
X$here/bin/aegis -copy_file $workchan/main.c -nl -v
Xif test $? -ne 0 ; then fail; fi
X
Xcat > $workchan/main.c << 'TheEnd'
X#include <stdio.h>
X
Xvoid
Xusage()
X{
X	fprintf(stderr, "usage: example [ <infile> [ <outfile> ]]\n");
X	exit(1);
X}
X
Xvoid
Xmain(argc, argv)
X	int	argc;
X	char	**argv;
X{
X	char	*in = 0;
X	char	*out = 0;
X	int	j;
X
X	for (j = 1; j < argc; ++j)
X	{
X		char *arg = argv[j];
X		if (arg[0] == '-')
X			usage();
X		if (!in)
X			in = arg;
X		else if (!out)
X			out = arg;
X		else
X			usage();
X	}
X	if (in && !freopen(in, "r", stdin))
X	{
X		perror(in);
X		exit(1);
X	}
X	if (out && !freopen(out, "w", stdout))
X	{
X		perror(out);
X		exit(1);
X	}
X	yyparse();
X	exit(0);
X}
X
Xvoid
Xyyerror(s)
X	char	*s;
X{
X	fprintf(stderr, "%s\n", s);
X	exit(1);
X}
XTheEnd
Xif test $? -ne 0 ; then fail; fi
X
X#
X# create a new test
X#
X$here/bin/aegis -nt -v
Xif test $? -ne 0 ; then fail; fi
X
Xsed -e 's/^X//' > $workchan/test/00/t0002a.sh << 'TheEnd'
XX:
XXhere=`pwd`
XXif test $? -ne 0 ; then exit 1; fi
XXtmp=/tmp/$$
XXmkdir $tmp
XXif test $? -ne 0 ; then exit 1; fi
XXcd $tmp
XXif test $? -ne 0 ; then exit 1; fi
XX
XXfail()
XX{
XX	echo SHUZBUTT 1>&2
XX	cd $here
XX	chmod u+w `find $tmp -type d -print`
XX	rm -rf $tmp
XX	exit 1
XX}
XXpass()
XX{
XX	cd $here
XX	chmod u+w `find $tmp -type d -print`
XX	rm -rf $tmp
XX	exit 0
XX}
XXtrap "fail" 1 2 3 15
XX
XXcat > test.in << 'end'
XX1
XX(4 - 2)
XX-(3 - 6)
XX8 * 0.5
XX1.5 / 0.3
XX4.5 + 1.5
XX10.1 - 3.1
XXend
XXif test $? -ne 0 ; then fail; fi
XX
XXcat > test.ok << 'end'
XX1
XX2
XX3
XX4
XX5
XX6
XX7
XXend
XXif test $? -ne 0 ; then fail; fi
XX
XX$here/example test.in < /dev/null > test.out 2>&1
XXif test $? -ne 0 ; then fail; fi
XX
XXdiff test.ok test.out
XXif test $? -ne 0 ; then fail; fi
XX
XX$here/example test.in test.out.2 < /dev/null
XXif test $? -ne 0 ; then fail; fi
XX
XXdiff test.ok test.out.2
XXif test $? -ne 0 ; then fail; fi
XX
XX# it probably worked
XXpass
XTheEnd
Xif test $? -ne 0 ; then fail; fi
X
X#
X# let the clock tick over, so the build will be happy
X#
Xsleep 1
X
X#
X# build the change
X#
X$here/bin/aegis -build -nl -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# difference the change
X#
X$here/bin/aegis -diff -v -nl
Xif test $? -ne 0 ; then fail; fi
X
X#
X# test the change
X#
X$here/bin/aegis -test -nl -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -test -bl -nl -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -test -reg -nl -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# finish development of the change
X#
X$here/bin/aegis -dev_end -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# pass the review
X#
X$here/bin/aegis -review_pass -list -proj example -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -review_pass -chan 2 -proj example -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# start integrating
X#
X$here/bin/aegis -intbeg -list -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -intbeg 2 -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -list cd -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# integrate build and test
X#
Xsleep 1
X$here/bin/aegis -build -nl -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -test -nl -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -test -bl -nl -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -test -reg -nl -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# pass the integration
X#
X$here/bin/aegis -intpass -nl -v
Xif test $? -ne 0 ; then fail; fi
X
X# --- 3 ----------------------------------------------------------------
X
X#
X# begin development of the change
X#
X$here/bin/aegis -devbeg -l -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -devbeg 3 -dir $workchan.3 -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add the new files to the change
X#
X$here/bin/aegis -copy_file $workchan.3/gram.y -nl -v
Xif test $? -ne 0 ; then fail; fi
X
Xcat > $workchan.3/gram.y << 'TheEnd'
X%{
X#include <stdio.h>
X#include <math.h>
X%}
X%token DOUBLE
X%token NAME
X%union
X{
X	double	lv_double;
X	int	lv_int;
X};
X
X%type <lv_double> DOUBLE expr
X%type <lv_int> NAME
X%left '+' '-'
X%left '*' '/'
X%right '^'
X%right UNARY
X%%
Xexample
X	: /* empty */
X	| example command '\n'
X		{ yyerrflag = 0; fflush(stderr); fflush(stdout); }
X	;
Xcommand
X	: expr
X		{ printf("%g\n", $1); }
X	| error
X	;
Xexpr
X	: DOUBLE
X	| '(' expr ')'
X		{ $$ = $2; }
X	| '-' expr
X		%prec UNARY
X		{ $$ = -$2; }
X	| expr '^' expr
X		{ $$ = pow($1, $3); }
X	| expr '*' expr
X		{ $$ = $1 * $3; }
X	| expr '/' expr
X		{ $$ = $1 / $3; }
X	| expr '+' expr
X		{ $$ = $1 + $3; }
X	| expr '-' expr
X		{ $$ = $1 - $3; }
X	;
XTheEnd
Xif test $? -ne 0 ; then fail; fi
X
X$here/bin/aegis -diff -v -nl
Xif test $? -ne 0 ; then fail; fi
Xcat $workchan.3/gram.y,D
Xif test $? -ne 0 ; then fail; fi
X
X#
X# create a new test
X#
X$here/bin/aegis -nt -v
Xif test $? -ne 0 ; then fail; fi
X
Xsed -e 's/^X//' > $workchan.3/test/00/t0003a.sh << 'TheEnd'
XX:
XXhere=`pwd`
XXif test $? -ne 0 ; then exit 1; fi
XXtmp=/tmp/$$
XXmkdir $tmp
XXif test $? -ne 0 ; then exit 1; fi
XXcd $tmp
XXif test $? -ne 0 ; then exit 1; fi
XX
XXfail()
XX{
XX	echo SHUZBUTT 1>&2
XX	cd $here
XX	chmod u+w `find $tmp -type d -print`
XX	rm -rf $tmp
XX	exit 1
XX}
XXpass()
XX{
XX	cd $here
XX	chmod u+w `find $tmp -type d -print`
XX	rm -rf $tmp
XX	exit 0
XX}
XXtrap "fail" 1 2 3 15
XX
XXcat > test.in << 'end'
XX5.3 ^ 0
XX4 ^ 0.5
XX27 ^ (1/3)
XXend
XXif test $? -ne 0 ; then fail; fi
XX
XXcat > test.ok << 'end'
XX1
XX2
XX3
XXend
XXif test $? -ne 0 ; then fail; fi
XX
XX$here/example test.in < /dev/null > test.out 2>&1
XXif test $? -ne 0 ; then fail; fi
XX
XXdiff test.ok test.out
XXif test $? -ne 0 ; then fail; fi
XX
XX$here/example test.in test.out.2 < /dev/null
XXif test $? -ne 0 ; then fail; fi
XX
XXdiff test.ok test.out.2
XXif test $? -ne 0 ; then fail; fi
XX
XX# it probably worked
XXpass
XTheEnd
Xif test $? -ne 0 ; then fail; fi
X
X#
X# let the clock tick over, so the build will be happy
X#
Xsleep 1
X
X#
X# build the change
X#
X$here/bin/aegis -build -nl -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# difference the change
X#
X$here/bin/aegis -diff -v -nl
Xif test $? -ne 0 ; then fail; fi
X
X#
X# test the change
X#
X$here/bin/aegis -test -nl -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -test -bl -nl -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -test -reg -nl -v
Xif test $? -ne 0 ; then fail; fi
X
X# --- 4 interrupts 3 ---------------------------------------------------
X
X#
X# begin development of the change
X#
X$here/bin/aegis -devbeg -l -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -devbeg 4 -dir $workchan.4 -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -l cd -v -c 4
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add the new files to the change
X#
X$here/bin/aegis -copy_file $workchan.4/gram.y -nl -v -c 4
Xif test $? -ne 0 ; then fail; fi
X
Xcat > $workchan.4/gram.y << 'TheEnd'
X%{
X#include <stdio.h>
X%}
X%token DOUBLE
X%token NAME
X%union
X{
X	double	lv_double;
X	int	lv_int;
X};
X
X%type <lv_double> DOUBLE expr
X%type <lv_int> NAME
X%left '+' '-'
X%left '*' '/'
X%right UNARY
X%%
Xexample
X	: /* empty */
X	| example command '\n'
X		{ yyerrflag = 0; fflush(stderr); fflush(stdout); }
X	;
Xcommand
X	: expr
X		{ printf("%g\n", $1); }
X	| NAME '=' expr
X		{ assign($1, $3); }
X	| error
X	;
Xexpr
X	: DOUBLE
X	| NAME
X		{ extern double recall(); $$ = recall($1); }
X	| '(' expr ')'
X		{ $$ = $2; }
X	| '-' expr
X		%prec UNARY
X		{ $$ = -$2; }
X	| expr '*' expr
X		{ $$ = $1 * $3; }
X	| expr '/' expr
X		{ $$ = $1 / $3; }
X	| expr '+' expr
X		{ $$ = $1 + $3; }
X	| expr '-' expr
X		{ $$ = $1 - $3; }
X	;
XTheEnd
Xif test $? -ne 0 ; then fail; fi
X
X$here/bin/aegis -new_file $workchan.4/var.c -nl -v -c 4
Xif test $? -ne 0 ; then fail; fi
X
Xcat > $workchan.4/var.c << 'TheEnd'
Xstatic double memory[26];
X
Xvoid
Xassign(name, value)
X	int	name;
X	double	value;
X{
X	memory[name] = value;
X}
X
Xdouble
Xrecall(name)
X	int	name;
X{
X	return memory[name];
X}
XTheEnd
Xif test $? -ne 0 ; then fail; fi
X
X#
X# create a new test
X#
X$here/bin/aegis -nt -v -c 4
Xif test $? -ne 0 ; then fail; fi
X
Xsed -e 's/^X//' > $workchan.4/test/00/t0004a.sh << 'TheEnd'
XX:
XXhere=`pwd`
XXif test $? -ne 0 ; then exit 1; fi
XXtmp=/tmp/$$
XXmkdir $tmp
XXif test $? -ne 0 ; then exit 1; fi
XXcd $tmp
XXif test $? -ne 0 ; then exit 1; fi
XX
XXfail()
XX{
XX	echo SHUZBUTT 1>&2
XX	cd $here
XX	chmod u+w `find $tmp -type d -print`
XX	rm -rf $tmp
XX	exit 1
XX}
XXpass()
XX{
XX	cd $here
XX	chmod u+w `find $tmp -type d -print`
XX	rm -rf $tmp
XX	exit 0
XX}
XXtrap "fail" 1 2 3 15
XX
XXcat > test.in << 'end'
XXa = 1
XXa + 1
XXc = a * 40 + 5
XXc / (a + 4)
XXend
XXif test $? -ne 0 ; then fail; fi
XX
XXcat > test.ok << 'end'
XX2
XX9
XXend
XXif test $? -ne 0 ; then fail; fi
XX
XX$here/example test.in < /dev/null > test.out 2>&1
XXif test $? -ne 0 ; then fail; fi
XX
XXdiff test.ok test.out
XXif test $? -ne 0 ; then fail; fi
XX
XX$here/example test.in test.out.2 < /dev/null
XXif test $? -ne 0 ; then fail; fi
XX
XXdiff test.ok test.out.2
XXif test $? -ne 0 ; then fail; fi
XX
XX# it probably worked
XXpass
XTheEnd
Xif test $? -ne 0 ; then fail; fi
X
X#
X# let the clock tick over, so the build will be happy
X#
Xsleep 1
X
X#
X# build the change
X#
X$here/bin/aegis -build -nl -v -c 4
Xif test $? -ne 0 ; then fail; fi
X
X#
X# difference the change
X#
X$here/bin/aegis -diff -v -nl -c 4
Xif test $? -ne 0 ; then fail; fi
Xcat $workchan.4/gram.y,D
Xif test $? -ne 0 ; then fail; fi
X
X#
X# test the change
X#
X$here/bin/aegis -test -nl -v -c 4
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -test -bl -nl -v -c 4
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -test -reg -nl -v -c 4
Xif test $? -ne 0 ; then fail; fi
X
X#
X# finish development of the change
X#
X$here/bin/aegis -dev_end -v -c 4
Xif test $? -ne 0 ; then fail; fi
X
X#
X# pass the review
X#
X$here/bin/aegis -review_pass -list -proj example -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -review_pass -chan 4 -proj example -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# start integrating
X#
X$here/bin/aegis -intbeg -list -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -intbeg 4 -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -list cd -v -c 4
Xif test $? -ne 0 ; then fail; fi
X
X#
X# integrate build and test
X#
Xsleep 1
X$here/bin/aegis -build -nl -v -c 4
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -test -nl -v -c 4
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -test -bl -nl -v -c 4
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -test -reg -nl -v -c 4
Xif test $? -ne 0 ; then fail; fi
X
X#
X# pass the integration
X#
X$here/bin/aegis -intpass -nl -v -c 4
Xif test $? -ne 0 ; then fail; fi
X
X# --- 3, again ---------------------------------------------------------
X
X#
X# finish development of the change
X#
X$here/bin/aegis -dev_end -v -c 3
Xif test $? -ne 1 ; then fail; fi
X
X#
X# need a new difference
X#
X$here/bin/aegis -diff -nl -v -c 3
Xif test $? -ne 0 ; then fail; fi
X
X#
X# look at the merge file
X#
Xcat $workchan.3/gram.y,D
Xif test $? -ne 0 ; then fail; fi
Xmv $workchan.3/gram.y,D $workchan.3/gram.y
Xif test $? -ne 0 ; then fail; fi
X
X#
X# need a new build
X#
Xsleep 1
X$here/bin/aegis -build -nl -v -c 3
Xif test $? -ne 0 ; then fail; fi
X
X#
X# test it again
X#
X$here/bin/aegis -test -nl -v -c 3
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -test -bl -nl -v -c 3
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -test -reg -nl -v -c 3
Xif test $? -ne 0 ; then fail; fi
X
X#
X# try to finish development of the change
X#
X$here/bin/aegis -dev_end -v -c 3
Xif test $? -ne 1 ; then fail; fi
X
X#
X# diff again
X#
X$here/bin/aegis -diff -nl -v -c 3
Xif test $? -ne 0 ; then fail; fi
X
X#
X# finish development of the change
X#
X$here/bin/aegis -dev_end -v -c 3
Xif test $? -ne 0 ; then fail; fi
X
X#
X# pass the review
X#
X$here/bin/aegis -review_pass -list -proj example -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -review_pass -chan 3 -proj example -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# start integrating
X#
X$here/bin/aegis -intbeg -list -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -intbeg 3 -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -list cd -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# integrate build and test
X#
Xsleep 1
X$here/bin/aegis -build -nl -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -test -nl -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -test -bl -nl -v
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -test -reg -nl -v
Xif test $? -ne 0 ; then fail; fi
X
X#
X# pass the integration
X#
X$here/bin/aegis -intpass -nl -v
Xif test $? -ne 0 ; then fail; fi
X
X# ----------------------------------------------------------------------
X
X#
X# the things tested in this test, worked
X# the things not tested in this test, may or may not work
X#
Xpass
END_OF_FILE
if test 22322 -ne `wc -c <'test/00/t0011a.sh'`; then
    echo shar: \"'test/00/t0011a.sh'\" unpacked with wrong size!
fi
# end of 'test/00/t0011a.sh'
fi
echo shar: End of archive 12 \(of 19\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 19 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
