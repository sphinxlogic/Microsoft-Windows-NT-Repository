Newsgroups: comp.sources.unix
From: pmiller@bmr.gov.au (Peter Miller)
Subject: v27i043: aegis - project change supervisor (V2.1), Part08/19
References: <1.748951883.12788@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: pmiller@bmr.gov.au (Peter Miller)
Posting-Number: Volume 27, Issue 43
Archive-Name: aegis-2.1/part08

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 8 (of 19)."
# Contents:  aegis/aedbu.c aegis/aedeu.c aegis/aenpr.c aegis/aent.c
#   aegis/aentu.c aux/Howto.cook aux/README.man common/ansi.c
#   common/error.c config doc/cA.0.so fmtgen/type_struc.c
# Wrapped by vixie@gw.home.vix.com on Sat Sep 25 03:00:39 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'aegis/aedbu.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aegis/aedbu.c'\"
else
echo shar: Extracting \"'aegis/aedbu.c'\" \(10732 characters\)
sed "s/^X//" >'aegis/aedbu.c' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to implement develop begin undo
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X#include <time.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X
X#include <aedbu.h>
X#include <ael.h>
X#include <arglex2.h>
X#include <change.h>
X#include <col.h>
X#include <commit.h>
X#include <common.h>
X#include <dir.h>
X#include <error.h>
X#include <help.h>
X#include <lock.h>
X#include <option.h>
X#include <os.h>
X#include <project.h>
X#include <sub.h>
X#include <trace.h>
X#include <undo.h>
X#include <user.h>
X
X
Xstatic void develop_begin_undo_usage _((void));
X
Xstatic void
Xdevelop_begin_undo_usage()
X{
X	char		*progname;
X
X	progname = option_progname_get();
X	fprintf(stderr, "usage: %s -Develop_Begin_Undo <change_number> [ <option>... ]\n", progname);
X	fprintf(stderr, "       %s -Develop_Begin_Undo -List [ <option>... ]\n", progname);
X	fprintf(stderr, "       %s -Develop_Begin_Undo -Help\n", progname);
X	quit(1);
X}
X
X
Xstatic void develop_begin_undo_help _((void));
X
Xstatic void
Xdevelop_begin_undo_help()
X{
X	static char *text[] =
X	{
X"NAME",
X"	%s -Develop_Begin_Undo - undo the effects of aedb",
X"",
X"SYNOPSIS",
X"	%s -Develop_Begin_Undo <change-number> [ <option>... ]",
X"	%s -Develop_Begin_Undo -List [ <option>... ]",
X"	%s -Develop_Begin_Undo -Help",
X"",
X"DESCRIPTION",
X"	The %s -Develop_Begin_Undo command is used to reverse",
X"	the effects of the '%s -Develop_Begin' command.",
X"",
X"OPTIONS",
X"	The following options are understood:",
X"",
X"	-Change <number>",
X"		This option may be used to specify a particular",
X"		change within a project.  When no -Change option is",
X"		specified, the AEGIS_CHANGE environment variable is",
X"		consulted.  If that does not exist, the user's",
X"		$HOME/.aegisrc file is examined for a default change",
X"		field (see aeuconf(5) for more information).  If",
X"		that does not exist, when the user is only working",
X"		on one change within a project, that is the default",
X"		change number.  Otherwise, it is an error.",
X"",
X"	-Help",
X"		This option may be used to obtain more",
X"		information about how to use the %s program.",
X"",
X"	-Keep",
X"		This option may be used to retain files and/or",
X"		directories usually deleted by the command.",
X"",
X"	-List",
X"		This option may be used to obtain a list of",
X"		suitable subjects for this command.  The list may",
X"		be more general than expected.",
X"",
X"	-Project <name>",
X"		This option may be used to select the project of",
X"		interest.  When no -Project option is specified, the",
X"		AEGIS_PROJECT environment variable is consulted.  If",
X"		that does not exist, the user's $HOME/.aegisrc file",
X"		is examined for a default project field (see",
X"		aeuconf(5) for more information).  If that does not",
X"		exist, when the user is only working on changes",
X"		within a single project, the project name defaults",
X"		to that project.  Otherwise, it is an error.",
X"",
X"	-TERse",
X"		This option may be used to cause listings to",
X"		produce the bare minimum of information.  It is",
X"		usually useful for shell scripts.",
X"",
X"	-Verbose",
X"		This option may be used to cause %s to produce",
X"		more output.  By default %s only produces",
X"		output on errors.  When used with the -List",
X"		option this option causes column headings to be",
X"		added.",
X"",
X"	All options may be abbreviated; the abbreviation is",
X"	documented as the upper case letters, all lower case",
X"	letters and underscores (_) are optional.  You must use",
X"	consecutive sequences of optional letters.",
X"",
X"	All options are case insensitive, you may type them in",
X"	upper case or lower case or a combination of both, case",
X"	is not important.",
X"",
X"	For example: the arguments \"-project, \"-PROJ\" and \"-p\"",
X"	are all interpreted to mean the -Project option.  The",
X"	argument \"-prj\" will not be understood, because",
X"	consecutive optional characters were not supplied.",
X"",
X"	Options and other command line arguments may be mixed",
X"	arbitrarily on the command line, after the function",
X"	selectors.",
X"",
X"	The GNU long option names are understood.  Since all",
X"	option names for aegis are long, this means ignoring the",
X"	extra leading '-'.  The \"--option=value\" convention is",
X"	also understood.",
X"",
X"RECOMMENDED ALIAS",
X"	The recommended alias for this command is",
X"	csh%%	alias aedbu '%s -dbu \\!* -v'",
X"	sh$	aedbu(){%s -dbu $* -v}",
X"",
X"ERRORS",
X"	It is an error if the change is no assigned to the",
X"	current user.",
X"	It is an error if the change is not in the",
X"	'being_developed' state.",
X"",
X"EXIT STATUS",
X"	The %s command will exit with a status of 1 on any",
X"	error.	The %s command will only exit with a status of",
X"	0 if there are no errors.",
X"",
X"COPYRIGHT",
X"	%C",
X"",
X"AUTHOR",
X"	%A",
X	};
X
X	help(text, SIZEOF(text), develop_begin_undo_usage);
X}
X
X
Xstatic void develop_begin_undo_list _((void));
X
Xstatic void
Xdevelop_begin_undo_list()
X{
X	string_ty	*project_name;
X
X	trace(("develop_begin_undo_list()\n{\n"/*}*/));
X	project_name = 0;
X	arglex();
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch (arglex_token)
X		{
X		default:
X			generic_argument(develop_begin_undo_usage);
X			continue;
X
X		case arglex_token_project:
X			if (arglex() != arglex_token_string)
X				develop_begin_undo_usage();
X			/* fall through... */
X		
X		case arglex_token_string:
X			if (project_name)
X				fatal("duplicate -Project option");
X			project_name = str_from_c(arglex_value.alv_string);
X			break;
X		}
X		arglex();
X	}
X	list_changes_in_state_mask
X	(
X		project_name,
X		1 << cstate_state_being_developed
X	);
X	if (project_name)
X		str_free(project_name);
X	trace((/*{*/"}\n"));
X}
X
X
Xstatic void develop_begin_undo_main _((void));
X
Xstatic void
Xdevelop_begin_undo_main()
X{
X	string_ty	*project_name;
X	long		change_number;
X	int		keep;
X	project_ty	*pp;
X	user_ty		*up;
X	change_ty	*cp;
X	pstate		pstate_data;
X	cstate		cstate_data;
X	cstate_history	history_data;
X
X	trace(("develop_begin_undo_main()\n{\n"/*}*/));
X	project_name = 0;
X	change_number = 0;
X	keep = 0;
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch (arglex_token)
X		{
X		default:
X			generic_argument(develop_begin_undo_usage);
X			continue;
X
X		case arglex_token_keep:
X			if (keep)
X			{
X				fatal
X				(
X					"duplicate %s option",
X					arglex_value.alv_string
X				);
X			}
X			keep++;
X			break;
X
X		case arglex_token_change:
X			if (arglex() != arglex_token_number)
X				develop_begin_undo_usage();
X			/* fall through... */
X
X		case arglex_token_number:
X			if (change_number)
X				fatal("duplicate -Change option");
X			change_number = arglex_value.alv_number;
X			if (change_number < 1)
X				fatal("change %ld out of range", change_number);
X			break;
X
X		case arglex_token_project:
X			if (arglex() != arglex_token_string)
X				develop_begin_undo_usage();
X			/* fall through... */
X		
X		case arglex_token_string:
X			if (project_name)
X				fatal("duplicate -Project option");
X			project_name = str_from_c(arglex_value.alv_string);
X			break;
X		}
X		arglex();
X	}
X
X	/*
X	 * locate project data
X	 */
X	if (!project_name)
X		project_name = user_default_project();
X	pp = project_alloc(project_name);
X	str_free(project_name);
X	project_bind_existing(pp);
X
X	/*
X	 * locate user data
X	 */
X	up = user_executing(pp);
X
X	/*
X	 * locate change data
X	 */
X	if (!change_number)
X		change_number = user_default_change(up);
X	cp = change_alloc(pp, change_number);
X	change_bind_existing(cp);
X
X	/*
X	 * Take an advisory write lock on the appropriate row of the change
X	 * table.  Take an advisory write lock on the appropriate row of the
X	 * user table.  Block until can get both simultaneously.
X	 */
X	project_pstate_lock_prepare(pp);
X	change_cstate_lock_prepare(cp);
X	user_ustate_lock_prepare(up);
X	lock_take();
X	cstate_data = change_cstate_get(cp);
X	pstate_data = project_pstate_get(pp);
X
X	/*
X	 * It is an error if the change is not in the being developed state.
X	 * It is an error if the change is not assigned to the current user.
X	 */
X	if (cstate_data->state != cstate_state_being_developed)
X		change_fatal(cp, "not in 'being_developed' state");
X	if (!str_equal(change_developer_name(cp), user_name(up)))
X	{
X		change_fatal
X		(
X			cp,
X			"user \"%S\" is not the developer",
X			user_name(up)
X		);
X	}
X
X	/*
X	 * add to history for state change
X	 */
X	history_data = change_history_new(cp, up);
X	history_data->what = cstate_history_what_develop_begin_undo;
X
X	/*
X	 * Send the change to the awaiting-development state.
X	 * Clear the build-time field.
X	 * Clear the test-time field.
X	 * Clear the test-baseline-time field.
X	 * Clear the src field.
X	 */
X	cstate_data->state = cstate_state_awaiting_development;
X	cstate_data->build_time = 0;
X	cstate_data->test_time = 0;
X	cstate_data->test_baseline_time = 0;
X	cstate_data->regression_test_time = 0;
X	while (cstate_data->src->length)
X		change_src_remove(cp, cstate_data->src->list[0]->file_name);
X
X	/*
X	 * Remove the change from the list of assigned changes in the user
X	 * change table (in the user row).
X	 */
X	user_own_remove(up, project_name_get(pp), change_number);
X
X	/*
X	 * remove the development directory
X	 */
X	if (!keep)
X	{
X		string_ty	*dd;
X
X		change_verbose(cp, "remove development directory");
X		dd = change_development_directory_get(cp, 1);
X		change_become(cp);
X		commit_rmdir_tree_errok(dd);
X		change_become_undo();
X	}
X
X	/*
X	 * clear development directory field
X	 */
X	change_development_directory_clear(cp);
X
X	/*
X	 * Write the change table row.
X	 * Write the user table row.
X	 * Release advisory locks.
X	 */
X	change_cstate_write(cp);
X	project_pstate_write(pp);
X	user_ustate_write(up);
X	commit();
X	lock_release();
X
X	/*
X	 * verbose success message
X	 */
X	change_verbose(cp, "no longer being developed");
X	change_free(cp);
X	project_free(pp);
X	user_free(up);
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xdevelop_begin_undo()
X{
X	trace(("develop_begin_undo()\n{\n"/*}*/));
X	switch (arglex())
X	{
X	default:
X		develop_begin_undo_main();
X		break;
X
X	case arglex_token_help:
X		develop_begin_undo_help();
X		break;
X
X	case arglex_token_list:
X		develop_begin_undo_list();
X		break;
X	}
X	trace((/*{*/"}\n"));
X}
END_OF_FILE
if test 10732 -ne `wc -c <'aegis/aedbu.c'`; then
    echo shar: \"'aegis/aedbu.c'\" unpacked with wrong size!
fi
# end of 'aegis/aedbu.c'
fi
if test -f 'aegis/aedeu.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aegis/aedeu.c'\"
else
echo shar: Extracting \"'aegis/aedeu.c'\" \(11307 characters\)
sed "s/^X//" >'aegis/aedeu.c' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to implement develop end undo
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X#include <time.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X
X#include <aedeu.h>
X#include <ael.h>
X#include <arglex2.h>
X#include <change.h>
X#include <col.h>
X#include <commit.h>
X#include <common.h>
X#include <dir.h>
X#include <error.h>
X#include <help.h>
X#include <lock.h>
X#include <option.h>
X#include <os.h>
X#include <project.h>
X#include <sub.h>
X#include <trace.h>
X#include <undo.h>
X#include <user.h>
X
X
Xstatic void develop_end_undo_usage _((void));
X
Xstatic void
Xdevelop_end_undo_usage()
X{
X	char		*progname;
X
X	progname = option_progname_get();
X	fprintf(stderr, "usage: %s -Undo_Develop_End [ <option>... ]\n", progname);
X	fprintf(stderr, "       %s -Undo_Develop_End -List [ <option>... ]\n", progname);
X	fprintf(stderr, "       %s -Undo_Develop_End -Help\n", progname);
X	quit(1);
X}
X
X
Xstatic void develop_end_undo_help _((void));
X
Xstatic void
Xdevelop_end_undo_help()
X{
X	static char *text[] =
X	{
X"NAME",
X"	%s -Develop_End_Undo - recall a change for further",
X"	development",
X"",
X"SYNOPSIS",
X"	%s -Develop_End_Undo <change-number> [ <option>... ]",
X"	%s -Develop_End_Undo -List [ <option>... ]",
X"	%s -Develop_End_Undo -Help",
X"",
X"DESCRIPTION",
X"	The %s -Develop_End_Undo command is used to recall a",
X"	change for further development.",
X"",
X"	Successful execution of this command returns the change",
X"	to the 'being_developed' state.",
X"",
X"	The files are changed back to being owned by the current",
X"	user, and cease to be read-only.",
X"",
X"OPTIONS",
X"	The following options are understood:",
X"",
X"	-Change <number>",
X"		This option may be used to specify a particular",
X"		change within a project.  When no -Change option is",
X"		specified, the AEGIS_CHANGE environment variable is",
X"		consulted.  If that does not exist, the user's",
X"		$HOME/.aegisrc file is examined for a default change",
X"		field (see aeuconf(5) for more information).  If",
X"		that does not exist, when the user is only working",
X"		on one change within a project, that is the default",
X"		change number.  Otherwise, it is an error.",
X"",
X"	-Help",
X"		This option may be used to obtain more",
X"		information about how to use the %s program.",
X"",
X"	-List",
X"		This option may be used to obtain a list of",
X"		suitable subjects for this command.  The list may",
X"		be more general than expected.",
X"",
X"	-Project <name>",
X"		This option may be used to select the project of",
X"		interest.  When no -Project option is specified, the",
X"		AEGIS_PROJECT environment variable is consulted.  If",
X"		that does not exist, the user's $HOME/.aegisrc file",
X"		is examined for a default project field (see",
X"		aeuconf(5) for more information).  If that does not",
X"		exist, when the user is only working on changes",
X"		within a single project, the project name defaults",
X"		to that project.  Otherwise, it is an error.",
X"",
X"	-TERse",
X"		This option may be used to cause listings to",
X"		produce the bare minimum of information.  It is",
X"		usually useful for shell scripts.",
X"",
X"	-Verbose",
X"		This option may be used to cause %s to produce",
X"		more output.  By default %s only produces",
X"		output on errors.  When used with the -List",
X"		option this option causes column headings to be",
X"		added.",
X"",
X"	All options are case insensitive.  Options may be",
X"	abbreviated; the abbreviation is the upper case letters.",
X"	Options and other command line arguments may be mixed",
X"	arbitrarily on the command line.",
X"",
X"RECOMMENDED ALIAS",
X"	The recommended alias for this command is",
X"	csh%%	alias aedeu '%s -deu \\!* -v'",
X"	sh$	aedeu(){%s -deu $* -v}",
X"",
X"ERRORS",
X"	It is an error if the change is not in one of the",
X"	'being_reviewed' or 'awaiting_integration' states.",
X"	It is an error if the change was not developed by the",
X"	current user.",
X"",
X"EXIT STATUS",
X"	The %s command will exit with a status of 1 on any",
X"	error.	The %s command will only exit with a status of",
X"	0 if there are no errors.",
X"",
X"COPYRIGHT",
X"	%C",
X"",
X"AUTHOR",
X"	%A",
X	};
X
X	help(text, SIZEOF(text), develop_end_undo_usage);
X}
X
X
Xstatic void develop_end_undo_list _((void));
X
Xstatic void
Xdevelop_end_undo_list()
X{
X	string_ty	*project_name;
X
X	trace(("develop_end_undo_list()\n{\n"/*}*/));
X	project_name = 0;
X	arglex();
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch (arglex_token)
X		{
X		default:
X			generic_argument(develop_end_undo_usage);
X			continue;
X
X		case arglex_token_project:
X			if (arglex() != arglex_token_string)
X				develop_end_undo_usage();
X			/* fall through... */
X		
X		case arglex_token_string:
X			if (project_name)
X				fatal("duplicate -Project option");
X			project_name = str_from_c(arglex_value.alv_string);
X			break;
X		}
X		arglex();
X	}
X	list_changes_in_state_mask
X	(
X		project_name,
X		(
X			(1 << cstate_state_being_reviewed)
X		|
X			(1 << cstate_state_awaiting_integration)
X		)
X	);
X	trace((/*{*/"}\n"));
X}
X
X
Xstatic void repair_diff_time _((change_ty *, string_ty *));
X
Xstatic void
Xrepair_diff_time(cp, path)
X	change_ty	*cp;
X	string_ty	*path;
X{
X	string_ty	*s;
X	cstate_src	src_data;
X	string_ty	*s2;
X
X	s = os_below_dir(change_development_directory_get(cp, 1), path);
X	src_data = change_src_find(cp, s);
X	if (src_data)
X		src_data->diff_time = os_mtime(path);
X	else
X	{
X		if
X		(
X			s->str_length > 2
X		&&
X			!strcmp(s->str_text + s->str_length - 2, ",D")
X		)
X		{
X			s2 = str_n_from_c(s->str_text, s->str_length - 2);
X			src_data = change_src_find(cp, s2);
X			if (src_data)
X				src_data->diff_file_time = os_mtime(path);
X			str_free(s2);
X		}
X	}
X	str_free(s);
X}
X
X
Xstatic void deu_func _((void *, dir_walk_message_ty, string_ty *, struct stat *));
X
Xstatic void
Xdeu_func(arg, message, path, st)
X	void		*arg;
X	dir_walk_message_ty message;
X	string_ty	*path;
X	struct stat	*st;
X{
X	change_ty	*cp;
X	int		uid;
X
X	trace(("deu_func(message = %d, path = \"%s\", st = %08lX)\n{\n"/*}*/,
X		message, path->str_text, st));
X	cp = (change_ty *)arg;
X	switch (message)
X	{
X	case dir_walk_dir_before:
X	case dir_walk_file:
X		os_become_query(&uid, (int *)0, (int *)0);
X		if (st->st_uid == uid)
X		{
X			os_chmod(path, st->st_mode | 0200);
X			undo_chmod(path, st->st_mode);
X		}
X		repair_diff_time(cp, path);
X		break;
X
X	case dir_walk_special:
X	case dir_walk_symlink:
X	case dir_walk_dir_after:
X		break;
X	}
X	trace((/*{*/"}\n"));
X}
X
X
Xstatic void develop_end_undo_main _((void));
X
Xstatic void
Xdevelop_end_undo_main()
X{
X	cstate		cstate_data;
X	pstate		pstate_data;
X	cstate_history	history_data;
X	int		j;
X	string_ty	*project_name;
X	project_ty	*pp;
X	long		change_number;
X	change_ty	*cp;
X	user_ty		*up;
X	string_ty	*dd;
X
X	trace(("develop_end_undo_main()\n{\n"/*}*/));
X	project_name = 0;
X	change_number = 0;
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch (arglex_token)
X		{
X		default:
X			generic_argument(develop_end_undo_usage);
X			continue;
X
X		case arglex_token_change:
X			if (arglex() != arglex_token_number)
X				develop_end_undo_usage();
X			/* fall through... */
X
X		case arglex_token_number:
X			if (change_number)
X				fatal("duplicate -Change option");
X			change_number = arglex_value.alv_number;
X			if (change_number < 1)
X				fatal("change %ld out of range", change_number);
X			break;
X
X		case arglex_token_project:
X			if (arglex() != arglex_token_string)
X				develop_end_undo_usage();
X			/* fall through... */
X		
X		case arglex_token_string:
X			if (project_name)
X				fatal("duplicate -Project option");
X			project_name = str_from_c(arglex_value.alv_string);
X			break;
X		}
X		arglex();
X	}
X
X	/*
X	 * locate project data
X	 */
X	if (!project_name)
X		project_name = user_default_project();
X	pp = project_alloc(project_name);
X	str_free(project_name);
X	project_bind_existing(pp);
X
X	/*
X	 * locate user data
X	 */
X	up = user_executing(pp);
X
X	/*
X	 * locate change data
X	 */
X	if (!change_number)
X		change_number = user_default_change(up);;
X	cp = change_alloc(pp, change_number);
X	change_bind_existing(cp);
X
X	/*
X	 * lock the change for writing
X	 */
X	project_pstate_lock_prepare(pp);
X	change_cstate_lock_prepare(cp);
X	user_ustate_lock_prepare(up);
X	lock_take();
X	cstate_data = change_cstate_get(cp);
X	pstate_data = project_pstate_get(pp);
X
X	/*
X	 * It is an error if the change is not in one of the 'being_reviewed'
X	 * or 'awaiting_integration' states.
X	 * It is an error if the current user did not develop the change.
X	 */
X	if
X	(
X		cstate_data->state != cstate_state_being_reviewed
X	&&
X		cstate_data->state != cstate_state_awaiting_integration
X	)
X		change_fatal(cp, "not in 'being_reviewed' state");
X	if (!str_equal(change_developer_name(cp), user_name(up)))
X	{
X		change_fatal
X		(
X			cp,
X			"user \"%S\" was not the developer",
X			user_name(up)
X		);
X	}
X
X	/*
X	 * Change the state.
X	 * Add to the change's history.
X	 */
X	cstate_data->state = cstate_state_being_developed;
X	history_data = change_history_new(cp, up);
X	history_data->what = cstate_history_what_develop_end_undo;
X	cstate_data->build_time = 0;
X
X	/*
X	 * add it back into the user's change list
X	 */
X	user_own_add(up, project_name_get(pp), change_number);
X
X	/*
X	 * go through the files in the change and unlock them
X	 * in the baseline
X	 */
X	for (j = 0; j < cstate_data->src->length; ++j)
X	{
X		cstate_src	c_src_data;
X		pstate_src	p_src_data;
X
X		c_src_data = cstate_data->src->list[j];
X		p_src_data = project_src_find(pp, c_src_data->file_name);
X		if (!p_src_data)
X			/* this is really a corrupted file */
X			continue;
X		p_src_data->locked_by = 0;
X
X		/*
X		 * Remove the file if it is about_to_be_created
X		 * by the change we are rescinding.
X		 */
X		if (p_src_data->about_to_be_created_by)
X		{
X			assert(p_src_data->about_to_be_created_by == change_number);
X			project_src_remove(pp, c_src_data->file_name);
X		}
X	}
X
X	/*
X	 * change the ownership back to the user
X	 */
X	dd = change_development_directory_get(cp, 1);
X	user_become(up);
X	dir_walk(dd, deu_func, cp);
X	user_become_undo();
X
X	/*
X	 * write out the data and release the locks
X	 */
X	change_cstate_write(cp);
X	project_pstate_write(pp);
X	user_ustate_write(up);
X	commit();
X	lock_release();
X
X	/*
X	 * run the notify command
X	 */
X	change_run_develop_end_undo_notify_command(cp);
X
X	/*
X	 * verbose success message
X	 */
X	change_verbose(cp, "development resumed");
X	change_free(cp);
X	project_free(pp);
X	user_free(up);
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xdevelop_end_undo()
X{
X	trace(("develop_end_undo()\n{\n"/*}*/));
X	switch (arglex())
X	{
X	default:
X		develop_end_undo_main();
X		break;
X
X	case arglex_token_help:
X		develop_end_undo_help();
X		break;
X
X	case arglex_token_list:
X		develop_end_undo_list();
X		break;
X	}
X	trace((/*{*/"}\n"));
X}
END_OF_FILE
if test 11307 -ne `wc -c <'aegis/aedeu.c'`; then
    echo shar: \"'aegis/aedeu.c'\" unpacked with wrong size!
fi
# end of 'aegis/aedeu.c'
fi
if test -f 'aegis/aenpr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aegis/aenpr.c'\"
else
echo shar: Extracting \"'aegis/aenpr.c'\" \(11506 characters\)
sed "s/^X//" >'aegis/aenpr.c' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to implement new project
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X
X#include <ael.h>
X#include <aenpr.h>
X#include <arglex2.h>
X#include <commit.h>
X#include <error.h>
X#include <gonzo.h>
X#include <help.h>
X#include <lock.h>
X#include <option.h>
X#include <os.h>
X#include <project.h>
X#include <trace.h>
X#include <undo.h>
X#include <user.h>
X
X
Xstatic void new_project_usage _((void));
X
Xstatic void
Xnew_project_usage()
X{
X	char	*progname;
X
X	progname = option_progname_get();
X	fprintf(stderr, "usage: %s -New_Project <name> [ <option>... ]\n", progname);
X	fprintf(stderr, "       %s -New_Project -List [ <option>... ]\n", progname);
X	fprintf(stderr, "       %s -New_Project -Help\n", progname);
X	quit(1);
X}
X
X
Xstatic void new_project_help _((void));
X
Xstatic void
Xnew_project_help()
X{
X	static char *text[] =
X	{
X"NAME",
X"	%s -New_PRoject - create a new project",
X"",
X"SYNOPSIS",
X"	%s -New_PRoject <project-name> [ <option>... ]",
X"	%s -New_PRoject -List [ <option>... ]",
X"	%s -New_PRoject -Help",
X"",
X"DESCRIPTION",
X"	The %s -New_PRoject command is used to create a new",
X"	project.",
X"",
X"	The project directory, under which the project baseline",
X"	and history and state and change data are kept, will be",
X"	created at this time.  If the -DIRectory option is not",
X"	given, the project directory will be created in the",
X"	directory specified by the default_project_directory field",
X"	of aeuconf(5), or if not set in current user's home",
X"	directory; in either case with the same name as the",
X"	project.",
X"",
X"	The project is created with the current user and group as",
X"	the owning user and group.  The current user is an",
X"	administrator for the project.  The project has no",
X"	developers, reviewers, integrators or other",
X"	administrators.",
X"",
X"	The project pointer will be added to the first element of",
X"	the search path, or /usr/local/lib/%s if no path is",
X"	set.  If this is inappropriate, use the -LIBrary option",
X"	to explicitly set the desired location.  See the -LIBrary",
X"	option for more information.",
X"",
X"	The project major version defaults to 1, and the minor",
X"	version	defaults to 0, unless modified by the version",
X"	options, below.",
X"",
X"OPTIONS",
X"	The following options are understood:",
X"",
X"	-DIRectory <path>",
X"		This option may be used to specify which directory",
X"		is to be used.  It is an error if the current user",
X"		does not have appropriate permissions to create",
X"		the directory path given.  This must be an",
X"		absolute path.",
X"",
X"		Caution: If you are using an automounter do not",
X"		use `pwd` to make an absolute path, it usually",
X"		gives the wrong answer.",
X"",
X"	-Help",
X"		This option may be used to obtain more information",
X"		about how to use the %s program.",
X"",
X"	-LIBrary <abspath>",
X"		This option may be used to specify a directory to",
X"		be searched for global state files and user state",
X"		files.  (See aegstate(5) and aeustate(5) for more",
X"		information.)  Several library options may be",
X"		present on the command line, and are search in the",
X"		order given.  Appended to this explicit search",
X"		path are the directories specified by the AEGIS",
X"		enviroment variable (colon separated), and",
X"		finally, /usr/local/lib/%s is always searched.",
X"		All paths specified, either on the command line or",
X"		in the AEGIS environment variable, must be",
X"		absolute.",
X"",
X"	-List",
X"		This option may be used to obtain a list of",
X"		suitable subjects for this command.  The list may",
X"		be more general than expected.",
X"",
X"	-MAJor <number>",
X"		Specify	that the major version number is to be",
X"		the given number.  Defaults to 1 if not set.",
X"",
X"	-MINOr <number>",
X"		Specify	that the minor version number is to be",
X"		the given number.  Defaults to 0 if not set.",
X"",
X"	-TERse",
X"		This option may be used to cause listings to",
X"		produce the bare minimum of information.  It is",
X"		usually useful for shell scripts.",
X"",
X"	-Verbose",
X"		This option may be used to cause %s to produce",
X"		more output.  By default %s only produces",
X"		output on errors.  When used with the -List option",
X"		this option causes column headings to be added.",
X"",
X"	All options may be abbreviated; the abbreviation is",
X"	documented as the upper case letters, all lower case",
X"	letters and underscores (_) are optional.  You must use",
X"	consecutive sequences of optional letters.",
X"",
X"	All options are case insensitive, you may type them in",
X"	upper case or lower case or a combination of both, case",
X"	is not important.",
X"",
X"	For example: the arguments \"-project, \"-PROJ\" and \"-p\"",
X"	are all interpreted to mean the -Project option.  The",
X"	argument \"-prj\" will not be understood, because",
X"	consecutive optional characters were not supplied.",
X"",
X"	Options and other command line arguments may be mixed",
X"	arbitrarily on the command line, after the function",
X"	selectors.",
X"",
X"	The GNU long option names are understood.  Since all",
X"	option names for aegis are long, this means ignoring the",
X"	extra leading '-'.  The \"--option=value\" convention is",
X"	also understood.",
X"",
X"RECOMMENDED ALIAS",
X"	The recommended alias for this command is",
X"	csh%%	alias aenpr '%s -npr \\!* -v'",
X"	sh$	aenpr(){%s -npr $* -v}",
X"",
X"ERRORS",
X"	It is an error if the project name already exists.",
X"	It is an error if the project directory already exists.",
X"	It is an error if the currrent user does not have suffient",
X"	permissions to create the directory specified with the",
X"	-DIRectory option.",
X"",
X"EXIT STATUS",
X"	The %s command will exit with a status of 1 on any",
X"	error.  The %s command will only exit with a status of",
X"	0 if there are no errors.",
X"",
X"COPYRIGHT",
X"	%C",
X"",
X"AUTHOR",
X"	%A",
X	};
X
X	help(text, SIZEOF(text), new_project_usage);
X}
X
X
Xstatic void new_project_list _((void));
X
Xstatic void
Xnew_project_list()
X{
X	arglex();
X	while (arglex_token != arglex_token_eoln)
X		generic_argument(new_project_usage);
X	list_projects(0, 0);
X}
X
X
Xstatic void new_project_main _((void));
X
Xstatic void
Xnew_project_main()
X{
X	pstate		pstate_data;
X	string_ty	*home;
X	string_ty	*s1;
X	string_ty	*project_name;
X	project_ty	*pp;
X	user_ty		*up;
X	string_ty	*bl;
X	string_ty	*hp;
X	string_ty	*ip;
X	long		major;
X	long		minor;
X
X	trace(("new_project_main()\n{\n"/*}*/));
X	project_name = 0;
X	home = 0;
X	major = 0;
X	minor = 0;
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch (arglex_token)
X		{
X		default:
X			generic_argument(new_project_usage);
X			continue;
X
X		case arglex_token_project:
X			if (arglex() != arglex_token_string)
X				new_project_usage();
X			/* fall through... */
X
X		case arglex_token_string:
X			if (project_name)
X				fatal("duplicate -Project option");
X			project_name = str_from_c(arglex_value.alv_string);
X			break;
X
X		case arglex_token_directory:
X			if (home)
X			{
X				duplicate:
X				fatal
X				(
X					"duplicate %s option",
X					arglex_value.alv_string
X				);
X			}
X			if (arglex() != arglex_token_string)
X			{
X		  		fatal
X				(
X			  "the -DIRectory option must be followed by a pathname"
X				);
X			}
X
X			/*
X			 * To cope with automounters, directories are stored as
X			 * given, or are derived from the home directory in the
X			 * passwd file.  Within aegis, pathnames have their
X			 * symbolic links resolved, and any comparison of paths
X			 * is done on this "system idea" of the pathname.
X			 */
X			home = str_from_c(arglex_value.alv_string);
X			break;
X
X		case arglex_token_major:
X			if (major)
X				goto duplicate;
X			if (arglex() != arglex_token_number)
X			{
X				major_bad:
X				error
X				(
X		       "the -MAJor option must be followed by a positive number"
X				);
X				new_project_usage();
X			}
X			major = arglex_value.alv_number;
X			if (major <= 0)
X				goto major_bad;
X			break;
X
X		case arglex_token_minor:
X			if (minor)
X				goto duplicate;
X			if (arglex() != arglex_token_number)
X			{
X				minor_bad:
X				error
X				(
X		       "the -MINOr option must be followed by a positive number"
X				);
X				new_project_usage();
X			}
X			minor = arglex_value.alv_number;
X			if (minor <= 0)
X				goto minor_bad;
X			break;
X		}
X		arglex();
X	}
X	if (!project_name)
X		fatal("no project name given");
X	if (!major)
X		major = 1;
X	if (!minor)
X		minor = 0;
X	
X	/*
X	 * read in the table
X	 */
X	gonzo_gstate_lock_prepare_new();
X	lock_take();
X
X	/*
X	 * locate user data
X	 */
X	up = user_executing((project_ty *)0);
X
X	/*
X	 * make sure not too privileged
X	 */
X	if (!user_uid_check(up->name))
X	{
X		fatal
X		(
X			"user \"%s\" is too privileged",
X			up->name->str_text
X		);
X	}
X	if (!user_gid_check(up->group))
X	{
X		fatal
X		(
X			"group \"%s\" is too privileged",
X			up->group->str_text
X		);
X	}
X
X	/*
X	 * it is an error if the name is already in use
X	 */
X	pp = project_alloc(project_name);
X	str_free(project_name);
X	project_bind_new(pp);
X
X	/*
X	 * create a new project state file
X	 */
X	pstate_data = project_pstate_get(pp);
X	pstate_data->description =
X		str_format("The \"%S\" program.", project_name_get(pp));
X	pstate_data->next_change_number = 1;
X	pstate_data->next_delta_number = 1;
X	pstate_data->version_major = major;
X	pstate_data->version_minor = minor;
X	pstate_data->owner_name = str_copy(user_name(up));
X	pstate_data->group_name = str_copy(user_group(up));
X	assert(pstate_data->administrator);
X	project_administrator_add(pp, user_name(up));
X
X	/*
X	 * if no project directory was specified
X	 * create the directory in their home directory.
X	 */
X	if (!home)
X	{
X		s1 = user_default_project_directory(up);
X		assert(s1);
X		home = str_format("%S/%S", s1, project_name_get(pp));
X		str_free(s1);
X	}
X	project_verbose(pp, "project directory \"%S\"", home);
X	project_home_path_set(pp, home);
X	str_free(home);
X
X	/*
X	 * create the diectory and subdirectories.
X	 * It is an error if the directories can't be created.
X	 */
X	s1 = project_home_path_get(pp);
X	bl = project_baseline_path_get(pp, 0);
X	hp = project_history_path_get(pp);
X	ip = project_info_path_get(pp);
X	project_become(pp);
X	os_mkdir(s1, 02755);
X	undo_rmdir_errok(s1);
X	os_mkdir(bl, 02755);
X	undo_rmdir_errok(bl);
X	os_mkdir(hp, 02755);
X	undo_rmdir_errok(hp);
X	os_mkdir(ip, 02755);
X	undo_rmdir_errok(ip);
X	project_become_undo();
X
X	/*
X	 * add a row to the table
X	 */
X	gonzo_project_add(pp);
X
X	/*
X	 * write the project pointer back out
X	 * release locks
X	 */
X	project_pstate_write(pp);
X	gonzo_gstate_write();
X	commit();
X	lock_release();
X
X	/*
X	 * verbose success message
X	 */
X	project_verbose(pp, "created");
X	project_free(pp);
X	user_free(up);
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xnew_project()
X{
X	trace(("new_project()\n{\n"/*}*/));
X	switch (arglex())
X	{
X	default:
X		new_project_main();
X		break;
X
X	case arglex_token_help:
X		new_project_help();
X		break;
X
X	case arglex_token_list:
X		new_project_list();
X		break;
X	}
X	trace((/*{*/"}\n"));
X}
END_OF_FILE
if test 11506 -ne `wc -c <'aegis/aenpr.c'`; then
    echo shar: \"'aegis/aenpr.c'\" unpacked with wrong size!
fi
# end of 'aegis/aenpr.c'
fi
if test -f 'aegis/aent.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aegis/aent.c'\"
else
echo shar: Extracting \"'aegis/aent.c'\" \(12223 characters\)
sed "s/^X//" >'aegis/aent.c' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to implement new test
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <unistd.h>
X
X#include <ael.h>
X#include <aent.h>
X#include <arglex2.h>
X#include <change.h>
X#include <col.h>
X#include <commit.h>
X#include <error.h>
X#include <glue.h>
X#include <help.h>
X#include <lock.h>
X#include <option.h>
X#include <os.h>
X#include <project.h>
X#include <trace.h>
X#include <user.h>
X#include <word.h>
X
X
Xstatic void new_test_usage _((void));
X
Xstatic void
Xnew_test_usage()
X{
X	char		*progname;
X
X	progname = option_progname_get();
X	fprintf(stderr, "usage: %s -New_Test [ <option>... ]\n", progname);
X	fprintf(stderr, "       %s -New_Test -List [ <option>... ]\n", progname);
X	fprintf(stderr, "       %s -New_Test -Help\n", progname);
X	quit(1);
X}
X
X
Xstatic void new_test_help _((void));
X
Xstatic void
Xnew_test_help()
X{
X	static char *text[] =
X	{
X"NAME",
X"	%s -New_Test - add a new test to a change",
X"",
X"SYNOPSIS",
X"	%s -New_Test [ <option>... ]",
X"	%s -New_Test -List [ <option>... ]",
X"	%s -New_Test -Help",
X"",
X"DESCRIPTION",
X"	The %s -New_Test command is used to add a new test to a",
X"	change.  A new file is created in the development directory.",
X"	The config file will be searched for a template for the new",
X"	file.  If a template is found, the new file will be",
X"	initialized to the template, otherwise it will be created",
X"	empty.  See aepconf(5) for more information.",
X"",
X"	New tests default to automatic unless otherwise",
X"	specified.",
X"",
X"	It is not possible to choose your own test number, or",
X"	test file name.	 All tests within a project are numbered",
X"	uniquely.  Test files are named as",
X"	\"test/XX/tXXXX[am].sh\", where XX is the first 2 digits of",
X"	the test number, XXXX is the whole test number, and [am]",
X"	is a for automatic tests and m for manual tests.",
X"",
X"	Tests may be modified in future	by adding them to a",
X"	change with the	aecp(1)	command.  Tests	are treated just",
X"	like any other source file, and	are subject to the same",
X"	process.",
X"",
X"OPTIONS",
X"	The following options are understood;",
X"",
X"	-AUTOmatic",
X"		This option may be uset to specify manual tests.",
X"		Automatic tests require no human assitance.",
X"",
X"	-Change <number>",
X"		This option may be used to specify a particular",
X"		change within a project.  When no -Change option is",
X"		specified, the AEGIS_CHANGE environment variable is",
X"		consulted.  If that does not exist, the user's",
X"		$HOME/.aegisrc file is examined for a default change",
X"		field (see aeuconf(5) for more information).  If",
X"		that does not exist, when the user is only working",
X"		on one change within a project, that is the default",
X"		change number.  Otherwise, it is an error.",
X"",
X"	-Help",
X"		This option may be used to obtain more",
X"		information about how to use the %s program.",
X"",
X"	-List",
X"		This option may be used to obtain a list of",
X"		suitable subjects for this command.  The list may",
X"		be more general than expected.",
X"",
X"	-MANual",
X"		This option may be used to specify manual tests.",
X"		Manual tests require some human intervention,",
X"		e.g.:  confirmation of some screen behaviour",
X"		(X11, for instance), or some user action, \"unplug",
X"		ethernet cable now\".",
X"",
X"	-Project <name>",
X"		This option may be used to select the project of",
X"		interest.  When no -Project option is specified, the",
X"		AEGIS_PROJECT environment variable is consulted.  If",
X"		that does not exist, the user's $HOME/.aegisrc file",
X"		is examined for a default project field (see",
X"		aeuconf(5) for more information).  If that does not",
X"		exist, when the user is only working on changes",
X"		within a single project, the project name defaults",
X"		to that project.  Otherwise, it is an error.",
X"",
X"	-TERse",
X"		This option may be used to cause listings to",
X"		produce the bare minimum of information.  It is",
X"		usually useful for shell scripts.",
X"",
X"	-Verbose",
X"		This option may be used to cause %s to produce",
X"		more output.  By default %s only produces",
X"		output on errors.  When used with the -List",
X"		option this option causes column headings to be",
X"		added.",
X"",
X"	All options may be abbreviated; the abbreviation is",
X"	documented as the upper case letters, all lower case",
X"	letters and underscores (_) are optional.  You must use",
X"	consecutive sequences of optional letters.",
X"",
X"	All options are case insensitive, you may type them in",
X"	upper case or lower case or a combination of both, case",
X"	is not important.",
X"",
X"	For example: the arguments \"-project, \"-PROJ\" and \"-p\"",
X"	are all interpreted to mean the -Project option.  The",
X"	argument \"-prj\" will not be understood, because",
X"	consecutive optional characters were not supplied.",
X"",
X"	Options and other command line arguments may be mixed",
X"	arbitrarily on the command line, after the function",
X"	selectors.",
X"",
X"	The GNU long option names are understood.  Since all",
X"	option names for aegis are long, this means ignoring the",
X"	extra leading '-'.  The \"--option=value\" convention is",
X"	also understood.",
X"",
X"RECOMMENDED ALIAS",
X"	The recommended alias for this command is",
X"	csh%%	alias aent '%s -nt \\!* -v'",
X"	sh$	aent(){%s -nt $* -v}",
X"",
X"ERRORS",
X"	It is an error if the change is not in the",
X"	'being_developed' state.",
X"	It is an error if the change is not assigned to the",
X"	current user.",
X"",
X"EXIT STATUS",
X"	The %s command will exit with a status of 1 on any",
X"	error.	The %s command will only exit with a status of",
X"	0 if there are no errors.",
X"",
X"COPYRIGHT",
X"	%C",
X"",
X"AUTHOR",
X"	%A",
X	};
X
X	help(text, SIZEOF(text), new_test_usage);
X}
X
X
Xstatic void new_test_list _((void));
X
Xstatic void
Xnew_test_list()
X{
X	string_ty	*project_name;
X	long		change_number;
X
X	trace(("new_test_list()\n{\n"/*}*/));
X	project_name = 0;
X	change_number = 0;
X	arglex();
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch (arglex_token)
X		{
X		default:
X			generic_argument(new_test_usage);
X			continue;
X
X		case arglex_token_change:
X			if (arglex() != arglex_token_number)
X				new_test_usage();
X			/* fall through... */
X
X		case arglex_token_number:
X			if (change_number)
X				fatal("duplicate -Change option");
X			change_number = arglex_value.alv_number;
X			if (change_number < 1)
X				fatal("change %ld out of range", change_number);
X			break;
X
X		case arglex_token_project:
X			if (arglex() != arglex_token_string)
X				new_test_usage();
X			if (project_name)
X				fatal("duplicate -Project option");
X			project_name = str_from_c(arglex_value.alv_string);
X			break;
X		}
X		arglex();
X	}
X	list_project_files(project_name, change_number);
X	if (project_name)
X		str_free(project_name);
X	trace((/*{*/"}\n"));
X}
X
X
Xstatic void new_test_main _((void));
X
Xstatic void
Xnew_test_main()
X{
X	cstate		cstate_data;
X	pstate		pstate_data;
X	string_ty	*s1;
X	string_ty	*s2;
X	string_ty	*dd;
X	cstate_src	src_data;
X	int		manual_flag;
X	int		automatic_flag;
X	string_ty	*project_name;
X	project_ty	*pp;
X	long		change_number;
X	change_ty	*cp;
X	user_ty		*up;
X
X	trace(("new_test_main()\n{\n"/*}*/));
X	manual_flag = 0;
X	automatic_flag = 0;
X	project_name = 0;
X	change_number = 0;
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch (arglex_token)
X		{
X		default:
X			generic_argument(new_test_usage);
X			continue;
X
X		case arglex_token_manual:
X			if (manual_flag)
X			{
X				duplicate:
X				fatal("duplicate %s option", arglex_value.alv_string);
X			}
X			manual_flag = 1;
X			break;
X
X		case arglex_token_automatic:
X			if (automatic_flag)
X				goto duplicate;
X			automatic_flag = 1;
X			break;
X
X		case arglex_token_change:
X			if (arglex() != arglex_token_number)
X				new_test_usage();
X			/* fall through... */
X
X		case arglex_token_number:
X			if (change_number)
X				fatal("duplicate -Change option");
X			change_number = arglex_value.alv_number;
X			if (change_number < 1)
X				fatal("change %ld out of range", change_number);
X			break;
X
X		case arglex_token_project:
X			if (arglex() != arglex_token_string)
X				new_test_usage();
X			if (project_name)
X				fatal("duplicate -Project option");
X			project_name = str_from_c(arglex_value.alv_string);
X			break;
X		}
X		arglex();
X	}
X	if (automatic_flag && manual_flag)
X		fatal("may not specify both -MANual and -AUTOmatic");
X	if (!manual_flag && !automatic_flag)
X		automatic_flag = 1;
X
X	/*
X	 * locate project data
X	 */
X	if (!project_name)
X		project_name = user_default_project();
X	pp = project_alloc(project_name);
X	str_free(project_name);
X	project_bind_existing(pp);
X
X	/*
X	 * locate user data
X	 */
X	up = user_executing(pp);
X
X	/*
X	 * locate change data
X	 */
X	if (!change_number)
X		change_number = user_default_change(up);
X	cp = change_alloc(pp, change_number);
X	change_bind_existing(cp);
X
X	/*
X	 * lock the change state file
X	 * and the project state file for the test number
X	 */
X	project_pstate_lock_prepare(pp);
X	change_cstate_lock_prepare(cp);
X	lock_take();
X	cstate_data = change_cstate_get(cp);
X	pstate_data = project_pstate_get(pp);
X
X	/*
X	 * It is an error if the change is not in the in_development state.
X	 * It is an error if the change is not assigned to the current user.
X	 */
X	if (cstate_data->state != cstate_state_being_developed)
X		change_fatal(cp, "not in 'being_developed' state");
X	if (!str_equal(change_developer_name(cp), user_name(up)))
X	{
X		change_fatal
X		(
X			cp,
X			"user \"%S\" is not the developer",
X			user_name(up)
X		);
X	}
X
X	/*
X	 * Create each file in the development directory.
X	 * Create any necessary directories along the way.
X	 */
X	dd = change_development_directory_get(cp, 1);
X	change_pconf_get(cp);
X	s1 =
X		str_format
X		(
X			"test/%2.2ld/t%4.4ld%s.sh",
X			pstate_data->next_test_number / 100,
X			pstate_data->next_test_number,
X			(manual_flag ? "m" : "a")
X		);
X	pstate_data->next_test_number++,
X	user_become(up);
X	os_mkdir_between(dd, s1, 02755);
X	s2 = str_format("%S/%S", dd, s1);
X	if (!os_exists(s2))
X	{
X		int		fd;
X		string_ty	*template;
X
X		os_become_undo();
X		template = change_file_template(cp, s1);
X		user_become(up);
X		fd = glue_creat(s2->str_text, 0666);
X		if (fd < 0)
X			nfatal("create(\"%s\")", s2->str_text);
X		if (template)
X		{
X			glue_write
X			(
X				fd,
X				template->str_text,
X				template->str_length
X			);
X			str_free(template);
X		}
X		glue_close(fd);
X		os_chmod(s2, 0644 & ~change_umask(cp));
X	}
X	str_free(s2);
X	os_become_undo();
X
X	/*
X	 * Add the file to the change,
X	 * and write it back out.
X	 */
X	src_data = change_src_new(cp);
X	src_data->file_name = s1;
X	src_data->action = file_action_create;
X	src_data->usage =
X		(manual_flag ? file_usage_manual_test : file_usage_test);
X
X	/*
X	 * the number of files changed, or the version did,
X	 * so stomp on the validation fields.
X	 */
X	cstate_data->build_time = 0;
X	cstate_data->test_time = 0;
X	cstate_data->test_baseline_time = 0;
X	cstate_data->regression_test_time = 0;
X
X	/*
X	 * The change now has at least one test,
X	 * so cancel any testing exemption.
X	 */
X	cstate_data->test_exempt = 0;
X	if (change_number > 1)
X		cstate_data->test_baseline_exempt = 0;
X
X	/*
X	 * release the locks
X	 */
X	project_pstate_write(pp);
X	change_cstate_write(cp);
X	commit();
X	lock_release();
X
X	/*
X	 * verbose success message
X	 */
X	change_verbose(cp, "file \"%S\" new test", s1);
X	project_free(pp);
X	change_free(cp);
X	user_free(up);
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xnew_test()
X{
X	trace(("new_test()\n{\n"/*}*/));
X	switch (arglex())
X	{
X	default:
X		new_test_main();
X		break;
X
X	case arglex_token_help:
X		new_test_help();
X		break;
X
X	case arglex_token_list:
X		new_test_list();
X		break;
X	}
X	trace((/*{*/"}\n"));
X}
END_OF_FILE
if test 12223 -ne `wc -c <'aegis/aent.c'`; then
    echo shar: \"'aegis/aent.c'\" unpacked with wrong size!
fi
# end of 'aegis/aent.c'
fi
if test -f 'aegis/aentu.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aegis/aentu.c'\"
else
echo shar: Extracting \"'aegis/aentu.c'\" \(11996 characters\)
sed "s/^X//" >'aegis/aentu.c' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to implement new test undo
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <unistd.h>
X
X#include <ael.h>
X#include <aentu.h>
X#include <arglex2.h>
X#include <change.h>
X#include <col.h>
X#include <commit.h>
X#include <error.h>
X#include <glue.h>
X#include <help.h>
X#include <lock.h>
X#include <option.h>
X#include <os.h>
X#include <project.h>
X#include <trace.h>
X#include <user.h>
X#include <word.h>
X
X
Xstatic void new_test_undo_usage _((void));
X
Xstatic void
Xnew_test_undo_usage()
X{
X	char		*progname;
X
X	progname = option_progname_get();
X	fprintf(stderr, "usage: %s -New_Test_Undo <filename>... [ <option>... ]\n", progname);
X	fprintf(stderr, "       %s -New_Test_Undo -List [ <option>... ]\n", progname);
X	fprintf(stderr, "       %s -New_Test_Undo -Help\n", progname);
X	quit(1);
X}
X
X
Xstatic void new_test_undo_help _((void));
X
Xstatic void
Xnew_test_undo_help()
X{
X	static char *text[] =
X	{
X"NAME",
X"	%s -New_Test_Undo - remove new tests from a change",
X"",
X"SYNOPSIS",
X"	%s -New_Test_Undo <filename>... [ <option>... ]",
X"	%s -New_Test_Undo -List [ <option>... ]",
X"	%s -New_Test_Undo -Help",
X"",
X"DESCRIPTION",
X"	The %s -New_Test_Undo command is used to remove new",
X"	tests from a change (reverse the actions of the '%s",
X"	-New_Test' command).  The file is deleted from the",
X"	development directory.	The file names may be relative to",
X"	the current directory, and %s will attemp to intuit",
X"	the names relative to the development directory or the",
X"	baseline directory.",
X"",
X"OPTIONS",
X"	The following options are understood:",
X"",
X"	-Change <number>",
X"		This option may be used to specify a particular",
X"		change within a project.  When no -Change option is",
X"		specified, the AEGIS_CHANGE environment variable is",
X"		consulted.  If that does not exist, the user's",
X"		$HOME/.aegisrc file is examined for a default change",
X"		field (see aeuconf(5) for more information).  If",
X"		that does not exist, when the user is only working",
X"		on one change within a project, that is the default",
X"		change number.  Otherwise, it is an error.",
X"",
X"	-Help",
X"		This option may be used to obtain more",
X"		information about how to use the %s program.",
X"",
X"	-Keep",
X"		This option may be used to retain files and/or",
X"		directories usually deleted by the command.",
X"",
X"	-List",
X"		This option may be used to obtain a list of",
X"		suitable subjects for this command.  The list may",
X"		be more general than expected.",
X"",
X"	-Project <name>",
X"		This option may be used to select the project of",
X"		interest.  When no -Project option is specified, the",
X"		AEGIS_PROJECT environment variable is consulted.  If",
X"		that does not exist, the user's $HOME/.aegisrc file",
X"		is examined for a default project field (see",
X"		aeuconf(5) for more information).  If that does not",
X"		exist, when the user is only working on changes",
X"		within a single project, the project name defaults",
X"		to that project.  Otherwise, it is an error.",
X"",
X"	-TERse",
X"		This option may be used to cause listings to",
X"		produce the bare minimum of information.  It is",
X"		usually useful for shell scripts.",
X"",
X"	-Verbose",
X"		This option may be used to cause %s to produce",
X"		more output.  By default %s only produces",
X"		output on errors.  When used with the -List",
X"		option this option causes column headings to be",
X"		added.",
X"",
X"	All options may be abbreviated; the abbreviation is",
X"	documented as the upper case letters, all lower case",
X"	letters and underscores (_) are optional.  You must use",
X"	consecutive sequences of optional letters.",
X"",
X"	All options are case insensitive, you may type them in",
X"	upper case or lower case or a combination of both, case",
X"	is not important.",
X"",
X"	For example: the arguments \"-project, \"-PROJ\" and \"-p\"",
X"	are all interpreted to mean the -Project option.  The",
X"	argument \"-prj\" will not be understood, because",
X"	consecutive optional characters were not supplied.",
X"",
X"	Options and other command line arguments may be mixed",
X"	arbitrarily on the command line, after the function",
X"	selectors.",
X"",
X"	The GNU long option names are understood.  Since all",
X"	option names for aegis are long, this means ignoring the",
X"	extra leading '-'.  The \"--option=value\" convention is",
X"	also understood.",
X"",
X"RECOMMENDED ALIAS",
X"	The recommended alias for this command is",
X"	csh%%	alias aentu '%s -ntu \\!$ -v'",
X"	sh$	aentu(){%s -ntu $* -v}",
X"",
X"ERRORS",
X"	It is an error if the change is not in the",
X"	'being_developed' state.",
X"	It is an error if the change is not assigned to the",
X"	current user.",
X"	It is an error if the file is not in the change.",
X"	It is an error if the file was not added to the change",
X"	with the '%s -New_Test' command.",
X"",
X"EXIT STATUS",
X"	The %s command will exit with a status of 1 on any",
X"	error.	The %s command will only exit with a status of",
X"	0 if there are no errors.",
X"",
X"COPYRIGHT",
X"	%C",
X"",
X"AUTHOR",
X"	%A",
X	};
X
X	help(text, SIZEOF(text), new_test_undo_usage);
X}
X
X
Xstatic void new_test_undo_list _((void));
X
Xstatic void
Xnew_test_undo_list()
X{
X	string_ty	*project_name;
X	long		change_number;
X
X	trace(("new_test_undo_list()\n{\n"/*}*/));
X	project_name = 0;
X	change_number = 0;
X	arglex();
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch (arglex_token)
X		{
X		default:
X			generic_argument(new_test_undo_usage);
X			continue;
X
X		case arglex_token_change:
X			if (arglex() != arglex_token_number)
X				new_test_undo_usage();
X			/* fall through... */
X
X		case arglex_token_number:
X			if (change_number)
X				fatal("duplicate -Change option");
X			change_number = arglex_value.alv_number;
X			if (change_number < 1)
X				fatal("change %ld out of range", change_number);
X			break;
X
X		case arglex_token_project:
X			if (arglex() != arglex_token_string)
X				new_test_undo_usage();
X			if (project_name)
X				fatal("duplicate -Project option");
X			project_name = str_from_c(arglex_value.alv_string);
X			break;
X		}
X		arglex();
X	}
X	list_change_files(project_name, change_number);
X	if (project_name)
X		str_free(project_name);
X	trace((/*{*/"}\n"));
X}
X
X
Xstatic void new_test_undo_main _((void));
X
Xstatic void
Xnew_test_undo_main()
X{
X	wlist		wl;
X	cstate		cstate_data;
X	pstate		pstate_data;
X	int		j;
X	string_ty	*s1;
X	string_ty	*s2;
X	int		keep;
X	string_ty	*project_name;
X	project_ty	*pp;
X	long		change_number;
X	change_ty	*cp;
X	user_ty		*up;
X	string_ty	*dd;
X	string_ty	*bl;
X
X	trace(("new_test_undo_main()\n{\n"/*}*/));
X	project_name = 0;
X	change_number = 0;
X	keep = 0;
X	wl_zero(&wl);
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch (arglex_token)
X		{
X		default:
X			generic_argument(new_test_undo_usage);
X			continue;
X
X		case arglex_token_string:
X			s1 = str_from_c(arglex_value.alv_string);
X			os_become_orig();
X			s2 = os_pathname(s1, 1);
X			os_become_undo();
X			str_free(s1);
X			if (wl_member(&wl, s2))
X				fatal("file \"%s\" named more than once", arglex_value.alv_string);
X			wl_append(&wl, s2);
X			str_free(s2);
X			break;
X
X		case arglex_token_keep:
X			if (keep)
X				fatal("duplicate -Keep option");
X			keep = 1;
X			break;
X
X		case arglex_token_change:
X			if (arglex() != arglex_token_number)
X				new_test_undo_usage();
X			/* fall through... */
X
X		case arglex_token_number:
X			if (change_number)
X				fatal("duplicate -Change option");
X			change_number = arglex_value.alv_number;
X			if (change_number < 1)
X				fatal("change %ld out of range", change_number);
X			break;
X
X		case arglex_token_project:
X			if (arglex() != arglex_token_string)
X				new_test_undo_usage();
X			if (project_name)
X				fatal("duplicate -Project option");
X			project_name = str_from_c(arglex_value.alv_string);
X			break;
X		}
X		arglex();
X	}
X	if (!wl.wl_nwords)
X		fatal("no files named");
X
X	/*
X	 * locate project data
X	 */
X	if (!project_name)
X		project_name = user_default_project();
X	pp = project_alloc(project_name);
X	str_free(project_name);
X	project_bind_existing(pp);
X
X	/*
X	 * locate user data
X	 */
X	up = user_executing(pp);
X
X	/*
X	 * locate change data
X	 */
X	if (!change_number)
X		change_number = user_default_change(up);
X	cp = change_alloc(pp, change_number);
X	change_bind_existing(cp);
X
X	/*
X	 * lock the change file
X	 */
X	change_cstate_lock_prepare(cp);
X	lock_take();
X	cstate_data = change_cstate_get(cp);
X	pstate_data = project_pstate_get(pp);
X
X	/*
X	 * It is an error if the change is not in the in_development state.
X	 * It is an error if the change is not assigned to the current user.
X	 */
X	if (cstate_data->state != cstate_state_being_developed)
X		change_fatal(cp, "not in 'being_developed' state");
X	if (!str_equal(change_developer_name(cp), user_name(up)))
X	{
X		change_fatal
X		(
X			cp,
X			"user \"%S\" is not the developer",
X			user_name(up)
X		);
X	}
X
X	/*
X	 * resolve the path of each file
X	 * 1.	the absolute path of the file name is obtained
X	 * 2.	if the file is inside the development directory, ok
X	 * 3.	if the file is inside the baseline, ok
X	 * 4.	if neither, error
X	 */
X	dd = change_development_directory_get(cp, 1);
X	bl = project_baseline_path_get(pp, 1);
X	for (j = 0; j < wl.wl_nwords; ++j)
X	{
X		s1 = wl.wl_word[j];
X		assert(s1->str_text[0] == '/');
X		s2 = os_below_dir(dd, s1);
X		if (!s2)
X			s2 = os_below_dir(bl, s1);
X		if (!s2)
X			change_fatal(cp, "path \"%S\" unrelated", s1);
X		str_free(s1);
X		wl.wl_word[j] = s2;
X	}
X
X	/*
X	 * ensure that each file
X	 * 1. is already part of the change
X	 * 2. is being created by this change
X	 */
X	for (j = 0; j < wl.wl_nwords; ++j)
X	{
X		cstate_src	src_data;
X
X		s1 = wl.wl_word[j];
X		src_data = change_src_find(cp, s1);
X		if (!src_data)
X			change_fatal(cp, "file \"%S\" not in change", s1);
X		if
X		(
X			src_data->action != file_action_create
X		||
X			(
X				src_data->usage != file_usage_test
X			&&
X				src_data->usage != file_usage_manual_test
X			)
X		)
X		{
X			change_fatal(cp, "file \"%S\" is not -New_Test", s1);
X		}
X	}
X
X	/*
X	 * Remove each file from the development directory,
X	 * if it still exists.
X	 */
X	if (!keep)
X	{
X		user_become(up);
X		for (j = 0; j < wl.wl_nwords; ++j)
X		{
X			s1 = wl.wl_word[j];
X			s2 = str_format("%S/%S", dd, s1);
X			if (os_exists(s2))
X				commit_unlink_errok(s2);
X			str_free(s2);
X
X			s2 = str_format("%S/%S,D", dd, s1);
X			if (os_exists(s2))
X				commit_unlink_errok(s2);
X			str_free(s2);
X		}
X		os_become_undo();
X	}
X
X	/*
X	 * Remove each file to the change file,
X	 * and write it back out.
X	 */
X	for (j = 0; j < wl.wl_nwords; ++j)
X		change_src_remove(cp, wl.wl_word[j]);
X
X	/*
X	 * the number of files changed, or the version did,
X	 * so stomp on the validation fields.
X	 */
X	cstate_data->build_time = 0;
X	cstate_data->test_time = 0;
X	cstate_data->test_baseline_time = 0;
X	cstate_data->regression_test_time = 0;
X
X	/*
X	 * release the locks
X	 */
X	change_cstate_write(cp);
X	commit();
X	lock_release();
X
X	/*
X	 * verbose success message
X	 */
X	for (j = 0; j < wl.wl_nwords; ++j)
X		change_verbose(cp, "file \"%S\": new test undo", wl.wl_word[j]);
X	wl_free(&wl);
X	project_free(pp);
X	change_free(cp);
X	user_free(up);
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xnew_test_undo()
X{
X	trace(("new_test_undo()\n{\n"/*}*/));
X	switch (arglex())
X	{
X	default:
X		new_test_undo_main();
X		break;
X
X	case arglex_token_help:
X		new_test_undo_help();
X		break;
X
X	case arglex_token_list:
X		new_test_undo_list();
X		break;
X	}
X	trace((/*{*/"}\n"));
X}
END_OF_FILE
if test 11996 -ne `wc -c <'aegis/aentu.c'`; then
    echo shar: \"'aegis/aentu.c'\" unpacked with wrong size!
fi
# end of 'aegis/aentu.c'
fi
if test -f 'aux/Howto.cook' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aux/Howto.cook'\"
else
echo shar: Extracting \"'aux/Howto.cook'\" \(11994 characters\)
sed "s/^X//" >'aux/Howto.cook' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: instructions to cook(1), how to build project
X */
X
X
X/*
X * You may want to change some of these options.
X * ([debug] must be defined, even if empty, use comments.)
X *
X * Change ``main.h'' to add the DEBUG define.
X * All files reference this file, so this will cause recompilation
X * of all files, both in the change and in the baseline.
X */
Xdebug = /* -g */ ;
Xgonzo_flags = -D\'LIB\=\"/usr/local/lib/aegis\"\';
X
X/*
X * Make sure the [project], [change] and [version] variables are set.
X */
X#ifndef project
Xecho "The [project] variable was not set from the command line." set silent;
Xecho "If you want to do a build with is not a development build" set silent;
Xecho "or an integration build, use the make command, not cook." set silent;
Xfail;
X#endif
X#ifndef change
Xecho "The [change] variable was not set from the command line." set silent;
Xecho "If you want to do a build with is not a development build" set silent;
Xecho "or an integration build, use the make command, not cook." set silent;
Xfail;
X#endif
X#ifndef version
Xecho "The [version] variable was not set from the command line." set silent;
Xecho "If you want to do a build with is not a development build" set silent;
Xecho "or an integration build, use the make command, not cook." set silent;
Xfail;
X#endif
X
X/*
X * If this is a development build, the version will be x.y.Czzz,
X * so look toi see if there is a C in the version string.
X * Include the baseline in the search path if this is
X * a development build.
X */
Xif [match_mask %1C%2 [version]] then
X{
X	baseline = [collect aegis -cd -bl -p [project]];
X	search_list = . [baseline];
X}
X
X/*
X * The source files.
X * This is given to us by aegis.
X */
Xvs_file = common/patchlevel.h;
Xchange_files =
X	[collect aegis -l chafil -ter -p [project] -c [change]]
X	;
Xproject_files =
X	[collect aegis -l profil -ter -p [project] -c [change]]
X	;
Xsource_files =
X	[sort [stringset [project_files] [change_files]]]
X	;
Xcommon_obj =
X	[fromto common/%.c common/%.o [match_mask common/%.c [source_files]]]
X	;
Xaegis_obj =
X	[fromto aegis/%.def aegis/%.o [match_mask aegis/%.def [source_files]]]
X	[fromto aegis/%.y aegis/%.gen.o [match_mask aegis/%.y [source_files]]]
X	[fromto aegis/%.c aegis/%.o [match_mask aegis/%.c [source_files]]]
X	[common_obj]
X	;
Xfmtgen_obj =
X	[fromto fmtgen/%.y fmtgen/%.gen.o [match_mask fmtgen/%.y [source_files]]]
X	[fromto fmtgen/%.c fmtgen/%.o [match_mask fmtgen/%.c [source_files]]]
X	[common_obj]
X	;
Xfmtgen_obj = [stringset [fmtgen_obj] - [vs_file]];
X
Xsource_files_build =
X	[collect ( aegis -l pf -p [project] -c [change] -unf ';'
X		aegis -l cf -p [project] -c [change] -unf )
X		| awk "'/^build/{print $NF}'" ]
X	;
Xsource_files_non_build =
X	[stringset [source_files] - [source_files_build]];
X
X/*
X * how to compile C sources
X */
Xcc = cc;
Xcc_flags = -O [debug];
Xcc_include_flags = ;
X
X/*
X * this next section is for gcc
X *	comment it out if you don't have gcc
X *
X * The gcc include files MUST be first.
X */
Xcc = gcc;
Xcc_include_flags =
X	-I/usr/local/lib/gcc-include
X	[cc_include_flags];
Xcc_flags = [cc_flags] -ansi -Wall -Wstrict-prototypes -Wmissing-prototypes;
X
X/*
X * include files from common
X */
Xcc_include_flags = [cc_include_flags] [prepost "-I" "/common" [search_list]];
X
X/*
X * Need to look at the ANSI include files which come with aegis,
X * but only after the system files.
X * (Since they supplement system files, not replace them.)
X * /
Xcc_include_flags =
X	[cc_include_flags] -I/usr/include [prepost "-I" "/h" [search_list]];
X */
X
X/*
X * Build %1/%2.o from %1/%2.c
X */
X%1/%2.o: %1/%2.c: [collect c_incl -s [stringset [prepost "-I" "/%1"
X	[search_list]] [cc_include_flags]] -eia [resolve %1/%2.c]]
X{
X	if [not [exists %1]] then
X		mkdir %1
X			set clearstat;
X	if [exists [target]] then
X		rm [target]
X			set clearstat;
X	if [defined %2_flags] then
X		extra = [%2_flags];
X	else
X		extra = ;
X	[cc] [stringset [prepost "-I" "/%1" [search_list]] [cc_include_flags]]
X		[cc_flags] [extra] -c [resolve %1/%2.c];
X	mv %2.o %1/%2.o;
X}
X
X
X/*
X * How to use yacc sources.
X */
X
Xyacc = yacc;
Xyacc_flags = ;
X
X%1/%2.gen.c %1/%2.gen.h: %1/%2.y
X{
X	if [not [exists %1]] then
X		mkdir %1
X			set clearstat;
X	if [exists %1/%2.list] then
X		rm %1/%2.list
X			set clearstat;
X	if [exists y.output] then
X		rm y.output
X			set clearstat;
X	if [exists %1/%2.gen.c] then
X		rm %1/%2.gen.c
X			set clearstat;
X	if [exists %1/%2.gen.h] then
X		rm %1/%2.gen.h
X			set clearstat;
X	[yacc] -d [yacc_flags] [resolve %1/%2.y];
X	sed "'s/[yY][yY]/%2_/g'" < y.tab.c | sed '1d' > %1/%2.gen.c;
X	rm y.tab.c;
X	sed "'s/[yY][yY]/%2_/g'" < y.tab.h > %1/%2.gen.h;
X	rm y.tab.h;
X	if [exists y.output] then
X		mv y.output %1/%2.list
X			set clearstat;
X}
X
X
X/*
X * The default recipe
X */
Xall = doc.targets bin/aegis bin/xaegis;
X
X/*
X * Integration builds also make the shar files for distribution.
X */
Xif [defined change] then if [not [defined baseline]] then
X	all = [all] archive/Part01.Z archive/[project].tar.Z
X		archive/[project].patch.Z ;
X
Xall: [all]
X{
X	if [not [defined baseline]] then
X	{
X		set silent;
X		echo "Integrator: please do the following:";
X		echo "	chown root bin/aegis";
X		echo "	chmod u+s bin/aegis";
X	}
X}
X
Xbin/%: script/%.tcl
X{
X	if [not [exists bin]] then
X		mkdir bin
X			set clearstat;
X	cp [resolve [need]] [target];
X	chmod a+rx,og-w [target];
X}
X
X
X/*
X * build the programs from their objects
X */
X
Xbin/%: [%_obj]
X{
X	if [not [exists bin]] then
X		mkdir bin
X			set clearstat;
X	if [exists [target]] then
X		rm [target]
X			set clearstat;
X	[cc] -o [target] [resolve [%_obj]];
X
X	chmod og\=u-w [target];
X
X	/*
X	 * aegis itself must be set-uid-root
X	 */
X	if [defined baseline] then
X	if [in [target] bin/aegis] then
X	{
X		su1 sh -c "'chown root "[target]" && chmod u+s "[target]"'"
X			set errok;
X	}
X}
X
X
X/*
X * building things which require fmtgen to build
X *
X * Build %.c and %.h from %.def
X */
X
X%1/%2.c %1/%2.h: %1/%2.def: bin/fmtgen [collect c_incl -s -eia [prepost "-I"
X	"/%1" [search_list]] [resolve %1/%2.def]]
X{
X	if [not [exists %1]] then
X		mkdir %1
X			set clearstat;
X	if [exists %1/%2.c] then
X		rm %1/%2.c
X			set clearstat;
X	if [exists %1/%2.h] then
X		rm %1/%2.h
X			set clearstat;
X	[resolve bin/fmtgen] [prepost "-I" "/%1" [search_list]]
X		[resolve %1/%2.def] %1/%2.c %1/%2.h;
X}
X
X/*
X * The version stamp is to be updated for every 
X * integration and development build.
X */
X
X#ifndef baseline
X
Xif [exists [vs_file]] then
X	rm [vs_file]
X		set clearstat;
X
X#endif
X
Xif [not [exists [vs_file]]] then
X{
X	if [not [exists [dirname [vs_file]]]] then
X		mkdir [dirname [vs_file]]
X			set clearstat;
X	echo "'#define PATCHLEVEL \""[version]"\"'" > [vs_file]
X		set clearstat;
X}
X
X#ifndef baseline
X
Xif [exists doc/version.so] then
X	rm doc/version.so
X		set clearstat;
X
X#endif
X
Xif [not [exists doc/version.so]] then
X{
X	if [not [exists doc]] then
X		mkdir doc
X			set clearstat;
X	echo \".ds V) [version]\" > doc/version.so
X		set clearstat;
X	echo \"[version]\"
X		| awk -F. "'{print \".ds v) \"$1\".\"$2}'"
X		>> doc/version.so;
X	aegis -list version -p [project] -c [change]
X		| awk -F'\'"\'' "'/previous/{print $2}'"
X		| awk -F. "'{print \".ds w) \"$1\".\"$2}'"
X		>> doc/version.so;
X	cooktime -m 2-Jan-70 doc/version.so;
X}
X
X#ifndef baseline
X
Xif [exists aux/new.so] then
X	rm aux/new.so
X		set clearstat;
X
X#endif
X
Xif [not [exists aux/new.so]] then
X{
X	if [not [exists aux]] then
X		mkdir aux
X			set clearstat;
X	echo \"[version]\"
X		| awk -F. "'{print \".so new.\"$1\".\"$2\".so\"}'"
X		> aux/new.so
X		set clearstat;
X	cooktime -m 2-Jan-70 aux/new.so;
X}
X
X/*
X * These recipes are only expected to be exercised in an integration build.
X * They will work sort-of-OK for a development build, but are incapable
X * of constructing a useful development build Makefile.
X */
X
XMakefile: aux/Makefile.sh aux/Makefile.awk [source_files_non_build]
X{
X	if [exists Makefile] then
X		rm Makefile
X			set clearstat;
X	sh [resolve aux/Makefile.sh [source_files_non_build]]
X		| gawk -f [resolve aux/Makefile.awk] > Makefile;
X}
X
X/*
X * formatting documents and manual entries
X */
Xdoc.targets: cat txt special;
X
X/*
X * manual entries
X */
Xcat = [fromto man%1/%2.%1 cat%1/%2.%1 [match_mask man%1/%2.%1 [source_files]]];
Xcat: [cat];
X
Xcat%1/%2.%1: man%1/%2.%1: [collect c_incl -r -eia [prepost "-I" "/man%1"
X	[search_list]] [resolve man%1/%2.%1]]
X{
X	if [not [exists cat%1]] then
X		mkdir cat%1
X			set clearstat;
X	if [exists [target]] then
X		rm [target]
X			set clearstat;
X	roffpp [prepost "-I" "/man%1" [search_list]] [resolve man%1/%2.%1]
X		| groff -Tascii -P-h -t -man > cat%1/%2.%1; 
X}
X
X
X/*
X * user manuals
X */
X
Xtxt = [fromto doc/%.ms doc/%.ps.Z [match_mask doc/%.ms [source_files]]];
Xtxt: [txt];
X
Xdoc/%.ps.Z: doc/%.ms: [collect c_incl -r -eia [prepost "-I" "/doc"
X	[search_list]] [resolve doc/%.ms]]
X{
X	if [not [exists doc]] then
X		mkdir doc
X			set clearstat;
X	if [exists [target]] then
X		rm -f [target]
X			set clearstat;
X	roffpp [prepost "-I" "/doc" [search_list]] [resolve doc/%.ms]
X		| groff -p -t -ms | compress > [target];
X}
X
X
X/*
X * specials
X */
X
Xspecial: [fromto aux/%.man % [match_mask aux/%.man [source_files]]];
X
X%: aux/%.man: [collect c_incl -r -eia [prepost "-I" "/aux" [search_list]]
X	[resolve aux/%.man]]
X{
X	if [exists [target]] then
X		rm -f [target]
X			set clearstat;
X	roffpp [prepost "-I" "/aux" [search_list]] [resolve aux/%.man]
X		| groff -Tascii -P-hub -t -man > [target]; 
X}
X
X
Xsource_file_order = README [sort [stringset [source_files] - README]];
X
Xarchive/Part01.Z: [source_file_order]
X{
X	if [not [exists archive]] then
X		mkdir archive
X			set clearstat;
X	parts = [glob "archive/Part*"];
X	if [parts] then
X		rm [parts]
X			set clearstat;
X	/* assumes shar.3.49 available */
X	shar -n[project] -a -c -oarchive/Part -L50
X		-s pmiller@bmr.gov.au
X		[resolve [source_file_order]];
X	compress -v archive/Part*;
X}
X
Xarchive/[project].tar.Z: [source_file_order]
X{
X	if [not [exists archive]] then
X		mkdir archive
X			set clearstat;
X	if [exists [target]] then
X		rm [target]
X			set clearstat;
X	if [exists archive/[project].tar] then
X		rm archive/[project].tar
X			set clearstat;
X	tar cf - [resolve [source_file_order]] | tardy -unu 0 -gnu 0
X	-una Peter -gna Miller -p [project] -ms 0644 -mc 07022 -now
X		> archive/[project].tar;
X	compress -v archive/[project].tar;
X}
X
Xarchive/[project].patch.Z: [source_file_order]
X{
X	if [not [exists archive]] then
X		mkdir archive
X			set clearstat;
X	if [exists [target]] then
X		rm [target]
X			set clearstat;
X	if [exists archive/[project].patch] then
X		rm archive/[project].patch
X			set clearstat;
X	sh [resolve aux/patches.sh] [project] [change]
X		> archive/[project].patch;
X	compress -v archive/[project].patch;
X}
X
XCHANGES: aux/CHANGES.sh [vs_file]
X{
X	if [exists [target]] then
X		rm [target]
X			set clearstat;
X	sh [resolve aux/CHANGES.sh] [project] > [target];
X}
X
XMANIFEST: aux/MANIFEST.sh [vs_file]
X{
X	if [exists [target]] then
X		rm [target]
X			set clearstat;
X	sh [resolve aux/MANIFEST.sh [source_file_order]] > [target];
X}
X
X
X/*
X * link to the correct common/conf.h file
X */
X
X#ifndef baseline
X
Xif [exists common/conf.h] then
X	rm common/conf.h
X		set clearstat;
X
X#endif
X
Xif [not [exists common/conf.h]] then
X{
X	if [not [exists common]] then
X		mkdir common;
X	uname-os = [collect uname -s];
X	uname-rel = [collect uname -r];
X	echo "'#include <../conf/"[uname-os]-[uname-rel]">'" > common/conf.h
X		set clearstat;
X	cooktime -m 2-jan-70 common/conf.h;
X}
END_OF_FILE
if test 11994 -ne `wc -c <'aux/Howto.cook'`; then
    echo shar: \"'aux/Howto.cook'\" unpacked with wrong size!
fi
# end of 'aux/Howto.cook'
fi
if test -f 'aux/README.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aux/README.man'\"
else
echo shar: Extracting \"'aux/README.man'\" \(12181 characters\)
sed "s/^X//" >'aux/README.man' <<'END_OF_FILE'
X'\" t
X.\"	aegis - project change supervisor
X.\"	Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: source for the README file
X.\"
X.TH readme aegis
X.if n .hy 0
X.if n .ad l
X.if n .nr IN 8n
X.so ../doc/version.so
X.SH NAME
Xaegis \- project change supervisor
X.br
X.if t .ds C) \(co
X.if n .ds C) (C)
XCopyright \*(C) 1990, 1991, 1992, 1993 Peter Miller.
X.br
XAll rights reserved.
X.PP
XThe
X.I aegis
Xprogram is distributed under the terms of the
XGNU General Public License.
XSee the LICENSE section, below, for more details.
X.PP
X.B aegis
X(ee.j.iz)
X.I n.,
Xa protection,
Xa defence.
X.SH DESCRIPTION
XThe
X.I aegis
Xprogram is a CASE tool with a difference.
XIn the spirit of the UNIX Operating System,
Xthe
X.I aegis
Xprogram is a small component designed to work with other programs.
X.PP
XMany CASE systems attempt to provide everything,
Xfrom bubble charts to source control to compilers.
XUsers are trapped with the components supplied by the CASE system,
Xand if you don't like one of the components (it may be too limited,
Xfor instance), then that is just tough.
X.PP
XIn contrast,
XUNIX provides many components of a CASE system \- compilers,
Xeditors,
Xdependency maintenance tools (such as make),
Xsource control tools (such as RCS).
XYou may substitute the tool of your choice
Xif you don't like the ones supplied with the system \- gcc, jove, cake,
Xto name just a few.
XThe
X.I aegis
Xprogram adds to this list with software configuration
Xmanagement,
Xand true to UNIX philosophy,
Xthe
X.I aegis
Xprogram does not
Xdictate the choice of any of the other tools (although it may stretch them
Xto their limits).
X.PP
XEnough hype, what is it that the
X.I aegis
Xprogram does?
XJust what is software configuration management?
XThis question is sufficiently broad as to require a book in answer.
XIn essence,
Xthe
X.I aegis
Xprogram is a project change supervisor.
XIt provides a
Xframework within which a team of developers may work on many changes to a
Xprogram independently,
Xand the
X.I aegis
Xprogram coordinates integrating these
Xchanges back into the master source of the program,
Xwith as little disruption as possible.
XResolution of contention for source files,
Xa major headache for any project with more than one developer,
Xis one of the
X.I aegis
Xprogram's major functions. 
X.PP
XIt should be noted that the
X.I aegis
Xprogram is a developer's tool,
Xin the same sense as make or RCS are developer's tools.
XIt is not a manager's tool \- it
Xdoes not provide progress tracking or manage work allocation.
X.br
X.ne 1i
X.SH BENEFITS
XSo why should you use the
X.I aegis
Xprogram?
X.PP
XThe
X.I aegis
Xprogram uses a particular model of the development of software
Xprojects.
XThis model has a master source (or baseline) of a project,
Xand a team of developers creating changes to be made to this baseline.
XWhen a change is complete,
Xit is integrated with the baseline,
Xto become the new baseline.
XEach change must be atomic and self-contained,
Xno change is allowed to cause the baseline to cease to work.
X"Working" is defined as passing it's own tests.
XThe tests are considered part of the baseline.
XThe
X.I aegis
Xprogram provides support for the developer so that an entire copy of
Xthe baseline need not be taken to change a few files,
Xonly those files which are to be changed need to be copied.
X.PP
XIn order to ensure that changes are unable to
Xcause the baseline to cease to work,
X.I aegis
Xmandates that changes be accompanied by at least one test,
Xand that all such tests be known to complete successfully.
XThese steadily accumulated tests form an ever increasing
Xregression test suite for all later changes.
XThere is also a mandatory review stage for each change to the baseline.
XWhile these requirements may be relaxed per-change or even per-project,
Xdoing so potentially compromises the "working" definition of the baseline.
X.PP
XThe win in using the
X.I aegis
Xprogram is that there are
X.I O(n)
Xinteractions between
Xdevelopers and the baseline.
XContrast this with a master source which is
Xbeing edited directly by the developers - there are
X.I O(n!)
Xinteractions between
Xdevelopers - this makes adding "just one more" developer a potential disaster.
X.PP
XAnother win is that the project baseline always works.
XAlways having a working baseline means that a version is always available for
Xdemonstrations,
Xor those "pre-release snapshots" we are always forced to provide.
X.PP
XThe above advantages are all very well - for management types.
XWhy should Joe Average Programmer use the
X.I aegis
Xprogram?
XRecall that RCS provides file locking,
Xbut only for one file at a time.
XThe
X.I aegis
Xprogram provides the file locking,
Xatomically,
Xfor the set of files in the change.
XRecall also that RCS locks the file the instant you start editing it.
XThis makes popular files a project bottleneck.
XThe
X.I aegis
Xprogram allows concurrent editing,
Xand a resolution mechanism just before the
Xchange must be integrated,
Xmeaning fewer delays for J.A.Programmer.
X.br
X.ne 1i
X.SH ARCHIVE SITE
XThe latest version of
X.I aegis
Xis available by anonymous FTP from:
X.RS
X.TS
Xcenter,tab(;);
Xl l s
Xl l l.
XHost:;ftp.cse.nau.edu (134.114.64.70)
XDir:;/pub/Aegis
XFile:;aegis.\*(v).tar.Z;# the complete source
XFile:;aegis.\*(v).patch.Z;# patch to take \*(w) to \*(v)
XFile:;aegis.\*(v).ps.Z;# PostScript of the User Guide
X.TE
X.RE
X.PP
XTo use anonymous FTP,
Xgive "anonymous" as the user name (omit the quotes)
Xand your email address as the password.
X.PP
XMy grateful thanks to Paul Balyoz <pab@ftp.cse.nau.edu>
Xfor his generosity in providing this archive space.
X.PP
XThis directory also contains a few other pieces of software written by me.
XSome are referred to in the
X.I aegis
Xdocumentation.
XPlease have a look if you are interested.
X.PP
XFor those of you without FTP,
XI recommend the use of an ftp-by-email server.
XHere is a list of a few (there are many more):
X.RS
X.nf
Xftpmail@decwrl.dec.com
Xftpmail@cs.uow.edu.au
X.fi
X.RE
X.PP
XIn general, you can get a help message about how to use each system
Xby sending email with a subject of "help"
Xand a message body containing just the word "help".
X.br
X.ne 1i
X.SH MAILING LIST
XA mailing list has been created so that users of
X.I aegis
Xmay exchange ideas about how to use the
X.I aegis
Xprogram.
XDiscussion may include,
Xbut is not limited to:
Xbugs, enhancements, and applications.
XThe list is not moderated.
X.PP
XThe address of the mailing list is
X.RS
X.ft CW
Xaegis-users@bmr.gov.au
X.ft R
X.RE
X.PP
XTo subscribe to this mailing list,
Xsend an email message to \f(CWmajordomo@bmr.gov.au\fP with
Xa message body containing the single line
X.RS
X.ft CW
Xsubscribe aegis-users
X.ft R
X.RE
XPlease note that \f(CWbmr.gov.au\fP is an Internet site,
Xso if you have an address which is not readily derived from
Xyour mail headers (majordomo is only a Perl program, after all)
Xyou will need to use a message of the form:
X.RS
X.ft CW
Xsubscribe aegis-users \fIaddress\fP
X.ft R
X.RE
Xwhere \fIaddress\fP is an email address which
Xmakes sense from an Internet site.
X.PP
XThe software which handles this mailing list
X.if n CANNOT
X.if t .B cannot
Xsend you a copy of the
X.I aegis
Xprogram.
XPlease use FTP or ftp-by-email, instead.
X.br
X.ne 1i
X.SH COMPARISON WITH CVS
XOne of the most common questions about
X.I aegis
Xis "How does it compare with CVS?"
X.PP
XThe CVS program aims to provide a repository,
XRCS for sets of files.
XThe
X.I aegis
Xprogram aims to provide a baseline,
Xa repository,
Xconsistency of the baseline,
Xand validation of changes being made to the baseline.
X.PP
XA simplistic way of thinking of this is "CVS is over RCS",
Xbut "aegis is over RCS and make".
XActually CVS requires RCS,
Xwhereas
X.I aegis
Xmay be configured to use almost any history tool;
Xsimilarly for the dependency maintenance tool,
X.I aegis
Xmay be configured to use almost any sufficiently capable
Xtool (unfortunately traditional make isn't sufficiently capable,
Xbut the name is well known and evokes the appropriate functional image).
X.PP
XThe most significant point of departure is around the "cvs checkin"
Xfunctionality.
XIn CVS, this is unconditional;
Xa developer can add a poorly though-out code change,
Xor even indulge in a little vandalism,
Xwith nothing to prevent it.
XIn contrast,
Xthe
X.I aegis
Xprogram breaks this step into several pieces:
Xthe change must be be known to build,
Xthe change must have tests and those tests be known to have run and passed,
Xthe change must then be reviewed (double check),
Xand then built and tested again (triple check).
X.PP
XFor a more detailed discussion,
Xsee appendix C of the User Guide.
X.br
X.ne 1i
X.SH NEW IN THIS RELEASE
XA number of features have been added to
X.I aegis
Xwith this release.
XA few of them are detailed here:
X.so new.so
X.PP
XPlus the usual crop of bug fixes and tinkering.
XFor excruciating detail,
Xand also acknowledgements of those who generously sent me feedback,
Xplease see the
X.I CHANGES
Xfile included in this distribution.
X.br
X.ne 1i
X.SH BUILDING
XInstructions on how to build and test the
X.I aegis
Xprogram
Xare to be found in the
X.I BUILDING
Xfile included in this distribution.
X.br
X.ne 1i
X.SH SOME HISTORY
XThe idea for
X.I aegis
Xdid not come full-blown into my head in the shower,
Xas some of my programs do,
Xbut rather from working in a software shop
Xwhich used a simplistic form of something similar.
XThat system was held together by chewing-gum and string,
Xit was written in a disgusting variant of Basic,
Xand by golly the damn thing worked (mostly).
XThe
X.I aegis
Xprogram is nothing like it,
Xowes none of its code to that system,
Xand is far more versatile.
X.PP
XSince that company decided to close down our section,
Xwe all moved on simultaneously (all 60 of us),
Xsometimes working together,
Xand sometimes not,
Xbut always keeping in touch.
XWith suggestions and conversations with
Xsome of them early in 1990,
Xthe manual entries for
X.I aegis
Xtook shape,
Xand formed most of the design document for
X.IR aegis .
X.PP
XSince getting the first glimmerings of a functional
X.I aegis
Xlate in 1990 it
Xis increasingly obvious that I never want to be without it ever again.
XAll of my sources that I modify are instantly placed under
X.IR aegis ,
Xas is anything I distribute.
XAll code I write for myself,
Xand all new code I write for my employer,
Xgoes under
X.IR aegis .
XWhy?
XBecause it has fewer bugs!
X.PP
XExample: one of the sources I carry with me from job to job is "cook",
Xmy dependency maintenance tool.
XCook had existed for 3 years before
X.I aegis
Xappeared on the scene,
Xand I used it daily.
XWhen I placed cook under
X.IR aegis ,
XI found 6 bugs!
XSince then I have found a few more.
XNot only are there now fewer bugs,
Xbut they never come back,
Xbecause the regression test suite always grows.
X.br
X.ne 1i
X.SH LICENSE
XThe
X.I aegis
Xprogram is free software;
Xyou can redistribute it and/or modify
Xit under the terms of the GNU General Public License as published by
Xthe Free Software Foundation;
Xeither version 2 of the License,
Xor (at your option) any later version.
X.PP
XThe
X.I aegis
Xprogram is distributed in the hope that it will be useful,
Xbut WITHOUT ANY WARRANTY;
Xwithout even the implied warranty of
XMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
XSee the GNU General Public License for more details.
X.PP
XYou should have received a copy of the GNU General Public License
Xalong with this program; if not, write to the Free Software
XFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.PP
XIt should be in the
X.I LICENSE
Xfile included in this distribution.
X.br
X.ne 1i
X.SH AUTHOR
X.TS
Xtab(;);
Xl l l.
XPeter Miller;UUCP;uunet!munnari!bmr.gov.au!pmiller
X\f(CW/\e/\e*\fR;Internet;pmiller@bmr.gov.au
X.TE
END_OF_FILE
if test 12181 -ne `wc -c <'aux/README.man'`; then
    echo shar: \"'aux/README.man'\" unpacked with wrong size!
fi
# end of 'aux/README.man'
fi
if test -f 'common/ansi.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/ansi.c'\"
else
echo shar: Extracting \"'common/ansi.c'\" \(11296 characters\)
sed "s/^X//" >'common/ansi.c' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: missing ANSI C library functions
X */
X
X#include <stddef.h>
X#include <stdio.h>
X#include <string.h>
X#include <time.h>
X
X#include <main.h>
X#include <conf.h>
X
X
X/*
X *  NAME
X *      strerror - string for error number
X *
X *  SYNOPSIS
X *      char *strerror(int errnum);
X *
X *  DESCRIPTION
X *      The strerror function maps the error number in errnum to an error
X *      message string.
X *
X *  RETURNS
X *      The strerror function returns a pointer to the string, the contents of
X *      which are implementation-defined.  The array pointed to shall not be
X *      modified by the program, but may be overwritten by a subsequent call to
X *      the strerror function.
X *
X *  CAVEAT
X *      Unknown errors will be rendered in the form "Error %d", where %d will
X *      be replaced by a decimal representation of the error number.
X */
X
X#ifdef CONF_NO_strerror
X
Xchar *
Xstrerror(n)
X    int     n;
X{
X    extern int sys_nerr;
X    extern char *sys_errlist[];
X    static char buffer[16];
X
X    if (n < 1 || n > sys_nerr)
X    {
X	sprintf(buffer, "Error %d", n);
X	return buffer;
X    }
X    return sys_errlist[n];
X}
X
X#endif /* CONF_NO_strerror */
X
X
X/*
X *  NAME
X *      strftime - string from time
X *
X *  SYNOPSIS
X *      size_t strftime(char *s, size_t maxsize, const char *format,
X *		const struct tm *timeptr);
X *
X *  DESCRIPTION
X *      The strftime function places characters into the array pointed to
X *	by s as controlled by the string pointed to by format.  The format
X *	string consists of zero or more directives and ordinary characters.
X *	A directive consists of a % character followed by a character that
X *	determined the dirrective's behaviour.  All ordinary characters
X *	(including the terminating null character) are copied unchanged
X *	into the array.  No more thaqn maxsize characters are placed into
X *	the array.  Each directive is replaced by appropriate characters as
X *	described in the following list.  The appropriate characters are
X *	determined by the program's locale and by the values contained in
X *	the structure pointed to by timeptr.
X *
X *	%a is replaced by the locale's abbreviated weekday name
X *	%A is replaced by the locale's full weekday name
X *	%b is replaced by the locale's abbreviated month name
X *	%B is replaced by the locale's full month name
X *	%c is replaced by the locale's appropriae date and time representation
X *	%d is replaced by the day of the month as decimal number (01-31)
X *	%H is replaced by the hour (24-hour clock) as decimal number (00-23)
X *	%I is replaced by the hour (12-hour clock) as decimal number (01-12)
X *	%j is replaced by the day of te year as decimal number (001-366)
X *	%m is replaced by the month as decomal number (01-12)
X *	%M is replaced by the minute as decimal number (00-59)
X *	%p is replaced by the locale's equivalent of either AM or PM
X *	%S is replaced by the second as decimal number (00-59)
X *	%U is replaced by the week number of they year (Sunday as the first
X *		day of the week) as decimal number (00-52)
X *	%w is replaced by the weekday as decimal number (0=Sunday to 6=Saturday)
X *	%W is replaced by the week number of the year (Monday as the first
X *		day of the week) as decimal number (00-52)
X *	%x is replaced by the locale's appropriate date representation
X *	%X is replaced by the locale's appropriate time representation
X *	%y is replaced by the year without century as decimal number (00-99)
X *	%Y is replaced by the year with century as decimal number
X *	%Z is replaced by the time zone name, or no characters in no time
X *		zone name is available
X *	%% is replaced by %
X *
X *  RETURNS
X *	If the total number of resulting characters including the terminating
X *	null character is not more than maxsize, the strftime function returns
X *	the number of characters placed into the array pointed to by s not
X *	including the terminating null character.  Otherwise, zero is returned
X *	and the contents of the array are indeterminate.
X *
X *  CAVEAT
X *      This suffers from a serious design flaw: there is no way to
X *	distinguish between a result which is the empty string, and a result
X *	which is more than maxsize characters.
X *
X *	The behaviour for unknow directivbes is not only undefined,
X *	it is unmentioned!  (Normally the standard specifically allows
X *	implementation defined behaviour on weird boundary conditions.)
X *	This implementation will echo unknown directives into the output.
X */
X
X#ifdef CONF_NO_strftime
X
X#ifdef SYSV
Xextern char *tzname[2];
X#endif
X
Xsize_t
Xstrftime(buf, max, fmt, tm)
X	char		*buf;
X	size_t		max;
X	char		*fmt;
X	struct tm	*tm;
X{
X	char		*cp;
X	char		*end;
X	char		output[1000];
X	int		n;
X	size_t		len;
X
X	static char *weekday[] =
X	{
X		"Sunday",
X		"Monday",
X		"Tuesday",
X		"Wednesday",
X		"Thrusday",
X		"Friday",
X		"Saturday",
X	};
X
X	static char *month[] =
X	{
X		"January",
X		"February",
X		"March",
X		"April",
X		"May",
X		"June",
X		"July",
X		"August",
X		"September",
X		"October",
X		"November",
X		"December",
X	};
X
X	end = buf + max - 1;
X	cp = buf;
X	while (*fmt)
X	{
X		if (*fmt++ != '%')
X		{
X			if (cp >= end)
X				return 0;
X			*cp++ = fmt[-1];
X			continue;
X		}
X		switch (*fmt++)
X		{
X		case 0:
X			--fmt;
X			output[0] = '%';
X			output[1] = 0;
X			break;
X
X		default:
X			output[0] = '%';
X			output[1] = fmt[-1];
X			output[2] = 0;
X			break;
X
X		case '%':
X			output[0] = '%';
X			output[1] = 0;
X			break;
X
X		case 'a':
X			/*
X			 * the abbreviated weekday name
X			 */
X			sprintf(output, "%3.3s", weekday[tm->tm_wday]);
X			break;
X
X		case 'A':
X			/*
X			 * the full weekday name
X			 */
X			strcpy(output, weekday[tm->tm_wday]);
X			break;
X
X		case 'b':
X		case 'h':
X			/*
X			 * the abbreviated month name
X			 */
X			sprintf(output, "%3.3s", month[tm->tm_mon]);
X			break;
X
X		case 'B':
X			/*
X			 * the full month name
X			 */
X			strcpy(output, month[tm->tm_mon]);
X			break;
X
X		case 'c':
X			/*
X			 * the date and time
X			 */
X			len = strftime(output, sizeof(output), "%b %e %X %Y", tm);
X			if (!len)
X				output[0] = 0;
X			break;
X
X		case 'C':
X			/*
X			 * This looks like a Sun extra.
X			 * Local date.
X			 */
X			len = strftime(output, sizeof(output), "%A, %B %e, %Y", tm);
X			if (!len)
X				output[0] = 0;
X			break;
X		
X		case 'd':
X			/*
X			 * the day of the month,
X			 * zero padded.
X			 */
X			sprintf(output, "%2.2d", tm->tm_mday);
X			break;
X		
X		case 'D':
X			/*
X			 * This looks like a Sun extra.
X			 * Local date.
X			 */
X			len = strftime(output, sizeof(output), "%m/%d/%y", tm);
X			if (!len)
X				output[0] = 0;
X			break;
X
X		case 'e':
X			/*
X			 * This looks like a Sun extra.
X			 * the day of the month,
X			 * blank padded.
X			 */
X			sprintf(output, "%2d", tm->tm_mday);
X			break;
X
X		case 'H':
X			/*
X			 * the hour of a 24-hour day
X			 * zero padded
X			 */
X			sprintf(output, "%2.2d", tm->tm_hour);
X			break;
X
X		case 'I':
X			/*
X			 * the hour of a 12-hour day,
X			 * zero padded
X			 */
X			n = tm->tm_hour % 12;
X			sprintf(output, "%2.2d", n ? n : 12);
X			break;
X
X		case 'j':
X			/*
X			 * the day of the year,
X			 * zero padded, one based
X			 */
X			sprintf(output, "%3.3d", tm->tm_yday + 1);
X			break;
X
X		case 'k':
X			/*
X			 * This looks like a Sun extra.
X			 * the hour of the 24-hour day,
X			 * blank padded.
X			 */
X			sprintf(output, "%2d", tm->tm_hour);
X			break;
X
X		case 'l':
X			/*
X			 * This looks like a Sun extra.
X			 * the hour of the 12-hour day,
X			 * blank padded.
X			 */
X			n = tm->tm_hour % 12;
X			sprintf(output, "%2d", n ? n : 12);
X			break;
X
X		case 'm':
X			/*
X			 * the month of the year,
X			 * zero padded, one based.
X			 */
X			sprintf(output, "%2.2d", tm->tm_mon + 1);
X			break;
X
X		case 'M':
X			/*
X			 * the minute of the hour,
X			 * zero padded
X			 */
X			sprintf(output, "%2.2d", tm->tm_min);
X			break;
X
X		case 'n':
X			/*
X			 * This looks like a Sun extra.
X			 * like \n
X			 */
X			output[0] = '\n';
X			output[1] = 0;
X			break;
X
X		case 'p':
X			/*
X			 * meridian indicator
X			 */
X			if (tm->tm_hour >= 12)
X				strcpy(output, "PM");
X			else
X				strcpy(output, "AM");
X			break;
X
X		case 'r':
X			/*
X			 * this looks like a Sun extra.
X			 * like %X, but 12-hour clock with meridian.
X			 */
X			len = strftime(output, sizeof(output), "%I:%M:%S %p", tm);
X			if (!len)
X				output[0] = 0;
X			break;
X
X		case 'R':
X			/*
X			 * this looks like a Sun extra.
X			 * the 24-hour time as HH:MM
X			 */
X			len = strftime(output, sizeof(output), "%H:%M", tm);
X			if (!len)
X				output[0] = 0;
X			break;
X
X		case 'S':
X			/*
X			 * seconds of the minute
X			 */
X			sprintf(output, "%2.2d", tm->tm_sec);
X			break;
X
X		case 't':
X			/*
X			 * this looks like a Sun extra.
X			 * like \t
X			 */
X			output[0] = '\t';
X			output[1] = 0;
X			break;
X
X		case 'T':
X			/*
X			 * This looks like a Sun extra.
X			 * the 24-hour time as HH:MM:SS
X			 */
X			len = strftime(output, sizeof(output), "%H:%M:%S", tm);
X			if (!len)
X				output[0] = 0;
X			break;
X
X		case 'U':
X			/*
X			 * the Sunday week of the year
X			 */
X			n = (tm->tm_yday - tm->tm_wday + 5) / 7;
X			sprintf(output, "%2.2d", n);
X			break;
X
X		case 'w':
X			/*
X			 * the day of the week,
X			 * Sunday = 0
X			 */
X			sprintf(output, "%d", tm->tm_wday);
X			break;
X
X		case 'W':
X			/*
X			 * the Monday week of the year
X			 */
X			n = (tm->tm_yday - ((tm->tm_wday + 6) % 7) + 5) / 7;
X			sprintf(output, "%2.2d", n);
X			break;
X
X		case 'x':
X			/*
X			 * the date, as mmm dd yyyy
X			 */
X			len = strftime(output, sizeof(output), "%b %d %Y", tm);
X			if (!len)
X				output[0] = 0;
X			break;
X
X		case 'X':
X			/*
X			 * the time as hh:mm:ss
X			 */
X			len = strftime(output, sizeof(output), "%H:%M:%S", tm);
X			if (!len)
X				output[0] = 0;
X			break;
X
X		case 'y':
X			/*
X			 * the year of the century
X			 */
X			sprintf(output, "%2.2d", tm->tm_year % 100);
X			break;
X
X		case 'Y':
X			/*
X			 * the year including century
X			 */
X			sprintf(output, "%4.4d", tm->tm_year + 1900);
X			break;
X
X		case 'Z':
X			/*
X			 * the timezone name, if any
X			 */
X#ifdef SYSV
X			if (tm->tm_isdst >= 0 && tm->tm_isdst <= 1)
X				strcpy(output, tzname[tm->tm_isdst]);
X			else
X				output[0] = 0;
X#else
X			/* Berkeley derivateives have extra tm field */
X			strcpy(output, tm->tm_zone);
X#endif
X			break;
X		}
X
X		/*
X		 * make sure it fits in the buffer
X		 */
X		len = strlen(output);
X		if (cp + len > end)
X			return -1;
X		memcpy(cp, output, len);
X		cp += len;
X	}
X	*cp = 0;
X	return (cp - buf);
X}
X
X#endif /* CONF_NO_strftime */
X
X#ifdef CONF_HAS_setresuid
X
Xint
Xseteuid(x)
X	int	x;
X{
X	return setresuid(-1, x, -1);
X}
X
Xint
Xsetegid(x)
X	int	x;
X{
X	return setresgid(-1, x, -1);
X}
X
X#endif
X
X#ifdef CONF_HAS_setreuid
X
Xint
Xseteuid(x)
X	int	x;
X{
X	return setreuid(-1, x);
X}
X
Xint
Xsetegid(x)
X	int	x;
X{
X	return setregid(-1, x);
X}
X
X#endif
END_OF_FILE
if test 11296 -ne `wc -c <'common/ansi.c'`; then
    echo shar: \"'common/ansi.c'\" unpacked with wrong size!
fi
# end of 'common/ansi.c'
fi
if test -f 'common/error.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/error.c'\"
else
echo shar: Extracting \"'common/error.c'\" \(11542 characters\)
sed "s/^X//" >'common/error.c' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to report errors
X */
X
X#include <ctype.h>
X#include <errno.h>
X#include <stddef.h>
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X
X#include <grp.h>
X#include <pwd.h>
X#include <unistd.h>
X
X#include <arglex.h>
X#include <error.h>
X#include <option.h>
X#include <s-v-arg.h>
X
X
X#define HUGE_BUFFER 6000
X
X
Xstatic void error_get_id _((int *, int *));
X
Xstatic void
Xerror_get_id(uid, gid)
X	int	*uid;
X	int	*gid;
X{
X	*uid = geteuid();
X	*gid = getegid();
X}
X
X
Xstatic	error_id_ty errid = error_get_id;
X
X
Xvoid
Xerror_set_id_func(f)
X	error_id_ty	f;
X{
X	if (f)
X		errid = f;
X	else
X		errid = error_get_id;
X}
X
X
X/*
X * NAME
X *	wrap - wrap s string over lines
X *
X * SYNOPSIS
X *	void wrap(char *);
X *
X * DESCRIPTION
X *	The wrap function is used to print error messages onto stderr
X *	wrapping ling lines.
X *
X * CAVEATS
X *	Line length is assumed to be 80 characters.
X */
X
Xstatic void wrap _((char *));
X
Xstatic void
Xwrap(s)
X	char	*s;
X{
X	char	*progname;
X	static char escapes[] = "\rr\nn\ff\bb\tt";
X	int	page_width;
X	char	tmp[MAX_PAGE_WIDTH + 2];
X	int	first_line;
X	char	*tp;
X
X	if (fflush(stdout) || ferror(stdout))
X		nfatal("(stdout)");
X	/* don't use last column, many terminals are dumb */
X	page_width = option_page_width_get() - 1;
X	progname = option_progname_get();
X	first_line = 1;
X	while (*s)
X	{
X		char	*ep;
X		int	ocol;
X
X		/*
X		 * Work out how many characters fit on the line.
X		 */
X		if (first_line)
X			ocol = strlen(progname) + 2;
X		else
X			ocol = 8;
X		for (ep = s; *ep; ++ep)
X		{
X			int	cw;
X			int	c;
X
X			c = (unsigned char)*ep;
X			if (isprint(c))
X				cw = 1 + (c == '\\');
X			else
X				cw = (strchr(escapes, c) ? 2 : 4);
X			if (ocol + cw > page_width)
X				break;
X			ocol += cw;
X		}
X
X		/*
X		 * see if there is a better place to break the line
X		 */
X		if (*ep && *ep != ' ')
X		{
X			char	*mp;
X
X			for (mp = ep; mp > s; --mp)
X			{
X				if (strchr(" /", mp[-1]))
X				{
X					ep = mp;
X					break;
X				}
X			}
X		}
X
X		/*
X		 * ignore trailing blanks
X		 */
X		while (ep > s && ep[-1] == ' ')
X			ep--;
X
X		/*
X		 * print the line
X		 */
X		if (first_line)
X			sprintf(tmp, "%s: ", progname);
X		else
X			strcpy(tmp, "\t");
X		tp = tmp + strlen(tmp);
X		while (s < ep)
X		{
X			int	c;
X
X			c = (unsigned char)*s++;
X			if (isprint(c))
X			{
X				if (c == '\\')
X					*tp++ = '\\';
X				*tp++ = c;
X			}
X			else
X			{
X				char	*esc;
X
X				esc = strchr(escapes, c);
X				if (esc)
X				{
X					*tp++ = '\\';
X					*tp++ = esc[1];
X				}
X				else
X				{
X					sprintf(tp, "\\%3.3o", c);
X					tp += strlen(tp);
X				}
X			}
X		}
X		*tp++ = '\n';
X		*tp = 0;
X		fputs(tmp, stderr);
X		if (ferror(stderr))
X			break;
X
X		/*
X		 * skip leading spaces for subsequent lines
X		 */
X		while (*s == ' ')
X			s++;
X		first_line = 0;
X	}
X	if (fflush(stderr) || ferror(stderr))
X		nfatal("(stderr)");
X}
X
X
Xstatic void id _((char *));
X
Xstatic void
Xid(s)
X	char		*s;
X{
X	int		uid;
X	struct passwd	*pw;
X	char		uidn[20];
X	int		gid;
X	struct group	*gr;
X	char		gidn[20];
X
X	errid(&uid, &gid);
X	pw = getpwuid(uid);
X	if (pw)
X		sprintf(uidn, "user \"%.8s\"", pw->pw_name);
X	else
X		sprintf(uidn, "uid %d", uid);
X
X	gr = getgrgid(gid);
X	if (gr)
X		sprintf(gidn, "group \"%.8s\"", gr->gr_name);
X	else
X		sprintf(gidn, "gid %d", gid);
X
X	sprintf(s, " [%s, %s]", uidn, gidn);
X}
X
X
X/*
X *  NAME
X *	error - place a message on the error stream
X *
X *  SYNOPSIS
X *	void error(char *s, ...);
X *
X *  DESCRIPTION
X *	Error places a message on the error output stream.
X *	The first argument is a printf-like format string,
X *	optionally followed by other arguments.
X *	The message will be prefixed by the program name and a colon,
X *	and will be terminated with a newline, automatically.
X *
X *  CAVEAT
X *	Things like "error(filename)" blow up if the filename
X *	contains a '%' character.
X */
X
X/*VARARGS1*/
Xvoid
Xerror(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	va_list		ap;
X	char		buffer[HUGE_BUFFER];
X
X	sva_init(ap, s);
X	vsprintf(buffer, s, ap);
X	va_end(ap);
X	wrap(buffer);
X}
X
X
X/*
X *  NAME
X *	nerror - place a system fault message on the error stream
X *
X *  SYNOPSIS
X *	void nerror(char *s, ...);
X *
X *  DESCRIPTION
X *	Nerror places a message on the error output stream.
X *	The first argument is a printf-like format string,
X *	optionally followed by other arguments.
X *	The message will be prefixed by the program name and a colon,
X *	and will be terminated with a text description of the error
X *	indicated by the 'errno' global variable, automatically.
X *
X *  CAVEAT
X *	Things like "nerror(filename)" blow up if the filename
X *	contains a '%' character.
X */
X
X/*VARARGS1*/
Xvoid
Xnerror(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	char		buffer[HUGE_BUFFER];
X	va_list		ap;
X	int		n;
X
X	n = errno;
X	sva_init(ap, s);
X	vsprintf(buffer, s, ap);
X	va_end(ap);
X	strcat(buffer, ": ");
X	strcat(buffer, strerror(n));
X	if (n == EPERM || n == EACCES)
X		id(buffer + strlen(buffer));
X	wrap(buffer);
X}
X
X
X/*
X *  NAME
X *	nfatal - place a system fault message on the error stream and exit
X *
X *  SYNOPSIS
X *	void nfatal(char *s, ...);
X *
X *  DESCRIPTION
X *	Nfatal places a message on the error output stream and exits.
X *	The first argument is a printf-like format string,
X *	optionally followed by other arguments.
X *	The message will be prefixed by the program name and a colon,
X *	and will be terminated with a text description of the error
X *	indicated by the 'errno' global variable, automatically.
X *
X *  CAVEAT
X *	Things like "nfatal(filename)" blow up if the filename
X *	contains a '%' character.
X *
X *	This function does NOT return.
X */
X
X/*VARARGS1*/
Xvoid
Xnfatal(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	char		buffer[HUGE_BUFFER];
X	va_list		ap;
X	int		n;
X
X	n = errno;
X	sva_init(ap, s);
X	vsprintf(buffer, s, ap);
X	va_end(ap);
X	strcat(buffer, ": ");
X	strcat(buffer, strerror(n));
X	if (n == EPERM || n == EACCES)
X		id(buffer + strlen(buffer));
X	wrap(buffer);
X	quit(1);
X}
X
X
X/*
X *  NAME
X *	fatal - place a message on the error stream and exit
X *
X *  SYNOPSIS
X *	void fatal(char *s, ...);
X *
X *  DESCRIPTION
X *	Fatal places a message on the error output stream and exits.
X *	The first argument is a printf-like format string,
X *	optionally followed by other arguments.
X *	The message will be prefixed by the program name and a colon,
X *	and will be terminated with a newline, automatically.
X *
X *  CAVEAT
X *	Things like "error(filename)" blow up if the filename
X *	contains a '%' character.
X *
X *	This function does NOT return.
X */
X
X/*VARARGS1*/
Xvoid
Xfatal(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	va_list		ap;
X	char		buffer[HUGE_BUFFER];
X
X	sva_init(ap, s);
X	vsprintf(buffer, s, ap);
X	va_end(ap);
X	wrap(buffer);
X	quit(1);
X}
X
X
X/*
X *  NAME
X *	assert - make an assertion
X *
X *  SYNOPSIS
X *	void assert(int condition);
X *
X *  DESCRIPTION
X *	Assert is a handy tool for a programmer to guarantee the internal
X *	consistency of their program. If "-DDEBUG" is specified on
X *	the compiler's command line, then assert will generate code to verify
X *	the assertios made. If no DEBUG is defined, assertions will generate
X *	no code.
X *
X *  CAVEAT
X *	If the assertion fails, a fatal diagnostic is issued.
X *
X *	The #define's which control the compilation may be found in "error.h".
X *
X */
X
Xint
Xassert_failed(s, file, line)
X	char	*s;
X	char	*file;
X	int	line;
X{
X	error("%s: %d: assertion \"%s\" failed (bug)", file, line, s);
X	abort();
X	exit(1); /* incase abort() comes back */
X	return 0; /* to silence lint */
X}
X
X
X/*
X *  NAME
X *	verbose - place a verbose message on the error stream
X *
X *  SYNOPSIS
X *	void verbose(char *s, ...);
X *
X *  DESCRIPTION
X *	The verbose function places a verbose message on the error stream.
X *	The first argument is a printf-like format string,
X *	optionally followed by other arguments.
X *	The message will be prefixed by the program name and a colon,
X *	and will be terminated with a newline, automatically.
X *
X *  CAVEAT
X *	Things like "verbose(filename)" blow up if the filename
X *	contains a '%' character.
X */
X
X/*VARARGS1*/
Xvoid
Xverbose(s sva_last)
X	char		*s;
X	sva_last_decl
X{
X	va_list		ap;
X	char		buffer[HUGE_BUFFER];
X
X	sva_init(ap, s);
X	vsprintf(buffer, s, ap);
X	va_end(ap);
X	if (option_verbose_get())
X		wrap(buffer);
X}
X
X
X/*
X *  NAME
X *      signal_name - find it
X *
X *  SYNOPSIS
X *      char *signal_name(int n);
X *
X *  DESCRIPTION
X *      The signal_name function is used to find the name of a signal from its
X *      number.
X *
X *  RETURNS
X *      char *: pointer to the signal name.
X *
X *  CAVEAT
X *      The signal name may not be written on.  Subsequent calls may alter the
X *      area pointed to.
X */
X
Xchar *
Xsignal_name(n)
X	int	n;
X{
X	static char buffer[16];
X
X	switch (n)
X	{
X#ifdef SIGHUP
X	case SIGHUP:
X		return "hang up [SIGHUP]";
X#endif /* SIGHUP */
X
X#ifdef SIGINT
X	case SIGINT:
X		return "user interrupt [SIGINT]";
X#endif /* SIGINT */
X
X#ifdef SIGQUIT
X	case SIGQUIT:
X		return "user quit [SIGQUIT]";
X#endif /* SIGQUIT */
X
X#ifdef SIGILL
X	case SIGILL:
X		return "illegal instruction [SIGILL]";
X#endif /* SIGILL */
X
X#ifdef SIGTRAP
X	case SIGTRAP:
X		return "trace trap [SIGTRAP]";
X#endif /* SIGTRAP */
X
X#ifdef SIGIOT
X	case SIGIOT:
X		return "abort [SIGIOT]";
X#endif /* SIGIOT */
X
X#ifdef SIGEMT
X	case SIGEMT:
X		return "EMT instruction [SIGEMT]";
X#endif /* SIGEMT */
X
X#ifdef SIGFPE
X	case SIGFPE:
X		return "floating point exception [SIGFPE]";
X#endif /* SIGFPE */
X
X#ifdef SIGKILL
X	case SIGKILL:
X		return "kill [SIGKILL]";
X#endif /* SIGKILL */
X
X#ifdef SIGBUS
X	case SIGBUS:
X		return "bus error [SIGBUS]";
X#endif /* SIGBUS */
X
X#ifdef SIGSEGV
X	case SIGSEGV:
X		return "segmentation violation [SIGSEGV]";
X#endif /* SIGSEGV */
X
X#ifdef SIGSYS
X	case SIGSYS:
X		return "bad argument to system call [SIGSYS]";
X#endif /* SIGSYS */
X
X#ifdef SIGPIPE
X	case SIGPIPE:
X		return "write on a pipe with no one to read it [SIGPIPE]";
X#endif /* SIGPIPE */
X
X#ifdef SIGALRM
X	case SIGALRM:
X		return "alarm clock [SIGALRM]";
X#endif /* SIGALRM */
X
X#ifdef SIGTERM
X	case SIGTERM:
X		return "software termination [SIGTERM]";
X#endif /* SIGTERM */
X
X#ifdef SIGUSR1
X	case SIGUSR1:
X		return "user defined signal one [SIGUSR1]";
X#endif /* SIGUSR1 */
X
X#ifdef SIGUSR2
X	case SIGUSR2:
X		return "user defined signal two [SIGUSR2]";
X#endif /* SIGUSR2 */
X
X#ifdef SIGCLD
X	case SIGCLD:
X		return "death of child [SIGCLD]";
X#endif /* SIGCLD */
X
X#ifdef SIGPWR
X	case SIGPWR:
X		return "power failure [SIGPWR]";
X#endif /* SIGPWR */
X
X	default:
X		sprintf(buffer, "signal %d", n);
X		return buffer;
X	}
X}
X
X
Xstatic	quit_ty	quit_list[10];
Xstatic	int	quit_list_len;
X
X
Xvoid
Xquit_register(func)
X	quit_ty	func;
X{
X	assert(quit_list_len < SIZEOF(quit_list));
X	assert(func);
X	quit_list[quit_list_len++] = func;
X}
X
X
Xvoid
Xquit(n)
X	int		n;
X{
X	int		j;
X	static int	quitting;
X
X	if (quitting > 4)
X	{
X		fprintf
X		(
X			stderr,
X			"%s: incorrectly handled error while quitting (bug)\n",
X			option_progname_get()
X		);
X		exit(1);
X	}
X	++quitting;
X	for (j = quit_list_len - 1; j >= 0; --j)
X		quit_list[j](n);
X	exit(n);
X}
END_OF_FILE
if test 11542 -ne `wc -c <'common/error.c'`; then
    echo shar: \"'common/error.c'\" unpacked with wrong size!
fi
# end of 'common/error.c'
fi
if test -f 'config' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config'\"
else
echo shar: Extracting \"'config'\" \(11544 characters\)
sed "s/^X//" >'config' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: instructions to aegis, per-project configuration
X */
X
X/*
X * how to build the project
X * mandatory
X */
Xbuild_command =
X	"cook -b ${source aux/Howto.cook} project=$project \
Xchange=$change version=$version -nl";
X
X/*
X * When do -Integrate_Begin, link the baseline to the integration directory,
X * rather than copying it.  This should be much faster.
X *
X * There is a gotcha: all the recipes in Howto.cook must unlink their targets
X * before re-creating them, otherwise the baseline will be trashed.
X */
Xlink_integration_directory = true;
X
X/*
X * create a new history
X * always executed as the project owner
X */
Xhistory_create_command =
X	"fhist ${basename $history} -create -i $input -p ${dirname $history} -r";
X
X/*
X * get a file from history
X * may be executed by developers
X */
Xhistory_get_command =
X	"fhist ${basename $history} -e '$edit' -o $output \
X-p ${dirname $history} -v 0";
X
X/*
X * add a new change to the history
X * always executed as the project owner
X */
Xhistory_put_command =
X	"fhist ${basename $history} -u -i $input -p ${dirname $history} -r";
X
X/*
X * query the topmost edit of a history file
X * Result to be printed on stdout.
X * may be executed by developers
X */
Xhistory_query_command =
X	"fhist ${basename $history} -l 0 -p ${dirname $history} -q";
X
X/*
X * difference of 2 files
X */
Xdiff_command = "fcomp -w -s $original $input -o $output";
X
X/*
X * difference of 3 files
X */
Xdiff3_command = "fmerge $original $mostrecent $input -o $output -c $input,C";
X
X/*
X * whenever files are added to or removed from the change,
X * execute the following command.
X */
Xchange_file_command = "rm -f .c_inclrc";
X
X/*
X * new file templates
X */
Xfile_template =
X[
X	{
X		pattern = [ "*.[cyl]" ];
X		body ="\
X/*\n\
X *	aegis - project change supervisor\n\
X *	Copyright (C) ${date %Y} Peter Miller.\n\
X *	All rights reserved.\n\
X *\n\
X *	This program is free software; you can redistribute it and/or modify\n\
X *	it under the terms of the GNU General Public License as published by\n\
X *	the Free Software Foundation; either version 2 of the License, or\n\
X *	(at your option) any later version.\n\
X *\n\
X *	This program is distributed in the hope that it will be useful,\n\
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
X *	GNU General Public License for more details.\n\
X *\n\
X *	You should have received a copy of the GNU General Public License\n\
X *	along with this program; if not, write to the Free Software\n\
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\
X *\n\
X * MANIFEST: functions to manipulate ${basename $fn .c}s\n\
X */\n";
X	},
X	{
X		pattern = [ "*.h" ];
X		body = "\
X/*\n\
X *	aegis - project change supervisor\n\
X *	Copyright (C) ${date %Y} Peter Miller.\n\
X *	All rights reserved.\n\
X *\n\
X *	This program is free software; you can redistribute it and/or modify\n\
X *	it under the terms of the GNU General Public License as published by\n\
X *	the Free Software Foundation; either version 2 of the License, or\n\
X *	(at your option) any later version.\n\
X *\n\
X *	This program is distributed in the hope that it will be useful,\n\
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
X *	GNU General Public License for more details.\n\
X *\n\
X *	You should have received a copy of the GNU General Public License\n\
X *	along with this program; if not, write to the Free Software\n\
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\
X *\n\
X * MANIFEST: interface definition for ${basename $fn .h}.c\n\
X */\n\
X\n\
X#ifndef ${upcase ${id $fn}}\n\
X#define ${upcase ${id $fn}}\n\
X\n\
X#include <main.h>\n\
X\n\
X#endif /* ${upcase ${id $fn}} */\n";
X	},
X	{
X		pattern = [ "test/*/*.sh" ];
X		body = "\
X#! /bin/sh\n\
X#\n\
X#	aegis - project change supervisor\n\
X#	Copyright (C) ${date %Y} Peter Miller.\n\
X#	All rights reserved.\n\
X#\n\
X#	This program is free software; you can redistribute it and/or modify\n\
X#	it under the terms of the GNU General Public License as published by\n\
X#	the Free Software Foundation; either version 2 of the License, or\n\
X#	(at your option) any later version.\n\
X#\n\
X#	This program is distributed in the hope that it will be useful,\n\
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
X#	GNU General Public License for more details.\n\
X#\n\
X#	You should have received a copy of the GNU General Public License\n\
X#	along with this program; if not, write to the Free Software\n\
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\
X#\n\
X# MANIFEST: Test the ??? functionality\n\
X#\n\
X\n\
Xunset AEGIS_PROJECT\n\
Xunset AEGIS_CHANGE\n\
Xumask 022\n\
X\n\
XUSER=$${USER:-$${LOGNAME:-`whoami`}}\n\
X\n\
Xwork=$${AEGIS_TMP:-/tmp}/$$$$\n\
XPAGER=cat\n\
Xexport PAGER\n\
X\n\
Xhere=`pwd`\n\
Xif test $$? -ne 0 ; then exit 1; fi\n\
Xmkdir $$work\n\
Xif test $$? -ne 0 ; then exit 1; fi\n\
X\n\
Xfail()\n\
X{\n\
X	set +x\n\
X	echo FAILED test of ... 1>&2\n\
X	cd $$here\n\
X	find $$work -type d -user $$USER -exec chmod u+w {} \\;\n\
X	rm -rf $$work\n\
X	exit 1\n\
X}\n\
Xpass()\n\
X{\n\
X	set +x\n\
X	echo PASSED 1>&2\n\
X	cd $$here\n\
X	find $$work -type d -user $$USER -exec chmod u+w {} \\;\n\
X	rm -rf $$work\n\
X	exit 0\n\
X}\n\
Xtrap \"fail\" 1 2 3 15\n\
X\n\
Xcd $$work\n\
Xif test $$? -ne 0 ; then fail; fi\n\
X\n\
X#\n\
X# put your test here\n\
X#\n\
X$$here/myprog\n\
Xif test $$? -ne 0 ; then fail; fi\n\
X\n\
X#\n\
X# Only definite negatives are possible.\n\
X# The functionality exercised by this test appears to work,\n\
X# no other guarantees are made.\n\
X#\n\
Xpass\n";
X	},
X	{
X		pattern = [ "*.sh" ];
X		body = "\
X#! /bin/sh\n\
X#\n\
X#	aegis - project change supervisor\n\
X#	Copyright (C) ${date %Y} Peter Miller.\n\
X#	All rights reserved.\n\
X#\n\
X#	This program is free software; you can redistribute it and/or modify\n\
X#	it under the terms of the GNU General Public License as published by\n\
X#	the Free Software Foundation; either version 2 of the License, or\n\
X#	(at your option) any later version.\n\
X#\n\
X#	This program is distributed in the hope that it will be useful,\n\
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
X#	GNU General Public License for more details.\n\
X#\n\
X#	You should have received a copy of the GNU General Public License\n\
X#	along with this program; if not, write to the Free Software\n\
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\
X#\n\
X# MANIFEST: shell script to manipulate ${basename $fn .sh}s\n\
X#\n\
X\n\
Xexit 0\n";
X	},
X	{
X		pattern = [ "*.man", "*.[12345678]" ];
X		body = "\
X'\\\" t\n\
X.\\\"	aegis - project change supervisor\n\
X.\\\"	Copyright (C) ${date %Y} Peter Miller.\n\
X.\\\"	All rights reserved.\n\
X.\\\"\n\
X.\\\"	This program is free software; you can redistribute it and/or modify\n\
X.\\\"	it under the terms of the GNU General Public License as published by\n\
X.\\\"	the Free Software Foundation; either version 2 of the License, or\n\
X.\\\"	(at your option) any later version.\n\
X.\\\"\n\
X.\\\"	This program is distributed in the hope that it will be useful,\n\
X.\\\"	but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
X.\\\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
X.\\\"	GNU General Public License for more details.\n\
X.\\\"\n\
X.\\\"	You should have received a copy of the GNU General Public License\n\
X.\\\"	along with this program; if not, write to the Free Software\n\
X.\\\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\
X.\\\"\n\
X.\\\" MANIFEST: manual page describing the ${basename $fn .1} command.\n\
X.\\\"\n\
X.TH aegis 1\n\
X.if n .ad l\n\
X.if n .hy 0\n\
X.SH NAME\n\
Xaegis \\- project change supervisor\n\
X.SH SYNOPSIS\n\
X.B aegis\n\
X[\n\
X.IR option \\&...\n\
X]\n\
X.IR filename \\&...\n\
X.br\n\
X.B aegis\n\
X.B -Help\n\
X.br\n\
X.B aegis\n\
X.B -VERSion\n\
X.SH DESCRIPTION\n\
XThe\n\
X.I aegis\n\
Xprogram is used to\n\
X.SH OPTIONS\n\
XThe following options are understood:\n\
X.TP 8n\n\
X.B -Help\n\
X.br\n\
XProvide some help with using the\n\
X.I aegis\n\
Xprogram.\n\
X.TP 8n\n\
X.B -VERSion\n\
X.br\n\
XPrint the version of the\n\
X.I aegis\n\
Xprogram being executed.\n\
X.PP\n\
XAll other options will produce a diagnostic error.\n\
XOptions may be abbreviated,\n\
Xthe minimum abbreviation is shown in upper-case.\n\
XOptions are case insensitive.\n\
XOptions and file names may be mixed arbitrarily on the command line.\n\
X.SH EXIT STATUS\n\
XThe\n\
X.I aegis\n\
Xprogram will exit with a status of 1 on any error.\n\
XThe\n\
X.I aegis\n\
Xprogram will only exit with a status of 0 if there are no errors.\n\
X.so z_cr.so\n";
X	},
X	{
X		pattern = [ "*.so", "*.ms", "*.me" ];
X		body = "\
X.\\\"\n\
X.\\\"	aegis - project change supervisor\n\
X.\\\"	Copyright (C) ${date %Y} Peter Miller.\n\
X.\\\"	All rights reserved.\n\
X.\\\"\n\
X.\\\"	This program is free software; you can redistribute it and/or modify\n\
X.\\\"	it under the terms of the GNU General Public License as published by\n\
X.\\\"	the Free Software Foundation; either version 2 of the License, or\n\
X.\\\"	(at your option) any later version.\n\
X.\\\"\n\
X.\\\"	This program is distributed in the hope that it will be useful,\n\
X.\\\"	but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
X.\\\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
X.\\\"	GNU General Public License for more details.\n\
X.\\\"\n\
X.\\\"	You should have received a copy of the GNU General Public License\n\
X.\\\"	along with this program; if not, write to the Free Software\n\
X.\\\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\
X.\\\"\n\
X.\\\" MANIFEST: document describing ${basename $fn .ms}\n\
X.\\\"\n";
X	},
X	{
X		pattern = [ "*" ];
X		body = "\
X#\n\
X#	aegis - project change supervisor\n\
X#	Copyright (C) ${date %Y} Peter Miller.\n\
X#	All rights reserved.\n\
X#\n\
X#	This program is free software; you can redistribute it and/or modify\n\
X#	it under the terms of the GNU General Public License as published by\n\
X#	the Free Software Foundation; either version 2 of the License, or\n\
X#	(at your option) any later version.\n\
X#\n\
X#	This program is distributed in the hope that it will be useful,\n\
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
X#	GNU General Public License for more details.\n\
X#\n\
X#	You should have received a copy of the GNU General Public License\n\
X#	along with this program; if not, write to the Free Software\n\
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\
X#\n\
X# MANIFEST: ${basename $fn}\n\
X#\n";
X	}
X];
X
Xdevelop_begin_command = "ln -s $baseline bl";
END_OF_FILE
if test 11544 -ne `wc -c <'config'`; then
    echo shar: \"'config'\" unpacked with wrong size!
fi
# end of 'config'
fi
if test -f 'doc/cA.0.so' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/cA.0.so'\"
else
echo shar: Extracting \"'doc/cA.0.so'\" \(12295 characters\)
sed "s/^X//" >'doc/cA.0.so' <<'END_OF_FILE'
X.\"
X.\"	aegis - project change supervisor
X.\"	Copyright (C) 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: User Guide, Appendix A: New Project Quick Reference
X.\"
X.bp
X.2C
X.nh 1 "Appendix A: New Project Quick Reference"
X.LP
XFor those of you too impatient to read a whole great big document
Xabout how to use the aegis program,
Xthis appendix gives a quick look at how
Xto place a project under aegis.
X.LP
XThe style here is a bullet list.
XIt does not try to be exhaustive.
XFor exact details on how to use the various aegis commands,
Xyou should see the manual pages,
Xditto for the formats and contents of some files.
X.LP
XProbably the quickest start of all is to copy
Xan already existing project.
XThe project used in chapter 2 is complete,
Xassuming you use the author's "cook" dependency maintenance tool.
XThe entirety of this example may be fond,
Xif slightly obfuscated,
Xin the aegis source file
X.I "test/00/t0011a.sh"
Xdistributed with aegis.
X.nh 2 "Create the Project"
X.LP
XThe
X.I aenpr
Xcommand is used to create a project.
XYou must supply the name on the command line.
XThe name should be ten characters or less,
Xsix characters or less if you want version numbers included.
X.LP
XThe user who creates the project is the owner of the project,
Xand is set as the administrator.
XThe default group of the user who created the project
Xis used as the project's group.
X.LP
XYou may want to have a user account which owns the project.
XYou must create the project as this user,
Xand then use the
X.I aena
Xand
X.I aera
Xcommands to add an appropriate administrator,
Xand remove the owning user as an administrator.
XAfter this, the password for the owning user may be disabled,
Xbecause the aegis program will,
Xat appropriate times,
Xset file ownership to reflect project ownership
Xor execute commands on behalf of the project owner \fIas\fP the project owner.
X.nh 3 "Add the Staff"
X.LP
XThe
X.I aend
Xcommand is used to add developers.
XThe
X.I aenrv
Xcommand is used to add reviewers.
XThe
X.I aeni
Xcommand is used to add integrators.
XThese commands may only be performed by a project administrator.
X.LP
XYou will still have to do this,
Xeven if the person who created the project will be among these people,
Xor even be all of these people.
X.nh 3 "Project Attributes"
X.LP
XThe
X.I aepa
Xcommand is used to change project attributes.
XThese attributes include the description of the project,
Xand booleans controlling whether, for example,
Xdevelopers may review their own work.
X.LP
XThe project attributes file is described in
Xthe \fIaepattr\fP(5)
Xmanual entry.
X.nh 2 "Create Change One"
X.LP
XThe
X.I aenc
Xcommand is used to create a new change.
XYou will need to construct a change attributes file
Xwith your favorite text editor before running this command.
X.LP
XThe change attributes file is described in
Xthe \fIaecattr\fP(5)
Xmanual entry.
X.nh 2 "Develop Change One"
X.LP
XThis is the most grueling step.
XIndeed, the integration step will probably reveal things you missed,
Xand you may return to the
X.I "being developed"
X state several times.
X.LP
XOne of the people you nominated as a developer
Xwill have to use the
X.I aedb
Xcommand to commence development of change 1.
XThe
X.I aecd
Xcommand can be used to change directory into the
Xjust-created development directory.
X.LP
XAdd files to the change.
XThe
X.I aenf
Xcommand is used to create new files.
XIf you don't use
X.I aenf
Xthen the aegis program has no way of knowing
Xwhether that file lying there in the development directory is significant
Xto the project,
Xor just a shopping list of the groceries you forgot to buy yesterday.
X.LP
XOne particular
Xnew file which \fImust\fP be created by this change is the
X.I "config"
Xfile.
XThis tells the aegis program what history mechanism you wish to use,
Xwhat dependency maintenance command to use,
Xwhat file difference tools to use,
Xand much more.
XThe \fIaepconf\fP(5) manual entry describes this file.
X.LP
XIf you are going to use the "cook" dependency maintenance tool,
Xanother new file
Xyou will need to create in this change is the "Howto.cook" file.
XSome other tool will want some other rules file.
X.LP
XYou probably have a prototype or some other "seed" you have sort-of
Xworking.  Create new files for each source file
Xand \fIthen\fP copy the files from wherever they are now
Xinto the development directory.
X.LP
XUse the
X.I aeb
Xcommand to build the change.
XIt will need to build cleanly before it can advance to the next step.
X.LP
XUse the
X.I aed
Xcommand to difference the change.
XIt will need to difference cleanly before it can advance to the next step.
X.LP
XUse the
X.I aent
Xcommand to add new tests to the command.
XIt will need to have tests before it can advance to the next step.
X.LP
XMost existing projects don't have formal tests.
XThese tests will form a regression test-bed,
Xused to make sure that future changes never compromise
Xexisting functionality.
X.LP
XUse the
X.I aet
Xcommand to test the change.
XIt will need to test cleanly before it can advance to the next step.
X.LP
XOnce the change builds, differences and tests cleanly,
Xuse the
X.I aede
Xcommand to end development.
XAt this point,
Xthe mode of the files will be changed to read only,
Xpreventing accidental modification of the files.
X.nh 2 "Review The Change"
X.LP
XOne of the people nominated as reviewers will have to run the
X.I aerpass
Xcommand to say that the change passed review.
X.LP
XThe aegis program does not mandate any particular review mechanism:
Xyou could use a single peer to do the review,
Xyou could use a panel,
Xyou could set the project so that developers may review their own work
Xand effectively eliminating the review step.
XIn projects with as few as two people,
Xit is always beneficial for someone other than the developer to review changes.
X.LP
XShould a reviewer actually want to \fIsee\fP the change,
Xthe
X.I aecd
Xcommand may be used to change directory to the development directory of
Xthe change.
XThe difference files all end with a "comma D" suffix, so the
X.E(
X.fi
Xmore `find . -name "*,D" -print | sort`
X.E)
Xcommand may be used to search them out and see them.
XThis is probably fairly useless for the first change,
Xbut is vital for all subsequent changes.
XThere is a supplied alias for this command,
Xit is
X.I aedmore
Xand there is a similar
X.I aedless
Xalias if you prefer the
X.I less (1)
Xcommand.
X.LP
XThere are some facts that a reviewer \fIknows\fP because otherwise
Xthe change would not be in the "being reviewed" state:
X\(bu the change compiles cleanly,
X\(bu the change passes all of its tests.
XOther information about the change may be obtained
Xusing the "change_details" variation of the
X.I ael
Xcommand.
X.LP
XThe
X.I aerfail
Xcommand may also be used by reviewers to fail reviews
Xand return a change to the developer for further work;
Xthe reviewer must supply a reason for the change history to record for all time.
XSimilarly,
Xthe
X.I aedeu
Xcommand may be used by the developer to resume development
Xof a change at any time before it is integrated;
Xno stated reason is required.
X.nh 2 "Integrate the Change"
X.LP
XA person nominated as an project integrator
Xthen integrates the change.
XThis involves making a copy of the integration directory,
Xapplying the modifications described by the change to this
Xintegration directory,
Xthen building and testing all over again.
X.LP
XThis re-build and re-test is to ensure that no
Xspecial aspect of the developers environment influenced the
Xsuccess up to this point,
Xsuch as a unique environment variable setting.
XThe re-build also ensures that all of the files in the baseline,
Xremembering that this includes source files and all other intermediate files
Xrequired by the build process,
Xensures that all of these files are consistent with each other,
Xthat the baseline is self-consistent.
XThe definition of the baseline is that it passes its own tests,
Xso the tests are run on the baseline.
X.LP
XUse the
X.I aeib
Xcommand to begin integration.
X.LP
XThe
X.I aeb
Xcommand is used to build the integration copy of the change.
X.LP
XThe
X.I aet
Xcommand is used to test the integration copy of the change.
X.LP
XOn later changes,
Xthe integration may also require the
X.I "aet -bl"
Xcommand to test the change against the baseline.
XThis tests ensures that the test
X.I fails
Xagainst the baseline.
XThis failure is to ensure that bug fixes are accompanied
Xby tests which reproduce the bug initially,
Xand that the change has fixed it.
XNew functionality, naturally,
Xwill not be present in the old baseline,
Xand so tests of new functionality will also fail against the old baseline.
X.LP
XLater changes may also have the regression tests run,
Xusing the
X.I "aet -reg"
Xcommand.
XThis can be a very time-consuming step
Xfor projects with a long history,
Xand thus a large collection of tests.
XThe
X.I aet
Xcommand can also be used to run "representative" sets of existing tests,
Xbut a full regression test run is recommended before a major release,
Xor, say, weekly if it will complete over the weekend.
XThis command is also available to developers,
Xso that they have fewer surprises from irate integrators.
X.LP
XThe integrator may use the
X.I aeifail
Xcommand to return a change to its developer for further work;
Xa reason must be supplied, and should include relevant excerpts from the build
Xlog in the case of a build failure (not the \fIwhole\fP log!),
Xor a list of the tests which failed for test failures.
X.LP
XThe 
X.I aeipass
Xcommand may be used to pass an integration.
XWhen the change passes,
Xthe file histories are updated.
XIn the case of the first change,
Xthe history is created,
Xand problems with the
X.I "config"
Xfile's history commands will
Xbe revealed at this point.
XThe integration won't pass,
Xand should be failed,
Xso that the developer may effect repairs.
XThere are rarely problems at this point for subsequent changes,
Xexcept for disk space problems.
X.LP
XOnce the history is successfully updated,
Xaegis renames the integration directory  as the baseline,
Xand throws the old baseline away.
XThe development directory is deleted at this time, too.
X.nh 2 "What to do Next"
X.LP
XThere,
Xthe first change is completed.
XThe whole cycle may now be repeated,
Xstarting at "Create Change,"
Xfor all subsequent changes,
Xwith very few differences.
X.LP
XIt is recommended that you read the
X.I "Change Development Cycle"
X chapter
Xfor a full worked
Xexample of the first four changes of an example project,
Xincluding some of the twists which occur in real-world use of aegis.
X.LP
XRemember, too, the definition:
X.DS
X\fBaegis\fP (ee.j.iz) \fIn.\fP a protection, a defence.
X.DE
XIt is not always the case that aegis exists to make life "easier" for
Xthe software engineers.
XThe goal is to have a baseline which always "works",
Xwhere "works" is defined as passing all of its own tests.
XWherever possible,
Xthe aegis program attempts to be as helpful and as unintrusive as possible,
Xbut when the "working" definition is threatened,
Xthe aegis program intrudes as necessary.
X(Example: you can't do an integrate pass without the integration copy
Xbuilding successfully.)
X.LP
XAll of the "extra work" of writing tests is a long-term win,
Xwhere old problems never again reappear.
XAll of the "extra work" of reviewing changes means that another pair of eyes
Xsights the code and finds potential problems before they manifest
Xthemselves in shipped product.
XAll of the "extra work" of integration ensures that the baseline always works,
Xand is always self-consistent.
XAll of the "extra work" of having a baseline and separate
Xdevelopment directories allows multiple parallel development,
Xwith no inter-developer interference;
Xand the baseline always works, it is never in an "in-between" state.
XIn each case,
Xnot doing this "extra work" is a false economy.
X.1C
END_OF_FILE
if test 12295 -ne `wc -c <'doc/cA.0.so'`; then
    echo shar: \"'doc/cA.0.so'\" unpacked with wrong size!
fi
# end of 'doc/cA.0.so'
fi
if test -f 'fmtgen/type_struc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fmtgen/type_struc.c'\"
else
echo shar: Extracting \"'fmtgen/type_struc.c'\" \(10569 characters\)
sed "s/^X//" >'fmtgen/type_struc.c' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: struct types function generation
X */
X
X#include <type.h>
X#include <indent.h>
X#include <mem.h>
X#include <id.h>
X#include <error.h>
X
X
Xtypedef struct type_struct_ty type_struct_ty;
Xstruct type_struct_ty
X{
X	/* inherited */
X	TYPE_T
X
X	/* instance variables */
X	parse_list_ty	*list;
X	int		toplevel;
X};
X
X
Xstatic void gen_include _((type_ty *, string_ty *));
X
Xstatic void
Xgen_include(type, name)
X	type_ty		*type;
X	string_ty	*name;
X{
X	parse_list_ty	*np;
X	type_struct_ty	*type2;
X	int		bitno;
X
X	type2 = (type_struct_ty *)type;
X	indent_putchar('\n');
X	indent_printf("#ifndef %s_DEF\n", name->str_text);
X	indent_printf("#define %s_DEF\n", name->str_text);
X	indent_printf("\n");
X	for (bitno = 0, np = type2->list; np; np = np->next, ++bitno)
X	{
X		indent_printf
X		(
X			"#define\t%s_%s_mask\t((unsigned long)1 << %d)\n",
X			name->str_text,
X			np->name->str_text,
X			bitno
X		);
X	}
X	indent_printf("\n");
X	indent_printf("typedef struct %s *%s;\n", name->str_text, name->str_text);
X	indent_printf("struct %s\n", name->str_text);
X	indent_printf("{\n"/*}*/);
X	indent_printf("%s\1mask;\n", "unsigned long");
X	for (np = type2->list; np; np = np->next)
X	{
X		type_ty		*tp;
X
X		if (!id_search(np->name, ID_CLASS_FIELD, (long *)&tp))
X			fatal("field \"%s\" vanished!", np->name->str_text);
X		type_gen_include_declarator(tp, np->name, 0);
X	}
X	indent_printf(/*{*/"};\n");
X	indent_printf("#endif /* %s_DEF */\n", name->str_text);
X
X	indent_putchar('\n');
X	indent_printf("extern type_ty %s_type;\n", name->str_text);
X
X	indent_putchar('\n');
X	if (type2->toplevel)
X		indent_printf("void %s_write _((%s));\n", name->str_text, name->str_text);
X	else
X		indent_printf("void %s_write _((char *, %s));\n", name->str_text, name->str_text);
X}
X
X
Xstatic void gen_include_declarator _((type_ty *, string_ty *, int));
X
Xstatic void
Xgen_include_declarator(type, name, is_a_list)
X	type_ty		*type;
X	string_ty	*name;
X	int		is_a_list;
X{
X	char		*deref;
X
X	deref = (is_a_list ? "*" : "");
X	indent_printf("%s\1%s%s;\n", type->name->str_text, deref, name->str_text);
X}
X
X
Xstatic void gen_code _((type_ty *, string_ty *));
X
Xstatic void
Xgen_code(type, name)
X	type_ty		*type;
X	string_ty	*name;
X{
X	parse_list_ty	*np;
X	type_struct_ty	*type2;
X	static int	done_table;
X	static int	done_offsetof;
X
X	if (!done_offsetof)
X	{
X		done_offsetof = 1;
X		indent_putchar('\n');
X		indent_printf("#ifndef offsetof\n");
X		indent_printf
X		(
X	"#define offsetof(a, b)\t((size_t)((char *)&((a *)0)->b - (char *)0))\n"
X		);
X		indent_printf("#endif\n");
X	}
X
X	type2 = (type_struct_ty *)type;
X	indent_putchar('\n');
X	indent_printf("void\n");
X	if (type2->toplevel)
X		indent_printf("%s_write(this)\n", name->str_text);
X	else
X		indent_printf("%s_write(name, this)\n", name->str_text);
X	indent_more();
X	if (!type2->toplevel)
X		indent_printf("%s\1*name;\n", "char");
X	indent_printf("%s\1this;\n", name->str_text);
X	indent_less();
X	indent_printf("{\n"/*}*/);
X	indent_printf("if (!this)\n");
X	indent_more();
X	indent_printf("return;\n");
X	indent_less();
X	if (type2->toplevel)
X		indent_printf("trace((\"%s_write(this = %%08lX)\\n{\\n\"/*}*/, this));\n", name->str_text);
X	else
X		indent_printf("trace((\"%s_write(name = \\\"%%s\\\", this = %%08lX)\\n{\\n\"/*}*/, name, this));\n", name->str_text);
X	if (!type2->toplevel)
X	{
X		indent_printf("if (name)\n");
X		indent_more();
X		indent_printf("indent_printf(\"%%s =\\n\", name);\n");
X		indent_less();
X		indent_printf("indent_printf(\"{\\n\"/*}*/);\n");
X	}
X	for (np = type2->list; np; np = np->next)
X	{
X		type_ty *tp;
X
X		id_search(np->name, ID_CLASS_FIELD, (long *)&tp);
X		type_gen_code_declarator(tp, np->name, 0);
X	}
X	if (!type2->toplevel)
X	{
X		indent_printf("indent_printf(/*{*/\"}\");\n");
X		indent_printf("if (name)\n");
X		indent_more();
X		indent_printf("indent_printf(\";\\n\");\n");
X		indent_less();
X	}
X	indent_printf("trace((/*{*/\"}\\n\"));\n");
X	indent_printf(/*{*/"}\n");
X
X	indent_putchar('\n');
X	indent_printf("static void *%s_alloc _((void));\n", name->str_text);
X
X	indent_putchar('\n');
X	indent_printf("static void *\n");
X	indent_printf("%s_alloc()\n", name->str_text);
X	indent_printf("{\n"/*}*/);
X	indent_printf("%s\1*result;\n", "void");
X	indent_putchar('\n');
X	indent_printf("trace((\"%s_alloc()\\n{\\n\"/*}*/));\n", name->str_text);
X	indent_printf
X	(
X		"result = (void *)mem_alloc_clear(sizeof(struct %s));\n",
X		name->str_text
X	);
X	indent_printf("trace((/*{*/\"return %%08lX;\\n}\\n\", (long)result));\n");
X	indent_printf("return result;\n");
X	indent_printf(/*{*/"}\n");
X
X	indent_putchar('\n');
X	indent_printf("static void %s_free _((void *));\n", name->str_text);
X
X	indent_putchar('\n');
X	indent_printf("static void\n");
X	indent_printf("%s_free(that)\n", name->str_text);
X	indent_more();
X	indent_printf("%s\1*that;\n", "void");
X	indent_less();
X	indent_printf("{\n"/*}*/);
X	indent_printf("%s\1this = (%s)that;\n", name->str_text, name->str_text);
X	indent_putchar('\n');
X	indent_printf("if (!this)\n");
X	indent_more();
X	indent_printf("return;\n");
X	indent_less();
X	indent_printf("trace((\"%s_free(this = %%08lX)\\n{\\n\"/*}*/, this));\n", name->str_text);
X	for (np = type2->list; np; np = np->next)
X	{
X		type_ty		*tp;
X
X		id_search(np->name, ID_CLASS_FIELD, (long *)&tp);
X		type_gen_free_declarator(tp, np->name, 0);
X	}
X	indent_printf("mem_free((char *)this);\n");
X	indent_printf("trace((/*{*/\"}\\n\"));\n");
X	indent_printf(/*{*/"}\n");
X
X	if (!done_table)
X	{
X		indent_printf("\n");
X		indent_printf("typedef struct table_ty table_ty;\n");
X		indent_printf("struct table_ty\n");
X		indent_printf("{\n");
X		indent_printf("%s\1*name;\n", "char");
X		indent_printf("%s\1offset;\n", "size_t");
X		indent_printf("%s\1*type;\n", "type_ty");
X		indent_printf("%s\1mask;\n", "unsigned long");
X		indent_printf("%s\1*fast_name;\n", "string_ty");
X		indent_printf("};\n");
X		done_table = 1;
X	}
X
X	indent_putchar('\n');
X	indent_printf
X	(
X		"static int %s_parse _((void *, string_ty *, type_ty **,\n\
Xvoid **, unsigned long *));\n",
X		name->str_text
X	);
X
X	indent_putchar('\n');
X	indent_printf("static int\n");
X	indent_printf("%s_parse(that, name, type_pp, addr_p, mask_p)\n", name->str_text);
X	indent_more();
X	indent_printf("%s\1*that;\n", "void");
X	indent_printf("%s\1*name;\n", "string_ty");
X	indent_printf("%s\1**type_pp;\n", "type_ty");
X	indent_printf("%s\1**addr_p;\n", "void");
X	indent_printf("%s\1*mask_p;\n", "unsigned long");
X	indent_less();
X	indent_printf("{\n"/*}*/);
X	indent_printf("%s\1table[] =\n", "static table_ty");
X	indent_printf("{\n"/*}*/);
X	for (np = type2->list; np; np = np->next)
X	{
X		type_ty		*tp;
X
X		id_search(np->name, ID_CLASS_FIELD, (long *)&tp);
X		indent_printf("{\n"/*}*/);
X		indent_printf("\"%s\",\n", np->name->str_text);
X		indent_printf
X		(
X			"offsetof(struct %s, %s),\n",
X			name->str_text,
X			np->name->str_text
X		);
X		indent_printf("&%s_type,\n", tp->name->str_text);
X		indent_printf
X		(
X			"%s_%s_mask,\n",
X			name->str_text,
X			np->name->str_text
X		);
X		indent_printf(/*{*/"},\n");
X	}
X	if (!type2->list)
X		indent_printf("{ \"\", },\n");
X	indent_printf(/*{*/"};\n");
X	indent_printf("%s\1this = (%s)that;\n", name->str_text, name->str_text);
X	indent_printf("%s\1*tp;\n", "table_ty");
X	indent_printf("%s\1result;\n", "int");
X	indent_putchar('\n');
X	indent_printf("trace((\"%s_parse(this = %%08lX, name = %%08lX, type_pp = %%08lX, addr_p = %%08lX)\\n{\\n\"/*}*/, this, name, type_pp, addr_p));\n", name->str_text);
X	indent_printf("result = -1;\n");
X	indent_printf("for (tp = table; tp < ENDOF(table); ++tp)\n");
X	indent_printf("{\n");
X	indent_printf("if (!tp->fast_name)\n");
X	indent_more();
X	indent_printf("tp->fast_name = str_from_c(tp->name);\n");
X	indent_less();
X	indent_printf("if (str_equal(name, tp->fast_name))\n");
X	indent_printf("{\n"/*}*/);
X	indent_printf("*type_pp = tp->type;\n");
X	indent_printf("trace_pointer(*type_pp);\n");
X	indent_printf("*addr_p = (void *)((char *)this + tp->offset);\n");
X	indent_printf("trace_pointer(*addr_p);\n");
X	indent_printf("*mask_p = tp->mask;\n");
X	indent_printf("result = 0;\n");
X	indent_printf("break;\n");
X	indent_printf(/*{*/"}\n");
X	indent_printf(/*{*/"}\n");
X	indent_printf("trace((/*{*/\"return %%d;\\n}\\n\", result));\n");
X	indent_printf("return result;\n");
X	indent_printf(/*{*/"}\n");
X
X	indent_putchar('\n');
X	indent_printf("type_ty %s_type =\n", name->str_text);
X	indent_printf("{\n"/*}*/);
X	indent_printf("type_class_struct,\n");
X	indent_printf("\"%s\",\n", name->str_text);
X	indent_printf("%s_alloc,\n", name->str_text);
X	indent_printf("%s_free,\n", name->str_text);
X	indent_printf("0, /* enum_parse */\n");
X	indent_printf("0, /* list_parse */\n");
X	indent_printf("%s_parse,\n", name->str_text);
X	indent_printf(/*{*/"};\n");
X}
X
X
Xstatic void gen_code_declarator _((type_ty *, string_ty *, int));
X
Xstatic void
Xgen_code_declarator(type, name, is_a_list)
X	type_ty		*type;
X	string_ty	*name;
X	int		is_a_list;
X{
X	indent_printf("%s_write("/*)*/, type->name->str_text);
X	if (is_a_list)
X		indent_printf("(char *)0");
X	else
X		indent_printf("\"%s\"", name->str_text);
X	indent_printf(/*(*/", this->%s);\n", name->str_text);
X}
X
X
Xstatic void gen_free_declarator _((type_ty *, string_ty *, int));
X
Xstatic void
Xgen_free_declarator(type, name, is_a_list)
X	type_ty		*type;
X	string_ty	*name;
X	int		is_a_list;
X{
X	indent_printf("%s_free(this->%s);\n", type->name->str_text, name->str_text);
X}
X
X
Xstatic type_method_ty method =
X{
X	gen_include,
X	gen_include_declarator,
X	gen_code,
X	gen_code_declarator,
X	gen_free_declarator,
X};
X
X
Xtype_ty *
Xtype_create_struct(name, list, toplevel)
X	string_ty	*name;
X	parse_list_ty	*list;
X	int		toplevel;
X{
X	type_struct_ty	*type;
X
X	type = (type_struct_ty *)mem_alloc(sizeof(type_struct_ty));
X	type->class = type_class_struct;
X	type->method = &method;
X	type->name = str_copy(name);
X	type->list = list;
X	type->toplevel = toplevel;
X	id_assign(name, ID_CLASS_TYPE, (long)type);
X	return (type_ty *)type;
X}
END_OF_FILE
if test 10569 -ne `wc -c <'fmtgen/type_struc.c'`; then
    echo shar: \"'fmtgen/type_struc.c'\" unpacked with wrong size!
fi
# end of 'fmtgen/type_struc.c'
fi
echo shar: End of archive 8 \(of 19\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 19 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
