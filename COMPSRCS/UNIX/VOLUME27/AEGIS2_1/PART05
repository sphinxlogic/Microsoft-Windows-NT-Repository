Newsgroups: comp.sources.unix
From: pmiller@bmr.gov.au (Peter Miller)
Subject: v27i040: aegis - project change supervisor (V2.1), Part05/19
References: <1.748951883.12788@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: pmiller@bmr.gov.au (Peter Miller)
Posting-Number: Volume 27, Issue 40
Archive-Name: aegis-2.1/part05

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 19)."
# Contents:  aegis/cstate.def aegis/help.c aegis/parse.c aegis/undo.c
#   common/option.c common/word.c doc/c2.2.so doc/c2.3.so doc/c4.1.so
#   doc/c7.4.so doc/cB.0.so doc/cC.0.so fmtgen/main.c
#   fmtgen/type_enum.c man5/aecstate.5 man5/aepattr.so man5/aepconf.5
#   man5/aesub.5 script/xaegis.tcl test/00/t0004a.sh test/00/t0007a.sh
#   test/00/t0016a.sh test/00/t0018a.sh
# Wrapped by vixie@gw.home.vix.com on Sat Sep 25 03:00:33 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'aegis/cstate.def' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aegis/cstate.def'\"
else
echo shar: Extracting \"'aegis/cstate.def'\" \(5498 characters\)
sed "s/^X//" >'aegis/cstate.def' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: change state file contents definition
X *
X * if you cange this file, don't forget to change
X *	man5/aecstate.5
X */
X
X#include <cattr.def>
X
Xstate =
X(
X	/*
X	 * The change has been created,
X	 * but has yet to be worked on.
X	 */
X	awaiting_development,
X
X	/*
X	 * The change is being developed.
X	 */
X	being_developed,
X
X	/*
X	 * The change has been developed,
X	 * and is being reviewed.
X	 * (There is no 'awaiting_review' state.)
X	 */
X	being_reviewed,
X
X	/*
X	 * The change has passed review,
X	 * and is queued ready for integration.
X	 */
X	awaiting_integration,
X
X	/*
X	 * The change is being integrated.
X	 */
X	being_integrated,
X
X	/*
X	 * The change has been completed and is now
X	 * part of the baseline.
X	 * Changes in this state can not be reversed.
X	 */
X	completed
X);
X
X/*
X * This field records the delta number for this change.
X * It is only present if the change is in one of
X * the 'being_integrated' or 'completed' states.
X */
Xdelta_number = integer;
X
X/*
X * This field records the last change integrated into the project.
X * If it disagrees with the project, a 'project_file_command' (from pconf)
X * needs to be executed at the next build.
X */
Xproject_file_command_sync = integer;
X
X/*
X * This field records the time the last successful
X * 'aegis -Test' command was run.
X * It is only present in the 'being_developed' and 'being_integrated' states.
X */
Xtest_time = integer;
X
X/*
X * This field records the time the last successful
X * 'aegis -Test -BaseLine' command was run.
X * It is only present in the 'being_developed' and 'being_integrated' states.
X */
Xtest_baseline_time = integer;
X
X/*
X * This field records the time the last successful
X * 'aegis -Test -Regression' command was run.
X * It is only present in the 'being_developed' and 'being_integrated' states.
X */
Xregression_test_time = integer;
X
X/*
X * This field records the time the last successful
X * 'aegis -Build' command was run.
X * It is only present in the 'being_developed' and 'being_integrated' states.
X */
Xbuild_time = integer; /* time() */
X
X/*
X * This field is the absolute path of the change's development directory.
X * It is only present of the change is in a state
X * between 'being_developed' and 'being_integrated' inclusive.
X */
Xdevelopment_directory = string;
X
X/*
X * This field is the absolute path of the change's integration directory.
X * It is only present of the change is in the 'being_integrated' state.
X */
Xintegration_directory = string;
X
X/*
X * This field records the history of the change,
X * in the form of state transitions.
X */
Xhistory = 
X[
X	{
X		/*
X		 * This field records the time the state transition occured.
X		 */
X		when = integer;
X
X		/*
X		 * This field records what happened.
X		 * Valid value names echo the various aegis functions.
X		 */
X		what =
X		(
X			new_change,
X			develop_begin,
X			develop_begin_undo,
X			develop_end,
X			develop_end_undo,
X			review_pass,
X			review_pass_undo,
X			review_fail,
X			integrate_begin,
X			integrate_begin_undo,
X			integrate_pass,
X			integrate_fail
X		);
X
X		/*
X		 * This field records the user name of the user who
X		 * caused the state transition.
X		 */
X		who = string; /* the user name */
X
X		/*
X		 * This field is optional.
X		 * It is a comment of some sort.
X		 * In the cause of review_file and integrate_fail,
X		 * this field will contain why the change failed.
X		 */
X		why = string;
X	}
X];
X
X/*
X * This field is a list of all the files in the change.
X */
Xsrc =
X[
X	{
X		/*
X		 * This file names the file.
X		 * The name is relative to the root of the
X		 * baseline directory tree.
X		 */
X		file_name = string;
X
X		/*
X		 * This field describes what is being done with the file.
X		 */
X		action = file_action;
X
X		/*
X		 * This field records the edit number of the file
X		 * when it was added to the change (or updated using the
X		 * 'aegis -DIFFerence' command).
X		 * This field is not present for new files.
X		 */
X		edit_number = string;
X
X		/*
X		 * This field describes what function the file serves.
X		 */
X		usage = file_usage;
X
X		/*
X		 * These fields are set by a successful
X		 * 'aegis -DIFFerence' command to the last-time-modified
X		 * of the source file and the difference listing.
X		 * It is only present between the 'being_developed' and
X		 * 'being_integrated' states, inclusive.
X		 * This allows checking that the files have not been modified
X		 * at the develop_end, review_pass and integrate_begin
X		 * state transitions.
X		 */
X		diff_time = integer; /* time() */
X		diff_file_time = integer; /* time() */
X
X		/*
X		 * To change the name of a file,
X		 * a combination of aerm and aenf are used.
X		 * With deleted files, this field is used to say where it went.
X		 * With new files, this field is used to say where it came from.
X		 */
X		move = string;
X	}
X];
END_OF_FILE
if test 5498 -ne `wc -c <'aegis/cstate.def'`; then
    echo shar: \"'aegis/cstate.def'\" unpacked with wrong size!
fi
# end of 'aegis/cstate.def'
fi
if test -f 'aegis/help.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aegis/help.c'\"
else
echo shar: Extracting \"'aegis/help.c'\" \(5412 characters\)
sed "s/^X//" >'aegis/help.c' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to provide consistent treatment of -Help options
X */
X
X#include <ctype.h>
X#include <stdio.h>
X#include <string.h>
X#include <stdlib.h>
X#include <unistd.h>
X
X#include <arglex2.h>
X#include <error.h>
X#include <gonzo.h>
X#include <help.h>
X#include <option.h>
X#include <pager.h>
X#include <patchlevel.h>
X#include <trace.h>
X#include <undo.h>
X
X
Xstatic char *cr[] =
X{
X	"%s version %v",
X	"Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.",
X	"All rights reserved.",
X	"",
X	"The %s program comes with ABSOLUTELY NO WARRANTY;",
X	"for details use the '%s -VERSion Warranty' command.",
X	"The %s program is free software, and you are welcome to",
X	"redistribute it under certain conditions;",
X	"for details use the '%s -VERSion Redistribution' command.",
X};
X
Xstatic char *au[] =
X{
X	"Peter Miller   UUCP     uunet!munnari!bmr.gov.au!pmiller",
X	"/\\/\\*          Internet pmiller@bmr.gov.au",
X};
X
X
Xstatic void interpret _((FILE *, char **, int, char *));
X
Xstatic void
Xinterpret(fp, text, text_len, prefix)
X	FILE	*fp;
X	char	**text;
X	int	text_len;
X	char	*prefix;
X{
X	char	*progname;
X	int	j;
X
X	trace(("interpret()\n{\n"/*}*/));
X	progname = option_progname_get();
X	for (j = 0; j < text_len; ++j)
X	{
X		char	indent[10];
X		char	*ip1;
X		char	*ip2;
X		char	*s;
X
X		s = text[j];
X		strcpy(indent, prefix);
X		ip2 = indent + strlen(indent);
X		ip1 = s;
X		while (isspace(*ip1))
X			*ip2++ = *ip1++;
X		*ip2 = 0;
X		if (ip1[0] == '%' && isupper(ip1[1]) && !ip1[2])
X		{
X			switch (ip1[1])
X			{
X			default:
X				assert(0);
X				break;
X
X			case 'C':
X				interpret(fp, cr, SIZEOF(cr), indent);
X				break;
X
X			case 'A':
X				interpret(fp, au, SIZEOF(au), indent);
X				break;
X			}
X			continue;
X		}
X		if (*prefix)
X			fputs(prefix, fp);
X		while (*s)
X		{
X			if (*s != '%')
X				putc(*s, fp);
X			else
X			{
X				switch (*++s)
X				{
X				default:
X					assert(0);
X					break;
X
X				case '%':
X					putc(*s, fp);
X					break;
X
X				case 's':
X					fputs(progname, fp);
X					break;
X
X				case 'v':
X					fputs(PATCHLEVEL, fp);
X					break;
X				}
X			}
X			++s;
X		}
X		fputc('\n', fp);
X		if (ferror(fp))
X			pager_error(fp);
X	}
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xhelp(text, text_len, usage)
X	char	**text;
X	int	text_len;
X	void	(*usage)_((void));
X{
X	FILE	*fp;
X
X	/*
X	 * collect the rest of thge command line,
X	 * if necessary
X	 */
X	trace(("help(text = %08lX, text_len = %d, usage = %08lX)\n{\n"/*}*/,
X		text, text_len, usage));
X	if (usage)
X	{
X		arglex();
X		while (arglex_token != arglex_token_eoln)
X			generic_argument(usage);
X	}
X
X	/*
X	 * paginate output if appropriate
X	 */
X	fp = pager_open();
X
X	/*
X	 * do what they asked
X	 */
X	interpret(fp, text, text_len, "");
X
X	/*
X	 * close the paginator
X	 */
X	pager_close(fp);
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xgeneric_argument(usage)
X	void	(*usage)_((void));
X{
X	trace(("generic_argument()\n{\n"/*}*/));
X	switch (arglex_token)
X	{
X	default:
X		bad_argument(usage);
X		/* NOTREACHED */
X
X	case arglex_token_library:
X		if (arglex() != arglex_token_string)
X			usage();
X		gonzo_library_append(arglex_value.alv_string);
X		arglex();
X		break;
X
X	case arglex_token_page_length:
X		if (arglex() != arglex_token_number)
X			usage();
X		option_page_length_set(arglex_value.alv_number);
X		arglex();
X		break;
X
X	case arglex_token_page_width:
X		if (arglex() != arglex_token_number)
X			usage();
X		option_page_width_set(arglex_value.alv_number);
X		arglex();
X		break;
X
X	case arglex_token_terse:
X		option_terse_set();
X		arglex();
X		break;
X
X	case arglex_token_trace:
X		if (arglex() != arglex_token_string)
X			usage();
X		for (;;)
X		{
X			trace_enable(arglex_value.alv_string);
X			if (arglex() != arglex_token_string)
X				break;
X		}
X#ifndef DEBUG
X		error
X		(
X"Warning: the -TRace option is only effective when the %s program \
Xis compiled using the DEBUG define in the conf/main.h include file.",
X			option_progname_get()
X		);
X#endif
X		break;
X
X	case arglex_token_unformatted:
X		option_unformatted_set();
X		arglex();
X		break;
X
X	case arglex_token_verbose:
X		option_verbose_set();
X		arglex();
X		break;
X	}
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xbad_argument(usage)
X	void	(*usage)_((void));
X{
X	trace(("bad_argument()\n{\n"/*}*/));
X	switch (arglex_token)
X	{
X	case arglex_token_string:
X		error("misplaced file name (\"%s\")", arglex_value.alv_string);
X		break;
X
X	case arglex_token_number:
X		error("misplaced number (%s)", arglex_value.alv_string);
X		break;
X
X	case arglex_token_option:
X		error("unknown \"%s\" option", arglex_value.alv_string);
X		break;
X
X	case arglex_token_eoln:
X		error("command line too short");
X		break;
X
X	default:
X		error("misplaced \"%s\" option", arglex_value.alv_string);
X		break;
X	}
X	usage();
X	trace((/*{*/"}\n"));
X	quit(1);
X	/* NOTREACHED */
X}
END_OF_FILE
if test 5412 -ne `wc -c <'aegis/help.c'`; then
    echo shar: \"'aegis/help.c'\" unpacked with wrong size!
fi
# end of 'aegis/help.c'
fi
if test -f 'aegis/parse.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aegis/parse.c'\"
else
echo shar: Extracting \"'aegis/parse.c'\" \(5220 characters\)
sed "s/^X//" >'aegis/parse.c' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to parse aegis' data files
X */
X
X#include <error.h>
X#include <gram.h>
X#include <lex.h>
X#include <mem.h>
X#include <parse.h>
X#include <trace.h>
X
Xstatic sem_ty *sem_root;
X
X
Xvoid *
Xparse(filename, type)
X	char	*filename;
X	type_ty	*type;
X{
X	void	*addr;
X
X	trace(("parse(filename = \"%s\", type = %08lx)\n{\n"/*}*/,
X		filename, type));
X	lex_open(filename);
X	sem_push(type, &addr);
X
X	trace(("gram_parse()\n{\n"/*}*/));
X	gram_parse();
X	trace((/*{*/"}\n"));
X
X	while (sem_root)
X		sem_pop();
X	lex_close();
X	trace(("return %08lX;\n", addr));
X	trace((/*{*/"}\n"));
X	return addr;
X}
X
X
Xvoid
Xsem_push(type, addr)
X	type_ty		*type;
X	void		*addr;
X{
X	sem_ty		*sp;
X
X	trace(("sem_push(type = %08lX, addr = %08lX)\n{\n"/*}*/, type, addr));
X	trace(("type->class == %s;\n", type ? type_class_name(type) : "void"));
X	sp = (sem_ty *)mem_alloc_clear(sizeof(sem_ty));
X	sp->type = type;
X	sp->addr = addr;
X	sp->next = sem_root;
X	sem_root = sp;
X	if (type && type->alloc)
X	{
X		*(void **)sp->addr = type->alloc();
X		trace
X		((
X			"sp->addr = %08lX->%08lX\n",
X			sp->addr,
X			*(void **)sp->addr
X		));
X	}
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xsem_pop()
X{
X	sem_ty *x;
X
X	trace(("sem_pop()\n{\n"/*}*/));
X	x = sem_root;
X	sem_root = x->next;
X	mem_free((char *)x);
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xsem_integer(n)
X	long	n;
X{
X	trace(("sem_integer(n = %ld)\n{\n"/*}*/, n));
X	if (!sem_root->type)
X		goto done;
X	if (sem_root->type->class != type_class_integer)
X	{
X		gram_error
X		(
X			"value of type %s required",
X			type_class_name(sem_root->type)
X		);
X	}
X	else
X		*(long *)sem_root->addr = n;
X
X	/*
X	 * here for all exits
X	 */
X	done:
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xsem_string(s)
X	string_ty *s;
X{
X	trace(("sem_string(s = %08lX)\n{\n"/*}*/, s));
X	trace_string(s->str_text);
X	if (!sem_root->type)
X		goto done;
X	if (sem_root->type->class != type_class_string)
X	{
X		gram_error
X		(
X			"value of type %s required",
X			type_class_name(sem_root->type)
X		);
X	}
X	else
X	{
X		trace
X		((
X			"addr = %08lX->%08lX",
X			sem_root->addr,
X			*(void **)sem_root->addr
X		));
X		*(string_ty **)sem_root->addr = s;
X	}
X	
X	/*
X	 * here for all exits
X	 */
X	done:
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xsem_enum(s)
X	string_ty *s;
X{
X	trace(("sem_enum(s = %08lX)\n{\n"/*}*/, s));
X	trace_string(s->str_text);
X	if (!sem_root->type)
X		goto done;
X	if (sem_root->type->class != type_class_enum)
X	{
X		gram_error
X		(
X			"value of type %s required",
X			type_class_name(sem_root->type)
X		);
X	}
X	else
X	{
X		if (sem_root->type->enum_parse(s, sem_root->addr))
X		{
X			gram_error
X			(
X				"the name \"%s\" is not a valid enumerator",
X				s->str_text
X			);
X		}
X	}
X
X	/*
X	 * here for all exits
X	 */
X	done:
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xsem_list()
X{
X	trace(("sem_list()\n{\n"/*}*/));
X	if (!sem_root->type)
X	{
X		sem_push(0, 0);
X		goto done;
X	}
X	if (sem_root->type->class != type_class_list)
X	{
X		gram_error
X		(
X			"value of type %s required",
X			type_class_name(sem_root->type)
X		);
X		sem_push(0, 0);
X	}
X	else
X	{
X		type_ty	*type;
X		void	*addr;
X
X		sem_root->type->list_parse
X		(
X			*(void **)sem_root->addr,
X			&type,
X			&addr
X		);
X		sem_push(type, addr);
X	}
X
X	/*
X	 * here for all exits
X	 */
X	done:
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xsem_field(name)
X	string_ty	*name;
X{
X	trace(("sem_field(name = %08lX)\n{\n"/*}*/, name));
X	trace_string(name->str_text);
X	trace(("sem_root == %08lX;\n", sem_root));
X	trace(("sem_root->type == %08lX;\n", sem_root->type));
X	if (!sem_root->type)
X	{
X		sem_push(0, 0);
X		goto done;
X	}
X	if (sem_root->type->class != type_class_struct)
X	{
X		gram_error
X		(
X			"value of type %s required",
X			type_class_name(sem_root->type)
X		);
X		sem_push(0, 0);
X	}
X	else
X	{
X		type_ty		*type;
X		void		*addr;
X		unsigned long	mask;
X
X		if (!sem_root->type->struct_parse)
X			error("no struct parse");
X		if
X		(
X			sem_root->type->struct_parse
X			(
X				*(void **)sem_root->addr,
X				name,
X				&type,
X				&addr,
X				&mask
X			)
X		)
X		{
X			gram_error("field name \"%s\" not valid", name->str_text);
X			sem_push(0, 0);
X		}
X		else
X		{
X			unsigned long	*rmask;
X
X			/*
X			 * The first element of all the generated
X			 * structures is the mask field.
X			 */
X			trace(("mask = 0x%08lX;\n", mask));
X			rmask = *(unsigned long **)sem_root->addr;
X			if (*rmask & mask)
X			{
X				gram_error
X				(
X					"field \"%s\" redefined",
X					name->str_text
X				);
X			}
X			*rmask |= mask;
X			trace(("*rmask == 0x%08lX;\n", *rmask));
X			sem_push(type, addr);
X		}
X	}
X
X	/*
X	 * here for all exits
X	 */
X	done:
X	trace((/*{*/"}\n"));
X}
END_OF_FILE
if test 5220 -ne `wc -c <'aegis/parse.c'`; then
    echo shar: \"'aegis/parse.c'\" unpacked with wrong size!
fi
# end of 'aegis/parse.c'
fi
if test -f 'aegis/undo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'aegis/undo.c'\"
else
echo shar: Extracting \"'aegis/undo.c'\" \(5742 characters\)
sed "s/^X//" >'aegis/undo.c' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to store and enact file operations on transation abort
X */
X
X#include <error.h>
X#include <mem.h>
X#include <option.h>
X#include <os.h>
X#include <trace.h>
X#include <undo.h>
X
X
Xenum what_ty
X{
X	what_rename,
X	what_chmod,
X	what_chmod_errok,
X	what_unlink_errok,
X	what_rmdir_errok
X};
Xtypedef enum what_ty what_ty;
X
Xtypedef struct action_ty action_ty;
Xstruct action_ty
X{
X	what_ty		what;
X	string_ty	*path1;
X	string_ty	*path2;
X	int		arg1;
X	int		arg2;
X	action_ty	*next;
X	int		uid;
X	int		gid;
X	int		umask;
X};
X
Xstatic	action_ty	*head;
X
X
Xstatic action_ty *newlink _((what_ty));
X
Xstatic action_ty *
Xnewlink(what)
X	what_ty		what;
X{
X	action_ty	*new;
X
X	trace(("undo::newlink(what = %d)\n{\n"/*}*/, what));
X	new = (action_ty *)mem_alloc(sizeof(action_ty));
X	new->what = what;
X	new->next = head;
X	new->path1 = 0;
X	new->path2 = 0;
X	new->arg1 = 0;
X	new->arg2 = 0;
X	os_become_query(&new->uid, &new->gid, &new->umask);
X	head = new;
X	trace(("return %08lX;\n", new));
X	trace((/*{*/"}\n"));
X	return new;
X}
X
X
Xvoid
Xundo_rename(from, to)
X	string_ty	*from;
X	string_ty	*to;
X{
X	action_ty	*new;
X
X	trace(("undo_rename(from = %08lX, to = %08lX)\n{\n"/*}*/, from, to));
X	trace_string(from->str_text);
X	trace_string(to->str_text);
X	new = newlink(what_rename);
X	new->path1 = str_copy(from);
X	new->path2 = str_copy(to);
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xundo_chmod(path, mode)
X	string_ty	*path;
X	int		mode;
X{
X	action_ty	*new;
X
X	mode &= 07777;
X	trace(("undo_chmod(path = %08lX, mode = %05o)\n{\n"/*}*/, path, mode));
X	trace_string(path->str_text);
X	new = newlink(what_chmod);
X	new->path1 = str_copy(path);
X	new->arg1 = mode;
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xundo_chmod_errok(path, mode)
X	string_ty	*path;
X	int		mode;
X{
X	action_ty	*new;
X
X	mode &= 07777;
X	trace(("undo_chmod_errok(path = %08lX, mode = %05o)\n{\n"/*}*/, path, mode));
X	trace_string(path->str_text);
X	new = newlink(what_chmod_errok);
X	new->path1 = str_copy(path);
X	new->arg1 = mode;
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xundo_unlink_errok(path)
X	string_ty	*path;
X{
X	action_ty	*new;
X
X	trace(("undo_unlink_errok(path = %08lX)\n{\n"/*}*/, path));
X	trace_string(path->str_text);
X	new = newlink(what_unlink_errok);
X	new->path1 = str_copy(path);
X	trace((/*{*/"}\n"));
X}
X
Xvoid
Xundo_rmdir_errok(path)
X	string_ty	*path;
X{
X	action_ty	*new;
X
X	trace(("undo_rmdir_errok(path = %08lX)\n{\n"/*}*/, path));
X	trace_string(path->str_text);
X	new = newlink(what_rmdir_errok);
X	new->path1 = str_copy(path);
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xundo()
X{
X	static int	count;
X	action_ty	*ap;
X	char		*progname;
X
X	trace(("undo()\n{\n"/*}*/));
X	++count;
X	switch (count)
X	{
X	case 1:
X		while (os_become_active())
X			os_become_undo();
X		while (head)
X		{
X			/*
X			 * Take the first item off the list.
X			 */
X			ap = head;
X			head = ap->next;
X	
X			/*
X			 * Do the action
X			 */
X			trace(("ap = %08lX;\n", ap));
X			os_become(ap->uid, ap->gid, ap->umask);
X			switch (ap->what)
X			{
X			case what_rename:
X				os_rename(ap->path1, ap->path2);
X				break;
X
X			case what_chmod:
X				os_chmod(ap->path1, ap->arg1);
X				break;
X
X			case what_chmod_errok:
X				os_chmod_errok(ap->path1, ap->arg1);
X				break;
X
X			case what_unlink_errok:
X				os_unlink_errok(ap->path1);
X				break;
X	
X			case what_rmdir_errok:
X				os_rmdir_errok(ap->path1);
X				break;
X			}
X			os_become_undo();
X	
X			/*
X			 * Free the list element.
X			 */
X			str_free(ap->path1);
X			if (ap->path2)
X				str_free(ap->path2);
X			mem_free((char *)ap);
X		}
X		break;
X
X	case 2:
X		progname = option_progname_get();
X		error
X		(
X"A fatal error occurred while attempting to recover \
Xfrom an earlier fatal error.  \
XSome %s data may have been corrupted.  \
XInform the nearest %s guru immediately.",
X			progname,
X			progname
X		);
X		while (head)
X		{
X			ap = head;
X			head = ap->next;
X			switch (ap->what)
X			{
X			case what_rename:
X				error
X				(
X					"unfinished recovery: mv %s %s",
X					ap->path1->str_text,
X					ap->path2->str_text
X				);
X				break;
X
X			case what_chmod:
X			case what_chmod_errok:
X				error
X				(
X					"unfinished recovery: chmod %04o %s",
X					ap->arg1,
X					ap->path1->str_text
X				);
X				break;
X
X			case what_unlink_errok:
X				error
X				(
X					"unfinished recovery: rm %s",
X					ap->path1->str_text
X				);
X				break;
X
X			case what_rmdir_errok:
X				error
X				(
X					"unfinished recovery: rmdir %s",
X					ap->path1->str_text
X				);
X				break;
X			}
X	
X			/*
X			 * Free the list element.
X			 */
X			str_free(ap->path1);
X			if (ap->path2)
X				str_free(ap->path2);
X			mem_free((char *)ap);
X		}
X		break;
X
X	default:
X		/* probably an error writing stderr */
X		break;
X	}
X	--count;
X	trace((/*{*/"}\n"));
X}
X
X
Xvoid
Xundo_quitter(n)
X	int	n;
X{
X	if (n)
X		undo();
X}
X
X
Xvoid
Xundo_cancel()
X{
X	action_ty	*ap;
X
X	trace(("undo_cancel()\n{\n"/*}*/));
X	while (head)
X	{
X		/*
X		 * Take the first item off the list.
X		 */
X		ap = head;
X		head = ap->next;
X
X		/*
X		 * Free the list element.
X		 */
X		str_free(ap->path1);
X		if (ap->path2)
X			str_free(ap->path2);
X		mem_free((char *)ap);
X	}
X	trace((/*{*/"}\n"));
X}
END_OF_FILE
if test 5742 -ne `wc -c <'aegis/undo.c'`; then
    echo shar: \"'aegis/undo.c'\" unpacked with wrong size!
fi
# end of 'aegis/undo.c'
fi
if test -f 'common/option.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/option.c'\"
else
echo shar: Extracting \"'common/option.c'\" \(5384 characters\)
sed "s/^X//" >'common/option.c' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate command line options
X */
X
X#include <string.h>
X#include <stdio.h>
X#include <stdlib.h>
X#include <sys/ioctl.h>
X
X#include <error.h>
X#include <option.h>
X#include <trace.h>
X
X
X#define MIN_PAGE_WIDTH 40
X/* #define MAX_PAGE_WIDTH in option.h */
X#define DEFAULT_PAGE_WIDTH 80
X#define MIN_PAGE_LENGTH 10
X#define MAX_PAGE_LENGTH 30000
X#define DEFAULT_PAGE_LENGTH 24
X
X#define LEVEL_TERSE 1
X#define LEVEL_UNFORMATTED 2
X#define LEVEL_UNSET 3
X#define LEVEL_VERBOSE 4
X
Xstatic	int	page_length;
Xstatic	char	*progname;
Xstatic	int	verbose_flag = LEVEL_UNSET;
Xstatic	int	page_width;
X
X
Xvoid
Xoption_progname_set(s)
X	char		*s;
X{
X	/* do NOT put tracing in this function */
X	assert(s);
X	assert(!progname);
X	for (;;)
X	{
X		progname = strrchr(s, '/');
X
X		/*
X		 * we were invoked as
X		 *	progname -args
X		 */
X		if (!progname)
X		{
X			progname = s;
X			break;
X		}
X
X		/*
X		 * we were invoked as
X		 *	/usr/local/progname -args
X		 */
X		if (progname[1])
X		{
X			++progname;
X			break;
X		}
X
X		/*
X		 * this is real nasty:
X		 * it is possible to invoke us as
X		 *	/usr//local///bin////progname///// -args
X		 * and it is legal!!
X		 */
X		*progname = 0;
X	}
X}
X
X
Xchar *
Xoption_progname_get()
X{
X	/* do NOT put tracing in this function */
X	assert(progname);
X	return progname;
X}
X
X
Xstatic void too_many _((void));
X
Xstatic void
Xtoo_many()
X{
X	fatal
X	(
X	     "only one of -TERse and -UNFormatted and -Verbose may be specified"
X	);
X}
X
X
Xvoid
Xoption_verbose_set()
X{
X	trace(("option_set_verbose()\n{\n"/*}*/));
X	if (verbose_flag == LEVEL_VERBOSE)
X		fatal("duplicate -Verbose option");
X	if (verbose_flag != LEVEL_UNSET)
X		too_many();
X	verbose_flag = LEVEL_VERBOSE;
X	trace((/*{*/"}\n"));
X}
X
X
Xint
Xoption_verbose_get()
X{
X	return (verbose_flag == LEVEL_VERBOSE);
X}
X
X
Xvoid
Xoption_terse_set()
X{
X	trace(("option_set_terse()\n{\n"/*}*/));
X	if (verbose_flag == LEVEL_TERSE)
X		fatal("duplicate -TERse option");
X	if (verbose_flag != LEVEL_UNSET)
X		too_many();
X	verbose_flag = LEVEL_TERSE;
X	trace((/*{*/"}\n"));
X}
X
X
Xint
Xoption_terse_get()
X{
X	return (verbose_flag == LEVEL_TERSE);
X}
X
X
Xvoid
Xoption_unformatted_set()
X{
X	trace(("option_set_unformatted()\n{\n"/*}*/));
X	if (verbose_flag == LEVEL_UNFORMATTED)
X		fatal("duplicate -UNFormatted option");
X	if (verbose_flag != LEVEL_UNSET)
X		too_many();
X	verbose_flag = LEVEL_UNFORMATTED;
X	trace((/*{*/"}\n"));
X}
X
X
Xint
Xoption_unformatted_get()
X{
X	return
X	(
X		verbose_flag == LEVEL_TERSE
X	||
X		verbose_flag == LEVEL_UNFORMATTED
X	);
X}
X
X
Xstatic void default_page_sizes _((void));
X
Xstatic void
Xdefault_page_sizes()
X{
X	if (!page_width)
X	{
X		char	*cp;
X
X		cp = getenv("COLS");
X		if (cp)
X		{
X			int	n;
X
X			n = atoi(cp);
X			if (n > 0)
X			{
X				if (n < MIN_PAGE_WIDTH)
X					n = MIN_PAGE_WIDTH;
X				if (n > MAX_PAGE_WIDTH)
X					n = MAX_PAGE_WIDTH;
X				page_width = n;
X			}
X		}
X	}
X	if (!page_length)
X	{
X		char	*cp;
X
X		cp = getenv("LINES");
X		if (cp)
X		{
X			int	n;
X
X			n = atoi(cp);
X			if (n > 0)
X			{
X				if (n < MIN_PAGE_LENGTH)
X					n = MIN_PAGE_LENGTH;
X				if (n > MAX_PAGE_LENGTH)
X					n = MAX_PAGE_LENGTH;
X				page_length = n;
X			}
X		}
X	}
X
X#ifdef TIOCGWINSZ
X	if (!page_width || !page_length)
X	{
X		struct winsize	ws;
X
X		if (ioctl(0, TIOCGWINSZ, &ws) == 0)
X		{
X			if (!page_width && ws.ws_col > 0)
X			{
X				page_width = ws.ws_col;
X				if (page_width < MIN_PAGE_WIDTH)
X					page_width = MIN_PAGE_WIDTH;
X				if (page_width > MAX_PAGE_WIDTH)
X					page_width = MAX_PAGE_WIDTH;
X			}
X			if (!page_length && ws.ws_row > 0)
X			{
X				page_length = ws.ws_row;
X				if (page_length < MIN_PAGE_LENGTH)
X					page_length = MIN_PAGE_LENGTH;
X				if (page_length > MAX_PAGE_LENGTH)
X					page_length = MAX_PAGE_LENGTH;
X			}
X		}
X	}
X#endif
X
X	if (!page_width)
X		page_width = DEFAULT_PAGE_WIDTH;
X	if (!page_length)
X		page_length = DEFAULT_PAGE_LENGTH;
X}
X
X
Xvoid
Xoption_page_width_set(n)
X	int	n;
X{
X	if (page_width)
X		fatal("duplicate -Page_Width option");
X	if (n < MIN_PAGE_WIDTH || n > MAX_PAGE_WIDTH)
X		fatal("page width %d out of range", n);
X	page_width = n;
X}
X
X
Xint
Xoption_page_width_get()
X{
X	/*
X	 * must not generate a fatal error in this function,
X	 * as it is used by 'error.c' when reporting fatal errors.
X	 *
X	 * must not put tracing in this function,
X	 * because 'trace.c' uses it to determine the width.
X	 */
X	if (!page_width)
X		default_page_sizes();
X	return page_width;
X}
X
X
Xvoid
Xoption_page_length_set(n)
X	int	n;
X{
X	if (page_length)
X		fatal("duplicate -Page_Length option");
X	if (n < MIN_PAGE_LENGTH || n > MAX_PAGE_LENGTH)
X		fatal("page length %d out of range", n);
X	page_length = n;
X}
X
X
Xint
Xoption_page_length_get()
X{
X	if (!page_length)
X		default_page_sizes();
X	return page_length;
X}
END_OF_FILE
if test 5384 -ne `wc -c <'common/option.c'`; then
    echo shar: \"'common/option.c'\" unpacked with wrong size!
fi
# end of 'common/option.c'
fi
if test -f 'common/word.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common/word.c'\"
else
echo shar: Extracting \"'common/word.c'\" \(6331 characters\)
sed "s/^X//" >'common/word.c' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: functions to manipulate lists of strings
X */
X
X#include <ctype.h>
X#include <stddef.h>
X#include <string.h>
X#include <stdlib.h>
X#include <time.h>
X
X#include <main.h>
X#include <string.h>
X#include <word.h>
X#include <error.h>
X#include <mem.h>
X
X
X/*
X * NAME
X *	wl_append - append to a word list
X *
X * SYNOPSIS
X *	void wl_append(wlist *wlp, string_ty *wp);
X *
X * DESCRIPTION
X *	Wl_append is used to append to a word list.
X *
X * CAVEAT
X *	The word being appended IS copied.
X */
X
Xvoid
Xwl_append(wlp, w)
X	wlist		*wlp;
X	string_ty	*w;
X{
X	*(string_ty **)
X	enlarge
X	(
X		&wlp->wl_nwords,
X		(char **)&wlp->wl_word, sizeof(string_ty *)
X	) =
X		str_copy(w);
X}
X
X
X/*
X * NAME
X *	wl_free - free a word list
X *
X * SYNOPSIS
X *	void wl_free(wlist *wlp);
X *
X * DESCRIPTION
X *	Wl_free is used to free the contents of a word list
X *	when it is finished with.
X *
X * CAVEAT
X *	It is assumed that the contents of the word list were all
X *	created using strdup() or similar, and grown using wl_append().
X */
X
Xvoid
Xwl_free(wlp)
X	wlist		*wlp;
X{
X	int		j;
X
X	for (j = 0; j < wlp->wl_nwords; j++)
X		str_free(wlp->wl_word[j]);
X	if (wlp->wl_nwords)
X		free(wlp->wl_word);
X	wlp->wl_nwords = 0;
X	wlp->wl_word = 0;
X}
X
X
X/*
X * NAME
X *	wl_member - word list membership
X *
X * SYNOPSIS
X *	int wl_member(wlist *wlp, string_ty *wp);
X *
X * DESCRIPTION
X *	Wl_member is used to determine if the given word is
X *	contained in the given word list.
X *
X * RETURNS
X *	A zero if the word is not in the list,
X *	and a non-zero if it is.
X */
X
Xint
Xwl_member(wlp, w)
X	wlist		*wlp;
X	string_ty	*w;
X{
X	int		j;
X
X	for (j = 0; j < wlp->wl_nwords; j++)
X		if (str_equal(wlp->wl_word[j], w))
X			return 1;
X	return 0;
X}
X
X
X/*
X * NAME
X *	wl_copy - copy a word list
X *
X * SYNOPSIS
X *	void wl_copy(wlist *to, wlist *from);
X *
X * DESCRIPTION
X *	Wl_copy is used to copy word lists.
X *
X * RETURNS
X *	A copy of the 'to' word list is placed in 'from'.
X *
X * CAVEAT
X *	It is the responsibility of the caller to ensure that the
X *	new word list is freed when finished with, by a call to wl_free().
X */
X
Xvoid
Xwl_copy(to, from)
X	wlist		*to;
X	wlist		*from;
X{
X	int		j;
X
X	wl_zero(to);
X	for (j = 0; j < from->wl_nwords; j++)
X		wl_append(to, str_copy(from->wl_word[j]));
X}
X
X
X/*
X * NAME
X *	wl2str - form a string from a word list
X *
X * SYNOPSIS
X *	string_ty *wl2str(wlist *wlp, int start, int stop);
X *
X * DESCRIPTION
X *	Wl2str is used to form a string from a word list.
X *
X * RETURNS
X *	A pointer to the newly formed string in dynamic memory.
X *
X * CAVEAT
X *	It is the responsibility of the caller to ensure that the
X *	new string is freed when finished with, by a call to free().
X */
X
Xstring_ty *
Xwl2str(wl, start, stop)
X	wlist		*wl;
X	int		start;
X	int		stop;
X{
X	int		j;
X	static char	*tmp;
X	static size_t	tmplen;
X	size_t		length;
X	char		*pos;
X	string_ty	*s;
X
X	length = 0;
X	for (j = start; j <= stop && j < wl->wl_nwords; j++)
X	{
X		s = wl->wl_word[j];
X		if (s->str_length)
X		{
X			if (length)
X				++length;
X			length += s->str_length;
X		}
X	}
X
X	if (!tmp)
X	{
X		tmplen = length;
X		if (tmplen < 16)
X			tmplen = 16;
X		tmp = mem_alloc(tmplen);
X	}
X	else
X	{
X		if (tmplen < length)
X		{
X			tmplen = length;
X			mem_change_size(&tmp, tmplen);
X		}
X	}
X
X	pos = tmp;
X	for (j = start; j <= stop && j < wl->wl_nwords; j++)
X	{
X		s = wl->wl_word[j];
X		if (s->str_length)
X		{
X			if (pos != tmp)
X				*pos++ = ' ';
X			memcpy(pos, s->str_text, s->str_length);
X			pos += s->str_length;
X		}
X	}
X
X	s = str_n_from_c(tmp, length);
X	return s;
X}
X
X
X/*
X * NAME
X *	str2wl - string to word list
X *
X * SYNOPSIS
X *	void str2wl(wlist *wlp, string_ty *s);
X *
X * DESCRIPTION
X *	Str2wl is used to form a word list from a string.
X *
X * RETURNS
X *	The string is broken on spaces into words,
X *	using strndup() and wl_append().
X *
X * CAVEAT
X *	Quoting is not understood.
X */
X
Xvoid
Xstr2wl(slp, s, sep)
X	wlist		*slp;
X	string_ty	*s;
X	char		*sep;
X{
X	char		*cp;
X	int		more;
X
X	wl_zero(slp);
X	cp = s->str_text;
X	more = 0;
X	while (*cp || more)
X	{
X		string_ty	*w;
X		char		*cp1;
X		char		*cp2;
X
X		while (isspace(*cp))
X			cp++;
X		if (!*cp && !more)
X			break;
X		more = 0;
X		cp1 = cp;
X		if (sep)
X		{
X			while (*cp && !strchr(sep, *cp))
X				cp++;
X			if (*cp)
X			{
X				cp2 = cp + 1;
X				more = 1;
X			}
X			else
X				cp2 = cp;
X			while (cp > cp1 && isspace(cp[-1]))
X				cp--;
X		}
X		else
X		{
X			while (*cp && !isspace(*cp))
X				cp++;
X			if (*cp)
X				cp2 = cp + 1;
X			else
X				cp2 = cp;
X		}
X		w = str_n_from_c(cp1, cp - cp1);
X		wl_append(slp, w);
X		str_free(w);
X		cp = cp2;
X	}
X}
X
X
X/*
X * NAME
X *	wl_insert - a insert a word into a list
X *
X * SYNOPSIS
X *	void wl_insert(wlist *wlp, string_ty *wp);
X *
X * DESCRIPTION
X *	Wl_insert is similar to wl_append, however it does not
X *	append the word unless it is not already in the list.
X *
X * CAVEAT
X *	If the word is inserted it is copied.
X */
X
Xvoid
Xwl_append_unique(wlp, wp)
X	wlist		*wlp;
X	string_ty	*wp;
X{
X	int		j;
X
X	for (j = 0; j < wlp->wl_nwords; j++)
X		if (str_equal(wlp->wl_word[j], wp))
X			return;
X	wl_append(wlp, wp);
X}
X
X
X/*
X * NAME
X *	wl_delete - remove list member
X *
X * SYNOPSIS
X *	void wl_delete(wlist *wlp, string_ty *wp);
X *
X * DESCRIPTION
X *	The wl_delete function is used to delete a member of a word list.
X *
X * RETURNS
X *	void
X */
X
Xvoid
Xwl_delete(wlp, wp)
X	wlist		*wlp;
X	string_ty	*wp;
X{
X	int		j;
X	int		k;
X
X	for (j = 0; j < wlp->wl_nwords; ++j)
X	{
X		if (str_equal(wlp->wl_word[j], wp))
X		{
X			wlp->wl_nwords--;
X			for (k = j; k < wlp->wl_nwords; ++k)
X				wlp->wl_word[k] = wlp->wl_word[k + 1];
X			str_free(wp);
X			break;
X		}
X	}
X}
X
Xvoid
Xwl_zero(wlp)
X	wlist		*wlp;
X{
X	wlp->wl_nwords = 0;
X	wlp->wl_word = 0;
X}
END_OF_FILE
if test 6331 -ne `wc -c <'common/word.c'`; then
    echo shar: \"'common/word.c'\" unpacked with wrong size!
fi
# end of 'common/word.c'
fi
if test -f 'doc/c2.2.so' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/c2.2.so'\"
else
echo shar: Extracting \"'doc/c2.2.so'\" \(5756 characters\)
sed "s/^X//" >'doc/c2.2.so' <<'END_OF_FILE'
X.\"
X.\"	aegis - project change supervisor
X.\"	Copyright (C) 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: User Guide, The Change Development Cycle, The Reviewer
X.\"
X.bp
X.nh 2 "The Reviewer"
X.LP
XThe role of a reviewer is to check another user's work.
XYou are helped in this by aegis,
Xbecause changes can never reach the
X.I "being reviewed"
Xstate without several preconditions:
X.LP
X\(bu The change is know to build.
XYou know that it compiled successfully,
Xso there is no need to search for syntax errors.
X.LP
X\(bu The change has tests,
Xand those tests have been run,
Xand have passed.
X.LP
XThis information allows you to concentrate on implementation issues,
Xcompleteness issues,
Xand local standards issues.
X.LP
XTo help the reviewer,
Xa set of "command D" files is available
Xin the change development directory.
XEvery files which is to be added to the baseline, 
Xremoved from the baseline,
Xor changed in some way,
Xhas a corresponding "comma D" file.
X.nh 3 "The First Change"
X.LP
XRobyn finds out what changes are available for review
Xby asking aegis:
X.E(
Xrobyn% \f(CBaerpass -l -p example\fP
X
XProject "example"
XList of Changes
X
XChange  State           Description
X------- -------         -------------
X   1    being_reviewed  Place under aegis
Xrobyn%
X.E)
XAny of the above changes could be reviewed,
XRobyn chooses the first.
X.E(
Xrobyn% \f(CBaecd -p example -c 1\fP
Xaegis: project "example": change 1: /u/pat/example.001
Xrobyn% \f(CBaedmore\fP
X\fI\&.\&.\&.examines each file.\&.\&.\fP
Xrobyn%
X.E)
XThe
X.I aedmore
Xcommand walks the development directory tree to find all of
Xthe "comma D" files, and displays them using
X.IR more (1)
XThere is a corresponding
X.I aedless
Xfor those who prefer the
X.IR less (1)
Xcommand.
X.LP
XOnce the change has been reviewed and found acceptable,
Xit is passed:
X.E(
Xrobyn% \f(CBaerpass example 1\fP
Xaegis: sh /usr/local/lib/aegis/rp.sh example 1 pat robyn
Xaegis: project "example": change 1: passed review
Xrobyn%
X.E)
XSome time soon Isa will notice the email
Xnotification and commence integration of the change.
X.nh 3 "The Second Change"
X.LP
XMost reviews have the same pattern as the first.
X.E(
Xrobyn% \f(CBaerpass -l -p example\fP
X
XProject "example"
XList of Changes
X
XChange  State           Description
X------- -------         -------------
X   2    being_reviewed  file names on command line
Xrobyn%
X.E)
X.LP
XAlways change directory to the change's development directory,
Xotherwise you will not be able to review the files.
X.E(
Xrobyn% \f(CBaecd -p example -c 2\fP
Xaegis: project "example": change 2: /u/jan/example.002
Xrobyn%
X.E)
X.LP
XAnother useful way of finding out about a change
Xis the "list change details" command, viz:
X.E(
Xrobyn% \f(CBael cd -p example -c 2\fP
X 
XProject "example", Change 2
XChange Details
X.E)
X.E(
XNAME
X        Project "example", Change 2.
X.E)
X.E(
XSUMMARY
X        file names on command line
X.E)
X.E(
XDESCRIPTION
X        Optional input and output files may be specified on
X        the command line.
X.E)
X.E(
XCAUSE
X        This change was caused by internal_bug.
X.E)
X.E(
XSTATE
X        This change is in 'being_integrated' state.
X.E)
X.E(
XFILES
X        Type    Action  Edit    File Name
X        ------- ------- ------- -----------
X        source  modify  1.1     main.c
X        test    create          test/00/t0002a.sh
X.E)
X.E(
XHISTORY
X        What            When            Who     Comment
X        ------          ------          -----   ---------
X        new_change      Fri Dec 11      alex
X                        14:55:06 1992
X        develop_begin   Mon Dec 14      jan
X                        09:07:08 1992
X        develop_end     Mon Dec 14      jan
X                        11:43:23 1992
Xrobyn%
X.E)
X.LP
XOnce Robyn knows what the change is meant to be doing,
Xthe files are then examined:
X.E(
Xrobyn% \f(CBaedmore\fP
X\fI\&.\&.\&.examines each file.\&.\&.\fP
Xrobyn%
X.E)
X.LP
XOnce the change is found to be acceptable,
Xit is passed:
X.E(
Xrobyn% \f(CBaerpass example 2\fP
Xaegis: sh /usr/local/lib/aegis/rp.sh example 2 jan robyn
Xaegis: project "example": change 2: passed review
Xrobyn%
X.E)
X.LP
XSome time soon Isa will notice the email
Xnotification and commence integration of the change.
X.LP
XThe reviews of the third and fourth changes will
Xnot be given here,
Xbecause they are almost identical to the other changes.
XIf you want to know how to fail a review,
Xsee the
X.IR aerfail (1)
Xmanual entry.
X.nh 3 "Reviewer Command Summary"
X.LP
XOnly a few of the aegis commands available to reviewers have
Xbeen used in this example.
XThe following table (very tersely) describes the aegis commands
Xmost useful to reviewers.
X.sp
X.TS
Xcenter,tab(;);
Xl l.
XCommand;Description
X_
Xaecd;Change Directory
Xaerpass;Review Pass
Xaerpu;Review Pass Undo
Xaerfail;Review Fail
Xael;List Stuff
X.TE
X.LP
XYou will want to read the manual entries for all of these commands.
XNote that all aegis commands have a
X.I \-Help
Xoption,
Xwhich will give a result very similar to the
Xcorresponding
X.I man (1)
Xoutput.
XMost aegis commands also have a
X.I \-List
Xoption,
Xwhich usually lists interesting context sensitive information.
END_OF_FILE
if test 5756 -ne `wc -c <'doc/c2.2.so'`; then
    echo shar: \"'doc/c2.2.so'\" unpacked with wrong size!
fi
# end of 'doc/c2.2.so'
fi
if test -f 'doc/c2.3.so' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/c2.3.so'\"
else
echo shar: Extracting \"'doc/c2.3.so'\" \(6349 characters\)
sed "s/^X//" >'doc/c2.3.so' <<'END_OF_FILE'
X.\"
X.\"	aegis - project change supervisor
X.\"	Copyright (C) 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: User Guide, The Change Development Cycle, The Integrator
X.\"
X.bp
X.nh 2 "The Integrator"
X.LP
XThis section shows what the integrator must do for each of the
Xchanges shown to date.
XThe integrator does not have the ability to alter anything in the change;
Xif a change being integrated is defective,
Xit is simply failed back to the developer.
XThis documented example has no such failures,
Xin order to keep it manageably small.
X.nh 3 "The First Change"
X.LP
XThe first change of a project is often the trickiest,
Xand the integrator is the last to know.
XThis example goes smoothly,
Xand you may want to consider using the example project
Xas a template.
X.LP
XThe integrator for this example project is Isa.
XIsa knows there is a change ready for integration
Xfrom the notification which arrived by email.
X.E(
Xisa% \f(CBaeib -l -p example\fP
X
XProject "example"
XList of Changes
X
XChange  State           Description
X------- -------         -------------
X   1    awaiting_       Place under aegis
X        integration
Xisa% \f(CBaeib example 1\fP
Xaegis: project "example": change 1: link baseline to integration
X        directory
Xaegis: project "example": change 1: apply change to integration
X        directory
Xaegis: project "example": change 1: integration has begun
Xisa%
X.E)
X.LP
XThe integrator must rebuild and retest each change.
XThis ensures that it was no quirk of the developer's
Xenvironment which resulted in the success at the development stage.
X.E(
Xisa% \f(CBaeb\fP
Xaegis: logging to "/projects/example/delta.001/aegis.log"
Xaegis: project "example": change 1: integration build started
Xaegis: cook -b Howto.cook project=example change=1
X        version=1.0.D001 -nl
Xcook: yacc -d gram.y
Xcook: mv y.tab.c gram.c
Xcook: mv y.tab.h gram.h
Xcook: cc -I. -O -c gram.c
Xcook: lex lex.l
Xcook: mv lex.yy.c lex.c
Xcook: cc -I. -O -c lex.c
Xcook: cc -I. -O -c main.c
Xcook: cc -o example gram.o lex.o main.o -ll -ly
Xaegis: project "example": change 1: integration build complete
Xisa%
X.E)
X.LP
XNotice how the above build differed from the builds that were done
Xwhile in the
X.I "being developed"
Xstate;
Xthe extra baseline include is gone.
XThis is because the integration directory will shortly be the new baseline,
Xand must be entirely internally consistent and self-sufficient.
X.LP
XYou are probably wondering why this isn't all rolled into the
Xone aegis command.
XIt is not because there may be some manual process to be
Xperformed after the build and before the test.
XThis may be making a command set-uid-root (as in the case of aegis)
Xor it may require some tinkering with the local oracle or ingress database.
XInstructions for the integrator may be placed in the
Xdescription field of the change attributes.
X.LP
XThe change is now re-tested:
X.E(
Xisa% \f(CBaet\fP
Xaegis: logging to "/projects/example/delta.001/aegis.log"
Xaegis: sh /project/example/delta.001/test/00/t0001a.sh
Xaegis: project "example": change 1: test "test/00/t0001a.sh"
X        passed
Xaegis: project "example": change 1: passed 1 test
Xisa%
X.E)
XThe change builds and tests.
XOnce Isa is happy with the change,
Xperhaps after browsing the files,
XIsa then passes the integration,
Xcausing the history files to be updated
Xand the integration directory becomes the baseline.
X.E(
Xisa% \f(CBaeipass\fP
Xaegis: logging to "/projects/example/delta.001/aegis.log"
Xaegis: ci -u -m/dev/null -t/dev/null /projects/example/delta.001/
X        Howto.cook /projects/example/history/Howto.cook,v;
X        rcs -U /projects/example/history/Howto.cook,v
X/projects/example/history/Howto.cook,v  <--
X        /projects/example/delta.001/Howto.cook
Xinitial revision: 1.1
Xdone
XRCS file: /projects/example/history/Howto.cook,v
Xdone
Xaegis: rlog -r /projects/example/history/Howto.cook,v | awk
X        '/^head:/ {print $2}' > /tmp/aegis.15309
X\fI\&...lots of similar RCS output...\fP
Xaegis: sh /usr/local/lib/aegis/ip.sh example 1 pat robyn isa
Xaegis: project "example": change 1: integrate pass
Xisa%
X.E)
X.LP
XAll of the staff involved,
Xwill receive email to say that the change has been integrated.
XThis notification is a shell script,
Xso USENET could be usefully used instead.
X.nh 3 "The Other Changes"
X.LP
XThere is no difference to integrating any of the later changes.
XThe integration process is very simple,
Xas it is a cut-down version of what the developer does,
Xwithout all the complexity.
X.LP
XYour project may elect to have the integrator also monitor
Xthe quality of the reviews.
XAn answer to "who will watch the watchers" if you like.
X.LP
XIt is also a good idea to rotate people out of the integrator
Xposition after a few weeks in a busy project,
Xthis is a very stressful position.
XThe position of integrator gives a unique perspective to software quality,
Xbut the person also needs to be able to say "NO!" when a cruddy
Xchange comes along.
X.bp
X.nh 3 "Integrator Command Summary"
X.LP
XOnly a few of the aegis commands available to integrators have
Xbeen used in this example.
XThe following table (very tersely) describes the aegis commands
Xmost useful to integrators.
X.sp
X.TS
Xcenter,tab(;);
Xl l.
XCommand;Description
X_
Xaeb;Build
Xaecd;Change Directory
Xaeib;Integrate Begin
Xaeibu;Integrate Begin Undo
Xaeifail;Integrate Fail
Xael;List Stuff
Xaet;Test
Xaeupass;Integrate Pass
X.TE
X.LP
XYou will want to read the manual entries for all of these commands.
XNote that all aegis commands have a
X.I \-Help
Xoption,
Xwhich will give a result very similar to the
Xcorresponding
X.I man (1)
Xoutput.
XMost aegis commands also have a
X.I \-List
Xoption,
Xwhich usually lists interesting context sensitive information.
END_OF_FILE
if test 6349 -ne `wc -c <'doc/c2.3.so'`; then
    echo shar: \"'doc/c2.3.so'\" unpacked with wrong size!
fi
# end of 'doc/c2.3.so'
fi
if test -f 'doc/c4.1.so' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/c4.1.so'\"
else
echo shar: Extracting \"'doc/c4.1.so'\" \(5556 characters\)
sed "s/^X//" >'doc/c4.1.so' <<'END_OF_FILE'
X.\"
X.\"	aegis - project change supervisor
X.\"	Copyright (C) 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: User Guide, The Dependency Maintenance Tool, Requirements
X.nh 2 "Required Features"
X.LP
XWhen selecting a Dependency Maintenance Tool
Xit is important to keep in mind that it must be able to
Xcope with a hierarchy of parallel source directory trees.
X.LP
XThe heart of any DMT is an \fIinference engine\fP.
XThis inference engine accepts a \fIgoal\fP of what you want it to construct
Xand a set of \fIrules\fP for how to construct things,
Xand attempts to construct what you asked for given the rules you specified.
XThis is exactly a description of an expert system,
Xand the DMT needs to be an expert system for constructing files.
X.LP
XThis perspective on what the aegis program needs from a DMT
Xreveals that the old-faithful \fImake\fP(1) distributed
Xwith so many flavours of 
X.UX
Xsimply isn't good enough,
Xand that something like PROLOG is probably ideal.
X.nh 3 "Search Lists"
X.LP
XFor the union of all files in a project and all files in a change
X(remembering that a change only copies those files it is modifying,
Xplus it may add or remove files)
Xfor all files you must be able to say to the dependency maintenance
Xtool,
X.QP
X"If and only if the file is up-to-date in the baseline,
Xuse the baseline copy of the file,
Xotherwise construct the file in the development directory".
X.LP
XThe presence of a source file in the change makes the copy
Xin the baseline out-of-date.
X.LP
XMost DMTs with this capability implement it by using
Xsome sort of search path,
Xallowing a hierarchy of directories to be scanned with little or
Xno modification to the rules.
X.nh 3 "Dynamic Include File Dependencies"
X.LP
XInclude file dependencies are very important,
Xbecause a change may alter an include file,
Xand all of the sources in the baseline which use that include file
Xmust be recompiled.
X.LP
XConsider the example given earlier:
Xthe include file describing the interface definition of a function is
Xcopied into a change and edited,
Xand so is the source file defining the function.
XIt is essential that all source files in the baseline which
Xinclude that file re recompiled,
Xwhich will usually result in suitable diagnostic errors if any of the
Xclients of the altered function have yet to be included in the change.
X.LP
XThere are two ways of handling include file dependencies:
X.LP
X\(bu They can be kept in a file,
Xand the file can be maintained but suitable programs
X(maintaining it manually never works, that's just human nature).
X.LP
X\(bu They can be determined by the DMT when it is scanning the rules
Xto determine what needs updating.
X.nh 4 "Static File"
X.LP
XKeeping include dependencies in a file has a number of advantages:
X.LP
X\(bu Most existing DMTs have the ability to include another rules file,
Xso that when performing a development build
Xfrom a baseline rules file,
Xit could include a
Xdependencies file in the development directory.
X.LP
X\(bu Reading a file is much faster than scanning all of the source files.
X.LP
XKeeping include dependencies in a file has a number of disadvantages:
X.LP
X\(bu The file is independent of the DMT,
Xit is either generated before the DMT is invoked,
Xin which case it may do more work than is necessary,
Xor it may be invoked after the DMT (or after the DMT has scanned its rules),
Xin which case it may well be out-of-date when the DMT needs it.
X.LP
XFor example,
Xthe use of
X.I "gcc -M"
Xproduces "dot d" files,
Xwhich may be merged to 
Xconstruct such an includable dependency file.
XThis happens after the DMT has read and applied the rules,
Xbut possibly before the DMT has finished executing.
X.LP
X\(bu Many tools which can generate this information,
Xsuch as the
X.I "gcc -M"
Xoption,
Xare triggered by source files,
Xand are unable to manage a case where it is an include file which is changing,
Xto include a different set of other include files.
XIn this case,
Xthe inaccurate dependencies file may contain references to 
Xthe old set of nested include files,
Xsome of which may no longer exist,
XThis causes
Xthe DMT to incorrectly generate an error stating that the
Xold include file is missing,
Xwhen it is actually no longer required.
X.LP
XIf a DMT can only support this kind of include file dependencies,
Xit is not suitable for use with aegis.
X.nh 4 "Dynamic"
X.LP
XIn order for a DMT to be suitable for use with aegis,
Xit is essential that rules for the DMT may be specified in such a way that
Xinclude file dependencies are determined "on the fly"
Xwhen the DMT is determining if a given rule is applicable,
Xand before the rule is applied.
X.LP
XThis method suffers from the problem being rather slow;
Xbut this is amenable to some caching and the losses of performance
Xare not as bad as could be imagined.
X.LP
XThis method has the advantage of correctness in all cases,
Xwhere a static file may at times be out-of-date.
END_OF_FILE
if test 5556 -ne `wc -c <'doc/c4.1.so'`; then
    echo shar: \"'doc/c4.1.so'\" unpacked with wrong size!
fi
# end of 'doc/c4.1.so'
fi
if test -f 'doc/c7.4.so' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/c7.4.so'\"
else
echo shar: Extracting \"'doc/c7.4.so'\" \(5680 characters\)
sed "s/^X//" >'doc/c7.4.so' <<'END_OF_FILE'
X.\"
X.\"	aegis - project change supervisor
X.\"	Copyright (C) 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: User Guide, How Aegis Works, Further Work
X.\"
X.bp
X.nh 2 "Further Work"
X.LP
XThe aegis program is far from finished.
XA number of features are known to lacking,
Xand several interesting (but as yet unformed) ideas are lurking.
X.nh 3 "Heterogeneous Environments"
X.LP
XThere is no support at the current time for
Xtracking aspects of development in an heterogeneous environment.
XThis is in the list of tasks,
Xbut has a low priority,
Xfirst all the other stuff has to work!
XIn time,
Xattributes will be added to projects to indicate a set of environments,
Xand each change will have to be built and tested in each.
X.LP
XThe configuration file the user supplies to the dependency maintenance tool
Xwill be responsible for figuring out which environment it
Xis in and building accordingly.
XIt is an operating system requirement
Xthat the baseline and development directories
Xare accessible in each environment (facilities such as RFS or NFS are assumed).
XNote that the baseline will expect to be self-consistent in all
Xof the environments simultaneously.
X.LP
XThere is no intention of ever providing the facility
Xwhere a given file may have different versions depending on
Xthe environment,
Xbut all have the same name\**.
X.FS
XSome other SCM tools provide a repository with this ability.
X.FE
X.nh 3 "Hierarchy of Projects"
X.LP
XIt would be nice if there was some way to use 
Xone projects as a sort of "super change" to a "super project",
Xso that large teams (say 1000 people)
Xcould work as lots of small teams (say 100 people).
XAs a small team gets their chunk ready,
Xusing the facilities provided to-date by aegis,
Xthe small team's baseline is treated as a change to be made to the
Xlarge team baseline.
X.LP
XThis idea can be extended quite naturally to any depth of layering.
X.LP
XThe desired semantics,
Xlet alone the implementation details,
Xcan not begin without  more experience to show (and fix) the warts
Xon the existing functionality.
X.nh 3 "Code Coverage Tool"
X.LP
XIt would be very helpful if a code coverage tool could be used
Xto analyze tests included with changes to ensure that the tests
Xactually exercised the lines of code changed in the change.
X.LP
XAnother use of the code coverage tool would be to select regression tests
Xbased on the object files recompiled by a change,
Xand those regression tests which exercise those files.
X.LP
XWhile there is freeware C code coverage tool available,
Xbased on GNU C,
Xthe interfacing and semantics still need more thought.
X.nh 3 "Branching"
X.LP
XThe aegis program does not provide support for branching
Xin the history files.
XThe semantics of the baseline,
Xthe source files and their closure,
Xwould appear to imply that a baseline is required for every leaf
Xin the history tree.
X.LP
XBranching is provided in this way with the
X.I "new release"
Xfunctionality.
XAn entire new project is derived from an existing project,
Xincluding another baseline.
XThe history,
Xhowever,
Xis severed from the original project,
Xprecluding automatic merging by aegis at a later date.
XIt also precludes having a single change to be applied
Xto more than one branch.
X.LP
XShould better semantics become available,
Xor a better algorithmic approach,
Xthis is certainly one area of aegis which could be improved.
X.nh 3 "Virtual File System"
X.LP
XThere is almost sufficient information in the aegis data base to create a virtual file system,
Xoverlaying the development directory atop the baseline\**.
X.FS
XReminiscent of Sun's TFS,
Xbut not the same.
X.FE
XThis could be implemented similarly to automounters,
Xintercepting file system operations by pretending to be an NFS server.
XMany commercial CASE products provide such a facility.
X.LP
XSuch a virtual file system has a number of advantages:
Xyou don't need such a capable DMT, for starters;
Xit only needs the dynamic include dependencies,
Xand does not need a search path\**.
X.FS
XDiscussed in the
X.I "Dependency Maintenance Tool"
Xchapter.
X.FE
XSecond,
Xmany horrible and dumb compilers,
Xnotably FORTRAN and "fourth" GLs,
Xdon't have adequate include semantics;
Xoverlaying the two directories make this much easier to deal with\**.
X.FS
XThere are other ways,
Xdiscussed in the
X.I "Tips and Traps"
Xchapter.
X.FE
XMany graphical tools,
Xsuch as bubble chart drawers, etc,
Xwhen they do actually have include files,
Xhave no command line specifiable search path.
X.LP
XThe disadvantage is that this adds significant complexity
Xto an already large program.
XAlso,
Ximplementation is limited to NFS capable systems,
Xor would have to be rewritten for a variety of other systems.
XThe semantics of interactions between the daemon and other aegis
Xcommands, while clearly specifiable, are challenging to implement.
XPerformance could also be a significant factor.
X.LP
XThe question is "is it really necessary?"
XIf the job can be done without it,
Xdoes the effort of writing such a beast result
Xin significant productivity gains?
END_OF_FILE
if test 5680 -ne `wc -c <'doc/c7.4.so'`; then
    echo shar: \"'doc/c7.4.so'\" unpacked with wrong size!
fi
# end of 'doc/c7.4.so'
fi
if test -f 'doc/cB.0.so' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/cB.0.so'\"
else
echo shar: Extracting \"'doc/cB.0.so'\" \(5480 characters\)
sed "s/^X//" >'doc/cB.0.so' <<'END_OF_FILE'
X.\"
X.\"	aegis - project change supervisor
X.\"	Copyright (C) 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: User Guide, Appendix B: Glossary
X.\"
X.bp
X.2C
X.nh 1 "Appendix B: Glossary"
X.LP
XThe following is an alphabetical list of terms used in this document.
X.IP "administrator"
X.br
XPerson responsible for administering a
X.I project .
X.IP "awaiting_development"
X.br
XThe state a change is in immediately after creation.
X.IP "awaiting_integration"
X.br
XThe state a change is in
Xafter it has passed review and before it is integrated.
X.IP "baseline"
X.br
XThe repository;
Xwhere the project master source is kept.
X.IP "being developed"
X.br
XThe state a change is in
Xwhen it is being worked on.
X.IP "being integrated"
X.br
XThe state a change is in
Xwhen it is being integrated with the baseline.
X.IP "being reviewed"
X.br
XThe state a change is in
Xafter it is developed.
X.IP "change"
X.br
XA collection of files to be applied as a single
Xatomic alteration of the baseline.
X.IP "change number"
X.br
XEach
X.I change
Xhas a unique number identifying it.
X.IP "completed"
X.br
XThe state a change is in
Xafter it has been integrated with the baseline.
X.IP "delta number"
X.br
XEach time the
X.I aeib (1)
Xcommand is used to start integrating a
X.I change
Xinto the
X.I baseline
Xa unique number is assigned.
XThis number is the delta number.
XThis allows ascending version numbers to be generated for the baseline,
Xindependent of change numbers, which are inevitably
Xintegrated in a different order to their creation.
X.IP "dependency maintenance tool"
X.br
XA program or programs external to aegis which may be given a set of rules
Xfor how to efficiently take a set of source files and
Xprocess them to produce the final product.
X.IP "DMT"
X.br
XAbbreviation of Dependency Maintenance Tool.
X.IP "develop_begin"
X.br
XThe command issued to take a change from the
X.I "awaiting development"
Xstate to the
X.I "being developed"
Xstate.
XThe change will be assigned to the user who executed the command.
X.IP "develop_begin_undo"
X.br
XThe command issued to take a change from the
X.I "being developed"
Xstate to the
X.I "awaiting development"
Xstate.
XThe change must have no files associated with it.
X.IP "develop_end"
X.br
XThe command issued to take a change from the
X.I "being developed"
Xstate to the
X.I "being reviewed"
Xstate.
XThe change must be known to build and test successfully.
X.IP "develop_end_undo"
X.br
XThe command issued to take a change from the
X.I "being reviewed"
Xstate back to the
X.I "being developed"
Xstate.
XThe command must be executed by the original developer.
X.IP "developer"
X.br
XA member of staff allowed to develop changes.
X.IP "development directory"
X.br
XEach change is given a unique development directory
Xin which to edit files and build and test.
X.IP "history tool"
X.br
XA program to save and restore previous versions of a file,
Xusually by storing edits between the versions for efficiency.
X.IP "integrate_pass"
X.br
XThe command used to take a change from the
X.I "being integrated"
Xstate to the
X.I "completed"
Xstate.
XThe change must be known to build and test successfully.
X.IP "integrate_begin"
X.br
XThe command used to take a change from the
X.I "awaiting integration"
Xstate to the
X.I "being integrated"
Xstate.
X.IP "integrate_begin_undo"
X.br
XThe command used to take a change from the
X.I "being integrated"
Xstate to the
X.I "awaiting integration"
Xstate.
X.IP "integrate_fail"
X.br
XThe command used to take a change from the
X.I "being integrated"
Xstate back to the
X.I "being developed"
Xstate.
X.IP "integration"
X.br
XThe process of merging the
X.I baseline
Xwith the
X.I "development directory"
Xto form a new baseline.
XThis includes building and testing the merged directory,
Xbefore replacing the original
X.I baseline
Xwith the new merged version.
X.IP "integration directory"
X.br
XThe directory used during
X.I integration
Xto merge the existing
X.I baseline
Xwith a change's
X.I "development directory" .
X.IP "integrator"
X.br
XA staff member who performs
X.I integration s.
X.IP "new_change"
X.br
XThe command used to create new changes.
X.IP "new_change_undo"
X.br
XThe command used to destroy changes.
X.IP "review_fail"
X.br
XThe command used to take a change from the
X.I "being reviewed"
Xstate back to the
X.I "being developed"
Xstate.
X.IP "review_pass"
X.br
XThe command used to take a change from the
X.I "being reviewed"
Xstate to the
X.I "awaiting integration"
Xstate.
X.IP "reviewer"
X.br
XA person who may review
X.I changes
Xand either pass or fail them (\fIreview_pass\fP
Xor \fIreview_fail\fP respectively).
X.IP "state"
X.br
XEach
X.I change
Xis in one of six states:
X.I "awaiting development" ,
X.I "being developed" ,
X.I "being reviewed" ,
X.I "awaiting integration" ,
X.I "being integrated"
Xor
X.I "completed" .
X.IP "state transition"
X.br
XThe event resulting in a
X.I change
Xchanging from one state to another.
X.1C
END_OF_FILE
if test 5480 -ne `wc -c <'doc/cB.0.so'`; then
    echo shar: \"'doc/cB.0.so'\" unpacked with wrong size!
fi
# end of 'doc/cB.0.so'
fi
if test -f 'doc/cC.0.so' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/cC.0.so'\"
else
echo shar: Extracting \"'doc/cC.0.so'\" \(5749 characters\)
sed "s/^X//" >'doc/cC.0.so' <<'END_OF_FILE'
X.\"
X.\"	aegis - project change supervisor
X.\"	Copyright (C) 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: User Guide, Appendix C, Product Comparisons
X.\"
X.bp
X.2C
X.nh 1 "Appendix C: Product Comparisons"
X.LP
XThis appendix compares the aegis program with other pieces of software.
XOnly a few work in the same area as the aegis program,
Xor a commonly compared to the aegis program.
X.nh 2 "CVS"
X.LP
XA comparison with CVS (Concurrent Version System) is frequently requested.
X.LP
XA fast comparison can be made by saying that
X.I "CVS is over RCS"
Xand that
X.I "aegis is over RCS and make."
XThis is a very simplistic view,
Xbut it illustrates the fact that aegis has a wider scope than make.
XWhile CVS covers a subset of the functionality covered by aegis,
Xit naturally does that subset better.
X.LP
XThe model used by aegis has a baseline
X.I and
Xa repository.
XThe baseline is all of the most up to date source file
X.B plus
Xall the implications flowing from those source files,
Xsuch as object files and executable programs or libraries.
XThis means there is always an "official" executable present,
Xrepresenting the progress made by the project at that very instant.
XThese source files are available for linking or inclusion,
Xthe object files available for linking,
Xat no extra effort for the developers.
X.LP
XThe repository is only for history,
Xusing the aegis model.  It is used to store everything that has happened,
Xso that developers may recreate earlier version when fixing bugs,
Xand aegis may use it for some other purposes.
X.LP
XCVS provides the repository functionality well.
XIt provides branching nicely,
Xand it has symbolic file sets.
XWhile is does not provide a baseline,
Xit does not prevent a project implementing it in some other fashion.
X.LP
XThe existence of the baseline for aegis is what limits branching.
XThe semantics of branching in the repository would appear to imply
Xthat a (logically) separate baseline is required for each leaf in
Xthe history tree.
XThis is why aegis only provides branching without the possibility of merging,
Xby deriving a whole new project from an existing one;
Xthus creating a whole new baseline as well.
XShould a better set of semantics be made apparent,
Xthis is certainly an area for improvement.
X.LP
XAnother aspect of Software Configuration Management (SCM) is
Xconsistency checking.
XFor example,
Xif two developers are working on two (logically) separate changes,
Xwhich both need to alter the same file,
Xone of them will inevitably return it to the baseline first,
Xand the other will then be working on an out of date copy.
XBoth aegis is CVS provide a conflict resolution mechanism to handle this;
Xthe same algorithm is used by both,
Xalthough implemented a little differently in each case.
X.LP
XThere is a second aspect to consistency checking required by SCM;
Xit is important that a change does not "break" the project,
Xand it is thus important that all the source files in the project
Xagree with each other.
XFor example,
Xif a developer alters an include file as part of a change,
Xand the portion of this include file describing a function
Xprototype is changed,
Xit is essential that all of the clients of that function be recompiled,
Xto ensure that they are still compatible with that prototype,
Xand may need to be included with the change to update their use of
Xthe function.
XSimilarly,
Xthe definition of the function needs to be recompiled,
Xto ensure that it, too, agrees with the prototype,
Xand have the interface and 9implementation changed to agree with it.
XThis type of consistency checking is provided by aegis,
Xbut not by CVS;
Xalthough CVS does not prevent a project implementing this in a different way.
X.LP
XAnother aspect of SCM provided by aegis is validation.
XThe aegis program insists that changes be accompanied by tests.
XThis allows greater confidence that a change actually works,
Xand the accumulation of such tests provides a regression test suite to verify
Xthat later changes do not "break" the functionality provided by this one.
XThe aegis program also insists that each change be reviewed;
Xby whom is configurable.
XWhile testing is not a silver bullet,
Xand neither is peer review,
Xboth are vital components producing quality software.
XCVS does not provide validation functionality;
Xalthough it does not prevent a project from implementing this in some other way.
X.LP
XThe CVS program aims to provide the repository function for SCM,
Xand it does this well.
XThe
Xaegis program aims to provide a baseline,
Xto provide a repository,
Xto provide baseline consistency, and
Xto provide baseline change validation.
XThere are situations where one is more suited,
Xand the other less, and vice versa.
XThe tools selected for a project,
Xfrom Gandt charts to assemblers,
Xmust be chosen for their "fit" with each individual project.
X.PP
XAnother point to note is that CVS requires RCS;
Xwhereas aegis may be configured to use almost any history tool.
XIf SCCS is bundled with your operating system,
Xor your company has its own history tool,
Xaegis can be configured to use that, instead.
X.1C
END_OF_FILE
if test 5749 -ne `wc -c <'doc/cC.0.so'`; then
    echo shar: \"'doc/cC.0.so'\" unpacked with wrong size!
fi
# end of 'doc/cC.0.so'
fi
if test -f 'fmtgen/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fmtgen/main.c'\"
else
echo shar: Extracting \"'fmtgen/main.c'\" \(5236 characters\)
sed "s/^X//" >'fmtgen/main.c' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: operating system start-up point
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X
X#include <arglex.h>
X#include <error.h>
X#include <id.h>
X#include <lex.h>
X#include <option.h>
X#include <parse.h>
X#include <str.h>
X#include <trace.h>
X
X
Xstatic void usage _((void));
X
Xstatic void
Xusage()
X{
X	char	*progname;
X
X	progname = option_progname_get();
X	fprintf(stderr, "usage: %s [ <option>... ] <file.def> <file.c> <file.h>\n", progname);
X	fprintf(stderr, "       %s -Help\n", progname);
X	exit(1);
X}
X
X
Xstatic void help _((void));
X
Xstatic void
Xhelp()
X{
X	static char *text[] =
X	{
X"NAME",
X"	%s - file format read/write generator",
X"",
X"SYNOPSIS",
X"	%s [ <option>... ] file.def file.c file.h",
X"	%s -Help",
X"",
X"DESCRIPTION",
X"	The %s program is used to process the .def files",
X"	describing a file format into the .c and .h files which",
X"	implement that format (with the help of gram.y and",
X"	indent.c).",
X"",
X"OPTIONS",
X"	The following options are understood:",
X"",
X"	-Help",
X"		Give this help message.",
X"",
X"	-I<path>",
X"		Specify and include search path.",
X"",
X"	All options may be abbreviated; the abbreviation is",
X"	documented as the upper case letters, all lower case",
X"	letters and underscores (_) are optional.  You must use",
X"	consecutive sequences of optional letters.",
X"",
X"	All options are case insensitive, you may type them in",
X"	upper case or lower case or a combination of both, case",
X"	is not important.",
X"",
X"	For example: the arguments \"-project, \"-PROJ\" and \"-p\"",
X"	are all interpreted to mean the -Project option.  The",
X"	argument \"-prj\" will not be understood, because",
X"	consecutive optional characters were not supplied.",
X"",
X"	Options and other command line arguments may be mixed",
X"	arbitrarily on the command line, after the function",
X"	selectors.",
X"",
X"	The GNU long option names are understood.  Since all",
X"	option names for aegis are long, this means ignoring the",
X"	extra leading '-'.  The \"--option=value\" convention is",
X"	also understood.",
X"",
X"EXIT STATUS",
X"	The %s program will exit with a status of 1 on any",
X"	error.	The %s program will only exit with a status",
X"	of 0 if there are no errors.",
X"",
X"COPYRIGHT",
X"	The %s program is Copyright (C) 1990, 1991, 1992, 1993 Peter Miller.",
X"	All rights reserved.",
X"",
X"	The %s program comes with ABSOLUTELY NO WARRANTY; for",
X"	details use the 'aegis -VERSion Warranty' command.  This",
X"	is free software and you are welcome to redistribute it",
X"	under certain conditions; for details use the 'aegis",
X"	-VERSion Redistribution' command.",
X"",
X"AUTHOR",
X"	Peter Miller   UUCP     uunet!munnari!bmr.gov.au!pmiller",
X"	/\\/\\*          Internet pmiller@bmr.gov.au",
X		0
X	};
X
X	char	**cpp;
X	char	*progname;
X
X	progname = option_progname_get();
X	for (cpp = text; *cpp; ++cpp)
X	{
X		printf(*cpp, progname);
X		printf("\n");
X	}
X}
X
X
Xenum
X{
X	arglex_token_include_short,
X	arglex_token_include_long
X};
X
Xstatic arglex_table_ty argtab[] =
X{
X	{ "-\\I*",	(arglex_token_ty)arglex_token_include_short,	},
X	{ "-Include",	(arglex_token_ty)arglex_token_include_long,	},
X	{ 0, (arglex_token_ty)0, }, /* end marker */
X};
X
X
Xint main _((int, char **));
X
Xint
Xmain(argc, argv)
X	int	argc;
X	char	**argv;
X{
X	char	*filename[3];
X	int	j;
X
X	str_initialize();
X	arglex_init(argc, argv, argtab);
X	id_initialize();
X	for (j = 0; j < SIZEOF(filename); ++j)
X		filename[j] = 0;
X	if (arglex() == arglex_token_help)
X	{
X		if (arglex() != arglex_token_eoln)
X			usage();
X		help();
X		exit(0);
X	}
X
X	while (arglex_token != arglex_token_eoln)
X	{
X		switch (arglex_token)
X		{
X		default:
X			error
X			(
X				"misplaced \"%s\" command line argument",
X				arglex_value.alv_string
X			);
X			usage();
X
X		case arglex_token_include_long:
X			if (arglex() != arglex_token_string)
X				usage();
X			/* fall through... */
X
X		case arglex_token_include_short:
X			lex_include_path(arglex_value.alv_string);
X			break;
X
X		case arglex_token_string:
X			for (j = 0; j < SIZEOF(filename); ++j)
X				if (!filename[j])
X					break;
X			if (j >= SIZEOF(filename))
X				fatal("too many file names specified");
X			filename[j] = arglex_value.alv_string;
X			break;
X#ifdef DEBUG
X		case arglex_token_trace:
X			while (arglex() == arglex_token_string)
X				trace_enable(arglex_value.alv_string);
X			continue;
X#endif
X		}
X		arglex();
X	}
X	for (j = 0; j < SIZEOF(filename); ++j)
X		if (!filename[j])
X			fatal("too few file names specified");
X
X	parse(filename[0], filename[1], filename[2]);
X	exit(0);
X	return 0;
X}
END_OF_FILE
if test 5236 -ne `wc -c <'fmtgen/main.c'`; then
    echo shar: \"'fmtgen/main.c'\" unpacked with wrong size!
fi
# end of 'fmtgen/main.c'
fi
if test -f 'fmtgen/type_enum.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fmtgen/type_enum.c'\"
else
echo shar: Extracting \"'fmtgen/type_enum.c'\" \(6560 characters\)
sed "s/^X//" >'fmtgen/type_enum.c' <<'END_OF_FILE'
X/*
X *	aegis - project change supervisor
X *	Copyright (C) 1991, 1992, 1993 Peter Miller.
X *	All rights reserved.
X *
X *	This program is free software; you can redistribute it and/or modify
X *	it under the terms of the GNU General Public License as published by
X *	the Free Software Foundation; either version 2 of the License, or
X *	(at your option) any later version.
X *
X *	This program is distributed in the hope that it will be useful,
X *	but WITHOUT ANY WARRANTY; without even the implied warranty of
X *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *	GNU General Public License for more details.
X *
X *	You should have received a copy of the GNU General Public License
X *	along with this program; if not, write to the Free Software
X *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * MANIFEST: enumerated types functions gereation
X */
X
X#include <type.h>
X#include <indent.h>
X#include <id.h>
X#include <mem.h>
X
X
Xtypedef struct type_enum_ty type_enum_ty;
Xstruct type_enum_ty
X{
X	/* inherited */
X	TYPE_T
X
X	/* instance variables */
X	parse_list_ty *list;
X};
X
X
Xstatic void gen_include _((type_ty *, string_ty *));
X
Xstatic void
Xgen_include(type, name)
X	type_ty		*type;
X	string_ty	*name;
X{
X	type_enum_ty	*type2;
X	parse_list_ty	*np;
X
X	type2 = (type_enum_ty *)type;
X	indent_putchar('\n');
X	indent_printf("#ifndef %s_DEF\n", name->str_text);
X	indent_printf("#define %s_DEF\n", name->str_text);
X	indent_printf("enum %s_ty\n", name->str_text);
X	indent_printf("{\n"/*}*/);
X	for (np = type2->list; np; np = np->next)
X	{
X		indent_printf("%s", np->name->str_text);
X		if (np->next)
X			indent_putchar(',');
X		indent_putchar('\n');
X	}
X	indent_printf(/*{*/"};\n");
X	indent_printf
X	(
X		"typedef enum %s_ty %s_ty;\n",
X		name->str_text,
X		name->str_text
X	);
X	indent_printf("#endif /* %s_DEF */\n", name->str_text);
X
X	indent_putchar('\n');
X	indent_printf("extern type_ty %s_type;\n", name->str_text);
X
X	indent_putchar('\n');
X	indent_printf
X	(
X		"void %s_write _((char *, %s_ty));\n",
X		name->str_text,
X		name->str_text
X	);
X	indent_printf
X	(
X		"char *%s_ename _((%s_ty));\n",
X		name->str_text,
X		name->str_text
X	);
X}
X
X
Xstatic void gen_include_declarator _((type_ty *, string_ty *, int));
X
Xstatic void
Xgen_include_declarator(type, name, is_a_list)
X	type_ty		*type;
X	string_ty	*name;
X	int		is_a_list;
X{
X	indent_printf
X	(
X		"%s_ty\1%s%s;\n",
X		type->name->str_text,
X		(is_a_list ? "*" : ""),
X		name->str_text
X	);
X}
X
X
Xstatic void gen_code _((type_ty *, string_ty *));
X
Xstatic void
Xgen_code(type, name)
X	type_ty		*type;
X	string_ty	*name;
X{
X	parse_list_ty	*np;
X	type_enum_ty	*type2;
X	int		n;
X
X	type2 = (type_enum_ty *)type;
X	indent_putchar('\n');
X	indent_printf("static char *%s_s[] =\n", name->str_text);
X	indent_printf("{\n"/*}*/);
X	for (np = type2->list, n = 0; np; np = np->next, ++n)
X	{
X		string_ty *s;
X
X		id_search(np->name, ID_CLASS_ENUMEL, (long *)&s);
X		indent_printf("\"%s\",\n", s->str_text);
X	}
X	indent_printf(/*{*/"};\n");
X
X	indent_putchar('\n');
X	indent_printf("char *\n");
X	indent_printf("%s_ename(this)\n", name->str_text);
X	indent_more();
X	indent_printf("%s_ty\1this;\n", name->str_text);
X	indent_less();
X	indent_printf("{\n"/*}*/);
X	indent_printf("static char\1buffer[20];\n\n");
X	indent_printf("if (this >= 0 && this < %d)\n", n);
X	indent_more();
X	indent_printf("return %s_s[this];\n", name->str_text);
X	indent_less();
X	indent_printf("sprintf(buffer, \"%%d\", this);\n");
X	indent_printf("return buffer;\n");
X	indent_printf(/*{*/"}\n");
X
X	indent_putchar('\n');
X	indent_printf("void\n");
X	indent_printf("%s_write(name, this)\n", name->str_text);
X	indent_more();
X	indent_printf("%s\1*name;\n", "char");
X	indent_printf("%s_ty\1this;\n", name->str_text);
X	indent_less();
X	indent_printf("{\n"/*}*/);
X	indent_printf("if (name)\n");
X	indent_more();
X	indent_printf("indent_printf(\"%%s = \", name);\n");
X	indent_less();
X	indent_printf("indent_printf(\"%%s\", %s_s[this]);\n", name->str_text);
X	indent_printf("if (name)\n");
X	indent_more();
X	indent_printf("indent_printf(\";\\n\");\n");
X	indent_less();
X	indent_printf(/*{*/"}\n");
X
X	indent_putchar('\n');
X	indent_printf
X	(
X		"static int %s_parse _((string_ty *, void *));\n",
X		name->str_text
X	);
X
X	indent_putchar('\n');
X	indent_printf("static int\n");
X	indent_printf("%s_parse(name, addr)\n", name->str_text);
X	indent_more();
X	indent_printf("%s\1*name;\n", "string_ty");
X	indent_printf("%s\1*addr;\n", "void");
X	indent_less();
X	indent_printf("{\n"/*}*/);
X	indent_printf("%s\1*%s_f[SIZEOF(%s_s)];\n", "static string_ty", name->str_text, name->str_text);
X	indent_printf("%s\1j;\n", "int");
X	indent_putchar('\n');
X	indent_printf("slow_to_fast(%s_s, %s_f, SIZEOF(%s_s));\n", name->str_text, name->str_text, name->str_text);
X	indent_printf("for (j = 0; j < SIZEOF(%s_f); ++j)\n", name->str_text);
X	indent_printf("{\n");
X	indent_printf("if (str_equal(name, %s_f[j]))\n", name->str_text);
X	indent_printf("{\n");
X	indent_printf("*(%s_ty *)addr = j;\n", name->str_text);
X	indent_printf("return 0;\n");
X	indent_printf("}\n");
X	indent_printf("}\n");
X	indent_printf("return -1;\n");
X	indent_printf(/*{*/"}\n");
X
X	indent_putchar('\n');
X	indent_printf("type_ty %s_type =\n", name->str_text);
X	indent_printf("{\n"/*}*/);
X	indent_printf("type_class_enum,\n");
X	indent_printf("\"%s\",\n", name->str_text);
X	indent_printf("0, /* alloc */\n");
X	indent_printf("0, /* free */\n");
X	indent_printf("%s_parse,\n", name->str_text);
X	indent_printf("0, /* list_parse */\n");
X	indent_printf("0, /* struct_parse */\n");
X	indent_printf(/*{*/"};\n");
X}
X
X
Xstatic void gen_code_declarator _((type_ty *, string_ty *, int));
X
Xstatic void
Xgen_code_declarator(type, name, is_a_list)
X	type_ty		*type;
X	string_ty	*name;
X	int		is_a_list;
X{
X	indent_printf("%s_write("/*)*/, type->name->str_text);
X	if (is_a_list)
X		indent_printf("(char *)0");
X	else
X		indent_printf("\"%s\"", name->str_text);
X	indent_printf(/*(*/", this->%s);\n", name->str_text);
X}
X
X
Xstatic void gen_free_declarator _((type_ty *, string_ty *, int));
X
Xstatic void
Xgen_free_declarator(type, name, is_a_list)
X	type_ty		*type;
X	string_ty	*name;
X	int		is_a_list;
X{
X	if (is_a_list)
X		indent_printf(";\n");
X}
X
X
Xstatic type_method_ty method =
X{
X	gen_include,
X	gen_include_declarator,
X	gen_code,
X	gen_code_declarator,
X	gen_free_declarator,
X};
X
X
Xtype_ty *
Xtype_create_enum(name, list)
X	string_ty	*name;
X	parse_list_ty	*list;
X{
X	type_enum_ty	*type;
X
X	type = (type_enum_ty *)mem_alloc(sizeof(type_enum_ty));
X	type->class = type_class_enum;
X	type->method = &method;
X	type->name = str_copy(name);
X	type->list = list;
X	id_assign(name, ID_CLASS_TYPE, (long)type);
X	return (type_ty *)type;
X}
END_OF_FILE
if test 6560 -ne `wc -c <'fmtgen/type_enum.c'`; then
    echo shar: \"'fmtgen/type_enum.c'\" unpacked with wrong size!
fi
# end of 'fmtgen/type_enum.c'
fi
if test -f 'man5/aecstate.5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man5/aecstate.5'\"
else
echo shar: Extracting \"'man5/aecstate.5'\" \(6187 characters\)
sed "s/^X//" >'man5/aecstate.5' <<'END_OF_FILE'
X'\" t
X.\"	aegis - project change supervisor
X.\"	Copyright (C) 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: description of aegis change state file format
X.\"
X.so z_name.so
X.TH aecstate 5 \*(N)
X.SH NAME
Xaecstate \- \*(n) change state file
X.SH SYNOPSIS
X\fIproject\fP\f(CW/info/change/\fP\fI[0-9]\fP\f(CW/\fP\fI[0-9][0-9][0-9]\fP
X.SH DESCRIPTION
XA change state file is used to store information about a change.
XThese files are created and maintained by \*(n).
XThese files should not be edited by humans.
XThese files is owned by the project owner and group.
X.PP
XThe change number is at least 3 digits, zero padded if necessary.
X(More digits will be used if a project has a 
Xthousand or more changes in any one release,
Xalthough this is rare.)
XThe files are spread across a directory tree,
X100 per subdirectory,
Xto improve the directory search times,
Xand to avoid various systems' directory length limitations.
X.SH CONTENTS
X.so aecattr.so
X.TP 8n
Xstate = ( ... );
X.br
XThis field is used to describe what state the change is in.
XThe state determines what operations may be performed on the change.
X.RS 8n
X.TP 8n
Xawaiting_development
X.br
XThe change has been created,
Xbut has yet to be worked on.
X.TP 8n
Xbeing_developed
X.br
XThe change is being developed.
X.TP 8n
Xbeing_reviewed
X.br
XThe change has been developed,
Xand is being reviewed.
X(There is no 'awaiting_review' state.)
X.TP 8n
Xawaiting_integration
X.br
XThe change has passed review,
Xand is queued ready for integration.
X.TP 8n
Xbeing_integrated
X.br
XThe change is being integrated.
X.TP 8n
Xcompleted
X.br
XThe change has been completed and is now
Xpart of the baseline.
XChanges in this state can not be reversed.
X.RE
X.TP 8n
Xdelta_number = integer;
X.br
XThis field records the delta number for this change.
XIt is only present if the change is in one of
Xthe
X.I being_integrated
Xor
X.I completed
Xstates.
X.TP 8n
Xproject_file_command_sync = integer;
X.br
XThis field records the last change integrated into the project.
XIf it disagrees with the project, a 'project_file_command' (from pconf)
Xneeds to be executed at the next build.
X.TP 8n
Xtest_time = integer;
X.br
XThis field records the time the last successful
X.I "\*(n) -Test"
Xcommand was run.
XIt is only present in the
X.I being_developed
Xand
X.I being_integrated
Xstates.
X.TP 8n
Xtest_baseline_time = integer;
X.br
XThis field records the time the last successful
X.I "\*(n) -Test -BaseLine"
Xcommand was run.
XIt is only present in the
X.I being_developed
Xand
X.I being_integrated
Xstates.
X.TP 8n
Xbuild_time = integer;
X.br
XThis field records the last time the last successful
X.I "\*(n) -Build"
Xcommand was run.
XIt is only present in the
X.I being_developed
Xand
X.I being_integrated
Xstates.
X.TP 8n
Xdevelopment_directory = string;
X.br
XThis field is the absolute path of the change's development directory.
XIt is only present of the change is in a state
Xbetween
X.I being_developed
Xand
X.I being_integrated
Xinclusive.
X.TP 8n
Xintegration_directory = string;
X.br
XThis field is the absolute path of the change's integration directory.
XIt is only present of the change is in the
X.I being_integrated
Xstate.
X.TP 8n
Xhistory = [ { ... }, ... ];
X.br
XThis field records the history of the change,
Xin the form of state transitions.
XThe history records have the form
X.RS 8n
X.TP 8n
Xwhen = integer;
X.br
XThis field records the time the state transition occurred.
X.TP 8n
Xwhat = ( ... );
X.br
XThis field records what happened.
XValid value names echo the various \*(n) functions.
X.TP 8n
Xwho = string;
X.br
XThis field records the user name of the user who caused the state transition.
X.TP 8n
Xwhy = string;
X.br
XThis field is optional.
XIt is a comment of some sort.
XIn the cases of
X.I review_fail
Xand
X.IR integrate_fail ,
Xthis field will contain why the change failed.
X.RE
X.TP 8n
Xsrc = [ { ... }, ... ];
X.br
XThis field is a list of all the files in the change.
XThe records have the form
X.RS 8n
X.TP 8n
Xfile_name = string;
X.br
XThis file names the file.
XThe name is relative to the root of the baseline directory tree.
X.TP 8n
Xaction = (create, modify, remove);
X.br
XThis field describes what is being done with the file.
X.TP 8n
Xedit_number = string;
X.br
XThis field records the edit number of the file
Xwhen it was added to the change (or updated using the
X.I "\*(n) -DIFFerence"
Xcommand).
XThis field is not present for new files.
X.TP 8n
Xusage = (source, test, manual_test);
X.br
XThis field describes what function the file serves.
X.TP 8n
Xdiff_time = integer;
X.br
XThis field records the last time modified of the change file
Xwhen the last
X.I "\*(n) -DIFFerence"
Xcommand was run.
XIt is only present between the
X.I being_developed
Xand
X.I being_integrated
Xstates,
Xinclusive.
XIt is not present for files which are being deleted.
XThis field is used to determine if a difference has been done,
Xand if the file has been tampered with before state transitions.
X.TP 8n
Xdiff_file_time = integer;
X.br
XThis field records the last time modified of the difference file
Xwhen the last
X.I "\*(n) -DIFFerence"
Xcommand was run.
XIt is only present between the
X.I being_developed
Xand
X.I being_integrated
Xstates,
Xinclusive.
XThis field is used to determine if a difference has been done,
Xand if the difference file has been tampered with before state transitions.
X.TP 8n
Xmove = string;
X.br
XTo change the name of a file,
Xa combination of deleting the old name and creating the new name is used.
XWith deleted files, this field is used to say where it went.
XWith new files, this field is used to say where it came from.
X.RE
X.so z_cr.so
END_OF_FILE
if test 6187 -ne `wc -c <'man5/aecstate.5'`; then
    echo shar: \"'man5/aecstate.5'\" unpacked with wrong size!
fi
# end of 'man5/aecstate.5'
fi
if test -f 'man5/aepattr.so' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man5/aepattr.so'\"
else
echo shar: Extracting \"'man5/aepattr.so'\" \(5833 characters\)
sed "s/^X//" >'man5/aepattr.so' <<'END_OF_FILE'
X'\" t
X.\"	aegis - project change supervisor
X.\"	Copyright (C) 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: description of aegis project attribute file format
X.\"
X.TP 8n
Xdescription = string;
XThis field contains
Xa description of the project.
XLarge amounts of prose are not required;
Xa single line is sufficient.
X.TP 8n
Xowner_name = string;
XThis field contains
Xthe name of the user to whom baseline files belong.
X.TP 8n
Xgroup_name = string;
XThis field contains
Xthe name of the group to which baseline files belong.
X.TP 8n
Xdeveloper_may_review = boolean;
XIf this field is true, then a developer may review her own change.
XThis is probably only a good idea for projects of less than 3 people.
XThe idea is for as many people as possible to critically examine a change.
X.TP 8n
Xdeveloper_may_integrate = boolean;
XIf this field is true, then a developer may integrate her own change.
XThis is probably only a good idea for projects of less than 3 people.
XThe idea is for as many people as possible to critically examine a change.
X.TP 8n
Xreviewer_may_integrate = boolean;
XIf this field is true, then a reviewer may integrate a change she reviewed.
XThis is probably only a good idea for projects of less than 3 people.
XThe idea is for as many people as possible to critically examine a change.
X.TP 8n
Xdevelopers_may_create_changes = boolean;
XThis field is true if developers may created changes,
Xin addition to administrators.
XThis tends to be a very useful thing,
Xsince developers find most of the bugs.
X.TP 8n
Xdevelop_end_notify_command = string;
XThis command is used to
Xnotify that a change is ready for review.
XIt will probably use mail,
Xor it could be an in-house bulletin board.
XThis field is optional,
Xif not present no notification will be given.
XThis command could also be used to notify other management systems,
Xsuch as progress and defect tracking.
XAll of the substitutions described by
X.IR aesub (5)
Xare available.
X.TP 8n
Xdevelop_end_undo_notify_command = string;
XThis command is used to
Xnotify that a change had been withdrawn from review
Xfor further development.
XIt will probably use mail,
Xor it could be an in-house bulletin board.
XThis field is optional,
Xif not present no notification will be given.
XThis command could also be used to notify other management systems,
Xsuch as progress and defect tracking.
XAll of the substitutions described by
X.IR aesub (5)
Xare available.
X.TP 8n
Xreview_pass_notify_command = string;
XThis command is used to
Xnotify that a review has passed.
XIt will probably use mail,
Xor it could be an in-house bulletin board.
XThis field is optional,
Xif not present no notification will be given.
XThis command could also be used to notify other management systems,
Xsuch as progress and defect tracking.
XAll of the substitutions described by
X.IR aesub (5)
Xare available.
X.TP 8n
Xreview_pass_undo_notify_command = string;
XThis command is used to
Xnotify that a review has passed.
XIt will probably use mail,
Xor it could be an in-house bulletin board.
XThis field is optional,
Xif not present no notification will be given.
XThis command could also be used to notify other management systems,
Xsuch as progress and defect tracking.
XDefaults to the same action as the \fIdevelop_end_notify_command\fP field.
XAll of the substitutions described by
X.IR aesub (5)
Xare available.
X.TP 8n
Xreview_fail_notify_command = string;
XThis command is used to
Xnotify that a review has failed.
XIt will probably use mail,
Xor it could be an in-house bulletin board.
XThis field is optional,
Xif not present no notification will be given.
XThis command could also be used to notify other management systems,
Xsuch as progress and defect tracking.
XAll of the substitutions described by
X.IR aesub (5)
Xare available.
X.TP 8n
Xintegrate_pass_notify_command = string;
XThis command is used to
Xnotify that an integration has passed.
XIt will probably use mail,
Xor it could be an in-house bulletin board.
XThis field is optional,
Xif not present no notification will be given.
XThis command could also be used to notify other management systems,
Xsuch as progress and defect tracking.
XAll of the substitutions described by
X.IR aesub (5)
Xare available.
X.TP 8n
Xintegrate_fail_notify_command = string;
XThis command is used to
Xnotify that an integration has failed.
XIt will probably use mail,
Xor it could be an in-house bulletin board.
XThis field is optional,
Xif not present no notification will be given.
XThis command could also be used to notify other management systems,
Xsuch as progress and defect tracking.
XAll of the substitutions described by
X.IR aesub (5)
Xare available.
X.TP 8n
Xdefault_development_directory = string;
XThe pathname of where to place new development directories.
XThe pathname must be absolute.
XThis field is only consulted if
Xthe field of the same name in the user configuration file is not set.
X.TP 8n
Xumask = integer;
X.br
XFile permission mode mask.
XSee
X.IR umask (2)
Xfor more information.
XThis value will always be OR'ed with 022,
Xbecause
X.I aegis
Xis paranoid.
X.TP 8n
Xdefault_test_exemption = boolean;
X.br
XThis field contains what to do when a change is created with
Xno test exemption specified.
END_OF_FILE
if test 5833 -ne `wc -c <'man5/aepattr.so'`; then
    echo shar: \"'man5/aepattr.so'\" unpacked with wrong size!
fi
# end of 'man5/aepattr.so'
fi
if test -f 'man5/aepconf.5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man5/aepconf.5'\"
else
echo shar: Extracting \"'man5/aepconf.5'\" \(7024 characters\)
sed "s/^X//" >'man5/aepconf.5' <<'END_OF_FILE'
X'\" t
X.\"	aegis - project change supervisor
X.\"	Copyright (C) 1991, 1992, 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: description of aegis project config file format
X.\"
X.so z_name.so
X.TH aepconf 5 \*(N)
X.SH NAME
Xaepconf - \*(n) project configuration file
X.SH SYNOPSIS
X\fIproject\fP\f(CW/baseline/config\fP
X.SH DESCRIPTION
XA project configuration file
Xis used to store information about a project.
XThis file is under source control,
Xand is one of the project's source files.
XDevelopers may thus modify this file as part of a change.
X.SH CONTENTS
XThis file contains the following fields:
X.TP 8n
Xbuild_command = string;
XThis field describes how to build the project
X(actually, how to do an integration build).
XThis field is mandatory.
XAll of the substitutions described by
X.IR aesub (5)
Xare available.
X.TP 8n
Xdevelopment_build_command = string;
XThis field describes how to do a development build.
XIf this field is absent, it defaults to the above.
XAll of the substitutions described by
X.IR aesub (5)
Xare available.
X.TP 8n
Xchange_file_command = string;
X.RS 8n
XThis field contains a command to be executed whenever
Xa '\*(n) -CoPy_file', '\*(n) -CoPy_file_Undo', '\*(n) -New_File', '\*(n) -New_File_Undo', '\*(n) -ReMove_file'
Xor '\*(n) -ReMove_file_Undo'
Xcommand is successful.
XIf this field is absent, nothing is done.
XAll of the substitutions described by
X.IR aesub (5)
Xare available;
Xin addition,
X.TP 8n
X${File_List}
X.br
XSpace separated list of files named.
X.RE
X.TP 8n
Xproject_file_command = string;
X.br
XThis field contains a command to be executed
Xduring a development build
Xbefore the
X.I "development build command"
Xabove, when 
X(a) it is the first build after a develop begin, or
X(b) some other change has been integrated into
Xthe baseline since the last build.
XIf this field is absent, nothing is done.
XAll of the substitutions described by
X.IR aesub (5)
Xare available.
X.TP 8n
Xintegrate_begin_command = string;
XThis field contains a command to be executed whenever
Xa '\*(n) -Integrate_Begin'
Xcommand is successful.
XIf this field is absent, nothing is done.
XAll of the substitutions described by
X.IR aesub (5)
Xare available.
X.TP 8n
Xlink_integration_directory
X.br
XThis flag is true if aegis should link the files from the baseline
Xinto the integration directory,
Xrather than copy them (the default).
XThis has risks,
Xas the build script (e.g.
X.I Howto.cook
Xor
X.IR Makefile ,
Xetc)
Xmust unlink targets before rebuilding them;
Xif this is not done the baseline will be corrupted.
X.TP 8n
Xhistory_create_command = string;
X.RS 8n
XThis field is used to create a new history.
XThe command is always executed as the project owner.
XAll of the substitutions described by
X.IR aesub (5)
Xare available;
Xin addition,
X.TP 8n
X${Input}
X.br
XAbsolute path of the source file.
X.TP 8n
X${History}
X.br
XAbsolute path of the history file.
XThis may need to be reworked with the
X.I Dirname
Xand
X.I Basename
Xsubstitutions to yield a string suitable for the history tool in question.
X.RE
X.TP 8n
Xhistory_get_command = string;
X.RS 8n
XThis field is used to get a file from history.
XThe command may be executed by developers.
XAll of the substitutions described by
X.IR aesub (5)
Xare available;
Xin addition,
X.TP 8n
X${History}
X.br
XThe absolute path of the history file.
XThis may need to be reworked with the
X.I Dirname
Xand
X.I Basename
Xsubstitutions to yield a string suitable for the history tool in question.
X.TP 8n
X${Edit}
X.br
XThe edit number to be extracted.
XIt may be an arbitrary string,
Xvarying on the particular history tool.
X.TP 8n
X${Output}
X.br
XThe absolute path of the destination file.
X.RE
X.TP 8n
Xhistory_put_command = string;
X.RS
XThis field is used to add a new change to the history.
XThe command is always executed as the project owner.
XAll of the substitutions described by
X.IR aesub (5)
Xare available;
Xin addition,
X.TP 8n
X${Input}
X.br
XThe absolute path of the source file.
X.TP 8n
X${History}
X.br
XThe absolute path of the history file.
XThis may need to be reworked with the
X.I Dirname
Xand
X.I Basename
Xsubstitutions to yield a string suitable for the history tool in question.
X.RE
X.TP 8n
Xhistory_query_command = string;
X.RS 8n
XThis field is used to query the topmost edit of a history file.
XResult to be printed on the standard output.
XThis command may be executed by developers.
XAll of the substitutions described by
X.IR aesub (5)
Xare available;
Xin addition,
X.TP 8n
X${History}
X.br
XThe absolute path of the history file.
XThis may need to be reworked with the
X.I Dirname
Xand
X.I Basename
Xsubstitutions to yield a string suitable for the history tool in question.
X.RE
X.TP 8n
Xdiff_command = string;
X.RS
XThis field is used to difference of 2 files.
XThe command is always executed by developers.
XAll of the substitutions described by
X.IR aesub (5)
Xare available;
Xin addition,
X.TP 8n
X${ORiginal}
X.br
XThe absolute path of the original
Xfile copied into the change.
XUsually in the baseline,
Xbut not always.
X.TP 8n
X${Input}
X.br
XThe absolute path of the file in the development directory.
X.TP 8n
X${Output}
X.br
XThe absolute path of the file in which to write the difference listing.
X.RE
X.TP 8n
Xdiff3_command = string;
X.RS 8n
XThis field is used to difference 3 files.
XThe command is always executed by developers.
XAll of the substitutions described by
X.IR aesub (5)
Xare available;
Xin addition,
X.TP 8n
X${ORiginal}
X.br
XThe absolute path of the original
Xfile copied into the change.
XUsually not in the baseline.
X.TP 8n
X${Most_Recent}
X.br
XThe absolute path of the competing edit,
Xusually in the baseline.
X.TP 8n
X${Input}
X.br
XThe absolute path of the file in the development directory.
X.TP 8n
X${Output}
X.br
XThe absolute path of the file in which to write the difference listing.
X.RE
X.TP 8n
Xfile_template = [ { ... } ];
X.br
XThe file template is consulted whenever a new file is created,
Xby one of the
X.IR aenf (1)
Xor
X.IT aent (1)
Xcommands.
XEach list item has the form:
X.RS
X.TP 8n
Xpattern = [ string ];
XThe name of the file,
Xrelative to the development directory.
XEach string is a shell file name pattern;
Xsee
X.IR sh (1)
Xfor more information.
X.TP 8n
Xbody = string;
XWhat to initialize the body of the file to.
XThere are no substitutions.
X.PP
XAll of the substitutions described in
X.IR aesub (5)
Xare available for the body string.
XIn addition, ${File_Name} will be replaced by the name of the new file.
X.RE
X.SH SEE ALSO
X.IR aeb (1)
X.so z_cr.so
END_OF_FILE
if test 7024 -ne `wc -c <'man5/aepconf.5'`; then
    echo shar: \"'man5/aepconf.5'\" unpacked with wrong size!
fi
# end of 'man5/aepconf.5'
fi
if test -f 'man5/aesub.5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man5/aesub.5'\"
else
echo shar: Extracting \"'man5/aesub.5'\" \(7265 characters\)
sed "s/^X//" >'man5/aesub.5' <<'END_OF_FILE'
X'\" t
X.\"	aegis - project change supervisor
X.\"	Copyright (C) 1993 Peter Miller.
X.\"	All rights reserved.
X.\"
X.\"	This program is free software; you can redistribute it and/or modify
X.\"	it under the terms of the GNU General Public License as published by
X.\"	the Free Software Foundation; either version 2 of the License, or
X.\"	(at your option) any later version.
X.\"
X.\"	This program is distributed in the hope that it will be useful,
X.\"	but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\"	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\"	GNU General Public License for more details.
X.\"
X.\"	You should have received a copy of the GNU General Public License
X.\"	along with this program; if not, write to the Free Software
X.\"	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" MANIFEST: manual page describing command substitutions
X.\"
X.so z_name.so
X.TH aesub 5 \*(N)
X.if n .ad l
X.if n .hy 0
X.SH NAME
Xaesub \- available command substitutions
X.SH DESCRIPTION
XWhen other programs are invoked by the
X.I aegis
Xprogram,
Xit is usually via a command string in a configuration file.
XThis section describes the format of these command strings.
X.SH GENERAL FORM
XThe command strings are very similar to shell variables.
XAn example will illustrate this:
X.RS 8n
X.nf
Xbuild_command =
X	"cook project=${project} change=${change}";
X.fi
X.RE
XIn this command definition,
Xthe "${project}" part is a substitution:
Xthe name of the project will be substituted
Xin the command at this point.
X.PP
XSubstitutions may take several forms:
X.TP 8n
X$name
X.br
XThis is the same as saying "${name}".
XThe name must start with an alphabetic,
Xand be followed by zero or more alphanumerics.
X.TP 8n
X${name}
X.br
XThe name in this form may contain any non-blank characters,
Xand it may be subject to substitution.
X.TP 8n
X${name \fIarg\fP...}
X.br
XThe name and the arguments in this form may contain any non-blank characters,
Xand it may be subject to further substitution.
X.TP 8n
X$$
X.br
XThis is replaced by a single $ character.
X.PP
XAs another example,
Xthe
X.I dirname
Xsubstitution is replaced by the directory name of the argument,
Xrather like the
X.IR dirname (1)
Xcommand.
XIn the command
X.RS
X.nf
Xhistory_query_command =
X	"get -t -g ${Dirname $History}/s.${Basename $History}";
X.fi
X.RE
Xthe
X.I Dirname
Xand
X.I Basename
Xsubstitutions are used to construct a suitable path to the SCCS
Xfile in the history directory.
X.SH ABBREVIATIONS
XThe names of the various substitutions may be abbreviated.
XIn the above examples,
Xand in the lists which follow,
Xthe minimum abbreviation is the uppercase letters.
XAll substitution name are case insensitive.
X.PP
XThe above example could be abbreviated to
X.RS
X.nf
Xhistory_query_command =
X	"get -t -g ${d $h}/s.${b $h}";
X.fi
X.RE
X.PP
XAmbiguous abbreviations will result in a fatal error message.
X.SH SUBSTITUTIONS
XThere are many substitutions which are always understood,
Xand some which are specific to the command being substituted.
XSpecific entries will be defined in the relevant manual section.
X.PP
XThe following lists contains those substitutions which are always understood:
X.TP 8n
XAdministrator_List
X.br
XSpace separated list of the project's administrators.
X.TP 8n
XBaseLine
X.br
XAbsolute path of the the project's baseline.
X.TP 8n
XBasename
X.br
XThis substitution takes one argument,
Xa pathname.
XThe value of the substitution will be the last element of the pathname.
XThis is similar to the
X.IR basename (1)
Xcommand.
X.TP 8n
XChange
X.br
XThe change number.
X.TP 8n
XDAte
X.br
XWith no arguments,
Xthe output is the current date.
XIf there are arguments,
Xthey forma format string.
XThis is similar to the
X.IR date (1)
Xcommand on many UNIX systems.
XFor a description of the date formats,
Xsee the
X.I DATE
Xsection,
Xbelow.
X.TP 8n
XDELta
X.br
XThe delta number of the change.
XThis is only available when the change is in the
X.I "being integrated"
Xstate or the
X.I completed
Xstate.
X.TP 8n
XDEVeloper
X.br
XThe name of the developer.
X.TP 8n
XDEVeloper_List
X.br
XSpace separated list of the project's developers.
X.TP 8n
XDevelopment_Directory
X.br
XThe absolute path of the change's development directory.
XOnly available when the change is between the
X.I "being developed"
Xstate and the
X.I "being integrated"
Xstate.
X.TP 8n
XDirname
X.br
XThis substitution takes one argument,
Xa pathname.
XThe value of the substitution will be everything but
Xthe last element of the pathname.
XThis is similar to the
X.IR dirname (1)
Xcommand.
X.TP 8n
XDownCase
X.br
XThis substitution takes one argument.
XThe value of the substitution will be the argument with
Xany upper case letters mapped to lower case.
X.TP 8n
XIDentifier
X.br
XThis substitution takes one argument.
XThe value of the substitution will be the argument with
Xall characters but alpha numerics mapped into an underscore (_),
Xso as to form a legal C identifier.
X.TP 8n
XINTegration_Directory
X.br
XThe absolute path of the change's integration directory.
XOnly available when the change is in the
X.I "being integrated"
Xstate.
X.TP 8n
XINTegrator
X.br
XThe name of the change's integrator.
XOnly available when the change is in the
X.I "being integrated"
Xstate or the
X.I "completed"
Xstate.
X.TP 8n
XINTegrator_List
X.br
XSpace separated list of the project's integrators.
X.TP 8n
XProject
X.br
XThe name of the project.
X.TP 8n
XReviewer
X.br
XThe name of the change's reviewer.
XOnly available when the change is between the
X.I "awaiting integration"
Xstate and the
X.I "completed"
Xstate.
X.TP 8n
XReviewer_List
X.br
XSpace separated list of the project's reviewers.
X.TP 8n
XUpCase
X.br
XThis substitution takes one argument.
XThe value of the substitution will be the argument with
Xany lower case letters mapped to upper case.
X.TP 8n
XVersion
X.br
XThe version of the change.
XIf the change is in the
X.I "being integrated"
Xstate or the
X.I "completed"
Xstate,
Xthe version will be of the form "\fIa\fB.\fIb\fB.D\fIddd\fR",
Xwhere "a" is the project's major version number,
X"b" is the project's minor version number, and
X"ddd" is the change's delta number.
XIf the change is in any other state,
Xthe version will be of the form "\fIa\fB.\fIb\fB.C\fIccc\fR",
Xwhere "ccc" is the change number.
X.SH DATE
XThis section describes the format specifiers accepted by the
Xdate substitution.
XThese are the same specifiers as defined
Xby the ANSI C standard
Xfor the strftime function.
X.TP 8n
X%%
XThe percent character (%)
X.TP 8n
X%a
Xthe abbreviated weekday name
X.TP 8n
X%A
Xthe full weekday name
X.TP 8n
X%b
Xthe abbreviated month name
X.TP 8n
X%B
Xthe full month name
X.TP 8n
X%c
Xthe date and time
X.TP 8n
X%d
Xthe day of the month,
Xzero padded
X.TP 8n
X%H
Xthe hour of the 24-hour day
X.TP 8n
X%I
Xthe hour of the 12-hour day
X.TP 8n
X%j
Xthe day number of year,
Xzero padded, one based
X.TP 8n
X%m
Xthe month of the year,
Xzero padded, one based
X.TP 8n
X%M
Xthe minute of the hour,
Xzero padded
X.TP 8n
X%p
Xmeridian indicator,
XAM or PM as appropriate
X.TP 8n
X%S
Xthe second of the minute
X.TP 8n
X%U
Xthe Sunday week of the year
X.TP 8n
X%w
Xthe day of the week,
XSunday is 0
X.TP 8n
X%W
Xthe Monday week of the year
X.TP 8n
X%x
Xthe date,
Xas \fImmm dd yyyy\fP
X.TP 8n
X%X
Xthe time,
Xas \fIhh:mm:ss\fP
X.TP 8n
X%y
Xthe year of the century
X.TP 8n
X%Y
Xthe year including the century
X.TP 8n
X%Z
Xtime zone abbreviation
X.PP
XUsing an undefined format specifier will
Xproduce random results,
Xdepending on the version of UNIX you are on.
X.so z_cr.so
END_OF_FILE
if test 7265 -ne `wc -c <'man5/aesub.5'`; then
    echo shar: \"'man5/aesub.5'\" unpacked with wrong size!
fi
# end of 'man5/aesub.5'
fi
if test -f 'script/xaegis.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'script/xaegis.tcl'\"
else
echo shar: Extracting \"'script/xaegis.tcl'\" \(6744 characters\)
sed "s/^X//" >'script/xaegis.tcl' <<'END_OF_FILE'
X#! /usr/local/bin/wish -f
X#
X#	aegis - project change supervisor
X#	Copyright (C) 1993 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: wish script to give aegis a GUI interface
X#
X# You will need to have tcl/tk/wish installed for this to work correctly.
X# This script is based on tcl 7.0 and tk 3.3.
X#
X
Xset lib /usr/local/lib/aegis
X
X#
X# set window manager properties for the top-level window
X#
Xwm title . Aegis
Xwm maxsize . 32767 32767
Xwm minsize . 200 100
Xwm iconname . Aegis
Xwm iconbitmap . @$lib/aegis.icon
Xwm iconmask . @$lib/aegis.mask
X
X#
X# create the menu bar
X#
Xframe .menubar -relief raised -borderwidth 1
Xpack .menubar -side top -fill x
Xmenubutton .menubar.file -text "File" -menu .menubar.file.m
Xmenubutton .menubar.command -text "Command" -menu .menubar.command.m
Xpack append .menubar .menubar.file left .menubar.command left
X
Xmenu .menubar.file.m
X.menubar.file.m add command \
X	-label "Quit" \
X	-command exit
X 
Xmenu .menubar.command.m
X.menubar.command.m add cascade		\
X	-label "Developer"		\
X	-menu .menubar.command.m.developer
X.menubar.command.m add cascade		\
X	-label "Reviewer"		\
X	-menu .menubar.command.m.reviewer
X.menubar.command.m add cascade		\
X	-label "Integrator"		\
X	-menu .menubar.command.m.integrator
X.menubar.command.m add cascade		\
X	-label "Administrator"		\
X	-menu .menubar.command.m.administrator
X
Xmenu .menubar.command.m.developer
X.menubar.command.m.developer add command \
X	-label "Develop Begin" \
X	-command not_implemented
X.menubar.command.m.developer add command \
X	-label "Develop Begin Undo" \
X	-command not_implemented
X.menubar.command.m.developer add command \
X	-label "Copy File" \
X	-command not_implemented
X.menubar.command.m.developer add command \
X	-label "Copy File Undo" \
X	-command not_implemented
X.menubar.command.m.developer add command \
X	-label "New File" \
X	-command not_implemented
X.menubar.command.m.developer add command \
X	-label "New File Undo" \
X	-command not_implemented
X.menubar.command.m.developer add command \
X	-label "New Test" \
X	-command not_implemented
X.menubar.command.m.developer add command \
X	-label "New Test Undo" \
X	-command not_implemented
X.menubar.command.m.developer add command \
X	-label "Remove File" \
X	-command not_implemented
X.menubar.command.m.developer add command \
X	-label "Remove File Undo" \
X	-command not_implemented
X.menubar.command.m.developer add command \
X	-label "Build" \
X	-command not_implemented
X.menubar.command.m.developer add command \
X	-label "Test" \
X	-command not_implemented
X.menubar.command.m.developer add command \
X	-label "Difference" \
X	-command not_implemented
X.menubar.command.m.developer add command \
X	-label "Develop End" \
X	-command not_implemented
X.menubar.command.m.developer add command \
X	-label "Develop End Undo" \
X	-command not_implemented
X
Xmenu .menubar.command.m.reviewer
X.menubar.command.m.reviewer add command \
X	-label "Review Fail" \
X	-command not_implemented
X.menubar.command.m.reviewer add command \
X	-label "Review Pass" \
X	-command not_implemented
X.menubar.command.m.reviewer add command \
X	-label "Review Pass Undo" \
X	-command not_implemented
X
Xmenu .menubar.command.m.integrator
X.menubar.command.m.integrator add command \
X	-label "Integrate Begin" \
X	-command not_implemented
X.menubar.command.m.integrator add command \
X	-label "Integrate Begin Undo" \
X	-command not_implemented
X.menubar.command.m.integrator add command \
X	-label "Build" \
X	-command not_implemented
X.menubar.command.m.integrator add command \
X	-label "Test" \
X	-command not_implemented
X.menubar.command.m.integrator add command \
X	-label "Integrate Fail" \
X	-command not_implemented
X.menubar.command.m.integrator add command \
X	-label "Integrate Pass" \
X	-command not_implemented
X
Xmenu .menubar.command.m.administrator
X.menubar.command.m.administrator add command \
X	-label "New Change" \
X	-command not_implemented
X.menubar.command.m.administrator add command \
X	-label "New Change Undo" \
X	-command not_implemented
X.menubar.command.m.administrator add command \
X	-label "Edit Change Attributes" \
X	-command not_implemented
X.menubar.command.m.administrator add command \
X	-label "Edit Project Attributes" \
X	-command not_implemented
X.menubar.command.m.administrator add command \
X	-label "New Developer" \
X	-command not_implemented
X.menubar.command.m.administrator add command \
X	-label "Remove Developer" \
X	-command not_implemented
X.menubar.command.m.administrator add command \
X	-label "New Reviewer" \
X	-command not_implemented
X.menubar.command.m.administrator add command \
X	-label "Remove Reviewer" \
X	-command not_implemented
X.menubar.command.m.administrator add command \
X	-label "New Integrator" \
X	-command not_implemented
X.menubar.command.m.administrator add command \
X	-label "Remove Integrator" \
X	-command not_implemented
X.menubar.command.m.administrator add command \
X	-label "New Administrator" \
X	-command not_implemented
X.menubar.command.m.administrator add command \
X	-label "Remove Administrator" \
X	-command not_implemented
X.menubar.command.m.administrator add command \
X	-label "New Project" \
X	-command not_implemented
X.menubar.command.m.administrator add command \
X	-label "Remove Project" \
X	-command not_implemented
X.menubar.command.m.administrator add command \
X	-label "New Project Release" \
X	-command not_implemented
X
X#
X# message when function is not implemented
X#
Xproc not_implemented {} \
X{
X	catch { destroy .notimp }
X	toplevel .notimp
X	wm title .notimp "Aegis"
X	wm iconname .notimp "Aegis"
X
X	message .notimp.msg \
X		-text "Work in progress\nFunction not yet implemented" \
X		-just center -aspect 300
X	pack .notimp.msg -side top -padx 10 -pady 10
X
X	button .notimp.button -text "Sigh" -command "destroy .notimp"
X	pack .notimp.button -side bottom -padx 10 -pady 10
X	bind .notimp <Return> "destroy .notimp"
X	focus .notimp
X}
X
X#
X# draw the aegis icon in a simple frame
X#
Xproc icon_screen { } \
X{
X	global lib
X	catch { destroy .screen }
X	frame .screen -width 200 -height 100
X	pack .screen -side bottom
X	label .screen.icon -bitmap @$lib/aegis.icon
X	pack .screen.icon -anchor center
X}
X
X#
X# on start-up, display the icon
X#
Xicon_screen
END_OF_FILE
if test 6744 -ne `wc -c <'script/xaegis.tcl'`; then
    echo shar: \"'script/xaegis.tcl'\" unpacked with wrong size!
fi
# end of 'script/xaegis.tcl'
fi
if test -f 'test/00/t0004a.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test/00/t0004a.sh'\"
else
echo shar: Extracting \"'test/00/t0004a.sh'\" \(7169 characters\)
sed "s/^X//" >'test/00/t0004a.sh' <<'END_OF_FILE'
X#! /bin/sh
X#
X#	aegis - project change supervisor
X#	Copyright (C) 1991, 1992, 1993 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: Test the 'aegis -DIFFerence' command.
X#
X# File which are removed should be 'diff /baseline/x /dev/null'ed,
X# rather than 'diff ./x /dev/null'ed.
X# This will generate an error out of 'diff' if the local
X# file is used, because it will not be found.
X#
X
Xunset AEGIS_PROJECT
Xunset AEGIS_CHANGE
Xumask 022
X
XUSER=${USER:-${LOGNAME:-`whoami`}}
X
Xwork=${AEGIS_TMP:-/tmp}/$$
X
Xfail()
X{
X	set +x
X	echo "FAILED test of 'aegis -DIFFerence' command" 1>&2
X	find $work -type d -user $USER -exec chmod u+w {} \;
X	rm -rf $work
X	exit 1
X}
Xpass()
X{
X	set +x
X	echo PASSED 1>&2
X	find $work -type d -user $USER -exec chmod u+w {} \;
X	rm -rf $work
X	exit 0
X}
Xtrap "fail" 1 2 3 15
X
X#
X# some variable to make things earier to read
X#
XPAGER=cat
Xexport PAGER
Xworklib=$work/lib
Xworkproj=$work/foo.proj
Xworkchan=$work/foo.chan
Xtmp=$work/tmp
X
X#
X# echo commands so we can tell what failed
X#
Xset -x
X
X#
X# make the directories
X#
Xmkdir $work
X
X#
X# make a new project
X#
X./bin/aegis -newpro foo -dir $workproj -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# change project attributes
X#
Xcat > $tmp << 'end'
Xdescription = "A bogus project created to test things.";
Xdeveloper_may_review = true;
Xdeveloper_may_integrate = true;
Xreviewer_may_integrate = true;
Xend
X./bin/aegis -proatt $tmp -proj foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# create a new change
X#	make sure it creates the files it should
X#
Xcat > $tmp << 'end'
Xbrief_description = "This change is used to test the aegis functionality \
Xwith respect to change descriptions.";
Xcause = internal_bug;
Xend
X./bin/aegis -new_change $tmp -project foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# create a second change
X#	make sure it creates the files it should
X#
Xcat > $tmp << 'end'
Xbrief_description = "This change was added to make the various listings \
Xmuch more interesting.";
Xcause = internal_bug;
Xend
X./bin/aegis -new_change $tmp -project foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add a new developer
X#
X./bin/aegis -newdev $USER -p foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# begin development of a change
X#
X./bin/aegis -devbeg 1 -p foo -dir $workchan -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add a new files to the change
X#
X./bin/aegis -new_file $workchan/main.c -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X./bin/aegis -new_file $workchan/fubar -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X./bin/aegis -new_file $workchan/config -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# put something in 'main.c'
X#
Xcat > $workchan/main.c << 'end'
Xvoid
Xmain()
X{
X	exit(0);
X}
Xend
X
X#
X# put something in 'config'
X#
Xcat > $workchan/config << 'end'
Xbuild_command = "rm -f foo; cc -o foo -D'VERSION=\"$v\"' main.c";
Xlink_integration_directory = true;
X
Xhistory_get_command =
X	"co -u'$e' -p $h,v > $o";
Xhistory_create_command =
X	"ci -u -m/dev/null -t/dev/null $i $h,v; rcs -U $h,v";
Xhistory_put_command =
X	"ci -u -m/dev/null -t/dev/null $i $h,v; rcs -U $h,v";
Xhistory_query_command =
X	"rlog -r $h,v | awk '/^head:/ {print $$2}'";
X
Xdiff_command = "set +e; diff $orig $i > $out; test $$? -le 1";
X
Xdiff3_command = "(diff3 -e $mr $orig $i | sed -e '/^w$$/d' -e '/^q$$/d'; \
X	echo '1,$$p' ) | ed - $mr > $out";
Xend
X
X#
X# create a new test
X#
X./bin/aegis -nt -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# put something in 'test/00/t0001a.sh'
X#
Xcat > $workchan/test/00/t0001a.sh << 'end'
X#!/bin/sh
X#
X# Project: "foo"
X# Change: 1
X#
X
Xfail()
X{
X	echo SHUZBUTT 1>&2
X	exit 1
X}
Xpass()
X{
X	exit 0
X}
Xtrap "fail" 1 2 3 15
X
X./foo
Xq=$?
X
X# check for signals
Xif test $q -ge 128 
Xthen
X	fail
Xfi
X
X# should not complain
Xif test $q -ne 0 
Xthen
X	fail
Xfi
X
X# it probably worked
Xpass
Xend
X
X#
X# let the clock tick over, so the build will be happy
X#
Xsleep 1
X
X#
X# build the change
X#
X./bin/aegis -build -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# difference the change
X#
X./bin/aegis -diff -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# test the change
X#
X./bin/aegis -test -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# finish development of the change
X#
X./bin/aegis -dev_end -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add a new reviewer
X#
X./bin/aegis -newrev $USER -p foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# pass the review
X#
X./bin/aegis -review_pass -chan 1 -proj foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add an integrator
X#
X./bin/aegis -newint $USER -p foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# start integrating
X#
X./bin/aegis -intbeg 1 -p foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# integrate build
X#
Xsleep 1
X./bin/aegis -build -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# integrate test
X#
X./bin/aegis -test -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# integration pass
X#
X./bin/aegis -intpass -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# start work on change 2
X#
X./bin/aegis -devbeg 2 -p foo -v -dir $workchan -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# copy a file into the change
X#
X./bin/aegis -cp $workchan/main.c -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# remove a file with the change
X#
X./bin/aegis -rm $workchan/fubar -nl -p foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# change the file
X#
Xcat > $workchan/main.c << 'end'
X
X#include <stdio.h>
X
Xvoid
Xmain(argc, argv)
X	int	argc;
X	char	**argv;
X{
X	if (argc != 1)
X	{
X		fprintf(stderr, "usage: %s\n", argv[0]);
X		exit(1);
X	}
X	printf("hello, world\n");
X	exit(0);
X}
Xend
X
X#
X# need another test
X#
X./bin/aegis -nt -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
Xcat > $workchan/test/00/t0002a.sh << 'end'
X#!/bin/sh
X#
X# Project: "foo"
X# Change: 2
X#
X
Xfail()
X{
X	echo SHUZBUTT 1>&2
X	exit 1
X}
Xpass()
X{
X	exit 0
X}
Xtrap "fail" 1 2 3 15
X
X./foo ickky
Xq=$?
X
X# check for signals
Xif test $q -ge 128 
Xthen
X	fail
Xfi
X
X# should have complained
Xif test $q -eq 0 
Xthen
X	fail
Xfi
X
X# it probably worked
Xpass
Xend
X
X#
X# tick over clock to keep build happy
X#
Xsleep 1
X
X#
X# diff the change
X#	This is what all the set-up was about!
X#
X./bin/aegis -diff -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X# should be no automatic logging
Xif test "`find $work -name 'aegis.log' -print`" != "" ; then fail; fi
X
X#
X# the things tested in this test, worked
X#
Xpass
X
END_OF_FILE
if test 7169 -ne `wc -c <'test/00/t0004a.sh'`; then
    echo shar: \"'test/00/t0004a.sh'\" unpacked with wrong size!
fi
# end of 'test/00/t0004a.sh'
fi
if test -f 'test/00/t0007a.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test/00/t0007a.sh'\"
else
echo shar: Extracting \"'test/00/t0007a.sh'\" \(6476 characters\)
sed "s/^X//" >'test/00/t0007a.sh' <<'END_OF_FILE'
X#! /bin/sh
X#
X#	aegis - project change supervisor
X#	Copyright (C) 1991, 1992, 1993 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: test for correct behaviour around symbolic links
X#
X# Make sure can cope with symbolic links.
X# This test will always pass on systems without symbolic links.
X#
X
Xunset AEGIS_PROJECT
Xunset AEGIS_CHANGE
Xumask 022
X
XUSER=${USER:-${LOGNAME:-`whoami`}}
X
XPAGER=cat
Xexport PAGER
Xwork=${AEGIS_TMP:-/tmp}/$$
X
Xhere=`pwd`
Xif test $? -ne 0 ; then exit 1; fi
Xmkdir $work
Xif test $? -ne 0 ; then exit 1; fi
X
Xfail()
X{
X	set +x
X	cd $here
X	echo FAILED test for correct behaviour around symbolic links 1>&2
X	find $work -type d -user $USER -exec chmod u+w {} \;
X	rm -rf $work
X	exit 1
X}
Xpass()
X{
X	set +x
X	cd $here
X	find $work -type d -user $USER -exec chmod u+w {} \;
X	rm -rf $work
X	exit 0
X}
Xtrap "fail" 1 2 3 15
X
Xcd $work
Xif test $? -ne 0 ; then fail; fi
X
X#
X# program to ask questions about symlinks
X#
Xcat > symlink.c << 'fubar'
X#include <sys/types.h>
X#include <sys/stat.h>
Xvoid
Xmain(argc, argv)
X	int	argc;
X	char	**argv;
X{
X#ifdef S_IFLNK
X	if (argc == 2)
X	{
X		struct stat st;
X		if (lstat(argv[1], &st))
X			exit(0);
X		/* fails if file exists */
X		exit(1);
X	}
X	exit(0);
X#else
X	exit(2);
X#endif
X}
Xfubar
Xif test $? -ne 0 ; then fail; fi
Xcc -o symlink symlink.c
Xif test $? -ne 0 ; then fail; fi
X
X#
X# if this system has no symlinks
X# automagically pass the test
X#
X./symlink
Xif test $? -ge 2 ; then pass; fi
X
X#
X# some variable to make things earier to read
X#
Xworklib=$work/lib
Xworkproj=$work/foo.proj
Xworkchan=$work/foo.chan
Xtmp=$work/tmp
Xsymlinktestfile=$workchan/symlink
Xsymlinkdest=$workchan/symlinkdest
X
X#
X# make a new project
X#	and check files it should have made
X#
X$here/bin/aegis -newpro foo -dir $workproj -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# change project attributes
X#
Xcat > $tmp << 'end'
Xdescription = "A bogus project created to test things.";
Xdeveloper_may_review = true;
Xdeveloper_may_integrate = true;
Xreviewer_may_integrate = true;
Xend
X$here/bin/aegis -proatt $tmp -proj foo -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# create a new change
X#	make sure it creates the files it should
X#
Xcat > $tmp << 'end'
Xbrief_description = "This change is used to test the aegis functionality \
Xwith respect to change descriptions.";
Xcause = internal_bug;
Xend
X$here/bin/aegis -new_change $tmp -project foo -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add a new developer
X#
X$here/bin/aegis -newdev $USER -p foo -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# begin development of a change
X#	check it made the files it should
X#
X$here/bin/aegis -devbeg 1 -p foo -dir $workchan -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# create a symbolic link in the development directory
X#
Xmkdir $symlinkdest
Xif test $? -ne 0 ; then fail; fi
Xln -s $symlinkdest $symlinktestfile
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add a new files to the change
X#
X$here/bin/aegis -new_file $workchan/main.c -nl -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -new_file $workchan/config -nl -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
Xcat > $workchan/main.c << 'end'
Xvoid
Xmain()
X{
X	exit(0);
X}
Xend
Xcat > $workchan/config << 'end'
Xbuild_command = "rm -f foo; cc -o foo -D'VERSION=\"$v\"' main.c";
Xlink_integration_directory = true;
X
Xhistory_get_command =
X	"co -u'$e' -p $h,v > $o";
Xhistory_create_command =
X	"ci -u -m/dev/null -t/dev/null $i $h,v; rcs -U $h,v";
Xhistory_put_command =
X	"ci -u -m/dev/null -t/dev/null $i $h,v; rcs -U $h,v";
Xhistory_query_command =
X	"rlog -r $h,v | awk '/^head:/ {print $$2}'";
X
Xdiff_command = "set +e; diff $orig $i > $out; test $$? -le 1";
X
Xdiff3_command = "(diff3 -e $mr $orig $i | sed -e '/^w$$/d' -e '/^q$$/d'; \
X	echo '1,$$p' ) | ed - $mr > $out";
Xend
X
X#
X# create a new test
X#
X$here/bin/aegis -nt -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
Xcat > $workchan/test/00/t0001a.sh << 'end'
X#!/bin/sh
X#
X# Project: "foo"
Xfail()
X{
X	echo SHUZBUTT 1>&2
X	exit 1
X}
Xpass()
X{
X	exit 0
X}
Xtrap "fail" 1 2 3 15
X
X./foo
Xq=$?
X
X# check for signals
Xif test $q -ge 128 
Xthen
X	fail
Xfi
X
X# should not complain
Xif test $q -ne 0 
Xthen
X	fail
Xfi
X
X# it probably worked
Xpass
Xend
X
X#
X# let the clock tick over, so the build will be happy
X#
Xsleep 1
X
X#
X# build the change
X#
X$here/bin/aegis -build -nl -lib $worklib -p foo > /dev/null 2>&1
Xif test $? -ne 0 ; then fail; fi
X
X#
X# difference the change
X#
X$here/bin/aegis -diff -nl -lib $worklib -p foo > /dev/null 2>&1
Xif test $? -ne 0 ; then fail; fi
X
X#
X# test the change
X#
X$here/bin/aegis -test -nl -lib $worklib -p foo > /dev/null 2>&1
Xif test $? -ne 0 ; then fail; fi
X
X#
X# finish development of the change
X#
X$here/bin/aegis -dev_end -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add a new reviewer
X#
X$here/bin/aegis -newrev $USER -p foo -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# pass the review
X#
X$here/bin/aegis -review_pass -chan 1 -proj foo -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add an integrator
X#
X$here/bin/aegis -newint $USER -p foo -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# start integrating
X#
X$here/bin/aegis -intbeg 1 -p foo -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# integrate build
X#
Xsleep 1
X$here/bin/aegis -build -nl -lib $worklib -p foo > /dev/null 2>&1
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -test -nl -lib $worklib -p foo > /dev/null 2>&1
Xif test $? -ne 0 ; then fail; fi
X
X#
X# pass the integration
X#
X$here/bin/aegis -intpass -nl -lib $worklib -p foo > /dev/null 2>&1
Xif test $? -ne 0 ; then fail; fi
X
X#
X# see if the symbolic link in the work area has been removed
X# or wether it is still there
X#
X./symlink $symlinktestfile
Xif test $? -ne 0 ; then fail; fi
X
X# should be no automatic logging
Xif test "`find $work -name 'aegis.log' -print`" != "" ; then fail; fi
X
X#
X# the things tested in this test, worked
X#
Xpass
END_OF_FILE
if test 6476 -ne `wc -c <'test/00/t0007a.sh'`; then
    echo shar: \"'test/00/t0007a.sh'\" unpacked with wrong size!
fi
# end of 'test/00/t0007a.sh'
fi
if test -f 'test/00/t0016a.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test/00/t0016a.sh'\"
else
echo shar: Extracting \"'test/00/t0016a.sh'\" \(7083 characters\)
sed "s/^X//" >'test/00/t0016a.sh' <<'END_OF_FILE'
X#! /bin/sh
X#
X#	aegis - project change supervisor
X#	Copyright (C) 1993 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: Test the aemv functionality
X#
X
Xunset AEGIS_PROJECT
Xunset AEGIS_CHANGE
Xumask 022
X
XUSER=${USER:-${LOGNAME:-`whoami`}}
X
Xwork=${AEGIS_TMP:-/tmp}/$$
XPAGER=cat
Xexport PAGER
X
Xhere=`pwd`
Xif test $? -ne 0 ; then exit 1; fi
Xmkdir $work
Xif test $? -ne 0 ; then exit 1; fi
X
Xfail()
X{
X	set +x
X	echo FAILED test of aemv command 1>&2
X	cd $here
X	find $work -type d -user $USER -exec chmod u+w {} \;
X	rm -rf $work
X	exit 1
X}
Xpass()
X{
X	set +x
X	echo PASSED 1>&2
X	cd $here
X	find $work -type d -user $USER -exec chmod u+w {} \;
X	rm -rf $work
X	exit 0
X}
Xtrap "fail" 1 2 3 15
X
Xcd $work
Xif test $? -ne 0 ; then fail; fi
X
X#
X# some variable to make things earier to read
X#
Xworklib=$work/lib
Xworkproj=$work/foo.proj
Xworkchan=$work/foo.chan
Xworkchan3=$work/foo.chan3
Xtmp=$work/tmp
X
X#
X# echo commands so we can tell what failed
X#
Xset -x
X
X#
X# make a new project
X#	and check files it should have made
X#
X$here/bin/aegis -newpro foo -dir $workproj -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# change project attributes
X#
Xcat > $tmp << 'end'
Xdescription = "A bogus project created to test things.";
Xdeveloper_may_review = true;
Xdeveloper_may_integrate = true;
Xreviewer_may_integrate = true;
Xdefault_test_exemption = true;
Xend
X$here/bin/aegis -proatt $tmp -proj foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# create a new change
X#	make sure it creates the files it should
X#
Xcat > $tmp << 'end'
Xbrief_description = "This change is used to test the aegis functionality \
Xwith respect to change descriptions.";
Xcause = internal_bug;
Xend
X$here/bin/aegis -new_change $tmp -project foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# create a second change
X#	make sure it creates the files it should
X#
Xcat > $tmp << 'end'
Xbrief_description = "This change was added to make the various listings \
Xmuch more interesting.";
Xcause = internal_bug;
Xend
X$here/bin/aegis -new_change $tmp -project foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add a new developer
X#
X$here/bin/aegis -newdev $USER -p foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# begin development of a change
X#	check it made the files it should
X#
X$here/bin/aegis -devbeg 1 -p foo -dir $workchan -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add a new files to the change
X#
X$here/bin/aegis -new_file $workchan/main.c -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -new_file $workchan/old -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -new_file $workchan/config -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
Xcat > $workchan/main.c << 'end'
Xvoid
Xmain()
X{
X	exit(0);
X}
Xend
Xcat > $workchan/config << 'end'
Xbuild_command = "rm -f foo; cc -o foo -D'VERSION=\"$version\"' main.c";
Xlink_integration_directory = true;
X
Xhistory_get_command =
X	"co -u'$e' -p $h,v > $o";
Xhistory_create_command =
X	"ci -u -m/dev/null -t/dev/null $i $h,v; rcs -U $h,v";
Xhistory_put_command =
X	"ci -u -m/dev/null -t/dev/null $i $h,v; rcs -U $h,v";
Xhistory_query_command =
X	"rlog -r $h,v | awk '/^head:/ {print $$2}'";
X
Xdiff_command = "set +e; diff $orig $i > $out; test $$? -le 1";
X
Xdiff3_command = "(diff3 -e $mr $orig $i | sed -e '/^w$$/d' -e '/^q$$/d'; \
X	echo '1,$$p' ) | ed - $mr > $out";
Xend
X
X#
X# create a new test
X#
X$here/bin/aegis -nt -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
Xcat > $workchan/test/00/t0001a.sh << 'end'
X#!/bin/sh
X
Xfail()
X{
X	echo SHUZBUTT 1>&2
X	exit 1
X}
Xpass()
X{
X	exit 0
X}
Xtrap "fail" 1 2 3 15
X
X./foo
Xif test $? -ne 0; then fail; fi
X
X# it probably worked
Xpass
Xend
X
X#
X# let the clock tick over, so the build will be happy
X#
Xsleep 1
X
X#
X# build the change
X#
X$here/bin/aegis -build -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# difference the change
X#
X$here/bin/aegis -diff -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# test the change
X#
X$here/bin/aegis -test -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# finish development of the change
X#
X$here/bin/aegis -dev_end -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add a new reviewer
X#
X$here/bin/aegis -newrev $USER -p foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# pass the review
X#
X$here/bin/aegis -review_pass -chan 1 -proj foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add an integrator
X#
X$here/bin/aegis -newint $USER -p foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# start integrating
X#
X$here/bin/aegis -intbeg 1 -p foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# integrate build
X#
Xsleep 1
X$here/bin/aegis -build -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -test -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# pass the integration
X#
X$here/bin/aegis -intpass -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# start work on change 2
X#
X$here/bin/aegis -devbeg 2 -p foo -v -dir $workchan -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# move a file in change 2
X#
X$here/bin/aegis -mv $workchan/old $workchan/new -nl -v -lib $worklib -c 2 -p foo
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -cp $workchan/main.c -nl -v -lib $worklib -c 2 -p foo
Xif test $? -ne 0 ; then fail; fi
X
X$here/bin/aegis -l cf -v -lib $worklib -p foo -c 2
X
X#
X# tick over clock to keep build happy
X#
Xsleep 1
X
X#
X# build the change
X# diff the change
X#
X$here/bin/aegis -b -nl -v -lib $worklib -c 2 -p foo
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -diff -nl -v -lib $worklib -c 2 -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# end development
X# review pass
X# start integrating
X#
X$here/bin/aegis -devend -v -lib $worklib -c 2 -p foo
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -revpass -v -c 2 -p foo -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X$here/bin/aegis -intbeg -v -c 2 -p foo -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# build the integration
X#
Xsleep 1
X$here/bin/aegis -b -nl -v -lib $worklib -c 2 -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# pass the integration
X#	make sure it create the files, etc
X#
X$here/bin/aegis -intpass -nl -lib $worklib -c 2 -p foo
Xif test $? -ne 0 ; then fail; fi
X
X$here/bin/aegis -l pf -v -lib $worklib -p foo
X
X#
X# Only definite negatives are possible.
X# The functionality exercised by this test appears to work,
X# no other guarantees are made.
X#
Xpass
END_OF_FILE
if test 7083 -ne `wc -c <'test/00/t0016a.sh'`; then
    echo shar: \"'test/00/t0016a.sh'\" unpacked with wrong size!
fi
# end of 'test/00/t0016a.sh'
fi
if test -f 'test/00/t0018a.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test/00/t0018a.sh'\"
else
echo shar: Extracting \"'test/00/t0018a.sh'\" \(7444 characters\)
sed "s/^X//" >'test/00/t0018a.sh' <<'END_OF_FILE'
X#! /bin/sh
X#
X#	aegis - project change supervisor
X#	Copyright (C) 1993 Peter Miller.
X#	All rights reserved.
X#
X#	This program is free software; you can redistribute it and/or modify
X#	it under the terms of the GNU General Public License as published by
X#	the Free Software Foundation; either version 2 of the License, or
X#	(at your option) any later version.
X#
X#	This program is distributed in the hope that it will be useful,
X#	but WITHOUT ANY WARRANTY; without even the implied warranty of
X#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X#	GNU General Public License for more details.
X#
X#	You should have received a copy of the GNU General Public License
X#	along with this program; if not, write to the Free Software
X#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X#
X# MANIFEST: Test the 'aegis -NewFile -Build' command.
X#
X
Xunset AEGIS_PROJECT
Xunset AEGIS_CHANGE
Xumask 022
X
XUSER=${USER:-${LOGNAME:-`whoami`}}
X
Xwork=${AEGIS_TMP:-/tmp}/$$
X
Xfail()
X{
X	set +x
X	echo "FAILED test of 'aegis -NewFile -Build' command" 1>&2
X	find $work -type d -user $USER -exec chmod u+w {} \;
X	rm -rf $work
X	exit 1
X}
Xpass()
X{
X	set +x
X	echo PASSED 1>&2
X	find $work -type d -user $USER -exec chmod u+w {} \;
X	rm -rf $work
X	exit 0
X}
Xtrap "fail" 1 2 3 15
X
X#
X# some variable to make things earier to read
X#
XPAGER=cat
Xexport PAGER
Xworklib=$work/lib
Xworkproj=$work/foo.proj
Xworkchan=$work/foo.chan
Xtmp=$work/tmp
X
X#
X# echo commands so we can tell what failed
X#
Xset -x
X
X#
X# make the directories
X#
Xmkdir $work
X
X#
X# make a new project
X#
X./bin/aegis -newpro foo -dir $workproj -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# change project attributes
X#
Xcat > $tmp << 'end'
Xdescription = "A bogus project created to test things.";
Xdeveloper_may_review = true;
Xdeveloper_may_integrate = true;
Xreviewer_may_integrate = true;
Xend
X./bin/aegis -proatt $tmp -proj foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# create a new change
X#	make sure it creates the files it should
X#
Xcat > $tmp << 'end'
Xbrief_description = "This change is used to test the aegis functionality \
Xwith respect to change descriptions.";
Xcause = internal_bug;
Xend
X./bin/aegis -new_change $tmp -project foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add a new developer
X#
X./bin/aegis -newdev $USER -p foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# begin development of a change
X#
X./bin/aegis -devbeg 1 -p foo -dir $workchan -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add a new files to the change
X#
X./bin/aegis -new_file $workchan/main.c -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X./bin/aegis -new_file $workchan/fubar -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X./bin/aegis -new_file $workchan/version -b -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X./bin/aegis -new_file $workchan/config -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# put something in 'main.c'
X#
Xcat > $workchan/main.c << 'end'
Xvoid
Xmain()
X{
X	exit(0);
X}
Xend
X
X#
X# put something in 'config'
X#
Xcat > $workchan/config << 'end'
Xbuild_command = "rm -f foo version; cc -o foo main.c; echo '$v' > version";
Xlink_integration_directory = true;
X
Xhistory_get_command =
X	"co -u'$e' -p $h,v > $o";
Xhistory_create_command =
X	"ci -u -m/dev/null -t/dev/null $i $h,v; rcs -U $h,v";
Xhistory_put_command =
X	"ci -u -m/dev/null -t/dev/null $i $h,v; rcs -U $h,v";
Xhistory_query_command =
X	"rlog -r $h,v | awk '/^head:/ {print $$2}'";
X
Xdiff_command = "set +e; diff $orig $i > $out; test $$? -le 1";
X
Xdiff3_command = "(diff3 -e $mr $orig $i | sed -e '/^w$$/d' -e '/^q$$/d'; \
X	echo '1,$$p' ) | ed - $mr > $out";
Xend
X
X#
X# create a new test
X#
X./bin/aegis -nt -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# put something in 'test/00/t0001a.sh'
X#
Xcat > $workchan/test/00/t0001a.sh << 'end'
X#!/bin/sh
X#
X# Project: "foo"
X# Change: 1
X#
X
Xfail()
X{
X	echo SHUZBUTT 1>&2
X	exit 1
X}
Xpass()
X{
X	exit 0
X}
Xtrap "fail" 1 2 3 15
X
X./foo
Xq=$?
X
X# check for signals
Xif test $q -ge 128 
Xthen
X	fail
Xfi
X
X# should not complain
Xif test $q -ne 0 
Xthen
X	fail
Xfi
X
X# it probably worked
Xpass
Xend
X
X#
X# let the clock tick over, so the build will be happy
X#
Xsleep 1
X
X#
X# build the change
X#
X./bin/aegis -build -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# difference the change
X#
X./bin/aegis -diff -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# test the change
X#
X./bin/aegis -test -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# finish development of the change
X#
X./bin/aegis -dev_end -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add a new reviewer
X#
X./bin/aegis -newrev $USER -p foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# pass the review
X#
X./bin/aegis -review_pass -chan 1 -proj foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add an integrator
X#
X./bin/aegis -newint $USER -p foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# start integrating
X#
X./bin/aegis -intbeg 1 -p foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# integrate build
X#
Xsleep 1
X./bin/aegis -build -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# integrate test
X#
X./bin/aegis -test -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# integration pass
X#
X./bin/aegis -intpass -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# create a new change
X#	make sure it creates the files it should
X#
Xcat > $tmp << 'end'
Xbrief_description = "A seconf Change";
Xcause = internal_bug;
Xend
X./bin/aegis -new_change $tmp -project foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# begin development of a change
X#
X./bin/aegis -devbeg 2 -p foo -dir $workchan -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# set change attributes
X#
Xcat > $workchan/xx  << 'fubar'
Xtest_exempt = true;
Xtest_baseline_exempt = true;
Xfubar
Xif test $? -ne 0 ; then fail; fi
X./bin/aegis -ca $workchan/xx -p foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# add a new files to the change
X#
X./bin/aegis -cp $workchan/main.c -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# make it re-compile
X#
Xcat >> $workchan/main.c << 'end'
X/* almost nothing */
Xend
X
X#
X# let the clock tick over, so the build will be happy
X#
Xsleep 1
X
X#
X# build the change
X#
X./bin/aegis -build -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# difference the change
X#
X./bin/aegis -diff -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# finish development of the change
X#
X./bin/aegis -dev_end -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# pass the review
X#
X./bin/aegis -review_pass -chan 2 -proj foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# start integrating
X#
X./bin/aegis -intbeg 2 -p foo -v -lib $worklib
Xif test $? -ne 0 ; then fail; fi
X
X#
X# integrate build
X#
Xsleep 1
X./bin/aegis -build -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# integration pass
X#
X./bin/aegis -intpass -nl -v -lib $worklib -p foo
Xif test $? -ne 0 ; then fail; fi
X
X#
X# the build file should now be a change file
X#	even though user did not put it there
X#
X./bin/aegis -l cf -c 2 -unf -lib $worklib -p foo > $work/test.out
Xif test $? -ne 0 ; then fail; fi
Xcat > $work/test.ok << 'fubar'
Xsource modify 1.2 main.c
Xbuild modify 1.2 version
Xfubar
Xif test $? -ne 0 ; then fail; fi
Xdiff $work/test.ok $work/test.out
Xif test $? -ne 0 ; then fail; fi
X
X#
X# the things tested in this test, worked
X#
Xpass
END_OF_FILE
if test 7444 -ne `wc -c <'test/00/t0018a.sh'`; then
    echo shar: \"'test/00/t0018a.sh'\" unpacked with wrong size!
fi
# end of 'test/00/t0018a.sh'
fi
echo shar: End of archive 5 \(of 19\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 19 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
