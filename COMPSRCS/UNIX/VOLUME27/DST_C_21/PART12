Newsgroups: comp.sources.unix
From: pleierc@informatik.tu-muenchen.de (Christoph Pleier)
Subject: v27i186: distributed-c-2.1 - Distributed C Development Environment, V2.1, Part12/18
References: <1.756634932.28500@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: pleierc@informatik.tu-muenchen.de (Christoph Pleier)
Posting-Number: Volume 27, Issue 186
Archive-Name: distributed-c-2.1/part12

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 12 (of 18)."
# Contents:  dcc/attr_general.c dcc/code_trans.c
#   examples/travel/travel.dc include/config.h lib/convert.c
# Wrapped by vixie@gw.home.vix.com on Thu Dec 23 00:12:04 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dcc/attr_general.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcc/attr_general.c'\"
else
echo shar: Extracting \"'dcc/attr_general.c'\" \(16526 characters\)
sed "s/^X//" >'dcc/attr_general.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                       a t t r _ g e n e r a l . c                       *
X *                                                                         *
X *                            Package : Compiler                           *
X *                            Version : 1.0                                *
X *                       CreationDate : 28.07.90                           *
X *                         LastUpDate : 08.11.91                           *
X *                                                                         *
X *     All routines used for administrating and handling attributes.       *
X *                                                                         *
X *                  Portions Copyright 1990 Franz Distler                  *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include "config.h"
X#include "extern.h"
X#include "functions.h"
X
X/******************************************************************************
X * create_arg_list_elem()                                                     *
X *                                                                            *
X * Allocates memory for an argument expression list element and initializes   *
X * it.                                                                        *
X *                                                                            *
X * Return values: pointer to new created attribute upon success /             *
X *                NULL during error handling                                  *
X ******************************************************************************/
XARG_LIST *
Xcreate_arg_list_elem(codestr)
Xchar *codestr;
X{
X    register ARG_LIST *ptr;
X
X    if (errflag)	/* error handling! */
X	return(NULL);
X#ifdef ATTRDEBUG
X    fputs("[attr] ***** create_arg_list_elem():\n", debugfile);
X    fprintf(debugfile, "[attr]       params: codestr = %s\n", codestr);
X#endif /* ATTRDEBUG /**/
X    ptr = (ARG_LIST *) Malloc(sizeof(ARG_LIST));
X#ifdef ATTRDEBUG
X    fprintf(debugfile, "[attr]       address of new arg list is %d\n", ptr);
X#endif /* ATTRDEBUG /**/
X    ptr->code = strsave(codestr);
X    ptr->next = (ARG_LIST *) NULL;
X    return(ptr);
X} /* create_arg_list_elem */
X
X/******************************************************************************
X * link_arguments()                                                           *
X *                                                                            *
X * Links two argument expression list elements.                               *
X *                                                                            *
X * Return values: pointer to the first of the linked elements /               *
X *                NULL during error handling                                  *
X ******************************************************************************/
XARG_LIST *
Xlink_arguments(arg1, arg2)
XARG_LIST *arg1, *arg2;
X{
X    if (errflag || !arg1 || !arg2) /* error handling! */
X	return(NULL);
X#ifdef ATTRDEBUG
X    fprintf(debugfile, "[attr] ***** link_arguments(): params: arg1 = %d, arg2 = %d\n",
X		arg1, arg2);
X#endif /* ATTRDEBUG /**/
X    arg1->next = arg2;
X    return(arg1);
X} /* link_arguments */
X
X/******************************************************************************
X * create_compound_attribute()                                                *
X *                                                                            *
X * Allocates memory for a compound statement attribute and initializes it.    *
X *                                                                            *
X * Return values: pointer to new created attribute upon success /             *
X *                dummy allocated attribute during error handling             *
X ******************************************************************************/
XCOMPATTR *
Xcreate_compound_attribute(declarations, statements)
Xchar *declarations, *statements;
X{
X    register COMPATTR *ptr;
X
X    if (errflag) /* error handling! */
X	return((COMPATTR *) Malloc(sizeof(COMPATTR)));
X#ifdef ATTRDEBUG
X    fputs("[attr] ***** create_compound_attribute():\n", debugfile);
X#endif /* ATTRDEBUG /**/
X    ptr = (COMPATTR *) Malloc(sizeof(COMPATTR));
X#ifdef ATTRDEBUG
X    fprintf(debugfile, "[attr]       address of new attribute = %d\n", ptr);
X#endif /* ATTRDEBUG /**/
X    ptr->decls = declarations;
X    ptr->stats = statements;
X    return(ptr);
X} /* create_compound_attribute */
X
X/******************************************************************************
X * add_includefile_to_list()                                                  *
X *                                                                            *
X * Adds the include filename 'name' to the include filename list.             *
X *                                                                            *
X * Return values: always OK for success                                       *
X ******************************************************************************/
Xint
Xadd_includefile_to_list(name)
Xchar *name;
X{
X    register struct include_list *ptr;
X
X#ifdef ATTRDEBUG
X    fputs("[attr] ***** add_includefile_to_list():\n", debugfile);
X    fprintf(debugfile, "[attr]       params: name = %s\n", name);
X#endif /* ATTRDEBUG /**/
X
X    /* check if include file is already in the list */
X    for(ptr = first_includename; ptr; ptr = ptr->next) 
X	if (!strcmp(name, ptr->name))
X	    return(OK);
X
X    /* allocate heap space for the new element */
X    ptr = (struct include_list *) Malloc(sizeof(struct include_list));
X
X    /* initialize new element */
X    ptr->name = strsave(name);
X    ptr->next = NULL;
X
X    /* chain new element in list */
X    if (!first_includename) {
X	first_includename = last_includename = ptr;
X    } else {
X	last_includename->next = ptr;
X	last_includename = ptr;
X    }
X
X    return(OK);
X} /* add_includefile_to_list */
X
X/******************************************************************************
X * create_accept_attribute()                                                  *
X *                                                                            *
X * Allocates memory for an accept statement attribute and initializes it.     *
X *                                                                            *
X * Return values: pointer to new created attribute upon success /             *
X *                dummy allocated attribute during error handling             *
X ******************************************************************************/
XACCEPTATTR *
Xcreate_accept_attribute(transaction, comp_attr)
XSYMBTABEL *transaction;
XCOMPATTR *comp_attr;
X{
X    register ACCEPTATTR *ptr;
X
X    if (errflag || !transaction || !comp_attr) /* error handling! */
X	return((ACCEPTATTR *) Malloc(sizeof(ACCEPTATTR)));
X#ifdef ATTRDEBUG
X    fputs("[attr] ***** create_accept_attribute():\n", debugfile);
X#endif /* ATTRDEBUG /**/
X    ptr = (ACCEPTATTR *) Malloc(sizeof(ACCEPTATTR));
X#ifdef ATTRDEBUG
X    fprintf(debugfile, "[attr]       address of new attribute = %d\n", ptr);
X#endif /* ATTRDEBUG /**/
X    ptr->transaction = transaction;
X    ptr->comp_attr   = comp_attr;
X    return(ptr);
X} /* create_accept_attribute */
X
X/******************************************************************************
X * create_select_attribute()                                                  *
X *                                                                            *
X * Allocates memory for a select statement sttribute and initializes it.      *
X *                                                                            *
X * Return values: pointer to new created attribute upon success /             *
X *                dummy allocated attribute during error handling             *
X ******************************************************************************/
XSELECTATTR *
Xcreate_select_attribute(type, accept_attr, statements)
Xint type;
XACCEPTATTR *accept_attr;
Xchar *statements;
X{
X    register SELECTATTR *ptr;
X
X    if (errflag || type == ERROR || (!accept_attr)) { /* error handling! */
X	ptr = (SELECTATTR *) Malloc(sizeof(SELECTATTR));
X	ptr->type = ERROR;
X    }
X#ifdef ATTRDEBUG
X    fputs("[attr] ***** create_select_attribute():\n", debugfile);
X#endif /* ATTRDEBUG /**/
X    ptr = (SELECTATTR *) Malloc(sizeof(SELECTATTR));
X#ifdef ATTRDEBUG
X    fprintf(debugfile, "[attr]       address of new attribute = %d\n", ptr);
X#endif /* ATTRDEBUG /**/
X    ptr->type        = type;
X    ptr->guard       = (char *) NULL;
X    ptr->accept_attr = accept_attr;
X    ptr->stats       = statements;
X    ptr->next        = (SELECTATTR *) NULL;
X    return(ptr);
X} /* create_select_attribute */
X
X/******************************************************************************
X * add_guard_to_attr()                                                        *
X *                                                                            *
X * Updates the component 'guard' of a select statement attribute.             *
X *                                                                            *
X * Return values: pointer to updated attribute upon success /                 *
X *                NULL during error handling                                  *
X ******************************************************************************/
XSELECTATTR *
Xadd_guard_to_attr(select_attr, guard)
XSELECTATTR *select_attr;
Xchar *guard;
X{
X    if (errflag || !select_attr) /* error handling! */
X	return(NULL);
X#ifdef ATTRDEBUG
X    fputs("[attr] ***** add_guard_to_attr():\n", debugfile);
X    fprintf(debugfile, "[attr] params: select_attr = %d\n", select_attr);
X    fprintf(debugfile, "[attr]         guard = %s\n", guard);
X#endif /* ATTRDEBUG /**/
X    select_attr->guard = guard;
X    return(select_attr);
X} /* add_guard_to_attr */
X
X/******************************************************************************
X * link_select_attributes()                                                   *
X *                                                                            *
X * Links two select statement attributes.                                     *
X *                                                                            *
X * Return values: pointer to the first of the linked elements                 *
X ******************************************************************************/
XSELECTATTR *
Xlink_select_attributes(attr1, attr2)
XSELECTATTR *attr1, *attr2;
X{
X    if (errflag || !attr1 || !attr2 || (attr1->type == ERROR)
X	|| (attr2->type == ERROR)) {
X	/* error handling! */
X	attr1->type = ERROR;
X	return(attr1);
X    }
X#ifdef ATTRDEBUG
X    fputs("[attr] ***** link_select_attributes():\n", debugfile);
X    fprintf(debugfile, "[attr] params: attr1 = %d\n", attr1);
X    fprintf(debugfile, "[attr]         attr2 = %d\n", attr2);
X#endif /* ATTRDEBUG /**/
X    attr1->next = attr2;
X    return(attr1);
X} /* link_select_attributes */
X
X/******************************************************************************
X * create_post_expr_attr()                                                    *
X *                                                                            *
X * Allocates memory for postfix expression attribute and initializes it.      *
X *                                                                            *
X * Return values: pointer to new created attribute upon success /             *
X *                dummy allocated attribute during error handling             *
X ******************************************************************************/
XPOSTATTR *
Xcreate_post_expr_attr(name)
Xchar *name;
X{
X    register POSTATTR *ptr;
X    SYMBTABEL *symbol;
X
X    if (errflag || (!name)) {
X        ptr = (POSTATTR *) Malloc(sizeof(POSTATTR));
X	ptr->codestr = strmalloc("");
X	return(ptr);
X    }
X#ifdef ATTRDEBUG
X    fprintf(debugfile,"[attr] ***** create_post_expr_attr():\n");
X    fprintf(debugfile,"[attr] name = %s\n", name);
X#endif /* ATTRDEBUG /**/
X    ptr = (POSTATTR *) Malloc(sizeof(POSTATTR));
X    ptr->idents = (IDENTCHAIN *) Malloc(sizeof(IDENTCHAIN));
X    ptr->codestr = (char *) strmalloc("");
X    if (!(symbol = lookup_symbtabel(name))) {
X#ifdef ATTRDEBUG
X	fprintf(debugfile, "no entry found in symbol table\n");
X#endif /* ATTRDEBUG /**/
X	strcpy(ptr->codestr, name);
X	ptr->idents->symbol = (SYMBTABEL *) NULL;
X	ptr->idents->next = (IDENTCHAIN *) NULL;
X	return(ptr);
X    }
X#ifdef ATTRDEBUG
X    fprintf(debugfile, "entry found in symbol table\n");
X#endif /* ATTRDEBUG /**/
X    strcpy(ptr->codestr, symbol->name);
X    ptr->idents->symbol = symbol;
X    ptr->idents->next = NULL;
X    return(ptr);
X} /* create_post_expr_attr */
X
X/******************************************************************************
X * update_post_expr_attr()                                                    *
X *                                                                            *
X * Updates a postfix expression attribute.                                    *
X *                                                                            *
X * Return values: pointer to the updated attribute upon success /             *
X *                NULL during error handling                                  *
X ******************************************************************************/
XIDENTCHAIN *
Xupdate_post_expr_attr(first, ident)
XIDENTCHAIN *first;
XSYMBTABEL *ident;
X{
X    register IDENTCHAIN *ptr;
X
X    if (errflag || (!first) || (!ident))
X	return(NULL);
X#ifdef ATTRDEBUG
X    fprintf(debugfile,"[attr] ***** update_post_expr_attr():\n");
X#endif /* ATTRDEBUG /**/
X    for(ptr = first; ptr->next; ptr = ptr->next)
X	;
X    ptr->next = (IDENTCHAIN *) Malloc(sizeof(IDENTCHAIN));
X    ptr->next->symbol = (SYMBTABEL *) Malloc(sizeof(SYMBTABEL));
X    ptr = ptr->next;
X    ptr->symbol = ident;
X    ptr->next = (IDENTCHAIN *) NULL;
X    return(first);
X} /* update_post_expr_attr */
X
X/******************************************************************************
X * create_trans_attr()                                                        *
X *                                                                            *
X * Allocates memory for transaction call attribute and initializes it.        *
X *                                                                            *
X * Return values: pointer to new created attribute upon success /             *
X *                dummy allocated attribute during error handling             *
X ******************************************************************************/
XTRANSATTR *
Xcreate_trans_attr(postattr, symbol, arg)
XPOSTATTR *postattr;
XSYMBTABEL *symbol;
XARG_LIST *arg;
X{
X    register TRANSATTR *ptr;
X
X    if (errflag) {
X        ptr = (TRANSATTR *) Malloc(sizeof(TRANSATTR));
X	return(ptr);
X    }
X#ifdef ATTRDEBUG
X    fprintf(debugfile,"[attr] ***** create_trans_attr():\n");
X    fprintf(debugfile,"[attr]       postattr->codestr = %s\n", postattr->codestr);
X    fprintf(debugfile,"[attr]       symbol->name = %s\n", symbol->name);
X#endif /* ATTRDEBUG /**/
X    ptr = (TRANSATTR *) Malloc(sizeof(TRANSATTR));
X    ptr->target = postattr->codestr;
X    ptr->symbol = symbol;
X    ptr->arg    = arg;
X    return(ptr);
X} /* create_trans_attr */
END_OF_FILE
if test 16526 -ne `wc -c <'dcc/attr_general.c'`; then
    echo shar: \"'dcc/attr_general.c'\" unpacked with wrong size!
fi
# end of 'dcc/attr_general.c'
fi
if test -f 'dcc/code_trans.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcc/code_trans.c'\"
else
echo shar: Extracting \"'dcc/code_trans.c'\" \(17142 characters\)
sed "s/^X//" >'dcc/code_trans.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                         c o d e _ t r a n s . c                         *
X *                                                                         *
X *                            Package : Compiler                           *
X *                            Version : 1.1                                *
X *                       CreationDate : 26.07.90                           *
X *                         LastUpDate : 08.06.91                           *
X *                                                                         *
X * The functions to generate the code and routines for transactions and    *
X * the build the code and routines to call transactions.                   *
X *                                                                         *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include "config.h"
X#include "extern.h"
X#include "functions.h"
X#include "com_Errno.h"
X#include "timeout.h"
X
X/******************************************************************************
X * gen_call_transaction_routines()                                            *
X *                                                                            *
X * Generates the call transaction routine for the transaction specified by    *
X * the symbol table element 'symbol'. The generated call transaction routine  *
X * is called at runtime to call the specified transaction, pass the arguments *
X * and get the result.                                                        *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error or during error handling *
X ******************************************************************************/
Xint
Xgen_call_transaction_routines(symbol)
XSYMBTABEL *symbol;
X{
X    char        *piname,
X                *ptiname, 
X                *uptiname,
X                 tmpstr[20];
X    SYMBTABEL   *actions,
X                *params;
X
X    if (errflag || !symbol)	/* error handling! */
X        return(ERROR);
X#ifdef CODEDEBUG
X    fputs("[code] ***** gen_call_transaction_routines():\n", debugfile);
X    fprintf(debugfile, "[code]       params: symbol = %d\n", symbol);
X#endif  /* CODEDEBUG /**/
X    for(actions=symbol->info.process.FirstTrans; actions; actions=actions->info.trans.NextTrans) {
X	ptiname  = actions->info.trans.ptiname;
X	uptiname = actions->info.trans.uptiname;
X        if (infoflag) {
X	    printf("%s generating calling routine for transaction '%s' of process '%s'\n", 
X		infoprefix, actions->name, symbol->name);
X	    fflush(stdout);
X        }
X	/* transaction code */
X	sprintf(tmpstr, " %d\n", ++transnum);
X	fprintf(creatfile,"\n/* specific routine to call transaction '%s' */\n",
X	    actions->name);
X	*convert_buffer = 0;
X	convert_buffer = convert_ds_to_string(convert_buffer, actions->info.trans.ReturnType);
X	fprintf(creatfile, "%s\ncall_%s(p_descr", convert_buffer, ptiname);
X	for(params=actions->info.trans.FirstParam; params; params=params->info.varorpar.NextParam) {
X	    fprintf(creatfile, ", %s", params->name);
X	}
X	fputs(", mode)\n", creatfile);
X	fputs("PROCESSDESCR p_descr;\n", creatfile);
X	for(params=actions->info.trans.FirstParam; params; params=params->info.varorpar.NextParam) {
X	    *convert_buffer = 0;
X	    convert_buffer = convert_ds_to_string(convert_buffer, params->info.varorpar.DataType);
X	    fprintf(creatfile, "%s %s;\n", convert_buffer, params->name);
X	}
X	fputs("int mode;\n", creatfile);
X	fputs("{\n", creatfile);
X	fputs("\tif (mode == CALL) {\n", creatfile);
X	fputs("\t\t/* call process and request transaction */\n", creatfile);
X	fprintf(creatfile, "\t\tif (_make_transaction_call(p_descr.port, \"%s\", 0))\n",
X	    uptiname);
X	fprintf(creatfile, "\t\t\t_RuntimeError(\"requesting transaction (%s@%s)\");\n",
X	    symbol->name, actions->name);
X	fputs("\t}\n", creatfile);
X	if (actions->info.trans.FirstParam) {
X	    fputs("\t/* o.k. transaction permitted, now send arguments */\n", 
X	        creatfile);
X            for(params=actions->info.trans.FirstParam; params; params=params->info.varorpar.NextParam)
X	        fprintf(creatfile,"\tdcc_par.%s.%s = %s;\n", ptiname, params->name,
X		    params->name);
X            fprintf(creatfile, "\tif (_send_data");
X#ifdef HETEROGENEOUS
X            fprintf(creatfile, "_encoded");
X#endif
X            fprintf(creatfile, "(&_con_port, (char *) &dcc_par.%s, ", ptiname);
X#if defined(SINGLE) || defined(HOMOGENEOUS)
X            fprintf(creatfile, "sizeof(%s%s)", uptiname, POSTFIXTRANSPAR);
X#else /* HETEROGENEOUS */
X            fprintf(creatfile, "xdr_%s%s", uptiname, POSTFIXTRANSPAR);
X#endif
X            fprintf(creatfile, ", %d) < 0) {\n", TRANSARGTIME);
X            fputs("\t\tif (Errno == ETIMEOUT)\n", creatfile);
X            fputs("\t\t\tErrno = ETTSENDARGS;\n", creatfile);
X            fprintf(creatfile, "\t\t_RuntimeError(\"sending arguments (%s@%s)\");\n",
X		symbol->name, actions->name);
X	    fputs("\t}\n", creatfile);
X	}
X#ifdef HETEROGENEOUS
X	/* We must clear the memory where the received data will be stored in,
X	 * because the xdr routines allocate storage for pointers only if
X	 * the pointer values equal the NULL pointer!!!
X	 */
X	fputs("\t/* clear structure to handle pointers correctly */\n", creatfile);
X	fprintf(creatfile, "\tbzero(&dcc_res.%s, sizeof(%s%s));\n", 
X	    ptiname, uptiname, POSTFIXTRANSRES);
X#endif
X        fprintf(creatfile, "\tif (_recv_data");
X#ifdef HETEROGENEOUS
X        fprintf(creatfile, "_encoded");
X#endif
X        fprintf(creatfile, "(&_con_port, (char *) &dcc_res.%s, ", ptiname);
X#if defined(SINGLE) || defined(HOMOGENEOUS)
X        fprintf(creatfile, "sizeof(%s%s)", uptiname, POSTFIXTRANSRES);
X#else /* HETEROGENEOUS */
X        fprintf(creatfile, "xdr_%s%s", uptiname, POSTFIXTRANSRES);
X#endif
X        fprintf(creatfile, ", %d) < 0) {\n", TRANSRESTIME);
X        fputs("\t\tif (Errno != ETIMEOUT)\n", creatfile);
X        fprintf(creatfile, "\t\t\t_RuntimeError(\"receiving transaction result (%s@%s)\");\n",
X	    symbol->name, actions->name);
X	fputs("\t}\n", creatfile);
X	fputs("\tif (_close_connection(&_con_port))\n", creatfile);
X        fprintf(creatfile, "\t\t_RuntimeError(\"during %s@%s\");\n",
X	    symbol->name, actions->name);
X	fputs("\t/* check for error */\n", creatfile);
X	fprintf(creatfile, "\tif (dcc_res.%s.Errno != OK) {\n", ptiname);
X	fprintf(creatfile, "\t\terrno = dcc_res.%s.errno;\n", ptiname);
X        fprintf(creatfile, "\t\t_RuntimeError(\"transaction error (%s@%s)\");\n\t}\n",
X	    symbol->name, actions->name);
X	fputs("\t/* return result */\n", creatfile);
X        fprintf(creatfile, "\treturn(dcc_res.%s.result);\n", ptiname);
X        fprintf(creatfile, "} /* call_%s */\n", ptiname);
X    } /* for */
X    return(OK);
X} /* gen_call_transaction_routines */
X
X/******************************************************************************
X * generate_call_transaction_code()                                           *
X *                                                                            *
X * Generates the code to call a particular transaction.                       *
X *                                                                            *
X * Return values: pointer to generated code string upon success /             *
X *                NULL upon error or during error handling                    *
X ******************************************************************************/
Xchar *
Xgenerate_call_transaction_code(duration, target, symbol, arg, expr)
Xchar      *duration,	/* time limit */
X          *target,	/* called process */
X          *expr;	/* expression to execute if timeout */
XSYMBTABEL *symbol;	/* pointer to transaction declaration */
XARG_LIST  *arg;		/* arguments */
X{
X    int        i;
X    char      *cmd;
X    ARG_LIST  *hptr;
X    SYMBTABEL *params;
X
X    if (errflag || !symbol) /* error handling! */
X        return(NULL);
X#ifdef CODEDEBUG
X    fputs("[code] ***** generate_call_transaction_code():\n", debugfile);
X    fprintf(debugfile, "[code] params: duration = %s\n", duration);
X    fprintf(debugfile, "[code]         target   = %s\n", target);
X    fprintf(debugfile, "[code]         expr     = %s\n", expr);
X    fprintf(debugfile, "[code]         symbol = %d, arg = %d\n", symbol, arg);
X    if (arg)
X        fputs("[code]    the arguments are:\n", debugfile);
X    for(hptr = arg, i = 1; hptr; hptr = hptr->next, ++i) 
X        fprintf(debugfile, "[code]    arg %d: %s\n", i, hptr->code);
X#endif /* CODEDEBUG /**/
X    if (!duration) {
X	/* transaction call without time limit */
X    	cmd = strmalloc("call_");
X    	cmd = Strcatmany(cmd, 3, symbol->info.trans.ptiname, "(", target);
X    	for(params=symbol->info.trans.FirstParam, hptr=arg; params;
X    	        params=params->info.varorpar.NextParam, hptr=hptr->next) {
X	    if (!hptr) {
X	        strcpy(yytext, "");
X	        Errno = WTRANSARGS;
X	        Warning("");
X	        break;
X	    }
X	    cmd = Strcatmany(cmd, 2, ", ", hptr->code);
X    	}
X        cmd = Strcat(cmd, ", CALL)");
X    } else {
X	/* transaction call with time limit */
X	cmd = strmalloc("(!_make_transaction_call((");
X	cmd = Strcatmany(cmd, 9, target, ").port, \"",
X	    symbol->info.trans.uptiname, "\", ", duration, ")) ? (call_",
X	    symbol->info.trans.ptiname, "(", target);
X    	for(params=symbol->info.trans.FirstParam, hptr=arg; params;
X    	        params=params->info.varorpar.NextParam, hptr=hptr->next) {
X	    if (!hptr) {
X	        strcpy(yytext, "");
X	        Errno = WTRANSARGS;
X	        Warning("");
X	        break;
X	    }
X	    cmd = Strcatmany(cmd, 2, ", ", hptr->code);
X    	}
X        cmd = Strcatmany(cmd, 2, ", DONTCALL)) : ", expr);
X	Free(duration);
X        Free(expr);
X    }
X    Free(target);
X    return(cmd);
X} /* generate_call_transaction_code */
X
X/******************************************************************************
X * generate_transaction_code()                                                *
X *                                                                            *
X * Generates the code for accepting a particular transaction.                 *
X *                                                                            *
X * Return values: pointer to generated code string upon success /             *
X *                NULL upon error or during error handling                    *
X ******************************************************************************/
Xchar *
Xgenerate_transaction_code(attr)
XACCEPTATTR *attr;
X{
X    char      *cs, 
X               tmpstr[20],
X	      *processname,
X              *ptiname,
X              *uptiname; 
X    SYMBTABEL *symbol,
X              *params;
X    COMPATTR  *comp_attr;
X
X    if (errflag || !attr) /* error handling! */
X	return(NULL);
X#ifdef CODEDEBUG
X    fputs("[code] ***** generate_transaction_code():\n", debugfile);
X#endif /* CODEDEBUG /**/
X    processname = attr->transaction->info.trans.Process->name;
X    ptiname     = attr->transaction->info.trans.ptiname;
X    uptiname    = attr->transaction->info.trans.uptiname;
X    symbol      = attr->transaction;
X    comp_attr   = attr->comp_attr;
X
X    cs = strmalloc("\n/* accept transaction ");
X    cs = Strcatmany(cs, 2, attr->transaction->name, " */\n{\n");
X
X    if (symbol->info.trans.FirstParam) {
X        for(params=symbol->info.trans.FirstParam; params; params=params->info.varorpar.NextParam) {
X	    cs = convert_ds_to_string(cs, params->info.varorpar.DataType); 
X	    cs = Strcatmany(cs, 2, params->name, ";\n");
X	}
X    }
X    cs = convert_ds_to_string(cs, symbol->info.trans.ReturnType);
X    cs = Strcat(cs, "_transaction_result;\n\n");
X
X    cs = Strcat(cs, "if (_get_transaction_call(\"");
X    cs = Strcatmany(cs, 2, uptiname, "\"))\n");
X    cs = Strcatmany(cs, 3, "_RuntimeError(\"", processname, ": accepting transaction\");\n");
X
X    if (symbol->info.trans.FirstParam) {
X#ifdef HETEROGENEOUS
X	/* We must clear the memory where the received data will be 
X	 * stored in, because the xdr routines allocate storage for 
X	 * pointers only if the pointer values equal the NULL pointer!!
X	 */
X	cs = Strcat(cs, "/* clear structure to handle pointers correctly */\n");
X	cs = Strcatmany(cs, 6, "bzero(&dcc_par.", ptiname, ", sizeof(",
X	    uptiname, POSTFIXTRANSPAR, "));\n");
X#endif
X	cs = Strcat(cs, "/* transaction was called, now get parameters */\n");
X	sprintf(tmpstr, "%d", ACCEPTPARTIME);
X	cs = Strcat(cs, "if (_recv_data");
X#ifdef HETEROGENEOUS
X	cs = Strcat(cs, "_encoded");
X#endif
X	cs = Strcatmany(cs, 2, "(&_con_port, (char *) &dcc_par.", ptiname);
X#if defined(SINGLE) || defined(HOMOGENEOUS)
X	cs = Strcatmany(cs, 4, ", sizeof(", uptiname, POSTFIXTRANSPAR, ")");
X#else /* HETEROGENEOUS */
X	cs = Strcatmany(cs, 3, ", xdr_", uptiname, POSTFIXTRANSPAR);
X#endif
X	cs = Strcatmany(cs, 3, ",", tmpstr, ") < 0){\n");
X	cs = Strcat(cs, "if (Errno == ETIMEOUT)\nErrno = ETARCVPARAMS;\n");
X        cs = Strcatmany(cs, 5, "_RuntimeError(\"", processname, ": ", 
X	    symbol->name, "\");\n}\n");
X        cs = Strcat(cs, "/* initialize parameters */\n");
X        for(params=symbol->info.trans.FirstParam; params; params=params->info.varorpar.NextParam)
X	    cs = Strcatmany(cs, 6, params->name, " = dcc_par.", ptiname, ".", 
X		params->name, ";\n");
X    }
X
X    if (*comp_attr->decls != 0 || *comp_attr->stats != 0) {
X        cs = Strcat(cs, "/* execute transaction */\n");
X        cs = Strcatmany(cs, 5, "{\n", comp_attr->decls, "\n", comp_attr->stats, "\n}\n"); 
X        sprintf(tmpstr, "tlabel_%d:\n", symbol->info.trans.labnum);
X        cs = Strcat(cs, tmpstr);
X    }
X
X    cs = Strcat(cs, "/* send result back to caller */\n");
X    cs = Strcatmany(cs, 3, "dcc_res.", ptiname, ".result = _transaction_result;\n");
X    cs = Strcatmany(cs, 3, "dcc_res.", ptiname, ".Errno = OK;\n");
X    sprintf(tmpstr, "%d", ACCEPTRESTIME);
X    cs = Strcat(cs, "if (_send_data");
X#ifdef HETEROGENEOUS
X    cs = Strcat(cs, "_encoded");
X#endif
X    cs = Strcatmany(cs, 2, "(&_con_port, (char *) &dcc_res.", ptiname);
X#if defined(SINGLE) || defined(HOMOGENEOUS)
X    cs = Strcatmany(cs, 4, ", sizeof(", uptiname, POSTFIXTRANSRES, ")");
X#else /* HETEROGENEOUS */
X    cs = Strcatmany(cs, 3, ", xdr_", uptiname, POSTFIXTRANSRES);
X#endif
X    cs = Strcatmany(cs, 3, ",", tmpstr, ") < 0){\n");
X    cs = Strcat(cs, "if (Errno == ETIMEOUT)\nErrno = ETASNDRESULT;\n");
X    cs = Strcatmany(cs, 5, "_RuntimeError(\"", processname, ": ", symbol->name,
X	"\");\n}\n");
X
X    cs = Strcat(cs, "if (_close_connection(&_con_port))\n");
X    cs = Strcatmany(cs, 3, "_RuntimeError(\"", processname, "\");\n");
X    cs = Strcatmany(cs, 3, "} /* accept transaction ", attr->transaction->name, " */\n");
X    return(cs);
X} /* generate_transaction_code */
X
X/******************************************************************************
X * generate_treturn_code()                                                    *
X *                                                                            *
X * Generates the code for the statement 'treturn'.                            *
X *                                                                            *
X * Return values: pointer to generated code string upon success /             *
X *                NULL upon error or during error handling                    *
X ******************************************************************************/
Xchar *
Xgenerate_treturn_code(expression)
Xchar *expression;
X{
X    char *cs, tmpstr[20];
X
X    if (errflag) /* error handling! */
X	return(NULL);
X#ifdef CODEDEBUG
X    fputs("[code] ***** generate_treturn_code():\n", debugfile);
X#endif /* CODEDEBUG /**/
X    cs = strmalloc("{ ");
X    if (expression)
X	cs = Strcatmany(cs, 3, "_transaction_result = ", expression, "; "); 
X    sprintf(tmpstr, "tlabel_%d", translabel);
X    cs = Strcatmany(cs, 3, "goto ", tmpstr, "; }\n");
X    return(cs);
X} /* generate_treturn_code */
END_OF_FILE
if test 17142 -ne `wc -c <'dcc/code_trans.c'`; then
    echo shar: \"'dcc/code_trans.c'\" unpacked with wrong size!
fi
# end of 'dcc/code_trans.c'
fi
if test -f 'examples/travel/travel.dc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/travel/travel.dc'\"
else
echo shar: Extracting \"'examples/travel/travel.dc'\" \(16790 characters\)
sed "s/^X//" >'examples/travel/travel.dc' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                          t r a v e l . d c                              *
X *                                                                         *
X *                 Version 1.0      CreationDate: 29.07.91                 *
X *                                    LastUpDate: 29.07.91                 *
X *                                                                         *
X *                     The traveling salesman problem.                     *
X *                 A solution implemented in Distributed C.                *
X *                                                                         *
X *                Copyright (C) 1991 by Christoph Pleier.                  *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X#include <stdio.h>
X#undef stdin
X#undef stdout
X#undef stderr
X#include <stdlib.h>
X#include "config.h"
X
X#define DEBUG /**/
X
X/****************************************************************************
X *         name : print_route                                               *
X *         type : function definition                                       *
X *   returntype : void                                                      *
X *   parameters : WAYINFO way                                               *
X *  description : Prints the names of the cities stored as way in 'way'.    *
X ****************************************************************************/
Xvoid print_route(comment, way)
Xchar *comment;
XWAYINFO way;
X{
X    register int i;
X    static char str[2000];
X    extern char *unity;
X    extern NAMEINFO data_cities[CITYNUM];
X
X    str[0] = '\0';
X    for(i = 0; i < way.num; ) {
X	strcat(str, data_cities[way.way[i]].name); 
X	if (++i < way.num)
X	    strcat(str, " -> ");
X    }
X    printf("%s %s%s, length = %d %s\n", _processprefix, comment, str, 
X	way.length, unity);
X} /* print_route */
X 
X/****************************************************************************
X *         name : relate_name                                               *
X *         type : function definition                                       *
X *   returntype : int                                                       *
X *   parameters : char *name                                                *
X *  description : Relates a real name to an intern name and returns the     *
X *                result or -1 if the name was not found in the data_table. *
X ****************************************************************************/
Xint relate_name(name)
Xchar *name;
X{
X    register int i;
X    extern NAMEINFO data_cities[CITYNUM];
X
X    for (i = 0; i < CITYNUM; i++)
X	if (!strcmp(name, data_cities[i].name))
X	    return(data_cities[i].num);
X    return(-1);
X} /* relate_name */
X
X/****************************************************************************
X *         name : find_route                                                *
X *         type : function definition                                       *
X *   returntype : WAYINFO                                                   *
X *   parameters : WAYINFO hitherto_way, CITYLIST choosen_cities             *
X *  description : Finds a shortest possible way and returns it as result.   *
X ****************************************************************************/
XWAYINFO find_route(hitherto_way, choosen_cities)
XWAYINFO hitherto_way;	/* the already worked out route */
XCITYLIST *choosen_cities;
X{
X    int     act_city, 		/* act_city for visited cities array */
X            i,			/* loop counter */
X            j,			/* loop counter */ 
X            already_visited;	/* city was already visited */
X    WAYINFO res_way,		/* the resulting way */
X            new_way,		/* the new way to test */
X            best_way;		/* the best way found */
X    extern int d_tab[CITYNUM][CITYNUM];
X
X    if (hitherto_way.num >= choosen_cities->citynum) {
X	/* All choosen cities visited. Add starting city to route and return
X	 * the result!
X	 */
X	res_way = hitherto_way;
X	res_way.way[res_way.num] = res_way.way[0];
X	res_way.length += distance(res_way.way[res_way.num-1], res_way.way[0]);
X	++res_way.num;
X	return(res_way);
X    } else {
X	/* Determine the shortest possible route by testing all possible
X	 * ways through the remainding cities.
X	 */
X	best_way.num = 0;
X	for(act_city = 0; act_city < choosen_cities->citynum; act_city++) {
X	    i = choosen_cities->cities[act_city];
X
X	    /* If the actual city has already been visited, continue with 
X	     * the next city stored in the array 'cities'.
X	     */
X	    already_visited = 0;
X	    for(j = 0; j < hitherto_way.num; j++)
X		if (hitherto_way.way[j] == i) {
X			already_visited = 1;
X			break;
X		}
X	    if (already_visited)
X		continue;
X
X	    /* Determine route with regard to the actual city.
X	     */
X	    new_way = hitherto_way;
X	    new_way.way[new_way.num] = i;
X	    new_way.length += distance(new_way.way[new_way.num-1], i);
X	    ++new_way.num;
X	    res_way = find_route(new_way, choosen_cities);
X
X	    /* If the found route is shorter than the stored route, store
X	     * this route as best path.
X	     */
X	    if (best_way.num == 0)
X		best_way = res_way;
X	    else
X		if (best_way.length > res_way.length)
X			best_way = res_way;
X	} /* for(act_city) */
X	return(best_way);
X    }
X} /* find_route */
X
X/****************************************************************************
X *         name : choose_cities                                             *
X *         type : function definition                                       *
X *   returntype : none                                                      *
X *   parameters : none                                                      *
X *  description : Function to enter a list of availible cities.             *
X ****************************************************************************/
Xvoid choose_cities(choosen_cities)
XCITYLIST *choosen_cities;
X{
X    register int j;
X    int          i = 0, 
X                 intern_name,
X                 flag;
X    char         input[100];
X    extern NAMEINFO data_cities[CITYNUM];
X
X    puts("\nEnter city names and press return after each name!");
X    puts("Type 'list' to list availible cities!");
X    puts("Type 'done' to finish input!");
X    do {
X        printf("%d. city? ", i + 1);
X        scanf("%s", input);
X
X        if (!strcmp(input, "done"))
X	    break;
X
X	if (!strcmp(input, "list")) {
X            for(j = 0; j < CITYNUM; j++)
X                printf("%s, ", data_cities[j].name);
X            puts("\b\b.   ");
X	    continue;
X	}
X
X        if ((intern_name = relate_name(input)) == -1) {
X	    puts("This city is not availible in the table! Try another one.");
X	    continue;
X	}
X
X	for(flag = j = 0; j < i; j++)
X	    if (intern_name == choosen_cities->cities[j]) {
X		flag = 1;
X		break;
X	    }
X	if (flag) {
X	    puts("This city is already in the route! Try another one.");
X	    continue;
X	}
X
X	choosen_cities->cities[i] = relate_name(input);
X	i++;
X    } while(i < CITYNUM);
X    choosen_cities->citynum = i;
X} /* choose_cities */
X
X/****************************************************************************
X *         name : collect_results                                           *
X *         type : process specification                                     *
X *   returntype : impossible                                                *
X *   parameters : long processnum                                           *
X *  description :                                                           *
X ****************************************************************************/
Xprocess spec collect_results(long processnum)
X{
X    trans void write_route(WAYINFO way);
X}
X
X/****************************************************************************
X *         name : collect_results                                           *
X *         type : process definition                                        *
X *   returntype : impossible                                                *
X *   parameters : long processnum                                           *
X *  description :                                                           *
X ****************************************************************************/
Xprocess body collect_results(processnum)
X{
X    int i;
X    WAYINFO best_way;
X    extern char *unity;
X    extern NAMEINFO data_cities[CITYNUM];
X    extern int d_tab[CITYNUM][CITYNUM];
X
X#ifdef DEBUG
X    printf("%s started!\n", _processprefix);
X    fflush(stdout);
X#endif /* DEBUG /**/
X    best_way.length = 0;
X    do {
X	accept write_route(way) {
X	    if (best_way.length > way.length || best_way.length == 0)
X	        best_way = way;
X	}
X	processnum--;
X    } while(processnum > 0);
X    puts("\nOne possible shortest way is: ");
X    for(i = 0; i < best_way.num; i++) {
X	printf("%s -> ", data_cities[best_way.way[i]].name); 
X    }
X    printf("\b\b\b\b.    \nThe length is %d %s.\n", best_way.length, unity); 
X    exit(0);
X} /* process collect_results */
X
X/****************************************************************************
X *         name : build_route                                               *
X *         type : process specification                                     *
X *   returntype : impossible                                                *
X *   parameters :                                                           *
X *  description :                                                           *
X ****************************************************************************/
Xprocess spec build_route(process collect_results cr_descr,
X			 WAYINFO hitherto_way,
X			 CITYLIST choosen_cities,
X			 int stage);
X
X/****************************************************************************
X *         name : build_route                                               *
X *         type : process definition                                        *
X *   returntype : impossible                                                *
X *   parameters :                                                           *
X *  description :                                                           *
X ****************************************************************************/
Xprocess body build_route(cr_descr, hitherto_way, choosen_cities, stage)
X{
X    int     act_city,              /* act_city for visited cities array */
X            i,                  /* loop counter */
X            j,                  /* loop counter */
X            already_visited;    /* city was already visited */
X    WAYINFO new_way;            /* the new way to test */
X    extern char *unity;
X    extern NAMEINFO data_cities[CITYNUM];
X    extern int d_tab[CITYNUM][CITYNUM];
X           
X#ifdef DEBUG
X    printf("%s started!\n", _processprefix);
X    print_route("hitherto route is ", hitherto_way);
X    fflush(stdout);
X#endif /* DEBUG /**/
X    if (stage == 0) {
X	/* No more processes to start. Determine the shortest route with
X	 * regard to all remainding cities and send the result to the 
X	 * process 'collect_results'.
X	 */
X	cr_descr@write_route(find_route(hitherto_way, &choosen_cities));
X    } else {
X	/* Still Processes to start. Create for each possible next city on
X	 * the route a process.
X	 */
X	 for(act_city = 0; act_city < choosen_cities.citynum; act_city++) {
X            i = choosen_cities.cities[act_city];
X
X            /* If the actual city has already been visited, continue with
X             * the next city stored in the array 'cities'.
X             */
X            already_visited = 0;
X            for(j = 0; j < hitherto_way.num; j++)
X                if (hitherto_way.way[j] == i) {
X                        already_visited = 1;
X                        break;
X                }
X            if (already_visited)
X                continue;
X
X            /* Create a new process to determine the shortest route with 
X	     * the actual city as next city on path.
X             */
X            new_way = hitherto_way;
X            new_way.way[new_way.num] = i;
X            new_way.length += distance(new_way.way[new_way.num-1], i);
X            ++new_way.num;
X            create build_route(cr_descr, new_way, choosen_cities, stage -1);
X	} /* for(act_city) */
X    }
X    exit(0);
X} /* process build_route */
X
X/****************************************************************************
X *         name : main                                                      *
X *         type : function definition                                       *
X *   returntype : int                                                       *
X *   parameters : none                                                      *
X *  description : Definition of the main function building the main program.*
X ****************************************************************************/
Xmain()
X{
X    int      i,			/* loop counter */
X             intern_name,	/* intern name of a city */
X             flag,		/* dummy flag handling error check */
X             stage,		/* stage of parallesim */
X             max_stage,		/* maximal allowed stage */
X             res;		/* dummy result variable */
X    char     input[100];	/* to store various user input */
X    CITYLIST choosen_cities;	/* the choosen cities */
X    WAYINFO  way;		/* to store the first way */
X    extern char *unity;
X    extern NAMEINFO data_cities[CITYNUM];
X
X    puts("\nThe traveling salesman problem.");
X    puts("Solution implemented by Christoph Pleier using Distributed C");
X    puts("At the chair for compiler construction of Professor Dr. J. Eickel.");
X    puts("Technische Universitaet Muenchen.\n");
X    printf("This is %s. The cities are\n", DESCRIPTION);
X    for(i = 0; i < CITYNUM; i++)
X        printf("%s, ", data_cities[i].name);
X    puts("\b\b.");
X
X    printf("\nIs this a round trip through all cities? (y/n) ");
X    scanf("%s", input);
X    if (input[0] == 'y' || input[0] == 'Y') {
X        for(i = 0; i < CITYNUM; i++)
X	    choosen_cities.cities[i] = data_cities[i].num;
X	choosen_cities.citynum = CITYNUM;
X    } else
X	choose_cities(&choosen_cities);
X
X    do {
X	flag = 0;
X        printf("\nStarting city? ");
X        scanf("%s", input);
X	intern_name = relate_name(input);
X	if (intern_name == -1)
X	    continue;
X        for(i = 0; i < choosen_cities.citynum; i++)
X	    if (choosen_cities.cities[i] == intern_name)
X		flag = 1;
X	if (flag == 0)
X	    puts("This city has not been choosen out. Try another one!");
X    } while(intern_name == -1 || flag == 0);
X
X    way.num    = 1;
X    way.way[0] = intern_name;
X    way.length = 0;
X
X    for(res = i = 1; i < choosen_cities.citynum; i++)
X	res *= i;
X    printf("\nNumber of possible routes is %d.\n", res);
X
X    printf("\nDo you want to determine the result sequential or parallel? (s/p) ");
X    scanf("%s", input);
X    if (input[0] == 's' || input[0] == 'S') {
X	way = find_route(way, &choosen_cities);
X        puts("\nOne possible shortest way is: ");
X        for(i = 0; i < way.num; i++)
X	    printf("%s -> ", data_cities[way.way[i]].name); 
X        printf("\b\b\b\b.    \nThe length is %d %s.\n", way.length, unity); 
X	exit(0);
X    }
X
X    puts("\nNumber of processes to create with regard to the state of parallism:\n");
X    puts("    ---------------------------");
X    puts("    | stage  | process number |");
X    puts("    |--------|----------------|");
X    for(res = i = 1; i < choosen_cities.citynum-1 && res < MAXPNUM; i++) {
X	res *= choosen_cities.citynum - i;
X	printf("    | %6d | %14d |\n", i+1, res);
X    }
X    puts("    ---------------------------");
X    max_stage = i;
X
X    do {
X        do {
X            printf("\nStage of parallelism? (2..%d) ", max_stage);
X            scanf("%d", &stage);
X        } while(stage < 2 || stage > max_stage);
X        for(res = i = 1; i < stage; i++)
X	    res *= choosen_cities.citynum - i;
X        printf("Do you really want to generate %d processes? (y/n) ", res);
X        scanf("%s", input);
X    } while(input[0] != 'y' && input[0] != 'Y');
X
X    create build_route(create collect_results(res) local, way, choosen_cities, stage-1);
X
X    exit(0);
X}
END_OF_FILE
if test 16790 -ne `wc -c <'examples/travel/travel.dc'`; then
    echo shar: \"'examples/travel/travel.dc'\" unpacked with wrong size!
fi
# end of 'examples/travel/travel.dc'
fi
if test -f 'include/config.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/config.h'\"
else
echo shar: Extracting \"'include/config.h'\" \(17581 characters\)
sed "s/^X//" >'include/config.h' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                             c o n f i g . h                             *
X *                                                                         *
X *                            Package : Include files                      *
X *                            Version : 1.0                                *
X *                       CreationDate : 05.07.90                           *
X *                         LastUpDate : 06.12.93                           *
X *                                                                         *
X * The main configuration file of the compiler containing preprocessor     *
X * definitions, macros, type and structure definitions.                    *
X *                                                                         *
X *      Copyright (C) 1990-1994 by Franz Distler and Christoph Pleier.     *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#ifndef __config_h
X#define __config_h
X
X/* ------------------------------ constants ------------------------------ */ 
X
X/* general return codes */
X#define OK		0
X#define ERROR		-1
X
X/* exit codes */
X#define EXIT_OK		0	/* no error */
X#define EXIT_FOPEN	1	/* error during opening of a file */
X#define EXIT_PARSEOPT	2	/* error during parsing of command line args */
X#define EXIT_INPUTFILE	3	/* error: inputfile does not exist */
X#define EXIT_CPP	4	/* error: cpp does not work */
X#define EXIT_PARSING	5	/* error during parsing of input file */
X#define EXIT_BUILDING	6	/* error during compilation and linking */
X#define EXIT_HOSTNAME	7	/* error: unable to determine name of host */
X#define EXIT_FATAL	8 	/* fatal error during compilation */
X#define EXIT_PANIC	9 	/* normally impossible error */
X
X/* boolean constants */
X#ifndef TRUE
X# define TRUE		1
X# define FALSE		0
X#endif
X
X/* maximal length of  */
X#define MAXFILENAMELEN	14	/* a filename */
X#define MAXPATHNAMELEN	256	/* a path name */
X#define MAXIDLEN	30	/* an identifier */
X/* NOTE: MAXIDLEN must be smaller than 'request' of 'TRANSDATA' in dcc.h! */
X
X/* postfixes of generated names */
X#define POSTFIXSPECPAR	"_PPAR"	/* process creation parameter types */
X#define POSTFIXTRANSPAR	"_TPAR"	/* transaction parameter types */
X#define POSTFIXTRANSRES	"_TRES"	/* transaction result types */
X
X/* postfixes of generated filenames */
X#define MAINFILEEXT	"_dc.c"
X#define SPECFILEEXT	"_sr.c"	
X#define FUNCFILEEXT	"_fn.c"
X#define XDRFILEEXT	"_xdr.c"
X
X/* sizes of the symbol table arrays */
X#define MAXIDNUM	1451	/* size of the ID list table (prime number!) */
X#define MAXPSTNUM	100	/* size of the PST table */
X
X/* the maximal size of code storing strings */
X#define CODESTRLEN	2000
X
X/* To avoid stupid memory allocation errors especially under UNIX SYSTEM V we 
X * add for safety reasons an additional value to the requested size during 
X * memory allocation in Malloc().
X */
X#if defined(SYSTEM_V) || defined(CONVEX)
X# define MALLOCADDVAL	100
X#else
X# define MALLOCADDVAL	0
X#endif /* SYSTEM_V /**/
X
X/* valid symbol table entry types */
X#define UDEC		0	/* not declared */
X#define PROCESSDECL	1	/* process */
X#define VARORPAR	2	/* variable or parameter */
X#define TRANSACTION	3	/* transaction */ 
X#define FUNCTIONDEF	4	/* function definition */
X#define PROCESSVAR	5	/* process variable */
X#define TYPEDEFNAME	6	/* type definition */
X#define STRUCTDECL	7	/* structure declaration */
X
X/* name of administration process */
X#define ADMINPATH	"dcadmin"
X
X/* types of alternatives */
X#define ALT_ACCEPT	1
X#define ALT_TERMINATE	2
X#define ALT_IMMEDIATE	3
X
X#ifdef iPSC
X/* nodes and pids of main and admin process */
X# define MAIN_NODE	0L
X# define MAIN_PID	0L
X# define ADMIN_NODE	1L
X# define ADMIN_PID	1L
X#endif /* iPSC /**/
X
X/* attribute types */
X#define SCS_ATTR_AUTO		0
X#define SCS_ATTR_REGISTER	1
X#define SCS_ATTR_STATIC		2
X#define SCS_ATTR_EXTERN		3
X#define SCS_ATTR_TYPEDEF	4
X#define TS_ATTR_VOID		5
X#define TS_ATTR_CHAR		6
X#define TS_ATTR_SHORT		7
X#define TS_ATTR_INT		8
X#define TS_ATTR_LONG		9
X#define TS_ATTR_FLOAT		10
X#define TS_ATTR_DOUBLE		11
X#define TS_ATTR_PROCESS		12
X#define TS_ATTR_SIGNED		13
X#define TS_ATTR_UNSIGNED	14
X#define TS_ATTR_ENUM		15
X#define TS_ATTR_STRUCT		16
X#define TS_ATTR_TYPENAME	17
X#define TQ_ATTR_CONST	 	18
X#define TQ_ATTR_VOLATILE 	19
X#define SU_ATTR_STRUCT		20
X#define SU_ATTR_UNION		21
X#define P_ATTR_1		22
X#define P_ATTR_2		23
X#define P_ATTR_3		24
X#define P_ATTR_4		25
X#define DD_ATTR_IDENT		26
X#define DD_ATTR_FUNC		27
X#define DD_ATTR_ARRAY		28
X#define DD_ATTR_BRACED		29
X#define SQL_ATTR_SPECIFIER	30
X#define SQL_ATTR_QUALIFIER	31
X
X#if defined(ATTRDEBUG) || defined(CODEDEBUG) || defined(DECLDEBUG) \
X	|| defined(DEBUG) || defined(STRUCTDEBUG) || defined(SYMBDEBUG) \
X	|| defined(XDRDEBUG) || defined(YYDEBUG)
X# define DEBUGFLAG
X#endif
X
X/* ------------------------------- macros ------------------------------- */ 
X
X#if defined(__STDC__) && !defined(NO_PROTOTYPE)
X# define FUNCPROTO(type,id,args)	extern type id args
X#else
X# define FUNCPROTO(type,id,args)	extern type id()
X#endif /* __STDC__ /**/
X
X#define PRINTERROR(s, c)		Errno = c; Error(NULL, s)
X
X#ifdef SYSTEM_V
X# define bzero(s, n)			memset((char *)(s), '\0', (unsigned)(n))
X# define bcopy(src, dst, num)		memcpy((dst), (src), (num))
X#endif /* SYSTEM_V /**/
X
X/* -------------------------- type definitions -------------------------- */ 
X
X/* the type of a symbol table element */
Xtypedef struct symbtabel {
X	char *name;	    /* the name of the identifier */
X	short type;	    /* the type of the entry */
X	int blknum;	    /* block depth */
X	short WasInSysIncl; /* symbol was declared in system include file */
X
X	union {
X
X		/* variable or parameter:
X		 * ----------------------
X		 * The components are:
X		 * 'DataType' (data type)
X		 *     The type of the variable or parameter (int, long, ...)
X		 *     as declaration specifiers attribute.
X		 * 'NextParam' (next parameter):
X		 *     Pointer to the next parameter in the parameter list
X		 *     (parameters only).
X		 */
X		struct {
X			struct ds_attr_t *DataType;
X			struct symbtabel *NextParam;
X		} varorpar;
X
X		/* transaction:
X		 * ------------
X		 * The components are:
X		 * 'IsDecl' (is declaration):
X		 *     Specifying entry is a declaration or not.
X		 * 'ReturnType' (return type):
X		 *     The return type of the transaction (int, long, ...)
X		 *     as declaration specifiers attribute.
X		 * 'labnum' (label number):
X		 *     The label number used for building the end label 
X		 * 'ptiname' (process transaction intern name):
X		 *     The process transaction intern name (needed for naming).
X		 * 'uptiname' (upcase process transaction intern name):
X		 *     The process transaction intern name in upcase letters 
X		 *     (needed for naming).
X		 * 'Process' (process):
X		 *     Pointer to the process containing this transaction.
X		 * 'FirstParam' (first parameter):
X		 *     Pointer to the first transaction parameter.
X		 * 'NextTrans' (next transaction):
X		 *     Pointer to the next transaction in transaction list.
X		 * 'ReturnType' (return type):
X		 *     Pointer to the declaration_specifiers_attribute
X		 *     specifying the return type.
X		 */
X		struct {
X			short IsDecl;
X			struct ds_attr_t *ReturnType;
X			int labnum;
X			char ptiname[MAXIDLEN+1],
X			     uptiname[MAXIDLEN+1];
X			struct symbtabel *Process,
X			                 *FirstParam,
X			                 *NextTrans;
X		} trans;
X
X		/* process specification:
X		 * ----------------------
X		 * The components are:
X		 * 'IsSpec' (is specification):
X		 *     Specifying entry is specification or not.
X		 * 'FirstParam' (first parameter):
X		 *     Pointer to the first process parameter.
X		 * 'FirstTrans' (first transaction):
X		 *     Pointer to the first process transaction.
X		 * 'filename' (filename):
X		 *     Name of the file to write the process code into.
X		 * 'piname' (process intern name):
X		 *     The process intern name (for naming).
X		 * 'upiname' (upcase process intern name):
X		 *     The process intern name in upcase letters (for naming).
X		 * 'codefile' (codefile):
X		 *     The file handler to write the process code into.
X		 */
X		struct {
X			short IsSpec;
X			struct symbtabel *FirstParam,
X			                 *FirstTrans;
X			char filename[MAXFILENAMELEN+1],
X			     piname[MAXIDLEN+1], 
X			     upiname[MAXIDLEN+1]; 
X			FILE *codefile;
X		} process;
X
X		/* function definition:
X		 * --------------------
X		 * The components are:
X		 * 'Returntype' (return type):
X		 *     The return type of the function as string.
X		 */
X		struct {
X			char *ReturnType;
X		} functiondef;
X
X		/* type definition:
X		 * ----------------
X		 * The components are:
X		 * 'IsPointer' (is a pointer)
X		 *     Specifying if type definition is a pointer or not.
X		 * 'BuildXDRRoutine' (build XDR routine):
X		 *     Specifying a special XDR routine must be created for
X		 *     this type definition or not.
X		 * 'decl_spec' (declaration specifiers):
X		 *     The corresponding declaration specifiers.
X		 * 'id_list' (init declarator list):
X		 *     The corresponding declarator list.
X		 * 'ErrPos' (error position):
X		 *     The source code position of the definition.
X		 */
X		struct {
X			short IsPointer,
X		              BuildXDRRoutine;
X			struct ds_attr_t *decl_spec;
X			struct idl_attr_t *id_list;
X			char *ErrPos;
X		} typedefname;
X
X		/* structure declaration:
X		 * ----------------------
X		 * The components are:
X		 * 'IsStruct' (is structure)
X		 *     Specifying if entry is struct or union.
X		 * 'BuildXDRRoutine' (build XDR routine):
X		 *     Specifying a special XDR routine must be created for
X		 *     this type definition or not.
X		 * 'StruDeclList' (struct declaration list):
X		 *     The corresponding struct declaration list.
X		 * 'ErrPos' (error position):
X		 *     The source code position of the definition.
X		 */
X		struct {
X			short IsStruct,
X		              BuildXDRRoutine;
X			struct stl_attr_t *StruDeclList;
X			char *ErrPos;
X		} structdecl;
X
X	} info;
X
X	struct symbtabel *IdNext,	/* next entry in ID list */
X	                 *PstNext;	/* next entry in PST list */
X} SYMBTABEL;
X
X/* the type of the symbol table */
Xtypedef struct {
X	struct symbtabel *IdTab[MAXIDNUM],
X	                 *PstTab[MAXPSTNUM];
X} SYMBTAB;
X
Xtypedef struct {
X	SYMBTABEL *symbol;
X	char name[MAXIDLEN];
X} IDENTINFO;
X
X/* identifier chain:
X * this structure is used to chain identifiers
X */
Xtypedef struct ident_chain_t {
X	SYMBTABEL            *symbol;
X	struct ident_chain_t *next;
X} IDENTCHAIN;
X
X/* argument expression list:
X * this structure is used to store the code of the several actual parameters
X * during process creation or transaction calls
X */
Xtypedef struct arg_list {
X	char            *code;	/* code of the argument */
X	struct arg_list *next;	/* next argument */
X} ARG_LIST;
X
X/* compound statement attribute:
X * this structure contains the two parts of a compound statement as strings
X */
Xtypedef struct comp_attr_t {
X	char *decls,		/* declarations */
X	     *stats;		/* statements */
X} COMPATTR;
X
X/* accept statement attribute:
X * contains the peculiar information of an accept statement
X */
Xtypedef struct accept_attr_t {
X	SYMBTABEL          *transaction; /* transaction */
X	struct comp_attr_t *comp_attr;   /* body */
X} ACCEPTATTR;
X
X/* select statement attribute:
X * contains the peculiar information of an select statement alternative
X */
Xtypedef struct select_attr_t {
X	int                   type;        /* type of the alternative */
X	char                 *guard,       /* guard */
X	                     *stats;       /* additional alternative code */
X	struct accept_attr_t *accept_attr; /* info of an accept alternative */
X	struct select_attr_t *next;        /* pointer to next alternative */
X} SELECTATTR;
X
X/* postfix statement attribute:
X * this structure is used to store the code of the postfix expression
X * and a pointer to the valid symbols in the symbol table
X */
Xtypedef struct post_attr_t {
X	char       *codestr;
X	IDENTCHAIN *idents;
X} POSTATTR;
X
X/* transaction attribute:
X * this structure is used to collect the information of a transaction call
X */
Xtypedef struct trans_attr_t {
X	char      *target;	/* code of the postfix expression */
X	SYMBTABEL *symbol;	/* pointer to the specified transaction */
X	ARG_LIST  *arg;		/* transaction arguments */
X} TRANSATTR;
X
X/* storage class specifier attribute:
X */
Xtypedef struct scs_attr_t {
X	char type;		/* auto, register, static, extern, typedef */
X} SCS_ATTR;
X
X/* type specifier attribute:
X */
Xtypedef struct ts_attr_t {
X	char type;	/* elementar, struct/union, typedefname */
X	union {
X		struct es_attr_t  *enuminfo; 
X		struct sus_attr_t *structinfo;
X		SYMBTABEL *typedefname,
X		          *process;
X	} info;
X} TS_ATTR;
X
X/* type qualifier attribute:
X */
Xtypedef struct tq_attr_t {
X	char type;		/* const, volatile */
X} TQ_ATTR;
X
X/* enumeration attribute:
X */
Xtypedef struct es_attr_t {
X	char *codestr;
X} ES_ATTR;
X
X/* struct or union attribute:
X */
Xtypedef struct su_attr_t {
X	char type;		/* struct, union */
X} SU_ATTR;
X
X/* type qualifier list attribute:
X */
Xtypedef struct tql_attr_t {
X	TQ_ATTR *type_qualifier;
X	struct tql_attr_t *tq_list;
X} TQL_ATTR;
X
X/* pointer attribute:
X */
Xtypedef struct p_attr_t {
X	char type;
X	TQL_ATTR *quali_list;
X	struct p_attr_t *pointer;
X} P_ATTR;
X
X/* direct declarator attribute:
X */
Xtypedef struct dd_attr_t {
X	char type;
X	SYMBTABEL *ident;
X	union {
X		struct d_attr_t *declarator;
X		struct {
X			struct dd_attr_t *direct_decl;
X			char *spec_str;
X		} comp;
X	} info;
X} DD_ATTR;
X
X/* declarator attribute:
X */
Xtypedef struct d_attr_t {
X	P_ATTR  *pointer;
X	DD_ATTR *direct_decl;
X} D_ATTR;
X
X/* struct declarator attribute:
X */
Xtypedef struct sd_attr_t {
X	D_ATTR *decl;
X	char   *const_expr;
X} SD_ATTR;
X
X/* struct declarator list attribute:
X */
Xtypedef struct sdl_attr_t {
X	SD_ATTR           *struct_declarator;
X	struct sdl_attr_t *sd_list;
X} SDL_ATTR;
X
X/* specifier qualifier list attribute:
X */
Xtypedef struct sql_attr_t {
X	char type; 	/* specifier or qualifier */
X	union {
X		TS_ATTR *type_specifier;
X		TQ_ATTR *type_qualifier;
X	} info;
X	struct sql_attr_t *sq_list;
X} SQL_ATTR;
X
X/* struct declaration attribute:
X */
Xtypedef struct st_attr_t {
X	SQL_ATTR *spec_qual_list;
X	SDL_ATTR *struct_decl_list;
X} ST_ATTR;
X
X/* struct declaration list attribute:
X */
Xtypedef struct stl_attr_t {
X	ST_ATTR           *struct_decl;
X	struct stl_attr_t *st_list;
X} STL_ATTR;
X
X/* struct or union specifier attribute:
X */
Xtypedef struct sus_attr_t {
X	SU_ATTR   *struct_or_union;
X	SYMBTABEL *tag;
X	STL_ATTR  *struct_decl_list;
X} SUS_ATTR;
X
X/* init_declarator_attribute:
X */
Xtypedef struct id_attr_t {
X	D_ATTR *d;	/* declarator */
X	char   *inistr;	/* initializer */
X} ID_ATTR;
X	
X/* init declarator list attribute:
X */
Xtypedef struct idl_attr_t {
X	struct idl_attr_t *id_list;	/* init declarator list */
X	ID_ATTR           *id;		/* init declarator */
X} IDL_ATTR;
X
X/* declaration specifiers attribute:
X */
Xtypedef struct ds_attr_t {
X	SCS_ATTR         *scs;	/* storage class specifier */
X	TS_ATTR          *ts;	/* type specifier */
X	TQ_ATTR          *tq;	/* type qualifier */
X	struct ds_attr_t *ds; 	/* declaration specifiers */
X} DS_ATTR;
X
X/* ------------------------ structure definitions ------------------------ */ 
X
X/* process filename list:
X * the names of the processfiles are stored in this list
X */
Xstruct process_list {
X	char                *name;	/* process filename */
X	FILE                *file;	/* process file */
X	struct process_list *next;	/* next element */
X};
X
X/* include filename list:
X * the names of the includefiles are stored in this list
X */
Xstruct include_list {
X	char                *name;	/* include filename */
X	struct include_list *next;	/* next element */
X};
X
X/* include filename list:
X * the names of additional include paths are stored in this list
X */
Xstruct include_path_list {
X	char                     *path;	/* path name */
X	struct include_path_list *next;	/* next element */
X};
X
X/* preprocessor definition list:
X * the names of additional preprocessor definitions are stored in this list
X */
Xstruct cpp_def_list {
X	char                *def;	/* preprocessor definition */
X	struct cpp_def_list *next;	/* next element */
X};
X
X/* structure and typedef list:
X * pointer to symbol table entries of structure and type definitions are 
X * collected in this list in the order of their appearance
X */
Xstruct struct_type_list {
X	SYMBTABEL               *symbol; /* pointer to symbol table entry */
X	struct struct_type_list *next;	 /* next element */
X};
X
X#endif /* !__config_h /**/
END_OF_FILE
if test 17581 -ne `wc -c <'include/config.h'`; then
    echo shar: \"'include/config.h'\" unpacked with wrong size!
fi
# end of 'include/config.h'
fi
if test -f 'lib/convert.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib/convert.c'\"
else
echo shar: Extracting \"'lib/convert.c'\" \(18797 characters\)
sed "s/^X//" >'lib/convert.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                           c o n v e r t . c                             *
X *                                                                         *
X *                            Package : Runtime Library                    *
X *                            Version : 2.0                                *
X *                       CreationDate : 27.07.90                           *
X *                         LastUpDate : 26.09.91                           *
X *                                                                         *
X *       The runtime library functions used to transform structures.       *
X *                                                                         *
X *                  Portions Copyright 1990 Franz Distler                  *
X *                  Portions Copyright 1990 Markus Pleier                  *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#ifdef HETEROGENEOUS
X# include <rpc/rpc.h>
X#endif
X#ifdef SYSTEM_V
X# include <memory.h>
X#endif /* SYSTEM_V /**/
X#include "ipc.h"
X#include "dcc.h"
X#include "run_Errno.h"
X
X#define DEBUG_CONVERT /**/
X
X#ifdef DEBUG_CONVERT
X/* the flag to control the debug messages output */
Xint _debug_convert = 0;
X#endif /* DEBUG_CONVERT /**/
X
X#ifdef DEBUG_CONVERT
X# define DEBUGPUTS(msg)		if (_debug_convert) { \
X				    fprintf(_debugout, "[cvt] %s %s\n", \
X				        _processprefix, msg); \
X				    if (_debugflush) \
X				        fflush(_debugout); \
X				}
X# define DEBUGDISPERR(msg)	if (_debug_convert) { \
X				    fprintf(_debugout, "[cvt] %s error: %s\n", \
X				        _processprefix, msg); \
X				    fprintf(_debugout, "[cvt] %s reason: %s\n",\
X				        _processprefix, sys_errlist[errno]); \
X				    if (_debugflush) \
X				        fflush(_debugout); \
X				}
X#else
X# define DEBUGPUTS(msg)		{ /* nothing */ }
X# define DEBUGDISPERR(msg)	{ /* nothing */ }
X#endif
X
X#ifdef HETEROGENEOUS
X
X/******************************************************************************
X * _allocate_encode_decode_buffer()                                           *
X *                                                                            *
X * Allocates the heap space to perform the encode/decode actions.             *
X * Note: This function is used only in the heterogenous version!              *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
X_allocate_encode_decode_buffer(size)
Xunsigned  size;
X{
X#ifdef DEBUG_CONVERT
X    if (_debug_convert) {
X        fprintf(_debugout, "[cvt] %s ***** _allocate_encode_decode_buffer():\n",
X	    _processprefix);
X        fprintf(_debugout, "[cvt] %s size = %d\n", _processprefix, size);
X        if (_debugflush)
X            fflush(_debugout);
X    }
X#endif /* DEBUG_CONVERT /**/
X    _dcc_buf      = (char *) malloc(size);
X    _xdr_size_buf = (char *) malloc(SIZEOFLONG);
X    if (_dcc_buf == NULL || _xdr_size_buf == NULL) {
X        Errno = EMALLOCBUF;
X	return(ERROR);
X    } else {
X        xdrmem_create(&encode_xdrs, _dcc_buf, size, XDR_ENCODE);
X        xdrmem_create(&decode_xdrs, _dcc_buf, size, XDR_DECODE);
X        xdrmem_create(&_xdr_encode_size_xdrs, _xdr_size_buf, SIZEOFLONG, XDR_ENCODE);
X        xdrmem_create(&_xdr_decode_size_xdrs, _xdr_size_buf, SIZEOFLONG, XDR_DECODE);
X	return(OK);
X    }
X} /* _allocate_encode_decode_buffer */
X
X/******************************************************************************
X * _encode()                                                                  *
X *                                                                            *
X * Transforms the structure pointed to by 'ptr' into XDR format. The result   *
X * will be stored in the memory pointed to by the global variable '_dcc_buf'. *
X * 'size' specifies the size of the processed structure.                      *
X * Note: This function is used only in the heterogenous version!              *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
X_encode(ptr, xdr_func, size)
Xchar          *ptr;
Xint           (*xdr_func)();
Xunsigned long *size;
X{
X#ifdef DEBUG_CONVERT
X    if (_debug_convert) {
X        fprintf(_debugout, "[cvt] %s ***** _encode():\n", _processprefix);
X        fprintf(_debugout, "[cvt] %s ptr = %d, xdr_func = %d\n",
X            _processprefix, ptr, xdr_func);
X        if (_debugflush)
X            fflush(_debugout);
X    }
X#endif /* DEBUG_CONVERT /**/
X    /* encode to XDR format */
X    if ((*xdr_func)(&encode_xdrs, ptr) == FALSE) {
X        Errno = EENCODE;
X	return(ERROR); 
X    }
X    /* determine size of encoded data */
X    if ((*size = xdr_getpos(&encode_xdrs)) == 0) {
X	Errno = EENCODESIZE;
X	return(ERROR);
X    }
X    /* rewind memory stream */
X    if (xdr_setpos(&encode_xdrs, 0) == 0) {
X	Errno = EXDRSETPOS;
X	return(ERROR);
X    }
X#ifdef DEBUG_CONVERT
X    if (_debug_convert) {
X        fprintf(_debugout, "[cvt] %s       resulting size = %d\n", 
X	    _processprefix, *size);
X        if (_debugflush)
X            fflush(_debugout);
X    }
X#endif /* DEBUG_CONVERT /**/
X    return(OK);
X} /* _encode */
X
X/******************************************************************************
X * _decode()                                                                  *
X *                                                                            *
X * Transforms the XDR formated memory block pointed to by the global variable *
X * '_dcc_buf' into the structure pointed to by 'ptr'. 'size' specifies the    *
X * size of the structure in bytes.                                            *
X * Note: This function is used only in the heterogenous version!              *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
X_decode(ptr, xdr_func)
Xchar *ptr;
Xint  (*xdr_func)();
X{
X#ifdef DEBUG_CONVERT
X    if (_debug_convert) {
X        fprintf(_debugout, "[cvt] %s ***** _decode():\n", _processprefix);
X        fprintf(_debugout, "[cvt] %s ptr = %d, xdr_func = %d\n",
X            _processprefix, ptr, xdr_func);
X        if (_debugflush)
X            fflush(_debugout);
X    }
X#endif /* DEBUG_CONVERT /**/
X    /* decode from XDR format */
X    if ((*xdr_func)(&decode_xdrs, ptr) == FALSE) {
X        Errno = EDECODE;
X	return(ERROR);
X    }
X    /* rewind memory stream */
X    if (xdr_setpos(&decode_xdrs, 0) == 0) {
X	Errno = EXDRSETPOS;
X	return(ERROR);
X    }
X    return(OK);
X} /* _decode */
X
X/******************************************************************************
X * _send_data_encoded()                                                       *
X *                                                                            *
X * ????                                                                       *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
X_send_data_encoded(con_port, data, xdr_func, timeout)
XCONNECTIONDESCR *con_port;
Xchar            *data;
Xint             (*xdr_func)();
Xint             timeout;
X{
X    unsigned long _xdr_size;
X
X#ifdef DEBUG_CONVERT
X    if (_debug_convert) {
X        fprintf(_debugout, "[cvt] %s ***** _send_data_encoded():\n", 
X	    _processprefix);
X        fprintf(_debugout, "[cvt] %s data = %d, xdr_func = %d\n",
X            _processprefix, data, xdr_func);
X        if (_debugflush)
X            fflush(_debugout);
X    }
X#endif /* DEBUG_CONVERT /**/
X    /* encode data to XDR format and store it in _dcc_buf */
X    if (_encode(data, xdr_func, &_xdr_size))
X        return(ERROR);
X    /* encode size of encoded data and store it in _xdr_size_buf */
X    if (!xdr_u_long(&_xdr_encode_size_xdrs, &_xdr_size)) {
X        Errno = EENCODE;
X        return(ERROR);
X    }
X    /* rewind memory stream */
X    if (xdr_setpos(&_xdr_encode_size_xdrs, 0) == 0) {
X        Errno = EXDRSETPOS;
X        return(ERROR);
X    }
X#ifdef DEBUG_CONVERT
X    if (_debug_convert) {
X        fprintf(_debugout, "[cvt] %s       size of encoded data: %d\n",
X            _processprefix, _xdr_size);
X        if (_debugflush)
X            fflush(_debugout);
X    }
X#endif /* DEBUG_CONVERT /**/
X    /* send size of encoded data */
X    if (_send_data(con_port, _xdr_size_buf, SIZEOFLONG, timeout) < 0)
X        return(ERROR);
X    if (_send_data(con_port, _dcc_buf, _xdr_size, timeout) < 0)
X        return(ERROR);
X    Errno = -1;
X    return(OK);
X} /* _send_data_encoded */
X
X/******************************************************************************
X * _recv_data_encoded()                                                       *
X *                                                                            *
X * ????                                                                       *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
X_recv_data_encoded(con_port, data, xdr_func, timeout)
XCONNECTIONDESCR *con_port;
Xchar            *data;
Xint             (*xdr_func)();
Xint             timeout;
X{
X    unsigned long _xdr_size;
X
X#ifdef DEBUG_CONVERT
X    if (_debug_convert) {
X        fprintf(_debugout, "[cvt] %s ***** _recv_data_encoded():\n", 
X	    _processprefix);
X        fprintf(_debugout, "[cvt] %s data = %d, xdr_func = %d\n",
X            _processprefix, data, xdr_func);
X        if (_debugflush)
X            fflush(_debugout);
X    }
X#endif /* DEBUG_CONVERT /**/
X    /* receive size of encoded data */
X    if (_recv_data(con_port, _xdr_size_buf, SIZEOFLONG, timeout) < 0)
X        return(ERROR);
X    /* decode size of encoded data and store it in _xdr_size */
X    if (!xdr_u_long(&_xdr_decode_size_xdrs, &_xdr_size))
X        return(ERROR);
X    /* rewind memory stream */
X    if (xdr_setpos(&_xdr_decode_size_xdrs, 0) == 0) {
X        Errno = EXDRSETPOS;
X        return(ERROR);
X    }
X    /* receive data */
X    if (_recv_data(con_port, _dcc_buf, _xdr_size, timeout) < 0)
X        return(ERROR);
X    /* decode data from _dcc_buf and store it */
X    if (_decode(data, xdr_func))
X        return(ERROR);
X    Errno = -1;
X    return(OK);
X} /* _recv_data_encoded */
X
X#endif /* HETEROGENEOUS /**/
X
X/******************************************************************************
X * _convert_port_to_argv()                                                    *
X *                                                                            *
X * Transforms the system dependent port information of 'port' into strings    *
X * pointed to by 'parv'. These strings are used as arguments during process   *
X * creation.                                                                  *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
X_convert_port_to_argv(parv, port1, port2)
Xchar      *parv[];
XPORTDESCR  port1,
X           port2;
X{
X	int i;
X	static char parstr[5][256];
X
X#ifdef DEBUG_CONVERT
X	if (_debug_convert) {
X	    fprintf(_debugout, "[cvt] %s ***** _convert_port_to_argv():\n",
X	        _processprefix);
X	    _display_port_info("[cvt]", "port1", port1);
X	    _display_port_info("[cvt]", "port2", port2);
X	}
X#endif /* DEBUG_CONVERT /**/
X#ifdef MSGSEM
X	sprintf(parstr[0], "%d", port1.msqid);
X	sprintf(parstr[1], "%d", port1.semid);
X	sprintf(parstr[2], "%d", port2.msqid);
X	sprintf(parstr[3], "%d", port2.semid);
X#endif /* MSGSEM /**/
X#ifdef SOCKET
X	sprintf(parstr[0], "%d", port1.portnum);
X	strcpy(parstr[1], port1.hostname);
X	sprintf(parstr[2], "%d", port2.portnum);
X	strcpy(parstr[3], port2.hostname);
X#endif /* SOCKET /**/
X	parv[1] = parstr[0];
X	parv[2] = parstr[1];
X	parv[3] = parstr[2];
X	parv[4] = parstr[3];
X	parv[5] = NULL;
X#ifdef DEBUG_CONVERT
X	if (_debug_convert) {
X	    fprintf(_debugout, "[cvt] %s arguments:\n", _processprefix); 
X	    for(i=1; parv[i]; i++) {
X	        fprintf(_debugout, "[cvt] %s    \"%s\"\n",
X		    _processprefix, parv[i]);
X	    }
X	    if (_debugflush)
X		fflush(_debugout);
X	}
X#endif /* DEBUG_CONVERT /**/
X} /* _convert_port_to_argv */
X
X/******************************************************************************
X * _convert_argv_to_port()                                                    *
X *                                                                            *
X * Transforms the system dependent port information stored in strings pointed *
X * to by 'parv' into 'port'.                                                  *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
X_convert_argv_to_port(port1, port2, parv)
XPORTDESCR *port1,
X          *port2;
Xchar      *parv[];
X{
X	DEBUGPUTS("***** _convert_argv_to_port():");
X#ifdef MSGSEM
X	port1->msqid = atoi(parv[1]);
X	port1->semid = atoi(parv[2]);
X	port2->msqid = atoi(parv[3]);
X	port2->semid = atoi(parv[4]);
X#endif /* MSGSEM /**/
X#ifdef SOCKET
X	port1->portnum = atoi(parv[1]);
X	strcpy(port1->hostname, parv[2]);
X	port2->portnum = atoi(parv[3]);
X	strcpy(port2->hostname, parv[4]);
X#endif /* SOCKET /**/
X#ifdef DEBUG_CONVERT
X	if (_debug_convert) {
X	    _display_port_info("[cvt]", "port1", *port1);
X	    _display_port_info("[cvt]", "port2", *port2);
X	    if (_debugflush)
X		fflush(_debugout);
X	}
X#endif /* DEBUG_CONVERT /**/
X} /* _convert_argv_to_port */
X
X#ifdef MSGSEM
X/******************************************************************************
X * init_port()                                                                *
X *                                                                            *
X * Initializes a port.                                                        *
X * NOTE: This is the version for use with message queues and semaphores.      *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
Xinit_port(port, msqid, semid)
XPORTDESCR *port;
Xint msqid, semid;
X{
X	port->msqid = msqid;
X	port->semid = semid;
X# ifdef DEBUG_CONVERT
X	if (_debug_convert) {
X	    fprintf(_debugout, "[cvt] %s ***** init_port():\n", _processprefix);
X	    _display_port_info("[cvt]", "port", *port);
X	    if (_debugflush)
X		fflush(_debugout);
X	}
X# endif /* DEBUG_CONVERT /**/
X} /* init_port (message queues and semaphores version) */
X#endif /* MSGSEM /**/
X
X#ifdef iPSC
X/******************************************************************************
X * init_port()                                                                *
X *                                                                            *
X * Initializes a port.                                                        *
X * NOTE: This is the version for use on Intel Hypercube.                      *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
Xinit_port(port, node, pid)
XPORTDESCR *port;
Xlong node, pid;
X{
X	port->node = node;
X	port->pid  = pid;
X# ifdef DEBUG_CONVERT
X	if (_debug_convert) {
X	    fprintf(_debugout, "[cvt] %s ***** init_port():\n", _processprefix);
X	    _display_port_info("[cvt]", "port", *port);
X	    if (_debugflush)
X		fflush(_debugout);
X	}
X# endif /* DEBUG_CONVERT /**/
X} /* init_port (Intel Hypercube version) */
X#endif /* iPSC /**/
X
X#ifdef SOCKET
X/******************************************************************************
X * init_port()                                                                *
X *                                                                            *
X * Initializes a port.                                                        *
X * NOTE: This is the version for use with stream sockets.                     *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
Xinit_port(port, socket, portnum, hostname)
XPORTDESCR *port;
Xint socket, portnum;
Xchar hostname[];
X{
X	port->state    = -1;
X	port->acc_sock = -1;
X	port->con_sock = -1;
X	port->portnum  = portnum;
X	strcpy(port->hostname, hostname);
X# ifdef DEBUG_CONVERT
X	if (_debug_convert) {
X	    fprintf(_debugout, "[cvt] %s ***** init_port():\n", _processprefix);
X	    _display_port_info("[cvt]", "port", *port);
X	    if (_debugflush)
X		fflush(_debugout);
X	}
X# endif /* DEBUG_CONVERT /**/
X} /* init_port (socket version) */
X#endif /* SOCKET /**/
END_OF_FILE
if test 18797 -ne `wc -c <'lib/convert.c'`; then
    echo shar: \"'lib/convert.c'\" unpacked with wrong size!
fi
# end of 'lib/convert.c'
fi
echo shar: End of archive 12 \(of 18\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
