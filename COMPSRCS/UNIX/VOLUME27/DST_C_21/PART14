Newsgroups: comp.sources.unix
From: pleierc@informatik.tu-muenchen.de (Christoph Pleier)
Subject: v27i188: distributed-c-2.1 - Distributed C Development Environment, V2.1, Part14/18
References: <1.756634932.28500@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: pleierc@informatik.tu-muenchen.de (Christoph Pleier)
Posting-Number: Volume 27, Issue 188
Archive-Name: distributed-c-2.1/part14

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 14 (of 18)."
# Contents:  dcc/symb_process.c dcc/xdrfile.c
# Wrapped by vixie@gw.home.vix.com on Thu Dec 23 00:12:05 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dcc/symb_process.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcc/symb_process.c'\"
else
echo shar: Extracting \"'dcc/symb_process.c'\" \(29410 characters\)
sed "s/^X//" >'dcc/symb_process.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                       s y m b _ p r o c e s s . c                       *
X *                                                                         *
X *                            Package : Compiler                           *
X *                            Version : 2.0                                *
X *                       CreationDate : 01.08.90                           *
X *                         LastUpDate : 08.06.91                           *
X *                                                                         *
X *    All functions handling symbol table information about processes.     *
X *                                                                         *
X *                  Portions Copyright 1990 Franz Distler                  *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include "config.h"
X#include "extern.h"
X#include "functions.h"
X#include "y.tab.h" 
X#include "com_Errno.h"
X
X/******************************************************************************
X * make_process()                                                             *
X *                                                                            *
X * Initializes the symbol table element pointed to by 'symbol' as process     *
X * specification.                                                             *
X *                                                                            *
X * Return values: 'symbol' upon success / NULL upon error                     *
X ******************************************************************************/
XSYMBTABEL *
Xmake_process(symbol)
XSYMBTABEL *symbol;
X{
X    if (errflag || !symbol) /* error handling */
X	return(NULL);
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** make_process(): params: symbol = %d\n",
X	symbol);
X#endif /* SYMBDEBUG /**/
X    if (symbol->type != UDEC) {
X	strcpy(yytext, symbol->name);
X	PRINTERROR("", EREDEFINITION);
X	return(symbol);
X    }
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb]       initializing entry \"%s\" as PROCESSDECL\n",
X	symbol->name);
X#endif /* SYMBDEBUG /**/
X    symbol->type = PROCESSDECL;
X    symbol->info.process.IsSpec     = TRUE;
X    symbol->info.process.FirstParam = (SYMBTABEL *) NULL;
X    symbol->info.process.FirstTrans = (SYMBTABEL *) NULL;
X    return(symbol);
X} /* make_process */
X
X/******************************************************************************
X * make_process_def()                                                         *
X *                                                                            *
X * Initializes the symbol table element pointed to by 'symbol' as process     *
X * defined.                                                                   *
X *                                                                            *
X * Return values: 'symbol' upon success / NULL upon error                     *
X ******************************************************************************/
XSYMBTABEL *
Xmake_process_def(symbol)
XSYMBTABEL *symbol;
X{
X    if (errflag || !symbol) /* error handling */
X	return((SYMBTABEL *) NULL);
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** make_process_def(): params: symbol = %d\n",
X	symbol);
X#endif /* SYMBDEBUG /**/
X    if (symbol->type != PROCESSDECL) {
X	strcpy(yytext, symbol->name);
X	PRINTERROR("", ENOTSPECIFIED);
X	return(symbol);
X    }
X    if (symbol->info.process.IsSpec != TRUE) {
X	strcpy(yytext, symbol->name);
X	PRINTERROR("", EREDEFINED);
X	return(symbol);
X    }
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb]       marking process \"%s\" as defined\n",
X	symbol->name);
X#endif /* SYMBDEBUG /**/
X    symbol->info.process.IsSpec = FALSE;
X    return(symbol);
X} /* make_process_def */
X
X/******************************************************************************
X * make_parameter()                                                           *
X *                                                                            *
X * Marks the symbol table element pointed to by 'symbol' as parameter.        *
X *                                                                            *
X * Return values: 'symbol' upon success / NULL upon error                     *
X ******************************************************************************/
XSYMBTABEL *
Xmake_parameter(symbol)
Xregister SYMBTABEL *symbol;
X{
X    if (errflag || !symbol) /* error handling */
X	return((SYMBTABEL *) NULL);
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** make_parameter(): params: symbol = %d\n",
X	symbol);
X#endif /* SYMBDEBUG /**/
X    switch(symbol->type) {
X    case UDEC:
X	break;
X    case PROCESSDECL:
X    case TRANSACTION:
X    case VARORPAR:
X    case FUNCTIONDEF:
X    case PROCESSVAR:
X    case TYPEDEFNAME:
X    case STRUCTDECL:
X	if (symbol->blknum == blknum) {
X	    strcpy(yytext, symbol->name);
X	    PRINTERROR("", EREDEFINITION);
X	    return(symbol);
X	} else
X	    symbol = enter_symbtabel(symbol->name);
X	break;
X    default:
X	Panic("unknown kind of symbol table entry in make_parameter()");
X    } /* switch */
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb]       marking \"%s\" as VARORPAR\n",
X	symbol->name);
X#endif /* SYMBDEBUG /**/
X    symbol->type = VARORPAR;
X    symbol->info.varorpar.DataType  = (DS_ATTR *)   NULL;
X    symbol->info.varorpar.NextParam = (SYMBTABEL *) NULL;
X    return(symbol);
X} /* make_parameter */
X
X/******************************************************************************
X * make_transaction()                                                         *
X *                                                                            *
X * Initializes the symbol table element pointed to by 'symbol' as transaction.*
X *                                                                            *
X * Return values: 'symbol' upon success / NULL upon error                     *
X ******************************************************************************/
XSYMBTABEL *
Xmake_transaction(symbol)
XSYMBTABEL *symbol;
X{
X    if (errflag || !symbol) /* error handling */
X	return((SYMBTABEL *) NULL);
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** make_transaction(): params: symbol = %d\n",
X	symbol);
X#endif /* SYMBDEBUG /**/
X    switch(symbol->type) {
X    case UDEC:
X	break;
X    case PROCESSDECL:
X    case TRANSACTION:
X    case VARORPAR:
X    case FUNCTIONDEF:
X    case PROCESSVAR:
X    case TYPEDEFNAME:
X    case STRUCTDECL:
X	if (symbol->blknum == blknum) {
X	    strcpy(yytext, symbol->name);
X	    PRINTERROR("", EREDEFINITION);
X	    return(symbol);
X	} else
X	    symbol = enter_symbtabel(symbol->name);
X	break;
X    default:
X	Panic("unknown kind of symbol table entry in make_transaction()");
X    } /* switch */
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb]       initializing \"%s\" as TRANSACTION\n", 
X	symbol->name);
X#endif /* SYMBDEBUG /**/
X    symbol->type = TRANSACTION;
X    symbol->info.trans.IsDecl      = TRUE;
X    symbol->info.trans.ReturnType  = (DS_ATTR *) NULL;
X    symbol->info.trans.ptiname[0]  = '\0';
X    symbol->info.trans.uptiname[0] = '\0';
X    symbol->info.trans.Process     = (SYMBTABEL *) NULL;
X    symbol->info.trans.FirstParam  = (SYMBTABEL *) NULL;
X    symbol->info.trans.NextTrans   = (SYMBTABEL *) NULL;
X    return(symbol);
X} /* make_transaction */
X
X/******************************************************************************
X * add_process_info()                                                         *
X *                                                                            *
X * Sets the pointers to the parameter list and the transaction list of a      *
X * process specification symbol table element.                                *
X *                                                                            *
X * Return values: 'symbol' upon success / NULL upon error                     *
X ******************************************************************************/
XSYMBTABEL *
Xadd_process_info(symbol, parameters, transactions)
XSYMBTABEL *symbol, *parameters, *transactions;
X{
X    char *piname, *upiname, *hstr;
X    static char extension[20];
X
X    if (errflag || !symbol) /* error handling */
X	return((SYMBTABEL *) NULL);
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** add_process_info():\n");
X    fprintf(debugfile, "[symb]       params: symbol = %d, parameters = %d\n", 
X	symbol, parameters);
X    fprintf(debugfile, "[symb]               transactions = %d\n",
X	transactions);
X#endif /* SYMBDEBUG /**/
X    symbol->info.process.FirstParam = parameters;
X    symbol->info.process.FirstTrans = transactions;
X    /* 
X     * determine process filename 
X     */
X    sprintf(extension, "_p%02d.c", ++processnum);
X    hstr = symbol->info.process.filename;
X    *hstr = hstr[MAXFILENAMELEN] = '\0';
X    strncat(hstr, filenameprefix, MAXFILENAMELEN - strlen(extension));
X    strcat(hstr, extension); 
X    /* 
X     * determine internal process names (used for naming) 
X     */
X    piname = symbol->info.process.piname;
X    *piname = piname[MAXIDLEN - 2] = '\0';
X    strncat(piname, symbol->name, MAXIDLEN - 2);
X    upiname = symbol->info.process.upiname;
X    strcpy(upiname, symbol->info.process.piname);
X    for(; *upiname; ++upiname)
X        *upiname = toupper(*upiname);
X    /*
X     * generate external declaration for include file
X     */
X    crextstr = Strcatmany(crextstr, 3, "extern PROCESSDESCR create_process_",
X	piname, "();\n");
X    return(symbol);
X} /* add_process_info */
X
X/******************************************************************************
X * add_trans_info()                                                           *
X *                                                                            *
X * Initializes the component 'piname' (process intern name).                  *
X *                                                                            *
X * Return values: 'symbol' upon success / NULL upon error                     *
X ******************************************************************************/
XSYMBTABEL *
Xadd_trans_info(process, transactions)
XSYMBTABEL *process, *transactions;
X{
X    register SYMBTABEL *actions;
X    register char *hstr;
X
X    if (errflag || !process) /* error handling */
X	return((SYMBTABEL *) NULL);
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** add_trans_info():\n");
X    fprintf(debugfile, "[symb]       params: process = %d, transactions = %d\n",
X	process, transactions);
X    fprintf(debugfile, "[symb]       adding process pointer and internal names\n");
X#endif /* SYMBDEBUG /**/
X    for(actions=process->info.process.FirstTrans; actions; actions=actions->info.trans.NextTrans) {
X        actions->info.trans.Process = process;
X        /* determine transaction internal names (used for naming) */
X        hstr = actions->info.trans.ptiname;
X        *hstr = '\0';
X        strncat(hstr, process->name, (int) (MAXIDLEN - 2) / 2);
X        strcat(hstr, "_");
X        strncat(hstr, actions->name, (int) (MAXIDLEN - 2) / 2);
X        hstr[MAXIDLEN - 2] = '\0';
X        hstr = actions->info.trans.uptiname;
X        strcpy(hstr, actions->info.trans.ptiname);
X        for(; *hstr; ++hstr)
X	    *hstr = toupper(*hstr);
X#ifdef SYMBDEBUG
X	fprintf(debugfile, "[symb]       transaction: \"%s\":\n", actions->name);
X	fprintf(debugfile, "[symb]          ptiname = %s, uptiname = %s\n",
X	    actions->info.trans.ptiname, actions->info.trans.uptiname);
X#endif /* SYMBDEBUG /**/
X	*convert_buffer = 0;
X	convert_buffer = convert_ds_to_string(convert_buffer, actions->info.trans.ReturnType);
X        trextstr = Strcatmany(trextstr, 5, "extern ", convert_buffer, "call_", 
X	    actions->info.trans.ptiname, "();\n");
X    } /* for */
X    return(process);
X} /* add_trans_info */
X
X/******************************************************************************
X * add_transaction_info()                                                     *
X *                                                                            *
X * Sets the returntype and the pointer to the parameter list of a transaction *
X * symbol table element.                                                      *
X *                                                                            *
X * Return values: 'symbol' upon success / NULL upon error                     *
X ******************************************************************************/
XSYMBTABEL *
Xadd_transaction_info(symbol, type, first_param)
XSYMBTABEL *symbol, 
X          *first_param;
XDS_ATTR   *type;
X{
X    if (errflag || !symbol) /* error handling */
X	return((SYMBTABEL *) NULL);
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** add_transaction_info():\n");
X    fprintf(debugfile, "[symb]       params: symbol = %d, type = %s, first_param = %d\n",
X	symbol, type, first_param);
X#endif /* SYMBDEBUG /**/
X    symbol->info.trans.ReturnType = type;
X    symbol->info.trans.FirstParam = first_param;
X    return(symbol);
X} /* add_transaction_info */
X
X/******************************************************************************
X * add_transaction_label()                                                    *
X *                                                                            *
X * Sets the label number used for generating the end label of the transaction.*
X *                                                                            *
X * Return values: 'symbol' upon success / NULL upon error                     *
X ******************************************************************************/
XSYMBTABEL *
Xadd_transaction_label(symbol)
XSYMBTABEL *symbol;
X{
X    if (errflag || !symbol) /* error handling */
X	return((SYMBTABEL *) NULL);
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** add_transaction_label():\n");
X    fprintf(debugfile, "[symb]       params: symbol = %d\n", symbol);
X#endif /* SYMBDEBUG /**/
X    symbol->info.trans.labnum = ++translabel;
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb]       labnum = %d\n", translabel);
X#endif /* SYMBDEBUG /**/
X    return(symbol);
X} /* add_transaction_info */
X
X/******************************************************************************
X * add_parm_type()                                                            *
X *                                                                            *
X * Sets the type of a parameter in a parameter symbol table entry.            *
X *                                                                            *
X * Return values: 'symbol' upon success / NULL upon error                     *
X ******************************************************************************/
XSYMBTABEL *
Xadd_parm_type(type, symbol)
XDS_ATTR   *type;
XSYMBTABEL *symbol;
X{
X    register SYMBTABEL *ptr;
X
X    if (errflag || !symbol) /* error handling */
X	return((SYMBTABEL *) NULL);
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** add_parm_type(): params: type = %s, symbol = %d\n",
X	type, symbol);
X    *convert_buffer = 0;
X    convert_buffer = convert_ds_to_string(convert_buffer, type);
X    fprintf(debugfile, "[symb]       setting data type of \"%s\" to \"%s\"\n",
X	symbol->name, convert_buffer);
X#endif /* SYMBDEBUG /**/
X    symbol->info.varorpar.DataType = type;
X    return(symbol);
X} /* add_parm_type */
X
X/******************************************************************************
X * link_parameters()                                                          *
X *                                                                            *
X * Concatenates the parameter lists specified by 'symbol' and 'next'. The     *
X * pointer to the resulting list is returned.                                 *
X *                                                                            *
X * Return values: 'symbol' upon success / NULL upon error                     *
X ******************************************************************************/
XSYMBTABEL *
Xlink_parameters(symbol, next)
XSYMBTABEL *symbol, *next;
X{
X    register SYMBTABEL *ptr;
X
X    if (errflag || !symbol) /* error handling */
X	return((SYMBTABEL *) NULL);
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** link_parameters():\n");
X    fprintf(debugfile, "[symb]       params: symbol = %d, next = %d\n",
X	symbol,next);
X#endif /* SYMBDEBUG /**/
X    if (symbol->type != VARORPAR)
X	Panic("argument for link_parameters() is no parameter");
X    for(ptr=symbol; ptr->info.varorpar.NextParam; ptr=ptr->info.varorpar.NextParam)
X	;
X#ifdef SYMBDEBUG
X    fprintf(debugfile,"[symb]       linking \"%s\" (%d) to \"%s\" (%d)\n",
X	ptr->name, ptr, next->name, next);
X#endif /* SYMBDEBUG /**/
X    ptr->info.varorpar.NextParam = next;
X    return(symbol);
X} /* link_parameters */
X
X/******************************************************************************
X * link_transactions()                                                        *
X *                                                                            *
X * Concatenates the transaction lists specified by 'symbol' and 'next'. The   *
X * pointer to the resulting list is returned.                                 *
X *                                                                            *
X * Return values: 'symbol' upon success / NULL upon error                     *
X ******************************************************************************/
XSYMBTABEL *
Xlink_transactions(symbol, next)
XSYMBTABEL *symbol, *next;
X{
X    register SYMBTABEL *ptr;
X
X    if (errflag || !symbol) /* error handling */
X	return((SYMBTABEL *) NULL);
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** link_transactions():\n");
X    fprintf(debugfile, "[symb]       params: symbol = %d, next = %d\n",
X	symbol, next);
X#endif /* SYMBDEBUG /**/
X    if (symbol->type != TRANSACTION)
X	Panic("argument for link_transactions() is no transaction");
X    for(ptr=symbol; ptr->info.trans.NextTrans; ptr=ptr->info.trans.NextTrans)
X	;
X#ifdef SYMBDEBUG
X    fprintf(debugfile,"[symb]       linking \"%s\" (%d) to \"%s\" (%d)\n", 
X	ptr->name, ptr, next->name, next);
X#endif /* SYMBDEBUG /**/
X    ptr->info.trans.NextTrans = next;
X    return(symbol);
X} /* link_transactions */
X
X/******************************************************************************
X * reenter_process_comps                                                      *
X *                                                                            *
X * Rechains parameters and transactions of process specified by 'proc' in     *
X * the symbol table.                                                          *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xvoid
Xreenter_process_comps(proc)
XSYMBTABEL *proc;
X{
X    int hashid;
X    register SYMBTABEL *ptr;
X
X    if (errflag || !proc) /* error handling! */
X        return;
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** reenter_process_comps(): params: proc = %d\n",
X	proc);
X#endif /* SYMBDEBUG /**/
X    /*
X     * reenter process parameters
X     */
X    for(ptr = proc->info.process.FirstParam; ptr; ptr = ptr->info.varorpar.NextParam) {
X#ifdef SYMBDEBUG
X	fprintf(debugfile, "[symb]       reentering parameter \"%s\"\n",
X	    ptr->name);
X#endif /* SYMBDEBUG /**/
X	/* insert new element in PST list */
X	ptr->PstNext           = symbtab.PstTab[blknum];
X	symbtab.PstTab[blknum] = ptr;
X	/* insert new element in ID list */
X	hashid = hash(ptr->name);
X	ptr->IdNext           = symbtab.IdTab[hashid];
X	symbtab.IdTab[hashid] = ptr;
X    }
X    /*
X     * reenter process transactions
X     */
X    for(ptr = proc->info.process.FirstTrans; ptr; ptr = ptr->info.trans.NextTrans) {
X#ifdef SYMBDEBUG
X	fprintf(debugfile, "[symb]       reentering transaction \"%s\"\n",
X	    ptr->name);
X#endif /* SYMBDEBUG /**/
X	/* insert new element in PST list */
X	ptr->PstNext           = symbtab.PstTab[blknum];
X	symbtab.PstTab[blknum] = ptr;
X	/* insert new element in ID list */
X	hashid = hash(ptr->name);
X	ptr->IdNext           = symbtab.IdTab[hashid];
X	symbtab.IdTab[hashid] = ptr;
X    }
X} /* reenter_process_comps */
X
X/******************************************************************************
X * reenter_transaction_params()                                               *
X *                                                                            *
X * Rechains parameters and transactions of process specified by 'proc' in     *
X * the symbol table.                                                          *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xvoid
Xreenter_transaction_params(trans)
XSYMBTABEL *trans;
X{
X    int hashid;
X    register SYMBTABEL *ptr;
X
X    if (errflag || !trans) /* error handling! */
X        return;
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** reenter_transaction_params(): params: trans = %d\n",
X	trans);
X#endif /* SYMBDEBUG /**/
X    for(ptr = trans->info.trans.FirstParam; ptr; ptr = ptr->info.varorpar.NextParam) {
X#ifdef SYMBDEBUG
X	fprintf(debugfile, "[symb]       reentering transaction parameter \"%s\"\n",
X	    ptr->name);
X#endif /* SYMBDEBUG /**/
X	/* insert new element in PST list */
X	ptr->PstNext           = symbtab.PstTab[blknum];
X	symbtab.PstTab[blknum] = ptr;
X	/* insert new element in ID list */
X	hashid = hash(ptr->name);
X	ptr->IdNext           = symbtab.IdTab[hashid];
X	symbtab.IdTab[hashid] = ptr;
X    }
X} /* reenter_transaction_params */
X
X/******************************************************************************
X * is_process()                                                               *
X *                                                                            *
X * Checks and display an error message if 'Elem' was not declared as a        *
X * process.                                                                   *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xvoid
Xis_process(Elem)
XSYMBTABEL *Elem;
X{
X
X    if (errflag || (!Elem))
X	return;
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** is_process(): params: Elem = %d\n",
X	Elem);
X    fprintf(debugfile, "[symb]       checking if \"%s\" is a PROCESSDECL\n",
X	Elem->name);
X#endif /* SYMBDEBUG /**/
X    if (Elem->type != PROCESSDECL) {
X	strcpy(yytext, Elem->name);
X	Errno = ENOTDEFINED;
X	Error(NULL, "");
X	return;
X    }
X} /* is_process */
X
X/******************************************************************************
X * get_process()                                                              *
X *                                                                            *
X * Determines to a transaction name the corresponding process name.           *
X *                                                                            *
X * Return values: pointer to transaction upon success / NULL upon error       *
X ******************************************************************************/
XSYMBTABEL * 
Xget_process(transaction)
XSYMBTABEL *transaction;
X{
X    int decls = 0;
X    SYMBTABEL *symbol, *actions, *result;
X
X    if (errflag || (!transaction))
X	return(NULL);
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** get_process():\n");
X    fprintf(debugfile, "[symb]       searching corresponding entry for \"%s\"\n",
X	transaction->name);
X#endif /* SYMBDEBUG /**/
X    for(symbol = symbtab.PstTab[0]; symbol; symbol = symbol->PstNext) {
X	if (symbol->type == PROCESSDECL) {
X#ifdef SYMBDEBUG
X	    fprintf(debugfile, "[symb]       checking process \"%s\"\n",
X		symbol->name);
X#endif /* SYMBDEBUG /**/
X            for(actions = symbol->info.process.FirstTrans; actions; 
X				actions = actions->info.trans.NextTrans) {
X		if (!strcmp(transaction->name, actions->name)) {
X#ifdef SYMBDEBUG
X	            fputs("[symb]       found!\n", debugfile);
X#endif /* SYMBDEBUG /**/
X		    if (!decls++)
X			result = actions;
X		}
X	    }
X	}
X    }
X    if (!decls) {
X	strcpy(yytext, transaction->name);
X	Errno = ENOTDEFINED;
X	Error(NULL, "");
X	return(NULL);
X    }
X    if (decls > 1) {
X	fprintf(stderr, "Warning: transaction \"%s\" is defined in more than one process!\n",
X	    transaction->name);
X	fprintf(stderr, "         Please check if generated call matches process \"%s\"!\n",
X	    result->name);
X    }
X    return(result);
X} /* get_process */
X
X/******************************************************************************
X * check_transaction()                                                        *
X *                                                                            *
X * Checks the name of a transaction if this name is defined and unmistakable. *
X *                                                                            *
X * Return values: pointer to transaction upon success / NULL upon error       *
X ******************************************************************************/
XSYMBTABEL *
Xcheck_transaction(transaction)
XSYMBTABEL *transaction;
X{
X    int decls = 0;
X    SYMBTABEL *symbol, *actions, *result;
X
X    if (errflag || (!transaction))
X	return(NULL);
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** check_transaction():\n");
X    fprintf(debugfile, "[symb]       searching corresponding entry for \"%s\"\n",
X	transaction->name);
X#endif /* SYMBDEBUG /**/
X    for(symbol = symbtab.PstTab[0]; symbol; symbol = symbol->PstNext) {
X	if (symbol->type == PROCESSDECL) {
X#ifdef SYMBDEBUG
X	    fprintf(debugfile, "[symb]       checking process \"%s\"\n",
X		symbol->name);
X#endif /* SYMBDEBUG /**/
X            for(actions = symbol->info.process.FirstTrans; actions; 
X				actions = actions->info.trans.NextTrans) {
X		if (!strcmp(transaction->name, actions->name)) {
X#ifdef SYMBDEBUG
X	            fputs("[symb]       found!\n", debugfile);
X#endif /* SYMBDEBUG /**/
X		    if (!decls++)
X			result = actions;
X		}
X	    }
X	}
X    }
X    if (!decls) {
X	strcpy(yytext, transaction->name);
X	Errno = ENOTDEFINED;
X	Error(NULL, "");
X	return(NULL);
X    }
X    if (decls > 1) {
X	fprintf(stderr, "Warning: Transaction \"%s\" is defined in more than one process!\n",
X	    transaction->name);
X	fprintf(stderr, "         Please check if accept matches process \"%s\"!\n",
X	    result->name);
X    }
X    return(result);
X} /* check_transaction */
X
X/******************************************************************************
X * reenter_transactions()                                                     *
X *                                                                            *
X * Rechains transactions of idents in symbol table.       		      *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xvoid
Xreenter_transactions(idents)
XIDENTCHAIN *idents;
X{
X    int hashid;
X    IDENTCHAIN *ptr;
X    SYMBTABEL *symbolptr, *hptr;
X
X    if (errflag || (!idents))
X	return;
X#ifdef SYMBDEBUG 
X    fprintf(debugfile, "[symb] ***** reenter_transactions():\n");
X#endif /* SYMBDEBUG /**/
X
X    /* DIRTY PROGRAMMING! */
X
X/*
X    for(ptr=idents; ptr; ptr = ptr->next) {
X        if (ptr->symbol->type == PROCESSVAR) {
X#ifdef SYMBDEBUG 
X	    fprintf(debugfile, "[symb]       ptr->symbol->name = %s\n",
X		ptr->symbol->name);
X#endif /* SYMBDEBUG /**/
X/*
X	    symbolptr = ptr->symbol->info.varorpar.DataType->info.process;
X	    for (hptr = symbolptr->info.process.FirstTrans; hptr; 
X					    hptr=hptr->info.trans.NextTrans) {
X		if (!(lookup_symbtabel(hptr->name))) {
X		    /* insert new element in PST list */
X/*
X		    hptr->PstNext          = symbtab.PstTab[blknum];
X		    symbtab.PstTab[blknum] = hptr;
X		    /* insert new element in ID list */
X/*
X		    hashid = hash(hptr->name);
X		    hptr->IdNext          = symbtab.IdTab[hashid];
X		    symbtab.IdTab[hashid] = hptr;
X		}
X	    }
X        }
X    }
X*/
X} /* reenter_transactions */
END_OF_FILE
if test 29410 -ne `wc -c <'dcc/symb_process.c'`; then
    echo shar: \"'dcc/symb_process.c'\" unpacked with wrong size!
fi
# end of 'dcc/symb_process.c'
fi
if test -f 'dcc/xdrfile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcc/xdrfile.c'\"
else
echo shar: Extracting \"'dcc/xdrfile.c'\" \(26041 characters\)
sed "s/^X//" >'dcc/xdrfile.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                            x d r f i l e . c                            *
X *                                                                         *
X *                            Package : Compiler                           *
X *                            Version : 1.0                                *
X *                       CreationDate : 25.09.91                           *
X *                         LastUpDate : 05.11.91                           *
X *                                                                         *
X *                  The routine to generate the xdr file.                  *
X *                                                                         *
X *               Copyright (C) 1991-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#if defined(HETEROGENEOUS) || defined(CHECK_XDR)
X
X#include <stdio.h>
X#include <sys/types.h>
X#ifndef CHECK_XDR
X# include <rpc/rpc.h>
X#endif
X#include <string.h>
X#include "config.h"
X#include "extern.h"
X#include "functions.h"
X#include "ipc.h"
X#include "dcc.h"
X#include "com_Errno.h"
X
X/******************************************************************************
X * print_dcc_buf_size_warning()                                               *
X *                                                                            *
X * Displays a warning about the size of the encode/decode buffer.             *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xstatic int
Xprint_dcc_buf_size_warning()
X{
X    if (!encode_warning) {
X        fputs("Warning: Pointers are used within interprocess communication!\n", stderr);
X        fputs("         Because the size of the buffer to store the encoded data\n", stderr);
X        fputs("         can not be predicted at compilation time correctly, you\n", stderr);
X        fputs("         may get problems during data conversion later.\n", stderr);
X        fputs("         Better use option '-f <bufsize>' to specify a sufficent value!\n", stderr);
X	encode_warning = TRUE;
X	yynwarns++;
X    }
X} /* print_dcc_buf_size_warning */
X
X/******************************************************************************
X * determine_xdr_routine()                                                    *
X *                                                                            *
X *    [signed, unsigned] [char, short, int, long]                             *
X *                       float, double                                        *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xstatic int
Xdetermine_xdr_routine(spec_qual_list, xdr_routine, type)
XSQL_ATTR *spec_qual_list;
Xchar **xdr_routine, **type;
X{
X    register int i;
X    char *name;
X    short elem_flag     = FALSE,
X          signed_flag   = FALSE,
X          unsigned_flag = FALSE;
X    SYMBTABEL *symbol;
X
X#ifdef XDRDEBUG
X    fputs("[code] ***** determine_xdr_routine():\n", debugfile);
X#endif /* XDRDEBUG /**/
X    for(; spec_qual_list; spec_qual_list = spec_qual_list->sq_list) {
X	switch(spec_qual_list->type) {
X	case SQL_ATTR_SPECIFIER:
X	    switch(spec_qual_list->info.type_specifier->type) {
X	    case TS_ATTR_VOID:
X		Errno = EILLVOID;
X		return(ERROR);
X		/* break; */
X	    case TS_ATTR_CHAR:
X		if (elem_flag) {
X		    Errno = EILLCHAR;
X		    return(ERROR);
X		}
X		*xdr_routine = (unsigned_flag) ? "u_char" : "char";
X		*type        = (unsigned_flag) ? "unsigned char" : "char";
X		elem_flag = TRUE;
X		break;
X	    case TS_ATTR_SHORT:
X		if (elem_flag) {
X		    Errno = EILLSHORT;
X		    return(ERROR);
X		}
X		*xdr_routine = (unsigned_flag) ? "u_short" : "short";
X		*type        = (unsigned_flag) ? "unsigned short" : "short";
X		elem_flag = TRUE;
X		break;
X	    case TS_ATTR_INT:
X		if (elem_flag) {
X		    Errno = EILLINT;
X		    return(ERROR);
X		}
X		*xdr_routine = (unsigned_flag) ? "u_int" : "int";
X		*type        = (unsigned_flag) ? "unsigned int" : "int";
X		elem_flag = TRUE;
X		break;
X	    case TS_ATTR_LONG:
X		if (elem_flag) {
X		    Errno = EILLLONG;
X		    return(ERROR);
X		}
X		*xdr_routine = (unsigned_flag) ? "u_long" : "long";
X		*type        = (unsigned_flag) ? "unsigned long" : "long";
X		elem_flag = TRUE;
X		break;
X	    case TS_ATTR_FLOAT:
X		if (elem_flag) {
X		    Errno = EILLFLOAT;
X		    return(ERROR);
X		}
X		*xdr_routine = *type = "float";
X		elem_flag = TRUE;
X		break;
X	    case TS_ATTR_DOUBLE:
X		if (elem_flag) {
X		    Errno = EILLDOUBLE;
X		    return(ERROR);
X		}
X		*xdr_routine = *type = "double";
X		elem_flag = TRUE;
X		break;
X	    case TS_ATTR_PROCESS:
X		if (elem_flag) {
X		    Errno = EILLPROCESS;
X		    return(ERROR);
X		}
X		*xdr_routine = *type = "PROCESSDESCR";
X		elem_flag = TRUE;
X		break;
X	    case TS_ATTR_SIGNED:
X		if (unsigned_flag) {
X		    Errno = EILLSIGNED;
X		    return(ERROR);
X		}
X		signed_flag = TRUE;
X		break;
X	    case TS_ATTR_UNSIGNED:
X		if (signed_flag) {
X		    Errno = EILLUNSIGNED;
X		    return(ERROR);
X		}
X		unsigned_flag = TRUE;
X		break;
X	    case TS_ATTR_ENUM:
X		Errno = EILLENUM;
X		return(ERROR);
X		break;
X	    case TS_ATTR_STRUCT:
X		if (unsigned_flag) {
X		    Errno = EILLSIGNED;
X		    return(ERROR);
X		}
X		if (signed_flag) {
X		    Errno = EILLUNSIGNED;
X		    return(ERROR);
X		}
X	        name = spec_qual_list->info.type_specifier->info.structinfo->tag->name;
X	        *xdr_routine = name;
X		*type = (char *) Malloc(strlen("struct " + strlen(name) + 1));
X		sprintf(*type, "struct %s", name);
X		break;
X	    case TS_ATTR_TYPENAME:
X	        *xdr_routine = *type = spec_qual_list->info.type_specifier->info.typedefname->name;
X		break;
X	    default:
X	        Panic("illegal TS_ATTR type in determine_xdr_routine()");
X	    } /* switch */
X	    break;
X	case SQL_ATTR_QUALIFIER:
X	    if (spec_qual_list->info.type_qualifier->type == TQ_ATTR_CONST)
X	        Errno = EILLCONST;
X	    else
X	        Errno = EILLVOLATILE;
X	    return(ERROR);
X	    break;
X	default:
X	    Panic("illegal SQL_ATTR type in determine_xdr_routine()");
X	} /* switch */
X    }
X    return(OK);
X} /* determine_xdr_routine */
X
X/******************************************************************************
X * determine_typedef_xdr_routine()                                            *
X *                                                                            *
X *    [signed, unsigned] [char, short, int, long]                             *
X *                       float, double                                        *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xstatic int
Xdetermine_typedef_xdr_routine(ds_attr, xdr_routine, type)
XDS_ATTR *ds_attr;	/* declaration specifiers attribute */
Xchar **xdr_routine, **type;
X{
X    register int i;
X    char *name;
X    short elem_flag     = FALSE,
X          signed_flag   = FALSE,
X          unsigned_flag = FALSE;
X    SYMBTABEL *symbol;
X
X#ifdef XDRDEBUG
X    fputs("[code] ***** determine_typedef_xdr_routine():\n", debugfile);
X#endif /* XDRDEBUG /**/
X
X    for(; ds_attr; ds_attr = ds_attr->ds) {
X
X	/* check if there is a storage class specifier in the type definition.
X	 * auto, register, static, extern or typedef are not allowed here! 
X	 */
X	if (ds_attr->scs) {
X	    switch(ds_attr->scs->type) {
X	    case SCS_ATTR_AUTO:
X		Errno = EILLAUTO;
X		break;
X	    case SCS_ATTR_REGISTER:
X		Errno = EILLREGISTER;
X		break;
X	    case SCS_ATTR_STATIC:
X		Errno = EILLSTATIC;
X		break;
X	    case SCS_ATTR_EXTERN:
X		Errno = EILLEXTERN;
X		break;
X	    case SCS_ATTR_TYPEDEF:
X		Errno = EILLTYPEDEF;
X		break;
X    	    default:
X        	Panic("illegal SCS_ATTR type in determine_typedef_xdr_routine()");
X    	    } /* switch */
X	    return(ERROR);
X	}
X
X	/* check if there is a type qualifier in the type definition.
X	 * const or volatile are not allowed here! 
X	 */
X	if (ds_attr->tq) {
X	    switch(ds_attr->tq->type) {
X	    case TQ_ATTR_CONST:
X		Errno = EILLCONST2;
X		break;
X	    case TQ_ATTR_VOLATILE:
X		Errno = EILLVOLATILE2;
X		break;
X	    default:
X	       	Panic("illegal TQ_ATTR type in determine_typedef_xdr_routine()");
X	    } /* switch */
X	    return(ERROR);
X	}
X
X	switch(ds_attr->ts->type) {
X	case TS_ATTR_VOID:
X	    Errno = EILLVOID2;
X	    return(ERROR);
X	    /* break; */
X	case TS_ATTR_CHAR:
X	    if (elem_flag) {
X	        Errno = EILLCHAR;
X	        return(ERROR);
X	    }
X	    *xdr_routine = (unsigned_flag) ? "u_char" : "char";
X	    *type        = (unsigned_flag) ? "unsigned char" : "char";
X	    elem_flag = TRUE;
X	    break;
X        case TS_ATTR_SHORT:
X	    if (elem_flag) {
X	        Errno = EILLSHORT;
X	        return(ERROR);
X	    }
X	    *xdr_routine = (unsigned_flag) ? "u_short" : "short";
X	    *type        = (unsigned_flag) ? "unsigned short" : "short";
X	    elem_flag = TRUE;
X	    break;
X        case TS_ATTR_INT:
X	    if (elem_flag) {
X	        Errno = EILLINT;
X	        return(ERROR);
X	    }
X	    *xdr_routine = (unsigned_flag) ? "u_int" : "int";
X	    *type        = (unsigned_flag) ? "unsigned int" : "int";
X	    elem_flag = TRUE;
X	    break;
X        case TS_ATTR_LONG:
X	    if (elem_flag) {
X	        Errno = EILLLONG;
X	        return(ERROR);
X	    }
X	    *xdr_routine = (unsigned_flag) ? "u_long" : "long";
X	    *type        = (unsigned_flag) ? "unsigned long" : "long";
X	    elem_flag = TRUE;
X	    break;
X        case TS_ATTR_FLOAT:
X	    if (elem_flag) {
X	        Errno = EILLFLOAT;
X	        return(ERROR);
X	    }
X	    *xdr_routine = *type = "float";
X	    elem_flag = TRUE;
X	    break;
X        case TS_ATTR_DOUBLE:
X	    if (elem_flag) {
X	        Errno = EILLDOUBLE;
X	        return(ERROR);
X	    }
X	    *xdr_routine = *type = "double";
X	    elem_flag = TRUE;
X	    break;
X        case TS_ATTR_PROCESS:
X	    if (elem_flag) {
X	        Errno = EILLPROCESS;
X	        return(ERROR);
X	    }
X	    *xdr_routine = *type = "PROCESSDESCR";
X	    elem_flag = TRUE;
X	    break;
X        case TS_ATTR_SIGNED:
X	   if (unsigned_flag) {
X		Errno = EILLSIGNED;
X	        return(ERROR);
X	    }
X	    signed_flag = TRUE;
X	    break;
X        case TS_ATTR_UNSIGNED:
X	    if (signed_flag) {
X		Errno = EILLUNSIGNED;
X	        return(ERROR);
X	    }
X	    unsigned_flag = TRUE;
X	    break;
X        case TS_ATTR_ENUM:
X	    Errno = EILLENUM2;
X	    return(ERROR);
X	    break;
X        case TS_ATTR_STRUCT:
X	    if (unsigned_flag) {
X	        Errno = EILLSIGNED;
X	        return(ERROR);
X	    }
X	    if (signed_flag) {
X	        Errno = EILLUNSIGNED;
X	        return(ERROR);
X	    }
X            if (!ds_attr->ts->info.structinfo->tag) {
X		Errno = ETSTRUCTTAG;
X		return(ERROR);
X	    }
X            name = ds_attr->ts->info.structinfo->tag->name;
X	    *xdr_routine = name;
X	    *type = (char *) Malloc(strlen("struct " + strlen(name) + 1));
X	    sprintf(*type, "struct %s", name);
X	    break;
X        case TS_ATTR_TYPENAME:
X            *xdr_routine = *type = ds_attr->ts->info.typedefname->name;
X	    break;
X        default:
X            Panic("illegal TS_ATTR type in determine_typedef_xdr_routine()");
X        } /* switch */
X
X    } /* for(ds_attr) */
X    return(OK);
X} /* determine_typedef_xdr_routine */
X
X/******************************************************************************
X * build_xdrfile()                                                            *
X *                                                                            *
X * Valid elementar types are:                                                 *
X *                                                                            *
X *    [signed, unsigned] [char, short, int, long]                             *
X *                       float, double                                        *
X *                                                                            *
X * Return values: always OK for success                                       *
X ******************************************************************************/
Xint
Xbuild_xdrfile()
X{
X    int i, length, signed_flag, unsigned_flag, pointer_flag;
X    char *xdr_name, *type;
X    char *hstr;
X    register SYMBTABEL *sptr, *actions, *params;
X    register struct struct_type_list *stlptr;
X    register struct include_list *inclptr;
X    ST_ATTR *st_attr;
X    STL_ATTR *stl_attr;
X    SD_ATTR *sd_attr;
X    SDL_ATTR *sdl_attr;
X    D_ATTR *d_attr;
X    DD_ATTR *dd_attr, *dd_attr2;
X    DS_ATTR *ds_attr, *ds_attr2;
X
X#ifdef XDRDEBUG
X    fputs("[code] ***** build_xdrfile():\n", debugfile);
X    display_struct_type_list();
X#endif /* XDRDEBUG /**/
X    if (infoflag) {
X	printf("%s building the xdrfile\n", infoprefix);
X	fflush(stdout);
X    }
X
X    /* 
X     * create file 
X     */
X    (void) strcpy(xdrfilename, filenameprefix);
X    length = MAXFILENAMELEN - strlen(XDRFILEEXT);
X    if (strlen(filenameprefix) <= length)
X        (void) strcat(xdrfilename, XDRFILEEXT);
X    else
X        (void) strcpy(&xdrfilename[length], XDRFILEEXT);
X    if (!(xdrfile = fopen(xdrfilename, "w"))) {
X        fprintf(stderr,"Error: impossible to open file for xdr routines '%s'\n",
X            xdrfilename);
X        exit(EXIT_FOPEN);
X    }
X    /* 
X     * write header to file 
X     */
X    fprintf(xdrfile, "/* %s */\n\n", xdrfilename);
X    fputs("/*\n", xdrfile);
X    for(i = 0; *headerstr[i]; ++i)
X        fprintf(xdrfile, " * %s\n", headerstr[i]);
X    fputs(" */\n\n", xdrfile);
X    fprintf(xdrfile, "#include \"%s\"\n\n", inclfilename);
X    xdrflag = 1;
X    /* create routines for structure and type definitions used as process
X     * parameter, transaction parameter or transaction result types
X     */
X    if (first_structtype) {
X	for(stlptr = first_structtype; stlptr; stlptr = stlptr->next) {
X
X	    switch(stlptr->symbol->type) {
X
X	    case TYPEDEFNAME:
X		if (!stlptr->symbol->info.typedefname.BuildXDRRoutine)
X		    continue;
X
X		stlptr->symbol->info.typedefname.BuildXDRRoutine = FALSE;
X
X                fprintf(xdrfile, "\nbool_t\n");
X                fprintf(xdrfile, "xdr_%s(xdrs, objp)\n", stlptr->symbol->name);
X                fprintf(xdrfile, "XDR *xdrs;\n%s *objp;\n{\n",
X		    stlptr->symbol->name);
X
X		ds_attr = stlptr->symbol->info.typedefname.decl_spec;
X		if (ds_attr->ts || ds_attr->tq || 
X		       (ds_attr->scs && ds_attr->scs->type != SCS_ATTR_TYPEDEF))
X		    Panic("no \"typedef\" in type definition");
X		if (!ds_attr->ds) {
X		    Errno = EILLTYPEDEF;
X	    	    strcpy(yytext, stlptr->symbol->name);
X	    	    Error(stlptr->symbol->info.typedefname.ErrPos, "");	    
X		    continue;
X		}
X
X		if (determine_typedef_xdr_routine(ds_attr->ds, &xdr_name, &type)) {
X	    	    strcpy(yytext, stlptr->symbol->name);
X	    	    Error(stlptr->symbol->info.typedefname.ErrPos, "");	    
X		    continue;
X		}
X	
X		if (stlptr->symbol->info.typedefname.IsPointer) {
X		    if (determine_dcc_buf_size && !encode_warning)
X			print_dcc_buf_size_warning();
X		    fprintf(xdrfile, "if (!xdr_pointer(xdrs, (char **) objp, sizeof(%s), xdr_%s", 
X			type, xdr_name);
X		} else 
X                    fprintf(xdrfile, "if (!xdr_%s(xdrs, objp", xdr_name);
X                fprintf(xdrfile, ")) {\nreturn (FALSE);\n}\n");
X		break;
X
X	    case STRUCTDECL:
X		if (!stlptr->symbol->info.structdecl.BuildXDRRoutine)
X		    continue;
X
X		stlptr->symbol->info.structdecl.BuildXDRRoutine = FALSE;
X
X                fprintf(xdrfile, "\nbool_t\n");
X                fprintf(xdrfile, "xdr_%s(xdrs, objp)\n", stlptr->symbol->name);
X                fprintf(xdrfile, "XDR *xdrs;\nstruct %s *objp;\n{\n",
X		    stlptr->symbol->name);
X
X		/* for each struct_declaration do */
X		for(stl_attr = stlptr->symbol->info.structdecl.StruDeclList;
X				       stl_attr; stl_attr = stl_attr->st_list) {
X
X		    /* get pointer to struct_declaration */
X		    st_attr = stl_attr->struct_decl;
X
X		    /* determine xdr routine and check for error */
X		    if (determine_xdr_routine(st_attr->spec_qual_list, &xdr_name, &type)) {
X	    		strcpy(yytext, stlptr->symbol->name);
X	    		Error(stlptr->symbol->info.structdecl.ErrPos, "");
X			continue;
X		    }
X
X		    /* for each struct_declarator do */
X		    for(sdl_attr = st_attr->struct_decl_list; sdl_attr;
X						 sdl_attr = sdl_attr->sd_list) {
X
X			/* get pointer to struct_declarator */
X			sd_attr = sdl_attr->struct_declarator;
X
X			/* bitfields are not allowed */
X			if (sd_attr->const_expr) {
X			    Errno = EILLBITFIELD;
X	    		    strcpy(yytext, stlptr->symbol->name);
X	    		    Error(stlptr->symbol->info.structdecl.ErrPos, "");
X			    continue;
X			}
X
X			/* get pointer to declarator */
X			d_attr = sd_attr->decl;
X
X			pointer_flag = FALSE;
X			/* only one pointer without type_qualifier is allowed */
X			if (d_attr->pointer) {
X			    switch(d_attr->pointer->type) {
X			    case P_ATTR_2:
X			        pointer_flag = TRUE;
X				break;
X			    case P_ATTR_1:
X			    case P_ATTR_3:
X			        Errno = EILLPOINTQUAL;
X	    		        strcpy(yytext, stlptr->symbol->name);
X	    		        Error(stlptr->symbol->info.structdecl.ErrPos, "");
X				continue;
X
X			    case P_ATTR_4:
X			        Errno = EMANYPOINTER;
X	    		        strcpy(yytext, stlptr->symbol->name);
X	    		        Error(stlptr->symbol->info.structdecl.ErrPos, "");
X				continue;
X			    default:
X				Panic("illegal P_ATTR type");
X			    } /* switch */
X			}
X
X			/* get pointer to direct_declarator */
X			dd_attr = d_attr->direct_decl;
X
X			switch(dd_attr->type) {
X			case DD_ATTR_IDENT:
X			    if (pointer_flag) {
X		    		if (determine_dcc_buf_size && !encode_warning)
X				    print_dcc_buf_size_warning();
X    				fprintf(xdrfile, "if (!xdr_pointer(xdrs, (char **) &objp->%s, sizeof(%s), xdr_%s",
X				    dd_attr->ident->name, type, xdr_name);
X			    } else {
X    				fprintf(xdrfile, "if (!xdr_%s(xdrs, &objp->%s",
X				    xdr_name, dd_attr->ident->name);
X			    }
X                	    fprintf(xdrfile, ")) {\nreturn (FALSE);\n}\n");
X			    break;
X			case DD_ATTR_BRACED:
X			    Errno = EILLBRACES;
X	    		    strcpy(yytext, stlptr->symbol->name);
X	    		    Error(stlptr->symbol->info.structdecl.ErrPos, "");
X			    continue;
X			    /* break; */
X			case DD_ATTR_FUNC:
X			    Errno = EILLFUNCTION;
X	    		    strcpy(yytext, stlptr->symbol->name);
X	    		    Error(stlptr->symbol->info.structdecl.ErrPos, "");
X			    continue;
X			    /* break; */
X			case DD_ATTR_ARRAY:
X			    if (pointer_flag) {
X			        Errno = EILLPOINTER;
X	    		        strcpy(yytext, stlptr->symbol->name);
X	    		        Error(stlptr->symbol->info.structdecl.ErrPos, "");
X			        continue;
X			    }
X			    if (!dd_attr->info.comp.spec_str) {
X			        Errno = EARRAYSIZE;
X	    		        strcpy(yytext, stlptr->symbol->name);
X	    		        Error(stlptr->symbol->info.structdecl.ErrPos, "");
X			        continue;
X			    }
X			    dd_attr2 = dd_attr->info.comp.direct_decl;
X			    switch(dd_attr2->type) {
X			    case DD_ATTR_IDENT:
X				fprintf(xdrfile, "if (!xdr_vector(xdrs, (char *) objp->%s, %s, sizeof(%s), xdr_%s)) {\n",
X				    dd_attr2->ident->name, dd_attr->info.comp.spec_str, 
X				    type, xdr_name);
X                	        fprintf(xdrfile, "return (FALSE);\n}\n");
X			        break;
X			    case DD_ATTR_BRACED:
X			        Errno = EILLARRBRACES;
X	    		        strcpy(yytext, stlptr->symbol->name);
X	    		        Error(stlptr->symbol->info.structdecl.ErrPos, "");
X			        continue;
X			        /* break; */
X			    case DD_ATTR_FUNC:
X			        Errno = EILLARRFUNCT;
X	    		        strcpy(yytext, stlptr->symbol->name);
X	    		        Error(stlptr->symbol->info.structdecl.ErrPos, "");
X			        continue;
X			        /* break; */
X			    case DD_ATTR_ARRAY:
X				Errno = EMULTIARRAY;
X	    		        strcpy(yytext, stlptr->symbol->name);
X	    		        Error(stlptr->symbol->info.structdecl.ErrPos, "");
X			        continue;
X				/* break; */
X	    		    default:
X				Panic("nor TYPEDEFNAME nor STRUCTDECL in struct_type_list");
X	    		    } /* switch(dd_attr2->type) */
X			    continue;
X			    /* break; */
X			} /* switch(dd_attr->type) */
X		    } /* for(sdl_attr) */
X		} /* for(stl_attr) */
X		break;
X	    default:
X		Panic("nor TYPEDEFNAME nor STRUCTDECL in struct_type_list");
X	    } /* switch(stlptr->symbol->type) */
X            fprintf(xdrfile, "return (TRUE);\n}\n");
X	    xdrextstr = Strcatmany(xdrextstr, 3, 
X	        "extern bool_t xdr_", stlptr->symbol->name, "();\n");
X	} /* for(stlptr) */
X    }
X    
X    /* create routines for process parameters, transaction parameters and
X     * transaction results
X     */
X    for(sptr = symbtab.PstTab[0]; sptr; sptr = sptr->PstNext) {
X        if (sptr->type != PROCESSDECL)
X            continue;
X
X        if (sptr->info.process.FirstParam || sptr->info.process.FirstTrans)
X            fprintf(xdrfile, "\n/*\n * process '%s'\n */\n", sptr->name);
X
X	/* process parameters */
X        if (sptr->info.process.FirstParam) {
X            fprintf(xdrfile, "\nbool_t\n");
X            fprintf(xdrfile, "xdr_%s%s(xdrs, objp)\n", 
X		sptr->info.process.upiname, POSTFIXSPECPAR);
X            fprintf(xdrfile, "XDR *xdrs;\n%s%s *objp;\n{\n",
X		sptr->info.process.upiname, POSTFIXSPECPAR);
X            for(params = sptr->info.process.FirstParam; params;
X                                     params = params->info.varorpar.NextParam) {
X		ds_attr2 = params->info.varorpar.DataType;
X		if (ds_attr2->ts && ds_attr2->ts->type == TS_ATTR_STRUCT)
X		    hstr = ds_attr2->ts->info.structinfo->tag->name;
X		else {
X                    *convert_buffer = 0;
X                    hstr = convert_buffer = convert_ds_to_string(convert_buffer, ds_attr2);
X		}
X                fprintf(xdrfile, "if (!xdr_%s(xdrs, &objp->%s)) {\n", hstr, params->name);
X                fprintf(xdrfile, "return (FALSE);\n}\n");
X            } /* for(params) */
X            fprintf(xdrfile, "return (TRUE);\n}\n");
X	    xdrextstr = Strcatmany(xdrextstr, 4, 
X		"extern bool_t xdr_", 
X		sptr->info.process.upiname, 
X		POSTFIXSPECPAR, 
X		"();\n");
X        }
X
X	/* process transactions */
X        for(actions = sptr->info.process.FirstTrans; actions;
X                                      actions = actions->info.trans.NextTrans) {
X
X	    /* transaction parameters */
X	    if (actions->info.trans.FirstParam) {
X                fprintf(xdrfile, "\nbool_t\n");
X                fprintf(xdrfile, "xdr_%s%s(xdrs, objp)\n", 
X		    actions->info.trans.uptiname, POSTFIXTRANSPAR);
X                fprintf(xdrfile, "XDR *xdrs;\n%s%s *objp;\n{\n",
X		    actions->info.trans.uptiname, POSTFIXTRANSPAR);
X		for(params = actions->info.trans.FirstParam; params;
X                                     params = params->info.varorpar.NextParam) {
X		    ds_attr2 = params->info.varorpar.DataType;
X		    if (ds_attr2->ts && ds_attr2->ts->type == TS_ATTR_STRUCT)
X                        hstr = ds_attr2->ts->info.structinfo->tag->name;
X                    else {
X                        *convert_buffer = 0;
X                        hstr = convert_buffer = convert_ds_to_string(convert_buffer, 
X		                ds_attr2);
X		    }
X                    fprintf(xdrfile, "if (!xdr_%s(xdrs, &objp->%s)) {\n", 
X		        hstr, params->name);
X                    fprintf(xdrfile, "return (FALSE);\n}\n");
X                } /* for(params) */
X                fprintf(xdrfile, "return (TRUE);\n}\n");
X	        xdrextstr = Strcatmany(xdrextstr, 4, 
X		    "extern bool_t xdr_", 
X		    actions->info.trans.uptiname, 
X		    POSTFIXTRANSPAR, 
X		    "();\n");
X	    }
X
X	    /* transaction result */
X            fprintf(xdrfile, "\nbool_t\n");
X            fprintf(xdrfile, "xdr_%s%s(xdrs, objp)\n", 
X		actions->info.trans.uptiname, POSTFIXTRANSRES);
X            fprintf(xdrfile, "XDR *xdrs;\n%s%s *objp;\n{\n",
X		actions->info.trans.uptiname, POSTFIXTRANSRES);
X	    ds_attr2 = actions->info.trans.ReturnType;
X	    if (ds_attr2->ts && ds_attr2->ts->type == TS_ATTR_STRUCT)
X                hstr = ds_attr2->ts->info.structinfo->tag->name;
X	    else {
X                *convert_buffer = 0;
X                hstr = convert_buffer = convert_ds_to_string(convert_buffer, ds_attr2);
X	    }
X            fprintf(xdrfile, "if (!xdr_%s(xdrs, &objp->result)) {\n", hstr);
X            fprintf(xdrfile, "return (FALSE);\n}\n");
X            fprintf(xdrfile, "if (!xdr_int(xdrs, &objp->Errno)) {\n");
X            fprintf(xdrfile, "return (FALSE);\n}\n");
X            fprintf(xdrfile, "if (!xdr_int(xdrs, &objp->errno)) {\n");
X            fprintf(xdrfile, "return (FALSE);\n}\n");
X            fprintf(xdrfile, "return (TRUE);\n}\n");
X	    xdrextstr = Strcatmany(xdrextstr, 4, 
X		"extern bool_t xdr_", 
X		actions->info.trans.uptiname, 
X		POSTFIXTRANSRES,
X		"();\n");
X
X        } /* for(actions) */
X
X    } /* for(sptr) */
X
X    return(OK);
X} /* build_xdrfile */
X
X#endif /* HETEROGENEOUS /**/
END_OF_FILE
if test 26041 -ne `wc -c <'dcc/xdrfile.c'`; then
    echo shar: \"'dcc/xdrfile.c'\" unpacked with wrong size!
fi
# end of 'dcc/xdrfile.c'
fi
echo shar: End of archive 14 \(of 18\).
cp /dev/null ark14isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
