Newsgroups: comp.sources.unix
From: pleierc@informatik.tu-muenchen.de (Christoph Pleier)
Subject: v27i182: distributed-c-2.1 - Distributed C Development Environment, V2.1, Part08/18
References: <1.756634932.28500@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: pleierc@informatik.tu-muenchen.de (Christoph Pleier)
Posting-Number: Volume 27, Issue 182
Archive-Name: distributed-c-2.1/part08

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 8 (of 18)."
# Contents:  config/symb_program.c dcc/code_create.c dcc/makefile.c
#   dcc/symb_debug.c examples/nullst/nullst.dc
#   examples/test/creation.dc include/dcc.h include/functions.h
# Wrapped by vixie@gw.home.vix.com on Thu Dec 23 00:12:00 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'config/symb_program.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/symb_program.c'\"
else
echo shar: Extracting \"'config/symb_program.c'\" \(10681 characters\)
sed "s/^X//" >'config/symb_program.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                       s y m b _ p r o g r a m . c                       *
X *                                                                         *
X *                            Package : Configuration Files Parsers        *
X *                            Version : 1.0                                *
X *                       CreationDate : 26.02.92                           *
X *                         LastUpDate : 27.02.92                           *
X *                                                                         *
X * All routines needed to manage the symbol table during parsing of        *
X * program configuration files.                                            *
X *                                                                         *
X *               Copyright (C) 1992-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include "cfgparsers.h"
X
X/******************************************************************************
X * generate_fsspec_info()                                                     *
X *                                                                            *
X * Generates and initializes a accessed filesystem info.                      *
X *                                                                            *
X * Return values: pointer to new element upon success / NULL upon error       *
X ******************************************************************************/
XFSSPECINFO *
Xgenerate_fsspec_info(fs_symbol, freq, quant)
XSYMBTABEL *fs_symbol;
Xfloat freq, quant;
X{
X    register FSSPECINFO *ptr;
X
X    /* check type */
X    if (fs_symbol->type != S_FIXED_DISK) {
X	printf("Error: line %d at \"%s\": \"%s\" is not a fixed disk\n",
X	    yylineno, yytext, fs_symbol->name);
X	exit(ERROR);
X    }
X
X    ptr = (FSSPECINFO *) Malloc(sizeof(FSSPECINFO));
X    ptr->filesys   = fs_symbol;
X    ptr->frequency = freq;
X    ptr->quantity  = quant;
X    ptr->next      = NULL;
X
X    return(ptr);
X} /* generate_fsspec_info */
X
X/******************************************************************************
X * chain_fsspec_infos()                                                       *
X *                                                                            *
X * Chains accessed filesystems info 'accfs2' to the end of info 'accfs1'.     *
X *                                                                            *
X * Return values: pointer to resulting targetinfo upon success /              *
X *                NULL upon error                                             *
X ******************************************************************************/
XFSSPECINFO *
Xchain_fsspec_infos(accfs1, accfs2)
XFSSPECINFO *accfs1, *accfs2;
X{
X    register FSSPECINFO *ptr;
X
X    for(ptr = accfs1; ptr->next; ptr = ptr->next)
X	;
X    ptr->next = accfs2;
X    return(accfs1);
X} /* chain_fsspec_infos */
X
X/******************************************************************************
X * generate_commp_info()                                                      *
X *                                                                            *
X * Generates and initializes a communication process info.                    *
X *                                                                            *
X * Return values: pointer to new element upon success / NULL upon error       *
X ******************************************************************************/
XCOMMPINFO *
Xgenerate_commp_info(process, freq, quant)
XSYMBTABEL *process;
Xfloat freq, quant;
X{
X    register COMMPINFO *ptr;
X
X    ptr = (COMMPINFO *) Malloc(sizeof(COMMPINFO));
X    ptr->Process   = process;
X    ptr->frequency = freq;
X    ptr->quantity  = quant;
X    ptr->next      = NULL;
X
X    return(ptr);
X} /* generate_commp_info */
X
X/******************************************************************************
X * chain_commp_infos()                                                        *
X *                                                                            *
X * Chains communication process info 'cattr1' to the end of info 'cattr2'.    *
X *                                                                            *
X * Return values: pointer to resulting targetinfo upon success /              *
X *                NULL upon error                                             *
X ******************************************************************************/
XCOMMPINFO *
Xchain_commp_infos(cattr1, cattr2)
XCOMMPINFO *cattr1, *cattr2;
X{
X    register COMMPINFO *ptr;
X
X    for(ptr = cattr1; ptr->next; ptr = ptr->next)
X	;
X    ptr->next = cattr2;
X    return(cattr1);
X} /* chain_commp_infos */
X
X/******************************************************************************
X * generate_process_attr_info()                                               *
X *                                                                            *
X * Generates and initializes a process attribute info.                        *
X *                                                                            *
X * Return values: pointer to new element upon success / NULL upon error       *
X ******************************************************************************/
XPATTRINFO *
Xgenerate_process_attr_info(type, idlist, number, mode, fsspec, commps)
Xint type;
XIDENTLIST *idlist;
Xfloat number;
Xint mode;
XFSSPECINFO *fsspec;
XCOMMPINFO *commps;
X{
X    register PATTRINFO *ptr;
X
X    ptr = (PATTRINFO *) Malloc(sizeof(PATTRINFO));
X
X    ptr->type = type;
X    switch(type) {
X    case PA_PREFERRED:
X	ptr->info.pref_hosts = idlist;
X	break;
X    case PA_RESTRICTED:
X	ptr->info.rest_hosts = idlist;
X	break;
X    case PA_INTENSITY_INDEX:
X	ptr->info.intensity_index = number;
X	break;
X    case PA_PHYS_MEM:
X	ptr->mode = mode;
X	ptr->info.phys_mem_size = number;
X	break;
X    case PA_VIRT_MEM:
X	ptr->mode = mode;
X	ptr->info.virt_mem_size = number;
X	break;
X    case PA_PERI_DEVICES:
X	ptr->info.peri_dev = idlist;
X	break;
X    case PA_FILESYSTEMS:
X	ptr->info.filesystems = fsspec;
X	break;
X    case PA_COMM_PROCESSES:
X	ptr->info.commps = commps;
X	break;
X    case PA_VECTORIZATION:
X	ptr->mode = mode;
X	break;
X    case PA_PARALLELIZATION:
X	ptr->mode = mode;
X	break;
X    }
X    ptr->next = NULL;
X    
X    return(ptr);
X} /* generate_process_attr_info */
X
X/******************************************************************************
X * chain_pattr_infos()                                                        *
X *                                                                            *
X * Chains process attribute info 'pattr1' to the end of info 'pattr2'.        *
X *                                                                            *
X * Return values: pointer to resulting targetinfo upon success /              *
X *                NULL upon error                                             *
X ******************************************************************************/
XPATTRINFO *
Xchain_pattr_infos(pattr1, pattr2)
XPATTRINFO *pattr1, *pattr2;
X{
X    register PATTRINFO *ptr;
X
X    for(ptr = pattr1; ptr->next; ptr = ptr->next)
X	;
X    ptr->next = pattr2;
X    return(pattr1);
X} /* chain_pattr_infos */
X
X/******************************************************************************
X * enter_process_description()                                                *
X *                                                                            *
X * Enters the process description 'symbol' in the symbol table including all  *
X * informations.                                                              *
X *                                                                            *
X * Return values: pointer to entered element upon success / NULL upon error   *
X ******************************************************************************/SYMBTABEL *
Xenter_process_description(symbol, pattrl)
XSYMBTABEL *symbol;
XPATTRINFO *pattrl;
X{
X    int intensityflag = FALSE;
X    register PATTRINFO *ptr;
X
X    /* check symbol */
X    if (symbol->type != UNDEFINED) {
X        printf("Error: line %d at \"%s\": redefinition: \"%s\"\n",
X            yylineno, yytext, symbol->name);
X        return(NULL);
X    }
X
X    symbol->type = S_PROCESS;
X    symbol->info.Process.pref_hosts  = NULL;
X    symbol->info.Process.rest_hosts  = NULL;
X    symbol->info.Process.peri_dev    = NULL;
X    symbol->info.Process.filesystems = NULL;
X    symbol->info.Process.commps      = NULL;
X    for(ptr = pattrl; ptr; ptr = ptr->next) {
X	switch(ptr->type) {
X	case PA_PREFERRED:
X	    symbol->info.Process.pref_hosts = ptr->info.pref_hosts;
X	    break;
X	case PA_RESTRICTED:
X	    symbol->info.Process.rest_hosts = ptr->info.rest_hosts;
X	    break;
X	case PA_PERI_DEVICES:
X	    symbol->info.Process.peri_dev = ptr->info.peri_dev;
X	    break;
X	case PA_FILESYSTEMS:
X	    symbol->info.Process.filesystems = ptr->info.filesystems;
X	    break;
X	case PA_COMM_PROCESSES:
X	    symbol->info.Process.commps = ptr->info.commps;
X	    break;
X	case PA_INTENSITY_INDEX:
X	    symbol->info.Process.intensity_index = ptr->info.intensity_index;
X	    intensityflag = 1;
X	    break;
X	} /* switch */
X    } /* for(ptr) */
X    symbol->info.Process.others = pattrl;
X
X    if (!intensityflag) {
X        printf("Error: process specification \"%s\": no intensity index\n",
X            symbol->name);
X        return(NULL);
X    }
X    return(symbol);
X} /* enter_process_description */
X
END_OF_FILE
if test 10681 -ne `wc -c <'config/symb_program.c'`; then
    echo shar: \"'config/symb_program.c'\" unpacked with wrong size!
fi
# end of 'config/symb_program.c'
fi
if test -f 'dcc/code_create.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcc/code_create.c'\"
else
echo shar: Extracting \"'dcc/code_create.c'\" \(9101 characters\)
sed "s/^X//" >'dcc/code_create.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                        c o d e _ c r e a t e . c                        *
X *                                                                         *
X *                            Package : Compiler                           *
X *                            Version : 1.0                                *
X *                       CreationDate : 04.09.90                           *
X *                         LastUpDate : 09.03.92                           *
X *                                                                         *
X * The functions to generate the process creation routine and the process  *
X * creation code.                                                          *
X *                                                                         *
X *                  Portions Copyright 1990 Franz Distler                  *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include "config.h"
X#include "extern.h"
X#include "functions.h"
X#include "com_Errno.h"
X#include "timeout.h"
X
X/******************************************************************************
X * gen_process_creation_routine()                                             *
X *                                                                            *
X * Generates the process creation routine for the process specified by the    *
X * symbol table element 'symbol'. The generated process creation routine is   *
X * called at runtime to create the specified process and pass the arguments.  *
X *                                                                            *
X * Return values: OK upon success / ERROR during error handling               *
X ******************************************************************************/
Xint
Xgen_process_creation_routine(symbol)
XSYMBTABEL *symbol;
X{
X    int          i,
X                 length;
X    char        *piname,
X                *upiname;
X    static char  processname[MAXFILENAMELEN+1];
X    SYMBTABEL   *params;
X
X    if (errflag || !symbol)	/* error handling! */
X        return(ERROR);
X#ifdef CODEDEBUG
X    fputs("[code] ***** gen_process_creation_routine():\n", debugfile);
X    fprintf(debugfile, "[code]       params: symbol = %d\n", symbol);
X#endif  /* CODEDEBUG /**/
X    piname  = symbol->info.process.piname,
X    upiname = symbol->info.process.upiname;
X    strcpy(processname, symbol->info.process.filename);
X    processname[strlen(processname)-2] = '\0';
X
X    if (infoflag) {
X	printf("%s generating creation routine for process '%s'\n",
X	    infoprefix, symbol->name);
X	fflush(stdout);
X    }
X
X    if (!specflag) {
X        strcpy(creatfilename, filenameprefix);
X        length = MAXFILENAMELEN - strlen(SPECFILEEXT);
X        if (strlen(filenameprefix) <= length)
X	    strcat(creatfilename, SPECFILEEXT);
X        else
X           strcpy(&creatfilename[length], SPECFILEEXT);
X        if (!(creatfile = fopen(creatfilename, "w"))) {
X	    fprintf(stderr,"Error: impossible to open file for creation routines '%s'\n",
X	        creatfilename);
X	    exit(EXIT_FOPEN);
X        }
X        fprintf(creatfile, "/* %s */\n\n", creatfilename);
X        fputs("/*\n", creatfile);
X        for(i = 0; *headerstr[i]; ++i)
X            fprintf(creatfile, " * %s\n", headerstr[i]);
X        fputs(" */\n\n", creatfile);
X        fprintf(creatfile, "#include \"%s\"\n", inclfilename);
X	specflag = TRUE;
X    }
X    fprintf(creatfile, "\n/* specific creation routine to create process '%s' */\n",
X        symbol->name);
X    fprintf(creatfile, "PROCESSDESCR\ncreate_process_%s(location", piname);
X    for(params=symbol->info.process.FirstParam; params; params=params->info.varorpar.NextParam) {
X	fprintf(creatfile, ", %s", params->name);
X    }
X    fputs(")\n", creatfile);
X    fputs("char *location;\n", creatfile);
X    for(params = symbol->info.process.FirstParam; params;
X				     params = params->info.varorpar.NextParam) {
X        *convert_buffer = 0;
X	convert_buffer = convert_ds_to_string(convert_buffer, params->info.varorpar.DataType),
X	fprintf(creatfile, "%s %s;\n", convert_buffer, params->name);
X    }
X    fputs("{\n\tPROCESSDESCR result;\n", creatfile);
X    fputs("\n\t/* create process and get process descriptor */\n", creatfile);
X    fprintf(creatfile, "\tif (_create_process(\"%s\", \"%s\", location, &result))\n",
X	symbol->name, processname);
X    fprintf(creatfile, "\t\t_RuntimeError(\"creating process\");\n");
X    if (symbol->info.process.FirstParam) {
X        fputs("\t/* transmit arguments */\n", creatfile);
X        for (params=symbol->info.process.FirstParam; params; params = params->info.varorpar.NextParam)
X	    fprintf(creatfile, "\tdcc_par.%s.%s = %s;\n", piname, params->name, 
X	        params->name);
X        fprintf(creatfile, "\tif (_send_data");
X#ifdef HETEROGENEOUS
X        fprintf(creatfile, "_encoded");
X#endif
X        fprintf(creatfile, "(&_con_port, (char *) &dcc_par.%s, ", piname);
X#if defined(SINGLE) || defined(HOMOGENEOUS)
X	fprintf(creatfile, "sizeof(%s%s)", upiname, POSTFIXSPECPAR);
X#else /* HETEROGENEOUS */
X	fprintf(creatfile, "xdr_%s%s", upiname, POSTFIXSPECPAR);
X#endif
X        fprintf(creatfile, ", %d) < 0) {\n", CPTONPPARTIME);
X        fputs("\t\tif (Errno == ETIMEOUT)\n", creatfile);
X        fputs("\t\t\tErrno = ETCCPTONPPAR;\n", creatfile);
X        fprintf(creatfile, "\t\t_RuntimeError(\"sending arguments\");\n");
X        fputs("\t}\n", creatfile);
X    }
X    fputs("\tif (_close_connection(&_con_port))\n", creatfile);
X    fputs("\t\t_RuntimeError(\"create_process_...()\");\n", creatfile);
X    fputs("\treturn(result);\n", creatfile);
X    fprintf(creatfile, "} /* create_process_%s */\n", piname);
X    return(OK);
X} /* gen_process_creation_routine */
X
X/******************************************************************************
X * generate_process_creation_code()                                           *
X *                                                                            *
X * Generates the code for creating a particular process.                      *
X *                                                                            *
X * Return values: pointer to generated code string upon success /             *
X *                NULL during error handling                                  *
X ******************************************************************************/
Xchar *
Xgenerate_process_creation_code(symbol, arg, location)
XSYMBTABEL *symbol;
XARG_LIST  *arg;
Xchar      *location;
X{
X    int        i;
X    char      *cmd;
X    ARG_LIST  *hptr;
X    SYMBTABEL *params;
X
X    if (errflag || !symbol)	/* error handling! */
X        return(NULL);
X#ifdef CODEDEBUG
X    fputs("[code] ***** generate_process_creation_code():\n", debugfile);
X    fprintf(debugfile, "[code]       params: symbol = %d, arg = %d, location = %s\n",
X        symbol, arg, location);
X    fputs("[code]       the arguments are:", debugfile);
X    for(hptr=arg, i=1; hptr; hptr=hptr->next, i++) 
X        fprintf(debugfile, "[code]           arg %d: %s\n", i, hptr->code);
X#endif  /* CODEDEBUG /**/
X    if (symbol->type != PROCESSDECL) {
X        strcpy(yytext, symbol->name);
X        PRINTERROR("", ENOTSPECIFIED);
X        /* (void) delete_arg_list(arg); */
X        Free(location);
X	return(strmalloc(""));
X    }
X    cmd = strmalloc("create_process_");
X    cmd = Strcatmany(cmd, 3, symbol->info.process.piname, "(", location);
X    for(params=symbol->info.process.FirstParam, hptr=arg; params;
X            params=params->info.varorpar.NextParam, hptr=hptr->next) {
X	if (!hptr) {
X	    strcpy(yytext, "");
X	    Errno = WPROCESSARGS;
X	    Warning("");
X	    break;
X	}
X	cmd = Strcatmany(cmd, 2, ", ", hptr->code);
X    }
X    cmd = Strcat(cmd, ")");
X    Free(location);
X    return(cmd);
X} /* generate_process_creation_code */
END_OF_FILE
if test 9101 -ne `wc -c <'dcc/code_create.c'`; then
    echo shar: \"'dcc/code_create.c'\" unpacked with wrong size!
fi
# end of 'dcc/code_create.c'
fi
if test -f 'dcc/makefile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcc/makefile.c'\"
else
echo shar: Extracting \"'dcc/makefile.c'\" \(10994 characters\)
sed "s/^X//" >'dcc/makefile.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                           m a k e f i l e . c                           *
X *                                                                         *
X *                            Package : Compiler                           *
X *                            Version : 1.0                                *
X *                       CreationDate : 15.08.90                           *
X *                         LastUpDate : 31.08.91                           *
X *                                                                         *
X *                  The routine to generate the makefile.                  *
X *                                                                         *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#ifdef HETEROGENEOUS
X# include <rpc/rpc.h>
X#endif
X#include <string.h>
X#include "config.h"
X#include "extern.h"
X#include "functions.h"
X#include "ipc.h"
X#include "dcc.h"
X
X/******************************************************************************
X * build_makefile()                                                           *
X *                                                                            *
X * Generates the makefile needed to manage the built files.                   *
X *                                                                            *
X * Return values: always OK for success                                       *
X ******************************************************************************/
Xint
Xbuild_makefile()
X{
X    int i, j, flag;
X    char mainstr[MAXFILENAMELEN+1], 
X         specstr[MAXFILENAMELEN+1], 
X         funcstr[MAXFILENAMELEN+1], 
X#if defined(HETEROGENEOUS) || defined(CHECK_XDR)
X         xdrstr[MAXFILENAMELEN+1],
X#endif /* HETEROGENEOUS /**/
X         *incdir, *libdir, *cflags, *lflags, *libs, *cb, *cbflags,
X         *hosts, *hp1, *targets, *makec;
X    struct process_list *ptr;
X    struct include_list *inclptr;
X    struct include_path_list *pathptr;
X    struct cpp_def_list *cppdefptr;
X
X#ifdef DEBUG
X    fputs("[debg] ***** build_makefile():\n", debugfile);
X#endif /* DEBUG /**/
X
X    if (infoflag) {
X	printf("%s building the makefile\n", infoprefix);
X	fflush(stdout);
X    }
X
X    if (!(makefile = fopen(makefilename, "w"))) {
X	fprintf(stderr, "Error: impossible to open makefile '%s'\n",
X	    makefilename);
X	exit(EXIT_FOPEN);
X    }
X    fprintf(makefile, "# %s - Makefile for '%s'\n", makefilename,
X	inputfilename);
X    fputs("#\n", makefile);
X    for(i = 0; *headerstr[i]; ++i)
X        fprintf(makefile, "# %s\n", headerstr[i]);
X    fputs("\n", makefile);
X
X    makec = (char *) getenv("DCC_MAKE");  
X    if (makec == NULL || *makec == '\0')
X	makec = "make";
X
X    cflags = (char *) getenv("DCC_CFLAGS");  
X    if (cflags == NULL || *cflags == '\0')
X	cflags = "";
X
X    lflags = (char *) getenv("DCC_LFLAGS");  
X    if (lflags == NULL || *lflags == '\0')
X	lflags = "";
X
X    libs = (char *) getenv("DCC_LIBS");  
X    if (libs == NULL || *libs == '\0')
X	libs = "";
X
X    cb = (char *) getenv("DCC_CB");  
X    if (cb == NULL || *cb == '\0')
X	cb = "undefined";
X
X    cbflags = (char *) getenv("DCC_CBFLAGS");  
X    if (cbflags == NULL || *cbflags == '\0')
X	cbflags = "";
X
X    targets = (char *) getenv("DCC_TARGETS");  
X    if (targets == NULL || *targets == '\0')
X#ifdef SINGLE
X	targets = "-target local";
X#else /* HOMOGENEOUS || HETEROGENEOUS */
X	targets = "-target all";
X#endif /* SINGLE /**/
X
X    fprintf(makefile, "   MAKE = @%s -f %s\n", makec, makefilename);
X    fprintf(makefile, "   ECHO = @echo\n");
X    fprintf(makefile, "  TOUCH = @touch\n");
X    fprintf(makefile, "     CC = dcinstall\n");
X    fprintf(makefile, " CFLAGS = $(TARGETS) %s", cflags);
X    for(pathptr = first_inclpathname; pathptr; pathptr = pathptr->next)
X        fprintf(makefile, "\\\n          -I%s ", pathptr->path);
X    for(cppdefptr = first_cppdef; cppdefptr; cppdefptr = cppdefptr->next)
X        fprintf(makefile, "\\\n          -D%s ", cppdefptr->def);
X    if (cflags != NULL && *cflags != 0 && cflagsstr != NULL && *cflagsstr != 0)
X        fprintf(makefile, "\\\n          %s %s\n", cflags, cflagsstr);
X    else
X	fprintf(makefile, "\n");
X    fprintf(makefile, "     LD = dcinstall\n");
X    fprintf(makefile, " LFLAGS = $(TARGETS) %s %s\n", lflags, lflagsstr);
X    fprintf(makefile, "   LIBS = %s %s\n", libs, libsstr);
X    fprintf(makefile, "     CB = %s\n", cb);
X    fprintf(makefile, "CBFLAGS = %s\n\n", cbflags);
X    fprintf(makefile, "TARGETS = %s\n\n", targets);
X
X    if (mainflag) {
X        strcpy(mainstr, outputfilename);
X        mainstr[strlen(mainstr)-2] = '\0';
X    }
X
X    if (specflag) {
X        strcpy(specstr, creatfilename);
X        specstr[strlen(specstr)-2] = '\0';
X    }
X
X#if defined(HETEROGENEOUS) || defined(CHECK_XDR)
X    if (xdrflag) {
X        strcpy(xdrstr, xdrfilename);
X        xdrstr[strlen(xdrstr)-2] = '\0';
X    }
X#endif /* HETEROGENEOUS /**/
X
X    if (funcflag) {
X        strcpy(funcstr, funcfilename);
X        funcstr[strlen(funcstr)-2] = '\0';
X    }
X
X    if (mainflag)
X        fprintf(makefile, "BIN =\t%s ", filenameprefix); 
X    else
X        fprintf(makefile, "BIN ="); 
X    for(ptr = first_processname; ptr; ptr = ptr->next) {
X	ptr->name[strlen(ptr->name)-2] = '\0';
X	fprintf(makefile, "\\\n\t%s ", ptr->name);
X    }
X
X    fprintf(makefile, "\n\nFILES = %s.h ", filenameprefix);
X    if (mainflag)
X        fprintf(makefile, "\\\n        %s ", outputfilename);
X    if (specflag)
X        fprintf(makefile, "\\\n        %s ", creatfilename);
X#if defined(HETEROGENEOUS) || defined(CHECK_XDR)
X    if (xdrflag)
X        fprintf(makefile, "\\\n        %s ", xdrfilename);
X#endif /* HETEROGENEOUS /**/
X    if (funcflag)
X        fprintf(makefile, "\\\n        %s ", funcfilename);
X    for(ptr = first_processname; ptr; ptr = ptr->next)
X	fprintf(makefile, "\\\n        %s.c ", ptr->name);
X    if (mainflag)
X        fprintf(makefile, "\\\n        %s.c", mainstr); 
X
X    fputs("\n\nOBJS =\t", makefile);
X    if (specflag)
X        fprintf(makefile, "%s.o", specstr);
X#ifdef HETEROGENEOUS
X    if (xdrflag)
X        fprintf(makefile, " %s.o", xdrstr);
X#endif /* HETEROGENEOUS /**/
X    if (funcflag)
X        fprintf(makefile, " %s.o", funcstr);
X
X    fputs("\n\n.c.o:\n\t$(ECHO) \"***** Compiling $<\"\n", makefile);
X    fputs("\t$(CC) $(CFLAGS) -c $<\n", makefile);
X    fputs("\t$(TOUCH) $@\n", makefile);
X
X    fputs("\nall:\n\t$(MAKE) $(BIN)\n", makefile);
X    fprintf(makefile, "\t$(ECHO) \"\"\n");
X    fprintf(makefile, "\t$(ECHO) all stuff done for '%s'!\n\n",inputfilename);
X
X    if (mainflag) {
X        fprintf(makefile, "%s: incl $(OBJS) %s.o\n", filenameprefix, mainstr);
X        fprintf(makefile, "\t$(ECHO) \"***** Building $@\"\n");
X        fprintf(makefile, "\t$(LD) -o %s $(LFLAGS) $(OBJS) %s.o $(LIBS)\n",
X	    filenameprefix, mainstr);
X        fprintf(makefile, "\t$(TOUCH) $@\n");
X    }
X
X    for(ptr = first_processname; ptr; ptr = ptr->next) {
X	fprintf(makefile, "\n%s: incl $(OBJS) %s.o\n", ptr->name, ptr->name);
X        fputs("\t$(ECHO) \"***** Building $@\"\n", makefile);
X	fprintf(makefile, "\t$(LD) -o %s $(LFLAGS) $(OBJS) %s.o $(LIBS)\n",
X	    ptr->name, ptr->name);
X        fprintf(makefile, "\t$(TOUCH) $@\n");
X    }
X
X    fprintf(makefile, "\nincl: %s.h\n", filenameprefix);
X    fprintf(makefile, "\t$(CC) $(CFLAGS) %s.h\n", filenameprefix);
X    fprintf(makefile, "\t$(TOUCH) $@\n\n");
X
X    if (specflag)
X        fprintf(makefile, "%s.o: %s.h %s.c\n", specstr, filenameprefix, specstr);
X
X#ifdef HETEROGENEOUS
X    if (xdrflag)
X        fprintf(makefile, "%s.o: %s.h %s.c\n", xdrstr, filenameprefix, xdrstr);
X#endif /* HETEROGENEOUS /**/
X
X    if (funcflag)
X        fprintf(makefile, "%s.o: %s.h %s.c\n", funcstr, filenameprefix, funcstr);
X
X    for(ptr = first_processname; ptr; ptr = ptr->next) {
X	fprintf(makefile, "%s.o: %s.h %s.c\n", ptr->name, filenameprefix, ptr->name);
X    }
X
X    if (mainflag)
X        fprintf(makefile, "%s.o: %s.h %s.c\n", mainstr, filenameprefix, mainstr);
X
X    fputs("\nnew:\n", makefile);
X    fprintf(makefile, "\ttouch %s.h\n", filenameprefix);
X    fprintf(makefile, "\t$(MAKE) all\n");
X
X    fputs("\nbeautify:\n", makefile);
X    fprintf(makefile, "\t$(ECHO) \"beautifying the generated files of '%s'\"\n",
X	inputfilename);
X    fputs("\t@for name in $(FILES); \\\n", makefile);
X    fputs("\tdo \\\n", makefile);
X#ifdef CONVEX
X    /* use indent to beautify files */
X    fputs("\t    $(CB) $(CBFLAGS) $${name}; \\\n",
X	makefile);
X#else
X    /* use cb to beautify files */
X    fputs("\t    mv $${name} cb.tmp; $(CB) $(CBFLAGS) cb.tmp > $${name}; \\\n",
X	makefile);
X#endif 
X    fputs("\tdone\n", makefile);
X#ifndef CONVEX
X    fputs("\t-@\\rm cb.tmp\n", makefile);
X#endif
X    fputs("\t$(ECHO) done!\n", makefile);
X
X    fputs("\nclean:\n", makefile);
X    fprintf(makefile, "\t-@\\rm -f %s.h \\\n", filenameprefix);
X    if (specflag)
X        fprintf(makefile, "\t         %s \\\n", creatfilename);
X#if defined(HETEROGENEOUS) || defined(CHECK_XDR)
X    if (xdrflag)
X        fprintf(makefile, "\t         %s \\\n", xdrfilename);
X#endif /* HETEROGENEOUS /**/
X    if (funcflag)
X        fprintf(makefile, "\t         %s \\\n", funcfilename);
X    if (mainflag) {
X        fprintf(makefile, "\t         %s \\\n", outputfilename);
X        fprintf(makefile, "\t         %s ", filenameprefix);
X    }
X    for(ptr = first_processname; ptr; ptr = ptr->next) {
X        fprintf(makefile, "\\\n\t         %s.c ", ptr->name, ptr->name);
X        fprintf(makefile, "\\\n\t         %s ", ptr->name, ptr->name);
X    }
X    fprintf(makefile, "\\\n\t         %s \\\n", makefilename);
X    fputs("\t         *.o incl\n", makefile);
X
X    return(OK);
X} /* build_makefile */
END_OF_FILE
if test 10994 -ne `wc -c <'dcc/makefile.c'`; then
    echo shar: \"'dcc/makefile.c'\" unpacked with wrong size!
fi
# end of 'dcc/makefile.c'
fi
if test -f 'dcc/symb_debug.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcc/symb_debug.c'\"
else
echo shar: Extracting \"'dcc/symb_debug.c'\" \(9368 characters\)
sed "s/^X//" >'dcc/symb_debug.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                         s y m b _ d e b u g . c                         *
X *                                                                         *
X *                            Package : Compiler                           *
X *                            Version : 1.0                                *
X *                       CreationDate : 13.09.91                           *
X *                         LastUpDate : 13.09.91                           *
X *                                                                         *
X *        Special routines for symbol table debugging purpose only.        *
X *                                                                         *
X *               Copyright (C) 1991-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include "config.h"
X#include "extern.h"
X#include "functions.h"
X#include "y.tab.h" 
X#include "com_Errno.h"
X
X#ifdef DEBUGFLAG
X
X/******************************************************************************
X * display_symbtab_entry()                                              OK    *
X *                                                                            *
X * Displays the specific information of the symbol table element pointed to   *
X * by 'ptr'.                                                                  *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
Xdisplay_symbtab_entry(ptr)
XSYMBTABEL *ptr;
X{
X    int i, j;
X    SYMBTABEL *hptr, *hptr2;
X
X    if (!ptr) /* error handling! */
X	return(ERROR);
X    fprintf(debugfile, "[symb] ***** display_symbtab_entry(): ptr = %d\n",
X	ptr);
X    fprintf(debugfile, "[symb]       name = %s, blknum = %d\n",
X	ptr->name, ptr->blknum);
X    fprintf(debugfile, "[symb]       WasInSysIncl = %s, type = ",
X	(ptr->WasInSysIncl) ? "TRUE" : "FALSE");
X    switch(ptr->type) {
X    case UDEC:
X	fputs("UDEC\n", debugfile);
X	break;
X    case FUNCTIONDEF:
X	fputs("FUNCTIONDEF\n", debugfile);
X	break;
X    case PROCESSDECL:
X	fprintf(debugfile, "PROCESSDECL\n[symb] IsSpec = %s\n", 
X		(ptr->info.process.IsSpec) ? "TRUE" : "FALSE");
X	if (hptr = ptr->info.process.FirstParam) {
X	    fputs("[symb] parameter list:\n", debugfile);
X	    for(i=1; hptr; hptr = hptr->info.varorpar.NextParam, i++) {
X		*convert_buffer = 0;
X		convert_buffer = convert_ds_to_string(convert_buffer, 
X		    hptr->info.varorpar.DataType);
X	        fprintf(debugfile, "[symb]     param %d: name = %s, type = %s\n",
X		    i, hptr->name, convert_buffer);
X	    }
X	} else 
X	    fputs("[symb] no process parameters declared!\n", debugfile);
X	if (hptr = ptr->info.process.FirstTrans) {
X	    fputs("[symb] transaction list:\n", debugfile);
X	    for(i=1; hptr; hptr = hptr->info.trans.NextTrans, i++) {
X		*convert_buffer = 0;
X		convert_buffer = convert_ds_to_string(convert_buffer,
X		    hptr->info.trans.ReturnType);
X	        fprintf(debugfile, "[symb]     trans %d: name = %s, ReturnType = %s\n",
X		    i, hptr->name, convert_buffer);
X                if (hptr2 = hptr->info.trans.FirstParam) {
X	            fputs("[symb]         parameter list:\n", debugfile);
X                    for(j=1; hptr2; hptr2=hptr2->info.varorpar.NextParam, j++) {
X			*convert_buffer = 0;
X			convert_buffer = convert_ds_to_string(convert_buffer,
X			    hptr2->info.varorpar.DataType);
X		        fprintf(debugfile, "[symb]         param %d: name = %s, type = %s\n",
X		            j, hptr2->name, convert_buffer);
X	            }
X		} else
X	            fputs("[symb]         no transaction parameters declared!\n", debugfile);
X	    } /* for */
X	} else
X	    fputs("[symb] no transactions declared!\n", debugfile);
X	break;
X    case VARORPAR:
X	*convert_buffer = 0;
X	convert_buffer = convert_ds_to_string(convert_buffer, ptr->info.varorpar.DataType);
X	fprintf(debugfile, "VARORPAR\n[symb] Type = %s, NextParam = %d\n",
X		convert_buffer, ptr->info.varorpar.NextParam);
X	break;
X    case TRANSACTION:
X	fprintf(debugfile, "TRANSACTION\n[symb] IsDecl = %s\n", 
X		(ptr->info.trans.IsDecl) ? "TRUE" : "FALSE");
X	fprintf(debugfile, "[symb] ptiname = %s, uptiname = %s\n",
X		ptr->info.trans.ptiname, ptr->info.trans.uptiname);
X	*convert_buffer = 0;
X	convert_buffer = convert_ds_to_string(convert_buffer, ptr->info.trans.ReturnType);
X	fprintf(debugfile, "[symb] ReturnType = %s, Process = %d(\"%s\")\n",
X		convert_buffer, ptr->info.trans.Process, (ptr->info.trans.Process)->name);
X        if (hptr = ptr->info.trans.FirstParam) {
X	    fputs("[symb] parameter list:\n", debugfile);
X            for(j=1; hptr; hptr=hptr->info.varorpar.NextParam, j++) {
X		*convert_buffer = 0;
X		convert_buffer = convert_ds_to_string(convert_buffer, hptr->info.varorpar.DataType);
X		fprintf(debugfile, "[symb]     param %d: name = %s, type = %s\n",
X		    j, hptr->name, convert_buffer);
X	    }
X	} else
X	    fputs("[symb] no transaction parameters declared!\n", debugfile);
X	break;
X    case PROCESSVAR:
X	fputs("PROCESSVAR\n", debugfile);
X	break;
X    case TYPEDEFNAME:
X	fputs("TYPEDEFNAME\n", debugfile);
X	fprintf(debugfile, "[symb] IsPointer = %s, BuildXDRRoutine = %s\n",
X	    (ptr->info.typedefname.IsPointer) ? "TRUE" : "FALSE", 
X	    (ptr->info.typedefname.BuildXDRRoutine) ? "TRUE" : "FALSE");
X	break;
X    case STRUCTDECL:
X	fputs("STRUCTDECL\n", debugfile);
X	fprintf(debugfile, "[symb] IsStruct = %s, BuildXDRRoutine = %s\n",
X	    (ptr->info.structdecl.IsStruct) ? "TRUE" : "FALSE", 
X	    (ptr->info.structdecl.BuildXDRRoutine) ? "TRUE" : "FALSE");
X	break;
X    default:
X	fputs("UNKNOWN!\n", debugfile);
X    } /* switch */
X} /* display_symbtab_entry */
X
X/******************************************************************************
X * display_symbol_table()                                                OK   *
X *                                                                            *
X * Displays the symbol table with all entries.                                *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
Xdisplay_symbol_table()
X{
X    register int i;
X    register SYMBTABEL *ptr;
X
X    fputs("[symb] ***** display_symbol_table():\n", debugfile);
X    for(i = blknum; i >= 0; i--) {
X        fprintf(debugfile, "[symb] ---------- symbol table - block depth %2d ----------\n", i);
X        for(ptr = symbtab.PstTab[i]; ptr; ptr = ptr->PstNext)
X            display_symbtab_entry(ptr);
X    }
X    fputs("[symb] ---------------------------------------------------\n", debugfile);
X} /* display_symbol_table */
X
X/******************************************************************************
X * display_struct_type_list                                              OK   *
X *                                                                            *
X * Displays the list containing the structure and type definitions.           *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
Xdisplay_struct_type_list()
X{
X    register int i;
X    struct struct_type_list *ptr;
X    SYMBTABEL *symbol;
X
X    fputs("[symb] ***** display_struct_type_list():\n", debugfile);
X    for(ptr = first_structtype, i = 1; ptr; ptr = ptr->next, i++) {
X	symbol = ptr->symbol;
X        fprintf(debugfile, "[symb]       [%d] ", i);
X	switch(symbol->type) {
X	case TYPEDEFNAME:
X	    fprintf(debugfile, "typedef ");
X	    break;
X	case STRUCTDECL:
X	    fprintf(debugfile, "struct ");
X	    break;
X	default:
X	    fprintf(debugfile, "illegal entry (type = %d)", symbol->type);
X	} /* switch */
X	fprintf(debugfile, " \"%s\"\n", symbol->name);
X    } /* for(ptr) */
X} /* display_struct_type_list */
X
X#endif /* DEBUGFLAG /**/
END_OF_FILE
if test 9368 -ne `wc -c <'dcc/symb_debug.c'`; then
    echo shar: \"'dcc/symb_debug.c'\" unpacked with wrong size!
fi
# end of 'dcc/symb_debug.c'
fi
if test -f 'examples/nullst/nullst.dc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/nullst/nullst.dc'\"
else
echo shar: Extracting \"'examples/nullst/nullst.dc'\" \(10721 characters\)
sed "s/^X//" >'examples/nullst/nullst.dc' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                           n u l l s t . d c                             *
X *                                                                         *
X *                 Version 1.0      CreationDate: 29.08.90                 *
X *                                    LastUpDate: 18.10.90                 *
X *                                                                         *
X *Berechnung der Nullstellen einer Funktion mittels der Halbierungsmethode.*
X *                                                                         *
X *        Copyright (C) 1990 by Franz Distler and Christoph Pleier.        *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * Dieses Programm berechnet die Nullstellen einer Funktion in einem best.
X * Intervall mittels der Halbierungsmethode.
X * Das Gesamtintervall wird in Teilintervalle untergliedert. Diese Teil-
X * intervalle werden auf mehreren Rechnern parallel berechnet.
X * Die zu untersuchende Funktion und die Genauigkeit der Berechnung werden
X * zur Uebersetzungszeit festgelegt.
X * Die Intervallgrenzen, die Schrittweite der Startnaeherung sowie die An-
X * zahl der Teilintervalle werden zur Laufzeit eingegeben.
X */
X
X#include <stdio.h>
X#undef stdin
X#undef stdout
X#undef stderr
X#include <math.h>
X
X/* Die Definition von DEMO konfiguriert eine Demonstrationsumgebung */
X/* #define DEMO /**/
X
X/* Die Definition von DEBUG bewirkt die zusaetzlich Ausgabe von Meldungen */
X/* #define DEBUG /**/
X
X/* maximale Anzahl von Berechnungsprozessen */
X#define MAXPROCESSANZ	100
X
X/* maximale Anzahl von Nullstellen pro Prozess */
X#define MAXENTRY	10000
X
X/* Genauigkeit der Nullstellenbestimmung: Abbruchkriterium. */
X#define LIMIT		1.0E-10 /* for HP 9000/720 */
X
X/* die zu untersuchende Funktion als Zeichenkette */
X#define FKTSTR		"sin(1/x)"
X
X#ifdef DEBUG
X# define DEBUGOUT(msg)	{printf("%s: %s\n", _processprefix, msg); \
X			fflush(stdout);}
X# define DEBUGPRINT(x)	{printf x; \
X			 fflush(stdout);}
X#else
X# define DEBUGOUT(msg)  /* nothing */
X# define DEBUGPRINT(x)  /* nothing */
X#endif /* DEBUG /**/
X
X/* In dieser Struktur werden die Ergebnisse gesammelt und an das 
X * Hauptprogramm ueber die Transaktion 'ReturnResult' uebergeben.
X */
Xstruct nullst {
X	int num;
X	double x[MAXENTRY];
X};
X
X/****************************************************************************
X *         Name : f                                                         *
X *          Art : Funktionsdefinition                                       *
X *    Returntyp : double                                                    *
X *    Parameter : double x                                                  *
X * Beschreibung : Vereinbarung der zu untersuchenden Funktion               *
X ****************************************************************************/
Xdouble f(x)
Xdouble x;
X{
X#ifdef DEMO
X	return( (x == 0) ? 1 : sin(1/x) );
X#else
X	return( (x == 0) ? 1 : sin(1/x) );
X#endif /* DEMO /**/
X} /* f */
X
X/****************************************************************************
X *         Name : get_it                                                    *
X *          Art : Funktionsdefinition                                       *
X *    Returntyp : double                                                    *
X *    Parameter : double xl, double xr                                      *
X * Beschreibung : Bestimmung der Nullstelle im Intervall [xl,xr].           *
X ****************************************************************************/
Xdouble get_it(xl, xr)
Xdouble xl, xr;
X{
X	double xn;
X
X	DEBUGPRINT(("%s get_it(%lf, %lf):\n", _processprefix, xl, xr));
X	while(xr - xl > LIMIT) {
X		xn = xl + (xr - xl) / 2;
X		if (f(xl)*f(xn) <= 0)
X			xr = xn;
X		else 
X			xl = xn;
X	}
X	DEBUGPRINT(("%s Result = %lf\n", _processprefix, xn));
X	return(xn);
X} /* get_it */
X
X/****************************************************************************
X *         Name : DisplayHelpMessage                                        *
X *          Art : Funktionsdefinition                                       *
X *    Returntyp : int                                                       *
X *    Parameter : keine                                                     *
X * Beschreibung : Ausgabe einer kurzen Programmbeschreibung.                *
X ****************************************************************************/
Xint DisplayHelpMessage()
X{
X	printf("Dieses Programm bestimmt zu einer Funktion die Nullstellen mittels der\n");
X	printf("Halbierungsmethode. Die Funktion ist vor der Uebersetzung des Programmes\n");
X	printf("im Quelltext anzugeben. Zur Laufzeit wird das zu untersuchende Intervall\n");
X	printf("und die Schrittweite der Startnaeherung eingegeben und anschliessend die\n");
X	printf("Nullstellen bestimmt.\n\n");
X} /* DisplayHelpMessage */
X
X/****************************************************************************
X *         Name : Nullstellen                                               *
X *          Art : Prozesspezifikation                                       *
X *    Returntyp : keiner                                                    *
X *    Parameter : double ug, double og, double step                         *
X * Beschreibung : Spezifikation des Prozesses und seiner Transaktionen.     *
X ****************************************************************************/
Xprocess spec Nullstellen(double ug, double og, double step)
X{
X	trans struct nullst ReturnResult();
X}
X
X/****************************************************************************
X *         Name : Nullstellen                                               *
X *          Art : Prozessdefinition                                         *
X *    Returntyp : keiner                                                    *
X *    Parameter : ug, og, step                                              *
X * Beschreibung : Definition des Prozessrumpfes sowie des accept - Rumpfes  *
X *                der Transaktion.                                          *
X ****************************************************************************/
Xprocess body Nullstellen(ug, og, step)
X{
X	int count = 0;
X	double xl, xr;
X	struct nullst result;
X
X	printf("%s Berechne Nullstellen im Intervall [%f,%f]...\n", 
X	    _processprefix, ug, og); 
X	fflush(stdout);
X
X	/* 
X	 * Berechne die Nullstellen im Intervall [ug,og]
X	 */
X
X	xl = ug;
X	xr = xl + step;
X	while(xl <= og) {
X		if (f(xl)*f(xr) <= 0) {
X			result.x[count] = get_it(xl, xr);
X			xr = result.x[count++] + LIMIT;
X			if (count >= MAXENTRY) {
X			        printf("%s Fehler: weitere Nullstellen nicht speicherbar\n",
X				    _processprefix);
X			}
X		}
X		xl = xr;
X		xr += step;
X	}
X	result.num = count;
X
X	printf("%s fertig!\n", _processprefix); 
X	fflush(stdout);
X
X	/*
X	 * Warte auf Abholen der Ergebnisse und sende sie zurueck
X	 */
X
X	DEBUGOUT("accepting ReturnResult()");
X	accept ReturnResult() { 
X		treturn(result); 
X	}
X
X	printf("%s terminiere!\n", _processprefix); 
X	fflush(stdout);
X	/* Prozesse sollten mit exit() beendet werden!!! */
X	exit(0);
X} /* process body Nullstellen */
X
X/****************************************************************************
X *         Name : main                                                      *
X *          Art : Funktionsdefinition                                       *
X *    Returntyp : int                                                       *
X *    Parameter : keine                                                     *
X * Beschreibung : Definition der Funktion main, die das Hauptprogramm bildet*
X ****************************************************************************/
Xmain(argc,argv)
X{
X	int i, j, ranz, nanz;
X	double ug, og, step, xl, xr, d;
X	struct nullst erg;
X	process Nullstellen N[MAXPROCESSANZ];
X
X	printf("Parallele Nullstellenbestimmung nach der Halbierungmethode\n");
X	printf("Realisiert in Distributed C von Christoph Pleier\n\n");
X
X	if (argc > 1) {
X		DisplayHelpMessage();
X		exit(-1);
X	}
X
X#ifdef DEMO
X	printf("Demonstrationsmodus aktiviert\n\n");
X	printf("Zu untersuchende Funktion f(x) = sin(1/x)\n");
X	printf("Zu untersuchendes Intervall = [%f,%f]\n", 
X		ug = -1.0, og = 1.0); 
X	printf("Schrittweite bei der Startnaeherung = %.8\n", 
X		step = 1E-07);
X#else
X	printf("Funktion: f(x) = %s\n", FKTSTR);
X	printf("Intervall:\n");
X	printf("   Untergrenze = ");
X	scanf("%lf", &ug);
X	printf("   Obergrenze  = ");
X	scanf("%lf", &og);
X	printf("Schrittweite bei der Startnaeherung = ");
X	scanf("%lf", &step);
X#endif /* DEMO /**/
X
X	printf("Wieviele Einzelprozesse sollen gestartet werden (max. %d)? ", 
X		MAXPROCESSANZ);
X	do {
X		scanf("%d", &ranz);
X	} while(ranz < 1 || ranz > MAXPROCESSANZ);
X
X	/* 
X	 * Verteile Berechnungen auf die einzelnen Rechner 
X	 * waehle Zielrechner entsprechend Standard-Konfigurationsdatei
X	 */
X
X	d = (og - ug) / ranz;
X
X	for(i = 1; i < ranz; i++) {
X		printf("Starte Prozesse...\n");
X		DEBUGPRINT(("%s Starte Prozess %d\n", _processprefix, i));
X		DEBUGPRINT(("%s     Intervall: [%f,%f], Schrittweite: %f\"\n", 
X			_processprefix, ug, ug+d, step));
X		N[i] = create Nullstellen(ug, ug+d, step);
X		ug += d + LIMIT;
X	}
X	DEBUGPRINT(("%s Starte Prozess %d\n", _processprefix, i));
X	DEBUGPRINT(("%s     Intervall: [%f,%f], Schrittweite: %f\"\n", 
X		_processprefix, ug, og, step));
X	N[i] = create Nullstellen(ug, og, step);
X
X	/* 
X	 * Hole Ergebnisse ab, gib sie aus und beende den Hauptprozess
X	 */
X
X	DEBUGOUT("Warte auf Ergebnisse");
X	nanz = 0;
X	for(i = 1; i <= ranz; i++) {
X		erg = N[i]@ReturnResult();
X		nanz += erg.num;
X		for(j = 0; j < erg.num && erg.x[j] < og; ++j) {
X			printf("Nullstelle bei x = %+10.20f, f(x) = %+.10f\n",
X				erg.x[j], f(erg.x[j]));
X		}
X	}
X
X	printf("Anzahl der Nullstellen im Intervall [%f,%f] : %d\n", 
X		ug, og, nanz);
X
X	/* exit() sollte immer am Endpunkten von main bzw. von Prozesses
X	 * stehen, damit der Verwaltungsprozess bei Termination benach-
X	 * richtigt wird!
X	 */
X	exit(0);
X
X} /* main */
END_OF_FILE
if test 10721 -ne `wc -c <'examples/nullst/nullst.dc'`; then
    echo shar: \"'examples/nullst/nullst.dc'\" unpacked with wrong size!
fi
# end of 'examples/nullst/nullst.dc'
fi
if test -f 'examples/test/creation.dc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/test/creation.dc'\"
else
echo shar: Extracting \"'examples/test/creation.dc'\" \(9266 characters\)
sed "s/^X//" >'examples/test/creation.dc' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                        c r e a t i o n . d c                            *
X *                                                                         *
X *                 Version 1.0      CreationDate: 20.09.90                 *
X *                                    LastUpDate: 22.10.90                 *
X *                                                                         *
X *              Special program to test the process creation.              *
X *                                                                         *
X *      Copyright (C) 1990-1993 by Franz Distler and Christoph Pleier.     *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/* define ONE of the following */
X/* #define iPSC		/* for Intel Hypercube */
X/* #define XENIX 	/* for Xenix System V */
X#define BSD		/* for BSD or compatibles */
X
X/****************************************************************************
X *         name : Message                                                   *
X *         type : function definition                                       *
X *   returntype : int                                                       *
X *   parameters : char * action                                             *
X *  description : This function displays the message action with an prefix  *
X *                specifying the calling process.                           *
X ****************************************************************************/
Xint Message(action)
Xchar *action;
X{
X#ifdef iPSC
X    printf("%-15s | %-8ld | %-8ld | %-30s\n", _processname, mynode(), 
X	_mypid(), action);
X#else
X    printf("%-15s | %-15s | %-10d | %-30s\n", _processname,
X# ifdef XENIX
X	"local",
X# else
X	_own_port.hostname,
X# endif /* XENIX /**/
X	getpid(), action);
X#endif /* iPSC /**/
X    fflush(stdout);
X} /* Message */
X
X/****************************************************************************
X *         name : P1                                                        *
X *         type : process specification                                     *
X *   returntype : none                                                      *
X *   parameters : none                                                      *
X *  description : Specification of the process P1.                          *
X ****************************************************************************/
Xprocess spec P1();
X
X/****************************************************************************
X *         name : P2                                                        *
X *         type : process specification                                     *
X *   returntype : none                                                      *
X *   parameters : struct P2_par par                                         *
X *  description : Specification of the process P1.                          *
X ****************************************************************************/
Xprocess spec P2(int id);
X
X/****************************************************************************
X *         name : P3                                                        *
X *         type : process specification                                     *
X *   returntype : none                                                      *
X *   parameters : none                                                      *
X *  description : Specification of the process P3.                          *
X ****************************************************************************/
Xprocess spec P3();
X
X/****************************************************************************
X *         name : P4                                                        *
X *         type : process specification                                     *
X *   returntype : none                                                      *
X *   parameters : double x, double y                                        *
X *  description : Specification of the process P4.                          *
X ****************************************************************************/
Xprocess spec P4(double x, double y);
X
X/****************************************************************************
X *         name : P1                                                        *
X *         type : process definition                                        *
X *   returntype : none                                                      *
X *   parameters : none                                                      *
X *  description : Definition of the process P1.                             *
X ****************************************************************************/
Xprocess body P1()
X{
X    process P2 p;
X
X    Message("RUNNING");
X    Message("STARTING P2");
X    p = create P2(1);
X    sleep(10);
X    Message("TERMINATING");
X    exit(0);
X} /* process body P1 */
X
X/****************************************************************************
X *         name : P2                                                        *
X *         type : process definition                                        *
X *   returntype : none                                                      *
X *   parameters : none                                                      *
X *  description : Definition of the process P2.                             *
X ****************************************************************************/
Xprocess body P2(id)
X{
X    process P2 p2; 
X    process P3 p3;
X
X    Message("RUNNING");
X    if (id <= 3) {
X        Message("STARTING P2");
X	p2 = create P2(id + 1);
X    } else {
X        Message("STARTING P3");
X        p3 = create P3();
X    }
X    sleep(5);
X    Message("TERMINATING");
X    exit(0);
X} /* process body P2 */
X
X/****************************************************************************
X *         name : P3                                                        *
X *         type : process definition                                        *
X *   returntype : none                                                      *
X *   parameters : none                                                      *
X *  description : Definition of the process P3.                             *
X ****************************************************************************/
Xprocess body P3()
X{
X    process P4 p;
X
X    Message("RUNNING");
X    Message("STARTING P4");
X    p = create P4(1.0, 1.1);
X    sleep(8);
X    Message("TERMINATING");
X    exit(0);
X} /* process body P3 */
X
X/****************************************************************************
X *         name : P4                                                        *
X *         type : process definition                                        *
X *   returntype : none                                                      *
X *   parameters : none                                                      *
X *  description : Definition of the process P4.                             *
X ****************************************************************************/
Xprocess body P4()
X{
X    Message("RUNNING");
X    sleep(10);
X    Message("TERMINATING");
X    exit(0);
X} /* process body P4 */
X
X/****************************************************************************
X *         name : main                                                      *
X *         type : function definition                                       *
X *   returntype : int                                                       *
X *   parameters : none                                                      *
X *  description : Definition of the main function building the main program.*
X ****************************************************************************/
Xmain()
X{
X    process P1 p1;
X    process P4 p4;
X
X    puts("This program tests the process creation facilities of the");
X    puts("distributed C package.");
X    puts("The following processes will be created:");
X    puts("    1 x P1, 4 x P2, 1 x P3, 2 x P4\n");
X#ifdef iPSC
X    printf("%-15s | %-8s | %-8s | %-30s\n", "PROCESS", "NODE", "PID", "ACTION");
X#else
X    printf("%-15s | %-15s | %-10s | %-30s\n", "PROCESS", "HOST", "PID", "ACTION");
X#endif /* iPSC /**/
X    puts("----------------|-----------------|------------|------------------------------");
X    Message("STARTING P1");
X    p1 = create P1();
X    Message("STARTING P4");
X    p4 = create P4(2.1, 3.2);
X    Message("TERMINATING");
X    exit(0);
X} /* main */
END_OF_FILE
if test 9266 -ne `wc -c <'examples/test/creation.dc'`; then
    echo shar: \"'examples/test/creation.dc'\" unpacked with wrong size!
fi
# end of 'examples/test/creation.dc'
fi
if test -f 'include/dcc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/dcc.h'\"
else
echo shar: Extracting \"'include/dcc.h'\" \(10529 characters\)
sed "s/^X//" >'include/dcc.h' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                                d c c . h                                *
X *                                                                         *
X *                            Package : Include files                      *
X *                            Version : 1.0                                *
X *                       CreationDate : 14.08.90                           *
X *                         LastUpDate : 06.12.93                           *
X *                                                                         *
X *      Special definitions and declarations mainly used at runtime.       *
X *                                                                         *
X *                  Portions Copyright 1990 Franz Distler                  *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#ifndef __dcc_h
X#define __dcc_h
X
X#if !defined(FILE) && !defined(RPC_XDR)
X# include <stdio.h>
X#endif
X#include "ipc.h"
X
X/* maximal length of */
X#define MAXPATHNAMELEN	256	/* a process pathname */
X#define MAXFILENAMELEN	14	/* a process filename */
X#ifndef MAXHOSTNAMELEN
X# define MAXHOSTNAMELEN 256	/* a hostname */
X#endif
X
X/* connection types */
X#define CREATION_CONNECTION	1
X#define TRANSACTION_CONNECTION	2
X#define ACCEPT_CONNECTION	3
X#define ABORT_CONNECTION	4
X
X/* constants for the transaction call protocoll */
X#define TRANS_ACCEPT		5	/* transaction accepted */
X#define TRANS_DENIED		6	/* transaction denied */
X
X/* transaction calling modes */
X#define CALL			7	/* call process as well */
X#define DONTCALL		8	/* don't call process */
X
X/* #ifdef iPSC */
X/* where to create the administration process */
X# define ADMIN_NODE	1L
X# define ADMIN_PID	1L
X/* #endif /* iPSC /**/
X
X/* constants specifying administration process' services */
X#define NOTIFY_START		0
X#define NOTIFY_END		1
X#define NOTIFY_ERROR		2
X#define NOTIFY_ACCORTER_ON	3
X#define NOTIFY_ACCORTER_OFF	4
X#define NOTIFY_GETLOCATION	5
X
X/* the type of a process descriptor */
Xstruct PROCESSDESCR {
X	char      processname[MAXPATHNAMELEN]; /* process name */
X	long      pid;                         /* process id */
X	PORTDESCR port;                        /* process port */
X};
X
X#ifndef RPC_XDR
Xtypedef struct PROCESSDESCR PROCESSDESCR;
X#endif /* !RPC_XDR /**/
X
X/* the type of a request sent to the administration process */
Xstruct ADMINREQUEST {
X	int request_type;	/* the request type */
X};
X
X#ifndef RPC_XDR
Xtypedef struct ADMINREQUEST ADMINREQUEST;
X#endif /* !RPC_XDR /**/
X
X/* the type used for sending the configfilename to the administration process */
Xstruct ADMINCFGINFO {
X	char filename[MAXFILENAMELEN];
X};
X
X#ifndef RPC_XDR
Xtypedef struct ADMINCFGINFO ADMINCFGINFO;
X#endif /* !RPC_XDR /**/
X
X/* the type used for getting location info from the administration process */
Xstruct ADMINLOCINFO {
X	char processname[80];                  /* name of process */
X	char processfilename[MAXFILENAMELEN];  /* corresponding file name */
X	char creator_location[MAXHOSTNAMELEN]; /* location of creator process */
X	char hostname[MAXHOSTNAMELEN];	       /* target host name */
X};
X
X#ifndef RPC_XDR
Xtypedef struct ADMINLOCINFO ADMINLOCINFO;
X#endif /* !RPC_XDR /**/
X
X#ifdef iPSC
X/* port informations of creator and administration process */
Xtypedef struct {
X	PORTDESCR creator_port;
X	PORTDESCR admin_port;
X} PORTSDATA;
X#endif
X
X/* specific informations of a process */
Xstruct PROCESSDATA {
X	char      processname[MAXPATHNAMELEN]; /* process name */
X	long      pid;                         /* process pid */
X	PORTDESCR port;                        /* process port */
X	int       error;                       /* error flag */
X};
X
X#ifndef RPC_XDR
Xtypedef struct PROCESSDATA PROCESSDATA;
X#endif /* !RPC_XDR /**/
X
X/* specific informations of a process
X * NOTE: request size mus be greater than MAXIDLEN of config.h! 
X */
Xstruct TRANSDATA {
X	char request[40]; /* transaction request */
X	int  reply;       /* transaction reply */
X};
X
X#ifndef RPC_XDR
Xtypedef struct TRANSDATA TRANSDATA;
X#endif /* !RPC_XDR /**/
X
X#ifndef RPC_XDR
X
X/* macro to determine the maximum of x and y */
X#define MAX(x,y)	((x >= y) ? x : y)
X
X#define XDRRESIZE(s)	s * 4 + 100
X
X#define SIZEOFLONG	64
X
X/* 
X * library functions in alphabetic order 
X */
X
X#if defined(__STDC__) && !defined(NO_PROTOTYPE)
X# define FUNCPROTO(type,id,args)	extern type id args
X#else
X# define FUNCPROTO(type,id,args)	extern type id()
X#endif /* __STDC__ /**/
X
XFUNCPROTO(int, accept_connection, (CONNECTIONDESCR *, PORTDESCR *, unsigned));
X#if defined(HPUX) || defined(UNICOS) || defined(LINUX)
XFUNCPROTO(void, _catch, (int));
X#else
XFUNCPROTO(int, _catch, (int));
X#endif /* HPUX || UNICOS || LINUX /**/
XFUNCPROTO(int, _check_process, (PROCESSDESCR));
XFUNCPROTO(int, _choose_host, (PORTDESCR *, char *));
XFUNCPROTO(int, _close_connection, (CONNECTIONDESCR *));
XFUNCPROTO(int, _convert_argv_to_port, (PORTDESCR *, PORTDESCR *, char **));
XFUNCPROTO(int, _convert_port_to_argv, (char **, PORTDESCR, PORTDESCR));
XFUNCPROTO(int, _create_port, (PORTDESCR *));
X#ifndef iPSC
XFUNCPROTO(int, _create_dcadmin, (char *, char *));
X#endif /* !iPSC /**/
XFUNCPROTO(int, _create_process, (char *, char *, char *, PROCESSDESCR *));
X#ifdef HETEROGENEOUS
XFUNCPROTO(int, _decode, (char *, bool_t (*)()));
X#endif /* HETEROGENEOUS /**/
XFUNCPROTO(int, _delete_port, (PORTDESCR *));
XFUNCPROTO(int, _destroy_process, (PROCESSDESCR, int));
XFUNCPROTO(int, _display_connection_port_info, (char *, char *, CONNECTIONDESCR));
XFUNCPROTO(int, _display_port_info, (char *, char *, PORTDESCR));
XFUNCPROTO(int, _display_processdata_info, (char *, char *, PROCESSDATA));
XFUNCPROTO(int, _display_processdescr_info, (char *, char *, PROCESSDESCR));
X#ifdef HETEROGENEOUS
XFUNCPROTO(int, _encode, (char *, bool_t (*)(), unsigned long *));
X#endif /* HETEROGENEOUS /**/
XFUNCPROTO(int, _get_location_from_admin, (char *, char *, char **));
X#ifdef iPSC
XFUNCPROTO(int, _get_ports, (CONNECTIONDESCR *));
X#endif /* iPSC /**/
XFUNCPROTO(int, _get_transaction_call, (char *));
XFUNCPROTO(int, _input_port_info, (PORTDESCR *));
XFUNCPROTO(int, _make_connection, (CONNECTIONDESCR *, PORTDESCR *, PORTDESCR *, unsigned));
XFUNCPROTO(int, _make_transaction_call, (PORTDESCR, char *, int));
XFUNCPROTO(int, _receive_connection_type_or_answer, ());
X#ifdef iPSC
XFUNCPROTO(int, _receive_ports_data, ());
X#endif /* iPSC /**/
XFUNCPROTO(int, _receive_process_data, (PROCESSDATA *));
XFUNCPROTO(int, _recv_data, (CONNECTIONDESCR *, char *, int, unsigned));
XFUNCPROTO(int, _recv_data_encoded, (CONNECTIONDESCR *, char *, int (*)(), int));
X#ifndef iPSC
XFUNCPROTO(int, _report_back, ());
X#endif /* !iPSC /**/
XFUNCPROTO(int, _send_connection_type_or_answer, (int));
XFUNCPROTO(int, _send_data, (CONNECTIONDESCR *, char *, int, unsigned));
XFUNCPROTO(int, _send_data_encoded, (CONNECTIONDESCR *, char *, int (*)(), int));
XFUNCPROTO(int, _send_process_data, ());
XFUNCPROTO(int, _set_signals, ());
XFUNCPROTO(int, _notify_admin_process, (int));
X#ifdef HETEROGENEOUS
XFUNCPROTO(bool_t, xdr_PORTDESCR,       (XDR *, PORTDESCR *));
XFUNCPROTO(bool_t, xdr_CONNECTIONDESCR, (XDR *, CONNECTIONDESCR *));
XFUNCPROTO(bool_t, xdr_PROCESSDESCR,    (XDR *, PROCESSDESCR *));
XFUNCPROTO(bool_t, xdr_ADMINREQUEST,    (XDR *, ADMINREQUEST *));
XFUNCPROTO(bool_t, xdr_ADMINLOCINFO,    (XDR *, ADMINLOCINFO *));
XFUNCPROTO(bool_t, xdr_ADMINCFGINFO,    (XDR *, ADMINCFGINFO *));
XFUNCPROTO(bool_t, xdr_PROCESSDATA,     (XDR *, PROCESSDATA *));
XFUNCPROTO(bool_t, xdr_TRANSDATA,       (XDR *, TRANSDATA *));
X#endif /* HETEROGENEOUS /**/
XFUNCPROTO(int, _RuntimeError, (char *));
XFUNCPROTO(int, _SendTransCallReply, (int));
X
X/*
X * external declarations of global variables
X */
X
Xextern int
X    Errno,
X    errno,
X    _debugflush;
X
Xextern char 
X     _processprefix[],
X    *_programname,
X    *_processname,
X    *sys_errlist[];
X
Xextern PORTDESCR 
X    _own_port,
X    _creator_port,
X    _admin_port;
X
Xextern CONNECTIONDESCR
X    _con_port;
X
Xextern FILE
X    *_debugout;
X
X#ifdef HETEROGENEOUS
Xextern char 
X    *_dcc_buf,
X    *_xdr_size_buf;
Xextern unsigned long
X    _xdr_size;
Xextern XDR 
X    encode_xdrs,
X    decode_xdrs,
X    _xdr_encode_size_xdrs,
X    _xdr_decode_size_xdrs;
X#endif /* HETEROGENEOUS /**/
X
X/* 
X * special utilities for debug purpose only 
X */
X
Xextern int
X    _debug_ipc,
X    _debug_convert,
X    _debug_control,
X    _debug_creation,
X    _debug_kill,
X    _debug_transaction;
X
X#define PRINT_DEBUG_ALL			{_debug_ipc = 1; \
X					_debug_convert = 1; \
X					_debug_control = 1; \
X					_debug_creation = 1; \
X					_debug_kill = 1; \
X					_debug_transaction = 1;}
X#define PRINT_DEBUG_IPC_ON		_debug_ipc         = 1
X#define PRINT_DEBUG_IPC_OFF		_debug_ipc         = 0
X#define PRINT_DEBUG_CONVERT_ON		_debug_convert     = 1
X#define PRINT_DEBUG_CONVERT_OFF		_debug_convert     = 0
X#define PRINT_DEBUG_CONTROL_ON		_debug_control     = 1
X#define PRINT_DEBUG_CONTROL_OFF		_debug_control     = 0
X#define PRINT_DEBUG_CREATION_ON		_debug_creation    = 1
X#define PRINT_DEBUG_CREATION_OFF	_debug_creation    = 0
X#define PRINT_DEBUG_KILL_ON		_debug_kill        = 1
X#define PRINT_DEBUG_KILL_OFF		_debug_kill        = 0
X#define PRINT_DEBUG_TRANSACTION_ON	_debug_transaction = 1
X#define PRINT_DEBUG_TRANSACTION_OFF	_debug_transaction = 0
X
X#endif /* !RPC_XDR /**/
X
X#endif /* !__dcc_h /**/
END_OF_FILE
if test 10529 -ne `wc -c <'include/dcc.h'`; then
    echo shar: \"'include/dcc.h'\" unpacked with wrong size!
fi
# end of 'include/dcc.h'
fi
if test -f 'include/functions.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/functions.h'\"
else
echo shar: Extracting \"'include/functions.h'\" \(10104 characters\)
sed "s/^X//" >'include/functions.h' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                          f u n c t i o n s . h                          *
X *                                                                         *
X *                            Package : Include files                      *
X *                            Version : 2.0                                *
X *                       CreationDate : 19.08.90                           *
X *                         LastUpDate : 04.11.91                           *
X *                                                                         *
X *           Compiler functions with parameter and return types.           *
X *                                                                         *
X *     Copyright (C) 1990-1994 by Franz Distler and Christoph Pleier.      *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#ifndef __functions_h
X#define __functions_h
X
XFUNCPROTO(SELECTATTR *, add_guard_to_attr, (SELECTATTR *, char *));
XFUNCPROTO(int         , add_includefile_to_list, (char *));
XFUNCPROTO(IDL_ATTR   *, add_init_declarator_list, (IDL_ATTR *, IDL_ATTR *));
XFUNCPROTO(SYMBTABEL  *, add_parm_type, (DS_ATTR *, SYMBTABEL *));
XFUNCPROTO(SYMBTABEL  *, add_process_info, (SYMBTABEL *, SYMBTABEL *, SYMBTABEL *));
XFUNCPROTO(SQL_ATTR   *, add_spec_qual_list, (SQL_ATTR *, SQL_ATTR *));
XFUNCPROTO(STL_ATTR   *, add_struct_declaration, (STL_ATTR *, STL_ATTR *));
XFUNCPROTO(SDL_ATTR   *, add_struct_declarator, (SDL_ATTR *, SDL_ATTR *));
XFUNCPROTO(SYMBTABEL  *, add_struct_or_union_info, (SU_ATTR *, SYMBTABEL *, STL_ATTR *));
XFUNCPROTO(SYMBTABEL  *, add_transaction_info, (SYMBTABEL *, DS_ATTR *, SYMBTABEL *));
XFUNCPROTO(SYMBTABEL  *, add_transaction_label, (SYMBTABEL *));
XFUNCPROTO(SYMBTABEL  *, add_trans_info, (SYMBTABEL *, SYMBTABEL *));
XFUNCPROTO(TQL_ATTR   *, add_type_qualifier, (TQL_ATTR *, TQL_ATTR *));
XFUNCPROTO(int         , append_file, (FILE *, FILE *));
XFUNCPROTO(int         , blk_pop, ());
XFUNCPROTO(int         , blk_push, ());
XFUNCPROTO(int         , build_includefile, ());
XFUNCPROTO(int         , build_makefile, ());
XFUNCPROTO(int         , build_xdrfile, ());
XFUNCPROTO(SYMBTABEL  *, check_transaction, (SYMBTABEL *));
XFUNCPROTO(char        , choose_void_type, ());
XFUNCPROTO(int         , close_files, ());
XFUNCPROTO(char       *, convert_d_to_string, (char *, D_ATTR *));
XFUNCPROTO(char       *, convert_dd_to_string, (char *, DD_ATTR *));
XFUNCPROTO(char       *, convert_ds_to_string, (char *, DS_ATTR *));
XFUNCPROTO(char       *, convert_id_to_string, (char *, ID_ATTR *));
XFUNCPROTO(char       *, convert_idl_to_string, (char *, IDL_ATTR *));
XFUNCPROTO(char       *, convert_p_to_string, (char *, P_ATTR *));
XFUNCPROTO(char       *, convert_scs_to_string, (char *, SCS_ATTR *));
XFUNCPROTO(char       *, convert_sd_to_string, (char *, SD_ATTR *));
XFUNCPROTO(char       *, convert_sdl_to_string, (char *, SDL_ATTR *));
XFUNCPROTO(char       *, convert_sql_to_string, (char *, SQL_ATTR *));
XFUNCPROTO(char       *, convert_st_to_string, (char *, ST_ATTR *));
XFUNCPROTO(char       *, convert_stl_to_string, (char *, STL_ATTR *));
XFUNCPROTO(char       *, convert_su_to_string, (char *, SU_ATTR *));
XFUNCPROTO(char       *, convert_sus_to_string, (char *, SUS_ATTR *, char));
XFUNCPROTO(char       *, convert_tq_to_string, (char *, TQ_ATTR *));
XFUNCPROTO(char       *, convert_tql_to_string, (char *, TQL_ATTR *));
XFUNCPROTO(char       *, convert_ts_to_string, (char *, TS_ATTR *, char));
XFUNCPROTO(ACCEPTATTR *, create_accept_attribute, (SYMBTABEL *, COMPATTR *));
XFUNCPROTO(ARG_LIST   *, create_arg_list_elem, (char *));
XFUNCPROTO(COMPATTR   *, create_compound_attribute, (char *, char *));
XFUNCPROTO(POSTATTR   *, create_post_expr_attr, (char *));
XFUNCPROTO(SELECTATTR *, create_select_attribute, (int, ACCEPTATTR *, char *));
XFUNCPROTO(TRANSATTR  *, create_trans_attr, (POSTATTR *, SYMBTABEL *, ARG_LIST *));
XFUNCPROTO(int         , display_comp_attribute, (COMPATTR *));
XFUNCPROTO(int         , display_help, ());
XFUNCPROTO(int         , display_select_attribute, (SELECTATTR *));
X#ifdef DEBUGFLAG
XFUNCPROTO(int         , display_struct_type_list, ());
XFUNCPROTO(int         , display_symbol_table, ());
XFUNCPROTO(int         , display_symbtab_entry, (SYMBTABEL *));
X#endif /* DEBUGFLAG /**/
XFUNCPROTO(int         , display_usage, ());
XFUNCPROTO(int         , display_version, ());
XFUNCPROTO(SYMBTABEL  *, enter_symbtabel, (char *));
XFUNCPROTO(char       *, evaluate_declaration, (DS_ATTR *, IDL_ATTR *));
XFUNCPROTO(char       *, gencode_function, (DS_ATTR *, D_ATTR *, char *, COMPATTR *));
XFUNCPROTO(char       *, generate_destroy_process_code, (char *));
XFUNCPROTO(int         , gencode_process_body, (SYMBTABEL *, COMPATTR *));
XFUNCPROTO(char       *, generate_call_transaction_code, (char *, char *, SYMBTABEL *, ARG_LIST *, char *));
XFUNCPROTO(char       *, generate_process_creation_code, (SYMBTABEL *, ARG_LIST *, char *));
XFUNCPROTO(char       *, generate_select_code, (SELECTATTR *));
XFUNCPROTO(char       *, generate_transaction_code, (ACCEPTATTR *));
XFUNCPROTO(char       *, generate_treturn_code, (char *));
XFUNCPROTO(int         , gen_call_transaction_routines, (SYMBTABEL *));
XFUNCPROTO(ES_ATTR    *, gen_enum_specifier_attr, (char *));
XFUNCPROTO(DS_ATTR    *, gen_declaration_specifiers_attr, (SCS_ATTR *, TS_ATTR *, TQ_ATTR *, DS_ATTR *));
XFUNCPROTO(D_ATTR     *, gen_declarator_attr, (P_ATTR *, DD_ATTR *));
XFUNCPROTO(DD_ATTR    *, gen_direct_decl_attr, (char, SYMBTABEL *, D_ATTR *, DD_ATTR *, char *));
XFUNCPROTO(ID_ATTR    *, gen_init_declarator_attr, (D_ATTR *, char *));
XFUNCPROTO(IDL_ATTR   *, gen_init_declarator_list_attr, (ID_ATTR *));
XFUNCPROTO(P_ATTR     *, gen_pointer_attr, (int, TQL_ATTR *, P_ATTR *));
XFUNCPROTO(int         , gen_process_creation_routine, (SYMBTABEL *));
XFUNCPROTO(SYMBTABEL  *, gen_process_file, (SYMBTABEL *));
XFUNCPROTO(SQL_ATTR   *, gen_spec_qual_list_attr, (TS_ATTR *, TQ_ATTR *));
XFUNCPROTO(SCS_ATTR   *, gen_storage_class_spec_attr, (char));
XFUNCPROTO(ST_ATTR    *, gen_struct_declaration_attr, (SQL_ATTR *, SDL_ATTR *));
XFUNCPROTO(SD_ATTR    *, gen_struct_declarator_attr, (D_ATTR *, char *));
XFUNCPROTO(SDL_ATTR   *, gen_struct_declarator_list_attr, (SD_ATTR *));
XFUNCPROTO(SU_ATTR    *, gen_struct_or_union_attr, (char));
XFUNCPROTO(SUS_ATTR   *, gen_struct_or_union_spec_attr, (SU_ATTR *, SYMBTABEL *, STL_ATTR *));
XFUNCPROTO(STL_ATTR   *, gen_stru_declaration_list_attr, (ST_ATTR *));
XFUNCPROTO(TQ_ATTR    *, gen_type_qualifier_attr, (char));
XFUNCPROTO(TQL_ATTR   *, gen_type_qualifier_list_attr, (TQ_ATTR *));
XFUNCPROTO(TS_ATTR    *, gen_type_specifier_attr, (int, ES_ATTR *, SUS_ATTR *, SYMBTABEL *));
XFUNCPROTO(SYMBTABEL  *, get_process, (SYMBTABEL *));
XFUNCPROTO(int         , hash, (char *));
XFUNCPROTO(int         , init_symbtab, ());
XFUNCPROTO(void        , is_process, (SYMBTABEL *));
XFUNCPROTO(void        , is_transaction, (SYMBTABEL *));
XFUNCPROTO(ARG_LIST   *, link_arguments, (ARG_LIST *, ARG_LIST *));
XFUNCPROTO(SYMBTABEL  *, link_parameters, (SYMBTABEL *, SYMBTABEL *));
XFUNCPROTO(SELECTATTR *, link_select_attributes, (SELECTATTR *, SELECTATTR *));
XFUNCPROTO(SYMBTABEL  *, link_transactions, (SYMBTABEL *, SYMBTABEL *));
XFUNCPROTO(SYMBTABEL  *, lookup_symbtabel, (char *));
XFUNCPROTO(SYMBTABEL  *, make_function, (DS_ATTR *, D_ATTR *));
XFUNCPROTO(SYMBTABEL  *, make_parameter, (SYMBTABEL *));
XFUNCPROTO(SYMBTABEL  *, make_process, (SYMBTABEL *));
XFUNCPROTO(SYMBTABEL  *, make_process_def, (SYMBTABEL *));
XFUNCPROTO(SYMBTABEL  *, make_structure, (SYMBTABEL *));
XFUNCPROTO(int         , make_structure_definition, (DS_ATTR *, IDL_ATTR *));
XFUNCPROTO(SYMBTABEL  *, make_transaction, (SYMBTABEL *));
XFUNCPROTO(int         , make_typedef_name, (DS_ATTR *, IDL_ATTR *));
XFUNCPROTO(DS_ATTR    *, mark_struct_or_type_def_for_XDR, (DS_ATTR *));
XFUNCPROTO(int         , parse_options, (int , char **));
XFUNCPROTO(void        , reenter_process_comps, (SYMBTABEL *));
XFUNCPROTO(void        , reenter_transactions, (IDENTCHAIN *));
XFUNCPROTO(void        , reenter_transaction_params, (SYMBTABEL *));
XFUNCPROTO(SYMBTABEL  *, store_struct_or_type_def, (SYMBTABEL *));
XFUNCPROTO(char       *, strmalloc, (char *));
XFUNCPROTO(char       *, strsave, (char *));
XFUNCPROTO(IDENTCHAIN *, update_post_expr_attr, (IDENTCHAIN *, SYMBTABEL *));
XFUNCPROTO(int         , yyerror, (char *));
XFUNCPROTO(int         , yymark, ());
XFUNCPROTO(char       *, yytoken, ());
XFUNCPROTO(char       *, yywhere, ());
XFUNCPROTO(int         , yywrap, ());
XFUNCPROTO(int         , Error, (char *, char *));
XFUNCPROTO(int         , Free, (char *));
XFUNCPROTO(char       *, Malloc, (unsigned));
XFUNCPROTO(int         , Panic, (char *));
XFUNCPROTO(int         , SetSignals, ());
XFUNCPROTO(char       *, Strcat, (char *, char *));
XFUNCPROTO(char       *, Strcatmany, ());
XFUNCPROTO(int         , Warning, (char *));
X
X#endif /* !__functions_h /**/
END_OF_FILE
if test 10104 -ne `wc -c <'include/functions.h'`; then
    echo shar: \"'include/functions.h'\" unpacked with wrong size!
fi
# end of 'include/functions.h'
fi
echo shar: End of archive 8 \(of 18\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
