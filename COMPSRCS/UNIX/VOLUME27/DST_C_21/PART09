Newsgroups: comp.sources.unix
From: pleierc@informatik.tu-muenchen.de (Christoph Pleier)
Subject: v27i183: distributed-c-2.1 - Distributed C Development Environment, V2.1, Part09/18
References: <1.756634932.28500@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: pleierc@informatik.tu-muenchen.de (Christoph Pleier)
Posting-Number: Volume 27, Issue 183
Archive-Name: distributed-c-2.1/part09

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 9 (of 18)."
# Contents:  dcanalyse/dcanalyse.dc dcc/code_others.c dcc/code_select.c
#   dcc/symb_general.c dcinstall/Prepare.c examples/config/system.WAN
#   lib/control.c
# Wrapped by vixie@gw.home.vix.com on Thu Dec 23 00:12:01 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dcanalyse/dcanalyse.dc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcanalyse/dcanalyse.dc'\"
else
echo shar: Extracting \"'dcanalyse/dcanalyse.dc'\" \(11121 characters\)
sed "s/^X//" >'dcanalyse/dcanalyse.dc' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                         d c a n a l y s e . d c                         *
X *                                                                         *
X *                            Package : System Analyser                    *
X *                            Version : 1.0                                *
X *                       CreationDate : 05.03.92                           *
X *                         LastUpDate : 13.03.92                           *
X *                                                                         *
X * The Distributed C source code containing all process definitions needed *
X * for building the system analyser.                                       *
X *                                                                         *
X *                 Copyright (C) 1992 by Christoph Pleier                  *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#undef stdin
X#undef stdout
X#undef stderr
X#include "cfgparsers.h"
X#include "analyse.h"
X#define DCANALYSE
X#include "version.h"
X
X/****************************************************************************
X *         name : tester                                                    *
X *         type : process specification                                     *
X *   returntype : none                                                      *
X *   parameters : none                                                      *
X *  description : Specification of the process tester which will be started *
X *                during testing.                                           *
X ****************************************************************************/
Xprocess spec tester()
X{
X    /* receive and send data */
X    trans struct trans_data_t TransmitData(struct trans_data_t data);
X}
X
X/****************************************************************************
X *         name : measure                                                   *
X *         type : process specification                                     *
X *   returntype : none                                                      *
X *   parameters : verbose, trial_num, hosts                                 *
X *  description : Specification of the process measure which will be started*
X *                at each host to perform the measuring.                    *
X ****************************************************************************/
Xprocess spec measure(int verbose, int num)
X{
X    /* Get an order */
X    trans int PutOrder(struct order_t order_p);
X
X    /* Send back avarage results */
X    trans struct order_t GetResult();
X}
X
X/****************************************************************************
X *         name : tester                                                    *
X *         type : process definition                                        *
X *   returntype : none                                                      *
X *   parameters : none                                                      *
X *  description : Definition of the body of the process tester.             *
X ****************************************************************************/
Xprocess body tester()
X{
X    int i;
X
X    for(i = 1; i <= COMMUNICNUM; i++) {
X        accept TransmitData(data) {
X	    treturn(data);
X        }
X    }
X
X    exit(0);
X} /* process body tester */
X
X/****************************************************************************
X *         name : measure                                                   *
X *         type : process definition                                        *
X *   returntype : none                                                      *
X *   parameters : none                                                      *
X *  description : Definition of the body of the process measure.            *
X ****************************************************************************/
Xprocess body measure(verbose, num, hosts)
X{
X    int i, j; 
X    long start, crea_time, crea_sum_time, comm_time, comm_sum_time;
X    struct order_t order;
X    struct trans_data_t c_param, c_result;
X    process tester t_pdescr;
X
X
X    while(1) {
X
X        accept PutOrder(order) {
X            order = order_p;
X        }
X
X	if (order.code == DO_TERMINATE)
X	    exit(0);
X
X	crea_sum_time = comm_sum_time = 0;
X
X        for(i = 1; i<= num; i++) {
X
X            start = time(NULL);
X	    if (verbose) {
X	        printf("    [%2d] %12s: ", i, order.hostname); 
X		fflush(stdout);
X	    }
X            t_pdescr = create tester() at host(order.hostname);
X            crea_time = time(NULL) - start;
X	    crea_sum_time += crea_time;
X            if (verbose) {
X                printf("creation: %2d s", crea_time);
X		fflush(stdout);
X            }
X
X            start = time(NULL);
X    	    for(j = 1; j <= COMMUNICNUM; j++) {
X                c_result = t_pdescr@TransmitData(c_param);
X	    }
X            comm_time = time(NULL) - start;
X	    comm_sum_time += comm_time;
X            if (verbose) {
X                printf(", communication: %2d s\n", comm_time);
X		fflush(stdout);
X            }
X
X        } /* for(i) */
X
X        order.crea_time = (int) crea_sum_time / num;
X        order.comm_time = (int) comm_sum_time / num;
X
X        accept GetResult() {
X	    treturn(order);
X        } /* accept */
X
X    }
X} /* process body measure */
X
X/*
X * global variables of process 'main' 
X */
X
XSYMBTABEL *symbtab, 
X          *last_symb;
Xint        append, 
X           verbose, 
X           alltargets,
X           no_measure,
X           trial_num;
Xchar      *outputfilename, 
X           cfgfilename[200];
Xstruct targetlist_t *first_target, *last_target;
X
X/****************************************************************************
X *         name : main                                                      *
X *         type : function definition                                       *
X *   returntype : int                                                       *
X *   parameters : none                                                      *
X *  description : Definition of the main function building the main program.*
X ****************************************************************************/
Xmain(argc, argv)
Xint   argc;
Xchar *argv[];
X{
X    int i, flag;
X    struct order_t order;
X    FILE *outputfp;
X    SYMBTABEL *symbol, *symbol2;
X    struct targetlist_t *act_target;
X    process measure pdescr;
X
X    /* display start message */
X    fprintf(stderr, "%s\n%s\n%s\n\n", progname, version, copyright);
X
X    /* some initializations */
X    cfgfilename[0] = 0;
X    append = verbose = alltargets = no_measure = FALSE;
X    trial_num = 1;
X    outputfilename = NULL;
X    first_target = last_target = NULL;
X
X    /* is there any job? */
X    if (argc == 1) {
X	fputs("Error: nothing to do\n\n", stderr);
X	DisplayUsage();
X	exit(ERROR);
X    }
X
X    /* parse command line */
X    if (ParseOptions(argc, argv)) {
X        DisplayUsage();
X        exit(ERROR);
X    }
X
X    /* interpret system configuration file */
X    printf("Parsing system configuration file  - \"%s\"\n", cfgfilename);
X    if (!(yyin = fopen(cfgfilename, "r"))) {
X        fprintf(stderr, "Error: can't open system configuration file \"%s\"\n",
X            cfgfilename);
X        exit(ERROR);
X    } else {
X        (void) yyparse();
X        (void) close(yyin);
X    }
X
X    if (append && outputfilename) {
X        fprintf(stderr, "Error: don't know where to write results to!\n");
X	fprintf(stderr, "       option '-append' and an output file specified!\n");
X        exit(ERROR);
X    }
X
X    if (!append && !outputfilename)
X	outputfp = stdout;
X
X    if (append) {
X	if (!(outputfp = fopen(cfgfilename, "a+"))) {
X            fprintf(stderr, "Error: can't open system configuration file \"%s\" for appending\n",
X                cfgfilename);
X            exit(ERROR);
X	}
X    } 
X
X    if (outputfilename) {
X	if (!(outputfp = fopen(outputfilename, "w"))) {
X            fprintf(stderr, "Error: can't open output file \"%s\"\n", outputfilename);
X            exit(ERROR);
X	}
X    }
X
X    fprintf(outputfp, "\n# ----------------------------------------------------------------------------\n"),
X    fprintf(outputfp, "# cost informations generated by dcanalyse\n\n");
X    fprintf(outputfp, "costs informations {\n\n");
X
X    /* perform measuring */
X    for(symbol = symbtab; symbol; symbol = symbol->next) {
X
X	if (symbol->type != S_HOST)
X	    continue;
X
X	if (!alltargets) {
X	    flag = FALSE;
X	    for(act_target = first_target; act_target; act_target = act_target->next) {
X		if (!strcmp(act_target->hostname, symbol->name)) {
X		    flag = TRUE;
X		    break; 
X		}
X	    }
X	    if (!flag)
X		continue;
X	}
X
X	if (!no_measure)
X	    pdescr = create measure(verbose, trial_num) at host(symbol->name);
X
X        for(symbol2 = symbtab; symbol2; symbol2 = symbol2->next) {
X
X	    if (symbol2->type != S_HOST)
X	        continue;
X
X	    printf("\nMeasuring %s -> %s\n", symbol->name, symbol2->name);
X	    fflush(stdout);
X
X	    if (!no_measure) {
X	        order.code = DO_MEASURING;
X	        strcpy(order.hostname, symbol2->name);
X	        pdescr@PutOrder(order);
X
X	        order = pdescr@GetResult();
X	
X	        if (verbose) {
X		    printf("    Average result: creation : %d s, communication: %d s\n",
X		        order.crea_time, order.comm_time);
X		    fflush(stdout);
X	        }
X
X	        fprintf(outputfp, "    %15s -> %15s: %d, %d\n",
X		    symbol->name, symbol2->name, order.crea_time, order.comm_time);
X	    } else {
X		fprintf(outputfp, "    %15s -> %15s: %d, %d\n",
X		    symbol->name, symbol2->name, 5, 10);
X	    }
X
X	    fflush(outputfp);
X    
X        } /* for(symbol2) */
X
X	if (!no_measure) {
X            order.code = DO_TERMINATE;
X            order.hostname[0] = 0;
X            pdescr@PutOrder(order);
X	}
X
X	fputs("\n", outputfp);
X
X    } /* for(symbol) */
X
X    fprintf(outputfp, "}\n");
X    fclose(outputfp);
X
X    exit(OK);
X} /* main */
END_OF_FILE
if test 11121 -ne `wc -c <'dcanalyse/dcanalyse.dc'`; then
    echo shar: \"'dcanalyse/dcanalyse.dc'\" unpacked with wrong size!
fi
# end of 'dcanalyse/dcanalyse.dc'
fi
if test -f 'dcc/code_others.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcc/code_others.c'\"
else
echo shar: Extracting \"'dcc/code_others.c'\" \(12215 characters\)
sed "s/^X//" >'dcc/code_others.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                        c o d e _ o t h e r s . c                        *
X *                                                                         *
X *                            Package : Compiler                           *
X *                            Version : 1.1                                *
X *                       CreationDate : 26.07.90                           *
X *                         LastUpDate : 20.12.93                           *
X *                                                                         *
X * The functions to generate the header of the main program and to build   *
X * the code of function definitions.                                       *
X *                                                                         *
X *                  Portions Copyright 1990 Franz Distler                  *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include "config.h"
X#include "extern.h"
X#include "functions.h"
X#include "com_Errno.h"
X#include "timeout.h"
X
X/******************************************************************************
X * gencode_function()                                                         *
X *                                                                            *
X * Generates special code for the function main of the main process (first    *
X * started process) or writes code for a function definition to 'funcfile'.   *
X *                                                                            *
X * Return values: pointer to generated code string upon success /             *
X *                NULL during error handling                                  *
X ******************************************************************************/
Xchar *
Xgencode_function(decl_spec, attr, decl_list, comp_stat)
XDS_ATTR  *decl_spec;
XD_ATTR   *attr;
Xchar     *decl_list;
XCOMPATTR *comp_stat;
X{
X    register int i, length;
X    register char *cs;
X    register struct include_list *inclptr;
X    DD_ATTR *dd_attr;
X    SYMBTABEL *symbol, *sptr, *actions;
X
X    if (errflag || !attr || !comp_stat) /* error handling! */
X	return(NULL);
X#ifdef CODEDEBUG
X    fputs("[code] ***** gencode_function():\n", debugfile);
X#endif /* CODEDEBUG /**/
X
X    symbol = NULL;
X    for(dd_attr = attr->direct_decl; dd_attr; ) {
X	switch(dd_attr->type) {
X	case DD_ATTR_IDENT:
X    	    symbol = dd_attr->ident;
X	    dd_attr = NULL; /* leave loop! */
X	    break;
X	case DD_ATTR_BRACED:
X	    dd_attr = dd_attr->info.declarator->direct_decl;
X	    break;
X	case DD_ATTR_ARRAY:
X	case DD_ATTR_FUNC:
X	    dd_attr = dd_attr->info.comp.direct_decl;
X	    break;
X	default:
X	    Panic("unknown DD_ATTR type in make_function()");
X	} /* switch */
X    }
X    if (!symbol)
X	Panic("identifier of function definition not found");
X
X    if (!strcmp("main", symbol->name)) {
X
X	mainflag = TRUE;
X
X        if (infoflag) {
X	    printf("%s generating code for function 'main'\n", infoprefix);
X	    fflush(stdout);
X        }
X        /* create output file */
X        strcpy(outputfilename, filenameprefix);
X        length = MAXFILENAMELEN - strlen(MAINFILEEXT);
X        if (strlen(filenameprefix) <= length)
X	    strcat(outputfilename, MAINFILEEXT);
X        else
X            strcpy(&outputfilename[length], MAINFILEEXT);
X        if (!(outfile = fopen(outputfilename, "w"))) {
X	    fprintf(stderr, "Error: impossible to open output file '%s'\n",
X	        outputfilename);
X	    exit(EXIT_FOPEN);
X        }
X
X        fprintf(outfile, "/* main */\n\n");
X        fputs("/*\n", outfile);
X        for(i = 0; *headerstr[i]; ++i)
X	    fprintf(outfile, " * %s\n", headerstr[i]);
X        fputs(" */\n\n", outfile);
X        fprintf(outfile, "#include \"%s\"\n\n", inclfilename);
X
X	cs = strmalloc("int              Errno;\n");
X#ifdef UNICOS
X	cs = Strcat(cs, "int              errno;\n");
X#endif
X#ifdef iPSC
X	cs = Strcat(cs, "long            _pidcount;\n");
X#endif /* iPSC /**/
X	cs = Strcat(cs, "char            *_programname;\n");
X	cs = Strcat(cs, "char            *_processname;\n");
X	cs = Strcat(cs, "char             _processprefix[80];\n");
X	cs = Strcat(cs, "DCC_PARAMS       dcc_par;\n");
X	cs = Strcat(cs, "DCC_RESULTS      dcc_res;\n");
X	cs = Strcat(cs, "PORTDESCR        _own_port;\n");
X	cs = Strcat(cs, "PORTDESCR        _creator_port; /* unused but needed! */\n");
X	cs = Strcat(cs, "PORTDESCR        _admin_port;\n");
X	cs = Strcat(cs, "CONNECTIONDESCR  _con_port;\n");
X#ifdef HETEROGENEOUS
X	cs = Strcat(cs, "XDR              encode_xdrs;\n");
X	cs = Strcat(cs, "XDR              decode_xdrs;\n");
X	cs = Strcat(cs, "XDR              _xdr_encode_size_xdrs;\n");
X	cs = Strcat(cs, "XDR              _xdr_decode_size_xdrs;\n");
X	cs = Strcat(cs, "char            *_dcc_buf;\n");
X	cs = Strcat(cs, "unsigned long    _dcc_buf_size;\n");
X	cs = Strcat(cs, "char            *_xdr_size_buf;\n");
X#endif /* HETEROGENEOUS /**/
X	cs = Strcat(cs, "\n");
X	if (decl_spec)
X	    cs = convert_ds_to_string(cs, decl_spec);
X
X	/* Hier fehlt noch der environment parameter: argc, argv, envp ! */
X	cs = Strcatmany(cs, 7, "\nmain(argc, argv, envp)\n", 
X	    "int argc;\nchar *argv[];\nchar *envp[];\n{\n",
X	    comp_stat->decls, "PROCESSDESCR admin_pdescr;\n",
X	    "int _opt;\nchar *_configfilename;\n",
X	    "extern int optind;\nextern int opterr;\n",
X	    "extern char *optarg;\n\n");
X
X	cs = Strcat(cs, "/* initialize program and process name */\n");
X	cs = Strcatmany(cs, 3, "_programname = \"", inputfilename, "\";\n");
X	cs = Strcat(cs, "_processname = \"main process\";\n");
X	cs = Strcat(cs, "_set_processprefix();\n");
X#ifdef iPSC
X	cs = Strcat(cs, "_pidcount    = mynode() * 1000;\n");
X#endif /* iPSC /**/
X
X	cs = Strcat(cs, "\t/* control signals */\n");
X	cs = Strcat(cs, "\t_set_signals();\n");
X
X#ifdef HETEROGENEOUS
X	 if (determine_dcc_buf_size) {
X	     /* This version of code determines the buffer size to allocate for
X	      * subsequent encoding/decoding actions. The result is the size
X	      * of the biggest communication structure multiplied by 4.
X	      * But the size needed to encode/decode dynamic structures like 
X	      * trees or list can not be predicted so errors during encoding or
X	      * decoding will be the consequence if the determined buffer is 
X	      *too little.
X	      */
X             cs = Strcat(cs, "\t/* determine size of encode/decode buffer */\n");
X	     cs = Strcat(cs, "\t_dcc_buf_size = 1000;\n");
X             cs = Strcat(cs, "\tDCCBUFRESIZE(PROCESSDATA);\n");
X             for(sptr = symbtab.PstTab[0]; sptr; sptr = sptr->PstNext) {
X                 if (sptr->type != PROCESSDECL)
X                     continue;
X                 if (sptr->info.process.FirstParam) {
X                     cs = Strcatmany(cs, 4, "\tDCCBUFRESIZE(", 
X			    sptr->info.process.upiname, POSTFIXSPECPAR, ");\n");
X                }
X                for(actions=sptr->info.process.FirstTrans; actions; actions=actions->info.trans.NextTrans) {
X                    if (actions->info.trans.FirstParam) {
X                        cs = Strcatmany(cs, 4, "\tDCCBUFRESIZE(", actions->info.trans.uptiname, 
X			    POSTFIXTRANSPAR, ");\n");
X                    }
X                    cs = Strcatmany(cs, 4, "\tDCCBUFRESIZE(", actions->info.trans.uptiname, 
X		        POSTFIXTRANSRES, ");\n");
X                } /* for */
X            } /* for */
X	} else {
X	    /* This version of code uses a fixed size to allocate for
X	     * the encode/decode buffer!
X	     */
X            cs = Strcat(cs, "\t/* size of encode/decode buffer */\n");
X	    cs = Strcatmany(cs, 3, "\t_dcc_buf_size = ", encode_decode_buf_size, ";\n");
X	}
X        cs = Strcat(cs, "\t/* allocate heap space for encode/decode buffer */\n");
X        cs = Strcat(cs, "\tif (_allocate_encode_decode_buffer(XDRRESIZE(_dcc_buf_size)))\n");
X        cs = Strcat(cs, "\t\t_RuntimeError(\"allocating heap space for encode/decode buffer\");\n");
X#endif /* HETEROGENEOUS /**/
X
X	cs = Strcat(cs, "/* create own port */\n");
X	cs = Strcat(cs, "if (_create_port(&_own_port))\n");
X	cs = Strcat(cs, "_RuntimeError(\"creating own_port\");\n");
X#ifdef iPSC
X	cs = Strcat(cs, "init_port(&_admin_port, ADMIN_NODE, ADMIN_PID);\n");
X	cs = Strcat(cs, "if (_send_filenname_to_admin(dcc_configfilename))\n");
X	cs = Strcat(cs, "_RuntimeError(\"sending configfilename\");\n");
X	cs = Strcat(cs, "if (_notify_admin_process(NOTIFY_START))\n");
X	cs = Strcat(cs, "_RuntimeError(\"notifying administration process\");\n");
X#else
X	cs = Strcat(cs, "/* create administration process */\n");
X	cs = Strcat(cs, "_configfilename = \"\";\n");
X	cs = Strcat(cs, "{\nint i;\n");
X	cs = Strcat(cs, "for(i=1; i<argc; i++) {\n");
X	cs = Strcat(cs, "if (!strcmp(argv[i], \"-cfgfile\")) {\n");
X	cs = Strcat(cs, "_configfilename = argv[++i];\n");
X	cs = Strcat(cs, "break;\n");
X	cs = Strcat(cs, "}\n}\n}\n");
X	cs = Strcat(cs, "if (_create_dcadmin(\"");
X	cs = Strcat(cs, ADMINPATH);
X	cs = Strcat(cs, "\", _configfilename))\n");
X	cs = Strcat(cs, "_RuntimeError(\"creating administration process\");\n");
X#endif /* iPSC /**/
X	cs = Strcat(cs, comp_stat->stats);
X	cs = Strcat(cs, "exit(0);\n");
X	cs = Strcat(cs, "\n}\n");
X    } else {
X
X        if (infoflag) {
X	    printf("%s generating code for function '%s'\n",
X	        infoprefix, symbol->name);
X	    fflush(stdout);
X        }
X
X	if (!funcflag) {
X	    /* create file for functions */
X            (void) strcpy(funcfilename, filenameprefix);
X            length = MAXFILENAMELEN - strlen(FUNCFILEEXT);
X            if (strlen(filenameprefix) <= length)
X	        (void) strcat(funcfilename, FUNCFILEEXT);
X            else
X               (void) strcpy(&funcfilename[length], FUNCFILEEXT);
X            if (!(funcfile = fopen(funcfilename, "w"))) {
X	        fprintf(stderr,"Error: impossible to open file for functions '%s'\n",
X	            funcfilename);
X	        exit(EXIT_FOPEN);
X            }
X            fprintf(funcfile, "/* %s */\n\n", funcfilename);
X            fputs("/*\n", funcfile);
X            for(i = 0; *headerstr[i]; ++i)
X                fprintf(funcfile, " * %s\n", headerstr[i]);
X            fputs(" */\n\n", funcfile);
X	    fprintf(funcfile, "#include \"%s\"\n\n", inclfilename);
X	    funcflag = 1;
X	}
X
X	/* determine the return type of the function; if the return type
X	 * equals a string of length zero, don't generate code for this
X	 * function!
X	 */
X	*convert_buffer = 0;
X	convert_buffer = convert_ds_to_string(convert_buffer, decl_spec);
X	if (*convert_buffer) {
X    	    fprintf(funcfile,"\n%s\n", convert_buffer);
X	    fnextstr = Strcatmany(fnextstr, 2, "extern ", convert_buffer);
X	    *convert_buffer = 0;
X	    convert_buffer = convert_d_to_string(convert_buffer, attr);
X    	    fprintf(funcfile,"%s\n%s{\n%s\n%s\n}\n", 
X	        convert_buffer, decl_list, comp_stat->decls, comp_stat->stats);
X	    fnextstr = Strcatmany(fnextstr, 2, convert_buffer, "();\n");
X	}
X
X        cs = strmalloc("");
X    }
X
X    return(cs);
X} /* gencode_function */
END_OF_FILE
if test 12215 -ne `wc -c <'dcc/code_others.c'`; then
    echo shar: \"'dcc/code_others.c'\" unpacked with wrong size!
fi
# end of 'dcc/code_others.c'
fi
if test -f 'dcc/code_select.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcc/code_select.c'\"
else
echo shar: Extracting \"'dcc/code_select.c'\" \(12482 characters\)
sed "s/^X//" >'dcc/code_select.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                        c o d e _ s e l e c t . c                        *
X *                                                                         *
X *                            Package : Compiler                           *
X *                            Version : 1.1                                *
X *                       CreationDate : 04.09.90                           *
X *                         LastUpDate : 12.03.92                           *
X *                                                                         *
X * The function 'generate_select_code' to build the complete code for a    *
X * select statement.                                                       *
X *                                                                         *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#ifdef HETEROGENEOUS
X# include <rpc/rpc.h>
X#endif
X#include "config.h"
X#include "extern.h"
X#include "functions.h"
X#include "com_Errno.h"
X#include "timeout.h"
X#include "ipc.h"
X#include "dcc.h"
X
X/******************************************************************************
X * generate_select_code()                                                     *
X *                                                                            *
X * Generates the code for a select statement. There are three different types *
X * of select statements. Select statements with only accept alternatives,     *
X * only immediate alternatives and both accept and immediate alternatives.    *
X * NOTE: The last type was not yet implemented!.                              *
X *                                                                            *
X * Return values: pointer to generated code string upon success /             *
X *                NULL upon error or during error handling                    *
X ******************************************************************************/
Xchar *
Xgenerate_select_code(attr)
XSELECTATTR *attr;
X{
X    int            i,
X                   acceptflag,
X                   termntflag,
X                   immedtflag;
X    char           tmpstr[20],
X                   tmpstr1[20], 
X                   tmpstr2[20],
X                  *ptiname,
X                  *uptiname,
X                  *decls,
X                  *stats;
X    register char *cmd;
X    SELECTATTR    *hptr;
X    SYMBTABEL     *symbol,
X                  *params;
X
X    if (errflag || attr->type == ERROR) /* error handling! */
X        return(NULL);
X#ifdef CODEDEBUG
X    fputs("[code] ***** generate_select_code():\n", debugfile);
X    fprintf(debugfile, "[code]       params: attr = %d\n", attr);
X    fputs("[code]       the alternatives are:\n", debugfile);
X    for(hptr = attr, i=1; hptr; hptr = hptr->next, i++) {
X        fprintf(debugfile, "[code] alternative %d:\n", i);
X	fprintf(debugfile, "[code]     guard = \"%s\"\n", hptr->guard);
X	fprintf(debugfile, "[code]     type  = '");
X	switch(hptr->type) {
X	case ALT_ACCEPT:
X	    fprintf(debugfile, "accept");
X	    break;
X	case ALT_TERMINATE:
X	    fprintf(debugfile, "terminate");
X	    break;
X	case ALT_IMMEDIATE:
X	    fprintf(debugfile, "immediate");
X	    break;
X	}
X	fprintf(debugfile, " alternative'\n");
X    } /* for */
X#endif  /* CODEDEBUG /**/
X
X    acceptflag = termntflag = immedtflag = FALSE;
X
X    for(hptr = attr; hptr; hptr = hptr->next) {
X	switch(hptr->type) {
X	case ALT_ACCEPT:
X	    acceptflag = TRUE;
X	    break;
X	case ALT_TERMINATE:
X	    termntflag = TRUE;
X	    break;
X	case ALT_IMMEDIATE:
X	    immedtflag = TRUE;
X	    break;
X	} /* switch */
X    }
X
X    cmd = strmalloc("");
X
X    if (termntflag)
X	cmd = Strcat(cmd, "_notify_admin_process(NOTIFY_ACCORTER_ON);\n");
X
X    cmd = Strcat(cmd, "while(1) {\n");
X
X    if (acceptflag && !immedtflag) {
X	/* case 1:
X	 * only accept alternatives
X	 */
X
X	cmd = Strcat(cmd, "char *request;\n");
X	cmd = Strcat(cmd, "static TRANSDATA transdata;\n\n");
X
X	cmd = Strcat(cmd, "/* get connection */\n");
X	sprintf(tmpstr2, "%d", SELECTCONTIME);
X	cmd = Strcatmany(cmd, 3, "if (_accept_connection(&_con_port, &_own_port, ",
X	    tmpstr2, ")) {\n");
X	cmd = Strcat(cmd, "if (Errno == ETIMEOUT)\n");
X	cmd = Strcat(cmd, "\tErrno = ETSACCEPTCON;\n");
X	cmd = Strcat(cmd, "_RuntimeError(\"accepting connections in select statement\");\n}\n");
X	cmd = Strcat(cmd, "/* check connection type */\n");
X	cmd = Strcat(cmd, "if (_receive_connection_type_or_answer() != TRANSACTION_CONNECTION) {\n");
X	cmd = Strcat(cmd, "if (_send_connection_type_or_answer(ABORT_CONNECTION))\n");
X	cmd = Strcat(cmd, "_RuntimeError(\"sending connection answer\");\n");
X	cmd = Strcat(cmd, "if (_close_connection(&_con_port))\n");
X	cmd = Strcat(cmd, "_RuntimeError(\"closing connection\");\n");
X	cmd = Strcat(cmd, "continue;\n");
X	cmd = Strcat(cmd, "} else {\n");
X	cmd = Strcat(cmd, "if (_send_connection_type_or_answer(ACCEPT_CONNECTION))\n");
X	cmd = Strcat(cmd, "_RuntimeError(\"sending connection answer\");\n");
X	cmd = Strcat(cmd, "}\n");
X	cmd = Strcat(cmd, "/* get transaction request */\n");
X	sprintf(tmpstr2, "%d", SELECTREQTIME);
X	cmd = Strcat(cmd, "if (_recv_data");
X#ifdef HETEROGENEOUS
X	cmd = Strcat(cmd, "_encoded");
X#endif
X	cmd = Strcat(cmd, "(&_con_port, (char *) &transdata, ");
X#if defined(SINGLE) || defined(HOMOGENEOUS)
X	cmd = Strcat(cmd, "sizeof(TRANSDATA), ");
X#else /* HETEROGENEOUS */
X	cmd = Strcat(cmd, "xdr_TRANSDATA, ");
X#endif
X	cmd = Strcatmany(cmd, 2, tmpstr2, ")<0) {\n");
X	cmd = Strcat(cmd, "if (Errno == ETIMEOUT)\n");
X	cmd = Strcat(cmd, "\tErrno = ETSRCVREQUEST;\n");
X	cmd = Strcat(cmd, "_RuntimeError(\"accepting transaction in select statement\");\n");
X	cmd = Strcat(cmd, "}\n");
X	cmd = Strcat(cmd, "request = transdata.request;\n");
X
X        for(hptr = attr, i = 1; hptr; hptr = hptr->next, ++i) {
X	    if (hptr->type == ALT_TERMINATE) {
X	        cmd = Strcat(cmd, "/* terminate alternative */\n");
X		cmd = Strcat(cmd, "if (!strcmp(request, \"TRANS_TERMINATE\")) {\n");
X		cmd = Strcat(cmd, "if (_close_connection(&_con_port))\n");
X    		cmd = Strcat(cmd, "_RuntimeError(\"closing connection\");\n");
X		cmd = Strcat(cmd, "exit(0);\n");
X		cmd = Strcat(cmd, "}\n");
X		continue;
X	    }
X
X	    symbol      = hptr->accept_attr->transaction;
X            ptiname     = symbol->info.trans.ptiname,
X            uptiname    = symbol->info.trans.uptiname;
X
X	    sprintf(tmpstr1, "%d", i);
X	    cmd = Strcatmany(cmd, 3, "/* alternative ", tmpstr1, " */\n");
X	    cmd = Strcatmany(cmd, 3, "if (!strcmp(request, \"", uptiname, "\")");
X	    if (hptr->guard)
X		cmd = Strcatmany(cmd, 3, " && (", hptr->guard, ")) {\n");
X	    else
X		cmd = Strcat(cmd, ") {\n");
X
X	    if (symbol->info.trans.FirstParam) {
X		for(params=symbol->info.trans.FirstParam; params; 
X				       params=params->info.varorpar.NextParam) {
X		    *convert_buffer = 0;
X		    convert_buffer = convert_ds_to_string(convert_buffer, 
X			params->info.varorpar.DataType); 
X            	    cmd = Strcatmany(cmd, 3, convert_buffer, params->name, ";\n");
X		}
X	    }
X	    *convert_buffer = 0;
X	    convert_buffer = convert_ds_to_string(convert_buffer, 
X		symbol->info.trans.ReturnType);
X	    cmd = Strcatmany(cmd, 2, convert_buffer, "_transaction_result;\n\n");
X
X	    cmd = Strcat(cmd, "_SendTransCallReply(TRANS_ACCEPT);\n");
X
X	    if (symbol->info.trans.FirstParam) {
X#ifdef HETEROGENEOUS
X	        /* We must clear the memory where the received data will be 
X		 * stored in, because the xdr routines allocate storage for 
X		 * pointers only if the pointer values equal the NULL pointer!!
X	 	 */
X		cmd = Strcat(cmd, "/* clear structure to handle pointers correctly */\n");
X		cmd = Strcatmany(cmd, 6, "bzero(&dcc_par.", ptiname, ", sizeof(",
X		    uptiname, POSTFIXTRANSPAR, "));\n");
X#endif
X	        cmd = Strcat(cmd, "/* get parameters */\n");
X	        sprintf(tmpstr1, "%d", SELECTPARTIME);
X		cmd = Strcat(cmd, "if (_recv_data");
X#ifdef HETEROGENEOUS
X		cmd = Strcat(cmd, "_encoded");
X#endif
X	        cmd = Strcatmany(cmd, 2, "(&_con_port, (char *) &dcc_par.", ptiname);
X#if defined(SINGLE) || defined(HOMOGENEOUS)
X	        cmd = Strcatmany(cmd, 4, ", sizeof(", uptiname, POSTFIXTRANSPAR, ")");
X#else /* HETEROGENEOUS */
X	        cmd = Strcatmany(cmd, 3, ", xdr_", uptiname, POSTFIXTRANSPAR);
X#endif
X	        cmd = Strcatmany(cmd, 3, ", ", tmpstr1, ") < 0){\n");
X	        cmd = Strcat(cmd,"if (Errno == ETIMEOUT)\nErrno = ETSRCVPARAMS;\n");
X                cmd = Strcat(cmd, "_RuntimeError(\"getting transaction parameters\");\n}\n");
X
X		cmd = Strcat(cmd, "/* initialize parameters */\n");
X		for(params=symbol->info.trans.FirstParam; params; 
X					params=params->info.varorpar.NextParam)
X		    cmd = Strcatmany(cmd, 6, params->name, " = dcc_par.", ptiname, 
X			".", params->name, ";\n");
X	    }
X
X	    decls = hptr->accept_attr->comp_attr->decls;
X	    stats = hptr->accept_attr->comp_attr->stats;
X            if (*decls != 0 || *stats != 0) {
X    	        cmd = Strcat(cmd, "/* execute transaction */\n");
X	        cmd = Strcatmany(cmd, 5, "{\n", decls, "\n", stats, "\n}\n");
X    	        sprintf(tmpstr, "tlabel_%d:\n", symbol->info.trans.labnum);
X    	        cmd = Strcat(cmd, tmpstr);
X	    }
X
X    	    cmd = Strcat(cmd, "/* send result back to caller */\n");
X	    cmd = Strcatmany(cmd, 3, "dcc_res.", ptiname, ".result = _transaction_result;\n");
X    	    cmd = Strcatmany(cmd, 3, "dcc_res.", ptiname, ".Errno = OK;\n");
X    	    sprintf(tmpstr1, "%d", SELECTRESTIME);
X    	    cmd = Strcat(cmd, "if (_send_data");
X#ifdef HETEROGENEOUS
X    	    cmd = Strcat(cmd, "_encoded");
X#endif /* HETEROGENEOUS /**/
X    	    cmd = Strcatmany(cmd, 2, "(&_con_port, (char *) &dcc_res.", ptiname);
X#if defined(SINGLE) || defined(HOMOGENEOUS)
X    	    cmd = Strcatmany(cmd, 4, ", sizeof(", uptiname, POSTFIXTRANSRES, ")");
X#else /* HETEROGENEOUS */
X    	    cmd = Strcatmany(cmd, 3, ", xdr_", uptiname, POSTFIXTRANSRES);
X#endif
X    	    cmd = Strcatmany(cmd, 3, ", ", tmpstr1, ") < 0) {\n");
X    	    cmd = Strcat(cmd, "if (Errno == ETIMEOUT)\nErrno = ETASNDRESULT;\n");
X    	    cmd = Strcat(cmd, "_RuntimeError(\"sending transaction results\");\n}\n");
X
X	    cmd = Strcat(cmd, "if (_close_connection(&_con_port))\n");
X    	    cmd = Strcat(cmd, "_RuntimeError(\"closing connection\");\n");
X
X	    cmd = Strcat(cmd, hptr->stats);
X	    cmd = Strcat(cmd, "break;\n}\n");
X	} /* for */
X	cmd = Strcat(cmd, "_SendTransCallReply(TRANS_DENIED);\n");
X	cmd = Strcat(cmd, "if (_close_connection(&_con_port))\n");
X    	cmd = Strcat(cmd, "_RuntimeError(\"closing connection\");\n");
X    } else if (acceptflag && immedtflag) {
X	/* case 2:
X	 * both accept and immediate alternatives
X	 */
X	cmd = Strcat(cmd, "this type of select statement is not yet implemented!");
X    } else {
X	/* case 3:
X	 * only immediate alternatives
X	 */
X        for(hptr = attr; hptr; hptr = hptr->next) {
X	    if (hptr->guard)
X		cmd = Strcatmany(cmd, 5, "if (", hptr->guard, ") {\n", 
X		    hptr->stats, "break;\n}\n");
X	    else
X		cmd = Strcatmany(cmd, 2, hptr->stats, "break;\n");
X	} /* for */
X    }
X
X    cmd = Strcat(cmd, "} /* while */\n");
X
X    if (termntflag) 
X    	cmd = Strcat(cmd, "_notify_admin_process(NOTIFY_ACCORTER_OFF);\n");
X
X    return(cmd);
X} /* generate_select_code */
END_OF_FILE
if test 12482 -ne `wc -c <'dcc/code_select.c'`; then
    echo shar: \"'dcc/code_select.c'\" unpacked with wrong size!
fi
# end of 'dcc/code_select.c'
fi
if test -f 'dcc/symb_general.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcc/symb_general.c'\"
else
echo shar: Extracting \"'dcc/symb_general.c'\" \(12189 characters\)
sed "s/^X//" >'dcc/symb_general.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                       s y m b _ g e n e r a l . c                       *
X *                                                                         *
X *                            Package : Compiler                           *
X *                            Version : 2.0                                *
X *                       CreationDate : 01.08.90                           *
X *                         LastUpDate : 08.11.91                           *
X *                                                                         *
X *          The functions used to administrate the symbol table.           *
X *                                                                         *
X *                  Portions Copyright 1990 Franz Distler                  *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include "config.h"
X#include "extern.h"
X#include "functions.h"
X#include "y.tab.h" 
X#include "com_Errno.h"
X
X/******************************************************************************
X * strsave()                                                                  *
X *                                                                            *
X * Copies 's' to a new allocated main memory block.                           *
X *                                                                            *
X * Return values: pointer to saved string upon success / NULL upon error      *
X ******************************************************************************/
Xchar *
Xstrsave(s)
Xregister char *s;
X{
X    register char *cp;
X
X    cp = (char *) Malloc(strlen(s)+1);
X    strcpy(cp, s);
X    return(cp);
X} /* strsave */
X
X/******************************************************************************
X * hash()                                                                     *
X *                                                                            *
X * Determines to the name 'name' the corresponding hash value.                *
X *                                                                            *
X * Return values: corresponding hash value                                    *
X ******************************************************************************/
Xint
Xhash(name)
Xchar *name;
X{
X    register char *p;
X    register unsigned h=0, g;
X
X    for(p = name; *p != '\0'; p = p+1) {
X	h = (h << 4) + (*p);
X	if (g = h & 0xf0000000) {
X	    h = h ^ (g >> 24);
X	    h = h ^ g;
X	}
X    }
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb]       hash(\"%s\") = %d\n", name, h % MAXIDNUM);
X#endif /* SYMBDEBUG /**/
X    return(h % MAXIDNUM);
X} /* hash */
X
X/******************************************************************************
X * init_symbtab()                                                             *
X *                                                                            *
X * Initializes the symbol table and the block depth.                          *
X *                                                                            *
X * Return values: always OK for success                                       *
X ******************************************************************************/
Xint
Xinit_symbtab()
X{
X    register int i;
X
X#ifdef SYMBDEBUG
X    fputs("[symb] ***** init_symbtab():\n", debugfile);
X#endif /* SYMBDEBUG /**/
X
X    blknum = 0;
X
X    for(i=0; i < MAXIDNUM; i++)
X	symbtab.IdTab[i] = (SYMBTABEL *) NULL;
X
X    for(i=0; i < MAXPSTNUM; i++)
X	symbtab.PstTab[i] = (SYMBTABEL *) NULL;
X
X    return(OK);
X} /* init_symbtab */
X
X/******************************************************************************
X * enter_symbtabel()                                                          *
X *                                                                            *
X * Creates a new symbol table element by allocating the needed heap space and *
X * initializes the components: 'name', 'type', 'blknum'.                      *
X * The new symbol table element will also be entered in the symbol table.     *
X *                                                                            *
X * Return values: pointer to new element upon success / NULL upon error       *
X ******************************************************************************/
XSYMBTABEL *
Xenter_symbtabel(name)
Xregister char *name;
X{
X    register int hashid;
X    register SYMBTABEL *symbol;
X
X    if (errflag)
X	return((SYMBTABEL *) NULL);
X
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** enter_symbtabel(): params: name = %s\n",
X	name);
X    fprintf(debugfile, "[symb]       creating and initializing new element\n");
X#endif /* SYMBDEBUG /**/
X
X    /* create and initialize new symbol table element */
X    symbol = (SYMBTABEL *) Malloc(sizeof(SYMBTABEL));
X    symbol->name         = strsave(name);
X    symbol->type         = UDEC;
X    symbol->blknum       = blknum;
X    symbol->WasInSysIncl = (sysinclflag) ? TRUE : FALSE;
X    symbol->IdNext       = symbol->PstNext = (SYMBTABEL *) NULL;
X
X    /* insert new element in PST list */
X    symbol->PstNext        = symbtab.PstTab[blknum];
X    symbtab.PstTab[blknum] = symbol;
X
X    /* insert new element in ID list */
X    hashid = hash(symbol->name);
X    symbol->IdNext        = symbtab.IdTab[hashid];
X    symbtab.IdTab[hashid] = symbol;
X
X#ifdef SYMBDEBUG
X    display_symbtab_entry(symbol);
X#endif /* SYMBDEBUG /**/
X
X    return(symbol);
X} /* enter_symbtabel */
X
X/******************************************************************************
X * lookup_symbtabel()                                                         *
X *                                                                            *
X * Search the symbol table entry specified by 'name'.                         *
X *                                                                            *
X * Return values: pointer to the found symbol table element upon success /    *
X *                NULL, if element not found or upon error                    *
X ******************************************************************************/
XSYMBTABEL *
Xlookup_symbtabel(name)
Xchar *name;
X{
X    register SYMBTABEL *symbol;
X    SYMBTABEL *result;
X
X    if (errflag || (!name))
X	return((SYMBTABEL *) NULL);
X
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** lookup_symbtabel()\n");
X    fprintf(debugfile, "[symb]       searching entry for \"%s\" in symbol table\n", name);
X#endif /* SYMBDEBUG /**/
X
X    result = (SYMBTABEL *) NULL;
X
X    for(symbol = symbtab.IdTab[hash(name)]; symbol; symbol = symbol->IdNext) {
X#ifdef SYMBDEBUG
X        fprintf(debugfile, "[symb]       checking \"%s\"\n", symbol->name);
X#endif /* SYMBDEBUG /**/
X	if (!strcmp(symbol->name, name)) {
X	    result = symbol;
X	    break;
X	}
X    } /* for */
X
X#ifdef SYMBDEBUG
X    if (!result) 
X        fprintf(debugfile, "[symb]       element not found\n");
X    else {
X        fprintf(debugfile, "[symb]       element found (adr = %d)\n", result);
X        fprintf(debugfile, "[symb]       name = %s, blknum = %d\n",
X	    result->name, result->blknum);
X        fprintf(debugfile, "[symb]       WasInSysIncl = %s, type = ",
X	    (result->WasInSysIncl) ? "TRUE" : "FALSE");
X        switch(result->type) {
X        case UDEC:
X            fprintf(debugfile, "UDEC (not declared)\n");
X	    break;
X        case PROCESSDECL:
X            fprintf(debugfile, "PROCESSDECL (process declaration)\n");
X	    break;
X        case VARORPAR:
X            fprintf(debugfile, "VARORPAR (variable or parameter)\n");
X	    break;
X        case TRANSACTION:
X            fprintf(debugfile, "TRANSACTION (transaction declaration)\n");
X	    break;
X        case FUNCTIONDEF:
X            fprintf(debugfile, "FUNCTIONDEF (function definition)\n");
X	    break;
X        case PROCESSVAR:
X            fprintf(debugfile, "PROCESSVAR (process variable)\n");
X	    break;
X        case TYPEDEFNAME:
X            fprintf(debugfile, "TYPEDEFNAME (type definition)\n");
X	    break;
X        case STRUCTDECL:
X            fprintf(debugfile, "STRUCTDECL (structure declaration)\n");
X	    break;
X        default:
X            fprintf(debugfile, "UNKNOWN (type = %d)\n", result->type);
X        } /* switch */
X    }
X#endif /* SYMBDEBUG /**/
X
X    return(result);
X} /* lookup_symbtabel */
X
X/******************************************************************************
X * blk_push()                                                                 *
X *                                                                            *
X * Increments the block depth counter.                                        *
X *                                                                            *
X * Return values: always OK for success                                       *
X ******************************************************************************/
Xint
Xblk_push()
X{
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** blk_push():\n");
X    fprintf(debugfile, "[symb]       new blknum = %d\n", blknum + 1);
X#endif /* SYMBDEBUG /**/
X    ++blknum;
X    return(OK);
X} /* blk_push */
X
X/******************************************************************************
X * blk_pop()                                                                  *
X *                                                                            *
X * Closes a block, deletes all symbol table entries corresponding to the      *
X * actual block depth and finally decrements the block depth.                 *
X *                                                                            *
X * REMARK: Transactions aren't deleted, so transaction names must be definite!*
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
Xblk_pop()
X{
X    int hashid;
X    register SYMBTABEL *ptr;
X
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** blk_pop():\n");
X    fprintf(debugfile, "[symb]       deleting entries with blknum = %d\n",
X	blknum);
X#endif /* SYMBDEBUG /**/
X    for(ptr = symbtab.PstTab[blknum]; ptr; ptr = ptr->PstNext) {
X#ifdef SYMBDEBUG
X	fprintf(debugfile, "[symb]       deleting \"%s\"\n", ptr->name);
X#endif  /* SYMBDEBUG /**/
X	/* delete element from Id list */
X	hashid = hash(ptr->name);
X	symbtab.IdTab[hashid] = symbtab.IdTab[hashid]->IdNext;
X	/* free heap space */
X	/* don't free parameters or transaction declarations! */
X	if (ptr->type != VARORPAR && ptr->type != TRANSACTION) {
X		Free((char *) ptr->name);
X		Free((char *) ptr);
X	}
X    } /* for */
X    /* delete PST list with actual blknum */
X    symbtab.PstTab[blknum] = (SYMBTABEL *) NULL;
X    /* decrement blknum */
X    if (--blknum < 0)
X	Panic("blknum < 0");
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb]       new blknum = %d\n", blknum);
X#endif  /* SYMBDEBUG /**/
X    return(OK);
X} /* blk_pop */
END_OF_FILE
if test 12189 -ne `wc -c <'dcc/symb_general.c'`; then
    echo shar: \"'dcc/symb_general.c'\" unpacked with wrong size!
fi
# end of 'dcc/symb_general.c'
fi
if test -f 'dcinstall/Prepare.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcinstall/Prepare.c'\"
else
echo shar: Extracting \"'dcinstall/Prepare.c'\" \(12503 characters\)
sed "s/^X//" >'dcinstall/Prepare.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                            P r e p a r e . c                            *
X *                                                                         *
X *                            Package : Installer Program                  *
X *                            Version : 1.1                                *
X *                       CreationDate : 25.11.91                           *
X *                         LastUpDate : 06.12.93                           *
X *                                                                         *
X * The routine 'PrepareTarget' which prepares target hosts for remote      *
X * compilation and program installing.                                     *
X *                                                                         *
X *               Copyright (C) 1991-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <pwd.h>
X#include "cfgparsers.h"
X#include "dcinstall.h"
X
Xchar *src_inc_files[] = {
X    "run_Errno.h",
X    "run_errlist.h",
X    "ipc.h",
X    "dcc.h",
X    "config.h",
X    "timeout.h",
X    "ipc_socket.h",
X    "ipc_msgsem.h",
X    ""
X};
X
Xchar *del_inc_files[] = {
X    "run_errlist.h",
X    "config.h",
X    "timeout.h",
X    "ipc_socket.h",
X    "ipc_msgsem.h",
X    ""
X};
X
Xchar *src_lib_files[] = {
X    "RuntimeError.c",
X    "control.c",
X    "convert.c",
X    "creation.c",
X    "debug.c",
X    "destruction.c",
X    "ipc.c",
X    "transaction.c",
X#ifdef HETEROGENEOUS
X    "transfer.c",
X#endif
X    ""
X};
X
X/******************************************************************************
X * PrepareTarget()                                                            *
X *                                                                            *
X * Prepares the target host specified by 'dest' for remote compilation.       *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
XPrepareTarget(src, dest)
XSYMBTABEL *src;		/* source host */
XSYMBTABEL *dest;	/* destination host */
X{
X    int mounted;                /* src and dest share one filesystem or not */
X    char **fptr;
X    static char cmd[1000];	/* to store the command */
X    TARGETINFO *targets;
X    SYMBTABEL *symbol, *symbol2, *class;
X
X    if (!dest->info.Host.istarget || dest->info.Host.ex_storage->info.disk.wasprepared) 
X	return(OK);
X
X#ifndef DEBUG
X    printf("Preparing    %s (%s)\n",
X        dest->name, dest->info.Host.ex_storage->name);
X#endif /* Not DEBUG /**/
X
X    /* Determine access mode:
X     * If source-host equals destination host or source and dest host
X     * share one disk the access mode is mounted. Otherwise if dest is
X     * accessed via network, it is not mounted!
X     */
X    if (src == dest || src->info.Host.ex_storage->info.disk.location == dest->info.Host.ex_storage->info.disk.location)
X	mounted = TRUE;
X    else
X	mounted = FALSE;
X
X    /* 
X     * FIRST: make directories 
X     */
X
X    if (mounted) {
X	sprintf(cmd, "cd %s ; \\rm -rf dcc", gethomedir(getLogin()));
X	strcat(cmd,  " ; mkdir dcc");
X	strcat(cmd,  " ; mkdir dcc/bin");
X	strcat(cmd,  " ; mkdir dcc/bin/");
X	strcat(cmd,  dest->info.Host.type->name);
X	strcat(cmd,  " ; mkdir dcc/include");
X	strcat(cmd,  " ; mkdir dcc/lib");
X	strcat(cmd,  " ; mkdir dcc/lib/");
X	strcat(cmd,  dest->info.Host.type->name);
X	strcat(cmd,  " ; mkdir dcc/compile");
X    } else {
X	sprintf(cmd, "%s %s -n \\\\rm -rf dcc", RSH, dest->name);
X	strcat(cmd,  " \";\" mkdir dcc");
X	strcat(cmd,  " \";\" mkdir dcc/bin");
X	strcat(cmd,  " \";\" mkdir dcc/bin/");
X	strcat(cmd,  dest->info.Host.type->name);
X	strcat(cmd,  " \";\" mkdir dcc/include");
X	strcat(cmd,  " \";\" mkdir dcc/lib");
X	strcat(cmd,  " \";\" mkdir dcc/lib/");
X	strcat(cmd,  dest->info.Host.type->name);
X	strcat(cmd,  " \";\" mkdir dcc/compile");
X    }
X
X    if (verbose)
X	printf("Make dirs    command: %s\n", cmd);
X
X    if (!noexecute)
X        if (system(cmd)) {
X            fprintf(stderr, "\nError making directories at host \"%s\"\n", dest->name);
X	    fprintf(stderr, "The following command caused the error:\n");
X	    fprintf(stderr, "\"%s\"\n", cmd);
X	    exit(ERROR);
X	}
X
X    /*
X     * SECOND: Transfer needed source files to host to build runtime library
X     */
X
X    /* Transfer include files */
X    for(fptr = src_inc_files; *fptr[0] != 0; fptr++) {
X
X	if (mounted)
X    	    sprintf(cmd, "cp %s/%s %s/dcc/include/%s", 
X		INCLUDEDIR, *fptr, gethomedir(getLogin()), *fptr);
X	else
X	    sprintf(cmd, "rcp %s/%s %s@%s:./dcc/include/%s", 
X		INCLUDEDIR, *fptr, getLogin(), dest->name, *fptr);
X
X	if (verbose)
X	    printf("Transferring command: %s\n", cmd);
X
X	if (!noexecute)
X            if (system(cmd)) {
X	        fprintf(stderr, "\nError transferring source files to host \"%s\"\n", dest->name);
X	        fprintf(stderr, "The following command caused the error:\n");
X	        fprintf(stderr, "\"%s\"\n", cmd);
X	        exit(ERROR);
X	    }
X    } /* for */
X
X    /* Transfer library files */
X    for(fptr = src_lib_files; *fptr[0] != 0; fptr++) {
X
X	if (mounted)
X    	    sprintf(cmd, "cp %s/%s %s/dcc/compile/%s", 
X		LIBRARYDIR, *fptr, gethomedir(getLogin()), *fptr);
X	else
X	    sprintf(cmd, "rcp %s/%s %s@%s:./dcc/compile/%s", 
X		LIBRARYDIR, *fptr, getLogin(), dest->name, *fptr);
X
X	if (verbose)
X	    printf("Transferring command: %s\n", cmd);
X
X	if (!noexecute)
X            if (system(cmd)) {
X	        fprintf(stderr, "\nError transferring source files to host \"%s\"\n", dest->name);
X	        fprintf(stderr, "The following command caused the error:\n");
X	        fprintf(stderr, "\"%s\"\n", cmd);
X	        exit(ERROR);
X	    }
X    } /* for */
X
X    /*
X     * THIRD: Build library
X     */
X
X    if (mounted)
X	sprintf(cmd, "cd %s/dcc/compile ;", gethomedir(getLogin()));
X    else
X	sprintf(cmd, "%s %s cd dcc/compile \";\"", RSH, dest->name);
X
X#ifdef HETEROGENEOUS
X    strcat(cmd, " rpcgen -c -o transfer.c ../include/dcc.h ");
X    if (mounted)
X	strcat(cmd, ";");
X    else
X	strcat(cmd, "\";\"");
X#endif /* HETEROGENEOUS /**/
X
X    for(targets = dest->info.Host.compinfo; targets; targets = targets->next) 
X	if (!strcmp(targets->type, dest->info.Host.type->name) 
X			&& !strcmp(targets->os, dest->info.Host.os->name))
X	    break;
X
X    if (!targets) {
X	fprintf(stderr, "Error: target specification for computer type \"%s\" of operating",
X	    dest->info.Host.type->name);
X	fprintf(stderr, "       system \"%s\" of host \"%s\" not found \n",
X	    dest->info.Host.os->name, dest->name);
X	fprintf(stderr, "       in system configuration file \"%s\"\n",
X	    cfgfilename);
X	exit(ERROR);
X    }
X
X    strcat(cmd, " ");
X    strcat(cmd, targets->cc);
X    strcat(cmd, " -I../include ");
X    strcat(cmd, targets->cflags);
X    strcat(cmd, " -c ");
X
X    for(fptr = src_lib_files; *fptr[0] != 0; fptr++) {
X	strcat(cmd, *fptr);
X	strcat(cmd, " ");
X    }
X
X    strcat(cmd, targets->libs);
X
X    if (mounted)
X	strcat(cmd, ";");
X    else
X	strcat(cmd, "\";\"");
X    
X    strcat(cmd, " ar q ../lib/");
X    strcat(cmd, dest->info.Host.type->name);
X    strcat(cmd, "/dcc.a ");
X    for(fptr = src_lib_files; *fptr[0] != 0; fptr++) {
X	strcat(cmd, *fptr);
X	cmd[strlen(cmd)-1] = 'o';
X	strcat(cmd, " ");
X    }
X
X#if !defined(UNICOS) && !defined(HPUX)
X    if (mounted)
X	strcat(cmd, ";");
X    else
X	strcat(cmd, "\";\"");
X    
X    strcat(cmd, " ranlib ../lib/");
X    strcat(cmd, dest->info.Host.type->name);
X    strcat(cmd, "/dcc.a ");
X#endif
X
X    if (verbose)
X        printf("Compilation  command: %s\n", cmd);
X
X    if (!noexecute) 
X        if (system(cmd)) {
X            fprintf(stderr, "\nError building the library for host \"%s\"\n", 
X		dest->name);
X            fprintf(stderr, "The following command caused the error:\n");
X            fprintf(stderr, "\"%s\"\n", cmd);
X#ifndef SCO_UNIX
X	    /* use of runlib produces an error under SCO UNIX -> ignored! */
X            exit(ERROR);
X#endif
X        }
X
X    dest->info.Host.ex_storage->info.disk.wasprepared = TRUE; 
X
X    /* check the remainding hosts */
X    for(symbol = symbtab; symbol; symbol = symbol->next) {
X
X	if (symbol->type == S_HOST && symbol->info.Host.istarget
X		&& symbol->info.Host.type == dest->info.Host.type
X		&& symbol->info.Host.os   == dest->info.Host.os) {
X
X	    if (symbol->info.Host.ex_storage->info.disk.wasprepared)
X		continue;
X
X	    if (symbol->info.Host.ex_storage == dest->info.Host.ex_storage) {
X		/* Host shares files with compilation host => nothing to do! */
X	        symbol->info.Host.ex_storage->info.disk.wasprepared = TRUE;
X	    } else {
X		/* Host has own filesystem => distribute files */
X#ifndef DEBUG
X    		printf("Distributing files %s (%s) -> %s (%s)\n",
X        	    dest->name, dest->info.Host.ex_storage->info.disk.location->name, 
X		    symbol->name, symbol->info.Host.ex_storage->info.disk.location->name);
X#endif /* Not DEBUG /**/
X		sprintf(cmd, "rcp %s@%s:dcc/lib/%s/dcc.a %s@%s:dcc/lib/%s/dcc.a",
X		    getLogin(), dest->name, dest->info.Host.type->name, 
X		    getLogin(), symbol->name, symbol->info.Host.type->name);
X		sprintf(&cmd[strlen(cmd)], "; rcp %s@%s:dcc/include/dcc.h %s@%s:dcc/include/dcc.h",
X		    getLogin(), dest->name, getLogin(), symbol->name);
X		sprintf(&cmd[strlen(cmd)], "; rcp %s@%s:dcc/include/run_Errno.h %s@%s:dcc/include/run_Errno.h",
X		    getLogin(), dest->name, getLogin(), symbol->name);
X		sprintf(&cmd[strlen(cmd)], "; rcp %s@%s:dcc/include/ipc.h %s@%s:dcc/include/ipc.h",
X		    getLogin(), dest->name, getLogin(), symbol->name);
X		if (verbose)
X		    printf("Distribution command: %s\n", cmd);
X		if (!noexecute)
X                    if (system(cmd)) {
X	                fprintf(stderr, "\nError distributing files to host \"%s\"\n", 
X			    symbol->name);
X	                fprintf(stderr, "The following command caused the error:\n");
X	                fprintf(stderr, "\"%s\"\n", cmd);
X	                exit(ERROR);
X	            }
X    		/* all hosts of this filesystem and the same class are also 
X		 * marked 
X		 */
X    		for(symbol2 = symbtab; symbol2; symbol2 = symbol2->next) {
X		    if (symbol2->type == S_HOST 
X		           && symbol2->info.Host.type == symbol->info.Host.type
X		           && symbol2->info.Host.os   == symbol->info.Host.os
X			   && symbol2->info.Host.ex_storage == symbol->info.Host.ex_storage) {
X			symbol2->info.Host.ex_storage->info.disk.wasprepared = TRUE;
X		    }
X		} /* for */
X	    } /* else */
X	} /* if */
X
X    } /* for(symbol) */
X
X    /*
X     * FOURTH: Delete some include files
X     */
X
X    /* Delete some include files */
X
X    if (mounted)
X	sprintf(cmd, "cd %s/dcc/include ; \\rm -f", gethomedir(getLogin()));
X    else
X	sprintf(cmd, "%s %s cd dcc/include \";\" \\\\rm -f", RSH, dest->name);
X
X    for(fptr = del_inc_files; *fptr[0] != 0; fptr++) {
X	strcat(cmd, " ");
X	strcat(cmd, *fptr);
X    } /* for */
X
X    if (verbose)
X	printf("Deleting     command: %s\n", cmd);
X
X    if (!noexecute)
X        if (system(cmd)) {
X            fprintf(stderr, "\nError deleting include files at host \"%s\"\n", dest->name);
X            fprintf(stderr, "The following command caused the error:\n");
X            fprintf(stderr, "\"%s\"\n", cmd);
X            exit(ERROR);
X        }
X
X    return(OK);
X
X} /* PrepareTarget */
END_OF_FILE
if test 12503 -ne `wc -c <'dcinstall/Prepare.c'`; then
    echo shar: \"'dcinstall/Prepare.c'\" unpacked with wrong size!
fi
# end of 'dcinstall/Prepare.c'
fi
if test -f 'examples/config/system.WAN' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/config/system.WAN'\"
else
echo shar: Extracting \"'examples/config/system.WAN'\" \(12406 characters\)
sed "s/^X//" >'examples/config/system.WAN' <<'END_OF_FILE'
X# system.WAN
X#
X# This is a system configuration file defining a Wide Area Network
X# consisting of computers in the area of munich.
X# This file contains ONLY the definitions needed for dcinstall, not
X# the definitions for dclocate or dcanalyse.
X# Use this file only in combination with dcinstall, version 2.0 or greater and 
X# dcadmin, version 2.0 (process allocation by mapfile).
X#
X# Christoph Pleier, December 1993
X#
X#
X# **************************************************************************
X# * PART I: definition of all hostnames
X# **************************************************************************
Xhostnames = {
X
X    # ----------
X    # LAN 1 at Technische Universitaet Muenchen
X    #
X    # Sun SPARCstation
X    suneickel2, suneickel4, suneickel5, suneickel6, suneickel7, 
X    suneickel8, suneickel9,
X    # HP 9000/720
X    hpeick7, hpeick8, hpeick9, 
X    # HP 9000/755
X    hpeick6,
X    # AT 486
X    ateickel1,
X    # ----------
X    # LAN 2 at Technische Universitaet Muenchen
X    #
X    # HP 9000/720
X    hphalle0, hphalle0a, hphalle0b, hphalle0c, hphalle0d, hphalle0e, 
X              hphalle0f, hphalle0g, hphalle0h, hphalle0i, hphalle0j,
X    hphalle1, hphalle1a, hphalle1b, hphalle1c, hphalle1d, hphalle1e, 
X              hphalle1f, hphalle1g, hphalle1h, hphalle1i, hphalle1j,
X    hphalle2, hphalle2a, hphalle2b, hphalle2c, hphalle2d, hphalle2e, 
X              hphalle2f, hphalle2g, hphalle2h, hphalle2i, hphalle2j,
X    hphalle3, hphalle3a, hphalle3b, hphalle3c, hphalle3d, hphalle3e, 
X              hphalle3f, hphalle3g, hphalle3h, hphalle3i, hphalle3j,
X    hphalle4, hphalle4a, hphalle4b, hphalle4c, hphalle4d, hphalle4e, 
X              hphalle4f, hphalle4g, hphalle4h, hphalle4i, hphalle4j,
X    hphalle5, hphalle5a, hphalle5b, hphalle5c, hphalle5d, hphalle5e, 
X              hphalle5f, hphalle5g, hphalle5h, hphalle5i, hphalle5j,
X    hphalle6, hphalle6a, hphalle6b, hphalle6c, hphalle6d, hphalle6e, 
X              hphalle6f, hphalle6g, hphalle6h, hphalle6i, hphalle6j,
X    hphalle7, hphalle7a, hphalle7b, hphalle7c, hphalle7d, hphalle7e, 
X              hphalle7f, hphalle7g, hphalle7h, hphalle7i, hphalle7j,
X    hphalle8, hphalle8a, hphalle8b, hphalle8c, hphalle8d, hphalle8e, 
X              hphalle8f, hphalle8g, hphalle8h, hphalle8i, hphalle8j,
X    hphalle9, hphalle9a, hphalle9b, hphalle9c, hphalle9d, hphalle9e, 
X              hphalle9f, hphalle9g, hphalle9h, hphalle9i, hphalle9j,
X    # ----------
X    # LAN 3 at Gesellschaft fuer Strahlen- und Umweltforschung, Neuherberg
X    #
X    # Convex supercomputer C3840 "cony" (146.107.1.2)
X    cony.gsf.de,
X    # ----------
X    # LAN 4 at Botanisches Institut, Ludwig-Maximilians-Universitaet Muenchen
X    #
X    # IBM RS 6000
X    odin.botanik.biologie.uni-muenchen.de, 
X    adgard.botanik.biologie.uni-muenchen.de, 
X    mitgard.botanik.biologie.uni-muenchen.de, 
X    utgard.botanik.biologie.uni-muenchen.de, 
X    baldur.botanik.biologie.uni-muenchen.de, 
X    freya.botanik.biologie.uni-muenchen.de, 
X    thor.botanik.biologie.uni-muenchen.de, 
X    fenris.botanik.biologie.uni-muenchen.de, 
X    loki.botanik.biologie.uni-muenchen.de, 
X    hel.botanik.biologie.uni-muenchen.de, 
X    woelsung.botanik.biologie.uni-muenchen.de, 
X    ragnaroek.botanik.biologie.uni-muenchen.de, 
X    sigurd.botanik.biologie.uni-muenchen.de,
X    # ----------
X    # LAN 5 at Leibniz Rechenzentrum, Muenchen
X    #
X    # Cray Supercomputer Y-MP EL "yel" (yel@lrz-muenchen.de)
X    129.187.14.4
X    # ----------
X}
X
X# **************************************************************************
X# * PART II: definition of all computer types
X# **************************************************************************
Xcomputer types = {
X    AT486, RS6000, SPARC, HP9000_720, HP9000_755, CONVEX_C3840, CRAY_Y-MP
X}
X
X# **************************************************************************
X# * PART III: definition of all UNIX variants
X# **************************************************************************
Xoperating system variants = {
X    LINUX, AIX, SunOS, HPUX, ConvexOS, UNICOS
X}
X
X# **************************************************************************
X# * PART IV: definition of all fixed disks (used by dcinstall) and their 
X# *          properities
X# *          Note: the speed value is not important here!
X# **************************************************************************
Xfixed disks = {
X    SUN6disk = {
X	location : suneickel6
X    }
X    HPEICK7disk = {
X	location : hpeick7
X    }
X    HPEICK8disk = {
X	location : hpeick8
X    }
X    HPEICK9disk = {
X	location : hpeick9
X    }
X    HPEICK6disk = {
X	location : hpeick6
X    }
X    HPHALLE7disk = {
X	location : hphalle7
X    }
X    CONVEXdisk = {
X        location : cony.gsf.de
X    }
X    CRAYdisk = {
X        location : 129.187.14.4
X    }
X    ODINdisk = {
X	location : odin.botanik.biologie.uni-muenchen.de
X    }
X    ATEICKEL1disk = {
X        location : ateickel1
X    }
X}
X
X# **************************************************************************
X# * PART V: definition of the hosts
X# **************************************************************************
Xhost suneickel2, suneickel4, suneickel5, suneickel6, suneickel7, suneickel8, suneickel9 = {
X    operating system : SunOS
X    computer specification {
X	type                    : SPARC
X	physical memory         : 16 MB	
X	virtual memory          : 32 MB	
X	performance index       : 4.0
X	storage for executables : SUN6disk
X    }
X    compilation {
X        target: SPARC (SunOS) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSPARC -DBSD -DSOCKET -DHETEROGENEOUS"
X	    LDFLAGS = ""
X	    LIBS    = ""
X	}
X    }
X} # suneickel2, suneickel4, suneickel5, suneickel6, suneickel7, suneickel8, suneickel9
X
Xhost hpeick7 = {
X    operating system : HPUX
X    computer specification {
X	type                    : HP9000_720
X	physical memory         : 32 MB	
X	virtual memory          : 32 MB	
X	performance index       : 18.0
X	storage for executables : HPEICK7disk
X    }
X    compilation {
X        target: HP9000_720 (HPUX) {
X	    CC      = "cc"
X	    CFLAGS  = "-DHPUX -DSYSTEM_V -DSOCKET -DHETEROGENEOUS"
X	    LDFLAGS = ""
X	    LIBS    = "-lcodelibs"
X	}
X    }
X} # hpeick7
X
Xhost hpeick8 = {
X    operating system : HPUX
X    computer specification {
X	type                    : HP9000_720
X	physical memory         : 32 MB	
X	virtual memory          : 32 MB	
X	performance index       : 18.0
X	storage for executables : HPEICK8disk
X    }
X    compilation {
X        target: HP9000_720 (HPUX) {
X	    CC      = "cc"
X	    CFLAGS  = "-DHPUX -DSYSTEM_V -DSOCKET -DHETEROGENEOUS"
X	    LDFLAGS = ""
X	    LIBS    = "-lcodelibs"
X	}
X    }
X} # hpeick8
X
Xhost hpeick9 = {
X    operating system : HPUX
X    computer specification {
X	type                    : HP9000_720
X	physical memory         : 32 MB	
X	virtual memory          : 32 MB	
X	performance index       : 18.0
X	storage for executables : HPEICK9disk
X    }
X    compilation {
X        target: HP9000_720 (HPUX) {
X	    CC      = "cc"
X	    CFLAGS  = "-DHPUX -DSYSTEM_V -DSOCKET -DHETEROGENEOUS"
X	    LDFLAGS = ""
X	    LIBS    = "-lcodelibs"
X	}
X    }
X} # hpeick9
X
Xhost hpeick6 = {
X    operating system : HPUX
X    computer specification {
X	type                    : HP9000_755
X	physical memory         : 128 MB	
X	virtual memory          : 128 MB	
X	performance index       : 24
X	storage for executables : HPEICK6disk
X    }
X    compilation {
X        target: HP9000_755 (HPUX) {
X	    CC      = "cc"
X	    CFLAGS  = "-DHPUX -DSYSTEM_V -DSOCKET -DHETEROGENEOUS"
X	    LDFLAGS = ""
X	    LIBS    = "-lcodelibs"
X	}
X    }
X} # hpeick6
X
Xhost hphalle0,  hphalle0a, hphalle0b, hphalle0c, hphalle0d, hphalle0e, 
X     hphalle0f, hphalle0g, hphalle0h, hphalle0i, hphalle0j,
X     hphalle1,  hphalle1a, hphalle1b, hphalle1c, hphalle1d, hphalle1e, 
X     hphalle1f, hphalle1g, hphalle1h, hphalle1i, hphalle1j,
X     hphalle2,  hphalle2a, hphalle2b, hphalle2c, hphalle2d, hphalle2e, 
X     hphalle2f, hphalle2g, hphalle2h, hphalle2i, hphalle2j,
X     hphalle3,  hphalle3a, hphalle3b, hphalle3c, hphalle3d, hphalle3e, 
X     hphalle3f, hphalle3g, hphalle3h, hphalle3i, hphalle3j,
X     hphalle4,  hphalle4a, hphalle4b, hphalle4c, hphalle4d, hphalle4e, 
X     hphalle4f, hphalle4g, hphalle4h, hphalle4i, hphalle4j,
X     hphalle5,  hphalle5a, hphalle5b, hphalle5c, hphalle5d, hphalle5e, 
X     hphalle5f, hphalle5g, hphalle5h, hphalle5i, hphalle5j,
X     hphalle6,  hphalle6a, hphalle6b, hphalle6c, hphalle6d, hphalle6e, 
X     hphalle6f, hphalle6g, hphalle6h, hphalle6i, hphalle6j,
X     hphalle7,  hphalle7a, hphalle7b, hphalle7c, hphalle7d, hphalle7e, 
X     hphalle7f, hphalle7g, hphalle7h, hphalle7i, hphalle7j,
X     hphalle8,  hphalle8a, hphalle8b, hphalle8c, hphalle8d, hphalle8e, 
X     hphalle8f, hphalle8g, hphalle8h, hphalle8i, hphalle8j,
X     hphalle9,  hphalle9a, hphalle9b, hphalle9c, hphalle9d, hphalle9e, 
X     hphalle9f, hphalle9g, hphalle9h, hphalle9i, hphalle9j
X= {
X    operating system : HPUX
X    computer specification {
X	type                    : HP9000_720
X	physical memory         : 32 MB	
X	virtual memory          : 32 MB	
X	performance index       : 18.0
X	storage for executables : HPHALLE7disk
X    }
X    compilation {
X        target: HP9000_720 (HPUX) {
X	    CC      = "cc"
X	    CFLAGS  = "-DHPUX -DSYSTEM_V -DSOCKET -DHETEROGENEOUS"
X	    LDFLAGS = ""
X	    LIBS    = "-lcodelibs"
X	}
X    }
X} # hphalle0, hphalle0a, ... , hphalle9j
X
X# definition of host "cony" (inetadr 146.107.1.2)
Xhost cony.gsf.de = {
X    operating system : ConvexOS
X    computer specification {
X        type:                    CONVEX_C3840
X        physical memory:         1 GB
X        virtual memory:          1 GB
X        performance index:       75
X        multiprocessor system: 4 processors, shared memory
X        vector computer
X        parallelizing compiler
X        storage for executables: CONVEXdisk
X    }
X    compilation {
X        target: CONVEX_C3840 (ConvexOS) {
X            CC      = "cc"
X            CFLAGS  = "-DCONVEX -DBSD -DSOCKET -DHETEROGENEOUS -ext"
X            LDFLAGS = "-ext"
X            LIBS    = ""
X        }
X    }
X
X    accessible filesystems = {
X        CONVEXdisk (10 ms)
X    }
X} # cony.gsf.de
X
X# muss noch aktualisiert werden!
X# definition of host "yel" (inetadr 129.187.14.4)
Xhost 129.187.14.4 = {
X    operating system : UNICOS
X    computer specification {
X        type:                    CRAY_Y-MP
X        physical memory:         1 GB	# ???
X        virtual memory:          1 GB	# ???
X        performance index:       75	# ???
X        multiprocessor system: 2 processors, shared memory # ???
X        vector computer
X        parallelizing compiler
X        storage for executables: CRAYdisk
X    }
X    compilation {
X        target: CRAY_Y-MP (UNICOS) {
X            CC      = "cc"
X            CFLAGS  = "-DCRAY -DSYSTEM_V -DSOCKET -DHETEROGENEOUS"
X            LDFLAGS = ""
X            LIBS    = ""
X        }
X    }
X} # 129.187.14.4
X
Xhost 
X    odin.botanik.biologie.uni-muenchen.de, 
X    adgard.botanik.biologie.uni-muenchen.de, 
X    mitgard.botanik.biologie.uni-muenchen.de, 
X    utgard.botanik.biologie.uni-muenchen.de, 
X    baldur.botanik.biologie.uni-muenchen.de, 
X    freya.botanik.biologie.uni-muenchen.de, 
X    thor.botanik.biologie.uni-muenchen.de, 
X    fenris.botanik.biologie.uni-muenchen.de, 
X    loki.botanik.biologie.uni-muenchen.de, 
X    hel.botanik.biologie.uni-muenchen.de, 
X    woelsung.botanik.biologie.uni-muenchen.de, 
X    ragnaroek.botanik.biologie.uni-muenchen.de, 
X    sigurd.botanik.biologie.uni-muenchen.de 
X= {
X    operating system : AIX
X    computer specification {
X        type                    : RS6000
X        physical memory         : 32 MB
X        virtual memory          : 32 MB
X        performance index       : 8.0
X        storage for executables : ODINdisk
X    }
X    compilation {
X        target: RS6000 (AIX) {
X            CC      = "cc"
X            CFLAGS  = "-DAIX -DSYSTEM_V -DSOCKET -DHETEROGENEOUS"
X            LDFLAGS = ""
X            LIBS    = ""
X        }
X    }
X} # odin.botanik.biologie.uni-muenchen.de, ...
X
Xhost ateickel1 = {
X    operating system : LINUX
X    computer specification {
X        type                    : AT486
X        physical memory         : 16 MB
X        virtual memory          : 16 MB
X        performance index       : 3.0
X        storage for executables : ATEICKEL1disk
X    }
X    compilation {
X        target: AT486 (LINUX) {
X            CC      = "cc"
X            CFLAGS  = "-DLINUX -DSYSTEM_V -DSOCKET -DHOMOGENEOUS"
X            LDFLAGS = ""
X            LIBS    = ""
X        }
X    }
X}
X
X
END_OF_FILE
if test 12406 -ne `wc -c <'examples/config/system.WAN'`; then
    echo shar: \"'examples/config/system.WAN'\" unpacked with wrong size!
fi
# end of 'examples/config/system.WAN'
fi
if test -f 'lib/control.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib/control.c'\"
else
echo shar: Extracting \"'lib/control.c'\" \(11254 characters\)
sed "s/^X//" >'lib/control.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                          c o n t r o l . c                              *
X *                                                                         *
X *                            Package : Runtime Library                    *
X *                            Version : 1.0                                *
X *                       CreationDate : 31.08.90                           *
X *                         LastUpDate : 06.12.93                           *
X *                                                                         *
X *       The routines to control signals and to terminate processes.       *
X *                                                                         *
X *     Copyright (C) 1990-1994 by Franz Distler and Christoph Pleier.      *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <signal.h>
X#include <sys/types.h>
X#ifdef HETEROGENEOUS
X# include <rpc/rpc.h>
X#endif
X#include "ipc.h"
X#include "dcc.h"
X#include "run_Errno.h"
X
X#define DEBUG_CONTROL /**/
X
X#ifdef DEBUG_CONTROL
X/* the flag to control the debug messages output */
Xint _debug_control = 0;
X#endif /* DEBUG_CONTROL /**/
X
X#ifdef DEBUG_CONTROL
X# define DEBUGPUTS(msg)		if (_debug_control) { \
X				    fprintf(_debugout, "[con] %s %s\n", \
X				        _processprefix, msg); \
X				    if (_debugflush) \
X				        fflush(_debugout); \
X				}
X# define DEBUGDISPERR(w, msg)	if (_debug_control) { \
X				    fprintf(_debugout, "[con] %s error: %s\n", \
X				        _processprefix, msg); \
X				    fprintf(_debugout, "[con] %s reason: %s\n",\
X				        _processprefix, sys_errlist[errno]); \
X				    if (_debugflush) \
X				        fflush(_debugout); \
X				}
X#else
X# define DEBUGPUTS(msg)		{ /* nothing */ }
X# define DEBUGDISPERR(msg)	{ /* nothing */ }
X#endif
X
X/******************************************************************************
X * _set_signals()                                                             *
X *                                                                            *
X * Catches all signals which default action is to terminate the program using *
X * '_catch'.                                                                  *
X *                                                                            *
X * Return value: none!                                                        *
X ******************************************************************************/
Xint
X_set_signals()
X{
X	register int i;
X#if defined(HPUX) || defined(UNICOS) || defined(LINUX)
X	void _Exit();
X#else
X	int _Exit();
X#endif /* HPUX || UNICOS || LINUX /**/
X	
X	DEBUGPUTS("catching signals");
X	for(i = 1; i <= NSIG; ++i) {
X		switch(i) {
X		case SIGUSR1:
X		    /* SIGUSR1 is used to force processes to terminate! 
X		     * See also destruction.c
X		     */
X		    signal(i, _Exit);
X		    break;
X		case SIGHUP:
X		case SIGALRM:
X		case SIGUSR2:
X#ifdef SIGCLD
X		case SIGCLD:
X#else
X		case SIGCHLD:
X#endif /* SIGCLD /**/
X			continue;
X		default:
X			signal(i, _catch);
X		}
X	}
X#ifdef UNICOS
X	signal(SIGINFO, SIG_IGN);
X#endif /* UNICOS /**/
X} /* _set_signals */
X
X/******************************************************************************
X * _catch()                                                                   *
X *                                                                            *
X * '_catch' will be called when a signal occurs. It then displays the signal  *
X * type on stdout and finally calles the signal by itsself to perform the     *
X * default action.                                                            *
X *                                                                            *
X * Return value: none!                                                        *
X ******************************************************************************/
X#if defined(HPUX) || defined(UNICOS) || defined(LINUX)
Xvoid 
X#else
Xint
X#endif
X_catch(sig)
Xint sig;
X{
X	char *what;
X	static char kind[40];
X
X	signal(sig, SIG_IGN);
X	switch(sig) {
X	case SIGHUP:
X		what = "Hangup";
X		break;
X	case SIGINT:
X		what = "Interrupt";
X		break;
X	case SIGQUIT:
X		what = "Quit";
X		break;
X	case SIGILL:
X		what = "Illegal instruction";
X		break;
X	case SIGTRAP:
X		what = "Trace trap";
X		break;
X#ifdef SIGIOT
X	case SIGIOT:
X		what = "I/O trap instruction";
X		break;
X#else	/* Do not delete this else! */
X# ifdef SIGABRT
X	case SIGABRT:
X		what = "abort";
X		break;
X# endif
X#endif
X#ifdef SIGEMT
X	case SIGEMT:
X		what = "Emulator trap instruction";
X		break;
X#endif
X	case SIGFPE:
X		what = "Floating-point exception";
X		break;
X	case SIGBUS:
X		what = "Bus error";
X		break;
X	case SIGSEGV:
X		what = "Segmentation violation";
X		break;
X#ifdef SIGSYS
X	case SIGSYS:
X		what = "Bad argument to system call";
X		break;
X#endif
X	case SIGPIPE:
X		what = "Write on a pipe with no one to read it";
X		break;
X	case SIGALRM:
X		what = "Alarm clock";
X		break;
X	case SIGTERM:
X		what = "Software termination signal";
X		break;
X	case SIGUSR1:
X		what = "User defined signal 1";
X		break;
X	case SIGUSR2:
X		what = "User defined signal 2";
X		break;
X#ifdef SIGCLD
X	case SIGCLD:
X#else
X	case SIGCHLD:
X#endif /* SIGCLD /**/
X		what = "Death of a child";
X		break;
X	default:
X		sprintf(kind, "unknown kind (number %d)", sig);
X		what = kind;
X	} /* switch */
X#ifndef DEBUG
X# ifdef SIGCLD
X	if (sig!=SIGALRM && sig!=SIGUSR1 && sig!=SIGUSR2 && sig!=SIGCLD){
X# else
X	if (sig!=SIGALRM && sig!=SIGUSR1 && sig!=SIGUSR2 && sig!=SIGCHLD){
X# endif /* SIGCLD /**/
X	    fprintf(stdout, "***** PROGRAM TERMINATED BY SIGNAL ******\n");
X# ifdef iPSC
X	    fprintf(stdout, "PROGRAM: %s, PROCESS: %s, NODE: %ld, PID: %ld\n", 
X	        _programname, _processname, mynode(), mypid());
X# else
X#  ifdef SINGLE
X	    fprintf(stdout, "PROGRAM: %s, PROCESS: %s, PID: %d\n",
X	        _programname, _processname, getpid());
X#  else /* HOMOGENEOUS || HETEROGENEOUS */
X	    fprintf(stdout, "PROGRAM: %s, PROCESS: %s, HOST: %s, PID: %d\n", 
X	        _programname, _processname, _own_port.hostname, getpid());
X#  endif /* SINGLE /**/
X# endif /* iPSC /**/
X	    fprintf(stdout, "Signal: %s\n", what);
X	    fflush(stdout);
X	}
X#else
X	if (_debug_control) {
X	    fprintf(_debugout, "[con] %s Signal received: %s\n",
X		_processprefix, what);
X	    if (_debugflush)
X		fflush(_debugout);
X	}
X#endif /* Not DEBUG /**/
X	signal(sig, SIG_DFL);
X	if (strcmp(_processname, "administration process")) {
X#ifdef SOCKET
X	    _own_port.state = CONNECTIONLESS;	/* DIRTY PROGRAMMING! */
X#endif /* SOCKET /**/
X	    _notify_admin_process(NOTIFY_ERROR);
X	}
X	/* force a core dump! */
X	abort();
X} /* _catch */
X
X/******************************************************************************
X * _Exit()                                                                    *
X *                                                                            *
X * Notifies the administration process the termination, deletes the port and  *
X * terminates.                                                                *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
X#if defined(HPUX) || defined(UNICOS) || defined(LINUX)
Xvoid
X#else
Xint
X#endif
X_Exit(code)
Xint code;
X{
X	int waitflag = TRUE;
X
X	if (!strcmp(_processname, "main process")) {
X	    /* The main process must be the last process to terminate.
X             * This must be ensured to handle the terminal redirections
X             * (by rsh) correctly.
X             * We guarrantee this by simulating a select-statement with
X             * terminate-alternative.
X             */
X	    fprintf(stderr, "main process: waiting for all processes to terminate!\n");
X            _notify_admin_process(NOTIFY_ACCORTER_ON);
X            while(waitflag) {
X                char *request;
X                static TRANSDATA transdata;
X
X                /* get connection */
X                (void) _accept_connection(&_con_port, &_own_port, 0);
X                /* check connection type */
X                if (_receive_connection_type_or_answer() != TRANSACTION_CONNECTION) {
X                        if (_send_connection_type_or_answer(ABORT_CONNECTION))
X                                _RuntimeError("sending connection answer");
X                        if (_close_connection(&_con_port))
X                                _RuntimeError("closing connection");
X                        continue;
X                } else {
X                        if (_send_connection_type_or_answer(ACCEPT_CONNECTION))
X                                _RuntimeError("sending connection answer");
X                }
X                /* get transaction request */
X#if defined(SINGLE) || defined(HOMOGENEOUS)
X                if (_recv_data(&_con_port, (char *) &transdata, sizeof(TRANSDATA), 30)<0) {
X#else
X                if (_recv_data_encoded(&_con_port, (char *) &transdata, xdr_TRANSDATA, 30)<0) {
X#endif /* SINGLE || HOMOGENEOUS /**/
X                        if (Errno == ETIMEOUT)
X                                Errno = ETSRCVREQUEST;
X                        _RuntimeError("simulating terminate-Alternative in main process");
X                }
X                request = transdata.request;
X                /* terminate alternative */
X                if (!strcmp(request, "TRANS_TERMINATE")) {
X                        (void) _close_connection(&_con_port);
X			waitflag = FALSE;
X                } else {
X                    _SendTransCallReply(TRANS_DENIED);
X                    if (_close_connection(&_con_port))
X                        _RuntimeError("closing connection");
X		}
X            } /* while */
X	    fprintf(stderr, "main process: all processes have terminated! Terminating.\n");
X	} 
X
X#ifdef SOCKET
X	_own_port.state = CONNECTIONLESS;	/* DIRTY PROGRAMMING! */
X#endif /* SOCKET /**/
X	DEBUGPUTS("notifying admin process");
X	_notify_admin_process(NOTIFY_END);
X	(void) _delete_port(&_own_port);
X	DEBUGPUTS("terminating by exit()");
X	exit(code);
X} /* _Exit */
END_OF_FILE
if test 11254 -ne `wc -c <'lib/control.c'`; then
    echo shar: \"'lib/control.c'\" unpacked with wrong size!
fi
# end of 'lib/control.c'
fi
echo shar: End of archive 9 \(of 18\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
