Newsgroups: comp.sources.unix
From: pleierc@informatik.tu-muenchen.de (Christoph Pleier)
Subject: v27i181: distributed-c-2.1 - Distributed C Development Environment, V2.1, Part07/18
References: <1.756634932.28500@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: pleierc@informatik.tu-muenchen.de (Christoph Pleier)
Posting-Number: Volume 27, Issue 181
Archive-Name: distributed-c-2.1/part07

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 18)."
# Contents:  config/debug.c config/system.y dcadmin/Status.c
#   dcinstall/Compile.c dcinstall/ParseOptions.c dcinstall/main.c
#   include/com_Errno.h include/globals.h include/run_errlist.h
#   ipc/p1.c
# Wrapped by vixie@gw.home.vix.com on Thu Dec 23 00:12:00 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'config/debug.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/debug.c'\"
else
echo shar: Extracting \"'config/debug.c'\" \(9082 characters\)
sed "s/^X//" >'config/debug.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                              d e b u g . c                              *
X *                                                                         *
X *                            Package : Configuration Files Parsers        *
X *                            Version : 1.0                                *
X *                       CreationDate : 26.02.92                           *
X *                         LastUpDate : 26.02.92                           *
X *                                                                         *
X * All routines needed to display additional informations for debugging    *
X * perpose only.                                                           *
X *                                                                         *
X *               Copyright (C) 1992-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include "cfgparsers.h"
X
X#define DEBUG
X
X#ifdef DEBUG
X
X/******************************************************************************
X * DisplaySymbtabel()                                                         *
X *                                                                            *
X * Displays the components of the symbol table element pointed to by 'symbol'.*
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
XDisplaySymbtabel(symbol)
XSYMBTABEL *symbol;
X{
X    TARGETINFO *target;
X    SYMBTABEL  *p_symb;
X    ACCFSINFO  *afs;
X    IDENTLIST  *idl;
X    FSSPECINFO *fsl;
X    COMMPINFO  *csl;
X    PATTRINFO  *pattrl;
X    PHOSTLIST  *phost;
X    COSTINFO   *costl;
X
X    printf("name : \"%s\"\n", symbol->name);
X    printf("type : ");
X    switch(symbol->type) {
X    case UNDEFINED:
X        puts("UNDEFINED");
X	break;
X    case S_HOST:
X        puts("S_HOST");
X	printf("installed operating system : %s\n", symbol->info.Host.os->name);
X	printf("             computer type : %s\n", symbol->info.Host.type->name);
X	printf("           physical memory : %f MB\n", symbol->info.Host.phys_mem);
X	printf("            virtual memory : %f MB\n", symbol->info.Host.virt_mem);
X	printf("         performance index : %f\n", symbol->info.Host.perf_index);
X	if (symbol->info.Host.multiprocessor) {
X	    printf("            multiprocessor : TRUE\n");
X	    printf("      number of processors : %d\n", symbol->info.Host.processors);
X	    printf("               memory type : %s memory\n", 
X	        (symbol->info.Host.memory_type == SHARED_MEMORY) ? "shared" : "distributed");
X	    printf("has parallelizing compiler : %s\n", (symbol->info.Host.has_par_compiler) ? "TRUE" : "FALSE");
X	} else 
X	    printf("            multiprocessor : FALSE\n");
X	printf("        is vector computer : %s\n", (symbol->info.Host.is_vector_computer) ? "TRUE" : "FALSE");
X
X	printf("peripheral devices:\n    ");
X	for(idl = symbol->info.Host.p_devices; idl; idl = idl->next)
X	    printf("%s ", idl->symbol->name);
X	puts("");
X
X	printf("accessible filesystems:\n    ");
X	for(afs = symbol->info.Host.f_systems; afs; afs = afs->next)
X	    printf("%s (%f) ", afs->filesystem->name, afs->acc_time);
X	puts("");
X
X	printf("compilation information:\n");
X	for(target = symbol->info.Host.compinfo; target; target = target->next){
X	    printf("    target type : \"%s\"\n", target->type);
X	    printf("    target os   : \"%s\"\n", target->os);
X	    printf("        cc      : \"%s\"\n", target->cc);
X	    printf("        cflags  : \"%s\"\n", target->cflags);
X	    printf("        ldflags : \"%s\"\n", target->ldflags);
X	    printf("        libs    : \"%s\"\n", target->libs);
X	}
X
X	printf("cost informations:\n");
X	for(costl = symbol->info.Host.costinfo; costl; costl = costl->next) 
X	    printf("    -> %15s : %3.2f, %3.2f\n", costl->dest_host->name, costl->crea_val, costl->comm_val);
X	printf("internal informations:\n");
X	printf("prob_load : %f\n", symbol->info.Host.prob_load);
X	printf(" pcreated : %d\n", symbol->info.Host.pcreated);
X	break;
X    case S_COMPUTER_TYPE:
X        puts("S_COMPUTER_TYPE");
X	break;
X    case S_OPERATING_SYSTEM:
X        puts("S_OPERATING_SYSTEM");
X	break;
X    case S_FIXED_DISK:
X        puts("S_FIXED_DISK");
X	printf("disk located in host \"%s\"\n", symbol->info.disk.location->name);
X	printf("disk size = %f MB\n", symbol->info.disk.size);
X	printf("disk access time = %f ms\n", symbol->info.disk.speed);
X	break;
X    case S_PROCESS:
X	puts("S_PROCESS");
X	printf("  intensity index : %f\n", symbol->info.Process.intensity_index);
X	if (symbol->info.Process.pref_hosts) {
X	    printf("  preferred hosts : ");
X	    for(idl = symbol->info.Process.pref_hosts; idl; idl = idl->next)
X		printf("%s ", idl->symbol->name);
X	    puts("");
X	}
X	if (symbol->info.Process.rest_hosts) {
X	    printf(" restricted hosts : ");
X	    for(idl = symbol->info.Process.rest_hosts; idl; idl = idl->next)
X		printf("%s ", idl->symbol->name);
X	    puts("");
X	}
X	if (symbol->info.Process.peri_dev) {
X	    printf("accesses peripheral devices :\n"); 
X	    for(idl = symbol->info.Process.peri_dev; idl; idl = idl->next)
X		printf("%s ", idl->symbol->name);
X	    puts("");
X	}
X	if (symbol->info.Process.filesystems) {
X	    printf("accesses filesystems:\n"); 
X	    for(fsl = symbol->info.Process.filesystems; fsl; fsl = fsl->next)
X		printf("    name: %s, freq: %f, quant: %f\n", 
X		    fsl->filesys->name, fsl->frequency, fsl->quantity);
X	}
X	if (symbol->info.Process.commps) {
X	    printf("communicates with:\n"); 
X	    for(csl = symbol->info.Process.commps; csl; csl = csl->next)
X		printf("    name: %s, freq: %f, quant: %f\n", 
X		    csl->Process->name, csl->frequency, csl->quantity);
X	}
X	for(pattrl = symbol->info.Process.others; pattrl; pattrl = pattrl->next) {
X	    switch(pattrl->type) {
X	    case PA_PHYS_MEM:
X		printf("%s physical memory: %f MB\n", (pattrl->mode == MODE_WISHES) ? "whishes" : "requires",
X			pattrl->info.phys_mem_size);
X		break;
X	    case PA_VIRT_MEM:
X		printf("%s virtual memory: %f MB\n", (pattrl->mode == MODE_WISHES) ? "whishes" : "requires",
X			pattrl->info.virt_mem_size);
X		break;
X	    case PA_VECTORIZATION:
X		printf("%s vectorization\n", (pattrl->mode == MODE_WISHES) ? "whishes" : "requires");
X		break;
X	    case PA_PARALLELIZATION:
X		printf("%s parallelization\n", (pattrl->mode == MODE_WISHES) ? "whishes" : "requires");
X		break;
X	    }
X	} /* for(pattrl) */
X	if (symbol->info.Process.phostlist) {
X	    printf("priority hostlist:\n"); 
X	    for(phost = symbol->info.Process.phostlist; phost; phost = phost->next)
X		printf("    host: %10s, pref: %d, w_val: %3d, load: %2.2f, overall: %2.2f\n",
X            	    phost->Host->name, phost->preferred, phost->wished_val, 
X		    phost->load, phost->overall_index);
X	}
X    default:
X        puts("unknown");
X    } /* switch */
X} /* DisplaySymbtabel */
X
X/******************************************************************************
X * DisplaySymbolTable()                                                       *
X *                                                                            *
X * Displays the complete symbol table.                                        *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
XDisplaySymbolTable()
X{
X    int i;
X    register SYMBTABEL *symbol;
X
X    puts("Symbol table:");
X    puts("=============\n");
X    for(symbol = symbtab, i = 1; symbol; symbol = symbol->next, i++) {
X	printf("Entry %3d:\n", i);
X	printf("----------\n");
X	DisplaySymbtabel(symbol);
X	puts("");
X    }
X} /* DisplaySymbolTable */
X
X#endif /* DEBUG /**/
END_OF_FILE
if test 9082 -ne `wc -c <'config/debug.c'`; then
    echo shar: \"'config/debug.c'\" unpacked with wrong size!
fi
# end of 'config/debug.c'
fi
if test -f 'config/system.y' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/system.y'\"
else
echo shar: Extracting \"'config/system.y'\" \(8845 characters\)
sed "s/^X//" >'config/system.y' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                             s y s t e m . y                             *
X *                                                                         *
X *                            Package : Configuration Files Parsers        *
X *                            Version : 2.0                                *
X *                       CreationDate : 20.11.91                           *
X *                         LastUpDate : 20.12.93                           *
X *                                                                         *
X *   The grammar specifying the syntax of the system configuration file.   *
X *                                                                         *
X *               Copyright (C) 1991-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X%{
X#include <stdio.h>
X#include <stdlib.h>
X#include <sys/types.h>
X#include "cfgparsers.h"
X%}
X
X/* the type of the value stack */
X%union {
X    char        *y_str;	    /* a string */
X    SYMBTABEL   *y_symb;	    /* a pointer to a symbol table element */
X    float        y_float;    /* a number */
X    MULTIINFO   *y_multi;    
X    OPTCOMPINFO *y_ocomp;
X    COMPSPEINFO *y_comsp;
X    TARGETINFO  *y_target;   /* a pointer to a target information */
X    ACCFSINFO   *y_accfs;
X    IDENTLIST   *y_idlist;   /* a pointer to an identifier list */
X}
X
X/* characters */
X%token ',' ';' ':' '.' '+' '-' '*' '/' '%' '~' '!' '&' '|' '^'
X%token '=' '<' '>' '{' '}' '[' ']' '(' ')' '\"' '\'' '\\' '@'
X
X/* special characters
X * NOTE: The token definition must be defined exactly like in program.y
X */
X%token ACCESSES ACCESSIBLE COMMUNICATES COMPILATION COMPILER COMPUTER COSTS 
X%token CREATION DEVICES DISKS DISTRIBUTED EXECUTABLES FILESYSTEMS FIXED FOR 
X%token GENERAL HOST HOSTS HOSTNAMES INDEX INFORMATIONS INTENSITY LISTS LOCATION 
X%token MEMORY MULTIPROCESSOR OPERATING PARALLELIZING PERFORMANCE PERIPHERAL 
X%token PHYSICAL PREFERRED PRIORITY PROCESS PROCESSORS REQUIRES RESTRICTED 
X%token SHARED SIZE SPECIFICATION SPEED STORAGE SYSTEM TARGET TYPE TYPES 
X%token VARIANTS VECTOR VIRTUAL WISHES WITH
X%token VECTORIZATION PARALLELIZATION
X%token MS NS KB MB GB
X%token CC CFLAGS LD LDFLAGS LIBS
X%token IDENT STRING NUMBER
X
X%type <y_str>    STRING
X%type <y_symb>   IDENT operating_system_definition
X%type <y_float>  NUMBER size_specification time_specification
X%type <y_float>  optional_disk_size_definition optional_disk_speed_definition
X%type <y_multi>  multiprocessor_specification
X%type <y_ocomp>  optional_computer_attribute_list optional_computer_attribute
X%type <y_comsp>  computer_specification
X%type <y_target> target_specification target_list compilation_specification 
X%type <y_accfs>  filesystem_definition filesystems_list
X%type <y_accfs>  accessible_filesystems_definition
X%type <y_idlist> ident_list peripheral_devices_definition
X
X%start system_configuration
X
X%%
X
Xsystem_configuration: 
X	  declaration_list
X	;
X
Xdeclaration_list:
X	  declaration
X	| declaration_list declaration
X	;
X
Xdeclaration:
X	  hostnames_definition
X	| computer_types_definition
X	| operating_system_variants_definition
X	| fixed_disks_definition
X	| host_specification
X	| compilation_hosts_definition
X	| costs_definition
X	;
X
Xhostnames_definition:
X	  HOSTNAMES '=' '{' ident_list '}'
X		{mark_symbols($4, S_HOST);}
X	;
X
Xcomputer_types_definition:
X	  COMPUTER TYPES '=' '{' ident_list '}'
X		{mark_symbols($5, S_COMPUTER_TYPE);}
X	;
X
Xoperating_system_variants_definition:
X	  OPERATING SYSTEM VARIANTS '=' '{' ident_list '}'
X		{mark_symbols($6, S_OPERATING_SYSTEM);}
X	;
X
Xfixed_disks_definition:
X	  FIXED DISKS '=' '{' disk_definition_list '}'
X	;
X
Xdisk_definition_list:
X	  disk_definition
X	| disk_definition_list disk_definition
X	;
X
Xdisk_definition:
X	  IDENT '=' '{' 
X	  	LOCATION ':' IDENT
X	  	optional_disk_size_definition
X	  	optional_disk_speed_definition
X	  '}'
X		{enter_disk_definition($1, $6, $7, $8);}
X	;
X
Xoptional_disk_size_definition:
X	  /* empty */
X		{$$ = 0.0;}
X	| SIZE ':' size_specification
X		{$$ = $3;}
X	;
X
Xoptional_disk_speed_definition:
X	  /* empty */
X		{$$ = 0.0;}
X	| SPEED ':' time_specification
X		{$$ = $3;}
X	;
X
Xhost_specification:
X	  HOST ident_list '=' '{' 
X		operating_system_definition
X		computer_specification
X		peripheral_devices_definition
X		compilation_specification
X		accessible_filesystems_definition
X	  '}'
X		{enter_host_specification($2, $5, $6, $7, $8, $9);}
X	;
X
Xoperating_system_definition:
X	  OPERATING SYSTEM ':' IDENT
X		{$$ = $4;}
X	;
X
Xcomputer_specification:
X	  COMPUTER SPECIFICATION '{'
X	  	TYPE ':' IDENT
X		PHYSICAL MEMORY ':' size_specification
X		VIRTUAL MEMORY ':' size_specification
X		PERFORMANCE INDEX ':' NUMBER
X	  	STORAGE FOR EXECUTABLES ':' IDENT
X	  '}'
X		{$$ = generate_comp_spec_info($6, $10, $14, $18, NULL, $23);}
X	| COMPUTER SPECIFICATION '{'
X	  	TYPE ':' IDENT
X		PHYSICAL MEMORY ':' size_specification
X		VIRTUAL MEMORY ':' size_specification
X		PERFORMANCE INDEX ':' NUMBER
X		optional_computer_attribute_list
X	  	STORAGE FOR EXECUTABLES ':' IDENT
X	  '}'
X		{$$ = generate_comp_spec_info($6, $10, $14, $18, $19, $24);}
X	;
X
Xoptional_computer_attribute_list:
X	  optional_computer_attribute
X	| optional_computer_attribute_list optional_computer_attribute
X		{$$ = add_opt_comp_attr_info($1, $2);}
X	;
X
Xoptional_computer_attribute:
X	  multiprocessor_specification
X		{$$ = generate_opt_comp_attr_info($1, 0);}
X	| VECTOR COMPUTER
X		{$$ = generate_opt_comp_attr_info(NULL, VECTOR_COMPUTER);}
X	| PARALLELIZING COMPILER
X		{$$ = generate_opt_comp_attr_info(NULL, PAR_COMPILER);}
X	;
X
Xmultiprocessor_specification:
X	  MULTIPROCESSOR SYSTEM ':' NUMBER PROCESSORS ',' SHARED MEMORY
X		{$$ = generate_multi_info($4, SHARED_MEMORY);}
X	| MULTIPROCESSOR SYSTEM ':' NUMBER PROCESSORS ',' DISTRIBUTED MEMORY
X		{$$ = generate_multi_info($4, DISTRIBUTED_MEMORY);}
X	;
X
Xperipheral_devices_definition:
X	  /* empty */
X		{$$ = NULL;}
X	| PERIPHERAL DEVICES '=' '{' ident_list '}'
X		{$$ = $5;}
X	;
X
Xcompilation_specification:
X	  COMPILATION '{' target_list '}'
X		{$$ = $3;}
X	;
X
Xtarget_list:
X	  target_specification 
X	| target_list target_specification
X		{$$ = chain_targetinfos($1, $2);}
X	;
X	  
Xtarget_specification:
X	  TARGET ':' IDENT '(' IDENT ')' '{'
X		CC      '=' STRING
X		CFLAGS  '=' STRING
X		LDFLAGS '=' STRING
X		LIBS    '=' STRING 
X	  '}'
X		{$$ = generate_targetinfo($3, $5, $10, $13, $16, $19);}
X	;
X
Xaccessible_filesystems_definition:
X	  /* empty */
X		{$$ = NULL;}
X	| ACCESSIBLE FILESYSTEMS '=' '{' filesystems_list '}'
X		{$$ = $5;}
X	;
X
Xfilesystems_list:
X	  filesystem_definition
X	| filesystems_list ',' filesystem_definition
X		{$$ = chain_accfs_infos($1, $3);}
X	;
X
Xfilesystem_definition:
X	  IDENT '(' time_specification ')'
X		{$$ = generate_accfs_info($1, $3);}
X	;
X
Xcompilation_hosts_definition:
X	  COMPILATION HOSTS PRIORITY LISTS '{'
X		compilation_hosts_priority_list
X	  '}'
X	;
X
Xcompilation_hosts_priority_list:
X	  /* empty */
X	| compilation_hosts_specification_list
X	| GENERAL ':' ident_list
X	;
X
Xcompilation_hosts_specification_list:
X	  IDENT ':' ident_list
X	| compilation_hosts_specification_list IDENT ':' ident_list
X	;
X
Xcosts_definition:
X	  COSTS INFORMATIONS '{' costs_definition_list '}'
X	;
X
Xcosts_definition_list:
X	  cost_definition
X	| costs_definition_list cost_definition
X	;
X
Xcost_definition:
X	  IDENT '-' '>' IDENT ':' NUMBER ',' NUMBER
X		{enter_cost_definition($1, $4, $6, $8);}
X	;
X
Xident_list:
X	  IDENT
X		{$$ = store_ident_in_list($1);}
X	| ident_list ',' IDENT 
X		{$$ = chain_ident_lists($1, store_ident_in_list($3));}
X	;
X
Xsize_specification:
X	  NUMBER MB
X	| NUMBER GB
X		{$$ = $1 * 1024;}
X	;
X
Xtime_specification:
X	  NUMBER MS
X	;
X
X%%
END_OF_FILE
if test 8845 -ne `wc -c <'config/system.y'`; then
    echo shar: \"'config/system.y'\" unpacked with wrong size!
fi
# end of 'config/system.y'
fi
if test -f 'dcadmin/Status.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcadmin/Status.c'\"
else
echo shar: Extracting \"'dcadmin/Status.c'\" \(7800 characters\)
sed "s/^X//" >'dcadmin/Status.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                             S t a t u s . c                             *
X *                                                                         *
X *                            Package : Administration Process             *
X *                            Version : 1.0                                *
X *                       CreationDate : 16.09.90                           *
X *                         LastUpDate : 06.12.93                           *
X *                                                                         *
X * All routines needed for storing new process states and for displaying   *
X * them.                                                                   *
X *                                                                         *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#ifdef HETEROGENEOUS
X# include <rpc/rpc.h>
X#endif
X#include <signal.h>
X#include <time.h>
X#ifndef UNICOS
X# include <sys/timeb.h>
X#endif
X#include <errno.h>
X#ifdef BSD
X# include <sys/wait.h>
X#endif /* BSD /**/
X#include "ipc.h"
X#include "dcc.h"
X#include "timeout.h"
X#include "dcadmin.h"
X
X#define EXIT(v)			fprintf(stderr, "dcadmin: Terminating!\n"); \
X				exit(v)
X
X/******************************************************************************
X * ChangeProcessStatus()                                                      *
X *                                                                            *
X * Change the state of a process to 'accept or terminate' or 'running'.       *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
XChangeProcessStatus(state)
Xint state;
X{
X    PROCESSDATA p_data;
X    register struct pdat_list *aptr;
X
X    /* Receive the process information of the process */
X    if (_receive_process_data(&p_data)) {
X	error("dcadmin: receiving process data");
X	EXIT(ERROR);
X    }
X    /* Search entry in list and change the state if there is one.
X     * Otherwise return an error.
X     */
X    for(aptr = pdat_first; aptr; aptr = aptr->next) {
X        if (!strcmp(aptr->p_descr.processname, p_data.processname)
X#ifdef iPSC
X	   && aptr->p_descr.port.node == p_data.port.node
X	   && aptr->p_descr.port.pid  == p_data.port.pid) {
X#else
X# ifdef SINGLE
X	   && aptr->p_descr.pid == p_data.pid) {
X# else /* HOMOGENEOUS || HETEROGENEOUS */
X	   && !strcmp(aptr->p_descr.port.hostname, p_data.port.hostname)
X	   && aptr->p_descr.port.portnum == p_data.port.portnum) {
X# endif /* SINGLE /**/
X#endif /* iPSC /**/
X		aptr->status = (state == NOTIFY_ACCORTER_ON) ? ACCORTER : RUNNING;
X#ifdef ADMINDEBUG
X    		fprintf(dfile, "[dbg] %s state of process %s with pid %d modified to %s\n",
X		    _processprefix, aptr->p_descr.processname, aptr->p_descr.pid, 
X		    (state == NOTIFY_ACCORTER_ON) ? "accept or terminate" : 
X		    "running");
X    		if (_debugflush)
X		    fflush(dfile);
X#endif /* ADMINDEBUG /**/
X		if (state == NOTIFY_ACCORTER_ON)
X		    CheckAcceptOrTerminate();
X		return(OK);
X	}
X    } /* for */
X    error("Process to change state not found in process data list");
X    return(ERROR);
X} /* ChangeProcessStatus */
X
X/******************************************************************************
X * DisplayStatus()                                                            *
X *                                                                            *
X * Displays the status of all processes of the 'process data list'.           *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
XDisplayStatus()
X{
X    register struct pdat_list *ptr;
X
X#ifdef DO_NOT_COMPILE
X    switch(fork()) {
X    case -1:
X	error("dcadmin: fork()");
X	EXIT(ERROR);
X	/* break; */
X    case 0:
X	/* child! */
X        printf("\n%-20s |", "PROCESSNAME");
X#ifdef iPSC
X        printf(" %-15s |", "NODE");
X#else
X# ifndef SINGLE
X        printf(" %-20s |", "HOST");
X# endif /* !SINGLE /**/
X#endif /* iPSC /**/
X        printf(" %-10s | %-15s\n", "PID", "STATUS");
X        for(ptr = pdat_first; ptr; ptr = ptr->next) {
X            printf("%-20s |", ptr->p_descr.processname);
X#ifdef iPSC
X            printf(" %-15ld |", ptr->p_descr.port.node);
X#else
X# ifndef SINGLE
X            printf(" %-20s |", ptr->p_descr.port.hostname);
X# endif /* !SINGLE /**/
X#endif /* iPSC /**/
X            printf(" %-10d | ", ptr->p_descr.pid);
X	    switch(ptr->status) {
X	    case RUNNING:
X                printf("%-15s\n", "running");
X		break;
X	    case ACCORTER:
X                printf("%-15s\n", "accept or terminate");
X		break;
X	    default:
X                printf("%-15s\n", "UNKNOWN");
X		break;
X	    } /* switch */
X        } /* for */
X	exit(OK);
X	break;
X    default:
X	/* parent! */
X	Intr = 1;
X        signal(SIGTERM, DisplayStatus);
X    } /* switch */
X#endif
X    return(OK);
X} /* DisplayStatus */
X
X/******************************************************************************
X * GetChildStatus()                                                           *
X *                                                                            *
X * Get status of terminating children to avoid zombies!                       * 
X *                                                                            *
X * Return values: none                                                        *
X ******************************************************************************/
Xint
XGetChildStatus()
X{
X    int              pid,
X                     status;
X    struct pid_list *pptr,
X                    *lptr;
X#ifdef SYSTEM_V
X    pid = wait(&status);
X#else /* BSD */
X    union wait       wstatus;
X
X    pid    = wait3(&wstatus, WNOHANG, NULL);
X    status = wstatus.w_status;
X#endif /* SYSTEM_V /**/
X#ifdef DO_NOT_COMPILE
X    if (status == 0xB1) {
X            fputs(": process was stopped!\n", pfile);
X    } else {
X	    if (!(status & 0xFF))
X	        fprintf(pfile, " by exit call. Exit code = %d\n",
X	            (status & 0xFF00) >> 8);
X	    else
X	        fprintf(pfile, " by signal %d\n", status);
X        }
X	fflush(pfile);
X    }
X#endif
X    /* set signal again */
X    /* signal(SIGCLD, GetChildStatus); */
X    Intr = 1;
X} /* GetChildStatus */
X
END_OF_FILE
if test 7800 -ne `wc -c <'dcadmin/Status.c'`; then
    echo shar: \"'dcadmin/Status.c'\" unpacked with wrong size!
fi
# end of 'dcadmin/Status.c'
fi
if test -f 'dcinstall/Compile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcinstall/Compile.c'\"
else
echo shar: Extracting \"'dcinstall/Compile.c'\" \(8377 characters\)
sed "s/^X//" >'dcinstall/Compile.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                            C o m p i l e . c                            *
X *                                                                         *
X *                            Package : Installer Program                  *
X *                            Version : 1.0                                *
X *                       CreationDate : 20.11.91                           *
X *                         LastUpDate : 03.12.93                           *
X *                                                                         *
X * The routine 'CompileFiles' which performs the complete compilation,     *
X * linking and loading of programs.                                        *
X *                                                                         *
X *               Copyright (C) 1991-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <pwd.h>
X#include "cfgparsers.h"
X#include "dcinstall.h"
X
X/******************************************************************************
X * CompileFiles()                                                             *
X *                                                                            *
X * Compiles, links and loads the files from the local host 'src' specified as *
X * command line arguments on the destination host 'dest'.                     *
X * NOTE: For local compilation 'src' equals 'dest'.                           *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
XCompileFiles(src, dest)
XSYMBTABEL *src;		/* source host      */
XSYMBTABEL *dest;	/* destination host */
X{
X    int mounted;		/* src and dest share one filesystem or not */
X    static char cmd[1000];	/* to store the command */
X    FILENAMELIST *fptr;		/* pointer for file list (xxx.c) */
X    OPTIONLIST *optr;		/* pointer for option list */
X    SYMBTABEL *symbol;		/* loop pointer for symbol table elements */
X    SYMBTABEL *symbol2;		/* loop pointer for symbol table elements */
X    SYMBTABEL *class;		/* destination compilation class */
X    TARGETINFO *targets;	/* all targets the local system can build */
X
X    if (!c_flag && !o_flag)
X	return(OK);
X
X#ifndef DEBUG
X    printf("    Compiling    files on %s (%s)\n",
X        dest->name, dest->info.Host.ex_storage->name);
X#endif /* Not DEBUG /**/
X
X    /* Determine access mode:
X     * If source-host equals destination host or source and dest host
X     * share one disk the access mode is mounted. Otherwise if dest is
X     * accessed via network, it is not mounted!
X     */
X    if (src == dest || src->info.Host.ex_storage->info.disk.location == dest->info.Host.ex_storage->info.disk.location)
X        mounted = TRUE;
X    else
X        mounted = FALSE;
X
X    if (mounted)
X	sprintf(cmd, "cd %s/dcc/compile ;", gethomedir(getLogin()));
X    else
X	sprintf(cmd, "%s %s cd dcc/compile \";\"", RSH, dest->name);
X
X    for(targets = dest->info.Host.compinfo; targets; targets = targets->next) 
X	if (!strcmp(targets->type, dest->info.Host.type->name)
X			&& !strcmp(targets->os, dest->info.Host.os->name))
X	    break;
X
X    if (!targets) {
X	fprintf(stderr, "Error: target specification for computer type \"%s\" of operating",
X            dest->info.Host.type->name);
X        fprintf(stderr, "       system \"%s\" of host \"%s\" not found \n",
X            dest->info.Host.os->name, dest->name);
X        fprintf(stderr, "       in system configuration file \"%s\"\n",
X            cfgfilename);
X	exit(ERROR);
X    }
X
X    strcat(cmd, " ");
X    strcat(cmd, targets->cc);
X    strcat(cmd, " -I. -I../include ");
X    strcat(cmd, targets->cflags);
X    strcat(cmd, " ");
X
X    if (o_flag) {
X	strcat(cmd, "-o ");
X	strcat(cmd, targetname);
X	strcat(cmd, " ");
X    }
X
X    if (c_flag) {
X	strcat(cmd, "-c ");
X	strcat(cmd, " ");
X    }
X
X    for(fptr = first_file; fptr; fptr = fptr->next) {
X	strcat(cmd, fptr->name);
X	strcat(cmd, " ");
X    }
X
X    for(optr = first_opt; optr; optr = optr->next) {
X        strcat(cmd, optr->option);
X	strcat(cmd, " ");
X    }
X
X    if (o_flag) {
X	strcat(cmd, " ../lib/");
X	strcat(cmd,  dest->info.Host.type->name);
X	strcat(cmd, "/dcc.a ");
X    }
X
X    strcat(cmd, targets->libs);
X
X    if (o_flag) {
X	if (mounted)
X	    strcat(cmd, " ; mv ");
X	else
X	    strcat(cmd, " \";\" mv ");
X	strcat(cmd, targetname);
X	strcat(cmd, " ");
X	strcat(cmd, "../bin/");
X	strcat(cmd,  dest->info.Host.type->name);
X	strcat(cmd, "/");
X	strcat(cmd, targetname);
X    }
X
X    if (verbose)
X        printf("    Compilation  command: %s\n", cmd);
X
X    if (!noexecute) 
X        if (system(cmd)) {
X            fprintf(stderr, "\nError compiling the files for host \"%s\"\n", 
X		dest->name);
X            fprintf(stderr, "The following command caused the error:\n");
X            fprintf(stderr, "\"%s\"\n", cmd);
X            exit(ERROR);
X        }
X
X    dest->info.Host.wasmade = TRUE;
X
X    /* check the remainding hosts */
X    for(symbol = symbtab; symbol; symbol = symbol->next) {
X
X	if (symbol->type == S_HOST
X		&& symbol->info.Host.type == dest->info.Host.type
X                && symbol->info.Host.os   == dest->info.Host.os) {
X
X	    if (!symbol->info.Host.istarget || symbol->info.Host.wasmade)
X		continue;
X
X	    if (symbol->info.Host.ex_storage == dest->info.Host.ex_storage) {
X		/* Host shares files with compilation host => nothing to do! */
X	        symbol->info.Host.wasmade = TRUE;
X	    } else {
X		/* Host has own filesystem => distribute generated executables 
X		 */
X		if (o_flag) {
X#ifndef DEBUG
X    		    printf("    Distributing files %s (%s) -> %s (%s)\n",
X        	        dest->name, dest->info.Host.ex_storage->info.disk.location->name, 
X		        symbol->name, symbol->info.Host.ex_storage->info.disk.location->name);
X#endif /* Not DEBUG /**/
X		    sprintf(cmd, "rcp %s/dcc/bin/%s/%s %s@%s:dcc/bin/%s/%s",
X			gethomedir(getLogin()), dest->info.Host.type->name,
X			targetname, getLogin(), symbol->name, 
X			dest->info.Host.type->name, targetname);
X		    if (verbose)
X		        printf("Distribution command: %s\n", cmd);
X		    if (!noexecute)
X                        if (system(cmd)) {
X	                    fprintf(stderr, "\nError distributing the files to host \"%s\"\n", 
X			        symbol->name);
X	                    fprintf(stderr, "The following command caused the error:\n");
X	                    fprintf(stderr, "\"%s\"\n", cmd);
X	                    exit(ERROR);
X	                }
X		}
X    		/* all hosts of this filesystem and the same class are also 
X		 * marked 
X		 */
X    		for(symbol2 = symbtab; symbol2; symbol2 = symbol2->next) {
X		    if (symbol2->type == S_HOST 
X			    && symbol2->info.Host.type == symbol->info.Host.type
X                            && symbol2->info.Host.os   == symbol->info.Host.os
X                            && symbol2->info.Host.ex_storage == symbol->info.Host.ex_storage) {
X			symbol2->info.Host.wasmade = TRUE;
X		    }
X		} /* for */
X	    }
X	}
X
X    } /* for(symbol) */
X
X    return(OK);
X
X} /* CompileFiles */
END_OF_FILE
if test 8377 -ne `wc -c <'dcinstall/Compile.c'`; then
    echo shar: \"'dcinstall/Compile.c'\" unpacked with wrong size!
fi
# end of 'dcinstall/Compile.c'
fi
if test -f 'dcinstall/ParseOptions.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcinstall/ParseOptions.c'\"
else
echo shar: Extracting \"'dcinstall/ParseOptions.c'\" \(8792 characters\)
sed "s/^X//" >'dcinstall/ParseOptions.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                       P a r s e O p t i o n s . c                       *
X *                                                                         *
X *                            Package : Installer Program                  *
X *                            Version : 1.1                                *
X *                       CreationDate : 20.11.91                           *
X *                         LastUpDate : 25.02.92                           *
X *                                                                         *
X *             Parses and interprets the command line options.             *
X *                                                                         *
X *               Copyright (C) 1991-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <string.h>
X#include <sys/types.h>
X#include "cfgparsers.h"
X#include "dcinstall.h"
X
X/******************************************************************************
X * ParseOptions()                                                             *
X *                                                                            *
X * Parses and interprets the command line options.                            *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
XParseOptions(argc, argv)
Xint   argc;
Xchar *argv[];
X{
X    int          i;
X    int          length;
X    char         *suffix;
X    char          localhostname[MAXHOSTNAMELEN];
X    char          input[80];
X    FILENAMELIST *fptr;
X    OPTIONLIST   *optr;
X    SYMBTABEL    *symbol;
X
X    for(i = 1; i < argc; i++) {
X
X	if (!strcmp(argv[i], "-f")) {
X	    /* this option was already managed! */
X	    ++i;
X	    continue;
X	}
X
X	if (!strcmp(argv[i], "-c")) {
X	    /* Option: "-c" */
X	    if (o_flag) {
X		fputs("Error: Option '-o' and '-c' combined\n", stderr);
X		exit(ERROR);
X	    }
X	    c_flag = TRUE;
X#ifdef DEBUG
X	    printf("Option recognized: \"-c\"\n");
X#endif /* DEBUG /**/
X	    continue;
X	}
X
X	if (!strcmp(argv[i], "-o")) {
X	    /* Option: "-o" */
X	    if (c_flag) {
X		fputs("Error: Option '-c' and '-o' combined\n", stderr);
X		exit(ERROR);
X	    }
X	    o_flag = TRUE;
X	    targetname = argv[++i];
X#ifdef DEBUG
X	    printf("Option recognized: \"-o %s\"\n", targetname);
X#endif /* DEBUG /**/
X	    continue;
X	}
X
X	if (!strcmp(argv[i], "-target")) {
X	    if (!strcmp(argv[++i], "all")) {
X		/* Option: "-target all" */
X		alltargets = TRUE;
X#ifdef DEBUG
X		printf("Option recognized: \"-target all\"\n");
X#endif /* DEBUG /**/
X	        for(symbol = symbtab; symbol; symbol = symbol->next) {
X	            if (symbol->type == S_HOST)
X		        symbol->info.Host.istarget = TRUE;
X		}
X		continue;
X	    } else {
X		/* Option: "-target local" or "-target hostname" */
X		if (!strcmp(argv[i], "local")) {
X		    localtarget = TRUE;
X		    if (gethostname(localhostname, MAXHOSTNAMELEN)) {
X			fputs("Error: can't determine name of local host\n", stderr);
X			exit(ERROR);
X		    }
X		    symbol = lookup_symbtabel(localhostname);
X		} else {
X		    symbol = lookup_symbtabel(argv[i]);
X		}
X		if (symbol == NULL) {
X		    fprintf(stderr, "Error: target system for hostname \"%s\" is not defined in\n", 
X		        (localtarget) ? localhostname : argv[i]);
X		    fprintf(stderr, "       system configuration file \"%s\"\n", 
X		        cfgfilename);
X		    exit(ERROR);
X		}
X		if (symbol->type != S_HOST) {
X		    fprintf(stderr, "Error: target system for hostname \"%s\" is not defined as\n",
X		        argv[i]);
X		    fprintf(stderr, "       hostname in system configuration file \"%s\"\n", 
X			cfgfilename);
X		    exit(ERROR);
X		}
X		symbol->info.Host.istarget = TRUE;
X	    }
X#ifdef DEBUG
X	    printf("Option recognized: \"-target %s\"\n", argv[i]);
X#endif /* DEBUG /**/
X		continue;
X	}
X
X	if (!strcmp(argv[i], "-prepare")) {
X	    /* Option: "-prepare" */
X	    prepare = TRUE;
X#ifdef DEBUG
X	    printf("Option recognized: \"-prepare\"\n");
X#endif /* DEBUG /**/
X	    if (!noexecute) {
X	        puts("WARNING: The option \"-prepare\" causes the destruction of all data");
X	        puts("         in the directory \"dcc\" including all subdirectories at");
X	        puts("         all specified hosts!");
X	        printf("Do you really want to continue? (y/n) ");
X	        scanf("%s", input);
X	        if (input[0] != 'y' && input[0] != 'Y')
X		    exit(OK);
X	    }
X	    continue;
X	}
X
X	if (!strcmp(argv[i], "-clean")) {
X	    /* Option: "-clean" */
X	    clean = TRUE;
X#ifdef DEBUG
X	    printf("Option recognized: \"-clean\"\n");
X#endif /* DEBUG /**/
X	    continue;
X	}
X
X	if (!strcmp(argv[i], "-crosscompile")) {
X	    /* Option: "-crosscompile" */
X	    crosscompile = TRUE;
X#ifdef DEBUG
X	    printf("Option recognized: \"-crosscompile\"\n");
X#endif /* DEBUG /**/
X	    fputs("Error: Option 'crosscompile' not yet implemented\n", stderr);
X	    fputs("This will be done in a future release.\n", stderr);
X	    exit(ERROR);
X	    continue;
X	}
X
X	if (!strcmp(argv[i], "-checktargets")) {
X	    /* Option: "-checktargets" */
X	    checktargets = TRUE;
X#ifdef DEBUG
X	    printf("Option recognized: \"-checktargets\"\n");
X#endif /* DEBUG /**/
X	    fputs("Error: Option 'checktargets' not yet implemented\n", stderr);
X	    fputs("This will be done in a future release.\n", stderr);
X	    exit(ERROR);
X	    continue;
X	}
X
X	if (!strcmp(argv[i], "-verbose")) {
X	    /* Option: "-verbose" */
X	    verbose = TRUE;
X#ifdef DEBUG
X	    printf("Option recognized: \"-verbose\"\n");
X#endif /* DEBUG /**/
X	    continue;
X	}
X
X	if (!strcmp(argv[i], "-noexecute")) {
X	    /* Option: "-noexecute" */
X	    noexecute = TRUE;
X#ifdef DEBUG
X	    printf("Option recognized: \"-noexecute\"\n");
X#endif /* DEBUG /**/
X	    continue;
X	}
X
X#ifdef YYDEBUG
X	if (!strcmp(argv[i], "-yydebug")) {
X	    /* Option: "-yydebug" */
X# ifdef DEBUG
X	    printf("Option recognized: \"-yydebug\"\n");
X# endif /* DEBUG /**/
X	    yydebug = 1;
X	    continue;
X	}
X#endif /* YYDEBUG /**/
X
X	length = strlen(argv[i]);
X	suffix = argv[i] + length - 2;
X
X	if (!strncmp(suffix, ".c", 2)) {
X	    /* Option: "<name>.c" */
X#ifdef DEBUG
X	    printf("Option recognized: filename \"%s\"\n", argv[i]);
X#endif /* DEBUG /**/
X	    /* store filename in filename list */
X	    fptr = (FILENAMELIST *) Malloc(sizeof(FILENAMELIST));
X	    fptr->name = argv[i];
X	    fptr->next = NULL;
X	    if (first_file == NULL) 
X		first_file = last_file = fptr;
X	    else {
X		last_file->next = fptr;
X		last_file = fptr;
X	    }
X	    continue;
X	}
X
X	if (!strncmp(suffix, ".h", 2)) {
X	    /* Option: "<name>.h" */
X#ifdef DEBUG
X	    printf("Option recognized: include filename \"%s\"\n", argv[i]);
X#endif /* DEBUG /**/
X	    /* store include filename in include filename list */
X	    fptr = (FILENAMELIST *) Malloc(sizeof(FILENAMELIST));
X	    fptr->name = argv[i];
X	    fptr->next = NULL;
X	    if (first_incl_file == NULL) 
X		first_incl_file = last_incl_file = fptr;
X	    else {
X		last_incl_file->next = fptr;
X		last_incl_file = fptr;
X	    }
X	    continue;
X	}
X
X#ifdef DEBUG
X	printf("Storing unknown Option: \"%s\"\n", argv[i]);
X#endif /* DEBUG /**/
X	/* store option in option list */
X	optr = (OPTIONLIST *) Malloc(sizeof(OPTIONLIST));
X	optr->option = argv[i];
X	optr->next = NULL;
X	if (first_opt == NULL) 
X	    first_opt = last_opt = optr;
X	else {
X	    last_opt->next = optr;
X	    last_opt = optr;
X	}
X
X    } /* for(i) */
X
X    return(OK);
X} /* ParseOptions */
END_OF_FILE
if test 8792 -ne `wc -c <'dcinstall/ParseOptions.c'`; then
    echo shar: \"'dcinstall/ParseOptions.c'\" unpacked with wrong size!
fi
# end of 'dcinstall/ParseOptions.c'
fi
if test -f 'dcinstall/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcinstall/main.c'\"
else
echo shar: Extracting \"'dcinstall/main.c'\" \(7420 characters\)
sed "s/^X//" >'dcinstall/main.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                               m a i n . c                               *
X *                                                                         *
X *                            Package : Installer Program                  *
X *                            Version : 1.1                                *
X *                       CreationDate : 20.11.91                           *
X *                         LastUpDate : 25.02.92                           *
X *                                                                         *
X *              The routine 'main' and the global variables.               *
X *                                                                         *
X *               Copyright (C) 1991-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include "cfgparsers.h"
X#include "dcinstall.h"
X#include "version.h"
X
X/*
X * global variables
X */
X
Xint alltargets;			/* perform actions for all targets */
Xint checkfile; 			/* check configuration file only or not */
Xint checktargets; 		/* check targets or not */
Xint c_flag;			/* option '-c' or not */
Xint clean;		        /* clean targets' remote compilation dirs */
Xint crosscompile; 		/* use cross compilation if possible or not */
Xint localtarget;    		/* perform actions for local host only */
Xint noexecute; 			/* execute commands or not */
Xint o_flag;			/* option '-o' or not */
Xint prepare;			/* install runtime library or not */
Xint verbose; 			/* print commands or not */
Xchar cfgfilename[MAXPATHNAMELEN]; /* name of configuration file */
Xchar *targetname;		/* name of compilation target */
XFILENAMELIST *first_file;       /* pointer to beginning of file list (xxx.c) */
XFILENAMELIST *last_file;        /* pointer to end       of file list (xxx.c) */
XFILENAMELIST *first_incl_file; 	/* pointer to beginning of file list (xxx.h) */
XFILENAMELIST *last_incl_file;	/* pointer to end       of file list (xxx.h) */
XOPTIONLIST *first_opt;		/* pointer to beginning of option list */
XOPTIONLIST *last_opt;		/* pointer to end       of option list */
XSYMBTABEL *symbtab;		/* pointer to beginning of symbol table */
XSYMBTABEL *last_symb;		/* pointer to end       of symbol table */
X#ifdef LINUX
Xint yylineno;
X#endif 
X
X/******************************************************************************
X * main()                                                                     *
X *                                                                            *
X * The function main.                                                         *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xmain(argc, argv)
Xint   argc;
Xchar *argv[];
X{
X    int i;
X    char localhostname[MAXHOSTNAMELEN];
X    SYMBTABEL *local_host, *dummy, *class, *symbol, 
X              *acthost, *actfsys, *cc_host;
X    char *descr;
X
X    /* some initializations */
X    prepare = clean = o_flag = c_flag = alltargets = FALSE;
X    crosscompile = checkfile = checktargets = FALSE;
X    localtarget = noexecute = verbose = FALSE;
X    symbtab = NULL;
X    targetname = NULL;
X    first_incl_file = last_incl_file = NULL;
X    cfgfilename[0] = 0;
X
X    /* is there any job? */
X    if (argc == 1) {
X        fprintf(stderr, "%s\n%s\n%s\n\n", progname, version, copyright);
X	fputs("Error: nothing to do\n\n", stderr);
X	DisplayUsage();
X	exit(ERROR);
X    }
X
X    /* check command line for '-f' option */
X    for(i = 1; i < argc; i++) {
X	if (!strcmp(argv[i], "-f")) {
X	    /* Option: "-f filename" */
X	    strcpy(cfgfilename, argv[++i]);
X#ifdef DEBUG
X	    printf("Option recognized: \"-f %s\"\n", cfgfilename);
X#endif /* DEBUG /**/
X	    break;
X	}
X    } /* for */
X
X    /* search default file in home directory */
X    if (cfgfilename[0] == 0)
X	sprintf(cfgfilename, "%s/%s", getenv("HOME"), CFGFILENAME);
X
X    /* interpret system configuration file */
X    if (!(yyin = fopen(cfgfilename, "r"))) {
X	fprintf(stderr, "Error: can't open system configuration file \"%s\"\n",
X	    cfgfilename);
X	exit(ERROR);
X    } else {
X        (void) parse_system();
X        (void) close(yyin);
X    }
X
X    /* parse command line (must follow reading of cfg file!!!) */
X    if (ParseOptions(argc, argv)) {
X	DisplayUsage();
X	exit(ERROR);
X    }
X
X    /* determine hostname of local host */
X    if (gethostname(localhostname, MAXHOSTNAMELEN)) {
X        fputs("Error: can't determine name of local host!\n", stderr);
X	exit(ERROR);
X    }
X
X    /* determine host informtion of local host */
X    if (!(local_host = lookup_symbtabel(localhostname))) {
X	fputs("Error: local hostname is not defined in configuration file\n", stderr);
X	exit(ERROR);
X    }
X
X    if (localtarget)
X	local_host->info.Host.istarget = TRUE;
X
X    /* prepare all target hosts if specified as command line option */
X    if (prepare) {
X        for(acthost = symbtab; acthost; acthost = acthost->next) {
X	    if (acthost->type != S_HOST || acthost->info.Host.ex_storage->info.disk.wasprepared)
X		continue;
X	    PrepareTarget(local_host, acthost);
X	}
X    }
X
X    /* generate the requested object files or executables for all targets
X     * specified in the command line
X     */
X    if (c_flag || o_flag || first_file || first_incl_file) {
X        for(dummy = symbtab; dummy; dummy = dummy->next) {
X
X	    if (dummy->type != S_HOST || !dummy->info.Host.istarget || dummy->info.Host.wasmade)
X	        continue;
X
X	    TransferFiles(local_host, dummy);
X    
X	    CompileFiles(local_host, dummy);
X
X	    dummy->info.Host.wasmade = TRUE;
X
X        } /* for(dummy) */
X    }
X
X    /* clean all target hosts if specified as command line option */
X    if (clean) {
X        for(acthost = symbtab; acthost; acthost = acthost->next) {
Xif (acthost->type != S_HOST || acthost->info.Host.ex_storage->info.disk.wasprepared)
X	    if (acthost->type != S_HOST || !acthost->info.Host.istarget 
X			    || acthost->info.Host.ex_storage->info.disk.wascleaned)
X		continue;
X	    CleanTarget(local_host, acthost);
X	}
X    }
X
X    exit(OK);
X} /* main */
END_OF_FILE
if test 7420 -ne `wc -c <'dcinstall/main.c'`; then
    echo shar: \"'dcinstall/main.c'\" unpacked with wrong size!
fi
# end of 'dcinstall/main.c'
fi
if test -f 'include/com_Errno.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/com_Errno.h'\"
else
echo shar: Extracting \"'include/com_Errno.h'\" \(7384 characters\)
sed "s/^X//" >'include/com_Errno.h' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                         c o m _ E r r n o . h                           *
X *                                                                         *
X *                            Package : Include files                      *
X *                            Version : 1.0                                *
X *                       CreationDate : 10.07.90                           *
X *                         LastUpDate : 30.08.91                           *
X *                                                                         *
X *                     Error codes of compiler errors.                     *
X *                                                                         *
X *      Copyright (C) 1990-1994 by Franz Distler and Christoph Pleier.     *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#ifndef __com_Errno_h
X#define __com_Errno_h
X
X/* syntax error */
X#define ESYNTAX		0
X
X/* redefinition of an identifier */
X#define EREDEFINITION	1
X
X/* definition or creation of not specified process */
X#define ENOTSPECIFIED	2
X
X/* redefinition of a process body */
X#define EREDEFINED	3
X
X/* creation of not defined process */
X#define ENOTDEFINED	4
X
X/* call of not specified transaction */
X#define EILLTRANSCALL	5
X
X/* badly placed accept statement */
X#define EBADLYACCEPT	6
X
X/* no variable and no parameter */
X#define ENOVARORPAR	7
X
X/* error in process specification */
X#define EINPROCSPEC	8
X
X/* process parameter expected */
X#define EPROCPAREXP	9
X
X/* process parameter expected */
X#define EPROCPAREXP2	10
X
X/* error in process parameter declaration */
X#define EINPROCPARAM	11
X
X/* process transaction expected */
X#define EPROCTRANSEXP	12
X
X/* process transaction expected */
X#define EPROCTRANSEXP2	13
X
X/* error in process transaction declaration */
X#define EINTRANSDECL	14
X
X/* error in process transaction declaration */
X#define EINTRANSDECL2	15
X
X/* error in process transaction declaration */
X#define EINTRANSDECL3	16
X
X/* error in process definition */
X#define EINPROCDEF	17
X
X/* error in accept statement */
X#define EINACCSTAT	18
X
X/* error in accept statement */
X#define EINACCSTAT2	19
X
X/* error in accept statement */
X#define EINACCSTAT3	20
X
X/* error in accept statement */
X#define EINACCSTAT4	21
X
X/* error in select statement */
X#define EINSELSTAT	22
X
X/* error in select statement */
X#define EINSELSTAT2	23
X
X/* error in select part */
X#define EINSELPART	24
X
X/* error in accept alternative */
X#define EINACCALTERN	25
X
X/* error in destroy statement */
X#define EINDESTRSTAT	26
X
X/* error in timed transaction call */
X#define EINTIMEDTRANS	27
X
X/* error in process creation */
X#define EINPROCCREATE	28
X
X/* error in process creation */
X#define EINPROCCREATE2	29
X
X/* error in process creation */
X#define EINPROCCREATE3	30
X
X/* error in process arguments */
X#define EINPROCARGS	31
X
X/* error in process location */
X#define EINPROCLOC	32
X
X/* error in transaction call */
X#define EINTRANSCALL	33
X
X/* error: 'const' is not allowed in structure definitions */
X#define EILLCONST	34
X
X/* error: 'volatile' is not allowed in structure definitions */
X#define EILLVOLATILE	35
X
X/* error: 'void' is not allowed in structure definitions */
X#define EILLVOID	36
X
X/* error: too many type specifiers at 'char' */
X#define EILLCHAR	37
X
X/* error: too many type specifiers at 'short' */
X#define EILLSHORT	38
X
X/* error: too many type specifiers at 'int' */
X#define EILLINT		39
X
X/* error: too many type specifiers at 'long' */
X#define EILLLONG	40
X
X/* error: too many type specifiers at 'float' */
X#define EILLFLOAT	41
X
X/* error: too many type specifiers at 'double' */
X#define EILLDOUBLE	42
X
X/* error: too many type specifiers at 'process' */
X#define EILLPROCESS	43
X
X/* error: badly placed 'signed' */
X#define EILLSIGNED	44
X
X/* error: badly placed 'unsigned' */
X#define EILLUNSIGNED	45
X
X/* error: enumerations are not allowed in special used structures */
X#define EILLENUM	46
X
X/* error: bitfields are not allowed in special used structures */
X#define EILLBITFIELD	47
X
X/* error: illegal pointer */
X#define EILLPOINTER	48
X
X/* error: too many pointers in special used structure */
X#define EMANYPOINTER	49
X
X/* error: type qualifier in combination with pointer is not allowed here */
X#define EILLPOINTQUAL	50
X
X/* error: function definitions are not allowed in special used structures */
X#define EILLFUNCTION	51
X
X/* error: arrays are not allowed in special used structures */
X#define EILLARRAY	52
X
X/* error: unknown array size */
X#define EARRAYSIZE	53
X
X/* error: braces '(' ')' are not allowed in combination with arrays */
X#define EILLARRBRACES	54
X
X/* error: function definitions are not allowed before arrays */
X#define EILLARRFUNCT   	55
X
X/* error: multiple dimensional arrays are not allowed here */
X#define EMULTIARRAY   	56
X
X/* error: braces '(' ')' are not allowed in special used structures */
X#define EILLBRACES	57
X
X/* error: typedef names are not allowed in special used structures */
X#define EILLTYPENAME	58
X
X/* error: 'auto' is not allowed in special used typedefs */
X#define EILLAUTO	59
X
X/* error: 'register' is not allowed in special used typedefs */
X#define EILLREGISTER	60
X
X/* error: 'static' is not allowed in special used typedefs */
X#define EILLSTATIC	61
X
X/* error: 'extern' is not allowed in special used typedefs */
X#define EILLEXTERN	62
X
X/* error: illegal typedef */
X#define EILLTYPEDEF	63
X
X/* error: 'const' is not allowed in special used typedefs */
X#define EILLCONST2	64
X
X/* error: 'volatile' is not allowed in special used typedefs */
X#define EILLVOLATILE2	65
X
X/* error: 'void' is not allowed in special used typedefs */
X#define EILLVOID2	66
X
X/* error: enumerations are not allowed in special used typedefs */
X#define EILLENUM2	67
X
X/* error: structure definition inside of struct definition requires tag name */
X#define EISTRUCTTAG	68
X
X/* error: structure definition of type definition requires tag name */
X#define ETSTRUCTTAG	69
X
X/* fatal error: cannot recover from errors */
X#define FCANTRECOVER	70
X
X/* warning, too few arguments for process creation */
X#define WPROCESSARGS	71
X
X/* warning, too few arguments for transaction call */
X#define WTRANSARGS	72
X
X#endif /* !__com_Errno_h */
END_OF_FILE
if test 7384 -ne `wc -c <'include/com_Errno.h'`; then
    echo shar: \"'include/com_Errno.h'\" unpacked with wrong size!
fi
# end of 'include/com_Errno.h'
fi
if test -f 'include/globals.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/globals.h'\"
else
echo shar: Extracting \"'include/globals.h'\" \(7825 characters\)
sed "s/^X//" >'include/globals.h' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                          g l o b a l s . h                              *
X *                                                                         *
X *                            Package : Include files                      *
X *                            Version : 1.0                                *
X *                       CreationDate : 14.08.90                           *
X *                         LastUpDate : 06.12.93                           *
X *                                                                         *
X *                      Global variables and tables.                       *
X *                                                                         *
X *      Copyright (C) 1990-1994 by Franz Distler and Christoph Pleier.     *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X/* the symbol table */
XSYMBTAB symbtab;
X
X/* the global variable to store the actual error */
Xint Errno = -1;
X
X/* the flag controlling error handling.
X * while errflag is set, the semantical functions are not executed!
X */
Xshort errflag = FALSE;
X
X/* the flag indicating an error during a process specification */
Xshort specerr = FALSE;
X
X/* the flag controlling creation of code.
X * while outcodeflag is set, the creation of code is stopped!
X */
Xshort outcodeflag = FALSE;
X
X/* the flag indicating parsing of a process body or not */
Xshort bodyflag = FALSE;
X
X/* the flag indicating function main() was declared or not */
Xshort mainflag = FALSE;
X
X/* this flag controls code generation in include files.
X * while sysinclflag is set, no code will be stored using Strcat(), 
X * Strcatmany() * or strmalloc()!
X */
Xshort sysinclflag = FALSE;
X
X/* the functions are collected in a special function file. The appropriate
X * file header may only be written once to this file. funcflag is used to
X * indicate if the header has already be written or not.
X */
Xshort funcflag = FALSE;
X
X/* the functions to create processes and to perform transactions are collected
X * in a special file. The appropriate file header may only be written once to
X * this file. specflag is used to indicate if the header has already be written
X * or not.
X */
Xshort specflag = FALSE;
X
X#if defined(HETEROGENEOUS) || defined(CHECK_XDR)
X/* the xdr routines to encode and decode data are collected in a special file. 
X * The appropriate file header may only be written once to this file. xdrflag 
X * is used to indicate if the header has already be written or not.
X */
Xshort xdrflag = FALSE;
X#endif /* HETEROGENEOUS /**/
X
X/* this flags control the various passes */
Xshort allflag     = FALSE,	/* compile and link files or not */
X      beautyflag  = FALSE,	/* beautify generated files or not */
X      infoflag    = FALSE,	/* display infos about internal actions */
X      cppflag	  = FALSE;	/* preprocess source files only or not */
X
X#ifndef YYDEBUG
X/* the flag indicating output of additional parsing information. If yydebug
X * equals 1 additional information will be displayed.
X */
X# ifdef UNICOS
Xlong yydebug = 0;
X# else
Xint yydebug = 0;
X# endif /* UNICOS /**/
X#endif /* YYDEBUG /**/
X
X/* the actual line number in the parsed file */
X#ifdef LINUX
Xint yylineno;
X#endif /* LINUX /**/
X
X#ifdef HETEROGENEOUS
X/* the flag indicating if code shall be generated to determine the buffer size 
X * of the encode/decode buffer or to use a fixed value.
X */
Xshort determine_dcc_buf_size = TRUE;
X
X/* the size specified as command line option */
Xchar *encode_decode_buf_size = NULL;
X
X/* print warning only one times */
Xshort encode_warning = FALSE;
X#endif /* HETEROGENEOUS /**/
X
X/* files */
XFILE *yyerrfile = NULL,		/* for error messages */
X     *outfile   = NULL,		/* for main program */
X     *inclfile  = NULL,		/* for dynamic includefile */
X     *funcfile  = NULL,		/* for functions */
X     *creatfile = NULL,		/* for specific process creation routines */
X#if defined(HETEROGENEOUS) || defined(CHECK_XDR)
X     *xdrfile   = NULL,		/* for xdr routines */
X#endif
X     *makefile  = NULL,		/* for makefile */
X     *debugfile = NULL;		/* for debug messages */
X
X/* filenames */
Xchar *inputfilename,
X     *yyerrfilename,
X      outputfilename[MAXFILENAMELEN],
X      funcfilename[MAXFILENAMELEN],
X      inclfilename[MAXFILENAMELEN],
X      creatfilename[MAXFILENAMELEN],
X#if defined(HETEROGENEOUS) || defined(CHECK_XDR)
X      xdrfilename[MAXFILENAMELEN],
X#endif
X      makefilename[MAXFILENAMELEN],
X      filenameprefix[MAXFILENAMELEN];
X
X/* strings to store special data temporary */
Xchar *crextstr,		/* the extern declarations of the creation routines */
X     *trextstr,		/* the declarations of the transaction call routines */	
X#if defined(HETEROGENEOUS) || defined(CHECK_XDR)
X     *xdrextstr,	/* the extern declarations of the xdr routines */
X#endif
X     *fnextstr,		/* the extern declarations of functions */	
X     *errormesg;	/* error message utility */
X
X/* string to store specified makefile options to pass to the generated 
X * makefile
X */
Xchar  *libsstr   = "",	/* libraries */
X      *cflagsstr = "",	/* compiler flags */
X      *lflagsstr = "";	/* loader flags */
X
X/* counters */
Xint phase      = 0,	/* compiler phase */
X    blknum     = 0,	/* block depth counter */
X    processnum = 0,	/* process counter */
X    transnum   = 0,	/* transaction counter */
X    yynwarns   = 0,	/* compiler warnings */
X    translabel = 0;	/* transaction labels */
X
X/* during parsing of the declaration of process variables processptr points to 
X * the symbol table entry containing the corresponding process declaration.
X */
XSYMBTABEL *processptr;
X
X/* buffer to store the result of convert attribute to string routines */
Xchar *convert_buffer;
X
X/* prefix for displaying informations about internal actions */
Xchar *infoprefix = "***";
X
X/* the include files for processes and the main program */
Xchar *includefiles[] =
X	{ "\"/usr/include/stdio.h\"", 
X	  "\"/usr/include/sys/types.h\"", 
X	  "" 
X	};
X
X/* anchors of process list */
Xstruct process_list *first_processname = NULL,
X		    *last_processname  = NULL;
X
X/* anchors of include list */
Xstruct include_list *first_includename = NULL,
X		    *last_includename  = NULL;
X
X/* anchors of additional include paths */
Xstruct include_path_list *first_inclpathname = NULL,
X                         *last_inclpathname  = NULL;
X
X/* anchors of additional preprocessor definitions */
Xstruct cpp_def_list *first_cppdef = NULL,
X                    *last_cppdef  = NULL;
X
X/* anchors of list of symbol table entries of structure and type definitions */
Xstruct struct_type_list *first_structtype = NULL,
X                        *last_structtype  = NULL;
END_OF_FILE
if test 7825 -ne `wc -c <'include/globals.h'`; then
    echo shar: \"'include/globals.h'\" unpacked with wrong size!
fi
# end of 'include/globals.h'
fi
if test -f 'include/run_errlist.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/run_errlist.h'\"
else
echo shar: Extracting \"'include/run_errlist.h'\" \(7317 characters\)
sed "s/^X//" >'include/run_errlist.h' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                      r u n _ e r r l i s t . h                          *
X *                                                                         *
X *                            Package : Include files                      *
X *                            Version : 1.0                                *
X *                       CreationDate : 14.08.90                           *
X *                         LastUpDate : 12.03.92                           *
X *                                                                         *
X *            The table containing the runtime error messages.             *
X *                                                                         *
X *      Copyright (C) 1990-1994 by Franz Distler and Christoph Pleier.     *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#ifndef __run_errlist_h
X#define __run_errlist_h
X
X/* the names in braces mean:
X *    AP  - Administration Process
X *    CP  - Creator Process
X *    NP  - New created Process
X *    TC  - Transaction Caller
X *    TA  - Transaction Acceptor
X *    TAS - Transaction Acceptor during Select
X *    P   - any Process
X */
X
Xchar *runtime_errlist[] = { 
X
X   /* EFATAL */
X   "fatal error",
X
X   /* ESYSTEMDPNT */
X   "system dependent error",
X
X   /* ECREATEPORT */
X   "unable to create a new port",
X
X   /* EDELETEPORT */
X   "unable to delete specified port",
X
X   /* EACPTCON	*/
X   "error accepting connection",
X
X   /* EMAKECON	*/
X   "error making connection",
X
X   /* ECLOSECON */
X   "error closing connection",
X
X   /* ERECVDATA */
X   "error receiving data",
X
X   /* ESENDDATA */
X   "error sending data",
X
X   /* ECONREFUSED */
X   "connection refused",
X
X   /* ETIMEOUT	*/
X   "operation timed out",
X
X   /* ETCCPTONPACC */
X   "Timeout error: (CP) created process doesn't report back",
X
X   /* ETCCPTONPCON */
X   "Timeout error: (CP) can't connect to new created process",
X
X   /* ETCCPTONPRCV */
X   "Timeout error: (CP) new process doesn't send process data",
X
X   /* ETCCPTONPPAR */
X   "Timeout error: (CP) can't send initial parameters to new process",
X
X   /* ETCCPTONPPDAT */
X   "Timeout error: (CP) can't send port information to new process",
X
X   /* ETCCPTOAPCON */
X   "Timeout error: (CP) can't connect to administration process",
X
X   /* ETCCPTOAPREQ */
X   "Timeout error: (CP) can't send location request to administration process",
X
X   /* ETCCPTOAPSND */
X   "Timeout error: (CP) can't send processname to administration process",
X
X   /* ETCCPTOAPRCV */
X   "Timeout error: (CP) can't get location info from administration process",
X
X   /* ETCNPTOAPCON */
X   "Timeout error: (NP) can't connect to administration process",
X
X   /* ETCNPTOAPREQ */
X   "Timeout error: (NP) can't send request to administration process",
X
X   /* ETCNPTOAPSND */
X   "Timeout error: (NP) can't send process data to administration process",
X
X   /* ETCNPTOCPCON */
X   "Timeout error: (NP) can't connect to creator process",
X
X   /* ETCNPTOCPACC */
X   "Timeout error: (NP) creator process doesen't request connection",
X
X   /* ETCNPTOCPSND */
X   "Timeout error: (NP) can't send process data back to creator",
X
X   /* ETCNPGETPARA */
X   "Timeout error: (NP) can't receive parameters from creator process",
X
X   /* ETCNPGETPDAT */
X   "Timeout error: (NP) can't receive port information from creator process",
X
X   /* ETTCONTOPROC */
X   "Timeout error: (TC) can't connect to called process",
X
X   /* ETTSNDREQUEST */
X   "Timeout error: (TC) can't send transaction request message",
X
X   /* ETTRCVREPLY */
X   "Timeout error: (TC) called process doesn't send reply message",
X
X   /* ETTSENDARGS */
X   "Timeout error: (TC) can't send transaction arguments to called process",
X
X   /* ETTRCVRESULT */
X   "Timeout error: (TC) can't receive transaction result",
X
X   /* ETAACCEPTCON */
X   "Timeout error: (TA) can't accept transaction request connection",
X
X   /* ETARCVREQUEST */
X   "Timeout error: (TA) can't receive transaction request message",
X
X   /* ETASENDREPLY */
X   "Timeout error: (TA) can't send transaction reply message",
X
X   /* ETARCVPARAMS */
X   "Timeout error: (TA) can't receive transaction parameters",
X
X   /* ETASNDRESULT */
X   "Timeout error: (TA) can't send transaction result",
X
X   /* ETSACCEPTCON */
X   "Timeout error: (TAS) can't accept transaction request connection",
X
X   /* ETSRCVREQUEST */
X   "Timeout error: (TAS) can't receive transaction request message",
X
X   /* ETSSENDREPLY */
X   "Timeout error: (TAS) can't send transaction reply message",
X
X   /* ETSRCVPARAMS */
X   "Timeout error: (TAS) can't receive transaction parameters",
X
X   /* ETSSNDRESULT */
X   "Timeout error: (TAS) can't send transaction result",
X
X   /* ETCAPTOCPCON */
X   "Timeout error: (AP) can't connect to creator process", 
X
X   /* ETCAPTOCPACC */
X   "Timeout error: (AP) can't get connection to receive config filename", 
X
X   /* ETCAPTOCPRCV */
X   "Timeout error: (AP) can't receive config filename", 
X
X   /* ETCADRCVNAME */
X   "Timeout error: (AP) can't receive process name to determine location of",
X
X   /* ETCADSNDLOC */
X   "Timeout error: (AP) can't send process creation location result",
X
X    /* ETCONNTYPESND */
X    "Timeout error: (P) can't send connection type",
X
X    /* ETCONNTYPERCV */
X    "Timeout error: (P) can't receive connection type",
X
X   /* EPROCSTOPPED */
X   "(TA) called process terminated during transaction execution",
X
X   /* EPROCESSCREAT */
X   "(P) can't create new process",
X
X   /* EPROCESSKILL */
X   "(P) can't kill process",
X
X   /* EEXECPROCESS */
X   "(P) can't transform process using execv",
X
X   /* EHOSTNAME */
X   "(P) can't determine hostname by gethostname()",
X
X   /* EMALLOCBUF */
X   "error allocating heap space for encode/decode buffer",
X
X   /* EENCODE */
X   "(P) error encoding data. Perhaps only '_dcc_buf_size' is too little!",
X
X   /* EENCODESIZE */
X   "(P) resulting size of converted data is too large. Resize '_dcc_buf_size'.",
X
X   /* EDECODE */
X   "(P) error decoding data. Perhaps only '_dcc_buf_size' is too little!",
X
X   /* EXDRSETPOS */
X   "(P) error: xdr_setpos() does not work!"
X};
X
X#endif /* !__run_errlist_h /**/
END_OF_FILE
if test 7317 -ne `wc -c <'include/run_errlist.h'`; then
    echo shar: \"'include/run_errlist.h'\" unpacked with wrong size!
fi
# end of 'include/run_errlist.h'
fi
if test -f 'ipc/p1.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ipc/p1.c'\"
else
echo shar: Extracting \"'ipc/p1.c'\" \(8046 characters\)
sed "s/^X//" >'ipc/p1.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *            A precompiler for distributed programming with C             *
X *                                                                         *
X *                                p 1 . c                                  *
X *                                                                         *
X *                 Version 1.0      CreationDate: 15.07.90                 *
X *                                    LastUpDate: 24.09.90                 *
X *                                                                         *
X *           Process 1 for testing the communication primitives.           *
X *                                                                         *
X *        Copyright (C) 1990 by Franz Distler and Christoph Pleier.        *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include "run_Errno.h"
X#include "ipc.h"
X
X#ifdef SYSTEM_V
X# define u_short	int
X#endif /* SYSTEM_V /**/
X
X#define DELAY		10
X#define MSGNUM		100
X
Xint		 Errno;
XPORTDESCR 	 own_port1,
X		 own_port2,
X		 P2_port;
XCONNECTIONDESCR	 con_port1,
X		 con_port2;
X
X/* global variables needed for the library functions! */
Xchar            *_programname = "p1",
X                *_processname = "P1";
XPORTDESCR 	 _own_port, 
X                 _creator_port,	/* unused, but needed! */
X                 _admin_port;	/* unused, but needed! */
XCONNECTIONDESCR	 _con_port;
X
Xmain()
X{
X	int  i, res;
X	char buffer[100], buffer2[100];
X
X	puts("dcc - distributed c compiler");
X	puts("Copyright (C) 1990 by Franz Distler and Christoph Pleier\n");
X	puts("Process p1 used for testing the communication primitives");
X	puts("Remark: the starting order is: p1, p2, p3");
X	if (_create_port(&own_port1))
X		_RuntimeError("P1: Error creating own port 1");
X#ifndef iPSC
X	_display_port_info("P1: port 1", own_port1);
X#endif /* iPSC /**/
X
X#ifdef iPSC
X	P2_port.node = 6;
X	P2_port.pid  = 101;
X#else
X	puts("P1: Enter port information of port 1 of process P2:");
X	_input_port_info(&P2_port);
X#endif /* iPSC /**/
X
X	puts("\nP1: Testing Rendezvous"); 
X	puts("P1:    Test 1a: accept_connection(...,'P1',0)");
X	if (_accept_connection(&con_port1, own_port1, 0))
X		_RuntimeError("P1: Error accepting connection");
X	puts("P1:    Test 1a: receiving 2 messages");
X	if (_recv_data(con_port1, buffer, 18, 0) < 0)
X		_RuntimeError("P1: Error in recv_data 1");
X        if (strcmp(buffer, "Test 1: Message 1")) {
X		puts("P1: Error: wrong message received!");
X		_close_connection(con_port1);
X		_delete_port(own_port1);
X		exit(-1);
X	}
X	if (_recv_data(con_port1, buffer, 18, 0) < 0)
X		_RuntimeError("P1: Error in recv_data 2");
X        if (strcmp(buffer, "Test 1: Message 2")) {
X		puts("P1: Error: wrong message received!");
X		_close_connection(con_port1);
X		_delete_port(own_port1);
X		exit(-1);
X	}
X	puts("P1:    Test 1a: sending 1 message");
X	strcpy(buffer, "Test 1: Message 3");
X	if (_send_data(con_port1, buffer, 18, 10) < 0)
X		_RuntimeError("P1: Error in send_data 1");
X	puts("P1:    Test 1a: receiving 1 message");
X	if (_recv_data(con_port1, buffer, 18, 10) < 0)
X		_RuntimeError("P1: Error in recv_data 3");
X        if (strcmp(buffer, "Test 1: Message 4")) {
X		puts("P1: Error: wrong message received!");
X		_close_connection(con_port1);
X		_delete_port(own_port1);
X		exit(-1);
X	}
X	if (_close_connection(con_port1))
X		_RuntimeError("P1: Error closing connection");
X	puts("P1:    Test 1b: make_connection(...,'P1','P2',0)");
X	if (_make_connection(&con_port1, own_port1, P2_port, 0))
X		_RuntimeError("P1: Error making connection");
X	puts("P1:    Test 1b: receiving 2 messages");
X	if (_recv_data(con_port1, buffer, 18, 0) < 0)
X		_RuntimeError("P1: Error in recv_data 1");
X        if (strcmp(buffer, "Test 1: Message 1")) {
X		puts("P1: Error: wrong message received!");
X		_close_connection(con_port1);
X		_delete_port(own_port1);
X		exit(-1);
X	}
X	if (_recv_data(con_port1, buffer, 18, 0) < 0)
X		_RuntimeError("P1: Error in recv_data 2");
X        if (strcmp(buffer, "Test 1: Message 2")) {
X		puts("P1: Error: wrong message received!");
X		_close_connection(con_port1);
X		_delete_port(own_port1);
X		exit(-1);
X	}
X	puts("P1:    Test 1b: sending 1 message");
X	strcpy(buffer, "Test 1: Message 3");
X	if (_send_data(con_port1, buffer, 18, 10) < 0)
X		_RuntimeError("P1: Error in send_data 1");
X	puts("P1:    Test 1b: receiving 1 message");
X	if (_recv_data(con_port1, buffer, 18, 10) < 0)
X		_RuntimeError("P1: Error in recv_data 3");
X        if (strcmp(buffer, "Test 1: Message 4")) {
X		puts("P1: Error: wrong message received!");
X		_close_connection(con_port1);
X		_delete_port(own_port1);
X		exit(-1);
X	}
X	if (_close_connection(con_port1))
X		_RuntimeError("P1: Error closing connection");
X	puts("P1: Rendezvous is OK");  
X
X	puts("\nP1: Testing timeouts");
X	puts("P1:    Test 2a: accept_connection(...,'P1',5)");
X	res = _accept_connection(&con_port1, own_port1, 5);
X	if (res < 0 && Errno != ETIMEOUT)
X		_RuntimeError("P1: Error accepting connection");
X
X	if (_create_port(&own_port2))
X		_RuntimeError("P1: Error creating dummy port");
X	puts("P1:    Test 2b: make_connection(...,'P1','dummy',5)");
X	res = _make_connection(&con_port1, own_port1, own_port2, 5);
X	if (res < 0 && Errno != ETIMEOUT)
X		_RuntimeError("P1: Error making connection");
X	_delete_port(own_port2);
X
X	puts("P1:    Test 2c: make_connection(...,'P1','P2',0)");
X	if (_make_connection(&con_port1, own_port1, P2_port, 0))
X		_RuntimeError("P1: Error making connection");
X	puts("P1:    Test 2c: recv_data(..., ..., ..., 5)");
X	res = _recv_data(con_port1, buffer, 10, 5);
X	if (res < 0 && Errno != ETIMEOUT)
X		_RuntimeError("P1: Error reading data");
X	if (res >= 0) {
X		puts("P1: Error in implementation of recv_data: message received!");
X		_close_connection(con_port1);
X	        _delete_port(own_port1);
X		exit(-1);
X	}
X
X#ifdef iPSC
X	printf("P1:    Test 2d: waiting %d seconds\n", DELAY);
X	sleep(DELAY);
X#endif /* iPSC /**/
X
X	puts("P1:    Test 2d: send_data(..., ..., ..., 5)");
X	res = _send_data(con_port2, buffer, 10, 5);
X	if (res < 0 && Errno != ETIMEOUT)
X		_RuntimeError("P1: Error writing data");
X	if (res >= 0) {
X		puts("P1: Error in implementation of send_data: message sent!");
X	        _delete_port(own_port1);
X		exit(-1);
X	}
X	puts("P1: timeouts are OK");  
X
X	puts("\nP1: Testing mutual exclusion of connections");
X	printf("P1:    Test 3: receiving %d messages\n", MSGNUM);
X	for (i=1; i<=100; i++) {
X		if (_recv_data(con_port1, buffer, 22, 0) < 0)
X			_RuntimeError("P1: Error in recv_data");
X		sprintf(buffer2, "Test 3: Message %3d", i);
X        	if (strcmp(buffer, buffer2)) {
X			puts("P1: Error: wrong message received!");
X			_close_connection(con_port1);
X			_delete_port(own_port1);
X			exit(-1);
X		}
X	}
X	puts("P1: mutual exclusion of connections is OK");
X
X
X	puts("\nP1: The test was successful.");
X	puts("P1: The communication primitives seem to be correct implemented");
X	sleep(10);
X	_delete_port(own_port1);
X	puts("\nP1: Done!");
X	exit(0);
X} /* main */
END_OF_FILE
if test 8046 -ne `wc -c <'ipc/p1.c'`; then
    echo shar: \"'ipc/p1.c'\" unpacked with wrong size!
fi
# end of 'ipc/p1.c'
fi
echo shar: End of archive 7 \(of 18\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
