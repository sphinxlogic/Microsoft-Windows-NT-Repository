Newsgroups: comp.sources.unix
From: pleierc@informatik.tu-muenchen.de (Christoph Pleier)
Subject: v27i179: distributed-c-2.1 - Distributed C Development Environment, V2.1, Part05/18
References: <1.756634932.28500@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: pleierc@informatik.tu-muenchen.de (Christoph Pleier)
Posting-Number: Volume 27, Issue 179
Archive-Name: distributed-c-2.1/part05

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 18)."
# Contents:  DEFINES config/program.y config/scanner.l config/util.c
#   dcadmin/configure.y dcadmin/debug.c dcc/Makefile dcc/dcc.l
#   dcc/files.c dcinstall/Transfer.c include/dcadmin.h
#   include/timeout.h ipc/p2.c lib/debug.c
# Wrapped by vixie@gw.home.vix.com on Thu Dec 23 00:11:58 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'DEFINES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'DEFINES'\"
else
echo shar: Extracting \"'DEFINES'\" \(5730 characters\)
sed "s/^X//" >'DEFINES' <<'END_OF_FILE'
XYou must configure the type of the runtime library and programs which will
Xbe generated corresponding to your particular purposes by various preprocessor 
Xdefinitions.
XThere are three different ways for placing the definitions: In the actual used
Xfile 'macros.xxx' (see macros.README for a general description how to do this),
Xwhich will be included by each Makefile, in the Makefile of each subdirectory
Xor in the corresponding source files.
X
X1. General definitions:
X=======================
X
XFirst you have to define the operating system you use. The following systems 
Xare availible:
X    iPSC          - Intel Hypercube
X    AIX           - AIX on IBM Workstations
X    CONVEX        - ConvexOs on Convex Supercomputers
X    HPUX          - HpUx on Hewlett Packard Machines
X    LINUX         - Linux on 386/486 ATs
X    SCO_XENIX     - SCO Xenix Version 2.3 on 386 ATs
X    SCO_UNIX      - SCO Unix Version 3.2 on 386 ATs
X    SPARC         - SunOs 4.1 or greater on Sun Sparc Stations
X    ULTRIX        - Ultrix on Vaxes
X    UNICOS        - Unicos on Cray Supercomputers
X
XSecond you must define the system type to one of the following:
X    BSD           - BSD Unix Version 4.3 or greater
X    SYSTEM_V      - Unix System V
X
XThird you have to define the type of the inter process communication routines 
Xyou want to use. Availible are
X    CUBE          - intel hypercube communication primitives
X    SOCKET        - stream sockets
X    MSGSEM        - message queues and semaphores
X
XFourthly you must define the type of network you want to use for distributing 
Xthe processes:
X    SINGLE        - one machine only, no distribution of processes
X    HOMOGENEOUS   - distribution of processes in a homogenous network
X    HETEROGENEOUS - distribution of processes in a heterogenous network
X
XChoose 'SINGLE' to use the compiler on a single computer, particular on a 
Xmultiprocessor workstation, where all processes are created "local", i.e. no
Xdistribution of processes will be performed. Choose 'HOMOGENEOUS' to use the 
Xcompiler on a network of binary compatible machines, i.e. the processes will
Xbe distributed in a homogenous network. Choose 'HETEROGENEOUS' to use the
Xcompiler on a network of various different Unix machines, i.e. the processes 
Xwill be distributed in a heterogenous network. 
XNote: o HOMOGENEOUS provides faster, HETEROGENEOUS provides more powerful inter 
X        process communications!
X      o If the operating system equals iPSC nothing must be defined here!
X      o Use SOCKET and HOMOGENEOUS on LINUX systems!
X
X2. Definitons for building the runtime library:
X===============================================
X
XDefine one or more of the following during compilation to be able to display 
Xspecial debug information at runtime:
X
X	DEBUG_IPC         - message passing
X	DEBUG_CONVERT     - data conversion
X	DEBUG_CONTROL     - process control
X	DEBUG_CREATION    - process creation
X	DEBUG_KILL        - process destruction
X	DEBUG_TRANSACTION - process transactions
X
XAt runtime the displaying of additional information can be switched on or off 
Xby initializing the corresponding global variables:
X
XExample:
X    To display runtime informations about inter process communication you 
X    have to compile the appropriate files of the runtime library with the 
X    option "-DDEBUG_IPC".
X    To display information during execution of a process you must patch the 
X    generated source file of this process and add the code "_debug_ipc = 1"
X    to switch the output of the additional informations on and "_debug_ipc = 0"
X    to switch it off.
X    To enable and disable the output you can use the macro "PRINT_DEBUG_IPC_ON"
X    and "PRINT_DEBUG_IPC_OFF", too. (These macros are defined in dcc.h)
X
XThe corresponding global variables are:
X	_debug_ipc
X	_debug_convert
X	_debug_control
X	_debug_creation
X	_debug_kill
X	_debug_transaction
X
XOn some systems (e.g. CONVEX) it will be necessary to flush the additional 
Xdisplayed messages. This can easely be done by initializing the global variable
X_debugflush to 1.
X
X
X3. Definitions for building the compiler:
X=========================================
X
XTo be able to check the various actions performed by the compiler you can
Xconfigure the generated compiler to write many additional messages to each 
Xparticular item in a special file 'dcc.debug'.
XYou can configure the items for which additional messages will be written to
Xthe file.
X
XUse a combination of the following to display additional informations about:
X	ATTRDEBUG    - attributes 
X	CODEDEBUG    - code generation
X	DECLDEBUG    - declaration handling (structs, typedefs, enums)
X	DEBUG        - some general actions
X	LEXDEBUG     - scanning
X	STRUCTDEBUG  - structure administration
X	SYMBDEBUG    - symbol table managing
X	XDRDEBUG     - generation of xdr routines
X	YYDEBUG      - parsing 
X
X4. Definitions for building the administration process:
X=======================================================
X
XIf you want that a executing administration process writes informations about
Xits internal states or actions to a file called 'dcadmin.debug' you have to
Xdefine "ADMINDEBUG" during compilation of the administration process source 
Xcode.
X
XWriting such messages to a file will slow done the execution of the 
Xadministration process very much. Enable this for testing purposes only! 
X
XNote: Define USE_MAPFILE during the generation of the administration process.
X      This is the well tested mode for mapping processes to nodes performed
X      by the administration process.
X
X5. Definitions for building the installer program:
X==================================================
X
XDefining "DEBUG" during generation of the installer program will cause the 
Xoutput of additional informations about the various performed actions.
END_OF_FILE
if test 5730 -ne `wc -c <'DEFINES'`; then
    echo shar: \"'DEFINES'\" unpacked with wrong size!
fi
# end of 'DEFINES'
fi
if test -f 'config/program.y' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/program.y'\"
else
echo shar: Extracting \"'config/program.y'\" \(6298 characters\)
sed "s/^X//" >'config/program.y' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                            p r o g r a m . y                            *
X *                                                                         *
X *                            Package : Configuration Files Parsers        *
X *                            Version : 1.0                                *
X *                       CreationDate : 26.02.92                           *
X *                         LastUpDate : 26.02.92                           *
X *                                                                         *
X *  The grammar specifying the syntax of the program configuration file.   *
X *                                                                         *
X *               Copyright (C) 1992-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X%{
X#include <stdio.h>
X#include <stdlib.h>  
X#include <sys/types.h>
X#include "cfgparsers.h"
X%}
X
X/* the type of the value stack */
X%union {
X    int		 y_int;
X    char        *y_str;     /* a string */
X    SYMBTABEL   *y_symb;    /* a pointer to a symbol table element */
X    float        y_float;   /* a number */
X    IDENTLIST   *y_idlist;  /* a pointer to an identifier list */
X    FSSPECINFO  *y_fsspec;
X    COMMPINFO   *y_chost;
X    PATTRINFO   *y_pattr;
X}
X
X/* characters */
X%token ',' ';' ':' '.' '+' '-' '*' '/' '%' '~' '!' '&' '|' '^'
X%token '=' '<' '>' '{' '}' '[' ']' '(' ')' '\"' '\'' '\\' '@'
X
X/* special characters 
X * NOTE: The token definition must be defined exactly like in system.y
X */
X%token ACCESSES ACCESSIBLE COMMUNICATES COMPILATION COMPILER COMPUTER COSTS 
X%token CREATION DEVICES DISKS DISTRIBUTED EXECUTABLES FILESYSTEMS FIXED FOR 
X%token GENERAL HOST HOSTS HOSTNAMES INDEX INFORMATIONS INTENSITY LISTS LOCATION 
X%token MEMORY MULTIPROCESSOR OPERATING PARALLELIZING PERFORMANCE PERIPHERAL 
X%token PHYSICAL PREFERRED PRIORITY PROCESS PROCESSORS REQUIRES RESTRICTED 
X%token SHARED SIZE SPECIFICATION SPEED STORAGE SYSTEM TARGET TYPE TYPES 
X%token VARIANTS VECTOR VIRTUAL WISHES WITH
X%token VECTORIZATION PARALLELIZATION
X%token MS NS KB MB GB
X%token CC CFLAGS LD LDFLAGS LIBS
X%token IDENT STRING NUMBER
X
X%type <y_str>    STRING
X%type <y_symb>   IDENT 
X%type <y_float>  NUMBER size_specification
X%type <y_int>    mode_spec
X%type <y_idlist> ident_list
X%type <y_fsspec> filesystems_list filesystem_specification
X%type <y_chost>  comm_processes_list comm_process_specification
X%type <y_pattr>  process_attributes_list process_attribute
X
X%start program_configuration
X
X%%
X
Xprogram_configuration: 
X	  description_list
X	;
X
Xdescription_list:
X	  process_description
X	| description_list process_description
X	;
X
Xprocess_description:
X	  PROCESS IDENT '=' '{' process_attributes_list '}'
X		{enter_process_description($2, $5);}
X	;
X
Xprocess_attributes_list:
X	  process_attribute
X	| process_attributes_list process_attribute
X		{$$ = chain_pattr_infos($1, $2);}
X	;
X
Xprocess_attribute:
X	  PREFERRED HOSTS ':' ident_list
X		{$$ = generate_process_attr_info(PA_PREFERRED, $4, 0, 0, NULL, NULL);}
X	| RESTRICTED HOSTS ':' ident_list
X		{$$ = generate_process_attr_info(PA_RESTRICTED, $4, 0, 0, NULL, NULL);}
X	| INTENSITY INDEX ':' NUMBER
X		{$$ = generate_process_attr_info(PA_INTENSITY_INDEX, NULL, $4, 0, NULL, NULL);}
X	| mode_spec PHYSICAL MEMORY ':' size_specification 
X		{$$ = generate_process_attr_info(PA_PHYS_MEM, NULL, $5, $1, NULL, NULL);}
X	| mode_spec VIRTUAL MEMORY ':' size_specification
X		{$$ = generate_process_attr_info(PA_VIRT_MEM, NULL, $5, $1, NULL, NULL);}
X	| ACCESSES PERIPHERAL DEVICES '{' ident_list '}'
X		{$$ = generate_process_attr_info(PA_PERI_DEVICES, $5, 0, 0, NULL, NULL);}
X	| ACCESSES FILESYSTEMS '{' filesystems_list '}'
X		{$$ = generate_process_attr_info(PA_FILESYSTEMS, NULL, 0, 0, $4, NULL);}
X	| COMMUNICATES WITH '{' comm_processes_list '}'
X		{$$ = generate_process_attr_info(PA_COMM_PROCESSES, NULL, 0, 0, NULL, $4);}
X	| mode_spec VECTORIZATION
X		{$$ = generate_process_attr_info(PA_VECTORIZATION, NULL, 0, $1, NULL, NULL);}
X	| mode_spec PARALLELIZATION
X		{$$ = generate_process_attr_info(PA_PARALLELIZATION, NULL, 0, $1, NULL, NULL);}
X	;
X
Xfilesystems_list:
X	  filesystem_specification
X	| filesystems_list ',' filesystem_specification
X		{$$ = chain_fsspec_infos($1, $3);}
X	;
X
Xfilesystem_specification:
X	  /* name ( frequency, quantity ) */
X	  IDENT '(' NUMBER ',' NUMBER ')'
X		{$$ = generate_fsspec_info($1, $3, $5);}
X	;
X
Xcomm_processes_list:
X	  comm_process_specification
X	| comm_processes_list ',' comm_process_specification
X		{$$ = chain_commp_infos($1, $3);}
X	;
X
Xcomm_process_specification:
X	  /* name ( frequency, quantity ) */
X	  IDENT '(' NUMBER ',' NUMBER ')'
X		{$$ = generate_commp_info($1, $3, $5);}
X	;
X
Xmode_spec:
X	  REQUIRES
X		{$$ = MODE_REQUIRES;}
X	| WISHES
X		{$$ = MODE_WISHES;}
X	;
X
Xident_list:
X	  IDENT
X                {$$ = store_ident_in_list($1);}
X	| ident_list ',' IDENT
X                {$$ = chain_ident_lists($1, store_ident_in_list($3));}
X	;
X
Xsize_specification:
X	  NUMBER MB
X	| NUMBER GB
X                {$$ = $1 * 1024;}
X	;
X
X%%
END_OF_FILE
if test 6298 -ne `wc -c <'config/program.y'`; then
    echo shar: \"'config/program.y'\" unpacked with wrong size!
fi
# end of 'config/program.y'
fi
if test -f 'config/scanner.l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/scanner.l'\"
else
echo shar: Extracting \"'config/scanner.l'\" \(6593 characters\)
sed "s/^X//" >'config/scanner.l' <<'END_OF_FILE'
X%{
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                            s c a n n e r . l                            *
X *                                                                         *
X *                            Package : Configuration Files Parsers        *
X *                            Version : 2.0                                *
X *                       CreationDate : 20.11.91                           *
X *                         LastUpDate : 02.12.93                           *
X *                                                                         *
X * The input file to build the scanner to interpret the program and the    *
X * system configuration file.                                              *
X *                                                                         *
X *               Copyright (C) 1991-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#ifdef DEBUGLEX
X
X# include <assert.h>
X
Xmain()
X{
X	char *p;
X
X	assert(sizeof(int) >= sizeof(char *));
X	while(p = (char *) yylex())
X		printf("%-10.10s is \"%s\"\n", p, yytext);
X}
X
Xint yynerrs = 0;
X	
X# define token(x)	(int) "x"
X
X#else 
X
X# define token(x)	x
X
X#endif /* DEBUGLEX /**/
X
X#include <stdio.h>
X#include <stdlib.h>  /* prototype of atof() !!! */
X#include "cfgparsers.h"
X#include "y.tab.h"
X
X#define END(v)		(v-1 + sizeof(v)/sizeof(v[0]))
X
Xstatic int screen();
X
X%}
X
Xletter		[a-zA-Z_]
Xdigit		[0-9]
Xeeval		[Ee][+-]?{digit}+
Xpval		[\.]{digit}+
Xfloat		{digit}+({eeval}|{pval})
Xnumber		{digit}+|{float}
Xstring		["][^"]*["]
Xinternetaddr	{digit}+[.]{digit}+[.]{digit}+[.]{digit}+
Xident		{letter}({letter}|{digit}|[.&!\$-])*
Xwhitespace	[ \t\n]
Xcomment		[#][^\n]*
Xother		[^\n]
X
X%%
X
X{comment}	;
X{whitespace}	;
X{string}	{ yylval.y_str = strsave(yytext);
X		  /* eliminate '"'s at begin and end of string */
X		  ++yylval.y_str;
X		  *(yylval.y_str + strlen(yylval.y_str) - 1) = 0;
X		  return(token(STRING)); 
X		}
X{number}	{ yylval.y_float = (float) atof(yytext);
X		  return(token(NUMBER)); 
X		}
X{internetaddr}  { return(screen()); }
X{ident}		{ return(screen()); }
X{other}		{ return(token(yytext[0])); }
X
X%%
X
X/*
X * Reserved words
X */
X
Xstatic struct rwtable {
X	char *rw_name;
X	int rw_yylex;
X} rwtable[] = {
X	/* NOTE: table must be sorted lexicographically! */
X	"CC",			token(CC),
X	"CFLAGS",		token(CFLAGS),
X	"GB",			token(GB),
X	"KB",			token(KB),
X	"LD",			token(LD),
X	"LDFLAGS",		token(LDFLAGS),
X	"LIBS",			token(LIBS),
X	"MB",			token(MB),
X	"accesses",		token(ACCESSES),
X	"accessible",		token(ACCESSIBLE),
X	"communicates",         token(COMMUNICATES),
X	"compilation",		token(COMPILATION),
X	"compiler",		token(COMPILER),
X	"computer",		token(COMPUTER),
X	"costs",		token(COSTS),
X	"creation",		token(CREATION),
X	"devices",		token(DEVICES),
X	"disks",		token(DISKS),
X	"distributed",		token(DISTRIBUTED),
X	"executables",		token(EXECUTABLES),
X	"filesystems",		token(FILESYSTEMS),
X	"fixed",		token(FIXED),
X	"for",			token(FOR),
X	"general",		token(GENERAL),
X	"host",			token(HOST),
X	"hostnames",		token(HOSTNAMES),
X	"hosts",		token(HOSTS),
X	"index",		token(INDEX),
X	"informations",		token(INFORMATIONS),
X	"intensity",            token(INTENSITY),
X	"lists",		token(LISTS),
X	"location",		token(LOCATION),
X	"memory",		token(MEMORY),
X	"ms",			token(MS),
X	"multiprocessor",	token(MULTIPROCESSOR),
X	"ns",			token(NS),
X	"operating",		token(OPERATING),
X	"parallelization",	token(PARALLELIZATION),
X	"parallelizing",	token(PARALLELIZING),
X	"performance",		token(PERFORMANCE),
X	"peripheral",		token(PERIPHERAL),
X	"physical",		token(PHYSICAL),
X	"preferred",            token(PREFERRED),
X	"priority",		token(PRIORITY),
X	"process",		token(PROCESS),
X	"processors",		token(PROCESSORS),
X	"requires",             token(REQUIRES),
X	"restricted",           token(RESTRICTED),
X	"shared",		token(SHARED),
X	"size",			token(SIZE),
X	"specification",	token(SPECIFICATION),
X	"speed",		token(SPEED),
X	"storage",		token(STORAGE),
X	"system",		token(SYSTEM),
X	"target",		token(TARGET),
X	"type",			token(TYPE),
X	"types",		token(TYPES),
X	"variants",		token(VARIANTS),
X	"vector",		token(VECTOR),
X	"vectorization",	token(VECTORIZATION),
X	"virtual",		token(VIRTUAL),
X	"wishes",               token(WISHES),
X	"with",                 token(WITH)
X};
X
X/******************************************************************************
X * screen()                                                                   *
X *                                                                            *
X * Checks if the string stored in 'yytext' is a reserved word or an ident.    *
X *                                                                            *
X * Return values: token code for a reserved word or an ident                  *
X ******************************************************************************/
Xstatic int screen()
X{
X	struct rwtable *low  = (struct rwtable *) rwtable, 
X	               *high = (struct rwtable *) END(rwtable), 
X	               *mid;
X	int c;
X	SYMBTABEL *symbol;
X
X	while (low <= high) {
X		mid = low + (high - low) / 2;
X		if ((c = strcmp(mid->rw_name, yytext)) == 0)
X			return(mid->rw_yylex);
X		else 	
X			if (c < 0) 
X				low = mid + 1;
X			else 
X				high = mid -1;
X	}
X
X	symbol = lookup_symbtabel(yytext);
X	if (symbol == NULL)  
X	    symbol = enter_symbtabel(yytext);
X	yylval.y_symb = symbol;
X
X	return(token(IDENT));
X} /* screen */
END_OF_FILE
if test 6593 -ne `wc -c <'config/scanner.l'`; then
    echo shar: \"'config/scanner.l'\" unpacked with wrong size!
fi
# end of 'config/scanner.l'
fi
if test -f 'config/util.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/util.c'\"
else
echo shar: Extracting \"'config/util.c'\" \(6243 characters\)
sed "s/^X//" >'config/util.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                               u t i l . c                               *
X *                                                                         *
X *                            Package : Configuration Files Parsers        *
X *                            Version : 1.0                                *
X *                       CreationDate : 20.11.91                           *
X *                         LastUpDate : 26.02.92                           *
X *                                                                         *
X *                          All utility routines.                          *
X *                                                                         *
X *               Copyright (C) 1991-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#ifdef CONVEX 
X# include <stdlib.h>
X#else
X# include <malloc.h>
X#endif
X#if defined(SCO_UNIX) || defined(SCO_XENIX)
X# include <sys/utsname.h>
X#endif
X#include "cfgparsers.h"
X
X/******************************************************************************
X * Malloc()                                                                   *
X *                                                                            *
X * Allocates memory of size 'size' and checks for error.                      *
X *                                                                            *
X * Return values: pointer to the allocated memory upon success                *
X ******************************************************************************/
Xchar *
XMalloc(size)
Xunsigned size;
X{
X    char *ptr;
X
X    ptr = (char *) malloc(size+10);
X    if (ptr == NULL) {
X	fputs("Panic: Out of heap space!\n", stderr);
X	exit(ERROR);
X    }	
X    return(ptr);
X} /* Malloc */
X
X/******************************************************************************
X * Free()                                                                     *
X *                                                                            *
X * Frees the allocated memory pointed to by specified by the pointer 'ptr'.   *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
XFree(ptr)
Xchar *ptr;
X{
X    if (ptr)
X        free(ptr);
X} /* Free */
X
X/******************************************************************************
X * strsave()                                                                  *
X *                                                                            *
X * Copies 's' to a new allocated main memory block.                           *
X *                                                                            *
X * Return values: pointer to saved string upon success / NULL upon error      *
X ******************************************************************************/
Xchar *
Xstrsave(s)
Xregister char *s;
X{
X    register char *cp;
X
X    cp = (char *) Malloc(strlen(s)+1);
X    strcpy(cp, s);
X    return(cp);
X} /* strsave */
X
X/******************************************************************************
X * gethomedir()                                                               *
X *                                                                            *
X * Determines the path to the home direcrory of the user 'user' by consulting *
X * the passwd file.                                                           *
X *                                                                            *
X * Return values: pointer to path upon success / NULL upon error              *
X ******************************************************************************/
Xchar *
Xgethomedir(user)
Xchar *user;
X{
X    static char *homedir;
X    extern char *getenv();
X
X    if (!(homedir = getenv("HOME"))) {
X	fputs("Error: can't determine home directory\n", stderr);
X        exit(ERROR);
X    }
X    return(homedir);
X} /* gethomedir */
X
X#if defined(SCO_UNIX) || defined(SCO_XENIX)
X
X/******************************************************************************
X * gethostname()                                                              *
X *                                                                            *
X * Determines the name of the local host.                                     *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
Xgethostname(hostname, len)
Xchar hostname[];
Xint len;
X{
X    static struct utsname name;
X
X    if (uname(&name) == -1) {
X	perror("Error in uname()");
X	return(ERROR);
X    } 
X    strcpy(hostname, name.nodename);
X    return(OK);
X} /* gethostname */
X
X#endif /* SCO_UNIX or SCO_XENIX /**/
END_OF_FILE
if test 6243 -ne `wc -c <'config/util.c'`; then
    echo shar: \"'config/util.c'\" unpacked with wrong size!
fi
# end of 'config/util.c'
fi
if test -f 'dcadmin/configure.y' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcadmin/configure.y'\"
else
echo shar: Extracting \"'dcadmin/configure.y'\" \(6301 characters\)
sed "s/^X//" >'dcadmin/configure.y' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                          c o n f i g u r e . y                          *
X *                                                                         *
X *                            Package : Administration Process             *
X *                            Version : 1.0                                *
X *                       CreationDate : 23.10.90                           *
X *                         LastUpDate : 06.12.93                           *
X *                                                                         *
X *      The grammar specifying the syntax of the configuration file.       *
X *                                                                         *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X%{
X#include <stdio.h>
X#include <sys/types.h>
X#ifdef HETEROGENEOUS
X#include <rpc/rpc.h>
X#endif
X#include "ipc.h"
X#include "dcc.h"
X#include "dcadmin.h"
X
Xextern struct pcreat_list *pcreat_first, *pcreat_last;
X%}
X
X/* the type of the value stack */
X%union {
X	int   y_int;	/* an integer value */
X	char *y_str;	/* a string */
X}
X
X/* characters */
X%token ',' ';' ':' '.' '+' '-' '*' '/' '%' '~' '!' '&' '|' '^'
X%token '=' '<' '>' '{' '}' '[' ']' '(' ')' '\"' '\'' '\\' '@'
X
X/* special characters */
X%token NUM AT NAME ADDRESS
X
X/* nonterminal types */
X%type <y_int> NUM 
X%type <y_int> AT
X%type <y_str> NAME
X%type <y_str> ADDRESS
X
X%start configuration
X
X%%
X
Xconfiguration: 
X	  entry_list
X	;
X
Xentry_list:
X	  entry
X	| entry_list entry
X	;
X
Xentry:
X	  creation_entry
X	;
X
Xcreation_entry:
X	  NAME
X		{store_creation_entry(-1, NULL, NULL, $1);}
X	| NUM AT NAME
X		{store_creation_entry($1, NULL, NULL, $3);}
X	| NAME AT NAME
X		{store_creation_entry(-1, $1, NULL, $3);}
X	| NUM NAME AT NAME
X		 {store_creation_entry($1, $2, NULL, $4);}
X	| NAME '@' NAME
X		{store_creation_entry(-1, NULL, $1, $3);}
X	| NUM AT NAME '@' NAME
X		{store_creation_entry($1, NULL, $3, $5);}
X	| NAME AT NAME '@' NAME
X		{store_creation_entry(-1, $1, $3, $5);}
X	| NUM NAME AT NAME '@' NAME
X		{store_creation_entry($1, $2, $4, $6);}
X	;
X
X%%
X
X#include "lex.yy.c"
X
X
X/******************************************************************************
X * store_creation_entry()                                                     *
X *                                                                            *
X * Stores a new parsed creation information in the creation list.             *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint store_creation_entry(num, processname, username, hostname)
Xint   num;
Xchar *processname,
X     *username,
X     *hostname;
X{
X#ifdef USE_MAPFILE
X	struct pcreat_list *ptr;
X
X	ptr = (struct pcreat_list *) malloc(sizeof(struct pcreat_list));
X	if (ptr == NULL) {
X	    fputs("Panic: Out of heap space!\n", stderr);
X	    exit(-1);
X	}
X	ptr->max_num     = num;
X	ptr->created_num = 0;
X	ptr->processname = processname;
X	ptr->username    = username;
X	ptr->hostname    = hostname;
X	ptr->next        = NULL;
X	if (pcreat_first == NULL)
X		pcreat_first = pcreat_last = ptr;
X	else {
X		pcreat_last->next = ptr;
X		pcreat_last = ptr;
X	}
X#endif /* USE_MAPFILE */
X} /* store_creation_entry */
X
X
X/******************************************************************************
X * yyerror()                                                                  *
X *                                                                            *
X * Writes a parser error message to stdout.                                   *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint yyerror(s)
Xchar *s;
X{
X	extern int yylineno;
X
X	printf("syntax error in configuration file: line %d at %s\n", 
X	    yylineno, yytext);
X	puts("The correct syntax is:");
X#ifdef iPSC
X	puts("     [num] [processname] [at] node-num");
X	puts("     e.g. \"1 prog_p01 at node-1\"");
X#else
X	puts("     [num] [processname] [at] [username@]hostname");
X	puts("     e.g. \"5 prog_p01 at sun5\"");
X#endif /* iPSC /**/
X} /* yyerror */
X
X/******************************************************************************
X * yywrap()                                                                   *
X *                                                                            *
X * This is a dummy routine needed for YACC and is called at end of parsing.   *
X *                                                                            *
X * Return values: always 1                                                    *
X ******************************************************************************/
X#ifndef LINUX	/* LINUX uses: "#define yywrap 1" */
Xint yywrap()
X{
X	return(1);
X} /* yywrap */
X#endif
END_OF_FILE
if test 6301 -ne `wc -c <'dcadmin/configure.y'`; then
    echo shar: \"'dcadmin/configure.y'\" unpacked with wrong size!
fi
# end of 'dcadmin/configure.y'
fi
if test -f 'dcadmin/debug.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcadmin/debug.c'\"
else
echo shar: Extracting \"'dcadmin/debug.c'\" \(5807 characters\)
sed "s/^X//" >'dcadmin/debug.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                              d e b u g . c                              *
X *                                                                         *
X *                            Package : Administration Process             *
X *                            Version : 1.0                                *
X *                       CreationDate : 16.09.90                           *
X *                         LastUpDate : 02.03.92                           *
X *                                                                         *
X *     All routines needed for displaying special debug informations.      *
X *                                                                         *
X *                  Portions Copyright 1990 Franz Distler                  *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#ifdef HETEROGENEOUS
X# include <rpc/rpc.h>
X#endif
X#include "ipc.h"
X#include "dcc.h"
X#include "dcadmin.h"
X
X#ifdef ADMINDEBUG
X
X/******************************************************************************
X * DisplayProcessList()                                                       *
X *                                                                            *
X * Displays the 'process data list'.                                          *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
XDisplayProcessList()
X{
X    register int i;
X    register char *tmpptr;
X    register struct pdat_list *aptr;
X
X    fprintf(dfile, "[dbg] %s ---------- processlist:\n", _processprefix);
X    for(aptr = pdat_first, i = 1; aptr; aptr = aptr->next, i++) {
X	fprintf(dfile, "[dbg] %s   entry %d:\n", _processprefix, i);
X	fprintf(dfile, "[dbg] %s      NAME: %s\n", _processprefix, 
X	    aptr->p_descr.processname);
X#ifdef iPSC
X	fprintf(dfile, "[dbg] %s      NODE: %ld\n", _processprefix, 
X	    aptr->p_descr.port.node);
X#else
X# ifndef SINGLE
X	fprintf(dfile, "[dbg] %s      HOST: %s\n", _processprefix, 
X	    aptr->p_descr.port.hostname);
X# endif /* !SINGLE /**/
X#endif /* iPSC /**/
X	fprintf(dfile, "[dbg] %s       PID: %d\n", _processprefix, 
X	    aptr->p_descr.pid);
X	switch(aptr->status) {
X	case RUNNING:
X	    tmpptr = "running";
X	    break;
X	case ACCORTER:
X	    tmpptr = "acc. or ter.";
X	    break;
X	case TERMINATED:
X	    tmpptr = "terminated";
X	    break;
X	default:
X	    tmpptr = "unknown";
X	} /* switch */
X	fprintf(dfile, "[dbg] %s    STATUS: %s\n", _processprefix, tmpptr);
X	fflush(dfile);
X    } /* for */
X    fprintf(dfile, "[dbg] %s ---------- end of processlist\n", _processprefix);
X    if (_debugflush)
X	fflush(dfile);
X} /* DisplayProcessList */
X
X# ifdef USE_MAPFILE
X
X/******************************************************************************
X * DisplayCreationList()                                                      *
X *                                                                            *
X *                                                                            *
X * Displays the 'process creation list'.                                      *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
XDisplayCreationList()
X{
X    register int i;
X    register struct pcreat_list *ptr;
X
X    fprintf(dfile, "[dbg] %s ---------- process creation list:\n", 
X	_processprefix);
X    for(ptr = pcreat_first, i = 1; ptr; ptr = ptr->next, i++) {
X	fprintf(dfile, "[dbg] %s   entry %d:\n", _processprefix, i);
X	fprintf(dfile, "[dbg] %s           max_num: %d\n", 
X	    _processprefix, ptr->max_num);
X	fprintf(dfile, "[dbg] %s       created_num: %d\n", 
X	    _processprefix, ptr->created_num);
X	fprintf(dfile, "[dbg] %s       processname: %s\n", 
X	    _processprefix, ptr->processname);
X	fprintf(dfile, "[dbg] %s          username: %s\n", 
X	    _processprefix, ptr->username);
X	fprintf(dfile, "[dbg] %s          hostname: %s\n", 
X	    _processprefix, ptr->hostname);
X    }
X    fprintf(dfile, "[dbg] %s ---------- end of process creation list\n", 
X	_processprefix);
X    if (_debugflush)
X	fflush(dfile);
X} /* DisplayCreationList */
X
X# endif /* USE_MAPFILE /**/
X
X#endif /* ADMINDEBUG /**/
END_OF_FILE
if test 5807 -ne `wc -c <'dcadmin/debug.c'`; then
    echo shar: \"'dcadmin/debug.c'\" unpacked with wrong size!
fi
# end of 'dcadmin/debug.c'
fi
if test -f 'dcc/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcc/Makefile'\"
else
echo shar: Extracting \"'dcc/Makefile'\" \(6387 characters\)
sed "s/^X//" >'dcc/Makefile' <<'END_OF_FILE'
X#***************************************************************************
X#*                                                                         *
X#* @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X#* @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X#* @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X#* @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X#* @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X#*                                                                         *
X#*              A compiler for distributed programming with C              *
X#*                                                                         *
X#*                             M a k e f i l e                             *
X#*                                                                         *
X#*                            Package : Compiler                           *
X#*                            Version : 1.0                                *
X#*                       CreationDate : 05.07.90                           *
X#*                         LastUpDate : 19.12.93                           *
X#*                                                                         *
X#*                  The makefile to generate the compiler.                 *
X#*                                                                         *
X#*     Copyright (C) 1990-1994 by Franz Distler and Christoph Pleier.      *
X#*                          All rights reserved!                           *
X#***************************************************************************/
X
X#.SILENT
X
X# Some utility programs
X   SHELL = /bin/sh
X    MAKE = make
X
X# Definitions using yacc
X    YACC = yacc
X  YFLAGS = -d $(YFLAGS_DCC) 
X YCFLAGS = -D__RUNTIME_YYMAXDEPTH
X
X# Definitions using bison
X#   YACC = bison -y
X# YFLAGS = -d $(YFLAGS_DCC) 
X#YCFLAGS = -DYYERROR_VERBOSE
X
X     LEX = lex
X  LFLAGS = 
X    LINT = /usr/bin/lint
X
X# Special compilation definitions. Define one or more using -D<NAME>.
X# Use a combination of the following to display additional informations about:
X#    ATTRDEBUG	 - attributes
X#    CODEDEBUG	 - code generation
X#    DECLDEBUG   - declaration handling (structs, enums, typedefs)
X#    DEBUG       - some general actions
X#    LEXDEBUG    - actions of lex
X#    STRUCTDEBUG - structure administration
X#    SYMBDEBUG   - functions for the symbol table
X#    XDRDEBUG    - generation of xdr routines
X#    YYDEBUG     - parsing
XDEBUG =
X
X# The path of the include directories
XINCLUDEDIR = ../include
X
X# Include target system specific macros
Xinclude ../macros
X
X# Set appropriate macros
X     CC = $(CC_DCC)
X CFLAGS = $(CFLAGS_DCC) -DDCC $(DEBUG) -I$(INCLUDEDIR) $(YCFLAGS) 
X     LD = $(LD_DCC)
XLDFLAGS = $(LDFLAGS_DCC)
X   LIBS = $(LIBS_DCC) 
X
X# The name of the compiler
XCOMPNAME = dcc
X
X# All source files needed to build the compiler
XSRCS = 	attr_debug.c attr_decl.c attr_general.c code_convert.c \
X	code_create.c code_decl.c code_destroy.c code_others.c \
X	code_process.c code_select.c code_trans.c help.c includefile.c \
X	main.c makefile.c Malloc.c parseoptions.c signal.c files.c \
X	symb_debug.c symb_general.c symb_others.c symb_process.c \
X	String.c usage.c util.c version.c xdrfile.c yyfuncts.c y.tab.c
X
X# All object files needed to build 'the compiler
XOBJS = $(SRCS:.c=.o)
X
X.c.o:
X	@echo "***** Compiling $<"
X	$(CC) $(CFLAGS) -c $<
X
Xall: $(INCLUDEDIR)/ipc.h
X	@echo ""
X	@echo "BUILDING THE COMPILER..."
X	$(MAKE) $(COMPNAME) 
X	@echo DONE!
X
X$(COMPNAME): $(OBJS)
X	@echo "***** Loading"
X	$(LD) -o $(COMPNAME) $(LDFLAGS) $(OBJS) $(LIBS)
X
Xlex.yy.c: dcc.l
X	@echo "***** Generating the scanner"
X	$(LEX) $(LFLAGS) dcc.l
X
Xy.tab.c y.tab.h: dcc.y
X	@echo "***** Generating the parser"
X	$(YACC) $(YFLAGS) dcc.y
X
Xy.tab.o: $(INCLUDEDIR)/config.h $(INCLUDEDIR)/reswords.h lex.yy.c 
X	@echo "***** Compiling y.tab.c (including lex.yy.c)"
X	$(CC) $(CFLAGS) -c y.tab.c
X
Xmain.o: ../include/globals.h ../include/version.h main.c
X	@echo "***** Compiling main.c"
X	$(CC) $(CFLAGS) -DCPP='"$(CPP) $(CPPFLAGS)"' -c main.c
X
Xlextest: lex.dummy.o lex.yy.c
X	@echo "***** Building the test scanner lextest"
X	$(CC) -o lextest $(CFLAGS) -DDEBUGLEX lex.dummy.o lex.yy.c
X
X$(INCLUDEDIR)/ipc.h:
X	( cd ../lib ; $(MAKE) )
X
Xnew: 
X	-\rm -f dcc *.o
X	touch dcc.l dcc.y $(INCLUDEDIR)/config.h
X	$(MAKE) all
X
Xcheck:
X	@echo "checking $(SRCS)"
X	$(LINT) $(CFLAGS) $(SRCS) | more
X
Xdepend: $(INCLUDEDIR)/ipc.h lex.yy.c y.tab.c
X	@echo "creating dependencies in Makefile"
X	makedepend $(CFLAGS) $(SRCS)
X
Xclean:
X	@echo "Cleaning the directory..."
X	-\rm -f *.o y.* lex.yy.c lextest $(COMPNAME)
X	@echo done!
X
X# General other dependencies
X$(OBJS): $(INCLUDEDIR)/config.h $(INCLUDEDIR)/functions.h
X
X# Other dependencies generated by make depend
Xattr_decl.o: ../include/extern.h
Xattr_general.o: ../include/extern.h 
Xcode_convert.o: ../include/extern.h
Xcode_create.o: ../include/extern.h ../include/com_Errno.h ../include/timeout.h
Xcode_decl.o: ../include/extern.h
Xcode_destroy.o: ../include/extern.h ../include/com_Errno.h ../include/timeout.h
Xcode_others.o: ../include/extern.h ../include/com_Errno.h 
Xcode_others.o: ../include/timeout.h
Xcode_process.o: ../include/extern.h ../include/com_Errno.h ../include/timeout.h
Xcode_select.o: ../include/extern.h ../include/com_Errno.h ../include/timeout.h 
Xcode_select.o: ../include/ipc.h ../include/dcc.h
Xcode_trans.o: ../include/extern.h ../include/com_Errno.h ../include/timeout.h
Xhelp.o: ../include/extern.h 
Xincludefile.o: ../include/extern.h ../include/ipc.h ../include/dcc.h
Xmakefile.o: ../include/extern.h ../include/ipc.h
Xmakefile.o: ../include/dcc.h 
Xparseoptions.o: ../include/extern.h
Xsignal.o: ../include/extern.h ../include/com_Errno.h
Xfiles.o: ../include/extern.h ../include/ipc.h
Xfiles.o: ../include/dcc.h
Xsymb_debug.o: ../include/extern.h y.tab.h ../include/com_Errno.h
Xsymb_general.o: ../include/extern.h y.tab.h ../include/com_Errno.h
Xsymb_others.o: ../include/extern.h y.tab.h ../include/com_Errno.h
Xsymb_process.o: ../include/extern.h y.tab.h ../include/com_Errno.h
XString.o: ../include/extern.h
Xusage.o: ../include/extern.h
Xutil.o: ../include/extern.h ../include/com_errlist.h
Xversion.o: ../include/extern.h $(SRCS)
Xyyfuncts.o: ../include/extern.h ../include/com_Errno.h
Xy.tab.o: ../include/extern.h ../include/com_Errno.h lex.yy.c
Xy.tab.o: ../include/reswords.h
END_OF_FILE
if test 6387 -ne `wc -c <'dcc/Makefile'`; then
    echo shar: \"'dcc/Makefile'\" unpacked with wrong size!
fi
# end of 'dcc/Makefile'
fi
if test -f 'dcc/dcc.l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcc/dcc.l'\"
else
echo shar: Extracting \"'dcc/dcc.l'\" \(5800 characters\)
sed "s/^X//" >'dcc/dcc.l' <<'END_OF_FILE'
X%{
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                                d c c . l                                *
X *                                                                         *
X *                            Package : Compiler                           *
X *                            Version : 1.0                                *
X *                       CreationDate : 05.07.90                           *
X *                         LastUpDate : 06.12.93                           *
X *                                                                         *
X *              The input file to build the scanner with lex.              *
X *                                                                         *
X *     Copyright (C) 1990-1994 by Franz Distler and Christoph Pleier.      *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#ifdef DEBUGLEX
X
X# include <assert.h>
X
X#ifdef LINUX
Xchar *yytext;
X#endif 
X
Xmain()
X{
X	char *p;
X
X	assert(sizeof(int) >= sizeof(char *));
X	while(p = (char *) yylex())
X		printf("%-10.10s is \"%s\"\n", p, yytext);
X}
X
Xint yynerrs = 0;
X	
X# define token(x)	(int) "x"
X
X#else 
X
X# include "functions.h"
X# define token(x)	x
X
X#endif /* DEBUGLEX /**/
X
X#ifdef LINUX
X# define INC_YYLINENO	++yylineno
X#else
X# define INC_YYLINENO	/* nothing */
X#endif
X
X#define END(v)		(v-1 + sizeof(v)/sizeof(v[0]))
X
X#ifdef DEBUGLEX
Xstatic char * screen();
X#else
Xstatic int screen();
X#endif
X
X%}
X
Xsign		[+-]
Xletter		[a-zA-Z_]
Xdigit		[0-9]
Xhexdigit	[0-9a-fA-F]
Xnumber		{digit}+
Xdigitseq	{digit}+
Xquoted		[nbtvrfa\\\?\"\']
Xeeval          	[eE]{sign}?{digit}+
Xpval           	[\.]{digit}+
Xfloat          	({digitseq}?{pval}{eeval})|({digit}+{eeval})|({digitseq}?{pval})
Xident		({letter}|{digit}|[_$])*
Xchar	  	[']([^']|{letter}|\\(x({hexdigit}{1,2})|({digit}{1,3})|{quoted}))[']
Xstring		["]([^"\n]|\\["\n])*["]
Xwhitespace	[ \t]
Xnewline 	[\n]
Xother		[^\n]
X
Xcpp_file_cray	"# line"{whitespace}+{digit}+{whitespace}+[a-zA-Z_!@#$%&/.]+{other}*\n
Xcpp_file_others	[#]{whitespace}*{digit}+{other}*{string}{other}*{digit}*\n
Xcpp_file	{cpp_file_cray}|{cpp_file_others}
Xcpp_pragma	[#]pragma{other}*
Xcpp_ident	[#]ident{other}*
Xcpp_others	[#]{whitespace}*{digit}+({whitespace}+.*)?\n
X
X%%
X
X{cpp_file}	{yymark();}
X{cpp_others}	;
X{cpp_ident}	;
X{cpp_pragma}	;
X
X"=="		return(token(EEQUAL)); 
X"!="		return(token(NOTEQUAL)); 
X"*="		return(token(MUL_ASSIGN)); 
X"/="		return(token(DIV_ASSIGN)); 
X"+="		return(token(PLUS_ASSIGN));
X"-="		return(token(MINUS_ASSIGN));
X"%="		return(token(MOD_ASSIGN));
X"&="		return(token(AMPERS_ASSIGN));
X"^="		return(token(HAT_ASSIGN));
X"|="		return(token(PIPE_ASSIGN));
X"<<="		return(token(LSHIFT_ASSIGN));
X">>="		return(token(RSHIFT_ASSIGN));
X"<="		return(token(LE));
X">="		return(token(GE));
X"++"		return(token(PLUSPLUS));
X"--"		return(token(MINUSMINUS));
X">>"		return(token(RSHIFT));
X"<<"		return(token(LSHIFT));
X"||"		return(token(LOGOR));
X"&&"		return(token(LOGAND));
X"->"		return(token(ARROW));
X"..."		return(token(TREEPOINT));
X{whitespace}	;
X{newline}	{INC_YYLINENO;}
X{number}	return(token(INT_CONST));
X{char}		return(token(CHR_CONST));
X{string}	return(token(STR_CONST));
X{float}		return(token(FLOAT_CONST));
X{ident}		return(screen());
X{other}		return(token(yytext[0]));
X
X%%
X
X#ifdef DEBUGLEX
X
Xstatic char * screen()
X{
X	return("IDENT");
X}
X
X
X#else
X
X/*
X * Reserved words
X */
X
Xstatic struct rwtable {
X	char *rw_name;
X	int rw_yylex;
X	} rwtable[] = {
X
X#include "reswords.h"
X
X	};
X
X/******************************************************************************
X * screen()                                                                   *
X *                                                                            *
X * Checks if the string stored in 'yytext' is a reserved word or an ident.    *
X *                                                                            *
X * Return values: token code for a reserved word or an ident                  *
X ******************************************************************************/
Xstatic int screen()
X{
X	struct rwtable *low = rwtable, *high = END(rwtable), *mid;
X	int c;
X	SYMBTABEL *symbol;
X
X	while (low <= high) {
X		mid = low + (high - low) / 2;
X		if ((c = strcmp(mid->rw_name, yytext)) == 0)
X			return(mid->rw_yylex);
X		else 	
X			if (c < 0) 
X				low = mid + 1;
X			else 
X				high = mid -1;
X	}
X	symbol = lookup_symbtabel(yytext);
X	yylval.y_symb = (symbol) ? symbol : enter_symbtabel(yytext);
X	if (!errflag && (yylval.y_symb->type == TYPEDEFNAME))
X		return(token(TYPEDEF_NAME));
X	else
X		return(token(IDENT));
X} /* screen */
X
X#endif /* !DEBUGLEX /**/
END_OF_FILE
if test 5800 -ne `wc -c <'dcc/dcc.l'`; then
    echo shar: \"'dcc/dcc.l'\" unpacked with wrong size!
fi
# end of 'dcc/dcc.l'
fi
if test -f 'dcc/files.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcc/files.c'\"
else
echo shar: Extracting \"'dcc/files.c'\" \(5298 characters\)
sed "s/^X//" >'dcc/files.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                              f i l e s . c                              *
X *                                                                         *
X *                            Package : Compiler                           *
X *                            Version : 1.0                                *
X *                       CreationDate : 15.08.90                           *
X *                         LastUpDate : 02.11.91                           *
X *                                                                         *
X *                    Some routines for handling files.                    *
X *                                                                         *
X *                  Portions Copyright 1990 Franz Distler                  *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include "config.h"
X#include "extern.h"
X#include "functions.h"
X
X/******************************************************************************
X * close_files()                                                              *
X *                                                                            *
X * Closes all special files created by 'open_files()'.                        *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
Xclose_files()
X{
X    struct process_list *ptr;
X
X    if (infoflag) {
X	printf("%s closing all files\n", infoprefix);
X	fflush(stdout);
X    }
X    for(ptr = first_processname; ptr; ptr = ptr->next)
X	fclose(ptr->file);
X    if (yyerrfile != stderr)
X	    fclose(yyerrfile);
X    if (inclfile)
X	fclose(inclfile);
X    if (funcfile)
X        fclose(funcfile);
X    if (creatfile)
X        fclose(creatfile);
X#if defined(HETEROGENEOUS) || defined(CHECK_XDR)
X    if (xdrfile)
X        fclose(xdrfile);
X#endif
X    if (makefile)
X        fclose(makefile);
X    if (outfile)
X        fclose(outfile);
X} /* close_files */
X
X/******************************************************************************
X * remove_files()                                                             *
X *                                                                            *
X * Deletes all special files created by 'open_files()'.                       *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
Xremove_files()
X{
X    register struct process_list *ptr;
X
X    if (infoflag) {
X	printf("%s removing all files\n", infoprefix);
X	fflush(stdout);
X    }
X    for(ptr = first_processname; ptr; ptr = ptr->next)
X	unlink(ptr->name);
X    if (yyerrfile != stderr)
X	    unlink(yyerrfilename);
X    unlink(inclfilename);
X    unlink(funcfilename);
X    unlink(creatfilename);
X#ifdef HETEROGENEOUS
X    unlink(xdrfilename);
X#endif
X    unlink(makefilename);
X    unlink(outputfilename);
X} /* remove_files */
X
X/******************************************************************************
X * append_file()                                                              *
X *                                                                            *
X * Appends the file 'srcfile' at the end of the file 'destfile'.              *
X *                                                                            *
X * Return values: always OK for success                                       *
X ******************************************************************************/
Xint
Xappend_file(srcfile, destfile)
XFILE *srcfile, *destfile;
X{
X    static char buffer[200];
X
X    rewind(srcfile);
X    while(fgets(buffer, 200, srcfile))
X        fputs(buffer, destfile);
X    return(OK);
X} /* append_file */
END_OF_FILE
if test 5298 -ne `wc -c <'dcc/files.c'`; then
    echo shar: \"'dcc/files.c'\" unpacked with wrong size!
fi
# end of 'dcc/files.c'
fi
if test -f 'dcinstall/Transfer.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcinstall/Transfer.c'\"
else
echo shar: Extracting \"'dcinstall/Transfer.c'\" \(5342 characters\)
sed "s/^X//" >'dcinstall/Transfer.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                           T r a n s f e r . c                           *
X *                                                                         *
X *                            Package : Installer Program                  *
X *                            Version : 1.1                                *
X *                       CreationDate : 20.11.91                           *
X *                         LastUpDate : 25.02.92                           *
X *                                                                         *
X * The routine 'TransferFiles' which performs the complete distributing of *
X * the source code information to the different file systems.              *
X *                                                                         *
X *               Copyright (C) 1991-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <pwd.h>
X#include "cfgparsers.h"
X#include "dcinstall.h"
X
X/******************************************************************************
X * TransferFiles()                                                            *
X *                                                                            *
X * Transfers all needed files from the local host 'src' to the destination    *
X * host 'dest'.                                                               *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
XTransferFiles(src, dest)
XSYMBTABEL *src;		/* source host      */
XSYMBTABEL *dest;	/* destination host */
X{
X    int mounted;		/* src and dest share one filesystem or not */
X    static char cmd[200];	/* to store the command */
X    FILENAMELIST *fptr;		/* pointer to a list of filenames */
X
X    if (dest->info.Host.ex_storage->info.disk.wascopied) 
X	return(OK);
X
X#ifndef DEBUG
X    printf("    Transfering  files %s (%s) -> %s (%s)\n",
X        src->name, src->info.Host.ex_storage->name, 
X	dest->name, dest->info.Host.ex_storage->name);
X#endif /* Not DEBUG /**/
X
X    /* Determine access mode:
X     * If source-host equals destination host or source and dest host
X     * share one disk the access mode is mounted. Otherwise if dest is
X     * accessed via network, it is not mounted!
X     */
X    if (src == dest || src->info.Host.ex_storage->info.disk.location == dest->info.Host.ex_storage->info.disk.location)
X        mounted = TRUE;
X    else
X        mounted = FALSE;
X
X    /* Transfer include files */
X    for(fptr = first_incl_file; fptr; fptr = fptr->next) {
X	if (mounted)
X    	    sprintf(cmd, "cp %s %s/dcc/compile/%s", 
X		fptr->name, gethomedir(getLogin()), fptr->name);
X	else
X	    sprintf(cmd, "rcp %s %s@%s:./dcc/compile/%s", 
X		fptr->name, getLogin(), dest->name, fptr->name);
X
X	if (verbose)
X	    printf("    Transfering  command: %s\n", cmd);
X
X	if (!noexecute)
X            if (system(cmd)) {
X	        fprintf(stderr, "\nError transferring the files to host \"%s\"\n", dest->name);
X	        fprintf(stderr, "The following command caused the error:\n");
X	        fprintf(stderr, "\"%s\"\n", cmd);
X	        exit(ERROR);
X	    }
X    } /* for */
X
X    /* Transfer other files */
X    for(fptr = first_file; fptr; fptr = fptr->next) {
X	if (mounted)
X    	    sprintf(cmd, "cp %s %s/dcc/compile/%s", 
X		fptr->name, gethomedir(getLogin()), fptr->name);
X	else
X	    sprintf(cmd, "rcp %s %s@%s:./dcc/compile/%s", 
X		fptr->name, getLogin(), dest->name, fptr->name);
X
X	if (verbose)
X	    printf("    Transfering  command: %s\n", cmd);
X
X	if (!noexecute)
X            if (system(cmd)) {
X	        fprintf(stderr, "\nError transferring the files to host \"%s\"\n", dest->name);
X	        fprintf(stderr, "The following command caused the error:\n");
X	        fprintf(stderr, "\"%s\"\n", cmd);
X	        exit(ERROR);
X	    }
X    } /* for */
X
X    dest->info.Host.ex_storage->info.disk.wascopied = TRUE;
X
X    return(OK);
X} /* TransferFiles */
END_OF_FILE
if test 5342 -ne `wc -c <'dcinstall/Transfer.c'`; then
    echo shar: \"'dcinstall/Transfer.c'\" unpacked with wrong size!
fi
# end of 'dcinstall/Transfer.c'
fi
if test -f 'include/dcadmin.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/dcadmin.h'\"
else
echo shar: Extracting \"'include/dcadmin.h'\" \(5734 characters\)
sed "s/^X//" >'include/dcadmin.h' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                           d c a d m i n . h                             *
X *                                                                         *
X *                              Package : Include Files                    *
X *                              Version : 1.0                              *
X *                         CreationDate : 23.10.90                         *
X *                           LastUpDate : 06.12.93                         *
X *                                                                         *
X * The configuration include file for building the administration process. *
X *                                                                         *
X *                  Portions Copyright 1990 Franz Distler                  *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#ifndef __dcadmin_h
X#define __dcadmin_h
X
X/* define this to display additional informations */
X/* #define ADMINDEBUG /**/
X
X/* define this to locate processes to hosts by mapfile
X * undefine this to locate them by configuration files
X */
X/* #define USE_MAPFILE /**/
X
X/* name of process creation configuration file */
X#ifdef USE_MAPFILE
X# define CONFIGFILE      "dcc.config"
X#else
X# define CONFIGFILE      "dclocate.dat"
X#endif /* USE_MAPFILE /**/
X
X/* the filename of the file to write the debug messages into */
X#define DEBUGFILENAME	"dcadmin.debug"
X
X/* the "security" delay to wait until ordering the processes to terminate */
X#define SHUTDOWN_DELAY	60
X
X/* the "security" delay to wait until finishing execution */
X#define TERMINATE_DELAY	60
X
X/* size of the encode/decode buffer */
X#define ADMINDCCBUFSIZE	10000
X
X/* process states */
X#define RUNNING		1       /* process running */
X#define ACCORTER	2       /* process in accept or terminate state */
X#define TERMINATED	3       /* process terminated */
X
X/* process data list:
X * All informations about processes and process states are stored in this 
X * list
X */
Xstruct pdat_list {
X	PROCESSDESCR p_descr;   /* process descriptor */
X#if defined(SCO_UNIX) && !defined(USE_MAPFILE)
X	char         hostname[100];
X#endif
X	int          status;    /* state of the process */
X	struct pdat_list *next;	/* next element of the list */
X};
X
X#ifdef USE_MAPFILE
X/* process creation list:
X * All informations needed to determine locations where to create processes
X * are stored in this list
X */
Xstruct pcreat_list {
X	int   max_num,             /* max. number of processes to create */
X	      created_num;         /* number of already created processes */
X	char *processname,         /* name of process */
X	     *username,            /* name of user */
X	     *hostname;            /* name of host */
X	struct pcreat_list *next;  /* next element in list */
X};
X#endif /* USE_MAPFILE /**/
X
Xextern int   
X	Intr,		/* indicating interrupt or not */
X        shutdown,	/* flag if to terminate all processes */
X        terminate,	/* flag if to finish own execution */
X	check_allocation;
X
X#ifdef UNICOS
Xextern long yydebug;
X#else
Xextern int yydebug;
X#endif
X
Xextern FILE 
X	*_debugout,
X	*dfile,
X        *yyin,
X        *yyout;
X
Xextern struct pdat_list 
X	*pdat_first; 	/* anchor of process status list */
X
X#ifdef USE_MAPFILE
Xextern struct pcreat_list 
X	*pcreat_first,	/* anchor to begin of process creation list */
X	*pcreat_last;	/* anchor to end of process creation list */
X#endif /* USE_MAPFILE /**/
X
X/*
X * prototypes of the functions 
X */
X
X#ifdef __STDC__
X#if defined(__STDC__) && !defined(NO_PROTOTYPE)
X# define FUNCPROTO(type,id,args)        extern type id args
X#else
X# define FUNCPROTO(type,id,args)        extern type id()
X#endif /* __STDC__ /**/
X
X#if defined(HPUX) || defined(UNICOS) || defined(LINUX)
XFUNCPROTO(void	, CatchSignals, (int));
X#else
XFUNCPROTO(int	, CatchSignals, (int));
X#endif
XFUNCPROTO(int	, ChangeProcessStatus, (int));
XFUNCPROTO(int	, CheckAcceptOrTerminate, ());
XFUNCPROTO(int	, DeleteProcessFromList, ());
XFUNCPROTO(int	, DetermineCreationLocation, ());
XFUNCPROTO(int	, DisplayCreationList, ());
XFUNCPROTO(int	, DisplayProcessList, ());
XFUNCPROTO(int	, DisplayStatus, ());
XFUNCPROTO(int	, GetChildStatus, ());
XFUNCPROTO(int	, GetConfigFilename, (char *));
XFUNCPROTO(int	, KillProcesses, ());
XFUNCPROTO(int	, SetSignals, ());
XFUNCPROTO(int	, ShutdownProcesses, ());
XFUNCPROTO(int	, StoreNewProcessInList, ());
XFUNCPROTO(int	, error, (char *));
X
X#endif /* __STDC__ /**/
X
X#endif /* !__dcadmin_h /**/
END_OF_FILE
if test 5734 -ne `wc -c <'include/dcadmin.h'`; then
    echo shar: \"'include/dcadmin.h'\" unpacked with wrong size!
fi
# end of 'include/dcadmin.h'
fi
if test -f 'include/timeout.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/timeout.h'\"
else
echo shar: Extracting \"'include/timeout.h'\" \(6002 characters\)
sed "s/^X//" >'include/timeout.h' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                            t i m e o u t . h                            *
X *                                                                         *
X *                            Package : Include files                      *
X *                            Version : 1.0                                *
X *                       CreationDate : 16.08.90                           *
X *                         LastUpDate : 12.03.92                           *
X *                                                                         *
X *               Definitions specifiying the timeout values.               *
X *                                                                         *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#ifndef __timeout_h
X#define __timeout_h
X
X/* NOTE: All values specify seconds! */
X
X/*
X * administration process
X */
X
X#ifndef iPSC
X/* maximum time trying to report back to creator process */
X# define ADMINCONTIME	60
X#endif /* Not iPSC /**/
X/* maximum time to wait accepting a service request */
X#define ADMINACCTIME	0	/* UNLIMITED! */
X/* maximum time to wait receiving service information */
X#define ADMINRCVTIME	30
X/* maximum time to wait receiving processname for location request */
X#define ADMINPRCTIME	30
X/* maximum time trying to send location reply */
X#define ADMINLOCTIME	60
X/* maximum time to wait accepting the connection to get config filename */
X#define ADMINFNATIME	60
X/* maximum time to wait receiving config filename */
X#define ADMINFNRTIME	30
X
X/* 
X * creator process 
X */
X
X#ifdef iPSC
X/* maximum time trying to connect to a new created process */
X# define CPTONPCONTIME	60 
X/* maximum time trying to send the port information to a new process */
X# define CPTONPPDATTIME	30
X#else
X/* time to wait for a connection request of a new created process */
X# define CPTONPACCTIME	180
X#endif /* iPSC /**/
X/* maximum time trying to connect to admin process to get location info */
X#define CPTOAPCONTIME	180 
X/* maximum time trying to send the location request to the admin process */
X#define CPTOAPREQTIME	60
X/* maximum time trying to send the processname to the admin process */
X#define CPTOAPSNDTIME	60
X/* maximum time trying to receive the location info from admin process */
X#define CPTOAPRCVTIME	180
X/* time to wait receiving port data of a new created process */
X#define CPTONPREPTIME	180
X/* maximum time trying to send the parameters to a new created process */
X#define CPTONPPARTIME	180
X
X/*
X * new created process
X */
X
X#ifdef iPSC
X/* time to wait for a connection request of a new created process */
X# define NPTOCPACCTIME	60
X/* time to wait for receiving port information from creator process */
X# define NPTOCPPDATTIME	30
X#else
X/* time to wait making a connection to the creator process */
X# define NPTOCPCONTIME	120
X#endif /* iPSC /**/
X/* time to wait making a connection to the administration process */
X#define NPTOAPCONTIME	180
X/* time to wait for sending request type to the administration process */
X#define NPTOAPREQTIME	60
X/* time to wait for sending process data to administration process */
X#define NPTOAPSNDTIME	60
X/* time to wait receiving parameters from creator process */
X#define NPTOCPPARTIME	180
X
X/*
X * calling transactions
X */
X
X/* maximum time trying to connect to the called process */
X#define TRANSCONTIME	0	/* UNLIMITED! */
X/* time to wait trying to send the transaction request message */
X#define TRANSREQTIME	60
X/* time to wait for reply message of transaction request message */
X#define TRANSREPTIME	60
X/* time to wait trying to send transaction arguments */
X#define TRANSARGTIME	180
X/* time to wait for transaction results */
X#define TRANSRESTIME	0	/* UNLIMITED! */
X
X/*
X * accepting transactions
X */
X
X/* time to wait for a connection request */
X#define ACCEPTCONTIME	0	/* UNLIMITED! */
X/* time to wait for transaction request message */
X#define ACCEPTREQTIME	60
X/* time to wait trying to send reply message */
X#define ACCEPTREPTIME	60
X/* time to wait trying to receive parameters */
X#define ACCEPTPARTIME	180
X/* time to wait trying to send transaction results back */
X#define ACCEPTRESTIME	180
X
X/*
X * select statements
X */
X
X/* time to wait for a connection request to accept */
X#define SELECTCONTIME	0	/* UNLIMITED! */
X/* time to wait for transaction request message */
X#define SELECTREQTIME	30
X/* time to wait trying to receive parameters */
X#define SELECTPARTIME	180
X/* time to wait trying to send transaction results back */
X#define SELECTRESTIME	180
X
X/*
X * others 
X */
X
X/* time to wait sending a conection type */
X#define CONNTYPESNDTIME	60
X/* time to wait receiving a conection type */
X#define CONNTYPERCVTIME	60
X
X#endif /* !__timeout_h /**/
END_OF_FILE
if test 6002 -ne `wc -c <'include/timeout.h'`; then
    echo shar: \"'include/timeout.h'\" unpacked with wrong size!
fi
# end of 'include/timeout.h'
fi
if test -f 'ipc/p2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ipc/p2.c'\"
else
echo shar: Extracting \"'ipc/p2.c'\" \(6119 characters\)
sed "s/^X//" >'ipc/p2.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *            A precompiler for distributed programming with C             *
X *                                                                         *
X *                                p 2 . c                                  *
X *                                                                         *
X *                 Version 1.0      CreationDate: 15.07.90                 *
X *                                    LastUpDate: 24.09.90                 *
X *                                                                         *
X *           Process 2 for testing the communication primitives.           *
X *                                                                         *
X *        Copyright (C) 1990 by Franz Distler and Christoph Pleier.        *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include "ipc.h"
X#include "run_Errno.h"
X
X#ifdef SYSTEM_V
X# define u_short	int
X#endif /* SYSTEM_V /**/
X
X#define DELAY		10
X#define MSGNUM		100
X
Xint		Errno;
XPORTDESCR 	own_port,
X		P1_port,
X		P3_port;
XCONNECTIONDESCR	con_port1,
X		con_port2;
X
X/* global variables needed for the library functions! */
Xchar            *_programname = "p2",
X                *_processname = "P2";
XPORTDESCR 	 _own_port, 
X                 _creator_port,	/* unused, but needed! */
X                 _admin_port;	/* unused, but needed! */
XCONNECTIONDESCR	 _con_port;
X
Xmain()
X{
X	int i;
X	char buffer[100];
X
X	puts("dcc - distributed c compiler");
X	puts("Copyright (C) 1990 by Franz Distler and Christoph Pleier\n");
X	puts("Process p2 used for testing the communication primitives");
X	puts("Remark: the starting order is: p1, p2, p3");
X	if (_create_port(&own_port))
X		_RuntimeError("P2: Error creating own port 1");
X
X#ifndef iPSC
X	_display_port_info("P2: port", own_port);
X
X	puts("P2: Enter port information of port 1 of process P1:");
X	_input_port_info(&P1_port);
X	puts("P2: Enter port information of port of process P3:");
X	_input_port_info(&P3_port);
X#else
X	P1_port.node = 5;
X	P1_port.pid  = 100;
X	P3_port.node = 7;
X	P3_port.pid  = 102;
X#endif /* iPSC /**/
X
X	printf("\nP2: Test 1a: waiting %d seconds\n", DELAY);
X	sleep(DELAY);
X
X	puts("\nP2: Test 1a: make_connection(...,'P2','P1',0)");
X	if (_make_connection(&con_port1, own_port, P1_port, 0))
X		_RuntimeError("P2: Error making connection");
X	puts("P2: Test 1a: sending 2 messages");
X	strcpy(buffer, "Test 1: Message 1");
X	if (_send_data(con_port1, buffer, 18, 0) < 0)
X		_RuntimeError("P2: Error in send_data 1");
X	strcpy(buffer, "Test 1: Message 2");
X	if (_send_data(con_port1, buffer, 18, 0) < 0)
X		_RuntimeError("P2: Error in send_data 2");
X	puts("P2: Test 1a: receiving 1 message");
X	if (_recv_data(con_port1, buffer, 18, 0) < 0)
X		_RuntimeError("P2: Error in recv_data 1");
X	if (strcmp(buffer, "Test 1: Message 3")) {
X		puts("P2: Error: wrong message received!");
X		_close_connection(con_port1);
X		_delete_port(own_port);
X		exit(-1);
X	}
X	puts("P2: Test 1a: sending 1 message");
X	strcpy(buffer, "Test 1: Message 4");
X	if (_send_data(con_port1, buffer, 18, 0) < 0)
X		_RuntimeError("P2: Error in send_data 3");
X	if (_close_connection(con_port1))
X		_RuntimeError("P2: Error closing connection");
X
X	printf("\nP2: Test 1b: waiting %d seconds\n", DELAY);
X	sleep(DELAY);
X
X	puts("P2: Test 1b: accept_connection(...,'P2',0)");
X	if (_accept_connection(&con_port1, own_port, 0))
X		_RuntimeError("P2: Error accepting connection");
X	puts("P2: Test 1b: sending 2 messages");
X	strcpy(buffer, "Test 1: Message 1");
X	if (_send_data(con_port1, buffer, 18, 0) < 0)
X		_RuntimeError("P2: Error in send_data 1");
X	strcpy(buffer, "Test 1: Message 2");
X	if (_send_data(con_port1, buffer, 18, 0) < 0)
X		_RuntimeError("P2: Error in send_data 2");
X	puts("P2: Test 1b: receiving 1 message");
X	if (_recv_data(con_port1, buffer, 18, 0) < 0) 
X		_RuntimeError("P2: Error in recv_data 1");
X	if (strcmp(buffer, "Test 1: Message 3")) {
X		puts("P2: Error: wrong message received!");
X		_close_connection(con_port1);
X		_delete_port(own_port);
X		exit(-1);
X	}
X	puts("P2: Test 1b: sending 1 message");
X	strcpy(buffer, "Test 1: Message 4");
X	if (_send_data(con_port1, buffer, 18, 0) < 0)
X		_RuntimeError("P2: Error in send_data 3");
X	if (_close_connection(con_port1))
X		_RuntimeError("P2: Error closing connection");
X
X	puts("\nP2: Test 2c: accept_connection(...,'P2',0)");
X	if (_accept_connection(&con_port1, own_port, 0))
X		_RuntimeError("P2: Error accepting connection");
X
X	puts("P2: Test 3: waiting 20 seconds");
X	sleep(20);
X
X	puts("\nP2: Test 3: make_connection(...,'P2','P3',0)");
X	if (_make_connection(&con_port2, own_port, P3_port, 0))
X		_RuntimeError("P2: Error making connection");
X	printf("P2: Test3: sending %d messages\n", MSGNUM);
X	for (i=1; i<=100; i++) {
X		sprintf(buffer, "Test 3: Message %3d", i);
X		if (_send_data(con_port1, buffer, 22, 0) < 0)
X			_RuntimeError("P2: Error in send_data");
X	}
X
X	_close_connection(con_port1);
X	_close_connection(con_port2);
X	_delete_port(own_port);
X
X	puts("\nP2: Done!");
X	exit(0);
X}
END_OF_FILE
if test 6119 -ne `wc -c <'ipc/p2.c'`; then
    echo shar: \"'ipc/p2.c'\" unpacked with wrong size!
fi
# end of 'ipc/p2.c'
fi
if test -f 'lib/debug.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib/debug.c'\"
else
echo shar: Extracting \"'lib/debug.c'\" \(6239 characters\)
sed "s/^X//" >'lib/debug.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                             d e b u g . c                               *
X *                                                                         *
X *                            Package : Runtime Library                    *
X *                            Version : 1.0                                *
X *                       CreationDate : 26.09.90                           *
X *                         LastUpDate : 12.09.91                           *
X *                                                                         *
X * The library routines to initialize the processprefix and to display the *
X * components of important data structures.                                *
X *                                                                         *
X *     Copyright (C) 1990-1994 by Franz Distler and Christoph Pleier.      *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#ifdef HETEROGENEOUS
X# include <rpc/rpc.h>
X#endif
X#include "ipc.h"
X#include "dcc.h"
X#include "run_Errno.h"
X
X/* some debug specific variables */
Xint   _debugflush = 1;
XFILE *_debugout = stdout;
X
X/******************************************************************************
X * _set_processprefix()                                                       *
X *                                                                            *
X * Initializes the processprefix of a process. A processprefix is a string    *
X * that names a process unmistakeable. According to the choosen system the    *
X * string is a combination of processname, process id, node number or host    *
X * name.                                                                      *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
X_set_processprefix()
X{
X    static char tmpstr1[100];
X#ifndef SINGLE
X    static char hostname[MAXHOSTNAMELEN];
X#endif
X
X    /* processname (max. 15 chars) */
X    strcpy(tmpstr1, _processname);
X    tmpstr1[15] = '\0';
X#ifdef iPSC
X    /* processname, node number and process id */
X    sprintf(_processprefix, "%-15s | %ld | %ld:", tmpstr1, mynode(), mypid());
X#else
X# ifdef SINGLE
X    /* processname and process id */
X    sprintf(_processprefix, "%-15s | %d:", tmpstr1, getpid());
X# else /* HOMOGENEOUS || HETEROGENEOUS */
X    /* processname, hostname (max. 15 chars) and process id */
X    if (gethostname(hostname, MAXHOSTNAMELEN)) {
X	fputs("ERROR: can't get hostname by gethostname()!\n", stderr);
X    }
X    hostname[15] = '\0';
X    sprintf(_processprefix, "%-15s | %s | %d:", tmpstr1, hostname, getpid());
X# endif /* SINGLE /**/
X#endif /* iPSC /**/
X} /* _set_processprefix */
X
X/******************************************************************************
X * _display_processdescr_info()                                               *
X *                                                                            *
X * Displays the specific information of a process descriptor.                 *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
X_display_processdescr_info(prefix, msg, pdescr)
Xchar         *prefix,
X             *msg;
XPROCESSDESCR  pdescr;
X{
X    fprintf(_debugout, "%s %s %s\n", prefix, _processprefix, msg);
X    fprintf(_debugout, "%s %s    processname = \"%s\"\n", prefix, 
X	_processprefix, pdescr.processname);
X    fprintf(_debugout, "%s %s    pid = %d\n", prefix, _processprefix, 
X	pdescr.pid);
X    _display_port_info(prefix, "port", pdescr.port);
X} /* _display_processdescr_info */
X
X/******************************************************************************
X * _display_processdata_info()                                                *
X *                                                                            *
X * Displays the specific process information of a process data variable.      *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
X_display_processdata_info(prefix, msg, pdata)
Xchar        *prefix,
X            *msg;
XPROCESSDATA  pdata;
X{
X    fprintf(_debugout, "%s %s %s\n", prefix, _processprefix, msg);
X    fprintf(_debugout, "%s %s    processname = \"%s\"\n", prefix, 
X	_processprefix, pdata.processname);
X    fprintf(_debugout, "%s %s    pid = %d\n", prefix, _processprefix, 
X	pdata.pid);
X    _display_port_info(prefix, "   port", pdata.port);
X    fprintf(_debugout, "%s %s    error = %d\n", prefix, _processprefix, 
X	pdata.error);
X} /* _display_processdata_info */
END_OF_FILE
if test 6239 -ne `wc -c <'lib/debug.c'`; then
    echo shar: \"'lib/debug.c'\" unpacked with wrong size!
fi
# end of 'lib/debug.c'
fi
echo shar: End of archive 5 \(of 18\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
