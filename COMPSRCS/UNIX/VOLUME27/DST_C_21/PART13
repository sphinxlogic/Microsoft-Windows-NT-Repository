Newsgroups: comp.sources.unix
From: pleierc@informatik.tu-muenchen.de (Christoph Pleier)
Subject: v27i187: distributed-c-2.1 - Distributed C Development Environment, V2.1, Part13/18
References: <1.756634932.28500@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: pleierc@informatik.tu-muenchen.de (Christoph Pleier)
Posting-Number: Volume 27, Issue 187
Archive-Name: distributed-c-2.1/part13

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 13 (of 18)."
# Contents:  dcc/code_convert.c dcc/symb_others.c
#   examples/config/system.FICT lib/ipc_iPSC.c
# Wrapped by vixie@gw.home.vix.com on Thu Dec 23 00:12:05 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'dcc/code_convert.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcc/code_convert.c'\"
else
echo shar: Extracting \"'dcc/code_convert.c'\" \(24017 characters\)
sed "s/^X//" >'dcc/code_convert.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                       c o d e _ c o n v e r t . c                       *
X *                                                                         *
X *                            Package : Compiler                           *
X *                            Version : 1.0                                *
X *                       CreationDate : 08.06.91                           *
X *                         LastUpDate : 08.06.91                           *
X *                                                                         *
X *             All routines converting attributes to strings.              *
X *                                                                         *
X *               Copyright (C) 1991-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <string.h>
X#include "config.h"
X#include "extern.h"
X#include "functions.h"
X
X/******************************************************************************
X * convert_su_to_string()                                                     *
X *                                                                            *
X * Converts a struct or union attribute to a string.                          *
X *                                                                            *
X * Return values: pointer to created string upon success /                    *
X *                NULL during error handling                                  *
X ******************************************************************************/
Xchar *
Xconvert_su_to_string(buffer, struct_or_union)
Xchar *buffer;
XSU_ATTR *struct_or_union;
X{
X    if (errflag || !struct_or_union)
X	return(buffer);
X#ifdef CODEDEBUG
X    fprintf(debugfile, "[code] ***** convert_su_to_string():\n");
X#endif /* CODEDEBUG /**/
X    switch(struct_or_union->type) {
X    case SU_ATTR_STRUCT:
X	    buffer = Strcat(buffer, "struct ");
X	    break;
X    case SU_ATTR_UNION:
X	    buffer = Strcat(buffer, "union ");
X	    break;
X    default:
X	    Panic("unknown SU_ATTR type in convert_su_to_string()");
X    } /* switch */
X    return(buffer);
X} /* convert_su_to_string */
X
X/******************************************************************************
X * convert_ts_to_string()                                                     *
X *                                                                            *
X * Converts a type attribute to a string.                                     *
X *                                                                            *
X * Return values: pointer to created string upon success /                    *
X *                NULL during error handling                                  *
X ******************************************************************************/
Xchar *
Xconvert_ts_to_string(buffer, type_specifier, stl_flag)
Xchar *buffer;
XTS_ATTR *type_specifier;
Xchar stl_flag;
X{
X    if (errflag || !type_specifier)
X	return(buffer);
X#ifdef CODEDEBUG
X    fprintf(debugfile, "[code] ***** convert_ts_to_string():\n");
X#endif /* CODEDEBUG /**/
X    switch(type_specifier->type) {
X    case TS_ATTR_VOID:
X	    buffer = Strcat(buffer, "void ");
X	    break;
X    case TS_ATTR_CHAR:
X	    buffer = Strcat(buffer, "char ");
X	    break;
X    case TS_ATTR_SHORT:
X	    buffer = Strcat(buffer, "short ");
X	    break;
X    case TS_ATTR_INT:
X	    buffer = Strcat(buffer, "int ");
X	    break;
X    case TS_ATTR_LONG:
X	    buffer = Strcat(buffer, "long ");
X	    break;
X    case TS_ATTR_FLOAT:
X	    buffer = Strcat(buffer, "float ");
X	    break;
X    case TS_ATTR_DOUBLE:
X	    buffer = Strcat(buffer, "double ");
X	    break;
X    case TS_ATTR_PROCESS:
X	    buffer = Strcat(buffer, "PROCESSDESCR ");
X	    break;
X    case TS_ATTR_SIGNED:
X	    buffer = Strcat(buffer, "signed ");
X	    break;
X    case TS_ATTR_UNSIGNED:
X	    buffer = Strcat(buffer, "unsigned ");
X	    break;
X    case TS_ATTR_ENUM:
X	    buffer = Strcat(buffer, type_specifier->info.enuminfo->codestr);
X	    break;
X    case TS_ATTR_STRUCT:
X	    buffer = convert_sus_to_string(buffer, 
X		type_specifier->info.structinfo, stl_flag);
X	    break;
X    case TS_ATTR_TYPENAME:
X	    buffer = Strcatmany(buffer, 2, type_specifier->info.typedefname->name, " ");
X	    break;
X    default:
X	    Panic("unknown TS_ATTR type in convert_ts_to_string()");
X    } /* switch */
X    return(buffer);
X} /* convert_ts_to_string */
X
X/******************************************************************************
X * convert_tq_to_string()                                                     *
X *                                                                            *
X * Converts a type qualifier to a string.                                     *
X *                                                                            *
X * Return values: pointer to created string upon success /                    *
X *                NULL during error handling                                  *
X ******************************************************************************/
Xchar *
Xconvert_tq_to_string(buffer, type_qualifier)
Xchar *buffer;
XTQ_ATTR *type_qualifier;
X{
X    if (errflag || !type_qualifier)
X	return(buffer);
X#ifdef CODEDEBUG
X    fprintf(debugfile, "[code] ***** convert_tq_to_string():\n");
X#endif /* CODEDEBUG /**/
X    switch(type_qualifier->type) {
X    case TQ_ATTR_CONST:
X	    buffer = Strcat(buffer, "const ");
X	    break;
X    case TQ_ATTR_VOLATILE:
X	    buffer = Strcat(buffer, "volatile ");
X	    break;
X    default:
X	    Panic("unknown TQ_ATTR type in convert_tq_to_string()");
X    } /* switch */
X    return(buffer);
X} /* convert_tq_to_string */
X
X/******************************************************************************
X * convert_scs_to_string()                                                    *
X *                                                                            *
X * Converts a storage class specifier attribute to a string.                  *
X *                                                                            *
X * Return values: pointer to created string upon success /                    *
X *                NULL during error handling                                  *
X ******************************************************************************/
Xchar *
Xconvert_scs_to_string(buffer, storage_class_specifier)
Xchar *buffer;
XSCS_ATTR *storage_class_specifier;
X{
X    if (errflag || !storage_class_specifier)
X	return(buffer);
X#ifdef CODEDEBUG
X    fprintf(debugfile, "[code] ***** convert_scs_to_string():\n");
X#endif /* CODEDEBUG /**/
X    switch(storage_class_specifier->type) {
X    case SCS_ATTR_AUTO:
X	    buffer = Strcat(buffer, "auto ");
X	    break;
X    case SCS_ATTR_REGISTER:
X	    buffer = Strcat(buffer, "register ");
X	    break;
X    case SCS_ATTR_STATIC:
X	    buffer = Strcat(buffer, "static ");
X	    break;
X    case SCS_ATTR_EXTERN:
X	    buffer = Strcat(buffer, "extern ");
X	    break;
X    case SCS_ATTR_TYPEDEF:
X	    buffer = Strcat(buffer, "typedef ");
X	    break;
X    default:
X	    Panic("unknown SCS_ATTR type in convert_scs_to_string()");
X    } /* switch */
X    return(buffer);
X} /* convert_scs_to_string */
X
X/******************************************************************************
X * convert_tql_to_string()                                                    *
X *                                                                            *
X * Converts a type qualifier list attribute to a string.                      *
X *                                                                            *
X * Return values: pointer to created string upon success /                    *
X *                NULL during error handling                                  *
X ******************************************************************************/
Xchar *
Xconvert_tql_to_string(buffer, type_qual_list)
Xchar *buffer;
XTQL_ATTR *type_qual_list;
X{
X    if (errflag || !type_qual_list)
X	return(buffer);
X#ifdef CODEDEBUG
X    fprintf(debugfile, "[code] ***** convert_tql_to_string():\n");
X#endif /* CODEDEBUG /**/
X    buffer = convert_tql_to_string(buffer, type_qual_list->tq_list);
X    buffer = convert_tq_to_string(buffer, type_qual_list->type_qualifier);
X    return(buffer);
X} /* convert_tql_to_string */
X
X/******************************************************************************
X * convert_p_to_string()                                                      *
X *                                                                            *
X * Converts a pointer attribute to a string.                                  *
X *                                                                            *
X * Return values: pointer to created string upon success /                    *
X *                NULL during error handling                                  *
X ******************************************************************************/
Xchar *
Xconvert_p_to_string(buffer, pointer)
Xchar *buffer;
XP_ATTR *pointer;
X{
X    if (errflag || !pointer)
X	return(buffer);
X#ifdef CODEDEBUG
X    fprintf(debugfile, "[code] ***** convert_p_to_string():\n");
X#endif /* CODEDEBUG /**/
X    buffer = Strcat(buffer, "*");
X    if (pointer->type == P_ATTR_1 || pointer->type == P_ATTR_3)
X	buffer = convert_tql_to_string(buffer, pointer->quali_list);
X    if (pointer->type == P_ATTR_3 || pointer->type == P_ATTR_4)
X	buffer = convert_p_to_string(buffer, pointer->pointer);
X    return(buffer);
X} /* convert_p_to_string */
X
X/******************************************************************************
X * convert_dd_to_string()                                                     *
X *                                                                            *
X * Converts a direct declarator attribute to a string.                        *
X *                                                                            *
X * Return values: pointer to created string upon success /                    *
X *                NULL during error handling                                  *
X ******************************************************************************/
Xchar *
Xconvert_dd_to_string(buffer, direct_decl)
Xchar *buffer;
XDD_ATTR *direct_decl;
X{
X    if (errflag || !direct_decl)
X	return(buffer);
X#ifdef CODEDEBUG
X    fprintf(debugfile, "[code] ***** convert_dd_to_string():\n");
X#endif /* CODEDEBUG /**/
X    switch(direct_decl->type) {
X    case DD_ATTR_IDENT:
X        buffer = Strcat(buffer, direct_decl->ident->name);
X        break;
X    case DD_ATTR_BRACED:
X	buffer = Strcat(buffer, "(");
X	buffer = convert_d_to_string(buffer, direct_decl->info.declarator);
X	buffer = Strcat(buffer, ")");
X        break;
X    case DD_ATTR_ARRAY:
X	buffer = convert_dd_to_string(buffer, direct_decl->info.comp.direct_decl);
X	buffer = Strcatmany(buffer, 3, "[", direct_decl->info.comp.spec_str, "]");
X	break;
X    case DD_ATTR_FUNC:
X	buffer = convert_dd_to_string(buffer, direct_decl->info.comp.direct_decl);
X	buffer = Strcatmany(buffer, 3, "(", direct_decl->info.comp.spec_str, ")");
X	break;
X    } /* switch */
X    return(buffer);
X} /* convert_dd_to_string */
X
X/******************************************************************************
X * convert_d_to_string()                                                      *
X *                                                                            *
X * Converts a declarator attribute to a string.                               *
X *                                                                            *
X * Return values: pointer to created string upon success /                    *
X *                NULL during error handling                                  *
X ******************************************************************************/
Xchar *
Xconvert_d_to_string(buffer, declarator)
Xchar *buffer;
XD_ATTR *declarator;
X{
X    if (errflag || !declarator)
X	return(buffer);
X#ifdef CODEDEBUG
X    fprintf(debugfile, "[code] ***** convert_d_to_string():\n");
X#endif /* CODEDEBUG /**/
X    if (declarator->pointer)
X	buffer = convert_p_to_string(buffer, declarator->pointer);
X    buffer = convert_dd_to_string(buffer, declarator->direct_decl);
X    return(buffer);
X} /* convert_d_to_string */
X
X/******************************************************************************
X * convert_sd_to_string()                                                     *
X *                                                                            *
X * Converts a struct declarator attribute to a string.                        *
X *                                                                            *
X * Return values: pointer to created string upon success /                    *
X *                NULL during error handling                                  *
X ******************************************************************************/
Xchar *
Xconvert_sd_to_string(buffer, struct_declarator)
Xchar *buffer;
XSD_ATTR *struct_declarator;
X{
X    if (errflag || !struct_declarator)
X	return(buffer);
X#ifdef CODEDEBUG
X    fprintf(debugfile, "[code] ***** convert_sd_to_string():\n");
X#endif /* CODEDEBUG /**/
X    if (struct_declarator->decl) 
X	buffer = convert_d_to_string(buffer, struct_declarator->decl);
X    if (struct_declarator->const_expr)
X	buffer = Strcatmany(buffer, 2, " : ", struct_declarator->const_expr);
X    return(buffer);
X} /* convert_sd_to_string */
X
X/******************************************************************************
X * convert_sql_to_string()                                                    *
X *                                                                            *
X * Converts a specifier qualifier list attribute to a string.                 *
X *                                                                            *
X * Return values: pointer to created string upon success /                    *
X *                NULL during error handling                                  *
X ******************************************************************************/
Xchar *
Xconvert_sql_to_string(buffer, spec_qual_list)
Xchar *buffer;
XSQL_ATTR *spec_qual_list;
X{
X    if (errflag || !spec_qual_list)
X	return(buffer);
X#ifdef CODEDEBUG
X    fprintf(debugfile, "[code] ***** convert_sql_to_string():\n");
X#endif /* CODEDEBUG /**/
X    if (spec_qual_list->type == SQL_ATTR_SPECIFIER)
X	buffer = convert_ts_to_string(buffer, spec_qual_list->info.type_specifier, FALSE);
X    else
X	buffer = convert_tq_to_string(buffer, spec_qual_list->info.type_qualifier);
X    if (spec_qual_list->sq_list)
X        buffer = convert_sql_to_string(buffer, spec_qual_list->sq_list->sq_list);
X    return(buffer);
X} /* convert_sql_to_string */
X
X/******************************************************************************
X * convert_sdl_to_string()                                                    *
X *                                                                            *
X * Converts a struct declarator list attribute to a string.                   *
X *                                                                            *
X * Return values: pointer to created string upon success /                    *
X *                NULL during error handling                                  *
X ******************************************************************************/
Xchar *
Xconvert_sdl_to_string(buffer, struct_decl_list)
Xchar *buffer;
XSDL_ATTR *struct_decl_list;
X{
X    if (errflag || !struct_decl_list)
X	return(buffer);
X#ifdef CODEDEBUG
X    fprintf(debugfile, "[code] ***** convert_sdl_to_string():\n");
X#endif /* CODEDEBUG /**/
X    buffer = convert_sd_to_string(buffer, struct_decl_list->struct_declarator);
X    if (struct_decl_list->sd_list) {
X	buffer = Strcat(buffer, ", ");
X	buffer = convert_sdl_to_string(buffer, struct_decl_list->sd_list);
X    }
X    return(buffer);
X} /* convert_sdl_to_string */
X
X/******************************************************************************
X * convert_st_to_string()                                                     *
X *                                                                            *
X * Converts a struct declaration attribute to a string.                       *
X *                                                                            *
X * Return values: pointer to created string upon success /                    *
X *                NULL during error handling                                  *
X ******************************************************************************/
Xchar *
Xconvert_st_to_string(buffer, struct_decl)
Xchar *buffer;
XST_ATTR *struct_decl;
X{
X    if (errflag || !struct_decl)
X	return(buffer);
X#ifdef CODEDEBUG
X    fprintf(debugfile, "[code] ***** convert_st_to_string():\n");
X#endif /* CODEDEBUG /**/
X    buffer = convert_sql_to_string(buffer, struct_decl->spec_qual_list);
X    buffer = convert_sdl_to_string(buffer, struct_decl->struct_decl_list);
X    buffer = Strcat(buffer, ";\n");
X    return(buffer);
X} /* convert_st_to_string */
X
X/******************************************************************************
X * convert_stl_to_string()                                                    *
X *                                                                            *
X * Converts a struct declaration list attribute to a string.                  *
X *                                                                            *
X * Return values: pointer to created string upon success /                    *
X *                NULL during error handling                                  *
X ******************************************************************************/
Xchar *
Xconvert_stl_to_string(buffer, struct_decl_list)
Xchar *buffer;
XSTL_ATTR *struct_decl_list;
X{
X    if (errflag || !struct_decl_list)
X	return(buffer);
X#ifdef CODEDEBUG
X    fprintf(debugfile, "[code] ***** convert_stl_to_string():\n");
X#endif /* CODEDEBUG /**/
X    buffer = convert_st_to_string(buffer, struct_decl_list->struct_decl);
X    if (struct_decl_list->st_list)
X	buffer = convert_stl_to_string(buffer, struct_decl_list->st_list);
X    return(buffer);
X} /* convert_stl_to_string */
X
X/******************************************************************************
X * convert_sus_to_string()                                                    *
X *                                                                            *
X * Converts a struct or union specifier attribute to a string.                *
X *                                                                            *
X * Return values: pointer to created string upon success /                    *
X *                NULL during error handling                                  *
X ******************************************************************************/
Xchar *
Xconvert_sus_to_string(buffer, sus, stl_flag)
Xchar *buffer;
XSUS_ATTR *sus;
Xchar stl_flag;
X{
X    if (errflag || !sus)
X	return(buffer);
X#ifdef CODEDEBUG
X    fprintf(debugfile, "[code] ***** convert_sus_to_string():\n");
X#endif /* CODEDEBUG /**/
X    buffer = convert_su_to_string(buffer, sus->struct_or_union);
X    if (sus->tag)
X	buffer = Strcatmany(buffer, 2, sus->tag->name, " ");
X    if ((stl_flag || !sus->tag) && sus->struct_decl_list) {
X	buffer = Strcat(buffer, " { \n");
X	buffer = convert_stl_to_string(buffer, sus->struct_decl_list);
X	buffer = Strcat(buffer, "} ");
X    }
X    return(buffer);
X} /* convert_sus_to_string */
X
X/******************************************************************************
X * convert_ds_to_string()                                                     *
X *                                                                            *
X * Converts a declaration specifiers attribute to a string.                   *
X *                                                                            *
X * Return values: pointer to created string upon success /                    *
X *                NULL during error handling                                  *
X ******************************************************************************/
Xchar *
Xconvert_ds_to_string(buffer, decl_spec)
Xchar *buffer;
XDS_ATTR *decl_spec;
X{
X    if (errflag || !decl_spec)
X	return(buffer);
X#ifdef CODEDEBUG
X    fprintf(debugfile, "[code] ***** convert_ds_to_string():\n");
X#endif /* CODEDEBUG /**/
X    if (decl_spec->scs)
X	buffer = convert_scs_to_string(buffer, decl_spec->scs);
X    else if (decl_spec->ts)
X	buffer = convert_ts_to_string(buffer, decl_spec->ts, FALSE);
X    else if (decl_spec->tq)
X	buffer = convert_tq_to_string(buffer, decl_spec->tq);
X    if (decl_spec->ds)
X	buffer = convert_ds_to_string(buffer, decl_spec->ds);
X    return(buffer);
X} /* convert_ds_to_string */
X
X/******************************************************************************
X * convert_id_to_string()                                                     *
X *                                                                            *
X * Converts a init declarator attribute to a string.                          *
X *                                                                            *
X * Return values: pointer to created string upon success /                    *
X *                NULL during error handling                                  *
X ******************************************************************************/
Xchar *
Xconvert_id_to_string(buffer, init_decl)
Xchar *buffer;
XID_ATTR *init_decl;
X{
X    if (errflag || !init_decl)
X	return(buffer);
X#ifdef CODEDEBUG
X    fprintf(debugfile, "[code] ***** convert_id_to_string():\n");
X#endif /* CODEDEBUG /**/
X    buffer = convert_d_to_string(buffer, init_decl->d);
X    if (init_decl->inistr)
X	buffer = Strcatmany(buffer, 2, " = ", init_decl->inistr);
X    return(buffer);
X} /* convert_id_to_string */
X
X/******************************************************************************
X * convert_idl_to_string()                                                    *
X *                                                                            *
X * Converts a init declarato list attribute to a string.                      *
X *                                                                            *
X * Return values: pointer to created string upon success /                    *
X *                NULL during error handling                                  *
X ******************************************************************************/
Xchar *
Xconvert_idl_to_string(buffer, id_list)
Xchar *buffer;
XIDL_ATTR *id_list;
X{
X    if (errflag || !id_list)
X	return(buffer);
X#ifdef CODEDEBUG
X    fprintf(debugfile, "[code] ***** convert_idl_to_string():\n");
X#endif /* CODEDEBUG /**/
X    buffer = convert_id_to_string(buffer, id_list->id);
X    if (id_list->id_list) {
X	buffer = Strcat(buffer, ", ");
X	buffer = convert_idl_to_string(buffer, id_list->id_list);
X    }
X    return(buffer);
X} /* convert_idl_to_string */
END_OF_FILE
if test 24017 -ne `wc -c <'dcc/code_convert.c'`; then
    echo shar: \"'dcc/code_convert.c'\" unpacked with wrong size!
fi
# end of 'dcc/code_convert.c'
fi
if test -f 'dcc/symb_others.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcc/symb_others.c'\"
else
echo shar: Extracting \"'dcc/symb_others.c'\" \(18843 characters\)
sed "s/^X//" >'dcc/symb_others.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                        s y m b _ o t h e r s . c                        *
X *                                                                         *
X *                            Package : Compiler                           *
X *                            Version : 2.0                                *
X *                       CreationDate : 01.08.90                           *
X *                         LastUpDate : 02.12.93                           *
X *                                                                         *
X *         All other functions handling symbol table informations.         * 
X *                                                                         *
X *                  Portions Copyright 1990 Franz Distler                  *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include "config.h"
X#include "extern.h"
X#include "functions.h"
X#include "y.tab.h" 
X#include "com_Errno.h"
X
X/******************************************************************************
X * make_function()                                                            *
X *                                                                            *
X * Initializes the symbol table element pointed to by 'symbol' as function.   *
X *                                                                            *
X * Return values: 'symbol' upon success / NULL upon error                     *
X ******************************************************************************/
XSYMBTABEL *
Xmake_function(decl_spec, declarator)
XDS_ATTR *decl_spec;
XD_ATTR  *declarator;
X{
X    SYMBTABEL *symbol, *ptr;
X    DD_ATTR *dd_attr;
X
X    if (errflag || !decl_spec || !declarator) /* error handling */
X	return((SYMBTABEL *) Malloc(sizeof(SYMBTABEL)));
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** make_function(): params: symbol = %d\n",
X	symbol);
X#endif /* SYMBDEBUG /**/
X    symbol = NULL;
X    for(dd_attr = declarator->direct_decl; dd_attr; ) {
X	switch(dd_attr->type) {
X	case DD_ATTR_IDENT:
X    	    symbol = dd_attr->ident;
X	    dd_attr = NULL; /* leave loop! */
X	    break;
X	case DD_ATTR_BRACED:
X	    dd_attr = dd_attr->info.declarator->direct_decl;
X	    break;
X	case DD_ATTR_ARRAY:
X	case DD_ATTR_FUNC:
X	    dd_attr = dd_attr->info.comp.direct_decl;
X	    break;
X	default:
X	    Panic("unknown DD_ATTR type in make_function()");
X	} /* switch */
X    }
X    if (!symbol)
X	Panic("identifier of function definition not found!");
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb]       symbol->name = %s\n", symbol->name);
X#endif /* SYMBDEBUG /**/
X    if (symbol->type != UDEC) {
X	strcpy(yytext, symbol->name);
X	PRINTERROR("", EREDEFINITION);
X	return(symbol);
X    }
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb]       initializing \"%s\" as FUNCTIONDEF\n",
X	symbol->name);
X#endif /* SYMBDEBUG /**/
X    symbol->type = FUNCTIONDEF;
X    *convert_buffer = 0;
X    convert_buffer = convert_ds_to_string(convert_buffer, decl_spec);
X    symbol->info.functiondef.ReturnType = strsave(convert_buffer);
X    return(symbol);
X} /* make_function */
X
X/******************************************************************************
X * make_typedef_name()                                                        *
X *                                                                            *
X * Declares symbols in the symbol table as a typedef definition.              *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
Xmake_typedef_name(decl_spec, id_list)
XDS_ATTR  *decl_spec;
XIDL_ATTR *id_list;
X{
X    short pointerflag;
X    D_ATTR *d_attr;
X    DD_ATTR *dd_attr;
X    SYMBTABEL *symbol;
X
X    if (errflag)
X	return;
X#ifdef SYMBDEBUG 
X    fprintf(debugfile, "[symb] ***** make_typedef_name():\n");
X#endif /* SYMBDEBUG /**/
X    for(; id_list; id_list = id_list->id_list) {
X	d_attr = id_list->id->d;
X	pointerflag = (d_attr->pointer) ? TRUE : FALSE;
X	dd_attr = d_attr->direct_decl;
X	while(dd_attr->type != DD_ATTR_IDENT) {
X	    if (dd_attr->type == DD_ATTR_BRACED) {
X		d_attr = dd_attr->info.declarator;
X		pointerflag = (d_attr->pointer) ? TRUE : FALSE;
X		dd_attr = d_attr->direct_decl;
X	    } else 
X		dd_attr = dd_attr->info.comp.direct_decl;
X	}
X	symbol = dd_attr->ident;
X	if (symbol->type == STRUCTDECL) {
X	    /* the same identifier was used for a structure tag name
X	     * and a subsequent type definition, e. g. 
X	     * "typedef struct NAME { ... } NAME;".
X	     * In this case we must create a new symbol table element to
X	     * store the type definition.
X	     */
X#ifdef SYMBDEBUG
X	    fprintf(debugfile, "[symb]       identical identifier for structure tag name and type definition\n");
X	    fprintf(debugfile, "[symb]       creating new symbol table element for '%s'\n", 
X		symbol->name);
X	    symbol = enter_symbtabel(symbol->name);
X#endif /* SYMBDEBUG /**/
X	}
X	symbol->type = TYPEDEFNAME;
X	symbol->info.typedefname.IsPointer       = pointerflag;
X	symbol->info.typedefname.BuildXDRRoutine = FALSE;
X	symbol->info.typedefname.decl_spec       = decl_spec;
X	symbol->info.typedefname.id_list         = id_list;
X	symbol->info.typedefname.ErrPos          = strsave(yywhere());
X#ifdef SYMBDEBUG
X	fprintf(debugfile, "[symb]       type definition: '%s' is %sa pointer\n", 
X	    symbol->name, (pointerflag) ? "" : "NOT ");
X#endif /* SYMBDEBUG /**/
X	(void) store_struct_or_type_def(symbol);
X    } /* for(id_list) */
X    return(OK);
X} /* make_typedef_name */
X
X/******************************************************************************
X * make_structure()                                                           *
X *                                                                            *
X * Declares symbol in the symbol table as a structure definition.             *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
XSYMBTABEL *
Xmake_structure(symbol)
XSYMBTABEL *symbol;
X{
X    if (errflag || !symbol)
X	return(NULL);
X#ifdef SYMBDEBUG 
X    fprintf(debugfile, "[symb] ***** make_structure():\n");
X    fprintf(debugfile, "[symb]       symbol->name = %s\n", symbol->name);
X#endif /* SYMBDEBUG /**/
X    if (symbol->type != UDEC) {
X	strcpy(yytext, symbol->name);
X	PRINTERROR("", EREDEFINITION);
X	return(symbol);
X    }
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb]       initializing \"%s\" as STRUCTDECL\n",
X	symbol->name);
X#endif /* SYMBDEBUG /**/
X    symbol->type = STRUCTDECL;
X    symbol->info.structdecl.IsStruct        = FALSE;
X    symbol->info.structdecl.BuildXDRRoutine = FALSE;
X    symbol->info.structdecl.StruDeclList    = (STL_ATTR *) NULL;
X    symbol->info.structdecl.ErrPos          = strsave(yywhere());
X    (void) store_struct_or_type_def(symbol);
X    return(symbol);
X} /* make_structure */
X
X/******************************************************************************
X * add_struct_or_union_info()                                                 *
X *                                                                            *
X * Marks the symbol table entry with name 'tag' as structure definition and   *
X * adds some useful information.                                              *
X *                                                                            *
X * Return values: 'tag' upon success / NULL upon error                        *
X ******************************************************************************/
XSYMBTABEL *
Xadd_struct_or_union_info(struct_or_union, tag, struct_declaration_list)
XSU_ATTR   *struct_or_union;
XSYMBTABEL *tag;
XSTL_ATTR  *struct_declaration_list;
X{
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** add_struct_or_union_info():\n");
X    fprintf(debugfile, "[symb]       params: struct_or_union = %s\n",
X        (struct_or_union->type == SU_ATTR_STRUCT) ? "struct" : "union");
X    fprintf(debugfile, "[symb]               tag = %d\n", tag);
X    fprintf(debugfile, "[symb]               struct_declaration_list = %d\n",
X        struct_declaration_list);
X#endif /* SYMBDEBUG /**/
X    if (struct_or_union->type == SU_ATTR_STRUCT) 
X        tag->info.structdecl.IsStruct = TRUE;
X    else
X        tag->info.structdecl.IsStruct = FALSE;
X    tag->info.structdecl.BuildXDRRoutine = FALSE;
X    tag->info.structdecl.StruDeclList = struct_declaration_list;
X    return(tag);
X} /* add_struct_or_union_info */
X
X/******************************************************************************
X * mark_structures_for_XDR()                                                  *
X *                                                                            *
X * Marks the structure pointed to by 'sus_attr' and all structure and type    *
X * definitions inside of this structure definition indicating that these      *
X * definitions are used as a process parameter, transaction parameter or      *
X * transaction result type, so a corresponding xdr routine will be created.   *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xstatic int
Xmark_structures_for_XDR(typedef_symbol, sus_attr)
XSYMBTABEL *typedef_symbol;
XSUS_ATTR  *sus_attr;
X{
X    TS_ATTR   *ts_attr;
X    DS_ATTR   *ds_attr;
X    SUS_ATTR  *sus_attr_2;
X    ST_ATTR   *st_attr;
X    STL_ATTR  *stl_attr;
X    SQL_ATTR  *sql_attr;
X    SYMBTABEL *symbol, *symbol2;
X#ifdef CONVEX
X    int mark_typenames_for_XDR();
X#else
X    static int mark_typenames_for_XDR();
X#endif
X
X#if defined(SYMBDEBUG) || defined(XDRDEBUG)
X    fprintf(debugfile, "[symb] ***** mark_structures_for_XDR():\n");
X#endif /* SYMBDEBUG || XDRDEBUG /**/
X
X    /* check for error */
X    if (!sus_attr->tag) {
X	if (!typedef_symbol)
X	    Panic("'typedef_symbol' not defined in mark_structures_for_XDR()!");
X        Errno = ETSTRUCTTAG;
X        strcpy(yytext, typedef_symbol->name);
X        Error(typedef_symbol->info.typedefname.ErrPos, "");
X        return(ERROR);
X    }
X
X    /* initialize pointer to symbol table entry */
X    symbol = sus_attr->tag;   
X
X    /* mark structure symbol table entry */
X    symbol->info.structdecl.BuildXDRRoutine = TRUE;
X
X#if defined(SYMBDEBUG) || defined(XDRDEBUG)
X    fprintf(debugfile, "[symb]       marking structure \"%s\" for xdr\n",
X        symbol->name);   
X#endif /* SYMBDEBUG || XDRDEBUG /**/
X
X    /* Pass through the complete struct_declaration_list of the structure 
X     * pointer to by 'sus_attr'. Check the specifier_qualifier_lists of
X     * each struct_declaration if it contains a structure or a type 
X     * definition. If true, mark the corresponding definition for xdr and
X     * check all structure definitions inside this definition (if there are
X     * any).
X     */
X    for(stl_attr = symbol->info.structdecl.StruDeclList; stl_attr; stl_attr = stl_attr->st_list) {
X        st_attr = stl_attr->struct_decl;
X        for(sql_attr = st_attr->spec_qual_list; sql_attr; sql_attr = sql_attr->sq_list) {
X	    if (sql_attr->type == SQL_ATTR_SPECIFIER) {
X		ts_attr = sql_attr->info.type_specifier;
X		switch(ts_attr->type) {
X		case TS_ATTR_STRUCT:
X		    sus_attr_2 = ts_attr->info.structinfo;
X		    if (!sus_attr_2->tag) {
X			/* error: missing tag name! */
X		        Errno = EISTRUCTTAG;
X		        strcpy(yytext, symbol->name);
X		        Error(symbol->info.structdecl.ErrPos, "");
X		        return(ERROR);
X		    }
X		    if (sus_attr_2 != sus_attr) {
X			/* Structure definition inside this structure found! 
X		 	 * Mark the inner structure and all structure and type 
X			 * definitions inside the inner structure for building 
X			 * xdr routines.
X		 	 */
X		        (void) mark_structures_for_XDR(NULL, sus_attr_2);
X		    }
X		    break;
X		case TS_ATTR_TYPENAME:
X		    (void) mark_typenames_for_XDR(ts_attr->info.typedefname);
X		    break;
X		default:
X		    break;
X		} /* switch */
X            }
X        } /* for(sql_attr) */
X    } /* for(stl_attr) */
X
X    return(OK);
X} /* mark_structures_for_XDR */
X
X/******************************************************************************
X * mark_typenames_for_XDR()                                                   *
X *                                                                            *
X * Marks the type definition pointed to by 'typedef_symbol' and all structure *
X * and type definitions specified by this type definition indicating that     *
X * these definitions are used as a process parameter, transaction parameter or*
X * transaction result type, so a corresponding xdr routine will be created.   *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xstatic int
Xmark_typenames_for_XDR(typedef_symbol)
XSYMBTABEL *typedef_symbol;
X{
X    DS_ATTR   *decl_spec;
X    SYMBTABEL *symbol;
X
X#if defined(SYMBDEBUG) || defined(XDRDEBUG)
X    fprintf(debugfile, "[symb] ***** mark_typenames_for_XDR():\n");
X#endif /* SYMBDEBUG || XDRDEBUG /**/
X
X    /* mark typedefname symbol table entry */
X    typedef_symbol->info.typedefname.BuildXDRRoutine = TRUE;
X
X#if defined(SYMBDEBUG) || defined(XDRDEBUG)
X    fprintf(debugfile, "[symb]       marking typename \"%s\" for xdr\n", typedef_symbol->name);   
X#endif /* SYMBDEBUG || XDRDEBUG /**/
X
X    decl_spec = typedef_symbol->info.typedefname.decl_spec->ds;
X    if (decl_spec->ts) {
X        switch(decl_spec->ts->type) {
X        case TS_ATTR_STRUCT:
X	    /* Type definition contains a structure definition. Mark this 
X	     * structure and all structure and type definitions inside this 
X	     * structure for building xdr routines.
X	     */
X	    (void) mark_structures_for_XDR(symbol, decl_spec->ts->info.structinfo);
X	    break;
X        case TS_ATTR_TYPENAME:
X	    /* Type definition specifies a type definition by itself. Mark this 
X	     * type definition and all structure and type definitions specified
X	     * by this type definition for building xdr routines.
X	     */
X	    symbol = decl_spec->ts->info.typedefname;
X	    (void) mark_typenames_for_XDR(symbol);
X	    break;
X        default:
X	    break;
X        } /* switch */
X    }
X    return(OK);
X} /* mark_typenames_for_XDR */
X
X/******************************************************************************
X * mark_struct_or_type_def_for_XDR()                                          *
X *                                                                            *
X * Marks the structure or typename definition indicating that these definition*
X * is used as a process parameter, transaction parameter or transaction result*
X * type. Calls mark_structures_for_XDR() to mark all inner structure and type *
X * definitions, too, if required.                                             *
X *                                                                            *
X * Return values: 'ds_attr' upon success / NULL upon error                    *
X ******************************************************************************/
XDS_ATTR *
Xmark_struct_or_type_def_for_XDR(ds_attr)
XDS_ATTR *ds_attr;
X{
X    DS_ATTR *ds_ptr, *ds_attr2;
X    SUS_ATTR *sus_attr, *sus_attr_2;
X    ST_ATTR *st_attr;
X    STL_ATTR *stl_attr;
X    SQL_ATTR *sql_attr;
X    SYMBTABEL *symbol;
X
X#ifdef SYMBDEBUG
X    fprintf(debugfile, "[symb] ***** mark_struct_or_type_def_for_XDR():\n");
X    *convert_buffer = 0;
X    convert_buffer = convert_ds_to_string(convert_buffer, ds_attr);
X    fprintf(debugfile, "[symb]       checking \"%s\"\n", convert_buffer);
X#endif /* SYMBDEBUG /**/
X    /* check if the declaration_specifiers_attribute contains a structure
X     * or type definition.
X     */
X    for(ds_ptr = ds_attr; ds_ptr; ds_ptr = ds_ptr->ds) {
X	if (ds_ptr->ts) {
X	    switch(ds_ptr->ts->type) {
X	    case TS_ATTR_STRUCT:
X		/* Structure definition found! 
X		 * Mark this structure and all structure and type definitions 
X		 * inside this structure for building xdr routines.
X		 */
X		(void) mark_structures_for_XDR(NULL, ds_ptr->ts->info.structinfo);
X		break;
X	    case TS_ATTR_TYPENAME:
X		/* Type definition found! 
X		 * Mark this type definition and all structure and type 
X		 * definitions inside this type definition for building a 
X		 * xdr routine.
X		 */
X		symbol = ds_ptr->ts->info.typedefname;
X		(void) mark_typenames_for_XDR(symbol);
X		break;
X	    default:
X		break;
X	    } /* switch */
X	    break;
X	}
X    } /* for(ds_ptr) */
X    return(ds_attr);
X} /* mark_struct_or_type_def_for_XDR */
X
X/******************************************************************************
X * choose_void_type()                                                         *
X *                                                                            *
X * Converts the type 'void' to type 'int' if required.                        *
X *                                                                            *
X * Return values: pointer to string containing result type                    *
X ******************************************************************************/
Xchar
Xchoose_void_type()
X{
X    static char *ptr;
X
X#ifdef SYMBDEBUG
X    fputs("[symb] ***** choose_void_type():\n", debugfile);
X#endif /* SYMBDEBUG /**/
X    return(TS_ATTR_INT);
X} /* choose_void_type */
END_OF_FILE
if test 18843 -ne `wc -c <'dcc/symb_others.c'`; then
    echo shar: \"'dcc/symb_others.c'\" unpacked with wrong size!
fi
# end of 'dcc/symb_others.c'
fi
if test -f 'examples/config/system.FICT' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/config/system.FICT'\"
else
echo shar: Extracting \"'examples/config/system.FICT'\" \(20365 characters\)
sed "s/^X//" >'examples/config/system.FICT' <<'END_OF_FILE'
X# system.FICT
X#
X# System configuration file of a ficticious system
X# Christoph Pleier, March 1992
X#
X# The system has the following structure:
X#
X#      AT286 (5, 10) --|            5km           |-- HP_1    (0, 0)
X#      AT386 (2,  4) --|     <--------------->    |-- HP_2    (0, 0)
X#    AT386_2 (2,  4) --|--------------------------|-- SPARC_2 (1, 3)
X#    SPARC_1 (1,  3) --|             |            |-- SPARC_3 (1, 3)
X#       C220 (0,  0) --|             |            |-- AT486   (0, 2)
X#                                    | ^      
X#                                    | |
X#                                    | | 
X#                                    | | 100km           
X#                                    |  ----------->       |-- Sun3_1  (2, 5)
X#                                     ---------------------|-- Sun3_2  (2, 5)
X#                                                          |-- SPARC_4 (1, 3)
X#                                                          |-- C3840   (0, 0)
X#
X# AT286 (5, 10) means: 
X#     computer: AT 286, creation factor: 5, communication factor: 10
X
X# definition of all hostnames
Xhostnames = {
X    node_AT286, node_AT386, node_AT386_2, node_AT486,
X    node_SPARC_1, node_SPARC_2, node_SPARC_3, node_SPARC_4, 
X    node_Sun3_1, node_Sun3_2,
X    node_HP_1, node_HP_2,
X    node_C220, node_C3840
X} # hostnames
X
X# definition of all computer types
Xcomputer types = {
X    AT286, 	# Intel ATi286
X    AT386, 	# Intel ATi386
X    AT486, 	# Intel ATi486
X    SPARC,	# Sun SPARC Station
X    Sun3, 	# Sun 3 Workstation
X    HP730, 	# Hewlett Packard 9000/730
X    C220, 	# CONVEX C220
X    C3840	# CONVEX C3840
X} # computer types
X
X# definition of all UNIX variants
Xoperating system variants = { 
X    SCO_UNIX, SCO_XENIX, SunOS, HPUX, ConvexOS
X}
X
X# definition of the fixed disks 
Xfixed disks = {
X    AT286disk = {
X        location : node_AT286
X	size     : 60 MB
X	speed    : 20 ms
X    }
X    AT386disk = {
X        location : node_AT386
X	size     : 150 MB
X	speed    : 15 ms
X    }
X    AT386disk2 = {
X        location : node_AT386_2
X	size     : 600 MB
X	speed    : 12 ms
X    }
X    AT486disk = {
X        location : node_AT486
X	size     : 150 MB
X	speed    : 10 ms
X    }
X    SUNdisk1 = {
X        location : node_SPARC_1
X	size     : 1 GB
X	speed    : 11 ms
X    }
X    SUNdisk2 = {
X        location : node_SPARC_4
X	size     : 1 GB
X	speed    : 15 ms
X    }
X    SUNdisk3 = {
X        location : node_Sun3_1
X	size     : 500 MB
X	speed    : 15 ms
X    }
X    SUNdisk4 = {
X        location : node_Sun3_2
X	size     : 500 MB
X	speed    : 15 ms
X    }
X    HPdisk = {
X        location : node_HP_1
X	size     : 1 GB
X	speed    : 15 ms
X    }
X    C220disk = {
X        location : node_C220
X	size     : 1 GB
X	speed    : 8 ms
X    }
X    C3840disk = {
X        location : node_C3840
X	size     : 10 GB
X	speed    : 6 ms
X    }
X}
X
X# definition of host node_AT286
Xhost node_AT286 = {
X    operating system : SCO_XENIX
X
X    computer specification {
X	type: 			 AT286
X	physical memory: 	 2 MB
X	virtual memory: 	 4 MB
X	performance index:	 0.0091
X	storage for executables: AT286disk
X    }
X
X    peripheral devices = {
X	PS_HP1, PS_HP2
X    }
X
X    compilation {
X        target: AT286 (SCO_XENIX) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSCO_XENIX -DSYSTEM_V -DMSGSEM -DSINGLE -compat"
X	    LDFLAGS = ""
X	    LIBS    = "-lx"
X	}
X    }
X
X    accessible filesystems = {
X	AT286disk (20 ms)
X    }
X} # node_AT286
X
X# definition of host node_AT386
Xhost node_AT386 = {
X    operating system : SCO_XENIX
X
X    computer specification {
X	type: 			 AT386
X	physical memory: 	 8 MB
X	virtual memory: 	 10 MB
X	performance index:	 0.16
X	storage for executables: AT386disk
X    }
X
X    peripheral devices = {
X	PS_HP1, PS_HP2
X    }
X
X    compilation {
X        target: AT286 (SCO_XENIX) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSCO_XENIX -DSYSTEM_V -DMSGSEM -DSINGLE -compat -x2.3"
X	    LDFLAGS = ""
X	    LIBS    = "-lx"
X	}
X        target: AT386 (SCO_XENIX) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSCO_XENIX -DSYSTEM_V -DMSGSEM -DSINGLE"
X	    LDFLAGS = ""
X	    LIBS    = "-lx"
X	}
X    }
X
X    accessible filesystems = {
X	AT386disk (15 ms)
X    }
X} # node_AT386
X
X# definition of host node_AT386_2
Xhost node_AT386_2 = {
X    operating system : SCO_UNIX
X
X    computer specification {
X	type: 			 AT386
X	physical memory: 	 8 MB
X	virtual memory: 	 10 MB
X	performance index:	 0.16
X	storage for executables: AT386disk2
X    }
X
X    peripheral devices = {
X	PS_HP1, PS_HP2
X    }
X
X    compilation {
X        target: AT286 (SCO_XENIX) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSCO_XENIX -DSYSTEM_V -DMSGSEM -DHETEROGENEOUS -compat -xenix -x2.3 -D__STDC__"
X	    LDFLAGS = ""
X	    LIBS    = "-lx"
X	}
X        target: AT386 (SCO_XENIX) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSCO_XENIX -DSYSTEM_V -DMSGSEM -DHETEROGENEOUS -compat -xenix -x2.3 -D__STDC__"
X	    LDFLAGS = ""
X	    LIBS    = "-lx"
X	}
X        target: AT386 (SCO_UNIX) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSCO_UNIX -DSYSTEM_V -DMSGSEM -DHETEROGENEOUS"
X	    LDFLAGS = ""
X	    LIBS    = "-lx"
X	}
X        target: AT486 (SCO_UNIX) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSCO_UNIX -DSYSTEM_V -DMSGSEM -DHETEROGENEOUS"
X	    LDFLAGS = ""
X	    LIBS    = "-lx"
X	}
X    }
X
X    accessible filesystems = {
X	AT386disk2 (12 ms)
X    }
X} # node_AT386_2
X
X# definition of host node_AT486
Xhost node_AT486 = {
X    operating system : SCO_UNIX
X
X    computer specification {
X	type: 			 AT486
X	physical memory: 	 32 MB
X	virtual memory: 	 40 MB
X	performance index:	 1.3
X	storage for executables: AT486disk
X    }
X
X    peripheral devices = {
X	LC890
X    }
X
X    compilation {
X        target: AT286 (SCO_XENIX) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSCO_XENIX -DSYSTEM_V -DMSGSEM -DHETEROGENEOUS -compat -xenix -x2.3 -D__STDC__"
X	    LDFLAGS = ""
X	    LIBS    = "-lx"
X	}
X        target: AT386 (SCO_XENIX) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSCO_XENIX -DSYSTEM_V -DMSGSEM -DHETEROGENEOUS -compat -xenix -x2.3 -D__STDC__"
X	    LDFLAGS = ""
X	    LIBS    = "-lx"
X	}
X        target: AT386 (SCO_UNIX) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSCO_UNIX -DSYSTEM_V -DMSGSEM -DHETEROGENEOUS"
X	    LDFLAGS = ""
X	    LIBS    = "-lx"
X	}
X        target: AT486 (SCO_UNIX) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSCO_UNIX -DSYSTEM_V -DMSGSEM -DHETEROGENEOUS"
X	    LDFLAGS = ""
X	    LIBS    = "-lx"
X	}
X    }
X
X    accessible filesystems = {
X	AT486disk (10 ms), SUNdisk1 (40 ms)
X    }
X} # node_AT486
X
X# definition of host node_SPARC_1
Xhost node_SPARC_1 = {
X    operating system : SunOS
X
X    computer specification {
X	type: 			 SPARC
X	physical memory: 	 16 MB
X	virtual memory: 	 32 MB
X	performance index:	 4.0
X	storage for executables: SUNdisk1
X    }
X
X    peripheral devices = {
X	PS_HP1, PS_HP2
X    }
X
X    compilation {
X        target: SPARC (SunOS) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSPARC -DBSD -DSOCKET -DHETEROGENEOUS"
X	    LDFLAGS = ""
X	    LIBS    = ""
X	}
X        target: Sun3 (SunOS) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSPARC -DBSD -DSOCKET -DHETEROGENEOUS -target sun3"
X	    LDFLAGS = ""
X	    LIBS    = ""
X	}
X    }
X
X    accessible filesystems = {
X	SUNdisk1 (11 ms)
X    }
X} # node_SPARC_1
X
X# definition of host node_SPARC_2
Xhost node_SPARC_2 = {
X    operating system : SunOS
X
X    computer specification {
X	type: 			 SPARC
X	physical memory: 	  8 MB
X	virtual memory: 	 32 MB
X	performance index:	 4.0
X	storage for executables: HPdisk
X    }
X
X    peripheral devices = {
X	LC890
X    }
X
X    compilation {
X        target: SPARC (SunOS) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSPARC -DBSD -DSOCKET -DHETEROGENEOUS"
X	    LDFLAGS = ""
X	    LIBS    = ""
X	}
X        target: Sun3 (SunOS) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSPARC -DBSD -DSOCKET -DHETEROGENEOUS -target sun3"
X	    LDFLAGS = ""
X	    LIBS    = ""
X	}
X    }
X
X    accessible filesystems = {
X	HPdisk (25 ms)
X    }
X} # node_SPARC_2
X
X# definition of host node_SPARC_3
Xhost node_SPARC_3 = {
X    operating system : SunOS
X
X    computer specification {
X	type: 			 SPARC
X	physical memory: 	  8 MB
X	virtual memory: 	 32 MB
X	performance index:	 4.0
X	storage for executables: HPdisk
X    }
X
X    peripheral devices = {
X	LC890
X    }
X
X    compilation {
X        target: SPARC (SunOS) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSPARC -DBSD -DSOCKET -DHETEROGENEOUS"
X	    LDFLAGS = ""
X	    LIBS    = ""
X	}
X        target: Sun3 (SunOS) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSPARC -DBSD -DSOCKET -DHETEROGENEOUS -target sun3"
X	    LDFLAGS = ""
X	    LIBS    = ""
X	}
X    }
X
X    accessible filesystems = {
X	HPdisk (25 ms)
X    }
X} # node_SPARC_3
X
X# definition of host node_SPARC_4
Xhost node_SPARC_4 = {
X    operating system : SunOS
X
X    computer specification {
X	type: 			 SPARC
X	physical memory: 	 16 MB
X	virtual memory: 	 32 MB
X	performance index:	 4.0
X	storage for executables: SUNdisk2
X    }
X
X    compilation {
X        target: SPARC (SunOS) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSPARC -DBSD -DSOCKET -DHETEROGENEOUS"
X	    LDFLAGS = ""
X	    LIBS    = ""
X	}
X        target: Sun3 (SunOS) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSPARC -DBSD -DSOCKET -DHETEROGENEOUS -target sun3"
X	    LDFLAGS = ""
X	    LIBS    = ""
X	}
X    }
X
X    accessible filesystems = {
X	SUNdisk2 (15 ms)
X    }
X} # node_SPARC_4
X
X# definition of host node_Sun3_1
Xhost node_Sun3_1 = {
X    operating system : SunOS
X
X    computer specification {
X	type: 			 Sun3
X	physical memory: 	  4 MB
X	virtual memory: 	 16 MB
X	performance index:	 0.46
X	storage for executables: SUNdisk3
X    }
X
X    compilation {
X        target: SPARC (SunOS) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSPARC -DBSD -DSOCKET -DHETEROGENEOUS -target sun4"
X	    LDFLAGS = ""
X	    LIBS    = ""
X	}
X        target: Sun3 (SunOS) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSPARC -DBSD -DSOCKET -DHETEROGENEOUS"
X	    LDFLAGS = ""
X	    LIBS    = ""
X	}
X    }
X
X    accessible filesystems = {
X	SUNdisk3 (15 ms), SUNdisk2 (25 ms), C3840disk (21 ms)
X    }
X} # node_Sun3_1
X
X# definition of host node_Sun3_2
Xhost node_Sun3_2 = {
X    operating system : SunOS
X
X    computer specification {
X	type: 			 Sun3
X	physical memory: 	  4 MB
X	virtual memory: 	 16 MB
X	performance index:	 0.46
X	storage for executables: SUNdisk4
X    }
X
X    compilation {
X        target: SPARC (SunOS) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSPARC -DBSD -DSOCKET -DHETEROGENEOUS -target sun4"
X	    LDFLAGS = ""
X	    LIBS    = ""
X	}
X        target: Sun3 (SunOS) {
X	    CC      = "cc"
X	    CFLAGS  = "-DSPARC -DBSD -DSOCKET -DHETEROGENEOUS"
X	    LDFLAGS = ""
X	    LIBS    = ""
X	}
X    }
X
X    accessible filesystems = {
X	SUNdisk4 (15 ms), SUNdisk2 (25 ms), C3840disk (21 ms)
X    }
X} # node_Sun3_2
X
X# definition of host node_HP_1
Xhost node_HP_1 = {
X    operating system : HPUX
X
X    computer specification {
X	type: 			 HP730
X	physical memory: 	 64 MB
X	virtual memory: 	 64 MB
X	performance index:	 24
X	storage for executables: HPdisk
X    }
X
X    peripheral devices = {
X	LC890
X    }
X
X    compilation {
X        target: HP730 (HPUX) {
X	    CC      = "cc"
X	    CFLAGS  = "-DHPUX -DSYSTEM_V -DSOCKET -DHETEROGENEOUS"
X	    LDFLAGS = ""
X	    LIBS    = ""
X	}
X    }
X
X    accessible filesystems = {
X	HPdisk (10 ms)
X    }
X} # node_HP_1
X
X# definition of host node_HP_2
Xhost node_HP_2 = {
X    operating system : HPUX
X
X    computer specification {
X	type: 			 HP730
X	physical memory: 	 64 MB
X	virtual memory: 	 64 MB
X	performance index:	 24
X	storage for executables: HPdisk
X    }
X
X    peripheral devices = {
X	LC890
X    }
X
X    compilation {
X        target: HP730 (HPUX) {
X	    CC      = "cc"
X	    CFLAGS  = "-DHPUX -DSYSTEM_V -DSOCKET -DHETEROGENEOUS"
X	    LDFLAGS = ""
X	    LIBS    = ""
X	}
X    }
X
X    accessible filesystems = {
X	HPdisk (10 ms)
X    }
X} # node_HP_2
X
X# definition of host node_C220
Xhost node_C220 = {
X    operating system : ConvexOS
X
X    computer specification {
X	type: 			 C220
X	physical memory: 	 512 MB
X	virtual memory: 	 512 MB
X	performance index:	 22
X	multiprocessor system: 2 processors, shared memory
X	vector computer
X	parallelizing compiler
X	storage for executables: C220disk
X    }
X
X    compilation {
X        target: C220 (ConvexOS) {
X	    CC      = "cc"
X	    CFLAGS  = "-DCONVEX -DBSD -DSOCKET -DHETEROGENEOUS -ext"
X	    LDFLAGS = "-ext"
X	    LIBS    = ""
X	}
X    }
X
X    accessible filesystems = {
X	C220disk (8 ms)
X    }
X} # node_C220
X
X# definition of host node_C3840
Xhost node_C3840 = {
X    operating system : ConvexOS
X
X    computer specification {
X	type: 			 C3840
X	physical memory: 	 1 GB
X	virtual memory: 	 1 GB
X	performance index:	 75
X	multiprocessor system: 8 processors, shared memory
X	vector computer
X	parallelizing compiler
X	storage for executables: C3840disk
X    }
X
X    compilation {
X        target: C3840 (ConvexOS) {
X	    CC      = "cc"
X	    CFLAGS  = "-DCONVEX -DBSD -DSOCKET -DHETEROGENEOUS -ext"
X	    LDFLAGS = "-ext"
X	    LIBS    = ""
X	}
X    }
X
X    accessible filesystems = {
X	C3840disk (6 ms) 
X    }
X} # node_C3840
X
X# definition of priority lists for cross compilation
Xcompilation hosts priority lists {
X    AT286   : node_AT486
X    AT386   : node_AT486
X    SPARC   : node_SPARC_1, node_SPARC_4
X#    general : node_C3840, node_C220, node_SPARC_1, node_AT486 
X} # compilation hosts priority lists
X
X# definition of the cost informations
X
Xcosts informations {
X
X	node_AT286	-> node_AT286	:  0,  20
X	node_AT286	-> node_AT386	:  2,  16
X	node_AT286	-> node_AT386_2	:  2,  16
X	node_AT286	-> node_AT486	:  2,  16
X	node_AT286	-> node_SPARC_1	:  1,  15
X	node_AT286	-> node_SPARC_2	:  3,  17
X	node_AT286	-> node_SPARC_3	:  3,  17
X	node_AT286	-> node_SPARC_4	: 11,  33
X	node_AT286	-> node_Sun3_1	: 12,  35
X	node_AT286	-> node_Sun3_2	: 12,  35
X	node_AT286	-> node_HP_1	:  2,  14
X	node_AT286	-> node_HP_2	:  2,  14
X	node_AT286	-> node_C220	:  0,  10
X	node_AT286	-> node_C3840	: 10,  30
X
X	node_AT386	-> node_AT286	:  5,  16
X	node_AT386	-> node_AT386	:  0,   8
X	node_AT386	-> node_AT386_2	:  2,  10
X	node_AT386	-> node_AT486	:  2,  10
X	node_AT386	-> node_SPARC_1	:  1,   9
X	node_AT386	-> node_SPARC_2	:  3,  11
X	node_AT386	-> node_SPARC_3	:  3,  11
X	node_AT386	-> node_SPARC_4	: 11,  27
X	node_AT386	-> node_Sun3_1	: 12,  29
X	node_AT386	-> node_Sun3_2	: 12,  29
X	node_AT386	-> node_HP_1	:  2,   8
X	node_AT386	-> node_HP_2	:  2,   8 
X	node_AT386	-> node_C220	:  0,   6
X	node_AT386	-> node_C3840	: 10,  24
X
X	node_AT386_2	-> node_AT286	:  5,  16
X	node_AT386_2	-> node_AT386	:  2,  10
X	node_AT386_2	-> node_AT386_2	:  0,   8
X	node_AT386_2	-> node_AT486	:  2,  10
X	node_AT386_2	-> node_SPARC_1	:  1,   9
X	node_AT386_2	-> node_SPARC_2	:  3,  11
X	node_AT386_2	-> node_SPARC_3	:  3,  11
X	node_AT386_2	-> node_SPARC_4	: 11,  27
X	node_AT386_2	-> node_Sun3_1	: 12,  29
X	node_AT386_2	-> node_Sun3_2	: 12,  29
X	node_AT386_2	-> node_HP_1	:  2,   8
X	node_AT386_2	-> node_HP_2	:  2,   8
X	node_AT386_2	-> node_C220	:  0,   6
X	node_AT386_2	-> node_C3840	: 10,  24
X
X	node_AT486	-> node_AT286	:  5,  16
X	node_AT486	-> node_AT386	:  4,  10
X	node_AT486	-> node_AT386_2	:  4,  10
X	node_AT486	-> node_AT486	:  0,   4
X	node_AT486	-> node_SPARC_1	:  3,   9
X	node_AT486	-> node_SPARC_2	:  1,   7
X	node_AT486	-> node_SPARC_3	:  1,   7
X	node_AT486	-> node_SPARC_4	: 11,  25
X	node_AT486	-> node_Sun3_1	: 12,  27
X	node_AT486	-> node_Sun3_2	: 12,  27
X	node_AT486	-> node_HP_1	:  0,   4
X	node_AT486	-> node_HP_2	:  0,   4
X	node_AT486	-> node_C220	:  2,   6
X	node_AT486	-> node_C3840	: 10,  22
X
X	node_SPARC_1	-> node_AT286	:  5,  15
X	node_SPARC_1	-> node_AT386	:  2,   9
X	node_SPARC_1	-> node_AT386_2	:  2,   9
X	node_SPARC_1	-> node_AT486	:  2,   9
X	node_SPARC_1	-> node_SPARC_1	:  0,   6
X	node_SPARC_1	-> node_SPARC_2	:  3,  10
X	node_SPARC_1	-> node_SPARC_3	:  3,  10
X	node_SPARC_1	-> node_SPARC_4	: 11,  26
X	node_SPARC_1	-> node_Sun3_1	: 12,  28
X	node_SPARC_1	-> node_Sun3_2	: 12,  28
X	node_SPARC_1	-> node_HP_1	:  2,   7
X	node_SPARC_1	-> node_HP_2	:  2,   7
X	node_SPARC_1	-> node_C220	:  0,   5
X	node_SPARC_1	-> node_C3840	: 10,  23
X
X	node_SPARC_2	-> node_AT286	:  7,  17
X	node_SPARC_2	-> node_AT386	:  4,  11
X	node_SPARC_2	-> node_AT386_2	:  4,  11
X	node_SPARC_2	-> node_AT486	:  0,   7
X	node_SPARC_2	-> node_SPARC_1	:  3,  10
X	node_SPARC_2	-> node_SPARC_2	:  0,   6
X	node_SPARC_2	-> node_SPARC_3	:  1,   8
X	node_SPARC_2	-> node_SPARC_4	: 11,  26
X	node_SPARC_2	-> node_Sun3_1	: 12,  28
X	node_SPARC_2	-> node_Sun3_2	: 12,  28
X	node_SPARC_2	-> node_HP_1	:  0,   5
X	node_SPARC_2	-> node_HP_2	:  0,   5
X	node_SPARC_2	-> node_C220	:  2,   7
X	node_SPARC_2	-> node_C3840	: 10,  23
X
X	node_SPARC_3	-> node_AT286	:  7,  17
X	node_SPARC_3	-> node_AT386	:  4,  11
X	node_SPARC_3	-> node_AT386_2	:  4,  11
X	node_SPARC_3	-> node_AT486	:  0,   7
X	node_SPARC_3	-> node_SPARC_1	:  3,  10
X	node_SPARC_3	-> node_SPARC_2	:  1,   8
X	node_SPARC_3	-> node_SPARC_3	:  0,   6
X	node_SPARC_3	-> node_SPARC_4	: 11,  26
X	node_SPARC_3	-> node_Sun3_1	: 12,  28
X	node_SPARC_3	-> node_Sun3_2	: 12,  28
X	node_SPARC_3	-> node_HP_1	:  0,   5
X	node_SPARC_3	-> node_HP_2	:  0,   5
X	node_SPARC_3	-> node_C220	:  2,   7
X	node_SPARC_3	-> node_C3840	: 10,  23
X
X	node_SPARC_4	-> node_AT286	: 15,  33
X	node_SPARC_4	-> node_AT386	: 12,  27
X	node_SPARC_4	-> node_AT386_2	: 12,  27
X	node_SPARC_4	-> node_AT486	: 10,  25
X	node_SPARC_4	-> node_SPARC_1	: 11,  26
X	node_SPARC_4	-> node_SPARC_2	: 11,  26
X	node_SPARC_4	-> node_SPARC_3	: 11,  26
X	node_SPARC_4	-> node_SPARC_4	:  1,   6
X	node_SPARC_4	-> node_Sun3_1	:  2,  10
X	node_SPARC_4	-> node_Sun3_2	:  2,  10
X	node_SPARC_4	-> node_HP_1	: 10,  23
X	node_SPARC_4	-> node_HP_2	: 10,  23
X	node_SPARC_4	-> node_C220	: 10,  23
X	node_SPARC_4	-> node_C3840	:  0,   5
X
X	node_Sun3_1	-> node_AT286	: 15,  35
X	node_Sun3_1	-> node_AT386	: 12,  29
X	node_Sun3_1	-> node_AT386_2	: 12,  29
X	node_Sun3_1	-> node_AT486	: 10,  27
X	node_Sun3_1	-> node_SPARC_1	: 11,  28
X	node_Sun3_1	-> node_SPARC_2	: 11,  28
X	node_Sun3_1	-> node_SPARC_3	: 11,  28
X	node_Sun3_1	-> node_SPARC_4	:  1,  10
X	node_Sun3_1	-> node_Sun3_1	:  0,  10
X	node_Sun3_1	-> node_Sun3_2	:  2,  12
X	node_Sun3_1	-> node_HP_1	: 10,  25
X	node_Sun3_1	-> node_HP_2	: 10,  25
X	node_Sun3_1	-> node_C220	: 10,  25
X	node_Sun3_1	-> node_C3840	:  0,   5
X
X	node_Sun3_2	-> node_AT286	: 15,  35
X	node_Sun3_2	-> node_AT386	: 12,  29
X	node_Sun3_2	-> node_AT386_2	: 12,  29
X	node_Sun3_2	-> node_AT486	: 10,  27
X	node_Sun3_2	-> node_SPARC_1	: 11,  28
X	node_Sun3_2	-> node_SPARC_2	: 11,  28
X	node_Sun3_2	-> node_SPARC_3	: 11,  28
X	node_Sun3_2	-> node_SPARC_4	:  1,  10
X	node_Sun3_2	-> node_Sun3_1	:  2,  12
X	node_Sun3_2	-> node_Sun3_2	:  0,  10
X	node_Sun3_2	-> node_HP_1	: 10,  25
X	node_Sun3_2	-> node_HP_2	: 10,  25
X	node_Sun3_2	-> node_C220	: 10,  25
X	node_Sun3_2	-> node_C3840	:  0,   5
X
X	node_HP_1	-> node_AT286	:  7,  14
X	node_HP_1	-> node_AT386	:  4,   8
X	node_HP_1	-> node_AT386_2	:  4,   8
X	node_HP_1	-> node_AT486	:  0,   4
X	node_HP_1	-> node_SPARC_1	:  3,   7
X	node_HP_1	-> node_SPARC_2	:  1,   5
X	node_HP_1	-> node_SPARC_3	:  1,   5
X	node_HP_1	-> node_SPARC_4	: 11,  23
X	node_HP_1	-> node_Sun3_1	: 12,  25
X	node_HP_1	-> node_Sun3_2	: 12,  25
X	node_HP_1	-> node_HP_1	:  0,   0
X	node_HP_1	-> node_HP_2	:  0,   2
X	node_HP_1	-> node_C220	:  2,   4
X	node_HP_1	-> node_C3840	: 10,  20
X
X	node_HP_2	-> node_AT286	:  7,  14
X	node_HP_2	-> node_AT386	:  4,   8
X	node_HP_2	-> node_AT386_2	:  4,   8
X	node_HP_2	-> node_AT486	:  0,   4
X	node_HP_2	-> node_SPARC_1	:  3,   7
X	node_HP_2	-> node_SPARC_2	:  1,   5
X	node_HP_2	-> node_SPARC_3	:  1,   5
X	node_HP_2	-> node_SPARC_4	: 11,  23
X	node_HP_2	-> node_Sun3_1	: 12,  25
X	node_HP_2	-> node_Sun3_2	: 12,  25
X	node_HP_2	-> node_HP_1	:  0,   2
X	node_HP_2	-> node_HP_2	:  0,   0
X	node_HP_2	-> node_C220	:  2,   4
X	node_HP_2	-> node_C3840	: 10,  20
X
X	node_C220	-> node_AT286	:  5,  10
X	node_C220	-> node_AT386	:  2,   6
X	node_C220	-> node_AT386_2	:  2,   6
X	node_C220	-> node_AT486	:  2,   6
X	node_C220	-> node_SPARC_1	:  1,   5
X	node_C220	-> node_SPARC_2	:  3,   7
X	node_C220	-> node_SPARC_3	:  3,   7
X	node_C220	-> node_SPARC_4	: 11,  23
X	node_C220	-> node_Sun3_1	: 12,  25
X	node_C220	-> node_Sun3_2	: 12,  25
X	node_C220	-> node_HP_1	:  2,   4
X	node_C220	-> node_HP_2	:  2,   4
X	node_C220	-> node_C220	:  0,   0
X	node_C220	-> node_C3840	: 10,  20
X
X	node_C3840	-> node_AT286	: 15,  30
X	node_C3840	-> node_AT386	: 12,  24
X	node_C3840	-> node_AT386_2	: 12,  24
X	node_C3840	-> node_AT486	: 10,  22
X	node_C3840	-> node_SPARC_1	: 11,  23
X	node_C3840	-> node_SPARC_2	: 11,  23
X	node_C3840	-> node_SPARC_3	: 11,  23
X	node_C3840	-> node_SPARC_4	:  1,   5
X	node_C3840	-> node_Sun3_1	:  2,   5
X	node_C3840	-> node_Sun3_2	:  2,   5
X	node_C3840	-> node_HP_1	: 10,  20
X	node_C3840	-> node_HP_2	: 10,  20
X	node_C3840	-> node_C220	: 10,  20
X	node_C3840	-> node_C3840	:  0,   0
X
X} # cost informations
END_OF_FILE
if test 20365 -ne `wc -c <'examples/config/system.FICT'`; then
    echo shar: \"'examples/config/system.FICT'\" unpacked with wrong size!
fi
# end of 'examples/config/system.FICT'
fi
if test -f 'lib/ipc_iPSC.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib/ipc_iPSC.c'\"
else
echo shar: Extracting \"'lib/ipc_iPSC.c'\" \(21990 characters\)
sed "s/^X//" >'lib/ipc_iPSC.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                          i p c _ i P S C . c                            *
X *                                                                         *
X *                            Package : Runtime Library                    *
X *                            Version : 1.0                                *
X *                       CreationDate : 01.09.90                           *
X *                         LastUpDate : 15.10.90                           *
X *                                                                         *
X * This file contains the hardware dependent routines building the message *
X * passing layer for the iPSC Intel Hypercube.                             *
X *                                                                         *
X *        Copyright (C) 1990-1994 by Christoph and Markus Pleier.          *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <signal.h>
X#include <errno.h>
X#include "cube.h"
X#include "ipc_iPSC.h"
X#include "run_Errno.h"
X
X#define DEBUG_IPC /**/
X
X/* the used external variables */
Xextern int   errno, 		/* system error code */
X             Errno,		/* function error code */
X             _debugflush;	/* flush debug messages or not */
Xextern char *sys_errlist[],	/* system error messages */
X             *_programname,	/* name of program */
X             *_processname,	/* name of process */
X             *_processprefix;	/* process specifying string */
Xextern FILE  *_debugout;	/* where to write the debug messages */
X
X/* the timeout variables */
Xstatic int  timeout_flag;
Xstatic long timeout_type,
X            timeout_msg;
X
X#ifdef DEBUG_IPC
X/* the flag to control the debug messages output */
Xint _debug_ipc = 0;
X#endif /* DEBUG_IPC /**/
X
X#define SETTIMER(time, type)	timeout_flag = FALSE; \
X				timeout_msg = type; \
X    				signal(SIGALRM, timeout_proc); \
X    				(void) alarm(time)
X
X#ifdef DEBUG_IPC
X# define DEBUGPUTS(msg)		if (_debug_ipc) { \
X				    fprintf(_debugout, "[ipc] %s %s\n", \
X				        _processprefix, msg); \
X				    if (_debugflush) \
X				        fflush(_debugout); \
X				}
X# define DEBUGDISPERR(msg)	if (_debug_ipc) { \
X				    fprintf(_debugout, "[ipc] %s error: %s\n", \
X				        _processprefix, msg); \
X				    fprintf(_debugout, "[ipc] %s reason: %s\n",\
X				        _processprefix, sys_errlist[errno]); \
X				    if (_debugflush) \
X				        fflush(_debugout); \
X				}
X#else
X# define DEBUGPUTS(msg)		{ /* nothing */ }
X# define DEBUGDISPERR(msg)	{ /* nothing */ }
X#endif
X
X/******************************************************************************
X * timeout_proc()                                                             *
X *                                                                            *
X * Sets the timeout flag 'timeout' to indicate a timeout error.               *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xstatic int
Xtimeout_proc()
X{
X    static char buf[10];
X
X#ifdef DEBUG_IPC
X    if (_debug_ipc) {
X        fprintf(_debugout, "[ipc] %s ***** timeout_proc():\n", _processprefix);
X        fprintf(_debugout, "[ipc] %s timeout_type = %s\n", _processprefix,
X	    (timeout_type == TIMER_NOMSG) ? "TIMER_NOMSG" : "TIMER_RECV");
X        fprintf(_debugout, "[ipc] %s timeout_msg  = %ld\n", _processprefix, 
X	    timeout_msg);
X    }
X#endif /* DEBUG_IPC /**/
X    timeout_flag = TRUE;
X    switch(timeout_type) {
X    case TIMER_NOMSG:
X	break;
X    case TIMER_RECV:
X        csend(timeout_msg, buf, 0, mynode(), mypid());
X	break;
X    default:
X	fprintf(stderr, "%s Panic: unknown timeout_type in timeout_proc()\n",
X	    _processprefix);
X#ifdef DEBUG_IPC
X	if (_debug_ipc && _debugout != stderr) 
X	    fprintf(_debugout, "%s Panic: unknown timeout_type in timeout_proc()\n",
X	        _processprefix);
X#endif /* DEBUG_IPC /**/
X	exit(-1);
X    } /* switch */
X} /* timeout_proc */
X
X/******************************************************************************
X * _create_port()                                                             *
X *                                                                            *
X * Creates a new communication endpoint:                                      *
X * Initialize the port variable specified by 'port'.                          *
X *                                                                            *
X * Return values: OK = success / ERROR = error                                *
X ******************************************************************************/
Xint
X_create_port(port)
XPORTDESCR *port;
X{
X#ifdef DEBUG_IPC
X    if (_debug_ipc) {
X        fprintf(_debugout, "[ipc] %s ***** _create_port():\n", _processprefix);
X        fprintf(_debugout, "[ipc] %s params: &port = %d\n", _processprefix, 
X	    port);
X	if (_debugflush)
X	    fflush(_debugout);
X    }
X#endif /* DEBUG_IPC /**/
X    /* set Errno */
X    Errno = ECREATEPORT;
X    /* initialize port */
X    if ((port->node = mynode()) < 0) {
X	DEBUGDISPERR("No node defined");
X	return(ERROR);
X    }
X    if ((port->pid  = mypid()) < 0) {
X	DEBUGDISPERR("No pid defined");
X	return(ERROR);
X    }
X    return(OK);
X} /* _create_port */
X
X/******************************************************************************
X * _delete_port()                                                             *
X *                                                                            *
X * Deletes the communication endpoint specified by 'port':                    *
X * there is nothing to do for iPSC!                                           *
X *                                                                            *
X * Return values: always OK for success                                       *
X ******************************************************************************/
Xint
X_delete_port(port)
XPORTDESCR *port;
X{
X#ifdef DEBUG_IPC
X    if (_debug_ipc) {
X        fprintf(_debugout, "[ipc] %s ***** _delete_port():\n", _processprefix);
X        fprintf(_debugout, "[ipc] %s params: port = (node = %ld, pid = %ld)\n", 
X	    _processprefix, port->node, port->pid);
X    }
X#endif /* DEBUG_IPC /**/
X    return(OK);
X} /* _delete_port */
X
X/******************************************************************************
X * _accept_connection()                                                       *
X *                                                                            *
X * Communication endpoint 'port' waits 'time' real time seconds for a         *
X * connection request (if 'time' equals 0 then the operation is unlimited).   *
X *                                                                            *
X * Return values: OK = success / ERROR = error                                *
X ******************************************************************************/
Xint
X_accept_connection(con_port, port, time)
XCONNECTIONDESCR *con_port;
XPORTDESCR       *port;
Xunsigned         time;
X{
X    static long res;
X    static char buf[1];
X
X#ifdef DEBUG_IPC
X    if (_debug_ipc) {
X        fprintf(_debugout, "[ipc] %s ***** _accept_connection():\n", 
X	    _processprefix);
X        fprintf(_debugout, "[ipc] %s con_port = %d\n", _processprefix, 
X	    con_port);
X        fprintf(_debugout, "[ipc] %s port = (node = %ld, pid = %ld)\n", 
X	    _processprefix, port->node, port->pid);
X        fprintf(_debugout, "[ipc] %s time = %d\n", _processprefix, time);
X    }
X#endif /* DEBUG_IPC /**/
X    /* set Errno */
X    Errno = EACPTCON;
X    /* set timer */
X    SETTIMER(time, CON_REQ);
X    while(!timeout_flag) {
X	/* get connection request */
X	timeout_type = TIMER_RECV;
X	if ((res = _crecv(CON_REQ, buf, 0)) < 0) {
X	    timeout_type = TIMER_NOMSG;
X#ifdef DEBUG_IPC
X	    if (_debug_ipc) {
X	        fprintf(_debugout, "[ipc] %s result of _crecv = %ld\n", 
X		    _processprefix, res);
X	    }
X#endif /* DEBUG_IPC /**/
X	    if (time == 0) {
X	        DEBUGDISPERR("can't receive connection requests");
X	        return(ERROR);
X	    } else
X	        continue;
X	}
X	timeout_type = TIMER_NOMSG;
X#ifdef DEBUG_IPC
X	if (_debug_ipc) {
X	    fprintf(_debugout, "[ipc] %s result of _crecv = %ld\n",
X	        _processprefix, res);
X	}
X#endif /* DEBUG_IPC /**/
X	if (timeout_flag)
X	    break;
X	/* got a connection, initialize connection descriptor */
X	con_port->othernode = infonode();
X	con_port->otherpid  = infopid();
X	con_port->msgtype   = (mynode() << 8 + mypid()) & 0x0FFFFFFF;
X	/* clear timer */
X	(void) alarm(0);
X        /* send back acknowledge message */
X#ifdef DEBUG_IPC
X	if (_debug_ipc) {
X	    fprintf(_debugout, "[ipc] %s sending acknowledge to node = %ld, pid = %ld\n",
X	        _processprefix, infonode(), infopid());
X	}
X#endif /* DEBUG_IPC /**/
X	isend(CON_ACK, buf, 0, infonode(), infopid());
X	flushmsg(CON_ACK, infonode(), infopid());
X	return(OK);
X    } /* while */
X    DEBUGPUTS("operation '_accept_connection' timed out");
X    Errno = ETIMEOUT;
X    return(ERROR);
X} /* _accept_connection */
X
X/******************************************************************************
X * _make_connection()                                                         *
X *                                                                            *
X * Communication enpoint 'port1' tries 'time' real time seconds to connect    *
X * to 'port2' (if 'time' equals 0 then the operation is unlimited).           *
X *                                                                            *
X * Return values: OK = success / ERROR = error                                *
X ******************************************************************************/
Xint
X_make_connection(con_port, port1, port2, time)
XCONNECTIONDESCR *con_port;
XPORTDESCR       *port1,
X                *port2;
Xunsigned         time;
X{
X    static long msg_id, res;
X    static char buf[1], rbuf[1];
X
X#ifdef DEBUG_IPC
X    if (_debug_ipc) {
X        fprintf(_debugout, "[ipc] %s ***** _make_connection():\n", 
X	    _processprefix);
X        fprintf(_debugout, "[ipc] %s port1 = (node = %ld, pid = %ld)\n",
X	    _processprefix, port1->node, port1->pid);
X        fprintf(_debugout, "[ipc] %s port2 = (node = %ld, pid = %ld)\n",
X	    _processprefix, port2->node, port2->pid);
X        fprintf(_debugout, "[ipc] %s time = %d\n", _processprefix, time);
X    }
X#endif /* DEBUG_IPC /**/
X    /* set Errno */
X    Errno = EMAKECON;
X#ifdef DEBUG_IPC
X    if (_debug_ipc)
X        fprintf(_debugout,"[ipc] %s sending request to node = %ld, pid = %ld\n",
X	    _processprefix, port2->node, port2->pid);
X#endif /* DEBUG_IPC /**/
X    msg_id = isend(CON_REQ, buf, 0, port2->node, port2->pid);
X    /* set timer */
X    SETTIMER(time, CON_ACK);
X    while(!timeout_flag) {
X	timeout_type = TIMER_RECV;
X	if ((res = _crecv(CON_ACK, rbuf, 0)) < 0) {
X	    timeout_type = TIMER_NOMSG;
X#ifdef DEBUG_IPC
X	    if (_debug_ipc) {
X	        fprintf(_debugout, "[ipc] %s result of _crecv = %ld\n",
X		    _processprefix, res);
X	    }
X#endif /* DEBUG_IPC /**/
X	    if (time == 0) {
X	        DEBUGDISPERR("can't receive connection acknowledge");
X	        return(ERROR);
X	    } else
X	        continue;
X	}
X#ifdef DEBUG_IPC
X	if (_debug_ipc) {
X	    fprintf(_debugout, "[ipc] %s result of _crecv = %ld\n",
X	        _processprefix, res);
X	}
X#endif /* DEBUG_IPC /**/
X	timeout_type = TIMER_NOMSG;
X	if (timeout_flag)
X	    break;
X	/* connection established, initialize connection descriptor */
X	con_port->othernode = port2->node;
X	con_port->otherpid  = port2->pid;
X	con_port->msgtype   = (port2->node << 8 + port2->pid) & 0x0FFFFFFF;
X	/* clear timer and return */
X	(void) alarm(0);
X	return(OK);
X    } /* while */
X    DEBUGPUTS("operation '_make_connection' timed out");
X    DEBUGPUTS("deleting request message");
X    msgcancel(msg_id);
X    flushmsg(CON_REQ, port2->node, port2->pid);
X    Errno = ETIMEOUT;
X    return(ERROR);
X} /* _make_connection */
X
X/******************************************************************************
X * _close_connection()                                                        *
X *                                                                            *
X * The connection associated to connection port 'con_port' is closed:         *
X * there is nothing to do for iPSC!                                           *
X *                                                                            *
X * Return values: always OK for success                                       *
X ******************************************************************************/
Xint
X_close_connection(con_port)
XCONNECTIONDESCR *con_port;
X{
X#ifdef DEBUG_IPC
X    if (_debug_ipc) {
X        fprintf(_debugout, "[ipc] %s ***** _close_connection():\n", 
X	    _processprefix);
X        fprintf(_debugout, "[ipc] %s con_port = (node = %ld, pid = %ld, type = %ld)\n",
X	    _processprefix, con_port->othernode, con_port->otherpid, 
X	    con_port->msgtype);
X    }
X#endif /* DEBUG_IPC /**/
X    return(OK);
X} /* _close_connection */
X
X/******************************************************************************
X * _recv_data()                                                               *
X *                                                                            *
X * 'number' bytes are received from connection port 'con_port' and stored     *
X * into 'buffer'. 'time' is the maximum real time in seconds to wait for a    *
X * message to arrive (if 'time' equals 0 the waiting is unlimited).           * 
X *                                                                            *
X * Return values: number of received bytes upon success / ERROR = error       *
X ******************************************************************************/
Xint
X_recv_data(con_port, buffer, number, time)
XCONNECTIONDESCR *con_port;
Xchar            *buffer;
Xint              number;
Xunsigned         time;
X{
X    static long res;
X
X#ifdef DEBUG_IPC
X    if (_debug_ipc) {
X        fprintf(_debugout, "[ipc] %s ***** _recv_data()\n", _processprefix);
X        fprintf(_debugout, "[ipc] %s con_port = (node = %ld, pid = %ld, type = %ld)\n",
X	    _processprefix, con_port->othernode, con_port->otherpid, 
X	    con_port->msgtype);
X        fprintf(_debugout, "[ipc] %s buffer = %d, number = %d\n", 
X	    _processprefix, buffer, number);
X        fprintf(_debugout, "[ipc] %s time = %d\n", _processprefix, time);
X    }
X#endif /* DEBUG_IPC /**/
X    /* set Errno */
X    Errno = ERECVDATA;
X    /* set timer */
X    SETTIMER(time, con_port->msgtype);
X    while(!timeout_flag) {
X	timeout_type = TIMER_RECV;
X        if ((res = _crecv(con_port->msgtype, buffer, number)) < 0) {
X	    timeout_type = TIMER_NOMSG;
X#ifdef DEBUG_IPC
X	    if (_debug_ipc) {
X	        fprintf(_debugout, "[ipc] %s result of _crecv = %ld\n",
X		    _processprefix, res);
X	    }
X#endif /* DEBUG_IPC /**/
X	    if (time == 0) {
X	        DEBUGDISPERR("can't receive message");
X	        return(ERROR);
X	    } else
X	        continue;
X	}
X	timeout_type = TIMER_NOMSG;
X#ifdef DEBUG_IPC
X	if (_debug_ipc) {
X	    fprintf(_debugout, "[ipc] %s result of _crecv = %ld\n", 
X	        _processprefix, res);
X	}
X#endif /* DEBUG_IPC /**/
X	if (timeout_flag)
X	    break;
X	/* clear timer and return */
X	(void) alarm(0);
X	DEBUGPUTS("sending acknowledge message");
X	isend(con_port->msgtype, buffer, 0, infonode(), infopid());
X	flushmsg(con_port->msgtype, infonode(), infopid());
X        return(number);
X    } /* while */
X    DEBUGPUTS("operation '_recv_data' timed out");
X    Errno = ETIMEOUT;
X    return(ERROR);
X} /* _recv_data */
X
X/******************************************************************************
X * _send_data()                                                               *
X *                                                                            *
X * 'number' bytes, stored in 'buffer', are send to connection port 'con_port'.*
X * 'time' is the maximum real time in seconds to retry sending upon error (if *
X * 'time' equals 0 the waiting is unlimited).                                 *
X *                                                                            *
X * Return values: number of sent bytes upon success / ERROR = error           *
X ******************************************************************************/
Xint
X_send_data(con_port, buffer, number, time)
XCONNECTIONDESCR *con_port;
Xchar            *buffer;
Xint              number;
Xunsigned         time;
X{
X    long res, msg_id;
X
X#ifdef DEBUG_IPC
X    if (_debug_ipc) {
X        fprintf(_debugout, "[ipc] %s ***** _send_data():\n", _processprefix);
X        fprintf(_debugout, "[ipc] %s con_port = (node = %ld, pid = %ld, type = %ld)\n",
X	    _processprefix, con_port->othernode, con_port->otherpid, 
X	    con_port->msgtype);
X        fprintf(_debugout, "[ipc] %s buffer = %d, number = %d\n", 
X	    _processprefix, buffer, number);
X        fprintf(_debugout, "[ipc] %s time = %d\n", _processprefix, time);
X    }
X#endif /* DEBUG_IPC /**/
X    /* set Errno */
X    Errno = ESENDDATA;
X#ifdef DEBUG_IPC
X    if (_debug_ipc) {
X        fprintf(_debugout,"[ipc] %s sending message to node = %ld, pid = %ld\n",
X	    _processprefix, con_port->othernode, con_port->otherpid);
X    }
X#endif /* DEBUG_IPC /**/
X    msg_id = isend(con_port->msgtype, buffer, number, con_port->othernode, 
X	con_port->otherpid);
X    /* set timer */
X    SETTIMER(time, con_port->msgtype);
X    while(!timeout_flag) {
X	timeout_type = TIMER_RECV;
X        if ((res = _crecv(con_port->msgtype, buffer, 0)) < 0) {
X	    timeout_type = TIMER_NOMSG;
X#ifdef DEBUG_IPC
X	    if (_debug_ipc) {
X	        fprintf(_debugout, "[ipc] %s result of _crecv = %ld\n",
X		    _processprefix, res);
X	    }
X#endif /* DEBUG_IPC /**/
X	    if (time == 0) {
X	        DEBUGDISPERR("can't receive message");
X	        return(ERROR);
X	    } else
X	        continue;
X	}
X	timeout_type = TIMER_NOMSG;
X#ifdef DEBUG_IPC
X	if (_debug_ipc) {
X	    fprintf(_debugout, "[ipc] %s result of _crecv = %ld\n", 
X	        _processprefix, res);
X	}
X#endif /* DEBUG_IPC /**/
X	if (timeout_flag)
X	    break;
X	/* clear timer and return */
X	(void) alarm(0);
X        return(number);
X    } /* while */
X    msgcancel(msg_id);
X    flushmsg(con_port->msgtype, con_port->othernode, con_port->otherpid);
X    DEBUGPUTS("operation '_send_data' timed out");
X    Errno = ETIMEOUT;
X    return(ERROR);
X} /* _send_data */
X
X/* ============================ DEBUG Routines ============================== */
X
X/******************************************************************************
X * _display_port_info()                                                       *
X *                                                                            *
X * Displays the components of the structure PORTDESCR specified by 'port'.    *
X *                                                                            *
X * Return values: always OK for success                                       *
X ******************************************************************************/
Xint
X_display_port_info(prefix, msg, port)
Xchar *prefix, *msg;
XPORTDESCR port;
X{
X    fprintf(_debugout, "%s %s %s: node = %ld, pid = %ld\n", 
X	prefix, _processprefix, msg, port.node, port.pid);
X    return(OK);
X} /* _display_port_info */
X
X/******************************************************************************
X * _display_connection_port_info()                                            *
X *                                                                            *
X * Displays the components of the structure CONNECTIONDESCR specified by      *
X * 'con_port'.                                                                *
X *                                                                            *
X * Return values: always OK for success                                       *
X ******************************************************************************/
Xint
X_display_connection_port_info(prefix, msg, con_port)
Xchar *prefix, *msg;
XCONNECTIONDESCR con_port;
X{
X	return(OK);
X} /* _display_connection_port_info */
X
X/******************************************************************************
X * _input_port_info()                                                         *
X *                                                                            *
X * Input the port information for 'port'.                                     *
X *                                                                            *
X * Return values: none                                                        *
X ******************************************************************************/
Xint
X_input_port_info(port)
XPORTDESCR *port;
X{
X	long node, pid;
X
X	printf("node = "); 
X	scanf("%ld", &(port->node));
X	printf("pid  = "); 
X	scanf("%ld", &(port->pid));
X} /* _input_port_info */
END_OF_FILE
if test 21990 -ne `wc -c <'lib/ipc_iPSC.c'`; then
    echo shar: \"'lib/ipc_iPSC.c'\" unpacked with wrong size!
fi
# end of 'lib/ipc_iPSC.c'
fi
echo shar: End of archive 13 \(of 18\).
cp /dev/null ark13isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
