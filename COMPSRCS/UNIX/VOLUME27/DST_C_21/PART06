Newsgroups: comp.sources.unix
From: pleierc@informatik.tu-muenchen.de (Christoph Pleier)
Subject: v27i180: distributed-c-2.1 - Distributed C Development Environment, V2.1, Part06/18
References: <1.756634932.28500@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: pleierc@informatik.tu-muenchen.de (Christoph Pleier)
Posting-Number: Volume 27, Issue 180
Archive-Name: distributed-c-2.1/part06

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 18)."
# Contents:  NOTES config/symb_general.c dcadmin/ProcessList.c
#   dcc/main.c dcc/parseoptions.c dcc/util.c dcc/yyfuncts.c
#   dclocate/main.c examples/philo/philo.dc examples/test/xdr.dc
#   include/com_errlist.h include/run_Errno.h
# Wrapped by vixie@gw.home.vix.com on Thu Dec 23 00:11:59 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'NOTES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'NOTES'\"
else
echo shar: Extracting \"'NOTES'\" \(6833 characters\)
sed "s/^X//" >'NOTES' <<'END_OF_FILE'
X              Distributed C Development Environment - Notes
X              =============================================
X
X1.) Generating executable load modules:
X---------------------------------------
X
XYou MUST use the same compiler for generating the runtime library functions
Xand for generating the executable load modules to which these library functions
Xare linked.
X
X2.) Problems encoding/decoding data (heterogeneous version only):
X----------------------------------------------------------------
X
XFor interprocess communications between different machine types data must be 
Xconverted. This conversion is performed by encoding the data before sending 
Xand decoding data after receiving using the Sun XDR-Routines.
XThe encode and decode actions are performed via a dynamic allocated
Xbuffer '_dcc_buf', the size of the buffer is specified at runtime by the
Xvariable '_dcc_buf_size' in the corresponding source code of each process.
XBut the size needed to encode/decode dynamic structures like trees
Xor lists can not be predicted at compilation time correctly!
XBecause of that, there are two different ways for generating code.
XThe default action performed by the compiler is to generate code which
Xdetermines the size of the buffer as the size of the greatest structure
Xto fit in multiplied by 4. If dynamic structures are used, it is better 
Xto specify a sufficent size using the '-f <bufsize>' compiler option.
XIf the allocated buffer size is too little to convert the dynamic data
Xstructures, errors during encoding/decoding will be the consequence up to
Xprocess crashes. So if you get runtime errors like "error encoding data"
Xor "error decoding data" you may probably be able to fix this problem by 
Xinctreasing the size of the corresponding variable '_dcc_buf_size'.
X
XMany errors during encoding and decoding data are the consequence of
Xwrong pointer handling caused by the programmer. 
XConsider this aspect if you get encode/decode errors!
X
X3.) Problems using 'stdin', 'stdout' or 'stderr' (heterogeneous version only):
X-----------------------------------------------------------------------------
X
XYou will get problems, if you use 'stdin', 'stdout' or 'stderr' in Distributed
XC programs and compile the generated standard C source code files via remote
Xcompilation on different machines.
XThe problem is caused by the different definitions at the various machines.
XFor example at a CONVEX 'stdin' is defined in 'stdio.h' as "(&__ap$iob[0])",
Xat a Sun Sparc Station as "(&_iob[0])", and at a Hewlett Packard Workstation
Xas "(&__iob[0])".
XTo avoid this problem you have easely to write the following code at the
Xbeginning of your Distributed C programs right after the include-directive,
Xwhich includes the file 'stdio.h':
X
X	#include <stdio.h>
X	#undef stdin
X	#undef stdout
X	#undef stderr
X
XThis will cause warnings of the type "xxx redefined", which can be ignored.
X	
X4.) Termination of all created processes after errors:
X------------------------------------------------------
X
XIf you want to shut down all created processes of an executing parallel program
Xafter errors, you can do this be calling the system function abort() in the 
Xprocess which detected the error.
X
X5.) Manually termination of all created processes:
X--------------------------------------------------
X
XIf you want to terminate all generated processes of an executing parallel 
Xprogram manually, send signal SIGTERM to the corresponding administration 
Xprocess dcadmin. Sending signal SIGTERM to dcadmin during runtime will cause 
Xthe forcefully termination of all generated processes.
X
X6.) Nested Distributed C statements:
X------------------------------------
X
XYou can't nest Distributed C Statements at will.
XDo NOT use accept- or create-statements within accept-statements, because
Xthis will cause an runtime error in the communication primitives.
X
X7.) Automatic process to node allocation:
X-----------------------------------------
X
XYou can use the process to node allocation performed by the informations of
Xa program and a system configuration file only for the HOMOGENEOUS or 
XHETEROGENEOUS version of the compiler. 
XBe careful not to use it at the Intel Hypercube: define USE_MAPFILE during
Xcompilation of the administration process for the iPSC compiler version.
X
X8.) Problems with system include files:
X---------------------------------------
X
XAny system files '#include' directives (e.g. "stdio.h") of a Distributed C 
Xprogram are collected and written to the corresponding generated include file.
XIf you use "#include <xxxxx.h>" preprocessor commands in combination with the
X'-Ipath' option during preprocessing, the problem may occur that this include
Xdirective does not appear in the generated include file.
XThe reason is that only the paths '/usr/include' and '/usr/local/dist/include'
Xare currently considered to be directories for storing system include files.
XIf you get the problem that some include files which are located in special
Xpaths and are included with "#include <....>" in combination with '-Ipath', you
Xmust add this path to the already considered paths ("/usr/include", ...) in the
Xfiles dcc/includefile.c and dcc/yyfuncts.c.
X
X9.) Supported operating-system/machine/environment configurations:
X------------------------------------------------------------------
X
XFollowing is a list of systems on which the software package was successfully
Xused. The list elements have the structure 
X  operating system, operating system version, 
X  machine types, 
X  communication routines, supported network types:
X
Xo AIX, 3.2, 
X  RS 6000, 
X  SOCKET, HETEROGENEOUS
Xo ConvexOS, 10.2, 
X  C220/C3840, 
X  SOCKET, HETEROGENEOUS
Xo HP-UX, A.09.01, 
X  HP9000-720/HP9000-755, 
X  SOCKET, HOMOGENEOUS/HETEROGENEOUS
Xo Linux, 0.99.13, 
X  AT i486s, 
X  SOCKET, HOMOGENEOUS
Xo SCO Xenix, 2.3, 
X  AT i386, 
X  MSGSEM, SINGLE
Xo SCO Unix, 3.2, 
X  AT i386, 
X  MSGSEM, SINGLE
Xo SunOS, 4.1 or greater, 
X  Sun SPARCstations(sun4c),
X  SOCKET, HOMOGENEOUS/HETEROGENEOUS
Xo Ultrix, 3.1, 
X  DECstations,
X  SOCKET, HOMOGENEOUS
Xo Unicos, 7.0, 
X  Cray Y-MP, 
X  SOCKET, HETEROGENEOUS
X
X(SOCKET = TCP/IP data stream sockets, MSGSEM = message queues and semaphores)
X
X10.) Problems starting Distributed C programs on Linux systems:
X--------------------------------------------------------------
X
XUse sockets as communication primitives on Linux systems!
X
XIf you still get problems starting Distributed C programs on your Linux system,
Xcheck if your network is correctly configured. You have to configure your 
XEthernet card if your system is connected to a network. If your machine is a 
Xstandalone system you MUST configure the 'loopback mode' (i.e. no SLIP, no 
Xethernet card, just TCP/IP connections to your own machine---called "loopback",
XIP address 127.0.0.1) to be able to run Distributed C programs (to do so, see 
Xthe corresponding FAQs, especially 'NET-2-HOWTO').
END_OF_FILE
if test 6833 -ne `wc -c <'NOTES'`; then
    echo shar: \"'NOTES'\" unpacked with wrong size!
fi
# end of 'NOTES'
fi
if test -f 'config/symb_general.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/symb_general.c'\"
else
echo shar: Extracting \"'config/symb_general.c'\" \(6751 characters\)
sed "s/^X//" >'config/symb_general.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                       s y m b _ g e n e r a l . c                       *
X *                                                                         *
X *                            Package : Configuration Files Parsers        *
X *                            Version : 1.0                                *
X *                       CreationDate : 26.02.92                           *
X *                         LastUpDate : 26.02.92                           *
X *                                                                         *
X *         All general routines needed to manage the symbol table.         *
X *                                                                         *
X *               Copyright (C) 1992-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include "cfgparsers.h"
X
X/******************************************************************************
X * enter_symbtabel()                                                          *
X *                                                                            *
X * Adds a new symbol table element to the symbol table.                       *
X *                                                                            *
X * Return values: pointer to new element upon success / NULL upon error       *
X ******************************************************************************/
XSYMBTABEL *
Xenter_symbtabel(name)
Xchar *name;
X{
X    SYMBTABEL *ptr;
X
X    ptr = (SYMBTABEL *) Malloc(sizeof(SYMBTABEL));
X    ptr->type = UNDEFINED;
X    ptr->name = strsave(name);
X    ptr->next = NULL;
X    if (!symbtab)
X	symbtab = last_symb = ptr;
X    else {
X	last_symb->next = ptr;
X	last_symb = ptr;
X    }
X    return(ptr);
X} /* enter_symbtabel */
X
X/******************************************************************************
X * lookup_symbtabel()                                                         *
X *                                                                            *
X * Searches the symbol table element specified by 'name'.                     *
X *                                                                            *
X * Return values: pointer to the found symbol table element upon success /    *
X *                NULL, if element not found or upon error                    *
X ******************************************************************************/
XSYMBTABEL *
Xlookup_symbtabel(name)
Xchar *name;
X{
X    register SYMBTABEL *symbol;
X
X    for(symbol = symbtab; symbol; symbol = symbol->next) 
X	if (!strcmp(symbol->name, name)) {
X	    return(symbol);
X	}
X    return(NULL);
X} /* lookup_symbtabel */
X
X/******************************************************************************
X * store_ident_in_list()                                                      *
X *                                                                            *
X * Stores the symbol table entry pointed to by 'symbol' in a identifier list. *
X *                                                                            *
X * Return values: pointer to ident list upon success / NULL upon error        *
X ******************************************************************************/
XIDENTLIST *
Xstore_ident_in_list(symbol)
XSYMBTABEL *symbol;
X{
X    register IDENTLIST *ptr;
X
X    ptr = (IDENTLIST *) Malloc(sizeof(IDENTLIST));
X    ptr->symbol = symbol;
X    ptr->next   = NULL;
X    return(ptr);
X} /* store_ident_in_list */
X
X/******************************************************************************
X * chain_ident_lists()                                                        *
X *                                                                            *
X * Chains ident list 'l2' to the end of ident list 'l1'.                      *
X *                                                                            *
X * Return values: pointer to resulting ident list upon success /              *
X *                NULL upon error                                             *
X ******************************************************************************/
XIDENTLIST *
Xchain_ident_lists(l1, l2)
XIDENTLIST *l1, *l2;
X{
X    register IDENTLIST *ptr;
X
X    for(ptr = l1; ptr->next; ptr = ptr->next)
X	;
X    ptr->next = l2;
X    return(l1);
X} /* chain_ident_lists */
X
X/******************************************************************************
X * mark_symbols()                                                             *
X *                                                                            *
X * Changes the type of all symbol table entrys in the identifier list         *
X * 'idlist' to the type specified by 'symboltype'.                            *
X *                                                                            *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/int
Xmark_symbols(idlist, symboltype)
XIDENTLIST *idlist;
Xint symboltype;
X{
X    for(; idlist; idlist = idlist->next) {
X        if (idlist->symbol->type != UNDEFINED && idlist->symbol->type != symboltype) {
X            printf("Error: line %d at \"%s\": redefinition\"%s\"\n",
X                yylineno, yytext, idlist->symbol->name);
X            exit(ERROR);
X        }
X        idlist->symbol->type = symboltype;
X    }
X} /* mark_symbols */
END_OF_FILE
if test 6751 -ne `wc -c <'config/symb_general.c'`; then
    echo shar: \"'config/symb_general.c'\" unpacked with wrong size!
fi
# end of 'config/symb_general.c'
fi
if test -f 'dcadmin/ProcessList.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcadmin/ProcessList.c'\"
else
echo shar: Extracting \"'dcadmin/ProcessList.c'\" \(7104 characters\)
sed "s/^X//" >'dcadmin/ProcessList.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                        P r o c e s s L i s t . c                        *
X *                                                                         *
X *                            Package : Administration Process             *
X *                            Version : 1.0                                *
X *                       CreationDate : 16.09.90                           *
X *                         LastUpDate : 14.03.92                           *
X *                                                                         *
X *        All routines needed to manage the process list correctly.        *
X *                                                                         *
X *                  Portions Copyright 1990 Franz Distler                  *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#ifdef HETEROGENEOUS
X# include <rpc/rpc.h>
X#endif
X#include <errno.h>
X#include "ipc.h"
X#include "dcc.h"
X#include "run_Errno.h"
X#include "timeout.h"
X#include "dcadmin.h"
X#ifndef USE_MAPFILE
X# include "cfgparsers.h"
X#endif /* Not USE_MAPFILE /**/
X
X#ifdef ADMINDEBUG
X# define DEBUGPUTS(str)		fprintf(dfile,"[dbg] %s %s\n", _processprefix, str)
X# define DEBUGFPRINTF(f, a)	fprintf(dfile, f, a)
X#else
X# define DEBUGPUTS(str)		/* nothing */
X# define DEBUGFPRINTF(f, a)	/* nothing */
X#endif /* ADMINDEBUG /**/
X
X#define EXIT(v)			fprintf(stderr, "dcadmin: Terminating!\n"); \
X				exit(v)
X
X/******************************************************************************
X * StoreNewProcessInList()                                                    *
X *                                                                            *
X * Stores a new created process in the 'process data list'.                   *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
XStoreNewProcessInList()
X{
X    PROCESSDATA p_data;
X    register struct pdat_list *pdatptr;
X
X    DEBUGPUTS("STORING new process in list");
X    /* Receive the process information of the new created process */
X    if (_receive_process_data(&p_data)) {
X	error("dcadmin: receiving process data");
X	EXIT(ERROR);
X    }
X    /* create a new process data list element */
X    if (!(pdatptr = (struct pdat_list *) malloc(sizeof(struct pdat_list)))) {
X	error("dcadmin: malloc()");
X	EXIT(ERROR);
X    }
X    /* store the new process in the process data list */
X    strcpy(pdatptr->p_descr.processname, p_data.processname);
X    pdatptr->p_descr.pid  = p_data.pid;
X    pdatptr->p_descr.port = p_data.port;
X    pdatptr->status       = RUNNING;
X    pdatptr->next         = pdat_first;
X    pdat_first            = pdatptr;
X#ifdef ADMINDEBUG
X    fprintf(dfile, "[dbg] %s Process %s with pid %d stored in list\n",
X	_processprefix, pdat_first->p_descr.processname, 
X	pdat_first->p_descr.pid);
X    if (_debugflush)
X	fflush(dfile);
X#endif /* ADMINDEBUG /**/
X    return(OK);
X} /* StoreNewProcessInList */
X
X/******************************************************************************
X * DeleteProcessFromList()                                                    *
X *                                                                            *
X * Delete a terminating process from the 'process data list'. If there is no  *
X * appropriate entry return an error.                                         *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
XDeleteProcessFromList()
X{
X    PROCESSDATA p_data;
X    register struct pdat_list *aptr, *lptr;
X#ifndef USE_MAPFILE
X    SYMBTABEL *psymbol, *hsymbol;
X#endif /* Not USE_MAPFILE /**/
X
X    /* Receive the process information of the terminating process */
X    if (_receive_process_data(&p_data)) {
X	error("dcadmin: receiving process data");
X	EXIT(ERROR);
X    }
X    /* Search entry in list and delete it if there is one.
X     * Otherwise return an error.
X     */
X    for(aptr = lptr = pdat_first; aptr; aptr = aptr->next) {
X        if (!strcmp(aptr->p_descr.processname, p_data.processname)
X#ifdef iPSC
X	   && aptr->p_descr.port.node == p_data.port.node
X	   && aptr->p_descr.port.pid  == p_data.port.pid) {
X#else
X# ifdef SINGLE
X	   && aptr->p_descr.pid == p_data.pid) {
X# else /* HOMOGENEOUS || HETEROGENEOUS */
X	   && !strcmp(aptr->p_descr.port.hostname, p_data.port.hostname)
X	   && aptr->p_descr.pid == p_data.pid) {
X# endif /* SINGLE /**/
X#endif /* iPSC /**/
X#if !defined(USE_MAPFILE) && !defined(SCO_UNIX)
X	/* actualize probably host load */
X        psymbol = lookup_symbtabel(p_data.processname);
X        hsymbol = lookup_symbtabel(p_data.port.hostname);
X        if (psymbol && hsymbol) {
X    	    hsymbol->info.Host.prob_load -= psymbol->info.Process.intensity_index / hsymbol->info.Host.perf_index;
X	}
X        /* printf("Probably load at host %s is now %3.2f\n", hsymbol->name, hsymbol->info.Host.prob_load); */
X#endif /* Not USE_MAPFILE /**/
X#ifdef ADMINDEBUG
X    		fprintf(dfile, "[dbg] %s Process %s with pid %d deleted from list\n",
X		    _processprefix, aptr->p_descr.processname, aptr->p_descr.pid);
X    		if (_debugflush)
X		    fflush(dfile);
X#endif /* ADMINDEBUG /**/
X		if (aptr == pdat_first)
X			pdat_first = pdat_first->next;
X		else
X			lptr->next = aptr->next;
X		free(aptr);
X		CheckAcceptOrTerminate();
X		return(OK);
X	} /* if */
X	lptr = aptr;
X    } /* for */
X    Errno = -1;
X    error("Terminating process not found in process data list");
X    return(ERROR);
X} /* DeleteProcessFromList */
X
END_OF_FILE
if test 7104 -ne `wc -c <'dcadmin/ProcessList.c'`; then
    echo shar: \"'dcadmin/ProcessList.c'\" unpacked with wrong size!
fi
# end of 'dcadmin/ProcessList.c'
fi
if test -f 'dcc/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcc/main.c'\"
else
echo shar: Extracting \"'dcc/main.c'\" \(6713 characters\)
sed "s/^X//" >'dcc/main.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                              m a i n . c                                *
X *                                                                         *
X *                            Package : Compiler                           *
X *                            Version : 1.0                                *
X *                       CreationDate : 05.07.90                           *
X *                         LastUpDate : 16.12.93                           *
X *                                                                         *
X *                           The function 'main'                           *
X *                                                                         *
X *                  Portions Copyright 1990 Franz Distler                  *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <signal.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include "config.h"
X#include "globals.h"
X#include "functions.h"
X
X/******************************************************************************
X * main()                                                                     *
X *                                                                            *
X * The function 'main' of the compiler.                                       *
X *                                                                            *
X * Return values: EXIT_OK upon success / EXIT_code upon error                 *
X ******************************************************************************/
Xint 
Xmain(argc,argv)
Xint    argc;
Xchar **argv;
X{
X    register int i;
X    static char cmd[1024];
X    struct stat statbuf;
X    struct include_path_list *pathptr;
X    struct cpp_def_list *cppdefptr;
X#ifdef UNICOS
X    extern long yydebug, yynerrs;
X#else
X    extern int yydebug, yynerrs;
X#endif
X    extern FILE *yyin;
X
X    /* initialize global variables */
X    yydebug   = 0;
X    yyerrfile = stderr;
X    convert_buffer = strmalloc("");
X#ifdef DEBUGFLAG
X    if (!(debugfile = fopen("dcc.debug", "w"))) {
X	printf("Error: impossible to open debug file\n");
X	exit(EXIT_FOPEN);
X    }
X#endif /* DEBUGFLAG /**/
X
X    /* catch some signals */
X    SetSignals();
X
X    /* parse command line options and check if inputfile is present */
X    if (parse_options(argc, argv))
X	exit(EXIT_PARSEOPT);
X    if (stat(inputfilename, &statbuf)) {
X        fputs("Error: inputfile doesn't exist!\n", stderr);
X        exit(EXIT_INPUTFILE);
X    }
X
X    /* use cpp to eliminate comments and preprocessor directives */
X    sprintf(cmd, "%s ", CPP);
X#ifdef iPSC
X    (void) strcat(cmd, "-DiPSC");
X# else 
X# ifdef SYSTEM_V
X    (void) strcat(cmd, "-DSYSTEM_V");
X# else /* BSD */
X    (void) strcat(cmd, "-DBSD");
X# endif /* SYSTEM_V /**/
X#endif /* iPSC /**/
X    for(pathptr = first_inclpathname; pathptr; pathptr = pathptr->next) {
X        (void) strcat(cmd, " -I");
X	(void) strcat(cmd, pathptr->path);
X    }
X    for(cppdefptr = first_cppdef; cppdefptr; cppdefptr = cppdefptr->next) {
X        (void) strcat(cmd, " -D");
X	(void) strcat(cmd, cppdefptr->def);
X    }
X    (void) strcat(cmd, " ");
X    (void) strcat(cmd, inputfilename);
X    if (cppflag) {
X	/* preprocess source files only and copy result to stdout */
X	system(cmd);
X	exit(EXIT_OK);
X    } else {
X        if (!(yyin = popen(cmd, "r"))) {
X            fputs("Error: cpp doesn't work!\n", stderr);
X            exit(EXIT_CPP);
X        }
X    }
X
X    /* determine some names */
X    (void) strcpy(filenameprefix, inputfilename);
X    filenameprefix[strlen(filenameprefix)-3] = '\0';
X    sprintf(inclfilename, "%s.h", filenameprefix);
X    sprintf(makefilename, "%s.mf", filenameprefix);
X
X    /* create information storing temporary strings */
X    crextstr      = strmalloc("");
X    trextstr      = strmalloc("");
X#ifdef HETEROGENEOUS
X    xdrextstr     = strmalloc("");
X#endif
X    fnextstr      = strmalloc("");
X
X    /* store includefiles in list */
X    for(i=0; *includefiles[i]; ++i)
X	add_includefile_to_list(includefiles[i]);
X
X    /* parse input */
X    if (allflag || beautyflag)
X        fprintf(stderr, "Phase %d: compiling to standard code\n", ++phase);
X    (void) yyparse();
X
X    /* close all files */
X    close_files();
X
X    /* if there was at least one warning or error display it */
X    if (yynerrs || (yynwarns && !allflag && !beautyflag))
X	fprintf(stderr, "\nErrors: %d\tWarnings: %d\n", yynerrs, yynwarns);
X
X    /* if there was an error, delete files and exit! */
X    if (yynerrs) {
X	remove_files();
X	exit(EXIT_PARSING);
X    }
X
X    /* execute makefile to beautify generated files */
X    if (beautyflag) {
X        fprintf(stderr, "Phase %d: beautifying generated files\n", ++phase);
X        sprintf(cmd, "make -sf %s \"ECHO=@sh -cn echo\" beautify", makefilename);
X        if (system(cmd))
X            fputs("Error beautifying the generated processes!\n", stderr);
X    }
X
X    /* execute makefile to build files */
X    if (allflag) {
X	fprintf(stderr, "Phase %d: compiling and linking\n", ++phase);
X#ifdef LINUX
X	sprintf(cmd, "make -sf %s \"MAKE=@make -sf %s \\\"ECHO=@echo\\\"\" \"ECHO=@echo\"",
X#else
X	sprintf(cmd, "make -sf %s \"MAKE=@make -sf %s \\\"ECHO=@sh -cn @echo\\\"\" \"ECHO=@sh -cn @echo\"",
X#endif
X	    makefilename, makefilename);
X	if (system(cmd)) {
X	    fputs("Error during compilation or linking!\n", stderr);
X	    exit(EXIT_BUILDING);
X	}
X    }
X
X    exit(EXIT_OK);
X} /* main */
END_OF_FILE
if test 6713 -ne `wc -c <'dcc/main.c'`; then
    echo shar: \"'dcc/main.c'\" unpacked with wrong size!
fi
# end of 'dcc/main.c'
fi
if test -f 'dcc/parseoptions.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcc/parseoptions.c'\"
else
echo shar: Extracting \"'dcc/parseoptions.c'\" \(7051 characters\)
sed "s/^X//" >'dcc/parseoptions.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                       p a r s e o p t i o n s . c                       *
X *                                                                         *
X *                            Package : Compiler                           *
X *                            Version : 1.0                                *
X *                       CreationDate : 11.07.91                           *
X *                         LastUpDate : 08.11.91                           *
X *                                                                         *
X *      The routine to parse and interpret the command line options.       *
X *                                                                         *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <signal.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include "config.h"
X#include "extern.h"
X#include "functions.h"
X#include "version.h"
X
Xextern char **inclpaths;
X
X/******************************************************************************
X * parse_options()                                                            *
X *                                                                            *
X * Parses and interprets the compiler commandline options and initializes the *
X * appropriate global flags.                                                  *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
Xparse_options(argc, argv)
Xint    argc;
Xchar **argv;
X{
X    int          opt;
X    char 	 optstr[20];
X    extern int   optind,
X                 opterr;
X    extern char *optarg;
X
X    strcpy(optstr, "habiEve:A:C:L:I:D:");
X#ifdef HETEROGENEOUS
X    strcat(optstr, "f:");
X#endif
X#ifdef DEBUGFLAG
X    strcat(optstr, "S");
X#endif
X#ifdef YYDEBUG
X    strcat(optstr, "Y");
X#endif
X    while((opt = getopt(argc, argv, optstr)) != EOF) {
X	/* options in alphabetical order! */
X        switch(opt) {
X	case 'a': 
X#ifdef DEBUG 
X	    fputs("[debg] enabling compiler and loader passes!\n", debugfile); 
X#endif /* DEBUG /**/ 
X	    allflag = TRUE; 
X	    break;
X	case 'b':
X#ifdef DEBUG
X            fputs("[debg] enabling beautifying of generated files!\n", debugfile);
X#endif /* DEBUG /**/
X	    beautyflag = TRUE;
X	    break;
X        case 'e':
X	    yyerrfilename = optarg;
X#ifdef DEBUG
X            fprintf(debugfile, "[debg] opening error file '%s'\n", yyerrfilename);
X#endif /* DEBUG /**/
X	    if (!(yyerrfile = fopen(yyerrfilename, "w"))) {
X                printf("Error: impossible to open error file\n");
X                exit(EXIT_FOPEN);
X            }
X            break;
X#ifdef HETEROGENEOUS
X	case 'f':
X	    encode_decode_buf_size = optarg;
X# ifdef DEBUG
X            fprintf(debugfile, "[debg] using fixed encode/decode buffer size %s!\n", 
X		encode_decode_buf_size);
X# endif /* DEBUG /**/
X	    determine_dcc_buf_size = FALSE;
X	    break;
X#endif /* HETEROGENEOUS /**/
X        case 'h':
X    	    printf("%s\n%s\n%s\n\n", progname, version, copyright);
X            display_help();
X            exit(EXIT_OK);
X            /* break; */
X	case 'i':
X#ifdef DEBUG 
X	    fputs("[debg] enabling output of internal action informations!\n", debugfile); 
X#endif /* DEBUG /**/ 
X	    infoflag = TRUE; 
X	    break;
X        case 'v':
X    	    printf("%s\n%s\n%s\n\n", progname, version, copyright);
X	    display_version();
X            exit(EXIT_OK);
X            /* break; */
X	case 'A':
X	    libsstr = optarg;
X#ifdef DEBUG
X	    fprintf(debugfile, "[debg] libsstr = %s\n", libsstr);
X#endif /* DEBUG /**/
X	    break;
X	case 'C':
X	    cflagsstr = optarg;
X#ifdef DEBUG
X	    fprintf(debugfile, "[debg] cflagsstr = %s\n", cflagsstr);
X#endif /* DEBUG /**/
X	    break;
X	case 'D':
X#ifdef DEBUG
X            fprintf(debugfile, "[debg] storing additional definition %s\n", optarg);
X#endif /* DEBUG /**/
X	    { 
X		struct cpp_def_list *ptr;
X
X		ptr = (struct cpp_def_list *) Malloc(sizeof(struct cpp_def_list));
X		ptr->def = optarg;
X		if (!first_cppdef)
X			first_cppdef = last_cppdef = ptr;
X		else {
X			last_cppdef->next = ptr;
X			last_cppdef       = ptr;
X		}
X	    }
X	    break;
X	case 'E':
X#ifdef DEBUG
X            fputs("[debg] preprocessing source only and copying result to stdout!\n",
X		debugfile);
X#endif /* DEBUG /**/
X	    cppflag = TRUE;
X	    break;
X	case 'I':
X#ifdef DEBUG
X            fprintf(debugfile, "[debg] storing additional include path: %s\n", 
X		optarg);
X#endif /* DEBUG /**/
X	    { 
X		struct include_path_list *ptr;
X
X		ptr = (struct include_path_list *) Malloc(sizeof(struct include_path_list));
X		ptr->path = optarg;
X		if (!first_inclpathname)
X			first_inclpathname = last_inclpathname = ptr;
X		else {
X			last_inclpathname->next = ptr;
X			last_inclpathname       = ptr;
X		}
X	    }
X	    break;
X	case 'L':
X	    lflagsstr = optarg;
X#ifdef DEBUG
X	    fprintf(debugfile, "[debg] lflagsstr = %s\n", lflagsstr);
X#endif /* DEBUG /**/
X	    break;
X	case 'S':
X	    fclose(debugfile);
X	    (void) system("cat dcc.debug");
X#ifdef DEBUG
X            puts("[debg] writing debug information to stdout!");
X#endif /* DEBUG /**/
X	    debugfile = stdout;
X	    break;
X        case 'Y':
X#ifdef DEBUG
X            fputs("[debg] enabling parser debug mode!\n", debugfile);
X#endif /* DEBUG /**/
X            yydebug = 1;
X            break;
X        case '?':
X	    fputs("\n", stderr);
X            display_usage();
X            return(ERROR);
X        } /* switch */
X    } /* while */
X    if (!(inputfilename = argv[optind])) {
X	fputs("Error: missing input file\n\n", stderr);
X	display_usage();
X	exit(EXIT_INPUTFILE);
X    }
X    return(OK);
X} /* parse_options */
END_OF_FILE
if test 7051 -ne `wc -c <'dcc/parseoptions.c'`; then
    echo shar: \"'dcc/parseoptions.c'\" unpacked with wrong size!
fi
# end of 'dcc/parseoptions.c'
fi
if test -f 'dcc/util.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcc/util.c'\"
else
echo shar: Extracting \"'dcc/util.c'\" \(6657 characters\)
sed "s/^X//" >'dcc/util.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                               u t i l . c                               *
X *                                                                         *
X *                            Package : Compiler                           *
X *                            Version : 1.0                                *
X *                       CreationDate : 09.09.90                           *
X *                         LastUpDate : 05.11.91                           *
X *                                                                         *
X *  All utility routines used to write error, warning and panic messages.  *
X *                                                                         *
X *     Copyright (C) 1990-1994 by Franz Distler and Christoph Pleier.      *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include "config.h"
X#include "extern.h"
X#include "functions.h"
X#include "com_errlist.h"
X
X/******************************************************************************
X * WriteEFWMessage()                                                          *
X *                                                                            *
X * Writes an error, fatal error or warning message to 'yyerrfile'.            *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xstatic int
XWriteEFWMessage(position, prefix, comment)
Xchar *position, *prefix, *comment;
X{
X    char *pos;
X
X    if (Errno == -1)
X	Panic("unknown Errno value in WriteEFWMessage()");
X    pos = (position) ? position : yywhere();
X    fprintf(yyerrfile, "%s at %s: %s: %s\n", 
X	pos, yytoken(), prefix, compiler_errlist[Errno]);
X    if (comment && *comment)
X        fprintf(yyerrfile, "%s at %s: %s\n", pos, yytoken(), comment);
X#ifdef DEBUGFLAG
X    fprintf(debugfile, "------------------------------\n");
X    fprintf(debugfile, "%s at %s: %s: %s\n", 
X	pos, yytoken(), prefix, compiler_errlist[Errno]);
X    if (comment && *comment)
X        fprintf(debugfile, "%s at %s: %s\n", pos, yytoken(), comment);
X    fprintf(debugfile, "------------------------------\n");
X#endif /* DEBUGFLAG /**/
X    Errno = -1;
X} /* WriteEFWMessage */
X
X/******************************************************************************
X * Error()                                                                    *
X *                                                                            *
X * Writes an error message to 'yyerrfile'.                                    *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
XError(position, comment)
Xchar *position, *comment;
X{
X    ++yynerrs;
X    WriteEFWMessage(position, "error", comment);
X    outcodeflag = TRUE;
X} /* Error */
X
X/******************************************************************************
X * FatalError()                                                               *
X *                                                                            *
X * Writes a fatal error message to 'yyerrfile', deletes the generated files   *
X * and terminates.                                                            *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
XFatalError(comment)
Xchar *comment;
X{
X    ++yynerrs;
X    WriteEFWMessage(NULL, "fatal error", comment);
X    fflush(yyerrfile);
X    close_files();
X    remove_files();
X    exit(EXIT_FATAL);
X} /* FatalError */
X
X/******************************************************************************
X * Warning()                                                                  *
X *                                                                            *
X * Writes a warning message to 'yyerrfile'.                                   *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
XWarning(comment)
Xchar *comment;
X{
X    ++yynwarns;
X    WriteEFWMessage(NULL, "warning", comment);
X} /* Warning */
X
X/******************************************************************************
X * Panic()                                                                    *
X *                                                                            *
X * Writes a panic message to 'stderr' and terminates the program.             *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
XPanic(error)
Xchar *error;
X{
X    fprintf(stderr, "***** Panic: disastrous error: %s\n", error);
X    fflush(stderr);
X    fflush(yyerrfile);
X    close_files();
X    remove_files();
X    abort();
X    /* exit(EXIT_PANIC); */
X} /* Panic */
END_OF_FILE
if test 6657 -ne `wc -c <'dcc/util.c'`; then
    echo shar: \"'dcc/util.c'\" unpacked with wrong size!
fi
# end of 'dcc/util.c'
fi
if test -f 'dcc/yyfuncts.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcc/yyfuncts.c'\"
else
echo shar: Extracting \"'dcc/yyfuncts.c'\" \(7188 characters\)
sed "s/^X//" >'dcc/yyfuncts.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                          y y f u n c t s . c                            *
X *                                                                         *
X *                            Package : Compiler                           *
X *                            Version : 1.0                                *
X *                       CreationDate : 07.07.90                           *
X *                         LastUpDate : 19.12.93                           *
X *                                                                         *
X *     Some routines for yacc and lex: 'yyerror', 'yywrap', 'yymark'.      *
X *                                                                         *
X *     Copyright (C) 1990-1994 by Franz Distler and Christoph Pleier.      *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <string.h>
X#include "config.h"
X#include "extern.h"
X#include "functions.h"
X#include "com_Errno.h"
X
X#ifdef UNICOS
Xextern long yynerrs;
X#else
Xextern int yynerrs;
X#endif
Xextern int yyleng;
X
Xstatic char *source;
X
X/******************************************************************************
X * yyerror()                                                                  *
X *                                                                            *
X * This function is called if a syntax error is detected.                     *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint
Xyyerror(s)
Xregister char *s;
X{
X    ++errflag;
X    Errno = ESYNTAX;
X    Error(NULL, "");
X} /* yyerror */
X
X/******************************************************************************
X * yywhere()                                                                  *
X *                                                                            *
X * Determines the location where a syntax error has occured and returns the   *
X * result as string.                                                          *
X *                                                                            *
X * Return values: pointer to the result string                                *
X ******************************************************************************/
Xchar *
Xyywhere()
X{
X    static char res[100], tmp[50];
X
X    if (!source)
X	return("?????");
X    if (source[0] == '"') {
X	strcpy(res, &source[1]);
X	res[strlen(res)-1] = 0;
X    } else
X	strcpy(res, source);
X    if (yylineno > 0) {
X	sprintf(tmp, ", line %d", yylineno - (*yytext == '\n' || !*yytext));
X	strcat(res, tmp);
X    }
X    return(res);
X} /* yywhere */
X
X/******************************************************************************
X * yytoken()                                                                  *
X *                                                                            *
X * Determines which token has produced a syntax error and returns the result  *
X * as string.                                                                 *
X *                                                                            *
X * Return values: pointer to the result string                                *
X ******************************************************************************/
Xchar *
Xyytoken()
X{
X    static char res[100];
X
X    if (*yytext)
X	sprintf(res, "\"%s\"", yytext);
X    else
X	res[0] = '\0';
X    return(res);
X} /* yytoken */
X
X/******************************************************************************
X * yymark()                                                                   *
X *                                                                            *
X * Initializes the variables used in 'yywhere()' to consider include files    *
X * and actualizes the include file list.                                      *
X *                                                                            *
X * Return values: none!                                                       *
X ******************************************************************************/
Xint 
Xyymark()
X{
X    if (source)
X	Free(source);
X    source = (char *) Malloc(yyleng + 1 * sizeof(char));
X#ifdef UNICOS
X    sscanf(yytext, "# line %d %s", &yylineno, source);
X#else
X    sscanf(yytext, "# %d %s", &yylineno, source);
X#endif
X#ifdef DEBUGFLAG
X    fprintf(debugfile, "[cpp ] ##### parsing file %s line %d\n", 
X	source, yylineno);
X#endif /* DEBUGFLAG /**/
X    if (!strncmp(source, "\"/usr/include/", 14)
X#ifdef UNICOS
X    	|| !strncmp(source, "/usr/include/", 13)
X#endif /* UNICOS /**/
X#ifdef LINUX
X    	|| !strncmp(source, "\"/usr/lib/gcc-lib/i486-linux/2.4.5/include/", 43)
X#endif /* LINUX /**/
X	|| !strncmp(source, "\"/usr/local/dist/include/", 24)) {
X	if (!sysinclflag) {
X	    /* Don't add system include files which are included within
X	     * system include files to the includefile list!
X	     */ 
X	    sysinclflag = TRUE;
X	    (void) add_includefile_to_list(source);
X	}
X    } else
X	sysinclflag = FALSE;
X} /* yymark */
X
X/******************************************************************************
X * yywrap()                                                                   *
X *                                                                            *
X * This function is called at end of parsing.                                 *
X *                                                                            *
X * Return values: always 1 for success                                        *
X *                NOTE: The result must be not-zero to end parsing!           *
X ******************************************************************************/
Xint
Xyywrap()
X{
X    /* we must return a value not equal zero to guarantee termination
X     * of ylex on some machines!
X     */
X    return(1);
X} /* yywrap */
END_OF_FILE
if test 7188 -ne `wc -c <'dcc/yyfuncts.c'`; then
    echo shar: \"'dcc/yyfuncts.c'\" unpacked with wrong size!
fi
# end of 'dcc/yyfuncts.c'
fi
if test -f 'dclocate/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dclocate/main.c'\"
else
echo shar: Extracting \"'dclocate/main.c'\" \(6640 characters\)
sed "s/^X//" >'dclocate/main.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                               m a i n . c                               *
X *                                                                         *
X *                            Package : Locator Program                    *
X *                            Version : 1.0                                *
X *                       CreationDate : 26.02.92                           *
X *                         LastUpDate : 06.03.92                           *
X *                                                                         *
X *              The routine 'main' and the global variables.               *
X *                                                                         *
X *               Copyright (C) 1992-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include "cfgparsers.h"
X#include "dclocate.h"
X#include "location.h"
X#include "version.h"
X
X/*
X * global variables
X */
X
Xint yynerrs;          /* to count the parsing errors */
Xfloat critprio_preferred;   
Xfloat critprio_wished;     
Xfloat critprio_load;        
Xfloat critprio_cload;
Xfloat critprio_crea;
Xfloat critprio_ipc;
Xfloat prio_tab[6] = PRIORITY_TAB;
Xint verbose;          /* print actions or not */
Xint show_result;      /* display resulting lists or not */
Xchar p_cfgfilename[MAXPATHNAMELEN]; /* name of program configuration file */
Xchar s_cfgfilename[MAXPATHNAMELEN]; /* name of system configuration file */
Xchar *targetfilename; /* name of target file */
XSYMBTABEL *symbtab;   /* pointer to beginning of symbol table */
XSYMBTABEL *last_symb; /* pointer to end of symbol table */
X
X/******************************************************************************
X * main()                                                                     *
X *                                                                            *
X * The function main.                                                         *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xmain(argc, argv)
Xint   argc;
Xchar *argv[];
X{
X    int i;
X    FILE *filep;
X
X    /* display start message */
X    fprintf(stderr, "%s\n%s\n%s\n\n", progname, version, copyright);
X
X    /* some initializations */
X    p_cfgfilename[0] = s_cfgfilename[0] = 0;
X    targetfilename = NULL;
X    verbose = show_result = FALSE;
X    critprio_preferred = prio_tab[0];
X    critprio_wished    = prio_tab[1];
X    critprio_load      = prio_tab[2];
X    critprio_cload     = prio_tab[3];
X    critprio_crea      = prio_tab[4];
X    critprio_ipc       = prio_tab[5];
X
X    /* is there any job? */
X    if (argc == 1) {
X	fputs("Error: nothing to do\n\n", stderr);
X	DisplayUsage();
X	exit(ERROR);
X    }
X
X    /* parse command line */
X    if (ParseOptions(argc, argv)) {
X        DisplayUsage();
X        exit(ERROR);
X    }
X
X    printf("\nPriorities of the criterions:\n");
X    printf("    %2.1f - preferred host\n", critprio_preferred);
X    printf("    %2.1f - wished ressources\n", critprio_wished);
X    printf("    %2.1f - minimum load (without)\n", critprio_load);
X    printf("    %2.1f - minimum load (with)\n", critprio_cload);
X    printf("    %2.1f - creation costs\n", critprio_crea);
X    printf("    %2.1f - ipc costs\n\n", critprio_ipc);
X
X    if (!targetfilename)
X	targetfilename = SYMBFILENAME;
X
X    /* search default files in home directory */
X    if (p_cfgfilename[0] == 0)
X	sprintf(p_cfgfilename, "%s/%s", getenv("HOME"), P_CFGFILENAME);
X    if (s_cfgfilename[0] == 0)
X	sprintf(s_cfgfilename, "%s/%s", getenv("HOME"), S_CFGFILENAME);
X
X    /* interpret system configuration file
X     * NOTE: Keep this order. The system configuration file must be
X     *       parsed BEFORE the program configuration file!
X     *       If you change the order the semantic checks during parsing
X     *       of the program configuration file will not work well.
X     */
X    printf("Parsing system configuration file  - \"%s\"\n", s_cfgfilename);
X    if (!(yyin = fopen(s_cfgfilename, "r"))) {
X	fprintf(stderr, "Error: can't open system configuration file \"%s\"\n",
X	    s_cfgfilename);
X	exit(ERROR);
X    } else {
X        (void) parse_system();
X        (void) close(yyin);
X    }
X
X    yylineno = 1;
X
X    /* interpret program configuration file */
X    printf("Parsing program configuration file - \"%s\"\n", p_cfgfilename);
X    if (!(yyin = fopen(p_cfgfilename, "r"))) {
X	fprintf(stderr, "Error: can't open program configuration file \"%s\"\n",
X	    p_cfgfilename);
X	exit(ERROR);
X    } else {
X        (void) parse_program();
X        (void) close(yyin);
X    }
X
X    if (yynerrs)
X	exit(-1);
X
X    /* Build Priority lists */
X    printf("Building priority lists\n");
X    BuildPriorityLists();
X
X    if (!(filep = fopen(targetfilename, "w"))) {
X        fprintf(stderr,"Error: impossible to open data file '%s'\n", targetfilename);
X        exit(-1);
X    }
X
X    /* Save symbol table */
X    printf("Saving informations in file - \"%s\"\n", targetfilename);
X    SaveSymbtab(filep);
X
X    /* Save priority values */
X    fprintf(filep, "%f %f %f %f %f %f\n",
X	critprio_preferred, critprio_wished, critprio_load,
X	critprio_cload, critprio_crea, critprio_ipc);
X
X    fclose(filep);
X
X    exit(OK);
X} /* main */
END_OF_FILE
if test 6640 -ne `wc -c <'dclocate/main.c'`; then
    echo shar: \"'dclocate/main.c'\" unpacked with wrong size!
fi
# end of 'dclocate/main.c'
fi
if test -f 'examples/philo/philo.dc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/philo/philo.dc'\"
else
echo shar: Extracting \"'examples/philo/philo.dc'\" \(7299 characters\)
sed "s/^X//" >'examples/philo/philo.dc' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                            p h i l o . d c                              *
X *                                                                         *
X *                 Version 1.0      CreationDate: 22.07.90                 *
X *                                    LastUpDate: 18.10.90                 *
X *                                                                         *
X *                     The mortal dining philosophers.                     *
X *                                                                         *
X ***************************************************************************/
X
X/* define DEBUG to display additional runtime information */
X/* #define DEBUG /**/
X
X/* how often the philosophers eat */
X#define LIFE_LIMIT	30
X
X/* how long the philosophers think */
X#define THINK_DELAY	0
X
X#ifdef DEBUG
X# define DEBUGOUT(msg)	{printf("%s: %s\n", _processprefix, msg); \
X			fflush(stdout);}
X# define DEBUGPRINT(x)	{printf x; \
X			 fflush(stdout);}
X#else
X# define DEBUGOUT(msg)  /* nothing */
X# define DEBUGPRINT(x)  /* nothing */ 
X#endif /* DEBUG /**/
X
X/****************************************************************************
X *         name : fork                                                      *
X *         type : process specification                                     *
X *   returntype : none                                                      *
X *   parameters : none                                                      *
X *  description : Specification of the fork process with the transactions   *
X *                pick_up and put_down.                                     *
X ****************************************************************************/
Xprocess spec fork()
X{
X	trans void pick_up();
X	trans void put_down();
X}
X
X/****************************************************************************
X *         name : philosopher                                               *
X *         type : process specification                                     *
X *   returntype : none                                                      *
X *   parameters : int id, process fork left, process fork right             *
X *  description : Specification of the philosopher process.                 *
X ****************************************************************************/
Xprocess spec philosopher (int id, process fork left, process fork right);
X
X/****************************************************************************
X *         name : fork                                                      *
X *         type : process definition                                        *
X *   returntype : none                                                      *
X *   parameters : none                                                      *
X *  description : Definition of the body of the fork process including      *
X *                the bodies of the transactions (accept statements).       *
X ****************************************************************************/
Xprocess body fork()
X{
X	for(;;) {
X	    select {
X		    accept pick_up;
X		    DEBUGOUT("transaction pick_up accepted");
X		    accept put_down;
X		    DEBUGOUT("transaction put_down accepted");
X		or
X		    terminate
X	    } /* select */
X	} /* for */
X} /* process body fork */
X
X/****************************************************************************
X *         name : philosopher                                               *
X *         type : process definition                                        *
X *   returntype : none                                                      *
X *   parameters : id, left, right                                           *
X *  description : Definition of the body of the fork process.               *
X ****************************************************************************/
Xprocess body philosopher(id, left, right)
X{
X	int times_eaten = 1, 
X	    erg;
X
X	while(times_eaten <= LIFE_LIMIT) {
X	    /* enter dining room */
X	    /* pick up forks */
X		DEBUGOUT("trying to pick up right fork");
X		right@pick_up(); 
X		DEBUGOUT("right fork picked up");
X		DEBUGOUT("trying to pick up left fork");
X		erg = within 5 ? (left@pick_up() : -1);
X		if (erg == -1) {
X		    DEBUGOUT("giving up");
X		    DEBUGOUT("trying to put down right fork");
X		    right@put_down();
X		    DEBUGOUT("right fork putted down");
X		    continue;
X		}
X		DEBUGOUT("left fork picked up");
X	    /* eat */
X#ifdef DEBUG
X		DEBUGOUT("EATING");
X#else
X		printf("Philosopher %d: *eating* (%d)\n", id, times_eaten);
X		fflush(stdout);
X#endif
X	    /* put down forks */
X		DEBUGOUT("trying to put down left fork");
X		left@put_down();
X		DEBUGOUT("left fork putted down");
X		DEBUGOUT("trying to put down right fork");
X		right@put_down();
X		DEBUGOUT("right fork putted down");
X	    /* get up and leave dining room */
X#ifdef DEBUG
X		DEBUGOUT("THINKING");
X#else
X		printf("Philosopher %d: *thinking*\n", id);
X		fflush(stdout);
X#endif
X		sleep(THINK_DELAY);
X		times_eaten++;
X	} /* while */
X#ifdef DEBUG
X	DEBUGOUT("GOOD BYE");
X#else
X	printf("Philosopher %d: See you in the next world.\n", id);
X#endif
X	/* Note: It is very important to terminate processes by exit()
X	 *       The only exception are processes with select statements
X	 *       containing accept or terminate alternatives (e.g. fork)
X	 */
X	exit(0);
X} /* process body philosopher */
X
X/****************************************************************************
X *         name : main                                                      *
X *         type : function definition                                       *
X *   returntype : int                                                       *
X *   parameters : none                                                      *
X *  description : Definition of the main function building the main program.*
X ****************************************************************************/
Xmain()
X{
X	process fork f[50];
X	int philanz, j;
X
X	puts("The mortal dining philosophers:\n");
X	do {
X		printf("number of philosophers (2...20)? ");
X		scanf("%d", &philanz);
X	} while(philanz < 2 || philanz > 20);
X	/* first create the forks, then create the philosophers.
X	 * choose the hosts where to create the processes by file 
X	 */
X	for(j=0; j<philanz; j++) 
X		f[j] = create fork();
X	for(j=0; j<philanz; j++) {
X		create philosopher(j, f[j], f[(j+1) % philanz]);
X	}
X	/* Note: It is also very important to terminate the function main
X	 *       by exit(). Don't use return statements to return from main!
X	 */
X	exit(0);
X} /* main */
END_OF_FILE
if test 7299 -ne `wc -c <'examples/philo/philo.dc'`; then
    echo shar: \"'examples/philo/philo.dc'\" unpacked with wrong size!
fi
# end of 'examples/philo/philo.dc'
fi
if test -f 'examples/test/xdr.dc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'examples/test/xdr.dc'\"
else
echo shar: Extracting \"'examples/test/xdr.dc'\" \(6967 characters\)
sed "s/^X//" >'examples/test/xdr.dc' <<'END_OF_FILE'
X/* xdr.dc */
X
X/* in the heterogenous version, the following data types can be used
X * as process or transaction parameters or transaction results:
X * (a) elementar types:
X *     char,     unsigned char
X *     short,    unsigned short
X *     int,      unsigned int
X *     long,     unsigned long
X *     float,
X *     double
X * (b) structure definitions without pointers (!) and without multidimensional
X *     arrays
X * (c) type definitions of elemental types or structure defs (no pointer!)
X */
X
X/* 
X * valid typedefs for heterogenous data transfer 
X */
X
Xtypedef unsigned char  U_CHAR;
Xtypedef unsigned short U_SHORT;
Xtypedef unsigned int   U_INT;
Xtypedef unsigned long  U_LONG;
Xtypedef long           *LONGPTR;
Xtypedef unsigned int   *UINTPTR;
X
X/* 
X * illegal typedefs for heterogenous data transfer 
X */
X
Xtypedef unsigned int *U_INTPTR;
Xtypedef int (* FKTPTR)();
X
X/* 
X * valid structure definitions for heterogenous data transfer 
X */
X
X/* elementar data types (standard format) */
Xstruct struct_1_t {
X	char   e_char;
X	short  e_short;
X	int    e_int;
X	long   e_long;
X	float  e_float;
X	double e_double;
X};
X
X/* elementar data types (unsigned) */
Xstruct struct_2_t {
X	char  signed_char;
X	short signed_short;
X	int   signed_int;
X	long  signed_long;
X	unsigned char  unsigned_char;
X	unsigned short unsigned_short;
X	unsigned int   unsigned_int;
X	unsigned long  unsigned_long;
X};
X
X/* identifier lists */
Xstruct struct_3_t {
X	int a;
X	int b1, b2;
X	int c1, c2, c3;
X};
X
X/* defined types inside structure defs */
Xstruct struct_4_t {
X	U_INT a;
X	U_SHORT b;
X	double c, d;
X};
X
X/* nested structure defs */
Xstruct struct_5_t {
X	char a;
X	struct struct_51_t {
X		short a;
X		struct struct_511_t {
X			int a;
X			struct struct_5111_t {
X				long a;
X				struct struct_51111_t {
X					float a;
X				} s51111;
X			} s5111;
X		} s511;
X	} s51;
X};
X
X/* arrays */
Xstruct struct_7_t {
X	int a[100];
X	float b[200];
X	unsigned long c[300];
X	struct struct_4_t d[400];
X};
X
X/* pointers */
Xtypedef struct struct_8_t {
X	int *ptr1;
X	double *ptr2;
X	unsigned int *ptr3;
X	struct struct_7_t *ptr4;
X	LONGPTR ptr5;
X	UINTPTR ptr6;
X} STRUCT_8;
X
Xtypedef struct list_t {
X	char name[100];
X	struct list_t *next;
X} LIST;
X
X
X/* all mixed */
Xtypedef struct struct_6_t {
X	int a, b;
X	U_LONG c;
X	struct struct_5_t s5;
X	struct struct_61_t {
X		double x, y, z;
X	} s61;
X	struct struct_4_t s4;
X	struct struct_7_t s7;
X	/* struct struct_8_t s8; */
X} STRUCT_6;
X
Xtypedef struct struct_5_t STRUCT_5;
X	
Xprocess spec receiver()
X{
X    trans STRUCT_6 T1(struct struct_6_t s6);
X    trans struct struct_8_t T2(STRUCT_8 s8);
X    trans int T3(LIST list);
X}
X
Xprocess spec sender(process receiver r_pdescr, char par1, short par2, int par3,
X					 long par4, float par5, double par6);
X
Xprocess body receiver()
X{
X    int i;
X    LIST *lptr;
X
X    accept T1(s6) {
X        printf("%s s6.a = %d (100 - int)\n", 
X		_processprefix, s6.a);
X        printf("%s s6.b = %d (-100 - int)\n", 
X		_processprefix, s6.b);
X        printf("%s s6.c = %d (1000000 - unsigned long)\n",
X		_processprefix, s6.c);
X        printf("%s s6.s5.a = %d (111 - char)\n", 
X		_processprefix, s6.s5.a);
X        printf("%s s6.s5.s51.a = %d (-10 - short)\n", 
X		_processprefix, s6.s5.s51.a);
X        printf("%s s6.s5.s51.s511.a = %d (10000 - int)\n", 
X		_processprefix, s6.s5.s51.s511.a);
X        printf("%s s6.s5.s51.s511.s5111.a = %d (12345678 - long)\n", 
X		_processprefix, s6.s5.s51.s511.s5111.a);
X        printf("%s s6.s5.s51.s511.s5111.s51111a = %f (0.123456 - float)\n", 
X		_processprefix, s6.s5.s51.s511.s5111.s51111.a);
X        printf("%s s6.s61.x = %f (-1.23456 - float)\n", 
X		_processprefix, s6.s61.x);
X        printf("%s s6.s61.y = %f (0.0 - float)\n", 
X		_processprefix, s6.s61.y);
X        printf("%s s6.s61.z = %f (1.23456 - float)\n", 
X		_processprefix, s6.s61.z);
X        printf("%s s6.s4.a = %d (250 - unsigned char)\n", 
X		_processprefix, s6.s4.a);
X        printf("%s s6.s4.b = %d (10 - unsigned short)\n", 
X		_processprefix, s6.s4.b);
X        printf("%s s6.s4.c = %f (0.12345678901234 - double)\n", 
X		_processprefix, s6.s4.c);
X        printf("%s s6.s4.d = %f (1E+30 - double)\n", 
X		_processprefix, s6.s4.d);
X    }
X    accept T2(s8) {
X	printf("%s *s8.ptr1 = %d (100 - *int)\n",
X		_processprefix, *(s8.ptr1));
X	printf("%s *s8.ptr2 = %.10f (0.12345678 - *double)\n",
X		_processprefix, *(s8.ptr2));
X	printf("%s *s8.ptr3 = %d (40000 - *unsigned int)\n",
X		_processprefix, *(s8.ptr3));
X	for(i=0; i<100; i++)
X	    printf("%s s8.ptr4->a[%d] = %d (*int[])\n",
X		_processprefix, i, s8.ptr4->a[i]);
X    }
X    printf("%s Dynamic list:\n", _processprefix);
X    accept T3(list) {
X	for(lptr = &list; lptr; lptr = lptr->next) 
X	    printf("%s     %s\n", _processprefix, lptr->name);
X    }
X}
X
Xprocess body sender()
X{
X    STRUCT_6 out, in;
X    int i, ptr1 = 100;
X    double ptr2 = 0.12345678;
X    unsigned int ptr3 = 40000;
X    struct struct_7_t ptr4;
X    STRUCT_8 s8_out, s8_in;
X    LIST list, *nptr, *lptr;
X
X    printf("%s checking parameters:\n", _processprefix);
X    printf("%s par1 (char)   is %d (should be 100)\n", _processprefix, par1);
X    printf("%s par2 (short)  is %d (should be -10)\n", _processprefix, par2);
X    printf("%s par3 (int)    is %d (should be 32000)\n", _processprefix, par3);
X    printf("%s par4 (long)   is %d (should be 1000000)\n", _processprefix, par4);
X    printf("%s par5 (float)  is %.8f (should be 1.0001)\n", _processprefix, par5);
X    printf("%s par6 (double) is %.8f (should be 1.0000001)\n", _processprefix, par6);
X    out.a =  100; /* int */
X    out.b = -100; /* int */
X    out.c = 1000000L; /* unsigned long */
X    out.s5.a = 111; /* char */
X    out.s5.s51.a = -10; /* short */
X    out.s5.s51.s511.a = 10000; /* int */
X    out.s5.s51.s511.s5111.a = 12345678; /* long */
X    out.s5.s51.s511.s5111.s51111.a = 0.123456; /* float */
X    out.s61.x = -1.23456; /* float */
X    out.s61.y =  0.0; /* float */
X    out.s61.z =  1.23456; /* float */
X    out.s4.a = 250; /* unsigned char */
X    out.s4.b = 10; /* unsigned short */
X    out.s4.c = 0.12345678901234; /* double */
X    out.s4.d = 1E+30; /* double */
X    r_pdescr@T1(out);
X
X    for(i=0; i<100; i++)
X	    ptr4.a[i] = i;
X    s8_out.ptr1 = &ptr1; 
Xprintf("sender: *s8_out.ptr1 = %d\n", *s8_out.ptr1); fflush(stdout);
X	s8_out.ptr2 = &ptr2;
X	s8_out.ptr3 = &ptr3;
X	s8_out.ptr4 = &ptr4;
X	r_pdescr@T2(s8_out);
X
X    /* build list */
X    strcpy(list.name, "list element 0");
X    lptr = &list;
X    for(i=1; i<=5; i++) {
X	nptr = (LIST *) malloc(sizeof(LIST));
X	sprintf(nptr->name, "list element %d", i);
X	nptr->next = NULL;
X	lptr->next = nptr;
X	lptr = nptr;
X    }
X    r_pdescr@T3(list);
X}
X
Xmain()
X{
X    process sender   s_pdescr;
X    process receiver r_pdescr;
X
X    /* create all receiver processes */
X    printf("%s creating process 'receiver'\n", _processprefix);
X    r_pdescr = create receiver() local;
X
X    /* create sender process */
X    printf("%s creating process 'sender' local\n", _processprefix);
X    s_pdescr = create sender(r_pdescr, 100, -10, 32000, 1000000, 1.0001, 
X							      1.0000001) local;
X
X	
X}
END_OF_FILE
if test 6967 -ne `wc -c <'examples/test/xdr.dc'`; then
    echo shar: \"'examples/test/xdr.dc'\" unpacked with wrong size!
fi
# end of 'examples/test/xdr.dc'
fi
if test -f 'include/com_errlist.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/com_errlist.h'\"
else
echo shar: Extracting \"'include/com_errlist.h'\" \(7311 characters\)
sed "s/^X//" >'include/com_errlist.h' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                      c o m _ e r r l i s t . h                          *
X *                                                                         *
X *                            Package : Include files                      *
X *                            Version : 1.0                                *
X *                       CreationDate : 14.08.90                           *
X *                         LastUpDate : 30.08.91                           *
X *                                                                         *
X *            The table containing the compiler error messages.            *
X *                                                                         *
X *      Copyright (C) 1990-1994 by Franz Distler and Christoph Pleier.     *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#ifndef __com_errlist_h
X#define __com_errlist_h
X
Xchar *compiler_errlist[] = {
X
X   /* ESYNTAX */
X   "syntax error",
X
X   /* EREDEFINITION */
X   "redefinition",
X
X   /* ENOTSPECIFIED */
X   "not specified",
X
X   /* EREDEFINED */
X   "process body redefined",
X
X   /* ENOTDEFINED */
X   "process not defined",
X
X   /* EILLTRANSCALL */
X   "no transaction",
X
X   /* EBADLYACCEPT */
X   "badly placed accept",
X
X   /* ENOVARORPAR */
X   "no variable and no parameter",
X
X   /* EINPROCSPEC */
X   "garbage before identifier of process specification",
X
X   /* EPROCPAREXP */
X   "parameter declaration expected",
X
X   /* EPROCPAREXP2 */
X   "garbage before parameter declaration",
X
X   /* EINPROCPARAM */
X   "in process parameter declaration",
X
X   /* EPROCTRANSEXP */
X   "transaction declaration expected",
X
X   /* EPROCTRANSEXP2 */
X   "garbage before transaction declaration",
X
X   /* EINTRANSDECL */
X   "in transaction declaration after keyword 'trans'",
X
X   /* EINTRANSDECL2 */
X   "in transaction declaration between 'trans' and transaction identifier",
X
X   /* EINTRANSDECL3 */
X   "garbage before identifier of transaction declaration",
X
X   /* EINPROCDEF */
X   "garbage before identifier of process definition",
X
X   /* EINACCSTAT */
X   "in accept statement after keyword 'accept'",
X
X   /* EINACCSTAT2 */
X   "in accept statement between 'accept' and transaction identifier",
X
X   /* EINACCSTAT3 */
X   "in accept statement between transaction identifier and parameters",
X
X   /* EINACCSTAT4 */
X   "in or near compound statement of accept statement",
X
X   /* EINSELSTAT */
X   "in select statement after keyword 'select'",
X
X   /* EINSELSTAT2 */
X   "in select statement before keyword 'or'",
X
X   /* EINSELPART */
X   "in select statement", 
X
X   /* EINACCALTERN */
X   "in accept alternative",
X
X   /* EINDESTRSTAT */
X   "in destroy statement",
X
X   /* EINTIMEDTRANS */
X   "in timed transaction call",
X
X   /* EINPROCCREATE */
X   "in process creation statement after keyword 'create'",
X
X   /* EINPROCCREATE2 */
X   "in process creation statement between 'create' and process identifier",
X
X   /* EINPROCCREATE3 */
X   "in process creation statement between process identifier and parameters",
X
X   /* EINPROCARGS */
X   "in process arguments",
X
X   /* EINPROCLOC */
X   "in process creation statement: wrong process location specification",
X
X   /* EINTRANSCALL */
X   "in transaction call",
X
X   /* EILLCONST */
X   "'const' is not allowed in structure definitions",
X
X   /* EILLVOLATILE */
X   "'volatile' is not allowed in structure definitions",
X
X   /* EILLVOID */
X   "'void' is not allowed in structure definitions",
X
X   /* EILLCHAR */
X   "too many type specifiers at 'char'",
X
X   /* EILLSHORT */
X   "too many type specifiers at 'short'",
X
X   /* EILLINT */
X   "too many type specifiers at 'int'",
X
X   /* EILLLONG */
X   "error: too many type specifiers at 'long'",
X
X   /* EILLFLOAT */
X   "too many type specifiers at 'float'",
X
X   /* EILLDOUBLE */
X   "too many type specifiers at 'double'",
X
X   /* EILLPROCESS */
X   "too many type specifiers at 'process'",
X
X   /* EILLSIGNED */
X   "badly placed 'signed'",
X
X   /* EILLUNSIGNED */
X   "badly placed 'unsigned'",
X
X   /* EILLENUM */
X   "enumerations are not allowed in special used structures",
X
X   /* EILLBITFIELD */
X   "bitfields are not allowed in special used structures",
X
X   /* EILLPOINTER */
X   "illegal pointer",
X
X   /* EMANYPOINTER */
X   "too many pointers in special used structure",
X
X   /* EILLPOINTQUAL */
X   "type qualifier in combination with pointer is not allowed here",
X
X   /* EILLFUNCTION */
X   "function definitions are not allowed in special used structures",
X
X   /* EILLARRAY */
X   "arrays are not allowed in special used structures",
X
X   /* EARRAYSIZE */
X   "unknown array size",
X
X   /* EILLARRBRACES */
X   "braces '(' ')' are not allowed in combination with arrays",
X
X   /* EILLARRFUNCT */
X   "function definitions are not allowed before arrays",
X
X   /* EMULTIARRAY */
X   "multiple dimensional arrays are not allowed here",
X
X   /* EILLBRACES */
X   "braces '(' ')' are not allowed in special used structures",
X
X   /* EILLTYPENAME */
X   "typedef names are not allowed in special used structures",
X
X   /* EILLAUTO */
X   "'auto' is not allowed in special used typedefs",
X
X   /* EILLREGISTER */
X   "'register' is not allowed in special used typedefs",
X
X   /* EILLSTATIC */
X   "'static' is not allowed in special used typedefs",
X
X   /* EILLEXTERN */
X   "'extern' is not allowed in special used typedefs",
X
X   /* EILLTYPEDEF */
X   "illegal typedef",
X
X   /* EILLCONST2 */
X   "'const' is not allowed in special used typedefs",
X
X   /* EILLVOLATILE2 */
X   "'volatile' is not allowed in special used typedefs",
X
X   /* EILLVOID2 */
X   "'void' is not allowed in special used typedefs",
X
X   /* EILLENUM2 */
X   "enumerations are not allowed in special used typedefs",
X
X   /* EISTRUCTTAG */
X   "all structure definitions inside this structure require tag names",
X
X   /* ETSTRUCTTAG */
X   "structure definition of this type definition requires tag name",
X
X   /* FCANTRECOVER */
X   "cannot recover from error(s). Good bye.",
X
X   /* WPROCESSARGS */
X   "too few arguments for process creation",
X
X   /* WTRANSARGS */
X   "too few arguments for transaction call"
X};
X
X#endif /* !__com_errlist_h /**/
END_OF_FILE
if test 7311 -ne `wc -c <'include/com_errlist.h'`; then
    echo shar: \"'include/com_errlist.h'\" unpacked with wrong size!
fi
# end of 'include/com_errlist.h'
fi
if test -f 'include/run_Errno.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/run_Errno.h'\"
else
echo shar: Extracting \"'include/run_Errno.h'\" \(6888 characters\)
sed "s/^X//" >'include/run_Errno.h' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                         r u n _ E r r n o . h                           *
X *                                                                         *
X *                            Package : Include files                      *
X *                            Version : 1.0                                *
X *                       CreationDate : 10.07.90                           *
X *                         LastUpDate : 12.03.92                           *
X *                                                                         *
X *                     Error codes of runtime errors.                      *
X *                                                                         *
X *      Copyright (C) 1990-1994 by Franz Distler and Christoph Pleier.     *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#ifndef __run_Errno_h
X#define __run_Errno_h
X
X/* 
X * fatal errors 
X */
X
X/* fatal error */
X#define EFATAL		0
X
X/* system dependent error */
X#define ESYSTEMDPNT 	1
X
X/* 
X * message passing errors 
X */
X
X/* error creating a port */
X#define ECREATEPORT	2
X
X/* error deleting a port */
X#define EDELETEPORT	3
X
X/* error accepting a connection */
X#define EACPTCON	4
X
X/* error making a connection */
X#define EMAKECON	5
X
X/* error closing a connection */
X#define ECLOSECON	6
X
X/* error receiving data */
X#define ERECVDATA	7
X
X/* error sending data */
X#define ESENDDATA	8
X
X/* connection refused */
X#define ECONREFUSED	9
X
X/* operation timed out */
X#define ETIMEOUT	10
X
X/* 
X * timeout errors:
X */
X
X/* prefix ETC means Error Timeout during process Creation 
X * prefix ETT means Error Timeout during Transaction call
X * prefix ETA means Error Timeout during Accepting transaction
X * prefix ETS means Error Timeout during Select statement
X */
X
X/* connection request of new process timed out */
X#define ETCCPTONPACC	11
X
X/* connection attempt to new process timed out */
X#define ETCCPTONPCON	12	/* iPSC only! */
X
X/* attempt to receive data of new process timed out*/
X#define ETCCPTONPRCV	13
X
X/* attempt to send initial parameters timed out */
X#define ETCCPTONPPAR	14
X
X/* attempt to send port information to new process timed out */
X#define ETCCPTONPPDAT	15	/* iPSC only! */
X
X/* connection attempt to administration process timed out */
X#define ETCCPTOAPCON	16
X
X/* attempt to send location request to administration process timed out */
X#define ETCCPTOAPREQ	17
X
X/* attempt to send processname to administration process timed out */
X#define ETCCPTOAPSND	18
X
X/* attempt to receive location info from administration process timed out */
X#define ETCCPTOAPRCV	19
X
X/* connection to administration process timed out */
X#define ETCNPTOAPCON	20
X
X/* attempt to send request type to administration process timed out */
X#define ETCNPTOAPREQ	21
X
X/* attempt to send process data to administration process timed out */
X#define ETCNPTOAPSND	22
X
X/* connection to creator process timed out */
X#define ETCNPTOCPCON	23
X
X/* attempt to accept a connection from the creator process timed out */
X#define ETCNPTOCPACC	24
X
X/* attempt to send process adress timed out */
X#define ETCNPTOCPSND	25
X
X/* receiving parameters timed out */
X#define ETCNPGETPARA	26
X
X/* receiving port information timed out */
X#define ETCNPGETPDAT	27
X
X/* error connecting to called process */
X#define ETTCONTOPROC	28
X
X/* error sending transaction request */
X#define ETTSNDREQUEST	29
X
X/* error receiving reply message of called process */
X#define ETTRCVREPLY	30
X
X/* error sending transaction arguments */
X#define ETTSENDARGS	31
X
X/* receiving transaction result timed out */
X#define ETTRCVRESULT	32
X
X/* accepting transaction request timed out */
X#define ETAACCEPTCON	33
X
X/* receiving transaction request timed out */
X#define ETARCVREQUEST	34
X
X/* attempt to send reply message timed out */
X#define ETASENDREPLY	35
X
X/* attempt to receive parameters timed out */
X#define ETARCVPARAMS	36
X
X/* attempt to send transaction result timed out */
X#define ETASNDRESULT	37
X
X/* accepting transaction request timed out */
X#define ETSACCEPTCON	38
X
X/* receiving transaction request timed out */
X#define ETSRCVREQUEST	39
X
X/* attempt to send reply message timed out */
X#define ETSSENDREPLY	40
X
X/* attempt to receive parameters timed out */
X#define ETSRCVPARAMS	41
X
X/* attempt to send transaction result timed out */
X#define ETSSNDRESULT	42
X
X/* connection attempt of admin process to creator process timed out */
X#define ETCAPTOCPCON	43
X
X/* attempt to get connection to receive configuration filename timed out */
X#define ETCAPTOCPACC	44
X
X/* attempt to get connection to receive configuration filename timed out */
X#define  ETCAPTOCPRCV	45
X
X/* attempt to receive processname to determine location of */
X#define  ETCADRCVNAME	46
X
X/* attempt to receive processname to determine location of */
X#define  ETCADSNDLOC	47
X
X/* attempt to send connection type timed out */
X#define ETCONNTYPESND	48
X
X/* attempt to receive connection type timed out */
X#define ETCONNTYPERCV	49
X
X/*
X * other errors
X */
X
X/* process stopped during transaction execution */
X#define EPROCSTOPPED	50
X
X/* new process can't be created */
X#define EPROCESSCREAT	51
X
X/* process can't be destroyed */
X#define EPROCESSKILL	52
X
X/* process can't be transformed to new process (execv) */
X#define EEXECPROCESS	53
X
X/* hostname can't be determined */
X#define EHOSTNAME	54
X
X/* error allocating heap space for encode/decode buffer */
X#define EMALLOCBUF	55
X
X/* error encoding data */
X#define EENCODE		56
X
X/* resulting size of converted data is too large */
X#define EENCODESIZE	57
X
X/* error decoding data */
X#define EDECODE		58
X
X/* error: xdr_setpos() does not work! */
X#define EXDRSETPOS	59
X
X
X#endif /* !__run_Errno_h /**/
END_OF_FILE
if test 6888 -ne `wc -c <'include/run_Errno.h'`; then
    echo shar: \"'include/run_Errno.h'\" unpacked with wrong size!
fi
# end of 'include/run_Errno.h'
fi
echo shar: End of archive 6 \(of 18\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
