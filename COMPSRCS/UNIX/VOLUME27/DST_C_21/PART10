Newsgroups: comp.sources.unix
From: pleierc@informatik.tu-muenchen.de (Christoph Pleier)
Subject: v27i184: distributed-c-2.1 - Distributed C Development Environment, V2.1, Part10/18
References: <1.756634932.28500@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: pleierc@informatik.tu-muenchen.de (Christoph Pleier)
Posting-Number: Volume 27, Issue 184
Archive-Name: distributed-c-2.1/part10

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 10 (of 18)."
# Contents:  CONTENTS config/SaveSymbtab.c dcc/code_process.c
#   dcc/includefile.c include/cfgparsers.h lib/transaction.c
# Wrapped by vixie@gw.home.vix.com on Thu Dec 23 00:12:02 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'CONTENTS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'CONTENTS'\"
else
echo shar: Extracting \"'CONTENTS'\" \(13731 characters\)
sed "s/^X//" >'CONTENTS' <<'END_OF_FILE'
XThe Distributed C package consists of the following files:
X 
X-rw-r--r--   1 pleierc  wiss          61 Dec 21 15:51 CONTENTS
X-rw-r--r--   1 pleierc  wiss        5730 Dec 19 21:06 DEFINES
X-rw-r--r--   1 pleierc  wiss        1506 Dec 19 21:10 INSTALLATION
X-rw-r--r--   1 pleierc  wiss        5111 Dec 20 13:41 Makefile
X-rw-r--r--   1 pleierc  wiss         769 Dec 19 21:12 Makefile.doc
X-rw-r--r--   1 pleierc  wiss         658 Dec 21 15:35 Makefile.msg
X-rw-r--r--   1 pleierc  wiss        6833 Dec 21 15:51 NOTES
X-rw-r--r--   1 pleierc  wiss        3438 Dec 19 21:20 OVERVIEW
X-rw-r--r--   1 pleierc  wiss        2412 Dec 19 21:17 README
X-rw-r--r--   2 pleierc  wiss        2722 Dec 21 15:00 macros
X-rw-r--r--   1 pleierc  wiss        2651 Dec 21 15:32 macros.AIX
X-rw-r--r--   1 pleierc  wiss        2662 Dec 21 15:01 macros.CONVEX
X-rw-r--r--   2 pleierc  wiss        2722 Dec 21 15:00 macros.HPUX
X-rw-r--r--   1 pleierc  wiss        2620 Dec 21 15:02 macros.LINUX
X-rw-r--r--   1 pleierc  wiss        3585 Dec 21 15:03 macros.README
X-rw-r--r--   1 pleierc  wiss        2634 Dec 21 15:11 macros.SPARC
X-rw-r--r--   1 pleierc  wiss        2510 Dec 21 15:04 macros.ULTRIX
X-rw-r--r--   1 pleierc  wiss        2631 Dec 21 15:04 macros.UNICOS
X-rw-r--r--   1 pleierc  wiss        2644 Dec 16 14:08 macros.UNIX
X-rw-r--r--   1 pleierc  wiss        2435 Dec 16 14:08 macros.XENIX
X-rw-r--r--   1 pleierc  wiss        2244 Dec 16 14:08 macros.iPSC
X
Xbin:
Xtotal 4
X-rwxr-----   1 pleierc  wiss         253 Oct 22 13:18 killdcadmins
X-rwxr--r--   1 pleierc  wiss         212 Dec  7 15:10 subst
X
Xconfig:
Xtotal 220
X-rw-r--r--   1 pleierc  wiss        3577 Dec  7 15:33 Makefile
X-rw-r--r--   1 pleierc  wiss       16007 Dec  7 15:33 ReadSymbtab.c
X-rw-r--r--   1 pleierc  wiss       13065 Dec  7 15:33 SaveSymbtab.c
X-rw-r--r--   1 pleierc  wiss        9082 Dec  7 15:33 debug.c
X-rw-r--r--   1 pleierc  wiss        6298 Dec  7 15:33 program.y
X-rw-r--r--   1 pleierc  wiss        6593 Dec  7 15:33 scanner.l
X-rw-r--r--   1 pleierc  wiss        6751 Dec  7 15:33 symb_general.c
X-rw-r--r--   1 pleierc  wiss       10681 Dec  7 15:33 symb_program.c
X-rw-r--r--   1 pleierc  wiss       16203 Dec  7 15:33 symb_system.c
X-rw-r--r--   1 pleierc  wiss        8845 Dec 20 12:40 system.y
X-rw-r--r--   1 pleierc  wiss        6243 Dec  7 15:33 util.c
X-rw-r--r--   1 pleierc  wiss        3503 Dec  7 15:33 yyfuncts.c
X
Xdcadmin:
Xtotal 200
X-rw-r--r--   1 pleierc  wiss        4004 Dec  7 15:31 CheckAcOrTer.c
X-rw-r--r--   1 pleierc  wiss        4895 Dec  7 15:31 GetCfgFile.c
X-rw-r--r--   1 pleierc  wiss        4207 Dec  7 15:31 Kill.c
X-rw-r--r--   1 pleierc  wiss       15073 Dec  7 15:31 Location.c
X-rw-r--r--   1 pleierc  wiss        4454 Dec 21 15:49 Makefile
X-rw-r--r--   1 pleierc  wiss        7104 Dec  7 15:31 ProcessList.c
X-rw-r--r--   1 pleierc  wiss        4637 Dec  7 15:31 Shutdown.c
X-rw-r--r--   1 pleierc  wiss        7800 Dec  7 15:31 Status.c
X-rw-r--r--   1 pleierc  wiss        3503 Dec  7 15:31 Usage.c
X-rw-r--r--   1 pleierc  wiss        3561 Dec  7 15:31 configure.l
X-rw-r--r--   1 pleierc  wiss        6301 Dec  7 15:31 configure.y
X-rw-r--r--   1 pleierc  wiss        5807 Dec  7 15:31 debug.c
X-rw-r--r--   1 pleierc  wiss        4019 Dec 21 14:31 error.c
X-rw-r--r--   1 pleierc  wiss       16102 Dec 19 22:28 main.c
X-rw-r--r--   1 pleierc  wiss        4631 Dec  7 15:31 signals.c
X
Xdcanalyse:
Xtotal 50
X-rw-r--r--   1 pleierc  wiss        4654 Dec 20 11:54 Makefile
X-rw-r--r--   1 pleierc  wiss        4957 Dec  7 15:35 ParseOptions.c
X-rw-r--r--   1 pleierc  wiss        3482 Dec  7 15:35 Usage.c
X-rw-r--r--   1 pleierc  wiss       11121 Dec  7 15:35 dcanalyse.dc
X
Xdcc:
Xtotal 796
X-rw-r--r--   1 pleierc  wiss        6387 Dec 20 10:53 Makefile
X-rw-r--r--   1 pleierc  wiss        3695 Dec  7 15:30 Malloc.c
X-rw-r--r--   1 pleierc  wiss        5087 Dec  7 15:30 String.c
X-rw-r--r--   1 pleierc  wiss        4658 Dec  7 15:30 attr_debug.c
X-rw-r--r--   1 pleierc  wiss       35350 Dec  7 15:30 attr_decl.c
X-rw-r--r--   1 pleierc  wiss       16526 Dec  7 15:30 attr_general.c
X-rw-r--r--   1 pleierc  wiss       24017 Dec  7 15:30 code_convert.c
X-rw-r--r--   1 pleierc  wiss        9101 Dec  7 15:30 code_create.c
X-rw-r--r--   1 pleierc  wiss        4720 Dec  7 15:30 code_decl.c
X-rw-r--r--   1 pleierc  wiss        3500 Dec  7 15:30 code_destroy.c
X-rw-r--r--   1 pleierc  wiss       12215 Dec 20 10:48 code_others.c
X-rw-r--r--   1 pleierc  wiss       13664 Dec  7 15:30 code_process.c
X-rw-r--r--   1 pleierc  wiss       12482 Dec  7 15:30 code_select.c
X-rw-r--r--   1 pleierc  wiss       17142 Dec  7 15:30 code_trans.c
X-rw-r--r--   1 pleierc  wiss        5800 Dec  7 15:30 dcc.l
X-rw-r--r--   1 pleierc  wiss       42425 Dec  7 15:30 dcc.y
X-rw-r--r--   1 pleierc  wiss        5298 Dec  7 15:30 files.c
X-rw-r--r--   1 pleierc  wiss        4341 Dec  7 15:30 help.c
X-rw-r--r--   1 pleierc  wiss       12548 Dec 19 22:15 includefile.c
X-rw-r--r--   1 pleierc  wiss        2134 Dec  7 15:30 lex.dummy.c
X-rw-r--r--   1 pleierc  wiss        6713 Dec 20 10:52 main.c
X-rw-r--r--   1 pleierc  wiss       10994 Dec  7 15:30 makefile.c
X-rw-r--r--   1 pleierc  wiss        7051 Dec  7 15:30 parseoptions.c
X-rw-r--r--   1 pleierc  wiss        4995 Dec  7 15:30 signal.c
X-rw-r--r--   1 pleierc  wiss        9368 Dec  7 15:30 symb_debug.c
X-rw-r--r--   1 pleierc  wiss       12189 Dec  7 15:30 symb_general.c
X-rw-r--r--   1 pleierc  wiss       18843 Dec 21 10:20 symb_others.c
X-rw-r--r--   1 pleierc  wiss       29410 Dec  7 15:30 symb_process.c
X-rw-r--r--   1 pleierc  wiss        4221 Dec  7 15:30 usage.c
X-rw-r--r--   1 pleierc  wiss        6657 Dec  7 15:30 util.c
X-rw-r--r--   1 pleierc  wiss        5140 Dec  7 15:30 version.c
X-rw-r--r--   1 pleierc  wiss       26041 Dec  7 15:30 xdrfile.c
X-rw-r--r--   1 pleierc  wiss        7188 Dec 19 22:17 yyfuncts.c
X
Xdcinstall:
Xtotal 136
X-rw-r--r--   1 pleierc  wiss        4822 Dec  7 15:35 Clean.c
X-rw-r--r--   1 pleierc  wiss        8377 Dec  7 15:35 Compile.c
X-rw-r--r--   1 pleierc  wiss        3018 Dec  7 15:35 GetLogin.c
X-rw-r--r--   1 pleierc  wiss        3502 Dec  7 15:35 Makefile
X-rw-r--r--   1 pleierc  wiss        8792 Dec  7 15:35 ParseOptions.c
X-rw-r--r--   1 pleierc  wiss       12503 Dec  7 15:35 Prepare.c
X-rw-r--r--   1 pleierc  wiss        5342 Dec  7 15:35 Transfer.c
X-rw-r--r--   1 pleierc  wiss        3811 Dec  7 15:35 Usage.c
X-rw-r--r--   1 pleierc  wiss        6285 Dec  7 15:35 getlogin
X-rw-r--r--   1 pleierc  wiss        7420 Dec  7 15:35 main.c
X
Xdckill:
Xtotal 12
X-rw-r-----   1 pleierc  wiss        2616 Oct 27 10:06 Makefile
X-rw-r-----   1 pleierc  wiss        2779 Oct 29 14:51 dckill.c
X
Xdclocate:
Xtotal 70
X-rw-r--r--   1 pleierc  wiss       14646 Dec  7 15:35 BuildLists.c
X-rw-r--r--   1 pleierc  wiss        3463 Dec  7 15:35 Makefile
X-rw-r--r--   1 pleierc  wiss        5067 Dec  7 15:35 ParseOptions.c
X-rw-r--r--   1 pleierc  wiss        3906 Dec  7 15:35 Usage.c
X-rw-r--r--   1 pleierc  wiss        6640 Dec  7 15:35 main.c
X
Xexamples:
Xtotal 18
X-rw-r-----   1 pleierc  wiss         568 Dec 20 11:03 Makefile
Xdrwxr-xr-x   2 pleierc  wiss        1024 Dec 20 14:18 buffer
Xdrwxr-xr-x   2 pleierc  wiss        1024 Dec 20 14:18 config
Xdrwxr-xr-x   2 pleierc  wiss        1024 Dec 20 14:18 hello
Xdrwxr-xr-x   2 pleierc  wiss        1024 Dec 21 14:53 nullst
Xdrwxr-xr-x   2 pleierc  wiss        1024 Dec 20 14:18 philo
Xdrwxr-xr-x   2 pleierc  wiss        1024 Dec 20 14:18 prod_cons
Xdrwxr-xr-x   2 pleierc  wiss        1024 Dec 20 14:18 test
Xdrwxr-xr-x   2 pleierc  wiss        1024 Dec 20 14:18 travel
X
Xexamples/buffer:
Xtotal 18
X-rw-r-----   1 pleierc  wiss         135 Oct 26 12:13 Makefile
X-rw-r-----   1 pleierc  wiss          77 Feb 20  1991 buffer.HC
X-rw-r-----   1 pleierc  wiss        4906 Dec  7 14:49 buffer.dc
X-rw-r--r--   1 pleierc  wiss        1424 Dec  6 20:55 chris.txt
X
Xexamples/config:
Xtotal 276
X-rw-r--r--   1 pleierc  wiss         562 Dec 20 13:01 READ.ME
X-rw-r--r--   1 pleierc  wiss        2923 Dec  7 15:48 dcc.config
X-rw-r--r--   1 pleierc  wiss        3487 Dec  7 15:48 performance
X-rw-r--r--   1 pleierc  wiss        1958 Dec  7 15:48 program.FICT
X-rw-r--r--   1 pleierc  wiss        1458 Dec  7 15:48 program.PQRT
X-rw-r--r--   2 pleierc  wiss        1247 Dec  7 15:48 system.AIX
X-rw-r--r--   2 pleierc  wiss        1247 Dec  7 15:48 system.BOTANIK
X-rw-r--r--   2 pleierc  wiss        1205 Dec  7 15:48 system.CONVEX
X-rw-r--r--   1 pleierc  wiss       20365 Dec  7 15:48 system.FICT
X-rw-r--r--   2 pleierc  wiss        1205 Dec  7 15:48 system.GSF
X-rw-r-----   1 pleierc  wiss         792 Dec 16 13:41 system.LINUX
X-rw-r--r--   1 pleierc  wiss        1218 Dec 20 11:31 system.SCO
X-rw-r--r--   1 pleierc  wiss       83879 Dec 16 13:52 system.TUM
X-rw-r--r--   1 pleierc  wiss       12406 Dec 20 13:27 system.WAN
X
Xexamples/hello:
Xtotal 8
X-rw-r-----   1 pleierc  wiss         129 Dec 20 11:02 Makefile
X-r--r--r--   1 pleierc  wiss        2522 Dec 20 11:06 hello.dc
X
Xexamples/nullst:
Xtotal 26
X-rw-r-----   1 pleierc  wiss         170 Mar 18  1993 Makefile
X-rw-r-----   1 pleierc  wiss          75 Feb 20  1991 nullst.HC
X-rw-r-----   1 pleierc  wiss       10721 Dec 16 14:54 nullst.dc
X
Xexamples/philo:
Xtotal 22
X-rw-r-----   1 pleierc  wiss         128 Dec 20 10:29 Makefile
X-rw-r-----   1 pleierc  wiss          74 Feb 20  1991 philo.HC
X-rw-r-----   1 pleierc  wiss         160 Feb 20  1991 philo.cfg
X-rw-r-----   1 pleierc  wiss        7299 Oct 25 09:44 philo.dc
X
Xexamples/prod_cons:
Xtotal 30
X-rw-r-----   1 pleierc  wiss        2821 Oct 26 12:06 Makefile
X-rw-r-----   1 pleierc  wiss        2733 Aug 13  1991 buffer.dc
X-rw-r-----   1 pleierc  wiss        2024 Jul 18  1991 config.h
X-rw-r-----   1 pleierc  wiss        2008 Jul 26  1991 consumer.dc
X-rw-r-----   1 pleierc  wiss        2506 Jul 26  1991 main.dc
X-rw-r-----   1 pleierc  wiss        1992 Jul 18  1991 producer.dc
X
Xexamples/test:
Xtotal 62
X-rw-r-----   1 pleierc  wiss          24 Aug  7  1991 Makefile
X-rw-r-----   1 pleierc  wiss         181 Feb 20  1991 bench.cfg
X-rw-r-----   1 pleierc  wiss        3342 Oct 25 09:45 bench.dc
X-rw-r-----   1 pleierc  wiss         307 Dec  4  1991 chris.dc
X-rw-r-----   1 pleierc  wiss          77 Feb 20  1991 creation.HC
X-rw-r-----   1 pleierc  wiss         363 Feb 20  1991 creation.cfg
X-rw-r-----   1 pleierc  wiss        9266 Oct 25 09:46 creation.dc
X-rw-r-----   1 pleierc  wiss        3332 Sep  4  1991 error.dc
X-rw-r-----   1 pleierc  wiss         359 Mar 17  1992 test.dc
X-rw-r-----   1 pleierc  wiss        6967 Nov 14  1991 xdr.dc
X
Xexamples/travel:
Xtotal 64
X-rw-r-----   1 pleierc  wiss        2310 Oct 26 12:27 Makefile
X-rw-r-----   1 pleierc  wiss         380 Aug 13  1991 READ.ME
X-rw-r-----   1 pleierc  wiss        2610 Nov 11  1991 config.h
X-rw-r-----   1 pleierc  wiss        2195 Jul 30  1991 demo.c
X-rw-r-----   1 pleierc  wiss        4120 Jul 30  1991 germany.c
X-rw-r-----   1 pleierc  wiss       16790 Oct 26 09:01 travel.dc
X
Xinclude:
Xtotal 290
X-rw-r--r--   1 pleierc  wiss        4438 Dec  7 15:28 analyse.h
X-rw-r--r--   1 pleierc  wiss       14298 Dec  7 15:28 cfgparsers.h
X-rw-r--r--   1 pleierc  wiss        7384 Dec  7 15:28 com_Errno.h
X-rw-r--r--   1 pleierc  wiss        7311 Dec  7 15:28 com_errlist.h
X-rw-r--r--   1 pleierc  wiss       17581 Dec 21 14:46 config.h
X-rw-r--r--   1 pleierc  wiss        5734 Dec 19 22:28 dcadmin.h
X-rw-r--r--   1 pleierc  wiss       10529 Dec  7 15:28 dcc.h
X-rw-r--r--   1 pleierc  wiss        3590 Dec  7 15:28 dcinstall.h
X-rw-r--r--   1 pleierc  wiss        3416 Dec  7 15:28 dclocate.h
X-rw-r--r--   1 pleierc  wiss        4002 Dec  7 15:28 extern.h
X-rw-r--r--   1 pleierc  wiss       10104 Dec  7 15:28 functions.h
X-rw-r--r--   1 pleierc  wiss        7825 Dec  7 15:28 globals.h
X-rw-r--r--   1 pleierc  wiss        2861 Dec  7 15:28 ipc_iPSC.h
X-rw-r--r--   1 pleierc  wiss        3343 Dec  7 15:28 ipc_msgsem.h
X-rw-r--r--   1 pleierc  wiss        4128 Dec  7 15:28 ipc_socket.h
X-rw-r--r--   1 pleierc  wiss        2855 Dec  7 15:28 location.h
X-rw-r--r--   1 pleierc  wiss        3279 Dec  7 15:28 reswords.h
X-rw-r--r--   1 pleierc  wiss        6888 Dec  7 15:28 run_Errno.h
X-rw-r--r--   1 pleierc  wiss        7317 Dec  7 15:28 run_errlist.h
X-rw-r--r--   1 pleierc  wiss        6002 Dec  7 15:28 timeout.h
X-rw-r--r--   1 pleierc  wiss        4594 Dec  7 15:28 version.h
X
Xipc:
Xtotal 66
X-rw-r-----   1 pleierc  wiss        3421 Sep 27  1990 Makefile
X-rw-r-----   1 pleierc  wiss         268 Aug  7  1991 READ.ME
X-rw-r--r--   1 pleierc  wiss           0 Dec  7 15:19 ipc.tmp
X-rw-r-----   1 pleierc  wiss        8046 Oct 29 14:54 p1.c
X-rw-r-----   1 pleierc  wiss        6119 Oct 29 14:54 p2.c
X-rw-r-----   1 pleierc  wiss        3551 Oct 29 14:54 p3.c
X-rw-r-----   1 pleierc  wiss        4101 Oct 29 14:54 pa.c
X-rw-r-----   1 pleierc  wiss        3896 Oct 29 14:54 pb.c
X-rw-r-----   1 pleierc  wiss          75 Sep  2  1990 tc
X
Xlib:
Xtotal 446
X-rw-r--r--   1 pleierc  wiss        4475 Dec  7 15:22 Makefile
X-rw-r--r--   1 pleierc  wiss        4058 Dec  7 15:22 RuntimeError.c
X-rw-r--r--   1 pleierc  wiss       11254 Dec  7 15:22 control.c
X-rw-r--r--   1 pleierc  wiss       18797 Dec 16 14:31 convert.c
X-rw-r--r--   1 pleierc  wiss       35757 Dec  8 20:32 creation.c
X-rw-r--r--   1 pleierc  wiss        6239 Dec  7 15:22 debug.c
X-rw-r--r--   1 pleierc  wiss        4967 Dec  7 15:22 destruction.c
X-rw-r--r--   1 pleierc  wiss       21990 Dec  7 15:22 ipc_iPSC.c
X-rw-r--r--   1 pleierc  wiss       41235 Dec  7 15:22 ipc_msgsem.c
X-rw-r--r--   1 pleierc  wiss       60451 Dec 21 10:13 ipc_socket.c
X-rw-r--r--   1 pleierc  wiss       14021 Dec  7 15:22 transaction.c
X
Xother:
Xtotal 6
X-rw-r-----   1 pleierc  wiss        2194 Dec  2 10:04 header
X
Xsysconf:
Xtotal 2
X-rw-r-----   1 pleierc  wiss         759 Mar 11  1992 sysinfo.c
END_OF_FILE
if test 13731 -ne `wc -c <'CONTENTS'`; then
    echo shar: \"'CONTENTS'\" unpacked with wrong size!
fi
# end of 'CONTENTS'
fi
if test -f 'config/SaveSymbtab.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config/SaveSymbtab.c'\"
else
echo shar: Extracting \"'config/SaveSymbtab.c'\" \(13065 characters\)
sed "s/^X//" >'config/SaveSymbtab.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                        S a v e S y m b t a b . c                        *
X *                                                                         *
X *                            Package : Configuration Files Parsers        *
X *                            Version : 1.0                                *
X *                       CreationDate : 02.03.92                           *
X *                         LastUpDate : 04.03.92                           *
X *                                                                         *
X *             All routines needed for saving a symbol table.              *
X *                                                                         *
X *               Copyright (C) 1992-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include "cfgparsers.h"
X
X/******************************************************************************
X * SaveIDENTLIST()                                                            *
X *                                                                            *
X * Saves the IDENTLIST 'idl' in the file specified by 'filep'.                *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
XSaveIDENTLIST(filep, idl)
XFILE *filep;
XIDENTLIST *idl;
X{
X    register IDENTLIST *idlp;
X    int count;
X
X    for(idlp = idl, count = 0 ; idlp; idlp = idlp->next)
X	++count;
X
X    fprintf(filep, "%d\n", count);
X
X    for(idlp = idl; idlp; idlp = idlp->next)
X        fprintf(filep, "%s\n", idlp->symbol->name);
X} /* SaveIDENTLIST */
X
X/******************************************************************************
X * SaveACCFSINFO()                                                            *
X *                                                                            *
X * Saves the ACCFSINFO 'accfs' in the file specified by 'filep'.              *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
XSaveACCFSINFO(filep, accfs)
XFILE *filep;
XACCFSINFO *accfs;
X{
X    register ACCFSINFO *accfsp;
X    int count;
X
X    for(accfsp = accfs, count = 0; accfsp; accfsp = accfsp->next)
X	++count;
X
X    fprintf(filep, "%d\n", count);
X
X    for(accfsp = accfs; accfsp; accfsp = accfsp->next)
X	fprintf(filep, "%s %f\n", accfsp->filesystem->name, accfsp->acc_time);
X} /* SaveACCFSINFO */
X
X/******************************************************************************
X * SaveFSSPECINFO()                                                           *
X *                                                                            *
X * Saves the FSSPECINFO 'fsspec' in the file specified by 'filep'.            *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
XSaveFSSPECINFO(filep, fsspec)
XFILE *filep;
XFSSPECINFO *fsspec;
X{
X    register FSSPECINFO *fsspecp;
X    int count;
X
X    for(fsspecp = fsspec, count = 0; fsspecp; fsspecp = fsspecp->next)
X	++count;
X
X    fprintf(filep, "%d\n", count);
X
X    for(fsspecp = fsspec; fsspecp; fsspecp = fsspecp->next) {
X        fprintf(filep, "%s %f %f\n", 
X            fsspecp->filesys->name,
X	    fsspecp->frequency, 
X	    fsspecp->quantity);
X    }
X} /* SaveFSSPECINFO */
X
X/******************************************************************************
X * SaveCOMMPINFO()                                                            *
X *                                                                            *
X * Saves the COMMPINFO 'commp' in the file specified by 'filep'.              *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
XSaveCOMMPINFO(filep, commp)
XFILE *filep;
XCOMMPINFO *commp;
X{
X    register COMMPINFO *commpp;
X    int count;
X
X    for(commpp = commp, count = 0; commpp; commpp = commpp->next)
X	++count;
X
X    fprintf(filep, "%d\n", count);
X
X    for(commpp = commp; commpp; commpp = commpp->next) {
X        fprintf(filep, "%s %f %f\n", 
X	    commpp->Process->name,
X	    commpp->frequency, 
X	    commpp->quantity);
X    }
X} /* SaveCOMMPINFO */
X
X/******************************************************************************
X * SavePATTRINFO()                                                            *
X *                                                                            *
X * Saves the PATTRINFO 'pattr' in the file specified by 'filep'.              *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
XSavePATTRINFO(filep, pattr)
XFILE *filep;
XPATTRINFO *pattr;
X{
X    register PATTRINFO *pattrp;
X    int count;
X
X    for(pattrp = pattr, count = 0; pattrp; pattrp = pattrp->next)
X	++count;
X
X    fprintf(filep, "%d\n", count);
X
X    for(pattrp = pattr; pattrp; pattrp = pattrp->next) {
X	fprintf(filep, "%d\n", pattrp->type);
X	switch(pattrp->type) {
X	case PA_PREFERRED:
X	case PA_RESTRICTED:
X	case PA_INTENSITY_INDEX:
X	case PA_PERI_DEVICES:
X	case PA_FILESYSTEMS:
X	case PA_COMM_PROCESSES:
X	    break;
X	case PA_PHYS_MEM:
X	    fprintf(filep, "%d %f\n", 
X		pattrp->mode,
X	        pattrp->info.phys_mem_size);
X	    break;
X	case PA_VIRT_MEM:
X	    fprintf(filep, "%d %f\n", 
X		pattrp->mode,
X	        pattrp->info.virt_mem_size);
X	    break;
X	case PA_VECTORIZATION:
X	    fprintf(filep, "%d\n", pattrp->mode);
X	    break;
X	case PA_PARALLELIZATION:
X	    fprintf(filep, "%d\n", pattrp->mode);
X	    break;
X	default:
X            fprintf(stderr, "Panic: unknown PATTRINFO type found in SavePATTRINFO()\n");
X	    fprintf(stderr, "Terminating.\n");
X	    exit(-1);
X	} /* switch */
X    } 
X} /* SavePATTRINFO */
X
X/******************************************************************************
X * SavePHOSTLIST()                                                            *
X *                                                                            *
X * Saves the PHOSTLIST 'phost' in the file specified by 'filep'.              *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
XSavePHOSTLIST(filep, phost)
XFILE *filep;
XPHOSTLIST *phost;
X{
X    register PHOSTLIST *phostp;
X    int count;
X
X    for(phostp = phost, count = 0; phostp; phostp = phostp->next)
X	++count;
X
X    fprintf(filep, "%d\n", count);
X
X    for(phostp = phost; phostp; phostp = phostp->next) {
X	fprintf(filep, "%s %d %d %f %f\n",
X	    phostp->Host->name,
X	    phostp->preferred,
X	    phostp->wished_val,
X	    phostp->load,
X	    phostp->overall_index);
X    }
X} /* SavePHOSTLIST */
X
X/******************************************************************************
X * SaveCOSTINFO()                                                             *
X *                                                                            *
X * Saves the COSTINFO 'costinf' in the file specified by 'filep'.             *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
XSaveCOSTINFO(filep, costinf)
XFILE *filep;
XCOSTINFO *costinf;
X{
X    register COSTINFO *costl;
X    int count;
X
X    for(costl = costinf, count = 0; costl; costl = costl->next)
X	++count;
X
X    fprintf(filep, "%d\n", count);
X
X    for(costl = costinf; costl; costl = costl->next) {
X	fprintf(filep, "%s %f %f\n", 
X	    costl->dest_host->name, costl->crea_val, costl->comm_val);
X    }
X} /* SaveCOSTINFO */
X
X/******************************************************************************
X * SaveSYMBTABEL()                                                            *
X *                                                                            *
X * Saves the symbol table element pointed to by 'symbol'.                     *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
XSaveSYMBTABEL(filep, symbol)
XFILE *filep;
XSYMBTABEL *symbol;
X{
X    switch(symbol->type) {
X    case UNDEFINED:
X	break;
X    case S_HOST:
X	fprintf(filep, "%s %s %f %f %f %d %d %d %d %d %s\n", 
X	    symbol->info.Host.os->name,
X	    symbol->info.Host.type->name,
X	    symbol->info.Host.phys_mem,
X	    symbol->info.Host.virt_mem,
X	    symbol->info.Host.perf_index,  
X	    symbol->info.Host.multiprocessor,
X	    symbol->info.Host.processors,
X	    symbol->info.Host.memory_type,
X	    symbol->info.Host.has_par_compiler,
X	    symbol->info.Host.is_vector_computer,
X	    symbol->info.Host.ex_storage->name);
X	SaveIDENTLIST(filep, symbol->info.Host.p_devices);
X	SaveACCFSINFO(filep, symbol->info.Host.f_systems);
X	SaveCOSTINFO(filep, symbol->info.Host.costinfo);
X	/* Compilation infos are not needed for location! Do not save it! */
X	break;
X    case S_COMPUTER_TYPE:
X    case S_OPERATING_SYSTEM:
X	break;
X    case S_FIXED_DISK:
X	fprintf(filep, "%s %f %f\n", 
X	    symbol->info.disk.location->name,
X	    symbol->info.disk.size, 
X	    symbol->info.disk.speed);
X	break;
X    case S_PROCESS:
X	fprintf(filep, "%f\n", symbol->info.Process.intensity_index);
X	SaveIDENTLIST(filep, symbol->info.Process.pref_hosts);
X	SaveIDENTLIST(filep, symbol->info.Process.rest_hosts);
X	SaveIDENTLIST(filep, symbol->info.Process.peri_dev);
X	SaveFSSPECINFO(filep, symbol->info.Process.filesystems);
X	SaveCOMMPINFO(filep, symbol->info.Process.commps);
X	SavePATTRINFO(filep, symbol->info.Process.others);
X	SavePHOSTLIST(filep, symbol->info.Process.phostlist);
X	break;
X    default:
X        fprintf(stderr, "Panic: unknown symbol table entry found in SaveSYMBTABEL()\n");
X	fprintf(stderr, "Symbol name is \"%s\". Terminating.\n", symbol->name);
X	exit(-1);
X    } /* switch */
X    return(OK);
X} /* SaveSYMBTABEL */
X
X/******************************************************************************
X * SaveSymbtab()                                                              *
X *                                                                            *
X * Saves a complete symbol table to file 'filename'.                          *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error                          *
X ******************************************************************************/
Xint
XSaveSymbtab(filep)
XFILE *filep;
X{
X    int count;
X    register SYMBTABEL *symbol;
X
X    for(symbol = symbtab, count = 0; symbol; symbol = symbol->next) 
X	++count;
X
X    fprintf(filep, "%d\n", count);
X
X    for(symbol = symbtab; symbol; symbol = symbol->next)
X        fprintf(filep, "%s %d\n", symbol->name, symbol->type);
X
X    for(symbol = symbtab; symbol; symbol = symbol->next)  {
X        fprintf(filep, "%s %d\n", symbol->name, symbol->type);
X        SaveSYMBTABEL(filep, symbol);
X    }
X} /* SaveSymbtab */
END_OF_FILE
if test 13065 -ne `wc -c <'config/SaveSymbtab.c'`; then
    echo shar: \"'config/SaveSymbtab.c'\" unpacked with wrong size!
fi
# end of 'config/SaveSymbtab.c'
fi
if test -f 'dcc/code_process.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcc/code_process.c'\"
else
echo shar: Extracting \"'dcc/code_process.c'\" \(13664 characters\)
sed "s/^X//" >'dcc/code_process.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                       c o d e _ p r o c e s s . c                       *
X *                                                                         *
X *                            Package : Compiler                           *
X *                            Version : 1.1                                *
X *                       CreationDate : 26.07.90                           *
X *                         LastUpDate : 06.12.93                           *
X *                                                                         *
X *              All functions generating code for processes.               *
X *                                                                         *
X *                  Portions Copyright 1990 Franz Distler                  *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include "config.h"
X#include "extern.h"
X#include "functions.h"
X#include "com_Errno.h"
X#include "timeout.h"
X
X/******************************************************************************
X * gen_process_file()                                                         *
X *                                                                            *
X * Creates a new file for the process specified by 'symbol' and stores the    *
X * corresponding filename and filepointer in the process filename list.       *
X *                                                                            *
X * Return values: pointer to the symbol table element specifying the process  *
X *                / NULL upon error or during error handling                  *
X ******************************************************************************/
XSYMBTABEL *
Xgen_process_file(symbol)
XSYMBTABEL *symbol;
X{
X    register struct process_list *pptr;
X
X    if (errflag || !symbol) /* error handling! */
X	return(NULL);
X#ifdef CODEDEBUG
X    fprintf(debugfile, "[code] ***** gen_process_file(): params: symbol = %d\n",
X	symbol);
X#endif /* CODEDEBUG /**/
X    if (symbol->type != PROCESSDECL || symbol->info.process.IsSpec == TRUE)
X	Panic("wrong symbol table entry in gen_process_file()");
X    /* 
X     * open codefile 
X     */
X    if (!(symbol->info.process.codefile=fopen(symbol->info.process.filename,"w"))) {
X	fprintf(stderr, "Error: can't open codefile \"%s\"\n",
X	    symbol->info.process.filename);
X	perror("Reason");
X	return(NULL);
X    }
X    /* 
X     * store process filename and filepointer in process filename list 
X     */
X    pptr = (struct process_list *) Malloc(sizeof(struct process_list));
X    pptr->name = (char *) Malloc(strlen(symbol->info.process.filename)+1);
X    strcpy(pptr->name, symbol->info.process.filename);
X    pptr->file = symbol->info.process.codefile;
X    pptr->next = NULL;
X    if (!first_processname)
X	first_processname = last_processname = pptr;
X    else {
X	last_processname->next = pptr;
X	last_processname = pptr;
X    }
X    return(symbol);
X} /* gen_process_file */
X
X/******************************************************************************
X * gencode_process_body()                                                     *
X *                                                                            *
X * Writes the complete code for a process to the appropriate file. The code   *
X * consists of: header comment, '#include' - directives, variable definitions,*
X * signal controlling code, communication header to report back and to get    *
X * the process parameters, the process body statements and ending code.       *
X *                                                                            *
X * Return values: OK upon success / ERROR upon error or during error handling *
X ******************************************************************************/
Xint
Xgencode_process_body(symbol, comp_attr)
XSYMBTABEL *symbol;
XCOMPATTR  *comp_attr;
X{
X    int                  i;
X    char                *piname,
X                        *upiname;
X    SYMBTABEL           *params,
X			*sptr,
X			*actions;
X    FILE                *file;
X    struct include_list *inclptr;
X
X    if (errflag || !symbol || !comp_attr) /* error handling! */
X        return(ERROR);
X#ifdef CODEDEBUG
X    fputs("[code] ***** gencode_process_body():\n", debugfile);
X    fprintf(debugfile, "       params: symbol = %d, comp_attr = %d\n", 
X        symbol, comp_attr);
X#endif /* CODEDEBUG /**/
X    if (infoflag) {
X	printf("%s generating code for process '%s'\n", infoprefix, symbol->name);
X	fflush(stdout);
X    }
X    piname  = symbol->info.process.piname;
X    upiname = symbol->info.process.upiname;
X    if (!(file    = symbol->info.process.codefile))
X	return(ERROR);
X    /*
X     * write header and '#include' directives to process file
X     */
X    fprintf(file, "/* process '%s' */\n\n", symbol->name);
X    fputs("/*\n", file);
X    for(i = 0; *headerstr[i]; ++i)
X	fprintf(file, " * %s\n", headerstr[i]);
X    fputs(" */\n\n", file);
X    fprintf(file, "#include \"%s\"\n\n", inclfilename);
X    /* 
X     * write global variables to process file
X     * these are the parameters and local variables of the process
X     * and other special variables
X     */
X    if (comp_attr->decls)
X        fprintf(file, "%s", comp_attr->decls);
X    else 
X	fputs("\n", file);
X    for(params = symbol->info.process.FirstParam; params; 
X				     params = params->info.varorpar.NextParam) {
X	*convert_buffer = 0;
X	convert_buffer = convert_ds_to_string(convert_buffer, params->info.varorpar.DataType);
X        fprintf(file, "%s %s;\n", convert_buffer, params->name);
X    }
X    fputs("int             Errno;\n", file); 
X#ifdef UNICOS
X    fputs("int             errno;\n", file); 
X#endif
X#ifdef iPSC
X    fputs("long            _pidcount;\n", file);
X#endif /* iPSC /**/
X    fputs("char           *_programname;\n", file);
X    fputs("char           *_processname;\n", file);
X    fputs("char            _processprefix[80];\n", file);
X    fputs("DCC_PARAMS      dcc_par;\n", file);
X    fputs("DCC_RESULTS     dcc_res;\n", file);
X    fputs("PORTDESCR       _own_port;\n", file);
X    fputs("PORTDESCR       _creator_port;\n", file);
X    fputs("PORTDESCR       _admin_port;\n", file);
X    fputs("CONNECTIONDESCR _con_port;\n", file);
X#ifdef HETEROGENEOUS
X    fputs("XDR             encode_xdrs;\n", file);
X    fputs("XDR             decode_xdrs;\n", file);
X    fputs("XDR             _xdr_encode_size_xdrs;\n", file);
X    fputs("XDR             _xdr_decode_size_xdrs;\n", file);
X    fputs("char           *_dcc_buf;\n", file);
X    fputs("unsigned long   _dcc_buf_size;\n", file);
X    fputs("char           *_xdr_size_buf;\n", file);
X#endif /* HETEROGENEOUS /**/
X    /*
X     * write decl of function 'main' and local variables
X     */
X    fputs("\nmain(argc, argv)\nint argc;\nchar *argv[];\n{\n", file);
X    fputs("\n\t/* initialize program and process name */\n", file);
X    fputs("\t_programname = argv[0];\n", file);
X    fprintf(file, "\t_processname = \"%s\";\n", symbol->name);
X    fputs("\t_set_processprefix();\n", file);
X#ifdef iPSC
X    fputs("\t_pidcount    = mynode() * 1000;\n", file);
X#endif /* iPSC /**/
X    /*
X     * add special signal controlling code
X     */
X    fputs("\t/* control signals */\n", file);
X    fputs("\t_set_signals();\n", file);
X#ifdef HETEROGENEOUS
X    /*
X     * add code to determine the size of the encode/decode buffer
X     */
X    if (determine_dcc_buf_size) {
X        /* This version of code determines the buffer size to allocate for
X         * subsequent encoding/decoding actions. The result is the size
X         * of the biggest communication structure multiplied by 4.
X         * But the size needed to encode/decode dynamic structures like 
X         * trees or list can not be predicted so errors during encoding or
X         * decoding will be the consequence if the determined buffer is 
X         *too little.
X         */
X        fputs("\n\t/* determine size of encode/decode buffer */\n", file);
X        fputs("\t_dcc_buf_size = 1000;\n", file);
X        fputs("\tDCCBUFRESIZE(PROCESSDATA);\n", file);
X        for(sptr = symbtab.PstTab[0]; sptr; sptr = sptr->PstNext) {
X            if (sptr->type != PROCESSDECL)
X                continue;
X            if (sptr->info.process.FirstParam) {
X                fprintf(file, "\tDCCBUFRESIZE(%s%s);\n",
X                    sptr->info.process.upiname, POSTFIXSPECPAR);
X            }
X            for(actions=sptr->info.process.FirstTrans; actions; actions=actions->info.trans.NextTrans) {
X                if (actions->info.trans.FirstParam) {
X                    fprintf(file, "\tDCCBUFRESIZE(%s%s);\n",
X                        actions->info.trans.uptiname, POSTFIXTRANSPAR);
X                }
X                fprintf(file, "\tDCCBUFRESIZE(%s%s);\n",
X                    actions->info.trans.uptiname, POSTFIXTRANSRES);
X            } /* for */
X        } /* for */
X    } else {
X        /* This version of code uses a fixed size to allocate for
X         * the encode/decode buffer!
X         */
X        fprintf(file, "\n\t/* size of encode/decode buffer */\n");
X        fprintf(file, "\t_dcc_buf_size = %s;\n", encode_decode_buf_size);
X    }
X    /*
X     * add code to allocate the heap space for the encode/decode buffer
X     */
X    fputs("\t/* allocate heap space for encode/decode buffer */\n", file);
X    fputs("\tif (_allocate_encode_decode_buffer(XDRRESIZE(_dcc_buf_size)))\n", file);
X    fputs("\t\t_RuntimeError(\"allocating heap space for encode/decode buffer\");\n",
X	file);
X#endif /* HETEROGENEOUS /**/
X    /*
X     * write communication header to process file
X     */
X    fputs("\t/* create own port */\n", file);
X    fputs("\tif (_create_port(&_own_port))\n", file);
X    fputs("\t\t_RuntimeError(\"creating own port\");\n", file);
X    fputs("\t/* initialize port of creator and administration process */\n",
X	file);
X#ifdef iPSC
X    fprintf(file, "\tif (_accept_connection(&_con_port, &_own_port, %d)) {\n",
X	NPTOCPACCTIME);
X    fputs("\t\tif (Errno == ETIMEOUT)\n", file);
X    fputs("\t\t\tErrno = ETCNPTOCPACC;\n", file);
X    fputs("\t\t_RuntimeError(\"accepting connection to creator\");\n", file);
X    fputs("\t}\n", file);
X    fputs("\tif (_receive_ports_data())\n", file);
X    fputs("\t\t_RuntimeError(\"receiving port data\");\n", file);
X#else
X    fputs("\t(void) _convert_argv_to_port(&_creator_port, &_admin_port, argv);\n",
X	file);
X    fprintf(file, "\tif (_report_back(&_con_port, \"%s\"))\n", symbol->name);
X    fputs("\t\t_RuntimeError(\"reporting back\");\n", file);
X#endif /* iPSC /**/
X    if (symbol->info.process.FirstParam) {
X#ifdef HETEROGENEOUS
X	/* We must clear the memory where the received data will be stored in,
X	 * because the xdr routines allocate storage for pointers only if
X	 * the pointer values equal the NULL pointer!!!
X	 */
X	fputs("\t/* clear structure to handle pointers correctly */\n", file);
X	fprintf(file, "\tbzero(&dcc_par.%s, sizeof(%s%s));\n", 
X	    piname, upiname, POSTFIXSPECPAR);
X#endif /* HETEROGENEOUS /**/
X	fputs("\t/* get parameters */\n", file);
X	fprintf(file, "\tif (_recv_data");
X#ifdef HETEROGENEOUS
X        fprintf(file, "_encoded");
X#endif
X	fprintf(file, "(&_con_port, (char *) &dcc_par.%s, ", piname);
X#if defined(SINGLE) || defined(HOMOGENEOUS)
X        fprintf(file, "sizeof(%s%s)", upiname, POSTFIXSPECPAR);
X#else /* HETEROGENEOUS */
X        fprintf(file, "xdr_%s%s", upiname, POSTFIXSPECPAR);
X#endif
X	fprintf(file, ", %d) < 0) {\n", NPTOCPPARTIME);
X	fputs("\t\tif (Errno == ETIMEOUT)\n\t\t\tErrno = ETCNPGETPARA;\n", file);
X        fputs("\t\t_RuntimeError(\"getting params\");\n\t}\n", file);
X	fputs("\t/* initialize actual parameters */\n", file);
X	for(params=symbol->info.process.FirstParam; params; params=params->info.varorpar.NextParam) {
X	    fprintf(file, "\t%s = dcc_par.%s.%s;\n", params->name, piname, 
X		params->name);
X        }
X    }
X    fputs("\tif (_close_connection(&_con_port))\n", file);
X    fputs("\t\t_RuntimeError(\"closing connection to creator process\");\n", file);
X    fputs("\tif (_notify_admin_process(NOTIFY_START))\n", file);
X    fputs("\t\t_RuntimeError(\"notifying administration process\");\n", file);
X    /*
X     * codeout: statements
X     */
X    fprintf(file, "\t/* body statements */\n%s\n", comp_attr->stats);
X    /*
X     * codeout: body tail
X     */
X    fputs("\t/* delete own port */\n", file);
X    fputs("\texit(0);\n", file);
X    fputs("}\n", file);
X    return(OK);
X} /* gencode_process_body */
END_OF_FILE
if test 13664 -ne `wc -c <'dcc/code_process.c'`; then
    echo shar: \"'dcc/code_process.c'\" unpacked with wrong size!
fi
# end of 'dcc/code_process.c'
fi
if test -f 'dcc/includefile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dcc/includefile.c'\"
else
echo shar: Extracting \"'dcc/includefile.c'\" \(12548 characters\)
sed "s/^X//" >'dcc/includefile.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                        i n c l u d e f i l e . c                        *
X *                                                                         *
X *                            Package : Compiler                           *
X *                            Version : 1.0                                *
X *                       CreationDate : 15.08.90                           *
X *                         LastUpDate : 19.12.93                           *
X *                                                                         *
X *                The routine to generate the include file.                *
X *                                                                         *
X *                  Portions Copyright 1990 Franz Distler                  *
X *               Copyright (C) 1990-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#ifdef HETEROGENEOUS
X# include <rpc/rpc.h>
X#endif
X#include <string.h>
X#include "config.h"
X#include "extern.h"
X#include "functions.h"
X#include "ipc.h"
X#include "dcc.h"
X
X/******************************************************************************
X * build_includefile()                                                        *
X *                                                                            *
X * Generates the include file containing type and structure definitions,      *
X * special variables needed for process creation and transaction calling      *
X * and function declarations.                                                 *
X *                                                                            *
X * Return values: always OK for success                                       *
X ******************************************************************************/
Xint
Xbuild_includefile()
X{
X    int flag, i;
X    register SYMBTABEL *sptr, *actions, *params;
X    register struct struct_type_list *stlptr;
X    register struct include_list *inclptr;
X    static char tmpstr[80];
X
X#ifdef DEBUG
X    fputs("[code] ***** build_includefile():\n", debugfile);
X#endif /* DEBUG /**/
X
X    if (infoflag) {
X	printf("%s building the includefile\n", infoprefix);
X	fflush(stdout);
X    }
X
X    /* create the include file */
X    if (!(inclfile = fopen(inclfilename, "w"))) {
X	fprintf(stderr, "Error: impossible to open runtime include file '%s'\n",
X	    inclfilename);
X	exit(EXIT_FOPEN);
X    }
X
X    /* write the header to the file */
X    fprintf(inclfile, "/* %s */\n\n", inclfilename);
X    fputs("/*\n", inclfile);
X    for(i = 0; *headerstr[i]; ++i)
X        fprintf(inclfile, " * %s\n", headerstr[i]);
X    fputs(" */\n\n", inclfile);
X
X    /* write the #include preprocessor directives to the include file
X     * by transforming "/usr/include/...." to <....>
X     * this realisation will fail, if some standard include directories
X     * have not the appropriate prefix.
X     */
X    for(inclptr = first_includename; inclptr; inclptr = inclptr->next) {
X	if (!strncmp(inclptr->name, "\"/usr/include/", 14)) {
X            (void) strcpy(tmpstr, "<");
X            (void) strcat(tmpstr, inclptr->name+14);
X            tmpstr[strlen(tmpstr)-1] = '>';
X	    fprintf(inclfile, "#include %s\n", tmpstr);
X#ifdef UNICOS
X	} else if (!strncmp(inclptr->name, "/usr/include/", 13)) {
X                (void) strcpy(tmpstr, "<");
X                (void) strcat(tmpstr, inclptr->name+13);
X                (void) strcat(tmpstr, ">");
X	        fprintf(inclfile, "#include %s\n", tmpstr);
X#endif /* UNICOS /**/
X#ifdef LINUX
X	} else if (!strncmp(inclptr->name, "\"/usr/lib/gcc-lib/i486-linux/2.4.5/include/", 43)) {
X                (void) strcpy(tmpstr, "<");
X                (void) strcat(tmpstr, inclptr->name+43);
X                tmpstr[strlen(tmpstr)-1] = '>';
X	        fprintf(inclfile, "#include %s\n", tmpstr);
X#endif /* LINUX /**/
X	} else if (!strncmp(inclptr->name, "\"/usr/local/dist/include/", 24)) {
X                (void) strcpy(tmpstr, "<");
X                (void) strcat(tmpstr, inclptr->name+25);
X                tmpstr[strlen(tmpstr)-1] = '>';
X	        fprintf(inclfile, "#include %s\n", tmpstr);
X	    } else 
X	        fprintf(inclfile, "#include %s\n", inclptr->name);
X    }
X#ifdef HETEROGENEOUS
X    fputs("#include <rpc/rpc.h>\n", inclfile);
X#endif
X#ifdef iPSC
X    fputs("#include <cube.h>\n", inclfile);
X#endif
X    fputs("#include <ipc.h>\n", inclfile);
X    fputs("#include <dcc.h>\n", inclfile);
X    fputs("#include <run_Errno.h>\n", inclfile);
X
X    /* 
X     * write the structure and type definitions to the include file 
X     */
X    if (first_structtype) {
X        fputs("\n/*\n * structure and type definitions\n */\n", inclfile);
X	for(stlptr = first_structtype; stlptr; stlptr = stlptr->next) {
X	    switch(stlptr->symbol->type) {
X	    case TYPEDEFNAME:
X		if (stlptr->symbol->WasInSysIncl)
X		    continue;
X		*convert_buffer = 0;
X		convert_buffer = convert_ds_to_string(convert_buffer,
X		    stlptr->symbol->info.typedefname.decl_spec);
X		convert_buffer = convert_id_to_string(convert_buffer,
X		    stlptr->symbol->info.typedefname.id_list->id);
X		fprintf(inclfile, "\n%s;\n", convert_buffer);
X		break;
X	    case STRUCTDECL:
X		if (stlptr->symbol->WasInSysIncl)
X		    continue;
X		*convert_buffer = 0;
X		convert_buffer = convert_stl_to_string(convert_buffer, 
X		    stlptr->symbol->info.structdecl.StruDeclList);
X		fprintf(inclfile, "\n%s %s {\n%s};\n", 
X		    (stlptr->symbol->info.structdecl.IsStruct) ? "struct " : "union",
X		    stlptr->symbol->name, convert_buffer);
X		    
X		break;
X	    default:
X		Panic("nor TYPEDEFNAME nor STRUCTDECL in struct_type_list");
X	    } /* switch */
X	} /* for */
X    }
X
X    /* 
X     * create the types for the process parameters 
X     */
X    for(sptr = symbtab.PstTab[0]; sptr; sptr = sptr->PstNext) {
X        if (sptr->type != PROCESSDECL) 
X	    continue;
X	if (sptr->info.process.FirstParam || sptr->info.process.FirstTrans)
X            fprintf(inclfile, "\n/*\n * process '%s'\n */\n", sptr->name);
X	if (sptr->info.process.FirstParam) {
X            fputs("\n/* process parameter structure */\n", inclfile);
X	    fputs("typedef struct {\n", inclfile);
X            for(params = sptr->info.process.FirstParam; params; 
X				     params = params->info.varorpar.NextParam) {
X		*convert_buffer = 0;
X		convert_buffer = convert_ds_to_string(convert_buffer,
X		    params->info.varorpar.DataType);
X                fprintf(inclfile, "\t%s %s;\n", convert_buffer, params->name);
X	    }
X            fprintf(inclfile, "} %s%s;\n", sptr->info.process.upiname,
X		POSTFIXSPECPAR);
X	}
X	for(actions = sptr->info.process.FirstTrans; actions; 
X				      actions = actions->info.trans.NextTrans) {
X	    if (actions->info.trans.FirstParam) {
X                fprintf(inclfile, "\n/* transaction '%s' parameter structure */\n",
X		    actions->name);
X	        fputs("typedef struct {\n", inclfile);
X	        for(params = actions->info.trans.FirstParam; params; 
X				     params = params->info.varorpar.NextParam) {
X		    *convert_buffer = 0;
X		    convert_buffer = convert_ds_to_string(convert_buffer,
X			params->info.varorpar.DataType);
X                    fprintf(inclfile, "\t%s %s;\n", convert_buffer, params->name);
X		}
X	        fprintf(inclfile, "} %s%s;\n", actions->info.trans.uptiname,
X		    POSTFIXTRANSPAR);
X	    }
X            fprintf(inclfile, "\n/* transaction '%s' result structure */\n",
X		actions->name);
X	    fputs("typedef struct {\n", inclfile);
X	    *convert_buffer = 0;
X	    convert_buffer = convert_ds_to_string(convert_buffer, 
X		actions->info.trans.ReturnType);
X	    fprintf(inclfile, "\t%s result;\n", convert_buffer);
X	    fputs("\tint Errno, errno;\n", inclfile);
X	    fprintf(inclfile, "} %s%s;\n", actions->info.trans.uptiname,
X		POSTFIXTRANSRES);
X	} /* for(actions) */
X    } /* for */
X
X    /* 
X     * create the variables for the process and transaction parameters 
X     */
X
X    fputs("\n/* struct for the parameter structures */\n", inclfile);
X    flag = 0;
X    fputs("typedef struct _parun {\n", inclfile);
X    for(sptr = symbtab.PstTab[0]; sptr; sptr = sptr->PstNext) {
X        if (sptr->type != PROCESSDECL) 
X	    continue;
X	if (sptr->info.process.FirstParam) {
X            fprintf(inclfile, "\t%s%s %s;\n", sptr->info.process.upiname,
X		POSTFIXSPECPAR, sptr->info.process.piname);
X	    flag = 1;
X	}
X	for(actions=sptr->info.process.FirstTrans; actions; actions=actions->info.trans.NextTrans) {
X	    if (actions->info.trans.FirstParam) {
X	        fprintf(inclfile, "\t%s%s %s;\n", actions->info.trans.uptiname,
X		    POSTFIXTRANSPAR, actions->info.trans.ptiname);
X		flag = 1;
X	    }
X	}
X    } /* for */
X    if (!flag)
X	fputs("\tchar dummy; /* to avoid compiler errors! */\n", inclfile);
X    fputs("} DCC_PARAMS;\n", inclfile);
X
X    fputs("\n/* struct for the transaction result structures */\n", inclfile);
X    flag = 0;
X    fputs("typedef struct _resun {\n", inclfile);
X    for(sptr = symbtab.PstTab[0]; sptr; sptr = sptr->PstNext) {
X        if (sptr->type != PROCESSDECL) 
X	    continue;
X	for(actions=sptr->info.process.FirstTrans; actions; actions=actions->info.trans.NextTrans) {
X	    fprintf(inclfile, "\t%s%s %s;\n", actions->info.trans.uptiname, 
X		POSTFIXTRANSRES, actions->info.trans.ptiname);
X	    flag = 1;
X	}
X    } /* for */
X    if (!flag)
X	fputs("\tchar dummy; /* to avoid compiler errors! */\n", inclfile);
X    fputs("} DCC_RESULTS;\n", inclfile);
X
X    fputs("\nextern DCC_PARAMS dcc_par;\n", inclfile);
X    fputs("extern DCC_RESULTS dcc_res;\n", inclfile);
X
X    /*
X     * macro to determine size of encode/decode buffer
X     */
X    fputs("\n/* macro to determine the size of the encode/decode buffer */\n", inclfile);
X    fputs("#define DCCBUFRESIZE(type)\tif (sizeof(type) > _dcc_buf_size)", inclfile);
X    fputs(" \\\n\t\t\t\t\t_dcc_buf_size = sizeof(type)\n", inclfile);
X
X    /* 
X     * generate function declarations 
X     */
X    flag = 1;
X    for(sptr = symbtab.PstTab[0]; sptr; sptr = sptr->PstNext) {
X#ifdef OLD /* CHANGED by CHRIS to eliminate a bug under LINUX */
X	if (sptr->type == FUNCTIONDEF) {
X#else
X	if (sptr->type == FUNCTIONDEF && sptr->WasInSysIncl == FALSE) {
X#endif
X	    if (flag) {
X    		fputs("\n/*\n * function list with parameter and return types\n */\n\n",
X		    inclfile);
X    		flag = 0;
X	    }
X	    fprintf(inclfile, "extern %s %s();\n", 
X		sptr->info.functiondef.ReturnType, sptr->name);
X	}
X    }
X    if (crextstr) {
X        fputs("\n/* process creation */\n", inclfile);
X        crextstr[strlen(crextstr)-2] = ';';
X        fprintf(inclfile, "%s", crextstr);
X    }
X    if (trextstr) {
X        fputs("\n/* transaction calls */\n", inclfile);
X        fprintf(inclfile, "%s", trextstr);
X    }
X#if defined(HETEROGENEOUS) || defined(CHECK_XDR)
X    if (xdrextstr) {
X        fputs("\n/* xdr routines */\n", inclfile);
X        fprintf(inclfile, "%s", xdrextstr);
X    }
X#endif /* HETEROGENEOUS /**/
X
X    fputs("\n#ifdef SYSTEM_V\n", inclfile);
X    fputs("# define bzero(s, n)\t\tmemset(s, 0, n)\n", inclfile);
X    fputs("# define bcopy(src, dst, num)\tmemcpy(dst, src, num)\n", inclfile);
X    fputs("#endif /* SYSTEM_V /**/\n", inclfile);
X
X    fputs("\n/* define this to make processes contact to admin upon termination */\n", inclfile);
X    fputs("#define exit(c)\t\t\t_Exit(c)\n", inclfile);
X
X    return(OK);
X} /* build_includefile */
END_OF_FILE
if test 12548 -ne `wc -c <'dcc/includefile.c'`; then
    echo shar: \"'dcc/includefile.c'\" unpacked with wrong size!
fi
# end of 'dcc/includefile.c'
fi
if test -f 'include/cfgparsers.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/cfgparsers.h'\"
else
echo shar: Extracting \"'include/cfgparsers.h'\" \(14298 characters\)
sed "s/^X//" >'include/cfgparsers.h' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                         c f g p a r s e r s . h                         *
X *                                                                         *
X *                            Package : Include files                      *
X *                            Version : 1.0                                *
X *                       CreationDate : 26.02.92                           *
X *                         LastUpDate : 06.12.93                           *
X *                                                                         *
X *     The include file for building the configuration files parsers.      *
X *                                                                         *
X *               Copyright (C) 1992-1994 by Christoph Pleier               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#ifndef __cfgparsers_h
X#define __cfgparsers_h
X
X/*
X * constants
X */
X
X/* general return codes */
X#define OK	0
X#define ERROR	-1
X
X/* boolean constants */
X#ifndef TRUE
X# define TRUE	1
X# define FALSE	0
X#endif 
X
X/* symbol table entry types */
X#define UNDEFINED		0
X#define S_HOST			1
X#define S_COMPUTER_TYPE		2
X#define S_OPERATING_SYSTEM	3
X#define S_FIXED_DISK		4
X#define S_PROCESS		5
X
X/* various constants */
X#define SHARED_MEMORY		10
X#define DISTRIBUTED_MEMORY	11
X#define VECTOR_COMPUTER		12
X#define PAR_COMPILER		13
X#define MODE_REQUIRES		14
X#define MODE_WISHES		15
X
X/* process attribute types */
X#define PA_PREFERRED		20
X#define PA_RESTRICTED		21
X#define PA_INTENSITY_INDEX	22
X#define PA_PHYS_MEM		23
X#define PA_VIRT_MEM		24
X#define PA_PERI_DEVICES		25
X#define PA_FILESYSTEMS		26
X#define PA_COMM_PROCESSES	27
X#define PA_VECTORIZATION	28
X#define PA_PARALLELIZATION	29
X
X/* to be able to work with two parsers, we must redefine some global variables
X */
X#ifdef SECOND_PARSER
X# if defined(SCO_UNIX) || defined (SCO_XENIX) || defined(SPARC)
X#  define yyv		second_yyv
X#  define yys		second_yys
X#  define yypv		second_yypv
X#  define yyps		second_yyps
X#  define yystate	second_yystate
X#  define yytmp		second_yytmp
X#  define yyerrfag	second_yyerrflag
X#  define yychar	second_yychar
X#  define yyact 	second_yyact
X#  define yydef 	second_yydef
X#  define yychk 	second_yychk
X#  define yypact	second_yypact
X#  define yytoks	second_yytoks
X#  define yyr1		second_yyr1
X#  define yyr2		second_yyr2
X#  define yyreds	second_yyreds
X#  define yypgo		second_yypgo
X#  define yyexca	second_yyexca
X# else
X#  define yymaxdepth	second_yymaxdepth 
X# endif /* SCO_UNIX || SCO_XENIX || SPARC /**/
X#endif /* SECOND_PARSER /**/
X
X/*
X * type definitions 
X */
X
X/* type of a list storing filenames */	
Xtypedef struct filenamelist {
X    char *name;
X    struct filenamelist *next;
X} FILENAMELIST;
X
X/* type of a list storing options */
Xtypedef struct optionlist {
X    char *option;
X    struct optionlist *next;
X} OPTIONLIST;
X
X/* type of a list storing identifiers (pointers to symbol table entries) */
Xtypedef struct identlist {
X    struct symbtabel *symbol;
X    struct identlist *next;
X} IDENTLIST;
X
X/* type of a symbol table element */
Xtypedef struct symbtabel {
X    char *name;				/* name of the entry */
X    int   type;				/* type of the entry */
X
X    union {
X
X	/* informations about fixed disks */
X	struct u_disk_t {
X	    struct symbtabel *location;	/* location of disk */
X	    float size;			/* size of disk */
X	    float speed;		/* access time of disk */
X		/* internal variables for dcinstall */
X	    short wasprepared;		/* disk was prepared or not */
X	    short wascopied;		/* files were copied or not */
X	    short wascleaned;		/* disk was cleaned or not */
X	} disk;
X
X	/* informations about hosts */
X	struct u_host_t {	
X		/* operating system */
X	    struct symbtabel *os;
X		/* computer hardware infos */
X	    struct symbtabel *type;	/* computer type */
X	    float phys_mem;		/* physical memory */
X	    float virt_mem;		/* virtual memory */
X	    float perf_index;		/* performance index */
X		/* multiprocessor informations */
X	    short multiprocessor;	/* multiprocessor system */
X	    short processors;		/* number of processors */
X	    short memory_type;		/* shared or distributed memory */
X	    short has_par_compiler;	/* parallelizing compiler */
X		/* other infos */
X	    short is_vector_computer;
X		/* peripheral devices */
X	    IDENTLIST *p_devices;
X		/* accessible filesystems */
X	    struct accfsinfo_t *f_systems; 
X		/* compilation information (for dcinstall only) */
X	    struct targetinfo_t *compinfo;
X	    struct symbtabel *ex_storage; /* storage for executables */
X		/* cost informations */
X	    struct costinfo_t *costinfo;
X		/* internal variables for dcinstall */
X	    short istarget;		/* hostname is target or not */
X	    short wasmade;		/* files are compiled or not */
X		/* internal variables for dcadmin */
X	    float prob_load;
X	    int pcreated;
X	} Host;
X
X	/* informations about processes */
X	struct {
X	    float intensity_index;	/* intensity index */
X	    IDENTLIST *pref_hosts;	/* preferred hosts */
X	    IDENTLIST *rest_hosts;	/* restricted hosts */
X	    IDENTLIST *peri_dev;	/* peripheral devices */
X	    struct fsspecinfo_t *filesystems;	/* filesystems */
X	    struct commpinfo_t *commps;	/* communication processes */
X	    struct pattrinfo_t *others;	/* other attributes */
X	    struct phostlist_t *phostlist; /* priority host list */
X	} Process;
X
X    } info;
X
X    struct symbtabel *next;		/* pointer to next entry */
X} SYMBTABEL;
X
X/* type of a list storing compilation information (system) */ 
Xtypedef struct targetinfo_t {
X    char *type,		/* target computer type                    */
X         *os,  		/* target operating system                 */
X         *cc,		/* compiler to use for building code       */
X         *cflags,	/* compiler flags to use for building code */
X         *ld,		/* loader to use for building code         */
X         *ldflags,	/* loader flags to use for building code   */
X         *libs,		/* libraries to use for building code      */
X         *cb,		/* beautifier to use for building code     */
X         *cbflags;	/* beautifier flags to use for beautifying */
X    struct targetinfo_t *next;
X} TARGETINFO;
X
X/* type to store multiprocessor_specification information (system) */
Xtypedef struct {
X    short proc_num;
X    short mem_type;
X} MULTIINFO;
X
X/* type to store optional_computer_attribute information (system) */
Xtypedef struct {
X    MULTIINFO *multiinfo;
X    short is_vector;
X    short has_par_comp;
X} OPTCOMPINFO;
X
X/* type to store computer_specification information (system) */
Xtypedef struct {
X    struct symbtabel *type;	  /* computer type */
X    float phys_mem;		  /* physical memory */
X    float virt_mem;		  /* virtual memory */
X    float perf_index;	    	  /* performance index */
X    short multiprocessor;	  /* multiprocessor system */
X    short processors;		  /* number of processors */
X    short memory_type;		  /* shared or distributed memory */
X    short has_par_compiler;	  /* parallelizing compiler */
X    short is_vector_computer;	  /* vector computer */
X    struct symbtabel *ex_storage; /* storage for executables */
X} COMPSPEINFO;
X
X/* type to store accessible filesystems information (system) */
Xtypedef struct accfsinfo_t {
X    SYMBTABEL *filesystem;
X    float acc_time;
X    struct accfsinfo_t *next;
X} ACCFSINFO;
X
X/* type to store cost definitions (system) */
Xtypedef struct costinfo_t {
X    SYMBTABEL *dest_host;
X    float crea_val;
X    float comm_val;
X    struct costinfo_t *next;
X} COSTINFO;
X
X/* type to store accessed filesystems (program) */
Xtypedef struct fsspecinfo_t {
X    SYMBTABEL *filesys;
X    float      frequency;
X    float      quantity;
X    struct fsspecinfo_t *next;
X} FSSPECINFO;
X
X/* type to store processes to communicate with (program) */
Xtypedef struct commpinfo_t {
X    SYMBTABEL *Process;
X    float      frequency;
X    float      quantity;
X    struct commpinfo_t *next;
X} COMMPINFO;
X
X/* type to store a process attribute information (process) */
Xtypedef struct pattrinfo_t {
X    short type;
X    int   mode;				/* requires or wishes */
X    union {
X	IDENTLIST *pref_hosts;		/* preferred hosts */
X	IDENTLIST *rest_hosts;		/* restricted hosts */
X	float intensity_index;		/* intensity index */
X	float phys_mem_size;		/* physical memory */
X	float virt_mem_size;		/* virtual memory */
X	IDENTLIST *peri_dev;		/* peripheral devices */
X	FSSPECINFO *filesystems;	/* filesystems */
X	COMMPINFO *commps;		/* communication processes */
X    } info;
X    struct pattrinfo_t *next;
X} PATTRINFO;
X
X/* type of a priority host list */
Xtypedef struct phostlist_t {
X    SYMBTABEL *Host;
X    short preferred;	 /* host is preferred or not */
X    short wished_val;	 /* sum of accomplished wished ressources */
X    float load;		 /* intensity_index / performance_index */
X    float overall_index; /* overall index with regard to all criterias */
X    struct phostlist_t *next;
X} PHOSTLIST;
X
X/*
X * external declarations
X */
X
X#ifdef UNICOS
Xextern long yydebug;
X#else
Xextern int yydebug; 
X#endif
Xextern int yylineno;
X#if defined(HPUX) || defined(AIX)
Xextern unsigned char yytext[];
X#else
X# ifdef LINUX
Xextern char *yytext;
X# else
Xextern char yytext[];
X# endif
X#endif
Xextern long
X    yymaxdepth;
Xextern FILENAMELIST 
X    * first_file,
X    * last_file,
X    * first_incl_file,
X    * last_incl_file;
Xextern OPTIONLIST 
X    * first_opt,
X    * last_opt;
Xextern SYMBTABEL
X    * symbtab,
X    * last_symb;
Xextern FILE 
X    *yyin,
X    *yyout;
X
X#if defined(__STDC__) && !defined(NO_PROTOTYPE)
X# define FUNCPROTO(type,id,args)	extern type id args
X#else
X# define FUNCPROTO(type,id,args)	extern type id()
X#endif /* __STDC__ /**/
X
XFUNCPROTO(int           , DisplaySymbolTable, ());
XFUNCPROTO(int           , DisplaySymbtabel, (SYMBTABEL *));
XFUNCPROTO(int           , Free, (char *));
XFUNCPROTO(char         *, Malloc, (unsigned));
XFUNCPROTO(ACCFSINFO    *, ReadACCFSINFO, (FILE *));
XFUNCPROTO(COMMPINFO    *, ReadCOMMPINFO, (FILE *));
XFUNCPROTO(COSTINFO     *, ReadCOSTINFO, (FILE *));
XFUNCPROTO(FSSPECINFO   *, ReadFSSPECINFO, (FILE *));
XFUNCPROTO(IDENTLIST    *, ReadIDENTLIST, (FILE *));
XFUNCPROTO(PATTRINFO    *, ReadPATTRINFO, (FILE *));
XFUNCPROTO(PHOSTLIST    *, ReadPHOSTLIST, (FILE *));
XFUNCPROTO(SYMBTABEL    *, ReadSYMBTABEL, (FILE *, SYMBTABEL *));
XFUNCPROTO(int           , ReadSymbtab, (FILE *));
XFUNCPROTO(int           , SaveACCFSINFO, (FILE *, ACCFSINFO *));
XFUNCPROTO(int           , SaveCOMMPINFO, (FILE *, COMMPINFO *));
XFUNCPROTO(int           , SaveCOSTINFO, (FILE *, COSTINFO *));
XFUNCPROTO(int           , SaveFSSPECINFO, (FILE *, FSSPECINFO *));
XFUNCPROTO(int           , SaveIDENTLIST, (FILE *, IDENTLIST *));
XFUNCPROTO(int           , SavePATTRINFO, (FILE *, PATTRINFO *));
XFUNCPROTO(int           , SavePHOSTLIST, (FILE *, PHOSTLIST *));
XFUNCPROTO(int           , SaveSYMBTABEL, (FILE *, SYMBTABEL *));
XFUNCPROTO(int           , SaveSymbtab, (FILE *));
XFUNCPROTO(OPTCOMPINFO  *, add_opt_comp_attr_info, (OPTCOMPINFO *, OPTCOMPINFO *));
XFUNCPROTO(IDENTLIST    *, chain_ident_lists, (IDENTLIST *, IDENTLIST *));
XFUNCPROTO(ACCFSINFO    *, chain_accfs_infos, (ACCFSINFO *, ACCFSINFO *));
XFUNCPROTO(ACCFSINFO    *, chain_accfs_infos, (ACCFSINFO *, ACCFSINFO *));
XFUNCPROTO(COMMPINFO    *, chain_commp_infos, (COMMPINFO *, COMMPINFO *));
XFUNCPROTO(FSSPECINFO   *, chain_fsspec_infos, (FSSPECINFO *, FSSPECINFO *));
XFUNCPROTO(PATTRINFO    *, chain_pattr_infos, (PATTRINFO *, PATTRINFO *));
XFUNCPROTO(TARGETINFO   *, chain_targetinfos, (TARGETINFO *, TARGETINFO *));
XFUNCPROTO(SYMBTABEL    *, enter_disk_definition, (SYMBTABEL *, SYMBTABEL *, float, float));
XFUNCPROTO(SYMBTABEL    *, enter_cost_definition, (SYMBTABEL *, SYMBTABEL *, float, float));
XFUNCPROTO(SYMBTABEL    *, enter_host_specification, (IDENTLIST *, SYMBTABEL *, COMPSPEINFO *, IDENTLIST *,
X				TARGETINFO *, ACCFSINFO *));
XFUNCPROTO(SYMBTABEL    *, enter_process_description, (SYMBTABEL *, PATTRINFO *));
XFUNCPROTO(SYMBTABEL    *, enter_symbtabel, (char *));
XFUNCPROTO(ACCFSINFO    *, generate_accfs_info, (SYMBTABEL *, float));
XFUNCPROTO(COMMPINFO    *, generate_commp_info, (SYMBTABEL *, float, float));
XFUNCPROTO(COMPSPEINFO  *, generate_comp_spec_info, (SYMBTABEL *, float, float, float, OPTCOMPINFO *, SYMBTABEL *));
XFUNCPROTO(FSSPECINFO   *, generate_fsspec_info, (SYMBTABEL *, float, float));
XFUNCPROTO(MULTIINFO    *, generate_multi_info, (float, short));
XFUNCPROTO(OPTCOMPINFO  *, generate_opt_comp_attr_info, (MULTIINFO *, short));
XFUNCPROTO(PATTRINFO    *, generate_process_attr_info, (int, IDENTLIST *, float, int, FSSPECINFO *, COMMPINFO *));
XFUNCPROTO(TARGETINFO   *, generate_targetinfo, (SYMBTABEL *, SYMBTABEL *, char *,char *, char *, char *));
XFUNCPROTO(char         *, gethomedir, (char *));
X#if defined (SCO_UNIX) || defined (SCO_XENIX)
XFUNCPROTO(int           , gethostname, (char *, int));
XFUNCPROTO(char         *, getlogin, ());
X#endif
XFUNCPROTO(SYMBTABEL    *, lookup_symbtabel, (char *));
XFUNCPROTO(SYMBTABEL    *, make_hostname, (SYMBTABEL *));
XFUNCPROTO(int           , mark_symbols, (IDENTLIST *, int));
XFUNCPROTO(IDENTLIST    *, store_ident_in_list, (SYMBTABEL *));
XFUNCPROTO(char         *, strsave, (char *));
X
X#endif /* !__cfgparsers_h /**/
END_OF_FILE
if test 14298 -ne `wc -c <'include/cfgparsers.h'`; then
    echo shar: \"'include/cfgparsers.h'\" unpacked with wrong size!
fi
# end of 'include/cfgparsers.h'
fi
if test -f 'lib/transaction.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib/transaction.c'\"
else
echo shar: Extracting \"'lib/transaction.c'\" \(14021 characters\)
sed "s/^X//" >'lib/transaction.c' <<'END_OF_FILE'
X/***************************************************************************
X *                                                                         *
X * @@@@  @@@ @@@@@ @@@@@ @@@@@ @@@ @@@@  @   @ @@@@@ @@@@@ @@@@       @@@  *
X * @   @  @  @       @   @   @  @  @   @ @   @   @   @     @   @     @   @ *
X * @   @  @  @@@@@   @   @@@@@  @  @@@@@ @   @   @   @@@@@ @   @     @     *
X * @   @  @      @   @   @ @    @  @   @ @   @   @   @     @   @     @   @ *
X * @@@@  @@@ @@@@@   @   @  @  @@@ @@@@  @@@@@   @   @@@@@ @@@@       @@@  *
X *                                                                         *
X *              A compiler for distributed programming with C              *
X *                                                                         *
X *                        t r a n s a c t i o n . c                        *
X *                                                                         *
X *                            Package : Runtime Library                    *
X *                            Version : 1.0                                *
X *                       CreationDate : 21.08.90                           *
X *                         LastUpDate : 12.03.92                           *
X *                                                                         *
X *          All library routines needed performing transactions.           *
X *                                                                         *
X *              Copyright (C) 1990-1994 by Christoph Pleier.               *
X *                          All rights reserved!                           *
X ***************************************************************************/
X
X/*
X * This file is part of the Distributed C Development Environment (DCDE).
X * DCDE is free software; you can redistribute it and/or modify
X * it under the terms written in the README-file. 
X * DCDE is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
X * See the file README for more details.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#ifdef HETEROGENEOUS
X# include <rpc/rpc.h>
X#endif
X#include <time.h>
X#include "ipc.h"
X#include "dcc.h"
X#include "run_Errno.h"
X#include "timeout.h"
X
X#define DEBUG_TRANSACTION /**/
X
X/* To avoid that processes whose transaction call is denied by the called 
X * process several times (e.g. if the called process waits itself for 
X * another type of transaction call) let grow the load of the calling 
X * computer node because of their message passing overhead (busy waiting!),
X * we raise each time a call is denied the delay until this process is 
X * allowed to retry the call.
X * The delay starts at TRANS_RETRY_DELAY_MIN and is raised in steps of
X * TRANS_RETRY_DELAY_STEP until TRANS_RETRY_DELAY_MAX. After the transaction
X * call succeeded or the operation is timed out the delay is reset to the min.
X * value.
X *
X * NOTE: the values specify different unities on different machines!
X */
X#if defined(SCO_XENIX) || defined(SCO_UNIX) || defined(HPUX)
X	/* the values specify milliseconds */
X# define TRANS_RETRY_DELAY_MIN		0
X# define TRANS_RETRY_DELAY_MAX		5000
X# define TRANS_RETRY_DELAY_STEP		50
X#else
X# ifdef SPARC
X	/* the values specify microseconds */
X#  define TRANS_RETRY_DELAY_MIN		5000
X#  define TRANS_RETRY_DELAY_MAX		500000
X#  define TRANS_RETRY_DELAY_STEP	5000
X# else
X	/* the values specify seconds */
X#  define TRANS_RETRY_DELAY_MIN		0
X#  define TRANS_RETRY_DELAY_MAX		2
X#  define TRANS_RETRY_DELAY_STEP	1	
X# endif /* SPARC /**/
X#endif /* SCO_XENIX || SCO_UNIX || HPUX /**/
X
X/* to store the actual retry delay */
Xstatic int trans_retry_delay = TRANS_RETRY_DELAY_MIN;
X
X#ifdef DEBUG_TRANSACTION
X/* the flag to control the debug messages output */
Xint _debug_transaction = 0;
X#endif /* DEBUG_TRANSACTION /**/
X
X#ifdef DEBUG_TRANSACTION
X# define DEBUGPUTS(msg)		if (_debug_transaction) { \
X				    fprintf(_debugout, "[tra] %s %s\n", \
X				        _processprefix, msg); \
X				    if (_debugflush) \
X				        fflush(_debugout); \
X				}
X# define DEBUGDISPERR(msg)	if (_debug_transaction) { \
X				    fprintf(_debugout, "[tra] %s error: %s\n", \
X				        _processprefix, msg); \
X				    fprintf(_debugout, "[tra] %s reason: %s\n",\
X				        _processprefix, sys_errlist[errno]); \
X				    if (_debugflush) \
X				        fflush(_debugout); \
X				}
X#else
X# define DEBUGPUTS(msg)		{ /* nothing */ }
X# define DEBUGDISPERR(msg)	{ /* nothing */ }
X#endif
X
X/******************************************************************************
X * _SendTransCallReply()                                                      *
X *                                                                            *
X * Sends a transaction reply message of the type 'reply' to the process       *
X * specified by 'con_port'                                                    *
X *                                                                            *
X * Return value: OK upon success / ERROR upon error                           *
X ******************************************************************************/
Xint
X_SendTransCallReply(reply)
Xint reply;
X{
X    static TRANSDATA transdata;
X    unsigned long size;
X
X    DEBUGPUTS("(TA) sending reply");
X    transdata.reply = reply;
X#if defined(SINGLE) || defined(HOMOGENEOUS)
X    if (_send_data(&_con_port, (char *) &transdata, sizeof(TRANSDATA), ACCEPTREPTIME) < 0)
X#else /* HETEROGENEOUS */
X    if (_send_data_encoded(&_con_port, (char *) &transdata, xdr_TRANSDATA, ACCEPTREPTIME))
X#endif /* SINGLE || HOMOGENEOUS /**/
X        return(ERROR);
X    return(OK);
X} /* _SendTransCallReply */
X
X/******************************************************************************
X * _make_transaction_call()                                                   *
X *                                                                            *
X * Connects to the process specified by 'port' and requests the transaction   *
X * 'transaction'. 'con_port' is reference parameter and is used to return the *
X * connection descriptor specifying the established connection upon success.  *
X *                                                                            *
X * Return value: OK upon success / ERROR upon error                           *
X ******************************************************************************/
Xint
X_make_transaction_call(port, transaction, timeout)
XPORTDESCR  port;	/* port to connect to */
Xchar      *transaction; /* transaction type */
Xint        timeout;	/* timeout (if there's any) */
X{
X    int reply;
X    long start_time;
X    static TRANSDATA transdata;
X    unsigned long size;
X
X#ifdef DEBUG_TRANSACTION
X    if (_debug_transaction) {
X        fprintf(_debugout, "[tra] %s (TC) making transaction call >> %s <<\n",
X	    _processprefix, transaction);
X        if (_debugflush)
X	    fflush(_debugout);
X    }
X#endif /* DEBUG_TRANSACTION /**/
X    if (timeout)
X	start_time = time((long *) NULL);
X    while(1) {
X	if (timeout)
X	    if (time((long *) NULL) - start_time >= timeout) {
X	        trans_retry_delay = TRANS_RETRY_DELAY_MIN;
X#ifdef DEBUG_TRANSACTION
X		if (_debug_transaction) {
X		    fprintf(_debugout, "[tra] %s (TC) retry delay now %d\n", 
X		        _processprefix, trans_retry_delay);
X		    if (_debugflush)
X		        fflush(_debugout);
X		}
X#endif /* DEBUG_TRANSACTION /**/
X		Errno = ETIMEOUT;
X		return(ERROR);
X	    }
X	/* call process */
X	if (_make_connection(&_con_port, &_own_port, &port, (timeout) ? timeout : TRANSCONTIME)) {
X		if (Errno == ETIMEOUT)
X			Errno = ETTCONTOPROC;
X		return(ERROR);
X	}
X#ifdef DEBUG_TRANSACTION
X	if (_debug_transaction) {
X	    fprintf(_debugout, "[tra] %s (TC) connection established\n", 
X	        _processprefix);
X	    fprintf(_debugout, "[tra] %s (TC) sending connection type (TRANS...)\n", 
X	        _processprefix);
X	    if (_debugflush)
X	        fflush(_debugout);
X        }
X#endif /* DEBUG_TRANSACTION /**/
X	if (_send_connection_type_or_answer(TRANSACTION_CONNECTION))
X            return(ERROR);
X	if (_receive_connection_type_or_answer() == ACCEPT_CONNECTION) {
X	    DEBUGPUTS("(TC) connection accepted");
X	} else {
X	    DEBUGPUTS("(TC) connection aborted");
X	    if (_close_connection(&_con_port))
X		return(ERROR);
X#if defined(SCO_XENIX) || defined(SCO_UNIX) || defined(HPUX)
X	    nap(trans_retry_delay);
X#else
X# ifdef SPARC
X	    usleep(trans_retry_delay);
X# else
X	    sleep(trans_retry_delay);
X# endif /* SPARC /**/
X#endif /* SCO_XENIX || SCO_UNIX /**/
X	    if (trans_retry_delay < TRANS_RETRY_DELAY_MAX) {
X		trans_retry_delay += TRANS_RETRY_DELAY_STEP;
X	    }
X	    DEBUGPUTS("(TC) trying again");
X	    continue;
X	}
X#ifdef DEBUG_TRANSACTION
X	if (_debug_transaction) {
X	    fprintf(_debugout, "[tra] %s (TC) sending request >> %s <<\n", 
X	        _processprefix, transaction);
X	    if (_debugflush)
X	        fflush(_debugout);
X	}
X#endif /* DEBUG_TRANSACTION /**/
X	/* send transaction request message */
X	(void) strcpy(transdata.request, transaction);
X#if defined(SINGLE) || defined(HOMOGENEOUS)
X	if (_send_data(&_con_port, (char *) &transdata, sizeof(TRANSDATA), TRANSREQTIME)<0){
X#else /* HETEROGENEOUS */
X	if (_send_data_encoded(&_con_port, (char *) &transdata, xdr_TRANSDATA, TRANSREQTIME)){
X#endif /* SINGLE || HOMOGENEOUS /**/
X            if (Errno == ETIMEOUT)
X                Errno = ETTSNDREQUEST;
X            return(ERROR);
X        }
X	DEBUGPUTS("(TC) request sent!"); 
X	DEBUGPUTS("(TC) receiving reply"); 
X	/* receive reply */ 
X#if defined(SINGLE) || defined(HOMOGENEOUS)
X	if (_recv_data(&_con_port, (char *) &transdata, sizeof(TRANSDATA), TRANSREPTIME)<0){
X#else /* HETEROGENEOUS */
X	if (_recv_data_encoded(&_con_port, (char *) &transdata, xdr_TRANSDATA, TRANSREPTIME)) {
X#endif /* HETEROGENEOUS /**/
X	    if (Errno == ETIMEOUT)
X		Errno = ETTRCVREPLY;
X	    (void) _close_connection(&_con_port);
X	    return(ERROR);
X	}
X	DEBUGPUTS("(TC) reply received!"); 
X	/* check reply */
X	reply = transdata.reply;
X	if (reply == TRANS_ACCEPT) {
X	    DEBUGPUTS("(TC) transaction ACCEPTED");
X	    trans_retry_delay = TRANS_RETRY_DELAY_MIN;
X#ifdef DEBUG_TRANSACTION
X	if (_debug_transaction) {
X	    fprintf(_debugout, "[tra] %s (TC) retry delay now %d\n", 
X	        _processprefix, trans_retry_delay);
X	    if (_debugflush)
X	        fflush(_debugout);
X	}
X#endif /* DEBUG_TRANSACTION /**/
X	    return(OK);
X	} else {
X	    DEBUGPUTS("(TC) transaction DENIED");
X	    if (_close_connection(&_con_port))
X		return(ERROR);
X#if defined(SCO_XENIX) || defined(SCO_UNIX) || defined(HPUX)
X	    nap(trans_retry_delay);
X#else
X# ifdef SPARC
X	    usleep(trans_retry_delay);
X# else
X	    sleep(trans_retry_delay);
X# endif /* SPARC /**/
X#endif /* SCO_XENIX || SCO_UNIX /**/
X	    if (trans_retry_delay < TRANS_RETRY_DELAY_MAX) {
X		trans_retry_delay += TRANS_RETRY_DELAY_STEP;
X	    }
X	    DEBUGPUTS("(TC) trying again");
X	}
X    } /* while */
X} /* _make_transaction_call */
X
X/******************************************************************************
X * _get_transaction_call()                                                    *
X *                                                                            *
X * Accepts a transaction request of type 'transaction'. 'con_port' is used    *
X * to return the connection descriptor specifying the established connection  *
X * upon success.                                                              *
X *                                                                            *
X * Return value: OK upon success / ERROR upon error                           *
X ******************************************************************************/
Xint
X_get_transaction_call(transaction)
Xchar *transaction;	/* transaction type */
X{
X    int reply, result;
X    static TRANSDATA transdata;
X    unsigned long size;
X
X#ifdef DEBUG_TRANSACTION
X    if (_debug_transaction) {
X        fprintf(_debugout, "[tra] %s (TA) getting transaction call >> %s <<\n",
X	    _processprefix, transaction);
X        if (_debugflush)
X            fflush(_debugout);
X    }
X#endif /* DEBUG_TRANSACTION /**/
X    while(1) {
X	/* get connection */
X	if (_accept_connection(&_con_port, &_own_port, ACCEPTCONTIME)) {
X		if (Errno == ETIMEOUT)
X			Errno = ETAACCEPTCON;
X		return(ERROR);
X	}
X	DEBUGPUTS("(TA) got a connection");
X	if (_receive_connection_type_or_answer() != TRANSACTION_CONNECTION) {
X            DEBUGPUTS("(TA) wrong connection accepted");
X            DEBUGPUTS("(TA) sending connection aborted (ABORT...)");
X            if (_send_connection_type_or_answer(ABORT_CONNECTION))
X                return(ERROR);
X            DEBUGPUTS("(TA) closing connection and trying again");
X            if (_close_connection(&_con_port))
X                return(ERROR);
X	    continue;
X	} else {
X	    DEBUGPUTS("(TA) sending connection accepted (ACCEPT...)");
X    	    if (_send_connection_type_or_answer(ACCEPT_CONNECTION))
X         	return(ERROR);
X	}
X	DEBUGPUTS("(TA) receiving request");
X	/* get transaction request */
X#if defined(SINGLE) || defined(HOMOGENEOUS)
X	if (_recv_data(&_con_port, (char *) &transdata, sizeof(TRANSDATA), ACCEPTREQTIME)<0){
X#else /* HETEROGENEOUS */
X	if (_recv_data_encoded(&_con_port, (char *) &transdata, xdr_TRANSDATA, ACCEPTREQTIME)){
X#endif /* HETEROGENEOUS /**/
X		if (Errno == ETIMEOUT)
X			Errno = ETARCVREQUEST;
X		return(ERROR);
X	}
X#ifdef DEBUG_TRANSACTION
X	if (_debug_transaction) {
X	    fprintf(_debugout, "[tra] %s (TA) request >> %s << received\n", 
X	        _processprefix, transdata.request);
X	    if (_debugflush)
X	        fflush(_debugout);
X	}
X#endif /* DEBUG_TRANSACTION /**/
X	result = !strcmp(transdata.request, transaction);
X	/* send reply */
X	if (result) {
X		DEBUGPUTS("(TA) transaction ACCEPTED");
X		reply = TRANS_ACCEPT;
X	} else {
X		DEBUGPUTS("(TA) transaction DENIED");
X		reply = TRANS_DENIED;
X	}
X	if (_SendTransCallReply(reply)) {
X		if (Errno == ETIMEOUT)
X			Errno = ETASENDREPLY;
X		return(ERROR);
X	}
X	if (result)
X	    return(OK);
X	DEBUGPUTS("(TA) trying again");
X	_close_connection(&_con_port);
X    } /* while */
X} /* _get_transaction_call */
END_OF_FILE
if test 14021 -ne `wc -c <'lib/transaction.c'`; then
    echo shar: \"'lib/transaction.c'\" unpacked with wrong size!
fi
# end of 'lib/transaction.c'
fi
echo shar: End of archive 10 \(of 18\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
