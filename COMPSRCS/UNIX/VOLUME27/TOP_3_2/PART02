Newsgroups: comp.sources.unix
From: phil@eecs.nwu.edu (William LeFebvre)
Subject: v27i002: top - a top process display, version 3.2, Part02/13
References: <1.744843136.4744@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: phil@eecs.nwu.edu (William LeFebvre)
Posting-Number: Volume 27, Issue 2
Archive-Name: top-3.2/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 13)."
# Contents:  INSTALL Porting commands.c screen.c top.X utils.c
# Wrapped by phil@pex on Wed Aug  4 14:22:40 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'INSTALL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'INSTALL'\"
else
echo shar: Extracting \"'INSTALL'\" \(6383 characters\)
sed "s/^X//" >'INSTALL' <<'END_OF_FILE'
X                             TOP
X                         Version 3.2
X
X                       William LeFebvre
X		     and a cast of dozens
X
XINSTALLATION
X
XConfiguration and installation of top is very straightforward.  After
Xunpacking the sources, run the script "Configure".  It will present you
Xwith a series of questions, all of which should be explained in the
Xpresentation.  After you have answered all the questions, "Configure" will
Xperform all the necessary configuration.  Once this is finished, type
X"make install".  Make will compile the sources then install the resulting
Xexecutable and manual page in the appropriate places.
X
XThe most difficult step in the configuration is the choice of an
Xappropriate machine-specific module.  The Configure script gives you a
Xlist of choices complete with brief descriptions of when each choice is
Xappropriate.  Each module is contained in a separate c file in the
Xdirectory "machine".  The module contains all of the machine-specific code
Xthat makes top work correctly on the architecture in question.  All of the
Xcode in the top-level directory is machine-independent (or at least
Xstrives to be).  Hints for some module choices that are not obvious are
Xgiven at the end of this file.
X
XThe first comment in each c file in that directory contains the synopsis
XAND a detailed description of the machines for which that module is
Xappropriate.  It also contains a list of authors for that module.  If you
Xare really stumped in this choice, use grep to find your machine
Xmanufacturer's name or operating system name in machine/*.c.  If you still
Xcan't find one that is appropriate, then chances are very good that one
Xhasn't been written yet.  If that is the case, then you are out of luck.
X
XHANDLING MULTIPLE ARCHITECTURES
X
XIf you need to recompile top for a different architecture (that is, using
Xa different module) you need to reconfigure top.  A short cut is available
Xto make this a little easier.  If all of your previous answers to the
Xconfiguration questions (except for the module name of course) are
Xadequate for the new architecture, then you can just use the command
X"Configure <modulename>".  The configuration script will reconfigure top
Xusing the new module and all the answers you gave last time.  It will
Xfinish with a "make clean".  Once that completes, type "make install"
Xand make will compile the sources and do the installation.
X
XHANDLING MULTIPLE OS VERSIONS
X
XBy far the most frequently received bug report for top is something like
Xthis: "We just upgraded our operating system to version 99.9.9.9 and top
Xbroke.  What should we do?"  The simple answer is "recompile".
X
XTop is very sensitive to changes in internal kernel data structures
X(especially the proc and user structures).  Some operating systems
X(especially SunOS) are notorious for changing these structure in every
Xminor release of the OS.  This means that a top executable made under one
Xversion of the OS will not always work correctly (if even at all) under
Xanother version.  This is just one of those tough facts of life.  There is
Xreally no way around it.
X
XTo make life even worse, some operating systems (SunOS again) will use
Xslightly different proc and user structures on different models.  For
Xexample, "top" built on a SparcStation 2 will not run correctly on a
XSparcStation 10, even if they are both running SunOS 4.1.3.  These
Xunfortunate circumstances makes maintaining top very difficult, especially
Xin an environment that runs several different versions of the same
Xoperating system.
X
XBut there is hope.  If your operating system has a properly functioning
X"uname" command then you can handle this problem rather gracefully.
XIncluded in the distribution is a shell file called "metatop".  All this
Xshell file does is:
X
X	exec top-`uname -m`-`uname -r` "$@"
X
XSo when you run this script, it execs a filename that is unique to your
Xspecific machine architecture and your OS revision number.
X
XTo use "metatop", do the following:
X
X	. on any machine, run Configure and choose the module that is
X	  appropriate for the machine
X	. for all machines which use the same module:
X	    . group machines according to machine architecture AND OS
X	      revision number (i.e.: sun4-4.1.1, sun4c-4.1.1, sun4c-4.1.2,
X	      sun4-4.1.3, sun4c-4.1.3, sun4m-4.1.3, ...)
X	    . for each group, choose one machine from that group and on it
X	      run "make clean; make installmeta".
X
X
XThe "installmeta" rule in the makefile will insure that top is compiled,
Xinstall the shell file "metatop" as "top", then install the executable
X"top" with a name appropriate to the machine architecture and OS revision.
X
X
XHINTS FOR CHOOSING THE CORRECT MODULE:
X
XSUN MULTIPROCESSOR ARCHITECTURES
X
XFirst, we need to be speaking the same language:
X
Xsun4	a regular sparc sun 4 architecture machine (sparc station 1,
X	sparc station 2, IPC, SLC, etc.)
X
Xsun4m	a multiprocessor sparc (Sparc 10, 4/670, 4/690)
X
XI intended to write the sunos4 module so that an executable compiled on a
Xsun4m machine would work correctly on a sun4 machine.  Unfortunately my
Xexperiments indicate that this cannot be done.  It turns out that the user
Xstructure is so different between these two architectures that nothing
Xshort of a serious hack will make the same executable work correctly on
Xboth machines.  I recommend that you use the separate module "sunos4mp"
Xwhen making an executable for a sun4m architecture, and use "sunos4" when
Xmaking an executable for sun4 or sun4c architectures.
X
XThere is a bug in the sunos5 module which prevents it from working
Xcorrectly on machines that contain more than one processor (single
Xprocessor sun4m machines seem to run just fine).  A fix is pending.
X
XSOLBOURNE OPERATING SYSTEM (OS/MP)
X
XIf you are running OS/MP version 4.1A, then use the module "osmp4.1a".
X
XIf you are running a version of OS/MP OLDER than 4.1A (that is, one
Xof its predecessors), use the module "sunos4".
X
XIf you are running OS/MP 4.1B or LATER, use the module "sunos4mp".
X
XHP/UX OPERATING SYSTEM
X
XThe module hpux8 works on all version 8 systems.  Some say that it works
Xwith version 9 as well, but one user did send me a separate module for
Xversion 9.  This module has only been tested on series 800 machines.  I
Xwould recommend the following for those running version 9: try hpux9 and
Xif it doesn't work then try hpux8.  If neither work, then send mail to me
Xand/or the modules' authors.
X
END_OF_FILE
if test 6383 -ne `wc -c <'INSTALL'`; then
    echo shar: \"'INSTALL'\" unpacked with wrong size!
fi
# end of 'INSTALL'
fi
if test -f 'Porting' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Porting'\"
else
echo shar: Extracting \"'Porting'\" \(7055 characters\)
sed "s/^X//" >'Porting' <<'END_OF_FILE'
XInstructions for porting top to other architectures.
X
XThis is still a preliminary document.  Suggestions for improvement are
Xmost welcome.
X
XMy address is "phil@eecs.nwu.edu".
X
XBefore you embark on a port, please send me a mail message telling me
Xwhat platform you are porting top to.  There are three reasons for
Xthis: (1) I may already have a port, (2) module naming needs to be
Xcentralized, (3) I want to loosely track the various porting efforts.
XYou do not need to wait for an "okay", but I do want to know that you
Xare working on it.  And of course, once it is finished, please send me
Xthe module files so that I can add them to the main distribution!
X
X----------
X
XThere is one set of functions which extract all the information that
Xtop needs for display.  These functions are collected in to one file.
XTo make top work on a different architecture simply requires a
Xdifferent implementation of these functions.  The functions for a
Xgiven architecture "foo" are stored in a file called "m_foo.c".  The
XConfigure script looks for these files and lets the configurer choose
Xone of them.  This file is called a "module".  The idea is that making
Xtop work on a different machine only requires one additional file and
Xdoes not require changes to any existing files.
X
XA module template is included in the distribution, called "m-template".
XTo write your own module, it is a good idea to start with this template.
XIf you architecture is similar to one for which a module already
Xexists, then you can start with that module instead.  If you do so,
Xremember to change the "AUTHOR" section at the top!
X
XThe first comment in a module contains information which is extracted
Xand used by Configure.  This information is marked with words in all
Xcapitals (such as "SYNOPSIS:" and "LIBS:").  Go look at m-template: it
Xis fairly self-explanatory.  The text after "LIBS:" (on the same line)
Xis extracted and included in the LIBS definition of the Makefile so
Xthat extra libraries which may be necessary on some machines (such as
X"-lkvm") can be specified in the module.  The text after "CFLAGS:"
X(on the same line) is extracted and included as flags in the "CFLAGS"
Xdefinition of the Makefile (thus in every compilation step).  This is
Xused for rare circumstances only:  please don't abuse this hook.
X
XSome operating systems have idiosyncrasies which will affect the form
Xand/or content of the information top displays.  You may wish to
Xdocument such anomalies in the top man page.  This can be done by adding
Xa file called m_{modulename}.man (where {modulename} is replaced with
Xthe name of the module).  Configure will automatically add this file to
Xthe end of the man page.  See m_sunos4.man for an example.
X
XA module is concerned with two structures:
X
XThe statics struct is filled in by machine_init.  Each item is a
Xpointer to a list of character pointers.  The list is terminated 
Xwith a null pointer.
X
Xstruct statics
X{
X    char **procstate_names;	/* process state names */
X    char **cpustate_names;	/* cpu state names */
X    char **memory_names;	/* memory information names */
X};
X
XThe system_info struct is filled in by get_system_info and
Xget_process_info.
X
Xstruct system_info
X{
X    int    last_pid;     /* last pid assigned (0 means non-sequential assignment) */
X    double load_avg[NUM_AVERAGES];     /* see below */
X    int    p_total;      /* total number of processes */
X    int    p_active;     /* number of procs considered "active" */
X    int    *procstates;  /* array of process state counters */
X    int    *cpustates;   /* array of cpustate counters */
X    int    *memory;      /* memory information */
X};
X
XThe last three pointers each point to an array of integers.  The
Xlength of the array is determined by the length of the corresponding
X_names array in the statics structure.  Furthermore, if an entry in a
X_names array is the empty string ("") then the corresponding value in
Xthe value array will be skipped over.  The display routine displays,
Xfor example, the string procstate_names[0] then the number
Xprocstates[0], then procstate_names[1], procstates[1], etc. until
Xprocstate_names[N] == NULL.  This allows for a tremendous amount of
Xflexibility in labeling the displayed values.
X
X"procstates" and "memory" are displayed as straight integer values.
XValues in "cpustates" are displayed as a percentage * 10.  For
Xexample, the (integer) value 105 is displayed as 10.5%.
X
XThese routines must be defined by the machine dependent module.
X
Xint machine_init(struct statics *)
X
X	returns 0 on success and -1 on failure,
X	prints error messages
X
Xchar *format_header(char *)
X
X	Returns a string which should be used as the header for the
X	process display area.  The argument is a string used to label
X	the username column (either "USERNAME" or "UID") and is always
X	8 characters in length.
X
Xvoid get_system_info(struct system_info *)
X
Xcaddr_t get_process_info(struct system_info *, int, int, int (*func)())
X
X	returns a handle to use with format_next_process
X
Xchar *format_next_process(caddr_t, char *(*func)())
X
X	returns string which describes next process
X
Xint proc_compare(caddr_t, caddr_t)
X
X	qsort comparison function
X
Xuid_t proc_owner(pid_t)
X
X	Returns the uid owner of the process specified by the pid argument.
X	This function is VERY IMPORTANT.  If it fails to do its job, then
X	top may pose a security risk.
X
X
Xget_process_info is called immediately after get_system_info.  In
Xfact, the two functions could be rolled in to one.  The reason they
Xare not is mostly historical.
X
XTop relies on the existence of a function called "setpriority" to
Xchange a process's priority.  This exists as a kernel call on most 4.3
XBSD derived Unixes.  If neither your operating system nor your C
Xlibrary supplies such a function, then you will need to add one to the
Xmodule.  It is defined as follows:
X
X	int setpriority (int dummy, int who, int niceval)
X
X	For the purposes of top, the first argument is meaningless.
X	The second is the pid and the third is the new nice value.
X	This function should behave just like a kernel call, setting
X	errno and returning -1 in case of an error.  This function MUST
X	check to make sure that a non-root user does not specify a nice
X	value less than the process's current value.  If it detects such
X	a condition, it should set errno to EACCES and return -1.
X	Other possible ERRNO values:  ESRCH when pid "who" does not exist,
X	EPERM when the invoker is not root and not the same as the
X	process owner.
X
XNote that top checks process ownership and should never call setpriority
Xwhen the invoker's uid is not root and not the same as the process's owner
Xuid.
X
X
XThe file "machine.h" contains definitions which are useful to modules
Xand to top.c (such as the structure definitions).  You SHOULD NOT need
Xto change it when porting to a new platform.
X
XPorting to a new platform should NOT require any changes to existing
Xfiles.  You should only need to add m_ files.  If you feel you need a
Xchange in one of the existing files, please contact me so that we can
Xdiscuss the details.  I want to keep such changes as general as
Xpossible.
X
END_OF_FILE
if test 7055 -ne `wc -c <'Porting'`; then
    echo shar: \"'Porting'\" unpacked with wrong size!
fi
# end of 'Porting'
fi
if test -f 'commands.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'commands.c'\"
else
echo shar: Extracting \"'commands.c'\" \(9977 characters\)
sed "s/^X//" >'commands.c' <<'END_OF_FILE'
X/*
X *  Top users/processes display for Unix
X *  Version 3
X *
X *  This program may be freely redistributed,
X *  but this entire comment MUST remain intact.
X *
X *  Copyright (c) 1984, 1989, William LeFebvre, Rice University
X *  Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
X */
X
X/*
X *  This file contains the routines that implement some of the interactive
X *  mode commands.  Note that some of the commands are implemented in-line
X *  in "main".  This is necessary because they change the global state of
X *  "top" (i.e.:  changing the number of processes to display).
X */
X
X#include "os.h"
X#include <ctype.h>
X#include <signal.h>
X#include <errno.h>
X#include <sys/time.h>
X#include <sys/resource.h>
X
X#include "sigdesc.h"		/* generated automatically */
X#include "boolean.h"
X#include "utils.h"
X
Xextern int  errno;
X
Xextern char *copyright;
X
X/* imported from screen.c */
Xextern int overstrike;
X
Xint err_compar();
Xchar *err_string();
X
X/*
X *  show_help() - display the help screen; invoked in response to
X *		either 'h' or '?'.
X */
X
Xshow_help()
X
X{
X    printf("Top version %s, %s\n", version_string(), copyright);
X    fputs("\n\n\
XA top users display for Unix\n\
X\n\
XThese single-character commands are available:\n\
X\n\
X^L      - redraw screen\n\
Xq       - quit\n\
Xh or ?  - help; show this text\n", stdout);
X
X    /* not all commands are availalbe with overstrike terminals */
X    if (overstrike)
X    {
X	fputs("\n\
XOther commands are also available, but this terminal is not\n\
Xsophisticated enough to handle those commands gracefully.\n\n", stdout);
X    }
X    else
X    {
X	fputs("\
Xd       - change number of displays to show\n\
Xe       - list errors generated by last \"kill\" or \"renice\" command\n\
Xi       - toggle the displaying of idle processes\n\
XI       - same as 'i'\n\
Xk       - kill processes; send a signal to a list of processes\n\
Xn or #  - change number of processes to display\n\
Xr       - renice a process\n\
Xs       - change number of seconds to delay between updates\n\
Xu       - display processes for only one user (+ selects all users)\n\
X\n\
X\n", stdout);
X    }
X}
X
X/*
X *  Utility routines that help with some of the commands.
X */
X
Xchar *next_field(str)
X
Xregister char *str;
X
X{
X    if ((str = strchr(str, ' ')) == NULL)
X    {
X	return(NULL);
X    }
X    *str = '\0';
X    while (*++str == ' ') /* loop */;
X    return(str);
X}
X
Xscanint(str, intp)
X
Xchar *str;
Xint  *intp;
X
X{
X    register int val = 0;
X    register char ch;
X
X    while ((ch = *str++) != '\0')
X    {
X	if (isdigit(ch))
X	{
X	    val = val * 10 + (ch - '0');
X	}
X	else if (isspace(ch))
X	{
X	    break;
X	}
X	else
X	{
X	    return(-1);
X	}
X    }
X    *intp = val;
X    return(0);
X}
X
X/*
X *  Some of the commands make system calls that could generate errors.
X *  These errors are collected up in an array of structures for later
X *  contemplation and display.  Such routines return a string containing an
X *  error message, or NULL if no errors occurred.  The next few routines are
X *  for manipulating and displaying these errors.  We need an upper limit on
X *  the number of errors, so we arbitrarily choose 20.
X */
X
X#define ERRMAX 20
X
Xstruct errs		/* structure for a system-call error */
X{
X    int  errno;		/* value of errno (that is, the actual error) */
X    char *arg;		/* argument that caused the error */
X};
X
Xstatic struct errs errs[ERRMAX];
Xstatic int errcnt;
Xstatic char *err_toomany = " too many errors occurred";
Xstatic char *err_listem = 
X	" Many errors occurred.  Press `e' to display the list of errors.";
X
X/* These macros get used to reset and log the errors */
X#define ERR_RESET   errcnt = 0
X#define ERROR(p, e) if (errcnt >= ERRMAX) \
X		    { \
X			return(err_toomany); \
X		    } \
X		    else \
X		    { \
X			errs[errcnt].arg = (p); \
X			errs[errcnt++].errno = (e); \
X		    }
X
X/*
X *  err_string() - return an appropriate error string.  This is what the
X *	command will return for displaying.  If no errors were logged, then
X *	return NULL.  The maximum length of the error string is defined by
X *	"STRMAX".
X */
X
X#define STRMAX 80
X
Xchar *err_string()
X
X{
X    register struct errs *errp;
X    register int  cnt = 0;
X    register int  first = Yes;
X    register int  currerr = -1;
X    int stringlen;		/* characters still available in "string" */
X    static char string[STRMAX];
X
X    /* if there are no errors, return NULL */
X    if (errcnt == 0)
X    {
X	return(NULL);
X    }
X
X    /* sort the errors */
X    qsort((char *)errs, errcnt, sizeof(struct errs), err_compar);
X
X    /* need a space at the front of the error string */
X    string[0] = ' ';
X    string[1] = '\0';
X    stringlen = STRMAX - 2;
X
X    /* loop thru the sorted list, building an error string */
X    while (cnt < errcnt)
X    {
X	errp = &(errs[cnt++]);
X	if (errp->errno != currerr)
X	{
X	    if (currerr != -1)
X	    {
X		if ((stringlen = str_adderr(string, stringlen, currerr)) < 2)
X		{
X		    return(err_listem);
X		}
X		(void) strcat(string, "; ");	  /* we know there's more */
X	    }
X	    currerr = errp->errno;
X	    first = Yes;
X	}
X	if ((stringlen = str_addarg(string, stringlen, errp->arg, first)) ==0)
X	{
X	    return(err_listem);
X	}
X	first = No;
X    }
X
X    /* add final message */
X    stringlen = str_adderr(string, stringlen, currerr);
X
X    /* return the error string */
X    return(stringlen == 0 ? err_listem : string);
X}
X
X/*
X *  str_adderr(str, len, err) - add an explanation of error "err" to
X *	the string "str".
X */
X
Xstr_adderr(str, len, err)
X
Xchar *str;
Xint len;
Xint err;
X
X{
X    register char *msg;
X    register int  msglen;
X
X    msg = err == 0 ? "Not a number" : errmsg(err);
X    msglen = strlen(msg) + 2;
X    if (len <= msglen)
X    {
X	return(0);
X    }
X    (void) strcat(str, ": ");
X    (void) strcat(str, msg);
X    return(len - msglen);
X}
X
X/*
X *  str_addarg(str, len, arg, first) - add the string argument "arg" to
X *	the string "str".  This is the first in the group when "first"
X *	is set (indicating that a comma should NOT be added to the front).
X */
X
Xstr_addarg(str, len, arg, first)
X
Xchar *str;
Xint  len;
Xchar *arg;
Xint  first;
X
X{
X    register int arglen;
X
X    arglen = strlen(arg);
X    if (!first)
X    {
X	arglen += 2;
X    }
X    if (len <= arglen)
X    {
X	return(0);
X    }
X    if (!first)
X    {
X	(void) strcat(str, ", ");
X    }
X    (void) strcat(str, arg);
X    return(len - arglen);
X}
X
X/*
X *  err_compar(p1, p2) - comparison routine used by "qsort"
X *	for sorting errors.
X */
X
Xerr_compar(p1, p2)
X
Xregister struct errs *p1, *p2;
X
X{
X    register int result;
X
X    if ((result = p1->errno - p2->errno) == 0)
X    {
X	return(strcmp(p1->arg, p2->arg));
X    }
X    return(result);
X}
X
X/*
X *  error_count() - return the number of errors currently logged.
X */
X
Xerror_count()
X
X{
X    return(errcnt);
X}
X
X/*
X *  show_errors() - display on stdout the current log of errors.
X */
X
Xshow_errors()
X
X{
X    register int cnt = 0;
X    register struct errs *errp = errs;
X
X    printf("%d error%s:\n\n", errcnt, errcnt == 1 ? "" : "s");
X    while (cnt++ < errcnt)
X    {
X	printf("%5s: %s\n", errp->arg,
X	    errp->errno == 0 ? "Not a number" : errmsg(errp->errno));
X	errp++;
X    }
X}
X
X/*
X *  kill_procs(str) - send signals to processes, much like the "kill"
X *		command does; invoked in response to 'k'.
X */
X
Xchar *kill_procs(str)
X
Xchar *str;
X
X{
X    register char *nptr;
X    int signum = SIGTERM;	/* default */
X    int procnum;
X    struct sigdesc *sigp;
X    int uid;
X
X    /* reset error array */
X    ERR_RESET;
X
X    /* remember our uid */
X    uid = getuid();
X
X    if (str[0] == '-')
X    {
X	/* explicit signal specified */
X	if ((nptr = next_field(str)) == NULL)
X	{
X	    return(" kill: no processes specified");
X	}
X
X	if (isdigit(str[1]))
X	{
X	    (void) scanint(str + 1, &signum);
X	    if (signum <= 0 || signum >= NSIG)
X	    {
X		return(" invalid signal number");
X	    }
X	}
X	else 
X	{
X	    /* translate the name into a number */
X	    for (sigp = sigdesc; sigp->name != NULL; sigp++)
X	    {
X		if (strcmp(sigp->name, str + 1) == 0)
X		{
X		    signum = sigp->number;
X		    break;
X		}
X	    }
X
X	    /* was it ever found */
X	    if (sigp->name == NULL)
X	    {
X		return(" bad signal name");
X	    }
X	}
X	/* put the new pointer in place */
X	str = nptr;
X    }
X
X    /* loop thru the string, killing processes */
X    do
X    {
X	if (scanint(str, &procnum) == -1)
X	{
X	    ERROR(str, 0);
X	}
X	else
X	{
X	    /* check process owner if we're not root */
X	    if (uid && (uid != proc_owner(procnum)))
X	    {
X		ERROR(str, EACCES);
X	    }
X	    /* go in for the kill */
X	    else if (kill(procnum, signum) == -1)
X	    {
X		/* chalk up an error */
X		ERROR(str, errno);
X	    }
X	}
X    } while ((str = next_field(str)) != NULL);
X
X    /* return appropriate error string */
X    return(err_string());
X}
X
X/*
X *  renice_procs(str) - change the "nice" of processes, much like the
X *		"renice" command does; invoked in response to 'r'.
X */
X
Xchar *renice_procs(str)
X
Xchar *str;
X
X{
X    register char negate;
X    int prio;
X    int procnum;
X    int uid;
X
X    ERR_RESET;
X    uid = getuid();
X
X    /* allow for negative priority values */
X    if ((negate = (*str == '-')) != 0)
X    {
X	/* move past the minus sign */
X	str++;
X    }
X
X    /* use procnum as a temporary holding place and get the number */
X    procnum = scanint(str, &prio);
X
X    /* negate if necessary */
X    if (negate)
X    {
X	prio = -prio;
X    }
X
X#if defined(PRIO_MIN) && defined(PRIO_MAX)
X    /* check for validity */
X    if (procnum == -1 || prio <= PRIO_MIN || prio >= PRIO_MAX)
X    {
X	return(" bad priority value");
X    }
X#endif
X
X    /* move to the first process number */
X    if ((str = next_field(str)) == NULL)
X    {
X	return(" no processes specified");
X    }
X
X    /* loop thru the process numbers, renicing each one */
X    do
X    {
X	if (scanint(str, &procnum) == -1)
X	{
X	    ERROR(str, 0);
X	}
X
X	/* check process owner if we're not root */
X	else if (uid && (uid != proc_owner(procnum)))
X	{
X	    ERROR(str, EACCES);
X	}
X	else if (setpriority(PRIO_PROCESS, procnum, prio) == -1)
X	{
X	    ERROR(str, errno);
X	}
X    } while ((str = next_field(str)) != NULL);
X
X    /* return appropriate error string */
X    return(err_string());
X}
X
END_OF_FILE
if test 9977 -ne `wc -c <'commands.c'`; then
    echo shar: \"'commands.c'\" unpacked with wrong size!
fi
# end of 'commands.c'
fi
if test -f 'screen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screen.c'\"
else
echo shar: Extracting \"'screen.c'\" \(9175 characters\)
sed "s/^X//" >'screen.c' <<'END_OF_FILE'
X/*
X *  Top users/processes display for Unix
X *  Version 3
X *
X *  This program may be freely redistributed,
X *  but this entire comment MUST remain intact.
X *
X *  Copyright (c) 1984, 1989, William LeFebvre, Rice University
X *  Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
X */
X
X/*  This file contains the routines that interface to termcap and stty/gtty.
X *
X *  Paul Vixie, February 1987: converted to use ioctl() instead of stty/gtty.
X *
X *  I put in code to turn on the TOSTOP bit while top was running, but I
X *  didn't really like the results.  If you desire it, turn on the
X *  preprocessor variable "TOStop".   --wnl
X */
X
X#include "os.h"
X
X#include <sys/ioctl.h>
X#ifdef CBREAK
X# include <sgtty.h>
X# define SGTTY
X#else
X# ifdef TCGETA
X#  define TERMIO
X#  include <termio.h>
X# else
X#  define TERMIOS
X#  include <termios.h>
X# endif
X#endif
X#if defined(TERMIO) || defined(TERMIOS)
X# ifndef TAB3
X#  ifdef OXTABS
X#   define TAB3 OXTABS
X#  else
X#   define TAB3 0
X#  endif
X# endif
X#endif
X#include "screen.h"
X#include "boolean.h"
X
Xextern char *myname;
X
Xint putstdout();
X
Xint  overstrike;
Xint  screen_length;
Xint  screen_width;
Xchar ch_erase;
Xchar ch_kill;
Xchar smart_terminal;
Xchar PC;
Xchar *tgetstr();
Xchar *tgoto();
Xchar termcap_buf[1024];
Xchar string_buffer[1024];
Xchar home[15];
Xchar lower_left[15];
Xchar *clear_line;
Xchar *clear_screen;
Xchar *clear_to_end;
Xchar *cursor_motion;
Xchar *start_standout;
Xchar *end_standout;
Xchar *terminal_init;
Xchar *terminal_end;
Xshort ospeed;
X
X#ifdef SGTTY
Xstatic struct sgttyb old_settings;
Xstatic struct sgttyb new_settings;
X#endif
X#ifdef TERMIO
Xstatic struct termio old_settings;
Xstatic struct termio new_settings;
X#endif
X#ifdef TERMIOS
Xstatic struct termios old_settings;
Xstatic struct termios new_settings;
X#endif
Xstatic char is_a_terminal = No;
X#ifdef TOStop
Xstatic int old_lword;
Xstatic int new_lword;
X#endif
X
X#define	STDIN	0
X#define	STDOUT	1
X#define	STDERR	2
X
Xinit_termcap()
X
X{
X    char *bufptr;
X    char *PCptr;
X    char *term_name;
X    char *getenv();
X    int status;
X
X    /* assume we have a smart terminal until proven otherwise */
X    smart_terminal = Yes;
X
X    /* get the terminal name */
X    term_name = getenv("TERM");
X
X    /* if there is no TERM, assume it's a dumb terminal */
X    /* patch courtesy of Sam Horrocks at telegraph.ics.uci.edu */
X    if (term_name == NULL)
X    {
X	smart_terminal = No;
X	return;
X    }
X
X    /* now get the termcap entry */
X    if ((status = tgetent(termcap_buf, term_name)) != 1)
X    {
X	if (status == -1)
X	{
X	    fprintf(stderr, "%s: can't open termcap file\n", myname);
X	}
X	else
X	{
X	    fprintf(stderr, "%s: no termcap entry for a `%s' terminal\n",
X		    myname, term_name);
X	}
X
X	/* pretend it's dumb and proceed */
X	smart_terminal = No;
X	return;
X    }
X
X    /* "hardcopy" immediately indicates a very stupid terminal */
X    if (tgetflag("hc"))
X    {
X	smart_terminal = No;
X	return;
X    }
X
X    /* set up common terminal capabilities */
X    if ((screen_length = tgetnum("li")) <= 0)
X    {
X	screen_length = smart_terminal = 0;
X	return;
X    }
X
X    /* screen_width is a little different */
X    if ((screen_width = tgetnum("co")) == -1)
X    {
X	screen_width = 79;
X    }
X    else
X    {
X	screen_width -= 1;
X    }
X
X#ifdef TIOCGWINSZ
X    {
X	struct winsize ws;
X
X	if (ioctl (1, TIOCGWINSZ, &ws) != -1)
X	{
X	    if (ws.ws_row != 0)
X	    {
X		screen_length = ws.ws_row;
X	    }
X	    if (ws.ws_col != 0)
X	    {
X		screen_width = ws.ws_col - 1;
X	    }
X	}
X    }
X#else
X#ifdef TIOCGSIZE
X    {
X	struct ttysize ts;
X
X	if (ioctl (1, TIOCGSIZE, &ts) != -1)
X	{
X	    if (ts.ts_lines != 0)
X	    {
X		screen_length = ts.ts_lines;
X	    }
X	    if (ts.ts_cols != 0)
X	    {
X		screen_width = ts.ts_cols - 1;
X	    }
X	}
X    }
X#endif /* TIOCGSIZE */
X#endif /* TIOCGWINSZ */
X
X    /* terminals that overstrike need special attention */
X    overstrike = tgetflag("os");
X
X    /* initialize the pointer into the termcap string buffer */
X    bufptr = string_buffer;
X
X    /* get "ce", clear to end */
X    if (!overstrike)
X    {
X	clear_line = tgetstr("ce", &bufptr);
X    }
X
X    /* get necessary capabilities */
X    if ((clear_screen  = tgetstr("cl", &bufptr)) == NULL ||
X	(cursor_motion = tgetstr("cm", &bufptr)) == NULL)
X    {
X	smart_terminal = No;
X	return;
X    }
X
X    /* get some more sophisticated stuff -- these are optional */
X    clear_to_end   = tgetstr("cd", &bufptr);
X    terminal_init  = tgetstr("ti", &bufptr);
X    terminal_end   = tgetstr("te", &bufptr);
X    start_standout = tgetstr("so", &bufptr);
X    end_standout   = tgetstr("se", &bufptr);
X
X    /* pad character */
X    PC = (PCptr = tgetstr("pc", &bufptr)) ? *PCptr : 0;
X
X    /* set convenience strings */
X    (void) strcpy(home, tgoto(cursor_motion, 0, 0));
X    (void) strcpy(lower_left, tgoto(cursor_motion, 0, screen_length - 1));
X
X    /* if stdout is not a terminal, pretend we are a dumb terminal */
X#ifdef SGTTY
X    if (ioctl(STDOUT, TIOCGETP, &old_settings) == -1)
X    {
X	smart_terminal = No;
X    }
X#endif
X#ifdef TERMIO
X    if (ioctl(STDOUT, TCGETA, &old_settings) == -1)
X    {
X	smart_terminal = No;
X    }
X#endif
X#ifdef TERMIOS
X    if (tcgetattr(STDOUT, &old_settings) == -1)
X    {
X	smart_terminal = No;
X    }
X#endif
X}
X
Xinit_screen()
X
X{
X    /* get the old settings for safe keeping */
X#ifdef SGTTY
X    if (ioctl(STDOUT, TIOCGETP, &old_settings) != -1)
X    {
X	/* copy the settings so we can modify them */
X	new_settings = old_settings;
X
X	/* turn on CBREAK and turn off character echo and tab expansion */
X	new_settings.sg_flags |= CBREAK;
X	new_settings.sg_flags &= ~(ECHO|XTABS);
X	(void) ioctl(STDOUT, TIOCSETP, &new_settings);
X
X	/* remember the erase and kill characters */
X	ch_erase = old_settings.sg_erase;
X	ch_kill  = old_settings.sg_kill;
X
X#ifdef TOStop
X	/* get the local mode word */
X	(void) ioctl(STDOUT, TIOCLGET, &old_lword);
X
X	/* modify it */
X	new_lword = old_lword | LTOSTOP;
X	(void) ioctl(STDOUT, TIOCLSET, &new_lword);
X#endif
X	/* remember that it really is a terminal */
X	is_a_terminal = Yes;
X
X	/* send the termcap initialization string */
X	putcap(terminal_init);
X    }
X#endif
X#ifdef TERMIO
X    if (ioctl(STDOUT, TCGETA, &old_settings) != -1)
X    {
X	/* copy the settings so we can modify them */
X	new_settings = old_settings;
X
X	/* turn off ICANON, character echo and tab expansion */
X	new_settings.c_lflag &= ~(ICANON|ECHO);
X	new_settings.c_oflag &= ~(TAB3);
X	new_settings.c_cc[VMIN] = 1;
X	new_settings.c_cc[VTIME] = 0;
X	(void) ioctl(STDOUT, TCSETA, &new_settings);
X
X	/* remember the erase and kill characters */
X	ch_erase = old_settings.c_cc[VERASE];
X	ch_kill  = old_settings.c_cc[VKILL];
X
X	/* remember that it really is a terminal */
X	is_a_terminal = Yes;
X
X	/* send the termcap initialization string */
X	putcap(terminal_init);
X    }
X#endif
X#ifdef TERMIOS
X    if (tcgetattr(STDOUT, &old_settings) != -1)
X    {
X	/* copy the settings so we can modify them */
X	new_settings = old_settings;
X
X	/* turn off ICANON, character echo and tab expansion */
X	new_settings.c_lflag &= ~(ICANON|ECHO);
X	new_settings.c_oflag &= ~(TAB3);
X	new_settings.c_cc[VMIN] = 1;
X	new_settings.c_cc[VTIME] = 0;
X	(void) tcsetattr(STDOUT, TCSADRAIN, &new_settings);
X
X	/* remember the erase and kill characters */
X	ch_erase = old_settings.c_cc[VERASE];
X	ch_kill  = old_settings.c_cc[VKILL];
X
X	/* remember that it really is a terminal */
X	is_a_terminal = Yes;
X
X	/* send the termcap initialization string */
X	putcap(terminal_init);
X    }
X#endif
X
X    if (!is_a_terminal)
X    {
X	/* not a terminal at all---consider it dumb */
X	smart_terminal = No;
X    }
X}
X
Xend_screen()
X
X{
X    /* move to the lower left, clear the line and send "te" */
X    if (smart_terminal)
X    {
X	putcap(lower_left);
X	putcap(clear_line);
X	putcap(terminal_end);
X    }
X
X    /* if we have settings to reset, then do so */
X    if (is_a_terminal)
X    {
X#ifdef SGTTY
X	(void) ioctl(STDOUT, TIOCSETP, &old_settings);
X#ifdef TOStop
X	(void) ioctl(STDOUT, TIOCLSET, &old_lword);
X#endif
X#endif
X#ifdef TERMIO
X	(void) ioctl(STDOUT, TCSETA, &old_settings);
X#endif
X#ifdef TERMIOS
X	(void) tcsetattr(STDOUT, TCSADRAIN, &old_settings);
X#endif
X    }
X}
X
Xreinit_screen()
X
X{
X    /* install our settings if it is a terminal */
X    if (is_a_terminal)
X    {
X#ifdef SGTTY
X	(void) ioctl(STDOUT, TIOCSETP, &new_settings);
X#ifdef TOStop
X	(void) ioctl(STDOUT, TIOCLSET, &new_lword);
X#endif
X#endif
X#ifdef TERMIO
X	(void) ioctl(STDOUT, TCSETA, &new_settings);
X#endif
X#ifdef TERMIOS
X	(void) tcsetattr(STDOUT, TCSADRAIN, &new_settings);
X#endif
X    }
X
X    /* send init string */
X    if (smart_terminal)
X    {
X	putcap(terminal_init);
X    }
X}
X
Xstandout(msg)
X
Xchar *msg;
X
X{
X    if (smart_terminal)
X    {
X	putcap(start_standout);
X	fputs(msg, stdout);
X	putcap(end_standout);
X    }
X    else
X    {
X	fputs(msg, stdout);
X    }
X}
X
Xclear()
X
X{
X    if (smart_terminal)
X    {
X	putcap(clear_screen);
X    }
X}
X
Xclear_eol(len)
X
Xint len;
X
X{
X    if (smart_terminal && !overstrike && len > 0)
X    {
X	if (clear_line)
X	{
X	    putcap(clear_line);
X	    return(0);
X	}
X	else
X	{
X	    while (len-- > 0)
X	    {
X		putchar(' ');
X	    }
X	    return(1);
X	}
X    }
X    return(-1);
X}
X
Xgo_home()
X
X{
X    if (smart_terminal)
X    {
X	putcap(home);
X    }
X}
X
X/* This has to be defined as a subroutine for tputs (instead of a macro) */
X
Xputstdout(ch)
X
Xchar ch;
X
X{
X    putchar(ch);
X}
X
END_OF_FILE
if test 9175 -ne `wc -c <'screen.c'`; then
    echo shar: \"'screen.c'\" unpacked with wrong size!
fi
# end of 'screen.c'
fi
if test -f 'top.X' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'top.X'\"
else
echo shar: Extracting \"'top.X'\" \(9942 characters\)
sed "s/^X//" >'top.X' <<'END_OF_FILE'
X.\" NOTE:  changes to the manual page for "top" should be made in the
X.\"        file "top.X" and NOT in the file "top.1".
X.nr N %topn%
X.nr D %delay%
X.TH TOP 1 Local
X.UC 4
X.SH NAME
Xtop \- display and update information about the top cpu processes
X.SH SYNOPSIS
X.B top
X[
X.B \-SbiInqu
X] [
X.BI \-d count
X] [
X.BI \-s time
X] [
X.BI \-U username
X] [
X.I number
X]
X.SH DESCRIPTION
X.\" This defines appropriate quote strings for nroff and troff
X.ds lq \&"
X.ds rq \&"
X.if t .ds lq ``
X.if t .ds rq ''
X.\" Just in case these number registers aren't set yet...
X.if \nN==0 .nr N 10
X.if \nD==0 .nr D 5
X.I Top
Xdisplays the top
X.if !\nN==-1 \nN
Xprocesses on the system and periodically updates this information.
X.if \nN==-1 \
X\{\
XIf standard output is an intelligent terminal (see below) then
Xas many processes as will fit on the terminal screen are displayed
Xby default.  Otherwise, a good number of them are shown (around 20).
X.\}
XRaw cpu percentage is used to rank the processes.  If
X.I number
Xis given, then the top
X.I number
Xprocesses will be displayed instead of the default.
X.PP
X.I Top
Xmakes a distinction between terminals that support advanced capabilities
Xand those that do not.  This
Xdistinction affects the choice of defaults for certain options.  In the
Xremainder of this document, an \*(lqintelligent\*(rq terminal is one that
Xsupports cursor addressing, clear screen, and clear to end of line.
XConversely, a \*(lqdumb\*(rq terminal is one that does not support such
Xfeatures.  If the output of
X.I top
Xis redirected to a file, it acts as if it were being run on a dumb
Xterminal.
X.SH OPTIONS
X.TP
X.B \-S
XShow system processes in the display.  Normally, system processes such as
Xthe pager and the swapper are not shown.  This option makes them visible.
X.TP
X.B \-b
XUse \*(lqbatch\*(rq mode.  In this mode, all input from the terminal is
Xignored.  Interrupt characters (such as ^C and ^\e) still have an effect.
XThis is the default on a dumb terminal, or when the output is not a terminal.
X.TP
X.B \-i
XUse \*(lqinteractive\*(rq mode.  In this mode, any input is immediately
Xread for processing.  See the section on \*(lqInteractive Mode\*(rq
Xfor an explanation of
Xwhich keys perform what functions.  After the command is processed, the
Xscreen will immediately be updated, even if the command was not
Xunderstood.  This mode is the default when standard output is an
Xintelligent terminal.
X.TP
X.B \-I
XDo not display idle processes.
XBy default, top displays both active and idle processes.
X.TP
X.B \-n
XUse \*(lqnon-interactive\*(rq mode.  This is indentical to \*(lqbatch\*(rq
Xmode.
X.TP
X.B \-q
XRenice
X.I top
Xto -20 so that it will run faster.  This can be used when the system is
Xbeing very sluggish to improve the possibility of discovering the problem.
XThis option can only be used by root.
X.TP
X.B \-u
XDo not take the time to map uid numbers to usernames.  Normally,
X.I top
Xwill read as much of the file \*(lq/etc/passwd\*(rq as is necessary to map
Xall the user id numbers it encounters into login names.  This option
Xdisables all that, while possibly decreasing execution time.  The uid
Xnumbers are displayed instead of the names.
X.TP
X.BI \-d count
XShow only
X.I count
Xdisplays, then exit.  A display is considered to be one update of the
Xscreen.  This option allows the user to select the number of displays he
Xwants to see before
X.I top
Xautomatically exits.  For intelligent terminals, no upper limit
Xis set.  The default is 1 for dumb terminals.
X.TP
X.BI \-s time
XSet the delay between screen updates to
X.I time
Xseconds.  The default delay between updates is \nD seconds.
X.TP
X.BI \-U username
XShow only those processes owned by
X.IR username .
XThis option currently only accepts usernames and will not understand
Xuid numbers.
X.PP
XBoth
X.I count
Xand
X.I number
Xfields can be specified as \*(lqinfinite\*(rq, indicating that they can
Xstretch as far as possible.  This is accomplished by using any proper
Xprefix of the keywords
X\*(lqinfinity\*(rq,
X\*(lqmaximum\*(rq,
Xor
X\*(lqall\*(rq.
XThe default for
X.I count
Xon an intelligent terminal is, in fact,
X.BI infinity .
X.PP
XThe environment variable
X.B TOP
Xis examined for options before the command line is scanned.  This enables
Xa user to set his or her own defaults.  The number of processes to display
Xcan also be specified in the environment variable
X.BR TOP .
XThe options
X.BR \-I ,
X.BR \-S ,
Xand
X.B \-u
Xare actually toggles.  A second specification of any of these options
Xwill negate the first.  Thus a user who has the environment variable
X.B TOP
Xset to \*(lq-I\*(rq may use the command \*(lqtop -I\*(rq to see idle processes.
X.SH "INTERACTIVE MODE"
XWhen
X.I top
Xis running in \*(lqinteractive mode\*(rq, it reads commands from the
Xterminal and acts upon them accordingly.  In this mode, the terminal is
Xput in \*(lqCBREAK\*(rq, so that a character will be
Xprocessed as soon as it is typed.  Almost always, a key will be
Xpressed when
X.I top
Xis between displays; that is, while it is waiting for
X.I time
Xseconds to elapse.  If this is the case, the command will be
Xprocessed and the display will be updated immediately thereafter
X(reflecting any changes that the command may have specified).  This
Xhappens even if the command was incorrect.  If a key is pressed while 
X.I top
Xis in the middle of updating the display, it will finish the update and
Xthen process the command.  Some commands require additional information,
Xand the user will be prompted accordingly.  While typing this information
Xin, the user's erase and kill keys (as set up by the command
X.IR stty )
Xare recognized, and a newline terminates the input.
X.PP
XThese commands are currently recognized (^L refers to control-L):
X.TP
X.B ^L
XRedraw the screen.
X.IP "\fBh\fP\ or\ \fB?\fP"
XDisplay a summary of the commands (help screen).
X.TP
X.B q
XQuit
X.IR top.
X.TP
X.B d
XChange the number of displays to show (prompt for new number).
XRemember that the next display counts as one, so typing
X.B d1
Xwill make
X.I top
Xshow one final display and then immediately exit.
X.TP
X.B n or #
XChange the number of processes to display (prompt for new number).
X.TP
X.B s
XChange the number of seconds to delay between displays
X(prompt for new number).
X.TP
X.B k
XSend a signal (\*(lqkill\*(rq by default) to a list of processes.  This
Xacts similarly to the command
X.IR kill (1)).
X.TP
X.B r
XChange the priority (the \*(lqnice\*(rq) of a list of processes.
XThis acts similarly to the command
X.IR renice (8)).
X.TP
X.B u
XDisplay only processes owned by a specific username (prompt for username).
XIf the username specified is simply \*(lq+\*(rq, then processes belonging
Xto all users will be displayed.
X.TP
X.B e
XDisplay a list of system errors (if any) generated by the last
X.BR k ill
Xor
X.BR r enice
Xcommand.
X.TP
X.B i
X(or
X.BR I)
XToggle the display of idle processes.
X.SH "THE DISPLAY"
XThe actual display varies depending on the specific variant of Unix
Xthat the machine is running.  This description may not exactly match
Xwhat is seen by top running on this particular machine.  Differences
Xare listed at the end of this manual entry.
X.PP
XThe top few lines of the display show general information
Xabout the state of the system, including
Xthe last process id assigned to a process (on most systems),
Xthe three load averages,
Xthe current time,
Xthe number of existing processes,
Xthe number of processes in each state
X(sleeping, running, starting, zombies, and stopped),
Xand a percentage of time spent in each of the processor states
X(user, nice, system, and idle).
XIt also includes information about physial and virtual memory allocation.
X.PP
XThe remainder of the screen displays information about individual
Xprocesses.  This display is similar in spirit to
X.IR ps (1)
Xbut it is not exactly the same.  PID is the process id, USERNAME is the name
Xof the process's owner (if
X.B \-u
Xis specified, a UID column will be substituted for USERNAME),
XPRI is the current priority of the process,
XNICE is the nice amount (in the range \-20 to 20),
XSIZE is the total size of the process (text, data, and stack),
XRES is the current amount of resident memory (both SIZE and RES are
Xgiven in kilobytes),
XSTATE is the current state (one of \*(lqsleep\*(rq, \*(lqWAIT\*(rq,
X\*(lqrun\*(rq, \*(lqidl\*(rq, \*(lqzomb\*(rq, or \*(lqstop\*(rq),
XTIME is the number of system and user cpu seconds that the process has used,
XWCPU, when displayed, is the weighted cpu percentage (this is the same
Xvalue that
X.IR ps (1)
Xdisplays as CPU),
XCPU is the raw percentage and is the field that is sorted to determine
Xthe order of the processes, and
XCOMMAND is the name of the command that the process is currently running
X(if the process is swapped out, this column is marked \*(lq<swapped>\*(rq).
X.SH NOTES
XThe \*(lqABANDONED\*(rq state (known in the kernel as \*(lqSWAIT\*(rq) was
Xabandoned, thus the name.  A process should never end up in this state.
X.SH AUTHOR
XWilliam LeFebvre, EECS Department, Northwestern University
X.SH ENVIRONMENT
X.DT
XTOP	user-configurable defaults for options.
X.SH FILES
X.DT
X/dev/kmem		kernel memory
X.br
X/dev/mem		physical memory
X.br
X/etc/passwd		used to map uid numbers to user names
X.br
X/vmunix		system image
X.SH BUGS
XDon't shoot me, but the default for
X.B \-I
Xhas changed once again.  So many people were confused by the fact that
X.I top
Xwasn't showing them all the processes that I have decided to make the
Xdefault behavior show idle processes, just like it did in version 2.
XBut to appease folks who can't stand that behavior, I have added the
Xability to set \*(lqdefault\*(rq options in the environment variable
X.B TOP
X(see the OPTIONS section).  Those who want the behavior that version
X3.0 had need only set the environment variable
X.B TOP
Xto \*(lq-I\*(rq.
X.PP
XThe command name for swapped processes should be tracked down, but this
Xwould make the program run slower.
X.PP
XAs with
X.IR ps (1),
Xthings can change while
X.I top
Xis collecting information for an update.  The picture it gives is only a
Xclose approximation to reality.
X.SH "SEE ALSO"
Xkill(1),
Xps(1),
Xstty(1),
Xmem(4),
Xrenice(8)
END_OF_FILE
if test 9942 -ne `wc -c <'top.X'`; then
    echo shar: \"'top.X'\" unpacked with wrong size!
fi
# end of 'top.X'
fi
if test -f 'utils.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils.c'\"
else
echo shar: Extracting \"'utils.c'\" \(6259 characters\)
sed "s/^X//" >'utils.c' <<'END_OF_FILE'
X/*
X *  Top users/processes display for Unix
X *  Version 3
X *
X *  This program may be freely redistributed,
X *  but this entire comment MUST remain intact.
X *
X *  Copyright (c) 1984, 1989, William LeFebvre, Rice University
X *  Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
X */
X
X/*
X *  This file contains various handy utilities used by top.
X */
X
X#include "top.h"
X
Xint atoiwi(str)
X
Xchar *str;
X
X{
X    register int len;
X
X    len = strlen(str);
X    if (len != 0)
X    {
X	if (strncmp(str, "infinity", len) == 0 ||
X	    strncmp(str, "all",      len) == 0 ||
X	    strncmp(str, "maximum",  len) == 0)
X	{
X	    return(Infinity);
X	}
X	else if (str[0] == '-')
X	{
X	    return(Invalid);
X	}
X	else
X	{
X	    return(atoi(str));
X	}
X    }
X    return(0);
X}
X
X/*
X *  itoa - convert integer (decimal) to ascii string for positive numbers
X *  	   only (we don't bother with negative numbers since we know we
X *	   don't use them).
X */
X
Xstatic char buffer[16];		/* shared by the next two routines */
X				/*
X				 * How do we know that 16 will suffice?
X				 * Because the biggest number that we will
X				 * ever convert will be 2^32-1, which is 10
X				 * digits.
X				 */
X
Xchar *itoa(val)
X
Xregister int val;
X
X{
X    register char *ptr;
X
X    ptr = buffer + sizeof(buffer);
X    *--ptr = '\0';
X    if (val == 0)
X    {
X	*--ptr = '0';
X    }
X    else while (val != 0)
X    {
X	*--ptr = (val % 10) + '0';
X	val /= 10;
X    }
X    return(ptr);
X}
X
X/*
X *  itoa7(val) - like itoa, except the number is right justified in a 7
X *	character field.  This code is a duplication of itoa instead of
X *	a front end to a more general routine for efficiency.
X */
X
Xchar *itoa7(val)
X
Xregister int val;
X
X{
X    register char *ptr;
X
X    ptr = buffer + sizeof(buffer);
X    *--ptr = '\0';
X    if (val == 0)
X    {
X	*--ptr = '0';
X    }
X    else while (val != 0)
X    {
X	*--ptr = (val % 10) + '0';
X	val /= 10;
X    }
X    while (ptr > buffer + sizeof(buffer) - 7)
X    {
X	*--ptr = ' ';
X    }
X    return(ptr);
X}
X
X/*
X *  digits(val) - return number of decimal digits in val.  Only works for
X *	positive numbers.  If val <= 0 then digits(val) == 0.
X */
X
Xint digits(val)
X
Xint val;
X
X{
X    register int cnt = 0;
X
X    while (val > 0)
X    {
X	cnt++;
X	val /= 10;
X    }
X    return(cnt);
X}
X
X/*
X *  strecpy(to, from) - copy string "from" into "to" and return a pointer
X *	to the END of the string "to".
X */
X
Xchar *strecpy(to, from)
X
Xregister char *to;
Xregister char *from;
X
X{
X    while ((*to++ = *from++) != '\0');
X    return(--to);
X}
X
X/*
X * argparse(line, cntp) - parse arguments in string "line", separating them
X *	put into an argv-like array, and setting *cntp to the number of
X *	arguments encountered.  This is a simple parser that doesn't understand
X *	squat about quotes.
X */
X
Xchar **argparse(line, cntp)
X
Xchar *line;
Xint *cntp;
X
X{
X    register char *from;
X    register char *to;
X    register int cnt;
X    register int ch;
X    int length;
X    int lastch;
X    register char **argv;
X    char **argarray;
X    char *args;
X
X    /* unfortunately, the only real way to do this is to go thru the
X       input string twice. */
X
X    /* step thru the string counting the white space sections */
X    from = line;
X    lastch = cnt = length = 0;
X    while ((ch = *from++) != '\0')
X    {
X	length++;
X	if (ch == ' ' && lastch != ' ')
X	{
X	    cnt++;
X	}
X	lastch = ch;
X    }
X
X    /* add three to the count:  one for the initial "dummy" argument,
X       one for the last argument and one for NULL */
X    cnt += 3;
X
X    /* allocate a char * array to hold the pointers */
X    argarray = (char **)malloc(cnt * sizeof(char *));
X
X    /* allocate another array to hold the strings themselves */
X    args = (char *)malloc(length+2);
X
X    /* initialization for main loop */
X    from = line;
X    to = args;
X    argv = argarray;
X    lastch = '\0';
X
X    /* create a dummy argument to keep getopt happy */
X    *argv++ = to;
X    *to++ = '\0';
X    cnt = 2;
X
X    /* now build argv while copying characters */
X    *argv++ = to;
X    while ((ch = *from++) != '\0')
X    {
X	if (ch != ' ')
X	{
X	    if (lastch == ' ')
X	    {
X		*to++ = '\0';
X		*argv++ = to;
X		cnt++;
X	    }
X	    *to++ = ch;
X	}
X	lastch = ch;
X    }
X
X    /* set cntp and return the allocated array */
X    *cntp = cnt;
X    return(argarray);
X}
X
X/*
X *  percentages(cnt, out, new, old, diffs) - calculate percentage change
X *	between array "old" and "new", putting the percentages i "out".
X *	"cnt" is size of each array and "diffs" is used for scratch space.
X *	The array "old" is updated on each call.
X *	The routine assumes modulo arithmetic.  This function is especially
X *	useful on BSD mchines for calculating cpu state percentages.
X */
X
Xlong percentages(cnt, out, new, old, diffs)
X
Xint cnt;
Xint *out;
Xregister long *new;
Xregister long *old;
Xlong *diffs;
X
X{
X    register int i;
X    register long change;
X    register long total_change;
X    register long *dp;
X    long half_total;
X
X    /* initialization */
X    total_change = 0;
X    dp = diffs;
X
X    /* calculate changes for each state and the overall change */
X    for (i = 0; i < cnt; i++)
X    {
X	if ((change = *new - *old) < 0)
X	{
X	    /* this only happens when the counter wraps */
X	    change = (int)
X		((unsigned long)*new-(unsigned long)*old);
X	}
X	total_change += (*dp++ = change);
X	*old++ = *new++;
X    }
X
X    /* calculate percentages based on overall change, rounding up */
X    half_total = total_change / 2l;
X    for (i = 0; i < cnt; i++)
X    {
X	*out++ = (int)((*diffs++ * 1000 + half_total) / total_change);
X    }
X
X    /* return the total in case the caller wants to use it */
X    return(total_change);
X}
X
X/*
X * errmsg(errnum) - return an error message string appropriate to the
X *           error number "errnum".  This is a substitute for the System V
X *           function "strerror" with one important difference:  the string
X *           returned by this function does NOT end in a newline!
X *           N.B.:  there appears to be no reliable way to determine if
X *           "strerror" exists at compile time, so I make do by providing
X *           something of similar functionality.
X */
X
X/* externs referenced by errmsg */
X
Xextern char *sys_errlist[];
Xextern int sys_nerr;
X
Xchar *errmsg(errnum)
X
Xint errnum;
X
X{
X    if (errnum > 0 && errnum < sys_nerr)
X    {
X	return(sys_errlist[errnum]);
X    }
X    return("No error");
X}
END_OF_FILE
if test 6259 -ne `wc -c <'utils.c'`; then
    echo shar: \"'utils.c'\" unpacked with wrong size!
fi
# end of 'utils.c'
fi
echo shar: End of archive 2 \(of 13\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 13 archives.
    echo "Now read README and INSTALL, then run Configure"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
