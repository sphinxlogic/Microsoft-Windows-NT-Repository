Newsgroups: comp.sources.unix
From: phil@eecs.nwu.edu (William LeFebvre)
Subject: v27i003: top - a top process display, version 3.2, Part03/13
References: <1.744843136.4744@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: phil@eecs.nwu.edu (William LeFebvre)
Posting-Number: Volume 27, Issue 3
Archive-Name: top-3.2/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 13)."
# Contents:  Configure machine/m_dgux.c machine/m_svr4.c
# Wrapped by phil@pex on Wed Aug  4 14:22:41 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Configure' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Configure'\"
else
echo shar: Extracting \"'Configure'\" \(11910 characters\)
sed "s/^X//" >'Configure' <<'END_OF_FILE'
X#!/bin/csh -f
X#
X# Configuration script for top.
X#
X# Use with version 3.0 and higher.
X#
Xset PRIME = "/usr/games/primes"
Xset vars = (module LoadMax topn NominalTopn delay owner group mode random \
X	TableSize bindir mandir manext mansty \
X	Cmdshell Cmdcc Cmdawk Cmdinstall cdefs)
Xset fastrack = 0
Xset yesno = (no yes)
X
Xonintr byebye
X
X# make sure that getans is there and ready
Xif (! -e getans) then
X   echo 'This package is not complete.  The shell file "getans" is missing.'
X   exit 10
Xendif
Xchmod +x getans
X
Xif ($#argv > 0) then
X# fast track configuration
X   set fastrack = 1
Xelse
Xcat <<'EOF'
XConfiguration for top, version 3
X
XOne moment....
X'EOF'
Xendif
X
X# collect file names and module names
Xls machine/m_*.c >$$.f
Xls machine/m_*.man >$$.m
Xsed -e 's@^machine/m_@@' -e 's/.c$//' $$.f >$$.n
X
X# build Make.desc
Xset descs = `sed -e 's@\.c$@.desc@' $$.f`
Xsed -e "s@%descs%@$descs@" Make.desc.X >Make.desc
X
X# build desc files and SYNOPSIS as needed
Xmake -f Make.desc >/dev/null
X
Xif (-e .defaults) then
X   echo ""
X   echo "Reading configuration from last time..."
X   source .defaults
X   set nodefaults = 0
X   if ($fastrack == 1) then
X      set module = $1
X   endif
Xelse
X   if ($fastrack == 1) then
X      echo "No previous configuration was found."
X      set fastrack = 0
X      set module = $1
X   else
X      set module = bsd43
X   endif
X   set LoadMax     = 5.0
X   set topn        = 15
X   set NominalTopn = 18
X   set delay       = 5
X   set TableSize   = 0
X   set bindir      = /usr/local/bin
X   set mandir      = /usr/man/manl
X   set manext      = l
X   set mansty      = man
X   set nodefaults  = 1
X   set Cmdshell    = /bin/sh
X   set Cmdawk      = awk
X   set Cmdinstall  = install
X   set Cmdcc       = cc
X   set cdefs       = -O
Xendif
Xecho ""
X
Xif ($fastrack == 1) then
X   grep -s $module $$.n >/dev/null
X   if ($status != 0) then
X      echo "$module is not recognized.  To see a list of available modules"
X      echo 'run "Configure" with no arguments.'
X      rm -f $$.[fmn]
X      exit 1
X   endif
X   set random1 = `expr $random + 1`
X   cat <<EOF
XUsing these settings:
X        Bourne Shell   $Cmdshell
X          C compiler   $Cmdcc
X    Compiler options   $cdefs
X         Awk command   $Cmdawk
X     Install command   $Cmdinstall
X
X              Module   $module
X             LoadMax   $LoadMax
X        Default TOPN   $topn
X        Nominal TOPN   $NominalTopn
X       Default Delay   $delay
XRandom passwd access   $yesno[$random1]
X          Table Size   $TableSize
X               Owner   $owner
X         Group Owner   $group
X                Mode   $mode
X       bin directory   $bindir
X       man directory   $mandir
X       man extension   $manext
X       man style       $mansty
X
XEOF
X   goto fast
Xendif
X
Xcat <<'EOF'
XYou will be asked a series of questions.  Each question will have a
Xdefault answer enclosed in brackets, such as "[5.0]".  In most cases,
Xthe default answer will work well.  To use that value, merely press
Xreturn.
X
X'EOF'
X
X# display synopses
X
Xgetmod:
Xcat <<'EOF'
X
XThe following machine-dependent modules are available:
X'EOF'
Xawk -F: ' { printf "%-8s %s\n", $1, $2 }' SYNOPSIS
Xecho ''
X./getans "What module is appropriate for this machine? " string $module .$$
Xset module = `cat .$$`
X
X# is it a valid one?
Xgrep -s $module $$.n >/dev/null
Xif ($status != 0) then
X    echo "That is not a recognized module name."
X    goto getmod
Xendif
X
X# display a full description
Xsed -e '1,/DESCRIPTION:/d' -e '/^$/,$d' machine/m_${module}.desc
X
X# verify it
Xecho ""
X./getans "Is this what you want to use?" yesno 1 .$$
Xif (`cat .$$` == 0) then
X   goto getmod
Xendif
Xendif
X
Xcat <<'EOF'
X
XFirst we need to find out a little bit about the executables needed to
Xcompile top.
X
X'EOF'
X./getans "What is the full path name for the Bourne shell" file "$Cmdshell" .$$
Xset Cmdshell = `cat .$$`
X
Xcat <<'EOF'
X
XPlease supply the name of the appropriate command.  It need not be a
Xfull path name, but the named command does need to exist somewhere on
Xthe current path.
X
X'EOF'
X./getans "AWK Interpreter" path "$Cmdawk" .$$
Xset Cmdawk = `cat .$$`
X./getans "Installer" path "$Cmdinstall" .$$
Xset Cmdinstall = `cat .$$`
X./getans "C Compiler" path "$Cmdcc" .$$
Xset Cmdcc = `cat .$$`
X
Xcat <<EOF
X
XWhat other options should be used with the $Cmdcc command (use "none" to
Xspecify no options)?
XEOF
X./getans "Compiler options" string "$cdefs" .$$
Xset cdefs = `cat .$$`
Xif ($cdefs == "none") then
X    set cdefs = ""
Xendif
X
Xcat <<'EOF'
X
XNow you need to answer some questions concerning the configuration of
Xtop itself.
X
XThe space command forces an immediate update.  Sometimes, on loaded
Xsystems, this update will take a significant period of time (because all
Xthe output is buffered).  So, if the short-term load average is above
X"LoadMax", then top will put the cursor home immediately after the space
Xis pressed before the next update is attempted.  This serves as a visual
Xacknowledgement of the command.  "LoadMax" should always be specified as a
Xfloating point number.
X
X'EOF'
X./getans "LoadMax" number "$LoadMax" .$$
Xset LoadMax = `cat .$$`
X
Xcat <<'EOF'
X
X"Default TOPN" is the default number of processes to show.  This is the
Xnumber that will be used when the user does not specify the number of
Xprocesses to show.  If you want "all" (or infinity) as the default, use
Xthe value "-1".
X
X'EOF'
X
X./getans "Default TOPN" neginteger "$topn" .$$
Xset topn = `cat .$$`
X
Xcat <<'EOF'
X
X"Nominal_TOPN" is used as the default TOPN when Default_TOPN is Infinity
Xand the output is a dumb terminal.  If we didn't do this, then
Xinstallations who use a default TOPN of Infinity will get every process in
Xthe system when running top on a dumb terminal (or redirected to a file).
XNote that Nominal_TOPN is a default: it can still be overridden on the
Xcommand line, even with the value "infinity".
X
X'EOF'
X
X./getans "Nominal TOPN" integer "$NominalTopn" .$$
Xset NominalTopn = `cat .$$`
X
Xcat <<'EOF'
X
XDefault Delay is the default number of seconds to wait between screen
Xupdates.
X
X'EOF'
X
X./getans "Default Delay" integer "$delay" .$$
Xset delay = `cat .$$`
X
Xecho ""
X
Xset rand = 0
Xypwhich >&/dev/null
Xif ($status == 0 || -e /etc/passwd.dir) then
X   set rand = 1
Xendif
X
Xif ($rand == 1) then
X   echo "It looks like you have a passwd file that can be accessed at random."
X   set pr = 'Do you want top to take advantage of this'
Xelse
X   echo "It looks like you have conventional passwd file access.  Top can take"
X   echo "advantage of a random access passwd mechanism if such exists.  Do"
X   echo "you want top to assume that accesses to the file /etc/passwd are done"
X   set pr = 'with random access rather than sequential'
Xendif
X
Xif ($nodefaults == 1) then
X   set random = $rand
Xendif
X
X./getans "${pr}?" yesno $random .$$
Xset random = `cat .$$`
X
Xecho ""
X
Xypcat passwd.byname >&/tmp/$$.a
Xif ($status == 0) then
X   set cnt = `wc -l </tmp/$$.a`
X   set mapfile = "NIS map"
Xelse
X   set cnt = `wc -l </etc/passwd`
X   set mapfile = "file"
Xendif
Xrm /tmp/$$.a
Xset double = `expr $cnt \* 2`
Xecho "I found $cnt entries in your passwd $mapfile.  Top hashes the username to"
Xecho "uid mappings as it goes along and it needs a good guess on the size of"
Xecho "that hash table.  This number should be the next highest prime number"
Xecho "after $double."
Xecho ""
Xif (-e $PRIME) then
X   set pr = `$PRIME $double | head -1`
X   echo "I have calculated that to be $pr."
Xelse
X   set pr = $double
X   echo "I cannot calculate that prime number, so you will need to provide it for me."
Xendif
X
Xif ($TableSize == 0) then
X   set TableSize = $pr
Xendif
X
X./getans "Enter the hash table size" integer "$TableSize" .$$
Xset TableSize = `cat .$$`
X
Xecho ""
X
X# !!! I need to fix this:  /dev/kmem might not exist on some machines !!!
X
X# determine the right way to invoke ls to get full output
Xset ls = "ls -l"
Xif (`$ls getans | wc -w` < 9) then
X   set ls = "ls -lg"
Xendif
X
Xset t_owner = root
Xset t_group = wheel
Xif (-e /proc) then
X   cat <<EOF
XUh oh!  I see /proc out there.  Some new Unix variants provide the /proc
Xfile system as a mechanism to get to a process's address space.  This
Xdirectory is typically only accessible by root.  However, there are a few
Xsystems (such as DG/UX) on which this directory exists, but isn't used.
XI'm going to assume that top needs to run setuid to root, but you should
Xdouble check and use mode 2755 (set group id) if top doesn't really need
Xroot access.  If you are running SunOS 5.x then you will need to install
Xtop setuid root (owner root and mode 4711).
X
XEOF
X   set t_mode = 4711
Xelse if (-e /dev/kmem) then
X   $ls /dev/kmem >/tmp/$$.b
X   grep '^....r..r..' /tmp/$$.b >&/dev/null
X   if ($status == 1) then
X      grep '^....r..-..' /tmp/$$.b >&/dev/null
X      if ($status == 0) then
X         set t_group = `awk ' { print $4 }' /tmp/$$.b`
X         set t_mode = 2755
X         echo "It looks like only group $t_group can read the memory devices."
X      else
X         set t_mode = 4755
X         echo "It looks like only root can read the memory devices."
X      endif
X   else
X      set t_mode = 755
X      echo "It looks like anybody can read the memory devices."
X   endif
Xelse
X   echo "It looks like there are no memory device special files."
X   set t_mode = 755
Xendif
Xif ($nodefaults) then
X   set owner = $t_owner
X   set group = $t_group
X   set mode =  $t_mode
Xendif
Xecho "Tell me how to set the following when top is installed:"
X./getans "Owner" user "$owner" .$$
Xset owner = `cat .$$`
X./getans "Group owner" group "$group" .$$
Xset group = `cat .$$`
X./getans "Mode" integer "$mode" .$$
Xset mode = `cat .$$`
Xrm -f /tmp/$$.b
X
Xecho ""
X./getans "Install the executable in this directory" file "$bindir" .$$
Xset bindir = `cat .$$`
X
Xecho ""
X./getans "Install the manual page in this directory" file "$mandir" .$$
Xset mandir = `cat .$$`
X
Xecho ""
X./getans "Install the manual page with this extension" string "$manext" .$$
Xset manext = `cat .$$`
X
Xecho ""
X./getans "Install the manual page as 'man' or 'catman'" string "$mansty" .$$
Xset mansty = `cat .$$`
X
Xecho ""
Xecho "We are done with the questions."
X
Xecho "Saving configuration..."
X# save settings to use as defaults the next time
Xrm -f .defaults
Xforeach v ($vars)
X   set tmp = `eval echo \$$v`
X   echo set $v = "'$tmp'" >>.defaults
Xend
X
Xfast:
X
X# set variables which contain module lists
Xset modules = `cat $$.f`
Xset manmodules = `cat $$.m`
X
X# clean up
Xrm -f $$.f $$.m $$.n
X
X# set the link for machine.c
Xrm -f machine.c machine.o
Xln -s machine/m_${module}.c machine.c
Xset libs = `grep LIBS: machine/m_${module}.desc | sed -e 's/^.[^:]*: *//'`
Xset cflgs = `grep CFLAGS: machine/m_${module}.desc | sed -e 's/^.[^:]*: *//'`
X
Xif ( { grep -s SIGINT /usr/include/signal.h } ) then
X    set signal="/usr/include/signal.h"
Xelse
X    set signal="/usr/include/sys/signal.h"
Xendif
X
X
Xecho "Building Makefile..."
Xsed -e "s|%topn%|$topn|" \
X    -e "s|%delay%|$delay|" \
X    -e "s|%owner%|$owner|" \
X    -e "s|%group%|$group|" \
X    -e "s|%mode%|$mode|" \
X    -e "s|%bindir%|$bindir|" \
X    -e "s|%mandir%|$mandir|" \
X    -e "s|%manext%|$manext|" \
X    -e "s|%mansty%|$mansty|" \
X    -e "s|%tablesize%|$TableSize|" \
X    -e "s|%libs%|$libs|" \
X    -e "s|%cflgs%|$cflgs|" \
X    -e "s|%cdefs%|$cdefs|" \
X    -e "s|%modules%|$modules|" \
X    -e "s|%manmodules%|$manmodules|" \
X    -e "s|%signal%|$signal|" \
X    -e "s|%cc%|$Cmdcc|" \
X    -e "s|%awk%|$Cmdawk|" \
X    -e "s|%install%|$Cmdinstall|" \
X    -e "s|%shell%|$Cmdshell|" \
X	Makefile.X >Makefile
X
Xecho "Building top.local.h..."
Xsed -e "s|%LoadMax%|$LoadMax|" \
X    -e "s|%TableSize%|$TableSize|" \
X    -e "s|%NominalTopn%|$NominalTopn|" \
X    -e "s|%topn%|$topn|" \
X    -e "s|%delay%|$delay|" \
X    -e "s|%random%|$random|" \
X	top.local.H >top.local.h
X
Xecho "Building top.1..."
Xsed -e "s|%topn%|$topn|" \
X    -e "s|%delay%|$delay|" \
X	top.X >top.1
Xif (-e machine/m_${module}.man ) then
X    cat machine/m_${module}.man >>top.1
Xendif
X
X# clean up
Xrm -f .$$
X
Xecho 'Doing a "make clean".'
Xmake clean
X
Xecho 'To create the executable, type "make".'
Xexit 0
X
Xbyebye:
Xrm -f .$$ $$.[fmn] /tmp/$$.[ab]
Xexit 1
END_OF_FILE
if test 11910 -ne `wc -c <'Configure'`; then
    echo shar: \"'Configure'\" unpacked with wrong size!
fi
chmod +x 'Configure'
# end of 'Configure'
fi
if test -f 'machine/m_dgux.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machine/m_dgux.c'\"
else
echo shar: Extracting \"'machine/m_dgux.c'\" \(12275 characters\)
sed "s/^X//" >'machine/m_dgux.c' <<'END_OF_FILE'
X/*
X * top - a top users display for Unix
X *
X * SYNOPSIS:  for DG AViiON with DG/UX 5.4+
X *
X * DESCRIPTION:
X * A top module for DG/UX 5.4 systems.
X * Uses DG/UX system calls to get info from the kernel.
X * (NB. top DOES NOT need to be installed setuid root under DG/UX 5.4.2)
X *
X * AUTHOR:  Mike Williams <mike@inform.co.nz>
X */
X
X/*
X * NOTE: This module will only work with top versions 3.1 and later!
X */
X
X#include <stdlib.h> 
X#include <unistd.h>
X#include <stdio.h>
X
X#include <sys/dg_sys_info.h>
X#include <sys/dg_process_info.h>
X#include <sys/systeminfo.h> 
X#include <sys/sysmacros.h> 
X
X#include "top.h"
X#include "machine.h"
X
Xlong percentages();
X
X/*--- process formatting --------------------------------------------------*/
X
Xstatic char header[] =
X  "  PID X         PRI NICE C    SIZE STATE    TIME    CPU COMMAND";
X/* ddddd ssssssss dddd ddd dd ddddddK ssssssdddd:dd dd.dd% sssssssssssssssss...
X * 0123456   -- field to fill in starts at header+6 */
X#define UNAME_START 6
X
X#define Proc_format \
X     "%5d %-8.8s %4d %3d %2d %6dK %-6s%4d:%02d %5.2f%% %.20s"
X
X/*--- process states ------------------------------------------------------*/
X
Xstatic char* procStateNames[] = {
X    "", " sleeping, ", " waiting, ", " running, ", " starting, ",
X    " zombie, ", " stopped, ",
X    NULL
X};
X
Xstatic char* procStateAbbrevs[] = {
X    "", "sleep", "wait", "run", "start", "zombie", "stop",
X    NULL
X};
X
X#define N_PROCESS_STATES \
X(sizeof (procStateNames) / sizeof (procStateNames[0]) - 1)
X
Xstatic int processStats[N_PROCESS_STATES];
X
X/*--- cpu states ----------------------------------------------------------*/
X
Xenum {
X    CPU_user,
X    CPU_system,
X    CPU_idle,
X    CPU_io_wait,
X};
X
Xstatic char* cpuStateNames[] = {
X    "user", "system", "idle", "io_wait",
X    NULL
X};
X
X#define N_CPU_STATES \
X(sizeof (cpuStateNames) / sizeof (cpuStateNames[0]) - 1)
X
Xstatic int cpuStats[N_CPU_STATES];
X
X/*--- memory statistics ---------------------------------------------------*/
X
Xenum {
X    MEM_available,
X    MEM_used,
X    MEM_free,
X    MEM_freeswap,
X};
X
Xstatic char* memoryNames[] = {
X    "K physical, ", "K in use, ", "K free, ", "K free swap, ", NULL
X};
X
X#define N_MEMORY_STATS \
X(sizeof (memoryNames) / sizeof (memoryNames[0]) - 1)
X
Xstatic int memoryStats[N_MEMORY_STATS];
X
X/*--- conversion macros ---------------------------------------------------*/
X
X/* Convert clicks (kernel pages) to kbytes ... */
X#define pagetok(size) ctob(size) >> LOG1024
X
X/* Convert timeval's to double */
X#define tvtod(tval) (1000000.0 * (tval).tv_sec + 1.0 * (tval).tv_usec)
X
X/* Scale timeval's onto longs */
X#define scaledtv(tval) (tvtod (tval) / 4096) 
X
X/*--- process table -------------------------------------------------------*/
X
Xtypedef struct _ProcInfo {
X    struct dg_process_info    p_info;
X    double 		      cpu_time;
X    double 		      fraction_cpu;
X} ProcInfo;
X
Xstatic ProcInfo* 	      processInfo;
Xstatic ProcInfo** 	      activeProcessInfo;
X
Xint 			      activeIndex;
X
Xtypedef struct _ProcTime {
X    pid_t 		      pid;
X    double 		      cpu_time;
X} ProcTime;
X
Xstatic ProcTime* 	      oldProcessTimes;
Xstatic int 		      n_oldProcessTimes;
X
Xstatic double 		      lastTime;
Xstatic double 		      thisTime;
Xstatic double 		      timeSlice;
X
X/*=========================================================================*/
X/*=== top "Callback" routines =============================================*/
X
Xstatic int IntCmp (i1, i2)
X  int* 			i1;
X  int* 			i2;
X{
X    return (*i2 - *i1);
X}
X
X/*=== Data collection =====================================================*/
X
Xint machine_init (statics)
X  /*~~~~~~~~~~~~
X   */
X  struct statics *statics;
X{
X    struct dg_sys_info_pm_info pm_info;
X    int 		      table_size;
X
X    /* fill in the statics information */
X    statics->procstate_names = procStateNames;
X    statics->cpustate_names = cpuStateNames;
X    statics->memory_names = memoryNames;
X
X    dg_sys_info ((long *)&pm_info,
X		 DG_SYS_INFO_PM_INFO_TYPE,
X		 DG_SYS_INFO_PM_VERSION_0);
X    table_size = pm_info.process_table_size + 1;
X
X    processInfo = (ProcInfo *) 
X	malloc (sizeof (processInfo[0]) * table_size);
X    activeProcessInfo = (ProcInfo **) 
X	malloc (sizeof (activeProcessInfo[0]) * table_size);
X    oldProcessTimes = (ProcTime *) 
X	malloc (sizeof (oldProcessTimes[0]) * table_size);
X
X    lastTime = 0;
X
X    return(0);
X}
X
Xint get_system_info (si)
X  /*~~~~~~~~~~~~~~~
X   */
X  struct system_info *si;
X{
X    struct dg_sys_info_vm_info    vm_info;
X    struct dg_sys_info_pm_info    pm_info;
X    struct dg_sys_info_load_info  load_info;
X
X    static long cpu_time [N_CPU_STATES];
X    static long cpu_old [N_CPU_STATES];
X    static long cpu_diff [N_CPU_STATES];
X
X    /* memory info */
X    
X    dg_sys_info ((long *)&vm_info,
X		 DG_SYS_INFO_VM_INFO_TYPE,
X		 DG_SYS_INFO_VM_VERSION_0);
X
X    memoryStats[MEM_available] = sysconf (_SC_AVAILMEM);
X    memoryStats[MEM_free]      = pagetok (vm_info.freemem);
X    memoryStats[MEM_used]      = memoryStats[0] - memoryStats[2];
X    memoryStats[MEM_freeswap]  = pagetok (vm_info.freeswap);
X    si->memory 		       = memoryStats;
X
X    /* process info */
X    
X    dg_sys_info ((long *)&pm_info,
X		 DG_SYS_INFO_PM_INFO_TYPE,
X		 DG_SYS_INFO_PM_VERSION_0);
X
X    si->last_pid 	      = 0;
X    si->p_total 	      = pm_info.process_count;
X    si->p_active 	      = pm_info.bound_runnable_process_count;
X
X    cpu_time[CPU_user]        = scaledtv (pm_info.user_time);
X    cpu_time[CPU_system]      = scaledtv (pm_info.system_time);
X    cpu_time[CPU_idle] 	      = scaledtv (pm_info.idle_time);
X    cpu_time[CPU_io_wait]     = scaledtv (pm_info.io_wait_time);
X    percentages (N_CPU_STATES, cpuStats, cpu_time, cpu_old, cpu_diff);
X    si->cpustates 	      = cpuStats;
X
X    /* calculate timescale */
X
X    thisTime = tvtod (pm_info.current_time);
X    timeSlice = thisTime - lastTime;
X    lastTime = thisTime;
X    
X    /* load info */
X    
X    dg_sys_info ((long *)&load_info,
X		 DG_SYS_INFO_LOAD_INFO_TYPE,
X		 DG_SYS_INFO_LOAD_VERSION_0);
X
X    si->load_avg[0] 	= load_info.one_minute;
X    si->load_avg[1] 	= load_info.five_minute;
X    si->load_avg[2] 	= load_info.fifteen_minute;
X
X    return 1;
X}
X
Xcaddr_t get_process_info (si, sel, compare)
X  /*    ~~~~~~~~~~~~~~~~ 
X   */
X  struct system_info* 	si;
X  struct process_select* sel;
X  int 			(*compare)();
X{
X    long 		key = DG_PROCESS_INFO_INITIAL_KEY;
X 			
X    int 		n_total = 0;
X    int 		n_active = 0;
X
X    ProcInfo* 		pp;
X    int 		i;
X
X    bzero((char *)processStats, sizeof(processStats));
X
X    while (dg_process_info (DG_PROCESS_INFO_SELECTOR_ALL_PROCESSES, 0,
X			    DG_PROCESS_INFO_CMD_NAME_ONLY,
X			    &key,
X			    &(processInfo[n_total].p_info),
X			    DG_PROCESS_INFO_CURRENT_VERSION) == 1) {
X
X	ProcInfo*       pp = &(processInfo[n_total++]);
X	int 		pid = pp->p_info.process_id;
X	ProcTime* 	old_time;
X
X	/* Increment count for this process state */
X	++processStats[pp->p_info.state];
X
X	/* Calculate % CPU usage */
X	pp->cpu_time = (tvtod (pp->p_info.system_time) + 
X			tvtod (pp->p_info.user_time));
X	old_time = (ProcTime *) 
X	    bsearch (&pid, oldProcessTimes, 
X		     n_oldProcessTimes, sizeof (ProcTime),
X		     IntCmp);
X	pp->fraction_cpu = (old_time 
X			    ? ((pp->cpu_time - old_time->cpu_time)
X			       / timeSlice) 
X			    : 0.0);
X
X	/* Skip if process not classed as "active" */
X	if ((pp->p_info.state == DG_PROCESS_INFO_STATUS_TERMINATED) ||
X	    (!sel->idle 
X	     && (pp->p_info.state != DG_PROCESS_INFO_STATUS_RUNNING)
X	     && (pp->p_info.state != DG_PROCESS_INFO_STATUS_WAITING)) ||
X	    (sel->uid != -1 && pp->p_info.user_id != (uid_t)sel->uid) ||
X	    (!sel->system && (pp->p_info.user_id == 0 &&
X			     pp->p_info.parent_process_id == 1)) ||
X	    (sel->command && strcmp (pp->p_info.cmd, sel->command) != 0))
X	    continue;
X
X	activeProcessInfo[n_active++] = pp;
X	
X    }
X
X    activeProcessInfo[n_active] = NULL;
X
X    si->p_total 	= n_total;
X    si->p_active 	= n_active;
X    si->procstates 	= processStats;
X
X    /* If requested, sort the "interesting" processes */
X    if (compare != NULL) qsort((void *)activeProcessInfo, 
X			       n_active, 
X			       sizeof (ProcInfo *), 
X			       compare);
X
X    /* Record scaled CPU totals, for calculating %CPU */
X    n_oldProcessTimes = n_total;
X    for (i = 0; i < n_oldProcessTimes; i++) {
X	oldProcessTimes[i].pid = processInfo[i].p_info.process_id;
X	oldProcessTimes[i].cpu_time = processInfo[i].cpu_time;
X    }
X    qsort (oldProcessTimes, n_oldProcessTimes, sizeof (ProcTime), IntCmp);
X
X    /* pass back a handle */
X    activeIndex = 0;
X    return ((caddr_t) &activeIndex);
X}
X
X/*=== Process comparison routine ==========================================*/
X
X/*
X * Sort keys are (in descending order of importance):
X *     - percent cpu
X *     - cpu ticks
X *     - state
X *     - resident set size
X *     
X * The process states are ordered as follows:
X *     - zombie
X *     - wait
X *     - sleep
X *     - stop
X *     - start
X *     - run
X */
X
Xstatic unsigned char sortedState[] =
X{
X    0,	                                /* not used */
X    3,	                                /* sleep */
X    1,	                                /* wait	*/
X    6,	                                /* run */
X    5,	                                /* start */
X    2,	                                /* zombie */
X    4,	                                /* stop */
X};
X
Xint proc_compare(pp1, pp2)
X  /*~~~~~~~~~~~~
X   */
X  ProcInfo** 		pp1;
X  ProcInfo** 		pp2;
X{
X    register ProcInfo* 	p1;
X    register ProcInfo* 	p2;
X    register int 	result;
X    register float 	lresult;
X
X    register long 	p1_cpu;
X    register long 	p2_cpu;
X
X    /* remove one level of indirection */
X    p1 = *pp1;
X    p2 = *pp2;
X
X    /* calculate cpu totals */
X    p1_cpu = p1->p_info.system_time.tv_sec + p1->p_info.user_time.tv_sec;
X    p2_cpu = p2->p_info.system_time.tv_sec + p2->p_info.user_time.tv_sec;
X
X    /* Compare %CPU usage */
X    if ((lresult = (p2->fraction_cpu - p1->fraction_cpu)) != 0)
X	return lresult < 0 ? -1 : 1;
X
X    /* Compare other fields until one differs */
X    ((result = (p2->p_info.cpu_usage - p1->p_info.cpu_usage)) ||
X     (result = (sortedState [p2->p_info.state] - 
X		sortedState [p1->p_info.state])) ||
X     (result = (p2->p_info.priority - p1->p_info.priority)) ||
X     (result = (p2->p_info.resident_process_size - 
X		p1->p_info.resident_process_size)) ||
X     (result = (p1->p_info.process_id - p2->p_info.process_id)));
X
X    return result;
X}
X
X/*=== Process owner validation ============================================*/
X
X/*
X * proc_owner(pid) - returns the uid that owns process "pid", or -1 if
X *		the process does not exist.
X *		It is EXTREMLY IMPORTANT that this function work correctly.
X *		If top runs setuid root (as in SVR4), then this function
X *		is the only thing that stands in the way of a serious
X *		security problem.  It validates requests for the "kill"
X *		and "renice" commands.
X */
X
Xint proc_owner (pid)
X  /*~~~~~~~~~~
X   */
X  int pid;
X{
X    register int      i;
X    ProcInfo* 	      pp;
X
X    for (i = 0; (pp = activeProcessInfo [i]); i++) {
X	if (pp->p_info.process_id == pid) 
X	    return (int)pp->p_info.user_id;
X    }
X    return(-1);
X}
X
X/*=== Output formatting ===================================================*/
X
Xchar* format_header (uname_field)
X  /*  ~~~~~~~~~~~~~
X   */
X  register char* 	uname_field;
X{
X    register char* 	ptr;
X
X    ptr = header + UNAME_START;
X    while (*uname_field != '\0')
X    {
X	*ptr++ = *uname_field++;
X    }
X
X    return(header);
X}
X
Xchar* format_next_process (index_ptr, get_userid)
X  /*  ~~~~~~~~~~~~~~~~~~~
X   */
X  int* 			index_ptr;
X  char* 		(*get_userid)();
X{
X    static char 	fmt[128];
X
X    int 		proc_index;
X    ProcInfo* 		pp;
X    long 		proc_cpu;
X
X    proc_index = (*index_ptr)++;
X    pp = activeProcessInfo [proc_index];
X    proc_cpu = pp->p_info.system_time.tv_sec + pp->p_info.user_time.tv_sec;
X
X    /* format this entry */
X
X    sprintf (fmt,
X	     Proc_format,
X	     pp->p_info.process_id,
X	     (*get_userid) (pp->p_info.user_id),
X	     pp->p_info.priority,
X	     pp->p_info.nice_value,
X	     pp->p_info.cpu_usage,
X	     pagetok (pp->p_info.resident_process_size),
X	     procStateAbbrevs[pp->p_info.state],
X	     proc_cpu / 60l,
X	     proc_cpu % 60l,
X	     100.0 * pp->fraction_cpu,
X	     pp->p_info.cmd);
X    
X    return(fmt);
X}
X
X/*=== END of m_dgux.c =====================================================*/
END_OF_FILE
if test 12275 -ne `wc -c <'machine/m_dgux.c'`; then
    echo shar: \"'machine/m_dgux.c'\" unpacked with wrong size!
fi
# end of 'machine/m_dgux.c'
fi
if test -f 'machine/m_svr4.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machine/m_svr4.c'\"
else
echo shar: Extracting \"'machine/m_svr4.c'\" \(15086 characters\)
sed "s/^X//" >'machine/m_svr4.c' <<'END_OF_FILE'
X/*
X * top - a top users display for Unix
X *
X * SYNOPSIS:  For Intel based System V Release 4
X *
X * DESCRIPTION:
X *      System V release 4.0.x for i486
X *
X * LIBS:  -lelf
X *
X * AUTHORS:  Andrew Herbert     <andrew@werple.apana.org.au>
X *           Robert Boucher     <boucher@sofkin.ca>
X */
X
X#include "top.h"
X#include "machine.h"
X#include <stdio.h>
X#include <fcntl.h>
X#include <unistd.h>
X#include <stdlib.h>
X#include <errno.h>
X#include <dirent.h>
X#include <nlist.h>
X#include <string.h>
X#include <sys/types.h>
X#include <sys/param.h>
X#include <sys/procfs.h>
X#include <sys/sysinfo.h>
X#include <sys/sysmacros.h>
X#include <sys/vmmeter.h>
X#include <vm/anon.h>
X#include <sys/priocntl.h>
X#include <sys/rtpriocntl.h>
X#include <sys/tspriocntl.h>
X#include <sys/procset.h>
X#include <sys/var.h>
X
X#define UNIX "/stand/unix"
X#define KMEM "/dev/kmem"
X#define PROCFS "/proc"
X#define CPUSTATES	5
X
X#ifndef PRIO_MAX
X#define PRIO_MAX	20
X#endif
X#ifndef PRIO_MIN
X#define PRIO_MIN	-20
X#endif
X
X#ifndef FSCALE
X#define FSHIFT  8		/* bits to right of fixed binary point */
X#define FSCALE  (1<<FSHIFT)
X#endif
X
X#define loaddouble(x) ((double)(x) / FSCALE)
X#define percent_cpu(x) ((double)(x)->pr_cpu / FSCALE)
X#define weighted_cpu(pct, pp) ( ((pp)->pr_time.tv_sec) == 0 ? 0.0 : \
X        ((pp)->pr_cpu) / ((pp)->pr_time.tv_sec) )
X#define pagetok(size) ctob(size) >> LOG1024
X
X/* definitions for the index in the nlist array */
X#define X_AVENRUN	0
X#define X_MPID		1
X#define X_V		2
X#define X_NPROC		3
X#define X_ANONINFO	4
X#define X_TOTAL		5
X#define X_SYSINFO	6
X
Xstatic struct nlist nlst[] =
X{
X  {"avenrun"},			/* 0 */
X  {"mpid"},			/* 1 */
X  {"v"},			/* 2 */
X  {"nproc"},			/* 3 */
X  {"anoninfo"},			/* 4 */
X  {"total"},			/* 5 */
X  {"sysinfo"},			/* 6 */
X  {NULL}
X};
X
Xstatic unsigned long avenrun_offset;
Xstatic unsigned long mpid_offset;
Xstatic unsigned long nproc_offset;
Xstatic unsigned long anoninfo_offset;
Xstatic unsigned long total_offset;
Xstatic unsigned long sysinfo_offset;
X
X/* get_process_info passes back a handle.  This is what it looks like: */
X
Xstruct handle
X  {
X    struct prpsinfo **next_proc;/* points to next valid proc pointer */
X    int remaining;		/* number of pointers remaining */
X  };
X
X/*
X *  These definitions control the format of the per-process area
X */
X
Xstatic char header[] =
X"  PID X        PRI NICE   SIZE   RES STATE   TIME   WCPU    CPU COMMAND";
X/* 0123456   -- field to fill in starts at header+6 */
X#define UNAME_START 6
X#define Proc_format \
X	"%5d %-8.8s %3d %4d%6dK %4dK %-5s%4d:%02d %3d.0%% %5.2f%% %.16s"
X
Xchar *state_abbrev[] =
X{"", "sleep", "run", "zombie", "stop", "start", "cpu", "swap"};
X
Xint process_states[8];
Xchar *procstatenames[] =
X{
X  "", " sleeping, ", " running, ", " zombie, ", " stopped, ",
X  " starting, ", " on cpu, ", " swapped, ",
X  NULL
X};
X
Xint cpu_states[CPUSTATES];
Xchar *cpustatenames[] =
X{"idle", "user", "kernel", "wait", "swap", NULL};
X
X/* these are for detailing the memory statistics */
X
Xint memory_stats[5];
Xchar *memorynames[] =
X{"K real, ", "K active, ", "K free, ", "K swap, ", "K free swap", NULL};
X
Xstatic int kmem = -1;
Xstatic int nproc;
Xstatic int bytes;
Xstatic struct prpsinfo *pbase;
Xstatic struct prpsinfo **pref;
Xstatic DIR *procdir;
X
X/* useful externals */
Xextern int errno;
Xextern char *sys_errlist[];
Xextern char *myname;
Xextern long percentages ();
Xextern int check_nlist ();
Xextern int getkval ();
Xextern void perror ();
Xextern void getptable ();
Xextern void quit ();
Xextern int nlist ();
X
Xint
Xmachine_init (struct statics *statics)
X  {
X    static struct var v;
X
X    /* fill in the statics information */
X    statics->procstate_names = procstatenames;
X    statics->cpustate_names = cpustatenames;
X    statics->memory_names = memorynames;
X
X    /* get the list of symbols we want to access in the kernel */
X    if (nlist (UNIX, nlst))
X      {
X	(void) fprintf (stderr, "Unable to nlist %s\n", UNIX);
X	return (-1);
X      }
X
X    /* make sure they were all found */
X    if (check_nlist (nlst) > 0)
X      return (-1);
X
X    /* open kernel memory */
X    if ((kmem = open (KMEM, O_RDONLY)) == -1)
X      {
X	perror (KMEM);
X	return (-1);
X      }
X
X    /* get the symbol values out of kmem */
X    /* NPROC Tuning parameter for max number of processes */
X    (void) getkval (nlst[X_V].n_value, &v, sizeof (struct var), nlst[X_V].n_name);
X    nproc = v.v_proc;
X
X    /* stash away certain offsets for later use */
X    mpid_offset = nlst[X_MPID].n_value;
X    nproc_offset = nlst[X_NPROC].n_value;
X    avenrun_offset = nlst[X_AVENRUN].n_value;
X    anoninfo_offset = nlst[X_ANONINFO].n_value;
X    total_offset = nlst[X_TOTAL].n_value;
X    sysinfo_offset = nlst[X_SYSINFO].n_value;
X
X    /* allocate space for proc structure array and array of pointers */
X    bytes = nproc * sizeof (struct prpsinfo);
X    pbase = (struct prpsinfo *) malloc (bytes);
X    pref = (struct prpsinfo **) malloc (nproc * sizeof (struct prpsinfo *));
X
X    /* Just in case ... */
X    if (pbase == (struct prpsinfo *) NULL || pref == (struct prpsinfo **) NULL)
X      {
X	(void) fprintf (stderr, "%s: can't allocate sufficient memory\n", myname);
X	return (-1);
X      }
X
X    if (!(procdir = opendir (PROCFS)))
X      {
X	(void) fprintf (stderr, "Unable to open %s\n", PROCFS);
X	return (-1);
X      }
X
X    if (chdir (PROCFS))
X      {				/* handy for later on when we're reading it */
X	(void) fprintf (stderr, "Unable to chdir to %s\n", PROCFS);
X	return (-1);
X      }
X
X    /* all done! */
X    return (0);
X  }
X
Xchar *
Xformat_header (char *uname_field)
X{
X  register char *ptr;
X
X  ptr = header + UNAME_START;
X  while (*uname_field != '\0')
X    *ptr++ = *uname_field++;
X
X  return (header);
X}
X
Xvoid
Xget_system_info (struct system_info *si)
X{
X  long avenrun[3];
X  struct sysinfo sysinfo;
X  struct vmtotal total;
X  struct anoninfo anoninfo;
X  static time_t cp_old[CPUSTATES];
X  static time_t cp_diff[CPUSTATES];	/* for cpu state percentages */
X  register int i;
X
X  (void) getkval (sysinfo_offset, &sysinfo, sizeof (struct sysinfo), "sysinfo");
X
X  /* convert cp_time counts to percentages */
X  (void) percentages (CPUSTATES, cpu_states, sysinfo.cpu, cp_old, cp_diff);
X
X  /* get mpid -- process id of last process */
X  (void) getkval (mpid_offset, &(si->last_pid), sizeof (si->last_pid),
X		  "mpid");
X
X  /* get load average array */
X  (void) getkval (avenrun_offset, (int *) avenrun, sizeof (avenrun), "avenrun");
X
X  /* convert load averages to doubles */
X  for (i = 0; i < 3; i++)
X    si->load_avg[i] = loaddouble (avenrun[i]);
X
X  /* get total -- systemwide main memory usage structure */
X  (void) getkval (total_offset, (int *) (&total), sizeof (total), "total");
X  /* convert memory stats to Kbytes */
X  memory_stats[0] = pagetok (total.t_rm);
X  memory_stats[1] = pagetok (total.t_arm);
X  memory_stats[2] = pagetok (total.t_free);
X  (void) getkval (anoninfo_offset, (int *) (&anoninfo), sizeof (anoninfo),
X		  "anoninfo");
X  memory_stats[3] = pagetok (anoninfo.ani_max - anoninfo.ani_free);
X  memory_stats[4] = pagetok (anoninfo.ani_max - anoninfo.ani_resv);
X
X  /* set arrays and strings */
X  si->cpustates = cpu_states;
X  si->memory = memory_stats;
X}
X
Xstatic struct handle handle;
X
Xcaddr_t
Xget_process_info (
X		   struct system_info *si,
X		   struct process_select *sel,
X		   int (*compare) ())
X{
X  register int i;
X  register int total_procs;
X  register int active_procs;
X  register struct prpsinfo **prefp;
X  register struct prpsinfo *pp;
X
X  /* these are copied out of sel for speed */
X  int show_idle;
X  int show_system;
X  int show_uid;
X
X  /* Get current number of processes */
X  (void) getkval (nproc_offset, (int *) (&nproc), sizeof (nproc), "nproc");
X
X  /* read all the proc structures */
X  getptable (pbase);
X
X  /* get a pointer to the states summary array */
X  si->procstates = process_states;
X
X  /* set up flags which define what we are going to select */
X  show_idle = sel->idle;
X  show_system = sel->system;
X  show_uid = sel->uid != -1;
X
X  /* count up process states and get pointers to interesting procs */
X  total_procs = 0;
X  active_procs = 0;
X  (void) memset (process_states, 0, sizeof (process_states));
X  prefp = pref;
X
X  for (pp = pbase, i = 0; i < nproc; pp++, i++)
X    {
X      /*
X	 *  Place pointers to each valid proc structure in pref[].
X	 *  Process slots that are actually in use have a non-zero
X	 *  status field.  Processes with SSYS set are system
X	 *  processes---these get ignored unless show_sysprocs is set.
X	 */
X      if (pp->pr_state != 0 &&
X	  (show_system || ((pp->pr_flag & SSYS) == 0)))
X	{
X	  total_procs++;
X	  process_states[pp->pr_state]++;
X	  if ((!pp->pr_zomb) &&
X	      (show_idle || (pp->pr_state == SRUN) || (pp->pr_state == SONPROC)) &&
X	      (!show_uid || pp->pr_uid == (uid_t) sel->uid))
X	    {
X	      *prefp++ = pp;
X	      active_procs++;
X	    }
X	}
X    }
X
X  /* if requested, sort the "interesting" processes */
X  if (compare != NULL)
X      qsort ((char *) pref, active_procs, sizeof (struct prpsinfo *), compare);
X
X  /* remember active and total counts */
X  si->p_total = total_procs;
X  si->p_active = active_procs;
X
X  /* pass back a handle */
X  handle.next_proc = pref;
X  handle.remaining = active_procs;
X  return ((caddr_t) & handle);
X}
X
Xchar fmt[128];			/* static area where result is built */
X
Xchar *
Xformat_next_process (
X		      caddr_t handle,
X		      char *(*get_userid) ())
X{
X  register struct prpsinfo *pp;
X  struct handle *hp;
X  register long cputime;
X  register double pctcpu;
X
X  /* find and remember the next proc structure */
X  hp = (struct handle *) handle;
X  pp = *(hp->next_proc++);
X  hp->remaining--;
X
X  /* get the cpu usage and calculate the cpu percentages */
X  cputime = pp->pr_time.tv_sec;
X  pctcpu = percent_cpu (pp);
X
X  /* format this entry */
X  (void) sprintf (fmt,
X		  Proc_format,
X		  pp->pr_pid,
X		  (*get_userid) (pp->pr_uid),
X		  pp->pr_pri - PZERO,
X		  pp->pr_nice - NZERO,
X		  pagetok (pp->pr_size),
X		  pagetok (pp->pr_rssize),
X		  state_abbrev[pp->pr_state],
X		  cputime / 60l,
X		  cputime % 60l,
X		  (pp->pr_cpu & 0377),
X		  100.0 * pctcpu,
X		  pp->pr_fname);
X
X  /* return the result */
X  return (fmt);
X}
X
X/*
X * check_nlist(nlst) - checks the nlist to see if any symbols were not
X *		found.  For every symbol that was not found, a one-line
X *		message is printed to stderr.  The routine returns the
X *		number of symbols NOT found.
X */
Xint
Xcheck_nlist (register struct nlist *nlst)
X{
X  register int i;
X
X  /* check to see if we got ALL the symbols we requested */
X  /* this will write one line to stderr for every symbol not found */
X
X  i = 0;
X  while (nlst->n_name != NULL)
X    {
X      if (nlst->n_type == 0)
X	{
X	  /* this one wasn't found */
X	  (void) fprintf (stderr, "kernel: no symbol named `%s'\n", nlst->n_name);
X	  i = 1;
X	}
X      nlst++;
X    }
X  return (i);
X}
X
X
X/*
X *  getkval(offset, ptr, size, refstr) - get a value out of the kernel.
X *	"offset" is the byte offset into the kernel for the desired value,
X *  	"ptr" points to a buffer into which the value is retrieved,
X *  	"size" is the size of the buffer (and the object to retrieve),
X *  	"refstr" is a reference string used when printing error meessages,
X *	    if "refstr" starts with a '!', then a failure on read will not
X *  	    be fatal (this may seem like a silly way to do things, but I
X *  	    really didn't want the overhead of another argument).
X *
X */
Xint
Xgetkval (
X	  unsigned long offset,
X	  int *ptr,
X	  int size,
X	  char *refstr)
X{
X  if (lseek (kmem, (long) offset, 0) == -1)
X    {
X      if (*refstr == '!')
X	refstr++;
X      (void) fprintf (stderr, "%s: lseek to %s: %s\n",
X		      myname, refstr, sys_errlist[errno]);
X      quit (22);
X    }
X  if (read (kmem, (char *) ptr, size) == -1)
X    if (*refstr == '!')
X      /* we lost the race with the kernel, process isn't in memory */
X      return (0);
X    else
X      {
X	(void) fprintf (stderr, "%s: reading %s: %s\n",
X			myname, refstr, sys_errlist[errno]);
X	quit (23);
X      }
X  return (1);
X}
X
X/* comparison routine for qsort */
X
X/*
X *  proc_compare - comparison function for "qsort"
X *	Compares the resource consumption of two processes using five
X *  	distinct keys.  The keys (in descending order of importance) are:
X *  	percent cpu, cpu ticks, state, resident set size, total virtual
X *  	memory usage.  The process states are ordered as follows (from least
X *  	to most important):  WAIT, zombie, sleep, stop, start, run.  The
X *  	array declaration below maps a process state index into a number
X *  	that reflects this ordering.
X */
X
X
Xunsigned char sorted_state[] =
X{
X  0,				/* not used		*/
X  3,				/* sleep		*/
X  6,				/* run			*/
X  2,				/* zombie		*/
X  4,				/* stop			*/
X  5,				/* start		*/
X  7,				/* run on a processor   */
X  1				/* being swapped (WAIT)	*/
X};
X
Xint
Xproc_compare (
X	       struct prpsinfo **pp1,
X	       struct prpsinfo **pp2)
X  {
X    register struct prpsinfo *p1;
X    register struct prpsinfo *p2;
X    register long result;
X
X    /* remove one level of indirection */
X    p1 = *pp1;
X    p2 = *pp2;
X
X    /* compare percent cpu (pctcpu) */
X    if ((result = (long) (p2->pr_cpu - p1->pr_cpu)) == 0)
X      {
X	/* use cpticks to break the tie */
X	if ((result = p2->pr_time.tv_sec - p1->pr_time.tv_sec) == 0)
X	  {
X	    /* use process state to break the tie */
X	    if ((result = (long) (sorted_state[p2->pr_state] -
X				  sorted_state[p1->pr_state])) == 0)
X	      {
X		/* use priority to break the tie */
X		if ((result = p2->pr_oldpri - p1->pr_oldpri) == 0)
X		  {
X		    /* use resident set size (rssize) to break the tie */
X		    if ((result = p2->pr_rssize - p1->pr_rssize) == 0)
X		      {
X			/* use total memory to break the tie */
X			result = (p2->pr_size - p1->pr_size);
X		      }
X		  }
X	      }
X	  }
X      }
X    return (result);
X  }
X
X/*
Xget process table
X*/
Xvoid
Xgetptable (struct prpsinfo *baseptr)
X{
X  struct prpsinfo *currproc;	/* pointer to current proc structure	*/
X  int numprocs = 0;
X  struct dirent *direntp;
X
X  for (rewinddir (procdir); direntp = readdir (procdir);)
X    {
X      int fd;
X
X      if ((fd = open (direntp->d_name, O_RDONLY)) < 0)
X	continue;
X
X      currproc = &baseptr[numprocs];
X      if (ioctl (fd, PIOCPSINFO, currproc) < 0)
X	{
X	  (void) close (fd);
X	  continue;
X	}
X
X      numprocs++;
X      (void) close (fd);
X    }
X
X  if (nproc != numprocs)
X    nproc = numprocs;
X}
X
X/* return the owner of the specified process, for use in commands.c as we're
X   running setuid root */
Xuid_t
Xproc_owner (pid_t pid)
X{
X  register struct prpsinfo *p;
X  int i;
X  for (i = 0, p = pbase; i < nproc; i++, p++)
X    if (p->pr_pid == pid)
X      return (p->pr_uid);
X
X  return (-1);
X}
X
Xint
Xsetpriority (int dummy, int who, int niceval)
X{
X  int scale;
X  int prio;
X  pcinfo_t pcinfo;
X  pcparms_t pcparms;
X  tsparms_t *tsparms;
X
X  strcpy (pcinfo.pc_clname, "TS");
X  if (priocntl (0, 0, PC_GETCID, (caddr_t) & pcinfo) == -1)
X    return (-1);
X
X  prio = niceval;
X  if (prio > PRIO_MAX)
X    prio = PRIO_MAX;
X  else if (prio < PRIO_MIN)
X    prio = PRIO_MIN;
X
X  tsparms = (tsparms_t *) pcparms.pc_clparms;
X  scale = ((tsinfo_t *) pcinfo.pc_clinfo)->ts_maxupri;
X  tsparms->ts_uprilim = tsparms->ts_upri = -(scale * prio) / 20;
X  pcparms.pc_cid = pcinfo.pc_cid;
X
X  if (priocntl (P_PID, who, PC_SETPARMS, (caddr_t) & pcparms) == -1)
X    return (-1);
X
X  return (0);
X}
END_OF_FILE
if test 15086 -ne `wc -c <'machine/m_svr4.c'`; then
    echo shar: \"'machine/m_svr4.c'\" unpacked with wrong size!
fi
# end of 'machine/m_svr4.c'
fi
echo shar: End of archive 3 \(of 13\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 13 archives.
    echo "Now read README and INSTALL, then run Configure"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
