Newsgroups: comp.sources.unix
From: phil@eecs.nwu.edu (William LeFebvre)
Subject: v27i001: top - a top process display, version 3.2, Part01/13
Message-id: <1.744843136.4744@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: phil@eecs.nwu.edu (William LeFebvre)
Posting-Number: Volume 27, Issue 1
Archive-Name: top-3.2/part01

[ this is the latest version of "top", which produces a real time, continuously
  updating display that looks more or less like this:

	load averages:   0.31,  0.25,  0.16                            13:40:52
	65 processes:  60 sleeping, 1 running, 4 stopped
	Cpu states: 13.8% user,  1.9% nice,  8.1% system, 76.0% idle
	Memory: Real: 21432K/25840K Virt: Free: 1044K

	  PID USERNAME PRI NICE   SIZE   RES STATE   TIME   WCPU    CPU COMMAND
	14295 news       2    4  6744K 4728K sleep 268:01  1.51%  1.51% innd
	 4495 vixie     28    0   840K  340K stop    0:01  1.04%  1.03% jove
	 6551 vixie      2    0  1508K  436K sleep   6:43  0.88%  0.88% xterm
	 4560 vixie     28    0   756K  232K run     0:00  3.01%  0.78% top
	  959 root       2    0   624K  124K sleep   0:15  0.00%  0.00% telnetd
	[...]

  it is mostly of use to system administrators but if you are ever wondering
  why your computer is slow, "top" can tell you.			--vix ]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 13)."
# Contents:  FAQ Make.desc.X Makefile.X README boolean.h display.h
#   getans getopt.c layout.h loadavg.h m-template machine machine.h
#   machine/m_386bsd.man machine/m_bsd44.man machine/m_bsd44a.man
#   machine/m_dgux.man machine/m_dynix.man machine/m_hpux9.man
#   machine/m_sunos4.man machine/m_sunos5.man machine/m_svr4.man
#   machine/m_svr42.man machine/m_umax.man metatop os.h patchlevel.h
#   screen.h sigconv.awk top.h top.local.H username.c utils.h
#   version.c
# Wrapped by phil@pex on Wed Aug  4 14:22:39 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'FAQ' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'FAQ'\"
else
echo shar: Extracting \"'FAQ'\" \(3184 characters\)
sed "s/^X//" >'FAQ' <<'END_OF_FILE'
X                             TOP
X                         Version 3.2
X
X                       William LeFebvre
X		     and a cast of dozens
X
X
XFREQUENTLY ASKED QUESTIONS AND THEIR ANSWERS
X
X1. "We just upgraded our operating system to version 99.9.9.9 and top
X   broke.  What should we do?"
X
X   Recompile.  Top is very sensitive to changes in internal kernel data
X   structures.  It is not uncommon for a new version of the operating
X   system to include changes to kernel data structures.
X
X2. "I tried compiling top under SunOS version 4.1.3 and it got compile
X   time errors.  Is there a patch?"
X
X   If you try compiling top in a "System V environment" under SunOS
X   (that is, /usr/5bin is before /usr/bin on your path) then the 
X   compilation will fail.  This is mostly due to the fact that top
X   thinks its being compiled on a System V machine when it really isn't.
X   The only solution is to put /usr/bin and /usr/ucb before /usr/5bin
X   on your path and try again.
X
X3. "Top is (not) displaying idle processes and I don't (do) want it to."
X
X   This default has only changed about a dozen times, and I finally got
X   tired of people whining about it.  Go read the manual page for version
X   3.2 and pay special attention to the description of the "TOP" environment
X   variable.
X
X4. "We have so much memory in our machine that the memory status display
X   (the fourth line) ends up being longer than 80 characters.  This
X   completely messes up top's output.  Is there a patch?"
X
X   No, but this will be fixed in version 3.2.  In the meantime, just
X   take some of that memory out of your machine.  :-)
X
X5. "When I run top on my SVR4-derived operating system, it displays all
X   the system information at the top but does not display any process
X   information.  Yet when I run it as root, everything works fine."
X
X   Your system probably uses the pseudo file system "/proc", which is
X   by default only accessible by root.  Top needs to be installed setuid
X   root on such systems if it is going to function correctly for normal
X   users.
X
X6. "Configure said that it saw /proc and is recommending that I install
X   top setuid root.  Is there any way around this?  Is it safe?"
X
X   There is no way around it.  Complain to Posix.  Every effort has been
X   made to make top a secure setuid program.  However, we cannot guarantee
X   that there are no security problems associated with this configuration.
X   The places where top is most vulnerable are the builtin kill and renice
X   commands.  There is no internal top command that causes top to start
X   a shell as a subprocess.
X
X7. "Is there a module that will make top work under AIX?"
X
X   Not at the current time.  Many people have started this project but
X   none have yet to finish.  That may say something about the difficulty
X   of the task......
X
X8. "To whom do I report problems with top?"
X
X   You can mail bug reports to "phil@eecs.nwu.edu".  If it looks like the
X   problem is machine-specific, I will forward the report along to the
X   module's author.  If you would like to converse directly with the
X   module author, the authors' names are listed at the beginning of the
X   module .c file in the "machine" directory.
X
END_OF_FILE
if test 3184 -ne `wc -c <'FAQ'`; then
    echo shar: \"'FAQ'\" unpacked with wrong size!
fi
# end of 'FAQ'
fi
if test -f 'Make.desc.X' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Make.desc.X'\"
else
echo shar: Extracting \"'Make.desc.X'\" \(604 characters\)
sed "s/^X//" >'Make.desc.X' <<'END_OF_FILE'
X# Makefile for .desc files
X
X# This makefile is the prototype for "Make.desc", which is used by
X# top's Configure script to build .desc files and the SYNOPSIS file.
X# Configure then uses these files to ask appropriate questions.
X
X# Written by William LeFebvre, Northwestern University
X
X# DO NOT EDIT "Make.desc"!!!  Make changes to "Make.desc.X",
X# then "make veryclean", then run "Configure".
X
XDESCS=%descs%
X
X.SUFFIXES: .desc
X
X.c.desc:
X	sed -e '/^$$/,$$d' -e 's,^[/ *]*,,' $< > $@
X
Xall: SYNOPSIS
X
XSYNOPSIS: $(DESCS)
X	grep SYNOPSIS: $(DESCS) | sed -e 's@^machine/m_@@' -e 's@.desc:.[^:]*: *@:@' >SYNOPSIS
END_OF_FILE
if test 604 -ne `wc -c <'Make.desc.X'`; then
    echo shar: \"'Make.desc.X'\" unpacked with wrong size!
fi
# end of 'Make.desc.X'
fi
if test -f 'Makefile.X' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.X'\"
else
echo shar: Extracting \"'Makefile.X'\" \(3729 characters\)
sed "s/^X//" >'Makefile.X' <<'END_OF_FILE'
X# Makefile for "top", a top 10 process display for Unix
X#
X# This makefile is for top, version 3
X#
X# Written by William LeFebvre, Northwestern University
X#			(formerly Rice University)
X
X# DO NOT EDIT "Makefile"!!!!  Make changes to "Makefile.X" and rerun
X# Configure.
X
X# Executables (these should be obvious):
X
XSHELL   = %shell%
XCC      = %cc%
XAWK     = %awk%
XINSTALL = %install%
X
X# installation information:
X#	OWNER	- name (or uid) for the installed executable's owner
X#	GROUP	- group name (or gid) for the installed executable's group
X#	MODE	- mode for the installed executable (should start with a 0)
X#	BINDIR	- directory where the executable should live
X#	MANDIR	- directory where the manual page should live
X#	MANEXT	- installed man pages end in .$(MANEXT)
X#	MANSTY	- "man" or "catman" depending on what's to be installed
X#	SIGNAL	- <signal.h> or <sys/signal.h>; the one with signal definitions
X#	TROFF	- most appropriate troff command
X
XOWNER  = %owner%
XGROUP  = %group%
XMODE   = %mode%
XBINDIR = %bindir%
XMANDIR = %mandir%
XMANEXT = %manext%
XMANSTY = %mansty%
XSIGNAL = %signal%
X
X# Values for the two defaults in "top":
X#	TOPN	- default number of processes to display
X#	DELAY	- default delay between updates
X#
X# set TOPN to -1 to indicate infinity (so that top will display as many
X# as the screen will hold).
X
XTOPN = %topn%
XDELAY = %delay%
X
XTARFILES = README INSTALL FAQ Changes Configure Porting \
X	   Makefile.X Make.desc.X getans \
X	   top.c commands.c display.c screen.c username.c \
X	   utils.c version.c getopt.c \
X	   boolean.h display.h layout.h loadavg.h screen.h \
X	   machine.h patchlevel.h top.h top.local.H os.h utils.h \
X	   sigconv.awk top.X m-template metatop \
X	   machine
XCFILES = top.c commands.c display.c screen.c username.c \
X	 utils.c version.c getopt.c machine.c
XOBJS = top.o commands.o display.o screen.o username.o \
X       utils.o version.o getopt.o machine.o
X
XCDEFS = %cdefs%
XLIBS = %libs%
X
XCFLAGS = %cflgs% $(CDEFS)
XLINTFLAGS = -x $(CDEFS)
X
Xall: Makefile top.local.h top
X
XMakefile: Makefile.X
X	@echo 'You need to run the script "Configure" before running "make".'
X	exit 10
X
Xtop.local.h: top.local.H
X	@echo 'You need to run the script "Configure" before running "make".'
X	exit 10
X
Xtop: $(OBJS)
X	rm -f top
X	$(CC) -o top $(OBJS) -ltermcap -lm $(LIBS)
X
Xlint: sigdesc.h
X	$(LINT) $(LINTFLAGS) $(CFILES)
X
X# include file dependencies
Xtop.o: boolean.h display.h screen.h top.h top.local.h utils.h machine.h 
Xcommands.o: boolean.h sigdesc.h utils.h
Xdisplay.o: boolean.h display.h layout.h screen.h top.h top.local.h utils.h
Xmachine.o: top.h machine.h
Xscreen.o: boolean.h screen.h
Xutils.o: top.h
Xversion.o: top.h patchlevel.h
Xusername.o: top.local.h utils.h
X
X# automatically built include file
Xsigdesc.h: sigconv.awk $(SIGNAL)
X	$(AWK) -f sigconv.awk $(SIGNAL) >sigdesc.h
X
Xtar:
X	rm -f top.tar machine/*.desc
X	tar cvf top.tar $(TARFILES)
X
Xshar:
X	rm -f top.shar* machine/*.desc
X	makekit -ntop.shar. -t"Now read README and INSTALL, then run Configure" machine $(TARFILES)/*
X
Xclean:
X	rm -f *.o top core core.* sigdesc.h
X
Xveryclean: clean
X	rm -f Make.desc machine/*.desc .defaults top.tar SYNOPSIS Makefile top.local.h top.1 machine.c
X
Xinstall: top top.1 install-top install-$(MANSTY)
X
Xinstall-top:
X	$(INSTALL) -s -o $(OWNER) -m $(MODE) -g $(GROUP) top $(BINDIR)
X
Xinstall-man:
X	$(INSTALL) -c top.1 $(MANDIR)/top.$(MANEXT)
X
Xinstall-catman:
X	tbl top.1 | nroff -man > $(MANDIR)/top.$(MANEXT)
X
Xinstallmeta: top top.1
X	$(INSTALL) -o $(OWNER) -m 755 -g $(GROUP) metatop $(BINDIR)/top
X	@echo $(INSTALL) -s -o $(OWNER) -m $(MODE) -g $(GROUP) top $(BINDIR)/top-`uname -m`-`uname -r`
X	@$(INSTALL) -s -o $(OWNER) -m $(MODE) -g $(GROUP) \
X		top $(BINDIR)/top-`uname -m`-`uname -r`
X	$(INSTALL) -c top.1 $(MANDIR)/top.$(MANEXT)
END_OF_FILE
if test 3729 -ne `wc -c <'Makefile.X'`; then
    echo shar: \"'Makefile.X'\" unpacked with wrong size!
fi
# end of 'Makefile.X'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(4578 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X                             TOP
X                         Version 3.2
X
X                       William LeFebvre
X		     and a cast of dozens
X
X
XIf you do not want to read this entire file, then at least read
Xthe section at the end entitled "KNOWN PROBLEMS".
X
X"top" is a program that will give continual reports about the state of
Xthe system, including a list of the top cpu using processes.  Version 3
Xof "top" has three primary design goals: provide an accurate snapshot of
Xthe system and process state, not be one of the top processes itself, be
Xas portable as possible.
X
XVersion 3 has many bug fixes from version 2.5, and it has also been
Xreorganized in a major way to make it easy to port to other platforms.
XAll system dependent code is now contained in one file.
X
XTop now includes a configuration script called "Configure".  It helps
Xthe installer choose the correct parameters for this particular
Xinstallation.  This script MUST be run before attempting to compile top.
X
XTop requires read access to the memory files "/dev/kmem" and "/dev/mem"
Xas well as the system image "/vmunix".  Some installations have these
Xfiles protected from general access.  These sites would have to install
Xthis program in the same way that programs such as "ps" are installed.
X
XCAVEAT: version 3 of top has internal commands that kill and renice
Xprocesses.  Although I have taken steps to insure that top makes
Xappropriate checks with these commands, I cannot guarantee that these
Xinternal commands are totally secure.  IF YOU INSTALL top as a SETUID
Xprogram, you do so AT YOUR OWN RISK!  I realize that some operating
Xsystems will require top to run setuid, and I will do everything I can
Xto make sure that top is a secure setuid program.
X
XConfigure will ask you to input values for certain parameters.  Before
Xeach parameter, Configure will display a description of what the
Xparameter does.  Read the description and choose an appropriate value.
XSometimes a default will appear in brackets.  Typing just return will
Xchoose the default.
X
XSystem support now takes the form of "modules".  Adding support for
Xa different architecture requires only adding a module.  Configure
Xasks which module to use when it is configuring top.  See the file
X"Porting" for a description of how to write your own module.
X
XTo compile and install "top", read the file "INSTALL" and follow the
Xdiurections and advice contained therein.
X
XOnce you have created a binary for one particular type of machine, you
Xcan reconfigure for another type with "./Configure modulename" where
X"modulename" is replaced with the appropriate module name.  All other
Xparameter values are kept the same.
X
XIf you make any kind of change to "top" that you feel would be
Xbeneficial to others who use this program, or if you find and fix a bug,
Xplease send me the change.
X
XAVAILABILITY
X
XThe latest version of "top" is always available via anonymous FTP from
Xthe host "eecs.nwu.edu" in the directory "/pub/top".  Additional modules
Xwill be made available in the directory "/pub/top/m".
X
XKNOWN PROBLEMS:
X
XGnu CC
X
XGnu CC likes very much to use its own include files.  Not being a gcc
Xexpert, I can't explain why it does this.  But I can tell you that in
Xat least some instances that I have encounterd, the files in gnu-cc's
X"include/sys" directory are INCORRECT.  Unfortunately, using the
Xstandard include files with Gnu CC doesn't seem to produce a usable
Xresult, either.  If you feel you must use gcc to compile top, then I
Xwould recommend you make machine.o with CFLAGS=-I/usr/include, then
Xmake the rest of the object files normally.  This seems to work
Xreasonably well.
X
X
XMultiprocessor Solaris 2 machines:
X
XThere is a bug in the sunos5 module which prevents it from working
Xcorrectly on machines that contain more than one processor (single
Xprocessor sun4m machines seem to run just fine).  A fix is pending.
X
X
XSystem V R 4.2
X
XLoad average and memory displays do not work.  The problem has been
Xtraced down to a potential bug in the "mem" driver.  The author
Xof the svr42 module is working on a fix.
X
X
XMemory output overflow
X
XSome "well endowed" machines will cause top to overflow some of the
Xfields in the memory line and the "SIZE" and "RES" columns.  Version
X3.2 will have an elegant fix for this (memory values over a certain
Xvalue will be displayed in megabytes with a trailing "M").
X
X
X
X		William LeFebvre
X		Department of Electrical Engineering and Computer Science
X		Northwestern University
X		<phil@eecs.nwu.edu>
X
X
X		U.S. Mail address:
X		    William LeFebvre
X		    EECS Department
X		    2145 Sheridan Road
X		    Evanston, IL  60208
END_OF_FILE
if test 4578 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'boolean.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'boolean.h'\"
else
echo shar: Extracting \"'boolean.h'\" \(125 characters\)
sed "s/^X//" >'boolean.h' <<'END_OF_FILE'
X/* My favorite names for boolean values */
X#define  No	0
X#define  Yes	1
X#define  Maybe	2		/* tri-state boolean, actually */
X
END_OF_FILE
if test 125 -ne `wc -c <'boolean.h'`; then
    echo shar: \"'boolean.h'\" unpacked with wrong size!
fi
# end of 'boolean.h'
fi
if test -f 'display.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'display.h'\"
else
echo shar: Extracting \"'display.h'\" \(135 characters\)
sed "s/^X//" >'display.h' <<'END_OF_FILE'
X/* constants needed for display.c */
X
X/* "type" argument for new_message function */
X
X#define  MT_standout  1
X#define  MT_delayed   2
X
END_OF_FILE
if test 135 -ne `wc -c <'display.h'`; then
    echo shar: \"'display.h'\" unpacked with wrong size!
fi
# end of 'display.h'
fi
if test -f 'getans' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getans'\"
else
echo shar: Extracting \"'getans'\" \(1544 characters\)
sed "s/^X//" >'getans' <<'END_OF_FILE'
X#!/bin/csh -f
Xset ny = (no yes)
Xif ($2 == "yesno") then
X    @ i = $3 + 1
X    set pmpt = "$1 [$ny[$i]]: "
Xelse
X    set pmpt = "$1 [$3]: "
Xendif
Xrpt:
Xecho -n "$pmpt"
Xset input = $<
Xswitch ($2)
X    case number:
X	set tmp = `echo $input | tr -d 0123456789.`
X	if ("x$tmp" != x) then
X	    echo "Invalid number.  Please try again."
X	    goto rpt
X	endif
X	breaksw
X
X    case integer:
X	set tmp = `echo $input | tr -d 0123456789`
X	if ("x$tmp" != x) then
X	    echo "Invalid integer.  Please try again."
X	    goto rpt
X	endif
X	breaksw
X
X    case neginteger:
X	if ("x$input" != x-1) then
X	    set tmp = `echo $input | tr -d 0123456789`
X	    if ("x$tmp" != x) then
X	        echo "Invalid integer.  Please try again."
X	        goto rpt
X	    endif
X	endif
X	breaksw
X
X    case file:
X	if ("x$input" == "x") then
X	    set input = $3
X	endif
X	if (! -e "$input") then
X	    echo The file $input "does not exist.  Please try again."
X	    goto rpt
X	endif
X	breaksw
X
X    case path:
X	if ("x$input" == "x") then
X	    set input = "$3"
X	endif
X	if (! -e "$input") then
X	    foreach elt ($path)
X		if (-e "$elt/$input") breaksw
X	    end
X	    echo The command $input "was not found.  Please try again."
X	    goto rpt
X	endif
X	breaksw
X
X    case yesno:
X	if ("x$input" == xy || "x$input" == xyes) then
X	   set input = 1
X	else if ("x$input" == xn || "x$input" == xno) then
X	   set input = 0
X	else if ("x$input" != x) then
X	   echo 'Please answer "yes" or "no".'
X	   goto rpt
X	endif
X	breaksw
X
X    default:
X	breaksw
X
Xendsw
X
Xif ("x$input" == x) then
X    set input = "$3"
Xendif
X
Xecho $input > $4
END_OF_FILE
if test 1544 -ne `wc -c <'getans'`; then
    echo shar: \"'getans'\" unpacked with wrong size!
fi
chmod +x 'getans'
# end of 'getans'
fi
if test -f 'getopt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getopt.c'\"
else
echo shar: Extracting \"'getopt.c'\" \(1262 characters\)
sed "s/^X//" >'getopt.c' <<'END_OF_FILE'
X/*
X * getopt routine customized for top.
X */
X
X/*LINTLIBRARY*/
X
X#include "os.h"
X#ifndef NULL
X#define NULL	0
X#endif
X#ifndef EOF
X#define EOF	(-1)
X#endif
X#define ERR(s, c)	if(opterr){\
X	extern int write();\
X	char errbuf[2];\
X	errbuf[0] = c; errbuf[1] = '\n';\
X	(void) write(2, argv[0], strlen(argv[0]));\
X	(void) write(2, s, strlen(s));\
X	(void) write(2, errbuf, 2);}
X
X
Xint	opterr = 1;
Xint	optind = 1;
Xint	optopt;
Xchar	*optarg;
X
Xint
Xgetopt(argc, argv, opts)
Xint	argc;
Xchar	**argv, *opts;
X{
X	static int sp = 1;
X	register int c;
X	register char *cp;
X
X	if(sp == 1)
X		if(optind >= argc ||
X		   argv[optind][0] != '-' || argv[optind][1] == '\0')
X			return(EOF);
X		else if(strcmp(argv[optind], "--") == 0) {
X			optind++;
X			return(EOF);
X		}
X	optopt = c = argv[optind][sp];
X	if(c == ':' || (cp=strchr(opts, c)) == NULL) {
X		ERR(": unknown option, -", c);
X		if(argv[optind][++sp] == '\0') {
X			optind++;
X			sp = 1;
X		}
X		return('?');
X	}
X	if(*++cp == ':') {
X		if(argv[optind][sp+1] != '\0')
X			optarg = &argv[optind++][sp+1];
X		else if(++optind >= argc) {
X			ERR(": argument missing for -", c);
X			sp = 1;
X			return('?');
X		} else
X			optarg = argv[optind++];
X		sp = 1;
X	} else {
X		if(argv[optind][++sp] == '\0') {
X			sp = 1;
X			optind++;
X		}
X		optarg = NULL;
X	}
X	return(c);
X}
END_OF_FILE
if test 1262 -ne `wc -c <'getopt.c'`; then
    echo shar: \"'getopt.c'\" unpacked with wrong size!
fi
# end of 'getopt.c'
fi
if test -f 'layout.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'layout.h'\"
else
echo shar: Extracting \"'layout.h'\" \(621 characters\)
sed "s/^X//" >'layout.h' <<'END_OF_FILE'
X/*
X *  Top - a top users display for Berkeley Unix
X *
X *  This file defines the locations on tne screen for various parts of the
X *  display.  These definitions are used by the routines in "display.c" for
X *  cursor addressing.
X */
X
X#define  x_lastpid	10
X#define  y_lastpid	0
X#define  x_loadave	33
X#define  x_loadave_nompid	16
X#define  y_loadave	0
X#define  x_procstate	0
X#define  y_procstate	1
X#define  x_brkdn	15
X#define  y_brkdn	1
X#define  x_mem		8
X#define  y_mem		3
X#define  y_message	4
X#define  x_header	0
X#define  y_header	5
X#define  x_idlecursor	0
X#define  y_idlecursor	4
X#define  y_procs	6
X
X#define  y_cpustates	2
END_OF_FILE
if test 621 -ne `wc -c <'layout.h'`; then
    echo shar: \"'layout.h'\" unpacked with wrong size!
fi
# end of 'layout.h'
fi
if test -f 'loadavg.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'loadavg.h'\"
else
echo shar: Extracting \"'loadavg.h'\" \(1466 characters\)
sed "s/^X//" >'loadavg.h' <<'END_OF_FILE'
X/*
X *  Top - a top users display for Berkeley Unix
X *
X *  Defines required to access load average figures.
X *
X *  This include file sets up everything we need to access the load average
X *  values in the kernel in a machine independent way.  First, it sets the
X *  typedef "load_avg" to be either double or long (depending on what is
X *  needed), then it defines these macros appropriately:
X *
X *	loaddouble(la) - convert load_avg to double.
X *	intload(i)     - convert integer to load_avg.
X */
X
X/*
X * We assume that if FSCALE is defined, then avenrun and ccpu are type long.
X * If your machine is an exception (mips, perhaps?) then make adjustments
X * here.
X *
X * Defined types:  load_avg for load averages, pctcpu for cpu percentages.
X */
X#ifdef mips
X# include <sys/fixpoint.h>
X# if defined(FBITS) && !defined(FSCALE)
X#  define FSCALE (1 << FBITS)	/* mips */
X# endif
X#endif
X
X#ifdef FSCALE
X# define FIXED_LOADAVG FSCALE
X# define FIXED_PCTCPU FSCALE
X#endif
X
X#ifdef ibm032
X# undef FIXED_LOADAVG
X# undef FIXED_PCTCPU
X# define FIXED_PCTCPU PCT_SCALE
X#endif
X
X
X#ifdef FIXED_PCTCPU
X  typedef long pctcpu;
X# define pctdouble(p) ((double)(p) / FIXED_PCTCPU)
X#else
Xtypedef double pctcpu;
X# define pctdouble(p) (p)
X#endif
X
X#ifdef FIXED_LOADAVG
X  typedef long load_avg;
X# define loaddouble(la) ((double)(la) / FIXED_LOADAVG)
X# define intload(i) ((int)((i) * FIXED_LOADAVG))
X#else
X  typedef double load_avg;
X# define loaddouble(la) (la)
X# define intload(i) ((double)(i))
X#endif
END_OF_FILE
if test 1466 -ne `wc -c <'loadavg.h'`; then
    echo shar: \"'loadavg.h'\" unpacked with wrong size!
fi
# end of 'loadavg.h'
fi
if test -f 'm-template' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'m-template'\"
else
echo shar: Extracting \"'m-template'\" \(5276 characters\)
sed "s/^X//" >'m-template' <<'END_OF_FILE'
X/*
X * top - a top users display for Unix
X *
X * THIS IS A TEMPLATE FILE FOR A MACHINE DEPENDENT (m_...c) FILE
X *
X * SYNOPSIS:  one line description of machine this module works with
X *
X * DESCRIPTION:
X * Detailed description of this machine dependent module.
X * It can be multiple lines, but a blank comment line (one with only an
X * asterisk) is considered to end it.  Place here a complete list of 
X * the machines and OS versions that this module works on.
X *
X * LIBS:  list of special libraries to include at link step (REMOVE THIS LINE IF NOT NEEDED)
X *
X * AUTHOR:  your name and <your@internet.address>
X */
X
X#include "top.h"
X#include "machine.h"
X
X
X/*
X *  These definitions control the format of the per-process area
X */
X
Xstatic char header[] =
X  "  PID X        PRI NICE   SIZE   RES STATE   TIME   WCPU    CPU COMMAND";
X/* 0123456   -- field to fill in starts at header+6 */
X#define UNAME_START 6
X
X#define Proc_format \
X	"%5d %-8.8s %3d %4d%6dK %4dK %-5s%4d:%02d %5.2f%% %5.2f%% %.14s"
X
X/* these are for detailing the process states */
X
Xint process_states[?];
Xchar *procstatenames[] = {
X    "", " sleeping, ", " ABANDONED, ", " running, ", " starting, ",
X    " zombie, ", " stopped, ",
X    NULL
X};
X
X/* these are for detailing the cpu states */
X
Xint cpu_states[?];
Xchar *cpustatenames[] = {
X    "user", "nice", "system", "idle",
X    NULL
X};
X
X/* these are for detailing the memory statistics */
X
Xint memory_stats[?];
Xchar *memorynames[] = {
X    "K available, ", "K in use, ", "K free, ", "K locked", NULL
X};
X
X/* useful externals */
Xextern int errno;
Xextern char *sys_errlist[];
X
Xlong lseek();
Xlong time();
Xlong percentages();
X
Xmachine_init(statics)
X
Xstruct statics *statics;
X
X{
X    return(0);
X}
X
Xchar *format_header(uname_field)
X
Xregister char *uname_field;
X
X{
X    register char *ptr;
X
X    ptr = header + UNAME_START;
X    while (*uname_field != '\0')
X    {
X	*ptr++ = *uname_field++;
X    }
X
X    return(header);
X}
X
Xget_system_info(si)
X
Xstruct system_info *si;
X
X{
X}
X
Xstatic struct handle handle;
X
Xcaddr_t get_process_info(si, sel, compare)
X
Xstruct system_info *si;
Xstruct process_select *sel;
Xint (*compare)();
X
X{
X    return((caddr_t)&handle);
X}
X
Xchar fmt[128];		/* static area where result is built */
X
X/* define what weighted cpu is.  */
X#define weighted_cpu(pct, pp) ((pp)->p_time == 0 ? 0.0 : \
X			 ((pct) / (1.0 - exp((pp)->p_time * logcpu))))
X
Xchar *format_next_process(handle, get_userid)
X
Xcaddr_t handle;
Xchar *(*get_userid)();
X
X{
X    return(fmt);
X}
X
X/*
X *  getkval(offset, ptr, size, refstr) - get a value out of the kernel.
X *	"offset" is the byte offset into the kernel for the desired value,
X *  	"ptr" points to a buffer into which the value is retrieved,
X *  	"size" is the size of the buffer (and the object to retrieve),
X *  	"refstr" is a reference string used when printing error meessages,
X *	    if "refstr" starts with a '!', then a failure on read will not
X *  	    be fatal (this may seem like a silly way to do things, but I
X *  	    really didn't want the overhead of another argument).
X *  	
X */
X
Xgetkval(offset, ptr, size, refstr)
X
Xunsigned long offset;
Xint *ptr;
Xint size;
Xchar *refstr;
X
X{
X    if (kvm_read(kd, offset, ptr, size) != size)
X    {
X	if (*refstr == '!')
X	{
X	    return(0);
X	}
X	else
X	{
X	    fprintf(stderr, "top: kvm_read for %s: %s\n",
X		refstr, sys_errlist[errno]);
X	    quit(23);
X	}
X    }
X    return(1);
X}
X    
X/* comparison routine for qsort */
X/* NOTE: this is specific to the BSD proc structure, but it should
X   give you a good place to start. */
X
X/*
X *  proc_compare - comparison function for "qsort"
X *	Compares the resource consumption of two processes using five
X *  	distinct keys.  The keys (in descending order of importance) are:
X *  	percent cpu, cpu ticks, state, resident set size, total virtual
X *  	memory usage.  The process states are ordered as follows (from least
X *  	to most important):  WAIT, zombie, sleep, stop, start, run.  The
X *  	array declaration below maps a process state index into a number
X *  	that reflects this ordering.
X */
X
Xstatic unsigned char sorted_state[] =
X{
X    0,	/* not used		*/
X    3,	/* sleep		*/
X    1,	/* ABANDONED (WAIT)	*/
X    6,	/* run			*/
X    5,	/* start		*/
X    2,	/* zombie		*/
X    4	/* stop			*/
X};
X 
Xproc_compare(pp1, pp2)
X
Xstruct proc **pp1;
Xstruct proc **pp2;
X
X{
X    register struct proc *p1;
X    register struct proc *p2;
X    register int result;
X    register pctcpu lresult;
X
X    /* remove one level of indirection */
X    p1 = *pp1;
X    p2 = *pp2;
X
X    /* compare percent cpu (pctcpu) */
X    if ((lresult = p2->p_pctcpu - p1->p_pctcpu) == 0)
X    {
X	/* use cpticks to break the tie */
X	if ((result = p2->p_cpticks - p1->p_cpticks) == 0)
X	{
X	    /* use process state to break the tie */
X	    if ((result = sorted_state[p2->p_stat] -
X			  sorted_state[p1->p_stat])  == 0)
X	    {
X		/* use priority to break the tie */
X		if ((result = p2->p_pri - p1->p_pri) == 0)
X		{
X		    /* use resident set size (rssize) to break the tie */
X		    if ((result = p2->p_rssize - p1->p_rssize) == 0)
X		    {
X			/* use total memory to break the tie */
X			result = PROCSIZE(p2) - PROCSIZE(p1);
X		    }
X		}
X	    }
X	}
X    }
X    else
X    {
X	result = lresult < 0 ? -1 : 1;
X    }
X
X    return(result);
X}
X
Xproc_owner(pid)
X
Xint pid;
X
X{
X   /* returns uid of owner of process pid */
X   return(uid);
X}
X
END_OF_FILE
if test 5276 -ne `wc -c <'m-template'`; then
    echo shar: \"'m-template'\" unpacked with wrong size!
fi
# end of 'm-template'
fi
if test ! -d 'machine' ; then
    echo shar: Creating directory \"'machine'\"
    mkdir 'machine'
fi
if test -f 'machine.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machine.h'\"
else
echo shar: Extracting \"'machine.h'\" \(1305 characters\)
sed "s/^X//" >'machine.h' <<'END_OF_FILE'
X/*
X *  This file defines the interface between top and the machine-dependent
X *  module.  It is NOT machine dependent and should not need to be changed
X *  for any specific machine.
X */
X
X/*
X * the statics struct is filled in by machine_init
X */
Xstruct statics
X{
X    char **procstate_names;
X    char **cpustate_names;
X    char **memory_names;
X};
X
X/*
X * the system_info struct is filled in by a machine dependent routine.
X */
X
Xstruct system_info
X{
X    int    last_pid;
X    double load_avg[NUM_AVERAGES];
X    int    p_total;
X    int    p_active;     /* number of procs considered "active" */
X    int    *procstates;
X    int    *cpustates;
X    int    *memory;
X};
X
X/* cpu_states is an array of percentages * 10.  For example, 
X   the (integer) value 105 is 10.5% (or .105).
X */
X
X/*
X * the process_select struct tells get_process_info what processes we
X * are interested in seeing
X */
X
Xstruct process_select
X{
X    int idle;		/* show idle processes */
X    int system;		/* show system processes */
X    int uid;		/* only this uid (unless uid == -1) */
X    char *command;	/* only this command (unless == NULL) */
X};
X
X/* routines defined by the machine dependent module */
X
Xchar *format_header();
Xchar *format_next_process();
X
X/* non-int routines typically used by the machine dependent module */
Xchar *printable();
END_OF_FILE
if test 1305 -ne `wc -c <'machine.h'`; then
    echo shar: \"'machine.h'\" unpacked with wrong size!
fi
# end of 'machine.h'
fi
if test -f 'machine/m_386bsd.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machine/m_386bsd.man'\"
else
echo shar: Extracting \"'machine/m_386bsd.man'\" \(194 characters\)
sed "s/^X//" >'machine/m_386bsd.man' <<'END_OF_FILE'
X.SH "386BSD NOTES"
XThe 386BSD port was adapted by Steve Hocking from a module 
Xoriginally written by Christos Zoulas.  The port was later updated
Xby Andrew Herbert (andrew@werple.apana.org.au).
END_OF_FILE
if test 194 -ne `wc -c <'machine/m_386bsd.man'`; then
    echo shar: \"'machine/m_386bsd.man'\" unpacked with wrong size!
fi
# end of 'machine/m_386bsd.man'
fi
if test -f 'machine/m_bsd44.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machine/m_bsd44.man'\"
else
echo shar: Extracting \"'machine/m_bsd44.man'\" \(138 characters\)
sed "s/^X//" >'machine/m_bsd44.man' <<'END_OF_FILE'
X.SH "4.4 BSD DIFFERENCES"
XThe 4.4 BSD port is said to work at least as well as ps does.
X
XThe 4.4 BSD port was written by Christos Zoulas.
END_OF_FILE
if test 138 -ne `wc -c <'machine/m_bsd44.man'`; then
    echo shar: \"'machine/m_bsd44.man'\" unpacked with wrong size!
fi
# end of 'machine/m_bsd44.man'
fi
if test -f 'machine/m_bsd44a.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machine/m_bsd44a.man'\"
else
echo shar: Extracting \"'machine/m_bsd44a.man'\" \(150 characters\)
sed "s/^X//" >'machine/m_bsd44a.man' <<'END_OF_FILE'
X.SH "4.4 BSD DIFFERENCES"
XThe 4.4 BSD alpha port is said to work at least as well as ps does.
X
XThe 4.4 BSD alpha port was written by Christos Zoulas.
END_OF_FILE
if test 150 -ne `wc -c <'machine/m_bsd44a.man'`; then
    echo shar: \"'machine/m_bsd44a.man'\" unpacked with wrong size!
fi
# end of 'machine/m_bsd44a.man'
fi
if test -f 'machine/m_dgux.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machine/m_dgux.man'\"
else
echo shar: Extracting \"'machine/m_dgux.man'\" \(977 characters\)
sed "s/^X//" >'machine/m_dgux.man' <<'END_OF_FILE'
X.SH "DG/UX 5.4 DIFFERENCES"
XThe WCPU and SIZE columns are not shown, nor is the "last pid" display, as
Xthis information is not available from the kernel.
XA "processor utilization" column is added, with the heading C.  This number
Xreflects a process' relative interactivity, represented by an integer from
X0 to 7.  A process with 7 is highly interactive.  A process with 0 is not
Xconsidered interactive, but uses mostly CPU resources.
XThe "nice" processor time is not shown, but a "io_wait" processor state is
Xadded, represented the time spent waiting on I/O operations.  This is
Xcurrently always set to zero.
X
XProcess are considered "idle" unless they are in "run" or "wait" state.
XProcess are considered to be "system" processes if they have uid=0 and
Xppid=1.
XPercent CPU is not maintained by the kernel, and has to be calculated by
Xtop, by dividing the difference in system+user time by the delay period.
X
XThe DG/UX 5.4 port was written by Mike Williams <mike@inform.co.nz>.
END_OF_FILE
if test 977 -ne `wc -c <'machine/m_dgux.man'`; then
    echo shar: \"'machine/m_dgux.man'\" unpacked with wrong size!
fi
# end of 'machine/m_dgux.man'
fi
if test -f 'machine/m_dynix.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machine/m_dynix.man'\"
else
echo shar: Extracting \"'machine/m_dynix.man'\" \(319 characters\)
sed "s/^X//" >'machine/m_dynix.man' <<'END_OF_FILE'
X.SH "DYNIX DIFFERENCES"
XOne the Sequent DYNIX operating system, there is a distinction between runable
Xand running on a processor.  The STATE column reflects this by showing "run"
Xwhen the process is runable, and "RUN" when the process is actually running
Xon a processor.
X
XThe DYNIX port was written by Daniel Trinkle.
END_OF_FILE
if test 319 -ne `wc -c <'machine/m_dynix.man'`; then
    echo shar: \"'machine/m_dynix.man'\" unpacked with wrong size!
fi
# end of 'machine/m_dynix.man'
fi
if test -f 'machine/m_hpux9.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machine/m_hpux9.man'\"
else
echo shar: Extracting \"'machine/m_hpux9.man'\" \(463 characters\)
sed "s/^X//" >'machine/m_hpux9.man' <<'END_OF_FILE'
X.SH "HPUX 9 INFORMATION"
XUnder HP/UX 9, the kernel symbol _ccpu was eliminated.  The author
Xbelieve that _cexp is a suitable substitute, but cannot be positive.
XThis seems to be confirmed by the fact that information produced using
Xthis assumption correlates well with that produced by HP's version of top.
X
XThis port was adapted from the port for HP/UX version 8 (written by
XChristos Zoulas).  The adaptation was performed by Kevin Schmidt
X<kevin@mcl.ucsb.edu>.
END_OF_FILE
if test 463 -ne `wc -c <'machine/m_hpux9.man'`; then
    echo shar: \"'machine/m_hpux9.man'\" unpacked with wrong size!
fi
# end of 'machine/m_hpux9.man'
fi
if test -f 'machine/m_sunos4.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machine/m_sunos4.man'\"
else
echo shar: Extracting \"'machine/m_sunos4.man'\" \(1281 characters\)
sed "s/^X//" >'machine/m_sunos4.man' <<'END_OF_FILE'
X.SH "SUNOS 4 DIFFERENCES"
XOn multiprocessor machines, the amount of time the processors spend in
Xa spin lock is displayed along with the other processor state
Xpercentages.  The percentages shown for processor states are averages
Xacross all processors.  A process in run state also has its current
Xprocessor displayed in the STATE column, for example "run/2" indicates
Xrunning on processor 2.  There is an extra column in the process
Xdisplay indicating which processor each running process is assigned
Xto.  Information about physical memory is displayed on the memory
Xstatus line, but information about virtual memory is not available.
X
XDue to incompatabilities in kernel data structures, a top executable
Xcompiled on a Sun 4 multiprocessor architecture machine (sun4m) will
Xnot run correctly on a uniprocessor architecture machine (sun4), and
Xvice versa.  You will have to compile and maintain separate executables
Xfor these architectures.  Yeah, I don't like it either.
X
XSome processes may show up with a resident set size (RES column) larger
Xthan total virtual memory size (SIZE column).  This seems odd at first,
Xbut is a consequence of shared libraries:  shared memory is counted as
Xresident but is not counted in total size.
X
XThe SunOS 4 port was written by William LeFebvre.
END_OF_FILE
if test 1281 -ne `wc -c <'machine/m_sunos4.man'`; then
    echo shar: \"'machine/m_sunos4.man'\" unpacked with wrong size!
fi
# end of 'machine/m_sunos4.man'
fi
if test -f 'machine/m_sunos5.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machine/m_sunos5.man'\"
else
echo shar: Extracting \"'machine/m_sunos5.man'\" \(333 characters\)
sed "s/^X//" >'machine/m_sunos5.man' <<'END_OF_FILE'
X.SH "SUNOS 5 NOTES"
XThe SunOS 5 (Solaris 2) port was written by Torsten Kasch,
X<torsten@techfak.uni-bielefeld.de>.  Support for multi-cpu,
Xcalculation of CPU% and memory stats provided by
XRobert Boucher <boucher@sofkin.ca>, Marc Cohen <marc@aai.com>, 
XCharles Hedrick <hedrick@geneva.rutgers.edu>, and
XWilliam L. Jones <jones@chpc>.
END_OF_FILE
if test 333 -ne `wc -c <'machine/m_sunos5.man'`; then
    echo shar: \"'machine/m_sunos5.man'\" unpacked with wrong size!
fi
# end of 'machine/m_sunos5.man'
fi
if test -f 'machine/m_svr4.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machine/m_svr4.man'\"
else
echo shar: Extracting \"'machine/m_svr4.man'\" \(243 characters\)
sed "s/^X//" >'machine/m_svr4.man' <<'END_OF_FILE'
X.SH "SVR4 CREDITS"
XThe SVR4 port was initially written by Andrew Herbert.  He was guided by a SVR4
Xport of top version 2.1 which was done by Andy Crump (andyc@bucky.intel.com).
XRobert Boucher (boucher@sofkin.ca) adapted it to top version 3.1.
END_OF_FILE
if test 243 -ne `wc -c <'machine/m_svr4.man'`; then
    echo shar: \"'machine/m_svr4.man'\" unpacked with wrong size!
fi
# end of 'machine/m_svr4.man'
fi
if test -f 'machine/m_svr42.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machine/m_svr42.man'\"
else
echo shar: Extracting \"'machine/m_svr42.man'\" \(118 characters\)
sed "s/^X//" >'machine/m_svr42.man' <<'END_OF_FILE'
X.SH "SVR42 CREDITS"
XThe SVR42 port was hacked by David Cutter from the SVR4 port initially
Xwritten by Andrew Herbert.
END_OF_FILE
if test 118 -ne `wc -c <'machine/m_svr42.man'`; then
    echo shar: \"'machine/m_svr42.man'\" unpacked with wrong size!
fi
# end of 'machine/m_svr42.man'
fi
if test -f 'machine/m_umax.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'machine/m_umax.man'\"
else
echo shar: Extracting \"'machine/m_umax.man'\" \(1024 characters\)
sed "s/^X//" >'machine/m_umax.man' <<'END_OF_FILE'
X.SH "MULTIMAX DIFFERENCES"
XThe umax operating system does not assign process ids sequentially, so
Xthere is no "last pid" display.  Process state names are: run, exec,
Xwait, event, start, stop.  Information about physical memory is
Xdisplayed on the memory status line, but information about virtual
Xmemory is not available.  WCPU is not displayed.  Percent CPU is
Xcalculated ove the entire life of the process and is a measure of the
Xpercentage of the process's life time spent running.  This is very
Xdifferent from the typical Unix measure of percent cpu, but is the
Xbest that can be done with the information available.  Also, no
Xattempt is made to determine if a process is currently "idle", thus
Xthe -I flag is assumed to always be true (idle processes are displayed).
X
XThe multimax port is not thorough and not complete.  It was done more
Xas an exercise in porting top than as an effort to create something
Xuseful.  Currently cpu state percentages are not calculated.
X
XThe Multimax port was written by William LeFebvre.
END_OF_FILE
if test 1024 -ne `wc -c <'machine/m_umax.man'`; then
    echo shar: \"'machine/m_umax.man'\" unpacked with wrong size!
fi
# end of 'machine/m_umax.man'
fi
if test -f 'metatop' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'metatop'\"
else
echo shar: Extracting \"'metatop'\" \(1331 characters\)
sed "s/^X//" >'metatop' <<'END_OF_FILE'
X#!/bin/sh
X#
X# Top is very sensitive to differences in the kernel, so much so that an
X# executable created on one sub-architecture may not work on others.  It
X# is also quite common for a minor OS revision to require recompilation of
X# top.  Both of these problems are especially prevalent on Suns.  For
X# example, a top executable made under SunOS 4.1.1 will not run correctly
X# under SunOS 4.1.2, and vice versa.  "metatop" attempts to solve this
X# problem by choosing one of several possible top executables to run then
X# executing it.
X#
X# To use metatop your operating system needs to have the command "uname"
X# as part of the standard OS release.  MAKE SURE IT DOES before proceeding.
X# It will try to execute the command "top-`uname -m`-`uname -r`"  For 
X# example, on a sparcstation 1 running SunOS 4.1.1, it will try to run
X# "top-sun4c-4.1.1".
X#
X# INSTALLATION is easy.  Just compile top as normal.  Then use the command
X# "make metainstall" (on the same machine!) instead of the usual.  "make"
X# will insure that this shell script is installed correctly then will install
X# the most recently made top executable with the correct name.  Remember:
X# you will need to "make clean" and "make metainstall" on every different
X# combination of sub-architecture and OS version that you have.
X#
Xexec top-`uname -m`-`uname -r` "$@"
END_OF_FILE
if test 1331 -ne `wc -c <'metatop'`; then
    echo shar: \"'metatop'\" unpacked with wrong size!
fi
chmod +x 'metatop'
# end of 'metatop'
fi
if test -f 'os.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'os.h'\"
else
echo shar: Extracting \"'os.h'\" \(602 characters\)
sed "s/^X//" >'os.h' <<'END_OF_FILE'
X#include <sys/types.h>
X#include <sys/param.h>	/* This defines BSD */
X#if defined(BSD) && !defined(BSD4_4)
X# include <stdio.h>
X# include <strings.h>
X# define strchr(a, b)		index((a), (b))
X# define strrchr(a, b)		rindex((a), (b))
X# define memcpy(a, b, c)	bcopy((b), (a), (c))
X# define memzero(a, b)		bzero((a), (b))
X# define memcmp(a, b, c)	bcmp((a), (b), (c))
X  typedef int sigret_t;
X#else 
X# include <stdio.h>
X# define setbuffer(f, b, s)	setvbuf((f), (b), (b) ? _IOFBF : _IONBF, (s))
X# include <string.h>
X# include <memory.h>
X# define memzero(a, b)		memset((a), 0, (b))
X  typedef void sigret_t;
X#endif
END_OF_FILE
if test 602 -ne `wc -c <'os.h'`; then
    echo shar: \"'os.h'\" unpacked with wrong size!
fi
# end of 'os.h'
fi
if test -f 'patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patchlevel.h'\"
else
echo shar: Extracting \"'patchlevel.h'\" \(21 characters\)
sed "s/^X//" >'patchlevel.h' <<'END_OF_FILE'
X#define PATCHLEVEL 2
END_OF_FILE
if test 21 -ne `wc -c <'patchlevel.h'`; then
    echo shar: \"'patchlevel.h'\" unpacked with wrong size!
fi
# end of 'patchlevel.h'
fi
if test -f 'screen.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screen.h'\"
else
echo shar: Extracting \"'screen.h'\" \(991 characters\)
sed "s/^X//" >'screen.h' <<'END_OF_FILE'
X/*
X *  top - a top users display for Unix 4.2
X *
X *  This file contains all the definitions necessary to use the hand-written
X *  screen package in "screen.c"
X */
X
X#define TCputs(str)	tputs(str, 1, putstdout)
X#define putcap(str)	(void)((str) != NULL ? TCputs(str) : 0)
X#define Move_to(x, y)	TCputs(tgoto(cursor_motion, x, y))
X
X/* declare return values for termcap functions */
Xchar *tgetstr();
Xchar *tgoto();
X
Xextern char ch_erase;		/* set to the user's erase character */
Xextern char ch_kill;		/* set to the user's kill  character */
Xextern char smart_terminal;     /* set if the terminal has sufficient termcap
X				   capabilities for normal operation */
X
X/* These are some termcap strings for use outside of "screen.c" */
Xextern char *cursor_motion;
Xextern char *clear_line;
Xextern char *clear_to_end;
X
X/* rows and columns on the screen according to termcap */
Xextern int  screen_length;
Xextern int  screen_width;
X
X/* a function that puts a single character on stdout */
Xint putstdout();
END_OF_FILE
if test 991 -ne `wc -c <'screen.h'`; then
    echo shar: \"'screen.h'\" unpacked with wrong size!
fi
# end of 'screen.h'
fi
if test -f 'sigconv.awk' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sigconv.awk'\"
else
echo shar: Extracting \"'sigconv.awk'\" \(1098 characters\)
sed "s/^X//" >'sigconv.awk' <<'END_OF_FILE'
XBEGIN		{
X		    nsig = 0;
X		    j = 0;
X		    print "/* This file was automatically generated */"
X		    print "/* by the awk script \"sigconv.awk\".      */\n"
X		    print "struct sigdesc {"
X		    print "    char *name;"
X		    print "    int  number;"
X		    print "};\n"
X		    print "struct sigdesc sigdesc[] = {"
X		}
X
X/^#define[ \t][ \t]*SIG[A-Z]/	{
X
X				    j = sprintf("%d", $3);
X				    str = $2;
X
X				    if (nsig < j) 
X					nsig = j;
X
X				    siglist[j] = sprintf("\"%s\",\t%2d,", \
X						substr(str, 4), j);
X				}
X/^#[ \t]*define[ \t][ \t]*SIG[A-Z]/	{
X
X				    j = sprintf("%d", $4);
X				    str = $3;
X
X				    if (nsig < j)
X					nsig = j;
X
X				    siglist[j] = sprintf("\"%s\",\t%2d,", \
X						substr(str, 4), j);
X				}
X/^#[ \t]*define[ \t][ \t]*_SIG[A-Z]/	{
X
X				    j = sprintf("%d", $4);
X				    str = $3;
X
X				    if (nsig < j)
X					nsig = j;
X
X				    siglist[j] = sprintf("\"%s\",\t%2d,", \
X					    substr(str, 5), j);
X				}
X
XEND				{
X				    for (n = 1; n <= nsig; n++) 
X					if (siglist[n] != "")
X					    printf("    %s\n", siglist[n]);
X
X				    printf("    NULL,\t 0\n};\n");
X				}
END_OF_FILE
if test 1098 -ne `wc -c <'sigconv.awk'`; then
    echo shar: \"'sigconv.awk'\" unpacked with wrong size!
fi
# end of 'sigconv.awk'
fi
if test -f 'top.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'top.h'\"
else
echo shar: Extracting \"'top.h'\" \(716 characters\)
sed "s/^X//" >'top.h' <<'END_OF_FILE'
X/*
X *  Top - a top users display for Berkeley Unix
X *
X *  General (global) definitions
X */
X
X/* Current major version number */
X#define VERSION		3
X
X/* Number of lines of header information on the standard screen */
X#define Header_lines	6
X
X/* Number of columns needed for display */
X#define Display_width	80
X
X/* Log base 2 of 1024 is 10 (2^10 == 1024) */
X#define LOG1024		10
X
Xchar *itoa();
Xchar *itoa7();
X
Xchar *version_string();
X
X/* Special atoi routine returns either a non-negative number or one of: */
X#define Infinity	-1
X#define Invalid		-2
X
X/* maximum number we can have */
X#define Largest		0x7fffffff
X
X/*
X * The entire display is based on these next numbers being defined as is.
X */
X
X#define NUM_AVERAGES    3
X
END_OF_FILE
if test 716 -ne `wc -c <'top.h'`; then
    echo shar: \"'top.h'\" unpacked with wrong size!
fi
# end of 'top.h'
fi
if test -f 'top.local.H' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'top.local.H'\"
else
echo shar: Extracting \"'top.local.H'\" \(2458 characters\)
sed "s/^X//" >'top.local.H' <<'END_OF_FILE'
X/*
X *  Top - a top users display for Berkeley Unix
X *
X *  Definitions for things that might vary between installations.
X */
X
X/*
X *  The space command forces an immediate update.  Sometimes, on loaded
X *  systems, this update will take a significant period of time (because all
X *  the output is buffered).  So, if the short-term load average is above
X *  "LoadMax", then top will put the cursor home immediately after the space
X *  is pressed before the next update is attempted.  This serves as a visual
X *  acknowledgement of the command.  On Suns, "LoadMax" will get multiplied by
X *  "FSCALE" before being compared to avenrun[0].  Therefore, "LoadMax"
X *  should always be specified as a floating point number.
X */
X#ifndef LoadMax
X#define LoadMax  %LoadMax%
X#endif
X
X/*
X *  "Table_size" defines the size of the hash tables used to map uid to
X *  username.  The number of users in /etc/passwd CANNOT be greater than
X *  this number.  If the error message "table overflow: too many users"
X *  is printed by top, then "Table_size" needs to be increased.  Things will
X *  work best if the number is a prime number that is about twice the number
X *  of lines in /etc/passwd.
X */
X#ifndef Table_size
X#define Table_size	%TableSize%
X#endif
X
X/*
X *  "Nominal_TOPN" is used as the default TOPN when Default_TOPN is Infinity
X *  and the output is a dumb terminal.  If we didn't do this, then
X *  installations who use a default TOPN of Infinity will get every
X *  process in the system when running top on a dumb terminal (or redirected
X *  to a file).  Note that Nominal_TOPN is a default:  it can still be
X *  overridden on the command line, even with the value "infinity".
X */
X#ifndef Nominal_TOPN
X#define Nominal_TOPN	%NominalTopn%
X#endif
X
X#ifndef Default_TOPN
X#define Default_TOPN	%topn%
X#endif
X
X#ifndef Default_DELAY
X#define Default_DELAY	%delay%
X#endif
X
X/*
X *  If the local system's getpwnam interface uses random access to retrieve
X *  a record (i.e.: 4.3 systems, Sun "yellow pages"), then defining
X *  RANDOM_PW will take advantage of that fact.  If RANDOM_PW is defined,
X *  then getpwnam is used and the result is cached.  If not, then getpwent
X *  is used to read and cache the password entries sequentially until the
X *  desired one is found.
X *
X *  We initially set RANDOM_PW to something which is controllable by the
X *  Configure script.  Then if its value is 0, we undef it.
X */
X
X#define RANDOM_PW	%random%
X#if RANDOM_PW == 0
X#undef RANDOM_PW
X#endif
END_OF_FILE
if test 2458 -ne `wc -c <'top.local.H'`; then
    echo shar: \"'top.local.H'\" unpacked with wrong size!
fi
# end of 'top.local.H'
fi
if test -f 'username.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'username.c'\"
else
echo shar: Extracting \"'username.c'\" \(4865 characters\)
sed "s/^X//" >'username.c' <<'END_OF_FILE'
X/*
X *  Top users/processes display for Unix
X *  Version 3
X *
X *  This program may be freely redistributed,
X *  but this entire comment MUST remain intact.
X *
X *  Copyright (c) 1984, 1989, William LeFebvre, Rice University
X *  Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
X */
X
X/*
X *  Username translation code for top.
X *
X *  These routines handle uid to username mapping.
X *  They use a hashing table scheme to reduce reading overhead.
X *  For the time being, these are very straightforward hashing routines.
X *  Maybe someday I'll put in something better.  But with the advent of
X *  "random access" password files, it might not be worth the effort.
X *
X *  Changes to these have been provided by John Gilmore (gnu@toad.com).
X *
X *  The hash has been simplified in this release, to avoid the
X *  table overflow problems of previous releases.  If the value
X *  at the initial hash location is not right, it is replaced
X *  by the right value.  Collisions will cause us to call getpw*
X *  but hey, this is a cache, not the Library of Congress.
X *  This makes the table size independent of the passwd file size.
X */
X
X#include <stdio.h>
X#include <pwd.h>
X
X#include "top.local.h"
X#include "utils.h"
X
Xstruct hash_el {
X    int  uid;
X    char name[9];
X};
X
X#define    is_empty_hash(x)	(hash_table[x].name[0] == 0)
X
X/* simple minded hashing function */
X#define    hashit(i)	((i) % Table_size)
X
X/* K&R requires that statically declared tables be initialized to zero. */
X/* We depend on that for hash_table and YOUR compiler had BETTER do it! */
Xstruct hash_el hash_table[Table_size];
X
Xinit_hash()
X
X{
X    /*
X     *  There used to be some steps we had to take to initialize things.
X     *  We don't need to do that anymore, but we will leave this stub in
X     *  just in case future changes require initialization steps.
X     */
X}
X
Xchar *username(uid)
X
Xregister int uid;
X
X{
X    register int hashindex;
X
X    hashindex = hashit(uid);
X    if (is_empty_hash(hashindex) || (hash_table[hashindex].uid != uid))
X    {
X	/* not here or not right -- get it out of passwd */
X	hashindex = get_user(uid);
X    }
X    return(hash_table[hashindex].name);
X}
X
Xint userid(username)
X
Xchar *username;
X
X{
X    struct passwd *pwd;
X
X    /* Eventually we want this to enter everything in the hash table,
X       but for now we just do it simply and remember just the result.
X     */
X
X    if ((pwd = getpwnam(username)) == NULL)
X    {
X	return(-1);
X    }
X
X    /* enter the result in the hash table */
X    enter_user(pwd->pw_uid, username, 1);
X
X    /* return our result */
X    return(pwd->pw_uid);
X}
X
Xint enter_user(uid, name, wecare)
X
Xregister int  uid;
Xregister char *name;
Xint wecare;		/* 1 = enter it always, 0 = nice to have */
X
X{
X    register int hashindex;
X
X#ifdef DEBUG
X    fprintf(stderr, "enter_hash(%d, %s, %d)\n", uid, name, wecare);
X#endif
X
X    hashindex = hashit(uid);
X
X    if (!is_empty_hash(hashindex))
X    {
X	if (!wecare)
X	    return 0;		/* Don't clobber a slot for trash */
X	if (hash_table[hashindex].uid == uid)
X	    return(hashindex);	/* Fortuitous find */
X    }
X
X    /* empty or wrong slot -- fill it with new value */
X    hash_table[hashindex].uid = uid;
X    (void) strncpy(hash_table[hashindex].name, name, 8);
X    return(hashindex);
X}
X
X/*
X * Get a userid->name mapping from the system.
X * If the passwd database is hashed (#define RANDOM_PW), we
X * just handle this uid.  Otherwise we scan the passwd file
X * and cache any entries we pass over while looking.
X */
X
Xint get_user(uid)
X
Xregister int uid;
X
X{
X    struct passwd *pwd;
X
X#ifdef RANDOM_PW
X    /* no performance penalty for using getpwuid makes it easy */
X    if ((pwd = getpwuid(uid)) != NULL)
X    {
X	return(enter_user(pwd->pw_uid, pwd->pw_name, 1));
X    }
X#else
X
X    int from_start = 0;
X
X    /*
X     *  If we just called getpwuid each time, things would be very slow
X     *  since that just iterates through the passwd file each time.  So,
X     *  we walk through the file instead (using getpwent) and cache each
X     *  entry as we go.  Once the right record is found, we cache it and
X     *  return immediately.  The next time we come in, getpwent will get
X     *  the next record.  In theory, we never have to read the passwd file
X     *  a second time (because we cache everything we read).  But in
X     *  practice, the cache may not be large enough, so if we don't find
X     *  it the first time we have to scan the file a second time.  This
X     *  is not very efficient, but it will do for now.
X     */
X
X    while (from_start++ < 2)
X    {
X	while ((pwd = getpwent()) != NULL)
X	{
X	    if (pwd->pw_uid == uid)
X	    {
X		return(enter_user(pwd->pw_uid, pwd->pw_name, 1));
X	    }
X	    (void) enter_user(pwd->pw_uid, pwd->pw_name, 0);
X	}
X	/* try again */
X	setpwent();
X    }
X#endif
X    /* if we can't find the name at all, then use the uid as the name */
X    return(enter_user(uid, itoa7(uid), 1));
X}
END_OF_FILE
if test 4865 -ne `wc -c <'username.c'`; then
    echo shar: \"'username.c'\" unpacked with wrong size!
fi
# end of 'username.c'
fi
if test -f 'utils.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils.h'\"
else
echo shar: Extracting \"'utils.h'\" \(483 characters\)
sed "s/^X//" >'utils.h' <<'END_OF_FILE'
X/*
X *  Top users/processes display for Unix
X *  Version 3
X *
X *  This program may be freely redistributed,
X *  but this entire comment MUST remain intact.
X *
X *  Copyright (c) 1984, 1989, William LeFebvre, Rice University
X *  Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
X */
X
X/* prototypes for functions found in utils.c */
X
Xint atoiwi();
Xchar *itoa();
Xchar *itoa7();
Xint digits();
Xchar *strecpy();
Xchar **argparse();
Xlong percentages();
Xchar *errmsg();
END_OF_FILE
if test 483 -ne `wc -c <'utils.h'`; then
    echo shar: \"'utils.h'\" unpacked with wrong size!
fi
# end of 'utils.h'
fi
if test -f 'version.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'version.c'\"
else
echo shar: Extracting \"'version.c'\" \(474 characters\)
sed "s/^X//" >'version.c' <<'END_OF_FILE'
X/*
X *  Top users/processes display for Unix
X *  Version 3
X *
X *  This program may be freely redistributed,
X *  but this entire comment MUST remain intact.
X *
X *  Copyright (c) 1984, 1989, William LeFebvre, Rice University
X *  Copyright (c) 1989, 1990, 1992, William LeFebvre, Northwestern University
X */
X
X#include "top.h"
X#include "patchlevel.h"
X
Xstatic char version[16];
X
Xchar *version_string()
X
X{
X    sprintf(version, "%d.%d", VERSION, PATCHLEVEL);
X    return(version);
X}
END_OF_FILE
if test 474 -ne `wc -c <'version.c'`; then
    echo shar: \"'version.c'\" unpacked with wrong size!
fi
# end of 'version.c'
fi
echo shar: End of archive 1 \(of 13\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 13 archives.
    echo "Now read README and INSTALL, then run Configure"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
