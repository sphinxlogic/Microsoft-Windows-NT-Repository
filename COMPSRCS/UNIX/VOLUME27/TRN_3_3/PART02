Newsgroups: comp.sources.unix
From: davison@borland.com (Wayne Davison)
Subject: v27i095: trn-3.3 - threaded newsreader based on RN, V3.3, Part02/12
References: <1.754431075.7231@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: davison@borland.com (Wayne Davison)
Posting-Number: Volume 27, Issue 95
Archive-Name: trn-3.3/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 12)."
# Contents:  HACKERSGUIDE HINTS INSTALL Makefile.SH Pnews.1 Rnmail.1
#   Speller.SH artcheck.c artio.c backpage.c cache.h final.c head.h
#   init.c makedepend.SH newsetup.SH newsgroups.SH ngdata.c ngsrch.c
#   nntpclient.c only.c rthread.h strftime.c
# Wrapped by vixie@gw.home.vix.com on Sun Nov 21 01:14:00 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'HACKERSGUIDE' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HACKERSGUIDE'\"
else
echo shar: Extracting \"'HACKERSGUIDE'\" \(4463 characters\)
sed "s/^X//" >'HACKERSGUIDE' <<'END_OF_FILE'
XHacking Notes from the hand of Larry Wall with respect to rn, trn's ancestor,
Xmodified by Wayne Davison to reflect the current state of trn.
X
XIf you aren't interested in mucking with the innards of trn, don't read this.
X
XIn the interests of both space and time optimization, things are done inside
Xtrn that don't always conform to the highest ideals of programming.  To the
Xextent I felt it was practical, I've tried to conform to good programming
Xpractice, but you must realize that my goal was to make a better mousetrap,
Xso certain conscious tradeoffs were made in the design of trn right from the
Xstart.  In particular, if you want to hack on trn (and I wouldn't blame you,
Xit's fun), beware of the following:
X  
X  * buf and cmd_buf are reused all over the place.  11-squishing is a good
X    term for it.  No, I'm on a Vax now, but I've been there.
X
X  * The article header is parsed on the fly, while it is being displayed.
X    In fact, practically everything is done on the fly within the article
X    display loop, and there are plenty of state variables.  The information
X    required to backup pages is not stored in memory, except for 1 buffer's
X    worth.
X
X  * Lots of contortions are gone through to avoid using static memory, or
X    allocating unnecessary memory, or losing track of allocated memory,
X    while at the same time allowing .newsrc lines and header lines to be
X    ANY length up to the amount of memory you have.  Trn spends a great deal
X    of effort being lazy.  Do not use a static buffer when you can use
X    growstr(). 
X
X  * Lots of contortions are gone through to try to do things when people
X    aren't waiting, or have only been waiting a very short time.  Guessing
X    the next article to be opened and opening it, searching ahead for the
X    next article with the same subject, delaying the look up of the number
X    of articles in a newsgroup, writing the rest of the page while the
X    reader is examining the header, cacheing up subjects while the user
X    is reading, checkpointing the .newsrc only while the reader is in the
X    middle of an interesting article, are some of the strategies employed.
X  
X  * There are plenty of goto's.  Most of them involve going back to reprompt,
X    to reask for input, or to just plain do the unstructured things people
X    want to do when they are glaring at a terminal.  If they bother you
X    too much, just think of trn as a big state machine.  If they don't bother
X    you at all, I don't want you hacking on trn.
X
X  * Put all includes at the front of the file, before the first function,
X    or makedepend will not work right.  I could relax this, but makedepend
X    would take about 5 times longer to run.
X
XIn general then, feel free to hack on trn.  Just don't broadcast untested
Xpatches to the net.  Remember that there are people with limited address
Xspaces and limited cpu cycles.  If you add a wonderful new feature and
Xwant to publish a patch, put #ifdef's around it so that people who don't
Xwant it or can't afford it can work around it.  THIS MEANS YOU.  We don't
Xneed 57 varieties of mutually incompatible and incomprehensible trn floating
Xabout the net.  Consider telling me about your patch so that I can consider
Xincluding it in the standard version.  A COMPLETE PATCH TAKES INTO ACCOUNT
XSYSTEM DEPENDENCIES AS DETERMINED BY THE CONFIGURE SCRIPT.
X
X* Don't use ints where trn uses typedefs, in particular, for article numbers.
X* Don't use %d anywhere that someone might need a %ld.  (Just because YOU
X    typedefed it as an int doesn't mean someone else won't need a long.)
X* Don't use %D, that's archaic.
X* Put FLUSHes after printf()s, fputs()es and putchar('\n')s for our poor
X    brethern and sistern without line buffering.
X* Declare the type of every function.  Use void, even if your C compiler
X    doesn't.
X* Follow the style that trn already uses!  This is my pet peeve.  Well, one
X    of them, anyway.  I follow other people's strange styles when modifying
X    their programs, so I'd be much obliged if you did likewise.
X* Use lint.
X* Use RCS.  Start a new branch, like 4.4.[2-9].  (I will use 4.4.1 myself.)
X* Be structured wherever it doesn't interfere with practicality.
X* Long live paranoid programming.  The rest of the program is out to get you.
X    The world is out to destroy the program, not to mention the .newsrc.
X    And then there's always bitrot...
X* Stop reading this lugubrious trash and start thinking for yourself.
X* Thank you and good night.
END_OF_FILE
if test 4463 -ne `wc -c <'HACKERSGUIDE'`; then
    echo shar: \"'HACKERSGUIDE'\" unpacked with wrong size!
fi
# end of 'HACKERSGUIDE'
fi
if test -f 'HINTS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HINTS'\"
else
echo shar: Extracting \"'HINTS'\" \(2999 characters\)
sed "s/^X//" >'HINTS' <<'END_OF_FILE'
XHere's some helpful hints for getting the most out of trn:
X
XThe 'X' command in the selector (kinda like catchup/yes) can be made the
Xdefault action on the last page of selections by using the command-line
Xoption:  -XX.  This lets you browse all the pages, making selections as you
Xgo, and then mark everything that was not selected as read when you press
Xspace at the last page.
X----------
XIf you like to select a little, read a little, and then select a little
Xmore, try using the command-line option:  -XDD.  This makes the 'D' command
Xthe default on all pages of the selector.  Thus you can select the things
Xyou want to read on the current page, press space, and you will read the
Xselected articles immediately (if there were any).  All other articles on
Xthe current page will be marked as read.
X----------
XKeep in mind that you can create a file called .trninit and point trn at
Xit by definining the environment variable TRNINIT.  Depending on your shell,
Xyou might use "setenv TRNINIT ~/.trninit" or some other type of assignment
X(put the definition in your shell's rc file).  Then put all your command-line
Xoptions in this file.
X----------
XI like to redefine the 'u' keys in the following way:  'u' visits the "Set
Xunread?" prompt (except in the thread selector), 'U' goes directly to the
Xalready-read article selector, and Ctrl-U unsubscribes from the group (even
Xwhile in the thread selector).  Put the following 3 macros in your .rnmac
Xfile to accomplish this (or change RNMACROS to .trnmac and put them there):
X
Xu	%(%m=[aefnp]?U:u)
XU	%(%m=[aefnp]?U+:U)
X^U	%(%m=t?+u:u)
X----------
XI like to have the '=' command start the article selector and the '+'
Xcommand to start the thread selector (or subject selector if the group
Xisn't threaded).  You can accomplish this by adding the following macros
Xto your .rnmac file:
X
X=	%(%m=[aep]?_a:=)
X+	%(%m=[aep]?_T:+)
X----------
XIf you like to be able to move forward/backward by article number more
Xoften than you need to search by subject, redefine ^N and ^P to be _N
Xand _P by putting these lines into your .rnmac file:
X
X^P	%(%m=[aep]?_P:^P)
X^N	%(%m=[aep]?_N:^N)
X----------
XIf you like the way that 'q' worked in the thread selector in trn 1.x, put
Xthe following macro in your .rnmac file:
X
Xq	%(%m=t?+:q)
X----------
XIf you would like the 'f' command to always answer yes to the "Are you start-
Xing an unreleated topic?" question, put this line into your .rnmac file:
X
Xf	%(%m=[ap]?fy^m:f)
X----------
XIf you want to be able to save your shar headers in a file as they are
Xextracted and you have access to "unshar" (a program that can extract
Xshar files while saving the headers in UNSHAR.HDR), twiddle the external
Xextract command to send the entire article:
X
X-EEXSAVER="%e <%A"
X
Xand then point the UNSHAR variable at unshar instead of /bin/sh:
X
X-EUNSHAR="unshar -s"
X
XNote that this assumes that any other commands you execute with "e dir|command"
Xcan also handle the entire article as input (uuencoded and shipped files are
Xnot affected).
X----------
END_OF_FILE
if test 2999 -ne `wc -c <'HINTS'`; then
    echo shar: \"'HINTS'\" unpacked with wrong size!
fi
# end of 'HINTS'
fi
if test -f 'INSTALL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'INSTALL'\"
else
echo shar: Extracting \"'INSTALL'\" \(5006 characters\)
sed "s/^X//" >'INSTALL' <<'END_OF_FILE'
XInstallation Instructions for trn 3.0:
X
X1)  Decide what package you want to use to solve your news database
X    needs.  There's currently two supported by trn:  mthreads and
X    news overview.  Mthreads creates smaller files that load faster
X    each time you enter a group, however it is more taxing on your
X    cpu and disk bandwidth because it keeps the files in thread order.
X    Overview files are larger, but they are less taxing on your system
X    because the format is pretty "raw" and the files are maintained by
X    your news software (either a modified C news or INN 1.3 and above).
X    Though they load slower than .thread files, they have subject and
X    author headers that are not truncated (unlike mthreads headers)
X    which means that trn won't have to "freshen" these headers during
X    its idle time.  The final choice is to not store a database.  If
X    you go this route it will take significantly longer to start up
X    a group in threaded mode, but you could chose to read one or more
X    groups unthreaded.
X
X2)  If you are going to make a version of trn that uses NNTP to get its
X    news remotely, be sure you have installed some version of inews that
X    sends articles to your news server.  The reference NNTP (v1.5.11)
X    comes with a version of inews that you can use, and C news and INN
X    both have versions that can be used remotely.
X
X3)  Run Configure.  This will figure out various things about your system.
X    Some things Configure will figure out for itself, other things it will
X    ask you about.  It will then proceed to make config.h, config.sh, the
X    Makefile, and a bunch of shell scripts.  You might possibly have to
X    trim # comments from the front of Configure if your sh doesn't handle
X    them, but all other # comments will be taken care of.
X
X4)  Glance through config.h and common.h to make sure system dependencies
X    are correct.  Most of them should have been taken care of by running
X    the Configure script.
X
X    If you have any additional changes to make to the C definitions, they
X    can be done in the Makefile, in config.h, or in common.h.  If you have
X    strange mailboxes on your system you should modify mbox.saver to correctly
X    append an article to a mailbox or folder.
X
X    If you are on a machine with limited address space, you probably don't
X    want to be using trn.  Feel free to give it a try, though -- there are
X    some defines in common.h that can be turned off to try to make trn fit
X    (see the System Dependencies section).  You might run a "make depend"
X    afterward just to be safe.
X
X5)  make
X
X    This will attempt to make trn in the current directory.
X
X6)  make install
X
X    This will put trn, newsetup, newsgroups, Pnews, and Rnmail into a
X    public directory (normally /usr/local/bin), and put a number of
X    files into the private trn library (e.g. /usr/local/lib/trn).  It
X    also tries to put the trn man page in a reasonable place.
X
X7)  Read the manual entry before running trn, or at least read the file
X    NEW if you are already familiar with trn.  Those that are brand new
X    to trn can get a quick idea of what's different from rn by reading
X    the WHAT'S NEW section of the man page.  Also check out the HINTS
X    file for some ways to get the most out of using trn.
X
X8)  Try trn, and play with some of the switches (use -x and -X if you told
X    Configure to leave these options off by default).  Any options you find
X    that you want to make the default for everyone can be placed into the
X    INIT file in the trn library.  Personal defaults can be put in a file
X    and the environment variable TRNINIT defined to point to it.
X
X9)  Once trn is running ok, make sure any database software you've installed
X    is going ok and interfacing properly with trn.  Read the documentation
X    that comes with the package of your choosing.
X
X10) IMPORTANT!  Help save the world!  Communicate any problems and suggested
X    patches to Wayne Davison <davison@borland.com> so we can keep the world
X    in sync.  If you have a problem, there's someone else out there who
X    either has had or will have the same problem.  If the problem affects
X    regular rn, code, I will pass it on to Stan Barber.
X
X    If possible, send in patches such that the patch program will apply them.
X    Unified or regular context diffs are the best, then normal diffs.  Don't
X    send ed scripts--I've probably changed my copy since the version you have.
X
X    Watch for trn patches in news.software.readers.  Patches will always be
X    in the unified context diff format, for application by the patch program.
X    If you don't have a patch program that handles unified context diffs,
X    you'll probably want to get one (such as patch version 12g8).  Otherwise,
X    you can use the (included) filter "unipatch", which can be generated with
X    the command "make unipatch".  To apply patches, use the command:
X
X	unipatch <patchfile | patch -p
X
X12) If you are going to hack on trn, please refer to rn's HACKERSGUIDE first.
END_OF_FILE
if test 5006 -ne `wc -c <'INSTALL'`; then
    echo shar: \"'INSTALL'\" unpacked with wrong size!
fi
# end of 'INSTALL'
fi
if test -f 'Makefile.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.SH'\"
else
echo shar: Extracting \"'Makefile.SH'\" \(5843 characters\)
sed "s/^X//" >'Makefile.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X    '') . ./config.sh ;;
Xesac
Xecho "Extracting Makefile (with variable substitutions)"
X$cat >Makefile <<!GROK!THIS!
X# $Id: Makefile.SH,v 3.0 1992/03/01 02:13:32 davison Trn $
X#
X# This software is Copyright 1991 by Stan Barber. 
X#
X# Permission is hereby granted to copy, reproduce, redistribute or otherwise
X# use this software as long as: there is no monetary profit gained
X# specifically from the use or reproduction of this software, it is not
X# sold, rented, traded or otherwise marketed, and this copyright notice is
X# included prominently in any copy made. 
X#
X# The author make no claims as to the fitness or correctness of this software
X# for any use whatsoever, and it is provided as is. Any use of this software
X# is at the user's own risk. 
X# 
X
XCC = $cc
Xrnbin = $bin
Xrnibin = $installbin
Xrnlib = $privlib
Xrnilib = $installprivlib
Xmansrc = $mansrc
Xmanext = $manext
XCFLAGS = $optimize $ccflags
XLDFLAGS = $ldflags
X#NNTPNNTPFLAGS = $nntpflags
Xndirc = $ndirc
Xndiro = $ndiro
Xstrftimec = $strftimec
Xstrftimeo = $strftimeo
Xfilexp = $filexp
X
Xlibs = $libndir $termlib $jobslib -lm $libs
X!GROK!THIS!
X$cat >>Makefile <<'!NO!SUBS!'
Xpublic = trn newsetup newsgroups Pnews Rnmail
Xprivate = norm.saver mbox.saver makedir Pnews.header Speller artcheck $(nntp)
Xutil = makedepend newsnews
Xmanpages = trn.1 Pnews.1 Rnmail.1 newsetup.1 newsgroups.1
X#NNTPnntp=getactive
X#NNTPnntpsrc=nntpinit.c nntpclient.c nntp.c
X#NNTPnntpobj=nntpinit.o nntpclient.o nntp.o
X
Xh1 = addng.h art.h artio.h artsrch.h autosub.h backpage.h bits.h cache.h 
Xh2 = common.h decode.h final.h hash.h head.h help.h init.h intrp.h kfile.h
Xh3 = last.h ng.h ngdata.h ngsrch.h ngstuff.h only.h rcln.h rcstuff.h
Xh4 = respond.h rthread.h rt-mt.h rt-ov.h rt-page.h rt-process.h rt-select.h
Xh5 = rt-util.h rt-wumpus.h search.h sw.h term.h trn.h util.h
X
Xh = $(h1) $(h2) $(h3) $(h4) $(h5)
X
Xc1 = addng.c art.c artio.c artsrch.c autosub.c backpage.c bits.c cache.c
Xc2 = decode.c edit_dist.c final.c hash.c head.c help.c init.c intrp.c
Xc3 = kfile.c last.c $(ndirc) ng.c ngdata.c nghash.c ngsrch.c ngstuff.c
Xc4 = only.c rcln.c rcstuff.c respond.c rthread.c rt-mt.c rt-ov.c
Xc5 = rt-process.c rt-page.c rt-select.c rt-util.c rt-wumpus.c search.c
Xc6 = $(strftimec) sw.c term.c trn.c util.c unship.c uudecode.c
Xc7 = $(nntpsrc)
X
Xc = $(c1) $(c2) $(c3) $(c4) $(c5) $(c6) $(c7)
X
Xobj1 = addng.o art.o artio.o artsrch.o autosub.o backpage.o bits.o cache.o
Xobj2 = decode.o edit_dist.o final.o hash.o head.o help.o init.o intrp.o
Xobj3 = kfile.o last.o $(ndiro) ng.o ngdata.o nghash.o ngsrch.o ngstuff.o
Xobj4 = only.o rcln.o rcstuff.o respond.o rthread.o rt-mt.o rt-ov.o
Xobj5 = rt-process.o rt-page.o rt-select.o rt-util.o rt-wumpus.o search.o
Xobj6 = $(strftimeo) sw.o term.o trn.o util.o unship.o uudecode.o parsedate.o
Xobj7 = $(nntpobj)
X
Xobj = $(obj1) $(obj2) $(obj3) $(obj4) $(obj5) $(obj6) $(obj7)
X
Xlintflags = -phbvxac
X
Xaddedbymake = $(public) $(private) $(util) $(nntp) Makefile.old config.h\
X	cppstdin all
X
X# grrr
XSHELL = /bin/sh
X
X.c.o:
X	$(CC) -c $(CFLAGS) $*.c
X
Xall: $(public) $(private) $(util) Makefile
X	touch all
X
Xtrn: $(obj)
X	$(CC) $(LDFLAGS) $(obj) $(libs) -o trn
X#NNTP
X#NNTPnntpinit.o:
X#NNTP	$(CC) -c $(CFLAGS) $(NNTPFLAGS) $*.c
X#NNTP
X#NNTPgetactive: getactive.o nntpinit.o nntpclient.o
X#NNTP	$(CC) $(LDFLAGS) getactive.o nntpinit.o nntpclient.o -o getactive $(libs)
X
Xartcheck: artcheck.o
X	$(CC) $(LDFLAGS) artcheck.o -o artcheck $(libs)
X
Xparsedate.o: parsedate.y
X	@echo 'Expect 6 shift/reduce conflicts'
X	yacc parsedate.y
X	mv -f y.tab.c parsedate.c
X	$(CC) -c $(CFLAGS) parsedate.c
X	rm -f parsedate.c
X#STRFTIME
X#STRFTIME$(strftimeo): $(strftimec)
X#STRFTIME	$(CC) -c $(CFLAGS) $(strftimec)
X
Xunipatch: unipatch.o
X	$(CC) $(LDFLAGS) unipatch.o -o unipatch
X
X# if a .h file depends on another .h file...
X$(h):
X	-touch $@
X
Xinstall: $(public) $(private) $(manpages)
X# won't work with csh
X	export PATH || exit 1
X	- (cd `./filexp $(rnibin)`; mv trn trn.old)
X	- if test `pwd` != `./filexp $(rnibin)`; then cp $(public) `./filexp $(rnibin)`; fi
X	- if test $(filexp) = Rnfilexp; then cp ./filexp `./filexp $(rnibin)/Rnfilexp`; fi
X	- ./makedir `./filexp $(rnilib)`
X	- if test `pwd` != `./filexp $(rnilib)`; then cp INIT filexp $(private) `./filexp $(rnilib)`; fi
X#NNTP	- if test `pwd` != `./filexp $(rnilib)`; then strip `./filexp $(rnilib)`/getactive ; fi
X	- if test ! -f `./filexp $(rnilib)/newsnews`; then cp newsnews `./filexp $(rnilib)`; fi
X	- if test "X$(mansrc)" != "X" -a "X`pwd`" != X`./filexp $(mansrc)`; then \
Xfor page in $(manpages); do \
Xdest=`./filexp $(mansrc)`/`basename $$page .1`.$(manext); \
Xrm -f $$dest; cp $$page $$dest; chmod 444 $$dest; \
Xdone; \
Xfi
X
Xclean:
X	@echo 'Use "make realclean" to also remove the Makefile.'
X	@echo 'Use "make spotless" to even remove config.sh.'
X	rm -rf UU
X	rm -f *.o core $(addedbymake)
X
Xrealclean:
X	@echo 'You can use "Configure -S ; make depend ; make" to reverse this.'
X	rm -rf UU
X	rm -f *.o core $(addedbymake) Makefile
X
Xspotless:
X	rm -rf UU
X	rm -f *.o core $(addedbymake) Makefile filexp config.sh
X
X# The following lint has practically everything turned on.  Unfortunately,
X# you have to wade through a lot of mumbo jumbo that can't be suppressed.
X# If the source file has a /*NOSTRICT*/ somewhere, ignore the lint message
X# for that spot.
X
Xlint: lint_trn
X
Xlint_trn:
X	lint $(lintflags) $(defs) $(c) > trn.fuzz
X
Xsabertrn: $(c)
X	#load $(c) $(libs)
X
Xdepend: config.h Makefile makedepend
X	./makedepend
X
X# AUTOMATICALLY GENERATED MAKE DEPENDENCIES--PUT NOTHING BELOW THIS LINE
X!NO!SUBS!
X$cat dependencies >>Makefile
Xcase "$d_nntp" in
Xdefine)	sed < Makefile -e '/^#NNTP/s/^#NNTP//' > Makefile.new ;;
X*)	sed < Makefile -e '/^#NNTP/d' > Makefile.new ;;
Xesac
Xcase "$strftimec" in
X''|' ')	sed < Makefile.new -e '/^#STRFTIME/d' > Makefile ;;
X*)	sed < Makefile.new -e '/^#STRFTIME/s/^#STRFTIME//' > Makefile ;;
Xesac
Xrm Makefile.new
X$eunicefix Makefile
END_OF_FILE
if test 5843 -ne `wc -c <'Makefile.SH'`; then
    echo shar: \"'Makefile.SH'\" unpacked with wrong size!
fi
chmod +x 'Makefile.SH'
# end of 'Makefile.SH'
fi
if test -f 'Pnews.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Pnews.1'\"
else
echo shar: Extracting \"'Pnews.1'\" \(4077 characters\)
sed "s/^X//" >'Pnews.1' <<'END_OF_FILE'
X.\" $Id: Pnews.1,v 4.4.3.1 1992/02/01 03:17:20 sob PATCH_3 sob $
X.\"
X.\" This software is Copyright 1991 by Stan Barber. 
X.\"
X.\" Permission is hereby granted to copy, reproduce, redistribute or otherwise
X.\" use this software as long as: there is no monetary profit gained
X.\" specifically from the use or reproduction of this software, it is not
X.\" sold, rented, traded or otherwise marketed, and this copyright notice is
X.\" included prominently in any copy made. 
X.\"
X.\" The authors make no claims as to the fitness or correctness of this software
X.\" for any use whatsoever, and it is provided as is. Any use of this software
X.\" is at the user's own risk. 
X.\"
X.de Sh
X.br
X.ne 5
X.PP
X\fB\\$1\fR
X.PP
X..
X.de Sp
X.if t .sp .5v
X.if n .sp
X..
X.\" unbreakable dash.
X.tr \(*W-|\(bv\*(Tr
X.ie n \{\
X.ds -- \(*W-
X.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
X.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
X.ds L" ""
X.ds R" ""
X.ds L' '
X.ds R' '
X'br\}
X.el\{\
X.ds -- \(em\|
X.tr \*(Tr
X.ds L" ``
X.ds R" ''
X.ds L' `
X.ds R' '
X'br\}
X.TH PNEWS 1 LOCAL
X.SH NAME
XPnews - a program for posting news articles
X.SH SYNOPSIS
X.B Pnews newsgroup title
X.br
X  or
X.br
X.B Pnews -h headerfile [oldarticle]
X.br
X  or
X.br
X.B Pnews
X.SH DESCRIPTION
XPnews is a friendly interface for posting news articles.
XIt will ask several questions, then allow you to enter your article,
Xand then post it using the inews(1) program.
XIf you type h and a carriage return at any point,
X.I Pnews
Xwill tell you what it wants to know.
X.PP
XIf you put a
X.I .signature
Xfile in your home directory, your inews program will usually append it
Xto your message after you are done editing it.
XIf you prefer to see your signature while you are editing, rename your
X\&.signature file to be .news_sig and it will be appended before you
Xbegin to edit.
XNote that .news_sig obeys the setting of DOTDIR, but .signature does
Xnot (since it is out of Pnew's control).
XIf both .news_sig and .signature exist you'll get two signatures appended.
X.PP
XThe -h form is used when invoked from
X.I trn
Xor
X.IR rn .
XIf your editor can edit multiple files, and you want the article to which
Xyou are replying to show up as an alternate file, define the environment
Xvariable NEWSPOSTER as \*(L"Pnews -h %h %A\*(R".
XYou can also modify the the NEWSHEADER environment variable to change the
Xheader file that
X.I [t]rn
Xpasses to Pnews.
X.SH ENVIRONMENT
X.IP AUTHORCOPY 8
XIf defined, contains the name of a file to which the finished article will
Xbe appended.
X.Sp
XDefault: article not saved
X.IP DOTDIR 8
XWhere to find your dot files, if they aren't in your home directory.
XThis is primarily for accounts which are shared by more than one person.
X.Sp
XDefault: $HOME
X.IP EDITOR 8
XThe editor you want to use, if VISUAL is undefined.
X.Sp
XDefault: whatever your news administrator installed, usually vi.
X.IP HOME 8
XYour home directory.
X.Sp
XDefault: $LOGDIR
X.IP LOGDIR 8
XYour home directory if HOME is undefined.
X.IP LOGNAME 8
XYour login name, if USER is undefined.
X.Sp
XDefault: value of \*(L"whoami\*(R".
X.IP NAME 8
XYour full name.
X.Sp
XDefault: name from /etc/passwd, or ~/.fullname.
X.IP NEWSORG 8
XEither the name of your organization, or the name of a file containing the
Xname of your organization. (For use at organizations where the ORGANIZATION
Xenvironmental variable is in use for other purposes). If both NEWSORG and
XORGANIZATION are set, NEWSORG will override ORGANIZATION.
X.IP ORGANIZATION 8
XEither the name of your organization, or the name of a file containing the
Xname of your organization.
X.Sp
XDefault: whatever your news administrator chose.
X.IP REPLYTO 8
XThe contents of a \*(L"Reply-To:\*(R" header line to insert into your message.
X.Sp
XDefault: header line not inserted.
X.IP USER 8
XYour login name.
X.Sp
XDefault: $LOGNAME
X.IP VISUAL 8
XThe editor you want to use.
X.Sp
XDefault: $EDITOR
X.SH FILES
X$DOTDIR/.article
X.br
X$DOTDIR/.news_sig
X.br
X~/dead.article
X.SH SEE ALSO
Xtrn(1), rn(1), Rnmail(1), inews(1)
X.SH DIAGNOSTICS
X.SH BUGS
XNot the speediest program in the world, but maybe that's a blessing to the
Xnet.
END_OF_FILE
if test 4077 -ne `wc -c <'Pnews.1'`; then
    echo shar: \"'Pnews.1'\" unpacked with wrong size!
fi
# end of 'Pnews.1'
fi
if test -f 'Rnmail.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Rnmail.1'\"
else
echo shar: Extracting \"'Rnmail.1'\" \(4061 characters\)
sed "s/^X//" >'Rnmail.1' <<'END_OF_FILE'
X.\" $Id: Rnmail.1,v 4.4.3.1 1992/02/01 03:17:20 sob PATCH_3 sob $
X.\"
X.\" This software is Copyright 1991 by Stan Barber. 
X.\"
X.\" Permission is hereby granted to copy, reproduce, redistribute or otherwise
X.\" use this software as long as: there is no monetary profit gained
X.\" specifically from the use or reproduction of this software, it is not
X.\" sold, rented, traded or otherwise marketed, and this copyright notice is
X.\" included prominently in any copy made. 
X.\"
X.\" The authors make no claims as to the fitness or correctness of this software
X.\" for any use whatsoever, and it is provided as is. Any use of this software
X.\" is at the user's own risk. 
X.\"
X.de Sh
X.br
X.ne 5
X.PP
X\fB\\$1\fR
X.PP
X..
X.de Sp
X.if t .sp .5v
X.if n .sp
X..
X.\" unbreakable dash.
X.tr \(*W-|\(bv\*(Tr
X.ie n \{\
X.ds -- \(*W-
X.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
X.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
X.ds L" ""
X.ds R" ""
X.ds L' '
X.ds R' '
X'br\}
X.el\{\
X.ds -- \(em\|
X.tr \*(Tr
X.ds L" ``
X.ds R" ''
X.ds L' `
X.ds R' '
X'br\}
X.TH RNMAIL 1 LOCAL
X.SH NAME
XRnmail - a program for replying via mail
X.SH SYNOPSIS
X.B Rnmail destination_list
X.br
X  or
X.br
X.B Rnmail -h headerfile [oldarticle]
X.br
X  or
X.br
X.B Rnmail
X.SH DESCRIPTION
XRnmail is a friendly interface for mailing replies to news articles.
XIt will ask several questions, then allow you to enter your letter,
Xand then mail it off.
XIf you type h and a carriage return at any point,
X.I Rnmail
Xwill tell you what it wants to know.
X.PP
XIf you put a
X.I .signature
Xfile in your home directory, Rnmail will append it
Xto your message after you are done editing it.
XIf you prefer to see your signature while you are editing, rename your
X\&.signature file to be .mail_sig and it will be appended before you
Xbegin to edit.
XNote that both .mail_sig and .signature obey the setting of DOTDIR unless
XRnmail was modified to take the .signature appending out of Rnmail's control
Xand that if both files exist you get two signatures appended.
X.PP
XThe -h form is used when invoked from
X.I trn
Xor
X.IR rn .
XIf your editor can edit multiple files, and you want the article to which
Xyou are replying to show up as an alternate file, define the environment
Xvariable MAILPOSTER as \*(L"Rnmail -h %h %A\*(R".
XYou can also modify the the MAILHEADER environment variable to change the
Xheader file that
X.I [t]rn
Xpasses to Rnmail.
X.SH ENVIRONMENT
X.IP DOTDIR 8
XIf defined, specifies a place other than your home directory where 'dot' files
Xmay be stored.
XThis is primarily for accounts which are shared by more than one person.
X.Sp
XDefault: $HOME
X.IP EDITOR 8
XThe editor you want to use, if VISUAL is undefined.
X.Sp
XDefault: whatever your news administrator installed, usually vi.
X.IP HOME 8
XYour home directory.
X.Sp
XDefault: $LOGDIR
X.IP LOGDIR 8
XYour home directory if HOME is undefined.
X.IP LOGNAME 8
XYour login name, if USER is undefined.
X.Sp
XDefault: value of \*(L"whoami\*(R".
X.IP MAILRECORD 8
XIf defined, contains the name of a file to which the finished message will
Xbe appended.
X.Sp
XDefault: message not saved
X.IP NEWSORG 8
XEither the name of your organization, or the name of a file containing the
Xname of your organization. (For use at organizations where the ORGANIZATION
Xenvironmental variable is in use for other purposes). If both NEWSORG and 
XORGANIZATION are set, NEWSORG will override ORGANIZATION.
X.Sp
XDefault: whatever your news administrator chose.
X.IP ORGANIZATION 8
XEither the name of your organization, or the name of a file containing the
Xname of your organization.
X.Sp
XDefault: whatever your news administrator chose.
X.IP REPLYTO 8
XThe contents of a \*(L"Reply-To:\*(R" header line to insert into your message.
X.Sp
XDefault: header line not inserted.
X.IP USER 8
XYour login name.
X.Sp
XDefault: $LOGNAME
X.IP VISUAL 8
XThe editor you want to use.
X.Sp
XDefault: $EDITOR
X.SH FILES
X$DOTDIR/.letter
X.br
X$DOTDIR/.signature
X.br
X$DOTDIR/.mail_sig
X.br
X~/dead.letter
X.SH SEE ALSO
Xtrn(1), rn(1), Pnews(1), mail(1)
X.SH DIAGNOSTICS
X.SH BUGS
XUses /bin/mail in the absence of sendmail.
END_OF_FILE
if test 4061 -ne `wc -c <'Rnmail.1'`; then
    echo shar: \"'Rnmail.1'\" unpacked with wrong size!
fi
# end of 'Rnmail.1'
fi
if test -f 'Speller.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Speller.SH'\"
else
echo shar: Extracting \"'Speller.SH'\" \(3545 characters\)
sed "s/^X//" >'Speller.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X    '') . ./config.sh ;;
Xesac
Xecho "Extracting Speller (with variable substitutions)"
X$spitshell >Speller <<!GROK!THIS!
X$startsh
X# $Id: Speller.SH,v 3.0 1992/02/23 21:25:39 davison Trn $
X#	Speller - a script to disassemble a posting; use ispell to spell-
X#	check the body along with the Subject, Keywords, and Summary lines;
X#	and put it all back together again.
X#
X#	Written by Eric Schnoebelen, (eric@cirr.com)
X#					Fri May 14 20:33:48 CDT 1993
X
Xexport PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
X
X# what pager you use--if you have kernal paging use cat
Xpager="\${PAGER-$pager}"
X# either the ispell program or "none"
Xispell=$ispell_prg
Xispell_options=$ispell_options
Xtest=${test-test}
Xsed=${sed-sed}
Xecho=${echo-echo}
Xcat=${cat-cat}
Xawk=${awk-awk}
Xrm=${rm-rm}
Xmv=${mv-mv}
Xdiff=${diff-diff}
Xed=${ed-ed}
X!GROK!THIS!
X$spitshell >>Speller <<'!NO!SUBS!'
X
Xtmpdir="${TMPDIR-/tmp}"
X
X# get us some temporary files.
Xhdrs=$tmpdir/sp$$hdr
Xbody=$tmpdir/sp$$body
Xsig=$tmpdir/sp$$sig
Xmine=$tmpdir/sp$$mine
Xquoted=$tmpdir/sp$$quoted
X
XCmdname=`basename $0`
X
Xif $test "$1 " = " "; then
X    $echo "$Cmdname: insufficent arguments" >&2
X    $echo "$Cmdname: usage: $Cmdname <filename>" >&2 
X    exit 1
Xfi
X
Xtrap "$rm -f $hdrs $body $body~ $sig $mine $quoted; exit 1" 0 1 2 15
X
Xwhile $test "$1" != ""; do
X
X    # create the files, so that cat is quiet later..
X    >$hdrs
X    >$body
X    >$sig
X    >$mine
X    >$quoted
X
X    # tear the wanted headers out and toss them at body, leaving the 
X    # the remainder to be put back in later.
X
X    $awk 'BEGIN { inhdr = 1; keephdr = 0; insig = 0 } 
X	/^$/		{ 
X			inhdr = 0;
X			print $0 > Body;
X			next;
X			}
X	/^-- $/		{
X			insig = 1;
X			print $0 > Sig;
X			next;
X			}
X	/^Subject: /	{ 
X			if (inhdr) { 
X			    keephdr = 1;
X			    print $0 > Body;
X			    next;
X			}  
X			}
X	/^Keywords: /	{
X			if (inhdr) { 
X			    keephdr = 1;
X			    print $0 > Body 
X			}
X			next;
X			}
X	/^Summary: /	{ if (inhdr) { 
X			    keephdr = 1;
X			    print $0 > Body 
X			}
X			next;
X			}
X	/^[ \t]/	{
X			    if (keephdr && indhr) {
X				print $0 > Body;
X			    } else if (inhdr) {
X				print $0 > Hdrs;
X			    }
X			}
X	/^.*: /		{ if (inhdr) { 
X			    keephdr = 0;
X			    print $0 > Hdrs;
X			    next;
X			} }
X	/^.*$/		{ if (!inhdr && !insig) {
X			    print $0 > Body;
X			    next;
X			} 
X			if (insig) {
X			    print $0 > Sig;
X			    next
X			} }
X    ' Body=$body Hdrs=$hdrs Sig=$sig $1
X
X    # now rip out the quoted text from the article, so we only
X    # spell check our own pristine prose..
X
X    if $test "$QUOTECHARS " = " " ; then
X	$mv $body $mine
X    else
X	$sed -e "/^$QUOTECHARS/s/.*//" $body >$mine
X	$diff -e $mine $body > $quoted
X    fi
X
X    # ok, we've torn everything asunder, now lets spell check
X    # the guts of the article..
X
X    if $test "$ispell " = "none "; then
X	($echo ---- misspelled words -------------------------------------
X	 spell $mine | fmt
X	 $echo -----------------------------------------------------------
X	) | $pager
X    else
X	$ispell $ispell_options $mine
X    fi
X
X    if $test $? -ne 0; then
X	$echo "$Cmdname: error returned, leaving message untouched"
X
X	# don't want to mess with this file again, either
X	shift
X	continue
X    fi
X
X    # resurrect the body of the article..
X    if $test -s $quoted ; then
X	($cat $quoted; $echo w $body; $echo q) | $ed - $mine
X    else
X	$mv $mine $body
X    fi
X
X    # ..and re-assemble the article.
X    $cat $hdrs $body $sig >$1
X
X    # move to the next filename!
X    shift
X
Xdone
X!NO!SUBS!
X$eunicefix Speller
Xchmod 755 Speller
END_OF_FILE
if test 3545 -ne `wc -c <'Speller.SH'`; then
    echo shar: \"'Speller.SH'\" unpacked with wrong size!
fi
# end of 'Speller.SH'
fi
if test -f 'artcheck.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'artcheck.c'\"
else
echo shar: Extracting \"'artcheck.c'\" \(4836 characters\)
sed "s/^X//" >'artcheck.c' <<'END_OF_FILE'
X/* $Id: artcheck.c,v 3.0 1992/02/01 03:09:32 davison Trn $
X*/
X/* The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X/* A program to check an article's validity and print warnings if problems
X** are found.
X**
X** Usage: artcheck <article> <maxLineLen> <newsgroupsFile> <activeFile>
X*/
X
X#include "EXTERN.h"
X#include "common.h"
X#include "config.h"
X
X#define MAXNGS 100
X
Xint
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X    FILE *fp, *fp_active = NULL, *fp_ng = NULL;
X    char buff[LBUFLEN], *cp, *cp2;
X    char *ngptrs[MAXNGS];
X    int nglens[MAXNGS];
X    int foundactive[MAXNGS];
X    int i, col, max_col_len, line_num = 0, ngcnt = 0, ngleft;
X    int found_newsgroups = 0;
X
X    if (argc != 5 || !(max_col_len = atoi(argv[2]))) {
X	fprintf(stderr, "\
XUsage: artcheck <article> <maxLineLen> <newsgroupsFile> <activeFile>\n");
X	exit(1);
X    }
X
X    if ((fp = fopen(argv[1], "r")) == NULL) {
X	fprintf(stderr, "artcheck: unable to open article `%s'.\n", argv[1]);
X	exit(1);
X    }
X
X    /* Check the header for proper format and report on the newsgroups */
X    while (fgets(buff, LBUFLEN, fp)) {
X	line_num++;
X	buff[strlen(buff)-1] = '\0';
X	if (!*buff)
X	    break;
X	if (*buff == ' ' || *buff == '\t')
X	    continue;
X	if (!(cp = index(buff, ':'))) {
X	    printf("\nERROR: line %d is an invalid header line:\n%s\n",
X		   line_num, buff);
X	    break;
X	}
X	if (cp[1] != ' ' && cp[1] != '\0') {
X	    printf("\n\
XERROR: header on line %d does not have a space after the colon:\n%s\n",
X		   line_num, buff);
X	}
X	if (cp - buff == 10 && strnEQ(buff, "Newsgroups", 10)) {
X	    found_newsgroups = 1;
X	    for (cp = buff + 11; *cp == ' '; cp++)
X		;
X	    if (index(cp, ' ')) {
X		printf("\n\
XERROR: the \"Newsgroups:\" line has spaces in it that MUST be removed. The\n\
Xonly allowable space is the one separating the colon (:) from the contents.\n\
XUse a comma (,) to separate multiple newsgroup names.\n");
X		continue;
X	    }
X	    while (*cp) {
X		if (!(cp2 = index(cp, ',')))
X		    cp2 = cp + strlen(cp);
X		else
X		    *cp2++ = '\0';
X		if (ngcnt < MAXNGS) {
X		    nglens[ngcnt] = strlen(cp);
X		    foundactive[ngcnt] = 0;
X		    ngptrs[ngcnt] = malloc(nglens[ngcnt]+1);
X		    if (!ngptrs[ngcnt]) {
X			fprintf(stderr,"Out of memory.\n");
X			exit(1);
X		    }
X		    strcpy(ngptrs[ngcnt], cp);
X		    ngcnt++;
X		}
X		cp = cp2;
X	    }
X	    if (!ngcnt) {
X		printf("\n\
XERROR: the \"Newsgroups:\" line lists no newsgroups.\n");
X		continue;
X	    }
X	}
X    }
X    if (!found_newsgroups) {
X	printf("\nERROR: the \"Newsgroups:\" line is missing from the header.\n");
X    }
X
X    /* Check the body of the article for long lines */
X    while (fgets(buff, LBUFLEN, fp)) {
X	line_num++;
X	buff[strlen(buff)-1] = '\0';
X	col = 0;
X	for (cp = buff; *cp; cp++) {
X	    if (*cp == '\t')
X		col += 8 - (col%8);
X	    else
X		col++;
X	}
X	if (col > max_col_len) {
X	    printf("\n\
XWarning: posting exceeds %d columns.  Line %d is the first long one:\n%s\n",
X		   max_col_len, line_num, buff);
X	    break;
X	}
X    }
X    if (ngcnt) {
X	struct stat st;
X	if (stat(argv[3], &st) != -1 && st.st_size > 0)
X	    fp_ng = fopen(argv[3], "r");
X	if (stat(argv[4], &st) != -1 && st.st_size > 0)
X	    fp_active = fopen(argv[4], "r");
X    }
X    if (ngcnt && (fp_ng != NULL || fp_active != NULL)) {
X	/* Print a note about each newsgroup */
X	printf("\nYour article's newsgroup%s:\n", ngcnt == 1? "" : "s");
X	if (fp_active == NULL) {
X	    for (i = 0; i < ngcnt; i++) {
X		foundactive[i] = 1;
X	    }
X	} else {
X	    ngleft = ngcnt;
X	    while (fgets(buff, LBUFLEN, fp_active)) {
X		if (!ngleft)
X		    break;
X		for (i = 0; i < ngcnt; i++) {
X		    if (!foundactive[i]) {
X			if ((buff[nglens[i]] == '\t' || buff[nglens[i]] == ' ')
X			  && strnEQ(ngptrs[i], buff, nglens[i])) {
X			    foundactive[i] = 1;
X			    ngleft--;
X			}
X		    }
X		}
X	    }
X	    fclose(fp_active);
X	}
X	if (fp_ng != NULL) {
X	    ngleft = ngcnt;
X	    while (fgets(buff, LBUFLEN, fp_ng)) {
X		if (!ngleft)
X		    break;
X		for (i = 0; i < ngcnt; i++) {
X		    if (foundactive[i] && ngptrs[i]) {
X			if ((buff[nglens[i]] == '\t' || buff[nglens[i]] == ' ')
X			  && strnEQ(ngptrs[i], buff, nglens[i])) {
X			    cp = &buff[nglens[i]];
X			    *cp++ = '\0';
X			    while (*cp == ' ' || *cp == '\t')
X				cp++;
X			    if (cp[0] == '?' && cp[1] == '?')
X				cp = "[no description available]\n";
X			    printf("%-23s %s", buff, cp);
X			    free(ngptrs[i]);
X			    ngptrs[i] = 0;
X			    ngleft--;
X			}
X		    }
X		}
X	    }
X	    fclose(fp_ng);
X	}
X	for (i = 0; i < ngcnt; i++) {
X	    if (!foundactive[i]) {
X		printf("%-23s ** invalid news group -- check spelling **\n",
X		   ngptrs[i]);
X		free(ngptrs[i]);
X	    } else if (ngptrs[i]) {
X		printf("%-23s [no description available]\n", ngptrs[i]);
X		free(ngptrs[i]);
X	    }
X	}
X    }
X    return 0;
X}
END_OF_FILE
if test 4836 -ne `wc -c <'artcheck.c'`; then
    echo shar: \"'artcheck.c'\" unpacked with wrong size!
fi
# end of 'artcheck.c'
fi
if test -f 'artio.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'artio.c'\"
else
echo shar: Extracting \"'artio.c'\" \(2545 characters\)
sed "s/^X//" >'artio.c' <<'END_OF_FILE'
X/* $Id: artio.c,v 3.0 1992/02/01 03:09:32 davison Trn $
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "cache.h"
X#include "rthread.h"
X#include "head.h"
X#include "nntp.h"
X#include "art.h"
X#include "bits.h"
X#include "final.h"
X#include "ngdata.h"
X#include "INTERN.h"
X#include "artio.h"
X
Xvoid
Xartio_init()
X{
X    ;
X}
X
X/* open an article, unless it's already open */
X
XFILE *
Xartopen(artnum)
XART_NUM artnum;
X{
X#ifndef USE_NNTP
X    char artname[MAXFILENAME];		/* filename of current article */
X#endif
X    ARTICLE *ap = find_article(artnum);
X
X    if (!ap || !artnum || (ap->flags & (AF_MISSING|AF_FAKE)) == AF_MISSING) {
X	errno = ENOENT;
X	return Nullfp;
X    }
X    if (openart == artnum) {		/* this article is already open? */
X	fseek(artfp,0L,0);		/* just get to the beginning */
X	return artfp;			/* and say we succeeded */
X    }
X    if (artfp != Nullfp) {		/* it was somebody else? */
X	fclose(artfp);			/* put them out of their misery */
X	openart = 0;			/* and remember them no more */
X    }
Xretry_open:
X#ifdef USE_NNTP
X    artfp = nntp_body(artnum);
X#else
X    sprintf(artname,"%ld",(long)artnum);
X    artfp = fopen(artname,"r");
X#endif
X    if (!artfp) {
X#ifdef ETIMEDOUT
X	if (errno == ETIMEDOUT)
X	    goto retry_open;
X#endif
X	if (errno == EINTR)
X	    goto retry_open;
X	uncache_article(ap,FALSE);
X    } else {
X#ifdef LINKART
X	char tmpbuf[256];
X	char *s;
X
X	if (!fstat(fileno(artfp),&filestat)
X	 && filestat.st_size < sizeof tmpbuf) {
X	    fgets(tmpbuf,sizeof tmpbuf,artfp);
X	    if (*tmpbuf == '/') {	/* is a "link" to another article */
X		fclose(artfp);
X		if (s=index(tmpbuf,'\n'))
X		    *s = '\0';
X		if (!(artfp = fopen(tmpbuf,"r"))) {
X		    uncache_article(ap,FALSE);
X		} else {
X		    if (*linkartname)
X			free(linkartname);
X		    linkartname = savestr(tmpbuf);
X		}
X	    } else
X		fseek(artfp,0L,0);	/* get back to the beginning */
X	}
X#endif
X	openart = artnum;		/* remember what we did here */
X    }
X    return artfp;			/* and return either fp or NULL */
X}
END_OF_FILE
if test 2545 -ne `wc -c <'artio.c'`; then
    echo shar: \"'artio.c'\" unpacked with wrong size!
fi
# end of 'artio.c'
fi
if test -f 'backpage.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'backpage.c'\"
else
echo shar: Extracting \"'backpage.c'\" \(2542 characters\)
sed "s/^X//" >'backpage.c' <<'END_OF_FILE'
X/* $Id: backpage.c,v 3.0 1991/09/09 20:18:23 davison Trn $
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "intrp.h"
X#include "final.h"
X#include "INTERN.h"
X#include "backpage.h"
X
XART_LINE maxindx = -1;
X
Xvoid
Xbackpage_init()
X{
X    char *varyname;
X    
X    varyname = filexp(VARYNAME);
X    close(creat(varyname,0600));
X    varyfd = open(varyname,2);
X    UNLINK(varyname);
X    if (varyfd < 0) {
X	printf(cantopen,varyname) FLUSH;
X	sig_catcher(0);
X    }
X    
X}
X
X/* virtual array read */
X
XART_POS
Xvrdary(indx)
XART_LINE indx;
X{
X    int subindx;
X    long offset;
X
X#ifdef DEBUG
X    if (indx > maxindx) {
X	printf("vrdary(%ld) > %ld\n",(long)indx, (long)maxindx) FLUSH;
X	return 0;
X    }
X#endif
X    if (indx < 0)
X	return 0;
X    subindx = indx % VARYSIZE;
X    offset = (indx - subindx) * sizeof(varybuf[0]);
X    if (offset != oldoffset) {
X	if (oldoffset >= 0) {
X#ifndef lint
X	    (void)lseek(varyfd,oldoffset,0);
X	    write(varyfd, (char *)varybuf,sizeof(varybuf));
X#endif /* lint */
X	}
X#ifndef lint
X	(void)lseek(varyfd,offset,0);
X	read(varyfd,(char *)varybuf,sizeof(varybuf));
X#endif /* lint */
X	oldoffset = offset;
X    }
X    return varybuf[subindx];
X}
X
X/* write to virtual array */
X
Xvoid
Xvwtary(indx,newvalue)
XART_LINE indx;
XART_POS newvalue;
X{
X    int subindx;
X    long offset;
X
X#ifdef DEBUG
X    if (indx < 0)
X	printf("vwtary(%ld)\n",(long)indx) FLUSH;
X    if (!indx)
X	maxindx = 0;
X    if (indx > maxindx) {
X	if (indx != maxindx + 1)
X	    printf("indx skipped %d-%d\n",maxindx+1,indx-1) FLUSH;
X	maxindx = indx;
X    }
X#endif
X    subindx = indx % VARYSIZE;
X    offset = (indx - subindx) * sizeof(varybuf[0]);
X    if (offset != oldoffset) {
X	if (oldoffset >= 0) {
X#ifndef lint
X	    (void)lseek(varyfd,oldoffset,0);
X	    write(varyfd,(char *)varybuf,sizeof(varybuf));
X#endif /* lint */
X	}
X#ifndef lint
X	(void)lseek(varyfd,offset,0);
X	read(varyfd,(char *)varybuf,sizeof(varybuf));
X#endif /* lint */
X	oldoffset = offset;
X    }
X    varybuf[subindx] = newvalue;
X}
X
END_OF_FILE
if test 2542 -ne `wc -c <'backpage.c'`; then
    echo shar: \"'backpage.c'\" unpacked with wrong size!
fi
# end of 'backpage.c'
fi
if test -f 'cache.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cache.h'\"
else
echo shar: Extracting \"'cache.h'\" \(4368 characters\)
sed "s/^X//" >'cache.h' <<'END_OF_FILE'
X/* $Id: cache.h,v 3.0 1991/09/09 20:18:23 davison Trn $
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X/* Subjects get their own structure */
X
Xtypedef struct rt_subj {
X    struct rt_subj *next;
X    struct rt_subj *prev;
X    struct rt_art *articles;
X    struct rt_art *thread;
X    struct rt_subj *thread_link;
X    char *str;
X    time_t date;
X    short flags;
X    short misc;		/* used for temporary totals and subject numbers */
X} SUBJECT;
X
X/* subject flags */
X
X#define SF_SEL		0x0001
X#define SF_DEL		0x0002
X#define SF_DELSEL	0x0004
X#define SF_OLDSEL	0x0008
X#define SF_INCLUDED	0x0010
X
X#define SF_THREAD	0x0100
X#define SF_VISIT	0x0200
X#define SF_WASSELECTED  0x0400
X#define SF_SUBJTRUNCED	0x1000
X
X/* This is our article-caching structure */
X
Xtypedef struct rt_art {
X    time_t date;
X    SUBJECT *subj;
X    char *from;
X    char *msgid;
X    char *xrefs;
X    struct rt_art *parent;	/* parent article */
X    struct rt_art *child1;	/* first child of a chain */
X    struct rt_art *sibling;	/* our next sibling */
X    struct rt_art *subj_next;	/* next article in subject order */
X    short flags;		/* user-settable flags */
X    short padding;
X} ARTICLE;
X
X/* article flags */
X
X#define AF_SEL		0x0001
X#define AF_DEL		0x0002
X#define AF_DELSEL	0x0004
X#define AF_OLDSEL	0x0008
X#define AF_INCLUDED	0x0010
X
X#define AF_READ		0x0020
X#define AF_CACHED	0x0040
X#define AF_THREADED	0x0080
X#define AF_MISSING	0x0100
X#define AF_AUTOKILL	0x0200
X#define AF_AUTOKILLALL	0x0400
X#define AF_AUTOSELECT	0x0800
X#define AF_AUTOSELECTALL 0x1000
X#define AF_AUTOFLAGS    (AF_AUTOKILL|AF_AUTOKILLALL|AF_AUTOSELECT|AF_AUTOSELECTALL)
X
X/* If AF_MISSING is NOT set the last 3 bits have the following meaning: */
X#define AF_HAS_RE	0x2000
X#define AF_YANKBACK	0x4000
X#define AF_FROMTRUNCED	0x8000
X
X/* These flags only have meaning when combined with AF_MISSING */
X#define AF_TMPMEM	(0x2000|AF_MISSING)
X#define AF_FAKE		(0x4000|AF_MISSING)
X
X/* The following define is only valid as a flag to the select_article call */
X#define AF_ECHO 	0x8000
X
X#define Nullart Null(ARTICLE*)
X#define Nullsubj Null(SUBJECT*)
X
X#define was_read(a)     ((a) < absfirst || (article_ptr(a)->flags & AF_READ))
X
X/* These must never use their args more than once in the definition */
X#define article_num(ap)      (((ap)-article_list)+absfirst)
X#define article_ptr(an)      (article_list+((an)-absfirst))
X#define find_article(an)     ((an < absfirst || an > lastart)? \
X			      Nullart : article_ptr(an))
X
XEXT ARTICLE *article_list INIT(Nullart);
XEXT ARTICLE **artptr_list INIT(0);
XEXT ARTICLE **artptr;
XEXT ART_NUM artptr_list_size INIT(0);
X
X#ifdef ARTSEARCH
XEXT ART_NUM srchahead INIT(0); 	/* are we in subject scan mode? */
X				/* (if so, contains art # found or -1) */
X#endif
X
XEXT ART_NUM first_cached;
XEXT ART_NUM last_cached;
XEXT bool cached_all_in_range;
XEXT ARTICLE *sentinel_artp;
X
X#define DONT_FILL_CACHE	0
X#define FILL_CACHE	1
X
XEXT struct rt_subj *first_subject INIT(0);
XEXT struct rt_subj *last_subject INIT(0);
X
XEXT bool untrim_cache INIT(FALSE);
X
X#ifdef PENDING
XEXT ART_NUM subj_to_get;
XEXT ART_NUM xref_to_get;
X#endif
X
Xvoid	cache_init _((void));
Xvoid	build_cache _((void));
Xvoid	grow_cache _((ART_NUM));
Xvoid	close_cache _((void));
Xvoid	cache_article _((ARTICLE*));
Xvoid	check_poster _((ARTICLE*));
Xvoid	uncache_article _((ARTICLE*,bool_int));
Xchar	*fetchcache _((ART_NUM,int,bool_int));
Xchar	*get_cached_line _((ARTICLE*, int, bool_int));
Xvoid	set_subj_line _((ARTICLE*, char*, int));
Xvoid	set_cached_line _((ARTICLE*, int, char*));
Xvoid	look_ahead _((void));
Xvoid	cache_until_key _((void));
Xbool	cache_subjects _((void));
Xbool	cache_xrefs _((void));
Xbool	cache_all_arts _((void));
Xbool	cache_unread_arts _((void));
Xbool	art_data _((ART_NUM,ART_NUM,bool_int,bool_int));
Xbool	cache_range _((ART_NUM,ART_NUM));
Xvoid	clear_article _((ARTICLE*));
Xvoid	free_subject _((SUBJECT*));
END_OF_FILE
if test 4368 -ne `wc -c <'cache.h'`; then
    echo shar: \"'cache.h'\" unpacked with wrong size!
fi
# end of 'cache.h'
fi
if test -f 'final.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'final.c'\"
else
echo shar: Extracting \"'final.c'\" \(5113 characters\)
sed "s/^X//" >'final.c' <<'END_OF_FILE'
X/* $Id: final.c,v 3.0 1992/02/01 03:09:32 davison Trn $
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "util.h"
X#include "cache.h"
X#include "bits.h"
X#include "term.h"
X#include "ng.h"
X#include "init.h"
X#include "last.h"
X#include "rcstuff.h"
X#include "ngdata.h"
X#include "artio.h"
X#include "intrp.h"
X#include "nntp.h"
X#include "INTERN.h"
X#include "final.h"
X
X#ifndef sigmask
X#define sigmask(m)	(1 << ((m)-1))
X#endif
X
Xvoid
Xfinal_init()
X{
X#ifdef SIGTSTP
X    sigset(SIGTSTP, stop_catcher);	/* job control signals */
X    sigset(SIGTTOU, stop_catcher);	/* job control signals */
X    sigset(SIGTTIN, stop_catcher);	/* job control signals */
X#endif
X
X    sigset(SIGINT, int_catcher);	/* always catch interrupts */
X#ifdef SIGHUP
X    sigset(SIGHUP, sig_catcher);	/* and hangups */
X#endif
X#ifdef SIGWINCH
X    sigset(SIGWINCH, winch_catcher);
X#endif
X
X#ifdef DEBUG
X    /* sometimes we WANT a core dump */
X    if (debug & DEB_COREDUMPSOK)
X	return;
X#endif
X    sigset(SIGILL, sig_catcher);
X#ifdef SIGTRAP
X    sigset(SIGTRAP, sig_catcher);
X#endif
X    sigset(SIGFPE, sig_catcher);
X#ifdef SIGBUS
X    sigset(SIGBUS, sig_catcher);
X#endif
X    sigset(SIGSEGV, sig_catcher);
X#ifdef SIGSYS
X    sigset(SIGSYS, sig_catcher);
X#endif
X    sigset(SIGTERM, sig_catcher);
X#ifdef SIGXCPU
X    sigset(SIGXCPU, sig_catcher);
X#endif
X#ifdef SIGXFSZ
X    sigset(SIGXFSZ, sig_catcher);
X#endif
X}
X
Xvoid					/* very much void */
Xfinalize(status)
Xint status;
X{
X    termlib_reset();
X    if (bizarre)
X	resetty();
X    if (lockname && *lockname)
X 	UNLINK(lockname);
X#ifdef USE_NNTP
X    nntp_cleanup();
X#endif
X    if (status < 0) {
X	chdir("/usr/tmp");
X	sigset(SIGILL,SIG_DFL);
X#ifdef HAS_SIGBLOCK
X	sigsetmask(sigblock(0) & ~(sigmask(SIGILL) | sigmask(SIGIOT)));
X#endif
X	abort();
X    }
X    exit(status);
X}
X
X/* come here on interrupt */
X
XSignal_t
Xint_catcher(dummy)
Xint dummy;
X{
X    sigset(SIGINT,int_catcher);
X#ifdef DEBUG
X    if (debug)
X	write(2,"int_catcher\n",12);
X#endif
X    if (!waiting) {
X	if (int_count) {		/* was there already an interrupt? */
X	    write(2,"\nBye-bye.\n",10);
X	    sig_catcher(0);		/* emulate the other signals */
X	}
X	int_count++;
X    }
X}
X
X/* come here on signal other than interrupt, stop, or cont */
X
XSignal_t
Xsig_catcher(signo)
Xint signo;
X{
X#ifdef VERBOSE
X    static char *signame[] = {
X	"",
X	"HUP",
X	"INT",
X	"QUIT",
X	"ILL",
X	"TRAP",
X	"IOT",
X	"EMT",
X	"FPE",
X	"KILL",
X	"BUS",
X	"SEGV",
X	"SYS",
X	"PIPE",
X	"ALRM",
X	"TERM",
X	"???"
X#ifdef SIGTSTP
X	,"STOP",
X	"TSTP",
X	"CONT",
X	"CHLD",
X	"TTIN",
X	"TTOU",
X	"TINT",
X	"XCPU",
X	"XFSZ"
X#ifdef SIGPROF
X	,"VTALARM",
X	"PROF"
X#endif
X#endif
X	};
X#endif
X
X#ifdef DEBUG
X    if (debug) {
X	printf("\nSIG%s--.newsrc not restored in debug\n",signame[signo]);
X	finalize(-1);
X    }
X#endif
X    if (panic) {
X#ifdef HAS_SIGBLOCK
X      sigsetmask(sigblock(0) & ~(sigmask(SIGILL) | sigmask(SIGIOT)));
X#endif
X	abort();
X      }
X    (void) sigset(SIGILL,SIG_DFL);
X    panic = TRUE;			/* disable terminal I/O */
X    if (doing_ng) {			/* need we reconstitute rc line? */
X	yankback();
X	bits_to_rc();			/* then do so (hope this works) */
X    }
X    doing_ng = FALSE;
X    if (rc_changed)			/* need we write .newsrc out? */
X	write_rc();			/* then do so */
X    rc_changed = FALSE;
X#ifdef SIGHUP
X    if (signo != SIGHUP)
X#endif
X#ifdef VERBOSE
X	IF(verbose)
X	    printf("\nCaught %s%s--.newsrc restored\n",
X		signo ? "a SIG" : "an internal error", signame[signo]);
X	ELSE
X#endif
X#ifdef TERSE
X	    printf("\nSignal %d--bye bye\n",signo);
X#endif
X    switch (signo) {
X#ifdef SIGBUS
X    case SIGBUS:
X#endif
X    case SIGILL:
X    case SIGSEGV:
X	finalize(-signo);
X    }
X    finalize(1);				/* and blow up */
X}
X
X#ifdef SIGTSTP
X/* come here on stop signal */
X
XSignal_t
Xstop_catcher(signo)
Xint signo;
X{
X    if (!waiting) {
X	checkpoint_rc();	/* good chance of crash while stopped */
X	if (clear_on_stop) {
X	    clear();
X	    putchar('\n') FLUSH;
X	}
X	termlib_reset();
X	resetty();		/* this is the point of all this */
X#ifdef DEBUG
X	if (debug)
X	    write(2,"stop_catcher\n",13);
X#endif
X	sigset(signo,SIG_DFL);	/* enable stop */
X#ifdef HAS_SIGBLOCK
X	sigsetmask(sigblock(0) & ~(1 << (signo-1)));
X#endif
X	kill(0,signo);		/* and do the stop */
X    	savetty();
X#ifdef MAILCALL
X    	mailcount = 0;			/* force recheck */
X#endif
X    	if (!panic) {
X	    if (!waiting) {
X		termlib_init();
X		noecho();			/* set no echo */
X		crmode();			/* set cbreak mode */
X		forceme("\f");			/* cause a refresh */
X						/* (defined only if TIOCSTI defined) */
X		errno = 0;			/* needed for getcmd */
X	    }
X    	}
X    }
X    sigset(signo,stop_catcher);	/* unenable the stop */
X}
X#endif
END_OF_FILE
if test 5113 -ne `wc -c <'final.c'`; then
    echo shar: \"'final.c'\" unpacked with wrong size!
fi
# end of 'final.c'
fi
if test -f 'head.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'head.h'\"
else
echo shar: Extracting \"'head.h'\" \(6341 characters\)
sed "s/^X//" >'head.h' <<'END_OF_FILE'
X/* $Id: head.h,v 3.0 1992/02/01 03:09:32 davison Trn $
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#define HEAD_FIRST 1
X
X/* types of header lines (if only C really believed in enums)
X * (These must stay in alphabetic order at least in the first letter.
X * Within each letter it helps to arrange in increasing likelihood.)
X */
X
X#define PAST_HEADER	0			/* body */
X#define SOME_LINE	(PAST_HEADER+1)		/* unrecognized */
X#define ARTID_LINE	(SOME_LINE+1)		/* article-i.d. */
X#define APPR_LINE	(ARTID_LINE+1)		/* approved */
X#define ACAT_LINE	(APPR_LINE+1)		/* ACategory (ClariNet) */
X#define ANPA_LINE	(ACAT_LINE+1)		/* ANPA (ClariNet) */
X#define CODES_LINE	(ANPA_LINE+1)		/* Codes (ClariNet) */
X#define CONTENT_LINE	(CODES_LINE+1)		/* MIME */
X#define CANCEL_LINE	(CONTENT_LINE+1)	/* cancel */
X#define DIST_LINE	(CANCEL_LINE+1)		/* distribution */
X#define DATE_LINE	(DIST_LINE+1)		/* date */
X#define RECEIVED_LINE	(DATE_LINE+1)		/* date-received */
X#define EXPIR_LINE	(RECEIVED_LINE+1)	/* expires */
X#define FOLLOW_LINE	(EXPIR_LINE+1)		/* followup-to */
X#define FROM_LINE	(FOLLOW_LINE+1)		/* from */
X#define FORM_LINE	(FROM_LINE+1)		/* Format (ClariNet) */
X#define KEYW_LINE	(FORM_LINE+1)		/* keywords */
X#define LINES_LINE	(KEYW_LINE+1)		/* lines */
X#define MESSID_LINE	(LINES_LINE+1)		/* message-id */
X#define NFFR_LINE	(MESSID_LINE+1)		/* nf-from */
X#define NFID_LINE	(NFFR_LINE+1)		/* nf-id */
X#define NGS_LINE	(NFID_LINE+1)		/* newsgroups */
X#define NNTPHOST_LINE	(NGS_LINE+1)		/* nntp-posting-host */
X#define NOTE_LINE	(NNTPHOST_LINE+1)	/* Note (ClariNet) */
X#define ORG_LINE	(NOTE_LINE+1)		/* organization */
X#define PATH_LINE	(ORG_LINE+1)		/* path */
X#define POSTED_LINE	(PATH_LINE+1)		/* posted */
X#define PVER_LINE	(POSTED_LINE+1)		/* posting-version */
X#define PRI_LINE	(PVER_LINE+1)		/* Priority (ClariNet) */
X#define REPLY_LINE	(PRI_LINE+1)		/* reply-to */
X#define REFS_LINE	(REPLY_LINE+1)		/* references */
X#define RVER_LINE	(REFS_LINE+1)		/* relay-version */
X#define SENDER_LINE	(RVER_LINE+1)		/* sender */
X#define SUMRY_LINE	(SENDER_LINE+1)		/* summary */
X#define SUBJ_LINE	(SUMRY_LINE+1)		/* subject */
X#define SUPR_LINE	(SUBJ_LINE+1)		/* supersedes */
X#define SLUG_LINE	(SUPR_LINE+1)		/* Slugword (ClariNet) */
X#define XREF_LINE	(SLUG_LINE+1)		/* xref */
X#define XSUP_LINE	(XREF_LINE+1)		/* X-Supersedes (ClariNet) */
X#define HEAD_LAST	(XSUP_LINE+1)		/* total # of headers */
X
Xstruct headtype {
X    char *ht_name;		/* header line identifier */
X    ART_POS ht_minpos;		/* pointer to beginning of line in article */
X    ART_POS ht_maxpos;		/* pointer to end of line in article */
X    char ht_length;		/* could make these into nybbles but */
X    char ht_flags;		/* it wouldn't save space normally */
X};				/* due to alignment considerations */
X
X#define HT_HIDE   1	/* -h on this line */
X#define HT_MAGIC  2	/* do any special processing on this line */
X#define HT_CACHED 4	/* this information is cached in the article data */
X
X/* This array must stay in the same order as the list above */
X
X#ifndef DOINIT
XEXT struct headtype htype[HEAD_LAST];
X#else
Xstruct headtype htype[HEAD_LAST] = {
X /* name             minpos   maxpos  length   flag */
X    {"BODY",		0,	0,	4,	0		},
X    {"unrecognized",	0,	0,	12,	0		},
X    {"article-i.d.",	0,	0,	12,	HT_HIDE		},
X    {"approved",	0,	0,	8,	HT_HIDE		},
X    {"acategory",	0,	0,	9,	HT_HIDE		},
X    {"anpa",		0,	0,	4,	HT_HIDE		},
X    {"codes",		0,	0,	5,	HT_HIDE		},
X#ifdef MIME_SUPPORT
X    {"content-type",	0,	0,	12,	HT_MAGIC	},
X#else
X    {"content-type",	0,	0,	12,	0		},
X#endif
X    {"control",		0,	0,	7,	0		},
X    {"distribution",	0,	0,	12,	0		},
X    {"date",		0,	0,	4,	HT_MAGIC	},
X    {"date-received",	0,	0,	13,	0		},
X    {"expires",		0,	0,	7,	HT_HIDE|HT_MAGIC},
X    {"followup-to",	0,	0,	11,	0		},
X    {"from",		0,	0,	4,	HT_CACHED	},
X    {"format",		0,	0,	6,	HT_HIDE		},
X    {"keywords",	0,	0,	8,	0		},
X    {"lines",		0,	0,	5,	0		},
X    {"message-id",	0,	0,	10,	HT_HIDE|HT_CACHED},
X    {"nf-from",		0,	0,	7,	HT_HIDE		},
X    {"nf-id",		0,	0,	5,	HT_HIDE		},
X#ifdef DBM_XREFS
X    {"newsgroups",	0,	0,	10,	HT_MAGIC|HT_HIDE|HT_CACHED},
X#else
X    {"newsgroups",	0,	0,	10,	HT_MAGIC|HT_HIDE},
X#endif
X    {"nntp-posting-host",0,	0,	17,	HT_HIDE		},
X    {"note",		0,	0,	4,	0,		},
X    {"organization",	0,	0,	12,	0		},
X    {"path",		0,	0,	4,	HT_HIDE		},
X    {"posted",		0,	0,	6,	HT_HIDE		},
X    {"posting-version",	0,	0,	15,	HT_HIDE		},
X    {"priority",	0,	0,	8,	HT_HIDE		},
X    {"reply-to",	0,	0,	8,	HT_HIDE		},
X    {"references",	0,	0,	10,	HT_HIDE		},
X    {"relay-version",	0,	0,	13,	HT_HIDE		},
X    {"sender",		0,	0,	6,	HT_HIDE		},
X    {"summary",		0,	0,	7,	0		},
X    {"subject",		0,	0,	7,	HT_MAGIC|HT_CACHED},
X    {"supersedes",	0,	0,	10,	0		},
X    {"slugword",	0,	0,	8,	HT_HIDE		},
X#ifdef DBM_XREFS
X    {"xref",		0,	0,	4,	HT_HIDE},
X#else
X    {"xref",		0,	0,	4,	HT_HIDE|HT_CACHED},
X#endif
X    {"x-supersedes",	0,	0,	12,	HT_HIDE		}
X};
X#endif
X
XEXT ART_NUM parsed_art INIT(0);		/* the article number we've parsed */
XEXT char in_header INIT(0);		/* are we decoding the header? */
XEXT char *headbuf;
XEXT long headbuf_size;
X
Xvoid	head_init _((void));
Xint	set_line_type _((char*,char*));
Xvoid	start_header _((ART_NUM));
Xvoid	end_header_line _((void));
Xvoid	end_header _((void));
Xbool    parseline _((char*,int,int));
Xbool	parseheader _((ART_NUM));
Xchar	*fetchlines _((ART_NUM,int));	/* returns a malloc'ed string */
Xchar	*prefetchlines _((ART_NUM,int,bool_int));
X
X#ifdef DEBUG
Xvoid	dumpheader _((char*));
X#endif
X
X#ifdef USE_NNTP
X#define PREFETCH_SIZE 5
X#endif
X
X#define fetchsubj(artnum,copy) prefetchlines(artnum,SUBJ_LINE,copy)
X#define fetchfrom(artnum,copy) prefetchlines(artnum,FROM_LINE,copy)
X#ifdef DBM_XREFS
X#define fetchxref(artnum,copy) prefetchlines(artnum,NGS_LINE,copy)
X#else
X#define fetchxref(artnum,copy) prefetchlines(artnum,XREF_LINE,copy)
X#endif
END_OF_FILE
if test 6341 -ne `wc -c <'head.h'`; then
    echo shar: \"'head.h'\" unpacked with wrong size!
fi
# end of 'head.h'
fi
if test -f 'init.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'init.c'\"
else
echo shar: Extracting \"'init.c'\" \(6289 characters\)
sed "s/^X//" >'init.c' <<'END_OF_FILE'
X/* $Id: init.c,v 3.0 1992/02/01 03:09:32 davison Trn $
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "util.h"
X#include "final.h"
X#include "term.h"
X#include "last.h"
X#include "trn.h"
X#include "rcstuff.h"
X#include "ngdata.h"
X#include "only.h"
X#include "intrp.h"
X#include "addng.h"
X#include "sw.h"
X#include "art.h"
X#include "artsrch.h"
X#include "artio.h"
X#include "backpage.h"
X#include "cache.h"
X#include "bits.h"
X#include "head.h"
X#include "help.h"
X#include "kfile.h"
X#include "ngsrch.h"
X#include "ngstuff.h"
X#include "rcln.h"
X#include "respond.h"
X#include "nntp.h"
X#include "rthread.h"
X#include "ng.h"
X#include "decode.h"
X#include "INTERN.h"
X#include "init.h"
X
Xbool
Xinitialize(argc,argv)
Xint argc;
Xchar *argv[];
X{
X    char *tcbuf;
X    register bool foundany = FALSE;
X#ifdef NOLINEBUF
X    static char std_out_buf[BUFSIZ];	/* must be static or malloced */
X
X    setbuf(stdout, std_out_buf);
X#endif
X
X    tcbuf = safemalloc(1024);		/* make temp buffer for termcap and */
X					/* other initialization stuff */
X    
X    our_pid = getpid();
X
X    /* init terminal */
X    
X    term_init();			/* must precede sw_init() so that */
X					/* ospeed is set for baud-rate */
X					/* switches.  Actually terminal */
X					/* mode setting is in term_set() */
X
X    /* init syntax etc. for searching (must also precede sw_init()) */
X
X    search_init();
X
X    /* we have to know rnlib to look up global switches in %X/INIT */
X
X    homedir = getenv("HOME");
X    if (homedir == Nullch)
X	homedir = getenv("LOGDIR");
X    lib = savestr(filexp(NEWSLIB));
X    rnlib = savestr(filexp(PRIVLIB));
X
X    /* decode switches */
X
X    sw_init(argc,argv,&tcbuf);          /* must not do % interps! */
X					/* (but may mung environment) */
X
X    /* init signals, status flags */
X
X    final_init();
X    
X    /* start up file expansion and the % interpreter */
X
X    intrp_init(tcbuf);
X    
X    /* now make sure we have a current working directory */
X
X    if (!checkflag)
X	cwd_check();
X    
X    /* now that we know where to save things, cd to news directory */
X
X    if (chdir(spool)) {
X	printf(nocd,spool) FLUSH;
X	finalize(1);
X    }
X
X    /* if we aren't just checking, turn off echo */
X
X    if (!checkflag)
X	term_set(tcbuf);
X
X    /* get info on last rn run, if any */
X
X    if (!checkflag)
X	last_init(tcbuf);
X
X    free(tcbuf);			/* recover 1024 bytes */
X
X    /* make sure we are the sole possessors of .newsrc */
X
X    if (!checkflag)
X	lock_check();
X
X    /* check for news news */
X
X    if (!checkflag)
X	newsnews_check();
X
X#ifdef USE_NNTP
X
X    /* open connection to server if appropriate */
X    nntp_connect();
X
X#endif
X
X    /* open active file, etc. */
X
X    ngdata_init();
X
X    /* now read in the .newsrc file */
X
X    foundany = rcstuff_init();
X
X    /* it looks like we will actually read something, so init everything */
X
X    addng_init();
X    art_init();
X    artio_init();
X    artsrch_init();
X    backpage_init();
X    bits_init();
X    cache_init();
X    head_init();
X    help_init();
X    kfile_init();
X    ng_init();
X    ngsrch_init();
X    ngstuff_init();
X    only_init();
X    rcln_init();
X    respond_init();
X    rn_init();
X    decode_init();
X    thread_init();
X    util_init();
X
X#ifdef FINDNEWNG
X	/*
X	 * Skip this check if the -q flag was given.
X	 */
X    if (!quickstart) {
X	if (find_new_groups()) {	/* did we add any new groups? */
X	    foundany = TRUE;		/* let main() know */
X	    starthere = 0;		/* start ng scan from the top */
X	}
X    }
X#endif
X    time(&lasttime);			/* remember when we inited-- */
X					/* ends up back in .rnlast */
X    writelast();			/* in fact, put it there now */
X
X#ifdef FINDNEWNG
X# ifdef ONLY
X    if (maxngtodo)			/* patterns on command line? */
X	foundany |= scanactive();
X# endif
X#endif
X
X    return foundany;
X}
X
X/* make sure there is no rn out there already */
X
Xvoid
Xlock_check()
X{
X    lockname = savestr(filexp(LOCKNAME));
X    if (!checkflag) {
X	tmpfp = fopen(lockname,"r");
X	if (tmpfp != Nullfp) {
X	    int processnum;
X    
X	    fgets(buf,LBUFLEN,tmpfp);
X	    fclose(tmpfp);
X	    processnum = atoi(buf);
X#ifdef VERBOSE
X	    IF(verbose)
X		printf("You seem to have left a trn running, process %d.\n",
X		    processnum) FLUSH;
X	    ELSE
X#endif
X#ifdef TERSE
X		printf("Trn left running, #%d.\n", processnum) FLUSH;
X#endif
X	    if (kill(processnum, 0)) {    /* does process not exist? */
X		sleep(2);
X#ifdef VERBOSE
X		IF(verbose)
X		    fputs("\n\
XThat process does not seem to exist anymore.  The count of read articles\n\
Xmay be incorrect in the last newsgroup accessed by that other (defunct)\n\
Xprocess.\n\n",stdout) FLUSH;
X		ELSE
X#endif
X#ifdef TERSE
X		    fputs("\nProcess crashed.\n",stdout) FLUSH;
X#endif
X		if (*lastngname) {
X#ifdef VERBOSE
X		    IF(verbose)
X			printf("(The last newsgroup accessed was %s.)\n\n",
X			lastngname) FLUSH;
X		    ELSE
X#endif
X#ifdef TERSE
X			printf("(In %s.)\n\n",lastngname) FLUSH;
X#endif
X		}
X		get_anything();
X		putchar('\n') FLUSH;
X	    }
X	    else {
X#ifdef VERBOSE
X		IF(verbose)
X		    fputs("\n\
XYou may not have two copies of [t]rn running simultaneously.  Goodbye.\n\
X",stdout) FLUSH;
X		ELSE
X#endif
X#ifdef TERSE
X		    fputs("\nCan't start another.\n",stdout) FLUSH;
X#endif
X               if (bizarre)
X                 resetty();
X		exit(0);
X	    }
X	}
X	tmpfp = fopen(lockname,"w");
X	if (tmpfp == Nullfp) {
X	    printf(cantcreate,lockname) FLUSH;
X	    sig_catcher(0);
X	}
X	fprintf(tmpfp,"%ld\n",our_pid);
X	fclose(tmpfp);
X    }
X}
X
Xvoid
Xnewsnews_check()
X{
X    char *newsnewsname = filexp(NEWSNEWSNAME);
X
X    if ((tmpfp = fopen(newsnewsname,"r")) != Nullfp) {
X	fstat(fileno(tmpfp),&filestat);
X	if (filestat.st_mtime > lasttime) {
X	    while (fgets(buf,sizeof(buf),tmpfp) != Nullch)
X		fputs(buf,stdout) FLUSH;
X	    get_anything();
X	    putchar('\n') FLUSH;
X	}
X	fclose(tmpfp);
X    }
X}
END_OF_FILE
if test 6289 -ne `wc -c <'init.c'`; then
    echo shar: \"'init.c'\" unpacked with wrong size!
fi
# end of 'init.c'
fi
if test -f 'makedepend.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makedepend.SH'\"
else
echo shar: Extracting \"'makedepend.SH'\" \(2446 characters\)
sed "s/^X//" >'makedepend.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X    '') . ./config.sh ;;
Xesac
Xecho "Extracting makedepend (with variable substitutions)"
X$spitshell >makedepend <<!GROK!THIS!
X$startsh
X# $Id: makedepend.SH,v 3.0 1991/09/09 20:23:31 davison Trn $
X# 
X# This software is Copyright 1991 by Stan Barber. 
X#
X# Permission is hereby granted to copy, reproduce, redistribute or otherwise
X# use this software as long as: there is no monetary profit gained
X# specifically from the use or reproduction of this software, it is not
X# sold, rented, traded or otherwise marketed, and this copyright notice is
X# included prominently in any copy made. 
X#
X# The author make no claims as to the fitness or correctness of this software
X# for any use whatsoever, and it is provided as is. Any use of this software
X# is at the user's own risk. 
Xexport PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
X
X$cat /dev/null >.deptmp
X$echo "(Note: this is going to take a while.)"
Xfor file in *.[cy]; do
X    case "\$file" in
X    *.c) filebase=\`basename \$file .c\`;;
X    *.y) filebase=\`basename \$file .y\`;;
X    esac
X    $echo "Finding dependencies for \$filebase.o."
X    $sed -n <\$file \\
X	-e "/^\${filebase}_init(/q" \\
X	-e '/^#/{' \\
X	-e 's|/\*.*$||' \\
X	-e 's/\\\\[ 	]*$//' \\
X	-e p \\
X	-e '}' | $cppstdin -I/usr/local/include | $sed \\
X	-e '/^# *line/s/line//' \
X	-e '/^# *[0-9]/!d' \\
X	-e 's/^.*"\(.*\)".*\$/'\$filebase'.o: \1/' \\
X	-e 's|: \./|: |' \\
X	-e 's/: .*\.c/: '\$file'/' | \\
X	$uniq | $sort | $uniq >> .deptmp
Xdone
X
Xfor file in *.SH; do
X    $echo \`basename \$file .SH\`: \$file config.sh \; /bin/sh \$file >> .deptmp
Xdone
X
X$sed <Makefile >Makefile.new -e '1,/^# AUTOMATICALLY/!d'
X
Xif $test -s .deptmp; then
X    echo "Updating Makefile..."
X    $sed -e 's/\\\$/\$\$/g' .deptmp | $egrep -v $usrinc >dependencies
Xelse
X    $echo "You don't seem to have a proper C preprocessor.  Using grep instead."
X    $egrep '^#include ' *.[cyh] ?.[cyh] >.deptmp
X    echo "Updating Makefile..."
X    <.deptmp $sed -n 's|c:#include "\(.*\)".*\$\$|o: \1|p' > dependencies
X    <.deptmp $sed -n 's|y:#include "\(.*\)".*\$\$|o: \1|p' >> dependencies
X    <.deptmp $sed -n 's|h:#include "\(.*\)".*\$\$|h: \1|p' >> dependencies
Xfi
X$echo "# WARNING: Put nothing here or make depend will gobble it up!" >> dependencies
X$mv Makefile Makefile.old
X$mv Makefile.new Makefile
X$cat dependencies >>Makefile
Xrm .deptmp
X!GROK!THIS!
X$eunicefix makedepend
Xchmod 755 makedepend
END_OF_FILE
if test 2446 -ne `wc -c <'makedepend.SH'`; then
    echo shar: \"'makedepend.SH'\" unpacked with wrong size!
fi
chmod +x 'makedepend.SH'
# end of 'makedepend.SH'
fi
if test -f 'newsetup.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsetup.SH'\"
else
echo shar: Extracting \"'newsetup.SH'\" \(3184 characters\)
sed "s/^X//" >'newsetup.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X    '') . ./config.sh ;;
Xesac
Xecho "Extracting newsetup (with variable substitutions)"
X$spitshell >newsetup <<!GROK!THIS!
X$startsh
X# $Id: newsetup.SH,v 3.0 1992/02/01 03:09:32 davison Trn $
X# 
X# This software is Copyright 1991 by Stan Barber. 
X#
X# Permission is hereby granted to copy, reproduce, redistribute or otherwise
X# use this software as long as: there is no monetary profit gained
X# specifically from the use or reproduction of this software, it is not
X# sold, rented, traded or otherwise marketed, and this copyright notice is
X# included prominently in any copy made. 
X#
X# The author make no claims as to the fitness or correctness of this software
X# for any use whatsoever, and it is provided as is. Any use of this software
X# is at the user's own risk. 
X
Xexport PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
X
X: syntax: newsetup
X
Xcase $d_portable in
Xdefine)
X    # where recordings, distributions and moderators are kept
X    lib=\`$filexp $newslib\`
X    # where important rn things are kept
X    rnlib=\`$filexp $privlib\`
X    ;;
Xundef)
X    # where recordings, distributions and moderators are kept
X    lib="$newslib"
X    # where important rn things are kept
X    rnlib="$privlib"
X    ;;
Xesac
X
Xtest=${test-test}
Xecho=${echo-echo}
Xcat=${cat-cat}
Xmv=${mv-mv}
Xrm=${rm-rm}
X
X!GROK!THIS!
X$cat >>newsetup <<'!NO!SUBS!'
Xdotdir="${DOTDIR-${HOME-$LOGDIR}}"
Xnewsrc="${NEWSRC-$dotdir/.newsrc}"
Xtmp="${TMPDIR-/tmp}"
X
Xsubs="$lib/subscriptions"
Xtmpsubs="$tmp/trnsubs.$$"
X
X$cat <<'EOH'
X
XWelcome to trn.  Here's some important things to remember:
X
X  o  Trn is an extension of rn and has a similar command syntax.
X  o  To access all the new features, specify the options -x and -X.  These
X     options MAY be on by default, but it won't hurt to be redundant.
X  o  Single-character commands don't require a carriage return -- only
X     commands that let you type in an argument.
X  o  At ANY prompt, you may type 'h' for help.  There are many different help
X     menus, depending on the context.  Also, typing <esc>h in the middle of a
X     multi-character command will list escape substitutions.
X  o  Typing a space to any prompt means to do the normal thing.  You could
X     spend all day reading news and never hit anything but the space bar.
X  o  If you have never used the news system before, you may find the articles
X     in news.announce.newusers to be helpful.
X  o  Please consult the man page for complete information.
X
XEOH
X
X$rm -f $newsrc-old
X$echo "Creating $newsrc to be used by news programs."
X
Xif $test -s "$newsrc"; then
X    $echo "Saving your current one as $newsrc-old..."
X    $mv -f $newsrc $newsrc-old
Xfi
X
Xif $test -r $subs; then
X    cp $subs $newsrc
Xelse
X    if $test -r $rnlib/getactive; then
X	$rnlib/getactive subscriptions $tmpsubs >/dev/null 2>&1
X    fi
X    if $test -s $tmpsubs; then
X	cp $tmpsubs $newsrc
X    else
X	$cat <<EOM >$newsrc
Xnews.announce.newusers: 
XEOM
X    fi
X    $rm -f $tmpsubs
Xfi
X
X$cat <<'EOH'
XDone.
X
XTo add new group use "a pattern" or "g newsgroup.name".  To get rid of
Xnewsgroups you aren't interested in, use the 'u' command.
XEOH
X!NO!SUBS!
X$eunicefix newsetup
Xchmod 755 newsetup
END_OF_FILE
if test 3184 -ne `wc -c <'newsetup.SH'`; then
    echo shar: \"'newsetup.SH'\" unpacked with wrong size!
fi
chmod +x 'newsetup.SH'
# end of 'newsetup.SH'
fi
if test -f 'newsgroups.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsgroups.SH'\"
else
echo shar: Extracting \"'newsgroups.SH'\" \(2581 characters\)
sed "s/^X//" >'newsgroups.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X    '') . ./config.sh ;;
Xesac
Xecho "Extracting newsgroups (with variable substitutions)"
X$spitshell >newsgroups <<!GROK!THIS!
X$startsh
X# $Id: newsgroups.SH,v 3.0 1992/02/01 03:09:32 davison Trn $
X# 
X# This software is Copyright 1991 by Stan Barber. 
X#
X# Permission is hereby granted to copy, reproduce, redistribute or otherwise
X# use this software as long as: there is no monetary profit gained
X# specifically from the use or reproduction of this software, it is not
X# sold, rented, traded or otherwise marketed, and this copyright notice is
X# included prominently in any copy made. 
X#
X# The author make no claims as to the fitness or correctness of this software
X# for any use whatsoever, and it is provided as is. Any use of this software
X# is at the user's own risk. 
X
Xexport PATH || (echo "OOPS, this isn't sh.  Desperation time.  I will feed myself to sh."; sh \$0; kill \$\$)
X
X: syntax: newsgroups [pattern] [pipeflag]
X
X: System Dependencies
X
X: You might want to change pager to a "make column" program if you have one.
X: On the other hand, if your kernel does paging, cat would probably do.
Xpager="${pager-/usr/ucb/more}"
X#NORMALactive="${active-/usr/lib/news/active}"
X
X#NORMALcase \$active in
X#NORMAL~*) active=\`$filexp \$active\` ;;
X#NORMALesac
X#NNTP
X#NNTPactive="/tmp/active.\$\$"
X#NNTPrnlib=$privlib
X#NNTPcase \$rnlib in
X#NNTP~*) rnlib=\`$filexp \$rnlib\` ;;
X#NNTPesac
X
X: End of system dependencies, hopefully
X#NNTP
X#NNTPif \$rnlib/getactive ACTIVE \$active; then
X#NNTP    true;
X#NNTPelse
X#NNTP    exit 1;
X#NNTPfi
X
Xif $test \$# -ge 2 ; then
X    pager=$cat
Xelse
X    $echo "Completely unsubscribed newsgroups:"
Xfi
X
Xdotdir=\${DOTDIR-\${HOME-\$LOGDIR}}
Xnewsrc=\${NEWSRC-\$dotdir/.newsrc}
X
X: Throwing .newsrc into the pot twice is a lovely hack to prevent
X: bogus newsgroups from showing up as unsubscribed.
X
X$cat \$newsrc \$newsrc \$active | \\
X$sed -n	-e '/^options/d' \\
X	-e '/^[	 ]/d' \\
X	-e '/^control/d' \\
X	-e '/^to\./d' \\
X 	-e '/ x\$/d' \\
X	-e 's/^\([^ !:]*\)[ !:].*\$/\1/' \\
X	-e "/.*\$1/p" | \\
X$sort | $uniq -u | \$pager
X#NNTP$rm -f \$active
Xif $test \$# -ge 2 ; then
X    exit
Xfi
X$echo $n "[Type return to continue] $c"
Xread tmp
X$echo ""
X$echo "Unsubscribed but mentioned in \$newsrc:"
X$sed -n < \$newsrc \\
X	-e "/\$1.*!/"'s/^\([^!]*\)!.*\$/\1/p' | \\
X$sort | \$pager
X!GROK!THIS!
Xcase "$d_nntp" in
Xdefine)  sed < newsgroups -e '/^#NNTP/s/^#NNTP//' -e '/^#NORMAL/d' > newsgroups.new ;;
X*) sed < newsgroups -e '/^#NNTP/d' -e '/^#NORMAL/s/^#NORMAL//' > newsgroups.new ;;
Xesac
Xmv newsgroups.new newsgroups
X$eunicefix newsgroups
Xchmod 755 newsgroups
END_OF_FILE
if test 2581 -ne `wc -c <'newsgroups.SH'`; then
    echo shar: \"'newsgroups.SH'\" unpacked with wrong size!
fi
chmod +x 'newsgroups.SH'
# end of 'newsgroups.SH'
fi
if test -f 'ngdata.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ngdata.c'\"
else
echo shar: Extracting \"'ngdata.c'\" \(6260 characters\)
sed "s/^X//" >'ngdata.c' <<'END_OF_FILE'
X/* $Id: ngdata.c,v 3.0 1992/02/01 03:09:32 davison Trn $
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "rcstuff.h"
X#include "trn.h"
X#include "cache.h"
X#include "bits.h"
X#include "head.h"
X#include "rthread.h"
X#include "rt-select.h"
X#include "ng.h"
X#include "intrp.h"
X#include "kfile.h"
X#include "final.h"
X#include "rcln.h"
X#include "term.h"
X#include "util.h"
X#include "nntp.h"
X#include "ndir.h"
X#include "INTERN.h"
X#include "ngdata.h"
X
X/* open the active file */
X
Xvoid
Xngdata_init()
X{
X    ngdatahash_init();
X    if (fseek(actfp,0L,0) == -1) {	/* just get to the beginning */
X	printf("Error seeking in active file.\n") FLUSH;
X	finalize(1);
X    }
X}
X
Xbool
Xaccess_ng()
X{
X#ifdef USE_NNTP
X    ART_NUM old_first = abs1st[ng];
X
X    if (!nntp_group(ngname,ng)) {
X	toread[ng] = TR_BOGUS;
X	return FALSE;
X    }
X    if ((lastart = getngsize(ng)) < 0)	/* this cannot happen (laugh here) */
X	return FALSE;
X    absfirst = abs1st[ng];
X    lastart = ngmax[ng];
X    if (absfirst > old_first)
X	checkexpired(ng);
X#else /* !USE_NNTP */
X
X    if (eaccess(ngdir,5)) {		/* directory read protected? */
X	if (eaccess(ngdir,0)) {
X# ifdef VERBOSE
X	    IF(verbose)
X		printf("\nNewsgroup %s does not have a spool directory!\n",
X		    ngname) FLUSH;
X	    ELSE
X# endif
X# ifdef TERSE
X		printf("\nNo spool for %s!\n",ngname) FLUSH;
X# endif
X# ifdef CATCHUP
X	    catch_up(ng);
X# endif
X	} else {
X# ifdef VERBOSE
X	    IF(verbose)
X		printf("\nNewsgroup %s is not currently accessible.\n",
X		    ngname) FLUSH;
X	    ELSE
X# endif
X# ifdef TERSE
X		printf("\n%s not readable.\n",ngname) FLUSH;
X# endif
X	}
X	toread[ng] = TR_NONE; /* make this newsgroup temporarily invisible */
X	return FALSE;
X    }
X
X    /* chdir to newsgroup subdirectory */
X
X    if (chdir(ngdir)) {
X	printf(nocd,ngdir) FLUSH;
X	return FALSE;
X    }
X    if ((lastart = getngsize(ng)) < 0)	/* this cannot happen (laugh here) */
X	return FALSE;
X    absfirst = abs1st[ng];
X    setfoundbits();			/* might reset absfirst */
X#endif /* !USE_NNTP */
X
X    dmcount = 0;
X
X    build_cache();
X    return TRUE;
X}
X
Xvoid
Xgrow_ng(newlast)
XART_NUM newlast;
X{
X    ART_NUM tmpfirst;
X
X    forcegrow = FALSE;
X    if (newlast > lastart) {
X	ART_NUM tmpart = art;
X	toread[ng] += (ART_UNREAD)(newlast-lastart);
X	grow_cache(newlast);
X	tmpfirst = lastart+1;
X	lastart = newlast;
X	thread_grow();
X#ifdef KILLFILES
X#ifdef VERBOSE
X	IF(verbose)
X	    sprintf(buf,
X		"%ld more article%s arrived -- processing memorized commands...\n\n",
X		(long)(lastart - tmpfirst + 1),
X		(lastart > tmpfirst ? "s have" : " has" ) );
X	ELSE			/* my, my, how clever we are */
X#endif
X#ifdef TERSE
X	    strcpy(buf, "More news -- auto-processing...\n\n");
X#endif
X	if (has_normal_kills)
X	    kill_unwanted(tmpfirst,buf,TRUE);
X#endif
X	art = tmpart;
X    }
X}
X
Xvoid
Xng_skip()
X{
X#ifndef USE_NNTP			/* never read it & cannot find it? */
X    if (errno != ENOENT) {	/* has it not been deleted? */
X	clear();
X# ifdef VERBOSE
X	IF(verbose)
X	    printf("\n(Article %ld exists but is unreadable.)\n",(long)art)
X		FLUSH;
X	ELSE
X# endif
X# ifdef TERSE
X	    printf("\n(%ld unreadable.)\n",(long)art) FLUSH;
X# endif
X	if (novice_delays) {
X	    pad(just_a_sec);
X	    sleep(2);
X	}
X    }
X    inc_art(selected_only,FALSE);	/* try next article */
X
X#else /* USE_NNTP */
X    ART_NUM artnum;
X
X    clear();
X# ifdef VERBOSE
X    IF(verbose)
X	fputs("Skipping unavailable article\n",stdout);
X    ELSE
X# endif /* VERBOSE */
X# ifdef TERSE
X	fputs("Skipping\n",stdout);
X# endif /* TERSE */
X    if (novice_delays) {
X	pad(just_a_sec/3);
X	sleep(1);
X    }
X    art++;
X    artp++;
X    do {
X	/* tries to grab PREFETCH_SIZE XHDRS, flagging missing articles */
X	(void) fetchsubj(art, FALSE);
X	artnum = art+PREFETCH_SIZE-1;
X	if (artnum > lastart)
X	    artnum = lastart;
X	while (art <= artnum) {
X	    if (!(artp->flags & AF_MISSING))
X		return;
X	    art++;
X	    artp++;
X	}
X    } while (art <= lastart);
X#endif /* USE_NNTP */
X}
X
X/* find the maximum article number of a newsgroup */
X
XART_NUM
Xgetngsize(num)
Xregister NG_NUM num;
X{
X    register int len;
X    register char *nam;
X    char tmpbuf[LBUFLEN];
X    ART_POS oldsoft;
X    long last, first;
X    char ch;
X
X    nam = rcline[num];
X    len = rcnums[num] - 1;
X    softtries++;
X#ifdef DEBUG
X    if (debug & DEB_SOFT_POINTERS)
X	printf("Softptr = %ld\n",(long)softptr[num]) FLUSH;
X#endif
X    oldsoft = softptr[num];
X#ifndef USE_NNTP
X    fseek(actfp,100000L,1);	/* hopefully this forces a reread */
X#endif
X    if ((softptr[num] = findact(tmpbuf, nam, len, (long)oldsoft)) >= 0) {
X	if (softptr[num] != oldsoft) {
X	    softmisses++;
X	    writesoft = TRUE;
X	}
X    }
X    else {
X	softptr[num] = 0;
X	if (RCCHAR(rcchar[num]) == ':')
X	    rcchar[num] = NEGCHAR;
X	return TR_BOGUS;
X    }
X	
X#ifdef DEBUG
X    if (debug & DEB_SOFT_POINTERS) {
X	printf("Should be %ld\n",(long)softptr[num]) FLUSH;
X    }
X#endif
X#ifndef ANCIENT_NEWS
X    sscanf(tmpbuf+len+1, "%ld %ld %c", &last, &first, &ch);
X#else
X    sscanf(tmpbuf+len+1, "%ld %c", &last, &ch);
X    first = 1;
X#endif
X    if (!abs1st[num])
X	abs1st[num] = (ART_NUM)first;
X    if (!in_ng) {
X	if (redirected) {
X	    if (redirected != nullstr)
X		free(redirected);
X	    redirected = Nullch;
X	}
X	switch (ch) {
X	case 'n':
X	    moderated = getval("NOPOSTRING"," (no posting)");
X	    break;
X	case 'm':
X	    moderated = getval("MODSTRING", " (moderated)");
X	    break;
X	case 'x':
X	    redirected = nullstr;
X	    moderated = " (DISABLED)";
X	    break;
X	case '=':
X	    len = strlen(tmpbuf);
X	    if (tmpbuf[len-1] == '\n')
X		tmpbuf[len-1] = '\0';
X	    redirected = savestr(rindex(tmpbuf, '=') + 1);
X	    moderated = " (REDIRECTED)";
X	    break;
X	default:
X	    moderated = nullstr;
X	    break;
X	}
X    }
X    if (last < ngmax[num])
X	return ngmax[num];
X    return ngmax[num] = (ART_NUM)last;
X}
END_OF_FILE
if test 6260 -ne `wc -c <'ngdata.c'`; then
    echo shar: \"'ngdata.c'\" unpacked with wrong size!
fi
# end of 'ngdata.c'
fi
if test -f 'ngsrch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ngsrch.c'\"
else
echo shar: Extracting \"'ngsrch.c'\" \(3351 characters\)
sed "s/^X//" >'ngsrch.c' <<'END_OF_FILE'
X/* $Id: ngsrch.c,v 3.0 1992/02/01 03:09:32 davison Trn $
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "rcstuff.h"
X#include "final.h"
X#include "search.h"
X#include "trn.h"
X#include "util.h"
X#include "term.h"
X#include "rcln.h"
X#include "INTERN.h"
X#include "ngsrch.h"
X
X#ifdef NGSEARCH
XCOMPEX ngcompex;
X#endif
X
Xvoid
Xngsrch_init()
X{
X#ifdef NGSEARCH
X    init_compex(&ngcompex)
X#endif
X    ;
X}
X
X#ifdef NGSEARCH
Xint
Xng_search(patbuf,get_cmd)
Xchar *patbuf;				/* if patbuf != buf, get_cmd must */
Xint get_cmd;				/*   be set to FALSE!!! */
X{
X    char *pattern;			/* unparsed pattern */
X    register char cmdchr = *patbuf;	/* what kind of search? */
X    register char *s;
X    bool backward = cmdchr == '?';	/* direction of search */
X
X    int_count = 0;
X    if (get_cmd && buf == patbuf)
X	if (!finish_command(FALSE))		/* get rest of command */
X	    return NGS_ABORT;
X    for (pattern = patbuf+1; *pattern == ' '; pattern++) ;
X    if (*pattern) {
X	ng_doread = FALSE;
X    }
X    s = rindex(pattern,cmdchr);
X    if (s != Nullch && *(s-1) != '\\') {
X	*s++ = '\0';
X	if (index(s,'r') != Nullch)
X	    ng_doread = TRUE;
X    }
X    if ((s = ng_comp(&ngcompex,pattern,TRUE,TRUE)) != Nullch) {
X					/* compile regular expression */
X	printf("\n%s\n",s) FLUSH;
X	return NGS_ERROR;
X    }
X    fputs("\nSearching...",stdout) FLUSH;	/* give them something to read */
X    fflush(stdout);
X    for (;;) {
X	if (int_count) {
X	    int_count = 0;
X	    return NGS_INTR;
X	}
X	if (backward) {
X	    if (ng > 0)
X		--ng;
X	    else
X		ng = nextrcline;
X	}
X	else {
X	    if (ng >= nextrcline)
X		ng = 0;
X	    else
X		++ng;
X	}
X	if (ng == current_ng)
X	    return NGS_NOTFOUND;
X	if (ng == nextrcline || toread[ng] < TR_NONE || !ng_wanted())
X	    continue;
X	if (toread[ng] == TR_NONE)
X	    set_toread(ng);
X	
X	if (toread[ng] > TR_NONE)
X	    return NGS_FOUND;
X	else if (toread[ng] == TR_NONE)
X	    if (ng_doread)
X		return NGS_FOUND;
X	    else
X		printf("\n[0 unread in %s -- skipping]",rcline[ng]) FLUSH;
X    }
X}
X
Xbool
Xng_wanted()
X{
X    return execute(&ngcompex,rcline[ng]) != Nullch;
X}
X#endif /* NGSEARCH */
X
X#ifdef NGSORONLY
Xchar *
Xng_comp(compex,pattern,RE,fold)
XCOMPEX *compex;
Xchar *pattern;
Xbool_int RE;
Xbool_int fold;
X{
X    char ng_pattern[128];
X    register char *s = pattern, *d = ng_pattern;
X
X    if (!*s) {
X	if (compile(compex, "", RE, fold))
X	    return "No previous search pattern";
X	else
X	    return Nullch;			/* reuse old pattern */
X    }
X    for (; *s; s++) {
X	if (*s == '.') {
X	    *d++ = '\\';
X	    *d++ = *s;
X	}
X	else if (*s == '?') {
X	    *d++ = '.';
X	}
X	else if (*s == '*') {
X	    *d++ = '.';
X	    *d++ = *s;
X	}
X	else if (strnEQ(s,"all",3)) {
X	    *d++ = '.';
X	    *d++ = '*';
X	    s += 2;
X	}
X	else
X	    *d++ = *s;
X    }
X    *d = '\0';
X    return compile(compex,ng_pattern,RE,fold);
X}
X#endif
X
END_OF_FILE
if test 3351 -ne `wc -c <'ngsrch.c'`; then
    echo shar: \"'ngsrch.c'\" unpacked with wrong size!
fi
# end of 'ngsrch.c'
fi
if test -f 'nntpclient.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nntpclient.c'\"
else
echo shar: Extracting \"'nntpclient.c'\" \(3423 characters\)
sed "s/^X//" >'nntpclient.c' <<'END_OF_FILE'
X/* $Id: nntpclient.c,v 3.0 1991/11/22 04:12:21 davison Trn $
X*/
X/* The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X
X#ifdef USE_NNTP
X
X#include "INTERN.h"
X#include "nntpclient.h"
X
X#define CANTPOST	\
X	"NOTE:  This machine does not have permission to post articles.\n"
X#define CANTUSE		\
X	"This machine does not have permission to use the %s news server.\n"
X
Xvoid
Xnntp_connect()
X{
X    char *server, filebuf[128];
X    int response;
X
X    if ((server = getenv("NNTPSERVER")) == Nullch)
X	server = SERVER_NAME;
X    if (server[0] == '/') {
X	register FILE *fp;
X	if ((fp = fopen(server, "r")) != Nullfp) {
X	    server = Nullch;
X	    while (fgets(filebuf, sizeof filebuf, fp) != Nullch) {
X		if (*filebuf == '\n' || *filebuf == '#')
X		    continue;
X		if ((server = index(filebuf, '\n')) != Nullch)
X		    *server = '\0';
X		server = filebuf;
X		break;
X	    }
X	    fclose(fp);
X	} else
X	    server = Nullch;
X	if (server == Nullch) {
X	    sprintf(ser_line, "\
XCouldn't get name of news server from %s\n\
XEither fix this file, or put NNTPSERVER in your environment.\n", SERVER_NAME);
X	    fatal_error(ser_line);
X	}
X    }
X
X    switch (response = server_init(server)) {
X    case NNTP_GOODBYE_VAL:
X	if (atoi(ser_line) == response) {
X	    char tmpbuf[LBUFLEN];
X	    sprintf(tmpbuf,"News server %s unavailable: %s\n",server,&ser_line[4]);
X	    fatal_error(tmpbuf);
X	}
X    case -1:
X	sprintf(ser_line,"News server %s unavailable, try again later.\n",server);
X	fatal_error(ser_line);
X    case NNTP_ACCESS_VAL:
X	sprintf(ser_line,CANTUSE,server);
X	fatal_error(ser_line);
X	/* NOT REACHED */
X    case NNTP_NOPOSTOK_VAL:
X	advise(CANTPOST);
X	/* FALL THROUGH */
X    case NNTP_POSTOK_VAL:
X	break;
X    default:
X	sprintf(ser_line,"Unknown response code %d from %s.\n", response, server);
X	fatal_error(ser_line);
X    }
X}
X
Xvoid
Xnntp_command(buf)
Xchar *buf;
X{
X#ifdef DEBUG
X    if (debug & DEB_NNTP)
X	printf(">%s\n", buf) FLUSH;
X#endif
X    fprintf(ser_wr_fp, "%s\r\n", buf);
X    fflush(ser_wr_fp);
X}
X
Xchar
Xnntp_check(strict)
Xbool_int strict;
X{
X    int n;
X
X#ifdef HAS_SIGHOLD
X    sighold(SIGINT);
X#endif
X    n = (fgets(ser_line, sizeof ser_line, ser_rd_fp) == NULL)? -1 : 0;
X#ifdef HAS_SIGHOLD
X    sigrelse(SIGINT);
X#endif
X    if (n < 0)
X	fatal_error("\nUnexpected close of server socket.\n");
X    n = strlen(ser_line);
X    if (n >= 2 && ser_line[n-1] == '\n' && ser_line[n-2] == '\r')
X	ser_line[n-2] = '\0';
X#ifdef DEBUG
X    if (debug & DEB_NNTP)
X	printf("<%s\n", ser_line) FLUSH;
X#endif
X    if (strict && *ser_line == NNTP_CLASS_FATAL) {	/* Fatal error */
X	char tmpbuf[LBUFLEN];
X	sprintf(tmpbuf,"\n%s\n",ser_line);
X	fatal_error(tmpbuf);
X    }
X    return *ser_line;
X}
X
Xint
Xnntp_gets(buf, len)
Xchar *buf;
Xint  len;
X{
X    int n;
X
X#ifdef HAS_SIGHOLD
X    sighold(SIGINT);
X#endif
X    n = (fgets(buf, len, ser_rd_fp) == NULL)? -1 : 0;
X#ifdef HAS_SIGHOLD
X    sigrelse(SIGINT);
X#endif
X    if (n < 0)
X	fatal_error("\nUnexpected close of server socket.\n");
X    n = strlen(buf);
X    if (n >= 2 && buf[n-1] == '\n' && buf[n-2] == '\r')
X	buf[n-2] = '\0';
X    return 0;
X}
X
Xvoid
Xnntp_close()
X{
X    if (ser_wr_fp != NULL && ser_rd_fp != NULL) {
X	nntp_command("QUIT");
X	fclose(ser_wr_fp);
X	ser_wr_fp = NULL;
X
X	nntp_check(FALSE);
X	fclose(ser_rd_fp);
X	ser_rd_fp = NULL;
X    }
X}
X
X#endif /* USE_NNTP */
END_OF_FILE
if test 3423 -ne `wc -c <'nntpclient.c'`; then
    echo shar: \"'nntpclient.c'\" unpacked with wrong size!
fi
# end of 'nntpclient.c'
fi
if test -f 'only.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'only.c'\"
else
echo shar: Extracting \"'only.c'\" \(2817 characters\)
sed "s/^X//" >'only.c' <<'END_OF_FILE'
X/* $Id: only.c,v 3.0 1991/09/09 20:23:31 davison Trn $
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "search.h"
X#include "util.h"
X#include "final.h"
X#include "ngsrch.h"
X#include "INTERN.h"
X#include "only.h"
X
Xvoid
Xonly_init()
X{
X    ;
X}
X
Xvoid
Xsetngtodo(pat)
Xchar *pat;
X{
X#ifdef ONLY
X#ifdef SPEED_OVER_MEM
X    char *s;
X#endif
X
X    if (!*pat)
X	return;
X    if (maxngtodo < NGMAX) {
X	ngtodo[maxngtodo] = savestr(pat);
X#ifdef SPEED_OVER_MEM
X#ifndef lint
X	compextodo[maxngtodo] = (COMPEX*)safemalloc(sizeof(COMPEX));
X#endif /* lint */
X	init_compex(compextodo[maxngtodo]);
X	compile(compextodo[maxngtodo],pat,TRUE,TRUE);
X	if ((s = ng_comp(compextodo[maxngtodo],pat,TRUE,TRUE)) != Nullch) {
X					    /* compile regular expression */
X	    printf("\n%s\n",s) FLUSH;
X	    finalize(1);
X	}
X#endif
X	maxngtodo++;
X    }
X#else
X    notincl("o");
X#endif
X}
X
X/* if command line list is non-null, is this newsgroup wanted? */
X
Xbool
Xinlist(ngnam)
Xchar *ngnam;
X{
X#ifdef ONLY
X    register int i;
X#ifdef SPEED_OVER_MEM
X
X    if (maxngtodo == 0)
X	return TRUE;
X    for (i=0; i<maxngtodo; i++) {
X	if (execute(compextodo[i],ngnam))
X	    return TRUE;
X    }
X    return FALSE;
X#else
X    COMPEX ilcompex;
X    char *s;
X
X    if (maxngtodo == 0)
X	return TRUE;
X    init_compex(&ilcompex);
X    for (i=0; i<maxngtodo; i++) {
X	if ((s = ng_comp(&ilcompex,ngtodo[i],TRUE,TRUE)) != Nullch) {
X					    /* compile regular expression */
X	    printf("\n%s\n",s) FLUSH;
X	    finalize(1);
X	}
X	
X	if (execute(&ilcompex,ngnam) != Nullch) {
X	    free_compex(&ilcompex);
X	    return TRUE;
X	}
X    }
X    free_compex(&ilcompex);
X    return FALSE;
X#endif
X#else
X    return TRUE;
X#endif
X}
X
X#ifdef ONLY
Xvoid
Xend_only()
X{
X    if (maxngtodo) {			/* did they specify newsgroup(s) */
X	int whicharg;
X
X#ifdef VERBOSE
X	IF(verbose)
X	    printf("\nRestriction %s%s removed.\n",ngtodo[0],
X		maxngtodo > 1 ? ", etc." : nullstr) FLUSH;
X	ELSE
X#endif
X#ifdef TERSE
X	    fputs("\nExiting \"only\".\n",stdout) FLUSH;
X#endif
X	for (whicharg = 0; whicharg < maxngtodo; whicharg++) {
X	    free(ngtodo[whicharg]);
X#ifdef SPEED_OVER_MEM
X	    free_compex(compextodo[whicharg]);
X#ifndef lint
X	    free((char*)compextodo[whicharg]);
X#endif /* lint */
X#endif
X	}
X	maxngtodo = 0;
X	emptyOnly = FALSE;
X    }
X}
X#endif
END_OF_FILE
if test 2817 -ne `wc -c <'only.c'`; then
    echo shar: \"'only.c'\" unpacked with wrong size!
fi
# end of 'only.c'
fi
if test -f 'rthread.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rthread.h'\"
else
echo shar: Extracting \"'rthread.h'\" \(2373 characters\)
sed "s/^X//" >'rthread.h' <<'END_OF_FILE'
X/* $Id: rthread.h,v 3.0 1992/12/14 00:14:15 davison Trn $
X*/
X/* The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
XEXT ART_NUM article_count INIT(0);
XEXT int subject_count INIT(0);
XEXT bool output_chase_phrase;
XEXT char *references;
XEXT bool ov_opened INIT(FALSE);
X
Xvoid thread_init _((void));
Xvoid thread_open _((void));
Xvoid thread_grow _((void));
Xvoid thread_close _((void));
X
Xvoid top_article _((void));
XARTICLE *first_art _((SUBJECT*));
XARTICLE *last_art _((SUBJECT*));
XARTICLE *bump_art _((ARTICLE*));
XARTICLE *next_art _((ARTICLE*));
XARTICLE *prev_art _((ARTICLE*));
Xvoid inc_art _((bool_int,bool_int));
Xvoid dec_art _((bool_int,bool_int));
Xbool next_art_with_subj _((void));
Xbool prev_art_with_subj _((void));
X
Xvoid select_article _((ARTICLE*,int));
Xvoid select_subject _((SUBJECT*,int));
Xvoid select_thread _((ARTICLE*,int));
Xvoid select_subthread _((ARTICLE*,int));
Xvoid deselect_article _((ARTICLE*));
Xvoid deselect_subject _((SUBJECT*));
Xvoid deselect_thread _((ARTICLE*));
Xvoid deselect_all _((void));
Xvoid kill_subject _((SUBJECT*,int));
Xvoid kill_thread _((ARTICLE*,int));
Xvoid kill_subthread _((ARTICLE*,int));
Xvoid unkill_subject _((SUBJECT*));
Xvoid unkill_thread _((ARTICLE*));
Xvoid unkill_subthread _((ARTICLE*));
Xvoid clear_subject _((SUBJECT*));
Xvoid clear_thread _((ARTICLE*));
Xvoid clear_subthread _((ARTICLE*));
X#define KF_UNSELECTED	0
X#define KF_ALL		1
X#define KF_KILLFILE	2
X
XARTICLE *subj_art _((SUBJECT*));
Xvoid next_subject _((void));
Xvoid prev_subject _((void));
X
Xbool find_parent _((bool_int));
Xbool find_leaf _((bool_int));
Xbool find_prev_sib _((void));
Xbool find_next_sib _((void));
X
Xvoid sort_subjects _((void));
Xvoid count_subjects _((int));
X#define CS_RETAIN      0
X#define CS_NORM        1
X#define CS_RESELECT    2
X#define CS_UNSELECT    3
X#define CS_UNSEL_STORE 4
X
Xint subjorder_date _((SUBJECT**, SUBJECT**));
Xint subjorder_str _((SUBJECT**, SUBJECT**));
Xint threadorder_date _((SUBJECT**, SUBJECT**));
Xint threadorder_str _((SUBJECT**, SUBJECT**));
X
Xvoid sort_articles _((void));
X
Xint artorder_date _((ARTICLE**, ARTICLE**));
Xint artorder_str _((ARTICLE**, ARTICLE**));
X
Xtime_t parsedate _((char*));
X
X/* Stuff local to rthread.c. */
X
X#ifdef DOINIT
X
Xstatic void build_artptrs _((void));
X
X#endif
END_OF_FILE
if test 2373 -ne `wc -c <'rthread.h'`; then
    echo shar: \"'rthread.h'\" unpacked with wrong size!
fi
# end of 'rthread.h'
fi
if test -f 'strftime.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'strftime.c'\"
else
echo shar: Extracting \"'strftime.c'\" \(4698 characters\)
sed "s/^X//" >'strftime.c' <<'END_OF_FILE'
X/*
X * strftime: print formatted information about a given time.
X * Adapted from the routine by Eric R. Smith, Michal Jaegermann,
X * Arnold Robins, and Paul Close.
X */
X/* The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X/* Configuration choices for %x and %X */
X
X#undef LOCAL_DDMMYY	/* choose DD/MM/YY instead of MM/DD/YY */
X#undef LOCAL_DOTTIME	/* choose HH.MM.SS instead of HH:MM:SS */
X
X#include "EXTERN.h"
X#include "common.h"
X
Xstatic char *mth_name[] = {
X    "January", "February", "March", "April", "May", "June",
X    "July", "August", "September", "October", "November", "December"
X};
X
Xstatic char *day_name[] = {
X    "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday",
X    "Saturday"
X};
X
X#ifdef HAS_FTIME
X# ifndef TM_ZONE
Xchar tznm[16] = "";
X# endif
X#else
Xextern char *tzname[];
X#endif
X
Xsize_t
Xstrftime(str, maxsize, fmt, ts)
Xchar *str;
Xsize_t maxsize;
XCONST char *fmt;
XCONST struct tm *ts;
X{
X    size_t num = 0, len;
X    char ch;
X    char *putstr;
X    char tmpbuf[80];
X
X    if (maxsize-- <= 0)
X	return 0;
X
X    for (;;) {
X	if (!(ch = *fmt++))
X	    break;
X	if (num == maxsize) {
X	    num = 0;
X	    break;
X	}
X	if (ch != '%') {
X	    *str++ = ch;
X	    num++;
X	    continue;
X	}
X	/* assume the finished product will be sprintf'ed into tmpbuf */
X	putstr = tmpbuf;
X
X	switch (ch = *fmt++) {
X	case 'A':
X	case 'a':
X	    if (ts->tm_wday < 0 || ts->tm_wday > 6)
X		putstr = "?";
X	    else
X		if (ch == 'A')
X		    putstr = day_name[ts->tm_wday];
X		else
X		    sprintf(tmpbuf, "%-.3s", day_name[ts->tm_wday]);
X	    break;
X	case 'B':
X	case 'b':
X	case 'h':
X	    if (ts->tm_mon < 0 || ts->tm_mon > 11)
X		putstr = "?";
X	    else if (ch == 'B')
X		putstr = mth_name[ts->tm_mon];
X	    else
X		sprintf(tmpbuf, "%-.3s", mth_name[ts->tm_mon]);
X	    break;
X	case 'C':
X	    strftime(tmpbuf, sizeof tmpbuf, "%A, %B %e, %Y", ts);
X	    break;
X	case 'c':
X	    strftime(tmpbuf, sizeof tmpbuf, "%x %X", ts);
X	    break;
X	case 'D':
X#ifndef LOCAL_DDMMYY
X	case 'x':
X#endif
X	    strftime(tmpbuf, sizeof tmpbuf, "%m/%d/%y", ts);
X	    break;
X	case 'd':
X	    sprintf(tmpbuf, "%02d", ts->tm_mday);
X	    break;
X	case 'e':	/* day of month, blank padded */
X	    sprintf(tmpbuf, "%2d", ts->tm_mday);
X	    break;
X	case 'H':
X	    sprintf(tmpbuf, "%02d", ts->tm_hour);
X	    break;
X	case 'I':
X	{
X	    int n;
X
X	    n = ts->tm_hour;
X	    if (n == 0)
X		n = 12;
X	    else if (n > 12)
X		n -= 12;
X	    sprintf(tmpbuf, "%02d", n);
X	    break;
X	}
X	case 'j':
X	    sprintf(tmpbuf, "%03d", ts->tm_yday + 1);
X	    break;
X	case 'm':
X	    sprintf(tmpbuf, "%02d", ts->tm_mon + 1);
X	    break;
X	case 'M':
X	    sprintf(tmpbuf, "%02d", ts->tm_min);
X	    break;
X	case 'p':
X	    putstr = (ts->tm_hour < 12) ? "AM" : "PM";
X	    break;
X	case 'r':
X	    strftime(tmpbuf, sizeof tmpbuf, "%I:%M:%S %p", ts);
X	    break;
X	case 'R':
X	    strftime(tmpbuf, sizeof tmpbuf, "%H:%M", ts);
X	    break;
X	case 'S':
X	    sprintf(tmpbuf, "%02d", ts->tm_sec);
X	    break;
X	case 'T':
X#ifndef LOCAL_DOTTIME
X	case 'X':
X#endif
X	    strftime(tmpbuf, sizeof tmpbuf, "%H:%M:%S", ts);
X	    break;
X	case 'U':	/* week of year - starting Sunday */
X	    sprintf(tmpbuf, "%02d", (ts->tm_yday - ts->tm_wday + 10) / 7);
X	    break;
X	case 'W':	/* week of year - starting Monday */
X	    sprintf(tmpbuf, "%02d", (ts->tm_yday - ((ts->tm_wday + 6) % 7)
X			+ 10) / 7);
X	    break;
X	case 'w':
X	    sprintf(tmpbuf, "%d", ts->tm_wday);
X	    break;
X	case 'y':
X	    sprintf(tmpbuf, "%02d", ts->tm_year % 100);
X	    break;
X#ifdef LOCAL_DOTTIME
X	case 'X':
X	    strftime(tmpbuf, sizeof tmpbuf, "%H.%M.%S", ts);
X	    break;
X#endif
X#ifdef LOCAL_DDMMYY
X	case 'x':
X	    strftime(tmpbuf, sizeof tmpbuf, "%d/%m/%y", ts);
X	    break;
X#endif
X	case 'Y':
X	    sprintf(tmpbuf, "%d", ts->tm_year + 1900);
X	    break;
X	case 'Z':
X#ifdef HAS_FTIME
X# ifdef TM_ZONE
X	    sprintf(tmpbuf, "%s", ts->tm_zone);
X# else
X	    if (*tznm == '\0') {
X		char *timezone();
X		struct timeval tv;
X		struct timezone tz;
X
X		(void) gettimeofday(&tv, &tz);
X		strcpy(tznm, timezone(tz.tz_minuteswest, ts->tm_isdst));
X	    }
X	    sprintf(tmpbuf, "%s", tznm);
X# endif
X#else
X	    sprintf(tmpbuf, "%s", tzname[ts->tm_isdst]);
X#endif
X	    break;
X	case '%':
X	case '\0':
X	    putstr = "%";
X	    break;
X	case 'n':	/* same as \n */
X	    putstr = "\n";
X	    break;
X	case 't':	/* same as \t */
X	    putstr = "\t";
X	    break;
X	default:
X	    sprintf(tmpbuf, "%%%c", ch);
X	    break;
X	}
X	len = strlen(putstr);
X	num += len;
X	if (num > maxsize) {
X	    len -= num - maxsize;
X	    num = 0;
X	    ch = '\0';
X	}
X	strncpy(str, putstr, len);
X	str += len;
X	if (!ch)
X	    break;
X    }
X    *str = '\0';
X    return num;
X}
END_OF_FILE
if test 4698 -ne `wc -c <'strftime.c'`; then
    echo shar: \"'strftime.c'\" unpacked with wrong size!
fi
# end of 'strftime.c'
fi
echo shar: End of archive 2 \(of 12\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 12 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
