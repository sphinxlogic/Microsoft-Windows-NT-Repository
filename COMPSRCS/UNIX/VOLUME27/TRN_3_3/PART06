Newsgroups: comp.sources.unix
From: davison@borland.com (Wayne Davison)
Subject: v27i099: trn-3.3 - threaded newsreader based on RN, V3.3, Part06/12
References: <1.754431075.7231@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: davison@borland.com (Wayne Davison)
Posting-Number: Volume 27, Issue 99
Archive-Name: trn-3.3/part06

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 12)."
# Contents:  bits.c cache.c help.c rt-page.c trn.c
# Wrapped by vixie@gw.home.vix.com on Sun Nov 21 01:14:05 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'bits.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bits.c'\"
else
echo shar: Extracting \"'bits.c'\" \(15782 characters\)
sed "s/^X//" >'bits.c' <<'END_OF_FILE'
X/* $Id: bits.c,v 3.0 1992/02/01 03:09:32 davison Trn $
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "cache.h"
X#include "INTERN.h"
X#include "bits.h"
X#include "EXTERN.h"
X#include "rcstuff.h"
X#include "head.h"
X#include "util.h"
X#include "final.h"
X#include "trn.h"
X#include "ng.h"
X#include "artio.h"
X#include "intrp.h"
X#include "ngdata.h"
X#include "rcln.h"
X#include "ndir.h"
X#include "nntp.h"
X#include "rthread.h"
X#include "rt-select.h"
X
X#ifdef DBM_XREFS
X#    ifdef NULL
X#	undef NULL
X#    endif
X#    include <dbm.h>
X#endif
X
Xvoid
Xbits_init()
X{
X    ;
X}
X
Xvoid
Xrc_to_bits()
X{
X    char *mybuf = buf;			/* place to decode rc line */
X    register char *s, *c, *h;
X    register long i;
X    register ART_NUM unread;
X    register ARTICLE *ap;
X
X    /* modify the article flags to reflect what has already been read */
X
X    for (s = rcline[ng] + rcnums[ng]; *s == ' '; s++) ;
X					/* find numbers in rc line */
X    i = strlen(s);
X#ifndef lint
X    if (i >= LBUFLEN-2)			/* bigger than buf? */
X	mybuf = safemalloc((MEM_SIZE)(i+2));
X#endif
X    strcpy(mybuf,s);			/* make scratch copy of line */
X    mybuf[i++] = ',';			/* put extra comma on the end */
X    mybuf[i] = '\0';
X    s = mybuf;				/* initialize the for loop below */
X    if (strnEQ(s,"1-",2)) {		/* can we save some time here? */
X	firstart = atol(s+2)+1;		/* process first range thusly */
X	s=index(s,',') + 1;
X	for (i = absfirst, ap = article_ptr(i); i < firstart; i++, ap++)
X	    ap->flags |= AF_READ;
X    } else {
X	i = firstart = absfirst;
X	ap = article_ptr(i);
X    }
X    unread = lastart - firstart + 1;	/* assume this range unread */
X#ifdef DEBUG
X    if (debug & DEB_CTLAREA_BITMAP) {
X	printf("\n%s\n",mybuf) FLUSH;
X	for (i = absfirst, ap = article_ptr(i); i < firstart; i++, ap++)
X	    if (!(ap->flags & AF_READ))
X		printf("%ld ",(long)i) FLUSH;
X    }
X#endif
X    for ( ; (c = index(s,',')) != Nullch; s = ++c) {	/* for each range */
X	ART_NUM min, max;
X
X	*c = '\0';			/* do not let index see past comma */
X	h = index(s,'-');
X	min = atol(s);
X	if (h)				/* is there a dash? */
X	    max = atol(h+1);
X	else
X	    max = min;
X	if (min < firstart)		/* make sure range is in range */
X	    min = firstart;
X	if (min > lastart)
X	    min = lastart+1;
X	for (; i < min; i++, ap++)
X	    ap->flags &= ~AF_READ;
X	if (max > lastart)
X	    max = lastart;
X	if (min <= max) {		/* non-null range? */
X	    unread -= max - min + 1;/* adjust unread count */
X	    /* mark all arts in range as read */
X	    for (; i <= max; i++, ap++)
X		ap->flags |= AF_READ;
X	}
X#ifdef DEBUG
X	if (debug & DEB_CTLAREA_BITMAP) {
X	    printf("\n%s\n",s) FLUSH;
X	    for (i=absfirst; i <= lastart; i++)
X		if (!was_read(i))
X		    printf("%ld ",(long)i) FLUSH;
X	}
X#endif
X    }
X    for (; i <= lastart; i++, ap++)
X	ap->flags &= ~AF_READ;
X#ifdef DEBUG
X    if (debug & DEB_CTLAREA_BITMAP) {
X	fputs("\n(hit CR)",stdout) FLUSH;
X	gets(cmd_buf);
X    }
X#endif
X    if (mybuf != buf)
X	free(mybuf);
X    toread[ng] = unread;
X}
X
X/* reconstruct the .newsrc line in a human readable form */
X
Xvoid
Xbits_to_rc()
X{
X    register char *s, *mybuf = buf;
X    register ART_NUM i;
X    ART_NUM count=0;
X    int safelen = LBUFLEN - 32;
X
X    strcpy(buf,rcline[ng]);		/* start with the newsgroup name */
X    s = buf + rcnums[ng] - 1;		/* use s for buffer pointer */
X    *s++ = RCCHAR(rcchar[ng]);		/* put the requisite : or !*/
X    for (i=absfirst; i<=lastart; i++)
X	if (!was_read(i))
X	    break;
X    sprintf(s," 1-%ld,",(long)i-1);
X    s += strlen(s);
X    for (; i<=lastart; i++) {	/* for each article in newsgroup */
X	if (s-mybuf > safelen) {	/* running out of room? */
X	    safelen *= 2;
X	    if (mybuf == buf) {		/* currently static? */
X		*s = '\0';
X		mybuf = safemalloc((MEM_SIZE)safelen + 32);
X		strcpy(mybuf,buf);	/* so we must copy it */
X		s = mybuf + (s-buf);
X					/* fix the pointer, too */
X	    }
X	    else {			/* just grow in place, if possible */
X		char *newbuf;
X
X		newbuf = saferealloc(mybuf,(MEM_SIZE)safelen + 32);
X		s = newbuf + (s-mybuf);
X		mybuf = newbuf;
X	    }
X	}
X	if (!was_read(i))		/* still unread? */
X	    count++;			/* then count it */
X	else {				/* article was read */
X	    ART_NUM oldi;
X
X	    sprintf(s,"%ld",(long)i);	/* put out the min of the range */
X	    s += strlen(s);		/* keeping house */
X	    oldi = i;			/* remember this spot */
X	    do i++; while (i <= lastart && was_read(i));
X					/* find 1st unread article or end */
X	    i--;			/* backup to last read article */
X	    if (i > oldi) {		/* range of more than 1? */
X		sprintf(s,"-%ld,",(long)i);
X					/* then it out as a range */
X		s += strlen(s);		/* and housekeep */
X	    }
X	    else
X		*s++ = ',';		/* otherwise, just a comma will do */
X	}
X    }
X    if (*(s-1) == ',')			/* is there a final ','? */
X	s--;				/* take it back */
X    *s++ = '\0';			/* and terminate string */
X#ifdef DEBUG
X    if (debug & DEB_NEWSRC_LINE && !panic) {
X	printf("%s: %s\n",rcline[ng],rcline[ng]+rcnums[ng]) FLUSH;
X	printf("%s\n",mybuf) FLUSH;
X    }
X#endif
X    free(rcline[ng]);			/* return old rc line */
X    if (mybuf == buf) {
X	rcline[ng] = safemalloc((MEM_SIZE)(s-buf)+1);
X					/* grab a new rc line */
X	strcpy(rcline[ng], buf);	/* and load it */
X    }
X    else {
X	mybuf = saferealloc(mybuf,(MEM_SIZE)(s-mybuf)+1);
X					/* be nice to the heap */
X	rcline[ng] = mybuf;
X    }
X    *(rcline[ng] + rcnums[ng] - 1) = '\0';
X    if (rcchar[ng] == NEGCHAR) {	/* did they unsubscribe? */
X	printf(unsubto,ngname) FLUSH;
X	toread[ng] = TR_UNSUB;		/* make line invisible */
X    }
X    else
X	/*NOSTRICT*/
X	toread[ng] = (ART_UNREAD)count;		/* remember how many unread there are */
X}
X
X#ifdef USE_NNTP
X
X/* Parse the LISTGROUP output and set anything not mentioned as missing. */
X
Xvoid
Xsetmissingbits()				/* NNTP version */
X{
X    register ART_NUM num, priornum;
X    register ARTICLE *ap;
X
X    if (!nntp_listgroup())
X	return;
X    for (priornum = absfirst-1, ap = article_ptr(absfirst);; ap++) {
X	nntp_gets(ser_line, sizeof ser_line);
X	if (*ser_line == '.')
X	    break;
X	num = atol(ser_line);
X	while (++priornum < num)
X	    uncache_article(ap++,FALSE);
X    }
X}
X
X#else /* !USE_NNTP */
X
X/* Scan the directory to find which articles are present. */
X
Xvoid
Xsetfoundbits()
X{
X    register ART_NUM first = lastart+1;
X    register DIR *dirp;
X    register struct direct *dp;
X    long an;
X    char ch;
X
X    if (!(dirp = opendir(".")))
X	return;
X    
X    found_min = absfirst;
X    an = (lastart-found_min)/BITSPERBYTE+20;
X    found_bits = safemalloc((MEM_SIZE)an);
X    bzero(found_bits, an);
X
X    while ((dp = readdir(dirp)) != Null(struct direct *)) {
X	if (sscanf(dp->d_name, "%ld%c", &an, &ch) == 1) {
X	    if (an <= lastart && an >= found_min) {
X		if (an < first)
X		    first = an;
X		foundart(an);
X	    }
X	}
X    }
X    closedir(dirp);
X    abs1st[ng] = first;
X    if (first > absfirst)
X	checkexpired(ng);
X    absfirst = first;
X}
X
Xvoid
Xsetmissingbits()				/* non-NNTP version */
X{
X    register ARTICLE *ap;
X    register ART_NUM an;
X
X    if (!found_bits)
X	return;
X
X    for (an = absfirst, ap = article_ptr(an); an <= lastart; an++, ap++) {
X	if (artismissing(an))
X	    onemissing(ap);
X    }
X    free(found_bits);
X    found_bits = NULL;
X}
X#endif /* !USE_NNTP */
X
X/* mark an article unread, keeping track of toread[] */
X
Xvoid
Xonemore(ap)
XARTICLE *ap;
X{
X    if (ap->flags & AF_READ) {
X	register ART_NUM artnum = article_num(ap);
X	check_first(artnum);
X	ap->flags &= ~AF_READ;
X	++toread[ng];
X	ap->flags &= ~AF_DEL;
X	if (ap->subj) {
X	    if (selected_only) {
X		if (ap->subj->flags & sel_mask) {
X		    ap->flags |= sel_mask;
X		    selected_count++;
X		}
X	    } else
X		ap->subj->flags |= SF_VISIT;
X	}
X    }
X}
X
X/* mark an article read, keeping track of toread[] */
X
Xvoid
Xoneless(ap)
XARTICLE *ap;
X{
X    if (!(ap->flags & AF_READ)) {
X	ap->flags |= AF_READ;
X	/* Keep selected_count accurate */
X	if (ap->flags & sel_mask) {
X	    selected_count--;
X	    ap->flags &= ~sel_mask;
X	}
X	if (toread[ng] > TR_NONE)
X	    --toread[ng];
X    }
X}
X
Xvoid
Xonemissing(ap)
XARTICLE *ap;
X{
X    oneless(ap);
X    ap->flags = (ap->flags & ~(AF_HAS_RE|AF_YANKBACK|AF_FROMTRUNCED))
X	      | AF_MISSING|AF_CACHED|AF_THREADED;
X}
X
X/* mark an article as unread, with possible xref chasing */
X
Xvoid
Xunmark_as_read()
X{
X    onemore(article_ptr(art));
X#ifdef MCHASE
X    chase_xrefs(art,FALSE);
X#endif
X}
X
X/* Mark an article as read in this newsgroup and possibly chase xrefs.
X** Don't call this on missing articles.
X*/
Xvoid
Xset_read(ap)
Xregister ARTICLE *ap;
X{
X    register ART_NUM artnum = article_num(ap);
X
X    oneless(ap);
X    if (!olden_days && ap->xrefs != nullstr) {
X	if (output_chase_phrase) {
X#ifdef VERBOSE
X	    IF(verbose)
X		fputs("\nChasing xrefs", stdout);
X	    ELSE
X#endif
X#ifdef TERSE
X		fputs("\nXrefs", stdout);
X#endif
X	    output_chase_phrase = 0;
X	}
X	putchar('.'), fflush(stdout);
X	chase_xrefs(artnum, TRUE);
X    }
X}
X
X/* temporarily mark article as read.  When newsgroup is exited, articles */
X/* will be marked as unread.  Called via M command */
X
Xvoid
Xdelay_unmark(ap)
XARTICLE *ap;
X{
X    if (!(ap->flags & AF_YANKBACK)) {
X	ap->flags |= AF_YANKBACK;
X	dmcount++;
X    }
X}
X
X/* mark article as read.  If article is cross referenced to other */
X/* newsgroups, mark them read there also. */
X
Xvoid
Xmark_as_read()
X{
X    oneless(article_ptr(art));
X    checkcount++;			/* get more worried about crashes */
X    chase_xrefs(art,TRUE);
X}
X
X/* keep firstart pointing at the first unread article */
X
Xvoid
Xcheck_first(min)
XART_NUM min;
X{
X    if (min < absfirst)
X	min = absfirst;
X    if (min < firstart)
X	firstart = min;
X}
X
X/* bring back articles marked with M */
X
Xvoid
Xyankback()
X{
X    register ARTICLE *ap;
X
X    if (dmcount) {			/* delayed unmarks pending? */
X	if (mode == 't')
X	    sprintf(buf, "Returned %ld Marked article%s.",(long)dmcount,
X		dmcount == 1 ? nullstr : "s");
X	else
X#ifdef VERBOSE
X	    printf("\nReturning %ld Marked article%s...\n",(long)dmcount,
X		dmcount == 1 ? nullstr : "s") FLUSH;
X#endif
X	for (art=absfirst, ap=article_ptr(art); art <= lastart; art++, ap++) {
X	    if ((ap->flags & (AF_YANKBACK|AF_MISSING)) == AF_YANKBACK) {
X		unmark_as_read();
X		if (selected_only)
X		    select_article(ap, 0);
X		ap->flags &= ~AF_YANKBACK;
X	    }
X	}
X	dmcount = 0;
X    }
X}
X    
X/* run down xref list and mark as read or unread */
X
X#ifndef DBM_XREFS
Xint
Xchase_xrefs(artnum,markread)	/* The Xref-line-using version */
XART_NUM artnum;
Xint markread;
X{
X# ifdef VALIDATE_XREF_SITE
X    bool valid_xref_site();
X# endif
X    register char *xartnum;
X    register ART_NUM x;
X    char *xref_buf, *curxref;
X    char tmpbuf[128];
X
X    xref_buf = fetchcache(artnum, XREF_LINE, FILL_CACHE);
X    if (!xref_buf || !*xref_buf)
X	return 0;
X
X    xref_buf = savestr(xref_buf);
X# ifdef DEBUG
X    if (debug & DEB_XREF_MARKER)
X	printf("Xref: %s\n",xref_buf) FLUSH;
X# endif
X    curxref = cpytill(tmpbuf,xref_buf,' ') + 1;
X# ifdef VALIDATE_XREF_SITE
X    if (valid_xref_site(artnum,tmpbuf))
X# endif
X    {
X	while (*curxref) {		/* for each newsgroup */
X	    curxref = cpytill(tmpbuf,curxref,' ');
X	    xartnum = index(tmpbuf,':');
X	    if (!xartnum)
X		break;
X	    *xartnum++ = '\0';
X	    if (!(x = atol(xartnum)))
X		continue;
X	    if (strEQ(tmpbuf,ngname)) {/* is this the current newsgroup? */
X		if (x < absfirst || x > lastart)
X		    continue;
X		if (markread)
X		    oneless(article_ptr(x)); /* take care of old C newses */
X#ifdef MCHASE
X		else
X		    onemore(article_ptr(x));
X#endif
X	    } else {
X		if (markread) {
X		    if (addartnum(x,tmpbuf))
X			break;
X		}
X# ifdef MCHASE
X		else
X		    subartnum(x,tmpbuf);
X# endif
X	    }
X	    while (*curxref && isspace(*curxref))
X		curxref++;
X	}
X    }
X    free(xref_buf);
X    return 0;
X}
X
X# ifdef VALIDATE_XREF_SITE
X/* Make sure the site name on Xref matches what inews thinks the site
X * is.  Check first against last inews_site.  If it matches, fine.
X * If not, fetch inews_site from current Path or Relay-Version line and
X * check again.  This is so that if the new administrator decides
X * to change the system name as known to inews, rn will still do
X * Xrefs correctly--each article need only match itself to be valid.
X */ 
Xbool
Xvalid_xref_site(artnum, site)
XART_NUM artnum;
Xchar *site;
X{
X    static char *inews_site = Nullch;
X    char *sitebuf, *s;
X
X    if (inews_site && strEQ(site,inews_site))
X	return TRUE;
X
X    if (inews_site)
X	free(inews_site);
X#ifndef ANCIENT_NEWS
X    /* Grab the site from the first component of the Path line */
X    sitebuf = fetchlines(artnum,PATH_LINE);
X    if ((s = index(sitebuf, '!')) != Nullch) {
X	*s = '\0';
X	inews_site = savestr(sitebuf);
X    }
X#else /* ANCIENT_NEWS */
X    /* Grab the site from the Posting-Version line */
X    sitebuf = fetchlines(artnum,RVER_LINE);
X    if ((s = instr(sitebuf,"; site ",TRUE)) != Nullch) {
X	char *t = index(s+7, '.');
X	if (t)
X	    *t = '\0';
X	inews_site = savestr(s+7);
X    }
X#endif /* ANCIENT_NEWS */
X    else
X	inews_site = savestr(nullstr);
X    free(sitebuf);
X
X    if (strEQ(site,inews_site))
X	return TRUE;
X
X#ifdef DEBUG
X    if (debug)
X	printf("Xref not from %s--ignoring\n",inews_site) FLUSH;
X#endif
X    return FALSE;
X}
X# endif /* VALIDATE_XREF_SITE */
X
X#else /* DBM_XREFS */
X
Xint
Xchase_xrefs(artnum,markread)		/* The DBM version */
XART_NUM artnum;
Xint markread;
X{
X    datum lhs, rhs;
X    datum fetch();
X    register char *idp;
X    char *ident_buf;
X    static FILE *hist_file = Nullfp;
X    long pos;
X    register char *xartnum;
X    register ART_NUM x;
X    char *xref_buf, *curxref;
X    char tmpbuf[128];
X
X    xref_buf = fetchcache(artnum, NGS_LINE, FILL_CACHE);
X    if (!xref_buf || !*xref_buf)
X	return 0;
X
X    xref_buf = safemalloc((MEM_SIZE)BUFSIZ);
X    if (hist_file == Nullfp) {	/* Init. file accesses */
X#ifdef DEBUG
X	if (debug)
X	    printf("chase_xref: opening files\n");
X#endif
X	dbminit(filexp(ARTFILE));
X	if ((hist_file = fopen(filexp(ARTFILE), "r")) == Nullfp)
X	    return 0;
X    }
X    ident_buf = fetchlines(artnum,MESSID_LINE);	/* get Message-ID */
X#ifdef DEBUG
X    if (debug)
X	printf ("chase_xref: Message-ID: %s\n", ident_buf);
X#endif
X    
X    if ((idp = index(ident_buf, '@')) != Nullch) {
X	while (*++idp)			/* make message-id case insensitive */
X	    if (isupper(*idp))
X		*idp = tolower(*idp);
X    }
X    lhs.dptr = ident_buf;		/* look up article by id */
X    lhs.dsize = strlen(lhs.dptr) + 1;
X    rhs = fetch(lhs);			/* fetch the record */
X    if (rhs.dptr == NULL)		/* if null, nothing there */
X	goto wild_goose;
X    bcopy(rhs.dptr,(char*)&pos, 4);
X    fseek(hist_file, pos, 0);	/* datum returned is position in hist file */
X    fgets(xref_buf, BUFSIZ, hist_file);
X#ifdef DEBUG
X    if (debug)
X	printf ("Xref from history: %s\n", xref_buf);
X#endif
X    curxref = cpytill(tmpbuf, xref_buf, '\t') + 1;
X    curxref = cpytill(tmpbuf, curxref, '\t') + 1;
X#ifdef DEBUG
X    if (debug)
X	printf ("chase_xref: curxref: %s\n", curxref);
X#endif
X    while (*curxref) {			/* for each newsgroup */
X	curxref = cpytill(tmpbuf,curxref,' ');
X	xartnum = index(tmpbuf,'/');
X	if (!xartnum)			/* probably an old-style Xref */
X	    break;
X	*xartnum++ = '\0';
X	if (!(x = atol(xartnum)))
X	    continue;
X	if (strNE(tmpbuf,ngname)) {	/* not the current newsgroup? */
X	    if (markread) {
X		if (addartnum(x,tmpbuf))
X		    goto wild_goose;
X	    }
X#ifdef MCHASE
X	    else
X		subartnum(x,tmpbuf);
X#endif
X	}
X	while (*curxref && isspace(*curxref))
X	    curxref++;
X    }
X  wild_goose:
X    free(xref_buf);
X    free(ident_buf);
X    return 0;
X}
X#endif /* DBM_XREFS */
END_OF_FILE
if test 15782 -ne `wc -c <'bits.c'`; then
    echo shar: \"'bits.c'\" unpacked with wrong size!
fi
# end of 'bits.c'
fi
if test -f 'cache.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cache.c'\"
else
echo shar: Extracting \"'cache.c'\" \(17951 characters\)
sed "s/^X//" >'cache.c' <<'END_OF_FILE'
X/* $Id: cache.c,v 3.0 1992/02/01 03:09:32 davison Trn $
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "INTERN.h"
X#include "cache.h"
X#include "EXTERN.h"
X#include "intrp.h"
X#include "search.h"
X#include "ng.h"
X#include "trn.h"
X#include "ngdata.h"
X#include "term.h"
X#include "final.h"
X#include "artsrch.h"
X#include "head.h"
X#include "bits.h"
X#include "rcstuff.h"
X#include "hash.h"
X#include "rthread.h"
X#include "rt-ov.h"
X#include "rt-select.h"
X#include "rt-util.h"
X#include "util.h"
X
X#ifdef PENDING
X#   ifdef ARTSEARCH
X	COMPEX srchcompex;		/* compiled regex for searchahead */
X#   endif
X#endif
X
XHASHTABLE *subj_hash = 0;
X
Xint subject_cmp _((char *,int,HASHDATUM));
X
Xvoid
Xcache_init()
X{
X#ifdef PENDING
X# ifdef ARTSEARCH
X    init_compex(&srchcompex)
X# endif
X#endif
X    ;
X}
X
XNG_NUM cached_ng = -1;
Xtime_t cached_time = 0;
XART_NUM cached_cnt = 0;
XART_NUM cached_absfirst = 0;
X
Xvoid
Xbuild_cache()
X{
X    if (cached_ng == ng && cached_absfirst == absfirst
X     && time((time_t*)NULL) < cached_time + 6*60*60L) {
X	grow_cache(lastart);
X	rc_to_bits();
X	if (sel_mode == SM_ARTICLE)
X	    set_selector(sel_mode, sel_artsort);
X	else
X	    set_selector(sel_threadmode, sel_threadsort);
X	thread_grow();
X	return;
X    }
X
X    close_cache();
X
X    cached_ng = ng;
X    cached_absfirst = absfirst;
X    cached_time = time((time_t*)NULL);
X    cached_cnt = lastart-absfirst+2 + 5;
X    article_list = (ARTICLE*)
X	safemalloc((MEM_SIZE)(cached_cnt * sizeof (ARTICLE)));
X    bzero((char*)article_list, cached_cnt * sizeof (ARTICLE));
X    subj_hash = hashcreate(201, subject_cmp);	/*TODO: pick a better size */
X
X    rc_to_bits();			/* sets firstart */
X    first_cached = thread_always? absfirst : firstart;
X    last_cached = first_cached-1;
X    cached_all_in_range = FALSE;
X#ifdef PENDING
X    subj_to_get = xref_to_get = firstart;
X#endif
X#ifndef USE_NNTP
X    setmissingbits();
X#endif
X
X    /* Cache as much data in advance as possible, possibly threading
X    ** articles as we go. */
X    thread_open();
X}
X
X#define FIXPTR(p) (!(p) || (p)<old_list || ((p)-old_list) > (lastart-absfirst)\
X		   ? (p) : (article_list + ((p)-old_list)))
X
Xvoid
Xgrow_cache(newlast)
XART_NUM newlast;
X{
X    ART_NUM new_cnt = newlast-absfirst+2;
X
X    if (new_cnt > cached_cnt) {
X	ARTICLE *old_list = article_list;
X	new_cnt += 5;
X	article_list = (ARTICLE*)saferealloc((char*)article_list,
X		(MEM_SIZE)(new_cnt * sizeof (ARTICLE)));
X	bzero((char*)(article_list+cached_cnt),
X		(new_cnt-cached_cnt) * sizeof (ARTICLE));
X	if (article_list != old_list) {
X	    register ARTICLE *ap;
X	    register SUBJECT *sp;
X	    for (sp = first_subject; sp; sp = sp->next) {
X		sp->thread = FIXPTR(sp->thread);
X		sp->articles = FIXPTR(sp->articles);
X		if (sp->thread) {
X		    for (ap = sp->thread; ap; ap = bump_art(ap)) {
X			ap->child1 = FIXPTR(ap->child1);
X			ap->parent = FIXPTR(ap->parent);
X			ap->sibling = FIXPTR(ap->sibling);
X			ap->subj_next = FIXPTR(ap->subj_next);
X		    }
X		} else {
X		    for (ap = sp->articles; ap; )
X			ap = ap->subj_next = FIXPTR(ap->subj_next);
X		}
X	    }
X	    artp = FIXPTR(artp);
X	    curr_artp = FIXPTR(curr_artp);
X	    recent_artp = FIXPTR(recent_artp);
X	}
X	cached_cnt = new_cnt;
X    }
X    cached_time = time((time_t*)NULL);
X}
X
Xvoid
Xclose_cache()
X{
X    SUBJECT *sp, *next;
X    ARTICLE *ap;
X    ART_NUM i;
X
X    if (subj_hash) {
X	hashdestroy(subj_hash);
X	subj_hash = 0;
X    }
X    /* Free all the subjects. */
X    for (sp = first_subject; sp; sp = next) {
X	next = sp->next;
X	free(sp->str);
X	free((char*)sp);
X    }
X    first_subject = last_subject = Nullsubj;
X    subject_count = 0;			/* just to be sure */
X    parsed_art = 0;
X
X    if (artptr_list) {
X	free((char*)artptr_list);
X	artptr_list = Null(ARTICLE**);
X    }
X    artptr = Null(ARTICLE**);
X    thread_close();
X
X    if (cached_cnt) {
X	for (i = 0, ap = article_list; i < cached_cnt; i++, ap++)
X	    clear_article(ap);
X	free((char*)article_list);
X	cached_cnt = 0;
X    }
X    cached_ng = -1;
X}
X
X/* The article has all it's data in place, so add it to the list of articles
X** with the same subject.
X*/
Xvoid
Xcache_article(ap)
Xregister ARTICLE *ap;
X{
X    register ARTICLE *next, *ap2;
X
X    if (!(next = ap->subj->articles) || ap->date < next->date)
X	ap->subj->articles = ap;
X    else {
X	while ((next = (ap2 = next)->subj_next) && next->date <= ap->date)
X	    ;
X	ap2->subj_next = ap;
X    }
X    ap->subj_next = next;
X    ap->flags |= AF_CACHED;
X
X    if (!(ap->flags & AF_READ) ^ sel_rereading) {
X	if (selected_only) {
X	    if (ap->subj->flags & sel_mask) {
X		ap->flags |= sel_mask;
X		selected_count++;
X	    }
X	} else if (ap->subj->flags & SF_WASSELECTED)
X	    select_article(ap, 0);
X	else {
X	    ap->subj->flags |= SF_VISIT;
X	    if (sel_mode == SM_THREAD)
X		ap->subj->thread->subj->flags |= SF_VISIT;
X	}
X    }
X}
X
Xvoid
Xcheck_poster(ap)
Xregister ARTICLE *ap;
X{
X    if (auto_select_postings && !(ap->flags & AF_MISSING)) {
X	if (ap->flags & AF_FROMTRUNCED) {
X	    strcpy(cmd_buf,realname);
X	    if (strEQ(ap->from,compress_name(cmd_buf,16))) {
X		untrim_cache = TRUE;
X		fetchfrom(article_num(ap),FALSE);
X		untrim_cache = FALSE;
X	    }
X	}
X	if (!(ap->flags & AF_FROMTRUNCED)) {
X	    if (instr(ap->from,phostname,FALSE)) {
X		if (instr(ap->from,loginName,TRUE))
X		    select_subthread(ap,AF_AUTOSELECT);
X		else {
X#ifdef SLOW_BUT_COMPLETE_POSTER_CHECKING
X		    char *reply_buf = fetchlines(article_num(ap),REPLY_LINE);
X		    if (instr(reply_buf,loginName,TRUE))
X			select_subthread(ap,AF_AUTOSELECT);
X		    free(reply_buf);
X#endif
X		}
X	    }
X	}
X    }
X}
X
X/* The article turned out to be a duplicate, so remove it from the cached
X** list and possibly destroy the subject (should only happen if the data
X** was corrupt and the duplicate id got a different subject).
X*/
Xvoid
Xuncache_article(ap, remove_empties)
Xregister ARTICLE *ap;
Xbool_int remove_empties;
X{
X    register ARTICLE *next, *ap2;
X
X    if (ap->subj) {
X	if ((ap->flags & (AF_CACHED|AF_MISSING)) == AF_CACHED) {
X	    if ((next = ap->subj->articles) == ap)
X		ap->subj->articles = ap->subj_next;
X	    else if (next) {
X		while (next && (next = (ap2 = next)->subj_next) != ap)
X		    ;
X		ap2->subj_next = next;
X	    }
X	}
X	if (remove_empties && !ap->subj->articles) {
X	    register SUBJECT *sp = ap->subj;
X	    if (sp == first_subject)
X		first_subject = sp->next;
X	    else
X		sp->prev->next = sp->next;
X	    if (sp == last_subject)
X		last_subject = sp->prev;
X	    else
X		sp->next->prev = sp->prev;
X	    free((char*)sp);
X	    ap->subj = Nullsubj;
X	    subject_count--;
X	}
X    }
X    onemissing(ap);
X}
X
X/* get the header line from an article's cache or parse the article trying */
X
Xchar *
Xfetchcache(artnum,which_line,fill_cache)
XART_NUM artnum;
Xint which_line;
Xbool_int fill_cache;
X{
X    register char *s;
X    register ARTICLE *ap;
X    register bool cached = (htype[which_line].ht_flags & HT_CACHED);
X
X    /* find_article() returns a Nullart if the artnum value is invalid */
X    if (!(ap = find_article(artnum)) || (ap->flags & AF_MISSING))
X	return nullstr;
X    if (cached && (s=get_cached_line(ap,which_line,untrim_cache)) != Nullch)
X	return s;
X    if (!fill_cache)
X	return Nullch;
X    if (!parseheader(artnum))
X	return nullstr;
X    if (cached)
X	return get_cached_line(ap,which_line,untrim_cache);
X    return Nullch;
X}
X
X/* Return a pointer to a cached header line for the indicated article.
X** Truncated headers (e.g. from a .thread file) are optionally ignored.
X*/
Xchar *
Xget_cached_line(ap, which_line, no_truncs)
Xregister ARTICLE *ap;
Xint which_line;
Xbool_int no_truncs;
X{
X    register char *s;
X
X    switch (which_line) {
X    case SUBJ_LINE:
X	if (!ap->subj || (no_truncs && (ap->subj->flags & SF_SUBJTRUNCED)))
X	    s = Nullch;
X	else
X	    s = ap->subj->str + ((ap->flags & AF_HAS_RE) ? 0 : 4);
X	break;
X    case FROM_LINE:
X	if (no_truncs && (ap->flags & AF_FROMTRUNCED))
X	    s = Nullch;
X	else
X	    s = ap->from;
X	break;
X#ifdef DBM_XREFS
X    case NGS_LINE:
X#else
X    case XREF_LINE:
X#endif
X	s = ap->xrefs;
X	break;
X    case MESSID_LINE:
X	s = ap->msgid;
X	break;
X    default:
X	s = Nullch;
X	break;
X    }
X    return s;
X}
X
Xvoid
Xset_subj_line(ap, subj, size)
Xregister ARTICLE *ap;
Xregister char *subj;	/* not yet allocated, so we can tweak it first */
Xregister int size;
X{
X    HASHDATUM data;
X    SUBJECT *sp;
X    char *newsubj, *subj_start;
X    char *t, *f;
X    int i;
X
X    while (*subj && *subj != '\n' && (unsigned char)*subj <= ' ')
X	subj++;
X    if (subj != (subj_start = get_subject_start(subj))) {
X	if ((size -= subj_start - subj) < 0)
X	    size = 0;
X	ap->flags |= AF_HAS_RE;
X    }
X    if (ap->subj && strnEQ(ap->subj->str+4, subj_start, size))
X	return;
X
X    newsubj = safemalloc(size + 4 + 1);
X    strcpy(newsubj, "Re: ");
X    for (t = newsubj + 4, f = subj_start, i = size; i--; ) {
X	if (*f == ' ' || *f == '\t') {
X	    while (i && (*++f == ' ' || *f == '\t'))
X		i--, size--;
X	    *t++ = ' ';
X	} else if (*f != '\n')
X	    *t++ = *f++;
X	else
X	    f++;
X    }
X    *t = '\0';
X
X    if (ap->subj) {
X	/* This only happens when we freshen truncated subjects */
X	hashdelete(subj_hash, ap->subj->str+4, strlen(ap->subj->str+4));
X	free(ap->subj->str);
X	ap->subj->str = newsubj;
X	data.dat_ptr = (char*)ap->subj;
X	hashstore(subj_hash, newsubj + 4, size, data);
X    } else {
X	data = hashfetch(subj_hash, newsubj + 4, size);
X	if (!(sp = (SUBJECT*)data.dat_ptr)) {
X	    sp = (SUBJECT*)safemalloc(sizeof (SUBJECT));
X	    bzero((char*)sp, sizeof (SUBJECT));
X	    subject_count++;
X	    if ((sp->prev = last_subject) != NULL)
X		sp->prev->next = sp;
X	    else
X		first_subject = sp;
X	    last_subject = sp;
X	    sp->str = newsubj;
X	    sp->thread_link = sp;
X	    sp->flags = SF_THREAD;
X
X	    data.dat_ptr = (char*)sp;
X	    hashstorelast(data);
X	} else
X	    free(newsubj);
X	ap->subj = sp;
X    }
X}
X
Xvoid
Xset_cached_line(ap, which_line, s)
Xregister ARTICLE *ap;
Xregister int which_line;
Xregister char *s;		/* already allocated, ready to save */
X{
X    /* SUBJ_LINE is handled specially above */
X    switch (which_line) {
X    case FROM_LINE:
X	ap->flags &= ~AF_FROMTRUNCED;
X	if (ap->from)
X	    free(ap->from);
X	ap->from = s;
X	break;
X#ifdef DBM_XREFS
X    case NGS_LINE:
X	if (ap->xrefs && ap->xrefs != nullstr)
X	    free(ap->xrefs);
X	if (!index(s, ',')) {	/* if no comma, no Xref! */
X	    free(s);
X	    s = nullstr;
X	}
X	ap->xrefs = s;
X	break;
X#else
X    case XREF_LINE:
X	if (ap->xrefs && ap->xrefs != nullstr)
X	    free(ap->xrefs);
X# ifdef USE_NNTP
X	if (strEQ(s, "(none)")) {
X	    free(s);
X	    s = nullstr;
X	}
X# endif
X	ap->xrefs = s;
X	break;
X#endif
X    case MESSID_LINE:
X	if (ap->msgid)
X	    free(ap->msgid);
X	ap->msgid = s;
X	break;
X    }
X}
X
Xint
Xsubject_cmp(key, keylen, data)
Xchar *key;
Xint keylen;
XHASHDATUM data;
X{
X    /* We already know that the lengths are equal, just compare the strings */
X    return bcmp(key, ((SUBJECT*)data.dat_ptr)->str+4, keylen);
X}
X
X/* see what we can do while they are reading */
X
X#ifdef PENDING
Xvoid
Xlook_ahead()
X{
X#ifdef ARTSEARCH
X    register char *h, *s;
X
X#ifdef DEBUG
X    if (debug && srchahead) {
X	printf("(%ld)",(long)srchahead);
X	fflush(stdout);
X    }
X#endif
X#endif
X
X    if (ThreadedGroup) {
X	artp = curr_artp;
X	inc_art(selected_only,FALSE);
X	if (artp)
X	    parseheader(art);
X    }
X    else
X#ifdef ARTSEARCH
X    if (srchahead && srchahead < art) {	/* in ^N mode? */
X	char *pattern;
X
X	pattern = buf+1;
X	strcpy(pattern,": *");
X	h = pattern + strlen(pattern);
X	interp(h,(sizeof buf) - (h-buf),"%\\s");
X	{			/* compensate for notesfiles */
X	    register int i;
X	    for (i = 24; *h && i--; h++)
X		if (*h == '\\')
X		    h++;
X	    *h = '\0';
X	}
X#ifdef DEBUG
X	if (debug & DEB_SEARCH_AHEAD) {
X	    fputs("(hit CR)",stdout);
X	    fflush(stdout);
X	    gets(buf+128);
X	    printf("\npattern = %s\n",pattern);
X	}
X#endif
X	if ((s = compile(&srchcompex,pattern,TRUE,TRUE)) != Nullch) {
X				    /* compile regular expression */
X	    printf("\n%s\n",s) FLUSH;
X	    srchahead = 0;
X	}
X	if (srchahead) {
X	    srchahead = art;
X	    for (;;) {
X		srchahead++;	/* go forward one article */
X		if (srchahead > lastart) { /* out of articles? */
X#ifdef DEBUG
X		    if (debug)
X			fputs("(not found)",stdout);
X#endif
X		    break;
X		}
X		if (!was_read(srchahead) &&
X		    wanted(&srchcompex,srchahead,0)) {
X				    /* does the shoe fit? */
X#ifdef DEBUG
X		    if (debug)
X			printf("(%ld)",(long)srchahead);
X#endif
X		    parseheader(srchahead);
X		    break;
X		}
X		if (input_pending())
X		    break;
X	    }
X	    fflush(stdout);
X	}
X    }
X    else
X#endif /* ARTSEARCH */
X    {
X	if (art+1 <= lastart)		/* how about a pre-fetch? */
X	    parseheader(art+1);		/* look for the next article */
X    }
X}
X#endif /* PENDING */
X
X/* see what else we can do while they are reading */
X
Xvoid
Xcache_until_key()
X{
X#ifdef PENDING
X    if (!in_ng || input_pending())
X	return;
X
X    untrim_cache = TRUE;
X    sentinel_artp = curr_artp;
X
X    /* Prioritize our caching based on what mode we're in */
X    if (mode == 't') {
X	if (cache_subjects())
X	    if (cache_xrefs())
X		if (ThreadedGroup)
X		    cache_all_arts();
X		else
X		    cache_unread_arts();
X    } else {
X	if (!ThreadedGroup || cache_all_arts())
X	    if (cache_subjects())
X		if (cache_unread_arts())
X		    cache_xrefs();
X    }
X
X    setspin(SPIN_OFF);
X    untrim_cache = FALSE;
X#endif
X}
X
X#ifdef PENDING
Xbool
Xcache_subjects()
X{
X    register ARTICLE *ap;
X    register ART_NUM an;
X
X    if (subj_to_get > lastart)
X	return TRUE;
X    setspin(SPIN_BACKGROUND);
X    for (an = subj_to_get, ap = article_ptr(an); an <= lastart; ap++, an++) {
X	if (input_pending())
X	    break;
X	if (!(ap->flags & AF_READ))
X	    fetchsubj(an,FALSE);
X    }
X    subj_to_get = an;
X    return subj_to_get > lastart;
X}
X
Xbool
Xcache_xrefs()
X{
X    register ARTICLE *ap;
X    register ART_NUM an;
X
X    if (olden_days || xref_to_get > lastart)
X	return TRUE;
X    setspin(SPIN_BACKGROUND);
X    for (an = xref_to_get, ap = article_ptr(an); an <= lastart; ap++, an++) {
X	if (input_pending())
X	    break;
X	if (!(ap->flags & AF_READ))
X	    fetchxref(an,FALSE);
X    }
X    xref_to_get = an;
X    return xref_to_get > lastart;
X}
X
Xbool
Xcache_all_arts()
X{
X    if (!cached_all_in_range)
X	last_cached = first_cached-1;
X    if (last_cached >= lastart && first_cached <= absfirst)
X	return TRUE;
X
X    /* turn it on as late as possible to avoid fseek()ing openart */
X    setspin(SPIN_BACKGROUND);
X    if (last_cached < lastart) {
X	if (!art_data(last_cached+1, lastart, TRUE, TRUE))
X	    return FALSE;
X	cached_all_in_range = TRUE;
X    }
X    if (first_cached > absfirst) {
X	if (ov_opened)
X	    ov_data(absfirst, first_cached-1, TRUE);
X	else
X	    art_data(absfirst, first_cached-1, TRUE, TRUE);
X	/* If we got interrupted, make a quick exit */
X	if (first_cached > absfirst)
X	    return FALSE;
X    }
X    /* We're all done threading the group, so if the current article is
X    ** still in doubt, tell them it's missing. */
X    if (curr_artp && !(curr_artp->flags & AF_CACHED) && !input_pending())
X	pushchar('\f' | 0200);
X    return TRUE;
X}
X
Xbool
Xcache_unread_arts()
X{
X    if (last_cached >= lastart)
X	return TRUE;
X    setspin(SPIN_BACKGROUND);
X    return art_data(last_cached+1, lastart, TRUE, FALSE);
X}
X#endif
X
Xbool
Xart_data(first, last, cheating, all_articles)
XART_NUM first, last;
Xbool_int cheating;
Xbool_int all_articles;
X{
X    register ARTICLE *ap;
X    register ART_NUM i;
X    int cachemask = (ThreadedGroup ? AF_THREADED : AF_CACHED)
X		  + (all_articles? 0 : AF_READ);
X
X    setspin(cheating? SPIN_BACKGROUND : SPIN_FOREGROUND);
X    assert(first >= absfirst && last <= lastart);
X    for (i = first, ap = article_ptr(first); i <= last; i++, ap++) {
X	if (ap->flags & cachemask)
X	    continue;
X	if (int_count) {
X	    int_count = 0;
X	    break;
X	}
X	if (cheating) {
X	    if (input_pending())
X		break;
X	    /* If the current article is no longer a '?', let them know. */
X	    if (curr_artp != sentinel_artp) {
X		pushchar('\f' | 0200);
X		break;
X	    }
X	}
X	/* This parses the header which will cache/thread the article */
X	(void) parseheader(i);
X    }
X    setspin(SPIN_POP);
X    if (--i > last_cached)
X	last_cached = i;
X    if (i == last) {
X	if (first < first_cached)
X	    first_cached = first;
X	return TRUE;
X    }
X    return FALSE;
X}
X
Xbool
Xcache_range(first,last)
XART_NUM first;
XART_NUM last;
X{
X    bool success = TRUE;
X    bool all_arts = (sel_rereading || thread_always);
X    ART_NUM count = 0;
X
X    if (sel_rereading && !cached_all_in_range) {
X	first_cached = first;
X	last_cached = first-1;
X    }
X    if (first < first_cached)
X	count = first_cached-first;
X    if (last > last_cached)
X	count += last-last_cached;
X    if (!count)
X	return TRUE;
X
X    if (first_cached > last_cached) {
X	if (sel_rereading) {
X	    if (first_subject)
X		count -= toread[ng];
X	} else if (first == firstart && last == lastart && !all_arts)
X	    count = toread[ng];
X    }
X
X    printf("\n%sing %ld article%s.", ThreadedGroup? "Thread" : "Cach",
X	   (long)count, count==1? nullstr : "s") FLUSH;
X
X    setspin(SPIN_FOREGROUND);
X
X    if (first < first_cached) {
X	if (ov_opened) {
X	    ov_data(absfirst,first_cached-1,FALSE);
X	    if ((success = (first_cached == absfirst)) != FALSE)
X		ov_close();
X	} else {
X	    success = art_data(first, first_cached-1, FALSE, all_arts);
X	    cached_all_in_range = (all_arts && success);
X	}
X    }
X    if (success && last_cached < last) {
X	success = art_data(last_cached+1, last, FALSE, all_arts);
X	cached_all_in_range = (all_arts && success);
X    }
X    setspin(SPIN_POP);
X    return success;
X}
X
Xvoid
Xclear_article(ap)
Xregister ARTICLE *ap;
X{
X    if (ap->from)
X	free(ap->from);
X    if (ap->msgid)
X	free(ap->msgid);
X    if (ap->xrefs && ap->xrefs != nullstr)
X	free(ap->xrefs);
X}
END_OF_FILE
if test 17951 -ne `wc -c <'cache.c'`; then
    echo shar: \"'cache.c'\" unpacked with wrong size!
fi
# end of 'cache.c'
fi
if test -f 'help.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help.c'\"
else
echo shar: Extracting \"'help.c'\" \(17232 characters\)
sed "s/^X//" >'help.c' <<'END_OF_FILE'
X/* $Id: help.c,v 3.0 1992/02/01 03:09:32 davison Trn $
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "trn.h"
X#include "term.h"
X#include "INTERN.h"
X#include "help.h"
X
Xvoid
Xhelp_init()
X{
X    ;
X}
X
Xint
Xhelp_page()
X{
X    int cmd;
X
X#ifdef PAGERHELP
X    doshell(sh,filexp(PAGERHELP));
X#else
X    page_init();
X    if ((cmd = print_lines("\
XPaging commands:\n\
X",STANDOUT)) ||
X    (cmd = print_lines("\n\
XSP	Display the next page.\n\
Xx	Display the next page decrypted (rot13).\n\
Xd	Display half a page more.\n\
XCR	Display one more line.\n\
X^R,v,^X	Restart the current article (v=verbose header, ^X=rot13).\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xb	Back up one page.\n\
X^L,X	Refresh the screen (X=rot13).\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xt	Display the entire article tree and all its subjects.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xg pat	Go to (search forward within article for) pattern.\n\
XG	Search again for current pattern within article.\n\
X^G	Search for next line beginning with \"Subject:\".\n\
XTAB	Search for next line beginning with a different character.\n\
Xq	Quit the pager, go to end of article.  Leave article read or unread.\n\
Xj	Junk this article (mark it read).  Goes to end of article.\n\
X\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
XThe following commands skip the rest of the current article, then behave\n\
Xjust as if typed to the 'What next?' prompt at the end of the article:\n\
X",STANDOUT)) ||
X    (cmd = print_lines("\n\
Xn	Scan forward for next unread article.\n\
XN	Go to next article.\n\
X^N	Scan forward for next unread article with same title.\n\
Xp,P,^P	Same as n,N,^N, only going backwards.\n\
X-	Go to previously displayed article.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X<, >	Browse the previous/next selected thread.  If no threads are selected,\n\
X	all threads that had unread news upon entry to the group are considered\n\
X	selected for browsing.  Entering an empty group browses all threads.\n\
X[, ]	Go to article's parent/child (try left-/right-arrow also).\n\
X(, )	Go to article's previous/next sibling (try up-/down-arrow also).\n\
X{, }	Go to tree's root/leaf.\n\
X\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
XThe following commands also take you to the end of the article.\n\
XType h at end of article for a description of these commands:\n\
X",STANDOUT)) ||
X    (cmd = print_lines("\
X	# $ & / = ? c C f F k K ^K J , m M number e r R ^R s S u U v w W Y ^ |\n\
X\n\
X(To return to the middle of the article after one of these commands, type ^L.)\n\
X",NOMARKING)) )
X	return cmd;
X#endif
X    return 0;
X}
X
Xint
Xhelp_art()
X{
X    int cmd;
X#ifdef ARTHELP
X    doshell(sh,filexp(ARTHELP));
X#else
X    page_init();
X    if ((cmd = print_lines("\
XArticle Selection commands:\n\
X",STANDOUT)) ||
X    (cmd = print_lines("\n\
Xn,SP	Find next unread article (follows discussion-tree in threaded groups).\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
XN	Go to next article.\n\
X^N	Scan forward for next unread article with same subject in date order.\n\
Xp,P,^P	Same as n,N,^N, only going backwards.\n\
X_N,_P	Go to the next/previous article numerically.\n\
X-	Go to previously displayed article.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X<, >	Browse the previous/next selected thread.  If no threads are selected,\n\
X	all threads that had unread news upon entry to the group are considered\n\
X	selected for browsing.  Entering an empty group browses all threads.\n\
X[, ]	Go to article's parent/child (try left-/right-arrow also).\n\
X(, )	Go to article's previous/next sibling (try up-/down-arrow also).\n\
X{, }	Go to tree's root/leaf.\n\
Xt	Display the entire article tree and all its subjects.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xnumber	Go to specified article.\n\
Xrange{,range}:command{:command}\n\
X	Apply one or more commands to one or more ranges of articles.\n\
X	Ranges are of the form: number | number-number.  You may use . for\n\
X	the current article, and $ for the last article.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X 	Valid commands are: e, j, m, M, s, S, t, T, |, +, ++, -, and --.\n\
X:cmd	Perform a command on all the selected articles.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X/pattern/modifiers\n\
X	Scan forward for article containing pattern in the subject line.\n\
X	(Use ?pat? to scan backwards; append f to scan from lines, h to scan\n\
X	whole headers, a to scan entire articles, r to scan read articles, c\n\
X	to make case-sensitive.)\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X/pattern/modifiers:command{:command}\n\
X	Apply one or more commands to the set of articles matching pattern.\n\
X	Use a K modifier to save entire command to the KILL file for this\n\
X	newsgroup.  Commands m and M, if first, imply an r modifier.\n\
X 	Valid commands are the same as for the range command.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xf,F	Submit a followup article (F = include this article).\n\
Xr,R	Reply through net mail (R = include this article).\n\
Xe dir{|command}\n\
X	Extract to directory using /bin/sh, uudecode, unship, or command.\n\
Xs ...	Save to file or pipe via sh.\n\
XS ...	Save via preferred shell.\n\
Xw,W	Like s and S but save without the header.\n\
X| ...	Same as s|...\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
XC	Cancel this article, if yours.\n\
X^R,v	Restart article (v=verbose).\n\
X^X	Restart article, rot13 mode.\n\
Xc	Catch up (mark all articles as read).\n\
Xb	Back up one page.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X^L	Refresh the screen.  You can get back to the pager with this.\n\
XX	Refresh screen in rot13 mode.\n\
X^	Go to first unread article.  Disables subject search mode.\n\
X$	Go to end of newsgroup.  Disables subject search mode.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("#       Print last article number.\n\
X&	Print current values of command-line switches.\n\
X&switch {switch}\n\
X	Set or unset more switches.\n\
X&&	Print current macro definitions.\n\
X&&def	Define a new macro.\n\
Xj	Junk this article (mark it read).  Stays at end of article.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xm	Mark article as still unread.\n\
XM	Mark article as read but to-return on group exit or Y command.\n\
XY	Yank back articles marked as to-return via the M command.\n\
Xk	Kill current subject (mark articles as read).\n\
X,	Mark current article and its replies as read.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
XJ	Junk entire thread (mark all subjects as read in this thread).\n\
XA	Add current subject to memorized commands (selection or killing).\n\
XT	Add current (sub)thread to memorized commands (selection or killing).\n\
XK	Mark current subject as read, and save command in KILL file.\n\
X^K	Edit local KILL file (the one for this newsgroup).\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X=	List subjects of unread articles.\n\
X+	Start the selector in whatever mode it was last in.\n\
X_a	Start the article selector.\n\
X_s	Start the subject selector.\n\
X_t	Start the thread selector.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X_T	Start the thread selector if threaded, else the subject selector.\n\
XU	Unread some news -- prompts for thread, subthread, all, or select.\n\
Xu	Unsubscribe from this newsgroup.\n\
Xq	Quit this newsgroup for now.\n\
XQ	Quit newsgroup, staying at current newsgroup.\n\
X",NOMARKING)) )
X	return cmd;
X#endif
X    return 0;
X}
X
Xint
Xhelp_ng()
X{
X    int cmd;
X#ifdef NGHELP
X    doshell(sh,filexp(NGHELP));
X#else
X    page_init();
X    if (cmd = print_lines("\
XNewsgroup Selection commands:\n\
X",STANDOUT) )
X	return cmd;
X    if (ng != nextrcline) {
X	if ((cmd = print_lines("\
X\n\
Xy	Do this newsgroup now.\n\
XSP	Do this newsgroup, executing the default command listed in []'s.\n\
X.cmd	Do this newsgroup, executing cmd as first command.\n\
X+	Enter this newsgroup through the selector (like typing .+<CR>).\n\
X=	Start this newsgroup, but list subjects before reading articles.\n\
XU	Enter this newsgroup by way of the \"Set unread?\" prompt.\n\
Xu	Unsubscribe from this newsgroup.\n\
X",NOMARKING)) )
X	    return cmd;
X    }
X    if ((cmd = print_lines("\
Xt	Toggle the newsgroup between threaded and unthreaded reading.\n\
Xc	Catch up (mark all articles as read).\n\
XA	Abandon read/unread changes to this newsgroup since you started trn.\n\
Xn	Go to the next newsgroup with unread news.\n\
XN	Go to the next newsgroup.\n\
Xp	Go to the previous newsgroup with unread news.\n\
XP	Go to the previous newsgroup.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X-	Go to the previously displayed newsgroup.\n\
X1	Go to the first newsgroup.\n\
X^	Go to the first newsgroup with unread news.\n\
X$	Go to the last newsgroup.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xg name	Go to the named newsgroup.  Subscribe to new newsgroups this way too.\n\
X/pat	Search forward for newsgroup matching pattern.\n\
X?pat	Search backward for newsgroup matching pattern.\n\
X	(Use * and ? style patterns.  Append r to include read newsgroups.)\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xl pat	List unsubscribed newsgroups containing pattern.\n\
Xm name	Move named newsgroup elsewhere (no name moves current newsgroup).\n\
Xo pat	Only display newsgroups matching pattern.  Omit pat to unrestrict.\n\
XO pat	Like o, but skip empty groups.\n\
Xa pat	Like o, but also scans for unsubscribed newsgroups matching pattern.\n\
XL	List current .newsrc.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X&	Print current command-line switch settings.\n\
X&switch {switch}\n\
X	Set (or unset) more command-line switches.\n\
X&&	Print current macro definitions.\n\
X&&def	Define a new macro.\n\
X!cmd	Shell escape.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xq	Quit trn.\n\
Xx	Quit, restoring .newsrc to its state at startup of trn.\n\
X^K	Edit the global KILL file.  Use commands like /pattern/j to suppress\n\
X	pattern in every newsgroup.\n\
Xv	Print version and the address for reporting bugs.\n\
X",NOMARKING)) )
X	return cmd;
X#endif
X    if (cmd = get_anything())
X	return cmd;
X    show_macros();
X    return 0;
X}
X
X#ifdef ESCSUBS
Xint
Xhelp_subs()
X{
X    int cmd;
X#ifdef SUBSHELP
X    doshell(sh,filexp(SUBSHELP));
X#else
X    page_init();
X    if ((cmd = print_lines("\
XValid substitutions are:\n\
X",STANDOUT)) ||
X    (cmd = print_lines("\
X\n\
Xa	Current article number\n\
XA	Full name of current article (%P/%c/%a)\n\
Xb	Destination of last save command, often a mailbox\n\
XB	Bytes to ignore at beginning of last saved article\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xc	Current newsgroup, directory form\n\
XC	Current newsgroup, dot form\n\
Xd	Full name of newsgroup directory (%P/%c)\n\
XD	Distribution line from current article\n\
Xe	The last command executed to extract data from an article\n\
XE	The last extraction directory\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xf	Who the current article is from\n\
XF	Newsgroups to followup to (from Newsgroups and Followup-To)\n\
Xh	(This help message)\n\
XH	Host name (yours)\n\
Xi	Message-I.D. line from current article, with <>\n\
XI	Reference indicator mark (see -F switch)\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xl	News administrator's login name, if any\n\
XL	Login name (yours)\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xm	Current mode, first letter of (init,newsgroup,thread,article,pager,\n\
X		unread,Add,Catchup,Delete-bogus,Mailbox,Resubscribe)\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
XM	Number of article marked with M\n\
Xn	Newsgroups from current article\n\
XN	Full name (yours)\n\
Xo	Organization (yours)\n\
XO	Original working directory (where you ran trn from)\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xp	Your private news directory (from -d)\n\
XP	Public news spool directory\n\
Xr	Last reference (parent article id)\n\
XR	References list for followup article\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
Xs	Subject, with all Re's and (nf)'s stripped off\n\
XS	Subject, with one Re stripped off\n\
Xt	New To line derived from From and Reply-To (Internet format)\n\
XT	New To line derived from Path\n\
Xu	Number of unread articles\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
XU	Number of unread articles not counting the current article (when\n\
X	threads are selected, the count only reflects selected articles)\n\
Xv	The number of extra (unselected) articles, not counting the current\n\
X	one if it is unselected\n\
XW	Where thread files are saved\n\
Xx	News library directory\n\
XX	Trn library directory\n\
Xz	Length of current article in bytes\n\
XZ	Number of selected threads\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X~	Your home directory\n\
X.	Directory containing the \"dot\" files, such as .newsrc\n\
X#	A counter in multi-article saves\n\
X$	Current process number\n\
X/	Last search string\n\
XESC	Run preceding command through % interpretation\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
XPut ^ in the middle to capitalize the first letter: %^C = Rec.humor\n\
XPut _ in the middle to capitalize the last component: %_c = rec/Humor\n\
XPut \\ in the middle to quote regexp and % characters in the resulting string\n\
XPut :FMT in the middle to format the result printf-style:  %:-30.30t\n\
X",NOMARKING)) )
X	return cmd;
X#endif
X    return 0;
X}
X#endif
X
Xint
Xhelp_select()
X{
X    int cmd;
X
X    page_init();
X    if ((cmd = print_lines("\
XSelection commands:\n\
X",STANDOUT)) ||
X    (cmd = print_lines("\n\
Xa-z,0-9	Select/deselect the indicated item by its letter or number.  Many of\n\
X	the alpha letters are ommitted for the following commands.\n\
XSP	Perform the default command (usually > or Z).\n\
XCR	Start reading.  Selects the current item if nothing is selected.\n\
XZ,TAB	Start reading.  If nothing is selected, read all unread articles.\n\
X.	Toggle the current item's selection.\n\
X*	Same as '.' except that it affects all items with the same subject.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X#	Read the current item only, temporarily ignoring all other selections.\n\
Xk, ','	Mark the current item as killed.\n\
Xm, \\	Unmark the current item.\n\
X-	Set a range, as in d - f.  Repeats the last marking action.\n\
X@	Toggle the selection of all visible items.\n\
XM	Mark the current item's article(s) as to-return and kill the item.\n\
XY	Yank back and select articles marked to return via M.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
XE	Toggle exclusion of non-selected items from the selection list.\n\
Xn, ]	Move down to the next item (try down-arrow also).\n\
Xp, [	Move up to the previous item (try up-arrow also).\n\
X<, >	Go to previous/next page (try left-/right-arrow also).\n\
X^, $	Go to first/last page.\n\
XS	Set what the selector displays:  threads, subjects, or articles.\n\
X	If the group is unthreaded, choosing threads will thread it.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X=	Toggle between the article and thread/subject selector.\n\
XO	Set the selector's order.  A separate default is kept for the\n\
X	article and subject/thread selector.\n\
XR	Reverse the current sort order.\n\
XL	Switch the display between a short style without authors and a\n\
X	medium or long style with authors.\n\
XU	Switch between selecting unread/read articles.\n\
XX	Mark all unselected articles as read and start reading.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
XD	Mark unselected articles on the current page as read.  Start\n\
X	reading if articles were selected, else go to next page.\n\
XJ	Junk all selected articles (mark them as read).\n\
Xc	Catch up -- marks ALL articles as read without chasing xrefs.\n\
XA	Add current subject to memorized commands (selection or killing).\n\
XT	Add current thread to memorized commands (selection or killing).\n\
X^K	Edit local KILL file (the one for this newsgroup).\n\
XN	Leave this group as-is and go on to the next one.\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
XP	Leave this group as-is and go on to the previous one.\n\
X:cmd	Perform a command on all the selected articles.\n\
X/pattern/modifiers\n\
X	Scan all articles for a subject containing pattern.\n\
X	(Append f to scan the from line, h to scan whole headers, a to scan\n\
X	entire articles, c to make it case-sensitive, r to scan read articles\n\
X	(assumed when you are selecting read articles to set unread.)\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X/pattern/modifiers:command{:command}\n\
X	Apply one or more commands to the set of articles matching pattern.\n\
X	Use a K modifier to save entire command to the KILL file for this\n\
X	newsgroup.  Commands m and M, if first, imply an r modifier.\n\
X 	Valid commands are: e, E, j, m, M, s, S, t, T, !, =, ',' and the\n\
X	article/thread (de)selection commands: +/++ (-/--).\n\
X",NOMARKING)) ||
X    (cmd = print_lines("\
X&	View or set command line switches.\n\
X&&	View or set macro definitions.\n\
X!cmd	Escape to a subshell.\n\
Xq	Quit the selector.\n\
XQ	Quit group and return to news group selection prompt for this group.\n\
X",NOMARKING)) )
X	return cmd;
X    return 0;
X}
END_OF_FILE
if test 17232 -ne `wc -c <'help.c'`; then
    echo shar: \"'help.c'\" unpacked with wrong size!
fi
# end of 'help.c'
fi
if test -f 'rt-page.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rt-page.c'\"
else
echo shar: Extracting \"'rt-page.c'\" \(16170 characters\)
sed "s/^X//" >'rt-page.c' <<'END_OF_FILE'
X/* $Id: rt-page.c,v 3.0 1992/12/14 00:14:12 davison Trn $
X*/
X/* The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "cache.h"
X#include "term.h"
X#include "ngdata.h"
X#include "trn.h"
X#include "util.h"
X#include "rthread.h"
X#include "rt-select.h"
X#include "rt-util.h"
X#include "INTERN.h"
X#include "rt-page.h"
X
Xextern char *display_mode;
Xextern char sel_disp_char[];
X
Xbool
Xset_sel_mode(ch)
Xchar_int ch;
X{
X    switch (ch) {
X    case 'a':
X	set_selector(SM_ARTICLE, sel_artsort);
X	break;
X    case 's':
X	set_selector(SM_SUBJECT, sel_threadsort);
X	break;
X    case 't':
X	if (in_ng && !ThreadedGroup) {
X	    bool always_save = thread_always;
X	    ThreadedGroup = TRUE;
X	    thread_always = TRUE;
X	    if (sel_rereading)
X		firstart = absfirst;
X	    printf("\nThreading the group. "), fflush(stdout);
X	    thread_open();
X	    thread_always = always_save;
X	    if (last_cached < lastart)
X		ThreadedGroup = FALSE;
X	}
X	/* FALL THROUGH */
X    case 'T':
X	set_selector(SM_THREAD, sel_threadsort);
X	break;
X    default:
X	return FALSE;
X    }
X    return TRUE;
X}
X
Xbool
Xset_sel_sort(ch)
Xchar_int ch;
X{
X    if (isupper(ch)) {
X	sel_direction = -1;
X	ch = tolower(ch);
X    } else
X	sel_direction = 1;
X    switch (ch) {
X    case 'd':
X	sel_sort = SS_DATE;
X	break;
X    case 's':
X	sel_sort = SS_SUBJECT;
X	break;
X    case 'a':
X	sel_sort = SS_AUTHOR;
X	break;
X    case 'c':
X	sel_sort = SS_COUNT;
X	break;
X    case 'g':
X	sel_sort = SS_GROUPS;
X	break;
X    default:
X	return FALSE;
X    }
X    if (sel_mode == SM_ARTICLE)
X	set_selector(sel_mode, sel_sort);
X    else
X	set_selector(sel_threadmode, sel_sort);
X    return TRUE;
X}
X
Xvoid
Xset_selector(smode, ssort)
Xint smode;
Xint ssort;
X{
X    sel_mode = smode;
X    sel_sort = ssort;
X
X    if (!ThreadedGroup && sel_mode == SM_THREAD)
X	sel_mode = SM_SUBJECT;
X
X    if (sel_mode == SM_ARTICLE) {
X	if (sel_sort == SS_COUNT)
X	    sel_sort = SS_DATE;
X    } else if (sel_sort == SS_AUTHOR || sel_sort == SS_GROUPS)
X	sel_sort = SS_DATE;
X
X    switch (sel_mode) {
X    case SM_THREAD:
X	sel_mode_string = "threads";
X	sel_threadmode = smode;
X	sel_threadsort = ssort;
X	break;
X    case SM_SUBJECT:
X	sel_mode_string = "subjects";
X	sel_threadmode = smode;
X	sel_threadsort = ssort;
X	break;
X    case SM_ARTICLE:
X	sel_mode_string = "articles";
X	sel_artsort = ssort;
X	break;
X    }
X
X    switch (sel_sort) {
X    case SS_DATE:
X	sel_sort_string = "date";
X	break;
X    case SS_SUBJECT:
X	sel_sort_string = "subject";
X	break;
X    case SS_AUTHOR:
X	sel_sort_string = "author";
X	break;
X    case SS_COUNT:
X	sel_sort_string = "count";
X	break;
X    case SS_GROUPS:
X	sel_sort_string = "SubjDate";
X	break;
X    }
X}
X
Xvoid
Xinit_pages()
X{
Xtry_again:
X    sel_prior_arts = sel_total_arts = 0;
X
X    if (sel_mode == SM_ARTICLE) {
X	ARTICLE *ap, **app, **limit;
X
X	if (sel_page_app) {
X	    int desired_flags = (sel_rereading? AF_READ : 0);
X	    limit = artptr_list + artptr_list_size;
X	    for (app = sel_page_app; app < limit; app++) {
X		ap = *app;
X		if ((ap->flags & (AF_MISSING|AF_READ)) == desired_flags)
X		    break;
X	    }
X	    sort_articles();
X	    if (app == limit)
X		sel_page_app = artptr_list + artptr_list_size;
X	    else {
X		for (app = artptr_list; app < limit; app++) {
X		    if (*app == ap) {
X			sel_page_app = app;
X			break;
X		    }
X		}
X	    }
X	} else
X	    sort_articles();
X
X	while (sel_page_sp && sel_page_sp->misc == 0)
X	    sel_page_sp = sel_page_sp->next;
X	/* The artptr_list contains only unread or read articles, never both */
X	limit = artptr_list + artptr_list_size;
X	for (app = artptr_list; app < limit; app++) {
X	    ap = *app;
X	    if (sel_rereading && !(ap->flags & sel_mask))
X		ap->flags |= AF_DEL;
X	    if (sel_page_app == app
X	     || (!sel_page_app && ap->subj == sel_page_sp)) {
X		sel_page_app = app;
X		sel_prior_arts = sel_total_arts;
X	    }
X	    if (!sel_exclusive || (ap->flags & sel_mask)) {
X		sel_total_arts++;
X		ap->flags |= AF_INCLUDED;
X	    } else
X		ap->flags &= ~AF_INCLUDED;
X	}
X	if (sel_exclusive && !sel_total_arts) {
X	    sel_exclusive = FALSE;
X	    goto try_again;
X	}
X	if (!sel_page_app)
X	    (void) first_page();
X	else if (sel_page_app >= limit)
X	    (void) last_page();
X    } else {
X	SUBJECT *sp, *group_sp;
X	int group_arts;
X
X	if (sel_page_sp) {
X	    while (sel_page_sp && sel_page_sp->misc == 0)
X		sel_page_sp = sel_page_sp->next;
X	    sort_subjects();
X	    if (!sel_page_sp)
X		sel_page_sp = last_subject;
X	} else
X	    sort_subjects();
X	for (sp = first_subject; sp; sp = sp->next) {
X	    if (sel_rereading && !(sp->flags & sel_mask))
X		sp->flags |= SF_DEL;
X
X	    group_sp = sp;
X	    group_arts = sp->misc;
X
X	    if (!sel_exclusive || (sp->flags & sel_mask))
X		sp->flags |= SF_INCLUDED;
X	    else
X		sp->flags &= ~SF_INCLUDED;
X
X	    if (sel_page_sp == group_sp)
X		sel_prior_arts = sel_total_arts;
X	    if (sel_mode == SM_THREAD) {
X		while (sp->next && sp->next->thread == sp->thread) {
X		    sp = sp->next;
X		    if (sp == sel_page_sp) {
X			sel_prior_arts = sel_total_arts;
X			sel_page_sp = group_sp;
X		    }
X		    sp->flags &= ~SF_INCLUDED;
X		    if (sp->flags & sel_mask)
X			group_sp->flags |= SF_INCLUDED;
X		    else if (sel_rereading)
X			sp->flags |= SF_DEL;
X		    group_arts += sp->misc;
X		}
X	    }
X	    if (group_sp->flags & SF_INCLUDED)
X		sel_total_arts += group_arts;
X	}
X	if (sel_exclusive && !sel_total_arts) {
X	    sel_exclusive = FALSE;
X	    goto try_again;
X	}
X	if (!sel_page_sp)
X	    (void) first_page();
X	else if (sel_page_sp == last_subject)
X	    (void) last_page();
X    }
X}
X
Xbool
Xfirst_page()
X{
X    sel_prior_arts = 0;
X
X    if (sel_mode == SM_ARTICLE) {
X	ARTICLE **app, **limit;
X
X	limit = artptr_list + artptr_list_size;
X	for (app = artptr_list; app < limit; app++) {
X	    if ((*app)->flags & AF_INCLUDED) {
X		if (sel_page_app != app) {
X		    sel_page_app = app;
X		    return TRUE;
X		}
X		break;
X	    }
X	}
X    } else {
X	SUBJECT *sp;
X
X	for (sp = first_subject; sp; sp = sp->next) {
X	    if (sp->flags & SF_INCLUDED) {
X		if (sel_page_sp != sp) {
X		    sel_page_sp = sp;
X		    return TRUE;
X		}
X		break;
X	    }
X	}
X    }
X    return FALSE;
X}
X
Xbool
Xlast_page()
X{
X    sel_prior_arts = sel_total_arts;
X
X    if (sel_mode == SM_ARTICLE) {
X	ARTICLE **app = sel_page_app;
X	sel_page_app = artptr_list + artptr_list_size;
X	if (!prev_page())
X	    sel_page_app = app;
X	else if (app != sel_page_app)
X	    return TRUE;
X    } else {
X	SUBJECT *sp = sel_page_sp;
X	sel_page_sp = Nullsubj;
X	if (!prev_page())
X	    sel_page_sp = sp;
X	else if (sp != sel_page_sp)
X	    return TRUE;
X    }
X    return FALSE;
X}
X
Xbool
Xnext_page()
X{
X    if (sel_mode == SM_ARTICLE) {
X	if (sel_next_app < artptr_list + artptr_list_size) {
X	    sel_page_app = sel_next_app;
X	    sel_prior_arts += sel_page_arts;
X	    return TRUE;
X	}
X    } else {
X	if (sel_next_sp) {
X	    sel_page_sp = sel_next_sp;
X	    sel_prior_arts += sel_page_arts;
X	    return TRUE;
X	}
X    }
X    return FALSE;
X}
X
Xbool
Xprev_page()
X{
X    int item_cnt = 0;
X
X    /* Scan the items in reverse to go back a page */
X    if (sel_mode == SM_ARTICLE) {
X	ARTICLE *ap, **app, **page_app = sel_page_app;
X
X	for (app = sel_page_app; --app >= artptr_list; ) {
X	    ap = *app;
X	    if (ap->flags & AF_INCLUDED) {
X		page_app = app;
X		sel_prior_arts--;
X		if (++item_cnt >= sel_max_cnt)
X		    break;
X	    }
X	}
X	if (sel_page_app != page_app) {
X	    sel_page_app = page_app;
X	    return TRUE;
X	}
X    } else {
X	SUBJECT *sp, *page_sp = sel_page_sp;
X	int line_cnt, item_arts, line;
X
X	line = 2;
X	for (sp = (!page_sp? last_subject : page_sp->prev); sp; sp=sp->prev) {
X	    item_arts = sp->misc;
X	    if (sel_mode == SM_THREAD) {
X		while (sp->prev && sp->prev->thread == sp->thread) {
X		    sp = sp->prev;
X		    item_arts += sp->misc;
X		}
X		line_cnt = count_thread_lines(sp, NULL);
X	    } else
X		line_cnt = count_subject_lines(sp, NULL);
X	    if (!(sp->flags & SF_INCLUDED) || !line_cnt)
X		continue;
X	    if (line_cnt > LINES - 5)
X		line_cnt = LINES - 5;
X	    line += line_cnt;
X	    if (line > LINES - 3) {
X		sp = page_sp;
X		break;
X	    }
X	    sel_prior_arts -= item_arts;
X	    page_sp = sp;
X	    if (++item_cnt >= sel_max_cnt)
X		break;
X	}
X	if (sel_page_sp != page_sp) {
X	    sel_page_sp = (page_sp? page_sp : first_subject);
X	    return TRUE;
X	}
X    }
X    return FALSE;
X}
X
Xvoid
Xdisplay_page()
X{
X    int sel;
X
X    sel_chars = getval("SELECTCHARS", SELECTCHARS);
X    sel_max_cnt = strlen(sel_chars);
X    if (sel_max_cnt > MAX_SEL)
X	sel_max_cnt = MAX_SEL;
X    if (sel_max_cnt > LINES-5)
X	sel_max_cnt = LINES-5;
X#ifndef CLEAREOL
X    clear();
X#else
X    if (can_home_clear) {
X	home_cursor();
X	maybe_eol();
X    } else
X	clear();
X#endif
X    carriage_return();
X
X#ifdef NOFIREWORKS
X    no_sofire();
X#endif
X    standout();
X    fputs(ngname, stdout);
X    un_standout();
X    printf("          %ld %sarticle%s", (long)sel_total_arts,
X	   sel_rereading? "read " : nullstr,
X	   article_count == 1 ? nullstr : "s");
X    if (sel_exclusive)
X	printf(" out of %ld", (long)article_count);
X    printf("%s\n", moderated);
X#ifdef CLEAREOL
X    maybe_eol();
X#endif
X    if (redirected && redirected != nullstr)
X	printf("\t** Please start using %s **", redirected);
X    putchar('\n') FLUSH;
Xtry_again:
X    sel_line = 2;
X    sel_page_arts = 0;
X    sel_item_cnt = 0;
X
X    if (!sel_total_arts)
X	;
X    else if (sel_mode == SM_ARTICLE) {
X	ARTICLE *ap, **app, **limit;
X
X	limit = artptr_list + artptr_list_size;
X	app = sel_page_app;
X	do {
X	    ap = *app;
X	    if (ap == sel_last_ap)
X		sel_item_index = sel_item_cnt;
X	    if (!(ap->flags & AF_INCLUDED))
X		continue;
X	    sel = !!(ap->flags & sel_mask) + (ap->flags & AF_DEL);
X	    sel_items[sel_item_cnt].ptr = (VOIDPTR*)ap;
X	    sel_items[sel_item_cnt].line = sel_line;
X	    sel_items[sel_item_cnt].sel = sel;
X	    sel_page_arts++;
X	    /* Output the article, with optional author */
X	    display_article(ap, sel_chars[sel_item_cnt], sel);
X	    sel_item_cnt++;
X	} while (++app < limit && sel_item_cnt < sel_max_cnt);
X	if (!sel_page_arts) {
X	    if (last_page())
X		goto try_again;
X	}
X	sel_next_app = app;
X    } else {
X	SUBJECT *sp;
X	int line_cnt;
X	bool etc;
X	char ch;
X
X	sp = sel_page_sp;
X	do {
X	    if (sp == sel_last_sp)
X		sel_item_index = sel_item_cnt;
X
X	    etc = FALSE;
X	    if (sp->flags & SF_INCLUDED) {
X		/* Compute how many lines we need to display this group */
X		if (sel_mode == SM_THREAD)
X		    line_cnt = count_thread_lines(sp, &sel);
X		else
X		    line_cnt = count_subject_lines(sp, &sel);
X		if (line_cnt) {
X		    /* If this item is too long to fit on the screen all by
X		    ** itself, trim it to fit and set the "etc" flag.
X		    */
X		    if (line_cnt > LINES - 5) {
X			line_cnt = LINES - 5;
X			etc = TRUE;
X		    }
X		    /* If it doesn't fit, save it for the next page */
X		    if (sel_line + line_cnt > LINES - 3)
X			break;
X		    sel_items[sel_item_cnt].ptr = (VOIDPTR*)sp;
X		    sel_items[sel_item_cnt].line = sel_line;
X		    sel_items[sel_item_cnt].sel = sel;
X		    sel_page_arts += sp->misc;
X
X		    ch = sel_chars[sel_item_cnt];
X		    sel = sel_items[sel_item_cnt].sel;
X		    sel_item_cnt++;
X		    if (sp->misc) {
X			display_subject(sp, ch, sel);
X			ch = ' ';
X		    }
X		}
X	    } else
X		line_cnt = 0;
X	    if (sel_mode == SM_THREAD) {
X		while (sp->next && sp->next->thread == sp->thread) {
X		    sp = sp->next;
X		    if (!line_cnt || !sp->misc)
X			continue;
X		    if (sel_line < LINES - 3)
X			display_subject(sp, ch, sel);
X		    ch = ' ';
X		    sel_page_arts += sp->misc;
X		}
X	    }
X	    if (etc)
X		fputs("      ...etc.", stdout);
X	} while ((sp=sp->next)!=Nullsubj && !etc && sel_item_cnt<sel_max_cnt);
X	if (!sel_page_arts) {
X	    if (last_page())
X		goto try_again;
X	}
X	sel_next_sp = sp;
X    }
X    sel_last_line = sel_line+1;
X    sel_last_ap = Nullart;
X    sel_last_sp = Nullsubj;
X    sel_at_end = (sel_prior_arts + sel_page_arts == sel_total_arts);
X#ifdef CLEAREOL
X    maybe_eol();
X#endif
X    putchar('\n') FLUSH;
X}
X
Xvoid
Xupdate_page()
X{
X    int sel;
X    int j;
X
X    for (j = 0; j < sel_item_cnt; j++) {
X	sel = sel_items[j].sel;
X	if (sel_mode == SM_ARTICLE) {
X	    ARTICLE *ap = (ARTICLE*)sel_items[j].ptr;
X	    if (sel == !!(ap->flags & sel_mask) + (ap->flags & AF_DEL))
X		continue;
X	} else {
X	    SUBJECT *sp = (SUBJECT*)sel_items[j].ptr;
X	    int real_sel;
X	    if (sel_mode == SM_THREAD)
X		(void) count_thread_lines(sp, &real_sel);
X	    else
X		(void) count_subject_lines(sp, &real_sel);
X	    if (sel == real_sel)
X		continue;
X	}
X	goto_line(sel_line, sel_items[j].line);
X	sel_line = sel_items[j].line;
X	sel_item_index = j;
X	output_sel(!sel);
X    }
X    if (++sel_item_index == sel_item_cnt)
X	sel_item_index = 0;
X}
X
Xvoid
Xoutput_sel(sel)
Xint sel;
X{
X    putchar(sel_chars[sel_item_index]);
X    putchar(sel_disp_char[sel]);
X    sel_items[sel_item_index].sel = sel;
X}
X
X/* Counts the number of lines needed to output a subject, including
X** optional authors.
X*/
Xstatic int
Xcount_subject_lines(subj, selptr)
XSUBJECT *subj;
Xint *selptr;
X{
X    register ARTICLE *ap;
X    register int sel;
X
X    if (subj->flags & SF_DEL)
X	sel = 2;
X    else if (subj->flags & sel_mask) {
X	sel = 1;
X	for (ap = subj->articles; ap; ap = ap->subj_next) {
X	    if ((!(ap->flags&AF_READ) ^ sel_rereading)
X	      && !(ap->flags & sel_mask)) {
X		sel = 3;
X		break;
X	    }
X	}
X    } else
X	sel = 0;
X    if (selptr)
X	*selptr = sel;
X    if (*display_mode == 'l')
X	return subj->misc;
X    if (*display_mode == 'm')
X	return (subj->misc <= 4? subj->misc : (subj->misc - 4) / 3 + 4);
X    return (subj->misc != 0);
X}
X
X/* Counts the number of lines needed to output a thread, including
X** optional authors.
X*/
Xstatic int
Xcount_thread_lines(subj, selptr)
XSUBJECT *subj;
Xint *selptr;
X{
X    register int total = 0;
X    register ARTICLE *thread = subj->thread;
X    int sel = -1, subj_sel;
X
X    do {
X	if (subj->misc) {
X	    total += count_subject_lines(subj, &subj_sel);
X	    if (sel < 0)
X		sel = subj_sel;
X	    else if (sel != subj_sel)
X		sel = 3;
X	}
X    } while ((subj = subj->next) != Nullsubj && subj->thread == thread);
X    if (selptr)
X	*selptr = (sel < 0? 0 : sel);
X    return total;
X}
X
X/* Display an article, perhaps with its author.
X*/
Xstatic void
Xdisplay_article(ap, ch, sel)
Xregister ARTICLE *ap;
Xchar_int ch;
Xint sel;
X{
X    int subj_width = COLS - 5;
X    int from_width = COLS / 5;
X
X#ifdef CLEAREOL
X    maybe_eol();
X#endif
X    if (subj_width < 32)
X	subj_width = 32;
X    
X    putchar(ch);
X    putchar(sel_disp_char[sel]);
X    if (*display_mode == 's' || from_width < 8)
X	printf("  %s\n",compress_subj(ap->subj->articles,subj_width)) FLUSH;
X    else {
X	printf("%s  %s\n",
X	   compress_from(ap, from_width),
X	   compress_subj(ap, subj_width - from_width)) FLUSH;
X    }
X    sel_line++;
X}
X
X/* Display the given subject group, with optional authors.
X*/
Xstatic void
Xdisplay_subject(subj, ch, sel)
XSUBJECT *subj;
Xchar_int ch;
Xint sel;
X{
X    register ARTICLE *ap;
X    register int j, i;
X    int subj_width = COLS - 8;
X    int from_width = COLS / 5;
X
X#ifdef CLEAREOL
X    maybe_eol();
X#endif
X    if (subj_width < 32)
X	subj_width = 32;
X
X    j = subj->misc;
X
X    putchar(ch);
X    if (ch != ' ')
X	putchar(sel_disp_char[sel]);
X    else
X	putchar(' ');
X    if (*display_mode == 's' || from_width < 8)
X	printf("%3d  %s\n",j,compress_subj(subj->articles,subj_width)) FLUSH;
X    else {
X	/* Find the first unread article so we get the author right */
X	for (ap = subj->articles; ap; ap = ap->subj_next) {
X	    if (!(ap->flags&AF_READ) ^ sel_rereading)
X		break;
X	}
X	printf("%s%3d  %s\n",
X	   compress_from(ap, from_width), j,
X	   compress_subj(ap, subj_width - from_width)) FLUSH;
X	i = -1;
X	if (--j && ap) {
X	    for (ap = ap->subj_next; ap && j; ap = ap->subj_next) {
X		if (!(!(ap->flags&AF_READ) ^ sel_rereading))
X		    continue;
X		j--;
X		if (i < 0)
X		    i = 0;
X		else if (*display_mode == 'm') {
X		    if (!j) {
X			if (i)
X			    putchar('\n');
X		    } else {
X			if (i == 3 || !i) {
X			    if (i)
X				putchar('\n');
X			    if (++sel_line >= LINES - 3)
X				return;
X#ifdef CLEAREOL
X			    maybe_eol();
X#endif
X			    i = 1;
X			} else
X			    i++;
X			printf("  %s      ",
X			       compress_from(ap, from_width)) FLUSH;
X			continue;
X		    }
X		}
X		if (++sel_line >= LINES - 3)
X		    return;
X#ifdef CLEAREOL
X		maybe_eol();
X#endif
X		printf("  %s\n", compress_from(ap, from_width)) FLUSH;
X	    }
X	}
X    }
X    sel_line++;
X}
END_OF_FILE
if test 16170 -ne `wc -c <'rt-page.c'`; then
    echo shar: \"'rt-page.c'\" unpacked with wrong size!
fi
# end of 'rt-page.c'
fi
if test -f 'trn.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'trn.c'\"
else
echo shar: Extracting \"'trn.c'\" \(15473 characters\)
sed "s/^X//" >'trn.c' <<'END_OF_FILE'
X/*  trn -- threaded readnews program based on rn 4.4
X *
X *  Author/Maintainer of trn: davison@borland.com (Wayne Davison)
X *  Organization: Borland International
X *  Author/Maintainer of rn: sob@bcm.tmc.edu (Stan Barber)
X *  Organization: Baylor College of Medicine, Houston,Tx
X *  Original Author: lwall@sdcrdcf.UUCP (Larry Wall)
X *  Organization: System Development Corporation, Santa Monica
X *
X *  History:
X *	01/14/83 - rn begun
X *	04/08/83 - rn 1.0
X *	09/01/83 - rn 2.0
X *	05/01/85 - rn 4.3
X *	11/01/89 - rn/rrn integration
X *	11/25/89 - trn begun
X *	07/21/90 - trn 1.0
X *	07/04/91 - rn 4.4
X *	11/25/91 - trn 2.0
X *	03/01/93 - trn 3.0 (or so... :-) )
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "patchlevel.h"
Xstatic char rnid[] = "@(#)$Id: trn.c,v 3.0 1991/11/22 00:14:59 davison Trn $";
Xstatic char patchlevel[] = PATCHLEVEL;
X
X#include "INTERN.h"
X#include "common.h"
X#include "trn.h"
X#include "EXTERN.h"
X#include "rcstuff.h"
X#include "term.h"
X#include "final.h"
X#include "search.h"
X#include "ngdata.h"
X#include "ngstuff.h"
X#include "util.h"
X#include "only.h"
X#include "ngsrch.h"
X#include "help.h"
X#include "last.h"
X#include "init.h"
X#include "intrp.h"
X#include "rcln.h"
X#include "sw.h"
X#include "cache.h"
X#include "addng.h"
X#include "ng.h"
X#include "kfile.h"
X#include "nntp.h"
X
Xvoid
Xrn_init()
X{
X    ;
X}
X
Xvoid
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X{
X    bool foundany;
X    register char *s;
X    bool oh_for_the_good_old_days = FALSE;
X    int direction = 1;
X
X#if !THREAD_INIT
X    /* Default to threaded operation if our name starts with a 't' */
X    if ((s = rindex(argv[0],'/')) == Nullch)
X	s = argv[0];
X    else
X	s++;
X    if (*s == 't')
X	use_threads = TRUE;
X    else
X	select_on = 0;
X#endif
X    foundany = initialize(argc,argv);
X
X    if (maxngtodo)
X	starthere = 0;
X    else if (!foundany) {		/* nothing to do? */
X#ifdef VERBOSE
X	if (verbose)
X	    fputs("\
XNo unread news in subscribed-to newsgroups.  To subscribe to a new\n\
Xnewsgroup use the g<newsgroup> command.\n\
X",stdout) FLUSH;
X#endif
X	starthere = nextrcline;
X    }
X
X    /* loop through all unread news */
X
X    {
X	bool special = FALSE;		/* temporarily allow newsgroup */
X					/*   with no unread news? */
X	bool retry;			/* cycle back to top of list? */
X	NG_NUM recent_ng = 0;
X	
X	current_ng = 0;
X	do {
X	    retry = FALSE;
X	    if (findlast) {
X		findlast = FALSE;
X		starthere = 0;
X		if (*lastngname) {
X		    if ((ng = find_ng(lastngname)) == nextrcline)
X			ng = 0;
X		    else {
X			set_ngname(lastngname);
X		    	set_toread(ng);
X			if (toread[ng] <= TR_NONE)
X			    ng = 0;
X		    }
X		}
X	    } else {
X		ng = starthere;
X		starthere = 0;
X	    }
X	    while (ng <= nextrcline) {	/* for each newsgroup */
X		if (ng == nextrcline) {	/* after the last newsgroup? */
X		    mode = 'f';
X#ifdef ONLY
X		    if (maxngtodo) {
X			if (retry)
X#ifdef VERBOSE
X			    IF(verbose)
X				printf("\nRestriction %s%s still in effect.\n",
X				    ngtodo[0],
X				    maxngtodo > 1 ? ", etc." : nullstr) FLUSH;
X			    ELSE
X#endif
X#ifdef TERSE
X				fputs("\n(\"Only\" mode.)\n",stdout) FLUSH;
X#endif
X			else {
X#ifdef VERBOSE
X			    IF(verbose)
X				fputs("\nNo articles under restriction.",
X				  stdout) FLUSH;
X			    ELSE
X#endif
X#ifdef TERSE
X				fputs("\nNo \"only\" articles.",stdout) FLUSH;
X#endif
X			    end_only();	/* release the restriction */
X			    retry = TRUE;
X			}
X		    }
X#endif
X		} else {
X		    bool shoe_fits;	/* newsgroup matches restriction? */
X
X		    mode = 'n';
X		    if (toread[ng] >= TR_NONE) {	/* recalc toread? */
X			set_ngname(rcline[ng]);
X			shoe_fits = inlist(ngname);
X			if (shoe_fits)
X			    set_toread(ng);
X			if (paranoid) {
X			    recent_ng = current_ng;
X			    current_ng = ng;
X			    cleanup_rc();
X					/* this may move newsgroups around */
X			    ng = current_ng;
X			    set_ngname(rcline[ng]);
X			}
X		    }
X		    if (toread[ng] < (emptyOnly || special ? TR_NONE : TR_ONE)
X		     || !shoe_fits) {		/* unwanted newsgroup? */
X			ng += direction;	/* then skip it */
X			if (ng < 0) {
X			   ng = 1;
X			   direction = 1;
X			}
X			continue;
X		    }
X		}
X		special = FALSE;	/* go back to normal mode */
X		if (ng != current_ng) {
X		    recent_ng = current_ng;
X					/* remember previous newsgroup */
X		    current_ng = ng;	/* remember current newsgroup */
X		}
X    reask_newsgroup:
X		unflush_output();	/* disable any ^O in effect */
X		if (ng >= nextrcline) {
X#ifdef USE_NNTP
X		    if (actFetchTime
X		     && time(Null(time_t*)) - lastactfetch > actFetchTime) {
X			fclose(actfp);
X			ngdata_init();	/* re-grab the active file */
X		    }
X#endif
X		    dfltcmd = (retry ? "npq" : "qnp");
X#ifdef VERBOSE
X		    IF(verbose)
X			printf("\n****** End of newsgroups -- what next? [%s] ",
X			    dfltcmd);
X		    ELSE
X#endif
X#ifdef TERSE
X			printf("\n**** End -- next? [%s] ", dfltcmd);
X#endif
X		} else {
X		    ThreadedGroup = (use_threads && rcchar[ng] != '0');
X		    dfltcmd = (select_on
X			&& (ART_NUM)toread[ng] >= select_on ? "+ynq" : "ynq");
X#ifdef VERBOSE
X		    IF(verbose)
X			printf("\n%s %3ld unread article%s in %s -- read now? [%s] ",
X			    ThreadedGroup? "======" : "******",
X			    (long)toread[ng], (toread[ng]==TR_ONE ? nullstr : "s"),
X			    ngname, dfltcmd);
X		    ELSE
X#endif
X#ifdef TERSE
X			printf("\n%s %3ld in %s -- read? [%s] ",
X			    ThreadedGroup? "====" : "****",
X			    (long)toread[ng],ngname,dfltcmd);
X#endif
X		}
X		fflush(stdout);
X    reinp_newsgroup:
X		eat_typeahead();
X		getcmd(buf);
X		if (errno || *buf == '\f') {
X		    putchar('\n') FLUSH; /* if return from stop signal */
X		    goto reask_newsgroup;	/* give them a prompt again */
X		}
X		setdef(buf,dfltcmd);
X#ifdef VERIFY
X		printcmd();
X#endif
X    do_command:
X		direction = 1;		/* default to forward motion */
X		addnewbydefault = 0;
X		switch (*buf) {
X		case 'P':		/* goto previous newsgroup */
X		    special = TRUE;	/* don't skip it if toread==0 */
X		    /* FALL THROUGH */
X		case 'p':		/* find previous unread newsgroup */
X		    if (ng > 0)
X			ng--;
X		    direction = -1;	/* go backward in the newsrc */
X		    break;
X		case '-':
X		    ng = recent_ng;	/* recall previous newsgroup */
X		    if (ng < nextrcline)
X			if (!get_ng(rcline[ng],0))
X			    ng = current_ng;
X		    special = TRUE;	/* don't skip it if toread==0 */
X		    break;
X		case 'q': case 'Q': case 'x':	/* quit? */
X		    oh_for_the_good_old_days = (*buf == 'x');
X		    putchar('\n') FLUSH;
X		    ng = nextrcline+1;	/* satisfy */
X		    retry = FALSE;	/*   loop conditions */
X		    break;
X		case '^':
X		    putchar('\n') FLUSH;
X		    ng = 0;
X		    break;
X		case 'n':		/* find next unread newsgroup */
X		    if (ng == nextrcline) {
X			putchar('\n') FLUSH;
X			retry = TRUE;
X		    } else if (toread[ng] > TR_NONE)
X			retry = TRUE;
X		    ng++;
X		    break;
X		case 'N':		/* goto next newsgroup */
X		    special = TRUE;	/* and don't skip it if toread==0 */
X		    ng++;
X		    break;
X		case '1':		/* goto 1st newsgroup */
X		    ng = 0;
X		    special = TRUE;	/* and don't skip it if toread==0 */
X		    break;
X		case '$':
X		    ng = nextrcline;	/* goto last newsgroup */
X		    retry = TRUE;
X		    break;
X		case 'L':
X		    list_newsgroups();
X		    goto reask_newsgroup;
X		case '/': case '?':	/* scan for newsgroup pattern */
X#ifdef NGSEARCH
X		    switch (ng_search(buf,TRUE)) {
X		    case NGS_ERROR:
X			goto reask_newsgroup;
X		    case NGS_ABORT:
X			goto reinp_newsgroup;
X		    case NGS_INTR:
X#ifdef VERBOSE
X			IF(verbose)
X			    fputs("\n(Interrupted)\n",stdout) FLUSH;
X			ELSE
X#endif
X#ifdef TERSE
X			    fputs("\n(Intr)\n",stdout) FLUSH;
X#endif
X			ng = current_ng;
X			goto reask_newsgroup;
X		    case NGS_FOUND:
X			special = TRUE;	/* don't skip it if toread==0 */
X			break;
X		    case NGS_NOTFOUND:
X#ifdef VERBOSE
X			IF(verbose)
X			    fputs("\n\nNot found -- use a or g to add newsgroups\n",
X				stdout) FLUSH;
X			ELSE
X#endif
X#ifdef TERSE
X			    fputs("\n\nNot found\n",stdout) FLUSH;
X#endif
X			goto reask_newsgroup;
X		    }
X#else
X		    notincl("/");
X#endif
X		    break;
X		case 'm':
X#ifndef RELOCATE
X		    notincl("m");
X		    break;
X#endif		    
X		case 'g':	/* goto named newsgroup */
X		    if (!finish_command(FALSE))
X					/* if they didn't finish command */
X			goto reinp_newsgroup;	/* go try something else */
X		    for (s = buf+1; *s == ' '; s++);
X					/* skip leading spaces */
X#ifdef RELOCATE
X		    if (!*s && *buf == 'm' && ngname && ng < nextrcline)
X			strcpy(s,ngname);
X#endif
X		    {
X		        char *_s;
X			for (_s=s; isdigit(*_s); _s++)
X			    ;
X			if (isspace(*_s))
X			    *_s = '\0';
X		        if (*_s)
X			    /* found non-digit before hitting end */
X			    set_ngname(s);
X			else {
X			    int rcnum;
X			    rcnum = atoi(s);
X			    if (rcnum < nextrcline)
X				set_ngname(rcline[rcnum]);
X			    else {
X				printf("\nOnly %d groups. Try again.\n",
X					nextrcline) FLUSH;
X				goto reask_newsgroup;
X			    }
X			}
X		    }
X		    /* try to find newsgroup */
X#ifdef RELOCATE
X		    if (!get_ng(ngname,(*buf=='m'?GNG_RELOC:0) | GNG_FUZZY))
X#else
X		    if (!get_ng(ngname,GNG_FUZZY))
X#endif
X			ng = current_ng;/* if not found, go nowhere */
X		    special = TRUE;	/* don't skip it if toread==0 */
X		    break;
X#ifdef DEBUG
X		case 'D':
X		    printf("\nTries: %d Hits: %d\n",
X			softtries,softtries-softmisses) FLUSH;
X		    goto reask_newsgroup;
X#endif
X		case '!':		/* shell escape */
X		    if (escapade())	 /* do command */
X			goto reinp_newsgroup;
X					/* if rubbed out, re input */
X		    goto reask_newsgroup;
X		case Ctl('k'):		/* edit global KILL file */
X		    edit_kfile();
X		    goto reask_newsgroup;
X		case 'c':		/* catch up */
X#ifdef CATCHUP
X		    if (ng < nextrcline)
X			ask_catchup();
X		    ng++;
X#else
X		    notincl("c");
X#endif
X		    break;
X		case 't':
X		    if (!use_threads)
X			printf("\n\nNot running in thread mode.\n");
X		    else if (ng < nextrcline && toread[ng] >= TR_NONE) {
X			bool read_unthreaded = (rcchar[ng] == ':');
X			rcchar[ng] = (read_unthreaded ? '0' : ':');
X			printf("\n\n%s will be read %sthreaded.\n",
X			    rcline[ng], read_unthreaded? "un" : "") FLUSH;
X			set_toread(ng);
X		    }
X		    special = TRUE;	/* don't skip it if toread==0 */
X		    break;
X		case 'u':		/* unsubscribe */
X		    if (ng < nextrcline && toread[ng] >= TR_NONE) {
X					/* unsubscribable? */
X			printf(unsubto,rcline[ng]) FLUSH;
X			rcchar[ng] = NEGCHAR;
X					/* unsubscribe to (from?) it */
X			toread[ng] = TR_UNSUB;
X					/* and make line invisible */
X			ng++;		/* do an automatic 'n' */
X		    }
X		    break;
X		case 'h': {		/* help */
X		    int cmd;
X
X		    if ((cmd = help_ng()) > 0)
X			pushchar(cmd);
X		    goto reask_newsgroup;
X		}
X		case 'A':
X		    if (ng >= nextrcline)
X			break;
Xreask_abandon:
X#ifdef VERBOSE
X		    IF(verbose)
X			in_char("\nAbandon changes to current newsgroup? [yn] ", 'B');
X		    ELSE
X#endif
X#ifdef TERSE
X			in_char("\nAbandon? [ynh] ", 'B');
X#endif
X		    setdef(buf,"y");
X#ifdef VERIFY
X		    printcmd();
X#endif
X		    putchar('\n') FLUSH;
X		    if (*buf == 'h') {
X#ifdef VERBOSE
X			printf("Type y or SP to abandon the changes to this group since you started trn.\n");
X			printf("Type n to leave the group as it is.\n");
X#else
X			printf("y or SP to abandon changes to this group.\n");
X			printf("n to forget it.\n");
X#endif
X			goto reask_abandon;
X		    } else if (*buf != 'y' && *buf != 'n' && *buf != 'q') {
X			printf(hforhelp);
X			settle_down();
X			goto reask_abandon;
X		    } else if (*buf == 'y')
X			abandon_ng(ng);
X		    special = TRUE;	/* don't skip it if toread==0 */
X		    break;
X		case 'a':
X#ifndef FINDNEWNG
X		    notincl("a");
X		    goto reask_newsgroup;
X#else
X		    /* FALL THROUGH */
X#endif
X		case 'o':
X		case 'O':
X#ifdef ONLY
X		{
X#ifdef FINDNEWNG
X		    bool doscan = (*buf == 'a');
X#endif
X
X		    if (!finish_command(TRUE)) /* get rest of command */
X			goto reinp_newsgroup;	/* if rubbed out, try something else */
X		    end_only();
X		    if (buf[1]) {
X			bool minusd = instr(buf+1,"-d", TRUE) != Nullch;
X
X			sw_list(buf+1);
X			if (minusd)
X			    cwd_check();
X			putchar('\n') FLUSH;
X#ifdef FINDNEWNG
X			if (doscan && maxngtodo)
X			    scanactive();
X#endif
X			emptyOnly = (*buf == 'o' && maxngtodo);
X		    }
X		    ng = 0;		/* simulate ^ */
X		    retry = FALSE;
X		    break;
X		}
X#else
X		    notincl("o");
X		    goto reask_newsgroup;
X#endif
X		case '&':
X		    if (switcheroo()) /* get rest of command */
X			goto reinp_newsgroup;	/* if rubbed out, try something else */
X		    goto reask_newsgroup;
X		case 'l': {		/* list other newsgroups */
X		    if (!finish_command(TRUE)) /* get rest of command */
X			goto reinp_newsgroup;	/* if rubbed out, try something else */
X		    for (s = buf+1; *s == ' '; s++);
X		    			/* skip leading spaces */
X		    sprintf(cmd_buf,"%s '%s'",filexp(NEWSGROUPS),s);
X		    resetty();
X		    if (doshell(sh,cmd_buf))
X#ifdef VERBOSE
X			IF(verbose)
X			    fputs("    (Error from newsgroups program)\n",
X				stdout) FLUSH;
X			ELSE
X#endif
X#ifdef TERSE
X			    fputs("(Error)\n",stdout) FLUSH;
X#endif
X		    noecho();
X		    crmode();
X		    goto reask_newsgroup;
X		}
X		case 'U': case '+':
X		case '.': case '=':
X		case 'y': case 'Y': case '\t': /* do normal thing */
X		    if (ng >= nextrcline) {
X			fputs("\nNot on a newsgroup.",stdout) FLUSH;
X			goto reask_newsgroup;
X		    } else if (*buf == '.') {	/* start command? */
X			if (!finish_command(FALSE)) /* get rest of command */
X			    goto reinp_newsgroup;
X			s = savestr(buf+1);  /* do_newsgroup will free it */
X		    } else {
X			s = buf;
X			if (*buf == '+' || *buf == 'U' || *buf == '=')
X			    *s++ = lastchar; /* restore 0200 if from a macro */
X			save_typeahead(s, sizeof buf - 1);
X			if (*buf)
X			    s = savestr(buf);
X			else
X			    s = Nullch;
X		    }
X		    if (toread[ng])
X			retry = TRUE;
X		    switch (do_newsgroup(s)) {
X		    case NG_ERROR:
X		    case NG_NORM:
X			ng++;
X			break;
X		    case NG_ASK:
X			goto reask_newsgroup;
X		    case NG_SELPRIOR:
X			*buf = 'p';
X			goto do_command;
X		    case NG_SELNEXT:
X			*buf = 'n';
X			goto do_command;
X		    case NG_MINUS:
X			ng = recent_ng;	/* recall previous newsgroup */
X			special = TRUE;	/* don't skip it if toread==0 */
X			break;
X		    }
X		    break;
X#ifdef STRICTCR
X		case '\n':
X		    fputs(badcr,stdout) FLUSH;
X		    goto reask_newsgroup;
X#endif
X		case 'v':
X		    printf("\n%s",rnid);
X		    printf("\n%s",patchlevel);
X		    printf("\nSend bugs to davison@borland.com\n") FLUSH;
X		    goto reask_newsgroup;
X		default:
X		    printf("\n%s",hforhelp) FLUSH;
X		    settle_down();
X		    goto reask_newsgroup;
X		}
X	    }
X	} while (retry);
X    }
X
X    /* now write .newsrc back out */
X
X    write_rc();
X
X    if (oh_for_the_good_old_days)
X	get_old_rc();
X
X    finalize(0);			/* and exit */
X}
X
X/* set current newsgroup */
X
Xvoid
Xset_ngname(what)
Xchar *what;
X{
X    int len = strlen(what)+1;
X
X    growstr(&ngname,&ngnlen,len);
X    strcpy(ngname,what);
X    growstr(&ngdir,&ngdlen,len);
X    strcpy(ngdir,getngdir(ngname));
X}
X
Xstatic char *myngdir;
Xstatic int ngdirlen = 0;
X
Xchar *
Xgetngdir(ngnam)
Xchar *ngnam;
X{
X    register char *s;
X
X    growstr(&myngdir,&ngdirlen,strlen(ngnam)+1);
X    strcpy(myngdir,ngnam);
X    for (s = myngdir; *s; s++)
X	if (*s == '.')
X	    *s = '/';
X    return myngdir;
X}
END_OF_FILE
if test 15473 -ne `wc -c <'trn.c'`; then
    echo shar: \"'trn.c'\" unpacked with wrong size!
fi
# end of 'trn.c'
fi
echo shar: End of archive 6 \(of 12\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 12 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
