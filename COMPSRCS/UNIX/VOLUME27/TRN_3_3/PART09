Newsgroups: comp.sources.unix
From: davison@borland.com (Wayne Davison)
Subject: v27i102: trn-3.3 - threaded newsreader based on RN, V3.3, Part09/12
References: <1.754431075.7231@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: davison@borland.com (Wayne Davison)
Posting-Number: Volume 27, Issue 102
Archive-Name: trn-3.3/part09

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 9 (of 12)."
# Contents:  art.c intrp.c term.c
# Wrapped by vixie@gw.home.vix.com on Sun Nov 21 01:14:08 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'art.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'art.c'\"
else
echo shar: Extracting \"'art.c'\" \(26289 characters\)
sed "s/^X//" >'art.c' <<'END_OF_FILE'
X/* $Id: art.c,v 3.0 1992/02/01 03:09:32 davison Trn $
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "trn.h"
X#include "ngstuff.h"
X#include "ngdata.h"
X#include "cache.h"
X#include "bits.h"
X#include "head.h"
X#include "help.h"
X#include "search.h"
X#include "artio.h"
X#include "ng.h"
X#include "final.h"
X#include "artstate.h"
X#include "rcstuff.h"
X#include "term.h"
X#include "sw.h"
X#include "util.h"
X#include "backpage.h"
X#include "intrp.h"
X#include "rthread.h"
X#include "rt-select.h"
X#include "rt-util.h"
X#include "rt-wumpus.h"
X#include "INTERN.h"
X#include "art.h"
X
X/* page_switch() return values */
X
X#define PS_NORM 0
X#define PS_ASK 1
X#define PS_RAISE 2
X#define PS_TOEND 3
X
Xbool special = FALSE;		/* is next page special length? */
Xint slines = 0;			/* how long to make page when special */
XART_LINE highlight = -1;	/* next line to be highlighted */
Xchar *restart = Nullch;		/* if nonzero, the place where last */
X				/* line left off on line split */
Xchar *blinebeg;			/* where in buffer current line began */
XART_POS alinebeg;		/* where in file current line began */
X
X#ifdef INNERSEARCH
XART_POS innersearch = 0;	/* artpos of end of line we found */
X				/* for 'g' command */
XART_LINE isrchline = 0;			/* last line to display */
Xbool hide_everything = FALSE;
X				/* if set, do not write page now, */
X				/* but refresh when done with page */
XCOMPEX gcompex;				/* in article search pattern */
X#endif
X
Xbool firstpage;			/* is this the 1st page of article? */
X
Xchar art_buf[LBUFLEN];		/* place for article lines */
X
Xvoid
Xart_init()
X{
X#ifdef INNERSEARCH
X    init_compex(&gcompex)
X#endif
X    ;
X}
X
X#ifdef MIME_SUPPORT
X#define VERY_LONG_STRING        200
Xint
Xdisplay_mime()
X{
X    int code = 1;
X
X    if (!getenv("NOMIME")) {
X	char oldmode = mode;
X
X	interp(cmd_buf,(sizeof cmd_buf),getval("MIMESHOW",MIMESHOW));
X	fputs("Process MIME article? [yn]",stdout);
X	fflush(stdout);
X	eat_typeahead();
X#ifdef PENDING
X	cache_until_key();
X#endif
X	mode = 'p';
X	getcmd(buf);
X	mode = oldmode;
X	setdef(buf,"y");
X#ifdef VERIFY
X	printcmd();
X#endif
X	carriage_return();
X	erase_eol();	/* erase the prompt */
X	carriage_return();	/* Resets kernel's tab column counter to 0 */
X	if (*buf == 'y') {
X	    putchar('\n');
X	    fflush(stdout);
X	    termlib_reset();
X	    resetty();
X	    code = doshell(SH,cmd_buf);
X	    noecho();
X	    crmode();
X	    termlib_init();
X	}
X    }
X    return code;
X}
X#endif
X
X
Xint
Xdo_article()
X{
X    register char *s;
X    ART_POS artsize;			/* size in bytes of article */
X    bool hide_this_line = FALSE;	/* hidden header line? */
X    ART_LINE linenum;	/* line # on page, 1 origin */
X#ifdef ULSMARTS
X    bool under_lining = FALSE;		/* are we underlining a word? */
X#endif
X    register char *bufptr = art_buf;	/* pointer to input buffer */
X    register int outpos;		/* column position of output */
X    static char prompt_buf[64];		/* place to hold prompt */
X    bool notesfiles = FALSE;		/* might there be notesfiles junk? */
X    char oldmode = mode;
X    char *ctime();
X#ifdef MIME_SUPPORT
X    bool tried_display_mime = FALSE;
X#endif
X#ifdef INNERSEARCH
X    register int outputok;
X#endif
X
X#ifdef MIME_SUPPORT
X    mime_article = FALSE;
X#endif
X
X    if (fstat(fileno(artfp),&filestat)) /* get article file stats */
X	return DA_CLEAN;
X    if ((filestat.st_mode & S_IFMT) != S_IFREG)
X	return DA_NORM;
X    artsize = filestat.st_size;		/* from that get article size */
X    sprintf(prompt_buf,
X	"%%sEnd of article %ld (of %ld) -- what next? [%%s]",
X	(long)art,(long)lastart);	/* format prompt string */
X    prompt = prompt_buf;
X    int_count = 0;		/* interrupt count is 0 */
X    if ((firstpage = (topline < 0)) != 0) {
X	parseheader(art);
X	fseek(artfp,htype[PAST_HEADER].ht_minpos,0);
X    }
X    for (;;) {			/* for each page */
X	if (ThreadedGroup && max_tree_lines)
X	    init_tree();	/* init tree display */
X	assert(art == openart);
X	if (do_fseek) {
X	    parseheader(art);		/* make sure header is ours */
X	    artpos = vrdary(artline);
X	    if (artpos < 0)
X		artpos = -artpos;	/* labs(), anyone? */
X	    if (firstpage)
X		artpos = (ART_POS)0;
X	    if (artpos < htype[PAST_HEADER].ht_minpos) {
X		in_header = SOME_LINE;
X		fseek(artfp,htype[PAST_HEADER].ht_minpos,0);
X	    } else
X		fseek(artfp,artpos,0);
X	    do_fseek = FALSE;
X	    restart = Nullch;
X	}
X	linenum = 1;
X	if (firstpage) {
X	    if (firstline) {
X		interp(art_buf, (sizeof art_buf), firstline);
X		linenum += tree_puts(art_buf,linenum+topline,0);
X	    } else 
X            {
X		ART_NUM i;
X		int selected, unseen;
X
X		selected = (curr_artp->flags & AF_SEL);
X		unseen = !was_read(art);
X		sprintf(art_buf,"%s%s #%ld",ngname,moderated,(long)art);
X		if (selected_only) {
X		    i = selected_count - (unseen && selected);
X		    sprintf(art_buf+strlen(art_buf)," (%ld + %ld more)",
X			    (long)i,(long)toread[ng] - selected_count
X					- (!selected && unseen));
X		}
X		else if ((i = (ART_NUM)(toread[ng] - unseen)) != 0
X		       || (!ThreadedGroup && dmcount))
X		    sprintf(art_buf+strlen(art_buf)," (%ld more)",(long)i);
X		if (!ThreadedGroup && dmcount)
X		    sprintf(art_buf+strlen(art_buf)-1," + %ld Marked to return)",
X			    (long)dmcount);
X		linenum += tree_puts(art_buf,linenum+topline,0);
X	    }
X	    start_header(art);
X	    forcelast = FALSE;		/* we will have our day in court */
X	    restart = Nullch;
X	    artline = 0;		/* start counting lines */
X	    artpos = 0;
X	    vwtary(artline,artpos);	/* remember pos in file */
X	}
X	for (;				/* linenum already set */
X	  in_header || (
X#ifdef INNERSEARCH
X	  innersearch ? innermore() :
X#endif
X	  linenum<(firstpage?initlines:(special?slines:LINES)) );
X	  linenum++) {		/* for each line on page */
X	    if (int_count) {	/* exit via interrupt? */
X		putchar('\n') FLUSH;	/* get to left margin */
X		int_count = 0;	/* reset interrupt count */
X		mode = oldmode;
X		special = FALSE;
X		return DA_NORM;	/* skip out of loops */
X	    }
X	    if (restart) {		/* did not finish last line? */
X		bufptr = restart;	/* then start again here */
X		restart = Nullch;	/* and reset the flag */
X	    }
X	    else if (in_header && headbuf[artpos] != '\0') {
X		bufptr = index(headbuf+artpos,'\n') + 1;
X		bcopy(headbuf+artpos,art_buf,bufptr-headbuf-artpos);
X		art_buf[bufptr-headbuf-artpos] = '\0';
X		bufptr = art_buf;
X	    } else {
X		if (fgets(art_buf,LBUFLEN,artfp)==Nullch) {
X					/* if all done */
X		    mode = oldmode;
X		    special = FALSE;
X		    return DA_NORM;	/* skip out of loops */
X		}
X		bufptr = art_buf;	/* so start at beginning */
X		art_buf[LBUFLEN-1] = '\0';
X					/* make sure string ends */
X	    }
X	    blinebeg = bufptr;	/* remember where we began */
X	    alinebeg = artpos;	/* both in buffer and file */
X	    if (in_header && bufptr == art_buf) {
X		hide_this_line =
X		    parseline(art_buf,do_hiding,hide_this_line);
X		if (!in_header) {
X		    linenum += finish_tree(linenum+topline);
X		    end_header();
X		}
X	    } else if (notesfiles && do_hiding &&
X	      bufptr == art_buf && *art_buf == '#' &&
X	      isupper(art_buf[1]) && art_buf[2] == ':' ) {
X		fgets(art_buf,sizeof(art_buf),artfp);
X		if (index(art_buf,'!') != Nullch)
X		    fgets(art_buf,sizeof(art_buf),artfp);
X		htype[PAST_HEADER].ht_minpos = ftell(artfp);
X					/* exclude notesfiles droppings */
X		hide_this_line = TRUE;	/* and do not print either */
X		notesfiles = FALSE;
X	    }
X#ifdef CUSTOMLINES
X	    if (hideline && bufptr == art_buf &&
X		  execute(&hide_compex,art_buf) )
X		hide_this_line = TRUE;
X#endif
X	    if (in_header && htype[in_header].ht_flags & HT_MAGIC) {
X		if (in_header == NGS_LINE) {
X		    if ((s = index(art_buf,'\n')) != Nullch)
X			*s = '\0';
X		    hide_this_line = (index(art_buf,',') == Nullch)
X			&& strEQ(art_buf+12, ngname);
X		    if (s != Nullch)
X			*s = '\n';
X		}
X		else if (in_header == EXPIR_LINE) {
X		    if (!(htype[EXPIR_LINE].ht_flags & HT_HIDE))
X			hide_this_line = (strlen(art_buf) < 10);
X		}
X		else if (in_header == FROM_LINE) {
X		    if (do_hiding && (s = extract_name(art_buf+6)) != Nullch)
X			strcpy(art_buf+6,s);
X		}
X#ifdef HAS_STRFTIME
X		else if (in_header == DATE_LINE) {
X		    if (do_hiding && curr_artp->date != -1)
X			strftime(art_buf+6, sizeof(art_buf)-6,
X				 getval("LOCALTIMEFMT", LOCALTIMEFMT),
X				 localtime(&curr_artp->date));
X		}
X#endif
X#ifdef MIME_SUPPORT
X		else if (in_header == CONTENT_LINE && !isspace(*art_buf)) {
X		    mime_article = nontext(art_buf+14);
X		}
X#endif
X	    }
X	    if (in_header == SUBJ_LINE &&
X		htype[SUBJ_LINE].ht_flags & HT_MAGIC) {
X			    /* is this the subject? */
X		int length;
X
X		length = strlen(art_buf)-1;
X		artline++;
X		art_buf[length] = '\0';		/* wipe out newline */
X#ifdef NOFIREWORKS
X		no_ulfire();
X#endif
X		notesfiles =
X		    (instr(&art_buf[length-10]," - (nf", TRUE) != Nullch);
X		/* tree_puts(, ,1) underlines subject */
X		linenum += tree_puts(art_buf,linenum+topline,1)-1;
X	    }
X	    else if (hide_this_line && do_hiding) {
X					/* do not print line? */
X		linenum--;		/* compensate for linenum++ */
X		if (!in_header)
X		    hide_this_line = FALSE;
X	    }
X	    else if (in_header) {
X		artline++;
X		linenum += tree_puts(art_buf,linenum+topline,0)-1;
X	    }
X	    else {			/* just a normal line */
X#ifdef MIME_SUPPORT
X		if (mime_article && do_hiding && !tried_display_mime) {
X		    if (display_mime() == 0)
X			return DA_NORM;
X		    else
X			tried_display_mime = TRUE;
X		}
X#endif
X		if (highlight==artline) {	/* this line to be highlit? */
X		    if (marking == STANDOUT) {
X#ifdef NOFIREWORKS
X			if (erase_screen)
X			    no_sofire();
X#endif
X			standout();
X		    }
X		    else {
X#ifdef NOFIREWORKS
X			if (erase_screen)
X			    no_ulfire();
X#endif
X			underline();
X		    }
X		    if (*bufptr == '\n')
X			putchar(' ');
X		}
X#ifdef INNERSEARCH
X		outputok = !hide_everything;
X					/* get it into register, hopefully */
X#endif
X#ifdef CLEAREOL
X#ifdef INNERSEARCH
X		if (outputok)
X#endif
X		maybe_eol();	
X#endif /* CLEAREOL */
X#ifdef CUSTOMLINES
X		if (pagestop && bufptr == art_buf && 
X		  execute(&page_compex,art_buf) )
X		    linenum = 32700;
X#endif
X		for (outpos = 0; outpos < COLS; ) {
X				    /* while line has room */
X		    if (*(unsigned char *)bufptr >= ' ') { /* normal char? */
X#ifdef ULSMARTS
X			if (*bufptr == '_') {
X			    if (bufptr[1] == '\b') {
X				if (!under_lining && highlight!=artline
X#ifdef INNERSEARCH
X				    && outputok
X#endif
X				    ) {
X				    under_lining++;
X				    if (UG) {
X					if (bufptr != buf &&
X					  bufptr[-1] == ' ') {
X					    outpos--;
X					    backspace();
X					}
X				    }
X				    underline();
X				}
X				bufptr += 2;
X			    }
X			}
X			else {
X			    if (under_lining) {
X				under_lining = 0;
X				un_underline();
X				if (UG) {
X				    if (*bufptr == ' ')
X					goto skip_put;
X				    outpos++;
X				}
X			    }
X			}
X#endif
X#ifdef INNERSEARCH
X			if (outputok)
X#endif
X			{
X#ifdef ROTATION
X			    if (rotate && !in_header
X			      && isalpha(*bufptr)) {
X				if ((*bufptr & 31) <= 13)
X				    putchar(*bufptr+13);
X				else
X				    putchar(*bufptr-13);
X			    }
X			    else
X#endif
X				putchar(*bufptr);
X			}
X			if (*UC && ((highlight==artline && marking == 1)
X#ifdef ULSMARTS
X			    || under_lining
X#endif
X			    )) {
X			    backspace();
X			    underchar();
X			}
X		    skip_put:
X			bufptr++;
X			outpos++;
X		    }
X		    else if (*bufptr == '\n' || !*bufptr) {
X						    /* newline? */
X#ifdef ULSMARTS
X			if (under_lining) {
X			    under_lining = 0;
X			    un_underline();
X			}
X#endif
X#ifdef DEBUG
X			if (debug & DEB_INNERSRCH && outpos < COLS - 6) {
X			    standout();
X			    printf("%4d",artline); 
X			    un_standout();
X			}
X#endif
X#ifdef INNERSEARCH
X			if (outputok)
X#endif
X			    putchar('\n') FLUSH;
X			restart = 0;
X			outpos = 1000;	/* signal normal \n */
X		    }
X		    else if (*bufptr == '\t') {	/* tab? */
X			int incpos =  8 - outpos % 8;
X#ifdef INNERSEARCH
X			if (outputok)
X#endif
X			    if (GT)
X				putchar(*bufptr);
X			    else
X				while (incpos--) putchar(' ');
X			bufptr++;
X			outpos += 8 - outpos % 8;
X		    }
X		    else if (*bufptr == '\f') {	/* form feed? */
X#ifdef INNERSEARCH
X			if (outputok)
X#endif
X			    fputs("^L",stdout);
X			if (bufptr == blinebeg && highlight != artline)
X			    linenum = 32700;
X			    /* how is that for a magic number? */
X			bufptr++;
X			outpos += 2;
X		    }
X		    else {		/* other control char */
X#ifdef INNERSEARCH
X			if (outputok)
X#endif
X			{
X			    if (dont_filter_control)
X				putchar(*bufptr);
X			    else {
X				putchar('^');
X				if (highlight == artline && *UC && marking == 1) {
X				    backspace();
X				    underchar();
X				    putchar(*bufptr+64);
X				    backspace();
X				    underchar();
X				}
X				else
X				    putchar(*bufptr+64);
X			    }
X			}
X			bufptr++;
X			outpos += 2;
X		    }
X		    
X		} /* end of column loop */
X
X		if (outpos < 1000) {/* did line overflow? */
X		    restart = bufptr;
X				    /* restart here next time */
X		    if (!AM || XN) {/* no automatic margins on tty? */
X#ifdef INNERSEARCH		    /* then move it down ourselves */
X			if (outputok)
X#endif
X			    putchar('\n') FLUSH;
X		    }
X		    if (*bufptr == '\n')    /* skip the newline */
X			restart = 0;
X		}
X
X		/* handle normal end of output line formalities */
X
X		if (highlight == artline) {
X					/* were we highlighting line? */
X		    if (marking == STANDOUT)
X			un_standout();
X		    else
X			un_underline();
X		    highlight = -1;	/* no more we are */
X		}
X		artline++;	/* count the line just printed */
X		if (artline - LINES + 1 > topline)
X			    /* did we just scroll top line off? */
X		    topline = artline - LINES + 1;
X			    /* then recompute top line # */
X	    }
X
X	    /* determine actual position in file */
X
X	    if (restart)	/* stranded somewhere in the buffer? */
X		artpos += restart - blinebeg;
X			    /* just calculate position */
X	    else if (in_header)
X		artpos = index(headbuf+artpos, '\n') - headbuf + 1;
X	    else		/* no, ftell will do */
X		artpos = ftell(artfp);
X	    vwtary(artline,artpos);	/* remember pos in file */
X	} /* end of line loop */
X
X#ifdef INNERSEARCH
X	innersearch = 0;
X	if (hide_everything) {
X	    hide_everything = FALSE;
X	    *buf = Ctl('l');
X	    goto fake_command;
X	}
X#endif
X	if (linenum >= 32700)/* did last line have formfeed? */
X	    vwtary(artline-1,-vrdary(artline-1));
X			    /* remember by negating pos in file */
X
X	special = FALSE;	/* end of page, so reset page length */
X	firstpage = FALSE;	/* and say it is not 1st time thru */
X
X	/* extra loop bombout */
X
X	if (artpos == artsize) {/* did we just now reach EOF? */
X	    mode = oldmode;
X	    return DA_NORM;	/* avoid --MORE--(100%) */
X	}
X
X/* not done with this article, so pretend we are a pager */
X
Xreask_pager:		    
X	unflush_output();	/* disable any ^O in effect */
X	standout();		/* enter standout mode */
X	printf("--MORE--(%ld%%)",(long)(artpos*100/artsize));
X	un_standout();	/* leave standout mode */
X#ifdef CLEAREOL
X 	maybe_eol();
X#endif
X	fflush(stdout);
X	eat_typeahead();
X#ifdef DEBUG
X	if (debug & DEB_CHECKPOINTING) {
X	    printf("(%d %d %d)",checkcount,linenum,artline);
X	    fflush(stdout);
X	}
X#endif
X	if (checkcount >= docheckwhen &&
X	  linenum == LINES &&
X	  (artline > 40 || checkcount >= docheckwhen+10) ) {
X			    /* while he is reading a whole page */
X			    /* in an article he is interested in */
X	    checkcount = 0;
X	    checkpoint_rc();	/* update .newsrc */
X	}
X	cache_until_key();
X	mode = 'p';
X	getcmd(buf);
X	if (errno) {
X	    if (LINES < 100 && !int_count)
X		*buf = '\f';/* on CONT fake up refresh */
X	    else {
X		*buf = 'q';	/* on INTR or paper just quit */
X	    }
X	}
X	carriage_return();
X#ifndef CLEAREOL
X	erase_eol();	/* and erase the prompt */
X#else
X	if (erase_screen && can_home_clear)	
X	    clear_rest();
X	else
X	    erase_eol();	/* and erase the prompt */
X#endif /* CLEAREOL */
X	carriage_return();	/* Resets kernel's tab column counter to 0 */
X	fflush(stdout);
X
X    fake_command:		/* used by innersearch */
X	output_chase_phrase = TRUE;
X
X	/* parse and process pager command */
X
X	switch (page_switch()) {
X	case PS_ASK:	/* reprompt "--MORE--..." */
X	    goto reask_pager;
X	case PS_RAISE:	/* reparse on article level */
X	    mode = oldmode;
X	    return DA_RAISE;
X	case PS_TOEND:	/* fast pager loop exit */
X	    mode = oldmode;
X	    return DA_TOEND;
X	case PS_NORM:	/* display more article */
X	    break;
X	}
X    } /* end of page loop */
X}
X
X/* process pager commands */
X
Xint
Xpage_switch()
X{
X    register char *s;
X    
X    switch (*buf) {
X    case 'd':
X    case Ctl('d'):	/* half page */
X	special = TRUE;
X	slines = LINES / 2 + 1;
X	if (marking && *blinebeg != '\f'
X#ifdef CUSTOMLINES
X	  && (!pagestop || blinebeg != art_buf ||
X	      !execute(&page_compex,blinebeg))
X#endif
X	  ) {
X	    up_line();
X	    highlight = --artline;
X	    restart = blinebeg;
X	    artpos = alinebeg;
X	}
X	return PS_NORM;
X    case '!':			/* shell escape */
X	escapade();
X	return PS_ASK;
X#ifdef INNERSEARCH
X    case Ctl('i'):
X	gline = 3;
X	sprintf(cmd_buf,"^[^%c]",*blinebeg);
X	compile(&gcompex,cmd_buf,TRUE,TRUE);
X	goto caseG;
X    case Ctl('g'):
X	gline = 3;
X	compile(&gcompex,"^Subject:",TRUE,TRUE);
X	goto caseG;
X    case 'g':		/* in-article search */
X	if (!finish_command(FALSE))/* get rest of command */
X	    return PS_ASK;
X	s = buf+1;
X	if (isspace(*s))
X	    s++;
X	if ((s = compile(&gcompex,s,TRUE,TRUE)) != Nullch) {
X			    /* compile regular expression */
X	    printf("\n%s\n",s) FLUSH;
X	    return PS_ASK;
X	}
X	carriage_return();
X	erase_eol();	/* erase the prompt */
X	carriage_return();	/* Resets kernel's tab column counter to 0 */
X	/* FALL THROUGH */
X    caseG:
X    case 'G': {
X	/* ART_LINE lines_to_skip = 0; */
X	ART_POS start_where;
X
X	if (gline < 0 || gline > LINES-2)
X	    gline = LINES-2;
X#ifdef DEBUG
X	if (debug & DEB_INNERSRCH)
X	    printf("Start here? %d  >=? %d\n",topline + gline + 1,artline)
X	      FLUSH;
X#endif
X	if (*buf == Ctl('i') || topline+gline+1 >= artline)
X	    start_where = artpos;
X			/* in case we had a line wrap */
X	else {
X	    start_where = vrdary(topline+gline+1);
X	    if (start_where < 0)
X		start_where = -start_where;
X	}
X	if (start_where < htype[PAST_HEADER].ht_minpos)
X	    start_where = htype[PAST_HEADER].ht_minpos;
X	fseek(artfp,(long)start_where,0);
X	innersearch = 0; /* assume not found */
X	while (fgets(buf, sizeof buf, artfp) != Nullch) {
X	    /* lines_to_skip++; 		NOT USED NOW */
X#ifdef DEBUG
X	    if (debug & DEB_INNERSRCH)
X		printf("Test %s",buf) FLUSH;
X#endif
X	    if (execute(&gcompex,buf) != Nullch) {
X		innersearch = ftell(artfp);
X		break;
X	    }
X	}
X	if (!innersearch) {
X	    fseek(artfp,artpos,0);
X	    fputs("(Not found)",stdout) FLUSH;
X	    return PS_ASK;
X	}
X#ifdef DEBUG
X	if (debug & DEB_INNERSRCH)
X	    printf("On page? %ld <=? %ld\n",(long)innersearch,(long)artpos)
X	      FLUSH;
X#endif
X	if (innersearch <= artpos) {	/* already on page? */
X	    if (innersearch < artpos) {
X		artline = topline+1;
X		while (vrdary(artline) < innersearch)
X		    artline++;
X	    }
X	    highlight = artline - 1;
X#ifdef DEBUG
X	    if (debug & DEB_INNERSRCH)
X		printf("@ %d\n",highlight) FLUSH;
X#endif
X	    topline = highlight - gline;
X	    if (topline < -1)
X		topline = -1;
X	    *buf = '\f';		/* fake up a refresh */
X	    innersearch = 0;
X	    return page_switch();
X	}
X	else {				/* who knows how many lines it is? */
X	    do_fseek = TRUE;
X	    hide_everything = TRUE;
X	}
X	return PS_NORM;
X    }
X#else
X    case 'g': case 'G': case Ctl('g'):
X	notincl("g");
X	return PS_ASK;
X#endif
X    case '\n':		/* one line */
X	special = TRUE;
X	slines = 2;
X	return PS_NORM;
X#ifdef ROTATION
X    case 'X':
X	rotate = !rotate;
X	/* FALL THROUGH */
X#endif
X    case 'l':
X    case '\f':		/* refresh screen */
X#ifdef DEBUG
X	if (debug & DEB_INNERSRCH) {
X	    printf("Topline = %d",topline) FLUSH;
X	    gets(buf);
X	}
X#endif
X	clear();
X	carriage_return();	/* Resets kernel's tab column counter to 0 */
X	do_fseek = TRUE;
X	artline = topline;
X	if (artline < 0)
X	    artline = 0;
X	firstpage = (topline < 0);
X	return PS_NORM;
X    case 'b':
X    case '\b':
X    case Ctl('b'): {	/* back up a page */
X	ART_LINE target;
X
X#ifndef CLEAREOL
X	clear();
X#else
X	if (can_home_clear)	/* if we can home do it */
X	    home_cursor();
X	else
X	    clear();
X
X#endif /* CLEAREOL */
X	carriage_return();	/* Resets kernel's tab column counter to 0 */
X	do_fseek = TRUE;	/* reposition article file */
X	target = topline - (LINES - 2);
X	artline = topline;
X	if (artline >= 0) do {
X	    artline--;
X	} while(artline >= 0 && artline > target && vrdary(artline-1) >= 0);
X	topline = artline;
X			/* remember top line of screen */
X			/*  (line # within article file) */
X	if (artline < 0)
X	    artline = 0;
X	firstpage = (topline < 0);
X	return PS_NORM;
X    }
X    case 'h': {		/* help */
X	int cmd;
X
X	if ((cmd = help_page()) > 0)
X	    pushchar(cmd);
X	return PS_ASK;
X    }
X    case 't':		/* output thread data */
X	page_line = 1;
X	entire_tree(curr_artp);
X	return PS_ASK;
X    case '_':
X	if (!finish_dblchar())
X	    return PS_ASK;
X	switch (buf[1] & 0177) {
X	default:
X	    goto leave_pager;
X	}
X	break;
X    case '\177':
X    case '\0':		/* treat del,break as 'n' */
X	*buf = 'n';
X	/* FALL THROUGH */
X    case 'k':	case 'K':	case 'J':
X    case 'n':	case 'N':	case Ctl('n'):
X    case 's':	case 'S':
X    case 'e':
X    case 'u':
X    case 'w':	case 'W':
X    case '|':
X	mark_as_read();		/* mark article as read */
X	/* FALL THROUGH */
X    case 'U':	case ',':
X    case '<':	case '>':
X    case '[':	case ']':
X    case '{':	case '}':
X    case '(':   case ')':
X    case '+':   case ':':
X    case '#':
X    case '$':
X    case '&':
X    case '-':
X    case '.':
X    case '/':
X    case '1': case '2': case '3': case '4': case '5':
X    case '6': case '7': case '8': case '9':
X    case '=':
X    case '?':
X    case 'A':	case 'T':
X    case 'c':	case 'C':	
X#ifdef DEBUG
X    case 'D':
X#endif
X    case 'E':
X    case 'f':	case 'F':	case Ctl('f'):
X    case 'j':
X				case Ctl('k'):
X    case 'm':	case 'M':	
X    case 'p':	case 'P':	case Ctl('p'):	
X		case 'Q':
X    case 'r':	case 'R':	case Ctl('r'):
X    case 'v':
X		case 'Y':
X#ifndef ROTATION
X    case 'x':	case 'X':
X#endif
X    case Ctl('x'):
X    case 'z':	case 'Z':
X    case '^':
Xleave_pager:
X#ifdef ROTATION
X	rotate = FALSE;
X#endif
X	reread = FALSE;
X	do_hiding = TRUE;
X	if (index("nNpP\016\020",*buf) == Nullch &&
X	  index("wWsSe:!&|/?123456789.",*buf) != Nullch) {
X	    setdfltcmd();
X	    standout();		/* enter standout mode */
X	    printf(prompt,mailcall,dfltcmd);
X			    /* print prompt, whatever it is */
X	    un_standout();	/* leave standout mode */
X	    putchar(' ');
X	    fflush(stdout);
X	}
X	return PS_RAISE;	/* and pretend we were at end */
X#ifdef ROTATION
X    case 'x':
X	rotate = TRUE;
X	/* FALL THROUGH */
X#endif
X    case 'y':
X    case Ctl('v'):
X					/* Leaving it undocumented in case */
X					/* I want to steal the key--LAW */
X    case ' ':	/* continue current article */
X	if (erase_screen) {	/* -e? */
X#ifndef CLEAREOL
X	    clear();		/* clear screen */
X#else
X	    if (can_home_clear)	/* if we can home do it */
X		home_cursor();
X	    else
X		clear();	/* else clear screen */
X
X#endif /* CLEAREOL */
X	    carriage_return();	/* Resets kernel's tab column counter to 0 */
X	    fflush(stdout);
X
X	    if (*blinebeg != '\f'
X#ifdef CUSTOMLINES
X	      && (!pagestop || blinebeg != art_buf ||
X	          !execute(&page_compex,blinebeg))
X#endif
X	      ) {
X		restart = blinebeg;
X		artline--;	 /* restart this line */
X		artpos = alinebeg;
X		if (marking)	/* and mark repeated line */
X		    highlight = artline;
X	    }
X	    topline = artline;
X			/* and remember top line of screen */
X			/*  (line # within article file) */
X	}
X	else if (marking && *blinebeg != '\f'
X#ifdef CUSTOMLINES
X	  && (!pagestop || blinebeg != art_buf ||
X	      !execute(&page_compex,blinebeg))
X#endif
X	  ) {
X				/* are we marking repeats? */
X	    up_line();		/* go up one line */
X	    highlight = --artline;/* and get ready to highlight */
X	    restart = blinebeg;	/*   the old line */
X	    artpos = alinebeg;
X	}
X	return PS_NORM;
X    case 'q':	/* quit this article? */
X	do_hiding = TRUE;
X	return PS_TOEND;
X    default:
X	fputs(hforhelp,stdout) FLUSH;
X	settle_down();
X	return PS_ASK;
X    }
X}
X
X#ifdef INNERSEARCH
Xbool
Xinnermore()
X{
X    if (artpos < innersearch) {		/* not even on page yet? */
X#ifdef DEBUG
X	if (debug & DEB_INNERSRCH)
X	    printf("Not on page %ld < %ld\n",(long)artpos,(long)innersearch)
X	      FLUSH;
X#endif
X	return TRUE;
X    }
X    if (artpos == innersearch) {	/* just got onto page? */
X	isrchline = artline;		/* remember first line after */
X	highlight = artline - 1;
X#ifdef DEBUG
X	if (debug & DEB_INNERSRCH)
X	    printf("There it is %ld = %ld, %d @ %d\n",(long)artpos,
X		(long)innersearch,hide_everything,highlight) FLUSH;
X#endif
X	if (hide_everything) {		/* forced refresh? */
X	    topline = highlight - gline;
X	    if (topline < -1)
X		topline = -1;
X	    return FALSE;		/* let refresh do it all */
X	}
X    }
X#ifdef DEBUG
X    if (debug & DEB_INNERSRCH)
X	printf("Not far enough? %d <? %d + %d\n",artline,isrchline,gline)
X	  FLUSH;
X#endif
X    if (artline < isrchline + gline) {
X	return TRUE;
X    }
X    return FALSE;
X}
X#endif
X
X#ifdef MIME_SUPPORT
Xint
Xnontext(content_type)
Xchar *content_type;
X{
X    char *t;
X
X    if (content_type[0] == '\n')
X	return 0;
X    while (content_type && isspace(*content_type))
X	content_type++;
X    t = index(content_type, ';');
X    if (!t)
X	t = index(content_type, '\n');
X    if (t)
X	*t-- = '\0';
X    while (t && *t && t > content_type && isspace(*t))
X	*t-- = '\0';
X    if (notplain(content_type))
X	return 1;
X    return 0;
X}
X
Xint
Xnotplain(s)
Xchar *s;
X{
X    char *t;
X    if (!s)
X	return 1;
X    while (*s && isspace(*s))
X	s++;
X    for (t=s; *t; ++t) {
X	if (isupper(*t))
X	    *t = tolower(*t);
X    }
X    while (t > s && isspace(*--t)) ;
X    if (((t-s) == 3) && !strncmp(s, "text", 4))
X	return 0;
X    if (strncmp(s, "text/plain", 10))
X	return 1;
X    t = index(s, ';');
X    while (t) {
X	t++;
X	while (*t && isspace(*t)) t++;
X	if (!strncmp(t, "charset", 7)) {
X	    s = index(t, '=');
X	    if (s) {
X		s++;
X		while (*s && isspace(*s)) s++;
X		if (!strncmp(s, "us-ascii", 8))
X		    return 0;
X	    }
X	    return(1);
X	}
X	t = index(t, ';');
X    }
X    return 0;	/* no charset, was text/plain */
X}
X#endif
END_OF_FILE
if test 26289 -ne `wc -c <'art.c'`; then
    echo shar: \"'art.c'\" unpacked with wrong size!
fi
# end of 'art.c'
fi
if test -f 'intrp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'intrp.c'\"
else
echo shar: Extracting \"'intrp.c'\" \(28089 characters\)
sed "s/^X//" >'intrp.c' <<'END_OF_FILE'
X/* $Id: intrp.c,v 3.0 1992/02/01 03:09:32 davison Trn $
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "util.h"
X#include "search.h"
X#include "cache.h"
X#include "bits.h"
X#include "head.h"
X#include "trn.h"
X#include "artsrch.h"
X#include "ng.h"
X#include "ngdata.h"
X#include "respond.h"
X#include "rcstuff.h"
X#include "artio.h"
X#include "init.h"
X#include "term.h"
X#include "final.h"
X#include "rthread.h"
X#include "rt-select.h"
X#include "rt-util.h"
X#include "nntp.h"
X#include "INTERN.h"
X#include "intrp.h"
X
Xstatic char * regexp_specials = "^$.*[\\/?%";
X
Xchar orgname[] = ORGNAME;
X
X#ifdef HAS_UNAME
X#include <sys/utsname.h>
Xstruct utsname utsn;
X#endif
X
X#ifdef TILDENAME
Xstatic char *tildename = Nullch;
Xstatic char *tildedir = Nullch;
X#endif
X
X#ifdef CONDSUB
XCOMPEX cond_compex;
Xchar *skipinterp _((char *,char *));
X#endif
X
Xstatic void abort_interp _((void));
X
Xvoid
Xintrp_init(tcbuf)
Xchar *tcbuf;
X{
X    char *getlogin();
X
X#ifdef CONDSUB
X    init_compex(&cond_compex);
X#endif
X    
X    /* get environmental stuff */
X
X#ifdef NEWS_ADMIN
X    {
X#ifdef HAS_GETPWENT
X	struct passwd *getpwnam();
X	struct passwd *pwd = getpwnam(NEWS_ADMIN);
X
X	if (pwd != NULL)
X	    newsuid = pwd->pw_uid;
X#else
X#ifdef TILDENAME
X	char tildenews[2+sizeof NEWS_ADMIN];
X	strcpy(tildenews, "~");
X	strcat(tildenews, NEWS_ADMIN);
X	(void) filexp(tildenews);
X#else
X	??? "Define either HAS_GETPWENT or TILDENAME to get NEWS_ADMIN"
X#endif  /* TILDENAME */
X#endif	/* HAS_GETPWENT */
X    }
X#endif	/* NEWS_ADMIN */
X    /* get home directory */
X
X    homedir = getenv("HOME");
X    if (homedir == Nullch)
X	homedir = getenv("LOGDIR");
X
X    dotdir = getval("DOTDIR",homedir);
X
X    /* get login name */
X
X    loginName = getenv("USER");
X    if (loginName == Nullch)
X	loginName = getenv("LOGNAME");
X#ifdef GETLOGIN
X    if (loginName == Nullch)
X	loginName = savestr(getlogin());
X#endif
X
X    spool = savestr(filexp(NEWSSPOOL));	/* usually /usr/spool/news */
X    threaddir = filexp(THREAD_DIR);
X    if (strEQ(threaddir,spool))
X	threaddir = spool;
X    else
X	threaddir = savestr(threaddir);
X    overviewdir = filexp(OVERVIEW_DIR);
X    if (strEQ(overviewdir,spool))
X	overviewdir = spool;
X    else
X	overviewdir = savestr(overviewdir);
X
X#ifdef NEWS_ADMIN
X    /* if this is the news admin then load his UID into newsuid */
X
X    if (strEQ(loginName,NEWS_ADMIN))
X	newsuid = getuid();
X#endif
X
X    if (checkflag)			/* that getwd below takes ~1/3 sec. */
X	return;				/* and we do not need it for -c */
X    getwd(tcbuf);			/* find working directory name */
X    origdir = savestr(tcbuf);		/* and remember it */
X
X    /* get the real name of the person (%N) */
X    /* Must be done after loginName is read in because BERKNAMES uses that */
X
X    strcpy(tcbuf,getrealname((long)getuid()));
X    realname = savestr(tcbuf);
X
X    /* name of header file (%h) */
X
X    headname = savestr(filexp(HEADNAME));
X
X    /* host name that goes in postings (%H) */
X
X    phostname = PHOSTNAME;
X    if (*phostname == '/') {
X	if ((tmpfp = fopen(phostname,"r")) == NULL) {
X	    printf("Warning: Couldn't open %s to determine hostname!\n",
X		   phostname); 
X	    sig_catcher(0);
X	}
X	fgets(buf, sizeof(buf), tmpfp);
X	if (buf[strlen(buf)-1] == '\n')
X	    buf[strlen(buf)-1] = 0;
X	fclose(tmpfp);
X	phostname = savestr(buf);
X    }
X    else {
X#ifdef HAS_GETHOSTNAME
X	gethostname(buf,sizeof buf);
X#else
X# ifdef HAS_UNAME
X	/* get sysname */
X	uname(&utsn);
X	strcpy(buf,utsn.nodename);
X# else
X#  ifdef PHOSTCMD
X       {
X	FILE *popen();
X	FILE *pipefp = popen(PHOSTCMD,"r");
X	
X	if (pipefp == Nullfp) {
X	    printf("Can't find hostname\n");
X	    sig_catcher(0);
X	}
X	fgets(buf,sizeof buf,pipefp);
X	buf[strlen(buf)-1] = '\0';	/* wipe out newline */
X	pclose(pipefp);
X       }
X#  else
X	*buf = '\0';
X#  endif /* PHOSTCMD */
X# endif /* HAS_UNAME */
X#endif /* HAS_GETHOSTNAME */
X	if (*buf) {
X	    char *cp = index(buf,'.');
X	    if (cp)
X		*cp = '\0';
X	    cp = index(phostname,'.');
X	    if (cp)
X		strcat(buf,cp);
X	    phostname = savestr(buf);
X	}
X    }
X}
X
X/* expand filename via %, ~, and $ interpretation */
X/* returns pointer to static area */
X/* Note that there is a 1-deep cache of ~name interpretation */
X
Xchar *
Xfilexp(s)
Xregister char *s;
X{
X    static char filename[CBUFLEN];
X    char scrbuf[CBUFLEN];
X    register char *d;
X
X#ifdef DEBUG
X    if (debug & DEB_FILEXP)
X	printf("< %s\n",s) FLUSH;
X#endif
X    interp(filename, (sizeof filename), s);	
X					/* interpret any % escapes */
X#ifdef DEBUG
X    if (debug & DEB_FILEXP)
X	printf("%% %s\n",filename) FLUSH;
X#endif
X    s = filename;
X    if (*s == '~') {	/* does destination start with ~? */
X	if (!*(++s) || *s == '/') {
X	    sprintf(scrbuf,"%s%s",homedir,s);
X				/* swap $HOME for it */
X#ifdef DEBUG
X    if (debug & DEB_FILEXP)
X	printf("~ %s\n",scrbuf) FLUSH;
X#endif
X	    strcpy(filename,scrbuf);
X	}
X	else {
X#ifdef TILDENAME
X	    for (d=scrbuf; isalnum(*s); s++,d++)
X		*d = *s;
X	    *d = '\0';
X	    if (tildedir && strEQ(tildename,scrbuf)) {
X		strcpy(scrbuf,tildedir);
X		strcat(scrbuf, s);
X		strcpy(filename, scrbuf);
X#ifdef DEBUG
X		if (debug & DEB_FILEXP)
X		    printf("r %s %s\n",tildename,tildedir) FLUSH;
X#endif
X	    }
X	    else {
X		if (tildename) {
X		    free(tildename);
X		    free(tildedir);
X		}
X		tildedir = Nullch;
X		tildename = savestr(scrbuf);
X#ifdef HAS_GETPWENT	/* getpwnam() is not the paragon of efficiency */
X		{
X#ifdef notdef
X		    struct passwd *getpwnam _((char*));
X#endif
X		    struct passwd *pwd = getpwnam(tildename);
X		    if (pwd == NULL) {
X			printf("%s is an unknown user. Using default.\n",tildename) FLUSH;
X			return Nullch;
X		    }
X		    sprintf(scrbuf,"%s%s",pwd->pw_dir,s);
X		    tildedir = savestr(pwd->pw_dir);
X		    strcpy(filename,scrbuf);
X		    endpwent();
X		}
X#else			/* this will run faster, and is less D space */
X		{	/* just be sure LOGDIRFIELD is correct */
X		    FILE *pfp = fopen("/etc/passwd","r");
X		    char tmpbuf[512];
X		    int i;
X		    
X		    if (pfp == Nullfp) {
X			printf(cantopen,"passwd") FLUSH;
X			sig_catcher(0);
X		    }
X		    while (fgets(tmpbuf,512,pfp) != Nullch) {
X			d = cpytill(scrbuf,tmpbuf,':');
X#ifdef DEBUG
X			if (debug & DEB_FILEXP)
X			    printf("p %s\n",tmpbuf) FLUSH;
X#endif
X			if (strEQ(scrbuf,tildename)) {
X			    for (i=LOGDIRFIELD-2; i; i--) {
X				if (d)
X				    d = index(d+1,':');
X			    }
X			    if (d) {
X				cpytill(scrbuf,d+1,':');
X				tildedir = savestr(scrbuf);
X				strcat(scrbuf,s);
X				strcpy(filename,scrbuf);
X			    }
X			    break;
X			}
X		    }
X		    fclose(pfp);
X		}
X#endif
X	    }
X#else /* !TILDENAME */
X#ifdef VERBOSE
X	    IF(verbose)
X		fputs("~loginname not implemented.\n",stdout) FLUSH;
X	    ELSE
X#endif
X#ifdef TERSE
X		fputs("~login not impl.\n",stdout) FLUSH;
X#endif
X#endif
X	}
X    }
X    else if (*s == '$') {	/* starts with some env variable? */
X	d = scrbuf;
X	*d++ = '%';
X	if (s[1] == '{')
X	    strcpy(d,s+2);
X	else {
X	    *d++ = '{';
X	    for (s++; isalnum(*s); s++) *d++ = *s;
X				/* skip over token */
X	    *d++ = '}';
X	    strcpy(d,s);
X	}
X#ifdef DEBUG
X	if (debug & DEB_FILEXP)
X	    printf("$ %s\n",scrbuf) FLUSH;
X#endif
X	interp(filename, (sizeof filename), scrbuf);
X					/* this might do some extra '%'s but */
X					/* that is how the Mercedes Benz */
X    }
X#ifdef DEBUG
X    if (debug & DEB_FILEXP)
X	printf("> %s\n",filename) FLUSH;
X#endif
X    return filename;
X}
X
X#ifdef CONDSUB
X/* skip interpolations */
X
Xchar *
Xskipinterp(pattern,stoppers)
Xregister char *pattern;
Xchar *stoppers;
X{
X
X    while (*pattern && (!stoppers || !index(stoppers,*pattern))) {
X#ifdef DEBUG
X	if (debug & DEB_INTRP)
X	    printf("skipinterp till %s at %s\n",stoppers?stoppers:"",pattern);
X#endif
X	if (*pattern == '%' && pattern[1]) {
X	    switch (*++pattern) {
X	    case '{':
X		for (pattern++; *pattern && *pattern != '}'; pattern++)
X		    if (*pattern == '\\')
X			pattern++;
X		break;
X	    case '[':
X		for (pattern++; *pattern && *pattern != ']'; pattern++)
X		    if (*pattern == '\\')
X			pattern++;
X		break;
X#ifdef CONDSUB
X	    case '(': {
X		pattern = skipinterp(pattern+1,"!=");
X		if (!*pattern)
X		    goto getout;
X		for (pattern++; *pattern && *pattern != '?'; pattern++)
X		    if (*pattern == '\\')
X			pattern++;
X		if (!*pattern)
X		    goto getout;
X		pattern = skipinterp(pattern+1,":)");
X		if (*pattern == ':')
X		    pattern = skipinterp(pattern+1,")");
X		break;
X	    }
X#endif
X#ifdef BACKTICK
X	    case '`': {
X		pattern = skipinterp(pattern+1,"`");
X		break;
X	    }
X#endif
X#ifdef PROMPTTTY
X	    case '"':
X		pattern = skipinterp(pattern+1,"\"");
X		break;
X#endif
X	    default:
X		break;
X	    }
X	    pattern++;
X	}
X	else {
X	    if (*pattern == '^' && pattern[1])
X		pattern += 2;
X	    else if (*pattern == '\\' && pattern[1])
X		pattern += 2;
X	    else
X		pattern++;
X	}
X    }
Xgetout:
X    return pattern;			/* where we left off */
X}
X#endif
X
X/* interpret interpolations */
X
Xchar *
Xdointerp(dest,destsize,pattern,stoppers)
Xregister char *dest;
Xregister int destsize;
Xregister char *pattern;
Xchar *stoppers;
X{
X    char *subj_buf = Nullch;
X    char *ngs_buf = Nullch;
X    char *refs_buf = Nullch;
X    char *artid_buf = Nullch;
X    char *reply_buf = Nullch;
X    char *from_buf = Nullch;
X    char *path_buf = Nullch;
X    char *follow_buf = Nullch;
X    char *dist_buf = Nullch;
X    char *line_buf = Nullch;
X    char *line_split = Nullch;
X    char *orig_dest = dest;
X    register char *s, *h;
X    register int i;
X    char scrbuf[512];
X    char spfbuf[512];
X    bool upper = FALSE;
X    bool lastcomp = FALSE;
X    bool re_quote = FALSE;
X    bool tick_quote = FALSE;
X    bool address_parse = FALSE;
X    bool comment_parse = FALSE;
X    bool proc_sprintf = FALSE;
X    int metabit = 0;
X
X    while (*pattern && (!stoppers || !index(stoppers,*pattern))) {
X#ifdef DEBUG
X	if (debug & DEB_INTRP)
X	    printf("dointerp till %s at %s\n",stoppers?stoppers:"",pattern);
X#endif
X	if (*pattern == '%' && pattern[1]) {
X	    upper = FALSE;
X	    lastcomp = FALSE;
X	    re_quote = FALSE;
X	    tick_quote = FALSE;
X	    address_parse = FALSE;
X	    comment_parse = FALSE;
X	    proc_sprintf = FALSE;
X	    for (s=Nullch; !s; ) {
X		switch (*++pattern) {
X		case '^':
X		    upper = TRUE;
X		    break;
X		case '_':
X		    lastcomp = TRUE;
X		    break;
X		case '\\':
X		    re_quote = TRUE;
X		    break;
X		case '\'':
X		    tick_quote = TRUE;
X		    break;
X		case '>':
X		    address_parse = TRUE;
X		    break;
X		case ')':
X		    comment_parse = TRUE;
X		    break;
X		case ':':
X		    proc_sprintf = TRUE;
X		    h = spfbuf;
X		    *h++ = '%';
X		    pattern++;	/* Skip over ':' */
X		    while (*pattern
X		     && (*pattern=='.' || *pattern=='-' || isdigit(*pattern))) {
X			*h++ = *pattern++;
X		    }
X		    *h++ = 's';
X		    *h++ = '\0';
X		    pattern--;
X		    break;
X		case '/':
X#ifdef ARTSEARCH
X		    s = scrbuf;
X		    if (!index("/?g",pattern[-2]))
X			*s++ = '/';
X		    strcpy(s,lastpat);
X		    s += strlen(s);
X		    if (pattern[-2] != 'g') {
X			if (index("/?",pattern[-2]))
X			    *s++ = pattern[-2];
X			else
X			    *s++ = '/';
X			if (art_doread)
X			    *s++ = 'r';
X			if (art_howmuch != ARTSCOPE_SUBJECT) {
X			    *s++ = scopestr[art_howmuch];
X			    if (art_howmuch == ARTSCOPE_ONEHDR) {
X				safecpy(s,art_srchhdr,
X					(sizeof scrbuf) - (s-scrbuf));
X				s = index(s,':') + 1;
X				if (!s)
X				    s = scrbuf+(sizeof scrbuf)-1;
X			    }
X			}
X		    }
X		    *s = '\0';
X		    s = scrbuf;
X#else
X		    s = nullstr;
X#endif
X		    break;
X		case '{':
X		    pattern = cpytill(scrbuf,pattern+1,'}');
X		    if (s = index(scrbuf,'-'))
X			*s++ = '\0';
X		    else
X			s = nullstr;
X		    s = getval(scrbuf,s);
X		    break;
X		case '[':
X		    pattern = cpytill(scrbuf,pattern+1,']');
X		    i = set_line_type(scrbuf,scrbuf+strlen(scrbuf));
X		    if (line_buf)
X			free(line_buf);
X		    s = line_buf = fetchlines(art,i);
X		    break;
X#ifdef CONDSUB
X		case '(': {
X		    COMPEX *oldbra_compex = bra_compex;
X		    char rch;
X		    bool matched;
X		    
X		    pattern = dointerp(dest,destsize,pattern+1,"!=");
X		    rch = *pattern;
X		    if (rch == '!')
X			pattern++;
X		    if (*pattern != '=')
X			goto getout;
X		    pattern = cpytill(scrbuf,pattern+1,'?');
X		    if (!*pattern)
X			goto getout;
X		    if (s = compile(&cond_compex,scrbuf,TRUE,TRUE)) {
X			printf("%s: %s\n",scrbuf,s) FLUSH;
X			pattern += strlen(pattern);
X			free_compex(&cond_compex);
X			goto getout;
X		    }
X		    matched = (execute(&cond_compex,dest) != Nullch);
X		    if (getbracket(&cond_compex, 0)) /* were there brackets? */
X			bra_compex = &cond_compex;
X		    if (matched==(rch == '=')) {
X			pattern = dointerp(dest,destsize,pattern+1,":)");
X			if (*pattern == ':')
X			    pattern = skipinterp(pattern+1,")");
X		    }
X		    else {
X			pattern = skipinterp(pattern+1,":)");
X			if (*pattern == ':')
X			    pattern++;
X			pattern = dointerp(dest,destsize,pattern,")");
X		    }
X		    s = dest;
X		    bra_compex = oldbra_compex;
X		    free_compex(&cond_compex);
X		    break;
X		}
X#endif
X#ifdef BACKTICK
X		case '`': {
X		    FILE *pipefp, *popen();
X
X		    pattern = dointerp(scrbuf,(sizeof scrbuf),pattern+1,"`");
X		    pipefp = popen(scrbuf,"r");
X		    if (pipefp != Nullfp) {
X			int len;
X
X			len = fread(scrbuf,sizeof(char),(sizeof scrbuf)-1,
X			    pipefp);
X			scrbuf[len] = '\0';
X			pclose(pipefp);
X		    }
X		    else {
X			printf("\nCan't run %s\n",scrbuf);
X			*scrbuf = '\0';
X		    }
X		    for (s=scrbuf; *s; s++) {
X			if (*s == '\n') {
X			    if (s[1])
X				*s = ' ';
X			    else
X				*s = '\0';
X			}
X		    }
X		    s = scrbuf;
X		    break;
X		}
X#endif
X#ifdef PROMPTTTY
X		case '"':
X		    pattern = dointerp(scrbuf,(sizeof scrbuf),pattern+1,"\"");
X		    fputs(scrbuf,stdout) FLUSH;
X		    resetty();
X		    gets(scrbuf);
X		    noecho();
X		    crmode();
X		    s = scrbuf;
X		    break;
X#endif
X		case '~':
X		    s = homedir;
X		    break;
X		case '.':
X		    s = dotdir;
X		    break;
X		case '$':
X		    s = scrbuf;
X		    sprintf(s,"%ld",our_pid);
X		    break;
X		case '#':
X		    s = scrbuf;
X		    sprintf(s,"%d",perform_cnt);
X		    break;
X		case '?':
X		    s = " ";
X		    line_split = dest;
X		    break;
X		case '0': case '1': case '2': case '3': case '4':
X		case '5': case '6': case '7': case '8': case '9':
X#ifdef CONDSUB
X		    s = getbracket(bra_compex,*pattern - '0');
X#else
X		    s = nullstr;
X#endif
X		    break;
X		case 'a':
X		    s = scrbuf;
X		    sprintf(s,"%ld",(long)art);
X		    break;
X		case 'A':
X#ifdef LINKART
X		    s = linkartname;	/* so Eunice people get right file */
X#else
X		    s = scrbuf;
X#ifdef USE_NNTP
X		    sprintf(s,"%s/%s",spool,nntp_artname());
X#else
X		    sprintf(s,"%s/%s/%ld",spool,ngdir,(long)art);
X#endif
X#endif
X		    break;
X		case 'b':
X		    s = savedest;
X		    break;
X		case 'B':
X		    s = scrbuf;
X		    sprintf(s,"%ld",(long)savefrom);
X		    break;
X		case 'c':
X		    s = ngdir;
X		    break;
X		case 'C':
X		    s = ngname;
X		    break;
X		case 'd':
X		    s = scrbuf;
X		    sprintf(s,"%s/%s",spool,ngdir);
X		    break;
X		case 'D':
X		    s = dist_buf = fetchlines(art,DIST_LINE);
X		    break;
X		case 'e':
X		    s = (extractprog ? extractprog : "-");
X		    break;
X		case 'E':
X		    s = extractdest;
X		    break;
X		case 'f':			/* from line */
X		    parseheader(art);
X		    if (htype[REPLY_LINE].ht_minpos >= 0 && !comment_parse) {
X						/* was there a reply line? */
X			if (!(s=reply_buf))
X			    s = reply_buf = fetchlines(art,REPLY_LINE);
X		    }
X		    else if (!(s = from_buf))
X			s = from_buf = fetchlines(art,FROM_LINE);
X		    break;
X		case 'F':
X		    parseheader(art);
X		    if (htype[FOLLOW_LINE].ht_minpos >= 0)
X					/* is there a Followup-To line? */
X			s = follow_buf = fetchlines(art,FOLLOW_LINE);
X		    else 
X			s = ngs_buf = fetchlines(art,NGS_LINE);
X		    break;
X		case 'h':			/* header file name */
X		    s = headname;
X		    break;
X		case 'H':			/* host name in postings */
X		    s = phostname;
X		    break;
X		case 'i':
X		    if (!(s=artid_buf))
X			s = artid_buf = fetchlines(art,MESSID_LINE);
X		    if (*s && *s != '<') {
X			sprintf(scrbuf,"<%s>",artid_buf);
X			s = scrbuf;
X		    }
X		    break;
X		case 'I':			/* ref article indicator */
X		    s = scrbuf;
X		    sprintf(scrbuf,"'%s'",indstr);
X		    break;
X		case 'l':			/* rn library */
X#ifdef NEWS_ADMIN
X		    s = newsadmin;
X#else
X		    s = "???";
X#endif
X		    break;
X		case 'L':			/* login id */
X		    s = loginName;
X		    break;
X		case 'm':		/* current mode */
X		    s = scrbuf;
X		    *s = mode;
X		    s[1] = '\0';
X		    break;
X		case 'M':
X		    sprintf(scrbuf,"%ld",(long)dmcount);
X		    s = scrbuf;
X		    break;
X		case 'n':			/* newsgroups */
X		    s = ngs_buf = fetchlines(art,NGS_LINE);
X		    break;
X		case 'N':			/* full name */
X		    s = getval("NAME",realname);
X		    break;
X		case 'o':			/* organization */
X#ifdef IGNOREORG
X		    s = getval("NEWSORG",orgname); 
X#else
X		    s = getenv("NEWSORG");
X		    if (s == Nullch) 
X			s = getval("ORGANIZATION",orgname); 
X#endif
X#ifdef ORGFILE
X		    if (*s == '/') {
X			FILE *ofp = fopen(s,"r");
X
X			if (ofp) {
X			    fgets(scrbuf,sizeof scrbuf,ofp);
X			    fclose(ofp);
X			    s = scrbuf+strlen(scrbuf)-1;
X			    if (*s == '\n')
X				*s = '\0';
X			    s = scrbuf;
X			}
X		    }
X#endif
X		    break;
X		case 'O':
X		    s = origdir;
X		    break;
X		case 'p':
X		    s = cwd;
X		    break;
X		case 'P':
X		    s = spool;
X		    break;
X		case 'r':
X		    parseheader(art);
X		    if (htype[REFS_LINE].ht_minpos >= 0) {
X			refs_buf = fetchlines(art,REFS_LINE);
X			refscpy(scrbuf,(sizeof scrbuf),refs_buf);
X		    }
X		    else
X			*scrbuf = '\0';
X		    s = rindex(scrbuf,'<');
X		    break;
X		case 'R':
X		    parseheader(art);
X		    if (htype[REFS_LINE].ht_minpos >= 0) {
X			refs_buf = fetchlines(art,REFS_LINE);
X			refscpy(scrbuf,(sizeof scrbuf),refs_buf);
X			/* no more than 3 prior references PLUS the
X			** root article allowed, including the one
X			** concatenated below */
X			if ((s = rindex(scrbuf,'<')) > scrbuf) {
X			    *s = '\0';
X			    h = rindex(scrbuf,'<');
X			    *s = '<';
X			    if (h > scrbuf) {
X				s = index(scrbuf+1,'<');
X				if (s < h)
X				    strcpy(s,h);
X			    }
X			}
X		    }
X		    else
X			*scrbuf = '\0';
X		    if (!artid_buf)
X			artid_buf = fetchlines(art,MESSID_LINE);
X		    if (artid_buf[0] == '<')
X			safecat(scrbuf,artid_buf,sizeof(scrbuf));
X		    else if (artid_buf[0]) {
X			char tmpbuf[64];
X    
X			sprintf(tmpbuf,"<%s>",artid_buf);
X			safecat(scrbuf,tmpbuf,sizeof(scrbuf));
X		    }
X		    s = scrbuf;
X		    break;
X		case 's':
X		    if (!(s=subj_buf))
X			s = subj_buf = fetchsubj(art,TRUE);
X						/* get subject handy */
X		    while ((*s=='R'||*s=='r')&&(s[1]=='E'||s[1]=='e')&&s[2]==':') {
X						/* skip extra Re: */
X			s += 3;
X			if (*s == ' ')
X			    s++;
X		    }
X		    if (h = instr(s,"- (nf", TRUE))
X			*h = '\0';
X		    break;
X		case 'S':
X		    if (!(s=subj_buf))
X			s = subj_buf = fetchsubj(art,TRUE);
X						/* get subject handy */
X		    if ((*s=='R'||*s=='r')&&(s[1]=='E'||s[1]=='e')&&s[2]==':') {
X						/* skip extra Re: */
X			s += 3;
X			if (*s == ' ')
X			    s++;
X		    }
X		    break;
X		case 't':
X		case 'T':
X		    parseheader(art);
X		    if (htype[REPLY_LINE].ht_minpos >= 0) {
X					/* was there a reply line? */
X			if (!(s=reply_buf))
X			    s = reply_buf = fetchlines(art,REPLY_LINE);
X		    }
X		    else if (!(s = from_buf))
X			s = from_buf = fetchlines(art,FROM_LINE);
X		    else
X			s = "noname";
X		    if (*pattern == 'T') {
X			if (htype[PATH_LINE].ht_minpos >= 0) {
X					/* should we substitute path? */
X			    s = path_buf = fetchlines(art,PATH_LINE);
X			}
X			i = strlen(phostname);
X			if (strnEQ(phostname,s,i) && s[i] == '!')
X			    s += i + 1;
X		    }
X		    address_parse = TRUE;	/* just the good part */
X		    break;
X		case 'u':
X		    sprintf(scrbuf,"%ld",(long)toread[ng]);
X		    s = scrbuf;
X		    break;
X		case 'U': {
X		    int unseen;
X
X		    unseen = (art <= lastart) && !was_read(art);
X		    if (selected_only) {
X			int selected;
X
X			selected = (curr_artp->flags & AF_SEL);
X			sprintf(scrbuf,"%ld",
X				(long)selected_count - (selected && unseen));
X		    }
X		    else
X			sprintf(scrbuf,"%ld",(long)toread[ng] - unseen);
X		    s = scrbuf;
X		    break;
X		}
X		case 'v': {
X		    int selected, unseen;
X
X		    selected = (curr_artp->flags & AF_SEL);
X		    unseen = (art <= lastart) && !was_read(art);
X		    sprintf(scrbuf,"%ld",(long)toread[ng] - selected_count
X					 - (!selected && unseen));
X		    s = scrbuf;
X		    break;
X		}
X		case 'W':
X		    s = threaddir;
X		    break;
X		case 'x':			/* news library */
X		    s = lib;
X		    break;
X		case 'X':			/* rn library */
X		    s = rnlib;
X		    break;
X		case 'z':
X#ifdef LINKART
X		    s = linkartname;	/* so Eunice people get right file */
X#else
X		    s = scrbuf;
X		    sprintf(s,"%ld",(long)art);
X#endif
X		    if (stat(s,&filestat) < 0)
X			filestat.st_size = 0L;
X		    sprintf(scrbuf,"%5ld",(long)filestat.st_size);
X		    s = scrbuf;
X		    break;
X		case 'Z':
X		    sprintf(scrbuf,"%ld",(long)selected_count);
X		    s = scrbuf;
X		    break;
X		default:
X		    if (--destsize <= 0)
X			abort_interp();
X		    *dest++ = *pattern | metabit;
X		    s = nullstr;
X		    break;
X		}
X	    }
X	    if (!s)
X		s = nullstr;
X	    if (proc_sprintf) {
X		sprintf(scrbuf,spfbuf,s);
X		s = scrbuf;
X	    }
X	    pattern++;
X	    if (upper || lastcomp) {
X		char *t;
X
X		if (s != scrbuf) {
X		    safecpy(scrbuf,s,(sizeof scrbuf));
X		    s = scrbuf;
X		}
X		if (upper || !(t=rindex(s,'/')))
X		    t = s;
X		while (*t && !isalpha(*t))
X		    t++;
X		if (islower(*t))
X		    *t = toupper(*t);
X	    }
X	    /* Do we have room left? */
X	    i = strlen(s);
X	    if (destsize <= i)
X		abort_interp();
X	    destsize -= i;	/* adjust the size now. */
X
X	    /* A maze of twisty little conditions, all alike... */
X	    if (address_parse || comment_parse) {
X		if (s != scrbuf) {
X		    safecpy(scrbuf,s,(sizeof scrbuf));
X		    s = scrbuf;
X		}
X		if (address_parse) {
X		    if ((h=index(s,'<')) != Nullch) { /* grab the good part */
X			s = h+1;
X			if ((h=index(s,'>')) != Nullch)
X			    *h = '\0';
X		    } else if ((h=index(s,'(')) != Nullch) {
X			while (h-- != s && *h == ' ')
X			    ;
X			h[1] = '\0';		/* or strip the comment */
X		    }
X		} else {
X		    if (!(s = extract_name(s)))
X			s = nullstr;
X		}
X	    }
X	    if (metabit) {
X		/* set meta bit while copying. */
X		i = metabit;		/* maybe get into register */
X		if (s == dest) {
X		    while (*dest)
X			*dest++ |= i;
X		} else {
X		    while (*s)
X			*dest++ = *s++ | i;
X		}
X	    } else if (re_quote || tick_quote) {
X		/* put a backslash before regexp specials while copying. */
X		if (s == dest) {
X		    /* copy out so we can copy in. */
X		    safecpy(scrbuf, s, sizeof scrbuf);
X		    s = scrbuf;
X		    if (i > sizeof scrbuf)	/* we truncated, ack! */
X			abort_interp();
X		}
X		if (tick_quote) {
X		    *dest++ = '\'';
X		    if ((destsize -= 2) <= 0)
X			abort_interp();
X		}
X		while (*s) {
X		    if ((re_quote && index(regexp_specials, *s))
X		     || (tick_quote && *s == '\'')) {
X			if (--destsize <= 0)
X			    abort_interp();
X			*dest++ = '\\';
X		    }
X		    *dest++ = *s++;
X		}
X		if (tick_quote)
X		    *dest++ = '\'';
X	    } else {
X		/* straight copy. */
X		if (s == dest) {
X		    dest += i;
X		} else {
X		    while (*s)
X			*dest++ = *s++;
X		}
X	    }
X	}
X	else {
X	    if (--destsize <= 0)
X		abort_interp();
X	    if (*pattern == '^' && pattern[1]) {
X		++pattern;			/* skip uparrow */
X		i = *pattern;		/* get char into a register */
X		if (i == '?')
X		    *dest++ = '\177' | metabit;
X		else if (i == '(') {
X		    metabit = 0200;
X		    destsize++;
X		}
X		else if (i == ')') {
X		    metabit = 0;
X		    destsize++;
X		}
X		else
X		    *dest++ = (i & 037) | metabit;
X		pattern++;
X	    }
X	    else if (*pattern == '\\' && pattern[1]) {
X		++pattern;			/* skip backslash */
X		i = *pattern;		/* get char into a register */
X    
X		/* this used to be a switch but the if may save space */
X		
X		if (i >= '0' && i <= '7') {
X		    i = 1;
X		    while (i < 01000 && *pattern >= '0' && *pattern <= '7') {
X			i <<= 3;
X			i += *pattern++ - '0';
X		    }
X		    *dest++ = (i & 0377) | metabit;
X		    --pattern;
X		}
X		else if (i == 'b')
X		    *dest++ = '\b' | metabit;
X		else if (i == 'f')
X		    *dest++ = '\f' | metabit;
X		else if (i == 'n')
X		    *dest++ = '\n' | metabit;
X		else if (i == 'r')
X		    *dest++ = '\r' | metabit;
X		else if (i == 't')
X		    *dest++ = '\t' | metabit;
X		else
X		    *dest++ = i | metabit;
X		pattern++;
X	    }
X	    else
X		*dest++ = *pattern++ | metabit;
X	}
X    }
X    *dest = '\0';
X    if (line_split != Nullch)
X	if (strlen(orig_dest) > 79)
X	    *line_split = '\n';
Xgetout:
X    if (subj_buf != Nullch)	/* return any checked out storage */
X	free(subj_buf);
X    if (ngs_buf != Nullch)
X	free(ngs_buf);
X    if (refs_buf != Nullch)
X	free(refs_buf);
X    if (artid_buf != Nullch)
X	free(artid_buf);
X    if (reply_buf != Nullch)
X	free(reply_buf);
X    if (from_buf != Nullch)
X	free(from_buf);
X    if (path_buf != Nullch)
X	free(path_buf);
X    if (follow_buf != Nullch)
X	free(follow_buf);
X    if (dist_buf != Nullch)
X	free(dist_buf);
X    if (line_buf != Nullch)
X	free(line_buf);
X    return pattern;			/* where we left off */
X}
X
Xvoid
Xinterp(dest,destsize,pattern)
Xchar *dest;
Xint destsize;
Xchar *pattern;
X{
X    dointerp(dest,destsize,pattern,Nullch);
X#ifdef DEBUG
X    if (debug & DEB_FILEXP)
X	fputs(dest,stdout);
X#endif
X}
X
X/* copy a references line, normalizing as we go */
X
Xvoid
Xrefscpy(dest,destsize,src)
Xregister char *dest, *src;
Xregister int destsize;
X{
X    register char *dot, *at, *beg;
X    char tmpbuf[64];
X    
X    while (*src) {
X	if (*src != '<') {
X	    if (--destsize <= 0)
X		break;
X	    *dest++ = '<';
X	    at = dot = Nullch;
X	    beg = src;
X	    while (*src && *src != ' ' && *src != ',') {
X		if (*src == '.')
X		    dot = src;
X		else if (*src == '@')
X		    at = src;
X		if (--destsize <= 0)
X		    break;
X		*dest++ = *src++;
X	    }
X	    if (destsize <= 0)
X		break;
X	    if (dot && !at) {
X		int len;
X
X		*dest = *dot++ = '\0';
X		sprintf(tmpbuf,"%s@%s.UUCP",dot,beg);
X		len = strlen(tmpbuf);
X		if (destsize > len) {
X		    strcpy(dest,tmpbuf);
X		    dest = dest + len;
X		    destsize -= len;
X		}
X	    }
X	    if (--destsize <= 0)
X		break;
X	    *dest++ = '>';
X	}
X	else {
X	    while (*src && --destsize > 0 && (*dest++ = *src++) != '>') ;
X	    if (destsize <= 0)
X		break;
X	}
X	while (*src == ' ' || *src == '\t' || *src == '\n' || *src == ',')
X	    src++;
X	if (*src && --destsize > 0)
X	    *dest++ = ' ';
X    }
X    *dest = '\0';
X} 
X
X/* get the person's real name from /etc/passwd */
X/* (string is overwritten, so it must be copied) */
X
Xchar *
Xgetrealname(uid)
Xlong uid;
X{
X    char *s, *c;
X
X#ifdef PASSNAMES
X#ifdef HAS_GETPWENT
X#ifdef notdef
X    struct passwd *getpwuid _((uid_t));
X#endif
X    struct passwd *pwd = getpwuid(uid);
X
X    if (!pwd)
X	return nullstr;
X
X    s = pwd->pw_gecos;
X#else
X    char tmpbuf[512];
X    int i;
X
X    getpw(uid, tmpbuf);
X    for (s=tmpbuf, i=GCOSFIELD-1; i; i--) {
X	if (s)
X	    s = index(s,':')+1;
X    }
X    if (!s)
X	return nullstr;
X    cpytill(tmpbuf,s,':');
X    s = tmpbuf;
X#endif
X#ifdef BERKNAMES
X#ifdef BERKJUNK
X    while (*s && !isalnum(*s) && *s != '&') s++;
X#endif
X    if ((c = index(s, ',')) != Nullch)
X	*c = '\0';
X    if ((c = index(s, ';')) != Nullch)
X	*c = '\0';
X    s = cpytill(buf,s,'&');
X    if (*s == '&') {			/* whoever thought this one up was */
X	c = buf + strlen(buf);		/* in the middle of the night */
X	strcat(c,loginName);		/* before the morning after */
X	strcat(c,s+1);
X	if (islower(*c))
X	    *c = toupper(*c);		/* gack and double gack */
X    }
X#else
X    if ((c = index(s, '(')) != Nullch)
X	*c = '\0';
X    if ((c = index(s, '-')) != Nullch)
X	s = c;
X    strcpy(buf,s);
X#endif
X#ifdef HAS_GETPWENT
X    endpwent();
X#endif
X    return buf;				/* return something static */
X#else
X    if ((tmpfp=fopen(filexp(FULLNAMEFILE),"r")) != Nullfp) {
X	fgets(buf,sizeof buf,tmpfp);
X	fclose(tmpfp);
X	buf[strlen(buf)-1] = '\0';
X	return buf;
X    }
X    return "PUT YOUR NAME HERE";
X#endif
X}
X
Xstatic void
Xabort_interp()
X{
X    fputs("\n% interp buffer overflow!\n",stdout) FLUSH;
X    sig_catcher(0);
X}
X
X
END_OF_FILE
if test 28089 -ne `wc -c <'intrp.c'`; then
    echo shar: \"'intrp.c'\" unpacked with wrong size!
fi
# end of 'intrp.c'
fi
if test -f 'term.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'term.c'\"
else
echo shar: Extracting \"'term.c'\" \(28395 characters\)
sed "s/^X//" >'term.c' <<'END_OF_FILE'
X/* $Id: term.c,v 3.0 1992/02/01 03:09:32 davison Trn $
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "util.h"
X#include "final.h"
X#include "help.h"
X#include "cache.h"
X#include "intrp.h"
X#include "INTERN.h"
X#include "term.h"
X
X#ifdef u3b2
X#undef TIOCGWINSZ
X#endif
X
Xchar ERASECH;		/* rubout character */
Xchar KILLCH;		/* line delete character */
Xchar tcarea[TCSIZE];	/* area for "compiled" termcap strings */
X
Xint upcost;
X
X/* guarantee capability pointer != Nullch */
X/* (I believe terminfo will ignore the &tmpaddr argument.) */
X
Xchar *tgetstr();
X#define Tgetstr(key) ((tmpstr = tgetstr(key,&tmpaddr)) ? tmpstr : nullstr)
X
Xstruct keymap {
X    char km_type[128];
X    union km_union {
X	struct keymap *km_km;
X	char *km_str;
X    } km_ptr[128];
X};
X
X#define KM_NOTHIN 0
X#define KM_STRING 1
X#define KM_KEYMAP 2
X#define KM_BOGUS 3
X
X#define KM_TMASK 3
X#define KM_GSHIFT 4
X#define KM_GMASK 7
X
Xtypedef struct keymap KEYMAP;
X
XKEYMAP *topmap INIT(Null(KEYMAP*));
X
Xvoid mac_init();
XKEYMAP *newkeymap();
Xvoid show_keymap();
X
Xvoid line_col_calcs();
X
X/* terminal initialization */
X
Xvoid
Xterm_init()
X{
X    savetty();				/* remember current tty state */
X
X#ifdef I_TERMIO
X    outspeed = _tty.c_cflag & CBAUD;	/* for tputs() */
X    ERASECH = _tty.c_cc[VERASE];	/* for finish_command() */
X    KILLCH = _tty.c_cc[VKILL];		/* for finish_command() */
X    if (GT = ((_tty.c_oflag & TABDLY) != TAB3))
X	/* we have tabs, so that's OK */;
X    else
X	_tty.c_oflag &= ~TAB3;	/* turn off kernel tabbing -- done in rn */
X#else /* !I_TERMIO */
X# ifdef I_TERMIOS
X    outspeed = cfgetospeed(&_tty);	/* for tputs() (output) */
X    ERASECH = _tty.c_cc[VERASE];	/* for finish_command() */
X    KILLCH = _tty.c_cc[VKILL];		/* for finish_command() */
X#if 0
X    _tty.c_oflag &= ~OXTABS;	/* turn off kernel tabbing-done in rn */
X#endif
X# else /* !I_TERMIOS */
X    outspeed = _tty.sg_ospeed;		/* for tputs() */
X    ERASECH = _tty.sg_erase;		/* for finish_command() */
X    KILLCH = _tty.sg_kill;		/* for finish_command() */
X    if (GT = ((_tty.sg_flags & XTABS) != XTABS))
X	/* we have tabs, so that's OK */;
X    else
X	_tty.sg_flags &= ~XTABS;
X# endif /* I_TERMIOS */
X#endif /* I_TERMIO */
X
X    /* The following could be a table but I can't be sure that there isn't */
X    /* some degree of sparsity out there in the world. */
X
X    switch (outspeed) {			/* 1 second of padding */
X#ifdef BEXTA
X        case BEXTA:  just_a_sec = 1920; break;
X#else
X#ifdef B19200
X        case B19200: just_a_sec = 1920; break;
X#endif
X#endif
X        case B9600:  just_a_sec =  960; break;
X        case B4800:  just_a_sec =  480; break;
X        case B2400:  just_a_sec =  240; break;
X        case B1800:  just_a_sec =  180; break;
X        case B1200:  just_a_sec =  120; break;
X        case B600:   just_a_sec =   60; break;
X	case B300:   just_a_sec =   30; break;
X	/* do I really have to type the rest of this??? */
X        case B200:   just_a_sec =   20; break;
X        case B150:   just_a_sec =   15; break;
X        case B134:   just_a_sec =   13; break;
X        case B110:   just_a_sec =   11; break;
X        case B75:    just_a_sec =    8; break;
X        case B50:    just_a_sec =    5; break;
X        default:     just_a_sec =  960; break;
X					/* if we are running detached I */
X    }					/*  don't want to know about it! */
X}
X
X/* set terminal characteristics */
X
Xvoid
Xterm_set(tcbuf)
Xchar *tcbuf;		/* temp area for "uncompiled" termcap entry */
X{
X    char *tmpaddr;			/* must not be register */
X    register char *tmpstr;
X    char *s;
X    int status;
X#ifdef TIOCGWINSZ
X    struct winsize winsize;
X#endif
X
X#ifdef PENDING
X#if ! defined (FIONREAD) && ! defined (HAS_RDCHK)
X    /* do no delay reads on something that always gets closed on exit */
X
X    devtty = open("/dev/tty",0);
X    if (devtty < 0) {
X	printf(cantopen,"/dev/tty") FLUSH;
X	finalize(1);
X    }
X    fcntl(devtty,F_SETFL,O_NDELAY);
X#endif
X#endif
X    
X    /* get all that good termcap stuff */
X
X#ifdef HAS_TERMLIB
X    status = tgetent(tcbuf,getenv("TERM"));	/* get termcap entry */
X    if (status < 1) {
X#ifdef VERBOSE
X	printf("No termcap %s found.\n", status ? "file" : "entry") FLUSH;
X#else
X	fputs("Termcap botch\n",stdout) FLUSH;
X#endif
X	finalize(1);
X    }
X    tmpaddr = tcarea;			/* set up strange tgetstr pointer */
X    s = Tgetstr("pc");			/* get pad character */
X    PC = *s;				/* get it where tputs wants it */
X    if (!tgetflag("bs")) {		/* is backspace not used? */
X	BC = Tgetstr("bc");		/* find out what is */
X	if (BC == nullstr) 		/* terminfo grok's 'bs' but not 'bc' */
X	    BC = Tgetstr("le");
X    } else
X	BC = "\b";			/* make a backspace handy */
X    UP = Tgetstr("up");			/* move up a line */
X    if (!*UP)				/* no UP string? */
X	marking = 0;			/* disable any marking */
X    if (muck_up_clear)			/* this is for weird HPs */
X	CL = "\n\n\n\n";
X    else
X	CL = Tgetstr("cl");		/* get clear string */
X    CE = Tgetstr("ce");			/* clear to end of line string */
X    TI = Tgetstr("ti");			/* initialize display */
X    TE = Tgetstr("te");			/* reset display */
X    HO = Tgetstr("ho");			/* home cursor if no CM */
X    CM = Tgetstr("cm");			/* cursor motion */
X    if (*CM || *HO)
X	can_home = TRUE;
X#ifdef CLEAREOL
X    CD = Tgetstr("cd");			/* clear to end of display */
X    if (!*CE || !*CD || !can_home)	/* can we CE, CD, and home? */
X	can_home_clear = FALSE;		/*  no, so disable use of clear eol */
X    if (!*CE)
X	CE = CD;
X#endif /* CLEAREOL */
X    upcost = strlen(UP);
X    SO = Tgetstr("so");			/* begin standout */
X    SE = Tgetstr("se");			/* end standout */
X    if ((SG = tgetnum("sg"))<0)
X	SG = 0;				/* blanks left by SG, SE */
X    US = Tgetstr("us");			/* start underline */
X    UE = Tgetstr("ue");			/* end underline */
X    if ((UG = tgetnum("ug"))<0)
X	UG = 0;				/* blanks left by US, UE */
X    if (*US)
X	UC = nullstr;			/* UC must not be NULL */
X    else
X	UC = Tgetstr("uc");		/* underline a character */
X    if (!*US && !*UC) {			/* no underline mode? */
X	US = SO;			/* substitute standout mode */
X	UE = SE;
X	UG = SG;
X    }
X    LINES = tgetnum("li");		/* lines per page */
X    COLS = tgetnum("co");		/* columns on page */
X
X#ifdef TIOCGWINSZ
X    { struct winsize ws;
X	if (ioctl(0, TIOCGWINSZ, &ws) >= 0 && ws.ws_row > 0 && ws.ws_col > 0) {
X	    LINES = ws.ws_row;
X	    COLS = ws.ws_col;
X	}
X    }
X#endif
X	
X    AM = tgetflag("am");		/* terminal wraps automatically? */
X    XN = tgetflag("xn");		/* then eats next newline? */
X    VB = Tgetstr("vb");
X    if (!*VB)
X	VB = "\007";
X    CR = Tgetstr("cr");
X    if (!*CR) {
X	if (tgetflag("nc") && *UP) {
X	    CR = safemalloc((MEM_SIZE)strlen(UP)+2);
X	    sprintf(CR,"%s\r",UP);
X	}
X	else
X	    CR = "\r";
X    }
X#ifdef TIOCGWINSZ
X	if (ioctl(1, TIOCGWINSZ, &winsize) >= 0) {
X		if (winsize.ws_row > 0)
X		    LINES = winsize.ws_row;
X		if (winsize.ws_col > 0)
X		    COLS = winsize.ws_col;
X	}
X#endif
X#else
X    ??????				/* Roll your own... */
X#endif
X    termlib_init();
X    line_col_calcs();
X    noecho();				/* turn off echo */
X    crmode();				/* enter cbreak mode */
X
X    mac_init(tcbuf);
X}
X
Xvoid
Xset_macro(seq,def)
Xchar *seq;	/* input sequence of keys */
Xchar *def;	/* definition */
X{
X    mac_line(def,seq,0);
X    /* check for common (?) brain damage: ku/kd/etc sequence may be the
X     * cursor move sequence instead of the input sequence.
X     * (This happens on the local xterm definitions.)
X     * Try to recognize and adjust for this case.
X     */
X    if (seq[0] == '\033' && seq[1] == '[' && seq[2]) {
X	char lbuf[LBUFLEN];	/* copy of possibly non-writable string */
X	strcpy(lbuf,seq);
X	lbuf[1] = 'O';
X	mac_line(def,lbuf,0);
X    }
X    if (seq[0] == '\033' && seq[1] == 'O' && seq[2]) {
X	char lbuf[LBUFLEN];	/* copy of possibly non-writable string */
X	strcpy(lbuf,seq);
X	lbuf[1] = '[';
X	mac_line(def,lbuf,0);
X    }
X}
X
X/* Turn the arrow keys into macros that do some basic trn functions.
X** Code provided by Clifford Adams.
X*/
Xvoid
Xarrow_macros(tmpbuf)
Xchar *tmpbuf;
X{
X    char lbuf[256];			/* should be long enough */
X    char *tmpaddr = tmpbuf;
X    register char *tmpstr;
X
X    /* If arrows are defined as single keys, we probably don't
X     * want to redefine them.  (The tvi912c defines kl as ^H)
X     */
X    strcpy(lbuf,Tgetstr("ku"));		/* up */
X    /* '(' at article or pager, 'p' otherwise */
X    if (strlen(lbuf)>1)
X	set_macro(lbuf,"%(%m=[ap]?\\(:p)");
X
X    strcpy(lbuf,Tgetstr("kd"));		/* down */
X    /* ')' at article or pager, 'n' otherwise */
X    if (strlen(lbuf)>1)
X	set_macro(lbuf,"%(%m=[ap]?\\):n)");
X
X    strcpy(lbuf,Tgetstr("kl"));		/* left */
X    /* '[' at article or pager, '<' otherwise */
X    if (strlen(lbuf)>1)
X	set_macro(lbuf,"%(%m=[ap]?\\[:<)");
X
X    strcpy(lbuf,Tgetstr("kr"));		/* right */
X    /* CR at newsgroups, ']' at article or pager, '>' otherwise */
X    if (strlen(lbuf)>1)
X	set_macro(lbuf,"%(%m=n?^j:%(%m=[ap]?\\]:>))");
X}
X
Xvoid
Xmac_init(tcbuf)
Xchar *tcbuf;
X{
X    char tmpbuf[1024];
X
X    if (auto_arrow_macros)
X	arrow_macros(tmpbuf);
X    if (use_threads)
X	tmpfp = fopen(filexp(getval("TRNMACRO",TRNMACRO)),"r");
X    else
X	tmpfp = Nullfp;
X    if (!tmpfp)
X	tmpfp = fopen(filexp(getval("RNMACRO",RNMACRO)),"r");
X    if (tmpfp) {
X	while (fgets(tcbuf,1024,tmpfp) != Nullch) {
X	    mac_line(tcbuf,tmpbuf,(sizeof tmpbuf));
X	}
X	fclose(tmpfp);
X    }
X}
X
Xvoid
Xmac_line(line,tmpbuf,tbsize)
Xchar *line;
Xchar *tmpbuf;
Xint tbsize;
X{
X    register char *s, *m;
X    register KEYMAP *curmap;
X    register int ch;
X    register int garbage = 0;
X    static char override[] = "\nkeymap overrides string\n";
X
X    if (topmap == Null(KEYMAP*))
X	topmap = newkeymap();
X    if (*line == '#' || *line == '\n')
X	return;
X    if (line[ch = strlen(line)-1] == '\n')
X	line[ch] = '\0';
X    /* A 0 length signifies we already parsed the macro into tmpbuf,
X    ** so line is just the definition. */
X    if (tbsize)
X	m = dointerp(tmpbuf,tbsize,line," \t");
X    else
X	m = line;
X    if (!*m)
X	return;
X    while (*m == ' ' || *m == '\t') m++;
X    for (s=tmpbuf,curmap=topmap; *s; s++) {
X	ch = *s & 0177;
X	if (s[1] == '+' && isdigit(s[2])) {
X	    s += 2;
X	    garbage = (*s & KM_GMASK) << KM_GSHIFT;
X	}
X	else
X	    garbage = 0;
X	if (s[1]) {
X	    if ((curmap->km_type[ch] & KM_TMASK) == KM_STRING) {
X		if (tbsize)
X		    fputs(override,stdout) FLUSH;
X		free(curmap->km_ptr[ch].km_str);
X		curmap->km_ptr[ch].km_str = Nullch;
X	    }
X	    curmap->km_type[ch] = KM_KEYMAP + garbage;
X	    if (curmap->km_ptr[ch].km_km == Null(KEYMAP*))
X		curmap->km_ptr[ch].km_km = newkeymap();
X	    curmap = curmap->km_ptr[ch].km_km;
X	}
X	else {
X	    if (tbsize && (curmap->km_type[ch] & KM_TMASK) == KM_KEYMAP)
X		fputs(override,stdout) FLUSH;
X	    else {
X		curmap->km_type[ch] = KM_STRING + garbage;
X		curmap->km_ptr[ch].km_str = savestr(m);
X	    }
X	}
X    }
X}
X
XKEYMAP*
Xnewkeymap()
X{
X    register int i;
X    register KEYMAP *map;
X
X#ifndef lint
X    map = (KEYMAP*)safemalloc(sizeof(KEYMAP));
X#else
X    map = Null(KEYMAP*);
X#endif /* lint */
X    for (i=127; i>=0; --i) {
X	map->km_ptr[i].km_km = Null(KEYMAP*);
X	map->km_type[i] = KM_NOTHIN;
X    }
X    return map;
X}
X
Xvoid
Xshow_macros()
X{
X    char prebuf[64];
X
X    if (topmap != Null(KEYMAP*)) {
X	print_lines("Macros:\n",STANDOUT);
X	*prebuf = '\0';
X	show_keymap(topmap,prebuf);
X    }
X    else {
X	print_lines("No macros defined.\n", NOMARKING);
X    }
X}
X
Xvoid
Xshow_keymap(curmap,prefix)
Xregister KEYMAP *curmap;
Xchar *prefix;
X{
X    register int i;
X    register char *next = prefix + strlen(prefix);
X    register int kt;
X
X    for (i=0; i<128; i++) {
X	if (kt = curmap->km_type[i]) {
X	    if (i < ' ')
X		sprintf(next,"^%c",i+64);
X	    else if (i == ' ')
X		strcpy(next,"\\040");
X	    else if (i == 127)
X		strcpy(next,"^?");
X	    else
X		sprintf(next,"%c",i);
X	    if ((kt >> KM_GSHIFT) & KM_GMASK) {
X		sprintf(cmd_buf,"+%d", (kt >> KM_GSHIFT) & KM_GMASK);
X		strcat(next,cmd_buf);
X	    }
X	    switch (kt & KM_TMASK) {
X	    case KM_NOTHIN:
X		sprintf(cmd_buf,"%s	%c\n",prefix,i);
X		print_lines(cmd_buf,NOMARKING);
X		break;
X	    case KM_KEYMAP:
X		show_keymap(curmap->km_ptr[(char)i].km_km, prefix);
X		break;
X	    case KM_STRING:
X		sprintf(cmd_buf,"%s	%s\n",prefix,curmap->km_ptr[i].km_str);
X		print_lines(cmd_buf,NOMARKING);
X		break;
X	    case KM_BOGUS:
X		sprintf(cmd_buf,"%s	BOGUS\n",prefix);
X		print_lines(cmd_buf,STANDOUT);
X		break;
X	    }
X	}
X    }
X}
X
X/* routine to pass to tputs */
X
Xchar
Xputchr(ch)
Xregister char_int ch;
X{
X    putchar(ch);
X#ifdef lint
X    ch = Null(char);
X    ch = ch;
X#endif
X    return((char) 0);
X}
X
X/* input the 2nd and succeeding characters of a multi-character command */
X/* returns TRUE if command finished, FALSE if they rubbed out first character */
X
Xint buflimit = LBUFLEN;
X
Xbool
Xfinish_command(donewline)
Xint donewline;
X{
X    register char *s;
X    register bool quoteone = FALSE;
X
X    s = buf;
X    if (s[1] != FINISHCMD)		/* someone faking up a command? */
X	return TRUE;
X    do {
X      top:
X	if (*(unsigned char *)s < ' ') {
X	    putchar('^');
X	    putchar(*s | 64);
X	}
X	else if (*s == '\177') {
X	    putchar('^');
X	    putchar('?');
X	}
X	else
X	    putchar(*s);		/* echo previous character */
X	s++;
X	if (s - buf == buflimit)
X	    break;
Xre_read:
X	fflush(stdout);
X	getcmd(s);
X	if (quoteone) {
X	    quoteone = FALSE;
X	    continue;
X	}
X	if (errno || *s == '\f') {
X	    *s = Ctl('r');		/* force rewrite on CONT */
X	}
X	if (*s == '\033') {		/* substitution desired? */
X#ifdef ESCSUBS
X	    char tmpbuf[4], *cpybuf;
X
X	    tmpbuf[0] = '%';
X	    read_tty(&tmpbuf[1],1);
X#ifdef RAWONLY
X	    tmpbuf[1] &= 0177;
X#endif
X	    tmpbuf[2] = '\0';
X	    if (tmpbuf[1] == 'h') {
X		(void) help_subs();
X		*s = '\0';
X		reprint();
X		goto re_read;
X	    }
X	    else if (tmpbuf[1] == '\033') {
X		*s = '\0';
X		cpybuf = savestr(buf);
X		interp(buf, (sizeof buf), cpybuf);
X		free(cpybuf);
X		s = buf + strlen(buf);
X		reprint();
X		goto re_read;
X	    }
X	    else {
X		interp(s,(sizeof buf) - (s-buf),tmpbuf);
X		fputs(s,stdout);
X		s += strlen(s);
X	    }
X	    goto re_read;
X#else
X	    notincl("^[");
X	    *s = '\0';
X	    reprint();
X	    goto re_read;
X#endif
X	}
X	else if (*s == ERASECH) {	/* they want to rubout a char? */
X	    rubout();
X	    s--;			/* discount the char rubbed out */
X	    if (*(unsigned char *)s < ' ' || *s == '\177')
X		rubout();
X	    if (s == buf) {		/* entire string gone? */
X		fflush(stdout);		/* return to single char command mode */
X		return FALSE;
X	    }
X	    else
X		goto re_read;
X	}
X	else if (*s == KILLCH) {	/* wipe out the whole line? */
X	    while (s-- != buf) {	/* emulate that many ERASEs */
X		rubout();
X		if (*(unsigned char *)s < ' ' || *s == '\177')
X		    rubout();
X	    }
X	    fflush(stdout);
X	    return FALSE;		/* return to single char mode */
X	}
X#ifdef WORDERASE
X	else if (*s == Ctl('w')) {	/* wipe out one word? */
X	    *s-- = ' ';
X	    while (!isspace(*s) || isspace(s[1])) {
X		rubout();
X		if (s-- == buf) {
X		    fflush(stdout);
X		    return FALSE;	/* return to single char mode */
X		}
X		if (*(unsigned char *)s < ' ' || *s == '\177')
X		    rubout();
X	    }
X	    s++;
X	    goto re_read;
X	}
X#endif
X	else if (*s == Ctl('r')) {
X	    *s = '\0';
X	    reprint();
X	    goto re_read;
X	}
X	else if (*s == Ctl('v')) {
X	    putchar('^');
X	    backspace();
X	    fflush(stdout);
X	    getcmd(s);
X	    goto top;
X	}
X	else if (*s == '\\') {
X	    quoteone = TRUE;
X	}
X#ifdef cray
X    } while (*s != '\r');		/* till a newline (not echoed) */
X#else
X    } while (*s != '\n');		/* till a newline (not echoed) */
X#endif
X    *s = '\0';				/* terminate the string nicely */
X    if (donewline)
X	putchar('\n') FLUSH;
X    return TRUE;			/* say we succeeded */
X}
X
Xbool
Xfinish_dblchar()
X{
X    bool ret;
X    buflimit = 2;
X    ret = finish_command(FALSE);
X    buflimit = LBUFLEN;
X    return ret;
X}
X
X/* discard any characters typed ahead */
X
Xvoid
Xeat_typeahead()
X{
X    if (!typeahead && nextin==nextout) { /* cancel only keyboard stuff */
X#ifdef PENDING
X	while (input_pending())
X	    read_tty(buf,sizeof(buf));
X#else /* this is probably v7 */
X# ifdef I_SGTTY
X	ioctl(_tty_ch,TIOCSETP,&_tty);
X# else
X#  ifdef I_TERMIO
X	ioctl(_tty_ch,TCSETAW,&_tty);
X#  else
X	tcsetattr(_tty_ch,TCSAFLUSH,&_tty);
X#  endif
X# endif
X#endif
X    }
X}
X
Xvoid
Xsave_typeahead(buf, len)
Xchar *buf;
Xint len;
X{
X    int cnt;
X
X    while (input_pending()) {
X	cnt = read_tty(buf, len);
X	buf += cnt;
X	len -= cnt;
X    }
X    *buf = '\0';
X}
X
Xvoid
Xsettle_down()
X{
X    dingaling();
X    fflush(stdout);
X    /*sleep(1);*/
X    nextout = nextin;			/* empty circlebuf */
X    eat_typeahead();
X}
X
X/* read a character from the terminal, with multi-character pushback */
X
Xint
Xread_tty(addr,size)
Xchar *addr;
Xint size;
X{
X    if (nextout != nextin) {
X	*addr = circlebuf[nextout++];
X	nextout %= PUSHSIZE;
X	return 1;
X    }
X    else {
X	size = read(0,addr,size);
X#ifdef RAWONLY
X	*addr &= 0177;
X#endif
X	return size;
X    }
X}
X
X#ifdef PENDING
X# if !defined (FIONREAD) && !defined (HAS_RDCHK)
Xint
Xcircfill()
X{
X    register int Howmany;
X
X    errno = 0;
X    Howmany = read(devtty,circlebuf+nextin,1);
X
X    if (Howmany < 0 && (errno == EAGAIN || errno == EINTR))
X	Howmany = 0;
X    if (Howmany) {
X	nextin += Howmany;
X	nextin %= PUSHSIZE;
X    }
X    return Howmany;
X}
X# endif /* PENDING */
X#endif /* FIONREAD */
X
Xvoid
Xpushchar(c)
Xchar_int c;
X{
X    nextout--;
X    if (nextout < 0)
X	nextout = PUSHSIZE - 1;
X    if (nextout == nextin) {
X	fputs("\npushback buffer overflow\n",stdout) FLUSH;
X	sig_catcher(0);
X    }
X    circlebuf[nextout] = c;
X}
X
X/* print an underlined string, one way or another */
X
Xvoid
Xunderprint(s)
Xregister char *s;
X{
X    assert(UC);
X    if (*UC) {		/* char by char underline? */
X	while (*s) {
X	    if (*(unsigned char *)s < ' ') {
X		putchar('^');
X		backspace();/* back up over it */
X		underchar();/* and do the underline */
X		putchar(*s+64);
X		backspace();/* back up over it */
X		underchar();/* and do the underline */
X	    }
X	    else {
X		putchar(*s);
X		backspace();/* back up over it */
X		underchar();/* and do the underline */
X	    }
X	    s++;
X	}
X    }
X    else {		/* start and stop underline */
X	underline();	/* start underlining */
X	while (*s) {
X	    if (*(unsigned char *)s < ' ') {
X		putchar('^');
X		putchar(*s+64);
X	    }
X	    else
X		putchar(*s);
X	    s++;
X	}
X	un_underline();	/* stop underlining */
X    }
X}
X
X/* keep screen from flashing strangely on magic cookie terminals */
X
X#ifdef NOFIREWORKS
Xvoid
Xno_sofire()
X{
X    if (*UP && *SE) {		/* should we disable fireworks? */
X	putchar('\n');
X	un_standout();
X	up_line();
X	carriage_return();
X    }
X}
X
Xvoid
Xno_ulfire()
X{
X    if (*UP && *US) {		/* should we disable fireworks? */
X	putchar('\n');
X	un_underline();
X	up_line();
X	carriage_return();
X    }
X}
X#endif
X
X/* get a character into a buffer */
X
Xvoid
Xgetcmd(whatbuf)
Xregister char *whatbuf;
X{
X    register KEYMAP *curmap;
X    register int i;
X    bool no_macros; 
X    int times = 0;			/* loop detector */
X    char scrchar;
X
Xtryagain:
X    curmap = topmap;
X    no_macros = (whatbuf != buf && nextin == nextout); 
X    for (;;) {
X	int_count = 0;
X	errno = 0;
X	if (read_tty(whatbuf,1) < 0){
X	    if (!errno)
X	        errno = EINTR;
X	    if (errno == EINTR)
X		return;
X	    perror(readerr);
X	    sig_catcher(0);
X	}
X	lastchar = *whatbuf;
X	if (*whatbuf & 0200 || no_macros) {
X	    *whatbuf &= 0177;
X	    goto got_canonical;
X	}
X	if (curmap == Null(KEYMAP*))
X	    goto got_canonical;
X	for (i = (curmap->km_type[*whatbuf] >> KM_GSHIFT) & KM_GMASK; i; --i){
X	    read_tty(&scrchar,1);
X	}
X	switch (curmap->km_type[*whatbuf] & KM_TMASK) {
X	case KM_NOTHIN:			/* no entry? */
X	    if (curmap == topmap)	/* unmapped canonical */
X		goto got_canonical;
X	    settle_down();
X	    goto tryagain;
X	case KM_KEYMAP:			/* another keymap? */
X	    curmap = curmap->km_ptr[*whatbuf].km_km;
X	    assert(curmap != Null(KEYMAP*));
X	    break;
X	case KM_STRING:			/* a string? */
X	    pushstring(curmap->km_ptr[*whatbuf].km_str,0200);
X	    if (++times > 20) {		/* loop? */
X		fputs("\nmacro loop?\n",stdout);
X		settle_down();
X	    }
X	    no_macros = FALSE;
X	    goto tryagain;
X	}
X    }
X
Xgot_canonical:
X#ifdef I_SGTTY
X    if (*whatbuf == '\r')
X	*whatbuf = '\n';
X#endif
X    if (whatbuf == buf)
X	whatbuf[1] = FINISHCMD;		/* tell finish_command to work */
X}
X
Xvoid
Xpushstring(str,bits)
Xchar *str;
Xchar_int bits;
X{
X    register int i;
X    char tmpbuf[PUSHSIZE];
X    register char *s = tmpbuf;
X
X    assert(str != Nullch);
X    interp(tmpbuf,PUSHSIZE,str);
X    for (i = strlen(s)-1; i >= 0; --i)
X	pushchar(s[i] ^ bits);
X}
X
Xint
Xget_anything()
X{
X    char tmpbuf[2];
X
Xreask_anything:
X    unflush_output();			/* disable any ^O in effect */
X    standout();
X#ifdef VERBOSE
X    IF(verbose)
X	fputs("[Type space to continue] ",stdout);
X    ELSE
X#endif
X#ifdef TERSE
X	fputs("[MORE] ",stdout);
X#endif
X    un_standout();
X    fflush(stdout);
X    eat_typeahead();
X    if (int_count) {
X	return -1;
X    }
X    cache_until_key();
X    getcmd(tmpbuf);
X    if (errno || *tmpbuf == '\f') {
X	putchar('\n') FLUSH;		/* if return from stop signal */
X	goto reask_anything;		/* give them a prompt again */
X    }
X    if (*tmpbuf == 'h') {
X#ifdef VERBOSE
X	IF(verbose)
X	    fputs("\nType q to quit or space to continue.\n",stdout) FLUSH;
X	ELSE
X#endif
X#ifdef TERSE
X	    fputs("\nq to quit, space to continue.\n",stdout) FLUSH;
X#endif
X	goto reask_anything;
X    }
X    else if (*tmpbuf != ' ' && *tmpbuf != '\n') {
X	carriage_return();
X	erase_eol();	/* erase the prompt */
X	carriage_return();
X	return *tmpbuf == 'q' ? -1 : *tmpbuf;
X    }
X    if (*tmpbuf == '\n') {
X	page_line = LINES - 1;
X	carriage_return();
X	erase_eol();
X	carriage_return();
X    }
X    else {
X	page_line = 1;
X	if (erase_screen)		/* -e? */
X	    clear();			/* clear screen */
X	else {
X	    carriage_return();
X	    erase_eol();		/* erase the prompt */
X	    carriage_return();
X	}
X    }
X    return 0;
X}
X
Xint
Xpause_getcmd()
X{
X    unflush_output();			/* disable any ^O in effect */
X    standout();
X#ifdef VERBOSE
X    IF(verbose)
X	fputs("[Type space or a command] ",stdout);
X    ELSE
X#endif
X#ifdef TERSE
X	fputs("[CMD] ",stdout);
X#endif
X    un_standout();
X    fflush(stdout);
X    eat_typeahead();
X    if (int_count)
X	return -1;
X    cache_until_key();
X    getcmd(buf);
X    if (errno || *buf == '\f')
X	return 0;			/* if return from stop signal */
X    else if (*buf != ' ') {
X	carriage_return();
X	erase_eol();	/* erase the prompt */
X	carriage_return();
X	return *buf;
X    }
X    return 0;
X}
X
Xvoid
Xin_char(prompt, newmode)
Xchar *prompt;
Xchar_int newmode;
X{
X    char oldmode = mode;
X
Xreask_in_char:
X    unflush_output();			/* disable any ^O in effect */
X    fputs(prompt,stdout);
X    fflush(stdout);
X    eat_typeahead();
X    mode = newmode;
X    getcmd(buf);
X    if (errno || *buf == '\f') {
X	putchar('\n') FLUSH;		/* if return from stop signal */
X	goto reask_in_char;		/* give them a prompt again */
X    }
X    mode = oldmode;
X}
X
Xvoid
Xin_answer(prompt, newmode)
Xchar *prompt;
Xchar_int newmode;
X{
X    char oldmode = mode;
X
Xreask_in_answer:
X    unflush_output();			/* disable any ^O in effect */
X    fputs(prompt,stdout);
X    fflush(stdout);
X    eat_typeahead();
X    mode = newmode;
Xreinp_in_answer:
X    getcmd(buf);
X    if (errno || *buf == '\f') {
X	putchar('\n') FLUSH;		/* if return from stop signal */
X	goto reask_in_answer;		/* give them a prompt again */
X    }
X    if (*buf != ' ' && *buf != '\n') 
X	if (!finish_command(TRUE))
X	    goto reinp_in_answer;
X    mode = oldmode;
X}
X
Xint
Xprint_lines(what_to_print,hilite)
Xchar *what_to_print;
Xint hilite;
X{
X    register char *s;
X    register int i;
X
X    if (page_line < 0)			/* they do not want to see this? */
X	return -1;
X    for (s=what_to_print; *s; ) {
X	if (page_line >= LINES || int_count) {
X	    if (i = -1, int_count || (i = get_anything())) {
X		page_line = -1;		/* disable further print_lines */
X		return i;
X	    }
X	}
X	page_line++;
X	if (hilite == STANDOUT) {
X#ifdef NOFIREWORKS
X	    if (erase_screen)
X		no_sofire();
X#endif
X	    standout();
X	}
X	else if (hilite == UNDERLINE) {
X#ifdef NOFIREWORKS
X	    if (erase_screen)
X		no_ulfire();
X#endif
X	    underline();
X	}
X	for (i=0; i<COLS; i++) {
X	    if (!*s)
X		break;
X	    if (*(unsigned char *)s >= ' ')
X		putchar(*s);
X	    else if (*s == '\t') {
X		putchar(*s);
X		i = ((i+8) & ~7) - 1; 
X	    }
X	    else if (*s == '\n') {
X		i = 32000;
X	    }
X	    else {
X		i++;
X		putchar('^');
X		putchar(*s + 64);
X	    }
X	    s++;
X	}
X	if (i) {
X	    if (hilite == STANDOUT)
X		un_standout();
X	    else if (hilite == UNDERLINE)
X		un_underline();
X	    if (AM && i == COLS)
X		fflush(stdout);
X	    else
X		putchar('\n') FLUSH;
X	}
X    }
X    return 0;
X}
X
Xvoid
Xpage_init()
X{
X    page_line = 1;
X    if (erase_screen)
X	clear();
X    else
X	putchar('\n') FLUSH;
X}
X
Xvoid
Xpad(num)
Xint num;
X{
X    register int i;
X
X    for (i = num; i; --i)
X	putchar(PC);
X    fflush(stdout);
X}
X
X/* echo the command just typed */
X
X#ifdef VERIFY
Xvoid
Xprintcmd()
X{
X    if (verify && buf[1] == FINISHCMD) {
X	if (*(unsigned char *)buf < ' ') {
X	    putchar('^');
X	    putchar(*buf | 64);
X	    backspace();
X	    backspace();
X	}
X	else {
X	    putchar(*buf);
X	    backspace();
X	}
X	fflush(stdout);
X    }
X}
X#endif
X
Xvoid
Xrubout()
X{
X    backspace();			/* do the old backspace, */
X    putchar(' ');			/*   space, */
X    backspace();			/*     backspace trick */
X}
X
Xvoid
Xreprint()
X{
X    register char *s;
X
X    fputs("^R\n",stdout) FLUSH;
X    for (s = buf; *s; s++) {
X	if (*(unsigned char *)s < ' ') {
X	    putchar('^');
X	    putchar(*s | 64);
X	}
X	else
X	    putchar(*s);
X    }
X}
X
Xvoid
Xhome_cursor()
X{
X    char *tgoto();
X
X    if (!*HO) {			/* no home sequence? */
X	if (!*CM) {		/* no cursor motion either? */
X	    fputs("\n\n\n", stdout);
X	    return;		/* forget it. */
X	}
X	tputs(tgoto(CM, 0, 0), 1, putchr);	/* go to home via CM */
X	return;
X    }
X    else {			/* we have home sequence */
X	tputs(HO, 1, putchr);	/* home via HO */
X    }
X}
X
Xvoid
Xgoto_line(from,to)	/* assumes caller is already at beginning of line */
Xint from,to;
X{
X    char *tgoto(), *str;
X    int cmcost;
X
X    if (from == to)
X	return;
X    if (*CM && !muck_up_clear)
X	cmcost = strlen(str = tgoto(CM,0,to));
X    else
X	cmcost = 9999;
X    if (to > from) {
X      go_down:
X	if (to - from <= cmcost) {
X	    while(from++ < to)
X		putchar('\n');
X	    return;
X	}
X    } else if(*UP) {
X	if ((from - to) * upcost <= cmcost) {
X	    while(from-- > to)
X		tputs(UP,1,putchr);
X	    return;
X	}
X    } else if (cmcost == 9999) {
X	home_cursor();
X	from = 0;
X	goto go_down;
X    }
X    tputs(str,1,putchr);
X}
X
Xvoid
Xline_col_calcs()
X{
X     if (LINES > 0) {			/* is this a crt? */
X	  if (!initlines || !initlines_specified)
X	       /* no -i or unreasonable value for initlines */
X	       if (outspeed >= B9600) 	/* whole page at >= 9600 baud */
X		    initlines = LINES;
X	       else if (outspeed >= B4800)/* 16 lines at 4800 */
X		    initlines = 16;
X	       else			/* otherwise just header */
X		    initlines = 8;
X     }
X     else {				/* not a crt */
X	  LINES = 30000;		/* so don't page */
X	  CL = "\n\n";			/* put a couple of lines between */
X	  if (!initlines || !initlines_specified)
X	       /* make initlines reasonable */
X	       initlines = 8;
X     }
X     if (COLS <= 0)
X	  COLS = 80;
X}
X
X
X#ifdef SIGWINCH
XSignal_t
Xwinch_catcher(dummy)
Xint dummy;
X{
X    /* Reset signal in case of System V dain bramage */
X    sigset(SIGWINCH, winch_catcher);
X
X    /* Come here if window size change signal received */
X#ifdef TIOCGWINSZ
X    {	struct winsize ws;
X	char lines[10], cols[10];
X	if (ioctl(0, TIOCGWINSZ, &ws) >= 0 && ws.ws_row > 0 && ws.ws_col > 0) {
X	    if (LINES != ws.ws_row || COLS != ws.ws_col) {
X		LINES = ws.ws_row;
X		COLS = ws.ws_col;
X		line_col_calcs();
X		sprintf(lines, "%d", LINES);
X		sprintf(cols, "%d", COLS);
X		export("LINES",lines);
X		export("COLUMNS",cols);
X		if (mode == 't' || mode == 'a' || mode == 'p')
X		    forceme("\f");	/* cause a refresh */
X					/* (defined only if TIOCSTI defined) */
X	    }
X	}
X    }
X#else
X    /* Well, if SIGWINCH is defined, but TIOCGWINSZ isn't, there's    */
X    /* almost certainly something wrong.  Figure it out for yourself, */
X    /* because I don't know how to deal with it :-)                   */
X#endif
X}
X#endif
X
Xvoid
Xtermlib_init()
X{
X#ifdef USETITE
X    if (TI && *TI)
X	tputs(TI,1,putchr);
X#endif
X    return;
X}
X
Xvoid
Xtermlib_reset()
X{
X#ifdef USETITE
X    if (TE && *TE)
X	tputs(TE,1,putchr);
X#endif
X    return;
X}
END_OF_FILE
if test 28395 -ne `wc -c <'term.c'`; then
    echo shar: \"'term.c'\" unpacked with wrong size!
fi
# end of 'term.c'
fi
echo shar: End of archive 9 \(of 12\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 12 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
