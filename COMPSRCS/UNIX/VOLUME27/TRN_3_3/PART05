Newsgroups: comp.sources.unix
From: davison@borland.com (Wayne Davison)
Subject: v27i098: trn-3.3 - threaded newsreader based on RN, V3.3, Part05/12
References: <1.754431075.7231@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: davison@borland.com (Wayne Davison)
Posting-Number: Volume 27, Issue 98
Archive-Name: trn-3.3/part05

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 12)."
# Contents:  NEW config.h.SH dependencies rt-util.c rt-wumpus.c
#   search.c sw.c
# Wrapped by vixie@gw.home.vix.com on Sun Nov 21 01:14:04 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'NEW' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'NEW'\"
else
echo shar: Extracting \"'NEW'\" \(15395 characters\)
sed "s/^X//" >'NEW' <<'END_OF_FILE'
XThis file will aquaint you with the user-visible changes in trn 3.0.
X
XSee the discussion of the -a option and the 't' command (newsgroup selection
Xlevel), and the 'T' command (article level & in kill files) for slight
Xincompatibilities between trn 2.5 and trn 3.0.
X
XChanges from trn 3.2 to trn 3.3:
X
X   o	Newsetup now looks for NEWSLIB/subscriptions for a default list
X	of groups to subscribe the user to.  If the file doesn't exist
X	the NNTP version will attempt to grab it via the LIST SUBSCRIPTIONS
X	command (available in INN and some nntp patches).
X	[HINT:  if you want your subscription file to default to all
X	groups in the active file, link your subscription file to your
X	active file -- trn will strip the info past the first space
X	when it processes the .newsrc.]
X   o	The file newsnews will now default to a simple version update
X	message instead of a welcome-to trn message (which is now provided
X	by the newsetup file when creating a new .newsrc for a user).
X	I still encourage you to install your own custom newsnews
X	when trn is updated (and trn still doesn't install newsnews
X	automatically -- you have to make this decision for your self).
X   o	Redirected and disabled groups (marked by '=' or 'x' in the active
X	file) are now handled better, allowing you to read any remaining
X	articles after a group gets redirected or disabled and warning you
X	to either start using the new group name or that the group will
X	not be receiving any new news.
X   o	Mime support is now prompted for in Configure and your system's
X	display/store commands are remembered.  We also handle a continued
X	Content-Type header correctly now.
X   o	The tick (') interp modifier will generate a tick-quoted string
X	with all ticks inside the string quoted.  For example, %'s might
X	generate (INCLUDING the "'"s)  'Ticks aren\'t a problem.'
X   o	If the environment variable FAST_PNEWS == y Pnews skips the "Are
X	you sure?" question and the "include file" prompt.  You can put
X	-EFAST_PNEWS=y in the global INIT file, if you so desire.
X   o	Various bug fixes.
X
XChanges from trn 3.1 to trn 3.2:
X
X   o	Configure and the include file structure has been improved to
X	install easier on more systems.
X   o	Fixed some non-portable test statements in Pnews.
X   o	Added the -Z option to allow you to turn on/off support for the
X	two different database formats (-Zt, -Zo, -Zot, or +Z).
X   o	Configure now allows you set the default database support to
X	thread files, overview files, both or none.
X   o	Trn and its support scripts handle ~/dirs in the newslib or
X	rnlib better.
X   o	Various bug fixes.
X
XChanges from trn 3.0 to trn 3.1:
X
X   o	Added a new header-searching syntax:  /string/Hheader:cmd.
X	This allows you to match a string on any header that trn
X	knows about and is faster on the NNTP side than full-header
X	matching.  Example:  /: .../Hlines:j  would junk all postings
X	longer than 99 lines.
X   o	Two new commands can be put into a group's kill file: *j
X	(kill all articles from THRU to the end of the group) and *X
X	(kill all unselected articles from THRU to the end of the group).
X   o	Pnews (using artcheck) now checks the active file as well as
X	the newsgroups file for each group on the Newsgroups line.  This
X	lets you know whenever you specify a group that doesn't exist.
X	Also, the NNTP version has been fixed to provide full checking.
X   o	Pnews/Rnmail have been modified to allow you to type either upper
X	or lower case for the response letters, and use "sp*ell" in addition
X	to "c*heck" for the spelling checker ("s*end" is unchanged).
X   o	Pnews/Rnmail each have a pre-edit signature appending option.
X	If you use the file DOTDIR/.news_sig INSTEAD of .signature Pnews
X	will append your signature before you edit the file.  Rnmail uses
X	the file DOTDIR/.mail_sig.  Note also that the names may be
X	customized with the environment variables NEWSSIGNATURE and
X	MAILSIGNATURE, if desired (allowing a per-group signature).
X   o	Added the modifiers '>' and ')' to interpreted strings.  For
X	example:  %>f gives you the address only on the From line,
X	while %)f gives you the real name portion.
X   o	Added the 'O' command (newsgroup level) that works just like 'o'
X	except that it does not visit empty groups.
X   o	The killfile is fully saved before manual editing with Ctrl-K
X	(message-id commands used to be saved only on exit from the group).
X   o	The screen is now refreshed when the window size changes.
X   o	Trn now makes use of stdlib.h, unistd.h (if available) and does a
X	more intelligent inclusion of time.h & sys/time.h (as needed).
X   o	Trn doesn't loop through the current thread if unread articles
X	still exist in it.  Also fixed various problems with '>' & 'P'.
X   o	The 'D' command in the selector no longer jumps back to the top.
X   o	The NNTP version has a different new-article aquisition strategy.
X	Your nntp server must send up-to-date information in response to
X	the GROUP command (INN's nnrpd does) for a group to expand while
X	you're in it.  Also, you can now set the minimum time for trn to
X	wait (see -z) before it refetches the active file at the end of
X	the newsgroups.  The default is 5 minutes.
X   o	Optional metamail support pauses between the headers and the
X	metamail-interpreted article.  Also, the 'v' command displays the
X	raw article without metamail processing.
X   o	Numerous portability changes and bug fixes.
X
XChanges from trn 2.5 to trn 3.0:
X
X   o	Trn is now capable of reading more news database formats.  It
X	currently supports news overview (.overview files), mthreads
X	(.thread files), and direct threading of the articles.  The
X	NNTP version supports the XTHREAD and XOVER NNTP extensions.
X	If you compile trn with support for both formats it will figure
X	out which groups (or which server) has which type of data and
X	act accordingly.
X   o	Mthreads is now a separate package from trn since not everyone
X	will need to use it.  Look for it in the same place you found
X	trn.
X   o	Trn attempts to build some useful default macros for your
X	terminal's arrow keys.  On the article level they move around
X	in the thread; in the selector they change pages (left/right)
X	and switch selections (up/down); on the newsgroup level they
X	move by group (up/down) and enter a group (right).  If you
X	don't like this, turn it off with the +A option.
X   o	There's a new search scope -- the from line.  For example:
X	use /author/f+ to search for and select 'author's articles.
X   o	The thread selector has been extended to be a subject and
X	article selector.  Use the 'S'et selector command to change
X	modes or use '=' to toggle between the article selector and
X	the subject/thread selector (whichever was last in use).
X   o	The selector can now be sorted in a variety of ways:  by date,
X	subject, author, article count (in the subject/thread selector),
X	or a combination of subject and date (in the article selector).
X	The default is date order of the oldest unread article in a thread.
X	Use the 'O'rder command to pick a new one or use 'R' to reverse
X	the sort.  See also the "-O<mode><order>" option to set your
X	favorite mode and order.  You can even put a "&-Oas" command (for
X	example) into a group's kill file to set a per-group default.
X   o	The selector allows you to exclude all the non-selected articles
X	from the display (i.e. narrow it) -- use 'E' to toggle this mode.
X   o	The selector has two new selection commands:  '*' is used to select
X	(or deselect) the current item and all other items with the same
X	subject (useful in the article selector); '#' is used to make an
X	overriding selection that immediately reads the current item
X	ignoring all other selections.
X   o	You can now type 'M' in the selector to mark the current item's
X	articles as read-but-returning and press 'Y' to yank back and
X	select these articles before exiting the group.
X   o	Selections via searches are article-oriented (/subj/+) or
X	thread-/subject-oriented (/subj/++).  The article selector's
X	default command is "+", while the thread/subject selector's is
X	"++".  In other words doing a "/subj" search with no specified
X	command selects whatever type of object you're looking at in the
X	selector.
X   o	If you specify the "-p" option, your postings and any replies to
X	them are auto-selected whenever trn encounters them.
X   o	The '+' command in a non-threaded group visits the subject selector.
X	You can also use "_a", "_s", "_t" or "_T" to force the article,
X	subject, thread, or thread-but-I'll-settle-for-subject selector.
X   o	The selector displays subjects/threads that are partially-selected
X	with a '*'.  Fully-selected items are marked with a '+', as before.
X	Use the article selector (possibly with 'E'xclusive set) to see
X	which articles are selected in a partially-selected group (or just
X	read them).
X   o	The selector remembers which subjects you selected (and didn't kill)
X	and marks any newly-arriving articles in these subjects as selected
X	until you exit the group.
X   o	The medium display mode of the thread selector has been improved
X	to make it more readable.
X   o	The selector will leave out the middle portion of a subject that is
X	too long to display the last two words of the subject.  If you don't
X	like this, use the -u option to leave them unbroken.
X   o	'T'hread KILL commands now use message-ids to either junk
X	or select articles.  The 'T' command has been extended to be
X	more flexible on the article level and has been added to the
X	selector.
X   o	Another new command 'A'dds selection or kill commands to the KILL
X	file, and works from both the article level and the selector.
X   o	The tree display has been updated to display unread-but-not-
X	selected articles as <x>.  Other unread articles are still [x],
X	while read articles still display as (x).
X   o	Trn can enter a group without thread information available and
X	thread it in the background while you read.  Articles that have
X	references that may or may not exist show up as "(?)".  If you
X	visit an article like this and wait there, the screen will update
X	when we know for sure one way or the other (after processing more
X	of the group).
X   o	The -a option is used to tell trn to thread all of the
X	articles on entry to the group.  If you don't specify this
X	option a group may have a few (or many) articles that get
X	threaded in the background and won't show up on the tree
X	display until trn processes them.
X   o	Pressing "_+" on the article level will select the entire thread
X	associated with the current article -- useful if you've selected
X	individual articles and wish to read the rest of the discussion.
X	Use "_-" to deselect the current thread.
X   o	The commands _N and _P move to the next and previous article
X	in numberical (arrival) order (article level).  Thus, you can
X	use the command "._P" on the newsgroup level to start reading
X	a group from the very last article to arrive.
X   o	The 't' command on the newsgroup level now turns OFF reading a
X	group with threads (this setting is stored in the .newsrc file,
X	so it is remembered from session to session).  Trn 2.x used this
X	to force threading to be turned ON, but it wasn't usually needed
X	for normal operation.  To temporarily turn threads on once inside
X	a non-threaded group, use the 't' or "_t" commands (article level)
X	or the "St" command (selector).
X   o	Trn now checks for the environment variable TRNMACRO on startup
X	(which defaults to DOTDIR/.trnmac) before checking for the usual
X	RNMACRO (DOTDIR/.rnmac) file.  If you're running trn in its rn-
X	compatible mode, only RNMACRO is tried.
X   o	The threaded and non-threaded data in a group has been unified,
X	resulting in more cached information on the non-threaded side
X	(such as the from line) and more efficient handling of missing
X	articles, just to name two benefits.
X   o	The newsgroup information is freed when we enter a new group,
X	not when we exit the current group.  This means that if you
X	quit out of a group (even accidentally), you can go back in
X	and everything is still there except the selections, which
X	get cleared on group exit.
X   o	KILL file processing will now ignore the THRU line as much as
X	possible without slowing down the handling of KILL files.
X	If you have really slow searches (header or article searches)
X	or you use trn without a database it will use the THRU line
X	to only search an article one time (as it would in rn).  This
X	means that if you have subject-oriented selection commands you
X	don't have to worry about missing articles if you don't read all
X	of them the first time you enter a group after they arrive.  This
X	also means that you won't have to edit your local kill file to
X	remove the THRU line to force a re-scan -- this is now unnecessary.
X   o	Header parsing is now done in-memory, making threading and
X	caching of articles much faster.  This especially helps out
X	NNTP users because trn used to write a tmp file for every
X	header parse.
X   o	Several new mode letters (accessed by %m in macros) were added.
X	The most significant are 'f' for the end (Finis) of the newsgroup
X	selection level (instead of 'n') and 'e' for the end of the article
X	reading level (instead of 'a').
X   o	A new % modifier has been introduced: "%:FMTx".  This allows you
X	to apply a printf-style column format to a regular %x expansion.
X	For example, %:-50.50s would left-justify the subject into 50
X	characters, exactly.
X   o	The -f option will make trn go a little faster by getting rid of the
X	delay/prompt after kill file processing, printing the "skipping
X	article" message, and printing the "Depositing KILL command" message.
X	This is the default if -t (terse) is specified, but can be overriden
X	by specifying +f after the -t option.
X   o	A new option for the gadget-conscious (-B) displays a spinner when
X	trn is processing articles in the background.
X   o	Added the -G option to make the newsgroup 'g'o command look for
X	near matches (for those typing mistakes).
X   o	New newsgroups that are left unsubscribed are not appended to the
X	.newsrc unless you use the -I option or you're running an NNTP
X	version that does not use the NEWGROUPS code.
X   o	Support for metamail's mime handling is now built into the code --
X	see the METAMAIL define in common.h.
X   o	Pnews does more checking of your article before posting, has a
X	spelling-check option, and allows the Cc: header to be used to
X	send mail while posting the article.
X
XChanges from trn 1.0.3 to trn 2.5:
X
X   o	Added the '(' and ')' commands (article level) to move to an
X	article's previous/next sibling, including "cousin" siblings.
X   o	The 'A'bandon command (newsgroup level) forgets all changes to the
X	current newsgroup since you first started trn.
X   o	The thread selector now allows you type type 'c'/'y' to catchup
X	the group without chasing cross-references.
X   o	Added 'z' and 'Z' commands (article level) supersede the current
X	article ('Z' also including the original text).
X   o	The g command (newsgroup level) will go to a newsgroup by number
X	where the the number corresponds to that shown in the 'L'ist
X	command.
X   o	Added the "-o" option to use the old method of junking articles in
X	the thread commands (they didn't chase cross-references in trn 1.x)
X   o	Added the "-b" option to read articles in a breadth-first descent
X	of the article tree.  You can specify this command at runtime to
X	switch from breadth-first (type "&-b") to depth-first ("&+b).
X   o	Added the "-j" option to tell trn to pass control characters through
X	the pager unharmed.
END_OF_FILE
if test 15395 -ne `wc -c <'NEW'`; then
    echo shar: \"'NEW'\" unpacked with wrong size!
fi
# end of 'NEW'
fi
if test -f 'config.h.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config.h.SH'\"
else
echo shar: Extracting \"'config.h.SH'\" \(13724 characters\)
sed "s/^X//" >'config.h.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X'') . ./config.sh ;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting config.h (with variable substitutions)"
Xsed <<!GROK!THIS! >config.h -e 's!^#undef!/\*#define!'
X/*
X * This file was produced by running the config.h.SH script, which
X * gets its values from config.sh, which is generally produced by
X * running Configure.
X *
X * Feel free to modify any of this as the need arises.  Note, however,
X * that running config.h.SH again will wipe out any changes you've made.
X * For a more permanent change edit config.sh and rerun config.h.SH.
X *
X * \$Id: Config.h.U,v 2.8.1.2 91/10/11 10:07:56 ram Exp Locker: ram $
X */
X
X/* Configuration time: $cf_time
X * Configured by: $cf_by
X * Target system: $myuname
X */
X
X#ifndef _config_h_
X#define _config_h_
X
X/* EUNICE:
X *	This symbol, if defined, indicates that the program is being compiled
X *	under the EUNICE package under VMS.  The program will need to handle
X *	things like files that don't go away the first time you unlink them,
X *	due to version numbering.  It will also need to compensate for lack
X *	of a respectable link() command.
X */
X/* VMS:
X *	This symbol, if defined, indicates that the program is running under
X *	VMS.  It is currently only set in conjunction with the EUNICE symbol.
X */
X#$d_eunice EUNICE		/**/
X#$d_eunice VMS		/**/
X
X/* HAS_GETPWENT
X *	This symbol, if defined, indicates that the getpwent() routine
X *	should be used instead of the getpw() routine.
X */
X#$d_getpwent HAS_GETPWENT	/**/
X
X/* HAS_TERMLIB
X *	This symbol, when defined, indicates that termlib-style routines
X *	are available.  There is nothing to include.
X */
X#$d_havetlib	HAS_TERMLIB	/**/
X
X/* HAS_MEMCMP
X *	This symbol, if defined, indicates that the memcmp routine is available
X *	to compare blocks of memory.
X */
X#$d_memcmp HAS_MEMCMP	/**/
X
X/* HAS_MEMCPY
X *	This symbol, if defined, indicates that the memcpy routine is available
X *	to copy blocks of memory.
X */
X#$d_memcpy HAS_MEMCPY	/**/
X
X/* HAS_MEMSET
X *	This symbol, if defined, indicates that the memset routine is available
X *	to set blocks of memory.
X */
X#$d_memset HAS_MEMSET	/**/
X
X/* NEWS_ADMIN
X *	This symbol, if defined, contains the login name of the news
X *	administrator.
X */
X#$d_newsadm NEWS_ADMIN "$newsadmin"		/**/
X
X/* NOLINEBUF:
X *	This symbol, if defined, indicates that stdout is not buffered, so that
X *	the program can call setbuf() or setlinebuf() for efficiency.
X */
X#$d_nolnbuf	NOLINEBUF	/**/
X
X/* NORMSIG:
X *	This symbol, if defined, indicates that normal signal handling routines
X *	should be used, as opposed to the ones in 4.1bsd (sigset, etc.).
X */
X#$d_normsig NORMSIG		/**/
X
X/* vfork:
X *	This symbol, if defined, remaps the vfork routine to fork if the
X *	vfork() routine isn't supported here.
X */
X#$d_novfork vfork fork	/**/
X
X/* HAS_RDCHK
X *	This symbol, if defined, indicates that the rdchk routine is available
X *	to find out if there is input pending on an IO channel.  Generally
X *	the routine is used only if FIONREAD and O_NDELAY aren't available.
X */
X#$d_rdchk HAS_RDCHK		/**/
X
X/* HAS_RENAME
X *	This symbol, if defined, indicates that the rename routine is available
X *	to rename files.  Otherwise you should do the unlink(), link(), unlink()
X *	trick.
X */
X#$d_rename HAS_RENAME	/**/
X
X/* HAS_SIGBLOCK:
X *	This symbol, if defined, indicates that the sigblock routine is
X *	available to block signal reception.
X */
X#$d_sigblock HAS_SIGBLOCK	/**/
X
X/* HAS_SIGHOLD:
X *	This symbol, if defined, indicates that the sighold routine is
X *	available to hold signals.
X */
X#$d_sighold HAS_SIGHOLD	/**/
X
X/* HAS_STRCASECMP:
X *	This symbol, if defined, indicates that the strcasecmp routine is
X *	available for case-insensitive string compares.
X */
X#$d_strcasecmp HAS_STRCASECMP	/**/
X
X/* Signal_t
X *	This symbol's value is either "void" or "int", corresponding to the
X *	appropriate return type of a signal handler.  Thus, you can declare
X *	a signal handler using "Signal_t (*handler)()", and define the
X *	handler using "Signal_t handler(sig)".
X */
X#define Signal_t $signal_t	/* Signal handler's return type */
X
X/* I_DIRENT:
X *	This symbol, if defined, indicates to the C program that it should
X *	include <dirent.h>.
X */
X#$i_dirent I_DIRENT		/**/
X
X/* I_STDLIB:
X *	This symbol, if defined, indicates that <stdlib.h> exists and should
X *	be included.
X */
X#$i_stdlib I_STDLIB		/**/
X
X/* I_SYS_DIR
X *	This symbol, if defined, indicates to the C program that it should
X *	include <sys/dir.h>.
X */
X#$i_sysdir I_SYS_DIR		/**/
X
X/* I_SYS_IOCTL
X *	This symbol, if defined, indicates that <sys/ioctl.h> exists and should
X *	be included. Otherwise, include <sgtty.h> or <termio.h>.
X */
X#$i_sysioctl	I_SYS_IOCTL		/**/
X
X/* I_SYS_NDIR
X *	This symbol, if defined, indicates to the C program that it should
X *	include <sys/ndir.h>.
X */
X#$i_sysndir I_SYS_NDIR	/**/
X
X/* I_TERMIO:
X *	This symbol, if defined, indicates that the program should include
X *	<termio.h> rather than <sgtty.h>.  There are also differences in
X *	the ioctl() calls that depend on the value of this symbol.
X */
X/* I_TERMIOS:
X *	This symbol, if defined, indicates that the program should include
X *	the POSIX termios.h rather than sgtty.h or termio.h.
X *	There are also differences in the ioctl() calls that depend on the
X *	value of this symbol.
X */
X/* I_SGTTY:
X *	This symbol, if defined, indicates that the program should include
X *	<sgtty.h> rather than <termio.h>.  There are also differences in
X *	the ioctl() calls that depend on the value of this symbol.
X */
X#$i_termio I_TERMIO		/**/
X#$i_termios I_TERMIOS		/**/
X#$i_sgtty I_SGTTY		/**/
X
X/* I_UNISTD:
X *	This symbol, if defined, indicates to the C program that it should
X *	include <unistd.h>.
X */
X#$i_unistd	I_UNISTD		/**/
X
X/* I_VFORK:
X *	This symbol, if defined, indicates to the C program that it should
X *	include vfork.h.
X */
X#$i_vfork I_VFORK	/**/
X
X/* MAILFILE:
X *	This symbol contains the interpretable name of the mail spool file
X *	for the current user.  The program must be prepared to substitute
X *	the HOME directory for %~, and the login id for %L.
X */
X#define MAILFILE "$mailfile"		/**/
X
X/* MBOXCHAR:
X *	This symbol contains a character which will match the beginning
X *	of a mailbox file.
X */
X#define MBOXCHAR '$mboxchar'		/**/
X
X/* ORGNAME:
X *	This symbol contains either the organizaton name or the full pathname
X *	of a file containing the organization name, which the program must
X *	be prepared to open and substitute the contents of.
X */
X#define ORGNAME "$orgname"		/**/
X
X/* PREFSHELL:
X *	This symbol contains the full name of the preferred user shell on this
X *	system.  Usual values are /bin/csh, /bin/ksh, /bin/sh.
X */
X#define PREFSHELL "$prefshell"		/**/
X
X/* ROOTID:
X *	This symbol contains the uid of root, normally 0.
X */
X#define ROOTID $rootid		/**/
X
X/* ACTIVE:
X *	The name of the active file for the news system.  This file contains
X *	the list of active newsgroups.  The name may have ~ on the front.
X */
X/* ACTIVE_TIMES:
X *	The name of the active.times file for the news system.
X */
X#define ACTIVE "$active"		/**/
X#$d_acttimes ACTIVE_TIMES "$acttimes"		/**/
X
X/* HAS_FTIME:
X *	This symbol, if defined, indicates that the ftime() routine exists.
X *	It is basically a sub-second accuracy clock, but is less accurate
X *	than gettimeofday(2) anyway. The type "Timeval" should be used to
X *	refer to "struct timeb".
X */
X#$d_ftime HAS_FTIME		/**/
X
X/* HAS_GETHOSTNAME
X *	This symbol, if defined, indicates that the C program may use the
X *	gethostname() routine to derive the host name.  See also HAS_UNAME
X *	and PHOSTCMD.
X */
X/* HAS_UNAME
X *	This symbol, if defined, indicates that the C program may use the
X *	uname() routine to derive the host name.  See also HAS_GETHOSTNAME
X *	and PHOSTCMD.
X */
X/* PHOSTCMD:
X *	This symbol, if defined, indicates that the C program may use the
X *	contents of PHOSTCMD as a command to feed to the popen() routine
X *	to derive the host name.  See also HAS_GETHOSTNAME and HAS_UNAME.
X *	Note that the command uses a fully qualified path, so that it is safe
X *	even if used by a process with super-user privileges.
X */
X#$d_gethname HAS_GETHOSTNAME	/**/
X#$d_uname HAS_UNAME		/**/
X#$d_phostcmd PHOSTCMD "$aphostcmd"	/* How to get the host name */
X
X/* HAS_GETWD
X *	This symbol, if defined, indicates that the getwd routine is
X *	available to get the working directory.
X */
X/* HAS_GETCWD:
X *	This symbol, if defined, indicates that the getcwd routine is
X *	available.  This is never defined if getwd is found first.
X */
X#$d_getwd HAS_GETWD		/**/
X#$d_getcwd HAS_GETCWD		/**/
X
X/* IGNOREORG:
X *	This symbol, if defined, indicates that the ORGANIZATION environment
X *	variable does not contain an organization name.
X */
X#$d_ignoreorg IGNOREORG		/**/
X
X/* INTERNET:
X *	This symbol, if defined, indicates that there is a mailer available
X *	which supports internet-style addresses (user@site.domain).
X */
X#$d_internet	INTERNET	/**/
X
X/* MIME_SUPPORT:
X *	This symbol, if defined, indicates mime articles should be processed
X *	by an external program.
X */
X/* MIMESHOW:
X *	This symbol points to the program to run to show a mime article.
X */
X/* MIMESTORE:
X *	This symbol points to the program to run to store a mime article.
X */
X#$d_mime MIME_SUPPORT	/**/
X#$d_mime MIMESHOW "$mimeshow"
X#$d_mime MIMESTORE "$mimestore"
X
X/* USE_NNTP:
X *	This symbol, if defined, indicates that NNTP should be used.
X */
X/* SERVER_NAME:
X *	When using NNTP, this symbol indicates the server name or a
X *	file to open to read the server name.
X */
X/* USE_XTHREAD:
X *	This symbol, if defined, indicates that .thread files can be
X *	gotten via NNTP.  It is never defined if USE_NNTP is undefined.
X */
X/* USE_XOVER:
X *	This symbol, if defined, indicates that .overview files can be
X *	gotten via NNTP.  It is never defined if USE_NNTP is undefined.
X */
X#$d_nntp	USE_NNTP	/**/
X#define SERVER_NAME "$servername"  	/**/
X#$d_xdata USE_XTHREAD  	/**/
X#$d_xdata USE_XOVER	/**/
X
X/* void:
X *	This symbol is used for void functions.  On implementations which
X *	support void appropriately, its value is "void".  Otherwise, its
X *	value should be set to "int".
X */
X#$d_novoid void int	/**/
X
X/* size_t:
X *	This symbol is defined as an int if no size_t definition exists.
X */
X#$d_sizet	size_t int		/**/
X
X/* HAS_STRCHR:
X *	This symbol is defined to indicate that the strchr()/strrchr()
X *	functions are available for string searching.
X */
X#$d_strchr	HAS_STRCHR	/**/
X
X/* HAS_STRFTIME:
X *	This symbol, if defined, indicates that the strftime routine is
X *	available to format locale-specific times.
X */
X#$d_strftime	HAS_STRFTIME		/**/
X
X/* EMULATE_NDIR:
X *	This symbol, if defined, indicates that the program should compile
X *	the ndir.c code provided with the package.
X */
X/* I_NDIR:
X *	This symbol, if defined, indicates that the program should include the
X *	system's version of ndir.h, rather than the one with this package.
X */
X#$d_usendir	EMULATE_NDIR		/**/
X#$d_libndir	I_NDIR		/**/
X
X/* DEFEDITOR:
X *	This symbol contains the full pathname of the default editor.
X */
X#define DEFEDITOR "$defeditor"		/**/
X
X/* I_PTEM:
X *	This symbol, if defined, indicates to the C program that it should
X *	include ptem.h.
X */
X#$i_ptem I_PTEM		/**/
X
X/* I_STRING:
X *	This symbol, if defined, indicates to the C program that it should
X *	include <string.h> (USG systems) instead of <strings.h> (BSD systems).
X */
X#$i_string I_STRING		/**/
X
X/* I_TIME
X *	This symbol, if defined, indicates to the C program that it should
X *	include <time.h>.
X */
X/* I_SYS_TIME
X *	This symbol, if defined, indicates to the C program that it should
X *	include <sys/time.h>.
X */
X#$i_time I_TIME		/**/
X#$i_systime I_SYS_TIME		/**/
X
X/* PASSNAMES:
X *	This symbol, if defined, indicates that full names are stored in
X *	the /etc/passwd file.
X */
X/* BERKNAMES:
X *	This symbol, if defined, indicates that full names are stored in
X *	the /etc/passwd file in Berkeley format (name first thing, everything
X *	up to first comma, with & replaced by capitalized login id, yuck).
X */
X#$d_passnames PASSNAMES /*  (undef to take name from ~/.fullname) */
X#$d_berknames BERKNAMES /* (that is, ":name,stuff:") */
X
X/* NEWSLIB:
X *	This symbol contains the name of the directory serving as the news
X *	library.  The program must be prepared to do ~ expansion on it.
X */
X#define NEWSLIB "$newslib"		/**/
X
X/* NEWSSPOOL:
X *	This symbol contains the directory name where news articles are
X *	spooled.  The program must be prepared to do ~ expansion on it.
X */
X#define NEWSSPOOL "$newsspool"		/**/
X
X/* PHOSTNAME:
X *	This symbol contains the posting host's name or a file from which
X *	to read its name.
X */
X#define PHOSTNAME "$phost"		/**/
X
X/* PRIVLIB:
X *	This symbol contains the name of the private library for this package.
X *	The library is private in the sense that it needn't be in anyone's
X *	execution path, but it should be accessible by the world.  The program
X *	should be prepared to do ~ expansion.
X */
X#define PRIVLIB "$privlib"		/**/
X
X/* THREAD_DIR:
X *	This symbol indicates where the thread files go.
X */
X/* OVERVIEW_DIR:
X *	This symbol indicates where the overview files go.
X */
X/* USE_MT:
X *	This symbol indicates if thread file support is desired.
X */
X/* USE_OV:
X *	This symbol indicates if overview file support is desired.
X */
X#define THREAD_DIR	"$threaddir"		/**/
X#define OVERVIEW_DIR	"$overviewdir"		/**/
X#$d_usemt USE_MT		/**/
X#$d_useov USE_OV		/**/
X
X/* THREAD_INIT:
X *	This symbol indicates we act like trn no matter what our name is.
X */
X/* SELECT_INIT:
X *	This symbol indicates we default to the selector for group entry.
X */
X#define THREAD_INIT	$trn_init
X#define SELECT_INIT	$trn_select
X
X#undef	LONG_THREAD_NAMES	/**/
X
X#define CANCEL	"$inewsloc -h <%h"
X#define SPEED_OVER_MEM	/* use more memory to run faster */
X/*#define ANCIENT_NEWS	/* if your B news system is <= 2.10.1 */
X
X#endif
X!GROK!THIS!
END_OF_FILE
if test 13724 -ne `wc -c <'config.h.SH'`; then
    echo shar: \"'config.h.SH'\" unpacked with wrong size!
fi
# end of 'config.h.SH'
fi
if test -f 'dependencies' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dependencies'\"
else
echo shar: Extracting \"'dependencies'\" \(14214 characters\)
sed "s/^X//" >'dependencies' <<'END_OF_FILE'
Xaddng.o: EXTERN.h
Xaddng.o: INTERN.h
Xaddng.o: addng.c
Xaddng.o: addng.h
Xaddng.o: common.h
Xaddng.o: config.h
Xaddng.o: final.h
Xaddng.o: intrp.h
Xaddng.o: last.h
Xaddng.o: ngdata.h
Xaddng.o: nntp.h
Xaddng.o: nntpclient.h
Xaddng.o: only.h
Xaddng.o: rcstuff.h
Xaddng.o: search.h
Xaddng.o: trn.h
Xaddng.o: util.h
Xart.o: EXTERN.h
Xart.o: INTERN.h
Xart.o: art.c
Xart.o: art.h
Xart.o: artio.h
Xart.o: artstate.h
Xart.o: backpage.h
Xart.o: bits.h
Xart.o: cache.h
Xart.o: common.h
Xart.o: config.h
Xart.o: final.h
Xart.o: head.h
Xart.o: help.h
Xart.o: intrp.h
Xart.o: ng.h
Xart.o: ngdata.h
Xart.o: ngstuff.h
Xart.o: rcstuff.h
Xart.o: rt-select.h
Xart.o: rt-util.h
Xart.o: rt-wumpus.h
Xart.o: rthread.h
Xart.o: search.h
Xart.o: sw.h
Xart.o: term.h
Xart.o: trn.h
Xart.o: util.h
Xartcheck.o: EXTERN.h
Xartcheck.o: artcheck.c
Xartcheck.o: common.h
Xartcheck.o: config.h
Xartio.o: EXTERN.h
Xartio.o: INTERN.h
Xartio.o: art.h
Xartio.o: artio.c
Xartio.o: artio.h
Xartio.o: bits.h
Xartio.o: cache.h
Xartio.o: common.h
Xartio.o: config.h
Xartio.o: final.h
Xartio.o: head.h
Xartio.o: ngdata.h
Xartio.o: nntp.h
Xartio.o: nntpclient.h
Xartio.o: rthread.h
Xartsrch.o: EXTERN.h
Xartsrch.o: INTERN.h
Xartsrch.o: artio.h
Xartsrch.o: artsrch.c
Xartsrch.o: artsrch.h
Xartsrch.o: bits.h
Xartsrch.o: cache.h
Xartsrch.o: common.h
Xartsrch.o: config.h
Xartsrch.o: final.h
Xartsrch.o: head.h
Xartsrch.o: intrp.h
Xartsrch.o: kfile.h
Xartsrch.o: ng.h
Xartsrch.o: ngdata.h
Xartsrch.o: ngstuff.h
Xartsrch.o: nntp.h
Xartsrch.o: nntpclient.h
Xartsrch.o: rt-select.h
Xartsrch.o: rthread.h
Xartsrch.o: search.h
Xartsrch.o: term.h
Xartsrch.o: util.h
Xautosub.o: EXTERN.h
Xautosub.o: INTERN.h
Xautosub.o: autosub.c
Xautosub.o: autosub.h
Xautosub.o: common.h
Xautosub.o: config.h
Xautosub.o: final.h
Xautosub.o: ngsrch.h
Xautosub.o: search.h
Xautosub.o: util.h
Xbackpage.o: EXTERN.h
Xbackpage.o: INTERN.h
Xbackpage.o: backpage.c
Xbackpage.o: backpage.h
Xbackpage.o: common.h
Xbackpage.o: config.h
Xbackpage.o: final.h
Xbackpage.o: intrp.h
Xbits.o: EXTERN.h
Xbits.o: INTERN.h
Xbits.o: artio.h
Xbits.o: bits.c
Xbits.o: bits.h
Xbits.o: cache.h
Xbits.o: common.h
Xbits.o: config.h
Xbits.o: final.h
Xbits.o: head.h
Xbits.o: intrp.h
Xbits.o: ndir.h
Xbits.o: ng.h
Xbits.o: ngdata.h
Xbits.o: nntp.h
Xbits.o: nntpclient.h
Xbits.o: rcln.h
Xbits.o: rcstuff.h
Xbits.o: rt-select.h
Xbits.o: rthread.h
Xbits.o: trn.h
Xbits.o: util.h
Xcache.o: EXTERN.h
Xcache.o: INTERN.h
Xcache.o: artsrch.h
Xcache.o: bits.h
Xcache.o: cache.c
Xcache.o: cache.h
Xcache.o: common.h
Xcache.o: config.h
Xcache.o: final.h
Xcache.o: hash.h
Xcache.o: head.h
Xcache.o: intrp.h
Xcache.o: ng.h
Xcache.o: ngdata.h
Xcache.o: rcstuff.h
Xcache.o: rt-ov.h
Xcache.o: rt-select.h
Xcache.o: rt-util.h
Xcache.o: rthread.h
Xcache.o: search.h
Xcache.o: term.h
Xcache.o: trn.h
Xcache.o: util.h
Xdecode.o: EXTERN.h
Xdecode.o: INTERN.h
Xdecode.o: common.h
Xdecode.o: config.h
Xdecode.o: decode.c
Xdecode.o: decode.h
Xedit_dist.o: EXTERN.h
Xedit_dist.o: common.h
Xedit_dist.o: config.h
Xedit_dist.o: edit_dist.c
Xedit_dist.o: util.h
Xfinal.o: EXTERN.h
Xfinal.o: INTERN.h
Xfinal.o: artio.h
Xfinal.o: bits.h
Xfinal.o: cache.h
Xfinal.o: common.h
Xfinal.o: config.h
Xfinal.o: final.c
Xfinal.o: final.h
Xfinal.o: init.h
Xfinal.o: intrp.h
Xfinal.o: last.h
Xfinal.o: ng.h
Xfinal.o: ngdata.h
Xfinal.o: nntp.h
Xfinal.o: nntpclient.h
Xfinal.o: rcstuff.h
Xfinal.o: term.h
Xfinal.o: util.h
Xgetactive.o: EXTERN.h
Xgetactive.o: common.h
Xgetactive.o: config.h
Xgetactive.o: getactive.c
Xgetactive.o: nntpclient.h
Xhash.o: EXTERN.h
Xhash.o: INTERN.h
Xhash.o: common.h
Xhash.o: config.h
Xhash.o: final.h
Xhash.o: hash.c
Xhash.o: hash.h
Xhash.o: util.h
Xhead.o: EXTERN.h
Xhead.o: INTERN.h
Xhead.o: artio.h
Xhead.o: cache.h
Xhead.o: common.h
Xhead.o: config.h
Xhead.o: final.h
Xhead.o: hash.h
Xhead.o: head.c
Xhead.o: head.h
Xhead.o: ng.h
Xhead.o: ngdata.h
Xhead.o: nntp.h
Xhead.o: nntpclient.h
Xhead.o: rt-process.h
Xhead.o: rt-util.h
Xhead.o: rthread.h
Xhead.o: util.h
Xhelp.o: EXTERN.h
Xhelp.o: INTERN.h
Xhelp.o: common.h
Xhelp.o: config.h
Xhelp.o: help.c
Xhelp.o: help.h
Xhelp.o: term.h
Xhelp.o: trn.h
Xinit.o: EXTERN.h
Xinit.o: INTERN.h
Xinit.o: addng.h
Xinit.o: art.h
Xinit.o: artio.h
Xinit.o: artsrch.h
Xinit.o: backpage.h
Xinit.o: bits.h
Xinit.o: cache.h
Xinit.o: common.h
Xinit.o: config.h
Xinit.o: decode.h
Xinit.o: final.h
Xinit.o: head.h
Xinit.o: help.h
Xinit.o: init.c
Xinit.o: init.h
Xinit.o: intrp.h
Xinit.o: kfile.h
Xinit.o: last.h
Xinit.o: ng.h
Xinit.o: ngdata.h
Xinit.o: ngsrch.h
Xinit.o: ngstuff.h
Xinit.o: nntp.h
Xinit.o: nntpclient.h
Xinit.o: only.h
Xinit.o: rcln.h
Xinit.o: rcstuff.h
Xinit.o: respond.h
Xinit.o: rthread.h
Xinit.o: search.h
Xinit.o: sw.h
Xinit.o: term.h
Xinit.o: trn.h
Xinit.o: util.h
Xintrp.o: EXTERN.h
Xintrp.o: INTERN.h
Xintrp.o: artio.h
Xintrp.o: artsrch.h
Xintrp.o: bits.h
Xintrp.o: cache.h
Xintrp.o: common.h
Xintrp.o: config.h
Xintrp.o: final.h
Xintrp.o: head.h
Xintrp.o: init.h
Xintrp.o: intrp.c
Xintrp.o: intrp.h
Xintrp.o: ng.h
Xintrp.o: ngdata.h
Xintrp.o: nntp.h
Xintrp.o: nntpclient.h
Xintrp.o: rcstuff.h
Xintrp.o: respond.h
Xintrp.o: rt-select.h
Xintrp.o: rt-util.h
Xintrp.o: rthread.h
Xintrp.o: search.h
Xintrp.o: term.h
Xintrp.o: trn.h
Xintrp.o: util.h
Xkfile.o: EXTERN.h
Xkfile.o: INTERN.h
Xkfile.o: artsrch.h
Xkfile.o: cache.h
Xkfile.o: common.h
Xkfile.o: config.h
Xkfile.o: hash.h
Xkfile.o: intrp.h
Xkfile.o: kfile.c
Xkfile.o: kfile.h
Xkfile.o: ng.h
Xkfile.o: ngdata.h
Xkfile.o: ngstuff.h
Xkfile.o: rcstuff.h
Xkfile.o: rt-process.h
Xkfile.o: rt-select.h
Xkfile.o: rthread.h
Xkfile.o: search.h
Xkfile.o: term.h
Xkfile.o: trn.h
Xkfile.o: util.h
Xlast.o: EXTERN.h
Xlast.o: INTERN.h
Xlast.o: common.h
Xlast.o: config.h
Xlast.o: intrp.h
Xlast.o: last.c
Xlast.o: last.h
Xlast.o: trn.h
Xlast.o: util.h
Xndir.o: EXTERN.h
Xndir.o: INTERN.h
Xndir.o: common.h
Xndir.o: config.h
Xndir.o: ndir.c
Xndir.o: ndir.h
Xng.o: EXTERN.h
Xng.o: INTERN.h
Xng.o: art.h
Xng.o: artio.h
Xng.o: artsrch.h
Xng.o: artstate.h
Xng.o: backpage.h
Xng.o: bits.h
Xng.o: cache.h
Xng.o: common.h
Xng.o: config.h
Xng.o: decode.h
Xng.o: final.h
Xng.o: head.h
Xng.o: help.h
Xng.o: intrp.h
Xng.o: kfile.h
Xng.o: last.h
Xng.o: ng.c
Xng.o: ng.h
Xng.o: ngdata.h
Xng.o: ngstuff.h
Xng.o: nntp.h
Xng.o: nntpclient.h
Xng.o: rcln.h
Xng.o: rcstuff.h
Xng.o: respond.h
Xng.o: rt-select.h
Xng.o: rt-wumpus.h
Xng.o: rthread.h
Xng.o: search.h
Xng.o: term.h
Xng.o: trn.h
Xng.o: util.h
Xngdata.o: EXTERN.h
Xngdata.o: INTERN.h
Xngdata.o: bits.h
Xngdata.o: cache.h
Xngdata.o: common.h
Xngdata.o: config.h
Xngdata.o: final.h
Xngdata.o: head.h
Xngdata.o: intrp.h
Xngdata.o: kfile.h
Xngdata.o: ndir.h
Xngdata.o: ng.h
Xngdata.o: ngdata.c
Xngdata.o: ngdata.h
Xngdata.o: nntp.h
Xngdata.o: nntpclient.h
Xngdata.o: rcln.h
Xngdata.o: rcstuff.h
Xngdata.o: rt-select.h
Xngdata.o: rthread.h
Xngdata.o: term.h
Xngdata.o: trn.h
Xngdata.o: util.h
Xnghash.o: EXTERN.h
Xnghash.o: common.h
Xnghash.o: config.h
Xnghash.o: final.h
Xnghash.o: hash.h
Xnghash.o: intrp.h
Xnghash.o: ndir.h
Xnghash.o: ngdata.h
Xnghash.o: nghash.c
Xnghash.o: nntp.h
Xnghash.o: nntpclient.h
Xnghash.o: rcln.h
Xnghash.o: rcstuff.h
Xnghash.o: term.h
Xnghash.o: trn.h
Xnghash.o: util.h
Xngsrch.o: EXTERN.h
Xngsrch.o: INTERN.h
Xngsrch.o: common.h
Xngsrch.o: config.h
Xngsrch.o: final.h
Xngsrch.o: ngsrch.c
Xngsrch.o: ngsrch.h
Xngsrch.o: rcln.h
Xngsrch.o: rcstuff.h
Xngsrch.o: search.h
Xngsrch.o: term.h
Xngsrch.o: trn.h
Xngsrch.o: util.h
Xngstuff.o: EXTERN.h
Xngstuff.o: INTERN.h
Xngstuff.o: bits.h
Xngstuff.o: cache.h
Xngstuff.o: common.h
Xngstuff.o: config.h
Xngstuff.o: decode.h
Xngstuff.o: final.h
Xngstuff.o: head.h
Xngstuff.o: intrp.h
Xngstuff.o: kfile.h
Xngstuff.o: ng.h
Xngstuff.o: ngdata.h
Xngstuff.o: ngstuff.c
Xngstuff.o: ngstuff.h
Xngstuff.o: rcstuff.h
Xngstuff.o: respond.h
Xngstuff.o: rt-select.h
Xngstuff.o: rt-wumpus.h
Xngstuff.o: rthread.h
Xngstuff.o: sw.h
Xngstuff.o: term.h
Xngstuff.o: trn.h
Xngstuff.o: util.h
Xnntp.o: EXTERN.h
Xnntp.o: bits.h
Xnntp.o: cache.h
Xnntp.o: common.h
Xnntp.o: config.h
Xnntp.o: final.h
Xnntp.o: head.h
Xnntp.o: init.h
Xnntp.o: ngdata.h
Xnntp.o: nntp.c
Xnntp.o: nntp.h
Xnntp.o: nntpclient.h
Xnntp.o: rcln.h
Xnntp.o: trn.h
Xnntp.o: util.h
Xnntpclient.o: EXTERN.h
Xnntpclient.o: INTERN.h
Xnntpclient.o: common.h
Xnntpclient.o: config.h
Xnntpclient.o: nntpclient.c
Xnntpclient.o: nntpclient.h
Xnntpinit.o: EXTERN.h
Xnntpinit.o: common.h
Xnntpinit.o: config.h
Xnntpinit.o: nntpclient.h
Xnntpinit.o: nntpinit.c
Xonly.o: EXTERN.h
Xonly.o: INTERN.h
Xonly.o: common.h
Xonly.o: config.h
Xonly.o: final.h
Xonly.o: ngsrch.h
Xonly.o: only.c
Xonly.o: only.h
Xonly.o: search.h
Xonly.o: util.h
Xparsedate.o: config.h
Xparsedate.o: parsedate.y
Xrcln.o: EXTERN.h
Xrcln.o: INTERN.h
Xrcln.o: common.h
Xrcln.o: config.h
Xrcln.o: ngdata.h
Xrcln.o: rcln.c
Xrcln.o: rcln.h
Xrcln.o: rcstuff.h
Xrcln.o: util.h
Xrcstuff.o: EXTERN.h
Xrcstuff.o: INTERN.h
Xrcstuff.o: autosub.h
Xrcstuff.o: bits.h
Xrcstuff.o: cache.h
Xrcstuff.o: common.h
Xrcstuff.o: config.h
Xrcstuff.o: final.h
Xrcstuff.o: hash.h
Xrcstuff.o: intrp.h
Xrcstuff.o: ngdata.h
Xrcstuff.o: nntp.h
Xrcstuff.o: nntpclient.h
Xrcstuff.o: only.h
Xrcstuff.o: rcln.h
Xrcstuff.o: rcstuff.c
Xrcstuff.o: rcstuff.h
Xrcstuff.o: search.h
Xrcstuff.o: term.h
Xrcstuff.o: trn.h
Xrcstuff.o: util.h
Xrespond.o: EXTERN.h
Xrespond.o: INTERN.h
Xrespond.o: artio.h
Xrespond.o: cache.h
Xrespond.o: common.h
Xrespond.o: config.h
Xrespond.o: decode.h
Xrespond.o: final.h
Xrespond.o: head.h
Xrespond.o: intrp.h
Xrespond.o: ng.h
Xrespond.o: ngdata.h
Xrespond.o: respond.c
Xrespond.o: respond.h
Xrespond.o: term.h
Xrespond.o: trn.h
Xrespond.o: util.h
Xrt-mt.o: EXTERN.h
Xrt-mt.o: INTERN.h
Xrt-mt.o: bits.h
Xrt-mt.o: cache.h
Xrt-mt.o: common.h
Xrt-mt.o: config.h
Xrt-mt.o: hash.h
Xrt-mt.o: intrp.h
Xrt-mt.o: ng.h
Xrt-mt.o: ngdata.h
Xrt-mt.o: nntp.h
Xrt-mt.o: nntpclient.h
Xrt-mt.o: rcln.h
Xrt-mt.o: rt-mt.c
Xrt-mt.o: rt-mt.h
Xrt-mt.o: rt-process.h
Xrt-mt.o: rthread.h
Xrt-mt.o: trn.h
Xrt-mt.o: util.h
Xrt-ov.o: EXTERN.h
Xrt-ov.o: INTERN.h
Xrt-ov.o: bits.h
Xrt-ov.o: cache.h
Xrt-ov.o: common.h
Xrt-ov.o: config.h
Xrt-ov.o: final.h
Xrt-ov.o: hash.h
Xrt-ov.o: head.h
Xrt-ov.o: ng.h
Xrt-ov.o: ngdata.h
Xrt-ov.o: nntp.h
Xrt-ov.o: nntpclient.h
Xrt-ov.o: overview.h
Xrt-ov.o: rt-ov.c
Xrt-ov.o: rt-ov.h
Xrt-ov.o: rt-process.h
Xrt-ov.o: rt-util.h
Xrt-ov.o: rthread.h
Xrt-ov.o: term.h
Xrt-ov.o: trn.h
Xrt-ov.o: util.h
Xrt-page.o: EXTERN.h
Xrt-page.o: INTERN.h
Xrt-page.o: cache.h
Xrt-page.o: common.h
Xrt-page.o: config.h
Xrt-page.o: ngdata.h
Xrt-page.o: rt-page.c
Xrt-page.o: rt-page.h
Xrt-page.o: rt-select.h
Xrt-page.o: rt-util.h
Xrt-page.o: rthread.h
Xrt-page.o: term.h
Xrt-page.o: trn.h
Xrt-page.o: util.h
Xrt-process.o: EXTERN.h
Xrt-process.o: bits.h
Xrt-process.o: cache.h
Xrt-process.o: common.h
Xrt-process.o: config.h
Xrt-process.o: final.h
Xrt-process.o: hash.h
Xrt-process.o: intrp.h
Xrt-process.o: kfile.h
Xrt-process.o: ng.h
Xrt-process.o: ngdata.h
Xrt-process.o: rcln.h
Xrt-process.o: rt-process.c
Xrt-process.o: rt-select.h
Xrt-process.o: rthread.h
Xrt-process.o: trn.h
Xrt-process.o: util.h
Xrt-select.o: EXTERN.h
Xrt-select.o: INTERN.h
Xrt-select.o: artsrch.h
Xrt-select.o: bits.h
Xrt-select.o: cache.h
Xrt-select.o: common.h
Xrt-select.o: config.h
Xrt-select.o: final.h
Xrt-select.o: help.h
Xrt-select.o: kfile.h
Xrt-select.o: ng.h
Xrt-select.o: ngdata.h
Xrt-select.o: ngstuff.h
Xrt-select.o: rt-page.h
Xrt-select.o: rt-select.c
Xrt-select.o: rt-select.h
Xrt-select.o: rt-util.h
Xrt-select.o: rthread.h
Xrt-select.o: search.h
Xrt-select.o: term.h
Xrt-select.o: trn.h
Xrt-select.o: util.h
Xrt-util.o: EXTERN.h
Xrt-util.o: INTERN.h
Xrt-util.o: artio.h
Xrt-util.o: cache.h
Xrt-util.o: common.h
Xrt-util.o: config.h
Xrt-util.o: ngdata.h
Xrt-util.o: rt-select.h
Xrt-util.o: rt-util.c
Xrt-util.o: rt-util.h
Xrt-util.o: rthread.h
Xrt-util.o: term.h
Xrt-wumpus.o: EXTERN.h
Xrt-wumpus.o: INTERN.h
Xrt-wumpus.o: artio.h
Xrt-wumpus.o: backpage.h
Xrt-wumpus.o: cache.h
Xrt-wumpus.o: common.h
Xrt-wumpus.o: config.h
Xrt-wumpus.o: final.h
Xrt-wumpus.o: head.h
Xrt-wumpus.o: ng.h
Xrt-wumpus.o: ngdata.h
Xrt-wumpus.o: rt-select.h
Xrt-wumpus.o: rt-wumpus.c
Xrt-wumpus.o: rt-wumpus.h
Xrt-wumpus.o: rthread.h
Xrt-wumpus.o: term.h
Xrt-wumpus.o: util.h
Xrthread.o: EXTERN.h
Xrthread.o: INTERN.h
Xrthread.o: artstate.h
Xrthread.o: bits.h
Xrthread.o: cache.h
Xrthread.o: common.h
Xrthread.o: config.h
Xrthread.o: hash.h
Xrthread.o: head.h
Xrthread.o: intrp.h
Xrthread.o: kfile.h
Xrthread.o: ng.h
Xrthread.o: ngdata.h
Xrthread.o: nntp.h
Xrthread.o: nntpclient.h
Xrthread.o: rcln.h
Xrthread.o: rcstuff.h
Xrthread.o: rt-mt.h
Xrthread.o: rt-ov.h
Xrthread.o: rt-page.h
Xrthread.o: rt-process.h
Xrthread.o: rt-select.h
Xrthread.o: rt-util.h
Xrthread.o: rt-wumpus.h
Xrthread.o: rthread.c
Xrthread.o: rthread.h
Xrthread.o: search.h
Xrthread.o: trn.h
Xrthread.o: util.h
Xsearch.o: EXTERN.h
Xsearch.o: INTERN.h
Xsearch.o: common.h
Xsearch.o: config.h
Xsearch.o: search.c
Xsearch.o: search.h
Xsearch.o: util.h
Xstrftime.o: EXTERN.h
Xstrftime.o: common.h
Xstrftime.o: config.h
Xstrftime.o: strftime.c
Xsw.o: EXTERN.h
Xsw.o: INTERN.h
Xsw.o: cache.h
Xsw.o: common.h
Xsw.o: config.h
Xsw.o: head.h
Xsw.o: intrp.h
Xsw.o: ng.h
Xsw.o: only.h
Xsw.o: rt-page.h
Xsw.o: rt-util.h
Xsw.o: search.h
Xsw.o: sw.c
Xsw.o: sw.h
Xsw.o: term.h
Xsw.o: util.h
Xterm.o: EXTERN.h
Xterm.o: INTERN.h
Xterm.o: cache.h
Xterm.o: common.h
Xterm.o: config.h
Xterm.o: final.h
Xterm.o: help.h
Xterm.o: intrp.h
Xterm.o: term.c
Xterm.o: term.h
Xterm.o: util.h
Xtrn.o: EXTERN.h
Xtrn.o: INTERN.h
Xtrn.o: addng.h
Xtrn.o: cache.h
Xtrn.o: common.h
Xtrn.o: config.h
Xtrn.o: final.h
Xtrn.o: help.h
Xtrn.o: init.h
Xtrn.o: intrp.h
Xtrn.o: kfile.h
Xtrn.o: last.h
Xtrn.o: ng.h
Xtrn.o: ngdata.h
Xtrn.o: ngsrch.h
Xtrn.o: ngstuff.h
Xtrn.o: nntp.h
Xtrn.o: nntpclient.h
Xtrn.o: only.h
Xtrn.o: patchlevel.h
Xtrn.o: rcln.h
Xtrn.o: rcstuff.h
Xtrn.o: search.h
Xtrn.o: sw.h
Xtrn.o: term.h
Xtrn.o: trn.c
Xtrn.o: trn.h
Xtrn.o: util.h
Xunipatch.o: unipatch.c
Xunship.o: EXTERN.h
Xunship.o: common.h
Xunship.o: config.h
Xunship.o: decode.h
Xunship.o: respond.h
Xunship.o: unship.c
Xutil.o: EXTERN.h
Xutil.o: INTERN.h
Xutil.o: common.h
Xutil.o: config.h
Xutil.o: final.h
Xutil.o: term.h
Xutil.o: util.c
Xutil.o: util.h
Xuudecode.o: EXTERN.h
Xuudecode.o: common.h
Xuudecode.o: config.h
Xuudecode.o: decode.h
Xuudecode.o: respond.h
Xuudecode.o: uudecode.c
XMakefile: Makefile.SH config.sh ; /bin/sh Makefile.SH
XPnews: Pnews.SH config.sh ; /bin/sh Pnews.SH
XRnmail: Rnmail.SH config.sh ; /bin/sh Rnmail.SH
XSpeller: Speller.SH config.sh ; /bin/sh Speller.SH
Xconfig.h: config.h.SH config.sh ; /bin/sh config.h.SH
Xmakedepend: makedepend.SH config.sh ; /bin/sh makedepend.SH
Xmakedir: makedir.SH config.sh ; /bin/sh makedir.SH
Xmbox.saver: mbox.saver.SH config.sh ; /bin/sh mbox.saver.SH
Xnewsetup: newsetup.SH config.sh ; /bin/sh newsetup.SH
Xnewsgroups: newsgroups.SH config.sh ; /bin/sh newsgroups.SH
Xnewsnews: newsnews.SH config.sh ; /bin/sh newsnews.SH
Xnorm.saver: norm.saver.SH config.sh ; /bin/sh norm.saver.SH
X# WARNING: Put nothing here or make depend will gobble it up!
END_OF_FILE
if test 14214 -ne `wc -c <'dependencies'`; then
    echo shar: \"'dependencies'\" unpacked with wrong size!
fi
# end of 'dependencies'
fi
if test -f 'rt-util.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rt-util.c'\"
else
echo shar: Extracting \"'rt-util.c'\" \(13147 characters\)
sed "s/^X//" >'rt-util.c' <<'END_OF_FILE'
X/* $Id: rt-util.c,v 3.0 1992/12/14 00:14:12 davison Trn $
X*/
X/* The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "cache.h"
X#include "ngdata.h"
X#include "artio.h"
X#include "rthread.h"
X#include "rt-select.h"
X#include "term.h"
X#include "INTERN.h"
X#include "rt-util.h"
X
X/* Name-munging routines written by Ross Ridge.
X** Enhanced by Wayne Davison.
X*/
X
X/* Extract the full-name part of an email address, returning NULL if not
X** found.
X*/
Xchar *
Xextract_name(name)
Xchar *name;
X{
X    char *s;
X    char *lparen, *rparen;
X    char *langle;
X
X    while (isspace(*name)) {
X	name++;
X    }
X
X    lparen = index(name, '(');
X    rparen = rindex(name, ')');
X    langle = index(name, '<');
X    if (!lparen && !langle) {
X	return NULL;
X    } else
X    if (langle && (!lparen || !rparen || lparen > langle || rparen < langle)) {
X	if (langle == name) {
X	    return NULL;
X	}
X	*langle = '\0';
X    } else {
X	name = lparen;
X	*name++ = '\0';
X	while (isspace(*name)) {
X	    name++;
X	}
X	if (name == rparen) {
X	    return NULL;
X	}
X	if (rparen != NULL) {
X	    *rparen = '\0';
X	}
X    }
X
X    if (*name == '"') {
X	name++;
X	while (isspace(*name)) {
X	    name++;
X	}
X	if ((s = rindex(name, '"')) != NULL) {
X	    *s = '\0';
X	}
X    }
X    return name;
X}
X
X/* If necessary, compress a net user's full name by playing games with
X** initials and the middle name(s).  If we start with "Ross Douglas Ridge"
X** we try "Ross D Ridge", "Ross Ridge", "R D Ridge" and finally "R Ridge"
X** before simply truncating the thing.  We also turn "R. Douglas Ridge"
X** into "Douglas Ridge" and "Ross Ridge D.D.S." into "Ross Ridge" as a
X** first step of the compaction, if needed.
X*/
Xchar *
Xcompress_name(name, max)
Xchar *name;
Xint max;
X{
X    register char *s, *last, *mid, *d;
X    register int len, namelen, midlen;
X    int notlast;
X
X    /* First remove white space from both ends. */
X    while (isspace(*name)) {
X	name++;
X    }
X    if ((len = strlen(name)) == 0) {
X	return name;
X    }
X    s = name + len - 1;
X    while (isspace(*s)) {
X	s--;
X    }
X    s[1] = '\0';
X    if (s - name + 1 <= max) {
X	return name;
X    }
X
X    /* Look for characters that likely mean the end of the name
X    ** and the start of some hopefully uninteresting additional info.
X    ** Spliting at a comma is somewhat questionalble, but since
X    ** "Ross Ridge, The Great HTMU" comes up much more often than 
X    ** "Ridge, Ross" and since "R HTMU" is worse than "Ridge" we do
X    ** it anyways.
X    */
X    for (d = name + 1; *d; d++) {
X	if (*d == ',' || *d == ';' || *d == '(' || *d == '@'
X	 || (*d == '-' && (d[1] == '-' || d[1] == ' '))) {
X	    *d-- = '\0';
X	    s = d;
X	    break;
X	}
X    }
X
X    /* Find the last name */
X    do {
X	notlast = 0;
X	while (isspace(*s)) {
X	    s--;
X	}
X	s[1] = '\0';
X	len = s - name + 1;
X	if (len <= max) {
X	    return name;
X	}
X	/* If the last name is an abbreviation it's not the one we want. */
X	if (*s == '.')
X	    notlast = 1;
X	while (!isspace(*s)) {
X	    if (s == name) {	/* only one name */
X		name[max] = '\0';
X		return name;
X	    }
X	    if (isdigit(*s)) {	/* probably a phone number */
X		notlast = 1;	/* so chuck it */
X	    }
X	    s--;
X	}
X    } while (notlast);
X
X    last = s-- + 1;
X
X    /* Look for a middle name */
X    while (isspace(*s)) {	/* get rid of any extra space */
X	len--;	
X	s--;
X    }
X    mid = name;
X    while (!isspace(*mid)) {
X	mid++;
X    }
X    namelen = mid - name + 1;
X    if (mid == s+1) {	/* no middle name */
X	mid = 0;
X    } else {
X	*mid++ = '\0';
X	while (isspace(*mid)) {
X	    len--;
X	    mid++;
X	}
X	midlen = s - mid + 2;
X	/* If first name is an initial and middle isn't and it all fits
X	** without the first initial, drop it. */
X	if (len > max && mid != s && mid[1] != '.'
X	 && (!name[1] || (name[1] == '.' && !name[2]))
X	 && len - namelen <= max) {
X	    len -= namelen;
X	    name = mid;
X	    mid = 0;
X	}
X    }
X    s[1] = '\0';
X    if (mid && len > max) {
X	/* Turn middle names into intials */
X	len -= s - mid + 2;
X	d = s = mid;
X	while (*s) {
X	    if (isalpha(*s)) {
X		if (d != mid) {
X		    *d++ = ' ';
X		}
X		*d++ = *s++;
X	    }
X	    while (*s && !isspace(*s)) {
X		s++;
X	    }
X	    while (isspace(*s)) {
X		s++;
X	    }
X	}
X	if (d != mid) {
X	    *d = '\0';
X	    midlen = d - mid + 1;
X	    len += midlen;
X	} else {
X	    mid = 0;
X	}
X    }
X    if (len > max) {
X	/* If the first name fits without the middle initials, drop them */
X	if (mid && len - midlen <= max) {
X	    len -= midlen;
X	    mid = 0;
X	} else {
X	    /* Turn the first name into an initial */
X	    len -= namelen - 2;
X	    name[1] = '\0';
X	    namelen = 2;
X	    if (len > max) {
X		/* Dump the middle initials (if present) */
X		if (mid) {
X		    len -= midlen;
X		    mid = 0;
X		}
X		if (len > max) {
X		    /* Finally just truncate the last name */
X		    last[max - 2] = '\0';
X		}
X	    }
X	}
X    }
X
X    /* Paste the names back together */
X    d = name + namelen;
X    if (mid) {
X	d[-1] = ' ';
X	strcpy(d, mid);
X	d += midlen;
X    }
X    d[-1] = ' ';
X    strcpy(d, last);
X    return name;
X}
X
X/* Compress an email address, trying to keep as much of the local part of
X** the addresses as possible.  The order of precence is @ ! %, but
X** @ % ! may be better...
X*/
Xstatic char *
Xcompress_address(name, max)
Xchar *name;
Xint max;
X{
X    char *s, *at, *bang, *hack, *start;
X    int len;
X
X    /* Remove white space from both ends. */
X    while (isspace(*name)) {
X	name++;
X    }
X    if ((len = strlen(name)) == 0) {
X	return name;
X    }
X    s = name + len - 1;
X    while (isspace(*s)) {
X	s--;
X    }
X    s[1] = '\0';
X    if (*name == '<') {
X	name++;
X	if (*s == '>') {
X	    *s-- = '\0';
X	}
X    }
X    if ((len = s - name + 1) <= max) {
X	return name;
X    }
X
X    at = bang = hack = NULL;
X    for (s = name + 1; *s; s++) {
X	/* If there's whitespace in the middle then it's probably not
X	** really an email address. */
X	if (isspace(*s)) {
X	    name[max] = '\0';
X	    return name;
X	}
X	switch (*s) {
X	case '@':
X	    if (at == NULL) {
X		at = s;
X	    }
X	    break;
X	case '!':
X	    if (at == NULL) {
X		bang = s;
X		hack = NULL;
X	    }
X	    break;
X	case '%':
X	    if (at == NULL && hack == NULL) {
X		hack = s;
X	    }
X	    break;
X	}
X    }
X    if (at == NULL) {
X	at = name + len;
X    }
X
X    if (hack != NULL) {
X	if (bang != NULL) {
X	    if (at - bang - 1 >= max) {
X		start = bang + 1;
X	    } else if (at - name >= max) {
X		start = at - max;
X	    } else {
X		start = name;
X	    }
X	} else {
X	    start = name;
X	}
X    } else if (bang != NULL) {
X	if (at - name >= max) {
X	    start = at - max;
X	} else {
X	    start = name;
X	}
X    } else {
X	start = name;
X    }
X    if (len - (start - name) > max) {
X	start[max] = '\0';
X    }
X    return start;
X}
X
X/* Fit the author name in <max> chars.  Uses the comment portion if present
X** and pads with spaces.
X*/
Xchar *
Xcompress_from(ap, size)
XARTICLE *ap;
Xint size;
X{
X    char *s, *t;
X    int len;
X
X    for (t = cmd_buf, s = ap && ap->from? ap->from : nullstr; *s; ) {
X	if ((unsigned char)*s < ' ')
X	    *t++ = ' ', s++;
X	else
X	    *t++ = *s++;
X    }
X    *t = '\0';
X    if ((s = extract_name(cmd_buf)) != NULL)
X	s = compress_name(s, size);
X    else
X	s = compress_address(cmd_buf, size);
X    len = strlen(s);
X    if (!len) {
X	strcpy(s,"NO NAME");
X	len = 7;
X    }
X    while (len < size)
X	s[len++] = ' ';
X    s[size] = '\0';
X    return s;
X}
X
X#define EQ(x,y) ((isupper(x) ? tolower(x) : (x)) == (y))
X
X/* Parse the subject to skip past any "Re[:^]"s at the start.
X*/
Xchar *
Xget_subject_start(str)
Xregister char *str;
X{
X    while (*str && (unsigned char)*str <= ' ')
X	str++;
X    while (EQ(str[0], 'r') && EQ(str[1], 'e')) {	/* check for Re: */
X      register char *cp = str + 2;
X	if (*cp == '^') {				/* allow Re^2: */
X	    while (*++cp <= '9' && *cp >= '0')
X		;
X	}
X	if (*cp != ':')
X	    break;
X	while (*++cp == ' ')
X	    ;
X	str = cp;
X    }
X    return str;
X}
X
X/* Output a subject in <max> chars.  Does intelligent trimming that tries to
X** save the last two words on the line, excluding "(was: blah)" if needed.
X*/
Xchar *
Xcompress_subj(ap, max)
XARTICLE *ap;
Xint max;
X{
X    register char *cp;
X    register int len;
X    ARTICLE *first;
X
X    if (!ap)
X	return "<MISSING>";
X
X    /* Put a preceeding '>' on subjects that are replies to other articles */
X    cp = buf;
X    first = (ThreadedGroup? ap->subj->thread : ap->subj->articles);
X    if (ap != first || (ap->flags & AF_HAS_RE)
X     || !(!(ap->flags&AF_READ) ^ sel_rereading))
X	*cp++ = '>';
X    strcpy(cp, ap->subj->str + 4);
X
X    /* Remove "(was: oldsubject)", because we already know the old subjects.
X    ** Also match "(Re: oldsubject)".  Allow possible spaces after the ('s.
X    */
X    for (cp = buf; (cp = index(cp+1, '(')) != Nullch;) {
X	while (*++cp == ' ')
X	    ;
X	if (EQ(cp[0], 'w') && EQ(cp[1], 'a') && EQ(cp[2], 's')
X	 && (cp[3] == ':' || cp[3] == ' ')) {
X	    *--cp = '\0';
X	    break;
X	}
X	if (EQ(cp[0], 'r') && EQ(cp[1], 'e')
X	 && ((cp[2]==':' && cp[3]==' ') || (cp[2]=='^' && cp[4]==':'))) {
X	    *--cp = '\0';
X	    break;
X	}
X    }
X    len = strlen(buf);
X    if (!unbroken_subjects && len > max) {
X	char *last_word;
X	/* Try to include the last two words on the line while trimming */ 
X	if ((last_word = rindex(buf, ' ')) != Nullch) {
X	    char *next_to_last;
X	    *last_word = '\0';
X	    if ((next_to_last = rindex(buf, ' ')) != Nullch) {
X		if (next_to_last-buf >= len - max + 3 + 10-1)
X		    cp = next_to_last;
X		else
X		    cp = last_word;
X	    } else
X		cp = last_word;
X	    *last_word = ' ';
X	    if (cp-buf >= len - max + 3 + 10-1) {
X		sprintf(buf + max - (len-(cp-buf)+3), "...%s", cp + 1);
X		len = max;
X	    }
X	}
X    }
X    if (len > max)
X	buf[max] = '\0';
X    return buf;
X}
X
X#ifndef HAS_STRCASECMP
Xstatic unsigned char casemap[256] = {
X    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
X    0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
X    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
X    0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,
X    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
X    0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,
X    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
X    0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
X    0x40,0x61,0x62,0x63,0x64,0x65,0x66,0x67,
X    0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,
X    0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
X    0x78,0x79,0x7A,0x7B,0x5C,0x5D,0x5E,0x5F,
X    0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,
X    0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,
X    0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
X    0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,
X    0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,
X    0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,
X    0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,
X    0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,
X    0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,
X    0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,
X    0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,
X    0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF,
X    0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,
X    0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,
X    0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,
X    0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,
X    0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,
X    0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,
X    0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,
X    0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF
X};
X
Xint
Xstrcasecmp(s1, s2)
Xregister char *s1, *s2;
X{
X    do {
X	if (casemap[(unsigned)*s1++] != casemap[(unsigned)*s2])
X	    return casemap[(unsigned)s1[-1]] - casemap[(unsigned)*s2];
X    } while (*s2++ != '\0');
X    return 0;
X}
X
Xint
Xstrncasecmp(s1, s2, len)
Xregister char *s1, *s2;
Xregister int len;
X{
X    while (len--) {
X	if (casemap[(unsigned)*s1++] != casemap[(unsigned)*s2])
X	    return casemap[(unsigned)s1[-1]] - casemap[(unsigned)*s2];
X	if (*s2++ == '\0')
X	    break;
X    }
X    return 0;
X}
X#endif
X
X/* Modified version of a spinner originally found in Clifford Adams' strn. */
X
Xstatic char spinchars[] = {'|','/','-','\\'};
Xstatic int spin_place;		/* represents place in spinchars array */
Xstatic int spin_count;		/* counter for when to spin */
Xstatic int spin_level INIT(0);	/* used to allow non-interfering nested spins */
Xstatic int spin_mode;
Xstatic ART_NUM spin_art;
Xstatic ART_POS spin_tell;
X
Xvoid
Xsetspin(mode)
Xint mode;
X{
X    switch (mode) {
X    case SPIN_FOREGROUND:
X    case SPIN_BACKGROUND:
X	if (!spin_level++) {
X	    if ((spin_art = openart) != 0)
X		spin_tell = ftell(artfp);
X	    spin_count = 1;	/* not 0 to prevent immediate spin display */
X	    spin_place = 1;	/* start with slash... */
X	}
X	spin_mode = mode;
X	break;
X    case SPIN_POP:
X	if (--spin_level > 0)
X	    break;
X	/* FALL THROUGH */
X    case SPIN_OFF:
X	spin_level = 0;
X	if (spin_place > 1) {	/* we have spun at least once */
X	    putchar(spin_char); /* get rid of spin character */
X	    backspace();
X	    fflush(stdout);
X	    spin_place = 0;
X	}
X	if (spin_art) {
X	    artopen(spin_art);
X	    fseek(artfp,spin_tell,0);	/* do not screw up the pager */
X	    spin_art = 0;
X	}
X	break;
X    }
X}
X
Xvoid
Xspin(count)
Xint count;		/* modulus for the spin... */
X{
X    if (!spin_level || (!bkgnd_spinner && spin_mode == SPIN_BACKGROUND))
X	return;
X    if (!(spin_count++%count)) {
X	if (spin_mode == SPIN_FOREGROUND)
X	    putchar('.');
X	else {
X	    putchar(spinchars[spin_place++%4]);
X	    backspace();
X	}
X	fflush(stdout);
X    }
X}
END_OF_FILE
if test 13147 -ne `wc -c <'rt-util.c'`; then
    echo shar: \"'rt-util.c'\" unpacked with wrong size!
fi
# end of 'rt-util.c'
fi
if test -f 'rt-wumpus.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rt-wumpus.c'\"
else
echo shar: Extracting \"'rt-wumpus.c'\" \(13386 characters\)
sed "s/^X//" >'rt-wumpus.c' <<'END_OF_FILE'
X/* $Id: rt-wumpus.c,v 3.0 1992/12/14 00:14:00 davison Trn $
X*/
X/* The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "cache.h"
X#include "ng.h"
X#include "head.h"
X#include "util.h"
X#include "term.h"
X#include "final.h"
X#include "ngdata.h"
X#include "artio.h"
X#include "backpage.h"
X#include "rthread.h"
X#include "rt-select.h"
X#include "INTERN.h"
X#include "rt-wumpus.h"
X
Xstatic char tree_indent[] = {
X    ' ', 0,
X    ' ', ' ', ' ', ' ', 0,   ' ', ' ', ' ', ' ', 0,
X    ' ', ' ', ' ', ' ', 0,   ' ', ' ', ' ', ' ', 0,
X    ' ', ' ', ' ', ' ', 0,   ' ', ' ', ' ', ' ', 0,
X    ' ', ' ', ' ', ' ', 0,   ' ', ' ', ' ', ' ', 0,
X    ' ', ' ', ' ', ' ', 0,   ' ', ' ', ' ', ' ', 0,
X    ' ', ' ', ' ', ' ', 0,   ' ', ' ', ' ', ' ', 0,
X    ' ', ' ', ' ', ' ', 0,   ' ', ' ', ' ', ' ', 0,
X    ' ', ' ', ' ', ' ', 0,   ' ', ' ', ' ', ' ', 0,
X    ' ', ' ', ' ', ' ', 0,   ' ', ' ', ' ', ' ', 0,
X    ' ', ' ', ' ', ' ', 0,   ' ', ' ', ' ', ' ', 0,
X    ' ', ' ', ' ', ' ', 0,   ' ', ' ', ' ', ' ', 0,
X    ' ', ' ', ' ', ' ', 0,   ' ', ' ', ' ', ' ', 0,
X    ' ', ' ', ' ', ' ', 0,   ' ', ' ', ' ', ' ', 0,
X    ' ', ' ', ' ', ' ', 0,   ' ', ' ', ' ', ' ', 0
X};
X
Xchar letters[] = "123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+";
X
Xstatic ARTICLE *tree_article;
X
Xstatic int max_depth, max_line = -1;
Xstatic int first_depth, first_line;
Xstatic int my_depth, my_line;
Xstatic bool node_on_line;
Xstatic int node_line_cnt;
X
Xstatic int line_num;
Xstatic int header_indent;
X
Xstatic char *tree_lines[11];
Xstatic char tree_buff[128], *str;
X
X/* Prepare tree display for inclusion in the article header.
X*/
Xvoid
Xinit_tree()
X{
X    ARTICLE *thread;
X    SUBJECT *sp;
X    int num;
X
X    while (max_line >= 0)		/* free any previous tree data */
X	free(tree_lines[max_line--]);
X
X    if (!(tree_article = curr_artp) || !tree_article->subj)
X	return;
X    if (!(thread = tree_article->subj->thread))
X	return;
X    /* Enumerate our subjects for display */
X    sp = thread->subj;
X    num = 0;
X    do {
X	sp->misc = num++;
X	sp = sp->thread_link;
X    } while (sp != thread->subj);
X
X    max_depth = max_line = my_depth = my_line = node_line_cnt = 0;
X    find_depth(thread, 0);
X
X    if (max_depth <= 5) {
X	first_depth = 0;
X    } else {
X	if (my_depth+2 > max_depth) {
X	    first_depth = max_depth - 5;
X	} else if ((first_depth = my_depth - 3) < 0) {
X	    first_depth = 0;
X	}
X	max_depth = first_depth + 5;
X    }
X    if (--max_line < max_tree_lines) {
X	first_line = 0;
X    } else {
X	if (my_line + max_tree_lines/2 > max_line) {
X	    first_line = max_line - (max_tree_lines-1);
X	} else if ((first_line = my_line - (max_tree_lines-1)/2) < 0) {
X	    first_line = 0;
X	}
X	max_line = first_line + max_tree_lines-1;
X    }
X
X    str = tree_buff;		/* initialize first line's data */
X    *str++ = ' ';
X    node_on_line = FALSE;
X    line_num = 0;
X    /* cache our portion of the tree */
X    cache_tree(thread, 0, tree_indent);
X
X    max_depth = (max_depth-first_depth) * 5;	/* turn depth into char width */
X    max_line -= first_line;			/* turn max_line into count */
X    /* shorten tree if lower lines aren't visible */
X    if (node_line_cnt < max_line) {
X	max_line = node_line_cnt + 1;
X    }
X}
X
X/* A recursive routine to find the maximum tree extents and where we are.
X*/
Xstatic void
Xfind_depth(article, depth)
XARTICLE *article;
Xint depth;
X{
X    if (depth > max_depth) {
X	max_depth = depth;
X    }
X    for (;;) {
X	if (article == tree_article) {
X	    my_depth = depth;
X	    my_line = max_line;
X	}
X	if (article->child1) {
X	    find_depth(article->child1, depth+1);
X	} else {
X	    max_line++;
X	}
X	if (!(article = article->sibling)) {
X	    break;
X	}
X    }
X}
X
X/* Place the tree display in a maximum of 11 lines x 6 nodes.
X*/
Xstatic void
Xcache_tree(ap, depth, cp)
XARTICLE *ap;
Xint depth;
Xchar *cp;
X{
X    int depth_mode;
X
X    cp[1] = ' ';
X    if (depth >= first_depth && depth <= max_depth) {
X	cp += 5;
X	depth_mode = 1;
X    } else if (depth+1 == first_depth) {
X	depth_mode = 2;
X    } else {
X	cp = tree_indent;
X	depth_mode = 0;
X    }
X    for (;;) {
X	switch (depth_mode) {
X	case 1: {
X	    char ch;
X
X	    *str++ = ((ap->flags & AF_HAS_RE) || ap->parent) ? '-' : ' ';
X	    if (ap == tree_article)
X		*str++ = '*';
X	    if (ap->flags & AF_READ) {
X		*str++ = '(';
X		ch = ')';
X	    } else if (!selected_only || (ap->flags & AF_SEL)) {
X		*str++ = '[';
X		ch = ']';
X	    } else {
X		*str++ = '<';
X		ch = '>';
X	    }
X	    if (ap == recent_artp && ap != tree_article)
X		*str++ = '@';
X	    *str++ = letter(ap);
X	    *str++ = ch;
X	    if (ap->child1) {
X		*str++ = (ap->child1->sibling? '+' : '-');
X	    }
X	    if (ap->sibling)
X		*cp = '|';
X	    else
X		*cp = ' ';
X	    node_on_line = TRUE;
X	    break;
X	}
X	case 2:
X	    *tree_buff = (!ap->child1)? ' ' :
X		(ap->child1->sibling)? '+' : '-';
X	    break;
X	default:
X	    break;
X	}
X	if (ap->child1) {
X	    cache_tree(ap->child1, depth+1, cp);
X	    cp[1] = '\0';
X	} else {
X	    if (!node_on_line && first_line == line_num) {
X		first_line++;
X	    }
X	    if (line_num >= first_line) {
X		if (str[-1] == ' ') {
X		    str--;
X		}
X		*str = '\0';
X		tree_lines[line_num-first_line]
X			= safemalloc(str-tree_buff + 1);
X		strcpy(tree_lines[line_num - first_line], tree_buff);
X		if (node_on_line) {
X		    node_line_cnt = line_num - first_line;
X		}
X	    }
X	    line_num++;
X	    node_on_line = FALSE;
X	}
X	if (!(ap = ap->sibling) || line_num > max_line)
X	    break;
X	if (!ap->sibling)
X	    *cp = '\\';
X	if (!first_depth)
X	    tree_indent[5] = ' ';
X	strcpy(tree_buff, tree_indent+5);
X	str = tree_buff + strlen(tree_buff);
X    }
X}
X
X/* Output a header line with possible tree display on the right hand side.
X** Does automatic wrapping of lines that are too long.
X*/
Xint
Xtree_puts(orig_line, header_line, use_underline)
Xchar *orig_line;
XART_LINE header_line;
Xint use_underline;
X{
X    char *buf;
X    register char *line, *cp, *end;
X    int pad_cnt, wrap_at;
X    ART_LINE start_line = header_line;
X    int i;
X    char ch;
X
X    /* Make a modifiable copy of the line */
X    buf = safemalloc(strlen(orig_line) + 2);  /* yes, I mean "2" */
X    strcpy(buf, orig_line);
X    line = buf;
X
X    /* Change any embedded control characters to spaces */
X    for (end = line; *end && *end != '\n'; end++) {
X	if ((unsigned char)*end < ' ') {
X	    *end = ' ';
X	}
X    }
X    *end = '\0';
X
X    if (!*line) {
X	strcpy(line, " ");
X	end = line+1;
X    }
X
X    /* If this is the first subject line, output it with a preceeding [1] */
X    if (ThreadedGroup && use_underline && (unsigned char)*line > ' ') {
X#ifdef NOFIREWORKS
X	no_sofire();
X#endif
X	standout();
X	putchar('[');
X	putchar(letter(curr_artp));
X	putchar(']');
X	un_standout();
X	putchar(' ');
X	header_indent = 4;
X	line += 9;
X	i = 0;
X    } else {
X	if (*line != ' ') {
X	    /* A "normal" header line -- output keyword and set header_indent
X	    ** _except_ for the first line, which is a non-standard header.
X	    */
X	    if (!header_line || !(cp = index(line, ':')) || *++cp != ' ') {
X		header_indent = 0;
X	    } else {
X		*cp = '\0';
X		fputs(line, stdout);
X		putchar(' ');
X		header_indent = ++cp - line;
X		line = cp;
X		if (!*line) {
X		    *--line = ' ';
X		}
X	    }
X	    i = 0;
X	} else {
X	    /* Skip whitespace of continuation lines and prepare to indent */
X	    while (*++line == ' ') {
X		;
X	    }
X	    i = header_indent;
X	}
X    }
X    for ( ; *line; i = header_indent) {
X#ifdef CLEAREOL
X	maybe_eol();
X#endif
X	if (i) {
X	    putchar('+');
X	    while (--i) {
X		putchar(' ');
X	    }
X	}
X	/* If no (more) tree lines, wrap at COLS-1 */
X	if (max_line < 0 || header_line > max_line+1) {
X	    wrap_at = COLS-1;
X	} else {
X	    wrap_at = COLS - max_depth - 5 - 3;
X	}
X	/* Figure padding between header and tree output, wrapping long lines */
X	pad_cnt = wrap_at - (end - line + header_indent);
X	if (pad_cnt <= 0) {
X	    cp = line + wrap_at - header_indent - 1;
X	    pad_cnt = 1;
X	    while (cp > line && *cp != ' ') {
X		if (*--cp == ',' || *cp == '.' || *cp == '-' || *cp == '!') {
X		    cp++;
X		    break;
X		}
X		pad_cnt++;
X	    }
X	    if (cp == line) {
X		cp += wrap_at - header_indent;
X		pad_cnt = 0;
X	    }
X	    ch = *cp;
X	    *cp = '\0';
X	    /* keep rn's backpager happy */
X	    vwtary(artline, vrdary(artline - 1));
X	    artline++;
X	} else {
X	    cp = end;
X	    ch = '\0';
X	}
X	if (use_underline) {
X	    underprint(line);
X	} else {
X	    fputs(line, stdout);
X	}
X	*cp = ch;
X	/* Skip whitespace in wrapped line */
X	while (*cp == ' ') {
X	    cp++;
X	}
X	line = cp;
X	/* Check if we've got any tree lines to output */
X	if (wrap_at != COLS-1 && header_line <= max_line) {
X	    char *cp1, *cp2;
X
X	    do {
X		putchar(' ');
X	    } while (pad_cnt--);
X	    /* Check string for the '*' flagging our current node
X	    ** and the '@' flagging our prior node.
X	    */
X	    cp = tree_lines[header_line];
X	    cp1 = index(cp, '*');
X	    cp2 = index(cp, '@');
X	    if (cp1 != Nullch) {
X		*cp1 = '\0';
X	    }
X	    if (cp2 != Nullch) {
X		*cp2 = '\0';
X	    }
X	    fputs(cp, stdout);
X	    /* Handle standout output for '*' and '@' marked nodes, then
X	    ** continue with the rest of the line.
X	    */
X	    while (cp1 || cp2) {
X		standout();
X		if (cp1 && (!cp2 || cp1 < cp2)) {
X		    cp = cp1;
X		    cp1 = Nullch;
X		    *cp++ = '*';
X		    putchar(*cp++);
X		    putchar(*cp++);
X		} else {
X		    cp = cp2;
X		    cp2 = Nullch;
X		    *cp++ = '@';
X		}
X		putchar(*cp++);
X		un_standout();
X		if (*cp) {
X		    fputs(cp, stdout);
X		}
X	    }/* while */
X	}/* if */
X	putchar('\n') FLUSH;
X	header_line++;
X    }/* for remainder of line */
X
X    /* free allocated copy of line */
X    free(buf);
X
X    /* return number of lines displayed */
X    return header_line - start_line;
X}
X
X/* Output any parts of the tree that are left to display.  Called at the
X** end of each header.
X*/
Xint
Xfinish_tree(last_line)
XART_LINE last_line;
X{
X    ART_LINE start_line = last_line;
X
X    while (last_line <= max_line) {
X	artline++;
X	last_line += tree_puts("+", last_line, 0);
X	vwtary(artline, artpos);	/* keep rn's backpager happy */
X    }
X    return last_line - start_line;
X}
X
X/* Output the entire article tree for the user.
X*/
Xvoid
Xentire_tree(ap)
XARTICLE *ap;
X{
X    ARTICLE *thread;
X    SUBJECT *sp;
X    int num;
X
X    if (!ap) {
X#ifdef VERBOSE
X	IF (verbose)
X	    fputs("\nNo article tree to display.\n", stdout) FLUSH;
X	ELSE
X#endif
X#ifdef TERSE
X	    fputs("\nNo tree.\n", stdout) FLUSH;
X#endif
X	return;
X    }
X
X    if (!ThreadedGroup) {
X	ThreadedGroup = TRUE;
X	printf("Threading the group. "), fflush(stdout);
X	thread_open();
X	if (!ThreadedGroup) {
X	    printf("*failed*\n") FLUSH;
X	    return;
X	}
X	count_subjects(CS_NORM);
X	putchar('\n') FLUSH;
X    }
X    if (!(ap->flags & AF_THREADED))
X	parseheader(article_num(ap));
X    if (check_page_line())
X	return;
X    putchar('\n');
X    thread = ap->subj->thread;
X    /* Enumerate our subjects for display */
X    sp = thread->subj;
X    num = 0;
X    do {
X	if (check_page_line())
X	    return;
X	printf("[%c] %s\n",letters[num>9+26+26? 9+26+26:num],sp->str+4) FLUSH;
X	sp->misc = num++;
X	sp = sp->thread_link;
X    } while (sp != thread->subj);
X    if (check_page_line())
X	return;
X    putchar('\n');
X    if (check_page_line())
X	return;
X    putchar(' ');
X    buf[3] = '\0';
X    display_tree(thread, tree_indent);
X
X    if (check_page_line())
X	return;
X    putchar('\n');
X}
X
X/* A recursive routine to output the entire article tree.
X*/
Xstatic void
Xdisplay_tree(article, cp)
XARTICLE *article;
Xchar *cp;
X{
X    if (cp - tree_indent > COLS || page_line < 0)
X	return;
X    cp[1] = ' ';
X    cp += 5;
X    for (;;) {
X	putchar(((article->flags&AF_HAS_RE) || article->parent) ? '-' : ' ');
X	if (article->flags & AF_READ) {
X	    buf[0] = '(';
X	    buf[2] = ')';
X	} else if (!selected_only || (article->flags & AF_SEL)) {
X	    buf[0] = '[';
X	    buf[2] = ']';
X	} else {
X	    buf[0] = '<';
X	    buf[2] = '>';
X	}
X	buf[1] = letter(article);
X	if (article == curr_artp) {
X	    standout();
X	    fputs(buf, stdout);
X	    un_standout();
X	} else if (article == recent_artp) {
X	    putchar(buf[0]);
X	    standout();
X	    putchar(buf[1]);
X	    un_standout();
X	    putchar(buf[2]);
X	} else {
X	    fputs(buf, stdout);
X	}
X
X	if (article->sibling) {
X	    *cp = '|';
X	} else {
X	    *cp = ' ';
X	}
X	if (article->child1) {
X	    putchar((article->child1->sibling)? '+' : '-');
X	    display_tree(article->child1, cp);
X	    cp[1] = '\0';
X	} else {
X	    putchar('\n') FLUSH;
X	}
X	if (!(article = article->sibling)) {
X	    break;
X	}
X	if (!article->sibling) {
X	    *cp = '\\';
X	}
X	tree_indent[5] = ' ';
X	if (check_page_line()) {
X	    return;
X	}
X	fputs(tree_indent+5, stdout);
X    }
X}
X
Xstatic int
Xcheck_page_line()
X{
X    if (page_line < 0)
X	return -1;
X    if (page_line >= LINES || int_count) {
X      register int cmd = -1;
X	if (int_count || (cmd = get_anything())) {
X	    page_line = -1;		/* disable further printing */
X	    if (cmd > 0)
X		pushchar(cmd);
X	    return cmd;
X	}
X    }
X    page_line++;
X    return 0;
X}
X
X/* Calculate the subject letter representation.  "Place-holder" nodes
X** are marked with a ' ', others get a letter in the sequence:
X**	' ', '1'-'9', 'A'-'Z', 'a'-'z', '+'
X*/
Xstatic char
Xletter(ap)
Xregister ARTICLE *ap;
X{
X    int subj = ap->subj->misc;
X
X    if (!(ap->flags & AF_CACHED)
X     && (absfirst < first_cached || last_cached < lastart
X      || !cached_all_in_range))
X	return '?';
X    if (ap->flags & AF_MISSING)
X	return ' ';
X    return letters[subj > 9+26+26 ? 9+26+26 : subj];
X}
END_OF_FILE
if test 13386 -ne `wc -c <'rt-wumpus.c'`; then
    echo shar: \"'rt-wumpus.c'\" unpacked with wrong size!
fi
# end of 'rt-wumpus.c'
fi
if test -f 'search.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'search.c'\"
else
echo shar: Extracting \"'search.c'\" \(13435 characters\)
sed "s/^X//" >'search.c' <<'END_OF_FILE'
X/* $Id: search.c,v 3.0 1992/02/01 03:09:32 davison Trn $
X */
X
X/* string search routines */
X 
X/*		Copyright (c) 1981,1980 James Gosling		*/
X 
X/* Modified Aug. 12, 1981 by Tom London to include regular expressions
X   as in ed.  RE stuff hacked over by jag to correct a few major problems,
X   mainly dealing with searching within the buffer rather than copying
X   each line to a separate array.  Newlines can now appear in RE's */
X
X/* Ripped to shreds and glued back together to make a search package,
X * July 6, 1984, by Larry Wall. (If it doesn't work, it's probably my fault.)
X * Changes include:
X *	Buffer, window, and mlisp stuff gone.
X *	Translation tables reduced to 1 table.
X *	Expression buffer is now dynamically allocated.
X *	Character classes now implemented with a bitmap.
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "util.h"
X#include "INTERN.h"
X#include "search.h"
X
X#ifndef BITSPERBYTE
X#define BITSPERBYTE 8
X#endif
X
X#define BMAPSIZ (127 / BITSPERBYTE + 1)
X
X/* meta characters in the "compiled" form of a regular expression */
X#define	CBRA	2		/* \( -- begin bracket */
X#define	CCHR	4		/* a vanilla character */
X#define	CDOT	6		/* . -- match anything except a newline */
X#define	CCL	8		/* [...] -- character class */
X#define	NCCL	10		/* [^...] -- negated character class */
X#define	CDOL	12		/* $ -- matches the end of a line */
X#define	CEND	14		/* The end of the pattern */
X#define	CKET	16		/* \) -- close bracket */
X#define	CBACK	18		/* \N -- backreference to the Nth bracketed
X				   string */
X#define CIRC	20		/* ^ matches the beginning of a line */
X
X#define WORD	32		/* matches word character \w */
X#define NWORD	34		/* matches non-word characer \W */
X#define WBOUND	36		/* matches word boundary \b */
X#define NWBOUND	38		/* matches non-(word boundary) \B */
X 
X#define	STAR	01		/* * -- Kleene star, repeats the previous
X				   REas many times as possible; the value
X				   ORs with the other operator types */
X 
X#define ASCSIZ 0200
Xtypedef char	TRANSTABLE[ASCSIZ];
X
Xstatic	TRANSTABLE trans = {
X0000,0001,0002,0003,0004,0005,0006,0007,
X0010,0011,0012,0013,0014,0015,0016,0017,
X0020,0021,0022,0023,0024,0025,0026,0027,
X0030,0031,0032,0033,0034,0035,0036,0037,
X0040,0041,0042,0043,0044,0045,0046,0047,
X0050,0051,0052,0053,0054,0055,0056,0057,
X0060,0061,0062,0063,0064,0065,0066,0067,
X0070,0071,0072,0073,0074,0075,0076,0077,
X0100,0101,0102,0103,0104,0105,0106,0107,
X0110,0111,0112,0113,0114,0115,0116,0117,
X0120,0121,0122,0123,0124,0125,0126,0127,
X0130,0131,0132,0133,0134,0135,0136,0137,
X0140,0141,0142,0143,0144,0145,0146,0147,
X0150,0151,0152,0153,0154,0155,0156,0157,
X0160,0161,0162,0163,0164,0165,0166,0167,
X0170,0171,0172,0173,0174,0175,0176,0177,
X};
Xstatic bool folding = FALSE;
X
Xstatic int err;
Xstatic char *FirstCharacter;
X
Xvoid
Xsearch_init()
X{
X#ifdef UNDEF
X    register int    i;
X    
X    for (i = 0; i < ASCSIZ; i++)
X	trans[i] = i;
X#else
X    ;
X#endif
X}
X
Xvoid
Xinit_compex(compex)
Xregister COMPEX *compex;
X{
X    /* the following must start off zeroed */
X
X    compex->eblen = 0;
X    compex->brastr = Nullch;
X}
X
Xvoid
Xfree_compex(compex)
Xregister COMPEX *compex;
X{
X    if (compex->eblen) {
X	free(compex->expbuf);
X	compex->eblen = 0;
X    }
X    if (compex->brastr) {
X	free(compex->brastr);
X	compex->brastr = Nullch;
X    }
X}
X
Xstatic char *gbr_str = Nullch;
Xstatic int gbr_siz = 0;
X
Xchar *
Xgetbracket(compex,n)
Xregister COMPEX *compex;
Xint n;
X{
X    int length = compex->braelist[n] - compex->braslist[n];
X
X    if (!compex->nbra)
X	return Nullch;
X    if (n > compex->nbra || !compex->braelist[n] || length < 0)
X	return nullstr;
X    growstr(&gbr_str, &gbr_siz, length+1);
X    safecpy(gbr_str, compex->braslist[n], length+1);
X    return gbr_str;
X}
X
Xvoid
Xcase_fold(which)
Xint which;
X{
X    register int i;
X
X    if (which != folding) {
X	if (which) {
X	    for (i = 'A'; i <= 'Z'; i++)
X		trans[i] = tolower(i);
X	}
X	else {
X	    for (i = 'A'; i <= 'Z'; i++)
X		trans[i] = i;
X	}
X	folding = which;
X    }
X}
X
X/* Compile the given regular expression into a [secret] internal format */
X
Xchar *
Xcompile(compex, strp, RE, fold)
Xregister COMPEX *compex;
Xregister char   *strp;
Xint RE;
Xint fold;
X{
X    register int c;
X    register char  *ep;
X    char   *lastep;
X    char    bracket[NBRA],
X	   *bracketp;
X    char **alt = compex->alternatives;
X    char *retmes = "Badly formed search string";
X 
X    case_fold(compex->do_folding = fold);
X    if (!compex->eblen) {
X	compex->expbuf = safemalloc(84);
X	compex->eblen = 80;
X    }
X    ep = compex->expbuf;		/* point at expression buffer */
X    *alt++ = ep;			/* first alternative starts here */
X    bracketp = bracket;			/* first bracket goes here */
X    if (*strp == 0) {			/* nothing to compile? */
X	if (*ep == 0)			/* nothing there yet? */
X	    return "Null search string";
X	return Nullch;			/* just keep old expression */
X    }
X    compex->nbra = 0;			/* no brackets yet */
X    lastep = 0;
X    for (;;) {
X	if (ep + 4 - compex->expbuf >= compex->eblen)
X	    ep = grow_eb(compex, ep, alt);
X	c = *strp++;			/* fetch next char of pattern */
X	if (c == 0) {			/* end of pattern? */
X	    if (bracketp != bracket) {	/* balanced brackets? */
X#ifdef VERBOSE
X		retmes = "Unbalanced parens";
X#endif
X		goto cerror;
X	    }
X	    *ep++ = CEND;		/* terminate expression */
X	    *alt++ = 0;			/* terminal alternative list */
X	    return Nullch;		/* return success */
X	}
X	if (c != '*')
X	    lastep = ep;
X	if (!RE) {			/* just a normal search string? */
X	    *ep++ = CCHR;		/* everything is a normal char */
X	    *ep++ = c;
X	}
X	else				/* it is a regular expression */
X	    switch (c) {
X 
X		case '\\':		/* meta something */
X		    switch (c = *strp++) {
X		    case '(':
X			if (compex->nbra >= NBRA) {
X#ifdef VERBOSE
X			    retmes = "Too many parens";
X#endif
X			    goto cerror;
X			}
X			*bracketp++ = ++compex->nbra;
X			*ep++ = CBRA;
X			*ep++ = compex->nbra;
X			break;
X		    case '|':
X			if (bracketp>bracket) {
X#ifdef VERBOSE
X			    retmes = "No \\| in parens";	/* Alas! */
X#endif
X			    goto cerror;
X			}
X			*ep++ = CEND;
X			*alt++ = ep;
X			break;
X		    case ')':
X			if (bracketp <= bracket) {
X#ifdef VERBOSE
X			    retmes = "Unmatched right paren";
X#endif
X			    goto cerror;
X			}
X			*ep++ = CKET;
X			*ep++ = *--bracketp;
X			break;
X		    case 'w':
X			*ep++ = WORD;
X			break;
X		    case 'W':
X			*ep++ = NWORD;
X			break;
X		    case 'b':
X			*ep++ = WBOUND;
X			break;
X		    case 'B':
X			*ep++ = NWBOUND;
X			break;
X		    case '0': case '1': case '2': case '3': case '4':
X		    case '5': case '6': case '7': case '8': case '9':
X			*ep++ = CBACK;
X			*ep++ = c - '0';
X			break;
X		    default:
X			*ep++ = CCHR;
X			if (c == '\0')
X			    goto cerror;
X			*ep++ = c;
X			break;
X		    }
X		    break;
X		case '.':
X		    *ep++ = CDOT;
X		    continue;
X 
X		case '*':
X		    if (lastep == 0 || *lastep == CBRA || *lastep == CKET
X			|| *lastep == CIRC
X			|| (*lastep&STAR)|| *lastep>NWORD)
X			goto defchar;
X		    *lastep |= STAR;
X		    continue;
X 
X		case '^':
X		    if (ep != compex->expbuf && ep[-1] != CEND)
X			goto defchar;
X		    *ep++ = CIRC;
X		    continue;
X 
X		case '$':
X		    if (*strp != 0 && (*strp != '\\' || strp[1] != '|'))
X			goto defchar;
X		    *ep++ = CDOL;
X		    continue;
X 
X		case '[': {		/* character class */
X		    register int i;
X		    
X		    if (ep - compex->expbuf >= compex->eblen - BMAPSIZ)
X			ep = grow_eb(compex, ep, alt); /* reserve bitmap */
X
X		    for (i = BMAPSIZ; i; --i)
X			ep[i] = 0;
X		    
X		    if ((c = *strp++) == '^') {
X			c = *strp++;
X			*ep++ = NCCL;	/* negated */
X		    }
X		    else
X			*ep++ = CCL;	/* normal */
X		    
X		    i = 0;		/* remember oldchar */
X		    do {
X			if (c == '\0') {
X#ifdef VERBOSE
X			    retmes = "Missing ]";
X#endif
X			    goto cerror;
X			}
X			if (*strp == '-' && *(++strp) != ']' && *strp)
X			    i = *strp++;
X			else
X			    i = c;
X			while (c <= i) {
X			    ep[c / BITSPERBYTE] |= 1 << (c % BITSPERBYTE);
X			    if (fold && isalpha(c))
X				ep[(c ^ 32) / BITSPERBYTE] |=
X				    1 << ((c ^ 32) % BITSPERBYTE);
X					/* set the other bit too */
X			    c++;
X			}
X		    } while ((c = *strp++) != ']');
X		    ep += BMAPSIZ;
X		    continue;
X		}
X 
X	    defchar:
X		default:
X		    *ep++ = CCHR;
X		    *ep++ = c;
X	    }
X    }
Xcerror:
X    compex->expbuf[0] = 0;
X    compex->nbra = 0;
X    return retmes;
X}
X
Xchar *
Xgrow_eb(compex, epp, alt)
Xregister COMPEX *compex;
Xchar *epp;
Xchar **alt;
X{
X    register char *oldbuf = compex->expbuf;
X    register char **altlist = compex->alternatives;
X
X    compex->eblen += 80;
X    compex->expbuf = saferealloc(compex->expbuf, (MEM_SIZE)compex->eblen + 4);
X    if (compex->expbuf != oldbuf) {	/* realloc can change expbuf! */
X	epp += compex->expbuf - oldbuf;
X	while (altlist != alt)
X	    *altlist++ += compex->expbuf - oldbuf; 
X    }
X    return epp;
X}
X
Xchar *
Xexecute(compex, addr)
Xregister COMPEX *compex;
Xchar *addr;
X{
X    register char *p1 = addr;
X    register char *trt = trans;
X    register int c;
X 
X    if (addr == Nullch || compex->expbuf == Nullch)
X	return Nullch;
X    if (compex->nbra) {			/* any brackets? */
X	for (c = 0; c <= compex->nbra; c++)
X	    compex->braslist[c] = compex->braelist[c] = Nullch;
X	if (compex->brastr)
X	    free(compex->brastr);
X	compex->brastr = savestr(p1);	/* in case p1 is not static */
X	p1 = compex->brastr;		/* ! */
X    }
X    case_fold(compex->do_folding);	/* make sure table is correct */
X    FirstCharacter = p1;		/* for ^ tests */
X    if (compex->expbuf[0] == CCHR && !compex->alternatives[1]) {
X	c = trt[compex->expbuf[1]];	/* fast check for first character */
X	do {
X	    if (trt[*p1] == c && advance(compex, p1, compex->expbuf))
X		return p1;
X	    p1++;
X	} while (*p1 && !err);
X	if (err) err = 0;
X	return Nullch;
X    }
X    else {			/* regular algorithm */
X	do {
X	    register char **alt = compex->alternatives;
X	    while (*alt) {
X		if (advance(compex, p1, *alt++))
X		    return p1;
X	    }
X	    p1++;
X	} while (*p1 && !err);
X	if (err) err = 0;
X	return Nullch;
X    }
X   /*NOTREACHED*/
X}
X 
X/* advance the match of the regular expression starting at ep along the
X   string lp, simulates an NDFSA */
Xbool
Xadvance(compex, lp, ep)
Xregister COMPEX *compex;
Xregister char *ep;
Xregister char *lp;
X{
X    register char *curlp;
X    register char *trt = trans;
X    register int i;
X 
X    while ((*ep & STAR) || *lp || *ep == CIRC || *ep == CKET)
X	switch (*ep++) {
X 
X	    case CCHR:
X		if (trt[*ep++] != trt[*lp]) return FALSE;
X		lp++;
X		continue;
X 
X	    case CDOT:
X		if (*lp == '\n') return FALSE;
X		lp++;
X		continue;
X 
X	    case CDOL:
X		if (!*lp || *lp == '\n')
X		    continue;
X		return FALSE;
X 
X	    case CIRC:
X		if (lp == FirstCharacter || lp[-1]=='\n')
X		    continue;
X		return FALSE;
X 
X	    case WORD:
X		if (isalnum(*lp)) {
X		    lp++;
X		    continue;
X		}
X		return FALSE;
X 
X	    case NWORD:
X		if (!isalnum(*lp)) {
X		    lp++;
X		    continue;
X		}
X		return FALSE;
X 
X	    case WBOUND:
X		if ((lp == FirstCharacter || !isalnum(lp[-1])) !=
X			(!*lp || !isalnum(*lp)) )
X		    continue;
X		return FALSE;
X 
X	    case NWBOUND:
X		if ((lp == FirstCharacter || !isalnum(lp[-1])) ==
X			(!*lp || !isalnum(*lp)))
X		    continue;
X		return FALSE;
X 
X	    case CEND:
X		return TRUE;
X 
X	    case CCL:
X		if (cclass(ep, *lp, 1)) {
X		    ep += BMAPSIZ;
X		    lp++;
X		    continue;
X		}
X		return FALSE;
X 
X	    case NCCL:
X		if (cclass(ep, *lp, 0)) {
X		    ep += BMAPSIZ;
X		    lp++;
X		    continue;
X		}
X		return FALSE;
X 
X	    case CBRA:
X		compex->braslist[*ep++] = lp;
X		continue;
X 
X	    case CKET:
X		i = *ep++;
X		compex->braelist[i] = lp;
X		compex->braelist[0] = lp;
X		compex->braslist[0] = compex->braslist[i];
X		continue;
X 
X	    case CBACK:
X		if (compex->braelist[i = *ep++] == 0) {
X		    fputs("bad braces\n",stdout) FLUSH;
X		    err = TRUE;
X		    return FALSE;
X		}
X		if (backref(compex, i, lp)) {
X		    lp += compex->braelist[i] - compex->braslist[i];
X		    continue;
X		}
X		return FALSE;
X 
X	    case CBACK | STAR:
X		if (compex->braelist[i = *ep++] == 0) {
X		    fputs("bad braces\n",stdout) FLUSH;
X		    err = TRUE;
X		    return FALSE;
X		}
X		curlp = lp;
X		while (backref(compex, i, lp)) {
X		    lp += compex->braelist[i] - compex->braslist[i];
X		}
X		while (lp >= curlp) {
X		    if (advance(compex, lp, ep))
X			return TRUE;
X		    lp -= compex->braelist[i] - compex->braslist[i];
X		}
X		continue;
X 
X	    case CDOT | STAR:
X		curlp = lp;
X		while (*lp++ && lp[-1] != '\n');
X		goto star;
X 
X	    case WORD | STAR:
X		curlp = lp;
X		while (*lp++ && isalnum(lp[-1]));
X		goto star;
X 
X	    case NWORD | STAR:
X		curlp = lp;
X		while (*lp++ && !isalnum(lp[-1]));
X		goto star;
X 
X	    case CCHR | STAR:
X		curlp = lp;
X		while (*lp++ && trt[lp[-1]] == trt[*ep]);
X		ep++;
X		goto star;
X 
X	    case CCL | STAR:
X	    case NCCL | STAR:
X		curlp = lp;
X		while (*lp++ && cclass(ep, lp[-1], ep[-1] == (CCL | STAR)));
X		ep += BMAPSIZ;
X		goto star;
X 
X	star:
X		do {
X		    lp--;
X		    if (advance(compex, lp, ep))
X			return TRUE;
X		} while (lp > curlp);
X		return FALSE;
X 
X	    default:
X		fputs("Badly compiled pattern\n",stdout) FLUSH;
X		err = TRUE;
X		return -1;
X	}
X    if (*ep == CEND || *ep == CDOL || *ep == WBOUND) {
X	return TRUE;
X    }
X    return FALSE;
X}
X 
Xbool
Xbackref(compex, i, lp)
Xregister COMPEX *compex;
Xregister int i;
Xregister char *lp;
X{
X    register char *bp;
X 
X    bp = compex->braslist[i];
X    while (*lp && *bp == *lp) {
X	bp++;
X	lp++;
X	if (bp >= compex->braelist[i])
X	    return TRUE;
X    }
X    return FALSE;
X}
X
Xbool
Xcclass(set, c, af)
Xregister char  *set;
Xregister int c;
Xint af;
X{
X    c &= 0177;
X#if BITSPERBYTE == 8
X    if (set[c >> 3] & 1 << (c & 7))
X#else
X    if (set[c / BITSPERBYTE] & 1 << (c % BITSPERBYTE))
X#endif
X	return af;
X    return !af;
X}
END_OF_FILE
if test 13435 -ne `wc -c <'search.c'`; then
    echo shar: \"'search.c'\" unpacked with wrong size!
fi
# end of 'search.c'
fi
if test -f 'sw.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sw.c'\"
else
echo shar: Extracting \"'sw.c'\" \(14030 characters\)
sed "s/^X//" >'sw.c' <<'END_OF_FILE'
X/* $Id: sw.c,v 3.0 1992/02/01 03:09:32 davison Trn $
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "util.h"
X#include "cache.h"
X#include "head.h"
X#include "only.h"
X#include "term.h"
X#include "ng.h"
X#include "intrp.h"
X#include "rt-page.h"
X#include "rt-util.h"
X#include "INTERN.h"
X#include "sw.h"
X
Xvoid
Xsw_init(argc,argv,tcbufptr)
Xint argc;
Xchar *argv[];
Xchar **tcbufptr;
X{
X    register int i;
X
X    if (argc >= 2 && strEQ(argv[1],"-c"))
X	checkflag=TRUE;			/* so we can optimize for -c */
X    interp(*tcbufptr,1024,GLOBINIT);
X    sw_file(tcbufptr,FALSE);
X    if (!use_threads || !*safecpy(*tcbufptr,getenv("TRNINIT"),1024))
X	safecpy(*tcbufptr,getenv("RNINIT"),1024);
X    if (**tcbufptr) {
X	if (**tcbufptr == '/') {
X	    sw_file(tcbufptr,TRUE);
X	}
X	else
X	    sw_list(*tcbufptr);
X    }
X
X    for (i = 1; i < argc; i++)
X	decode_switch(argv[i]);
X}
X
Xvoid
Xsw_file(tcbufptr,bleat)
Xchar **tcbufptr;
Xbool_int bleat;
X{
X    int initfd = open(*tcbufptr,0);
X	
X    if (initfd >= 0) {
X	fstat(initfd,&filestat);
X	if (filestat.st_size > 1024)
X	    *tcbufptr = saferealloc(*tcbufptr,(MEM_SIZE)filestat.st_size);
X	if (filestat.st_size) {
X	    read(initfd,*tcbufptr,(int)filestat.st_size);
X	    (*tcbufptr)[filestat.st_size-1] = '\0';
X				/* wipe out last newline */
X	    sw_list(*tcbufptr);
X	}
X	else
X	    **tcbufptr = '\0';
X	close(initfd);
X    }
X    else {
X	if (bleat)
X	    printf(cantopen,*tcbufptr) FLUSH;
X	**tcbufptr = '\0';
X    }
X}
X
X/* decode a list of space separated switches */
X
Xvoid
Xsw_list(swlist)
Xchar *swlist;
X{
X    char *tmplist = safemalloc((MEM_SIZE) strlen(swlist) + 2);
X					/* semi-automatic string */
X    register char *s, *p, inquote = 0;
X
X    strcpy(tmplist,swlist);
X    p = tmplist;
X    for (s = p;;) {
X	while (isspace(*s)) s++;	/* skip any initial spaces */
X	if (*s != '#') {
X	    if (s != p)
X		strcpy(p, s);
X	    break;
X	}
X	while (*s && *s++ != '\n') ;	/* skip comments */
X    }
X    while (*p) {			/* "String, or nothing" */
X	if (!inquote && isspace(*p)) {	/* word delimiter? */
X	    *p++ = '\0';		/* chop here */
X	    for (s = p;;) {
X		while (isspace(*s)) s++;
X		if (*s != '#') {
X		    if (s != p)
X			strcpy(p, s);
X		    break;
X		}
X		while (*s && *s++ != '\n') ;
X	    }
X	}
X	else if (inquote == *p) {
X	    strcpy(p,p+1);		/* delete trailing quote */
X	    inquote = 0;		/* no longer quoting */
X	}
X	else if (!inquote && (*p == '"' || *p == '\'')) {
X					/* OK, I know when I am not wanted */
X	    inquote = *p;		/* remember single or double */
X	    strcpy(p,p+1);		/* delete the quote */
X	}				/* (crude, but effective) */
X	else if (*p == '\\') {		/* quoted something? */
X	    if (p[1] == '\n')		/* newline? */
X		strcpy(p,p+2);		/* "I didn't see anything" */
X	    else {
X		strcpy(p,p+1);		/* delete the backwhack */
X		p++;			/* leave the whatever alone */
X	    }
X	}
X	else
X	    p++;			/* normal char, leave it alone */
X    }
X    *++p = '\0';			/* put an extra null on the end */
X    if (inquote)
X	printf("Unmatched %c in switch\n",inquote) FLUSH;
X    for (p = tmplist; *p; /* p += strlen(p)+1 */ ) {
X	decode_switch(p);
X	while (*p++) ;			/* point at null + 1 */
X    }
X    free(tmplist);			/* this oughta be in Ada */
X}
X
X/* decode a single switch */
X
Xvoid
Xdecode_switch(s)
Xregister char *s;
X{
X    while (isspace(*s))			/* ignore leading spaces */
X	s++;
X#ifdef DEBUG
X    if (debug)
X	printf("Switch: %s\n",s) FLUSH;
X#endif
X    if (*s != '-' && *s != '+') {	/* newsgroup pattern */
X	setngtodo(s);
X    }
X    else {				/* normal switch */
X	bool upordown = *s == '-' ? TRUE : FALSE;
X	char tmpbuf[LBUFLEN];
X
X	s++;
X	switch (*s) {
X#ifdef TERMMOD
X	case '=': {
X	    char *beg = s+1;
X
X	    while (*s && *s != '-' && *s != '+') s++;
X	    cpytill(tmpbuf,beg,*s);
X	    if (upordown ? strEQ(getenv("TERM"),tmpbuf)
X	    		 : strNE(getenv("TERM"),tmpbuf) ) {
X		decode_switch(s);
X	    }
X	    break;
X	}
X#endif
X#ifdef BAUDMOD
X	case '0': case '1': case '2': case '3': case '4':
X	case '5': case '6': case '7': case '8': case '9':
X	    if (upordown ? (just_a_sec*10 <= atoi(s))
X	    		 : (just_a_sec*10 >= atoi(s)) ) {
X		while (isdigit(*s)) s++;
X		decode_switch(s);
X	    }
X	    break;
X#endif
X	case '/':
X	    if (checkflag)
X		break;
X#ifdef SETENV
X	    export("SAVEDIR",  upordown ? "%p/%c" : "%p" );
X	    export("SAVENAME", upordown ? "%a"    : "%^C");
X#else
X	    notincl("-/");
X#endif
X	    break;
X	case 'a':
X	    thread_always = upordown;
X	    break;
X	case 'A':
X	    auto_arrow_macros = upordown;
X	    break;
X	case 'b':
X	    breadth_first = upordown;
X	    break;
X	case 'B':
X	    bkgnd_spinner = upordown;
X	    break;
X	case 'c':
X	    checkflag = upordown;
X	    break;
X	case 'C':
X	    s++;
X	    if (*s == '=') s++;
X	    docheckwhen = atoi(s);
X	    break;
X	case 'd': {
X	    if (checkflag)
X		break;
X	    s++;
X	    if (*s == '=') s++;
X	    if (cwd) {
X		chdir(cwd);
X		free(cwd);
X	    }
X	    cwd = savestr(s);
X	    break;
X	}
X#ifdef DEBUG
X	case 'D':
X	    s++;
X	    if (*s == '=') s++;
X	    if (*s)
X		if (upordown)
X		    debug |= atoi(s);
X		else
X		    debug &= ~atoi(s);
X	    else
X		if (upordown)
X		    debug |= 1;
X		else
X		    debug = 0;
X	    break;
X#endif
X	case 'e':
X	    erase_screen = upordown;
X	    break;
X	case 'E':
X#ifdef SETENV
X	    s++;
X	    if (*s == '=')
X		s++;
X	    strcpy(tmpbuf,s);
X	    s = index(tmpbuf,'=');
X	    if (s) {
X		*s++ = '\0';
X		export(tmpbuf,s);
X	    }
X	    else
X		export(tmpbuf,nullstr);
X#else
X	    notincl("-E");
X#endif
X	    break;
X	case 'f':
X	    novice_delays = !upordown;
X	    break;
X	case 'F':
X	    s++;
X	    indstr = savestr(s);
X	    break;
X#ifdef INNERSEARCH
X	case 'g':
X	    gline = atoi(s+1)-1;
X	    break;
X#endif
X#ifdef EDIT_DISTANCE
X	case 'G':
X	    fuzzyGet = upordown;
X	    break;
X#endif        
X	case 'H':
X	case 'h': {
X	    register int len, i;
X	    char *t;
X	    int flag = (*s == 'h' ? HT_HIDE : HT_MAGIC);
X	    
X	    if (checkflag)
X		break;
X	    s++;
X	    len = strlen(s);
X	    for (t=s; *t; t++)
X		if (isupper(*t))
X		   *t = tolower(*t);
X	    for (i=HEAD_FIRST; i<HEAD_LAST; i++)
X		if (!len || strnEQ(s,htype[i].ht_name,len))
X		    if (upordown)
X			htype[i].ht_flags |= flag;
X		    else
X			htype[i].ht_flags &= ~flag;
X	    break;
X	}
X	case 'i':
X	    s++;
X	    if (*s == '=') s++;
X	    initlines = atoi(s);
X	    initlines_specified = TRUE;
X	    break;
X	case 'I':
X	    append_unsub = upordown;
X	    break;
X	case 'j':
X	    dont_filter_control = TRUE;
X	    break;
X	case 'l':
X	    muck_up_clear = upordown;
X	    break;
X	case 'L':
X#ifdef CLEAREOL
X	    can_home_clear = upordown;
X#else
X	    notincl("-L");
X#endif
X	    break;
X	case 'M':
X	    mbox_always = upordown;
X	    break;
X	case 'm':
X	    s++;
X	    if (*s == '=') s++;
X	    if (!upordown)
X		marking = NOMARKING;
X	    else if (*s == 'u')
X		marking = UNDERLINE;
X	    else {
X		marking = STANDOUT;
X	    }
X	    break;
X	case 'N':
X	    norm_always = upordown;
X	    break;
X#ifdef VERBOSE
X	case 'n':
X	    fputs("This isn't readnews.  Don't use -n.\n\n",stdout) FLUSH;
X	    break;
X#endif
X	case 'o':
X	    s++;
X	    if (*s == '=') s++;
X	    if (*s <= '9' && *s >= '0') {
X		olden_days = atoi(s);
X		do {
X		    s++;
X		} while (*s <= '9' && *s >= '0');
X	    } else
X		olden_days = upordown;
X	    break;
X	case 'O':
X	    s++;
X	    if (*s == '=') s++;
X	    if (!*s)
X		break;
X	    if (!set_sel_mode(*s)
X	     || (*++s && !set_sel_sort(*s))) {
X#ifdef VERBOSE
X		IF(verbose)
X		    printf("\nIgnoring unrecognized -O option: %c\n", *s) FLUSH;
X		ELSE
X#endif
X#ifdef TERSE
X		    printf("\nIgnoring -O with %c\n", *s) FLUSH;
X#endif
X		break;
X	    }
X	    break;
X	case 'p':
X	    auto_select_postings = upordown;
X	    break;
X	case 'q':
X	    quickstart = upordown;
X	    break;
X	case 'r':
X	    findlast = upordown;
X	    break;
X	case 's':
X	    s++;
X	    if (*s == '=') s++;
X	    if (*s) {
X		countdown = atoi(s);
X		suppress_cn = FALSE;
X	    }
X	    else {
X		if (!upordown)
X		    countdown = 5;
X		suppress_cn = upordown;
X	    }
X	    break;
X	case 'S':
X#ifdef ARTSEARCH
X	    s++;
X	    if (*s == '=') s++;
X	    if (*s)
X		scanon = atoi(s);
X	    else
X		scanon = upordown*3;
X#else
X	    notincl("-S");
X#endif
X	    break;
X	case 't':
X#ifdef VERBOSE
X#ifdef TERSE
X	    verbose = !upordown;
X	    if (!verbose)
X		novice_delays = FALSE;
X#else
X	    notincl("+t");
X#endif
X#else
X	    notincl("+t");
X#endif
X	    break;
X	case 'T':
X	    typeahead = upordown;
X	    break;
X	case 'u':
X	    unbroken_subjects = upordown;
X	    break;
X	case 'U':
X	    unsafe_rc_saves = upordown;
X	    break;
X	case 'v':
X#ifdef VERIFY
X	    verify = upordown;
X#else
X	    notincl("-v");
X#endif
X	    break;
X	case 'x':
X	    s++;
X	    if (*s == '=') s++;
X	    if (*s <= '9' && *s >= '0') {
X		if ((max_tree_lines = atoi(s)) > 11)
X		    max_tree_lines = 11;
X		do {
X		    s++;
X		} while (*s <= '9' && *s >= '0');
X	    } else
X		max_tree_lines = 6;
X	    if (*s)
X		strncpy(select_order, s, 3);
X	    use_threads = upordown;
X	    break;
X	case 'X':
X	    s++;
X	    if (*s == '=') s++;
X	    if (*s <= '9' && *s >= '0') {
X		select_on = atoi(s);
X		do {
X		    s++;
X		} while (*s <= '9' && *s >= '0');
X	    } else
X		select_on = upordown;
X	    if (*s)
X		end_select = *s++;
X	    if (*s)
X		page_select = *s;
X	    break;
X	case 'z':
X	    s++;
X	    if (*s == '=') s++;
X	    if (*s)
X		actFetchTime = atoi(s) * 60L;
X	    else
X		actFetchTime = upordown * 5L * 60L;
X	    break;
X	case 'Z':
X	    s++;
X	    if (*s == '=') s++;
X	    try_mt = FALSE;
X	    try_ov = FALSE;
X	    if (upordown) {
X		while (*s) {
X		    switch (*s++) {
X		    case 'o':
X			try_ov = TRUE;
X			break;
X		    case 't':
X			try_mt = TRUE;
X			break;
X		    }
X		}
X	    }
X	    break;
X	default:
X#ifdef VERBOSE
X	    IF(verbose)
X		printf("\nIgnoring unrecognized switch: -%c\n", *s) FLUSH;
X	    ELSE
X#endif
X#ifdef TERSE
X		printf("\nIgnoring -%c\n", *s) FLUSH;
X#endif
X	    break;
X	}
X    }
X}
X
X/* print current switch values */
X
Xvoid
Xpr_switches()
X{
X    static char mp[2] = {'+','-'};
X    register int i;
X    
X    fputs("\nCurrent switch settings:\n",stdout);
X    printf("%c/ ", mp[strEQ(getval("SAVEDIR",SAVEDIR),"%p/%c")]);
X    printf("%ca ", mp[thread_always]);
X    printf("%cA ", mp[auto_arrow_macros]);
X    printf("%cb ", mp[breadth_first]);
X    printf("%cB ", mp[bkgnd_spinner]);
X    printf("%cc ", mp[checkflag]);
X    printf("-C%d ", docheckwhen);
X    printf("-d%s ", cwd);
X#ifdef DEBUG
X    if (debug)
X	printf("-D%d ", debug);
X#endif
X    printf("%ce ", mp[erase_screen]);
X    printf("%cf ", mp[!novice_delays]);
X    printf("-F\"%s\" ", indstr);
X#ifdef INNERSEARCH
X    printf("-g%d ", gline+1);
X#endif
X    printf("%cG", mp[fuzzyGet]);
X    putchar('\n');
X#ifdef VERBOSE
X    if (verbose) {
X	for (i=HEAD_FIRST; i<HEAD_LAST; i++)
X	    printf("%ch%s%c",
X		mp[htype[i].ht_flags & HT_HIDE], htype[i].ht_name,
X		(! (i % 5) ? '\n' : ' ') );
X	putchar('\n');
X    }
X#endif
X    printf("-i%d ", initlines);
X    printf("%cI ", mp[append_unsub]);
X    printf("%cj ", mp[dont_filter_control]);
X    printf("%cl ", mp[muck_up_clear]);
X#ifdef CLEAREOL
X    printf("%cL ", mp[can_home_clear]);
X#endif /* CLEAREOL */
X    if (marking)
X	printf("-m%c ",marking==UNDERLINE?'u':'s');
X    else
X	printf("+m ");
X    printf("%cM ", mp[mbox_always]);
X    printf("%cN ", mp[norm_always]);
X    if (olden_days)
X	printf("-o%d ", olden_days);
X    else
X	printf("+o ");
X    printf("%cp ", mp[auto_select_postings]);
X    printf("%cq ", mp[quickstart]);
X    printf("%cr ", mp[findlast]);
X    if (countdown)
X	printf("-s%d ", countdown);
X    else
X	printf("%cs ", mp[suppress_cn]);
X#ifdef ARTSEARCH
X    if (scanon)
X	printf("-S%d ",scanon);
X    else
X	printf("+S ");
X#endif
X    putchar('\n');
X#ifdef VERBOSE
X#ifdef TERSE
X    printf("%ct ", mp[!verbose]);
X#endif
X#endif
X    printf("%cT ", mp[typeahead]);
X    printf("%cu ", mp[unbroken_subjects]);
X    printf("%cU ", mp[unsafe_rc_saves]);
X#ifdef VERIFY
X    printf("%cv ", mp[verify]);
X#endif
X    if (use_threads)
X	printf("-x%d%s ",max_tree_lines,select_order);
X    else
X	printf("+x ");
X    if (select_on)
X	printf("-X%d%c%c ",select_on,end_select,page_select);
X    else
X	printf("+X ");
X    if (actFetchTime)
X	printf("-z%ld ",(long)actFetchTime / 60);
X    else
X	printf("+z ");
X    if (try_mt || try_ov) {
X	printf("-Z");
X	if (try_ov)
X	    putchar('o');
X	if (try_mt)
X	    putchar('t');
X	putchar(' ');
X    } else
X	printf("+Z ");
X    fputs("\n\n",stdout) FLUSH;
X#ifdef ONLY
X    if (maxngtodo) {
X#ifdef VERBOSE
X	IF(verbose)
X	    fputs("Current restriction:",stdout);
X	ELSE
X#endif
X#ifdef TERSE
X	    fputs("Only:",stdout);
X#endif
X	for (i=0; i<maxngtodo; i++)
X	    printf(" %s",ngtodo[i]);
X	fputs("\n\n",stdout) FLUSH;
X    }
X#ifdef VERBOSE
X    else if (verbose)
X	fputs("No restriction.\n\n",stdout) FLUSH;
X#endif
X#endif
X}
X
Xvoid
Xcwd_check()
X{
X    char tmpbuf[LBUFLEN];
X
X    if (!cwd)
X	cwd = savestr(filexp("~/News"));
X    strcpy(tmpbuf,cwd);
X    if (chdir(cwd)) {
X	safecpy(tmpbuf,filexp(cwd),sizeof tmpbuf);
X	if (makedir(tmpbuf,MD_DIR) < 0 || chdir(tmpbuf) < 0) {
X	    interp(cmd_buf, (sizeof cmd_buf), "%~/News");
X	    if (makedir(cmd_buf,MD_DIR) < 0)
X		strcpy(tmpbuf,homedir);
X	    else
X		strcpy(tmpbuf,cmd_buf);
X	    chdir(tmpbuf);
X#ifdef VERBOSE
X	    IF(verbose)
X		printf("\
XCannot make directory %s--\n\
X	articles will be saved to %s\n\
X\n\
X",cwd,tmpbuf) FLUSH;
X	    ELSE
X#endif
X#ifdef TERSE
X		printf("\
XCan't make %s--\n\
X	using %s\n\
X\n\
X",cwd,tmpbuf) FLUSH;
X#endif
X	}
X    }
X    free(cwd);
X    getwd(tmpbuf);
X    if (eaccess(tmpbuf,2)) {
X#ifdef VERBOSE
X	IF(verbose)
X	    printf("\
XCurrent directory %s is not writeable--\n\
X	articles will be saved to home directory\n\n\
X",tmpbuf) FLUSH;
X	ELSE
X#endif
X#ifdef TERSE
X	    printf("%s not writeable--using ~\n\n",tmpbuf) FLUSH;
X#endif
X	strcpy(tmpbuf,homedir);
X    }
X    cwd = savestr(tmpbuf);
X}
END_OF_FILE
if test 14030 -ne `wc -c <'sw.c'`; then
    echo shar: \"'sw.c'\" unpacked with wrong size!
fi
# end of 'sw.c'
fi
echo shar: End of archive 5 \(of 12\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 12 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
