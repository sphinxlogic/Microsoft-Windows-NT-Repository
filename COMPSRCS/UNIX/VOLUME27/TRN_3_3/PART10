Newsgroups: comp.sources.unix
From: davison@borland.com (Wayne Davison)
Subject: v27i103: trn-3.3 - threaded newsreader based on RN, V3.3, Part10/12
References: <1.754431075.7231@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: davison@borland.com (Wayne Davison)
Posting-Number: Volume 27, Issue 103
Archive-Name: trn-3.3/part10

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 10 (of 12)."
# Contents:  ng.c rthread.c
# Wrapped by vixie@gw.home.vix.com on Sun Nov 21 01:14:09 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'ng.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ng.c'\"
else
echo shar: Extracting \"'ng.c'\" \(33206 characters\)
sed "s/^X//" >'ng.c' <<'END_OF_FILE'
X/* $Id: ng.c,v 3.0 1992/02/01 03:09:32 davison Trn $
X */
X/* This software is Copyright 1991 by Stan Barber. 
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "trn.h"
X#include "term.h"
X#include "final.h"
X#include "util.h"
X#include "cache.h"
X#include "bits.h"
X#include "artsrch.h"
X#include "help.h"
X#include "kfile.h"
X#include "rcstuff.h"
X#include "head.h"
X#include "art.h"
X#include "artio.h"
X#include "ngstuff.h"
X#include "intrp.h"
X#include "respond.h"
X#include "ngdata.h"
X#include "backpage.h"
X#include "rcln.h"
X#include "last.h"
X#include "search.h"
X#include "nntp.h"
X#include "rthread.h"
X#include "rt-select.h"
X#include "rt-wumpus.h"
X#include "decode.h"
X#include "INTERN.h"
X#include "ng.h"
X#include "artstate.h"			/* somebody has to do it */
X
X/* art_switch() return values */
X
X#define AS_NORM 0
X#define AS_INP 1
X#define AS_ASK 2
X#define AS_CLEAN 3
X
Xint exit_code = NG_NORM;
X
Xvoid
Xng_init()
X{
X
X#ifdef KILLFILES
X    open_kfile(KF_GLOBAL);
X#endif
X#ifdef CUSTOMLINES
X    init_compex(&hide_compex);
X    init_compex(&page_compex);
X#endif
X}
X
X/* do newsgroup on line ng with name ngname */
X
X/* assumes that we are chdir'ed to NEWSSPOOL, and assures that that is
X * still true upon return, but chdirs to NEWSSPOOL/ngname in between
X *
X * If you can understand this routine, you understand most of the program.
X * The basic structure is:
X *	for each desired article
X *		for each desired page
X *			for each line on page
X *				if we need another line from file
X *					get it
X *					if it's a header line
X *						do special things
X *				for each column on page
X *					put out a character
X *				end loop
X *			end loop
X *		end loop
X *	end loop
X *
X *	(Actually, the pager is in another routine.)
X *
X * The chief problem is deciding what is meant by "desired".  Most of
X * the messiness of this routine is due to the fact that people want
X * to do unstructured things all the time.  I have used a few judicious
X * goto's where I thought it improved readability.  The rest of the messiness
X * arises from trying to be both space and time efficient.  Have fun.
X */
X
Xint
Xdo_newsgroup(start_command)
Xchar *start_command;			/* command to fake up first */
X{
X    char oldmode = mode;
X    char *whatnext = "%sWhat next? [%s]";
X
X#ifdef ARTSEARCH
X    srchahead = (scanon && !ThreadedGroup	/* did they say -S? */
X	      && ((ART_NUM)toread[ng]) >= scanon ? -1 : 0);
X#endif
X    
X    exit_code = NG_NORM;
X    localkf_changes = 0;
X    killfirst = 0;
X
X    if (extractdest) {
X	free(extractdest);
X	extractdest = Nullch;
X    }
X    if (extractprog) {
X	free(extractprog);
X	extractprog = Nullch;
X    }
X
X    /* initialize the newsgroup data structures */
X
X    if (!access_ng())
X	return -1;
X
X    /* FROM HERE ON, RETURN THRU CLEANUP OR WE ARE SCREWED */
X
X    in_ng = TRUE;			/* tell the world we are here */
X    forcelast = TRUE;			/* if 0 unread, do not bomb out */
X    recent_artp = curr_artp = Nullart;
X    recent_art = curr_art = lastart+1;
X    prompt = whatnext;
X
X    /* remember what newsgroup we were in for sake of posterity */
X
X    writelast();
X
X    /* see if there are any special searches to do */
X
X    has_normal_kills = FALSE;
X#ifdef KILLFILES
X    open_kfile(KF_LOCAL);
X# ifdef VERBOSE
X    IF(verbose)
X	kill_unwanted(firstart,"Processing memorized commands...\n\n",TRUE);
X    ELSE
X# endif
X# ifdef TERSE
X	kill_unwanted(firstart,"Auto-processing...\n\n",TRUE);
X# endif
X#endif
X    if (!selected_count)
X	selected_only = FALSE;
X    top_article();
X
X    /* do they want a special top line? */
X
X    firstline = getval("FIRSTLINE",Nullch);
X
X    /* custom line suppression, custom page ending */
X
X#ifdef CUSTOMLINES
X    if (hideline = getval("HIDELINE",Nullch))
X	compile(&hide_compex,hideline,TRUE,TRUE);
X    if (pagestop = getval("PAGESTOP",Nullch))
X	compile(&page_compex,pagestop,TRUE,TRUE);
X#endif
X
X    /* now read each unread article */
X
X    rc_changed = doing_ng = TRUE;	/* enter the twilight zone */
X    if (!unsafe_rc_saves)
X	checkcount = 0;			/* do not checkpoint for a while */
X    do_fseek = FALSE;			/* start 1st article at top */
X    for (; art<=lastart+1; ) {		/* for each article */
X	mode = 'a';
X
X	/* do we need to "grow" the newsgroup? */
X
X	if (art > lastart || forcegrow) {
X	    ART_NUM oldlast = lastart;
X#ifdef USE_NNTP
X	    if (!nntp_group(ngname,ng)) {
X		fprintf(stderr,"Your server went south for the winter:\n%s\n",
X			ser_line);
X		finalize(1);
X	    }
X	    if (ngmax[ng] > lastart) {
X		grow_ng(ngmax[ng]);
X	    }
X#else
X	    grow_ng(getngsize(ng));
X#endif
X	    if (forcelast && art > oldlast)
X		art = lastart+1;
X	}
X	if (!artp || (artp->flags & AF_TMPMEM) != AF_TMPMEM || art != 0)
X	    artp = find_article(art);
X	if (start_command) {		/* do we have an initial command? */
X	    pushstring(start_command, 0);
X	    free(start_command);
X	    start_command = Nullch;
X	    art = curr_art = lastart+1;
X	    artp = curr_artp = Nullart;
X	    if (input_pending())
X		goto reinp_article;
X	}
X	if (art>lastart) {		/* are we off the end still? */
X	    ARTICLE *ap;
X	    ART_NUM i;
X	    art = lastart + 1;		/* keep pointer references sane */
X	    if (!forcelast && toread[ng] && selected_only && !selected_count) {
X		art = curr_art;
X		artp = curr_artp;
X		strcpy(buf, "+");
X		goto article_level;
X	    }
X	    count_subjects(CS_RETAIN);
X	    for (i=last_cached+1, ap=article_ptr(i); i<=lastart; i++, ap++)
X		if (!(ap->flags & AF_READ))
X		    article_count++;
X	    toread[ng] = (ART_UNREAD)article_count;
X	    if (artp != curr_artp) {
X		recent_art = curr_art;	/* remember last article # (for '-') */
X		curr_art = art;		/* set current article # */
X		recent_artp = curr_artp;
X		curr_artp = artp;
X	    }
X	    if (erase_screen)
X		clear();			/* clear the screen */
X	    else
X		fputs("\n\n",stdout) FLUSH;
X#ifdef VERBOSE
X	    IF(verbose)
X		printf("End of newsgroup %s.",ngname);
X					/* print pseudo-article */
X	    ELSE
X#endif
X#ifdef TERSE
X		printf("End of %s",ngname);
X#endif
X	    if (article_count) {
X		if (selected_only)
X		    printf("  (%ld + %ld articles still unread)",
X			(long)selected_count,
X			(long)article_count-selected_count);
X		else
X		    printf("  (%ld article%s still unread)",
X			(long)article_count,article_count==1?nullstr:"s");
X	    }
X	    if (redirected) {
X		if (redirected == nullstr)
X		    printf("\n\n** This group has been disabled by your news admin **");
X		else
X		    printf("\n\n** Please start using %s **", redirected);
X	    } else if (!article_count && !forcelast)
X		goto cleanup;		/* actually exit newsgroup */
X	    mode = 'e';
X	    prompt = whatnext;
X#ifdef ARTSEARCH
X	    srchahead = 0;		/* no more subject search mode */
X#endif
X	    fputs("\n\n",stdout) FLUSH;
X	}
X	else if (!reread && (was_read(art) || (artp->flags & AF_MISSING)
X		|| (selected_only && !(artp->flags & AF_SEL)))) {
X					/* has this article been read? */
X	    inc_art(selected_only,FALSE);/* then skip it */
X	    continue;
X	}
X	else if (!reread && !parseheader(art)) {
X	    oneless(artp);		/* mark deleted as read */
X	    ng_skip();
X	}
X	else {				/* we have a real live article */
X	    if (artp != curr_artp) {
X		recent_art = curr_art;	/* remember last article # (for '-') */
X		curr_art = art;		/* set current article # */
X		recent_artp = curr_artp;
X		curr_artp = artp;
X	    }
X	    if (!do_fseek) {		/* starting at top of article? */
X		artline = 0;		/* start at the beginning */
X		topline = -1;		/* and remember top line of screen */
X					/*  (line # within article file) */
X	    }
X	    clear();			/* clear screen */
X	    if (!artopen(art)) {	/* make sure article is found & open */
X		char tmpbuf[256];
X		/* see if we have tree data for this article anyway */
X		init_tree();
X		sprintf(tmpbuf,"%s: article is not available.",ngname);
X		if (artp && !(artp->flags & AF_CACHED)) {
X		    if (absfirst < first_cached || last_cached < lastart
X		     || !cached_all_in_range)
X			sprintf(tmpbuf,"%s: article may show up in a moment.",
X				ngname);
X		}
X		tree_puts(tmpbuf,0,0);
X		vwtary((ART_LINE)0,(ART_POS)0);
X		finish_tree(1);
X		prompt = whatnext;
X#ifdef ARTSEARCH
X		srchahead = 0;
X#endif
X	    }
X	    else {			/* found it, so print it */
X		switch (do_article()) {
X		case DA_CLEAN:		/* quit newsgroup */
X		    goto cleanup;
X		case DA_TOEND:		/* do not mark as read */
X		    goto reask_article; 
X		case DA_RAISE:		/* reparse command at end of art */
X		    goto article_level;
X		case DA_NORM:		/* normal end of article */
X		    break;
X		}
X	    }
X	    if (art >= absfirst)	/* don't mark non-existant articles */
X		mark_as_read();		/* mark current article as read */
X	    do_hiding = TRUE;
X#ifdef ROTATION
X	    rotate = FALSE;
X#endif
X	}
X
X/* if these gotos bother you, think of this as a little state machine */
X
Xreask_article:
X#ifdef MAILCALL
X	setmail(FALSE);
X#endif
X	setdfltcmd();
X#ifdef CLEAREOL
X	if (erase_screen && can_home_clear)
X	    clear_rest();
X#endif /* CLEAREOL */
X	unflush_output();		/* disable any ^O in effect */
X	standout();			/* enter standout mode */
X	printf(prompt,mailcall,dfltcmd);/* print prompt, whatever it is */
X	un_standout();			/* leave standout mode */
X	putchar(' ');
X	fflush(stdout);
Xreinp_article:
X	reread = FALSE;
X	forcelast = FALSE;
X	eat_typeahead();
X#ifdef PENDING
X	look_ahead();			/* see what we can do in advance */
X	cache_until_key();
X#endif
X	art = curr_art;
X	artp = curr_artp;
X	getcmd(buf);
X	if (errno || *buf == '\f') {
X	    if (LINES < 100 && !int_count)
X		*buf = '\f';		/* on CONT fake up refresh */
X	    else {
X		putchar('\n') FLUSH;		/* but only on a crt */
X		goto reask_article;
X	    }
X	}
Xarticle_level:
X	output_chase_phrase = TRUE;
X
X	/* parse and process article level command */
X
X	switch (art_switch()) {
X	case AS_INP:			/* multichar command rubbed out */
X	    goto reinp_article;
X	case AS_ASK:			/* reprompt "End of article..." */
X	    goto reask_article;
X	case AS_CLEAN:			/* exit newsgroup */
X	    goto cleanup;
X	case AS_NORM:			/* display article art */
X	    break;
X	}
X    }					/* end of article selection loop */
X    
X/* shut down newsgroup */
X
Xcleanup:
X    decode_end();
X#ifdef KILLFILES
X    kill_unwanted(firstart,"\nCleaning up...\n\n",FALSE);
X					/* do cleanup from KILL file, if any */
X#endif
X    in_ng = FALSE;			/* leave newsgroup state */
X    if (artfp != Nullfp) {		/* article still open? */
X	fclose(artfp);			/* close it */
X	artfp = Nullfp;			/* and tell the world */
X	openart = 0;
X    }
X    putchar('\n') FLUSH;
X    deselect_all();
X    yankback();				/* do a Y command */
X    bits_to_rc();			/* reconstitute .newsrc line */
X    doing_ng = FALSE;			/* tell sig_catcher to cool it */
X    if (!unsafe_rc_saves)
X	write_rc();			/* and update .newsrc */
X    rc_changed = FALSE;			/* tell sig_catcher it is ok */
X    if (chdir(spool)) {
X	printf(nocd,spool) FLUSH;
X	sig_catcher(0);
X    }
X#ifdef KILLFILES
X    if (localkfp) {
X	fclose(localkfp);
X	localkfp = Nullfp;
X    }
X#endif
X    mode = oldmode;
X    return exit_code;
X}					/* Whew! */
X
X/* decide what to do at the end of an article */
X
Xint
Xart_switch()
X{
X    register ART_NUM i;
X      
X    setdef(buf,dfltcmd);
X#ifdef VERIFY
X    printcmd();
X#endif
X
X    switch (*buf) {
X    case '<':			/* goto previous subject/thread */
X	prev_subject();
X	return AS_NORM;
X    case '>':			/* goto next subject/thread */
X	next_subject();
X	return AS_NORM;
X    case 'U': {			/* unread some articles */
X	char *u_prompt, *u_help_thread;
X
X	dfltcmd = "+";
X	if (!artp) {
X	    u_help_thread = nullstr;
X#ifdef VERBOSE
X	    IF(verbose)
X		u_prompt = "\nSet unread: +select or all? [+an] ";
X	    ELSE
X#endif
X#ifdef TERSE
X		u_prompt = "\nSet unread? [+an] ";
X#endif
X	}
X	else {
X#ifdef VERBOSE
X	    IF(verbose) {
X		u_prompt = "\n\
XSet unread: +select, thread, subthread, or all? [+tsan] ";
X		u_help_thread = "\
XType t or SP to mark this thread's articles as unread.\n\
XType s to mark the current article and its descendants as unread.\n";
X	    }
X	    ELSE
X#endif
X#ifdef TERSE
X	    {
X		u_prompt = "\nSet unread? [+tsan] ";
X		u_help_thread = "\
Xt or SP to mark thread unread.\n\
Xs to mark subthread unread.\n";
X	    }
X#endif
X	}
X      reask_unread:
X	in_char(u_prompt,'u');
X	setdef(buf,dfltcmd);
X#ifdef VERIFY
X	printcmd();
X#endif
X	putchar('\n') FLUSH;
X	if (*buf == 'h') {
X#ifdef VERBOSE
X	    IF(verbose)
X	    {
X		fputs("\
XType + to enter select thread mode using all the unread articles.\n\
X(The selected threads will be marked as unread and displayed as usual.)\n\
X",stdout) FLUSH;
X		fputs(u_help_thread,stdout);
X		fputs("\
XType a to mark all articles in this group as unread.\n\
XType n to change nothing.\n\
X",stdout) FLUSH;
X	    }
X	    ELSE
X#endif
X#ifdef TERSE
X	    {
X		fputs("\
X+ to select threads from the unread.\n\
X",stdout) FLUSH;
X		fputs(u_help_thread,stdout);
X		fputs("\
Xa to mark all articles unread.\n\
Xn to change nothing.\n\
X",stdout) FLUSH;
X	    }
X#endif
X	    goto reask_unread;
X	}
X	else if (*buf == 'n' || *buf == 'q')
X	    return AS_ASK;
X	else if (*buf == 't' && u_help_thread != nullstr) {
X	    unkill_thread(artp->subj->thread);
X	    if ((artp = first_art(artp->subj)) != Nullart)
X		art = article_num(artp);
X	} else if (*buf == 's' && u_help_thread != nullstr)
X	    unkill_subthread(artp);
X	else if (*buf == 'a') {
X	    register ARTICLE *ap;
X	    check_first(absfirst);
X	    ap = article_ptr(absfirst);
X	    for (i = absfirst; i <= lastart; i++, ap++)
X		if ((ap->flags & (AF_READ|AF_MISSING)) == AF_READ) {
X		    ap->flags &= ~AF_READ;		/* mark as unread */
X		    toread[ng]++;
X		}
X	    count_subjects(CS_NORM);
X	}
X	else if (*buf == '+') {
X	    *buf = 'U';
X	    goto run_the_selector;
X	}
X	else {
X	    fputs(hforhelp,stdout) FLUSH;
X	    settle_down();
X	    goto reask_unread;
X	}
X	return AS_NORM;
X    }
X    case '[':			/* goto parent article */
X    case '{':			/* goto thread's root article */
X	if (artp) {
X	    if (!find_parent(*buf == '{')) {
X		register char *cp = (*buf=='['?"parent":"root");
X#ifdef VERBOSE
X		IF(verbose)
X		    printf("\nThere is no %s article prior to this one.\n",
X			cp) FLUSH;
X		ELSE
X#endif
X#ifdef TERSE
X		    printf("\nNo prior %s.\n",cp) FLUSH;
X#endif
X		return AS_ASK;
X	    }
X	    reread = TRUE;
X	    return AS_NORM;
X	}
Xnot_threaded:
X	if (!artp) {
X#ifdef VERBOSE
X	    IF(verbose)
X		fputs("\nYou're at the end of the group.\n",stdout) FLUSH;
X	    ELSE
X#endif
X#ifdef TERSE
X		fputs("\nEnd of group.\n",stdout) FLUSH;
X#endif
X	    return AS_ASK;
X	}
X#ifdef VERBOSE
X	IF(verbose)
X	    fputs("\nThis group is not threaded.\n",stdout) FLUSH;
X	ELSE
X#endif
X#ifdef TERSE
X	    fputs("\nUnthreaded group.\n",stdout) FLUSH;
X#endif
X	return AS_ASK;
X    case ']':			/* goto child article */
X    case '}':			/* goto thread's leaf article */
X	if (artp) {
X	    if (!find_leaf(*buf == '}')) {
X#ifdef VERBOSE
X		IF(verbose)
X		    fputs("\n\
XThis is the last leaf in this tree.\n",stdout) FLUSH;
X		ELSE
X#endif
X#ifdef TERSE
X		    fputs("\nLast leaf.\n",stdout) FLUSH;
X#endif
X		return AS_ASK;
X	    }
X	    reread = TRUE;
X	    return AS_NORM;
X	}
X	goto not_threaded;
X    case '(':			/* goto previous sibling */
X    case ')':			/* goto next sibling */
X	if (artp) {
X	    if (!(*buf == '(' ? find_prev_sib() : find_next_sib())) {
X		register char *cp = (*buf == '(' ? "previous" : "next");
X#ifdef VERBOSE
X		IF(verbose)
X		    printf("\nThis article has no %s sibling.\n",cp) FLUSH;
X		ELSE
X#endif
X#ifdef TERSE
X		    printf("\nNo %s sibling.\n",cp) FLUSH;
X#endif
X		return AS_ASK;
X	    }
X	    reread = TRUE;
X	    return AS_NORM;
X	}
X	goto not_threaded;
X    case 'T':
X	if (!ThreadedGroup)
X	    goto not_threaded;
X	/* FALL THROUGH */
X    case 'A':
X	if (!artp)
X	    goto not_threaded;
X	switch (ask_memorize(*buf)) {
X	case ',':  case 'j':
X	    return AS_NORM;
X	}
X	return AS_ASK;
X    case 'K':
X	if (!artp)
X	    goto not_threaded;
X	/* first, write kill-subject command */
X	(void)art_search(buf, (sizeof buf), TRUE);
X	art = curr_art;
X	artp = curr_artp;
X	kill_subject(artp->subj,KF_ALL);/* take care of any prior subjects */
X	return AS_NORM;
X    case ',':		/* kill this node and all descendants */
X	if (!artp)
X	    goto not_threaded;
X	if (ThreadedGroup)
X	    kill_subthread(artp,KF_ALL);
X	else if (art >= absfirst && art <= lastart)
X	    mark_as_read();
X	return AS_NORM;
X    case 'J':		/* Junk all nodes in this thread */
X	if (!artp)
X	    goto not_threaded;
X	if (ThreadedGroup) {
X	    kill_thread(artp->subj->thread,KF_ALL);
X	    return AS_NORM;
X	}
X	/* FALL THROUGH */
X    case 'k':		/* kill current subject */
X	if (!artp)
X	    goto not_threaded;
X	kill_subject(artp->subj,KF_ALL);
X	if (last_cached < lastart) {
X	    *buf = 'k';
X	    goto normal_search;
X	}
X	return AS_NORM;
X    case 't':
X	carriage_return();
X#ifndef CLEAREOL
X	erase_eol();		/* erase the prompt */
X#else
X	if (erase_screen && can_home_clear)
X	    clear_rest();
X	else
X	    erase_eol();	/* erase the prompt */
X#endif /* CLEAREOL */
X	fflush(stdout);
X	page_line = 1;
X	entire_tree(curr_artp);
X	return AS_ASK;
X    case ':':			/* execute command on selected articles */
X	page_line = 1;
X	if (!use_selected())
X	    return AS_INP;
X	putchar('\n');
X	art = curr_art;
X	artp = curr_artp;
X	return AS_ASK;
X    case 'p':			/* find previous unread article */
X	do {
X	    dec_art(selected_only,FALSE);
X	} while (art >= firstart && (was_read(art) || !parseheader(art)));
X#ifdef ARTSEARCH
X	srchahead = 0;
X#endif
X	if (art >= firstart)
X	    return AS_NORM;
X	art = absfirst;	
X	/* FALL THROUGH */
X    case 'P':		/* goto previous article */
X	dec_art(FALSE,TRUE);
X      check_dec_art:
X	if (art < absfirst) {
X#ifdef VERBOSE
X	    IF(verbose)
X		printf("\nThere are no%s%s articles prior to this one.\n",
X			*buf=='P'?nullstr:" unread",
X			selected_only?" selected":nullstr) FLUSH;
X	    ELSE
X#endif
X#ifdef TERSE
X		printf("\nNo previous%s%s articles\n",
X			*buf=='P'?nullstr:" unread",
X			selected_only?" selected":nullstr) FLUSH;
X#endif
X	    art = curr_art;
X	    artp = curr_artp;
X	    return AS_ASK;
X	}
X	reread = TRUE;
X#ifdef ARTSEARCH
X	srchahead = 0;
X#endif
X	return AS_NORM;
X    case '-':
X	if (recent_art >= 0) {
X	    art = recent_art;
X	    artp = recent_artp;
X	    reread = TRUE;
X	    forcelast = TRUE;
X#ifdef ARTSEARCH
X	    srchahead = -(srchahead != 0);
X#endif
X	    return AS_NORM;
X	}
X	else {
X	    exit_code = NG_MINUS;
X	    return AS_CLEAN;
X	}
X    case 'n':		/* find next unread article? */
X	if (art > lastart) {
X	    if (!toread[ng])
X		return AS_CLEAN;
X	    top_article();
X	}
X#ifdef ARTSEARCH
X	else if (scanon && !ThreadedGroup && srchahead) {
X	    *buf = Ctl('n');
X	    if (!next_art_with_subj())
X		goto normal_search;
X	    return AS_NORM;
X	}
X#endif
X	else
X	    inc_art(selected_only,FALSE);
X
X#ifdef ARTSEARCH
X	srchahead = 0;
X#endif
X	return AS_NORM;
X    case 'N':			/* goto next article */
X	if (art > lastart)
X	    if (!first_subject) {
X		art = absfirst;
X		artp = article_ptr(art);
X	    } else {
X		artp = first_subject->articles;
X		if (artp->flags & AF_MISSING)
X		    inc_art(FALSE,TRUE);
X		else
X		    art = article_num(artp);
X	    }
X	else
X	    inc_art(FALSE,TRUE);
X	if (art <= lastart)
X	    reread = TRUE;
X#ifdef ARTSEARCH
X	srchahead = 0;
X#endif
X	return AS_NORM;
X    case '$':
X	art = lastart+1;
X	artp = Nullart;
X	forcelast = TRUE;
X#ifdef ARTSEARCH
X	srchahead = 0;
X#endif
X	return AS_NORM;
X    case '1': case '2': case '3':	/* goto specified article */
X    case '4': case '5': case '6':	/* or do something with a range */
X    case '7': case '8': case '9': case '.':
X	forcelast = TRUE;
X	switch (numnum()) {
X	case NN_INP:
X	    return AS_INP;
X	case NN_ASK:
X	    return AS_ASK;
X	case NN_REREAD:
X	    reread = TRUE;
X#ifdef ARTSEARCH
X	    if (srchahead)
X		srchahead = -1;
X#endif
X	    break;
X	case NN_NORM:
X	    if (was_read(art)) {
X		top_article();
X		pad(just_a_sec/3);
X	    }
X	    else {
X		putchar('\n');
X		return AS_ASK;
X	    }
X	    break;
X	}
X	return AS_NORM;
X    case Ctl('k'):
X	edit_kfile();
X	return AS_ASK;
X    case Ctl('n'):	/* search for next article with same subject */
X    case Ctl('p'):	/* search for previous article with same subject */
X	if (*buf == Ctl('n')? next_art_with_subj() : prev_art_with_subj())
X	    return AS_NORM;
X    case '/': case '?':
Xnormal_search:
X#ifdef ARTSEARCH
X    {		/* search for article by pattern */
X	char cmd = *buf;
X	
X	reread = TRUE;		/* assume this */
X	page_line = 1;
X	switch (art_search(buf, (sizeof buf), TRUE)) {
X	case SRCH_ERROR:
X	    art = curr_art;
X	    return AS_ASK;
X	case SRCH_ABORT:
X	    art = curr_art;
X	    return AS_INP;
X	case SRCH_INTR:
X#ifdef VERBOSE
X	    IF(verbose)
X		printf("\n(Interrupted at article %ld)\n",(long)art) FLUSH;
X	    ELSE
X#endif
X#ifdef TERSE
X		printf("\n(Intr at %ld)\n",(long)art) FLUSH;
X#endif
X	    art = curr_art;	    /* restore to current article */
X	    return AS_ASK;
X	case SRCH_DONE:
X	    fputs("done\n",stdout) FLUSH;
X	    pad(just_a_sec/3);	/* 1/3 second */
X	    if (!srchahead) {
X		art = curr_art;
X		return AS_ASK;
X	    }
X	    top_article();
X	    reread = FALSE;
X	    return AS_NORM;
X	case SRCH_SUBJDONE:
X#ifdef UNDEF
X	    fputs("\n\n\n\nSubject not found.\n",stdout) FLUSH;
X	    pad(just_a_sec/3);	/* 1/3 second */
X#endif
X	    top_article();
X	    reread = FALSE;
X	    return AS_NORM;
X	case SRCH_NOTFOUND:
X	    fputs("\n\n\n\nNot found.\n",stdout) FLUSH;
X	    art = curr_art;  /* restore to current article */
X	    return AS_ASK;
X	case SRCH_FOUND:
X	    if (cmd == Ctl('n') || cmd == Ctl('p')) {
X		oldsubject = TRUE;
X		reread = FALSE;
X	    }
X	    break;
X	}
X	return AS_NORM;
X    }
X#else /* !ARTSEARCH */
X	buf[1] = '\0';
X	notincl(buf);
X	return AS_ASK;
X#endif
X    case 'u':			/* unsubscribe from this newsgroup? */
X	rcchar[ng] = NEGCHAR;
X	return AS_CLEAN;
X    case 'M':
X	if (art <= lastart) {
X	    delay_unmark(artp);
X	    oneless(artp);
X	    printf("\nArticle %ld will return.\n",(long)art) FLUSH;
X	}
X	return AS_ASK;
X    case 'm':
X	if (art >= absfirst && art <= lastart) {
X	    unmark_as_read();
X	    printf("\nArticle %ld marked as still unread.\n",(long)art) FLUSH;
X	}
X	return AS_ASK;
X    case 'c':			/* catch up */
X	switch (ask_catchup()) {
X	case 'n':
X	    return AS_ASK;
X	case 'u':
X	    return AS_CLEAN;
X	}
X	art = lastart+1;
X	artp = Nullart;
X	forcelast = FALSE;
X	return AS_NORM;
X    case 'Q':
X	exit_code = NG_ASK;
X	/* FALL THROUGH */
X    case 'q':			/* go back up to newsgroup level? */
X	return AS_CLEAN;
X    case 'j':
X	putchar('\n') FLUSH;
X	if (art >= absfirst && art <= lastart)
X	    mark_as_read();
X	return AS_ASK;
X    case 'h': {			/* help? */
X	int cmd;
X
X	if ((cmd = help_art()) > 0)
X	    pushchar(cmd);
X	return AS_ASK;
X    }
X    case '&':
X	if (switcheroo()) /* get rest of command */
X	    return AS_INP;	/* if rubbed out, try something else */
X	return AS_ASK;
X    case '#':
X#ifdef VERBOSE
X	IF(verbose)
X	    printf("\nThe last article is %ld.\n",(long)lastart) FLUSH;
X	ELSE
X#endif
X#ifdef TERSE
X	    printf("\n%ld\n",(long)lastart) FLUSH;
X#endif
X	return AS_ASK;
X    case '+':			/* enter selection mode */
Xrun_the_selector:
X	*buf = do_selector(*buf);
X	switch (*buf) {
X	case '+':
X	    putchar('\n') FLUSH;
X	    return AS_ASK;
X	case 'Q':
X	    exit_code = NG_ASK;
X	    /* FALL THROUGH */
X	case 'q':
X	    break;
X	case 'N':
X	    exit_code = NG_SELNEXT;
X	    break;
X	case 'P':
X	    exit_code = NG_SELPRIOR;
X	    break;
X	default:
X	    if (toread[ng])
X		return AS_NORM;
X	    break;
X	}
X	return AS_CLEAN;
X    case '=': {			/* list subjects */
X	char tmpbuf[256];
X	ART_NUM oldart = art;
X	int cmd;
X	char *s;
X	char *subjline = getval("SUBJLINE",Nullch);
X	ARTICLE *ap = article_ptr(firstart);
X
X	page_init();
X	for (i=firstart; i<=lastart && !int_count; i++, ap++) {
X	    if (!(ap->flags & AF_READ) && (s = fetchsubj(i,FALSE)) != Nullch) {
X		sprintf(tmpbuf,"%5ld ", i);
X		if (subjline) {
X		    art = i;
X		    interp(tmpbuf + 6, (sizeof tmpbuf) - 6, subjline);
X		}
X		else
X		    safecpy(tmpbuf + 6, s, (sizeof tmpbuf) - 6);
X		if (cmd = print_lines(tmpbuf,NOMARKING)) {
X		    if (cmd > 0)
X			pushchar(cmd);
X		    break;
X		}
X	    }
X	}
X	int_count = 0;
X	art = oldart;
X	return AS_ASK;
X    }
X    case '^':
X	top_article();
X#ifdef ARTSEARCH
X	srchahead = 0;
X#endif
X	return AS_NORM;
X#ifdef DEBUG
X    case 'D':
X	printf("\nFirst article: %ld\n",(long)firstart) FLUSH;
X	{
X	    ARTICLE *ap = article_ptr(firstart);
X	    for (i = firstart; i <= lastart && !int_count; i++, ap++) {
X		if (ap->subj)
X		    printf("%5ld %c %s\n",i,(was_read(i)?'y':'n'),
X			   ap->subj->str) FLUSH;
X	    }
X	}
X	int_count = 0;
X	return AS_ASK;
X#endif
X    case 'v':
X	if (art <= lastart) {
X	    reread = TRUE;
X	    do_hiding = FALSE;
X	}
X	return AS_NORM;
X#ifdef ROTATION
X    case Ctl('x'):
X#endif
X    case Ctl('r'):
X#ifdef ROTATION
X	rotate = (*buf==Ctl('x'));
X#endif
X	if (art <= lastart)
X	    reread = TRUE;
X	else
X	    forcelast = TRUE;
X	return AS_NORM;
X#ifdef ROTATION
X    case 'X':
X	rotate = !rotate;
X	/* FALL THROUGH */
X#else
X    case Ctl('x'):
X    case 'x':
X    case 'X':
X	notincl("x");
X	return AS_ASK;
X#endif
X    case 'l': case Ctl('l'):		/* refresh screen */
X	if (art <= lastart) {
X	    reread = TRUE;
X	    clear();
X	    do_fseek = TRUE;
X	    artline = topline;
X	    if (artline < 0)
X		artline = 0;
X	}
X	return AS_NORM;
X    case Ctl('f'):
X	carriage_return();
X	erase_eol();		/* erase the prompt */
X#ifdef MAILCALL
X	setmail(TRUE);		/* force a mail check */
X#endif
X	return AS_ASK;
X    case 'b': case Ctl('b'):		/* back up a page */
X	if (art <= lastart) {
X	    ART_LINE target;
X
X	    reread = TRUE;
X	    clear();
X	    do_fseek = TRUE;
X	    target = topline - (LINES - 2);
X	    artline = topline;
X	    if (artline >= 0) do {
X		artline--;
X	    } while(artline >= 0 && artline > target && vrdary(artline-1) >= 0);
X	    topline = artline;
X	    if (artline < 0)
X		artline = 0;
X	}
X	return AS_NORM;
X    case '!':			/* shell escape */
X	if (escapade())
X	    return AS_INP;
X	return AS_ASK;
X    case 'C': {
X	cancel_article();
X	return AS_ASK;
X    }
X    case 'Z':
X    case 'z': {
X	supersede_article();	/* supersedes */
X	return AS_ASK;
X    }
X    case 'R':
X    case 'r': {			/* reply? */
X	reply();
X	return AS_ASK;
X    }
X    case 'F':
X    case 'f': {			/* followup command */
X	followup();
X	forcegrow = TRUE;		/* recalculate lastart */
X	return AS_ASK;
X    }
X    case '|':
X    case 'w': case 'W':
X    case 's': case 'S':		/* save command */
X    case 'e':			/* extract command */
X	if (save_article() == SAVE_ABORT)
X	    return AS_INP;
X	int_count = 0;
X	return AS_ASK;
X    case 'E':
X	if (decode_fp)
X	    decode_end();
X	else
X	    putchar('\n') FLUSH;
X	return AS_ASK;
X    case 'Y':				/* yank back M articles */
X	yankback();
X	top_article();			/* from the beginning */
X	return AS_NORM;			/* pretend nothing happened */
X#ifdef STRICTCR
X    case '\n':
X	fputs(badcr,stdout) FLUSH;
X	return AS_ASK;
X#endif
X    case '_':
X	if (!finish_dblchar())
X	    return AS_INP;
X	switch (buf[1] & 0177) {
X	case 'P':
X	    art--;
X	    goto check_dec_art;
X	case 'N':
X	    if (art > lastart)
X		art = absfirst;
X	    else
X		art++;
X	    if (art <= lastart)
X		reread = TRUE;
X#ifdef ARTSEARCH
X	    srchahead = 0;
X#endif
X	    return AS_NORM;
X	case '+':
X	    if (ThreadedGroup) {
X		select_thread(artp->subj->thread, 0);
X		printf("\nSelected all articles in this thread.\n");
X	    } else {
X		select_subject(artp->subj, 0);
X		printf("\nSelected all articles in this subject.\n");
X	    }
X	    return AS_ASK;
X	case '-':
X	    if (sel_mode == SM_THREAD) {
X		deselect_thread(artp->subj->thread);
X		printf("\nDeselected all articles in this thread.\n");
X	    } else {
X		deselect_subject(artp->subj);
X		printf("\nDeselected all articles in this subject.\n");
X	    }
X	    return AS_ASK;
X	case 'a':  case 's':  case 't':  case 'T':
X	    *buf = buf[1];
X	    goto run_the_selector;
X	}
X	/* FALL THROUGH */
X    default:
X	printf("\n%s",hforhelp) FLUSH;
X	settle_down();
X	break;
X    }
X    return AS_ASK;
X}
X
X#ifdef MAILCALL
X/* see if there is any mail */
X
Xvoid
Xsetmail(force)
Xbool_int force;
X{
X    if (force)
X	mailcount = 0;
X    if (!(mailcount++)) {
X	char *mailfile = filexp(getval("MAILFILE",MAILFILE));
X	
X	if (stat(mailfile,&filestat) < 0 || !filestat.st_size
X	    || filestat.st_atime > filestat.st_mtime)
X	    mailcall = nullstr;
X	else
X	    mailcall = getval("MAILCALL","(Mail) ");
X    }
X    mailcount %= 10;			/* check every 10 articles */
X}
X#endif
X
Xvoid
Xsetdfltcmd()
X{
X    if (!toread[ng]) {
X	if (art > lastart)
X	    dfltcmd = "qnp";
X	else
X	    dfltcmd = "npq";
X    }
X    else {
X#ifdef ARTSEARCH
X	if (srchahead)
X	    dfltcmd = "^Nnpq";
X	else
X#endif
X	    dfltcmd = "npq";
X    }
X}
X
X/* Ask the user about catching-up the current group.  Returns 'y' if yes,
X** 'n' or 'N' if no ('N' means we used one line when in the selector),
X** or 'u' for yes with unsubscribe.  Actually performs the catchup and
X** unsubscription as needed.
X*/
Xchar
Xask_catchup()
X{
X    char ch;
X    bool use_one_line = (mode == 't');
X
X    if (!use_one_line)
X	putchar('\n') FLUSH;
Xreask_catchup:
X#ifdef VERBOSE
X    IF(verbose)
X	in_char("Do you really want to mark everything as read? [yn] ", 'C');
X    ELSE
X#endif
X#ifdef TERSE
X	in_char("Really? [ynh] ", 'C');
X#endif
X    setdef(buf,"y");
X#ifdef VERIFY
X    printcmd();
X#endif
X    if ((ch = *buf) == 'h') {
X	use_one_line = FALSE;
X#ifdef VERBOSE
X	IF(verbose)
X	    fputs("\n\
XType y or SP to mark all articles as read.\n\
XType n to leave articles marked as they are.\n\
XType u to mark everything read and unsubscribe.\n\n\
X",stdout) FLUSH;
X	ELSE
X#endif
X#ifdef TERSE
X	    fputs("\n\
Xy or SP to mark all read.\n\
Xn to forget it.\n\
Xu to mark all and unsubscribe.\n\n\
X",stdout) FLUSH;
X#endif
X	goto reask_catchup;
X    }
X    if (ch == 'n' || ch == 'q') {
X	if (use_one_line)
X	    return 'N';
X	putchar('\n') FLUSH;
X	return 'n';
X    }
X    if (ch != 'y' && ch != 'u') {
X	use_one_line = FALSE;
X	printf("\n%s\n", hforhelp) FLUSH;
X	settle_down();
X	goto reask_catchup;
X    }
X    if (mode == 'n') {
X	putchar('\n') FLUSH;
X	catch_up(ng);
X    }
X    else {
X	int i;
X	ARTICLE *ap;
X	for (i = firstart, ap = article_ptr(i); i <= lastart; i++, ap++)
X	    ap->flags = ((ap->flags & ~sel_mask) | AF_READ);
X	selected_count = selected_subj_cnt = selected_only = 0;
X	toread[ng] = 0;
X	if (dmcount)
X	    yankback();
X	putchar('\n') FLUSH;
X    }
X    if (ch == 'u')
X	rcchar[ng] = NEGCHAR;
X    return ch;
X}
X
Xchar
Xask_memorize(ch)
Xchar_int ch;
X{
X    bool thread_cmd = (ch == 'T');
X    bool use_one_line = (mode == 't');
X    char *mode_string = (thread_cmd? "thread" : "subject");
X    char *mode_phrase = (thread_cmd? "replies to this article" :
X				     "this subject and all replies");
X    ART_NUM art_hold = art;
X    ARTICLE *artp_hold = artp;
X
X    if (!use_one_line)
X	putchar('\n') FLUSH;
X    sprintf(cmd_buf,"Memorize %s command: [+.j,cC]", mode_string);
Xreask_memorize:
X    in_char(cmd_buf, 'm');
X    setdef(buf,"+");
X#ifdef VERIFY
X    printcmd();
X#endif
X    if ((ch = *buf) == 'h') {
X	use_one_line = FALSE;
X#ifdef VERBOSE
X	IF(verbose)
X	    printf("\n\
XType + or SP to auto-select this %s (i.e. includes future articles).\n\
XType . to auto-select %s.\n\
XType j to auto-kill (junk) this %s.\n\
XType , to auto-kill %s.\n\
XType c to clear all selection/killing on this %s.\n\
XType C to clear all selection/killing on %s.\n\
XType q to abort the operation.\n\n\
X",mode_string,mode_phrase,mode_string,mode_phrase,mode_string,mode_phrase) FLUSH;
X	ELSE
X#endif
X#ifdef TERSE
X	    printf("\n\
X+ or SP auto-selects this %s.\n\
X. auto-selects %s.\n\
Xj auto-kills this %s.\n\
X, auto-kills %s.\n\
Xc clears auto-commands for this %s.\n\
XC clears auto-commands for %s.\n\
Xq aborts.\n\n\
X",mode_string,mode_phrase,mode_string,mode_phrase,mode_string,mode_phrase) FLUSH;
X#endif
X	goto reask_memorize;
X    }
X    if (ch == 'q') {
X	if (use_one_line)
X	    return 'Q';
X	putchar('\n');
X	return 'q';
X    }
X    if (ch == '+') {
X	if (!thread_cmd) {
X	    (void)art_search(buf, (sizeof buf), TRUE);
X	    art = art_hold;
X	    artp = artp_hold;
X	    ch = '.';
X	} else
X	    ch = (use_one_line? '+' : '.');
X	if (thread_cmd)
X	    select_thread(artp->subj->thread, AF_AUTOSELECTALL);
X	else
X	    select_subject(artp->subj, 0);
X	if (mode != 't')
X	    printf("\nSelection memorized.\n");
X    } else if (ch == '.') {
X	if (!thread_cmd) {
X	    (void)art_search(buf, (sizeof buf), TRUE);
X	    art = art_hold;
X	    artp = artp_hold;
X	} else
X	    ch = (use_one_line? '+' : '.');
X	select_subthread(artp,thread_cmd? AF_AUTOSELECT : 0);
X	if (mode != 't')
X	    printf("\nSelection memorized.\n");
X    } else if (ch == 'j') {
X	if (!thread_cmd) {
X	    *buf = 'K';
X	    (void)art_search(buf, (sizeof buf), TRUE);
X	    art = art_hold;
X	    artp = artp_hold;
X	}
X	if (thread_cmd)
X	    kill_thread(artp->subj->thread,KF_ALL|KF_KILLFILE);
X	else
X	    kill_subject(artp->subj,KF_ALL);
X	if (mode != 't')
X	    printf("\nKill memorized.\n");
X    } else if (ch == ',') {
X	if (!thread_cmd) {
X	    (void)art_search(buf, (sizeof buf), TRUE);
X	    art = art_hold;
X	    artp = artp_hold;
X	}
X	kill_subthread(artp,KF_ALL|(thread_cmd?KF_KILLFILE:0));
X	if (mode != 't')
X	    printf("\nKill memorized.\n");
X    } else if (ch == 'c') {
X	if (thread_cmd)
X	    clear_thread(artp->subj->thread);
X	else
X	    clear_subject(artp->subj);
X    } else if (ch == 'C') {
X	clear_subthread(artp);
X    } else {
X	use_one_line = FALSE;
X	printf("\n%s\n", hforhelp) FLUSH;
X	settle_down();
X	goto reask_memorize;
X    }
X    if (!use_one_line)
X	putchar('\n') FLUSH;
X    return ch;
X}
END_OF_FILE
if test 33206 -ne `wc -c <'ng.c'`; then
    echo shar: \"'ng.c'\" unpacked with wrong size!
fi
# end of 'ng.c'
fi
if test -f 'rthread.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rthread.c'\"
else
echo shar: Extracting \"'rthread.c'\" \(32362 characters\)
sed "s/^X//" >'rthread.c' <<'END_OF_FILE'
X/* $Id: rthread.c,v 3.0 1992/12/14 00:14:13 davison Trn $
X*/
X/* The authors make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X */
X
X#include "EXTERN.h"
X#include "common.h"
X#include "intrp.h"
X#include "trn.h"
X#include "cache.h"
X#include "bits.h"
X#include "ng.h"
X#include "rcln.h"
X#include "search.h"
X#include "artstate.h"
X#include "rcstuff.h"
X#include "ngdata.h"
X#include "kfile.h"
X#include "head.h"
X#include "util.h"
X#include "hash.h"
X#include "nntp.h"
X#include "rt-mt.h"
X#include "rt-ov.h"
X#include "rt-page.h"
X#include "rt-process.h"
X#include "rt-select.h"
X#include "rt-util.h"
X#include "rt-wumpus.h"
X#include "INTERN.h"
X#include "rthread.h"
X
XHASHTABLE *msgid_hash = 0;
X
Xvoid
Xthread_init()
X{
X    if (try_ov)
X	try_ov = ov_init();
X    if (try_mt)
X	try_mt = mt_init();
X}
X
X/* Generate the thread data we need for this group.  We must call
X** thread_close() before calling this again.
X*/
Xvoid
Xthread_open()
X{
X    if (!msgid_hash)
X	msgid_hash = hashcreate(201, msgid_cmp); /*TODO: pick a better size */
X    if (ThreadedGroup) {
X	/* Parse input and use msgid_hash for quick article lookups. */
X	/* If cached but not threaded articles exist, set up to thread them. */
X	if (first_subject) {
X	    first_cached = firstart;
X	    last_cached = firstart - 1;
X	    parsed_art = 0;
X	}
X    }
X
X    if (sel_mode == SM_ARTICLE)
X	set_selector(sel_mode, sel_artsort);
X    else
X	set_selector(sel_threadmode, sel_threadsort);
X
X    if (try_mt && !first_subject)
X	if (!mt_data())
X	    return;
X    if (try_ov && first_cached > last_cached)
X	if (thread_always)
X	    (void) ov_data(absfirst, lastart, FALSE);
X	else if (firstart > lastart) {
X	    /* If no unread articles, see if ov. exists as quick as possible */
X	    (void) ov_data(absfirst, absfirst, FALSE);
X	    first_cached = last_cached+1;
X	} else
X	    (void) ov_data(firstart, lastart, FALSE);
X#ifdef USE_NNTP
X    if (!ov_opened)
X	setmissingbits();
X#endif
X
X#ifndef USE_NNTP
X    if (last_cached > lastart) {
X	toread[ng] += (ART_UNREAD)(last_cached-lastart);
X	/* ensure getngsize() knows the new maximum */
X	ngmax[ng] = lastart = last_cached;
X    }
X#endif
X    thread_grow();	/* thread any new articles not yet in the database */
X    added_articles = 0;
X    sel_page_sp = 0;
X    sel_page_app = 0;
X}
X
X/* Update the group's thread info.
X*/
Xvoid
Xthread_grow()
X{
X    added_articles = lastart - last_cached;
X    if (added_articles > 0 && thread_always)
X	cache_range(last_cached + 1, lastart);
X    count_subjects(CS_NORM);
X    if (artptr_list)
X	sort_articles();
X    else
X	sort_subjects();
X}
X
Xstatic void
Xkill_tmp_arts(data, extra)
XHASHDATUM *data;
Xint extra;
X{
X    register ARTICLE *ap = (ARTICLE*)data->dat_ptr;
X
X    if (ap) {
X	clear_article(ap);
X	free((char*)ap);
X    }
X}
X
Xvoid
Xthread_close()
X{
X    curr_artp = artp = Nullart;
X    init_tree();			/* free any tree lines */
X
X    if (msgid_hash) {
X	hashwalk(msgid_hash, kill_tmp_arts, 0);
X	hashdestroy(msgid_hash);
X	msgid_hash = 0;
X    }
X    sel_page_sp = 0;
X    sel_page_app = 0;
X    sel_last_ap = 0;
X    sel_last_sp = 0;
X    selected_only = FALSE;
X    sel_exclusive = 0;
X    ov_close();
X}
X
Xvoid
Xtop_article()
X{
X    art = lastart+1;
X    artp = Nullart;
X    inc_art(selected_only, FALSE);
X}
X
XARTICLE *
Xfirst_art(sp)
Xregister SUBJECT *sp;
X{
X    register ARTICLE *ap = (ThreadedGroup? sp->thread : sp->articles);
X    if (ap && (ap->flags & AF_MISSING))
X	ap = next_art(ap);
X    return ap;
X}
X
XARTICLE *
Xlast_art(sp)
Xregister SUBJECT *sp;
X{
X    register ARTICLE *ap;
X
X    if (!ThreadedGroup) {
X	ap = sp->articles;
X	while (ap->subj_next)
X	    ap = ap->subj_next;
X	return ap;
X    }
X
X    ap = sp->thread;
X    if (ap) {
X	for (;;) {
X	    if (ap->sibling)
X		ap = ap->sibling;
X	    else if (ap->child1)
X		ap = ap->child1;
X	    else
X		break;
X	}
X	if (ap->flags & AF_MISSING)
X	    ap = prev_art(ap);
X    }
X    return ap;
X}
X
X/* Bump art/artp to the next article, wrapping from thread to thread.
X** If sel_flag is TRUE, only stops at selected articles.
X** If rereading is FALSE, only stops at unread articles.
X*/
Xvoid
Xinc_art(sel_flag, rereading)
Xbool_int sel_flag, rereading;
X{
X    register ARTICLE *ap = artp;
X    int subj_mask = (sel_mode == SM_THREAD? (SF_THREAD|SF_VISIT) : SF_VISIT);
X
X    /* Use the explicit article-order if it exists */
X    if (artptr_list) {
X	ARTICLE **limit = artptr_list + artptr_list_size;
X	if (!ap)
X	    artptr = artptr_list-1;
X	else if (!artptr || *artptr != ap) {
X	    for (artptr = artptr_list; artptr < limit; artptr++) {
X		if (*artptr == ap)
X		    break;
X	    }
X	}
X	do {
X	    if (++artptr >= limit)
X		break;
X	    ap = *artptr;
X	} while ((!rereading && (ap->flags & AF_READ))
X	      || (sel_flag && !(ap->flags & AF_SEL)));
X	if (artptr < limit) {
X	    artp = *artptr;
X	    art = article_num(artp);
X	} else {
X	    artp = Nullart;
X	    art = lastart+1;
X	    artptr = artptr_list;
X	}
X	return;
X    }
X
X    /* Use subject- or thread-order when possible */
X    if (ThreadedGroup || srchahead) {
X	register SUBJECT *sp;
X	if (ap)
X	    sp = ap->subj;
X	else
X	    for (sp = first_subject; sp && (sp->flags&subj_mask) != subj_mask;)
X		sp = sp->next;
X	if (!sp)
X	    goto num_inc;
X	do {
X	    if (ap)
X		ap = next_art(ap);
X	    else
X		ap = first_art(sp);
X	    while (!ap) {
X		while ((sp = sp->next) != Nullsubj
X		    && !rereading && (sp->flags & subj_mask) != subj_mask)
X		    ;
X		if (!sp)
X		    break;
X		ap = first_art(sp);
X	    }
X	} while (ap && ((!rereading && (ap->flags & AF_READ))
X		     || (sel_flag && !(ap->flags & AF_SEL))));
X	if ((artp = ap) != Nullart)
X	    art = article_num(ap);
X	else {
X	    if (art <= last_cached)
X		art = last_cached+1;
X	    else
X		art++;
X	    if (art <= lastart)
X		artp = article_ptr(art);
X	    else
X		art = lastart+1;
X	}
X	return;
X    }
X
X    /* Otherwise, just increment through the art numbers */
X  num_inc:
X    if (!ap) {
X	art = firstart-1;
X	ap = article_ptr(art);
X    }
X    do {
X	if (++art > lastart) {
X	    ap = Nullart;
X	    break;
X	}
X	ap++;
X    } while ((!rereading && (ap->flags & AF_READ))
X	  || (sel_flag && !(ap->flags & AF_SEL))
X	  || (ap->flags & AF_MISSING));
X    artp = ap;
X}
X
X/* Bump art/artp to the previous article, wrapping from thread to thread.
X** If sel_flag is TRUE, only stops at selected articles.
X** If rereading is FALSE, only stops at unread articles.
X*/
Xvoid
Xdec_art(sel_flag, rereading)
Xbool_int sel_flag, rereading;
X{
X    register ARTICLE *ap = artp;
X    int subj_mask = (sel_mode == SM_THREAD? (SF_THREAD|SF_VISIT) : SF_VISIT);
X
X    /* Use the explicit article-order if it exists */
X    if (artptr_list) {
X	ARTICLE **limit = artptr_list + artptr_list_size;
X	if (!ap)
X	    artptr = limit;
X	else if (!artptr || *artptr != ap) {
X	    for (artptr = artptr_list; artptr < limit; artptr++) {
X		if (*artptr == ap)
X		    break;
X	    }
X	}
X	do {
X	    if (artptr == artptr_list)
X		break;
X	    ap = *--artptr;
X	} while ((!rereading && (ap->flags & AF_READ))
X	      || (sel_flag && !(ap->flags & AF_SEL)));
X	artp = *artptr;
X	art = article_num(artp);
X	return;
X    }
X
X    /* Use subject- or thread-order when possible */
X    if (ThreadedGroup || srchahead) {
X	register SUBJECT *sp;
X	if (ap)
X	    sp = ap->subj;
X	else
X	    for (sp = last_subject; sp && (sp->flags&subj_mask) != subj_mask;)
X		sp = sp->prev;
X	if (!sp)
X	    goto num_dec;
X	do {
X	    if (ap)
X		ap = prev_art(ap);
X	    else
X		ap = last_art(sp);
X	    while (!ap) {
X		while ((sp = sp->prev) != Nullsubj
X		    && !rereading && (sp->flags & subj_mask) != subj_mask)
X		    ;
X		if (!sp)
X		    break;
X		ap = last_art(sp);
X	    }
X	} while (ap && ((!rereading && (ap->flags & AF_READ))
X		     || (sel_flag && !(ap->flags & AF_SEL))));
X	if ((artp = ap) != Nullart)
X	    art = article_num(ap);
X	else
X	    art = absfirst-1;
X	return;
X    }
X
X    /* Otherwise, just decrement through the art numbers */
X  num_dec:
X    ap = article_ptr(art);
X    do {
X	if (--art < absfirst) {
X	    ap = Nullart;
X	    break;
X	}
X	ap--;
X    } while ((!rereading && (ap->flags & AF_READ))
X	  || (sel_flag && !(ap->flags & AF_SEL))
X	  || (ap->flags & AF_MISSING));
X    artp = ap;
X}
X
X/* Bump the param to the next article in depth-first order.
X*/
XARTICLE *
Xbump_art(ap)
Xregister ARTICLE *ap;
X{
X    if (ap->child1)
X	return ap->child1;
X    while (!ap->sibling) {
X	if (!(ap = ap->parent))
X	    return Nullart;
X    }
X    return ap->sibling;
X}
X
X/* Bump the param to the next REAL article.  Uses subject order in a
X** non-threaded group; honors the breadth_first flag in a threaded one.
X*/
XARTICLE *
Xnext_art(ap)
Xregister ARTICLE *ap;
X{
Xtry_again:
X    if (!ThreadedGroup) {
X	ap = ap->subj_next;
X	goto done;
X    }
X    if (breadth_first) {
X	if (ap->sibling) {
X	    ap = ap->sibling;
X	    goto done;
X	}
X	if (ap->parent)
X	    ap = ap->parent->child1;
X	else
X	    ap = ap->subj->thread;
X    }
X    do {
X	if (ap->child1) {
X	    ap = ap->child1;
X	    goto done;
X	}
X	while (!ap->sibling) {
X	    if (!(ap = ap->parent))
X		return Nullart;
X	}
X	ap = ap->sibling;
X    } while (breadth_first);
Xdone:
X    if (ap && (ap->flags & AF_MISSING))
X	goto try_again;
X    return ap;
X}
X
X/* Bump the param to the previous REAL article.  Uses subject order in a
X** non-threaded group.
X*/
XARTICLE *
Xprev_art(ap)
Xregister ARTICLE *ap;
X{
X    register ARTICLE *initial_ap;
X
Xtry_again:
X    initial_ap = ap;
X    if (!ThreadedGroup) {
X	if ((ap = ap->subj->articles) == initial_ap)
X	    ap = Nullart;
X	else
X	    while (ap->subj_next != initial_ap)
X		ap = ap->subj_next;
X	goto done;
X    }
X    ap = (ap->parent ? ap->parent->child1 : ap->subj->thread);
X    if (ap == initial_ap) {
X	ap = ap->parent;
X	goto done;
X    }
X    while (ap->sibling != initial_ap)
X	ap = ap->sibling;
X    while (ap->child1) {
X	ap = ap->child1;
X	while (ap->sibling)
X	    ap = ap->sibling;
X    }
Xdone:
X    if (ap && (ap->flags & AF_MISSING))
X	goto try_again;
X    return ap;
X}
X
X/* Find the next art/artp with the same subject as this one.  Returns
X** FALSE if no such article exists.
X*/
Xbool
Xnext_art_with_subj()
X{
X    register ARTICLE *ap = artp;
X    register SUBJECT *sp;
X
X    if (!ap)
X	return FALSE;
X    sp = ap->subj;
X
X    do {
X	ap = ap->subj_next;
X	if (!ap) {
X	    if (!art)
X		art = firstart;
X	    return FALSE;
X	}
X    } while ((ap->flags & (AF_READ|AF_MISSING))
X	  || (selected_only && !(ap->flags & AF_SEL)));
X    artp = ap;
X    art = article_num(ap);
X#ifdef ARTSEARCH
X    srchahead = -1;
X#endif
X    return TRUE;
X}
X
X/* Find the previous art/artp with the same subject as this one.  Returns
X** FALSE if no such article exists.
X*/
Xbool
Xprev_art_with_subj()
X{
X    register ARTICLE *ap = artp, *ap2;
X    register SUBJECT *sp;
X
X    if (!ap)
X	return FALSE;
X    sp = ap->subj;
X
X    do {
X	ap2 = ap->subj->articles;
X	if (ap2 == ap)
X	    ap = Nullart;
X	else {
X	    while (ap2 && ap2->subj_next != ap)
X		ap2 = ap2->subj_next;
X	    ap = ap2;
X	}
X	if (!ap) {
X	    if (!art)
X		art = lastart;
X	    return FALSE;
X	}
X    } while ((ap->flags & AF_MISSING)
X	  || (selected_only && !(ap->flags & AF_SEL)));
X    artp = ap;
X    art = article_num(ap);
X    return TRUE;
X}
X
X/* Select a single article.
X*/
Xvoid
Xselect_article(ap, sel_flags)
Xregister ARTICLE *ap;
Xint sel_flags;
X{
X    int desired_flags = (sel_rereading? AF_READ : 0);
X#ifdef VERBOSE
X    bool echo;
X
X    if (sel_flags & AF_ECHO) {
X	echo = TRUE;
X	sel_flags &= ~AF_ECHO;
X    } else
X	echo = FALSE;
X#else
X    sel_flags &= ~AF_ECHO;
X#endif
X    if (sel_flags & (AF_AUTOSELECT|AF_AUTOSELECTALL))
X	localkf_changes = 2;
X    if ((ap->flags & (AF_MISSING|AF_READ)) == desired_flags) {
X	if (!(ap->flags & sel_mask)) {
X	    selected_count++;
X#ifdef VERBOSE
X	    if (echo) {
X		IF(verbose)
X		    fputs("\tSelected",stdout);
X	    }
X#endif
X	}
X	ap->flags = (ap->flags & ~AF_DEL) | sel_mask | sel_flags;
X    } else
X	ap->flags |= sel_flags;
X    if (ap->subj) {
X	if (!(ap->subj->flags & sel_mask))
X	    selected_subj_cnt++;
X	ap->subj->flags = (ap->subj->flags&~SF_DEL) | sel_mask | SF_VISIT;
X	if (sel_mode == SM_THREAD) {
X	    if ((ap = ap->subj->thread) != NULL)
X		ap->subj->flags |= SF_VISIT;
X	}
X    }
X    selected_only = (selected_only || selected_count != 0);
X}
X
X/* Select all the articles in a subject.
X*/
Xvoid
Xselect_subject(subj, sel_flags)
XSUBJECT *subj;
Xint sel_flags;
X{
X    register ARTICLE *ap;
X    int desired_flags = (sel_rereading? AF_READ : 0);
X    int old_count = selected_count;
X
X    if (sel_flags & (AF_AUTOSELECT|AF_AUTOSELECTALL))
X	localkf_changes = 2;
X    for (ap = subj->articles; ap; ap = ap->subj_next) {
X	if ((ap->flags & (AF_MISSING|AF_READ|sel_mask)) == desired_flags) {
X	    ap->flags |= sel_mask | sel_flags;
X	    selected_count++;
X	} else
X	    ap->flags |= sel_flags;
X    }
X    if (selected_count > old_count) {
X	if (!(subj->flags & sel_mask))
X	    selected_subj_cnt++;
X	subj->flags = (subj->flags & ~SF_DEL)
X		    | sel_mask | SF_VISIT | SF_WASSELECTED;
X	if (sel_mode == SM_THREAD) {
X	    if ((ap = subj->thread) != NULL)
X		ap->subj->flags |= SF_VISIT;
X	}
X	selected_only = TRUE;
X    } else
X	subj->flags |= SF_WASSELECTED;
X}
X
X/* Select all the articles in a thread.
X*/
Xvoid
Xselect_thread(thread, sel_flags)
Xregister ARTICLE *thread;
Xint sel_flags;
X{
X    register SUBJECT *sp;
X
X    sp = thread->subj;
X    do {
X	select_subject(sp, sel_flags);
X	sp = sp->thread_link;
X    } while (sp != thread->subj);
X}
X
X/* Select the subthread attached to this article.
X*/
Xvoid
Xselect_subthread(ap, sel_flags)
Xregister ARTICLE *ap;
Xint sel_flags;
X{
X    register ARTICLE *limit;
X    SUBJECT *subj;
X    int desired_flags = (sel_rereading? AF_READ : 0);
X    int old_count = selected_count;
X
X    if (!ap)
X	return;
X    subj = ap->subj;
X    for (limit = ap; limit; limit = limit->parent) {
X	if (limit->sibling) {
X	    limit = limit->sibling;
X	    break;
X	}
X    }
X
X    if (sel_flags & (AF_AUTOSELECT|AF_AUTOSELECTALL))
X	localkf_changes = 2;
X    for (; ap != limit; ap = bump_art(ap)) {
X	if ((ap->flags & (AF_MISSING|AF_READ|sel_mask)) == desired_flags) {
X	    ap->flags |= sel_mask | sel_flags;
X	    selected_count++;
X	} else
X	    ap->flags |= sel_flags;
X    }
X    if (subj && selected_count > old_count) {
X	if (!(subj->flags & sel_mask))
X	    selected_subj_cnt++;
X	subj->flags = (subj->flags & ~SF_DEL) | sel_mask | SF_VISIT;
X	if (sel_mode == SM_THREAD) {
X	    if ((ap = subj->thread) != NULL)
X		ap->subj->flags |= SF_VISIT;
X	}
X	selected_only = TRUE;
X    }
X}
X
X/* Deselect a single article.
X*/
Xvoid
Xdeselect_article(ap)
Xregister ARTICLE *ap;
X{
X    if (ap->flags & sel_mask) {
X	ap->flags &= ~sel_mask;
X	if (!selected_count--)
X	    selected_count = 0;
X#ifdef VERBOSE
X	if (mode != 't') {
X	    IF(verbose)
X		fputs("\tDeselected",stdout);
X	}
X#endif
X    }
X    if (sel_rereading && sel_mode == SM_ARTICLE)
X	ap->flags |= AF_DEL;
X}
X
X/* Deselect all the articles in a subject.
X*/
Xvoid
Xdeselect_subject(subj)
XSUBJECT *subj;
X{
X    register ARTICLE *ap;
X
X    for (ap = subj->articles; ap; ap = ap->subj_next) {
X	if (ap->flags & sel_mask) {
X	    ap->flags &= ~sel_mask;
X	    if (!selected_count--)
X		selected_count = 0;
X	}
X    }
X    if (subj->flags & sel_mask) {
X	subj->flags &= ~sel_mask;
X	selected_subj_cnt--;
X    }
X    subj->flags &= ~(SF_VISIT | SF_WASSELECTED);
X    if (sel_rereading)
X	subj->flags |= SF_DEL;
X    else
X	subj->flags &= ~SF_DEL;
X}
X
X/* Deselect all the articles in a thread.
X*/
Xvoid
Xdeselect_thread(thread)
Xregister ARTICLE *thread;
X{
X    register SUBJECT *sp;
X
X    sp = thread->subj;
X    do {
X	deselect_subject(sp);
X	sp = sp->thread_link;
X    } while (sp != thread->subj);
X}
X
X/* Deselect everything.
X*/
Xvoid
Xdeselect_all()
X{
X    register SUBJECT *sp;
X
X    for (sp = first_subject; sp; sp = sp->next)
X	deselect_subject(sp);
X    selected_count = selected_subj_cnt = 0;
X    sel_page_sp = 0;
X    sel_page_app = 0;
X    sel_last_ap = 0;
X    sel_last_sp = 0;
X    selected_only = FALSE;
X}
X
X/* Kill all unread articles attached to the given subject.
X*/
Xvoid
Xkill_subject(subj, kill_flags)
XSUBJECT *subj;
Xint kill_flags;
X{
X    register ARTICLE *ap;
X    register int killmask = ((kill_flags&KF_ALL)? AF_READ:(AF_READ|sel_mask));
X
X    if (kill_flags & KF_KILLFILE) {
X	localkf_changes = 2;
X	kill_flags = AF_AUTOKILLALL;
X    } else
X	kill_flags = 0;
X    for (ap = subj->articles; ap; ap = ap->subj_next) {
X	if (!(ap->flags & killmask))
X	    set_read(ap);
X	ap->flags |= kill_flags;
X    }
X    subj->flags &= ~(SF_VISIT | SF_WASSELECTED);
X}
X
X/* Kill all unread articles attached to the given thread.
X*/
Xvoid
Xkill_thread(thread, kill_flags)
Xregister ARTICLE *thread;
Xint kill_flags;
X{
X    register SUBJECT *sp;
X
X    sp = thread->subj;
X    do {
X	kill_subject(sp, kill_flags);
X	sp = sp->thread_link;
X    } while (sp != thread->subj);
X}
X
X/* Kill the subthread attached to this article.
X*/
Xvoid
Xkill_subthread(ap, kill_flags)
Xregister ARTICLE *ap;
Xint kill_flags;
X{
X    register ARTICLE *limit;
X
X    if (!ap)
X	return;
X    for (limit = ap; limit; limit = limit->parent) {
X	if (limit->sibling) {
X	    limit = limit->sibling;
X	    break;
X	}
X    }
X
X    if (kill_flags & KF_KILLFILE) {
X	localkf_changes = 2;
X	kill_flags = AF_AUTOKILL;
X    } else
X	kill_flags = 0;
X    for (; ap != limit; ap = bump_art(ap)) {
X	if (!(ap->flags & (AF_READ|AF_MISSING)))
X	    set_read(ap);
X	ap->flags |= kill_flags;
X    }
X}
X
X/* Unkill all the articles attached to the given subject.
X*/
Xvoid
Xunkill_subject(subj)
XSUBJECT *subj;
X{
X    register ARTICLE *ap;
X
X    for (ap = subj->articles; ap; ap = ap->subj_next) {
X	if (sel_rereading) {
X	    if ((ap->flags & (AF_DELSEL|AF_MISSING)) == AF_DELSEL) {
X		if (ap->flags & AF_READ)
X		    toread[ng]++;
X		ap->flags = (ap->flags & ~(AF_DELSEL|AF_READ)) | AF_SEL;
X	    } else
X		ap->flags &= ~(AF_DEL|AF_DELSEL);
X	} else {
X	    if ((ap->flags & (AF_READ|AF_MISSING)) == AF_READ)
X		onemore(ap);
X	    if (selected_only && !(ap->flags & (AF_SEL|AF_READ))) {
X		ap->flags = (ap->flags & ~AF_DEL) | AF_SEL;
X		selected_count++;
X	    }
X	}
X    }
X    if (!sel_rereading && selected_only && !(subj->flags & SF_SEL)) {
X	subj->flags |= SF_SEL | SF_VISIT | SF_WASSELECTED;
X	if (sel_mode == SM_THREAD) {
X	    if ((ap = subj->thread) != NULL)
X		ap->subj->flags |= SF_VISIT;
X	}
X	selected_subj_cnt++;
X    }
X    subj->flags &= ~(SF_DEL|SF_DELSEL);
X}
X
X/* Unkill all the articles attached to the given thread.
X*/
Xvoid
Xunkill_thread(thread)
Xregister ARTICLE *thread;
X{
X    register SUBJECT *sp;
X
X    sp = thread->subj;
X    do {
X	unkill_subject(sp);
X	sp = sp->thread_link;
X    } while (sp != thread->subj);
X}
X
X/* Unkill the subthread attached to this article.
X*/
Xvoid
Xunkill_subthread(ap)
Xregister ARTICLE *ap;
X{
X    register ARTICLE *limit;
X    register SUBJECT *sp;
X
X    if (!ap)
X	return;
X    for (limit = ap; limit; limit = limit->parent) {
X	if (limit->sibling) {
X	    limit = limit->sibling;
X	    break;
X	}
X    }
X
X    sp = ap->subj;
X    for (; ap != limit; ap = bump_art(ap)) {
X	if ((ap->flags & (AF_READ|AF_MISSING)) == AF_READ)
X	    onemore(ap);
X	if (selected_only && !(ap->flags & AF_SEL)) {
X	    ap->flags |= AF_SEL;
X	    selected_count++;
X	}
X    }
X    if (!(sp->flags & sel_mask))
X	selected_subj_cnt++;
X    sp->flags = (sp->flags & ~SF_DEL) | SF_SEL | SF_VISIT;
X    if (sel_mode == SM_THREAD) {
X	if ((ap = sp->thread) != NULL)
X	    ap->subj->flags |= SF_VISIT;
X    }
X    selected_only = (selected_only || selected_count != 0);
X}
X
X/* Clear the auto flags in all unread articles attached to the given subject.
X*/
Xvoid
Xclear_subject(subj)
XSUBJECT *subj;
X{
X    register ARTICLE *ap;
X
X    for (ap = subj->articles; ap; ap = ap->subj_next) {
X	ap->flags &= ~AF_AUTOFLAGS;
X    }
X    localkf_changes = 2;
X}
X
X/* Clear the auto flags in all unread articles attached to the given thread.
X*/
Xvoid
Xclear_thread(thread)
Xregister ARTICLE *thread;
X{
X    register SUBJECT *sp;
X
X    sp = thread->subj;
X    do {
X	clear_subject(sp);
X	sp = sp->thread_link;
X    } while (sp != thread->subj);
X}
X
X/* Clear the auto flags in the subthread attached to this article.
X*/
Xvoid
Xclear_subthread(ap)
Xregister ARTICLE *ap;
X{
X    register ARTICLE *limit;
X
X    if (!ap)
X	return;
X    for (limit = ap; limit; limit = limit->parent) {
X	if (limit->sibling) {
X	    limit = limit->sibling;
X	    break;
X	}
X    }
X
X    for (; ap != limit; ap = bump_art(ap)) {
X	ap->flags &= ~AF_AUTOFLAGS;
X    }
X    localkf_changes = 2;
X}
X
XARTICLE *
Xsubj_art(sp)
XSUBJECT *sp;
X{
X    register ARTICLE *ap = Nullart;
X    int art_mask = (selected_only? AF_SEL : 0);
X    bool TG_save = ThreadedGroup;
X
X    ThreadedGroup = (sel_mode == SM_THREAD);
X    ap = first_art(sp);
X    while (ap && (ap->flags & (art_mask|AF_READ)) != art_mask)
X	ap = next_art(ap);
X    if (!ap) {
X	reread = TRUE;
X	ap = first_art(sp);
X	if (art_mask) {
X	    while (ap && !(ap->flags & AF_SEL))
X		ap = next_art(ap);
X	    if (!ap)
X		ap = first_art(sp);
X	}
X    }
X    ThreadedGroup = TG_save;
X    return ap;
X}
X
X/* Find the next thread (first if art > lastart).  If articles are selected,
X** only choose from threads with selected articles.
X*/
Xvoid
Xnext_subject()
X{
X    register SUBJECT *sp;
X    register ARTICLE *ap;
X    int subj_mask = (sel_mode == SM_THREAD? (SF_THREAD|SF_VISIT) : SF_VISIT);
X
X    sp = ((ap = artp) ? ap->subj->next : first_subject);
X    for (; sp; sp = sp->next) {
X	if ((sp->flags & subj_mask) == subj_mask) {
X	    if ((ap = subj_art(sp)) != Nullart) {
X		art = article_num(ap);
X		artp = ap;
X		return;
X	    }
X	    reread = FALSE;
X	}
X    }
X    artp = Nullart;
X    art = lastart+1;
X    forcelast = TRUE;
X}
X
X/* Find previous thread (or last if artp == NULL).  If articles are selected,
X** only choose from threads with selected articles.
X*/
Xvoid
Xprev_subject()
X{
X    register SUBJECT *sp;
X    register ARTICLE *ap;
X    int subj_mask = (sel_mode == SM_THREAD? (SF_THREAD|SF_VISIT) : SF_VISIT);
X
X    sp = ((ap = artp) ? ap->subj->prev : last_subject);
X    for (; sp; sp = sp->prev) {
X	if ((sp->flags & subj_mask) == subj_mask) {
X	    if ((ap = subj_art(sp)) != Nullart) {
X		art = article_num(ap);
X		artp = ap;
X		return;
X	    }
X	    reread = FALSE;
X	}
X    }
X    artp = Nullart;
X    art = lastart+1;
X    forcelast = TRUE;
X}
X
X/* Find artp's parent or oldest ancestor.  Returns FALSE if no such
X** article.  Sets art and artp otherwise.
X*/
Xbool
Xfind_parent(keep_going)
Xbool_int keep_going;
X{
X    register ARTICLE *ap = artp;
X
X    if (!ap->parent)
X	return FALSE;
X
X    do {
X	ap = ap->parent;
X    } while (keep_going && ap->parent);
X
X    if (((artp = ap)->flags & AF_TMPMEM) == AF_TMPMEM)
X	art = 0;
X    else
X	art = article_num(ap);
X    return TRUE;
X}
X
X/* Find artp's first child or youngest decendent.  Returns FALSE if no
X** such article.  Sets art and artp otherwise.
X*/
Xbool
Xfind_leaf(keep_going)
Xbool_int keep_going;
X{
X    register ARTICLE *ap = artp;
X
X    if (!ap->child1)
X	return FALSE;
X
X    do {
X	ap = ap->child1;
X    } while (keep_going && ap->child1);
X
X    if (((artp = ap)->flags & AF_TMPMEM) == AF_TMPMEM)
X	art = 0;
X    else
X	art = article_num(ap);
X    return TRUE;
X}
X
Xstatic ARTICLE *first_sib(), *last_sib();
X
X/* Find the next "sibling" of artp, including cousins that are the
X** same distance down the thread as we are.  Returns FALSE if no such
X** article.  Sets art and artp otherwise.
X*/
Xbool
Xfind_next_sib()
X{
X    ARTICLE *ta, *tb;
X    int ascent;
X
X    ascent = 0;
X    ta = artp;
X    for (;;) {
X	while (ta->sibling) {
X	    ta = ta->sibling;
X	    if (tb = first_sib(ta, ascent)) {
X		if (((artp = tb)->flags & AF_TMPMEM) == AF_TMPMEM)
X		    art = 0;
X		else
X		    art = article_num(tb);
X		return TRUE;
X	    }
X	}
X	if (!(ta = ta->parent))
X	    break;
X	ascent++;
X    }
X    return FALSE;
X}
X
X/* A recursive routine to find the first node at the proper depth.  This
X** article is at depth 0.
X*/
Xstatic ARTICLE *
Xfirst_sib(ta, depth)
XARTICLE *ta;
Xint depth;
X{
X    ARTICLE *tb;
X
X    if (!depth)
X	return ta;
X
X    for (;;) {
X	if (ta->child1 && (tb = first_sib(ta->child1, depth-1)))
X	    return tb;
X
X	if (!ta->sibling)
X	    return Nullart;
X
X	ta = ta->sibling;
X    }
X}
X
X/* Find the previous "sibling" of artp, including cousins that are
X** the same distance down the thread as we are.  Returns FALSE if no
X** such article.  Sets art and artp otherwise.
X*/
Xbool
Xfind_prev_sib()
X{
X    ARTICLE *ta, *tb;
X    int ascent;
X
X    ascent = 0;
X    ta = artp;
X    for (;;) {
X	tb = ta;
X	if (ta->parent)
X	    ta = ta->parent->child1;
X	else
X	    ta = ta->subj->thread;
X	if (tb = last_sib(ta, ascent, tb)) {
X	    if (((artp = tb)->flags & AF_TMPMEM) == AF_TMPMEM)
X		art = 0;
X	    else
X		art = article_num(tb);
X	    return TRUE;
X	}
X	if (!(ta = ta->parent))
X	    break;
X	ascent++;
X    }
X    return FALSE;
X}
X
X/* A recursive routine to find the last node at the proper depth.  This
X** article is at depth 0.
X*/
Xstatic ARTICLE *
Xlast_sib(ta, depth, limit)
XARTICLE *ta;
Xint depth;
XARTICLE *limit;
X{
X    ARTICLE *tb, *tc;
X
X    if (ta == limit)
X	return Nullart;
X
X    if (ta->sibling) {
X	tc = ta->sibling;
X	if (tc != limit && (tb = last_sib(tc,depth,limit)))
X	    return tb;
X    }
X    if (!depth)
X	return ta;
X    if (ta->child1)
X	return last_sib(ta->child1, depth-1, limit);
X    return Nullart;
X}
X
X/* Get each subject's article count; count total articles and selected
X** articles (use sel_rereading to determine whether to count read or
X** unread articles); deselect any subjects we find that are empty if
X** CS_UNSELECT or CS_UNSEL_STORE is specified.  If mode is CS_RESELECT
X** is specified, the selections from the last CS_UNSEL_STORE are
X** reselected.
X*/
Xvoid
Xcount_subjects(mode)
Xint mode;
X{
X    register int count, sel_count;
X    register ARTICLE *ap;
X    register SUBJECT *sp;
X    int desired_flags = (sel_rereading? AF_READ : 0);
X    time_t subjdate;
X
X    article_count = selected_count = selected_subj_cnt = 0;
X    if (last_cached >= lastart)
X	firstart = lastart+1;
X
X    if (mode != CS_RETAIN)
X	for (sp = first_subject; sp; sp = sp->next)
X	    sp->flags &= ~SF_VISIT;
X    for (sp = first_subject; sp; sp = sp->next) {
X	subjdate = 0;
X	count = sel_count = 0;
X	for (ap = sp->articles; ap; ap = ap->subj_next) {
X	    if ((ap->flags & (AF_MISSING|AF_READ)) == desired_flags) {
X		count++;
X		if (ap->flags & sel_mask)
X		    sel_count++;
X		if (!subjdate)
X		    subjdate = ap->date;
X		if (article_num(ap) < firstart)
X		    firstart = article_num(ap);
X	    }
X	}
X	if (mode == CS_UNSEL_STORE) {
X	    if (sp->flags & SF_SEL)
X		sp->flags |= SF_OLDSEL;
X	    else
X		sp->flags &= ~SF_OLDSEL;
X	} else if (mode == CS_RESELECT) {
X	    if (sp->flags & SF_OLDSEL)
X		sp->flags |= SF_SEL;
X	    else
X		sp->flags &= ~SF_SEL;
X	}
X	sp->misc = count;
X	if (subjdate)
X	    sp->date = subjdate;
X	article_count += count;
X	if (sel_count) {
X	    sp->flags = (sp->flags & ~(SF_SEL|SF_DEL)) | sel_mask;
X	    selected_count += sel_count;
X	    selected_subj_cnt++;
X	} else if (mode >= CS_UNSELECT)
X	    sp->flags &= ~sel_mask;
X	else if (sp->flags & sel_mask) {
X	    sp->flags &= ~SF_DEL;
X	    selected_subj_cnt++;
X	}
X	if (count && (!selected_only || (sp->flags & sel_mask))) {
X	    sp->flags |= SF_VISIT;
X	    if (sel_mode == SM_THREAD) {
X		if ((ap = sp->thread) != NULL)
X		    ap->subj->flags |= SF_VISIT;
X	    }
X	}
X    }
X    if (mode != CS_RETAIN && !article_count && !selected_only) {
X	for (sp = first_subject; sp; sp = sp->next)
X	    sp->flags |= SF_VISIT;
X    }
X}
X
Xint
Xsubjorder_subject(spp1, spp2)
Xregister SUBJECT **spp1;
Xregister SUBJECT **spp2;
X{
X    return strcasecmp((*spp1)->str+4, (*spp2)->str+4) * sel_direction;
X}
X
Xint
Xsubjorder_date(spp1, spp2)
Xregister SUBJECT **spp1;
Xregister SUBJECT **spp2;
X{
X    return (int)((*spp1)->date - (*spp2)->date) * sel_direction;
X}
X
Xint
Xsubjorder_count(spp1, spp2)
Xregister SUBJECT **spp1;
Xregister SUBJECT **spp2;
X{
X    int eq;
X    if ((eq = (int)((*spp1)->misc - (*spp2)->misc)) != 0)
X	return eq * sel_direction;
X    return (int)((*spp1)->date - (*spp2)->date);
X}
X
Xint
Xthreadorder_subject(spp1, spp2)
XSUBJECT **spp1;
XSUBJECT **spp2;
X{
X    register ARTICLE *t1 = (*spp1)->thread;
X    register ARTICLE *t2 = (*spp2)->thread;
X    if (t1 != t2 && t1 && t2)
X	return strcasecmp(t1->subj->str+4, t2->subj->str+4) * sel_direction;
X    return (int)((*spp1)->date - (*spp2)->date);
X}
X
Xint
Xthreadorder_date(spp1, spp2)
XSUBJECT **spp1;
XSUBJECT **spp2;
X{
X    register ARTICLE *t1 = (*spp1)->thread;
X    register ARTICLE *t2 = (*spp2)->thread;
X    if (t1 != t2 && t1 && t2) {
X	register SUBJECT *sp1, *sp2;
X	int eq;
X	if (!(sp1 = t1->subj)->misc)
X	    for (sp1=sp1->thread_link; sp1 != t1->subj; sp1=sp1->thread_link)
X		if (sp1->misc)
X		    break;
X	if (!(sp2 = t2->subj)->misc)
X	    for (sp2=sp2->thread_link; sp2 != t2->subj; sp2=sp2->thread_link)
X		if (sp2->misc)
X		    break;
X	if (!(eq = (int)(sp1->date - sp2->date)))
X	    return strcasecmp(sp1->str+4, sp2->str+4);
X	return eq * sel_direction;
X    }
X    return (int)((*spp1)->date - (*spp2)->date);
X}
X
Xint
Xthreadorder_count(spp1, spp2)
XSUBJECT **spp1;
XSUBJECT **spp2;
X{
X    register int size1 = (*spp1)->misc;
X    register int size2 = (*spp2)->misc;
X    if ((*spp1)->thread != (*spp2)->thread) {
X	register SUBJECT *sp;
X	for (sp = (*spp1)->thread_link; sp != *spp1; sp = sp->thread_link)
X	    size1 += sp->misc;
X	for (sp = (*spp2)->thread_link; sp != *spp2; sp = sp->thread_link)
X	    size2 += sp->misc;
X    }
X    if (size1 != size2)
X	return (size1 - size2) * sel_direction;
X    return threadorder_date(spp1, spp2);
X}
X
X/* Sort the subjects according to the chosen order.
X*/
Xvoid
Xsort_subjects()
X{
X    register SUBJECT *sp;
X    register int i;
X    SUBJECT **lp, **subj_list;
X    int (*sort_procedure)();
X
X    /* If we don't have at least two subjects, we're done! */
X    if (!first_subject || !first_subject->next)
X	return;
X
X    switch (sel_sort) {
X    case SS_DATE:
X    case SS_AUTHOR:
X    case SS_GROUPS:
X	sort_procedure = (sel_mode == SM_THREAD?
X			  threadorder_date : subjorder_date);
X	break;
X    case SS_SUBJECT:
X	sort_procedure = (sel_mode == SM_THREAD?
X			  threadorder_subject : subjorder_subject);
X	break;
X    case SS_COUNT:
X	sort_procedure = (sel_mode == SM_THREAD?
X			  threadorder_count : subjorder_count);
X	break;
X    }
X
X    subj_list = (SUBJECT**)safemalloc(subject_count * sizeof (SUBJECT*));
X    for (lp = subj_list, sp = first_subject; sp; sp = sp->next)
X	*lp++ = sp;
X    assert(lp - subj_list == subject_count);
X
X    qsort(subj_list, subject_count, sizeof (SUBJECT*), sort_procedure);
X
X    first_subject = sp = subj_list[0];
X    sp->prev = Nullsubj;
X    for (i = subject_count, lp = subj_list; --i; lp++) {
X	lp[0]->next = lp[1];
X	lp[1]->prev = lp[0];
X	if (sel_mode == SM_THREAD) {
X	    if (lp[0]->thread == lp[1]->thread)
X		lp[0]->thread_link = lp[1];
X	    else {
X		lp[0]->thread_link = sp;
X		sp = lp[1];
X	    }
X	}
X    }
X    last_subject = lp[0];
X    last_subject->next = Nullsubj;
X    if (sel_mode == SM_THREAD)
X	last_subject->thread_link = sp;
X    free((char*)subj_list);
X}
X
Xint
Xartorder_date(art1, art2)
Xregister ARTICLE **art1;
Xregister ARTICLE **art2;
X{
X    return (int)((*art1)->date - (*art2)->date) * sel_direction;
X}
X
Xint
Xartorder_subject(art1, art2)
Xregister ARTICLE **art1;
Xregister ARTICLE **art2;
X{
X    if ((*art1)->subj == (*art2)->subj)
X	return (int)((*art1)->date - (*art2)->date);
X    return strcasecmp((*art1)->subj->str + 4, (*art2)->subj->str + 4)
X	* sel_direction;
X}
X
Xint
Xartorder_author(art1, art2)
Xregister ARTICLE **art1;
Xregister ARTICLE **art2;
X{
X    int eq;
X    if ((eq = strcasecmp((*art1)->from, (*art2)->from)) != 0)
X	return eq * sel_direction;
X    return (int)((*art1)->date - (*art2)->date);
X}
X
Xint
Xartorder_groups(art1, art2)
Xregister ARTICLE **art1;
Xregister ARTICLE **art2;
X{
X    if ((*art1)->subj == (*art2)->subj)
X	return (int)((*art1)->date - (*art2)->date);
X    return (int)((*art1)->subj->date - (*art2)->subj->date) * sel_direction;
X}
X
X/* Sort the articles according to the chosen order.
X*/
Xvoid
Xsort_articles()
X{
X    int (*sort_procedure)();
X
X    build_artptrs();
X
X    /* If we don't have at least two articles, we're done! */
X    if (artptr_list_size < 2)
X	return;
X
X    switch (sel_sort) {
X    case SS_DATE:
X    case SS_COUNT:
X	sort_procedure = artorder_date;
X	break;
X    case SS_SUBJECT:
X	sort_procedure = artorder_subject;
X	break;
X    case SS_AUTHOR:
X	sort_procedure = artorder_author;
X	break;
X    case SS_GROUPS:
X	sort_procedure = artorder_groups;
X	break;
X    }
X    sel_page_app = 0;
X    qsort(artptr_list, artptr_list_size, sizeof (ARTICLE*), sort_procedure);
X}
X
Xstatic void
Xbuild_artptrs()
X{
X    ARTICLE **app, *ap;
X    ART_NUM count = article_count;
X    int desired_flags = (sel_rereading? AF_READ : 0);
X
X    if (!artptr_list || artptr_list_size != count) {
X	artptr_list = (ARTICLE**)saferealloc((char*)artptr_list,
X		(MEM_SIZE)count * sizeof (ARTICLE*));
X	artptr_list_size = count;
X    }
X    for (app = artptr_list, ap = article_list; count; ap++) {
X	if ((ap->flags & (AF_MISSING|AF_READ)) == desired_flags) {
X	    *app++ = ap;
X	    count--;
X	}
X    }
X}
END_OF_FILE
if test 32362 -ne `wc -c <'rthread.c'`; then
    echo shar: \"'rthread.c'\" unpacked with wrong size!
fi
# end of 'rthread.c'
fi
echo shar: End of archive 10 \(of 12\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 12 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
