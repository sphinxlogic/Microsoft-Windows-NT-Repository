Newsgroups: comp.sources.unix
From: yenne@austin.eds.com (Britt Yenne)
Subject: v27i024: ytalk-3.0 - multi-user replacement for the UNIX "talk" program, Part01/01
Message-id: <1.745877479.25571@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: yenne@austin.eds.com (Britt Yenne)
Posting-Number: Volume 27, Issue 24
Archive-Name: ytalk-3.0/part01

Okay... believe it or not, here it finally is.  Several people who have been
mailing me for months to ask about the status of 3.0 graciously
"volunteered" to beta-test, and all appears to work.

Ytalk is in essence a multi-user replacement for the UNIX "talk" program.
Not only will ytalk allow any number of users to connect with one another,
but it also will communicate with _both_ UNIX talk daemons, as well as
daemons compiled incorrectly and/or with byte-order or address boundary
problems.

There is a very large ytalk following spanning every continent, and older
versions of ytalk are available on more anonymous FTP sites than I can even
keep track of, but this is the first time I have attempted to post the
sources to a newsgroup.  Somehow, this seems more organized (or maybe I'm
frightfully naive... :-)

Version 3.0 is also the first ytalk source I am actually proud of.  It has
been completely rewritten since 2.3 to remove all of the desperate hacks
placed in response to incoming bug reports and comments.

My development platform is a Sun SPARC.  Although I have tested on every
platform I have access to, I am always looking for cross-platform compile
problems should anyone wish to mail me some.

	As always, have fun.
	-britt

	yenne@austin.eds.com

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  README Manifest ytalk.1 Imakefile Makefile term.doc
#   header.h menu.h socket.h curses.h xwin.h main.c comm.c fd.c menu.c
#   exec.c rc.c socket.c user.c term.c curses.c xwin.c
# Wrapped by yenne@poe on Thu Aug 19 14:41:37 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(1453 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XYTalk Make Procedure:
X
X    To restore the Makefile to its original state, run:
X
X	make start
X
X    If wish to support the X11 interface, edit the configuration at
X    the top of the 'Imakefile' file then run:
X
X	xmkmf 
X	make
X    
X    If you do not have "xmkmf" on your system, then you cannot support
X    X11 through ytalk at this time.  Ask your system administrator to
X    install "xmkmf" (it stands for "X Make Makefile").
X
X    If you do not have X11 installed on your system, or you do not
X    wish to support the X11 interface, then edit the configuration at
X    the top of the 'Makefile' file then run:
X
X	make
X
XThe resulting executable program will be named "ytalk".
X
XA manpage will automatically be built.  It will be named "ytalk.cat".
XYou can read the manual page by running:
X
X	more ytalk.cat
X
XIf you make changes to this source code or if you have any ideas for
Xneat new features, _PLEASE_ mail me and let me know about it.  Chances
Xare I'll incorporate your ideas/changes into the next version and put a
Xgreat big "thank you" note to you in the documentation and source
Xcode.  If you do change something or add features, and you intend to
Xgive a copy to a friend, please make sure _your_ name appears somewhere
Xin the documentation so that _I_ don't get reams of mail or bug reports
Xabout features I didn't know existed... :-)
X
XIf you have questions or suggestions, I'd be happy to hear from you
Xat this email address:
X
X    ytalk@austin.eds.com
END_OF_FILE
if test 1453 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'Manifest' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Manifest'\"
else
echo shar: Extracting \"'Manifest'\" \(170 characters\)
sed "s/^X//" >'Manifest' <<'END_OF_FILE'
XREADME
XManifest
Xytalk.1
XImakefile
XMakefile
Xterm.doc
Xheader.h
Xmenu.h
Xsocket.h
Xcurses.h
Xxwin.h
Xmain.c
Xcomm.c
Xfd.c
Xmenu.c
Xexec.c
Xrc.c
Xsocket.c
Xuser.c
Xterm.c
Xcurses.c
Xxwin.c
END_OF_FILE
if test 170 -ne `wc -c <'Manifest'`; then
    echo shar: \"'Manifest'\" unpacked with wrong size!
fi
# end of 'Manifest'
fi
if test -f 'ytalk.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ytalk.1'\"
else
echo shar: Extracting \"'ytalk.1'\" \(11073 characters\)
sed "s/^X//" >'ytalk.1' <<'END_OF_FILE'
X'''
X'''  Ytalk Version 3
X'''
X.de Sh
X.br
X.ne 5
X.PP
X\fB\\$1\fR
X.PP
X..
X.TH YTalk 1 "24 Jun 1993"
X.SH NAME
Xytalk - A multi-user chat program. 
X.SH SYNOPSIS
X.B ytalk username...
X.SH DESCRIPTION
X.I YTalk V3.0
X.PP
XYTalk is in essence a multi-user chat program.  It works almost exactly like
Xthe UNIX talk program and even communicates with the same talk daemon(s), but
XYTalk allows for multiple connections.
X
XThe 
X.I username
Xfield may be formatted in several different ways:
X.br
X	name          - some user on your machine
X.br
X	name@host     - some user on a different machine
X.br
X	name#tty      - some user on a particular terminal
X.br
X	name#tty@host - some user on a particular tty on a 
X.br 
X				 different machine
X.br
X	name@host#tty - same as "name#tty@host"
X.PP
XYou can specify multiple user names on the command line, ie:
X.sp
X	ytalk george fred@hissun.edu marc@grumpy.cc
X.PP
XFor each user on the command line, YTalk will attempt to connect to the talk
Xdaemon on the specified user's host and determine if that user has left an
Xinvitation for you to call.  If not, YTalk leaves an invitation for him
Xand tells his talk daemon to send an announcement to his screen.
XThere is not yet a dedicated YTalk daemon, but there will be.  Right now,
XYTalk is able to communicate with BOTH existing versions of UNIX talk
Xdaemons.  For any particular host, YTalk will attempt to communicate with a 
Xtalk daemon the caller's host also supports.  If the two hosts have no daemon
Xin common, then UNIX talk will not function at all, but a connection is
Xpossible through (and only through) YTalk.
X.PP
XOnce a connection has been established between two users, they can chat back
Xand forth to their hearts' content.  The connection is terminated when one
Xof them hits control-C or selects quit off the main menu.
X.PP
XYTalk is perfectly compatible with UNIX talk and they can even converse
Xwith each other without any problems.  However, many of the features of YTalk
Xcan only operate when you are connected to a user who is also using YTalk.
XFor the rest of this document, it will be assumed that all connected users
Xare using YTalk, unless otherwise stated.
X.PP
XIf you specified more than one user on the YTalk command line, then YTalk
Xwill process and add each user to the conversation as they respond to your
Xinvitation.  As each new user enters the conversation, the screen is further
Xsubdivided into smaller and smaller windows, one for each connected user.
XRight now, the number of connected users is limited by the number of lines
Xon your terminal (or window), for each connected user needs at least three
Xlines.
X.PP
XYTalk does implement primitive support of the X11 Windowing System.  If the
Xenvironment variable DISPLAY is set, then YTalk attempts to connect to that
XX server.  Further details about the X11 interface (and how to turn it off)
Xare given below.
X.PP
XAs each new user is added to the conversation, YTalk will transmit information
Xabout that user to all other connected YTalk users so that their screens will
Xalso subdivide and incorporate the new user.  If the new user is using UNIX
Xtalk, then information about him will NOT be transmitted, for his screen
Xwould be unable to accept multiple connections.  I have given brief thought
Xto allowing at least the output of UNIX talk users to be transmitted to
Xall connected YTalk users, but I have not written any code to do so.  Note
Xthat even though UNIX talk cannot handle multiple connections, it is still
Xpossible for YTalk to handle multiple UNIX "talk" connections.  For example,
Xgeorge (using YTalk) could communicate with fred and joe (both using UNIX
Xtalk), but fred and joe would be unaware of each other.  The best way to
Xunderstand the limitations that UNIX "talk" places on YTalk is to test
Xvarious connections between the two and see how things work.
X.PP
X.SH ESCAPE MENU
XWhenever you are using YTalk, you can hit the 
X.I ESCAPE 
Xkey to bring up a menu which at this
Xmoment has these options:
X.sp
X        a: add a user
X.sp
X        d: delete a user
X.sp
X        o: options
X.sp
X        s: shell
X.sp
X        u: user list
X.sp
X        w: output user to file
X.sp
X        q: quit
X.PP
XBy choosing option "a", you are given the opportunity to type the name of any
Xuser you wish to include into the conversation.  Again, YTalk will accept an
Xinvitation from that user if an invitation exists, or will leave an invitation
Xand ring the given user.
X.PP
XBy choosing option "d", you can select the name of a connection to terminate.
X.PP
XBy choosing option "o", you can view and/or modify any of the YTalk options.
XSee the OPTIONS section below for a list of YTalk options.
X.PP
XBy choosing option "s", you can invoke a shell in your YTalk window.  All
Xother users will see what happens in your shell.  YTalk will automatically
Xresize your window down to the size of the smallest window you are
Xconnected to, in order to ensure that all users always see the same thing.
X.PP
XThe "u" option displays a list of connected and unconnected users, as well
Xas their window sizes and what version of talk software they are running.
X.PP
XBy choosing option "w", you can select any connected user and type the
Xname of a file, and all further output from that user will be dumped to the
Xspecified file.  The file, if it exists, will be OVERWRITTEN.  By choosing
X"w" and the same user again, further output to the file will be terminated.
X.PP
XOh, one other thing:  when user A attempts to ytalk to user B, but user B is
Xalready ytalking with user C, user A's YTalk program will realize that user
XB is already using YTalk, and will communicate with user B's YTalk program
Xdirectly in order to initialize the conversation.  User B will see a nice
Xwindowed message like:
X.sp
X	Do you wish to talk with user A?
X.PP
Xand he will be prompted for a yes/no answer.  This, in my opinion, is much
Xpreferable to blitting the announcement message and messing up user B's
Xscreen.
X
X.SH RUNTIME OPTIONS
XWhen you select Options off of the main menu, you are given the opportunity
Xto edit the YTalk options.  The current options are:
X.sp
X	s: turn scrolling [off/on]
X.sp
X	w: turn word-wrap [off/on]
X.sp
X	i: turn auto-import [off/on]
X.sp
X	v: turn auto-invite [off/on]
X.sp
X	r: turn auto-rering [off/on]
X.PP
XIf
X.I scrolling
Xis turned on, then a user's window will scroll when he reaches the bottom,
Xinstead of wrapping back around to the top.
X.PP
XIf
X.I word-wrap
Xis turned on, then any word which would overextend the right margin will
Xbe automatically moved to the next line on your screen.
X.PP
XIf
X.I auto-import
Xis turned on, then YTalk will assume that you wish to talk to any users
Xwhich connect to other YTalk users which are connected to you.  That last
Xsentence does make sense; try again.  YTalk will add these users to your
Xsession automatically, without asking you for verification.
X.PP
XIf
X.I auto-invite
Xis turned on, then YTalk will automatically accept any connection requested
Xby another user and add them to your session.  You will not be asked for
Xverification.
X.PP
XIf
X.I auto-rering
Xis turned on, then YTalk will automatically re-ring any user who does not
Xrespond to your invitation within 30 seconds.  You will not be asked for
Xverification.
X.PP
XAny of these options can be set to your preference in your .ytalkrc file,
Xas described below.
X.SH YTALK STARTUP FILE
XIf your home directory contains a file named ".ytalkrc" then YTalk will
Xread this file while starting up.  All YTalk runtime options, as well as
Xsome startup options, can be set in this file.
X.Sh "SETTING BOOLEAN OPTIONS"
XBoolean options can be pre-set with the following syntax:
X.sp
X	turn
X.I option
X[off | on]
X.PP
Xwhere
X.I option
Xis one of
X.I scrolling ,
X.I word-wrap ,
X.I auto-import ,
X.I auto-invite ,
X.I auto-rering ,
Xor
X.I X .
XSetting these options works just like described above.  Turning
X.I X
Xon or off will enable or disable the X11 Interface described below.
XFor example, one could enable word-wrap with the line:
X.sp
X	turn word-wrap on
X.Sh "SETTING RE-ADDRESS MODES"
XThe purpose of readdressing is to allow Ytalk connections across
Xpoint-to-point network gateways where the local machines know themselves
Xby a different address (and typically hostname) than the remote machines.
XThe basic syntax of a readdress command is this:
X.sp
X	readdress
X.I from-address
X.I to-address
X.I domain
X.PP
XThe
X.I readdress
Xstatement simply makes a claim that the machine(s) in
X.I domain
Xcommunicate with the machine(s) at
X.I from-address
Xby sending a packet to
X.I to-address .
XSince most users have no use for this whatsoever, I'll describe it only
Xbriefly.
X.PP
XTHIS IS NOT ROUTING.  For example, my machine at home is connected via
XPPP to the network at my office.  My machine at home thinks its ethernet
Xaddress is 192.188.253.1 and its hostname is "talisman.com".  The network
Xat my office has the address 192.67.141.0.  When I'm connected via PPP,
Xmy home machine is placed into the office network as address 192.67.141.9
Xwith hostname "talisman.austin.eds.com".
X.PP
XYTalk needs to know that if it is running on domain 192.67.141.0 and
Xreceives packets from 192.188.253.1 that it should respond to
X192.67.141.9, not 192.188.253.1.  right?  right.  okay, okay, okay.
XI put this line into my .ytalkrc on both ends:
X.sp
X	readdress talisman talisman.austin.eds.com 192.67.141.0
X.PP
XOn my home end, this translates to:
X.sp
X	readdress 192.188.253.1 192.67.141.9 192.67.141.0
X.PP
Xwhich tells my home machine to advertise itself as "192.67.141.9" instead
Xof "192.188.253.1" when YTalk-ing to machines on the network "192.67.141.0".
XOn the office end, the readdress command translates to:
X.sp
X	readdress 192.67.141.9 192.67.141.9 192.67.141.0
X.PP
Xwhich the office machines basically ignore.
X.PP
XEnough.  For more information on how to use this, consult the source code
Xor send me a letter.  :-)
X.SH X11 INTERFACE
XIf the DISPLAY environment variable is defined when YTalk starts up, then
XYTalk will attempt to communicate with that X server.  A window will be
Xcreated for you and each user you are connected to.  The X11 Interface can
Xbe disabled by putting this line into your .ytalkrc file:
X.sp
X	turn X off
X.PP
XYTalk consults the X11 Resource Database for these user-definable
Xconfiguration options:
X.sp
X    YTalk.display:  X server to connect to, defaulting to the
XDISPLAY environment variable.
X.sp
X    YTalk.reverse:  reverse black/white pixels.
X.sp
X    YTalk.font:  font to use, defaulting to "9x15".
X.sp
X    YTalk.geometry:  window size, defaulting to  "80x24".
X.SH FUTURE WORK
XWork is being done on the following ideas:
X.sp
X	1) private conversations which do not get interrupted 
X.br
X        or transmitted to all YTalk connections,
X.br
X	2) a way to send an aside to just one or a few of the 
X.br
X        connected users,
X.br
X	3) a dedicated YTalk daemon.
X
X.SH AUTHOR
X
XBritt Yenne
X.br
Xyenne@austin.eds.com
X
X.SH CONTRIBUTORS
XSpecial thanks to Carl Edman, Tobias Hahn, and Geoff W. for beta
Xtesting and suggestions.
X.PP
XThanks to Sitaram Ramaswamy for the original YTalk manpage.
X
X.SH BUGS
X
XIf you have any ideas, comments, or questions, I'd be happy to hear from you
Xat:
X
X	ytalk@austin.eds.com
X
END_OF_FILE
if test 11073 -ne `wc -c <'ytalk.1'`; then
    echo shar: \"'ytalk.1'\" unpacked with wrong size!
fi
# end of 'ytalk.1'
fi
if test -f 'Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imakefile'\"
else
echo shar: Extracting \"'Imakefile'\" \(1825 characters\)
sed "s/^X//" >'Imakefile' <<'END_OF_FILE'
X#### Imakefile for YTalk version 3.0 ####
X#
X#			   NOTICE
X#
X# Copyright (c) 1990,1992,1993 Britt Yenne.  All rights reserved.
X# 
X# This software is provided AS-IS.  The author gives no warranty,
X# real or assumed, and takes no responsibility whatsoever for any 
X# use or misuse of this software, or any damage created by its use
X# or misuse.
X# 
X# This software may be freely copied and distributed provided that
X# no part of this NOTICE is deleted or edited in any manner.
X# 
X
X###################################
X## CONFIGURATION  (The Fun Part) ##
X###################################
X#
X# If your machine does not support TERMIOS (example: any NeXT running
X# NeXTStep earlier than version 3.1), then uncomment the following
X# line.
X#
X#TDEFS = -DUSE_SGTTY
X
X#
X# If you are using a Sun running NIS (also known as YP), you might need to
X# uncomment the next line if ytalk asks you "Who are you?"
X#
X#SLIBS = -lsun
X
X############################################################
X## Past this point, you shouldn't need to modify anything ##
X############################################################
XDEFINES = -DUSE_X11
XLIB = -lcurses -ltermcap $(SLIBS) $(XLIB)
XCPPFLAGS = -I/usr/local/include $(TOP_INCLUDES) $(TDEFS)
XLDFLAGS = $(LDOPTIONS)
XOBJ = main.o term.o user.o fd.o comm.o menu.o socket.o rc.o exec.o curses.o \
X      xwin.o
XPRG = ytalk
X
Xall:	$(PRG) ytalk.cat
X
X$(PRG):	$(OBJ)
X	$(CC) $(LDFLAGS) -o $(PRG) $(OBJ) $(LIB)
X    
Xytalk.cat:	ytalk.1
X	nroff -man ytalk.1 > ytalk.cat
X
Xstart:	Imakefile
X	cp Imakefile Makefile
X
Xshar:
X	make start
X	shar -i Manifest -o ytalk-3.0.shar -t "== Now read the README file =="
X
Xclean::
X	-rm $(OBJ)
X
Xinstall::
X
X$(OBJ):		header.h Makefile
Xmain.o:		menu.h
Xterm.o:		curses.h xwin.h menu.h
Xfd.o:		menu.h
Xcomm.o:		socket.h menu.h
Xmenu.o:		menu.h
Xsocket.o:	socket.h
Xcurses.o:	curses.h
Xxwin.o:		xwin.h
X
END_OF_FILE
if test 1825 -ne `wc -c <'Imakefile'`; then
    echo shar: \"'Imakefile'\" unpacked with wrong size!
fi
# end of 'Imakefile'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(1825 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#### Imakefile for YTalk version 3.0 ####
X#
X#			   NOTICE
X#
X# Copyright (c) 1990,1992,1993 Britt Yenne.  All rights reserved.
X# 
X# This software is provided AS-IS.  The author gives no warranty,
X# real or assumed, and takes no responsibility whatsoever for any 
X# use or misuse of this software, or any damage created by its use
X# or misuse.
X# 
X# This software may be freely copied and distributed provided that
X# no part of this NOTICE is deleted or edited in any manner.
X# 
X
X###################################
X## CONFIGURATION  (The Fun Part) ##
X###################################
X#
X# If your machine does not support TERMIOS (example: any NeXT running
X# NeXTStep earlier than version 3.1), then uncomment the following
X# line.
X#
X#TDEFS = -DUSE_SGTTY
X
X#
X# If you are using a Sun running NIS (also known as YP), you might need to
X# uncomment the next line if ytalk asks you "Who are you?"
X#
X#SLIBS = -lsun
X
X############################################################
X## Past this point, you shouldn't need to modify anything ##
X############################################################
XDEFINES = -DUSE_X11
XLIB = -lcurses -ltermcap $(SLIBS) $(XLIB)
XCPPFLAGS = -I/usr/local/include $(TOP_INCLUDES) $(TDEFS)
XLDFLAGS = $(LDOPTIONS)
XOBJ = main.o term.o user.o fd.o comm.o menu.o socket.o rc.o exec.o curses.o \
X      xwin.o
XPRG = ytalk
X
Xall:	$(PRG) ytalk.cat
X
X$(PRG):	$(OBJ)
X	$(CC) $(LDFLAGS) -o $(PRG) $(OBJ) $(LIB)
X    
Xytalk.cat:	ytalk.1
X	nroff -man ytalk.1 > ytalk.cat
X
Xstart:	Imakefile
X	cp Imakefile Makefile
X
Xshar:
X	make start
X	shar -i Manifest -o ytalk-3.0.shar -t "== Now read the README file =="
X
Xclean::
X	-rm $(OBJ)
X
Xinstall::
X
X$(OBJ):		header.h Makefile
Xmain.o:		menu.h
Xterm.o:		curses.h xwin.h menu.h
Xfd.o:		menu.h
Xcomm.o:		socket.h menu.h
Xmenu.o:		menu.h
Xsocket.o:	socket.h
Xcurses.o:	curses.h
Xxwin.o:		xwin.h
X
END_OF_FILE
if test 1825 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'term.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'term.doc'\"
else
echo shar: Extracting \"'term.doc'\" \(7818 characters\)
sed "s/^X//" >'term.doc' <<'END_OF_FILE'
XTerminal I/O requirements:
X
XEvery time a user joins a YTalk connection, he is given a window in
Xwhich his output will appear.  This terminal I/O is modularized in such
Xa way that YTalk should be able to drive any windowing system or terminal,
Xas long as someone programs a set of primitive functions.
X
XWhen init_term() [in term.c] is called from main(), it will select the
Xappropriate window system, initialize pointers to the appropriate
Xprimitives, and call the init function for that window system.  After
Xthis initialization, YTalk will transparently communicate with the
Xwindow system by using these primitives.  It is therefore important
Xthat each primitive should be implemented exactly the same for each
Xwindowing system.  The purpose of this document is to define the
Xexpected behavior of each of the terminal I/O functions.
X
XA valid YTalk 3.0 terminal interface provides an input interface.  Each
Xtime the user sends keyboard input, the input should be given to YTalk
Xby calling this function in comm.c:
X
X    void
X    my_input(buf, len)		[in comm.c]
X      ychar *buf;
X      int len;
X
XNote that it is much more optimal to call this function once with a
Xbatch of input characters rather than calling this function once for
Xeach character.
X    
XA valid YTalk 3.0 terminal interface provides these output functions:
X
X    void
X    init_???()
X
XThis is called when the terminal interface has been selected for
Xuse.  It should initialize any static variables and start any necessary
Xconnections.  It should not open or create any user windows.
X
XInput processing (ie: calls to my_input() in comm.c) should begin after
Xthis initialization function is called.
X
X----------------------
X
X    void
X    end_???()
X
XThis is called before YTalk exits.  All open windows should be shut
Xdown, any memory should be freed, and any connections should be
Xterminated.  Consider your terminal interface worthy if it can survive
Xthis test indefinitely:
X
X    for(;;)
X    {
X	init_???();
X	end_???();
X    }
X
X----------------------
X
X    int
X    open_???(user, title)
X      yuser *user;
X      char *title;
X
XZero should be returned on success; any other value will be interpreted
Xas an error.
X
XThis function should open a new window with the given title and assigned
Xto the given user.  All future calls which affect this window will be
Xpassed the same user pointer.  Since the yuser structure is not passed
Xbetween clients, you may add any variables you wish to the structure
Xas long as you comment them as part of your terminal interface.
X
XThe terminal interface should never modify any of the other fields in
Xthe yuser structure, especially the window height and width fields.  These
Xshould only be set by calling the resize_win() [term.c] function.
X
XThe cursor position should be preset to 0,0.
X
XThe window size is assumed to be 80 columns by 24 rows.  If this is
Xnot the case, you are required to call the function resize_win() [term.c]
Xwith the appropriate height and width values.  I suggest you always call
Xresize_win() from within open_???().
X
X    void
X    resize_win(user, height, width)	[in term.c]
X      yuser *user;
X      int height, width;
X
X----------------------
X
X    void
X    close_???(user)
X      yuser *user;
X
XThis will close the window assigned to the given user and free any
Xattached memory.  Again, imagine the test:
X
X    for(;;)
X    {
X	open_???(user, "test");
X	close_???(user);
X    }
X
X----------------------
X
X    void
X    addch_???(user, char)
X      yuser *user;
X      ychar char;
X
XThis will add the given character to the window, following the terminal
XI/O rules listed below.
X
X----------------------
X
X    void
X    move_???(user, y, x)
X      yuser *user;
X      int y, x;
X
XThis will move the cursor (the next output location) to the given Y,X
Xcoordinates, following the terminal I/O rules listed below.
X
X----------------------
X
X    void
X    clreol_???(user)
X      yuser *user;
X
XThis will clear all characters from (and including) the current cursor
Xposition to the end of the line.  The cursor position does not change.
X
X----------------------
X
X    void
X    clreos_???(user)
X      yuser *user;
X
XThis will clear all characters from (and including) the current cursor
Xposition to the end of the screen.  The cursor position does not change.
X
X----------------------
X
X    void
X    scroll_???(user)
X      yuser *user;
X
XThis will scroll the window up one line, losing the line at the top
Xof the window and creating a BLANK line at the bottom of the window.
XThe cursor's X and Y positions do not change.
X
XThis function can be implemented using the other primitives, so it
Xis therefore optional.  I strongly recommend that it be included, as
Xit will no doubt be faster than the version implemented through the
Xprimitives.  If it is not available, then _scroll_term should be
Xset to NULL in term.c.
X
X----------------------
X
X    void
X    rev_scroll_???(user)
X      yuser *user;
X
XThis will revserse-scroll the window up one line, losing the line at
Xthe bottom of the window and creating a BLANK line at the top of the
Xwindow.  The cursor's X and Y positions do not change.
X
XThis function can be implemented using the other primitives, so it
Xis therefore optional.  I strongly recommend that it be included, as
Xit will no doubt be faster than the version implemented through the
Xprimitives.  If it is not available, then _rev_scroll_term should be
Xset to NULL in term.c.
X
X----------------------
X
X    void
X    flush_???(user)
X      yuser *user;
X
XIf your window driver optimizes I/O by queuing updates and sending
Xbatches of changes at a time, this function should flush any pending
Xoutput.  If your window driver does not require flushes, then this
Xfunction should do nothing.
X
X----------------------
X
XTerminal I/O Rules:
X
X[ For simplicity, I'll use "maxrows" to mean the maximum number of      ]
X[ rows and "maxcols" to mean the maximum number of columns in a window. ]
X
XWhen a window is initially opened, the cursor position should start
Xat the upper left-hand corner.  This position is Y=0,X=0, or (0,0).
XThe Y position is always given first and corresponds to the row
Xnumber, starting at zero and ending at (maxrows-1).  The X position
Xis always given second and corresponds to the column number, starting
Xat zero and ending at (maxcols-1).
X
XEvery window is required to have at least two rows, and each row should
Xhave at least 20 columns.
X
XEvery time a character is added to the window, it should be placed
Xat the cursor's current Y,X position, clearing and overwriting any
Xcharacter which may already be there.  Then, the cursor's X position
Xshould be incremented by one.  If the X position is now greater than
Xor equal to maxcols, then the X position should be set back to
X(maxcols-1).  THERE IS NO DEFINITION FOR WRAPPING.  The cursor's
XY position is never incremented as a result of X being too large.
XInstead, X is maintained at (maxcols-1) until move_???() is called
Xto move the cursor.
X
XSince there is no definition for wrapping, it follows that there is
Xno definition for automatic scrolling.  A window should only scroll
Xwhen scroll_???() is called explicitly.  Note that some terminals
Xwill scroll automatically when a character is placed in the lower
Xright-hand corner.  If this is the case with your system, I suggest
Xyou tell YTalk that your terminal is actually one row shorter.  You
Xcould tell YTalk it is one column skinnier, but this effect can
Xbe visually displeasing.
X
XThe terminal interface will only be asked to display printable
Xcharacters.  These are the characters in the decimal range from
X32 [space] to 126 [tilde] inclusive.  Therefore, the addch_???()
Xprocedure need not consider how to display control characters or
Xhigh-bit characters, because these will never be sent.
X
XSimilarly, the move_???() procedure will never be called with
XY or X values outside the range of the current window.
X
X-- EOF --
END_OF_FILE
if test 7818 -ne `wc -c <'term.doc'`; then
    echo shar: \"'term.doc'\" unpacked with wrong size!
fi
# end of 'term.doc'
fi
if test -f 'header.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'header.h'\"
else
echo shar: Extracting \"'header.h'\" \(12034 characters\)
sed "s/^X//" >'header.h' <<'END_OF_FILE'
X/* header.h */
X
X/*			   NOTICE
X *
X * Copyright (c) 1990,1992,1993 Britt Yenne.  All rights reserved.
X * 
X * This software is provided AS-IS.  The author gives no warranty,
X * real or assumed, and takes no responsibility whatsoever for any 
X * use or misuse of this software, or any damage created by its use
X * or misuse.
X * 
X * This software may be freely copied and distributed provided that
X * no part of this NOTICE is deleted or edited in any manner.
X * 
X */
X
X/* Mail comments or questions to ytalk@austin.eds.com */
X
X#include <sys/types.h>
X#include <sys/param.h>
X#include <sys/socket.h>
X#include <netinet/in.h>
X#include <errno.h>
X#include <stdlib.h>
X#include <string.h>
X#include <stdio.h>
X#ifdef USE_X11
X# include <X11/X.h>
X#endif
X
X#define VMAJOR	3	/* major version number */
X#define VMINOR	0	/* minor version number */
X
X/* ---- YTalk protocols ---- */
X
X/* These protocol numbers are a MAJOR HACK designed to get around the
X * fact that old versions of ytalk didn't send any version information
X * during handshaking.  Nor did they bzero() the unused portions of the
X * handshaking structures.  Argh!  These two protocol numbers were very
X * carefully picked... do not add any others and expect them to work.
X * Instead, use the "vmajor" and "vminor" fields of the y_parm structure.
X */
X#define YTP_OLD	20	/* YTalk versions before 3.0 */
X#define YTP_NEW	27	/* YTalk versions 3.0 and up */
X
X/* ---- types ---- */
X
Xtypedef void *	yaddr;		/* any 32-bit address */
Xtypedef yaddr	yterm;		/* terminal cookie */
Xtypedef u_char	ychar;		/* we use unsigned chars */
X
Xtypedef struct {
X    u_char w_rows, w_cols;	/* window size FOR PROTOCOL YTP_OLD */
X    char protocol;		/* ytalk protocol -- see above */
X    char pad1;			/* zeroed out */
X    short vmajor, vminor;	/* version numbers */
X    u_short rows, cols;		/* his window size over there */
X    u_short my_rows, my_cols;	/* my window size over there */
X    u_long pid;			/* my process id */
X    char pad[44];		/* zeroed out */
X} y_parm;
X
X#define MAXARG	4		/* max ESC sequence arg count */
X
Xtypedef struct _yuser {
X    struct _yuser *next;	/* next user in group lists */
X    struct _yuser *unext;	/* next user in full user list */
X    int fd;			/* file descriptor */
X    int output_fd;		/* non-zero if output is going to a file */
X    u_long flags;		/* active FL_* flags below */
X    ychar edit[4];		/* edit characters */
X    u_short t_rows, t_cols;	/* his rows and cols on window over here */
X    u_short rows, cols;		/* his active region rows and cols over here */
X    y_parm remote;		/* remote parms */
X    ychar **scr;		/* screen data */
X    char bump;			/* set if at far right */
X    ychar old_rub;		/* my actual rub character */
X    char got_esc;		/* received an ESC */
X    ychar key;			/* this user's ident letter for menus */
X    int y, x;			/* current cursor position */
X    int sy, sx;			/* saved cursor position */
X    int sc_top, sc_bot;		/* scrolling region */
X    int region_set;		/* set if using a screen region */
X    char *full_name;		/* full name (up to 50 chars) */
X    char *user_name;		/* user name */
X    char *host_name;		/* host name */
X    char *tty_name;		/* tty name */
X    u_long host_addr;		/* host inet address */
X    int daemon;			/* daemon type to use */
X    u_long l_id, r_id;		/* local and remote talkd invite list index */
X    u_long d_id;		/* talk daemon process id -- see socket.c */
X    long last_invite;		/* timestamp of last invitation sent */
X    struct sockaddr_in sock;	/* communication socket */
X    struct sockaddr_in orig_sock; /* original socket -- another sick hack */
X    u_int av[MAXARG];		/* ESC sequence arguments */
X    u_int ac;			/* ESC sequence arg count */
X
X    /* out-of-band data */
X
X    int dbuf_size;		/* current buffer size */
X    ychar *dbuf, *dptr;		/* buffer base and current pointer */
X    int drain;			/* remaining bytes to drain */
X    void (*dfunc)();		/* function to call with drained data */
X    int got_oob;		/* got OOB flag */
X
X    /* anything below this is available for the terminal interface */
X
X    yterm term;			/* terminal cookie */
X    int ty, tx;			/* terminal's idea of Y,X (optional) */
X#ifdef USE_X11
X    Window win;			/* user's window */
X#endif
X} yuser;
X
X#define FL_RAW		0x00000001L	/* raw input enabled */
X#define FL_SCROLL	0x00000002L	/* scrolling enabled */
X#define FL_WRAP		0x00000004L	/* word-wrap enabled */
X#define FL_IMPORT	0x00000008L	/* auto-import enabled */
X#define FL_INVITE	0x00000010L	/* auto-invite enabled */
X#define FL_RING		0x00000020L	/* auto-rering enabled */
X#define FL_XWIN		0x00000040L	/* X Windows enabled (startup opt) */
X#define FL_LOCKED	0x40000000L	/* flags locked by other end */
X
X/* ---- defines and short-cuts ---- */
X
X#ifdef NOFILE
X# define MAX_FILES	NOFILE	/* max open file descriptors */
X#else
X# define MAX_FILES	256	/* better to be too high than too low */
X#endif
X#define CLEAN_INTERVAL	16	/* seconds between calls to house_clean() */
X#define MAXBUF		4096	/* buffer size for I/O operations */
X#define MAXERR		132	/* error text buffer size */
X#define MAXTEXT		50	/* text entry buffer */
X
X#define RUB	edit[0]
X#define KILL	edit[1]
X#define WORD	edit[2]
X#define CLR	edit[3]
X#define RUBDEF	0xfe
X
X/* ---- Ytalk version 3.* out-of-band data ---- */
X
X/* see comm.c for a description of Ytalk 3.* OOB protocol */
X
X#define V3_OOB		0xfd	/* out-of-band marker -- see comm.c */
X#define V3_MAXPACK	0xfc	/* max OOB packet size -- see comm.c */
X#define V3_NAMELEN	16	/* max username length */
X#define V3_HOSTLEN	64	/* max hostname length */
X
Xtypedef struct {
X    ychar code;			/* V3_EXPORT, V3_IMPORT, or V3_ACCEPT */
X    char filler[3];
X    u_long host_addr;		/* host address */
X    u_long pid;			/* process id */
X    char name[V3_NAMELEN];	/* user name */
X    char host[V3_HOSTLEN];	/* host name */
X} v3_pack;
X
X#define V3_PACKLEN	sizeof(v3_pack)
X#define V3_EXPORT	101	/* export a user */
X#define V3_IMPORT	102	/* import a user */
X#define V3_ACCEPT	103	/* accept a connection from a user */
X
Xtypedef struct {
X    ychar code;			/* V3_LOCKF or V3_UNLOCKF */
X    char filler[3];
X    u_long flags;		/* flags */
X} v3_flags;
X
X#define V3_FLAGSLEN	sizeof(v3_flags)
X#define V3_LOCKF	111	/* lock my flags */
X#define V3_UNLOCKF	112	/* unlock my flags */
X
Xtypedef struct {
X    ychar code;			/* V3_YOURWIN, V3_MYWIN, or V3_REGION */
X    char filler[3];
X    u_short rows, cols;		/* window size */
X} v3_winch;
X
X#define V3_WINCHLEN	sizeof(v3_winch)
X#define V3_YOURWIN	121	/* your window size changed over here */
X#define V3_MYWIN	122	/* my window size changed over here */
X#define V3_REGION	123	/* my window region changed over here */
X
X/* ---- Ytalk version 2.* out-of-band data ---- */
X
X#define V2_NAMELEN	12
X#define V2_HOSTLEN	64
X
Xtypedef struct {
X    ychar code;			/* one of the V2_?? codes below */
X    char filler;
X    char name[V2_NAMELEN];	/* user name */
X    char host[V2_HOSTLEN];	/* user host */
X} v2_pack;
X
X#define V2_PACKLEN	sizeof(v2_pack)
X#define V2_EXPORT	130	/* export a user */
X#define V2_IMPORT	131	/* import a user */
X#define V2_ACCEPT	132	/* accept a connection from a user */
X#define V2_AUTO		133	/* accept auto invitation */
X
X/* ---- exit codes ---- */
X
X#define YTE_SUCCESS	0	/* successful completion */
X#define YTE_INIT	1	/* initialization error */
X#define YTE_NO_MEM	2	/* out of memory */
X#define YTE_SIGNAL	3	/* fatal signal received */
X#define YTE_ERROR	4	/* unrecoverable error */
X
X/* ---- global variables ---- */
X
Xextern char *sys_errlist[];	/* system errors */
X
Xextern yuser *me;		/* just lil' ol' me */
Xextern yuser *user_list;	/* full list of invited/connected users */
Xextern yuser *connect_list;	/* list of connected users */
Xextern yuser *wait_list;	/* list of invited users */
Xextern yuser *fd_to_user[MAX_FILES];	/* convert file descriptors to users */
Xextern yuser *key_to_user[128];	/* convert menu ident chars to users */
Xextern char errstr[MAXERR];	/* temporary string for errors */
Xextern u_long def_flags;	/* default FL_* flags */
Xextern int user_winch;		/* user window/status changed flag */
X
Xextern ychar *io_ptr;		/* user input pointer */
Xextern int    io_len;		/* user input count */
X
Xextern int running_process;	/* flag: is process running? */
X
X/* ---- global functions ---- */
X
Xextern void	bail		( /* int */ );			/* main.c */
Xextern yaddr	get_mem		( /* int */ );			/* main.c */
Xextern char    *str_copy	( /* string */ );		/* main.c */
Xextern yaddr	realloc_mem	( /* pointer, int */ );		/* main.c */
Xextern void	show_error	( /* str */ );			/* main.c */
X
Xextern void	init_term	();				/* term.c */
Xextern void	set_terminal_size  ( /* fd, rows, cols */ );	/* term.c */
Xextern void	set_terminal_flags ( /* fd */ );		/* term.c */
Xextern int	what_term	();				/* term.c */
Xextern void	end_term	();				/* term.c */
Xextern int	open_term	( /* yuser, title */ );		/* term.c */
Xextern void	close_term	( /* yuser */ );		/* term.c */
Xextern void	addch_term	( /* yuser, ch */ );		/* term.c */
Xextern void	move_term	( /* yuser, y, x */ );		/* term.c */
Xextern void	clreol_term	( /* yuser */ );		/* term.c */
Xextern void	clreos_term	( /* yuser */ );		/* term.c */
Xextern void	scroll_term	( /* yuser */ );		/* term.c */
Xextern void	rev_scroll_term	( /* yuser */ );		/* term.c */
Xextern void	flush_term	( /* yuser */ );		/* term.c */
Xextern void	rub_term	( /* yuser */ );		/* term.c */
Xextern int	word_term	( /* yuser */ );		/* term.c */
Xextern void	kill_term	( /* yuser */ );		/* term.c */
Xextern void	tab_term	( /* yuser */ );		/* term.c */
Xextern void	newline_term	( /* yuser */ );		/* term.c */
Xextern void	add_line_term	( /* yuser, num */ );		/* term.c */
Xextern void	del_line_term	( /* yuser, num */ );		/* term.c */
Xextern void	add_char_term	( /* yuser, num */ );		/* term.c */
Xextern void	del_char_term	( /* yuser, num */ );		/* term.c */
Xextern void	redraw_term	( /* yuser, start_row */ );	/* term.c */
Xextern void	resize_win	( /* yuser, h, w */ );		/* term.c */
Xextern void	set_win_region	( /* yuser, h, w */ );		/* term.c */
Xextern void	end_win_region	( /* yuser */ );		/* term.c */
Xextern void	set_scroll_region( /* yuser, top, bottom */ );	/* term.c */
Xextern void	msg_term	( /* yuser, str */ );		/* term.c */
Xextern void	spew_term	( /* yuser, fd, rows, cols */ ); /* term.c */
Xextern int	center		( /* width, n */ );		/* term.c */
X
Xextern void	init_user	();				/* user.c */
Xextern yuser   *new_user	( /* name, host, tty */ );	/* user.c */
Xextern void	free_user	( /* yuser */ );		/* user.c */
Xextern yuser   *find_user	( /* name, host_addr, pid */ );	/* user.c */
X
Xextern void	init_fd		();				/* fd.c */
Xextern void	add_fd		( /* fd, func */ );		/* fd.c */
Xextern void	remove_fd	( /* fd */ );			/* fd.c */
Xextern int	full_read	( /* fd, buf, len */ );		/* fd.c */
Xextern void	main_loop	();				/* fd.c */
Xextern void	input_loop	();				/* fd.c */
X
Xextern void	invite		( /* username, announce */ );	/* comm.c */
Xextern void	house_clean	();				/* comm.c */
Xextern void	send_winch	( /* yuser */ );		/* comm.c */
Xextern void	send_region	();				/* comm.c */
Xextern void	send_end_region	();				/* comm.c */
Xextern void	send_users	( /* buf, len */ );		/* comm.c */
Xextern void	show_input	( /* user, buf, len */ );	/* comm.c */
Xextern void	my_input	( /* buf, len */ );		/* comm.c */
Xextern void	lock_flags	( /* flags */ );		/* comm.c */
Xextern void	unlock_flags	();				/* comm.c */
X
Xextern void	init_socket	();				/* socket.c */
Xextern void	close_all	();				/* socket.c */
Xextern int	send_dgram	( /* user, type */ );		/* socket.c */
Xextern int	send_auto	( /* type */ );			/* socket.c */
Xextern void	kill_auto	();				/* socket.c */
Xextern int	newsock		( /* yuser */ );		/* socket.c */
Xextern int	connect_to	( /* yuser */ );		/* socket.c */
Xextern u_long	get_host_addr	( /* hostname */ );		/* socket.c */
Xextern char    *host_name	( /* addr */ );			/* socket.c */
Xextern void	readdress_host	( /* from, to, on */ );		/* socket.c */
X
Xextern void	read_ytalkrc	();				/* rc.c */
X
Xextern void	execute		( /* command */ );		/* exec.c */
Xextern void	update_exec	();				/* exec.c */
Xextern void	kill_exec	();				/* exec.c */
Xextern void	winch_exec	();				/* exec.c */
X
X/* EOF */
END_OF_FILE
if test 12034 -ne `wc -c <'header.h'`; then
    echo shar: \"'header.h'\" unpacked with wrong size!
fi
# end of 'header.h'
fi
if test -f 'menu.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'menu.h'\"
else
echo shar: Extracting \"'menu.h'\" \(1609 characters\)
sed "s/^X//" >'menu.h' <<'END_OF_FILE'
X/* menu.h */
X
X/*			   NOTICE
X *
X * Copyright (c) 1990,1992,1993 Britt Yenne.  All rights reserved.
X * 
X * This software is provided AS-IS.  The author gives no warranty,
X * real or assumed, and takes no responsibility whatsoever for any 
X * use or misuse of this software, or any damage created by its use
X * or misuse.
X * 
X * This software may be freely copied and distributed provided that
X * no part of this NOTICE is deleted or edited in any manner.
X * 
X */
X
X/* Mail comments or questions to ytalk@austin.eds.com */
X
X/* The following structure defines a menu item.  It will be displayed
X * to the user as the _key_ followed by the _item_.  If an item's _key_
X * is pressed, the _func_ for that item is called with one argument:
X * the _key_ pressed.
X */
Xtypedef struct {
X    char *item;		/* item string, ie: "add a user" */
X    void (*func)();	/* function to call */
X    ychar key;		/* activating keypress, ie: "a" */
X} menu_item;
X
Xextern menu_item *menu_ptr;	/* if non-NULL, current menu in processing */
X
X/* global functions */
X
Xextern void	kill_menu	();				/* menu.c */
Xextern void	update_menu	();				/* menu.c */
Xextern int	show_menu	( /* menuptr, len */ );		/* menu.c */
Xextern int	show_text	( /* prompt, func */ );		/* menu.c */
Xextern int	show_mesg	();				/* menu.c */
Xextern int	show_main_menu	();				/* menu.c */
Xextern int	show_option_menu();				/* menu.c */
Xextern int	show_user_menu	( /* title, func */ );		/* menu.c */
Xextern int	show_error_menu	( /* str1, str2 */ );		/* menu.c */
Xextern int	yes_no		( /* prompt */ );		/* menu.c */
Xextern void	update_user_menu();				/* menu.c */
X
X/* EOF */
END_OF_FILE
if test 1609 -ne `wc -c <'menu.h'`; then
    echo shar: \"'menu.h'\" unpacked with wrong size!
fi
# end of 'menu.h'
fi
if test -f 'socket.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'socket.h'\"
else
echo shar: Extracting \"'socket.h'\" \(2595 characters\)
sed "s/^X//" >'socket.h' <<'END_OF_FILE'
X/* socket.h */
X
X#include <netdb.h>
X
X/* ---- talk daemon information structure ---- */
X
X#define MAXDAEMON	5
X
Xstruct _talkd {
X    struct sockaddr_in sock;	/* socket */
X    int fd;			/* socket file descriptor */
X    short port;			/* port number */
X    yaddr mptr;			/* message pointer */
X    int mlen;			/* message length */
X    yaddr rptr;			/* response pointer */
X    int rlen;			/* response length */
X};
X
Xtypedef struct _hostinfo {
X    struct _hostinfo *next;	/* next in linked list */
X    u_long host_addr;		/* host address */
X    int dtype;			/* active daemon types bitmask */
X} hostinfo;
X
Xtypedef struct _readdr {
X    struct _readdr *next;	/* next in linked list */
X    u_long addr;		/* this net address [group?], */
X    u_long mask;		/* with this mask, */
X    u_long id_addr;		/* thinks I'm at this net address, */
X    u_long id_mask;		/* with this mask. */
X} readdr;
X
Xextern struct _talkd talkd[MAXDAEMON+1];
Xextern int daemons;
X
X/* ---- talk daemon I/O structures ---- */
X
X#define NAME_SIZE 9
X#define TTY_SIZE 16
X
X/* Control Message structure for earlier than BSD4.2
X */
Xtypedef struct {
X	char	type;
X	char	l_name[NAME_SIZE];
X	char	r_name[NAME_SIZE];
X	char	filler;
X	u_long	id_num;
X	u_long	pid;
X	char	r_tty[TTY_SIZE];
X	struct	sockaddr_in addr;
X	struct	sockaddr_in ctl_addr;
X} CTL_MSG;
X
X/* Control Response structure for earlier than BSD4.2
X */
Xtypedef struct {
X	char	type;
X	char	answer;
X	u_short	filler;
X	u_long	id_num;
X	struct	sockaddr_in addr;
X} CTL_RESPONSE;
X
X/* Control Message structure for BSD4.2
X */
Xtypedef struct {
X	u_char	vers;
X	char	type;
X	u_short	filler;
X	u_long	id_num;
X	struct	sockaddr_in addr;
X	struct	sockaddr_in ctl_addr;
X	u_long	pid;
X	char	l_name[NAME_SIZE];
X	char	l_name_filler[3];
X	char	r_name[NAME_SIZE];
X	char	r_name_filler[3];
X	char	r_tty[TTY_SIZE];
X} CTL_MSG42;
X
X/* Control Response structure for BSD4.2
X */
Xtypedef struct {
X	u_char	vers;
X	char	type;
X	char	answer;
X	char	filler;
X	u_long	id_num;
X	struct	sockaddr_in addr;
X} CTL_RESPONSE42;
X
X#define	TALK_VERSION	1		/* protocol version */
X
X/* Dgram Types.
X *
X * These are the "type" arguments to feed to send_dgram().  Each acts
X * either on the remote daemon or the local daemon, as marked.
X */
X
X#define LEAVE_INVITE	0	/* leave an invitation (local) */
X#define LOOK_UP		1	/* look up an invitation (remote) */
X#define DELETE		2	/* delete erroneous invitation (remote) */
X#define ANNOUNCE	3	/* ring a user (remote) */
X#define DELETE_INVITE	4	/* delete my invitation (local) */
X#define AUTO_LOOK_UP	5	/* look up auto-invitation (remote) */
X#define AUTO_DELETE	6	/* delete erroneous auto-invitation (remote) */
X
X/* EOF */
END_OF_FILE
if test 2595 -ne `wc -c <'socket.h'`; then
    echo shar: \"'socket.h'\" unpacked with wrong size!
fi
# end of 'socket.h'
fi
if test -f 'curses.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'curses.h'\"
else
echo shar: Extracting \"'curses.h'\" \(1046 characters\)
sed "s/^X//" >'curses.h' <<'END_OF_FILE'
X/* curses.h -- curses interface (curses.c) */
X
X/*			   NOTICE
X *
X * Copyright (c) 1990,1992,1993 Britt Yenne.  All rights reserved.
X * 
X * This software is provided AS-IS.  The author gives no warranty,
X * real or assumed, and takes no responsibility whatsoever for any 
X * use or misuse of this software, or any damage created by its use
X * or misuse.
X * 
X * This software may be freely copied and distributed provided that
X * no part of this NOTICE is deleted or edited in any manner.
X * 
X */
X
X/* Mail comments or questions to ytalk@austin.eds.com */
X
Xextern void	init_curses	();
Xextern void	end_curses	();
Xextern int	open_curses	( /* yuser, title */ );
Xextern void	close_curses	( /* yuser */ );
Xextern void	addch_curses	( /* yuser, char */ );
Xextern void	move_curses	( /* yuser, y, x */ );
Xextern void	clreol_curses	( /* yuser */ );
Xextern void	clreos_curses	( /* yuser */ );
Xextern void	scroll_curses	( /* yuser */ );
Xextern void	flush_curses	( /* yuser */ );
X
X#ifndef getyx
X# define getyx(w,y,x)	y = w->_cury, x = w->_curx
X#endif
X
X/* EOF */
END_OF_FILE
if test 1046 -ne `wc -c <'curses.h'`; then
    echo shar: \"'curses.h'\" unpacked with wrong size!
fi
# end of 'curses.h'
fi
if test -f 'xwin.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xwin.h'\"
else
echo shar: Extracting \"'xwin.h'\" \(1023 characters\)
sed "s/^X//" >'xwin.h' <<'END_OF_FILE'
X/* xwin.h -- X Windows interface (xwin.c) */
X
X/*			   NOTICE
X *
X * Copyright (c) 1990,1992,1993 Britt Yenne.  All rights reserved.
X * 
X * This software is provided AS-IS.  The author gives no warranty,
X * real or assumed, and takes no responsibility whatsoever for any 
X * use or misuse of this software, or any damage created by its use
X * or misuse.
X * 
X * This software may be freely copied and distributed provided that
X * no part of this NOTICE is deleted or edited in any manner.
X * 
X */
X
X/* Mail comments or questions to ytalk@austin.eds.com */
X
X#ifdef USE_X11
X
Xextern void	init_xwin	();
Xextern void	end_xwin	();
Xextern int	open_xwin	( /* yuser, title */ );
Xextern void	close_xwin	( /* yuser */ );
Xextern void	addch_xwin	( /* yuser, char */ );
Xextern void	move_xwin	( /* yuser, y, x */ );
Xextern void	clreol_xwin	( /* yuser */ );
Xextern void	clreos_xwin	( /* yuser */ );
Xextern void	scroll_xwin	( /* yuser */ );
Xextern void	rev_scroll_xwin	( /* yuser */ );
Xextern void	flush_xwin	( /* yuser */ );
X
X#endif
X
X/* EOF */
END_OF_FILE
if test 1023 -ne `wc -c <'xwin.h'`; then
    echo shar: \"'xwin.h'\" unpacked with wrong size!
fi
# end of 'xwin.h'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
echo shar: Extracting \"'main.c'\" \(2829 characters\)
sed "s/^X//" >'main.c' <<'END_OF_FILE'
X/* main.c */
X
X/*			   NOTICE
X *
X * Copyright (c) 1990,1992,1993 Britt Yenne.  All rights reserved.
X * 
X * This software is provided AS-IS.  The author gives no warranty,
X * real or assumed, and takes no responsibility whatsoever for any 
X * use or misuse of this software, or any damage created by its use
X * or misuse.
X * 
X * This software may be freely copied and distributed provided that
X * no part of this NOTICE is deleted or edited in any manner.
X * 
X */
X
X/* Mail comments or questions to ytalk@austin.eds.com */
X
X#include "header.h"
X#include <signal.h>
X#include "menu.h"
X
Xchar errstr[132];	/* temporary string for errors */
X
X/* Clean up and exit.
X */
Xvoid
Xbail(n)
X  int n;
X{
X    end_term();
X    kill_auto();
X    (void)exit(n);
X}
X
X/* Display an error.
X */
Xvoid
Xshow_error(str)
X  register char *str;
X{
X    register char *syserr;
X    static int in_error = 0;
X
X    if(errno == 0)
X	syserr = "(no system error)";
X    else
X	syserr = sys_errlist[errno];
X
X    putc(7, stderr);
X    if(in_error == 0 && what_term() != 0)
X    {
X	in_error = 1;
X	if(show_error_menu(str, syserr) < 0)
X	{
X	    show_error("show_error: show_error_menu() failed");
X	    show_error(str);
X	}
X	else
X	    update_menu();
X	in_error = 0;
X    }
X    else
X    {
X	fprintf(stderr, "%s: %s\n", str, syserr);
X	sleep(2);
X    }
X}
X
X/* Allocate memory.
X */
Xyaddr
Xget_mem(n)
X  int n;
X{
X    register yaddr out;
X    if((out = (yaddr)malloc(n)) == NULL)
X    {
X	show_error("malloc() failed");
X	bail(YTE_NO_MEM);
X    }
X    return out;
X}
X
X/* Copy a string.
X */
Xchar *
Xstr_copy(str)
X  register char *str;
X{
X    register char *out;
X    register int len;
X
X    if(str == NULL)
X	return NULL;
X    len = strlen(str) + 1;
X    out = get_mem(len);
X    (void)memcpy(out, str, len);
X    return out;
X}
X
X/* Reallocate memory.
X */
Xyaddr
Xrealloc_mem(p, n)
X  char *p;
X  int n;
X{
X    register yaddr out;
X    if(p == NULL)
X	return get_mem(n);
X    if((out = (yaddr)realloc(p, n)) == NULL)
X    {
X	show_error("realloc() failed");
X	bail(YTE_NO_MEM);
X    }
X    return out;
X}
X
X/* Process signals.
X */
Xstatic void
Xgot_sig(n)
X  int n;
X{
X    if(n == SIGINT)
X	bail(0);
X    bail(YTE_SIGNAL);
X}
X
X/*  MAIN  */
Xint
Xmain(argc, argv)
X  int argc;
X  char **argv;
X{
X    if(argc <= 1)
X    {
X	fprintf(stderr, "Usage: %s user[@hostname][#tty] [user...]\n", *argv);
X	(void)exit(YTE_INIT);
X    }
X    argv++, argc--;
X
X    /* set up signals */
X
X    signal(SIGINT, got_sig);
X    signal(SIGHUP, got_sig);
X    signal(SIGQUIT, got_sig);
X    signal(SIGABRT, got_sig);
X
X    /* set default options */
X
X    def_flags = FL_XWIN;
X
X    /* go for it! */
X
X    errno = 0;
X    init_fd();
X    init_user();
X    read_ytalkrc();
X    init_term();
X    init_socket();
X    for(; argc > 0; argc--, argv++)
X	invite(*argv, 1);
X    msg_term(me, "Waiting for connection...");
X    main_loop();
X    bail(YTE_SUCCESS);
X
X    return 0;	/* make lint happy */
X}
END_OF_FILE
if test 2829 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
fi
# end of 'main.c'
fi
if test -f 'comm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'comm.c'\"
else
echo shar: Extracting \"'comm.c'\" \(27713 characters\)
sed "s/^X//" >'comm.c' <<'END_OF_FILE'
X/* comm.c -- firewall between socket and terminal I/O */
X
X/*			   NOTICE
X *
X * Copyright (c) 1990,1992,1993 Britt Yenne.  All rights reserved.
X * 
X * This software is provided AS-IS.  The author gives no warranty,
X * real or assumed, and takes no responsibility whatsoever for any 
X * use or misuse of this software, or any damage created by its use
X * or misuse.
X * 
X * This software may be freely copied and distributed provided that
X * no part of this NOTICE is deleted or edited in any manner.
X * 
X */
X
X/* Mail comments or questions to ytalk@austin.eds.com */
X
X#include "header.h"
X#include "socket.h"
X#include "menu.h"
X#include <sys/uio.h>
X
Xychar *io_ptr;		/* user input pointer */
Xint    io_len = 0;	/* user input count */
X
Xextern int input_flag;	/* see fd.c */
X
X/* ---- local functions ---- */
X
Xstatic y_parm parm;
Xstatic v2_pack v2p;
Xstatic v3_pack v3p;
Xstatic v3_flags v3f;
Xstatic v3_winch v3w;
X
X/* Set up a drain of out-of-band data.
X */
Xstatic void
Xdrain_user(user, len, func)
X  yuser *user;
X  int len;
X  void (*func)();
X{
X    if(len > user->dbuf_size)
X    {
X	user->dbuf_size = len + 64;
X	user->dbuf = (ychar *)realloc_mem(user->dbuf, user->dbuf_size);
X    }
X    user->drain = len;
X    user->dptr = user->dbuf;
X    user->dfunc = func;
X}
X
X/* Send out-of-band data.
X */
Xstatic void
Xsend_oob(fd, ptr, len)
X  int fd;
X  yaddr ptr;
X  int len;
X{
X    ychar oob, size;
X    static struct iovec iov[3];
X
X    if(len <= 0 || len > V3_MAXPACK)
X    {
X	errno = 0;
X	show_error("send_oob: packet too large");
X	return;
X    }
X
X    oob = V3_OOB;
X    iov[0].iov_base = (yaddr)(&oob);
X    iov[0].iov_len = 1;
X
X    size = len;
X    iov[1].iov_base = (yaddr)(&size);
X    iov[1].iov_len = 1;
X
X    iov[2].iov_base = ptr;
X    iov[2].iov_len = len;
X
X    if(writev(fd, iov, 3) != len + 2)
X	show_error("send_oob: write failed");
X}
X
X/* Ask another ytalk connection if he wants to import a user I've
X * just now connected to.
X */
Xstatic void
Xsend_import(to, from)
X  yuser *to, *from;
X{
X    if(to->remote.vmajor > 2)
X    {
X	v3p.code = V3_IMPORT;
X	v3p.host_addr = htonl(from->host_addr);
X	v3p.pid = htonl(from->remote.pid);
X	strncpy(v3p.name, from->user_name, V3_NAMELEN);
X	strncpy(v3p.host, from->host_name, V3_HOSTLEN);
X	send_oob(to->fd, &v3p, V3_PACKLEN);
X    }
X    else if(to->remote.vmajor == 2)
X    {
X	v2p.code = V2_IMPORT;
X	strncpy(v2p.name, from->user_name, V2_NAMELEN);
X	strncpy(v2p.host, from->host_name, V2_HOSTLEN);
X	(void)write(to->fd, &v2p, V2_PACKLEN);
X    }
X}
X
X/* Tell another ytalk connection to connect to a user.
X */
Xstatic void
Xsend_accept(to, from)
X  yuser *to, *from;
X{
X    if(to->remote.vmajor > 2)
X    {
X	v3p.code = V3_ACCEPT;
X	v3p.host_addr = htonl(from->host_addr);
X	v3p.pid = htonl(from->remote.pid);
X	strncpy(v3p.name, from->user_name, V3_NAMELEN);
X	strncpy(v3p.host, from->host_name, V3_HOSTLEN);
X	send_oob(to->fd, &v3p, V3_PACKLEN);
X    }
X    else if(to->remote.vmajor == 2)
X    {
X	v2p.code = V2_ACCEPT;
X	strncpy(v2p.name, from->user_name, V2_NAMELEN);
X	strncpy(v2p.host, from->host_name, V2_HOSTLEN);
X	(void)write(to->fd, &v2p, V2_PACKLEN);
X    }
X}
X
X/* Process a Ytalk version 2.? data packet.
X */
Xstatic void
Xv2_process(user, pack)
X  yuser *user;
X  v2_pack *pack;
X{
X    register yuser *u;
X    u_long host_addr;
X    static char name[V2_NAMELEN + 1];
X    static char host[V2_HOSTLEN + 1];
X    static char estr[V2_NAMELEN + V2_HOSTLEN + 20];
X
X    /* Ytalk version 2.* didn't have very clever import/export
X     * capabilities.  We'll just go with the flow.
X     */
X    strncpy(name, pack->name, V2_NAMELEN);
X    strncpy(host, pack->host, V2_HOSTLEN);
X    name[V2_NAMELEN] = '\0';
X    host[V2_HOSTLEN] = '\0';
X    if((host_addr = get_host_addr(host)) == (u_long)-1)
X    {
X	errno = 0;
X	sprintf(errstr, "unknown host: '%s'\n", host);
X	show_error(errstr);
X	show_error("port from ytalk V2.? failed");
X	return;
X    }
X    switch(pack->code)
X    {
X	case V2_IMPORT:
X	    /* Don't import a user with the same name of an existing
X	     * user at this end.  yukk.
X	     */
X	    if(find_user(name, host_addr, (u_long)-1) != NULL)
X		break;
X	    if(!(def_flags & FL_IMPORT))
X	    {
X		sprintf(estr, "Import %s@%s?", name, host);
X		if(yes_no(estr) == 'n')
X		    break;
X	    }
X
X	    /* invite him but don't ring him */
X
X	    sprintf(estr, "%s@%s", name, host);
X	    invite(estr, 0);
X
X	    /* now tell him to connect to us */
X
X	    pack->code = V2_EXPORT;
X	    (void)write(user->fd, pack, V2_PACKLEN);
X
X	    break;
X	case V2_EXPORT:
X	    /* We don't need to check if he's not connected, since
X	     * send_accept() will think his version number is zero
X	     * and won't send anything.
X	     */
X	    if((u = find_user(name, host_addr, (u_long)-1)) == NULL)
X		break;
X	    send_accept(u, user);
X	    break;
X	case V2_ACCEPT:
X	    sprintf(estr, "%s@%s", name, host);
X	    invite(estr, 1);	/* we should be expected */
X	    break;
X    }
X}
X
X/* Process a Ytalk version 3.? data packet.
X */
Xstatic void
Xv3_process_pack(user, pack)
X  yuser *user;
X  v3_pack *pack;
X{
X    register yuser *u;
X    u_long host_addr, pid;
X    static char name[V3_NAMELEN + 1];
X    static char host[V3_HOSTLEN + 1];
X    static char estr[V3_NAMELEN + V3_HOSTLEN + 20];
X
X    strncpy(name, pack->name, V3_NAMELEN);
X    strncpy(host, pack->host, V3_HOSTLEN);
X    name[V3_NAMELEN] = '\0';
X    host[V3_HOSTLEN] = '\0';
X    if((host_addr = get_host_addr(host)) == (u_long)-1)
X	host_addr = ntohl(pack->host_addr);
X    pid = ntohl(pack->pid);
X
X    switch(pack->code)
X    {
X	case V3_IMPORT:
X	    /* Don't import a user which is already in this
X	     * session.  This is defined as a user with a matching
X	     * name, host address, and process id.
X	     */
X	    if(find_user(name, host_addr, pid) != NULL)
X		break;
X	    if(!(def_flags & FL_IMPORT))
X	    {
X		sprintf(estr, "Import %s@%s?", name, host);
X		if(yes_no(estr) == 'n')
X		    break;
X	    }
X
X	    /* invite him but don't ring him */
X
X	    sprintf(estr, "%s@%s", name, host);
X	    invite(estr, 0);
X
X	    /* now tell him to connect to us */
X
X	    pack->code = V3_EXPORT;
X	    send_oob(user->fd, pack, V3_PACKLEN);
X
X	    break;
X	case V3_EXPORT:
X	    /* We don't need to check if he's not connected, since
X	     * send_accept() will think his version number is zero
X	     * and won't send anything.
X	     */
X	    if((u = find_user(name, host_addr, pid)) == NULL)
X		break;
X	    send_accept(u, user);
X	    break;
X	case V3_ACCEPT:
X	    sprintf(estr, "%s@%s", name, host);
X	    invite(estr, 1);	/* we should be expected */
X	    break;
X    }
X}
X
X/* Process a Ytalk version 3.? flags packet.  Other users can request
X * that their flags be locked to a particular value until they unlock
X * them later.
X */
Xstatic void
Xv3_process_flags(user, pack)
X  yuser *user;
X  v3_flags *pack;
X{
X    switch(pack->code)
X    {
X	case V3_LOCKF:
X	    user->flags = ntohl(pack->flags) | FL_LOCKED;
X	    break;
X	case V3_UNLOCKF:
X	    user->flags = def_flags;
X	    break;
X    }
X}
X
X/* Process a Ytalk version 3.? winch packet.
X */
Xstatic void
Xv3_process_winch(user, pack)
X  yuser *user;
X  v3_winch *pack;
X{
X    switch(pack->code)
X    {
X	case V3_YOURWIN:
X	    user->remote.my_rows = ntohs(pack->rows);
X	    user->remote.my_cols = ntohs(pack->cols);
X	    winch_exec();
X	    break;
X	case V3_MYWIN:
X	    user->remote.rows = ntohs(pack->rows);
X	    user->remote.cols = ntohs(pack->cols);
X	    break;
X	case V3_REGION:
X	    pack->rows = ntohs(pack->rows);
X	    pack->cols = ntohs(pack->cols);
X	    if(pack->rows > 0)
X		set_win_region(user, (int)(pack->rows), (int)(pack->cols));
X	    else
X		end_win_region(user);
X	    break;
X    }
X    user_winch = 1;
X}
X
X/* Process a Ytalk version 3.? out-of-band packet.  Call the appropriate
X * function based on the type of packet.
X */
Xstatic void
Xv3_process(user, ptr)
X  yuser *user;
X  yaddr ptr;
X{
X    ychar *str;
X
X    /* ignore anything we don't understand */
X
X    str = (ychar *)ptr;
X    switch(*str)
X    {
X	case V3_IMPORT:
X	case V3_EXPORT:
X	case V3_ACCEPT:
X	    v3_process_pack(user, (v3_pack *)ptr);
X	    break;
X	case V3_LOCKF:
X	case V3_UNLOCKF:
X	    v3_process_flags(user, (v3_flags *)ptr);
X	    break;
X	case V3_YOURWIN:
X	case V3_MYWIN:
X	case V3_REGION:
X	    v3_process_winch(user, (v3_winch *)ptr);
X	    break;
X    }
X}
X
X/* Take input from a connected user.  If necessary, drain out-of-band
X * data from the canonical input stream.
X */
Xstatic void
Xread_user(fd)
X  int fd;
X{
X    register ychar *c, *p;
X    register int rc;
X    register yuser *user;
X    static ychar buf[512];
X
X    if(input_flag)
X    {
X	/* tell input_loop() to ignore this function for now */
X	input_flag = 0;
X	return;
X    }
X    if((user = fd_to_user[fd]) == NULL)
X    {
X	remove_fd(fd);
X	show_error("read_user: unknown contact");
X	return;
X    }
X    if((rc = read(fd, buf, 512)) <= 0)
X    {
X	if(rc < 0)
X	    show_error("read_user: read() failed");
X	free_user(user);
X	return;
X    }
X    c = buf;
X    while(rc > 0)
X    {
X	if(user->drain > 0)	/* there is still some OOB data to drain */
X	{
X	    if(rc < user->drain)
X	    {
X		(void)memcpy(user->dptr, c, rc);
X		user->dptr += rc;
X		user->drain -= rc;
X		rc = 0;
X	    }
X	    else
X	    {
X		(void)memcpy(user->dptr, c, user->drain);
X		rc -= user->drain;
X		c += user->drain;
X		user->drain = 0;
X		user->dfunc(user, user->dbuf);
X	    }
X	}
X	else
X	{
X	    /* Ytalk version 3.0 Out-Of-Band data protocol:
X	     *
X	     *    If I receive a V3_OOB character, I look at the next
X	     *    character.  If the next character is V3_OOB, then I
X	     *    send one V3_OOB through transparently.  Else, the
X	     *    next character is a packet length to be drained.
X	     *    The packet length can never be V3_OOB because the
X	     *    maximum out-of-band packet length is (V3_OOB - 1) bytes.
X	     *    If any packet requires more information, then it can
X	     *    always kick off another drain_user() inside v3_process().
X	     */
X	    p = buf;
X	    if(user->got_oob)
X	    {
X		user->got_oob = 0;
X		if(*c <= V3_MAXPACK)
X		{
X		    drain_user(user, *c, v3_process);
X		    c++, rc--;
X		    continue;
X		}
X		*(p++) = *c;
X		c++, rc--;
X	    }
X	    for(; rc > 0; c++, rc--)
X	    {
X		if(*c > 127)			/* could be inline data */
X		{
X		    if(user->remote.vmajor > 2)		/* ytalk 3.0+ */
X		    {
X			if(*c == V3_OOB)
X			{
X			    c++, rc--;
X			    if(rc > 0)
X			    {
X				if(*c <= V3_MAXPACK)
X				{
X				    drain_user(user, *c, v3_process);
X				    c++, rc--;
X				    break;
X				}
X			    }
X			    else
X			    {
X				user->got_oob = 1;
X				break;
X			    }
X			}
X		    }
X		    else if(user->remote.vmajor == 2)	/* ytalk 2.0+ */
X		    {
X			/* Version 2.* didn't support data transparency */
X
X			if(*c == V2_IMPORT || *c == V2_EXPORT
X			|| *c == V2_ACCEPT || *c == V2_AUTO)
X			{
X			    drain_user(user, V2_PACKLEN, v2_process);
X			    /* don't increment c or decrement rc -- they're
X			     * part of the drain.  :-)
X			     */
X			    break;
X			}
X		    }
X		}
X		*(p++) = *c;
X	    }
X	    if(p > buf)
X	    {
X		if(user->output_fd > 0)
X		    if(write(user->output_fd, buf, p - buf) <= 0)
X		    {
X			show_error("write to user output file failed");
X			close(user->output_fd);
X			user->output_fd = 0;
X		    }
X		show_input(user, buf, p - buf);
X	    }
X	}
X    }
X}
X
X/* Initial Handshaking:  read the parameter pack from another ytalk user.
X */
Xstatic void
Xytalk_user(fd)
X  int fd;
X{
X    register yuser *user, *u;
X    u_short cols;
X
X    if((user = fd_to_user[fd]) == NULL)
X    {
X	remove_fd(fd);
X	show_error("ytalk_user: unknown contact");
X	return;
X    }
X    if(full_read(user->fd, &parm, sizeof(y_parm)) < 0)
X    {
X	free_user(user);
X	show_error("ytalk_user: bad ytalk contact");
X	return;
X    }
X    switch(parm.protocol)
X    {
X	case YTP_OLD:
X	    cols = parm.w_cols;
X	    (void)memset(&parm, 0, sizeof(y_parm));
X	    parm.vmajor = 2;
X	    parm.cols = cols;
X	    parm.my_cols = cols;
X	    spew_term(me, fd, me->t_rows, parm.cols);
X	    break;
X	case YTP_NEW:
X	    parm.vmajor = ntohs(parm.vmajor);
X	    parm.vminor = ntohs(parm.vminor);
X	    parm.rows = ntohs(parm.rows);
X	    parm.cols = ntohs(parm.cols);
X	    parm.my_rows = ntohs(parm.my_rows);
X	    parm.my_cols = ntohs(parm.my_cols);
X	    parm.pid = ntohl(parm.pid);
X	    if(user->remote.vmajor <= 2)
X		spew_term(me, fd, parm.rows, parm.cols);
X	    /* else we spew_term later */
X	    break;
X	default:
X	    free_user(user);
X	    show_error("ytalk_user: unsupported ytalk protocol");
X	    return;
X    }
X    user->remote = parm;
X    user_winch = 1;
X    add_fd(fd, read_user);
X
X    /* update the lists */
X
X    if(user == wait_list)
X	wait_list = user->next;
X    else
X	for(u = wait_list; u; u = u->next)
X	    if(u->next == user)
X	    {
X		u->next = user->next;
X		break;
X	    }
X    user->next = connect_list;
X    connect_list = user;
X
X    /* send him my status */
X
X    if(user->remote.vmajor > 2)
X    {
X	if(me->region_set)
X	{
X	    v3w.code = V3_REGION;
X	    v3w.rows = htons(me->rows);
X	    v3w.cols = htons(me->cols);
X	    send_oob(fd, &v3w, V3_WINCHLEN);
X	    winch_exec();
X	    spew_term(me, fd, me->rows, me->cols);
X	}
X	else
X	    spew_term(me, fd, parm.rows, parm.cols);
X
X	if(me->flags & FL_LOCKED)
X	{
X	    v3f.code = V3_LOCKF;
X	    v3f.flags = htonl(me->flags);
X	    send_oob(fd, &v3f, V3_FLAGSLEN);
X	}
X    }
X
X    /* tell everybody else he's here! */
X
X    for(u = connect_list; u; u = u->next)
X	if(u != user)
X	    send_import(u, user);
X}
X
X/* Initial Handshaking:  read the edit keys and determine whether or not
X * this is another ytalk user.
X */
Xstatic void
Xconnect_user(fd)
X  int fd;
X{
X    register yuser *user, *u;
X
X    if((user = fd_to_user[fd]) == NULL)
X    {
X	remove_fd(fd);
X	show_error("connect_user: unknown contact");
X	return;
X    }
X    if(full_read(fd, user->edit, 3) < 0)
X    {
X	free_user(user);
X	show_error("connect_user: bad read");
X	return;
X    }
X    if(open_term(user, user->user_name) < 0)
X    {
X	free_user(user);
X	show_error("connect_user: open_term() failed");
X	return;
X    }
X
X    /* check for ytalk connection */
X
X    if(user->RUB == RUBDEF)
X    {
X	(void)memset(&parm, 0, sizeof(y_parm));
X	parm.protocol = YTP_NEW;
X	parm.vmajor = htons(VMAJOR);
X	parm.vminor = htons(VMINOR);
X	parm.rows = htons(me->t_rows);
X	parm.cols = htons(me->t_cols);
X	parm.my_rows = htons(user->t_rows);
X	parm.my_cols = htons(user->t_cols);
X	parm.w_rows = parm.rows;
X	parm.w_cols = parm.cols;
X	parm.pid = htonl(me->remote.pid);
X	(void)write(user->fd, &parm, sizeof(y_parm));
X	add_fd(fd, ytalk_user);
X    }
X    else
X    {
X	/* update the lists */
X
X	if(user == wait_list)
X	    wait_list = user->next;
X	else
X	    for(u = wait_list; u; u = u->next)
X		if(u->next == user)
X		{
X		    u->next = user->next;
X		    break;
X		}
X	user->next = connect_list;
X	connect_list = user;
X
X	spew_term(me, fd, me->t_rows, me->t_cols);
X	user_winch = 1;
X	add_fd(fd, read_user);
X    }
X}
X
X/* Initial Handshaking:  delete his invitation (if it exists) and send
X * my edit keys.
X */
Xstatic void
Xcontact_user(fd)
X  int fd;
X{
X    register yuser *user;
X    register int n;
X    int socklen;
X
X    remove_fd(fd);
X    if((user = fd_to_user[fd]) == NULL)
X    {
X	show_error("contact_user: unknown contact");
X	return;
X    }
X    (void)send_dgram(user, DELETE_INVITE);
X    socklen = sizeof(struct sockaddr_in);
X    if((n = accept(fd, (struct sockaddr *) &(user->sock), &socklen)) < 0)
X    {
X	free_user(user);
X	show_error("connect_user: accept() failed");
X	return;
X    }
X    close(fd);
X    fd_to_user[fd] = NULL;
X
X    user->fd = n;
X    fd_to_user[user->fd] = user;
X    add_fd(user->fd, connect_user);
X    (void)write(user->fd, me->edit, 3);	/* send the edit keys */
X}
X
X/* Do a word wrap.
X */
Xstatic int
Xword_wrap(user)
X  register yuser *user;
X{
X    register int i, x, bound;
X    static ychar temp[20];
X
X    x = user->x;
X    if((bound = (x >> 1)) > 20)
X	bound = 20;
X    for(i = 1; i < bound && user->scr[user->y][x-i] != ' '; i++)
X	temp[i] = user->scr[user->y][x-i];
X    if(i >= bound)
X	return;
X    move_term(user, user->y, x - i);
X    clreol_term(user);
X    newline_term(user);
X    for(i--; i >= 1; i--)
X	addch_term(user, temp[i]);
X}
X
X/* Ring a user.  If he has an auto-invitation port established then talk
X * to that instead of messing up his screen.
X */
Xstatic int
Xannounce(user)
X  yuser *user;
X{
X    register int rc, fd;
X
X    errno = 0;
X    while((rc = send_dgram(user, AUTO_LOOK_UP)) == 0)
X    {
X	/* he has an auto-invite port established */
X
X	if((fd = connect_to(NULL)) < 0)
X	{
X	    if(fd == -3) /* it's one of my sockets... *sigh* */
X		break;
X	    if(fd == -2) /* connection refused -- they hung up! */
X	    {
X		(void)send_dgram(user, AUTO_DELETE);
X		errno = 0;
X		continue;
X	    }
X	    return -1;
X	}
X	/* Go ahead and use the Ytalk version 2.? auto-announce
X	 * packet.
X	 */
X	v2p.code = V2_AUTO;
X	strncpy(v2p.name, me->user_name, V2_NAMELEN);
X	strncpy(v2p.host, me->host_name, V2_HOSTLEN);
X	v2p.name[V2_NAMELEN-1] = '\0';
X	v2p.host[V2_HOSTLEN-1] = '\0';
X	(void)write(fd, &v2p, V2_PACKLEN);
X	close(fd);
X	return 0;
X    }
X    if(rc == -1)
X	return -1;
X
X    errno = 0;
X    if(send_dgram(user, ANNOUNCE) != 0)
X	return -1;
X    return 0;
X}
X
X/* ---- global functions ---- */
X
X/* Invite a user into the conversation.
X */
Xvoid
Xinvite(name, send_announce)
X  register char *name;
X  int send_announce;
X{
X    register int rc;
X    char *hisname, *hishost, *histty;
X    yuser *user;
X
X    /* First break down the username into login name and login host,
X     * assuming our host as a default.
X     */
X
X    hisname = str_copy(name);
X    hishost = NULL;
X    histty  = NULL;
X    for(name = hisname; *name; name++)
X    {
X	if(*name == '@')
X	{
X	    *name = '\0';
X	    hishost = name+1;
X	}
X	if(*name == '#')
X	{
X	    *name = '\0';
X	    histty = name+1;
X	}
X    }
X    user = new_user(hisname, hishost, histty);
X    free(hisname);
X    if(user == NULL)
X	return;
X
X    /* Now send off the invitation */
X
X    user->next = wait_list;
X    wait_list = user;
X    user_winch = 1;
X    while((rc = send_dgram(user, LOOK_UP)) == 0)
X    {
X	/* We are expected... */
X	if((rc = connect_to(user)) < 0)
X	{
X	    if(rc == -3) /* it's one of my sockets... *sigh* */
X		break;
X	    if(rc == -2) /* connection refused -- they hung up! */
X	    {
X		(void)send_dgram(user, DELETE);
X		continue;
X	    }
X	    free_user(user);
X	    return;
X	}
X	user->last_invite = time(NULL);
X	add_fd(user->fd, connect_user);
X	(void)write(user->fd, me->edit, 3);	/* send the edit keys */
X	return;
X    }
X    if(rc == -1)
X	return;
X
X    /* Leave an invitation for him, and announce ourselves. */
X
X    if(send_announce)
X    {
X	sprintf(errstr, "Ringing %s...", user->user_name);
X	msg_term(me, errstr);
X    }
X    if(newsock(user) != 0)
X    {
X	free_user(user);
X	return;
X    }
X    (void)send_dgram(user, LEAVE_INVITE);
X    user->last_invite = time(NULL);
X    if(send_announce && announce(user) < 0)
X    {
X	(void)send_dgram(user, DELETE_INVITE);
X	sprintf(errstr, "%s not logged in", user->full_name);
X	show_error(errstr);
X	free_user(user);
X	return;
X    }
X    add_fd(user->fd, contact_user);
X}
X
X/* Periodic housecleaning.
X */
Xvoid
Xhouse_clean()
X{
X    register yuser *u, *next;
X    long t;
X    static char estr[80];
X    static u_long last_auto = 0;
X    int answer;
X
X    t = time(NULL);
X
X    if(t - last_auto >= 30)
X    {
X	last_auto = t;
X	if(send_auto(LEAVE_INVITE) != 0)
X	{
X	    show_error("house_clean: send_auto() failed");
X	    kill_auto();
X	}
X    }
X
X    for(u = wait_list; u; u = next)
X    {
X	next = u->next;
X	if(t - u->last_invite >= 30)
X	{
X	    (void)send_dgram(u, LEAVE_INVITE);
X	    u->last_invite = t = time(NULL);
X	    if(!(def_flags & FL_RING))
X	    {
X		if(input_flag)
X		    continue;
X		sprintf(estr, "Rering %s?", u->full_name);
X		answer = yes_no(estr);
X		t = time(NULL);
X		if(answer == 'n')
X		    continue;
X	    }
X	    if(announce(u) < 0)
X	    {
X		(void)send_dgram(u, DELETE_INVITE);
X		sprintf(errstr, "%s not logged in", u->full_name);
X		show_error(errstr);
X		free_user(u);
X	    }
X	}
X    }
X}
X
Xvoid
Xsend_winch(user)
X  yuser *user;
X{
X    register yuser *u;
X
X    v3w.rows = htons(user->t_rows);
X    v3w.cols = htons(user->t_cols);
X
X    if(user == me)
X    {
X	v3w.code = V3_MYWIN;
X	for(u = connect_list; u; u = u->next)
X	    if(u->remote.vmajor > 2)
X		send_oob(u->fd, &v3w, V3_WINCHLEN);
X	winch_exec();
X    }
X    else if(user->remote.vmajor > 2)
X    {
X	v3w.code = V3_YOURWIN;
X	send_oob(user->fd, &v3w, V3_WINCHLEN);
X    }
X}
X
Xvoid
Xsend_region()
X{
X    register yuser *u;
X
X    v3w.code = V3_REGION;
X    v3w.rows = htons(me->rows);
X    v3w.cols = htons(me->cols);
X
X    for(u = connect_list; u; u = u->next)
X	if(u->remote.vmajor > 2)
X	    send_oob(u->fd, &v3w, V3_WINCHLEN);
X}
X
Xvoid
Xsend_end_region()
X{
X    register yuser *u;
X
X    v3w.code = V3_REGION;
X    v3w.rows = htons(0);
X    v3w.cols = htons(0);
X
X    for(u = connect_list; u; u = u->next)
X	if(u->remote.vmajor > 2)
X	    send_oob(u->fd, &v3w, V3_WINCHLEN);
X}
X
Xvoid
Xsend_users(buf, len)
X  ychar *buf;
X  register int len;
X{
X    register ychar *o, *b;
X    register yuser *u;
X    static ychar *o_buf = NULL;
X    static int o_len = 0;
X
X    /* data transparency */
X
X    if((len << 1) > o_len)
X    {
X	o_len = (len << 1) + 512;
X	o_buf = (ychar *)realloc_mem(o_buf, o_len);
X    }
X    for(b = buf, o = o_buf; len > 0; b++, len--)
X    {
X	*(o++) = *b;
X	if(*b == V3_OOB)
X	    *(o++) = V3_OOB;
X    }
X    for(u = connect_list; u; u = u->next)
X	if(u->remote.vmajor > 2)
X	    (void)write(u->fd, o_buf, o - o_buf);
X	else
X	    (void)write(u->fd, buf, b - buf);
X}
X
X/* Display user input.  Emulate ANSI.
X */
Xvoid
Xshow_input(user, buf, len)
X  yuser *user;
X  register ychar *buf;
X  register int len;
X{
X    if(user->got_esc)
X    {
Xprocess_esc:
X	for(; len > 0; len--, buf++)
X	{
X	    if(*buf >= '0' && *buf <= '9' && user->got_esc > 1)
X	    {
X		user->av[user->ac] = (user->av[user->ac] * 10) + (*buf - '0');
X		continue;
X	    }
X	    switch(*buf)
X	    {
X		case ';':	/* arg separator */
X		    if(user->ac < MAXARG-1)
X			user->av[++(user->ac)] = 0;
X		    break;
X		case '[':
X		    user->got_esc = 2;
X		    break;
X		case '?':
X		    if(user->got_esc == 2)
X			user->got_esc = 3;
X		    else
X			user->got_esc = 0;
X		    break;
X		case '7':	/* save cursor */
X		    user->sy = user->y;
X		    user->sx = user->x;
X		    user->got_esc = 0;
X		    break;
X		case '8':	/* restore cursor */
X		    move_term(user, user->sy, user->sx);
X		    user->got_esc = 0;
X		    break;
X		case '@':
X		    if(user->got_esc == 2)	/* add char */
X		    {
X			if(user->av[0] == 0)
X			    add_char_term(user, 1);
X			else
X			    add_char_term(user, user->av[0]);
X		    }
X		    user->got_esc = 0;
X		    break;
X		case 'A':	/* move up */
X		    if(user->av[0] == 0)
X			move_term(user, user->y - 1, user->x);
X		    else if(user->av[0] > user->y)
X			move_term(user, 0, user->x);
X		    else
X			move_term(user, user->y - user->av[0], user->x);
X		    user->got_esc = 0;
X		    break;
X		case 'B':	/* move down */
X		    if(user->av[0] == 0)
X			move_term(user, user->y + 1, user->x);
X		    else
X			move_term(user, user->y + user->av[0], user->x);
X		    user->got_esc = 0;
X		    break;
X		case 'C':	/* move right */
X		    if(user->av[0] == 0)
X			move_term(user, user->y, user->x + 1);
X		    else
X			move_term(user, user->y, user->x + user->av[0]);
X		    user->got_esc = 0;
X		    break;
X		case 'D':	/* move left */
X		    if(user->av[0] == 0)
X			move_term(user, user->y, user->x - 1);
X		    else if(user->av[0] > user->x)
X			move_term(user, user->y, 0);
X		    else
X			move_term(user, user->y, user->x - user->av[0]);
X		    user->got_esc = 0;
X		    break;
X		case 'H':	/* move */
X		    if(user->av[0] > 0)
X			user->av[0]--;
X		    if(user->av[1] > 0)
X			user->av[1]--;
X		    move_term(user, user->av[0], user->av[1]);
X		    user->got_esc = 0;
X		    break;
X		case 'J':	/* clear to end of screen */
X		    clreos_term(user);
X		    user->got_esc = 0;
X		    break;
X		case 'K':	/* clear to end of line */
X		    clreol_term(user);
X		    user->got_esc = 0;
X		    break;
X		case 'L':
X		    if(user->got_esc == 2)	/* add line */
X		    {
X			if(user->av[0] == 0)
X			    add_line_term(user, 1);
X			else
X			    add_line_term(user, user->av[0]);
X		    }
X		    user->got_esc = 0;
X		    break;
X		case 'M':
X		    if(user->got_esc == 2)	/* delete line */
X		    {
X			if(user->av[0] == 0)
X			    del_line_term(user, 1);
X			else
X			    del_line_term(user, user->av[0]);
X		    }
X		    else			/* reverse scroll */
X			rev_scroll_term(user);
X		    user->got_esc = 0;
X		    break;
X		case 'P':
X		    if(user->got_esc == 2)	/* del char */
X		    {
X			if(user->av[0] == 0)
X			    del_char_term(user, 1);
X			else
X			    del_char_term(user, user->av[0]);
X		    }
X		    user->got_esc = 0;
X		    break;
X		case 'S':	/* forward scroll */
X		    scroll_term(user);
X		    user->got_esc = 0;
X		    break;
X		case 'r':	/* set scroll region */
X		    if(user->av[0] > 0)
X			user->av[0]--;
X		    if(user->av[1] > 0)
X			user->av[1]--;
X		    set_scroll_region(user, user->av[0], user->av[1]);
X		    user->got_esc = 0;
X		    break;
X		default:
X		    user->got_esc = 0;
X	    }
X	    if(user->got_esc == 0)
X	    {
X		len--, buf++;
X		break;
X	    }
X	}
X    }
X    for(; len > 0; len--, buf++)
X    {
X	if(*buf >= ' ' && *buf <= '~')
X	{
X	    if((user->flags & FL_WRAP) && user->x + 1 >= user->cols)
X	    {
X		if(*buf == ' ')
X		    newline_term(user);
X		else
X		{
X		    word_wrap(user);
X		    addch_term(user, *buf);
X		}
X	    }
X	    else
X		addch_term(user, *buf);
X	}
X	else if(*buf == user->RUB && !(user->flags & FL_RAW))
X	    rub_term(user);
X	else if(*buf == user->WORD && !(user->flags & FL_RAW))
X	    (void)word_term(user);
X	else if(*buf == user->KILL && !(user->flags & FL_RAW))
X	    kill_term(user);
X	else
X	{
X	    switch(*buf)
X	    {
X		case 7:		/* Bell */
X		    putc(7, stderr);
X		    break;
X		case 8:		/* Backspace */
X		    if(user->x > 0)
X			move_term(user, user->y, user->x - 1);
X		    break;
X		case 9:		/* Tab */
X		    tab_term(user);
X		    break;
X		case 10:	/* Newline */
X		    newline_term(user);
X		    break;
X		case 13:	/* Return */
X		    if(user->flags & FL_RAW)
X			move_term(user, user->y, 0);
X		    else
X			newline_term(user);
X		    break;
X		case 27:	/* Escape */
X		    user->got_esc = 1;
X		    user->ac = 0;
X		    user->av[0] = 0;
X		    user->av[1] = 0;
X		    len--, buf++;
X		    goto process_esc;	/* ugly but _fast_ */
X		default:
X		    if(*buf < ' ')
X		    {
X			/* show a control char */
X		    }
X	    }
X	}
X    }
X    flush_term(user);
X}
X
X/* Process keyboard input.
X */
Xvoid
Xmy_input(buf, len)
X  register ychar *buf;
X  int len;
X{
X    register ychar *c;
X    register int i;
X
X    /* If someone's waiting for input, give it to them! */
X
X    if(input_flag)
X    {
X	io_ptr = buf;
X	io_len = len;
X	return;
X    }
X
X    /* Process input normally */
X
X    while(len > 0)
X    {
X	/* check for a menu in process */
X
X	if(menu_ptr)
X	{
X	    io_ptr = buf;
X	    io_len = len;
X	    update_menu();
X	    buf = io_ptr;
X	    len = io_len;
X	    io_len = 0;
X	}
X
X	/* check for a running process */
X
X	if(running_process)
X	{
X	    io_ptr = buf;
X	    io_len = len;
X	    update_exec();
X	    buf = io_ptr;
X	    len = io_len;
X	    io_len = 0;
X	}
X	else
X	{
X	    /* do normal input */
X
X	    c = buf;
X	    for(; len > 0; buf++, len--)
X	    {
X		if(*buf == me->old_rub)
X		    *buf = me->RUB;
X		else if(*buf == '\r')
X		    *buf = '\n';
X		else if(*buf == 3)	/* Ctrl-C */
X		    bail(0);
X		else if(*buf == 27)	/* Esc */
X		    break;
X	    }
X	    if((i = buf - c) > 0)
X	    {
X		show_input(me, c, i);
X		send_users(c, i);
X	    }
X	}
X
X	/* start a menu if necessary */
X
X	if(len > 0)
X	{
X	    buf++;
X	    len--;
X	    show_main_menu();
X	    if(len <= 0)
X		update_menu();
X	}
X    }
X}
X
Xvoid
Xlock_flags(flags)
X  u_long flags;
X{
X    register yuser *u;
X
X    me->flags = flags | FL_LOCKED;
X
X    /* send to connected users... */
X
X    v3f.code = V3_LOCKF;
X    v3f.flags = htonl(me->flags);
X    for(u = connect_list; u; u = u->next)
X	if(u->remote.vmajor > 2)
X	    send_oob(u->fd, &v3f, V3_FLAGSLEN);
X}
X
Xvoid
Xunlock_flags()
X{
X    register yuser *u;
X
X    me->flags = def_flags;
X
X    /* send to connected users... */
X
X    v3f.code = V3_UNLOCKF;
X    v3f.flags = htonl(me->flags);
X    for(u = connect_list; u; u = u->next)
X	if(u->remote.vmajor > 2)
X	    send_oob(u->fd, &v3f, V3_FLAGSLEN);
X}
END_OF_FILE
if test 27713 -ne `wc -c <'comm.c'`; then
    echo shar: \"'comm.c'\" unpacked with wrong size!
fi
# end of 'comm.c'
fi
if test -f 'fd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fd.c'\"
else
echo shar: Extracting \"'fd.c'\" \(5663 characters\)
sed "s/^X//" >'fd.c' <<'END_OF_FILE'
X/* fd.c */
X
X/*			   NOTICE
X *
X * Copyright (c) 1990,1992,1993 Britt Yenne.  All rights reserved.
X * 
X * This software is provided AS-IS.  The author gives no warranty,
X * real or assumed, and takes no responsibility whatsoever for any 
X * use or misuse of this software, or any damage created by its use
X * or misuse.
X * 
X * This software may be freely copied and distributed provided that
X * no part of this NOTICE is deleted or edited in any manner.
X * 
X */
X
X/* Mail comments or questions to ytalk@austin.eds.com */
X
X#include "header.h"
X#include "menu.h"
X#include <sys/time.h>
X#include <signal.h>
X#ifdef _AIX
X# include <sys/select.h>
X#endif
X
Xstatic fd_set fdset;		/* descriptors to select on */
Xstatic fd_set fdtmp;		/* descriptors to select on (input_loop) */
Xstatic fd_set sel;		/* currently readable descriptors */
Xstatic int high_fd = 0;		/* highest fd so far */
Xint input_flag = 0;		/* flag: waiting for user input */
Xint user_winch = 0;		/* flag: user window/status changed */
X
Xstruct fd_func {
X    void (*func)();			/* user function */
X};
Xstatic struct fd_func tag[MAX_FILES];	/* one function per file descriptor */
X
X/* Initialize fdset data.
X */
Xvoid
Xinit_fd()
X{
X    FD_ZERO(&fdset);
X}
X
X/* Add a file descriptor to the current checklist.  The supplied
X * function will be called whenever the file descriptor has input
X * waiting.
X */
Xvoid
Xadd_fd(fd, user_func)
X  int fd;
X  void (*user_func)();
X{
X    if(fd < 0 || fd >= MAX_FILES)
X    {
X	show_error("add_fd: descriptor out of range");
X	return;
X    }
X    FD_SET(fd, &fdset);
X    tag[fd].func = user_func;
X    if(fd >= high_fd)
X	high_fd = fd + 1;
X}
X
X/* Remove a file descriptor from the checklist.
X */
Xvoid
Xremove_fd(fd)
X  int fd;
X{
X    if(fd < 0 || fd >= MAX_FILES)
X    {
X	show_error("remove_fd: descriptor out of range");
X	return;
X    }
X    FD_CLR(fd, &fdset);
X    FD_CLR(fd, &fdtmp);
X    FD_CLR(fd, &sel);
X}
X
X/* Read an entire length of data.
X * Returns 0 on success, -1 on error.
X */
Xint
Xfull_read(fd, buf, len)
X  int fd;
X  register char *buf;
X  register int len;
X{
X    register int rc;
X
X    while(len > 0)
X    {
X	if((rc = read(fd, buf, len)) <= 0)
X	    return -1;
X	buf += rc;
X	len -= rc;
X    }
X    return 0;
X}
X
X/* -- MAIN LOOPS -- */
X
Xstatic long lastping, curtime;
X
Xvoid
Xmain_loop()
X{
X    register int fd, rc;
X    int mask, old_mask;
X    struct timeval tv;
X
X    /* Some signals need to be blocked while doing internal
X     * processing, else some craziness might occur.
X     */
X
X    mask = 0;
X
X#ifdef SIGWINCH
X    mask |= sigmask(SIGWINCH);
X#endif
X
X    /* For housecleaning to occur every CLEAN_INTERVAL seconds, we make
X     * our own little timer system.  SIGALRM is nice; in fact it's so
X     * useful that we'll be using it in other parts of YTalk.  Since
X     * we therefore can't use it here, we affect the timer manually.
X     */
X
X    house_clean();
X    curtime = lastping = time(NULL);
X    for(;;)
X    {
X	/* check if we're done */
X
X	if(connect_list == NULL
X	&& wait_list == NULL
X	&& menu_ptr == NULL
X	&& running_process == 0)
X	    bail(0);
X
X	/* select */
X
X	sel = fdset;
X	if(curtime > lastping + CLEAN_INTERVAL)
X	    tv.tv_sec = 0;
X	else
X	    tv.tv_sec = (lastping + CLEAN_INTERVAL) - curtime;
X	tv.tv_usec = 0;
X	if((rc = select(high_fd, &sel, 0, 0, &tv)) < 0)
X	    if(errno != EINTR)
X		show_error("main_loop: select failed");
X
X	/* block signals while doing internal processing */
X
X	old_mask = sigblock(mask);
X
X	/* process file descriptors with input waiting */
X
X	if(rc > 0)
X	    for(fd = 0; fd < high_fd; fd++)
X		if(FD_ISSET(fd, &sel))
X		{
X		    errno = 0;
X		    tag[fd].func(fd);
X		    if(--rc <= 0)
X			break;
X		}
X
X	/* check timer */
X
X	curtime = time(NULL);
X	if(curtime - lastping >= CLEAN_INTERVAL)
X	{
X	    house_clean();
X	    lastping = time(NULL);
X	}
X
X	/* re-allow signals */
X
X	sigsetmask(old_mask);
X	if(user_winch)
X	{
X	    /* This is a cute hack that updates a user menu
X	     * dynamically as information changes.  So I had
X	     * some free time.  there.
X	     */
X	    user_winch = 0;
X	    update_user_menu();
X	}
X    }
X}
X
X/* Input loop.  This loop keeps everything except user input going until
X * input is received from <me>.  This is necessary for answering pressing
X * questions without needing to add a getch_term() function to the terminal
X * definition library.  Hack?  maybe.  Fun, tho.
X */
Xvoid
Xinput_loop()
X{
X    register int fd, rc;
X    struct timeval tv;
X    static int left_loop;
X
X    left_loop = 0;
X    fdtmp = fdset;
X    while(io_len <= 0)
X    {
X	/* select */
X
X	sel = fdtmp;
X	if(curtime > lastping + CLEAN_INTERVAL)
X	    tv.tv_sec = 0;
X	else
X	    tv.tv_sec = (lastping + CLEAN_INTERVAL) - curtime;
X	tv.tv_usec = 0;
X	if((rc = select(high_fd, &sel, 0, 0, &tv)) < 0)
X	    if(errno != EINTR)
X		show_error("input_loop: select failed");
X
X	/* process file descriptors with input waiting */
X
X	if(rc > 0)
X	    for(fd = 0; fd < high_fd; fd++)
X		if(FD_ISSET(fd, &sel))
X		{
X		    /* Here the hack begins.  Any function that takes user
X		     * input should clear "input_flag" and return.  This
X		     * tells us to ignore this function for now.  Any
X		     * function which receives input from <me> should leave
X		     * my input in io_ptr/io_len.
X		     */
X		    errno = 0;
X		    input_flag = 1;
X		    tag[fd].func(fd);
X		    if(left_loop) /* recursive input_loop()s.  argh! */
X			return;   /* let my parent function re-call me */
X		    if(input_flag == 0)
X		    {
X			/* don't check this descriptor anymore */
X			FD_CLR(fd, &fdtmp);
X		    }
X		    if(--rc <= 0)
X			break;
X		}
X
X	/* check timer */
X
X	curtime = time(NULL);
X	if(curtime - lastping >= CLEAN_INTERVAL)
X	{
X	    input_flag = 1;
X	    house_clean();
X	    lastping = time(NULL);
X	}
X    }
X    input_flag = 0;
X    left_loop = 1;
X}
END_OF_FILE
if test 5663 -ne `wc -c <'fd.c'`; then
    echo shar: \"'fd.c'\" unpacked with wrong size!
fi
# end of 'fd.c'
fi
if test -f 'menu.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'menu.c'\"
else
echo shar: Extracting \"'menu.c'\" \(18501 characters\)
sed "s/^X//" >'menu.c' <<'END_OF_FILE'
X/* menu.c */
X
X/*			   NOTICE
X *
X * Copyright (c) 1990,1992,1993 Britt Yenne.  All rights reserved.
X * 
X * This software is provided AS-IS.  The author gives no warranty,
X * real or assumed, and takes no responsibility whatsoever for any 
X * use or misuse of this software, or any damage created by its use
X * or misuse.
X * 
X * This software may be freely copied and distributed provided that
X * no part of this NOTICE is deleted or edited in any manner.
X * 
X */
X
X/* Mail comments or questions to ytalk@austin.eds.com */
X
X#include "header.h"
X#include <fcntl.h>
X#include "menu.h"
X
X/* This particular file was written real early one night (morning?)
X * while trying to stay awake long enough to do laundry.  I hereby take
X * extra-special pains to absolve myself of any and all responsibility
X * for this source.
X */
X
Xstatic void main_menu_sel();
Xmenu_item *menu_ptr = NULL;		/* current menu in processing */
Xstatic int menu_len;			/* number of items in current menu */
Xstatic int menu_long;			/* longest item of current menu */
Xstatic int menu_line;			/* current line number of menu */
Xstatic int text_pos = -1;		/* text offset if non-negative */
Xstatic int text_ypos = -1, text_xpos = -1; /* text coord if non-negative */
X
Xextern void raw_term();			/* our raw interface to the terminal */
X
X/* some menus... */
X
Xstatic menu_item main_menu[] = {
X    { "Main Menu",		NULL,		' ' },
X    { "",			NULL,		' ' },
X    { "add a user",		main_menu_sel,	'a' },
X    { "delete a user",		main_menu_sel,	'd' },
X    { "options",		main_menu_sel,	'o' },
X    { "shell",			main_menu_sel,	's' },
X    { "user list",		main_menu_sel,	'u' },
X    { "output user to file",	main_menu_sel,	'w' },
X    { "quit",			main_menu_sel,	'q' },
X    { "",			NULL,		'\0'}	/* MUST BE LAST */
X};
X
X#define MAXUMENU 52
Xstatic menu_item user_menu[MAXUMENU];	/* this one changes each time */
Xstatic menu_item option_menu[20];	/* options menu buffer */
Xstatic menu_item yes_no_menu[1];	/* yes/no entry menu */
Xstatic menu_item mesg_menu[1];		/* message menu */
X
Xstatic char text_str[MAXTEXT+1];	/* string entry buffer */
Xstatic menu_item text_menu[2];		/* string entry menu */
Xstatic char user_buf[MAXUMENU][80];	/* user list buffers */
X
X/* major hack below... [maniacal laughter] */
X
Xstatic int got_error = 0;
Xstatic char err_str[8][MAXERR];
Xstatic menu_item error_menu[] = {
X    { "Ytalk Error",		NULL,		' ' },
X    { "",			NULL,		' ' },
X    { NULL,			show_error,	' ' },
X    { NULL,			show_error,	' ' },
X    { "",			NULL,		' ' },
X    { NULL,			show_error,	' ' },
X    { NULL,			show_error,	' ' },
X    { "",			NULL,		' ' },
X    { NULL,			show_error,	' ' },
X    { NULL,			show_error,	' ' },
X    { "",			NULL,		' ' },
X    { NULL,			show_error,	' ' },
X    { NULL,			show_error,	' ' },
X    { "",			NULL,		'\0'}	/* MUST BE LAST */
X};
X
X/* ---- local functions ---- */
X
Xstatic yuser *output_user = NULL;
X
Xstatic void
Xdo_output(filename)
X  char *filename;
X{
X    int fd;
X
X    if(output_user == NULL)
X	return;
X    if((fd = open(filename, O_RDWR | O_TRUNC | O_CREAT, 0600)) < 0)
X    {
X	show_error(filename);
X	return;
X    }
X    output_user->output_fd = fd;
X    spew_term(output_user, fd, output_user->rows, output_user->cols);
X    output_user = NULL;
X}
X
Xstatic void
Xdo_output_user(user)
X  yuser *user;
X{
X    /* if he has an open descriptor, close it */
X
X    if(user->output_fd > 0)
X    {
X	close(user->output_fd);
X	user->output_fd = 0;
X	if(show_mesg("Output Terminated", NULL) >= 0)
X	    update_menu();
X	return;
X    }
X
X    /* else open one */
X
X    output_user = user;
X    if(show_text("Output filename?", do_output) >= 0)
X	update_menu();
X    else
X	output_user = NULL;
X}
X
Xstatic void
Xdo_invite(name)
X  char *name;
X{
X    invite(name, 1);
X}
X
Xstatic void
Xmain_menu_sel(key)
X  ychar key;
X{
X    switch(key)
X    {
X	case 'a':	/* add a user */
X	    if(show_text("Add Which User?", do_invite) >= 0)
X		update_menu();
X	    break;
X	case 'd':	/* delete a user */
X	    if(show_user_menu("Delete Which User?", free_user) >= 0)
X		update_menu();
X	    break;
X	case 'o':	/* show options */
X	    if(show_option_menu() >= 0)
X		update_menu();
X	    break;
X	case 's':	/* invoke a shell */
X	    kill_menu();
X	    execute(NULL);
X	    break;
X	case 'u':	/* show a user list */
X	    if(show_user_list() >= 0)
X		update_menu();
X	    break;
X	case 'w':	/* output user to file */
X	    if(show_user_menu("Output Which User?", do_output_user) >= 0)
X		update_menu();
X	    break;
X	case 'q':	/* quit */
X	    bail(0);
X    }
X}
X
Xstatic void
Xoption_menu_sel(key)
X  ychar key;
X{
X    register yuser *u;
X    u_long old_flags;
X
X    old_flags = def_flags;
X    switch(key)
X    {
X	case 's':	/* toggle scrolling */
X	    def_flags ^= FL_SCROLL;
X	    break;
X	case 'w':	/* toggle word wrap */
X	    def_flags ^= FL_WRAP;
X	    break;
X	case 'i':	/* toggle automatic imports */
X	    def_flags ^= FL_IMPORT;
X	    break;
X	case 'v':	/* toggle automatic invitations */
X	    def_flags ^= FL_INVITE;
X	    break;
X	case 'r':	/* toggle automatic re-rings */
X	    def_flags ^= FL_RING;
X	    break;
X    }
X
X    if(old_flags != def_flags)
X    {
X	for(u = user_list; u != NULL; u = u->unext)
X	    if(!(u->flags & FL_LOCKED))
X		u->flags = def_flags;
X    }
X
X    if(show_option_menu() >= 0)
X	update_menu();
X    else
X	kill_menu();
X}
X
Xstatic void
Xuser_menu_sel(key)
X  ychar key;
X{
X    register int i;
X    register yuser *u;
X
X    /* Remember... the user list could have changed between the time
X     * I created the user menu and the time I just now selected one
X     * of the users from it.
X     */
X    for(i = 0; i < menu_len; i++)
X	if(user_menu[i].key == key)
X	{
X	    for(u = user_list; u; u = u->unext)
X		if(u->key == key
X		&& strcmp(u->full_name, user_menu[i].item) == 0)
X		{
X		    user_menu[0].func(u);
X		    break;
X		}
X	    break;
X	}
X    if(menu_ptr == user_menu)
X	kill_menu();
X}
X
X#define MENU_EXTRA 7	/* number of extra characters per menu screen item */
X
Xstatic void
Xgenerate_text_length()
X{
X    menu_long = me->t_cols - MENU_EXTRA - 2;
X    if(menu_long < 5 || menu_long > MAXTEXT)
X	menu_long = MAXTEXT;
X}
X
Xstatic void
Xgenerate_yes_no_length()
X{
X    menu_long = strlen(yes_no_menu[0].item) - 2;
X}
X
Xstatic void
Xpad_str(from, len, to)
X  char *from, *to;
X  int len;
X{
X    for(; len > 0 && *from; len--, from++)
X	*(to++) = *from;
X    for(; len > 0; len--)
X	*(to++) = ' ';
X    *to = '\0';
X}
X
X/* ---- global functions ---- */
X
X/* End any menu processing.
X */
Xvoid
Xkill_menu()
X{
X    register int i;
X
X    if(menu_ptr != NULL)
X    {
X	menu_ptr = NULL;
X	redraw_term(me, 0);
X	flush_term(me);
X	text_pos = -1;
X	text_ypos = -1;
X	text_xpos = -1;
X    }
X    if(got_error)
X    {
X	got_error = 0;
X	for(i = 0; error_menu[i].key != '\0'; i++)
X	    if(error_menu[i].func != NULL)
X		error_menu[i].item = NULL;
X    }
X}
X
X/* Update menu information.
X */
Xvoid
Xupdate_menu()
X{
X    register ychar *c;
X    register char *d;
X    register int j, i, y, x;
X    static ychar *buf = NULL;
X    static int buflen = 0;
X
X    if(menu_ptr == NULL)
X	return;
X    
X    /* process any input */
X
X    if(io_len > 0)
X    {
X	ychar ic;
X
X	if(menu_ptr == text_menu)
X	{
X	    for(; io_len > 0; io_len--)
X	    {
X		ic = *(io_ptr++);
X
X		if(ic > ' ' && ic <= '~')
X		{
X		    if(text_pos >= menu_long)
X			putc(7, stderr);
X		    else
X		    {
X			text_str[text_pos] = (char)ic;
X			if(text_ypos >= 0)
X			    raw_term(me, text_ypos, text_xpos + text_pos,
X				text_str + text_pos, 1);
X			text_str[++text_pos] = '\0';
X		    }
X		}
X		else if(ic == me->old_rub)
X		{
X		    if(text_pos > 0)
X		    {
X			text_str[--text_pos] = '\0';
X			if(text_ypos >= 0)
X			    raw_term(me, text_ypos, text_xpos + text_pos,
X				" ", 1);
X		    }
X		}
X		else if(ic == me->KILL || ic == me->WORD)
X		{
X		    if(text_pos > 0)
X		    {
X			text_str[0] = '\0';
X			text_pos = 0;
X			if(text_ypos > 0)
X			    raw_term(me, text_ypos, text_xpos,
X				"     ", menu_long);
X		    }
X		}
X		else if(ic == '\n' || ic == '\r')
X		{
X		    if(text_pos > 0)
X		    {
X			text_str[text_pos] = '\0';	/* just to be sure */
X			kill_menu();
X			text_menu[0].func(text_str);
X		    }
X		    else
X			kill_menu();
X		    return;
X		}
X		else if(ic == 27 || ic == 4)
X		{
X		    kill_menu();
X		    return;
X		}
X	    }
X	    if(text_ypos >= 0)
X	    {
X		raw_term(me, text_ypos, text_xpos + text_pos, NULL, 0);
X		flush_term(me);
X		return;
X	    }
X	}
X	else if(menu_ptr == yes_no_menu)
X	{
X	    /* don't handle yes/no input here */
X	}
X	else if(menu_ptr == mesg_menu)
X	{
X	    ic = *(io_ptr++);
X	    io_len--;
X	    kill_menu();
X	    if(mesg_menu[0].func)
X		mesg_menu[0].func(ic);
X	    return;
X	}
X	else
X	{
X	    ic = *(io_ptr++);
X	    io_len--;
X	    if(ic == ' ' || ic == '\n' || ic == '\r')
X	    {
X		/* scroll the menu */
X
X		menu_line += me->t_rows - 1;
X		if(menu_line >= menu_len)
X		{
X		    kill_menu();
X		    return;
X		}
X		i = menu_len - (me->t_rows - 1);	/* last full screen */
X		if(i < menu_line)
X		    menu_line = i;
X	    }
X	    else if(ic > ' ' && ic <= '~')
X	    {
X		for(i = 0; i < menu_len; i++)
X		    if(menu_ptr[i].key == ic && menu_ptr[i].func != NULL)
X		    {
X			menu_ptr[i].func(ic);
X			/*
X			 * THE WHOLE WORLD COULD BE DIFFERENT NOW.
X			 */
X			i = -1;
X			break;
X		    }
X		if(i >= 0)
X		    kill_menu();
X		return;
X	    }
X	    else
X	    {
X		kill_menu();
X		return;
X	    }
X	}
X    }
X
X    /* Check the buffer.  Keep in mind that we could be here because
X     * the window size has changed.
X     */
X
X    if(menu_ptr == text_menu)
X    {
X	generate_text_length();
X	text_ypos = -1;		/* assume it's not displayed */
X	text_xpos = -1;
X    }
X    else if(menu_ptr == yes_no_menu)
X    {
X	menu_len = 1;
X	menu_line = 0;
X	generate_yes_no_length();
X    }
X    if(menu_long > buflen)
X    {
X	buflen = menu_long + 64;
X	buf = (ychar *)realloc_mem(buf, buflen + MENU_EXTRA);
X    }
X
X    /* get starting X and Y coord */
X
X    x = center(me->t_cols, menu_long + MENU_EXTRA);
X    if(menu_line == 0)
X    {
X	if(menu_len + 2 <= me->t_rows)
X	{
X	    y = center(me->t_rows, menu_len + 2);
X	    raw_term(me, y++, x, "#####", menu_long + MENU_EXTRA);
X	}
X	else
X	    y = 0;
X    }
X    else
X	y = 0;
X
X    /* show as many menu lines as we can */
X
X    for(i = menu_line; y+1 < me->t_rows && i < menu_len; i++, y++)
X    {
X	c = buf;
X	*(c++) = '#';
X	*(c++) = ' ';
X	if(menu_ptr[i].key == ' ')
X	{
X	    j = 0;
X	    if(menu_ptr == text_menu)
X	    {
X		if(i > 0)
X		{
X		    *(c++) = '>';
X		    *(c++) = ' ';
X		    j += 2;
X		    text_ypos = y;
X		    text_xpos = x + j + 2;
X		}
X	    }
X	    else if(menu_ptr != yes_no_menu)
X	    {
X		int temp;
X		temp = center(menu_long + 3, strlen(menu_ptr[i].item));
X		for(; j < temp; j++)
X		    *(c++) = ' ';
X	    }
X	    for(d = menu_ptr[i].item; *d; d++, j++)
X		*(c++) = (ychar)*d;
X	    for(; j < menu_long + 3; j++)
X		*(c++) = ' ';
X	}
X	else
X	{
X	    *(c++) = menu_ptr[i].key;
X	    *(c++) = ':';
X	    *(c++) = ' ';
X	    for(d = menu_ptr[i].item, j = 0; *d; d++, j++)
X		*(c++) = (ychar)*d;
X	    for(; j < menu_long; j++)
X		*(c++) = ' ';
X	}
X	*(c++) = ' ';
X	*(c++) = '#';
X	raw_term(me, y, x, buf, c - buf);
X    }
X    if(y < me->t_rows)
X    {
X	if(i < menu_len)
X	{
X	    c = buf;
X	    *(c++) = '#';
X	    *(c++) = ' ';
X	    *(c++) = ' ';
X	    *(c++) = ' ';
X	    *(c++) = ' ';
X	    for(d = "(more)", j = 0; *d; d++, j++)
X		*(c++) = (ychar)*d;
X	    for(; j < menu_long; j++)
X		*(c++) = ' ';
X	    *(c++) = ' ';
X	    *(c++) = '#';
X	    raw_term(me, y, x, buf, c - buf);
X	    raw_term(me, y, x + 12, NULL, 0);
X	}
X	else
X	{
X	    raw_term(me, y, x, "#####", menu_long + MENU_EXTRA);
X	    if(menu_ptr == text_menu)
X		raw_term(me, text_ypos, text_xpos + text_pos, NULL, 0);
X	    else if(menu_ptr == yes_no_menu)
X		raw_term(me, y-1, x + menu_long + MENU_EXTRA - 2, NULL, 0);
X	    else
X		raw_term(me, y, me->t_cols / 2, NULL, 0);
X	}
X    }
X    flush_term(me);
X}
X
X/* Show a menu, overriding any existing menu.
X */
Xint
Xshow_menu(menu, len)
X  menu_item *menu;
X  int len;
X{
X    register int i, j;
X
X    if(me->t_rows < 2)
X    {
X	show_error("show_menu: window too small");
X	return -1;
X    }
X
X    /* scan the menu for problems */
X
X    menu_long = 0;
X    for(i = 0; i < len; i++)
X    {
X	if((j = strlen(menu[i].item)) > menu_long)
X	    menu_long = j;
X	if(menu[i].key < ' ' || menu[i].key >= '~')
X	{
X	    show_error("show_menu: invalid key");
X	    return -1;
X	}
X    }
X    if(menu_long <= 0)
X    {
X	show_error("show_menu: menu too small");
X	return -1;
X    }
X    if(menu_long < 10)
X	menu_long = 10;
X    
X    /* set up the menu for display */
X
X    menu_ptr = menu;
X    menu_len = len;
X    menu_line = 0;
X    
X    return 0;
X}
X
X/* Show a text entry menu, overriding any existing menu.
X */
Xint
Xshow_text(prompt, func)
X  char *prompt;
X  void (*func)();
X{
X    if(me->t_rows < 3)
X    {
X	show_error("show_text: window too small");
X	return -1;
X    }
X
X    /* set up the menu for display */
X
X    text_menu[0].item = prompt;
X    text_menu[0].func = func;
X    text_menu[0].key = ' ';
X
X    text_str[0] = '\0';
X    text_menu[1].item = text_str;
X    text_menu[1].func = NULL;
X    text_menu[1].key = ' ';
X
X    menu_ptr = text_menu;
X    menu_len = 2;
X    menu_line = 0;
X    text_ypos = -1;
X    text_xpos = -1;
X    text_pos = 0;
X    generate_text_length();
X    
X    return 0;
X}
X
X/* Show a message in a menu.
X */
Xint
Xshow_mesg(mesg, func)
X  char *mesg;
X  void (*func)();
X{
X    /* set up the menu for display */
X
X    mesg_menu[0].item = mesg;
X    mesg_menu[0].func = func;
X    mesg_menu[0].key = ' ';
X
X    return show_menu(mesg_menu, 1);
X}
X
Xint
Xshow_main_menu()
X{
X    static int main_items = 0;
X
X    if(main_items == 0)
X    {
X	while(main_menu[main_items].key != '\0')
X	    main_items++;
X    }
X    return show_menu(main_menu, main_items);
X}
X
Xint
Xshow_option_menu()
X{
X    register int i = 0;
X
X    option_menu[i].item = "Options Menu";
X    option_menu[i].func = NULL;
X    option_menu[i].key = ' ';
X    i++;
X
X    option_menu[i].item = "";
X    option_menu[i].func = NULL;
X    option_menu[i].key = ' ';
X    i++;
X
X    if(def_flags & FL_SCROLL)
X	option_menu[i].item = "turn scrolling off";
X    else
X	option_menu[i].item = "turn scrolling on";
X    option_menu[i].func = option_menu_sel;
X    option_menu[i].key = 's';
X    i++;
X
X    if(def_flags & FL_WRAP)
X	option_menu[i].item = "turn word-wrap off";
X    else
X	option_menu[i].item = "turn word-wrap on";
X    option_menu[i].func = option_menu_sel;
X    option_menu[i].key = 'w';
X    i++;
X
X    if(def_flags & FL_IMPORT)
X	option_menu[i].item = "turn auto-import off";
X    else
X	option_menu[i].item = "turn auto-import on";
X    option_menu[i].func = option_menu_sel;
X    option_menu[i].key = 'i';
X    i++;
X
X    if(def_flags & FL_INVITE)
X	option_menu[i].item = "turn auto-invite off";
X    else
X	option_menu[i].item = "turn auto-invite on";
X    option_menu[i].func = option_menu_sel;
X    option_menu[i].key = 'v';
X    i++;
X
X    if(def_flags & FL_RING)
X	option_menu[i].item = "turn auto-rering off";
X    else
X	option_menu[i].item = "turn auto-rering on";
X    option_menu[i].func = option_menu_sel;
X    option_menu[i].key = 'r';
X    i++;
X
X    return show_menu(option_menu, i);
X}
X
Xint
Xshow_user_menu(title, func)
X  char *title;
X  void (*func)();
X{
X    register int i;
X    register yuser *u;
X
X    user_menu[0].item = title;
X    user_menu[0].func = func;
X    user_menu[0].key = ' ';
X
X    user_menu[1].item = "";
X    user_menu[1].func = NULL;
X    user_menu[1].key = ' ';
X
X    for(i = 2, u = user_list; u != NULL && i < MAXUMENU; u = u->unext)
X	if(u != me)
X	{
X	    if(u->key != '\0')
X	    {
X		strcpy(user_buf[i], u->full_name);
X		user_menu[i].item = user_buf[i];
X		user_menu[i].func = user_menu_sel;
X		user_menu[i].key = u->key;
X		i++;
X	    }
X	}
X    
X    if(i > 2)
X	return show_menu(user_menu, i);
X    kill_menu();
X    return -1;
X}
X
Xint
Xshow_user_list()
X{
X    register int i;
X    register yuser *u;
X    static char name_buf[25], stat_buf[25];
X
X    i = 0;
X
X    user_menu[i].item = "User List";
X    user_menu[i].func = NULL;
X    user_menu[i].key = ' ';
X    i++;
X
X    user_menu[i].item = "Name            Winsize [My_Size] Software       ";
X    user_menu[i].func = NULL;
X    user_menu[i].key = ' ';
X    i++;
X
X    user_menu[i].item = "";
X    user_menu[i].func = NULL;
X    user_menu[i].key = ' ';
X    i++;
X
X    for(u = connect_list; u && i < MAXUMENU; u = u->next)
X	if(u != me)
X	{
X	    if(u->remote.vmajor > 2)
X		sprintf(stat_buf, "YTalk V%d.%d",
X		    u->remote.vmajor, u->remote.vminor);
X	    else if(u->remote.vmajor == 2)
X		sprintf(stat_buf, "YTalk V2.?");
X	    else
X		sprintf(stat_buf, "UNIX Talk");
X	    pad_str(u->full_name, 15, name_buf);
X	    pad_str(stat_buf, 15, stat_buf);
X	    sprintf(user_buf[i], "%s %3.3dx%3.3d [%3.3dx%3.3d] %s",
X		name_buf,
X		u->remote.cols, u->remote.rows,
X		u->remote.my_cols, u->remote.my_rows,
X		stat_buf);
X
X	    user_menu[i].item = user_buf[i];
X	    user_menu[i].func = NULL;
X	    user_menu[i].key = ' ';
X	    i++;
X	}
X
X    for(u = wait_list; u && i < MAXUMENU; u = u->next)
X    {
X	pad_str(u->full_name, 15, name_buf);
X	pad_str("<unconnected>", 15, stat_buf);
X	sprintf(user_buf[i], "%s                   %s",
X	    name_buf,
X	    stat_buf);
X
X	user_menu[i].item = user_buf[i];
X	user_menu[i].func = NULL;
X	user_menu[i].key = ' ';
X	i++;
X    }
X    
X    return show_menu(user_menu, i);
X}
X
Xint
Xshow_error_menu(str1, str2)
X  char *str1, *str2;
X{
X    register int i;
X
X    for(i = 0; error_menu[i].key != '\0'; i++)
X	if(error_menu[i].item == NULL)
X	{
X	    strncpy(err_str[got_error], str1, MAXERR);
X	    err_str[got_error][MAXERR-1] = '\0';
X	    error_menu[i++].item = err_str[got_error++];
X
X	    strncpy(err_str[got_error], str2, MAXERR);
X	    err_str[got_error][MAXERR-1] = '\0';
X	    error_menu[i++].item = err_str[got_error++];
X
X	    return show_menu(error_menu, i);
X	}
X    return 0;
X}
X
X/* Prompt user for yes/no response.  Return the response.  It is
X * necessary for this function to hang until an answer is received.
X */
Xint
Xyes_no(prompt)
X  char *prompt;
X{
X    int out = 0;
X
X    yes_no_menu[0].func = NULL;
X    yes_no_menu[0].key = ' ';
X
X    /* show the menu and call input_loop() */
X
X    do {
X	yes_no_menu[0].item = prompt;
X	menu_ptr = yes_no_menu;
X	update_menu();
X	input_loop();
X	if(menu_ptr != yes_no_menu || yes_no_menu[0].item != prompt)
X	{
X	    /* somebody pre-empted us */
X	    kill_menu();
X	    io_len = 0;
X	}
X	for(; io_len > 0; io_len--, io_ptr++)
X	{
X	    if(*io_ptr == 'y' || *io_ptr == 'Y')
X	    {
X		out = 'y';
X		break;
X	    }
X	    if(*io_ptr == 'n' || *io_ptr == 'N' || *io_ptr == 27)
X	    {
X		out = 'n';
X		break;
X	    }
X	}
X    } while(out == 0);
X
X    kill_menu();
X    io_len = 0;
X    return out;
X}
X
Xvoid
Xupdate_user_menu()
X{
X    if(menu_ptr == user_menu)
X    {
X	redraw_term(me, 0);
X	if(user_menu[0].func)	/* it's a user menu */
X	    (void)show_user_menu(user_menu[0].item, user_menu[0].func);
X	else	/* it's a user status list */
X	    (void)show_user_list();
X	update_menu();
X    }
X}
END_OF_FILE
if test 18501 -ne `wc -c <'menu.c'`; then
    echo shar: \"'menu.c'\" unpacked with wrong size!
fi
# end of 'menu.c'
fi
if test -f 'exec.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'exec.c'\"
else
echo shar: Extracting \"'exec.c'\" \(4308 characters\)
sed "s/^X//" >'exec.c' <<'END_OF_FILE'
X/* exec.c -- run a command inside a window */
X
X/*			   NOTICE
X *
X * Copyright (c) 1990,1992,1993 Britt Yenne.  All rights reserved.
X * 
X * This software is provided AS-IS.  The author gives no warranty,
X * real or assumed, and takes no responsibility whatsoever for any 
X * use or misuse of this software, or any damage created by its use
X * or misuse.
X * 
X * This software may be freely copied and distributed provided that
X * no part of this NOTICE is deleted or edited in any manner.
X * 
X */
X
X/* Mail comments or questions to ytalk@austin.eds.com */
X
X#include "header.h"
X#include <fcntl.h>
X#include <signal.h>
X#include <sys/wait.h>
X#ifdef USE_SGTTY
X# include <sys/ioctl.h>
X# ifdef hpux
X#  include <sys/bsdtty.h>
X#  include <sgtty.h>
X# endif
X#endif
X
Xint running_process = 0;	/* flag: is process running? */
Xstatic int pid;			/* currently executing process id */
Xstatic int pfd;			/* currently executing process fd */
Xstatic int prows, pcols;	/* saved rows, cols */
X
X/* ---- local functions ---- */
X
X#ifdef USE_SGTTY
Xstatic int
Xsetsid()
X{
X    register int fd;
X
X    if((fd = open("/dev/tty", O_RDWR)) >= 0)
X    {
X	ioctl(fd, TIOCNOTTY);
X	close(fd);
X    }
X    return fd;
X}
X#endif
X
Xstatic int
Xgetpty(name)
X  char *name;
X{
X    register int pty, tty;
X
X    strcpy(name, "/dev/ptyp0");
X    while(access(name, 0) == 0)
X    {
X	if((pty = open(name, O_RDWR)) >= 0)
X	{
X	    name[5] = 't';
X	    if((tty = open(name, O_RDWR)) >= 0)
X	    {
X		close(tty);
X		return pty;
X	    }
X	    name[5] = 'p';
X	    close(pty);
X	}
X
X	/* get next pty name */
X
X	if(name[9] == 'f')
X	{
X	    name[8]++;
X	    name[9] = '0';
X	}
X	else if(name[9] == '9')
X	    name[9] = 'a';
X	else
X	    name[9]++;
X    }
X    errno = ENOENT;
X    return -1;
X}
X
Xstatic void
Xexec_input(fd)
X  int fd;
X{
X    register int rc;
X    static ychar buf[MAXBUF];
X
X    if((rc = read(fd, buf, MAXBUF)) <= 0)
X    {
X	kill_exec();
X	errno = 0;
X	show_error("command shell terminated");
X	return;
X    }
X    show_input(me, buf, rc);
X    send_users(buf, rc);
X}
X
Xstatic void
Xcalculate_size(rows, cols)
X  int *rows, *cols;
X{
X    register yuser *u;
X
X    *rows = me->t_rows;
X    *cols = me->t_cols;
X
X    for(u = connect_list; u; u = u->next)
X	if(u->remote.vmajor > 2)
X	{
X	    if(u->remote.my_rows > 1 && u->remote.my_rows < *rows)
X		*rows = u->remote.my_rows;
X	    if(u->remote.my_cols > 1 && u->remote.my_cols < *cols)
X		*cols = u->remote.my_cols;
X	}
X}
X
X/* ---- global functions ---- */
X
X/* Execute a command inside my window.  If command is NULL, then execute
X * a shell.
X */
Xvoid
Xexecute(command)
X  char *command;
X{
X    int fd;
X    char name[20], *shell;
X
X    if(me->flags & FL_LOCKED)
X    {
X	errno = 0;
X	show_error("alternate mode already running");
X	return;
X    }
X    if((fd = getpty(name)) < 0)
X    {
X	msg_term(me, "cannot get pseudo terminal");
X	return;
X    }
X    if((shell = getenv("SHELL")) == NULL)
X	shell = "/bin/sh";
X    calculate_size(&prows, &pcols);
X    if((pid = fork()) == 0)
X    {
X	close_all();
X        if(setsid() < 0)
X            exit(-1);
X        if((fd = open(name, O_RDWR)) < 0)
X            exit(-1);
X        dup2(fd, 0);
X        dup2(fd, 1);
X        dup2(fd, 2);
X
X	/* set terminal characteristics */
X
X	set_terminal_flags(fd);
X	set_terminal_size(fd, prows, pcols);
X#ifndef NeXT
X	putenv("TERM=vt100");
X#endif
X
X	/* execute the command */
X
X	if(command)
X	    execl(shell, shell, "-c", command, NULL);
X	else
X	    execl(shell, shell, NULL);
X	perror("execl");
X	(void)exit(-1);
X    }
X    if(pid < 0)
X    {
X	show_error("fork() failed");
X	return;
X    }
X    set_win_region(me, prows, pcols);
X    sleep(1);
X    pfd = fd;
X    running_process = 1;
X    lock_flags(FL_RAW | FL_SCROLL);
X    add_fd(fd, exec_input);
X}
X
X/* Send input to the command shell.
X */
Xvoid
Xupdate_exec()
X{
X    (void)write(pfd, io_ptr, io_len);
X    io_len = 0;
X}
X
X/* Kill the command shell.
X */
Xvoid
Xkill_exec()
X{
X    if(!running_process)
X	return;
X    remove_fd(pfd);
X    close(pfd);
X    running_process = 0;
X    unlock_flags();
X    end_win_region(me);
X}
X
X/* Send a SIGWINCH to the process.
X */
Xvoid
Xwinch_exec()
X{
X    int rows, cols;
X
X    if(!running_process)
X	return;
X    calculate_size(&rows, &cols);
X    if(rows == prows && cols == pcols)
X	return;
X    prows = rows;
X    pcols = cols;
X    set_terminal_size(pfd, prows, pcols);
X    set_win_region(me, prows, pcols);
X#ifdef SIGWINCH
X    kill(pid, SIGWINCH);
X#endif
X}
END_OF_FILE
if test 4308 -ne `wc -c <'exec.c'`; then
    echo shar: \"'exec.c'\" unpacked with wrong size!
fi
# end of 'exec.c'
fi
if test -f 'rc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rc.c'\"
else
echo shar: Extracting \"'rc.c'\" \(3857 characters\)
sed "s/^X//" >'rc.c' <<'END_OF_FILE'
X/* rc.c -- read the .ytalkrc file */
X
X/*			   NOTICE
X *
X * Copyright (c) 1990,1992,1993 Britt Yenne.  All rights reserved.
X * 
X * This software is provided AS-IS.  The author gives no warranty,
X * real or assumed, and takes no responsibility whatsoever for any 
X * use or misuse of this software, or any damage created by its use
X * or misuse.
X * 
X * This software may be freely copied and distributed provided that
X * no part of this NOTICE is deleted or edited in any manner.
X * 
X */
X
X/* Mail comments or questions to ytalk@austin.eds.com */
X
X#include "header.h"
X
X#define IS_WHITE(c)	((c)==' ' || (c)=='\t' || (c)=='\n')
X
X/* ---- local functions ---- */
X
Xstatic char *
Xget_word(p)
X  char **p;
X{
X    register char *c, *out;
X
X    c = *p;
X    while(IS_WHITE(*c))
X	c++;
X    if(*c == '\0')
X	return NULL;
X    out = c;
X    while(*c && !IS_WHITE(*c))
X	c++;
X    if(*c)
X	*(c++) = '\0';
X    *p = c;
X    return out;
X}
X
Xstatic int
Xset_option(opt, value)
X  char *opt, *value;
X{
X    u_long mask = 0L;
X    int set_it;
X
X    if(strcmp(value, "true") == 0 || strcmp(value, "on") == 0)
X	set_it = 1;
X    else if(strcmp(value, "false") == 0 || strcmp(value, "off") == 0)
X	set_it = 0;
X    else
X	return -1;
X    
X    if(strcmp(opt, "scroll") == 0
X    || strcmp(opt, "scrolling") == 0
X    || strcmp(opt, "sc") == 0)
X	mask |= FL_SCROLL;
X
X    if(strcmp(opt, "wrap") == 0
X    || strcmp(opt, "word-wrap") == 0
X    || strcmp(opt, "wordwrap") == 0
X    || strcmp(opt, "wrapping") == 0
X    || strcmp(opt, "ww") == 0)
X	mask |= FL_WRAP;
X
X    if(strcmp(opt, "import") == 0
X    || strcmp(opt, "auto-import") == 0
X    || strcmp(opt, "autoimport") == 0
X    || strcmp(opt, "importing") == 0
X    || strcmp(opt, "aip") == 0
X    || strcmp(opt, "ai") == 0)
X	mask |= FL_IMPORT;
X
X    if(strcmp(opt, "invite") == 0
X    || strcmp(opt, "auto-invite") == 0
X    || strcmp(opt, "autoinvite") == 0
X    || strcmp(opt, "aiv") == 0
X    || strcmp(opt, "av") == 0)
X	mask |= FL_IMPORT;
X
X    if(strcmp(opt, "ring") == 0
X    || strcmp(opt, "auto-ring") == 0
X    || strcmp(opt, "auto-rering") == 0
X    || strcmp(opt, "autoring") == 0
X    || strcmp(opt, "autorering") == 0
X    || strcmp(opt, "ar") == 0)
X	mask |= FL_RING;
X
X    if(strcmp(opt, "xwin") == 0
X    || strcmp(opt, "xwindows") == 0
X    || strcmp(opt, "XWindows") == 0
X    || strcmp(opt, "Xwin") == 0
X    || strcmp(opt, "x") == 0
X    || strcmp(opt, "X") == 0)
X	mask |= FL_XWIN;
X    
X    if(!mask)
X	return -1;
X
X    if(set_it)
X	def_flags |= mask;
X    else
X	def_flags &= ~mask;
X
X    return 0;
X}
X
X/* ---- global functions ---- */
X
Xvoid
Xread_ytalkrc()
X{
X    FILE *fp;
X    char *buf, *ptr;
X    char *w, *arg1, *arg2, *arg3;
X    int line_no, errline;
X    yuser *u;
X
X    if((w = getenv("HOME")) == NULL)
X	return;
X    buf = get_mem(BUFSIZ);
X    sprintf(buf, "%s/.ytalkrc", w);
X    if((fp = fopen(buf, "r")) == NULL)
X    {
X	if(errno != ENOENT)
X	    show_error(buf);
X	free(buf);
X	return;
X    }
X
X    line_no = errline = 0;
X    while(fgets(buf, BUFSIZ, fp) != NULL)
X    {
X	line_no++;
X	ptr = buf;
X	w = get_word(&ptr);
X	if(w == NULL || *w == '#')
X	    continue;
X	
X	if(strcmp(w, "readdress") == 0)
X	{
X	    arg1 = get_word(&ptr);
X	    arg2 = get_word(&ptr);
X	    arg3 = get_word(&ptr);
X	    if(arg3 == NULL)
X	    {
X		errline = line_no;
X		break;
X	    }
X	    readdress_host(arg1, arg2, arg3);
X	}
X	else if(strcmp(w, "set") == 0 || strcmp(w, "turn") == 0)
X	{
X	    arg1 = get_word(&ptr);
X	    arg2 = get_word(&ptr);
X	    if(arg2 == NULL)
X	    {
X		errline = line_no;
X		break;
X	    }
X	    if(set_option(arg1, arg2) < 0)
X	    {
X		errline = line_no;
X		break;
X	    }
X	}
X	else
X	{
X	    errline = line_no;
X	    break;
X	}
X    }
X    if(errline)
X    {
X	sprintf(errstr, ".ytalkrc: syntax error at line %d", errline);
X	errno = 0;
X	show_error(errstr);
X    }
X
X    free(buf);
X    fclose(fp);
X
X    for(u = user_list; u != NULL; u = u->unext)
X	if(!(u->flags & FL_LOCKED))
X	    u->flags = def_flags;
X}
END_OF_FILE
if test 3857 -ne `wc -c <'rc.c'`; then
    echo shar: \"'rc.c'\" unpacked with wrong size!
fi
# end of 'rc.c'
fi
if test -f 'socket.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'socket.c'\"
else
echo shar: Extracting \"'socket.c'\" \(21959 characters\)
sed "s/^X//" >'socket.c' <<'END_OF_FILE'
X/* socket.c - socket functions */
X
X/*			   NOTICE
X *
X * Copyright (c) 1990,1992,1993 Britt Yenne.  All rights reserved.
X * 
X * This software is provided AS-IS.  The author gives no warranty,
X * real or assumed, and takes no responsibility whatsoever for any 
X * use or misuse of this software, or any damage created by its use
X * or misuse.
X * 
X * This software may be freely copied and distributed provided that
X * no part of this NOTICE is deleted or edited in any manner.
X * 
X */
X
X/* Mail comments or questions to ytalk@austin.eds.com */
X
X#include "header.h"
X#include "menu.h"
X#include "socket.h"
X#include <sys/time.h>
X#ifdef _AIX
X# include <sys/select.h>
X#endif
X
Xstruct _talkd talkd[MAXDAEMON+1];
Xint daemons = 0;
X
Xstatic int otalk, ntalk;		/* daemon numbers */
Xstatic CTL_MSG omsg;			/* old talk message */
Xstatic CTL_RESPONSE orsp;		/* old talk response */
Xstatic CTL_MSG42 nmsg;			/* new talk message */
Xstatic CTL_RESPONSE42 nrsp;		/* new talk response */
X
Xstatic int autofd = -1;			/* auto invite socket fd */
Xstatic struct sockaddr_in autosock;	/* auto invite socket */
Xstatic long autoid[MAXDAEMON+1];	/* auto invite seq numbers */
Xstatic u_long announce_id = 0;		/* announce sequence id */
Xstatic readdr *readdr_list = NULL;	/* list of re-addresses */
X
X#define IN_ADDR(s)	((s).sin_addr.s_addr)
X#define IN_PORT(s)	((s).sin_port)
X#define SOCK_EQUAL(s,c)	(IN_PORT(s) == IN_PORT(c) && IN_ADDR(s) == IN_ADDR(c))
X
X/* ---- local functions ---- */
X
X/* Create a datagram socket.
X */
Xstatic int
Xinit_dgram(sock)
X  struct sockaddr_in *sock;
X{
X    int fd, socklen;
X
X    sock->sin_family = AF_INET;
X    IN_ADDR(*sock) = INADDR_ANY;
X    IN_PORT(*sock) = 0;
X    if((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
X    {
X	show_error("init_dgram: socket() failed");
X	bail(YTE_ERROR);
X    }
X    if(bind(fd, (struct sockaddr *)sock, sizeof(struct sockaddr_in)) != 0)
X    {
X	close(fd);
X	show_error("init_dgram: bind() failed");
X	bail(YTE_ERROR);
X    }
X    socklen = sizeof(struct sockaddr_in);
X    if(getsockname(fd, (struct sockaddr *)sock, &socklen) < 0)
X    {
X	close(fd);
X	show_error("init_dgram: getsockname() failed");
X	bail(YTE_ERROR);
X    }
X    IN_ADDR(*sock) = me->host_addr;
X    return fd;
X}
X
X/* Initialize a new daemon structure.
X */
Xstatic int
Xinit_daemon(name, port, mptr, mlen, rptr, rlen)
X  char *name;
X  short port;
X  yaddr mptr, rptr;
X  int mlen, rlen;
X{
X    struct servent *serv;
X    int d;
X
X    if(daemons >= MAXDAEMON)
X    {
X	show_error("init_daemon: too many daemons");
X	bail(YTE_ERROR);
X    }
X    d = ++daemons;	/* daemon number zero is not defined */
X
X    if((serv = getservbyname(name, "udp")) != NULL)
X	talkd[d].port = serv->s_port;
X    else
X	talkd[d].port = port;
X    
X    talkd[d].fd = init_dgram(&(talkd[d].sock));
X    talkd[d].mptr = mptr;
X    talkd[d].mlen = mlen;
X    talkd[d].rptr = rptr;
X    talkd[d].rlen = rlen;
X    return d;
X}
X
Xstatic void
Xread_autoport(fd)
X  int fd;
X{
X    int socklen;
X    static v2_pack pack;
X    static char estr[V2_NAMELEN + V2_HOSTLEN + 20];
X    static struct sockaddr_in temp;
X
X    /* accept the connection */
X
X    socklen = sizeof(struct sockaddr_in);
X    if((fd = accept(autofd, (struct sockaddr *) &temp, &socklen)) == -1)
X    {
X	show_error("read_autoport: accept() failed");
X	return;
X    }
X
X    /* The autoport socket just uses the old Ytalk version 2.?
X     * packet.
X     */
X    errno = 0;
X    if(full_read(fd, &pack, V2_PACKLEN) < 0 || pack.code != V2_AUTO)
X    {
X	show_error("read_autoport: unknown auto-invite connection");
X	close(fd);
X	return;
X    }
X    close(fd);
X    if(!(def_flags & FL_INVITE))
X    {
X	sprintf(estr, "Talk to %s@%s?", pack.name, pack.host);
X	if(yes_no(estr) == 'n')
X	    return;
X    }
X    sprintf(estr, "%s@%s", pack.name, pack.host);
X    invite(estr, 1);	/* we should be expected */
X}
X
X/* Create and initialize the auto-invitation socket.
X */
Xstatic void
Xinit_autoport()
X{
X    int socklen;
X
X    autosock.sin_family = AF_INET;
X    IN_ADDR(autosock) = INADDR_ANY;
X    IN_PORT(autosock) = 0;
X    if((autofd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
X    {
X	show_error("init_autoport: socket() failed");
X	return;
X    }
X    if(bind(autofd, (struct sockaddr *)&autosock,
X	sizeof(struct sockaddr_in)) < 0)
X    {
X	close(autofd);
X	autofd = -1;
X	show_error("init_autoport: bind() failed");
X	return;
X    }
X    socklen = sizeof(struct sockaddr_in);
X    if(getsockname(autofd, (struct sockaddr *)&autosock, &socklen) < 0)
X    {
X	close(autofd);
X	autofd = -1;
X	show_error("init_autoport: getsockname() failed");
X	return;
X    }
X    IN_ADDR(autosock) = me->host_addr;
X    if(listen(autofd, 5) < 0)
X    {
X	close(autofd);
X	autofd = -1;
X	show_error("init_autoport: listen() failed");
X	return;
X    }
X    (void)memset(autoid, 0, (MAXDAEMON + 1) * sizeof(long));
X    add_fd(autofd, read_autoport);
X}
X
X/* Fill the socket address field with the appropriate return address for
X * the host I'm sending to.
X */
Xstatic void
Xplace_my_address(sock, addr)
X  struct sockaddr_in *sock;
X  register u_long addr;
X{
X    register readdr *r;
X
X    for(r = readdr_list; r != NULL; r = r->next)
X	if((addr & r->mask) == r->addr)
X	{
X	    addr = (r->id_addr & r->id_mask) |
X		   (me->host_addr & (~(r->id_mask)));
X	    IN_ADDR(*sock) = addr;
X	    break;
X	}
X    if(r == NULL)
X	IN_ADDR(*sock) = me->host_addr;
X    sock->sin_family = htons(AF_INET);
X}
X
X/* sendit() sends the completed message to the talk daemon at the given
X * hostname, then reads a response packet.
X */
Xstatic int
Xsendit(addr, d)
X  u_long addr;	/* host internet address */
X  int d;	/* daemon number */
X{
X    int n;
X    struct sockaddr_in daemon;
X    struct timeval tv;
X    char *rtype, *mtype;
X    fd_set sel;
X
X    /* set up the appropriate message structure */
X
X    if(d == ntalk)
X    {
X	nmsg.vers = TALK_VERSION;
X	place_my_address(&(nmsg.ctl_addr), addr);
X	mtype = &(nmsg.type);
X	rtype = &(nrsp.type);
X    }
X    else if(d == otalk)
X    {
X	omsg.type = nmsg.type;
X	omsg.addr = nmsg.addr;
X	omsg.id_num = nmsg.id_num;
X	omsg.pid = nmsg.pid;
X	strncpy(omsg.l_name, nmsg.l_name, NAME_SIZE);
X	strncpy(omsg.r_name, nmsg.r_name, NAME_SIZE);
X	strncpy(omsg.r_tty, nmsg.r_tty, TTY_SIZE);
X	place_my_address(&(omsg.ctl_addr), addr);
X	mtype = &(omsg.type);
X	rtype = &(orsp.type);
X    }
X    else
X    {
X	sprintf(errstr, "Unkown daemon type: %d", d);
X	show_error(errstr);
X	return -1;
X    }
X
X    /* set up a sockaddr_in for the daemon we're sending to */
X
X    daemon.sin_family = AF_INET;
X    IN_ADDR(daemon) = addr;
X    IN_PORT(daemon) = talkd[d].port;
X
X    /* flush any lingering input */
X
X    FD_ZERO(&sel);
X    for(;;)
X    {
X	tv.tv_sec = 0L;
X	tv.tv_usec = 0L;
X	FD_SET(talkd[d].fd, &sel);
X	if((n = select(talkd[d].fd + 1, &sel, 0, 0, &tv)) < 0)
X	{
X	    show_error("sendit: flush select() failed");
X	    return -1;
X	}
X	if(n <= 0)
X	    break;
X	if(recv(talkd[d].fd, talkd[d].rptr, talkd[d].rlen, 0) < 0)
X	{
X	    show_error("sendit: flush recv() failed");
X	    return -1;
X	}
X    }
X
X    /* Now we need to send the actual packet.  Due to unreliability of
X     * DGRAM sockets, we must resend the packet until we get a response
X     * from the server.  Geez... two different daemons, both on unreliable
X     * sockets, and maybe even different daemons on different machines.
X     * Is *nothing* reliable anymore???
X     */
X    do
X    {
X    	do
X	{
X	    n = sendto(talkd[d].fd, talkd[d].mptr, talkd[d].mlen,
X		0, (struct sockaddr *) &daemon, sizeof(daemon));
X	    if(n != talkd[d].mlen)
X	    {
X		show_error("sendit: sendto() failed");
X		return -1;
X	    }
X
X	    tv.tv_sec = 5L;
X	    tv.tv_usec = 0L;
X	    FD_SET(talkd[d].fd, &sel);
X	    if((n = select(talkd[d].fd + 1, &sel, 0, 0, &tv)) < 0)
X	    {
X		show_error("sendit: first select() failed");
X		return -1;
X	    }
X 	} while (n <= 0);	/* ie: until we receive a reply */
X
X    	do
X	{
X	    n = recv(talkd[d].fd, talkd[d].rptr, talkd[d].rlen, 0);
X	    if(n < 0)
X	    {
X		show_error("sendit: recv() failed");
X		return -1;
X	    }
X
X	    if(*rtype != *mtype)
X		tv.tv_sec = 5L;
X	    else
X		tv.tv_sec = 0L;
X	    tv.tv_usec = 0L;
X	    FD_SET(talkd[d].fd, &sel);
X	    if((n = select(talkd[d].fd + 1, &sel, 0, 0, &tv)) < 0)
X	    {
X		show_error("sendit: second select() failed");
X		return -1;
X	    }
X    	} while(n > 0 && *rtype != *mtype);
X    } while(*rtype != *mtype);
X
X    /* WHEW */
X
X    /* Just because a person is a SYSADMIN doesn't necessarily mean he/she
X     * knows everything about installing software.  In fact, many have been
X     * known to install the talk daemon without setting the option required
X     * to pad out the structures so that "long"s are on four-byte boundaries
X     * on machines where "long"s can be on two-byte boundaries.  This "bug"
X     * cost me about four hours of debugging to discover, so I'm not happy
X     * right now.  Anyway, here's a quick hack to fix this problem.
X     */
X    if(d == otalk && nrsp.type == LOOK_UP && nrsp.answer == 0)
X    {
X	u_short t;
X	(void)memcpy((char *)&t, ((char *)&orsp.addr.sin_family)-2, sizeof(t));
X	if(ntohs(t) == AF_INET && ntohs(orsp.addr.sin_family) != AF_INET)
X	{
X	    char *c;
X	    c = ((char *)&orsp) + sizeof(orsp) - 1;
X	    for(; c >= (char *)&orsp.id_num; c--)
X		*c = *(c-2);
X	}
X    }
X
X    /* Fill in the new talk response structure if we just read an
X     * old one.
X     */
X    if(d == otalk)
X    {
X	nrsp.type = orsp.type;
X	nrsp.answer = orsp.answer;
X	nrsp.id_num = orsp.id_num;
X	nrsp.addr = orsp.addr;
X    }
X
X    return 0;
X}
X
X/* find_daemon() locates the talk daemon(s) on a machine and determines
X * what version(s) of the daemon are running.
X */
Xstatic int
Xfind_daemon(addr)
X  u_long addr;
X{
X    register hostinfo *h;
X    register int n, i, d;
X    CTL_MSG m1;
X    CTL_MSG42 m2;
X    struct sockaddr_in daemon;
X    struct timeval tv;
X    int sel, out;
X    static hostinfo *host_head = NULL;
X
X    /* If we've already used this host, look it up instead of blitting to
X     * the daemons again...
X     */
X    for(h = host_head; h; h = h->next)
X	if(h->host_addr == addr)
X	    return h->dtype;
X
X    daemon.sin_family = AF_INET;
X    IN_ADDR(daemon) = addr;
X
X    m1 = omsg;
X    m2 = nmsg;
X    m1.ctl_addr = talkd[otalk].sock;
X    place_my_address(&(m1.ctl_addr), addr);
X    m2.ctl_addr = talkd[ntalk].sock;
X    place_my_address(&(m2.ctl_addr), addr);
X    m1.type = m2.type = LOOK_UP;
X    m1.id_num = m2.id_num = htonl(0);
X    m1.r_tty[0] = m2.r_tty[0] = '\0';
X    strcpy(m1.r_name, "ytalk");
X    strcpy(m2.r_name, "ytalk");
X    m1.addr.sin_family = m2.addr.sin_family = htons(AF_INET);
X
X    out = 0;
X    for(i = 0; i < 5; i++)
X    {
X	IN_PORT(daemon) = talkd[ntalk].port;
X	n = sendto(talkd[ntalk].fd, &m2, sizeof(m2),
X	    0, (struct sockaddr *) &daemon, sizeof(daemon));
X	if(n != sizeof(m2))
X	    show_error("Warning: cannot write to new talk daemon");
X
X	IN_PORT(daemon) = talkd[otalk].port;
X	n = sendto(talkd[otalk].fd, &m1, sizeof(m1),
X	    0, (struct sockaddr *) &daemon, sizeof(daemon));
X	if(n != sizeof(m1))
X	    show_error("Warning: cannot write to old talk daemon");
X
X	tv.tv_sec = 4L;
X	tv.tv_usec = 0L;
X	sel = (1 << talkd[ntalk].fd) | (1 << talkd[otalk].fd);
X	if((n = select(32, &sel, 0, 0, &tv)) < 0)
X	{
X	    show_error("find_daemon: first select() failed");
X	    continue;
X	}
X	if(n == 0)
X	    continue;
X
X	do
X	{
X	    for(d = 1; d <= daemons; d++)
X		if(sel & (1 << talkd[d].fd))
X		{
X		    out |= (1 << d);
X		    if(recv(talkd[d].fd, errstr, talkd[d].rlen, 0) < 0)
X			show_error("find_daemon: recv() failed");
X		}
X
X	    tv.tv_sec = 0L;
X	    tv.tv_usec = 500000L;	/* give the other daemon a chance */
X	    sel = (1 << talkd[ntalk].fd) | (1 << talkd[otalk].fd);
X	    if((n = select(32, &sel, 0, 0, &tv)) < 0)
X		show_error("find_daemon: second select() failed");
X	} while(n > 0);
X
X	h = (hostinfo *)get_mem(sizeof(hostinfo));
X	h->next = host_head;
X	host_head = h;
X	h->host_addr = addr;
X	h->dtype = out;
X	return out;
X    }
X    sprintf(errstr, "No talk daemon on %s", host_name(addr));
X    show_error(errstr);
X    return 0;
X}
X
Xstatic u_long
Xmake_net_mask(addr)
X  u_long addr;
X{
X    if(addr & (u_long)0xff)
X	return (u_long)0xffffffff;
X    if(addr & (u_long)0xffff)
X	return (u_long)0xffffff00;
X    if(addr & (u_long)0xffffff)
X	return (u_long)0xffff0000;
X    if(addr)
X	return (u_long)0xff000000;
X    return (u_long)0;
X}
X
X/* ---- global functions ---- */
X
X/* Initialize sockets and message parameters.
X */
Xvoid
Xinit_socket()
X{
X    /* init daemons in order of preference */
X
X    ntalk = init_daemon("ntalk", 518, &nmsg, sizeof(nmsg),
X	&nrsp, sizeof(nrsp));
X    otalk = init_daemon("talk", 517, &omsg, sizeof(omsg),
X	&orsp, sizeof(orsp));
X
X    strncpy(nmsg.l_name, me->user_name, NAME_SIZE);
X
X    omsg.ctl_addr = talkd[otalk].sock;
X    nmsg.ctl_addr = talkd[ntalk].sock;
X    nmsg.vers = TALK_VERSION;
X
X    (void)find_daemon(me->host_addr);
X    init_autoport();
X}
X
X/* Close every open descriptor.  This should only be used for a quick
X * exit... it does not gracefully shut systems down.
X */
Xvoid
Xclose_all()
X{
X    register yuser *u;
X    register int d;
X
X    for(u = user_list; u; u = u->unext)
X    {
X	if(u->fd > 0)
X	    close(u->fd);
X	if(u->output_fd > 0)
X	    close(u->output_fd);
X    }
X    if(autofd > 0)
X	close(autofd);
X    for(d = 1; d <= daemons; d++)
X	close(talkd[d].fd);
X}
X
X/* The following routines send a request across the DGRAM socket to the
X * talk daemons.
X */
X
X/* First, a quick and easy interface for the user sockets.
X */
Xint
Xsend_dgram(user, type)
X  yuser *user;
X  u_char type;
X{
X    u_long addr;
X    int d;
X
X    /* set up the message type and where to send it */
X
X    switch(type)
X    {
X	case LEAVE_INVITE:	/* leave an invite on my machine */
X	    addr = me->host_addr;
X	    nmsg.type = LEAVE_INVITE;
X	    nmsg.id_num = htonl(user->l_id);
X	    break;
X	case DELETE_INVITE:	/* delete my invite on my machine */
X	    addr = me->host_addr;
X	    nmsg.type = DELETE;
X	    nmsg.id_num = htonl(user->l_id);
X	    break;
X	case ANNOUNCE:		/* ring a user */
X	    addr = user->host_addr;
X	    nmsg.type = ANNOUNCE;
X	    announce_id += 5;	/* no guesswork here */
X	    nmsg.id_num = htonl(announce_id);
X	    break;
X	case LOOK_UP:		/* look up remote invitation */
X	    addr = user->host_addr;
X	    nmsg.type = LOOK_UP;
X	    nmsg.id_num = htonl(user->r_id);
X	    break;
X	case DELETE:		/* delete erroneous remote invitation */
X	    addr = user->host_addr;
X	    nmsg.type = DELETE;
X	    nmsg.id_num = htonl(user->r_id);
X	    break;
X	case AUTO_LOOK_UP:	/* look up remote auto-invitation */
X	    addr = user->host_addr;
X	    nmsg.type = LOOK_UP;
X	    nmsg.id_num = htonl(user->r_id);
X	    break;
X	case AUTO_DELETE:	/* delete erroneous remote auto-invitation */
X	    addr = user->host_addr;
X	    nmsg.type = DELETE;
X	    nmsg.id_num = htonl(user->r_id);
X	    break;
X	default:
X	    errno = 0;
X	    show_error("send_dgram: unknown type");
X	    return -1;
X    }
X
X    /* find a common daemon, if possible */
X
X    if(user->daemon != 0)
X	d = user->daemon;
X    else
X    {
X	int dtype, d1, d2;
X
X	/* Find the daemon(s) their host supports.  If our two machines
X	 * support a daemon in common, use that one.  Else, normal UNIX
X	 * "talk" is already screwed to the wall, but YTalk will at least
X	 * work.
X	 */
X	d1 = find_daemon(user->host_addr);
X	d2 = find_daemon(me->host_addr);
X	dtype = d1 & d2;
X
X	if(d1 == 0 || d2 == 0)
X	    return -1;
X	if(dtype == 0)
X	{
X	    dtype = find_daemon(addr);
X	    for(d = 1; d <= daemons; d++)
X		if(dtype & (1<<d))
X		    break;
X	    if(d > daemons)
X		return -1;
X	}
X	else
X	{
X	    for(d = 1; d <= daemons; d++)
X		if(dtype & (1<<d))
X		{
X		    user->daemon = d;
X		    break;
X		}
X	    if(d > daemons)
X		return -1;
X	}
X    }
X
X    /* Each user has his own unique daemon id.  Why?  Tsch.  Why.
X     * Well, the talk daemons consider two users equivalent if their
X     * usernames and machine names match.  Hence, the daemons will not
X     * allow ytalk to talk with two different users with the same name
X     * on some machine.  By assigning unique process id's, we trick
X     * the daemons into thinking we're several different users trying
X     * to talk to the same person.  Sick?  Don't blame me.
X     */
X    nmsg.pid = htonl(user->d_id);
X    if(type == AUTO_LOOK_UP || type == AUTO_DELETE)
X    {
X	strcpy(nmsg.l_name, "+AUTO");	/* put on my mask... */
X	strncpy(nmsg.r_name, user->user_name, NAME_SIZE);
X	nmsg.r_tty[0] = '\0';
X    }
X    else
X    {
X	strncpy(nmsg.r_name, user->user_name, NAME_SIZE);
X	strncpy(nmsg.r_tty, user->tty_name, TTY_SIZE);
X    }
X    nmsg.addr = user->sock;
X    nmsg.addr.sin_family = htons(AF_INET);
X    if(sendit(addr, d) != 0)
X	return -2;
X
X    switch(type)
X    {
X	case LEAVE_INVITE:
X	    user->l_id = ntohl(nrsp.id_num);
X	    break;
X	case LOOK_UP:
X	    user->r_id = ntohl(nrsp.id_num);
X	    break;
X	case AUTO_LOOK_UP:
X	    strncpy(nmsg.l_name, me->user_name, NAME_SIZE);
X	    user->r_id = ntohl(nrsp.id_num);
X	    break;
X	case AUTO_DELETE:
X	    strncpy(nmsg.l_name, me->user_name, NAME_SIZE);
X	    break;
X    }
X    return nrsp.answer;
X}
X
X/* Next, an interface for the auto-invite socket.  The auto-invite socket
X * always sends to the caller's host, and always does just an invite.
X */
Xint
Xsend_auto(type)
X  u_char type;
X{
X    int dtype, d, rc;
X
X    if(autofd < 0)
X	return 0;
X    nmsg.type = type;
X    strcpy(nmsg.r_name, "+AUTO");
X    nmsg.r_tty[0] = '\0';
X    nmsg.addr = autosock;
X    nmsg.addr.sin_family = htons(AF_INET);
X
X    rc = 0;
X    dtype = find_daemon(me->host_addr);
X    for(d = daemons; d >= 1; d--)
X	if(dtype & (1<<d))
X	{
X	    nmsg.id_num = htonl(autoid[d]);
X	    nmsg.pid = htonl(1);
X	    if(sendit(me->host_addr, d) < 0)
X		rc = -1;
X	    else
X		autoid[d] = ntohl(nrsp.id_num);
X	}
X
X    if(rc)
X	return rc;
X    if(type == LEAVE_INVITE)
X	return 0;
X    return nrsp.answer;
X}
X
X/* Shut down the auto-invitation system.
X */
Xvoid
Xkill_auto()
X{
X    if(autofd < 0)
X	return;
X    (void)send_auto(DELETE);
X    remove_fd(autofd);
X    close(autofd);
X    autofd = -1;
X}
X
X/* Create a TCP socket for communication with other talk users.
X */
Xint
Xnewsock(user)
X  yuser *user;
X{
X    int socklen, fd;
X
X    user->sock.sin_family = AF_INET;
X    IN_ADDR(user->sock) = INADDR_ANY;
X    IN_PORT(user->sock) = 0;
X    if((fd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
X    {
X	show_error("newsock: socket() failed");
X	return -1;
X    }
X    if(bind(fd, (struct sockaddr *)&user->sock, sizeof(struct sockaddr_in)) < 0)
X    {
X	close(fd);
X	show_error("newsock: bind() failed");
X	return -1;
X    }
X    socklen = sizeof(struct sockaddr_in);
X    if(getsockname(fd, (struct sockaddr *)&user->sock, &socklen) < 0)
X    {
X	close(fd);
X	show_error("newsock: getsockname() failed");
X	return -1;
X    }
X    place_my_address(&(user->sock), user->host_addr);
X    if(listen(fd, 5) < 0)
X    {
X	close(fd);
X	show_error("newsock: listen() failed");
X	return -1;
X    }
X    user->fd = fd;
X    fd_to_user[user->fd] = user;
X    user->orig_sock = user->sock;
X    return 0;
X}
X
X/* Connect to another user's communication socket.
X */
Xint
Xconnect_to(user)
X  yuser *user;
X{
X    register yuser *u;
X    int socklen, fd;
X    struct sockaddr_in sock, orig_sock;
X
X    orig_sock = *(struct sockaddr_in *)&nrsp.addr;
X    orig_sock.sin_family = AF_INET;
X
X    /* it could be one of mine... */
X    for(u = user_list; u; u = u->unext)
X	if(SOCK_EQUAL(orig_sock, u->orig_sock))
X	    return -3;
X    if(SOCK_EQUAL(orig_sock, autosock))
X	return -3;
X
X    sock = orig_sock;
X    if((fd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
X    {
X	show_error("connect_to: socket() failed");
X	return -1;
X    }
X    if(connect(fd, (struct sockaddr *)&sock, sizeof(struct sockaddr_in)) < 0)
X    {
X	close(fd);
X	if(errno == ECONNREFUSED)
X	{
X	    errno = 0;
X	    return -2;
X	}
X	show_error("connect_to: connect() failed");
X	return -1;
X    }
X    socklen = sizeof(struct sockaddr_in);
X    if(getsockname(fd, (struct sockaddr *)&sock, &socklen) < 0)
X    {
X	close(fd);
X	show_error("connect_to: getsockname() failed");
X	return -1;
X    }
X    if(user)
X    {
X	user->sock = sock;
X	user->orig_sock = orig_sock;
X	user->fd = fd;
X	fd_to_user[user->fd] = user;
X    }
X    return fd;
X}
X
X/* Find a host's address.
X */
Xu_long
Xget_host_addr(hostname)
X  char *hostname;
X{
X    struct hostent *host;
X    u_long addr;
X    u_long inet_addr();
X
X    if((host = (struct hostent *) gethostbyname(hostname)) != NULL)
X    {
X	if(host->h_length != sizeof(addr))
X	{
X	    sprintf(errstr, "Bad IN addr: %s\n", hostname);
X	    show_error(errstr);
X	    return (u_long)-1;
X	}
X	(void)memcpy(&addr, host->h_addr, sizeof(addr));
X    }
X    else if((addr = inet_addr(hostname)) == (u_long)-1)
X	return (u_long)-1;
X    return addr;
X}
X
X/* Find a host name by host address.
X */
Xchar *
Xhost_name(addr)
X  u_long addr;
X{
X    struct hostent *host;
X    char *inet_ntoa();
X
X    if((host = gethostbyaddr((char *) &addr, sizeof(addr), AF_INET)) == NULL)
X    {
X	struct in_addr tmp;
X	tmp.s_addr = addr;
X	return inet_ntoa(tmp);
X    }
X    return host->h_name;
X}
X
X/* Re-address a given host ("from_id") to the given address or host
X * id ("to_id") when communicating with some other host id ("on_id").
X * This is useful especially over routers where "foo.com" is known
X * as the differently-addressed "bar.com" to host "xyzzy.com".
X */
Xvoid
Xreaddress_host(from_id, to_id, on_id)
X  char *from_id, *to_id, *on_id;
X{
X    register readdr *new;
X    u_long from_addr, to_addr, on_addr;
X    u_long from_mask, to_mask, on_mask;
X
X    if((from_addr = get_host_addr(from_id)) == (u_long)-1)
X    {
X	sprintf(errstr, "Unknown host: '%s'\n", from_id);
X	show_error(errstr);
X	return;
X    }
X    if((to_addr = get_host_addr(to_id)) == (u_long)-1)
X    {
X	sprintf(errstr, "Unknown host: '%s'\n", to_id);
X	show_error(errstr);
X	return;
X    }
X    if((on_addr = get_host_addr(on_id)) == (u_long)-1)
X    {
X	sprintf(errstr, "Unknown host: '%s'\n", on_id);
X	show_error(errstr);
X	return;
X    }
X    from_mask = make_net_mask(from_addr);
X    to_mask = make_net_mask(to_addr);
X    on_mask = make_net_mask(on_addr);
X    
X    if((from_addr & from_mask) != (me->host_addr & from_mask))
X	return;
X    if(from_addr == to_addr)
X	return;
X
X    new = (readdr *)get_mem(sizeof(readdr));
X    new->addr = on_addr;
X    new->mask = on_mask;
X    new->id_addr = to_addr;
X    new->id_mask = to_mask;
X    new->next = readdr_list;
X    readdr_list = new;
X}
END_OF_FILE
if test 21959 -ne `wc -c <'socket.c'`; then
    echo shar: \"'socket.c'\" unpacked with wrong size!
fi
# end of 'socket.c'
fi
if test -f 'user.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'user.c'\"
else
echo shar: Extracting \"'user.c'\" \(6756 characters\)
sed "s/^X//" >'user.c' <<'END_OF_FILE'
X/* user.c -- user database */
X
X/*			   NOTICE
X *
X * Copyright (c) 1990,1992,1993 Britt Yenne.  All rights reserved.
X * 
X * This software is provided AS-IS.  The author gives no warranty,
X * real or assumed, and takes no responsibility whatsoever for any 
X * use or misuse of this software, or any damage created by its use
X * or misuse.
X * 
X * This software may be freely copied and distributed provided that
X * no part of this NOTICE is deleted or edited in any manner.
X * 
X */
X
X/* Mail comments or questions to ytalk@austin.eds.com */
X
X#include "header.h"
X#include <pwd.h>
X
Xextern char *getlogin();
X
Xyuser *me;			/* my user information */
Xyuser *user_list;		/* list of invited/connected users */
Xyuser *connect_list;		/* list of connected users */
Xyuser *wait_list;		/* list of connected users */
Xyuser *fd_to_user[MAX_FILES];	/* convert file descriptors to users */
Xyuser *key_to_user[128];	/* convert menu ident chars to users */
Xu_long def_flags = 0L;		/* default FL_* flags */
Xstatic u_long daemon_id;	/* running daemon ID counter */
X
X/* ---- local functions ----- */
X
Xstatic int passwd_opened = 0;
X
Xstatic int
Xuser_id(name)
X  char *name;
X{
X    register struct passwd *pw;
X    passwd_opened = 1;
X    if((pw = getpwnam(name)) == NULL)
X	return -1;
X    return pw->pw_uid;
X}
X
Xstatic char *
Xuser_name(uid)
X  int uid;
X{
X    register struct passwd *pw;
X    passwd_opened = 1;
X    if((pw = getpwuid(uid)) == NULL)
X	return NULL;
X    return pw->pw_name;
X}
X
Xstatic void
Xclose_passwd()
X{
X    extern void endpwent();
X
X    if(passwd_opened)
X    {
X	endpwent();
X	passwd_opened = 0;
X    }
X}
X
Xstatic void
Xgenerate_full_name(user)
X  yuser *user;
X{
X    register char *c, *d, *ce;
X
X    if(user->full_name == NULL)
X	user->full_name = get_mem(50);
X    c = user->full_name, ce = user->full_name + 49;
X
X    for(d = user->user_name; *d && c < ce; d++)
X	*(c++) = *d;
X
X    if(c < ce)
X	*(c++) = '@';
X    for(d = user->host_name; *d && c < ce; d++)
X	*(c++) = *d;
X
X    if(user->tty_name[0])
X    {
X	if(c < ce)
X	    *(c++) = '#';
X	for(d = user->tty_name; *d && c < ce; d++)
X	    *(c++) = *d;
X    }
X
X    *c = '\0';
X}
X
Xstatic void
Xassign_key(user)
X  yuser *user;
X{
X    register ychar old;
X    static ychar key = 'a';
X
X    if(user->key != '\0' || user == me || user_list == NULL)
X	return;
X    old = key;
X    do {
X	if(key_to_user[key] == NULL)
X	{
X	    key_to_user[key] = user;
X	    user->key = key;
X	    return;
X	}
X
X	if(key == 'z')
X	    key = 'A';
X	else if(key == 'Z')
X	    key = 'a';
X	else
X	    key++;
X    } while(old != key);
X    user->key = '\0';
X}
X
X/* ---- global functions ----- */
X
X/* Initialize user data structures.
X */
Xvoid
Xinit_user()
X{
X    int my_uid;
X    char *my_name;
X    char my_host[100];
X
X    user_list = NULL;
X    connect_list = NULL;
X    wait_list = NULL;
X    daemon_id = getpid() << 10;
X    (void)memset(fd_to_user, 0, MAX_FILES * sizeof(yuser *));
X    (void)memset(key_to_user, 0, 128 * sizeof(yuser *));
X    my_uid = getuid();
X
X    /* get my username */
X
X    if((my_name = getlogin()) != NULL)
X	if(my_uid < 0 || user_id(my_name) != my_uid)
X	    my_name = NULL;
X    if(my_name == NULL)
X	my_name = user_name(getuid());
X    if(my_name == NULL)
X    {
X	show_error("Who are you?");
X	bail(YTE_ERROR);
X    }
X
X    /* get my hostname */
X
X    if(gethostname(my_host, 100) < 0)
X    {
X	show_error("init_user: gethostname() failed");
X	bail(YTE_ERROR);
X    }
X
X    /* get my user record */
X
X    if((me = new_user(my_name, my_host, NULL)) == NULL)
X	bail(YTE_ERROR);
X    me->remote.protocol = YTP_NEW;
X    me->remote.vmajor = VMAJOR;
X    me->remote.vminor = VMINOR;
X    me->remote.pid = getpid();
X
X    close_passwd();
X}
X
X/* Create a new user record.
X */
Xyuser *
Xnew_user(name, hostname, tty)
X  char *name, *hostname, *tty;
X{
X    register yuser *out, *u;
X    u_long addr;
X
X    /* find the host address */
X
X    if(hostname == NULL || *hostname == '\0')
X    {
X	hostname = me->host_name;
X	addr = me->host_addr;
X    }
X    else if((addr = get_host_addr(hostname)) == (u_long)-1)
X    {
X	sprintf(errstr, "new_user: bad host: '%s'\n", hostname);
X	show_error(errstr);
X	return NULL;
X    }
X
X    /* create the user record */
X
X    out = (yuser *)get_mem(sizeof(yuser));
X    (void)memset(out, 0, sizeof(yuser));
X    out->user_name = str_copy(name);
X    out->host_name = str_copy(hostname);
X    out->host_addr = addr;
X    if(tty)
X	out->tty_name = str_copy(tty);
X    else
X	out->tty_name = str_copy("");
X    out->d_id = daemon_id++;
X    generate_full_name(out);
X    assign_key(out);
X    out->flags = def_flags;
X
X    /* Actually make an effort to keep the user list in order */
X
X    if(user_list == NULL || out->key <= user_list->key)
X    {
X	out->unext = user_list;
X	user_list = out;
X    }
X    else
X    {
X	for(u = user_list; u->unext != NULL; u = u->unext)
X	    if(out->key <= u->unext->key)
X		break;
X	out->unext = u->unext;
X	u->unext = out;
X    }
X    return out;
X}
X
Xvoid
Xfree_user(user)
X  yuser *user;
X{
X    register yuser *u;
X
X    /* remove him from the various blacklists */
X
X    if(user == user_list)
X	user_list = user->unext;
X    else
X	for(u = user_list; u; u = u->unext)
X	    if(u->unext == user)
X	    {
X		u->unext = user->unext;
X		break;
X	    }
X
X    if(user == connect_list)
X	connect_list = user->next;
X    else
X	for(u = connect_list; u; u = u->next)
X	    if(u->next == user)
X	    {
X		u->next = user->next;
X		break;
X	    }
X
X    if(user == wait_list)
X	wait_list = user->next;
X    else
X	for(u = wait_list; u; u = u->next)
X	    if(u->next == user)
X	    {
X		u->next = user->next;
X		break;
X	    }
X
X    /* close him down */
X
X    close_term(user);
X    free(user->full_name);
X    free(user->user_name);
X    free(user->host_name);
X    free(user->tty_name);
X    if(user->dbuf)
X	free(user->dbuf);
X    if(user->output_fd > 0)
X	close(user->output_fd);
X    if(user->fd)
X    {
X	remove_fd(user->fd);
X	fd_to_user[user->fd] = NULL;
X	close(user->fd);
X    }
X    if(user->key != '\0')
X	key_to_user[user->key] = NULL;
X    free(user);
X    if(connect_list == NULL && wait_list != NULL)
X	msg_term(me, "Waiting for connection...");
X    user_winch = 1;
X}
X
X/* Find a user by name/host/pid.  If name is NULL, then it is not checked.
X * If host_addr is (u_long)-1 then it is not checked.  If pid is (u_long)-1
X * then it is not checked.
X */
Xyuser *
Xfind_user(name, host_addr, pid)
X  char *name;
X  u_long host_addr, pid;
X{
X    register yuser *u;
X
X    for(u = user_list; u; u = u->unext)
X	if(name == NULL || strcmp(u->user_name, name) == 0)
X	    if(host_addr == (u_long)-1 || u->host_addr == host_addr)
X		if(pid == (u_long)-1 || u->remote.pid == pid)
X		    return u;
X    
X    /* it could be _me_! */
X
X    if(name == NULL || strcmp(me->user_name, name) == 0)
X	if(host_addr == (u_long)-1 || me->host_addr == host_addr)
X	    if(pid == (u_long)-1 || me->remote.pid == pid)
X		return me;
X
X    /* nobody I know */
X
X    return NULL;
X}
END_OF_FILE
if test 6756 -ne `wc -c <'user.c'`; then
    echo shar: \"'user.c'\" unpacked with wrong size!
fi
# end of 'user.c'
fi
if test -f 'term.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'term.c'\"
else
echo shar: Extracting \"'term.c'\" \(21740 characters\)
sed "s/^X//" >'term.c' <<'END_OF_FILE'
X/* term.c */
X
X/*			   NOTICE
X *
X * Copyright (c) 1990,1992,1993 Britt Yenne.  All rights reserved.
X * 
X * This software is provided AS-IS.  The author gives no warranty,
X * real or assumed, and takes no responsibility whatsoever for any 
X * use or misuse of this software, or any damage created by its use
X * or misuse.
X * 
X * This software may be freely copied and distributed provided that
X * no part of this NOTICE is deleted or edited in any manner.
X * 
X */
X
X/* Mail comments or questions to ytalk@austin.eds.com */
X
X#include "header.h"
X#ifdef USE_SGTTY
X# include <sys/ioctl.h>
X# ifdef hpux
X#  include <sys/bsdtty.h>
X#  include <sgtty.h>
X# endif
X#else
X# include <termios.h>
X#endif
X#include "curses.h"
X#include "xwin.h"
X#include "menu.h"
X
Xstatic int  (*_open_term)();	/* open a new terminal */
Xstatic void (*_close_term)();	/* close a terminal */
Xstatic void (*_addch_term)();	/* write a char to a terminal */
Xstatic void (*_move_term)();	/* move cursor to Y,X position */
Xstatic void (*_clreol_term)();	/* clear to end of line */
Xstatic void (*_clreos_term)();	/* clear to end of screen */
Xstatic void (*_scroll_term)();	/* scroll up one line */
Xstatic void (*_rev_scroll_term)(); /* scroll down one line */
Xstatic void (*_flush_term)();	/* flush pending output */
X
Xstatic int term_type = 0;
X#ifdef USE_SGTTY
X static int line_discipline;
X static int local_mode;
X static struct sgttyb sgttyb;
X static struct tchars tchars;
X static struct ltchars ltchars;
X#else
X static struct termios tio;
X#endif
X
X#ifdef USE_SGTTY
Xstatic void
Xinit_sgtty()
X{
X    if(ioctl(0, TIOCGETD, &line_discipline) < 0)
X    {
X	show_error("TIOCGETD");
X	bail(YTE_INIT);
X    }
X    if(ioctl(0, TIOCLGET, &local_mode) < 0)
X    {
X	show_error("TIOCGETP");
X	bail(YTE_INIT);
X    }
X    if(ioctl(0, TIOCGETP, &sgttyb) < 0)
X    {
X	show_error("TIOCGETP");
X	bail(YTE_INIT);
X    }
X    if(ioctl(0, TIOCGETC, &tchars) < 0)
X    {
X	show_error("TIOCGETC");
X	bail(YTE_INIT);
X    }
X    if(ioctl(0, TIOCGLTC, &ltchars) < 0)
X    {
X	show_error("TIOCGLTC");
X	bail(YTE_INIT);
X    }
X    me->old_rub = sgttyb.sg_erase;
X    me->RUB  = RUBDEF;
X    me->KILL = sgttyb.sg_kill;
X    me->WORD = ltchars.t_werasc;
X    me->CLR = '\024';		/* ^T */
X}
X#else
Xstatic void
Xinit_termios()
X{
X    /* get edit chars */
X
X    if(tcgetattr(0, &tio) < 0)
X    {
X	show_error("tcgetattr failed");
X	bail(YTE_INIT);
X    }
X    me->old_rub = tio.c_cc[VERASE];
X    me->RUB  = RUBDEF;
X#ifdef VKILL
X    me->KILL = tio.c_cc[VKILL];
X#else
X    me->KILL = '\025';	/* ^U */
X#endif
X#ifdef VWERASE
X    me->WORD = tio.c_cc[VWERASE];
X    if(me->WORD == 0xff)
X	me->WORD = '\027';	/* ^W */
X#else
X    me->WORD = '\027';	/* ^W */
X#endif
X    me->CLR = '\024';		/* ^T */
X}
X#endif
X
X/* Initialize terminal and input characteristics.
X */
Xvoid
Xinit_term()
X{
X    char tmpstr[64];
X
X#ifdef USE_SGTTY
X    init_sgtty();
X#else
X    init_termios();
X#endif
X
X    /* Decide on a terminal (window) system and set up the
X     * function pointers.
X     */
X
X    term_type = 0;	/* nothing selected yet */
X
X#ifdef USE_X11
X    if(term_type == 0 && (def_flags & FL_XWIN) && getenv("DISPLAY"))
X    {
X	_open_term = open_xwin;
X	_close_term = close_xwin;
X	_addch_term = addch_xwin;
X	_move_term = move_xwin;
X	_clreol_term = clreol_xwin;
X	_clreos_term = clreos_xwin;
X	_scroll_term = scroll_xwin;
X	_rev_scroll_term = rev_scroll_xwin;
X	_flush_term = flush_xwin;
X	init_xwin();
X	term_type = 2;	/* using xwin */
X    }
X#endif
X
X    /* if no window system found, default to curses */
X     
X    if(term_type == 0)
X    {
X	_open_term = open_curses;
X	_close_term = close_curses;
X	_addch_term = addch_curses;
X	_move_term = move_curses;
X	_clreol_term = clreol_curses;
X	_clreos_term = clreos_curses;
X	_scroll_term = scroll_curses;
X	_rev_scroll_term = NULL;
X	_flush_term = flush_curses;
X	init_curses();
X	term_type = 1;	/* using curses */
X    }
X
X    /* set me up a terminal */
X
X    sprintf(tmpstr, "YTalk version %d.%d", VMAJOR, VMINOR);
X    if(open_term(me, tmpstr) < 0)
X    {
X	end_term();
X	show_error("init_term: open_term() failed");
X	bail(0);
X    }
X}
X
X/* Set terminal size.
X */
Xvoid
Xset_terminal_size(fd, rows, cols)
X  int fd, rows, cols;
X{
X#ifdef TIOCSWINSZ
X    struct winsize winsize;
X
X    winsize.ws_row = rows;
X    winsize.ws_col = cols;
X    ioctl(fd, TIOCSWINSZ, &winsize);
X#endif
X}
X
X/* Set terminal and input characteristics for slave terminals.
X */
Xvoid
Xset_terminal_flags(fd)
X  int fd;
X{
X#ifdef USE_SGTTY
X    (void)ioctl(fd, TIOCSETD, &line_discipline);
X    (void)ioctl(fd, TIOCLSET, &local_mode);
X    (void)ioctl(fd, TIOCSETP, &sgttyb);
X    (void)ioctl(fd, TIOCSETC, &tchars);
X    (void)ioctl(fd, TIOCSLTC, &ltchars);
X#else
X    if(tcsetattr(fd, TCSANOW, &tio) < 0)
X	show_error("tcsetattr failed");
X#endif
X}
X
Xint
Xwhat_term()
X{
X    return term_type;
X}
X
X/* Abort all terminal processing.
X */
Xvoid
Xend_term()
X{
X    switch(term_type)
X    {
X	case 1:		/* curses */
X	    end_curses();
X	    break;
X#ifdef USE_X11
X	case 2:		/* xwin */
X	    end_xwin();
X	    break;
X#endif
X    }
X    term_type = 0;
X}
X
X/* Open a new user window.
X */
Xint
Xopen_term(user, title)
X  register yuser *user;
X  register char *title;
X{
X    if(_open_term(user, title) != 0)
X	return -1;
X    user->x = user->y = 0;
X    if(user->scr == NULL)
X	resize_win(user, 24, 80);
X    return 0;
X}
X
X/* Close a user window.
X */
Xvoid
Xclose_term(user)
X  register yuser *user;
X{
X    register int i;
X
X    if(user->scr)
X    {
X	_close_term(user);
X	for(i = 0; i < user->t_rows; i++)
X	    free(user->scr[i]);
X	free(user->scr);
X	user->scr = NULL;
X	user->t_rows = user->rows = 0;
X	user->t_cols = user->cols = 0;
X    }
X}
X
X/* Place a character.
X */
Xvoid
Xaddch_term(user, c)
X  register yuser *user;
X  register ychar c;
X{
X    if(c >= ' ' && c <= '~')
X    {
X	_addch_term(user, c);
X	user->scr[user->y][user->x] = c;
X	if(++(user->x) >= user->cols)
X	{
X	    user->bump = 1;
X	    user->x = user->cols - 1;
X	    if(user->cols < user->t_cols)
X		_move_term(user, user->y, user->x);
X	}
X    }
X}
X
X/* Move the cursor.
X */
Xvoid
Xmove_term(user, y, x)
X  register yuser *user;
X  register int y, x;
X{
X    if(y < 0 || y >= user->rows)
X	y = user->rows - 1;
X    if(x < 0 || x >= user->cols)
X    {
X	user->bump = 1;
X	x = user->cols - 1;
X    }
X    else
X	user->bump = 0;
X    _move_term(user, y, x);
X    user->y = y;
X    user->x = x;
X}
X
X/* Clear to EOL.
X */
Xvoid
Xclreol_term(user)
X  register yuser *user;
X{
X    register int j;
X    register ychar *c;
X
X    if(user->cols < user->t_cols)
X    {
X	c = user->scr[user->y] + user->x;
X	for(j = user->x; j < user->cols; j++)
X	{
X	    *(c++) = ' ';
X	    _addch_term(user, ' ');
X	}
X	move_term(user, user->y, user->x);
X    }
X    else
X    {
X	_clreol_term(user);
X	c = user->scr[user->y] + user->x;
X	for(j = user->x; j < user->cols; j++)
X	    *(c++) = ' ';
X    }
X}
X
X/* Clear to EOS.
X */
Xvoid
Xclreos_term(user)
X  register yuser *user;
X{
X    register int j, i;
X    register ychar *c;
X    int x, y;
X
X    if(user->cols < user->t_cols || user->rows < user->t_rows)
X    {
X	x = user->x;
X	y = user->y;
X	clreol_term(user);
X	for(i = user->y + 1; i < user->rows; i++)
X	{
X	    move_term(user, i, 0);
X	    clreol_term(user);
X	}
X	move_term(user, y, x);
X    }
X    else
X    {
X	_clreos_term(user);
X	j = user->x;
X	for(i = user->y; i < user->rows; i++)
X	{
X	    c = user->scr[i] + j;
X	    for(; j < user->cols; j++)
X		*(c++) = ' ';
X	    j = 0;
X	}
X    }
X}
X
X/* Scroll window.
X */
Xvoid
Xscroll_term(user)
X  register yuser *user;
X{
X    register int i;
X    register ychar *c;
X
X    if(user->sc_bot > user->sc_top)
X    {
X	c = user->scr[user->sc_top];
X	for(i = user->sc_top; i < user->sc_bot; i++)
X	    user->scr[i] = user->scr[i+1];
X	user->scr[user->sc_bot] = c;
X	for(i = 0; i < user->cols; i++)
X	    *(c++) = ' ';
X	if(_scroll_term
X	&& user->rows == user->t_rows
X	&& user->cols == user->t_cols
X	&& user->sc_top == 0
X	&& user->sc_bot == user->rows - 1)
X	    _scroll_term(user);
X	else
X	    redraw_term(user, 0);
X    }
X    else
X    {
X	move_term(user, user->sc_top, 0);
X	clreol_term(user);
X    }
X}
X
X/* Reverse-scroll window.
X */
Xvoid
Xrev_scroll_term(user)
X  register yuser *user;
X{
X    register int i;
X    register ychar *c;
X
X    if(user->sc_bot > user->sc_top)
X    {
X	c = user->scr[user->sc_bot];
X	for(i = user->sc_bot; i > user->sc_top; i--)
X	    user->scr[i] = user->scr[i-1];
X	user->scr[user->sc_top] = c;
X	for(i = 0; i < user->cols; i++)
X	    *(c++) = ' ';
X	if(_rev_scroll_term
X	&& user->rows == user->t_rows
X	&& user->cols == user->t_cols
X	&& user->sc_top == 0
X	&& user->sc_bot == user->rows - 1)
X	    _rev_scroll_term(user);
X	else
X	    redraw_term(user, 0);
X    }
X    else
X    {
X	move_term(user, user->sc_top, 0);
X	clreol_term(user);
X    }
X}
X
X/* Flush window output.
X */
Xvoid
Xflush_term(user)
X  register yuser *user;
X{
X    _flush_term(user);
X}
X
X/* Rub one character.
X */
Xvoid
Xrub_term(user)
X  register yuser *user;
X{
X    if(user->x > 0)
X    {
X	if(user->bump)
X	{
X	    addch_term(user, ' ');
X	    user->bump = 0;
X	}
X	else
X	{
X	    move_term(user, user->y, user->x - 1);
X	    addch_term(user, ' ');
X	    move_term(user, user->y, user->x - 1);
X	}
X
X    }
X}
X
X/* Rub one word.
X */
Xint
Xword_term(user)
X  register yuser *user;
X{
X    register int x, out;
X
X    for(x = user->x - 1; x >= 0 && user->scr[user->y][x] == ' '; x--)
X	continue;
X    for(; x >= 0 && user->scr[user->y][x] != ' '; x--)
X	continue;
X    out = user->x - (++x);
X    if(out <= 0)
X	return 0;
X    move_term(user, user->y, x);
X    clreol_term(user);
X    return out;
X}
X
X/* Kill current line.
X */
Xvoid
Xkill_term(user)
X  register yuser *user;
X{
X    if(user->x > 0)
X    {
X	move_term(user, user->y, 0);
X	clreol_term(user);
X    }
X}
X
X/* Expand a tab.  We use non-destructive tabs.
X */
Xvoid
Xtab_term(user)
X  register yuser *user;
X{
X    move_term(user, user->y, (user->x + 8) & 0xfff8);
X}
X
X/* Process a newline.
X */
Xvoid
Xnewline_term(user)
X  register yuser *user;
X{
X    register int new_y, next_y;
X
X    new_y = user->y + 1;
X    if(user->flags & FL_RAW)
X    {
X	if(new_y >= user->rows)
X	{
X	    if(user->flags & FL_SCROLL)
X		scroll_term(user);
X	}
X	else
X	    move_term(user, new_y, user->x);
X    }
X    else
X    {
X	if(new_y >= user->rows)
X	{
X	    if(user->flags & FL_SCROLL)
X	    {
X		scroll_term(user);
X		move_term(user, user->y, 0);
X		return;
X	    }
X	    new_y = 0;
X	}
X	next_y = new_y + 1;
X	if(next_y >= user->rows)
X	    next_y = 0;
X	if(next_y > 0 || !(user->flags & FL_SCROLL))
X	{
X	    move_term(user, next_y, 0);
X	    clreol_term(user);
X	}
X	move_term(user, new_y, 0);
X	clreol_term(user);
X    }
X}
X
X/* Insert lines.
X */
Xvoid
Xadd_line_term(user, num)
X  register yuser *user;
X  int num;
X{
X    register ychar *c;
X    register int i;
X
X    if(num == 1 && user->y == 0)
X	rev_scroll_term(user);
X    else
X    {
X	/* find number of remaining lines */
X
X	i = user->rows - user->y - num;
X	if(i <= 0)
X	{
X	    i = user->x;
X	    move_term(user, user->y, 0);
X	    clreos_term(user);
X	    move_term(user, user->y, i);
X	    return;
X	}
X
X	/* swap the remaining lines to bottom */
X
X	for(i--; i >= 0; i--)
X	{
X	    c = user->scr[user->y + i];
X	    user->scr[user->y + i] = user->scr[user->y + i + num];
X	    user->scr[user->y + i + num] = c;
X	}
X
X	/* clear the added lines */
X
X	for(num--; num >= 0; num--)
X	{
X	    c = user->scr[user->y + num];
X	    for(i = 0; i < user->cols; i++)
X		*(c++) = ' ';
X	}
X	redraw_term(user, user->y);
X    }
X}
X
X/* Delete lines.
X */
Xvoid
Xdel_line_term(user, num)
X  register yuser *user;
X  int num;
X{
X    register ychar *c;
X    register int i;
X
X    if(num == 1 && user->y == 0)
X	scroll_term(user);
X    else
X    {
X	/* find number of remaining lines */
X
X	i = user->rows - user->y - num;
X	if(i <= 0)
X	{
X	    i = user->x;
X	    move_term(user, user->y, 0);
X	    clreos_term(user);
X	    move_term(user, user->y, i);
X	    return;
X	}
X
X	/* swap the remaining lines to top */
X
X	for(; i > 0; i--)
X	{
X	    c = user->scr[user->rows - i];
X	    user->scr[user->rows - i] = user->scr[user->rows - i - num];
X	    user->scr[user->rows - i - num] = c;
X	}
X
X	/* clear the remaining bottom lines */
X
X	for(; num > 0; num--)
X	{
X	    c = user->scr[user->rows - num];
X	    for(i = 0; i < user->cols; i++)
X		*(c++) = ' ';
X	}
X	redraw_term(user, user->y);
X    }
X}
X
Xstatic void
Xcopy_text(fr, to, count)
X  register ychar *fr, *to;
X  register int count;
X{
X    if(to < fr)
X    {
X	for(; count > 0; count--)
X	    *(to++) = *(fr++);
X    }
X    else
X    {
X	fr += count;
X	to += count;
X	for(; count > 0; count--)
X	    *(--to) = *(--fr);
X    }
X}
X
X/* Add chars.
X */
Xvoid
Xadd_char_term(user, num)
X  register yuser *user;
X  int num;
X{
X    register ychar *c;
X    register int i;
X
X    /* find number of remaining non-blank chars */
X
X    i = user->cols - user->x - num;
X    c = user->scr[user->y] + user->cols - num - 1;
X    while(i > 0 && *c == ' ')
X	c--, i--;
X    if(i <= 0)
X    {
X	clreol_term(user);
X	return;
X    }
X
X    /* transfer the chars and clear the remaining */
X
X    c++;
X    copy_text(c - i, c - i + num, i);
X    for(c -= i; num > 0; num--)
X    {
X	*(c++) = ' ';
X	_addch_term(user, ' ');
X    }
X    for(; i > 0; i--)
X	_addch_term(user, *(c++));
X    _move_term(user, user->y, user->x);
X}
X
X/* Delete chars.
X */
Xvoid
Xdel_char_term(user, num)
X  register yuser *user;
X  int num;
X{
X    register ychar *c;
X    register int i;
X
X    /* find number of remaining non-blank chars */
X
X    i = user->cols - user->x - num;
X    c = user->scr[user->y] + user->cols - 1;
X    while(i > 0 && *c == ' ')
X	c--, i--;
X    if(i <= 0)
X    {
X	clreol_term(user);
X	return;
X    }
X
X    /* transfer the chars and clear the remaining */
X
X    c++;
X    copy_text(c - i, c - i - num, i);
X    for(c -= (i + num); i > 0; i--)
X	_addch_term(user, *(c++));
X    for(; num > 0; num--)
X    {
X	*(c++) = ' ';
X	_addch_term(user, ' ');
X    }
X    _move_term(user, user->y, user->x);
X}
X
X/* Redraw a user's window.
X */
Xvoid
Xredraw_term(user, y)
X  register yuser *user;
X  register int y;
X{
X    register int x, spaces;
X    register ychar *c;
X
X    for(; y < user->t_rows; y++)
X    {
X	_move_term(user, y, 0);
X	_clreol_term(user);
X	spaces = 0;
X	c = user->scr[y];
X	for(x = 0; x < user->t_cols; x++, c++)
X	{
X	    if(*c == ' ')
X		spaces++;
X	    else
X	    {
X		if(spaces)
X		{
X		    if(spaces <= 3)	/* arbitrary */
X		    {
X			for(; spaces > 0; spaces--)
X			    _addch_term(user, ' ');
X		    }
X		    else
X		    {
X			_move_term(user, y, x);
X			spaces = 0;
X		    }
X		}
X		_addch_term(user, *c);
X	    }
X	}
X    }
X
X    /* redisplay any active menu */
X
X    if(menu_ptr != NULL)
X	update_menu();
X    else
X	_move_term(user, user->y, user->x);
X}
X
X/* Return the first interesting row for a user with a window of
X * the given height and width.
X */
Xstatic int
Xfirst_interesting_row(user, height, width)
X  yuser *user;
X  int height, width;
X{
X    register int j, i;
X    register ychar *c;
X
X    if(height < user->t_rows)
X    {
X	j = (user->y + 1) - height;
X	if(j < 0)
X	    j += user->t_rows;
X    }
X    else
X    {
X	j = user->y + 1;
X	if(j >= user->t_rows)
X	    j = 0;
X    }
X    while(j != user->y)
X    {
X	i = (width > user->t_cols) ? user->t_cols : width;
X	for(c = user->scr[j]; i > 0; i--, c++)
X	    if(*c != ' ')
X		break;
X	if(i > 0)
X	    break;
X	if(++j >= user->t_rows)
X	    j = 0;
X    }
X    return j;
X}
X
X/* Called when a user's window has been resized.
X */
Xvoid
Xresize_win(user, height, width)
X  yuser *user;
X  int height, width;
X{
X    register int j, i;
X    register ychar *c, **newscr;
X    int new_y, y_pos;
X
X    if(height == user->t_rows && width == user->t_cols)
X	return;
X
X    /* resize the user terminal buffer */
X
X    new_y = -1;
X    y_pos = 0;
X    newscr = (ychar **)get_mem(height * sizeof(ychar *));
X    if(user->scr == NULL)
X    {
X	user->t_rows = user->rows = 0;
X	user->t_cols = user->cols = 0;
X    }
X    else if(user->region_set)
X    {
X	/* save as many top lines as possible */
X
X	for(j = 0; j < height && j < user->t_rows; j++)
X	    newscr[j] = user->scr[j];
X	new_y = j - 1;
X	y_pos = user->y;
X	for(; j < user->t_rows; j++)
X	    free(user->scr[j]);
X	free(user->scr);
X    }
X    else
X    {
X	/* shift all recent lines to top of screen */
X
X	j = first_interesting_row(user, height, width);
X	for(i = 0; i < height; i++)
X	{
X	    newscr[++new_y] = user->scr[j];
X	    if(j == user->y)
X		break;
X	    if(++j >= user->t_rows)
X		j = 0;
X	}
X	for(i++; i < user->t_rows; i++)
X	{
X	    if(++j >= user->t_rows)
X		j = 0;
X	    free(user->scr[j]);
X	}
X	y_pos = new_y;
X	free(user->scr);
X    }
X    user->scr = newscr;
X
X    /* fill in the missing portions */
X
X    if(width > user->t_cols)
X	for(i = 0; i <= new_y; i++)
X	{
X	    user->scr[i] = (ychar *)realloc_mem(user->scr[i], width);
X	    for(j = user->t_cols; j < width; j++)
X		user->scr[i][j] = ' ';
X	}
X    for(i = new_y + 1; i < height; i++)
X    {
X	c = user->scr[i] = (ychar *)get_mem(width);
X	for(j = 0; j < width; j++)
X	    *(c++) = ' ';
X    }
X
X    /* reset window values */
X
X    user->t_rows = user->rows = height;
X    user->t_cols = user->cols = width;
X    user->sc_top = 0;
X    user->sc_bot = height - 1;
X    move_term(user, y_pos, user->x);
X    send_winch(user);
X    redraw_term(user, 0);
X    flush_term(user);
X}
X
X/* Draw a nice box.
X */
Xstatic void
Xdraw_box(user, height, width, c)
X  yuser *user;
X  int height, width;
X  char c;
X{
X    register int i;
X
X    if(width < user->t_cols)
X    {
X	for(i = 0; i < height; i++)
X	{
X	    move_term(user, i, width);
X	    addch_term(user, c);
X	    if(width + 1 < user->t_cols)
X		clreol_term(user);
X	}
X    }
X    if(height < user->t_rows)
X    {
X	move_term(user, height, 0);
X	for(i = 0; i < width; i++)
X	    addch_term(user, c);
X	if(width < user->t_cols)
X	    addch_term(user, c);
X	if(width + 1 < user->t_cols)
X	    clreol_term(user);
X	if(height + 1 < user->t_rows)
X	{
X	    move_term(user, height + 1, 0);
X	    clreos_term(user);
X	}
X    }
X}
X
X/* Set the virtual terminal size, ie: the display region.
X */
Xvoid
Xset_win_region(user, height, width)
X  yuser *user;
X  int height, width;
X{
X    register int x, y;
X    int old_height, old_width;
X
X    if(height < 2 || height > user->t_rows)
X	height = user->t_rows;
X    if(width < 2 || width > user->t_cols)
X	width = user->t_cols;
X
X    /* Don't check if they're already equal; always perform processing.
X     * Just because it's equal over here doesn't mean it's equal for all
X     * ytalk connections.  We still need to clear the screen.
X     */
X
X    old_height = user->rows;
X    old_width = user->cols;
X    user->rows = user->t_rows;
X    user->cols = user->t_cols;
X    if(user->region_set)
X    {
X	x = user->x;
X	y = user->y;
X	if(width > old_width || height > old_height)
X	    draw_box(user, old_height, old_width, ' ');
X    }
X    else
X    {
X	x = y = 0;
X	move_term(user, 0, 0);
X	clreos_term(user);
X	user->region_set = 1;
X    }
X    draw_box(user, height, width, '%');
X
X    /* set the display region */
X
X    user->rows = height;
X    user->cols = width;
X    user->sc_top = 0;
X    user->sc_bot = height - 1;
X    move_term(user, y, x);
X    flush_term(user);
X    
X    if(user == me)
X	send_region();
X}
X
X/* Set the virtual terminal size, ie: the display region.
X */
Xvoid
Xend_win_region(user)
X  yuser *user;
X{
X    int old_height, old_width;
X
X    old_height = user->rows;
X    old_width = user->cols;
X    user->rows = user->t_rows;
X    user->cols = user->t_cols;
X    if(old_height < user->t_rows || old_width < user->t_cols)
X	draw_box(user, old_height, old_width, ' ');
X    user->region_set = 0;
X    if(user == me)
X	send_end_region();
X}
X
X/* Set the scrolling region.
X */
Xvoid
Xset_scroll_region(user, top, bottom)
X  yuser *user;
X  int top, bottom;
X{
X    if(top < 0 || top >= user->rows)
X	return;
X    if(bottom < top || bottom >= user->rows)
X	return;
X    user->sc_top = top;
X    user->sc_bot = bottom;
X}
X
X/* Send a message to the terminal.
X */
Xvoid
Xmsg_term(user, str)
X  yuser *user;
X  char *str;
X{
X    int y;
X
X    if((y = user->y + 1) >= user->rows)
X	y = 0;
X    _move_term(user, y, 0);
X    _addch_term(user, '[');
X    while(*str)
X	_addch_term(user, *(str++));
X    _addch_term(user, ']');
X    _clreol_term(user);
X    _move_term(user, user->y, user->x);
X    _flush_term(user);
X}
X
X/* Spew terminal contents to a file descriptor.
X */
Xvoid
Xspew_term(user, fd, rows, cols)
X  yuser *user;
X  int fd, rows, cols;
X{
X    register ychar *c, *e;
X    register int len;
X    int y;
X    static char tmp[20];
X
X    if(user->region_set)
X    {
X	y = 0;
X	if(cols > user->cols)
X	    cols = user->cols;
X	if(rows > user->rows)
X	    rows = user->rows;
X	for(;;)
X	{
X	    for(c = e = user->scr[y], len = cols; len > 0; len--, c++)
X		if(*c != ' ')
X		    e = c + 1;
X	    if(e != user->scr[y])
X		(void)write(fd, user->scr[y], e - user->scr[y]);
X	    if(++y >= rows)
X		break;
X	    (void)write(fd, "\n", 1);
X	}
X
X	/* move the cursor to the correct place */
X
X	sprintf(tmp, "%c[%d;%dH", 27, user->y + 1, user->x + 1);
X	(void)write(fd, tmp, strlen(tmp));
X    }
X    else
X    {
X	y = first_interesting_row(user, rows, cols);
X	for(;;)
X	{
X	    if(y == user->y)
X	    {
X		if(user->x > 0)
X		    (void)write(fd, user->scr[y], user->x);
X		break;
X	    }
X	    for(c = e = user->scr[y], len = user->t_cols; len > 0; len--, c++)
X		if(*c != ' ')
X		    e = c + 1;
X	    if(e != user->scr[y])
X		(void)write(fd, user->scr[y], e - user->scr[y]);
X	    (void)write(fd, "\n", 1);
X	    if(++y >= user->t_rows)
X		y = 0;
X	}
X    }
X}
X
X/* Draw some raw characters to the screen without updating any buffers.
X * Whoever uses this should know what they're doing.  It should always
X * be followed by a redraw_term() before calling any of the normal
X * term functions again.
X *
X * If the given string is not as long as the given length, then the
X * string is repeated to fill the given length.
X *
X * This is an unadvertised function.
X */
Xvoid
Xraw_term(user, y, x, str, len)
X  yuser *user;
X  int y, x;
X  ychar *str;
X  int len;
X{
X    register ychar *c;
X
X    if(y < 0 || y >= user->t_rows)
X	return;
X    if(x < 0 || x >= user->t_cols)
X	return;
X    _move_term(user, y, x);
X
X    for(c = str; len > 0; len--, c++)
X    {
X	if(*c == '\0')
X	    c = str;
X	if(*c < ' ' || *c > '~')
X	    return;
X	_addch_term(user, *c);
X    }
X}
X
Xint
Xcenter(width, n)
X  int width, n;
X{
X    if(n >= width)
X	return 0;
X    return (width - n) >> 1;
X}
END_OF_FILE
if test 21740 -ne `wc -c <'term.c'`; then
    echo shar: \"'term.c'\" unpacked with wrong size!
fi
# end of 'term.c'
fi
if test -f 'curses.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'curses.c'\"
else
echo shar: Extracting \"'curses.c'\" \(6765 characters\)
sed "s/^X//" >'curses.c' <<'END_OF_FILE'
X/* curses.c -- curses interface */
X
X/*			   NOTICE
X *
X * Copyright (c) 1990,1992,1993 Britt Yenne.  All rights reserved.
X * 
X * This software is provided AS-IS.  The author gives no warranty,
X * real or assumed, and takes no responsibility whatsoever for any 
X * use or misuse of this software, or any damage created by its use
X * or misuse.
X * 
X * This software may be freely copied and distributed provided that
X * no part of this NOTICE is deleted or edited in any manner.
X * 
X */
X
X/* Mail comments or questions to ytalk@austin.eds.com */
X
X#include "header.h"
X#include <curses.h>
X#include <sys/signal.h>
X#include "curses.h"
X
Xtypedef struct _ywin {
X    struct _ywin *next;		/* next ywin in linked list */
X    yuser *user;		/* user pointer */
X    WINDOW *win;		/* window pointer */
X    int height, width;		/* height and width in characters */
X    int row, col;		/* row and column position on screen */
X    char *title;		/* window title string */
X} ywin;
X
Xstatic ywin *head;		/* head of linked list */
X
X/* ---- local functions ---- */
X
X/* Take input from the user.
X */
Xstatic void
Xcurses_input(fd)
X  int fd;
X{
X    register int rc;
X    static ychar buf[MAXBUF];
X
X    if((rc = read(fd, buf, MAXBUF)) <= 0)
X    {
X	if(rc == 0)
X	    bail(YTE_SUCCESS);
X	bail(YTE_ERROR);
X    }
X    my_input(buf, rc);
X}
X
Xstatic ywin *
Xnew_ywin(user, title)
X  yuser *user;
X  char *title;
X{
X    register ywin *out;
X    register int len;
X
X    len = strlen(title);
X    out = (ywin *)get_mem(sizeof(ywin) + len + 1);
X    (void)memset(out, 0, sizeof(ywin));
X    out->user = user;
X    out->title = ((char *)out) + sizeof(ywin);
X    strcpy(out->title, title);
X    return out;
X}
X
Xstatic void
Xmake_win(w, height, width, row, col)
X  ywin *w;
X  int height, width, row, col;
X{
X    if((w->win = newwin(height, width, row, col)) == NULL)
X    {
X	register ywin *w;
X	w = (ywin *)(me->term);
X	if(w->win != NULL)
X	    show_error("make_win: newwin() failed");
X	bail(YTE_ERROR);
X    }
X    w->height = height;
X    w->width = width;
X    w->row = row;
X    w->col = col;
X    scrollok(w->win, FALSE);
X    wmove(w->win, 0, 0);
X}
X
Xstatic void
Xdraw_title(w)
X  ywin *w;
X{
X    register int pad, x;
X    register char *t;
X
X    pad = (w->width - strlen(w->title)) / 2;
X    move(w->row - 1, w->col);
X    x = 0;
X    for(; x < pad - 2; x++)
X	addch('-');
X    if(pad >= 2)
X    {
X	addch('=');
X	addch(' ');
X	x += 2;
X    }
X    for(t = w->title; *t && x < w->width; x++, t++)
X	addch(*t);
X    if(pad >= 2)
X    {
X	addch(' ');
X	addch('=');
X	x += 2;
X    }
X    for(; x < w->width; x++)
X	addch('-');
X}
X
X/* Return number of lines per window, given "wins" windows.
X */
Xstatic int
Xwin_size(wins)
X  int wins;
X{
X    return (LINES - 1) / wins;
X}
X
X/* Break down and redraw all user windows.
X */
Xstatic void
Xcurses_redraw()
X{
X    register ywin *w;
X    register int row, wins, wsize;
X
X    /* kill old windows */
X
X    wins = 0;
X    for(w = head; w; w = w->next)
X    {
X	if(w->win)
X	{
X	    delwin(w->win);
X	    w->win = NULL;
X	}
X	wins++;
X    }
X    if((wsize = win_size(wins)) < 3)
X    {
X	end_term();
X	errno = 0;
X	show_error("curses_redraw: window size too small");
X	bail(YTE_ERROR);
X    }
X
X    /* make new windows */
X
X    clear();
X    refresh();
X    row = 0;
X    for(w = head; w; w = w->next)
X    {
X	if(w->next)
X	{
X	    make_win(w, wsize-1, COLS, row+1, 0);
X	    resize_win(w->user, wsize-1, COLS);
X	}
X	else
X	{
X	    make_win(w, LINES-row-2, COLS, row+1, 0);
X	    resize_win(w->user, LINES-row-2, COLS);
X	}
X	draw_title(w);
X	row += wsize;
X	refresh();
X	wrefresh(w->win);
X    }
X}
X
X/* Start curses and set all options.
X */
Xstatic void
Xcurses_start()
X{
X    LINES = COLS = 0;	/* so resizes will work */
X    initscr();
X    raw();
X    crmode();
X    noecho();
X    clear();
X}
X
X/* Restart curses... window size has changed.
X */
Xstatic void
Xcurses_restart()
X{
X    register ywin *w;
X
X    /* kill old windows */
X
X    for(w = head; w; w = w->next)
X	if(w->win)
X	{
X	    delwin(w->win);
X	    w->win = NULL;
X	}
X
X    /* restart curses */
X
X    endwin();
X    curses_start();
X    curses_redraw();
X    refresh();
X
X    /* some systems require we do this again */
X
X#ifdef SIGWINCH
X    signal(SIGWINCH, curses_restart);
X#endif
X}
X
X/* ---- global functions ---- */
X
Xvoid
Xinit_curses()
X{
X    curses_start();
X    refresh();
X    head = NULL;
X    add_fd(0, curses_input);	/* set up user's input function */
X
X    /* set up SIGWINCH signal handler */
X
X#ifdef SIGWINCH
X    signal(SIGWINCH, curses_restart);
X#endif
X}
X
Xvoid
Xend_curses()
X{
X    move(LINES-1, 0);
X    clrtoeol();
X    refresh();
X    endwin();
X}
X
X/* Open a new window.
X */
Xint
Xopen_curses(user, title)
X  yuser *user;
X  char *title;
X{
X    register ywin *w;
X    register int wins;
X
X    /* count the open windows.  We want to ensure at least
X     * three lines per window.
X     */
X    wins = 0;
X    for(w = head; w; w = w->next)
X	wins++;
X    if(win_size(wins+1) < 3)
X	return -1;
X    
X    /* add the new user */
X
X    if(head == NULL)
X	w = head = new_ywin(user, title);
X    else
X	for(w = head; w; w = w->next)
X	    if(w->next == NULL)
X	    {
X		w->next = new_ywin(user, title);
X		w = w->next;
X		break;
X	    }
X    user->term = w;
X
X    /* redraw */
X
X    curses_redraw();
X    return 0;
X}
X
X/* Close a window.
X */
Xvoid
Xclose_curses(user)
X  yuser *user;
X{
X    register ywin *w, *p;
X
X    /* zap the old user */
X
X    w = (ywin *)(user->term);
X    if(w == head)
X	head = w->next;
X    else
X    {
X	for(p = head; p; p = p->next)
X	    if(w == p->next)
X	    {
X		p->next = w->next;
X		break;
X	    }
X	if(p == NULL)
X	{
X	    show_error("close_curses: user not found");
X	    return;
X	}
X    }
X    delwin(w->win);
X    free(w);
X    curses_redraw();
X}
X
Xvoid
Xaddch_curses(user, c)
X  yuser *user;
X  register ychar c;
X{
X    register ywin *w;
X    register int x, y;
X
X    w = (ywin *)(user->term);
X    getyx(w->win, y, x);
X    waddch(w->win, c);
X    if(x >= COLS-1)
X	wmove(w->win, y, x);
X}
X
Xvoid
Xmove_curses(user, y, x)
X  yuser *user;
X  register int y, x;
X{
X    register ywin *w;
X
X    w = (ywin *)(user->term);
X    wmove(w->win, y, x);
X}
X
Xvoid
Xclreol_curses(user)
X  register yuser *user;
X{
X    register ywin *w;
X
X    w = (ywin *)(user->term);
X    wclrtoeol(w->win);
X}
X
Xvoid
Xclreos_curses(user)
X  register yuser *user;
X{
X    register ywin *w;
X
X    w = (ywin *)(user->term);
X    wclrtobot(w->win);
X}
X
Xvoid
Xscroll_curses(user)
X  register yuser *user;
X{
X    register ywin *w;
X
X    /* Curses has uses busted scrolling.  In order to call scroll()
X     * effectively, scrollok() must be TRUE.  However, if scrollok()
X     * is TRUE, then placing a character in the lower right corner
X     * will cause an auto-scroll.  *sigh*
X     */
X    w = (ywin *)(user->term);
X    scrollok(w->win, TRUE);
X    scroll(w->win);
X    scrollok(w->win, FALSE);
X}
X
Xvoid
Xflush_curses(user)
X  register yuser *user;
X{
X    register ywin *w;
X
X    w = (ywin *)(user->term);
X    wrefresh(w->win);
X}
END_OF_FILE
if test 6765 -ne `wc -c <'curses.c'`; then
    echo shar: \"'curses.c'\" unpacked with wrong size!
fi
# end of 'curses.c'
fi
if test -f 'xwin.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xwin.c'\"
else
echo shar: Extracting \"'xwin.c'\" \(9252 characters\)
sed "s/^X//" >'xwin.c' <<'END_OF_FILE'
X/* xwin.c -- X Window Terminal Interface */
X
X/*			   NOTICE
X *
X * Copyright (c) 1990,1992,1993 Britt Yenne.  All rights reserved.
X * 
X * This software is provided AS-IS.  The author gives no warranty,
X * real or assumed, and takes no responsibility whatsoever for any 
X * use or misuse of this software, or any damage created by its use
X * or misuse.
X * 
X * This software may be freely copied and distributed provided that
X * no part of this NOTICE is deleted or edited in any manner.
X * 
X */
X
X/* Mail comments or questions to ytalk@austin.eds.com */
X
X#ifdef USE_X11
X
X#include "header.h"
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xresource.h>
X
Xstatic Display	       *display;	/* display */
Xstatic Window		rootwin;	/* root window */
Xstatic int		screen_num;	/* screen number */
Xstatic XrmDatabase	db;		/* resource database */
Xstatic XFontStruct     *text_font;	/* font */
Xstatic GC		textGC,		/* text graphic context */
X			invertGC;	/* graphic context for inverts */
Xstatic u_long		whitepix,	/* white pixel */
X			blackpix;	/* black pixel */
Xstatic int		font_width,	/* font width */
X			font_height,	/* font height */
X			font_ascent;	/* font ascent */
X
X#define YPOS(p) ((p) * font_height)
X#define XPOS(p) ((p) * font_width)
X
X/* ----- local functions ----- */
X
Xstatic XTextProperty *
XstrToTP(s)
X  char *s;
X{
X    XTextProperty *tp = (XTextProperty *)get_mem(sizeof(XTextProperty));
X    XStringListToTextProperty(&s, 1, tp);
X    return tp;
X}
X
Xstatic char *
XgetOption(o)
X  char *o;
X{
X    XrmValue value;
X    char *type;
X
X    if(XrmGetResource(db, o, o, &type, &value))
X    {
X	if(value.addr == NULL)
X	    return NULL;
X	if(strcmp(value.addr, "false") == 0)
X	    return NULL;
X	if(strcmp(value.addr, "False") == 0)
X	    return NULL;
X	return value.addr;
X    }
X    else
X	return (char *)NULL;
X}
X
Xstatic void
Xload_font(name, font)
X  char *name;
X  XFontStruct **font;
X{
X    if((*font = XLoadQueryFont(display, name)) == NULL)
X    {
X	sprintf(errstr, "Cannot load font %s", name);
X	show_error(errstr);
X	bail(YTE_ERROR);
X    }
X}
X
Xstatic void
Xmake_GC(gc, font, fgpixel, bgpixel, l_width, l_style, l_cap, l_join, gcfunc)
X  GC *gc;
X  XFontStruct *font;
X  u_long fgpixel, bgpixel;
X  int l_width, l_style, l_cap, l_join, gcfunc;
X{
X    u_long mask = 0;
X    XGCValues values;
X
X    if(font != NULL)
X    {
X	values.font = font->fid;
X	mask |= GCFont;
X    }
X    values.foreground = fgpixel;
X    values.background = bgpixel;
X    values.line_width = l_width;
X    values.line_style = l_style;
X    values.cap_style = l_cap;
X    values.join_style = l_join;
X    mask |= GCForeground | GCBackground | GCLineWidth | GCLineStyle | 
X	    GCCapStyle | GCJoinStyle;
X    if(gcfunc != -1)
X    {
X	values.function = gcfunc;
X	mask |= GCFunction;
X    }
X    *gc = XCreateGC(display, rootwin, mask, &values);
X}
X
X/* Find the user who owns a given Window.
X */
Xstatic yuser *
Xwin_user(win)
X  Window win;
X{
X    register yuser *u;
X
X    for(u = user_list; u; u = u->unext)
X	if(u->win == win)
X	    break;
X    return u;
X}
X
X#define TWIN	report.xany.window
X
Xstatic void
Xprocess_event()
X{
X    register int n;
X    register yuser *user;
X    static XEvent report;
X    static char buf[512];
X
X    while(XPending(display))
X    {
X	XNextEvent(display, &report);
X	switch(report.type)
X	{
X	    case Expose:
X		if(report.xexpose.count)
X		    break;
X		if((user = win_user(TWIN)) != NULL)
X		    redraw_term(user, 0);
X		break;
X	    case ConfigureNotify: /* RESIZED (or moved) */
X		if((user = win_user(TWIN)) != NULL)
X		{
X		    int rows, cols;
X		    rows = report.xconfigure.height / font_height;
X		    cols = report.xconfigure.width / font_width;
X		    resize_win(user, rows, cols);
X		}
X		break;
X	    case KeyPress:
X		n = XLookupString(&report, buf, 512, NULL, NULL);
X		my_input(buf, n);
X		break;
X	}
X    }
X}
X
Xstatic void
Xplace_cursor(win, y, x)
X  Window win;
X  int y, x;
X{
X    XFillRectangle(display, win, invertGC,
X	XPOS(x), YPOS(y),
X	font_width, font_height);
X}
X
X/* ----- global functions ----- */
X
X/* Initialize X Windows.
X */
Xvoid
Xinit_xwin()
X{
X    extern char *getenv();
X    char	*displayName;
X    char	*rfn, str[256];
X    int		xfd;
X    XGCValues   values;
X
X    /* get and open the display */
X
X    displayName = getOption("YTalk.display");
X    if((display = XOpenDisplay(displayName)) == NULL)
X    {
X	show_error("Cannot open X display");
X	bail(YTE_ERROR);
X    }
X    rootwin = DefaultRootWindow(display);
X    screen_num = DefaultScreen(display);
X
X    /* read all options */
X
X    db = XrmGetStringDatabase(XResourceManagerString(display));
X    if((rfn = getenv("HOME")) != NULL)
X    {
X	sprintf(str, "%s/.Xdefaults", rfn);
X	if(access(str, 0) == 0)
X	    XrmMergeDatabases(XrmGetFileDatabase(str), &db);
X    }
X    if((rfn = getenv("XENVIRONMENT")) != NULL)
X	if(access(rfn, 0) == 0)
X	    XrmMergeDatabases(XrmGetFileDatabase(rfn), &db);
X    if(getOption("YTalk.reverse"))
X    {
X	whitepix = BlackPixel(display, screen_num);
X	blackpix = WhitePixel(display, screen_num);
X    }
X    else
X    {
X	blackpix = BlackPixel(display, screen_num);
X	whitepix = WhitePixel(display, screen_num);
X    }
X
X    /* load font and graphic context */
X
X    if((rfn = getOption("YTalk.font")) == NULL)
X	rfn = "9x15";
X    load_font(rfn, &text_font);
X    font_width = text_font->max_bounds.rbearing;
X    font_height = text_font->max_bounds.ascent + text_font->max_bounds.descent;
X    font_ascent = text_font->max_bounds.ascent;
X    make_GC(&textGC, text_font, blackpix, whitepix,
X	    2, LineSolid, CapRound, JoinRound, -1);
X    make_GC(&invertGC, text_font, blackpix, whitepix,
X	    2, LineSolid, CapRound, JoinRound, GXinvert);
X    values.plane_mask = blackpix ^ whitepix;
X    XChangeGC(display, invertGC, GCPlaneMask, &values);
X
X    /* set up event processing */
X
X    xfd = ConnectionNumber(display);
X    add_fd(xfd, process_event);
X}
X
X/* End X Windows.
X */
Xvoid
Xend_xwin()
X{
X    XCloseDisplay(display);
X}
X
X/* Open a new window.
X */
Xint
Xopen_xwin(user, title)
X  yuser *user;
X  char *title;
X{
X    XWMHints	WMhints;
X    XClassHint	ClassHints;
X    XSizeHints	size;
X    XTextProperty *name;
X    Window	win;
X    int		rows, cols;
X
X    size.x = 0;
X    size.y = 0;
X    size.width = 80;
X    size.height = 24;
X    size.min_width = 20;
X    size.min_height = 2;
X    size.width_inc = font_width;
X    size.height_inc = font_height;
X    size.flags = PSize | PMinSize | PResizeInc;
X    if(getOption("YTalk.geometry"))
X    {
X	XParseGeometry(getOption("YTalk.geometry"),
X	    &size.x, &size.y, &size.width, &size.height);
X
X	/* don't set USPosition -- it confuses tvtwm */
X    }
X    rows = size.height;
X    cols = size.width;
X    size.width *= font_width;
X    size.height *= font_height;
X    size.min_width *= font_width;
X    size.min_height *= font_height;
X    win = XCreateSimpleWindow(display, rootwin, size.x, size.y,
X	size.width, size.height, 4, blackpix, whitepix);
X    if(win == (Window)0)
X	return -1;
X
X    WMhints.flags = InputHint;
X    WMhints.input = 1;
X    ClassHints.res_name = "ytalk";
X    ClassHints.res_class = "YTalk";
X    name = strToTP(title);
X    XSetWMProperties(display, win, name, name,
X	0, 0, &size, &WMhints, &ClassHints);
X
X    XSelectInput(display, win, ExposureMask | KeyPressMask
X	| StructureNotifyMask);
X    XMapRaised(display, win);
X
X    user->win = win;
X    user->ty = user->tx = 0;
X    place_cursor(win, 0, 0);
X    resize_win(user, rows, cols);
X    return 0;
X}
X
Xvoid
Xclose_xwin(user)
X  yuser *user;
X{
X    XDestroyWindow(display, user->win);
X    user->win = (Window)0;
X}
X
Xvoid
Xaddch_xwin(user, ch)
X  yuser *user;
X  ychar ch;
X{
X    XClearArea(display, user->win,
X	XPOS(user->tx), YPOS(user->ty),
X	font_width, font_height,
X	False);
X    XDrawString(display, user->win, textGC,
X	XPOS(user->tx), YPOS(user->ty) + font_ascent,
X	&ch, 1);
X    user->tx++;
X    if(user->tx >= user->t_cols)
X	user->tx--;
X    place_cursor(user->win, user->ty, user->tx);
X}
X
Xvoid
Xmove_xwin(user, y, x)
X  yuser *user;
X  int y, x;
X{
X    place_cursor(user->win, user->ty, user->tx);
X    user->ty = y;
X    user->tx = x;
X    place_cursor(user->win, user->ty, user->tx);
X}
X
Xvoid
Xclreol_xwin(user)
X  yuser *user;
X{
X    XClearArea(display, user->win,
X	XPOS(user->tx), YPOS(user->ty),
X	0, font_height,
X	False);
X    place_cursor(user->win, user->ty, user->tx);
X}
X
Xvoid
Xclreos_xwin(user)
X  yuser *user;
X{
X    XClearArea(display, user->win,
X	XPOS(user->tx), YPOS(user->ty),
X	0, font_height,
X	False);
X    XClearArea(display, user->win,
X	0, YPOS(user->ty + 1),
X	0, 0,
X	False);
X    place_cursor(user->win, user->ty, user->tx);
X}
X
Xvoid
Xscroll_xwin(user)
X  yuser *user;
X{
X    place_cursor(user->win, user->ty, user->tx);
X    XCopyArea(display, user->win, user->win, textGC,
X	XPOS(0), YPOS(1),
X	XPOS(user->t_cols), YPOS(user->t_rows - 1),
X	XPOS(0), YPOS(0));
X    XClearArea(display, user->win,
X	0, YPOS(user->t_rows - 1),
X	0, font_height,
X	False);
X    place_cursor(user->win, user->ty, user->tx);
X}
X
Xvoid
Xrev_scroll_xwin(user)
X  yuser *user;
X{
X    place_cursor(user->win, user->ty, user->tx);
X    XCopyArea(display, user->win, user->win, textGC,
X	XPOS(0), YPOS(0),
X	XPOS(user->t_cols), YPOS(user->t_rows - 1),
X	XPOS(0), YPOS(1));
X    XClearArea(display, user->win,
X	XPOS(0), YPOS(0),
X	0, font_height,
X	False);
X    place_cursor(user->win, user->ty, user->tx);
X}
X
Xvoid
Xflush_xwin(user)
X  yuser *user;
X{
X    /* "user" is unused -- sorry, lint  :-) */
X    XFlush(display);
X}
X
X#endif
END_OF_FILE
if test 9252 -ne `wc -c <'xwin.c'`; then
    echo shar: \"'xwin.c'\" unpacked with wrong size!
fi
# end of 'xwin.c'
fi
echo shar: End of shell archive.
echo "== Now read the README file =="
exit 0
