Newsgroups: comp.sources.unix
From: yenne@austin.eds.com (Britt Yenne)
Subject: v27i025: ytalk-3.0 - multi-user replacement for the UNIX "talk" program, Patch01
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: yenne@austin.eds.com (Britt Yenne)
Posting-Number: Volume 27, Issue 25
Archive-Name: ytalk-3.0/patch01

Patch01 for ytalk-3.0, Volume 27

This patch will update Ytalk 3.0 to Patch Level 1.  This patch requires
that you have a directory of unmodified source code for YTalk version 3.0,
with no patches currently applied.

    To determine which version of Ytalk you have, run it and look at the top
    of your window.  The version identifier for the original ytalk release
    source will look something like this:

        YTalk version 3.0

    The version above is what this patch will work on.  If there is also
    a number in parentheses, ie:

        YTalk version 3.0 (1)

    then that is the current Patch Level, meaning that all patches up
    to and including the displayed number have been applied.  This patch
    will not work if there is a number in parentheses.

If this is not the patch you require, check the ftp.uu.net USENET archive
for comp.sources.unix via anonymous FTP (ytalk-3.0 is under volume27), or
mail to ytalk@austin.eds.com.

To apply this patch, make a copy of this file under your ytalk source
directory and follow the instructions for the "shell archive" below.

This patch comes with a new Imakefile and Makefile.  You will need to
rename or remove your current Imakefile and Makefile before you unpack
the shell archive below.  After you unpack the archive you will need
to configure the new Imakefile or Makefile -- see the README file.

For a list of changes contained in this patch, see the README file after
you apply the patch.

Questions or comments to:  ytalk@austin.eds.com (Britt Yenne)

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  Imakefile Makefile patch_01
# Wrapped by yenne@poe on Tue Aug 24 16:41:25 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'curses.c' ; then 
    echo 'shar: curses.c -> cwin.c'
    mv curses.c cwin.c
fi
if test -f 'curses.h' ; then 
    echo 'shar: curses.h -> cwin.h'
    mv curses.h cwin.h
fi
if test -f 'Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imakefile'\"
else
echo shar: Extracting \"'Imakefile'\" \(2694 characters\)
sed "s/^X//" >'Imakefile' <<'END_OF_FILE'
X#### Imakefile for YTalk version 3.0 ####
X#
X#			   NOTICE
X#
X# Copyright (c) 1990,1992,1993 Britt Yenne.  All rights reserved.
X# 
X# This software is provided AS-IS.  The author gives no warranty,
X# real or assumed, and takes no responsibility whatsoever for any 
X# use or misuse of this software, or any damage created by its use
X# or misuse.
X# 
X# This software may be freely copied and distributed provided that
X# no part of this NOTICE is deleted or edited in any manner.
X# 
X
X###################################
X## CONFIGURATION  (The Fun Part) ##
X###################################
X#
X# If your machine does not support TERMIOS (example: any NeXT running
X# NeXTStep up to and including version 3.1), then uncomment the following
X# line.
X 
X#TDEFS = -DUSE_SGTTY
X
X#
X# If you are running an older Sun OS using YP (now known as NIS), you might
X# need to uncomment the next line if ytalk asks you "Who are you?"
X
X#SLIBS = -lsun
X
X#
X# If you are on a sun running solaris 2.* you might need to uncomment the 
X# following line.
X
X#SLIBS = -lnsl -lsocket
X
X#
X# If your machine has a 64-bit architecture or uses 64-bit 'long's, then you
X# will need to uncomment the following line.
X
X#BDEFS = -DY64BIT
X
X#
X# If you have (or want) a system-wide .ytalkrc file, uncomment the next
X# line and set it to the correct pathname.  The backslashes must remain
X# before each double-quote.
X
X#RCDEF = -DSYSTEM_YTALKRC=\"/usr/local/etc/ytalkrc\"
X
X#
X# If you plan to install ytalk on your system, you may want to modify
X# the following lines.  Y_BINDIR is where the binary will be placed.
X# Y_MANDIR is where the manpage will be placed.
X
XY_BINDIR = /usr/local/bin
XY_MANDIR = /usr/local/man/man1
X
X############################################################
X## Past this point, you shouldn't need to modify anything ##
X############################################################
XLIB = -lcurses -ltermcap $(SLIBS) $(XLIB)
XDEFINES = -DUSE_X11 -I/usr/local/include $(TDEFS) $(BDEFS) $(RCDEF)
XLDFLAGS = $(LDOPTIONS)
XOBJ = main.o term.o user.o fd.o comm.o menu.o socket.o rc.o exec.o cwin.o \
X      xwin.o
XPRG = ytalk
X
Xall:	$(PRG) ytalk.cat
X
X$(PRG):	$(OBJ)
X	$(CC) $(LDFLAGS) -o $(PRG) $(OBJ) $(LIB)
X    
Xytalk.cat:	ytalk.1
X	nroff -man ytalk.1 > ytalk.cat
X
Xstart:	Imakefile
X	sed 's/^DEFINES.*X11/CFLAGS =/' < Imakefile > Makefile
X
Xshar:
X	make start
X	shar -i Manifest -o ytalk-3.0.shar -t "== Now read the README file =="
X
Xclean::
X	-rm -f $(OBJ)
X
Xinstall:: $(PRG)
X	/bin/cp ytalk $(Y_BINDIR)
X	/bin/cp ytalk.1 $(Y_MANDIR)
X	@echo "Ytalk installation complete."
X
X$(OBJ):		header.h
Xmain.o:		menu.h
Xterm.o:		cwin.h xwin.h menu.h
Xfd.o:		menu.h
Xcomm.o:		socket.h menu.h
Xmenu.o:		menu.h
Xsocket.o:	socket.h
Xcwin.o:		cwin.h
Xxwin.o:		xwin.h
X
END_OF_FILE
if test 2694 -ne `wc -c <'Imakefile'`; then
    echo shar: \"'Imakefile'\" unpacked with wrong size!
fi
# end of 'Imakefile'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(2683 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#### Imakefile for YTalk version 3.0 ####
X#
X#			   NOTICE
X#
X# Copyright (c) 1990,1992,1993 Britt Yenne.  All rights reserved.
X# 
X# This software is provided AS-IS.  The author gives no warranty,
X# real or assumed, and takes no responsibility whatsoever for any 
X# use or misuse of this software, or any damage created by its use
X# or misuse.
X# 
X# This software may be freely copied and distributed provided that
X# no part of this NOTICE is deleted or edited in any manner.
X# 
X
X###################################
X## CONFIGURATION  (The Fun Part) ##
X###################################
X#
X# If your machine does not support TERMIOS (example: any NeXT running
X# NeXTStep up to and including version 3.1), then uncomment the following
X# line.
X 
X#TDEFS = -DUSE_SGTTY
X
X#
X# If you are running an older Sun OS using YP (now known as NIS), you might
X# need to uncomment the next line if ytalk asks you "Who are you?"
X
X#SLIBS = -lsun
X
X#
X# If you are on a sun running solaris 2.* you might need to uncomment the 
X# following line.
X
X#SLIBS = -lnsl -lsocket
X
X#
X# If your machine has a 64-bit architecture or uses 64-bit 'long's, then you
X# will need to uncomment the following line.
X
X#BDEFS = -DY64BIT
X
X#
X# If you have (or want) a system-wide .ytalkrc file, uncomment the next
X# line and set it to the correct pathname.  The backslashes must remain
X# before each double-quote.
X
X#RCDEF = -DSYSTEM_YTALKRC=\"/usr/local/etc/ytalkrc\"
X
X#
X# If you plan to install ytalk on your system, you may want to modify
X# the following lines.  Y_BINDIR is where the binary will be placed.
X# Y_MANDIR is where the manpage will be placed.
X
XY_BINDIR = /usr/local/bin
XY_MANDIR = /usr/local/man/man1
X
X############################################################
X## Past this point, you shouldn't need to modify anything ##
X############################################################
XLIB = -lcurses -ltermcap $(SLIBS) $(XLIB)
XCFLAGS = -I/usr/local/include $(TDEFS) $(BDEFS) $(RCDEF)
XLDFLAGS = $(LDOPTIONS)
XOBJ = main.o term.o user.o fd.o comm.o menu.o socket.o rc.o exec.o cwin.o \
X      xwin.o
XPRG = ytalk
X
Xall:	$(PRG) ytalk.cat
X
X$(PRG):	$(OBJ)
X	$(CC) $(LDFLAGS) -o $(PRG) $(OBJ) $(LIB)
X    
Xytalk.cat:	ytalk.1
X	nroff -man ytalk.1 > ytalk.cat
X
Xstart:	Imakefile
X	sed 's/^DEFINES.*X11/CFLAGS =/' < Imakefile > Makefile
X
Xshar:
X	make start
X	shar -i Manifest -o ytalk-3.0.shar -t "== Now read the README file =="
X
Xclean::
X	-rm -f $(OBJ)
X
Xinstall:: $(PRG)
X	/bin/cp ytalk $(Y_BINDIR)
X	/bin/cp ytalk.1 $(Y_MANDIR)
X	@echo "Ytalk installation complete."
X
X$(OBJ):		header.h
Xmain.o:		menu.h
Xterm.o:		cwin.h xwin.h menu.h
Xfd.o:		menu.h
Xcomm.o:		socket.h menu.h
Xmenu.o:		menu.h
Xsocket.o:	socket.h
Xcwin.o:		cwin.h
Xxwin.o:		xwin.h
X
END_OF_FILE
if test 2683 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'patch_01' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch_01'\"
else
echo shar: Extracting \"'patch_01'\" \(61834 characters\)
sed "s/^X//" >'patch_01' <<'END_OF_FILE'
X*** 3.0.0/README	Mon Aug 23 14:05:01 1993
X--- README	Tue Aug 24 16:37:57 1993
X***************
X*** 22,27 ****
X--- 22,31 ----
X  
X  The resulting executable program will be named "ytalk".
X  
X+ If you ever go back and change some configuration parameters at the
X+ top of Imakefile or Makefile, you should run 'make clean' before running
X+ 'xmkmf' and/or 'make' again.  This will ensure that everything recompiles.
X+ 
X  A manpage will automatically be built.  It will be named "ytalk.cat".
X  You can read the manual page by running:
X  
X***************
X*** 40,42 ****
X--- 44,69 ----
X  at this email address:
X  
X      ytalk@austin.eds.com
X+ 
X+ ---- PATCH LEVEL 01
X+ 
X+   1. Forcibly reset the scrolling region after a shell exits.
X+   2. Handle a local X resize while in a shell.
X+   3. Repair the password entry lookup stuff.
X+   4. Character-wrap to next line if word-wrap is disabled.
X+   5. Solaris 2.* support, patch by Magnus Hammerin.
X+   6. Aside messages in X, patch by Jonas Yngvesson.
X+   7. Fix X support, patch by Carl Edman.
X+   8. Option -x to disable X from the command line, thanks to John Vanderpool.
X+   9. Ctrl-L or ctrl-R to redraw screen, thanks to Shih-Chen Huang.
X+  10. Fix bizarre WINCH bug in exec.c.
X+  11. Handle 64-bit machines, thanks to Andrew Myers.
X+  12. Implement raw/cooked curses -- fixes 8-bit/parity problems with some
X+      terminals and allows ytalk to be suspended.  Thanks to Duncan Sinclair.
X+  13. System ytalkrc file, thanks to Evan McLean.
X+  14. Place user's full name in title bar, thanks to Evan McLean.
X+  15. Better imake support, thanks to Carl Edman.
X+  16. Installation features for make.
X+  17. Fix X resource database calls, patch by Andreas Stolcke.
X+  18. Fix cross-platform problems, thanks to Larry Schwimmer.
X+ 
X*** 3.0.0/ytalk.1	Mon Aug 23 14:05:02 1993
X--- ytalk.1	Tue Aug 24 12:11:08 1993
X***************
X*** 12,20 ****
X  .SH NAME
X  ytalk - A multi-user chat program. 
X  .SH SYNOPSIS
X! .B ytalk username...
X  .SH DESCRIPTION
X! .I YTalk V3.0
X  .PP
X  YTalk is in essence a multi-user chat program.  It works almost exactly like
X  the UNIX talk program and even communicates with the same talk daemon(s), but
X--- 12,20 ----
X  .SH NAME
X  ytalk - A multi-user chat program. 
X  .SH SYNOPSIS
X! .B ytalk [-x] username...
X  .SH DESCRIPTION
X! .I YTalk V3.0 Patch Level 1
X  .PP
X  YTalk is in essence a multi-user chat program.  It works almost exactly like
X  the UNIX talk program and even communicates with the same talk daemon(s), but
X***************
X*** 40,45 ****
X--- 40,47 ----
X  .sp
X  	ytalk george fred@hissun.edu marc@grumpy.cc
X  .PP
X+ The -x option disables the X11 interface (described below).
X+ .PP
X  For each user on the command line, YTalk will attempt to connect to the talk
X  daemon on the specified user's host and determine if that user has left an
X  invitation for you to call.  If not, YTalk leaves an invitation for him
X***************
X*** 95,111 ****
X  moment has these options:
X  .sp
X          a: add a user
X! .sp
X          d: delete a user
X! .sp
X          o: options
X! .sp
X          s: shell
X! .sp
X          u: user list
X! .sp
X          w: output user to file
X! .sp
X          q: quit
X  .PP
X  By choosing option "a", you are given the opportunity to type the name of any
X--- 97,113 ----
X  moment has these options:
X  .sp
X          a: add a user
X! .br
X          d: delete a user
X! .br
X          o: options
X! .br
X          s: shell
X! .br
X          u: user list
X! .br
X          w: output user to file
X! .br
X          q: quit
X  .PP
X  By choosing option "a", you are given the opportunity to type the name of any
X***************
X*** 148,161 ****
X  to edit the YTalk options.  The current options are:
X  .sp
X  	s: turn scrolling [off/on]
X! .sp
X  	w: turn word-wrap [off/on]
X! .sp
X  	i: turn auto-import [off/on]
X! .sp
X  	v: turn auto-invite [off/on]
X! .sp
X  	r: turn auto-rering [off/on]
X  .PP
X  If
X  .I scrolling
X--- 150,165 ----
X  to edit the YTalk options.  The current options are:
X  .sp
X  	s: turn scrolling [off/on]
X! .br
X  	w: turn word-wrap [off/on]
X! .br
X  	i: turn auto-import [off/on]
X! .br
X  	v: turn auto-invite [off/on]
X! .br
X  	r: turn auto-rering [off/on]
X+ .br
X+ 	a: turn asides [off/on]
X  .PP
X  If
X  .I scrolling
X***************
X*** 186,191 ****
X--- 190,201 ----
X  respond to your invitation within 30 seconds.  You will not be asked for
X  verification.
X  .PP
X+ If
X+ .I asides
X+ is turned on (it may not be available), then keyboard input received while
X+ the input focus is in a specific users' window will only be sent to that
X+ user.  See the X11 interface description below.
X+ .PP
X  Any of these options can be set to your preference in your .ytalkrc file,
X  as described below.
X  .SH YTALK STARTUP FILE
X***************
X*** 207,212 ****
X--- 217,223 ----
X  .I auto-import ,
X  .I auto-invite ,
X  .I auto-rering ,
X+ .I asides ,
X  or
X  .I X .
X  Setting these options works just like described above.  Turning
X***************
X*** 269,278 ****
X  If the DISPLAY environment variable is defined when YTalk starts up, then
X  YTalk will attempt to communicate with that X server.  A window will be
X  created for you and each user you are connected to.  The X11 Interface can
X! be disabled by putting this line into your .ytalkrc file:
X  .sp
X  	turn X off
X  .PP
X  YTalk consults the X11 Resource Database for these user-definable
X  configuration options:
X  .sp
X--- 280,298 ----
X  If the DISPLAY environment variable is defined when YTalk starts up, then
X  YTalk will attempt to communicate with that X server.  A window will be
X  created for you and each user you are connected to.  The X11 Interface can
X! be disabled either by specifying -x on the command line or by putting this
X! line into your .ytalkrc file:
X  .sp
X  	turn X off
X  .PP
X+ A window is created for each individual user in the conversation.  If the
X+ input focus is in the main window (ie: the one with "ytalk" in the title
X+ bar) then anything typed will be sent to all connected users.  If the input
X+ focus is in one of the users' windows, then anything typed will be sent
X+ as an aside to only that user.  If the "aside" option is turned off (see
X+ above) then ytalk will beep and not accept anything typed when the input
X+ focus is not in the main window.
X+ .PP
X  YTalk consults the X11 Resource Database for these user-definable
X  configuration options:
X  .sp
X***************
X*** 291,301 ****
X  .br
X          or transmitted to all YTalk connections,
X  .br
X! 	2) a way to send an aside to just one or a few of the 
X  .br
X!         connected users,
X  .br
X! 	3) a dedicated YTalk daemon.
X  
X  .SH AUTHOR
X  
X--- 311,329 ----
X  .br
X          or transmitted to all YTalk connections,
X  .br
X! 	2) a dedicated YTalk daemon.
X! 
X! .SH FILES
X! 
X! /usr/local/etc/ytalkrc
X  .br
X!     System-wide defaults file.
X! .PP
X! $HOME/.ytalkrc
X  .br
X!     User's local configuration file.  This file overrides
X! .br
X!     options set in the system ytalkrc file.
X  
X  .SH AUTHOR
X  
X***************
X*** 304,313 ****
X  yenne@austin.eds.com
X  
X  .SH CONTRIBUTORS
X! Special thanks to Carl Edman, Tobias Hahn, and Geoff W. for beta
X! testing and suggestions.
X  .PP
X  Thanks to Sitaram Ramaswamy for the original YTalk manpage.
X  
X  .SH BUGS
X  
X--- 332,355 ----
X  yenne@austin.eds.com
X  
X  .SH CONTRIBUTORS
X! Special thanks to Carl Edman for numerous code patches, beta testing,
X! and comments.  I think this guy spends as much time on ytalk as I do.
X  .PP
X+ Special thanks to Tobias Hahn and Geoff W. for beta testing and
X+ suggestions.
X+ .PP
X  Thanks to Sitaram Ramaswamy for the original YTalk manpage.
X+ .PP
X+ Thanks to Magnus Hammerin for Solaris 2.* support.
X+ .PP
X+ Thanks to Jonas Yngvesson for aside messages in X.
X+ .PP
X+ Thanks to Andreas Stolcke for fixing the X resource database calls.
X+ .PP
X+ Thanks to John Vanderpool, Shih-Chen Huang, Andrew Myers, Duncan Sinclair,
X+ Evan McLean, and Larry Schwimmer for comments and ideas.
X+ .PP
X+ The README file shipped with ytalk gives detailed attributions.
X  
X  .SH BUGS
X  
X*** 3.0.0/term.doc	Mon Aug 23 14:05:02 1993
X--- term.doc	Sun Aug 22 21:34:48 1993
X***************
X*** 19,27 ****
X  by calling this function in comm.c:
X  
X      void
X!     my_input(buf, len)		[in comm.c]
X        ychar *buf;
X        int len;
X  
X  Note that it is much more optimal to call this function once with a
X  batch of input characters rather than calling this function once for
X--- 19,37 ----
X  by calling this function in comm.c:
X  
X      void
X!     my_input(user, buf, len)	[in comm.c]
X!       yuser *user;
X        ychar *buf;
X        int len;
X+ 
X+ The "user" parameter should be set to the user pointer whose window
X+ the given input was taken from (ie: I had my mouse cursor in the
X+ window assigned to user X and typed some info).  The my_input routine
X+ will send the given info to the given user as an aside, ie: no other
X+ users get sent this info.  If a terminal interface cannot distinguish
X+ input from various windows, or if you do not wish to bother with this,
X+ then just send "me" as the user.  Any input given the "me" user will
X+ get sent to all connected users.
X  
X  Note that it is much more optimal to call this function once with a
X  batch of input characters rather than calling this function once for
X*** 3.0.0/header.h	Mon Aug 23 14:05:02 1993
X--- header.h	Tue Aug 24 10:39:40 1993
X***************
X*** 30,35 ****
X--- 30,36 ----
X  
X  #define VMAJOR	3	/* major version number */
X  #define VMINOR	0	/* minor version number */
X+ #define VPATCH	1	/* patch level */
X  
X  /* ---- YTalk protocols ---- */
X  
X***************
X*** 49,54 ****
X--- 50,61 ----
X  typedef yaddr	yterm;		/* terminal cookie */
X  typedef u_char	ychar;		/* we use unsigned chars */
X  
X+ #ifdef Y64BIT
X+ typedef u_int	ylong;		/* unsigned 32-bit */
X+ #else
X+ typedef u_long	ylong;		/* unsigned 32-bit */
X+ #endif
X+ 
X  typedef struct {
X      u_char w_rows, w_cols;	/* window size FOR PROTOCOL YTP_OLD */
X      char protocol;		/* ytalk protocol -- see above */
X***************
X*** 56,62 ****
X      short vmajor, vminor;	/* version numbers */
X      u_short rows, cols;		/* his window size over there */
X      u_short my_rows, my_cols;	/* my window size over there */
X!     u_long pid;			/* my process id */
X      char pad[44];		/* zeroed out */
X  } y_parm;
X  
X--- 63,69 ----
X      short vmajor, vminor;	/* version numbers */
X      u_short rows, cols;		/* his window size over there */
X      u_short my_rows, my_cols;	/* my window size over there */
X!     ylong pid;			/* my process id */
X      char pad[44];		/* zeroed out */
X  } y_parm;
X  
X***************
X*** 67,73 ****
X      struct _yuser *unext;	/* next user in full user list */
X      int fd;			/* file descriptor */
X      int output_fd;		/* non-zero if output is going to a file */
X!     u_long flags;		/* active FL_* flags below */
X      ychar edit[4];		/* edit characters */
X      u_short t_rows, t_cols;	/* his rows and cols on window over here */
X      u_short rows, cols;		/* his active region rows and cols over here */
X--- 74,80 ----
X      struct _yuser *unext;	/* next user in full user list */
X      int fd;			/* file descriptor */
X      int output_fd;		/* non-zero if output is going to a file */
X!     ylong flags;		/* active FL_* flags below */
X      ychar edit[4];		/* edit characters */
X      u_short t_rows, t_cols;	/* his rows and cols on window over here */
X      u_short rows, cols;		/* his active region rows and cols over here */
X***************
X*** 85,95 ****
X      char *user_name;		/* user name */
X      char *host_name;		/* host name */
X      char *tty_name;		/* tty name */
X!     u_long host_addr;		/* host inet address */
X      int daemon;			/* daemon type to use */
X!     u_long l_id, r_id;		/* local and remote talkd invite list index */
X!     u_long d_id;		/* talk daemon process id -- see socket.c */
X!     long last_invite;		/* timestamp of last invitation sent */
X      struct sockaddr_in sock;	/* communication socket */
X      struct sockaddr_in orig_sock; /* original socket -- another sick hack */
X      u_int av[MAXARG];		/* ESC sequence arguments */
X--- 92,102 ----
X      char *user_name;		/* user name */
X      char *host_name;		/* host name */
X      char *tty_name;		/* tty name */
X!     ylong host_addr;		/* host inet address */
X      int daemon;			/* daemon type to use */
X!     ylong l_id, r_id;		/* local and remote talkd invite list index */
X!     ylong d_id;			/* talk daemon process id -- see socket.c */
X!     ylong last_invite;		/* timestamp of last invitation sent */
X      struct sockaddr_in sock;	/* communication socket */
X      struct sockaddr_in orig_sock; /* original socket -- another sick hack */
X      u_int av[MAXARG];		/* ESC sequence arguments */
X***************
X*** 119,124 ****
X--- 126,132 ----
X  #define FL_INVITE	0x00000010L	/* auto-invite enabled */
X  #define FL_RING		0x00000020L	/* auto-rering enabled */
X  #define FL_XWIN		0x00000040L	/* X Windows enabled (startup opt) */
X+ #define FL_ASIDE	0x00000080L	/* multiple window input/asides */
X  #define FL_LOCKED	0x40000000L	/* flags locked by other end */
X  
X  /* ---- defines and short-cuts ---- */
X***************
X*** 151,158 ****
X  typedef struct {
X      ychar code;			/* V3_EXPORT, V3_IMPORT, or V3_ACCEPT */
X      char filler[3];
X!     u_long host_addr;		/* host address */
X!     u_long pid;			/* process id */
X      char name[V3_NAMELEN];	/* user name */
X      char host[V3_HOSTLEN];	/* host name */
X  } v3_pack;
X--- 159,166 ----
X  typedef struct {
X      ychar code;			/* V3_EXPORT, V3_IMPORT, or V3_ACCEPT */
X      char filler[3];
X!     ylong host_addr;		/* host address */
X!     ylong pid;			/* process id */
X      char name[V3_NAMELEN];	/* user name */
X      char host[V3_HOSTLEN];	/* host name */
X  } v3_pack;
X***************
X*** 165,171 ****
X  typedef struct {
X      ychar code;			/* V3_LOCKF or V3_UNLOCKF */
X      char filler[3];
X!     u_long flags;		/* flags */
X  } v3_flags;
X  
X  #define V3_FLAGSLEN	sizeof(v3_flags)
X--- 173,179 ----
X  typedef struct {
X      ychar code;			/* V3_LOCKF or V3_UNLOCKF */
X      char filler[3];
X!     ylong flags;		/* flags */
X  } v3_flags;
X  
X  #define V3_FLAGSLEN	sizeof(v3_flags)
X***************
X*** 220,226 ****
X  extern yuser *fd_to_user[MAX_FILES];	/* convert file descriptors to users */
X  extern yuser *key_to_user[128];	/* convert menu ident chars to users */
X  extern char errstr[MAXERR];	/* temporary string for errors */
X! extern u_long def_flags;	/* default FL_* flags */
X  extern int user_winch;		/* user window/status changed flag */
X  
X  extern ychar *io_ptr;		/* user input pointer */
X--- 228,234 ----
X  extern yuser *fd_to_user[MAX_FILES];	/* convert file descriptors to users */
X  extern yuser *key_to_user[128];	/* convert menu ident chars to users */
X  extern char errstr[MAXERR];	/* temporary string for errors */
X! extern ylong def_flags;		/* default FL_* flags */
X  extern int user_winch;		/* user window/status changed flag */
X  
X  extern ychar *io_ptr;		/* user input pointer */
X***************
X*** 228,233 ****
X--- 236,249 ----
X  
X  extern int running_process;	/* flag: is process running? */
X  
X+ /* ---- some machine compatibility definitions ---- */
X+ 
X+ #if defined(SYSV)
X+ # define Y_USE_SIGHOLD 1
X+ #endif
X+ 
X+ extern int errno;
X+ 
X  /* ---- global functions ---- */
X  
X  extern void	bail		( /* int */ );			/* main.c */
X***************
X*** 267,272 ****
X--- 283,292 ----
X  extern void	msg_term	( /* yuser, str */ );		/* term.c */
X  extern void	spew_term	( /* yuser, fd, rows, cols */ ); /* term.c */
X  extern int	center		( /* width, n */ );		/* term.c */
X+ extern void	redraw_all_terms();				/* term.c */
X+ extern void	set_raw_term	();				/* term.c */
X+ extern void	set_cooked_term	();				/* term.c */
X+ extern int	term_does_asides();				/* term.c */
X  
X  extern void	init_user	();				/* user.c */
X  extern yuser   *new_user	( /* name, host, tty */ );	/* user.c */
X***************
X*** 298,304 ****
X  extern void	kill_auto	();				/* socket.c */
X  extern int	newsock		( /* yuser */ );		/* socket.c */
X  extern int	connect_to	( /* yuser */ );		/* socket.c */
X! extern u_long	get_host_addr	( /* hostname */ );		/* socket.c */
X  extern char    *host_name	( /* addr */ );			/* socket.c */
X  extern void	readdress_host	( /* from, to, on */ );		/* socket.c */
X  
X--- 318,324 ----
X  extern void	kill_auto	();				/* socket.c */
X  extern int	newsock		( /* yuser */ );		/* socket.c */
X  extern int	connect_to	( /* yuser */ );		/* socket.c */
X! extern ylong	get_host_addr	( /* hostname */ );		/* socket.c */
X  extern char    *host_name	( /* addr */ );			/* socket.c */
X  extern void	readdress_host	( /* from, to, on */ );		/* socket.c */
X  
X*** 3.0.0/socket.h	Mon Aug 23 14:05:03 1993
X--- socket.h	Sun Aug 22 21:05:40 1993
X***************
X*** 18,33 ****
X  
X  typedef struct _hostinfo {
X      struct _hostinfo *next;	/* next in linked list */
X!     u_long host_addr;		/* host address */
X      int dtype;			/* active daemon types bitmask */
X  } hostinfo;
X  
X  typedef struct _readdr {
X      struct _readdr *next;	/* next in linked list */
X!     u_long addr;		/* this net address [group?], */
X!     u_long mask;		/* with this mask, */
X!     u_long id_addr;		/* thinks I'm at this net address, */
X!     u_long id_mask;		/* with this mask. */
X  } readdr;
X  
X  extern struct _talkd talkd[MAXDAEMON+1];
X--- 18,33 ----
X  
X  typedef struct _hostinfo {
X      struct _hostinfo *next;	/* next in linked list */
X!     ylong host_addr;		/* host address */
X      int dtype;			/* active daemon types bitmask */
X  } hostinfo;
X  
X  typedef struct _readdr {
X      struct _readdr *next;	/* next in linked list */
X!     ylong addr;		/* this net address [group?], */
X!     ylong mask;		/* with this mask, */
X!     ylong id_addr;		/* thinks I'm at this net address, */
X!     ylong id_mask;		/* with this mask. */
X  } readdr;
X  
X  extern struct _talkd talkd[MAXDAEMON+1];
X***************
X*** 45,52 ****
X  	char	l_name[NAME_SIZE];
X  	char	r_name[NAME_SIZE];
X  	char	filler;
X! 	u_long	id_num;
X! 	u_long	pid;
X  	char	r_tty[TTY_SIZE];
X  	struct	sockaddr_in addr;
X  	struct	sockaddr_in ctl_addr;
X--- 45,52 ----
X  	char	l_name[NAME_SIZE];
X  	char	r_name[NAME_SIZE];
X  	char	filler;
X! 	ylong	id_num;
X! 	ylong	pid;
X  	char	r_tty[TTY_SIZE];
X  	struct	sockaddr_in addr;
X  	struct	sockaddr_in ctl_addr;
X***************
X*** 58,64 ****
X  	char	type;
X  	char	answer;
X  	u_short	filler;
X! 	u_long	id_num;
X  	struct	sockaddr_in addr;
X  } CTL_RESPONSE;
X  
X--- 58,64 ----
X  	char	type;
X  	char	answer;
X  	u_short	filler;
X! 	ylong	id_num;
X  	struct	sockaddr_in addr;
X  } CTL_RESPONSE;
X  
X***************
X*** 68,77 ****
X  	u_char	vers;
X  	char	type;
X  	u_short	filler;
X! 	u_long	id_num;
X  	struct	sockaddr_in addr;
X  	struct	sockaddr_in ctl_addr;
X! 	u_long	pid;
X  	char	l_name[NAME_SIZE];
X  	char	l_name_filler[3];
X  	char	r_name[NAME_SIZE];
X--- 68,77 ----
X  	u_char	vers;
X  	char	type;
X  	u_short	filler;
X! 	ylong	id_num;
X  	struct	sockaddr_in addr;
X  	struct	sockaddr_in ctl_addr;
X! 	ylong	pid;
X  	char	l_name[NAME_SIZE];
X  	char	l_name_filler[3];
X  	char	r_name[NAME_SIZE];
X***************
X*** 86,92 ****
X  	char	type;
X  	char	answer;
X  	char	filler;
X! 	u_long	id_num;
X  	struct	sockaddr_in addr;
X  } CTL_RESPONSE42;
X  
X--- 86,92 ----
X  	char	type;
X  	char	answer;
X  	char	filler;
X! 	ylong	id_num;
X  	struct	sockaddr_in addr;
X  } CTL_RESPONSE42;
X  
X*** 3.0.0/cwin.h	Mon Aug 23 14:05:03 1993
X--- cwin.h	Tue Aug 24 11:16:40 1993
X***************
X*** 1,4 ****
X! /* curses.h -- curses interface (curses.c) */
X  
X  /*			   NOTICE
X   *
X--- 1,4 ----
X! /* cwin.h -- curses interface (cwin.c) */
X  
X  /*			   NOTICE
X   *
X***************
X*** 26,31 ****
X--- 26,34 ----
X  extern void	clreos_curses	( /* yuser */ );
X  extern void	scroll_curses	( /* yuser */ );
X  extern void	flush_curses	( /* yuser */ );
X+ extern void	redisplay_curses();
X+ extern void	set_raw_curses();
X+ extern void	set_cooked_curses();
X  
X  #ifndef getyx
X  # define getyx(w,y,x)	y = w->_cury, x = w->_curx
X*** 3.0.0/main.c	Mon Aug 23 14:05:03 1993
X--- main.c	Tue Aug 24 16:07:47 1993
X***************
X*** 134,146 ****
X    int argc;
X    char **argv;
X  {
X!     if(argc <= 1)
X      {
X! 	fprintf(stderr, "Usage: %s user[@hostname][#tty] [user...]\n", *argv);
X  	(void)exit(YTE_INIT);
X      }
X      argv++, argc--;
X  
X      /* set up signals */
X  
X      signal(SIGINT, got_sig);
X--- 134,195 ----
X    int argc;
X    char **argv;
X  {
X!     int xflg = 0;
X!     char *prog;
X! 
X!     /* check for a 64-bit mis-compile */
X! 
X!     if(sizeof(ylong) != 4)
X      {
X! 	if(sizeof(ylong) > 4)
X! 	{
X! 	    fprintf(stderr,
X! 		"You should have compiled ytalk with the -DY64BIT option.\n");
X! 	}
X! 	else
X! 	{
X! #ifdef Y64BIT
X! 	    fprintf(stderr,
X! 		"You should NOT have compiled ytalk with the -DY64BIT option.\n");
X! #else
X! 	    fprintf(stderr,
X! 		"Your machine doesn't support 32-bit longs.  Please mail\n");
X! 	    fprintf(stderr,
X! 		"ytalk@austin.eds.com your machine type and OS version.\n");
X! 	    (void)exit(YTE_INIT);
X! #endif
X! 	}
X! 	fprintf(stderr,
X! 	    "See the README file on how to update the appropriate\n");
X! 	fprintf(stderr,
X! 	    "makefile, then type 'make clean', 'make'.\n");
X  	(void)exit(YTE_INIT);
X      }
X+ 
X+     /* search for options */
X+ 
X+     prog = *argv;
X      argv++, argc--;
X+     while(argc > 0 && **argv == '-')
X+     {
X+ 	if(strcmp(*argv, "-x") == 0
X+ 	|| strcmp(*argv, "-nw") == 0)
X+ 	{
X+ 	    xflg++;	/* disable X from the command line */
X+ 	    argv++, argc--;
X+ 	}
X+ 	else
X+ 	    argc = 0;	/* force a Usage error */
X+     }
X  
X+     /* check for users */
X+ 
X+     if(argc <= 0)
X+     {
X+ 	fprintf(stderr, "Usage: %s [-x] user[@hostname][#tty]...\n", prog);
X+ 	(void)exit(YTE_INIT);
X+     }
X+ 
X      /* set up signals */
X  
X      signal(SIGINT, got_sig);
X***************
X*** 158,163 ****
X--- 207,214 ----
X      init_fd();
X      init_user();
X      read_ytalkrc();
X+     if(xflg)
X+ 	def_flags &= ~FL_XWIN;
X      init_term();
X      init_socket();
X      for(; argc > 0; argc--, argv++)
X*** 3.0.0/comm.c	Mon Aug 23 14:05:03 1993
X--- comm.c	Mon Aug 23 13:30:30 1993
X***************
X*** 142,148 ****
X    v2_pack *pack;
X  {
X      register yuser *u;
X!     u_long host_addr;
X      static char name[V2_NAMELEN + 1];
X      static char host[V2_HOSTLEN + 1];
X      static char estr[V2_NAMELEN + V2_HOSTLEN + 20];
X--- 142,148 ----
X    v2_pack *pack;
X  {
X      register yuser *u;
X!     ylong host_addr;
X      static char name[V2_NAMELEN + 1];
X      static char host[V2_HOSTLEN + 1];
X      static char estr[V2_NAMELEN + V2_HOSTLEN + 20];
X***************
X*** 154,160 ****
X      strncpy(host, pack->host, V2_HOSTLEN);
X      name[V2_NAMELEN] = '\0';
X      host[V2_HOSTLEN] = '\0';
X!     if((host_addr = get_host_addr(host)) == (u_long)-1)
X      {
X  	errno = 0;
X  	sprintf(errstr, "unknown host: '%s'\n", host);
X--- 154,160 ----
X      strncpy(host, pack->host, V2_HOSTLEN);
X      name[V2_NAMELEN] = '\0';
X      host[V2_HOSTLEN] = '\0';
X!     if((host_addr = get_host_addr(host)) == (ylong)-1)
X      {
X  	errno = 0;
X  	sprintf(errstr, "unknown host: '%s'\n", host);
X***************
X*** 168,174 ****
X  	    /* Don't import a user with the same name of an existing
X  	     * user at this end.  yukk.
X  	     */
X! 	    if(find_user(name, host_addr, (u_long)-1) != NULL)
X  		break;
X  	    if(!(def_flags & FL_IMPORT))
X  	    {
X--- 168,174 ----
X  	    /* Don't import a user with the same name of an existing
X  	     * user at this end.  yukk.
X  	     */
X! 	    if(find_user(name, host_addr, (ylong)-1) != NULL)
X  		break;
X  	    if(!(def_flags & FL_IMPORT))
X  	    {
X***************
X*** 193,199 ****
X  	     * send_accept() will think his version number is zero
X  	     * and won't send anything.
X  	     */
X! 	    if((u = find_user(name, host_addr, (u_long)-1)) == NULL)
X  		break;
X  	    send_accept(u, user);
X  	    break;
X--- 193,199 ----
X  	     * send_accept() will think his version number is zero
X  	     * and won't send anything.
X  	     */
X! 	    if((u = find_user(name, host_addr, (ylong)-1)) == NULL)
X  		break;
X  	    send_accept(u, user);
X  	    break;
X***************
X*** 212,218 ****
X    v3_pack *pack;
X  {
X      register yuser *u;
X!     u_long host_addr, pid;
X      static char name[V3_NAMELEN + 1];
X      static char host[V3_HOSTLEN + 1];
X      static char estr[V3_NAMELEN + V3_HOSTLEN + 20];
X--- 212,218 ----
X    v3_pack *pack;
X  {
X      register yuser *u;
X!     ylong host_addr, pid;
X      static char name[V3_NAMELEN + 1];
X      static char host[V3_HOSTLEN + 1];
X      static char estr[V3_NAMELEN + V3_HOSTLEN + 20];
X***************
X*** 221,227 ****
X      strncpy(host, pack->host, V3_HOSTLEN);
X      name[V3_NAMELEN] = '\0';
X      host[V3_HOSTLEN] = '\0';
X!     if((host_addr = get_host_addr(host)) == (u_long)-1)
X  	host_addr = ntohl(pack->host_addr);
X      pid = ntohl(pack->pid);
X  
X--- 221,227 ----
X      strncpy(host, pack->host, V3_HOSTLEN);
X      name[V3_NAMELEN] = '\0';
X      host[V3_HOSTLEN] = '\0';
X!     if((host_addr = get_host_addr(host)) == (ylong)-1)
X  	host_addr = ntohl(pack->host_addr);
X      pid = ntohl(pack->pid);
X  
X***************
X*** 524,532 ****
X  	    parm.my_rows = ntohs(parm.my_rows);
X  	    parm.my_cols = ntohs(parm.my_cols);
X  	    parm.pid = ntohl(parm.pid);
X! 	    if(user->remote.vmajor <= 2)
X! 		spew_term(me, fd, parm.rows, parm.cols);
X! 	    /* else we spew_term later */
X  	    break;
X  	default:
X  	    free_user(user);
X--- 524,530 ----
X  	    parm.my_rows = ntohs(parm.my_rows);
X  	    parm.my_cols = ntohs(parm.my_cols);
X  	    parm.pid = ntohl(parm.pid);
X! 	    /* we spew_term later */
X  	    break;
X  	default:
X  	    free_user(user);
X***************
X*** 603,609 ****
X  	show_error("connect_user: bad read");
X  	return;
X      }
X!     if(open_term(user, user->user_name) < 0)
X      {
X  	free_user(user);
X  	show_error("connect_user: open_term() failed");
X--- 601,607 ----
X  	show_error("connect_user: bad read");
X  	return;
X      }
X!     if(open_term(user, user->full_name) < 0)
X      {
X  	free_user(user);
X  	show_error("connect_user: open_term() failed");
X***************
X*** 699,710 ****
X      for(i = 1; i < bound && user->scr[user->y][x-i] != ' '; i++)
X  	temp[i] = user->scr[user->y][x-i];
X      if(i >= bound)
X! 	return;
X      move_term(user, user->y, x - i);
X      clreol_term(user);
X      newline_term(user);
X      for(i--; i >= 1; i--)
X  	addch_term(user, temp[i]);
X  }
X  
X  /* Ring a user.  If he has an auto-invitation port established then talk
X--- 697,709 ----
X      for(i = 1; i < bound && user->scr[user->y][x-i] != ' '; i++)
X  	temp[i] = user->scr[user->y][x-i];
X      if(i >= bound)
X! 	return -1;
X      move_term(user, user->y, x - i);
X      clreol_term(user);
X      newline_term(user);
X      for(i--; i >= 1; i--)
X  	addch_term(user, temp[i]);
X+     return 0;
X  }
X  
X  /* Ring a user.  If he has an auto-invitation port established then talk
X***************
X*** 812,818 ****
X  	    free_user(user);
X  	    return;
X  	}
X! 	user->last_invite = time(NULL);
X  	add_fd(user->fd, connect_user);
X  	(void)write(user->fd, me->edit, 3);	/* send the edit keys */
X  	return;
X--- 811,817 ----
X  	    free_user(user);
X  	    return;
X  	}
X! 	user->last_invite = (ylong)time(NULL);
X  	add_fd(user->fd, connect_user);
X  	(void)write(user->fd, me->edit, 3);	/* send the edit keys */
X  	return;
X***************
X*** 833,839 ****
X  	return;
X      }
X      (void)send_dgram(user, LEAVE_INVITE);
X!     user->last_invite = time(NULL);
X      if(send_announce && announce(user) < 0)
X      {
X  	(void)send_dgram(user, DELETE_INVITE);
X--- 832,838 ----
X  	return;
X      }
X      (void)send_dgram(user, LEAVE_INVITE);
X!     user->last_invite = (ylong)time(NULL);
X      if(send_announce && announce(user) < 0)
X      {
X  	(void)send_dgram(user, DELETE_INVITE);
X***************
X*** 851,862 ****
X  house_clean()
X  {
X      register yuser *u, *next;
X!     long t;
X      static char estr[80];
X!     static u_long last_auto = 0;
X      int answer;
X  
X!     t = time(NULL);
X  
X      if(t - last_auto >= 30)
X      {
X--- 850,861 ----
X  house_clean()
X  {
X      register yuser *u, *next;
X!     ylong t;
X      static char estr[80];
X!     static ylong last_auto = 0;
X      int answer;
X  
X!     t = (ylong)time(NULL);
X  
X      if(t - last_auto >= 30)
X      {
X***************
X*** 874,880 ****
X  	if(t - u->last_invite >= 30)
X  	{
X  	    (void)send_dgram(u, LEAVE_INVITE);
X! 	    u->last_invite = t = time(NULL);
X  	    if(!(def_flags & FL_RING))
X  	    {
X  		if(input_flag)
X--- 873,879 ----
X  	if(t - u->last_invite >= 30)
X  	{
X  	    (void)send_dgram(u, LEAVE_INVITE);
X! 	    u->last_invite = t = (ylong)time(NULL);
X  	    if(!(def_flags & FL_RING))
X  	    {
X  		if(input_flag)
X***************
X*** 881,887 ****
X  		    continue;
X  		sprintf(estr, "Rering %s?", u->full_name);
X  		answer = yes_no(estr);
X! 		t = time(NULL);
X  		if(answer == 'n')
X  		    continue;
X  	    }
X--- 880,886 ----
X  		    continue;
X  		sprintf(estr, "Rering %s?", u->full_name);
X  		answer = yes_no(estr);
X! 		t = (ylong)time(NULL);
X  		if(answer == 'n')
X  		    continue;
X  	    }
X***************
X*** 948,955 ****
X  	    send_oob(u->fd, &v3w, V3_WINCHLEN);
X  }
X  
X  void
X! send_users(buf, len)
X    ychar *buf;
X    register int len;
X  {
X--- 947,958 ----
X  	    send_oob(u->fd, &v3w, V3_WINCHLEN);
X  }
X  
X+ /* Send some output to a given user.  Sends the output to all connected
X+  * users if the given user is either "me" or NULL.
X+  */
X  void
X! send_users(user, buf, len)
X!   yuser *user;
X    ychar *buf;
X    register int len;
X  {
X***************
X*** 971,981 ****
X  	if(*b == V3_OOB)
X  	    *(o++) = V3_OOB;
X      }
X!     for(u = connect_list; u; u = u->next)
X! 	if(u->remote.vmajor > 2)
X! 	    (void)write(u->fd, o_buf, o - o_buf);
X! 	else
X! 	    (void)write(u->fd, buf, b - buf);
X  }
X  
X  /* Display user input.  Emulate ANSI.
X--- 974,996 ----
X  	if(*b == V3_OOB)
X  	    *(o++) = V3_OOB;
X      }
X! 
X!     if(user && user != me)
X!     {
X! 	if(user->fd > 0)	/* just to be sure... */
X! 	{
X! 	    if(user->remote.vmajor > 2)
X! 		(void)write(user->fd, o_buf, o - o_buf);
X! 	    else
X! 		(void)write(user->fd, buf, b - buf);
X! 	}
X!     }
X!     else
X! 	for(u = connect_list; u; u = u->next)
X! 	    if(u->remote.vmajor > 2)
X! 		(void)write(u->fd, o_buf, o - o_buf);
X! 	    else
X! 		(void)write(u->fd, buf, b - buf);
X  }
X  
X  /* Display user input.  Emulate ANSI.
X***************
X*** 1136,1149 ****
X      {
X  	if(*buf >= ' ' && *buf <= '~')
X  	{
X! 	    if((user->flags & FL_WRAP) && user->x + 1 >= user->cols)
X  	    {
X! 		if(*buf == ' ')
X! 		    newline_term(user);
X  		else
X  		{
X- 		    word_wrap(user);
X  		    addch_term(user, *buf);
X  		}
X  	    }
X  	    else
X--- 1151,1174 ----
X      {
X  	if(*buf >= ' ' && *buf <= '~')
X  	{
X! 	    if(user->x + 1 >= user->cols)
X  	    {
X! 		if(user->flags & FL_WRAP)
X! 		{
X! 		    if(*buf == ' ')
X! 			newline_term(user);
X! 		    else if(word_wrap(user) >= 0)
X! 			addch_term(user, *buf);
X! 		    else
X! 		    {
X! 			addch_term(user, *buf);
X! 			newline_term(user);
X! 		    }
X! 		}
X  		else
X  		{
X  		    addch_term(user, *buf);
X+ 		    newline_term(user);
X  		}
X  	    }
X  	    else
X***************
X*** 1199,1205 ****
X  /* Process keyboard input.
X   */
X  void
X! my_input(buf, len)
X    register ychar *buf;
X    int len;
X  {
X--- 1224,1231 ----
X  /* Process keyboard input.
X   */
X  void
X! my_input(user, buf, len)
X!   yuser *user;
X    register ychar *buf;
X    int len;
X  {
X***************
X*** 1246,1268 ****
X  	{
X  	    /* do normal input */
X  
X! 	    c = buf;
X! 	    for(; len > 0; buf++, len--)
X  	    {
X! 		if(*buf == me->old_rub)
X! 		    *buf = me->RUB;
X! 		else if(*buf == '\r')
X! 		    *buf = '\n';
X! 		else if(*buf == 3)	/* Ctrl-C */
X! 		    bail(0);
X! 		else if(*buf == 27)	/* Esc */
X! 		    break;
X  	    }
X- 	    if((i = buf - c) > 0)
X- 	    {
X- 		show_input(me, c, i);
X- 		send_users(c, i);
X- 	    }
X  	}
X  
X  	/* start a menu if necessary */
X--- 1272,1314 ----
X  	{
X  	    /* do normal input */
X  
X! 	    while(len > 0)
X  	    {
X! 		c = buf;
X! 		for(; len > 0; buf++, len--)
X! 		{
X! 		    if(*buf == me->old_rub)
X! 			*buf = me->RUB;
X! 		    else if(*buf == '\r')
X! 			*buf = '\n';
X! 		    else if(*buf == 3)	/* Ctrl-C */
X! 			bail(0);
X! 		    else if(*buf == 27)	/* Esc */
X! 			break;
X! 		    else if(*buf == 12 || *buf == 18) /* ^L or ^R */
X! 			break;
X! 		}
X! 		if((i = buf - c) > 0)
X! 		{
X! 		    if(user != NULL && user != me && !(def_flags & FL_ASIDE))
X! 			putc(7, stderr);
X! 		    else
X! 		    {
X! 			show_input(me, c, i);
X! 			send_users(user, c, i);
X! 		    }
X! 		}
X! 		if(len > 0)	/* we broke for a special char */
X! 		{
X! 		    if(*buf == 27) /* ESC */
X! 			break;
X! 		    if(*buf == 12 || *buf == 18) /* ^L or ^R */
X! 		    {
X! 			redraw_all_terms();
X! 			buf++, len--;
X! 		    }
X! 		}
X  	    }
X  	}
X  
X  	/* start a menu if necessary */
X***************
X*** 1269,1276 ****
X  
X  	if(len > 0)
X  	{
X! 	    buf++;
X! 	    len--;
X  	    show_main_menu();
X  	    if(len <= 0)
X  		update_menu();
X--- 1315,1321 ----
X  
X  	if(len > 0)
X  	{
X! 	    buf++, len--;
X  	    show_main_menu();
X  	    if(len <= 0)
X  		update_menu();
X***************
X*** 1280,1286 ****
X  
X  void
X  lock_flags(flags)
X!   u_long flags;
X  {
X      register yuser *u;
X  
X--- 1325,1331 ----
X  
X  void
X  lock_flags(flags)
X!   ylong flags;
X  {
X      register yuser *u;
X  
X*** 3.0.0/fd.c	Mon Aug 23 14:05:04 1993
X--- fd.c	Tue Aug 24 11:12:15 1993
X***************
X*** 103,127 ****
X  
X  /* -- MAIN LOOPS -- */
X  
X! static long lastping, curtime;
X  
X  void
X  main_loop()
X  {
X      register int fd, rc;
X-     int mask, old_mask;
X      struct timeval tv;
X  
X      /* Some signals need to be blocked while doing internal
X       * processing, else some craziness might occur.
X       */
X  
X      mask = 0;
X  
X! #ifdef SIGWINCH
X      mask |= sigmask(SIGWINCH);
X  #endif
X  
X      /* For housecleaning to occur every CLEAN_INTERVAL seconds, we make
X       * our own little timer system.  SIGALRM is nice; in fact it's so
X       * useful that we'll be using it in other parts of YTalk.  Since
X--- 103,139 ----
X  
X  /* -- MAIN LOOPS -- */
X  
X! static ylong lastping, curtime;
X  
X  void
X  main_loop()
X  {
X      register int fd, rc;
X      struct timeval tv;
X+ #ifndef Y_USE_SIGHOLD
X+     int mask, old_mask;
X+ #endif
X  
X      /* Some signals need to be blocked while doing internal
X       * processing, else some craziness might occur.
X       */
X  
X+ #ifndef Y_USE_SIGHOLD
X+ 
X      mask = 0;
X  
X! # ifdef SIGWINCH
X      mask |= sigmask(SIGWINCH);
X+ # endif
X+ 
X  #endif
X  
X+ #if defined(SIGCHLD)
X+     signal(SIGCHLD, SIG_IGN);
X+ #elif defined(SIGCLD)
X+     signal(SIGCLD, SIG_IGN);
X+ #endif
X+ 
X      /* For housecleaning to occur every CLEAN_INTERVAL seconds, we make
X       * our own little timer system.  SIGALRM is nice; in fact it's so
X       * useful that we'll be using it in other parts of YTalk.  Since
X***************
X*** 129,135 ****
X       */
X  
X      house_clean();
X!     curtime = lastping = time(NULL);
X      for(;;)
X      {
X  	/* check if we're done */
X--- 141,147 ----
X       */
X  
X      house_clean();
X!     curtime = lastping = (ylong)time(NULL);
X      for(;;)
X      {
X  	/* check if we're done */
X***************
X*** 154,160 ****
X--- 166,178 ----
X  
X  	/* block signals while doing internal processing */
X  
X+ #ifdef Y_USE_SIGHOLD
X+ # ifdef SIGWINCH
X+ 	sighold(SIGWINCH);
X+ # endif
X+ #else
X  	old_mask = sigblock(mask);
X+ #endif
X  
X  	/* process file descriptors with input waiting */
X  
X***************
X*** 170,185 ****
X  
X  	/* check timer */
X  
X! 	curtime = time(NULL);
X  	if(curtime - lastping >= CLEAN_INTERVAL)
X  	{
X  	    house_clean();
X! 	    lastping = time(NULL);
X  	}
X  
X  	/* re-allow signals */
X  
X  	sigsetmask(old_mask);
X  	if(user_winch)
X  	{
X  	    /* This is a cute hack that updates a user menu
X--- 188,209 ----
X  
X  	/* check timer */
X  
X! 	curtime = (ylong)time(NULL);
X  	if(curtime - lastping >= CLEAN_INTERVAL)
X  	{
X  	    house_clean();
X! 	    lastping = (ylong)time(NULL);
X  	}
X  
X  	/* re-allow signals */
X  
X+ #ifdef Y_USE_SIGHOLD
X+ # ifdef SIGWINCH
X+ 	sigrelse(SIGWINCH);
X+ # endif
X+ #else
X  	sigsetmask(old_mask);
X+ #endif
X  	if(user_winch)
X  	{
X  	    /* This is a cute hack that updates a user menu
X***************
X*** 248,259 ****
X  
X  	/* check timer */
X  
X! 	curtime = time(NULL);
X  	if(curtime - lastping >= CLEAN_INTERVAL)
X  	{
X  	    input_flag = 1;
X  	    house_clean();
X! 	    lastping = time(NULL);
X  	}
X      }
X      input_flag = 0;
X--- 272,283 ----
X  
X  	/* check timer */
X  
X! 	curtime = (ylong)time(NULL);
X  	if(curtime - lastping >= CLEAN_INTERVAL)
X  	{
X  	    input_flag = 1;
X  	    house_clean();
X! 	    lastping = (ylong)time(NULL);
X  	}
X      }
X      input_flag = 0;
X*** 3.0.0/menu.c	Mon Aug 23 14:05:04 1993
X--- menu.c	Mon Aug 23 11:31:43 1993
X***************
X*** 175,185 ****
X    ychar key;
X  {
X      register yuser *u;
X!     u_long old_flags;
X  
X      old_flags = def_flags;
X      switch(key)
X      {
X  	case 's':	/* toggle scrolling */
X  	    def_flags ^= FL_SCROLL;
X  	    break;
X--- 175,188 ----
X    ychar key;
X  {
X      register yuser *u;
X!     ylong old_flags;
X  
X      old_flags = def_flags;
X      switch(key)
X      {
X+ 	case 'a':	/* toggle asides */
X+ 	    def_flags ^= FL_ASIDE;
X+ 	    break;
X  	case 's':	/* toggle scrolling */
X  	    def_flags ^= FL_SCROLL;
X  	    break;
X***************
X*** 713,718 ****
X--- 716,732 ----
X      option_menu[i].func = option_menu_sel;
X      option_menu[i].key = 'r';
X      i++;
X+ 
X+     if(term_does_asides())
X+     {
X+ 	if(def_flags & FL_ASIDE)
X+ 	    option_menu[i].item = "turn asides off";
X+ 	else
X+ 	    option_menu[i].item = "turn asides on";
X+ 	option_menu[i].func = option_menu_sel;
X+ 	option_menu[i].key = 'a';
X+ 	i++;
X+     }
X  
X      return show_menu(option_menu, i);
X  }
X*** 3.0.0/exec.c	Mon Aug 23 14:05:04 1993
X--- exec.c	Tue Aug 24 14:40:49 1993
X***************
X*** 102,108 ****
X  	return;
X      }
X      show_input(me, buf, rc);
X!     send_users(buf, rc);
X  }
X  
X  static void
X--- 102,108 ----
X  	return;
X      }
X      show_input(me, buf, rc);
X!     send_users(me, buf, rc);
X  }
X  
X  static void
X***************
X*** 147,157 ****
X  	msg_term(me, "cannot get pseudo terminal");
X  	return;
X      }
X!     if((shell = getenv("SHELL")) == NULL)
X  	shell = "/bin/sh";
X      calculate_size(&prows, &pcols);
X      if((pid = fork()) == 0)
X      {
X  	close_all();
X          if(setsid() < 0)
X              exit(-1);
X--- 147,158 ----
X  	msg_term(me, "cannot get pseudo terminal");
X  	return;
X      }
X!     if((shell = (char *)getenv("SHELL")) == NULL)
X  	shell = "/bin/sh";
X      calculate_size(&prows, &pcols);
X      if((pid = fork()) == 0)
X      {
X+ 	close(fd);
X  	close_all();
X          if(setsid() < 0)
X              exit(-1);
X***************
X*** 161,166 ****
X--- 162,173 ----
X          dup2(fd, 1);
X          dup2(fd, 2);
X  
X+ 	/* tricky bit -- ignore WINCH */
X+ 
X+ #ifdef SIGWINCH
X+ 	signal(SIGWINCH, SIG_IGN);
X+ #endif
X+ 
X  	/* set terminal characteristics */
X  
X  	set_terminal_flags(fd);
X***************
X*** 188,193 ****
X--- 195,201 ----
X      pfd = fd;
X      running_process = 1;
X      lock_flags(FL_RAW | FL_SCROLL);
X+     set_raw_term();
X      add_fd(fd, exec_input);
X  }
X  
X***************
X*** 211,216 ****
X--- 219,225 ----
X      close(pfd);
X      running_process = 0;
X      unlock_flags();
X+     set_cooked_term();
X      end_win_region(me);
X  }
X  
X***************
X*** 223,231 ****
X--- 232,250 ----
X  
X      if(!running_process)
X  	return;
X+ 
X+     /* if the winch has no effect, return now */
X+ 
X      calculate_size(&rows, &cols);
X      if(rows == prows && cols == pcols)
X+     {
X+ 	if(prows != me->rows || pcols != me->cols)
X+ 	    set_win_region(me, prows, pcols);
X  	return;
X+     }
X+ 
X+     /* oh well -- redo everything */
X+ 
X      prows = rows;
X      pcols = cols;
X      set_terminal_size(pfd, prows, pcols);
X*** 3.0.0/rc.c	Mon Aug 23 14:05:05 1993
X--- rc.c	Tue Aug 24 14:41:04 1993
X***************
X*** 46,52 ****
X  set_option(opt, value)
X    char *opt, *value;
X  {
X!     u_long mask = 0L;
X      int set_it;
X  
X      if(strcmp(value, "true") == 0 || strcmp(value, "on") == 0)
X--- 46,52 ----
X  set_option(opt, value)
X    char *opt, *value;
X  {
X!     ylong mask = 0;
X      int set_it;
X  
X      if(strcmp(value, "true") == 0 || strcmp(value, "on") == 0)
X***************
X*** 81,87 ****
X      || strcmp(opt, "autoinvite") == 0
X      || strcmp(opt, "aiv") == 0
X      || strcmp(opt, "av") == 0)
X! 	mask |= FL_IMPORT;
X  
X      if(strcmp(opt, "ring") == 0
X      || strcmp(opt, "auto-ring") == 0
X--- 81,87 ----
X      || strcmp(opt, "autoinvite") == 0
X      || strcmp(opt, "aiv") == 0
X      || strcmp(opt, "av") == 0)
X! 	mask |= FL_INVITE;
X  
X      if(strcmp(opt, "ring") == 0
X      || strcmp(opt, "auto-ring") == 0
X***************
X*** 98,103 ****
X--- 98,108 ----
X      || strcmp(opt, "x") == 0
X      || strcmp(opt, "X") == 0)
X  	mask |= FL_XWIN;
X+ 
X+     if(strcmp(opt, "asides") == 0
X+     || strcmp(opt, "aside") == 0
X+     || strcmp(opt, "as") == 0)
X+ 	mask |= FL_ASIDE;
X      
X      if(!mask)
X  	return -1;
X***************
X*** 110,137 ****
X      return 0;
X  }
X  
X! /* ---- global functions ---- */
X! 
X! void
X! read_ytalkrc()
X  {
X      FILE *fp;
X      char *buf, *ptr;
X      char *w, *arg1, *arg2, *arg3;
X      int line_no, errline;
X-     yuser *u;
X  
X!     if((w = getenv("HOME")) == NULL)
X! 	return;
X!     buf = get_mem(BUFSIZ);
X!     sprintf(buf, "%s/.ytalkrc", w);
X!     if((fp = fopen(buf, "r")) == NULL)
X      {
X  	if(errno != ENOENT)
X! 	    show_error(buf);
X! 	free(buf);
X  	return;
X      }
X  
X      line_no = errline = 0;
X      while(fgets(buf, BUFSIZ, fp) != NULL)
X--- 115,136 ----
X      return 0;
X  }
X  
X! static void
X! read_rcfile(fname)
X!   char *fname;
X  {
X      FILE *fp;
X      char *buf, *ptr;
X      char *w, *arg1, *arg2, *arg3;
X      int line_no, errline;
X  
X!     if((fp = fopen(fname, "r")) == NULL)
X      {
X  	if(errno != ENOENT)
X! 	    show_error(fname);
X  	return;
X      }
X+     buf = get_mem(BUFSIZ);
X  
X      line_no = errline = 0;
X      while(fgets(buf, BUFSIZ, fp) != NULL)
X***************
X*** 177,183 ****
X      }
X      if(errline)
X      {
X! 	sprintf(errstr, ".ytalkrc: syntax error at line %d", errline);
X  	errno = 0;
X  	show_error(errstr);
X      }
X--- 176,182 ----
X      }
X      if(errline)
X      {
X! 	sprintf(errstr, "%s: syntax error at line %d", fname, errline);
X  	errno = 0;
X  	show_error(errstr);
X      }
X***************
X*** 184,189 ****
X--- 183,214 ----
X  
X      free(buf);
X      fclose(fp);
X+ }
X+ 
X+ /* ---- global functions ---- */
X+ 
X+ void
X+ read_ytalkrc()
X+ {
X+     char *w;
X+     yuser *u;
X+     char fname[256];
X+ 
X+     /* read the system ytalkrc file */
X+ 
X+ #ifdef SYSTEM_YTALKRC
X+     read_rcfile(SYSTEM_YTALKRC);
X+ #endif
X+ 
X+     /* read the user's ytalkrc file */
X+ 
X+     if((w = (char *)getenv("HOME")) != NULL)
X+     {
X+ 	sprintf(fname, "%s/.ytalkrc", w);
X+ 	read_rcfile(fname);
X+     }
X+ 
X+     /* set all default flags */
X  
X      for(u = user_list; u != NULL; u = u->unext)
X  	if(!(u->flags & FL_LOCKED))
X*** 3.0.0/socket.c	Mon Aug 23 14:05:05 1993
X--- socket.c	Sun Aug 22 21:03:21 1993
X***************
X*** 35,42 ****
X  
X  static int autofd = -1;			/* auto invite socket fd */
X  static struct sockaddr_in autosock;	/* auto invite socket */
X! static long autoid[MAXDAEMON+1];	/* auto invite seq numbers */
X! static u_long announce_id = 0;		/* announce sequence id */
X  static readdr *readdr_list = NULL;	/* list of re-addresses */
X  
X  #define IN_ADDR(s)	((s).sin_addr.s_addr)
X--- 35,42 ----
X  
X  static int autofd = -1;			/* auto invite socket fd */
X  static struct sockaddr_in autosock;	/* auto invite socket */
X! static ylong autoid[MAXDAEMON+1];	/* auto invite seq numbers */
X! static ylong announce_id = 0;		/* announce sequence id */
X  static readdr *readdr_list = NULL;	/* list of re-addresses */
X  
X  #define IN_ADDR(s)	((s).sin_addr.s_addr)
X***************
X*** 188,194 ****
X  	show_error("init_autoport: listen() failed");
X  	return;
X      }
X!     (void)memset(autoid, 0, (MAXDAEMON + 1) * sizeof(long));
X      add_fd(autofd, read_autoport);
X  }
X  
X--- 188,194 ----
X  	show_error("init_autoport: listen() failed");
X  	return;
X      }
X!     (void)memset(autoid, 0, (MAXDAEMON + 1) * sizeof(ylong));
X      add_fd(autofd, read_autoport);
X  }
X  
X***************
X*** 198,204 ****
X  static void
X  place_my_address(sock, addr)
X    struct sockaddr_in *sock;
X!   register u_long addr;
X  {
X      register readdr *r;
X  
X--- 198,204 ----
X  static void
X  place_my_address(sock, addr)
X    struct sockaddr_in *sock;
X!   register ylong addr;
X  {
X      register readdr *r;
X  
X***************
X*** 220,226 ****
X   */
X  static int
X  sendit(addr, d)
X!   u_long addr;	/* host internet address */
X    int d;	/* daemon number */
X  {
X      int n;
X--- 220,226 ----
X   */
X  static int
X  sendit(addr, d)
X!   ylong addr;	/* host internet address */
X    int d;	/* daemon number */
X  {
X      int n;
X***************
X*** 379,385 ****
X   */
X  static int
X  find_daemon(addr)
X!   u_long addr;
X  {
X      register hostinfo *h;
X      register int n, i, d;
X--- 379,385 ----
X   */
X  static int
X  find_daemon(addr)
X!   ylong addr;
X  {
X      register hostinfo *h;
X      register int n, i, d;
X***************
X*** 468,486 ****
X      return 0;
X  }
X  
X! static u_long
X  make_net_mask(addr)
X!   u_long addr;
X  {
X!     if(addr & (u_long)0xff)
X! 	return (u_long)0xffffffff;
X!     if(addr & (u_long)0xffff)
X! 	return (u_long)0xffffff00;
X!     if(addr & (u_long)0xffffff)
X! 	return (u_long)0xffff0000;
X      if(addr)
X! 	return (u_long)0xff000000;
X!     return (u_long)0;
X  }
X  
X  /* ---- global functions ---- */
X--- 468,486 ----
X      return 0;
X  }
X  
X! static ylong
X  make_net_mask(addr)
X!   ylong addr;
X  {
X!     if(addr & (ylong)0xff)
X! 	return (ylong)0xffffffff;
X!     if(addr & (ylong)0xffff)
X! 	return (ylong)0xffffff00;
X!     if(addr & (ylong)0xffffff)
X! 	return (ylong)0xffff0000;
X      if(addr)
X! 	return (ylong)0xff000000;
X!     return (ylong)0;
X  }
X  
X  /* ---- global functions ---- */
X***************
X*** 540,546 ****
X    yuser *user;
X    u_char type;
X  {
X!     u_long addr;
X      int d;
X  
X      /* set up the message type and where to send it */
X--- 540,546 ----
X    yuser *user;
X    u_char type;
X  {
X!     ylong addr;
X      int d;
X  
X      /* set up the message type and where to send it */
X***************
X*** 822,834 ****
X  
X  /* Find a host's address.
X   */
X! u_long
X  get_host_addr(hostname)
X    char *hostname;
X  {
X      struct hostent *host;
X!     u_long addr;
X!     u_long inet_addr();
X  
X      if((host = (struct hostent *) gethostbyname(hostname)) != NULL)
X      {
X--- 822,834 ----
X  
X  /* Find a host's address.
X   */
X! ylong
X  get_host_addr(hostname)
X    char *hostname;
X  {
X      struct hostent *host;
X!     ylong addr;
X!     ylong inet_addr();
X  
X      if((host = (struct hostent *) gethostbyname(hostname)) != NULL)
X      {
X***************
X*** 836,847 ****
X  	{
X  	    sprintf(errstr, "Bad IN addr: %s\n", hostname);
X  	    show_error(errstr);
X! 	    return (u_long)-1;
X  	}
X  	(void)memcpy(&addr, host->h_addr, sizeof(addr));
X      }
X!     else if((addr = inet_addr(hostname)) == (u_long)-1)
X! 	return (u_long)-1;
X      return addr;
X  }
X  
X--- 836,847 ----
X  	{
X  	    sprintf(errstr, "Bad IN addr: %s\n", hostname);
X  	    show_error(errstr);
X! 	    return (ylong)-1;
X  	}
X  	(void)memcpy(&addr, host->h_addr, sizeof(addr));
X      }
X!     else if((addr = (ylong)inet_addr(hostname)) == (ylong)-1)
X! 	return (ylong)-1;
X      return addr;
X  }
X  
X***************
X*** 849,855 ****
X   */
X  char *
X  host_name(addr)
X!   u_long addr;
X  {
X      struct hostent *host;
X      char *inet_ntoa();
X--- 849,855 ----
X   */
X  char *
X  host_name(addr)
X!   ylong addr;
X  {
X      struct hostent *host;
X      char *inet_ntoa();
X***************
X*** 873,894 ****
X    char *from_id, *to_id, *on_id;
X  {
X      register readdr *new;
X!     u_long from_addr, to_addr, on_addr;
X!     u_long from_mask, to_mask, on_mask;
X  
X!     if((from_addr = get_host_addr(from_id)) == (u_long)-1)
X      {
X  	sprintf(errstr, "Unknown host: '%s'\n", from_id);
X  	show_error(errstr);
X  	return;
X      }
X!     if((to_addr = get_host_addr(to_id)) == (u_long)-1)
X      {
X  	sprintf(errstr, "Unknown host: '%s'\n", to_id);
X  	show_error(errstr);
X  	return;
X      }
X!     if((on_addr = get_host_addr(on_id)) == (u_long)-1)
X      {
X  	sprintf(errstr, "Unknown host: '%s'\n", on_id);
X  	show_error(errstr);
X--- 873,894 ----
X    char *from_id, *to_id, *on_id;
X  {
X      register readdr *new;
X!     ylong from_addr, to_addr, on_addr;
X!     ylong from_mask, to_mask, on_mask;
X  
X!     if((from_addr = get_host_addr(from_id)) == (ylong)-1)
X      {
X  	sprintf(errstr, "Unknown host: '%s'\n", from_id);
X  	show_error(errstr);
X  	return;
X      }
X!     if((to_addr = get_host_addr(to_id)) == (ylong)-1)
X      {
X  	sprintf(errstr, "Unknown host: '%s'\n", to_id);
X  	show_error(errstr);
X  	return;
X      }
X!     if((on_addr = get_host_addr(on_id)) == (ylong)-1)
X      {
X  	sprintf(errstr, "Unknown host: '%s'\n", on_id);
X  	show_error(errstr);
X*** 3.0.0/user.c	Mon Aug 23 14:05:05 1993
X--- user.c	Tue Aug 24 15:44:59 1993
X***************
X*** 27,34 ****
X  yuser *wait_list;		/* list of connected users */
X  yuser *fd_to_user[MAX_FILES];	/* convert file descriptors to users */
X  yuser *key_to_user[128];	/* convert menu ident chars to users */
X! u_long def_flags = 0L;		/* default FL_* flags */
X! static u_long daemon_id;	/* running daemon ID counter */
X  
X  /* ---- local functions ----- */
X  
X--- 27,34 ----
X  yuser *wait_list;		/* list of connected users */
X  yuser *fd_to_user[MAX_FILES];	/* convert file descriptors to users */
X  yuser *key_to_user[128];	/* convert menu ident chars to users */
X! ylong def_flags = 0L;		/* default FL_* flags */
X! static ylong daemon_id;	/* running daemon ID counter */
X  
X  /* ---- local functions ----- */
X  
X***************
X*** 41,47 ****
X      register struct passwd *pw;
X      passwd_opened = 1;
X      if((pw = getpwnam(name)) == NULL)
X! 	return -1;
X      return pw->pw_uid;
X  }
X  
X--- 41,47 ----
X      register struct passwd *pw;
X      passwd_opened = 1;
X      if((pw = getpwnam(name)) == NULL)
X! 	return -60000;	/* for most archs, an impossible user ID */
X      return pw->pw_uid;
X  }
X  
X***************
X*** 59,69 ****
X  static void
X  close_passwd()
X  {
X-     extern void endpwent();
X- 
X      if(passwd_opened)
X      {
X! 	endpwent();
X  	passwd_opened = 0;
X      }
X  }
X--- 59,67 ----
X  static void
X  close_passwd()
X  {
X      if(passwd_opened)
X      {
X! 	(void)endpwent();
X  	passwd_opened = 0;
X      }
X  }
X***************
X*** 147,157 ****
X      /* get my username */
X  
X      if((my_name = getlogin()) != NULL)
X! 	if(my_uid < 0 || user_id(my_name) != my_uid)
X  	    my_name = NULL;
X      if(my_name == NULL)
X! 	my_name = user_name(getuid());
X      if(my_name == NULL)
X      {
X  	show_error("Who are you?");
X  	bail(YTE_ERROR);
X--- 145,157 ----
X      /* get my username */
X  
X      if((my_name = getlogin()) != NULL)
X! 	if(user_id(my_name) != my_uid)
X  	    my_name = NULL;
X      if(my_name == NULL)
X! 	my_name = user_name(my_uid);
X      if(my_name == NULL)
X+ 	my_name = getlogin();
X+     if(my_name == NULL || my_name[0] == '\0')
X      {
X  	show_error("Who are you?");
X  	bail(YTE_ERROR);
X***************
X*** 184,190 ****
X    char *name, *hostname, *tty;
X  {
X      register yuser *out, *u;
X!     u_long addr;
X  
X      /* find the host address */
X  
X--- 184,190 ----
X    char *name, *hostname, *tty;
X  {
X      register yuser *out, *u;
X!     ylong addr;
X  
X      /* find the host address */
X  
X***************
X*** 193,199 ****
X  	hostname = me->host_name;
X  	addr = me->host_addr;
X      }
X!     else if((addr = get_host_addr(hostname)) == (u_long)-1)
X      {
X  	sprintf(errstr, "new_user: bad host: '%s'\n", hostname);
X  	show_error(errstr);
X--- 193,199 ----
X  	hostname = me->host_name;
X  	addr = me->host_addr;
X      }
X!     else if((addr = get_host_addr(hostname)) == (ylong)-1)
X      {
X  	sprintf(errstr, "new_user: bad host: '%s'\n", hostname);
X  	show_error(errstr);
X***************
X*** 298,324 ****
X  }
X  
X  /* Find a user by name/host/pid.  If name is NULL, then it is not checked.
X!  * If host_addr is (u_long)-1 then it is not checked.  If pid is (u_long)-1
X   * then it is not checked.
X   */
X  yuser *
X  find_user(name, host_addr, pid)
X    char *name;
X!   u_long host_addr, pid;
X  {
X      register yuser *u;
X  
X      for(u = user_list; u; u = u->unext)
X  	if(name == NULL || strcmp(u->user_name, name) == 0)
X! 	    if(host_addr == (u_long)-1 || u->host_addr == host_addr)
X! 		if(pid == (u_long)-1 || u->remote.pid == pid)
X  		    return u;
X      
X      /* it could be _me_! */
X  
X      if(name == NULL || strcmp(me->user_name, name) == 0)
X! 	if(host_addr == (u_long)-1 || me->host_addr == host_addr)
X! 	    if(pid == (u_long)-1 || me->remote.pid == pid)
X  		return me;
X  
X      /* nobody I know */
X--- 298,324 ----
X  }
X  
X  /* Find a user by name/host/pid.  If name is NULL, then it is not checked.
X!  * If host_addr is (ylong)-1 then it is not checked.  If pid is (ylong)-1
X   * then it is not checked.
X   */
X  yuser *
X  find_user(name, host_addr, pid)
X    char *name;
X!   ylong host_addr, pid;
X  {
X      register yuser *u;
X  
X      for(u = user_list; u; u = u->unext)
X  	if(name == NULL || strcmp(u->user_name, name) == 0)
X! 	    if(host_addr == (ylong)-1 || u->host_addr == host_addr)
X! 		if(pid == (ylong)-1 || u->remote.pid == pid)
X  		    return u;
X      
X      /* it could be _me_! */
X  
X      if(name == NULL || strcmp(me->user_name, name) == 0)
X! 	if(host_addr == (ylong)-1 || me->host_addr == host_addr)
X! 	    if(pid == (ylong)-1 || me->remote.pid == pid)
X  		return me;
X  
X      /* nobody I know */
X*** 3.0.0/term.c	Mon Aug 23 14:05:05 1993
X--- term.c	Tue Aug 24 11:00:02 1993
X***************
X*** 26,32 ****
X  #else
X  # include <termios.h>
X  #endif
X! #include "curses.h"
X  #include "xwin.h"
X  #include "menu.h"
X  
X--- 26,32 ----
X  #else
X  # include <termios.h>
X  #endif
X! #include "cwin.h"
X  #include "xwin.h"
X  #include "menu.h"
X  
X***************
X*** 170,176 ****
X  
X      /* set me up a terminal */
X  
X!     sprintf(tmpstr, "YTalk version %d.%d", VMAJOR, VMINOR);
X      if(open_term(me, tmpstr) < 0)
X      {
X  	end_term();
X--- 170,176 ----
X  
X      /* set me up a terminal */
X  
X!     sprintf(tmpstr, "YTalk version %d.%d (%d)", VMAJOR, VMINOR, VPATCH);
X      if(open_term(me, tmpstr) < 0)
X      {
X  	end_term();
X***************
X*** 386,391 ****
X--- 386,392 ----
X  {
X      register int i;
X      register ychar *c;
X+     int sy, sx;
X  
X      if(user->sc_bot > user->sc_top)
X      {
X***************
X*** 406,413 ****
X--- 407,417 ----
X      }
X      else
X      {
X+ 	sy = user->y;
X+ 	sx = user->x;
X  	move_term(user, user->sc_top, 0);
X  	clreol_term(user);
X+ 	move_term(user, sy, sx);
X      }
X  }
X  
X***************
X*** 419,424 ****
X--- 423,429 ----
X  {
X      register int i;
X      register ychar *c;
X+     int sy, sx;
X  
X      if(user->sc_bot > user->sc_top)
X      {
X***************
X*** 439,446 ****
X--- 444,454 ----
X      }
X      else
X      {
X+ 	sy = user->y;
X+ 	sx = user->x;
X  	move_term(user, user->sc_top, 0);
X  	clreol_term(user);
X+ 	move_term(user, sy, sx);
X      }
X  }
X  
X***************
X*** 1022,1027 ****
X--- 1030,1037 ----
X      old_width = user->cols;
X      user->rows = user->t_rows;
X      user->cols = user->t_cols;
X+     user->sc_top = 0;
X+     user->sc_bot = user->rows - 1;
X      if(old_height < user->t_rows || old_width < user->t_cols)
X  	draw_box(user, old_height, old_width, ' ');
X      user->region_set = 0;
X***************
X*** 1166,1169 ****
X--- 1176,1239 ----
X      if(n >= width)
X  	return 0;
X      return (width - n) >> 1;
X+ }
X+ 
X+ void
X+ redraw_all_terms()
X+ {
X+     register yuser *u;
X+ 
X+     switch(term_type)
X+     {
X+ 	case 1:		/* curses */
X+ 	    redisplay_curses();
X+ 	    break;
X+ 	default:
X+ 	    redraw_term(me, 0);
X+ 	    flush_term(me);
X+ 	    for(u = connect_list; u; u = u->next)
X+ 	    {
X+ 		redraw_term(u, 0);
X+ 		flush_term(u);
X+ 	    }
X+     }
X+ }
X+ 
X+ void
X+ set_raw_term()
X+ {
X+     /* only some terminal systems need to do this */
X+ 
X+     switch(term_type)
X+     {
X+ 	case 1:		/* curses */
X+ 	    set_raw_curses();
X+ 	    break;
X+     }
X+ }
X+ 
X+ void
X+ set_cooked_term()
X+ {
X+     /* only some terminal systems need to do this */
X+ 
X+     switch(term_type)
X+     {
X+ 	case 1:		/* curses */
X+ 	    set_cooked_curses();
X+ 	    break;
X+     }
X+ }
X+ 
X+ int
X+ term_does_asides()
X+ {
X+     /* only some terminal systems can do this */
X+ 
X+     switch(term_type)
X+     {
X+ 	case 2:		/* X11 */
X+ 	    return 1;
X+     }
X+     return 0;
X  }
X*** 3.0.0/cwin.c	Mon Aug 23 14:05:06 1993
X--- cwin.c	Tue Aug 24 11:31:34 1993
X***************
X*** 1,4 ****
X! /* curses.c -- curses interface */
X  
X  /*			   NOTICE
X   *
X--- 1,4 ----
X! /* cwin.c -- curses interface */
X  
X  /*			   NOTICE
X   *
X***************
X*** 19,25 ****
X  #include "header.h"
X  #include <curses.h>
X  #include <sys/signal.h>
X! #include "curses.h"
X  
X  typedef struct _ywin {
X      struct _ywin *next;		/* next ywin in linked list */
X--- 19,25 ----
X  #include "header.h"
X  #include <curses.h>
X  #include <sys/signal.h>
X! #include "cwin.h"
X  
X  typedef struct _ywin {
X      struct _ywin *next;		/* next ywin in linked list */
X***************
X*** 49,55 ****
X  	    bail(YTE_SUCCESS);
X  	bail(YTE_ERROR);
X      }
X!     my_input(buf, rc);
X  }
X  
X  static ywin *
X--- 49,55 ----
X  	    bail(YTE_SUCCESS);
X  	bail(YTE_ERROR);
X      }
X!     my_input(me, buf, rc);
X  }
X  
X  static ywin *
X***************
X*** 188,194 ****
X  {
X      LINES = COLS = 0;	/* so resizes will work */
X      initscr();
X!     raw();
X      crmode();
X      noecho();
X      clear();
X--- 188,194 ----
X  {
X      LINES = COLS = 0;	/* so resizes will work */
X      initscr();
X!     noraw();
X      crmode();
X      noecho();
X      clear();
X***************
X*** 382,387 ****
X--- 382,394 ----
X      scrollok(w->win, TRUE);
X      scroll(w->win);
X      scrollok(w->win, FALSE);
X+ 
X+     /* Some curses won't leave the cursor in the same place, and some
X+      * curses programs won't erase the bottom line properly.
X+      */
X+     wmove(w->win, user->t_rows - 1, 0);
X+     wclrtoeol(w->win);
X+     wmove(w->win, user->y, user->x);
X  }
X  
X  void
X***************
X*** 392,395 ****
X--- 399,436 ----
X  
X      w = (ywin *)(user->term);
X      wrefresh(w->win);
X+ }
X+ 
X+ /* Clear and redisplay.
X+  */
X+ void
X+ redisplay_curses()
X+ {
X+     register ywin *w;
X+ 
X+     clear();
X+     refresh();
X+     for(w = head; w; w = w->next)
X+     {
X+ 	redraw_term(w->user, 0);
X+ 	draw_title(w);
X+ 	refresh();
X+ 	wrefresh(w->win);
X+     }
X+ }
X+ 
X+ /* Set raw mode.
X+  */
X+ void
X+ set_raw_curses()
X+ {
X+     raw();
X+ }
X+ 
X+ /* Set cooked mode.
X+  */
X+ void
X+ set_cooked_curses()
X+ {
X+     noraw();
X  }
X*** 3.0.0/xwin.c	Mon Aug 23 14:05:06 1993
X--- xwin.c	Tue Aug 24 14:47:49 1993
X***************
X*** 30,36 ****
X  static XFontStruct     *text_font;	/* font */
X  static GC		textGC,		/* text graphic context */
X  			invertGC;	/* graphic context for inverts */
X! static u_long		whitepix,	/* white pixel */
X  			blackpix;	/* black pixel */
X  static int		font_width,	/* font width */
X  			font_height,	/* font height */
X--- 30,36 ----
X  static XFontStruct     *text_font;	/* font */
X  static GC		textGC,		/* text graphic context */
X  			invertGC;	/* graphic context for inverts */
X! static ylong		whitepix,	/* white pixel */
X  			blackpix;	/* black pixel */
X  static int		font_width,	/* font width */
X  			font_height,	/* font height */
X***************
X*** 88,97 ****
X  make_GC(gc, font, fgpixel, bgpixel, l_width, l_style, l_cap, l_join, gcfunc)
X    GC *gc;
X    XFontStruct *font;
X!   u_long fgpixel, bgpixel;
X    int l_width, l_style, l_cap, l_join, gcfunc;
X  {
X!     u_long mask = 0;
X      XGCValues values;
X  
X      if(font != NULL)
X--- 88,97 ----
X  make_GC(gc, font, fgpixel, bgpixel, l_width, l_style, l_cap, l_join, gcfunc)
X    GC *gc;
X    XFontStruct *font;
X!   ylong fgpixel, bgpixel;
X    int l_width, l_style, l_cap, l_join, gcfunc;
X  {
X!     ylong mask = 0;
X      XGCValues values;
X  
X      if(font != NULL)
X***************
X*** 160,167 ****
X  		}
X  		break;
X  	    case KeyPress:
X! 		n = XLookupString(&report, buf, 512, NULL, NULL);
X! 		my_input(buf, n);
X  		break;
X  	}
X      }
X--- 160,167 ----
X  		}
X  		break;
X  	    case KeyPress:
X! 		n = XLookupString((XKeyEvent *) &report, buf, 512, NULL, NULL);
X! 		my_input(win_user(report.xkeymap.window), buf, n);
X  		break;
X  	}
X      }
X***************
X*** 184,190 ****
X  void
X  init_xwin()
X  {
X!     extern char *getenv();
X      char	*displayName;
X      char	*rfn, str[256];
X      int		xfd;
X--- 184,190 ----
X  void
X  init_xwin()
X  {
X!     char	*xrmstr;
X      char	*displayName;
X      char	*rfn, str[256];
X      int		xfd;
X***************
X*** 203,218 ****
X  
X      /* read all options */
X  
X!     db = XrmGetStringDatabase(XResourceManagerString(display));
X!     if((rfn = getenv("HOME")) != NULL)
X      {
X  	sprintf(str, "%s/.Xdefaults", rfn);
X  	if(access(str, 0) == 0)
X! 	    XrmMergeDatabases(XrmGetFileDatabase(str), &db);
X      }
X!     if((rfn = getenv("XENVIRONMENT")) != NULL)
X! 	if(access(rfn, 0) == 0)
X! 	    XrmMergeDatabases(XrmGetFileDatabase(rfn), &db);
X      if(getOption("YTalk.reverse"))
X      {
X  	whitepix = BlackPixel(display, screen_num);
X--- 203,223 ----
X  
X      /* read all options */
X  
X!     db = NULL;
X!     XrmInitialize();
X!     if((xrmstr = XResourceManagerString(display)) != NULL)
X! 	db = XrmGetStringDatabase(xrmstr);
X!     else if((rfn = (char *)getenv("XENVIRONMENT")) != NULL
X!         && access(rfn, 0) == 0)
X! 	db = XrmGetFileDatabase(rfn);
X!     else if((rfn = (char *)getenv("HOME")) != NULL)
X      {
X  	sprintf(str, "%s/.Xdefaults", rfn);
X  	if(access(str, 0) == 0)
X! 	    db = XrmGetFileDatabase(str);
X      }
X!     if(db == NULL)
X! 	db = XrmGetStringDatabase("");
X      if(getOption("YTalk.reverse"))
X      {
X  	whitepix = BlackPixel(display, screen_num);
X***************
X*** 279,285 ****
X      if(getOption("YTalk.geometry"))
X      {
X  	XParseGeometry(getOption("YTalk.geometry"),
X! 	    &size.x, &size.y, &size.width, &size.height);
X  
X  	/* don't set USPosition -- it confuses tvtwm */
X      }
X--- 284,290 ----
X      if(getOption("YTalk.geometry"))
X      {
X  	XParseGeometry(getOption("YTalk.geometry"),
X! 	    &size.x, &size.y, (u_int *)&size.width, (u_int *)&size.height);
X  
X  	/* don't set USPosition -- it confuses tvtwm */
X      }
END_OF_FILE
if test 61834 -ne `wc -c <'patch_01'`; then
    echo shar: \"'patch_01'\" unpacked with wrong size!
fi
# end of 'patch_01'
fi
echo shar: End of shell archive.
echo "== Now run 'patch < patch_01' =="
exit 0
