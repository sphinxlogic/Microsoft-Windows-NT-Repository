Newsgroups: comp.sources.unix
From: dbell@canb.auug.org.au (David I. Bell)
Subject: v27i141: calc-2.9.0 - arbitrary precision C-like programmable calculator, Part14/19
References: <1.755316719.21314@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: dbell@canb.auug.org.au (David I. Bell)
Posting-Number: Volume 27, Issue 141
Archive-Name: calc-2.9.0/part14

#!/bin/sh
# this is part 14 of a multipart archive
# do not concatenate these parts, unpack them in order with /bin/sh
# file calc2.9.0/zmul.c continued
#
CurArch=14
if test ! -r s2_seq_.tmp
then echo "Please unpack part 1 first!"
     exit 1; fi
( read Scheck
  if test "$Scheck" != $CurArch
  then echo "Please unpack part $Scheck next!"
       exit 1;
  else exit 0; fi
) < s2_seq_.tmp || exit 1
echo "x - Continuing file calc2.9.0/zmul.c"
sed 's/^X//' << 'SHAR_EOF' >> calc2.9.0/zmul.c
X	 */
X	hd = &vp[size - 1];
X	while ((*hd == 0) && (size > 1)) {
X		size--;
X		hd--;
X	}
X	sizetotal = size + size;
X
X	/*
X	 * If the number has only a small number of digits, then use the
X	 * (almost) normal multiplication method.  Multiply each halfword
X	 * only by those halfwards further on in the number.  Missed terms
X	 * will then be the same pairs of products repeated, and the squares
X	 * of each halfword.  The first case is handled by doubling the
X	 * result.  The second case is handled explicitly.  The number of
X	 * digits where the algorithm changes is settable from 2 to maxint.
X	 */
X	if (size < _sq2_) {
X		hd = ans;
X		len = sizetotal;
X		while (len--)
X			*hd++ = 0;
X
X		h2 = vp;
X		hd = ans + 1;
X		for (len = size; len--; hd += 2) {
X			digit = (FULL) *h2++;
X			if (digit == 0)
X				continue;
X			h3 = h2;
X			h1 = hd;
X			carry = 0;
X			len1 = len;
X			while (len1 >= 4) {	/* expand the loop some */
X				len1 -= 4;
X				sival.ivalue = (digit * ((FULL) *h3++))
X					+ ((FULL) *h1) + carry;
X				*h1++ = sival.silow;
X				sival.ivalue = (digit * ((FULL) *h3++))
X					+ ((FULL) *h1) + ((FULL) sival.sihigh);
X				*h1++ = sival.silow;
X				sival.ivalue = (digit * ((FULL) *h3++))
X					+ ((FULL) *h1) + ((FULL) sival.sihigh);
X				*h1++ = sival.silow;
X				sival.ivalue = (digit * ((FULL) *h3++))
X					+ ((FULL) *h1) + ((FULL) sival.sihigh);
X				*h1++ = sival.silow;
X				carry = sival.sihigh;
X			}
X			while (len1--) {
X				sival.ivalue = (digit * ((FULL) *h3++))
X					+ ((FULL) *h1) + carry;
X				*h1++ = sival.silow;
X				carry = sival.sihigh;
X			}
X			while (carry) {
X				sival.ivalue = ((FULL) *h1) + carry;
X				*h1++ = sival.silow;
X				carry = sival.sihigh;
X			}
X		}
X
X		/*
X		 * Now double the result.
X		 * There is no final carry to worry about because we
X		 * handle all digits of the result which must fit.
X		 */
X		carry = 0;
X		hd = ans;
X		len = sizetotal;
X		while (len--) {
X			digit = ((FULL) *hd);
X			sival.ivalue = digit + digit + carry;
X			*hd++ = sival.silow;
X			carry = sival.sihigh;
X		}
X
X		/*
X		 * Now add in the squares of each halfword.
X		 */
X		carry = 0;
X		hd = ans;
X		h3 = vp;
X		len = size;
X		while (len--) {
X			digit = ((FULL) *h3++);
X			sival.ivalue = digit * digit + ((FULL) *hd) + carry;
X			*hd++ = sival.silow;
X			carry = sival.sihigh;
X			sival.ivalue = ((FULL) *hd) + carry;
X			*hd++ = sival.silow;
X			carry = sival.sihigh;
X		}
X		while (carry) {
X			sival.ivalue = ((FULL) *hd) + carry;
X			*hd++ = sival.silow;
X			carry = sival.sihigh;
X		}
X
X		/*
X		 * Finally return the size of the result.
X		 */
X		len = sizetotal;
X		hd = &ans[len - 1];
X		while ((*hd == 0) && (len > 1)) {
X			len--;
X			hd--;
X		}
X		return len;
X	}
X
X	/*
X	 * The number to be squared is large.
X	 * Allocate temporary space and determine the sizes and
X	 * positions of the values to be calculated.
X	 */
X	temp = tempbuf;
X	tempbuf += (3 * (size + 1) / 2);
X
X	sizeA = size / 2;
X	sizeB = size - sizeA;
X	shift = sizeB;
X	baseA = vp + sizeB;
X	baseB = vp;
X	baseAA = &ans[shift * 2];
X	baseBB = ans;
X	baseAABB = temp;
X	baseAB = temp;
X	baseABAB = &temp[shift];
X
X	/*
X	 * Trim the second number of leading zeroes.
X	 */
X	hd = &baseB[sizeB - 1];
X	while ((*hd == 0) && (sizeB > 1)) {
X		sizeB--;
X		hd--;
X	}
X
X	/*
X	 * Now to proceed to calculate the result using the formula.
X	 *	(A*S+B)^2 = (S^2+S)*A^2 + (S+1)*B^2 - S*(A-B)^2.
X	 * The steps are done in the following order:
X	 *	S^2*A^2 + B^2
X	 *	A^2 + B^2
X	 *	(S^2+S)*A^2 + (S+1)*B^2
X	 *	(A-B)^2
X	 *	(S^2+S)*A^2 + (S+1)*B^2 - S*(A-B)^2.
X	 *
X	 * Begin by forming the squares of two the halfs concatenated
X	 * together in the final result location.  Make sure that the
X	 * highest words of the results are zero.
X	 */
X	sizeBB = dosquare(baseB, sizeB, baseBB);
X	hd = &baseBB[sizeBB];
X	len = shift * 2 - sizeBB;
X	while (len--)
X		*hd++ = 0;
X
X	sizeAA = dosquare(baseA, sizeA, baseAA);
X	hd = &baseAA[sizeAA];
X	len = sizetotal - shift * 2 - sizeAA;
X	while (len--)
X		*hd++ = 0;
X
X	/*
X	 * Sum the two squares into a temporary location.
X	 */
X	if (sizeAA >= sizeBB) {
X		h1 = baseAA;
X		h2 = baseBB;
X		sizeAABB = sizeAA;
X		sumsize = sizeBB;
X	} else {
X		h1 = baseBB;
X		h2 = baseAA;
X		sizeAABB = sizeBB;
X		sumsize = sizeAA;
X	}
X	copysize = sizeAABB - sumsize;
X
X	hd = baseAABB;
X	carry = 0;
X	while (sumsize--) {
X		sival.ivalue = ((FULL) *h1++) + ((FULL) *h2++) + carry;
X		*hd++ = sival.silow;
X		carry = sival.sihigh;
X	}
X	while (copysize--) {
X		sival.ivalue = ((FULL) *h1++) + carry;
X		*hd++ = sival.silow;
X		carry = sival.sihigh;
X	}
X	if (carry) {
X		*hd = (HALF)carry;
X		sizeAABB++;
X	}
X
X	/*
X	 * Add the sum back into the previously calculated squares
X	 * shifted over to the proper location.
X	 */
X	h1 = baseAABB;
X	hd = ans + shift;
X	carry = 0;
X	len = sizeAABB;
X	while (len--) {
X		sival.ivalue = ((FULL) *hd) + ((FULL) *h1++) + carry;
X		*hd++ = sival.silow;
X		carry = sival.sihigh;
X	}
X	while (carry) {
X		sival.ivalue = ((FULL) *hd) + carry;
X		*hd++ = sival.silow;
X		carry = sival.sihigh;
X	}
X
X	/*
X	 * Calculate the absolute value of the difference of the two halfs
X	 * into a temporary location.
X	 */
X	if (sizeA == sizeB) {
X		len = sizeA;
X		h1 = &baseA[len - 1];
X		h2 = &baseB[len - 1];
X		while ((len > 1) && (*h1 == *h2)) {
X			len--;
X			h1--;
X			h2--;
X		}
X	}
X	if ((sizeA > sizeB) || ((sizeA == sizeB) && (*h1 > *h2)))
X	{
X		h1 = baseA;
X		h2 = baseB;
X		sizeAB = sizeA;
X		subsize = sizeB;
X	} else {
X		h1 = baseB;
X		h2 = baseA;
X		sizeAB = sizeB;
X		subsize = sizeA;
X	}
X	copysize = sizeAB - subsize;
X
X	hd = baseAB;
X	carry = 0;
X	while (subsize--) {
X		sival.ivalue = BASE1 - ((FULL) *h1++) + ((FULL) *h2++) + carry;
X		*hd++ = BASE1 - sival.silow;
X		carry = sival.sihigh;
X	}
X	while (copysize--) {
X		sival.ivalue = (BASE1 - ((FULL) *h1++)) + carry;
X		*hd++ = BASE1 - sival.silow;
X		carry = sival.sihigh;
X	}
X
X	hd = &baseAB[sizeAB - 1];
X	while ((*hd == 0) && (sizeAB > 1)) {
X		sizeAB--;
X		hd--;
X	}
X
X	/*
X	 * Now square the number into another temporary location,
X	 * and subtract that from the final result.
X	 */
X	sizeABAB = dosquare(baseAB, sizeAB, baseABAB);
X
X	h1 = baseABAB;
X	hd = ans + shift;
X	carry = 0;
X	while (sizeABAB--) {
X		sival.ivalue = BASE1 - ((FULL) *hd) + ((FULL) *h1++) + carry;
X		*hd++ = BASE1 - sival.silow;
X		carry = sival.sihigh;
X	}
X	while (carry) {
X		sival.ivalue = BASE1 - ((FULL) *hd) + carry;
X		*hd++ = BASE1 - sival.silow;
X		carry = sival.sihigh;
X	}
X
X	/*
X	 * Return the size of the result.
X	 */
X	len = sizetotal;
X	hd = &ans[len - 1];
X	while ((*hd == 0) && (len > 1)) {
X		len--;
X		hd--;
X	}
X	tempbuf = temp;
X	return len;
X}
X
X
X/*
X * Return a pointer to a buffer to be used for holding a temporary number.
X * The buffer will be at least as large as the specified number of HALFs,
X * and remains valid until the next call to this routine.  The buffer cannot
X * be freed by the caller.  There is only one temporary buffer, and so as to
X * avoid possible conflicts this is only used by the lowest level routines
X * such as divide, multiply, and square.
X */
XHALF *
Xzalloctemp(len)
X	LEN len;		/* required number of HALFs in buffer */
X{
X	HALF *hp;
X	static LEN buflen;	/* current length of temp buffer */
X	static HALF *bufptr;	/* pointer to current temp buffer */
X
X	if (len <= buflen)
X		return bufptr;
X
X	/*
X	 * We need to grow the temporary buffer.
X	 * First free any existing buffer, and then allocate the new one.
X	 * While we are at it, make the new buffer bigger than necessary
X	 * in order to reduce the number of reallocations.
X	 */
X	len += 100;
X	if (buflen) {
X		buflen = 0;
X		free(bufptr);
X	}
X	hp = (HALF *) malloc(len * sizeof(HALF));
X	if (hp == NULL)
X		math_error("No memory for temp buffer");
X	bufptr = hp;
X	buflen = len;
X	return hp;
X}
X
X/* END CODE */
SHAR_EOF
echo "File calc2.9.0/zmul.c is complete"
chmod 0644 calc2.9.0/zmul.c || echo "restore of calc2.9.0/zmul.c fails"
set `wc -c calc2.9.0/zmul.c`;Sum=$1
if test "$Sum" != "27288"
then echo original size 27288, current size $Sum;fi
echo "x - extracting calc2.9.0/help/Makefile (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/Makefile &&
X#
X# help - makefile for calc help files
X#
X# Copyright (c) 1993 David I. Bell and Landon Curt Noll
X# Permission is granted to use, distribute, or modify this source,
X# provided that this copyright notice remains intact.
X#
X# Arbitrary precision calculator.
X#
X# calculator by David I. Bell
X# makefile by Landon Curt Noll
X
XSHELL= /bin/sh
X
X# Normally, the upper level makefile will set these values.  We provide
X# a default here just in case you want to build from this directory.
X#
X# where to install things
XHELPDIR= /usr/local/lib/calc/help
X# the usually LIBDIR value from the upper level Makefile
XLIBDIR= /usr/local/lib/calc
X
X# how to build a directory
XMKDIR=mkdir -p
X#MKDIR=mkdir
X
X# standard tools
XSED= sed
X
X# Standard help files
X#
XSTD_HELP_FILES=intro command expression define variable statement \
X	operator types mat list file builtin config interrupt \
X	history usage credit bindings assoc \
X	overview stdlib environment todo credit help
X
X# Help files that are constructed from other sources
X#
XBUILT_HELP_FILES=bindings stdlib changes libcalc
X
Xall: ${STD_HELP_FILES} obj.file ${BUILT_HELP_FILES}
X
Xbindings: ../lib/bindings
X	rm -f bindings
X	cp ../lib/bindings bindings
X	chmod 0444 bindings
X
Xstdlib: ../lib/README
X	rm -f stdlib
X	cp ../lib/README stdlib
X	chmod 0444 stdlib
X
Xchanges: ../CHANGES
X	rm -f changes
X	cp ../CHANGES changes
X	chmod 0444 changes
X
Xlibcalc: ../LIBRARY
X	rm -f libcalc
X	${SED} -e 's:$${LIBDIR}:${LIBDIR}:g' < ../LIBRARY > libcalc
X	chmod 0444 libcalc
X
Xclean:
X
Xclobber:
X	rm -f ${BUILT_HELP_FILES}
X
Xinstall: all
X	-@if [ ! -d ${HELPDIR} ]; then \
X		echo ${MKDIR} ${HELPDIR}; \
X		${MKDIR} ${HELPDIR}; \
X	fi
X	@for i in ${STD_HELP_FILES} ${BUILT_HELP_FILES}; do \
X		echo rm -f ${HELPDIR}/$$i; \
X		rm -f ${HELPDIR}/$$i; \
X		echo cp $$i ${HELPDIR}; \
X		cp $$i ${HELPDIR}; \
X		echo chmod 0444 ${HELPDIR}/$$i; \
X		chmod 0444 ${HELPDIR}/$$i; \
X	done
X	rm -f ${HELPDIR}/obj
X	cp obj.file ${HELPDIR}/obj
X	chmod 0444 ${HELPDIR}/obj
SHAR_EOF
chmod 0444 calc2.9.0/help/Makefile || echo "restore of calc2.9.0/help/Makefile fails"
set `wc -c calc2.9.0/help/Makefile`;Sum=$1
if test "$Sum" != "1934"
then echo original size 1934, current size $Sum;fi
echo "x - extracting calc2.9.0/help/assoc (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/assoc &&
XUsing associations
X
X	Associations are special values that act like matrices, except
X	that they are more general (and slower) than normal matrices.
X	Unlike matrices, associations can be indexed by arbitrary values.
X	For example, if 'val' was an association, you could do the following:
X
X		val['hello'] = 11;
X		val[4.5] = val['hello'];
X		print val[9/2];
X
X	and 11 would be printed.
X
X	Associations are created by the 'assoc' function.  It takes no
X	arguments, and simply returns an empty association.  You can then
X	insert elements into the association by indexing the returned value
X	as shown above.
X
X	Associations are multi-dimensional.  You can index them using one to
X	four dimensions as desired, and the elements with different numbers
X	of dimensions will remain separated.  For example, 'val[3]' and
X	'val[3,0]' can both be used in the same association and will be
X	distinct elements.
X
X	When references are made to undefined elements of an association,
X	a null value is simply returned.  Therefore no bounds errors can
X	occur when indexing an association.  Assignments of a null value
X	to an element of an association does not delete the element, but
X	a later reference to that element will return the null value as if
X	the element was undefined.  Elements with null values are implicitly
X	created on certain other operations which require an address to be
X	taken, such as the += operator and using & in a function call.
X
X	The elements of an association are stored in a hash table for
X	quick access.  The index values are hashed to select the correct
X	hash chain for a small sequential search for the element.  The hash
X	table will be resized as necessary as the number of entries in
X	the association becomes larger.
X
X	The size function returns the number of elements in an association.
X	This size will include elements with null values.
X
X	Double bracket indexing can be used for associations to walk through
X	the elements of the association.  The order that the elements are
X	returned in as the index increases is essentially random.  Any
X	change made to the association can reorder the elements, this making
X	a sequential scan through the elements difficult.
X
X	The search and rsearch functions can search for an element in an
X	association which has the specified value.  They return the index
X	of the found element, or a NULL value if the value was not found.
X
X	Associations can be copied by an assignment, and can be compared
X	for equality.  But no other operations on associations have meaning,
X	and are illegal.
SHAR_EOF
chmod 0644 calc2.9.0/help/assoc || echo "restore of calc2.9.0/help/assoc fails"
set `wc -c calc2.9.0/help/assoc`;Sum=$1
if test "$Sum" != "2519"
then echo original size 2519, current size $Sum;fi
echo "x - extracting calc2.9.0/help/builtin (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/builtin &&
XBuiltin functions
X
X	There is a large number of built-in functions.  Many of the
X	functions work on several types of arguments, whereas some only
X	work for the correct types (e.g., numbers or strings).  In the
X	following description, this is indicated by whether or not the
X	description refers to values or numbers.  This display is generated
X	by the 'show builtins' command.
X
X	    Name      Args   Description
X
X	    abs       1-2    absolute value within accuracy b
X	    acos      1-2    arccosine of a within accuracy b
X	    acosh     1-2    hyperbolic arccosine of a within accuracy b
X	    append    2      append value to end of list
X	    appr      1-2    approximate a with simpler fraction to within b
X	    arg       1-2    argument (the angle) of complex number
X	    asin      1-2    arcsine of a within accuracy b
X	    asinh     1-2    hyperbolic arcsine of a within accuracy b
X	    atan      1-2    arctangent of a within accuracy b
X	    atan2     2-3    angle to point (b,a) within accuracy c
X	    atanh     1-2    hyperbolic arctangent of a within accuracy b
X	    avg       1+     arithmetic mean of values
X	    bround    1-2    round value a to b number of binary places
X	    btrunc    1-2    truncate a to b number of binary places
X	    ceil      1      smallest integer greater than or equal to number
X	    cfappr    1-2    approximate a within accuracy b using 
X				continued fractions
X	    cfsim     1      simplify number using continued fractions
X	    char      1      character corresponding to integer value
X	    cmp       2      compare values returning -1, 0, or 1
X	    comb      2      combinatorial number a!/b!(a-b)!
X	    config    1-2    set or read configuration value
X	    conj      1      complex conjugate of value
X	    cos       1-2    cosine of value a within accuracy b
X	    cosh      1-2    hyperbolic cosine of a within accuracy b
X	    cp        2      Cross product of two vectors
X	    delete    2      delete element from list a at position b
X	    den       1      denominator of fraction
X	    det       1      determinant of matrix
X	    digit     2      digit at specified decimal place of number
X	    digits    1      number of digits in number
X	    dp        2      Dot product of two vectors
X	    epsilon   0-1    set or read allowed error for real calculations
X	    eval      1      Evaluate expression from string to value
X	    exp       1-2    exponential of value a within accuracy b
X	    fcnt      2      count of times one number divides another
X	    fib       1      Fibonacci number F(n)
X	    frem      2      number with all occurrences of factor removed
X	    fact      1      factorial
X	    fclose    1      close file
X	    feof      1      whether EOF reached for file
X	    ferror    1      whether error occurred for file
X	    fflush    1      flush output to file
X	    fgetc     1      read next char from file
X	    fgetline  1      read next line from file
X	    files     0-1    return opened file or max number of opened files
X	    floor     1      greatest integer less than or equal to number
X	    fopen     2      open file name a in mode b
X	    fprintf   2+     print formatted output to opened file
X	    frac      1      fractional part of value
X	    gcd       1+     greatest common divisor
X	    gcdrem    2      a divided repeatedly by gcd with b
X	    hash      1+     return non-negative hash value for one or
X	                     more values
X	    highbit   1      high bit number in base 2 representation
X	    hmean     1+     harmonic mean of values
X	    hypot     2-3    hypotenuse of right triangle within accuracy c
X	    ilog      2      integral log of one number with another
X	    ilog10    1      integral log of a number base 10
X	    ilog2     1      integral log of a number base 2
X	    im        1      imaginary part of complex number
X	    insert    3      insert value c into list a at position b
X	    int       1      integer part of value
X	    inverse   1      multiplicative inverse of value
X	    iroot     2      integer b'th root of a
X	    iseven    1      whether a value is an even integer
X	    isfile    1      whether a value is a file
X	    isint     1      whether a value is an integer
X	    islist    1      whether a value is a list
X	    ismat     1      whether a value is a matrix
X	    ismult    2      whether a is a multiple of b
X	    isnull    1      whether a value is the null value
X	    isnum     1      whether a value is a number
X	    isobj     1      whether a value is an object
X	    isodd     1      whether a value is an odd integer
X	    isqrt     1      integer part of square root
X	    isreal    1      whether a value is a real number
X	    isset     2      whether bit b of abs(a) (in base 2) is set
X	    isstr     1      whether a value is a string
X	    isrel     2      whether two numbers are relatively prime
X	    issimple  1      whether value is a simple type
X	    issq      1      whether or not number is a square
X	    istype    2      whether the type of a is same as the type of b
X	    jacobi    2      -1 => a is not quadratic residue mod b
X			     1 => b is composite, or a is quad residue of b
X	    lcm       1+     least common multiple
X	    lcmfact   1      lcm of all integers up till number
X	    lfactor   2      lowest prime factor of a in first b primes
X	    list      0+     create list of specified values
X	    ln        1-2    natural logarithm of value a within accuracy b
X	    lowbit    1      low bit number in base 2 representation
X	    ltol      1-2    leg-to-leg of unit right triangle (sqrt(1 - a^2))
X	    matdim    1      number of dimensions of matrix
X	    matfill   2-3    fill matrix with value b (value c on diagonal)
X	    matmax    2      maximum index of matrix a dim b
X	    matmin    2      minimum index of matrix a dim b
X	    mattrans  1      transpose of matrix
X	    max       1+     maximum value
X	    meq       3      whether a and b are equal modulo c
X	    min       1+     minimum value
X	    minv      2      inverse of a modulo b
X	    mmin      2      a mod b value with smallest abs value
X	    mne       3      whether a and b are not equal modulo c
X	    near      2-3    sign of (abs(a-b) - c)
X	    norm      1      norm of a value (square of absolute value)
X	    null      0      null value
X	    num       1      numerator of fraction
X	    ord       1      integer corresponding to character value
X	    param     1      value of parameter n (or parameter count if n 
X				is zero)
X	    perm      2      permutation number a!/(a-b)!
X	    pfact     1      product of primes up till number
X	    pi        0-1    value of pi accurate to within epsilon
X	    places    1      places after decimal point (-1 if infinite)
X	    pmod      3      mod of a power (a ^ b (mod c))
X	    polar     2-3    complex value of polar coordinate (a * exp(b*1i))
X	    poly      2+     (a1,a2,...,an,x) = a1*x^n+a2*x^(n-1)+...+an
X	    pop       1      pop value from front of list
X	    power     2-3    value a raised to the power b within accuracy c
X	    ptest     2      probabilistic primality test
X	    printf    1+     print formatted output to stdout
X	    prompt    1      prompt for input line using value a
X	    push      2      push value onto front of list
X	    quomod    4      set c and d to quotient and remainder of a 
X				divided by b
X	    rcin      2      convert normal number a to REDC number mod b
X	    rcmul     3      multiply REDC numbers a and b mod c
X	    rcout     2      convert REDC number a mod b to normal number
X	    rcpow     3      raise REDC number a to power b mod c
X	    rcsq      2      square REDC number a mod b
X	    re        1      real part of complex number
X	    remove    1      remove value from end of list
X	    root      2-3    value a taken to the b'th root within accuracy c
X	    round     1-2    round value a to b number of decimal places
X	    rsearch   2-3    reverse search matrix or list for value b 
X				starting at index c
X	    runtime   0      user mode cpu time in seconds
X	    scale     2      scale value up or down by a power of two
X	    search    2-3    search matrix or list for value b starting 
X				at index c
X	    sgn       1      sign of value (-1, 0, 1)
X	    sin       1-2    sine of value a within accuracy b
X	    sinh      1-2    hyperbolic sine of a within accuracy b
X	    size      1      total number of elements in value
X	    sqrt      1-2    square root of value a within accuracy b
X	    ssq       1+     sum of squares of values
X	    str       1      simple value converted to string
X	    strcat    1+     concatenate strings together
X	    strlen    1      length of string
X	    strprintf 1+     return formatted output as a string
X	    substr    3      substring of a from position b for c chars
X	    swap      2      swap values of variables a and b (can be dangerous)
X	    tan       1-2    tangent of a within accuracy b
X	    tanh      1-2    hyperbolic tangent of a within accuracy b
X	    trunc     1-2    truncate a to b number of decimal places
X	    xor       1+     logical xor
X
X	The config function sets or reads the value of a configuration
X	parameter.  The first argument is a string which names the parameter
X	to be set or read.  If only one argument is given, then the current
X	value of the named parameter is returned.  If two arguments are given,
X	then the named parameter is set to the value of the second argument,
X	and the old value of the parameter is returned.  Therefore you can
X	change a parameter and restore its old value later.  The possible
X	parameters are explained in the next section.
X
X	The scale function multiplies or divides a number by a power of 2.
X	This is used for fractional calculations, unlike the << and >>
X	operators, which are only defined for integers.  For example,
X	scale(6, -3) is 3/4.
X
X	The quomod function is used to obtain both the quotient and remainder
X	of a division in one operation.  The first two arguments a and b are
X	the numbers to be divided.  The last two arguments c and d are two
X	variables which will be assigned the quotient and remainder.  For
X	nonnegative arguments, the results are equivalent to computing a//b
X	and a%b.  If a is negative and the remainder is nonzero, then the
X	quotient will be one less than a//b.  This makes the following three
X	properties always hold:  The quotient c is always an integer.  The
X	remainder d is always 0 <= d < b.  The equation a = b * c + d always
X	holds.  This function returns 0 if there is no remainder, and 1 if
X	there is a remainder.  For examples, quomod(10, 3, x, y) sets x to 3,
X	y to 1, and returns the value 1, and quomod(-4, 3.14159, x, y) sets x
X	to -2, y to 2.28318, and returns the value 1.
X
X	The eval function accepts a string argument and evaluates the
X	expression represented by the string and returns its value.
X	The expression can include function calls and variable references.
X	For example, eval("fact(3) + 7") returns 13.  When combined with
X	the prompt function, this allows the calculator to read values from
X	the user.  For example, x=eval(prompt("Number: ")) sets x to the
X	value input by the user.
X
X	The digit and isset functions return individual digits of a number,
X	either in base 10 or in base 2, where the lowest digit of a number
X	is at digit position 0.  For example, digit(5678, 3) is 5, and
X	isset(0b1000100, 2) is 1.  Negative digit positions indicate places
X	to the right of the decimal or binary point, so that for example,
X	digit(3.456, -1) is 4.
X
X	The ptest function is a primality testing function.  The first
X	argument is the suspected prime to be tested.  The second argument
X	is an iteration count.  The function returns 0 if the number is
X	definitely not prime, and 1 is the number is probably prime.  The
X	chance of a number which is probably prime being actually composite
X	is less than 1/4 raised to the power of the iteration count.  For
X	example, for a random number p, ptest(p, 10) incorrectly returns 1
X	less than once in every million numbers, and you will probably never
X	find a number where ptest(p, 20) gives the wrong answer.
X
X	The functions rcin, rcmul, rcout, rcpow, and rcsq are used to
X	perform modular arithmetic calculations for large odd numbers
X	faster than the usual methods.  To do this, you first use the
X	rcin function to convert all input values into numbers which are
X	in a format called REDC format.  Then you use rcmul, rcsq, and
X	rcpow to multiply such numbers together to produce results also
X	in REDC format.  Finally, you use rcout to convert a number in
X	REDC format back to a normal number.  The addition, subtraction,
X	negation, and equality comparison between REDC numbers are done
X	using the normal modular methods.  For example, to calculate the
X	value 13 * 17 + 1 (mod 11), you could use:
X
X		p = 11;
X		t1 = rcin(13, p);
X		t2 = rcin(17, p);
X		t3 = rcin(1, p);
X		t4 = rcmul(t1, t2, p);
X		t5 = (t4 + t3) % p;
X		answer = rcout(t5, p);
X
X	The swap function exchanges the values of two variables without
X	performing copies.  For example, after:
X
X		x = 17;
X		y = 19;
X		swap(x, y);
X
X	then x is 19 and y is 17.  This function should not be used to
X	swap a value which is contained within another one.  If this is
X	done, then some memory will be lost.  For example, the following
X	should not be done:
X
X		mat x[5];
X		swap(x, x[0]);
X
X	The hash function returns a relatively small non-negative integer
X	for one or more input values.  The hash values should not be used
X	across runs of the calculator, since the algorithms used to generate
X	the hash value may change with different versions of the calculator.
SHAR_EOF
chmod 0644 calc2.9.0/help/builtin || echo "restore of calc2.9.0/help/builtin fails"
set `wc -c calc2.9.0/help/builtin`;Sum=$1
if test "$Sum" != "13487"
then echo original size 13487, current size $Sum;fi
echo "x - extracting calc2.9.0/help/command (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/command &&
XCommand sequence
X
X	This is a sequence of any the following command formats, where
X	each command is terminated by a semicolon or newline.  Long command
X	lines can be extended by using a back-slash followed by a newline
X	character.  When this is done, the prompt shows a double angle
X	bracket to indicate that the line is still in progress.  Certain
X	cases will automatically prompt for more input in a similar manner,
X	even without the back-slash.  The most common case for this is when
X	a function is being defined, but is not yet completed.
X
X	Each command sequence terminates only on an end of file.  In
X	addition, commands can consist of expression sequences, which are
X	described in the next section.
X
X
X	NOTE: Calc commands are in lower case.   UPPER case is used below
X	      for emphasis only, and should be considered in lower case.
X
X
X	DEFINE function(params) { body }
X	DEFINE function(params) = expression
X		This first form defines a full function which can consist
X		of declarations followed by many statements which implement
X		the function.
X
X		The second form defines a simple function which calculates
X		the specified expression value from the specified parameters.
X		The expression cannot be a statement.  However, the comma
X		and question mark operators can be useful.  Examples of
X		simple functions are:
X
X			define sumcubes(a, b) = a^3 + b^3;
X			define pimod(a) = a % pi();
X
X	HELP
X		This displays a general help message.
X
X	READ filename
X		This reads definitions from the specified filename.
X		The name can be quoted if desired.  The calculator
X		uses the CALCPATH environment variable to search
X		through the specified directories for the filename,
X		similarly to the use of the PATH environment variable.
X		If CALCPATH is not defined, then a default path of
X		":/usr/lib/calc" is used (that is, the current directory
X		followed by a general calc library directory).  The
X		".cal" extension is defaulted for input files, so that
X		if "filename" is not found, then "filename.cal" is then
X		searched for.  The contents of the filename are command
X		sequences which can consist of expressions to evaluate
X		or functions to define, just like at the top level
X		command level.
X
X	WRITE filename
X		This writes the values of all global variables to the
X		specified filename, in such a way that the file can be
X		later read in order to recreate the variable values.
X		For speed reasons, values are written as hex fractions.
X		This command currently only saves simple types, so that
X		matrices, lists, and objects are not saved.  Function
X		definitions are also not saved.
X
X	QUIT
X		This leaves the calculator, when given as a top-level
X		command.
X	
X
X	Also see the help topic:
X
X		statement       flow control and declaration statements
SHAR_EOF
chmod 0644 calc2.9.0/help/command || echo "restore of calc2.9.0/help/command fails"
set `wc -c calc2.9.0/help/command`;Sum=$1
if test "$Sum" != "2740"
then echo original size 2740, current size $Sum;fi
echo "x - extracting calc2.9.0/help/config (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/config &&
XConfiguration parameters
X
X	Configuration parameters affect how the calculator performs certain
X	operations, and affects all future calculations.  These parameters
X	affect the accuracy of calculations, the displayed format of results,
X	and which algorithms are used for calculations.  The parameters are
X	read or set using the "config" built-in function.  The following
X	parameters can be specified:
X
X		"trace"		turns tracing on or off (for debugging).
X		"display"	sets number of digits in prints.
X		"epsilon"	sets error value for transcendentals.
X		"maxprint"	sets maximum number of elements printed.
X		"mode"		sets printout mode.
X		"mul2"		sets size for alternative multiply.
X		"sq2"		sets size for alternative squaring.
X		"pow2"		sets size for alternate powering.
X		"redc2"		sets size for alternate REDC.
X
X	The use of the trace flag is for debugging, and its meaning may
X	change in the future.  A value of 1 causes the calculator to print
X	its internal opcodes as it executes functions.  A value of zero
X	disables tracing again.
X
X	Display specifies how many digits after the decimal point should
X	be printed when printing real or exponential numbers.  The initial
X	display value is 20.  This parameter does not affect the accuracy
X	of a calculation, since it only has meaning when printing results.
X
X	Epsilon specifies the required precision of calculations by
X	setting the maximum allowed error for transcendental functions.
X	The error is an absolute error value for many functions, but
X	for some functions it is a relative error.  The initial value
X	is 1e-20.  Functions which require an epsilon value accept an
X	optional argument which overrides this default epsilon value for
X	that single call.  The built-in function "epsilon" also can be
X	used to read or set this value, and is provided for ease of use.
X
X	Mode specifies how numbers should be printed.  Mode is a string
X	value indicating the printout method.  The initial mode is "real".
X	Possible modes are:
X
X		"frac"		decimal fractions
X		"int"		decimal integer
X		"real"		decimal floating point
X		"exp"		decimal exponential
X		"hex"		hex fractions
X		"oct"		octal fractions
X		"bin"		binary fractions
X
X	Maxprint specifies the maximum number of elements to be displayed
X	when a matrix or list is printed.  The initial value is 16 elements.
X
X	Mul2 and sq2 specify the sizes of numbers at which calc switches
X	from its first to its second algorithm for multiplying and squaring.
X	The first algorithm is the usual method of cross multiplying, which
X	runs in a time of O(N^2).  The second method is a recursive and
X	complicated method which runs in a time of O(N^1.585).  The argument
X	for these parameters is the number of binary words at which the
X	second algorithm begins to be used.  The minimum value is 2, and
X	the maximum value is very large.  If 2 is used, then the recursive
X	algorithm is used all the way down to single digits, which becomes
X	slow since the recursion overhead is high.  If a number such as
X	1000000 is used, then the recursive algorithm is never used, causing
X	calculations for large numbers to slow down.  For a typical example
X	on a 386, the two algorithms are about equal in speed for a value
X	of 20, which is about 100 decimal digits.  A value of zero resets
X	the parameter back to its default value.  Usually there is no need
X	to change these parameters.
X
X	Pow2 specifies the sizes of numbers at which calc switches from
X	its first to its second algorithm for calculating powers modulo
X	another number.  The first algorithm for calculating modular powers
X	is by repeated squaring and multiplying and dividing by the modulus.
X	The second method uses the REDC algorithm given by Peter Montgomery
X	which avoids divisions.  The argument for pow2 is the size of the
X	modulus at which the second algorithm begins to be used.
X
X	Redc2 specifies the sizes of numbers at which calc switches from
X	its first to its second algorithm when using the REDC algorithm.
X	The first algorithm performs a multiply and a modular reduction
X	together in one loop which runs in O(N^2).  The second algorithm
X	does the REDC calculation using three multiplies, and runs in
X	O(N^1.585).  The argument for redc2 is the size of the modulus at
X	which the second algorithm begins to be used.
X
X	Examples of setting some parameters are:
X
X		config("mode", "exp");		exponential output
X		config("display", 50);		50 digits of output
X		epsilon(epsilon() / 8);		3 bits more accuracy
SHAR_EOF
chmod 0644 calc2.9.0/help/config || echo "restore of calc2.9.0/help/config fails"
set `wc -c calc2.9.0/help/config`;Sum=$1
if test "$Sum" != "4426"
then echo original size 4426, current size $Sum;fi
echo "x - extracting calc2.9.0/help/credit (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/credit &&
XCredits
X
X	Written by David I. Bell.
X
X	Thanks for suggestions and encouragement from Peter Miller,
X	Neil Justusson, and Landon Noll.
X
X	Thanks to Stephen Rothwell for writing the original version of
X	hist.c which is used to do the command line editing.
X
X	Thanks to Ernest W. Bowen for supplying some improvements in
X	accuracy and generality for some numeric functions.  Much of
X	this was in terms of actual code which I gratefully accepted.
X
X	Portions of this program are derived from an earlier set of
X	public domain arbitrarily precision routines which was posted
X	to the net around 1984.  By now, there is almost no recognizable 
X	code left from that original source.
X
X	Most of this source and binary is:
X
X		Copyright (c) 1993 David I. Bell
X
X	A few files are a joint copyright between David I. Bell and Landon Noll.
X
X	Permission is granted to use, distribute, or modify this source,
X	provided that this copyright notice remains intact.
X
X	Send calc comments, suggestions, bug fixes, enhancements and
X	interesting calc scripts that you would like you see included in
X	future distributions to:
X
X		dbell@canb.auug.org.au
X		chongo@toad.com
X
X	Enjoy!
SHAR_EOF
chmod 0644 calc2.9.0/help/credit || echo "restore of calc2.9.0/help/credit fails"
set `wc -c calc2.9.0/help/credit`;Sum=$1
if test "$Sum" != "1145"
then echo original size 1145, current size $Sum;fi
echo "x - extracting calc2.9.0/help/define (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/define &&
XFunction definitions
X
X	Function definitions are introduced by the 'define' keyword.
X	Other than this, the basic structure of a function is like in C.
X	That is, parameters are specified for the function within parenthesis,
X	the function body is introduced by a left brace, variables are
X	declared for the function, statements implementing the function
X	follow, and the function is ended with a right brace.
X
X	There are some subtle differences, however.  The types of parameters
X	and variables are not defined at compile time, but instead are typed
X	at runtime.  Thus there is no definitions needed to distinguish
X	between integers, fractions, complex numbers, matrices, and so on.
X	Thus when declaring parameters for a function, only the name of
X	the parameter is needed.  Thus there are never any declarations
X	between the function parameter list and the body of the function.
X
X	For example, the following function computes a factorial:
X
X		define factorial(n)
X		{
X			local	ans;
X
X			ans = 1;
X			while (n > 1)
X				ans *= n--;
X			return ans;
X		}
X
X	If a function is very simple and just returns a value, then the
X	function can be defined in shortened manner by using an equals sign
X	in place of the left brace.  In this case, the function declaration
X	is terminated by a newline character, and its value is the specified
X	expression.  Statements such as 'if' are not allowed.  An optional
X	semicolon ending the expression is allowed.  As an example, the
X	average of two numbers could be defined as:
X
X		define average(a, b) = (a + b) / 2;
X
X	Functions can be defined which can be very complex.  These can be
X	defined on the command line if desired, but editing of partial
X	functions is not possible past a single line.  If an error is made
X	on a previous line, then the function must be finished (with probable
X	errors) and reentered from the beginning.  Thus for complicated
X	functions, it is best to use an editor to create the function in a
X	file, and then enter the calculator and read in the file containing
X	the definition.
X
X	The parameters of a function can be referenced by name, as in
X	normal C usage, or by using the 'param' function.  This function
X	returns the specified parameter of the function it is in, where
X	the parameters are numbered starting from 1.  The total number
X	of parameters to the function is returned by using 'param(0)'.
X	Using this function allows you to implement varargs-like routines
X	which can handle any number of calling parameters.  For example:
X
X		define sc()
X		{
X			local s, i;
X
X			s = 0;
X			for (i = 1; i <= param(0); i++)
X				s += param(i)^3;
X			return s;
X		}
X
X	defines a function which returns the sum of the cubes of all it's
X	parameters.
SHAR_EOF
chmod 0644 calc2.9.0/help/define || echo "restore of calc2.9.0/help/define fails"
set `wc -c calc2.9.0/help/define`;Sum=$1
if test "$Sum" != "2679"
then echo original size 2679, current size $Sum;fi
echo "x - extracting calc2.9.0/help/environment (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/environment &&
XEnvironment variables
X
X	CALCPATH
X
X	    A :-separated list of directories used to search for
X	    scripts filenames that do not begin with /, ./ or ~.
X
X	    If this variable does not exist, a compiled value
X	    is used.  Typically compiled in value is:
X
X			.:./lib:~/lib:${LIBDIR}/calc
X	
X	    where ${LIBDIR} is usually:
X
X			/usr/lib/calc
X
X	    This value is used by the READ command.  It is an error
X	    if no such readable file is found.
X	
X	
X	CALCRC
X
X	    On startup (unless -h or -q was given on the command
X	    line), calc searches for files along the :-separated
X	    $CALCRC environment variable.
X
X	    If this variable does not exist, a compiled value
X	    is used.  Typically compiled in value is:
X
X			${LIBDIR}/startup:~/.calcrc
X	
X	    where ${LIBDIR} is usually:
X
X			/usr/lib/calc
X
X	    Missing files along the $CALCRC path are silently ignored.
X	
X	CALCBINDINGS
X
X	    On startup (unless -h or -q was given on the command
X	    line), calc reads key bindings from the filename specified
X	    in the $CALCRC environment variable.  These key bindings
X	    are used for command line editing and the command history.
X
X	    If this variable does not exist, a compiled value is used.
X	    Typically compiled in value is:
X
X			${LIBDIR}/bindings
X	
X	    where ${LIBDIR} is usually:
X
X			/usr/lib/calc
X
X	    If the file could not be opened, or if standard input is not
X	    a terminal, then calc will still run, but fancy command line
X	    editing is disabled.
X
X	HOME
X
X	    This value is taken to be the home directory of the
X	    current user.  It is used when files begin with '~/'.
X
X	    If this variable does not exist, the home directory password 
X	    entry of the current user is used.  If that information
X	    is not available, '.' is used.
X	
X	PAGER
X
X	    When invoking help, this environment variable is used
X	    to display a help file.
X
X	    If this variable does not exist, a compiled value
X	    is used.  Typically compiled in value is something
X	    such as 'more', 'less', 'pg' or 'cat'.
X	
X	SHELL
X
X	    When a !-command is used, the program indicated by
X	    this environment variable is used.
X
X	    If this variable does not exist, a compiled value
X	    is used.  Typically compiled in value is something
X	    such as 'sh' is used.
SHAR_EOF
chmod 0644 calc2.9.0/help/environment || echo "restore of calc2.9.0/help/environment fails"
set `wc -c calc2.9.0/help/environment`;Sum=$1
if test "$Sum" != "2248"
then echo original size 2248, current size $Sum;fi
echo "x - extracting calc2.9.0/help/expression (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/expression &&
XExpression sequences
X
X	This is a sequence of statements, of which expression statements
X	are the commonest case.  Statements are separated with semicolons,
X	and the newline character generally ends the sequence.  If any
X	statement is an expression by itself, or is associated with an
X	'if' statement which is true, then two special things can happen.
X	If the sequence is executed at the top level of the calculator,
X	then the value of '.' is set to the value of the last expression.
X	Also, if an expression is a non-assignment, then the value of the
X	expression is automatically printed if its value is not NULL.
X	Some operations such as	pre-increment and plus-equals are also
X	treated as assignments.
X
X	Examples of this are the following:
X
X	expression		sets '.' to		prints
X	----------		-----------		------
X	3+4			7			7
X	2*4; 8+1; fact(3)	6			8, 9, and 6
X	x=3^2			9			-
X	if (3 < 2) 5; else 6	6			6
X	x++			old x			-
X	print fact(4)		-			24
X	null()			null()			-
X
X	Variables can be defined at the beginning of an expression sequence.
X	This is most useful for local variables, as in the following example,
X	which sums the square roots of the first few numbers:
X
X	local s, i; s = 0; for (i = 0; i < 10; i++) s += sqrt(i); s
X
X	If a return statement is executed in an expression sequence, then
X	the result of the expression sequence is the returned value.  In
X	this case, '.' is set to the value, but nothing is printed.
SHAR_EOF
chmod 0644 calc2.9.0/help/expression || echo "restore of calc2.9.0/help/expression fails"
set `wc -c calc2.9.0/help/expression`;Sum=$1
if test "$Sum" != "1413"
then echo original size 1413, current size $Sum;fi
echo "x - extracting calc2.9.0/help/file (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/file &&
XUsing files
X
X	The calculator provides some functions which allow the program to
X	read or write text files.  These functions use stdio internally,
X	and the functions appear similar to some of the stdio functions.
X	Some differences do occur, as will be explained here.
X
X	Names of files are subject to ~ expansion just like the C or
X	Korn shell.  For example, the file name:
X
X		~/.rc.cal
X	
X	refers to the file '.rc.cal' under your home directory.  The
X	file name:
X
X		~chongo/.rc.cal
X
X	refers to the a file 'rc.cal' under the home directory of 'chongo'.
X
X	A file can be opened for either reading, writing, or appending.
X	To do this, the 'fopen' function is used, which accepts a filename
X	and an open mode, both as strings.  You use 'r' for reading, 'w'
X	for writing, and 'a' for appending.  For example, to open the file
X	'foo' for reading, the following could be used:
X
X		fd = fopen('foo', 'r');
X
X	If the open is unsuccessful, the numeric value of errno is returned.
X	If the open is successful, a value of type 'file' will be returned.
X	You can use the 'isfile' function to test the return value to see
X	if the open succeeded.  You should assign the return value of fopen
X	to a variable for later use.  File values can be copied to more than
X	one variable, and using any of the variables with the same file value
X	will produce the same results.
X
X	If you overwrite a variable containing a file value or don't save the
X	result of an 'fopen', the opened file still remains open.  Such 'lost'
X	files can be recovered by using the 'files' function.  This function
X	either takes no arguments or else takes one integer argument.  If no
X	arguments are given, then 'files' returns the maximum number of opened
X	files.  If an argument is given, then the 'files' function uses it as
X	an index into an internal table of open files, and returns a value
X	referring to one the open files.  If that entry in the table is not
X	in use, then the null value is returned instead.  Index 0 always
X	refers to standard input, index 1 always refers to standard output,
X	and index 2 always refers to standard error.  These three files are
X	already open by the calculator and cannot be closed.  As an example
X	of using 'files', if you wanted to assign a file value which is
X	equivalent to stdout, you could use:
X
X		stdout = files(1);
X
X	The 'fclose' function is used to close a file which had been opened.
X	When this is done, the file value associated with the file remains
X	a file value, but appears 'closed', and cannot be used in further
X	file-related calls (except fclose) without causing errors.  This same
X	action occurs to all copies of the file value.  You do not need to
X	explicitly close all the copies of a file value.  The 'fclose'
X	function returns the numeric value of errno if there had been an
X	error using the file, or the null value if there was no error.
X
X	File values can be printed.  When this is done, the filename of the
X	opened file is printed inside of quote marks.  If the file value had
X	been closed, then the null string is printed.  If a file value is the
X	result of a top-level expression, then in addition to the filename,
X	the open mode, file position, and possible EOF, error, and closed
X	status is also displayed.
X
X	File values can be used inside of 'if' tests.  When this is done,
X	an opened file is TRUE, and a closed file is FALSE.  As an example
X	of this, the following loop will print the names of all the currently
X	opened non-standard files with their indexes, and then close them:
X
X		for (i = 3; i < files(); i++) {
X			if (files(i)) {
X				print i, files(i);
X				fclose(files(i));
X			}
X		}
X
X	The functions to read from files are 'fgetline' and 'fgetc'.
X	The 'fgetline' function accepts a file value, and returns the next
X	input line from a file.  The line is returned as a string value, and
X	does not contain the end of line character.  Empty lines return the
X	null string.  When the end of file is reached, fgetline returns the
X	null value.  (Note the distinction between a null string and a null
X	value.)  If the line contained a numeric value, then the 'eval'
X	function can then be used to convert the string to a numeric value.
X	Care should be used when doing this, however, since eval will
X	generate an error if the string doesn't represent a valid expression.
X	The 'fgetc' function returns the next character from a file as a
X	single character string.  It returns the null value when end of file
X	is reached.
X
X	The 'printf' and 'fprintf' functions are used to print results to a
X	file (which could be stdout or stderr).  The 'fprintf' function
X	accepts a file variable, whereas the 'printf' function assumes the
X	use of 'files(1)' (stdout).  They both require a format string, which
X	is used in almost the same way as in normal C.  The differences come
X	in the interpretation of values to be printed for various formats.
X	Unlike in C, where an unmatched format type and value will cause
X	problems, in the calculator nothing bad will happen.  This is because
X	the calculator knows the types of all values, and will handle them
X	all reasonably.  What this means is that you can (for example), always
X	use %s or %d in your format strings, even if you are printing a non-
X	string or non-numeric value.  For example, the following is valid:
X
X		printf("Two values are %d and %s\n", "fred", 4567);
X
X	and will print "Two values are fred and 4567".
X
X	Using particular format characters, however, is still useful if
X	you wish to use width or precision arguments in the format, or if
X	you wish to print numbers in a particular format.  The following
X	is a list of the possible numeric formats:
X
X		%d		print in currently defined numeric format
X		%f		print as floating point
X		%e		print as exponential
X		%r		print as decimal fractions
X		%x		print as hex fractions
X		%o		print as octal fractions
X		%b		print as binary fractions
X
X	Note then, that using %d in the format makes the output configurable
X	by using the 'config' function to change the output mode, whereas
X	the other formats override the mode and force the output to be in
X	the specified format.
X
X	Using the precision argument will override the 'config' function
X	to set the number of decimal places printed.  For example:
X
X		printf("The number is %.100f\n", 1/3);
X
X	will print 100 decimal places no matter what the display configuration
X	value is set to.
X
X	The %s and %c formats are identical, and will print out the string
X	representation of the value.  In these cases, the precision argument
X	will truncate the output the same way as in standard C.
X
X	If a matrix or list is printed, then the output mode and precision
X	affects the printing of each individual element.  However, field
X	widths are ignored since these values print using multiple lines.
X	Field widths are also ignored if an object value prints on multiple
X	lines.
X
X	The final file-related functions are 'fflush', 'ferror', and 'feof'.
X	The 'fflush' function forces buffered output to a file.  The 'ferror'
X	function returns nonzero if an error had occurred to a file.  The
X	'feof' function returns nonzero if end of file has been reached
X	while reading a file.
X
X	The 'strprintf' function formats output similarly to 'printf',
X	but the output is returned as a string value instead of being
X	printed.
SHAR_EOF
chmod 0644 calc2.9.0/help/file || echo "restore of calc2.9.0/help/file fails"
set `wc -c calc2.9.0/help/file`;Sum=$1
if test "$Sum" != "7229"
then echo original size 7229, current size $Sum;fi
echo "x - extracting calc2.9.0/help/help (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/help &&
XFor more information while running calc, type  help  followed by one of the
Xfollowing topics:
X
X	topic		description
X	-----		-----------
X	intro		introduction to calc
X	overview	overview of calc
X
X	assoc		using associations
X	bindings	input & history character bindings
X	builtin		builtin functions
X	command		top level commands
X	config		configuration parameters
X	define		how to define functions
X	environment	how environment variables effect calc
X	expression	expression sequences
X	file		using files
X	history		command history
X	interrupt	how interrupts are handled
X	list		using lists
X	mat		using matrices
X	obj		user defined data types
X	operator	math, relational, logic and variable access operators
X	statement	flow control and declaration statements
X	stdlib		description of some lib files shipped with calc
X	types		builtin data types
X	usage		how to invoke the calc command
X	variable	variables and variable declarations
X
X	changes		recent changes to calc
X	credit		who wrote calc, and who helped, copyright
X	help		this file
X	libcalc		using the arbitrary precision routines in a C program
X	todo		needed enhancements and wish list
X
XFor example:
X
X	help usage
X
Xwill print the calc command usage information.  One can obtain calc help
Xwithout invoking any startup code by running calc as follows:
X
X	calc -q help topic
X
Xwhere 'topic' is one of the topics listed above.
SHAR_EOF
chmod 0644 calc2.9.0/help/help || echo "restore of calc2.9.0/help/help fails"
set `wc -c calc2.9.0/help/help`;Sum=$1
if test "$Sum" != "1350"
then echo original size 1350, current size $Sum;fi
echo "x - extracting calc2.9.0/help/history (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/history &&
XCommand history
X
X	There is a command line editor and history mechanism built
X	into calc, which is active when stdin is a terminal.  When
X	stdin is not a terminal, then the command line editor is
X	disabled.
X
X	Lines of input to calc are always terminated by the return
X	(or enter) key.  When the return key is typed, then the current
X	line is executed and is also saved into a command history list
X	for future recall.
X
X	Before the return key is typed, the current line can be edited
X	using emacs-like editing commands.  As examples, ^A moves to
X	the beginning of the line, ^F moves forwards through the line,
X	backspace removes characters from the line, and ^K kills the
X	rest of the line.
X
X	Previously entered commands can be recalled by using the history
X	list.  The history list functions in a LRU manner, with no
X	duplicated lines.  This means that the most recently entered
X	lines are always at the end of the history list where they are
X	easiest to recall.
X
X	Typing <esc>h lists all of the commands in the command history
X	and numbers the lines.  The most recently executed line is always
X	number 1, the next most recent number 2, and so on.  The numbering
X	for a particular command therefore changes as lines are entered.
X
X	Typing a number at the beginning of a line followed by <esc>g
X	will recall that numbered line.  So that for example, 2<esc>g
X	will recall the second most recent line that was entered.
X
X	The ^P and ^N keys move up and down the lines in the history list.
X	If they attempt to go off the top or bottom of the list, then a
X	blank line is shown to indicate this, and then they wrap around
X	to the other end of the list.
X
X	Typing a string followed by a ^R will search backwards through
X	the history and recall the most recent command which begins
X	with that string.
X
X	Typing ^O inserts the current line at the end of the history list
X	without executing it, and starts a new line.  This is useful to
X	rearrange old history lines to become recent, or to save a partially
X	completed command so that another command can be typed ahead of it.
X
X	If your terminal has arrow keys which generate escape sequences
X	of a particular kind (<esc>[A and so on), then you can use
X	those arrow keys in place of the ^B, ^F, ^P, and ^N keys.
X
X	The actual keys used for editing are defined in a bindings file,
X	called /usr/lib/calc/bindings.  Changing the entries in this file
X	will change the key bindings used for editing.  If the file
X	is not readable, then a message will be output and command
X	line editing is disabled.  In this case you can only edit each
X	line as provided by the terminal driver in the operating system.
X
X	A shell command can be executed by typing '!cmd', where cmd
X	is the command to execute.  If cmd is not given, then a shell
X	command level is started.
SHAR_EOF
chmod 0644 calc2.9.0/help/history || echo "restore of calc2.9.0/help/history fails"
set `wc -c calc2.9.0/help/history`;Sum=$1
if test "$Sum" != "2782"
then echo original size 2782, current size $Sum;fi
echo "x - extracting calc2.9.0/help/interrupt (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/interrupt &&
XInterrupts
X
X	While a calculation is in progress, you can generate the SIGINT
X	signal, and the calculator will catch it.  At appropriate points
X	within a calculation, the calculator will check that the signal
X	has been given, and will abort the calculation cleanly.  If the
X	calculator is in the middle of a large calculation, it might be
X	a while before the interrupt has an effect.
X
X	You can generate the SIGINT signal multiple times if necessary,
X	and each time the calculator will abort the calculation at a more
X	risky place within the calculation.  Each new interrupt prints a
X	message of the form:
X
X		[Abort level n]
X
X	where n ranges from 1 to 3.  For n equal to 1, the calculator will
X	abort calculations at the next statement boundary.  For n equal to 2,
X	the calculator will abort calculations at the next opcode boundary.
X	For n equal to 3, the calculator will abort calculations at the next
X	lowest level arithmetic operation boundary.
X
X	If a final interrupt is given when n is 3, the calculator will
X	immediately abort the current calculation and longjmp back to the
X	top level command level.  Doing this may result in corrupted data
X	structures and unpredictable future behavior, and so should only
X	be done as a last resort.  You are advised to quit the calculator
X	after this has been done.
SHAR_EOF
chmod 0644 calc2.9.0/help/interrupt || echo "restore of calc2.9.0/help/interrupt fails"
set `wc -c calc2.9.0/help/interrupt`;Sum=$1
if test "$Sum" != "1306"
then echo original size 1306, current size $Sum;fi
echo "x - extracting calc2.9.0/help/intro (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/intro &&
XQuick introduction
X
X	This is an interactive calculator which provides for easy large
X	numeric calculations, but which also can be easily programmed
X	for difficult or long calculations.  It can accept a command line
X	argument, in which case it executes that single command and exits.
X	Otherwise, it enters interactive mode.  In this mode, it accepts
X	commands one at a time, processes them, and displays the answers.
X	In the simplest case, commands are simply expressions which are
X	evaluated.  For example, the following line can be input:
X
X		3 * (4 + 1)
X
X	and the calculator will print 15.
X
X	The special '.' symbol (called dot), represents the result of the
X	last command expression, if any.  This is of great use when a series
X	of partial results are calculated, or when the output mode is changed
X	and the last result needs to be redisplayed.  For example, the above
X	result can be doubled by typing:
X
X		. * 2
X
X	and the calculator will print 30.
X
X	For more complex calculations, variables can be used to save the
X	intermediate results.  For example, the result of adding 7 to the
X	previous result can be saved by typing:
X
X		old = . + 7
X
X	Functions can be used in expressions.  There are a great number of
X	pre-defined functions.  For example, the following will calculate
X	the factorial of the value of 'old':
SHAR_EOF
echo "End of part 14"
echo "File calc2.9.0/help/intro is continued in part 15"
echo "15" > s2_seq_.tmp
exit 0
