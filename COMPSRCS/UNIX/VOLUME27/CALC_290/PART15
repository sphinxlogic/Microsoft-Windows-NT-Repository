Newsgroups: comp.sources.unix
From: dbell@canb.auug.org.au (David I. Bell)
Subject: v27i142: calc-2.9.0 - arbitrary precision C-like programmable calculator, Part15/19
References: <1.755316719.21314@gw.home.vix.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: dbell@canb.auug.org.au (David I. Bell)
Posting-Number: Volume 27, Issue 142
Archive-Name: calc-2.9.0/part15

#!/bin/sh
# this is part 15 of a multipart archive
# do not concatenate these parts, unpack them in order with /bin/sh
# file calc2.9.0/help/intro continued
#
CurArch=15
if test ! -r s2_seq_.tmp
then echo "Please unpack part 1 first!"
     exit 1; fi
( read Scheck
  if test "$Scheck" != $CurArch
  then echo "Please unpack part $Scheck next!"
       exit 1;
  else exit 0; fi
) < s2_seq_.tmp || exit 1
echo "x - Continuing file calc2.9.0/help/intro"
sed 's/^X//' << 'SHAR_EOF' >> calc2.9.0/help/intro
X
X		fact(old)
X
X	and the calculator prints 13763753091226345046315979581580902400000000.
X	Notice that numbers can be very large. (There is a practical limit
X	of several thousand digits before calculations become too slow.)
X
X	The calculator can calculate transcendental functions, and accept and
X	display numbers in real or exponential format. For example, typing:
X
X		config("display", 50)
X		epsilon(1e-50)
X		sin(1)
X
X	prints "~.84147098480789650665250232163029899962256306079837".
X
X	The calculator also knows about complex numbers, so that typing:
X
X		(2+3i) * (4-3i)
X
X	prints "17+6i".
SHAR_EOF
echo "File calc2.9.0/help/intro is complete"
chmod 0644 calc2.9.0/help/intro || echo "restore of calc2.9.0/help/intro fails"
set `wc -c calc2.9.0/help/intro`;Sum=$1
if test "$Sum" != "1895"
then echo original size 1895, current size $Sum;fi
echo "x - extracting calc2.9.0/help/list (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/list &&
XUsing lists
X
X	Lists are a sequence of values which are doubly linked so that
X	elements can be removed or inserted anywhere within the list.
X	The function 'list' creates a list with possible initial elements.
X	For example,
X
X		x = list(4, 6, 7);
X
X	creates a list in the variable x of three elements, in the order
X	4, 6, and 7.
X
X	The 'push' and 'pop' functions insert or remove an element from
X	the beginning of the list.  The 'append' and 'remove' functions
X	insert or remove an element from the end of the list.  The 'insert'
X	and 'delete' functions insert or delete an element from the middle
X	(or ends) of a list.  The functions which insert elements return
X	the null value, but the functions which remove an element return
X	the element as their value.  The 'size' function returns the number
X	of elements in the list.
X
X	Note that these functions manipulate the actual list argument,
X	instead of returning a new list.  Thus in the example:
X
X		push(x, 9);
X
X	x becomes a list of four elements, in the order 9, 4, 6, and 7.
X	Lists can be copied by assigning them to another variable.
X
X	An arbitrary element of a linked list can be accessed by using the
X	double-bracket operator.  The beginning of the list has index 0.
X	Thus in the new list x above, the expression x[[0]] returns the
X	value of the first element of the list, which is 9.  Note that this
X	indexing does not remove elements from the list.
X
X	Since lists are doubly linked in memory, random access to arbitrary
X	elements can be slow if the list is large.  However, for each list
X	a pointer is kept to the latest indexed element, thus relatively
X	sequential accesses to the elements in a list will not be slow.
X
X	Lists can be searched for particular values by using the 'search'
X	and 'rsearch' functions.  They return the element number of the
X	found value (zero based), or null if the value does not exist in
X	the list.
SHAR_EOF
chmod 0644 calc2.9.0/help/list || echo "restore of calc2.9.0/help/list fails"
set `wc -c calc2.9.0/help/list`;Sum=$1
if test "$Sum" != "1880"
then echo original size 1880, current size $Sum;fi
echo "x - extracting calc2.9.0/help/mat (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/mat &&
XUsing matrices
X
X	Matrices can have from 1 to 4 dimensions, and are indexed by a
X	normal-sized integer.  The lower and upper bounds of a matrix can
X	be specified at runtime.  The elements of a matrix are defaulted
X	to zeroes, but can be assigned to be of any type.  Thus matrices
X	can hold complex numbers, strings, objects, etc.  Matrices are
X	stored in memory as an array so that random access to the elements
X	is easy.
X
X	Matrices are normally indexed using square brackets.  If the matrix
X	is multi-dimensional, then an element can be indexed either by
X	using multiple pairs of square brackets (as in C), or else by
X	separating the indexes by commas.  Thus the following two statements
X	reference the same matrix element:
X
X		x = name[3][5];
X		x = name[3,5];
X
X	The double-square bracket operator can be used on any matrix to
X	make references to the elements easy and efficient.  This operator
X	bypasses the normal indexing mechanism, and treats the array as if
X	it was one-dimensional and with a lower bound of zero.  In this
X	indexing mode, elements correspond to the normal indexing mode where
X	the rightmost index increases most frequently.  For example, when
X	using double-square bracket indexing on a two-dimensional matrix,
X	increasing indexes will reference the matrix elements left to right,
X	row by row.  Thus in the following example, 'x' and 'y' are copied
X	from the same matrix element:
X
X		mat m[1:2, 1:3];
X		x = m[2,1];
X		y = m[[3]];
X
X	There are functions which return information about a matrix.
X	The 'size' functions returns the total number of elements.
X	The 'matdim', 'matmin', and 'matmax' functions return the number
X	of dimensions of a matrix, and the lower and upper index bounds
X	for a dimension of a matrix.  For square matrices, the 'det'
X	function calculates the determinant of the matrix.
X
X	Some functions return matrices as their results.  These	functions
X	do not affect the original matrix argument, but instead return
X	new matrices.  For example, the 'mattrans' function returns the
X	transpose of a matrix, and 'inverse' returns the inverse of a
X	matrix.  So to invert a matrix called 'x', you could use:
X
X		x = inverse(x);
X
X	The 'matfill' function fills all elements of a matrix with the
X	specified value, and optionally fills the diagonal elements of a
X	square matrix with a different value.  For example:
X
X		matfill(x,1);
X
X	will fill any matrix with ones, and:
X
X		matfill(x, 0, 1);
X
X	will create an identity matrix out of any square matrix.  Note that
X	unlike most matrix functions, this function does not return a matrix
X	value, but manipulates the matrix argument itself.
X
X	Matrices can be multiplied by numbers, which multiplies each element
X	by the number.  Matrices can also be negated, conjugated, shifted,
X	rounded, truncated, fraction'ed, and modulo'ed.  Each of these
X	operations is applied to each element.
X
X	Matrices can be added or multiplied together if the operation is
X	legal.  Note that even if the dimensions of matrices are compatible,
X	operations can still fail because of mismatched lower bounds.  The
X	lower bounds of two matrices must either match, or else one of them
X	must have a lower bound of zero.  Thus the following code:
X
X		mat x[3:3];
X		mat y[4:4];
X		z = x + y;
X
X	fails because the calculator does not have a way of knowing what
X	the bounds should be on the resulting matrix.  If the bounds match,
X	then the resulting matrix has the same bounds.  If exactly one of
X	the lower bounds is zero, then the resulting matrix will have the
X	nonzero lower bounds.  Thus means that the bounds of a matrix are
X	preserved when operated on by matrices with lower bounds of zero.
X	For example:
X
X		mat x[3:7];
X		mat y[5];
X		z = x + y;
X
X	will succeed and assign the variable 'z' a matrix whose
X	bounds are 3-7.
X
X	Vectors are matrices of only a single dimension.  The 'dp' and 'cp'
X	functions calculate the dot product and cross product of a vector
X	(cross product is only defined for vectors of size 3).
X
X	Matrices can be searched for particular values by using the 'search'
X	and 'rsearch' functions.  They return the element number of the
X	found value (zero based), or null if the value does not exist in the
X	matrix.  Using the element number in double-bracket indexing will
X	then refer to the found element.
SHAR_EOF
chmod 0644 calc2.9.0/help/mat || echo "restore of calc2.9.0/help/mat fails"
set `wc -c calc2.9.0/help/mat`;Sum=$1
if test "$Sum" != "4259"
then echo original size 4259, current size $Sum;fi
echo "x - extracting calc2.9.0/help/obj.file (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/obj.file &&
XUsing objects
X
X	Objects are user-defined types which are associated with user-
X	defined functions to manipulate them.  Object types are defined
X	similarly to structures in C, and consist of one or more elements.
X	The advantage of an object is that the user-defined routines are
X	automatically called by the calculator for various operations,
X	such as addition, multiplication, and printing.  Thus they can be
X	manipulated by the user as if they were just another kind of number.
X
X	An example object type is "surd", which represents numbers of the form
X
X		a + b*sqrt(D),
X
X	where D is a fixed integer, and 'a' and 'b' are arbitrary rational
X	numbers.  Addition, subtraction, multiplication, and division can be
X	performed on such numbers, and the result can be put unambiguously
X	into the same form.  (Complex numbers are an example of surds, where
X	D is -1.)
X
X	The "obj" statement defines either an object type or an actual
X	variable of that type.  When defining the object type, the names of
X	its elements are specified inside of a pair of braces.  To define
X	the surd object type, the following could be used:
X
X		obj surd {a, b};
X
X	Here a and b are the element names for the two components of the
X	surd object.  An object type can be defined more than once as long
X	as the number of elements and their names are the same.
X
X	When an object is created, the elements are all defined with zero
X	values.  A user-defined routine should be provided which will place
X	useful values in the elements.  For example, for an object of type
X	'surd', a function called 'surd' can be defined to set the two
X	components as follows:
X
X		define surd(a, b)
X		{
X			local x;
X
X			obj surd x;
X			x.a = a;
X			x.b = b;
X			return x;
X		}
X
X	When an operation is attempted for an object, user functions with
X	particular names are automatically called to perform the operation.
X	These names are created by concatenating the object type name and
X	the operation name together with an underscore.  For example, when
X	multiplying two objects of type surd, the function "surd_mul" is
X	called.
X
X	The user function is called with the necessary arguments for that
X	operation.  For example, for "surd_mul", there are two arguments,
X	which are the two numbers.  The order of the arguments is always
X	the order of the binary operands.  If only one of the operands to
X	a binary operator is an object, then the user function for that
X	object type is still called.  If the two operands are of different
X	object types, then the user function that is called is the one for
X	the first operand.
X
X	The above rules mean that for full generality, user functions
X	should detect that one of their arguments is not of its own object
X	type by using the 'istype' function, and then handle these cases
X	specially.  In this way, users can mix normal numbers with object
X	types.  (Functions which only have one operand don't have to worry
X	about this.)  The following example of "surd_mul" demonstrates how
X	to handle regular numbers when used together with surds:
X
X		define surd_mul(a, b)
X		{
X			local x;
X
X			obj surd x;
X			if (!istype(a, x)) {	
X				/* a not of type surd */
X				x.a = b.a * a;
X				x.b = b.b * a;
X			} else if (!istype(b, x)) {
X				/* b not of type surd */
X				x.a = a.a * b;
X				x.b = a.b * b;
X			} else {			
X				/* both are surds */
X				x.a = a.a * b.a + D * a.b * b.b;
X				x.b = a.a * b.b + a.b * b.a;
X			}
X			if (x.b == 0)
X				return x.a;	/* normal number */
X			return x;		/* return surd */
X		}
X
X	In order to print the value of an object nicely, a user defined
X	routine can be provided.  For small amounts of output, the print
X	routine should not print a newline.  Also, it is most convenient
X	if the printed object looks like the call to the creation routine.
X	For output to be correctly collected within nested output calls,
X	output should only go to stdout.  This means use the 'print'
X	statement, the 'printf' function, or the 'fprintf' function with
X	'files(1)' as the output file.  For example, for the "surd" object:
X
X		define surd_print(a)
X		{
X			print "surd(" : a.a : "," : a.b : ")" : ;
X		}
X
X	It is not necessary to provide routines for all possible operations
X	for an object, if those operations can be defaulted or do not make
X	sense for the object.  The calculator will attempt meaningful
X	defaults for many operations if they are not defined.  For example,
X	if 'surd_square' is not defined to square a number, then 'surd_mul'
X	will be called to perform the squaring.  When a default is not
X	possible, then an error will be generated.
X
X	Please note: Arguments to object functions are always passed by
X	reference (as if an '&' was specified for each variable in the call).
X	Therefore, the function should not modify the parameters, but should
X	copy them into local variables before modifying them.  This is done
X	in order to make object calls quicker in general.
X
X	The double-bracket operator can be used to reference the elements
X	of any object in a generic manner.  When this is done, index 0
X	corresponds to the first element name, index 1 to the second name,
X	and so on.  The 'size' function will return the number of elements
X	in an object.
X
X	The following is a list of the operations possible for objects.
X	The 'xx' in each function name is replaced with the actual object
X	type name.  This table is displayed by the 'show objfuncs' command.
X
X		Name	Args	Comments
X
X		xx_print    1	print value, default prints elements
X		xx_one      1	multiplicative identity, default is 1
X		xx_test     1	logical test (false,true => 0,1), 
X				    default tests elements
X		xx_add      2	
X		xx_sub      2	subtraction, default adds negative
X		xx_neg      1	negative
X		xx_mul      2	
X		xx_div      2	non-integral division, default multiplies 
X				    by inverse
X		xx_inv      1	multiplicative inverse
X		xx_abs      2	absolute value within given error
X		xx_norm     1	square of absolute value
X		xx_conj     1	conjugate
X		xx_pow      2	integer power, default does multiply, 
X				    square, inverse
X		xx_sgn      1	sign of value (-1, 0, 1)
X		xx_cmp      2	equality (equal,non-equal => 0,1), 
X				    default tests elements
X		xx_rel      2	inequality (less,equal,greater => -1,0,1)
X		xx_quo      2	integer quotient
X		xx_mod      2	remainder of division
X		xx_int      1	integer part
X		xx_frac     1	fractional part
X		xx_inc      1	increment, default adds 1
X		xx_dec      1	decrement, default subtracts 1
X		xx_square   1	default multiplies by itself
X		xx_scale    2	multiply by power of 2
X		xx_shift    2	shift left by n bits (right if negative)
X		xx_round    2	round to given number of decimal places
X		xx_bround   2	round to given number of binary places
X		xx_root     3	root of value within given error
X		xx_sqrt     2	square root within given error
X
X
X	Also see the library files:
X
X		dms.cal
X		mod.cal
X		poly.cal
X		quat.cal
X		surd.cal
SHAR_EOF
chmod 0644 calc2.9.0/help/obj.file || echo "restore of calc2.9.0/help/obj.file fails"
set `wc -c calc2.9.0/help/obj.file`;Sum=$1
if test "$Sum" != "6792"
then echo original size 6792, current size $Sum;fi
echo "x - extracting calc2.9.0/help/operator (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/operator &&
XOperators
X
X	The operators are similar to C, but the precedence of most of
X	the operators differs.  In addition, there are several additional
X	operators, and some C operators are missing.  The following list
X	gives the operators arranged in order of precedence, from the
X	least tightly binding to the most tightly binding.
X
X
X	,	Comma operator.
X		For situations in which a comma is used for another purpose
X		(function arguments, array indexing, and the print statement),
X		parenthesis must be used around the comma operator.
X
X	a?:b:c	Conditional value.
X		The test for 'a' is identical to an if test.
X
X	=  +=  -=  *=  /=  %=  //=  &=  |=  <<=  >>=  ^=  **=
X		Assignments.
X
X	||	Conditional OR.
X		Unlike C, the result is the first non-zero expression or 0,
X		instead of just 0 or 1.
X
X	&&	Conditional AND.
X		Unlike C, the result is the last expression or 0,
X		instead of just 0 or 1.
X
X	==  !=  <=  >=  <  >
X		Relations.
X
X	+  -
X		Binary plus and minus.
X
X	*  /  //  %
X		Multiply, divide. and modulo.
X		Please Note: The '/' operator is a fractional divide,
X		whereas the '//' is an integral divide.  Thus think of '/'
X		as division of real numbers, and think of '//' as division
X		of integers (e.g., 8 / 3 is 8/3 whereas 8 // 3 is 2).
X		The '%' is integral or fractional modulus (e.g., 11%4 is 3,
X		and 10%pi() is ~.575222).
X
X	|	Logical OR.
X		The signs of numbers do not affect the bit value.
X
X	&	Logical AND.
X		The signs of numbers do not affect the bit value.
X
X	^  **  <<  >>
X		Powers and shifts.
X		The '^' and '**' are both exponentiation (e.g., 2^3 is 8).
X		The signs of numbers do not affect the bit values of shifts.
X		These operators associate rightward (e.g., 1<<3^2 is 512).
X
X	+  -  !
X		Unary operators.
X		The '!' is the logical NOT operator.  Be careful about
X		using this as the first character of a top level command,
X		since it is also used for executing shell commands.
X
X	++  --
X		Pre or post indexing.
X		These are applicable only to variables.
X
X	[ ]  [[ ]]  .  ( )
X		Indexing, double-bracket indexing, element references,
X		and function calls.  Indexing can only be applied to matrices,
X		element references can only be applied to objects, but
X		double-bracket indexing can be applied to matrices, objects,
X		or lists.
X
X	variables  constants  .  ( )
X		These are variable names and constants, the special '.' symbol,
X		or a parenthesized expression.  Variable names begin with a
X		letter, but then can contain letters, digits, or underscores.
X		Constants are numbers in various formats, or strings inside
X		either single or double quote marks.
SHAR_EOF
chmod 0644 calc2.9.0/help/operator || echo "restore of calc2.9.0/help/operator fails"
set `wc -c calc2.9.0/help/operator`;Sum=$1
if test "$Sum" != "2550"
then echo original size 2550, current size $Sum;fi
echo "x - extracting calc2.9.0/help/overview (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/overview &&
X			CALC - An arbitrary precision calculator.
X				by David I. Bell
X
X
X	This is a calculator program with arbitrary precision arithmetic.
X	All numbers are represented as fractions with arbitrarily large
X	numerators and denominators which are always reduced to lowest terms.
X	Real or exponential format numbers can be input and are converted
X	to the equivalent fraction.  Hex, binary, or octal numbers can be
X	input by using numbers with leading '0x', '0b' or '0' characters.
X	Complex numbers can be input using a trailing 'i', as in '2+3i'.
X	Strings and characters are input by using single or double quotes.
X
X	Commands are statements in a C-like language, where each input
X	line is treated as the body of a procedure.  Thus the command
X	line can contain variable declarations, expressions, labels,
X	conditional tests, and loops.  Assignments to any variable name
X	will automatically define that name as a global variable.  The
X	other important thing to know is that all non-assignment expressions
X	which are evaluated are automatically printed.  Thus, you can evaluate 
X	an expression's value by simply typing it in.
X
X	Many useful built-in mathematical functions are available.  Use
X	the 'show builtins' command to list them.  You can also define
X	your own functions by using the 'define' keyword, followed by a
X	function declaration very similar to C.  Functions which only
X	need to return a simple expression can be defined using an
X	equals sign, as in the example 'define sc(a,b) = a^3 + b^3'.
X	Variables in functions can be defined as either 'global', 'local',
X	or 'static'.  Global variables are common to all functions and the
X	command line, whereas local variables are unique to each function
X	level, and are destroyed when the function returns.  Static variables
X	are scoped within single input files, or within functions, and are
X	never destroyed.  Variables are not typed at definition time, but
X	dynamically change as they are used.  So you must supply the correct
X	type of variable to those functions and operators which only work
X	for a subset of types.
X
X	By default, arguments to functions are passed by value (even
X	matrices).  For speed, you can put an ampersand before any
X	variable argument in a function call, and that variable will be
X	passed by reference instead.  However, if the function changes
X	its argument, the variable will change.  Arguments to built-in
X	functions and object manipulation functions are always called
X	by reference.  If a user-defined function takes more arguments
X	than are passed, the undefined arguments have the null value.
X	The 'param' function returns function arguments by argument
X	number, and also returns the number of arguments passed.  Thus
X	functions can be written to handle an arbitrary number of
X	arguments.
X
X	The mat statement is used to create a matrix.  It takes a
X	variable name, followed by the bounds of the matrix in square
X	brackets.  The lower bounds are zero by default, but colons can
X	be used to change them.  For example 'mat foo[3, 1:10]' defines
X	a two dimensional matrix, with the first index ranging from 0
X	to 3, and the second index ranging from 1 to 10.  The bounds of
X	a matrix can be an expression calculated at runtime.
X
X	Lists of values are created using the 'list' function, and values can
X	be inserted or removed from either the front or the end of the list.
X	List elements can be indexed directly using double square brackets.
X
X	The obj statement is used to create an object.  Objects are
X	user-defined values for which user-defined routines are
X	implicitly called to perform simple actions such as add,
X	multiply, compare, and print. Objects types are defined as in
X	the example 'obj complex {real, imag}', where 'complex' is the
X	name of the object type, and 'real' and 'imag' are element
X	names used to define the value of the object (very much like
X	structures).  Variables of an object type are created as in the
X	example 'obj complex x,y', where 'x' and 'y' are variables.
X	The elements of an object are referenced using a dot, as in the
X	example 'x.real'. All user-defined routines have names composed
X	of the object type and the action to perform separated by an
X	underscore, as in the example 'complex_add'.  The command 'show
X	objfuncs' lists all the definable routines.  Object routines
X	which accept two arguments should be prepared to handle cases
X	in which either one of the arguments is not of the expected
X	object type.
X
X	These are the differences between the normal C operators and
X	the ones defined by the calculator.  The '/' operator divides
X	fractions, so that '7 / 2' evaluates to 7/2. The '//' operator
X	is an integer divide, so that '7 // 2' evaluates to 3.  The '^'
X	operator is a integral power function, so that 3^4 evaluates to
X	81.  Matrices of any dimension can be treated as a zero based
X	linear array using double square brackets, as in 'foo[[3]]'.
X	Matrices can be indexed by using commas between the indices, as
X	in foo[3,4].  Object and list elements can be referenced by
X	using double square brackets.
X
X	The print statement is used to print values of expressions.
X	Separating values by a comma puts one space between the output
X	values, whereas separating values by a colon concatenates the
X	output values.  A trailing colon suppresses printing of the end
X	of line.  An example of printing is 'print \"The square of\",
X	x, \"is\", x^2\'.
X
X	The 'config' function is used to modify certain parameters that
X	affect calculations or the display of values.  For example, the
X	output display mode can be set using 'config(\"mode\", type)',
X	where 'type' is one of 'frac', 'int', 'real', 'exp', 'hex',
X	'oct', or 'bin'.  The default output mode is real.  For the
X	integer, real, or exponential formats, a leading '~' indicates
X	that the number was truncated to the number of decimal places
X	specified by the default precision.  If the '~' does not
X	appear, then the displayed number is the exact value.
X
X	The number of decimal places printed is set by using
X	'config(\"display\", n)'.  The default precision for
X	real-valued functions can be set by using 'epsilon(x)', where x
X	is the required precision (such as 1e-50).
X
X	There is a command stack feature so that you can easily
X	re-execute previous commands and expressions from the terminal.
X	You can also edit the current command before it is completed.
X	Both of these features use emacs-like commands.
X
X	Files can be read in by using the 'read filename' command.
X	These can contain both functions to be defined, and expressions
X	to be calculated.  Global variables which are numbers can be
X	saved to a file by using the 'write filename' command.
SHAR_EOF
chmod 0644 calc2.9.0/help/overview || echo "restore of calc2.9.0/help/overview fails"
set `wc -c calc2.9.0/help/overview`;Sum=$1
if test "$Sum" != "6614"
then echo original size 6614, current size $Sum;fi
echo "x - extracting calc2.9.0/help/statement (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/statement &&
XStatements
X
X	Statements are very much like C statements.  Most statements act
X	identically to those in C, but there are minor differences and
X	some additions.  The following is a list of the statement types,
X	with explanation of the non-C statements.  In this list, upper
X	case words identify the keywords which are actually in lower case.
X	Statements are generally terminated with semicolons, except if the
X	statement is the compound one formed by matching braces.  Various
X	expressions are optional and may be omitted (as in RETURN).
X
X
X	NOTE: Calc commands are in lower case.   UPPER case is used below
X	      for emphasis only, and should be considered in lower case.
X
X
X	IF (expr) statement
X	IF (expr) statement ELSE statement
X	FOR (optionalexpr ; optionalexpr ; optionalexpr) statement
X	WHILE (expr) statement
X	DO statement WHILE (expr)
X	CONTINUE
X	BREAK
X	GOTO label
X		These all work like in normal C.
X
X	RETURN optionalexpr
X		This returns a value from a function.  Functions always
X		have a return value, even if this statement is not used.
X		If no return statement is executed, or if no expression
X		is specified in the return statement, then the return
X		value from the function is the null type.
X
X	SWITCH (expr) { caseclauses }
X		Switch statements work similarly to C, except for the
X		following.  A switch can be done on any type of value,
X		and the case statements can be of any type of values.
X		The case statements can also be expressions calculated
X		at runtime.  The calculator compares the switch value
X		with each case statement in the order specified, and
X		selects the first case which matches.  The default case
X		is the exception, and only matches once all other cases
X		have been tested.
X
X	{ statements }
X		This is a normal list of statements, each one ended by
X		a semicolon.  Unlike the C language, no declarations are
X		permitted within an inner-level compound statement.
X		Declarations are only permitted at the beginning of a
X		function definition, or at the beginning of an expression
X		sequence.
X
X	MAT variable [dimension] [dimension] ...
X	MAT variable [dimension, dimension, ...]
X	MAT variable [] = { value, ... }
X		This creates a matrix variable with the specified dimensions.
X		Matrices can have from 1 to 4 dimensions.  When specifying
X		multiple dimensions, you can use either the standard C syntax,
X		or else you can use commas for separating the dimensions.
X		For example, the following two statements are equivalent,
X		and so will create the same two dimensional matrix:
X
X			mat foo[3][6];
X			mat foo[3,6];
X
X		By default, each dimension is indexed starting at zero,
X		as in normal C, and contains the specified number of
X		elements.  However, this can be changed if a colon is
X		used to separate two values.  If this is done, then the
X		two values become the lower and upper bounds for indexing.
X		This is convenient, for example, to create matrices whose
X		first row and column begin at 1.  Examples of matrix
X		definitions are:
X
X			mat x[3]	one dimension, bounds are 0-2
X			mat foo[4][5]	two dimensions, bounds are 0-3 and 0-4
X			mat a[-7:7]	one dimension, bounds are (-7)-7
X			mat s[1:9,1:9]	two dimensions, bounds are 1-9 and 1-9
X
X		Note that the MAT statement is not a declaration, but is
X		executed at runtime.  Within a function, the specified
X		variable must already be defined, and is just converted to
X		a matrix of the specified size, and all elements are set
X		to the value of zero.  For convenience, at the top level
X		command level, the MAT command automatically defines a
X		global variable of the specified name if necessary.
X
X		Since the MAT statement is executed, the bounds on the
X		matrix can be full expressions, and so matrices can be
X		dynamically allocated.  For example:
X
X			size = 20;
X			mat data[size*2];
X
X		allocates a matrix which can be indexed from 0 to 39.
X
X		Initial values for the elements of a matrix can be specified
X		by following the bounds information with an equals sign and
X		then a list of values enclosed in a pair of braces.  Even if
X		the matrix has more than one dimension, the elements must be
X		specified as a linear list.  If too few values are specified,
X		the remaining values are set to zero.  If too many values are
X		specified, a runtime error will result.  Examples of some
X		initializations are:
X
X			mat table1[5] = {77, 44, 22};
X			mat table2[2,2] = {1, 2, 3, 4};
X
X		When an initialization is done, the bounds of the matrix
X		can optionally be left out of the square brackets, and the
X		correct bounds (zero based) will be set.  This can only be
X		done for one-dimensional matrices.  An example of this is:
X
X			mat fred[] = {99, 98, 97};
X
X		The MAT statement can also be used in declarations to set
X		variables as being matrices from the beginning.  For example:
X
X			local mat temp[5];
X			static mat strtable[] = {"hi", "there", "folks");
X
X	OBJ type { elementnames } optionalvariables
X	OBJ type variable
X
X		These create a new object type, or create one or more
X		variables of the specified type.  For this calculator,
X		an object is just a structure which is implicitly acted
X		on by user defined routines.  The user defined routines
X		implement common operations for the object, such as plus
X		and minus, multiply and divide, comparison and printing.
X		The calculator will automatically call these routines in
X		order to perform many operations.
X	
X		To create an object type, the data elements used in
X		implementing the object are specified within a pair
X		of braces, separated with commas.  For example, to
X		define an object will will represent points in 3-space,
X		whose elements are the three coordinate values, the
X		following could be used:
X	
X			obj point {x, y, z};
X	
X		This defines an object type called point, whose elements
X		have the names x, y, and z.  The elements are accessed
X		similarly to structure element accesses, by using a period.
X		For example, given a variable 'v' which is a point object,
X		the three coordinates of the point can be referenced by:
X
X			v.x
X			v.y
X			v.z
X
X		A particular object type can only be defined once, and
X		is global throughout all functions.  However, different
X		object types can be used at the same time.
X
X		In order to create variables of an object type, they
X		can either be named after the right brace of the object
X		creation statement, or else can be defined later with
X		another obj statement.  To create two points using the
X		second (and most common) method, the following is used:
X
X			obj point p1, p2;	
X
X		This statement is executed, and is not a declaration.
X		Thus within a function, the variables p1 and p2 must have
X		been previously defined, and are just changed to be the
X		new object type.  For convenience, at the top level command
X		level, object variables are automatically defined as being
X		global when necessary.
X
X		Initial values for an object can be specified by following
X		the variable name by an equals sign and a list of values
X		enclosed in a pair of braces.  For example:
X
X			obj point pt = {5, 6};
X
X		The OBJ statement can also be used in declarations to set
X		variables as being objects from the beginning.  If multiple
X		variables are specified, then each one is defined as the
X		specified object type.  Examples of declarations are:
X
X			local obj point temp1;
X			static obj point temp2 = {4, 3};
X			global obj point p1, p2, p3;
X
X	EXIT string
X	QUIT string
X
X		This command is used in two cases.  At the top command
X		line level, quit will exit from the calculator.  This
X		is the normal way to leave the calculator.  In any other
X		use, quit will abort the current calculation as if an
X		error had occurred.  If a string is given, then the string
X		is printed as the reason for quitting, otherwise a general
X		quit message is printed.  The routine name and line number
X		which executed the quit is also printed in either case.
X
X		Quit is useful when a routine detects invalid arguments,
X		in order to stop a calculation cleanly.  For example,
X		for a square root routine, an error can be given if the
X		supplied parameter was a negative number, as in:
X
X			define mysqrt(n)
X			{
X				if (n < 0)
X					quit "Negative argument";
X				...
X			}
X
X		Exit is an alias for quit.
X
X
X	PRINT exprs
X
X		For interactive expression evaluation, the values of all
X		typed-in expressions are automatically displayed to the
X		user.  However, within a function or loop, the printing of
X		results must be done explicitly.  This can be done using
X		the 'printf' or 'fprintf' functions, as in standard C, or
X		else by using the built-in 'print' statement.  The advantage
X		of the print statement is that a format string is not needed.
X		Instead, the given values are simply printed with zero or one
X		spaces between each value.
X
X		Print accepts a list of expressions, separated either by
X		commas or colons.  Each expression is evaluated in order
X		and printed, with no other output, except for the following
X		special cases.  The comma which separates expressions prints
X		a single space, and a newline is printed after the last
X		expression unless the statement ends with a colon.  As
X		examples:
X
X			print 3, 4;		prints "3 4" and newline.
X			print 5:;		prints "5" with no newline.
X			print 'a' : 'b' , 'c';	prints "ab c" and newline.
X			print;			prints a newline.
X
X		For numeric values, the format of the number depends on the
X		current "mode" configuration parameter.  The initial mode
X		is to print real numbers, but it can be changed to other
X		modes such as exponential, decimal fractions, or hex.
X
X		If a matrix or list is printed, then the elements contained
X		within the matrix or list will also be printed, up to the
X		maximum number specified by the "maxprint" configuration
X		parameter.  If an element is also a matrix or a list, then
X		their values are not recursively printed.  Objects are printed
X		using their user-defined routine.  Printing a file value
X		prints the name of the file that was opened.
X
X
X	SHOW item
X
X		This command displays some information.
X		The following is a list of the various items:
X
X			builtins	built in functions
X			globals		global variables
X			functions	user-defined functions
X			objfuncs	possible object functions
X			memory		memory usage
X	
X
X	Also see the help topic:
X
X		command         top level commands
SHAR_EOF
chmod 0644 calc2.9.0/help/statement || echo "restore of calc2.9.0/help/statement fails"
set `wc -c calc2.9.0/help/statement`;Sum=$1
if test "$Sum" != "10197"
then echo original size 10197, current size $Sum;fi
echo "x - extracting calc2.9.0/help/todo (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/todo &&
XNeeded enhancements
X
X	Send calc comments, suggestions, bug fixes, enhancements and
X	interesting calc scripts that you would like you see included in
X	future distributions to:
X
X		dbell@canb.auug.org.au
X		chongo@toad.com
X
X	The following items are in the calc wish list.  Programs like this
X	can be extended and improved forever.
X
X	*  Implement an autoload feature.  Associate a calc library filename
X	   with a function or global variable.  On the first reference of
X	   such item, perform an automatic load of that file.
X
X	*  Use faster multiply and divide algorithms for large numbers.
X
X	*  Add error handling statements, so that QUITs, errors from the 
X	   'eval' function, division by zeroes, and so on can be caught.
X	   This should be done using syntax similar to:
X
X		    ONERROR statement DO statement;
X
X	   Something like signal isn't versatile enough.
X
X	*  Add a debugging capability so that functions can be single stepped,
X	   breakpoints inserted, variables displayed, and so on.
X
X	*  Figure out how to write all variables out to a file, including
X	   deeply nested arrays, lists, and objects.
X
X	*  Implement pointers.
X
X	*  Eliminate the need for the define keyword by doing smarter parsing.
X
X	*  Allow results of a command (or all commands) to be re-directed to a 
X	   file or piped into a command.
X
X	*  Add some kind of #include and #define facility.  Perhaps use
X	   the C pre-processor itself?
X
X	*  Allow one to undefine anything.  Allow one to test if anything
X	   is defined.
X
X	*  Support a more general input and output base mode other than
X	   just dec, hex or octal.
X
X	*  Allow support of POSIX bc via a translator reads bc commands, 
X	   converts it to calc and pipes it into calc.
X
X	*  Implement a form of symbolic algebra.  Work on this has already
X	   begun.  This will use backquotes to define expressions, and new
X	   functions will be able to act on expressions.  For example:
X
X	   	x = `hello * strlen(mom)`;
X		x = sub(x, `hello`, `hello + 1`);
X		x = sub(x, `hello`, 10, `mom`, "curds");
X		eval(x);
X
X	   prints 55.
X
X	*  Place the results of previous commands into a parallel history list.
X	   Add a binding that returns the saved result of the command so
X	   that one does not need to re-execute a previous command simply
X	   to obtain its value.
X
X	   If you have a command that takes a very long time to execute,
X	   it would be nice if you could get at its result without having
X	   to spend the time to reexecute it.
X
X	*  Add a binding to delete a value from the history list.
X
X	   One may need to remove a large value from the history list if
X	   it is very large.  Deleting the value would replace the history
X	   entry with a null value.
X
X	*  Add a binding to delete a command from the history list.
X
X	   Since you can delete values, you might as well be able to
X	   delete commands.
X
X	*  All one to alter the size of the history list thru config().
X
X	   In some cases, 256 values is too small, in others it is too large.
X
X	*  Add a builtin that returns a value from the history list.
X	   As an example:
X
X		histval(-10)
X	
X	   returns the 10th value on the history value list, if such 
X	   a value is in the history list (null otherwise).  And:
X
X		histval(23)
X	
X	   return the value of the 23rd command given to calc, if
X	   such a value is in the history list (null otherwise).
X
X	   It would be very helpful to use the history values in
X	   subsequent equations.
X
X	*  Add a builtin that returns command as a string from the
X	   history list.  As an example:
X
X		history(-10)
X	
X	   returns a string containing the 10th command on the
X	   history list, if a such a value is in the history list 
X	   (empty string otherwise).  And:
X
X		history(23)
X	
X	   return the string containing the 23rd command given to calc, if
X	   such a value is in the history list (empty string otherwise).
X
X	   One could use the eval() function to re-evaluate the command.
X
X	*  Restore the command number to calc prompts.  When going back
X	   in the history list, indicate the command number that is
X	   being examined.
X
X	   The command number was a useful item.  When one is scanning the
X	   history list, knowing where you are is hard without it.  It can
X	   get confusing when the history list wraps or when you use
X	   search bindings.  Command numbers would be useful in
X	   conjunction with positive args for the history() and histval()
X	   functions as suggested above.
X
X	*  Add a builtin that returns the current command number.
X	   For example:
X
X		cmdnum()
X
X	   returns the current command number.
X
X	   This would allow one to tag a value in the history list.  One
X	   could save the result of cmdnum() in a variable and later use
X	   it as an arg to the histval() or history() functions.
X
X	*  Add a builtin to determine if an object as been defined.
X	   For example:
X
X		isobjdef("surd")
X
X	   would return true if one had previously defined the
X	   surd object.  I.e., if "obj surd {...};" had been
X	   executed.
X
X	   One cannot redefine an object.  If a script defines an object,
X	   one cannot reload it without getting lots of already defined
X	   errors.  If two scripts needed the same object, both could
X	   define it and use isobjdef() to avoid redefinition problems.
X
X	*  Add a builtin to determine if a function as been defined.
X	   For example:
X
X		isfunct("foo")
X
X	   would return true if foo has been defined as a function.
X
X	*  Permit one to destroy an object.
X
X	   What if one does want to redefine an object?  Consider the case
X	   where one it debugging a script and wants to reload it.  If
X	   that script defines an object you are doomed.  Perhaps
X	   destroying a object would undefine all of its related functions
X	   and values?
X
X	*  Port calc to a 64 bit machine, or a machine where long was larger
X	   than an int.
X
X	   There are at least two issues here.  The first is fix places
X	   where calc assumes that an int and a long are the same size.
X	   The second and more important would be to change calc so that
X	   it could be configured to work with a base of 2^32.  (Right now
X	   calc is somewhat wired to use base 2^16).
X
X	   In other words first make calc 64 bit safe, then increase
X	   performance on 64 bit machines by allowing one to configure
X	   (via the Makefile) calc to use an larger internal base.
X	
X	*  One some machines (such as the 486), floating point can be faster 
X	   than integer arithmetic.  Often such floating point would allow
X	   for a larger base than 2^16, allowing calc to run even faster.
X	   Allow calc to take advantage of such hardware.
X	
X	*  Add NAN's (Not A Number's) to calc.  Where is it reasonable, change 
X	   calc to process these values in way similar to that of the IEEE 
X	   floating point.
X	
X	*  Add a factoring builtin functions.  Provide functions that perform 
X	   multiple polynomial quadratic sieves, elliptic curve, difference 
X	   of two squares, N-1 factoring as so on.  Provide a easy general 
X	   factoring builtin (say factor(foo)) that would attempt to apply
X	   whatever process was needed based on the value.
X
X	   Factoring builtins would return a matrix of factors.
X
X	   It would be handy to configure, via config(), the maximum time
X	   that one should try to factor a number.  By default the time
X	   should be infinite.  If one set the time limit to a finite
X	   value and the time limit was exceeded, the factoring builtin
X	   would return whatever if had found thus far, even if no new 
X	   factors had been found.
X
X	   Another factoring configuration interface, via config(), that
X	   is needed would be to direct the factoring builtins to return
X	   as soon as a factor was found.
X
X	*  Allow one to disable, via config, the printing of the leading ~
X	   on truncated numeric values.
X
X	   Sometimes the leading ~'s are more annoying than helpful.
X	
X	*  Allow one to disable, via config, the printing of the leading tab 
X	   when printing the value of a command that one just typed.
X
X	   Most of the time, the leading tab is reasonable.  Sometimes
X	   it is not.  It would be helpful if one could turn off the
X	   tab in such cases.
X	
X	*  Allow one to config calc break up long output lines.
X
X	   The command:  calc '2^100000'  will produce one very long
X	   line.  Many times this is reasonable.  Long output lines
X	   are a problem for some utilities.  It would be nice if one
X	   could configure, via config(), calc to fold long lines.
X
X	   By default, calc should continue to produce long lines.
X
X	   One option to config should be to specify the length to
X	   fold output.  Another option should be to append a trailing
X	   \ on folded lines (as some symbolic packages use).
X
X	*  Add scanf() and fscanf() functions.
X
X	   The scanf function should be able to handle both long lines
X	   and split lines with trailing \'s.  It should also be able
X	   to ignore the leading ~.
X
SHAR_EOF
chmod 0644 calc2.9.0/help/todo || echo "restore of calc2.9.0/help/todo fails"
set `wc -c calc2.9.0/help/todo`;Sum=$1
if test "$Sum" != "8781"
then echo original size 8781, current size $Sum;fi
echo "x - extracting calc2.9.0/help/types (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/types &&
XBuiltin types
X
X	The calculator has the following built-in types.
X
X	null value
X		This is the undefined value type.  The function 'null'
X		returns this value.  Functions which do not explicitly
X		return a value return this type.  If a function is called
X		with fewer parameters than it is defined for, then the
X		missing parameters have the null type.  The null value is
X		false if used in an IF test.
X
X	rational numbers
X		This is the basic data type of the calculator.
X		These are fractions whose numerators and denominators
X		can be arbitrarily large.  The fractions are always
X		in lowest terms.  Integers have a denominator of 1.
X		The numerator of the number contains the sign, so that
X		the denominator is always positive.  When a number is
X		entered in floating point or exponential notation, it is
X		immediately converted to the appropriate fractional value.
X		Printing a value as a floating point or exponential value
X		involves a conversion from the fractional representation.
X
X		Numbers are stored in binary format, so that in general,
X		bit tests and shifts are quicker than multiplies and divides.
X		Similarly, entering or displaying of numbers in binary,
X		octal, or hex formats is quicker than in decimal.  The
X		sign of a number does not affect the bit representation
X		of a number.
X
X	complex numbers
X		Complex numbers are composed of real and imaginary parts,
X		which are both fractions as defined above.  An integer which
X		is followed by an 'i' character is a pure imaginary number.
X		Complex numbers such as "2+3i" when typed in, are processed
X		as the sum of a real and pure imaginary number, resulting
X		in the desired complex number.  Therefore, parenthesis are
X		sometimes necessary to avoid confusion, as in the two values:
X
X			1+2i ^2		(which is -3)
X			(1+2i) ^2	(which is -3+4i)
X
X		Similar care is required when entering fractional complex
X		numbers.  Note the differences below:
X
X			3/4i		(which is -(3/4)i)
X			3i/4		(which is (3/4)i)
X
X		The imaginary unit itself is input using "1i".
X
X	strings
X		Strings are a sequence of zero or more characters.
X		They are input using either of the single or double
X		quote characters.  The quote mark which starts the
X		string also ends it.  Various special characters can
X		also be inserted using back-slash.  Example strings:
X
X			"hello\n"
X			"that's all"
X			'lots of """"'
X			'a'
X			""
X
X		There is no distinction between single character and
X		multi-character strings.  The 'str' and 'ord' functions
X		will convert between a single character string and its
X		numeric value.  The 'str' and 'eval' functions will
X		convert between longer strings and the corresponding
X		numeric value (if legal).  The 'strcat', 'strlen', and
X		'substr' functions are also useful.
X
X	matrices
X		These are one to four dimensional matrices, whose minimum
X		and maximum bounds can be specified at runtime.  Unlike C,
X		the minimum bounds of a matrix do not have to start at 0.
X		The elements of a matrix can be of any type.  There are
X		several built-in functions for matrices.  Matrices are
X		created using the 'mat' statement.
X
X	associations
X		These are one to four dimensional matrices which can be
X		indexed by arbitrary values, instead of just integers.
X		These are also known as associative arrays.  The elements of
X		an association can be of any type.  Very few operations are
X		permitted on an association except for indexing.  Associations
X		are created using the 'assoc' function.
X
X	lists
X		These are a sequence of values, which are linked together
X		so that elements can be easily be inserted or removed
X		anywhere in the list.  The values can be of any type.
X		Lists are created using the 'list' function.
X
X	files
X		These are text files opened using stdio.  Files may be opened
X		for sequential reading, writing, or appending.  Opening a
X		file using the 'fopen' function returns a value which can
X		then be used to perform I/O to that file.  File values can
X		be copied by normal assignments between variables, or by
X		using the result of the 'files' function.  Such copies are
X		indistinguishable from each other.
SHAR_EOF
chmod 0644 calc2.9.0/help/types || echo "restore of calc2.9.0/help/types fails"
set `wc -c calc2.9.0/help/types`;Sum=$1
if test "$Sum" != "4070"
then echo original size 4070, current size $Sum;fi
echo "x - extracting calc2.9.0/help/usage (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/usage &&
XCalc command line
X
X	Calc has the following command line:
X
X		calc [-h] [-q] [calc_command ...]
X
X		-h	print a help message  (equivalent to the
X			help command)
X
X		-q	By default, calc executes each file specified
X			in the :-separated list found in the environment
X			variable $CALCRC.  If $CALCRC does not exist,
X			an internal default is used.
X
X	If some calc_commands arguments are given on the command line,
X	calc executes these commands and then exists.  If no command
X	line arguments are given, calc prompts and reads commands
X	from standard input.
SHAR_EOF
chmod 0644 calc2.9.0/help/usage || echo "restore of calc2.9.0/help/usage fails"
set `wc -c calc2.9.0/help/usage`;Sum=$1
if test "$Sum" != "551"
then echo original size 551, current size $Sum;fi
echo "x - extracting calc2.9.0/help/variable (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/help/variable &&
XVariable declarations
X
X	Variables can be declared as either being global, local, or static.
X	Global variables are visible to all functions and on the command
X	line, and are permanent.  Local variables are visible only within
X	a single function or command sequence.  When the function or command
X	sequence returns, the local variables are deleted.  Static variables
X	are permanent like global variables, but are only visible within the
X	same input file or function where they are defined.
X
X	To declare one or more variables, the 'local', 'global', or 'static'
X	keywords are used, followed by the desired list of variable names,
X	separated by commas.  The definition is terminated with a semicolon.
X	Examples of declarations are:
X
X		local	x, y, z;
X		global	fred;
X		local	foo, bar;
X		static	var1, var2, var3;
X
X	Variables may have initializations applied to them.  This is done
X	by following the variable name by an equals sign and an expression.
X	Global and local variables are initialized each time that control
X	reaches them (e.g., at the entry to a function which contains them).
X	Static variables are initialized once only, at the time that control
X	first reaches them (but in future releases the time of initialization
X	may change).  Unlike in C, expressions for static variables may
X	contain function calls and refer to variables.  Examples of such
X	initializations are:
X
X		local	a1 = 7, a2 = 3;
X		static	b = a1 + sin(a2);
X
X	Within function declarations, all variables must be defined.
X	But on the top level command line, assignments automatically define
X	global variables as needed.  For example, on the top level command
X	line, the following defines the global variable x if it had not
X	already been defined:
X
X		x = 7
X
X	The static keyword may be used at the top level command level to
X	define a variable which is only accessible interactively, or within
X	functions defined interactively.
X
X	Variables have no fixed type, thus there is no need or way to
X	specify the types of variables as they are defined.  Instead, the
X	types of variables change as they are assigned to or are specified
X	in special statements such as 'mat' and 'obj'.  When a variable is
X	first defined using 'local', 'global', or 'static', it has the
X	value of zero.
X
X	If a procedure defines a local or static variable name which matches
X	a global variable name, or has a parameter name which matches a
X	global variable name, then the local variable or parameter takes
X	precedence within that procedure, and the global variable is not
X	directly accessible.
X
X	The MAT and OBJ keywords may be used within a declaration statement
X	in order to initially define variables as that type.  Initialization
X	of these variables are also allowed.  Examples of such declarations
X	are:
X
X		static mat table[3] = {5, 6, 7};
X		local obj point p1, p2;
X
X	There are no pointers in the calculator language, thus all
X	arguments to user-defined functions are normally passed by value.
X	This is true even for matrices, strings, and lists.  In order
X	to circumvent this, the '&' operator is allowed before a variable
X	when it is an argument to a function.  When this is done, the
X	address of the variable is passed to the function instead of its
X	value.  This is true no matter what the type of the variable is.
X	This allows for fast calls of functions when the passed variable
X	is huge (such as a large array).  However, the passed variable can
X	then be changed by the function if the parameter is assigned into.
X	The function being called does not need to know if the variable
X	is being passed by value or by address.
X
X	Built-in functions and object functions always accept their
X	arguments as addresses, thus there is no need to use '&' when
X	calling built-in functions.
SHAR_EOF
chmod 0644 calc2.9.0/help/variable || echo "restore of calc2.9.0/help/variable fails"
set `wc -c calc2.9.0/help/variable`;Sum=$1
if test "$Sum" != "3722"
then echo original size 3722, current size $Sum;fi
echo "x - extracting calc2.9.0/lib/Makefile (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/lib/Makefile &&
X#
X# lib - makefile for calc library scripts
X#
X# Copyright (c) 1993 David I. Bell and Landon Curt Noll
X# Permission is granted to use, distribute, or modify this source,
X# provided that this copyright notice remains intact.
X#
X# Arbitrary precision calculator.
X#
X# calculator by David I. Bell
X# makefile by Landon Curt Noll
X
X# Normally, the upper level makefile will set these values.  We provide
X# a default here just in case you want to build from this directory.
X#
X# where to install things
XLIBDIR= /usr/local/lib/calc
X# how to build a directory
XMKDIR=mkdir -p
X#MKDIR=mkdir
X
X# The calc files to install
X#
XCALC_FILES= README bigprime.cal deg.cal ellip.cal lucas.cal lucas_chk.cal \
X	lucas_tbl.cal mersenne.cal mod.cal nextprim.cal pell.cal pi.cal \
X	pollard.cal poly.cal psqrt.cal quat.cal regress.cal solve.cal \
X	sumsq.cal surd.cal unitfrac.cal varargs.cal chrem.cal cryrand.cal \
X	bindings
X
XSHELL= /bin/sh
X
Xall: ${CALC_FILES}
X
Xclean:
X
Xclobber:
X
Xinstall: all
X	-@if [ ! -d ${LIBDIR} ]; then \
X		echo ${MKDIR} ${LIBDIR}; \
X		${MKDIR} ${LIBDIR}; \
X	fi
X	@for i in ${CALC_FILES}; do \
X		echo rm -f ${LIBDIR}/$$i; \
X		rm -f ${LIBDIR}/$$i; \
X		echo cp $$i ${LIBDIR}; \
X		cp $$i ${LIBDIR}; \
X		echo chmod 0444 ${LIBDIR}/$$i; \
X		chmod 0444 ${LIBDIR}/$$i; \
X	done
SHAR_EOF
chmod 0644 calc2.9.0/lib/Makefile || echo "restore of calc2.9.0/lib/Makefile fails"
set `wc -c calc2.9.0/lib/Makefile`;Sum=$1
if test "$Sum" != "1257"
then echo original size 1257, current size $Sum;fi
echo "x - extracting calc2.9.0/lib/README (Text)"
sed 's/^X//' << 'SHAR_EOF' > calc2.9.0/lib/README &&
X
X# Copyright (c) 1993 David I. Bell and Landon Curt Noll
X# Permission is granted to use, distribute, or modify this source,
X# provided that this copyright notice remains intact.
X
XThe following calc library files are provided because they serve as 
Xexamples of how use the calc language, and because the authors thought 
Xthem to be useful!
X
XIf you write something that you think is useful, please send it to:
X
X    dbell@canb.auug.org.au
X    chongo@toad.com                 {uunet,pyramid,sun}!hoptoad!chongo
X
XBy convention, a lib file only defines and/or initializes functions,
Xobjects and variables.  (The regression test is an exception.)  Also by
Xconvention, the a usage message regarding each important object and
Xfunction is printed at the time of the read.
X
XBy convention, the global variable  lib_debug  is used to control
Xthe verbosity of debug information printed by lib files.  By default,
Xthe lib_debug has a value of 0.  If lib_debug < 0, then no debug
Xmessages are printed.  If lib_debug >= 0, then only usage message 
Xregarding each important object are printed at the time of the read.
XIf lib_debug == 0, then only such usage messages are printed; no
Xother debug information is printed.
X
XTo conform to the above convention, your lib files should end with
Xlines of the form:
X
X	global lib_debug;
X	if (lib_debug >= 0) {
X	    print "funcA(side_a, side_b, side_c) defined";
X	    print "funcB(size, mass) defined";
X	}
X
X
X=-=
X
X
Xbernoulli.cal
X
X    B(n)
X
X    Calculate the nth Bernoulli number.
X
X
Xbigprime.cal
X
X    bigprime(a, m, p) 
X
X    A prime test, base a, on p*2^x+1 for even x>m.
X
X
Xchrem.cal
X
X    chrem(r1,m1 [,r2,m2, ...])
X    chrem(rlist, mlist)
X
X    Chinese remainder theorem/problem solver.
X
X
Xcryrand.cal
X
X    shufrand()
X    sshufrand(seed)
X    rand([a, [b]])
X    srand(seed)
X    cryrand([a, [b]])
X    scryrand([seed, [len1, len2]])
X    random([a, [b]])
X    srandom(seed)
X    obj cryobj
X    randstate([cryobj | 0])
X    nxtprime(n, [val, modulus])
X
X    Cryptographically strong pseudo-random number generator library.
X    
X
Xdeg.cal		
X
X    dms(deg, min, sec)
X    dms_add(a, b)
X    dms_neg(a)
X    dms_sub(a, b)
X    dms_mul(a, b)
X    dms_print(a)
X
X    Calculate in degrees, minutes, and seconds.
X
X
Xellip.cal	
X
X    factor(iN, ia, B, force)
X
X    Attempt to factor using the elliptic functions: y^2 = x^3 + a*x + b.
X
X
Xlucas.cal
X
X    lucas(h, n)
X
X    Perform a primality test of h*2^n-1, with 1<=h<2*n.
X
X
Xlucas_chk.cal
X
X    lucas_chk(high_n)
X
X    Test all primes of the form h*2^n-1, with 1<=h<200 and n <= high_n.
X    Requires lucas.cal to be loaded.  The highest useful high_n is 1000.
X
X
Xlucas_tbl.cal
X
X    Lucasian criteria for primality tables.
X
X
Xmersenne.cal
X
X    mersenne(p)
X
X    Perform a primality test of 2^p-1, for prime p>1.
X
X
Xmod.cal	
X
X    mod(a)
X    mod_print(a)
X    mod_one()
X    mod_cmp(a, b)
X    mod_rel(a, b)
X    mod_add(a, b)
X    mod_sub(a, b)
X    mod_neg(a)
X    mod_mul(a, b)
X    mod_square(a)
X    mod_inc(a)
X    mod_dec(a)
X    mod_inv(a)
X    mod_div(a, b)
X    mod_pow(a, b)
X
X    Routines to handle numbers modulo a specified number.
X
X
Xnextprim.cal
X
X    nextprime(n, tries)
X
X    Function to find the next prime (probably).
X
X
Xpell.cal
X
X    pellx(D)
X    pell(D)
X
X    Solve Pell's equation; Returns the solution X to: X^2 - D * Y^2 = 1.
X    Type the solution to pells equation for a particular D.
X
X
Xpi.cal
SHAR_EOF
echo "End of part 15"
echo "File calc2.9.0/lib/README is continued in part 16"
echo "16" > s2_seq_.tmp
exit 0
