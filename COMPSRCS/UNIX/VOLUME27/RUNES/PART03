Newsgroups: comp.sources.unix
From: prb@cray.com
Subject: v27i029: REPOST runes - an implementation of setlocale(3) and all its friends, Part03/03
References: <9309071427.AA14351@krystal.cray.com>
Sender: unix-sources-moderator@gw.home.vix.com
Approved: vixie@gw.home.vix.com

Submitted-By: prb@cray.com
Posting-Number: Volume 27, Issue 29
Archive-Name: runes/part03

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 3)."
# Contents:  doc/euc.4 doc/setlocale.3 libc/rune.c mklocale/yacc.y
# Wrapped by prb@krystal.cray.com on Sun Sep  5 11:15:56 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'doc/euc.4' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/euc.4'\"
else
echo shar: Extracting \"'doc/euc.4'\" \(7430 characters\)
sed "s/^X//" >'doc/euc.4' <<'END_OF_FILE'
X.\" Copyright (c) 1993
X.\"	The Regents of the University of California.  All rights reserved.
X.\"
X.\" This code is derived from software contributed to Berkeley by
X.\" Paul Borman at Krystal Technologies.
X.\"
X.\" Redistribution and use in source and binary forms, with or without
X.\" modification, are permitted provided that the following conditions
X.\" are met:
X.\" 1. Redistributions of source code must retain the above copyright
X.\"    notice, this list of conditions and the following disclaimer.
X.\" 2. Redistributions in binary form must reproduce the above copyright
X.\"    notice, this list of conditions and the following disclaimer in the
X.\"    documentation and/or other materials provided with the distribution.
X.\" 3. All advertising materials mentioning features or use of this software
X.\"    must display the following acknowledgement:
X.\"	This product includes software developed by the University of
X.\"	California, Berkeley and its contributors.
X.\" 4. Neither the name of the University nor the names of its contributors
X.\"    may be used to endorse or promote products derived from this software
X.\"    without specific prior written permission.
X.\"
X.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X.\" SUCH DAMAGE.
X.\"
X.\"	@(#)euc.4	8.1 (Berkeley) 6/4/93
X.\"
X.Dd "June 4, 1993"
X.Dt EUC 4
X.Os
X.Sh NAME
X.Nm EUC
X.Nd EUC encoding of runes
X.Sh SYNOPSIS
X\fBENCODING "EUC"\fP
X.br
X\fBVARIABLE \fP\fIlen1 mask1 len2 mask2 len3 mask3 len4 mask4 mask\fP
X.Sh DESCRIPTION
XThe
X.Nm EUC
Xencoding is provided for compatibility with
X.Ux
Xbased systems.
XSee
X.Xr mklocale 1
Xfor a complete description of the
X.Ev LC_CTYPE
Xsource file format.
X.Pp
X.Nm EUC
Ximplements a system of 4 multibyte codesets.
XA multibyte character in the first codeset consists of
X.Ar len1
Xbytes starting with a byte in the range of 0x00 to 0x7f.
XTo allow use of ASCII,
X.Ar len1
Xis always 1.
XA multibyte character in the second codeset consists of
X.Ar len2
Xbytes starting with a byte in the range of 0x80-0xff excluding 0x8e and 0x8f.
XA multibyte character in the third codeset consists of
X.Ar len3
Xbytes starting with the byte 0x8e.
XA multibyte character in the fourth codeset consists of
X.Ar len4
Xbytes starting with the byte 0x8f.
X.Pp
XThe 
X.Ev rune_t
Xencoding of
X.Nm EUC
Xmultibyte characters is dependent on the
X.Ar len
Xand
X.Ar mask
Xarguments.
XFirst, the bytes are moved into a
X.Ev rune_t
Xas follows:
X.Bd -literal
Xbyte0 << ((\fIlen\fPN-1) * 8) | byte1 << ((\fIlen\fPN-2) * 8) | ... | byte\fIlen\fPN-1
X.Ed
X.sp
XThe result is then ANDed with
X.Ar ~mask
Xand ORed with
X.Ar mask\fPN.
XCodesets 2 and 3 are special in that the leading byte (0x8e or 0x8f) is
Xfirst removed and the
X.Ar len\fPN
Xargument is reduced by 1.
X.sp
XFor example, the Japanese locale has the following
X.Ev VARIABLE
Xline:
X.Bd -literal
XVARIABLE	1 0x0000 2 0x8080 2 0x0080 3 0x8000 0x8080
X.Ed
X.sp
XCodeset 1 consists of the values 0x0000 - 0x007f.
X.sp
XCodeset 2 consists of the values who have the bits 0x8080 set.
X.sp
XCodeset 3 consists of the values 0x0080 - 0x00ff.
X.sp
XCodeset 4 consists of the values 0x8000 - 0xff7f excluding the values
Xwhich have the 0x0080 bit set.
X.sp
XNotice that the global
X.Ar mask
Xis set to 0x8080, this implies that from those 2 bits the codeset can
Xbe determined.
X.Sh "EXAMPLE - Japanese Locale"
XThis is a complete example of an
X.Ev LC_CTYPE
Xsource file for the Japanese locale
X.Bd -literal
X/*
X * Japanese LOCALE_CTYPE definitions using EUC of JIS character sets
X */
X
XENCODING	"EUC"
X
X/*		JIS	 JIS	  JIS			*/
X/*		X201	 X208	  X201 			*/
X/*		00-7f		  84-fe			*/
X
XVARIABLE	1 0x0000 2 0x8080 2 0x0080 3 0x8000 0x8080
X
X/*
X * Code Set 1
X */
XALPHA		'A' - 'Z' 'a' - 'z'
XCONTROL		0x00 - 0x1f 0x7f
XDIGIT		'0' - '9'
XGRAPH		0x21 - 0x7e
XLOWER		'a' - 'z'
XPUNCT		0x21 - 0x2f 0x3a - 0x40 0x5b - 0x60 0x7b - 0x7e
XSPACE		0x09 - 0x0d 0x20
XUPPER		'A' - 'Z'
XXDIGIT		'a' - 'f' 'A' - 'F'
XBLANK		' ' '\t'
XPRINT		0x20 - 0x7e
X
XMAPLOWER	< 'A' - 'Z' : 'a' > < 'a' - 'z' : 'a' >
XMAPUPPER	< 'A' - 'Z' : 'A' > < 'a' - 'z' : 'A' >
XTODIGIT		< '0' - '9' : 0 >
XTODIGIT		< 'A' - 'F' : 10 > < 'a' - 'f' : 10 >
X
X/*
X * Code Set 2
X */
X
XSPACE		0xa1a1
XPHONOGRAM	0xa1bc
XSPECIAL		0xa1a2 - 0xa1fe
XPUNCT		0xa1a2 - 0xa1f8		/* A few too many in here... */
X
XSPECIAL		0xa2a1 - 0xa2ae 0xa2ba - 0xa2c1 0xa2ca - 0xa2d0 0xa2dc - 0xa2ea
XSPECIAL		0xa2f2 - 0xa2f9 0xa2fe
X
XDIGIT		0xa3b0 - 0xa3b9
XUPPER		0xa3c1 - 0xa3da				/* Romaji */
XLOWER		0xa3e1 - 0xa3fa				/* Romaji */
XMAPLOWER	< 0xa3c1 - 0xa3da : 0xa3e1 >			/* English */
XMAPLOWER	< 0xa3e1 - 0xa3fa : 0xa3e1 >			/* English */
XMAPUPPER	< 0xa3c1 - 0xa3da : 0xa3c1 >
XMAPUPPER	< 0xa3e1 - 0xa3fa : 0xa3c1 >
X
XXDIGIT		0xa3c1 - 0xa3c6 0xa3e1 - 0xa3e6
X
XTODIGIT		< 0xa3b0 - 0xa3b9 : 0 >
XTODIGIT		< 0xa3c1 - 0xa3c6 : 10 > < 0xa3e1 - 0xa3e6 : 10 >
X
XPHONOGRAM	0xa4a1 - 0xa4f3
XPHONOGRAM	0xa5a1 - 0xa5f6
X
XUPPER		0xa6a1 - 0xa6b8				/* Greek */
XLOWER		0xa6c1 - 0xa6d8				/* Greek */
XMAPLOWER	< 0xa6a1 - 0xa6b8 : 0xa6c1 > < 0xa6c1 - 0xa6d8 : 0xa6c1 >
XMAPUPPER	< 0xa6a1 - 0xa6b8 : 0xa6a1 > < 0xa6c1 - 0xa6d8 : 0xa6a1 >
X
XUPPER		0xa7a1 - 0xa7c1				/* Cyrillic */
XLOWER		0xa7d1 - 0xa7f1				/* Cyrillic */
XMAPLOWER	< 0xa7a1 - 0xa7c1 : 0xa7d1 > < 0xa7d1 - 0xa7f1 : 0xa7d1 >
XMAPUPPER	< 0xa7a1 - 0xa7c1 : 0xa7a1 > < 0xa7d1 - 0xa7f1 : 0xa7a1 >
X
XSPECIAL		0xa8a1 - 0xa8c0
X
XIDEOGRAM	0xb0a1 - 0xb0fe 0xb1a1 - 0xb1fe 0xb2a1 - 0xb2fe
XIDEOGRAM	0xb3a1 - 0xb3fe 0xb4a1 - 0xb4fe 0xb5a1 - 0xb5fe
XIDEOGRAM	0xb6a1 - 0xb6fe 0xb7a1 - 0xb7fe 0xb8a1 - 0xb8fe
XIDEOGRAM	0xb9a1 - 0xb9fe 0xbaa1 - 0xbafe 0xbba1 - 0xbbfe
XIDEOGRAM	0xbca1 - 0xbcfe 0xbda1 - 0xbdfe 0xbea1 - 0xbefe
XIDEOGRAM	0xbfa1 - 0xbffe 0xc0a1 - 0xc0fe 0xc1a1 - 0xc1fe
XIDEOGRAM	0xc2a1 - 0xc2fe 0xc3a1 - 0xc3fe 0xc4a1 - 0xc4fe
XIDEOGRAM	0xc5a1 - 0xc5fe 0xc6a1 - 0xc6fe 0xc7a1 - 0xc7fe
XIDEOGRAM	0xc8a1 - 0xc8fe 0xc9a1 - 0xc9fe 0xcaa1 - 0xcafe
XIDEOGRAM	0xcba1 - 0xcbfe 0xcca1 - 0xccfe 0xcda1 - 0xcdfe
XIDEOGRAM	0xcea1 - 0xcefe 0xcfa1 - 0xcfd3 0xd0a1 - 0xd0fe
XIDEOGRAM	0xd1a1 - 0xd1fe 0xd2a1 - 0xd2fe 0xd3a1 - 0xd3fe
XIDEOGRAM	0xd4a1 - 0xd4fe 0xd5a1 - 0xd5fe 0xd6a1 - 0xd6fe
XIDEOGRAM	0xd7a1 - 0xd7fe 0xd8a1 - 0xd8fe 0xd9a1 - 0xd9fe
XIDEOGRAM	0xdaa1 - 0xdafe 0xdba1 - 0xdbfe 0xdca1 - 0xdcfe
XIDEOGRAM	0xdda1 - 0xddfe 0xdea1 - 0xdefe 0xdfa1 - 0xdffe
XIDEOGRAM	0xe0a1 - 0xe0fe 0xe1a1 - 0xe1fe 0xe2a1 - 0xe2fe
XIDEOGRAM	0xe3a1 - 0xe3fe 0xe4a1 - 0xe4fe 0xe5a1 - 0xe5fe
XIDEOGRAM	0xe6a1 - 0xe6fe 0xe7a1 - 0xe7fe 0xe8a1 - 0xe8fe
XIDEOGRAM	0xe9a1 - 0xe9fe 0xeaa1 - 0xeafe 0xeba1 - 0xebfe
XIDEOGRAM	0xeca1 - 0xecfe 0xeda1 - 0xedfe 0xeea1 - 0xeefe
XIDEOGRAM	0xefa1 - 0xeffe 0xf0a1 - 0xf0fe 0xf1a1 - 0xf1fe
XIDEOGRAM	0xf2a1 - 0xf2fe 0xf3a1 - 0xf3fe 0xf4a1 - 0xf4a4
X/*
X * This is for Code Set 3, half-width kana
X */
XSPECIAL		0xa1 - 0xdf
XPHONOGRAM	0xa1 - 0xdf
XCONTROL		0x84 - 0x97 0x9b - 0x9f 0xe0 - 0xfe
X.Ed
X.Sh "SEE ALSO"
X.Xr mklocale 1 ,
X.Xr setlocale 3
END_OF_FILE
if test 7430 -ne `wc -c <'doc/euc.4'`; then
    echo shar: \"'doc/euc.4'\" unpacked with wrong size!
fi
# end of 'doc/euc.4'
fi
if test -f 'doc/setlocale.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/setlocale.3'\"
else
echo shar: Extracting \"'doc/setlocale.3'\" \(8646 characters\)
sed "s/^X//" >'doc/setlocale.3' <<'END_OF_FILE'
X.\" Copyright (c) 1993
X.\"	The Regents of the University of California.  All rights reserved.
X.\"
X.\" This code is derived from software contributed to Berkeley by
X.\" Donn Seeley at BSDI.
X.\"
X.\" Redistribution and use in source and binary forms, with or without
X.\" modification, are permitted provided that the following conditions
X.\" are met:
X.\" 1. Redistributions of source code must retain the above copyright
X.\"    notice, this list of conditions and the following disclaimer.
X.\" 2. Redistributions in binary form must reproduce the above copyright
X.\"    notice, this list of conditions and the following disclaimer in the
X.\"    documentation and/or other materials provided with the distribution.
X.\" 3. All advertising materials mentioning features or use of this software
X.\"    must display the following acknowledgement:
X.\"	This product includes software developed by the University of
X.\"	California, Berkeley and its contributors.
X.\" 4. Neither the name of the University nor the names of its contributors
X.\"    may be used to endorse or promote products derived from this software
X.\"    without specific prior written permission.
X.\"
X.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X.\" SUCH DAMAGE.
X.\"
X.\"	@(#)setlocale.3	8.1 (Berkeley) 6/9/93
X.\"
X.Dd June 9, 1993
X.Dt SETLOCALE 3
X.Os
X.Sh NAME
X.Nm setlocale ,
X.Nm localeconv
X.Nd natural language formatting for C
X.Sh SYNOPSIS
X.Fd #include <locale.h>
X.Ft char *
X.Fn setlocale "int category" "const char *locale"
X.Ft struct lconv *
X.Fn localeconv "void"
X.Sh DESCRIPTION
XThe
X.Fn setlocale
Xfunction sets the C library's notion
Xof natural language formatting style
Xfor particular sets of routines.
XEach such style is called a
X.Sq locale
Xand is invoked using an appropriate name passed as a C string.
XThe
X.Fn localeconv
Xroutine returns the current locale's parameters
Xfor formatting numbers.
X.Pp
XThe
X.Fn setlocale
Xfunction recognizes several categories of routines.
XThese are the categories and the sets of routines they select:
X.Pp
X.Bl -tag -width LC_MONETARY
X.It Dv LC_ALL
XSet the entire locale generically.
X.It Dv LC_COLLATE
XSet a locale for string collation routines.
XThis controls alphabetic ordering in
X.Fn strcoll
Xand
X.Fn strxfrm .
X.It Dv LC_CTYPE
XSet a locale for the
X.Xr ctype 3 ,
X.Xr mbrune 3 ,
X.Xr multibyte 3
Xand
X.Xr rune 3
Xfunctions.
XThis controls recognition of upper and lower case,
Xalphabetic or non-alphabetic characters,
Xand so on.  The real work is done by the
X.Fn setrunelocale
Xfunction.
X.It Dv LC_MONETARY
XSet a locale for formatting monetary values;
Xthis affects the
X.Fn localeconv
Xfunction.
X.It Dv LC_NUMERIC
XSet a locale for formatting numbers.
XThis controls the formatting of decimal points
Xin input and output of floating point numbers
Xin functions such as
X.Fn printf
Xand
X.Fn scanf ,
Xas well as values returned by
X.Fn localeconv .
X.It Dv LC_TIME
XSet a locale for formatting dates and times using the
X.Fn strftime
Xfunction.
X.El
X.Pp
XOnly three locales are defined by default,
Xthe empty string
X.Li "\&""\|""
Xwhich denotes the native environment, and the
X.Li "\&""C""
Xand
X.LI "\&""POSIX""
Xlocales, which denote the C language environment.
XA
X.Fa locale
Xargument of
X.Dv NULL
Xcauses
X.Fn setlocale
Xto return the current locale.
XBy default, C programs start in the
X.Li "\&""C""
Xlocale.
XThe only function in the library that sets the locale is
X.Fn setlocale ;
Xthe locale is never changed as a side effect of some other routine.
X.Pp
XThe
X.Fn localeconv
Xfunction returns a pointer to a structure
Xwhich provides parameters for formatting numbers,
Xespecially currency values:
X.Bd -literal -offset indent
Xstruct lconv {
X	char	*decimal_point;
X	char	*thousands_sep;
X	char	*grouping;
X	char	*int_curr_symbol;
X	char	*currency_symbol;
X	char	*mon_decimal_point;
X	char	*mon_thousands_sep;
X	char	*mon_grouping;
X	char	*positive_sign;
X	char	*negative_sign;
X	char	int_frac_digits;
X	char	frac_digits;
X	char	p_cs_precedes;
X	char	p_sep_by_space;
X	char	n_cs_precedes;
X	char	n_sep_by_space;
X	char	p_sign_posn;
X	char	n_sign_posn;
X};
X.Ed
X.Pp
XThe individual fields have the following meanings:
X.Pp
X.Bl -tag -width mon_decimal_point
X.It Fa decimal_point
XThe decimal point character, except for currency values.
X.It Fa thousands_sep
XThe separator between groups of digits
Xbefore the decimal point, except for currency values.
X.It Fa grouping
XThe sizes of the groups of digits, except for currency values.
XThis is a pointer to a vector of integers, each of size
X.Va char ,
Xrepresenting group size from low order digit groups
Xto high order (right to left).
XThe list may be terminated with 0 or
X.Dv CHAR_MAX .
XIf the list is terminated with 0,
Xthe last group size before the 0 is repeated to account for all the digits.
XIf the list is terminated with
X.Dv CHAR_MAX ,
Xno more grouping is performed.
X.It Fa int_curr_symbol
XThe standardized international currency symbol.
X.It Fa currency_symbol
XThe local currency symbol.
X.It Fa mon_decimal_point
XThe decimal point character for currency values.
X.It Fa mon_thousands_sep
XThe separator for digit groups in currency values.
X.It Fa mon_grouping
XLike
X.Fa grouping
Xbut for currency values.
X.It Fa positive_sign
XThe character used to denote nonnegative currency values,
Xusually the empty string.
X.It Fa negative_sign
XThe character used to denote negative currency values,
Xusually a minus sign.
X.It Fa int_frac_digits
XThe number of digits after the decimal point
Xin an international-style currency value.
X.It Fa frac_digits
XThe number of digits after the decimal point
Xin the local style for currency values.
X.It Fa p_cs_precedes
X1 if the currency symbol precedes the currency value
Xfor nonnegative values, 0 if it follows.
X.It Fa p_sep_by_space
X1 if a space is inserted between the currency symbol
Xand the currency value for nonnegative values, 0 otherwise.
X.It Fa n_cs_precedes
XLike
X.Fa p_cs_precedes
Xbut for negative values.
X.It Fa n_sep_by_space
XLike
X.Fa p_sep_by_space
Xbut for negative values.
X.It Fa p_sign_posn
XThe location of the
X.Fa positive_sign
Xwith respect to a nonnegative quantity and the
X.Fa currency_symbol ,
Xcoded as follows:
X.Bl -tag -width 3n -compact
X.It Li 0
XParentheses around the entire string.
X.It Li 1
XBefore the string.
X.It Li 2
XAfter the string.
X.It Li 3
XJust before
X.Fa currency_symbol .
X.It Li 4
XJust after
X.Fa currency_symbol .
X.El
X.It Fa n_sign_posn
XLike
X.Fa p_sign_posn
Xbut for negative currency values.
X.El
X.Pp
XUnless mentioned above,
Xan empty string as a value for a field
Xindicates a zero length result or
Xa value that is not in the current locale.
XA
X.Dv CHAR_MAX
Xresult similarly denotes an unavailable value.
X.Sh "RETURN VALUES
XThe
X.Fn setlocale
Xfunction returns
X.Dv NULL
Xand fails to change the locale
Xif the given combination of
X.Fa category
Xand
X.Fa locale
Xmakes no sense.
XThe
X.Fn localeconv
Xfunction returns a pointer to a static object
Xwhich may be altered by later calls to
X.Fn setlocale
Xor
X.Fn localeconv .
X.Sh FILES
X.Bl -tag -width /usr/share/locale/locale/category -compact
X.It Pa $PATH_LOCALE/\fIlocale\fP/\fIcategory\fP
X.It Pa /usr/share/locale/\fIlocale\fP/\fIcategory\fP
Xlocale file for the locale \fIlocale\fP
Xand the category \fIcategory\fP.
X.El
X.Sh "SEE ALSO
X.Xr euc 4 ,
X.Xr mbrune 3 ,
X.Xr multibyte 3 ,
X.Xr rune 3 ,
X.Xr strcoll 3 ,
X.Xr strxfrm 3 ,
X.Xr utf2 4
X.Sh STANDARDS
XThe
X.Fn setlocale
Xand
X.Fn localeconv
Xfunctions conform to
X.St -ansiC .
X.Sh HISTORY
XThe
X.Fn setlocale
Xand
X.Fn localeconv
Xfunctions first appeared in 4.4BSD.
X.Sh BUGS
XThe current implementation supports only the
X.Li "\&""C""
Xand
X.Li "\&""POSIX""
Xlocales for all but the LC_CTYPE locale.
X.Pp
XIn spite of the gnarly currency support in
X.Fn localeconv ,
Xthe standards don't include any functions
Xfor generalized currency formatting.
X.Pp
X.Dv LC_COLLATE
Xdoes not make sense for many languages.
XUse of
X.Dv LC_MONETARY
Xcould lead to misleading results until we have a real time currency
Xconversion function.
X.Dv LC_NUMERIC
Xand
X.Dv LC_TIME
Xare personal choices and should not be wrapped up with the other categories.
END_OF_FILE
if test 8646 -ne `wc -c <'doc/setlocale.3'`; then
    echo shar: \"'doc/setlocale.3'\" unpacked with wrong size!
fi
# end of 'doc/setlocale.3'
fi
if test -f 'libc/rune.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libc/rune.c'\"
else
echo shar: Extracting \"'libc/rune.c'\" \(7949 characters\)
sed "s/^X//" >'libc/rune.c' <<'END_OF_FILE'
X/*-
X * Copyright (c) 1993
X *	The Regents of the University of California.  All rights reserved.
X *
X * This code is derived from software contributed to Berkeley by
X * Paul Borman at Krystal Technologies.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#if defined(LIBC_SCCS) && !defined(lint)
Xstatic char sccsid[] = "@(#)rune.c	8.1 (Berkeley) 6/4/93";
X#endif /* LIBC_SCCS and not lint */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X
X#include <ctype.h>
X#include <errno.h>
X#include <limits.h>
X#include <rune.h>
X#include <stdio.h>
X#include <stdlib.h>
X
Xextern int		_none_init __P((_RuneLocale *));
Xextern int		_UTF2_init __P((_RuneLocale *));
Xextern int		_EUC_init __P((_RuneLocale *));
Xstatic _RuneLocale	*_Read_RuneMagi __P((FILE *));
X
Xstatic char *PathLocale = 0;
X
Xint
Xsetrunelocale(encoding)
X	char *encoding;
X{
X	FILE *fp;
X	char name[PATH_MAX];
X	_RuneLocale *rl;
X
X	if (!encoding)
X	    return(EFAULT);
X
X	/*
X	 * The "C" and "POSIX" locale are always here.
X	 */
X	if (!strcmp(encoding, "C") || !strcmp(encoding, "POSIX")) {
X		_CurrentRuneLocale = &_DefaultRuneLocale;
X		return(0);
X	}
X
X	if (!PathLocale && !(PathLocale = getenv("PATH_LOCALE")))
X		PathLocale = _PATH_LOCALE;
X
X	sprintf(name, "%s/%s/LC_CTYPE", PathLocale, encoding);
X
X	if ((fp = fopen(name, "r")) == NULL)
X		return(ENOENT);
X
X	if ((rl = _Read_RuneMagi(fp)) == 0) {
X		fclose(fp);
X		return(EFTYPE);
X	}
X
X	if (!rl->encoding[0] || !strcmp(rl->encoding, "UTF2")) {
X		return(_UTF2_init(rl));
X	} else if (!strcmp(rl->encoding, "NONE")) {
X		return(_none_init(rl));
X	} else if (!strcmp(rl->encoding, "EUC")) {
X		return(_EUC_init(rl));
X	} else
X		return(EINVAL);
X}
X
Xvoid
Xsetinvalidrune(ir)
X	rune_t ir;
X{
X	_INVALID_RUNE = ir;
X}
X
Xstatic _RuneLocale *
X_Read_RuneMagi(fp)
X	FILE *fp;
X{
X	char *data;
X	void *np;
X	void *lastp;
X	_RuneLocale *rl;
X	_RuneEntry *rr;
X	struct stat sb;
X	int x;
X
X	if (fstat(fileno(fp), &sb) < 0)
X		return(0);
X
X	if (sb.st_size < sizeof(_RuneLocale))
X		return(0);
X
X	if ((data = malloc(sb.st_size)) == NULL)
X		return(0);
X
X	rewind(fp); /* Someone might have read the magic number once already */
X
X	if (fread(data, sb.st_size, 1, fp) != 1) {
X		free(data);
X		return(0);
X	}
X
X	rl = (_RuneLocale *)data;
X	lastp = data + sb.st_size;
X
X	rl->variable = rl + 1;
X
X	if (memcmp(rl->magic, _RUNE_MAGIC_1, sizeof(rl->magic))) {
X		free(data);
X		return(0);
X	}
X
X	rl->invalid_rune = ntohl(rl->invalid_rune);
X	rl->variable_len = ntohl(rl->variable_len);
X	rl->runetype_ext.nranges = ntohl(rl->runetype_ext.nranges);
X	rl->maplower_ext.nranges = ntohl(rl->maplower_ext.nranges);
X	rl->mapupper_ext.nranges = ntohl(rl->mapupper_ext.nranges);
X
X	for (x = 0; x < _CACHED_RUNES; ++x) {
X		rl->runetype[x] = ntohl(rl->runetype[x]);
X		rl->maplower[x] = ntohl(rl->maplower[x]);
X		rl->mapupper[x] = ntohl(rl->mapupper[x]);
X	}
X
X	rl->runetype_ext.ranges = (_RuneEntry *)rl->variable;
X	rl->variable = rl->runetype_ext.ranges + rl->runetype_ext.nranges;
X	if (rl->variable > lastp) {
X		free(data);
X		return(0);
X	}
X
X	rl->maplower_ext.ranges = (_RuneEntry *)rl->variable;
X	rl->variable = rl->maplower_ext.ranges + rl->maplower_ext.nranges;
X	if (rl->variable > lastp) {
X		free(data);
X		return(0);
X	}
X
X	rl->mapupper_ext.ranges = (_RuneEntry *)rl->variable;
X	rl->variable = rl->mapupper_ext.ranges + rl->mapupper_ext.nranges;
X	if (rl->variable > lastp) {
X		free(data);
X		return(0);
X	}
X
X	for (x = 0; x < rl->runetype_ext.nranges; ++x) {
X		rr = rl->runetype_ext.ranges;
X
X		rr[x].min = ntohl(rr[x].min);
X		rr[x].max = ntohl(rr[x].max);
X		if ((rr[x].map = ntohl(rr[x].map)) == 0) {
X			int len = rr[x].max - rr[x].min + 1;
X			rr[x].types = rl->variable;
X			rl->variable = rr[x].types + len;
X			if (rl->variable > lastp) {
X				free(data);
X				return(0);
X			}
X			while (len-- > 0)
X				rr[x].types[len] = ntohl(rr[x].types[len]);
X		} else
X			rr[x].types = 0;
X	}
X
X	for (x = 0; x < rl->maplower_ext.nranges; ++x) {
X		rr = rl->maplower_ext.ranges;
X
X		rr[x].min = ntohl(rr[x].min);
X		rr[x].max = ntohl(rr[x].max);
X		rr[x].map = ntohl(rr[x].map);
X	}
X
X	for (x = 0; x < rl->mapupper_ext.nranges; ++x) {
X		rr = rl->mapupper_ext.ranges;
X
X		rr[x].min = ntohl(rr[x].min);
X		rr[x].max = ntohl(rr[x].max);
X		rr[x].map = ntohl(rr[x].map);
X	}
X	if (((char *)rl->variable) + rl->variable_len > (char *)lastp) {
X		free(data);
X		return(0);
X	}
X
X	/*
X	 * Go out and zero pointers that should be zero.
X	 */
X	if (!rl->variable_len)
X		rl->variable = 0;
X
X	if (!rl->runetype_ext.nranges)
X		rl->runetype_ext.ranges = 0;
X
X	if (!rl->maplower_ext.nranges)
X		rl->maplower_ext.ranges = 0;
X
X	if (!rl->mapupper_ext.nranges)
X		rl->mapupper_ext.ranges = 0;
X	    
X	return(rl);
X}
X
Xunsigned long
X___runetype(c)
X	_BSD_RUNE_T_ c;
X{
X	int x;
X	_RuneRange *rr = &_CurrentRuneLocale->runetype_ext;
X	_RuneEntry *re = rr->ranges;
X
X	if (c == EOF)
X		return(0);
X	for (x = 0; x < rr->nranges; ++x, ++re) {
X		if (c < re->min)
X			return(0L);
X		if (c <= re->max) {
X			if (re->types)
X			    return(re->types[c - re->min]);
X			else
X			    return(re->map);
X		}
X	}
X	return(0L);
X}
X
X_BSD_RUNE_T_
X___toupper(c)
X	_BSD_RUNE_T_ c;
X{
X	int x;
X	_RuneRange *rr = &_CurrentRuneLocale->mapupper_ext;
X	_RuneEntry *re = rr->ranges;
X
X	if (c == EOF)
X		return(EOF);
X	for (x = 0; x < rr->nranges; ++x, ++re) {
X		if (c < re->min)
X			return(c);
X		if (c <= re->max)
X			return(re->map + c - re->min);
X	}
X	return(c);
X}
X
X_BSD_RUNE_T_
X___tolower(c)
X	_BSD_RUNE_T_ c;
X{
X	int x;
X	_RuneRange *rr = &_CurrentRuneLocale->maplower_ext;
X	_RuneEntry *re = rr->ranges;
X
X	if (c == EOF)
X		return(EOF);
X	for (x = 0; x < rr->nranges; ++x, ++re) {
X		if (c < re->min)
X			return(c);
X		if (c <= re->max)
X			return(re->map + c - re->min);
X	}
X	return(c);
X}
X
X
X#if !defined(_USE_CTYPE_INLINE_) && !defined(_USE_CTYPE_MACROS_)
X/*
X * See comments in <machine/ansi.h>
X */
Xint
X__istype(c, f)
X	_BSD_RUNE_T_ c;
X	unsigned long f;
X{
X	return ((((c & _CRMASK) ? ___runetype(c)
X           : _CurrentRuneLocale->runetype[c]) & f) ? 1 : 0);
X}
X
Xint
X__isctype(_BSD_RUNE_T_ c, unsigned long f)
X	_BSD_RUNE_T_ c;
X	unsigned long f;
X{
X	return ((((c & _CRMASK) ? 0
X           : _DefaultRuneLocale.runetype[c]) & f) ? 1 : 0);
X}
X
X_BSD_RUNE_T_
Xtoupper(c)
X	_BSD_RUNE_T_ c;
X{
X	return ((c & _CRMASK) ?
X	    ___toupper(c) : _CurrentRuneLocale->mapupper[c]);
X}
X
X_BSD_RUNE_T_
Xtolower(c)
X	_BSD_RUNE_T_ c;
X{
X	return ((c & _CRMASK) ?
X	    ___tolower(c) : _CurrentRuneLocale->maplower[c]);
X}
X#endif
END_OF_FILE
if test 7949 -ne `wc -c <'libc/rune.c'`; then
    echo shar: \"'libc/rune.c'\" unpacked with wrong size!
fi
# end of 'libc/rune.c'
fi
if test -f 'mklocale/yacc.y' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mklocale/yacc.y'\"
else
echo shar: Extracting \"'mklocale/yacc.y'\" \(19494 characters\)
sed "s/^X//" >'mklocale/yacc.y' <<'END_OF_FILE'
X%{
X/*-
X * Copyright (c) 1993
X *	The Regents of the University of California.  All rights reserved.
X *
X * This code is derived from software contributed to Berkeley by
X * Paul Borman at Krystal Technologies.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#ifndef lint
Xstatic char sccsid[] = "@(#)yacc.y	8.1 (Berkeley) 6/6/93";
X#endif /* not lint */
X
X#include <ctype.h>
X#include <rune.h>
X#include <stddef.h>
X#include <stdio.h>
X#include <stdlib.h>
X
X#include "ldef.h"
X
Xchar	*locale_file = "<stdout>";
X
Xrune_map	maplower = { 0, };
Xrune_map	mapupper = { 0, };
Xrune_map	types = { 0, };
X
X_RuneLocale	new_locale = { 0, };
X
Xvoid set_map __P((rune_map *, rune_list *, u_long));
Xvoid set_digitmap __P((rune_map *, rune_list *));
Xvoid add_map __P((rune_map *, rune_list *, u_long));
X%}
X
X%union	{
X    rune_t	rune;
X    int		i;
X    char	*str;
X
X    rune_list	*list;
X}
X
X%token	<rune>	RUNE
X%token		LBRK
X%token		RBRK
X%token		THRU
X%token		MAPLOWER
X%token		MAPUPPER
X%token		DIGITMAP
X%token	<i>	LIST
X%token	<str>	VARIABLE
X%token		ENCODING
X%token		INVALID
X%token	<str>	STRING
X
X%type	<list>	list
X%type	<list>	map
X
X
X%%
X
Xlocale	:	/* empty */
X	|	table
X	    	{ dump_tables(); }
X	;
X
Xtable	:	entry
X	|	table entry
X	;
X
Xentry	:	ENCODING STRING
X		{ strncpy(new_locale.encoding, $2, sizeof(new_locale.encoding)); }
X	|	VARIABLE
X		{ new_locale.variable_len = strlen($1) + 1;
X		  new_locale.variable = malloc(new_locale.variable_len);
X		  strcpy((char *)new_locale.variable, $1);
X		}
X	|	INVALID RUNE
X		{ new_locale.invalid_rune = $2; }
X	|	LIST list
X		{ set_map(&types, $2, $1); }
X	|	MAPLOWER map
X		{ set_map(&maplower, $2, 0); }
X	|	MAPUPPER map
X		{ set_map(&mapupper, $2, 0); }
X	|	DIGITMAP map
X		{ set_digitmap(&types, $2); }
X	;
X
Xlist	:	RUNE
X		{
X		    $$ = (rune_list *)malloc(sizeof(rune_list));
X		    $$->min = $1;
X		    $$->max = $1;
X		    $$->next = 0;
X		}
X	|	RUNE THRU RUNE
X		{
X		    $$ = (rune_list *)malloc(sizeof(rune_list));
X		    $$->min = $1;
X		    $$->max = $3;
X		    $$->next = 0;
X		}
X	|	list RUNE
X		{
X		    $$ = (rune_list *)malloc(sizeof(rune_list));
X		    $$->min = $2;
X		    $$->max = $2;
X		    $$->next = $1;
X		}
X	|	list RUNE THRU RUNE
X		{
X		    $$ = (rune_list *)malloc(sizeof(rune_list));
X		    $$->min = $2;
X		    $$->max = $4;
X		    $$->next = $1;
X		}
X	;
X
Xmap	:	LBRK RUNE RUNE RBRK
X		{
X		    $$ = (rune_list *)malloc(sizeof(rune_list));
X		    $$->min = $2;
X		    $$->max = $2;
X		    $$->map = $3;
X		    $$->next = 0;
X		}
X	|	map LBRK RUNE RUNE RBRK
X		{
X		    $$ = (rune_list *)malloc(sizeof(rune_list));
X		    $$->min = $3;
X		    $$->max = $3;
X		    $$->map = $4;
X		    $$->next = $1;
X		}
X	|	LBRK RUNE THRU RUNE ':' RUNE RBRK
X		{
X		    $$ = (rune_list *)malloc(sizeof(rune_list));
X		    $$->min = $2;
X		    $$->max = $4;
X		    $$->map = $6;
X		    $$->next = 0;
X		}
X	|	map LBRK RUNE THRU RUNE ':' RUNE RBRK
X		{
X		    $$ = (rune_list *)malloc(sizeof(rune_list));
X		    $$->min = $3;
X		    $$->max = $5;
X		    $$->map = $7;
X		    $$->next = $1;
X		}
X	;
X%%
X
Xint debug = 0;
XFILE *fp = stdout;
X
Xmain(ac, av)
X	int ac;
X	char *av[];
X{
X    int x;
X
X    extern char *optarg;
X    extern int optind;
X
X    while ((x = getopt(ac, av, "do:")) != EOF) {
X	switch(x) {
X	case 'd':
X	    debug = 1;
X	    break;
X	case 'o':
X	    locale_file = optarg;
X	    if ((fp = fopen(locale_file, "w")) == 0) {
X		perror(locale_file);
X		exit(1);
X	    }
X	    break;
X	default:
X	usage:
X	    fprintf(stderr, "Usage: mklocale [-d] [-o output] [source]\n");
X	    exit(1);
X	}
X    }
X
X    switch (ac - optind) {
X    case 0:
X	break;
X    case 1:
X	if (freopen(av[optind], "r", stdin) == 0) {
X	    perror(av[optind]);
X	    exit(1);
X	}
X	break;
X    default:
X	goto usage;
X    }
X    for (x = 0; x < _CACHED_RUNES; ++x) {
X	mapupper.map[x] = x;
X	maplower.map[x] = x;
X    }
X    new_locale.invalid_rune = _INVALID_RUNE;
X    memcpy(new_locale.magic, _RUNE_MAGIC_1, sizeof(new_locale.magic));
X
X    yyparse();
X}
X
Xyyerror(s)
X	char *s;
X{
X    fprintf(stderr, "%s\n", s);
X}
X
Xvoid *
Xxmalloc(sz)
X	unsigned int sz;
X{
X    void *r = malloc(sz);
X    if (!r) {
X	perror("xmalloc");
X	abort();
X    }
X    return(r);
X}
X
Xu_long *
Xxlalloc(sz)
X	unsigned int sz;
X{
X    u_long *r = (u_long *)malloc(sz * sizeof(u_long));
X    if (!r) {
X	perror("xlalloc");
X	abort();
X    }
X    return(r);
X}
X
Xu_long *
Xxrelalloc(old, sz)
X	u_long *old;
X	unsigned int sz;
X{
X    u_long *r = (u_long *)realloc((char *)old, sz * sizeof(u_long));
X    if (!r) {
X	perror("xrelalloc");
X	abort();
X    }
X    return(r);
X}
X
Xvoid
Xset_map(map, list, flag)
X	rune_map *map;
X	rune_list *list;
X	u_long flag;
X{
X    while (list) {
X	rune_list *nlist = list->next;
X	add_map(map, list, flag);
X	list = nlist;
X    }
X}
X
Xvoid
Xset_digitmap(map, list)
X	rune_map *map;
X	rune_list *list;
X{
X    rune_t i;
X
X    while (list) {
X	rune_list *nlist = list->next;
X	for (i = list->min; i <= list->max; ++i) {
X	    if (list->map + (i - list->min)) {
X		rune_list *tmp = (rune_list *)xmalloc(sizeof(rune_list));
X		tmp->min = i;
X		tmp->max = i;
X		add_map(map, tmp, list->map + (i - list->min));
X	    }
X	}
X	free(list);
X	list = nlist;
X    }
X}
X
Xvoid
Xadd_map(map, list, flag)
X	rune_map *map;
X	rune_list *list;
X	u_long flag;
X{
X    rune_t i;
X    rune_list *lr = 0;
X    rune_list *r;
X    rune_t run;
X
X    while (list->min < _CACHED_RUNES && list->min <= list->max) {
X	if (flag)
X	    map->map[list->min++] |= flag;
X	else
X	    map->map[list->min++] = list->map++;
X    }
X
X    if (list->min > list->max) {
X	free(list);
X	return;
X    }
X
X    run = list->max - list->min + 1;
X
X    if (!(r = map->root) || (list->max < r->min - 1)
X			 || (!flag && list->max == r->min - 1)) {
X	if (flag) {
X	    list->types = xlalloc(run);
X	    for (i = 0; i < run; ++i)
X		list->types[i] = flag;
X	}
X	list->next = map->root;
X	map->root = list;
X	return;
X    }
X
X    for (r = map->root; r && r->max + 1 < list->min; r = r->next)
X	lr = r;
X
X    if (!r) {
X	/*
X	 * We are off the end.
X	 */
X	if (flag) {
X	    list->types = xlalloc(run);
X	    for (i = 0; i < run; ++i)
X		list->types[i] = flag;
X	}
X	list->next = 0;
X	lr->next = list;
X	return;
X    }
X
X    if (list->max < r->min - 1) {
X	/*
X	 * We come before this range and we do not intersect it.
X	 * We are not before the root node, it was checked before the loop
X	 */
X	if (flag) {
X	    list->types = xlalloc(run);
X	    for (i = 0; i < run; ++i)
X		list->types[i] = flag;
X	}
X	list->next = lr->next;
X	lr->next = list;
X	return;
X    }
X
X    /*
X     * At this point we have found that we at least intersect with
X     * the range pointed to by `r', we might intersect with one or
X     * more ranges beyond `r' as well.
X     */
X
X    if (!flag && list->map - list->min != r->map - r->min) {
X	/*
X	 * There are only two cases when we are doing case maps and
X	 * our maps needn't have the same offset.  When we are adjoining
X	 * but not intersecting.
X	 */
X	if (list->max + 1 == r->min) {
X	    lr->next = list;
X	    list->next = r;
X	    return;
X	}
X	if (list->min - 1 == r->max) {
X	    list->next = r->next;
X	    r->next = list;
X	    return;
X	}
X	fprintf(stderr, "Error: conflicting map entries\n");
X	exit(1);
X    }
X
X    if (list->min >= r->min && list->max <= r->max) {
X	/*
X	 * Subset case.
X	 */
X
X	if (flag) {
X	    for (i = list->min; i <= list->max; ++i)
X		r->types[i - r->min] |= flag;
X	}
X	free(list);
X	return;
X    }
X    if (list->min <= r->min && list->max >= r->max) {
X	/*
X	 * Superset case.  Make him big enough to hold us.
X	 * We might need to merge with the guy after him.
X	 */
X	if (flag) {
X	    list->types = xlalloc(list->max - list->min + 1);
X
X	    for (i = list->min; i <= list->max; ++i)
X		list->types[i - list->min] = flag;
X
X	    for (i = r->min; i <= r->max; ++i)
X		list->types[i - list->min] |= r->types[i - r->min];
X
X	    free(r->types);
X	    r->types = list->types;
X	} else {
X	    r->map = list->map;
X	}
X	r->min = list->min;
X	r->max = list->max;
X	free(list);
X    } else if (list->min < r->min) {
X	/*
X	 * Our tail intersects his head.
X	 */
X	if (flag) {
X	    list->types = xlalloc(r->max - list->min + 1);
X
X	    for (i = r->min; i <= r->max; ++i)
X		list->types[i - list->min] = r->types[i - r->min];
X
X	    for (i = list->min; i < r->min; ++i)
X		list->types[i - list->min] = flag;
X
X	    for (i = r->min; i <= list->max; ++i)
X		list->types[i - list->min] |= flag;
X
X	    free(r->types);
X	    r->types = list->types;
X	} else {
X	    r->map = list->map;
X	}
X	r->min = list->min;
X	free(list);
X	return;
X    } else {
X	/*
X	 * Our head intersects his tail.
X	 * We might need to merge with the guy after him.
X	 */
X	if (flag) {
X	    r->types = xrelalloc(r->types, list->max - r->min + 1);
X
X	    for (i = list->min; i <= r->max; ++i)
X		r->types[i - r->min] |= flag;
X
X	    for (i = r->max+1; i <= list->max; ++i)
X		r->types[i - r->min] = flag;
X	}
X	r->max = r->max;
X	free(list);
X    }
X
X    /*
X     * Okay, check to see if we grew into the next guy(s)
X     */
X    while ((lr = r->next) && r->max >= lr->min) {
X	if (flag) {
X	    if (r->max >= lr->max) {
X		/*
X		 * Good, we consumed all of him.
X		 */
X		for (i = lr->min; i <= lr->max; ++i)
X		    r->types[i - r->min] |= lr->types[i - lr->min];
X	    } else {
X		/*
X		 * "append" him on to the end of us.
X		 */
X		r->types = xrelalloc(r->types, lr->max - r->min + 1);
X
X		for (i = lr->min; i <= r->max; ++i)
X		    r->types[i - r->min] |= lr->types[i - lr->min];
X
X		for (i = r->max+1; i <= lr->max; ++i)
X		    r->types[i - r->min] = lr->types[i - lr->min];
X
X		r->max = lr->max;
X	    }
X	} else {
X	    if (lr->max > r->max)
X		r->max = lr->max;
X	}
X
X	r->next = lr->next;
X
X	if (flag)
X	    free(lr->types);
X	free(lr);
X    }
X}
X
Xvoid
Xdump_tables()
X{
X    int x;
X    rune_list *list;
X
X    /*
X     * See if we can compress some of the istype arrays
X     */
X    for(list = types.root; list; list = list->next) {
X	list->map = list->types[0];
X	for (x = 1; x < list->max - list->min + 1; ++x) {
X	    if (list->types[x] != list->map) {
X		list->map = 0;
X		break;
X	    }
X	}
X    }
X
X    new_locale.invalid_rune = htonl(new_locale.invalid_rune);
X
X    /*
X     * Fill in our tables.  Do this in network order so that
X     * diverse machines have a chance of sharing data.
X     * (Machines like Crays cannot share with little machines due to
X     *  word size.  Sigh.  We tried.)
X     */
X    for (x = 0; x < _CACHED_RUNES; ++x) {
X	new_locale.runetype[x] = htonl(types.map[x]);
X	new_locale.maplower[x] = htonl(maplower.map[x]);
X	new_locale.mapupper[x] = htonl(mapupper.map[x]);
X    }
X
X    /*
X     * Count up how many ranges we will need for each of the extents.
X     */
X    list = types.root;
X
X    while (list) {
X	new_locale.runetype_ext.nranges++;
X	list = list->next;
X    }
X    new_locale.runetype_ext.nranges = htonl(new_locale.runetype_ext.nranges);
X
X    list = maplower.root;
X
X    while (list) {
X	new_locale.maplower_ext.nranges++;
X	list = list->next;
X    }
X    new_locale.maplower_ext.nranges = htonl(new_locale.maplower_ext.nranges);
X
X    list = mapupper.root;
X
X    while (list) {
X	new_locale.mapupper_ext.nranges++;
X	list = list->next;
X    }
X    new_locale.mapupper_ext.nranges = htonl(new_locale.mapupper_ext.nranges);
X
X    new_locale.variable_len = htonl(new_locale.variable_len);
X
X    /*
X     * Okay, we are now ready to write the new locale file.
X     */
X
X    /*
X     * PART 1: The _RuneLocale structure
X     */
X    if (fwrite((char *)&new_locale, sizeof(new_locale), 1, fp) != 1) {
X	perror(locale_file);
X	exit(1);
X    }
X    /*
X     * PART 2: The runetype_ext structures (not the actual tables)
X     */
X    list = types.root;
X
X    while (list) {
X	_RuneEntry re;
X
X	re.min = htonl(list->min);
X	re.max = htonl(list->max);
X	re.map = htonl(list->map);
X
X	if (fwrite((char *)&re, sizeof(re), 1, fp) != 1) {
X	    perror(locale_file);
X	    exit(1);
X	}
X
X        list = list->next;
X    }
X    /*
X     * PART 3: The maplower_ext structures
X     */
X    list = maplower.root;
X
X    while (list) {
X	_RuneEntry re;
X
X	re.min = htonl(list->min);
X	re.max = htonl(list->max);
X	re.map = htonl(list->map);
X
X	if (fwrite((char *)&re, sizeof(re), 1, fp) != 1) {
X	    perror(locale_file);
X	    exit(1);
X	}
X
X        list = list->next;
X    }
X    /*
X     * PART 4: The mapupper_ext structures
X     */
X    list = mapupper.root;
X
X    while (list) {
X	_RuneEntry re;
X
X	re.min = htonl(list->min);
X	re.max = htonl(list->max);
X	re.map = htonl(list->map);
X
X	if (fwrite((char *)&re, sizeof(re), 1, fp) != 1) {
X	    perror(locale_file);
X	    exit(1);
X	}
X
X        list = list->next;
X    }
X    /*
X     * PART 5: The runetype_ext tables
X     */
X    list = types.root;
X
X    while (list) {
X	for (x = 0; x < list->max - list->min + 1; ++x)
X	    list->types[x] = htonl(list->types[x]);
X
X	if (!list->map) {
X	    if (fwrite((char *)&list->types,
X		(list->max - list->min + 1)*sizeof(u_long), 1, fp) != 1) {
X		perror(locale_file);
X		exit(1);
X	    }
X	}
X        list = list->next;
X    }
X    /*
X     * PART 5: And finally the variable data
X     */
X    if (fwrite((char *)new_locale.variable,
X	       ntohl(new_locale.variable_len), 1, fp) != 1) {
X	perror(locale_file);
X	exit(1);
X    }
X    fclose(fp);
X
X    if (!debug)
X	return;
X
X    if (new_locale.encoding[0])
X	fprintf(stderr, "ENCODING	%s\n", new_locale.encoding);
X    if (new_locale.variable)
X	fprintf(stderr, "VARIABLE	%s\n", new_locale.variable);
X
X    fprintf(stderr, "\nMAPLOWER:\n\n");
X
X    for (x = 0; x < _CACHED_RUNES; ++x) {
X	if (isprint(maplower.map[x]))
X	    fprintf(stderr, " '%c'", maplower.map[x]);
X	else if (maplower.map[x])
X	    fprintf(stderr, "%04x", maplower.map[x]);
X	else
X	    fprintf(stderr, "%4x", 0);
X	if ((x & 0xf) == 0xf)
X	    fprintf(stderr, "\n");
X	else
X	    fprintf(stderr, " ");
X    }
X    fprintf(stderr, "\n");
X
X    for (list = maplower.root; list; list = list->next)
X	fprintf(stderr, "\t%04x - %04x : %04x\n", list->min, list->max, list->map);
X
X    fprintf(stderr, "\nMAPUPPER:\n\n");
X
X    for (x = 0; x < _CACHED_RUNES; ++x) {
X	if (isprint(mapupper.map[x]))
X	    fprintf(stderr, " '%c'", mapupper.map[x]);
X	else if (mapupper.map[x])
X	    fprintf(stderr, "%04x", mapupper.map[x]);
X	else
X	    fprintf(stderr, "%4x", 0);
X	if ((x & 0xf) == 0xf)
X	    fprintf(stderr, "\n");
X	else
X	    fprintf(stderr, " ");
X    }
X    fprintf(stderr, "\n");
X
X    for (list = mapupper.root; list; list = list->next)
X	fprintf(stderr, "\t%04x - %04x : %04x\n", list->min, list->max, list->map);
X
X
X    fprintf(stderr, "\nTYPES:\n\n");
X
X    for (x = 0; x < _CACHED_RUNES; ++x) {
X	u_long r = types.map[x];
X
X	if (r) {
X	    if (isprint(x))
X		fprintf(stderr, " '%c': %2d", x, r & 0xff);
X	    else
X		fprintf(stderr, "%04x: %2d", x, r & 0xff);
X
X	    fprintf(stderr, " %4s", (r & _A) ? "alph" : "");
X	    fprintf(stderr, " %4s", (r & _C) ? "ctrl" : "");
X	    fprintf(stderr, " %4s", (r & _D) ? "dig" : "");
X	    fprintf(stderr, " %4s", (r & _G) ? "graf" : "");
X	    fprintf(stderr, " %4s", (r & _L) ? "low" : "");
X	    fprintf(stderr, " %4s", (r & _P) ? "punc" : "");
X	    fprintf(stderr, " %4s", (r & _S) ? "spac" : "");
X	    fprintf(stderr, " %4s", (r & _U) ? "upp" : "");
X	    fprintf(stderr, " %4s", (r & _X) ? "xdig" : "");
X	    fprintf(stderr, " %4s", (r & _B) ? "blnk" : "");
X	    fprintf(stderr, " %4s", (r & _R) ? "prnt" : "");
X	    fprintf(stderr, " %4s", (r & _I) ? "ideo" : "");
X	    fprintf(stderr, " %4s", (r & _T) ? "spec" : "");
X	    fprintf(stderr, " %4s", (r & _Q) ? "phon" : "");
X	    fprintf(stderr, "\n");
X	}
X    }
X
X    for (list = types.root; list; list = list->next) {
X	if (list->map && list->min + 3 < list->max) {
X	    u_long r = list->map;
X
X	    fprintf(stderr, "%04x: %2d", list->min, r & 0xff);
X
X	    fprintf(stderr, " %4s", (r & _A) ? "alph" : "");
X	    fprintf(stderr, " %4s", (r & _C) ? "ctrl" : "");
X	    fprintf(stderr, " %4s", (r & _D) ? "dig" : "");
X	    fprintf(stderr, " %4s", (r & _G) ? "graf" : "");
X	    fprintf(stderr, " %4s", (r & _L) ? "low" : "");
X	    fprintf(stderr, " %4s", (r & _P) ? "punc" : "");
X	    fprintf(stderr, " %4s", (r & _S) ? "spac" : "");
X	    fprintf(stderr, " %4s", (r & _U) ? "upp" : "");
X	    fprintf(stderr, " %4s", (r & _X) ? "xdig" : "");
X	    fprintf(stderr, " %4s", (r & _B) ? "blnk" : "");
X	    fprintf(stderr, " %4s", (r & _R) ? "prnt" : "");
X	    fprintf(stderr, " %4s", (r & _I) ? "ideo" : "");
X	    fprintf(stderr, " %4s", (r & _T) ? "spec" : "");
X	    fprintf(stderr, " %4s", (r & _Q) ? "phon" : "");
X	    fprintf(stderr, "\n...\n");
X
X	    fprintf(stderr, "%04x: %2d", list->max, r & 0xff);
X
X	    fprintf(stderr, " %4s", (r & _A) ? "alph" : "");
X	    fprintf(stderr, " %4s", (r & _C) ? "ctrl" : "");
X	    fprintf(stderr, " %4s", (r & _D) ? "dig" : "");
X	    fprintf(stderr, " %4s", (r & _G) ? "graf" : "");
X	    fprintf(stderr, " %4s", (r & _L) ? "low" : "");
X	    fprintf(stderr, " %4s", (r & _P) ? "punc" : "");
X	    fprintf(stderr, " %4s", (r & _S) ? "spac" : "");
X	    fprintf(stderr, " %4s", (r & _U) ? "upp" : "");
X	    fprintf(stderr, " %4s", (r & _X) ? "xdig" : "");
X	    fprintf(stderr, " %4s", (r & _B) ? "blnk" : "");
X	    fprintf(stderr, " %4s", (r & _R) ? "prnt" : "");
X	    fprintf(stderr, " %4s", (r & _I) ? "ideo" : "");
X	    fprintf(stderr, " %4s", (r & _T) ? "spec" : "");
X	    fprintf(stderr, " %4s", (r & _Q) ? "phon" : "");
X	    fprintf(stderr, "\n");
X	} else 
X	for (x = list->min; x <= list->max; ++x) {
X	    u_long r = ntohl(list->types[x - list->min]);
X
X	    if (r) {
X		fprintf(stderr, "%04x: %2d", x, r & 0xff);
X
X		fprintf(stderr, " %4s", (r & _A) ? "alph" : "");
X		fprintf(stderr, " %4s", (r & _C) ? "ctrl" : "");
X		fprintf(stderr, " %4s", (r & _D) ? "dig" : "");
X		fprintf(stderr, " %4s", (r & _G) ? "graf" : "");
X		fprintf(stderr, " %4s", (r & _L) ? "low" : "");
X		fprintf(stderr, " %4s", (r & _P) ? "punc" : "");
X		fprintf(stderr, " %4s", (r & _S) ? "spac" : "");
X		fprintf(stderr, " %4s", (r & _U) ? "upp" : "");
X		fprintf(stderr, " %4s", (r & _X) ? "xdig" : "");
X		fprintf(stderr, " %4s", (r & _B) ? "blnk" : "");
X		fprintf(stderr, " %4s", (r & _R) ? "prnt" : "");
X		fprintf(stderr, " %4s", (r & _I) ? "ideo" : "");
X		fprintf(stderr, " %4s", (r & _T) ? "spec" : "");
X		fprintf(stderr, " %4s", (r & _Q) ? "phon" : "");
X		fprintf(stderr, "\n");
X	    }
X	}
X    }
X}
END_OF_FILE
if test 19494 -ne `wc -c <'mklocale/yacc.y'`; then
    echo shar: \"'mklocale/yacc.y'\" unpacked with wrong size!
fi
# end of 'mklocale/yacc.y'
fi
echo shar: End of archive 3 \(of 3\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
