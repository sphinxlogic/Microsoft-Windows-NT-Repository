This is Info file elisp, produced by Makeinfo-1.55 from the input file
elisp.texi.

   This version is newer than the second printed edition of the GNU
Emacs Lisp Reference Manual.  It corresponds to Emacs Version 19.19.

   Published by the Free Software Foundation 675 Massachusetts Avenue
Cambridge, MA 02139 USA

   Copyright (C) 1990, 1991, 1992, 1993 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: elisp,  Node: Repeat Events,  Next: Motion Events,  Prev: Button-Down Events,  Up: Input Events

Repeat Events
-------------

   If you press the same mouse button more than once in quick succession
without moving the mouse, Emacs uses special "repeat" mouse events for
the second and subsequent presses.

   The most common repeat events are "double-click" events.  Emacs
generates a double-click event when you click a button twice; the event
happens when you release the button (as is normal for all click events).

   The event type of a double-click event contains the prefix `double'.
Thus, a double click on the second mouse button with meta held down
comes to the Lisp program as `M-double-mouse-2'.  If a double-click
event has no binding, the binding of the corresponding ordinary click
event is used to execute it.  Thus, you need not pay attention to the
double click feature unless you really want to.

   When the user performs a double click, Emacs generates first an
ordinary click event, and then a double-click event.  Therefore, the
command binding of the double click event must be written to assume
that the single-click command has already run.  It must produce the
desired results of a double click, starting from the results of a
single click.

   This means that it is most convenient to give double clicks a meaning
that somehow "builds on" the meaning of a single click.  This is what
user interface experts recommend that double clicks should do.

   If you click a button, then press it down again and start moving the
mouse with the button held down, then you get a "double-drag" event
when you ultimately release the button.  Its event type contains
`double-drag' instead of just `drag'.  If a double-drag event has no
binding, Emacs looks for an alternate binding as if the event were an
ordinary click.

   Before the double-click or double-drag event, Emacs generates a
"double-down" event when the button is pressed down for the second
time.  Its event type contains `double-down' instead of just `down'.
If a double-down event has no binding, Emacs looks for an alternate
binding as if the event were an ordinary button-down event.  If it
finds no binding that way either, the double-down event is ignored.

   To summarize, when you click a button and then press it again right
away, Emacs generates a double-down event, followed by either a
double-click or a double-drag.

   If you click a button twice and then press it again, all in quick
succession, Emacs generates a "triple-down" event, followed by either a
"triple-click" or a "triple-drag".  The event types of these events
contain `triple' instead of `double'.  If any triple event has no
binding, Emacs uses the binding that it would use for the corresponding
double event.

   If you click a button three or more times and then press it again,
the events for the presses beyond the third are all triple events.
Emacs does not have quadruple, quintuple, etc. events as separate event
types.  However, you can look at the event list to find out precisely
how many times the button was pressed.

 - Function: event-click-count EVENT
     This function returns the number of consecutive button presses
     that led up to EVENT.  If EVENT is a double-down, double-click or
     double-drag event, the value is 2.  If EVENT is a triple event,
     the value is 3 or greater.  If EVENT is an ordinary mouse event
     (not a repeat event), the value is 1.

 - Variable: double-click-time
     To count as double- and triple-clicks, mouse clicks must be at the
     same location as the first click, and the number of milliseconds
     between the first release and the second must be less than the
     value of `double-click-time'.  Setting `double-click-time' to
     `nil' disables multi-click detection entirely.  Setting it to `t'
     removes the time limit; Emacs then detects multi-clicks by
     position only.


File: elisp,  Node: Motion Events,  Next: Focus Events,  Prev: Repeat Events,  Up: Input Events

Motion Events
-------------

   Emacs sometimes generates "mouse motion" events to describe motion
of the mouse without any button activity.  Mouse motion events are
represented by lists that look like this:

     (mouse-movement
      (WINDOW BUFFER-POS
       (COLUMN . ROW) TIMESTAMP))

   The second element of the list describes the current position of the
mouse, just as in a click event (*note Click Events::.).

   The special form `track-mouse' enables generation of motion events
within its body.  Outside of `track-mouse' forms, Emacs does not
generate events for mere motion of the mouse, and these events do not
appear.

 - Special Form: track-mouse BODY...
     This special form executes BODY, with generation of mouse motion
     events enabled.  Typically BODY would use `read-event' to read the
     motion events and modify the display accordingly.

     When the user releases the button, that generates a click event.
     Normally BODY should return when it sees the click event, and
     discard the event.


File: elisp,  Node: Focus Events,  Next: Event Examples,  Prev: Motion Events,  Up: Input Events

Focus Events
------------

   Window systems provide general ways for the user to control which
window gets keyboard input.  This choice of window is called the
"focus".  When the user does something to switch between Emacs frames,
that generates a "focus event".  The normal definition of a focus event,
in the global keymap, is to select a new frame within Emacs, as the user
would expect.  *Note Input Focus::.

   Focus events are represented in Lisp as lists that look like this:

     (switch-frame NEW-FRAME)

where NEW-FRAME is the frame switched to.

   In X windows, most window managers are set up so that just moving the
mouse into a window is enough to set the focus there.  Emacs appears to
do this, because it changes the cursor to solid in the new frame.
However, there is no need for the Lisp program to know about the focus
change until some other kind of input arrives.  So Emacs generates the
focus event only when the user actually types a keyboard key or presses
a mouse button in the new frame; just moving the mouse between frames
does not generate a focus event.

   A focus event in the middle of a key sequence would garble the
sequence.  So Emacs never generates a focus event in the middle of a key
sequence.  If the user changes focus in the middle of a key
sequence--that is, after a prefix key--then Emacs reorders the events
so that the focus event comes either before or after the multi-event key
sequence, and not within it.


File: elisp,  Node: Event Examples,  Next: Classifying Events,  Prev: Focus Events,  Up: Input Events

Event Examples
--------------

   If the user presses and releases the left mouse button over the same
location, that generates a sequence of events like this:

     (down-mouse-1 (#<window 18 on NEWS> 2613 (0 . 38) -864320))
     (mouse-1      (#<window 18 on NEWS> 2613 (0 . 38) -864180))

   Or, while holding the control key down, the user might hold down the
second mouse button, and drag the mouse from one line to the next.
That produces two events, as shown here:

     (C-down-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219))
     (C-drag-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219)
                     (#<window 18 on NEWS> 3510 (0 . 28) -729648))

   Or, while holding down the meta and shift keys, the user might press
the second mouse button on the window's mode line, and then drag the
mouse into another window.  That produces the following pair of events:

     (M-S-down-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844))
     (M-S-drag-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844)
                       (#<window 20 on carlton-sanskrit.tex> 161 (33 . 3)
                        -453816))


File: elisp,  Node: Classifying Events,  Next: Accessing Events,  Prev: Event Examples,  Up: Input Events

Classifying Events
------------------

   Every event has an "event type" which classifies the event for key
binding purposes.  For a keyboard event, the event type equals the event
value; thus, the event type for a character is the character, and the
event type for a function key symbol is the symbol itself.  For events
which are lists, the event type is the symbol in the CAR of the list.
Thus, the event type is always a symbol or a character.

   Two events of the same type are equivalent where key bindings are
concerned; thus, they always run the same command.  That does not
necessarily mean they do the same things, however, as some commands look
at the whole event to decide what to do.  For example, some commands use
the location of a mouse event to decide what text to act on.

   Sometimes broader classifications of events are useful.  For example,
you might want to ask whether an event involved the META key,
regardless of which other key or mouse button was used.

   The functions `event-modifiers' and `event-basic-type' are provided
to get such information conveniently.

 - Function: event-modifiers EVENT
     This function returns a list of the modifiers that EVENT has.  The
     modifiers are symbols; they include `shift', `control', `meta',
     `alt', `hyper' and `super'.  In addition, the property of a mouse
     event symbol always has one of `click', `drag', and `down' among
     the modifiers.  For example:

          (event-modifiers ?a)
               => nil
          (event-modifiers ?\C-a)
               => (control)
          (event-modifiers ?\C-%)
               => (control)
          (event-modifiers ?\C-\S-a)
               => (control shift)
          (event-modifiers 'f5)
               => nil
          (event-modifiers 's-f5)
               => (super)
          (event-modifiers 'M-S-f5)
               => (meta shift)
          (event-modifiers 'mouse-1)
               => (click)
          (event-modifiers 'down-mouse-1)
               => (down)

     The modifiers list for a click event explicitly contains `click',
     but the event symbol name itself does not contain `click'.

 - Function: event-basic-type EVENT
     This function returns the key or mouse button that EVENT
     describes, with all modifiers removed.  For example:

          (event-basic-type ?a)
               => 97
          (event-basic-type ?A)
               => 97
          (event-basic-type ?\C-a)
               => 97
          (event-basic-type ?\C-\S-a)
               => 97
          (event-basic-type 'f5)
               => f5
          (event-basic-type 's-f5)
               => f5
          (event-basic-type 'M-S-f5)
               => f5
          (event-basic-type 'down-mouse-1)
               => mouse-1

 - Function: mouse-movement-p OBJECT
     This function returns non-`nil' if OBJECT is a mouse movement
     event.


File: elisp,  Node: Accessing Events,  Next: Strings of Events,  Prev: Classifying Events,  Up: Input Events

Accessing Events
----------------

   This section describes convenient functions for accessing the data in
an event which is a list.

   The following functions return the starting or ending position of a
mouse-button event.  The position is a list of this form:

     (WINDOW BUFFER-POSITION (COL . ROW) TIMESTAMP)

 - Function: event-start EVENT
     This returns the starting position of EVENT.

     If EVENT is a click or button-down event, this returns the
     location of the event.  If EVENT is a drag event, this returns the
     drag's starting position.

 - Function: event-end EVENT
     This returns the ending position of EVENT.

     If EVENT is a drag event, this returns the position where the user
     released the mouse button.  If EVENT is a click or button-down
     event, the value is actually the starting position, which is the
     only position such events have.

   These four functions take a position-list as described above, and
return various parts of it.

 - Function: posn-window POSITION
     Return the window that POSITION is in.

 - Function: posn-point POSITION
     Return the buffer location in POSITION.

 - Function: posn-col-row POSITION
     Return the row and column in POSITION, as a list `(COL . ROW)'.

 - Function: posn-timestamp POSITION
     Return the timestamp of POSITION.

 - Function: scroll-bar-scale RATIO TOTAL
     This function multiples (in effect) RATIO by TOTAL, rounding the
     result to an integer.  RATIO is not a number, but rather  a pair
     `(NUM . DENOM)'.

     This is handy for scaling a position on a scroll bar into a buffer
     position.  Here's how to do that:

          (+ (point-min)
             (scroll-bar-scale
                (posn-col-row (event-start event))
                (- (point-max) (point-min))))


File: elisp,  Node: Strings of Events,  Prev: Accessing Events,  Up: Input Events

Putting Keyboard Events in Strings
----------------------------------

   In most of the places where strings are used, we conceptualize the
string as containing text characters--the same kind of characters found
in buffers or files.  Occasionally Lisp programs use strings which
conceptually contain keyboard characters; for example, they may be key
sequences or keyboard macro definitions.  There are special rules for
how to put keyboard characters into a string, because they are not
limited to the range of 0 to 255 as text characters are.

   A keyboard character typed using the META key is called a "meta
character".  The numeric code for such an event includes the 2**23 bit;
it does not even come close to fitting in a string.  However, earlier
Emacs versions used a different representation for these characters,
which gave them codes in the range of 128 to 255.  That did fit in a
string, and many Lisp programs contain string constants that use `\M-'
to express meta characters, especially as the argument to `define-key'
and similar functions.

   We provide backward compatibility to run those programs with special
rules for how to put a keyboard character event in a string.  Here are
the rules:

   * If the keyboard event value is in the range of 0 to 127, it can go
     in the string unchanged.

   * The meta variants of those events, with codes in the range of
     2**23 to 2**23+127, can also go in the string, but you must change
     their numeric values.  You must set the 2**7 bit instead of the
     2**23 bit, resulting in a value between 128 and 255.

   * Other keyboard character events cannot fit in a string.  This
     includes keyboard events in the range of 128 to 255.

   Functions such as `read-key-sequence' that can construct strings
containing events follow these rules.

   When you use the read syntax `\M-' in a string, it produces a code
in the range of 128 to 255--the same code that you get if you modify
the corresponding keyboard event to put it in the string.  Thus, meta
events in strings work consistently regardless of how they get into the
strings.

   New programs can avoid dealing with these rules by using vectors
instead of strings for key sequences when there is any possibility that
these issues might arise.

   The reason we changed the representation of meta characters as
keyboard events is to make room for basic character codes beyond 127,
and support meta variants of such larger character codes.


File: elisp,  Node: Reading Input,  Next: Waiting,  Prev: Input Events,  Up: Command Loop

Reading Input
=============

   The editor command loop reads keyboard input using the function
`read-key-sequence', which uses `read-event'.  These and other
functions for keyboard input are also available for use in Lisp
programs.  See also `momentary-string-display' in *Note Temporary
Displays::, and `sit-for' in *Note Waiting::.  *Note Terminal Input::,
for functions and variables for controlling terminal input modes and
debugging terminal input.

   For higher-level input facilities, see *Note Minibuffers::.

* Menu:

* Key Sequence Input::		How to read one key sequence.
* Reading One Event::		How to read just one event.
* Quoted Character Input::	Asking the user to specify a character.
* Peeking and Discarding::	How to reread or throw away input events.


File: elisp,  Node: Key Sequence Input,  Next: Reading One Event,  Up: Reading Input

Key Sequence Input
------------------

   The command loop reads input a key sequence at a time, by calling
`read-key-sequence'.  Lisp programs can also call this function; for
example, `describe-key' uses it to read the key to describe.

 - Function: read-key-sequence PROMPT
     This function reads a key sequence and returns it as a string or
     vector.  It keeps reading events until it has accumulated a full
     key sequence; that is, enough to specify a non-prefix command
     using the currently active keymaps.

     If the events are all characters and all can fit in a string, then
     `read-key-sequence' returns a string (*note Strings of Events::.).
     Otherwise, it returns a vector, since a vector can hold all kinds
     of events--characters, symbols, and lists.  The elements of the
     string or vector are the events in the key sequence.

     Quitting is suppressed inside `read-key-sequence'.  In other words,
     a `C-g' typed while reading with this function is treated like any
     other character, and does not set `quit-flag'.  *Note Quitting::.

     The argument PROMPT is either a string to be displayed in the echo
     area as a prompt, or `nil', meaning not to display a prompt.

     In the example below, the prompt `?' is displayed in the echo area,
     and the user types `C-x C-f'.

          (read-key-sequence "?")
          
          ---------- Echo Area ----------
          ?`C-x C-f'
          ---------- Echo Area ----------
          
               => "^X^F"

 - Variable: num-input-keys
     This variable's value is the number of key sequences processed so
     far in this Emacs session.  This includes key sequences read from
     the terminal and key sequences read from keyboard macros being
     executed.

   If an input character is an upper case letter and has no key binding,
but the lower case equivalent has one, then `read-key-sequence'
converts the character to lower case.  Note that `lookup-key' does not
perform case conversion in this way.

   The function `read-key-sequence' also transforms some mouse events.
It converts unbound drag events into click events, and discards unbound
button-down events entirely.  It also reshuffles focus events so that
they never appear in a key sequence with any other events.

   When mouse events occur in special parts of a window, such as a mode
line or a scroll bar, the event itself shows nothing special--only the
symbol that would normally represent that mouse button and modifier
keys.  The information about the screen region is kept elsewhere in the
event--in the coordinates.  But `read-key-sequence' translates this
information into imaginary prefix keys, all of which are symbols:
`mode-line', `vertical-line', `horizontal-scroll-bar' and
`vertical-scroll-bar'.

   For example, if you call `read-key-sequence' and then click the
mouse on the window's mode line, this is what happens:

     (read-key-sequence "Click on the mode line: ")
          => [mode-line
               (mouse-1
                (#<window 6 on NEWS> mode-line
                 (40 . 63) 5959987))]

   You can define meanings for mouse clicks in special window regions by
defining key sequences using these imaginary prefix keys.


File: elisp,  Node: Reading One Event,  Next: Quoted Character Input,  Prev: Key Sequence Input,  Up: Reading Input

Reading One Event
-----------------

   The lowest level functions for command input are those which read a
single event.

 - Function: read-event
     This function reads and returns the next event of command input,
     waiting if necessary until an event is available.  Events can come
     directly from the user or from a keyboard macro.

     The function `read-event' does not display any message to indicate
     it is waiting for input; use `message' first, if you wish to
     display one.  If you have not displayed a message, `read-event'
     does "prompting": it displays descriptions of the events that led
     to or were read by the current command.  *Note The Echo Area::.

     If `cursor-in-echo-area' is non-`nil', then `read-event' moves the
     cursor temporarily to the echo area, to the end of any message
     displayed there.  Otherwise `read-event' does not move the cursor.

   Here is what happens if you call `read-event' and then press the
right-arrow function key:

     (read-event)
          => right

 - Function: read-char
     This function reads and returns a character of command input.  It
     discards any events that are not characters until it gets a
     character.

     In the first example, the user types `1' (which is ASCII code 49).
     The second example shows a keyboard macro definition that calls
     `read-char' from the minibuffer.  `read-char' reads the keyboard
     macro's very next character, which is `1'.  The value of this
     function is displayed in the echo area by the command
     `eval-expression'.

          (read-char)
               => 49
          
          (symbol-function 'foo)
               => "^[^[(read-char)^M1"
          (execute-kbd-macro foo)
               -| 49
               => nil


File: elisp,  Node: Quoted Character Input,  Next: Peeking and Discarding,  Prev: Reading One Event,  Up: Reading Input

Quoted Character Input
----------------------

   You can use the function `read-quoted-char' when you want the user
to specify a character, and allow the user to specify a control or meta
character conveniently with quoting or as an octal character code.  The
command `quoted-insert' calls this function.

 - Function: read-quoted-char &optional PROMPT
     This function is like `read-char', except that if the first
     character read is an octal digit (0-7), it reads up to two more
     octal digits (but stopping if a non-octal digit is found) and
     returns the character represented by those digits as an octal
     number.

     Quitting is suppressed when the first character is read, so that
     the user can enter a `C-g'.  *Note Quitting::.

     If PROMPT is supplied, it specifies a string for prompting the
     user.  The prompt string is always printed in the echo area and
     followed by a single `-'.

     In the following example, the user types in the octal number 177
     (which is 127 in decimal).

          (read-quoted-char "What character")
          
          ---------- Echo Area ----------
          What character-`177'
          ---------- Echo Area ----------
          
               => 127


File: elisp,  Node: Peeking and Discarding,  Prev: Quoted Character Input,  Up: Reading Input

Peeking and Discarding
----------------------

 - Variable: unread-command-events
     This variable holds a list of events waiting to be read as command
     input.  The events are used in the order they appear in the list.

     The variable is used because in some cases a function reads a
     event and then decides not to use it.  Storing the event in this
     variable causes it to be processed normally by the command loop or
     when the functions to read command input are called.

     For example, the function that implements numeric prefix arguments
     reads any number of digits.  When it finds a non-digit event, it
     must unread the event so that it can be read normally by the
     command loop.  Likewise, incremental search uses this feature to
     unread events it does not recognize.

 - Variable: unread-command-char
     This variable holds a character to be read as command input.  A
     value of -1 means "empty".

     This variable is pretty much obsolete now that you can use
     `unread-command-events' instead; it exists only to support programs
     written for Emacs versions 18 and earlier.

 - Function: listify-key-sequence KEY
     This function converts the string or vector KEY to a list of
     events which you can put in `unread-command-events'.  Converting a
     vector is simple, but converting a string is tricky because of the
     special representation used for meta characters in a string (*note
     Strings of Events::.).

 - Function: input-pending-p
     This function determines whether any command input is currently
     available to be read.  It returns immediately, with value `t' if
     there is input, `nil' otherwise.  On rare occasions it may return
     `t' when no input is available.

 - Variable: last-input-event
 - Variable: last-input-char
     This variable records the last terminal input event read, whether
     as part of a command or explicitly by a Lisp program.

     In the example below, a character is read (the character `1',
     ASCII code 49).  It becomes the value of `last-input-char', while
     `C-e' (from the `C-x C-e' command used to evaluate this
     expression) remains the value of `last-command-char'.

          (progn (print (read-char))
                 (print last-command-char)
                 last-input-char)
               -| 49
               -| 5
               => 49

     The alias `last-input-char' exists for compatibility with Emacs
     version 18.

 - Function: discard-input
     This function discards the contents of the terminal input buffer
     and cancels any keyboard macro that might be in the process of
     definition.  It returns `nil'.

     In the following example, the user may type a number of characters
     right after starting the evaluation of the form.  After the
     `sleep-for' finishes sleeping, any characters that have been typed
     are discarded.

          (progn (sleep-for 2)
            (discard-input))
               => nil


File: elisp,  Node: Waiting,  Next: Quitting,  Prev: Reading Input,  Up: Command Loop

Waiting for Elapsed Time or Input
=================================

   The waiting commands are designed to make Emacs wait for a certain
amount of time to pass or until there is input.  For example, you may
wish to pause in the middle of a computation to allow the user time to
view the display.  `sit-for' pauses and updates the screen, and returns
immediately if input comes in, while `sleep-for' pauses without
updating the screen.

 - Function: sit-for SECONDS &optional MILLISEC NODISP
     This function performs redisplay (provided there is no pending
     input from the user), then waits SECONDS seconds, or until input is
     available.  The result is `t' if `sit-for' waited the full time
     with no input arriving (see `input-pending-p' in *Note Peeking and
     Discarding::).  Otherwise, the value is `nil'.

     The optional argument MILLISEC specifies an additional waiting
     period measured in milliseconds.  This adds to the period
     specified by SECONDS.  Not all operating systems support waiting
     periods other than multiples of a second; on those that do not,
     you get an error if you specify nonzero MILLISEC.

     Redisplay is always preempted if input arrives, and does not
     happen at all if input is available before it starts.  Thus, there
     is no way to force screen updating if there is pending input;
     however, if there is no input pending, you can force an update
     with no delay by using `(sit-for 0)'.

     If NODISP is non-`nil', then `sit-for' does not redisplay, but it
     still returns as soon as input is available (or when the timeout
     elapses).

     The usual purpose of `sit-for' is to give the user time to read
     text that you display.

 - Function: sleep-for SECONDS &optional MILLISEC
     This function simply pauses for SECONDS seconds without updating
     the display.  It pays no attention to available input.  It returns
     `nil'.

     The optional argument MILLISEC specifies an additional waiting
     period measured in milliseconds.  This adds to the period
     specified by SECONDS.  Not all operating systems support waiting
     periods other than multiples of a second; on those that do not,
     you get an error if you specify nonzero MILLISEC.

     Use `sleep-for' when you wish to guarantee a delay.

   *Note Time of Day::, for functions to get the current time.


File: elisp,  Node: Quitting,  Next: Prefix Command Arguments,  Prev: Waiting,  Up: Command Loop

Quitting
========

   Typing `C-g' while the command loop has run a Lisp function causes
Emacs to "quit" whatever it is doing.  This means that control returns
to the innermost active command loop.

   Typing `C-g' while the command loop is waiting for keyboard input
does not cause a quit; it acts as an ordinary input character.  In the
simplest case, you cannot tell the difference, because `C-g' normally
runs the command `keyboard-quit', whose effect is to quit.  However,
when `C-g' follows a prefix key, the result is an undefined key.  The
effect is to cancel the prefix key as well as any prefix argument.

   In the minibuffer, `C-g' has a different definition: it aborts out
of the minibuffer.  This means, in effect, that it exits the minibuffer
and then quits.  (Simply quitting would return to the command loop
*within* the minibuffer.)  The reason why `C-g' does not quit directly
when the command reader is reading input is so that its meaning can be
redefined in the minibuffer in this way.  `C-g' following a prefix key
is not redefined in the minibuffer, and it has its normal effect of
canceling the prefix key and prefix argument.  This too would not be
possible if `C-g' quit directly.

   `C-g' causes a quit by setting the variable `quit-flag' to a
non-`nil' value.  Emacs checks this variable at appropriate times and
quits if it is not `nil'.  Setting `quit-flag' non-`nil' in any way
thus causes a quit.

   At the level of C code, quits cannot happen just anywhere; only at
the special places which check `quit-flag'.  The reason for this is
that quitting at other places might leave an inconsistency in Emacs's
internal state.  Because quitting is delayed until a safe place,
quitting cannot make Emacs crash.

   Certain functions such as `read-key-sequence' or `read-quoted-char'
prevent quitting entirely even though they wait for input.  Instead of
quitting, `C-g' serves as the requested input.  In the case of
`read-key-sequence', this serves to bring about the special behavior of
`C-g' in the command loop.  In the case of `read-quoted-char', this is
so that `C-q' can be used to quote a `C-g'.

   You can prevent quitting for a portion of a Lisp function by binding
the variable `inhibit-quit' to a non-`nil' value.  Then, although `C-g'
still sets `quit-flag' to `t' as usual, the usual result of this--a
quit--is prevented.  Eventually, `inhibit-quit' will become `nil'
again, such as when its binding is unwound at the end of a `let' form.
At that time, if `quit-flag' is still non-`nil', the requested quit
happens immediately.  This behavior is ideal for a "critical section",
where you wish to make sure that quitting does not happen within that
part of the program.

   In some functions (such as `read-quoted-char'), `C-g' is handled in
a special way which does not involve quitting.  This is done by reading
the input with `inhibit-quit' bound to `t' and setting `quit-flag' to
`nil' before `inhibit-quit' becomes `nil' again.  This excerpt from the
definition of `read-quoted-char' shows how this is done; it also shows
that normal quitting is permitted after the first character of input.

     (defun read-quoted-char (&optional prompt)
       "...DOCUMENTATION..."
       (let ((count 0) (code 0) char)
         (while (< count 3)
           (let ((inhibit-quit (zerop count))
                 (help-form nil))
             (and prompt (message "%s-" prompt))
             (setq char (read-char))
             (if inhibit-quit (setq quit-flag nil)))
           ...)
         (logand 255 code)))

 - Variable: quit-flag
     If this variable is non-`nil', then Emacs quits immediately,
     unless `inhibit-quit' is non-`nil'.  Typing `C-g' sets `quit-flag'
     non-`nil', regardless of `inhibit-quit'.

 - Variable: inhibit-quit
     This variable determines whether Emacs should quit when `quit-flag'
     is set to a value other than `nil'.  If `inhibit-quit' is
     non-`nil', then `quit-flag' has no special effect.

 - Command: keyboard-quit
     This function signals the `quit' condition with `(signal 'quit
     nil)'.  This is the same thing that quitting does.  (See `signal'
     in *Note Errors::.)

   You can specify a character other than `C-g' to use for quitting.
See the function `set-input-mode' in *Note Terminal Input::.


File: elisp,  Node: Prefix Command Arguments,  Next: Recursive Editing,  Prev: Quitting,  Up: Command Loop

Prefix Command Arguments
========================

   Most Emacs commands can use a "prefix argument", a number specified
before the command itself.  (Don't confuse prefix arguments with prefix
keys.)  The prefix argument is represented by a value that is always
available (though it may be `nil', meaning there is no prefix
argument).  Each command may use the prefix argument or ignore it.

   There are two representations of the prefix argument: "raw" and
"numeric".  The editor command loop uses the raw representation
internally, and so do the Lisp variables that store the information, but
commands can request either representation.

   Here are the possible values of a raw prefix argument:

   * `nil', meaning there is no prefix argument.  Its numeric value is
     1, but numerous commands make a distinction between `nil' and the
     integer 1.

   * An integer, which stands for itself.

   * A list of one element, which is an integer.  This form of prefix
     argument results from one or a succession of `C-u''s with no
     digits.  The numeric value is the integer in the list, but some
     commands make a distinction between such a list and an integer
     alone.

   * The symbol `-'.  This indicates that `M--' or `C-u -' was typed,
     without following digits.  The equivalent numeric value is -1, but
     some commands make a distinction between the integer -1 and the
     symbol `-'.

   The various possibilities may be illustrated by calling the following
function with various prefixes:

     (defun display-prefix (arg)
       "Display the value of the raw prefix arg."
       (interactive "P")
       (message "%s" arg))

Here are the results of calling `print-prefix' with various raw prefix
arguments:

             M-x print-prefix  -| nil
     
     C-u     M-x print-prefix  -| (4)
     
     C-u C-u M-x print-prefix  -| (16)
     
     C-u 3   M-x print-prefix  -| 3
     
     M-3     M-x print-prefix  -| 3      ; (Same as `C-u 3'.)
     
     C-u -   M-x print-prefix  -| -
     
     M- -    M-x print-prefix  -| -      ; (Same as `C-u -'.)
     
     C-u -7  M-x print-prefix  -| -7
     
     M- -7   M-x print-prefix  -| -7     ; (Same as `C-u -7'.)

   Emacs uses two variables to store the prefix argument: `prefix-arg'
and `current-prefix-arg'.  Commands such as `universal-argument' that
set up prefix arguments for other commands store them in `prefix-arg'.
In contrast, `current-prefix-arg' conveys the prefix argument to the
current command, so setting it has no effect on the prefix arguments
for future commands.

   Normally, commands specify which representation to use for the prefix
argument, either numeric or raw, in the `interactive' declaration.
(*Note Interactive Call::.)  Alternatively, functions may look at the
value of the prefix argument directly in the variable
`current-prefix-arg', but this is less clean.

   Do not call the functions `universal-argument', `digit-argument', or
`negative-argument' unless you intend to let the user enter the prefix
argument for the *next* command.

 - Command: universal-argument
     This command reads input and specifies a prefix argument for the
     following command.  Don't call this command yourself unless you
     know what you are doing.

 - Command: digit-argument ARG
     This command adds to the prefix argument for the following
     command.  The argument ARG is the raw prefix argument as it was
     before this command; it is used to compute the updated prefix
     argument.  Don't call this command yourself unless you know what
     you are doing.

 - Command: negative-argument ARG
     This command adds to the numeric argument for the next command.
     The argument ARG is the raw prefix argument as it was before this
     command; its value is negated to form the new prefix argument.
     Don't call this command yourself unless you know what you are
     doing.

 - Function: prefix-numeric-value ARG
     This function returns the numeric meaning of a valid raw prefix
     argument value, ARG.  The argument may be a symbol, a number, or a
     list.  If it is `nil', the value 1 is returned; if it is any other
     symbol, the value -1 is returned.  If it is a number, that number
     is returned; if it is a list, the CAR of that list (which should
     be a number) is returned.

 - Variable: current-prefix-arg
     This variable is the value of the raw prefix argument for the
     *current* command.  Commands may examine it directly, but the usual
     way to access it is with `(interactive "P")'.

 - Variable: prefix-arg
     The value of this variable is the raw prefix argument for the
     *next* editing command.  Commands that specify prefix arguments for
     the following command work by setting this variable.


File: elisp,  Node: Recursive Editing,  Next: Disabling Commands,  Prev: Prefix Command Arguments,  Up: Command Loop

Recursive Editing
=================

   The Emacs command loop is entered automatically when Emacs starts up.
This top-level invocation of the command loop is never exited until the
Emacs is killed.  Lisp programs can also invoke the command loop.  Since
this makes more than one activation of the command loop, we call it
"recursive editing".  A recursive editing level has the effect of
suspending whatever command invoked it and permitting the user to do
arbitrary editing before resuming that command.

   The commands available during recursive editing are the same ones
available in the top-level editing loop and defined in the keymaps.
Only a few special commands exit the recursive editing level; the others
return to the recursive editing level when finished.  (The special
commands for exiting are always available, but do nothing when recursive
editing is not in progress.)

   All command loops, including recursive ones, set up all-purpose error
handlers so that an error in a command run from the command loop will
not exit the loop.

   Minibuffer input is a special kind of recursive editing.  It has a
few special wrinkles, such as enabling display of the minibuffer and the
minibuffer window, but fewer than you might suppose.  Certain keys
behave differently in the minibuffer, but that is only because of the
minibuffer's local map; if you switch windows, you get the usual Emacs
commands.

   To invoke a recursive editing level, call the function
`recursive-edit'.  This function contains the command loop; it also
contains a call to `catch' with tag `exit', which makes it possible to
exit the recursive editing level by throwing to `exit' (*note Catch and
Throw::.).  If you throw a value other than `t', then `recursive-edit'
returns normally to the function that called it.  The command `C-M-c'
(`exit-recursive-edit') does this.  Throwing a `t' value causes
`recursive-edit' to quit, so that control returns to the command loop
one level up.  This is called "aborting", and is done by `C-]'
(`abort-recursive-edit').

   Most applications should not use recursive editing, except as part of
using the minibuffer.  Usually it is more convenient for the user if you
change the major mode of the current buffer temporarily to a special
major mode, which has a command to go back to the previous mode.  (This
technique is used by the `w' command in Rmail.)  Or, if you wish to
give the user different text to edit "recursively", create and select a
new buffer in a special mode.  In this mode, define a command to
complete the processing and go back to the previous buffer.  (The `m'
command in Rmail does this.)

   Recursive edits are useful in debugging.  You can insert a call to
`debug' into a function definition as a sort of breakpoint, so that you
can look around when the function gets there.  `debug' invokes a
recursive edit but also provides the other features of the debugger.

   Recursive editing levels are also used when you type `C-r' in
`query-replace' or use `C-x q' (`kbd-macro-query').

 - Function: recursive-edit
     This function invokes the editor command loop.  It is called
     automatically by the initialization of Emacs, to let the user begin
     editing.  When called from a Lisp program, it enters a recursive
     editing level.

     In the following example, the function `simple-rec' first advances
     point one word, then enters a recursive edit, printing out a
     message in the echo area.  The user can then do any editing
     desired, and then type `C-M-c' to exit and continue executing
     `simple-rec'.

          (defun simple-rec ()
            (forward-word 1)
            (message "Recursive edit in progress.")
            (recursive-edit)
            (forward-word 1))
               => simple-rec
          (simple-rec)
               => nil

 - Command: exit-recursive-edit
     This function exits from the innermost recursive edit (including
     minibuffer input).  Its definition is effectively `(throw 'exit
     nil)'.

 - Command: abort-recursive-edit
     This function aborts the command that requested the innermost
     recursive edit (including minibuffer input), by signaling `quit'
     after exiting the recursive edit.  Its definition is effectively
     `(throw 'exit t)'.  *Note Quitting::.

 - Command: top-level
     This function exits all recursive editing levels; it does not
     return a value, as it jumps completely out of any computation
     directly back to the main command loop.

 - Function: recursion-depth
     This function returns the current depth of recursive edits.  When
     no recursive edit is active, it returns 0.


File: elisp,  Node: Disabling Commands,  Next: Command History,  Prev: Recursive Editing,  Up: Command Loop

Disabling Commands
==================

   "Disabling a command" marks the command as requiring user
confirmation before it can be executed.  Disabling is used for commands
which might be confusing to beginning users, to prevent them from using
the commands by accident.

   The low-level mechanism for disabling a command is to put a
non-`nil' `disabled' property on the Lisp symbol for the command.
These properties are normally set up by the user's `.emacs' file with
Lisp expressions such as this:

     (put 'upcase-region 'disabled t)

For a few commands, these properties are present by default and may be
removed by the `.emacs' file.

   If the value of the `disabled' property is a string, that string is
included in the message printed when the command is used:

     (put 'delete-region 'disabled
          "Text deleted this way cannot be yanked back!\n")

   *Note Disabling: (emacs)Disabling, for the details on what happens
when a disabled command is invoked interactively.  Disabling a command
has no effect on calling it as a function from Lisp programs.

 - Command: enable-command COMMAND
     Allow COMMAND to be executed without special confirmation from now
     on.  The user's `.emacs' file is optionally altered so that this
     will apply to future sessions.

 - Command: disable-command COMMAND
     Require special confirmation to execute COMMAND from now on.  The
     user's `.emacs' file is optionally altered so that this will apply
     to future sessions.

 - Variable: disabled-command-hook
     This variable is a normal hook that is run instead of a disabled
     command, when the user runs the disabled command interactively.
     The hook functions can use `this-command-keys' to determine what
     the user typed to run the command, and thus find the command
     itself.

     By default, `disabled-command-hook' contains a function that asks
     the user whether to proceed.


File: elisp,  Node: Command History,  Next: Keyboard Macros,  Prev: Disabling Commands,  Up: Command Loop

Command History
===============

   The command loop keeps a history of the complex commands that have
been executed, to make it convenient to repeat these commands.  A
"complex command" is one for which the interactive argument reading
uses the minibuffer.  This includes any `M-x' command, any `M-ESC'
command, and any command whose `interactive' specification reads an
argument from the minibuffer.  Explicit use of the minibuffer during
the execution of the command itself does not cause the command to be
considered complex.

 - Variable: command-history
     This variable's value is a list of recent complex commands, each
     represented as a form to evaluate.  It continues to accumulate all
     complex commands for the duration of the editing session, but all
     but the first (most recent) thirty elements are deleted when a
     garbage collection takes place (*note Garbage Collection::.).

          command-history
          => ((switch-to-buffer "chistory.texi")
              (describe-key "^X^[")
              (visit-tags-table "~/emacs/src/")
              (find-tag "repeat-complex-command"))

   This history list is actually a special case of minibuffer history
(*note Minibuffer History::.), with one special twist: the elements are
expressions rather than strings.

   There are a number of commands devoted to the editing and recall of
previous commands.  The commands `repeat-complex-command', and
`list-command-history' are described in the user manual (*note
Repetition: (emacs)Repetition.).  Within the minibuffer, the history
commands used are the same ones available in any minibuffer.


File: elisp,  Node: Keyboard Macros,  Prev: Command History,  Up: Command Loop

Keyboard Macros
===============

   A "keyboard macro" is a canned sequence of input events that can be
considered a command and made the definition of a key.  Don't confuse
keyboard macros with Lisp macros (*note Macros::.).

 - Function: execute-kbd-macro MACRO &optional COUNT
     This function executes MACRO as a sequence of events.  If MACRO is
     a string or vector, then the events in it are executed exactly as
     if they had been input by the user.  The sequence is *not*
     expected to be a single key sequence; normally a keyboard macro
     definition consists of several key sequences concatenated.

     If MACRO is a symbol, then its function definition is used in
     place of MACRO.  If that is another symbol, this process repeats.
     Eventually the result should be a string or vector.  If the result
     is not a symbol, string, or vector, an error is signaled.

     The argument COUNT is a repeat count; MACRO is executed that many
     times.  If COUNT is omitted or `nil', MACRO is executed once.  If
     it is 0, MACRO is executed over and over until it encounters an
     error or a failing search.

 - Variable: last-kbd-macro
     This variable is the definition of the most recently defined
     keyboard macro.  Its value is a string or vector, or `nil'.

 - Variable: executing-macro
     This variable contains the string or vector that defines the
     keyboard macro that is currently executing.  It is `nil' if no
     macro is currently executing.

 - Variable: defining-kbd-macro
     This variable indicates whether a keyboard macro is being defined.
     It is set to `t' by `start-kbd-macro', and `nil' by
     `end-kbd-macro'.  You can use this variable to make a command
     behave differently when run from a keyboard macro (perhaps
     indirectly by calling `interactive-p').  However, do not set this
     variable yourself.

   The commands are described in the user's manual (*note Keyboard
Macros: (emacs)Keyboard Macros.).


File: elisp,  Node: Keymaps,  Next: Modes,  Prev: Command Loop,  Up: Top

Keymaps
*******

   The bindings between input events and commands are recorded in data
structures called "keymaps".  Each binding in a keymap associates (or
"binds") an individual event type either with another keymap or with a
command.  When an event is bound to a keymap, that keymap is used to
look up the next character typed; this continues until a command is
found.  The whole process is called "key lookup".

* Menu:

* Keymap Terminology::        	Definitions of terms pertaining to keymaps.
* Format of Keymaps::		What a keymap looks like as a Lisp object.
* Creating Keymaps:: 		Functions to create and copy keymaps.
* Inheritance and Keymaps::	How one keymap can inherit the bindings
				   of another keymap.
* Prefix Keys::                 Defining a key with a keymap as its definition.
* Menu Keymaps::		A keymap can define a menu.
* Active Keymaps::	        Each buffer has a local keymap
                                   to override the standard (global) bindings.
				   A minor mode can also override them.
* Key Lookup::                  How extracting elements from keymaps works.
* Functions for Key Lookup::    How to request key lookup.
* Changing Key Bindings::       Redefining a key in a keymap.
* Key Binding Commands::        Interactive interfaces for redefining keys.
* Scanning Keymaps::            Looking through all keymaps, for printing help.

