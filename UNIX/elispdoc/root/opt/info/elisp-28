This is Info file elisp, produced by Makeinfo-1.55 from the input file
elisp.texi.

   This version is newer than the second printed edition of the GNU
Emacs Lisp Reference Manual.  It corresponds to Emacs Version 19.19.

   Published by the Free Software Foundation 675 Massachusetts Avenue
Cambridge, MA 02139 USA

   Copyright (C) 1990, 1991, 1992, 1993 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: elisp,  Node: Display,  Next: Calendar,  Prev: System Interface,  Up: Top

Emacs Display
*************

   This chapter describes a number of features related to the display
that Emacs presents to the user.

* Menu:

* Refresh Screen::      Clearing the screen and redrawing everything on it.
* Screen Size::         How big is the Emacs screen.
* Truncation::          Folding or wrapping long text lines.
* The Echo Area::       Where messages are displayed.
* Selective Display::   Hiding part of the buffer text.
* Overlay Arrow::       Display of an arrow to indicate position.
* Temporary Displays::  Displays that go away automatically.
* Overlays::		Use overlays to highlight parts of the buffer.
* Faces::		A face defines a graphics appearance: font, color, etc.
* Blinking::            How Emacs shows the matching open parenthesis.
* Inverse Video::	Specifying how the screen looks.
* Usual Display::	The usual conventions for displaying nonprinting chars.
* Display Tables::	How to specify other conventions.
* Beeping::             Audible signal to the user.
* Window Systems::      Which window system is being used.


File: elisp,  Node: Refresh Screen,  Next: Screen Size,  Up: Display

Refreshing the Screen
=====================

   The function `redraw-frame' redisplays the entire contents of a
given frame.  *Note Frames::.

 - Function: redraw-frame FRAME
     This function clears and redisplays frame FRAME.

   Even more powerful is `redraw-display'.

 - Command: redraw-display
     This function clears and redisplays all visible frames.

   Normally, suspending and resuming Emacs also refreshes the screen.
Some terminal emulators record separate contents for display-oriented
programs such as Emacs and for ordinary sequential display.  If you are
using such a terminal, you might want to inhibit the redisplay on
resumption.  *Note Suspending Emacs::.

 - Variable: no-redraw-on-reenter
     This variable controls whether Emacs redraws the entire screen
     after it has been suspended and resumed.  Non-`nil' means yes,
     `nil' means no.

   Processing user input takes absolute priority over redisplay.  If you
call these functions when input is available, they do nothing
immediately, but a full redisplay does happen eventually--after all the
input has been processed.


File: elisp,  Node: Screen Size,  Next: Truncation,  Prev: Refresh Screen,  Up: Display

Screen Size
===========

   The screen size functions report or tell Emacs the height or width of
the terminal.  When you are using multiple frames, they apply to the
selected frame (*note Frames::.).

 - Function: screen-height
     This function returns the number of lines on the screen that are
     available for display.

          (screen-height)
               => 50

 - Function: screen-width
     This function returns the number of columns on the screen that are
     available for display.

          (screen-width)
               => 80

 - Function: set-screen-height LINES &optional NOT-ACTUAL-SIZE
     This function declares that the terminal can display LINES lines.
     The sizes of existing windows are altered proportionally to fit.

     If NOT-ACTUAL-SIZE is non-`nil', then Emacs displays LINES lines
     of output, but does not change its value for the actual height of
     the screen.  (Knowing the correct actual size may be necessary for
     correct cursor positioning.)  Using a smaller height than the
     terminal actually implements may be useful to reproduce behavior
     observed on a smaller screen, or if the terminal malfunctions when
     using its whole screen.

     If LINES is different from what it was previously, then the entire
     screen is cleared and redisplayed using the new size.

     This function returns `nil'.

 - Function: set-screen-width COLUMNS &optional NOT-ACTUAL-SIZE
     This function declares that the terminal can display COLUMNS
     columns.  The details are as in `set-screen-height'.


File: elisp,  Node: Truncation,  Next: The Echo Area,  Prev: Screen Size,  Up: Display

Truncation
==========

   When a line of text extends beyond the right edge of a window, the
line can either be truncated or continued on the next line.  When a line
is truncated, this is shown with a `$' in the rightmost column of the
window.  When a line is continued or "wrapped" onto the next line, this
is shown with a `\' on the rightmost column of the window.  The
additional screen lines used to display a long text line are called
"continuation" lines.  (Note that wrapped lines are not filled; filling
has nothing to do with continuation and truncation.  *Note Filling::.)

 - User Option: truncate-lines
     This buffer-local variable controls how Emacs displays lines that
     extend beyond the right edge of the window.  If it is non-`nil',
     then Emacs does not display continuation lines; rather each line of
     text occupies exactly one screen line, and a dollar sign appears
     at the edge of any line that extends to or beyond the edge of the
     window.  The default is `nil'.

     If the variable `truncate-partial-width-windows' is non-`nil',
     then truncation is used for windows that are not the full width of
     the screen, regardless of the value of `truncate-lines'.

 - Variable: default-truncate-lines
     This variable is the default value for `truncate-lines' in buffers
     that do not have local values for it.

 - User Option: truncate-partial-width-windows
     This variable determines how lines that are too wide to fit on the
     screen are displayed in side-by-side windows (*note Splitting
     Windows::.).  If it is non-`nil', then wide lines are truncated
     (with a `$' at the end of the line); otherwise they wrap to the
     next screen line (with a `\' at the end of the line).

   You can override the images that indicate continuation or truncation
with the display table; see *Note Display Tables::.


File: elisp,  Node: The Echo Area,  Next: Selective Display,  Prev: Truncation,  Up: Display

The Echo Area
=============

   The "echo area" is used for displaying messages made with the
`message' primitive, and for echoing keystrokes.  It is not the same as
the minibuffer, despite the fact that the minibuffer appears (when
active) in the same place on the screen as the echo area.  The `GNU
Emacs Manual' specifies the rules for resolving conflicts between the
echo area and the minibuffer for use of that screen space (*note The
Minibuffer: (emacs)Minibuffer.).  Error messages appear in the echo
area; see *Note Errors::.

   You can write output in the echo area by using the Lisp printing
functions with `t' as the stream (*note Output Functions::.), or as
follows:

 - Function: message STRING &rest ARGUMENTS
     This function prints a one-line message in the echo area.  The
     argument STRING is similar to a C language `printf' control
     string.  See `format' in *Note String Conversion::, for the details
     on the conversion specifications.  `message' returns the
     constructed string.

     If STRING is `nil', `message' clears the echo area.  If the
     minibuffer is active, this brings the minibuffer contents back onto
     the screen immediately.
          (message
           "Minibuffer depth is %d."
           (minibuffer-depth))
          => "Minibuffer depth is 0."
          
          ---------- Echo Area ----------
          Minibuffer depth is 0.
          ---------- Echo Area ----------

 - Variable: cursor-in-echo-area
     This variable controls where the cursor appears when a message is
     displayed in the echo area.  If it is non-`nil', then the cursor
     appears at the end of the message.  Otherwise, the cursor appears
     at point--not in the echo area at all.

     The value is normally `nil'; Lisp programs bind it to `t' for
     brief periods of time.


File: elisp,  Node: Selective Display,  Next: Overlay Arrow,  Prev: The Echo Area,  Up: Display

Selective Display
=================

   "Selective display" is a class of minor modes in which specially
marked lines do not appear on the screen, or in which highly indented
lines do not appear.

   The first variant, explicit selective display, is designed for use in
a Lisp program.  The program controls which lines are hidden by altering
the text.  Outline mode uses this variant.  In the second variant, the
choice of lines to hide is made automatically based on indentation.
This variant is designed as a user-level feature.

   The way you control explicit selective display is by replacing a
newline (control-j) with a control-m.  The text which was formerly a
line following that newline is now invisible.  Strictly speaking, it is
temporarily no longer a line at all, since only newlines can separate
lines; it is now part of the previous line.

   Selective display does not directly affect editing commands.  For
example, `C-f' (`forward-char') moves point unhesitatingly into
invisible space.  However, the replacement of newline characters with
carriage return characters affects some editing commands.  For example,
`next-line' skips invisible lines, since it searches only for newlines.
Modes that use selective display can also define commands that take
account of the newlines, or which make parts of the text visible or
invisible.

   When you write a selectively displayed buffer into a file, all the
control-m's are replaced by their original newlines.  This means that
when you next read in the file, it looks OK, with nothing invisible.
The selective display effect is seen only within Emacs.

 - Variable: selective-display
     This buffer-local variable enables selective display.  This means
     that lines, or portions of lines, may be made invisible.

        * If the value of `selective-display' is `t', then any portion
          of a line that follows a control-m is not displayed.

        * If the value of `selective-display' is a positive integer,
          then lines that start with more than `selective-display'
          columns of indentation are not displayed.

     When some portion of a buffer is invisible, the vertical movement
     commands operate as if that portion did not exist, allowing a
     single `next-line' command to skip any number of invisible lines.
     However, character movement commands (such as `forward-char') do
     not skip the invisible portion, and it is possible (if tricky) to
     insert or delete text in an invisible portion.

     In the examples below, what is shown is the *display* of the buffer
     `foo', which changes with the value of `selective-display'.  The
     *contents* of the buffer do not change.

          (setq selective-display nil)
               => nil
          
          ---------- Buffer: foo ----------
          1 on this column
           2on this column
            3n this column
            3n this column
           2on this column
          1 on this column
          ---------- Buffer: foo ----------
          
          (setq selective-display 2)
               => 2
          
          ---------- Buffer: foo ----------
          1 on this column
           2on this column
           2on this column
          1 on this column
          ---------- Buffer: foo ----------

 - Variable: selective-display-ellipses
     If this buffer-local variable is non-`nil', then Emacs displays
     `...' at the end of a line that is followed by invisible text.
     This example is a continuation of the previous one.

          (setq selective-display-ellipses t)
               => t
          
          ---------- Buffer: foo ----------
          1 on this column
           2on this column ...
           2on this column
          1 on this column
          ---------- Buffer: foo ----------

     You can use a display table to substitute other text for the
     ellipsis (`...').  *Note Display Tables::.


File: elisp,  Node: Overlay Arrow,  Next: Temporary Displays,  Prev: Selective Display,  Up: Display

Overlay Arrow
=============

   The "overlay arrow" is useful for directing the user's attention to
a particular line in a buffer.  For example, in the modes used for
interface to debuggers, the overlay arrow indicates the line of code
about to be executed.

 - Variable: overlay-arrow-string
     This variable holds the string to display as an arrow, or `nil' if
     the arrow feature is not in use.

 - Variable: overlay-arrow-position
     This variable holds a marker which indicates where to display the
     arrow.  It should point at the beginning of a line.  The arrow
     text is displayed at the beginning of that line, overlaying any
     text that would otherwise appear.  Since the arrow is usually
     short, and the line usually begins with indentation, normally
     nothing significant is overwritten.

     The overlay string is displayed only in the buffer which this
     marker points into.  Thus, only one buffer can have an overlay
     arrow at any given time.


File: elisp,  Node: Temporary Displays,  Next: Overlays,  Prev: Overlay Arrow,  Up: Display

Temporary Displays
==================

   Temporary displays are used by commands to put output into a buffer
and then present it to the user for perusal rather than for editing.
Many of the help commands use this feature.

 - Special Form: with-output-to-temp-buffer BUFFER-NAME FORMS...
     This function executes FORMS while arranging to insert any output
     they print into the buffer named BUFFER-NAME.  The buffer is then
     shown in some window for viewing, displayed but not selected.

     The string BUFFER-NAME specifies the temporary buffer, which need
     not already exist.  The argument must be a string, not a buffer.
     The buffer is erased initially (with no questions asked), and it is
     marked as unmodified after `with-output-to-temp-buffer' exits.

     `with-output-to-temp-buffer' binds `standard-output' to the
     temporary buffer, then it evaluates the forms in FORMS.  Output
     using the Lisp output functions within FORMS goes by default to
     that buffer (but screen display and messages in the echo area,
     although output in the general sense of the word, are not
     affected).  *Note Output Functions::.

     The value of the last form in FORMS is returned.

          ---------- Buffer: foo ----------
           This is the contents of foo.
          ---------- Buffer: foo ----------
          
          (with-output-to-temp-buffer "foo"
              (print 20)
              (print standard-output))
          => #<buffer foo>
          
          ---------- Buffer: foo ----------
          20
          
          #<buffer foo>
          
          ---------- Buffer: foo ----------

 - Variable: temp-buffer-show-function
     The value of this variable, if non-`nil', is called as a function
     to display a help buffer.  This variable is used by
     `with-output-to-temp-buffer'.

     In Emacs versions 18 and earlier, this variable was called
     `temp-buffer-show-hook'.

 - Function: momentary-string-display STRING POSITION &optional CHAR
          MESSAGE
     This function momentarily displays STRING in the current buffer at
     POSITION (which is a character offset from the beginning of the
     buffer).  The display remains until the next character is typed.

     If the next character the user types is CHAR, Emacs ignores it.
     Otherwise, that character remains buffered for subsequent use as
     input.  Thus, typing CHAR will simply remove the string from the
     display, while typing (say) `C-f' will remove the string from the
     display and later (presumably) move point forward.  The argument
     CHAR is a space by default.

     The return value of `momentary-string-display' is not meaningful.

     If MESSAGE is non-`nil', it is displayed in the echo area while
     STRING is displayed in the buffer.  If it is `nil', then
     instructions to type CHAR are displayed there, e.g., `Type RET to
     continue editing'.

     In this example, point is initially located at the beginning of the
     second line:

          ---------- Buffer: foo ----------
          This is the contents of foo.
          -!-Second line.
          ---------- Buffer: foo ----------
          
          (momentary-string-display
             "**** Important Message! ****" (point) ?\r
             "Type RET when done reading")
          => t
          
          ---------- Buffer: foo ----------
          This is the contents of foo.
          **** Important Message! ****Second line.
          ---------- Buffer: foo ----------
          
          ---------- Echo Area ----------
          Type RET when done reading
          ---------- Echo Area ----------

     This function works by actually changing the text in the buffer.
     As a result, if you later undo in this buffer, you will see the
     message come and go.


File: elisp,  Node: Overlays,  Next: Faces,  Prev: Temporary Displays,  Up: Display

Overlays
========

   You can use "overlays" to alter the appearance of a buffer's text on
the screen.  An overlay is an object which belongs to a particular
buffer, and has a specified beginning and end.  It also has properties
which you can examine and set; these affect the display of the text
within the overlay.

* Menu:

* Overlay Properties::	How to read and set properties.
			What properties do to the screen display.
* Managing Overlays::   Creating, moving, finding overlays.


File: elisp,  Node: Overlay Properties,  Next: Managing Overlays,  Up: Overlays

Overlay Properties
------------------

   Overlay properties are like text properties in some respects, but the
differences are more important than the similarities.  Text properties
are considered a part of the text; overlays are specifically considered
not to be part of the text.  Thus, copying text between various buffers
and strings preserves text properties, but does not try to preserve
overlays.  Changing a buffer's text properties marks the buffer as
modified, while moving an overlay or changing its properties does not.

`face'
     This property controls the font and color of text.  *Note Faces::,
     for more information.  This feature is temporary; in the future,
     we may replace it with other ways of specifying how to display
     text.

`mouse-face'
     This property is used instead of `face' when the mouse is within
     the range of the overlay.  This feature is not yet implemented,
     and may be temporary.  It is documented here because we are likely
     to implement it this way at least for a while.

`priority'
     This property's value (which should be a nonnegative number)
     determines the priority of the overlay.  The priority matters when
     two or more overlays cover the same character and both specify a
     face for display; the one whose `priority' value is larger takes
     priority over the other, and its face attributes override the face
     attributes of the lower priority overlay.

     Currently, all overlays take priority over text properties.  Please
     avoid using negative priority values, as we have not yet decided
     just what they should mean.

`window'
     If the `window' property is non-`nil', then the overlay applies
     only on that window.

`before-string'
     This property's value is a string to add to the display at the
     beginning of the overlay.  The string does not appear in the
     buffer in any sense--only on the screen.  This is not yet
     implemented, but will be.

`after-string'
     This property's value is a string to add to the display at the end
     of the overlay.  The string does not appear in the buffer in any
     sense--only on the screen.  This is not yet implemented, but will
     be.

`modification-hooks'
     This property's value is a list of functions to be called if any
     character within the overlay is changed or if text is inserted
     strictly within the overlay.  Each function receives two
     arguments: the beginning and end of the part of the buffer being
     modified.

`insert-in-front-hooks'
     This property's value is a list of functions to be called if text
     is inserted right at the beginning of the overlay.

`insert-behind-hooks'
     This property's value is a list of functions to be called if text
     is inserted right at the end of the overlay.

   These are the functions for reading and writing the properties of an
overlay.

 - Function: overlay-get OVERLAY PROP
     This function returns the value of property PROP recorded in
     OVERLAY.  If OVERLAY does not record any value for that property,
     then the value is `nil'.

 - Function: overlay-put OVERLAY PROP VALUE
     This function sets the value of property PROP recorded in OVERLAY
     to VALUE.  It returns VALUE.


File: elisp,  Node: Managing Overlays,  Prev: Overlay Properties,  Up: Overlays

Managing Overlays
-----------------

 - Function: make-overlay START END &optional BUFFER
     This function creates and returns an overlay which belongs to
     BUFFER and ranges from START to END.  Both START and END must
     specify buffer positions; they may be integers or markers.  If
     BUFFER is omitted, the overlay is created in the current buffer.

     The return value is the overlay itself.

 - Function: overlay-start OVERLAY
     This function returns the position at which OVERLAY starts.

 - Function: overlay-end OVERLAY
     This function returns the position at which OVERLAY ends.

 - Function: overlay-buffer OVERLAY
     This function returns the buffer that OVERLAY belongs to.

 - Function: delete-overlay OVERLAY
     This function deletes OVERLAY.  The overlay continues to exist as
     a Lisp object, but ceases to be part of the buffer it belonged to,
     and ceases to have any effect on display.

 - Function: move-overlay OVERLAY START END &optional BUFFER
     This function moves OVERLAY to BUFFER, and places its bounds at
     START and END.  Both arguments START and END must specify buffer
     positions; they may be integers or markers.  If BUFFER is omitted,
     the overlay stays in the same buffer.

     The return value is OVERLAY.

     This is the only valid way to change the endpoints of an overlay.
     Do not try modifying the markers in the overlay by hand, as that
     fails to update other vital data structures and can cause some
     overlays to be "lost".

 - Function: overlays-at POS
     This function returns a list of all the overlays that contain
     position POS in the current buffer.  The list is in no particular
     order.  An overlay contains position POS if it begins at or before
     POS, and ends after POS.

 - Function: next-overlay-change POS
     This function returns the buffer position of the next beginning or
     end of an overlay, after POS.


File: elisp,  Node: Faces,  Next: Blinking,  Prev: Overlays,  Up: Display

Faces
=====

   A "face" is a named collection of graphical attributes: font,
foreground color, background color and optional underlining.  Faces
control the display of text on the screen.

   Each face has its own "face id number" which distinguishes faces at
low levels within Emacs.  However, for most purposes, you can refer to
faces in Lisp programs by their names.

   Each face name is meaningful for all frames, and by default it has
the same meaning in all frames.  But you can arrange to give a
particular face name a special meaning in one frame if you wish.

   The face named `default' is used for ordinary text.  The face named
`modeline' is used for displaying the mode line and menu bars.  The
face named `region' is used for highlighting the region (in Transient
Mark mode only).

* Menu:

* Merging Faces::	How Emacs decides which face to use for a character.
* Face Functions::	How to define and examine faces.


File: elisp,  Node: Merging Faces,  Next: Face Functions,  Up: Faces

Merging Faces for Display
-------------------------

   Here are all the ways to specify which face to use for display of
text:

   * With defaults.  Each frame has a "default face", whose id number is
     zero, which is used for all text that doesn't somehow specify
     another face.

   * With text properties.  A character may have a `face' property; if
     so, it's displayed with that face.  If the character has a
     `mouse-face' property, that is used instead of the `face' property
     when the mouse is "near enough" to the character.  *Note Special
     Properties::.

   * With overlays.  An overlay may have `face' and `mouse-face'
     properties too; they apply to all the text covered by the overlay.

   * With special glyphs.  Each glyph can specify a particular face id
     number.  *Note Glyphs::.

   If these various sources together specify more than one face for a
particular character, Emacs merges the attributes of the various faces
specified.  The attributes of the faces of special glyphs come first;
then come attributes of faces from overlays, followed by those from text
properties, and last the default face.

   When multiple overlays cover one character, an overlay with higher
priority overrides those with lower priority.  *Note Overlays::.

   If an attribute such as the font or a color is not specified in any
of the above ways, the frame's own font or color is used.


File: elisp,  Node: Face Functions,  Prev: Merging Faces,  Up: Faces

Functions for Working with Faces
--------------------------------

   The attributes a face can specify include the font, the foreground
color, the background color, and underlining.  The face can also leave
these unspecified by giving the value `nil' for them.

   Here are the primitives for creating and changing faces.

 - Function: make-face NAME
     This function defines a new face named NAME, initially with all
     attributes `nil'.  It does nothing if there is already a face named
     NAME.

 - Function: face-list
     This function returns a list of all defined face names.

 - Function: copy-face OLD-FACE NEW-NAME &optional FRAME NEW-FRAME
     This function defines a new face named NEW-NAME which is a copy of
     the existing face named OLD-FACE.  If there is already a face
     named NEW-NAME, then it alters the face to have the same
     attributes as OLD-FACE.

     If the optional argument FRAME is given, this function applies
     only to that frame.  Otherwise it applies to each frame
     individually, copying attributes from OLD-FACE in that frame to
     NEW-FACE in the same frame.

     If the optional argument NEW-FRAME is given, then `copy-face'
     copies the attributes of OLD-FACE in FRAME to NEW-NAME in
     NEW-FRAME.

   You can modify the attributes of an existing face with the following
functions.  If you specify FRAME, they affect just that frame;
otherwise, they affect all frames as well as the defaults that apply to
new frames.

 - Function: set-face-foreground FACE COLOR &optional FRAME
 - Function: set-face-background FACE COLOR &optional FRAME
     These functions set the foreground (respectively, background)
     color of face FACE to COLOR.  The argument COLOR color should be a
     string, the name of a color.

 - Function: set-face-font FACE FONT &optional FRAME
     This function sets the font of face FACE.  The argument FONT
     should be a string.

 - Function: set-face-underline-p FACE UNDERLINE-P &optional FRAME
     This function sets the underline attribute of face FACE.

 - Function: invert-face FACE &optional FRAME
     Swap the foreground and background colors of face FACE.  If the
     face doesn't specify both foreground and background, then its
     foreground and background are set to the default background and
     foreground.

   These functions examine the attributes of a face.  If you don't
specify FRAME, they refer to the default data for new frames.

 - Function: face-foreground FACE &optional FRAME
 - Function: face-background FACE &optional FRAME
     These functions return the foreground (respectively, background)
     color of face FACE.  The argument COLOR color should be a string,
     the name of a color.

 - Function: face-font FACE &optional FRAME
     This function returns the name of the font of face FACE.

 - Function: face-underline-p FACE &optional FRAME
     This function returns the underline attribute of face FACE.

 - Function: face-id-number FACE
     This function returns the id number of face FACE.

 - Function: face-equal FACE1 FACE2 &optional FRAME
     This returns `t' if the faces FACE1 and FACE2 have the same
     attributes for display.

 - Function: face-differs-from-default-p FACE &optional FRAME
     This returns `t' if the face FACE displays differently from the
     default face.  A face is considered to be "the same" as the normal
     face if each attribute is either the same as that of the default
     face or `nil' (meaning to inherit from the default).

 - Variable: region-face
     This variable's value specifies the face id to use to display
     characters in the region when it is active (in Transient Mark mode
     only).  The face thus specified takes precedence over all faces
     that come from text properties and overlays, for characters in the
     region.  *Note The Mark::, for more information about Transient
     Mark mode.

     Normally, the value is the id number of the face named `region'.


File: elisp,  Node: Blinking,  Next: Inverse Video,  Prev: Faces,  Up: Display

Blinking
========

   This section describes the mechanism by which Emacs shows a matching
open parenthesis when the user inserts a close parenthesis.

 - Variable: blink-paren-function
     The value of this variable should be a function (of no arguments)
     to be called whenever a char with close parenthesis syntax is
     inserted.  The value of `blink-paren-function' may be `nil', in
     which case nothing is done.

          *Please note:* this variable was named `blink-paren-hook' in
          older Emacs versions, but since it is not called with the
          standard convention for hooks, it was renamed to
          `blink-paren-function' in version 19.

 - Variable: blink-matching-paren
     If this variable is `nil', then `blink-matching-open' does nothing.

 - Variable: blink-matching-paren-distance
     This variable specifies the maximum distance to scan for a matching
     parenthesis before giving up.

 - Function: blink-matching-open
     This function is the default value of `blink-paren-function'.  It
     assumes that point follows a character with close parenthesis
     syntax and moves the cursor momentarily to the matching opening
     character.  If that character is not already on the screen, then
     its context is shown by displaying it in the echo area.  To avoid
     long delays, this function does not search farther than
     `blink-matching-paren-distance' characters.

     Here is an example of calling this function explicitly.

          (defun interactive-blink-matching-open ()
            "Indicate momentarily the start of sexp before point."
            (interactive)

          (let ((blink-matching-paren-distance
                   (buffer-size))
                  (blink-matching-paren t))
              (blink-matching-open)))


File: elisp,  Node: Inverse Video,  Next: Usual Display,  Prev: Blinking,  Up: Display

Inverse Video
=============

 - User Option: inverse-video
     This variable controls whether Emacs uses inverse video for all
     text on the screen.  Non-`nil' means yes, `nil' means no.  The
     default is `nil'.

 - User Option: mode-line-inverse-video
     This variable controls the use of inverse video for mode lines.
     If it is non-`nil', then mode lines are displayed in inverse video
     (under X, this uses the face named `modeline', which you can set
     as you wish).  Otherwise, mode lines are displayed normally, just
     like text.  The default is `t'.


File: elisp,  Node: Usual Display,  Next: Display Tables,  Prev: Inverse Video,  Up: Display

Usual Display Conventions
=========================

   The usual display conventions define how to display each character
code.  You can override these conventions by setting up a display table
(*note Display Tables::.).  Here are the usual display conventions:

   * Character codes 32 through 126 map to glyph codes 32 through 126.
     Normally this means they display as themselves.

   * Character code 9 is a horizontal tab.  It displays as whitespace
     up to a position determined by `tab-width'.

   * Character code 10 is a newline.

   * All other codes in the range 0 through 31, and code 127, display
     in one of two ways according to the value of `ctl-arrow'.  If it
     is is non-`nil', these codes map to sequences of two glyphs, where
     the first glyph is the ASCII code for `^'.  Otherwise, these codes
     map just like the codes in the range 128 to 255.

   * Character codes 128 through 255 map to sequences of four glyphs,
     where the first glyph is the ASCII code for `\', and the others
     are digit characters representing the code in octal.

   The usual display conventions apply even when there is a display
table, for any character whose entry in the active display table is
`nil'.  Thus, when you set up a display table, you need only specify
the the characters for which you want unusual behavior.

   These variables affect the way certain characters are displayed on
the screen.  Since they change the number of columns the characters
occupy, they also affect the indentation functions.

 - User Option: ctl-arrow
     This buffer-local variable controls how control characters are
     displayed.  If it is non-`nil', they are displayed as a caret
     followed by the character: `^A'.  If it is `nil', they are
     displayed as a backslash followed by three octal digits: `\001'.

 - Variable: default-ctl-arrow
     The value of this variable is the default value for `ctl-arrow' in
     buffers that do not override it.  This is the same as executing the
     following expression:

          (default-value 'ctl-arrow)

     *Note Default Value::.

 - User Option: tab-width
     The value of this variable is the spacing between tab stops used
     for displaying tab characters in Emacs buffers.  The default is 8.
     Note that this feature is completely independent from the
     user-settable tab stops used by the command `tab-to-tab-stop'.
     *Note Indent Tabs::.


File: elisp,  Node: Display Tables,  Next: Beeping,  Prev: Usual Display,  Up: Display

Display Tables
==============

   You can use the "display table" feature to control how all 256
possible character codes display on the screen.  This is useful for
displaying European languages that have letters not in the ASCII
character set.

   The display table maps each character code into a sequence of
"glyphs", each glyph being an image that takes up one character
position on the screen.  You can also define how to display each glyph
on your terminal, using the "glyph table".

* Menu:

* Display Table Format::	What a display table consists of.
* Active Display Table::	How Emacs selects a display table to use.
* Glyphs::			How to define a glyph, and what glyphs mean.
* ISO Latin 1::			How to use display tables
				  to support the ISO Latin 1 character set.


File: elisp,  Node: Display Table Format,  Next: Active Display Table,  Up: Display Tables

Display Table Format
--------------------

   A display table is actually an array of 261 elements.

 - Function: make-display-table
     This creates and returns a display table.  The table initially has
     `nil' in all elements.

   The first 256 elements correspond to character codes; the Nth
element says how to display the character code N.  The value should be
`nil' or a vector of glyph values (*note Glyphs::.).  If an element is
`nil', it says to display that character according to the usual display
conventions (*note Usual Display::.).

   The remaining five elements of a display table serve special
purposes, and `nil' means use the default stated below.

256
     The glyph for the end of a truncated screen line (the default for
     this is `$').  *Note Glyphs::.

257
     The glyph for the end of a continued line (the default is `\').

258
     The glyph for indicating a character displayed as an octal
     character code (the default is `\').

259
     The glyph for indicating a control character (the default is `^').

260
     A vector of glyphs for indicating the presence of invisible lines
     (the default is `...').  *Note Selective Display::.

   For example, here is how to construct a display table that mimics the
effect of setting `ctl-arrow' to a non-`nil' value:

     (setq disptab (make-display-table))
     (let ((i 0))
       (while (< i 32)
         (or (= i ?\t) (= i ?\n)
             (aset disptab i (vector ?^ (+ i 64))))
         (setq i (1+ i)))
       (aset disptab 127 (vector ?^ ??)))


File: elisp,  Node: Active Display Table,  Next: Glyphs,  Prev: Display Table Format,  Up: Display Tables

Active Display Table
--------------------

   Each window can specify a display table, and so can each buffer.
When a buffer B is displayed in window W, display uses the display
table for window W if it has one; otherwise, the display table for
buffer B if it has one; otherwise, the standard display table if any.
The display table chosen is called the "active" display table.

 - Function: window-display-table WINDOW
     This function returns WINDOW's display table, or `nil' if WINDOW
     does not have an assigned display table.

 - Function: set-window-display-table WINDOW TABLE
     This function sets the display table of WINDOW to TABLE.  The
     argument TABLE should be either a display table or `nil'.

 - Variable: buffer-display-table
     This variable is automatically local in all buffers; its value in a
     particular buffer is the display table for that buffer, or `nil' if
     the buffer does not have any assigned display table.

 - Variable: standard-display-table
     This variable's value is the default display table, used when
     neither the current buffer nor the window displaying it has an
     assigned display table.  This variable is `nil' by default.

   If neither the selected window nor the current buffer has a display
table, and if the variable `standard-display-table' is `nil', then
Emacs uses the usual display conventions.  *Note Usual Display::.


File: elisp,  Node: Glyphs,  Next: ISO Latin 1,  Prev: Active Display Table,  Up: Display Tables

Glyphs
------

   A "glyph" is a generalization of a character; it stands for an image
that takes up a single character position on the screen.  Glyphs are
represented in Lisp as integers, just as characters are.

   The meaning of each integer, as a glyph, is defined by the glyph
table, which is the value of the variable `glyph-table'.

 - Variable: glyph-table
     The value of this variable is the current glyph table.  It should
     be a vector; the Gth element defines glyph code G.  If the value
     is `nil' instead of a vector, then all glyphs are simple (see
     below).

   Here are the possible types of elements in the glyph table:

INTEGER
     Define this glyph code as an alias for code INTEGER.  This is used
     with X Windows to specify a face code.

STRING
     Send the characters in STRING to the terminal to output this
     glyph.  This alternative is available on character terminals, but
     not under X.

`NIL'
     This glyph is simple.  On an ordinary terminal, the glyph code mod
     256 is the character to output.  With X, the glyph code mod 256 is
     character to output, and the glyph code divided by 256 specifies
     the "face id number" to use while outputting it.  *Note Faces::.

   If a glyph code is greater than or equal to the length of the glyph
table, that code is automatically simple.


File: elisp,  Node: ISO Latin 1,  Prev: Glyphs,  Up: Display Tables

ISO Latin 1
-----------

   If you have a terminal that can handle the entire ISO Latin 1
character set, you can arrange to use that character set as follows:

     (require 'disp-table)
     ;; Set char codes 160--255 to display as themselves.
     ;; (Codes 128--159 are the additional control characters.)
     (standard-display-8bit 160 255)

   If you are editing buffers written in the ISO Latin 1 character set
and your terminal doesn't handle anything but ASCII, you can load the
file `iso-ascii' to set up a display table which makes the other ISO
characters display as sequences of ASCII characters.  For example, the
character "o with umlaut" displays as `{"o}'.

   Some European countries have terminals that don't support ISO Latin 1
but do support the special characters for that country's language.  You
can define a display table to work one language using such terminals.
For an example, see `lisp/iso-swed.el', which handles certain Swedish
terminals.

   You can load the appropriate display table for your terminal
automatically by writing a terminal-specific Lisp file for the terminal
type.


File: elisp,  Node: Beeping,  Next: Window Systems,  Prev: Display Tables,  Up: Display

Beeping
=======

   You can make Emacs ring a bell (or blink the screen) to attract the
user's attention.  Be conservative about how often you do this; frequent
bells can become irritating.  Also be careful not to use beeping alone
when signaling an error is appropriate.  (*Note Errors::.)

 - Function: ding &optional DONT-TERMINATE
     This function beeps, or flashes the screen (see `visible-bell'
     below).  It also terminates any keyboard macro currently executing
     unless DONT-TERMINATE is non-`nil'.

 - Function: beep &optional DONT-TERMINATE
     This is a synonym for `ding'.

 - Variable: visible-bell
     This variable determines whether Emacs should flash the screen to
     represent a bell.  Non-`nil' means yes, `nil' means no.  This is
     effective only if the Termcap entry for the terminal in use has the
     visible bell flag (`vb') set.


File: elisp,  Node: Window Systems,  Prev: Beeping,  Up: Display

Window Systems
==============

   Emacs works with several window systems, most notably the X Window
Syste,.  Note that both Emacs and X use the term "window", but use it
differently.  An Emacs frame is a single window as far as X is
concerned; the individual Emacs windows are not known to X at all.

 - Variable: window-system
     This variable tells Lisp programs what window system Emacs is
     running under.  Its value should be a symbol such as `x' (if Emacs
     is running under X) or `nil' (if Emacs is running on an ordinary
     terminal).

 - Variable: window-system-version
     This variable distinguishes between different versions of the X
     Window System.  Its value is 10 or 11 when using X; `nil'
     otherwise.

 - Variable: window-setup-hook
     This variable is a normal hook which Emacs runs after loading your
     `.emacs' file and the default initialization file (if any), after
     loading terminal-specific Lisp code, and after running the hook
     `term-setup-hook'.

     This hook is used for internal purposes: setting up communication
     with the window system, and creating the initial window.  Users
     should not interfere with it.


File: elisp,  Node: Calendar,  Next: Tips,  Prev: Display,  Up: Top

Customizing the Calendar and Diary
**********************************

   There are many customizations that you can use to make the calendar
and diary suit your personal tastes.

* Menu:

* Calendar Customizing::   Defaults you can set.
* Holiday Customizing::    Defining your own holidays.
* Date Display Format::    Changing the format.
* Time Display Format::    Changing the format.
* Daylight Savings::       Changing the default.
* Diary Customizing::      Defaults you can set.
* Hebrew/Islamic Entries:: How to obtain them.
* Fancy Diary Display::    Enhancing the diary display, sorting entries.
* Included Diary Files::   Sharing a common diary file.
* Sexp Diary Entries::     Fancy things you can do.
* Appt Customizing::	   Customizing appointment reminders.


File: elisp,  Node: Calendar Customizing,  Next: Holiday Customizing,  Up: Calendar

Customizing the Calendar
========================

   If you set the variable `view-diary-entries-initially' to `t',
calling up the calendar automatically displays the diary entries for
the current date as well.  The diary dates appear only if the current
date is visible.  If you add both of the following lines to your
`.emacs' file:

     (setq view-diary-entries-initially t)
     (calendar)

they display both the calendar and diary windows whenever you start
Emacs.

   Similarly, if you set the variable
`view-calendar-holidays-initially' to `t', entering the calendar
automatically displays a list of holidays for the current three month
period.  The holiday list appears in a separate window.

   You can set the variable `mark-diary-entries-in-calendar' to `t' in
order to place a plus sign (`+') beside any dates with diary entries.
Whenever the calendar window is displayed or redisplayed, the diary
entries are automatically marked for holidays.

   Similarly, setting the variable `mark-holidays-in-calendar' to `t'
places an asterisk (`*') after all holiday dates visible in the
calendar window.

   There are many customizations that you can make with the hooks
provided.  For example, the variable `calendar-load-hook', whose
default value is `nil', is a normal hook run when the calendar package
is first loaded (before actually starting to display the calendar).

   The variable `initial-calendar-window-hook', whose default value is
`nil', is a normal hook run the first time the calendar window is
displayed.  The function is invoked only when you first enter Calendar
mode, not when you redisplay an existing Calendar window.  But if you
leave the calendar with the `q' command and reenter it, the hook runs
again.

   The variable `today-visible-calendar-hook', whose default value is
`nil', is a normal hook run after the calendar buffer has been prepared
with the calendar when the current date is visible in the window.  One
use of this hook is to replace today's date with asterisks; a function
`calendar-star-date' is included for this purpose.  In your `.emacs'
file, put:

     (setq today-visible-calendar-hook 'calendar-star-date)

Another standard hook function adds asterisks around the current date.
Here's how to use it:

     (setq today-visible-calendar-hook 'calendar-mark-today)

A corresponding variable, `today-invisible-calendar-hook', whose
default value is `nil', is a normal hook run after the calendar buffer
text has been prepared, if the current date is *not* visible in the
window.

