This is Info file elisp, produced by Makeinfo-1.55 from the input file
elisp.texi.

   This version is newer than the second printed edition of the GNU
Emacs Lisp Reference Manual.  It corresponds to Emacs Version 19.19.

   Published by the Free Software Foundation 675 Massachusetts Avenue
Cambridge, MA 02139 USA

   Copyright (C) 1990, 1991, 1992, 1993 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: elisp,  Node: Deleting Windows,  Next: Selecting Windows,  Prev: Splitting Windows,  Up: Windows

Deleting Windows
================

   A window remains visible on its frame unless you "delete" it by
calling certain functions that delete windows.  A deleted window cannot
appear on the screen, but continues to exist as a Lisp object until
there are no references to it.  There is no way to cancel the deletion
of a window aside from restoring a saved window configuration (*note
Window Configurations::.).  Restoring a window configuration also
deletes any windows that aren't part of that configuration.

   When you delete a window, the space it took up is given to one
adjacent sibling.  (In Emacs version 18, the space was divided evenly
among all the siblings.)

 - Function: window-live-p WINDOW
     This function returns `nil' if WINDOW is deleted, and `t'
     otherwise.

     *Warning:* erroneous information or fatal errors may result from
     using a deleted window as if it were live.

 - Command: delete-window &optional WINDOW
     This function removes WINDOW from the display.  If WINDOW is
     omitted, then the selected window is deleted.  An error is signaled
     if there is only one window when `delete-window' is called.

     This function returns `nil'.

     When `delete-window' is called interactively, WINDOW defaults to
     the selected window.

 - Command: delete-other-windows &optional WINDOW
     This function makes WINDOW the only window on its frame, by
     deleting all the other windows.  If WINDOW is omitted or `nil',
     then the selected window is used by default.

     The result is `nil'.

 - Command: delete-windows-on BUFFER &optional FRAME
     This function deletes all windows showing BUFFER.  If there are no
     windows showing BUFFER, then this function does nothing.  If all
     windows in some frame are showing BUFFER (including the case where
     there is only one window), then the frame reverts to having a
     single window showing the buffer chosen by `other-buffer'.  *Note
     The Buffer List::.

     If there are several windows showing different buffers, then those
     showing BUFFER are removed, and the others are expanded to fill the
     void.

     If FRAME is a frame, then `delete-windows-on' considers just the
     windows on FRAME.  If FRAME is `nil', all windows on all frames
     are considered.  If FRAME is `t', that stands for the selected
     frame.

     This function always returns `nil'.


File: elisp,  Node: Selecting Windows,  Next: Cyclic Window Ordering,  Prev: Deleting Windows,  Up: Windows

Selecting Windows
=================

   When a window is selected, the buffer in the window becomes the
current buffer, and the cursor will appear in it.

 - Function: selected-window
     This function returns the selected window.  This is the window in
     which the cursor appears and to which many commands apply.

 - Function: select-window WINDOW
     This function makes WINDOW the selected window.  The cursor then
     appears in WINDOW (on redisplay).  The buffer being displayed in
     WINDOW is immediately designated the current buffer.

     The return value is WINDOW.

          (setq w (next-window))
          (select-window w)
               => #<window 65 on windows.texi>

   The following functions choose one of the windows on the screen,
offering various criteria for the choice.

 - Function: get-lru-window &optional ALL-FRAMES
     This function returns the window least recently "used" (that is,
     selected).  The selected window is always the most recently used
     window.

     The selected window can be the least recently used window if it is
     the only window.  A newly created window becomes the least
     recently used window until it is selected.  The minibuffer window
     is not considered a candidate.

     The argument ALL-FRAMES controls which set of windows are
     considered.  If it is non-`nil', then all windows on all frames are
     considered.  Otherwise, only windows in the selected frame are
     considered.

 - Function: get-largest-window &optional ALL-FRAMES
     This function returns the window with the largest area (height
     times width).  If there are no side-by-side windows, then this is
     the window with the most lines.  The minibuffer window is not
     considered a candidate.

     If there are two windows of the same size, then the function
     returns the window which is first in the cyclic ordering of
     windows (see following section), starting from the selected window.

     The argument ALL-FRAMES controls which set of windows are
     considered.  If it is non-`nil', then all windows on all frames are
     considered.  Otherwise, only windows in the selected frame are
     considered.


File: elisp,  Node: Cyclic Window Ordering,  Next: Buffers and Windows,  Prev: Selecting Windows,  Up: Windows

Cycling Ordering of Windows
===========================

   When you use the command `C-x o' (`other-window') to select the next
window, it moves through all the windows on the screen in a specific
cyclic order.  For any given configuration of windows, this order never
varies.  It is called the "cyclic ordering of windows".

   This ordering generally goes from top to bottom, and from left to
right.  But it may go down first or go right first, depending on the
order in which the windows were split.

   If the first split was vertical (into windows one above each other),
and then the subwindows were split horizontally, then the ordering is
left to right in the top, and then left to right in the next lower part
of the frame, and so on.  If the first split was horizontal, the
ordering is top to bottom in the left part, and so on.  In general,
within each set of siblings at any level in the window tree, the order
is left to right, or top to bottom.

 - Function: next-window WINDOW &optional MINIBUF ALL-FRAMES
     This function returns the window following WINDOW in the cyclic
     ordering of windows.  This is the window which `C-x o' would select
     if done when WINDOW is selected.  If WINDOW is the only window
     visible, then this function returns WINDOW.

     The value of the argument MINIBUF determines whether the
     minibuffer is included in the window order.  Normally, when
     MINIBUF is `nil', the minibuffer is included if it is currently
     active; this is the behavior of `C-x o'.

     If MINIBUF is `t', then the cyclic ordering includes the
     minibuffer window even if it is not active.

     If MINIBUF is neither `t' nor `nil', then the minibuffer window is
     not included even if it is active.  (The minibuffer window is
     active while the minibuffer is in use.  *Note Minibuffers::.)

     When there are multiple frames, this functions normally cycles
     through all the windows in the selected frame, plus the minibuffer
     used by the selected frame even if it lies in some other frame.

     If ALL-FRAMES is `t', then it cycles through all the windows in
     all the frames that currently exist.

     If ALL-FRAMES is neither `t' nor `nil', then it cycles through
     precisely the windows in the selected frame, excluding the
     minibuffer in use if it lies in some other frame.

     This example shows two windows, which both happen to be displaying
     the same buffer:

          (selected-window)
               => #<window 56 on windows.texi>
          (next-window (selected-window))
               => #<window 52 on windows.texi>
          (next-window (next-window (selected-window)))
               => #<window 56 on windows.texi>

 - Function: previous-window WINDOW &optional MINIBUF ALL-FRAMES
     This function returns the window preceding WINDOW in the cyclic
     ordering of windows.  The other arguments affect which windows are
     included in the cycle, as in `next-window'.

 - Command: other-window COUNT
     This function selects the COUNTth next window in the cyclic order.
     If count is negative, then it selects the -COUNTth preceding
     window.  It returns `nil'.

     In an interactive call, COUNT is the numeric prefix argument.

 - Function: walk-windows PROC &optional MINIBUF ALL-FRAMES
     This function cycles through all visible windows, calling `proc'
     once for each window with the window as its sole argument.

     The optional argument MINIBUF says whether to include minibuffer
     windows.  A value of `t' means count the minibuffer window even if
     not active.  A value of `nil' means count it only if active.  Any
     other value means not to count the minibuffer even if it is active.

     If the optional third argument ALL-FRAMES is `t', that means
     include all windows in all frames.  If ALL-FRAMES is `nil', it
     means to cycle within the selected frame, but include the
     minibuffer window (if MINIBUF says so) that that frame uses, even
     if it is on another frame.  If ALL-FRAMES is neither `nil' nor `t',
     `walk-windows' sticks strictly to the selected frame.


File: elisp,  Node: Buffers and Windows,  Next: Displaying Buffers,  Prev: Cyclic Window Ordering,  Up: Windows

Buffers and Windows
===================

   This section describes low-level functions to examine windows or to
show buffers in windows in a precisely controlled fashion.  *Note
Displaying Buffers::, for related functions that find a window to use
and specify a buffer for it.  The functions described there are easier
to use than these, but they employ heuristics in choosing or creating a
window; use these functions when you need complete control.

 - Function: set-window-buffer WINDOW BUFFER-OR-NAME
     This function makes WINDOW display BUFFER-OR-NAME as its contents.
     It returns `nil'.

          (set-window-buffer (selected-window) "foo")
               => nil

 - Function: window-buffer &optional WINDOW
     This function returns the buffer that WINDOW is displaying.  If
     WINDOW is omitted, then this function returns the buffer for the
     selected window.

          (window-buffer)
               => #<buffer windows.texi>

 - Function: get-buffer-window BUFFER-OR-NAME &optional ALL-FRAMES
     This function returns a window currently displaying
     BUFFER-OR-NAME, or `nil' if there is none.  If there are several
     such windows, then the function returns the first one in the
     cyclic ordering of windows, starting from the selected window.
     *Note Cyclic Window Ordering::.

     The argument ALL-FRAMES controls which set of windows are
     considered.
        * If it is `nil', then windows on the selected frame are
          considered.

        * If it is a frame, then windows on that frame are considered.

        * If it is `t', then windows on all visible frames are
          considered.

        * If it is some other non-`nil' value, then all windows on all
          frames are considered.

 - Command: replace-buffer-in-windows BUFFER
     This function replaces BUFFER with some other buffer in all
     windows displaying it.  The other buffer used is chosen with
     `other-buffer'.  In the usual applications of this function, you
     don't care which other buffer is used; you just want to make sure
     that BUFFER is no longer displayed.

     This function returns `nil'.


File: elisp,  Node: Displaying Buffers,  Next: Choosing Window,  Prev: Buffers and Windows,  Up: Windows

Displaying Buffers in Windows
=============================

   In this section we describe convenient functions that choose a window
automatically and use it to display a specified buffer.  These functions
can also split an existing window in certain circumstances.  We also
describe variables that parameterize the heuristics used for choosing a
window.  *Note Buffers and Windows::, for low-level functions that give
you more precise control.

   Do not use the functions in this section in order to make a buffer
current so that a Lisp program can access or modify it; they are too
drastic for that purpose, since they change the display of buffers in
windows, which is gratuitous and will surprise the user.  Instead, use
`set-buffer' (*note Current Buffer::.) and `save-excursion' (*note
Excursions::.), which designate buffers as current for programmed
access without affecting the display of buffers in windows.

 - Command: switch-to-buffer BUFFER-OR-NAME &optional NORECORD
     This function makes BUFFER-OR-NAME the current buffer, and also
     displays the buffer in the selected window.  This means that a
     human can see the buffer and subsequent keyboard commands will
     apply to it.  Contrast this with `set-buffer', which makes
     BUFFER-OR-NAME the current buffer but does not display it in the
     selected window.  *Note Current Buffer::.

     If BUFFER-OR-NAME does not identify an existing buffer, then a new
     buffer by that name is created.

     Normally the specified buffer is put at the front of the buffer
     list.  This affects the operation of `other-buffer'.  However, if
     NORECORD is non-`nil', this is not done.  *Note The Buffer List::.

     The `switch-to-buffer' function is often used interactively, as
     the binding of `C-x b'.  It is also used frequently in programs.
     It always returns `nil'.

 - Command: switch-to-buffer-other-window BUFFER-OR-NAME
     This function makes BUFFER-OR-NAME the current buffer and displays
     it in a window not currently selected.  It then selects that
     window.  The handling of the buffer is the same as in
     `switch-to-buffer'.

     The previously selected window is absolutely never used to display
     the buffer.  If it is the only window, then it is split to make a
     distinct window for this purpose.  If the selected window is
     already displaying the buffer, then it continues to do so, but
     another window is nonetheless found to display it in as well.

 - Function: pop-to-buffer BUFFER-OR-NAME &optional OTHER-WINDOW
     This function makes BUFFER-OR-NAME the current buffer and switches
     to it in some window, preferably not the window previously
     selected.  The "popped-to" window becomes the selected window.

     If the variable `pop-up-frames' is non-`nil', `pop-to-buffer'
     creates a new frame to display the buffer in.  Otherwise, if the
     variable `pop-up-windows' is non-`nil', windows may be split to
     create a new window that is different from the original window.
     For details, see *Note Choosing Window::.

     If OTHER-WINDOW is non-`nil', `pop-to-buffer' finds or creates
     another window even if BUFFER-OR-NAME is already visible in the
     selected window.  Thus BUFFER-OR-NAME could end up displayed in
     two windows.  On the other hand, if BUFFER-OR-NAME is already
     displayed in the selected window and OTHER-WINDOW is `nil', then
     the selected window is considered sufficient display for
     BUFFER-OR-NAME, so that nothing needs to be done.

     If BUFFER-OR-NAME is a string that does not name an existing
     buffer, a buffer by that name is created.

     An example use of this function is found at the end of *Note
     Filter Functions::.


File: elisp,  Node: Choosing Window,  Next: Window Point,  Prev: Displaying Buffers,  Up: Windows

Choosing a Window
=================

   This section describes the basic facility which chooses a window to
display a buffer in--`display-buffer'.  All the higher-level functions
and commands use this subroutine.  Here we describe how to use
`display-buffer' and how to customize it.

 - Function: display-buffer BUFFER-OR-NAME &optional NOT-THIS-WINDOW
     This function makes BUFFER-OR-NAME appear in some window, like
     `pop-to-buffer', but it does not select that window and does not
     make the buffer current.  The identity of the selected window is
     unaltered by this function.

     If NOT-THIS-WINDOW is non-`nil', it means that the specified
     buffer should be displayed in a window other than the selected
     one, even if it is already on display in the selected window.
     This can cause the buffer to appear in two windows at once.
     Otherwise, if BUFFER-OR-NAME is already being displayed in any
     window, that is good enough, so this function does nothing.

     `display-buffer' returns the window chosen to display
     BUFFER-OR-NAME.

     Precisely how `display-buffer' finds or creates a window depends on
     the variables described below.

   A window can be marked as "dedicated" to its buffer.  Then
`display-buffer' does not try to use that window.

 - Function: window-dedicated-p WINDOW
     This function returns `t' if WINDOW is marked as dedicated;
     otherwise `nil'.

 - Function: set-window-dedicated-p WINDOW FLAG
     This function marks WINDOW as dedicated if FLAGS is non-`nil', and
     nondedicated otherwise.

 - User Option: pop-up-windows
     This variable controls whether `display-buffer' makes new windows.
     If it is non-`nil' and there is only one window, then that window
     is split.  If it is `nil', then `display-buffer' does not split
     the single window, but rather replaces its buffer.

 - User Option: split-height-threshold
     This variable determines when `display-buffer' may split a window,
     if there are multiple windows.  `display-buffer' splits the
     largest window if it has at least this many lines.

     If there is only one window, it is split regardless of this value,
     provided `pop-up-windows' is non-`nil'.

 - User Option: pop-up-frames
     This variable controls whether `display-buffer' makes new frames.
     If it is non-`nil', `display-buffer' makes a new frame.  If it is
     `nil', then `display-buffer' either splits a window or reuses one.

     If this is non-`nil', the variables `pop-up-windows' and
     `split-height-threshold' do not matter.

     *Note Frames::, for more information.

 - Variable: pop-up-frame-function
     This variable specifies how to make a new frame if `pop-up-frame'
     is non-`nil'.

     Its value should be a function of no arguments.  When
     `display-buffer' makes a new frame, it does so by calling that
     function, which should return a frame.  The default value of the
     variable is a function which creates a frame using parameters from
     `pop-up-frame-alist'.

 - Variable: pop-up-frame-alist
     This variable holds an alist specifying frame parameters used when
     `display-buffer' makes a new frame.  *Note Frame Parameters::, for
     more information about frame parameters.

 - Variable: display-buffer-function
     This variable is the most flexible way to customize the behavior of
     `display-buffer'.  If it is non-`nil', it should be a function
     that `display-buffer' calls to do the work.  The function should
     accept two arguments, the same two arguments that `display-buffer'
     received.  It should choose or create a window, display the
     specified buffer, and then return the window.

     This hook takes precedence over all the other options and hooks
     described above.


File: elisp,  Node: Window Point,  Next: Window Start,  Prev: Choosing Window,  Up: Windows

Window Point
============

   Each window has its own value of point, independent of the value of
point in other windows displaying the same buffer.  This makes it useful
to have multiple windows showing one buffer.

   * The window point is established when a window is first created; it
     is initialized from the buffer's point, or from the window point
     of another window opened on the buffer if such a window exists.

   * Selecting a window sets the value of point in its buffer to the
     window's value of point.  Conversely, deselecting a window sets
     the window's value of point from that of the buffer.  Thus, when
     you switch between windows that display a given buffer, the point
     value for the selected window is in effect in the buffer, while
     the point values for the other windows are stored in those windows.

   * As long as the selected window displays the current buffer, the
     window's point and the buffer's point always move together; they
     remain equal.

   * *Note Positions::, for more details on positions.

   As far as the user is concerned, point is where the cursor is, and
when the user switches to another buffer, the cursor jumps to the
position of point in that buffer.

 - Function: window-point WINDOW
     This function returns the current position of point in WINDOW.
     For a nonselected window, this is the value point would have (in
     that window's buffer) if that window were selected.

     When WINDOW is the selected window and its buffer is also the
     current buffer, the value returned is the same as point in that
     buffer.

     Strictly speaking, it would be more correct to return the
     "top-level" value of point, outside of any `save-excursion' forms.
     But that value is hard to find.

 - Function: set-window-point WINDOW POSITION
     This function positions point in WINDOW at position POSITION in
     WINDOW's buffer.


File: elisp,  Node: Window Start,  Next: Vertical Scrolling,  Prev: Window Point,  Up: Windows

The Window Start Position
=========================

   Each window contains a marker used to keep track of a buffer position
which specifies where in the buffer display should start.  This position
is called the "display-start" position of the window (or just the
"start").  The character after this position is the one that appears at
the upper left corner of the window.  It is usually, but not
inevitably, at the beginning of a text line.

 - Function: window-start &optional WINDOW
     This function returns the display-start position of window WINDOW.
     If WINDOW is `nil', the selected window is used.

          (window-start)
               => 7058

     For a more complicated example of use, see the description of
     `count-lines' in *Note Text Lines::.

 - Function: window-end &optional WINDOW
     This function returns the position of the end of the display in
     window WINDOW.  If WINDOW is `nil', the selected window is used.

 - Function: set-window-start WINDOW POSITION &optional NOFORCE
     This function sets the display-start position of WINDOW to
     POSITION in WINDOW's buffer.

     The display routines insist that the position of point be visible
     when a buffer is displayed.  Normally, they change the
     display-start position (that is, scroll the window) whenever
     necessary to make point visible.  However, if you specify the
     start position with this function with `nil' for NOFORCE, it means
     you want display to start at POSITION even if that would put the
     location of point off the screen.  What the display routines do in
     this case is move point instead, to the left margin on the middle
     line in the window.

     For example, if point is 1 and you attempt to set the start of the
     window to 2, then the position of point would be "above" the top
     of the window.  The display routines would automatically move
     point if it is still 1 when redisplay occurs.  Here is an example:

          ;; Here is what `foo' looks like before executing
          ;;   the `set-window-start' expression.
          
          ---------- Buffer: foo ----------
          -!-This is the contents of buffer foo.
          2
          3
          4
          5
          6
          ---------- Buffer: foo ----------
          
          (set-window-start
           (selected-window)
           (1+ (window-start)))
          
          ;; Here is what `foo' looks like after executing
          ;;   the `set-window-start' expression.
          
          ---------- Buffer: foo ----------
          his is the contents of buffer foo.
          2
          3
          -!-4
          5
          6
          ---------- Buffer: foo ----------
          
               => 2

     However, when NOFORCE is non-`nil', `set-window-start' does
     nothing if the specified start position would make point invisible.

     This function returns POSITION, regardless of whether the NOFORCE
     option caused that position to be overruled.

 - Function: pos-visible-in-window-p &optional POSITION WINDOW
     This function returns `t' if POSITION is within the range of text
     currently visible on the screen in WINDOW.  It returns `nil' if
     POSITION is scrolled vertically out of view.  The argument
     POSITION defaults to the current position of point; WINDOW, to the
     selected window.  Here is an example:

          (or
          (pos-visible-in-window-p
           (point) (selected-window))
              (recenter 0))

     The `pos-visible-in-window-p' function considers only vertical
     scrolling.  It returns `t' if POSITION is out of view only because
     WINDOW has been scrolled horizontally.  *Note Horizontal
     Scrolling::.


File: elisp,  Node: Vertical Scrolling,  Next: Horizontal Scrolling,  Prev: Window Start,  Up: Windows

Vertical Scrolling
==================

   Vertical scrolling means moving the text up or down in a window.  It
works by changing the value of the window's display-start location.  It
may also change the value of `window-point' to keep it on the screen.

   In the commands `scroll-up' and `scroll-down', the directions "up"
and "down" refer to the motion of the text in the buffer at which you
are looking through the window.  Imagine that the text is written on a
long roll of paper and that the scrolling commands move the paper up
and down.  Thus, if you are looking at text in the middle of a buffer
and repeatedly call `scroll-down', you will eventually see the
beginning of the buffer.

   Some people have urged that the opposite convention be used: they
imagine that the window moves over text that remains in place.  Then
"down" commands would take you to the end of the buffer.  This view is
more consistent with the actual relationship between windows and the
text in the buffer, but it is less like what the user sees.  The
position of a window on the terminal does not move, and short scrolling
commands clearly move the text up or down on the screen.  We have chosen
names that fit the user's point of view.

   The scrolling functions (aside from `scroll-other-window') will have
unpredictable results if the current buffer is different from the
buffer that is displayed in the selected window.  *Note Current
Buffer::.

 - Command: scroll-up &optional COUNT
     This function scrolls the text in the selected window upward COUNT
     lines.  If COUNT is negative, scrolling is actually downward.

     If COUNT is `nil' (or omitted), then the length of scroll is
     `next-screen-context-lines' lines less than the usable height of
     the window (not counting its mode line).

     `scroll-up' returns `nil'.

 - Command: scroll-down &optional COUNT
     This function scrolls the text in the selected window downward
     COUNT lines.  If COUNT is negative, scrolling is actually upward.

     If COUNT is omitted or `nil', then the length of the scroll is
     `next-screen-context-lines' lines less than the usable height of
     the window.

     `scroll-down' returns `nil'.

 - Command: scroll-other-window &optional COUNT
     This function scrolls the text in another window upward COUNT
     lines.  Negative values of COUNT, or `nil', are handled as in
     `scroll-up'.

     The window that is scrolled is normally the one following the
     selected window in the cyclic ordering of windows--the window that
     `next-window' would return.  *Note Cyclic Window Ordering::.

     If the selected window is the minibuffer, the next window is
     normally the one at the top left corner.  However, you can specify
     the window to scroll by binding the variable
     `minibuffer-scroll-window'.  This variable has no effect when any
     other window is selected.  *Note Minibuffer Misc::.

     When the minibuffer is active, it is the next window if the
     selected window is the one at the bottom right corner.  In this
     case, `scroll-other-window' attempts to scroll the minibuffer.  If
     the minibuffer contains just one line, it has nowhere to scroll
     to, so the line reappears after the echo area momentarily displays
     the message "Beginning of buffer".

 - Variable: other-window-scroll-buffer
     If this variable is non-`nil', it tells `scroll-other-window'
     which buffer to scroll.

 - User Option: scroll-step
     This variable controls how scrolling is done automatically when
     point moves off the screen.  If the value is zero, then the text
     is scrolled so that point is centered vertically in the window.
     If the value is a positive integer N, then if it is possible to
     bring point back on screen by scrolling N lines in either
     direction, that is done; otherwise, point is centered vertically
     as usual.  The default value is zero.

 - User Option: next-screen-context-lines
     The value of this variable is the number of lines of continuity to
     retain when scrolling by full screens.  For example, when
     `scroll-up' executes, this many lines that were visible at the
     bottom of the window move to the top of the window.  The default
     value is `2'.

 - Command: recenter &optional COUNT
     This function scrolls the selected window to put the text where
     point is located at a specified vertical position within the
     window.

     If COUNT is a nonnegative number, it puts the line containing
     point COUNT lines down from the top of the window.  If COUNT is a
     negative number, then it counts upward from the bottom of the
     window, so that -1 stands for the last usable line in the window.
     If COUNT is a non-`nil' list, then it stands for the line in the
     middle of the window.

     If COUNT is `nil', then it puts the line containing point in the
     middle of the window, then clears and redisplays the entire
     selected frame.

     When `recenter' is called interactively, Emacs sets COUNT to the
     raw prefix argument.  Thus, typing `C-u' as the prefix sets the
     COUNT to a non-`nil' list, while typing `C-u 4' sets COUNT to 4,
     which positions the current line four lines from the top.

     Typing `C-u 0 C-l' positions the current line at the top of the
     window.  This action is so handy that some people bind the command
     to a function key.  For example,

          (defun line-to-top-of-window ()
            "Scroll current line to top of window.
          Replaces three keystroke sequence C-u 0 C-l."
            (interactive)
            (recenter 0))
          
          (global-set-key "\C-cl" 'line-to-top-of-window)


File: elisp,  Node: Horizontal Scrolling,  Next: Size of Window,  Prev: Vertical Scrolling,  Up: Windows

Horizontal Scrolling
====================

   Because we read English first from top to bottom and second from left
to right, horizontal scrolling is not like vertical scrolling.  Vertical
scrolling involves selection of a contiguous portion of text to display.
Horizontal scrolling causes part of each line to go off screen.  The
amount of horizontal scrolling is therefore specified as a number of
columns rather than as a position in the buffer.  It has nothing to do
with the display-start position returned by `window-start'.

   Usually, no horizontal scrolling is in effect; then the leftmost
column is at the left edge of the window.  In this state, scrolling to
the right is meaningless, since there is no data to the left of the
screen to be revealed by it, so it is not allowed.  Scrolling to the
left is allowed; it causes the first columns of text to go off the edge
of the window and can reveal additional columns on the right that were
truncated before.  Once a window has a nonzero amount of leftward
horizontal scrolling, you can scroll it back to the right, but only so
far as to reduce the net horizontal scroll to zero.  There is no limit
to how far left you can scroll, but eventually all the text will
disappear off the left edge.

 - Command: scroll-left COUNT
     This function scrolls the selected window COUNT columns to the
     left (or to the right if COUNT is negative).  The return value is
     the total amount of leftward horizontal scrolling in effect after
     the change--just like the value returned by `window-hscroll'.

 - Command: scroll-right COUNT
     This function scrolls the selected window COUNT columns to the
     right  (or to the left if COUNT is negative).  The return value is
     the total amount of leftward horizontal scrolling in effect after
     the change--just like the value returned by `window-hscroll'.

     Once you scroll a window as far right as it can go, back to its
     normal position where the total leftward scrolling is zero,
     attempts to scroll any farther have no effect.

 - Function: window-hscroll &optional WINDOW
     This function returns the total leftward horizontal scrolling of
     WINDOW--the number of columns by which the text in WINDOW is
     scrolled left past the left margin.

     The value is never negative.  It is zero when no horizontal
     scrolling has been done in WINDOW (which is usually the case).

     If WINDOW is `nil', the selected window is used.

          (window-hscroll)
               => 0
          (scroll-left 5)
               => 5
          (window-hscroll)
               => 5

 - Function: set-window-hscroll WINDOW COLUMNS
     This function sets the number of columns from the left margin that
     WINDOW is scrolled to the value of COLUMNS.  The argument COLUMNS
     should be zero or positive; if not, it is taken as zero.

     The value returned is COLUMNS.

          (set-window-hscroll (selected-window) 10)
               => 10

   Here is how you can determine whether a given position POSITION is
off the screen due to horizontal scrolling:

     (save-excursion
       (goto-char POSITION)
       (and
        (>= (- (current-column) (window-hscroll WINDOW)) 0)
        (< (- (current-column) (window-hscroll WINDOW))
           (window-width WINDOW))))


File: elisp,  Node: Size of Window,  Next: Resizing Windows,  Prev: Horizontal Scrolling,  Up: Windows

The Size of a Window
====================

   An Emacs window is rectangular, and its size information consists of
the height (the number of lines) and the width (the number of character
positions in each line).  The mode line is included in the height.  For
a window that does not abut the right hand edge of the screen, the
column of `|' characters that separates it from the window on the right
is included in the width.

   The following three functions return size information about a window:

 - Function: window-height &optional WINDOW
     This function returns the number of lines in WINDOW, including its
     mode line.  If WINDOW fills its entire frame, this is one less
     than the value of `frame-height' on that frame (since the last line
     is always reserved for the minibuffer).

     If WINDOW is `nil', the function uses the selected window.

          (window-height)
               => 23
          (split-window-vertically)
               => #<window 4 on windows.texi>
          (window-height)
               => 11

 - Function: window-width &optional WINDOW
     This function returns the number of columns in WINDOW.  If WINDOW
     fills its entire frame, this is the same as the value of
     `frame-width' on that frame.

     If WINDOW is `nil', the function uses the selected window.

          (window-width)
               => 80

 - Function: window-edges &optional WINDOW
     This function returns a list of the edge coordinates of WINDOW.
     If WINDOW is `nil', the selected window is used.

     The order of the list is `(LEFT TOP RIGHT BOTTOM)', all elements
     relative to 0, 0 at the top left corner of the frame.  The element
     RIGHT of the value is one more than the rightmost column used by
     WINDOW, and BOTTOM is one more than the bottommost row used by
     WINDOW and its mode-line.

     Here is the result obtained on a typical 24-line terminal with
     just one window:

          (window-edges (selected-window))
               => (0 0 80 23)

     If WINDOW is at the upper left corner of its frame, RIGHT and
     BOTTOM are the same as the values returned by `(window-width)' and
     `(window-height)' respectively, and TOP and BOTTOM are zero.  For
     example, the edges of the following window are `0 0 5 8'.
     Assuming that the frame has more than 8 columns, the last column
     of the window (column 7) holds a border rather than text.  The
     last row (row 4) holds the mode line, shown here with `xxxxxxxxx'.

                     0
                     _______
                  0 |       |
                    |       |
                    |       |
                    |       |
                    xxxxxxxxx  4
          
                            7

     When there are side-by-side windows, any window not at the right
     edge of its frame has a border in its last column.  This border
     counts as one column in the width of the window.  A window never
     includes a border on its left, since the border there belongs to
     the window to the left.

     In the following example, let's imagine that the frame is 7
     columns wide.  Then the edges of the left window are `0 0 4 3' and
     the edges of the right window are `4 0 7 3'.

                     ___ ___
                    |   |   |
                    |   |   |
                    xxxxxxxxx
          
                     0  34  7


File: elisp,  Node: Resizing Windows,  Next: Coordinates and Windows,  Prev: Size of Window,  Up: Windows

Changing the Size of a Window
=============================

   The window size functions fall into two classes: high-level commands
that change the size of windows and low-level functions that access
window size.  Emacs does not permit overlapping windows or gaps between
windows, so resizing one window affects other windows.

 - Command: enlarge-window SIZE &optional HORIZONTAL
     This function makes the selected window SIZE lines bigger,
     stealing lines from neighboring windows.  It takes the lines from
     one window at a time until that window is used up, then takes from
     another.  If a window from which lines are stolen shrinks below
     `window-min-height' lines, then that window disappears.

     If HORIZONTAL is non-`nil', then this function makes WINDOW wider
     by SIZE columns, stealing columns instead of lines.  If a window
     from which columns are stolen shrinks below `window-min-width'
     columns, then that window disappears.

     If the window's frame is smaller than SIZE lines (or columns),
     then the function makes the window occupy the entire height (or
     width) of the frame.

     If SIZE is negative, this function shrinks the window by -SIZE
     lines.  If it becomes shorter than `window-min-height', it
     disappears.

     `enlarge-window' returns `nil'.

 - Command: enlarge-window-horizontally COLUMNS
     This function makes the selected window COLUMNS wider.  It could
     be defined as follows:

          (defun enlarge-window-horizontally (columns)
            (enlarge-window columns t))

 - Command: shrink-window SIZE &optional HORIZONTAL
     This function is like `enlarge-window' but negates the argument
     SIZE, making the selected window smaller by giving lines (or
     columns) to the other windows.  If the window shrinks below
     `window-min-height' or `window-min-width', then it disappears.

     If SIZE is negative, the window is enlarged by -SIZE lines.

 - Command: shrink-window-horizontally COLUMNS
     This function makes the selected window COLUMNS narrower.  It
     could be defined as follows:

          (defun shrink-window-horizontally (columns)
            (shrink-window columns t))

   The following two variables constrain the window size changing
functions to a minimum height and width.

 - User Option: window-min-height
     The value of this variable determines how short a window may become
     before it disappears.  A window disappears when it becomes smaller
     than `window-min-height', and no window may be created that is
     smaller.  The absolute minimum height is two (allowing one line
     for the mode line, and one line for the buffer display).  Actions
     which change window sizes reset this variable to two if it is less
     than two.  The default value is 4.

 - User Option: window-min-width
     The value of this variable determines how narrow a window may
     become before it disappears.  A window disappears when it becomes
     narrower than `window-min-width', and no window may be created
     that is narrower.  The absolute minimum width is one; any value
     below that is ignored.  The default value is 10.


File: elisp,  Node: Coordinates and Windows,  Next: Window Configurations,  Prev: Resizing Windows,  Up: Windows

Coordinates and Windows
=======================

   This section describes how to compare screen coordinates with
windows.

 - Function: window-at X Y &optional FRAME
     This function returns the window containing the specified cursor
     position in the frame FRAME.  The coordinates X and Y are measured
     in characters and count from the top left corner of the screen or
     frame.

     If you omit FRAME, the selected frame is used.

 - Function: coordinates-in-window-p COORDINATES WINDOW
     This function checks whether a particular frame position falls
     within the window WINDOW.

     The argument COORDINATES is a cons cell of this form:

          (X . Y)

     The coordinates X and Y are measured in characters, and count from
     the top left corner of the screen or frame.

     The value of `coordinates-in-window-p' is non-`nil' if the
     coordinates are inside WINDOW.  The value also indicates what part
     of the window the position is in, as follows:

    `(RELX . RELY)'
          The coordinates are inside WINDOW.  The numbers RELX and RELY
          are the equivalent window-relative coordinates for the
          specified position, counting from 0 at the top left corner of
          the window.

    `mode-line'
          The coordinates are in the mode line of WINDOW.

    `vertical-split'
          The coordinates are in the vertical line between WINDOW and
          its neighbor to the right.

    `nil'
          The coordinates are not in any sense within WINDOW.

     The function `coordinates-in-window-p' does not require a frame as
     argument because it always uses the frame that window WINDOW is on.


File: elisp,  Node: Window Configurations,  Prev: Coordinates and Windows,  Up: Windows

Window Configurations
=====================

   A "window configuration" records the entire layout of a frame--all
windows, their sizes, which buffers they contain, what part of each
buffer is displayed, and the values of point and the mark.  You can
bring back an entire previous layout by restoring a window
configuration previously saved.

   If you want to record all frames instead of just one, use a frame
configuration instead of a window configuration.  *Note Frame
Configurations::.

 - Function: current-window-configuration
     This function returns a new object representing Emacs's current
     window configuration, namely the number of windows, their sizes
     and current buffers, which window is the selected window, and for
     each window the displayed buffer, the display-start position, and
     the positions of point and the mark.  An exception is made for
     point in the current buffer, whose value is not saved.

 - Function: set-window-configuration CONFIGURATION
     This function restores the configuration of Emacs's windows and
     buffers to the state specified by CONFIGURATION.  The argument
     CONFIGURATION must be a value that was previously returned by
     `current-window-configuration'.

     Here is a way of using this function to get the same effect as
     `save-window-excursion':

          (let ((config (current-window-configuration)))
            (unwind-protect
                (progn (split-window-vertically nil)
                       ...)
              (set-window-configuration config)))

 - Special Form: save-window-excursion FORMS...
     This special form executes FORMS in sequence, preserving window
     sizes and contents, including the value of point and the portion
     of the buffer which is visible.  It also preserves the choice of
     selected window.  However, it does not restore the value of point
     in the current buffer; use `save-excursion' for that.

     The return value is the value of the final form in FORMS.  For
     example:

          (split-window)
               => #<window 25 on control.texi>
          (setq w (selected-window))
               => #<window 19 on control.texi>
          (save-window-excursion
            (delete-other-windows w)
            (switch-to-buffer "foo")
            'do-something)
               => do-something
               ;; The screen is now split again.

 - Function: window-configuration-p OBJECT
     This function returns `t' if OBJECT is a window configuration.

   Primitives to look inside of window configurations would make sense,
but none are implemented.  It is not clear they are useful enough to be
worth implementing.


File: elisp,  Node: Frames,  Next: Positions,  Prev: Windows,  Up: Top

Frames
******

   A FRAME is a rectangle on the screen that contains one or more Emacs
windows.  A frame initially contains a single main window (plus perhaps
a minibuffer window) which you can subdivide vertically or horizontally
into smaller windows.

   When Emacs runs on a text-only terminal, it has just one frame, a
"terminal frame".  There is no way to create another terminal frame
after startup.  If Emacs has an X display, it does not make a terminal
frame; instead, it initially creates a single "X window frame".  You
can create more; see *Note Creating Frames::.

 - Function: framep OBJECT
     This predicate returns `t' if OBJECT is a frame, and `nil'
     otherwise.

* Menu:

* Creating Frames::		Creating additional X Window frames.
* Frame Parameters::		Controlling frame size, position, font, etc.
* Deleting Frames::		Frames last until explicitly deleted.
* Finding All Frames::		How to examine all existing frames.
* Frames and Windows::		A frame contains windows;
				  display of text always works through windows.
* Minibuffers and Frames::	How a frame finds the minibuffer to use.
* Input Focus::			What is this??
* Visibility of Frames::	Frames may be visible or invisible, or icons.
* Raising and Lowering::	Raising a frame makes it hide other X windows;
				  lowering it makes the others hide them.
* Frame Configurations::	Saving the state of all frames.
* Mouse Tracking::		Getting events that say when the mouse moves.
* Mouse Position::		Asking where the mouse is, or moving it.
* Pop-Up Menus::		Displaying a menu for the user to select from.
* X Selections::		Transferring text to and from other X clients.
* X Server::

   *Note Display::, for related information.


File: elisp,  Node: Creating Frames,  Next: Frame Parameters,  Up: Frames

Creating Frames
===============

   To create a new frame, call the function `make-frame'.

 - Function: make-frame ALIST
     This function creates a new frame, if the display mechanism permits
     creation of frames.  (An X server does; an ordinary terminal does
     not.)

     The argument is an alist specifying frame parameters.  Any
     parameters not mentioned in ALIST default according to the value
     of the variable `default-frame-alist'; parameters not specified
     there either default from the standard X defaults file and X
     resources.

     The set of possible parameters depends in principle on what kind of
     window system Emacs uses to display its the frames.  *Note X Frame
     Parameters::, for documentation of individual parameters you can
     specify when creating an X window frame.

 - Variable: default-frame-alist
     An alist specifying default values of frame parameters.  Each
     element has the form:

          (PARAMETER . VALUE)

     If you use options that specify window appearance when you invoke
     Emacs, they take effect by adding elements to
     `default-frame-alist'.


File: elisp,  Node: Frame Parameters,  Next: Deleting Frames,  Prev: Creating Frames,  Up: Frames

Frame Parameters
================

   A frame has many parameters that control how it displays.

* Menu:

* Parameter Access::       How to change a frame's parameters.
* Initial Parameters::	   Specifying frame parameters when you make a frame.
* X Frame Parameters::     Individual parameters documented.
* Size And Position::      Changing the size and position of a frame.


File: elisp,  Node: Parameter Access,  Next: Initial Parameters,  Up: Frame Parameters

Access to Frame Parameters
--------------------------

   These functions let you read and change the parameter values of a
frame.

 - Function: frame-parameters FRAME
     The function `frame-parameters' returns an alist of all the
     parameters of FRAME.

 - Function: modify-frame-parameters FRAME ALIST
     This function alters the parameters of frame FRAME based on the
     elements of ALIST.  Each element of ALIST has the form `(PARM .
     VALUE)', where PARM is a symbol naming a parameter.  If you don't
     mention a parameter in ALIST, its value doesn't change.

