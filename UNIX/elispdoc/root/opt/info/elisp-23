This is Info file elisp, produced by Makeinfo-1.55 from the input file
elisp.texi.

   This version is newer than the second printed edition of the GNU
Emacs Lisp Reference Manual.  It corresponds to Emacs Version 19.19.

   Published by the Free Software Foundation 675 Massachusetts Avenue
Cambridge, MA 02139 USA

   Copyright (C) 1990, 1991, 1992, 1993 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: elisp,  Node: Kill Functions,  Next: Yank Commands,  Prev: Kill Ring Concepts,  Up: The Kill Ring

Functions for Killing
---------------------

   `kill-region' is the usual subroutine for killing text.  Any command
that calls this function is a "kill command" (and should probably have
`kill' in its name).  `kill-region' puts the newly killed text in a new
element at the beginning of the kill ring or adds it to the most recent
element.  It uses the `last-command' variable to keep track of whether
the previous was a kill command, and in such cases appends the killed
text to the most recent entry.

 - Command: kill-region START END
     This function kills the text in the region defined by START and
     END.  The text is deleted but saved in the kill ring.  The value
     is always `nil'.

     In an interactive call, START and END are point and the mark.

     If the buffer is read-only, `kill-region' modifies the kill ring
     just the same, then signals an error without modifying the buffer.
     This is convenient because it lets the user use all the kill
     commands to copy text into the kill ring from a read-only buffer.

 - Command: copy-region-as-kill START END
     This function saves the region defined by START and END on the
     kill ring, but does not delete the text from the buffer.  It
     returns `nil'.  It also indicates the extent of the text copied by
     moving the cursor momentarily, or by displaying a message in the
     echo area.

     Don't use this command in Lisp programs; use `kill-new' or
     `kill-append' instead.  *Note Low Level Kill Ring::.

     In an interactive call, START and END are point and the mark.


File: elisp,  Node: Yank Commands,  Next: Low Level Kill Ring,  Prev: Kill Functions,  Up: The Kill Ring

Functions for Yanking
---------------------

 - Command: yank &optional ARG
     This function inserts the text in the first entry in the kill ring
     directly before point.  After the yank, the mark is positioned at
     the beginning and point is positioned after the end of the
     inserted text.

     If ARG is a list (which occurs interactively when the user types
     `C-u' with no digits), then `yank' inserts the text as described
     above, but puts point before the yanked text and puts the mark
     after it.  If ARG is a number, then `yank' inserts the ARGth most
     recently killed text.

     `yank' does not alter the contents of the kill ring or rotate it.
     It returns `nil'.

 - Command: yank-pop ARG
     This function replaces the just-yanked text with another batch of
     killed text--another element of the kill ring.

     This command is allowed only immediately after a `yank' or a
     `yank-pop'.  At such a time, the region contains text that was just
     inserted by the previous `yank'.  `yank-pop' deletes that text and
     inserts in its place a different stretch of killed text.  The text
     that is deleted is not inserted into the kill ring, since it is
     already in the kill ring somewhere.

     If ARG is `nil', then the existing region contents are replaced
     with the previous element of the kill ring.  If ARG is numeric,
     then the ARGth previous kill is the replacement.  If ARG is
     negative, a more recent kill is the replacement.

     The sequence of kills in the kill ring wraps around, so that after
     the oldest one comes the newest one, and before the newest one
     goes the oldest.

     The value is always `nil'.


File: elisp,  Node: Low Level Kill Ring,  Next: Internals of Kill Ring,  Prev: Yank Commands,  Up: The Kill Ring

Low Level Kill Ring
-------------------

   These functions and variables provide access to the kill ring at a
lower level, but still convenient for use in Lisp programs.  They take
care of interaction with X Window selections.  They do not exist in
Emacs version 18.

 - Function: current-kill N &optional DO-NOT-MOVE
     The function `current-kill' rotates the yanking pointer in the
     kill ring by N places, and returns the text at that place in the
     ring.

     If the optional second argument DO-NOT-MOVE is non-`nil', then
     `current-kill' doesn't alter the yanking pointer; it just returns
     the Nth kill forward from the current yanking pointer.

     If N is zero, indicating a request for the latest kill,
     `current-kill' calls the value of `interprogram-paste-function'
     (documented below) before consulting the kill ring.

 - Function: kill-new STRING
     This function puts the text STRING into the kill ring as a new
     entry at the front of the ring.  It also discards the oldest entry
     if appropriate.  It also invokes the value of
     `interprogram-cut-function' (see below).

 - Function: kill-append STRING BEFORE-P
     This function appends the text STRING to the first entry in the
     kill ring.  Normally STRING goes at the end of the entry, but if
     BEFORE-P is non-`nil', it goes at the beginning.  This function
     also invokes the value of `interprogram-cut-function' (see below).

 - Variable: interprogram-paste-function
     This variable provides a way of transferring killed text from other
     programs, when you are using a window system.  Its value should be
     `nil' or a function of no arguments.

     If the value is a function, it is called when the "most recent
     kill" value is called for.  If the function returns a non-`nil'
     values, then that value is used as the "most recent kill".  If it
     returns `nil', then the first element of the kill ring is used.

 - Variable: interprogram-cut-function
     This variable provides a way of communicating killed text to and
     from other programs, when you are using a window system.  Its
     value should be `nil' or a function of one argument.

     If the value is a function, it is called whenever the "most recent
     kill" is changed, with the new string of killed text as an
     argument.


File: elisp,  Node: Internals of Kill Ring,  Prev: Low Level Kill Ring,  Up: The Kill Ring

Internals of the Kill Ring
--------------------------

   The variable `kill-ring' holds the kill ring contents, in the form
of a list of strings.  The most recent kill is always at the front of
the list.

   The `kill-ring-yank-pointer' variable points to a link in the kill
ring list, whose CAR is the text that "yank" functions should copy.
Moving `kill-ring-yank-pointer' to a different link is called "rotating
the kill ring".  We call the kill ring a "ring" because the functions
that move the yank pointer wrap around from the end of the list to the
beginning, or vice-versa.  Rotating the ring does not change the value
of `kill-ring'.

   Both `kill-ring' and `kill-ring-yank-pointer' are Lisp variables
whose values are normally lists.  The word "pointer" in the name of the
`kill-ring-yank-pointer' indicates that the variable's purpose is to
identify one element of the list for use by the next yank command.

   The value of `kill-ring-yank-pointer' is always `eq' to one of the
links in the kill ring list.  The element it identifies is the CAR of
that link.  Commands which change the text in the kill ring also set
this variable from `kill-ring'.  The effect is to rotate the ring so
that the newly killed text is at front.

   Here is a diagram that shows the variable `kill-ring-yank-pointer'
pointing to the second entry in the kill ring `("some text" "a
different piece of text" "yet more text")'.

     kill-ring       kill-ring-yank-pointer
       |               |
       |     ___ ___    --->  ___ ___      ___ ___
        --> |___|___|------> |___|___|--> |___|___|--> nil
              |                |            |
              |                |            |
              |                |             -->"yet more text"
              |                |
              |                 --> "a different piece of text"
              |
               --> "some text"

This circumstance might occur after `C-y' (`yank') immediately followed
by `M-y' (`yank-pop').

 - Variable: kill-ring
     List of killed text sequences, most recently killed first.

 - Variable: kill-ring-yank-pointer
     This variable's value indicates which element of the kill ring is
     at the "front" of the ring for yanking.  More precisely, the value
     is a sublist of the value of `kill-ring', and its CAR is the kill
     string that `C-y' should yank.

 - User Option: kill-ring-max
     The value of this variable is the maximum length to which the kill
     ring can grow, before elements are thrown away at the end.  The
     default value for `kill-ring-max' is 30.


File: elisp,  Node: Undo,  Next: Maintaining Undo,  Prev: The Kill Ring,  Up: Text

Undo
====

   Most buffers have an "undo list" which records all changes made to
the buffer's text so that they can be undone.  (The buffers which don't
have one are usually special-purpose buffers for which Emacs assumes
that undoing is not useful.)  All the primitives which modify the text
in the buffer automatically add elements to the front of the undo list,
which you can find in the variable `buffer-undo-list'.

 - Variable: buffer-undo-list
     This variable's value is the undo list of the current buffer.  A
     value of `t' disables the recording of undo information.

   Here are the kinds of elements an undo list can have:

`INTEGER'
     This kind of element records a previous value of point.  Ordinary
     cursor motion does not get any sort of undo record, but these
     entries are used to record where point was before a deletion.

`(BEG . END)'
     This kind of element indicates how to delete text that was
     inserted.  Upon insertion, the text occupied the range BEG-END in
     the buffer.

`(POS . DELETED)'
     This kind of element indicates how to reinsert text that was
     deleted.  The deleted text itself is the string DELETED.  The
     place to reinsert it is POS.

`(t HIGH . LOW)'
     This kind of element indicates that an unmodified buffer became
     modified.  The elements HIGH and LOW are two integers, each
     recording 16 bits of the visited file's modification time as of
     when it was previously visited or saved.  `primitive-undo' uses
     those values to determine whether to mark the buffer as unmodified
     once again; it does so only if the file's modification time
     matches those numbers.

`(nil PROPERTY VALUE BEG . END)'
     This kind of element records a change in a text property.  Here's
     how you might undo the change:

          (put-text-property BEG END
                             PROPERTY VALUE)

`nil'
     This element is a boundary.  The function `undo-boundary' adds
     these elements.  The elements between two boundaries are called a
     "change group"; normally, each change group corresponds to one
     keyboard command, and undo commands normally undo an entire group
     as a unit.

 - Function: undo-boundary
     This function places a boundary element in the undo list.  The undo
     command stops at such a boundary, and successive undo commands undo
     to earlier and earlier boundaries.  This function returns `nil'.

     The editor command loop automatically creates an undo boundary
     between keystroke commands.  Thus, each undo normally undoes the
     effects of one command.  Calling this function explicitly is
     useful for splitting the effects of a command into more than one
     unit.  For example, `query-replace' calls this function after each
     replacement so that the user can undo individual replacements one
     by one.

 - Function: primitive-undo COUNT LIST
     This is the basic function for undoing elements of an undo list.
     It undoes the first COUNT elements of LIST, returning the rest of
     LIST.  You could write this function in Lisp, but it is convenient
     to have it in C.

     `primitive-undo' adds elements to the buffer's undo list.  Undo
     commands avoid confusion by saving the undo list value at the
     beginning of a sequence of undo operations.  Then the undo
     operations use and update the saved value.  The new elements added
     by undoing never get into the saved value, so they don't cause any
     trouble.


File: elisp,  Node: Maintaining Undo,  Next: Auto Filling,  Prev: Undo,  Up: Text

Maintaining Undo Lists
======================

   This section describes how to enable and disable undo information for
a given buffer.  It also explains how data from the undo list is
discarded automatically so it doesn't get too big.

   Recording of undo information in a newly created buffer is normally
enabled to start with; but if the buffer name starts with a space, the
undo recording is initially disabled.  You can explicitly enable or
disable undo recording with the following two functions, or by setting
`buffer-undo-list' yourself.

 - Command: buffer-enable-undo &optional BUFFER-OR-NAME
     This function enables recording undo information for buffer
     BUFFER-OR-NAME, so that subsequent changes can be undone.  If no
     argument is supplied, then the current buffer is used.  This
     function does nothing if undo recording is already enabled in the
     buffer.  It returns `nil'.

     In an interactive call, BUFFER-OR-NAME is the current buffer.  You
     cannot specify any other buffer.

 - Function: buffer-disable-undo BUFFER
 - Function: buffer-flush-undo BUFFER
     This function discards the undo list of BUFFER, and disables
     further recording of undo information.  As a result, it is no
     longer possible to undo either previous changes or any subsequent
     changes.  If the undo list of BUFFER is already disabled, this
     function has no effect.

     This function returns `nil'.  It cannot be called interactively.

     The name `buffer-flush-undo' is not considered obsolete, but the
     preferred name `buffer-disable-undo' was not provided in Emacs
     versions 18 and earlier.

   As editing continues, undo lists get longer and longer.  To prevent
them from using up all available memory space, garbage collection trims
them back to size limits you can set.  (For this purpose, the "size" of
an undo list measures the cons cells that make up the list, plus the
strings of deleted text.)  Two variables control the range of acceptable
sizes: `undo-limit' and `undo-strong-limit'.

 - Variable: undo-limit
     This is the soft limit for the acceptable size of an undo list.
     The change group at which this size is exceeded is the last one
     kept.

 - Variable: undo-strong-limit
     The upper limit for the acceptable size of an undo list.  The
     change group at which this size is exceeded is discarded itself
     (along with all subsequent changes).  There is one exception:
     garbage collection always keeps the very last change group no
     matter how big it is.


File: elisp,  Node: Filling,  Next: Sorting,  Prev: Auto Filling,  Up: Text

Filling
=======

   "Filling" means adjusting the lengths of lines (by moving words
between them) so that they are nearly (but no greater than) a specified
maximum width.  Additionally, lines can be "justified", which means
that spaces are inserted between words to make the line exactly the
specified width.  The width is controlled by the variable
`fill-column'.  For ease of reading, lines should be no longer than 70
or so columns.

   You can use Auto Fill mode (*note Auto Filling::.) to fill text
automatically as you insert it, but changes to existing text may leave
it improperly filled.  Then you must fill the text explicitly.

   Most of the functions in this section return values that are not
meaningful.

 - Command: fill-paragraph JUSTIFY-FLAG
     This function fills the paragraph at or after point.  If
     JUSTIFY-FLAG is non-`nil', each line is justified as well.  It
     uses the ordinary paragraph motion commands to find paragraph
     boundaries.

 - Command: fill-region START END &optional JUSTIFY-FLAG
     This function fills each of the paragraphs in the region from
     START to END.  It justifies as well if JUSTIFY-FLAG is non-`nil'.
     (In an interactive call, this is true if there is a prefix
     argument.)

     The variable `paragraph-separate' controls how to distinguish
     paragraphs.

 - Command: fill-individual-paragraphs START END &optional JUSTIFY-FLAG
          MAIL-FLAG
     This function fills each paragraph in the region according to its
     individual fill prefix.  Thus, if the lines of a paragraph are
     indented with spaces, the filled paragraph will continue to be
     indented in the same fashion.

     The first two arguments, START and END, are the beginning and end
     of the region that will be filled.  The third and fourth
     arguments, JUSTIFY-FLAG and MAIL-FLAG, are optional.  If
     JUSTIFY-FLAG is non-`nil', the paragraphs are justified as well as
     filled.  If MAIL-FLAG is non-`nil', the function is told that it
     is operating on a mail message and therefore should not fill the
     header lines.

     Ordinarily, `fill-individual-paragraphs' regards each change in
     indentation as starting a new paragraph.  If
     `fill-individual-varying-indent' is non-`nil', then only separator
     lines separate paragraphs.  That mode can handle paragraphs with
     extra indentation on the first line.

 - User Option: fill-individual-varying-indent
     This variable alters the action of `fill-individual-paragraphs' as
     described above.

 - Command: fill-region-as-paragraph START END &optional JUSTIFY-FLAG
     This function considers a region of text as a paragraph and fills
     it.  If the region was made up of many paragraphs, the blank lines
     between paragraphs are removed.  This function justifies as well
     as filling when JUSTIFY-FLAG is non-`nil'.  In an interactive
     call, any prefix argument requests justification.

     In Adaptive Fill mode, which is enabled by default,
     `fill-region-as-paragraph' on an indented paragraph when there is
     no fill prefix uses the indentation of the second line of the
     paragraph as the fill prefix.

 - Command: justify-current-line
     This function inserts spaces between the words of the current line
     so that the line ends exactly at `fill-column'.  It returns `nil'.

 - User Option: fill-column
     This buffer-local variable specifies the maximum width of filled
     lines.  Its value should be an integer, which is a number of
     columns.  All the filling, justification and centering commands
     are affected by this variable, including Auto Fill mode (*note
     Auto Filling::.).

     As a practical matter, if you are writing text for other people to
     read, you should set `fill-column' to no more than 70.  Otherwise
     the line will be too long for people to read comfortably, and this
     can make the text seem clumsy.

 - Variable: default-fill-column
     The value of this variable is the default value for `fill-column'
     in buffers that do not override it.  This is the same as
     `(default-value 'fill-column)'.

     The default value for `default-fill-column' is 70.


File: elisp,  Node: Auto Filling,  Next: Filling,  Prev: Maintaining Undo,  Up: Text

Auto Filling
============

   "Filling" breaks text into lines that are no more than a specified
number of columns wide.  Filled lines end between words, and therefore
may have to be shorter than the maximum width.

   Auto Fill mode is a minor mode in which Emacs fills lines
automatically as text as inserted.  This section describes the hook and
the two variables used by Auto Fill mode.  For a description of
functions that you can call manually to fill and justify text, see
*Note Filling::.

 - Variable: auto-fill-function
     The value of this variable should be a function (of no arguments)
     to be called after self-inserting a space at a column beyond
     `fill-column'.  It may be `nil', in which case nothing special is
     done.

     The default value for `auto-fill-function' is `do-auto-fill', a
     function whose sole purpose is to implement the usual strategy for
     breaking a line.

          In older Emacs versions, this variable was named
          `auto-fill-hook', but since it is not called with the
          standard convention for hooks, it was renamed to
          `auto-fill-function' in version 19.


File: elisp,  Node: Sorting,  Next: Indentation,  Prev: Filling,  Up: Text

Sorting Text
============

   The sorting commands described in this section all rearrange text in
a buffer.  This is in contrast to the function `sort', which rearranges
the order of the elements of a list (*note Rearrangement::.).  The
values returned by these commands are not meaningful.

 - Command: sort-regexp-fields REVERSE RECORD-REGEXP KEY-REGEXP START
          END
     This command sorts the region between START and END alphabetically
     as specified by RECORD-REGEXP and KEY-REGEXP.  If REVERSE is a
     negative integer, then sorting is in reverse order.

     Alphabetical sorting means that two sort keys are compared by
     comparing the first characters of each, the second characters of
     each, and so on.  If a mismatch is found, it means that the sort
     keys are unequal; the sort key whose character is less at the
     point of first mismatch is the lesser sort key.  The individual
     characters are compared according to their numerical values.
     Since Emacs uses the ASCII character set, the ordering in that set
     determines alphabetical order.

     The value of the RECORD-REGEXP argument specifies the textual
     units or "records" that should be sorted.  At the end of each
     record, a search is done for this regular expression, and the text
     that matches it is the next record.  For example, the regular
     expression `^.+$', which matches lines with at least one character
     besides a newline, would make each such line into a sort record.
     *Note Regular Expressions::, for a description of the syntax and
     meaning of regular expressions.

     The value of the KEY-REGEXP argument specifies what part of each
     record is to be compared against the other records.  The
     KEY-REGEXP could match the whole record, or only a part.  In the
     latter case, the rest of the record has no effect on the sorted
     order of records, but it is carried along when the record moves to
     its new position.

     The KEY-REGEXP argument can refer to the text matched by a
     subexpression of RECORD-REGEXP, or it can be a regular expression
     on its own.

     If KEY-REGEXP is:

    `\DIGIT'
          then the text matched by the DIGITth `\(...\)' parenthesis
          grouping in RECORD-REGEXP is used for sorting.

    `\&'
          then the whole record is used for sorting.

    a regular expression
          then the function searches for a match for the regular
          expression within the record.  If such a match is found, it
          is used for sorting.  If a match for KEY-REGEXP is not found
          within a record then that record is ignored, which means its
          position in the buffer is not changed.  (The other records
          may move around it.)

     For example, if you plan to sort all the lines in the region by the
     first word on each line starting with the letter `f', you should
     set RECORD-REGEXP to `^.*$' and set KEY-REGEXP to `\<f\w*\>'.  The
     resulting expression looks like this:

          (sort-regexp-fields nil "^.*$" "\\<f\\w*\\>"
                              (region-beginning)
                              (region-end))

     If you call `sort-regexp-fields' interactively, you are prompted
     for RECORD-REGEXP and KEY-REGEXP in the minibuffer.

 - Command: sort-subr REVERSE NEXTRECFUN ENDRECFUN &optional
          STARTKEYFUN ENDKEYFUN
     This command is the general text sorting routine that divides a
     buffer into records and sorts them.  The functions `sort-lines',
     `sort-paragraphs', `sort-pages', `sort-fields',
     `sort-regexp-fields' and `sort-numeric-fields' all use `sort-subr'.

     To understand how `sort-subr' works, consider the whole accessible
     portion of the buffer as being divided into disjoint pieces called
     "sort records".  A portion of each sort record (perhaps all of it)
     is designated as the sort key.  The records are rearranged in the
     buffer in order by their sort keys.  The records may or may not be
     contiguous.

     Usually, the records are rearranged in order of ascending sort key.
     If the first argument to the `sort-subr' function, REVERSE, is
     non-`nil', the sort records are rearranged in order of descending
     sort key.

     The next four arguments to `sort-subr' are functions that are
     called to move point across a sort record.  They are called many
     times from within `sort-subr'.

       1. NEXTRECFUN is called with point at the end of a record.  This
          function moves point to the start of the next record.  The
          first record is assumed to start at the position of point
          when `sort-subr' is called.  (Therefore, you should usually
          move point to the beginning of the buffer before calling
          `sort-subr'.)

          This function can indicate there are no more sort records by
          leaving point at the end of the buffer.

       2. ENDRECFUN is called with point within a record.  It moves
          point to the end of the record.

       3. STARTKEYFUN is called to move point from the start of a
          record to the start of the sort key.  This argument is
          optional.  If supplied, the function should either return a
          non-`nil' value to be used as the sort key, or return `nil'
          to indicate that the sort key is in the buffer starting at
          point.  In the latter case, ENDKEYFUN is called to find the
          end of the sort key.

       4. ENDKEYFUN is called to move point from the start of the sort
          key to the end of the sort key.  This argument is optional.
          If STARTKEYFUN returns `nil' and this argument is omitted (or
          `nil'), then the sort key extends to the end of the record.
          There is no need for ENDKEYFUN if STARTKEYFUN returns a
          non-`nil' value.

     As an example of `sort-subr', here is the complete function
     definition for `sort-lines':

          ;; Note that the first two lines of doc string
          ;; are effectively one line when viewed by a user.
          (defun sort-lines (reverse beg end)
            "Sort lines in region alphabetically;\
           argument means descending order.
          Called from a program, there are three arguments:
          REVERSE (non-nil means reverse order),
          and BEG and END (the region to sort)."
            (interactive "P\nr")
            (save-restriction
              (narrow-to-region beg end)
              (goto-char (point-min))
              (sort-subr reverse
                         'forward-line
                         'end-of-line)))

     Here `forward-line' moves point to the start of the next record,
     and `end-of-line' moves point to the end of record.  We do not pass
     the arguments STARTKEYFUN and ENDKEYFUN, because the entire record
     is used as the sort key.

     The `sort-paragraphs' function is very much the same, except that
     its `sort-subr' call looks like this:

          (sort-subr reverse
                     (function
                      (lambda ()
                        (skip-chars-forward "\n \t\f")))
                     'forward-paragraph)

 - Command: sort-lines REVERSE START END
     This command sorts lines in the region between START and END
     alphabetically.  If REVERSE is non-`nil', the sort is in reverse
     order.

 - Command: sort-paragraphs REVERSE START END
     This command sorts paragraphs in the region between START and END
     alphabetically.  If REVERSE is non-`nil', the sort is in reverse
     order.

 - Command: sort-pages REVERSE START END
     This command sorts pages in the region between START and END
     alphabetically.  If REVERSE is non-`nil', the sort is in reverse
     order.

 - Command: sort-fields FIELD START END
     This command sorts lines in the region between START and END,
     comparing them alphabetically by the FIELDth field of each line.
     Fields are separated by whitespace and numbered starting from 1.
     If FIELD is negative, sorting is by the -FIELDth field from the
     end of the line.  This command is useful for sorting tables.

 - Command: sort-numeric-fields FIELD START END
     This command sorts lines in the region between START and END,
     comparing them numerically by the FIELDth field of each line.
     Fields are separated by whitespace and numbered starting from 1.
     The specified field must contain a number in each line of the
     region.  If FIELD is negative, sorting is by the -FIELDth field
     from the end of the line.  This command is useful for sorting
     tables.

 - Command: sort-columns REVERSE &optional BEG END
     This command sorts the lines in the region between BEG and END,
     comparing them alphabetically by a certain range of columns.  The
     column positions of BEG and END bound the range of columns to sort
     on.

     If REVERSE is non-`nil', the sort is in reverse order.

     One unusual thing about this command is that the entire line
     containing position BEG, and the entire line containing position
     END, are included in the region sorted.

     Note that `sort-columns' uses the `sort' utility program, and so
     cannot work properly on text containing tab characters.  Use `M-x
     `untabify'' to convert tabs to spaces before sorting.

     The `sort-columns' function did not work on VMS prior to Emacs 19.


File: elisp,  Node: Indentation,  Next: Columns,  Prev: Sorting,  Up: Text

Indentation
===========

   The indentation functions are used to examine, move to, and change
whitespace that is at the beginning of a line.  Some of the functions
can also change whitespace elsewhere on a line.  Indentation always
counts from zero at the left margin.

* Menu:

* Primitive Indent::      Functions used to count and insert indentation.
* Mode-Specific Indent::  Customize indentation for different modes.
* Region Indent::         Indent all the lines in a region.
* Relative Indent::       Indent the current line based on previous lines.
* Indent Tabs::           Adjustable, typewriter-like tab stops.
* Motion by Indent::      Move to first non-blank character.


File: elisp,  Node: Primitive Indent,  Next: Mode-Specific Indent,  Up: Indentation

Indentation Primitives
----------------------

   This section describes the primitive functions used to count and
insert indentation.  The functions in the following sections use these
primitives.

 - Function: current-indentation
     This function returns the indentation of the current line, which is
     the horizontal position of the first nonblank character.  If the
     contents are entirely blank, then this is the horizontal position
     of the end of the line.

 - Command: indent-to COLUMN &optional MINIMUM
     This function indents from point with tabs and spaces until COLUMN
     is reached.  If MINIMUM is specified and non-`nil', then at least
     that many spaces are inserted even if this requires going beyond
     COLUMN.  The value is the column at which the inserted indentation
     ends.

 - User Option: indent-tabs-mode
     If this variable is non-`nil', indentation functions can insert
     tabs as well as spaces.  Otherwise, they insert only spaces.
     Setting this variable automatically makes it local to the current
     buffer.


File: elisp,  Node: Mode-Specific Indent,  Next: Region Indent,  Prev: Primitive Indent,  Up: Indentation

Indentation Controlled by Major Mode
------------------------------------

   An important function of each major mode is to customize the TAB key
to indent properly for the language being edited.  This section
describes the mechanism of the TAB key and how to control it.  The
functions in this section return unpredictable values.

 - Variable: indent-line-function
     This variable's value is the function to be used by TAB (and
     various commands) to indent the current line.  The command
     `indent-according-to-mode' does no more than call this function.

     In Lisp mode, the value is the symbol `lisp-indent-line'; in C
     mode, `c-indent-line'; in Fortran mode, `fortran-indent-line'.  In
     Fundamental mode, Text mode, and many other modes with no standard
     for indentation, the value is `indent-to-left-margin' (which is the
     default value).

 - Command: indent-according-to-mode
     This command calls the function in `indent-line-function' to
     indent the current line in a way appropriate for the current major
     mode.

 - Command: indent-for-tab-command
     This command calls the function in `indent-line-function' to
     indent the current line, except that if that function is
     `indent-to-left-margin', `insert-tab' is called instead.  (That is
     a trivial command which inserts a tab character.)

 - Variable: left-margin
     This variable is the column to which the default
     `indent-line-function' will indent.  (That function is
     `indent-to-left-margin'.)  In Fundamental mode, LFD indents to
     this column.  This variable automatically becomes buffer-local when
     set in any fashion.

 - Function: indent-to-left-margin
     This is the default `indent-line-function', used in Fundamental
     mode, Text mode, etc.  Its effect is to adjust the indentation at
     the beginning of the current line to the value specified by the
     variable `left-margin'.  This may involve either inserting or
     deleting whitespace.

 - Command: newline-and-indent
     This function inserts a newline, then indents the new line (the one
     following the newline just inserted) according to the major mode.

     Indentation is done using the current `indent-line-function'.  In
     programming language modes, this is the same thing TAB does, but
     in some text modes, where TAB inserts a tab, `newline-and-indent'
     indents to the column specified by `left-margin'.

 - Command: reindent-then-newline-and-indent
     This command reindents the current line, inserts a newline at
     point, and then reindents the new line (the one following the
     newline just inserted).

     Indentation of both lines is done according to the current major
     mode; this means that the current value of `indent-line-function'
     is called.  In programming language modes, this is the same thing
     TAB does, but in some text modes, where TAB inserts a tab,
     `reindent-then-newline-and-indent' indents to the column specified
     by `left-margin'.


File: elisp,  Node: Region Indent,  Next: Relative Indent,  Prev: Mode-Specific Indent,  Up: Indentation

Indenting an Entire Region
--------------------------

   This section describes commands which indent all the lines in the
region.  They return unpredictable values.

 - Command: indent-region START END TO-COLUMN
     This command indents each nonblank line starting between START
     (inclusive) and END (exclusive).  If TO-COLUMN is `nil',
     `indent-region' indents each nonblank line by calling the current
     mode's indentation function, the value of `indent-line-function'.

     If TO-COLUMN is non-`nil', it should be an integer specifying the
     number of columns of indentation; then this function gives each
     line exactly that much indentation, by either adding or deleting
     whitespace.

     If there is a fill prefix, `indent-region' indents each line by
     making it start with the fill prefix.

 - Variable: indent-region-function
     The value of this variable is a function that can be used by
     `indent-region' as a short cut.  You should design the function so
     that it will produce the same results as indenting the lines of the
     region one by one (but presumably faster).

     If the value is `nil', there is no short cut, and `indent-region'
     actually works line by line.

     A short cut function is useful in modes such as C mode and Lisp
     mode, where the `indent-line-function' must scan from the
     beginning of the function: applying it to each line would be
     quadratic in time.  The short cut can update the scan information
     as it moves through the lines indenting them; this takes linear
     time.  If indenting a line individually is fast, there is no need
     for a short cut.

     `indent-region' with a non-`nil' argument has a different
     definition and does not use this variable.

 - Command: indent-rigidly START END COUNT
     This command indents all lines starting between START (inclusive)
     and END (exclusive) sideways by `count' columns.  This "preserves
     the shape" of the affected region, moving it as a rigid unit.
     Consequently, this command is useful not only for indenting
     regions of unindented text, but also for indenting regions of
     formatted code.

     For example, if COUNT is 3, this command adds 3 columns of
     indentation to each of the lines beginning in the region specified.

     In Mail mode, `C-c C-y' (`mail-yank-original') uses
     `indent-rigidly' to indent the text copied from the message being
     replied to.

 - Function: indent-code-rigidly START END COLUMNS &optional
          NOCHANGE-REGEXP
     This is like `indent-rigidly', except that it doesn't alter lines
     that start within strings or comments.

     In addition, it doesn't alter a line if NOCHANGE-REGEXP matches at
     the beginning of the line (if NOCHANGE-REGEXP is non-`nil').


File: elisp,  Node: Relative Indent,  Next: Indent Tabs,  Prev: Region Indent,  Up: Indentation

Indentation Relative to Previous Lines
--------------------------------------

   This section describes two commands which indent the current line
based on the contents of previous lines.

 - Command: indent-relative &optional UNINDENTED-OK
     This function inserts whitespace at point, extending to the same
     column as the next "indent point" of the previous nonblank line.
     An indent point is a non-whitespace character following
     whitespace.  The next indent point is the first one at a column
     greater than the current column of point.  For example, if point
     is underneath and to the left of the first non-blank character of
     a line of text, it moves to that column by inserting whitespace.

     If the previous nonblank line has no next indent point (i.e., none
     at a great enough column position), this function either does
     nothing (if UNINDENTED-OK is non-`nil') or calls `tab-to-tab-stop'.
     Thus, if point is underneath and to the right of the last column
     of a short line of text, this function moves point to the next tab
     stop by inserting whitespace.

     This command returns an unpredictable value.

     In the following example, point is at the beginning of the second
     line:

                      This line is indented twelve spaces.
          -!-The quick brown fox jumped.

     Evaluation of the expression `(indent-relative nil)' produces the
     following:

                      This line is indented twelve spaces.
                      -!-The quick brown fox jumped.

     In this example, point is between the `m' and `p' of `jumped':

                      This line is indented twelve spaces.
          The quick brown fox jum-!-ped.

     Evaluation of the expression `(indent-relative nil)' produces the
     following:

                      This line is indented twelve spaces.
          The quick brown fox jum  -!-ped.

 - Command: indent-relative-maybe
     This command indents the current line like the previous nonblank
     line.  The function consists of a call to `indent-relative' with a
     non-`nil' value passed to the UNINDENTED-OK optional argument.
     The value is unpredictable.

     If the previous line has no indentation, the current line is given
     no indentation (any existing indentation is deleted); if the
     previous nonblank line has no indent points beyond the column at
     which point starts, nothing is changed.


File: elisp,  Node: Indent Tabs,  Next: Motion by Indent,  Prev: Relative Indent,  Up: Indentation

Adjustable "Tab Stops"
----------------------

   This section explains the mechanism for user-specified "tab stops"
and the mechanisms which use and set them.  The name "tab stops" is
used because the feature is similar to that of the tab stops on a
typewriter.  The feature works by inserting an appropriate number of
spaces and tab characters to reach the designated position, like the
other indentation functions; it does not affect the display of tab
characters in the buffer (*note Usual Display::.).  Note that the TAB
character as input uses this tab stop feature only in a few major
modes, such as Text mode.

 - Function: tab-to-tab-stop
     This function inserts spaces or tabs up to the next tab stop column
     defined by `tab-stop-list'.  It searches the list for an element
     greater than the current column number, and uses that element as
     the column to indent to.  If no such element is found, then
     nothing is done.

 - User Option: tab-stop-list
     This variable is the list of tab stop columns used by
     `tab-to-tab-stops'.  The elements should be integers in increasing
     order.  The tab stop columns need not be evenly spaced.

     Use `M-x edit-tab-stops' to edit the location of tab stops
     interactively.


File: elisp,  Node: Motion by Indent,  Prev: Indent Tabs,  Up: Indentation

Indentation-Based Motion Commands
---------------------------------

   These commands, primarily for interactive use, act based on the
indentation in the text.

 - Command: back-to-indentation
     This command moves point to the first non-whitespace character in
     the current line (which is the line in which point is located).
     It returns `nil'.

 - Command: backward-to-indentation ARG
     This command moves point backward ARG lines and then to the first
     nonblank character on that line.  It returns `nil'.

 - Command: forward-to-indentation ARG
     This command moves point forward ARG lines and then to the first
     nonblank character on that line.  It returns `nil'.


File: elisp,  Node: Columns,  Next: Case Changes,  Prev: Indentation,  Up: Text

Counting Columns
================

   The column functions convert between a character position (counting
characters from the beginning of the buffer) and a column position
(counting screen characters from the beginning of a line).

   Column number computations ignore the width of the window and the
amount of horizontal scrolling.  Consequently, a column value can be
arbitrarily high.  The first (or leftmost) column is numbered 0.

   A character counts according to the number of columns it occupies on
the screen.  This means control characters count as occupying 2 or 4
columns, depending upon the value of `ctl-arrow', and tabs count as
occupying a number of columns that depends on the value of `tab-width'
and on the column where the tab begins.  *Note Usual Display::.

 - Function: current-column
     This function returns the horizontal position of point, measured in
     columns, counting from 0 at the left margin.  The column count is
     calculated by adding together the widths of all the displayed
     representations of the characters between the start of the current
     line and point.

     For a more complicated example of the use of `current-column', see
     the description of `count-lines' in *Note Text Lines::.

 - Function: move-to-column COLUMN &optional FORCE
     This function moves point to COLUMN in the current line.  The
     calculation of COLUMN takes into account the widths of all the
     displayed representations of the characters between the start of
     the line and point.

     If the argument COLUMN is greater than the column position of the
     end of the line, point moves to the end of the line.  If COLUMN is
     negative, point moves to the beginning of the line.

     If it is impossible to move to column COLUMN because that is in
     the middle of a multicolumn character such as a tab, point moves
     to the end of that character.  However, if FORCE is non-`nil', and
     COLUMN is in the middle of a tab, then `move-to-column' converts
     the tab into spaces so that it can move precisely to column COLUMN.

     The argument FORCE also has an effect if the line isn't long
     enough to reach column COLUMN; in that case, it says to indent at
     the end of the line to reach that column.

     If COLUMN is not an integer, an error is signaled.

     The return value is the column number actually moved to.


File: elisp,  Node: Case Changes,  Next: Text Properties,  Prev: Columns,  Up: Text

Case Changes
============

   The case change commands described here work on text in the current
buffer.  *Note Character Case::, for case conversion commands that work
on strings and characters.  *Note Case Table::, for how to customize
which characters are upper or lower case and how to convert them.

 - Command: capitalize-region START END
     This function capitalizes all words in the region defined by START
     and END.  To capitalize means to convert each word's first
     character to upper case and convert the rest of each word to lower
     case.  The function returns `nil'.

     If one end of the region is in the middle of a word, the part of
     the word within the region is treated as an entire word.

     When `capitalize-region' is called interactively, START and END
     are point and the mark, with the smallest first.

          ---------- Buffer: foo ----------
          This is the contents of the 5th foo.
          ---------- Buffer: foo ----------
          
          (capitalize-region 1 44)
          => nil
          
          ---------- Buffer: foo ----------
          This Is The Contents Of The 5th Foo.
          ---------- Buffer: foo ----------

 - Command: downcase-region START END
     This function converts all of the letters in the region defined by
     START and END to lower case.  The function returns `nil'.

     When `downcase-region' is called interactively, START and END are
     point and the mark, with the smallest first.

 - Command: upcase-region START END
     This function converts all of the letters in the region defined by
     START and END to upper case.  The function returns `nil'.

     When `upcase-region' is called interactively, START and END are
     point and the mark, with the smallest first.

 - Command: capitalize-word COUNT
     This function capitalizes COUNT words after point, moving point
     over as it does.  To capitalize means to convert each word's first
     character to upper case and convert the rest of each word to lower
     case.  If COUNT is negative, the function capitalizes the -COUNT
     previous words but does not move point.  The value is `nil'.

     If point is in the middle of a word, the part of word the before
     point (if moving forward) or after point (if operating backward)
     is ignored.  The rest is treated as an entire word.

     When `capitalize-word' is called interactively, COUNT is set to
     the numeric prefix argument.

 - Command: downcase-word COUNT
     This function converts the COUNT words after point to all lower
     case, moving point over as it does.  If COUNT is negative, it
     converts the -COUNT previous words but does not move point.  The
     value is `nil'.

     When `downcase-word' is called interactively, COUNT is set to the
     numeric prefix argument.

 - Command: upcase-word COUNT
     This function converts the COUNT words after point to all upper
     case, moving point over as it does.  If COUNT is negative, it
     converts the -COUNT previous words but does not move point.  The
     value is `nil'.

     When `upcase-word' is called interactively, COUNT is set to the
     numeric prefix argument.


File: elisp,  Node: Text Properties,  Next: Substitution,  Prev: Case Changes,  Up: Text

Text Properties
===============

   Each character position in a buffer or a string can have a "text
property list", much like the property list of a symbol.  The properties
belong to a particular character at a particular place, such as, the
letter `T' at the beginning of this sentence or the first `o' in
`foo'--if the same character occurs in two different places, the two
occurrences generally have different properties.

   Each property has a name, which is usually a symbol, and an
associated value, which can be any Lisp object--just as for properties
of symbols (*note Property Lists::.).

   If a character has a `category' property, we call it the "category"
of the character.  It should be a symbol.  The properties of the symbol
serve as defaults for the properties of the character.

   Copying text between strings and buffers preserves the properties
along with the characters; this includes such diverse functions as
`substring', `insert', and `buffer-substring'.

* Menu:

* Examining Properties::	Looking at the properties of one character.
* Changing Properties::		Setting the properties of a range of text.
* Property Search::		Searching for where a property changes value.
* Special Properties::		Particular properties with special meanings.
* Sticky Properties::           How inserted text gets properties from
                                  neighboring text.
* Not Intervals::		Why text properties do not use
				  Lisp-visible text intervals.

