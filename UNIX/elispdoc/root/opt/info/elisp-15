This is Info file elisp, produced by Makeinfo-1.55 from the input file
elisp.texi.

   This version is newer than the second printed edition of the GNU
Emacs Lisp Reference Manual.  It corresponds to Emacs Version 19.19.

   Published by the Free Software Foundation 675 Massachusetts Avenue
Cambridge, MA 02139 USA

   Copyright (C) 1990, 1991, 1992, 1993 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: elisp,  Node: Keymap Terminology,  Next: Format of Keymaps,  Up: Keymaps

Keymap Terminology
==================

   A "keymap" is a table mapping event types to definitions (which can
be any Lisp objects, though only certain types are meaningful for
execution by the command loop).  Given an event (or an event type) and a
keymap, Emacs can get the event's definition.  Events include ordinary
ASCII characters, function keys, and mouse actions (*note Input
Events::.).

   A sequence of input events that form a unit is called a "key
sequence", or "key" for short.  A sequence of one event is always a key
sequence, and so are some multi-event sequences.

   A keymap determines a binding or definition for any key sequence.  If
the key sequence is a single event, its binding is the definition of the
event in the keymap.  The binding of a key sequence of more than one
event is found by an iterative process: the binding of the first event
is found, and must be a keymap; then the second event's binding is found
in that keymap, and so on until all the events in the key sequence are
used up.

   If the binding of a key sequence is a keymap, we call the key
sequence a "prefix key".  Otherwise, we call it a "complete key"
(because no more characters can be added to it).  If the binding is
`nil', we call the key "undefined".  Examples of prefix keys are `C-c',
`C-x', and `C-x 4'.  Examples of defined complete keys are `X', RET,
and `C-x 4 C-f'.  Examples of undefined complete keys are `C-x C-g',
and `C-c 3'.  *Note Prefix Keys::, for more details.

   The rule for finding the binding of a key sequence assumes that the
intermediate bindings (found for the events before the last) are all
keymaps; if this is not so, the sequence of events does not form a
unit--it is not really a key sequence.  In other words, removing one or
more events from the end of any valid key must always yield a prefix
key.  For example, `C-f C-f' is not a key; `C-f' is not a prefix key,
so a longer sequence starting with `C-f' cannot be a key.

   Note that the set of possible multi-event key sequences depends on
the bindings for prefix keys; therefore, it can be different for
different keymaps, and can change when bindings are changed.  However,
a one-event sequence is always a key sequence, because it does not
depend on any prefix keys for its well-formedness.

   At any time, several primary keymaps are "active"--that is, in use
for finding key bindings.  These are the "global map", which is shared
by all buffers; the "local keymap", which is usually associated with a
specific major mode; and zero or more "minor mode keymaps" which belong
to currently enabled minor modes.  (Not all minor modes have keymaps.)
The local keymap bindings shadow (i.e., take precedence over) the
corresponding global bindings.  The minor mode keymaps shadow both
local and global keymaps.  *Note Active Keymaps::, for details.


File: elisp,  Node: Format of Keymaps,  Next: Creating Keymaps,  Prev: Keymap Terminology,  Up: Keymaps

Format of Keymaps
=================

   A keymap is a list whose CAR is the symbol `keymap'.  The remaining
elements of the list define the key bindings of the keymap.  Use the
function `keymapp' (see below) to test whether an object is a keymap.

   An ordinary element is a cons cell of the form `(TYPE .  BINDING)'.
This specifies one binding which applies to events of type TYPE.  Each
ordinary binding applies to events of a particular "event type", which
is always a character or a symbol.  *Note Classifying Events::.

   A cons cell whose CAR is `t' is a "default key binding"; any event
not bound by other elements of the keymap is given BINDING as its
binding.  Default bindings allow a keymap to bind all possible event
types without having to enumerate all of them.  A keymap that has a
default binding completely masks any lower-precedence keymap.

   If an element of a keymap is a vector, the vector counts as bindings
for all the ASCII characters; vector element N is the binding for the
character with code N.  This is a more compact way to record lots of
bindings.  A keymap with such a vector is called a "full keymap".
Other keymaps are called "sparse keymaps".

   When a keymap contains a vector, it always defines a binding for
every ASCII character even if the vector element is `nil'.  Such a
binding of `nil' overrides any default binding in the keymap.  However,
default bindings are still meaningful for events that are not ASCII
characters.  A binding of `nil' does *not* override lower-precedence
keymaps; thus, if the local map gives a binding of `nil', Emacs uses
the binding from the global map.

   Aside from bindings, a keymap can also have a string as an element.
This is called the "overall prompt string" and makes it possible to use
the keymap as a menu.  *Note Menu Keymaps::.

   Keymaps do not directly record bindings for the meta characters,
whose codes are from 128 to 255.  Instead, meta characters are regarded
for purposes of key lookup as sequences of two characters, the first of
which is ESC (or whatever is currently the value of
`meta-prefix-char').  Thus, the key `M-a' is really represented as `ESC
a', and its global binding is found at the slot for `a' in `esc-map'.

   Here as an example is the local keymap for Lisp mode, a sparse
keymap.  It defines bindings for DEL and TAB, plus `C-c C-l', `M-C-q',
and `M-C-x'.

     lisp-mode-map
     =>
     (keymap
      ;; TAB
      (9 . lisp-indent-line)
      ;; DEL
      (127 . backward-delete-char-untabify)
      (3 keymap
         ;; `C-c C-l'
         (12 . run-lisp))
      (27 keymap
          ;; `M-C-q', treated as `ESC C-q'
          (17 . indent-sexp)
          ;; `M-C-x', treated as `ESC C-x'
          (24 . lisp-send-defun)))

 - Function: keymapp OBJECT
     This function returns `t' if OBJECT is a keymap, `nil' otherwise.
     Practically speaking, this function tests for a list whose CAR is
     `keymap'.

          (keymapp '(keymap))
              => t
          (keymapp (current-global-map))
              => t


File: elisp,  Node: Creating Keymaps,  Next: Inheritance and Keymaps,  Prev: Format of Keymaps,  Up: Keymaps

Creating Keymaps
================

   Here we describe the functions for creating keymaps.

 - Function: make-keymap &optional PROMPT
     This function creates and returns a new full keymap (i.e., one
     which contains a vector of length 128 for defining all the ASCII
     characters).  The new keymap initially binds all ASCII characters
     to `nil', and does not bind any other kind of event.

          (make-keymap)
              => (keymap [nil nil nil ... nil nil])

     If you specify PROMPT, that becomes the overall prompt string for
     the keymap.  The prompt string is useful for menu keymaps (*note
     Menu Keymaps::.).

 - Function: make-sparse-keymap &optional PROMPT
     This function creates and returns a new sparse keymap with no
     entries.  The new keymap does not bind any events.  The argument
     PROMPT specifies a prompt string, as in `make-keymap'.

          (make-sparse-keymap)
              => (keymap)

 - Function: copy-keymap KEYMAP
     This function returns a copy of KEYMAP.  Any keymaps which appear
     directly as bindings in KEYMAP are also copied recursively, and so
     on to any number of levels.  However, recursive copying does not
     take place when the definition of a character is a symbol whose
     function definition is a keymap; the same symbol appears in the
     new copy.

          (setq map (copy-keymap (current-local-map)))
          => (keymap
               ;; (This implements meta characters.)
               (27 keymap
                   (83 . center-paragraph)
                   (115 . center-line))
               (9 . tab-to-tab-stop))
          
          (eq map (current-local-map))
              => nil
          (equal map (current-local-map))
              => t


File: elisp,  Node: Inheritance and Keymaps,  Next: Prefix Keys,  Prev: Creating Keymaps,  Up: Keymaps

Inheritance and Keymaps
=======================

   A keymap can inherit the bindings of another keymap.  Do do this,
make a keymap whose "tail" is another existing keymap to inherit from.
Such a keymap looks like this:

     (keymap BINDINGS... . OTHER-KEYMAP)

The effect is that this keymap inherits all the bindings of
OTHER-KEYMAP, whatever they may be at the time a key is looked up, but
can add to them or override them with BINDINGS.

   If you change the bindings in OTHER-KEYMAP using `define-key' or
other key-binding functions, these changes are visible in the
inheriting keymap unless shadowed by BINDINGS.  The converse is not
true: if you use `define-key' to change the inheriting keymap, that
affects BINDINGS, but has no effect on OTHER-KEYMAP.

   Here is an example showing how to make a keymap that inherits from
`text-mode-map':

     (setq my-mode-map (cons 'keymap text-mode-map))


File: elisp,  Node: Prefix Keys,  Next: Menu Keymaps,  Prev: Inheritance and Keymaps,  Up: Keymaps

Prefix Keys
===========

   A "prefix key" has an associated keymap which defines what to do
with key sequences that start with the prefix key.  For example, `C-x'
is a prefix key, and it uses a keymap which is also stored in the
variable `ctl-x-map'.  Here is a list of the standard prefix keys of
Emacs and their keymaps:

   * `esc-map' is used for events that follow ESC.  Thus, the global
     definitions of all meta characters are actually found here.  This
     map is also the function definition of `ESC-prefix'.

   * `help-map' is used for events that follow `C-h'.

   * `mode-specific-map' is for events that follow `C-c'.  This map is
     not actually mode specific; its name was chosen to be informative
     for the user in `C-h b' (`display-bindings'), where it describes
     the main use of the `C-c' prefix key.

   * `ctl-x-map' is the variable name for the map used for events that
     follow `C-x'.  This map is also the function definition of
     `Control-X-prefix'.

   * `ctl-x-4-map' is used for events that follow `C-x 4'.

   * `ctl-x-5-map' used is for events that follow `C-x 5'.

   * A nameless keymap is used for events that follow `C-x n'.  Others
     are used for events following `C-x r' and `C-x a'.

   The binding of a prefix key is the keymap to use for looking up the
events that follow the prefix key.  (It may instead be a symbol whose
function definition is a keymap.  The effect is the same, but the symbol
serves as a name for the prefix key.)  Thus, the binding of `C-x' is
the symbol `Control-X-prefix', whose function definition is the keymap
for `C-x' commands.  (The same keymap is also the value of `ctl-x-map'.)

   Prefix key definitions of this sort can appear in any active keymap.
The definitions of `C-c', `C-x', `C-h' and ESC as prefix keys appear in
the global map, so these prefix keys are always available.  Major and
minor modes can redefine a key as a prefix by putting a prefix key
definition for it in the local map or the minor mode's map.  *Note
Active Keymaps::.

   If a key is defined as a prefix in more than one active map, then the
various definitions are in effect merged: the commands defined in the
minor mode keymaps come first, followed by those in the local map's
prefix definition, and then by those from the global map.

   In the following example, we make `C-p' a prefix key in the local
keymap, in such a way that `C-p' is identical to `C-x'.  Then the
binding for `C-p C-f' is the function `find-file', just like `C-x C-f'.
The key sequence `C-p 6' is not found in any active keymap.

     (use-local-map (make-sparse-keymap))
         => nil
     (local-set-key "\C-p" ctl-x-map)
         => nil
     (key-binding "\C-p\C-f")
         => find-file
     
     (key-binding "\C-p6")
         => nil

 - Function: define-prefix-command SYMBOL
     This function defines SYMBOL as a prefix command: it creates a
     full keymap and stores it as SYMBOL's function definition.
     Storing the symbol as the binding of a key makes the key a prefix
     key which has a name.  It also sets SYMBOL as a variable, to have
     the keymap as its value.  The function returns SYMBOL.

     In Emacs version 18, only the function definition of SYMBOL was
     set, not the value as a variable.


File: elisp,  Node: Menu Keymaps,  Next: Active Keymaps,  Prev: Prefix Keys,  Up: Keymaps

Menu Keymaps
============

   A keymap can define a menu as well as ordinary keys and mouse button
meanings.  Menus are normally actuated with the mouse, but they can work
with the keyboard also.

* Menu:

* Defining Menus::		How to make a keymap that defines a menu.
* Mouse Menus::			How users actuate the menu with the mouse.
* Keyboard Menus::		How they actuate it with the keyboard.
* Menu Example::		Making a simple menu.
* Menu Bar::			How to customize the menu bar.
* Modifying Menus::             How to add new items to a menu.


File: elisp,  Node: Defining Menus,  Next: Mouse Menus,  Up: Menu Keymaps

Defining Menus
--------------

   A keymap is suitable for menu use if it has an "overall prompt
string", which is a string that appears as an element of the keymap.
(*Note Format of Keymaps::.)  The string should describe the purpose of
the menu.  The easiest way to construct a keymap with a prompt string is
to specify the string as an argument when you call `make-keymap' or
`make-sparse-keymap' (*note Creating Keymaps::.).

   The individual bindings in the menu keymap should also have prompt
strings; these strings become the items displayed in the menu.  A
binding with a prompt string looks like this:

     (STRING . REAL-BINDING)

   As far as `define-key' and `lookup-key' are concerned, the string is
part of the event's binding.  However, only REAL-BINDING is used for
executing the key.

   You can also supply a second string, called the help string, as
follows:

     (STRING HELP-STRING . REAL-BINDING)

   Currently Emacs does not actually use HELP-STRING; it knows only how
to ignore HELP-STRING in order to extract REAL-BINDING.  In the future
we hope to make HELP-STRING serve as extended documentation for the
menu item, available on request.

   The prompt string for a binding should be short--one or two words.
It should describe the action of the command it corresponds to.

   If REAL-BINDING is `nil', then STRING appears in the menu but cannot
be selected.

   If REAL-BINDING is a symbol, and has a non-`nil' `menu-enable'
property, that property is an expression which controls whether the
menu item is enabled.  Every time the keymap is used to display a menu,
Emacs evaluates the expression, and it enables the menu item only if
the expression's value is non-`nil'.  When a menu item is disabled, it
is displayed in a "fuzzy" fashion, and cannot be selected with the
mouse.

   The order of items in the menu is the same as the order of bindings
in the keymap.  Since `define-key' puts new bindings at the front, you
should define the menu items starting at the bottom of the menu and
moving to the top, if you care about the order.


File: elisp,  Node: Mouse Menus,  Next: Keyboard Menus,  Prev: Defining Menus,  Up: Menu Keymaps

Menus and the Mouse
-------------------

   The way to make a menu keymap produce a menu is to make it the
definition of a prefix key.

   When the prefix key ends with a mouse event, Emacs handles the menu
keymap by popping up a visible menu, so that the user can select a
choice with the mouse.  When the user clicks on a menu item, the event
generated is whatever character or symbol has the binding which brought
about that menu item.

   It's often best to use a button-down event to trigger the menu.  Then
the user can select a menu item by releasing the button.

   A single keymap can appear as multiple menu panes, if you explicitly
arrange for this.  The way to do this is to make a keymap for each pane,
then create a binding for each of those maps in the main keymap of the
menu.  Give each of these bindings a prompt string that starts with
`@'.  The rest of the prompt string becomes the name of the pane.  See
the file `lisp/mouse.el' for an example of this.  Any ordinary bindings
with `@'-less prompt strings are grouped into one pane, which appears
along with the other panes explicitly created for the submaps.

   You can also get multiple panes from separate keymaps.  The full
definition of a prefix key always comes from merging the definitions
supplied by the various active keymaps (minor mode, local, and global).
When more than one of these keymaps is a menu, each of them makes a
separate pane or panes.  *Note Active Keymaps::.

   A Lisp program can explicitly pop up a menu and receive the user's
choice.  You can use keymaps for this also.  *Note Pop-Up Menus::.


File: elisp,  Node: Keyboard Menus,  Next: Menu Example,  Prev: Mouse Menus,  Up: Menu Keymaps

Menus and the Keyboard
----------------------

   When a prefix key ending with a keyboard event (a character or
function key) has a definition that is a menu keymap, the user can use
the keyboard to choose a menu item.

   Emacs displays the menu alternatives (the prompt strings of the
bindings) in the echo area.  If they don't all fit at once, the user can
type SPC to see the next line of alternatives.  Successive uses of SPC
eventually get to the end of the menu and then cycle around to the
beginning.

   When the user has found the desired alternative from the menu, he or
she should type the corresponding character--the one whose binding is
that alternative.

   In a menu intended for keyboard use, each menu item must clearly
indicate what character to type.  The best convention to use is to make
the character the first letter of the menu item prompt string.  That is
something users will understand without being told.

   This way of using menus in an Emacs-like editor was inspired by the
Hierarkey system.

 - Variable: menu-prompt-more-char
     This variable specifies the character to use to ask to see the
     next line of a menu.  Its initial value is 32, the code for SPC.


File: elisp,  Node: Menu Example,  Next: Menu Bar,  Prev: Keyboard Menus,  Up: Menu Keymaps

Menu Example
------------

   Here is a simple example of how to set up a menu for mouse use.

     (defvar my-menu-map
       (make-sparse-keymap "Key Commands <==> Functions"))
     (fset 'help-for-keys my-menu-map)
     
     (define-key my-menu-map [bindings]
       '("List all keystroke commands" . describe-bindings))
     (define-key my-menu-map [key]
       '("Describe key briefly" . describe-key-briefly))
     (define-key my-menu-map [key-verbose]
       '("Describe key verbose" . describe-key))
     (define-key my-menu-map [function]
       '("Describe Lisp function" . describe-function))
     (define-key my-menu-map [where-is]
       '("Where is this command" . where-is))
     
     (define-key global-map [C-S-down-mouse-1] 'help-for-keys)

   The symbols used in the key sequences bound in the menu are
fictitious "function keys"; they don't appear on the keyboard, but that
doesn't stop you from using them in the menu.  Their names were chosen
to be mnemonic, because they show up in the output of `where-is' and
`apropos' to identify the corresponding menu items.

   However, if you want the menu to be usable from the keyboard as well,
you must use real ASCII characters instead of fictitious function keys.


File: elisp,  Node: Menu Bar,  Next: Modifying Menus,  Prev: Menu Example,  Up: Menu Keymaps

The Menu Bar
------------

   Under X Windows, each frame can have a "menu bar"--a permanently
displayed menu stretching horizontally across the top of the frame.  The
items of the menu bar are the subcommands of the fake "function key"
`menu-bar', as defined by all the active keymaps.

   To add an item to the menu bar, invent a fake "function key" of your
own (let's call it KEY), and make a binding for the key sequence
`[menu-bar KEY]'.  Most often, the binding is a menu keymap, so that
pressing a button on the menu bar item leads to another menu.

   When more than one active keymap defines the same fake function key
for the menu bar, the item appears just once.  If the user clicks on
that menu bar item, it brings up a single, combined submenu containing
all the subcommands of that item--the global subcommands, the local
subcommands, and the minor mode subcommands, all together.

   In order for a frame to display a menu bar, its `menu-bar-lines'
property must be greater than zero.  Emacs uses just one line for the
menu bar itself; if you specify more than one line, the other lines
serve to separate the menu bar from the windows in the frame.  We
recommend you try one or two as the value of `menu-bar-lines'.  *Note X
Frame Parameters::.

   Here's an example of setting up a menu bar item:

     (modify-frame-parameters (selected-frame) '((menu-bar-lines . 2)))
     
     ;; Make a menu keymap (with a prompt string)
     ;; to be the menu bar item's definition.
     (define-key global-map [menu-bar words]
       (cons "Words" (make-sparse-keymap "Words")))
     ;; Make specific subcommands in the item's submenu.
     (define-key global-map
       [menu-bar words forward]
       '("Forward word" . forward-word))

     (define-key global-map
       [menu-bar words backward]
       '("Backward word" . backward-word))

   A local keymap can cancel a menu bar item made by the global keymap
by rebinding the same fake function key with `undefined' as the
binding.  For example, this is how Dired suppresses the `Edit' menu bar
item:

     (define-key dired-mode-map [menu-bar edit] 'undefined)

`edit' is the fake function key used by the global map for the `Edit'
menu bar item.  The main reason to suppress a global menu bar item is
to regain space for mode-specific items.

 - Variable: menu-bar-final-items
     Normally the menu bar shows global items followed by items defined
     by the local maps.

     This variable holds a list of fake function keys for items to
     display at the end of the menu bar rather than in normal sequence.
     The default value is `(help)'; thus, the `Help' menu item
     normally appears at the end of the menu bar, following local menu
     items.


File: elisp,  Node: Modifying Menus,  Prev: Menu Bar,  Up: Menu Keymaps

Modifying Menus
---------------

   When you insert a new item in an existing menu, you probably want to
put it in a particular place among the menu's existing items.  If you
use `define-key' to add the item, it normally goes at the front of the
menu.  To put it elsewhere, use `define-key-after':

 - Function: define-key-after MAP KEY BINDING AFTER
     Define a binding in MAP for KEY, with value BINDING, just like
     `define-key', but position the binding in MAP after the binding
     for the key AFTER.  For example,

          (define-key my-menu [drink]
                      '("Drink" . drink-command) [eat])

     makes a binding for the fake function key drink and puts it right
     after the binding for eat.


File: elisp,  Node: Active Keymaps,  Next: Key Lookup,  Prev: Menu Keymaps,  Up: Keymaps

Active Keymaps
==============

   Emacs normally contains many keymaps; at any given time, just a few
of them are "active" in that they participate in the interpretation of
user input.  These are the global keymap, the current buffer's local
keymap, and the keymaps of any enabled minor modes.

   The "global keymap" holds the bindings of keys that are defined
regardless of the current buffer, such as `C-f'.  The variable
`global-map' holds this keymap, which is always active.

   Each buffer may have another keymap, its "local keymap", which may
contain new or overriding definitions for keys.  At all times, the
current buffer's local keymap is active.  Text properties can specify an
alternative local map for certain parts of the buffer; see *Note
Special Properties::.

   Each minor mode may have a keymap; if it does, the keymap is active
whenever the minor mode is enabled.

   All the active keymaps are used together to determine what command to
execute when a key is entered.  The key lookup proceeds as described
earlier (*note Key Lookup::.), but Emacs *first* searches for the key
in the minor mode maps (one map at a time); if they do not supply a
binding for the key, Emacs searches the local map; if that too has no
binding, Emacs then searches the global map.

   Since every buffer that uses the same major mode normally uses the
very same local keymap, it may appear as if the keymap is local to the
mode.  A change to the local keymap of a buffer (using `local-set-key',
for example) will be seen also in the other buffers that share that
keymap.

   The local keymaps that are used for Lisp mode, C mode, and several
other major modes exist even if they have not yet been used.  These
local maps are the values of the variables `lisp-mode-map',
`c-mode-map', and so on.  For most other modes, which are less
frequently used, the local keymap is constructed only when the mode is
used for the first time in a session.

   The minibuffer has local keymaps, too; they contain various
completion and exit commands.  *Note Minibuffers::.

   *Note Standard Keymaps::, for a list of standard keymaps.

 - Variable: global-map
     This variable contains the default global keymap that maps Emacs
     keyboard input to commands.  Normally this keymap is the global
     keymap.  The default global keymap is a full keymap that binds
     `self-insert-command' to all of the printing characters.

 - Function: current-global-map
     This function returns the current global keymap.  This is always
     the same as the value of `global-map' unless you change one or the
     other.

          (current-global-map)
          => (keymap [set-mark-command beginning-of-line ...
                      delete-backward-char])

 - Function: current-local-map
     This function returns the current buffer's local keymap, or `nil'
     if it has none.  In the following example, the keymap for the
     `*scratch*' buffer (using Lisp Interaction mode) is a sparse keymap
     in which the entry for ESC, ASCII code 27, is another sparse
     keymap.

          (current-local-map)
          => (keymap
              (10 . eval-print-last-sexp)
              (9 . lisp-indent-line)
              (127 . backward-delete-char-untabify)
              (27 keymap
                  (24 . eval-defun)
                  (17 . indent-sexp)))

 - Function: current-minor-mode-maps
     This function returns a list of the keymaps of currently enabled
     minor modes.

 - Function: use-global-map KEYMAP
     This function makes KEYMAP the new current global keymap.  It
     returns `nil'.

     It is very unusual to change the global keymap.

 - Function: use-local-map KEYMAP
     This function makes KEYMAP the new current local keymap of the
     current buffer.  If KEYMAP is `nil', then there will be no local
     keymap.  It returns `nil'.  Most major modes use this function.

 - Variable: minor-mode-map-alist
     This variable is an alist describing keymaps that may or may not be
     active according to the values of certain variables.  Its elements
     look like this:

          (VARIABLE . KEYMAP)

     The keymap KEYMAP is active whenever VARIABLE has a non-`nil'
     value.  Typically VARIABLE is the variable which enables or
     disables a minor mode.  *Note Keymaps and Minor Modes::.

     When more than one minor mode keymap is active, their order of
     priority is the order of `minor-mode-map-alist'.

     See also `minor-mode-key-binding' in *Note Functions for Key
     Lookup::.


File: elisp,  Node: Key Lookup,  Next: Functions for Key Lookup,  Prev: Active Keymaps,  Up: Keymaps

Key Lookup
==========

   "Key lookup" is the process of finding the binding of a key sequence
from a given keymap.  Actual execution of the binding is not part of
key lookup.

   Key lookup uses just the event types of each event in the key
sequence; the rest of the event is ignored.  In fact, a key sequence
used for key lookup may designate mouse events with just their types
(symbols) instead of with entire mouse events (lists).  *Note Input
Events::.  Such a pseudo-key-sequence is insufficient for
`command-execute', but it is sufficient for looking up or rebinding a
key.

   When the key sequence consists of multiple events, key lookup
processes the events sequentially: the binding of the first event is
found, and must be a keymap; then the second event's binding is found in
that keymap, and so on until all the events in the key sequence are used
up.  (The binding thus found for the last event may or may not be a
keymap.)  Thus, the process of key lookup is defined in terms of a
simpler process for looking up a single event in a keymap.  How that is
done depends on the type of object associated with the event in that
keymap.

   Let's use the term "keymap entry" to describe the value directly
associated with an event type in a keymap.  While any Lisp object may be
stored as a keymap entry, not all make sense for key lookup.  Here is a
list of the meaningful kinds of keymap entries:

`nil'
     `nil' means that the events used so far in the lookup form an
     undefined key.  When a keymap fails to mention an event type at
     all, that is equivalent to an entry of `nil' for that type.

KEYMAP
     The events used so far in the lookup form a prefix key.  The next
     event of the key sequence is looked up in KEYMAP.

COMMAND
     The events used so far in the lookup form a complete key, and
     COMMAND is its binding.

STRING
VECTOR
     The events used so far in the lookup form a complete key, whose
     binding is a keyboard macro.  See *Note Keyboard Macros::, for more
     information.

LIST
     The meaning of a list depends on the types of the elements of the
     list.

        * If the CAR of LIST is the symbol `keymap', then the list is a
          keymap, and is treated as a keymap (see above).

        * If the CAR of LIST is `lambda', then the list is a lambda
          expression.  This is presumed to be a command, and is treated
          as such (see above).

        * If the CAR of LIST is a keymap and the CDR is an event type,
          then this is an "indirect entry":

               (OTHERMAP . OTHERTYPE)

          When key lookup encounters an indirect entry, it looks up
          instead the binding of OTHERTYPE in OTHERMAP and uses that.

          This feature permits you to define one key as an alias for
          another key.  For example, an entry whose CAR is the keymap
          called `esc-map' and whose CDR is 32 (the code for space)
          means, "Use the global binding of `Meta-SPC', whatever that
          may be."

        * If the CAR of LIST is a string, it serves as a menu item name
          if the keymap is used as a menu.  For executing the key, the
          string is discarded and the CDR of LIST is used instead.
          (Any number of strings can be discarded from the front of the
          list in this way.) *Note Menu Keymaps::.

SYMBOL
     The function definition of SYMBOL is used in place of SYMBOL.  If
     that too is a symbol, then this process is repeated, any number of
     times.  Ultimately this should lead to an object which is a
     keymap, a command or a keyboard macro.  A list is allowed if it is
     a keymap or a command, but indirect entries are not understood
     when found via symbols.

     Note that keymaps and keyboard macros (strings and vectors) are not
     valid functions, so a symbol with a keymap, string or vector as its
     function definition is also invalid as a function.  It is, however,
     valid as a key binding.  If the definition is a keyboard macro,
     then the symbol is also valid as an argument to `command-execute'
     (*note Interactive Call::.).

     The symbol `undefined' is worth special mention: it means to treat
     the key as undefined.  Strictly speaking, the key is defined, and
     its binding is the command `undefined'; but that command does the
     same thing that is done automatically for an undefined key: it
     rings the bell (by calling `ding') but does not signal an error.

     `undefined' is used in local keymaps to override a global key
     binding and make the key "undefined" locally.  A local binding of
     `nil' would fail to do this because it would not override the
     global binding.

ANYTHING ELSE
     If any other type of object is found, the events used so far in the
     lookup form a complete key, and the object is its binding, but the
     binding is not executable as a command.

   In short, a keymap entry may be a keymap, a command, a keyboard
macro, a symbol which leads to one of them, or an indirection or `nil'.
Here is an example of a sparse keymap with two characters bound to
commands and one bound to another keymap.  This map is the normal value
of `emacs-lisp-mode-map'.  Note that 9 is the code for TAB, 127 for
DEL, 27 for ESC, 17 for `C-q' and 24 for `C-x'.

     (keymap (9 . lisp-indent-line)
             (127 . backward-delete-char-untabify)
             (27 keymap (17 . indent-sexp) (24 . eval-defun)))


File: elisp,  Node: Functions for Key Lookup,  Next: Changing Key Bindings,  Prev: Key Lookup,  Up: Keymaps

Functions for Key Lookup
========================

   Here are the functions and variables pertaining to key lookup.

 - Function: lookup-key KEYMAP KEY &optional ACCEPT-DEFAULTS
     This function returns the definition of KEY in KEYMAP.  If the
     string or vector KEY is not a valid key sequence according to the
     prefix keys specified in KEYMAP (which means it is "too long" and
     has extra events at the end), then the value is a number, the
     number of events at the front of KEY that compose a complete key.

     If ACCEPT-DEFAULTS is non-`nil', then `lookup-key' considers
     default bindings as well as bindings for the specific events in
     KEY.  Otherwise, `lookup-key' reports only bindings for the
     specific sequence KEY, ignoring default bindings except when an
     element of KEY is `t'.

     All the other functions described in this chapter that look up
     keys use `lookup-key'.

          (lookup-key (current-global-map) "\C-x\C-f")
              => find-file
          (lookup-key (current-global-map) "\C-x\C-f12345")
              => 2

     If KEY contains a meta character, that character is implicitly
     replaced by a two-character sequence: the value of
     `meta-prefix-char', followed by the corresponding non-meta
     character.  Thus, the first example below is handled by conversion
     into the second example.

          (lookup-key (current-global-map) "\M-f")
              => forward-word
          (lookup-key (current-global-map) "\ef")
              => forward-word

     This function does not modify the specified events in ways that
     discard information as `read-key-sequence' does (*note Key
     Sequence Input::.).  In particular, it does not convert letters to
     lower case and it does not change drag events to clicks.

 - Command: undefined
     Used in keymaps to undefine keys.  It calls `ding', but does not
     cause an error.

 - Function: key-binding KEY &optional ACCEPT-DEFAULTS
     This function returns the binding for KEY in the current keymaps,
     trying all the active keymaps.  The result is `nil' if KEY is
     undefined in the keymaps.

     The argument ACCEPT-DEFAULTS controls checking for default
     bindings, as in `lookup-key'.

     An error is signaled if KEY is not a string or a vector.

          (key-binding "\C-x\C-f")
              => find-file

 - Function: local-key-binding KEY &optional ACCEPT-DEFAULTS
     This function returns the binding for KEY in the current local
     keymap, or `nil' if it is undefined there.

     The argument ACCEPT-DEFAULTS controls checking for default
     bindings, as in `lookup-key' (above).

 - Function: global-key-binding KEY &optional ACCEPT-DEFAULTS
     This function returns the binding for command KEY in the current
     global keymap, or `nil' if it is undefined there.

     The argument ACCEPT-DEFAULTS controls checking for default
     bindings, as in `lookup-key' (above).

 - Function: minor-mode-key-binding KEY &optional ACCEPT-DEFAULTS
     This function returns a list of all the active minor mode bindings
     of KEY.  More precisely, it returns an alist of pairs `(MODENAME .
     BINDING)', where MODENAME is the the variable which enables the
     minor mode, and BINDING is KEY's binding in that mode.  If KEY has
     no minor-mode bindings, the value is `nil'.

     If the first binding is a non-prefix, all subsequent bindings from
     other minor modes are omitted, since they would be completely
     shadowed.  Similarly, the list omits non-prefix bindings that
     follow prefix bindings.

     The argument ACCEPT-DEFAULTS controls checking for default
     bindings, as in `lookup-key' (above).

 - Variable: meta-prefix-char
     This variable is the meta-prefix character code.  It is used when
     translating a meta character to a two-character sequence so it can
     be looked up in a keymap.  For useful results, the value should be
     a prefix event (*note Prefix Keys::.).  The default value is 27,
     which is the ASCII code for ESC.

     As long as the value of `meta-prefix-char' remains 27, key lookup
     translates `M-b' into `ESC b', which is normally defined as the
     `backward-word' command.  However, if you set `meta-prefix-char'
     to 24, the code for `C-x', then Emacs will translate `M-b' into
     `C-x b', whose standard binding is the `switch-to-buffer' command.

          meta-prefix-char                    ; The default value.
               => 27

          (key-binding "\M-b")
               => backward-word

          ?\C-x                               ; The print representation
               => 24                          ;   of a character.

          (setq meta-prefix-char 24)
               => 24

          (key-binding "\M-b")
               => switch-to-buffer            ; Now, typing `M-b' is
                                              ;   like typing `C-x b'.
          
          (setq meta-prefix-char 27)          ; Avoid confusion!
               => 27                          ; Restore the default value!


File: elisp,  Node: Changing Key Bindings,  Next: Key Binding Commands,  Prev: Functions for Key Lookup,  Up: Keymaps

Changing Key Bindings
=====================

   The way to rebind a key is to change its entry in a keymap.  You can
change the global keymap, so that the change is effective in all buffers
(except those that override the global binding with a local one).  Or
you can change the current buffer's local map, which usually affects all
buffers using the same major mode.  The `global-set-key' and
`local-set-key' functions are convenient interfaces for these
operations.  Or you can use `define-key' and specify explicitly which
map to change.

   People often use `global-set-key' in their `.emacs' file for simple
customization.  For example,

     (global-set-key "\C-x\C-\\" 'next-line)

or

     (global-set-key [?\C-x ?\C-\\] 'next-line)

redefines `C-x C-\' to move down a line.

     (global-set-key [M-mouse-1] 'mouse-set-point)

redefines the first (leftmost) mouse button, typed with the Meta key, to
set point where you click.

   In writing the key sequence to rebind, it is useful to use the
special escape sequences for control and meta characters (*note String
Type::.).  The syntax `\C-' means that the following character is a
control character and `\M-' means that the following character is a meta
character.  Thus, the string `"\M-x"' is read as containing a single
`M-x', `"\C-f"' is read as containing a single `C-f', and `"\M-\C-x"'
and `"\C-\M-x"' are both read as containing a single `C-M-x'.

   For the functions below, an error is signaled if KEYMAP is not a
keymap or if KEY is not a string or vector representing a key sequence.
However, you can use event types (symbols) as shorthand for events
that are lists.

 - Function: define-key KEYMAP KEY BINDING
     This function sets the binding for KEY in KEYMAP.  (If KEY is more
     than one event long, the change is actually made in another keymap
     reached from KEYMAP.)  The argument BINDING can be any Lisp
     object, but only certain types are meaningful.  (For a list of
     meaningful types, see *Note Key Lookup::.) The value returned by
     `define-key' is BINDING.

     Every prefix of KEY must be a prefix key (i.e., bound to a keymap)
     or undefined; otherwise an error is signaled.

     If some prefix of KEY is undefined, then `define-key' defines it
     as a prefix key so that the rest of KEY may be defined as
     specified.

     The following example creates a sparse keymap and makes a number of
     bindings:

          (setq map (make-sparse-keymap))
              => (keymap)

          (define-key map "\C-f" 'forward-char)
              => forward-char

          map
              => (keymap (6 . forward-char))

          ;; Build sparse submap for `C-x' and bind `f' in that.
          (define-key map "\C-xf" 'forward-word)
              => forward-word

          map
          => (keymap
              (24 keymap                ; `C-x'
                  (102 . forward-word)) ;      `f'
              (6 . forward-char))       ; `C-f'

          ;; Bind `C-p' to the `ctl-x-map'.
          (define-key map "\C-p" ctl-x-map)
          ;; `ctl-x-map'
          => [nil ... find-file ... backward-kill-sentence]

          ;; Bind `C-f' to `foo' in the `ctl-x-map'.
          (define-key map "\C-p\C-f" 'foo)
          => 'foo

          map
          => (keymap     ; Note `foo' in `ctl-x-map'.
              (16 keymap [nil ... foo ... backward-kill-sentence])
              (24 keymap
                  (102 . forward-word))
              (6 . forward-char))

     Note that storing a new binding for `C-p C-f' actually works by
     changing an entry in `ctl-x-map', and this has the effect of
     changing the bindings of both `C-p C-f' and `C-x C-f' in the
     default global map.

 - Function: substitute-key-definition OLDDEF NEWDEF KEYMAP &optional
          OLDMAP
     This function replaces OLDDEF with NEWDEF for any keys in KEYMAP
     that were bound to OLDDEF.  In other words, OLDDEF is replaced
     with NEWDEF wherever it appears.  The function returns `nil'.

     For example, this redefines `C-x C-f', if you do it in an Emacs
     with standard bindings:

          (substitute-key-definition
           'find-file 'find-file-read-only (current-global-map))

     If OLDMAP is non-`nil', then its bindings determine which keys to
     rebind.  The rebindings still happen in NEWMAP, not in OLDMAP.
     Thus, you can change one map under the control of the bindings in
     another.  For example,

          (substitute-key-definition
            'delete-backward-char 'my-funny-delete
            my-map global-map)

     puts the special deletion command in `my-map' for whichever keys
     are globally bound to the standard deletion command.

     Here is an example showing a keymap before and after substitution:

          (setq map '(keymap
                      (?1 . olddef-1)
                      (?2 . olddef-2)
                      (?3 . olddef-1)))
          => (keymap (49 . olddef-1) (50 . olddef-2) (51 . olddef-1))

          (substitute-key-definition 'olddef-1 'newdef map)
          => nil

          map
          => (keymap (49 . newdef) (50 . olddef-2) (51 . newdef))

 - Function: suppress-keymap KEYMAP &optional NODIGITS
     This function changes the contents of the full keymap KEYMAP by
     replacing the self-insertion commands for numbers with the
     `digit-argument' function, unless NODIGITS is non-`nil', and by
     replacing the functions for the rest of the printing characters
     with `undefined'.  This means that ordinary insertion of text is
     impossible in a buffer with a local keymap on which
     `suppress-keymap' has been called.

     `suppress-keymap' returns `nil'.

     The `suppress-keymap' function does not make it impossible to
     modify a buffer, as it does not suppress commands such as `yank'
     and `quoted-insert'.  To prevent any modification of a buffer, make
     it read-only (*note Read Only Buffers::.).

     Since this function modifies KEYMAP, you would normally use it on
     a newly created keymap.  Operating on an existing keymap that is
     used for some other purpose is likely to cause trouble; for
     example, suppressing `global-map' would make it impossible to use
     most of Emacs.

     Most often, `suppress-keymap' is used to initialize local keymaps
     of modes such as Rmail and Dired where insertion of text is not
     desirable and the buffer is read-only.  Here is an example taken
     from the file `emacs/lisp/dired.el', showing how the local keymap
     for Dired mode is set up:

          ...
            (setq dired-mode-map (make-keymap))
            (suppress-keymap dired-mode-map)
            (define-key dired-mode-map "r" 'dired-rename-file)
            (define-key dired-mode-map "\C-d" 'dired-flag-file-deleted)
            (define-key dired-mode-map "d" 'dired-flag-file-deleted)
            (define-key dired-mode-map "v" 'dired-view-file)
            (define-key dired-mode-map "e" 'dired-find-file)
            (define-key dired-mode-map "f" 'dired-find-file)
            ...


File: elisp,  Node: Key Binding Commands,  Next: Scanning Keymaps,  Prev: Changing Key Bindings,  Up: Keymaps

Commands for Binding Keys
=========================

   This section describes some convenient interactive interfaces for
changing key bindings.  They work by calling `define-key'.

 - Command: global-set-key KEY DEFINITION
     This function sets the binding of KEY in the current global map to
     DEFINITION.

          (global-set-key KEY DEFINITION)
          ==
          (define-key (current-global-map) KEY DEFINITION)

 - Command: global-unset-key KEY
     This function removes the binding of KEY from the current global
     map.

     One use of this function is in preparation for defining a longer
     key which uses it implicitly as a prefix--which would not be
     allowed if KEY has a non-prefix binding.  For example:

          (global-unset-key "\C-l")
              => nil

          (global-set-key "\C-l\C-l" 'redraw-display)
              => nil

     This function is implemented simply using `define-key':

          (global-unset-key KEY)
          ==
          (define-key (current-global-map) KEY nil)

 - Command: local-set-key KEY DEFINITION
     This function sets the binding of KEY in the current local keymap
     to DEFINITION.

          (local-set-key KEY DEFINITION)
          ==
          (define-key (current-local-map) KEY DEFINITION)

 - Command: local-unset-key KEY
     This function removes the binding of KEY from the current local
     map.

          (local-unset-key KEY)
          ==
          (define-key (current-local-map) KEY nil)

