This is Info file elisp, produced by Makeinfo-1.55 from the input file
elisp.texi.

   This version is newer than the second printed edition of the GNU
Emacs Lisp Reference Manual.  It corresponds to Emacs Version 19.19.

   Published by the Free Software Foundation 675 Massachusetts Avenue
Cambridge, MA 02139 USA

   Copyright (C) 1990, 1991, 1992, 1993 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: elisp,  Node: Yes-or-No Queries,  Next: Multiple Queries,  Prev: Completion,  Up: Minibuffers

Yes-or-No Queries
=================

   This section describes functions used to ask the user a yes-or-no
question.  The function `y-or-n-p' can be answered with a single
character; it is useful for questions where an inadvertent wrong answer
will not have serious consequences.  `yes-or-no-p' is suitable for more
momentous questions, since it requires three or four characters to
answer.

   Strictly speaking, `yes-or-no-p' uses the minibuffer and `y-or-n-p'
does not; but it seems best to describe them together.

 - Function: y-or-n-p PROMPT
     This function asks the user a question, expecting input in the echo
     area.  It returns `t' if the user types `y', `nil' if the user
     types `n'.  This function also accepts SPC to mean yes and DEL to
     mean no.  It accepts `C-]' to mean "quit", like `C-g', because the
     question might look like a minibuffer and for that reason the user
     might try to use `C-]' to get out.  The answer is a single
     character, with no RET needed to terminate it.  Upper and lower
     case are equivalent.

     "Asking the question" means printing PROMPT in the echo area,
     followed by the string `(y or n) '.  If the input is not one of
     the expected answers (`y', `n', `SPC', `DEL', or something that
     quits), the function responds `Please answer y or n.', and repeats
     the request.

     This function does not actually use the minibuffer, since it does
     not allow editing of the answer.  It actually uses the echo area
     (*note The Echo Area::.), which uses the same screen space as the
     minibuffer.  The cursor moves to the echo area while the question
     is being asked.

     The meanings of answers, even `y' and `n', are not hardwired.
     They are controlled by the keymap `query-replace-map'.  *Note
     Replacement::.

     In the following example, the user first types `q', which is
     invalid.  At the next prompt the user types `n'.

          (y-or-n-p "Do you need a lift? ")
          
          ;; After evaluating the preceding expression,
          ;;   the following prompt appears in the echo area:

          ---------- Echo area ----------
          Do you need a lift? (y or n)
          ---------- Echo area ----------
          
          ;; If the user then types `q', the following appears:
          ---------- Echo area ----------
          Please answer y or n.  Do you need a lift? (y or n)
          ---------- Echo area ----------
          
          ;; When the user types a valid answer,
          ;;   it is displayed after the question:
          ---------- Echo area ----------
          Do you need a lift? (y or n) y
          ---------- Echo area ----------

     Note that we show successive lines of echo area messages here.
     Only one actually appears on the screen at a time.

 - Function: yes-or-no-p PROMPT
     This function asks the user a question, expecting input in
     minibuffer.  It returns `t' if the user enters `yes', `nil' if the
     user types `no'.  The user must type RET to finalize the response.
     Upper and lower case are equivalent.

     `yes-or-no-p' starts by displaying PROMPT in the echo area,
     followed by `(yes or no) '.  The user must type one of the
     expected responses; otherwise, the function responds `Please answer
     yes or no.', waits about two seconds and repeats the request.

     `yes-or-no-p' requires more work from the user than `y-or-n-p' and
     is appropriate for more crucial decisions.

     Here is an example:

          (yes-or-no-p "Do you really want to remove everything? ")
          
          ;; After evaluating the preceding expression,
          ;;   the following prompt appears,
          ;;   with an empty minibuffer:

          ---------- Buffer: minibuffer ----------
          Do you really want to remove everything? (yes or no)
          ---------- Buffer: minibuffer ----------

     If the user first types `y RET', which is invalid because this
     function demands the entire word `yes', it responds by displaying
     these prompts, with a brief pause between them:

          ---------- Buffer: minibuffer ----------
          Please answer yes or no.
          Do you really want to remove everything? (yes or no)
          ---------- Buffer: minibuffer ----------


File: elisp,  Node: Multiple Queries,  Next: Minibuffer Misc,  Prev: Yes-or-No Queries,  Up: Minibuffers

Asking Multiple Y-or-N Queries
==============================

 - Function: map-y-or-n-p PROMPTER ACTOR LIST &optional HELP
          ACTION-ALIST
     This function, new in Emacs 19, asks the user a series of
     questions, reading a single-character answer in the echo area for
     each one.

     The value of LIST specifies what varies from question to question
     within the series.  It should be either a list of objects or a
     generator function.  If it is a function, it should expect no
     arguments, and should return either the next object or `nil'
     meaning there are no more questions.

     The argument PROMPTER specifies how to ask each question.  If
     PROMPTER is a string, the question text is computed like this:

          (format PROMPTER OBJECT)

     where OBJECT is the next object to ask about (as obtained from
     LIST).

     If not a string, PROMPTER should be a function of one argument
     (the next object to ask about) and should return the question text.

     The argument ACTOR says how to act on the answers that the user
     gives.  It should be a function of one argument, and it is called
     with each object that the user says yes for.  Its argument is
     always an object obtained from LIST.

     If the argument HELP is given, it should be a list of this form:

          (SINGULAR PLURAL ACTION)

     where SINGULAR is a string containing a singular noun that
     describes the objects conceptually being acted on, PLURAL is the
     corresponding plural noun, and ACTION is a transitive verb
     describing what ACTOR does.

     If you don't specify HELP, the default is `("object" "objects"
     "act on")'.

     Each time a question is asked, the user may enter `y', `Y', or SPC
     to act on that object; `n', `N', or DEL to skip that object; `!'
     to act on all following objects; ESC or `q' to exit (skip all
     following objects); `.' (period) to act on the current object and
     then exit; or `C-h' to get help.  These are the same answers that
     `query-replace' accepts.  The keymap `query-replace-map' defines
     their meaning for `map-y-or-n-p' as well as for `query-replace';
     see *Note Replacement::.

     You can use ACTION-ALIST to specify additional possible answers
     and what they mean.  It is an alist of elements of the form `(CHAR
     FUNCTION HELP)', each of which defines one additional answer.  In
     this element, CHAR is a character (the answer); FUNCTION is a
     function of one argument (an object from LIST); HELP is a string.

     When the user responds with CHAR, `map-y-or-n-p' calls FUNCTION.
     If it returns non-`nil', the object is considered "acted upon",
     and `map-y-or-n-p' advances to the next object in LIST.  If it
     returns `nil', the prompt is repeated for the same object.

     The return value of `map-y-or-n-p' is the number of objects acted
     on.


File: elisp,  Node: Minibuffer Misc,  Prev: Multiple Queries,  Up: Minibuffers

Minibuffer Miscellany
=====================

   This section describes some basic functions and variables related to
minibuffers.

 - Command: exit-minibuffer
     This command exits the active minibuffer.  It is normally bound to
     keys in minibuffer local keymaps.

 - Command: self-insert-and-exit
     This command exits the active minibuffer after inserting the last
     character typed on the keyboard (found in `last-command-char';
     *note Command Loop Info::.).

 - Command: previous-history-element N
     This command replaces the minibuffer contents with the value of the
     Nth previous (older) history element.

 - Command: next-history-element N
     This command replaces the minibuffer contents with the value of the
     Nth more recent history element.

 - Command: previous-matching-history-element PATTERN
     This command replaces the minibuffer contents with the value of the
     previous (older) history element that matches PATTERN.  At the
     time of printing, we have not made a final decision about how to
     get the pattern interactively or how to match it against history
     elements.

 - Command: next-matching-history-element PATTERN
     This command replaces the minibuffer contents with the value of the
     next (newer) history element that matches PATTERN.

 - Variable: minibuffer-setup-hook
     This is a normal hook that is run whenever the minibuffer is
     entered.

 - Variable: minibuffer-help-form
     The current value of this variable is used to rebind `help-form'
     locally inside the minibuffer (*note Help Functions::.).

 - Function: minibuffer-window &optional FRAME
     This function returns the window that is used for the minibuffer.
     In Emacs 18, there is one and only one minibuffer window; this
     window always exists and cannot be deleted.  In Emacs 19, each
     frame can have its own minibuffer, and this function returns the
     minibuffer window used for frame FRAME (which defaults to the
     currently selected frame).

 - Function: window-minibuffer-p WINDOW
     This function returns non-`nil' if WINDOW is a minibuffer window.

   It is not correct to determine whether a given window is a
minibuffer by comparing it with the result of `(minibuffer-window)',
because there can be more than one minibuffer window there is more than
one frame.

 - Function: minibuffer-window-active-p WINDOW
     This function returns non-`nil' if WINDOW, assumed to be a
     minibuffer window, is currently active.

 - Variable: minibuffer-scroll-window
     If the value of this variable is non-`nil', it should be a window
     object.  When the function `scroll-other-window' is called in the
     minibuffer, it scrolls this window.

   Finally, some functions and variables deal with recursive minibuffers
(*note Recursive Editing::.):

 - Function: minibuffer-depth
     This function returns the current depth of activations of the
     minibuffer, a nonnegative integer.  If no minibuffers are active,
     it returns zero.

 - User Option: enable-recursive-minibuffers
     If this variable is non-`nil', you can invoke commands (such as
     `find-file') which use minibuffers even while in the minibuffer
     window.  Such invocation produces a recursive editing level for a
     new minibuffer.  The outer-level minibuffer is invisible while you
     are editing the inner one.

     This variable only affects invoking the minibuffer while the
     minibuffer window is selected.   If you switch windows while in the
     minibuffer, you can always invoke minibuffer commands while some
     other window is selected.

   If a command name has a property `enable-recursive-minibuffers'
which is non-`nil', then the command can use the minibuffer to read
arguments even if it is invoked from the minibuffer.  The minibuffer
command `next-matching-history-element' (normally bound to `M-s' in the
minibuffer) uses this feature.


File: elisp,  Node: Command Loop,  Next: Keymaps,  Prev: Minibuffers,  Up: Top

Command Loop
************

   When you run Emacs, it enters the "editor command loop" almost
immediately.  This loop reads key sequences, executes their definitions,
and displays the results.  In this chapter, we describe how these things
are done, and the subroutines that allow Lisp programs to do them.

* Menu:

* Command Overview::    How the command loop reads commands.
* Defining Commands::   Specifying how a function should read arguments.
* Interactive Call::    Calling a command, so that it will read arguments.
* Command Loop Info::   Variables set by the command loop for you to examine.
* Input Events::	What input looks like when you read it.
* Reading Input::       How to read input events from the keyboard or mouse.
* Waiting::             Waiting for user input or elapsed time.
* Quitting::            How `C-g' works.  How to catch or defer quitting.
* Prefix Command Arguments::    How the commands to set prefix args work.
* Recursive Editing::   Entering a recursive edit,
                          and why you usually shouldn't.
* Disabling Commands::  How the command loop handles disabled commands.
* Command History::     How the command history is set up, and how accessed.
* Keyboard Macros::     How keyboard macros are implemented.


File: elisp,  Node: Command Overview,  Next: Defining Commands,  Up: Command Loop

Command Loop Overview
=====================

   The first thing the command loop must do is read a key sequence,
which is a sequence of events that translates into a command.  It does
this by calling the function `read-key-sequence'.  Your Lisp code can
also call this function (*note Key Sequence Input::.).  Lisp programs
can also do input at a lower level with `read-event' (*note Reading One
Event::.) or discard pending input with `discard-input' (*note Peeking
and Discarding::.).

   The key sequence is translated into a command through the currently
active keymaps.  *Note Key Lookup::, for information on how this is
done.  The result should be a keyboard macro or an interactively
callable function.  If the key is `M-x', then it reads the name of
another command, which is used instead.  This is done by the command
`execute-extended-command' (*note Interactive Call::.).

   Once the command is chosen, it must be executed, which includes
reading arguments to be given to it.  This is done by calling
`command-execute' (*note Interactive Call::.).  For commands written in
Lisp, the `interactive' specification says how to read the arguments.
This may use the prefix argument (*note Prefix Command Arguments::.) or
may read with prompting in the minibuffer (*note Minibuffers::.).  For
example, the command `find-file' has an `interactive' specification
which says to read a file name using the minibuffer.  The command's
function body does not use the minibuffer; if you call this command
from Lisp code as a function, you must supply the file name string as
an ordinary Lisp function argument.

   If the command is a string or vector (i.e., a keyboard macro) then
`execute-kbd-macro' is used to execute it.  You can call this function
yourself (*note Keyboard Macros::.).

   If a command runs away, typing `C-g' terminates its execution
immediately.  This is called "quitting" (*note Quitting::.).

 - Variable: pre-command-hook
     The editor command loop runs this normal hook before each command.

 - Variable: post-command-hook
     The editor command loop runs this normal hook after each command,
     and also when the command loop is entered, or reentered after an
     error or quit.


File: elisp,  Node: Defining Commands,  Next: Interactive Call,  Prev: Command Overview,  Up: Command Loop

Defining Commands
=================

   A Lisp function becomes a command when its body contains, at top
level, a form which calls the special form `interactive'.  This form
does nothing when actually executed, but its presence serves as a flag
to indicate that interactive calling is permitted.  Its argument
controls the reading of arguments for an interactive call.

* Menu:

* Using Interactive::     General rules for `interactive'.
* Interactive Codes::     The standard letter-codes for reading arguments
                             in various ways.
* Interactive Examples::  Examples of how to read interactive arguments.


File: elisp,  Node: Using Interactive,  Next: Interactive Codes,  Up: Defining Commands

Using `interactive'
-------------------

   This section describes how to write the `interactive' form that
makes a Lisp function an interactively-callable command.

 - Special Form: interactive ARG-DESCRIPTOR
     This special form declares that the function in which it appears
     is a command, and that it may therefore be called interactively
     (via `M-x' or by entering a key sequence bound to it).  The
     argument ARG-DESCRIPTOR declares the way the arguments to the
     command are to be computed when the command is called
     interactively.

     A command may be called from Lisp programs like any other
     function, but then the arguments are supplied by the caller and
     ARG-DESCRIPTOR has no effect.

     The `interactive' form has its effect because the command loop
     (actually, its subroutine `call-interactively') scans through the
     function definition looking for it, before calling the function.
     Once the function is called, all its body forms including the
     `interactive' form are executed, but at this time `interactive'
     simply returns `nil' without even evaluating its argument.

   There are three possibilities for the argument ARG-DESCRIPTOR:

   * It may be omitted or `nil'; then the command is called with no
     arguments.  This leads quickly to an error if the command requires
     one or more arguments.

   * It may be a Lisp expression that is not a string; then it should
     be a form that is evaluated to get a list of arguments to pass to
     the command.

   * It may be a string; then its contents should consist of a code
     character followed by a prompt (which some code characters use and
     some ignore).  The prompt ends either with the end of the string
     or with a newline.  Here is a simple example:

          (interactive "bFrobnicate buffer: ")

     The code letter `b' says to read the name of an existing buffer,
     with completion.  The buffer name is the sole argument passed to
     the command.  The rest of the string is a prompt.

     If there is a newline character in the string, it terminates the
     prompt.  If the string does not end there, then the rest of the
     string should contain another code character and prompt,
     specifying another argument.  You can specify any number of
     arguments in this way.

     The prompt string can use `%' to include previous argument values
     in the prompt.  This is done using `format' (*note Formatting
     Strings::.).  For example, here is how you could read the name of
     an existing buffer followed by a new name to give to that buffer:

          (interactive "bBuffer to rename: \nsRename buffer %s to: ")

     If the first character in the string is `*', then an error is
     signaled if the buffer is read-only.

     If the first character in the string is `@', and if the key
     sequence used to invoke the command includes any mouse events, then
     the window associated with the first of those events is selected
     before the command is run.

     You can use `*' and `@' together; the order does not matter.
     Actual reading of arguments is controlled by the rest of the prompt
     string (starting with the first character that is not `*' or `@').


File: elisp,  Node: Interactive Codes,  Next: Interactive Examples,  Prev: Using Interactive,  Up: Defining Commands

Code Characters for `interactive'
---------------------------------

   The code character descriptions below contain a number of key words,
defined here as follows:

Completion
     Provide completion.  TAB, SPC, and RET perform name completion
     because the argument is read using `completing-read' (*note
     Completion::.).  `?' displays a list of possible completions.

Existing
     Require the name of an existing object.  An invalid name is not
     accepted; the commands to exit the minibuffer do not exit if the
     current input is not valid.

Default
     A default value of some sort is used if the user enters no text in
     the minibuffer.  The default depends on the code character.

No I/O
     This code letter computes an argument without reading any input.
     Therefore, it does not use a prompt string, and any prompt string
     you supply is ignored.

Prompt
     A prompt immediately follows the code character.  The prompt ends
     either with the end of the string or with a newline.

Special
     This code character is meaningful only at the beginning of the
     interactive string, and it does not look for a prompt or a newline.
     It is a single, isolated character.

   Here are the code character descriptions for use with `interactive':

`*'
     Signal an error if the current buffer is read-only.  Special.

`@'
     Select the window mentioned in the first mouse event in the key
     sequence that invoked this command.  Special.

`a'
     A function name (i.e., a symbol which is `fboundp').  Existing,
     Completion, Prompt.

`b'
     The name of an existing buffer.  By default, uses the name of the
     current buffer (*note Buffers::.).  Existing, Completion, Default,
     Prompt.

`B'
     A buffer name.  The buffer need not exist.  By default, uses the
     name of a recently used buffer other than the current buffer.
     Completion, Prompt.

`c'
     A character.  The cursor does not move into the echo area.  Prompt.

`C'
     A command name (i.e., a symbol satisfying `commandp').  Existing,
     Completion, Prompt.

`d'
     The position of point as a number (*note Point::.).  No I/O.

`D'
     A directory name.  The default is the current default directory of
     the current buffer, `default-directory' (*note System
     Environment::.).  Existing, Completion, Default, Prompt.

`e'
     The first or next mouse event in the key sequence that invoked the
     command.  More precisely, `e' gets events which are lists, so you
     can look at the data in the lists.  *Note Input Events::.  No I/O.

     You can use `e' more than once in a single command's interactive
     specification.  If the key sequence which invoked the command has
     N events with parameters, the Nth `e' provides the Nth list event.
     Events which are not lists, such as function keys and ASCII
     characters, do not count where `e' is concerned.

     Even though `e' does not use a prompt string, you must follow it
     with a newline if it is not the last code character.

`f'
     A file name of an existing file (*note File Names::.).  The default
     directory is `default-directory'.  Existing, Completion, Default,
     Prompt.

`F'
     A file name.  The file need not exist.  Completion, Default,
     Prompt.

`k'
     A key sequence (*note Keymap Terminology::.).  This keeps reading
     events until a command (or undefined command) is found in the
     current key maps.  The key sequence argument is represented as a
     string or vector.  The cursor does not move into the echo area.
     Prompt.

     This kind of input is used by commands such as `describe-key' and
     `global-set-key'.

`m'
     The position of the mark as a number.  No I/O.

`n'
     A number read with the minibuffer.  If the input is not a number,
     the user is asked to try again.  The prefix argument, if any, is
     not used.  Prompt.

`N'
     The raw prefix argument.  If the prefix argument is `nil', then a
     number is read as with `n'.  Requires a number.  Prompt.

`p'
     The numeric prefix argument.  (Note that this `p' is lower case.)
     No I/O.

`P'
     The raw prefix argument.  (Note that this `P' is upper case.)
     *Note Prefix Command Arguments::.  No I/O.

`r'
     Point and the mark, as two numeric arguments, smallest first.
     This is the only code letter that specifies two successive
     arguments rather than one.  No I/O.

`s'
     Arbitrary text, read in the minibuffer and returned as a string
     (*note Text from Minibuffer::.).  Terminate the input with either
     LFD or RET.  (`C-q' may be used to include either of these
     characters in the input.)  Prompt.

`S'
     An interned symbol whose name is read in the minibuffer.  Any
     whitespace character terminates the input.  (Use `C-q' to include
     whitespace in the string.)  Other characters that normally
     terminate a symbol (e.g., parentheses and brackets) do not do so
     here.  Prompt.

`v'
     A variable declared to be a user option (i.e., satisfying the
     predicate `user-variable-p').  *Note High-Level Completion::.
     Existing, Completion, Prompt.

`x'
     A Lisp object specified in printed representation, terminated with
     a LFD or RET.  The object is not evaluated.  *Note Object from
     Minibuffer::.  Prompt.

`X'
     A Lisp form is read as with `x', but then evaluated so that its
     value becomes the argument for the command.  Prompt.


File: elisp,  Node: Interactive Examples,  Prev: Interactive Codes,  Up: Defining Commands

Examples of Using `interactive'
-------------------------------

   Here are some examples of `interactive':

     (defun foo1 ()              ; `foo1' takes no arguments,
         (interactive)           ;   just moves forward two words.
         (forward-word 2))
          => foo1
     
     (defun foo2 (n)             ; `foo2' takes one argument,
         (interactive "p")       ;   which is the numeric prefix.
         (forward-word (* 2 n)))
          => foo2
     
     (defun foo3 (n)             ; `foo3' takes one argument,
         (interactive "nCount:") ;   which is read with the Minibuffer.
         (forward-word (* 2 n)))
          => foo3
     
     (defun three-b (b1 b2 b3)
       "Select three existing buffers.
     Put them into three windows, selecting the last one."
         (interactive "bBuffer1:\nbBuffer2:\nbBuffer3:")
         (delete-other-windows)
         (split-window (selected-window) 8)
         (switch-to-buffer b1)
         (other-window 1)
         (split-window (selected-window) 8)
         (switch-to-buffer b2)
         (other-window 1)
         (switch-to-buffer b3))
          => three-b
     (three-b "*scratch*" "declarations.texi" "*mail*")
          => nil


File: elisp,  Node: Interactive Call,  Next: Command Loop Info,  Prev: Defining Commands,  Up: Command Loop

Interactive Call
================

   After the command loop has translated a key sequence into a
definition, it invokes that definition using the function
`command-execute'.  If the definition is a function that is a command,
`command-execute' calls `call-interactively', which reads the arguments
and calls the command.  You can also call these functions yourself.

 - Function: commandp OBJECT
     Returns `t' if OBJECT is suitable for calling interactively; that
     is, if OBJECT is a command.  Otherwise, returns `nil'.

     The interactively callable objects include strings and vectors
     (treated as keyboard macros), lambda expressions that contain a
     top-level call to `interactive', byte-code function objects,
     autoload objects that are declared as interactive (non-`nil'
     fourth argument to `autoload'), and some of the primitive
     functions.

     A symbol is `commandp' if its function definition is `commandp'.

     Keys and keymaps are not commands.  Rather, they are used to look
     up commands (*note Keymaps::.).

     See `documentation' in *Note Accessing Documentation::, for a
     realistic example of using `commandp'.

 - Function: call-interactively COMMAND &optional RECORD-FLAG
     This function calls the interactively callable function COMMAND,
     reading arguments according to its interactive calling
     specifications.  An error is signaled if COMMAND cannot be called
     interactively (i.e., it is not a command).  Note that keyboard
     macros (strings and vectors) are not accepted, even though they
     are considered commands.

     If RECORD-FLAG is non-`nil', then this command and its arguments
     are unconditionally added to the list `command-history'.
     Otherwise, the command is added only if it uses the minibuffer to
     read an argument.  *Note Command History::.

 - Function: command-execute COMMAND &optional RECORD-FLAG
     This function executes COMMAND as an editing command.  The
     argument COMMAND must satisfy the `commandp' predicate; i.e., it
     must be an interactively callable function or a string.

     A string or vector as COMMAND is executed with
     `execute-kbd-macro'.  A function is passed to
     `call-interactively', along with the optional RECORD-FLAG.

     A symbol is handled by using its function definition in its place.
     A symbol with an `autoload' definition counts as a command if it
     was declared to stand for an interactively callable function.
     Such a definition is handled by loading the specified library and
     then rechecking the definition of the symbol.

 - Command: execute-extended-command PREFIX-ARGUMENT
     This function reads a command name from the minibuffer using
     `completing-read' (*note Completion::.).  Then it uses
     `command-execute' to call the specified command.  Whatever that
     command returns becomes the value of `execute-extended-command'.

     If the command asks for a prefix argument, the value
     PREFIX-ARGUMENT is supplied.  If `execute-extended-command' is
     called interactively, the current raw prefix argument is used for
     PREFIX-ARGUMENT, and thus passed on to whatever command is run.

     `execute-extended-command' is the normal definition of `M-x', so
     it uses the string `M-x ' as a prompt.  (It would be better to
     take the prompt from the events used to invoke
     `execute-extended-command', but that is painful to implement.)  A
     description of the value of the prefix argument, if any, also
     becomes part of the prompt.

          (execute-extended-command 1)
          ---------- Buffer: Minibuffer ----------
          M-x forward-word RET
          ---------- Buffer: Minibuffer ----------
               => t

 - Function: interactive-p
     This function returns `t' if the containing function (the one that
     called `interactive-p') was called interactively, with the function
     `call-interactively'.  (It makes no difference whether
     `call-interactively' was called from Lisp or directly from the
     editor command loop.)  Note that if the containing function was
     called by Lisp evaluation (or with `apply' or `funcall'), then it
     was not called interactively.

     The usual application of `interactive-p' is for deciding whether to
     print an informative message.  As a special exception,
     `interactive-p' returns `nil' whenever a keyboard macro is being
     run.  This is to suppress the informative messages and speed
     execution of the macro.

     For example:

          (defun foo ()
            (interactive)
            (and (interactive-p)
                 (message "foo")))
               => foo
          
          (defun bar ()
            (interactive)
            (setq foobar (list (foo) (interactive-p))))
               => bar
          
          ;; Type `M-x foo'.
               -| foo
          
          ;; Type `M-x bar'.
          ;; This does not print anything.
          
          foobar
               => (nil t)


File: elisp,  Node: Command Loop Info,  Next: Input Events,  Prev: Interactive Call,  Up: Command Loop

Information from the Command Loop
=================================

   The editor command loop sets several Lisp variables to keep status
records for itself and for commands that are run.

 - Variable: last-command
     This variable records the name of the previous command executed by
     the command loop (the one before the current command).  Normally
     the value is a symbol with a function definition, but this is not
     guaranteed.

     The value is set by copying the value of `this-command' when a
     command returns to the command loop, except when the command
     specifies a prefix argument for the following command.

 - Variable: this-command
     This variable records the name of the command now being executed by
     the editor command loop.  Like `last-command', it is normally a
     symbol with a function definition.

     This variable is set by the command loop just before the command
     is run, and its value is copied into `last-command' when the
     command finishes (unless the command specifies a prefix argument
     for the following command).

     Some commands change the value of this variable during their
     execution, simply as a flag for whatever command runs next.  In
     particular, the functions that kill text set `this-command' to
     `kill-region' so that any kill commands immediately following will
     know to append the killed text to the previous kill.

 - Function: this-command-keys
     This function returns a string or vector containing the key
     sequence that invoked the present command, plus any previous
     commands that generated the prefix argument for this command.  The
     value is a string if all those events were characters.  *Note
     Input Events::.

          (this-command-keys)
          ;; Now type `C-u C-x C-e'.
               => "^U^X^E"

 - Variable: last-nonmenu-event
     This variable holds the last input event read as part of a key
     sequence, aside from events resulting from mouse menus.

     One use of this variable is to figure out a good default location
     to pop up another menu.

 - Variable: last-command-event
 - Variable: last-command-char
     This variable is set to the last input event that was read by the
     command loop as part of a command.  The principal use of this
     variable is in `self-insert-command', which uses it to decide which
     character to insert.

          last-command-char
          ;; Now type `C-u C-x C-e'.
               => 5

     The value is 5 because that is the ASCII code for `C-e'.

     The alias `last-command-char' exists for compatibility with Emacs
     version 18.

 - Variable: last-event-frame
     This variable records which frame the last input event was
     directed to.  Usually this is the frame that was selected when the
     event was generated, but if that frame has redirected input focus
     to another frame, the value is the frame to which the event was
     redirected.  *Note Input Focus::.

 - Variable: echo-keystrokes
     This variable determines how much time should elapse before command
     characters echo.  Its value must be an integer, which specifies the
     number of seconds to wait before echoing.  If the user types a
     prefix key (say `C-x') and then delays this many seconds before
     continuing, the key `C-x' is echoed in the echo area.  Any
     subsequent characters in the same command will be echoed as well.

     If the value is zero, then command input is not echoed.


File: elisp,  Node: Input Events,  Next: Reading Input,  Prev: Command Loop Info,  Up: Command Loop

Input Events
============

   The Emacs command loop reads a sequence of "input events" that
represent keyboard or mouse activity.  The events for keyboard activity
are characters or symbols; mouse events are always lists.  This section
describes the representation and meaning of input events in detail.

   A command invoked using events that are lists can get the full
values of these events using the `e' interactive code.  *Note
Interactive Codes::.

   A key sequence that starts with a mouse event is read using the
keymaps of the buffer in the window that the mouse was in, not the
current buffer.  This does not imply that clicking in a window selects
that window or its buffer--that is entirely under the control of the
command binding of the key sequence.

 - Function: eventp OBJECT
     This function returns non-`nil' if EVENT is an input event.

* Menu:

* Keyboard Events::		Ordinary characters-keys with symbols on them.
* Function Keys::		Function keys-keys with names, not symbols.
* Click Events::		Pushing and releasing a mouse button.
* Drag Events::			Moving the mouse before releasing the button.
* Button-Down Events::		A button was pushed and not yet released.
* Repeat Events::               Double and triple click (or drag, or down).
* Motion Events::		Just moving the mouse, not pushing a button.
* Focus Events::		Moving the mouse between frames.
* Event Examples::		Examples of the lists for mouse events.
* Classifying Events::		Finding the modifier keys in an event symbol.
				Event types.
* Accessing Events::		Functions to extract info from events.
* Strings of Events::           Special considerations for putting
				  keyboard character events in a string.


File: elisp,  Node: Keyboard Events,  Next: Function Keys,  Up: Input Events

Keyboard Events
---------------

   There are two kinds of input you can get from the keyboard: ordinary
keys, and function keys.  Ordinary keys correspond to characters; the
events they generate are represented in Lisp as characters.  In Emacs
versions 18 and earlier, characters were the only events.

   An input character event consists of a "basic code" between 0 and
255, plus any or all of these "modifier bits":

meta
     The 2**23 bit in the character code indicates a character typed
     with the meta key held down.

control
     The 2**22 bit in the character code indicates a non-ASCII control
     character.

     ASCII control characters such as `C-a' have special basic codes of
     their own, so Emacs needs no special bit to indicate them.  Thus,
     the code for `C-a' is just 1.

     But if you type a control combination not in ASCII, such as `%'
     with the control key, the numeric value you get is the code for
     `%' plus 2**22 (assuming the terminal supports non-ASCII control
     characters).

shift
     The 2**21 bit in the character code indicates an ASCII control
     character typed with the shift key held down.

     For letters, the basic code indicates upper versus lower case; for
     digits and punctuation, the shift key selects an entirely different
     character with a different basic code.  In order to keep within
     the ASCII character set whenever possible, Emacs avoids using the
     2**21 bit for those characters.

     However, ASCII provides no way to distinguish `C-A' from `C-A', so
     Emacs uses the 2**21 bit in `C-A' and not in `C-a'.

hyper
     The 2**20 bit in the character code indicates a character typed
     with the hyper key held down.

super
     The 2**19 bit in the character code indicates a character typed
     with the super key held down.

alt
     The 2**18 bit in the character code indicates a character typed
     with the alt key held down.  (On some terminals, the key labeled
     ALT is actually the meta key.)

   In the future, Emacs may support a larger range of basic codes.  We
may also move the modifier bits to larger bit numbers.  Therefore, you
should avoid mentioning specific bit numbers in your program.  Instead,
the way to test the modifier bits of a character is with the function
`event-modifiers' (*note Classifying Events::.).


File: elisp,  Node: Function Keys,  Next: Click Events,  Prev: Keyboard Events,  Up: Input Events

Function Keys
-------------

   Most keyboards also have "function keys"--keys which have names or
symbols that are not characters.  Function keys are represented in Lisp
as symbols; the symbol's name is the function key's label.  For example,
pressing a key labeled F1 places the symbol `f1' in the input stream.

   For all keyboard events, the event type (which classifies the event
for key lookup purposes) is identical to the event--it is the character
or the symbol.  *Note Classifying Events::.

   Here are a few special cases in the symbol naming convention for
function keys:

`backspace', `tab', `newline', `return', `delete'
     These keys correspond to common ASCII control characters that have
     special keys on most keyboards.

     In ASCII, `C-i' and TAB are the same character.  Emacs lets you
     distinguish them if you wish, by returning the former as the
     integer 9, and the latter as the symbol `tab'.

     Most of the time, it's not useful to distinguish the two.  So
     normally `function-key-map' is set up to map `tab' into 9.  Thus, a
     key binding for character code 9 also applies to `tab'.  Likewise
     for the other symbols in this group.  The function `read-char'
     also converts these events into characters.

     In ASCII, BS is really `C-h'.  But `backspace' converts into the
     character code 127 (DEL), not into code 8 (BS).  This is what most
     users prefer.

`kp-add', `kp-decimal', `kp-divide', ...
     Keypad keys (to the right of the regular keyboard).

`kp-0', `kp-1', ...
     Keypad keys with digits.

`kp-f1', `kp-f2', `kp-f3', `kp-f4'
     Keypad PF keys.

`left', `up', `right', `down'
     Cursor arrow keys

   You can use the modifier keys CTRL, META, HYPER, SUPER, ALT and
SHIFT with function keys.  The way to represent them is with prefixes
in the symbol name:

`A-'
     The alt modifier.

`C-'
     The control modifier.

`H-'
     The hyper modifier.

`M-'
     The meta modifier.

`S-'
     The shift modifier.

`s-'
     The super modifier.

   Thus, the symbol for the key F3 with META held down is `M-F3'.  When
you use more than one prefix, we recommend you write them in
alphabetical order (though the order does not matter in arguments to
the key-binding lookup and modification functions).


File: elisp,  Node: Click Events,  Next: Drag Events,  Prev: Function Keys,  Up: Input Events

Click Events
------------

   When the user presses a mouse button and releases it at the same
location, that generates a "click" event.  Mouse click events have this
form:

     (EVENT-TYPE
      (WINDOW BUFFER-POS
       (COLUMN . ROW) TIMESTAMP)
      CLICK-COUNT)

   Here is what the elements normally mean:

EVENT-TYPE
     This is a symbol that indicates which mouse button was used.  It is
     one of the symbols `mouse-1', `mouse-2', ..., where the buttons
     are numbered numbered left to right.

     You can also use prefixes `A-', `C-', `H-', `M-', `S-' and `s-'
     for modifiers alt, control, hyper, meta, shift and super, just as
     you would with function keys.

     This symbol also serves as the event type of the event.  Key
     bindings describe events by their types; thus, if there is a key
     binding for `mouse-1', that binding would apply to all events whose
     EVENT-TYPE is `mouse-1'.

WINDOW
     This is the window in which the click occurred.

COLUMN
ROW
     These are the column and row of the click, relative to the top left
     corner of WINDOW, which is `(0 . 0)'.

BUFFER-POS
     This is the buffer position of the character clicked on.

TIMESTAMP
     This is the time at which the event occurred, in milliseconds.
     (Since this value wraps around the entire range of Emacs Lisp
     integers in about five hours, it is useful only for relating the
     times of nearby events.)

CLICK-COUNT
     This is the number of rapid repeated presses so far of the same
     mouse button.  *Note Repeat Events::.

   The meanings of BUFFER-POS, ROW and COLUMN are somewhat different
when the event location is in a special part of the screen, such as the
mode line or a scroll bar.

   If the location is in a scroll bar, then BUFFER-POS is the symbol
`vertical-scroll-bar' or `horizontal-scroll-bar', and the pair `(COLUMN
. ROW)' is replaced with a pair `(PORTION . WHOLE)', where PORTION is
the distance of the click from the top or left end of the scroll bar,
and WHOLE is the length of the entire scroll bar.

   If the position is on a mode line or the vertical line separating
WINDOW from its neighbor to the right, then BUFFER-POS is the symbol
`mode-line' or `vertical-line'.  For the mode line, ROW does not have
meaningful data.  For the vertical line, COLUMN does not have
meaningful data.

   BUFFER-POS may be a list containing a symbol (one of the symbols
listed above) instead of just the symbol.  This is what happens after
the imaginary prefix keys for these events are inserted into the input
stream.  *Note Key Sequence Input::.


File: elisp,  Node: Drag Events,  Next: Button-Down Events,  Prev: Click Events,  Up: Input Events

Drag Events
-----------

   With Emacs, you can have a drag event without even changing your
clothes.  A "drag event" happens every time the user presses a mouse
button and then moves the mouse to a different character position before
releasing the button.  Like all mouse events, drag events are
represented in Lisp as lists.  The lists record both the starting mouse
position and the final position, like this:

     (EVENT-TYPE
      (WINDOW1 BUFFER-POS1
       (COLUMN1 . ROW1) TIMESTAMP1)
      (WINDOW2 BUFFER-POS2
       (COLUMN2 . ROW2) TIMESTAMP2)
      CLICK-COUNT)

   For a drag event, the name of the symbol EVENT-TYPE contains the
prefix `drag-'.  The second and third elements of the event give the
starting and ending position of the drag.  Aside from that, the data
have the same meanings as in a click event (*note Click Events::.).  You
can access the second element of any mouse event in the same way, with
no need to distinguish drag events from others.

   The `drag-' prefix follows the modifier key prefixes such as `C-'
and `M-'.

   If `read-key-sequence' receives a drag event which has no key
binding, and the corresponding click event does have a binding, it
changes the drag event into a click event at the drag's starting
position.  This means that you don't have to distinguish between click
and drag events unless you want to.


File: elisp,  Node: Button-Down Events,  Next: Repeat Events,  Prev: Drag Events,  Up: Input Events

Button-Down Events
------------------

   Click and drag events happen when the user releases a mouse button.
They cannot happen earlier, because there is no way to distinguish a
click from a drag until the button is released.

   If you want to take action as soon as a button is pressed, you need
to handle "button-down" events.(1).  These occur as soon as a button is
pressed.  They are represented by lists which look exactly like click
events (*note Click Events::.), except that the name of EVENT-TYPE
contains the prefix `down-'.  The `down-' prefix follows the modifier
key prefixes such as `C-' and `M-'.

   The function `read-key-sequence', and the Emacs command loop, ignore
any button-down events that don't have command bindings.  This means
that you need not worry about defining button-down events unless you
want them to do something.  The usual reason to define a button-down
event is so that you can track mouse motion (by reading motion events)
until the button is released.  *Note Motion Events::.

   ---------- Footnotes ----------

   (1)  Button-down is the conservative antithesis of drag.

