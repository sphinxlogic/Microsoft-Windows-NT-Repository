This is Info file elisp, produced by Makeinfo-1.55 from the input file
elisp.texi.

   This version is newer than the second printed edition of the GNU
Emacs Lisp Reference Manual.  It corresponds to Emacs Version 19.19.

   Published by the Free Software Foundation 675 Massachusetts Avenue
Cambridge, MA 02139 USA

   Copyright (C) 1990, 1991, 1992, 1993 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: elisp,  Node: Auto-Saving,  Next: Reverting,  Prev: Backup Files,  Up: Backups and Auto-Saving

Auto-Saving
===========

   Emacs periodically saves all files that you are visiting; this is
called "auto-saving".  Auto-saving prevents you from losing more than a
limited amount of work if the system crashes.  By default, auto-saves
happen every 300 keystrokes, or after around 30 seconds of idle time.
*Note Auto-Save: (emacs)Auto-Save, for information on auto-save for
users.  Here we describe the functions used to implement auto-saving
and the variables that control them.

 - Variable: buffer-auto-save-file-name
     This buffer-local variable is the name of the file used for
     auto-saving the current buffer.  It is `nil' if the buffer should
     not be auto-saved.

          buffer-auto-save-file-name
          => "/xcssun/users/rms/lewis/#files.texi#"

 - Command: auto-save-mode ARG
     When used interactively without an argument, this command is a
     toggle switch: it turns on auto-saving of the current buffer if it
     is off, and vice-versa.  With an argument ARG, the command turns
     auto-saving on if the value of ARG is `t', a nonempty list, or a
     positive integer.  Otherwise, it turns auto-saving off.

 - Function: auto-save-file-name-p FILENAME
     This function returns a non-`nil' value if FILENAME is a string
     that could be the name of an auto-save file.  It works based on
     knowledge of the naming convention for auto-save files: a name that
     begins and ends with hash marks (`#') is a possible auto-save file
     name.  The argument FILENAME should not contain a directory part.

          (make-auto-save-file-name)
               => "/xcssun/users/rms/lewis/#files.texi#"
          (auto-save-file-name-p "#files.texi#")
               => 0
          (auto-save-file-name-p "files.texi")
               => nil

     The standard definition of this function is as follows:

          (defun auto-save-file-name-p (filename)
            "Return non-nil if FILENAME can be yielded by..."
            (string-match "^#.*#$" filename))

     This function exists so that you can customize it if you wish to
     change the naming convention for auto-save files.  If you redefine
     it, be sure to redefine the function `make-auto-save-file-name'
     correspondingly.

 - Function: make-auto-save-file-name
     This function returns the file name to use for auto-saving the
     current buffer.  This is just the file name with hash marks (`#')
     appended and prepended to it.  This function does not look at the
     variable `auto-save-visited-file-name'; that should be checked
     before this function is called.

          (make-auto-save-file-name)
               => "/xcssun/users/rms/lewis/#backup.texi#"

     The standard definition of this function is as follows:

          (defun make-auto-save-file-name ()
            "Return file name to use for auto-saves \
          of current buffer..."
            (if buffer-file-name
                (concat
                 (file-name-directory buffer-file-name)
                 "#"
                 (file-name-nondirectory buffer-file-name)
                 "#")
              (expand-file-name
               (concat "#%" (buffer-name) "#"))))

     This exists as a separate function so that you can redefine it to
     customize the naming convention for auto-save files.  Be sure to
     change `auto-save-file-name-p' in a corresponding way.

 - Variable: auto-save-visited-file-name
     If this variable is non-`nil', Emacs auto-saves buffers in the
     files they are visiting.  That is, the auto-save is done in the
     same file which you are editing.  Normally, this variable is
     `nil', so auto-save files have distinct names that are created by
     `make-auto-save-file-name'.

     When you change the value of this variable, the value does not take
     effect until the next time auto-save mode is reenabled in any given
     buffer.  If auto-save mode is already enabled, auto-saves continue
     to go in the same file name until `auto-save-mode' is called again.

 - Function: recent-auto-save-p
     This function returns `t' if the current buffer has been
     auto-saved since the last time it was read in or saved.

 - Function: set-buffer-auto-saved
     This function marks the current buffer as auto-saved.  The buffer
     will not be auto-saved again until the buffer text is changed
     again.  The function returns `nil'.

 - User Option: auto-save-interval
     The value of this variable is the number of characters that Emacs
     reads from the keyboard between auto-saves.  Each time this many
     more characters are read, auto-saving is done for all buffers in
     which it is enabled.

 - User Option: auto-save-timeout
     The value of this variable is the number of seconds of idle time
     that should cause auto-saving.  Each time the user pauses for this
     long, Emacs auto-saves any buffers that need it.  (Actually, the
     specified timeout is multiplied by a factor depending on the size
     of the current buffer.)

 - Variable: auto-save-hook
     This normal hook is run whenever an auto-save is about to happen.

 - User Option: auto-save-default
     If this variable is non-`nil', buffers that are visiting files
     have auto-saving enabled by default.  Otherwise, they do not.

 - Command: do-auto-save &optional NO-MESSAGE
     This function auto-saves all buffers that need to be auto-saved.
     This is all buffers for which auto-saving is enabled and that have
     been changed since the last time they were auto-saved.

     Normally, if any buffers are auto-saved, a message that says
     `Auto-saving...' is displayed in the echo area while auto-saving is
     going on.  However, if NO-MESSAGE is non-`nil', the message is
     inhibited.

 - Function: delete-auto-save-file-if-necessary
     This function deletes the current buffer's auto-save file if
     `delete-auto-save-files' is non-`nil'.  It is called every time a
     buffer is saved.

 - Variable: delete-auto-save-files
     This variable is used by the function
     `delete-auto-save-file-if-necessary'.  If it is non-`nil', Emacs
     deletes auto-save files when a true save is done (in the visited
     file).  This saves on disk space and unclutters your directory.

 - Function: rename-auto-save-file
     This function adjusts the current buffer's auto-save file name if
     the visited file name has changed.  It also renames an existing
     auto-save file.  If the visited file name has not changed, this
     function does nothing.


File: elisp,  Node: Reverting,  Prev: Auto-Saving,  Up: Backups and Auto-Saving

Reverting
=========

   If you have made extensive changes to a file and then change your
mind about them, you can get rid of them by reading in the previous
version of the file with the `revert-buffer' command.  *Note Reverting
a Buffer: (emacs)Reverting.

 - Command: revert-buffer &optional CHECK-AUTO-SAVE NOCONFIRM
     This command replaces the buffer text with the text of the visited
     file on disk.  This action undoes all changes since the file was
     visited or saved.

     If the argument CHECK-AUTO-SAVE is non-`nil', and the latest
     auto-save file is more recent than the visited file,
     `revert-buffer' asks the user whether to use that instead.
     Otherwise, it always uses the text of the visited file itself.
     Interactively, CHECK-AUTO-SAVE is set if there is a numeric prefix
     argument.

     When the value of the NOCONFIRM argument is non-`nil',
     `revert-buffer' does not ask for confirmation for the reversion
     action.  This means that the buffer contents are deleted and
     replaced by the text from the file on the disk, with no further
     opportunities for the user to prevent it.

     Since reverting works by deleting the entire text of the buffer and
     inserting the file contents, all the buffer's markers are
     relocated to point at the beginning of the buffer.  This is not
     "correct", but then, there is no way to determine what would be
     correct.  It is not possible to determine, from the text before
     and after, which characters after reversion correspond to which
     characters before.

     If the value of the `revert-buffer-function' variable is
     non-`nil', it is called as a function with no arguments to do the
     work.

 - Variable: revert-buffer-function
     The value of this variable is the function to use to revert this
     buffer; but if the value of this variable is `nil', then the
     `revert-buffer' function carries out its default action.  Modes
     such as Dired mode, in which the text being edited does not
     consist of a file's contents but can be regenerated in some other
     fashion, give this variable a buffer-local value that is a
     function to regenerate the contents.

 - Variable: revert-buffer-insert-file-contents-function
     The value of this variable, if non-`nil', is the function to use
     to insert contents when reverting this buffer.  The function
     receives two arguments, first the file name to use, and second,
     `t' if the user has asked to read the auto-save file.

 - Command: recover-file FILENAME
     This function visits FILENAME, but gets the contents from its last
     auto-save file.  This is useful after the system has crashed, to
     resume editing the same file without losing all the work done in
     the previous session.

     An error is signaled if there is no auto-save file for FILENAME,
     or if FILENAME is newer than its auto-save file.  If FILENAME does
     not exist, but its auto-save file does, then the auto-save file is
     read as usual.  This last situation may occur if you visited a
     nonexistent file and never actually saved it.


File: elisp,  Node: Buffers,  Next: Windows,  Prev: Backups and Auto-Saving,  Up: Top

Buffers
*******

   A "buffer" is a Lisp object containing text to be edited.  Buffers
are used to hold the contents of files that are being visited; there may
also be buffers which are not visiting files.  While several buffers may
exist at one time, exactly one buffer is designated the "current
buffer" at any time.  Most editing commands act on the contents of the
current buffer.  Each buffer, including the current buffer, may or may
not be displayed in any windows.

* Menu:

* Buffer Basics::       What is a buffer?
* Buffer Names::        Accessing and changing buffer names.
* Buffer File Name::    The buffer file name indicates which file is visited.
* Buffer Modification:: A buffer is "modified" if it needs to be saved.
* Modification Time::   Determining whether the visited file was changed
                         "behind Emacs's back".
* Read Only Buffers::   Modifying text is not allowed in a read-only buffer.
* The Buffer List::     How to look at all the existing buffers.
* Creating Buffers::    Functions that create buffers.
* Killing Buffers::     Buffers exist until explicitly killed.
* Current Buffer::      Designating a buffer as current
                          so primitives will access its contents.


File: elisp,  Node: Buffer Basics,  Next: Buffer Names,  Prev: Buffers,  Up: Buffers

Buffer Basics
=============

   A "buffer" is a Lisp object containing text to be edited.  Buffers
are used to hold the contents of files that are being visited; there may
also be buffers which are not visiting files.  While several buffers may
exist at one time, exactly one buffer is designated the "current
buffer" at any time.  Most editing commands act on the contents of the
current buffer.  Each buffer, including the current buffer, may or may
not be displayed in any windows.

   Buffers in Emacs editing are objects which have distinct names and
hold text that can be edited.  Buffers appear to Lisp programs as a
special data type.  The contents of a buffer may be viewed as an
extendable string; insertions and deletions may occur in any part of the
buffer.  *Note Text::.

   A Lisp buffer object contains numerous pieces of information.  Some
of this information is directly accessible to the programmer through
variables, while other information is only accessible through
special-purpose functions.  For example, the width of a tab character is
directly accessible through a variable, while the value of point is
accessible only through a primitive function.

   Buffer-specific information that is directly accessible is stored in
"buffer-local" variable bindings, which are variable values that are
effective only in a particular buffer.  This feature allows each buffer
to override the values of certain variables.  Most major modes override
variables such as `fill-column' or `comment-column' in this way.  For
more information about buffer-local variables and functions related to
them, see *Note Buffer-Local Variables::.

   For functions and variables related to visiting files in buffers, see
*Note Visiting Files:: and *Note Saving Buffers::.  For functions and
variables related to the display of buffers in windows, see *Note
Buffers and Windows::.

 - Function: bufferp OBJECT
     This function returns `t' if OBJECT is a buffer, `nil' otherwise.


File: elisp,  Node: Buffer Names,  Next: Buffer File Name,  Prev: Buffer Basics,  Up: Buffers

Buffer Names
============

   Each buffer has a unique name, which is a string.  Many of the
functions that work on buffers accept either a buffer or a buffer name
as an argument.  Any argument called BUFFER-OR-NAME is of this sort,
and an error is signaled if it is neither a string nor a buffer.  Any
argument called BUFFER is required to be an actual buffer object, not a
name.

   Buffers that are ephemeral and generally uninteresting to the user
have names starting with a space, which prevents them from being listed
by the `list-buffers' or `buffer-menu' commands.  (A name starting with
space also initially disables recording undo information; see *Note
Undo::.)

 - Function: buffer-name &optional BUFFER
     This function returns the name of BUFFER as a string.  If BUFFER
     is not supplied, it defaults to the current buffer.

     If `buffer-name' returns `nil', it means that BUFFER has been
     killed.  *Note Killing Buffers::.

          (buffer-name)
               => "buffers.texi"
          
          (setq foo (get-buffer "temp"))
               => #<buffer temp>
          (kill-buffer foo)
               => nil
          (buffer-name foo)
               => nil
          foo
               => #<killed buffer>

 - Command: rename-buffer NEWNAME &optional UNIQUE
     This function renames the current buffer to NEWNAME.  An error is
     signaled if NEWNAME is not a string, or if there is already a
     buffer with that name.  The function returns `nil'.

     Ordinarily, `rename-buffer' signals an error if NEWNAME is already
     in use.  However, if UNIQUE is non-`nil', it modifies NEWNAME to
     make a name that is not in use.  Interactively, you can make
     UNIQUE non-`nil' with a numeric prefix argument.

     One application of this command is to rename the `*shell*' buffer
     to some other name, thus making it possible to create a second
     shell buffer under the name `*shell*'.

 - Function: get-buffer BUFFER-OR-NAME
     This function returns the buffer specified by BUFFER-OR-NAME.  If
     BUFFER-OR-NAME is a string and there is no buffer with that name,
     the value is `nil'.  If BUFFER-OR-NAME is a buffer, it is returned
     as given.  (That is not very useful, so the argument is usually a
     name.)  For example:

          (setq b (get-buffer "lewis"))
               => #<buffer lewis>
          (get-buffer b)
               => #<buffer lewis>
          (get-buffer "Frazzle-nots")
               => nil

     See also the function `get-buffer-create' in *Note Creating
     Buffers::.

 - Function: generate-new-buffer-name STARTING-NAME
     This function returns a name that would be unique for a new
     buffer--but does not create the buffer.  It starts with
     STARTING-NAME, and produces a name not currently in use for any
     buffer by appending a number inside of `<...>'.

     See the related function `generate-new-buffer' in *Note Creating
     Buffers::.


File: elisp,  Node: Buffer File Name,  Next: Buffer Modification,  Prev: Buffer Names,  Up: Buffers

Buffer File Name
================

   The "buffer file name" is the name of the file that is visited in
that buffer.  When a buffer is not visiting a file, its buffer file name
is `nil'.  Most of the time, the buffer name is the same as the
nondirectory part of the buffer file name, but the buffer file name and
the buffer name are distinct and can be set independently.  *Note
Visiting Files::.

 - Function: buffer-file-name &optional BUFFER
     This function returns the absolute file name of the file that
     BUFFER is visiting.  If BUFFER is not visiting any file,
     `buffer-file-name' returns `nil'.  If BUFFER is not supplied, it
     defaults to the current buffer.

          (buffer-file-name (other-buffer))
               => "/usr/user/lewis/manual/files.texi"

 - Variable: buffer-file-name
     This buffer-local variable contains the name of the file being
     visited in the current buffer, or `nil' if it is not visiting a
     file.  It is a permanent local, unaffected by
     `kill-local-variables'.

          buffer-file-name
               => "/usr/user/lewis/manual/buffers.texi"

     It is risky to change this variable's value without doing various
     other things.  See the definition of `set-visited-file-name' in
     `files.el'; some of the things done there, such as changing the
     buffer name, are not strictly necessary, but others are essential
     to avoid confusing Emacs.

 - Variable: buffer-file-truename
     This buffer-local variable holds the truename of the file visited
     in the current buffer, or `nil' if no file is visited.  It is a
     permanent local, unaffected by `kill-local-variables'.  *Note
     Truenames::.

 - Variable: buffer-file-number
     This buffer-local variable holds the file number and directory
     device number of the file visited in the current buffer, or `nil'
     if no file or a nonexistent file is visited.  It is a permanent
     local, unaffected by `kill-local-variables'.  *Note Truenames::.

     The value is normally a list of the form `(FILENUM DEVNUM)'.  This
     pair of numbers uniquely identifies the file among all files
     accessible on the system.  See the function `file-attributes', in
     *Note File Attributes::, for more information about them.

 - Function: get-file-buffer FILENAME
     This function returns the buffer visiting file FILENAME.  If there
     is no such buffer, it returns `nil'.  The argument FILENAME, which
     must be a string, is expanded (*note File Name Expansion::.), then
     compared against the visited file names of all live buffers.

          (get-file-buffer "buffers.texi")
              => #<buffer buffers.texi>

     In unusual circumstances, there can be more than one buffer
     visiting the same file name.  In such cases, this function returns
     the first such buffer in the buffer list.

 - Command: set-visited-file-name FILENAME
     If FILENAME is a non-empty string, this function changes the name
     of the file visited in current buffer to FILENAME.  (If the buffer
     had no visited file, this gives it one.)  The *next time* the
     buffer is saved it will go in the newly-specified file.  This
     command marks the buffer as modified, since it does not (as far as
     Emacs knows) match the contents of FILENAME, even if it matched the
     former visited file.

     If FILENAME is `nil' or the empty string, that stands for "no
     visited file".  In this case, `set-visited-file-name' marks the
     buffer as having no visited file.

     When the function `set-visited-file-name' is called interactively,
     it prompts for FILENAME in the minibuffer.

     See also `clear-visited-file-modtime' and
     `verify-visited-file-modtime' in *Note Buffer Modification::.

 - Variable: list-buffers-directory
     This buffer-local variable records a string to display in a buffer
     listing in place of the visited file name, for buffers that don't
     have a visited file name.  Dired buffers use this variable.


File: elisp,  Node: Buffer Modification,  Next: Modification Time,  Prev: Buffer File Name,  Up: Buffers

Buffer Modification
===================

   Emacs keeps a flag called the "modified flag" for each buffer, to
record whether you have changed the text of the buffer.  This flag is
set to `t' whenever you alter the contents of the buffer, and cleared
to `nil' when you save it.  Thus, the flag shows whether there are
unsaved changes.  The flag value is normally shown in the mode line
(*note Mode Line Variables::.), and controls saving (*note Saving
Buffers::.) and auto-saving (*note Auto-Saving::.).

   Some Lisp programs set the flag explicitly.  For example, the
function `set-visited-file-name' sets the flag to `t', because the text
does not match the newly-visited file, even if it is unchanged from the
file formerly visited.

   The functions that modify the contents of buffers are described in
*Note Text::.

 - Function: buffer-modified-p &optional BUFFER
     This function returns `t' if the buffer BUFFER has been modified
     since it was last read in from a file or saved, or `nil'
     otherwise.  If BUFFER is not supplied, the current buffer is
     tested.

 - Function: set-buffer-modified-p FLAG
     This function marks the current buffer as modified if FLAG is
     non-`nil', or as unmodified if the flag is `nil'.

     Another effect of calling this function is to cause unconditional
     redisplay of the mode line for the current buffer.  In fact, the
     function `force-mode-line-update' works by doing this:

          (set-buffer-modified-p (buffer-modified-p))

 - Command: not-modified
     This command marks the current buffer as unmodified, and not
     needing to be saved.  Don't use this function in programs, since
     it prints a message in the echo area; use `set-buffer-modified-p'
     (above) instead.

 - Function: buffer-modified-tick &optional BUFFER
     This function returns BUFFER`s modification-count.  This is a
     counter that increments every time the buffer is modified.  If
     BUFFER is `nil' (or omitted), the current buffer is used.


File: elisp,  Node: Modification Time,  Next: Read Only Buffers,  Prev: Buffer Modification,  Up: Buffers

Comparison of Modification Time
===============================

   Suppose that you visit a file and make changes in its buffer, and
meanwhile the file itself is changed on disk.  At this point, saving the
buffer would overwrite the changes in the file.  Occasionally this may
be what you want, but usually it would lose valuable information.  Emacs
therefore checks the file's modification time using the functions
described below before saving the file.

 - Function: verify-visited-file-modtime BUFFER
     This function compares Emacs's record of the modification time for
     the file that the buffer is visiting against the actual
     modification time of the file as recorded by the operating system.
     The two should be the same unless some other process has written
     the file since Emacs visited or saved it.

     The function returns `t' if the last actual modification time and
     Emacs's recorded modification time are the same, `nil' otherwise.

 - Function: clear-visited-file-modtime
     This function clears out the record of the last modification time
     of the file being visited by the current buffer.  As a result, the
     next attempt to save this buffer will not complain of a
     discrepancy in file modification times.

     This function is called in `set-visited-file-name' and other
     exceptional places where the usual test to avoid overwriting a
     changed file should not be done.

 - Function: set-visited-file-modtime &optional TIME
     This function updates the buffer's record of the last modification
     time of the visited file, to the value specified by TIME if TIME
     is not `nil', and otherwise to the last modification time of the
     visited file.

     If TIME is not `nil', it should have the form `(HIGH . LOW)' or
     `(HIGH LOW)', in either case containing two integers, each of
     which holds 16 bits of the time.  (This is the same format that
     `file-attributes' uses to return time values; see *Note File
     Attributes::.)

     This function is useful if the buffer was not read from the file
     normally, or if the file itself has been changed for some known
     benign reason.

 - Function: visited-file-modtime
     This function returns the buffer's recorded last file modification
     time, as a list of the form `(HIGH . LOW)'.  Note that this is not
     identical to the last modification time of the file that is
     visited (though under normal circumstances the values are equal).

 - Function: ask-user-about-supersession-threat FN
     This function is used to ask a user how to proceed after an
     attempt to modify an obsolete buffer.  An "obsolete buffer" is an
     unmodified buffer for which the associated file on disk is newer
     than the last save-time of the buffer.  This means some other
     program has probably altered the file.

     This function is called automatically by Emacs on the proper
     occasions.  It exists so you can customize Emacs by redefining it.
     See the file `userlock.el' for the standard definition.

     Depending on the user's answer, the function may return normally,
     in which case the modification of the buffer proceeds, or it may
     signal a `file-supersession' error with data `(FN)', in which case
     the proposed buffer modification is not allowed.

     See also the file locking mechanism in *Note File Locks::.


File: elisp,  Node: Read Only Buffers,  Next: The Buffer List,  Prev: Modification Time,  Up: Buffers

Read-Only Buffers
=================

   A buffer may be designated as "read-only".  This means that the
buffer's contents may not be modified, although you may change your view
of the contents by scrolling, narrowing, or widening, etc.

   Read-only buffers are used in two kinds of situations:

   * A buffer visiting a file is made read-only if the file is
     write-protected.

     Here, the purpose is to show the user that editing the buffer with
     the aim of saving it in the file may be futile or undesirable.
     The user who wants to change the buffer text despite this can do
     so after clearing the read-only flag with the function
     `toggle-read-only'.

   * Modes such as Dired and Rmail make buffers read-only when altering
     the contents with the usual editing commands is probably a mistake.

     The special commands of the mode in question bind
     `buffer-read-only' to `nil' (with `let') around the places where
     they change the text.

 - Variable: buffer-read-only
     This buffer-local variable specifies whether the buffer is
     read-only.  The buffer is read-only if this variable is non-`nil'.

 - Variable: inhibit-read-only
     If this variable is non-`nil', then read-only buffers and read-only
     characters may be modified.  The value of `buffer-read-only' does
     not matter when `inhibit-read-only' is non-`nil'.

     If `inhibit-read-only' is `t', all `read-only' text properties
     have no effect (*note Special Properties::.).  If
     `inhibit-read-only' is a list, then `read-only' text properties
     are ignored if they are members of the list (comparison is done
     with `eq').

 - Command: toggle-read-only
     This command changes whether the current buffer is read-only.  It
     is intended for interactive use; don't use it in programs.  At any
     given point in a program, you should know whether you want the
     read-only flag on or off; so you can set `buffer-read-only'
     explicitly to the proper value, `t' or `nil'.

 - Function: barf-if-buffer-read-only
     This function signals a `buffer-read-only' error if the current
     buffer is read-only.  *Note Interactive Call::, for another way to
     signal an error if the current buffer is read-only.


File: elisp,  Node: The Buffer List,  Next: Creating Buffers,  Prev: Read Only Buffers,  Up: Buffers

The Buffer List
===============

   The "buffer list" is a list of all buffers that have not been
killed.  The order of the buffers in the list is based primarily on how
recently each buffer has been displayed in the selected window.  Several
functions, notably `other-buffer', make use of this ordering.

 - Function: buffer-list
     This function returns a list of all buffers, including those whose
     names begin with a space.  The elements are actual buffers, not
     their names.

          (buffer-list)
               => (#<buffer buffers.texi>
                   #<buffer  *Minibuf-1*> #<buffer buffer.c>
                   #<buffer *Help*> #<buffer TAGS>)
          
          ;; Note that the name of the minibuffer
          ;;   begins with a space!
          
          (mapcar (function buffer-name) (buffer-list))
              => ("buffers.texi" " *Minibuf-1*"
                   "buffer.c" "*Help*" "TAGS")

     Buffers appear earlier in the list if they were current more
     recently.

     This list is a copy of a list used inside Emacs; modifying it has
     no effect on the buffers.

 - Function: other-buffer &optional BUFFER-OR-NAME VISIBLE-OK
     This function returns the first buffer in the buffer list other
     than BUFFER-OR-NAME.  Usually this is the buffer most recently
     shown in the selected window, aside from BUFFER-OR-NAME.  Buffers
     are moved to the front of the list when they are selected and to
     the end when they are buried.  Buffers whose names start with a
     space are not even considered.

     If BUFFER-OR-NAME is not supplied (or if it is not a buffer), then
     `other-buffer' returns the first buffer on the buffer list that is
     not visible in any window in a visible frame.

     Normally, `other-buffer' avoids returning a buffer visible in any
     window on any visible frame, except as a last resort.  However, if
     VISIBLE-OK is non-`nil', then a buffer displayed in some window is
     admissible to return.

     If no suitable buffer exists, the buffer `*scratch*' is returned
     (and created, if necessary).

 - Command: list-buffers &optional FILES-ONLY
     This function displays a listing of the names of existing buffers.
     It clears the buffer `*Buffer List*', then inserts the listing
     into that buffer and displays it in a window.  `list-buffers' is
     intended for interactive use, and is described fully in `The GNU
     Emacs Manual'.  It returns `nil'.

 - Command: bury-buffer &optional BUFFER-OR-NAME
     This function puts BUFFER-OR-NAME at the end of the buffer list
     without changing the order of any of the other buffers on the list.
     This buffer therefore becomes the least desirable candidate for
     `other-buffer' to return, and appears last in the list displayed by
     `list-buffers'.

     If BUFFER-OR-NAME is `nil' or omitted, this means to bury the
     current buffer.  In addition, this switches to some other buffer
     (obtained using `other-buffer') in the selected window.  If the
     buffer is displayed in a window other than the selected one, it
     remains there.

     If you wish to remove a buffer from all the windows that display
     it, you can do so with a loop that uses `get-buffer-window'.
     *Note Buffers and Windows::.


File: elisp,  Node: Creating Buffers,  Next: Killing Buffers,  Prev: The Buffer List,  Up: Buffers

Creating Buffers
================

   This section describes the two primitives for creating buffers.
`get-buffer-create' creates a buffer if it finds no existing buffer;
`generate-new-buffer' always creates a new buffer, and gives it a
unique name.

   Other functions you can use to create buffers include
`with-output-to-temp-buffer' (*note Temporary Displays::.) and
`create-file-buffer' (*note Visiting Files::.).

 - Function: get-buffer-create NAME
     This function returns a buffer named NAME.  If such a buffer
     already exists, it is returned.  If such a buffer does not exist,
     one is created and returned.  The buffer does not become the
     current buffer--this function does not change which buffer is
     current.

     An error is signaled if NAME is not a string.

          (get-buffer-create "foo")
               => #<buffer foo>

     The major mode for the new buffer is set by the value of
     `default-major-mode'.  *Note Auto Major Mode::.

 - Function: generate-new-buffer NAME
     This function returns a newly created, empty buffer, but does not
     make it current.  If there is no buffer named NAME, then that is
     the name of the new buffer.  If that name is in use, this function
     adds suffixes of the form `<N>' are added to NAME, where N is an
     integer.  It tries successive integers starting with 2 until it
     finds an available name.

     An error is signaled if NAME is not a string.

          (generate-new-buffer "bar")
               => #<buffer bar>
          (generate-new-buffer "bar")
               => #<buffer bar<2>>
          (generate-new-buffer "bar")
               => #<buffer bar<3>>

     The major mode for the new buffer is set by the value of
     `default-major-mode'.  *Note Auto Major Mode::.

     See the related function `generate-new-buffer-name' in *Note
     Buffer Names::.


File: elisp,  Node: Killing Buffers,  Next: Current Buffer,  Prev: Creating Buffers,  Up: Buffers

Killing Buffers
===============

   "Killing a buffer" makes its name unknown to Emacs and makes its
space available for other use.

   The buffer object for the buffer which has been killed remains in
existence as long as anything refers to it, but it is specially marked
so that you cannot make it current or display it.  Killed buffers retain
their identity, however; two distinct buffers, when killed, remain
distinct according to `eq'.

   If you kill a buffer that is current or displayed in a window, Emacs
automatically selects or displays some other buffer instead.  This means
that killing a buffer can in general change the current buffer.
Therefore, when you kill a buffer, you should also take the precautions
associated with changing the current buffer (unless you happen to know
that the buffer being killed isn't current).  *Note Current Buffer::.

   The `buffer-name' of a killed buffer is `nil'.  You can use this
feature to test whether a buffer has been killed:

     (defun killed-buffer-p (buffer)
       "Return t if BUFFER is killed."
       (not (buffer-name buffer)))

 - Command: kill-buffer BUFFER-OR-NAME
     This function kills the buffer BUFFER-OR-NAME, freeing all its
     memory for use as space for other buffers.  (Emacs version 18 and
     older was unable to return the memory to the operating system.)
     It returns `nil'.

     Any processes that have this buffer as the `process-buffer' are
     sent the `SIGHUP' signal, which normally causes them to terminate.
     (The usual meaning of `SIGHUP' is that a dialup line has been
     disconnected.)  *Note Deleting Processes::.

     If the buffer is visiting a file when `kill-buffer' is called and
     the buffer has not been saved since it was last modified, the user
     is asked to confirm before the buffer is killed.  This is done
     even if `kill-buffer' is not called interactively.  To prevent the
     request for confirmation, clear the modified flag before calling
     `kill-buffer'.  *Note Buffer Modification::.

     Just before actually killing the buffer, after asking all
     questions, `kill-buffer' runs the normal hook `kill-buffer-hook'.
     The buffer to be killed is current when the hook functions run.
     *Note Hooks::.

     Killing a buffer that is already dead has no effect.

          (kill-buffer "foo.unchanged")
               => nil
          (kill-buffer "foo.changed")
          
          ---------- Buffer: Minibuffer ----------
          Buffer foo.changed modified; kill anyway? (yes or no) `yes'
          ---------- Buffer: Minibuffer ----------
          
               => nil


File: elisp,  Node: Current Buffer,  Prev: Killing Buffers,  Up: Buffers

The Current Buffer
==================

   There are, in general, many buffers in an Emacs session.  At any
time, one of them is designated as the "current buffer".  This is the
buffer in which most editing takes place, because most of the primitives
for examining or changing text in a buffer operate implicitly on the
current buffer (*note Text::.).  Normally the buffer that is displayed
on the screen in the selected window is the current buffer, but this is
not always so: a Lisp program can designate any buffer as current
temporarily in order to operate on its contents, without changing what
is displayed on the screen.

   The way to designate a current buffer in a Lisp program is by calling
`set-buffer'.  The specified buffer remains current until a new one is
designated.

   When an editing command returns to the editor command loop, the
command loop designates the buffer displayed in the selected window as
current, to prevent confusion: the buffer that the cursor is in, when
Emacs reads a command, is the one to which the command will apply.
(*Note Command Loop::.)  Therefore, `set-buffer' is not usable for
switching visibly to a different buffer so that the user can edit it.
For this, you must use the functions described in *Note Displaying
Buffers::.

   However, Lisp functions that change to a different current buffer
should not leave it to the command loop to set it back afterwards.
Editing commands written in Emacs Lisp can be called from other programs
as well as from the command loop.  It is convenient for the caller if
the subroutine does not change which buffer is current (unless, of
course, that is the subroutine's purpose).  Therefore, you should
normally use `set-buffer' within a `save-excursion' that will restore
the current buffer when your program is done (*note Excursions::.).
Here is an example, the code for the command `append-to-buffer' (with
the documentation string abridged):

     (defun append-to-buffer (buffer start end)
       "Append to specified buffer the text of the region..."
       (interactive "BAppend to buffer: \nr")
       (let ((oldbuf (current-buffer)))
         (save-excursion
           (set-buffer (get-buffer-create buffer))
           (insert-buffer-substring oldbuf start end))))

This function binds a local variable to the current buffer, and then
`save-excursion' records the values of point, the mark, and the
original buffer.  Next, `set-buffer' makes another buffer current.
Finally, `insert-buffer-substring' copies the string from the original
current buffer to the new current buffer.

   If the buffer appended to happens to be displayed in some window,
then the next redisplay will show how its text has changed.  Otherwise,
you will not see the change immediately on the screen.  The buffer
becomes current temporarily during the execution of the command, but
this does not cause it to be displayed.

   Changing the current buffer between the binding and unbinding of a
buffer-local variable can cause it to be bound in one buffer, and then
unbound in another!  You can avoid this problem by using save-excursion
to make sure that the buffer from which the variable was bound is
current again whenever the variable is unbound.

     (let (buffer-read-only)
       (save-excursion
         (set-buffer ...)
         ...))

 - Function: current-buffer
     This function returns the current buffer.

          (current-buffer)
               => #<buffer buffers.texi>

 - Function: set-buffer BUFFER-OR-NAME
     This function makes BUFFER-OR-NAME the current buffer.  However,
     it does not display the buffer in the currently selected window or
     in any other window.  This means that the user cannot necessarily
     see the buffer, but Lisp programs can in any case work on it.

     This function returns the buffer identified by BUFFER-OR-NAME.  An
     error is signaled if BUFFER-OR-NAME does not identify an existing
     buffer.


File: elisp,  Node: Windows,  Next: Frames,  Prev: Buffers,  Up: Top

Windows
*******

   This chapter describes most of the functions and variables related to
Emacs windows.  See *Note Display::, for information on how text is
displayed in windows.

* Menu:

* Basic Windows::          Basic information on using windows.
* Splitting Windows::      Splitting one window into two windows.
* Deleting Windows::       Deleting a window gives its space to other windows.
* Selecting Windows::      The selected window is the one that you edit in.
* Cyclic Window Ordering:: Moving around the existing windows.
* Buffers and Windows::    Each window displays the contents of a buffer.
* Displaying Buffers::     Higher-lever functions for displaying a buffer
                             and choosing a window for it.
* Choosing Window::	   How to choose a window for displaying a buffer.
* Window Point::           Each window has its own location of point.
* Window Start::           The display-start position controls which text
                             is on-screen in the window.
* Vertical Scrolling::     Moving text up and down in the window.
* Horizontal Scrolling::   Moving text sideways on the window.
* Size of Window::         Accessing the size of a window.
* Resizing Windows::       Changing the size of a window.
* Coordinates and Windows::Converting coordinates to windows.
* Window Configurations::  Saving and restoring the state of the screen.


File: elisp,  Node: Basic Windows,  Next: Splitting Windows,  Up: Windows

Basic Concepts of Emacs Windows
===============================

   A "window" is the physical area of the screen in which a buffer is
displayed.  The term is also used to refer to a Lisp object which
represents that screen area in Emacs Lisp.  It should be clear from the
context which is meant.

   There is always at least one window displayed on the screen, and
there is exactly one window that we call the "selected window".  The
cursor is in the selected window.  The selected window's buffer is
usually the current buffer (except when `set-buffer' has been used.)
*Note Current Buffer::.

   For all intents, a window only exists while it is displayed on the
terminal.  Once removed from the display, the window is effectively
deleted and should not be used, *even though there may still be
references to it* from other Lisp objects.  Restoring a saved window
configuration is the only way for a window no longer on the screen to
come back to life.  (*Note Deleting Windows::.)

   Each window has the following attributes:

   * containing frame

   * window height

   * window width

   * window edges with respect to the screen or frame

   * the buffer it displays

   * position within the buffer at the upper left of the window

   * the amount of horizontal scrolling, in columns

   * point

   * the mark

   * how recently the window was selected

   Applications use multiple windows for a variety of reasons, but most
often to give different views of the same information.  In Rmail, for
example, you can move through a summary buffer in one window while the
other window shows messages one at a time as they are reached.

   The term "window" in Emacs means something similar to what it means
in the context of general purpose window systems such as X, but not
identical.  The X Window System subdivides the screen into X windows;
Emacs uses one or more X windows, called "frames" in Emacs terminology,
and subdivides each of them into (nonoverlapping) Emacs windows.  When
you use Emacs on an ordinary display terminal, Emacs subdivides the
terminal screen into Emacs windows.

   Most window systems support arbitrarily located overlapping windows.
In contrast, Emacs windows are "tiled"; they never overlap, and
together they fill the whole of the screen or frame.  Because of the way
in which Emacs creates new windows and resizes them, you can't create
every conceivable tiling on an Emacs screen.  *Note Splitting Windows::.
Also, see *Note Size of Window::.

   *Note Display::, for information on how the contents of the window's
buffer are displayed in the window.

 - Function: windowp OBJECT
     This function returns `t' if OBJECT is a window.


File: elisp,  Node: Splitting Windows,  Next: Deleting Windows,  Prev: Basic Windows,  Up: Windows

Splitting Windows
=================

   The functions described here are the primitives used to split a
window into two windows.  Two higher level functions sometimes split a
window, but not always: `pop-to-buffer' and `display-buffer' (*note
Displaying Buffers::.).

   The functions described here do not accept a buffer as an argument.
They let the two "halves" of the split window display the same buffer
previously visible in the window that was split.

 - Function: one-window-p &optional NO-MINI
     This function returns non-`nil' if there is only one window.  The
     argument NO-MINI, if non-`nil', means don't count the minibuffer
     even if it is active; otherwise, the minibuffer window is
     included, if active, in the total number of windows which is
     compared against one.

 - Command: split-window &optional WINDOW SIZE HORIZONTAL
     This function splits WINDOW into two windows.  The original window
     WINDOW remains the selected window, but occupies only part of its
     former screen area.  The rest is occupied by a newly created
     window which is returned as the value of this function.

     If HORIZONTAL is non-`nil', then WINDOW splits side by side,
     keeping the leftmost SIZE columns and giving the rest of the
     columns to the new window.  Otherwise, it splits into halves one
     above the other, keeping the upper SIZE lines and giving the rest
     of the lines to the new window.  The original window is therefore
     the right-hand or upper of the two, and the new window is the
     left-hand or lower.

     If WINDOW is omitted or `nil', then the selected window is split.
     If SIZE is omitted or `nil', then WINDOW is divided evenly into
     two parts.  (If there is an odd line, it is allocated to the new
     window.)  When `split-window' is called interactively, all its
     arguments are `nil'.

     The following example starts with one window on a screen that is 50
     lines high by 80 columns wide; then the window is split.

          (setq w (selected-window))
               => #<window 8 on windows.texi>
          (window-edges)          ; Edges in order:
               => (0 0 80 50)     ;   left--top--right--bottom

          ;; Returns window created
          (setq w2 (split-window w 15))
               => #<window 28 on windows.texi>

          (window-edges w2)
               => (0 15 80 50)    ; Bottom window;
                                  ;   top is line 15

          (window-edges w)
               => (0 0 80 15)     ; Top window

     The screen looks like this:

          __________
                  |          |  line 0
                  |    w     |
                  |__________|
                  |          |  line 15
                  |    w2    |
                  |__________|
                                line 50
           column 0   column 80

     Next, the top window is split horizontally:

          (setq w3 (split-window w 35 t))
               => #<window 32 on windows.texi>

          (window-edges w3)
               => (35 0 80 15)  ; Left edge at column 35

          (window-edges w)
               => (0 0 35 15)   ; Right edge at column 35

          (window-edges w2)
               => (0 15 80 50)  ; Bottom window unchanged

     Now, the screen looks like this:

          column 35
                   __________
                  |   |      |  line 0
                  | w |  w3  |
                  |___|______|
                  |          |  line 15
                  |    w2    |
                  |__________|
                                line 50
           column 0   column 80

 - Command: split-window-vertically SIZE
     This function splits the selected window into two windows, one
     above the other, leaving the selected window with SIZE lines.

     This function is simply an interface to `split-windows'.  Here is
     the complete function definition for it:

          (defun split-window-vertically (&optional arg)
            "Split selected window into two windows,
          one above the other..."
            (interactive "P")
            (split-window nil (and arg (prefix-numeric-value arg))))

 - Command: split-window-horizontally SIZE
     This function splits the selected window into two windows
     side-by-side, leaving the selected window with SIZE columns.

     This function is simply an interface to `split-windows'.  Here is
     the complete definition for `split-window-horizontally' (except for
     part of the documentation string):

          (defun split-window-horizontally (&optional arg)
            "Split selected window into two windows
          side by side..."
            (interactive "P")
            (split-window nil (and arg (prefix-numeric-value arg)) t))

