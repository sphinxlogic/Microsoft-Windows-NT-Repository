


EXPECT(1)                USER COMMANDS                  EXPECT(1)



NNNNAAAAMMMMEEEE
     expect - programmed dialogue with interactive programs

SSSSYYYYNNNNOOOOPPPPSSSSIIIISSSS
     eeeexxxxppppeeeecccctttt [ ----ddddiiiinnnnNNNN ] [ ----cccc _c_m_d_s ] [[ ----ffff ] _c_m_d_f_i_l_e ] [ _a_r_g_s ]

IIIINNNNTTTTRRRROOOODDDDUUUUCCCCTTTTIIIIOOOONNNN
     eeeexxxxppppeeeecccctttt is a program that "talks" to other  interactive  pro-
     grams  according  to a script.  Following the script, eeeexxxxppppeeeecccctttt
     knows what can be expected  from  a  program  and  what  the
     correct  response  should  be.  An interpreted language pro-
     vides branching and high-level control structures to  direct
     the  dialogue.   (Alternatively,  the  user  may  use  the C
     language directly.  See  libexpect(3).)   In  addition,  the
     user  can  take  control and interact directly when desired,
     afterward returning control to the script.

     The  name  "expect"  comes  from  the  idea  of  _s_e_n_d/_e_x_p_e_c_t
     sequences  popularized  by uucp, kermit and other modem con-
     trol programs.  However unlike uucp, eeeexxxxppppeeeecccctttt  is  generalized
     so  that it can be run as a user-level command with any pro-
     gram and task in mind.  (eeeexxxxppppeeeecccctttt can actually talk to several
     programs at the same time.)

     For example, here are some things eeeexxxxppppeeeecccctttt can do:

          +o   Cause your computer to dial you back, so  that  you
              can login without paying for the call.

          +o   Start a game (e.g., rogue) and if the optimal  con-
              figuration  doesn't  appear,  restart it (again and
              again) until it does, then  hand  over  control  to
              you.

          +o   Run fsck, and in response to its questions,  answer
              "yes",  "no"  or give control back to you, based on
              predetermined criteria.

          +o   Connect to another network or BBS (e.g., MCI  Mail,
              CompuServe) and automatically retrieve your mail so
              that it appears as if it  was  originally  sent  to
              your local system.

          +o   Carry environment variables, current directory,  or
              any kind of information across rlogin, telnet, tip,
              su, chgrp, etc.

     There are a variety of reasons why the shell cannot  perform
     these  tasks.   (Try,  you'll  see.)   All are possible with
     eeeexxxxppppeeeecccctttt.





AT&T Bell LaboratoriesLast change: 22 October 1992                 1






EXPECT(1)                USER COMMANDS                  EXPECT(1)



     In general, eeeexxxxppppeeeecccctttt is useful for running any  program  which
     requires  interaction between the program and the user.  All
     that is necessary is that the interaction can be  character-
     ized  programmatically.   eeeexxxxppppeeeecccctttt can also give the user back
     control (without halting the program  being  controlled)  if
     desired.   Similarly,  the  user  can  return control to the
     _s_e_n_d/_e_x_p_e_c_t script at any time.

UUUUSSSSAAAAGGGGEEEE
     eeeexxxxppppeeeecccctttt reads _c_m_d_f_i_l_e for a  list  of  commands  to  execute.
     eeeexxxxppppeeeecccctttt  may also be invoked implicitly on systems which sup-
     port the #! notation by marking the script  executable,  and
     making the first line in your script:

          #!/usr/local/bin/expect -f

     Of course, the path must accurately  describe  where  eeeexxxxppppeeeecccctttt
     lives.  /usr/local/bin is just an example.

     The ----cccc flag prefaces a command to be executed before any  in
     the  script.   The command should be quoted to prevent being
     broken up by the shell.  This option may  be  used  multiple
     times.   Multiple  commands may be executed with a single -c
     by separating them with semicolons.  Commands  are  executed
     in the order they appear.

     The ----dddd flag enables some debugging output,  which  primarily
     reports  internal  activity  of  commands such as eeeexxxxppppeeeecccctttt and
     iiiinnnntttteeeerrrraaaacccctttt.  This flag has the same effect as "debug 1" at the
     beginning of an expect script, plus the version of eeeexxxxppppeeeecccctttt is
     printed.  (The ssssttttrrrraaaacccceeee command is useful for  tracing  state-
     ments,  and the ttttrrrraaaacccceeee command is useful for tracing variable
     assignments.)

     The ----ffff flag prefaces a file  from  which  to  read  commands
     from.  The flag itself is optional as it is only useful when
     using the #! notation (see above), so that  other  arguments
     may be supplied on the command line.

     If the string "-" is supplied as a filename, standard  input
     is  read  instead.   (Use "./-" to read from a file actually
     named "-".)

     The ----iiii flag causes eeeexxxxppppeeeecccctttt to interactively prompt  for  com-
     mands  instead  of  reading  them from a file.  Prompting is
     terminated via the eeeexxxxiiiitttt command or  upon  EOF.   See  iiiinnnntttteeeerrrr----
     pppprrrreeeetttteeeerrrr  (below) for more information.  ----iiii is assumed if nei-
     ther a command file nor ----cccc is used.

     -------- may be used to delimit the end of the options.   This  is
     useful  if  you want to pass an option-like argument to your
     script without it being interpreted  by  eeeexxxxppppeeeecccctttt.   This  can



AT&T Bell LaboratoriesLast change: 22 October 1992                 2






EXPECT(1)                USER COMMANDS                  EXPECT(1)



     usefully  be  placed in the #! line to prevent any flag-like
     interpretation by expect.  For example, the  following  will
     leave  the original arguments (including the script name) in
     the variable _a_r_g_v.

          #!/usr/local/bin/expect --

     Note that the usual getopt(3) and execve(2) conventions must
     be observed when adding arguments to the #! line.

     The file $expect_library/expect.rc is sourced  automatically
     if  present,  unless the ----NNNN flag is used.  Immediately after
     this, the file ~/.expect.rc is sourced automatically, unless
     the  ----nnnn  flag is used.  Both of these are sourced after exe-
     cuting any ----cccc flags.

     Optional _a_r_g_s are constructed into a list and stored in  the
     variable  named  _a_r_g_v.   _a_r_g_v may be accessed with the usual
     list access commands.  For example, the length  of  _a_r_g_v  is
     calculated by "llength $argv".

     _a_r_g_v[_0] is defined to be the name of the script.  For  exam-
     ple, the following prints out the name of the script and the
     first two arguments:

          send_user [lrange $argv 0 2]


CCCCOOOOMMMMMMMMAAAANNNNDDDDSSSS
     eeeexxxxppppeeeecccctttt uses _T_c_l (Tool Command Language).  Tcl provides  con-
     trol  flow (e.g., if, for, break), expression evaluation and
     several other features such as recursion, procedure  defini-
     tion,  etc.   Commands used here but not defined (e.g., sssseeeetttt,
     iiiiffff, eeeexxxxeeeecccc) are Tcl commands (see  tcl(3)).   eeeexxxxppppeeeecccctttt  supports
     additional  commands,  described  below.   Unless  otherwise
     specified, commands return the empty string.

     Commands are listed  alphabetically  so  that  they  can  be
     quickly  located.   However, new users may find it easier to
     start by reading the descriptions of  ssssppppaaaawwwwnnnn,  sssseeeennnndddd,  eeeexxxxppppeeeecccctttt,
     and  iiiinnnntttteeeerrrraaaacccctttt, in that order.  Then read the examples at the
     rear of this man page.

     cccclllloooosssseeee [-_i _s_p_a_w_n__i_d]
               closes the  connection  to  the  current  process.
               Most interactive programs will detect EOF on their
               stdin and exit; thus  cccclllloooosssseeee  usually  suffices  to
               kill  the  process  as well.  The ----iiii flag declares
               the process to close corresponding  to  the  named
               spawn_id.

               Both eeeexxxxppppeeeecccctttt and  iiiinnnntttteeeerrrraaaacccctttt  will  detect  when  the



AT&T Bell LaboratoriesLast change: 22 October 1992                 3






EXPECT(1)                USER COMMANDS                  EXPECT(1)



               current  process  exits and implicitly do a cccclllloooosssseeee.
               But if you kill the process by,  say,  "exec  kill
               $pid", you will need to explicitly call cccclllloooosssseeee.

               No matter whether the connection is closed  impli-
               citly or explicitly, you should call wwwwaaaaiiiitttt to clear
               up the corresponding kernel process  slot.   cccclllloooosssseeee
               does  not  call  wwwwaaaaiiiitttt  since there is no guarantee
               that closing a process connection will cause it to
               exit.  See wwwwaaaaiiiitttt below for more info.

     ddddeeeebbbbuuuugggg [-_f _f_i_l_e] _v_a_l_u_e
               causes further commands to send debugging informa-
               tion  internal  to  eeeexxxxppppeeeecccctttt  to  stderr if _v_a_l_u_e is
               non-zero.  This output is disabled if _v_a_l_u_e is  0.
               The debugging information includes every character
               received, and every  attempt  made  to  match  the
               current output against the patterns.

               If the optional _f_i_l_e is supplied, all  normal  and
               debugging  output is written to that file (regard-
               less of the value of _v_a_l_u_e).  Any previous  debug-
               ging output file is closed.

     ddddiiiissssccccoooonnnnnnnneeeecccctttt
               disconnects a forked process  from  the  terminal.
               It  continues running in the background.  The pro-
               cess is given its own process group (if possible).
               Standard I/O is redirected to /dev/null.

               The following fragment uses ddddiiiissssccccoooonnnnnnnneeeecccctttt to continue
               running the script in the background.

                     if [fork]!=0 exit
                     disconnect
                     . . .

               The following script reads a  password,  and  then
               runs  a program every hour that demands a password
               each time it is  run.   The  script  supplies  the
               password  so  that  you only have to type it once.
               (See the ssssyyyysssstttteeeemmmm command which demonstrates how  to
               turn off password echoing.)

                     send_user "password?\ "
                     expect_user -re "(.*)\n"
                     for {} 1 {} {
                           if [fork]!=0 {exec sleep 3600;continue}
                           disconnect
                           spawn priv_prog
                           expect Password:
                           send "$expect_out(1,string)\r"



AT&T Bell LaboratoriesLast change: 22 October 1992                 4






EXPECT(1)                USER COMMANDS                  EXPECT(1)



                           . . .
                           exit
                     }

               An advantage to using ddddiiiissssccccoooonnnnnnnneeeecccctttt  over  the  shell
               asynchronous  process  feature  (&) is that eeeexxxxppppeeeecccctttt
               can save the terminal parameters prior to  discon-
               nection,  and  then  later apply them to new ptys.
               With &, eeeexxxxppppeeeecccctttt does not have a chance to read  the
               terminal's   parameters   since  the  terminal  is
               already disconnected by the time  eeeexxxxppppeeeecccctttt  receives
               control.

     eeeexxxxiiiitttt [_s_t_a_t_u_s]
               kills  eeeexxxxppppeeeecccctttt.    All   connections   to   spawned
               processes are closed.  Closure will be detected as
               an EOF by spawned processes.

               Exit generates a signal 0 (see ttttrrrraaaapppp),  but  other-
               wise takes no other actions beyond what the normal
               _exit(2) procedure does.  Thus, spawned  processes
               that do not check for EOF may continue to run.  (A
               variety of conditions are important  to  determin-
               ing,  for  example, what signals a spawned process
               will be sent, but these are system-dependent, typ-
               ically   documented   under   exit(3).)    Spawned
               processes that continue to run will  be  inherited
               by init.

               _s_t_a_t_u_s (or 0 if not specified) is returned as  the
               exit  status  of  eeeexxxxppppeeeecccctttt.  eeeexxxxiiiitttt is implicitly exe-
               cuted if the end of the script is reached.

     eeeexxxxppppeeeecccctttt [[-_o_p_t_s] _p_a_t_l_i_s_t_1 _b_o_d_y_1] ... [-_o_p_t_s] _p_a_t_l_i_s_t_n [_b_o_d_y_n]
               waits until one of the patterns matches the output
               of  a spawned process, a specified time period has
               passed, or an end-of-file is seen.  If  the  final
               body is null, it may be omitted.

               Patterns from the most recent  eeeexxxxppppeeeecccctttt____bbbbeeeeffffoooorrrreeee  com-
               mand  are  implicitly  used  before any other pat-
               terns.  Patterns from the most recent eeeexxxxppppeeeecccctttt____aaaafffftttteeeerrrr
               command  are  implicitly used after any other pat-
               terns.

               If the arguments to the  entire  eeeexxxxppppeeeecccctttt  statement
               require  more than one line, all the arguments may
               be "braced" into one so as  to  avoid  terminating
               each line with a backslash.  In this one case, the
               usual Tcl substitutions  will  occur  despite  the
               braces.




AT&T Bell LaboratoriesLast change: 22 October 1992                 5






EXPECT(1)                USER COMMANDS                  EXPECT(1)



               Each _p_a_t_l_i_s_t consists of a single pattern or  list
               of patterns.  If a _p_a_t_l_i_s_t is eeeeooooffff, the correspond-
               ing body  is  executed  upon  end-of-file.   If  a
               _p_a_t_l_i_s_t is ttttiiiimmmmeeeeoooouuuutttt, the corresponding body is exe-
               cuted upon timeout.  The default timeout period is
               10  seconds  but may be set, for example to 30, by
               the command "set timeout 30".  An infinite timeout
               may  be  designated by the value -1.  If a _p_a_t_l_i_s_t
               is ddddeeeeffffaaaauuuulllltttt, the  corresponding  body  is  executed
               upon either timeout or end-of-file.

               If a pattern matches, then the corresponding  body
               is  executed.   eeeexxxxppppeeeecccctttt  returns  the result of the
               body (or null if  no  pattern  matched).   In  the
               event   that  multiple  patterns  match,  the  one
               appearing first is used to select a body.

               Each time new output arrives, it  is  compared  to
               each  pattern in the order they are listed.  Thus,
               you may test for absence of a match by making  the
               last  pattern something guaranteed to appear, such
               as a prompt.  In  situations  where  there  is  no
               prompt,  you must use ttttiiiimmmmeeeeoooouuuutttt (just like you would
               if you were interacting manually).

               Pattern lists  are  specified  in  two  ways.   By
               default,  pattern lists are lists of patterns that
               are specified as with Tcl's ssssttttrrrriiiinnnngggg mmmmaaaattttcccchhhh  command.
               (Such patterns are also similar to C-shell regular
               expressions usually referred  to  as  "glob"  pat-
               terns).

               For example, the following fragment  looks  for  a
               successful login.  (Note that aaaabbbboooorrrrtttt is presumed to
               be a procedure defined elsewhere in the script.)

                     expect {
                            connected    break
                            busy         {print busy\n ; continue}
                            {failed {invalid password}} abort
                            timeout      abort
                     }

               Braces are not necessary on the  first  or  second
               _p_a_t_l_i_s_t,  although  the  the  second body requires
               them, since it is a set of statements.  The  third
               _p_a_t_l_i_s_t  contains two patterns.  The second one is
               surrounded by braces to protect the literal  space
               from breaking it up.  Alternatively, spaces may be
               escaped with  backslashes.   More  information  on
               forming glob-style patterns can be found in EXPECT
               HINTS below as well as the Tcl manual itself.



AT&T Bell LaboratoriesLast change: 22 October 1992                 6






EXPECT(1)                USER COMMANDS                  EXPECT(1)



               Alternatively, regexp-style  patterns  follow  the
               syntax defined by Tcl's command, rrrreeeeggggeeeexxxxpppp (short for
               "regular expression") command.  Lists of such pat-
               terns  are  specified using the regexp alternation
               syntax (rather than the Tcl braced  list).   (This
               alone tends to make regexp patterns easier to deal
               with.)  regexp patterns are  introduced  with  the
               flag  ----rrrreeee.   The previous example can be rewritten
               using a regexp as:

                     expect {
                            connected    break
                            busy         {print busy\n ; continue}
                            -re "failed|invalid password" abort
                            timeout      abort
                     }

               Both types of  patterns  are  "unanchored".   This
               means  that  patterns  do  not  have  to match the
               entire string, but can begin  and  end  the  match
               anywhere in the string (as long as everything else
               matches).  Use ^  to  match  the  beginning  of  a
               string,  and $ to match the end.  Note that if you
               do  not  wait  for  the  end  of  a  string,  your
               responses  can  easily end up in the middle of the
               string as they are echoed from  the  spawned  pro-
               cess.   While still producing correct results, the
               output can look unnatural.   Thus,  use  of  $  is
               encouraged if you can exactly describe the charac-
               ters at the end of a string.

               The ----nnnnooooccccaaaasssseeee flag causes  uppercase  characters  of
               the  output  to  compare as if they were lowercase
               characters.  The pattern is not affected.

               While reading output, more  than  2000  bytes  can
               force  earlier  bytes to be "forgotten".  This may
               be changed with  the  function  mmmmaaaattttcccchhhh____mmmmaaaaxxxx.   (Note
               that  excessively  large  values can slow down the
               pattern matcher.)  If _p_a_t_l_i_s_t is bbbbuuuuffffffffeeeerrrr____ffffuuuullllllll,  the
               corresponding  body is executed if _m_a_t_c_h__m_a_x bytes
               have been received  and  no  other  patterns  have
               matched.

               Upon matching a pattern (or eof  or  buffer_full),
               any  matching  and  previously unmatched output is
               saved in the variable _e_x_p_e_c_t__o_u_t(_b_u_f_f_e_r).  Up to 9
               regexp  substring  matches  are saved in the vari-
               ables         _e_x_p_e_c_t__o_u_t(_1,_s_t_r_i_n_g)         through
               _e_x_p_e_c_t__o_u_t(_9,_s_t_r_i_n_g).   The  starting  and  ending
               indices (in a form suitable for llllrrrraaaannnnggggeeee) of the  10
               strings    are    stored    in    the    variables



AT&T Bell LaboratoriesLast change: 22 October 1992                 7






EXPECT(1)                USER COMMANDS                  EXPECT(1)



               _e_x_p_e_c_t__o_u_t(_X,_s_t_a_r_t) and _e_x_p_e_c_t__o_u_t(_X,_e_n_d) where  X
               is  the  corresponds  to the substring position in
               the pattern.   0  refers  to  the  entire  pattern
               itself.   For  example,  if a process has produced
               output of "abcdefgh\n", the result of:

                     expect "cd"

               is as if the following statements had executed:

                            set expect_out(0,start) 2
                            set expect_out(0,end) 3
                            set expect_out(0,string) cd
                            set expect_out(buffer) abcd

               and "efgh\n" is left in the output buffer.   If  a
               process  produced the output "abbbcabkkkka\n", the
               result of:

                            expect -re "b(b*).*(k+)"

               is as if the following statements had executed:

                            set expect_out(0,start) 1
                            set expect_out(0,end) 10
                            set expect_out(0,string) bbbcabkkkk
                            set expect_out(1,start) 2
                            set expect_out(1,end) 3
                            set expect_out(1,string) bb
                            set expect_out(2,start) 10
                            set expect_out(2,end) 10
                            set expect_out(2,string) k
                            set expect_out(buffer) abbbcabkkkk

               and "a\n" is left in the output buffer.  The  pat-
               tern  "*"  will  flush  the  output buffer without
               reading any more output from the process.

               Normally, the matched  output  is  discarded  from
               expect's  internal buffers.  This may be prevented
               by prefixing a pattern  with  the  ----nnnn  flag.   The
               name,  placement,  and  existence  of this flag is
               subject to change in a future release.  Therefore,
               it  should not be used in permanent scripts.  How-
               ever, it is  especially  useful  in  experimenting
               (which is why it has a one-character name).

               By default, patterns are  matched  against  output
               from  the  current  process,  however  the ----iiii flag
               declares the output from  the  named  spawn_id  be
               matched  against any following patterns (up to the
               next ----iiii).   For  example,  the  following  example



AT&T Bell LaboratoriesLast change: 22 October 1992                 8






EXPECT(1)                USER COMMANDS                  EXPECT(1)



               waits for "connected" from the current process, or
               "busy", "failed" or "invalid  password"  from  the
               spawn_id named by $proc2.

                     expect {
                            connected    break
                            -i $proc2 busy{print busy\n ; continue}
                            -re "failed|invalid password" abort
                            timeout      abort
                     }

               The variable _a_n_y__s_p_a_w_n__i_d may  be  used  to  match
               patterns  to  any  spawn_id  that  is  named  with
               another ----iiii flag.  associated with a pattern.  Upon
               matching  a  pattern  (or eof or buffer_full), the
               variable,  _e_x_p_e_c_t__o_u_t(_s_p_a_w_n__i_d)  is  set  to   the
               spawn_id which produced the matching output.

               Actions such as bbbbrrrreeeeaaaakkkk and ccccoooonnnnttttiiiinnnnuuuueeee  cause  control
               structures  (i.e.,  ffffoooorrrr,  pppprrrroooocccc)  to  behave in the
               usual way.  The special argument ----eeeexxxxppppeeeecccctttt  to  ccccoooonnnn----
               ttttiiiinnnnuuuueeee  allows  eeeexxxxppppeeeecccctttt itself to continue executing
               rather than returning as it normally would.

               This is useful  for  avoiding  explicit  loops  or
               repeated expect statements.  The following example
               is part of a fragment  to  automate  rlogin.   The
               ccccoooonnnnttttiiiinnnnuuuueeee  avoids  having  to write a second eeeexxxxppppeeeecccctttt
               statement (to look for the prompt  again)  if  the
               rlogin prompts for a password.

               expect {
                            Password: {
                                         system stty -echo
                                         send_user "password (for $user) on $host: "
                                         expect_user -re "(.*)\n"
                                         send_user "\n"
                                         send "$expect_out(1,string)\r"
                                         system stty echo
                                         continue -expect
                            } incorrect* {
                                         send_user "invalid password or account\n"
                                         exit
                            } timeout {
                                         send_user "connection to $host timed out\n"
                                         exit
                            } eof {
                                         send_user "connection to host failed: $expect_out(buffer)"
                                         exit
                            } -re $prompt
               }




AT&T Bell LaboratoriesLast change: 22 October 1992                 9






EXPECT(1)                USER COMMANDS                  EXPECT(1)



               For example, the following fragment might  help  a
               user  guide an interaction that is already totally
               automated.  In this case, the terminal is put into
               raw  mode.  If the user presses "+", a variable is
               incremented.  If "p" is pressed, several  newlines
               are  returns  are  sent to the process, perhaps to
               poke it  in  some  way,  and  "i"  lets  the  user
               interact  with  the  process, effectively stealing
               away control from the script.  In each  case,  the
               ccccoooonnnnttttiiiinnnnuuuueeee ----eeeexxxxppppeeeecccctttt allows the current eeeexxxxppppeeeecccctttt to con-
               tinue pattern matching after executing the current
               action.

               system stty raw -echo
               expect_after { -i $user_spawn_id
                            "p" {send "\r\r\r"; continue -expect}
                            "+" {incr foo; continue -expect}
                            "i" {interact; continue -expect}
                            "quit" exit
               }


               ccccoooonnnnttttiiiinnnnuuuueeee ----eeeexxxxppppeeeecccctttt resets the timeout timer.

               When running in cooked mode, SIGINT (usually  gen-
               erated  by  pressing  ^C)  will  cause  eeeexxxxppppeeeecccctttt  to
               timeout an internal read() prematurely.   This  is
               useful  for  debugging scripts.  A ^C at any other
               time  (except  during  iiiinnnntttteeeerrrraaaacccctttt)  will  implicitly
               cause  the  eeeexxxxppppeeeecccctttt program to exit (as if the eeeexxxxiiiitttt
               command had been used).  SIGINT may  be  redefined
               by the trap command.  For example, to force a SIG-
               INT to abort the program at any time, it  suffices
               to say "trap exit 2".

     eeeexxxxppppeeeecccctttt____aaaafffftttteeeerrrr [_e_x_p_e_c_t _a_r_g_s]
               takes the same arguments  as  eeeexxxxppppeeeecccctttt,  however  it
               returns  immediately.   Pattern-action  pairs from
               the most recent eeeexxxxppppeeeecccctttt____aaaafffftttteeeerrrr are implicitly  added
               to  any  following  eeeexxxxppppeeeecccctttt commands.  If a pattern
               matches, it is treated as if it had been specified
               in  the  eeeexxxxppppeeeecccctttt command itself, and the associated
               body is executed in the context of the eeeexxxxppppeeeecccctttt com-
               mand.    If   patterns   from   both   eeeexxxxppppeeeecccctttt  and
               eeeexxxxppppeeeecccctttt____aaaafffftttteeeerrrr can  match,  the  eeeexxxxppppeeeecccctttt  pattern  is
               used.

               Unless overridden by a ----iiii flag, eeeexxxxppppeeeecccctttt____aaaafffftttteeeerrrr  pat-
               terns  match  against  the spawn_id defined at the
               time that the eeeexxxxppppeeeecccctttt____aaaafffftttteeeerrrr  command  was  executed
               (not when its pattern is matched).




AT&T Bell LaboratoriesLast change: 22 October 1992                10






EXPECT(1)                USER COMMANDS                  EXPECT(1)



     eeeexxxxppppeeeecccctttt____bbbbeeeeffffoooorrrreeee [_e_x_p_e_c_t _a_r_g_s]
               takes the same arguments  as  eeeexxxxppppeeeecccctttt,  however  it
               returns  immediately.   Pattern-action  pairs from
               the most recent eeeexxxxppppeeeecccctttt____bbbbeeeeffffoooorrrreeee are implicitly added
               to  any  following  eeeexxxxppppeeeecccctttt commands.  If a pattern
               matches, it is treated as if it had been specified
               in  the  eeeexxxxppppeeeecccctttt command itself, and the associated
               body is executed in the context of the eeeexxxxppppeeeecccctttt com-
               mand.   If  patterns  from  both eeeexxxxppppeeeecccctttt____bbbbeeeeffffoooorrrreeee and
               eeeexxxxppppeeeecccctttt can match,  the  eeeexxxxppppeeeecccctttt____bbbbeeeeffffoooorrrreeee  pattern  is
               used.

               Unless overridden by a ----iiii flag, eeeexxxxppppeeeecccctttt____bbbbeeeeffffoooorrrreeee pat-
               terns  match  against  the spawn_id defined at the
               time that the eeeexxxxppppeeeecccctttt____bbbbeeeeffffoooorrrreeee command  was  executed
               (not when its pattern is matched).

     eeeexxxxppppeeeecccctttt____uuuusssseeeerrrr [_e_x_p_e_c_t _a_r_g_s] [_p_a_t_l_i_s_t_1 _b_o_d_y_1 ...] _p_a_t_l_i_s_t_n [_b_o_d_y_n]
               is  like eeeexxxxppppeeeecccctttt but it reads characters from stdin
               (i.e. keystrokes  from  the  user).   By  default,
               reading  is performed in cooked mode.  Thus, lines
               must end with a return in order for eeeexxxxppppeeeecccctttt to  see
               them.   This may be changed via ssssttttttttyyyy (see the ssssyyyyssss----
               tttteeeemmmm command below).

     eeeexxxxppppeeeecccctttt____vvvveeeerrrrssssiiiioooonnnn [[-_e_x_i_t] _v_e_r_s_i_o_n]
               is useful for assuring that the script is compati-
               ble with the current version of expect.

               With no arguments, the current version  of  eeeexxxxppppeeeecccctttt
               is  returned.  This version may then be encoded in
               your script.  If you actually know  that  you  are
               not  using  features  of  recent versions, you can
               specify an earlier version.

               Versions consist of up to three numbers  separated
               by  dots.   First  is  the  major number.  Scripts
               written for versions of eeeexxxxppppeeeecccctttt  with  a  different
               major  number  will  almost  certainly  not  work.
               eeeexxxxppppeeeecccctttt____vvvveeeerrrrssssiiiioooonnnn  returns  an  error  if  the  major
               numbers do not match.

               Second is the minor number.  Scripts written for a
               version  with  a  greater  minor  number  than the
               current version may depend upon some  new  feature
               and  might  not  run.   eeeexxxxppppeeeecccctttt____vvvveeeerrrrssssiiiioooonnnn  returns an
               error if the major numbers match, but  the  script
               minor  number  is greater than that of the running
               expect.

               Third is a number that plays no part in  the  ver-
               sion  comparison.  However, it is incremented when



AT&T Bell LaboratoriesLast change: 22 October 1992                11






EXPECT(1)                USER COMMANDS                  EXPECT(1)



               the eeeexxxxppppeeeecccctttt software distribution is changed in any
               way, such as by additional documentation or optim-
               ization.  It is reset to 0  upon  each  new  minor
               version.

               With the ----eeeexxxxiiiitttt flag, eeeexxxxppppeeeecccctttt prints  an  error  and
               exits if the version is out of date.

               There have been three major  versions  of  Expect.
               The  first  was never officially released and only
               existed for two  months,  as  I  experimented  and
               designed  the  basic  style of expect.  The second
               version lasted a year and a half  until  the  time
               when Tcl 6 and Expect 3 were issued.  Version 6 of
               Tcl was incompatible with  earlier  versions,  but
               John  Ousterhout  (Tcl's  author)  suggested  that
               enough  experience  had  been  gained  that   such
               changes  were  appropriate,  and this might be the
               last time it could be done because  further  delay
               would  be  that much more painful due to the ever-
               growing number of people using  it.   I  feel  the
               same  way.   I  hope  that  the current version of
               EEEExxxxppppeeeecccctttt will last many years without the  introduc-
               tion   of   incompatibilities  that  might  render
               scripts obsolete.

               During its one and a half  year  public  lifetime,
               the  second  version  of Expect was requested (and
               perhaps even used) by over 3000 sites.  I received
               numerous  suggestions  for  improvements or future
               directions.  Many of these either  appear  in  the
               current version or are addressed in the eeeexxxxppppeeeecccctttt FAQ
               file.

     ffffoooorrrrkkkk      creates a new process.   The  new  process  is  an
               exact copy of the current eeeexxxxppppeeeecccctttt process.  On suc-
               cess, ffffoooorrrrkkkk returns 0 to the  new  (child)  process
               and  return the process ID of the child process to
               the parent process.  On failure (invariably due to
               lack of resources, e.g., swap space, memory), ffffoooorrrrkkkk
               returns -1 to the parent  process,  and  no  child
               process is created.

               Forked processes exit via the eeeexxxxiiiitttt  command,  just
               like  the  original process.  Forked processes are
               allowed to write to the log files.  If you do  not
               disable  debugging  or  logging  in  most  of  the
               processes, the result can be confusing.

               Some pty implementations may be confused by multi-
               ple  readers and writers, even momentarily.  Thus,
               it is safest to ffffoooorrrrkkkk before spawning processes.



AT&T Bell LaboratoriesLast change: 22 October 1992                12






EXPECT(1)                USER COMMANDS                  EXPECT(1)



[_b_o_d_y_n]
     iiiinnnntttteeeerrrraaaacccctttt [-_u _s_p_a_w_n__i_d] [[-_f]  _s_t_r_i_n_g_1  _b_o_d_y_1  ...]  [-_f]  _s_t_r_i_n_g_n
               gives  control of the current process to the user,
               so that keystrokes are sent to  the  current  pro-
               cess,  and  the  stdout  and stderr of the current
               process are returned.

               String-body pairs may be specified  as  arguments,
               in  which  case  the  body  is  executed  when the
               corresponding string is entered.  (The  string  is
               not  sent  to  the  current process.)   The iiiinnnntttteeeerrrr----
               pppprrrreeeetttteeeerrrr command is assumed, if the  final  body  is
               missing.

               If the arguments to the  entire  eeeexxxxppppeeeecccctttt  statement
               require  more than one line, all the arguments may
               be "braced" into one so as  to  avoid  terminating
               each line with a backslash.  In this one case, the
               usual Tcl substitutions  will  occur  despite  the
               braces.

               For example, the following command  runs  interact
               with  the  following  string-body  pairs  defined:
               When ^Z is pressed, eeeexxxxppppeeeecccctttt is suspended.  When  ^A
               is  pressed, the user sees "you typed a control-A"
               and the process is sent a ^A.  When $ is  pressed,
               the  user  sees  the  date.   When  ^C is pressed,
               eeeexxxxppppeeeecccctttt exits.  If "foo" is entered, the user  sees
               "bar".  When ~~ is pressed, the eeeexxxxppppeeeecccctttt interpreter
               runs interactively.

                   set CTRLZ \032
                   interact {
                            $CTRLZ  {exec kill -STOP 0}
                            \001    {send_user "you typed a control-A\n";
                                     send "\001"
                                    }
                            $       {send_user "The date is [exec date]."}
                            \003    exit
                            foo     {send_user "bar"}
                            ~~
                   }


               In string-body pairs, strings are matched  in  the
               order  they are listed as arguments.  Strings that
               partially match are not sent to the  current  pro-
               cess  in anticipation of the remainder coming.  If
               characters are then entered such that there can no
               longer  possibly  be a match, only the part of the
               string will be sent to  the  process  that  cannot
               possibly  begin another match.  Thus, strings that



AT&T Bell LaboratoriesLast change: 22 October 1992                13






EXPECT(1)                USER COMMANDS                  EXPECT(1)



               are substrings of partial matches can match later,
               if  the original strings that was attempting to be
               match ultimately fails.

               Actions such as bbbbrrrreeeeaaaakkkk and ccccoooonnnnttttiiiinnnnuuuueeee  cause  control
               structures  (i.e.,  ffffoooorrrr,  pppprrrroooocccc)  to  behave in the
               usual way.   However  rrrreeeettttuuuurrrrnnnn  causes  interact  to
               return  to  its  caller,  while rrrreeeettttuuuurrrrnnnn ----ttttccccllll causes
               iiiinnnntttteeeerrrraaaacccctttt to cause a return  in  its  caller.   For
               example,  if "proc foo" called iiiinnnntttteeeerrrraaaacccctttt which then
               executed the action rrrreeeettttuuuurrrrnnnn ----ttttccccllll,  pppprrrroooocccc  ffffoooooooo  would
               return.  (This means that if iiiinnnntttteeeerrrraaaacccctttt calls iiiinnnntttteeeerrrr----
               pppprrrreeeetttteeeerrrr interactivley typing rrrreeeettttuuuurrrrnnnn will cause  the
               interact to continue, while rrrreeeettttuuuurrrrnnnn ----ttttccccllll will cause
               the interact to return to its caller.)

               During iiiinnnntttteeeerrrraaaacccctttt, raw mode  is  used  so  that  all
               characters  may  be passed to the current process.
               If the current process does not catch job  control
               signals,  it  will  stop if sent a stop signal (by
               default ^Z).  To restart it, send a continue  sig-
               nal  (such  as  by  "kill  -CONT  <pid>").  If you
               really want to send a SIGSTOP to  such  a  process
               (by ^Z), consider spawning csh first and then run-
               ning your program.  On the other hand, if you want
               to  send  a  SIGSTOP to eeeexxxxppppeeeecccctttt itself, first press
               the escape character, and then press ^Z.

               String-body pairs can be used as a  shorthand  for
               avoiding  having to enter the interpreter and exe-
               cute commands interactively.  The previous  termi-
               nal  mode  is used while the body of a string-body
               pair is being executed.

               The ----ffff flag (for "fast") skips the possibility  of
               a  temporary  mode  switch during pair processing.
               This consequently prevents characters  from  being
               lost when the terminal is returned to raw mode (an
               unfortunate feature of the terminal driver) at the
               end  of  a key-body pair execution.  ----ffff also skips
               the check that _s_p_a_w_n__i_d might have  changed.   The
               only  reason  not  to  use  ----ffff  is  if your action
               depends on  running  in  cooked  mode,  or  if  it
               changes the value of spawn_id.

               The ----FFFF flag indicates  that  all  following  flags
               behave as if they each were declared with ----ffff.

               The previous example is restated below in  a  more
               efficient  form,  using ----FFFF.  The first line cannot
               use ----ffff because it would leave the user back in the
               shell  in raw mode.  The last line would remain in



AT&T Bell LaboratoriesLast change: 22 October 1992                14






EXPECT(1)                USER COMMANDS                  EXPECT(1)



               raw mode but it is overridden by  the  iiiinnnntttteeeerrrrpppprrrreeeetttteeeerrrr
               command  itself,  which forces it into cooked mode
               temporarily.  The second line requires no extra \r
               because  sssseeeennnndddd  automatically  adds one.  The other
               lines need no change and run fine with -f.

                   set CTRLZ \032
                   interact {
                            $CTRLZ     {kill -STOP 0}
                            -F \001    {send_user "you typed a control-A\n";
                                        send "\001"
                                       }
                            $          {send_user "The date is [exec date]."}
                            \003       exit
                            foo        {send_user "bar"}
                            ~~
                   }


               During  iiiinnnntttteeeerrrraaaacccctttt,  previous  use  of  lllloooogggg____uuuusssseeeerrrr  is
               ignored.   In  particular, iiiinnnntttteeeerrrraaaacccctttt will force its
               output to be logged (sent to the standard  output)
               since  it  is  presumed  the  user doesn't wish to
               interact blindly.

               The ----oooo flag causes following key-body pairs to  be
               applied  to  the  output  of  the current process.
               This can be useful, for example, when dealing with
               hosts  that send unwanted characters during a tel-
               net session.

               By default, iiiinnnntttteeeerrrraaaacccctttt expects the user to be  writ-
               ing stdin and reading stdout of the eeeexxxxppppeeeecccctttt process
               itself.  The -u flag (for "user")  makes  iiiinnnntttteeeerrrraaaacccctttt
               look  for  the  user  as  the process named by its
               argument (which must be a spawned id).

               This allows two unrelated processes to  be  joined
               together  without  using an explicit loop.  To aid
               in debugging,  expect  diagnostics  always  go  to
               stderr  (or  stdout for certain logging and debug-
               ging  information).   For  the  same  reason,  the
               iiiinnnntttteeeerrrrpppprrrreeeetttteeeerrrr  command  will read interactively from
               stdin.

               For example,  the  following  fragment  creates  a
               login  process.   Then  it  dials  the  user  (not
               shown), and finally connects the two together.  Of
               course,  any process may be substituted for login.
               A shell, for example, would allow the user to work
               without supplying an account and password.




AT&T Bell LaboratoriesLast change: 22 October 1992                15






EXPECT(1)                USER COMMANDS                  EXPECT(1)



                            spawn login
                            set login $spawn_id
                            spawn tip modem
                            # dial back out to user
                            # connect user to login
                            interact -u $login


     iiiinnnntttteeeerrrrpppprrrreeeetttteeeerrrr
               causes the user to be interactively  prompted  for
               eeeexxxxppppeeeecccctttt  and Tcl commands.  The result of each com-
               mand is printed.

               Actions such as bbbbrrrreeeeaaaakkkk and ccccoooonnnnttttiiiinnnnuuuueeee  cause  control
               structures  (i.e.,  ffffoooorrrr,  pppprrrroooocccc)  to  behave in the
               usual way.  However rrrreeeettttuuuurrrrnnnn causes  interpreter  to
               return  to  its  caller,  while rrrreeeettttuuuurrrrnnnn ----ttttccccllll causes
               iiiinnnntttteeeerrrrpppprrrreeeetttteeeerrrr to cause a return in its caller.   For
               example,  if  "proc  foo" called iiiinnnntttteeeerrrrpppprrrreeeetttteeeerrrr which
               then executed the action  rrrreeeettttuuuurrrrnnnn  ----ttttccccllll,  pppprrrroooocccc  ffffoooooooo
               would  return.   Any  other  command causes iiiinnnntttteeeerrrr----
               pppprrrreeeetttteeeerrrr to continue prompting for new commands.

               By default, the prompt contains two integers.  The
               first  integer  describes the depth of the evalua-
               tion stack (i.e., how many procedures have yet  to
               return).   The  second  integer is the Tcl history
               identifier.  The prompt can be set by  defining  a
               procedure  called  "prompt1"  whose  return  value
               becomes the next prompt.  If a statement has  open
               quotes,  parens,  braces, or brackets, a secondary
               prompt (by default "+> ") is issued upon  newline.
               The secondary prompt may be set by defining a pro-
               cedure called "prompt2".

               During iiiinnnntttteeeerrrrpppprrrreeeetttteeeerrrr, cooked mode is used,  even  if
               the its caller was using raw mode.

     lllloooogggg____ffffiiiilllleeee [[-_a] _f_i_l_e]
               If a filename is provided, lllloooogggg____ffffiiiilllleeee will record  a
               transcript  of  the  session  (beginning  at  that
               point) in the file.  lllloooogggg____ffffiiiilllleeee will stop  recording
               if no argument is given.  Any previous log file is
               closed.

               The -_a flag forces output to be  logged  that  was
               suppressed by the lllloooogggg____uuuusssseeeerrrr command.

               The lllloooogggg____ffffiiiilllleeee command _a_p_p_e_n_d_s to old  files  rather
               than truncating them, for the convenience of being
               able to turn logging off and on multiple times  in
               one  session.  A simple way to always start with a



AT&T Bell LaboratoriesLast change: 22 October 1992                16






EXPECT(1)                USER COMMANDS                  EXPECT(1)



               fresh log file is to delete the  log  file  before
               using the lllloooogggg____ffffiiiilllleeee command for the first time in a
               script.  For example:

                            exec rm transcript
                            log_file transcript


     lllloooogggg____uuuusssseeeerrrr _e_x_p_r_e_s_s_i_o_n
               By default, the send/expect dialogue is logged  to
               stdout  (and  a logfile if open).  This logging is
               disabled by the command "log_user 0" and reenabled
               by "log_user 1".

     mmmmaaaattttcccchhhh____mmmmaaaaxxxx [-_d] [-_i _s_p_a_w_n__i_d] [_s_i_z_e]
               defines the size of the  buffer  (in  bytes)  used
               internally  by eeeexxxxppppeeeecccctttt.  With no _s_i_z_e argument, the
               current size is returned.

               With the ----dddd flag, the default size is  set.   (The
               initial  default  is 2000.)  With the ----iiii flag, the
               size is set for the named spawn id,  otherwise  it
               is set for the current process.

     oooovvvveeeerrrrllllaaaayyyy [-# _s_p_a_w_n__i_d] [-# _s_p_a_w_n__i_d] [...] _p_r_o_g_r_a_m [_a_r_g_s]
               executes _p_r_o_g_r_a_m _a_r_g_s  in  place  of  the  current
               eeeexxxxppppeeeecccctttt  program,  which terminates.  A bare hyphen
               argument forces a hyphen in front of  the  command
               name  as  if  it was a login shell.  All spawn_ids
               are closed except for those  named  as  arguments.
               These are mapped onto the named file descriptors.

               Spawn_ids are mapped to file descriptors  for  the
               new  program to inherit.  For example, the follow-
               ing line runs chess and allows it to be controlled
               by the current process - say, a chess master.

                            overlay -0 $spawn_id -1 $spawn_id -2 $spawn_id chess

               This is more efficient than  "interact  -u",  how-
               ever,  it  sacrifices the ability to do programmed
               interaction since the eeeexxxxppppeeeecccctttt process is no  longer
               in control.

               Note that no  controlling  terminal  is  provided.
               Thus,  if  you disconnect or remap standard input,
               programs that do job control (shells, login,  etc)
               will not function properly.

     sssseeeennnndddd [-_s] [-_h] [-_i _s_p_a_w_n__i_d] [-_r_a_w] _a_r_g_s
               Sends _a_r_g_s to the current  process.   Strings  are
               interpreted following Tcl rules.  For example, the



AT&T Bell LaboratoriesLast change: 22 October 1992                17






EXPECT(1)                USER COMMANDS                  EXPECT(1)



               command

                            send "hello world\r"

               sends the characters, h e l l o <blank> w o r l  d
               <return>  to  the current process. (Tcl includes a
               printf command (called  ffffoooorrrrmmmmaaaatttt)  which  can  build
               arbitrarily complex strings.)

               The -_i flag declares that the string  be  sent  to
               the   named   spawn_id.    If   the   spawn_id  is
               _u_s_e_r__s_p_a_w_n__i_d, and the terminal is  in  raw  mode,
               newlines  in  the string are translated to return-
               newline sequences so that they appear  as  it  the
               terminal  was  in cooked mode.  The -_r_a_w flag dis-
               ables this translation.

               The -_s flag forces output  to  be  sent  "slowly",
               thus  avoid  the common situation where a computer
               outtypes an input buffer that was designed  for  a
               human  who  would  never  outtype the same buffer.
               This output is controlled  by  the  value  of  the
               variable  "send_slow"  which  takes  a two element
               list.   The  first  element  is  an  integer  that
               describes  the number of bytes to send atomically.
               The second element is a real number that describes
               the  number  of  seconds by which the atomic sends
               must be separated.  For  example,  "set  send_slow
               {10  .001}"  would force "send -s" to send strings
               with 1 millisecond in between each  10  characters
               sent.

               The -_h flag forces output to  be  sent  (somewhat)
               like  a  human actually typing.  Human-like delays
               appear between the characters.  (The algorithm  is
               based  upon a Weibull distribution, with modifica-
               tions to suit this particular application.)   This
               output  is controlled by the value of the variable
               "send_human" which takes a five element list.  The
               first  two  elements are average interarrival time
               of characters in seconds.  The first  is  used  by
               default.   The  second is used at word endings, to
               simulate the subtle pauses that occasionally occur
               at  such  transitions.   The  third parameter is a
               measure of varibility where .1 is quite  variable,
               1  is reasonably variable, and 10 is quite invari-
               able.  The extremes are 0 to infinity.   The  last
               two  parameters  are,  respectively, a minimum and
               maximum interarrival time.   As  an  example,  the
               following  command  types a lot like the author (a
               fast and consistent typist):




AT&T Bell LaboratoriesLast change: 22 October 1992                18






EXPECT(1)                USER COMMANDS                  EXPECT(1)



                            set send_human {.1 .3 1 .05 2}
                            send -h "I'm hungry.  Let's do lunch."

               while the following might be more suitable after a
               hangover:

                            set send_human {.4 .4 .2 .5 100}
                            send -h "Goodd party lash night!"

               Note that errors are not simulated,  although  you
               can set up error correction situations yourself by
               embedding mistakes and corrections in a send argu-
               ment.

               It is a good idea to precede the first sssseeeennnndddd  to  a
               process  by  an  eeeexxxxppppeeeecccctttt.  eeeexxxxppppeeeecccctttt will wait for the
               process to start, while sssseeeennnndddd cannot.  In  particu-
               lar,  if  the first sssseeeennnndddd completes before the pro-
               cess starts running, you run the  risk  of  having
               your  data  ignored.  In situations where interac-
               tive programs offer no  initial  prompt,  you  can
               precede sssseeeennnndddd by a delay as in:

                            # To avoid giving hackers hints on how to break in,
                            # this system does not prompt for an external password.
                            # Wait for 5 seconds for exec to complete
                            spawn telnet very.secure.gov
                            exec sleep 5
                            send password\r


     sssseeeennnndddd____eeeerrrrrrrroooorrrr _a_r_g_s
               is like sssseeeennnndddd, except that the arguments  are  sent
               to stderr rather than the current process.

     sssseeeennnndddd____uuuusssseeeerrrr _a_r_g_s
               is like sssseeeennnndddd, except that the arguments  are  sent
               to stdout rather than the current process.

     ssssppppaaaawwwwnnnn _p_r_o_g_r_a_m [_a_r_g_s]
               creates a new process running _p_r_o_g_r_a_m  _a_r_g_s.   Its
               stdin,  stdout and stderr are connected to expect,
               so that they may be  read  and  written  by  other
               eeeexxxxppppeeeecccctttt  commands.   The  connection  is  broken by
               cccclllloooosssseeee or if the process itself closes any  of  the
               file descriptors.

               When a process is started by ssssppppaaaawwwwnnnn,  the  variable
               _s_p_a_w_n__i_d  is set to a descriptor referring to that
               process.  The process  described  by  _s_p_a_w_n__i_d  is
               considered  the  _c_u_r_r_e_n_t _p_r_o_c_e_s_s.  _s_p_a_w_n__i_d may be
               read or written, in effect providing job control.



AT&T Bell LaboratoriesLast change: 22 October 1992                19






EXPECT(1)                USER COMMANDS                  EXPECT(1)



               _u_s_e_r__s_p_a_w_n__i_d is a predefined variable  containing
               a  descriptor which refers to the user.  For exam-
               ple, when _s_p_a_w_n__i_d is set to  this  value,  eeeexxxxppppeeeecccctttt
               behaves like eeeexxxxppppeeeecccctttt____uuuusssseeeerrrr.  Do not assume the value
               of _u_s_e_r__s_p_a_w_n__i_d will remain  the  same  from  one
               version of eeeexxxxppppeeeecccctttt to another.

               ssssppppaaaawwwwnnnn returns the UNIX process id.  Note that  the
               UNIX  process id is not equivalent to the descrip-
               tor in _s_p_a_w_n__i_d.

               Internally, ssssppppaaaawwwwnnnn uses a pty, initialized the same
               way  as the user's tty.  When this is not possible
               (i.e., eeeexxxxppppeeeecccctttt was not started with  a  controlling
               terminal),   ssssppppaaaawwwwnnnn  uses  the  tty  settings  that
               correspond  to  "stty  sane".   If  the   variable
               _s_t_t_y__i_n_i_t  is  defined,  it  is interpreted in the
               style of stty arguments as  further  configuration
               for  any  pty  used by future ssssppppaaaawwwwnnnn commands.  For
               example, "set stty_init sane" repeats the  default
               initialization.

               Normally, ssssppppaaaawwwwnnnn takes little time to execute.   If
               you  notice  spawn  taking a significant amount of
               time, it is probably encountering  ptys  that  are
               wedged.   A  number  of  tests  are run on ptys to
               avoid entanglements with errant processes.  (These
               take  10  seconds per wedged pty.)  Running expect
               with  the  -d  option  will  show  if  eeeexxxxppppeeeecccctttt   is
               encountering many ptys in odd states.  If you can-
               not kill the processes to  which  these  ptys  are
               attached, your only recourse may be to reboot.

               If _p_r_o_g_r_a_m cannot be spawned successfully  because
               exec(2)  fails  (e.g. when _p_r_o_g_r_a_m doesn't exist),
               an error message will  be  returned  by  the  next
               iiiinnnntttteeeerrrraaaacccctttt  or  eeeexxxxppppeeeecccctttt command as if _p_r_o_g_r_a_m had run
               and produced the error message  as  output.   This
               behavior is a natural consequence of the implemen-
               tation of ssssppppaaaawwwwnnnn.  Internally, spawn  forks,  after
               which  the  spawned process has no way to communi-
               cate with the original eeeexxxxppppeeeecccctttt  process  except  by
               communication via the spawn_id.

     ssssttttrrrraaaacccceeee _l_e_v_e_l
               causes following statements to be  printed  before
               being executed.  (Tcl's trace command traces vari-
               ables.)  _l_e_v_e_l indicates how far down in the  call
               stack  to  trace.  For example, the following com-
               mand runs eeeexxxxppppeeeecccctttt while tracing the first 4  levels
               of calls, but none below that.




AT&T Bell LaboratoriesLast change: 22 October 1992                20






EXPECT(1)                USER COMMANDS                  EXPECT(1)



                            expect -c "strace 4" script.exp


     ssssyyyysssstttteeeemmmm _a_r_g_s
               gives _a_r_g_s to sh(1) as input, just if it had  been
               typed  as a command from a terminal.  eeeexxxxppppeeeecccctttt waits
               until the shell  terminates.   The  return  status
               from  sh is handled the same way that eeeexxxxeeeecccc handles
               its return status.

               In contrast to  eeeexxxxeeeecccc  which  redirects  stdin  and
               stdout  to the script, ssssyyyysssstttteeeemmmm performs no redirec-
               tion (other than  that  indicated  by  the  string
               itself).   Thus,  it  is  possible to use programs
               which must talk directly  to  /dev/tty.   For  the
               same   reason,  the  results  of  ssssyyyysssstttteeeemmmm  are  not
               recorded in the log.

               ssssyyyysssstttteeeemmmm understands and evaluates certain cases  of
               "stty"  directly,  in  order to efficiently handle
               mode switching during iiiinnnntttteeeerrrrppppeeeetttteeeerrrr and iiiinnnntttteeeerrrraaaacccctttt.  In
               particular,  the  arguments rrrraaaawwww or ----ccccooooooookkkkeeeedddd put the
               terminal into raw mode.   The  arguments  ----rrrraaaawwww  or
               ccccooooooookkkkeeeedddd  put  the  terminal  into cooked mode.  The
               arguments eeeecccchhhhoooo and ----eeeecccchhhhoooo  put  the  terminal  into
               echo and noecho mode respectively.

               The following example illustrates how to use  ssssyyyyssss----
               tttteeeemmmm to temporarily disable echoing.  This could be
               used  in  otherwise-automatic  scripts  to   avoid
               embedding passwords in them.  (See more discussion
               on this under EXPECT HINTS below.)

                            system stty -echo
                            send_user "Password: "
                            expect_user -re "(.*)\n"
                            set password $expect_out(1,string)
                            system stty echo


     ttttrrrraaaapppp [[_c_o_m_m_a_n_d] _s_i_g_n_a_l_s]
               causes the  given  _c_o_m_m_a_n_d  to  be  executed  upon
               future  receipt  of  any of the given signals.  If
               _c_o_m_m_a_n_d is absent, the signal actions are reset to
               their defaults.  If _c_o_m_m_a_n_d is the string SIG_IGN,
               the signals are ignored.  _s_i_g_n_a_l_s is either a sin-
               gle  signal  or a list of signals.  Signals may be
               specified numerically or symbolically as per  sig-
               nal(3).   The "SIG" prefix may be omitted.  ONEXIT
               (signal 0) is raised upon exit from expect.

               With  no  arguments,  ttttrrrraaaapppp  prints  the   commands



AT&T Bell LaboratoriesLast change: 22 October 1992                21






EXPECT(1)                USER COMMANDS                  EXPECT(1)



               associated with each signal number.

               For example, the command "trap {send_user "Ouch!"}
               SIGINT"  will  print  "Ouch!"   each time the user
               presses ^C.  The default behavior is  restored  by
               "trap SIGINT".

               Note that output may be  lost  if  signals  arrive
               during reads (although this is usually the desired
               behavior).

               ttttrrrraaaapppp will not let  you  override  the  action  for
               SIGALRM as this is used internally to eeeexxxxppppeeeecccctttt.  The
               disconnect  command  sets   SIGALRM   to   SIG_IGN
               (ignore).   You  can  reenable this as long as you
               disable it during subsequent spawn commands.

               Few checks on signals are made.  For example, ttttrrrraaaapppp
               does not prevent you from registering signals that
               the kernel refuses to catch.   See  signal(3)  for
               more info.

     wwwwaaaaiiiitttt [-_i _s_p_a_w_n__i_d]
               delays until a signal is  received  or  the  named
               spawned process (or the current process if none is
               named) terminates (or stops due to tracing).  (See
               wait(2) for more info.)

               wwwwaaaaiiiitttt returns two integers.  The first  integer  is
               the  pid  of the process that was waited upon.  In
               this case, the second integer is WEXITSTATUS  (see
               wait(2)).   If  your  system does not support WEX-
               ITSTATUS, the raw exit value is returned.   If  an
               error  occurs  during  execution  of the wait, the
               integers returned are -1 followed by errno(3).

               The  ----iiii  flag  declares  the   process   to   wait
               corresponding  to the named spawn_id (NOT the pro-
               cess id).

PPPPRRRREEEETTTTTTTTYYYY----PPPPRRRRIIIINNNNTTTTIIIINNNNGGGG
     A vgrind definition is available for pretty-printing  eeeexxxxppppeeeecccctttt
     scripts.   Assuming  the vgrind definition supplied with the
     eeeexxxxppppeeeecccctttt distribution is correctly installed, you can  use  it
     as:

                  vgrind -lexpect file


EEEEXXXXAAAAMMMMPPPPLLLLEEEESSSS
     It many not be apparent how to put everything together  that
     the man page describes.  I encourage you to read and try out



AT&T Bell LaboratoriesLast change: 22 October 1992                22






EXPECT(1)                USER COMMANDS                  EXPECT(1)



     the many examples in the test directory of the  eeeexxxxppppeeeecccctttt  dis-
     tribution.  Some of them are real programs.  Others are sim-
     ply illustrative of certain techniques,  and  of  course,  a
     couple  are  just quick hacks.  The INSTALL file has a quick
     overview of these programs.

     The eeeexxxxppppeeeecccctttt papers (see SEE ALSO) are  also  useful  although
     invariably  shorter.  However, there is a significant amount
     of explanatory text accompanying those examples.

CCCCAAAAVVVVEEEEAAAATTTTSSSS
     eeeexxxxppppeeeecccctttt takes a rather liberal view of scoping.  In  particu-
     lar,  variables read by commands specific to the eeeexxxxppppeeeecccctttt pro-
     gram will be sought first from the local scope, and  if  not
     found,  in the global scope.  For example, this obviates the
     need to place "global timeout" in every procedure you  write
     that  uses eeeexxxxppppeeeecccctttt.  On the other hand, variables written are
     always in the local scope (unless  a  "global"  command  has
     been issued).

     If you cannot enable  the  multispawning  capability  (i.e.,
     your system supports neither select (BSD *.*), poll (SVR>2),
     nor something equivalent), eeeexxxxppppeeeecccctttt will only be able to  con-
     trol  a  single  process  at  a  time.  In this case, do not
     attempt to set _s_p_a_w_n__i_d, nor should  you  execute  processes
     via  exec  while a spawned process is running.  Furthermore,
     you will not be  able  to  eeeexxxxppppeeeecccctttt  from  multiple  processes
     (including the user as one) at the same time.

     If the terminal is not set  "correctly",  scripts  may  mis-
     behave.   For  example,  scripts  that  are  written  to see
     specific control sequences such as carriage-return  linefeed
     do  not  see  them  under  the  emacs shell window.  This is
     because emacs shell changes the  "usual"  mappings,  so  for
     instance   newlines  get  mapped  to  newlines,  instead  of
     carriage-return newlines.  The  emacs  shell  also  disables
     echoing.   Normally, this is desirable; it allows one to use
     emacs to edit the input line.  Unfortunately, expect  cannot
     possibly guess this.

     It is possible to write scripts that function  both  outside
     and inside of such unusual environments.  The easiest way is
     to set the terminal characteristics in the  script.   Unfor-
     tunately,  users  may  not  like this.  The harder way is to
     avoid depending upon things  like  echoing  and  end-of-line
     mappings.


BBBBUUUUGGGGSSSS
     It was really tempting to name the program "sex" (for either
     "Smart  EXec"  or "Send-EXpect"), but good sense (or perhaps
     just Puritanism) prevailed.



AT&T Bell LaboratoriesLast change: 22 October 1992                23






EXPECT(1)                USER COMMANDS                  EXPECT(1)



     Tcl 6.0 has a bug in it that impacts expect.  Namely,  sssspppplllliiiitttt
     does  not  correctly  handle formatting characters.  This is
     fixed in Tcl 6.1.

     Tcl 6.0 through 6.3 have a bug which may produce  the  error
     "Tcl_WaitPids  got unknown process" followed by a core dump.
     The problem is that Tcl assumes it knows  about  all  forked
     processes.  When it waits for one of its own (i.e., in exec)
     and stumbles across one that was spawned by expect, it  gen-
     erates  that error.  Until this is fixed, make sure you do a
     "wait" on any spawned processes that have exited before  you
     call  exec.   ssssyyyysssstttteeeemmmm is safe from this bug, so if don't need
     the  differences  provided  by  eeeexxxxeeeecccc,  you  can  use  ssssyyyysssstttteeeemmmm
     meanwhile.   Tcl  6.2 has a partial fix; core is not dumped,
     but expect loses the possibility of waiting on  the  process
     if your system does not support waitpid.

     Since Tcl uses C-style null-terminated strings, there is  no
     way  to  represent  strings with nulls in them.  eeeexxxxppppeeeecccctttt will
     record such output to the log and stdout, but it will  strip
     them out before performing string matching or storing in the
     variable _e_x_p_e_c_t__o_u_t.

     When a shell is spawned on an  HP-UX  system,  it  complains
     about  not  being  able to access the tty.  However, it runs
     anyway.   You'll  have  to  discard  that  message  in  your
     scripts,  though.   If you figure out why this occurs please
     let me know.

     Ultrix 4.1 (at least the latest versions around  here)  con-
     siders timeouts of above 1000000 to be equivalent to 0.

     Telnet (verified only under SunOS 4.1.2) hangs  if  TERM  is
     not  set.  This is a problem under cron and at, which do not
     define TERM.  Thus, you must set it explicitly.

     Some implementations of ptys are designed so that the kernel
     throws away any unread output after 10 to 15 seconds (actual
     number subject to your device driver) after the process  has
     closed the file descriptor.  Thus eeeexxxxppppeeeecccctttt programs such as

                  spawn date
                  exec sleep 20
                  expect

     will fail.  To avoid this, invoke  non-interactive  programs
     with eeeexxxxeeeecccc rather than ssssppppaaaawwwwnnnn.  While such situations are con-
     ceivable, in practice I have never encountered  a  situation
     in  which  the  final  output of a truly interactive program
     would be lost due to this behavior.

     On the other hand, Cray UNICOS ptys throw  away  any  unread



AT&T Bell LaboratoriesLast change: 22 October 1992                24






EXPECT(1)                USER COMMANDS                  EXPECT(1)



     output  immediately  after  the  process has closed the file
     descriptor.  I have reported this to Cray and they are work-
     ing on a fix.

     Sometimes a  delay  is  required  between  a  prompt  and  a
     response, such as when a tty interface is changing UART set-
     tings or matching baud rates by looking for start/stop bits.
     Usually,  all  this  is  require is to sleep for a second or
     two.  A more robust technique is to retry until the hardware
     is  ready to receive input.  The following example uses both
     strategies:

                  send "speed 9600\r";
                  exec sleep 1
                  expect {
                             timeout {send "\r"; continue -expect}
                             $prompt
                  }


EEEEXXXXPPPPEEEECCCCTTTT HHHHIIIINNNNTTTTSSSS
     There are a couple of things about eeeexxxxppppeeeecccctttt that may  be  non-
     intuitive.   This  section attempts to address some of these
     things with a couple of suggestions.

     A common expect problem is how to recognize  shell  prompts.
     Since these are customized differently by differently people
     and different shells, portably automating rlogin can be dif-
     ficult  without knowing the prompt.  A reasonable convention
     is to have users store a regular expression describing their
     prompt  (in  particular,  the  end of it) in the environment
     variable EXPECT_PROMPT.  Code  like  the  following  can  be
     used.   If EXPECT_PROMPT doesn't exist, the code still has a
     good chance of functioning correctly.

     set prompt "(%|$|#) "          ;# default prompt
     if [info exists env(EXPECT_PROMPT)] {
                  set prompt $env(EXPECT_PROMPT)
     }

     expect -re $prompt

     I encourage you to write eeeexxxxppppeeeecccctttt patterns  that  include  the
     end  of  whatever you eeeexxxxppppeeeecccctttt to see.  This avoids the possi-
     bility of answering a  question  before  seeing  the  entire
     thing.   In  addition,  while you may well be able to answer
     questions before seeing them entirely, if you answer  early,
     your  answer  may  appear  echoed  back in the middle of the
     question.  In other words, the resulting dialogue be correct
     but look scrambled.

     Most prompts include a space  character  at  the  end.   For



AT&T Bell LaboratoriesLast change: 22 October 1992                25






EXPECT(1)                USER COMMANDS                  EXPECT(1)



     example,  the  prompt  from  ftp  is  'f', 't', 'p', '>' and
     <blank>.  To match this prompt, you must account for each of
     these characters.  It is a common mistake not to include the
     blank.  You can either put the blank in explicitly (prefaced
     with a backslash) or use a *.

     If you use a pattern of the form X*, the *  will  match  all
     the  output  received  from  the  end of X to the last thing
     received.  This sounds intuitive but can be somewhat confus-
     ing  because  the  phrase  "last  thing  received"  can vary
     depending upon the speed of the computer and the  processing
     of I/O both by the kernel and the device driver.

     In particular, humans tend to see program output arriving in
     huge  chunks (atomically) when in reality most programs pro-
     duce output one line at a time.  Assuming this is the  case,
     the  *  in  the  pattern  of the previous paragraph may only
     match the end of the current line even though there seems to
     be  more,  because at the time of the match that was all the
     output that had been received.

     eeeexxxxppppeeeecccctttt has no way of knowing that further output  is  coming
     unless your pattern specifically accounts for it.

     Even depending on line-oriented buffering  is  unwise.   Not
     only  do  programs  rarely  make  promises about the type of
     buffering they do, but system indigestion can  break  output
     lines  up  so  that  lines break at seemingly random places.
     Thus, if you can express the last few characters of a prompt
     when writing patterns, it is wise to do so.

     If you are waiting for a pattern in the  last  output  of  a
     program  and  the  program emits something else instead, you
     will not be able to detect that with  the  ttttiiiimmmmeeeeoooouuuutttt  keyword.
     The reason is that eeeexxxxppppeeeecccctttt will not timeout - instead it will
     get an eeeeooooffff indication.  Use that instead.  Even better,  use
     both.  That way if that line is ever moved around, you won't
     have to edit the line itself.

     Newlines are usually converted to carriage return,  linefeed
     sequences  when output by the terminal driver.  Thus, if you
     want a pattern that explicitly matches the two lines,  from,
     say,   printf("foo\nbar"),   you   should  use  the  pattern
     {foo\r\nbar}.

     A similar translation occurs when reading from the user, via
     eeeexxxxppppeeeecccctttt____uuuusssseeeerrrr.   In  this case, when you press return, it will
     be translated to a newline.  If eeeexxxxppppeeeecccctttt then passes that to a
     program  which  sets its terminal to raw mode (like telnet),
     there is going to be a problem, as  the  program  expects  a
     true  return.  (Some programs are actually forgiving in that
     they will automatically translate newlines to  returns,  but



AT&T Bell LaboratoriesLast change: 22 October 1992                26






EXPECT(1)                USER COMMANDS                  EXPECT(1)



     most  don't.)   Unfortunately,  there  is no way to find out
     that a program put its terminal into raw mode.

     Rather than manually replacing newlines  with  returns,  the
     solution  is to just do a "system stty raw", which will stop
     the translation.  Note, however, that this  means  that  you
     will no longer get the cooked line-editing features.

     iiiinnnntttteeeerrrraaaacccctttt implicitly sets your terminal to raw mode  so  this
     problem will not arise then.

     It is often useful to  store  passwords  (or  other  private
     information)  in  eeeexxxxppppeeeecccctttt  scripts.   This is not recommended
     since anything that is stored on a computer  is  susceptible
     to  being accessed by anyone.  Thus, interactively prompting
     for passwords from a script is a smarter idea than embedding
     them  literally.   Nonetheless,  sometimes such embedding is
     the only possibility.

     Unfortunately, the UNIX file system has  no  direct  way  of
     creating files which are executable but unreadable.  Systems
     which support setgid shell scripts may  indirectly  simulate
     this as follows:

     Create the eeeexxxxppppeeeecccctttt script (that contains the secret data)  as
     usual.   Make  its permissions be 750 (-rwxr-x---) and owned
     by a trusted group, i.e., a group which is allowed  to  read
     it.   If  necessary,  create  a  new group for this purpose.
     Next, create a /bin/sh script with permissions 2751  (-rwxr-
     s--x) owned by the same group as before.

     The result is a script which may be executed (and  read)  by
     anyone.  When invoked, it runs the eeeexxxxppppeeeecccctttt script.

     I believe that the regexp-style patterns are much easier  to
     use.  The original release of Tcl/expect did not offer them,
     and hence the glob-style patterns remain the default due  to
     common  practice.  Nonetheless, I encourage you to avoid the
     glob-style patterns.  Here is a description of the  pitfalls
     of glob-style patterns, should you decide to persevere.

     Quoting conventions  can  be  confusing  when  using  double
     quotes,  braces,  backslash  sequences  and  white  space in
     eeeexxxxppppeeeecccctttt''''ssss glob-style _p_a_t_l_i_s_t_s.  _p_a_t_l_i_s_t_s are actually scanned
     twice  (just  like  Tcl's  ccccaaaasssseeee  _p_a_t_l_i_s_t_s)  which will break
     strings up on white space.  One solution is just  to  put  a
     backslash  in  front of every whitespace character.  You can
     also protect whitespace by placing a second  set  of  braces
     around the pattern, however this will prevent backslash sub-
     stitution.  Alternatively, you can double quote  the  braced
     pattern  thereby  allowing backslash sequences.  (Admittedly
     it is just plain ugly.)  Just about  any  other  combination



AT&T Bell LaboratoriesLast change: 22 October 1992                27






EXPECT(1)                USER COMMANDS                  EXPECT(1)



     looks  right but fails for one reason or another.  For exam-
     ple, if you wish  to  match  the  characters:  a  <space>  b
     <return> <newline> <anything>, the following will work:

                  expect {a\ b\r\n*}
                  expect "{a b\r\n*}"

     The following commands fail.

                  expect a b\r\n*
                  # breaks around space, and b\r\n* becomes action

                  expect {a b\r\n*}
                  # breaks into 2 patterns (around space)

                  expect {"a b\r\n*"}
                  # breaks into 2 patterns (around space)

                  expect {{a b\r\n*}}
                  # double brace disables \r\n interpretation

                  expect "a\ b\r\n*"
                  # breaks into 3 patterns (around space and newline)

                  expect "a b\r\n*"
                  # breaks into 3 patterns (around space and newline)


SSSSEEEEEEEE AAAALLLLSSSSOOOO
     TTTTccccllll(3), lllliiiibbbbeeeexxxxppppeeeecccctttt(3)
     "_e_x_p_e_c_t: _C_u_r_i_n_g _T_h_o_s_e _U_n_c_o_n_t_r_o_l_l_a_b_l_e _F_i_t_s _o_f  _I_n_t_e_r_a_c_t_i_v_i_t_y"
     by  Don Libes, Proceedings of the Summer 1990 USENIX Confer-
     ence, Anaheim, California, June 11-15, 1990.
     "_U_s_i_n_g eeeexxxxppppeeeecccctttt to Automate System  Administration  Tasks"  by
     Don Libes, Proceedings of the 1990 USENIX Large Installation
     Systems   Administration   Conference,   Colorado   Springs,
     Colorado, October 17-19, 1990.
     "_T_c_l: _A_n _E_m_b_e_d_d_a_b_l_e _C_o_m_m_a_n_d _L_a_n_g_u_a_g_e"  by  John  Ousterhout,
     Proceedings  of  the Winter 1990 USENIX Conference, Washing-
     ton, D.C., January 22-26, 1990.  "_e_x_p_e_c_t: _S_c_r_i_p_t_s  _f_o_r  _C_o_n_-
     _t_r_o_l_l_i_n_g  _I_n_t_e_r_a_c_t_i_v_e _P_r_o_g_r_a_m_s" by Don Libes, Computing Sys-
     tems, Vol. 4, No. 2, University of  California  Press  Jour-
     nals, November 1991.

AAAAUUUUTTTTHHHHOOOORRRR
     Don Libes, National Institute of Standards and Technology

AAAACCCCKKKKNNNNOOOOWWWWLLLLEEEEDDDDGGGGEEEEMMMMEEEENNNNTTTTSSSS
     Thanks to John Ousterhout for Tcl,  and  Scott  Paisley  for
     inspiration.





AT&T Bell LaboratoriesLast change: 22 October 1992                28






EXPECT(1)                USER COMMANDS                  EXPECT(1)



     The HISTORY file documents much of the evolution of  expect.
     It  makes  interesting  reading  and  might give you further
     insight to this software.  Thanks to the people mentioned in
     it that sent me bug fixes or gave other assistance.

     Design and implementation of eeeexxxxppppeeeecccctttt was paid for by the U.S.
     government  and  is therefore in the public domain.  However
     the author and NIST would like credit if  this  program  and
     documentation or portions of them are used.














































AT&T Bell LaboratoriesLast change: 22 October 1992                29



