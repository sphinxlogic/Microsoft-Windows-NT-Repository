This is Info file stabs.info, produced by Makeinfo-1.55 from the input
file ./stabs.texinfo.

START-INFO-DIR-ENTRY
* Stabs::                       The "stabs" debugging information format.
END-INFO-DIR-ENTRY

   This document describes the stabs debugging symbol tables.

   Copyright 1992, 1993 Free Software Foundation, Inc.  Contributed by
Cygnus Support.  Written by Julia Menapace, Jim Kingdon, and David
MacKenzie.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy or distribute modified versions of this
manual under the terms of the GPL (for which purpose this text may be
regarded as a program in the language TeX).


File: stabs.info,  Node: Traditional Other Types,  Prev: Traditional Integer Types,  Up: Traditional Builtin Types

Traditional Other Types
.......................

   If the upper bound of a subrange is 0 and the lower bound is
positive, the type is a floating point type, and the lower bound of the
subrange indicates the number of bytes in the type:

     .stabs "float:t12=r1;4;0;",128,0,0,0
     .stabs "double:t13=r1;8;0;",128,0,0,0

   However, GCC writes `long double' the same way it writes `double',
so there is no way to distinguish.

     .stabs "long double:t14=r1;8;0;",128,0,0,0

   Complex types are defined the same way as floating-point types;
there is no way to distinguish a single-precision complex from a
double-precision floating-point type.

   The C `void' type is defined as itself:

     .stabs "void:t15=15",128,0,0,0

   I'm not sure how a boolean type is represented.


File: stabs.info,  Node: Builtin Type Descriptors,  Next: Negative Type Numbers,  Prev: Traditional Builtin Types,  Up: Builtin Types

Defining Builtin Types Using Builtin Type Descriptors
-----------------------------------------------------

   This is the method used by Sun's `acc' for defining builtin types.
These are the type descriptors to define builtin types:

`b SIGNED CHAR-FLAG WIDTH ; OFFSET ; NBITS ;'
     Define an integral type.  SIGNED is `u' for unsigned or `s' for
     signed.  CHAR-FLAG is `c' which indicates this is a character
     type, or is omitted.  I assume this is to distinguish an integral
     type from a character type of the same size, for example it might
     make sense to set it for the C type `wchar_t' so the debugger can
     print such variables differently (Solaris does not do this).  Sun
     sets it on the C types `signed char' and `unsigned char' which
     arguably is wrong.  WIDTH and OFFSET appear to be for small
     objects stored in larger ones, for example a `short' in an `int'
     register.  WIDTH is normally the number of bytes in the type.
     oFFSET seems to always be zero.  NBITS is the number of bits in
     the type.

     Note that type descriptor `b' used for builtin types conflicts with
     its use for Pascal space types (*note Miscellaneous Types::.);
     they can be distinguished because the character following the type
     descriptor will be a digit, `(', or `-' for a Pascal space type, or
     `u' or `s' for a builtin type.

`w'
     Documented by AIX to define a wide character type, but their
     compiler actually uses negative type numbers (*note Negative Type
     Numbers::.).

`R FP-TYPE ; BYTES ;'
     Define a floating point type.  FP-TYPE has one of the following
     values:

    `1 (NF_SINGLE)'
          IEEE 32-bit (single precision) floating point format.

    `2 (NF_DOUBLE)'
          IEEE 64-bit (double precision) floating point format.

    `3 (NF_COMPLEX)'
    `4 (NF_COMPLEX16)'
    `5 (NF_COMPLEX32)'
          These are for complex numbers.  A comment in the GDB source
          describes them as Fortran `complex', `double complex', and
          `complex*16', respectively, but what does that mean?  (i.e.,
          Single precision?  Double precison?).

    `6 (NF_LDOUBLE)'
          Long double.  This should probably only be used for Sun format
          `long double', and new codes should be used for other floating
          point formats (`NF_DOUBLE' can be used if a `long double' is
          really just an IEEE double, of course).

     BYTES is the number of bytes occupied by the type.  This allows a
     debugger to perform some operations with the type even if it
     doesn't understand FP-TYPE.

`g TYPE-INFORMATION ; NBITS'
     Documented by AIX to define a floating type, but their compiler
     actually uses negative type numbers (*note Negative Type
     Numbers::.).

`c TYPE-INFORMATION ; NBITS'
     Documented by AIX to define a complex type, but their compiler
     actually uses negative type numbers (*note Negative Type
     Numbers::.).

   The C `void' type is defined as a signed integral type 0 bits long:
     .stabs "void:t19=bs0;0;0",128,0,0,0
   The Solaris compiler seems to omit the trailing semicolon in this
case.  Getting sloppy in this way is not a swift move because if a type
is embedded in a more complex expression it is necessary to be able to
tell where it ends.

   I'm not sure how a boolean type is represented.


File: stabs.info,  Node: Negative Type Numbers,  Prev: Builtin Type Descriptors,  Up: Builtin Types

Negative Type Numbers
---------------------

   This is the method used in XCOFF for defining builtin types.  Since
the debugger knows about the builtin types anyway, the idea of negative
type numbers is simply to give a special type number which indicates
the builtin type.  There is no stab defining these types.

   There are several subtle issues with negative type numbers.

   One is the size of the type.  A builtin type (for example the C types
`int' or `long') might have different sizes depending on compiler
options, the target architecture, the ABI, etc.  This issue doesn't
come up for IBM tools since (so far) they just target the RS/6000; the
sizes indicated below for each size are what the IBM RS/6000 tools use.
To deal with differing sizes, either define separate negative type
numbers for each size (which works but requires changing the debugger,
and, unless you get both AIX dbx and GDB to accept the change,
introduces an incompatibility), or use a type attribute (*note String
Field::.) to define a new type with the appropriate size (which merely
requires a debugger which understands type attributes, like AIX dbx).
For example,

     .stabs "boolean:t10=@s8;-16",128,0,0,0

   defines an 8-bit boolean type, and

     .stabs "boolean:t10=@s64;-16",128,0,0,0

   defines a 64-bit boolean type.

   A similar issue is the format of the type.  This comes up most often
for floating-point types, which could have various formats (particularly
extended doubles, which vary quite a bit even among IEEE systems).
Again, it is best to define a new negative type number for each
different format; changing the format based on the target system has
various problems.  One such problem is that the Alpha has both VAX and
IEEE floating types.  One can easily imagine one library using the VAX
types and another library in the same executable using the IEEE types.
Another example is that the interpretation of whether a boolean is true
or false can be based on the least significant bit, most significant
bit, whether it is zero, etc., and different compilers (or different
options to the same compiler) might provide different kinds of boolean.

   The last major issue is the names of the types.  The name of a given
type depends *only* on the negative type number given; these do not
vary depending on the language, the target system, or anything else.
One can always define separate type numbers--in the following list you
will see for example separate `int' and `integer*4' types which are
identical except for the name.  But compatibility can be maintained by
not inventing new negative type numbers and instead just defining a new
type with a new name.  For example:

     .stabs "CARDINAL:t10=-8",128,0,0,0

   Here is the list of negative type numbers.  The phrase "integral
type" is used to mean twos-complement (I strongly suspect that all
machines which use stabs use twos-complement; most machines use
twos-complement these days).

`-1'
     `int', 32 bit signed integral type.

`-2'
     `char', 8 bit type holding a character.   Both GDB and dbx on AIX
     treat this as signed.  GCC uses this type whether `char' is signed
     or not, which seems like a bad idea.  The AIX compiler (`xlc')
     seems to avoid this type; it uses -5 instead for `char'.

`-3'
     `short', 16 bit signed integral type.

`-4'
     `long', 32 bit signed integral type.

`-5'
     `unsigned char', 8 bit unsigned integral type.

`-6'
     `signed char', 8 bit signed integral type.

`-7'
     `unsigned short', 16 bit unsigned integral type.

`-8'
     `unsigned int', 32 bit unsigned integral type.

`-9'
     `unsigned', 32 bit unsigned integral type.

`-10'
     `unsigned long', 32 bit unsigned integral type.

`-11'
     `void', type indicating the lack of a value.

`-12'
     `float', IEEE single precision.

`-13'
     `double', IEEE double precision.

`-14'
     `long double', IEEE double precision.  The compiler claims the size
     will increase in a future release, and for binary compatibility
     you have to avoid using `long double'.  I hope when they increase
     it they use a new negative type number.

`-15'
     `integer'.  32 bit signed integral type.

`-16'
     `boolean'.  32 bit type.  How is the truth value encoded?  Is it
     the least significant bit or is it a question of whether the whole
     value is zero or non-zero?

`-17'
     `short real'.  IEEE single precision.

`-18'
     `real'.  IEEE double precision.

`-19'
     `stringptr'.  *Note Strings::.

`-20'
     `character', 8 bit unsigned character type.

`-21'
     `logical*1', 8 bit type.  This Fortran type has a split
     personality in that it is used for boolean variables, but can also
     be used for unsigned integers.  0 is false, 1 is true, and other
     values are non-boolean.

`-22'
     `logical*2', 16 bit type.  This Fortran type has a split
     personality in that it is used for boolean variables, but can also
     be used for unsigned integers.  0 is false, 1 is true, and other
     values are non-boolean.

`-23'
     `logical*4', 32 bit type.  This Fortran type has a split
     personality in that it is used for boolean variables, but can also
     be used for unsigned integers.  0 is false, 1 is true, and other
     values are non-boolean.

`-24'
     `logical', 32 bit type.  This Fortran type has a split personality
     in that it is used for boolean variables, but can also be used for
     unsigned integers.  0 is false, 1 is true, and other values are
     non-boolean.

`-25'
     `complex'.  A complex type consisting of two IEEE single-precision
     floating point values.

`-26'
     `complex'.  A complex type consisting of two IEEE double-precision
     floating point values.

`-27'
     `integer*1', 8 bit signed integral type.

`-28'
     `integer*2', 16 bit signed integral type.

`-29'
     `integer*4', 32 bit signed integral type.

`-30'
     `wchar'.  Wide character, 16 bits wide, unsigned (what format?
     Unicode?).


File: stabs.info,  Node: Miscellaneous Types,  Next: Cross-References,  Prev: Builtin Types,  Up: Types

Miscellaneous Types
===================

`b TYPE-INFORMATION ; BYTES'
     Pascal space type.  This is documented by IBM; what does it mean?

     This use of the `b' type descriptor can be distinguished from its
     use for builtin integral types (*note Builtin Type Descriptors::.)
     because the character following the type descriptor is always a
     digit, `(', or `-'.

`B TYPE-INFORMATION'
     A volatile-qualified version of TYPE-INFORMATION.  This is a Sun
     extension.  References and stores to a variable with a
     volatile-qualified type must not be optimized or cached; they must
     occur as the user specifies them.

`d TYPE-INFORMATION'
     File of type TYPE-INFORMATION.  As far as I know this is only used
     by Pascal.

`k TYPE-INFORMATION'
     A const-qualified version of TYPE-INFORMATION.  This is a Sun
     extension.  A variable with a const-qualified type cannot be
     modified.

`M TYPE-INFORMATION ; LENGTH'
     Multiple instance type.  The type seems to composed of LENGTH
     repetitions of TYPE-INFORMATION, for example `character*3' is
     represented by `M-2;3', where `-2' is a reference to a character
     type (*note Negative Type Numbers::.).  I'm not sure how this
     differs from an array.  This appears to be a Fortran feature.
     lENGTH is a bound, like those in range types; see *Note
     Subranges::.

`S TYPE-INFORMATION'
     Pascal set type.  TYPE-INFORMATION must be a small type such as an
     enumeration or a subrange, and the type is a bitmask whose length
     is specified by the number of elements in TYPE-INFORMATION.

`* TYPE-INFORMATION'
     Pointer to TYPE-INFORMATION.


File: stabs.info,  Node: Cross-References,  Next: Subranges,  Prev: Miscellaneous Types,  Up: Types

Cross-References to Other Types
===============================

   A type can be used before it is defined; one common way to deal with
that situation is just to use a type reference to a type which has not
yet been defined.

   Another way is with the `x' type descriptor, which is followed by
`s' for a structure tag, `u' for a union tag, or `e' for a enumerator
tag, followed by the name of the tag, followed by `:'.  For example,
the following C declarations:

     struct foo;
     struct foo *bar;

produce:

     .stabs "bar:G16=*17=xsfoo:",32,0,0,0

   Not all debuggers support the `x' type descriptor, so on some
machines GCC does not use it.  I believe that for the above example it
would just emit a reference to type 17 and never define it, but I
haven't verified that.

   Modula-2 imported types, at least on AIX, use the `i' type
descriptor, which is followed by the name of the module from which the
type is imported, followed by `:', followed by the name of the type.
There is then optionally a comma followed by type information for the
type.  This differs from merely naming the type (*note Typedefs::.) in
that it identifies the module; I don't understand whether the name of
the type given here is always just the same as the name we are giving
it, or whether this type descriptor is used with a nameless stab (*note
String Field::.), or what.  The symbol ends with `;'.


File: stabs.info,  Node: Subranges,  Next: Arrays,  Prev: Cross-References,  Up: Types

Subrange Types
==============

   The `r' type descriptor defines a type as a subrange of another
type.  It is followed by type information for the type of which it is a
subrange, a semicolon, an integral lower bound, a semicolon, an
integral upper bound, and a semicolon.  The AIX documentation does not
specify the trailing semicolon, in an effort to specify array indexes
more cleanly, but a subrange which is not an array index has always
included a trailing semicolon (*note Arrays::.).

   Instead of an integer, either bound can be one of the following:

`A OFFSET'
     The bound is passed by reference on the stack at offset OFFSET
     from the argument list.  *Note Parameters::, for more information
     on such offsets.

`T OFFSET'
     The bound is passed by value on the stack at offset OFFSET from
     the argument list.

`a REGISTER-NUMBER'
     The bound is pased by reference in register number REGISTER-NUMBER.

`t REGISTER-NUMBER'
     The bound is passed by value in register number REGISTER-NUMBER.

`J'
     There is no bound.

   Subranges are also used for builtin types; see *Note Traditional
Builtin Types::.


File: stabs.info,  Node: Arrays,  Next: Strings,  Prev: Subranges,  Up: Types

Array Types
===========

   Arrays use the `a' type descriptor.  Following the type descriptor
is the type of the index and the type of the array elements.  If the
index type is a range type, it ends in a semicolon; otherwise (for
example, if it is a type reference), there does not appear to be any
way to tell where the types are separated.  In an effort to clean up
this mess, IBM documents the two types as being separated by a
semicolon, and a range type as not ending in a semicolon (but this is
not right for range types which are not array indexes, *note
Subranges::.).  I think probably the best solution is to specify that a
semicolon ends a range type, and that the index type and element type
of an array are separated by a semicolon, but that if the index type is
a range type, the extra semicolon can be omitted.  GDB (at least
through version 4.9) doesn't support any kind of index type other than a
range anyway; I'm not sure about dbx.

   It is well established, and widely used, that the type of the index,
unlike most types found in the stabs, is merely a type definition, not
type information (*note String Field::.) (that is, it need not start
with `TYPE-NUMBER=' if it is defining a new type).  According to a
comment in GDB, this is also true of the type of the array elements; it
gives `ar1;1;10;ar1;1;10;4' as a legitimate way to express a two
dimensional array.  According to AIX documentation, the element type
must be type information.  GDB accepts either.

   The type of the index is often a range type, expressed as the type
descriptor `r' and some parameters.  It defines the size of the array.
In the example below, the range `r1;0;2;' defines an index type which
is a subrange of type 1 (integer), with a lower bound of 0 and an upper
bound of 2.  This defines the valid range of subscripts of a
three-element C array.

   For example, the definition:

     char char_vec[3] = {'a','b','c'};

produces the output:

     .stabs "char_vec:G19=ar1;0;2;2",32,0,0,0
          .global _char_vec
          .align 4
     _char_vec:
          .byte 97
          .byte 98
          .byte 99

   If an array is "packed", the elements are spaced more closely than
normal, saving memory at the expense of speed.  For example, an array
of 3-byte objects might, if unpacked, have each element aligned on a
4-byte boundary, but if packed, have no padding.  One way to specify
that something is packed is with type attributes (*note String
Field::.).  In the case of arrays, another is to use the `P' type
descriptor instead of `a'.  Other than specifying a packed array, `P'
is identical to `a'.

   An open array is represented by the `A' type descriptor followed by
type information specifying the type of the array elements.

   An N-dimensional dynamic array is represented by

     D DIMENSIONS ; TYPE-INFORMATION

   DIMENSIONS is the number of dimensions; TYPE-INFORMATION specifies
the type of the array elements.

   A subarray of an N-dimensional array is represented by

     E DIMENSIONS ; TYPE-INFORMATION

   DIMENSIONS is the number of dimensions; TYPE-INFORMATION specifies
the type of the array elements.


File: stabs.info,  Node: Strings,  Next: Enumerations,  Prev: Arrays,  Up: Types

Strings
=======

   Some languages, like C or the original Pascal, do not have string
types, they just have related things like arrays of characters.  But
most Pascals and various other languages have string types, which are
indicated as follows:

`n TYPE-INFORMATION ; BYTES'
     BYTES is the maximum length.  I'm not sure what TYPE-INFORMATION
     is; I suspect that it means that this is a string of
     TYPE-INFORMATION (thus allowing a string of integers, a string of
     wide characters, etc., as well as a string of characters).  Not
     sure what the format of this type is.  This is an AIX feature.

`z TYPE-INFORMATION ; BYTES'
     Just like `n' except that this is a gstring, not an ordinary
     string.  I don't know the difference.

`N'
     Pascal Stringptr.  What is this?  This is an AIX feature.


File: stabs.info,  Node: Enumerations,  Next: Structures,  Prev: Strings,  Up: Types

Enumerations
============

   Enumerations are defined with the `e' type descriptor.

   The source line below declares an enumeration type at file scope.
The type definition is located after the `N_RBRAC' that marks the end of
the previous procedure's block scope, and before the `N_FUN' that marks
the beginning of the next procedure's block scope.  Therefore it does
not describe a block local symbol, but a file local one.

   The source line:

     enum e_places {first,second=3,last};

generates the following stab:

     .stabs "e_places:T22=efirst:0,second:3,last:4,;",128,0,0,0

   The symbol descriptor (`T') says that the stab describes a
structure, enumeration, or union tag.  The type descriptor `e',
following the `22=' of the type definition narrows it down to an
enumeration type.  Following the `e' is a list of the elements of the
enumeration.  The format is `NAME:VALUE,'.  The list of elements ends
with `;'.

   There is no standard way to specify the size of an enumeration type;
it is determined by the architecture (normally all enumerations types
are 32 bits).  There should be a way to specify an enumeration type of
another size; type attributes would be one way to do this.  *Note Stabs
Format::.


File: stabs.info,  Node: Structures,  Next: Typedefs,  Prev: Enumerations,  Up: Types

Structures
==========

   The encoding of structures in stabs can be shown with an example.

   The following source code declares a structure tag and defines an
instance of the structure in global scope. Then a `typedef' equates the
structure tag with a new type.  Seperate stabs are generated for the
structure tag, the structure `typedef', and the structure instance.  The
stabs for the tag and the `typedef' are emited when the definitions are
encountered.  Since the structure elements are not initialized, the
stab and code for the structure variable itself is located at the end
of the program in the bss section.

     struct s_tag {
       int   s_int;
       float s_float;
       char  s_char_vec[8];
       struct s_tag* s_next;
     } g_an_s;
     
     typedef struct s_tag s_typedef;

   The structure tag has an `N_LSYM' stab type because, like the
enumeration, the symbol has file scope.  Like the enumeration, the
symbol descriptor is `T', for enumeration, structure, or tag type.  The
type descriptor `s' following the `16=' of the type definition narrows
the symbol type to structure.

   Following the `s' type descriptor is the number of bytes the
structure occupies, followed by a description of each structure element.
The structure element descriptions are of the form NAME:TYPE, BIT
OFFSET FROM THE START OF THE STRUCT, NUMBER OF BITS IN THE ELEMENT.

     # 128 is N_LSYM
     .stabs "s_tag:T16=s20s_int:1,0,32;s_float:12,32,32;
             s_char_vec:17=ar1;0;7;2,64,64;s_next:18=*16,128,32;;",128,0,0,0

   In this example, the first two structure elements are previously
defined types.  For these, the type following the `NAME:' part of the
element description is a simple type reference.  The other two structure
elements are new types.  In this case there is a type definition
embedded after the `NAME:'.  The type definition for the array element
looks just like a type definition for a standalone array.  The `s_next'
field is a pointer to the same kind of structure that the field is an
element of.  So the definition of structure type 16 contains a type
definition for an element which is a pointer to type 16.


File: stabs.info,  Node: Typedefs,  Next: Unions,  Prev: Structures,  Up: Types

Giving a Type a Name
====================

   To give a type a name, use the `t' symbol descriptor.  The type is
specified by the type information (*note String Field::.) for the stab.
For example,

     .stabs "s_typedef:t16",128,0,0,0     # 128 is N_LSYM

   specifies that `s_typedef' refers to type number 16.  Such stabs
have symbol type `N_LSYM' (or `C_DECL' for XCOFF).

   If you are specifying the tag name for a structure, union, or
enumeration, use the `T' symbol descriptor instead.  I believe C is the
only language with this feature.

   If the type is an opaque type (I believe this is a Modula-2 feature),
AIX provides a type descriptor to specify it.  The type descriptor is
`o' and is followed by a name.  I don't know what the name means--is it
always the same as the name of the type, or is this type descriptor
used with a nameless stab (*note String Field::.)?  There optionally
follows a comma followed by type information which defines the type of
this type.  If omitted, a semicolon is used in place of the comma and
the type information, and the type is much like a generic pointer
type--it has a known size but little else about it is specified.


File: stabs.info,  Node: Unions,  Next: Function Types,  Prev: Typedefs,  Up: Types

Unions
======

     union u_tag {
       int  u_int;
       float u_float;
       char* u_char;
     } an_u;

   This code generates a stab for a union tag and a stab for a union
variable.  Both use the `N_LSYM' stab type.  If a union variable is
scoped locally to the procedure in which it is defined, its stab is
located immediately preceding the `N_LBRAC' for the procedure's block
start.

   The stab for the union tag, however, is located preceding the code
for the procedure in which it is defined.  The stab type is `N_LSYM'.
This would seem to imply that the union type is file scope, like the
struct type `s_tag'.  This is not true.  The contents and position of
the stab for `u_type' do not convey any infomation about its procedure
local scope.

     # 128 is N_LSYM
     .stabs "u_tag:T23=u4u_int:1,0,32;u_float:12,0,32;u_char:21,0,32;;",
            128,0,0,0

   The symbol descriptor `T', following the `name:' means that the stab
describes an enumeration, structure, or union tag.  The type descriptor
`u', following the `23=' of the type definition, narrows it down to a
union type definition.  Following the `u' is the number of bytes in the
union.  After that is a list of union element descriptions.  Their
format is NAME:TYPE, BIT OFFSET INTO THE UNION, NUMBER OF BYTES FOR THE
ELEMENT;.

   The stab for the union variable is:

     .stabs "an_u:23",128,0,0,-20     # 128 is N_LSYM

   `-20' specifies where the variable is stored (*note Stack
Variables::.).


File: stabs.info,  Node: Function Types,  Prev: Unions,  Up: Types

Function Types
==============

   Various types can be defined for function variables.  These types are
not used in defining functions (*note Procedures::.); they are used for
things like pointers to functions.

   The simple, traditional, type is type descriptor `f' is followed by
type information for the return type of the function, followed by a
semicolon.

   This does not deal with functions for which the number and types of
the parameters are part of the type, as in Modula-2 or ANSI C.  AIX
provides extensions to specify these, using the `f', `F', `p', and `R'
type descriptors.

   First comes the type descriptor.  If it is `f' or `F', this type
involves a function rather than a procedure, and the type information
for the return type of the function follows, followed by a comma.  Then
comes the number of parameters to the function and a semicolon.  Then,
for each parameter, there is the name of the parameter followed by a
colon (this is only present for type descriptors `R' and `F' which
represent Pascal function or procedure parameters), type information
for the parameter, a comma, 0 if passed by reference or 1 if passed by
value, and a semicolon.  The type definition ends with a semicolon.

   For example, this variable definition:

     int (*g_pf)();

generates the following code:

     .stabs "g_pf:G24=*25=f1",32,0,0,0
         .common _g_pf,4,"bss"

   The variable defines a new type, 24, which is a pointer to another
new type, 25, which is a function returning `int'.


File: stabs.info,  Node: Symbol Tables,  Next: Cplusplus,  Prev: Types,  Up: Top

Symbol Information in Symbol Tables
***********************************

   This chapter describes the format of symbol table entries and how
stab assembler directives map to them.  It also describes the
transformations that the assembler and linker make on data from stabs.

* Menu:

* Symbol Table Format::
* Transformations On Symbol Tables::


File: stabs.info,  Node: Symbol Table Format,  Next: Transformations On Symbol Tables,  Up: Symbol Tables

Symbol Table Format
===================

   Each time the assembler encounters a stab directive, it puts each
field of the stab into a corresponding field in a symbol table entry of
its output file.  If the stab contains a string field, the symbol table
entry for that stab points to a string table entry containing the
string data from the stab.  Assembler labels become relocatable
addresses.  Symbol table entries in a.out have the format:

     struct internal_nlist {
       unsigned long n_strx;         /* index into string table of name */
       unsigned char n_type;         /* type of symbol */
       unsigned char n_other;        /* misc info (usually empty) */
       unsigned short n_desc;        /* description field */
       bfd_vma n_value;              /* value of symbol */
     };

   If the stab has a string, the `n_strx' field holds the offset in
bytes of the string within the string table.  The string is terminated
by a NUL character.  If the stab lacks a string (for example, it was
produced by a `.stabn' or `.stabd' directive), the `n_strx' field is
zero.

   Symbol table entries with `n_type' field values greater than 0x1f
originated as stabs generated by the compiler (with one random
exception).  The other entries were placed in the symbol table of the
executable by the assembler or the linker.


File: stabs.info,  Node: Transformations On Symbol Tables,  Prev: Symbol Table Format,  Up: Symbol Tables

Transformations on Symbol Tables
================================

   The linker concatenates object files and does fixups of externally
defined symbols.

   You can see the transformations made on stab data by the assembler
and linker by examining the symbol table after each pass of the build.
To do this, use `nm -ap', which dumps the symbol table, including
debugging information, unsorted.  For stab entries the columns are:
VALUE, OTHER, DESC, TYPE, STRING.  For assembler and linker symbols,
the columns are: VALUE, TYPE, STRING.

   The low 5 bits of the stab type tell the linker how to relocate the
value of the stab.  Thus for stab types like `N_RSYM' and `N_LSYM',
where the value is an offset or a register number, the low 5 bits are
`N_ABS', which tells the linker not to relocate the value.

   Where the value of a stab contains an assembly language label, it is
transformed by each build step.  The assembler turns it into a
relocatable address and the linker turns it into an absolute address.

* Menu:

* Transformations On Static Variables::
* Transformations On Global Variables::
* ELF Transformations::	       In ELF, things are a bit different.


File: stabs.info,  Node: Transformations On Static Variables,  Next: Transformations On Global Variables,  Up: Transformations On Symbol Tables

Transformations on Static Variables
-----------------------------------

   This source line defines a static variable at file scope:

     static int s_g_repeat

The following stab describes the symbol:

     .stabs "s_g_repeat:S1",38,0,0,_s_g_repeat

The assembler transforms the stab into this symbol table entry in the
`.o' file.  The location is expressed as a data segment offset.

     00000084 - 00 0000 STSYM s_g_repeat:S1

In the symbol table entry from the executable, the linker has made the
relocatable address absolute.

     0000e00c - 00 0000 STSYM s_g_repeat:S1


File: stabs.info,  Node: Transformations On Global Variables,  Next: ELF Transformations,  Prev: Transformations On Static Variables,  Up: Transformations On Symbol Tables

Transformations on Global Variables
-----------------------------------

   Stabs for global variables do not contain location information. In
this case, the debugger finds location information in the assembler or
linker symbol table entry describing the variable.  The source line:

     char g_foo = 'c';

generates the stab:

     .stabs "g_foo:G2",32,0,0,0

   The variable is represented by two symbol table entries in the object
file (see below).  The first one originated as a stab.  The second one
is an external symbol.  The upper case `D' signifies that the `n_type'
field of the symbol table contains 7, `N_DATA' with local linkage.  The
stab's value is zero since the value is not used for `N_GSYM' stabs.
The value of the linker symbol is the relocatable address corresponding
to the variable.

     00000000 - 00 0000  GSYM g_foo:G2
     00000080 D _g_foo

These entries as transformed by the linker.  The linker symbol table
entry now holds an absolute address:

     00000000 - 00 0000  GSYM g_foo:G2
     ...
     0000e008 D _g_foo


File: stabs.info,  Node: ELF Transformations,  Prev: Transformations On Global Variables,  Up: Transformations On Symbol Tables

Transformations of Stabs in ELF Files
-------------------------------------

   For ELF files, use `objdump --stabs' instead of `nm' to show the
stabs in an object or executable file.  `objdump' is a GNU utility; Sun
does not provide any equivalent.

   The following example is for a stab whose value is an address is
relative to the compilation unit (*note Stabs In ELF::.).  For example,
if the source line

     static int ld = 5;

   appears within a function, then the assembly language output from the
compiler contains:

     .Ddata.data:
     ...
             .stabs "ld:V(0,3)",0x26,0,4,.L18-Ddata.data    # 0x26 is N_STSYM
     ...
     .L18:
             .align 4
             .word 0x5

   Because the value is formed by subtracting one symbol from another,
the value is absolute, not relocatable, and so the object file contains

     Symnum n_type n_othr n_desc n_value  n_strx String
     31     STSYM  0      4      00000004 680    ld:V(0,3)

   without any relocations, and the executable file also contains

     Symnum n_type n_othr n_desc n_value  n_strx String
     31     STSYM  0      4      00000004 680    ld:V(0,3)


File: stabs.info,  Node: Cplusplus,  Next: Stab Types,  Prev: Symbol Tables,  Up: Top

GNU C++ Stabs
*************

* Menu:

* Basic Cplusplus Types::
* Simple Classes::
* Class Instance::
* Methods::			Method definition
* Protections::
* Method Modifiers::
* Virtual Methods::
* Inheritence::
* Virtual Base Classes::
* Static Members::

   Type descriptors added for C++ descriptions:

`#'
     method type (`##' if minimal debug)

`@'
     Member (class and variable) type.  It is followed by type
     information for the offset basetype, a comma, and type information
     for the type of the field being pointed to.  (FIXME: this is
     acknowledged to be gibberish.  Can anyone say what really goes
     here?).

     Note that there is a conflict between this and type attributes
     (*note String Field::.); both use type descriptor `@'.
     Fortunately, the `@' type descriptor used in this C++ sense always
     will be followed by a digit, `(', or `-', and type attributes
     never start with those things.


File: stabs.info,  Node: Basic Cplusplus Types,  Next: Simple Classes,  Up: Cplusplus

Basic Types For C++
===================

   << the examples that follow are based on a01.C >>

   C++ adds two more builtin types to the set defined for C.  These are
the unknown type and the vtable record type.  The unknown type, type
16, is defined in terms of itself like the void type.

   The vtable record type, type 17, is defined as a structure type and
then as a structure tag.  The structure has four fields: delta, index,
pfn, and delta2.  pfn is the function pointer.

   << In boilerplate $vtbl_ptr_type, what are the fields delta, index,
and delta2 used for? >>

   This basic type is present in all C++ programs even if there are no
virtual methods defined.

     .stabs "struct_name:sym_desc(type)type_def(17)=type_desc(struct)struct_bytes(8)
             elem_name(delta):type_ref(short int),bit_offset(0),field_bits(16);
             elem_name(index):type_ref(short int),bit_offset(16),field_bits(16);
             elem_name(pfn):type_def(18)=type_desc(ptr to)type_ref(void),
                                         bit_offset(32),field_bits(32);
             elem_name(delta2):type_def(short int);bit_offset(32),field_bits(16);;"
             N_LSYM, NIL, NIL

     .stabs "$vtbl_ptr_type:t17=s8
             delta:6,0,16;index:6,16,16;pfn:18=*15,32,32;delta2:6,32,16;;"
             ,128,0,0,0

     .stabs "name:sym_dec(struct tag)type_ref($vtbl_ptr_type)",N_LSYM,NIL,NIL,NIL

     .stabs "$vtbl_ptr_type:T17",128,0,0,0


File: stabs.info,  Node: Simple Classes,  Next: Class Instance,  Prev: Basic Cplusplus Types,  Up: Cplusplus

Simple Class Definition
=======================

   The stabs describing C++ language features are an extension of the
stabs describing C.  Stabs representing C++ class types elaborate
extensively on the stab format used to describe structure types in C.
Stabs representing class type variables look just like stabs
representing C language variables.

   Consider the following very simple class definition.

     class baseA {
     public:
             int Adat;
             int Ameth(int in, char other);
     };

   The class `baseA' is represented by two stabs.  The first stab
describes the class as a structure type.  The second stab describes a
structure tag of the class type.  Both stabs are of stab type `N_LSYM'.
Since the stab is not located between an `N_FUN' and an `N_LBRAC' stab
this indicates that the class is defined at file scope.  If it were,
then the `N_LSYM' would signify a local variable.

   A stab describing a C++ class type is similar in format to a stab
describing a C struct, with each class member shown as a field in the
structure.  The part of the struct format describing fields is expanded
to include extra information relevent to C++ class members.  In
addition, if the class has multiple base classes or virtual functions
the struct format outside of the field parts is also augmented.

   In this simple example the field part of the C++ class stab
representing member data looks just like the field part of a C struct
stab.  The section on protections describes how its format is sometimes
extended for member data.

   The field part of a C++ class stab representing a member function
differs substantially from the field part of a C struct stab.  It still
begins with `name:' but then goes on to define a new type number for
the member function, describe its return type, its argument types, its
protection level, any qualifiers applied to the method definition, and
whether the method is virtual or not.  If the method is virtual then
the method description goes on to give the vtable index of the method,
and the type number of the first base class defining the method.

   When the field name is a method name it is followed by two colons
rather than one.  This is followed by a new type definition for the
method.  This is a number followed by an equal sign and the type
descriptor `#', indicating a method type, and a second `#', indicating
that this is the "minimal" type of method definition used by GCC2, not
larger method definitions used by earlier versions of GCC.  This is
followed by a type reference showing the return type of the method and a
semi-colon.

   The format of an overloaded operator method name differs from that of
other methods.  It is `op$::OPERATOR-NAME.' where OPERATOR-NAME is the
operator name such as `+' or `+='.  The name ends with a period, and
any characters except the period can occur in the OPERATOR-NAME string.

   The next part of the method description represents the arguments to
the method, preceeded by a colon and ending with a semi-colon.  The
types of the arguments are expressed in the same way argument types are
expressed in C++ name mangling.  In this example an `int' and a `char'
map to `ic'.

   This is followed by a number, a letter, and an asterisk or period,
followed by another semicolon.  The number indicates the protections
that apply to the member function.  Here the 2 means public.  The
letter encodes any qualifier applied to the method definition.  In this
case, `A' means that it is a normal function definition.  The dot shows
that the method is not virtual.  The sections that follow elaborate
further on these fields and describe the additional information present
for virtual methods.

     .stabs "class_name:sym_desc(type)type_def(20)=type_desc(struct)struct_bytes(4)
             field_name(Adat):type(int),bit_offset(0),field_bits(32);
     
             method_name(Ameth)::type_def(21)=type_desc(method)return_type(int);
             :arg_types(int char);
             protection(public)qualifier(normal)virtual(no);;"
             N_LSYM,NIL,NIL,NIL

     .stabs "baseA:t20=s4Adat:1,0,32;Ameth::21=##1;:ic;2A.;;",128,0,0,0
     
     .stabs "class_name:sym_desc(struct tag)",N_LSYM,NIL,NIL,NIL
     
     .stabs "baseA:T20",128,0,0,0


File: stabs.info,  Node: Class Instance,  Next: Methods,  Prev: Simple Classes,  Up: Cplusplus

Class Instance
==============

   As shown above, describing even a simple C++ class definition is
accomplished by massively extending the stab format used in C to
describe structure types.  However, once the class is defined, C stabs
with no modifications can be used to describe class instances.  The
following source:

     main () {
             baseA AbaseA;
     }

yields the following stab describing the class instance.  It looks no
different from a standard C stab describing a local variable.

     .stabs "name:type_ref(baseA)", N_LSYM, NIL, NIL, frame_ptr_offset

     .stabs "AbaseA:20",128,0,0,-20


File: stabs.info,  Node: Methods,  Next: Protections,  Prev: Class Instance,  Up: Cplusplus

Method Definition
=================

   The class definition shown above declares Ameth.  The C++ source
below defines Ameth:

     int
     baseA::Ameth(int in, char other)
     {
             return in;
     };

   This method definition yields three stabs following the code of the
method.  One stab describes the method itself and following two describe
its parameters.  Although there is only one formal argument all methods
have an implicit argument which is the `this' pointer.  The `this'
pointer is a pointer to the object on which the method was called.  Note
that the method name is mangled to encode the class name and argument
types.  Name mangling is described in the ARM (`The Annotated C++
Reference Manual', by Ellis and Stroustrup, ISBN 0-201-51459-1);
`gpcompare.texi' in Cygnus GCC distributions describes the differences
between GNU mangling and ARM mangling.

     .stabs "name:symbol_desriptor(global function)return_type(int)",
             N_FUN, NIL, NIL, code_addr_of_method_start
     
     .stabs "Ameth__5baseAic:F1",36,0,0,_Ameth__5baseAic

   Here is the stab for the `this' pointer implicit argument.  The name
of the `this' pointer is always `this'.  Type 19, the `this' pointer is
defined as a pointer to type 20, `baseA', but a stab defining `baseA'
has not yet been emited.  Since the compiler knows it will be emited
shortly, here it just outputs a cross reference to the undefined
symbol, by prefixing the symbol name with `xs'.

     .stabs "name:sym_desc(register param)type_def(19)=
             type_desc(ptr to)type_ref(baseA)=
             type_desc(cross-reference to)baseA:",N_RSYM,NIL,NIL,register_number
     
     .stabs "this:P19=*20=xsbaseA:",64,0,0,8

   The stab for the explicit integer argument looks just like a
parameter to a C function.  The last field of the stab is the offset
from the argument pointer, which in most systems is the same as the
frame pointer.

     .stabs "name:sym_desc(value parameter)type_ref(int)",
             N_PSYM,NIL,NIL,offset_from_arg_ptr
     
     .stabs "in:p1",160,0,0,72

   << The examples that follow are based on A1.C >>


File: stabs.info,  Node: Protections,  Next: Method Modifiers,  Prev: Methods,  Up: Cplusplus

Protections
===========

   In the simple class definition shown above all member data and
functions were publicly accessable.  The example that follows contrasts
public, protected and privately accessable fields and shows how these
protections are encoded in C++ stabs.

   Protections for class member data are signified by two characters
embedded in the stab defining the class type.  These characters are
located after the name: part of the string.  `/0' means private, `/1'
means protected, and `/2' means public.  If these characters are omited
this means that the member is public.  The following C++ source:

     class all_data {
     private:
             int   priv_dat;
     protected:
             char  prot_dat;
     public:
             float pub_dat;
     };

generates the following stab to describe the class type all_data.

     .stabs "class_name:sym_desc(type)type_def(19)=type_desc(struct)struct_bytes
             data_name:/protection(private)type_ref(int),bit_offset,num_bits;
             data_name:/protection(protected)type_ref(char),bit_offset,num_bits;
             data_name:(/num omited, private)type_ref(float),bit_offset,num_bits;;"
             N_LSYM,NIL,NIL,NIL

     .stabs "all_data:t19=s12
             priv_dat:/01,0,32;prot_dat:/12,32,8;pub_dat:12,64,32;;",128,0,0,0

   Protections for member functions are signified by one digit embeded
in the field part of the stab describing the method.  The digit is 0 if
private, 1 if protected and 2 if public.  Consider the C++ class
definition below:

     class all_methods {
     private:
             int   priv_meth(int in){return in;};
     protected:
             char  protMeth(char in){return in;};
     public:
             float pubMeth(float in){return in;};
     };

   It generates the following stab.  The digit in question is to the
left of an `A' in each case.  Notice also that in this case two symbol
descriptors apply to the class name struct tag and struct type.

     .stabs "class_name:sym_desc(struct tag&type)type_def(21)=
             sym_desc(struct)struct_bytes(1)
             meth_name::type_def(22)=sym_desc(method)returning(int);
             :args(int);protection(private)modifier(normal)virtual(no);
             meth_name::type_def(23)=sym_desc(method)returning(char);
             :args(char);protection(protected)modifier(normal)virual(no);
             meth_name::type_def(24)=sym_desc(method)returning(float);
             :args(float);protection(public)modifier(normal)virtual(no);;",
             N_LSYM,NIL,NIL,NIL

     .stabs "all_methods:Tt21=s1priv_meth::22=##1;:i;0A.;protMeth::23=##2;:c;1A.;
             pubMeth::24=##12;:f;2A.;;",128,0,0,0


File: stabs.info,  Node: Method Modifiers,  Next: Virtual Methods,  Prev: Protections,  Up: Cplusplus

Method Modifiers (`const', `volatile', `const volatile')
========================================================

   << based on a6.C >>

   In the class example described above all the methods have the normal
modifier.  This method modifier information is located just after the
protection information for the method.  This field has four possible
character values.  Normal methods use `A', const methods use `B',
volatile methods use `C', and const volatile methods use `D'.  Consider
the class definition below:

     class A {
     public:
             int ConstMeth (int arg) const { return arg; };
             char VolatileMeth (char arg) volatile { return arg; };
             float ConstVolMeth (float arg) const volatile {return arg; };
     };

   This class is described by the following stab:

     .stabs "class(A):sym_desc(struct)type_def(20)=type_desc(struct)struct_bytes(1)
             meth_name(ConstMeth)::type_def(21)sym_desc(method)
             returning(int);:arg(int);protection(public)modifier(const)virtual(no);
             meth_name(VolatileMeth)::type_def(22)=sym_desc(method)
             returning(char);:arg(char);protection(public)modifier(volatile)virt(no)
             meth_name(ConstVolMeth)::type_def(23)=sym_desc(method)
             returning(float);:arg(float);protection(public)modifer(const volatile)
             virtual(no);;", ...

     .stabs "A:T20=s1ConstMeth::21=##1;:i;2B.;VolatileMeth::22=##2;:c;2C.;
                  ConstVolMeth::23=##12;:f;2D.;;",128,0,0,0

