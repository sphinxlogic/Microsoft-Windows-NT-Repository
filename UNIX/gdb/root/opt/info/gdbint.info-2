This is Info file gdbint.info, produced by Makeinfo-1.55 from the input
file ./gdbint.texinfo.

START-INFO-DIR-ENTRY
* Gdb-Internals: (gdbint).	The GNU debugger's internals.
END-INFO-DIR-ENTRY

   This file documents the internals of the GNU debugger GDB.

   Copyright 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
Contributed by Cygnus Support.  Written by John Gilmore.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy or distribute modified versions of this
manual under the terms of the GPL (for which purpose this text may be
regarded as a program in the language TeX).


File: gdbint.info,  Node: Remote Stubs,  Next: Longjmp Support,  Prev: Frames,  Up: Top

Remote Stubs
************

   GDB's file `remote.c' talks a serial protocol to code that runs in
the target system.  GDB provides several sample "stubs" that can be
integrated into target programs or operating systems for this purpose;
they are named `*-stub.c'.

   The GDB user's manual describes how to put such a stub into your
target code.  What follows is a discussion of integrating the SPARC stub
into a complicated operating system (rather than a simple program), by
Stu Grossman, the author of this stub.

   The trap handling code in the stub assumes the following upon entry
to trap_low:

  1. %l1 and %l2 contain pc and npc respectively at the time of the trap

  2. traps are disabled

  3. you are in the correct trap window

   As long as your trap handler can guarantee those conditions, then
there is no reason why you shouldn't be able to `share' traps with the
stub.  The stub has no requirement that it be jumped to directly from
the hardware trap vector.  That is why it calls `exceptionHandler()',
which is provided by the external environment.  For instance, this
could setup the hardware traps to actually execute code which calls the
stub first, and then transfers to its own trap handler.

   For the most point, there probably won't be much of an issue with
`sharing' traps, as the traps we use are usually not used by the
kernel, and often indicate unrecoverable error conditions.  Anyway,
this is all controlled by a table, and is trivial to modify.  The most
important trap for us is for `ta 1'.  Without that, we can't single
step or do breakpoints.  Everything else is unnecessary for the proper
operation of the debugger/stub.

   From reading the stub, it's probably not obvious how breakpoints
work.  They are simply done by deposit/examine operations from GDB.


File: gdbint.info,  Node: Longjmp Support,  Next: Coding Style,  Prev: Remote Stubs,  Up: Top

Longjmp Support
***************

   GDB has support for figuring out that the target is doing a
`longjmp' and for stopping at the target of the jump, if we are
stepping.  This is done with a few specialized internal breakpoints,
which are visible in the `maint info breakpoint' command.

   To make this work, you need to define a macro called
`GET_LONGJMP_TARGET', which will examine the `jmp_buf' structure and
extract the longjmp target address.  Since `jmp_buf' is target
specific, you will need to define it in the appropriate `tm-xxx.h'
file.  Look in `tm-sun4os4.h' and `sparc-tdep.c' for examples of how to
do this.


File: gdbint.info,  Node: Coding Style,  Next: Clean Design,  Prev: Longjmp Support,  Up: Top

Coding Style
************

   GDB is generally written using the GNU coding standards, as
described in `standards.texi', which is available for anonymous FTP
from GNU archive sites.  There are some additional considerations for
GDB maintainers that reflect the unique environment and style of GDB
maintenance.  If you follow these guidelines, GDB will be more
consistent and easier to maintain.

   GDB's policy on the use of prototypes is that prototypes are used to
*declare* functions but never to *define* them.  Simple macros are used
in the declarations, so that a non-ANSI compiler can compile GDB
without trouble.  The simple macro calls are used like this:

     extern int
     memory_remove_breakpoint PARAMS ((CORE_ADDR, char *));

   Note the double parentheses around the parameter types.  This allows
an arbitrary number of parameters to be described, without freaking out
the C preprocessor.  When the function has no parameters, it should be
described like:

     void
     noprocess PARAMS ((void));

   The `PARAMS' macro expands to its argument in ANSI C, or to a simple
`()' in traditional C.

   All external functions should have a `PARAMS' declaration in a
header file that callers include.  All static functions should have such
a declaration near the top of their source file.

   We don't have a gcc option that will properly check that these rules
have been followed, but it's GDB policy, and we periodically check it
using the tools available (plus manual labor), and clean up any
remnants.


File: gdbint.info,  Node: Clean Design,  Next: Submitting Patches,  Prev: Coding Style,  Up: Top

Clean Design
************

   In addition to getting the syntax right, there's the little question
of semantics.  Some things are done in certain ways in GDB because long
experience has shown that the more obvious ways caused various kinds of
trouble.  In particular:

*
     You can't assume the byte order of anything that comes from a
     target (including VALUEs, object files, and instructions).  Such
     things must be byte-swapped using `SWAP_TARGET_AND_HOST' in GDB,
     or one of the swap routines defined in `bfd.h', such as
     `bfd_get_32'.

*
     You can't assume that you know what interface is being used to
     talk to the target system.  All references to the target must go
     through the current `target_ops' vector.

*
     You can't assume that the host and target machines are the same
     machine (except in the "native" support modules).  In particular,
     you can't assume that the target machine's header files will be
     available on the host machine.  Target code must bring along its
     own header files - written from scratch or explicitly donated by
     their owner, to avoid copyright problems.

*
     Insertion of new `#ifdef''s will be frowned upon.  It's much better
     to write the code portably than to conditionalize it for various
     systems.

*
     New `#ifdef''s which test for specific compilers or manufacturers
     or operating systems are unacceptable.  All `#ifdef''s should test
     for features.  The information about which configurations contain
     which features should be segregated into the configuration files.
     Experience has proven far too often that a feature unique to one
     particular system often creeps into other systems; and that a
     conditional based on some predefined macro for your current system
     will become worthless over time, as new versions of your system
     come out that behave differently with regard to this feature.

*
     Adding code that handles specific architectures, operating
     systems, target interfaces, or hosts, is not acceptable in generic
     code.  If a hook is needed at that point, invent a generic hook
     and define it for your configuration, with something like:

          #ifdef	WRANGLE_SIGNALS
             WRANGLE_SIGNALS (signo);
          #endif

     In your host, target, or native configuration file, as appropriate,
     define `WRANGLE_SIGNALS' to do the machine-dependent thing.  Take
     a bit of care in defining the hook, so that it can be used by other
     ports in the future, if they need a hook in the same place.

     If the hook is not defined, the code should do whatever "most"
     machines want.  Using `#ifdef', as above, is the preferred way to
     do this, but sometimes that gets convoluted, in which case use

          #ifndef SPECIAL_FOO_HANDLING
          #define SPECIAL_FOO_HANDLING(pc, sp) (0)
          #endif

     where the macro is used or in an appropriate header file.

     Whether to include a "small" hook, a hook around the exact pieces
     of code which are system-dependent, or whether to replace a whole
     function with a hook depends on the case.  A good example of this
     dilemma can be found in `get_saved_register'.  All machines that
     GDB 2.8 ran on just needed the `FRAME_FIND_SAVED_REGS' hook to
     find the saved registers.  Then the SPARC and Pyramid came along,
     and `HAVE_REGISTER_WINDOWS' and `REGISTER_IN_WINDOW_P' were
     introduced.  Then the 29k and 88k required the `GET_SAVED_REGISTER'
     hook.  The first three are examples of small hooks; the latter
     replaces a whole function.  In this specific case, it is useful to
     have both kinds; it would be a bad idea to replace all the uses of
     the small hooks with `GET_SAVED_REGISTER', since that would result
     in much duplicated code.  Other times, duplicating a few lines of
     code here or there is much cleaner than introducing a large number
     of small hooks.

     Another way to generalize GDB along a particular interface is with
     an attribute struct.  For example, GDB has been generalized to
     handle multiple kinds of remote interfaces - not by #ifdef's
     everywhere, but by defining the "target_ops" structure and having
     a current target (as well as a stack of targets below it, for
     memory references).  Whenever something needs to be done that
     depends on which remote interface we are using, a flag in the
     current target_ops structure is tested (e.g.  `target_has_stack'),
     or a function is called through a pointer in the current
     target_ops structure.  In this way, when a new remote interface is
     added, only one module needs to be touched - the one that actually
     implements the new remote interface.  Other examples of
     attribute-structs are BFD access to multiple kinds of object file
     formats, or GDB's access to multiple source languages.

     Please avoid duplicating code.  For example, in GDB 3.x all the
     code interfacing between `ptrace' and the rest of GDB was
     duplicated in `*-dep.c', and so changing something was very
     painful.  In GDB 4.x, these have all been consolidated into
     `infptrace.c'.  `infptrace.c' can deal with variations between
     systems the same way any system-independent file would (hooks, #if
     defined, etc.), and machines which are radically different don't
     need to use infptrace.c at all.

*
     *Do* write code that doesn't depend on the sizes of C data types,
     the format of the host's floating point numbers, the alignment of
     anything, or the order of evaluation of expressions.  In short,
     follow good programming practices for writing portable C code.


File: gdbint.info,  Node: Submitting Patches,  Next: Host Conditionals,  Prev: Clean Design,  Up: Top

Submitting Patches
******************

   Thanks for thinking of offering your changes back to the community of
GDB users.  In general we like to get well designed enhancements.
Thanks also for checking in advance about the best way to transfer the
changes.

   The two main problems with getting your patches in are,

*
     The GDB maintainers will only install "cleanly designed" patches.
     You may not always agree on what is clean design.  *note Coding
     Style::., *note Clean Design::..

*
     If the maintainers don't have time to put the patch in when it
     arrives, or if there is any question about a patch, it goes into a
     large queue with everyone else's patches and bug reports.

   I don't know how to get past these problems except by continuing to
try.

   There are two issues here - technical and legal.

   The legal issue is that to incorporate substantial changes requires a
copyright assignment from you and/or your employer, granting ownership
of the changes to the Free Software Foundation.  You can get the
standard document for doing this by sending mail to
`gnu@prep.ai.mit.edu' and asking for it.  I recommend that people write
in "All programs owned by the Free Software Foundation" as "NAME OF
PROGRAM", so that changes in many programs (not just GDB, but GAS,
Emacs, GCC, etc) can be contributed with only one piece of legalese
pushed through the bureacracy and filed with the FSF.  I can't start
merging changes until this paperwork is received by the FSF (their
rules, which I follow since I maintain it for them).

   Technically, the easiest way to receive changes is to receive each
feature as a small context diff or unidiff, suitable for "patch".  Each
message sent to me should include the changes to C code and header
files for a single feature, plus ChangeLog entries for each directory
where files were modified, and diffs for any changes needed to the
manuals (gdb/doc/gdb.texi or gdb/doc/gdbint.texi).  If there are a lot
of changes for a single feature, they can be split down into multiple
messages.

   In this way, if I read and like the feature, I can add it to the
sources with a single patch command, do some testing, and check it in.
If you leave out the ChangeLog, I have to write one.  If you leave out
the doc, I have to puzzle out what needs documenting.  Etc.

   The reason to send each change in a separate message is that I will
not install some of the changes.  They'll be returned to you with
questions or comments.  If I'm doing my job, my message back to you
will say what you have to fix in order to make the change acceptable.
The reason to have separate messages for separate features is so that
other changes (which I *am* willing to accept) can be installed while
one or more changes are being reworked.  If multiple features are sent
in a single message, I tend to not put in the effort to sort out the
acceptable changes from the unacceptable, so none of the features get
installed until all are acceptable.

   If this sounds painful or authoritarian, well, it is.  But I get a
lot of bug reports and a lot of patches, and most of them don't get
installed because I don't have the time to finish the job that the bug
reporter or the contributor could have done.  Patches that arrive
complete, working, and well designed, tend to get installed on the day
they arrive.  The others go into a queue and get installed if and when
I scan back over the queue - which can literally take months sometimes.
It's in both our interests to make patch installation easy - you get
your changes installed, and I make some forward progress on GDB in a
normal 12-hour day (instead of them having to wait until I have a
14-hour or 16-hour day to spend cleaning up patches before I can
install them).

   Please send patches to `bug-gdb@prep.ai.mit.edu', if they are less
than about 25,000 characters.  If longer than that, either make them
available somehow (e.g. anonymous FTP), and announce it on `bug-gdb',
or send them directly to the GDB maintainers at
`gdb-patches@cygnus.com'.


File: gdbint.info,  Node: Host Conditionals,  Next: Target Conditionals,  Prev: Submitting Patches,  Up: Top

Host Conditionals
*****************

   When GDB is configured and compiled, various macros are defined or
left undefined, to control compilation based on the attributes of the
host system.  These macros and their meanings are:

   *NOTE:  For now, both host and target conditionals are here.
Eliminate target conditionals from this list as they are identified.*

`BLOCK_ADDRESS_FUNCTION_RELATIVE'
     dbxread.c

`GDBINIT_FILENAME'
     The default name of GDB's initialization file (normally
     `.gdbinit').

`KERNELDEBUG'
     tm-hppa.h

`MEM_FNS_DECLARED'
     Your host config file defines this if it includes declarations of
     `memcpy' and `memset'.  Define this to avoid conflicts between the
     native include files and the declarations in `defs.h'.

`NO_SYS_FILE'
     dbxread.c

`PYRAMID_CONTROL_FRAME_DEBUGGING'
     pyr-xdep.c

`SIGWINCH_HANDLER_BODY'
     utils.c

`ADDITIONAL_OPTIONS'
     main.c

`ADDITIONAL_OPTION_CASES'
     main.c

`ADDITIONAL_OPTION_HANDLER'
     main.c

`ADDITIONAL_OPTION_HELP'
     main.c

`ADDR_BITS_REMOVE'
     defs.h

`AIX_BUGGY_PTRACE_CONTINUE'
     infptrace.c

`ALIGN_STACK_ON_STARTUP'
     main.c

`ALTOS'
     altos-xdep.c

`ALTOS_AS'
     xm-altos.h

`ASCII_COFF'
     remote-adapt.c

`BADMAG'
     coffread.c

`BCS'
     tm-delta88.h

`BEFORE_MAIN_LOOP_HOOK'
     main.c

`BELIEVE_PCC_PROMOTION'
     coffread.c

`BELIEVE_PCC_PROMOTION_TYPE'
     stabsread.c

`BITS_BIG_ENDIAN'
     defs.h

`BKPT_AT_MAIN'
     solib.c

`BLOCK_ADDRESS_ABSOLUTE'
     dbxread.c

`BPT_VECTOR'
     tm-m68k.h

`BREAKPOINT'
     tm-m68k.h

`BREAKPOINT_DEBUG'
     breakpoint.c

`BROKEN_LARGE_ALLOCA'
     Avoid large `alloca''s.  For example, on sun's, Large alloca's fail
     because the attempt to increase the stack limit in main() fails
     because shared libraries are allocated just below the initial
     stack limit.  The SunOS kernel will not allow the stack to grow
     into the area occupied by the shared libraries.

`BSTRING'
     regex.c

`CALL_DUMMY'
     valops.c

`CALL_DUMMY_LOCATION'
     inferior.h

`CALL_DUMMY_STACK_ADJUST'
     valops.c

`CANNOT_FETCH_REGISTER'
     hppabsd-xdep.c

`CANNOT_STORE_REGISTER'
     findvar.c

`CFRONT_PRODUCER'
     dwarfread.c

`CHILD_PREPARE_TO_STORE'
     inftarg.c

`CLEAR_DEFERRED_STORES'
     inflow.c

`CLEAR_SOLIB'
     objfiles.c

`COFF_ENCAPSULATE'
     hppabsd-tdep.c

`COFF_FORMAT'
     symm-tdep.c

`CORE_NEEDS_RELOCATION'
     stack.c

`CPLUS_MARKER'
     cplus-dem.c

`CREATE_INFERIOR_HOOK'
     infrun.c

`C_ALLOCA'
     regex.c

`C_GLBLREG'
     coffread.c

`DBXREAD_ONLY'
     partial-stab.h

`DBX_PARM_SYMBOL_CLASS'
     stabsread.c

`DEBUG'
     remote-adapt.c

`DEBUG_INFO'
     partial-stab.h

`DEBUG_PTRACE'
     hppabsd-xdep.c

`DECR_PC_AFTER_BREAK'
     breakpoint.c

`DEFAULT_PROMPT'
     The default value of the prompt string (normally `"(gdb) "').

`DELTA88'
     m88k-xdep.c

`DEV_TTY'
     symmisc.c

`DGUX'
     m88k-xdep.c

`DISABLE_UNSETTABLE_BREAK'
     breakpoint.c

`DONT_USE_REMOTE'
     remote.c

`DO_DEFERRED_STORES'
     infrun.c

`DO_REGISTERS_INFO'
     infcmd.c

`EXTRACT_RETURN_VALUE'
     tm-m68k.h

`EXTRACT_STRUCT_VALUE_ADDRESS'
     values.c

`EXTRA_FRAME_INFO'
     frame.h

`EXTRA_SYMTAB_INFO'
     symtab.h

`FILES_INFO_HOOK'
     target.c

`FLOAT_INFO'
     infcmd.c

`FOPEN_RB'
     defs.h

`FRAMELESS_FUNCTION_INVOCATION'
     blockframe.c

`FRAME_ARGS_ADDRESS_CORRECT'
     stack.c

`FRAME_CHAIN_COMBINE'
     blockframe.c

`FRAME_CHAIN_VALID'
     frame.h

`FRAME_CHAIN_VALID_ALTERNATE'
     frame.h

`FRAME_FIND_SAVED_REGS'
     stack.c

`FRAME_GET_BASEREG_VALUE'
     frame.h

`FRAME_NUM_ARGS'
     tm-m68k.h

`FRAME_SPECIFICATION_DYADIC'
     stack.c

`FUNCTION_EPILOGUE_SIZE'
     coffread.c

`F_OK'
     xm-ultra3.h

`GCC2_COMPILED_FLAG_SYMBOL'
     dbxread.c

`GCC_COMPILED_FLAG_SYMBOL'
     dbxread.c

`GCC_MANGLE_BUG'
     symtab.c

`GCC_PRODUCER'
     dwarfread.c

`GET_SAVED_REGISTER'
     findvar.c

`GPLUS_PRODUCER'
     dwarfread.c

`HANDLE_RBRAC'
     partial-stab.h

`HAVE_MMAP'
     In some cases, use the system call `mmap' for reading symbol
     tables.  For some machines this allows for sharing and quick
     updates.

`HAVE_REGISTER_WINDOWS'
     findvar.c

`HAVE_SIGSETMASK'
     main.c

`HAVE_TERMIO'
     inflow.c

`HEADER_SEEK_FD'
     arm-tdep.c

`HOSTING_ONLY'
     xm-rtbsd.h

`HOST_BYTE_ORDER'
     ieee-float.c

`HPUX_ASM'
     xm-hp300hpux.h

`HPUX_VERSION_5'
     hp300ux-xdep.c

`HP_OS_BUG'
     infrun.c

`I80960'
     remote-vx.c

`IEEE_DEBUG'
     ieee-float.c

`IEEE_FLOAT'
     valprint.c

`IGNORE_SYMBOL'
     dbxread.c

`INIT_EXTRA_FRAME_INFO'
     blockframe.c

`INIT_EXTRA_SYMTAB_INFO'
     symfile.c

`INIT_FRAME_PC'
     blockframe.c

`INNER_THAN'
     valops.c

`INT_MAX'
     defs.h

`INT_MIN'
     defs.h

`IN_GDB'
     i960-pinsn.c

`IN_SIGTRAMP'
     infrun.c

`IN_SOLIB_TRAMPOLINE'
     infrun.c

`ISATTY'
     main.c

`IS_TRAPPED_INTERNALVAR'
     values.c

`KERNELDEBUG'
     dbxread.c

`KERNEL_DEBUGGING'
     tm-ultra3.h

`KERNEL_U_ADDR'
     Define this to the address of the `u' structure (the "user struct",
     also known as the "u-page") in kernel virtual memory.  GDB needs
     to know this so that it can subtract this address from absolute
     addresses in the upage, that are obtained via ptrace or from core
     files.  On systems that don't need this value, set it to zero.

`KERNEL_U_ADDR_BSD'
     Define this to cause GDB to determine the address of `u' at
     runtime, by using Berkeley-style `nlist' on the kernel's image in
     the root directory.

`KERNEL_U_ADDR_HPUX'
     Define this to cause GDB to determine the address of `u' at
     runtime, by using HP-style `nlist' on the kernel's image in the
     root directory.

`LCC_PRODUCER'
     dwarfread.c

`LOG_FILE'
     remote-adapt.c

`LONGERNAMES'
     cplus-dem.c

`LONGEST'
     defs.h

`CC_HAS_LONG_LONG'
     defs.h

`PRINTF_HAS_LONG_LONG'
     defs.h

`LONG_MAX'
     defs.h

`LSEEK_NOT_LINEAR'
     source.c

`L_LNNO32'
     coffread.c

`L_SET'
     This macro is used as the argument to lseek (or, most commonly,
     bfd_seek).  FIXME, it should be replaced by SEEK_SET instead,
     which is the POSIX equivalent.

`MACHKERNELDEBUG'
     hppabsd-tdep.c

`MAINTENANCE'
     dwarfread.c

`MAINTENANCE_CMDS'
     If the value of this is 1, then a number of optional maintenance
     commands are compiled in.

`MALLOC_INCOMPATIBLE'
     Define this if the system's prototype for `malloc' differs from the
     ANSI definition.

`MIPSEL'
     mips-tdep.c

`MMAP_BASE_ADDRESS'
     When using HAVE_MMAP, the first mapping should go at this address.

`MMAP_INCREMENT'
     when using HAVE_MMAP, this is the increment between mappings.

`MONO'
     ser-go32.c

`MOTOROLA'
     xm-altos.h

`NBPG'
     altos-xdep.c

`NEED_POSIX_SETPGID'
     infrun.c

`NEED_TEXT_START_END'
     exec.c

`NFAILURES'
     regex.c

`NORETURN'
     (in defs.h - is this really useful to define/undefine?)

`NOTDEF'
     regex.c

`NOTDEF'
     remote-adapt.c

`NOTDEF'
     remote-mm.c

`NOTICE_SIGNAL_HANDLING_CHANGE'
     infrun.c

`NO_HIF_SUPPORT'
     remote-mm.c

`NO_JOB_CONTROL'
     signals.h

`NO_MMALLOC'
     GDB will use the `mmalloc' library for memory allocation for symbol
     reading, unless this symbol is defined.  Define it on systems on
     which `mmalloc' does not work for some reason.  One example is the
     DECstation, where its RPC library can't cope with our redefinition
     of `malloc' to call `mmalloc'.  When defining `NO_MMALLOC', you
     will also have to override the setting of `MMALLOC_LIB' to empty,
     in the Makefile.  Therefore, this define is usually set on the
     command line by overriding `MMALLOC_DISABLE' in `config/*/*.mh',
     rather than by defining it in `xm-*.h'.

`NO_MMALLOC_CHECK'
     Define this if you are using `mmalloc', but don't want the overhead
     of checking the heap with `mmcheck'.

`NO_SIGINTERRUPT'
     remote-adapt.c

`NO_SINGLE_STEP'
     infptrace.c

`NS32K_SVC_IMMED_OPERANDS'
     ns32k-opcode.h

`NUMERIC_REG_NAMES'
     mips-tdep.c

`N_SETV'
     dbxread.c

`N_SET_MAGIC'
     hppabsd-tdep.c

`NaN'
     tm-umax.h

`ONE_PROCESS_WRITETEXT'
     breakpoint.c

`O_BINARY'
     exec.c

`O_RDONLY'
     xm-ultra3.h

`PC'
     convx-opcode.h

`PCC_SOL_BROKEN'
     dbxread.c

`PC_IN_CALL_DUMMY'
     inferior.h

`PC_LOAD_SEGMENT'
     stack.c

`PRINT_RANDOM_SIGNAL'
     infcmd.c

`PRINT_REGISTER_HOOK'
     infcmd.c

`PRINT_TYPELESS_INTEGER'
     valprint.c

`PROCESS_LINENUMBER_HOOK'
     buildsym.c

`PROLOGUE_FIRSTLINE_OVERLAP'
     infrun.c

`PSIGNAL_IN_SIGNAL_H'
     defs.h

`PUSH_ARGUMENTS'
     valops.c

`PYRAMID_CONTROL_FRAME_DEBUGGING'
     pyr-xdep.c

`PYRAMID_CORE'
     pyr-xdep.c

`PYRAMID_PTRACE'
     pyr-xdep.c

`REGISTER_BYTES'
     remote.c

`REGISTER_NAMES'
     tm-a29k.h

`REG_STACK_SEGMENT'
     exec.c

`REG_STRUCT_HAS_ADDR'
     findvar.c

`RE_NREGS'
     regex.h

`R_FP'
     dwarfread.c

`R_OK'
     xm-altos.h

`SEEK_END'
     state.c

`SEEK_SET'
     state.c

`SEM'
     coffread.c

`SET_STACK_LIMIT_HUGE'
     When defined, stack limits will be raised to their maximum.  Use
     this if your host supports `setrlimit' and you have trouble with
     `stringtab' in `dbxread.c'.

     Also used in `fork-child.c' to return stack limits before child
     processes are forked.

`SHELL_COMMAND_CONCAT'
     infrun.c

`SHELL_FILE'
     infrun.c

`SHIFT_INST_REGS'
     breakpoint.c

`SIGN_EXTEND_CHAR'
     regex.c

`SIGTRAP_STOP_AFTER_LOAD'
     infrun.c

`SKIP_PROLOGUE'
     tm-m68k.h

`SKIP_PROLOGUE_FRAMELESS_P'
     blockframe.c

`SKIP_TRAMPOLINE_CODE'
     infrun.c

`SOLIB_ADD'
     core.c

`SOLIB_CREATE_INFERIOR_HOOK'
     infrun.c

`STACK_ALIGN'
     valops.c

`START_INFERIOR_TRAPS_EXPECTED'
     infrun.c

`STOP_SIGNAL'
     main.c

`STORE_RETURN_VALUE'
     tm-m68k.h

`SUN4_COMPILER_FEATURE'
     infrun.c

`SUN_FIXED_LBRAC_BUG'
     dbxread.c

`SVR4_SHARED_LIBS'
     solib.c

`SWITCH_ENUM_BUG'
     regex.c

`SYM1'
     tm-ultra3.h

`SYMBOL_RELOADING_DEFAULT'
     symfile.c

`SYNTAX_TABLE'
     regex.c

`Sword'
     regex.c

`TDESC'
     infrun.c

`TIOCGETC'
     inflow.c

`TIOCGLTC'
     inflow.c

`TIOCGPGRP'
     inflow.c

`TIOCLGET'
     inflow.c

`TIOCLSET'
     inflow.c

`TIOCNOTTY'
     inflow.c

`T_ARG'
     coffread.c

`T_VOID'
     coffread.c

`UINT_MAX'
     defs.h

`UPAGES'
     altos-xdep.c

`USER'
     m88k-tdep.c

`USE_GAS'
     xm-news.h

`USE_O_NOCTTY'
     inflow.c

`USE_STRUCT_CONVENTION'
     values.c

`USG'
     Means that System V (prior to SVR4) include files are in use.
     (FIXME:  This symbol is abused in `infrun.c', `regex.c',
     `remote-nindy.c', and `utils.c' for other things, at the moment.)

`USIZE'
     xm-m88k.h

`U_FPSTATE'
     i386-xdep.c

`VARIABLES_INSIDE_BLOCK'
     dbxread.c

`WRS_ORIG'
     remote-vx.c

`_LANG_c'
     language.c

`_LANG_m2'
     language.c

`__GNUC__'
     news-xdep.c

`__GO32__'
     inflow.c

`__HPUX_ASM__'
     xm-hp300hpux.h

`__INT_VARARGS_H'
     printcmd.c

`__not_on_pyr_yet'
     pyr-xdep.c

`alloca'
     defs.h

`const'
     defs.h

`GOULD_PN'
     gould-pinsn.c

`hp800'
     xm-hppabsd.h

`hpux'
     hppabsd-core.c

`lint'
     valarith.c

`longest_to_int'
     defs.h

`mc68020'
     m68k-stub.c

`notdef'
     gould-pinsn.c

`ns32k_opcodeT'
     ns32k-opcode.h

`sgi'
     mips-tdep.c

`sparc'
     regex.c

`sun'
     m68k-tdep.c

`sun386'
     tm-sun386.h

`test'
     regex.c

`ultrix'
     xm-mips.h

`volatile'
     defs.h


File: gdbint.info,  Node: Target Conditionals,  Next: Native Conditionals,  Prev: Host Conditionals,  Up: Top

Target Conditionals
*******************

   When GDB is configured and compiled, various macros are defined or
left undefined, to control compilation based on the attributes of the
target system.  These macros and their meanings are:

   *NOTE:  For now, both host and target conditionals are here.
Eliminate host conditionals from this list as they are identified.*

`PUSH_DUMMY_FRAME'
     Used in `call_function_by_hand' to create an artificial stack
     frame.

`POP_FRAME'
     Used in `call_function_by_hand' to remove an artificial stack
     frame.

`BLOCK_ADDRESS_FUNCTION_RELATIVE'
     dbxread.c

`KERNELDEBUG'
     tm-hppa.h

`NO_SYS_FILE'
     dbxread.c

`PYRAMID_CONTROL_FRAME_DEBUGGING'
     pyr-xdep.c

`SIGWINCH_HANDLER_BODY'
     utils.c

`ADDITIONAL_OPTIONS'
     main.c

`ADDITIONAL_OPTION_CASES'
     main.c

`ADDITIONAL_OPTION_HANDLER'
     main.c

`ADDITIONAL_OPTION_HELP'
     main.c

`ADDR_BITS_REMOVE'
     defs.h

`ALIGN_STACK_ON_STARTUP'
     main.c

`ALTOS'
     altos-xdep.c

`ALTOS_AS'
     xm-altos.h

`ASCII_COFF'
     remote-adapt.c

`BADMAG'
     coffread.c

`BCS'
     tm-delta88.h

`BEFORE_MAIN_LOOP_HOOK'
     main.c

`BELIEVE_PCC_PROMOTION'
     coffread.c

`BELIEVE_PCC_PROMOTION_TYPE'
     stabsread.c

`BITS_BIG_ENDIAN'
     defs.h

`BKPT_AT_MAIN'
     solib.c

`BLOCK_ADDRESS_ABSOLUTE'
     dbxread.c

`BPT_VECTOR'
     tm-m68k.h

`BREAKPOINT'
     tm-m68k.h

`BREAKPOINT_DEBUG'
     breakpoint.c

`BSTRING'
     regex.c

`CALL_DUMMY'
     valops.c

`CALL_DUMMY_LOCATION'
     inferior.h

`CALL_DUMMY_STACK_ADJUST'
     valops.c

`CANNOT_FETCH_REGISTER'
     hppabsd-xdep.c

`CANNOT_STORE_REGISTER'
     findvar.c

`CFRONT_PRODUCER'
     dwarfread.c

`CHILD_PREPARE_TO_STORE'
     inftarg.c

`CLEAR_DEFERRED_STORES'
     inflow.c

`CLEAR_SOLIB'
     objfiles.c

`COFF_ENCAPSULATE'
     hppabsd-tdep.c

`COFF_FORMAT'
     symm-tdep.c

`CORE_NEEDS_RELOCATION'
     stack.c

`CPLUS_MARKER'
     cplus-dem.c

`CREATE_INFERIOR_HOOK'
     infrun.c

`C_ALLOCA'
     regex.c

`C_GLBLREG'
     coffread.c

`DBXREAD_ONLY'
     partial-stab.h

`DBX_PARM_SYMBOL_CLASS'
     stabsread.c

`DEBUG'
     remote-adapt.c

`DEBUG_INFO'
     partial-stab.h

`DEBUG_PTRACE'
     hppabsd-xdep.c

`DECR_PC_AFTER_BREAK'
     breakpoint.c

`DELTA88'
     m88k-xdep.c

`DEV_TTY'
     symmisc.c

`DGUX'
     m88k-xdep.c

`DISABLE_UNSETTABLE_BREAK'
     breakpoint.c

`DONT_USE_REMOTE'
     remote.c

`DO_DEFERRED_STORES'
     infrun.c

`DO_REGISTERS_INFO'
     infcmd.c

`END_OF_TEXT_DEFAULT'
     This is an expression that should designate the end of the text
     section (? FIXME ?)

`EXTRACT_RETURN_VALUE'
     tm-m68k.h

`EXTRACT_STRUCT_VALUE_ADDRESS'
     values.c

`EXTRA_FRAME_INFO'
     frame.h

`EXTRA_SYMTAB_INFO'
     symtab.h

`FILES_INFO_HOOK'
     target.c

`FLOAT_INFO'
     infcmd.c

`FOPEN_RB'
     defs.h

`FP0_REGNUM'
     a68v-xdep.c

`FPC_REGNUM'
     mach386-xdep.c

`FP_REGNUM'
     parse.c

`FPU'
     Unused?  6-oct-92 rich@cygnus.com.  FIXME.

`FRAMELESS_FUNCTION_INVOCATION'
     blockframe.c

`FRAME_ARGS_ADDRESS_CORRECT'
     stack.c

`FRAME_CHAIN'
     Given FRAME, return a pointer to the calling frame.

`FRAME_CHAIN_COMBINE'
     blockframe.c

`FRAME_CHAIN_VALID'
     frame.h

`FRAME_CHAIN_VALID_ALTERNATE'
     frame.h

`FRAME_FIND_SAVED_REGS'
     stack.c

`FRAME_GET_BASEREG_VALUE'
     frame.h

`FRAME_NUM_ARGS'
     tm-m68k.h

`FRAME_SPECIFICATION_DYADIC'
     stack.c

`FRAME_SAVED_PC'
     Given FRAME, return the pc saved there.  That is, the return
     address.

`FUNCTION_EPILOGUE_SIZE'
     coffread.c

`F_OK'
     xm-ultra3.h

`GCC2_COMPILED_FLAG_SYMBOL'
     dbxread.c

`GCC_COMPILED_FLAG_SYMBOL'
     dbxread.c

`GCC_MANGLE_BUG'
     symtab.c

`GCC_PRODUCER'
     dwarfread.c

`GDB_TARGET_IS_HPPA'
     This determines whether horrible kludge code in dbxread.c and
     partial-stab.h is used to mangle multiple-symbol-table files from
     HPPA's.  This should all be ripped out, and a scheme like
     elfread.c used.

`GDB_TARGET_IS_MACH386'
     mach386-xdep.c

`GDB_TARGET_IS_SUN3'
     a68v-xdep.c

`GDB_TARGET_IS_SUN386'
     sun386-xdep.c

`GET_LONGJMP_TARGET'
     For most machines, this is a target-dependent parameter.  On the
     DECstation and the Iris, this is a native-dependent parameter,
     since <setjmp.h> is needed to define it.

     This macro determines the target PC address that longjmp() will
     jump to, assuming that we have just stopped at a longjmp
     breakpoint.  It takes a CORE_ADDR * as argument, and stores the
     target PC value through this pointer.  It examines the current
     state of the machine as needed.

`GET_SAVED_REGISTER'
     findvar.c

`GPLUS_PRODUCER'
     dwarfread.c

`GR64_REGNUM'
     remote-adapt.c

`GR64_REGNUM'
     remote-mm.c

`HANDLE_RBRAC'
     partial-stab.h

`HAVE_68881'
     m68k-tdep.c

`HAVE_REGISTER_WINDOWS'
     findvar.c

`HAVE_SIGSETMASK'
     main.c

`HAVE_TERMIO'
     inflow.c

`HEADER_SEEK_FD'
     arm-tdep.c

`HOSTING_ONLY'
     xm-rtbsd.h

`HOST_BYTE_ORDER'
     ieee-float.c

`HPUX_ASM'
     xm-hp300hpux.h

`HPUX_VERSION_5'
     hp300ux-xdep.c

`HP_OS_BUG'
     infrun.c

`I80960'
     remote-vx.c

`IBM6000_TARGET'
     Shows that we are configured for an IBM RS/6000 target.  This
     conditional should be eliminated (FIXME) and replaced by
     feature-specific macros.  It was introduced in haste and we are
     repenting at leisure.

`IEEE_DEBUG'
     ieee-float.c

`IEEE_FLOAT'
     valprint.c

`IGNORE_SYMBOL'
     dbxread.c

`INIT_EXTRA_FRAME_INFO'
     blockframe.c

`INIT_EXTRA_SYMTAB_INFO'
     symfile.c

`INIT_FRAME_PC'
     blockframe.c

`INNER_THAN'
     valops.c

`INT_MAX'
     defs.h

`INT_MIN'
     defs.h

`IN_GDB'
     i960-pinsn.c

`IN_SIGTRAMP'
     infrun.c

`IN_SOLIB_TRAMPOLINE'
     infrun.c

`ISATTY'
     main.c

`IS_TRAPPED_INTERNALVAR'
     values.c

`KERNELDEBUG'
     dbxread.c

`KERNEL_DEBUGGING'
     tm-ultra3.h

`LCC_PRODUCER'
     dwarfread.c

`LOG_FILE'
     remote-adapt.c

`LONGERNAMES'
     cplus-dem.c

`LONGEST'
     defs.h

`CC_HAS_LONG_LONG'
     defs.h

`PRINTF_HAS_LONG_LONG'
     defs.h

`LONG_MAX'
     defs.h

`L_LNNO32'
     coffread.c

`MACHKERNELDEBUG'
     hppabsd-tdep.c

`MAINTENANCE'
     dwarfread.c

`MIPSEL'
     mips-tdep.c

`MOTOROLA'
     xm-altos.h

`NBPG'
     altos-xdep.c

`NEED_POSIX_SETPGID'
     infrun.c

`NEED_TEXT_START_END'
     exec.c

`NFAILURES'
     regex.c

`NNPC_REGNUM'
     infrun.c

`NOTDEF'
     regex.c

`NOTDEF'
     remote-adapt.c

`NOTDEF'
     remote-mm.c

`NOTICE_SIGNAL_HANDLING_CHANGE'
     infrun.c

`NO_HIF_SUPPORT'
     remote-mm.c

`NO_SIGINTERRUPT'
     remote-adapt.c

`NO_SINGLE_STEP'
     infptrace.c

`NPC_REGNUM'
     infcmd.c

`NS32K_SVC_IMMED_OPERANDS'
     ns32k-opcode.h

`NUMERIC_REG_NAMES'
     mips-tdep.c

`N_SETV'
     dbxread.c

`N_SET_MAGIC'
     hppabsd-tdep.c

`NaN'
     tm-umax.h

`ONE_PROCESS_WRITETEXT'
     breakpoint.c

`PC'
     convx-opcode.h

`PCC_SOL_BROKEN'
     dbxread.c

`PC_IN_CALL_DUMMY'
     inferior.h

`PC_LOAD_SEGMENT'
     stack.c

`PC_REGNUM'
     parse.c

`PRINT_RANDOM_SIGNAL'
     infcmd.c

`PRINT_REGISTER_HOOK'
     infcmd.c

`PRINT_TYPELESS_INTEGER'
     valprint.c

`PROCESS_LINENUMBER_HOOK'
     buildsym.c

`PROLOGUE_FIRSTLINE_OVERLAP'
     infrun.c

`PSIGNAL_IN_SIGNAL_H'
     defs.h

`PS_REGNUM'
     parse.c

`PUSH_ARGUMENTS'
     valops.c

`REGISTER_BYTES'
     remote.c

`REGISTER_NAMES'
     tm-a29k.h

`REG_STACK_SEGMENT'
     exec.c

`REG_STRUCT_HAS_ADDR'
     findvar.c

`RE_NREGS'
     regex.h

`R_FP'
     dwarfread.c

`R_OK'
     xm-altos.h

`SDB_REG_TO_REGNUM'
     Define this to convert sdb register numbers into gdb regnums.  If
     not defined, no conversion will be done.

`SEEK_END'
     state.c

`SEEK_SET'
     state.c

`SEM'
     coffread.c

`SHELL_COMMAND_CONCAT'
     infrun.c

`SHELL_FILE'
     infrun.c

`SHIFT_INST_REGS'
     breakpoint.c

`SIGN_EXTEND_CHAR'
     regex.c

`SIGTRAP_STOP_AFTER_LOAD'
     infrun.c

`SKIP_PROLOGUE'
     tm-m68k.h

`SKIP_PROLOGUE_FRAMELESS_P'
     blockframe.c

`SKIP_TRAMPOLINE_CODE'
     infrun.c

`SOLIB_ADD'
     core.c

`SOLIB_CREATE_INFERIOR_HOOK'
     infrun.c

`SP_REGNUM'
     parse.c

`STAB_REG_TO_REGNUM'
     Define this to convert stab register numbers (as gotten from `r'
     declarations) into gdb regnums.  If not defined, no conversion
     will be done.

`STACK_ALIGN'
     valops.c

`START_INFERIOR_TRAPS_EXPECTED'
     infrun.c

`STOP_SIGNAL'
     main.c

`STORE_RETURN_VALUE'
     tm-m68k.h

`SUN4_COMPILER_FEATURE'
     infrun.c

`SUN_FIXED_LBRAC_BUG'
     dbxread.c

`SVR4_SHARED_LIBS'
     solib.c

`SWITCH_ENUM_BUG'
     regex.c

`SYM1'
     tm-ultra3.h

`SYMBOL_RELOADING_DEFAULT'
     symfile.c

`SYNTAX_TABLE'
     regex.c

`Sword'
     regex.c

`TARGET_BYTE_ORDER'
     defs.h

`TARGET_CHAR_BIT'
     defs.h

`TARGET_COMPLEX_BIT'
     defs.h

`TARGET_DOUBLE_BIT'
     defs.h

`TARGET_DOUBLE_COMPLEX_BIT'
     defs.h

`TARGET_FLOAT_BIT'
     defs.h

`TARGET_INT_BIT'
     defs.h

`TARGET_LONG_BIT'
     defs.h

`TARGET_LONG_DOUBLE_BIT'
     defs.h

`TARGET_LONG_LONG_BIT'
     defs.h

`TARGET_PTR_BIT'
     defs.h

`TARGET_READ_PC'
`TARGET_WRITE_PC'
`TARGET_READ_SP'
`TARGET_WRITE_SP'
`TARGET_READ_FP'
`TARGET_WRITE_FP'
     These change the behavior of `read_pc', `write_pc', `read_sp',
     `write_sp', `read_fp' and `write_fp'.  For most targets, these may
     be left undefined.  GDB will call the read and write register
     functions with the relevant `_REGNUM' argument.

     These macros are useful when a target keeps one of these registers
     in a hard to get at place;  for example, part in a segment
     register and part in an ordinary register.

`TARGET_SHORT_BIT'
     defs.h

`TDESC'
     infrun.c

`T_ARG'
     coffread.c

`T_VOID'
     coffread.c

`UINT_MAX'
     defs.h

`USER'
     m88k-tdep.c

`USE_GAS'
     xm-news.h

`USE_STRUCT_CONVENTION'
     values.c

`USIZE'
     xm-m88k.h

`U_FPSTATE'
     i386-xdep.c

`VARIABLES_INSIDE_BLOCK'
     dbxread.c

`WRS_ORIG'
     remote-vx.c

`_LANG_c'
     language.c

`_LANG_m2'
     language.c

`__GO32__'
     inflow.c

`__HPUX_ASM__'
     xm-hp300hpux.h

`__INT_VARARGS_H'
     printcmd.c

`__not_on_pyr_yet'
     pyr-xdep.c

`GOULD_PN'
     gould-pinsn.c

`hp800'
     xm-hppabsd.h

`hpux'
     hppabsd-core.c

`longest_to_int'
     defs.h

`mc68020'
     m68k-stub.c

`ns32k_opcodeT'
     ns32k-opcode.h

`sgi'
     mips-tdep.c

`sparc'
     regex.c

`sun'
     m68k-tdep.c

`sun386'
     tm-sun386.h

`test'
     (Define this to enable testing code in regex.c.)


File: gdbint.info,  Node: Native Conditionals,  Next: Obsolete Conditionals,  Prev: Target Conditionals,  Up: Top

Native Conditionals
*******************

   When GDB is configured and compiled, various macros are defined or
left undefined, to control compilation when the host and target systems
are the same.  These macros should be defined (or left undefined) in
`nm-SYSTEM.h'.

`ATTACH_DETACH'
     If defined, then gdb will include support for the `attach' and
     `detach' commands.

`FETCH_INFERIOR_REGISTERS'
     Define this if the native-dependent code will provide its own
     routines `fetch_inferior_registers' and `store_inferior_registers'
     in `HOST-nat.c'.  If this symbol is *not* defined, and
     `infptrace.c' is included in this configuration, the default
     routines in `infptrace.c' are used for these functions.

`GET_LONGJMP_TARGET'
     For most machines, this is a target-dependent parameter.  On the
     DECstation and the Iris, this is a native-dependent parameter,
     since <setjmp.h> is needed to define it.

     This macro determines the target PC address that longjmp() will
     jump to, assuming that we have just stopped at a longjmp
     breakpoint.  It takes a CORE_ADDR * as argument, and stores the
     target PC value through this pointer.  It examines the current
     state of the machine as needed.

`PROC_NAME_FMT'
     Defines the format for the name of a `/proc' device.  Should be
     defined in `nm.h' *only* in order to override the default
     definition in `procfs.c'.

`PTRACE_FP_BUG'
     mach386-xdep.c

`PTRACE_ARG3_TYPE'
     The type of the third argument to the `ptrace' system call, if it
     exists and is different from `int'.

`REGISTER_U_ADDR'
     Defines the offset of the registers in the "u area"; *note Host::..

`USE_PROC_FS'
     This determines whether small routines in `*-tdep.c', which
     translate register values between GDB's internal representation
     and the /proc representation, are compiled.

`U_REGS_OFFSET'
     This is the offset of the registers in the upage.  It need only be
     defined if the generic ptrace register access routines in
     `infptrace.c' are being used (that is, `infptrace.c' is configured
     in, and `FETCH_INFERIOR_REGISTERS' is not defined).  If the
     default value from `infptrace.c' is good enough, leave it
     undefined.

     The default value means that u.u_ar0 *points to* the location of
     the registers.  I'm guessing that `#define U_REGS_OFFSET 0' means
     that u.u_ar0 *is* the location of the registers.


File: gdbint.info,  Node: Obsolete Conditionals,  Next: XCOFF,  Prev: Native Conditionals,  Up: Top

Obsolete Conditionals
*********************

   Fragments of old code in GDB sometimes reference or set the following
configuration macros.  They should not be used by new code, and old
uses should be removed as those parts of the debugger are otherwise
touched.

`STACK_END_ADDR'
     This macro used to define where the end of the stack appeared, for
     use in interpreting core file formats that don't record this
     address in the core file itself.  This information is now
     configured in BFD, and GDB gets the info portably from there.  The
     values in GDB's configuration files should be moved into BFD
     configuration files (if needed there), and deleted from all of
     GDB's config files.

     Any `FOO-xdep.c' file that references STACK_END_ADDR is so old
     that it has never been converted to use BFD.  Now that's old!


File: gdbint.info,  Node: XCOFF,  Prev: Obsolete Conditionals,  Up: Top

The XCOFF Object File Format
****************************

   The IBM RS/6000 running AIX uses an object file format called xcoff.
The COFF sections, symbols, and line numbers are used, but debugging
symbols are dbx-style stabs whose strings are located in the `.debug'
section (rather than the string table).  For more information, *Note
Top: (stabs)Top, and search for XCOFF.

   The shared library scheme has a nice clean interface for figuring out
what shared libraries are in use, but the catch is that everything which
refers to addresses (symbol tables and breakpoints at least) needs to be
relocated for both shared libraries and the main executable.  At least
using the standard mechanism this can only be done once the program has
been run (or the core file has been read).


