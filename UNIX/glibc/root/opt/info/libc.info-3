This is Info file libc.info, produced by Makeinfo-1.55 from the input
file libc.texinfo.

   This file documents the GNU C library.

   This is Edition 0.05, last updated 30 August 1993, of `The GNU C
Library Reference Manual', for Version 1.07 Beta.

   Copyright (C) 1993 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU Library General Public License" is
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the text of the translations of the section
entitled "GNU Library General Public License" must be approved for
accuracy by the Foundation.


File: libc.info,  Node: Unconstrained Allocation,  Next: Obstacks,  Prev: Dynamic Allocation and C,  Up: Memory Allocation

Unconstrained Allocation
========================

   The most general dynamic allocation facility is `malloc'.  It allows
you to allocate blocks of memory of any size at any time, make them
bigger or smaller at any time, and free the blocks individually at any
time (or never).

* Menu:

* Basic Allocation::            Simple use of `malloc'.
* Malloc Examples::             Examples of `malloc'.  `xmalloc'.
* Freeing after Malloc::        Use `free' to free a block you
				 got with `malloc'.
* Changing Block Size::         Use `realloc' to make a block
				 bigger or smaller.
* Allocating Cleared Space::    Use `calloc' to allocate a
				 block and clear it.
* Efficiency and Malloc::       Efficiency considerations in use of
				 these functions.
* Aligned Memory Blocks::       Allocating specially aligned memory:
				 `memalign' and `valloc'.
* Heap Consistency Checking::   Automatic checking for errors.
* Hooks for Malloc::            You can use these hooks for debugging
				 programs that use `malloc'.
* Statistics of Malloc::        Getting information about how much
				 memory your program is using.
* Summary of Malloc::           Summary of `malloc' and related functions.


File: libc.info,  Node: Basic Allocation,  Next: Malloc Examples,  Up: Unconstrained Allocation

Basic Storage Allocation
------------------------

   To allocate a block of memory, call `malloc'.  The prototype for
this function is in `stdlib.h'.

 - Function: void * malloc (size_t SIZE)
     This function returns a pointer to a newly allocated block SIZE
     bytes long, or a null pointer if the block could not be allocated.

   The contents of the block are undefined; you must initialize it
yourself (or use `calloc' instead; *note Allocating Cleared Space::.).
Normally you would cast the value as a pointer to the kind of object
that you want to store in the block.  Here we show an example of doing
so, and of initializing the space with zeros using the library function
`memset' (*note Copying and Concatenation::.):

     struct foo *ptr;
     ...
     ptr = (struct foo *) malloc (sizeof (struct foo));
     if (ptr == 0) abort ();
     memset (ptr, 0, sizeof (struct foo));

   You can store the result of `malloc' into any pointer variable
without a cast, because ANSI C automatically converts the type `void *'
to another type of pointer when necessary.  But the cast is necessary
in contexts other than assignment operators or if you might want your
code to run in traditional C.

   Remember that when allocating space for a string, the argument to
`malloc' must be one plus the length of the string.  This is because a
string is terminated with a null character that doesn't count in the
"length" of the string but does need space.  For example:

     char *ptr;
     ...
     ptr = (char *) malloc (length + 1);

*Note Representation of Strings::, for more information about this.


File: libc.info,  Node: Malloc Examples,  Next: Freeing after Malloc,  Prev: Basic Allocation,  Up: Unconstrained Allocation

Examples of `malloc'
--------------------

   If no more space is available, `malloc' returns a null pointer.  You
should check the value of *every* call to `malloc'.  It is useful to
write a subroutine that calls `malloc' and reports an error if the
value is a null pointer, returning only if the value is nonzero.  This
function is conventionally called `xmalloc'.  Here it is:

     void *
     xmalloc (size_t size)
     {
       register void *value = malloc (size);
       if (value == 0)
         fatal ("virtual memory exhausted");
       return value;
     }

   Here is a real example of using `malloc' (by way of `xmalloc').  The
function `savestring' will copy a sequence of characters into a newly
allocated null-terminated string:

     char *
     savestring (const char *ptr, size_t len)
     {
       register char *value = (char *) xmalloc (len + 1);
       memcpy (value, ptr, len);
       value[len] = '\0';
       return value;
     }

   The block that `malloc' gives you is guaranteed to be aligned so
that it can hold any type of data.  In the GNU system, the address is
always a multiple of eight; if the size of block is 16 or more, then the
address is always a multiple of 16.  Only rarely is any higher boundary
(such as a page boundary) necessary; for those cases, use `memalign' or
`valloc' (*note Aligned Memory Blocks::.).

   Note that the memory located after the end of the block is likely to
be in use for something else; perhaps a block already allocated by
another call to `malloc'.  If you attempt to treat the block as longer
than you asked for it to be, you are liable to destroy the data that
`malloc' uses to keep track of its blocks, or you may destroy the
contents of another block.  If you have already allocated a block and
discover you want it to be bigger, use `realloc' (*note Changing Block
Size::.).


File: libc.info,  Node: Freeing after Malloc,  Next: Changing Block Size,  Prev: Malloc Examples,  Up: Unconstrained Allocation

Freeing Memory Allocated with `malloc'
--------------------------------------

   When you no longer need a block that you got with `malloc', use the
function `free' to make the block available to be allocated again.  The
prototype for this function is in `stdlib.h'.

 - Function: void free (void *PTR)
     The `free' function deallocates the block of storage pointed at by
     PTR.

 - Function: void cfree (void *PTR)
     This function does the same thing as `free'.  It's provided for
     backward compatibility with SunOS; you should use `free' instead.

   Freeing a block alters the contents of the block.  *Do not expect to
find any data (such as a pointer to the next block in a chain of
blocks) in the block after freeing it.*  Copy whatever you need out of
the block before freeing it!  Here is an example of the proper way to
free all the blocks in a chain, and the strings that they point to:

     struct chain
       {
         struct chain *next;
         char *name;
       }
     
     void
     free_chain (struct chain *chain)
     {
       while (chain != 0)
         {
           struct chain *next = chain->next;
           free (chain->name);
           free (chain);
           chain = next;
         }
     }

   Occasionally, `free' can actually return memory to the operating
system and make the process smaller.  Usually, all it can do is allow a
later call to `malloc' to reuse the space.  In the meantime, the space
remains in your program as part of a free-list used internally by
`malloc'.

   There is no point in freeing blocks at the end of a program, because
all of the program's space is given back to the system when the process
terminates.


File: libc.info,  Node: Changing Block Size,  Next: Allocating Cleared Space,  Prev: Freeing after Malloc,  Up: Unconstrained Allocation

Changing the Size of a Block
----------------------------

   Often you do not know for certain how big a block you will
ultimately need at the time you must begin to use the block.  For
example, the block might be a buffer that you use to hold a line being
read from a file; no matter how long you make the buffer initially, you
may encounter a line that is longer.

   You can make the block longer by calling `realloc'.  This function
is declared in `stdlib.h'.

 - Function: void * realloc (void *PTR, size_t NEWSIZE)
     The `realloc' function changes the size of the block whose address
     is PTR to be NEWSIZE.

     Since the space after the end of the block may be in use, `realloc'
     may find it necessary to copy the block to a new address where
     more free space is available.  The value of `realloc' is the new
     address of the block.  If the block needs to be moved, `realloc'
     copies the old contents.

     If you pass a null pointer for PTR, `realloc' behaves just like
     `malloc (NEWSIZE)'.  This can be convenient, but beware that older
     implementations (before ANSI C) may not support this behavior, and
     will probably crash when `realloc' is passed a null pointer.

   Like `malloc', `realloc' may return a null pointer if no memory
space is available to make the block bigger.  When this happens, the
original block is untouched; it has not been modified or relocated.

   In most cases it makes no difference what happens to the original
block when `realloc' fails, because the application program cannot
continue when it is out of memory, and the only thing to do is to give
a fatal error message.  Often it is convenient to write and use a
subroutine, conventionally called `xrealloc', that takes care of the
error message as `xmalloc' does for `malloc':

     void *
     xrealloc (void *ptr, size_t size)
     {
       register void *value = realloc (ptr, size);
       if (value == 0)
         fatal ("Virtual memory exhausted");
       return value;
     }

   You can also use `realloc' to make a block smaller.  The reason you
would do this is to avoid tying up a lot of memory space when only a
little is needed.  Making a block smaller sometimes necessitates
copying it, so it can fail if no other space is available.

   If the new size you specify is the same as the old size, `realloc'
is guaranteed to change nothing and return the same address that you
gave.


File: libc.info,  Node: Allocating Cleared Space,  Next: Efficiency and Malloc,  Prev: Changing Block Size,  Up: Unconstrained Allocation

Allocating Cleared Space
------------------------

   The function `calloc' allocates memory and clears it to zero.  It is
declared in `stdlib.h'.

 - Function: void * calloc (size_t COUNT, size_t ELTSIZE)
     This function allocates a block long enough to contain a vector of
     COUNT elements, each of size ELTSIZE.  Its contents are cleared to
     zero before `calloc' returns.

   You could define `calloc' as follows:

     void *
     calloc (size_t count, size_t eltsize)
     {
       size_t size = count * eltsize;
       void *value = malloc (size);
       if (value != 0)
         memset (value, 0, size);
       return value;
     }

   We rarely use `calloc' today, because it is equivalent to such a
simple combination of other features that are more often used.  It is a
historical holdover that is not quite obsolete.


File: libc.info,  Node: Efficiency and Malloc,  Next: Aligned Memory Blocks,  Prev: Allocating Cleared Space,  Up: Unconstrained Allocation

Efficiency Considerations for `malloc'
--------------------------------------

   To make the best use of `malloc', it helps to know that the GNU
version of `malloc' always dispenses small amounts of memory in blocks
whose sizes are powers of two.  It keeps separate pools for each power
of two.  This holds for sizes up to a page size.  Therefore, if you are
free to choose the size of a small block in order to make `malloc' more
efficient, make it a power of two.

   Once a page is split up for a particular block size, it can't be
reused for another size unless all the blocks in it are freed.  In many
programs, this is unlikely to happen.  Thus, you can sometimes make a
program use memory more efficiently by using blocks of the same size for
many different purposes.

   When you ask for memory blocks of a page or larger, `malloc' uses a
different strategy; it rounds the size up to a multiple of a page, and
it can coalesce and split blocks as needed.

   The reason for the two strategies is that it is important to allocate
and free small blocks as fast as possible, but speed is less important
for a large block since the program normally spends a fair amount of
time using it.  Also, large blocks are normally fewer in number.
Therefore, for large blocks, it makes sense to use a method which takes
more time to minimize the wasted space.


File: libc.info,  Node: Aligned Memory Blocks,  Next: Heap Consistency Checking,  Prev: Efficiency and Malloc,  Up: Unconstrained Allocation

Allocating Aligned Memory Blocks
--------------------------------

   The address of a block returned by `malloc' or `realloc' in the GNU
system is always a multiple of eight.  If you need a block whose
address is a multiple of a higher power of two than that, use
`memalign' or `valloc'.  These functions are declared in `stdlib.h'.

   With the GNU library, you can use `free' to free the blocks that
`memalign' and `valloc' return.  That does not work in BSD,
however--BSD does not provide any way to free such blocks.

 - Function: void * memalign (size_t SIZE, size_t BOUNDARY)
     The `memalign' function allocates a block of SIZE bytes whose
     address is a multiple of BOUNDARY.  The BOUNDARY must be a power
     of two!  The function `memalign' works by calling `malloc' to
     allocate a somewhat larger block, and then returning an address
     within the block that is on the specified boundary.

 - Function: void * valloc (size_t SIZE)
     Using `valloc' is like using `memalign' and passing the page size
     as the value of the second argument.  It is implemented like this:

          void *
          valloc (size_t size)
          {
            return memalign (size, getpagesize ());
          }


File: libc.info,  Node: Heap Consistency Checking,  Next: Hooks for Malloc,  Prev: Aligned Memory Blocks,  Up: Unconstrained Allocation

Heap Consistency Checking
-------------------------

   You can ask `malloc' to check the consistency of dynamic storage by
using the `mcheck' function.  This function is a GNU extension,
declared in `malloc.h'.

 - Function: int mcheck (void (*ABORTFN) (void))
     Calling `mcheck' tells `malloc' to perform occasional consistency
     checks.  These will catch things such as writing past the end of a
     block that was allocated with `malloc'.

     The ABORTFN argument is the function to call when an inconsistency
     is found.  If you supply a null pointer, the `abort' function is
     used.

     It is too late to begin allocation checking once you have allocated
     anything with `malloc'.  So `mcheck' does nothing in that case.
     The function returns `-1' if you call it too late, and `0'
     otherwise (when it is successful).

     The easiest way to arrange to call `mcheck' early enough is to use
     the option `-lmcheck' when you link your program; then you don't
     need to modify your program source at all.


File: libc.info,  Node: Hooks for Malloc,  Next: Statistics of Malloc,  Prev: Heap Consistency Checking,  Up: Unconstrained Allocation

Storage Allocation Hooks
------------------------

   The GNU C library lets you modify the behavior of `malloc',
`realloc', and `free' by specifying appropriate hook functions.  You
can use these hooks to help you debug programs that use dynamic storage
allocation, for example.

   The hook variables are declared in `malloc.h'.

 - Variable: __malloc_hook
     The value of this variable is a pointer to function that `malloc'
     uses whenever it is called.  You should define this function to
     look like `malloc'; that is, like:

          void *FUNCTION (size_t SIZE)

 - Variable: __realloc_hook
     The value of this variable is a pointer to function that `realloc'
     uses whenever it is called.  You should define this function to
     look like `realloc'; that is, like:

          void *FUNCTION (void *PTR, size_t SIZE)

 - Variable: __free_hook
     The value of this variable is a pointer to function that `free'
     uses whenever it is called.  You should define this function to
     look like `free'; that is, like:

          void FUNCTION (void *PTR)

   You must make sure that the function you install as a hook for one of
these functions does not call that function recursively without
restoring the old value of the hook first!  Otherwise, your program
will get stuck in an infinite recursion.

   Here is an example showing how to use `__malloc_hook' properly.  It
installs a function that prints out information every time `malloc' is
called.

     static void *(*old_malloc_hook) (size_t);
     static void *
     my_malloc_hook (size_t size)
     {
       void *result;
       __malloc_hook = old_malloc_hook;
       result = malloc (size);
       __malloc_hook = my_malloc_hook;
       printf ("malloc (%u) returns %p\n", (unsigned int) size, result);
       return result;
     }
     
     main ()
     {
       ...
       old_malloc_hook = __malloc_hook;
       __malloc_hook = my_malloc_hook;
       ...
     }

   The `mcheck' function (*note Heap Consistency Checking::.) works by
installing such hooks.


File: libc.info,  Node: Statistics of Malloc,  Next: Summary of Malloc,  Prev: Hooks for Malloc,  Up: Unconstrained Allocation

Statistics for Storage Allocation with `malloc'
-----------------------------------------------

   You can get information about dynamic storage allocation by calling
the `mstats' function.  This function and its associated data type are
declared in `malloc.h'; they are a GNU extension.

 - Data Type: struct mstats
     This structure type is used to return information about the dynamic
     storage allocator.  It contains the following members:

    `size_t bytes_total'
          This is the total size of memory managed by `malloc', in
          bytes.

    `size_t chunks_used'
          This is the number of chunks in use.  (The storage allocator
          internally gets chunks of memory from the operating system,
          and then carves them up to satisfy individual `malloc'
          requests; see *Note Efficiency and Malloc::.)

    `size_t bytes_used'
          This is the number of bytes in use.

    `size_t chunks_free'
          This is the number of chunks which are free - that is, that
          have been allocated by the operating system to your program,
          but which are not now being used.

    `size_t bytes_free'
          This is the number of bytes which are free.

 - Function: struct mstats mstats (void)
     This function returns information about the current dynamic memory
     usage in a structure of type `struct mstats'.


File: libc.info,  Node: Summary of Malloc,  Prev: Statistics of Malloc,  Up: Unconstrained Allocation

Summary of `malloc'-Related Functions
-------------------------------------

   Here is a summary of the functions that work with `malloc':

`void *malloc (size_t SIZE)'
     Allocate a block of SIZE bytes.  *Note Basic Allocation::.

`void free (void *ADDR)'
     Free a block previously allocated by `malloc'.  *Note Freeing
     after Malloc::.

`void *realloc (void *ADDR, size_t SIZE)'
     Make a block previously allocated by `malloc' larger or smaller,
     possibly by copying it to a new location.  *Note Changing Block
     Size::.

`void *calloc (size_t COUNT, size_t ELTSIZE)'
     Allocate a block of COUNT * ELTSIZE bytes using `malloc', and set
     its contents to zero.  *Note Allocating Cleared Space::.

`void *valloc (size_t SIZE)'
     Allocate a block of SIZE bytes, starting on a page boundary.
     *Note Aligned Memory Blocks::.

`void *memalign (size_t SIZE, size_t BOUNDARY)'
     Allocate a block of SIZE bytes, starting on an address that is a
     multiple of BOUNDARY.  *Note Aligned Memory Blocks::.

`int mcheck (void (*ABORTFN) (void))'
     Tell `malloc' to perform occasional consistency checks on
     dynamically allocated memory, and to call ABORTFN when an
     inconsistency is found.  *Note Heap Consistency Checking::.

`void *(*__malloc_hook) (size_t SIZE)'
     A pointer to a function that `malloc' uses whenever it is called.

`void *(*__realloc_hook) (void *PTR, size_t SIZE)'
     A pointer to a function that `realloc' uses whenever it is called.

`void (*__free_hook) (void *PTR)'
     A pointer to a function that `free' uses whenever it is called.

`struct mstats mstats (void)'
     Return information about the current dynamic memory usage.  *Note
     Statistics of Malloc::.


File: libc.info,  Node: Obstacks,  Next: Variable Size Automatic,  Prev: Unconstrained Allocation,  Up: Memory Allocation

Obstacks
========

   An "obstack" is a pool of memory containing a stack of objects.  You
can create any number of separate obstacks, and then allocate objects in
specified obstacks.  Within each obstack, the last object allocated must
always be the first one freed, but distinct obstacks are independent of
each other.

   Aside from this one constraint of order of freeing, obstacks are
totally general: an obstack can contain any number of objects of any
size.  They are implemented with macros, so allocation is usually very
fast as long as the objects are usually small.  And the only space
overhead per object is the padding needed to start each object on a
suitable boundary.

* Menu:

* Creating Obstacks::		How to declare an obstack in your program.
* Preparing for Obstacks::	Preparations needed before you can
				 use obstacks.
* Allocation in an Obstack::    Allocating objects in an obstack.
* Freeing Obstack Objects::     Freeing objects in an obstack.
* Obstack Functions::		The obstack functions are both
				 functions and macros.
* Growing Objects::             Making an object bigger by stages.
* Extra Fast Growing::		Extra-high-efficiency (though more
				 complicated) growing objects.
* Status of an Obstack::        Inquiries about the status of an obstack.
* Obstacks Data Alignment::     Controlling alignment of objects in obstacks.
* Obstack Chunks::              How obstacks obtain and release chunks;
				 efficiency considerations.
* Summary of Obstacks::


File: libc.info,  Node: Creating Obstacks,  Next: Preparing for Obstacks,  Up: Obstacks

Creating Obstacks
-----------------

   The utilities for manipulating obstacks are declared in the header
file `obstack.h'.

 - Data Type: struct obstack
     An obstack is represented by a data structure of type `struct
     obstack'.  This structure has a small fixed size; it records the
     status of the obstack and how to find the space in which objects
     are allocated.  It does not contain any of the objects themselves.
     You should not try to access the contents of the structure
     directly; use only the functions described in this chapter.

   You can declare variables of type `struct obstack' and use them as
obstacks, or you can allocate obstacks dynamically like any other kind
of object.  Dynamic allocation of obstacks allows your program to have a
variable number of different stacks.  (You can even allocate an obstack
structure in another obstack, but this is rarely useful.)

   All the functions that work with obstacks require you to specify
which obstack to use.  You do this with a pointer of type `struct
obstack *'.  In the following, we often say "an obstack" when strictly
speaking the object at hand is such a pointer.

   The objects in the obstack are packed into large blocks called
"chunks".  The `struct obstack' structure points to a chain of the
chunks currently in use.

   The obstack library obtains a new chunk whenever you allocate an
object that won't fit in the previous chunk.  Since the obstack library
manages chunks automatically, you don't need to pay much attention to
them, but you do need to supply a function which the obstack library
should use to get a chunk.  Usually you supply a function which uses
`malloc' directly or indirectly.  You must also supply a function to
free a chunk.  These matters are described in the following section.


File: libc.info,  Node: Preparing for Obstacks,  Next: Allocation in an Obstack,  Prev: Creating Obstacks,  Up: Obstacks

Preparing for Using Obstacks
----------------------------

   Each source file in which you plan to use the obstack functions must
include the header file `obstack.h', like this:

     #include <obstack.h>

   Also, if the source file uses the macro `obstack_init', it must
declare or define two functions or macros that will be called by the
obstack library.  One, `obstack_chunk_alloc', is used to allocate the
chunks of memory into which objects are packed.  The other,
`obstack_chunk_free', is used to return chunks when the objects in them
are freed.

   Usually these are defined to use `malloc' via the intermediary
`xmalloc' (*note Unconstrained Allocation::.).  This is done with the
following pair of macro definitions:

     #define obstack_chunk_alloc xmalloc
     #define obstack_chunk_free free

Though the storage you get using obstacks really comes from `malloc',
using obstacks is faster because `malloc' is called less often, for
larger blocks of memory.  *Note Obstack Chunks::, for full details.

   At run time, before the program can use a `struct obstack' object as
an obstack, it must initialize the obstack by calling `obstack_init'.

 - Function: void obstack_init (struct obstack *OBSTACK_PTR)
     Initialize obstack OBSTACK_PTR for allocation of objects.

   Here are two examples of how to allocate the space for an obstack and
initialize it.  First, an obstack that is a static variable:

     static struct obstack myobstack;
     ...
     obstack_init (&myobstack);

Second, an obstack that is itself dynamically allocated:

     struct obstack *myobstack_ptr
       = (struct obstack *) xmalloc (sizeof (struct obstack));
     
     obstack_init (myobstack_ptr);


File: libc.info,  Node: Allocation in an Obstack,  Next: Freeing Obstack Objects,  Prev: Preparing for Obstacks,  Up: Obstacks

Allocation in an Obstack
------------------------

   The most direct way to allocate an object in an obstack is with
`obstack_alloc', which is invoked almost like `malloc'.

 - Function: void * obstack_alloc (struct obstack *OBSTACK_PTR, size_t
          SIZE)
     This allocates an uninitialized block of SIZE bytes in an obstack
     and returns its address.  Here OBSTACK_PTR specifies which obstack
     to allocate the block in; it is the address of the `struct obstack'
     object which represents the obstack.  Each obstack function or
     macro requires you to specify an OBSTACK_PTR as the first argument.

   For example, here is a function that allocates a copy of a string STR
in a specific obstack, which is in the variable `string_obstack':

     struct obstack string_obstack;
     
     char *
     copystring (char *string)
     {
       char *s = (char *) obstack_alloc (&string_obstack,
                                         strlen (string) + 1);
       memcpy (s, string, strlen (string));
       return s;
     }

   To allocate a block with specified contents, use the function
`obstack_copy', declared like this:

 - Function: void * obstack_copy (struct obstack *OBSTACK_PTR, void
          *ADDRESS, size_t SIZE)
     This allocates a block and initializes it by copying SIZE bytes of
     data starting at ADDRESS.

 - Function: void * obstack_copy0 (struct obstack *OBSTACK_PTR, void
          *ADDRESS, size_t SIZE)
     Like `obstack_copy', but appends an extra byte containing a null
     character.  This extra byte is not counted in the argument SIZE.

   The `obstack_copy0' function is convenient for copying a sequence of
characters into an obstack as a null-terminated string.  Here is an
example of its use:

     char *
     obstack_savestring (char *addr, size_t size)
     {
       return obstack_copy0 (&myobstack, addr, size);
     }

Contrast this with the previous example of `savestring' using `malloc'
(*note Basic Allocation::.).


File: libc.info,  Node: Freeing Obstack Objects,  Next: Obstack Functions,  Prev: Allocation in an Obstack,  Up: Obstacks

Freeing Objects in an Obstack
-----------------------------

   To free an object allocated in an obstack, use the function
`obstack_free'.  Since the obstack is a stack of objects, freeing one
object automatically frees all other objects allocated more recently in
the same obstack.

 - Function: void obstack_free (struct obstack *OBSTACK_PTR, void
          *OBJECT)
     If OBJECT is a null pointer, everything allocated in the obstack
     is freed.  Otherwise, OBJECT must be the address of an object
     allocated in the obstack.  Then OBJECT is freed, along with
     everything allocated in OBSTACK since OBJECT.

   Note that if OBJECT is a null pointer, the result is an
uninitialized obstack.  To free all storage in an obstack but leave it
valid for further allocation, call `obstack_free' with the address of
the first object allocated on the obstack:

     obstack_free (obstack_ptr, first_object_allocated_ptr);

   Recall that the objects in an obstack are grouped into chunks.  When
all the objects in a chunk become free, the obstack library
automatically frees the chunk (*note Preparing for Obstacks::.).  Then
other obstacks, or non-obstack allocation, can reuse the space of the
chunk.


File: libc.info,  Node: Obstack Functions,  Next: Growing Objects,  Prev: Freeing Obstack Objects,  Up: Obstacks

Obstack Functions and Macros
----------------------------

   The interfaces for using obstacks may be defined either as functions
or as macros, depending on the compiler.  The obstack facility works
with all C compilers, including both ANSI C and traditional C, but
there are precautions you must take if you plan to use compilers other
than GNU C.

   If you are using an old-fashioned non-ANSI C compiler, all the
obstack "functions" are actually defined only as macros.  You can call
these macros like functions, but you cannot use them in any other way
(for example, you cannot take their address).

   Calling the macros requires a special precaution: namely, the first
operand (the obstack pointer) may not contain any side effects, because
it may be computed more than once.  For example, if you write this:

     obstack_alloc (get_obstack (), 4);

you will find that `get_obstack' may be called several times.  If you
use `*obstack_list_ptr++' as the obstack pointer argument, you will get
very strange results since the incrementation may occur several times.

   In ANSI C, each function has both a macro definition and a function
definition.  The function definition is used if you take the address of
the function without calling it.  An ordinary call uses the macro
definition by default, but you can request the function definition
instead by writing the function name in parentheses, as shown here:

     char *x;
     void *(*funcp) ();
     /* Use the macro.  */
     x = (char *) obstack_alloc (obptr, size);
     /* Call the function.  */
     x = (char *) (obstack_alloc) (obptr, size);
     /* Take the address of the function.  */
     funcp = obstack_alloc;

This is the same situation that exists in ANSI C for the standard
library functions.  *Note Macro Definitions::.

   *Warning:* When you do use the macros, you must observe the
precaution of avoiding side effects in the first operand, even in ANSI
C.

   If you use the GNU C compiler, this precaution is not necessary,
because various language extensions in GNU C permit defining the macros
so as to compute each argument only once.


File: libc.info,  Node: Growing Objects,  Next: Extra Fast Growing,  Prev: Obstack Functions,  Up: Obstacks

Growing Objects
---------------

   Because storage in obstack chunks is used sequentially, it is
possible to build up an object step by step, adding one or more bytes
at a time to the end of the object.  With this technique, you do not
need to know how much data you will put in the object until you come to
the end of it.  We call this the technique of "growing objects".  The
special functions for adding data to the growing object are described
in this section.

   You don't need to do anything special when you start to grow an
object.  Using one of the functions to add data to the object
automatically starts it.  However, it is necessary to say explicitly
when the object is finished.  This is done with the function
`obstack_finish'.

   The actual address of the object thus built up is not known until the
object is finished.  Until then, it always remains possible that you
will add so much data that the object must be copied into a new chunk.

   While the obstack is in use for a growing object, you cannot use it
for ordinary allocation of another object.  If you try to do so, the
space already added to the growing object will become part of the other
object.

 - Function: void obstack_blank (struct obstack *OBSTACK_PTR, size_t
          SIZE)
     The most basic function for adding to a growing object is
     `obstack_blank', which adds space without initializing it.

 - Function: void obstack_grow (struct obstack *OBSTACK_PTR, void
          *DATA, size_t SIZE)
     To add a block of initialized space, use `obstack_grow', which is
     the growing-object analogue of `obstack_copy'.  It adds SIZE bytes
     of data to the growing object, copying the contents from DATA.

 - Function: void obstack_grow0 (struct obstack *OBSTACK_PTR, void
          *DATA, size_t SIZE)
     This is the growing-object analogue of `obstack_copy0'.  It adds
     SIZE bytes copied from DATA, followed by an additional null
     character.

 - Function: void obstack_1grow (struct obstack *OBSTACK_PTR, char C)
     To add one character at a time, use the function `obstack_1grow'.
     It adds a single byte containing C to the growing object.

 - Function: void * obstack_finish (struct obstack *OBSTACK_PTR)
     When you are finished growing the object, use the function
     `obstack_finish' to close it off and return its final address.

     Once you have finished the object, the obstack is available for
     ordinary allocation or for growing another object.

   When you build an object by growing it, you will probably need to
know afterward how long it became.  You need not keep track of this as
you grow the object, because you can find out the length from the
obstack just before finishing the object with the function
`obstack_object_size', declared as follows:

 - Function: size_t obstack_object_size (struct obstack *OBSTACK_PTR)
     This function returns the current size of the growing object, in
     bytes.  Remember to call this function *before* finishing the
     object.  After it is finished, `obstack_object_size' will return
     zero.

   If you have started growing an object and wish to cancel it, you
should finish it and then free it, like this:

     obstack_free (obstack_ptr, obstack_finish (obstack_ptr));

This has no effect if no object was growing.

   You can use `obstack_blank' with a negative size argument to make
the current object smaller.  Just don't try to shrink it beyond zero
length--there's no telling what will happen if you do that.


File: libc.info,  Node: Extra Fast Growing,  Next: Status of an Obstack,  Prev: Growing Objects,  Up: Obstacks

Extra Fast Growing Objects
--------------------------

   The usual functions for growing objects incur overhead for checking
whether there is room for the new growth in the current chunk.  If you
are frequently constructing objects in small steps of growth, this
overhead can be significant.

   You can reduce the overhead by using special "fast growth" functions
that grow the object without checking.  In order to have a robust
program, you must do the checking yourself.  If you do this checking in
the simplest way each time you are about to add data to the object, you
have not saved anything, because that is what the ordinary growth
functions do.  But if you can arrange to check less often, or check
more efficiently, then you make the program faster.

   The function `obstack_room' returns the amount of room available in
the current chunk.  It is declared as follows:

 - Function: size_t obstack_room (struct obstack *OBSTACK_PTR)
     This returns the number of bytes that can be added safely to the
     current growing object (or to an object about to be started) in
     obstack OBSTACK using the fast growth functions.

   While you know there is room, you can use these fast growth functions
for adding data to a growing object:

 - Function: void obstack_1grow_fast (struct obstack *OBSTACK_PTR, char
          C)
     The function `obstack_1grow_fast' adds one byte containing the
     character C to the growing object in obstack OBSTACK_PTR.

 - Function: void obstack_blank_fast (struct obstack *OBSTACK_PTR,
          size_t SIZE)
     The function `obstack_blank_fast' adds SIZE bytes to the growing
     object in obstack OBSTACK_PTR without initializing them.

   When you check for space using `obstack_room' and there is not
enough room for what you want to add, the fast growth functions are not
safe.  In this case, simply use the corresponding ordinary growth
function instead.  Very soon this will copy the object to a new chunk;
then there will be lots of room available again.

   So, each time you use an ordinary growth function, check afterward
for sufficient space using `obstack_room'.  Once the object is copied
to a new chunk, there will be plenty of space again, so the program will
start using the fast growth functions again.

   Here is an example:

     void
     add_string (struct obstack *obstack, char *ptr, size_t len)
     {
       while (len > 0)
         {
           if (obstack_room (obstack) > len)
             {
               /* We have enough room: add everything fast.  */
               while (len-- > 0)
                 obstack_1grow_fast (obstack, *ptr++);
             }
           else
             {
               /* Not enough room. Add one character slowly,
                  which may copy to a new chunk and make room.  */
               obstack_1grow (obstack, *ptr++);
               len--;
             }
         }
     }


File: libc.info,  Node: Status of an Obstack,  Next: Obstacks Data Alignment,  Prev: Extra Fast Growing,  Up: Obstacks

Status of an Obstack
--------------------

   Here are functions that provide information on the current status of
allocation in an obstack.  You can use them to learn about an object
while still growing it.

 - Function: void * obstack_base (struct obstack *OBSTACK_PTR)
     This function returns the tentative address of the beginning of the
     currently growing object in OBSTACK_PTR.  If you finish the object
     immediately, it will have that address.  If you make it larger
     first, it may outgrow the current chunk--then its address will
     change!

     If no object is growing, this value says where the next object you
     allocate will start (once again assuming it fits in the current
     chunk).

 - Function: void * obstack_next_free (struct obstack *OBSTACK_PTR)
     This function returns the address of the first free byte in the
     current chunk of obstack OBSTACK_PTR.  This is the end of the
     currently growing object.  If no object is growing,
     `obstack_next_free' returns the same value as `obstack_base'.

 - Function: size_t obstack_object_size (struct obstack *OBSTACK_PTR)
     This function returns the size in bytes of the currently growing
     object.  This is equivalent to

          obstack_next_free (OBSTACK_PTR) - obstack_base (OBSTACK_PTR)


File: libc.info,  Node: Obstacks Data Alignment,  Next: Obstack Chunks,  Prev: Status of an Obstack,  Up: Obstacks

Alignment of Data in Obstacks
-----------------------------

   Each obstack has an "alignment boundary"; each object allocated in
the obstack automatically starts on an address that is a multiple of the
specified boundary.  By default, this boundary is 4 bytes.

   To access an obstack's alignment boundary, use the macro
`obstack_alignment_mask', whose function prototype looks like this:

 - Macro: int obstack_alignment_mask (struct obstack *OBSTACK_PTR)
     The value is a bit mask; a bit that is 1 indicates that the
     corresponding bit in the address of an object should be 0.  The
     mask value should be one less than a power of 2; the effect is
     that all object addresses are multiples of that power of 2.  The
     default value of the mask is 3, so that addresses are multiples of
     4.  A mask value of 0 means an object can start on any multiple of
     1 (that is, no alignment is required).

     The expansion of the macro `obstack_alignment_mask' is an lvalue,
     so you can alter the mask by assignment.  For example, this
     statement:

          obstack_alignment_mask (obstack_ptr) = 0;

     has the effect of turning off alignment processing in the
     specified obstack.

   Note that a change in alignment mask does not take effect until
*after* the next time an object is allocated or finished in the
obstack.  If you are not growing an object, you can make the new
alignment mask take effect immediately by calling `obstack_finish'.
This will finish a zero-length object and then do proper alignment for
the next object.


File: libc.info,  Node: Obstack Chunks,  Next: Summary of Obstacks,  Prev: Obstacks Data Alignment,  Up: Obstacks

Obstack Chunks
--------------

   Obstacks work by allocating space for themselves in large chunks, and
then parceling out space in the chunks to satisfy your requests.  Chunks
are normally 4096 bytes long unless you specify a different chunk size.
The chunk size includes 8 bytes of overhead that are not actually used
for storing objects.  Regardless of the specified size, longer chunks
will be allocated when necessary for long objects.

   The obstack library allocates chunks by calling the function
`obstack_chunk_alloc', which you must define.  When a chunk is no
longer needed because you have freed all the objects in it, the obstack
library frees the chunk by calling `obstack_chunk_free', which you must
also define.

   These two must be defined (as macros) or declared (as functions) in
each source file that uses `obstack_init' (*note Creating Obstacks::.).
Most often they are defined as macros like this:

     #define obstack_chunk_alloc xmalloc
     #define obstack_chunk_free free

   Note that these are simple macros (no arguments).  Macro definitions
with arguments will not work!  It is necessary that
`obstack_chunk_alloc' or `obstack_chunk_free', alone, expand into a
function name if it is not itself a function name.

   The function that actually implements `obstack_chunk_alloc' cannot
return "failure" in any fashion, because the obstack library is not
prepared to handle failure.  Therefore, `malloc' itself is not
suitable.  If the function cannot obtain space, it should either
terminate the process (*note Program Termination::.) or do a nonlocal
exit using `longjmp' (*note Non-Local Exits::.).

   If you allocate chunks with `malloc', the chunk size should be a
power of 2.  The default chunk size, 4096, was chosen because it is long
enough to satisfy many typical requests on the obstack yet short enough
not to waste too much memory in the portion of the last chunk not yet
used.

 - Macro: size_t obstack_chunk_size (struct obstack *OBSTACK_PTR)
     This returns the chunk size of the given obstack.

   Since this macro expands to an lvalue, you can specify a new chunk
size by assigning it a new value.  Doing so does not affect the chunks
already allocated, but will change the size of chunks allocated for
that particular obstack in the future.  It is unlikely to be useful to
make the chunk size smaller, but making it larger might improve
efficiency if you are allocating many objects whose size is comparable
to the chunk size.  Here is how to do so cleanly:

     if (obstack_chunk_size (obstack_ptr) < NEW_CHUNK_SIZE)
       obstack_chunk_size (obstack_ptr) = NEW_CHUNK_SIZE;


File: libc.info,  Node: Summary of Obstacks,  Prev: Obstack Chunks,  Up: Obstacks

Summary of Obstack Functions
----------------------------

   Here is a summary of all the functions associated with obstacks.
Each takes the address of an obstack (`struct obstack *') as its first
argument.

`void obstack_init (struct obstack *OBSTACK_PTR)'
     Initialize use of an obstack.  *Note Creating Obstacks::.

`void *obstack_alloc (struct obstack *OBSTACK_PTR, size_t SIZE)'
     Allocate an object of SIZE uninitialized bytes.  *Note Allocation
     in an Obstack::.

`void *obstack_copy (struct obstack *OBSTACK_PTR, void *ADDRESS, size_t SIZE)'
     Allocate an object of SIZE bytes, with contents copied from
     ADDRESS.  *Note Allocation in an Obstack::.

`void *obstack_copy0 (struct obstack *OBSTACK_PTR, void *ADDRESS, size_t SIZE)'
     Allocate an object of SIZE+1 bytes, with SIZE of them copied from
     ADDRESS, followed by a null character at the end.  *Note
     Allocation in an Obstack::.

`void obstack_free (struct obstack *OBSTACK_PTR, void *OBJECT)'
     Free OBJECT (and everything allocated in the specified obstack
     more recently than OBJECT).  *Note Freeing Obstack Objects::.

`void obstack_blank (struct obstack *OBSTACK_PTR, size_t SIZE)'
     Add SIZE uninitialized bytes to a growing object.  *Note Growing
     Objects::.

`void obstack_grow (struct obstack *OBSTACK_PTR, void *ADDRESS, size_t SIZE)'
     Add SIZE bytes, copied from ADDRESS, to a growing object.  *Note
     Growing Objects::.

`void obstack_grow0 (struct obstack *OBSTACK_PTR, void *ADDRESS, size_t SIZE)'
     Add SIZE bytes, copied from ADDRESS, to a growing object, and then
     add another byte containing a null character.  *Note Growing
     Objects::.

`void obstack_1grow (struct obstack *OBSTACK_PTR, char DATA_CHAR)'
     Add one byte containing DATA_CHAR to a growing object.  *Note
     Growing Objects::.

`void *obstack_finish (struct obstack *OBSTACK_PTR)'
     Finalize the object that is growing and return its permanent
     address.  *Note Growing Objects::.

`size_t obstack_object_size (struct obstack *OBSTACK_PTR)'
     Get the current size of the currently growing object.  *Note
     Growing Objects::.

`void obstack_blank_fast (struct obstack *OBSTACK_PTR, size_t SIZE)'
     Add SIZE uninitialized bytes to a growing object without checking
     that there is enough room.  *Note Extra Fast Growing::.

`void obstack_1grow_fast (struct obstack *OBSTACK_PTR, char DATA_CHAR)'
     Add one byte containing DATA_CHAR to a growing object without
     checking that there is enough room.  *Note Extra Fast Growing::.

`size_t obstack_room (struct obstack *OBSTACK_PTR)'
     Get the amount of room now available for growing the current
     object.  *Note Extra Fast Growing::.

`int obstack_alignment_mask (struct obstack *OBSTACK_PTR)'
     The mask used for aligning the beginning of an object.  This is an
     lvalue.  *Note Obstacks Data Alignment::.

`size_t obstack_chunk_size (struct obstack *OBSTACK_PTR)'
     The size for allocating chunks.  This is an lvalue.  *Note Obstack
     Chunks::.

`void *obstack_base (struct obstack *OBSTACK_PTR)'
     Tentative starting address of the currently growing object.  *Note
     Status of an Obstack::.

`void *obstack_next_free (struct obstack *OBSTACK_PTR)'
     Address just after the end of the currently growing object.  *Note
     Status of an Obstack::.


File: libc.info,  Node: Variable Size Automatic,  Next: Relocating Allocator,  Prev: Obstacks,  Up: Memory Allocation

Automatic Storage with Variable Size
====================================

   The function `alloca' supports a kind of half-dynamic allocation in
which blocks are allocated dynamically but freed automatically.

   Allocating a block with `alloca' is an explicit action; you can
allocate as many blocks as you wish, and compute the size at run time.
But all the blocks are freed when you exit the function that `alloca'
was called from, just as if they were automatic variables declared in
that function.  There is no way to free the space explicitly.

   The prototype for `alloca' is in `stdlib.h'.  This function is a BSD
extension.

 - Function: void * alloca (size_t SIZE);
     The return value of `alloca' is the address of a block of SIZE
     bytes of storage, allocated in the stack frame of the calling
     function.

   Do not use `alloca' inside the arguments of a function call--you
will get unpredictable results, because the stack space for the
`alloca' would appear on the stack in the middle of the space for the
function arguments.  An example of what to avoid is `foo (x, alloca
(4), y)'.

* Menu:

* Alloca Example::              Example of using `alloca'.
* Advantages of Alloca::        Reasons to use `alloca'.
* Disadvantages of Alloca::     Reasons to avoid `alloca'.
* GNU C Variable-Size Arrays::  Only in GNU C, here is an alternative
				 method of allocating dynamically and
				 freeing automatically.


File: libc.info,  Node: Alloca Example,  Next: Advantages of Alloca,  Up: Variable Size Automatic

`alloca' Example
----------------

   As an example of use of `alloca', here is a function that opens a
file name made from concatenating two argument strings, and returns a
file descriptor or minus one signifying failure:

     int
     open2 (char *str1, char *str2, int flags, int mode)
     {
       char *name = (char *) alloca (strlen (str1) + strlen (str2) + 1);
       strcpy (name, str1);
       strcat (name, str2);
       return open (name, flags, mode);
     }

Here is how you would get the same results with `malloc' and `free':

     int
     open2 (char *str1, char *str2, int flags, int mode)
     {
       char *name = (char *) malloc (strlen (str1) + strlen (str2) + 1);
       int desc;
       if (name == 0)
         fatal ("virtual memory exceeded");
       strcpy (name, str1);
       strcat (name, str2);
       desc = open (name, flags, mode);
       free (name);
       return desc;
     }

   As you can see, it is simpler with `alloca'.  But `alloca' has
other, more important advantages, and some disadvantages.

