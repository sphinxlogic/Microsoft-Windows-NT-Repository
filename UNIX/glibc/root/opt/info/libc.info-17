This is Info file libc.info, produced by Makeinfo-1.55 from the input
file libc.texinfo.

   This file documents the GNU C library.

   This is Edition 0.05, last updated 30 August 1993, of `The GNU C
Library Reference Manual', for Version 1.07 Beta.

   Copyright (C) 1993 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU Library General Public License" is
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the text of the translations of the section
entitled "GNU Library General Public License" must be approved for
accuracy by the Foundation.


File: libc.info,  Node: Limits on Resources,  Next: Priority,  Prev: Resource Usage,  Up: Date and Time

Limiting Resource Usage
=======================

   You can specify limits for the resource usage of a process.  When the
process tries to exceed a limit, it may get a signal, or the system call
by which it tried to do so may fail, depending on the limit.  Each
process initially inherits its limit values from its parent, but it can
subsequently change them.

   The symbols in this section are defined in `sys/resource.h'.

 - Function: int getrlimit (int RESOURCE, struct rlimit *RLP)
     Read the current value and the maximum value of resource RESOURCE
     and store them in `*RLP'.

     The return value is `0' on success and `-1' on failure.  The only
     possible `errno' error condition is `EFAULT'.

 - Function: int setrlimit (int RESOURCE, struct rlimit *RLP)
     Store the current value and the maximum value of resource RESOURCE
     in `*RLP'.

     The return value is `0' on success and `-1' on failure.  The
     following `errno' error condition is possible:

    `EPERM'
          You tried to change the maximum permissible limit value, but
          you don't have privileges to do so.

 - Data Type: struct rlimit
     This structure is used with `getrlimit' to receive limit values,
     and with `setrlimit' to specify limit values.  It has two fields:

    `rlim_cur'
          The current value of the limit in question.

    `rlim_max'
          The maximum permissible value of the limit in question.  You
          cannot set the current value of the limit to a larger number
          than this maximum.  Only the super user can change the
          maximum permissible value.

     In `getrlimit', the structure is an output; it receives the current
     values.  In `setrlimit', it specifies the new values.

   Here is a list of resources that you can specify a limit for.  Those
that are sizes are measured in bytes.

`RLIMIT_CPU'
     The maximum amount of cpu time the process can use.  If it runs for
     longer than this, it gets a signal: `SIGXCPU'.  The value is
     measured in seconds.  *Note Nonstandard Signals::.

`RLIMIT_FSIZE'
     The maximum size of file the process can create.  Trying to write a
     larger file causes a signal: `SIGXFSZ'.  *Note Nonstandard
     Signals::.

`RLIMIT_DATA'
     The maximum size of data memory for the process.  If the process
     tries to allocate data memory beyond this amount, the allocation
     function fails.

`RLIMIT_STACK'
     The maximum stack size for the process.  If the process tries to
     extend its stack past this size, it gets a `SIGSEGV' signal.
     *Note Program Error Signals::.

`RLIMIT_CORE'
     The maximum size core file that this process can create.  If the
     process terminates and a core file is made, and this maximum size
     is not enough, the core file is truncated.

`RLIMIT_RSS'
     The maximum amount of physical memory that this process should get.
     This parameter is a guide for the system's scheduler and memory
     allocator; the system may give the process more memory when there
     is a surplus.

`RLIMIT_OPEN_FILES'
     The maximum number of files that the process can open.  If it
     tries to open more files than this, it gets error code `EMFILE'.
     *Note Error Codes::.

`RLIM_NLIMITS'
     The number of different resource limits.  Any valid RESOURCE
     operand must be less than `RLIM_NLIMITS'.

 - Constant: int
     This constant stands for a value of "infinity" when supplied as
     the limit value in `setrlimit'.

   Two historical functions for setting resource limits, `ulimit' and
`vlimit', are not documented here.  The latter is declared in
`sys/vlimit.h' and comes from BSD.


File: libc.info,  Node: Priority,  Prev: Limits on Resources,  Up: Date and Time

Process Priority
================

   When several processes try to run, their respective priorities
determine what share of the CPU each process gets.  This section
describes how you can read and set the priority of a process.  All
these functions and macros are declared in `sys/resource.h'.

   The range of valid priority values depends on the operating system,
but typically it runs from `-20' to `20'.  A lower priority value means
the process runs more often.  These constants describe the range of
priority values:

`PRIO_MIN'
     The smallest valid priority value.

`PRIO_MAX'
     The smallest valid priority value.

 - Function: int getpriority (int CLASS, int ID)
     Read the priority of a class of processes; CLASS and ID specify
     which ones (see below).

     The return value is the priority value on success, and `-1' on
     failure.  The following `errno' error condition are possible for
     this function:

    `ESRCH'
          The combination of CLASS and ID does not match any existing
          process.

    `EINVAL'
          The value of CLASS is not valid.

     When the return value is `-1', it could indicate failure, or it
     could be the priority value.  The only way to make certain is to
     set `errno = 0' before calling `getpriority', then use `errno !=
     0' afterward as the criterion for failure.

 - Function: int setpriority (int CLASS, int ID, int PRIORITY)
     Read the priority of a class of processes; CLASS and ID specify
     which ones (see below).

     The return value is `0' on success and `-1' on failure.  The
     following `errno' error condition are defined for this function:

    `ESRCH'
          The combination of CLASS and ID does not match any existing
          process.

    `EINVAL'
          The value of CLASS is not valid.

    `EPERM'
          You tried to set the priority of some other user's process,
          and you don't have privileges for that.

    `EACCES'
          You tried to lower the priority of a process, and you don't
          have privileges for that.

   The arguments CLASS and ID together specify a set of processes you
are interested in.  These are the possible values for CLASS:

`PRIO_PROCESS'
     Read or set the priority of one process.  The argument ID is a
     process ID.

`PRIO_PGRP'
     Read or set the priority of one process group.  The argument ID is
     a process group ID.

`PRIO_USER'
     Read or set the priority of one user's processes.  The argument ID
     is a user ID.

   If the argument ID is 0, it stands for the current process, current
process group, or the current user, according to CLASS.

 - Function: int nice (int INCREMENT)
     Increment the priority of the current process by INCREMENT.  The
     return value is not meaningful.

     Here is an equivalent definition for `nice':

          int
          nice (int increment)
          {
            int old = getpriority (PRIO_PROCESS, 0);
            setpriority (PRIO_PROCESS, 0, old + increment);
          }


File: libc.info,  Node: Extended Characters,  Next: Locales,  Prev: String and Array Utilities,  Up: Top

Extended Characters
*******************

   A number of languages use character sets that are larger than the
range of values of type `char'.  Japanese and Chinese are probably the
most familiar examples.

   The GNU C library includes support for two mechanisms for dealing
with extended character sets: multibyte characters and wide characters.
This chapter describes how to use these mechanisms, and the functions
for converting between them.

   The behavior of the functions in this chapter is affected by the
current locale for character classification--the `LC_CTYPE' category;
see *Note Locale Categories::.  This choice of locale selects which
multibyte code is used, and also controls the meanings and
characteristics of wide character codes.

* Menu:

* Extended Char Intro::         Multibyte codes versus wide characters.
* Locales and Extended Chars::  The locale selects the character codes.
* Multibyte Char Intro::        How multibyte codes are represented.
* Wide Char Intro::             How wide characters are represented.
* Wide String Conversion::      Converting wide strings to multibyte code
                                 and vice versa.
* Length of Char::              how many bytes make up one multibyte char.
* Converting One Char::         Converting a string character by character.
* Example of Conversion::       Example showing why converting
				 one character at a time may be useful.
* Shift State::                 Multibyte codes with "shift characters".


File: libc.info,  Node: Extended Char Intro,  Next: Locales and Extended Chars,  Up: Extended Characters

Introduction to Extended Characters
===================================

   You can represent extended characters in either of two ways:

   * As "multibyte characters" which can be embedded in an ordinary
     string, an array of `char' objects.  Their advantage is that many
     programs and operating systems can handle occasional multibyte
     characters scattered among ordinary ASCII characters, without any
     change.

   * As "wide characters", which are like ordinary characters except
     that they occupy more bits.  The wide character data type,
     `wchar_t', has a range large enough to hold extended character
     codes as well as old-fashioned ASCII codes.

     An advantage of wide characters is that each character is a single
     data object, just like ordinary ASCII characters.  There are a few
     disadvantages:

        * Each existing program must be modified and recompiled to make
          it use wide characters.

        * Files of wide characters cannot be read by programs that
          expect ordinary characters.

   Typically, you use the multibyte character representation as part of
the external program interface, such as reading or writing text to
files.  However, it's usually easier to perform internal manipulations
on strings containing extended characters on arrays of `wchar_t'
objects, since the uniform representation makes most editing operations
easier.  If you do use multibyte characters for files and wide
characters for internal operations, you need to convert between them
when you read and write data.

   If your system supports extended characters, then it supports them
both as multibyte characters and as wide characters.  The library
includes functions you can use to convert between the two
representations.  These functions are described in this chapter.


File: libc.info,  Node: Locales and Extended Chars,  Next: Multibyte Char Intro,  Prev: Extended Char Intro,  Up: Extended Characters

Locales and Extended Characters
===============================

   A computer system can support more than one multibyte character code,
and more than one wide character code.  The user controls the choice of
codes through the current locale for character classification (*note
Locales::.).  Each locale specifies a particular multibyte character
code and a particular wide character code.  The choice of locale
influences the behavior of the conversion functions in the library.

   Some locales support neither wide characters nor nontrivial multibyte
characters.  In these locales, the library conversion functions still
work, even though what they do is basically trivial.

   If you select a new locale for character classification, the internal
shift state maintained by these functions can become confused, so it's
not a good idea to change the locale while you are in the middle of
processing a string.


File: libc.info,  Node: Multibyte Char Intro,  Next: Wide Char Intro,  Prev: Locales and Extended Chars,  Up: Extended Characters

Multibyte Characters
====================

   In the ordinary ASCII code, a sequence of characters is a sequence of
bytes, and each character is one byte.  This is very simple, but allows
for only 256 distinct characters.

   In a "multibyte character code", a sequence of characters is a
sequence of bytes, but each character may occupy one or more consecutive
bytes of the sequence.

   There are many different ways of designing a multibyte character
code; different systems use different codes.  To specify a particular
code means designating the "basic" byte sequences--those which represent
a single character--and what characters they stand for.  A code that a
computer can actually use must have a finite number of these basic
sequences, and typically none of them is more than a few characters
long.

   These sequences need not all have the same length.  In fact, many of
them are just one byte long.  Because the basic ASCII characters in the
range from `0' to `0177' are so important, they stand for themselves in
all multibyte character codes.  That is to say, a byte whose value is
`0' through `0177' is always a character in itself.  The characters
which are more than one byte must always start with a byte in the range
from `0200' through `0377'.

   The byte value `0' can be used to terminate a string, just as it is
often used in a string of ASCII characters.

   Specifying the basic byte sequences that represent single characters
automatically gives meanings to many longer byte sequences, as more than
one character.  For example, if the two byte sequence `0205 049' stands
for the Greek letter alpha, then `0205 049 065' must stand for an alpha
followed by an `A' (ASCII code 065), and `0205 049 0205 049' must stand
for two alphas in a row.

   If any byte sequence can have more than one meaning as a sequence of
characters, then the multibyte code is ambiguous--and no good.  The
codes that systems actually use are all unambiguous.

   In most codes, there are certain sequences of bytes that have no
meaning as a character or characters.  These are called "invalid".

   The simplest possible multibyte code is a trivial one:

     The basic sequences consist of single bytes.

   This particular code is equivalent to not using multibyte characters
at all.  It has no invalid sequences.  But it can handle only 256
different characters.

   Here is another possible code which can handle 9376 different
characters:

     The basic sequences consist of

        * single bytes with values in the range `0' through `0237'.

        * two-byte sequences, in which both of the bytes have values in
          the range from `0240' through `0377'.

This code or a similar one is used on some systems to represent Japanese
characters.  The invalid sequences are those which consist of an odd
number of consecutive bytes in the range from `0240' through `0377'.

   Here is another multibyte code which can handle more distinct
extended characters--in fact, almost thirty million:

     The basic sequences consist of

        * single bytes with values in the range `0' through `0177'.

        * sequences of up to four bytes in which the first byte is in
          the range from `0200' through `0237', and the remaining bytes
          are in the range from `0240' through `0377'.

In this code, any sequence that starts with a byte in the range from
`0240' through `0377' is invalid.

   And here is another variant which has the advantage that removing the
last byte or bytes from a valid character can never produce another
valid character.  (This property is convenient when you want to search
strings for particular characters.)

     The basic sequences consist of

        * single bytes with values in the range `0' through `0177'.

        * two-byte sequences in which the first byte is in the range
          from `0200' through `0207', and the second byte is in the
          range from `0240' through `0377'.

        * three-byte sequences in which the first byte is in the range
          from `0210' through `0217', and the other bytes are in the
          range from `0240' through `0377'.

        * four-byte sequences in which the first byte is in the range
          from `0220' through `0227', and the other bytes are in the
          range from `0240' through `0377'.

The list of invalid sequences for this code is long and not worth
stating in full; examples of invalid sequences include `0240' and `0220
0300 065'.

   The number of *possible* multibyte codes is astronomical.  But a
given computer system will support at most a few different codes.  (One
of these codes may allow for thousands of different characters.)
Another computer system may support a completely different code.  The
library facilities described in this chapter are helpful because they
package up the knowledge of the details of a particular computer
system's multibyte code, so your programs need not know them.

   You can use special standard macros to find out the maximum possible
number of bytes in a character in the currently selected multibyte code
with `MB_CUR_MAX', and the maximum for *any* multibyte code supported
on your computer with `MB_LEN_MAX'.

 - Macro: int MB_LEN_MAX
     This is the maximum length of a multibyte character for any
     supported locale.  It is defined in `limits.h'.

 - Macro: int MB_CUR_MAX
     This macro expands into a (possibly non-constant) positive integer
     expression that is the maximum number of bytes in a multibyte
     character in the current locale.  The value is never greater than
     `MB_LEN_MAX'.

     `MB_CUR_MAX' is defined in `stdlib.h'.

   Normally, each basic sequence in a particular character code stands
for one character, the same character regardless of context.  Some
multibyte character codes have a concept of "shift state"; certain
codes, called "shift sequences", change to a different shift state, and
the meaning of some or all basic sequences varies according to the
current shift state.  In fact, the set of basic sequences might even be
different depending on the current shift state.  *Note Shift State::,
for more information on handling this sort of code.

   What happens if you try to pass a string containing multibyte
characters to a function that doesn't know about them?  Normally, such
a function treats a string as a sequence of bytes, and interprets
certain byte values specially; all other byte values are "ordinary".
As long as a multibyte character doesn't contain any of the special
byte values, the function should pass it through as if it were several
ordinary characters.

   For example, let's figure out what happens if you use multibyte
characters in a file name.  The functions such as `open' and `unlink'
that operate on file names treat the name as a sequence of byte values,
with `/' as the only special value.  Any other byte values are copied,
or compared, in sequence, and all byte values are treated alike.  Thus,
you may think of the file name as a sequence of bytes or as a string
containing multibyte characters; the same behavior makes sense equally
either way, provided no multibyte character contains a `/'.


File: libc.info,  Node: Wide Char Intro,  Next: Wide String Conversion,  Prev: Multibyte Char Intro,  Up: Extended Characters

Wide Character Introduction
===========================

   "Wide characters" are much simpler than multibyte characters.  They
are simply characters with more than eight bits, so that they have room
for more than 256 distinct codes.  The wide character data type,
`wchar_t', has a range large enough to hold extended character codes as
well as old-fashioned ASCII codes.

   An advantage of wide characters is that each character is a single
data object, just like ordinary ASCII characters.  Wide characters also
have some disadvantages:

   * A program must be modified and recompiled in order to use wide
     characters at all.

   * Files of wide characters cannot be read by programs that expect
     ordinary characters.

   Wide character values `0' through `0177' are always identical in
meaning to the ASCII character codes.  The wide character value zero is
often used to terminate a string of wide characters, just as a single
byte with value zero often terminates a string of ordinary characters.

 - Data Type: wchar_t
     This is the "wide character" type, an integer type whose range is
     large enough to represent all distinct values in any extended
     character set in the supported locales.  *Note Locales::, for more
     information about locales.  This type is defined in the header
     file `stddef.h'.

   If your system supports extended characters, then each extended
character has both a wide character code and a corresponding multibyte
basic sequence.

   In this chapter, the term "code" is used to refer to a single
extended character object to emphasize the distinction from the `char'
data type.


File: libc.info,  Node: Wide String Conversion,  Next: Length of Char,  Prev: Wide Char Intro,  Up: Extended Characters

Conversion of Extended Strings
==============================

   The `mbstowcs' function converts a string of multibyte characters to
a wide character array.  The `wcstombs' function does the reverse.
These functions are declared in the header file `stdlib.h'.

   In most programs, these functions are the only ones you need for
conversion between wide strings and multibyte character strings.  But
they have limitations.  If your data is not null-terminated or is not
all in core at once, you probably need to use the low-level conversion
functions to convert one character at a time.  *Note Converting One
Char::.

 - Function: size_t mbstowcs (wchar_t *WSTRING, const char *STRING,
          size_t SIZE)
     The `mbstowcs' ("multibyte string to wide character string")
     function converts the null-terminated string of multibyte
     characters STRING to an array of wide character codes, storing not
     more than SIZE wide characters into the array beginning at WSTRING.
     The terminating null character counts towards the size, so if SIZE
     is less than the actual number of wide characters resulting from
     STRING, no terminating null character is stored.

     The conversion of characters from STRING begins in the initial
     shift state.

     If an invalid multibyte character sequence is found, this function
     returns a value of `-1'.  Otherwise, it returns the number of wide
     characters stored in the array WSTRING.  This number does not
     include the terminating null character, which is present if the
     number is less than SIZE.

     Here is an example showing how to convert a string of multibyte
     characters, allocating enough space for the result.

          wchar_t *
          mbstowcs_alloc (const char *string)
          {
            size_t size = strlen (string) + 1;
            wchar_t *buf = xmalloc (size * sizeof (wchar_t));
          
            size = mbstowcs (buf, string, size);
            if (size == (size_t) -1)
              return NULL;
            buf = xrealloc (buf, (size + 1) * sizeof (wchar_t));
            return buf;
          }


 - Function: size_t wcstombs (char *STRING, const wchar_t WSTRING,
          size_t SIZE)
     The `wcstombs' ("wide character string to multibyte string")
     function converts the null-terminated wide character array WSTRING
     into a string containing multibyte characters, storing not more
     than SIZE bytes starting at STRING, followed by a terminating null
     character if there is room.  The conversion of characters begins in
     the initial shift state.

     The terminating null character counts towards the size, so if SIZE
     is less than or equal to the number of bytes needed in WSTRING, no
     terminating null character is stored.

     If a code that does not correspond to a valid multibyte character
     is found, this function returns a value of `-1'.  Otherwise, the
     return value is the number of bytes stored in the array STRING.
     This number does not include the terminating null character, which
     is present if the number is less than SIZE.


File: libc.info,  Node: Length of Char,  Next: Converting One Char,  Prev: Wide String Conversion,  Up: Extended Characters

Multibyte Character Length
==========================

   This section describes how to scan a string containing multibyte
characters, one character at a time.  The difficulty in doing this is
to know how many bytes each character contains.  Your program can use
`mblen' to find this out.

 - Function: int mblen (const char *STRING, size_t SIZE)
     The `mblen' function with a non-null STRING argument returns the
     number of bytes that make up the multibyte character beginning at
     STRING, never examining more than SIZE bytes.  (The idea is to
     supply for SIZE the number of bytes of data you have in hand.)

     The return value of `mblen' distinguishes three possibilities: the
     first SIZE bytes at STRING start with valid multibyte character,
     they start with an invalid byte sequence or just part of a
     character, or STRING points to an empty string (a null character).

     For a valid multibyte character, `mblen' returns the number of
     bytes in that character (always at least `1', and never more than
     SIZE).  For an invalid byte sequence, `mblen' returns `-1'.  For
     an empty string, it returns `0'.

     If the multibyte character code uses shift characters, then `mblen'
     maintains and updates a shift state as it scans.  If you call
     `mblen' with a null pointer for STRING, that initializes the shift
     state to its standard initial value.  It also returns nonzero if
     the multibyte character code in use actually has a shift state.
     *Note Shift State::.

     The function `mblen' is declared in `stdlib.h'.


File: libc.info,  Node: Converting One Char,  Next: Example of Conversion,  Prev: Length of Char,  Up: Extended Characters

Conversion of Extended Characters One by One
============================================

   You can convert multibyte characters one at a time to wide characters
with the `mbtowc' function.  The `wctomb' function does the reverse.
These functions are declared in `stdlib.h'.

 - Function: int mbtowc (wchar_t *RESULT, const char *STRING, size_t
          SIZE)
     The `mbtowc' ("multibyte to wide character") function when called
     with non-null STRING converts the first multibyte character
     beginning at STRING to its corresponding wide character code.  It
     stores the result in `*RESULT'.

     `mbtowc' never examines more than SIZE bytes.  (The idea is to
     supply for SIZE the number of bytes of data you have in hand.)

     `mbtowc' with non-null STRING distinguishes three possibilities:
     the first SIZE bytes at STRING start with valid multibyte
     character, they start with an invalid byte sequence or just part
     of a character, or STRING points to an empty string (a null
     character).

     For a valid multibyte character, `mbtowc' converts it to a wide
     character and stores that in `*RESULT', and returns the number of
     bytes in that character (always at least `1', and never more than
     SIZE).

     For an invalid byte sequence, `mbtowc' returns `-1'.  For an empty
     string, it returns `0', also storing `0' in `*RESULT'.

     If the multibyte character code uses shift characters, then
     `mbtowc' maintains and updates a shift state as it scans.  If you
     call `mbtowc' with a null pointer for STRING, that initializes the
     shift state to its standard initial value.  It also returns
     nonzero if the multibyte character code in use actually has a
     shift state.  *Note Shift State::.

 - Function: int wctomb (char *STRING, wchar_t WCHAR)
     The `wctomb' ("wide character to multibyte") function converts the
     wide character code WCHAR to its corresponding multibyte character
     sequence, and stores the result in bytes starting at STRING.  At
     most `MB_CUR_MAX' characters are stored.

     `wctomb' with non-null STRING distinguishes three possibilities
     for WCHAR: a valid wide character code (one that can be translated
     to a multibyte character), an invalid code, and `0'.

     Given a valid code, `wctomb' converts it to a multibyte character,
     storing the bytes starting at STRING.  Then it returns the number
     of bytes in that character (always at least `1', and never more
     than `MB_CUR_MAX').

     If WCHAR is an invalid wide character code, `wctomb' returns `-1'.
     If WCHAR is `0', it returns `0', also storing `0' in `*STRING'.

     If the multibyte character code uses shift characters, then
     `wctomb' maintains and updates a shift state as it scans.  If you
     call `wctomb' with a null pointer for STRING, that initializes the
     shift state to its standard initial value.  It also returns
     nonzero if the multibyte character code in use actually has a
     shift state.  *Note Shift State::.

     Calling this function with a WCHAR argument of zero when STRING is
     not null has the side-effect of reinitializing the stored shift
     state *as well as* storing the multibyte character `0' and
     returning `0'.


File: libc.info,  Node: Example of Conversion,  Next: Shift State,  Prev: Converting One Char,  Up: Extended Characters

Character-by-Character Conversion Example
=========================================

   Here is an example that reads multibyte character text from
descriptor `input' and writes the corresponding wide characters to
descriptor `output'.  We need to convert characters one by one for this
example because `mbstowcs' is unable to continue past a null character,
and cannot cope with an apparently invalid partial character by reading
more input.

     int
     file_mbstowcs (int input, int output)
     {
       char buffer[BUFSIZ + MB_LEN_MAX];
       int filled = 0;
       int eof = 0;
     
       while (!eof)
         {
           int nread;
           int nwrite;
           char *inp = buffer;
           wchar_t outbuf[BUFSIZ];
           wchar_t *outp = outbuf;
     
           /* Fill up the buffer from the input file.  */
           nread = read (input, buffer + filled, BUFSIZ);
           if (nread < 0)
             {
               perror ("read");
               return 0;
             }
           /* If we reach end of file, make a note to read no more. */
           if (nread == 0)
             eof = 1;
     
           /* `filled' is now the number of bytes in `buffer'. */
           filled += nread;
     
           /* Convert those bytes to wide characters--as many as we can. */
           while (1)
             {
               int thislen = mbtowc (outp, inp, filled);
               /* Stop converting at invalid character;
                  this can mean we have read just the first part
                  of a valid character.  */
               if (thislen == -1)
                 break;
               /* Treat null character like any other,
                  but also reset shift state. */
               if (thislen == 0) {
                 thislen = 1;
                 mbtowc (NULL, NULL, 0);
               }
               /* Advance past this character. */
               inp += thislen;
               filled -= thislen;
               outp++;
             }
     
           /* Write the wide characters we just made.  */
           nwrite = write (output, outbuf,
                           (outp - outbuf) * sizeof (wchar_t));
           if (nwrite < 0)
             {
               perror ("write");
               return 0;
             }
     
           /* See if we have a *real* invalid character. */
           if ((eof && filled > 0) || filled >= MB_CUR_MAX)
             {
               error ("invalid multibyte character");
               return 0;
             }
     
           /* If any characters must be carried forward,
              put them at the beginning of `buffer'. */
           if (filled > 0)
             memcpy (inp, buffer, filled);
           }
         }
     
       return 1;
     }


File: libc.info,  Node: Shift State,  Prev: Example of Conversion,  Up: Extended Characters

Multibyte Codes Using Shift Sequences
=====================================

   In some multibyte character codes, the *meaning* of any particular
byte sequence is not fixed; it depends on what other sequences have come
earlier in the same string.  Typically there are just a few sequences
that can change the meaning of other sequences; these few are called
"shift sequences" and we say that they set the "shift state" for other
sequences that follow.

   To illustrate shift state and shift sequences, suppose we decide that
the sequence `0200' (just one byte) enters Japanese mode, in which
pairs of bytes in the range from `0240' to `0377' are single
characters, while `0201' enters Latin-1 mode, in which single bytes in
the range from `0240' to `0377' are characters, and interpreted
according to the ISO Latin-1 character set.  This is a multibyte code
which has two alternative shift states ("Japanese mode" and "Latin-1
mode"), and two shift sequences that specify particular shift states.

   When the multibyte character code in use has shift states, then
`mblen', `mbtowc' and `wctomb' must maintain and update the current
shift state as they scan the string.  To make this work properly, you
must follow these rules:

   * Before starting to scan a string, call the function with a null
     pointer for the multibyte character address--for example, `mblen
     (NULL, 0)'.  This initializes the shift state to its standard
     initial value.

   * Scan the string one character at a time, in order.  Do not "back
     up" and rescan characters already scanned, and do not intersperse
     the processing of different strings.

   Here is an example of using `mblen' following these rules:

     void
     scan_string (char *s)
     {
       int length = strlen (s);
     
       /* Initialize shift state. */
       mblen (NULL, 0);
     
       while (1)
         {
           int thischar = mblen (s, length);
           /* Deal with end of string and invalid characters. */
           if (thischar == 0)
             break;
           if (thischar == -1)
             {
               error ("invalid multibyte character");
               break;
             }
           /* Advance past this character. */
           s += thischar;
           length -= thischar;
         }
     }

   The functions `mblen', `mbtowc' and `wctomb' are not reentrant when
using a multibyte code that uses a shift state.  However, no other
library functions call these functions, so you don't have to worry that
the shift state will be changed mysteriously.


File: libc.info,  Node: Locales,  Next: Searching and Sorting,  Prev: Extended Characters,  Up: Top

Locales and Internationalization
********************************

   Different countries and cultures have varying conventions for how to
communicate.  These conventions range from very simple ones, such as the
format for representing dates and times, to very complex ones, such as
the language spoken.

   "Internationalization" of software means programming it to be able
to adapt to the user's favorite conventions.  In ANSI C,
internationalization works by means of "locales".  Each locale
specifies a collection of conventions, one convention for each purpose.
The user chooses a set of conventions by specifying a locale (via
environment variables).

   All programs inherit the chosen locale as part of their environment.
Provided the programs are written to obey the choice of locale, they
will follow the conventions preferred by the user.

* Menu:

* Effects of Locale::           Actions affected by the choice of
                                 locale.
* Choosing Locale::             How the user specifies a locale.
* Locale Categories::           Different purposes for which you can
                                 select a locale.
* Setting the Locale::          How a program specifies the locale
                                 with library functions.
* Standard Locales::            Locale names available on all systems.
* Numeric Formatting::          How to format numbers according to the
                                 chosen locale.


File: libc.info,  Node: Effects of Locale,  Next: Choosing Locale,  Up: Locales

What Effects a Locale Has
=========================

   Each locale specifies conventions for several purposes, including the
following:

   * What multibyte character sequences are valid, and how they are
     interpreted (*note Extended Characters::.).

   * Classification of which characters in the local character set are
     considered alphabetic, and upper- and lower-case conversion
     conventions (*note Character Handling::.).

   * The collating sequence for the local language and character set
     (*note Collation Functions::.).

   * Formatting of numbers and currency amounts (*note Numeric
     Formatting::.).

   * Formatting of dates and times (*note Formatting Date and Time::.).

   * What language to use for output, including error messages.  (The C
     library doesn't yet help you implement this.)

   * What language to use for user answers to yes-or-no questions.

   * What language to use for more complex user input.  (The C library
     doesn't yet help you implement this.)

   Some aspects of adapting to the specified locale are handled
automatically by the library subroutines.  For example, all your program
needs to do in order to use the collating sequence of the chosen locale
is to use `strcoll' or `strxfrm' to compare strings.

   Other aspects of locales are beyond the comprehension of the library.
For example, the library can't automatically translate your program's
output messages into other languages.  The only way you can support
output in the user's favorite language is to program this more or less
by hand.  (Eventually, we hope to provide facilities to make this
easier.)

   This chapter discusses the mechanism by which you can modify the
current locale.  The effects of the current locale on specific library
functions are discussed in more detail in the descriptions of those
functions.


File: libc.info,  Node: Choosing Locale,  Next: Locale Categories,  Prev: Effects of Locale,  Up: Locales

Choosing a Locale
=================

   The simplest way for the user to choose a locale is to set the
environment variable `LANG'.  This specifies a single locale to use for
all purposes.  For example, a user could specify a hypothetical locale
named `espana-castellano' to use the standard conventions of most of
Spain.

   The set of locales supported depends on the operating system you are
using, and so do their names.  We can't make any promises about what
locales will exist, except for one standard locale called `C' or
`POSIX'.

   A user also has the option of specifying different locales for
different purposes--in effect, choosing a mixture of multiple locales.

   For example, the user might specify the locale `espana-castellano'
for most purposes, but specify the locale `usa-english' for currency
formatting.  This might make sense if the user is a Spanish-speaking
American, working in Spanish, but representing monetary amounts in US
dollars.

   Note that both locales `espana-castellano' and `usa-english', like
all locales, would include conventions for all of the purposes to which
locales apply.  However, the user can choose to use each locale for a
particular subset of those purposes.


File: libc.info,  Node: Locale Categories,  Next: Setting the Locale,  Prev: Choosing Locale,  Up: Locales

Categories of Activities that Locales Affect
============================================

   The purposes that locales serve are grouped into "categories", so
that a user or a program can choose the locale for each category
independently.  Here is a table of categories; each name is both an
environment variable that a user can set, and a macro name that you can
use as an argument to `setlocale'.

`LC_COLLATE'
     This category applies to collation of strings (functions `strcoll'
     and `strxfrm'); see *Note Collation Functions::.

`LC_CTYPE'
     This category applies to classification and conversion of
     characters, and to multibyte and wide characters; see *Note
     Character Handling:: and *Note Extended Characters::.

`LC_MONETARY'
     This category applies to formatting monetary values; see *Note
     Numeric Formatting::.

`LC_NUMERIC'
     This category applies to formatting numeric values that are not
     monetary; see *Note Numeric Formatting::.

`LC_TIME'
     This category applies to formatting date and time values; see
     *Note Formatting Date and Time::.

`LC_ALL'
     This is not an environment variable; it is only a macro that you
     can use with `setlocale' to set a single locale for all purposes.

`LANG'
     If this environment variable is defined, its value specifies the
     locale to use for all purposes except as overridden by the
     variables above.


File: libc.info,  Node: Setting the Locale,  Next: Standard Locales,  Prev: Locale Categories,  Up: Locales

How Programs Set the Locale
===========================

   A C program inherits its locale environment variables when it starts
up.  This happens automatically.  However, these variables do not
automatically control the locale used by the library functions, because
ANSI C says that all programs start by default in the standard `C'
locale.  To use the locales specified by the environment, you must call
`setlocale'.  Call it as follows:

     setlocale (LC_ALL, "");

to select a locale based on the appropriate environment variables.

   You can also use `setlocale' to specify a particular locale, for
general use or for a specific category.

   The symbols in this section are defined in the header file
`locale.h'.

 - Function: char * setlocale (int CATEGORY, const char *LOCALE)
     The function `setlocale' sets the current locale for category
     CATEGORY to LOCALE.

     If CATEGORY is `LC_ALL', this specifies the locale for all
     purposes.  The other possible values of CATEGORY specify an
     individual purpose (*note Locale Categories::.).

     You can also use this function to find out the current locale by
     passing a null pointer as the LOCALE argument.  In this case,
     `setlocale' returns a string that is the name of the locale
     currently selected for category CATEGORY.

     The string returned by `setlocale' can be overwritten by subsequent
     calls, so you should make a copy of the string (*note Copying and
     Concatenation::.) if you want to save it past any further calls to
     `setlocale'.  (The standard library is guaranteed never to call
     `setlocale' itself.)

     You should not modify the string returned by `setlocale'.  It
     might be the same string that was passed as an argument in a
     previous call to `setlocale'.

     When you read the current locale for category `LC_ALL', the value
     encodes the entire combination of selected locales for all
     categories.  In this case, the value is not just a single locale
     name.  In fact, we don't make any promises about what it looks
     like.  But if you specify the same "locale name" with `LC_ALL' in
     a subsequent call to `setlocale', it restores the same combination
     of locale selections.

     When the LOCALE argument is not a null pointer, the string returned
     by `setlocale' reflects the newly modified locale.

     If you specify an empty string for LOCALE, this means to read the
     appropriate environment variable and use its value to select the
     locale for CATEGORY.

     If you specify an invalid locale name, `setlocale' returns a null
     pointer and leaves the current locale unchanged.

   Here is an example showing how you might use `setlocale' to
temporarily switch to a new locale.

     #include <stddef.h>
     #include <locale.h>
     #include <stdlib.h>
     #include <string.h>
     
     void
     with_other_locale (char *new_locale,
                        void (*subroutine) (int),
                        int argument)
     {
       char *old_locale, *saved_locale;
     
       /* Get the name of the current locale.  */
       old_locale = setlocale (LC_ALL, NULL);
     
       /* Copy the name so it won't be clobbered by `setlocale'. */
       saved_locale = strdup (old_locale);
       if (old_locale == NULL)
         fatal ("Out of memory");
     
       /* Now change the locale and do some stuff with it. */
       setlocale (LC_ALL, new_locale);
       (*subroutine) (argument);
     
       /* Restore the original locale. */
       setlocale (LC_ALL, saved_locale);
       free (saved_locale);
     }

   *Portability Note:* Some ANSI C systems may define additional locale
categories.  For portability, assume that any symbol beginning with
`LC_' might be defined in `locale.h'.


File: libc.info,  Node: Standard Locales,  Next: Numeric Formatting,  Prev: Setting the Locale,  Up: Locales

Standard Locales
================

   The only locale names you can count on finding on all operating
systems are these three standard ones:

`"C"'
     This is the standard C locale.  The attributes and behavior it
     provides are specified in the ANSI C standard.  When your program
     starts up, it initially uses this locale by default.

`"POSIX"'
     This is the standard POSIX locale.  Currently, it is an alias for
     the standard C locale.

`""'
     The empty name says to select a locale based on environment
     variables.  *Note Locale Categories::.

   Defining and installing named locales is normally a responsibility of
the system administrator at your site (or the person who installed the
GNU C library).  Some systems may allow users to create locales, but we
don't discuss that here.

   If your program needs to use something other than the `C' locale, it
will be more portable if you use whatever locale the user specifies
with the environment, rather than trying to specify some non-standard
locale explicitly by name.  Remember, different machines might have
different sets of locales installed.


File: libc.info,  Node: Numeric Formatting,  Prev: Standard Locales,  Up: Locales

Numeric Formatting
==================

   When you want to format a number or a currency amount using the
conventions of the current locale, you can use the function
`localeconv' to get the data on how to do it.  The function
`localeconv' is declared in the header file `locale.h'.

 - Function: struct lconv * localeconv (void)
     The `localeconv' function returns a pointer to a structure whose
     components contain information about how numeric and monetary
     values should be formatted in the current locale.

     You shouldn't modify the structure or its contents.  The structure
     might be overwritten by subsequent calls to `localeconv', or by
     calls to `setlocale', but no other function in the library
     overwrites this value.

 - Data Type: struct lconv
     This is the data type of the value returned by `localeconv'.

   If a member of the structure `struct lconv' has type `char', and the
value is `CHAR_MAX', it means that the current locale has no value for
that parameter.

* Menu:

* General Numeric::             Parameters for formatting numbers and
                                 currency amounts.
* Currency Symbol::             How to print the symbol that identifies an
                                 amount of money (e.g. `$').
* Sign of Money Amount::        How to print the (positive or negative) sign
                                 for a monetary amount, if one exists.

