Return-Path: <krab@iesd.auc.dk>
Date: Wed, 24 Feb 1993 19:33:38 +0100
From: Kresten Krab Thorup <krab@iesd.auc.dk>
To: gnu-objc@gnu.ai.mit.edu
Subject: Introducing class Class
Cc: krab@iesd.auc.dk, rms@gnu.ai.mit.edu, burchard@geom.umn.edu

Hi again...

I am considering the possibility to introduce a class Class in
objective C -- i.e. the class of class Objects, somewhat like it is
known in Smalltalk.

The benefits we would get from this was that all the `highlevel'
functionality of the runtime could actually be coded in objective C --
that is, most of the `objc_<doSomething>()' functions could be
avoided.  In my opinion these are ugly!  For instance, I would prefer:

	[<SomeClass> setVersion: XX];
over
	objc_setVersion(<SomeClass>, XX);

Besides, this would make it considerably simpler to understand the
entire concept of classes and metaclasses as objects existing at
runtime. 

I suppose you're confused -- objc does not allow for descriptions of
classes like that!  The classes and metaclasses are generated by the
compiler!  What do you mean!?

The trick is to introduce the class Class, as a subclass of `Object'.
Then as the runtime is being initialized, install the `class object
for class Class' as the `superclass for the metaclass of class Object.'
The class hierachy then comes out as the illustration below.. It is
the `snaky' link which is additionally installed by the runtime.
Aditionally, the `isa' link for `meta Object' should point to `meta
Class'.   

                        ,=======.                                 
                       ||       \/                                
           [Object]----||-->[meta Object]--.                            
              ||       ||        ||        |                             
              ||       ||        ||        |                             
              \/       ||        \/        |                             
            [Class]----||--->[meta Class]<-'
              ||       ||
               `======='                                          
                             Ledgend:  A ==> B     B inherits A
                                       A --> B     A is instance of B


This allows for the most basic factory methods now in class Object to
be implemented as instance methods in class Class.  But!  In order to
conform to the objective C `standard' (did I say standard?) class
Object must implement the factory methods `currently' implemented there
-- no problem, we will simply make them `subclassResponsibility's and
really implement them in class Class.

Indeed this opens the possibility that part of the runtime is coded in
objective C, but the introduction of class Class does not nessecarily
cost anything for the runtime, since we could still just implement the
entire thing in C.  However, the factory methods of class Object which
already implement some kind of runtime interface could be placed in
class Class at no additional cost.

The following is the interface for this new class Class.  The methods
from class Object which are related to class manipulation are put in a
special category (Class) along with class Class.  In order to make the
thing consistent, I renamed `name' to `className', and class Class now
implements `name' in the strightforward meaning, and also `super'
which just returns the super link.  

/Kresten

/*
 * The runtime installs this the class object for this class as the
 * superclass for the metaclass of class Object.  
 *
 * Instances of this class (or rather its subclasses) are generated by
 * the compiler for each class in the system.  Hence, the number, type
 * and order of instance variables should *not* be changed unless gcc
 * is updated accordingly!
 *
 */

@interface Class : Object
{
  Class*  		super_class;
  const char*        	name;
  long     		version;
  long 			info;
  long 			instance_size;
  IvarList* 		ivars;
  MethodList*		methods;
  DispatchTable*        dtable;
}

+ (BOOL)isClass;		/* allways answers NO */
- (BOOL)isClass;		/* allways answers YES */

+ (BOOL)isMetaClass;		/* allways answers YES */
- (BOOL)isMetaClass;		/* allways answers NO */

- new;				/* answer a new object */
+ new;				/* shouldNotImplement */

- alloc;			/* allocate an object */
+ alloc;			/* shouldNotImplement */

- free;				/* shouldNotImplement */

- (Class*)super;		/* answer super link (super_class) */

- (BOOL)instancesRespondsTo: (SEL)aSelector; /* do whatever... */

- poseAs: (Class*)aClassObject;	/* do whatever... */

- (int)version;			/* set and get version */
- setVersion:(int)aVersion;

- (const char*) name;		/* the name of *this* class */

@end


/* **************************************************************
 * Add Class operations to class Object 
 * ************************************************************** */

@interface Object (Class)

- (BOOL)isClass;		/* allways answers NO */
- (BOOL)isMetaClass;		/* allways answers NO */

+ new;				/* subclassResponsibility */
+ alloc;			/* subclassResponsibility */

- init;				/* user level initialize */

+ free;				/* shouldNotImplement */
- free;				/* actually free it */

- copy;				/* [self shallowCopy] */
- shallowCopy;			/* (*_objc_copy)(self) */
- deepCopy;			/* [[self shallowCopy] deep] */
- deep;				/* just return self */

- (Class*)class;		/* isa */
- (Class*)superClass;		/* [isa super] */

- (const char*)className;	/* [isa name] */
- self;				/* self */

- (BOOL)isKindOf: (Class*)aClassObject;
- (BOOL)isMemeberOf: (Class*)aClassObject;
- (BOOL)isKindOfGivenName: (const char*)aClassName;
- (BOOL)isMemberOfGivenName: (const char*)aClassName;

+ (IMP)methodFor: (SEL)aSelector; /* subclassResponsibility */
+ (BOOL)instancesRespondsTo: (SEL)aSelector; /* subclassResponsibility */
- (BOOL)respondsTo: (SEL)aSelector; /* [isa instancesRespondsTo: aSel] */

- perform: (SEL)aSelector;	/* (*[isa methodFor: aSelector])() */
- perform: (SEL)aSelector with: anObject; /* ditto with arg */

+ poseAs: (Class*)aClassObject;	/* subclassResponsibility */

+ (long)version;		/* subclassResponsibility */
+ setVersion:(long)aVersion;	/* subclassResponsibility */

@end




Return-Path: <Steve_Naroff@NeXT.COM>
From: Steve_Naroff@NeXT.COM (Steve Naroff)
Date: Wed, 24 Feb 93 11:19:44 -0800
To: Kresten Krab Thorup <krab@iesd.auc.dk>
Subject: Re: Introducing class Class
Cc: gnu-objc@gnu.ai.mit.edu, krab@iesd.auc.dk, rms@gnu.ai.mit.edu,
        burchard@geom.umn.edu


I think this is really worthwhile (and a cleanup we have wanted to do  
for sometime now). Our newer work is described in terms of the  
language it implements (like protocols, which are described in  
Objective-C, not C). 


Protocols are "sealed" classes (ie. they can't be subclassed). I  
imagine you intend for the class Class to be sealed. I haven't  
flushed out about the implementation issues, but it would be nice to  
add state and behavior to a Class object. Obviously, this is one way  
to view class variables, as an extension of the Class object.

I hope to make time and give you more feedback on your proposal.

snaroff.

Date: Fri, 26 Feb 1993 01:13:46 +0100
From: Kresten Krab Thorup <krab@iesd.auc.dk>
To: rasmus@dannug.dk
Cc: gnu-objc@prep.ai.mit.edu
In-Reply-To: <9302251923.AA01265@peter.dannug.dk>
Subject: Re: Class Variables

Peter Rasmussen (pra@iesd.auc.dk) writes: 
>If class variables were to be introduced into the GNU Objective-C  
>system object system, then things would be different. Then they would  
>be inherited by subclasses and their definition would be relevant to
>place into the @interface def. 

This would fit nicely into the idea of a class Class.  class Class
will contain the `default' attributes of a class object as instance
variables.  These are really class variables -- it does make sense to
say MyClass->super_class, and hence the concept is already there.
Now, additionally introduced class variables are simply appended to
the layout of a class object, exactly as the case is for instances.
The only fuss is to implement it, and agree on some syntax.
Personally I like the `+' and optional `-' in front of variable
declarations.

/Kresten

Date: Fri, 26 Feb 1993 01:48:00 +0100
From: Kresten Krab Thorup <krab@iesd.auc.dk>
To: Bruce Nilo <bruce@ictv.com>
In-Reply-To: <199302252000.AA00891@taos.ictv.com>
Subject: Re: Introducing class Class
Cc: krab@iesd.auc.dk, gnu-objc@gnu.ai.mit.edu

Bruce Nilo writes:
>Ideally different meta class objects could be introduced which would  
>enable one to define different semantics to various aspects of the  
>runtime. If at all possible it would be great if you did not have to  
>seal the class Class.

In order to be able to subclass class Class meaningfully, I think
there should be introduced completely new language mechanisms.  To me
it is fine if such subclassing is the job of the compiler (i.e.
metaclasses for ordinary classes would be subclasses of class Class)

>For example, I would love to be able to create a meta class whose  
>runtime access to instance variables could be modified to support  
>versioning and/or persistence. Or perhaps the default method dispatch  
>could be overriden to provide some kind of rudimentary method  
>combination as is required by an application or a family of  
>applications.

For the matter of method dispatch it could be meaningfull, but this
could simply be introduced by having a convention about a specific
fatory method name [MyClass methodFor: sSelector] which is used in the
dispatcher.   During normal usage, the dispatcher could be statically
bound to that factory method (defined in class Class perhaps) but if
it is redefined somewhere we could hadle this specially.

>Issues relating to default runtime performance versus refined runtime  
>performance would have to be addressed. Does your idea support this  
>notion of adapting the runtime programmatically? If so what aspects  
>do you envision as being customizable? Would it be too hard to do  
>this and have a fast default runtime? Does the idea sound at all  
>appealing?

Ideally the messenger should be expanded inline, but perhaps with an
escape to an alternative messenger... Somewhat like:

   inline IMP  
   objc_msgSend (id receiver, SEL sel)
   {
     if(objc_altMsgSend)
       return (*objc_altMsgSend)(receiver,sel);
     if(!receiver)
       receriver = nilObject;
     return sarray_get(receiver->class_pointer->dtable, (unsigned)sel);
   }  

As it is in my current experimental runtime.  This alternative
messenger could then be an entrance to an Class based message lookup
mechanism.  However, once we get forwarding up running anything is
possible without the extra hack by installing magic handlers directly
in the dispatch table.

/Kresten

