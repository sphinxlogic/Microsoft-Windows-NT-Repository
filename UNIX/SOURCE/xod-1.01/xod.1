.TH XOD 1 "October 15, 1992"
.SH NAME
xod \- X-based octal dump program
.SH SYNOPSIS
xod [options] filename
.SH DESCRIPTION
.I xod
is a program like the od(1) program, allowing you to examine binary files
in several different ways.  The data can be viewed in a variety of
fashions, based on command line switches, or menu selectable.  The default
viewing mode is hex.
.LP
On the screen, you will see the data displayed in your specified viewing
mode, with an ASCII equivalent on the right.  The ASCII on the right
shows only printable ASCII characters.  Non-printable ones are shown as
whitespace.
.LP
The screen is divided into 3 areas.  The strip along the top contains
the File button, a status area, a place for decoded binary data, and
the  byte offset (the byte offset in the file where the cursor is located).
.LP
The left side of the screen shows pushbuttons that allow you to do
several things.  The top bank of buttons allows you to chose
the data view mode (hex, octal, decimal, or ASCII).  The ASCII view mode is
like done od(1).  Small, unprintable ASCII characters are shown by their
ANSI names.  If the byte is > 127, it is shown underlined, but the value
displayed is < 127.  That is, if you see it underlined, you can assume
that it has a value > 127.
.LP
The buttons below this allow you to decode the data your cursor is
on in a variety of fashions.  Merely click the mouse on a byte in
the data area, and then click on a decode mode.  The decoded data will
be displayed at the top of the window.  If you chose to decode in float
or double, and the decoded value is a huge number, you can generally
assume that the data wasn't a real floating point number.
.LP
Moving around the decoded data can be accomplished using the PgUp, PgDn
and arrow keys, or certain vi-like or emacs equivalents.  Position the
mouse in the data area, and hit "?" to get a popup showing what keystrokes
are available to you.
.LP
Clicking the mouse on the byte offset label (upper right corner of the
window) brings up a popup, allowing you to specify an absolute byte to
go to.  The address may be supplied in hex (precede address with 0x),
octal (precede address with 0), or decimal.
.SH OPTIONS
.IP -x 10
Display data in hex
.IP -o 10
Display data in octal
.IP -d 10
Display data in decimal
.IP -a 10
Display data in ASCII.
.IP "-off n" 10
Start displaying the file at offset n.  N may be decimal, octal (begins
with 0), or hex (begins with 0x).
.IP "-odf type" 10
Set the offset display format.  This is the legend which shows byte offsets
into the data file.  The default is hex.  Type can be o (octal), d (decimal),
or h or x (hex).
.LP
After choosing a display mode on the command line (hex is the default),
there are radio buttons under the data display area which allow you to
view the data in one of 4 ways, at the click of a button.
.LP
The mouse is active over the data area.  Clicking mouse button 1
changes that byte into reverse video.
.LP
The reverse video data byte determines the starting byte for decoding.
Decoding is accomplished via clicking one of the buttons
corresponding to how you want the data decoded.
.SH AUTHOR
.I xod
was written for fast analysis of binary file data.  The Unix-supplied
.I od
wasn't good enough in many situations.  Thus,
.I xod
was born.  I couldn't find anything similar, so I wrote this.
.LP
.I xod
is built upon Paul Fox's (paul@demon.co.uk) CTW (color
terminal) widget.  This was done because CTW is very fast, and
prevented me from having to make this more difficult than it really needed
to be.  Xod was written by  RF Starr (starr@wg2.waii.com).
.SH NOTE
Before you run
.I xod,
be *sure* that the app-defaults file is  loaded somewhere where it
can be found.  The  app-defaults file is named "Xod.ad".  It should be
copied into a valid app-defaults directory, and renamed "Xod".
.LP
The key bindings are not described in the man page.  You can see what they
are by hitting "?" with the mouse in the data area.  Not shown in the
help popup are some emacs bindings.  Try them.
.SH BUGS
As noted in the CTW documentation, the CTW widget
has only been tested on a Sun.  I developed this on a 486 running Linux,
and it appears to work fine.  Note that ctw.c has been marginally enhanced.
