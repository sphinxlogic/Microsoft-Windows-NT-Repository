#!/bin/sh
# this is part 3 of a multipart archive
# do not concatenate these parts, unpack them in order with /bin/sh
# file ctw.h continued
#
CurArch=3
if test ! -r s2_seq_.tmp
then echo "Please unpack part 1 first!"
     exit 1; fi
( read Scheck
  if test "$Scheck" != $CurArch
  then echo "Please unpack part $Scheck next!"
       exit 1;
  else exit 0; fi
) < s2_seq_.tmp || exit 1
echo "x - Continuing file ctw.h"
sed 's/^X//' << 'SHAR_EOF' >> ctw.h
X	CTW_TOP_LINE,	/* Top line changed. Allow application to change */
X			/* thumb on a scrollbar.			 */
X	CTW_BUTTON_DOWN,/* Button down event.				 */
X	CTW_BUTTON_UP,	/* Button up event.				 */
X	CTW_BUTTON_MOTION,/* Button motion event.			 */
X	CTW_SELECTION,	/* User is selecting text -- tell app to not give us */
X			/* any more data.				*/
X	CTW_PASTE,	/* Received selection from owner.		*/
X	CTW_OPEN_WINDOW,/* Uniconise window.				*/
X	CTW_CLOSE_WINDOW,/* Iconise window.				*/
X	CTW_MOVE_WINDOW, /* Change window position.			*/
X	CTW_SIZE_WINDOW_PIXELS, /* Change window size.			*/
X	CTW_FRONT_WINDOW,/* Raise window.				*/
X	CTW_BACK_WINDOW,	/* Lower window.				*/
X	CTW_SIZE_WINDOW_CHARS /* Change window size.			*/
X	};
X
Xtypedef struct ctw_callback_t {
X	enum ctw_reasons	reason;
X	char			*ptr;
X	int			len;
X	int			top_line;
X	int			x, y;
X	int			width, height;
X	XEvent			*event;
X	} ctw_callback_t;
X/**********************************************************************/
X/*   Index into array of flag values.				      */
X/**********************************************************************/
Xenum ctw_flags {
X	CTW_AUTOWRAP = 0,
X	CTW_AUTOLINEFEED,
X	CTW_APPL_KEYPAD,
X	CTW_APPL_MOUSE,
X	CTW_CURSOR_KEYPAD,
X	CTW_COLOR_RESET,
X	CTW_CUT_NEWLINES,
X	CTW_DESTRUCTIVE_TABS,
X	CTW_ERASE_BLACK,
X	CTW_ESC_LITERAL,
X	CTW_FONT_SIZE,
X	CTW_LITERAL_MODE,
X	CTW_NEWLINE_GLITCH,
X	CTW_PC_CHARSET,
X	CTW_RESET,
X	CTW_SCROLLING_REGION,
X	CTW_SIZE,
X	CTW_SLOW_MODE,
X	CTW_SMOOTH_SCROLL,
X	CTW_SUN_FUNCTION_KEYS,
X	CTW_ISC_DRIVER,
X	CTW_SCO_DRIVER,
X
X	CTW_MAX_ATTR
X	};
X
X/**********************************************************************/
X/*   Following  macro  used  to  allow  compilation  with ANSI C and  */
X/*   non-ANSI C compilers automatically.			      */
X/**********************************************************************/
X# if !defined(PROTO)
X# 	if	defined(__STDC__)
X#		define	PROTO(x)	x
X#	else
X#		define	PROTO(x)	()
X#	endif
X# endif
X
X/**********************************************************************/
X/*   Add a string to be displayed including ANSI escape sequences.    */
X/**********************************************************************/
Xvoid	ctw_add_string PROTO((CtwWidget, char *, int));
X
X/**********************************************************************/
X/*   Return  line  number  at  top  of screen. Used for implementing  */
X/*   scrollable area.						      */
X/**********************************************************************/
Xint	ctw_get_top_line PROTO((CtwWidget));
X
X/**********************************************************************/
X/*   Set  the  line at the top of the display. Used for implementing  */
X/*   scrollable area.						      */
X/**********************************************************************/
Xvoid	ctw_set_top_line PROTO((CtwWidget, int));
X
X/**********************************************************************/
X/*   Function to retrieve current state of the various attributes.     */
X/**********************************************************************/
Xint	ctw_get_attributes PROTO((CtwWidget, int **, char ***));
X/**********************************************************************/
X/*   Function  to  set  attributes  current  state  of  the  various  */
X/*   attributes.						      */
X/**********************************************************************/
Xvoid	ctw_set_attributes PROTO((CtwWidget, int *));
X
X/**********************************************************************/
X/*   Tell widget to grab the contents of the selection.		      */
X/**********************************************************************/
Xvoid	ctw_get_selection PROTO((CtwWidget));
X#endif /* _Ctw_h */
SHAR_EOF
echo "File ctw.h is complete"
chmod 0644 ctw.h || echo "restore of ctw.h fails"
set `wc -c ctw.h`;Sum=$1
if test "$Sum" != "8032"
then echo original size 8032, current size $Sum;fi
echo "x - extracting ctwP.h (Text)"
sed 's/^X//' << 'SHAR_EOF' > ctwP.h &&
X/*# include <X11/copyright.h>*/
X
X/* $XConsortium: TemplateP.h,v 1.4 89/07/21 01:41:48 kit Exp $ */
X/* Copyright	Massachusetts Institute of Technology	1987, 1988 */
X
X#ifndef _CtwP_h
X#define _CtwP_h
X
X# include "ctw.h"
X/* include superclass private header file */
X#include <X11/CoreP.h>
X
X/* define unique representation types not found in <X11/StringDefs.h> */
X
X#define XtRCtwResource "CtwResource"
X
Xtypedef struct {
X/* private: */
X	int	dummy;
X} CtwClassPart;
X
Xtypedef struct _CtwClassRec {
X    CoreClassPart	core_class;
X    CtwClassPart	ctw_class;
X} CtwClassRec;
X
Xextern CtwClassRec ctwClassRec;
X
X# define	BEL		0x07
X# define	ESC		0x1b
X# define	XON		('q' & 0x1f)
X# define	XOFF		('s' & 0x1f)
X
X# define	MAX_ESCBUF	128
X
X/**********************************************************************/
X/*   Structure containing stats.				      */
X/**********************************************************************/
X# define COLLECT_STATS	1
X# if COLLECT_STATS
Xstruct stats {
X	unsigned long	lines_scrolled;
X	unsigned long	lines_jumped;
X	unsigned long	scroll_ups;
X	} ctw_stats;
X# endif
X
X/**********************************************************************/
X/*   Definitions for the multi-click code.			      */
X/**********************************************************************/
X# define	CLICK_CHAR	0
X# define	CLICK_WORD	1
X# define	CLICK_LINE	2
X
X/**********************************************************************/
X/*   Define  a  'byte'. A byte represents a character on the screen.  */
X/*   Its  4-bytes  wide containing an 8-bit character, plus a 'font'  */
X/*   indicator.   This  is  used  to  indicate  whether  we  have  a  */
X/*   line-drawing  character  at that position. Another byte is used  */
X/*   to   encode  color  information.  One  more  byte  for  display  */
X/*   attributes  (such  as  bold,  reverse  video). And one which is  */
X/*   spare for now.						      */
X/**********************************************************************/
X# define	VB_LINE		0x01
X# define	VB_REVERSE	0x02
X# define	VB_BOLD		0x04
X# define	VB_FLASHING	0x08
X# define	VB_UNDERLINE	0x10
X# define	VB_SELECT	0x20
X
Xtypedef struct vbyte_t {
X	union {
X		unsigned long	lbyte;
X		struct vb {
X			unsigned char	byte;
X			unsigned char	attr;
X			unsigned char	color;
X			unsigned char	spare;
X			} vbyte;
X		} u;
X	} vbyte_t;
X# define	vb_byte		u.vbyte.byte
X# define	vb_attr		u.vbyte.attr
X# define	vb_color	u.vbyte.color
X# define	vb_spare	u.vbyte.spare
X# define	vb_all		u.lbyte
X
X/**********************************************************************/
X/*   Color manipulation macros.					      */
X/**********************************************************************/
X# define	FG_COLOR	0xf0
X# define	BG_COLOR	0x0f
X# define	FG(x)		((x) << 4)
X# define	BG(x)		(x)
X# define	GET_FG(x)	((x) >> 4)
X# define	GET_BG(x)	((x) & 0x0f)
X
Xenum cursor_type {
X	CURSOR_OFF,
X	CURSOR_ON,
X	CURSOR_SORT_OF,
X	CURSOR_HIDDEN
X	};
X
Xtypedef struct {
X	/* resources */
X	Pixel		window_background;
X	String		table;
X	Pixel		cursor_color;
X	int		rows;
X	int		columns;
X	XtCallbackList	kbd_callback;
X	Boolean		sun_function_keys;
X	int		max_lines;
X	XtCallbackList	resize_callback;
X	XtCallbackList	top_callback;
X	XtCallbackList	mouse_callback;
X	XtCallbackList	appl_callback;
X	char		*geometry;
X	int		flashrate;
X	char		*font;
X	char		*font1;
X	char		*font2;
X	char		*font3;
X	char		*font4;
X	char		*font5;
X	char		*font6;
X	Pixel		hilite_fg;
X	Pixel		hilite_bg;
X	int		multiClickTime;
X
X/* private: */
X	XFontStruct	*fontp;
X	XFontStruct	*line_fontp;	/* Font for line-drawing graphics. */
X	/***********************************************/
X	/*   Need  to  keep  track  of size of window  */
X	/*   allocated  so  if  window  is resized to  */
X	/*   be  larger  than what we have we need to  */
X	/*   allocate a new window.		       */
X	/***********************************************/
X	int	win_width_allocated;
X	int	win_height_allocated;
X
X	/***********************************************/
X	/*   Graphics contexts			       */
X	/***********************************************/
X	GC	gc;		/* Normal text.		*/
X	GC	line_gc;	/* Line-drawing GC.	*/
X	GC	cursor_gc;	/* For drawing cursor.	*/
X
X	int	font_height;
X	int	font_width;
X	int	char_set;
X
X	int	x, y;
X	int	saved_x, saved_y;
X	int	cursor_visible;
X	XtIntervalId	cursor_timer;
X	enum cursor_type	cursor_state;
X	int	have_focus;	/* Used for cursor flashing.	*/
X
X	char	escbuf[MAX_ESCBUF];	/* Used to assemble escape sequences*/
X	char	*escp;
X
X	int	num_exposures;	/* Number of Exposure events to wait for. */
X
X	int	old_top_line;
X	int	top_line;
X
X	int	scroll_top;	/* Top and bottom scrolling region lines. */
X	int	scroll_bot;
X
X	int	old_rows;
X	int	old_columns;
X	vbyte_t	*memory;	/* Pointer to originally allocated */
X				/* memory.			   */
X	vbyte_t	**orig_lines;	/* Array of lines pointers.	   */
X	vbyte_t	**lines;	/* Array of lines corresponding to screen */
X
X	Time	timestamp;	/* Time of last event.	*/
X	char	*sel_string;	/* Copy of selected text.	*/
X	int	sel_length;
X	int	sel_start_x, sel_start_y; /* Starting co-ordinate of hilite*/
X	int	sel_cur_x, sel_cur_y;	/* Current motion position.	*/
X	int	num_clicks;	/* Number of button clicks for selecting text */
X	/***********************************************/
X	/*   ANSI escape attributes.		       */
X	/***********************************************/
X	int	old_color;
X	vbyte_t	attr;		/* Current display attributes.		*/
X	int	flags[CTW_MAX_ATTR];
X} CtwPart;
X
Xtypedef struct _CtwRec {
X    CorePart		core;
X    CtwPart		ctw;
X} CtwRec;
X
X#endif /* _CtwP_h */
SHAR_EOF
chmod 0644 ctwP.h || echo "restore of ctwP.h fails"
set `wc -c ctwP.h`;Sum=$1
if test "$Sum" != "5457"
then echo original size 5457, current size $Sum;fi
echo "x - extracting decode.c (Text)"
sed 's/^X//' << 'SHAR_EOF' > decode.c &&
Xstatic char *RcsID = "$Id: decode.c,v 1.11 1993/03/02 00:45:01 rfs Exp $";
X/*
X * $Log: decode.c,v $
X * Revision 1.11  1993/03/02  00:45:01  rfs
X * Added integrity checks.
X *
X * Revision 1.10  1993/02/26  21:36:37  rfs
X * *** empty log message ***
X *
X * Revision 1.9  1993/02/23  18:22:17  rfs
X * fixed display of ascii decoded data.
X *
X * Revision 1.8  1993/02/17  22:55:01  rfs
X * *** empty log message ***
X *
X * Revision 1.7  1993/02/16  23:13:00  rfs
X * removed "smartness" about handling Home & End
X *
X * Revision 1.6  1993/02/13  23:23:03  rfs
X * Added logic to prevent any display activity on Home or End
X * if we're already there.
X *
X * Revision 1.5  1993/02/13  17:35:50  rfs
X * Fixed pronblem with ASCII decode, and keep mouse position
X * constant whne hcanging view modes.
X *
X * Revision 1.4  1993/02/13  13:41:20  rfs
X * mouse highlight on DisplayFullPagge
X *
X * Revision 1.3  1993/02/13  12:18:24  rfs
X * Added function PackedColumn
X *
X * Revision 1.1  1993/02/13  02:06:39  rfs
X * Initial revision
X *
X * Revision 1.1  1993/02/13  02:06:39  rfs
X * Initial revision
X *
X*/
X
X#include <xod.h>
X#include <ctype.h>
X#include <xod.pt>
X
Xstatic char *escbeg, *escend;
X
X/* what column packed ascii strip begins at */
Xint
XPackedColumn(void) {
X	return CtwColumns-BytesHoriz;
X}
X
Xstatic char *
XAsciiDecode(unsigned char ch) {
X	static char chbuf[128];
X	char buf[10], *p;
X	int  parity = 0;
X
X	if (ch > 127) {
X		parity = 1;
X		ch -= 127;
X	}
X	*buf = ch;
X	*(buf+1) = (char)0;
X	p = buf;
X
X	if (ch < ' ') {
X		switch (ch) {
X			case 0: p = "nul"; break;
X			case 1: p = "soh"; break;
X			case 2: p = "stx"; break;
X			case 3: p = "etx"; break;
X			case 4: p = "eot"; break;
X			case 5: p = "enq"; break;
X			case 6: p = "ack"; break;
X			case 7: p = "bel"; break;
X			case 8: p = "bs"; break;
X			case 9: p = "ht"; break;
X			case 10: p = "nl"; break;
X			case 11: p = "vt"; break;
X			case 12: p = "np"; break;
X			case 13: p = "cr"; break;
X			case 14: p = "so"; break;
X			case 15: p = "si"; break;
X			case 16: p = "dle"; break;
X			case 17: p = "dc1"; break;
X			case 18: p = "dc2"; break;
X			case 19: p = "dc3"; break;
X			case 20: p = "dc4"; break;
X			case 21: p = "nak"; break;
X			case 22: p = "syn"; break;
X			case 23: p = "etb"; break;
X			case 24: p = "can"; break;
X			case 25: p = "em"; break;
X			case 26: p = "sub"; break;
X			case 27: p = "esc"; break;
X			case 28: p = "fs"; break;
X			case 29: p = "gs"; break;
X			case 30: p = "rs"; break;
X			case 31: p = "us"; break;
X		}
X	}
X	if (ch == 127)
X		p = "del";
X	if (parity)
X		sprintf(chbuf, "%s%3s%s", UNDERLINE, p, DATANORMAL);
X	else
X		sprintf(chbuf, "%3s", p);
X	return chbuf;
X}
X
Xstatic char *
XPackedEncode(unsigned char *data,  int length) {
X	static char buffer[MAXLEN];
X	unsigned char *src = data;
X	unsigned char *dest = buffer;
X	unsigned ch;
X	int i, ndx;
X
X	for (i=0, ndx =0; i < BytesHoriz; i++) {
X		if (i >= length) {
X			*dest++ = ' ';
X			continue;
X		}
X		ch = *src;
X		*dest = (isprint(ch)) ? ch : ' ';
X		src++;
X		dest++;
X	}
X	*dest = (char)0;
X	return buffer;
X}
X
Xchar *
XGetFormat(int *width) {
X	char *fmt;
X	int  n = 3;
X
X	switch (DataMode) {
X		case HEX:
X			n = 2;
X			fmt = " %02x";
X			break;
X		case OCTAL:
X			fmt = " %03o";
X			break;
X		case DECIMAL:
X			fmt = " %03d";
X			break;
X		case ASCII:
X			fmt = " %3s";
X			break;
X		default:
X			n = 2;
X			fmt = " %02x";
X			break;
X	}
X	*width = n;
X	return fmt;
X}
X
X/* code to highlight the byte under the mouse click */
Xstatic void
XMouseLight(int mousex, int mousey, int hilite) {
X	char buffer[MAXLEN], chbuf[MAXLEN];
X	char *fmt, *pa;
X	unsigned char ch;
X	int  width, chpos, row, col;
X
X	switch (hilite) {
X		case 0:
X			escbeg = DATANORMAL;
X			escend = "";
X			break;
X		case 1:
X			escbeg = RevVideo();
X			escend = DATANORMAL;
X			break;
X	}
X	fmt = GetFormat(&width);
X	/* account for space in front of each entry */
X	width++;
X	chpos = (mousex-1)/width;
X	chpos++;
X	if (chpos > BytesHoriz)
X		return;
X	ch = ByteAtPosition(mousey, chpos);
X	row = mousey;
X	col = (mousex-1)-((mousex-1)%width)+1;
X	if (DataMode == ASCII) {
X		*chbuf = ' '; *(chbuf+1) = NIL;
X		strcat(chbuf, (hilite) ? RevVideo() : DATANORMAL);
X		strcat(chbuf, AsciiDecode(ch));
X	}
X	else
X		sprintf(chbuf, fmt, ch);
X	sprintf(buffer, "%s%s%s", escbeg, chbuf, escend);
X	CursorAt(row, col);
X	SendString(buffer);
X	/* and, highlight the packed ascii portion too */
X	CursorAt(mousey, PackedColumn()+chpos-1);
X	pa = PackedEncode(&ch, 1);
X	*(pa+1) = NIL;
X	sprintf(buffer, "%s%s%s", escbeg, pa, escend);
X	SendString(buffer);
X	/* send cursor to lower right of screen */
X	CursorAt(NumberRows, CtwColumns);
X}
X
Xvoid
XMouseHighlight(int mousex, int mousey) {
X	MouseLight(mousex, mousey, 1);
X}
X
Xvoid
XMouseUnhighlight(int mousex, int mousey) {
X	MouseLight(mousex, mousey, 0);
X}
X
Xchar *
XBuildLine(unsigned char *data, int length) {
X	static char buffer[3*MAXLEN];
X	char minibuf[MAXLEN];
X	char *fmt, *here;
X	char *p;
X	int i, n;
X
X	*buffer = (char)0;
X	here = buffer;
X	fmt = GetFormat(&n);
X
X	for (i=0; i < length; i++) {
X		if (DataMode == ASCII) {
X			p = AsciiDecode(*data);
X			sprintf(here, " %s", p);
X			here += strlen(p)+1;
X		}
X		else {
X			sprintf(here, fmt, *data);
X			here += n+1;
X		}
X		data++;
X	}
X
X	if (DataMode == ASCII) {
X		p = AsciiDecode(0);
X		n = strlen(p);
X	}
X	else {
X		sprintf(minibuf, fmt, 0);
X		p = minibuf;
X	}
X
X	for (i=length; i < BytesHoriz; i++) {
X		sprintf(here, "%s", p);
X		here += n+1;
X	}
X	return buffer;
X}
X
X/* display a single line of binary data in the CTW widget */
Xvoid
XDisplayLine(unsigned char *data, int length, int line) {
X	char buffer[MAXLEN];
X	char *cp;
X
X	line++;
X	CursorAt(line, 1);
X	cp = BuildLine(data, length);
X	SendString(cp);
X	CursorAt(line, PackedColumn());
X	SendString(PackedEncode(data, length));
X}
X
Xvoid
XDisplayFullPage(int line, int moff) {
X	unsigned char *data;
X	static int dispcnt = 0;
X	int i, cline, cmoff, maxline;
X
X	/* don't do End if we're already there */
X	if (line < 0 && IsAtEOF()) return;
X	/* don't do Home if we're already there */
X	if (dispcnt)
X		DataLocation(&cline, &cmoff);
X
X	maxline = LargestLine();
X	if (line > maxline) line = maxline;
X	data = ReadBlock(line, BytesHoriz, NumberRows, moff);
X	if (!dispcnt)
X		ClearScreen();
X	dispcnt++;
X	for (i=0; i < NumberRows; i++)  {
X		DisplayLine(data+(i*BytesHoriz), BytesHoriz, i);
X	}
X	ResetMouseCoord();
X	MouseHighlight(1, 1);
X	UpdateStatus();
X}
X
Xvoid
XRedisplayPage(void) {
X	int line, moff;
X	int x, y;
X
X	GetCursorOnData(&x, &y);
X	DataLocation(&line, &moff);
X	ClearScreen();
X	DisplayFullPage(line, moff);
X	MouseUnhighlight(1, 1);
X	/*
X	SetMouseCoord(mx, my);
X	MouseHighlight(mx, my);
X	*/
X	SetCursorOnData(x, y);
X}
SHAR_EOF
chmod 0644 decode.c || echo "restore of decode.c fails"
set `wc -c decode.c`;Sum=$1
if test "$Sum" != "6496"
then echo original size 6496, current size $Sum;fi
echo "x - extracting defines.h (Text)"
sed 's/^X//' << 'SHAR_EOF' > defines.h &&
X#define XOD_OK 1
X#define XOD_CANCEL 2
X
X/* foreground & background escape sequences */
X#define FGBLACK "\033[30m"
X#define FGRED "\033[31m"
X#define FGGREEN "\033[32m"
X#define FGYELLOW "\033[33m"
X#define FGBLUE "\033[34m"
X#define FGMAGENTA "\033[35m"
X#define FGCYAN "\033[36m"
X#define FGWHITE "\033[37m"
X
X#define BGBLACK "\033[40m"
X#define BGRED "\033[41m"
X#define BGGREEN "\033[42m"
X#define BGYELLOW "\033[43m"
X#define BGBLUE "\033[44m"
X#define BGMAGENTA "\033[45m"
X#define BGCYAN "\033[46m"
X#define BGWHITE "\033[47m"
X
X#define REVVID "\033[7m"
X#define UNDERLINE "\033[4m"
X#define DATANORMAL "\033[0m\033[34m\033[47m"
X
X/* various decoding modes */
X#define HEX 		0
X#define OCTAL 		1
X#define DECIMAL 	2
X#define ASCII 		3
X#define PACKASCII 	4
X
X#define SHORT 1
X#define USHORT 2
X#define LONG 3
X#define ULONG 4
X#define FLOAT 5
X#define DOUBLE 6
X#define dASCII 7
X
X/* what user types in search box means */
X#define SmGrep 0
X#define SmLine 1
X#define SmAdvance 2
X#define SmRetard 3
X
X#define MAXLEN 256
SHAR_EOF
chmod 0644 defines.h || echo "restore of defines.h fails"
set `wc -c defines.h`;Sum=$1
if test "$Sum" != "989"
then echo original size 989, current size $Sum;fi
echo "x - extracting fileio.c (Text)"
sed 's/^X//' << 'SHAR_EOF' > fileio.c &&
Xstatic char *RcsId = "$Id: fileio.c,v 1.9 1993/03/02 02:56:05 rfs Exp $";
X
X/*
X * $Log: fileio.c,v $
X * Revision 1.9  1993/03/02  02:56:05  rfs
X * Better ahndling of opening bogus ilfe names
X *
X * Revision 1.8  1993/03/02  00:46:04  rfs
X * Added several routines, and comments.
X *
X * Revision 1.7  1993/02/26  21:36:59  rfs
X * *** empty log message ***
X *
X * Revision 1.6  1993/02/25  00:44:11  rfs
X * *** empty log message ***
X *
X * Revision 1.5  1993/02/24  23:14:10  rfs
X * Added ReadNbytes, for use in decoding.
X *
X * Revision 1.4  1993/02/13  23:23:51  rfs
X * Fixed bug in computation of the offeset on End.
X *
X * Revision 1.3  1993/02/13  17:59:19  rfs
X * fixed problem with byte offsets when user hits End
X *
X * Revision 1.2  1993/02/13  13:40:35  rfs
X * Mouse coordinates reset on new file load.
X *
X * Revision 1.1  1993/02/13  02:20:18  rfs
X * Initial revision
X *
X * Revision 1.1  1993/02/13  02:20:18  rfs
X * Initial revision
X *
X*/
X
X#include <stdio.h>
X#include <malloc.h>
X
X#define True 1
X#define False 0;
X#define SRCHBUF 4096
Xtypedef int Boolean;
X
Xstatic unsigned char *data = NULL;
Xstatic char *FileName;
Xstatic long FileSize = 0L;
Xstatic FILE *fp = (FILE *)NULL;
Xstatic Boolean AtEOF = 0;
Xstatic long DataOffset = 0L;
Xstatic int Dwidth, Dheight, Dblksize;
X
X/* returns line # and offset from Dwidth of left corner byte */
Xvoid
XDataLocation(int *line, int *moff) {
X	int Dwidth = GetBytesHoriz();
X
X	*line = DataOffset/Dwidth;
X	*moff = DataOffset % Dwidth;
X}
X
Xlong
XGetDataOffset(void) {
X	return DataOffset;
X}
X
Xchar *
XGetFileName(void) {
X	return FileName;
X}
X
XBoolean
XIsAtEOF(void) {
X	return AtEOF;
X}
X
X/* 
X	search for specified pattern starting 1 byte past cursor...
X	wrap if required.
X*/
XDoSearch(unsigned char *pattern, int len) {
X	unsigned char buffer[SRCHBUF];
X	long begin = DataOffset;
X	long start;
X	long end = DataOffset+(Dwidth*Dheight)-1;
X	long offset, where;
X	int  pass = 0;
X	int  x, y;
X	int  line, moff;
X	int  i, j, bytes;
X
X	offset = begin;
X	GetCursorOnData(&x, &y);
X	offset += (y-1)*Dwidth + (x-1) + 1;
X	start = offset-1;
X	while (1) {
X		fseek(fp, offset, 0);
X		bytes = fread(buffer, sizeof(unsigned char), SRCHBUF, fp);
X		for (i=0; i < bytes; i++) {
X			if (buffer[i] == *pattern) {
X				for (j=0; j < len; j++) {
X					if (buffer[i+j] != *(pattern+j)) break;
X				}
X				/* did we find a match? */
X				if (j == len) {
X					where = offset+i;
X					line = where/Dwidth;
X					if (line < 0) line = 1;
X					moff = begin % Dwidth;
X					if (where > end || pass) {
X						begin = line*Dwidth + moff;
X						DisplayFullPage(line, moff);
X					}
X					y = (where-begin)/Dwidth + 1;
X					x = (where-begin)-((y-1)*Dwidth) + 1;
X
X					if (where <= end) {
X						SetCursorOnData(x, y);
X					}
X					else {
X						DisplayFullPage(line, moff);
X						SetCursorOnData(x, y);
X					}
X					return;
X				}
X			}
X		}
X		offset += SRCHBUF-len+1;
X		if (bytes < SRCHBUF) {
X			if (start == 0L)
X				break;
X			else {
X				pass++;
X				offset = 0;
X				start =0;
X				continue;
X			}
X		}
X		if (pass > 0 && offset > begin)
X			break;
X	}
X}
X
Xunsigned char *
XReadBlock(int startline, int width, int height, int moff) {
X	int blksize = width*height;
X	int offset = startline*width+moff;
X	int i, diff, bytes;
X
X	/* implies end-of-file */
X	if (startline < 0) {
X		/* compute offset, and be sure offset % width is 0 */
X		offset = FileSize-blksize;
X		if (offset < 0) offset = moff;
X		diff = offset % width;
X		if (diff)
X			offset += (width-diff);
X	}
X	DataOffset = offset;
X	Dwidth = width;
X	Dheight = height;
X	Dblksize = blksize;
X
X	/* always read into the same place */
X	if (!data)
X		data = (unsigned char *)malloc(blksize*sizeof(unsigned char));
X	fseek(fp, offset, 0);
X	bytes = fread(data, sizeof(unsigned char), blksize, fp);
X	AtEOF = (bytes < blksize) ? True : False;
X	if ((offset+bytes+1) >= FileSize)
X		AtEOF = True;
X	/* ensure we return a full block.  pad w/ zeros if necessary */
X	for (i=bytes; i < blksize; i++) {
X		*(data+i) = (unsigned char)0;
X	}
X	return data;
X}
X
X/* read n bytes starting at begin... this is for decoding */
XReadNbytes(long begin, int n, unsigned char *where) {
X	fseek(fp, begin, 0);
X	fread(where, sizeof(unsigned char), n, fp);
X}
X
X/* return byte that is at specified position */
Xunsigned char
XByteAtPosition(int line, int chpos) {
X	int  off = ((line-1)*Dwidth)+chpos-1;
X
X	return *(data+off);
X}
X
X/* Returns True if the specified address is on the screen, False otherwise */
XBoolean
XAddressOnScreen(long addr) {
X	long begin = DataOffset;
X	long end = begin + Dblksize -1;
X
X	return (addr >= begin && addr <= end) ? True : False;
X}
X
X
XBoolean
XFileOpen(char *filename) {
X	FILE *oldfp = fp;
X	FILE *newfp;
X
X	if (filename)
X		newfp = fopen(filename, "r");
X	else
X		return False;
X
X	if (newfp) {
X		if (oldfp) fclose(oldfp);
X		fp = newfp;
X	}
X	else
X		return False;
X
X	ResetMouseCoord();
X	/* save the file name being looked at */
X	if (FileName)
X		free(FileName);
X	FileName = (char *)malloc(strlen(filename)+1);
X	strcpy(FileName, filename);
X
X	/* figure out the size of the file we're looking at */
X	fseek(fp, 0, 2);
X	FileSize = ftell(fp);
X	fseek(fp, 0, 0);
X	return True;
X}
X
X/* return largest allowed line #, knowing size of file */
XLargestLine(void) {
X	return FileSize/GetBytesHoriz();
X}
X
Xlong
XCurrentFileSize(void) {
X	return FileSize;
X}
SHAR_EOF
chmod 0644 fileio.c || echo "restore of fileio.c fails"
set `wc -c fileio.c`;Sum=$1
if test "$Sum" != "5196"
then echo original size 5196, current size $Sum;fi
echo "x - extracting frowny.xbm (Text)"
sed 's/^X//' << 'SHAR_EOF' > frowny.xbm &&
X#define frowny_width 16
X#define frowny_height 16
Xstatic char frowny_bits[] = {
X   0xe0, 0x03, 0x18, 0x0c, 0x04, 0x10, 0x32, 0x23, 0x32, 0x23, 0x01, 0x40,
X   0x01, 0x40, 0x01, 0x40, 0xe1, 0x43, 0x11, 0x44, 0x0a, 0x28, 0x02, 0x20,
X   0x04, 0x10, 0x18, 0x0c, 0xe0, 0x03, 0x00, 0x00};
SHAR_EOF
chmod 0644 frowny.xbm || echo "restore of frowny.xbm fails"
set `wc -c frowny.xbm`;Sum=$1
if test "$Sum" != "281"
then echo original size 281, current size $Sum;fi
echo "x - extracting getres.c (Text)"
sed 's/^X//' << 'SHAR_EOF' > getres.c &&
Xstatic char *RcsID = "$Id: getres.c,v 1.2 1993/02/13 14:34:24 rfs Exp $";
X/*
X * $Log: getres.c,v $
X * Revision 1.2  1993/02/13  14:34:24  rfs
X * *** empty log message ***
X *
X * Revision 1.1  1993/02/13  02:06:39  rfs
X * Initial revision
X *
X * Revision 1.1  1993/02/13  02:06:39  rfs
X * Initial revision
X *
X*/
X
X/*
X * Get resources that don't apply to widgets, per se.
X *
X * cursorFg: foreground color for "cursor"
X * cursorBg: background color for "cursor"
X *
X * Note: "cursor" is the data byte clicked on with the mouse
X*/
X
X#include <xod.h>
X
X/* #defined here, since no one else need to know about them */
X#define XtNcursorForeground "cursorFg"
X#define XtCCursorForeground "CursorFg"
X#define XtNcursorBackground "cursorBg"
X#define XtCCursorBackground "CursorBg"
X
X/* the 7 colors allowed by the CTW widget */
Xstatic char *CTWcolors[] = {
X	"black",
X	"red",
X	"green",
X	"yellow",
X	"blue",
X	"magenta",
X	"cyan",
X	"white"
X};
X
Xstatic char *intoRev = NULL;
Xstatic char *selCurFg = NULL;
Xstatic char *selCurBg = NULL;
X
X/* returns ESC seequence to set desired reverse video on data */
Xchar *
XRevVideo(void) {
X	return intoRev;
X}
X
Xtypedef struct {
X	String cursorFg;
X	String cursorBg;
X} InstanceRec;
X
Xstatic XtResource resources[] = {
X	{ 
X		XtNcursorForeground, XtCCursorForeground,
X		XtRString, sizeof(char *),
X		XtOffsetOf(InstanceRec, cursorFg),
X		XtRString, "black"
X	},
X	{ 
X		XtNcursorBackground, XtCCursorBackground,
X		XtRString, sizeof(char *),
X		XtOffsetOf(InstanceRec, cursorBg),
X		XtRString, "yellow"
X	}
X};
X
Xstatic int
XXlateColor(char *color) {
X	int  i;
X
X	for (i=0; i < (sizeof(CTWcolors)/sizeof(char *)); i++) {
X		if (!strcmp(CTWcolors[i], color))
X			return i;
X	}
X	return -1;
X}
X
Xvoid
XFigureRevVidSeq(void) {
X	char buffer[MAXLEN];
X	char *cfg, *cbg;
X	int fg, bg;
X
X	fg = XlateColor(selCurFg);
X	bg = XlateColor(selCurBg);
X	if (fg < 0)
X		fprintf(stderr, "Foreground color %s is illegal\n", selCurFg);
X	if (bg < 0)
X		fprintf(stderr, "Background color %s is illegal\n", selCurBg);
X	if (fg < 0 || bg < 0)
X		exit(1);
X	switch (fg) {
X		case 0: cfg = FGBLACK; break;
X		case 1: cfg = FGRED; break;
X		case 2: cfg = FGGREEN; break;
X		case 3: cfg = FGYELLOW; break;
X		case 4: cfg = FGBLUE; break;
X		case 5: cfg = FGMAGENTA; break;
X		case 6: cfg = FGCYAN; break;
X		case 7: cfg = FGWHITE; break;
X	}
X	switch (bg) {
X		case 0: cbg = BGBLACK; break;
X		case 1: cbg = BGRED; break;
X		case 2: cbg = BGGREEN; break;
X		case 3: cbg = BGYELLOW; break;
X		case 4: cbg = BGBLUE; break;
X		case 5: cbg = BGMAGENTA; break;
X		case 6: cbg = BGCYAN; break;
X		case 7: cbg = BGWHITE; break;
X	}
X	sprintf(buffer, "%s%s", cfg, cbg);
X	intoRev = (char *)malloc(strlen(buffer)+1);
X	strcpy(intoRev, buffer);
X}
X
Xvoid
XXodGetResources(Widget top) {
X	InstanceRec ir;
X	XtGetApplicationResources(top, &ir, resources, XtNumber(resources),
X		NULL, 0);
X	selCurFg = ir.cursorFg;
X	selCurBg = ir.cursorBg;
X}
SHAR_EOF
chmod 0644 getres.c || echo "restore of getres.c fails"
set `wc -c getres.c`;Sum=$1
if test "$Sum" != "2844"
then echo original size 2844, current size $Sum;fi
echo "x - extracting gvars.h (Text)"
sed 's/^X//' << 'SHAR_EOF' > gvars.h &&
X#include	<stdio.h>
X#include	<X11/X.h>
X
X#ifdef XOD_MAIN
X#	define Dextern
X#else
X#	define Dextern extern
X#endif
X
XDextern FILE *datafp;
XDextern int  FileSize;
XDextern int  DataOffset;
XDextern int  DataMode;
XDextern int  BytesHoriz;
XDextern int  DataLeftCol;
XDextern int  OffsetClickedOn;
XDextern int  MatchAt;
XDextern int  NumberRows;
XDextern int  charwidth;
XDextern int  charheight;
XDextern int  SearchMode;
XDextern char *OffsetFmt;
XDextern int  OffsetMode;
XDextern int  MaxOffset;
XDextern int  CtwColumns;		/* actual width of CTW display, in chars */
SHAR_EOF
chmod 0644 gvars.h || echo "restore of gvars.h fails"
set `wc -c gvars.h`;Sum=$1
if test "$Sum" != "549"
then echo original size 549, current size $Sum;fi
echo "x - extracting gwidgets.h (Text)"
sed 's/^X//' << 'SHAR_EOF' > gwidgets.h &&
X#include <stdio.h>
X#include <X11/X.h>
X#include <X11/Intrinsic.h>
X#include <Dialog.h>
X
X#ifdef XOD_MAIN
X#	define Dextern
X#else
X#	define Dextern extern
X#endif
X
XDextern Widget HelpDialog, ModeSelect, GrepText;
XDextern Widget ByteAddress, ctwWidget, ByteOffsetWidget;
XDextern Widget StatusWidget, ErrorDialog, DecodeWidget;
XDextern Dialog GotoByteDialog;
SHAR_EOF
chmod 0644 gwidgets.h || echo "restore of gwidgets.h fails"
set `wc -c gwidgets.h`;Sum=$1
if test "$Sum" != "350"
then echo original size 350, current size $Sum;fi
echo "x - extracting helpdialog.c (Text)"
sed 's/^X//' << 'SHAR_EOF' > helpdialog.c &&
Xstatic char *RcsId = "$Id: helpdialog.c,v 1.8 1993/03/02 23:05:41 rfs Exp $";
X
X/*
X * $Log: helpdialog.c,v $
X * Revision 1.8  1993/03/02  23:05:41  rfs
X * *** empty log message ***
X *
X * Revision 1.7  1993/03/02  00:46:34  rfs
X * Updated messages.
X *
X * Revision 1.6  1993/02/26  21:37:32  rfs
X * *** empty log message ***
X *
X * Revision 1.5  1993/02/23  18:22:53  rfs
X * position the popup.
X *
X * Revision 1.4  1993/02/13  23:25:14  rfs
X * Added code for error dialog popup.
X *
X * Revision 1.3  1993/02/13  18:02:40  rfs
X * generalized slightly for other dialogs.
X *
X * Revision 1.2  1993/02/13  14:34:43  rfs
X * *** empty log message ***
X *
X * Revision 1.1  1993/02/13  02:20:18  rfs
X * Initial revision
X *
X * Revision 1.1  1993/02/13  02:20:18  rfs
X * Initial revision
X *
X*/
X
X#include <xod.h>
X#include <Dialog.h>
X#include <X11/Xaw/Dialog.h>
X#include <X11/Xaw/Paned.h>
X#include <X11/Xaw/Form.h>
X#include <X11/Xaw/Label.h>
X#include <X11/Xaw/Command.h>
X
Xstatic char *viHelp = "\
Xj    | cursor down\n\
Xk    | cursor up\n\
Xh    | cursor left\n\
Xl    | cursor right\n\
X(arrow keys also work)\n\
X^F   | page forward\n\
X^B   | page backward\n\
XG    | end-of-file\n\
X$    | end-of-line \n\
Xq    | quit xod\n";
X
Xstatic char *moveHelp = "\
XHome | top-of-file\n\
XEnd  | end-of-file\n\
X     |\n\
X+    | move cursor ahead n bytes\n\
X-    | move cursor back n bytes\n\
X/    | search for a string\n\
X(popup will appear)\n\
Xn    | next search\n";
X
Xstatic char *otherHelp = "\
XMeta-h | hex\n\
XMeta-o | octal\n\
XMeta-d | decimal\n\
XMeta-a | ASCII\n\
XAlt-h  | offset format in hex\n\
XAlt-o  | offset format in octal\n\
XAlt-d  | offset format in decimal\n";
X
Xvoid SetSelected();
X
Xstatic void 
XPopdownDialog(Widget w, XtPointer clientData, XtPointer callData) {
X	XtPopdown((Widget)clientData);
X}
X
Xstatic Widget 
XHelpCreateDialog(Widget parent) {
X	Widget pushell, mainpane, helppane, helpform, helplabel, okbutton;
X
X	pushell = XtCreatePopupShell("helpDialog", transientShellWidgetClass, 
X		parent, NULL, 0);
X	/* pane for window title */
X	mainpane = XtCreateManagedWidget("paneMain", panedWidgetClass,
X		pushell, NULL, 0);
X	helpform = XtCreateManagedWidget("form", formWidgetClass,
X		mainpane, NULL, 0);
X	helplabel = XtCreateManagedWidget("labelHelp", labelWidgetClass,
X		helpform, NULL, 0);
X	XtVaSetValues(helplabel, XtNlabel, "Xod Quick Help", NULL);
X	/* pane for first help block */
X	helppane = XtCreateManagedWidget("pane", panedWidgetClass,
X		mainpane, NULL, 0);
X	helpform = XtCreateManagedWidget("form", formWidgetClass,
X		helppane, NULL, 0);
X	helplabel = XtCreateManagedWidget("labelHelp", labelWidgetClass,
X		helpform, NULL, 0);
X	XtVaSetValues(helplabel, XtNlabel, viHelp, NULL);
X	helpform = XtCreateManagedWidget("form", formWidgetClass,
X		helppane, NULL, 0);
X	helplabel = XtCreateManagedWidget("labelHelp", labelWidgetClass,
X		helpform, NULL, 0);
X	XtVaSetValues(helplabel, XtNlabel, moveHelp, NULL);
X	/* form for second help block */
X	helpform = XtCreateManagedWidget("form", formWidgetClass,
X		mainpane, NULL, 0);
X	helplabel = XtCreateManagedWidget("labelHelp", labelWidgetClass,
X		helpform, NULL, 0);
X	XtVaSetValues(helplabel, XtNlabel, otherHelp, NULL);
X	/* form for the OK button */
X	helpform = XtCreateManagedWidget("form", formWidgetClass,
X		mainpane, NULL, 0);
X	okbutton = XtCreateManagedWidget("helpOK", commandWidgetClass,
X		helpform, NULL, 0);
X	XtVaSetValues(okbutton, XtNlabel, "Dismiss", NULL);
X	XtAddCallback(okbutton, XtNcallback, PopdownDialog, 
X		(XtPointer)pushell);
X	return pushell;
X}
X
XWidget
XCreateHelpDialog(Widget parent) {
X	Widget w;
X	w = HelpCreateDialog(parent);
X	return w;
X}
X
XPopupHelpDialog(void) {
X	XtPopup(HelpDialog, XtGrabNone);
X	PositionPopup(GetTopLevel(), HelpDialog);
X}
X
XWidget 
XErrorCreateDialog(Widget parent, char *bits, int width, int height) {
X	Widget pushell, mainpane, errlabel, okbutton;
X	Pixmap bm;
X
X	pushell = XtCreatePopupShell("errorDialog", transientShellWidgetClass, 
X		parent, NULL, 0);
X	if (bits) {
X		bm = XCreateBitmapFromData(XtDisplay(pushell), 
X			RootWindowOfScreen(XtScreen(pushell)), bits, width, height);
X	}
X	/* pane for window title */
X	mainpane = XtCreateManagedWidget("paneMain", panedWidgetClass,
X		pushell, NULL, 0);
X	errlabel = XtCreateManagedWidget("labelError", labelWidgetClass,
X		mainpane, NULL, 0);
X	XtVaSetValues(errlabel, XtNleftBitmap, bm, NULL);
X	okbutton = XtCreateManagedWidget("errorOK", commandWidgetClass,
X		mainpane, NULL, 0);
X	XtVaSetValues(okbutton, XtNlabel, "OK", NULL);
X	XtAddCallback(okbutton, XtNcallback, PopdownDialog, 
X		(XtPointer)pushell);
X	AddWidgetAssoc(pushell, errlabel);
X	return pushell;
X}
X
Xvoid
XPopupErrorDialog(Widget w, char *msg) {
X	Widget label;
X
X	label = (Widget)GetWidgetAssoc(w);
X	XtVaSetValues(label, XtNlabel, msg, NULL);
X	PositionPopup(GetTopLevel(), w);
X	XtPopup(w, XtGrabExclusive);
X}
SHAR_EOF
chmod 0644 helpdialog.c || echo "restore of helpdialog.c fails"
set `wc -c helpdialog.c`;Sum=$1
if test "$Sum" != "4782"
then echo original size 4782, current size $Sum;fi
echo "x - extracting keyhandler.c (Text)"
sed 's/^X//' << 'SHAR_EOF' > keyhandler.c &&
Xstatic char *RcsID = "$Id: keyhandler.c,v 1.5 1993/03/02 00:47:01 rfs Exp $";
X
X/*
X * $Log: keyhandler.c,v $
X * Revision 1.5  1993/03/02  00:47:01  rfs
X * Added new features.
X *
X * Revision 1.4  1993/02/26  21:38:22  rfs
X * *** empty log message ***
X *
X * Revision 1.3  1993/02/23  18:23:38  rfs
X * Many mods, all for the better.
X *
X * Revision 1.2  1993/02/14  01:15:09  rfs
X * made certain keys work properly
X *
X * Revision 1.1  1993/02/13  02:19:24  rfs
X * Initial revision
X *
X*/
X
X#include <xod.h>
X#include <keys.h>
X
X/*
X * This is the function that handles all keys the user hits
X * while focus is in the data display window.
X*/
X
XXtEventHandler
Xkeyhandler(Widget w, void *cd, XKeyEvent *event) {
X	static int ctrl = 0;
X	static int meta = 0;
X	static int alt = 0;
X	static int lastch = 0;
X	char buffer[MAXLEN];
X	KeySym keysym;
X	XComposeStatus compose;
X	int line, moff, x, y;
X	int isctrl = False;
X	int ismeta = False;
X	int isalt = False;
X	int isshift = False;
X
X	
X	XLookupString(event, buffer, MAXLEN, &keysym, &compose);
X
X	/* see if key is a meta or ctrl key */
X	if (keysym == XK_Meta_L || keysym == XK_Meta_R)
X		ismeta = True;
X	if (keysym == XK_Control_L || keysym == XK_Control_R)
X		isctrl = True;
X	if (keysym == XK_Alt_L || keysym == XK_Alt_R)
X		isalt = True;
X	if (keysym == XK_Shift_L || keysym == XK_Shift_R)
X		isshift = True;
X
X	/* ignore KeyRelease for non-meta or ctrl keys */
X	if (isshift)
X		return;
X	if (!ismeta && !isctrl && !isalt && (event->type != KeyPress))
X		return;
X
X	/* set internal state of meta, ctrl, and alt */
X	if (isctrl) {
X		ctrl = (event->type == KeyPress) ? 1 : 0;
X		return;
X	}
X	else if (ismeta) {
X		meta = (event->type == KeyPress) ? 1 : 0;
X		return;
X	}
X	else if (isalt) {
X		alt = (event->type == KeyPress) ? 1 : 0;
X		return;
X	}
X
X	/* Meta keys */
X	if (meta) {
X		switch (keysym) {
X			case 'h': DataMode = HEX; ClearScreen(); break;
X			case 'o': DataMode = OCTAL; ClearScreen(); break;
X			case 'd': DataMode = DECIMAL; ClearScreen(); break;
X			case 'a': DataMode = ASCII; ClearScreen(); break;
X		}
X	}
X	/* Alt keys */
X	else if (alt) {
X		long addr = GetDataOffset();
X		/* select offset display mode */
X		switch (keysym) {
X			case 'h':
X				UpdateAll(HEX, addr);
X				break;
X			case 'o':
X				UpdateAll(OCTAL, addr);
X				break;
X			case 'd':
X				UpdateAll(DECIMAL, addr);
X				break;
X		}
X		UpdateByteOffset();
X		return;
X	}
X	/* Ctrl keys */
X	else if (ctrl) {
X		switch (keysym) {
X			case 'f': keysym = PgDn; break;
X			case 'b': keysym = PgUp; break;
X			case 'c': exit(0); break;
X			case 'v': keysym = PgDn; break;			/* emacs... ulk */
X			case 'n': keysym = DownArrow; break;	/* emacs... ulk */
X			case 'p': keysym = UpArrow; break;		/* emacs... ulk */
X		}
X	}
X	/* regular keys */
X	else {
X		switch (keysym) {
X			case 'h': keysym = LeftArrow; break;
X			case 'l': keysym = RightArrow; break;
X			case 'j': keysym = DownArrow; break;
X			case 'k': keysym = UpArrow; break;
X			case 'n': NextSearch(); return; break;
X			case 'v': 
X				if (lastch == XK_Escape) keysym = PgUp;	/* emacs... ulk */
X				break;
X			case XK_slash: 
X				PopupSearch("Search for:");
X				return;
X				break;
X		}
X	}
X	switch (keysym) {
X		case 'G':
X			keysym = End;
X			break;
X		case '+':
X			break;
X		case '-':
X			break;
X	}
X	DataLocation(&line, &moff);
X	switch (keysym) {
X		case '+':
X			PopupAdvanceToByte("+");
X			return;
X			break;
X		case '-':
X			PopupAdvanceToByte("-");
X			return;
X			break;
X		case '<':
X		case '>':
X			return;
X			break;
X		case '?':
X			PopupHelpDialog();
X			return;
X			break;
X		case '$':
X			GetCursorOnData(&x, &y);
X			if (x < BytesHoriz)
X				SetCursorOnData(BytesHoriz, y);
X			return;
X			break;
X		case 'q':
X			exit(0);
X			break;
X		case XK_Return:
X			if (!IsAtEOF())
X				line++;
X			break;
X		case PgUp:
X			if (line == 0)
X				moff = 0;
X			if (line > 0)
X				line -= NumberRows;
X			if (line < 0) {
X				line = 0;
X				moff = 0;
X			}
X			DataOffset -= NumberRows*BytesHoriz;
X			break;
X		case PgDn:
X			if (!IsAtEOF())
X				line += NumberRows;
X			break;
X		case Home:
X			line = moff = 0;
X			break;
X		case End:
X			CursorToAbsByte(CurrentFileSize());
X			return;
X			break;
X		case RightArrow:
X			GetCursorOnData(&x, &y);
X			x++;
X			if (x <= BytesHoriz) 
X				SetCursorOnData(x, y);
X			else {
X				x = 1;
X				y++;
X				if (y > NumberRows) {
X					if (IsAtEOF()) return;
X					line++;
X					DisplayFullPage(line, moff);
X					SetCursorOnData(x, 0);
X				}
X				else
X					SetCursorOnData(x, y);
X			}
X			return;
X			break;
X		case LeftArrow:
X			GetCursorOnData(&x, &y);
X			if (x == 1) {
X				y--;
X				if (y == 0) {
X					line--;
X					if (line >= 1)
X						DisplayFullPage(line, moff);
X				}
X				x = BytesHoriz;
X				SetCursorOnData(x, y);
X			}
X			else {
X				if (x >= 1)
X					SetCursorOnData(--x, y);
X			}
X			return;
X			break;
X		case DownArrow:
X			GetCursorOnData(&x, &y);
X			if (y >= NumberRows) {
X				if (IsAtEOF()) return;
X				line++;
X				DisplayFullPage(line, moff);
X				SetCursorOnData(x, NumberRows);
X			}
X			else {
X				SetCursorOnData(x, ++y);
X			}
X			return;
X			break;
X		case UpArrow:
X			GetCursorOnData(&x, &y);
X			y--;
X			if (y == 0) {
X				line--;
X				if (line < 0) return;
X				DisplayFullPage(line, moff);
X				SetCursorOnData(x, y);
X			}
X			else
X				SetCursorOnData(x, y);
X			return;
X			break;
X	}
X	lastch = keysym;
X	DisplayFullPage(line, moff);
X}
SHAR_EOF
chmod 0644 keyhandler.c || echo "restore of keyhandler.c fails"
set `wc -c keyhandler.c`;Sum=$1
if test "$Sum" != "5210"
then echo original size 5210, current size $Sum;fi
echo "x - extracting keys.h (Text)"
sed 's/^X//' << 'SHAR_EOF' > keys.h &&
X#include <X11/keysym.h>
X
X/* various keys on keyboard, Sun4 & Linux tested */
X#ifdef linux
X#define PgUp XK_Prior
X#define PgDn XK_Next
X#define Home XK_Home
X#define End  XK_End
X#else
X#define PgUp XK_R9
X#define PgDn XK_R15
X#define Home XK_R7
X#define End  XK_R13
X#endif
X#define UpArrow XK_Up
X#define DownArrow XK_Down
X#define LeftArrow XK_Left
X#define RightArrow XK_Right
SHAR_EOF
chmod 0644 keys.h || echo "restore of keys.h fails"
set `wc -c keys.h`;Sum=$1
if test "$Sum" != "367"
then echo original size 367, current size $Sum;fi
echo "x - extracting main.c (Text)"
sed 's/^X//' << 'SHAR_EOF' > main.c &&
Xstatic char *RcsID = "$Id: main.c,v 1.10 1993/03/02 02:55:46 rfs Exp $";
X/*
X * $Log: main.c,v $
X * Revision 1.10  1993/03/02  02:55:46  rfs
X * *** empty log message ***
X *
X * Revision 1.9  1993/03/02  00:47:41  rfs
X * *** empty log message ***
X *
X * Revision 1.8  1993/02/26  21:38:39  rfs
X * *** empty log message ***
X *
X * Revision 1.7  1993/02/24  23:33:37  rfs
X * *** empty log message ***
X *
X * Revision 1.6  1993/02/23  18:24:38  rfs
X * Added search dialog.
X *
X * Revision 1.5  1993/02/13  23:25:41  rfs
X * pop up error dialog if file to be opened can't be.
X *
X * Revision 1.4  1993/02/13  14:37:09  rfs
X * accept a new file name & load it
X *
X * Revision 1.3  1993/02/13  13:42:17  rfs
X * resources read before DisplayFullPage called.
X *
X * Revision 1.2  1993/02/13  11:35:12  rfs
X * position cursor initially over 1st byte in file
X *
X * Revision 1.1  1993/02/13  02:06:39  rfs
X * Initial revision
X *
X * Revision 1.1  1993/02/13  02:06:39  rfs
X * Initial revision
X *
X*/
X
X
X#define XOD_MAIN 1
X#include <xod.h>
X#include <X11/Xaw/Paned.h>
X#include <X11/Xaw/Form.h>
X#include <X11/Xaw/Box.h>
X#include <X11/Xaw/Command.h>
X#include <X11/Xaw/Toggle.h>
X#include <X11/Xaw/MenuButton.h>
X#include <X11/Xaw/SimpleMenu.h>
X#include <X11/Xaw/SmeLine.h>
X#include <X11/Xaw/SmeBSB.h>
X#include <buttons.h>
X#include <version.h>
X#include <xod.pt>
X
Xstatic Widget top;
Xstatic unsigned char *SearchPattern = NULL;
Xstatic int  SearchPatternLength = 0;
X
X/* show version information */
Xchar *
XXodVersion(void) {
X	return VERSION;
X}
X
X/* set the toplevel widget */
Xvoid
XSetTopLevel(Widget w) {
X	top = w;
X}
X
X/* get the toplevel widget */
XWidget
XGetTopLevel(void) {
X	return top;
X}
X
X/* how many bytes to be displayed horizontally */
Xint
XGetBytesHoriz(void) {
X	return BytesHoriz;
X}
X
X/* data initialization */
XgvInit() {
X	datafp = (FILE *)NULL;
X	FileSize = 0;
X	DataOffset = 0;
X	BytesHoriz = 16;
X	OffsetClickedOn = -1;
X	MatchAt = -1;
X	SearchMode = SmGrep;
X	OffsetFmt = NULL;
X	OffsetMode = HEX;
X	MaxOffset = 0;
X	DataMode = HEX;
X}
X
Xvoid
XEditModeCB(Widget w, XtPointer client, XtPointer call) {
X	ButtonPtr bp = (ButtonPtr)client;
X	int  x, y;
X
X	GetCursorOnData(&x, &y);
X	DataMode = bp->id;
X	RedisplayPage();
X	SetCursorOnData(x, y);
X}
X
Xvoid
XEditDecodeCB(Widget w, XtPointer client, XtPointer call) {
X	ButtonPtr bp = (ButtonPtr)client;
X	DoDecode(bp->id);
X}
X
XXtActionProc
XJunk() {
X}
X
Xvoid SetDialogButton();
X
XBoolean image_visible = False;
XPixmap check_mark;
XDialog NewFileDialog, SearchDialog, qsave_dialog;
XString filename = NULL, basename = NULL, format;
Xchar message[80];
X
X
Xvoid 
XFileMenuCallback(Widget w, XtPointer clientData, XtPointer callData) {
X	String file;
X	char buffer[MAXLEN];
X	int *id = (int *)clientData;
X	int stat;
X
X	switch (*id) {
X		case New:
X			stat = PopupDialog(NewFileDialog, "File to dump:", "", &file,
X				XtGrabExclusive);
X			if (stat == Okay) {
X				if (strlen(file)) {
X					if (FileOpen(file)) {
X						DisplayFullPage(0, 0);
X					}
X					else {
X						sprintf(buffer, "Cannot open file %s", file);
X						PopupErrorDialog(ErrorDialog, buffer);
X					}
X				}
X			}
X			break;
X		case Quit:
X			exit(0);
X			break;
X	}
X}
X
XNextSearch(void) {
X	if (!SearchPattern) return;
X	DoSearch(SearchPattern, SearchPatternLength);
X}
X
Xvoid 
XPopupSearch(String message) {
X	String search4;
X	char buffer[MAXLEN];
X	int stat, len;
X
X	stat = PopupDialog(SearchDialog, message, "", &search4,
X		XtGrabExclusive);
X	if (stat == Okay) {
X		if (SearchPattern)
X			XtFree(SearchPattern);
X		len = strlen(search4);
X		SearchPattern = XtMalloc(len+1);
X		strcpy(SearchPattern, search4);
X		SearchPatternLength = len;
X		DoSearch(search4, len);
X	}
X}
X
Xvoid 
Xmain(int argc, char **argv) {
X	Arg wargs[2];
X	char buffer[MAXLEN];
X	int rows, columns;
X	int i, n;
X
X	gvInit();
X	MakeWidgets(&argc, argv);
X	ParseCommandLine(argc, argv);
X
X	XtVaGetValues(ctwWidget, XtNrows, &rows, XtNcolumns, &columns, NULL);
X	NumberRows = rows;
X	CtwColumns = columns;
X	ShowByteAddress(0);
X
X	/* capture keystrokes in the CTW widget */
X	XtAddEventHandler(ctwWidget, KeyPressMask|KeyReleaseMask, False,
X		(XtEventHandler)keyhandler, (XtPointer)NULL);
X
X	XtRealizeWidget(top); 
X	sprintf(buffer, "xod v%s", VERSION);
X	XStoreName(XtDisplay(top), XtWindow(top), buffer);
X
X	/* see getres.c to see what this does */
X	XodGetResources(top);
X	FigureRevVidSeq();
X	DisplayFullPage(0, 0);
X	/* do what may have been told us via cmd line args */
X	CmdLineInit();
X
X	/* create all the dialogs we'll be using */
X	NewFileDialog = CreateDialog(top, "newFile", Okay | Cancel);
X	SearchDialog = CreateDialog(top, "search", Okay | Cancel);    
X	GotoByteDialog = CreateDialog(top, "gotoByte", Okay | Cancel);    
X	HelpDialog = CreateHelpDialog(top);
X
X	XtMainLoop();
X}
SHAR_EOF
chmod 0644 main.c || echo "restore of main.c fails"
set `wc -c main.c`;Sum=$1
if test "$Sum" != "4647"
then echo original size 4647, current size $Sum;fi
echo "x - extracting mkwidgets.c (Text)"
sed 's/^X//' << 'SHAR_EOF' > mkwidgets.c &&
Xstatic char *RcsID = "$Id: mkwidgets.c,v 1.7 1993/03/02 01:03:48 rfs Exp $";
X
X/*
X * $Log: mkwidgets.c,v $
X * Revision 1.7  1993/03/02  01:03:48  rfs
X * Make cc stop complaining.
X *
X * Revision 1.6  1993/03/02  00:48:02  rfs
X * Added going to absolute byte routines.
X *
X * Revision 1.5  1993/02/26  21:39:59  rfs
X * *** empty log message ***
X *
X * Revision 1.4  1993/02/14  01:16:04  rfs
X * The byte-offset label now responds to button press.
X *
X * Revision 1.3  1993/02/13  23:26:42  rfs
X * Create ErrorDialog.
X *
X * Revision 1.2  1993/02/13  14:35:39  rfs
X * *** empty log message ***
X *
X * Revision 1.1  1993/02/13  02:20:18  rfs
X * Initial revision
X *
X * Revision 1.1  1993/02/13  02:20:18  rfs
X * Initial revision
X *
X*/
X
X#include <xod.h>
X#include <X11/Xaw/Paned.h>
X#include <X11/Xaw/Form.h>
X#include <X11/Xaw/Box.h>
X#include <X11/Xaw/Command.h>
X#include <X11/Xaw/Toggle.h>
X#include <X11/Xaw/MenuButton.h>
X#include <X11/Xaw/SimpleMenu.h>
X#include <X11/Xaw/SmeLine.h>
X#include <X11/Xaw/SmeBSB.h>
X#include <buttons.h>
X#include <xod.pt>
X#include <frowny.xbm>
X
Xstatic XtActionsRec actions_table[] = {
X  {(String)"fix-menu", (XtActionProc)Junk},
X  {(String)"set-dialog-button", (XtActionProc)SetDialogButton}
X};
X
Xstatic Widget 
X    parent_widget,
X    formy_widget,
X    fileButton_widget, fileMenu_widget,
X    editButton_widget, editMenu_widget,
X    pane_widget, 
X    form_widget;
X
Xvoid 
XPopupGotoByte(void) {
X	String gotobyte;
X	char buffer[MAXLEN];
X	long addr;
X	int stat, len;
X
X	stat = PopupDialog(GotoByteDialog, "Go to byte:", "", &gotobyte,
X		XtGrabExclusive);
X	if (stat == Okay) {
X		addr = AddressConvert(gotobyte);
X		CursorToAbsByte(addr);
X	}
X}
X
Xvoid 
XPopupAdvanceToByte(char *direction) {
X	String gotobyte;
X	char buffer[MAXLEN], *label;
X	long addr, bias;
X	int stat, len, line, moff;
X
X	if (*direction == '+')
X		label = "Ahead n bytes:";
X	else
X		label = "Back n bytes:";
X	DataLocation(&line, &moff);
X	addr = (line*BytesHoriz) + moff + AbsByteOffset();
X	stat = PopupDialog(GotoByteDialog, label, "", &gotobyte,
X		XtGrabExclusive);
X	if (stat == Okay) {
X		bias = AddressConvert(gotobyte);
X		addr += (*direction == '+') ? bias : -bias;
X		if (addr < 0) addr = 0;
X		CursorToAbsByte(addr);
X	}
X}
X
X/* make all the widgets we'll be needing */
Xvoid
XMakeWidgets(int *argc, char **argv) {
X	Widget w, pane, form, top;
X	int  i;
X
X	top = XtInitialize(NULL, "Xod", NULL, 0, argc, argv);
X	SetTopLevel(top);
X	XtAddActions(actions_table, XtNumber(actions_table));
X
X	parent_widget = XtCreateManagedWidget("parent", panedWidgetClass,
X		top, NULL, 0);
X
X	formy_widget = XtCreateManagedWidget("formy", formWidgetClass,
X		parent_widget, NULL, 0);
X
X	fileMenu_widget = XtCreatePopupShell("menu", 
X		simpleMenuWidgetClass, formy_widget, NULL, 0);
X
X	fileButton_widget = XtCreateManagedWidget("File", menuButtonWidgetClass, 
X		formy_widget, NULL, 0);
X
X	/* put buttons in the File pulldown menu */
X	for (i = 0; i < XtNumber(file_menu); i++) {
X		w = XtCreateManagedWidget(file_menu[i].name, 
X			(file_menu[i].trap ? smeBSBObjectClass : smeLineObjectClass),
X			fileMenu_widget, NULL, 0),
X		XtAddCallback(w, XtNcallback, FileMenuCallback, 
X			(XtPointer)&file_menu[i].id);
X		file_menu[i].widget = w;
X	}
X
X	StatusWidget = XtCreateManagedWidget("status", labelWidgetClass, 
X		formy_widget, NULL, 0);
X	DecodeWidget = XtCreateManagedWidget("decode", labelWidgetClass, 
X		formy_widget, NULL, 0);
X	ByteOffsetWidget = XtCreateManagedWidget("byteoffset", labelWidgetClass,
X		formy_widget, NULL, 0);
X	XtVaSetValues(DecodeWidget, XtNwidth, 200, NULL);
X	XtAddEventHandler(ByteOffsetWidget, ButtonPressMask, False,
X		(XtEventHandler)PopupGotoByte, (XtPointer)NULL);
X	pane = XtCreateManagedWidget("pane", panedWidgetClass, parent_widget,
X		NULL, 0);
X	form = XtCreateManagedWidget("form", formWidgetClass, pane,
X		NULL, 0);
X
X	for (i = 0; i < XtNumber(buttonsMode); i++) {
X		w = XtCreateManagedWidget(buttonsMode[i].name, 
X			(buttonsMode[i].trap ? toggleWidgetClass : commandWidgetClass), 
X			form, NULL, 0);
X		XtAddCallback(w, XtNcallback, EditModeCB, 
X			(XtPointer)&buttonsMode[i]);
X		buttonsMode[i].widget = w;
X    }
X	for (i = 0; i < XtNumber(buttonsDecode); i++) {
X		w = XtCreateManagedWidget(buttonsDecode[i].name, 
X			(buttonsDecode[i].trap ? toggleWidgetClass : commandWidgetClass), 
X			form, NULL, 0);
X		XtAddCallback(w, XtNcallback, EditDecodeCB, 
X			(XtPointer)&buttonsDecode[i]);
X		buttonsDecode[i].widget = w;
X    }
X
X	/* holds the base address of each column */
X	ByteAddress = XtCreateManagedWidget("byteoff", labelWidgetClass, 
X		pane, NULL, 0);
X	/* Create CTW widget. */
X	ctwWidget = XtCreateManagedWidget("vt100", ctwWidgetClass,
X		pane, NULL, 0);
X	XtAddCallback(ctwWidget, XtNmouseCallback, (XtCallbackProc)MouseCB,
X		 (XtPointer)NULL);
X
X	ErrorDialog = ErrorCreateDialog(top, frowny_bits, frowny_width,
X		frowny_height);
X}
SHAR_EOF
chmod 0644 mkwidgets.c || echo "restore of mkwidgets.c fails"
set `wc -c mkwidgets.c`;Sum=$1
if test "$Sum" != "4791"
then echo original size 4791, current size $Sum;fi
echo "x - extracting rotate.c (Text)"
sed 's/^X//' << 'SHAR_EOF' > rotate.c &&
Xstatic char *RcsID = "$Id: rotate.c,v 1.1 1993/02/13 18:40:43 rfs Exp $";
X/*
X * $Log: rotate.c,v $
X * Revision 1.1  1993/02/13  18:40:43  rfs
X * Initial revision
X *
X *
X*/
X
X/**********************************************************************/
X/*   Function  to  rotate a block of memory. Can be used for example  */
X/*   with an array of pointers.					      */
X/**********************************************************************/
X# include	<malloc.h>
X# include	<memory.h>
X
X# if defined(MSDOS) || defined(__MSDOS__)
X# 	define	TMP_SIZE	1024
X# else
X# 	define	TMP_SIZE	8192
X# endif
X
Xstatic void	my_memcpy();
X
X/**********************************************************************/
X/*   If amount > 0 then copy from start=>start+amount.		      */
X/*   If amount < 0 then copy from start+amount=>start.		      */
X/**********************************************************************/
Xvoid
Xrotate_mem(ptr, ptr_end, amount)
Xchar	*ptr;
Xchar	*ptr_end;
Xint	amount;
X{	char	tmpbuf[TMP_SIZE];
X	char	*tmp;
X	int	abs_amount = amount < 0 ? -amount : amount;
X	int	size = ptr_end - ptr;
X
X	if (amount == 0 || size == 0)
X		return;
X
X	if (abs_amount <= TMP_SIZE)
X		tmp = tmpbuf;
X	else
X		tmp = malloc(abs_amount);
X	if (amount < 0) {
X		memcpy(tmp, ptr, abs_amount);
X		memcpy(ptr, ptr + abs_amount, size - abs_amount);
X		memcpy(ptr + size - abs_amount, tmp, abs_amount);
X		}
X	else {
X		memcpy(tmp, ptr + size - abs_amount, abs_amount);
X		my_memcpy(ptr + abs_amount, ptr, size - abs_amount);
X		memcpy(ptr, tmp, abs_amount);
X		}
X	if (tmp != tmpbuf)
X		free(tmp);
X}
Xstatic void
Xmy_memcpy(p1, p2, len)
Xchar	*p1;
Xchar	*p2;
Xint	len;
X{
X	p1 += len;
X	p2 += len;
X	if (((int) p1 & 3) == 0 && ((int) p2 & 3) == 0 && (len & 3) == 0
X	   && sizeof(long) == 4) {
X		while (len >= sizeof(long)) {
X			p1 -= sizeof(long);
X			p2 -= sizeof(long);
X			*(long *) p1 = *(long *) p2;
X			len -= sizeof(long);
X			}
X		}
X	while (len-- > 0)
X		*--p1 = *--p2;
X}
SHAR_EOF
chmod 0644 rotate.c || echo "restore of rotate.c fails"
set `wc -c rotate.c`;Sum=$1
if test "$Sum" != "1908"
then echo original size 1908, current size $Sum;fi
echo "x - extracting utils.c (Text)"
sed 's/^X//' << 'SHAR_EOF' > utils.c &&
Xstatic char *RcsId = "$Id: utils.c,v 1.3 1993/03/02 00:48:38 rfs Exp $";
X
X/*
X * $Log: utils.c,v $
X * Revision 1.3  1993/03/02  00:48:38  rfs
X * Added AddressConvert routine.
X *
X * Revision 1.2  1993/02/13  14:35:15  rfs
X * *** empty log message ***
X *
X * Revision 1.1  1993/02/13  02:20:18  rfs
X * Initial revision
X *
X * Revision 1.1  1993/02/13  02:20:18  rfs
X * Initial revision
X *
X*/
X
X#include "xod.h"
X
X/* Position cursor */
XCursorAt(int x, int y) {
X	char buffer[MAXLEN];
X	sprintf(buffer, "\033[%d;%dH", x, y);
X	SendString(buffer);
X}
X
X/* clear screen and home cursor */
XClearScreen() {
X	char buffer[MAXLEN];
X	sprintf(buffer, "\033[2J%s", DATANORMAL);
X	CursorAt(1, 1);
X	SendString(buffer);
X}
X
X/* convert ASCII address in decimal, octal, or hext to numeric equiv */
Xlong
XAddressConvert(char *caddr) {
X	long addr;
X	char *p, *fmt;
X
X	if (!strncmp(caddr, "0x", 2)) {
X		p = caddr+2;
X		fmt = "%x";
X	}
X	else if (*caddr == '0') {
X		p++;
X		fmt = "%o";
X	}
X	else {
X		p = caddr;
X		fmt = "%d";
X	}
X	sscanf(p, fmt, &addr);
X	return addr;
X}
SHAR_EOF
chmod 0644 utils.c || echo "restore of utils.c fails"
set `wc -c utils.c`;Sum=$1
if test "$Sum" != "1025"
then echo original size 1025, current size $Sum;fi
echo "x - extracting version.h (Text)"
sed 's/^X//' << 'SHAR_EOF' > version.h &&
X#define VERSION "1.01"
SHAR_EOF
chmod 0644 version.h || echo "restore of version.h fails"
set `wc -c version.h`;Sum=$1
if test "$Sum" != "23"
then echo original size 23, current size $Sum;fi
echo "x - extracting xod.1 (Text)"
sed 's/^X//' << 'SHAR_EOF' > xod.1 &&
X.TH XOD 1 "October 15, 1992"
X.SH NAME
Xxod \- X-based octal dump program
X.SH SYNOPSIS
Xxod [options] filename
X.SH DESCRIPTION
X.I xod
Xis a program like the od(1) program, allowing you to examine binary files
Xin several different ways.  The data can be viewed in a variety of
Xfashions, based on command line switches, or menu selectable.  The default
Xviewing mode is hex.
X.LP
XOn the screen, you will see the data displayed in your specified viewing
Xmode, with an ASCII equivalent on the right.  The ASCII on the right
Xshows only printable ASCII characters.  Non-printable ones are shown as
Xwhitespace.
X.LP
XThe screen is divided into 3 areas.  The strip along the top contains
Xthe File button, a status area, a place for decoded binary data, and
Xthe  byte offset (the byte offset in the file where the cursor is located).
X.LP
XThe left side of the screen shows pushbuttons that allow you to do
Xseveral things.  The top bank of buttons allows you to chose
Xthe data view mode (hex, octal, decimal, or ASCII).  The ASCII view mode is
Xlike done od(1).  Small, unprintable ASCII characters are shown by their
XANSI names.  If the byte is > 127, it is shown underlined, but the value
Xdisplayed is < 127.  That is, if you see it underlined, you can assume
Xthat it has a value > 127.
X.LP
XThe buttons below this allow you to decode the data your cursor is
Xon in a variety of fashions.  Merely click the mouse on a byte in
Xthe data area, and then click on a decode mode.  The decoded data will
Xbe displayed at the top of the window.  If you chose to decode in float
Xor double, and the decoded value is a huge number, you can generally
Xassume that the data wasn't a real floating point number.
X.LP
XMoving around the decoded data can be accomplished using the PgUp, PgDn
Xand arrow keys, or certain vi-like or emacs equivalents.  Position the
Xmouse in the data area, and hit "?" to get a popup showing what keystrokes
Xare available to you.
X.LP
XClicking the mouse on the byte offset label (upper right corner of the
Xwindow) brings up a popup, allowing you to specify an absolute byte to
Xgo to.  The address may be supplied in hex (precede address with 0x),
Xoctal (precede address with 0), or decimal.
X.SH OPTIONS
X.IP -x 10
XDisplay data in hex
X.IP -o 10
XDisplay data in octal
X.IP -d 10
XDisplay data in decimal
X.IP -a 10
XDisplay data in ASCII.
X.IP "-off n" 10
XStart displaying the file at offset n.  N may be decimal, octal (begins
Xwith 0), or hex (begins with 0x).
X.IP "-odf type" 10
XSet the offset display format.  This is the legend which shows byte offsets
Xinto the data file.  The default is hex.  Type can be o (octal), d (decimal),
Xor h or x (hex).
X.LP
XAfter choosing a display mode on the command line (hex is the default),
Xthere are radio buttons under the data display area which allow you to
Xview the data in one of 4 ways, at the click of a button.
X.LP
XThe mouse is active over the data area.  Clicking mouse button 1
Xchanges that byte into reverse video.
X.LP
XThe reverse video data byte determines the starting byte for decoding.
XDecoding is accomplished via clicking one of the buttons
Xcorresponding to how you want the data decoded.
X.SH AUTHOR
X.I xod
Xwas written for fast analysis of binary file data.  The Unix-supplied
X.I od
Xwasn't good enough in many situations.  Thus,
X.I xod
Xwas born.  I couldn't find anything similar, so I wrote this.
X.LP
X.I xod
Xis built upon Paul Fox's (paul@demon.co.uk) CTW (color
Xterminal) widget.  This was done because CTW is very fast, and
Xprevented me from having to make this more difficult than it really needed
Xto be.  Xod was written by  RF Starr (starr@wg2.waii.com).
X.SH NOTE
XBefore you run
X.I xod,
Xbe *sure* that the app-defaults file is  loaded somewhere where it
Xcan be found.  The  app-defaults file is named "Xod.ad".  It should be
Xcopied into a valid app-defaults directory, and renamed "Xod".
X.LP
XThe key bindings are not described in the man page.  You can see what they
Xare by hitting "?" with the mouse in the data area.  Not shown in the
Xhelp popup are some emacs bindings.  Try them.
X.SH BUGS
XAs noted in the CTW documentation, the CTW widget
Xhas only been tested on a Sun.  I developed this on a 486 running Linux,
Xand it appears to work fine.  Note that ctw.c has been marginally enhanced.
SHAR_EOF
chmod 0644 xod.1 || echo "restore of xod.1 fails"
set `wc -c xod.1`;Sum=$1
if test "$Sum" != "4234"
then echo original size 4234, current size $Sum;fi
echo "x - extracting xod.h (Text)"
sed 's/^X//' << 'SHAR_EOF' > xod.h &&
X#include <stdio.h>
X#include <fcntl.h>
X#include <string.h>
X#include <X11/X.h>
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#include <X11/Shell.h>
X#include <ctw.h>
X#include <Dialog.h>
X#include <stdlib.h>
X#include <memory.h>
X#include <defines.h>
X#include <gwidgets.h>
X#include <gvars.h>
X
X#ifndef NIL
X#	define NIL 0
X#endif
SHAR_EOF
chmod 0644 xod.h || echo "restore of xod.h fails"
set `wc -c xod.h`;Sum=$1
if test "$Sum" != "329"
then echo original size 329, current size $Sum;fi
echo "x - extracting xod.pt (Text)"
sed 's/^X//' << 'SHAR_EOF' > xod.pt &&
X#if defined(__STDC__) || defined(__cplusplus)
X# define _P_XOD(s) s
X#else
X# define _P_XOD(s) ()
X#endif
X
X
X/* main.c */
Xvoid SetTopLevel _P_XOD((Widget w));
XWidget GetTopLevel _P_XOD((void));
Xchar *XodVersion _P_XOD((void));
Xint gvInit _P_XOD((void));
Xvoid EditModeCB _P_XOD((Widget w, XtPointer client, XtPointer call));
Xvoid EditDecodeCB _P_XOD((Widget w, XtPointer client, XtPointer call));
XXtActionProc Junk _P_XOD((void));
Xvoid FileMenuCallback _P_XOD((Widget w, XtPointer clientData, XtPointer callData));
Xint NextSearch _P_XOD((void));
Xvoid PopupSearch _P_XOD((String message));
Xvoid main _P_XOD((int argc, char **argv));
X
X/* rotate.c */
Xvoid rotate_mem _P_XOD((char *ptr, char *ptr_end, int amount));
X
X/* ctw.c */
Xvoid HandleFocusChange _P_XOD((Widget widget, CtwWidget w, XFocusChangeEvent *event));
Xint ctw_set_font _P_XOD((Widget w, char *font_name));
Xvoid ctw_add_string _P_XOD((CtwWidget w, char *str, int len));
Xint ctw_get_top_line _P_XOD((CtwWidget ctw));
Xvoid ctw_set_top_line _P_XOD((CtwWidget ctw, int top_line));
Xint ctw_get_attributes _P_XOD((CtwWidget w, int **ip, char ***strp));
Xvoid ctw_set_attributes _P_XOD((CtwWidget w, int *ip));
Xvoid ctw_get_selection _P_XOD((CtwWidget w));
X
X/* math_util.c */
Xvoid HpToIeee _P_XOD((int HpType, unsigned char *in, double *out));
Xdouble hp4_2_dbl _P_XOD((unsigned char *in));
Xdouble hp6_2_dbl _P_XOD((unsigned char *in));
Xint dbl_2_hp4 _P_XOD((unsigned char *out, double in));
Xint dbl_2_hp6 _P_XOD((unsigned char *out, double in));
Xvoid math_tst _P_XOD((int argc, char *argv[]));
X
X/* xutils.c */
Xint ResetMouseCoord _P_XOD((void));
Xvoid GetMouseCoord _P_XOD((int *x, int *y));
Xvoid SetMouseCoord _P_XOD((int x, int y));
Xvoid GetCursorOnData _P_XOD((int *x, int *y));
Xvoid SetCursorOnData _P_XOD((int x, int y));
Xint AbsByteOffset _P_XOD((void));
Xint CursorToAbsByte _P_XOD((long addr));
Xvoid UpdateByteOffset _P_XOD((void));
Xvoid DoDecode _P_XOD((int mode));
Xvoid UpdateAll _P_XOD((int mode, long addr));
Xvoid UpdateStatus _P_XOD((void));
Xvoid SetWidgetLabel _P_XOD((Widget w, char *value));
Xint SendString _P_XOD((char *string));
Xvoid get_font_size _P_XOD((CtwWidget w, int *fwidth, int *fheight));
XXtCallbackProc MouseCB _P_XOD((Widget widget, char *name, ctw_callback_t *reason));
Xvoid AddWidgetAssoc _P_XOD((Widget a, Widget b));
XWidget GetWidgetAssoc _P_XOD((Widget w));
X
X/* Dialog.c */
Xvoid SetSelected _P_XOD((Widget w, XtPointer clientData, XtPointer callData));
Xvoid SetDialogButton _P_XOD((Widget w, XEvent *event, String *argv, Cardinal *argc));
XDialog CreateDialog _P_XOD((Widget top_widget, String name, unsigned long options));
Xvoid PopdownDialog _P_XOD((Dialog popup, String *answer));
Xunsigned long PopupDialog _P_XOD((Dialog popup, String message, String suggestion, String *answer, XtGrabKind grab));
Xvoid PositionPopup _P_XOD((Widget top, Widget popup));
Xvoid PositionPopupDialog _P_XOD((Widget top_widget, Widget shell_widget, Dimension *width, Dimension *height));
X
X/* keyhandler.c */
XXtEventHandler keyhandler _P_XOD((Widget w, void *cd, XKeyEvent *event));
X
X/* helpdialog.c */
XWidget CreateHelpDialog _P_XOD((Widget parent));
Xint PopupHelpDialog _P_XOD((void));
XWidget ErrorCreateDialog _P_XOD((Widget parent, char *bits, int width, int height));
Xvoid PopupErrorDialog _P_XOD((Widget w, char *msg));
X
X/* stubs.c */
Xint SetModeWidget _P_XOD((void));
Xint PrintOffset _P_XOD((void));
Xint Search _P_XOD((void));
Xint SetGrepLabel _P_XOD((void));
Xint XmTextSetString _P_XOD((void));
Xint SimulateButton _P_XOD((void));
Xint CorrectOffset _P_XOD((void));
X
X/* byteaddress.c */
Xvoid SetAddressMode _P_XOD((int mode));
Xchar *FmtOffset _P_XOD((long addr));
Xvoid ShowByteAddress _P_XOD((long startaddr));
X
X/* decode.c */
Xint PackedColumn _P_XOD((void));
Xchar *GetFormat _P_XOD((int *width));
Xvoid MouseHighlight _P_XOD((int mousex, int mousey));
Xvoid MouseUnhighlight _P_XOD((int mousex, int mousey));
Xchar *BuildLine _P_XOD((unsigned char *data, int length));
SHAR_EOF
echo "End of part 3"
echo "File xod.pt is continued in part 4"
echo "4" > s2_seq_.tmp
exit 0
-- 
| Bob Starr (starr@wg2.waii.com) | Western Geophysical | Opinions R mine! |


