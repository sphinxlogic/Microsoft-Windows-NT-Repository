#! /bin/sh
#
# If these # comments don't work, trim them. Don't worry about any
# other shell scripts, Configure will trim # comments from them for you.
#
# (If you are trying to port this package to a machine without sh,
# I would suggest you have a look at the prototypical config.h.SH file
# and edit it to reflect your system. Some packages may include samples
# of config.h for certain machines, so you might look for one of those.)
#
# Yes, you may rip this off to use in other distribution packages. This
# script belongs to the public domain and cannot be copyrighted.
#
# (Note: this Configure script was generated automatically. Rather than
# working with this copy of Configure, you may wish to get metaconfig.
# Write to ram@eiffel.com (Raphael Manfredi) and I will send you the
# latest revision of the dist package, which includes metaconfig.)

# $Id: Configure,v 2.0.1.6 92/04/20 17:30:40 ram Exp $
#
# Generated on Sat Jan 11 19:03:07 PST 1992 [metaconfig 2.8 PL13]

cat >/tmp/c1$$ <<EOF

ARGGGHHHH!!!!!

SCO csh still thinks true is false.  Write to SCO today and tell them that next
year Configure ought to "rm /bin/csh" unless they fix their blasted shell. :-)

(Actually, Configure ought to just patch csh in place.  Hmm.  Hmmmmm.  All
we'd have to do is go in and swap the && and || tokens, wherever they are.)

[End of diatribe.  We now return you to your regularly scheduled programming...]
EOF
cat >/tmp/c2$$ <<EOF

OOPS!  You naughty creature!  You didn't run Configure with sh!
I will attempt to remedy the situation by running sh for you...
EOF

true || cat /tmp/c1$$ /tmp/c2$$
true || exec sh $0

export PATH || cat /tmp/c2$$
export PATH || exec sh $0
rm -f /tmp/c1$$ /tmp/c2$$

: sanity checks
PATH=".:$PATH:/bin:/usr/bin:/usr/local/bin:/usr/ucb:/usr/local:/usr/lbin:/usr/ucb:/usr/ucblib"
PATH=$PATH:'/usr/5bin:/etc:/usr/gnu/bin:/usr/new:/usr/new/bin:/usr/nbin'
PATH=$PATH:'/sys5.3/bin:/sys5.3/usr/bin /bsd4.3/bin /bsd4.3/usr/ucb'
PATH=$PATH:'/bsd4.3/usr/bin:/usr/bsd:/bsd43/bin'
export PATH

if test ! -t 0; then
    echo "Say 'sh Configure', not 'sh <Configure'"
    exit 1
fi

(alias) >/dev/null 2>&1 && \
    echo "(I see you are using the Korn shell.  Some ksh's blow up on Configure," && \
    echo "especially on exotic machines.  If yours does, try the Bourne shell instead.)"

test -d UU || mkdir UU
cd UU && rm -f *

case "$1" in
-d) shift; fastread='yes';;
esac

d_eunice=''
d_xenix=''
d_bsd=''
define=''
eunicefix=''
Mcc=''
awk=''
bison=''
cat=''
chgrp=''
chmod=''
chown=''
compress=''
cp=''
cpio=''
cpp=''
csh=''
date=''
echo=''
egrep=''
emacs=''
expr=''
grep=''
inews=''
less=''
line=''
lint=''
ln=''
lp=''
lpr=''
ls=''
mail=''
mailx=''
make=''
mkdir=''
more=''
mv=''
nroff=''
perl=''
pg=''
pmake=''
pr=''
rm=''
rmail=''
sed=''
sendmail=''
sleep=''
smail=''
sort=''
submit=''
tail=''
tar=''
tbl=''
test=''
touch=''
tr=''
troff=''
uname=''
uniq=''
uuname=''
vi=''
zcat=''
Author=''
Date=''
Header=''
Id=''
Locker=''
Log=''
RCSfile=''
Revision=''
Source=''
State=''
bin=''
byteorder=''
cc=''
ccflags=''
ldflags=''
cppflags=''
optimize=''
contains=''
cppstdin=''
cppminus=''
d_bcopy=''
d_getopt=''
d_index=''
d_memcpy=''
d_memset=''
d_perror=''
d_portable=''
d_voidsig=''
signal_t=''
defeditor=''
i_fcntl=''
i_string=''
strings=''
i_sysioctl=''
i_bsdioctl=''
i_syssockio=''
d_voidtty=''
i_termio=''
i_sgtty=''
i_termios=''
libc=''
nm_opt=''
libpth=''
plibpth=''
libs=''
mailer=''
mansrc=''
manext=''
n=''
c=''
package=''
privlib=''
scriptdir=''
spitshell=''
shsharp=''
sharpbang=''
startsh=''
sysman=''
usrinc=''
mips=''
incpath=''
mips_type=''
voidflags=''
defvoidused=''
needbtar=''
wantbtar=''
d_taropt_o=''
hasdes=''
tapedev=''
large=''
d_whoami=''
i_sysselct=''
CONFIG=''
: set package name
package=kit

: Eunice requires " " instead of "", can you believe it
echo " "
: Here we go...
echo "Beginning of configuration questions for $package kit."

define='define'
undef='undef'
smallmach='pdp11 i8086 z8000 i80286 iAPX286'
rmlist='ark[1-9]isdone ark[1-9][0-9]isdone'
trap 'echo " "; rm -f $rmlist; exit 1' 1 2 3 15

: We must find out about Eunice early
eunicefix=':'
if test -f /etc/unixtovms; then
    eunicefix=/etc/unixtovms
fi
if test -f /etc/unixtovms.exe; then
    eunicefix=/etc/unixtovms.exe
fi

: Find out which program gives a meaningful exit status
if ls blurfl >/dev/null 2>&1; then
	if awk '' blurfl >/dev/null 2>&1; then
		check='cat'
	else
		check='awk ""'
	fi
else
	check='ls'
fi

: Now test for existence of everything in MANIFEST
echo " "
if test -f ../MANIFEST; then
	echo "First let's make sure your kit is complete.  Checking..."
	: some grep do not return a proper exit status
	grep '^---' ../MANIFEST > .grepmani 2>/dev/null
	if test -s .grepmani; then
(cd ..; eval $check `awk '!/^.*\/$/{if (b) print $1}
/^---/{b=1}' MANIFEST` || kill $$) >/dev/null
	else
(cd ..; eval $check `awk '!/^.*\/$/{print $1}' MANIFEST` || kill $$) >/dev/null
	fi
	echo "Looks good..."
else
	echo "No MANIFEST found. Hope your kit is complete !"
fi
rm -f .grepmani

: list of known cpp symbols
attrlist="DGUX M_I186 M_I286 M_I386 M_I8086 M_XENIX UTS __DGUX__"
attrlist="$attrlist _AIX __STDC__ __m88k__ ansi bsd4_2 gcos gimpel"
attrlist="$attrlist hp9000s300 hp9000s500 hp9000s800 hpux"
attrlist="$attrlist i186 i386 i486 i8086 iAPX286 ibm interdata"
attrlist="$attrlist m88k mc300 mc500 mc68000 mc68k mc700 mert"
attrlist="$attrlist mips ns16000 ns32000 nsc32000 os pdp11 posix pyr"
attrlist="$attrlist sinix sony sparc sun tower tower32 tower32_600"
attrlist="$attrlist tower32_800 tss u3b2 u3b20 u3b200 u3b5 ultrix unix"
attrlist="$attrlist vax venix xenix z8000"

: no include file wanted by default
inclwanted=''

: change the next line if compiling for Xenix/286 on Xenix/386
xlibpath='/usr/lib/386 /lib/386'
libpth='/usr/lib/large /lib '$xlibpth' /lib/large'
libpth=$libpth' /usr/lib/small /lib/small'

: full support for void wanted by default
defvoidused=15


: some greps do not return status, grrr.
echo "grimblepritz" >grimble
if grep blurfldyick grimble >/dev/null 2>&1 ; then
    contains=contains
elif grep grimblepritz grimble >/dev/null 2>&1 ; then
    contains=grep
else
    contains=contains
fi
rm -f grimble
: the following should work in any shell
case "$contains" in
contains*)
    echo " "
    echo "AGH!  Grep doesn't return a status.  Attempting remedial action."
    cat >contains <<'EOSS'
grep "$1" "$2" >.greptmp && cat .greptmp && test -s .greptmp
EOSS
chmod +x contains
esac

: first determine how to suppress newline on echo command
echo " "
echo "Checking echo to see how to suppress newlines..."
(echo "hi there\c" ; echo " ") >.echotmp
if $contains c .echotmp >/dev/null 2>&1 ; then
    echo "...using -n."
    n='-n'
    c=''
else
    cat <<'EOM'
...using \c
EOM
    n=''
    c='\c'
fi
echo $n "The star should be here-->$c"
echo '*'
rm -f .echotmp

: set up the echo used in my read
myecho="case \"\$xxxm\" in
'') echo $n \"\$rp $c\";;
*) case \"\$rp\" in
	'') echo $n \"[\$xxxm] $c\";;
	*) echo $n \"\$rp [\$xxxm] $c\";;
	esac;;
esac"

: now set up to do reads with possible shell escape and default assignment
cat <<EOSC >myread
xxxm=\$dflt
$myecho
case "\$fastread" in
yes) case "\$dflt" in
	'') ans='!';;
	*) ans=''; echo " " ;;
	esac;;
*) ans='!';;
esac
while expr "X\$ans" : "X!" >/dev/null; do
	read answ
	set x \$xxxm
	shift
	aok=''; eval "ans=\"\$answ\"" && aok=y
	case  "\$answ" in
	"\$ans")
		case "\$ans" in
		!)
			sh
			echo " "
			$myecho
			;;
		!*)
			set x \`expr "X\$ans" : "X!\(.*\)\$"\`
			shift
			sh -c "\$*"
			echo " "
			$myecho
			;;
		esac;;
	*)
		case "\$aok" in
		y)
			echo "*** Substitution done -- please confirm."
			xxxm="\$ans"
			ans=\`echo $n "\$ans$c" | tr '\012' ' '\`
			xxxm="\$ans"
			ans=!
			;;
		*)
			echo "*** Error -- try again."
			ans=!
			;;
		esac
		$myecho
		;;
	esac
done
case "\$ans" in
'') ans="\$xxxm";;
esac
EOSC

: general instructions
cat <<EOH
 
This installation shell script will examine your system and ask you questions
to determine how the kit package should be installed.  If you get stuck
on a question, you may use a ! shell escape to start a subshell or execute a
command.  Many of the questions will have default answers in square brackets;
typing carriage return will give you the default.

On some of the questions which ask for file or directory names you are allowed
to use the ~name construct to specify the login directory belonging to "name",
even if you don't have a shell which knows about that.  Questions where this is
allowed will be marked "(~name ok)".

EOH
rp=''
dflt="Type carriage return to continue"
. myread
cat <<'EOH'

The prompter used in this script allows you to use shell variables and
backticks in your answers.  You may use $1, $2, etc...  to refer to the words
in the default answer, as if the default line was a set of arguments given to a
script shell.  This means you may also use $* to repeat the whole default line,
so you do not have to re-type everything to add something to the default.

Everytime there is a substitution, you will have to confirm.  If there is an
error (e.g. an unmatched backtick), the default answer will remain unchanged
and you will be prompted again.

If you are in a hurry, you may run 'Configure -d'.  This will bypass nearly all
the questions and use the computed defaults (or the previous answers if there
was already a config.sh file).

EOH
. myread
cat <<EOH

Much effort has been expended to ensure that this shell script will run on any
Unix system.  If despite that it blows up on yours, your best bet is to edit
Configure and run it again.  Also, let me (ram@eiffel.com)
know how I blew it.  If you can't run Configure for some reason, you'll have to
generate a config.sh file by hand.

This installation script affects things in two ways:

1) it may do direct variable substitutions on some of the files included
   in this kit.
2) it builds a config.h file for inclusion in C programs.  You may edit
   any of these files as the need arises after running this script.

If you make a mistake on a question, there is no easy way to back up to it
currently.  The easiest thing to do is to edit config.sh and rerun all the SH
files.  Configure will offer to let you do this before it runs the SH files.

EOH
dflt="Type carriage return to continue"
. myread

: see if sh knows # comments
echo " "
echo "Checking your sh to see if it knows about # comments..."
if sh -c '#' >/dev/null 2>&1 ; then
	echo "Your sh handles # comments correctly."
	shsharp=true
	spitshell=cat
	echo " "
	echo "Okay, let's see if #! works on this system..."
	echo "#!/bin/cat" >try
	$eunicefix try
	chmod +x try
	try > today
	if test -s today; then
		echo "It does."
		sharpbang='#!'
	else
		echo "#! /bin/cat" > try
		$eunicefix try
		chmod +x try
		try > today
		if test -s today; then
			echo "It does."
			sharpbang='#! '
		else
			echo "It doesn't."
			sharpbang=': use '
		fi
	fi
else
	echo "Your sh doesn't grok # comments--I will strip them later on."
	shsharp=false
	echo "exec grep -v '^[ 	]*#'" >spitshell
	chmod +x spitshell
	$eunicefix spitshell
	spitshell=`pwd`/spitshell
	echo "I presume that if # doesn't work, #! won't work either!"
	sharpbang=': use '
fi
rm -f try today

: figure out how to guarantee sh startup
echo " "
echo "Checking out how to guarantee sh startup..."
startsh=$sharpbang'/bin/sh'
echo "Let's see if '$startsh' works..."
cat >try <<EOSS
$startsh
set abc
test "$?abc" != 1
EOSS

chmod +x try
$eunicefix try
if try; then
    echo "Yup, it does."
else
    echo "Nope.  You may have to fix up the shell scripts to make sure sh runs them."
fi
rm -f try

: find out where common programs are
echo " "
echo "Locating common programs..."
cat <<EOSC >loc
$startsh
case \$# in
0) exit 1;;
esac
thing=\$1
shift
dflt=\$1
shift
for dir in \$*; do
    case "\$thing" in
    .)
	if test -d \$dir/\$thing; then
	    echo \$dir
	    exit 0
	fi
	;;
    *)
	if test -f \$dir/\$thing; then
	    echo \$dir/\$thing
	    exit 0
	elif test -f \$dir/\$thing.exe; then
	    : on Eunice apparently
	    echo \$dir/\$thing
	    exit 0
	fi
	;;
    esac
done
echo \$dflt
exit 1
EOSC
chmod +x loc
$eunicefix loc
loclist="
awk
cat
chgrp
chmod
chown
echo
expr
grep
mv
rm
sed
tr
"
trylist="
Mcc
cpp
mail
nroff
rmail
sendmail
tar
test
uname
vi
"
pth=`echo $PATH | sed -e 's/:/ /g'`
pth="$pth /lib /usr/lib"
for file in $loclist; do
    xxx=`loc $file $file $pth`
    eval $file=$xxx
    eval _$file=$xxx
    case "$xxx" in
    /*)
	echo $file is in $xxx.
	;;
    *)
	echo "I don't know where $file is.  I hope it's in everyone's PATH."
	;;
    esac
done
echo " "
echo "Don't worry if any of the following aren't found..."
ans=offhand
for file in $trylist; do
    xxx=`loc $file $file $pth`
    eval $file=$xxx
    eval _$file=$xxx
    case "$xxx" in
    /*)
	echo $file is in $xxx.
	;;
    *)
	echo "I don't see $file out there, $ans."
	ans=either
	;;
    esac
done
case "$egrep" in
egrep)
    echo "Substituting grep for egrep."
    egrep=$grep
    ;;
esac
case "$test" in
test)
    echo "Hopefully test is built into your sh."
    ;;
/bin/test)
    if sh -c "PATH= test true" >/dev/null 2>&1; then
	echo "Using the test built into your sh."
	test=test
    fi
    ;;
*)
    test=test
    ;;
esac
case "$echo" in
echo)
    echo "Hopefully echo is built into your sh."
    ;;
/bin/echo)
    echo " "
    echo "Checking compatibility between /bin/echo and builtin echo (if any)..."
    $echo $n "hi there$c" >foo1
    echo $n "hi there$c" >foo2
    if cmp foo1 foo2 >/dev/null 2>&1; then
	echo "They are compatible.  In fact, they may be identical."
    else
	case "$n" in
	'-n') n='' c='\c';;
	*) n='-n' c='';;
	esac
	cat <<FOO
They are not compatible!  You are probably running ksh on a non-USG system.
I'll have to use /bin/echo instead of the builtin, since Bourne shell doesn't
have echo built in and we may have to run some Bourne shell scripts.  That
means I'll have to use $ans to suppress newlines now.  Life is ridiculous.

FOO
	$echo $n "The star should be here-->$c"
	$echo "*"
    fi
    $rm -f foo1 foo2
    ;;
*)
    : cross your fingers
    echo=echo
    ;;
esac
rmlist="$rmlist loc"

: get old answers, if there is a config file out there
hint=default
if test -f ../config.sh; then
    echo " "
    dflt=y
    rp="I see a config.sh file.  Did Configure make it on THIS system?"
    . myread
    case "$ans" in
    n*|N*) echo "OK, I'll ignore it.";;
    *)  echo "Fetching default answers from your old config.sh file..."
		tmp="$n"
		ans="$c"
		. ../config.sh
		cp ../config.sh .
		n="$tmp"
		c="$ans"
		hint=previous
		;;
	esac
fi

: Restore computed paths
for file in $loclist $trylist; do
	eval $file="\$_$file"
done

: set up shell script to do ~ expansion
cat >filexp <<EOSS
$startsh
: expand filename
case "\$1" in
 ~/*|~)
    echo \$1 | $sed "s|~|\${HOME-\$LOGDIR}|"
    ;;
 ~*)
    if $test -f /bin/csh; then
	/bin/csh -f -c "glob \$1"
	echo ""
    else
	name=\`$expr x\$1 : '..\([^/]*\)'\`
	dir=\`$sed -n -e "/^\${name}:/{s/^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\).*"'\$'"/\1/" -e p -e q -e '}' </etc/passwd\`
	if $test ! -d "\$dir"; then
	    me=\`basename \$0\`
	    echo "\$me: can't locate home directory for: \$name" >&2
	    exit 1
	fi
	case "\$1" in
	*/*)
	    echo \$dir/\`$expr x\$1 : '..[^/]*/\(.*\)'\`
	    ;;
	*)
	    echo \$dir
	    ;;
	esac
    fi
    ;;
*)
    echo \$1
    ;;
esac
EOSS
chmod +x filexp
$eunicefix filexp

: determine where manual pages are on this system
echo " "
case "$sysman" in
'') sysman=`loc . /usr/man/man1 /usr/man/man1 /usr/man/mann /usr/man/manl /usr/man/local/man1 /usr/man/u_man/man1 /usr/share/man/man1 /usr/catman/u_man/man1 /usr/man/l_man/man1 /usr/local/man/u_man/man1 /usr/local/man/l_man/man1 /usr/man/man.L`
    ;;
esac
if test -d "$sysman"; then
	echo "System manual is in $sysman."
else
	echo "Could not find manual pages in source form."
fi

: make some quick guesses about what we are up against
echo " "
$echo $n "Hmm...  $c"
$cat /usr/include/signal.h /usr/include/sys/signal.h >foo 2>/dev/null
if test `echo abc | tr a-z A-Z` = Abc ; then
	xxx=`./loc addbib blurfl $pth`
	if $test -f $xxx; then
		echo "Looks kind of like a USG system with BSD features, but we'll see..."
		echo exit 0 >bsd
		echo exit 0 >usg
		echo exit 1 >v7
	else
		if $contains SIGTSTP foo >/dev/null 2>&1 ; then
			echo "Looks kind of like an extended USG system, but we'll see..."
		else
			echo "Looks kind of like a USG system, but we'll see..."
		fi
		echo exit 1 >bsd
		echo exit 0 >usg
		echo exit 1 >v7
	fi
	d_bsd="$undef"
elif $contains SIGTSTP foo >/dev/null 2>&1 ; then
    echo "Looks kind of like a BSD system, but we'll see..."
	d_bsd="$define"
    echo exit 0 >bsd
    echo exit 1 >usg
    echo exit 1 >v7
else
    echo "Looks kind of like a Version 7 system, but we'll see..."
	d_bsd="$undef"
    echo exit 1 >bsd
    echo exit 1 >usg
    echo exit 0 >v7
fi
case "$eunicefix" in
*unixtovms*)
    cat <<'EOI'
There is, however, a strange, musty smell in the air that reminds me of
something...hmm...yes...I've got it...there's a VMS nearby, or I'm a Blit.
EOI
    echo "exit 0" >eunice
    eunicefix=unixtovms
    d_eunice="$define"
: it so happens the Eunice I know will not run shell scripts in Unix format
	;;
*)
    echo " "
    echo "Congratulations.  You aren't running Eunice."
    eunicefix=':'
    d_eunice="$undef"
    echo "exit 1" >eunice
	;;
esac
if test -f /xenix; then
    echo "Actually, this looks more like a XENIX system..."
    echo "exit 0" >xenix
	d_xenix="$define"
else
    echo " "
    echo "It's not Xenix..."
    echo "exit 1" >xenix
	d_xenix="$undef"
fi
chmod +x xenix
$eunicefix xenix
if test -f /venix; then
    echo "Actually, this looks more like a VENIX system..."
    echo "exit 0" >venix
else
    echo " "
    if xenix; then
	: null
    else
	echo "Nor is it Venix..."
    fi
    echo "exit 1" >venix
fi
chmod +x bsd usg v7 eunice venix
$eunicefix bsd usg v7 eunice venix
$rm -f foo
rmlist="$rmlist bsd usg v7 eunice venix xenix"

: see if we need a special compiler
echo " "
if usg; then
	case "$cc" in
	'') case "$Mcc" in
		/*) dflt='Mcc';;
		*) case "$large" in
			-M*) dflt='cc';;
			*)	if $contains '\-M' $sysman/cc.1 >/dev/null 2>&1 ; then
					if $contains '\-M' $sysman/cpp.1 >/dev/null 2>&1; then
						dflt='cc'
					else
						dflt='cc -M'
					fi
				else
					dflt='cc'
				fi;;
			esac;;
		esac;;
    *)  dflt="$cc";;
    esac
    $cat <<'EOM'
On some systems the default C compiler will not resolve multiple global
references that happen to have the same name.  On some such systems the "Mcc"
command may be used to force these to be resolved.  On other systems a "cc -M"
command is required.  (Note that the -M flag on other systems indicates a
memory model to use!) If you have the Gnu C compiler, you might wish to use
that instead.

EOM
	rp="What command will force resolution on this system?"
	. myread
	cc="$ans"
else
	case "$cc" in
	'') dflt=cc;;
	*) dflt="$cc";;
	esac
	rp="Use which C compiler?"
	. myread
	cc="$ans"
fi
case "$cc" in
gcc*) cpp=`loc gcc-cpp $cpp $pth`;;
esac

: What should the include directory be ?
echo " "
$echo $n "Hmm...  $c"
case "$usrinc" in
'') dflt='/usr/include';;
*) dflt=$usrinc;;
esac
incpath=''
mips_type=''
if $test -f /bin/mips && /bin/mips; then
	echo "Looks like a MIPS system..."
	$cat >usr.c <<'EOCP'
#ifdef SYSTYPE_BSD43
/bsd43
#endif
EOCP
	if $cc -E usr.c > usr.out && $contains / usr.out >/dev/null 2>&1; then
		dflt='/bsd43/usr/include'
		incpath='/bsd43'
		mips_type='BSD 4.3'
	else
		mips_type='System V'
	fi
	echo "and you're compiling with the $mips_type compiler and libraries."
else
	echo "Doesn't look like a MIPS system."
	echo "exit 1" >mips
	chmod +x mips
	$eunicefix mips
fi
cont=true
while $test "$cont"; do
	echo " "
	rp="Where are the include files you want to use?"
	. myread
	usrinc="$ans"
	if $test -d "$ans"; then
		cont=''
	else
		if $test "$fastread" = yes; then
			dflt=y
		else
			dflt=n
		fi
		rp="Directory $ans doesn't exist.  Use that name anyway?"
		. myread
		dflt=''
		case "$ans" in
		y*) cont='';;
		esac
	fi
done
$rm -f usr.c usr.out

: determine optimize, if desired, or use for debug flag also
case "$optimize" in
' ') dflt="none";;
'') dflt="-O";;
*) dflt="$optimize";;
esac
$cat <<EOH

Some C compilers have problems with their optimizers, by default, $package
compiles with the -O flag to use the optimizer.  Alternately, you might want to
use the symbolic debugger, which uses the -g flag (on traditional Unix systems).
Either flag can be specified here. To use neither flag, specify the word "none".

EOH
rp="What optimizer/debugger flag should be used?"
. myread
optimize="$ans"
case "$optimize" in
'none') optimize=" ";;
esac

case "$ccflags" in
'') case "$cc" in
	*gcc*) dflt='-fpcc-struct-return';;
	*) dflt='';;
	esac
	;;
*) dflt="$ccflags"
	case "$cc" in
	*gcc*) case "$dflt" in
		*-fpcc-struct-return*) ;;
		*) dflt="$dflt -fpcc-struct-return";;
		esac;;
	esac;;
esac

case "$mips_type" in
*BSD*) ;;
'') ;;
*) inclwanted="$inclwanted $usrinc/bsd";;
esac
for thisincl in $inclwanted; do
	if $test -d $thisincl; then
		if $test x$thisincl != x$usrinc; then
			case "$dflt" in
			*$thisincl*);;
			*) dflt="$dflt -I$thisincl";;
			esac
		fi
	fi
done

case "$optimize" in
-g*)
	case "$dflt" in
	*DEBUG*);;
	*) dflt="$dflt -DDEBUG";;
	esac
	;;
esac
if $contains 'LANGUAGE_C' $usrinc/signal.h >/dev/null 2>&1; then
	case "$dflt" in
	*LANGUAGE_C*);;
	*) dflt="$dflt -DLANGUAGE_C";;
	esac
elif $contains 'LANGUAGE_C' $usrinc/sys/signal.h >/dev/null 2>&1; then
	case "$dflt" in
	*LANGUAGE_C*);;
	*) dflt="$dflt -DLANGUAGE_C";;
	esac
fi
if $contains '_NO_PROTO' $usrinc/signal.h >/dev/null 2>&1; then
	case "$dflt" in
	*_NO_PROTO*);;
	*) dflt="$dflt -D_NO_PROTO";;
	esac
elif $contains '_NO_PROTO' $usrinc/sys/signal.h >/dev/null 2>&1; then
	case "$dflt" in
	*_NO_PROTO*);;
	*) dflt="$dflt -D_NO_PROTO";;
	esac
fi
case "$dflt" in
'') dflt=none;;
esac
$cat <<EOH

Your C compiler may want other flags.  For this question you should include
-I/whatever and -DWHATEVER flags and any other flags used by the C compiler,
but you should NOT include libraries or ld flags like -lwhatever.  To use no
flags, specify the word "none".

EOH
set X $dflt
shift
dflt=${1+"$@"}
rp="Any additional cc flags?"
. myread
case "$ans" in
none) ans='';
esac
ccflags="$ans"

: the following weeds options from ccflags that are of no interest to cpp
cppflags="$ccflags"
case "$cc" in
*gcc*) cppflags="$cppflags -D__GNUC__";;
esac
case "$mips_type" in
'');;
*BSD*) cppflags="$cppflags -DSYSTYPE_BSD43";;
esac
case "$cppflags" in
'');;
*)  set X $cppflags
	cppflags=''
	for flag do
		case $flag in
		-D*|-I*|-traditional|-ansi|-nostdinc) cppflags="$cppflags $flag";;
		esac
	done
	case "$cppflags" in
	*-*)  echo "(C preprocessor flags: $cppflags)";;
	esac
	;;
esac

case "$ldflags" in
'') if venix; then
		dflt='-i -z'
	else
		dflt='none'
	fi
	;;
*) dflt="$ldflags";;
esac
echo " "
rp="Any additional ld flags (NOT including libraries)?"
. myread
case "$ans" in
none) ans='';
esac
ldflags="$ans"
rmlist="$rmlist pdp11"

: check for ordering of bytes in a long
case "$byteorder" in
'')
$cat <<'EOM'
  
In the following, larger digits indicate more significance.  A big-endian
machine like a Pyramid or a Motorola 680?0 chip will come out to 4321.  A
little-endian machine like a Vax or an Intel 80?86 chip would be 1234.  Other
machines may have weird orders like 3412.  A Cray will report 87654321.  If
the test program works the default is probably right.
I'm now running the test program...
EOM
    $cat >try.c <<'EOCP'
#include <stdio.h>
main()
{
    int i;
    union {
	unsigned long l;
	char c[sizeof(long)];
    } u;

    if (sizeof(long) > 4)
	u.l = (0x08070605<<32) | 0x04030201;
    else
	u.l = 0x04030201;
    for (i=0; i < sizeof(long); i++)
	printf("%c",u.c[i]+'0');
    printf("\n");
}
EOCP
    if $cc $ccflags try.c -o try >/dev/null 2>&1 ; then
	dflt=`./try`
	case "$dflt" in
	????|????????) echo "(The test program ran ok.)";;
	*) echo "(The test program didn't run right for some reason.)";;
	esac
    else
	dflt='4321'
	echo "(I can't seem to compile the test program.  Guessing big-endian...)"
    fi
    ;;
*)
    echo " "
    dflt="$byteorder"
    ;;
esac
rp="What is the order of bytes in a long?"
. myread
byteorder="$ans"
$rm -f try.c try

: Set private lib path
case "$plibpth" in
'') if mips; then
		plibpth="$incpath/usr/lib /usr/local/lib /usr/ccs/lib"
	else
		plibpth="/usr/ccs/lib /usr/lib /usr/ucblib /usr/local/lib"
	fi;;
esac
libpth="$plibpth $libpth"

: Looking for optional libraries
echo " "
echo "Checking for optional libraries..."
case "$libs" in
'') dflt='';;
*) dflt="$libs";;
esac
case "$libswanted" in
'') libswanted='c_s';;
esac
for thislib in $libswanted; do
	case "$thislib" in
	dbm) thatlib=ndbm;;
	*_s) thatlib=NONE;;
	*) thatlib="${thislib}_s";;
	*) thatlib=NONE;;
	esac
	yyy="$incpath/usr/ccs/lib $incpath/usr/lib $incpath/usr/ucblib"
	yyy="$yyy $incpath/usr/local/lib $incpath/lib"
	xxx=`loc lib$thislib.a X $yyy`
	if $test -f $xxx; then
		echo "Found -l$thislib."
		case "$dflt" in
		*-l$thislib*|*-l$thatlib*);;
		*) dflt="$dflt -l$thislib";;
		esac
	else
		xxx=`loc lib$thislib.a X $libpth`
		if $test -f $xxx; then
			echo "Found $xxx."
			case "$dflt" in
			*$xxx*);;
			*) dflt="$dflt $xxx";;
			esac
		else
			xxx=`loc Slib$thislib.a X $xlibpth`
			if $test -f $xxx; then
				echo "Found -l$thislib."
				case "$dflt" in
				*-l$thislib*|*-l$thatlib*);;
				*) dflt="$dflt -l$thislib";;
				esac
			else
				echo "No -l$thislib."
			fi
		fi
	fi
done
set X $dflt
shift
dflt="$*"
case "$libs" in
'') dflt="$dflt";;
*) dflt="$libs";;
esac
case "$dflt" in
'') dflt='none';;
esac

$cat <<EOM
 
Some versions of Unix support shared libraries, which make executables smaller
but make load time slightly longer.

On some systems, mostly newer Unix System V's, the shared library is included
by putting the option "-lc_s" as the last thing on the cc command line when
linking.  Other systems use shared libraries by default.  There may be other
libraries needed to compile $package on your machine as well.  If your system
needs the "-lc_s" option, include it here.  Include any other special libraries
here as well.  Say "none" for none.
EOM

echo " "
rp="Any additional libraries?"
. myread
case "$ans" in
none) ans='';
esac
libs="$ans"

: get list of predefined functions in a handy place
echo " "
case "$libc" in
'') libc=unknown;;
esac
case "$nm_opt" in
'') if $test -f /mach_boot; then
		nm_opt=''
	elif $test -d /usr/ccs/lib; then
		nm_opt='-p'
	elif $test -f /dgux; then
		nm_opt='-p'
	else
		nm_opt=''
	fi;;
esac
libpth="$plibpth $libpth"
case "$libs" in
*-lc_s*) libc=`loc libc_s.a $libc $libpth`
esac
libnames='';
case "$libs" in
'') ;;
*)  for thislib in $libs; do
	case "$thislib" in
	-l*) thislib=`expr X$thislib : 'X-l\(.*\)'`
	    try=`loc lib$thislib.a blurfl/dyick $libpth`
	    if test ! -f $try; then
		try=`loc lib$thislib blurfl/dyick $libpth`
		if test ! -f $try; then
		    try=`loc $thislib blurfl/dyick $libpth`
		    if test ! -f $try; then
			try=`loc Slib$thislib.a blurfl/dyick $xlibpth`
			if test ! -f $try; then
			    try=''
			fi
		    fi
		fi
	    fi
	    libnames="$libnames $try"
	    ;;
	*) libnames="$libnames $thislib" ;;
	esac
    done
    ;;
esac
set /usr/ccs/lib/libc.so
$test -f $1 || set /usr/lib/libc.so
$test -f $1 || set /usr/lib/libc.so.[0-9]*
$test -f $1 || set /lib/libsys_s.a
eval set \$$#
if test -f "$1"; then
    echo "Your (shared) C library seems to be in $1."
    libc="$1"
elif test -f /lib/libc && test -f /lib/clib; then
    echo "Your C library seems to be in both /lib/clib and /lib/libc."
    libc='/lib/clib /lib/libc'
	if test -f /lib/syslib; then
		echo "(Your math library is in /lib/syslib.)"
		libc="$libc /lib/syslib"
	fi
elif test -f "$libc"; then
    echo "Your C library seems to be in $libc, as you said before."
elif test -f $incpath/usr/lib/libc.a; then
	libc=$incpath/usr/lib/libc.a;
    echo "Your C library seems to be in $libc.  That's fine."
elif test -f /lib/libc.a; then
	libc=/lib/libc.a;
    echo "Your C library seems to be in $libc.  You're normal."
else
    if ans=`./loc libc.a blurfl/dyick $libpth`; test -f "$ans"; then
		:
	elif ans=`./loc libc blurfl/dyick $libpth`; test -f "$ans"; then
		libnames="$libnames "`./loc clib blurfl/dyick $libpth`
	elif ans=`./loc clib blurfl/dyick $libpth`; test -f "$ans"; then
		:
	elif ans=`./loc Slibc.a blurfl/dyick $xlibpth`; test -f "$ans"; then
		:
	elif ans=`./loc Mlibc.a blurfl/dyick $xlibpth`; test -f "$ans"; then
		:
	else
		ans=`./loc Llibc.a blurfl/dyick $xlibpth`
    fi
    if test -f "$ans"; then
		echo "Your C library seems to be in $ans, of all places."
		libc=$ans
	else
		libc='blurfl'
	fi
fi
if $test -f "$libc"; then
	dflt="$libc"
	cat <<EOM

If the guess above is wrong (which it might be if you're using a strange
compiler, or your machine supports multiple models), you can override it here.

EOM
else
	dflt=''
	echo $libpth | tr ' ' '\012' | sort | uniq > libpath
	cat <<EOM
I can't seem to find your C library.  I've looked in the following places:

EOM
	$sed 's/^/	/' libpath
	cat <<EOM

None of these seems to contain your C library. I need to get its name...

EOM
fi
cont=true
while $test "$cont"; do
	rp="Where is your C library?"
	. myread
	libc="$ans"
	if $test -f "$libc"; then
		cont=''
	else
		case "$fastread" in
		yes) dflt=y;;
		*) dflt=n;;
		esac
		rp="File $libc does not exist. Use that name anyway?"
		. myread
		case "$ans" in
		y*) cont='';;
		esac
		dflt=''
	fi
done
echo " "
echo $libc $libnames | tr ' ' '\012' | sort | uniq > libnames
set X `cat libnames`
shift
xxx=files
case $# in 1) xxx=file; esac
echo "Extracting names from the following $xxx for later perusal:"
echo " "
$sed 's/^/	/' libnames
echo " "
$echo $n "This may take a while...$c"
nm $nm_opt $* 2>/dev/null >libc.tmp
$echo $n ".$c"
$grep fprintf libc.tmp > libc.ptf
xscan='eval "<libc.ptf $com >libc.list"; $echo $n ".$c"'
xrun='eval "<libc.tmp $com >libc.list"; echo "done"'
if com="$sed -n -e 's/^.* [ADTS]  *_[_.]*//p' -e 's/^.* [ADTS] //p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^__*//' -e 's/^\([a-zA-Z_0-9$]*\).*xtern.*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e '/|UNDEF/d' -e '/FUNC..GL/s/^.*|__*//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.* D __*//p' -e 's/^.* D //p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^_//' -e 's/^\([a-zA-Z_0-9]*\).*xtern.*text.*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.*|FUNC |GLOB .*|//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$grep '|' | $sed -n -e '/|COMMON/d' -e '/|DATA/d' \
				-e '/ file/d' -e 's/^\([^ 	]*\).*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.*|FUNC |GLOB .*|//p' -e 's/^.*|FUNC |WEAK .*|//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^__//' -e '/|Undef/d' -e '/|Proc/s/ .*//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
else
	nm -p $* 2>/dev/null >libc.tmp
	com="$sed -n -e 's/^.* [ADTS]  *_[_.]*//p' -e 's/^.* [ADTS] //p'";\
	eval "<libc.tmp $com >libc.list"
	if $contains '^fprintf$' libc.list >/dev/null 2>&1; then
		nm_opt='-p'
		echo "done"
	else
		echo " "
		echo "nm didn't seem to work right. Trying ar instead..."
		com=''
		if ar t $libc > libc.tmp; then
			for thisname in $libnames; do
				ar t $thisname >>libc.tmp
			done
			$sed -e 's/\.o$//' < libc.tmp > libc.list
			echo "Ok."
		else
			echo "ar didn't seem to work right."
			echo "Maybe this is a Cray...trying bld instead..."
			if bld t $libc | $sed -e 's/.*\///' -e 's/\.o:.*$//' > libc.list; then
				for thisname in $libnames; do
					bld t $libnames | \
					$sed -e 's/.*\///' -e 's/\.o:.*$//' >>libc.list
					ar t $thisname >>libc.tmp
				done
				echo "Ok."
			else
				echo "That didn't work either.  Giving up."
				exit 1
			fi
		fi
	fi
fi
nm_extract="$com"
if test -f /lib/syscalls.exp; then
	echo " "
	echo "Also extracting names from /lib/syscalls.exp for good ole AIX..."
	$sed -n 's/^\([^ 	]*\)[ 	]*syscall$/\1/p' /lib/syscalls.exp >>libc.list
fi
$rm -f libnames libpath

: set up the script used to warn in case of inconsistency
cat <<'EOSC' >whoa
dflt=y
echo ' '
echo "*** WHOA THERE!!! ***"
echo "    The $hint value for \$$var on this machine was \"$was\"!"
rp="    Keep the $hint value?"
. myread
case "$ans" in
y) td=$was; tu=$was;;
esac
EOSC

: define an is-in-libc? function
inlibc='echo " "; td=$define; tu=$undef;
var=$2; eval "was=\$$2";
if $contains "^$1\$" libc.list >/dev/null 2>&1;
then echo "$1() found.";
	eval "case \"\$$var\" in $undef) . whoa; esac"; eval "$var=\$td";
else echo "$1() not found.";
	eval "case \"\$$var\" in $define) . whoa; esac"; eval "$var=\$tu"; fi'

: see if bcopy exists
case "$d_bcopy" in
$define) d_bcopy="$undef";;
$undef) d_bcopy="$define";;
esac
set bcopy d_bcopy
eval $inlibc
case "$d_bcopy" in
$define) d_bcopy="$undef";;
*) d_bcopy="$define";;
esac

: see if getopt exists
set getopt d_getopt
eval $inlibc

: function used to set $1 to $val
setvar='var=$1; eval "was=\$$1"; td=$define; tu=$undef;
case "$val$was" in
$define$undef) . whoa; eval "$var=\$td";;
$undef$define) . whoa; eval "$var=\$tu";;
*) eval "$var=$val";;
esac'

: see which of string.h or strings.h is needed
echo " "
strings=`loc string.h "" $usrinc $inclwanted`
val="$undef"
if $test -r "$strings"; then
	echo "Using <string.h> instead of <strings.h>."
	if bsd; then
		echo "(Actually, this looks more like it were an USG system)"
	fi
	val="$define"
else
	strings=`loc strings.h "" $usrinc $inclwanted`
	if $test -r "$strings"; then
		echo "Using <strings.h> instead of <string.h>."
		if usg; then
			echo "(Actually, this looks more like it were a BSD system)"
		fi
	else
		echo "No string header found--You'll surely have problems."
	fi
fi
set i_string
eval $setvar

: index or strchr
echo " "
case "$d_index" in
n) dflt=n;;
*) dflt=y;;
esac
if $contains '^index$' libc.list >/dev/null 2>&1 ; then
	if $contains '^strchr$' libc.list >/dev/null 2>&1 ; then
		if $contains strchr "$strings" >/dev/null 2>&1 ; then
			if $contains index "$strings" >/dev/null 2>&1 ; then
				echo "Your system has both index() and strchr()."
				rp="Shall I use index() rather than strchr()?"
				. myread
				case "$ans" in
					n*) val="$define" ;;
					*)  val="$undef" ;;
				esac
			else
				val="$define"
				echo "strchr() found."
			fi
		else
			val="$undef"
			echo "index() found."
		fi
	else
		val="$undef"
		echo "index() found."
	fi
else
	if $contains '^strchr$' libc.list >/dev/null 2>&1 ; then
		val="$define"
		echo "strchr() found."
	else
		echo "No index() or strchr() found!"
		val="$undef"
	fi
fi
set d_index
eval $setvar

: see if memcpy exists
set memcpy d_memcpy
eval $inlibc

: see if memset exists
set memset d_memset
eval $inlibc

: see if perror exists
echo " "
if $contains '^perror$' libc.list >/dev/null 2>&1; then
    echo 'perror() found.'
    d_perror="$undef"
else
    echo "perror() not found -- Won't be able to give precise error messages."
    d_perror="$define"
fi

: see if this is an fcntl system
echo " "
if $test -r $usrinc/fcntl.h ; then
    val="$define"
    echo "<fcntl.h> found."
else
    val="$undef"
    echo "No <fcntl.h> found, but that's ok."
fi
set i_fcntl
eval $setvar

: see how we invoke the C preprocessor
echo " "
echo "Now, how can we feed standard input to your C preprocessor..."
cat <<'EOT' >testcpp.c
#define ABC abc
#define XYZ xyz
ABC.XYZ
EOT
cd ..
echo 'cat >.$$.c; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >cppstdin
chmod 755 cppstdin
wrapper=`pwd`/cppstdin
cd UU
if test "X$cppstdin" != "X" && \
	$cppstdin $cppminus <testcpp.c >testcpp.out 2>&1 && \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "You used to use $cppstdin $cppminus so we'll use that again."
elif test "$cc" = gcc && \
	(echo "Using gcc, eh?  We'll try to force gcc -E using a wrapper..."; \
	$wrapper <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1) ; then
	echo "Yup, we can."
	cppstdin="$wrapper"
	cppminus='';
elif echo 'Maybe "'"$cc"' -E" will work...'; \
	$cc -E <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yup, it does."
	cppstdin="$cc -E"
	cppminus='';
elif echo 'Nope...maybe "'"$cc"' -E -" will work...'; \
	$cc -E - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yup, it does."
	cppstdin="$cc -E"
	cppminus='-';
elif echo 'Uh-uh.  Time to get fancy.  Trying a wrapper...'; \
	$wrapper <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	cppstdin="$wrapper"
	cppminus=''
	echo "Eureka!"
elif echo 'No such luck, maybe "'$cpp'" will work...'; \
	$cpp <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "It works!"
	cppstdin="$cpp"
	cppminus='';
elif echo 'Nixed again...maybe "'$cpp' -" will work...'; \
	$cpp - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Hooray, it works!  I was beginning to wonder."
	cppstdin="$cpp"
	cppminus='-';
elif echo 'Nope...maybe "'"$cc"' -P" will work...'; \
	$cc -P <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yipee, that works!"
	cppstdin="$cc -P"
	cppminus='';
elif echo 'Nope...maybe "'"$cc"' -P -" will work...'; \
	$cc -P - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "At long last!"
	cppstdin="$cc -P"
	cppminus='-';
else
	dflt=''
	rp="No dice.  I can't find a C preprocessor.  Name one:"
	. myread
	cppstdin="$ans"
	$cppstdin <testcpp.c >testcpp.out 2>&1
	if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
		echo "OK, that will do."
	else
		echo "Sorry, I can't get that to work.  Go find one and rerun Configure."
		exit 1
	fi
fi
$rm -f testcpp.c testcpp.out

: get C preprocessor symbols handy
echo " "
echo $attrlist | $tr '[ - ]' '[\012-\012]' >Cppsym.know
$cat <<EOSS >Cppsym
$startsh
case "\$1" in
-l) list=true
    shift
    ;;
esac
unknown=''
case "\$list\$#" in
1|2)
    for sym do
	if $contains "^\$1$" Cppsym.true >/dev/null 2>&1; then
	    exit 0
	elif $contains "^\$1$" Cppsym.know >/dev/null 2>&1; then
		:
	else
	    unknown="\$unknown \$sym"
	fi
    done
    set X \$unknown
    shift
    ;;
esac
case \$# in
0) exit 1;;
esac
echo \$* | $tr '[ - ]' '[\012-\012]' | $sed -e 's/\(.*\)/\\
#ifdef \1\\
exit 0; _ _ _ _\1\\	 \1\\
#endif\\
/' >Cppsym\$\$
echo exit 1 >>Cppsym\$\$
$cppstdin $cppminus <Cppsym\$\$ >Cppsym2\$\$
case "\$list" in
true) $awk 'NF > 5 {print substr(\$6,2,100)}' <Cppsym2\$\$ ;;
*)
    sh Cppsym2\$\$
    status=\$?
    ;;
esac
$rm -f Cppsym\$\$ Cppsym2\$\$
exit \$status
EOSS
chmod +x Cppsym
$eunicefix Cppsym
echo "Your C preprocessor defines the following symbols:"
Cppsym -l $attrlist >Cppsym.true
$cat Cppsym.true
rmlist="$rmlist Cppsym Cppsym.know Cppsym.true"

: see if this is a termio system
val="$undef"
val2="$undef"
val3="$undef"
if $test -r $usrinc/termios.h ; then
	set tcsetattr i_termios
	eval $inlibc
	val3="$i_termios"
fi
echo " "
case "$val3" in
"$define") echo "You have POSIX termios.h... good!";;
*) if Cppsym pyr; then
		case "`bin/universe`" in
		ucb) if $test -r $usrinc/sgtty.h; then
				val2="$define"
				echo "<sgtty.h> found."
			else
				echo "System is pyramid with BSD universe."
				echo "<sgtty.h> not found--you could have problems."
			fi;;
		*) if $test -r $usrinc/termio.h; then
				val="$define"
				echo "<termio.h> found."
			else
				echo "System is pyramid with USG universe."
				echo "<termio.h> not found--you could have problems."
			fi;;
		esac
	elif usg; then
		if $test -r $usrinc/termio.h ; then
			echo "<termio.h> found."
			val="$define"
		elif $test -r $usrinc/sgtty.h ; then
			echo "<sgtty.h> found."
			val2="$define"
		else
			echo "Neither <termio.h> nor <sgtty.h> found--you could have problems."
		fi
	else
		if $test -r $usrinc/sgtty.h ; then
			echo "<sgtty.h> found."
			val2="$define"
		elif $test -r $usrinc/termio.h ; then
			echo "<termio.h> found."
			val="$define"
		else
			echo "Neither <sgtty.h> nor <termio.h> found--you could have problems."
		fi
	fi;;
esac
set i_termio; eval $setvar
val=$val2; set i_sgtty; eval $setvar
val=$val3; set i_termios; eval $setvar

: see if ioctl defs are in sgtty/termio or sys/ioctl
echo " "
if $test -r $usrinc/sys/ioctl.h ; then
    val="$define"
    echo "<sys/ioctl.h> found."
else
    val="$undef"
	$test $i_termio = "$define" && xxx="termio.h"
	$test $i_termios = "$define" && xxx="termios.h"
	$test $i_sgtty = "$define" && xxx="sgtty.h"
	echo "No <sys/ioctl.h> found, assuming ioctl args are defined in <$xxx>."
fi
set i_sysioctl
eval $setvar

: see if signal is declared as pointer to function returning int or void
echo " "
$cppstdin $cppminus $cppflags < $usrinc/signal.h >$$.tmp
if $contains 'int.*\*[ 	]*signal' $$.tmp >/dev/null 2>&1 ; then
    echo "You have int (*signal())() instead of void."
	val="$undef"
	signal_t="int"
elif $contains 'void.*\*[ 	]*signal' $$.tmp >/dev/null 2>&1 ; then
    echo "You have void (*signal())() instead of int."
    val="$define"
	signal_t="void"
elif $contains 'extern[ 	]*[(\*]*signal' $$.tmp >/dev/null 2>&1 ; then
    echo "You have int (*signal())() instead of void."
	val="$undef"
	signal_t="int"
else
	case "$d_voidsig" in
	'') echo "I can't determine whether signal handler returns void or int..."
		dflt=void
		rp="What type does your signal handler returns?"
		. myread
		case "$ans" in
		void) val="$define"; signal_t="void";;
		*) val="$undef"; signal_t="int";;
		esac;;
	*) echo "As you already told me, signal handler returns $signal_t.";;
	esac
fi
set d_voidsig
eval $setvar
$rm -f $$.tmp

: locate the default tape device
echo " "
case "$tapedev" in
'') if set x /dev/rst*; shift; $test -c "$1"; then
		dflt="$1";
	elif set x /dev/rmt*; shift; $test -c "$1"; then
		dflt="$1";
	elif set x /dev/rmt/m*; shift; $test -c "$1"; then
		dflt="$1";
	elif set x /dev/rmt/?; shift; $test -c "$1"; then
		dflt="$1";
	else
		dflt="/dev/rmt8";
	fi
	;;
*) dflt="$tapedev";;
esac
rp='Where is your tape device located?'
. myread
tapedev="$ans"

: check for void type
echo " "
$cat <<EOM
Checking to see how well your C compiler groks the void type...

  Support flag bits are:
    1: basic void declarations.
    2: arrays of pointers to functions returning void.
    4: operations between pointers to and addresses of void functions.
    8: generic void pointers.

EOM
case "$voidflags" in
'')
    $cat >try.c <<'EOCP'
#if TRY & 1
void main() {
#else
main() {
#endif
	extern void moo();	/* function returning void */
	void (*goo)();		/* ptr to func returning void */
#if TRY & 8
	void *hue;		/* generic ptr */
#endif
#if TRY & 2
	void (*foo[10])();
#endif

#if TRY & 4
	if(goo == moo) {
		exit(0);
	}
#endif
	exit(0);
}
EOCP
    if $cc -S -DTRY=$defvoidused try.c >.out 2>&1 ; then
		voidflags=$defvoidused
	echo "It appears to support void to the level $package wants ($defvoidused)."
		if $contains warning .out >/dev/null 2>&1; then
			echo "However, you might get some warnings that look like this:"
			$cat .out
		fi
    else
		echo "Hmm, your compiler has some difficulty with void.  Checking further..."
		if $cc -S -DTRY=1 try.c >/dev/null 2>&1 ; then
			echo "It supports 1..."
			if $cc -S -DTRY=3 try.c >/dev/null 2>&1 ; then
				echo "It also supports 2..."
				if $cc -S -DTRY=7 try.c >/dev/null 2>&1 ; then
					voidflags=7
					echo "And it supports 4 but not 8 definitely."
				else
					echo "It doesn't support 4..."
					if $cc -S -DTRY=11 try.c >/dev/null 2>&1 ; then
						voidflags=11
						echo "But it supports 8."
					else
						voidflags=3
						echo "Neither does it support 8."
					fi
				fi
			else
				echo "It does not support 2..."
				if $cc -S -DTRY=13 try.c >/dev/null 2>&1 ; then
					voidflags=13
					echo "But it supports 4 and 8."
				else
					if $cc -S -DTRY=5 try.c >/dev/null 2>&1 ; then
						voidflags=5
						echo "And it supports 4 but has not heard about 8."
					else
						echo "However it supports 8 but not 4."
					fi
				fi
			fi
		else
			echo "There is no support at all for void."
			voidflags=0
		fi
    fi
esac
dflt="$voidflags";
rp="Your void support flags add up to what?"
. myread
voidflags="$ans"
$rm -f try.* .out

: preserve RCS keywords in files with variable substitution, grrr
Id='$Id'
Log='$Log'

: determine where public executables go
case "$bin" in
'')
    dflt=`loc . /bin /usr/local/bin /usr/lbin /usr/local /usr/bin`
    ;;
*)  dflt="$bin"
    ;;
esac
cont=true
while $test "$cont" ; do
    echo " "
    rp="Where do you want to put the public executables? (~name ok)"
    . myread
    bin="$ans"
    bin=`filexp $bin`
    if test -d $bin; then
	cont=''
    else
	dflt=n
	rp="Directory $bin doesn't exist.  Use that name anyway?"
	. myread
	dflt=''
	case "$ans" in
	y*) cont='';;
	esac
    fi
done

: decide how portable to be
case "$d_portable" in
"$define") dflt=y;;
*)	dflt=n;;
esac
$cat <<'EOH'
 
I can set things up so that your shell scripts and binaries are more portable,
at what may be a noticable cost in performance.  In particular, if you
ask to be portable, the following happens:

     1) Shell scripts will rely on the PATH variable rather than using
	the paths derived above.
     2) ~username interpretations will be done at run time rather than
	by Configure.

EOH
rp="Do you expect to run these scripts and binaries on multiple machines?"
. myread
case "$ans" in
    y*) d_portable="$define"
	for file in $loclist; do
	    eval $file=$file
	done
	;;
    *)  d_portable="$undef" ;;
esac

: see if we need -o option for tar
echo " "
case "$d_taropt_o" in
'') if $test -f "$tar"; then
		if $tar -cf - /dev/null 2>/dev/null | $tar -xof - >/dev/null 2>&1; then
			val="$define"
		else
			val="$undef"
		fi
	else
		val="$undef"
	fi;;
*) val="$d_taropt_o";;
esac
case "$val" in
"$define") echo "I'll use the -o option with tar upon archive extraction.";;
*) echo "Your tar does not seem to support the -o option. I'll ignore it then.";;
esac
set d_taropt_o
eval $setvar

: determine default editor
case "$defeditor" in
'')
    case "$_vi" in
    */*) dflt="$_vi";;
    *) dflt=/usr/ucb/vi;;
    esac
    ;;
*)  dflt="$defeditor"
    ;;
esac
cont=true
while $test "$cont" ; do
	echo " "
	rp="What is the default editor on your system?"
	. myread
	defeditor="$ans"
	if test -f $ans; then
		cont=''
	else
		dflt=n
		rp="File $ans doesn't exist.  Use that name anyway?"
		. myread
		dflt=''
		case "$ans" in
		y*) cont='';;
		esac
	fi
done

: see if des is there and compatible
echo " "
case "$hasdes" in
'') hasdes=false
	xxx=`loc des x $pth`
	case "$xxx" in
	/*) echo "I see you already have a DES in $xxx."
		echo "Let's make sure it is compatible with mine..."
		$cat > dedes.c <<EOP
#include <stdio.h>
main()
{
	char s[10];
	int c;

	while (gets(s)) {
		sscanf(s, "%d", &c);
		putchar(c);
	}
}
EOP
		if $cc -o dedes dedes.c >/dev/null 2>&1; then
			echo "This is a DES try" > des.1
			$tr ' ' '\012' >des.data <<EOD
237 195 33 239 62 135 8 90 191 42 108 230 24 121 207 173 18 98
224 166 63 115 153 79
EOD
			./dedes >des.input <des.data
			$xxx -d -k foo <des.input > des.2 2>&1
			if cmp -s des.1 des.2 >/dev/null 2>&1; then
				echo "Yes, it is! We won't need mine then."
				hasdes=true
			else
				echo "No, it isn't!! But that's ok, I'll use my own version."
				hasdes=false
			fi
		else
			echo "(I can't seem to compile the test program--Using your DES)"
			hasdes=true
		fi
		;;
	*) echo "I don't see any DES implementation out there. I'll use mine."
		;;
	esac
	;;
*) case "$hasdes" in
	true) echo "I already know that your DES is compatible with mine.";;
	*) $cat <<EOM
As before, I'm going to use the DES implementation provided with $package.
EOM
	;;
	esac
	;;
esac
$rm -f dedes.c dedes des.data des.input des.1 des.2

: determine the name of a reasonable mailer
case "$mailer" in
'')
	if $test -f "$sendmail"; then
		dflt="$sendmail"
	elif $test -f "$rmail"; then
		dflt="$rmail"
	elif $test -f /bin/mail; then
		dflt=/bin/mail
	else
		dflt=$mail
	fi
	;;
*)  dflt="$mailer";;
esac
cont=true
while $test "$cont" ; do
	cat <<EOM

I need the full pathname of the program used to deliver mail on your system.
A typical answer would be /usr/lib/sendmail or /bin/rmail, but you may choose
any other program, as long as $package can feed its standard input.

EOM
	rp="Mail transport agent to be used?"
	. myread
	mailer="$ans"
	if test -f $ans; then
		cont=''
	else
		dflt=n
		rp="File $ans doesn't exist.  Use that name anyway?"
		. myread
		dflt=''
		case "$ans" in
		y*) cont='';;
		esac
	fi
done

: determine where manual pages go
$cat <<EOM

$package has manual pages available in source form.
EOM
case "$nroff" in
nroff)
	echo "However, you don't have nroff, so they're probably useless to you."
	case "$mansrc" in
	'') mansrc="none";;
	esac;;
esac
echo "If you don't want the manual sources installed, answer 'none'."
case "$mansrc" in
'')
    dflt="$sysman"
    ;;
*)  dflt="$mansrc"
    ;;
esac
cont=true
while $test "$cont" ; do
    echo " "
    rp="Where do the manual pages (source) go? (~name ok)"
    . myread
	case "$ans" in
	'none') mansrc=''
		cont='';;
	*)
		mansrc=`filexp "$ans"`
		if test -d "$mansrc"; then
			cont=''
		else
			dflt=n
			rp="Directory $mansrc doesn't exist.  Use that name anyway?"
			. myread
			dflt=''
			case "$ans" in
			y*) cont='';;
			esac
		fi;;
	esac
done
case "$mansrc" in
'') manext='0';;
*l) manext=l;;
*n) manext=n;;
*o) manext=l;;
*p) manext=n;;
*C) manext=C;;
*L) manext=L;;
*) manext=1;;
esac

: see if we need badtar
echo " "
case "$needbtar" in
'') xxx=''
	case "$d_taropt_o" in
	"$define") xxx='o';;
	esac
	echo "Checking to see how well 'tar x${xxx}f' sets ownership..."
	(cd /bin; $tar cf - rm) | eval "$tar x${xxx}f -"
	needbtar='true'
	if test -f rm; then
		(cd /bin; ls -l rm) > rm.orig
		ls -l rm > rm.now
		if cmp rm.orig rm.now >/dev/null 2>&1; then
		echo "Your tar does not seem to overwrite ownership -- I'll use badtar."
		else
			echo "Your tar works fine."
			needbtar='false'
		fi
	else
		echo "(My test failed -- Using badtar, just in case.)"
	fi
	;;
*) case "$needbtar" in
	true) echo "I'll pipe badtar's output to tar, so that things run smoothly."
		;;
	*) echo "I'll trust your tar to overwrite file ownership."
		;;
	esac
	;;
esac
$rm -f rm rm.orig rm.now

: does the user want badtar ?
wantbtar='true'
case "$needbtar" in
true) ;;
*) $cat <<EOM

$package comes with badtar, a program which repairs damaged tar files. You
do not need it to run $package, but you may want to compile and install it
anyway. Badtar has its output piped to tar and does some kind of filterting,
like padding files (assuming some blocks on the tape could not be read),
stripping down absolute paths to relative ones by removing the leading '/',
or simply overwriting the ownership of the files. It comes with a manual page.

EOM
	dflt='y'
	rp='Would you like to have badtar installed?'
	. myread
	case "$ans" in
	n*|N*) wantbtar='false';;
	esac
	;;
esac

: determine where private executables go
case "$privlib" in
'')
    dflt=/usr/lib/$package
    test -d /usr/local/lib && dflt=/usr/local/lib/$package
    ;;
*)  dflt="$privlib"
    ;;
esac
$cat <<EOM

The $package package has some auxiliary files that should be put in a library
that is accessible by everyone.  Where do you want to put these "private" but
accessible files?

EOM
rp="Private library path? (~name ok)"
. myread
privlib="$ans"
case "$d_portable" in
"$undef")
    privlib=`filexp $privlib`
    ;;
esac

: determine where public executables go
case "$scriptdir" in
'')
    dflt="$bin"
    : guess some guesses
    $test -d /usr/share/scripts && dflt=/usr/share/scripts
    $test -d /usr/share/bin && dflt=/usr/share/bin
    ;;
*)  dflt="$scriptdir"
    ;;
esac
cont=true
$cat <<EOM
 
Some installations have a separate directory just for executable scripts so
that they can mount it across multiple architectures but keep the scripts in
one spot.  You might, for example, have a subdirectory of /usr/share for this.
Or you might just lump your scripts in with all your other executables.
 
EOM
while $test "$cont" ; do
    rp="Where do you keep publicly executable scripts? (~name ok)"
    . myread
    scriptdir="$ans"
    scriptdir=`./filexp "$scriptdir"`
    if $test -d $scriptdir; then
	cont=''
    else
	case "$fastread" in
	yes) dflt=y;;
	*) dflt=n;;
	esac
	rp="Directory $scriptdir doesn't exist.  Use that name anyway?"
	. myread
	dflt=''
	case "$ans" in
	y*) cont='';;
	esac
    fi
done

echo " "
echo "End of configuration questions."
echo " "

: create config.sh file
echo " "
if test -d ../UU; then
    cd ..
fi
echo "Creating config.sh..."
$spitshell <<EOT >config.sh
$startsh
#
# This file was produced by running the Configure script. It holds all the
# definitions figured out by Configure. Should you modify one of these values,
# do not forget to propagate your changes by running "Configure -d". You may
# instead choose to run each of the .SH files by yourself.
#

d_eunice='$d_eunice'
d_xenix='$d_xenix'
d_bsd='$d_bsd'
define='$define'
eunicefix='$eunicefix'
Mcc='$Mcc'
awk='$awk'
bison='$bison'
cat='$cat'
chgrp='$chgrp'
chmod='$chmod'
chown='$chown'
compress='$compress'
cp='$cp'
cpio='$cpio'
cpp='$cpp'
csh='$csh'
date='$date'
echo='$echo'
egrep='$egrep'
emacs='$emacs'
expr='$expr'
grep='$grep'
inews='$inews'
less='$less'
line='$line'
lint='$lint'
ln='$ln'
lp='$lp'
lpr='$lpr'
ls='$ls'
mail='$mail'
mailx='$mailx'
make='$make'
mkdir='$mkdir'
more='$more'
mv='$mv'
nroff='$nroff'
perl='$perl'
pg='$pg'
pmake='$pmake'
pr='$pr'
rm='$rm'
rmail='$rmail'
sed='$sed'
sendmail='$sendmail'
sleep='$sleep'
smail='$smail'
sort='$sort'
submit='$submit'
tail='$tail'
tar='$tar'
tbl='$tbl'
test='$test'
touch='$touch'
tr='$tr'
troff='$troff'
uname='$uname'
uniq='$uniq'
uuname='$uuname'
vi='$vi'
zcat='$zcat'
Author='$Author'
Date='$Date'
Header='$Header'
Id='$Id'
Locker='$Locker'
Log='$Log'
RCSfile='$RCSfile'
Revision='$Revision'
Source='$Source'
State='$State'
bin='$bin'
byteorder='$byteorder'
cc='$cc'
ccflags='$ccflags'
ldflags='$ldflags'
cppflags='$cppflags'
optimize='$optimize'
contains='$contains'
cppstdin='$cppstdin'
cppminus='$cppminus'
d_bcopy='$d_bcopy'
d_getopt='$d_getopt'
d_index='$d_index'
d_memcpy='$d_memcpy'
d_memset='$d_memset'
d_perror='$d_perror'
d_portable='$d_portable'
d_voidsig='$d_voidsig'
signal_t='$signal_t'
defeditor='$defeditor'
i_fcntl='$i_fcntl'
i_string='$i_string'
strings='$strings'
i_sysioctl='$i_sysioctl'
i_bsdioctl='$i_bsdioctl'
i_syssockio='$i_syssockio'
d_voidtty='$d_voidtty'
i_termio='$i_termio'
i_sgtty='$i_sgtty'
i_termios='$i_termios'
libc='$libc'
nm_opt='$nm_opt'
libpth='$libpth'
plibpth='$plibpth'
libs='$libs'
mailer='$mailer'
mansrc='$mansrc'
manext='$manext'
n='$n'
c='$c'
package='$package'
privlib='$privlib'
scriptdir='$scriptdir'
spitshell='$spitshell'
shsharp='$shsharp'
sharpbang='$sharpbang'
startsh='$startsh'
sysman='$sysman'
usrinc='$usrinc'
mips='$mips'
incpath='$incpath'
mips_type='$mips_type'
voidflags='$voidflags'
defvoidused='$defvoidused'
needbtar='$needbtar'
wantbtar='$wantbtar'
d_taropt_o='$d_taropt_o'
hasdes='$hasdes'
tapedev='$tapedev'
EOT

: add special variables
test -f patchlevel.h && \
awk '/^#define/ {printf "%s=%s\n",$2,$3}' patchlevel.h >>config.sh
echo "CONFIG=true" >>config.sh

: propagate old symbols
if test -f UU/config.sh; then
	<UU/config.sh sort | uniq >UU/oldconfig.sh
	sed -n 's/^\([a-zA-Z_0-9]*\)=.*/\1/p' config.sh config.sh UU/oldconfig.sh |\
	sort | uniq -u >UU/oldsyms
	set X `cat UU/oldsyms`
	shift
	case $# in
	0) ;;
	*)	echo "Hmm...You had some extra variables I don't know about...I'll try to keep 'em..."
	for sym in `cat UU/oldsyms`; do
		echo "    Propagating $hint variable "'$'"$sym..."
		eval 'tmp="$'"${sym}"'"'
		echo "$tmp" | \
		sed -e "s/'/'\"'\"'/g" -e "s/^/$sym='/" -e "s/$/'/" >>config.sh
	done
	;;
	esac
fi

: Finish up
CONFIG=true

echo " "
dflt=''
echo "If you didn't make any mistakes, then just type a carriage return here."
rp="If you need to edit config.sh, do it as a shell escape here:"
. UU/myread
case "$ans" in
'') ;;
*) : in case they cannot read
    eval $ans;;
esac
. ./config.sh

echo " "
echo "Doing variable substitutions on .SH files..."
if test -f MANIFEST; then
	set x `awk '{print $1}' <MANIFEST | $grep '\.SH'`
else
	set x `find . -name "*.SH" -print`
fi
shift
case $# in
0) set x *.SH; shift;;
esac
if test ! -f $1; then
    shift
fi
for file in $*; do
    case "$file" in
    */*)
	dir=`$expr X$file : 'X\(.*\)/'`
	file=`$expr X$file : 'X.*/\(.*\)'`
	(cd $dir && . $file)
	;;
    *)
	. $file
	;;
    esac
done
if test -f config.h.SH; then
    if test ! -f config.h; then
	: oops, they left it out of MANIFEST, probably, so do it anyway.
	. config.h.SH
    fi
fi

if $contains '^depend:' Makefile >/dev/null 2>&1; then
    dflt=n
    $cat <<EOM

Now you need to generate make dependencies by running "make depend".
You might prefer to run it in background: "make depend > makedepend.out &"
It can take a while, so you might not want to run it right now.

EOM
    rp="Run make depend now?"
    . UU/myread
    case "$ans" in
    y*) make depend
	echo "Now you must run a make."
	;;
    *)  echo "You must run 'make depend' then 'make'."
	;;
    esac
elif test -f [Mm]akefile; then
    echo " "
    echo "Now you must run a make."
else
    echo "Done."
fi

$rm -f kit*isdone
$rm -rf UU
: end of Configure
