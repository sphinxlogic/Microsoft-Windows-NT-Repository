/* ta=4		set tabstop=4	*/
/****************************************************************************
*				 	p s f . c		v3										*
*																			*
*	Print text files to postscript printer.									*
*																			*
*	Tony Field: tony@ajfcal.cuc.ab.ca										*
****************************************************************************/
/*
 * $Id: psf.c,v 3.5 1992/06/02 08:16:01 ajf Exp ajf $
*/
/*	Three versions of psf can be compiled:

		psf:		postscript filter for command line use.
			
		psffilter:	used with lp/lpsched.  accepts command line argument.
					Input on stdin. compile with -DPSFFILTER.

		psflpd:		like psffilter, but for lpr/lpd.
					compile with -DPSFFILTER -DFORLPD
 */

#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <setjmp.h>
#include <sys/types.h>

#ifdef ISC22
#define pid_t short
#endif

#if !defined(MSDOS)  &&  !defined(__MSDOS__)
#include <sys/wait.h>
#ifndef WEXITSTATUS
#define WEXITSTATUS(stat_val) ((unsigned)(stat_val) >> 8)
#undef WIFEXITED /* Avoid 4.3BSD incompatibility with Posix.  */
#endif
#ifndef WIFEXITED
#define WIFEXITED(stat_val) (!((stat_val) & 255))
#endif
#endif
#include <math.h>
#include <time.h>
#if defined(MSDOS)  ||  defined(__MSDOS__)
#include <process.h>
#endif
#include <signal.h>
#include "ctp.h"
#include "patchlevel.h"
#include "psf.h"

/*	set up the mechanism for underline display */

#define SHOWU(fp,ps)	fprintf (fp, ") %d showuline\n", ps)

#define NOMINAL_CWIDE	7.2		/* point width for Courier 12-point			*/
#define NOMINAL_POINTS	12		/* standard 12-point for printing			*/

#define NORMAL		0x00		/* bitset for  print_attributes				*/
#define ITALICS		0x01
#define BOLD		0x02
#define UNDERLINE	0x04		/* must be 0x04.  underline is not a font	*/

#define CTLC_CANCEL 0x03		/*	ctl/c is cancel current job				*/
#define CTLD_EOJ	0x04		/* ctl/d is end of postscript job.			*/
#define REQUEST_STATUS 	'\024'	/* ^T */
char c_CTLC_CANCEL[] = { CTLD_EOJ, CTLC_CANCEL } ;
#define READ_ERROR	-2			/*	error cond when read from printer port	*/


/*	Paper physical dimensions.
	The default paper sizes is for a NEC LC890 and is overridden in
	"psfprint.def".
*/

typedef struct		 			/*	measurement in point					*/
{	char	paper_name[60];		/*	name of paper size (for command line)	*/
	char	paper_tray[200];	/*	postscript operator to select this tray	*/
	int		width;				/*	portrait point width of paper			*/
	int		height;				/*	portrait point height of paper			*/
	int		lx, ly, ux, uy;
	int		left_marg;			/*	margin widths (unprintable area)		*/
	int		bot_marg;			/*			"								*/
	int		right_marg;			/*			"								*/
	int		top_marg;			/*			"								*/
	int		x_size;				/*	generated by psf.						*/
	int		y_size;				/*	size after correction for line count	*/
} measure;

measure	*p;		/*	working set of parameters  (points to something below) 	*/
measure	page_types[NPAGE] =
{			{ 	"letter",
				"statusdict begin lettertray end",
				  612,   792,    18,    15,   593,   777
			},
			{ 	"legal",
				"statusdict begin legaltray end",
				  612,  1008,    18,    15,   593,   993
			},
			{	"a4",
				"statusdict begin a4tray end",
				  595,   842,    18,    15,   578,   827
			},
			{	"b5",
				"statusdict begin b5tray end",
				  516,   729,    18,    15,   497,   712
			},
			{	"",			/* end of paper list */
				"",
				 0, 0,  0,  0, 0, 0, 0, 0, 0, 0 
			}
};

char	duplex_mode[200] = "\0";
char	order_default[20] = "Normal";
char	order_normal[100] = "\0";
char	order_reverse[100] = "\0";
char	*order_command = NULL;

char	slots[NSLOTS][200] = 
{			"statusdict begin 1 setpapertray end",
			"statusdict begin 2 setpapertray end",
			"", "", "", ""
} ;
int		nslots = 2;

int		nominal_high;			/*	save original width and height for		*/
int		nominal_wide;			/*		defaults when -M is used.			*/

int		y_top_offset;			/*	offsets for each frame					*/
int		x_left_offset;
int		dx_home[4];				/*	page frame home (0,0) translations		*/
int		dy_home[4];

double	scale_x, scale_y;		/* scale factors for 2-up, 4-up printing	*/
int		real_width;

long	*pg_loc;				/* double side print byte ptr to %%Page:	*/
int		npg_loc;				/* number of elements in pg_loc[]			*/

int		duplex			= 0;	/* duplex mode								*/
int		book 			= 0;	/* book format: double sided				*/
int		bookwork		= 0;	/* book format, 2-up print					*/
int		lines_on_page 	= 60;	/* user print lines on page					*/
int		lines_total 	= 0;	/* total number of lines for scale purposes	*/
int		chars_on_line 	= 80;	/* default number of chars on line			*/
int		landscape 		= 0;	/* 1 = landscape, 0 = portrait layout		*/
int		header    		= 0;	/* 1 = print header at top of each page		*/
int		cross	  		= 0;	/* 1 = print cross on 4-up pages			*/
int		line_number		= 0;	/* current logical line number on page		*/
int		enable_wrap		= 0;	/* enable line wrap if 1.					*/
int		rational_wrap	= 0;	/* wrap lines to right if 1					*/
int		tab_size   		= 8;	/* space translation for tabs.				*/
int		font_number 	= 0;	/* one of the valid fonts in the printer	*/
int		point_size		= 12;	/* can be changed with the -p option		*/
int		extra_space		= 0;	/* if point size and line count specified	*/
int		x_user_offset 	= 0;	/* offsets specified buy user				*/
int		y_user_offset 	= 0;	/* points from physical page edge.			*/
#ifdef FORCETYPE
int		set_paper_tray 	= 1;	/* user has set paper tray selection		*/
#else
int		set_paper_tray 	= 0;	/* user has set paper tray selection		*/
#endif
int		set_line_count 	= 0;	/*				print line count on page	*/
int		set_total_count	= 0;	/*			    total line count on page	*/
int		set_point_size 	= 0;	/*				point size					*/
int		preserve_point	= 0;	/*				preserve point size with -M	*/
int		set_char_count 	= 0;	/*				characters on a line		*/
int		set_paper_bin	= 0;	/*				paper bin (not page size)	*/
char	header_text[100];		/*				header line text			*/

int		print_attribute = 0;	/* such as BOLD, UNDERLINE, ITALICS			*/
int		default_font_number;	/* set with -f option, or 0					*/
int		default_point_size;		/* assumes value due to -p option			*/
int		y_coord			= 0;	/* current logical page y-coordinate, points*/
int		x_coord			= 0;	/* current logical page x-coordinate, points*/
int		page_number;			/* current page number for this file		*/
int		physical_page 	= 0;	/* postscript physical page for multi-up	*/
int		print_postscript = 0; 	/* force print of postscript				*/
int		remove_beginning = 0;	/* remove lines at beginning of job			*/
int		remove_between	= 0;	/* remove lines between printed pages		*/
int		is_a_formfeed	= 0;	/* skip to top of page caused by formfeed	*/
int		end_of_file		= 0;	/* end of printing file						*/
int		save_point_size ;		/* save original point size for headers		*/
int		n_chars;				/*	number of characters on a line			*/
int		reverse_order	= 0;	/* 	print in reverse_order					*/
int		reverse_requested = 0;	/*	user option for reverse order			*/
int		gen_eoj			= 0;	/*	psf: generate ctl/d on end of file		*/
char	fname[100];
char	now[50];				/* time of day for page headers 			*/

#ifdef HOPPER
int		hopper_available = 1;
#else
int		hopper_available = 0;
#endif

/*	to select a font, use 4 * font_number + print_attribute as index.

	Helvetica-Bold = fonts[4 * 1 + 2]
				   = fonts [4 * 1 + ITALICS | BOLD]

	If one of the following fonts is found in "psfprint.def", then it is
	flagged as "available" (fonts_have[i] = 1), if not, it is
	"unavailable". This font list should include all known adobe fonts.
*/
	  
#define NFONTS  	144		/* 	4 variations * 36 font families  */

int	font_count = 48;		/*	4 * 12 default fonts for fonts below	*/
char *fonts[NFONTS] =
{
	/* base font                italics font                bold font                   bold-italics   */

	"Courier",		            "Courier-Oblique",		    "Courier-Bold", 	        "Courier-BoldOblique",
	"Helvetica", 	            "Helvetica-Oblique", 	    "Helvetica-Bold",	        "Helvetica-BoldOblique",
	"Times-Roman", 	            "Times-Italic", 		    "Times-Bold", 		        "Times-BoldItalic",
	"AvantGarde-Book",          "AvantGarde-BookOblique",   "AvantGarde-Demi",          "AvantGarde-DemiOblique",
	"Bookman-Light",            "Bookman-LightItalic",      "Bookman-Demi",             "Bookman-DemiItalic",
	"NewCenturySchlbk-Roman",   "NewCenturySchlbk-Italic",  "NewCenturySchlbk-Bold",    "NewCenturySchlbk-BoldItalic",
	"Palatino-Roman",           "Palatino-Italic",          "Palatino-Bold",            "Palatino-BoldItalic",
	"Helvetica-Narrow",         "Helvetica-Narrow-Oblique", "Helvetica-Narrow-Bold",    "Helvetica-Narrow-BoldOblique",
	"Garamond-Light",			"Garamond-LightItalic",		"Garamond-Bold",			"Garamond-BoldItalic",
	"Korinna-Regular",			"Korinna-KursivRegular",	"Korinna-Bold",				"Korinna-KursivBold",
	"Helvetica-Condensed",		"Helvetica-Condensed-Oblique", "Helvetica-Condensed-Bold", "Helvetica-Condensed-BoldObl",
	"ZapfChancery-MediumItalic","ZapfChancery-MediumItalic","ZapfChancery-MediumItalic","ZapfChancery-MediumItalic"
} ;

int	fonts_used[NFONTS];
int	fonts_iso[NFONTS];				/*	ioslatin1 encoded	*/

#ifdef ISO
int	isolatin = 1;					/*	enable ISOLatin1Encoding by default */
#else
int	isolatin = 0;					/*	disable ISOLatin1Encoding by default */
#endif

int	fonts_have[NFONTS];
unsigned char	xlate[256];			/*	translation vector 	*/
int		need_xlate = 0;				/*	no default xlate	*/
char	copyfile[150];				/*	copy file name from psfprint.def */

int	max_frame	= 1;		/* max number of frames in use */
int	frame		= -1;		/* current frame in use */

FILE	*input_fp, *output_fp;
char	*pipe_name;

/*	input line and input line pointer */
char	*c;
char	line[LONG_STR + 1];
char	shortline[150];

char	*pgmname;

jmp_buf eof_env;

char	*defref = NULL;
FILE	*pdef = NULL;		/*	psfprint.def file	*/

char *ascii_hex = "0123456789abcdefghijklmnopqrstuvwxyz";
#if !defined(MSDOS)  &&  !defined(__MSDOS__)
extern int getpid();
#endif
extern int atoi();

char *malloc();

char *account_file_name = NULL;		/*	accounting file name				*/
char *host = NULL;					/*	accounting host						*/
char *user = NULL;					/*	accounting user						*/
int	printfd = 1;					/*	read from stdout					*/
int	pid;							/*	pid for accounting					*/
int	read_access = 0;				/*	spooler can read from printer, too 	*/
long pages_written = 0;				/*	page count if no access to printer	*/

#ifdef __STDC__
measure *locate_pagetype(char *desired, int printerr);
#else
measure *locate_pagetype();
#endif


#include "psfproto.h"


/****************************************************************************
*	main ()																	*
****************************************************************************/

main (argc, argv)
int		argc;
char	*argv[];
{	int		c, i, j, number;
	extern char *optarg;
	extern int	optind, getopt();
	char	bookfile[100];
	char	*getenv();
	int		narrow2x;
	char	*alt_cmd;
	char	*new_marg;
	int		want_stats = 0;
	char	alt_def_file[200];
	double	atof();
	int		modified_argv = 0;

	pid = getpid();

	if ((pgmname = strrchr (argv[0], '/'))
			|| (pgmname = strrchr (argv[0], '\\'))
			|| (pgmname = strrchr (argv[0], ':')))
		pgmname++;
	else
		pgmname = argv[0];

	copyfile[0] = 0;
	pipe_name = NULL;
	for (i = 0; i < 256;  i++)			/*	initial xlate = no translation */
		xlate[i] = i;
	for (i = font_count;  i < NFONTS;  i++)
		fonts[i] = "N/A";
	for (i = 0;  i < NFONTS;  i++)
		fonts_iso[i] = 0;

	defref = NULL;
	for (i = 0;  i < argc;  i++)		/*	if user sets -u alt.def */
	{	if (strncmp (argv[i], "-u", 2) == 0)
		{	if (strlen (argv[i]) > 2)
				defref = argv[i] + 2;
 		else
				defref = argv[i+1];
			break;
		}
	}
	if (i >= argc)
	{	if ((defref = getenv ("PSFDEF")) == NULL)
			defref = PDEF;
	}

	/*	Read the .def file if it exists	*/

redo_def:
	alt_cmd = malloc (200);
	if (access (defref, 0)  &&  defref != PDEF
							&&  strchr (defref, '/') == NULL  
							&&  strchr (defref, '\\') == NULL)
	{	/* see if file is in same directory as PDEF */
		char *c, *strrchr();
		strcpy (shortline, PDEF);
		if ((c = strrchr (shortline, '/')) == NULL)
		{	if ((c = strrchr (shortline, '\\')) == NULL)
				c = shortline;
			else
				c++;
		}
		else
			c++;
		*c = 0;
		strcat (c, defref);
		defref = shortline;
	}
		
	if ((pdef = fopen (defref, "r")) != NULL)
	{	char	line_type[50];
#if defined(FORLPD)
		char	*quote, *word;
		int		want_new_def = 0;

		/*	get original host, user, and accounting file */
		
		if (modified_argv == 0)
		{
			while ((c = getopt(argc, argv, "cw:l:i:n:h:")) != -1)
			{	switch (c)
				{
				case 'n':	user = optarg;		break;
				case 'h':	host = optarg;		break;
				case 'c':
				case 'w':
				case 'l':
				case 'i':	continue;
				default: ;
				}
			}
			if (optind == argc - 1)
				account_file_name = argv[optind];
			else
				account_file_name = NULL;
		}

		/*	read lpd options from psfprint.def.  Format is:
				*psflpd argv0name opt1 opt2 opt3...
			If -u is in the options, read the new def file.
		*/			

		optind = 1; 		/* reset getopt for possibly new arg list */
		while (fgets (alt_cmd, 200, pdef))
		{	if (*alt_cmd == '#')
				continue;
			alt_cmd[199] = '\0';
			trim (alt_cmd);
			word = nexttok (alt_cmd, " \t'\"");
			if (strcmp (word, "*psflpd") == 0)
			{	word = nexttok (NULL, " \t'\"");
				if (strcmp (word, pgmname) == 0)
				{	/*	create a new argument vector */
					argv = (char **) malloc (sizeof (char *) * 50);
					argv[0] = word;
					modified_argv = 1;
					argc = 1;
					while (word = nexttok (NULL, " \t'\""))
					{	if (*word == '#')	/* quite on comments */
							break;
						if (strncmp (word, "-u", 2) == 0)
						{	/*	get another .def file - but keep all
								provided arguments.
							*/
							if (strlen (word) == 2)
							{	word = nexttok (NULL, " \t'\"");
								if (word)
									strcpy (alt_def_file, word);
								else
								{	fprintf (stderr, "%s: invalid -u option\n", pgmname);
									exit (DISCARD_JOB);
								}
							}
							else
								strcpy (alt_def_file, word + 2);
							defref = alt_def_file;
							want_new_def = 1;
						}
						else
							argv[argc++] = word;
					}
					argv[argc] = NULL;
					break;
				}
			}
			else if (strcmp (word, "*printer") == 0)
				break;
		}
		if (want_new_def)
		{	pdef = NULL;
			fclose (pdef);
			goto redo_def;
		}
		if (modified_argv == 0)
		{	argc = 1;
			argv[1] = NULL;
		}

#endif	/* FORLPD */

		/*	skip to printer definition */
		if (strncmp (alt_cmd, "*printer", 8))
		{	while (fgets (line, 200, pdef))
			{	if (strncmp (line, "*printer", 8) == 0)
					break;
			}
		}
		nslots = 0;
		fgets (line, 200, pdef);		/*	skip printer name 	*/
		while (fgets (line, 200, pdef))
		{	trim (line);
			sscanf (line, "%s%d", line_type, &number);

			if (strcmp (line_type, "*paper") == 0)
			{	for (i = j = 0;  i < number;  i++)
				{	if (i >= NPAGE - 1)
					{	fgets (line, 200, pdef);
						fgets (line, 200, pdef);
						fgets (line, 200, pdef);
						continue;
					}
					if (fgets (line, 200, pdef) == NULL)
						bad_file();
					line[59] = 0;
					trim (line);
					strcpy (page_types[i].paper_name, line);
					if (fgets (line, 99, pdef) == NULL)
						bad_file();
					line[99] = 0;
					trim (line);
					strcpy (page_types[i].paper_tray, line);
					if (fgets (line, 100, pdef) == NULL)
						bad_file();
					trim (line);
					sscanf (line, "%d%d%d%d%d%d",
						&page_types[i].width, &page_types[i].height,
						&page_types[i].lx,    &page_types[i].ly,
						&page_types[i].ux,    &page_types[i].uy);
					j = i;
				}
				page_types[j+1].paper_name[0] = '\0';
			}
				
			else if (strcmp (line_type, "*order") == 0)
			{	fgets (line, 200, pdef);
				line[19] = 0;
				trim (line);
				strcpy (order_default, line);
				if (number > 1)
				{	if (fgets (line, 200, pdef) == NULL)
						bad_file();
					trim (line);
					line[99] = 0;
					strcpy (order_normal, line);
					if (fgets (line, 200, pdef) == NULL)
						bad_file();
					trim (line);
					line[99] = 0;
					strcpy (order_reverse, line);
				}
			}
			
			else if (strcmp (line_type, "*fonts") == 0)
			{	for (i = 0;  i < NFONTS;  i++)
					fonts_have[i] = 0;
				for (i = 0;  i < number;  i++)
				{	if (fgets (line, 200, pdef) == NULL)
						bad_file();
					trim (line);
					for (j = 0;  j < font_count;  j++)
					{	if (compare (fonts[j], line) == 0)
						{	fonts_have[j] = 1;
							break;
						}
					}
				}
			}

			else if (strcmp (line_type, "*slots") == 0)
			{	for (j = 0;  j < NSLOTS;  j++)
					slots[j][0] = 0;
				for (i = j = 0;  i < number;  i++)
				{	if (fgets (line, 200, pdef) == NULL)
						bad_file();
					if (i >= NSLOTS)
						continue;
					line[99] = 0;
					trim (line);
					strcpy (slots[i], line);
					j = i;
				}
				nslots = j + 1;
			}
			else if (strcmp (line_type, "*duplex") == 0)
			{	for (i = 0;  i < number;  i++)
				{	if (fgets (duplex_mode, 200, pdef) == NULL)
						bad_file();
				}
			}

			else if (strcmp (line_type, "*eof") == 0)
				break;
			else
				bad_file();
		}
		replacement_fonts ();
	}
	else /* if no .def, assume all fonts exist */
	{	for (i = 0;  i < font_count;  i++)
			fonts_have[i] = 1;
	}

#ifdef PAPERTYPE
	p = locate_pagetype (PAPERTYPE, 1);
	if (p == NULL)
		p = &page_types[0];
#else
	p = &page_types[0];			/* default to letter size paper	*/
#endif	/* PAPERTYPE */

	*header_text = '\0';
	if (argc > 1  &&  (strcmp (argv[1], "-") == 0  || strcmp (argv[1], "--") == 0))
		usage();

	narrow2x = 0;
	new_marg = NULL;
	while ((c = getopt(argc, argv, "124aEejxhInwDdvzsA:i:m:b:c:g:H:l:L:M:f:t:O:P:p:r:R:u:Y:y:-?")) != -1)
	{	switch (c)
		{
		case '1':
			max_frame = 1;
			break;
			
		case '2':
			if (narrow2x == 0)
				landscape = 1;
			max_frame = 2;
			break;
		
		case '4':
			max_frame = 4;
			break;

		case 'a':
			read_access = 1;
			break;
			
		case 'A':
			account_file_name = optarg;		/*	for lpsched's benifit */
			break;

		case 'b':
			if ((set_paper_bin = atoi (optarg)) > nslots)
			{	if (nslots == 0)
					fprintf (stderr, "%s: no alternate bins permitted\n", pgmname);
				else
					fprintf (stderr, "%s: paper bin greater than %d\n", pgmname, nslots);
				exit (DISCARD_JOB);
			}
			break;

		case 'c':
			chars_on_line = atoi (optarg);
			set_char_count = 1;
			break;

		case 'D':
			duplex = 1;
			if (duplex_mode[0] == 0)
			{	fprintf (stderr, "%s: duplex mode not available\n", pgmname);
				exit (DISCARD_JOB);
			}
			break;
	
		case 'd':
			book = 1;
			break;
					
		case 'e':
			enable_wrap = 1;
			break;
	
		case 'E':
			enable_wrap = 1;
			rational_wrap = 1;
			break;
	
		case 'f':
			if (*optarg > '9'  &&  optarg[1])		/*	at least 2 chars */
			{	/*	character string name of font */
				for (i = 0;  i < font_count;  i += 4)
				{	if (partial_compare (optarg, fonts[i]) == 0)
					{	font_number =  i / 4;
						break;
					}
				}
				if (i >= font_count)
					font_number = 0;
			}
			else
			{	/*	single digit hex */
				font_number = xtoi ((int) *optarg);
				if (font_number > (font_count / 4))
					font_number = 0;
			}
			break;

		case 'g':
			p = locate_pagetype (optarg, 1);
			if (p == NULL)
				exit (DISCARD_JOB);
			set_paper_tray = 1;
			break;

		case 'h':
			header = 1;
			break;

		case 'H':
			header = 2;
			strcpy (header_text, optarg);
			break;

		case 'I':
#ifdef ISO
			isolatin = 0;
#else
			isolatin = 1;
#endif
			break;
	
		case 'i':
			x_user_offset = atof (optarg) * cvt_unit (optarg) + 0.01;
			break;

		case 'l':
			lines_on_page = atoi (optarg);
			set_line_count = 1;
			break;

		case 'j':
			gen_eoj = 1;
			break;
	
		case 'L':
			lines_total = atoi (optarg);
			set_total_count = 1;
			break;

		case 'm':
			y_user_offset = atof (optarg) * cvt_unit(optarg) + 0.01;
			break;
		
		case 'M':
			new_marg = optarg;
			break;

		case 'n':
			landscape = 0;
			narrow2x = 1;
			break;

		case 'O':
			pipe_name = optarg;
			break;

		case 'p':
			point_size = atoi (optarg);
			set_point_size = 1;
			break;

		case 'P':
			point_size = atoi (optarg);
			set_point_size = 1;
			preserve_point = 1;
			break;

		case 'r':
			remove_between = atoi (optarg);
			break;
		
		case 'R':
			remove_beginning = atoi (optarg);
			break;
			
		case 's':
			want_stats = 1;
			break;

		case 't':
			tab_size = atoi (optarg);
			break;
			
		case 'u':		/* already processed */
			break;

		case 'v':
			reverse_requested = 1;
			break;

		case 'w':
			landscape = 1;
			break;
			
		case 'x':
			cross = 1;
			break;

		case 'y':
			user = optarg;
			break;
	
		case 'Y':
			host = optarg;
			break;

		case 'z':
			print_postscript = 1;
			break;

		default:	usage ();
			break;
		}
	}
	if (duplex  ||  pipe_name)		/*	cannot support book mode */
		book = 0;

	if (strncmp (order_default, "Reverse", 7) == 0)		/*	stacking sequence 		*/
		reverse_order = 1;								/*	"Reverse"				*/
	else
		reverse_order = 0;								/*	"Normal"				*/
	if (reverse_requested)								/*	User wants reverse ?	*/
		reverse_order = !reverse_order;					/*		yes					*/
	if (reverse_order  &&  order_reverse[0])			/*	Reverse tray command 	*/
	{	order_command = order_reverse;					/*		yes					*/
		reverse_order = 0;								/*		order_command does the work*/
	}
	else if (reverse_order == 0  &&  order_normal[0])	/*	Force normal order tray?*/
		order_command = order_normal;					/*		yes					*/
	else
		order_command = NULL;							/*	use default action 		*/

	nominal_high = p->uy - p->ly + 1;					/* for default row/col scaling */
	nominal_wide = p->ux - p->lx + 1;		

	if (reverse_requested && book)
	{	fprintf (stderr, "Double sided or book in reverse ordered not supported\n");
		exit (DISCARD_JOB);
	}
	/*	if -M specified, set the imageable area coordinates to reflect
		the deisred margin size.
	*/
	if (new_marg)
	{	char *mc, *v[6];
		int	iv;
		double	fact;

		mc = new_marg;
		iv = 1;
		v[0] = mc;
		while (*mc  &&  iv < 6)
		{	if (*mc == ',')
			{	v[iv++] = mc + 1;
				*mc = 0;
			}
			mc++;
		}
		if (iv < 4)
		{	fprintf (stderr, "Must have 4 margin sizes specified\n");
			exit (DISCARD_JOB);
		}
		if (iv > 4)
			fact = cvt_unit (v[4]);
		else
			fact = cvt_unit (v[3]);

		if (landscape)
		{	if ((iv = atof (v[3]) * fact) > 0)
				p->lx = max (p->lx, (iv + 1));
			if ((iv = atof (v[2]) * fact) > 0)
				p->ux = min (p->ux, p->width  - (iv + 1));
			if ((iv = atof (v[1]) * fact) > 0)
				p->uy = min (p->uy, p->height - (iv + 1));
			if ((iv = atof (v[0]) * fact) > 0)
				p->ly = max (p->ly, (iv + 1));
		}
		else
		{	if ((iv = atof (v[0]) * fact) > 0)
				p->lx = max (p->lx, (iv + 1));
			if ((iv = atof (v[1]) * fact) > 0)
				p->ux = min (p->ux, p->width  - (iv + 1));
			if ((iv = atof (v[2]) * fact) > 0)
				p->uy = min (p->uy, p->height - (iv + 1));
			if ((iv = atof (v[3]) * fact) > 0)
				p->ly = max (p->ly, (iv + 1));
		}
		if (p->ux - p->lx < 200  ||  p->uy - p->ly < 200)
		{	fprintf (stderr, "Margin size is inappropriate\n");
				exit (DISCARD_JOB);
		}
	}
	for (i = 0;  page_types[i].paper_name[0];  i++)
	{	page_types[i].left_marg  = page_types[i].lx;
		page_types[i].bot_marg   = page_types[i].ly;
		page_types[i].top_marg   = (page_types[i].height - 1) - page_types[i].uy;
		page_types[i].right_marg = (page_types[i].width  - 1) - page_types[i].ux;

		page_types[i].x_size = page_types[i].ux - page_types[i].lx + 1;
		page_types[i].y_size = page_types[i].uy - page_types[i].ly + 1;
	}
	if (want_stats)
	{	size_display();
		exit (DISCARD_JOB);
	}
	if (nslots <= 1)
		hopper_available = 0;
	if (reverse_order  ||  (book  &&  hopper_available))
		sprintf (bookfile, "%s%d.bok", TEMPFILE, getpid());
	else
		strcpy (bookfile, BOOKFILE);

	if (optind >=  argc  &&  header == 1)	/* no file name header on stdin */
		header = 0;
	save_point_size = point_size;
	
	(void)	signal (SIGINT, catch);			/*	for lpd quit */

#ifdef PSFFILTER

	if (pipe_name)
	{	if ((output_fp = popen (pipe_name, "w")) == NULL)
		{	fprintf (stderr, "%s: cannot open pipe to %s\n", pgmname, pipe_name);
			exit (DISCARD_JOB);
		}
		read_access = 0;					/*	can't read from pipe */
	}
	else
		output_fp = stdout;
	input_fp  = stdin;
	if (header == 1)
		strcpy (fname, argv[optind]);
	else
		*fname = 0;	

	if (fgets (line, LONG_STR, input_fp) == NULL)
		exit (JOB_IS_DONE);
	if ((strncmp (line, "%!", 2) == 0  ||  strncmp (line, "%%!", 3) == 0)
			&&  print_postscript == 0)
	{	/*	already postscript  copy to output */
		char	last_char;

		if (read_access)
			create_fork ();

		/*	attempt to force tray and bin selection */

		set_bin (set_paper_bin);
		set_tray (set_paper_tray);
		
		if (fputs (line, output_fp) == EOF)
			output_trouble (DISCARD_JOB);
		while ((i = fgetc (input_fp)) != EOF)
		{	if (fputc (i, output_fp) == EOF)
				output_trouble (DISCARD_JOB);
			last_char = i;
		}
		if (last_char != CTLD_EOJ)
			fputc (CTLD_EOJ, output_fp);
		pages_written = -1; /* i.e. we don't know */
	}
	else
	{	/*	standard postscript conversion for file on stdin */

		if (font_number * 4 > font_count)
		{	fprintf (stderr,"Font number invalid....\n");
			usage ();
		}

		if (read_access)
			create_fork ();

		if (book  ||  reverse_order)
		{	if ((output_fp = fopen (bookfile, "w")) == NULL)
			{	fprintf (stderr, "%s: cannot create work file\n", pgmname);
				exit (DISCARD_JOB);
			}
			if ((pg_loc = (long *) malloc (sizeof (long) * MAX_PAGES)) == NULL)
			{	fprintf (stderr, "%s: cannot allocate enough memory\n", pgmname);
				exit (DISCARD_JOB);
			}
			npg_loc = 0;
		}

		for (i = 0;  i < NFONTS;  i++)
			fonts_used[i] = 0;

		page_number = -1;
		line_number = 32000;
		default_point_size = point_size;
		default_font_number = font_number;
		bookwork = book  &&  landscape  &&  (max_frame == 2);

		get_time (now);		
		scale_factors ();
		prologue ();
		start_file ();
		process_file ();
		terminate_printer ();
		output_book (bookfile);
	}
	if (read_access == 0)
		write_accounting (pages_written, 0);

#else	/* not PSFFILTER */

	/*	begin normal "psf" code */

	if (font_number * 4 > font_count)
	{	fprintf (stderr,"Font number invalid....\n");
		usage ();
	}

	if (book  ||  reverse_order)
	{	if ((output_fp = fopen (bookfile, "w")) == NULL)
		{	fprintf (stderr, "%s: cannot create work file\n", pgmname);
			exit (DISCARD_JOB);
		}
		if ((pg_loc = (long *) malloc (sizeof (long) * MAX_PAGES)) == NULL)
		{	fprintf (stderr, "%s: cannot allocate enough memory\n", pgmname);
			exit (DISCARD_JOB);
		}
		npg_loc = 0;
	}
	else	
	{	char	*env_fname;			/*	environment specified output file */
		if (env_fname = getenv ("PSFLP"))
#if defined(MSDOS)  ||  defined (__MSDOS__)
		{	if ((output_fp = fopen (env_fname, "wt")) == NULL)
#else
		{	if ((output_fp = fopen (env_fname, "w")) == NULL)
#endif
			{	fprintf (stderr, "Cannot open output file %s\n", env_fname);
				exit (DISCARD_JOB);
			}
		}
		else
		{	output_fp = stdout;
		}
	}


	for (i = 0;  i < NFONTS;  i++)
		fonts_used[i] = 0;

	page_number = -1;
	line_number = 32000;
	default_point_size = point_size;
	default_font_number = font_number;
	bookwork = book  &&  landscape  &&  (max_frame == 2);
	*fname = 0;	

	get_time (now);		
	scale_factors ();
	prologue ();
	if (optind >=  argc)						/*	process on stdin */
	{	input_fp = stdin;
		start_file ();
		process_file ();
	}
	else 
	{	for ( ;  optind < argc;  optind++)		/*	files from cmd line */
		{	strcpy (fname, argv[optind]);
			if ((input_fp = fopen (argv[optind], "r")) == NULL)
			{	fprintf (stderr, "Unknown file: %s\n", argv[optind]);
				continue;
			}
			start_file ();
			process_file ();
			fclose (input_fp);
		}
	}
	terminate_printer ();

	output_book (bookfile);
	/*	end normal psf code */

#endif	/* PSFFILTER */

	exit (JOB_IS_DONE);
}

#ifdef PSFFILTER

/****************************************************************************
*	create_fork ()															*
*	fork a child to send to printer.  parent reads from printer				*
****************************************************************************/

void create_fork ()
{	int     parent;
	long	pages_printed;
	long	start_count;
	int     status;
	int		log_exit;
	
	request_pagecount (1);
	if ((parent = fork ()) < 0)
		expire ("fork");
	if (parent)
	{	/*	parent: read from printer port until child finishes print */
		start_count = get_page_count ();
		while (wait (&status) == -1)
			if (errno != EINTR)
				expire ("fork wait");
		request_pagecount (0);
		pages_printed = get_page_count () - start_count;
		log_exit = WIFEXITED (status) ? WEXITSTATUS (status) : DISCARD_JOB;
		write_accounting (pages_printed, log_exit);
		fflush (stdout);
		fflush (stderr);
		exit (log_exit);
	}
	/*	child: continue to print the job */
	return;
}

/****************************************************************************
*	write_accounting ()														*
*	send number of printed pages to accounting file. record non-zero exit	*
****************************************************************************/

void write_accounting (pages_printed, log_exit)
long	pages_printed;
int		log_exit;
{	FILE	*accounting;

	if (account_file_name == NULL)
		return;

	if ((accounting = fopen (account_file_name, "a")) != NULL)
	{	if (log_exit)
			(void) fprintf(accounting, "%ld\t%s:%s\ttermination:%d\n", pages_printed, host, user, log_exit);
		else
			(void) fprintf(accounting, "%ld\t%s:%s\n", pages_printed, host, user);
		fclose (accounting);
	}
	else 
	{	time_stamp();
		perror(account_file_name);
	}
}

/****************************************************************************
*	time_stamp ()															*
*	record date stamp into error log file									*
****************************************************************************/

void time_stamp()
{
	int e = errno;
	time_t clock = time((time_t *)0);
	(void) fprintf (stderr, "%s: %.24s ", pgmname, ctime(&clock));
	errno = e;
}

/****************************************************************************
*	expire ()																*
*	create date-stamp and error message.									*
****************************************************************************/

void expire(s)
char *s;
{
	time_stamp ();
	perror (s);
	exit (DISCARD_JOB);
}

/****************************************************************************
*	getc_from_printer ()													*
*	read a character from the printer,  return char or ERROR.				*
****************************************************************************/

int getc_from_printer ()
{
	char c;
	int r;
	
	r = read (printfd, &c, 1);
	if (r == 0)
		return (EOF);
	if (r == 1)
		return (c);
	return (READ_ERROR);		/* error during read */
}

/****************************************************************************
*	abort_job ()															*
*	Abort the current printer job; don't wait for reply.					*
****************************************************************************/

void abort_job() 
{
	(void) fwrite (c_CTLC_CANCEL, 1, sizeof(c_CTLC_CANCEL), output_fp); 
	fflush (output_fp);
}

/****************************************************************************
*	abort_exit ()															*
*	Abort the current printer job and exit. 								*
****************************************************************************/

void abort_exit() 
{	abort_job (); 
	exit (DISCARD_JOB);
	_exit (DISCARD_JOB);
}

/****************************************************************************
*	request_pagecount ()													*
*	request page count from printer as a small postscript job.				*
****************************************************************************/

void request_pagecount (cancel)
int cancel;
{	register int c;
	char	pline[400];

	if (cancel) {
		/* Cancel any incomplete job and discard its output.  */
		abort_job();
		while ((c = getc_from_printer ()) != CTLD_EOJ)
			if (c < 0)
				expire ("pagecount cancel");
	}

	sprintf (pline, "([%d] )print\n%s%s%s%s%s%s%s%s%s%c",
				pid,
				"/GetPageCount {\n",
				"	/str 64 string def\n",
				"	statusdict begin\n",
				"		currentdict/pagecount known {\n",
				"			pagecount str cvs print\n",
				"		} if \n",
				"	 end %statusdict\n",
				"} def\n",
				"GetPageCount\n",
				CTLD_EOJ
			);

	c = strlen (pline);
	if (fwrite (pline, 1, c, output_fp)  !=  c)
		expire ("write pagecount");
}

/****************************************************************************
*	get_page_count ()														*
*	get page count from printer.											*
*	any other messages from printer are logged to the log file.				*
****************************************************************************/

long get_page_count ()
{	long	pc;
	int		c, line_start = 1;
	char	pline[100], *p;

	(void) sprintf (pline, "[%d].", pid);
	p = pline;
	c = getc_from_printer ();
	do
	{	/* Print any false match from the last time through the loop.  */
		fprintf (stderr, "%.*s", (int)(p - pline), pline);

		/*	sync on [ */
		for (;  c != '[';  c = getc_from_printer ())
		{	if (c == EOF  ||  c == READ_ERROR)
				expire ("read page count (1)");
			if (c != CTLD_EOJ)
			{	if (line_start)
					{	time_stamp ();
						line_start = 0;
					}
				fputc (c, stderr);
				if (c == '\n')
					line_start = 1;
			}
		}
		
		p = pline + 1;
		while (1)
		{	c = getc_from_printer();
			if (c == READ_ERROR  ||  c == EOF)
				expire ("read page count error (2)");
			if (*p == c)
				p++;
			else
				break;
		}
	
	} while (*p != '.'  ||  c != ' ');

	if (!line_start)
		fputc ('\n', stderr);

	/*	at page count number.  get value into pc */

	pc = 0;
	for (;;)
	{	c = getc_from_printer ();
		if (isdigit (c))
			pc = pc * 10 + (c - '0');
		else if (c == ' ')
			continue;
		else break;
	}

	wait_for_eoj (c);
	return (pc);
}

/****************************************************************************
*	wait_for_eoj ())														*
*	wait for the expected ctl/d eoj echo from the printer.					*
****************************************************************************/

void wait_for_eoj (c)
int		c;
{
	for (;  c != CTLD_EOJ;  c = getc_from_printer())
	{	if (c == EOF || c == READ_ERROR)
			expire ("eof not eoj");
		if (isascii (c) == 0)
		{	fprintf (stderr, "non-ascii char = %02x\n", c);
			expire("pagecount cancel");
		}
	}
}

#endif /* PSFFILTER */

/****************************************************************************
*	locate_pagetype ()														*
*	look for paper type in table of available types.						*
****************************************************************************/

measure	*locate_pagetype (desired, printerr)
char	*desired;
int		printerr;
{	int		i;
	measure	*p;

	p = NULL;
	for (i = 0;  page_types[i].paper_name[0];  i++)
	{	if (compare (page_types[i].paper_name, desired) == 0)
		{	p = &page_types[i];
			break;
		}
	}
	if (!p)
	{	if (printerr)
		{	fprintf (stderr, "Unknown page type %s.  Choose from: ", desired);
			for (i = 0;  page_types[i].paper_name[0];  i++)
				fprintf (stderr, " %s", page_types[i].paper_name);
			fprintf (stderr, "\n");
		}
	}
	return (p);
}

/****************************************************************************
*	cvt_unit ()																*
*	Determine the margin offset conversion factor to points.				*
****************************************************************************/

double cvt_unit (which)
char *which;
{	double	fact;

	fact = 1.0;
	while (*which)
	{
		if (*which == '.'  ||  isdigit (*which))
		{	which++;
			continue;
		}
		switch (toupper (*which))
		{
		case 'I':	fact = 72.0;		break;		/* inches 	*/
		case 'C':	fact = 72.0 / 2.54;	break;		/* cm	  	*/
		case 'P':	fact = 1.0;			break;		/* points	*/
		case ',':	break;
		default :	fprintf (stderr, "invalid margin unit '%c'\n", *which);
					exit (DISCARD_JOB);
		}
		if (*which++ != ',')
			break;
	}
	return (fact);
}

/****************************************************************************
*	scale_factors ()														*
*	Compute the x and y scale factors.										*
****************************************************************************/

/*					total paper size - unprintable size
	scale factor = --------------------------------------
							print size
*/

void scale_factors ()
{	int	wide;				/*	width needed for char count			*/
	int	high;				/*	points needed for line count		*/
	int	n_lines;			/*	number of lines on a page			*/
	int	i;
	double	char_width;
	double	char_sf, line_sf;
	
	real_width = p->width;		/* for initial axis translate only	*/

	if (landscape)
	{	if ((max_frame == 1) || ( max_frame == 4)  ||  set_point_size)
		{	/* use landscape as basis for line/col counts */
			i = nominal_high;
			nominal_high = nominal_wide;
			nominal_wide = i;
		}
		i = p->height;      p->height    = p->width;        p->width      = i;
		i = p->left_marg;   p->left_marg = p->bot_marg;     p->bot_marg   = i;
		i = p->top_marg;    p->top_marg  = p->right_marg;   p->right_marg = i;
		i = p->lx;		    p->lx        = p->ly;		    p->ly		  = i;
		i = p->ux;		    p->ux        = p->uy;		    p->uy		  = i;
		i = p->x_size;	    p->x_size    = p->y_size;	    p->y_size	  = i;
	}
	x_user_offset = max (0, x_user_offset - p->left_marg);
	y_user_offset = max (0, y_user_offset - p->top_marg);
	p->width -= x_user_offset;		/* reduce effective page size */
	p->height -= y_user_offset;
	p->x_size -= x_user_offset;
	p->y_size -= y_user_offset;

	if (set_point_size)		/*	Attempt to honour point size */
	{	if (preserve_point)
		{	nominal_high = p->y_size;
			nominal_wide = p->x_size;
		}
		char_width = (double) point_size / 12.0 * (double) NOMINAL_CWIDE;
		n_chars = ceil ((double) nominal_wide / char_width);
		char_sf = (double) (nominal_wide) / (double) (char_width * n_chars);
		n_lines = (double) nominal_high / (double) point_size;
		if (set_char_count)
			char_sf *= (double) n_chars / (double) chars_on_line;
		else
			chars_on_line = n_chars;
		line_sf = 1.0;

		if (set_total_count == 0)
			lines_total = n_lines;
		if (set_line_count == 0)
			lines_on_page = n_lines;
		if (lines_total < lines_on_page)
		{	if (set_total_count)
				lines_on_page = lines_total;
			else
				lines_total = lines_on_page;
		}
		if (n_lines != lines_total)
			extra_space = (double) (nominal_high - (lines_total * point_size)) 
							/ (double) (lines_total);

		if (header)				/* compress scale to allow headers */
		{	lines_on_page += 2;
			lines_total += 2;
			line_sf = (double) (lines_total - 2) / (double) (lines_total);
		}
	}
	else
	{	/*	determine independent scale factors to lines and columns
			based on user line and column count. This changes
			the character aspect ration - squashing it vertically
			and/or horizontally.
		*/
		char_width = NOMINAL_CWIDE;
		n_chars = ceil ((double) nominal_wide / (double) char_width);

		if (set_char_count)
			char_sf = (double) n_chars / (double) chars_on_line;
		else
		{	char_sf = 1.0;				/*	no change to char count */
			chars_on_line = n_chars;
		}

		n_lines = (double) nominal_high / (double) point_size;
 
		if (set_total_count == 0)
			lines_total = n_lines;
		if (set_line_count == 0)
			lines_on_page = n_lines;
		if (lines_total < lines_on_page)
		{	if (set_total_count)
				lines_on_page = lines_total;
			else
				lines_total = lines_on_page;
		}
		if (header)				/* compress scale to allow headers */
		{	lines_on_page += 2;
			lines_total += 2;
		}
		line_sf = (double) n_lines / (double) lines_total;
	}

	/*	theoretical points high and wide that we would "like" to
		have for our page - before scaling - including a 1/2 line
		for descenders for the last line.
	*/
	high = ceil ((double) point_size * ((double) n_lines + 0.51));
	wide = ceil (n_chars * char_width);

	switch (max_frame)
	{
	case 1:
		scale_x = (double) (p->x_size) / (double) wide * char_sf;
		scale_y = (double) (p->y_size) / (double) high * line_sf;
		x_left_offset  = (int) ceil ((double) (p->left_marg) / scale_x);
		y_top_offset   = (int) ceil ((double) (p->top_marg) / scale_y);
		x_user_offset = (double) x_user_offset / scale_x;
		y_user_offset = (double) y_user_offset / scale_y;
		p->height = (int)((double) p->height / scale_y);
		p->width  = (int)((double) p->width / scale_x);
		p->bot_marg = ceil ((double) p->bot_marg / scale_y);

		/*	page origin translation vectors	*/

		dx_home[0] = x_user_offset;
		dy_home[0] = 0;
		break;

	case 2:
		scale_x = (double) (p->width - 2 * p->left_marg - 2 * p->right_marg)
				/ (double) (2 * wide) * char_sf;
		scale_y = (double) (p->y_size) / (double) high * line_sf;

		if (landscape == 0  &&  set_line_count == 0)
		{	scale_y /= 2.0;
			lines_total *= 2.0;
			lines_on_page *= 2.0;
		}
		/*	point offsets for margins account for physical "forbidden" area */

		x_left_offset  = (int) ceil ((double) p->left_marg / scale_x);
		y_top_offset   = (int) ceil ((double) p->top_marg / scale_y);

		p->height = (int)((double) p->height / scale_y);
		p->width  = (int)((double) (p->width)  / (scale_x * 2.0));
		p->bot_marg = ceil ((double) p->bot_marg / scale_y);

		x_user_offset = (double) x_user_offset / scale_x;
		y_user_offset = (double) y_user_offset / scale_y;

		/*	page origin translation vectors	*/

		dx_home[0] = x_user_offset;
		dy_home[0] = 0;
		dx_home[1] = p->width;
		dy_home[1] = 0;
		break;
	
	case 4:
		scale_x = (double) (p->width - 2 * p->left_marg - 2 * p->right_marg)
				/ (double) (2 * wide) * char_sf;
		scale_y = (double) (p->height - 2 * p->top_marg - 2 * p->bot_marg)
				/ (double) (2 * high) * line_sf;

		/*	point offsets for margins account for physical "forbidden" area */

		x_left_offset = (int) ceil ((double) p->left_marg / scale_x);
		y_top_offset  = (int) ceil ((double) p->top_marg / scale_y);

		p->height = (int)((double) (p->height)  / (scale_y * 2.0));
		p->width  = (int)((double) (p->width)  / (scale_x * 2.0));
		p->bot_marg = ceil ((double) p->bot_marg / scale_y);

		x_user_offset = (double) x_user_offset / scale_x;
		y_user_offset = (double) y_user_offset / scale_y;

		/*	page origin tranlsation vectors	*/

		dx_home[0] = x_user_offset;
		dy_home[0] = p->height;
		dx_home[1] = p->width;
		dy_home[1] = 0;
		dx_home[2] = -p->width;
		dy_home[2] = -p->height;
		dx_home[3] = p->width;
		dy_home[3] = 0;
		break;

	default: ;
	}
}


/****************************************************************************
*	prologue ()																*
*	generate the require postscript-conformant prologue						*
****************************************************************************/

void prologue ()
{	char	*getlogin(), *me;
	int		c;
	FILE	*fp;

	if (book  || reverse_order)
		fprintf (output_fp, "%%Book file: psf-to-psfdoub\n");
	else
		fprintf (output_fp, "%%!PS-Adobe-\n");
#if !defined(MSDOS)  && !defined(__MSDOS__)
	me = getlogin();
	if (me == NULL)				/* AT&T Unix 3.2 getlogin() is broken */
#endif
	  me = "psf";				/* could use cuserid() instead        */
	fprintf (output_fp, "%%%%Creator: %s\n", me);
	fprintf (output_fp, "%%%%CreationDate: %s\n", now);
	fprintf (output_fp, "%%%%DocumentFonts: (atend)\n");
	fprintf (output_fp, "%%%%Pages: (atend)\n");
	fprintf (output_fp, "%%%%EndComments\n");

	/*	usage:     	(text to underline) <pointsize> showuline
		where:		<pointsize> is current text point size.

		eg:			(text to underline) 12 showuline
	*/
	fprintf (output_fp, "%s%s%s%s%s%s%s%s%s%s%s",
			"/showuline {\n",
			"	/CurPointSize exch def\n",
			"	dup stringwidth pop\n",
			"	gsave\n",
			"	currentfont /FontInfo get dup\n",
			"	/UnderlinePosition get CurPointSize mul 1000 div 0 exch rmoveto exch 0 rlineto\n",
			"	/UnderlineThickness get CurPointSize mul 1000 div setlinewidth stroke\n",
			"	grestore\n",
			"	show\n",
			"} def\n",
			"/mv {moveto} def\n");

	/* iso font encoding
		% Header to convert StandardEncoded fonts to ISOLatin1Encoded fonts.
		% Written by Magnus Hammerin 920226.
		% Copyright (c) 1992 Magnus Hammerin.
		% You may distribute this code freely as long as this note remains intact.

		% Modification and adaption for usage with psf by Leif H (leif@ifm.liu.se)
		%
		% Test to see if the printer supports ISOLatin1Encoding.

		/ReEncodeISO { % <newfontname> <oldfontname> ReEncodeISO
	*/
	if (isolatin)
		fprintf (output_fp, "%s%s%s%s%s%s%s%s%s%s%s%s",
			"/ReEncodeISO {\n",
			"  /ISOLatin1Encoding where {\n",
			"    pop\n",
			"    findfont\n",
			"    dup length dict begin\n",
			"      {1 index /FID ne {def} {pop pop} ifelse} forall\n",
			"      /Encoding ISOLatin1Encoding def\n",
			"      currentdict\n",
			"    end\n",
			"    definefont pop\n",
			"  } { pop pop } ifelse\n",
			"} bind def\n");

	/*	add additional startup prologue code from psfprint.def
		probably for non-English language support.
	*/
	if (pdef)
	{
#ifdef PSFFILTER
 		char	line[LONG_STR + 1];		/* line already has text stream		   */
										/* Jan Fernquist (fer@gorbie.n.tvt.se) */
#endif
		while (fgets (line, LONG_STR, pdef))
		{	if (fputs (line, output_fp) == EOF)
				output_trouble (DISCARD_JOB);
		}
		fclose (pdef);
		pdef = NULL;
	}
	
	/*	copy a copyfile requested from psfprint.def */
	
	if (copyfile[0])
	{	if (fp = fopen (copyfile, "r"))
		{	while (1)
			{	c = fgetc (fp);
				if (feof (fp)  ||  ferror (fp))
					break;
				if (fputc (c, fp) == EOF)
					output_trouble (DISCARD_JOB);
			}
			fclose (fp);
		}
	}
		
	fprintf (output_fp, "%%%%EndProlog\n");

	set_tray (set_paper_tray);
	if (duplex)
		fprintf (output_fp, "%s\n", duplex_mode);

	if (order_command)
		fprintf (output_fp, "%s\n", order_command);
	else if (set_paper_bin)
		set_bin (set_paper_bin);
}

/****************************************************************************
*	set_tray ()																*
****************************************************************************/

void set_tray (set_paper_tray)
int		set_paper_tray;
{
	if (set_paper_tray)
		fprintf (output_fp, "%s\n", p->paper_tray);
}

/****************************************************************************
*	set_bin ()																*
****************************************************************************/

void set_bin (set_paper_bin)
int		set_paper_bin;
{
	if (set_paper_bin)
		fprintf (output_fp, "%s\n", slots[set_paper_bin - 1]);
}

/****************************************************************************
*	showpage ()																*
*	Generate a real "showpage" if we have really finished generating a		*
*	physical page.  If we are processing 2 or 4 up, then generate 			*
*	coordinate "translates" if we really haven't finished all possible		*
*	page frames of the page.												*
****************************************************************************/

void showpage (end_of_file)
int end_of_file;
{	int		skipping;

	line_number = 0;

	if (max_frame > 1)
		fprintf (output_fp, "grestore\n");

	if (is_a_formfeed)			/*	don't skip if caused by form feed */
		is_a_formfeed = 0;		/*	needed for lpr of= processing	  */
	else if (page_number > 0  &&  end_of_file == 0)
	{	skipping = remove_between;
		while (skipping--  &&  fgets (line, LONG_STR, input_fp))
			;
		if (skipping >= 0)
		{	end_of_file = 1;
			if (bookwork == 0)				/* psfdoub will re-insert this */
				fprintf (output_fp, "showpage pg restore\n");
			pages_written++;
			frame = 0;
			longjmp (eof_env, 1);
		}
	}

	if (++frame >= max_frame  ||  end_of_file)
	{	if (bookwork == 0)					/* psfdoub will re-insert this */
			fprintf (output_fp, "showpage pg restore\n");
		pages_written++;
		frame = 0;
	}
	if (!end_of_file)
		set_frame ();
	
}

/****************************************************************************
*	set_frame ()															*
*	Select the next logical frame in two-up or four-up mode.  If it is		*
*	the first frame of a physical page, the generate the %%Page				*
****************************************************************************/

void set_frame ()
{
	if (frame == 0  ||  bookwork)
	{	if (book || reverse_order)		/*	mark byte position of %%Page: for psfdoub  */
		{	pg_loc[npg_loc++] = ftell (output_fp);
		}
		fprintf (output_fp, "%%%%Page: ? %d\n", ++physical_page);
		if (bookwork == 0)					/* psfdoub will re-insert these */
		{	fprintf (output_fp, "/pg save def\n");
			if (landscape)
				fprintf (output_fp, "90 rotate 0 %d translate\n", -real_width);
			fprintf (output_fp, "%.5f %.5f scale\n", scale_x, scale_y);
		}
		findfont();
	}

	set_y_coord ();

	if (bookwork == 0)
		fprintf (output_fp, "%d %d translate\n", dx_home[frame], dy_home[frame]);
	if (max_frame > 1)
	{
		if (frame == 0  &&  cross)
			draw_cross();
		fprintf (output_fp, "gsave\n");
		set_clip_path (0, 0, p->width, p->height);
	}
}


/****************************************************************************
*	set_y_coord																*
*	position next line to the top of a logical page.						*
*****************************************************************************/

void set_y_coord ()
{
	if (extra_space > 0)
		y_coord = p->height - y_top_offset - (point_size + extra_space / 2);
	else
		y_coord = p->height - y_top_offset - point_size;
}

/****************************************************************************
*	put_top																	*
*	put a header line at the top of the page								*
*****************************************************************************/

void put_top ()
{	int	save_attr, save_point, nc;
	char	fmt[50], *hd;
	
	save_attr = print_attribute;
	save_point = point_size;
	print_attribute = BOLD;
	point_size = save_point_size;

	hd = (header == 1) ? fname : header_text;
	nc = n_chars - 33;
	if ((int *)nc < (int *)strlen (hd))
		nc = strlen (hd) + 3;
	sprintf (fmt, "(%%-%ds%%3d     %%s)show\n", nc);

	findfont();
	moveto (0, y_coord, 1);
	fprintf (output_fp, fmt, hd, page_number + 1, now);
	y_coord -= ((point_size + extra_space)  * 2);

	x_coord = 0;
	print_attribute = save_attr;
	point_size = save_point;
	findfont();
}

/****************************************************************************
*	process_file()															*
*	Read the file, look for escape sequences, put text in postscript form	*
****************************************************************************/

void process_file ()
{	int		char_type, char_count, i, set_page, esc_type;
	char	*strchr (), *lc;
	int		previous_attribute;
	int		lcount = 0;
	int		line_is_wrapped;
	char	line_tab[LONG_STR + 1];
	unsigned char	*xln;

	set_page = 0;
	i = remove_beginning;
	while (i--  &&  fgets (line, LONG_STR, input_fp))
		;
	if (i >= 0)
	{	showpage (1);
		return;
	}

	if (setjmp (eof_env))
	{	return;
	}
	line_is_wrapped = 0;

#ifdef PSFFILTER
	/*	psffilter already has a first line,  psf does not */
	do
#else
	while (line_is_wrapped  ||  fgets (line, LONG_STR, input_fp) != NULL)
#endif
	{	if (lcount++ == 0)
		{	if ((i = tscan (line, "ta=")) >= 0)
			{	tab_size = atoi (line + i + 3);
			}
			if (*line == CTLD_EOJ)
			{	/* postscript code may have leading ctl/d.  remove them */
				lc = line;
				while (*lc  && *lc == CTLD_EOJ)
					lc++;
				i = 0;
				do
				{	line[i++] = *lc;
				} while (*lc++);
			}
		}
		else if (*line == CTLD_EOJ)	/* printing postscript code: ^D at end	*/
			break;					/* assume it is end of file also		*/

		if (need_xlate)				/*	translate character set? */
		{	xln = (unsigned char *) line;
			while (*xln)
			{	i = *xln;
				*xln++ = xlate[i];
			}
		}

		if ((c = strchr (line, '\f')) != NULL)
		{	if (c == line)
			{	line_number = 32000;
				c = line + 1;
			}
			else
			{	*c = 0;
				set_page = 1;
				c = line;
			}
			is_a_formfeed = 1;
		}
		else
			c = line;

		if (enable_wrap  &&  line_is_wrapped == 0)
		{	/* for wrapped line, do tab analysis now */
			char_count = 0;
			lc = line_tab;
			c = line;
			while (*c)
			{
				if (*c == ESCAPE)
				{	*lc++ = *c++;
					if (*c == 'P')
						*lc++ = *c++;		/* point size = 2 chars */
					if (*c)
						*lc++ = *c++;
				}
				else if (*c == '\t')
				{	*lc++ = ' ';
					while (++char_count % tab_size)
						*lc++ = ' ';
					c++;
				}
				else
				{	*lc++ = *c++;
					char_count++;
				}
			}
			*lc = '\0';
			c = line_tab;
		}

		if (line_number >= lines_on_page * 10)
		{	page_number++;
			showpage (0);
			line_number = 10;
			if (header)
			{	put_top();
				line_number += 20;
			}
		}
		else
			line_number += 10;

		char_type = char_count = 0;

		/*	for empty lines, don't generate a real moveto - but to call
			to ensure that check for page overflow is done.
		*/
		if (*c == '\n')
			moveto (x_coord, y_coord, 0);		/*	don't gen moveto	*/
		else
			moveto (x_coord, y_coord, 1);		/*	do gen moveto		*/

		while (*c  && *c != '\n')
		{	if (char_type == 0)
			{	if (fputc ('(', output_fp) == EOF)
					output_trouble (DISCARD_JOB);
			}
			switch ((int) *c)
			{
			case ESCAPE:
				previous_attribute = print_attribute;
				esc_type = *(++c);
				if (escape_sequence (esc_type) == 0)
				{	switch (esc_type)
					{
					case 'u':
						SHOWU (output_fp, point_size);
						break;

					default:
						if (char_type  &&  (previous_attribute & UNDERLINE))
							SHOWU (output_fp, point_size);
						else
						{	if (fputs (")show\n", output_fp) == EOF)
								output_trouble (DISCARD_JOB);
						}
						if (esc_type == '+'  ||  esc_type == '-')
						{	/*	check for +/- 1/2 line feed		*/
							if (esc_type == '+')
								y_coord -= ((point_size + extra_space) / 2);
							else
								y_coord += ((point_size + extra_space)  / 2);
							moveto (x_coord, y_coord, 1);
							char_type = -1;
							c++;
							if (*c != '\n')
							{	if (fputc ('(', output_fp) == EOF)
									output_trouble (DISCARD_JOB);
							}
							continue;
						}
						else
							findfont ();
					}
					char_type = 0;
				}
				break;

			default:
				char_type = 1;
				if (enable_wrap  &&  char_count >= chars_on_line)
				{	int	  nb;
					lc = line;
					if (rational_wrap)	/* right-justify */
					{	nb = chars_on_line - strlen (c) + 1;
						if (nb > 0)
						{	while (nb--)
								*lc++ = ' ';
						}
					}
					while (*c)
						*lc++ = *c++;
					*lc = 0;
					line_is_wrapped = 1;
					goto wrapit;
				}
				if (*c == '\t')
				{	fputc (' ', output_fp);
					while (++char_count % tab_size)
					{	if (fputc (' ', output_fp) == EOF)
							output_trouble (DISCARD_JOB);
					}
				}
				else
				{	if (strchr ("\r\b\\()", *c) != NULL)
						if (fputc ('\\', output_fp) == EOF)
							output_trouble (DISCARD_JOB);
					if (fputc (*c, output_fp) == EOF)
						output_trouble (DISCARD_JOB);
					char_count++;
				}
				break;
			}
			c++;
		}
		line_is_wrapped = 0;
wrapit:
		if (char_type == 1)
		{	if (print_attribute & UNDERLINE)
				SHOWU (output_fp, point_size);
			else
			{	if (fputs (")show\n", output_fp) == EOF)
					output_trouble (DISCARD_JOB);
			}
		}

		y_coord -= (point_size + extra_space);
		x_coord = 0;
		if (set_page)
		{	line_number = 32000;
			set_page = 0;
		}
#ifdef PSFFILTER
	} while (line_is_wrapped  ||  fgets (line, LONG_STR, input_fp) != NULL);
#else
	}
#endif
	if (end_of_file == 0)
		showpage (1);
}

/****************************************************************************
*	escape_sequence ()														*
*	If an escape sequence (esc,char) is found, mark which type of font		*
****************************************************************************/

int escape_sequence (which)
int	which;
{	char	s[10];

	switch (which)
	{
	case 'I':
		print_attribute |= ITALICS;
		break;

	case 'i':
		print_attribute &= ~ITALICS;
		break;

	case 'B':
		print_attribute |= BOLD;
		break;

	case 'b':
		print_attribute &= ~BOLD;
		break;

	case 'U':
		print_attribute |= UNDERLINE;
		break;

	case 'u':
		print_attribute &= ~UNDERLINE;
		break;

	case 'F':
		s[0] = *(++c);
		s[1] = '\0';
		font_number = xtoi ((int) *s);		
		if (font_number > (font_count / 4))
			font_number = (font_count / 4) - 1;
		break;

	case 'f':
		font_number = default_font_number;
		break;

	case 'P':
		s[0] = *(++c);
		s[1] = *(++c);
		s[2] = '\0';
		point_size = atoi (s);
		break;

	case 'p':
		point_size = default_point_size;
		break;

	case '+':
	case '-':
		break;

	default:
		return (-1);
		;
	}
	return (0);
}

/****************************************************************************
*	moveto ()																*
*	Generate a postscript     x y moveto    statememt						*
****************************************************************************/

void moveto (x, y, do_move)
int	x;
int	y;
int do_move;			/*	1 = gen moveto     0 = dont gen moveto	*/
{
	/*	ensure that the current line can fit on the page - including the
		1/4 line needed for the decenders
	*/

	if (line_number > lines_on_page * 10  ||  y < (p->bot_marg + point_size / 3))
	{	if (line_number < lines_on_page * 10)
			page_number++;
		showpage (0);
		if (header)
		{	put_top();
			line_number += 20;
		}
		y = y_coord;
		x = x_coord;
	}

	if (do_move)
		fprintf (output_fp, "%d %d mv ", x + x_left_offset, y);
}

/****************************************************************************
*	findfont ()																*
*	generate a findfont statement. Do ISOLatin1 encoding if desired.		*
****************************************************************************/

void findfont ()
{	int	this;
	char	new_font_name[100], *fontname;

	/*	remove reference to UNDERLINE.  Underline is not a font.	*/

	this = (font_number * 4) + (print_attribute & 0x03);
	fonts_used[this] = 1;

	if (isolatin)
	{
		strcpy (new_font_name, fonts[this]);
		strcat (new_font_name, "-ISO");
		if (fonts_iso[this] == 0)
		{	fprintf (output_fp, "/%s /%s ReEncodeISO\n", new_font_name, fonts[this]);
			fonts_iso[this] = 1;
		}
		fontname = new_font_name;
	}
	else
		fontname = fonts[this];

	fprintf (output_fp, "/%s findfont %d scalefont setfont\n", fontname, point_size);
}

/****************************************************************************
*	start_file ()															*
*	Generate things that are appropriate for beginning of file processing	*
****************************************************************************/

void start_file ()
{
	end_of_file = 0;
	line_number = 0;
	print_attribute = 0;
	page_number = 0;
	frame = 0;
	set_frame ();
	if (header)
	{	put_top();
		line_number += 20;
	}
}


/****************************************************************************
*	terminate_printer ()													*
*	Generate things that are appropriate wrap-up after all files printed	*
*	For double sided printing (book == 1), generate byte offset info.		*
****************************************************************************/

void terminate_printer ()
{	int	i, used;
	long	psfptr;

	if (book || reverse_order)
	{	pg_loc[npg_loc++] = ftell (output_fp);
	}
	fprintf (output_fp, "%%%%Trailer\n");
	for (used = i = 0;  i < font_count;  i++)
	{	if (fonts_used[i])
		{	used = 1;
			break;
		}
	}
	if (used)
	{	fprintf (output_fp, "%%%%DocumentFonts:");
		for (i = 0;  i < font_count;  i ++)
		{	if (fonts_used[i])
				fprintf (output_fp, " %s", fonts[i]);
		}
		fprintf (output_fp, "\n");
	}

	fprintf (output_fp, "%%%%Pages: %d\n", physical_page);

	if (book || reverse_order)			/*	print statistics for psfdoub  */
	{	psfptr = ftell (output_fp);
		fprintf (output_fp, "%%PsfScale: %.5f %.5f scale\n", scale_x, scale_y);
		fprintf (output_fp, "%%PsfMargin: %d %d %d %d %d\n", 
						max_frame, landscape, real_width, p->height, p->width);
		for (i = 0;  i < 4;  i++)
			fprintf (output_fp, "%%PsfHome: %d %d %d\n",  i, dx_home[i], dy_home[i]);
		for (i = 0;  i < npg_loc-1;  i++)
			fprintf (output_fp, "%%PsfPg: %d %d\n",  i, pg_loc[i]);
		fprintf (output_fp, "%%PsfPg: 9999 %d\n", pg_loc[npg_loc-1]);
		fprintf (output_fp, "%%PsfPtr: %d\n", psfptr);
	}
#ifdef PSFFILTER
	fprintf (output_fp, "%c", CTLD_EOJ);		/* CTL/D = end job */
#else
	if (gen_eoj)
		fprintf (output_fp, "%c", CTLD_EOJ);
#ifdef CTLDALWAYS
	if (gen_eoj == 0)
		fprintf (output_fp, "%c", CTLD_EOJ);
#endif
#endif
}

/****************************************************************************
*	draw_cross ()															*
*	Draw horizontal and vertical separation lines between pages 2/4-up		*
****************************************************************************/

void draw_cross ()
{	int	 p_w, p_h;

	if (max_frame > 1)
	{	p_w = p->width;
		p_h = p->height;
		if (max_frame == 4)
		{	fprintf (output_fp,"gsave %d %d moveto\n", p_w, p_h);
			fprintf (output_fp,"%d %d lineto\n", p_w, -p_h);
			fprintf (output_fp,"%d %d moveto\n", 0, 0);
			fprintf (output_fp,"%d %d lineto\n", p_w * 2, 0);
			fprintf (output_fp,"%s\n", "stroke grestore");
		}
		else
		{	fprintf (output_fp,"gsave %d %d moveto\n", p_w, p_h);
			fprintf (output_fp,"%d %d lineto\n", p_w, 0);
			fprintf (output_fp,"%s\n", "stroke grestore");
		}
	}
}

/****************************************************************************
*	set_clip_path															*
****************************************************************************/

void set_clip_path (x1, y1, x2, y2)
int	x1, y1, x2, y2;
{
	x1--; y1--; x2++; y2++;

	fprintf (output_fp, "newpath\n");
	fprintf (output_fp,"%d %d moveto\n", x1, y1);
	fprintf (output_fp,"%d %d lineto\n", x1, y2);
	fprintf (output_fp,"%d %d lineto\n", x2, y2);
	fprintf (output_fp,"%d %d lineto\n", x2, y1);
	fprintf (output_fp,"%s\n", "closepath clip");
}

/****************************************************************************
*	output_book ()															*
*	Send file "double sided print" mode.  Used to make a "book".			*
****************************************************************************/

void output_book (bookfile)
char	*bookfile;
{	char	opts[50];

	if (book == 0  &&  reverse_order == 0)
		return;

#ifdef HOPPER

	if (nslots > 1  ||  reverse_order)
	{	if (output_fp != stdout)
		{	fflush (output_fp);
			fclose (output_fp);

			sprintf (opts, "%s %s", reverse_requested ? "-v" : "",
									 book ? "-3" : "");

#if defined(MSDOS)  ||  defined(__MSDOS__)
			sprintf (line, "%s %s -u %s %s", PSFDOUB, opts, defref, bookfile);
#else
			sprintf (line, "%s/%s %s -u %s %s", BINDIR, PSFDOUB, opts, defref, bookfile);
#endif
			system (line);
			unlink (bookfile);
		}
	}


#else	/*	not HOPPER	*/
	if (reverse_order)
	{	if (output_fp != stdout)
		{	fflush (output_fp);
			fclose (output_fp);
		
			sprintf (opts, "%s", reverse_requested ? "-v" : "");

#if defined(MSDOS)  ||  defined(__MSDOS__)
			sprintf (line, "%s %s -u %s %s", PSFDOUB, opts, defref, bookfile);
#else
			sprintf (line, "%s/%s %s -u %s %s", BINDIR, PSFDOUB, opts, defref, bookfile);
#endif
			system (line);
			unlink (bookfile);
		}
	}	


#endif	/* HOPPER */
}


/************************************************************************
*	nexttok()															*
*	like strtok() however assumes that quote or apostrophe delimit		*
*	multi-word groups.													*
************************************************************************/

char *nexttok (ss, q)
char *ss, *q;
{
	static char *s;
	char	quote_char, *start, *quote, *apostrophe;
	
	if (ss)
		s = ss;
	if (s  &&  *s)
	{
		/*	use quote or apostrophe delimiting? */
	
		quote = strchr (q, '"');
		apostrophe = strchr (q, '\'');
		
		/*	skip leading quote symbols */
		
		quote_char = *s;
		while (*s)
		{	if ((quote && *s == '"')  ||  (apostrophe  &&  *s == '\''))
			{	quote_char = *s++;
				break;
			}
			if (strchr (q, *s) == NULL)
				break;
			quote_char = *s++;
		}
		
		/*	skip to next quote */
		
		start = s;						/*	beginning of user string */

		if (quote_char == '"' ||  quote_char == '\'')
		{	while (*s  &&  *s != quote_char)
				s++;
		}
		else
		{	while (*s  &&  strchr (q, *s) == NULL)
				s++;
		}
		
		if (*s)							/*	end of user string		*/
			*s++ = '\0';
		else
			s = NULL;

	}
	else
	{	s = NULL;
		start = NULL;
	}
	return (start);
}


/************************************************************************
*		tscan (s,t)														*		
*	look for string t in s. return -1 if t does not exits in s else		*
*	return array position of first character match						*
************************************************************************/

int tscan (s, t)
char 	s[], t[];
{
	int	i, j, k;
	for (i = 0;  s[i] != '\0';  i++)
	{	for (j = i, k=0;  t[k] != '\0'  &&  s[j] == t[k];  j++, k++)
			;
		if (t[k] == '\0')
			return (i);
	}
	return (-1);
}

void get_time (t)				/*	get current time of */
char	*t;
{
	time_t	n_time, time ();
	char	*x_time, *cc, *strchr();

	n_time = time ((time_t *)0);	/* get time */
	x_time = ctime (&n_time);	/* convert ascii */
	if ((cc = strchr (x_time, '\n')) != NULL)
		*cc = '\0';
	strcpy (t, x_time);
}

int compare (a,b)				/*	case insensitive compare */
char	*a, *b;
{	int	aa, bb;

	while (*a)
	{	aa = *a++;
		bb = *b++;
		if (UCCHAR (aa)  !=  UCCHAR (bb))
			return (UCCHAR(aa) - UCCHAR(bb));
	}
	return (UCCHAR (*a) - UCCHAR (*b));
}

int partial_compare (a,b)			/*	case insensitive compare */
char	*a, *b;						/*	if all parts of 'a' are successful */
{	int	aa, bb;

	while (*a)
	{	aa = *a++;
		bb = *b++;
		if (UCCHAR (aa)  !=  UCCHAR (bb))
			return (UCCHAR(aa) - UCCHAR(bb));
	}
	return (0);
}

void trim (s)					/*	trim trailing blanks  and \n */
char	*s;
{	int many;

	for (many = strlen (s) - 1;  many >= 0;  many--)
	{	if (isgraph (s[many]))
			break;
		else
			s[many] = '\0';
	}
}

void bad_file()
{
	fprintf (stderr, "Bad %s file\n", defref);
	exit (DISCARD_JOB);
}

int xtoi (c)					/*	hex character to integer 	*/
int c;							/*	any letter is a 'hex' digit */
{
	char xc[2];
	int	 rv;
	
	if (isupper (c))
		xc[0] = tolower (c);
	else
		xc[0] = c;
	xc[1] = '\0';
	
	rv = tscan (ascii_hex, xc);
	if (rv >= 0)
		return (rv);
	return (0);
}


/********************************************************
*	catch ()											*
*	Catch SIGINT from lpd								*
********************************************************/

void catch (signo)
int	signo;
{
#ifdef PSFFILTER
	abort_exit ();
#else
	if (gen_eoj)
		fprintf (output_fp, "%c", CTLD_EOJ);
#ifdef CTLDALWAYS
	if (gen_eoj == 0)
		fprintf (output_fp, "%c", CTLD_EOJ);
#endif
#endif
		exit (JOB_IS_DONE);
}

void output_trouble (rc)
int	rc;
{
#ifndef PSFFILTER
	fprintf (stderr, "Cannot write to output file\n");
#endif
	exit (rc);
}
/************************************************************************
*	replacement_fonts()													*
*	get language-specific fonts and translation vectors.				*
*	Reads only the %%PsfStart -to- %%PsfEnd code.  The file is is left	*
*	positioned at the first postscript code that prologue() will copy	*
*	to the output.														*
************************************************************************/

void replacement_fonts ()
{	int		found, i, fn, xold, xnew;
	char	line[201];
	char	*ln, *x, *fname;

	if (pdef == NULL)
		return;
	found = 0;
	while (fgets (line, 200, pdef))		/*	skip printer name 	*/
	{	if (strncmp (line, "%%PsfStart", 10) == 0)
		{	found = 1;
			break;
		}
	}
	if (found)
	{	while (fgets (line, 200, pdef))			/*	read fonts, translate */
		{	if (strncmp (line, "%%PsfEnd", 8) == 0)
				break;
			if (strncmp (line, "%%font",  6) == 0)
			{	fn = xtoi (line[6]) * 4;
				if (fn >= font_count)
					font_count = fn + 4;
				trim (line);
				ln = malloc (strlen (line) - 6);
				strcpy (ln, line + 7);
				fonts_have[fn] = 1;
				fonts[fn++] = strtok (ln, " \t");
				for (i = 1;  i < 4;  i++)
				{	fonts_have[fn] = 1;
					fonts[fn++] = strtok (NULL, " \t");
				}
			}
			else if (strncmp (line, "%%translate",  11) == 0)
			{	x = strtok (line + 11, " \t");
				do
				{	xold = otoi (x) % 256;
					xnew = otoi (x+4) % 256;
					xlate[xold] = xnew;
				} while (x = strtok (NULL, " \t"));
				need_xlate = 1;
			}
			else if (strncmp (line, "%%copy", 6) == 0)
			{	fname = strtok (line + 6, " \t");
				if (fname)
					strcpy (copyfile, fname);
			}
		}
	}
	else
	{	fclose (pdef);
		pdef = NULL;
	}
	return;
}

/****************************************************************************
*	octal to integer														*
****************************************************************************/
int	otoi (s)
char	*s;
{
	int v;
	unsigned d;

	v = 0;
	while (*s == ' ')
		s++;
	while ((d = *s++ - '0')  <  8)
		v = (v << 3) + d;
	return (v);
}

/****************************************************************************
*	usage ()																*
****************************************************************************/

#ifdef PSFFILTER

void usage ()
{	exit (DISCARD_JOB);
}
void size_display ()
{	exit (DISCARD_JOB);
}

#else	/* not PSFFILTER */

static char *usage_text[] =
{
#ifdef CTLDALWAYS
	"Usage: %s [-124DdehIjnswx][-b n][-c n][-f n][-g type][-H txt][-i n][-l n]\n",
#else
	"Usage: %s [-124DdEehInswx][-b n][-c n][-f n][-g type][-H txt][-i n][-l n]\n",
#endif
	"     [-m n][-M l,r,t,b[,pic]][-p n][-P n][-R n][-r n][-t n][-u f] file..",
	"   -1|2|4  print 1,2,4 up (default=1)",
	"   -b n    paper bin n",
	"   -c n    print columns",
	"   -D      duplex double sided",
	"   -d      double sided",
	"   -e      left-justified line wrap",
	"   -E      right-justified line wrap",
	"   -f n    font number (def=0:Courier)",
	"   -g type letter legal a4 b5",
	"   -h      file name header",
	"   -H text text header",
#ifdef ISO
	"   -I      disable ISOLatin1 encoding",
#else
	"   -I      use ISOLatin1 encoding",
#endif
	"   -i n[pic] indent left margin points",
#ifndef CTLDALWAYS
	"   -j      ctl/d at end of print job",
#endif
	"   -l n    print lines per page",
	"   -L n    lines per page",
	"   -m n[pic] top margin points",
	"   -M xxx  set all margins",
	"   -n      portrait (narrow) format",
	"   -p n    point size n",
	"   -P n    preserve point size n",
	"   -R n    remove lines from beginning",
	"   -r n    remove lines between pages",
	"   -s      show page stats",
	"   -t n    tabs to n (default=8)",
	"   -u fil  use this file as psfprint.def",
	"   -v      reverse page order",
	"   -w      landscape (wide) format",
	"   -x      draw cross (2/4-up page)",
	"   file..  name of files (or stdin)",
	"   output: stdout",
	""
} ;

#define TOPCOUNT 2

void usage ()
{	int		i, many, n, ff;

	fprintf (stderr, usage_text[0], pgmname);
	for (i = 1;  i < TOPCOUNT; i++)
		fprintf (stderr, "%s\n", usage_text[i]);

	many = sizeof (usage_text)/sizeof (char *) - TOPCOUNT;
	
	for (i = 0;  i < many/2;  i++)
		fprintf (stderr, "%-38s %-38s\n", usage_text[i+TOPCOUNT], usage_text[i+many/2+TOPCOUNT]);

	fprintf (stderr,"Fonts selection with -f n (number or name)\n");
	many = ff = 0;
	for (i = 0;  i < font_count/4;  i++)
	{	if (fonts_have[i*4])
		{	fprintf (stderr, " %c %-22s", ascii_hex[i], fonts[i*4]);
			many++;
			if ((ff = many % 3)  == 0)
				fprintf (stderr, "\n");
		}
	}
	if (ff)
		fprintf (stderr, "\n");

	fprintf (stderr, "Paper type/size selection with -g type\n");
	many = 0;
	for (i = 0;  page_types[i].paper_name[0] != '\0';  i++)
	{	n = strlen (page_types[i].paper_name);
		if (many + n > 75)
		{	many = 0;
			fprintf (stderr,"\n");
			ff = 0;
		}
		else ff = 1;
		many += n + 3;
		fprintf (stderr,"   %s", page_types[i].paper_name);
	}
	fprintf (stderr, "\n");
	if (ff)
		fprintf (stderr, "\n");
	exit (DISCARD_JOB);
}

/************************************************************************
*	size_display ()														*
*	print a table of point size, page size, line count, column count	*
************************************************************************/

void size_display ()
{
	int	point_size, ps, nominal_high, nominal_wide, i;
	int	n_chars, n_lines;
	double	char_width;
	char	*which;
	
	fprintf (stderr, "%22s", "point size: ");
	for (point_size = 6;  point_size < 17;  point_size += 2)
		fprintf (stderr, " %5d   ", point_size);
	fprintf (stderr, "\n%-22s", " ");
	for (point_size = 6;  point_size < 17;  point_size += 2)
		fprintf (stderr, "  lin col");
	fprintf (stderr, "\n%-22s", "---- Page Layout ----");
	for (point_size = 6;  point_size < 17;  point_size += 2)
		fprintf (stderr, "  --- ---");
	fprintf (stderr, "\n");
	for (ps = 0;  page_types[ps].paper_name[0];  ps++)
	{	for (i = 0;  i < 2;  i++)
		{	if (i == 0)
			{	nominal_high = page_types[ps].y_size;
				nominal_wide = page_types[ps].x_size;
				which = "portrait";
			}
			else
			{	nominal_high = page_types[ps].x_size;
				nominal_wide = page_types[ps].y_size;
				which = "landscape";
			}
			fprintf (stderr, "%10.10s %9s: ", page_types[ps].paper_name, which);
			for (point_size = 6;  point_size < 17;  point_size += 2)
			{	char_width = point_size / 12.0 * NOMINAL_CWIDE;
				n_chars = ceil ((double) nominal_wide / (double) char_width);
				n_lines = (double) nominal_high / (double) point_size + 0.0001;
				fprintf (stderr, " %4d%4d", n_lines, n_chars);
			}
			fprintf (stderr, "\n");
		}
	}
	exit (DISCARD_JOB);
}
#endif /* PSFFILTER */
