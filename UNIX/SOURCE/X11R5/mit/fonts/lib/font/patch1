	      Contributed Type 1 Rasterizer Public Patch
                           MIT X Consortium
			      July 1992

To apply this patch:

cd to the directory containing the Type1 rasterizer code and do:
        patch -s < ThisFile
Patch will work silently unless an error occurs.
If you want to watch patch do its thing, leave out the "-s" argument to patch.

After applying this patch, you will need to rebuild the font library,
font server, and X server.


This patch fixes the following problems in the version on
the R5 contrib tape:

fontlib: interface changes with public patch 13
Type1: fonts with character sets other than ISOLatin1 fail
Type1: t1_Unique() can dereference a null pointer
Type1: memory leaks
Type1: fails to recognize Weight object in font
Type1: NULL is undeclared in t1info.c
Type1: errors in properties computation
Type1: abort() called instead of t1_abort() in malloc


*** fonts/lib/font/Type1/README~	Sat Oct  5 10:38:40 1991
--- fonts/lib/font/Type1/README	Tue Jul 28 15:53:51 1992
***************
*** 1,12 ****
! This directory contains a rasterizer, donated by IBM, for "Type 1"
! (PostScript) format outline fonts.  To be used, this rasterizer must be
! bound into the X server and the font server.  It is more convenient to
! do this if this directory is moved to the 'mit' side of the directory
! tree (i.e., mit/font/lib/font/Type1, a peer of the 'Speedo' directory).
! Of course, mit/font/lib/font/Imakefile must be made aware of its new
! subdirectory and the objects in it.  If you keep this directory where it
! it, you must insure that the library mit/font/lib/font/libfont.a
! contains this code.
   
  In addition, the rasterizer must be "registered" with X. The source in
  mit/fonts/lib/font/fontfile/renderers.c, specifically the routine
--- 1,15 ----
! This directory contains a rasterizer for "Type 1" (PostScript) format
! outline fonts.  It was donated by IBM for the R5 contrib tape and has
! been maintained since then by the MIT X Consortium.  This version is
! compatible with X11R5 public patch 13.
! 
! To be used, this rasterizer must be bound into the X server and the font
! server.  It is most convenient to do this if this directory is moved
! into the 'mit' directory tree (i.e., mit/font/lib/font/Type1, a peer of
! the 'Speedo' directory).  Of course, mit/font/lib/font/Imakefile must be
! made aware of its new subdirectory and the objects in it.  In any case,
! you must ensure that the library mit/font/lib/font/libfont.a contains
! this code.
   
  In addition, the rasterizer must be "registered" with X. The source in
  mit/fonts/lib/font/fontfile/renderers.c, specifically the routine
*** fonts/lib/font/Type1/fontfcn.c~	Fri Oct 11 11:34:25 1991
--- fonts/lib/font/Type1/fontfcn.c	Thu Jul 23 10:03:30 1992
***************
*** 1,4 ****
! /* $XConsortium: fontfcn.c,v 1.5 91/10/11 11:34:02 rws Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
--- 1,4 ----
! /* $XConsortium: fontfcn.c,v 1.8 92/03/27 18:15:45 eswu Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
***************
*** 34,39 ****
--- 34,40 ----
  #include "t1imager.h"
  #include "util.h"
  #include "fontfcn.h"
+ #include "fontmisc.h"
   
  extern xobject Type1Char();
  /***================================================================***/
***************
*** 79,85 ****
  
    if (!(vm_init(cnt))) return(FALSE);
    vm_base = vm_next_byte();
!   if (!(Init_StdEnc())) return(FALSE);
    strcpy(CurFontName, "");    /* iniitialize to none */
    FontP = &TheCurrentFont;
    FontP->vm_start = vm_next_byte();
--- 80,86 ----
  
    if (!(vm_init(cnt))) return(FALSE);
    vm_base = vm_next_byte();
!   if (!(Init_BuiltInEncoding())) return(FALSE);
    strcpy(CurFontName, "");    /* iniitialize to none */
    FontP = &TheCurrentFont;
    FontP->vm_start = vm_next_byte();
***************
*** 118,124 ****
    rcode = scan_font(FontP);
    if (rcode == SCAN_OUT_OF_MEMORY) {
      /* free the memory and start again */
!     free(vm_base);
      if (!(initFont(vm_size * 2))) {
        /* we are really out of memory */
        return(SCAN_OUT_OF_MEMORY);
--- 119,125 ----
    rcode = scan_font(FontP);
    if (rcode == SCAN_OUT_OF_MEMORY) {
      /* free the memory and start again */
!     xfree(vm_base);
      if (!(initFont(vm_size * 2))) {
        /* we are really out of memory */
        return(SCAN_OUT_OF_MEMORY);
***************
*** 130,137 ****
    return(rcode);
  }
  /***================================================================***/
! xobject fontfcnB(FontP,S,code,lenP,mode)
! psfont  *FontP;
  XYspace S;
  unsigned char *code;
  int  *lenP;
--- 131,137 ----
    return(rcode);
  }
  /***================================================================***/
! xobject fontfcnB(S,code,lenP,mode)
  XYspace S;
  unsigned char *code;
  int  *lenP;
***************
*** 149,173 ****
   
    path  charpath;   /* the path for this character              */
   
-   /* We parse the glyphname.  Multi-byte names are delimited by '|'; */
-   /* all others are single-byte.  */
-   --(*lenP);
    charnameP = &CodeName;
!     if (*code != '|') {
!       charnameP->len = 1;
!       charnameP->data.stringP = code;
!     }
!     else {
!       for (s = ++code; *s++ != '|'; )
!         if (--(*lenP) <= 0) {
!           *mode = FF_PARSE_ERROR;
!           return(NULL);
!         }
!       charnameP->len = s - code - 1;
!       charnameP->data.stringP = code ;
!       --(*lenP);
!     }
!  
    CharStringsDictP =  FontP->CharStringsP;
   
    /* search the chars string for this charname as key */
--- 149,158 ----
   
    path  charpath;   /* the path for this character              */
   
    charnameP = &CodeName;
!   charnameP->len = *lenP;
!   charnameP->data.stringP = code;
! 
    CharStringsDictP =  FontP->CharStringsP;
   
    /* search the chars string for this charname as key */
***************
*** 197,215 ****
    return(charpath);
  }
  /***================================================================***/
! /*   fontfcnA(env,S,code, len,mode)                                   */
  /*                                                                    */
  /*          env is a pointer to a string that contains the fontname.  */
  /*                                                                    */
  /*     1) initialize the font     - global indicates it has been done */
  /*     2) load the font                                               */
- /*     3) use the font to call fontfcnB to get the character pattern  */
  /***================================================================***/
! xobject fontfcnA(env,S,code,len,mode)
  char *env;
- XYspace S;
- unsigned char *code;
- int  *len;
  int  *mode;
  {
    int rc;
--- 182,196 ----
    return(charpath);
  }
  /***================================================================***/
! /*   fontfcnA(env, mode)                                              */
  /*                                                                    */
  /*          env is a pointer to a string that contains the fontname.  */
  /*                                                                    */
  /*     1) initialize the font     - global indicates it has been done */
  /*     2) load the font                                               */
  /***================================================================***/
! Bool fontfcnA(env,mode)
  char *env;
  int  *mode;
  {
    int rc;
***************
*** 221,227 ****
      if (!(initFont(VM_SIZE))) {
        /* we are really out of memory */
        *mode = SCAN_OUT_OF_MEMORY;
!       return(NULL);
      }
    }
   
--- 202,208 ----
      if (!(initFont(VM_SIZE))) {
        /* we are really out of memory */
        *mode = SCAN_OUT_OF_MEMORY;
!       return(FALSE);
      }
    }
   
***************
*** 234,243 ****
      if (rc != 0 ) {
        strcpy(CurFontName, "");    /* no font loaded */
        *mode = rc;
!       return(NULL);
      }
    }
!   return(fontfcnB(FontP,S,code,len,mode));
   
  }
  /***================================================================***/
--- 215,224 ----
      if (rc != 0 ) {
        strcpy(CurFontName, "");    /* no font loaded */
        *mode = rc;
!       return(FALSE);
      }
    }
!   return(TRUE);
   
  }
  /***================================================================***/
*** fonts/lib/font/Type1/fontfcn.h~	Thu Oct 10 11:18:07 1991
--- fonts/lib/font/Type1/fontfcn.h	Thu Jul 23 10:03:31 1992
***************
*** 1,4 ****
! /* $XConsortium: fontfcn.h,v 1.2 91/10/10 11:18:06 rws Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
--- 1,4 ----
! /* $XConsortium: fontfcn.h,v 1.3 92/03/26 16:42:23 eswu Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
***************
*** 62,68 ****
   
  #define FONTNAME 1
  #define PAINTTYPE 2
! #define FONTTYPE  3
  #define FONTMATRIX 4
  #define FONTBBOX   5
  #define UNIQUEID  6
--- 62,68 ----
   
  #define FONTNAME 1
  #define PAINTTYPE 2
! #define FONTTYPENUM 3
  #define FONTMATRIX 4
  #define FONTBBOX   5
  #define UNIQUEID  6
***************
*** 76,81 ****
--- 76,82 ----
  #define ISFIXEDPITCH  14
  #define UNDERLINEPOSITION 15
  #define UNDERLINETHICKNESS 16
+ #define ENCODING 17
  /***================================================================***/
  /*  Name of Private values                                            */
  /***================================================================***/
*** fonts/lib/font/Type1/objects.c~	Thu Oct 10 11:18:36 1991
--- fonts/lib/font/Type1/objects.c	Thu Jul 23 10:03:35 1992
***************
*** 1,4 ****
! /* $XConsortium: objects.c,v 1.4 91/10/10 11:18:29 rws Exp $ */
  /* Copyright International Business Machines, Corp. 1991
   * All Rights Reserved
   * Copyright Lexmark International, Inc. 1991
--- 1,4 ----
! /* $XConsortium: objects.c,v 1.5 92/03/20 15:56:06 eswu Exp $ */
  /* Copyright International Business Machines, Corp. 1991
   * All Rights Reserved
   * Copyright Lexmark International, Inc. 1991
***************
*** 725,731 ****
         copy...Note also that if the object was not permanent, we must
         consume the old handle! 3-26-91 PNM
         NOTE : consumption of the old handle moved to Allocate. 4-18-91 */
!     if (obj->references == 1)
          return(obj);
   
      obj = Copy(obj);
--- 725,731 ----
         copy...Note also that if the object was not permanent, we must
         consume the old handle! 3-26-91 PNM
         NOTE : consumption of the old handle moved to Allocate. 4-18-91 */
!     if (!obj || obj->references == 1)
          return(obj);
   
      obj = Copy(obj);
*** fonts/lib/font/Type1/objects.h~	Thu Oct 10 11:18:39 1991
--- fonts/lib/font/Type1/objects.h	Thu Jul 23 10:03:36 1992
***************
*** 1,4 ****
! /* $XConsortium: objects.h,v 1.5 91/10/10 11:18:38 rws Exp $ */
  /* Copyright International Business Machines, Corp. 1991
   * All Rights Reserved
   * Copyright Lexmark International, Inc. 1991
--- 1,4 ----
! /* $XConsortium: objects.h,v 1.6 92/03/20 14:35:56 keith Exp $ */
  /* Copyright International Business Machines, Corp. 1991
   * All Rights Reserved
   * Copyright Lexmark International, Inc. 1991
***************
*** 55,61 ****
  #define   abort(line)       t1_abort(line)
  #define   Allocate(n,t,s)   t1_Allocate(n,t,s)
  #define   Free(obj)         t1_Free(obj)
! #define   NonObjectFree(a)  free(a)
  #define   Consume           t1_Consume
  #define   ArgErr(s,o,r)     t1_ArgErr(s,o,r)
  #define   TypeErr(n,o,e,r)  t1_TypeErr(n,o,e,r)
--- 55,61 ----
  #define   abort(line)       t1_abort(line)
  #define   Allocate(n,t,s)   t1_Allocate(n,t,s)
  #define   Free(obj)         t1_Free(obj)
! #define   NonObjectFree(a)  xiFree(a)
  #define   Consume           t1_Consume
  #define   ArgErr(s,o,r)     t1_ArgErr(s,o,r)
  #define   TypeErr(n,o,e,r)  t1_TypeErr(n,o,e,r)
*** fonts/lib/font/Type1/t1funcs.c~	Thu Oct 10 11:19:30 1991
--- fonts/lib/font/Type1/t1funcs.c	Thu Jul 23 10:03:45 1992
***************
*** 1,4 ****
! /* $XConsortium: t1funcs.c,v 1.4 91/10/10 11:19:28 rws Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
--- 1,4 ----
! /* $XConsortium: t1funcs.c,v 1.10 92/05/12 18:07:55 gildea Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
***************
*** 55,60 ****
--- 55,61 ----
   */
   
  #include    <string.h>
+ #include    "X11/Xfuncs.h"
  #include    "fontfilest.h"
  #include    "FSproto.h"
  #include    "t1intf.h"
***************
*** 62,537 ****
  #include "objects.h"
  #include "spaces.h"
  #include "regions.h"
   
  int         Type1OpenScalable ();
  static int  Type1GetGlyphs();
- extern int  GenericGetExtents();
  void        Type1CloseFont();
  extern int  Type1GetInfoScalable ();
- extern int  GenericGetBitmaps();
   
  static int  Type1GetMetrics ();
   
  static void fillrun();
   
- char *ISO8859[] = {
-  /* 32*/ "|space|",
-  /* 33*/ "|exclam|",
-  /* 34*/ "|quotedbl|",
-  /* 35*/ "|numbersign|",
-  /* 36*/ "|dollar|",
-  /* 37*/ "|percent|",
-  /* 38*/ "|ampersand|",
-  /* 39*/ "|quoteright|",
-  /* 40*/ "|parenleft|",
-  /* 41*/ "|parenright|",
-  /* 42*/ "|asterisk|",
-  /* 43*/ "|plus|",
-  /* 44*/ "|comma|",
-  /* 45*/ "|minus|",
-  /* 46*/ "|period|",
-  /* 47*/ "|slash|",
-  /* 48*/ "|zero|",
-  /* 49*/ "|one|",
-  /* 50*/ "|two|",
-  /* 51*/ "|three|",
-  /* 52*/ "|four|",
-  /* 53*/ "|five|",
-  /* 54*/ "|six|",
-  /* 55*/ "|seven|",
-  /* 56*/ "|eight|",
-  /* 57*/ "|nine|",
-  /* 58*/ "|colon|",
-  /* 59*/ "|semicolon|",
-  /* 60*/ "|less|",
-  /* 61*/ "|equal|",
-  /* 62*/ "|greater|",
-  /* 63*/ "|question|",
-  /* 64*/ "|at|",
-  /* 65*/ "A",
-  /* 66*/ "B",
-  /* 67*/ "C",
-  /* 68*/ "D",
-  /* 69*/ "E",
-  /* 70*/ "F",
-  /* 71*/ "G",
-  /* 72*/ "H",
-  /* 73*/ "I",
-  /* 74*/ "J",
-  /* 75*/ "K",
-  /* 76*/ "L",
-  /* 77*/ "M",
-  /* 78*/ "N",
-  /* 79*/ "O",
-  /* 80*/ "P",
-  /* 81*/ "Q",
-  /* 82*/ "R",
-  /* 83*/ "S",
-  /* 84*/ "T",
-  /* 85*/ "U",
-  /* 86*/ "V",
-  /* 87*/ "W",
-  /* 88*/ "X",
-  /* 89*/ "Y",
-  /* 90*/ "Z",
-  /* 91*/ "|bracketleft|",
-  /* 92*/ "|backslash|",
-  /* 93*/ "|bracketright|",
-  /* 94*/ "|asciicircum|",
-  /* 95*/ "|underscore|",
-  /* 96*/ "|quoteleft|",
-  /* 97*/ "a",
-  /* 98*/ "b",
-  /* 99*/ "c",
-  /*100*/ "d",
-  /*101*/ "e",
-  /*102*/ "f",
-  /*103*/ "g",
-  /*104*/ "h",
-  /*105*/ "i",
-  /*106*/ "j",
-  /*107*/ "k",
-  /*108*/ "l",
-  /*109*/ "m",
-  /*110*/ "n",
-  /*111*/ "o",
-  /*112*/ "p",
-  /*113*/ "q",
-  /*114*/ "r",
-  /*115*/ "s",
-  /*116*/ "t",
-  /*117*/ "u",
-  /*118*/ "v",
-  /*119*/ "w",
-  /*120*/ "x",
-  /*121*/ "y",
-  /*122*/ "z",
-  /*123*/ "|braceleft|",
-  /*124*/ "|bar|",
-  /*125*/ "|braceright|",
-  /*126*/ "|asciitilde|",
-  /*127*/ NULL,
-  /*128*/ NULL,
-  /*129*/ NULL,
-  /*130*/ NULL,
-  /*131*/ NULL,
-  /*132*/ NULL,
-  /*133*/ NULL,
-  /*134*/ NULL,
-  /*135*/ NULL,
-  /*136*/ NULL,
-  /*137*/ NULL,
-  /*138*/ NULL,
-  /*139*/ NULL,
-  /*140*/ NULL,
-  /*141*/ NULL,
-  /*142*/ NULL,
-  /*143*/ NULL,
-  /*144*/ NULL,
-  /*145*/ NULL,
-  /*146*/ NULL,
-  /*147*/ NULL,
-  /*148*/ NULL,
-  /*149*/ NULL,
-  /*150*/ NULL,
-  /*151*/ NULL,
-  /*152*/ NULL,
-  /*153*/ NULL,
-  /*154*/ NULL,
-  /*155*/ NULL,
-  /*156*/ NULL,
-  /*157*/ NULL,
-  /*158*/ NULL,
-  /*159*/ NULL,
-  /*160*/ NULL,
-  /*161*/ "|exclamdown|",
-  /*162*/ "|cent|",
-  /*163*/ "|sterling|",
-  /*164*/ "|currency|",
-  /*165*/ "|yen|",
-  /*166*/ "|brokenbar|",
-  /*167*/ "|section|",
-  /*168*/ "|dieresis|",
-  /*169*/ "|copyright|",
-  /*170*/ "|ordfeminine|",
-  /*171*/ "|guillemotleft|",
-  /*172*/ "|logicalnot|",
-  /*173*/ "|hyphen|",
-  /*174*/ "|registered|",
-  /*175*/ "|macron|",
-  /*176*/ "|degree|",
-  /*177*/ "|plusminus|",
-  /*178*/ "|twosuperior|",
-  /*179*/ "|threesuperior|",
-  /*180*/ "|acute|",
-  /*181*/ "|mu|",
-  /*182*/ "|paragraph|",
-  /*183*/ "|periodcentered|",
-  /*184*/ "|cedilla|",
-  /*185*/ "|onesuperior|",
-  /*186*/ "|ordmasculine|",
-  /*187*/ "|guillemotright|",
-  /*188*/ "|onequarter|",
-  /*189*/ "|onehalf|",
-  /*190*/ "|threequarters|",
-  /*191*/ "|questiondown|",
-  /*192*/ "|Agrave|",
-  /*193*/ "|Aacute|",
-  /*194*/ "|Acircumflex|",
-  /*195*/ "|Atilde|",
-  /*196*/ "|Adieresis|",
-  /*197*/ "|Aring|",
-  /*198*/ "|AE|",
-  /*199*/ "|Ccedilla|",
-  /*200*/ "|Egrave|",
-  /*201*/ "|Eacute|",
-  /*202*/ "|Ecircumflex|",
-  /*203*/ "|Edieresis|",
-  /*204*/ "|Igrave|",
-  /*205*/ "|Iacute|",
-  /*206*/ "|Icircumflex|",
-  /*207*/ "|Idieresis|",
-  /*208*/ "|Eth|",
-  /*209*/ "|Ntilde|",
-  /*210*/ "|Ograve|",
-  /*211*/ "|Oacute|",
-  /*212*/ "|Ocircumflex|",
-  /*213*/ "|Otilde|",
-  /*214*/ "|Odieresis|",
-  /*215*/ "|multiply|",
-  /*216*/ "|Oslash|",
-  /*217*/ "|Ugrave|",
-  /*218*/ "|Uacute|",
-  /*219*/ "|Ucircumflex|",
-  /*220*/ "|Udieresis|",
-  /*221*/ "|Yacute|",
-  /*222*/ "|Thorn|",
-  /*223*/ "|germandbls|",
-  /*224*/ "|agrave|",
-  /*225*/ "|aacute|",
-  /*226*/ "|acircumflex|",
-  /*227*/ "|atilde|",
-  /*228*/ "|adieresis|",
-  /*229*/ "|aring|",
-  /*230*/ "|ae|",
-  /*231*/ "|ccedilla|",
-  /*232*/ "|egrave|",
-  /*233*/ "|eacute|",
-  /*234*/ "|ecircumflex|",
-  /*235*/ "|edieresis|",
-  /*236*/ "|igrave|",
-  /*237*/ "|iacute|",
-  /*238*/ "|icircumflex|",
-  /*239*/ "|idieresis|",
-  /*240*/ "|eth|",
-  /*241*/ "|ntilde|",
-  /*242*/ "|ograve|",
-  /*243*/ "|oacute|",
-  /*244*/ "|ocircumflex|",
-  /*245*/ "|otilde|",
-  /*246*/ "|odieresis|",
-  /*247*/ "|divide|",
-  /*248*/ "|oslash|",
-  /*249*/ "|ugrave|",
-  /*250*/ "|uacute|",
-  /*251*/ "|ucircumflex|",
-  /*252*/ "|udieresis|",
-  /*253*/ "|yacute|",
-  /*254*/ "|thorn|",
-  /*255*/ "|ydieresis|"
- };
   
! char *SYMBOL[] = {
! /*   32  */ "|space|",
! /*   33  */ "|exclam|",
! /*   34  */ "|universal|",
! /*   35  */ "|numbersign|",
! /*   36  */ "|existential|",
! /*   37  */ "|percent|",
! /*   38  */ "|ampersand|",
! /*   39  */ "|suchthat|",
! /*   40  */ "|parenleft|",
! /*   41  */ "|parenright|",
! /*   42  */ "|asteriskmath|",
! /*   43  */ "|plus|",
! /*   44  */ "|comma|",
! /*   45  */ "|minus|",
! /*   46  */ "|period|",
! /*   47  */ "|slash|",
! /*   48  */ "|zero|",
! /*   49  */ "|one|",
! /*   50  */ "|two|",
! /*   51  */ "|three|",
! /*   52  */ "|four|",
! /*   53  */ "|five|",
! /*   54  */ "|six|",
! /*   55  */ "|seven|",
! /*   56  */ "|eight|",
! /*   57  */ "|nine|",
! /*   58  */ "|colon|",
! /*   59  */ "|semicolon|",
! /*   60  */ "|less|",
! /*   61  */ "|equal|",
! /*   62  */ "|greater|",
! /*   63  */ "|question|",
! /*   64  */ "|congruent|",
! /*   65  */ "|Alpha|",
! /*   66  */ "|Beta|",
! /*   67  */ "|Chi|",
! /*   68  */ "|Delta|",
! /*   69  */ "|Epsilon|",
! /*   70  */ "|Phi|",
! /*   71  */ "|Gamma|",
! /*   72  */ "|Eta|",
! /*   73  */ "|Iota|",
! /*   74  */ "|theta1|",
! /*   75  */ "|Kappa|",
! /*   76  */ "|Lambda|",
! /*   77  */ "|Mu|",
! /*   78  */ "|Nu|",
! /*   79  */ "|Omicron|",
! /*   80  */ "|Pi|",
! /*   81  */ "|Theta|",
! /*   82  */ "|Rho|",
! /*   83  */ "|Sigma|",
! /*   84  */ "|Tau|",
! /*   85  */ "|Upsilon|",
! /*   86  */ "|sigma1|",
! /*   87  */ "|Omega|",
! /*   88  */ "|Xi|",
! /*   89  */ "|Psi|",
! /*   90  */ "|Zeta|",
! /*   91  */ "|bracketleft|",
! /*   92  */ "|therefore|",
! /*   93  */ "|bracketright|",
! /*   94  */ "|perpendicular|",
! /*   95  */ "|underscore|",
! /*   96  */ "|radicalex|",
! /*   97  */ "|alpha|",
! /*   98  */ "|beta|",
! /*   99  */ "|chi|",
! /*  100  */ "|delta|",
! /*  101  */ "|epsilon|",
! /*  102  */ "|phi|",
! /*  103  */ "|gamma|",
! /*  104  */ "|eta|",
! /*  105  */ "|iota|",
! /*  106  */ "|phi1|",
! /*  107  */ "|kappa|",
! /*  108  */ "|lambda|",
! /*  109  */ "|mu|",
! /*  110  */ "|nu|",
! /*  111  */ "|omicron|",
! /*  112  */ "|pi|",
! /*  113  */ "|theta|",
! /*  114  */ "|rho|",
! /*  115  */ "|sigma|",
! /*  116  */ "|tau|",
! /*  117  */ "|upsilon|",
! /*  118  */ "|omega1|",
! /*  119  */ "|omega|",
! /*  120  */ "|xi|",
! /*  121  */ "|psi|",
! /*  122  */ "|zeta|",
! /*  123  */ "|braceleft|",
! /*  124  */ "|bar|",
! /*  125  */ "|braceright|",
! /*  126  */ "|similar|",
!  /*127*/ NULL,
!  /*128*/ NULL,
!  /*129*/ NULL,
!  /*130*/ NULL,
!  /*131*/ NULL,
!  /*132*/ NULL,
!  /*133*/ NULL,
!  /*134*/ NULL,
!  /*135*/ NULL,
!  /*136*/ NULL,
!  /*137*/ NULL,
!  /*138*/ NULL,
!  /*139*/ NULL,
!  /*140*/ NULL,
!  /*141*/ NULL,
!  /*142*/ NULL,
!  /*143*/ NULL,
!  /*144*/ NULL,
!  /*145*/ NULL,
!  /*146*/ NULL,
!  /*147*/ NULL,
!  /*148*/ NULL,
!  /*149*/ NULL,
!  /*150*/ NULL,
!  /*151*/ NULL,
!  /*152*/ NULL,
!  /*153*/ NULL,
!  /*154*/ NULL,
!  /*155*/ NULL,
!  /*156*/ NULL,
!  /*157*/ NULL,
!  /*158*/ NULL,
!  /*159*/ NULL,
!  /*160*/ NULL,
! /*  161  */ "|Upsilon1|",
! /*  162  */ "|minute|",
! /*  163  */ "|lessequal|",
! /*  164  */ "|fraction|",
! /*  165  */ "|infinity|",
! /*  166  */ "|florin|",
! /*  167  */ "|club|",
! /*  168  */ "|diamond|",
! /*  169  */ "|heart|",
! /*  170  */ "|spade|",
! /*  171  */ "|arrowboth|",
! /*  172  */ "|arrowleft|",
! /*  173  */ "|arrowup|",
! /*  174  */ "|arrowright|",
! /*  175  */ "|arrowdown|",
! /*  176  */ "|degree|",
! /*  177  */ "|plusminus|",
! /*  178  */ "|second|",
! /*  179  */ "|greaterequal|",
! /*  180  */ "|multiply|",
! /*  181  */ "|proportional|",
! /*  182  */ "|partialdiff|",
! /*  183  */ "|bullet|",
! /*  184  */ "|divide|",
! /*  185  */ "|notequal|",
! /*  186  */ "|equivalence|",
! /*  187  */ "|approxequal|",
! /*  188  */ "|ellipsis|",
! /*  189  */ "|arrowvertex|",
! /*  190  */ "|arrowhorizex|",
! /*  191  */ "|carriagereturn|",
! /*  192  */ "|aleph|",
! /*  193  */ "|Ifraktur|",
! /*  194  */ "|Rfraktur|",
! /*  195  */ "|weierstrass|",
! /*  196  */ "|circlemultiply|",
! /*  197  */ "|circleplus|",
! /*  198  */ "|emptyset|",
! /*  199  */ "|intersection|",
! /*  200  */ "|union|",
! /*  201  */ "|propersuperset|",
! /*  202  */ "|reflexsuperset|",
! /*  203  */ "|notsubset|",
! /*  204  */ "|propersubset|",
! /*  205  */ "|reflexsubset|",
! /*  206  */ "|element|",
! /*  207  */ "|notelement|",
! /*  208  */ "|angle|",
! /*  209  */ "|gradient|",
! /*  210  */ "|registerserif|",
! /*  211  */ "|copyrightserif|",
! /*  212  */ "|trademarkserif|",
! /*  213  */ "|product|",
! /*  214  */ "|radical|",
! /*  215  */ "|dotmath|",
! /*  216  */ "|logicalnot|",
! /*  217  */ "|logicaland|",
! /*  218  */ "|logicalor|",
! /*  219  */ "|arrowdblboth|",
! /*  220  */ "|arrowdblleft|",
! /*  221  */ "|arrowdblup|",
! /*  222  */ "|arrowdblright|",
! /*  223  */ "|arrowdbldown|",
! /*  224  */ "|lozenge|",
! /*  225  */ "|angleleft|",
! /*  226  */ "|registersans|",
! /*  227  */ "|copyrightsans|",
! /*  228  */ "|trademarksans|",
! /*  229  */ "|summation|",
! /*  230  */ "|parenlefttp|",
! /*  231  */ "|parenleftex|",
! /*  232  */ "|parenleftbt|",
! /*  233  */ "|bracketlefttp|",
! /*  234  */ "|bracketleftex|",
! /*  235  */ "|bracketleftbt|",
! /*  236  */ "|bracelefttp|",
! /*  237  */ "|braceleftmid|",
! /*  238  */ "|braceleftbt|",
! /*  239  */ "|braceex|",
! /*  240  */ "|apple|",
! /*  241  */ "|angleright|",
! /*  242  */ "|integral|",
! /*  243  */ "|integraltp|",
! /*  244  */ "|integralex|",
! /*  245  */ "|integralbt|",
! /*  246  */ "|parenrighttp|",
! /*  247  */ "|parenrightex|",
! /*  248  */ "|parenrightbt|",
! /*  249  */ "|bracketrighttp|",
! /*  250  */ "|bracketrightex|",
! /*  251  */ "|bracketrightbt|",
! /*  252  */ "|bracerighttp|",
! /*  253  */ "|bracerightmid|",
! /*  254  */ "|bracerightbt|",
! /*  255  */ NULL
! };
!  
!  
  extern unsigned long *Xalloc();
  static void fill();
- static void clearmemory();
   
  /*ARGSUSED*/
  int Type1OpenScalable (fpe, ppFont, flags, entry, fileName, vals, format, fmask)
--- 63,87 ----
  #include "objects.h"
  #include "spaces.h"
  #include "regions.h"
+ #include "t1stdio.h"
+ #include "util.h"
+ #include "fontfcn.h"
   
  int         Type1OpenScalable ();
  static int  Type1GetGlyphs();
  void        Type1CloseFont();
  extern int  Type1GetInfoScalable ();
   
  static int  Type1GetMetrics ();
   
  static void fillrun();
   
   
! extern psfont *FontP;
! extern psobj *ISOLatin1EncArrayP;
! 
  extern unsigned long *Xalloc();
  static void fill();
   
  /*ARGSUSED*/
  int Type1OpenScalable (fpe, ppFont, flags, entry, fileName, vals, format, fmask)
***************
*** 545,551 ****
      fsBitmapFormatMask  fmask;
  {
         extern struct XYspace *IDENTITY;
!        extern struct region *fontfcnA();
   
   
         FontPtr     pFont;
--- 95,102 ----
      fsBitmapFormatMask  fmask;
  {
         extern struct XYspace *IDENTITY;
!        extern Bool fontfcnA();
!        extern struct region *fontfcnB();
   
   
         FontPtr     pFont;
***************
*** 565,572 ****
         int len,rc;
         struct type1font *type1;
         char *p;
!        char **codepage;
!  
         /* set up default values */
         FontDefaultFormat(&bit, &byte, &glyph, &scan);
         /* get any changes made from above */
--- 116,123 ----
         int len,rc;
         struct type1font *type1;
         char *p;
!        psobj *fontencoding = NULL;
! 
         /* set up default values */
         FontDefaultFormat(&bit, &byte, &glyph, &scan);
         /* get any changes made from above */
***************
*** 588,598 ****
                 xfree(pFont);
                 return AllocError;
         }
!        clearmemory(type1, sizeof(struct type1font));
   
         /* heuristic for "maximum" size of pool we'll need: */
!        size = 20000 + 12 * vals->pixel * sizeof(short);
!        if (size < 0 || NULL == (pool = xalloc(size))) {
                 xfree(type1);
                 xfree(pFont);
                 return AllocError;
--- 139,149 ----
                 xfree(pFont);
                 return AllocError;
         }
!        bzero(type1, sizeof(struct type1font));
   
         /* heuristic for "maximum" size of pool we'll need: */
!        size = 200000 + 120 * vals->pixel * sizeof(short);
!        if (size < 0 || NULL == (pool = (unsigned long *) xalloc(size))) {
                 xfree(type1);
                 xfree(pFont);
                 return AllocError;
***************
*** 605,627 ****
   
         glyphs = type1->glyphs;
   
!        for (p = entry->name.name, i = 13; --i >= 0 && p != NULL; p = strchr(p + 1, '-')) { ; }
!  
!        if (p != NULL && !strncmp(p, "-ADOBE-FONTSPECIFIC", 19))
!                codepage = SYMBOL;
!        else
!                codepage = ISO8859;
!  
!  
         for (i=0; i < 256-FIRSTCOL; i++) {
                 long h,w;
                 long paddedW;
!  
!                if (codepage[i] == NULL)
!                        continue;
!                len = strlen(codepage[i]);
                 rc = 0;
!                area = fontfcnA(fileName, S, codepage[i], &len, &rc);
                 if (rc < 0) {
                         rc = BadFontName;
                         break;
--- 156,188 ----
   
         glyphs = type1->glyphs;
   
!        /* load font if not already loaded */
!        if (!fontfcnA(fileName, &rc))
! 	   return (rc);
! 
!        p = entry->name.name + entry->name.length - 19;
!        if (entry->name.ndashes == 14 &&
! 	   p >= entry->name.name &&
! 	   !strcmp (p, "-adobe-fontspecific"))
!        {
! 	   fontencoding = FontP->fontInfoP[ENCODING].value.data.arrayP;
!        }
! 
!        if (!fontencoding)
! 	   fontencoding = ISOLatin1EncArrayP;
! 
         for (i=0; i < 256-FIRSTCOL; i++) {
                 long h,w;
                 long paddedW;
! 	       char *codename;
! 
! 	       codename = fontencoding[i + FIRSTCOL].data.valueP;
! 	       len = fontencoding[i + FIRSTCOL].len;
! 	       if (len == 7 && strcmp(codename,".notdef")==0)
! 		   continue;
! 
                 rc = 0;
!                area = fontfcnB(S, codename, &len, &rc);
                 if (rc < 0) {
                         rc = BadFontName;
                         break;
***************
*** 653,663 ****
                 glyphs[i].metrics.leftSideBearing  = area->xmin;
                 glyphs[i].metrics.characterWidth   = NEARESTPEL(area->ending.x - area->origin.x);
                 glyphs[i].metrics.rightSideBearing = w + area->xmin;
!                glyphs[i].metrics.descent          = area->ymax - NEARESTPEL(area->origin.x);
                 glyphs[i].metrics.ascent           = h - glyphs[i].metrics.descent;
   
                 if (h > 0 && w > 0) {
!                        clearmemory(glyphs[i].bits, size);
                         fill(glyphs[i].bits, h, paddedW, area, byte, bit, wordsize );
                 }
   
--- 214,224 ----
                 glyphs[i].metrics.leftSideBearing  = area->xmin;
                 glyphs[i].metrics.characterWidth   = NEARESTPEL(area->ending.x - area->origin.x);
                 glyphs[i].metrics.rightSideBearing = w + area->xmin;
!                glyphs[i].metrics.descent          = area->ymax - NEARESTPEL(area->origin.y);
                 glyphs[i].metrics.ascent           = h - glyphs[i].metrics.descent;
   
                 if (h > 0 && w > 0) {
!                        bzero(glyphs[i].bits, size);
                         fill(glyphs[i].bits, h, paddedW, area, byte, bit, wordsize );
                 }
   
***************
*** 689,698 ****
         pFont->info.firstRow = 0;
         pFont->info.lastRow  = 0;
   
-        pFont->get_bitmaps = GenericGetBitmaps;
         pFont->get_metrics = Type1GetMetrics;
         pFont->get_glyphs  = Type1GetGlyphs;
-        pFont->get_extents = GenericGetExtents;
         pFont->unload_font = Type1CloseFont;
         pFont->refcnt = 0;
         pFont->maxPrivate = -1;
--- 250,257 ----
***************
*** 809,829 ****
                 if (type1->glyphs[i].bits != NULL)
                          xfree(type1->glyphs[i].bits);
         xfree(type1);
!        xfree(pFont->info.props);
!        xfree(pFont->info.isStringProp);
         xfree(pFont);
  }
   
   
   
- static void clearmemory(addr, size)
-        long *addr;
-        int size;
- {
-        while (0 <= (size -= sizeof(long)))
-                *addr++ = 0;
- }
-  
  static void fill(dest, h, w, area, byte, bit, wordsize)
         register char *dest;  /* destination bitmap                           */
         int h,w;              /* dimensions of 'dest', w padded               */
--- 368,385 ----
                 if (type1->glyphs[i].bits != NULL)
                          xfree(type1->glyphs[i].bits);
         xfree(type1);
! 
!        if (pFont->info.props)
! 	   xfree(pFont->info.props);
! 
!        if (pFont->info.isStringProp)
! 	   xfree(pFont->info.isStringProp);
! 
         xfree(pFont);
  }
   
   
   
  static void fill(dest, h, w, area, byte, bit, wordsize)
         register char *dest;  /* destination bitmap                           */
         int h,w;              /* dimensions of 'dest', w padded               */
***************
*** 950,963 ****
      T1InitStdProps();
      for (i=0; i < sizeof(renderers) / sizeof(FontRendererRec); i++)
              FontFileRegisterRenderer(&renderers[i]);
- }
-  
- /*
- Synonym for xalloc() so type1 scanner doesn't have to know about X stuff:
- */
-  
- unsigned long *type1alloc(size)
-        unsigned size;
- {
-        return xalloc(size);
  }
--- 506,509 ----
*** fonts/lib/font/Type1/t1imager.h~	Thu Oct 10 11:19:35 1991
--- fonts/lib/font/Type1/t1imager.h	Thu Jul 23 10:03:46 1992
***************
*** 1,4 ****
! /* $XConsortium: t1imager.h,v 1.4 91/10/10 11:19:33 rws Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
--- 1,4 ----
! /* $XConsortium: t1imager.h,v 1.5 92/03/20 14:36:05 keith Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
***************
*** 27,41 ****
   * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
   * SOFTWARE.
   */
! #ifndef  pointer
!  
! #if __STDC__
! #define pointer void *
! #else
! #define pointer char *
! #endif
!  
! #endif
   
  typedef  pointer xobject;
  typedef  pointer location;
--- 27,34 ----
   * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
   * SOFTWARE.
   */
! 
! #include "fontmisc.h"
   
  typedef  pointer xobject;
  typedef  pointer location;
*** fonts/lib/font/Type1/t1info.c~	Thu Oct 10 11:19:38 1991
--- fonts/lib/font/Type1/t1info.c	Thu Jul 23 10:03:47 1992
***************
*** 1,4 ****
! /* $XConsortium: t1info.c,v 1.6 91/10/10 11:19:35 rws Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
--- 1,4 ----
! /* $XConsortium: t1info.c,v 1.9 92/03/20 16:00:13 eswu Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
***************
*** 53,59 ****
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   */
!  
  #include "fontfilest.h"
  #include "FSproto.h"
  #include "t1intf.h"
--- 53,60 ----
   * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   */
! 
! #include <stdio.h> 
  #include "fontfilest.h"
  #include "FSproto.h"
  #include "t1intf.h"
***************
*** 74,80 ****
      enum scaleType type;
  }           fontProp;
   
! static fontProp fontNamePropTable[] = {  /* Example:
      "FOUNDRY", 0, atom,                  /* adobe */
      "FAMILY_NAME", 0, atom,              /* times roman */
      "WEIGHT_NAME", 0, atom,              /* bold */
--- 75,81 ----
      enum scaleType type;
  }           fontProp;
   
! static fontProp fontNamePropTable[] = {  /* Example: */
      "FOUNDRY", 0, atom,                  /* adobe */
      "FAMILY_NAME", 0, atom,              /* times roman */
      "WEIGHT_NAME", 0, atom,              /* bold */
***************
*** 320,326 ****
           case COPYRIGHTPROP:
              *is_str = TRUE;
              QueryFontLib(Filename, "Notice", &infostrP, &rc);
!             if (rc) {
                  infostrP = "Copyright Notice not available";
              }
              pp->value = MakeAtom(infostrP, strlen(infostrP), TRUE);
--- 321,327 ----
           case COPYRIGHTPROP:
              *is_str = TRUE;
              QueryFontLib(Filename, "Notice", &infostrP, &rc);
!             if (rc || !infostrP) {
                  infostrP = "Copyright Notice not available";
              }
              pp->value = MakeAtom(infostrP, strlen(infostrP), TRUE);
***************
*** 343,353 ****
      int flags = 0;
      long format = 0;  /* It doesn't matter what format for just info */
      long fmask = 0;
   
!     Type1OpenScalable(fpe, &pfont, flags, entry, fileName, Vals, format, fmask);
      *pInfo = pfont->info;
!  
      Type1CloseFont(pfont);
  }
   
  void
--- 344,362 ----
      int flags = 0;
      long format = 0;  /* It doesn't matter what format for just info */
      long fmask = 0;
+     int ret;
   
!     ret = Type1OpenScalable(fpe, &pfont, flags, entry, fileName, Vals, format, fmask);
!     if (ret != Successful)
! 	return ret;
      *pInfo = pfont->info;
! 
!     /* XXX - Set pointers in pfont->info to NULL so they are not freed. */
!     pfont->info.props = NULL;
!     pfont->info.isStringProp = NULL;
! 
      Type1CloseFont(pfont);
+     return Successful;
  }
   
  void
*** fonts/lib/font/Type1/t1malloc.c~	Thu Oct 10 11:19:46 1991
--- fonts/lib/font/Type1/t1malloc.c	Thu Jul 23 10:03:49 1992
***************
*** 1,4 ****
! /* $XConsortium: t1malloc.c,v 1.3 91/10/10 11:19:43 rws Exp $ */
  /* Copyright International Business Machines, Corp. 1991
   * All Rights Reserved
   * Copyright Lexmark International, Inc. 1991
--- 1,4 ----
! /* $XConsortium: t1malloc.c,v 1.4 92/03/20 15:58:05 eswu Exp $ */
  /* Copyright International Business Machines, Corp. 1991
   * All Rights Reserved
   * Copyright Lexmark International, Inc. 1991
***************
*** 36,41 ****
--- 36,44 ----
  &author. Jeffrey B. Lotspiech (lotspiech@almaden.ibm.com)
   
  */
+ 
+ #include "objects.h"	/* get #define for abort() */
+ 
  static combine();
  static freeuncombinable();
  static unhook();
*** fonts/lib/font/Type1/t1stub.c~	Thu Oct 10 11:19:52 1991
--- fonts/lib/font/Type1/t1stub.c	Thu Jul 23 10:03:50 1992
***************
*** 1,4 ****
! /* $XConsortium: t1stub.c,v 1.2 91/10/10 11:19:51 rws Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
--- 1,4 ----
! /* $XConsortium: t1stub.c,v 1.3 92/03/20 15:58:40 eswu Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
***************
*** 27,40 ****
   * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
   * SOFTWARE.
   */
   
  xiStub()
  {
         printf("xiStub called\n");
!        abort();
  }
   
! t1_DumpText()
  {
         xiStub();
  }
--- 27,42 ----
   * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
   * SOFTWARE.
   */
+ 
+ #include "objects.h"	/* get #define for abort() */
   
  xiStub()
  {
         printf("xiStub called\n");
!        abort("xiStub called");
  }
   
! void t1_DumpText()
  {
         xiStub();
  }
*** fonts/lib/font/Type1/util.c~	Thu Oct 10 11:20:13 1991
--- fonts/lib/font/Type1/util.c	Thu Jul 23 10:03:56 1992
***************
*** 1,4 ****
! /* $XConsortium: util.c,v 1.4 91/10/10 11:20:12 rws Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
--- 1,4 ----
! /* $XConsortium: util.c,v 1.6 92/03/26 16:42:26 eswu Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
***************
*** 31,39 ****
   
  #include <stdio.h>
  #include "util.h"
   
- extern unsigned long *type1alloc();
-  
  static char *vm_base = NULL;  /* Start of virtual memory area */
         char *vm_next = NULL;  /* Pointer to first free byte */
         long  vm_free = 0;     /* Count of free bytes */
--- 31,38 ----
   
  #include <stdio.h>
  #include "util.h"
+ #include "fontmisc.h"
   
  static char *vm_base = NULL;  /* Start of virtual memory area */
         char *vm_next = NULL;  /* Pointer to first free byte */
         long  vm_free = 0;     /* Count of free bytes */
***************
*** 45,51 ****
  boolean vm_init(cnt)
  int cnt;
  {
!   vm_next = vm_base = (char *)type1alloc(cnt);
   
    if (vm_base != NULL) {
      vm_free = cnt;
--- 44,50 ----
  boolean vm_init(cnt)
  int cnt;
  {
!   vm_next = vm_base = (char *)xalloc (cnt);
   
    if (vm_base != NULL) {
      vm_free = cnt;
***************
*** 116,121 ****
--- 115,135 ----
      objP->type         = OBJ_BOOLEAN;
      objP->len          = 0;
      objP->data.boolean = value;
+   }
+ }
+  
+ /*
+  * Format an Encoding object
+  */
+ void objFormatEncoding(objP,length,valueP)
+   psobj *objP;
+   int length;
+   psobj *valueP;
+ {
+   if (objP != NULL) {
+     objP->type        = OBJ_ENCODING;
+     objP->len         = length;
+     objP->data.arrayP = valueP;
    }
  }
   
*** fonts/lib/font/Type1/util.h~	Thu Oct 10 11:20:15 1991
--- fonts/lib/font/Type1/util.h	Thu Jul 23 10:03:57 1992
***************
*** 1,4 ****
! /* $XConsortium: util.h,v 1.2 91/10/10 11:20:14 rws Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
--- 1,4 ----
! /* $XConsortium: util.h,v 1.3 92/03/26 16:42:29 eswu Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
***************
*** 95,100 ****
--- 95,101 ----
  #define OBJ_STRING     (4)
  #define OBJ_NAME       (5)
  #define OBJ_FILE       (6)
+ #define OBJ_ENCODING   (7)
   
  /***================================================================***/
  /* Value of PostScript objects */
*** fonts/lib/font/Type1/scanfont.c~	Thu Oct 10 11:19:15 1991
--- fonts/lib/font/Type1/scanfont.c	Tue Jul 28 15:36:37 1992
***************
*** 1,4 ****
! /* $XConsortium: scanfont.c,v 1.3 91/10/10 11:19:10 rws Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
--- 1,4 ----
! /* $XConsortium: scanfont.c,v 1.9 92/07/07 17:14:56 gildea Exp $ */
  /* Copyright International Business Machines,Corp. 1991
   * All Rights Reserved
   *
***************
*** 48,63 ****
   
   
  /**********************************************************************/
! /*   Init_StdEnc()                                                    */
  /*                                                                    */
! /*          Initializes the Standard Encoding vector.                 */
  /*                                                                    */
  /**********************************************************************/
! static struct {              /* Builtin Standard Encoding */
     int  index;
     char *name;
! } StdEnc[] = {
!      0 , ".notdef",
     040 , "space",
     041 , "exclam",
     042 , "quotedbl",
--- 48,65 ----
   
   
  /**********************************************************************/
! /*   Init_BuiltInEncoding()                                           */
  /*                                                                    */
! /*     Initializes the StandardEncoding and ISOLatin1Encoding vector. */
  /*                                                                    */
  /**********************************************************************/
! typedef struct				/* Builtin Standard Encoding */
! {
     int  index;
     char *name;
! } EncodingTable;
! 
! static EncodingTable StdEnc[] = {
     040 , "space",
     041 , "exclam",
     042 , "quotedbl",
***************
*** 209,243 ****
    0373 , "germandbls",
      0,      0
  };
  static psobj *StdEncArrayP = NULL;
   
! boolean Init_StdEnc()
  {
    int i;
   
!   StdEncArrayP = (psobj *)vm_alloc(256*(sizeof(psobj)));
!   if (StdEncArrayP) {
!     for (i=0; i<256;i++) {
!       /* initialize everything to .notdef */
!       objFormatName(&(StdEncArrayP[i]),strlen(StdEnc[0].name),
!                                           StdEnc[0].name);
!     }
!     for (i=0; StdEnc[i].name; i++) {
!       objFormatName(&(StdEncArrayP[StdEnc[i].index]),
!                    strlen(StdEnc[i].name),
!                    StdEnc[i].name);
!     }
!     return(TRUE);
    }
!   return(FALSE);
  }
   
   
-  
  /********************************************************************/
  /***================================================================***/
! int getNextValue(valueType)
! int valueType;
  {
    scan_token(inputP);
    if (tokenType != valueType) {
--- 211,449 ----
    0373 , "germandbls",
      0,      0
  };
+ 
+ static EncodingTable ISO8859Enc[] = {
+   32, "space",
+   33, "exclam",
+   34, "quotedbl",
+   35, "numbersign",
+   36, "dollar",
+   37, "percent",
+   38, "ampersand",
+   39, "quoteright",
+   40, "parenleft",
+   41, "parenright",
+   42, "asterisk",
+   43, "plus",
+   44, "comma",
+   45, "minus",
+   46, "period",
+   47, "slash",
+   48, "zero",
+   49, "one",
+   50, "two",
+   51, "three",
+   52, "four",
+   53, "five",
+   54, "six",
+   55, "seven",
+   56, "eight",
+   57, "nine",
+   58, "colon",
+   59, "semicolon",
+   60, "less",
+   61, "equal",
+   62, "greater",
+   63, "question",
+   64, "at",
+   65, "A",
+   66, "B",
+   67, "C",
+   68, "D",
+   69, "E",
+   70, "F",
+   71, "G",
+   72, "H",
+   73, "I",
+   74, "J",
+   75, "K",
+   76, "L",
+   77, "M",
+   78, "N",
+   79, "O",
+   80, "P",
+   81, "Q",
+   82, "R",
+   83, "S",
+   84, "T",
+   85, "U",
+   86, "V",
+   87, "W",
+   88, "X",
+   89, "Y",
+   90, "Z",
+   91, "bracketleft",
+   92, "backslash",
+   93, "bracketright",
+   94, "asciicircum",
+   95, "underscore",
+   96, "quoteleft",
+   97, "a",
+   98, "b",
+   99, "c",
+  100, "d",
+  101, "e",
+  102, "f",
+  103, "g",
+  104, "h",
+  105, "i",
+  106, "j",
+  107, "k",
+  108, "l",
+  109, "m",
+  110, "n",
+  111, "o",
+  112, "p",
+  113, "q",
+  114, "r",
+  115, "s",
+  116, "t",
+  117, "u",
+  118, "v",
+  119, "w",
+  120, "x",
+  121, "y",
+  122, "z",
+  123, "braceleft",
+  124, "bar",
+  125, "braceright",
+  126, "asciitilde",
+  161, "exclamdown",
+  162, "cent",
+  163, "sterling",
+  164, "currency",
+  165, "yen",
+  166, "brokenbar",
+  167, "section",
+  168, "dieresis",
+  169, "copyright",
+  170, "ordfeminine",
+  171, "guillemotleft",
+  172, "logicalnot",
+  173, "hyphen",
+  174, "registered",
+  175, "macron",
+  176, "degree",
+  177, "plusminus",
+  178, "twosuperior",
+  179, "threesuperior",
+  180, "acute",
+  181, "mu",
+  182, "paragraph",
+  183, "periodcentered",
+  184, "cedilla",
+  185, "onesuperior",
+  186, "ordmasculine",
+  187, "guillemotright",
+  188, "onequarter",
+  189, "onehalf",
+  190, "threequarters",
+  191, "questiondown",
+  192, "Agrave",
+  193, "Aacute",
+  194, "Acircumflex",
+  195, "Atilde",
+  196, "Adieresis",
+  197, "Aring",
+  198, "AE",
+  199, "Ccedilla",
+  200, "Egrave",
+  201, "Eacute",
+  202, "Ecircumflex",
+  203, "Edieresis",
+  204, "Igrave",
+  205, "Iacute",
+  206, "Icircumflex",
+  207, "Idieresis",
+  208, "Eth",
+  209, "Ntilde",
+  210, "Ograve",
+  211, "Oacute",
+  212, "Ocircumflex",
+  213, "Otilde",
+  214, "Odieresis",
+  215, "multiply",
+  216, "Oslash",
+  217, "Ugrave",
+  218, "Uacute",
+  219, "Ucircumflex",
+  220, "Udieresis",
+  221, "Yacute",
+  222, "Thorn",
+  223, "germandbls",
+  224, "agrave",
+  225, "aacute",
+  226, "acircumflex",
+  227, "atilde",
+  228, "adieresis",
+  229, "aring",
+  230, "ae",
+  231, "ccedilla",
+  232, "egrave",
+  233, "eacute",
+  234, "ecircumflex",
+  235, "edieresis",
+  236, "igrave",
+  237, "iacute",
+  238, "icircumflex",
+  239, "idieresis",
+  240, "eth",
+  241, "ntilde",
+  242, "ograve",
+  243, "oacute",
+  244, "ocircumflex",
+  245, "otilde",
+  246, "odieresis",
+  247, "divide",
+  248, "oslash",
+  249, "ugrave",
+  250, "uacute",
+  251, "ucircumflex",
+  252, "udieresis",
+  253, "yacute",
+  254, "thorn",
+  255, "ydieresis",
+     0,      0
+ };
+ 
  static psobj *StdEncArrayP = NULL;
+ psobj *ISOLatin1EncArrayP = NULL; 
   
! static psobj *MakeEncodingArrayP(encodingTable)
!     EncodingTable *encodingTable;
  {
    int i;
+   psobj *encodingArrayP;
   
!   encodingArrayP = (psobj *)vm_alloc(256*(sizeof(psobj)));
!   if (!encodingArrayP)
!       return NULL;
! 
!   /* initialize everything to .notdef */
!   for (i=0; i<256;i++)
!       objFormatName(&(encodingArrayP[i]),7, ".notdef");
! 
!   for (i=0; encodingTable[i].name; i++)
!   {
!       objFormatName(&(encodingArrayP[encodingTable[i].index]),
! 		    strlen(encodingTable[i].name),
! 		    encodingTable[i].name);
    }
! 
!   return(encodingArrayP);
  }
   
+ boolean Init_BuiltInEncoding()
+ {
+     StdEncArrayP = MakeEncodingArrayP(StdEnc);
+     ISOLatin1EncArrayP = MakeEncodingArrayP(ISO8859Enc);
+     return (StdEncArrayP && ISOLatin1EncArrayP);
+ }
   
  /********************************************************************/
  /***================================================================***/
! static int getNextValue(valueType)
!     int valueType;
  {
    scan_token(inputP);
    if (tokenType != valueType) {
***************
*** 249,255 ****
  /***================================================================***/
  /*  This routine will set the global rc if there is an error          */
  /***================================================================***/
! int getInt()
  {
    scan_token(inputP);
    if (tokenType != TOKEN_INTEGER) {
--- 455,461 ----
  /***================================================================***/
  /*  This routine will set the global rc if there is an error          */
  /***================================================================***/
! static int getInt()
  {
    scan_token(inputP);
    if (tokenType != TOKEN_INTEGER) {
***************
*** 262,270 ****
   
  }
  /***================================================================***/
! int getArray(arrayP)
! psobj *arrayP;
  {
    int N;   /* count the items in the array */
    psobj *objP;
   
--- 468,594 ----
   
  }
  /***================================================================***/
! /*
!  * See Sec 10.3 of ``Adobe Type 1 Font Format'' v1.1,
!  * for parsing Encoding.
!  */
! static int getEncoding(arrayP)
!     psobj *arrayP;
  {
+ 
+   scan_token(inputP);
+   if ((tokenType == TOKEN_NAME)
+                 &&
+      (((tokenLength==16) && (!strncmp(tokenStartP,"StandardEncoding",16))) ||
+       (((tokenLength==17) && (!strncmp(tokenStartP,"ISOLatin1Encoding",17))))))
+   {
+       /* Adobe Standard Encoding */
+ 
+       if (tokenLength == 16)
+ 	  arrayP->data.valueP = (char *) StdEncArrayP;
+       else
+ 	  arrayP->data.valueP = (char *) ISOLatin1EncArrayP;
+ 
+       arrayP->len = 256;
+       return(SCAN_OK);
+   }
+   else if ( (tokenType == TOKEN_LEFT_BRACE) ||
+        (tokenType == TOKEN_LEFT_BRACKET) )
+   {
+       /* Array of literal names */
+ 
+       psobj *objP;
+       int i;
+ 
+       objP = (psobj *)vm_alloc(256*(sizeof(psobj)));
+       if (!(objP)) return(SCAN_OUT_OF_MEMORY);
+ 
+       arrayP->data.valueP = (char *) objP;
+       arrayP->len = 256;
+ 
+       for (i=0; i<256; i++, objP++)
+       {
+ 	  scan_token(inputP);
+ 	  
+ 	  if (tokenType != TOKEN_LITERAL_NAME)
+ 	      return(SCAN_ERROR);
+ 
+ 	  if (!(vm_alloc(tokenLength)) ) return(SCAN_OUT_OF_MEMORY);
+ 	  objFormatName(objP,tokenLength,tokenStartP);
+       }
+ 
+       scan_token(inputP);
+       if ( (tokenType == TOKEN_RIGHT_BRACE) ||
+ 	  (tokenType == TOKEN_RIGHT_BRACKET) )
+ 	  return(SCAN_OK);
+   }
+   else
+   {
+       /* Must be sequences of ``dup <index> <charactername> put" */
+ 
+       psobj *objP;
+       int i;
+ 
+       objP = (psobj *)vm_alloc(256*(sizeof(psobj)));
+       if (!(objP)) return(SCAN_OUT_OF_MEMORY);
+ 
+       arrayP->data.valueP = (char *) objP;
+       arrayP->len = 256;
+ 
+       for (i=0; i<256; i++)
+ 	  objFormatName(objP + i, 7, ".notdef");
+ 
+       while (TRUE)
+       {
+ 	  scan_token(inputP);
+ 
+ 	  switch (tokenType)
+ 	  {
+ 	  case TOKEN_NAME:
+ 	      if (tokenLength == 3)
+ 	      {
+ 		  if (strncmp(tokenStartP,"dup",3) == 0)
+ 		  {
+ 		      /* get <index> */
+ 		      scan_token(inputP);
+ 		      if (tokenType != TOKEN_INTEGER ||
+ 			  tokenValue.integer < 0 ||
+ 			  tokenValue.integer > 255)
+ 			  return (SCAN_ERROR);
+ 		      i = tokenValue.integer;
+ 
+ 		      /* get <characer_name> */
+ 		      scan_token(inputP);
+ 		      if (tokenType != TOKEN_LITERAL_NAME)
+ 			  return(SCAN_ERROR);
+ 
+ 		      if (!(vm_alloc(tokenLength)) )
+ 			  return(SCAN_OUT_OF_MEMORY);
+ 		      objFormatName(objP + i,tokenLength,tokenStartP);
+ 
+ 		      /* get "put" */
+ 		      scan_token(inputP);
+ 		      if (tokenType != TOKEN_NAME)
+ 			  return(SCAN_ERROR);
+ 		  }
+ 		  else if (strncmp(tokenStartP,"def",3) == 0)
+ 		      return (SCAN_OK);
+ 	      }
+ 	      break;
+ 	  case TOKEN_EOF:
+ 	  case TOKEN_NONE:
+ 	  case TOKEN_INVALID:
+ 	      return (SCAN_ERROR);
+ 	  }
+       }
+   }
+ 
+   return (SCAN_ERROR);
+ }
+ /***================================================================***/
+ static int getArray(arrayP)
+     psobj *arrayP;
+ {
    int N;   /* count the items in the array */
    psobj *objP;
   
***************
*** 304,311 ****
    /* NOTREACHED*/
  }
  /***================================================================***/
! int getName(nameP)
! char *nameP;
  {
    do {
      scan_token(inputP);
--- 628,635 ----
    /* NOTREACHED*/
  }
  /***================================================================***/
! static int getName(nameP)
!     char *nameP;
  {
    do {
      scan_token(inputP);
***************
*** 319,326 ****
    return(SCAN_OK);
  }
  /***================================================================***/
! int getNbytes(N)
! int N;
  {
    int I;
   
--- 643,650 ----
    return(SCAN_OK);
  }
  /***================================================================***/
! static int getNbytes(N)
!     int N;
  {
    int I;
   
***************
*** 342,349 ****
  /*    It means that the CharStrings does not have as many characters  */
  /*    as the dictionary said it would and that is ok.                 */
  /***================================================================***/
! int getLiteralName(nameObjP)
! psobj *nameObjP;
  {
    do {
      scan_token(inputP);
--- 666,673 ----
  /*    It means that the CharStrings does not have as many characters  */
  /*    as the dictionary said it would and that is ok.                 */
  /***================================================================***/
! static int getLiteralName(nameObjP)
!     psobj *nameObjP;
  {
    do {
      scan_token(inputP);
***************
*** 371,378 ****
   */
  /***================================================================***/
   
! int BuildSubrs(FontP)
! psfont *FontP;
  {
     int N;   /* number of values in Subrs */
     int I;   /* index into Subrs */
--- 695,702 ----
   */
  /***================================================================***/
   
! static int BuildSubrs(FontP)
!     psfont *FontP;
  {
     int N;   /* number of values in Subrs */
     int I;   /* index into Subrs */
***************
*** 446,453 ****
   */
  /***================================================================***/
   
! int BuildCharStrings(FontP)
! psfont   *FontP;
  {
     int N;   /* number of values in CharStrings */
     int i;   /* loop thru  Subrs */
--- 770,777 ----
   */
  /***================================================================***/
   
! static int BuildCharStrings(FontP)
!     psfont   *FontP;
  {
     int N;   /* number of values in CharStrings */
     int i;   /* loop thru  Subrs */
***************
*** 506,513 ****
   *   BuildFontInfo Dictionary
   */
  /***================================================================***/
! int BuildFontInfo(fontP)
! psfont *fontP;
  {
    psdict *dictP;
   
--- 830,837 ----
   *   BuildFontInfo Dictionary
   */
  /***================================================================***/
! static int BuildFontInfo(fontP)
!     psfont *fontP;
  {
    psdict *dictP;
   
***************
*** 516,532 ****
    if (!(dictP)) return(SCAN_OUT_OF_MEMORY);
   
    fontP->fontInfoP = dictP;
!   fontP->fontInfoP[0].key.len = 16;  /* number of actual entries */
    objFormatName(&(dictP[FONTNAME].key),8,"FontName");
    objFormatName(&(dictP[FONTNAME].value),0,NULL);
    objFormatName(&(dictP[PAINTTYPE].key),9,"PaintType");
    objFormatInteger(&(dictP[PAINTTYPE].value),0);
!   objFormatName(&(dictP[FONTTYPE].key),8,"FontType");
!   objFormatInteger(&(dictP[FONTTYPE].value),0);
    objFormatName(&(dictP[FONTMATRIX].key),10,"FontMatrix");
    objFormatArray(&(dictP[FONTMATRIX].value),0,NULL);
    objFormatName(&(dictP[FONTBBOX].key),8,"FontBBox");
    objFormatArray(&(dictP[FONTBBOX].value),0,NULL);
    objFormatName(&(dictP[UNIQUEID].key),8,"UniqueID");
    objFormatInteger(&(dictP[UNIQUEID].value),0);
    objFormatName(&(dictP[STROKEWIDTH].key),11,"StrokeWidth");
--- 840,858 ----
    if (!(dictP)) return(SCAN_OUT_OF_MEMORY);
   
    fontP->fontInfoP = dictP;
!   fontP->fontInfoP[0].key.len = 17;  /* number of actual entries */
    objFormatName(&(dictP[FONTNAME].key),8,"FontName");
    objFormatName(&(dictP[FONTNAME].value),0,NULL);
    objFormatName(&(dictP[PAINTTYPE].key),9,"PaintType");
    objFormatInteger(&(dictP[PAINTTYPE].value),0);
!   objFormatName(&(dictP[FONTTYPENUM].key),8,"FontType");
!   objFormatInteger(&(dictP[FONTTYPENUM].value),0);
    objFormatName(&(dictP[FONTMATRIX].key),10,"FontMatrix");
    objFormatArray(&(dictP[FONTMATRIX].value),0,NULL);
    objFormatName(&(dictP[FONTBBOX].key),8,"FontBBox");
    objFormatArray(&(dictP[FONTBBOX].value),0,NULL);
+   objFormatName(&(dictP[ENCODING].key),8,"Encoding");
+   objFormatEncoding(&(dictP[ENCODING].value),0,NULL);
    objFormatName(&(dictP[UNIQUEID].key),8,"UniqueID");
    objFormatInteger(&(dictP[UNIQUEID].value),0);
    objFormatName(&(dictP[STROKEWIDTH].key),11,"StrokeWidth");
***************
*** 539,545 ****
    objFormatString(&(dictP[FULLNAME].value),0,NULL);
    objFormatName(&(dictP[FAMILYNAME].key),10,"FamilyName");
    objFormatString(&(dictP[FAMILYNAME].value),0,NULL);
!   objFormatName(&(dictP[WEIGHT].key),8,"Weight");
    objFormatString(&(dictP[WEIGHT].value),0,NULL);
    objFormatName(&(dictP[ITALICANGLE].key),11,"ItalicAngle");
    objFormatReal(&(dictP[ITALICANGLE].value),0.0);
--- 865,871 ----
    objFormatString(&(dictP[FULLNAME].value),0,NULL);
    objFormatName(&(dictP[FAMILYNAME].key),10,"FamilyName");
    objFormatString(&(dictP[FAMILYNAME].value),0,NULL);
!   objFormatName(&(dictP[WEIGHT].key),6,"Weight");
    objFormatString(&(dictP[WEIGHT].value),0,NULL);
    objFormatName(&(dictP[ITALICANGLE].key),11,"ItalicAngle");
    objFormatReal(&(dictP[ITALICANGLE].value),0.0);
***************
*** 556,563 ****
   *   BuildPrivate Dictionary
   */
  /***================================================================***/
! int BuildPrivate(fontP)
! psfont *fontP;
  {
    psdict *Private;
   
--- 882,889 ----
   *   BuildPrivate Dictionary
   */
  /***================================================================***/
! static int BuildPrivate(fontP)
!     psfont *fontP;
  {
    psdict *Private;
   
***************
*** 615,622 ****
  /*                                                                    */
  /*                                                                    */
  /**********************************************************************/
! int GetType1Blues(fontP)
! psfont *fontP;
  {
    psdict *PrivateDictP;   /* the Private dict relating to hints */
    struct blues_struct *blues;  /* ptr for the blues struct we will allocate */
--- 941,948 ----
  /*                                                                    */
  /*                                                                    */
  /**********************************************************************/
! static int GetType1Blues(fontP)
!     psfont *fontP;
  {
    psdict *PrivateDictP;   /* the Private dict relating to hints */
    struct blues_struct *blues;  /* ptr for the blues struct we will allocate */
***************
*** 929,936 ****
   */
  /***================================================================***/
   
! int FindDictValue(dictP)
! psdict    *dictP;
  {
     psobj LitName;
     int   N;
--- 1255,1262 ----
   */
  /***================================================================***/
   
! static int FindDictValue(dictP)
!     psdict    *dictP;
  {
     psobj LitName;
     int   N;
***************
*** 945,950 ****
--- 1271,1280 ----
     if ( N > 0 ) {
       /* what type */
       switch (dictP[N].value.type) {
+        case OBJ_ENCODING:
+          V = getEncoding(&(dictP[N].value));
+          if ( V != SCAN_OK ) return(V);
+          break;
         case OBJ_ARRAY:
           V = getArray(&(dictP[N].value));
           if ( V != SCAN_OK ) return(V);
***************
*** 1134,1141 ****
          break;
        case TOKEN_NAME:
              if (0 == strncmp(tokenStartP,"eexec",5) ) {
-             extern struct filter EexecFilter;
-  
                 /* if file started with x'80', check next 5 bytes */
                 if (starthex80) {
                   V = getc(fileP);
--- 1464,1469 ----
diff -c mit/fonts/lib/font/Type1/Imakefile:1.1 mit/fonts/lib/font/Type1/Imakefile:1.3
*** mit/fonts/lib/font/Type1/Imakefile:1.1	Fri Sep  4 00:19:06 1992
--- mit/fonts/lib/font/Type1/Imakefile	Fri Sep  4 00:19:06 1992
***************
*** 53,56 ****
--- 53,60 ----
  NormalLibraryObjectRule()
  NormalLintTarget($(SRCS))
  
+ NormalLibraryTarget(Type1,$(OBJS))
+ 
+ InstallLinkKitLibrary(Type1,$(LINKKITDIR)/renderers)
+ 
  DependTarget()
