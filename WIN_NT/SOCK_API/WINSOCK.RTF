{\rtf1\ansi \deff0\deflang1024{\fonttbl{\f0\froman CG Times (WN);}{\f1\froman Symbol;}{\f2\fswiss Univers (WN);}{\f3\fmodern Courier;}{\f4\froman Times New Roman;}{\f5\fmodern Courier New;}{\f6\fmodern MS LineDraw;}
{\f7\fswiss Arial;}{\f8\froman Tms Rmn;}{\f9\fswiss Helv;}{\f10\froman MS Serif;}{\f11\fswiss MS Sans Serif;}{\f12\fnil Wingdings;}{\f13\fmodern LinePrinter;}{\f14\froman Roman;}{\f15\fscript Script;}{\f16\fmodern Modern;}}{\colortbl;\red0\green0\blue0;
\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue127;\red0\green127\blue127;\red0\green127\blue0;\red127\green0\blue127;
\red127\green0\blue0;\red127\green127\blue0;\red127\green127\blue127;\red192\green192\blue192;}{\stylesheet{\s228\li2880\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 \sbasedon0\snext0 toc 5;}{\s229\li2160\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 
\sbasedon0\snext0 toc 4;}{\s230\li1440\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 \sbasedon0\snext0 toc 3;}{\s231\li720\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 \sbasedon0\snext0 toc 2;}{\s232\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 
\sbasedon0\snext0 toc 1;}{\s233\li2160 \fs20\lang1033 \sbasedon0\snext0 index 7;}{\s234\li1800 \fs20\lang1033 \sbasedon0\snext0 index 6;}{\s235\li1440 \fs20\lang1033 \sbasedon0\snext0 index 5;}{\s236\li1080 \fs20\lang1033 \sbasedon0\snext0 index 4;}{
\s237\li720 \fs20\lang1033 \sbasedon0\snext0 index 3;}{\s238\li360 \fs20\lang1033 \sbasedon0\snext0 index 2;}{\s239 \fs20\lang1033 \sbasedon0\snext0 index 1;}{\s240 \fs20\lang1033 \sbasedon0\snext0 line number;}{\s241 \fs20\lang1033 
\sbasedon0\snext239 index heading;}{\s242\tqc\tx4320\tqr\tx8640 \fs20\lang1033 \sbasedon0\snext242 footer;}{\s243\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 \sbasedon0\snext243 header;}{\s244 \fs16\up6\lang1033 
\sbasedon0\snext0 footnote reference;}{\s245 \fs20\lang1033 \sbasedon0\snext245 footnote text;}{\s246\li720 \i\fs20\lang1033 \sbasedon0\snext255 heading 9;}{\s247\li720 \i\fs20\lang1033 \sbasedon0\snext255 heading 8;}{\s248\li720 \i\fs20\lang1033 
\sbasedon0\snext255 heading 7;}{\s249\li720 \fs20\ul\lang1033 \sbasedon0\snext255 heading 6;}{\s250\li720 \b\fs20\lang1033 \sbasedon0\snext255 heading 5;}{\s251 \b\lang1033 \sbasedon0\snext255 {\*\keycode \shift\ctrl 4}heading 4;}{\s252 \b\f2\lang1033 
\sbasedon0\snext255 {\*\keycode \shift\ctrl 3}heading 3;}{\s253\sb120 \b\f2\lang1033 \sbasedon0\snext0 {\*\keycode \shift\ctrl 2}heading 2;}{\s254\sb240 \b\f2\ul\lang1033 \sbasedon0\snext0 {\*\keycode \shift\ctrl 1}heading 1;}{\s255\li720 \fs20\lang1033 
\sbasedon0\snext255 Normal Indent;}{\fs20\lang1033 \snext0 Normal;}{\s2\fi-1440\li1440 \fs20\lang1033 \sbasedon0\snext2 desc;}{\s3\fi-1440\li1440 \fs20\lang1033 \sbasedon0\snext3 include;}{\s4\fi-1440\li1440 \fs20\lang1033 \sbasedon0\snext4 syntax;}{
\s5\fi-1440\li1440 \fs20\lang1033 \sbasedon0\snext12 descrip;}{\s6\fi-1440\li2880 \fs20\ul\lang1033 \sbasedon0\snext6 param;}{\s7\fi-1440\li1440 \fs20\lang1033 \sbasedon0\snext7 returns;}{\s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 
\sbasedon0\snext11 errors;}{\s9\fi-1440\li1440 \fs20\lang1033 \sbasedon0\snext9 see;}{\s10\fi-1440\li2880 \fs20\lang1033 \sbasedon6\snext10 paramtext;}{\s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 \sbasedon8\snext11 errors2;}{\s12\li1440 
\fs20\lang1033 \sbasedon5\snext12 descrip2;}{\s13\fi-1440\li2880 \fs20\lang1033 \sbasedon0\snext13 returns2;}{\s14\li1440 \fs20\lang1033 \sbasedon0\snext14 returns3;}{\s15\li2160 \fs20\lang1033 \sbasedon10\snext15 val;}{\s16\li2160 \fs20\ul\lang1033 
\sbasedon0\snext16 val1;}{\s17\li2160 \fs20\lang1033 \sbasedon0\snext17 val2;}{\s18\fi-360\li1800\tx3600 \fs20\lang1033 \sbasedon12\snext18 descrip3;}{\s19\fi-2160\li3600\tx3600 \fs20\lang1033 \sbasedon18\snext19 descrip4;}{\s20\fi-1440\li3600 
\fs20\ul\lang1033 \sbasedon16\snext20 val3;}{\s21\fi-1440\li3600 \fs20\lang1033 \sbasedon17\snext21 val4;}{\s22\fi-1440\li1440 \fs20\lang1033 \sbasedon0\snext22 notes;}{\s23\li1440 \fs20\lang1033 \sbasedon0\snext23 notes2;}{\s24\fi-2160\li3600 
\fs20\ul\lang1033 \sbasedon0\snext24 Notes3;}{\s25\fi-2160\li3600\tx4320 \fs20\lang1033 \sbasedon0\snext25 Notes4;}{\s26\fi-1440\li1440 \fs20\lang1033 \sbasedon0\snext26 comments;}{\s27\fi-2160\li3600\tx4140\tx5760 \fs20\ul\lang1033 
\sbasedon0\snext27 errors3;}{\s28\li1440 \fs20\lang1033 \sbasedon0\snext28 errors4;}{\s29\li1440 \f5\fs20\lang1033 \sbasedon12\snext29 code;}{\s30\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760 \f5\fs16\lang1033 \sbasedon0\snext30 hdr-file-code;}{
\s31\keep\keepn \f5\fs16\lang1033 \sbasedon30\snext31 err-table;}{\s32\fi-1440\li2880 \f5\fs20\lang1033 \sbasedon10\snext32 paramcode;}{\s33\keepn \b\fs20\lang1033 \snext33 NormalHead;}}{\info{\title WinSockAPI}
{\subject WinSockAPI Specification Version 1.0}{\author Martin Hall}{\operator David R. Treadwell}{\creatim\yr1993\mo1\dy7\hr15\min31}{\revtim\yr1993\mo1\dy21\hr12\min30}{\printim\yr1993\mo1\dy21\hr11\min35}{\version10}{\edmins418}{\nofpages138}
{\nofwords37188}{\nofchars255885}{\vern16417}}\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\gutter0 \widowctrl\ftnbj\revbar1\revprop0 \sectd \pgnrestart\pgnlcrm\linex0\endnhere\titlepg {\footer \pard\plain 
\s242\qc\tqc\tx4320\tqr\tx8640 \fs20\lang1033 {\field{\*\fldinst PAGE}{\fldrslt 10}}
\par }\pard\plain \s2\qc\fi-1440\li1440\tx2880 \fs20\lang1033 
\par \pard \s2\qc\fi-1440\li1440 
\par 
\par 
\par 
\par \pard \s2\qc\li2880\ri2880\box\brdrsh\brdrth\brdrw30\brsp20 {\b\f2\fs48 Windows
\par }{\b\f2\fs48 Sockets}
\par \pard \s2\qc\fi-1440\li1440 {\b\f2\fs40 
\par }{\b\f2\fs40 
\par }{\b\f2\fs72 Windows Sockets}{\b\f2\fs40 
\par }{\b\f2\fs34 An Open Interface for
\par }{\b\f2\fs34 Network Programming u}{\b\f2\fs34 nder
\par }{\b\f2\fs34 Microsoft}{\field\flddirty{\*\fldinst {\b\f2\fs16 SYMBOL 226 \\f "Symbol"}}{\fldrslt }}{\b\f2\fs34  Windows}{\field\flddirty{\*\fldinst {\b\f2\fs16\dn6 SYMBOL 228 \\f "Symbol"}}{\fldrslt }}{\b 
\par }{\b\f2\fs40 
\par }{\b\f2\fs34 Version 1.1
\par }{\b\f2\fs34 
\par }{\b\f2\fs34 20 January}{\b\f2\fs28  }{\b\f2\fs34 1993}{\b\f2\fs28 
\par }{\b\f2\fs28 
\par }{\b\f2\fs28 
\par }Martin Hall
\par Mark Towfiq
\par Geoff Arnold
\par David Treadwell
\par Henry Sanders{\plain \b\f2\lang1033 
\par }{\b\f2\fs34\ul 
\par }{\b\f2\fs28\ul 
\par }{\b\f2\fs28\ul \page 
\par }{\b\f2\fs28\ul 
\par }{\b\f2\fs28\ul 
\par }{\b\f2\fs28\ul 
\par }\pard\plain \qc \fs20\lang1033 Copyright {\field{\*\fldinst SYMBOL 211 \\f "Symbol"}{\fldrslt }} 1992 by Martin Hall, Mark Towfiq
\par Geoff Arnold, David Treadwell and Henry Sanders
\par 
\par All rights reserved.
\par 
\par \pard \qj\li1440\ri1440 This document may be freely redistributed in any form, electronic or otherwise, provided that it is distributed in its entirety and that the copyright and this notice are i
ncluded.  Comments or questions may be submitted via electronic mail to {\b\f7 winsock@}{\b\f7\revised microdyne}{\b\f7 .com}.  Requests to be added to the Windows Sockets mailing list should be addressed to {\b\f7 winsock-request@}{\b\f7\revised 
microdyne}{\b\f7 .com}.  {\revised This specification, archives of the mailing list, and other information on Windows Sockets are available via anonymous FTP from the host microdyne.com, directory /pub/winsock.  }
Questions about products conforming to this specification should be addressed to the vendors of the products.
\par 
\par {\revised Portions of th}{\revised 
e Windows Sockets specification are derived from material which is Copyright (c) 1982-1986 by the Regents of the University of California.  All rights are reserved.  The Berkeley Software License Agreement specifies the terms and conditions for redistribu
}{\revised tion.
\par }
\par 
\par {\ul Revision history:}
\par 1.0 Rev.A\tab June 11, 1992
\par 1.0 Rev.B\tab June 16, 1992
\par 1.0 Rev. C\tab October 12, 1992
\par 1.1\tab \tab January, 1993
\par \pard\plain \s2\qc\fi-1440\li1440 \fs20\lang1033 {\b\f2\fs28\ul 
\par }{\b\f2\fs28\ul \page }{\b\f2\fs28 Windows Sockets
\par }{\b\f2\fs28 Version 1.1
\par }\pard\plain \s254\sb240 \b\f2\ul\lang1033 TABLE OF CONTENTS
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s232\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 {\field{\*\fldinst {\b\ul TOC \\o}}{\fldrslt TABLE OF CONTENTS\tab iii
\par ACKNOWLEDGMENTS\tab iv
\par 1.  INTRODUCTION\tab 1
\par \pard\plain \s231\li720\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 1.1 What is Windows Sockets?\tab 1
\par 1.2 Berkeley Sockets\tab 1
\par 1.3 Microsoft Windows and Windows-specific extensions\tab 1
\par 1.4 The Status of this Specification\tab 2
\par 1.5 Revision History\tab 2
\par \pard\plain \s230\li1440\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 1.5.1 Windows Sockets Version 1.0\tab 2
\par 1.5.2 Windows Sockets Version 1.1\tab 2
\par \pard\plain \s232\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 2.  PROGRAMMING WITH SOCKETS\tab 4
\par \pard\plain \s231\li720\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 2.1 Windows Sockets Stack Installation Checking\tab 4
\par 2.2 Sockets\tab 4
\par \pard\plain \s230\li1440\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 2.2.1 Basic concepts\tab 4
\par 2.2.2 Client-server model\tab 4
\par 2.2.3 Out-of-band data\tab 5
\par 2.2.4 Broadcasting\tab 5
\par \pard\plain \s231\li720\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 2.3 Byte Ordering\tab 6
\par 2.4 Socket Options\tab 6
\par 2.5 Database Files\tab 7
\par 2.6 Deviation from Berkeley Sockets\tab 7
\par \pard\plain \s230\li1440\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 2.6.1 socket data type and error values\tab 8
\par 2.6.2 select() and FD_*\tab 8
\par 2.6.3 Error codes - errno, h_errno & WSAGetLastError()\tab 8
\par 2.6.4 Pointers\tab 9
\par 2.6.5 Renamed functions\tab 9
\par \pard\plain \s229\li2160\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 2.6.5.1 close() & closesocket()\tab 9
\par 2.6.5.1 ioctl() & ioctlsocket()\tab 9
\par \pard\plain \s230\li1440\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 2.6.6 Blocking routines & EINPROGRESS\tab 9
\par 2.6.7 Maximum number of sockets supported\tab 9
\par 2.6.8 Include files\tab 10
\par 2.6.9 Return values on API failure\tab 10
\par 2.6.10 Raw Sockets\tab 10
\par \pard\plain \s231\li720\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 2.7 Windows Sockets in Multithreaded Versions of Windows\tab 10
\par \pard\plain \s232\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 3.  SOCKET LIBRARY OVERVIEW\tab 12
\par \pard\plain \s231\li720\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 3.1 Socket Functions\tab 12
\par \pard\plain \s230\li1440\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 3.1.1 Blocking/Non blocking & Data Volatility\tab 12
\par \pard\plain \s231\li720\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 3.2 Database Functions\tab 13
\par 3.3 Microsoft Windows-specific Extension Functions\tab 14
\par \pard\plain \s230\li1440\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 3.3.1 Asynchronous select() Mechanism\tab 15
\par 3.3.2 Asynchronous Support Routines\tab 15
\par 3.3.3 Hooking Blocking Methods\tab 15
\par 3.3.4 Error Handling\tab 16
\par 3.3.5 Accessing a Windows Sockets DLL from an Intermediate DLL\tab 16
\par 3.3.6 Internal use of Messages by Windows Sockets Implementations\tab 16
\par 3.3.7 Private API Interfaces\tab 17
\par \pard\plain \s232\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 4.  SOCKET LIBRARY REFERENCE\tab 18
\par \pard\plain \s231\li720\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 4.1 Socket Routines\tab 18
\par \pard\plain \s230\li1440\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 4.1.1 accept()\tab 19
\par 4.1.2 bind()\tab 21
\par 4.1.3 closesocket()\tab 23
\par 4.1.4 connect()\tab 25
\par 4.1.5 getpeername()\tab 27
\par 4.1.6 getsockname()\tab 28
\par 4.1.7 getsockopt()\tab 29
\par 4.1.8 htonl()\tab 31
\par 4.1.9 htons()\tab 32
\par 4.1.10 inet_addr()\tab 33
\par 4.1.11 inet_ntoa()\tab 34
\par 4.1.12 ioctlsocket()\tab 35
\par 4.1.13 listen()\tab 37
\par 4.1.14 ntohl()\tab 39
\par 4.1.15 ntohs()\tab 40
\par 4.1.16 recv()\tab 41
\par 4.1.17 recvfrom()\tab 43
\par 4.1.18 select()\tab 46
\par 4.1.19 send()\tab 48
\par 4.1.20 sendto()\tab 50
\par 4.1.21 setsockopt()\tab 53
\par 4.1.22 shutdown()\tab 56
\par 4.1.23 socket()\tab 58
\par \pard\plain \s231\li720\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 4.2 Database Routines\tab 60
\par \pard\plain \s230\li1440\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 4.2.1 gethostbyaddr()\tab 60
\par 4.2.2 gethostbyname()\tab 62
\par 4.2.3 gethostname()\tab 63
\par 4.2.4 getprotobyname()\tab 64
\par 4.2.5 getprotobynumber()\tab 66
\par 4.2.6 getservbyname()\tab 67
\par 4.2.7 getservbyport()\tab 69
\par \pard\plain \s231\li720\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 4.3 Microsoft Windows-specific Extensions\tab 70
\par \pard\plain \s230\li1440\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 4.3.1 WSAAsyncGetHostByAddr()\tab 70
\par 4.3.2 WSAAsyncGetHostByName()\tab 73
\par 4.3.3 WSAAsyncGetProtoByName()\tab 76
\par 4.3.4 WSAAsyncGetProtoByNumber()\tab 79
\par 4.3.5 WSAAsyncGetServByName()\tab 82
\par 4.3.6 WSAAsyncGetServByPort()\tab 85
\par 4.3.7 WSAAsyncSelect()\tab 88
\par 4.3.8 WSACancelAsyncRequest()\tab 94
\par 4.3.9 WSACancelBlockingCall()\tab 96
\par 4.3.10 WSACleanup()\tab 98
\par 4.3.11 WSAGetLastError()\tab 100
\par 4.3.12 WSAIsBlocking()\tab 101
\par 4.3.13 WSASetBlockingHook()\tab 102
\par 4.3.14 WSASetLastError()\tab 104
\par 4.3.15 WSAStartup()\tab 105
\par 4.3.16 WSAUnhookBlockingHook()\tab 109
\par \pard\plain \s232\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 Appendix A.  Error Codes and Header Files\tab 110
\par \pard\plain \s231\li720\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 A.1 Error Codes\tab 110
\par A.2 Header Files\tab 112
\par \pard\plain \s230\li1440\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 A.2.1 Berkeley Header Files\tab 112
\par A.2.2 Windows Sockets Header File - winsock.h\tab 113
\par \pard\plain \s232\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 Appendix B.  Notes for Windows Sockets Suppliers\tab 125
\par \pard\plain \s231\li720\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 B.1 Introduction\tab 125
\par B.2 Windows Sockets Components\tab 125
\par \pard\plain \s230\li1440\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 B.2.1 Development Components\tab 125
\par B.2.2 Run Time Components\tab 125
\par \pard\plain \s231\li720\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 B.3 Multithreadedness and blocking routines.\tab 125
\par B.4 Database Files\tab 126
\par B.5 FD_ISSET\tab 126
\par B.6 Error Codes\tab 126
\par B.7 DLL Ordinal Numbers\tab 126
\par B.8 Validation Suite\tab 127
\par \pard\plain \s232\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 Appendix C.  For Further Reference\tab 129
\par Appendix D.  Background Information\tab 130
\par \pard\plain \s231\li720\ri720\tldot\tx8280\tqr\tx8640 \fs20\lang1033 D.1 Legal Status of Windows Sockets\tab 130
\par D.2 The Story Behind the Windows Sockets Icon\tab 130
\par \pard\plain \fs20\lang1033 }}\pard\plain \fs20\lang1033 {\b\ul \sect }\sectd \pgnlcrm\linex0\endnhere {\header \pard\plain \s243\qr\sa120\tqc\tx4320\tqr\tx8640 \b\f2\lang1033 
\par }\pard\plain \s254\sb240 \b\f2\ul\lang1033 ACKNOWLEDGMENTS{\revised 
\par }\pard\plain \fs20\lang1033 {\revised 
\par }{\f4\revised The authors would like to thank their com}{\f4\revised panies for allowing them the time and resources to make this specification possible:  JSB Corporation, Microdyne Corporation, FTP Software, Sun Microsystems, and Microsoft Corporation.

\par }{\f4\revised 
\par }{\f4\revised 
Special thanks should also be extended to the other efforts contributing to the success of Windows Sockets. The original draft was heavily influenced by existing specifications offered and detailed by JSB Corporation and Net Manage, Inc. The "version 1.0 
}{\f4\revised debate" hosted by Microsoft in Seattle allowed many of the members of}{\f4\revised  the working group to hash out final details for 1.0 vis-a-vis. 
\par }{\f4\revised 
\par }{\f4\revised Sun Microsystems was kind enough to allow first time implementors to "plug and play" beta software during the first Windows Sock-A-Thon of  Windows Sockets application}{\f4 s}{\f4\revised  and implementation}{\f4 s}{\f4\revised  at Interop}{
\f4  Fall '92}{\f4\revised .  Microsoft has shared WSAT (the Windows Sockets API Tester) with other Windows Sockets implementors as a standard Windows Sockets test suite to aid in testing their implementations. Finally, }{\f4 Sun Microsystems and }{
\f4\revised FTP Software plan to h}{\f4\revised ost the Windows Sock-A-Thon II in Boston}{\f4  February '93}{\f4\revised . 
\par }{\f4\revised 
\par }{\f4\revised Without the contributions of the individuals and corporations involved in the working group, Windows Sockets would never have been as thoroughly reviewed and completed as quickly. In just one year, several 
\par }{\f4\revised 
competitors in the networking business developed a useful specification with something to show for it! Many thanks to all which participated, either in person or on e-mail to the Windows Sockets effort. The authors would like to thank everyone w}{
\f4\revised ho participated in any way, and apologize in advance for anyone we have omitted. 
\par }{\f4\revised 
\par }{\f4\revised List of contributors:
\par }{\f4\revised 
\par }{\f4\revised Martin Hall \tab (Chairman)\tab JSB Corporation\tab \tab \tab martinh@jsbus.com
\par }{\f4\revised Mark Towfiq \tab (Coordinator)\tab Microdyne Corporation\tab \tab towfiq@microdyne.com
\par }{\f4\revised Ge}{\f4 o}{\f4\revised ff Arnold \tab (Editor 1.0)\tab Sun Microsystems\tab \tab geoff@east.sun.com
\par }{\f4\revised David Treadwell\tab (Editor 1.1)\tab Microsoft Corporation\tab \tab davidtr@microsoft.com
\par }{\f4\revised Henry Sanders\tab \tab \tab Microsoft Corporation\tab \tab henrysa@microsoft.com
\par }{\f4\revised 
\par }\trowd \trgaph108\trleft-108 \cellx2772\cellx5652\cellx8532\pard \intbl {\revised J. Allard\cell }{\revised Microsoft Corporation\cell }{\revised jallard@microsoft.com\cell }\pard \intbl {\revised \row }\trowd \trgaph108\trleft-108 \cellx2772\cellx5652
\cellx8532\pard \intbl {\revised Chris }{\revised Arap-Bologna\cell }{\revised Distinct\cell }{\revised chris@distinct.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Larry Backman\cell }{\revised FTP Software\cell }{\revised backman@ftp.com
\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Alistair Banks\cell }{\revised Microsoft} Corporation{\revised \cell }{\revised alistair@microsoft.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Rob Barrow\cell }{\revised 
JSB Corporation\cell }{\revised robb@jsb.co.uk\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Carl Beame\cell }{\revised Beame & Whiteside\cell }{\revised beame@mcmaster,ca\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Dave Beaver
\cell }{\revised Microsoft} Corporation{\revised \cell }{\revised dbeaver@microsoft.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Amatzia BenArtzi\cell }{\revised NetManage, Inc.\cell }{\revised amatzia@netmanage.com\cell }\pard \intbl {
\revised \row }\pard \intbl {\revised Mark Beyer\cell }{\revised Ungermann-Bass\cell }{\revised mbeyer@ub.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Nelson Bolyard\cell }{\revised Silicon Graphics, Inc.\cell }{\revised nelson@sgi.com
\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Pat Bonner\cell }{\revised Hewlett-Packard\cell }{\revised p}{\revised _bonner@cnd.hp.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Derek Brown\cell }{\revised FTP Software\cell }{
\revised db@wco.ftp.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Malcolm Butler\cell }{\revised ICL\cell }{\revised mcab@oasis.icl.co.uk\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Mike Calbaum\cell }{\revised 
Fronteir Technologies\cell }{\revised mike@frontiertech.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Isaac Chan\cell }{\revised Microsoft} Corporation{\revised \cell }{\revised isaacc@microsoft.com\cell }\pard \intbl {\revised \row 
}\pard \intbl {\revised Khoji Darbani\cell }{\revised Informix\cell }{\revised khoji@informix.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Nestor Fesas\cell }{\revised Hughes LAN Systems\cell }{\revised nestor@hls.com\cell }\pard \intbl {
\revised \row }\pard \intbl {\revised Karanja Gakio\cell }{\revised FTP Software\cell }{\revised karanja@ftp.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Vikas Garg\cell }{\revised Distinct\cell }{\revised vikas@distinct.com\cell }\pard 
\intbl {\revised \row }\pard \intbl {\revised Gary Gere\cell }{\revised Gupta\cell }{\revised ggere@gupta.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Jim Gilroy\cell }{\revised Microsoft Corporation\cell }{\revised jamesg@microsoft}{
\revised .com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Bill Hayes\cell }{\revised Hewlett-Packard\cell }{\revised billh@hpchdpc.cnd.hp.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Paul Hill\cell }{\revised MIT\cell }{
\revised pbh@athena.mit.edu\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Tmima Koren\cell }{\revised Net Manage, Inc.\cell }{\revised tmima@netmanage.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Hoek Law\cell }{\revised 
Citicorp\cell }{\revised law@dcc.tti.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Graeme Le Roux\cell }{\revised Moresdawn P/L\cell }{\revised -\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Kevin Lewis\cell }{\revised Novell
\cell }{\revised kevinl@novell.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Roger Lin\cell }{\revised 3Com\cell }{\revised roger_lin@3mail.3com.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Terry Lister\cell }{\revised 
Hewlett-Packard\cell }{\revised tel@cnd.hp.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Jeng Long Jiang\cell }{\revised Wollongong\cell }{\revised long@twg.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Lee Murach\cell }{
\revised Network Research\cell }{\revised lee@nrc.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Pete Ostenson\cell }{\revised Microsoft Corporation\cell }{\revised peteo@microsoft.}{\revised com\cell }\pard \intbl {\revised \row }\pard 
\intbl {\revised David Pool\cell }{\revised Spry, Inc.\cell }{\revised dave@spry.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Bob Quinn\cell }{\revised FTP Software\cell }{\revised rcq@ftp.com\cell }\pard \intbl {\revised \row }\pard 
\intbl {\revised Glenn Reitsma\cell }{\revised Hughes LAN Systems\cell }{\revised glennr@hls.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Brad Rice\cell }{\revised Age\cell }{\revised rice@age.com\cell }\pard \intbl {\revised \row }\pard 
\intbl {\revised Allen Rochkind\cell }{\revised 3Com\cell }{\revised -\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Jonathan Rosen\cell }{\revised IBM\cell }{\revised jrosen@vnet.ibm.com\cell }\pard \intbl {\revised \row }\pard \intbl {
\revised Steve Stokes\cell }{\revised Novell\cell }{\revised stoke@novell.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Joseph Tsai\cell }{\revised 3Com\cell }{\revised joe_tsai@3mail.3com.com\cell }\pard \intbl {\revised \row }\pard 
\intbl {\revised James Van Bokkelen\cell }{\revised FTP Software\cell }{\revised jbvb@ftp.com\cell }\pard \intbl {\revised \row }\pard \intbl {\revised Miles Wu\cell }{\revised Wollongong\cell }{\revised wu@twg.com\cell }\pard \intbl {\revised \row 
}\trowd \trgaph108\trleft-108 \cellx2772\cellx5652\cellx8532\pard \intbl {\revised Boris Yanovsky\cell }{\revised NetManage, Inc.\cell }{\revised boris@netmanage.com\cell }\pard \intbl {\revised \row }\pard 
\par \sect \sectd \pgnrestart\linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 Introduction {\field{\*\fldinst PAGE}{\fldrslt 3}}
\par }\pard\plain \fs20\lang1033 
\par \pard\plain \s254\sb240 \b\f2\ul\lang1033 1.  INTRODUCTION
\par \pard\plain \s253\sb120 \b\f2\lang1033 1.1 What is Windows Sockets?
\par \pard\plain \fs20\lang1033 The Windows Sockets specification defines a network programming interface for Microsoft Windows{\fs16\up6 \chftn {\footnote \pard\plain \s245 \fs20\lang1033 {\fs16\up6 \chftn } Windows is a trademark of Microsoft Corporation.}}
 which is based on the "socket" paradigm popularized in the Berkeley Software Distribution (BSD) from the University of California at Berkeley.  It encompasses both familiar Berkeley socket style routines and a set of Windows-specific extensions designed 
to allow the programmer to take advantage of the message-driven nature of Windows.
\par \pard 
\par \pard The Windows Sockets Specification is intended to provide a s
ingle API to which application developers can program and multiple network software vendors can conform.  Furthermore, in the context of a particular version of Microsoft Windows, it defines a binary interface (ABI) such that an application written to the
 Windows Sockets API can work with a conformant protocol implementation from any network software vendor.  This specification thus defines the library calls and associated semantics to which an application developer can program and which a network softwar
e vendor can implement.
\par \pard 
\par \pard 
Network software which conforms to this Windows Sockets specification will be considered "Windows Sockets Compliant".  Suppliers of interfaces which are "Windows Sockets Compliant" shall be referred to as "Windows Sockets Suppliers".  To be Windows Socket
s Compliant, a vendor must implement 100% of this Windows Sockets specification.
\par \pard 
\par \pard Applications which are capable of operating with any "Windows Sockets Compliant" protocol implementation will be considered as having a "Windows Sockets Interface" and will be referred to as "Windows Sockets Applications".
\par \pard 
\par \pard 
This version of the Windows Sockets specification defines and documents the use of the API in conjunction with the Internet Protocol Suite (IPS, generally referred to as TCP/IP).  Specifically, all Windows Sockets implementations support both stream (TCP)
 and datagram (UDP) sockets.
\par \pard 
\par \pard While the use of this API with alternative protocol stacks is not precluded (and is expected to be the subject of future revisions of the specification), such usage is beyond the scope of this version of the specification.
\par \pard 
\par \pard\plain \s253\sb120 \b\f2\lang1033 1.2 Berkeley Sockets
\par \pard\plain \fs20\lang1033 
The Windows Sockets Specification has been built upon the Berkeley Sockets programming model which is the de facto standard for TCP/IP networking.  It is intended to provide a high degree of familiarity for programmers who are used to programming with soc
kets in UNIX{\fs16\up6 \chftn {\footnote \pard\plain \s245 \fs20\lang1033 {\fs16\up6 \chftn } UNIX is a trademark of Unix System Laboratories, Inc.}}
 and other environments, and to simplify the task of porting existing sockets-based source code.  The Windows Sockets API is consistent with release 4.3 of the Berkeley Software Distribution (4.3BSD).
\par \pard 
\par \pard 
Portions of the Windows Sockets specification are derived from material which is Copyright (c) 1982-1986 by the Regents of the University of California.  All rights are reserved.  The Berkeley Software License Agreement specifies the terms and conditions 
for redistribution.
\par \pard 
\par \pard\plain \s253\sb120 \b\f2\lang1033 1.3 Microsoft Windows and Windows-specific extensions
\par \pard\plain \fs20\lang1033 This API is intended to be usable within all implementations and versions of Microsoft Windows from Microsoft Windows 
Version 3.0 onwards.  It thus provides for Windows Sockets implementations and Windows Sockets applications in both 16 and 32 bit operating environments.  
\par \pard 
\par \pard Windows Sockets makes provisions for multithreaded Windows processes.  A process contains one or more threads of execution.  In the {\revised Windows 3.1}
 non-multithreaded world, a task corresponds to a process with a single thread.  All references to threads in this document refer to actual "threads" in multithreaded Windows environments.  In non multithreaded
 environments (such as Windows 3.0), use of the term thread refers to a Windows process.
\par \pard 
\par \pard 
The Microsoft Windows extensions included in Windows Sockets are provided to allow application developers to create software which conforms to the Windows programming model.  It is expected that this will facilitate the creation of robust and high-perform
ance applications, and will improve the cooperative multitasking of applications within non-preemptive versions of Windows.  With the exception of {\b WSAStartup()} and {\b W}{\b SACleanup()} their use is not mandatory.
\par \pard 
\par \pard\plain \s253\sb120 \b\f2\lang1033 1.4 The Status of this Specification
\par \pard\plain \fs20\lang1033 {\b\ul 
\par }\pard {\f4 
Windows Sockets is an independent specification which was created and exists for the benefit of application developers and network vendors and, indirectly, computer users. Each published (non-draft) version of this specification  represents a fully workab
}{\f4 le API for implementation by network vendors and programming use by application developers. Discussion of this specification and  suggested improvements continue and are welc}{\f4 
omed. Such discussion occurs mainly via the Internet electronic mail forum winsock@}{\f4\revised microdyne}{\f4 .com. Meetings of  interested parties occur on an irregular basis. Details of these meetings are publicized to the electronic mail forum.

\par }\pard {\f4 
\par }\pard\plain \s253\sb120 \b\f2\lang1033 {\revised 1.5 Revision History
\par }\pard\plain \s252 \b\f2\lang1033 {\revised 1.5.1 Windows Sockets Version 1.0
\par }\pard\plain \fs20\lang1033 {\f4\revised 
Windows Sockets Version 1.0 represented the results of considerable work within  the vendor and user community as discussed in Appendix C. This version of  the specification was released in order that network software supp}{\f4\revised 
liers and  application developers could begin to construct implementations and 
\par }\pard {\f4\revised applications  which conformed to the Windows Sockets standard.
\par }{\f4\revised 
\par }\pard\plain \s252 \b\f2\lang1033 {\revised 1.5.2 Windows Sockets Version 1.1
\par }\pard\plain \fs20\lang1033 {\f4\revised 
Windows Sockets Version 1.1 follows the guidelines and structure laid out by version 1.0, making changes only where absolutely necessary as indicated by the experiences of a number of companies that created Windows Sockets implementations based on the ver
}{\f4\revised sion 1.0 specification.  Version 1.1 contains several clarifications and mi}{\f4\revised nor fixes to version 1.0.  Additionally, the following more significant changes were incorporated into version 1.1:
\par }\pard\plain \s255\li720 \fs20\lang1033 {\f4\revised 
\par }\pard \s255\li720 {\f4\revised o Inclusion of the }{\b\f4\revised gethostname() }{\f4\revised routine to simplify retrieval of the host's name and address.
\par }\pard \s255\li720 {\f4\revised 
\par }\pard \s255\li720 {\f4\revised 
o Definition of DLL ordinal values below 1000 as reserved for Windows Sockets and ordinals above 1000 as unrestricted.  This allows Windows Sockets vendors to include private interfaces to their DLLs without risking that the ordinals chosen will conflict 
}{\f4\revised with a future version of Windows Sockets}{\f4\revised .
\par }\pard \s255\li720 {\f4\revised 
\par }\pard \s255\li720 {\revised o Addition of a reference count to }{\b\revised WSAStartup() }{\revised and }{\b\revised WSACleanup()}{\revised 
, requiring correspondences between the calls.  This allows applications and third-party DLLs to make use of a Windows Sockets implementation without being concerned about the calls to these APIs made by the other.
\par }\pard \s255\li720 {\f4\revised 
\par }\pard \s255\li720 {\f4\revised o Change of return type of }{\b\f4\revised inet_addr() }{\f4\revised from }{\b\f4\revised struct in_addr}{\f4\revised  to }{\b\f4\revised unsigned long}{\f4\revised 
.  This was required due to different handling of four-byte structure returns between the Microsoft and Borland C compilers.
\par }\pard \s255\li720 {\f4\revised 
\par }\pard \s255\li720 {\f4\revised o Change of }{\b\f4\revised WSAAsyncSe}{\b\f4\revised lect() }{\f4\revised semantics from "edge-triggered" to "level-triggered".  The level-triggered semantics significantly simplify an application's use of this routine.

\par }\pard \s255\li720 {\f4\revised 
\par }\pard \s255\li720 {\f4\revised o Change the }{\b\f4\revised ioctlsocket() }{\f4\revised FIONBIO semantics to fail if a }{\b\f4\revised WSAAsyncSelect() }{\f4\revised call is outstanding on the socket.
\par }\pard \s255\li720 {\f4\revised 
\par }{\f4\revised o Addition of the TCP_NODELAY socket option for RFC 1122 conformance.
\par }{\f4\revised 
\par }\pard\plain \fs20\lang1033 {\revised All changes between the 1.0 and 1.1 specifications are flagged with change bars at the left of the page.
\par }\pard\plain \s255\li720 \fs20\lang1033 {\revised 
\par }\pard\plain \fs20\lang1033 {\b\ul \sect }\sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 Programming with Sockets {\field{\*\fldinst PAGE}{\fldrslt 10}}
\par }\pard\plain \s254\sb240 \b\f2\ul\lang1033 2.  PROGRAMMING WITH SOCKETS
\par \pard\plain \s253\sb120 \b\f2\lang1033 2.1 Windows Sockets Stack Installation Checking
\par \pard\plain \fs20\lang1033 To detect the presence of one (or many) Windows Sockets implementations on a system, an application which has been linked with the Windows Sockets Import Library may simply call the {\b WSAStartup()}
 routine.  If an application wishes to be a little more sophisticated it can examine the $PATH environment variable and search for instances of Windows Sockets implementations (WINSOCK.DLL).  For each instance it can issue a {\b LoadLibrary()}
 call and use the {\b WSAStartup()} routine to discover implementation specific data.
\par \pard 
\par \pard 
This version of the Windows Sockets specification does not attempt to address explicitly the issue of multiple concurrent Windows Sockets implementations.  Nothing in the specification should be interpreted as restricting multiple Windows Sockets DLLs fro
m being present and used concurrently by one or more Windows Sockets applications.
\par \pard 
\par For further details of where to obtain Windows Sockets components, see Appendix B.2.
\par 
\par \pard\plain \s253\sb120 \b\f2\lang1033 2.2 Sockets
\par \pard\plain \fs20\lang1033 {\f4 The following material is derived from the docum}{\f4 ent "An Advanced 4.3BSD Interprocess Communication Tutorial" by Samuel J. Leffler, Robert S. Fabry, William N. Joy, Phil Lapsley, Steve Miller, and Chris Torek.
\par }\pard {\f4 
\par }\pard\plain \s252 \b\f2\lang1033 2.2.1 Basic concepts
\par \pard\plain \fs20\lang1033 
The basic building block for communication is the socket.  A socket is an endpoint of communication to which a name may be bound.  Each socket in use has a type and an associated process.  Sockets exist within communication domains.  A communication domai
n is an abstraction introduced to bundle common properties of threads c
ommunicating through sockets.  Sockets normally exchange data only with sockets in the same domain (it may be possible to cross domain boundaries, but only if some translation process is performed).  The Windows Sockets facilities support a single communi
cation domain: the Internet domain, which is used by processes which communicate using the Internet Protocol Suite.  (Future versions of this specification may include additional domains.) 
\par \pard 
\par \pard Sockets are typed according to the communication properties visi
ble to a user.  Applications are presumed to communicate only between sockets of the same type, although there is nothing that prevents communication between sockets of different types should the underlying communication protocols support this.  
\par \pard 
\par \pard Two types of sockets currently are available to a user.  A stream socket provides for the bi-directional, reliable, sequenced, and unduplicated flow of data without record boundaries.  
\par \pard 
\par \pard A datagram socket supports bi-directional flow of data which is not promi
sed to be sequenced, reliable, or unduplicated.  That is, a process receiving messages on a datagram socket may find messages duplicated, and, possibly, in an order different from the order in which it was sent.  An important characteristic of a datagram 
socket is that record boundaries in data are preserved.  Datagram sockets closely model the facilities found in many contemporary packet switched networks such as Ethernet.  
\par \pard 
\par \pard\plain \s252 \b\f2\lang1033 2.2.2 Client-server model
\par \pard\plain \fs20\lang1033 The most commonly used paradigm in constructing dist
ributed applications is the client/server model.  In this scheme client applications request services from a server application.  This implies an asymmetry in establishing communication between the client and server.  
\par \pard 
\par \pard 
The client and server require a well-known set of conventions before service may be rendered (and accepted).  This set of conventions comprises a protocol which must be implemented at both ends of a connection.  Depending on the situation, the protocol ma
y be symmetric or asymmetric.  In a
 symmetric protocol, either side may play the master or slave roles.  In an asymmetric protocol, one side is immutably recognized as the master, with the other as the slave.  An example of a symmetric protocol is the TELNET protocol used in the Internet f
or remote terminal emulation.  An example of an asymmetric protocol is the Internet file transfer protocol, FTP.  No matter whether the specific protocol used in obtaining a service is symmetric or asymmetric, when accessing a service there is a "client p
rocess'' and a "server process''.  
\par \pard 
\par \pard 
A server application normally listens at a well-known address for service requests.  That is, the server process remains dormant until a connection is requested by a client's connection to the server's address.  At such a time the server process "wakes up
'' and services the client, performing whatever appropriate actions the client requests of it.  While connection-based services are the norm, some services are based on the use of datagram sockets.  
\par \pard 
\par \pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart oob}2.2.3{\*\bkmkend oob} Out-of-band data
\par \pard\plain \box\brdrsh\brdrs\brdrw30\brsp40 \fs20\lang1033 
Note: The following discussion of out-of-band data, also referred to as TCP Urgent data,  follows the model used in the Berkeley software distribution.  Users and implementors should be aware of the fact that there are at present two conflicting interpret
ations of RFC 793 (in which the concept is introduced), and that the implementation of out-of-band data in the Berkeley Software Distribution does not conform to the Host Requirements laid down in RFC 1122.  To minimize interoperability problems, app
lications writers are advised not to use out-of-band data unless this is required in order to interoperate with an existing service.  Windows Sockets suppliers are urged to document the out-of-band semantics (BSD or RFC 1122) which their product implement
s.  It is beyond the scope of this specification to mandate a particular set of semantics for out-of-band data handling.
\par \pard 
\par \pard The stream socket abstraction includes the notion of "out of band'' data.  Out-of-band data is a logically independent transmission c
hannel associated with each pair of connected stream sockets.  Out-of-band data is delivered to the user independently of normal data.  The abstraction defines that the out-of-band data facilities must support the reliable delivery of at least one out-of-
band message at a time.  This message may contain at least one byte of data, and at least one message may be pending delivery to the user at any one time.  For communications protocols which support only in-band signaling (i.e.  the urgent data is deliver
ed
 in sequence with the normal data), the system normally extracts the data from the normal data stream and stores it separately.  This allows users to choose between receiving the urgent data in order and receiving it out of sequence without having to buff
er all the intervening data.  It is possible to "peek'' at out-of-band data.  
\par \pard 
\par \pard An application may prefer to process out-of-band data "in-line", as part of the normal data stream.  This is achieved by setting the socket option SO_OOBINLINE (see section {\field{\*\fldinst ref setsockopt}{\fldrslt 4.1.21}}, {\b setsockopt()}
).  In this case, the application may wish to determine whether any of the unread data is "urgent" (the term usually applied to in-line out-of-band data).  To facilitate this, the Windows Sockets implementation will maintain a logical "mark" in the data s
tream indicate the point at which the out-of-band data was sent.  An application can use the SIOCATMARK {\b ioctlsocket()} command (see section {\field{\*\fldinst ref ioctlsocket}{\fldrslt 4.1.12}}
) to determine whether there is any unread data preceding the mark.  For example, it might use this to resynchronize with its peer by ensuring that all data up to the mark in the data stream is discarded when appropriate.
\par \pard 
\par \pard The {\b WSAAsyncSelect()} routine is particularly well suited to handling notification of the presence of out-of-band-data.
\par \pard 
\par \pard\plain \s252 \b\f2\lang1033 2.2.4 Broadcasting
\par \pard\plain \fs20\lang1033 By using a datagram socket, it is possible to send broadcast packets on many networks supported by the system.  The network itself must support broadcast: the system provides no simulation of broadcast in
 software.  Broadcast messages can place a high load on a network, since they force every host on the network to service them.  Consequently, the ability to send broadcast packets has been limited to sockets which are explicitly marked as allowing broadca
sting.  Broadcast is typically used for one of two reasons: it is desired to find a resource on a local network without prior knowledge of its address, or important functions such as routing require that information be sent to all accessible neighbors.

\par \pard 
\par \pard T
he destination address of the message to be broadcast depends on the network(s) on which the message is to be broadcast.  The Internet domain supports a shorthand notation for broadcast on the local network, the address INADDR_BROADCAST.  Received broadca
st messages contain the senders address and port, as datagram sockets must be bound before use.
\par \pard 
\par \pard Some types of network support the notion of different types of broadcast.  For example, the IEEE 802.5 token ring architecture supports the use of link-level 
broadcast indicators, which control whether broadcasts are forwarded by bridges.  The Windows Sockets specification does not provide any mechanism whereby an application can determine the type of underlying network, nor any way to control the semantics of
 broadcasting.
\par \pard 
\par \pard\plain \s253\sb120 \b\f2\lang1033 2.3 Byte Ordering
\par \pard\plain \fs20\lang1033 The Intel byte ordering is like that of the DEC VAX{\fs16\up6 \chftn {\footnote \pard\plain \s245 \fs20\lang1033 {\fs16\up6 \chftn } VAX is a trademark of Digital Equipment Corporation.}}
, and therefore differs from the Internet and 68000{\fs16\up6 \chftn {\footnote \pard\plain \s245 \fs20\lang1033 {\fs16\up6 \chftn } 68000 is a trademark of Motorola, Inc.}}
-type processor byte ordering.  Thus care must be taken to ensure correct orientation.
\par \pard 
\par \pard {\revised Any reference to IP addres}{\revised ses or port numbers passed to or from a Windows Sockets routine must be in network order.  This includes the IP address and port fields of a }{\b\revised struct sockaddr_in}{\revised  (but not the }{
\i\revised sin_family}{\revised  field).}
\par \pard 
\par \pard Consider an application which normally contacts a server on the TCP port corresponding to the "time" service, but which provides a mechanism for the user to specify that an alternative port is to be used.  The port number returned by {\b 
getservbyname()} is already in network order, which is the format required construct
ing an address, so no translation is required.  However if the user elects to use a different port, entered as an integer, the application must convert this from host to network order (using the {\b htons()}
 function) before using it to construct an address.  Conversely, if the application wishes to display the number of the port within an address (returned via, e.g., {\b getpeername()}), the port number must be converted from network to host order (using {
\b ntohs()}) before it can be displayed.
\par \pard 
\par \pard Since the Intel and In
ternet byte orders are different, the conversions described above are unavoidable.  Application writers are cautioned that they should use the standard conversion functions provided as part of the Windows Sockets API rather than writing their own conversi
on code, since future implementations of Windows Sockets are likely to run on systems for which the host order is identical to the network byte order.  Only applications which use the standard conversion functions are likely to be portable.
\par \pard 
\par \pard\plain \s253\sb120 \b\f2\lang1033 {\*\bkmkstart Socket_Options}2.4{\*\bkmkend Socket_Options} Socket Options
\par \pard\plain \s15 \fs20\lang1033 The socket options supported by Windows Sockets are listed in the pages describing {\b setsockopt()} and {\b getsockopt()}.  A Windows Sockets implementation must recognize all of these options, and (for {\b getsockopt()}
) return plausible values for each.  The default value for each option is shown in the following table.
\par \pard \s15 
\par \trowd \trgaph108\trleft-108 \clbrdrt\brdrs\brdrw30 \clbrdrl\brdrs\brdrw30 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx1824\clbrdrt\brdrs\brdrw30 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3054\clbrdrt
\brdrs\brdrw30 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx5934\clbrdrt\brdrs\brdrw30 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx7806\clbrdrt\brdrs\brdrw30 \clbrdrl\brdrs\brdrw15 \clbrdrb
\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw30 \cellx8526\pard\plain \keep\keepn\intbl \fs20\lang1033 {\*\bkmkstart sockopt}{\*\bkmkend sockopt}Value\cell \pard \keep\keepn\intbl Type\cell \pard \keep\keepn\intbl Meaning\cell \pard \keep\keepn\intbl Default\cell 
\pard \keep\keepn\intbl Note\cell \pard \intbl \row \trowd \trgaph108\trleft-108 \clbrdrl\brdrs\brdrw30 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx1824\clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3054\clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx5934\clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx7806\clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw30 \cellx8526\pard \keep\keepn\intbl 
SO_ACCEPTCON{\revised N}\cell \pard \keep\keepn\intbl BOOL\cell \pard \keep\keepn\intbl Socket is {\b listen()}ing.\cell \pard \keep\keepn\intbl FALSE unless a {\b listen()} has been performed\cell \pard \keep\keepn\intbl \cell \pard \intbl \row \trowd 
\trgaph108\trleft-108 \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw30 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx1824\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3054\clbrdrt\brdrs\brdrw15 
\clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx5934\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx7806\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 
\clbrdrr\brdrs\brdrw30 \cellx8526\pard \keep\keepn\intbl SO_BROADCAST\cell \pard \keep\keepn\intbl BOOL\cell \pard \keep\keepn\intbl Socket is configured for the transmission of broadcast messages.\cell \pard \keep\keepn\intbl FALSE\cell \pard 
\keep\keepn\intbl \cell \pard \intbl \row \pard \keep\keepn\intbl SO_DEBUG\cell \pard \keep\keepn\intbl BOOL\cell \pard \keep\keepn\intbl Debugging is enabled.  \cell \pard \keep\keepn\intbl FALSE\cell \pard \keep\keepn\intbl (i)\cell \pard \intbl \row 
\pard \keep\keepn\intbl SO_DONTLINGER\cell \pard \keep\keepn\intbl BOOL\cell \pard \keep\keepn\intbl If true, the SO_LINGER option is disabled.\cell \pard \keep\keepn\intbl TRUE\cell \pard \keep\keepn\intbl \cell \pard \intbl \row \pard \keep\keepn\intbl 
SO_DONTROUTE\cell \pard \keep\keepn\intbl BOOL\cell \pard \keep\keepn\intbl Routing is disabled.\cell \pard \keep\keepn\intbl FALSE\cell \pard \keep\keepn\intbl (i)\cell \pard \intbl \row \pard \keep\keepn\intbl SO_ERROR\cell \pard \keep\keepn\intbl int
\cell \pard \keep\keepn\intbl Retrieve error status and clear.\cell \pard \keep\keepn\intbl 0\cell \pard \keep\keepn\intbl \cell \pard \intbl \row \pard \keep\keepn\intbl SO_KEEPALIVE\cell \pard \keep\keepn\intbl BOOL\cell \pard \keep\keepn\intbl 
Keepalives are being sent.\cell \pard \keep\keepn\intbl FALSE\cell \pard \keep\keepn\intbl \cell \pard \intbl \row \pard \keep\keepn\intbl SO_LINGER\cell \pard \keep\keepn\intbl struct linger FAR *\cell \pard \keep\keepn\intbl 
Returns the current linger options.\cell \pard \keep\keepn\intbl {\i l_onoff} is 0\cell \pard \keep\keepn\intbl {\i \cell }\pard \intbl \row \pard \keep\keepn\intbl SO_OOBINLINE\cell \pard \keep\keepn\intbl BOOL\cell \pard \keep\keepn\intbl 
Out-of-band data is being received in the normal data stream.  \cell \pard \keep\keepn\intbl FALSE\cell \pard \keep\keepn\intbl \cell \pard \intbl \row \pard \keep\keepn\intbl SO_RCVBUF\cell \pard \keep\keepn\intbl int\cell \pard \keep\keepn\intbl 
Buffer size for receives\cell \pard \keep\keepn\intbl Implementation dependent\cell \pard \keep\keepn\intbl (i)\cell \pard \intbl \row \pard \keep\keepn\intbl SO_REUSEADDR\cell \pard \keep\keepn\intbl BOOL\cell \pard \keep\keepn\intbl 
The address to which this socket is bound can be used by others.\cell \pard \keep\keepn\intbl FALSE\cell \pard \keep\keepn\intbl \cell \pard \intbl \row \pard \keep\keepn\intbl SO_SNDBUF\cell \pard \keep\keepn\intbl int\cell \pard \keep\keepn\intbl 
Buffer size for sends\cell \pard \keep\keepn\intbl Implementation dependent\cell \pard \keep\keepn\intbl (i)\cell \pard \intbl \row \trowd \trgaph108\trleft-108 \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw30 \clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw15 
\cellx1824\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw15 \cellx3054\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw15 \cellx5934\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw15 \cellx7806\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw30 \cellx8526\pard \keep\keepn\intbl SO_TYPE\cell \pard \keep\keepn\intbl int\cell \pard 
\keep\keepn\intbl The type of the socket (e.g. SOCK_STREAM).\cell \pard \keep\keepn\intbl As created via {\b socket()}\cell \pard \keep\keepn\intbl \cell \pard \intbl \row \trowd \trgaph108\trleft-108 \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw30 \clbrdrb
\brdrs\brdrw30 \clbrdrr\brdrs\brdrw15 \cellx1824\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw15 \cellx3054\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw15 \cellx5934
\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw15 \cellx7806\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw30 \cellx8526\pard \keep\keepn\intbl {\revised TCP_NODELAY}
\cell \pard \keep\keepn\intbl {\revised BOOL}\cell \pard \keep\keepn\intbl {\revised Disables the Nagle algorithm for send coalescing.}\cell \pard \keep\keepn\intbl {\revised Implementation dependent}\cell \pard \keep\keepn\intbl \cell \pard \intbl \row 
\pard\plain \s15 \fs20\lang1033 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 Notes:
\par \pard \s22\fi-1440\li1440 (i)\tab An implementation may silently ignore this option on {\b setso}{\b ckopt()} and return a constant value for {\b getsockopt()}, or it may accept a value for {\b setsockopt()} and return the corresponding value in {\b 
getsockopt()} without using the value in any way.
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 
\par \pard\plain \fs20\lang1033 {\*\bkmkstart SocketOptions}{\*\bkmkend SocketOptions}
\par \pard\plain \s253\sb120 \b\f2\lang1033 2.5 Database Files
\par \pard\plain \fs20\lang1033 The {\b getXbyY()}{\fs16\up6 \chftn {\footnote \pard\plain \s245 \fs20\lang1033 {\fs16\up6 \chftn } This specification uses the function name {\b ge}{\b tXbyY()} to represent the set of routines {\b gethostbyaddr()}, {\b 
gethostbyname()}, etc. Similarly {\b WSAAsyncGetXByY()} represents {\b WSAAsyncGetHostByAddr()}, etc.}} and {\b WSAAsyncGetXByY()} classes of routines are provided for retrieving network specific information.  The {\b getXbyY()}
 routines were originally designed (in the first Berkeley UNIX releases) as mechanisms for looking up information in text databases.  Although the information may be retrieved
 by the Windows Sockets implementation in different ways, a Windows Sockets application requests such information in a consistent manner through either the {\b getXbyY()} or the {\b WSAAsyncGetXByY()} class of routines.
\par \pard {\b 
\par }\pard\plain \s253\sb120 \b\f2\lang1033 2.6 Deviation from Berkeley Sockets
\par \pard\plain \fs20\lang1033 There are a few limited instances where the Windows Sockets API has had to divert from strict adherence to the Berkeley conventions, usually because of difficulties of implementation in a Windows environment.
\par \pard 
\par \pard\plain \s252 \b\f2\lang1033 2.6.1 socket data type and error values
\par \pard\plain \fs20\lang1033 A new data type, SOCKET, has been defined.  The definition of this type was necessary for future enhancements to the Windows Sockets specification, such as being able to use sockets as file handles in Windows NT{\fs16\up6 
\chftn {\footnote \pard\plain \s245 \fs20\lang1033 {\fs16\up6 \chftn } NT and Windows/NT are trademarks of Microsoft Corporation.}}
.  Definition of this type also facilitates porting of applications to a Win/32 environment, as the type will automatically be promoted from 16 to 32 bits.
\par \pard 
\par \pard {\revised In UNIX, all handles, including socket handles, are small, non-negative integers, and some applications make assumptions that this will be true.  Wind}{\revised 
ows Sockets handles have no restrictions, other than that the value INVALID_SOCKET is not a valid socket.  Socket handles may take any value in the range 0 to INVALID_SOCKET-1.}
\par \pard 
\par \pard Because the SOCKET type is unsigned, compiling existing source code from, for example, a UNIX environment may lead to compiler warnings about signed/unsigned data type mismatches.
\par \pard 
\par \pard This means, for example, that checking for errors when the {\b socket()} and {\b accept()} routines return should {\ul not} be done by comparing the return value wit
h -1, or seeing if the value is negative (both common, and legal, approaches in BSD).  Instead, an application should use the manifest constant INVALID_SOCKET as defined in {\b winsock.h}.  For example:
\par \pard \keepn \tab {\b TYPICAL BSD STYLE:
\par }\pard\plain \s29\li1440\keepn \f5\fs20\lang1033 s = socket(...);
\par if (s == -1)\tab /* or s < 0 */
\par \tab \{...\}
\par \pard\plain \fs20\lang1033 
\par \pard \keepn \tab {\b PREFERRED STYLE:}
\par \pard\plain \s29\li1440\keepn \f5\fs20\lang1033 s = socket(...);
\par if (s == INVALID_SOCKET)
\par \pard \s29\li1440 \tab \{...\}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s252 \b\f2\lang1033 2.6.2 select() and FD_*
\par \pard\plain \fs20\lang1033 Because a SOCKET is no longer represented by the UNIX-style "small non-negative integer", the implementation of the {\b select()} function was changed in the Windows Sockets API.  Each set of {\revised socket}
s is still represented by the fd_set type, but instead of being stored as a bitmask the set is implemented as an array of SOCKETs.  To avoid potential problems, applications {\ul must}
 adhere to the use of the FD_XXX macros to set, initialize, clear, and check the fd_set structures.
\par \pard 
\par \pard\plain \s252 \b\f2\lang1033 2.6.3 Error codes - errno, h_errno & WSAGetLastError()
\par \pard\plain \fs20\lang1033 Error codes set by the Windows Sockets implementation are NOT made available via the errno variable.  Additionally, for the {\b getXbyY()}
 class of functions, error codes are NOT made available via the h_errno variable.  Instead, error codes are accessed by using the {\b WSAGetLastError()} API described in section {\field{\*\fldinst ref WSAGetLastError}{\fldrslt 4.3.11}}
.  This function is provided in Windows Sockets as a precursor (and eventually an alias) for the Win32 function {\b GetLastError()}
.  This is intended to provide a reliable way for a thread in a multi-threaded process to obtain per-thread error information.
\par \pard 
\par For compatibility with BSD, an application may choose to include a line of the form:
\par 
\par \pard\plain \s29\li1440 \f5\fs20\lang1033 #define errno WSAGetLastError()
\par \pard\plain \fs20\lang1033 
\par \pard 
This will allow networking code which was written to use the global errno to work correctly in a single-threaded environment.  There are, obviously, some drawbacks.  If a source file includes code which inspects errno for both socket and non-socket functi
ons, this mechanism cannot be used.  Furthermore, it is not possible for an application to assign a new value to errno.  (In Windows Sockets the function {\b WSASetLastError()} may be used for this purpose.)
\par \pard 
\par \pard \keepn \tab {\b TYPICAL BSD STYLE:
\par }\pard\plain \s29\li1440\keepn \f5\fs20\lang1033 r = recv(...);
\par if (r == -1
\par     && errno == EWOULDBLOCK)
\par \tab \{...\}
\par \pard\plain \fs20\lang1033 
\par \pard \keepn \tab {\b PREFERRED STYLE:}
\par \pard\plain \s29\li1440\keepn \f5\fs20\lang1033 r = recv(...);
\par if (r == -1       /* (but see below) */
\par     && WSAGetLastError() == EWOULDBLOCK)
\par \pard \s29\li1440\keepn {\b \tab \{...\}
\par }\pard \s29\li1440 
\par \pard\plain \fs20\lang1033 
Although error constants consistent with 4.3 Berkeley Sockets are provided for compatibility purposes, applications should, where possible, use the "WSA" error code definitions.  For example, a more accurate version of the above source code fragment is:

\par \pard 
\par \pard\plain \s29\li1440\keepn \f5\fs20\lang1033 r = recv(...);
\par if (r == -1{\revised        /* (but see below) */}
\par     && WSAGetLastError() == WSAEWOULDBLOCK)
\par \pard \s29\li1440\keepn {\b \tab \{...\}
\par }\pard\plain \fs20\lang1033 
\par \pard\plain \s252 \b\f2\lang1033 2.6.4 Pointers
\par \pard\plain \fs20\lang1033 All pointers used by applications with Windows Sockets should be FAR.  To facilitate this, data type definitions such as LPHOSTENT are provided.
\par \pard 
\par \pard\plain \s252 \b\f2\lang1033 2.6.5 Renamed functions
\par \pard\plain \fs20\lang1033 In two cases it was necessary to rename functions which are used in Berkeley Sockets in order to avoid clashes with other APIs.
\par \pard {\b 
\par }\pard\plain \s251 \b\lang1033 2.6.5.1 close() & closesocket()
\par \pard\plain \fs20\lang1033 In Berkeley Sockets, sockets are represented by standard file descriptors, and so the {\b close()}
 function can be used to close sockets as well as regular files.  While nothing in the Windows Sockets API prevents an implementation from using regular file handles to identify sockets, nothing requires it either.  Socket descriptors are not presumed to 
correspond to regular file handles, and file operations such as {\b read()}, {\b write()}, and {\b close()} cannot be assumed to work correctly when applied to socket{\revised s}.  Sockets must be closed by using the {\b closesocket()} routine.  Us
ing the {\b close()} routine to close a socket is incorrect and the effects of doing so are undefined by this specification.
\par \pard 
\par \pard\plain \s251 \b\lang1033 2.6.5.1 ioctl() & ioctlsocket()
\par \pard\plain \fs20\lang1033 Various C language run-time systems use the {\b ioctl()} routine for purposes unrelated to Windows Sockets.  For this reason we have defined the routine {\b ioctlsocket()}
 which is used to handle socket functions which in the Berkeley Software Distribution are performed using {\b ioctl()} and {\b fcntl()}.
\par \pard 
\par \pard\plain \s252 \b\f2\lang1033 2.6.6 Blocking routines & EINPROGRESS
\par \pard\plain \fs20\lang1033 Although blocking operations on sockets are supported under Windows Sockets, their use is strongly discouraged.  Programmers who are constrained to use blocking mode {\f1 -}
 for example, as part of an existing application which is to be ported {\f1 -} should be aware of the semantics of blocking operations in Windows Sockets.  See section {\field{\*\fldinst ref blocking}{\fldrslt 3.1.1}} for more details.
\par \pard 
\par \pard\plain \s252 \b\f2\lang1033 2.6.7 Maximum number of sockets supported
\par \pard\plain \fs20\lang1033 The maximum number of sockets supported by a particular Windows Sockets supplier is implementation specific.  An application
 should make no assumptions about the availability of a certain number of sockets.  This topic is addressed further in section {\field{\*\fldinst ref WSAStartup}{\fldrslt 4.3.15}}, {\b WSAStartup()}
.  However, independent of the number of sockets supported by a particular implementation is the issue of the maximum number of sockets which an application can actually make use of.
\par \pard 
\par \pard The maximum number of sockets which a Windows Sockets application can make use of is determined at compile time by the manifest constant FD_SETSIZE.  This value is used in constructing the fd_set structures used in {\b select()} (see section 
{\field{\*\fldinst ref select}{\fldrslt 4.1.18}}).  The default value in {\b winsock.h} is 64.  If an application is designed to be capable of working with more than 64 sockets, the implementor should define the manifest FD_SETSIZE in every source file {
\ul before} including {\b winsock.h}.  One way of doing this may be to include the definition within the compiler options in the makefile{\revised , for example adding  -DFD_SETSIZE=128 as an option to the compiler command line for Micros}{\revised oft C}
.  It must be emphasized that defining FD_SETSIZE as a particular value has no effect on the actual number of sockets provided by a Windows Sockets implementation.
\par \pard 
\par \pard\plain \s252 \b\f2\lang1033 2.6.8 Include files
\par \pard\plain \fs20\lang1033 For ease of portability of existing Berkeley sockets based source code, a number of standard Berkeley include files are supported.  However, these Berkeley header files merely include the {\b winsock.h}
 include file, and it is therefore sufficient (and recommended) that Windows Sockets application source files should simply include {\b winsock.h}.
\par \pard 
\par \pard\plain \s252 \b\f2\lang1033 2.6.9 Return values on API failure
\par \pard\plain \fs20\lang1033 The manifest constant SOCKET_ERROR is provided for checking API failure.  Although use of this constant is not mandatory, it is recommended.  The following example illustrates the use of the SOCKET_ERROR constant:
\par \pard 
\par \pard \keepn {\b \tab TYPICAL BSD STYLE:
\par }\pard\plain \s29\li1440\keepn \f5\fs20\lang1033 r = recv(...);
\par if (r == -1     /* or r < 0 */
\par     && errno == EWOULDBLOCK)
\par \pard \s29\li1440 \tab \{...\}
\par \pard\plain \keepn \fs20\lang1033 {\b \tab PREFERRED STYLE:}
\par \pard\plain \s29\li1440\keepn \f5\fs20\lang1033 r = recv(...);
\par if (r == SOCKET_ERROR
\par     && WSAGetLastError() == WSAEWOULDBLOCK)
\par \pard \s29\li1440 {\b \tab \{...\}
\par }\pard\plain \fs20\lang1033 
\par \pard\plain \s252 \b\f2\lang1033 {\revised 2.6.10 Raw Sock}{\revised ets
\par }\pard\plain \fs20\lang1033 {\revised 
The Windows Sockets specification does not mandate that a Windows Sockets DLL support raw sockets, that is, sockets opened with SOCK_RAW.  However, a Windows Sockets DLL is allowed and encouraged to supply raw socket support.  A Windows Sockets-compliant 
}{\revised application that wishes to use raw sockets should attempt to open the socket with the }{\b\revised socket()}{\revised  call (see section }{\field{\*\fldinst {\revised ref socket}}{\fldrslt {\revised 4.1.23}}}{\revised 
), and if it fails either attempt to use another socket type or indicate the failure to the user.
\par }\pard {\deleted 
\par }\pard\plain \s253\sb120 \b\f2\lang1033 2.{\revised 7 Windows Sockets}{\revised  in Multithreaded Versions of Windows
\par }\pard\plain \fs20\lang1033 {\revised The Windows Sockets interface is designed to work for both single-threaded versions of Windows (such as Windows 3.1) and preemptive multithreaded versions of Windows (such as }Windows NT{\revised 
).  In a multithreaded environment the sockets interface is basically the same, but the author of a multithreaded application must be aware that it is the responsibility of the application, not the Windows Sockets implementation, to synchronize access to 
}{\revised a socket between threads.  This i}{\revised s the same rule as applies to other forms of I/O such as file I/O.  Failure to synchronize calls on a socket leads to unpredictable results; for example if there are two simultaneous calls to }{
\b\revised send(), }{\revised there is no guarantee as to the order in which the data will be sent.  
\par }\pard {\revised 
\par }\pard {\revised Closing a socket in one thread that has an outstanding blocking call on the same socket in another thread will cause the blocking call to fail with WSAEINTR, just as if the operation were }canceled{\revised 
.  This also applies if there is a }{\b\revised select}{\b\revised ()}{\revised  call outstanding and the application closes one of the sockets being selected.
\par }\pard {\revised 
\par }\pard There is no default blocking hook installed in preemptive multithreaded versions of Windows.  {\revised This is because the machine will not be blocked if a single application is waiting for an operation to complete and hence not calling }{
\b\revised PeekMessage() }{\revised or }{\b\revised GetMessage()}{\revised  which cause the application to yield in nonpremptive Windows.  However, for backwards compatibility the }{\b\revised WSASetBlockingHook()}{\revised 
 call is implemented in multithreaded version}{\revised s of Windows, and any application whose behavior depends on the default blocking hook may install their own blocking hook which duplicates the default hook's semantics, if desired.
\par }\pard\plain \s33\keepn \b\fs20\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 Socket Library Overview {\field{\*\fldinst PAGE}{\fldrslt 19}}
\par }\pard\plain \s254\sb240 \b\f2\ul\lang1033 3.  SOCKET LIBRARY OVERVIEW
\par \pard\plain \s253\sb120 \b\f2\lang1033 3.1 Socket Functions
\par \pard\plain \fs20\lang1033 The Windows Sockets specification includes the following Berkeley-style socket routines:
\par 
\par \trowd \trgaph108\trleft-108 \clbrdrt\brdrs\brdrw30 \clbrdrl\brdrs\brdrw30 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3060\clbrdrt\brdrs\brdrw30 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw30 \cellx8100\pard \keepn\intbl {
\b accept()}{\b\revised  *}\cell \pard \keepn\intbl An incoming connection is acknowledged and associated with an immediately created socket.  The original socket is returned to the listening state.\cell \pard \intbl \row \trowd \trgaph108\trleft-108 
\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw30 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3060\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw30 \cellx8100\pard \keepn\intbl {\b bind()}\cell \pard 
\keepn\intbl Assign a local name to an unnamed socket.\cell \pard \intbl \row \pard \keepn\intbl {\b closesocket()}{\b\revised  *}\cell \pard \keepn\intbl Remove a socket from the per-process object reference table.{\revised 
  Only blocks if SO_LINGER is set.}\cell \pard \intbl \row \pard \keepn\intbl {\b connect()}{\b\revised  *}\cell \pard \keepn\intbl Initiate a connection on the specified socket.\cell \pard \intbl \row \pard \keepn\intbl {\b getpeername()}\cell \pard 
\keepn\intbl Retrieve the name of the peer connected to the specified socket{\revised .}\cell \pard \intbl \row \pard \keepn\intbl {\b getsockname()}\cell \pard \keepn\intbl Retrieve the current name for the specified socket\cell \pard \intbl \row \pard 
\keepn\intbl {\b getsockopt()}\cell \pard \keepn\intbl Retrieve options associated with the specified socket{\revised .}\cell \pard \intbl \row \pard \keepn\intbl {\b htonl()}\cell \pard \keepn\intbl 
Convert a 32-bit quantity from host byte order to network byte order.\cell \pard \intbl \row \pard \keepn\intbl {\b htons()}\cell \pard \keepn\intbl Convert a 16-bit quantity from host byte order to network byte order.\cell \pard \intbl \row \pard 
\keepn\intbl {\b inet_addr()}\cell \pard \keepn\intbl Converts a character string representing a number in the Internet standard ".'' notation to an Internet address value.\cell \pard \intbl \row \pard\plain \s5\fi-1440\li1440\keepn\intbl \fs20\lang1033 {
\b inet_ntoa()}\cell \pard\plain \keepn\intbl \fs20\lang1033 Converts an Internet address value to an ASCII string in ".'' notation i.e.  "a.b.c.d''.\cell \pard \intbl \row \pard \keepn\intbl {\b ioctlsocket()}\cell \pard \keepn\intbl Provide control for 
{\revised sockets.}\cell \pard \intbl \row \pard \keepn\intbl {\b listen()}\cell \pard \keepn\intbl Listen for incoming connections on a specified socket.\cell \pard \intbl \row \pard \keepn\intbl {\b ntohl()}\cell \pard \keepn\intbl 
Convert a 32-bit quantity from network byte order to host byte order.\cell \pard \intbl \row \pard \keepn\intbl {\b ntohs()}\cell \pard \keepn\intbl Convert a 16-bit quantity from network byte order to host byte order.\cell \pard \intbl \row \pard 
\keepn\intbl {\b recv()}{\b\revised  *}\cell \pard \keepn\intbl Receive data from a connected socket.\cell \pard \intbl \row \pard \keepn\intbl {\b recvfrom()}{\b\revised  *}\cell \pard \keepn\intbl 
Receive data from either a connected or unconnected socket.\cell \pard \intbl \row \pard \keepn\intbl {\b select()}{\b\revised  *}\cell \pard \keepn\intbl Perform synchronous I/O multiplexing.\cell \pard \intbl \row \pard \keepn\intbl {\b send()}{
\b\revised  *}\cell \pard \keepn\intbl Send data to a connected socket.\cell \pard \intbl \row \pard \keepn\intbl {\b sendto()}{\b\revised  *}\cell \pard \keepn\intbl Send data to either a connected or unconnected socket.\cell \pard \intbl \row \pard 
\keepn\intbl {\b setsockopt()}\cell \pard \keepn\intbl Store options associated with the specified socket{\revised .}\cell \pard \intbl \row \pard \keepn\intbl {\b shutdown()}\cell \pard \keepn\intbl Shut down part of a full-duplex connection.\cell \pard 
\intbl \row \trowd \trgaph108\trleft-108 \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw30 \clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw15 \cellx3060\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw30 \cellx8100\pard 
\keepn\intbl {\b socket()}\cell \pard \keepn\intbl Create an endpoint for communication and return a socket{\revised .}\cell \pard \intbl \row \pard {\revised 
\par }{\revised * = The routine can block if acting on a blocking socket.
\par }
\par \pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart blocking}3.1.1{\*\bkmkend blocking} Blocking/Non blocking & Data Volatility
\par \pard\plain \fs20\lang1033 
One major issue in porting applications from a Berkeley sockets environment to a Windows environment involves "blocking"; that is, invoking a function which does not return until the associated operation is completed.  The problem arises when the operatio
n may take an arbitrarily long time to complete: an obvious example is a {\b recv()}
 which may block until data has been received from the peer system.  The default behavior within the Berkeley sockets model is for a socket to operate in a blocking mode unless the programmer explicitly requests that operations be treated as non-blocking.
{\revised   }{\b\i\revised 
It is strongly recommended that programmers use the nonblocking (asynchronous) operations if at all possible, as they work significantly better within the nonpreemptive Windows environment.  Use blocking operations only if absolutely necessary, and }{
\b\i\revised carefully read and understand this section if you must use blocking operations.}{\b 
\par }\pard 
\par \pard Even on a blocking socket, some operations (e.g. {\b bind()}, {\b getsockopt()}, {\b getpeername()}) can be completed immediately.  For such operations there is no difference between blocking and non-blocking operation.  Other operations (e.g. {\b 
recv()}) may be completed immediately or may take an arbitrary time to complete, depending on various transport conditions.  When applied to a blocking socket, these operations are referred to as blocking operations.{\revised 
  All routines which can block are listed with an asterisk in the tables above and below.}
\par \pard 
\par \pard 
Within a Windows Sockets implementation, a blocking operation which cannot be completed immediately is handled as follows.  The DLL initiates the operation, and then enters a loop in which it dispatches any Windows messages (yielding the processor to anot
her thread if necessary) and then checks for the completion of the Windows Sockets function.  If the function has completed, or if {\b WSACancelBlockingC}{\b all()}
 has been invoked, the blocking function completes with an appropriate result.  Refer to section {\field{\*\fldinst ref WSASetBlockingHook}{\fldrslt 4.3.13}}, {\b WSASetBlockingHook()}
, for a complete description of this mechanism, including pseudocode for the various functions.
\par \pard 
\par \pard 
If a Windows message is received for a process for which a blocking operation is in progress, there is a risk that the application will attempt to issue another Windows Sockets call.  Because of the difficulty of managing this condition safely, the Window
s Sockets specification does not support such application behavior.  Two functions are provided to assist the programmer in this situation.  {\b WSAIsBlocking()} may be called to determine whether or not a blocking Windows Sockets call is in progress.  {
\b WSACancelBlockingCall()} may be called to cancel an in-progress blocking call, if any.  {\ul Any other Windows Sockets function which is called in this situation will fail with the error WSAEINPROGRESS}
.  It should be emphasized that this restriction applies to both blocking and non-blocking operations.
\par \pard 
\par \pard 
Although this mechanism is sufficient for simple applications, it cannot support the complex message-dispatching requirements of more advanced applications (for example, those using the MDI model).  For such applications, the Windows Sockets API includes 
the function {\b WSASetBlockingHook()}, which allows the programmer to define a special routine which will be called instead of the default message dispatch routine described above.
\par \pard {\revised 
\par }\pard {\revised The Windows Sockets DLL calls the blocking }{\revised 
hook only if all of the following are true: the routine is one which is defined as being able to block, the specified socket is a blocking socket, and the request cannot be completed immediately.  (A socket is set to blocking by default, but the IOCTL FIO
}{\revised NBIO and  }{\b\revised WSAAsyncSelect()}{\revised  both set a socket to nonblocking mode.)  If an application uses only non}-{\revised blocking sockets and uses the }{\b\revised WSA}{\b AsyncSelect() }and/or the {\b WSA}{\b\revised 
AsyncGetXByY() }{\revised routines instead of }{\b select() }and {\revised the }{\b\revised getXbyY() }{\revised routines, then the blocking hook w}{\revised 
ill never be called and the application does not need to be concerned with the reentrancy issues the blocking hook can introduce.
\par }\pard 
\par \pard 
If an application invokes an asynchronous or non-blocking operation which takes a pointer to a memory object (e.g. a buffer, or a global variable) as an argument, it is the responsibility of the application to ensure that the object is available to the Wi
ndows Sockets implementation throughout the operation.  The application must not invoke any Windows function which might aff
ect the mapping or addressability of the memory involved.  In a multithreaded system, the application is also responsible for coordinating access to the object using appropriate synchronization mechanisms.  A Windows Sockets implementation cannot, and wil
l not, address these issues.  The possible consequences of failing to observe these rules are beyond the scope of this specification.
\par \pard 
\par \pard\plain \s253\sb120 \b\f2\lang1033 3.2 Database Functions
\par \pard\plain \fs20\lang1033 The Windows Sockets specification defines the following "database" routines.  As noted earlier, 
a Windows Sockets supplier may choose to implement these in a manner which does not depend on local database files.  The pointer returned by certain database routines such as {\b gethostbyname()}
 points to a structure which is allocated by the Windows Sockets library.  The data which is pointed to is volatile and is good only until the next Windows Sockets API call from that thread.  Additionally, the application must never attempt to modify this
 structure or to free any of its components.  Only one copy of this structure is allocated for a thread, and so the application should copy any information which it needs before issuing any other Windows Sockets API calls.
\par \pard 
\par 
\par \trowd \trgaph108\trleft-108 \clbrdrt\brdrs\brdrw30 \clbrdrl\brdrs\brdrw30 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3060\clbrdrt\brdrs\brdrw30 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw30 \cellx8100\pard \keepn\intbl {
\b gethostbyaddr()}{\b\revised  *}\cell \pard \keepn\intbl Retrieve the name(s) and address corresponding to a network address.\cell \pard \intbl \row \trowd \trgaph108\trleft-108 \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw30 \clbrdrb\brdrs\brdrw15 
\clbrdrr\brdrs\brdrw15 \cellx3060\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw30 \cellx8100\pard \keepn\intbl {\b\revised gethostbyname() *}\cell \pard \keepn\intbl 
Retrieve the name(s) and address corresponding to a host name{\revised .}\cell \pard \intbl \row \pard \keepn\intbl {\b\revised gethostname()}\cell \pard \keepn\intbl {\revised Retrieve the name of the local host.}\cell \pard \intbl \row \pard 
\keepn\intbl {\b getprotobyname()}{\b\revised  *}\cell \pard \keepn\intbl Retrieve the protocol name and number corresponding to a protocol name.\cell \pard \intbl \row \pard \keepn\intbl {\b getprotobynumber()}{\b\revised  *}\cell \pard \keepn\intbl 
Retrieve the protocol name and number corresponding to a protocol number.\cell \pard \intbl \row \pard \keepn\intbl {\b getservbyname()}{\b\revised  *}\cell \pard \keepn\intbl Retrieve the service name and port corresponding to a service name.\cell \pard 
\intbl \row \pard \keepn\intbl {\b getservbyport()}{\b\revised  *}\cell \pard \keepn\intbl Retrieve the service name and port corresponding to a port.\cell \pard \intbl \row \trowd \trgaph108\trleft-108 \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw30 
\clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw15 \cellx3060\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw30 \cellx8100\pard \keepn\intbl {\b \cell }\pard \keepn\intbl \cell \pard \intbl \row \pard {\b\revised 

\par }{\b\revised * = }{\revised The routine can block under some circumstances.}{\b\revised 
\par }{\b 
\par }\pard\plain \s253\sb120 \b\f2\lang1033 3.3 Microsoft Windows-specific Extension Functions
\par \pard\plain \fs20\lang1033 The Windows Sockets specification provides a number of extensions to the standard set of Berkeley Sockets routines.  Principally, these extended APIs all
ow message-based, asynchronous access to network events.  While use of this extended API set is not mandatory for socket-based programming  {\revised (with the }exception of {\b\revised WSAStartup() }{\revised and }{\b\revised WSACleanup()}{\revised )}
, it is recommended for conformance with the Microsoft Windows programming paradigm.
\par \pard 
\par \pard \fi-3600\li3600 
\par \trowd \trgaph108\trleft-108 \clbrdrt\brdrs\brdrw30 \clbrdrl\brdrs\brdrw30 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3060\clbrdrt\brdrs\brdrw30 \clbrdrl\brdrs\brdrw15 \clbrdrr\brdrs\brdrw30 \cellx8100\pard \keepn\intbl {\b 
WSAAsyncGetHostByAddr()}\cell \pard \keepn\intbl A set of functions which provide asynchronous\cell \pard \intbl \row \trowd \trgaph108\trleft-108 \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw30 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3060
\clbrdrl\brdrs\brdrw15 \clbrdrr\brdrs\brdrw30 \cellx8100\pard \keepn\intbl {\b WSAAsyncGetHostByName()}\cell \pard \keepn\intbl versions of the standard Berkeley\cell \pard \intbl \row \pard \keepn\intbl {\b WSAAsyncGetProtoByName()}\cell \pard 
\keepn\intbl {\b getXbyY()} functions.  For example, the\cell \pard \intbl \row \pard \keepn\intbl {\b WSAAsyncGetProtoByNumber(}{\b )}\cell \pard \keepn\intbl {\b WSAAsyncGetHostByName()} function provides an\cell \pard \intbl \row \pard \keepn\intbl {
\b WSAAsyncGetServByName()}\cell \pard \keepn\intbl asynchronous message based implementation of\cell \pard \intbl \row \trowd \trgaph108\trleft-108 \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw30 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3060
\clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw30 \cellx8100\pard \keepn\intbl {\b WSAAsyncGetServByPort()}\cell \pard \keepn\intbl the standard Berkeley {\b gethostbyname()} function.\cell \pard \intbl \row \trowd 
\trgaph108\trleft-108 \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw30 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3060\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw30 \cellx8100\pard \keepn\intbl {\b 
WSAAsyncSelect()\cell }\pard \keepn\intbl Perform asynchronous version of {\b select()}\cell \pard \intbl \row \pard \keepn\intbl {\b WSACancelAsyncRequest()}\cell \pard \keepn\intbl Cancel an outstanding instance of a {\b WSAAsyncGetXByY()} function.
\cell \pard \intbl \row \pard \keepn\intbl {\b WSACancelBlockingCall()}\cell \pard \keepn\intbl Cancel an outstanding "blocking" API call\cell \pard \intbl \row \pard \keepn\intbl {\b WSACleanup()}\cell \pard \keepn\intbl 
Sign off from the underlying Windows Sockets DLL.\cell \pard \intbl \row \pard \keepn\intbl {\b WSAGetLastError()}\cell \pard \keepn\intbl Obtain details of last Windows Sockets API error\cell \pard \intbl \row \pard \keepn\intbl {\b WSAIsBlocking()}
\cell \pard \keepn\intbl Determine if the underlying Windows Sockets DLL is already blocking an existing call for this thread\cell \pard \intbl \row \pard \keepn\intbl {\b WSASetBlockingHook()}\cell \pard \keepn\intbl 
"Hook" the blocking method used by the underlying Windows Sockets implementation\cell \pard \intbl \row \pard \keepn\intbl {\b WSASetLastError()}\cell \pard \keepn\intbl Set the error to be returned by a subsequent {\b WSAGetLastError()}\cell \pard 
\intbl \row \pard \keepn\intbl {\b WSAStartup()}\cell \pard \keepn\intbl Initialize the underlying Windows Sockets DLL.\cell \pard \intbl \row \trowd \trgaph108\trleft-108 \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw30 \clbrdrb\brdrs\brdrw30 \clbrdrr
\brdrs\brdrw15 \cellx3060\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw30 \cellx8100\pard \keepn\intbl {\b WSAUnhookBlockingHook()}\cell \pard \keepn\intbl Restore the original blocking function\cell \pard 
\intbl \row \pard 
\par \pard\plain \s252 \b\f2\lang1033 3.3.1 Asynchronous select() Mechanism
\par \pard\plain \fs20\lang1033 The {\b WSAAsyncSelect()} API allows an application to register an interest in one or many network events.  This API is provided to supersede the need to do polled network I/O.  Any situation in which {\b select()}
 or non-blocking I/O routines (such as {\b send()} and {\b recv()}) are either already used or are being considered is usually a candidate for the {\b WSAAsyncSelect()}
 API.  When declaring interest in such condition(s), you supply a window handle to be used for notification.  The corresponding window then receives message-based notification of the conditions in which you declared an interest.
\par \pard 
\par \pard \keepn {\b WSAAsyncSelect()} allows interest to be declared in the following conditions for a particular socket:
\par \tab Socket readiness for reading
\par \tab Socket readiness for writing
\par \tab Out-of-band data ready for reading
\par \tab Socket readiness for accepting incoming connection
\par \tab Completion of non-blocking {\b connect()}
\par \pard \tab Connection closure
\par 
\par \pard\plain \s252 \b\f2\lang1033 3.3.2 Asynchronous Support Routines
\par \pard\plain \fs20\lang1033 The asynchronous "database" functions allow applications to request information in an asynchronous manner.  Some network implementations and/or configurations perform network based operations to resolve such requests.  The {\b 
WSAAsyncGetXByY()} functions allow application developers to request services which would otherwise block the operation of the whole Windows environment if the standard Berkeley function were used.  The {\b WSACancelAsyncRequest()}
 function allows an application to cancel any outstanding asynchronous request.
\par \pard 
\par \pard\plain \s252 \b\f2\lang1033 3.3.3 Hooking Blocking Methods
\par \pard\plain \fs20\lang1033 As noted in section {\field{\*\fldinst ref blocking}{\fldrslt 3.1.1}}
 above, Windows Sockets implements blocking operations in such a way that Windows message processing can continue, which may result in the application which issued the call receiving a Windows message.  In certain situations an application may want to inf
luence or change the way in which this pseudo-blocking process is implemented.  The {\b WSASetBlockingHook()} provides the ability to substitute a named routine which the Windows Sockets implementation is to use when relinquishing 
the processor during a "blocking" operation.
\par \pard 
\par \pard\plain \s252 \b\f2\lang1033 3.3.4 Error Handling
\par \pard\plain \fs20\lang1033 For compatibility with thread-based environments, details of API errors are obtained through the {\b WSAGetLastError()}
 API.  Although the accepted "Berkeley-Style" mechanism for obtaining socket-based network errors is via "errno", this mechanism cannot guarantee the integrity of an error ID in a multi-threaded environment.  {\b WSAGetLastError()}
 allows you to retrieve an error code on a per thread basis.
\par \pard 
\par \pard {\b WSAGetLastError()} returns error codes 
which avoid conflict with standard Microsoft C error codes.  Certain error codes returned by certain Windows Sockets routines fall into the standard range of error codes as defined by Microsoft C.  If you are NOT using an application development environme
nt which defines error codes consistent with Microsoft C, you are advised to use the Windows Sockets error codes prefixed by "WSA" to ensure accurate error code detection.
\par \pard 
\par \pard Note that this specification defines a recommended set of error codes, and lists t
he possible errors which may be returned as a result of each function.  It may be the case in some implementations that other Windows Sockets error codes will be returned in addition to those listed, and applications should be prepared to handle errors ot
her than those enumerated under each API description.  However a Windows Sockets implementation must not return any value which is not enumerated in the table of legal Windows Sockets errors given in Appendix A.1.
\par \pard 
\par \pard\plain \s252 \b\f2\lang1033 {\revised 3.3.5 Accessing a Windows Sockets DLL fr}{\revised om an Intermediate DLL
\par }\pard\plain \fs20\lang1033 {\revised 
A Windows Sockets DLL may be accessed both directly from an application and through an "intermediate" DLL.  An example of such an intermediate DLL would be a virtual network API layer that supports generalized network functionality for applications and us
}{\revised es Windows Sockets.  Such a DLL could be used by several applications simultaneously, and the DLL must take special precautions with respect to the }{\b\revised WSAStartup() }{\revised and}{\b\revised  WSACleanup() }{\revised 
calls to ensure that these routines are called in the c}{\revised ontext of each task that will make Windows Sockets calls.  This is because the Windows Sockets DLL will need a call to }{\b\revised WSAStartup() }{\revised 
for each task in order to set up task-specific data structures, and a call to }{\b\revised WSACleanup() }{\revised to free any resources allocated for the task.  
\par }\pard {\revised 
\par }\pard {\revised There are (at least) two ways to accomplish this.  The simplest method is for the intermediate DLL to have calls similar to }{\b\revised WSAStartup() }{\revised and}{\b\revised  WSACleanup() }{\revised 
that applications call as appropriate.  The DLL would then call }{\b\revised WSAStartup() }{\revised or}{\b\revised  WSAC}{\b\revised leanup() }{\revised 
 from within these routines.  Another mechanism is for the intermediate DLL to build a table of task handles, which are obtained from the }{\b\revised GetCurrentTask() }{\revised 
Windows API, and at each entry point into the intermediate DLL check whether }{\b\revised WSAStartup() }{\revised has been called for the current task, then call }{\b\revised WSAStartup() }{\revised if necessary.
\par }\pard {\revised 
\par }\pard {\revised If a DLL makes a blocking call and does not install its own blocking hook, then the DLL author must be aware that control may be returned to the application either by an applicatio}{\revised 
n-installed blocking hook or by the default blocking hook.  Thus, it is possible that the application will cancel the DLL's blocking operation via }{\b\revised WSACancelBlockingCall()}{\revised 
.  If this occurs, the DLL's blocking operation will fail with the error code WSAEINTR, and the DLL must return control to the calling task as quickly as possible, as the used has likely pressed a cancel or close button and the task has requested control 
}{\revised of the CPU.  It is recommended that DLLs which make blocking calls install their own bl}{\revised ocking hooks with }{\b\revised WSASetBlockingHook()}{\revised  to prevent unforeseen interactions between the application and the DLL.}{
\i\revised 
\par }\pard {\i\revised 
\par }\pard {\revised Note that this is not necessary for DLLs in }Windows NT{\revised  because of its different process and DLL structure.  Under }Windows NT{\revised , the intermediate DLL could simply call }{\b\revised WSAStartup() }{\revised 
in its DLL initialization routine, which is called whenever a new process which uses the DLL starts.
\par }\pard {\revised 
\par }\pard\plain \s252 \b\f2\lang1033 {\revised 3.3.6 Internal use of Messages by Windows Sockets Implementations
\par }\pard\plain \fs20\lang1033 {\revised In order to implement Windows Sockets purely as a}{\revised 
 DLL, it may be necessary for the DLL to post messages internally for communication and timing.  This is perfectly legal; however, a Windows Sockets DLL must not post messages to a window handle opened by a client application except for those messages req
}{\revised uested by the application.  A Windows Sockets DLL that needs to use messages for its own purposes must open a hidden window and post any necessary messages to the handle for that window.
\par }\pard {\revised 
\par }\pard\plain \s252 \b\f2\lang1033 {\revised 3.3.7 Private API Interfaces
\par }\pard\plain \fs20\lang1033 {\revised The winsock.def file in Appendix B.7 }{\revised 
lists the ordinals defined for the Windows Sockets APIs.  In addition to the ordinal values listed, all ordinals 999 and below are reserved for future Windows Sockets use.  It may be convenient for a Windows Sockets implementation to export additional, pr
}{\revised 
ivate interfaces from the Windows Sockets DLL.  This is perfectly acceptable, as long as the ordinals for these exports are above 1000.  Note that any application that uses a particular Windows Sockets DLL's private APIs will most likely not work on any o
}{\revised th}{\revised er vendor's Windows Sockets implementation.  Only the APIs defined in this document are guaranteed to be present in every Windows Sockets implementation.
\par }\pard {\revised 
\par }\pard {\revised If an application uses private interfaces of a particular vendor's Windows Sockets DLL, it is recommended that the DLL not be statically linked with the application but rather dynamically loaded with the Windows routines }{\b\revised 
LoadLibrary()}{\revised  and }{\b\revised GetProcAddress().}{\revised   This allows the application to give an informative error message if it is run on a system with a }{\revised 
Windows Sockets DLL that does not support the same set of extended functionality.}
\par \pard\plain \s254\sb240 \b\f2\ul\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 Socket Library Reference {\field{\*\fldinst PAGE}{\fldrslt 15}}
\par }{\footer \pard\plain \s242\qc\tqc\tx4320\tqr\tx8640 \fs20\lang1033 
\par }\pard\plain \s254\sb240 \b\f2\ul\lang1033 4.  SOCKET LIBRARY REFERENCE
\par \pard\plain \s253\sb120 \b\f2\lang1033 4.1 Socket Routines
\par \pard\plain \fs20\lang1033 This chapter presents the socket library routines in alphabetical order, and describes each routine in detail.  
\par \pard 
\par \pard In each routine it is indicated that the header file {\b winsock.h}
 must be included.  Appendix A.2 lists the Berkeley-compatible header files which are supported.  These are provided for compatibility purposes only, and each of them will simply include {\b winsock.h}.  The Windows header file {\b windows.h}
 is also needed, but {\b winsock.h} will include it if necessary.
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 accept {\field{\*\fldinst PAGE}{\fldrslt 21}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart accept}4.1.1{\*\bkmkend accept} accept()
\par \pard\plain \fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Accept a connection on a socket.
\par 
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fi-1440\li1440 \fs20\lang1033 
\par {\b\f2  }\tab {\b SOCKET }{\b\revised PASCAL FAR }{\b accept ( SOCKET} {\i s}{\b , struct sockaddr FAR *} {\i addr}{\b\i ,}{\b  }{\b\revised 
\par }{\b\revised \tab }{\b int FAR * }{\i addrlen }{\b );}
\par 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i s}\tab A descriptor identifying a socket which is listening for connections after a {\b listen}().
\par \pard \s10\fi-1440\li2880 
\par \pard \s10\fi-1440\li2880 {\i addr}\tab {\revised An optional pointer to a buffer which receives }the address of the connecting entity, as known to the communications layer.  The exact format of the {\i addr}
 argument is determined by the address family established when the socket was created.
\par \pard \s10\fi-1440\li2880 
\par \pard \s10\fi-1440\li2880 {\i addrlen}\tab A{\revised n optional} pointer to an integer which contains the length of the address {\i addr}.
\par \pard\plain \fi-1440\li1440 \fs20\lang1033 
\par \pard\plain \s2\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This routine extracts the first connection on the queue of pending connections on {\i s}, creates a new socket with the same properties as {\i s}
 and returns a handle to the new socket.  If no pending connections are present on the queue, and the socket is not marked as non-blocking, {\b accept()} blocks the caller u
ntil a connection is present.  If the socket is marked non-blocking and no pending connections are present on the queue, {\b accept()}
 returns an error as described below.  The accepted socket may not be used to accept more connections.  The original socket remains open.
\par \pard\plain \fi-1440\li1440 \fs20\lang1033 
\par \pard \li1440 The argument {\i addr} is a result parameter that is filled in with the address of the connecting entity, as known to the communications layer.  The exact format of the {\i addr}
 parameter is determined by the address family in which the communication is occurring.  The {\i addrlen} is a value-result parameter; it should initially contain the amount of space pointed to by {\i addr}
; on return it will contain the actual length (in bytes) of the address returned.  This call is used with connection-based socket types such as SOCK_STREAM.{\revised   If }{\i\revised addr}{\revised  and/or }{\i\revised addrlen}{\revised 
 are equal to NULL, then no information about the remote address of the accepted socket is returned.}
\par \pard 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b accept}() returns a value of type SOCKET which is a descriptor for the a
ccepted packet.  Otherwise, a value of INVALID_SOCKET is returned, and a specific error code may be retrieved by calling {\b WSAGetLastError}().
\par \pard \s7\fi-1440\li1440 
\par \pard\plain \s14\li1440 \fs20\lang1033 The integer referred to by {\i addrlen} initially contains the amount of space pointed to by {\i addr}.  On return it will contain the actual length in bytes of the address returned.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEFAULT\tab The {\i addrlen }{\revised argument is too small (less than the sizeof a struct sockaddr).}
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINTR\tab The (blocking) call was canceled via {\b WSACancelBlockingCall().}
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAEINPROGRESS\tab A blocking Windows Sockets call is in progress.
\par 
\par WSAEINVAL\tab {\b listen()} was not invoked prior to {\b accept()}.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEMFILE\tab The queue is empty upon entry to {\b accept()} and there are no descriptors available.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAENOBUFS\tab No buffer space is available.
\par 
\par WSAENOTSOCK\tab The descriptor is not a socket.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEOPNOTSUPP\tab The referenced socket is not a type that supports connection-oriented service.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEWOULDBLOCK\tab The socket is marked as non-blocking and no connections are present to be accepted.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b bind()}, {\b connect()}, {\b listen()}, {\b select()}, {\b socket()}, {\b WSAAsyncSelect()}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 bind {\field{\*\fldinst PAGE}{\fldrslt 23}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart bind}4.1.2{\*\bkmkend bind} bind()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Associate a local address with a socket.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fi-1440\li1440 \fs20\lang1033 
\par \pard\plain \s2\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int }{\b\revised PASCAL FAR }{\b bind ( SOCKET }{\i s}{\b\i ,}{\b  }{\b\revised const }{\b struct sockaddr FAR *} {\i name},{\b  int} {\i namelen }{\b );}
\par \pard\plain \fi-1440\li1440 \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i s}\tab A descriptor identifying an unbound socket.
\par 
\par \pard \s10\fi-1440\li2880 {\i name}\tab The address to assign to the socket.  The sockaddr structure is defined as follows:
\par \pard\plain \s32\fi-1440\li2880 \f5\fs20\lang1033 
\par \tab struct sockaddr \{
\par \tab \tab u_short\tab sa_family;
\par \tab \tab char\tab sa_data[14];
\par \tab \};
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 
\par {\i namelen}\tab The length of the {\i name}.
\par \pard\plain \fi-1440\li1440 \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This routine is used on an unconnected datagram or stream socket, before subsequent {\b connect}()s or {\b listen}()s.  When a socket is created with {\b socket}
(), it exists in a name space (address family), but it has no name assigned.  {\b bind}() establishes the local association (host address/port number) of the socket by assigning a local name to an unnamed socket.
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 
In the Internet address family, a name consists of several components.  For SOCK_DGRAM and SOCK_STREAM, the name consists of three parts: a host address, the protocol number (set implicitly to UDP or TCP, respectively), and a port number which identifies 
the application.  If an application does not care what address is assigned to it, it may specify{\revised  }an Internet address {\revised equal to INADDR_ANY, a }port equal to 0{\revised , or both}.  {\revised 
If the Internet address is equal to INADDR_ANY, any appropriate network interface }{\revised will be used; this simplifies application programming in the presence of multi-homed hosts.  }If the port is specified as 0, the Windows Sockets implemen{
\revised t}ation will assign a unique port to the application with a value between 1024 and 5000.  The application may use {\b getsockname()} after {\b bind()} to learn the address that has been assigned to it{\revised , but note that }{\b\revised 
getsockname()}{\revised  will not necessarily fill in the Internet address until the socket is connected, since several Internet addresses may be valid if the host is}{\revised  multi-homed.
\par }\pard \s12\li1440 
\par \pard \s12\li1440 {\revised If an application desires to bind to an arbitrary port outside of the range 1024 to 5000, such as the case of rsh which must bind to any reserved port, code similar to the following may be used:
\par }\pard\plain \fs20\lang1033 {\f4\revised 
\par }\pard\plain \s29\li1440 \f5\fs20\lang1033 {\revised     SOCKADDR_IN sin;
\par }{\revised     SOCKET s;
\par }{\revised     u}_{\revised short alport = IPPORT_RESERVED;
\par }{\revised 
\par }{\revised     sin.sin_family = AF_INET;
\par }{\revised     sin.sin_addr.s_addr = 0;
\par }{\revised     for (;;) \{
\par }{\revised         sin.sin_port = htons(alport);
\par }{\revised         if (bind(s, (LPSOCKADDR)&sin, sizeof (sin)) == 0) \{
\par }{\revised             /* it worked */
\par }{\revised         \}
\par }{\revised   }{\revised       if ( GetLastError() != WSAEADDRINUSE) \{
\par }{\revised             /* fail */
\par }{\revised         \}
\par }{\revised         alport--;
\par }{\revised         if (alport == IPPORT_RESERVED/2 ) \{
\par }{\revised             /* fail--all unassigned reserved ports are */
\par }{\revised             /* in use. */
\par }{\revised         \}
\par }{\revised     \}
\par }\pard\plain \s12\li1440 \fs20\lang1033 {\revised 
\par }{\revised 
\par }
\par \pard\plain \fi-1440\li1440 \fs20\lang1033 
\par \pard 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b bind()} returns 0.  Otherwise, it returns SOCKET_ERROR, and a specific error code may be retrieved by calling {\b WSAGetLastError()}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEADDRINUSE \tab The specified address is already in use.  (See the SO_REUSEADDR socket option under {\b setsockopt()}.)
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEFAULT\tab The {\i namelen} argument is too small (less than the size of a struct sockaddr).
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAEINPROGRESS\tab A blocking Windows Sockets call is in progress.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEAFNOSUPPORT\tab The specified address family is not supported by this protocol.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAEINVAL\tab The socket is already bound to an address.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENOBUFS\tab Not enough buffers available, too many connections.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAENOTSOCK\tab The descriptor is not a socket.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b connect()}, {\b listen()}, {\b getsockname()}, {\b setsockopt()}, {\b socket()}, {\b WSACancelBlockingCall()}.
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 closesocket {\field{\*\fldinst PAGE}{\fldrslt 25}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart closesocket}{\*\bkmkstart this}4.1.3{\*\bkmkend closesocket}{\*\bkmkend this} closesocket()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Close a socket.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int }{\b\revised PASCAL FAR }{\b closesocket ( SOCKET} {\i s }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i s}\tab A descriptor identifying a socket.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This function closes a socket.  More precisely, it releases the socket descriptor {\i s}, so that further references to {\i s} will 
fail with the error WSAENOTSOCK.  If this is the last reference to the underlying socket, the associated naming information and queued data are discarded.
\par \pard \s5\fi-1440\li1440 
\par \pard\plain \s12\li1440 \fs20\lang1033 The semantics of {\b closesocket}() are affected by the socket options SO_LINGER and SO_DONTLINGER as follows:
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 Option\tab \tab Interval\tab \tab Type of close\tab Wait for close?
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 SO_DONTLINGER\tab Don't care\tab Graceful\tab \tab No
\par SO_LINGER\tab \tab Zero\tab \tab Hard\tab \tab No
\par SO_LINGER\tab \tab Non-zero\tab Graceful\tab \tab Yes
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 If SO_LINGER is set (i.e. the {\i l_onoff} field of the linger structure is non-zero; see sections {\field{\*\fldinst ref Socket_Options}{\fldrslt 2.4}},  {\field{\*\fldinst ref getsockopt}{\fldrslt 4.1.7}} and 
{\field{\*\fldinst ref setsockopt}{\fldrslt 4.1.21}}) with a zero timeout interval ({\i l_linger} is zero), {\b closesocket()} is not blocked even if queued data has not yet been sent or acknowledged.  This is called a "hard"{\revised  or "abortive"}
 close, because the socket's virtual circuit is reset immediately, and any unsent data is lost.{\revised   Any }{\b\revised recv() }{\revised call on the remote side of the circuit will fail with WSAECONNRESET.}
\par \pard \s12\li1440 
\par \pard \s12\li1440 If SO_LINGER is set with a non-zero timeout interval, the {\b closesocket()} call blocks until the remaining data has been sent or until the timeout expires.  This is called a graceful disconnect.{\revised 
  Note that if the socket is set to non-blocking and SO_LINGER is set to a non-zero timeout, the call to }{\b\revised closesocket() }{\revised will fail with an error of WSAEWOULDBLOCK.}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 If SO_DONTLINGER is set on a stream socket (i.e. the {\i l_onoff} field of the linger structure is zero; see sections {\field{\*\fldinst ref Socket_Options}{\fldrslt 2.4}}, {\field{\*\fldinst ref getsockopt
}{\fldrslt 4.1.7}} and {\field{\*\fldinst ref setsockopt}{\fldrslt 4.1.21}}), the {\b closesocket()} call will return immedi
ately.  However, any data queued for transmission will be sent if possible before the underlying socket is closed.  This is also called a graceful disconnect.  Note that in this case the Windows Sockets implementation may not release the socket and other 
resources for an arbitrary period, which may affect applications which expect to use all available sockets.
\par \pard\plain \fs20\lang1033 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b closesocket()} returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling {\b WSAGetLastError().}
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAENOTSOCK\tab The descriptor is not a socket.
\par 
\par WSAEINPROGRESS\tab A blocking Windows Sockets call is in progress.
\par {\revised 
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\revised WSAEINTR\tab The (blocking) call was canceled via }{\b\revised WSACancelBlockingCall().
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\b\revised 
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\revised WSAEWOULDBLOCK\tab The socket is marked as nonblocking and SO_LINGER is set to a nonzero timeou}{\revised t value.
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 
\par \pard \s9\fi-1440\li1440 {\b\f2 See Also}\tab {\b accept()}, {\b socket()}, {\b ioctlsocket()}, {\b setsockopt()}, {\b WSAAsyncSelect()}.
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 connect {\field{\*\fldinst PAGE}{\fldrslt 27}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart connect}4.1.4{\*\bkmkend connect} connect()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Establish a connection to a peer.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int }{\b\revised PASCAL FAR }{\b connect ( SOCKET} {\i s}{\b , }{\b\revised const }{\b struct sockaddr FAR * }{\i name}{\b , }{\b\revised 
\par }{\b\revised \tab }{\b int} {\i namelen }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i s}\tab A descriptor identifying an unconnected socket.
\par 
\par {\i name}\tab The name of the peer to which the socket is to be connected.
\par 
\par {\i namelen}\tab The length of the {\i name}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This function is used to create a connection to the specified foreign association.  The parameter {\i s}
 specifies an unconnected datagram or stream socket  If the socket is unbound, unique values are assigned to the local association by the system, and the socket is marked as bound.  Note that if the address field of the {\i name} structure is all zeroes, 
{\b connect()} will return the error WSAEADDRNOTAVAIL.
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 For stream sockets (type SOCK_STREAM), an active connection is initiated to the foreign host using {\i name} (an address in the name space of the socket).  When the socket call complet
es successfully, the socket is ready to send/receive data.  
\par \pard \s12\li1440 
\par \pard \s12\li1440 For a datagram socket (type SOCK_DGRAM), a default destination is set, which will be used on subsequent {\b send}() and {\b recv}() calls.
\par \pard \s12\li1440 
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b connect()} returns 0.  Otherwise, it returns SOCKET_ERROR, and a specific error code may be retrieved by calling {\b WSAGetLastError().}{\b\revised 
\par }\pard \s7\fi-1440\li1440 {\b\revised 
\par }\pard\plain \s14\li1440 \fs20\lang1033 {\revised On a blocking socket, the return value indicates success or failure of the connection attempt.
\par }\pard \s14\li1440 {\revised 
\par }\pard \s14\li1440 {\revised On a non-blocking socket, if the return value is }{\revised SOCKET_ERROR an application should call }{\b\revised WSAGetLastError().}{\revised 
  If this indicates an error code of WSAEWOULDBLOCK, then your application can either:
\par }\pard \s14\li1440 {\revised 
\par }\pard \s14\li1440 {\revised 1. Use }{\b\revised select()}{\revised  to determine the completion of the connection request by checking if the socket is writeable,  or
\par }\pard \s14\li1440 {\revised 
\par }\pard \s14\li1440 {\revised 2. If your application is using the message-based }{\b\revised WSAAsyncSelect()}{\revised 
 to indicate interest in connection events, then your application will receive an FD_CONNECT message when the connect operation is complete.}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAEADDRINUSE\tab The specified address is already in use.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINTR\tab The (blocking) call was canceled via {\b WSACancelBlockingCall().}
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAEINPROGRESS\tab A blocking Windows Sockets call is in progress.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEADDRNOTAVAIL\tab The specified address is not available from the local machine.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEAFNOSUPPORT\tab Addresses in the specified family cannot be used with this socket.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAECONNREFUSED\tab The attempt to connect was forcefully rejected.
\par 
\par WSAEDESTADDREQ\tab A destination address is required.
\par 
\par WSAEFAULT\tab The {\i namelen} argument is incorrect.
\par 
\par WSAEINVAL\tab The socket is not already bound to an address.
\par 
\par WSAEISCONN\tab The socket is already connected.
\par 
\par WSAEMFILE\tab No more file descriptors are available.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETUNREACH\tab The network can't be reached from this host at this time.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENOBUFS\tab No buffer space is available.  The socket cannot be connected.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAENOTSOCK\tab The descriptor is not a socket.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAETIMEDOUT\tab Attempt to connect timed out without establishing a connection
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEWOULDBLOCK{\revised  }\tab The socket is marked as non-blocking and the connection cannot be completed immediately.  It is possible to {\b select()} the socket while it is connecting by {\b select()}
ing it for writing.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b accept()}, {\b bind()}, {\b getsockname()}, {\b socket()}{\revised , }{\b\revised select() and WSAAsyncSelect().}{\deleted .
\par }\pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 getpeername {\field{\*\fldinst PAGE}{\fldrslt 29}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart getpeername}4.1.5{\*\bkmkend getpeername} getpeername()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Get the address of the peer to which a socket is connected.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h}{\b >}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int }{\b\revised PASCAL FAR }{\b getpeername ( SOCKET} {\i s}{\b , struct sockaddr FAR * }{\i name}{\b , int FAR *} {\i namelen }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880\tx3960 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i s}\tab A descriptor identifying a connected socket.
\par 
\par {\i name}\tab The structure which is to receive the name of the peer.
\par 
\par {\i namelen}\tab A pointer to the size of the {\i name} structure.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab {\b getpeername()} retrieves the name of the peer connected to the socket {\i s} and stores it in the struct sockaddr identified by {\i name}
.  It is used on a connected datagram or stream socket.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 On return, the {\i namelen} argument contains the actual size of the name returned in bytes.
\par \pard\plain \fs20\lang1033 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b getpeername()} returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling {\b WSAGetLastError().}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAEFAULT\tab The namelen argument is not large enough.
\par 
\par WSAEINPROGRESS\tab A blocking Windows Sockets call is in progress.
\par 
\par WSAENOTCONN\tab The socket is not connected.
\par 
\par WSAENOTSOCK\tab The descriptor is not a socket.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b bind()}, {\b socket()}, {\b getsockname()}.
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 getsockname {\field{\*\fldinst PAGE}{\fldrslt 25}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart getsockname}4.1.6{\*\bkmkend getsockname} getsockname()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Get the local name for a socket.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int }{\b\revised PASCAL FAR }{\b getsockname ( SOCKET} s{\b , struct sockaddr FAR * }{\i name}{\b , }{\b\revised 
\par }{\b\revised \tab }{\b int FAR *} {\i namelen }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i s}\tab A descriptor identifying a bound socket.
\par 
\par {\i name}\tab {\revised Receives the address (name)} of the socket.
\par 
\par {\i namelen}\tab {\b  }The size of the {\i name} {\revised buffer}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab {\b getsock}{\b name()} retrieves the current name for the specified socket descriptor in {\i name}.  It is used on a bound and/or connected socket specified by the {\i s}
 parameter.  The local association is returned.  This call is especially useful when a {\b connect()} call has been made without doing a {\b bind()}
 first; this call provides the only means by which you can determine the local association which has been set by the system.
\par \pard \s5\fi-1440\li1440 
\par \tab On return, the {\i namelen} argument contains the actual size of the name returned in bytes.
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 If {\revised a socke}{\revised t was bound to INADDR_ANY, indicating that any of the host's IP addresses should be used for the socket, }{\b\revised getsockname()}{\revised 
 will not necessarily return information about the host IP address, unless the socket has been connected with }{\b\revised connect()}{\b  }or{\b  accept()}{\b\revised .}{\revised 
  A Windows Sockets application must not assume that the IP address will be changed from INADDR_ANY unless the socket is connected.}  {\revised 
This is because for a multi-homed host the IP address that will be used for the socket is unknown unless the socket is connected.}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b getsockname()} returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling {\b WSAGetLastError().}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAEFAULT\tab The {\i namelen} argument is not large enough.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 WSAENOTSOCK\tab The descriptor is not a socket.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\revised WSAEINVAL\tab The socket has not been bound to an address with }{\b\revised bind().}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b bind()}, {\b socket()}{\b\revised , getpeername()}.
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 getsockopt {\field{\*\fldinst PAGE}{\fldrslt 31}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart getsockopt}4.1.7{\*\bkmkend getsockopt} getsockopt()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Retrieve a socket option.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int }{\b\revised PASCAL FAR }{\b getsockopt ( SOCKET} {\i s}{\b , int} {\i level}{\b , int} {\i optname}{\b , }{\b\revised 
\par }{\b\revised \tab }{\b char FAR * }{\i optval}{\b , int} FAR{\b  * }{\i optlen }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i s}\tab A descriptor identifying a socket.
\par 
\par \pard \s10\fi-1440\li2880 {\i level}\tab The level at which the option is defined; the only supported {\i level}{\i\revised s} {\revised are }SOL_SOCKET{\revised  and IPPROTO_TCP}.
\par \pard \s10\fi-1440\li2880 
\par {\i optname}\tab The socket option for which the value is to be retrieved.
\par 
\par \pard \s10\fi-1440\li2880 {\i optval}\tab A pointer to the buffer in which the value for the requested option is to be returned.
\par \pard \s10\fi-1440\li2880 
\par {\i optlen}\tab A pointer to the size of the {\i optval} buffer.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab {\b getsockopt()} retrieves the current value for a socket option associated with a socket of any type, in any state, and stores the result in {\i optval}
.  Options may exist at multiple protocol levels, but they are always present at the uppermost "socket'' level.  Options affect socket operations, such as whether an operation blocks or not, the routing of packets, out-of-band data transfer, etc.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 The value associated  with the selected option is returned in the buffer {\i optval}.  The integer pointed to by  {\i optlen}
 should originally contain the size of this buffer; on return, it will be set to the size of the value returned.  For SO_LINGER, this will be the size of  a struct linger; for all other options it will be the size of an integer.
\par \pard \s12\li1440 
\par \pard \s12\li1440 If the option was never set with {\b setsockopt(),} then {\b getsockopt(}{\b )} returns the default value for the option.
\par \pard \s12\li1440 
\par \pard \s12\li1440 The following options are supported for {\b getsockopt()}.  The {\ul Type} identifies the type of data addressed by {\i optval}.  {\revised The TCP_NODELAY option uses }{\i\revised level}{\revised  IPPROTO_TCP; all other options use }{
\i\revised level}{\revised  SOL_SOCKET.}
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 
\par \trowd \trgaph108\trleft-108 \cellx3987\cellx5217\cellx9507\pard \s10\li2160\intbl {\ul Value}\cell \pard \s10\intbl {\ul Type}\cell \pard \s10\intbl {\ul Meaning}\cell \pard\plain \intbl \fs20\lang1033 \row \trowd \trgaph108\trleft-108 \cellx3987
\cellx5217\cellx9507\pard\plain \s10\li2160\intbl \fs20\lang1033 SO_ACCEPTCON{\revised N}\cell \pard \s10\intbl BOOL\cell \pard \s10\intbl Socket is {\b listen()}ing.\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl 
\fs20\lang1033 SO_BROADCAST\cell \pard \s10\intbl BOOL\cell \pard \s10\intbl Socket is configured for the transmission of broadcast messages.\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 SO_DEBUG\cell \pard 
\s10\intbl BOOL\cell \pard \s10\intbl Debugging is enabled.  \cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 SO_DONTLINGER\cell \pard \s10\intbl BOOL\cell \pard \s10\intbl If true, the SO_LINGER option is disab
led.\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 SO_DONTROUTE\cell \pard \s10\intbl BOOL\cell \pard \s10\intbl Routing is disabled.\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl 
\fs20\lang1033 SO_ERROR\cell \pard \s10\intbl int\cell \pard \s10\intbl Retrieve error status and clear.\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 SO_KEEPALIVE\cell \pard \s10\intbl BOOL\cell \pard 
\s10\intbl Keepalives are being sent.\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 SO_LINGER\cell \pard \s10\intbl struct linger FAR *\cell \pard \s10\intbl Returns the current linger options.\cell \pard\plain 
\intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 SO_OOBINLINE\cell \pard \s10\intbl BOOL\cell \pard \s10\intbl Out-of-band data is being received in the normal data stream.  \cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain 
\s10\li2160\intbl \fs20\lang1033 SO_RCVBUF\cell \pard \s10\intbl int\cell \pard \s10\intbl Buffer size for receives\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 SO_REUSEADDR\cell \pard \s10\intbl BOOL\cell 
\pard \s10\intbl The socket may be bound to an address which is already in use.\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 SO_SNDBUF\cell \pard \s10\intbl int\cell \pard \s10\intbl Buffer size for sends\cell 
\pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 SO_TYPE\cell \pard \s10\intbl int\cell \pard \s10\intbl The type of the socket (e.g. SOCK_STREAM).\cell \pard\plain \intbl \fs20\lang1033 \row \trowd 
\trgaph108\trleft-108 \cellx3987\cellx5217\cellx9507\pard\plain \s10\li2160\intbl \fs20\lang1033 {\revised TCP_NODELAY}\cell \pard \s10\intbl BOOL\cell \pard \s10\intbl Disables the Nagle algorithm for send coalescing.\cell \pard\plain \intbl 
\fs20\lang1033 \row \pard \li2160 
\par BSD options not supported for {\b getsockopt()} are:
\par 
\par \trowd \trgaph108\trleft-108 \cellx3987\cellx5292\cellx9582\pard\plain \s10\li2160\intbl \fs20\lang1033 {\ul Value}\cell \pard \s10\intbl {\ul Type}\cell \pard \s10\intbl {\ul Meaning}\cell \pard\plain \intbl \fs20\lang1033 \row \trowd 
\trgaph108\trleft-108 \cellx3987\cellx5292\cellx9582\pard\plain \s10\li2160\intbl \fs20\lang1033 SO_RCVLOWAT\cell \pard \s10\intbl int\cell \pard \s10\intbl Receive low water mark\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl 
\fs20\lang1033 SO_RCVTIMEO\cell \pard \s10\intbl int\cell \pard \s10\intbl Receive timeout\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 SO_SNDLOWAT\cell \pard \s10\intbl int\cell \pard \s10\intbl 
Send low water mark\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 SO_SNDTIMEO\cell \pard \s10\intbl int\cell \pard \s10\intbl Send timeout\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain 
\s10\li2160\intbl \fs20\lang1033 IP_OPTIONS\cell \pard \s10\intbl \cell \pard \s10\intbl Get options in IP header.\cell \pard\plain \intbl \fs20\lang1033 \row \trowd \trgaph108\trleft-108 \cellx3987\cellx5292\cellx9582\pard\plain \s10\li2160\intbl 
\fs20\lang1033 TCP_MAXSEG\cell \pard \s10\intbl int\cell \pard \s10\intbl Get TCP maximum segment size.\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 Calling {\b getsockopt()} with an unsupported option will result in an error code of WSAENOPROTOOPT being returned from {\b WSAGetLastError()}.
\par \pard \s12\li1440 
\par \pard\plain \fs20\lang1033 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b getsockopt()} returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling {\b WSAGetLastError()}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAEFAULT\tab The {\i optlen} argument was invalid.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENOPROTOOPT\tab The option is unknown or unsupported.  In particular, SO_BROADCAST is not supported on sockets of type SOCK_STREAM, while SO_ACCEPTCON{\revised N}
, SO_DONTLINGER, SO_KEEPALIVE, SO_LINGER and SO_OOBINLINE are not supported on sockets of type SOCK_DGRAM.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAENOTSOCK\tab The descriptor is not a socket.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b setsockopt()}, {\b WSAAsyncSelect()}, {\b socket()}.
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 htonl {\field{\*\fldinst PAGE}{\fldrslt 33}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart htonl}4.1.8{\*\bkmkend htonl} htonl()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Convert a {\b u_long} from host to network byte order.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b u}{\b _long }{\b\revised PASCAL FAR }{\b htonl ( u_long} {\i hostlong }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i hostlong}\tab A 32-bit number in host byte order.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This routine takes a 32-bit number in host byte order and returns a 32-bit number in network byte order.
\par \pard\plain \fs20\lang1033 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab {\b htonl()} returns the value in network byte order.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b htons()}, {\b ntohl()}, {\b ntohs()}.
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 htons {\field{\*\fldinst PAGE}{\fldrslt 29}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart htons}4.1.9{\*\bkmkend htons} htons()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Convert a {\b u_short} from host to network byte order.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b u_short }{\b\revised PASCAL FAR }{\b htons ( u_short} {\i hostshort }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i hostshort}\tab A 16-bit number in host byte order.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This routine takes a 16-bit number in host byte order and returns a 16-bit number in network byte order.
\par \pard\plain \fs20\lang1033 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab {\b htons()} returns the value in network byte order.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b htonl()}, {\b ntohl()}, {\b ntohs()}.
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 inet_addr {\field{\*\fldinst PAGE}{\fldrslt 35}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart inet_addr}4.1.10{\*\bkmkend inet_addr} inet_addr()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Convert a string containing a dotted address into an {\b in_addr}.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b \tab unsigned long }{\b\revised PASCAL FAR }{\b inet_addr ( }{\b\revised const }{\b char FAR * }{\i cp }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i cp}\tab A character string representing a number expressed in the Internet standard ".'' notation.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This function interprets the character string specified by the {\i cp}
 parameter.  This string represents a numeric Internet address expressed in the Internet standard ".'' notation.  The value returned is a number suitable for use as an Internet address.  All Internet addresses are returned in network order (bytes ordered 
from left to right).
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 {\ul Internet Addresses
\par }
\par Values specified using the ".'' notation take one of the following forms:
\par 
\par a.b.c.d\tab a.b.c\tab a.b\tab a
\par 
\par \pard \s12\li1440 When four parts are specif
ied, each is interpreted as a byte of data and assigned, from left to right, to the four bytes of an Internet address.  Note that when an Internet address is viewed as a 32-bit integer quantity on the Intel architecture, the bytes referred to above appear
 as "d.c.b.a''.  That is, the bytes on an Intel processor are ordered from right to left.
\par \pard \s12\li1440 
\par \pard \s12\li1440 Note: The following notations are only used by Berkeley, and nowhere else on the Internet.  In the interests of compatibility with their software, they are supported as specified.
\par \pard \s12\li1440 
\par \pard \s12\li1440 
When a three part address is specified, the last part is interpreted as a 16-bit quantity and placed in the right most two bytes of the network address.  This makes the three part address format convenient for specifying Class B network addresses as "128.
net.host''.
\par \pard \s12\li1440 
\par \pard \s12\li1440 When a two part address is specified, the last part is interpreted as a 24-bit quantity and placed in the right most three bytes of the network address.  This makes the two part address format convenient for specifying Clas
s A network addresses as "net.host''.
\par \pard \s12\li1440 
\par \pard \s12\li1440 When only one part is given, the value is stored directly in the network address without any byte rearrangement.
\par \pard\plain \fs20\lang1033 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b inet_addr()} returns an unsig{\revised ned long} containing a suitable binary representation of the Internet address given.  {\revised 
If the passed-in string does not contain a legitimate Internet address, for example if a portion of an "a.b.c.d" address exceeds 255, }{\b\revised inet_addr() }{\revised retur}ns the value INADDR_NONE{\revised .}
\par \pard \s7\fi-1440\li1440 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b inet_ntoa()}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 inet_ntoa {\field{\*\fldinst PAGE}{\fldrslt 31}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart inet_ntoa}4.1.11{\*\bkmkend inet_ntoa} inet_ntoa()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Convert a network address into a string in dotted format.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b char FAR * }{\b\revised PASCAL FAR }{\b inet_ntoa ( struct in_addr} {\i in }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i in}\tab A structure which represents an Internet host address.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This function takes an Internet address structure specified by the {\i in}
 parameter.  It returns an ASCII string representing the address in ".''  notation as "a.b.c.d''.  Note that the string returned by {\b inet_ntoa()} resides in memory which is allocated by the Windows S
ockets implementation.  The application should not make any assumptions about the way in which the memory is allocated.  The data is guaranteed to be valid until the next Windows Sockets API call within the same thread, but no longer.
\par \pard\plain \fs20\lang1033 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b inet_ntoa()}
 returns a char pointer to a static buffer containing the text address in standard ".'' notation.  Otherwise, it returns NULL.  The data should be copied before another Windows Sockets call is made.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b inet_addr()}.
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 ioctlsocket {\field{\*\fldinst PAGE}{\fldrslt 37}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart ioctlsocket}4.1.12{\*\bkmkend ioctlsocket} ioctlsocket{\*\bkmkstart fcntl}{\*\bkmkend fcntl}()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Control the mode of a socket.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int }{\b\revised PASCAL FAR }{\b ioctlsocket ( SOCKET} {\i s}{\b , long} {\i cmd}{\b , u_long FAR *} {\i argp }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i s}\tab A descriptor identifying a socket.
\par 
\par {\i cmd}\tab The command to perform on the socket {\i s}.
\par 
\par {\i argp}\tab A pointer to a parameter for {\i cmd}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab 
This routine may be used on any socket in any state.  It is used to get or retrieve operating parameters associated with the socket, independent of the protocol and communications subsystem.  The following commands are supported:
\par \pard \s5\fi-1440\li1440 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 Command\tab Semantics
\par 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 FIONBIO\tab Enable or disable non-blocking mode on the socket {\i s}.  {\i argp} points at an {\b unsigned long}
, which is non-zero if non-blocking mode is to be enabled and zero if it is to be disabled.  When a socket is created, it operates in blocking mode (i.e. non-blocking mode is disabled).  This is consistent with BSD sockets.
\par \pard \s10\fi-1440\li2880 
\par \pard \s10\fi-1440\li2880 \tab The {\b WSAAsyncSelect() }routine automatically sets a {\revised socket to nonblocking mode.  If }{\b\revised WSAAsyncSelect() }{\revised has been issued on a socket, then any attempt}{\revised  to use }{\b\revised 
ioctlsocket() }{\revised to set the socket back to blocking mode will fail with WSAEINVAL.  To set the socket back to blocking mode, an application must first disable }{\b\revised WSAAsyncSelect() }{\revised by calling }{\b\revised WSAAsyncSelect() }{
\revised with the }{\i\revised lEvent}{\revised  parameter equal to 0.}
\par \pard \s10\fi-1440\li2880 
\par \pard \s10\fi-1440\li2880 FIONREAD\tab Determine the amount of data which can be read atomically from socket {\i s}.  {\i argp} points at an {\b unsigned long} in which {\b ioctlsocket()} stores the result.  If {\i s}
 is of type SOCK_STREAM, FIONREAD returns the total amount of data which may be read in a single {\b rec}{\b v()}; this is normally the same as the total amount of data queued on the socket.  If {\i s}
 is of type SOCK_DGRAM, FIONREAD returns the size of the first datagram queued on the socket.
\par \pard \s10\fi-1440\li2880 
\par \pard \s10\fi-1440\li2880 SIOCATMARK\tab 
Determine whether or not all out-of-band data has been read.  This applies only to a socket of type SOCK_STREAM which has been configured for in-line reception of any out-of-band data (SO_OOBINLINE).  If no out-of-band data is waiting to be rea
d,  the operation returns TRUE.  Otherwise it returns FALSE, and the next {\b recv()} or {\b recvfrom()}
 performed on the socket will retrieve some or all of the data preceding the "mark"; the application should use the SIOCATMARK operation to determine whether any remains.  If there is any normal data preceding the "urgent" (out of band) data, it will be r
eceived in order.  (Note that a {\b recv()} or {\b recvfrom()} will never mix out-of-band and normal data in the same call.)  {\i argp} points at a {\b BOOL} in which {\b ioctlsocket()} stores the result.
\par \pard\plain \fs20\lang1033 
\par \pard \fi-1440\li1440 {\b\f2 Compatibility}\tab This function is a subset of {\b ioctl()} as 
used in Berkeley sockets.  In particular, there is no command which is equivalent to FIOASYNC, while SIOCATMARK is the only socket-level command which is supported.
\par \pard 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab Upon successful completion, the {\b ioctlsocket()} returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling {\b 
WSAGetLastError().}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINVAL\tab {\i cmd} is not a valid command, or {\i arg}{\i\revised p} is not an acceptable parameter for {\i cmd}, or the command is not applicable to the type of socket supplied
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 WSAENOTSOCK\tab The descriptor {\i s} is not a socket.
\par 
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b socket()}, {\b setsockopt()}, {\b getsockopt()}, {\b WSAAsyncSelect()}{\b\revised .}{\b 
\par }\pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 listen {\field{\*\fldinst PAGE}{\fldrslt 39}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart listen}4.1.13{\*\bkmkend listen} listen()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Establish a socket to listen for incoming connection.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int }{\b\revised PASC}{\b\revised AL FAR }{\b listen ( SOCKET} {\i s}{\b , int} {\i backlog }{\b );}
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i 
\par }{\i s}\tab A descriptor identifying a bound, unconnected socket.
\par 
\par \pard \s10\fi-1440\li2880 {\i backlog}\tab The maximum length to which the queue of pending connections may grow.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab To accept connections, a socket is first created with {\b socket}(), a backlog for incoming connections is specified with {\b listen}(), and then the connections are accepted with {\b 
accept}().  {\b listen}() applies only to sockets that support connections, i.e. those of type SOCK_STREAM.  The socket {\i s} is put into "passive'' mode where incoming connections are acknowledged and queued pending acceptance by the process.
\par \pard \s5\fi-1440\li1440 
\par \pard\plain \s12\li1440 \fs20\lang1033 
This function is typically used by servers that could have more than one connection request at a time: if a connection request arrives with the queue full, the client will receive an error with an indication of WSAECONNREFUSED.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 {\b listen}() attempts to continue to function rationally when there are no available descriptors.  It will accept connections until the queue is emptied.  If descriptors become available, a later call to {\b listen}
() or {\b accept}() will re-fill the queue to the current or most recent "backlog'', if possible, and resume listening for incoming connections.
\par \pard \s12\li1440 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 {\b\f2 Compatibility}\tab {\i backlog} is currently limited (silently) to 5.  As in 4.3BSD, illegal values (less than 1 or greater than 5) are replaced by the nearest legal value.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b listen()} returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling {\b WSAGetLastError()}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEADDRINUSE\tab An attempt has been made to {\b listen()} on an address in use.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 WSAEINVAL\tab The socket has not been bound with {\b bind()}{\b\revised  }{\revised or is already connected}.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAEISCONN\tab The socket is already connected.
\par 
\par WSAEMFILE\tab No more file descriptors are available.
\par 
\par WSAENOBUFS\tab No buffer space is available.
\par 
\par WSAENOTSOCK\tab The descriptor is not a socket.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEOPNOTSUPP\tab The referenced socket is not of a type that supports the {\b listen()} operation.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b accept()},  {\b connect()}, {\b socket()}.
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 ntohl {\field{\*\fldinst PAGE}{\fldrslt 41}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart ntohl}4.1.14{\*\bkmkend ntohl} ntohl()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Convert a {\b u_long} from network to host byte order.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b u_long }{\b\revised PASCAL FAR }{\b ntohl ( u_long} {\i netlong }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i netlong}\tab A 32-bit number in network byte order.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This routine takes a 32-bit number in network byte order and returns a 32-bit number in host byte order.
\par \pard\plain \fs20\lang1033 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab {\b ntohl()} returns the value in host byte order.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b htonl()}, {\b htons()}, {\b ntohs()}.
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 ntohs {\field{\*\fldinst PAGE}{\fldrslt 37}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart ntohs}4.1.15{\*\bkmkend ntohs} ntohs()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Convert a {\b u_short} from network to host byte order.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b u_short }{\b\revised PASCAL FAR }{\b ntohs ( u_short} {\i netshort }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i netshort}\tab A 16-bit number in network byte order.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This routine takes a 16-bit number in network byte order and returns a 16-bit number in host byte order.
\par \pard\plain \fs20\lang1033 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab {\b ntohs()} returns the value in host byte order.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b htonl()}, {\b htons()}, {\b ntohl()}.
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 recv {\field{\*\fldinst PAGE}{\fldrslt 43}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart recv}4.1.16{\*\bkmkend recv} recv()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Receive data from a socket.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int }{\b\revised PASCAL FAR }{\b recv ( SOCKET} {\i s}{\b , char FAR *} {\i buf}{\b , int} {\i len}{\b , int} {\i flags }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i s}\tab A descriptor identifying a connected socket.
\par 
\par {\i buf}\tab A buffer for the incoming data.
\par 
\par {\i len}\tab The length of {\i buf}.
\par 
\par {\i flags}\tab Specifies the way in which the call is made.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This function is used on connected datagram or stream sockets specified by the {\i s} parameter and is used to read incoming data.
\par \pard \s5\fi-1440\li1440 
\par \pard\plain \s12\li1440 \fs20\lang1033 
For sockets of type SOCK_STREAM, as much information as is currently available up to the size of the buffer supplied is returned.  If the socket has been configured for in-line reception of out-of-band data (socket option SO_OOBINLINE) and out-of-band dat
a is unread, only out-of-band data will be returned.  The application may use the {\b ioctlsocket()} SIOCATMARK to determine whether any more out-of-band data remains to be read.
\par \pard \s12\li1440 
\par \pard \s12\li1440 For datagram sockets, data is extracted from the first enqueued datagram, up to the size of the buffer supplied.  If the datagram is larger than the buffer supplied, {\revised the buffer is filled with the first part of the datagram, }
the excess data is lost{\revised , and }{\b\revised recv() }{\revised returns the error WSAEMSGSIZE}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 If no incoming data is available at the socket, the {\b recv()}
 call waits for data to arrive unless the socket is non-blocking.  In this case a value of SOCKET_ERROR is returned with the error code set to WSAEWOULDBLOCK.  The {\b select}() or {\b WSAAsyncSelect}() calls may be used to determine wh
en more data arrives.
\par \pard \s12\li1440 
\par \pard \s12\li1440 {\revised If the socket is of type SOCK_STREAM and the remote side has shut down the connection gracefully, a }{\b\revised recv()}{\revised  will complete immediately with 0 bytes received.  If the connection has been reset, a }{
\b\revised recv() }{\revised will fail with the error WSAECONNRESET.}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 {\i Flags}
 may be used to influence the behavior of the function invocation beyond the options specified for the associated socket.  That is, the semantics of this function are determined by the socket options and the {\i flags} parameter.  The latter is
 constructed by or-ing any of the following values:
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\ul Value\tab Meaning
\par }\pard \s10\fi-1440\li2880 MSG_PEEK\tab Peek at the incoming data.  The data is copied into the buffer but is not removed from the input queue.
\par \pard \s10\fi-1440\li2880 
\par \pard \s10\fi-1440\li2880 MSG_OOB\tab Process out-of-band data (See section {\field{\*\fldinst ref oob}{\fldrslt 2.2.3}} for a discussion of this topic.)
\par \pard\plain \fs20\lang1033 
\par 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b recv()}
 returns the number of bytes received.  If the connection has been closed, it returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling {\b WSAGetLastError()}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAENOTCONN\tab The socket is not connected.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINTR\tab The (blocking) call was canceled via {\b WSACancelBlockingCall().}
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 WSAENOTSOCK\tab The descriptor is not a socket.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEOPNOTSUPP\tab MSG_OOB was specified, but the socket is not of type SOCK_STREAM.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAESHUTDOWN\tab The socket has been shutdown; it is not possible to {\b recv()} on a socket after {\b shutdown()} has been invoked with {\i how} set to 0 or 2.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEWOULDBLOCK\tab The socket is marked as non-blocking and the receive operation would block.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\revised WSAEMSGSIZE\tab The datagram was too large to fit into the specified buffer and was truncated.
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\revised 
\par }{\revised WSAEINVAL\tab The socket has not been bound with }{\b\revised bind().
\par }{\b\revised 
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\revised WSAECONNABORTED\tab The virtual circuit was aborted due to timeout or other failure.
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\revised 
\par }{\revised WSAECONN}{\revised RESET\tab The virtual circuit was rese}t {\revised by the remote side.}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b recvfrom()}, {\b\deleted read()}{\deleted , }{\revised ,}{\b\revised recv(), }{\b send()}, {\b select()}, {\b WSAAsyncSelect()}, {\b socket()}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 recvfrom {\field{\*\fldinst PAGE}{\fldrslt 47}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart recvfrom}4.1.17{\*\bkmkend recvfrom} recvfrom()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Receive a datagram and store the source address.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int }{\b\revised PASCAL FAR }{\b recvfrom ( SOCKET} {\i s}{\b , char FAR * }{\i buf}{\b , int} {\i len}{\b , int} {\i flags}{\b , }{\b\revised 
\par }{\b\revised \tab }{\b struct sockaddr FAR *} {\i from}{\b , int FAR *} {\i fromlen }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i s}\tab A descriptor identifying a bound socket.
\par 
\par {\i buf}\tab A buffer for the incoming data.
\par 
\par {\i len}\tab The length of {\i buf}.
\par 
\par {\i flags}\tab Specifies the way in which the call is made.
\par 
\par \pard \s10\fi-1440\li2880 {\i from}\tab {\revised An optional pointer} to a buffer which will hold the source address upon return.
\par \pard \s10\fi-1440\li2880 
\par {\i fromlen}\tab A{\revised n optional} pointer to the size of the {\i from} buffer.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This function is used to read incoming data on a (possibly connected) socket and capture the address from which the data was sent.
\par \pard \s5\fi-1440\li1440 
\par \pard\plain \s12\li1440 \fs20\lang1033 For sockets of type SOCK_STREAM, as much information as is currently available up to the size of the buffer supplied is returned.  If the socket has been configured for in-line recep
tion of out-of-band data (socket option SO_OOBINLINE) and out-of-band data is unread, only out-of-band data will be returned.  The application may use the {\b ioctlsocket()}
 SIOCATMARK to determine whether any more out-of-band data remains to be read.  The {\i from }and {\i fromlen }parameters are ignored for SOCK_STREAM socke{\revised ts.}
\par \pard \s12\li1440 
\par \pard \s12\li1440 For datagram sockets, data is extracted from the first enqueued datagram, up to the size of the buffer supplied.  If the datagram is larger than the buffer supplied, {\revised the buffer is filled with }{\revised 
the first part of the message, }the excess data is lost{\revised , and }{\b\revised recvfrom() }{\revised returns the error code WSAEMSGSIZE}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 If {\i from} is non-zero, and the socket is of type SOCK_DGRAM, the network address of the peer which sent the data is copied to the corresponding struct sockaddr.  The value pointed to by {\i fromlen}
 is initialized to the size of this structure, and is modified on return to indicate the actual size of the address stored there.
\par \pard \s12\li1440 
\par \pard \s12\li1440 If no incoming data is available at the socket, the {\b recvfrom()} call waits for data to arrive unless the socket is non-blocking.  In this case a value of SOCKET_ERROR is returned with the error code set to WSAEWOULDBLOCK.  The {\b 
select}() or {\b WSAAsyncSelect}() calls may be used to determine when more data arrives.
\par \pard \s12\li1440 
\par \pard \s12\li1440 {\revised If the socket is of type SOCK_STREAM and the remote side has shut down the connection gracefully, a }{\b\revised recv}{\b from}{\b\revised ()}{\revised 
 will complete immediately with 0 bytes received.  If the connection has been }reset {\b recv() }{\revised will fail with the error WSAECONNRESET.
\par }\pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 {\i Flags} may be used to influence th
e behavior of the function invocation beyond the options specified for the associated socket.  That is, the semantics of this function are determined by the socket options and the {\i flags}
 parameter.  The latter is constructed by or-ing any of the following values:
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s10\fi-1440\li2880\keepn \fs20\lang1033 {\ul Value\tab Meaning
\par }\pard \s10\fi-1440\li2880 MSG_PEEK\tab Peek at the incoming data.  The data is copied into the buffer but is not removed from the input queue.
\par \pard \s10\fi-1440\li2880 
\par \pard \s10\fi-1440\li2880 MSG_OOB\tab Process out-of-band data (See section {\field{\*\fldinst ref oob}{\fldrslt 2.2.3}} for a discussion of this topic.)
\par \pard\plain \fs20\lang1033 
\par 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b recvfrom()}
 returns the number of bytes received.  If the connection has been closed, it returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling {\b WSAGetLastError()}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEFAULT\tab The {\i fromlen} argument was invalid: the {\i from} buffer was too small to accommodate the peer address.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINTR\tab The (blocking) call was canceled via {\b WSACancelBlockingCall().}
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 WSAEINVAL\tab The socket has not been bound with {\b bind()}.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENOTCONN\tab The socket is not connected (SOCK_STREAM only).
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAENOTSOCK\tab The descriptor is not a socket.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEOPNOTSUPP\tab MSG_OOB was specified, but the socket is not of type SOCK_STREAM.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAESHUTDOWN\tab The socket has been shutdown; it is not possible to {\b recvfrom()} on a socket after {\b shutdown()} has been invoked with {\i how} set to 0 or 2.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEWOULDBLOCK\tab The socket is marked as non-blocking and the {\b recvfrom()} operation would block.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\revised WSAEMSGSIZE\tab The datagram was too large to fit into the specified buffer and was truncated.
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\b\revised 
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\revised WSAECONNABORTED\tab The virtual circuit was aborted due to timeout or other failure.
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\revised 
\par }{\revised WSAECONNRESET\tab The virtual circuit was reset by the remote side.
\par }
\par 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b recv()}, {\b send()}, {\b socket()}, {\b WSAAsyncSelect()}.
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 select {\field{\*\fldinst PAGE}{\fldrslt 49}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart select}4.1.18{\*\bkmkend select} select()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Determine the status of one or more sockets, waiting if necessary.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int }{\b\revised PASCAL FAR }{\b select ( int} {\i nfds}{\b , fd_set FAR * }{\i readfds}{\b , fd_set FAR * }{\i writefds}{\b , \line fd_set FAR * }{\i exceptfds}{\b , }{\b\revised const }{\b 
struct timeval FAR * }{\i timeout }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i nfds}\tab This argument is ignored and included only for the sake of compatibility.
\par \pard \s10\fi-1440\li2880 
\par {\i readfds}\tab A{\revised n optional pointer to a} set of sockets to be checked for readability.
\par 
\par {\i writefds}\tab A{\revised n optional pointer to a} set of sockets to be checked for writ{\revised a}bility
\par 
\par {\i exceptfds}\tab A{\revised n optional pointer to a} set of sockets to be checked for errors.
\par 
\par \pard \s10\fi-1440\li2880 {\i timeout}\tab The maximum time for {\b select()} to wait, or NULL for blocking operation.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab 
This function is used to determine the status of one or more sockets.  For each socket, the caller may request information on read, write or error status.  The set of sockets for which a given status is requested is indicated by an fd_set structure.  Upo
n return, the structure is updated to reflect the subset of these sockets which meet the specified condition, and {\b select()} ret
urns the number of sockets meeting the conditions.  A set of macros is provided for manipulating an fd_set.  These macros are compatible with those used in the Berkeley software, but the underlying representation is completely different.  
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 The parameter {\i readfds} identifies those sockets which are to be checked for readability.  If the socket is currently {\b listen()}ing, it will be marked as readable if an incoming connection request has been received, so that an {\b 
accept()} is guaranteed to complete without blocking.  For other sockets, readability means that queued data is available for reading{\revised  or, for sockets of type SOCK_STREAM, that the virtual socket corresponding to the socket has been closed}
, so that a {\b recv()} or {\b recvfrom()} is guaranteed to complete without blocking.  {\revised If the virtual circuit was closed gracefully, then a }{\b\revised recv() }{\revised 
will return immediately with 0 bytes read; if the virtual circuit was reset, then a }{\b\revised recv() }{\revised will complete immediately with the error code WSAECONNRESET. }The presence of out-of-band dat
a will be checked if the socket option SO_OOBINLINE has been enabled (see {\b setsockopt()}).
\par \pard \s12\li1440 
\par \pard \s12\li1440 The parameter {\i writefds} identifies those sockets which are to be checked for writ{\revised a}bility.  {\revised  }If a socket is {\b connect()}ing (non-blocking), writ{\revised a}bility means that the connection establishment {
\revised successfully} complete{\revised d}.  If the {\revised socket is not in the process of }{\b\revised connect()}{\revised ing}, writ{\revised a}bility means that a {\b send()} or {\b sendto()}
 will complete without blocking.  [It is not specified how long this guarantee can be assumed to be valid, particularly in a multithreaded environment.]
\par \pard \s12\li1440 
\par \pard \s12\li1440 The parameter {\i exceptfds}
 identifies those sockets which are to be checked for the presence of out-of-band data or any exceptional error conditions.  Note that out-of-band data will only be reported in this way if the option SO_OOBINLINE is FALSE.  For a SOCK_STREAM, the breaking
 of the connection by the peer or due to KEEPALIVE failure will be indicated as an exception.  This specification does not define which other errors will be included.{\revised   If a socket is }{\b\revised connect}{\b\revised ()}{\revised 
ing (non-blocking), failure of the connect attempt is indicated in }{\i\revised exceptfds.}
\par \pard \s12\li1440 
\par \pard \s12\li1440 Any of {\i readfds}, {\i writefds}, or {\i exceptfds} may be given as NULL if no descriptors are of interest.
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 Four macros are defined in the header file {\b winsock.h}
 for manipulating the descriptor sets.  The variable FD_SETSIZE determines the maximum number of descriptors in a set.  (The default value of FD_SETSIZE is 64, which may be modified by #defining FD_SETSIZE to another value before #including {\b winsock.h}
.)  Internally, an fd_set is represented as an array of SOCKETs; the last valid entry is followed by an element set to INVALID_SOCKET.  The macros are:
\par \pard \s12\li1440 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\b FD_CLR(}{\i s}{\b , *}{\i set}{\b )}\tab Removes the descriptor {\i s} from {\i set}.
\par 
\par {\b FD_ISSET(}{\i s}{\b , *}{\i set}{\b )}\tab Nonzero if {\i s} is a member of the {\i set}, zero otherwise.
\par 
\par {\b FD_SET(}{\i s}{\b , *}{\i set}{\b )}\tab \tab Adds descriptor {\i s} to {\i set}.
\par 
\par {\b FD_ZERO(*}{\i set}{\b )}\tab \tab Initializes the {\i set} to the NULL set.
\par 
\par \pard\plain \s12\li1440 \fs20\lang1033 The parameter {\i timeout} controls how long the {\b select()} may take to complete.  If {\i timeout} is a null pointer, {\b select()} will block indefinitely until at least one
 descriptor meets the specified criteria.  Otherwise, {\i timeout} points to a struct timeval which specifies the maximum time that {\b select()} should wait before returning.  If the timeval is initialized to \{0, 0\}, {\b select()}
 will return immediately; this is used to "poll" the state of the selected sockets.{\revised   If this is the case, then the }{\b\revised select() }{\revised 
call is considered nonblocking and the standard assumptions for nonblocking calls apply.  For example, the blocking hook must not be called, and the Windows Sockets impleme}{\revised ntation must not yield.}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab {\b select()} returns the total number of descriptors which are ready and contained in the fd_set structures, 0 if the time limit expired, {\revised 
or SOCKET_ERROR if an error occurred.  If the return value is SOCKET_ERROR, }{\b\revised WSAGetLastError()}{\revised  may be used to retrieve a specific error code.}{\i\deleted 
\par }\pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAEINVAL\tab The {\i timeout} value is not valid.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINTR\tab The (blocking) call was canceled via {\b WSACancelBlockingCall().}
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 WSAENOTSOCK\tab One of the descriptor sets contains an entry which is not a socket.
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 
\par \pard \s9\fi-1440\li1440 {\b\f2 See Also}\tab {\b WSAAsyncSelect()}, {\b accept()}, {\b connect()},{\revised  }{\b recv()}, {\b recvfrom()}, {\b send()}.
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 send {\field{\*\fldinst PAGE}{\fldrslt 51}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart send}4.1.19{\*\bkmkend send} send()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Send data on a connected socket.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int }{\b\revised PASCAL FAR }{\b send ( SOCKET} {\i s}{\b , }{\b\revised const }{\b char FAR * }{\i buf}{\b , int} {\i len}{\b , int} {\i fl}{\i ags }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i s}\tab A descriptor identifying a connected socket.
\par 
\par {\i buf}\tab A buffer containing the data to be transmitted.
\par 
\par {\i len}\tab The length of the data in {\i buf}.
\par 
\par {\i flags}\tab Specifies the way in which the call is made.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab {\b send}
() is used on connected datagram or stream sockets and is used to write outgoing data on a socket.  For datagram sockets, care must be taken not to exceed the maximum IP packet size of the underlying subnets, which is given by the {\i iMaxUdpDg}
 element in the WSAData structure returned by {\b WSASt}{\b artup()}.  If the data is too long to pass atomically through the underlying protocol the error WSAEMSGSIZE is returned, and {\revised no }data is transmitted.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 Note that the successful completion of a {\b send()} does not indicate that the data was successfully delivered.
\par \pard \s12\li1440 
\par \pard \s12\li1440 If no buffer space is available within the transport system to hold the data to be transmitted, {\b send}
() will block unless the socket has been placed in a non-blocking I/O mode.  On non-blocking SOCK_STREAM sockets, the number of bytes written may be b
etween 1 and the requested length, depending on buffer availability on both the local and foreign hosts.  The {\b select}() call may be used to determine when it is possible to send more data.
\par \pard \s12\li1440 
\par \pard \s12\li1440 {\i Flags} may be used to influence the behavior of the function invocation beyond the options specified for the associated socket.  That is, the semantics of this function are determined by the socket options and the {\i flags}
 parameter.  The latter is constructed by or-ing any of the following values:
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\ul Value\tab Meaning
\par }\pard \s10\fi-1440\li2880 MSG_DONTROUTE\line Specifies that the data should not be subject to routing.  A Windows Sockets supplier may choose to ignore this flag; see also the discussion of the SO_DONTROUTE option in section {\field{\*\fldinst 
ref Socket_Options}{\fldrslt 2.4}}.
\par \pard \s10\fi-1440\li2880 
\par MSG_OOB\tab Send out-of-band data (SOCK_STREAM only; see also section {\field{\*\fldinst ref oob}{\fldrslt 2.2.3}})
\par 
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b send()} returns the total number of characters sent.  (Note that this may be less than the number indicated by {\i len}
.) Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling {\b WSAGetLastError()}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEACCES\tab The requested address is a broadcast address, but the appropriate flag was not set.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINTR\tab The (blocking) call was canceled via {\b WSACancelBlockingCall().}
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEFAULT\tab The {\i buf }argument is not in a valid part of the user address space.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETRESET\tab The connection must be reset because the Windows Sockets implementation dropped it.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENOBUFS\tab The Windows Sockets implementation reports a buffer deadlock.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAENOTCONN\tab The socket is not connected.
\par 
\par WSAENOTSOCK\tab The descriptor is not a socket.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEOPNOTSUPP\tab MSG_OOB was specified, but the socket is not of type SOCK_STREAM.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAESHUTDOWN\tab The socket has been shutdown; it is not possible to {\b send()} on a socket after {\b sh}{\b utdown()} has been invoked with how set to 1 or 2.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEWOULDBLOCK\tab The socket is marked as non-blocking and the requested operation would block.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEMSGSIZE\tab The socket is of type SOCK_DGRAM, and the datagram is larger than the maximum supported by the Windows Sockets implementation.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par {\revised WSAEINVAL\tab The socket has not been bound with }{\b\revised bind().
\par }{\b\revised 
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\revised WSAECONNABORTED\tab The virtual circuit was }aborted{\revised  due to timeout or other failure.
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\revised 
\par }{\revised WSAECONNRESET\tab The virtual circuit was }reset by{\revised  the remote side.
\par }
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b rec}{\b v()}, {\b recvfrom()}, {\b socket()}, {\b sendto()}, {\b WSAStartup()}.
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 sendto {\field{\*\fldinst PAGE}{\fldrslt 53}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart sendto}4.1.20{\*\bkmkend sendto} sendto()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Send data to a specific destination.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int }{\b\revised PASCAL FAR }{\b sendto ( SOCKET} {\i s}{\b , }{\b\revised const }{\b char FAR * }{\i buf}{\b , int} {\i len}{\b , int} {\i flags}{\b , }{\b\revised 
\par }{\b\revised \tab const }{\b struct sockaddr FAR * }{\i to}{\b , int} {\i tolen }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i s}\tab A descriptor identifying a socket.
\par 
\par {\i buf}\tab A buffer containing the data to be transmitted.
\par 
\par {\i len}\tab The length of the data in {\i buf}.
\par 
\par {\i flags}\tab Specifies the way in which the call is made.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i to}\tab A{\revised n optional} pointer to the address of the target socket.
\par 
\par {\i tolen}\tab The size of the address in {\i to}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab {\b sendto}
() is used on datagram or stream sockets and is used to write outgoing data on a socket.  For datagram sockets, care must be taken not to exceed the maximum IP packet size of the underlying subnets, which is given by the {\i iMaxUdpDg}
 element in the WSAData structure returned by {\b WSAStartup()}.  If the data is too long to pass atomically through the underlying protocol the error WSAEMSGSIZE is returned, and {\revised no }data is transmitted.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 Note that the successful completion of a {\b sendto()} does not indicate that the data was successfully delivered.
\par \pard \s12\li1440 
\par \pard \s12\li1440 {\b sendto()} is normally used on a SOCK_DGRAM socket to send a datagram to a specific peer socket identified by the {\i to} parameter.  On a {\revised SOCK_STREAM} socket, the {\i to} {\revised and }{\i\revised tolen }
parameters are ignored; in this case the {\b sendto()} is equivalent to {\b send}().
\par \pard \s12\li1440 
\par \pard \s12\li1440 To send a broadcast (on a SOCK_DGRAM only), the address in the {\i to} parameter should be constructed using the special IP address INADDR_BROADCAST (defined in {\b winso}{\b ck.h}
) together with the intended port number.  It is generally inadvisable for a broadcast datagram to exceed the size at which fragmentation may occur, which implies that the data portion of the datagram (excluding headers) should not exceed 512 bytes.

\par \pard \s12\li1440 
\par \pard \s12\li1440 If no buffer space is available within the transport system to hold the data to be transmitted, {\b sendto}
() will block unless the socket has been placed in a non-blocking I/O mode.  On non-blocking SOCK_STREAM sockets, the number of bytes written may be betw
een 1 and the requested length, depending on buffer availability on both the local and foreign hosts.  The {\b select}() call may be used to determine when it is possible to send more data.
\par \pard \s12\li1440 
\par \pard \s12\li1440 {\i Flags} may be used to influence the behavior of the function invocation beyond the options specified for the associated socket.  That is, the semantics of this function are determined by the socket options and the {\i flags}
 parameter.  The latter is constructed by or-ing any of the following values:
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\ul Value\tab Meaning
\par }\pard \s10\fi-1440\li2880 MSG_DONTROUTE\line Specifies that the data should not be subject to routing.  A Windows Sockets supplier may choose to ignore this flag; see also the discussion of the SO_DONTROUTE option in section {\field{\*\fldinst 
ref Socket_Options}{\fldrslt }}.
\par \pard \s10\fi-1440\li2880 
\par MSG_OOB\tab Send out-of-band data (SOCK_STREAM only; see also section {\field{\*\fldinst ref oob}{\fldrslt }})
\par \pard\plain \fs20\lang1033 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b sendto()} returns the total number of characters sent.  (Note that this may be less than the number indicated by {\i len}
.) Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling {\b WSAGetLastError()}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEACCES\tab The requested address is a broadcast address, but the appropriate flag was not set.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINTR\tab The (blocking) call was canceled via {\b WSACancelBlockingCall().}
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 WSAEFAULT\tab The {\i buf }or {\i to }parameters are not part of the user address space, {\revised or the }{\i\revised to }{\revised 
argument is too small (less than the sizeof a struct sockaddr).
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETRESET\tab The connection must be reset because the Windows Sockets implementation dropped it.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENOBUFS\tab The Windows Sockets implementation reports a buffer deadlock.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENOTCONN\tab The socket is not connected (SOCK_STREAM only).
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAENOTSOCK\tab The descriptor is not a socket.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEOPNOTSUPP\tab MSG_OOB was specified, but the socket is not of type SOCK_STREAM.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAESHUTDOWN\tab The socket has been shutdown; it is not possible to {\b sendto()} on a socket after {\b shutdown()} has been invoked with how set to 1 or 2.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEWOULDBLOCK\tab The socket is marked as non-blocking and the requested operation would block.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEMSGSIZE\tab The socket is of type SOCK_DGRAM, and the datagram is larger than the maximum supported by the Windows Sockets implementation.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\revised WSAECONNABORTED\tab The virtual circuit was aborted due to timeout or other failure.
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\revised 
\par }{\revised WSAECONNRESET\tab The virtual circuit was rese}t {\revised by the remo}{\revised te side.
\par }{\revised 
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEADDRNOTAVAIL\tab {\revised The }specified address is not available from the local machine.{\deleted 
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\revised 
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\revised WSAEAFNOSUPPORT\tab Addresses in the specified family cannot be used with this socket.
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\revised 
\par }{\revised WSAEDESTADDRREQ\tab A destination address is required.
\par }{\revised 
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\revised WSAENETUNREACH\tab The network can't be reached from this host at this time.
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b recv()}, {\b recvfrom()}, {\b socket()}, {\b send()}, {\b WSAStartup()}.
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 setsockopt {\field{\*\fldinst PAGE}{\fldrslt 57}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart setsockopt}4.1.21{\*\bkmkend setsockopt} setsockopt()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Set a socket option.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int }{\b\revised PASCAL FAR }{\b setsockopt ( SOCKET} {\i s}{\b , int} {\i level}{\b , int} {\i optname}{\b , }{\b\revised 
\par }{\b\revised \tab const }{\b char FAR * }{\i optval}{\b , int} {\i optlen }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i s}\tab A descriptor identifying a socket.
\par 
\par \pard \s10\fi-1440\li2880 {\i level}\tab The level at which the option is defined; the only supported {\i level}{\revised s are} SOL_SOCKET{\revised  and IPPROTO_TCP}.
\par \pard \s10\fi-1440\li2880 
\par {\i optname}\tab The socket option for which the value is to be set.
\par 
\par \pard \s10\fi-1440\li2880 {\i optval}\tab A pointer to the buffer in which the value for the requested option is supplied.
\par \pard \s10\fi-1440\li2880 
\par {\i optlen}\tab {\revised T}he size of the {\i optval} buffer.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab {\b setsockopt()} sets the current value for a socket option associated with a socket of any type, in any sta
te.  Although options may exist at multiple protocol levels, this specification only defines options that exist at the uppermost "socket'' level.  Options affect socket operations, such as whether expedited data is received in the normal data stream, whet
her broadcast messages may be sent on the socket, etc.  
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 There are two types of socket options: Boolean options that enable or disable a feature or behavior, and options which require an integer value or structure.  To enable a Boolean option, {\i optval} poi
nts to a nonzero integer.  To disable the option {\i optval} points to an integer equal to zero.  {\i optlen} should be equal to sizeof(int) for Boolean options.  For other options, {\i optval}
 points to the an integer or structure that contains the desired value for the option, and {\i optlen} is the length of the integer or structure.
\par \pard \s12\li1440 
\par \pard \s12\li1440 SO_LINGER controls the action taken when unsent data is queued on a socket and a {\b closesocket()} is performed.  See {\b closesocket()} for a description of the way in which the SO_LINGER settings affect the semantics of {\b 
closesocket()}.  The application sets the desired behavior by creating a {\i struct linger} (pointed to by the {\i optval} argument) with the following elements:
\par \pard \s12\li1440 
\par \pard\plain \s29\li1440 \f5\fs20\lang1033 struct linger \{
\par \tab int\tab l_onoff;
\par \tab int\tab l_linger;
\par \}
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 To enable SO_LINGER, the application should set {\i l_onoff} to a non-zero value, set {\i l_linger} to 0 or the desired timeout (in seconds), and call {\b setsockopt()}.  To enable SO_DONTLINGER (i.e. disable SO_LINGER) {\i l_onoff}
 should be set to zero and {\b setsockopt()} should be called.
\par \pard \s12\li1440 
\par \pard \s12\li1440 By default, a socket may not be bound (see {\b bind()}
) to a local address which is already in use.  On occasions, however, it may be desirable to "re-use" an address in this way.  Since every connection is uniquely identified by the combination of local and remote addresses, there is no problem with having 
two sockets bound to the same local address as long as the remote addresses are different.  To inform the Windows Sockets implementation that a {\b bind()} on a socket should not be disallowed b{\revised e}cause the desired address i
s already in use by another socke{\revised t,} the application should set the SO_REUSEADDR socket option for the socket before issuing the {\b bind()}.  Note that the option is interpreted only at the time of the {\b bind()}
: it is therefore unnecessary (but harmless) to set the option on a socket which is not to be bound to an existing address, and setting or resetting the option after the {\b bind()} has no effect on this or any other socket.
\par \pard \s12\li1440 
\par \pard \s12\li1440 An application may request that the Windows Sockets implementation enable the use of "
keep-alive" packets on TCP connections by turning on the SO_KEEPALIVE socket option.  A Windows Sockets implementation need not support the use of keep-alives: if it does, the precise semantics are implementation-specific but should conform to section 4.2
.3.6 of RFC 1122: {\i Requirements for Internet Hosts -- Communication Layers}
.  If a connection is dropped as the result of "keep-alives" the error code WSAENETRESET is returned to any calls in progress on the socket, and any subsequent calls will fail with WSAENOTCONN.  
\par \pard \s12\li1440 
\par \pard \s12\li1440 {\revised The TCP_NODELAY option disables the Nagle algorithm.  The Nagle algorithm is used to reduce the number of small packets sent by a host by }buffering{\revised 
 unacknowledged send data until a full-size packet can be sent.  However, for some applications this algorithm can impede performance, and TCP_NODELAY may be used to turn it off.  Application writers should not set TCP_NODELAY unless the impact of doing s
}{\revised o is well-un}derstood and desired{\revised , since setting TCP_NODELAY can have a significant negative imp}{\revised act of network performance.  TCP_NODELAY is the only supported socket option which uses }{\i\revised level}{\revised 
 IPPROTO_TCP; all other options use level SOL_SOCKET.}
\par \pard \s12\li1440 
\par \pard \s12\li1440 {\revised 
Windows Sockets suppliers are encouraged (but not required) to supply output debug information if the SO_DEBUG option is set by an application.  The mechanism for generating the debug information and the form it takes are beyond the scope of this specific
}{\revised ation.}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 The following options are supported for {\b setsockopt()}.  The {\ul Type} identifies the type of data addressed by {\i optval}.
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 
\par \trowd \trgaph108\trleft-108 \cellx3987\cellx5217\cellx9507\pard \s10\li2160\intbl {\ul Value}\cell \pard \s10\intbl {\ul Type}\cell \pard \s10\intbl {\ul Meaning}\cell \pard\plain \intbl \fs20\lang1033 \row \trowd \trgaph108\trleft-108 \cellx3987
\cellx5217\cellx9507\pard\plain \s10\li2160\intbl \fs20\lang1033 SO_BROADCAST\cell \pard \s10\intbl BOOL\cell \pard \s10\intbl Allow transmission of broadcast messages on the socket.\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain 
\s10\li2160\intbl \fs20\lang1033 SO_DEBUG\cell \pard \s10\intbl BOOL\cell \pard \s10\intbl Record debugging information.  \cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 SO_DONTLINGER\cell \pard \s10\intbl BOOL
\cell \pard \s10\intbl Don't block close waiting for unsent data to be sent.  Setting this option is equivalent to setting SO_LINGER with {\i l_onoff} set to zero.\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 
SO_DONTROUTE\cell \pard \s10\intbl BOOL\cell \pard \s10\intbl Don't route: send directly to interface.\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 SO_KEEPALIVE\cell \pard \s10\intbl BOOL\cell \pard \s10\intbl 
Send keepalives\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 SO_LINGER\cell \pard \s10\intbl struct linger FAR *\cell \pard \s10\intbl Linger on close if unsent data is present\cell \pard\plain \intbl 
\fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 SO_OOBINLINE\cell \pard \s10\intbl BOOL\cell \pard \s10\intbl Receive out-of-band data in the normal data stream.  \cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl 
\fs20\lang1033 SO_RCVBUF\cell \pard \s10\intbl int\cell \pard \s10\intbl Specify buffer size for receives\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 SO_REUSEADDR\cell \pard \s10\intbl BOOL\cell \pard 
\s10\intbl Allow the socket to be bound to an address which is already in use.  (See {\b bind()}.) \cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 SO_SNDBUF\cell \pard \s10\intbl int\cell \pard \s10\intbl 
Specify buffer size for sends.\cell \pard\plain \intbl \fs20\lang1033 \row \trowd \trgaph108\trleft-108 \cellx3987\cellx5217\cellx9507\pard\plain \s10\li2160\intbl \fs20\lang1033 {\revised TCP_NODELAY}\cell \pard \s10\intbl {\revised BOOL}\cell \pard 
\s10\intbl Disables the Nagle algorithm for send coalescing.\cell \pard\plain \intbl \fs20\lang1033 \row \pard \li2160 
\par BSD options not supported for {\b setsockopt()} are:
\par 
\par \trowd \trgaph108\trleft-108 \cellx3987\cellx5292\cellx9582\pard\plain \s10\li2160\intbl \fs20\lang1033 {\ul Value}\cell \pard \s10\intbl {\ul Type}\cell \pard \s10\intbl {\ul Meaning}\cell \pard\plain \intbl \fs20\lang1033 \row \trowd 
\trgaph108\trleft-108 \cellx3987\cellx5292\cellx9582\pard\plain \s10\li2160\intbl \fs20\lang1033 SO_ACCEPTCON{\revised N}\cell \pard \s10\intbl BOOL\cell \pard \s10\intbl Socket is listening\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain 
\s10\li2160\intbl \fs20\lang1033 SO_ERROR\cell \pard \s10\intbl int\cell \pard \s10\intbl Get error status and clear\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 SO_RCVLOWAT\cell \pard \s10\intbl int\cell \pard 
\s10\intbl Receive low water mark\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 SO_RCVTIMEO\cell \pard \s10\intbl int\cell \pard \s10\intbl Receive timeout\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain 
\s10\li2160\intbl \fs20\lang1033 SO_SNDLOWAT\cell \pard \s10\intbl int\cell \pard \s10\intbl Send low water mark\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 SO_SNDTIMEO\cell \pard \s10\intbl int\cell \pard 
\s10\intbl Send timeout\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s10\li2160\intbl \fs20\lang1033 SO_TYPE\cell \pard \s10\intbl int\cell \pard \s10\intbl Type of the socket\cell \pard\plain \intbl \fs20\lang1033 \row \trowd 
\trgaph108\trleft-108 \cellx3987\cellx5292\cellx9582\pard\plain \s10\li2160\intbl \fs20\lang1033 IP_OPTIONS\cell \pard \s10\intbl \cell \pard \s10\intbl Set options field in IP header.\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain 
\s7\fi-1440\li1440 \fs20\lang1033 
\par \pard \s7\fi-1440\li1440 {\b\f2 Return Value}\tab If no error occurs, {\b setsockopt()} returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling {\b WSAGetLastError()}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEFAULT\tab {\i optval} is not in a valid part of the process address  space.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 WSAEINVAL\tab {\i level} is not valid{\revised , or the information in }{\i\revised optval }{\revised is not valid.}
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETRESET\tab Connection has timed out when SO_KEEPALIVE is set.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENOPROTOOPT\tab The option is unknown or unsupported.  In particular, SO_BROADCAST is not supported on s
ockets of type SOCK_STREAM, while SO_DONTLINGER, SO_KEEPALIVE, SO_LINGER and SO_OOBINLINE are not supported on sockets of type SOCK_DGRAM.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENOTCONN\tab Connection has been reset when SO_KEEPALIVE is set.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAENOTSOCK\tab The descriptor is not a socket.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b bind()}, {\b getsockopt()}, {\b ioctlsocket()}, {\b socket()}, {\b WSAAsyncSelect()}.
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 shutdown {\field{\*\fldinst PAGE}{\fldrslt 59}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart shutdown}4.1.22{\*\bkmkend shutdown} shutdown()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Disable sends and/or receives on a socket.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int }{\b\revised PASCAL FAR }{\b shutdown ( SOCKET} {\i s}{\b , int} {\i how }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i s}\tab A descriptor identifying a socket.
\par 
\par \pard \s10\fi-1440\li2880 {\i how}\tab A flag that describes what types of operation will no longer be allowed.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab {\b shutdown}() is used on all types of sockets to disable reception, transmission, or both.
\par 
\par \pard\plain \s12\li1440 \fs20\lang1033 If {\i how}
 is 0, subsequent receives on the socket will be disallowed.  This has no effect on the lower protocol layers.  For TCP, the TCP window is not changed and incoming data will be accepted (but not acknowledged) until the window is exhausted.  For UDP, incom
ing datagrams are accepted and queued.  In no case will an ICMP error packet be generated.
\par \pard \s12\li1440 
\par If {\i how} is 1, subsequent sends are disallowed.  For TCP sockets, a FIN will be sent.
\par 
\par Setting {\i how} to 2 disables both sends and receives as described above.
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 Note that {\b shutdown()} does not close the socket, and resources attached to the socket will not be freed until {\b closesocket()} is invoked.
\par \pard \s12\li1440 
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Comments}\tab {\b shutdown()} does not block regardless of the SO_LINGER setting on the socket.
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 An application should not rely on being able to re-use a socket after it has been shut down.  In particular, a Windows Sockets implementation is not required to support the use of {\b connect()} on such a socket.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b shutdown()} returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code may be retrieved by calling {\b WSAGetLastError().}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAEINVAL\tab how is not valid.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENOTCONN\tab The socket is not connected (SOCK_STREAM only).
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAENOTSOCK\tab The descriptor is not a socket.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b connect()}, {\b socket()}.
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 socket {\field{\*\fldinst PAGE}{\fldrslt 61}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart socket}4.1.23{\*\bkmkend socket} socket()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Create a socket.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b SOCKET }{\b\revised PASCAL FAR }{\b socket ( int} {\i af}{\b , int} {\i type}{\b , int} {\i protocol }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i af}\tab An address format specification.  The only format currently supported is PF_INET, which is the ARPA Internet address format.
\par \pard \s10\fi-1440\li2880 
\par {\i type}\tab A type specification for the new socket.
\par 
\par \pard \s10\fi-1440\li2880 {\i protocol}\tab A particular protocol to be used with the socket{\revised , or 0 if the caller does not wish to specify a protocol.}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab {\b socket()} allocates a socket descriptor of the specified address family, data type and protocol, as well as related resources.  If a protocol is not specified{\revised 
 (i.e. equal to 0)}, the default for the specified connection mode is used.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 Only a single protocol exists to support a particular socket type using a given address format.  However, the address family may be given as AF_UNSPEC (unspecified), in which case the {\i protocol}
 parameter must be specified.  The protocol number to use is particular to the "communication domain'' in which communication is to take place.
\par \pard \s12\li1440 
\par The following {\i type} specifications are supported:
\par 
\par \pard\plain \s16\fi-2160\li4320 \fs20\ul\lang1033 Type\tab Explanation
\par \pard\plain \s17\fi-2160\li4320 \fs20\lang1033 SOCK_STREAM\tab Provides sequenced, reliable, two-way, connection-based byte streams with an out-of-band data transmission mechanism.  Uses TCP for the Internet address family.
\par \pard \s17\fi-2160\li4320 
\par \pard \s17\fi-2160\li4320 SOCK_DGRAM\tab Supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length.  Uses UDP for the Internet address family.
\par \pard \s17\fi-2160\li4320 
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 Sockets of type SOCK_STREAM are full-duplex byte streams.  A stream socket must be in a connected state before any data may be sent or received on it.  A connection to another socket is created with a {\b connect}
() call.  Once connected, data may be transferred using {\b send}() and {\b recv}() calls.  When a session has been completed, a {\b closesocket}() must be performed.  Out-of-band data may also be transmitted as described in {\b send}
() and received as described in {\b recv}().
\par \pard \s12\li1440 
\par \pard \s12\li1440 
The communications protocols used to implement a SOCK_STREAM ensure that data is not lost or duplicated.  If data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable length of time,  the connection is consid
ered broken and subsequent calls will fail with the error code set to WSAETIMEDOUT.
\par \pard \s12\li1440 
\par \pard \s12\li1440 SOCK_DGRAM sockets allow sending and receiving of datagrams to and from arbitrary peers using {\b sendto()} and {\b recvfrom()}.  If such a socket is {\b connect()}ed to a specific peer, datagrams may be send to that peer {\b send}
() and may be received from (only) this peer using {\b recv}().
\par \pard\plain \fs20\lang1033 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b socket()}
 returns a descriptor referencing the new socket.  Otherwise, a value of INVALID_SOCKET is returned, and a specific error code may be retrieved by calling {\b WSAGetLastError().}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAEAFNOSUPPORT\tab The specified address family is not supported.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAEMFILE\tab No more file descriptors are available.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENOBUFS\tab No buffer space is available.  The socket cannot be created.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAEPROTONOSUPPORT\tab The specified protocol is not supported.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEPROTOTYPE\tab The specified protocol is the wrong type for this socket.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAESOCKTNOSUPPORT\tab The specified socket type is not supported in this address family.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b accept()}, {\b bind()}, {\b connect()}, {\b getsockname()}, {\b getsockopt()}, {\b setsockopt()}, {\b listen()}, r{\b ecv()}, {\b recvfrom()}, {\b select()}, {\b send()}, {\b sendto()}
, {\b shutdown()}, {\b ioctlsocket()}.
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 gethostbyaddr {\field{\*\fldinst PAGE}{\fldrslt 63}}
\par }\pard\plain \s253\sb120 \b\f2\lang1033 4.2 Database Routines
\par \pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart gethostbyaddr}4.2.1{\*\bkmkend gethostbyaddr} gethostbyaddr()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Get host information corresponding to an address.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b struct hostent FAR * }{\b\revised PASCAL FAR }{\b gethostbyaddr ( }{\b\revised const }{\b char FAR *} {\i addr}{\b , int} {\i len}{\b , }{\b\revised  }{\b int} {\i type }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i addr}\tab A pointer to an address in network byte order.
\par 
\par {\i len}\tab The length of the address, which must be 4 for PF_INET addresses.
\par 
\par {\i type}\tab The type of the address, which must be PF_INET.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab {\b gethostbyaddr}() returns a pointer to the following structure which contains the name(s) and address which correspond to the given address.  
\par \pard \s5\fi-1440\li1440 
\par \pard\plain \s29\li1440 \f5\fs20\lang1033 struct hostent \{
\par \tab char FAR *\tab h_name;
\par \tab char FAR * FAR *\tab h_aliases;
\par \tab {\revised short}\tab h_addrtype;
\par \tab {\revised short}\tab h_length;
\par \tab char FAR * FAR *\tab h_addr_list;
\par \};
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard\plain \s19\fi-2160\li3600\tx3600 \fs20\lang1033 The members of this structure are:
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 Element\tab Usage
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 h_name\tab Official name of the host (PC).
\par h_aliases\tab A NULL-terminated array of alternate names.
\par \pard \s10\fi-1440\li2880 h_addrtype\tab The type of address being returned; for Windows Sockets this is always PF_INET.
\par \pard \s10\fi-1440\li2880 h_length\tab The length, in bytes, of each address; for PF_INET, this is always 4.
\par \pard \s10\fi-1440\li2880 h_addr_list\tab A NULL-terminated list of addresses for the host.  Addresses are returned in network byte order.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 The macro h_addr is defined to be h_addr_list[0] for compatibility with older software.
\par 
\par \pard \s12\li1440 The pointer which is returned points to a structure which is allocated by the Wi
ndows Sockets implementation.  The application must never attempt to modify this structure or to free any of its components.  Furthermore, only one copy of this structure is allocated per thread, and so the application should copy any information which it
 needs before issuing any other Windows Sockets API calls.
\par \pard \s12\li1440 
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b gethostbyaddr()}
 returns a pointer to the hostent structure described above.  Otherwise it returns a NULL pointer and a specific error number may be retrieved by calling {\b WSAGetLastError{\*\bkmkstart now}().}{\*\bkmkend now}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAHOST_NOT_FOUND\tab Authoritative Answer Host not found.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSATRY_AGAIN\tab Non-Authoritative Host not found, or SERVERFAIL.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSANO_RECOVERY\tab Non recoverable errors, FORMERR, REFUSED, NOTIMP.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSANO_DATA\tab Valid name, no data record of requested type.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINTR\tab The (blocking) call was canceled via {\b WSACancelBlockingCall().}
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b WSAAsyncGetHostByAddr()}, {\b gethostbyname()},
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 gethostname {\field{\*\fldinst PAGE}{\fldrslt 65}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart gethostbyname}4.2.2{\*\bkmkend gethostbyname} gethostbyname()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Get host information corresponding to a hostname.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b struct hostent FAR * }{\b\revised PASCAL FAR }{\b gethostbyname ( }{\b\revised const }{\b char FAR * }{\i name }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i name}\tab A pointer to the name of the host.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab {\b gethostbyname}() returns a pointer to a hostent structure as described under {\b gethostbyaddr}().  The contents of this structure correspond to the hostname {\i name}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 
The pointer which is returned points to a structure which is allocated by the Windows Sockets implementation.  The application must never attempt to modify this structure or to free any of its components.  Furthermore, only one copy of this structure is a
llocated per thread, and so the application should copy any information which it needs before issuing any other Windows Sockets API calls.
\par \pard \s12\li1440 
\par \pard \s12\li1440 {\revised A }{\b\revised gethostbyname() }{\revised implementation must not resolve IP address strings passed }{\revised 
to it.  Such a request should be treated exactly as if an unknown host name were passed.  An application with an IP address string to resolve should use }{\b\revised inet_addr() }{\revised to convert the string to an IP address, then }{\b\revised 
gethostbyaddr() }{\revised to obtain the hostent structure.}
\par \pard\plain \fs20\lang1033 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b gethostbyname()}
 returns a pointer to the hostent structure described above.  Otherwise it returns a NULL pointer and a specific error number may be retrieved by calling {\b WSAGetLastError()}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAHOST_NOT_FOUND\tab Authoritative Answer Host not found.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSATRY_AGAIN\tab Non-Authoritative Host not found, or SERVERFAIL.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSANO_RECOVERY\tab Non recoverable errors, FORMERR, REFUSED, NOTIMP.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSANO_DATA\tab Valid name, no data record of requested type.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINTR\tab The (blocking) call was canceled via {\b WSACancelBlockingCall().}
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b WSAAsyncGetHostByName()}, {\b gethostbyaddr()\page 
\par }\pard\plain \s252 \b\f2\lang1033 {\revised {\*\bkmkstart gethostname}4.2.3{\*\bkmkend gethostname} gethostname()
\par }\pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2\revised Description\tab }{\revised Return the standard host name for the local machine.
\par }{\revised 
\par }{\revised \tab }{\b\revised #include <winsock.h>
\par }{\b\revised 
\par }\pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\revised \tab }{\b\revised int }{\b PASCAL FAR }{\b\revised gethostname ( char FAR * }{\i\revised name}{\b\revised , int }{\i\revised namelen}{\revised  }{\b\revised );}{\revised 
\par }{\revised 
\par }\pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i\revised name\tab }{\revised A pointer to a buffer that will receive the host name.
\par }{\revised 
\par }{\i\revised namelen}{\revised \tab The length of the buffer.
\par }{\revised 
\par }\pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2\revised Remarks}{\revised \tab This routine returns the name of the local host into the buffer specified by the }{\i\revised name }{\revised parameter.  The host name is returned a}{\revised 
s a null-terminated string.  The form of the host name is dependent on the Windows Sockets implementation--it may be a simple host name, or it may be a fully qualified domain name.  However, it is guaranteed that the name returned will be successfully par
}{\revised sed by }{\b\revised gethostbyname() }{\revised and }{\b\revised WSAAsyncGetHostByName().}{\revised 
\par }\pard \s5\fi-1440\li1440 {\revised 
\par }\pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2\revised Return Value}{\revised \tab If no error occurs, }{\b\revised gethostname() }{\revised returns 0, otherwise it returns SOCKET_ERROR and a specific error code may be retrieved by calling }{
\b\revised WSAGetLastError()}{\revised .
\par }\pard \s7\fi-1440\li1440 {\revised 
\par }\pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2\revised Error Codes}{\revised \tab WSAEFAULT\tab The }{\i\revised namelen }{\revised parameter is too small
\par }{\revised 
\par }\pard \s8\fi-4320\li4320\keep\tx1440\tx4320 {\revised \tab WSANOTINITIALISED\tab A successful }{\b\revised WSAStartup() }{\revised must occur before using this API.
\par }\pard \s8\fi-4320\li4320\keep\tx1440\tx4320 {\revised 
\par }\pard \s8\fi-4320\li4320\keep\tx1440\tx4320 {\revised \tab WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par }\pard \s8\fi-4320\li4320\keep\tx1440\tx4320 {\revised 
\par }\pard \s8\fi-4320\li4320\keep\tx1440\tx4320 {\revised \tab WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par }\pard \s8\fi-4320\li4320\keep\tx1440\tx4320 {\revised 
\par }\pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2\revised See Also}{\b\revised \tab gethostbyname(), WSAAsyncGetHostByName().}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 getprotobyname {\field{\*\fldinst PAGE}{\fldrslt 67}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart getprotobyname}4.2.4{\*\bkmkend getprotobyname} getprotobyname()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Get protocol information corresponding to a protocol name.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b struct protoent FAR * }{\b\revised PASCAL FAR }{\b getprotobyname ( }{\b\revised cons}{\b\revised t }{\b char FAR * }{\i name }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i name}\tab A pointer to a protocol name.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab {\b getprotobyname}() returns a pointer to the following structure which contains the name(s) and protocol number which correspond to the given protocol {\i name}.  
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s29\li1440 \f5\fs20\lang1033 struct protoent \{
\par \tab char FAR *\tab p_name;
\par \tab char FAR * FAR *\tab p_aliases;
\par \tab {\revised short}\tab p_proto;
\par \};
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s19\fi-2160\li3600\tx3600 \fs20\lang1033 The members of this structure are:
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 Element\tab Usage
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 p_name\tab Official name of the protocol.
\par p_aliases\tab A NULL-terminated array of alternate names.
\par p_proto\tab The protocol number, in host byte order.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 The poi
nter which is returned points to a structure which is allocated by the Windows Sockets library.  The application must never attempt to modify this structure or to free any of its components.  Furthermore only one copy of this structure is allocated per th
read, and so the application should copy any information which it needs before issuing any other Windows Sockets API calls.
\par \pard\plain \fs20\lang1033 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b getprotobyname()} returns a pointer to the protoent structure described above.  Otherwise it retur
ns a NULL pointer and a specific error number may be retrieved by calling {\b WSAGetLastError()}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSANO_RECOVERY\tab Non recoverable errors, FORMERR, REFUSED, NOTIMP.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSANO_DATA\tab Valid name, no data record of requested type.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINTR\tab The (blocking) call was canceled via {\b WSACancelBlockingCall().}
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard\plain \fs20\lang1033 
\par \pard {\b\f2 See Also}\tab {\b WSAAsyncGetProtoByName()}, {\b getprotobynumber()}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 getprotobynumber {\field\flddirty{\*\fldinst PAGE}{\fldrslt 60}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart getprotobynumber}4.2.5{\*\bkmkend getprotobynumber} getprotobynumber()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Get protocol information corresponding to a protocol number.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b struct protoent FAR * }{\b\revised PASCAL FAR }{\b getprotobynumber ( int} {\i number }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i number}\tab A protocol number, in host byte order.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This function returns a pointer to a protoent structure as described above in {\b getprotobyname()}.  The contents of the structure correspond to the given protocol number.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 
The pointer which is returned points to a structure which is allocated by the Windows Sockets implementation.  The application must never attempt to modify this structure or to free any of its components.  Furthermore, only one copy of this structure is a
llocated per thread, and so the application should copy any information which it needs before issuing any other Windows Sockets API calls.
\par \pard\plain \fs20\lang1033 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b getprotobynumber()} returns a pointer to the protoent structure describ
ed above.  Otherwise it returns a NULL pointer and a specific error number may be retrieved by calling {\b WSAGetLastError()}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSANO_RECOVERY\tab Non recoverable errors, FORMERR, REFUSED, NOTIMP.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSANO_DATA\tab Valid name, no data record of requested type.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINTR\tab The (blocking) call was canceled via {\b WSACancelBlockingCall().}
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b WSAAsyncGetProtoByNumber()}, {\b getprotobyname()}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 getservbyname {\field{\*\fldinst PAGE}{\fldrslt 69}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart getservbyname}4.2.6{\*\bkmkend getservbyname} getservbyname()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Get service information corresponding to a service name and protocol.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b struct servent FAR * }{\b\revised PASCAL FAR }{\b getservbyname ( }{\b\revised const }{\b char FAR * }{\i name}{\b , }{\b\revised 
\par }{\b\revised \tab const }{\b char FAR * }{\i proto }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i name}\tab A pointer to a service name.
\par 
\par \pard \s10\fi-1440\li2880 {\i proto}\tab A{\revised n optional} pointer to a protocol name.  If this is NULL, {\b getservbyname()} returns the first service entry for which the {\i name} matches the s_name or one of the s_aliases.  Otherwise {\b 
getservbyname()} matches both the {\i name }and the {\i proto}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab {\b getservbyname()} returns a pointer to the following structure which contains the name(s) and service number which correspond to the given service {\i name}.  
\par \pard \s5\fi-1440\li1440 
\par \pard\plain \s29\li1440 \f5\fs20\lang1033 struct servent \{
\par \tab char FAR *\tab s_name;
\par \tab char FAR * FAR *\tab s_aliases;
\par \tab {\revised short}\tab s_port;
\par \tab char FAR *\tab s_proto;
\par \};
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s19\fi-2160\li3600\tx3600 \fs20\lang1033 The members of this structure are:
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 Element\tab Usage
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 s_name\tab Official name of the service.
\par s_aliases\tab A NULL-terminated array of alternate names.
\par \pard \s10\fi-1440\li2880 s_port\tab The port number at which the service may be contacted.  Port numbers are returned in network byte order.
\par \pard \s10\fi-1440\li2880 s_proto\tab The name of the protocol to use when contacting the service.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 
The pointer which is returned points to a structure which is allocated by the Windows Sockets library.  The application must never attempt to modify this structure or to free any of its components.  Furthermore only one copy of this structure is allocated
 per thread, and so the application should copy any information which it needs before issuing any other Windows Sockets API calls.
\par \pard\plain \fs20\lang1033 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b getservbyname()}
 returns a pointer to the servent structure described above.  Otherwise it returns a NULL pointer and a specific error number may be retrieved by calling {\b WSAGetLastError().}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSANO_RECOVERY\tab Non recoverable errors, FORMERR, REFUSED, NOTIMP.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSANO_DATA\tab Valid name, no data record of requested type.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINTR\tab The (blocking) call was canceled via {\b WSACancelBlockingCall().}
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard\plain \fs20\lang1033 
\par \pard {\b\f2 See Also}\tab {\b WSAAsyncGetServByName()}, {\b getservbyport()}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 getservbyport {\field{\*\fldinst PAGE}{\fldrslt 71}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart getservbyport}4.2.7{\*\bkmkend getservbyport} getservbyport()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Get service information corresponding to a port and protocol.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b struct servent FAR * }{\b\revised PASCAL FAR }{\b getservbyport ( int} {\i port}{\b , const char FAR }{\b *} {\i proto }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i port}\tab The port for a service, in network byte order.
\par 
\par \pard \s10\fi-1440\li2880 {\i proto}\tab A{\revised n optional} pointer to a protocol name.  If this is NULL, {\b getservbyport()} returns the first service entry for which the {\i port }matches the s_port.  Otherwise {\b getservbyport()}
 matches both the {\i port} and the {\i proto}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab {\b getservbyport()} returns a pointer a servent structure as described above for {\b getservbyname()}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 The pointer which is returned points to a structure which is allocated by the Windows Sockets implementation.  The applicati
on must never attempt to modify this structure or to free any of its components.  Furthermore, only one copy of this structure is allocated per thread, and so the application should copy any information which it needs before issuing any other Windows Sock
ets API calls.
\par \pard\plain \fs20\lang1033 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab If no error occurs, {\b getservbyport()}
 returns a pointer to the servent structure described above.  Otherwise it returns a NULL pointer and a specific error number may be retrieved by calling {\b WSAGetLastError().}
\par \pard \s7\fi-1440\li1440 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSANO_RECOVERY\tab Non recoverable errors, FORMERR, REFUSED, NOTIMP.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSANO_DATA\tab Valid name, no data record of requested type.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINTR\tab The (blocking) call was canceled via {\b WSACancelBlockingCall().}
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b WSAAsyncGetServByPort()}, {\b getservbyname()}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 WSAAsyncGetHostByAddr {\field{\*\fldinst PAGE}{\fldrslt 73}}
\par }\pard\plain \s253\sb120 \b\f2\lang1033 4.3 Microsoft Windows-specific Extensions
\par \pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart WSAAsyncGetHostByAdd}4.3.1{\*\bkmkend WSAAsyncGetHostByAdd} {\*\bkmkstart WSAGetHostByAddr}{\*\bkmkend WSAGetHostByAddr}WSAAsyncGetHostByAddr()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Get host information corresponding to an address - asynchronous version.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b HANDLE }{\b\revised PASCAL FAR }{\b WSAAsyncGetHostByAddr ( HWND} {\i hWnd}{\b , }{\b\revised 
\par }\pard \s4\fi-1440\li1440 {\b\revised \tab }{\b unsigned int} {\i wMsg}{\b ,  }{\b\revised const }{\b char FAR * }{\i addr}{\b , int} {\i len}{\b , int} {\i type}{\b , char FAR *} {\i buf}{\b , int} {\i buflen }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i hWnd}\tab The handle of the window which should receive a message when the asynchronous request completes.
\par \pard \s10\fi-1440\li2880 
\par {\i wMsg}\tab The message to be received when the asynchronous request completes.
\par 
\par \pard \s10\fi-1440\li2880 {\i addr}\tab A{\b  }pointer to the network address for the host.  Host addresses are stored in network byte order.
\par \pard \s10\fi-1440\li2880 
\par {\i len}\tab The length of the address, which must be 4 for PF_INET.
\par 
\par {\i type}\tab The type of the address, which must be PF_INET.
\par 
\par \pard \s10\fi-1440\li2880 {\i buf}\tab 
A pointer to the data area to receive the hostent data.  Note that this must be larger than the size of a hostent structure.  This is because the data area supplied is used by the Windows Sockets implementation to contain not only a hostent structure but
 any and all of the data which is referenced by members of the hostent structure.  It is recommended that you supply a buffer of MAXGETHOSTSTRUCT bytes.
\par \pard \s10\fi-1440\li2880 
\par {\i buflen}\tab The size of data area {\i buf} above.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This function is an asynchronous version of {\b gethostbyaddr()}
, and is used to retrieve host name and address information corresponding to a network address.  The Windows Sockets implementation initiates the operation and returns to the caller immediately, passing back an {\ul asynchronous task handle}
 which the application may use to identify the operation.  When the operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 When the asynchronous operation is complete the application's window {\i hWnd} receives message {\i wMsg}.  The {\i wParam}
 argument contains the asynchronous task handle as returned by the original function call.  The high 16 bits of {\i lParam} contain any error code.  The error code may be any error as defined in {\b winsock.h}.  An error code of zero indi
cates successful completion of the asynchronous operation.  On successful completion, the buffer supplied to the original function call contains a hostent structure.  To access the elements of this structure, the original buffer address should be cast to 
a hostent structure pointer and accessed as appropriate.
\par \pard \s12\li1440 
\par \pard \s12\li1440 Note that if the error code is WSAENOBUFS, it indicates that the size of the buffer specified by {\i buflen} in the original call was too small to contain all the resultant information.  In this case, the low 16 bits of {\i lParam}
 contain the size of buffer required to supply ALL the requisite information.  If the application decides that the partial data is inadequate, it may reissue the {\b WSAAsyncGetHostByAddr() }
function call with a buffer large enough to receive all the desired  information (i.e.  no smaller than the low 16 bits of {\i lParam}).
\par \pard \s12\li1440 
\par \pard \s12\li1440 The error code and buffer length should be extracted from the {\i lParam} using the macros  WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in {\b winsock.h} as:
\par \pard \s12\li1440 
\par \pard\plain \s32\fi-1440\li2880 \f5\fs20\lang1033 #define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
\par #define WSAGETASYNCBUFLEN(lParam)           LOWORD(lParam)
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 The use of these macros will maximize the portability of the source code for the application.  
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab The return value specifies whether or not the asynchronous operation was successfully initiated.  Note that it does {\ul not} imply success or failure of the operation itself.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s14\li1440 \fs20\lang1033 If the operation was successfully initiated, {\b WSAAsyncGetHostByAddr()} returns a nonzero value of type HANDLE which is 
the asynchronous task handle for the request.  This value can be used in two ways.  It can be used to cancel the operation using {\b WSACancelAsyncRequest()}
.  It can also be used to match up asynchronous operations and completion messages, by examining the {\i wParam} message argument.
\par \pard \s14\li1440 
\par \pard\plain \s12\li1440 \fs20\lang1033 If the asynchronous operation could not be initiated, {\b WSAAsyncGetHostByAddr()} returns a zero value, and a specific error number may be retrieved by calling {\b WSAGetLastError()}.
\par \pard \s12\li1440 
\par \pard\plain \s26\fi-1440\li1440 \fs20\lang1033 {\b\f2 Comments}\tab The buffer supplied to this function is used
 by the Windows Sockets implementation to construct a hostent structure together with the contents of data areas referenced by members of the same hostent structure.  To avoid the WSAENOBUFS error noted above, the application should provide a buffer of at
 least MAXGETHOSTSTRUCT bytes (as defined in {\b winsock.h}).
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 {\b\f2 Notes For
\par }{\b\f2 Windows Sockets}
\par \pard \s22\fi-1440\li1440 {\b\f2 Suppliers}\tab It is the responsibility of the Windows Sockets implementation to ensure that messages are successfully posted to the application.  If a {\b PostMessage()} operatio
n fails, the Windows Sockets implementation {\ul must} re-post that message{\revised  as long as the window exists}.
\par \pard\plain \s23\li1440 \fs20\lang1033 
\par \pard \s23\li1440 Windows Sockets suppliers should use the WSAMAKEASYNCREPLY macro when constructing the {\i lParam} in the message.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 {\b\f2 Error Codes}\tab The following error codes may be set when an application window receives a message.  As described above, they may be extracted from the {\i lParam}
 in the reply message using the WSAGETASYNCERROR macro.
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAENOBUFS\tab No/insufficient buffer space is available
\par 
\par WSAHOST_NOT_FOUND\tab Authoritative Answer Host not found.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSATRY_AGAIN\tab Non-Authoritative Host not found, or SERVERFAIL.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSANO_RECOVERY\tab Non recoverable errors, FORMERR, REFUSED, NOTIMP.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSANO_DATA\tab Valid name, no data record of requested type.
\par 
\par \pard\plain \s23\li1440 \fs20\lang1033 The following errors may occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEWOULDBLOCK\tab The asynchronous operation cannot be scheduled at this time due to resource or other constraints within the Windows Sockets implementation.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b gethostbyaddr()}, {\b WSACancelAsyncRequest()}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 WSAAsyncGetHostByName {\field{\*\fldinst PAGE}{\fldrslt 77}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart WSAAsyncGetHostByNam}4.3.2{\*\bkmkend WSAAsyncGetHostByNam} {\*\bkmkstart WSAGetHostByName}{\*\bkmkend WSAGetHostByName}WSAAsyncGetHostByName()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Get host information corresponding to a hostname - asynchronous version.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b HANDLE }{\b\revised PASCAL FAR }{\b WSAAsyncGetHostByName ( HWND} {\i hWnd}{\b , }{\b\revised 
\par }{\b\revised \tab }{\b unsigned int} {\i wMsg}{\b , }{\b\revised  const }{\b char FAR * }{\i name}{\b , char FAR *} {\i buf}{\b , int} {\i buflen }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i hWnd}\tab The handle of the window which should receive a message when the asynchronous request completes.
\par \pard \s10\fi-1440\li2880 
\par {\i wMsg}\tab The message to be received when the asynchronous request completes.
\par 
\par {\i name}\tab A{\b  }pointer to the name of the host.
\par 
\par \pard \s10\fi-1440\li2880 {\i buf}\tab A pointer to the data area to receive the hostent data.  Note that this must be larger than the size of
 a hostent structure.  This is because the data area supplied is used by the Windows Sockets implementation to contain not only a hostent structure but any and all of the data which is referenced by members of the hostent structure.  It is recommended tha
t you supply a buffer of MAXGETHOSTSTRUCT bytes.
\par \pard \s10\fi-1440\li2880 
\par {\i buflen}\tab The size of data area {\i buf} above.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This function is an asynchronous version of {\b gethostbyname()}, and is used to retrieve host name and address information corresponding to a hostname.  The W
indows Sockets implementation initiates the operation and returns to the caller immediately, passing back an {\ul asynchronous task handle}
 which the application may use to identify the operation.  When the operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 When the asynchronous operation is complete the application's window {\i hWnd} receives message {\i wMsg}.  The {\i wParam} argument contains the asynchronous task handle as ret
urned by the original function call.  The high 16 bits of {\i lParam} contain any error code.  The error code may be any error as defined in {\b winsock.h}
.  An error code of zero indicates successful completion of the asynchronous operation.  On successful completion, the buffer supplied to the original function call contains a hostent structure.  To access the elements of this structure, the original buff
er address should be cast to a hostent structure pointer and accessed as appropriate.
\par \pard \s12\li1440 
\par \pard \s12\li1440 Note that if the error code is WSAENOBUFS, it indicates that the size of the buffer specified by {\i buflen} in the original call was too small to contain all the resultant information.  In this case, the low 16 bits of {\i lParam}
 contain the size of buffer required to supply ALL the requisite information.  If the application decides that the partial data is inadequate, it may reissue the {\b WSAAsyncGetHostByName() }
function call with a buffer large enough to receive all the desired  information (i.e. no smaller than the low 16 bits of {\i lParam}).
\par \pard \s12\li1440 
\par \pard \s12\li1440 The error code and buffer length should be extracted from the {\i lParam} using the macros  WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in {\b winsock.h} as:
\par \pard \s12\li1440 
\par \pard\plain \s32\fi-1440\li2880 \f5\fs20\lang1033 #define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
\par #define WSAGETASYNCBUFLEN(lParam)           LOWORD(lParam)
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 The use of these macros will maximize the portability of the source code for the application.  
\par \pard\plain \fs20\lang1033 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab The return value specifies whether or not the asynchronous operation was successfully initiated.  Note that it does {\ul not} imply success or failure of the operation itself.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s14\li1440 \fs20\lang1033 If the operation was successfully initiated, {\b WSAAsyncGetHostByName()}
 returns a nonzero value of type HANDLE which is the asynchronous task handle for the request.  This value can be used in two ways.  It can be used to cancel the operation using {\b WSACancelAsyncRequest()}
.  It can also be used to match up asynchronous operations and completion messages, by examining the {\i wParam} message argument.
\par \pard \s14\li1440 
\par \pard\plain \s12\li1440 \fs20\lang1033 If the asynchronous operation could not be initiated, {\b WS}{\b AAsyncGetHostByName()} returns a zero value, and a specific error number may be retrieved by calling {\b WSAGetLastError()}.
\par \pard \s12\li1440 
\par \pard\plain \s26\fi-1440\li1440 \fs20\lang1033 {\b\f2 Comments}\tab 
The buffer supplied to this function is used by the Windows Sockets implementation to construct a hostent structure together with the contents of data areas referenced by members of the same hostent structure.  To avoid the WSAENOBUFS error noted above, 
the application should provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in {\b winsock.h}).
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 {\b\f2 Notes For
\par }{\b\f2 Windows Soc}{\b\f2 kets
\par }\pard \s22\fi-1440\li1440 {\b\f2 Suppliers}\tab It is the responsibility of the Windows Sockets implemen{\plain \fs20 tation} to ensure that messages are successfully posted to the application.  If a {\b PostMessage()}
 operation fails, the Windows Sockets implementation {\ul must} re-post that message{\revised  as long as the window exists}.
\par \pard\plain \s23\li1440 \fs20\lang1033 
\par \pard \s23\li1440 Windows Sockets suppliers should use the WSAMAKEASYNCREPLY macro when constructing the {\i lParam} in the message.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 {\b\f2 Error Codes}\tab The following error codes may be set when an application window receives a message.  As described above, they may be extracted from the {\i lParam}
 in the reply message using the WSAGETASYNCERROR macro.
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAENOBUFS\tab No/insufficient buffer space is available
\par 
\par WSAHOST_NOT_FOUND\tab Authoritative Answer Host not found.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSATRY_AGAIN\tab Non-Authoritative Host not found, or SERVERFAIL.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSANO_RECOVERY\tab Non recoverable errors, FORMERR, REFUSED, NOTIMP.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSANO_DATA\tab Valid name, no data record of requested type.
\par 
\par \pard\plain \s23\li1440 \fs20\lang1033 The following errors may occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEWOULDBLOCK\tab The asynchronous operation cannot be scheduled at this time due to resource or other constraints within the Windows Sockets implementation.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b gethostbyname()}, {\b WSACancelAsyncRequest()}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 WSAAsyncGetProtoByName {\field{\*\fldinst PAGE}{\fldrslt 79}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart WSAAsyncGetProtoByNa}4.3.3{\*\bkmkend WSAAsyncGetProtoByNa} {\*\bkmkstart WSAGetProtoByName}{\*\bkmkend WSAGetProtoByName}WSAAsyncGetProtoByName()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Get protocol information corresponding to a protocol name - asynchronous version.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b HANDLE }{\b\revised PASCAL FAR }{\b WSAAsyncGetProtoByName ( HWND} {\i hWnd}{\b , }{\b\revised 
\par }{\b\revised \tab }{\b unsigned int} {\i wMsg}{\b , }{\b\revised  const }{\b char FAR * }{\i name}{\b , char FAR *} {\i buf}{\b , int} {\i buflen }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i hWnd}\tab The handle of the window which should receive a message when the asynchronous request completes.
\par \pard \s10\fi-1440\li2880 
\par {\i wMsg}\tab The message to be received when the asynchronous request completes.
\par 
\par {\i name}\tab A{\b  }pointer to the protocol name to be resolved.
\par 
\par \pard \s10\fi-1440\li2880 {\i buf}\tab 
A pointer to the data area to receive the protoent data.  Note that this must be larger than the size of a protoent structure.  This is because the data area supplied is used by the Windows Sockets implementation to contain not only a protoent structure 
but any and all of the data which is referenced by members of the protoent structure.  It is recommended that you supply a buffer of MAXGETHOSTSTRUCT bytes.
\par \pard \s10\fi-1440\li2880 
\par {\i buf}{\i len}\tab The size of data area {\i buf} above.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This function is an asynchronous version of {\b getprotobyname()}
, and is used to retrieve the protocol name and number corresponding to a protocol name.  The Windows Sockets implementation initiates the operation and returns to the caller immediately, passing back an {\ul asynchronous task handle}
 which the application may use to identify the operation.  When the operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 When the asynchronous operation is complete the application's window {\i hWnd} receives message {\i wMsg}.  The {\i wParam}
 argument contains the asynchronous task handle as returned by the original function call.  The high 16 bits of {\i lParam} contain any error code.  The error code may be any error as defined in {\b winsock.h}
.  An error code of zero indicates successful completion of the asynchronous operation.  On successful completion, the buffer supplied to the original function call
 contains a protoent structure.  To access the elements of this structure, the original buffer address should be cast to a protoent structure pointer and accessed as appropriate.
\par \pard \s12\li1440 
\par \pard \s12\li1440 Note that if the error code is WSAENOBUFS, it indicates that the size of the buffer specified by {\i buflen} in the original call was too small to contain all the resultant information.  In this case, the low 16 bits of {\i lParam}
 contain the size of buffer required to supply ALL the requisite information.  If the application decides that the partial data is inadequate, it may reissue the {\b WSAAsyncGetProtoByName() }
function call with a buffer large enough to receive all the desired  information (i.e.  no smaller than the low 16 bits of {\i lParam}).
\par \pard \s12\li1440 
\par \pard \s12\li1440 The error code and buffer length should be extracted from the {\i lParam} using the macros  WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in {\b winsock.h} as:
\par \pard \s12\li1440 
\par \pard\plain \s32\fi-1440\li2880 \f5\fs20\lang1033 #define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
\par #define WSAGETASYNCBUFLEN(lParam)           LOWORD(lParam)
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 The use of these macros will maximize the portability of the source code for the application.  
\par \pard\plain \fs20\lang1033 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab The return value specifies whether or not the asynchronous operation was successfully initiated.  Note that it does {\ul not} imply success or failure of the operation itself.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s14\li1440 \fs20\lang1033 If the operation was successfully initiated, {\b WSAAsyncGetProtoByName()}
 returns a nonzero value of type HANDLE which is the asynchronous task handle for the request.  This value can be used in two ways.  It can be used to cancel the operation using {\b WSACancelAsyncRequest()}
.  It can also be used to match up asynchronous operations and completion messages, by examining the {\i wParam} message argument.
\par \pard \s14\li1440 
\par \pard\plain \s12\li1440 \fs20\lang1033 If the asynchronous operation could not be initiated, {\b WSAAsyncGetProtoByName()} returns a zero value, and a specific error number may be retrieved by calling {\b WSAGetLastError()}.
\par \pard \s12\li1440 
\par \pard\plain \s26\fi-1440\li1440 \fs20\lang1033 {\b\f2 Comments}\tab The buffer supplied to this function is used by the Windows Sockets implementation to construct a protoent structure together with the contents of data areas referenced by 
members of the same protoent structure.  To avoid the WSAENOBUFS error noted above, the application should provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in {\b winsock.h}).
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 {\b\f2 Notes For
\par }{\b\f2 Windows Sockets
\par }\pard \s22\fi-1440\li1440 {\b\f2 Suppliers}\tab It is the responsibility of the Windows Sockets implementation to ensure that messages are successfully posted to the application.  If a {\b PostMessage()}
 operation fails, the Windows Sockets implementation {\ul must} re-post that message{\revised  as long as the window exists}.
\par \pard\plain \s23\li1440 \fs20\lang1033 
\par \pard \s23\li1440 Windows Sockets suppliers should use the WSAMAKEASYNCREPLY macro when constructing the {\i lParam} in the message.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 {\b\f2 Error Codes}\tab The following error codes may be set when an application window receives a message.  As described above, they may be extracted from the {\i lParam}
 in the reply message using the WSAGETASYNCERROR macro.
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAENOBUFS\tab No/insufficient buffer space is available
\par 
\par WSAHOST_NOT_FOUND\tab Authoritative Answer Host not found.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSATRY_AGAIN\tab Non-Authoritative Host not found, or SERVERFAIL.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSANO_RECOVERY\tab Non recoverable errors, FORMERR, REFUSED, NOTIMP.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSANO_DATA\tab Valid name, no data record of requested type.
\par 
\par \pard\plain \s23\li1440 \fs20\lang1033 The following errors may occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEWOULDBLOCK\tab The asynchronous operation cannot be scheduled at this time due to resource or other constraints within the Windows Sockets implementation.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b getprotobyname()}, {\b WSACancelAsyncRequest()}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 WSAAsyncGetProtoByNumber {\field{\*\fldinst PAGE}{\fldrslt 83}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart WSAAsyncGetProtoByNu}4.3.4{\*\bkmkend WSAAsyncGetProtoByNu} {\*\bkmkstart WSAGetProtoByNumber}{\*\bkmkend WSAGetProtoByNumber}WSAAsyncGetProtoByNumber()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Get protocol information corresponding to a protocol number - asynchronous version.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b HANDLE }{\b\revised PASCAL FAR }{\b WSAAsyncGetProtoByNumber ( HWND} {\i hWnd}{\b , }{\b\revised 
\par }{\b\revised \tab }{\b unsig}{\b ned int} {\i wMsg}{\b ,  int} {\i number}{\b , char FAR *} {\i buf}{\b , int} {\i buflen }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i hWnd}\tab The handle of the window which should receive a message when the asynchronous request completes.
\par \pard \s10\fi-1440\li2880 
\par {\i wMsg}\tab The message to be received when the asynchronous request completes.
\par 
\par {\i number}\tab The protocol number to be resolved, in host byte order.
\par 
\par \pard \s10\fi-1440\li2880 {\i buf}\tab A pointer to the data area to receive the protoent data.  Note that this must be larger than the size of a protoent structure.  This is because the data area supplied is used by the Windows Sockets i
mplementation to contain not only a protoent structure but any and all of the data which is referenced by members of the protoent structure.  It is recommended that you supply a buffer of MAXGETHOSTSTRUCT bytes.
\par \pard \s10\fi-1440\li2880 
\par {\i buflen}\tab The size of data area {\i buf} above.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This function is an asynchronous version of {\b getprotobynumber()}
, and is used to retrieve the protocol name and number corresponding to a protocol number.  The Windows Sockets implementation initiates the operation and returns to the caller immediately, passing back an {\ul asynchronous task handle}
 which the application may use to identify the operation.  When the operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 When the asynchronous operation is complete the application's window {\i hWnd} receives message {\i wMsg}.  The {\i wParam}
 argument contains the asynchronous task handle as returned by the original function call.  The high 16 bits of {\i lParam} contain any error code.  The error code may be any error as defined in {\b winsock.h}
.  An error code of zero indicates successful completion of the asynchronous operation.  On successful completion, the buffer supplied to the original function call contains a protoent structure.  To access the elements of this structure, the original buf
fer address should be cast to a protoent structure pointer and accessed as appropriate.
\par \pard \s12\li1440 
\par \pard \s12\li1440 Note that if the error code is WSAENOBUFS, it indicates that the size of the buffer specified by {\i buflen} in the original call was too small to contain all the resultant information.  In this case, the low 16 bits of {\i lParam}
 contain the size of buffer required to supply ALL the requisite information.  If the application decides that the partial data is inadequate, it may reissue the {\b WSAAsyncGetProtoByNumber() }
function call with a buffer large enough to receive all the desired  information (i.e. no smaller than the low 16 bits of {\i lParam}).
\par \pard \s12\li1440 
\par \pard \s12\li1440 The error code and buffer length should be extracted from the {\i lParam} using the macros  WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in {\b winsock.h} as:
\par \pard \s12\li1440 
\par \pard\plain \s32\fi-1440\li2880 \f5\fs20\lang1033 #define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
\par #define WSAGETASYNCBUFLEN(lParam)           LOWORD(lParam)
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 The use of these macros will maximize the portability of the source code for the application.  
\par \pard\plain \fs20\lang1033 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab The return value specifies whether or not the asynchronous operation was successfully initiated.  Note that it does {\ul not} imply success or failure of the operation itself.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s14\li1440 \fs20\lang1033 If the operation was successfully initiated, {\b WSAAsyncGetProtoByNumber()}
 returns a nonzero value of type HANDLE which is the asynchronous task handle for the request.  This value can be used in two ways.  It can be used to cancel the operation using {\b WSACancelAsyncRequest()}
.  It can also be used to match up asynchronous operations and completion messages, by examining the {\i wParam} message argument.
\par \pard \s14\li1440 
\par \pard\plain \s12\li1440 \fs20\lang1033 If the asynchronous operation could not be initiated, {\b WSAAsyncGetProtoByNumber()} returns a zero value, and a specific error number may be retrieved by calling {\b WSAGetLastError()}.
\par \pard \s12\li1440 
\par \pard\plain \s26\fi-1440\li1440 \fs20\lang1033 {\b\f2 Comments}\tab 
The buffer supplied to this function is used by the Windows Sockets implementation to construct a protoent structure together with the contents of data areas referenced by members of the same protoent structure.  To avoid the WSAENOBUFS error noted above
, the application should provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in {\b winsock.h}).
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 {\b\f2 Notes For
\par }{\b\f2 Windows Sockets
\par }\pard \s22\fi-1440\li1440 {\b\f2 Suppliers}\tab It is the responsibility of the Windows Sockets implementation to ensure that messages are successfully posted to the application.  If a {\b PostMessage()}
 operation fails, the Windows Sockets implementation {\ul must} re-post that message{\revised  as long as the window exists}.
\par \pard\plain \s23\li1440 \fs20\lang1033 
\par \pard \s23\li1440 Windows Sockets suppliers should use the WSAMAKEASYNCREPLY macro when constructing the {\i lParam} in the message.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 {\b\f2 Error Codes}\tab The following error codes may be set when an application window receives a message.  As described above, they may be extracted from the {\i lParam}
 in the reply message using the WSAGETASYNCERROR macro.
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAENOBUFS\tab No/insufficient buffer space is available
\par 
\par WSAHOST_NOT_FOUND\tab Authoritative Answer Host not found.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSATRY_AGAIN\tab Non-Authoritative Host not found, or SERVERFAIL.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSANO_RECOVERY\tab Non recoverable errors, FORMERR, REFUSED, NOTIMP.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSANO_DATA\tab Valid name, no data record of requested type.
\par 
\par \pard\plain \s23\li1440 \fs20\lang1033 The following errors may occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEWOULDBLOCK\tab The asynchronous operation cannot be scheduled at this time due to resource or other constraints within the Windows Sockets implementation.
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b getprotobynumber()}, {\b WSACancelAsyncRequest()}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 WSAAsyncGetServByName {\field{\*\fldinst PAGE}{\fldrslt 85}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart WSAAsyncGetServByNam}4.3.5{\*\bkmkend WSAAsyncGetServByNam} {\*\bkmkstart WSAGetServByName}{\*\bkmkend WSAGetServByName}WSAAsyncGetServByName()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Get service information corresponding to a service name and port - asynchronous version.
\par \pard \s3\fi-1440\li1440 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b HANDLE }{\b\revised PASCAL FAR }{\b WSAAsyncGetServByName ( HWND} {\i hWnd}{\b , }{\b\revised 
\par }\pard \s4\fi-1440\li1440 {\b\revised \tab }{\b unsigned int} {\i wMsg}{\b ,  }{\b\revised const }{\b char FAR *} {\i name}{\b , }{\b\revised const }{\b char FAR * }{\i proto}{\b , char FAR *} {\i buf}{\b , }{\b\revised  }{\b int} {\i buflen }{\b );}

\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i hWnd}\tab The handle of the window which should receive a message when the asynchronous request completes.
\par \pard \s10\fi-1440\li2880 
\par {\i wMsg}\tab The message to be received when the asynchronous request completes.
\par 
\par {\i name}\tab A pointer to a service name.
\par 
\par \pard \s10\fi-1440\li2880 {\i proto}\tab A pointer to a protocol name.  This may be NULL, in which case {\b WSAAsyncGetServByName()} will search for the first service entry for which {\i s_name} or one of the {\i s_aliases} matches the given {\i name}
.  Otherwise {\b WSAAsyncGetServByName()} matches both {\i name} and {\i proto}.
\par \pard \s10\fi-1440\li2880 
\par \pard \s10\fi-1440\li2880 {\i buf}\tab A pointer to the data area to receive the servent data.  Note that this must be larger than the size of a servent structure.  This is because the data area supplied is used by the Windows Sockets implementation to
 contain not only a servent structure but any and all of the data which is referenced by members of the servent structure.  It is recommended that you supply a buffer of MAXGETHOSTSTRUCT bytes.
\par \pard \s10\fi-1440\li2880 
\par {\i buflen}\tab The size of data area {\i buf} above.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This function is an asynchronous version of {\b getservbyname()}
, and is used to retrieve service information corresponding to a service name.  The Windows Sockets implementation initiates the operation and returns to the caller immediately, passing back an {\ul asynchronou}{\ul s task handle}
 which the application may use to identify the operation.  When the operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 When the asynchronous operation is complete the application's window {\i hWnd} receives message {\i wMsg}.  The {\i wParam}
 argument contains the asynchronous task handle as returned by the original function call.  The high 16 bits of {\i lParam} contain any error code.  The error code may be any error as defined in {\b winsock.h}
.  An error code of zero indicates successful completion of the asynchronous operation.  On successful completion, the buffer supplied to the original function call contains a hostent structure.  To access the elements of this structure, the original buff
er address should be cast to a hostent structure pointer and accessed as appropriate.
\par \pard \s12\li1440 
\par \pard \s12\li1440 Note that if the error code is WSAENOBUFS, it indicates that the size of the buffer specified by {\i buflen} in the original call was too small to contain all the resultant information.  In this case, the low 16 bits of {\i lParam}
 contain the size of buffer required to supply ALL the requisite information.  If the application decides that the partial data is inadequate, it may reissue the {\b WSAAsyncGetServBy}{\b\revised Name}{\b () }
function call with a buffer large enough to receive all the desired  information (i.e. no smaller than the low 16 bits of {\i lParam}).
\par \pard \s12\li1440 
\par \pard \s12\li1440 The error code and buffer length should be extracted from the {\i lParam} using the macros  WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in {\b winsock.h} as:
\par \pard \s12\li1440 
\par \pard\plain \s32\fi-1440\li2880 \f5\fs20\lang1033 #define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
\par #define WSAGETASYNCBUFLEN(lParam)           LOWORD(lParam)
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 The use of these macros will maximize the portability of the source code for the application.  
\par \pard\plain \fs20\lang1033 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab The return value specifies whether or not the asynchronous operation was successfully initiated.  Note that it does {\ul not} imply success or failure of the operation itself.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s14\li1440 \fs20\lang1033 If the operation was successfully initiated, {\b WSAAsyncGet}{\b\revised Serv}{\b By}{\b\revised Name}{\b ()}
 returns a nonzero value of type HANDLE which is the asynchronous task handle for the request.  This value can be used in two ways.  It can be used to cancel the operation using {\b WSACancelAsyncRequest()}
.  It can also be used to match up asynchronous operations and completion messages, by examining the {\i wParam} message argument.
\par \pard \s14\li1440 
\par \pard\plain \s12\li1440 \fs20\lang1033 If the asynchronous operation could not be initiated, {\b WSAAsync}{\b\revised Serv}{\b By}{\b\revised Name}{\b ()} returns a zero value, and a specific error number may be retrieved by calling {\b WSAGetLastError()}
.
\par \pard \s12\li1440 
\par \pard\plain \s26\fi-1440\li1440 \fs20\lang1033 {\b\f2 C}{\b\f2 omments}\tab 
The buffer supplied to this function is used by the Windows Sockets implementation to construct a hostent structure together with the contents of data areas referenced by members of the same hostent structure.  To avoid the WSAENOBUFS error noted above, 
the application should provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in {\b winsock.h}).
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 {\b\f2 Notes For
\par }{\b\f2 Windows Sockets
\par }\pard \s22\fi-1440\li1440 {\b\f2 Suppliers}\tab It is the responsibility of the Windows Sockets implementation to ensure that messages are successfully posted to the application.  If a {\b PostMessage()}
 operation fails, the Windows Sockets implementation {\ul must} re-post that message{\revised  as long as the window exists}.
\par \pard\plain \s23\li1440 \fs20\lang1033 
\par \pard \s23\li1440 Windows Sockets suppliers should use the WSAMAKEASYNCREPLY macro when constructing the {\i lParam} in the message.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 {\b\f2 Error Codes}\tab The following error codes may be set when an application window receives a message.  As described above, they may be extracted from the {\i lParam}
 in the reply message using the WSAGETASYNCERROR macro.
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAENOBUFS\tab No/insufficient buffer space is available
\par 
\par WSAHOST_NOT_FOUND\tab Authoritative Answer Host not found.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSATRY_AGAIN\tab Non-Authoritative Host not found, or SERVERFAIL.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSANO_RECOVERY\tab Non recoverable errors, FORMERR, REFUSED, NOTIMP.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSANO_DATA\tab Valid name, no data record of requested type.
\par 
\par \pard\plain \s23\li1440 \fs20\lang1033 The following errors may occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEWOULDBLOCK\tab The asynchronous operation cannot be scheduled at this time due to resource or other constraints within the Windows Sockets implementation.
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 
\par \pard \s9\fi-1440\li1440 {\b\f2 See Also}\tab {\b getservbyname()}, {\b WSACancelAsyncRequest()}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 WSAAsyncGetServByPort {\field{\*\fldinst PAGE}{\fldrslt 89}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart WSAAsyncGetServByPor}4.3.6{\*\bkmkend WSAAsyncGetServByPor} {\*\bkmkstart WSAGetServByPort}{\*\bkmkend WSAGetServByPort}WSAAsyncGetServByPort()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Get service information corresponding to a port and protocol - asynchronous version.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b HANDLE }{\b\revised PASCAL FAR }{\b WSAAsyncGetServByPort ( HWND} {\i hWnd}{\b , }{\b\revised 
\par }{\b\revised \tab }{\b unsigned int} {\i wMsg}{\b ,  int} {\i port}{\b , const char FAR * }{\i proto}{\b , char FAR *} {\i buf}{\b , int} {\i buflen }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i hWnd}\tab The handle of the window which should receive a message when the asynchronous request completes.
\par \pard \s10\fi-1440\li2880 
\par {\i wMsg}\tab The message to be received when the asynchronous request completes.
\par 
\par {\i port}\tab The port for the service, in network byte order.
\par 
\par \pard \s10\fi-1440\li2880 {\i proto}\tab A pointer to a protocol name.  This may be NULL, in which case {\b WSAAsyncGetServByPort()} will search for the first service entry for which {\i s_port} match the given {\i port}.  Otherwise {\b 
WSAAsyncGetServByPort()} matches both {\i port} and {\i proto}.
\par \pard \s10\fi-1440\li2880 
\par \pard \s10\fi-1440\li2880 {\i buf}\tab 
A pointer to the data area to receive the servent data.  Note that this must be larger than the size of a servent structure.  This is because the data area supplied is used by the Windows Sockets implementation to contain not only a servent structure but
 any and all of the data which is referenced by members of the servent structure.  It is recommended that you supply a buffer of MAXGETHOSTSTRUCT bytes.
\par \pard \s10\fi-1440\li2880 
\par {\i buflen}\tab The size of data area {\i buf} above.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This function is an asynchronous version of {\b getservbyport()}
, and is used to retrieve service information corresponding to a port number.  The Windows Sockets implementation initiates the operation and returns to the caller immediately, passing back an {\ul asynchronous task handle}
 which the application may use to identify the operation.  When the operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 When the asynchronous operation is complete the application's window {\i hWnd} receives message {\i wMsg}.  The {\i wParam}
 argument contains the asynchronous task handle as returned by the original function call.  The high 16 bits of {\i lParam} contain any error code.  The error code may be any error as defined in {\b winsock.h}
.  An error code of zero indicates successful comp
letion of the asynchronous operation.  On successful completion, the buffer supplied to the original function call contains a servent structure.  To access the elements of this structure, the original buffer address should be cast to a servent structure p
ointer and accessed as appropriate.
\par \pard \s12\li1440 
\par \pard \s12\li1440 Note that if the error code is WSAENOBUFS, it indicates that the size of the buffer specified by {\i buflen} in the original call was too small to contain all the resultant information.  In this case, the low 16 bits of {\i lPa}{\i ram}
 contain the size of buffer required to supply ALL the requisite information.  If the application decides that the partial data is inadequate, it may reissue the {\b WSAAsyncGetServByPort() }
function call with a buffer large enough to receive all the desired  information (i.e. no smaller than the low 16 bits of {\i lParam}).
\par \pard \s12\li1440 
\par \pard \s12\li1440 The error code and buffer length should be extracted from the {\i lParam} using the macros  WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in {\b winsock.h} as:
\par \pard \s12\li1440 
\par \pard\plain \s32\fi-1440\li2880 \f5\fs20\lang1033 #define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
\par #define WSAGETASYNCBUFLEN(lParam)           LOWORD(lParam)
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 The use of these macros will maximize the portability of the source code for the application.  
\par \pard\plain \fs20\lang1033 
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab The return value specifies whether or not the asynchronous operation was successfully initiated.  Note that it does {\ul not} imply success or failure of the operation itself.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s14\li1440 \fs20\lang1033 If the operation was successfully initiated, {\b WSAAsyncGetServByPort()} returns a nonzero value of type HANDLE which is the asynchronous tas
k handle for the request.  This value can be used in two ways.  It can be used to cancel the operation using {\b WSACancelAsyncRequest()}.  It can also be used to match up asynchronous operations and completion messages, by examining the {\i wParam}
 message argument.
\par \pard \s14\li1440 
\par \pard\plain \s12\li1440 \fs20\lang1033 If the asynchronous operation could not be initiated, {\b WSAAsyncGetServByPort()} returns a zero value, and a specific error number may be retrieved by calling {\b WSAGetLastError()}.
\par \pard \s12\li1440 
\par \pard\plain \s26\fi-1440\li1440 \fs20\lang1033 {\b\f2 Comments}\tab The buffer supplied to this function is used by the Windows Sock
ets implementation to construct a servent structure together with the contents of data areas referenced by members of the same servent structure.  To avoid the WSAENOBUFS error noted above, the application should provide a buffer of at least MAXGETHOSTSTR
UCT bytes (as defined in {\b winsock.h}).
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 {\b\f2 Notes For
\par }{\b\f2 Windows Sockets
\par }\pard \s22\fi-1440\li1440 {\b\f2 Suppliers}\tab It is the responsibility of the Windows Sockets implementation to ensure that messages are successfully posted to the application.  If a {\b PostMessage()} operation fails, the Windows
 Sockets implementation {\ul must} re-post that message{\revised  as long as the window exists}.
\par \pard\plain \s23\li1440 \fs20\lang1033 
\par \pard \s23\li1440 Windows Sockets suppliers should use the WSAMAKEASYNCREPLY macro when constructing the {\i lParam} in the message.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 {\b\f2 Error Codes}\tab The following error codes may be set when an application window receives a message.  As described above, they may be extracted from the {\i lParam}
 in the reply message using the WSAGETASYNCERROR macro.
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAENOBUFS\tab No/insufficient buffer space is available
\par 
\par WSAHOST_NOT_FOUND\tab Authoritative Answer Host not found.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSATRY_AGAIN\tab Non-Authoritative Host not found, or SERVERFAIL.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSANO_RECOVERY\tab Non recoverable errors, FORMERR, REFUSED, NOTIMP.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSANO_DATA\tab Valid name, no data record of requested type.
\par 
\par \pard\plain \s23\li1440 \fs20\lang1033 The following errors may occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEWOULDBLOCK\tab The asynchronous operation cannot be scheduled at this time due to resource or other constraints within the Windows Sockets implementation.
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b getservbyport()}, {\b WSACancelAsyncRequest()}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 WSAAsyncSelect {\field{\*\fldinst PAGE}{\fldrslt 95}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart WSAAsyncSelect}4.3.7{\*\bkmkend WSAAsyncSelect} {\*\bkmkstart WSASelectWindow}{\*\bkmkend WSASelectWindow}WSAAsyncSelect()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Request event notification for a socket.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int PASCAL }{\b\revised F}{\b\revised AR }{\b WSAAsyncSelect ( SOCKET} {\i s}{\b , HWND} {\i hWnd}{\b , }{\b\revised 
\par }{\b\revised \tab }{\b unsigned int} {\i wMsg}{\b ,  long} {\i lEvent }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i s}\tab A descriptor identifying the socket for which event notification is required.
\par \pard \s10\fi-1440\li2880 
\par \pard \s10\fi-1440\li2880 {\i hWnd}\tab A handle identifying the window which should receive a message when a network event occurs.
\par \pard \s10\fi-1440\li2880 
\par {\i wMsg}\tab The message to be received when a network event occurs.
\par 
\par \pard \s10\fi-1440\li2880 {\i lEvent}\tab A bitmask which specifies a combination of network events in which the application is interested.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This function is used to request that the Windows Sockets DLL should send a message to the window {\i hWnd} whenever it detects any of the network events specified by the {\i lEvent}
 parameter.  The message which should be sent is specified by the {\i wMsg} parameter.  The socket for which notification is required is identified by {\i s}.
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par {\revised This function automatically sets socket }{\i\revised s}{\revised  to non-blocking mode.
\par }\pard\plain \fi-1440\li2880 \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 The {\i lEvent} parameter is constructed by or'ing any of the values specified in the following list.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s20\fi-1440\li3600 \fs20\ul\lang1033 Value\tab Meaning
\par \pard\plain \s21\fi-1440\li3600 \fs20\lang1033 FD_READ\tab Want to receive notification of readiness for reading
\par FD_WRITE\tab Want to receive notification of readiness for writing
\par FD_OOB\tab Want to receive notification of the arrival of out-of-band data
\par FD_ACCEPT\tab Want to receive notification of incoming connections
\par FD_CONNECT\tab Want to receive notification of completed connection
\par FD_CLOSE\tab Want to receive notification of socket closure
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 Issuing a {\b WSAAsyncSelect()} for a socket cancels any previous {\b WSAAsyncSelect()} for the same socket.  For example, to receive notification for both reading and writing, the application must call {\b WSA}{\b 
AsyncSelect()} with both FD_READ and FD_WRITE, as follows:
\par \pard \s12\li1440 
\par \pard\plain \s32\fi-1440\li2880 \f5\fs20\lang1033 rc = WSAAsyncSelect(s, hWnd, wMsg, FD_READ|FD_WRITE);
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 It is not possible to specify different messages for different events.  The following code will {\ul not} work; the second call will cancel the effects of the first, and only FD_WRITE events will be reported with message wMsg2:
\par \pard \s12\li1440 
\par \pard\plain \s32\fi-1440\li2880 \f5\fs20\lang1033 rc = WSAAsyncSelect(s, hWnd, wMsg1, FD_READ);
\par rc = WSAAsyncSelect(s, hWnd, wMsg2, FD_WRITE);
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 To cancel all notification {\f1 -} i.e., to indicate that the Windows Sockets implementation should send no further messages related to network events on the socket {\f1 -} {\i lEvent} should be set to zero.  
\par \pard \s12\li1440 
\par \pard\plain \s32\fi-1440\li2880 \f5\fs20\lang1033 rc = WSAAsyncSelect(s, hWnd, 0, 0);
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 Although in this instance {\b WSAAsyncSelect()} immediately{\revised  disables event message posting for the socket}
, it is possible that messages may be waiting in the application's message queue.  The application must therefore be prepared to receive network event messages even after cancellation.  {\revised Closing a socket with }{\b\revised closesocket() }{
\revised also cancels  }{\b WSAAsyncSelec}{\b t()}{\revised  message sending, but the same caveat about messages in the queue prior to the }{\b\revised closesocket() }{\revised still applies.}
\par \pard \s12\li1440 
\par \pard \s12\li1440 {\revised Since an }{\b\revised accept()'}{\revised ed socket has the same properties as the listening socket used to accept it, any }{\b\revised WSAAsyncSelect() }{\revised 
events set for the listening socket apply to the accepted socket.  For example, if a listening socket has }{\b\revised WSAAsyncSelect() }{\revised 
events FD_ACCEPT, FD_READ, and FD_WRITE, then any socket accepted on that listening socket will also have FD_ACCEPT, FD_READ, and FD_WRITE events with the same}{\revised  }{\i\revised wMsg}{\revised  value used for messages.  If a different }{\i\revised 
wMsg}{\revised  or events are desired, the application should call }{\b\revised WSAAsyncSelect()}{\revised , passing the accepted socket and the desired new information.}{\fs16\up6 \chftn {\footnote \pard\plain \s245 \fs20\lang1033 {\fs16\up6 \chftn }
Note that there is a timing window between the {\b accept() }call and the call to {\b WSAAsyncSelect() }to change the events or {\i wMsg}.  An application which desires a different {\i wMsg} for the listening and {\b accept()}
'ed sockets should ask for only FD_ACCEPT events on the listening socket, then set appropriate events after the {\b accept()}
.  Since FD_ACCEPT is never sent for a connected socket and FD_READ, FD_WRITE, FD_OOB, and FD_CLOSE are never sent for listening sockets, this will not impose difficulties.}}
\par \pard \s12\li1440 
\par \pard \s12\li1440 When one of the nominated network events occurs on the specified socket {\i s}, the application's window {\i hWnd} receives message {\i wMsg}.  The {\i wParam}
 argument identifies the socket on which a network event has occurred.  The low word of {\i lParam} specifies the network event that has occurred.  The high word of {\i lParam} contains any error code.  The error code be any error as defined in {\b 
winsock.h}.
\par \pard \s12\li1440 
\par \pard \s12\li1440 The error and event codes may be extracted from the {\i lParam} using the macros WSAGETSELECTERROR and WSAGETSELECTEVENT, defined in {\b winsock.h} as:
\par \pard \s12\li1440 
\par \pard\plain \s32\fi-1440\li2880 \f5\fs20\lang1033 #define WSAGETSELECTERROR(lParam)            HIWORD(lParam)
\par #define WSAGETSELECTEVENT(lParam)            LOWORD(lParam)
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 The use of these macros will maximize the portability of the source code for the application.  
\par \pard \s12\li1440 
\par The possible network event codes which may be returned are as follows:
\par 
\par \pard\plain \s20\fi-1440\li3600 \fs20\ul\lang1033 Value\tab Meaning
\par \pard\plain \s21\fi-1440\li3600 \fs20\lang1033 FD_READ\tab Socket {\i s} ready for reading
\par FD_WRITE\tab Socket {\i s} ready for writing
\par FD_OOB\tab Out-of-band data ready for reading on socket {\i s}.
\par FD_ACCEPT\tab Socket {\i s} ready for accepting a new incoming connection
\par FD_CONNECT\tab Connection on socket {\i s} completed
\par FD_CLOSE\tab Connection identified by socket {\i s} has been closed
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab 
The return value is 0 if the application's declaration of interest in the network event set was successful.  Otherwise the value SOCKET_ERROR is returned, and a specific error number may be retrieved by calling {\b WSAGetLastError()}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Comments}\tab Although {\b WSAAsyncSelect()} can be called with interest in multiple events, the application window will receive a single message for each network event.
\par \pard\plain \li1440 \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 As in the case of the {\b select()} function, {\b WSAAsyncSelect()} will frequently be used to determine when a data transfer operation ({\b send()} or {\b recv()}
) can be issued with the expectation of immediate success.  Nevertheless, a robust application must be prepared for the possibility that it may receive a message
 and issue a Windows Sockets API call which returns WSAEWOULDBLOCK immediately.  For example, the following sequence of events is possible:
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 
\par \pard \s10\fi-1440\li2880 (i)\tab data arrives on socket {\b s}; Windows Sockets posts {\b WSAAsyncSelect} message
\par \pard \s10\fi-1440\li2880 (ii)\tab application processes some other message
\par \pard \s10\fi-1440\li2880 (iii)\tab while processing, application issues an {\b ioctlsocket(s, FIONREAD...)} and notices that there is data ready to be read
\par \pard \s10\fi-1440\li2880 (iv)\tab application issues a {\b recv(s,...)} to read the data
\par \pard \s10\fi-1440\li2880 (v)\tab application  loops to process next message, eventually reaching the {\b WSAAsyncSelect} message indicating that data is ready to read
\par (vi)\tab application issues {\b recv(s,...)}, which fails with the error WSAEWOULDBLOCK.
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par Other sequences are possible.  
\par 
\par \pard\plain \s23\li1440 \fs20\lang1033 
The Windows Sockets DLL will not continually flood an application with messages for a particular network event.  Having successfully posted notification of a particular event to an application window, no further message(s) for that network event will be p
osted to the application window until the application makes the function call which implicitly reenables notification of that network event.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s24\fi-2160\li3600 \fs20\ul\lang1033 Event\tab Re-enabling function
\par \pard\plain \s25\fi-2160\li3600\tx4320 \fs20\lang1033 FD_READ\tab {\b recv()} or {\b recvfrom()}
\par FD_WRITE\tab {\b send()} or {\b sendto()}
\par FD_OOB\tab {\b recv()}
\par FD_ACCEPT\tab {\b accept()}
\par FD_CONNECT\tab NONE
\par FD_CLOSE\tab NONE
\par 
\par \pard\plain \s12\li1440 \fs20\lang1033 {\revised Any call to the reenabling routine, even one which fails, results in reenabling of message posting for the relevant event.
\par }\pard \s12\li1440 {\revised 
\par }\pard \s12\li1440 {\revised For FD_READ, FD_OOB, and FD_ACCEPT events, message posting is "level-triggered."  This means that if the reenabling routine is called and the relevant event i}{\revised s still valid after the call, a }{\b\revised 
WSAAsyncSelect() }{\revised message is posted to the application.  This allows an application to be event-driven and not concern itself with the amount of data that arrives at any one time.  Consider the following sequence:
\par }\pard \s12\li1440 {\revised 
\par }\pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\revised (i)\tab Windows Sockets DLL receives 100 bytes of data on socket }{\b\revised s }{\revised and posts an FD_READ message.
\par }\pard \s10\fi-1440\li2880 {\revised (ii)\tab The application issues }{\b\revised recv( s, buffptr, 50, 0)}{\revised  to read 50 bytes.
\par }\pard \s10\fi-1440\li2880 {\revised (iii)\tab The Windows Sockets DLL posts another FD_READ message since there is still data to be read.}{\revised 
\par }\pard \s10\fi-1440\li2880 {\revised 
\par }\pard\plain \s12\li1440 \fs20\lang1033 {\revised With these semantics, an application need not read all available data in response to an FD_READ message--a single }{\b\revised recv() }{\revised 
in response to each FD_READ message is appropriate.  If an application issues multiple }{\b\revised recv() }{\revised 
calls in response to a single FD_READ, it may receive multiple FD_READ messages.  Such an application may wish to disable FD_READ messages before starting the }{\b\revised recv() }{\revised calls by calling }{\b\revised WSAAsyncSelect() }{\revised 
with the FD_READ event not set.
\par }\pard \s12\li1440 {\revised 
\par }\pard \s12\li1440 {\revised If an event is true when the application initially calls }{\b\revised WS}{\b\revised AAsyncSelect()}{\revised 
 or when the reenabling function is called, then a message is posted as appropriate.  For example, if an application calls }{\b\revised listen()}{\revised , a connect attempt is made, then the application calls }{\b\revised WSAAsyncSelect() }{\revised 
specifying that it wants to receive FD_ACCEPT messages for the socket, the Windows Sockets implementation posts an FD_ACCEPT message immediately.
\par }\pard \s12\li1440 {\deleted 
\par }\pard \s12\li1440 {\revised The FD_WRITE event is handled slightly differently.  An FD_WRITE message is posted when a socket is first connected with }{\b\revised connect() }{\revised or accepted wi}{\revised th }{\b\revised accept()}{\revised 
, and then after a }{\b\revised send() }{\revised or }{\b\revised sendto() }{\revised 
fails with WSAEWOULDBLOCK and buffer space becomes available.  Therefore, an application can assume that sends are possible starting from the first FD_WRITE message and lasting until a send returns WSAEWOULDBLOCK.  After such a failure the application wil
}{\revised l be notified that sends are again possible with an FD_WRITE message.}
\par \pard \s12\li1440 
\par \pard\plain \li1440 \fs20\lang1033 The FD_OOB event is used only when a socket is configured to receive out-of-band data separately.  If the socket is configured to recei
ve out-of-band data in-line, the out-of-band (expedited) data is treated as normal data and the application should register an interest in, and will  receive, FD_READ events, {\ul not}
 FD_OOB events.  An application may set or inspect the way in which out-of-band data is to be handled by using {\b setsockopt()} or {\b getsockopt()} for the SO_OOBINLINE option.
\par \pard \li1440 
\par \pard \li1440 {\revised The error code in an FD_CLOSE message indicates whether the socket close was graceful or abortive.  If the error code is 0, then the close was graceful; if the er}{\revised 
ror code is WSAECONNRESET, then the socket's virtual socket was reset.  This only applies to sockets of type SOCK_STREAM.  
\par }\pard \li1440 {\revised 
\par }\pard \li1440 {\revised 
The FD_CLOSE message is posted when a close indication is received for the virtual circuit corresponding to the socket.  In TCP terms, this means that the FD_CLOSE is posted when the connection goes into the FIN WAIT or CLOSE WAIT states.  This results fr
}{\revised om the remote end performing a }{\b\revised shutdown() }{\revised on the send side or a }{\b\revised closesocket().
\par }\pard \li1440 {\b\revised 
\par }\pard \li1440 {\revised Please note your application will receive ONLY a}{\revised n FD_CLOSE message to indicate closure of a virtual circuit. It will NOT receive an FD_READ message to indicate this condition.}
\par \pard 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINVAL\tab Indicates that one of the specified parameters was invalid
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s28\li1440 \fs20\lang1033 Additional error codes may be set when an application window receives a message.  This error code is extracted from the {\i lParam}
 in the reply message using the WSAGETSELECTERROR macro.  Possible error codes for each network event are:
\par \pard\plain \li1440 \fs20\lang1033 {\b Event: FD_CONNECT
\par }\pard\plain \s27\fi-2160\li3600\tx4320\tx5760 \fs20\ul\lang1033 Error Code\tab \tab Meaning
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 WSAEADDRINUSE\tab The specified address is already in use.
\par \pard\plain \s27\fi-2160\li3600\tx4140\tx5760 \fs20\ul\lang1033 
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 WSAEADDRNOTAVAIL\tab The specified address is not available from the local machine.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEAFNOSUPPORT\tab Addresses in the specified family cannot be used with this socket.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAECONNREFUSED\tab The attempt to connect was forcefully rejected.
\par 
\par WSAEDESTADDRREQ\tab A destination address is required.
\par 
\par WSAEFAULT\tab The namelen argument is incorrect.
\par 
\par WSAEINVAL\tab The socket is already bound to an address.
\par 
\par WSAEISCONN\tab The socket is already connected.
\par 
\par WSAEMFILE\tab No more file descriptors are available.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETUNREACH\tab The network can't be reached from this host at this time.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENOBUFS\tab No buffer space is available.  The socket cannot be connected.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par WSAENOTCONN\tab The socket is not connected.
\par 
\par WSAENOTSOCK\tab The descriptor is a file, not a socket.
\par 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAETIMEDOUT\tab Attempt to connect timed out without establishing a connection
\par \pard\plain \fs20\lang1033 
\par \pard \li1440 {\b Event: FD_CLOSE}{\b\revised 
\par }\pard\plain \s27\fi-2160\li3600\tx4320\tx5760 \fs20\ul\lang1033 {\revised Error Code\tab \tab Meaning
\par }\pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 {\revised WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\revised 
\par }{\revised WSAECONNRESET\tab The connection was reset by the remote side.
\par }{\revised 
\par }\pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 {\revised WSAECONNABORTED\tab The connection was aborted due to timeout or other failure.}{\b\revised 
\par }\pard\plain \li1440 \fs20\lang1033 {\b 
\par }\pard \fi-1440\li2880\tx2880 {\b Event: FD_READ
\par }{\b Event: FD_WRITE
\par }{\b Event: FD_OOB
\par }{\b Event: FD_ACCEPT
\par }\pard\plain \s27\fi-2160\li3600\tx4320\tx5760 \fs20\ul\lang1033 Error Code\tab \tab Meaning
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 {\b\f2 Notes For
\par }{\b\f2 Windows Sockets
\par }\pard \s22\fi-1440\li1440 {\b\f2 Suppliers}\tab It is the responsibility of the Windows Sockets Supplier to ensure that messages are successfully posted to the application.  If a {\b PostMessage()}
 operation fails, the Windows Sockets implementation MUST re-post that message{\revised  as long as the window exists}.
\par \pard\plain \s23\li1440 \fs20\lang1033 
\par \pard \s23\li1440 Windows Sockets suppliers should use the WSAMAKESELECTREPLY macro when constructing the {\i lParam} in the message.
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 
\par \pard\plain \s23\li1440 \fs20\lang1033 When a socket is closed, the Windows Sockets Supplier sh
ould purge any messages remaining for posting to the application window.  However the application must be prepared to receive, and discard, any messages which may have been posted prior to the {\b closesocket()}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b select()}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 WSACancelAsyncRequest {\field{\*\fldinst PAGE}{\fldrslt 97}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart WSACancelAsyncReques}4.3.8{\*\bkmkend WSACancelAsyncReques} {\*\bkmkstart WSACancelGetXbyY}{\*\bkmkend WSACancelGetXbyY}WSACancelAsyncRequest()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Cancel an incomplete asynchronous operation.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int }{\b\revised PASCAL FAR }{\b WSACancelAsyncRequest ( HANDLE} {\i hAsyncTaskHandle }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i hAsyncTaskHandle}\tab Specifies the asynchronous operation to be canceled.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab The {\b WSACanc}{\b elAsyncRequest()} function is used to cancel an asynchronous operation which was initiated by one of the {\b WSAAsyncGetXByY()} functions such as {\b 
WSAAsyncGetHostByName()}.  The operation to be canceled is identified by the {\i hAsyncTaskHandle} parameter, which should be set to the asynchronous task handle as returned by the initiating function.
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab The value returned by {\b WSACancelAsyncRequest()} is 0 if the operation was successfully canceled.  Otherwise the value SOCKET_ERROR is returned, and a specific e
rror number may be retrieved by calling {\b WSAGetLastError()}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s26\fi-1440\li1440 \fs20\lang1033 {\b\f2 Comments}\tab An attempt to cancel an existing asynchronous {\b WSAAsyncGetXByY()}
 operation can fail with an error code of WSAEALREADY for two reasons.  First, the original operation has already completed and the application has dealt with the resultant message.  Second, the original operation has already completed but the resultant m
essage is still waiting in the application window queue.
\par \pard \s26\fi-1440\li1440 
\par {\b\f2 Notes For
\par }{\b\f2 Windows Sockets
\par }\pard \s26\fi-1440\li1440 {\b\f2 Suppliers}\tab It is unclear whether the
 application can usefully distinguish between WSAEINVAL and WSAEALREADY, since in both cases the error indicates that there is no asynchronous operation in progress with the indicated handle.  [Trivial exception: 0 is always an invalid asynchronous task h
andle.]  The Windows Sockets specification does not prescribe how a conformant Windows Sockets implementation should distinguish between the two cases.  For maximum portability, a Windows Sockets application should treat the two errors as equivalent.

\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Err}{\b\f2 or Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINVAL\tab Indicates that the specified asynchronous task handle was invalid
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEALREADY\tab The asynchronous routine being canceled has already completed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b WSAAsyncGetHostByAddr()}, {\b WSAAsyncGetHostByName()}, {\b WSAAsyncGetProtoByNumber()}, {\b WSA}{\b AsyncGetProtoByName()}, {\b WSAAsyncGetHostByName()}, {\b WSAAsyncGetServByPort()}
, {\b WSAAsyncGetServByName()}{\b\revised .}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 WSACancelBlockingCall {\field{\*\fldinst PAGE}{\fldrslt 99}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart WSACancelBlockingCal}4.3.9{\*\bkmkend WSACancelBlockingCal} WSACancelBlockingCall()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Cancel a blocking call which is currently in progress.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int }{\b\revised PASCAL FAR }{\b WSACancelBlockingCall ( void );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This function cancels any outstanding blocking operation for this task.  It is normally used in two situations:
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 (1) An application is processing a message which has been received while a blocking call is in progress.  In this case, {\b WSAIsBlocking()} will be true.
\par \pard \s12\li1440 
\par \pard \s12\li1440 (2) A blocking call is in progress, and Windows Sockets has called back to the application's "blocking hook" function (as established by {\b WSASetBlockingHook()}).
\par \pard \s12\li1440 
\par \pard \s12\li1440 
In each case, the original blocking call will terminate as soon as possible with the error WSAEINTR.  (In (1), the termination will not take place until Windows message scheduling has caused control to revert to the blocking routine in Windows Sockets.  I
n (2), the blocking call will be terminated as soon as the blocking hook function completes.)
\par \pard \s12\li1440 
\par \pard \s12\li1440 In the case of a blocking {\b connect()}
 operation, the Windows Sockets implementation will terminate the blocking call as soon as possible, but it may not be possible for the socket resources to be released until the connection has completed (and then been reset) or timed out.  This is likely 
to be noticeable only if the application immediately tries to open a new socket (if no sockets are available), or to {\b connect()} to the same peer.
\par \pard \s12\li1440 
\par \pard \s12\li1440 {\revised Cancelling an }{\b\revised accept() }{\revised or a }{\b\revised select() }{\revised 
call does not adversely impact the sockets passed to these calls.  Only the particular call fails; any operation that was legal before the cancel is legal after the cancel, and the state of the socket is not affected in any way.}
\par \pard \s12\li1440 
\par \pard \s12\li1440 {\revised Cancelling any operation other than }{\b\revised accept() }{\revised and }{\b\revised select() }{\revised 
can leave the socket in an indeterminate state.  If an application cancels a blocking operation on a socket, the only operation that the application can depend on being able to perform on the socket is a call to }{\b\revised c}{\b\revised losesocket()}{
\revised 
, although other operations may work on some Windows Sockets implementations.  If an application desires maximum portability, it must be careful not to depend on performing operations after a cancel.  An application may reset the connection by setting the
}{\revised  timeout on SO_LINGER to 0.
\par }\pard \s12\li1440 {\revised 
\par }\pard \s12\li1440 {\revised If a cancel operation compromised the integrity of a SOCK_STREAM's data stream in any way, the Windows Sockets implementation must reset the connection and fail all future operations other than }{\b\revised closesocket() }{
\revised with W}{\revised SAECONNABORTED.}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab The value returned by {\b WSACancelBlockingCall()}
 is 0 if the operation was successfully canceled.  Otherwise the value SOCKET_ERROR is returned, and a specific error number may be retrieved by calling {\b WSAGetLastError()}.
\par \pard \s7\fi-1440\li1440 
\par \pard\plain \s26\fi-1440\li1440 \fs20\lang1033 {\b\f2 Comments\tab }Note that it is possible that the network{\revised  operation completes before the }{\b\revised WSACancelBlockingCall()  }{\revised 
is processed, for example if data is received into the user buffer at interrupt time while the application is in a blocking hook.  In this case, the bloc}{\revised king operation will return successfully as if }{\b\revised WSACancelBlockingCall() }{
\revised had never been called.  Note that the }{\b\revised WSACancelBlockingCall() }{\revised still succeeds in this case; the only way to know with certainty that an operation was actually }canceled{\revised 
 is to check for a return code of WSAEINTR from the blocking call.}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINVAL\tab Indicates that there is no outstanding blocking call.
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 WSACleanup {\field{\*\fldinst PAGE}{\fldrslt 101}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart WSACleanup}4.3.10{\*\bkmkend WSACleanup} WSACleanup()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Terminate use of the Windows Sockets DLL.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int }{\b\revised PASCAL FAR }{\b WSACleanup ( void );}
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 
\par \pard \s5\fi-1440\li1440 {\b\f2 Remarks}\tab An application {\revised or DLL }is required to perform a (successful) {\b WSAStartup()} call before it can use Windows Sockets services.  When it has completed the use of Windows Sockets, the application {
\revised or DLL }m{\revised ust} call {\b WSACleanup()} to deregister itself from a Windows Sockets implementation{\revised  and allow the implementati}{\revised on to free any resources allocated on behalf of the application or DLL.  Any }open {\revised 
SOCK_STREAM sockets that are connected when }{\b\revised WSACleanup() }{\revised is called are reset; sockets which have been closed with }{\b closesocket() }but which still have pending data to be sent are not affected--the pending data is still sent.{
\revised 
\par }\pard\plain \s12\li1440 \fs20\lang1033 {\revised 
\par }\pard \s12\li1440 {\revised There must be a call to }{\b\revised WSACleanup() }{\revised for every call to }{\b\revised WSAStartup() }{\revised made by a task.  Only the final }{\b\revised WSACleanup() }{\revised 
for that task does the actual cleanup; the preceding calls simply decrement an internal ref}{\revised erence count in the Windows Sockets DLL.  A naive application may ensure that }{\b\revised WSACleanup() }{\revised was called enough times by calling }{
\b\revised WSACleanup() }{\revised in a loop until it returns WSANOTINITIALISED.}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab The return value is 0 if the operation was successful.  Otherwise the value SOCKET_ERROR is returned, and a specific error number may be retrieved by calling {\b WSAGetLastError()}.

\par \pard \s7\fi-1440\li1440 
\par \pard \s7\fi-1440\li1440 {\b\f2 Comments\tab }Attempting to call {\b WSACleanup()} from {\revised within} a blocking hook and then failing to check the return code is a common{\revised  Windows} Sockets programming error.  {\revised 
If an application needs to quit while a blocking call is outstanding, the application must first cancel the blocking call with }{\b\revised WSACancelBlockingCall()}{\revised  then issue the }{\b\revised WSACleanup() }{\revised 
call once control has been returned to the application.}{\b 
\par }\pard\plain \fs20\lang1033 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 {\b\f2 Notes For
\par }{\b\f2 Windows Sockets
\par }\pard \s22\fi-1440\li1440 {\b\f2 Suppliers}\tab Well-behaved Windows Sockets applications will make a {\b WSACleanup()}
 call to indicate deregistration from a Windows Sockets implementation.  This function can thus, for example, be utilized to free up resources allocated to the specific application.
\par \pard \s22\fi-1440\li1440 
\par \pard\plain \s23\li1440 \fs20\lang1033 A Windows Sockets implementation must be prepared to deal with an application which terminates without invoking {\b WSACleanup()} - for example, as a result of an error.
\par \pard \s23\li1440 
\par \pard \s23\li1440 In a multithreaded environment, {\b WSACleanup()} terminates Windows Sockets operations for all threads. 
\par \pard \s23\li1440 
\par \pard \s23\li1440 A Windows Sockets implementation must ensure that {\b WSACleanup()} leaves things in a state in which the application can invoke {\b WSAStartup()} to re-establish Windows Sockets usage.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b WSAStartup()}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 WSAGetLastError {\field{\*\fldinst PAGE}{\fldrslt 99}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart WSAGetLastError}4.3.11{\*\bkmkend WSAGetLastError} WSAGetLastError()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Get the error status for the last operation which failed.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int }{\b\revised PASCAL FAR }{\b WSAGetLastError ( void );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This function returns the last network error that occurred.  
When a particular Windows Sockets API function indicates that an error has occurred, this function should be called to retrieve the appropriate error code.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab The return value indicates the error code for the last Windows Sockets API routine performed by this thread.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 {\b\f2 Notes For
\par }{\b\f2 Windows Sockets
\par }\pard \s22\fi-1440\li1440 {\b\f2 Suppliers}\tab The use of the {\b WSAGetLastError()} function to retrieve the last error code, rather than relying on a global error variable (cf. {\i errno}), is required in order to provide compatibility with futu
re multi-threaded environments.  
\par \pard\plain \s23\li1440 \fs20\lang1033 
\par \pard \s23\li1440 Note that in a nonpreemptive Wi{\revised ndows} environment {\b WSAGetLastError()} is used to retrieve only Windows Sockets API errors.  In a preemptive environment, {\b WSAGetLastError()} will invoke {\b GetLastError()}
, which is used to retrieve the error status for all Win32 API functions on a per-thread basis.  For portability, an application should use {\b WSAGetLastError()} {\ul immediately} after the Windows Sockets API function which failed.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b WSASetLastError()}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 WSAIsBlocking {\field{\*\fldinst PAGE}{\fldrslt 103}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart WSAIsBlocking}4.3.12{\*\bkmkend WSAIsBlocking} WSAIsBlocking()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 De}{\b\f2 scription}\tab Determine if a blocking call is in progress.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b BOOL }{\b\revised PASCAL FAR }{\b WSAIsBlocking ( void );}
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 
\par \pard \s5\fi-1440\li1440 {\b\f2 Remarks}\tab This function allows a task to determine if it is executing while waiting for a previous blocking call to complete.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab The return value is TRUE if there is an outstanding blocking function awaiting completion.  Otherwise, it is FALSE.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s26\fi-1440\li1440 \fs20\lang1033 {\b\f2 Comments}\tab Although a call issued on a blocking socket appears to an application program as though it "blocks", the Windows So
ckets DLL has to relinquish the processor to allow other applications to run.  This means that it is possible for the application which issued the blocking call to be re-entered, depending on the message(s) it receives.  In this instance, the {\b 
WSAIsBlocking()} function can be used to ascertain whether the task has been re-entered while waiting for an outstanding blocking call to complete.  Note that Windows Sockets prohibits more than one outstanding call per thread.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 {\b\f2 Notes For
\par }{\b\f2 Windows Sockets
\par }\pard \s22\fi-1440\li1440 {\b\f2 Suppliers}\tab A Windows Sockets implementation must prohibit more than one outstanding blocking call per thread.
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 WSASetBlockingHook {\field{\*\fldinst PAGE}{\fldrslt 105}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart WSASetBlockingHook}4.3.13{\*\bkmkend WSASetBlockingHook} WSASetBlockingHook()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Establish an application-specific blocking hook function.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b FARPROC }{\b\revised PASCAL FAR }{\b WSASetBlockingHook ( FARPROC} {\i lpBlockFunc }{\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i lpBlockFunc}\tab A pointer to the procedure instance address of the blocking function to be installed.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This function installs a new function which a Windows Sockets implementation should use to implement blocking socket function calls.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 A Windows Sockets implementation includes a default mechanism by which blocking socket functions are implemented.  The function {\b WSASetBlockingHook()}
 gives the application the ability to execute its own function at "blocking" time in place of the default function.
\par \pard \s12\li1440 
\par \pard \s12\li1440 When an application invokes a blocking Windows Sockets API operation, the Windows Sockets implementation initiates the operation and then enters a loop which is sim{\revised ilar} to the following pseudocode:
\par \pard \s12\li1440 
\par \pard\plain \s29\li1440 \f5\fs20\lang1033 for(;;) \{
\par      /* flush messages for good user response */
\par      while(BlockingHook())
\par           ;
\par      /* check for WSACancelBlockingCall() */
\par      if(operation_cancelled())
\par           break;
\par      /* check to see if operation completed */
\par      if(operation_complete())
\par           break;     /* normal completion */
\par \}
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 {\revised Note that Windows Sockets implementations may perform the above steps in a different order; for example, the check for operation complete may occur before calling the blocking hook.  }The default {\b Bl}{\b ockingHook()}
 function is equivalent to:
\par \pard \s12\li1440 
\par \pard\plain \s29\li1440 \f5\fs20\lang1033 BOOL DefaultBlockingHook(void) \{
\par      MSG msg;
\par      BOOL ret;
\par      /* get the next message if any */
\par      ret = (BOOL)PeekMessage(&msg,{\revised NULL,}0,0,PM_REMOVE);
\par      /* if we got one, process it */
\par      if (ret) \{
\par           TranslateMessage(&msg);
\par           DispatchMessage(&msg);
\par      \}
\par      /* TRUE if we got a message */
\par      return ret;
\par \}
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 The {\b WSASetBlockingHook()} function is provided to support those applications which require more complex message processing - for example, those employing the MDI (multiple document interface) model.  It is {\ul not}
 intended as a mechanism for performing general applications functions.  In particular, the only Windows Sockets API function which may be issued from a custom blocking hook function is {\b WSACancelBlockingCall()}
, which will cause the blocking loop to terminate.
\par \pard \s12\li1440 
\par \pard \s12\li1440 {\revised This function must be implemented on a per-task basis for non-multithreaded versions of Windows and on a per-thread basis for multithreaded versions of Windo}{\revised 
ws such as Windows NT.  It thus provides for a particular task or thread to replace the blocking mechanism without affecting other tasks or threads.
\par }\pard \s12\li1440 {\revised 
\par }\pard \s12\li1440 {\revised In multithreaded versions of Windows, there is no default blocking hook--blocking calls block the thread that makes the call.  However, an application may install a specific blocking hook by calling }{\b\revised 
WSASetBlockingHook().  
\par }\pard \s12\li1440 {\revised This allows easy portability of applications that depend on the blocking hook behavior.
\par }
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab The return value is a pointer to the procedure-instance of the previously installed blocking function.  The application or library that calls the {\b WSASetBlockingHook ()}
 function should save this return value so that it can be restored if necessary.  (If "nesting" is not important, the application may simply discard the value returned by {\b WSASetBlockingHook()} and eventually use {\b WSAUn}{\b\revised hook}{\b 
BlockingHook()} to restore the default mechanism.)  If the operation fails, a NULL pointer is returned, and a specific error number may be retrieved by calling {\b WSAGetLastError()}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAENETDOWN\tab The Windows Sockets implementation has detected that the network subsystem has failed.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINPROGRESS\tab A blocking Windows Sockets operation is in progress.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b WSAUnhookBlockingHook()}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 WSASetLastError {\field{\*\fldinst PAGE}{\fldrslt 103}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart WSASetLastError}4.3.14{\*\bkmkend WSASetLastError} WSASetLastError()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Set the error code which can be retrieved by {\b WSAGetLastError()}.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par {\b\f2  }\tab \tab {\b void }{\b\revised PASCAL FAR }{\b WSASetLastError ( int} {\i iError }{\b );}
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Re}{\b\f2 marks}\tab This function allows an application to set the error code to be returned by a subsequent {\b WSAGetLastError()}
 call for the current thread.  Note that any subsequent Windows Sockets routine called by the application will override the error code as set by this routine.
\par \pard \s7\fi-1440\li1440 
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 {\i iError}\tab Specifies the error code to be returned by a subsequent {\b WSAGetLastError()} call.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 {\b\f2 Notes For
\par }{\b\f2 Windows Sockets
\par }\pard\plain \fs20\lang1033 {\b\f2 Suppliers}\tab In a Win32 environment, this function will invoke {\b SetLastError()}.
\par 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab None.
\par 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b WSAGetLastError()}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 WSAStartup {\field{\*\fldinst PAGE}{\fldrslt 109}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart WSAStartup}4.3.15{\*\bkmkend WSAStartup} WSAStartup()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab 
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int }{\b\revised PASCAL FAR }{\b WSAStartup ( WORD} {\i wVersionRequested}{\b , }{\b\revised 
\par }{\b\revised \tab }{\b LPWSADATA} {\i lpWSAData} {\b );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s6\fi-2160\li3600 \fs20\ul\lang1033 
\par \pard\plain \s10\fi-2160\li3600 \fs20\lang1033 {\i wVersionRequested}\tab The highest version of Windows Sockets API support {\revised that the caller can use}
.  The high order byte specifies the minor version (revision) number; the low-order byte specifies the major version number.
\par \pard \s10\fi-2160\li3600 
\par \pard \s10\fi-2160\li3600 {\i lpWSAData}\tab A pointer to the {\b WSADATA} data structure that is to receive details of the Windows Sockets implementation.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This function {\b MUST} be the first Windows Sockets function called by an application{\revised  or DLL}.  It allows an application or{\revised  DLL }
 to specify the version of Windows Sockets API required and to retrieve details of the specific Windows Sockets implementation.  The application{\revised  or DLL} may only issue further Windows Sockets API functions after a successful {\b WSAStartup()}
 invocation.
\par \pard \s5\fi-1440\li1440 
\par \pard\plain \s12\li1440 \fs20\lang1033 {\revised In order to support future Windows Sockets implem}{\revised entations and applications which may have functionality differences from Windows Sockets 1.1, a negotiation takes place in }{\b\revised 
WSAStartup()}{\revised .  The caller of }{\b\revised WSAStartup()}{\revised  and the Windows Sockets DLL indicate to each other the highest version that they can support, and each confirms that the other's highest version is acceptable.  Upon entry to }{
\b\revised WSAStartup()}{\revised , the Windows Sockets DLL examines the version requested by the application.  If this version is higher than the lowest version supported by the DLL, the call s}{\revised ucceeds and the DLL returns in }{\i\revised 
wHighVersion }{\revised the highest version it supports and in }{\i\revised wVersion}{\revised  the minimum of its high version and }{\i\revised wVersionRequested.  }{\revised The Windows Sockets DLL then assumes that the application will use }{
\i\revised wVersion.}{\revised   If the }{\i\revised wVersion}{\revised  field of the }{\b\revised WSADATA}{\revised  structure is unacceptable to the caller, it should call }{\b\revised WSACleanup() }{\revised 
and either search for another Windows Sockets DLL or fail to initialize.
\par }\pard \s12\li1440 {\revised 
\par }\pard \s12\li1440 This negotiation allows both a Windows Sockets DLL and a Windows Sockets application to support a range of Windows Sockets versions.  An application can successfully utilize a {\revised Windows Sockets }
DLL if there is any overlap in the version ranges.  The following chart gives examples of how {\b WSAStartup()} works in conjunction with different application and {\revised Windows Sockets }DLL versions: 
\par \pard\plain \fs20\lang1033 
\par \trowd \trgaph108\trleft1392 \clbrdrt\brdrs\brdrw30 \clbrdrl\brdrs\brdrw30 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx2487\clbrdrt\brdrs\brdrw30 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3687\clbrdrt
\brdrs\brdrw30 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx5205\clbrdrt\brdrs\brdrw30 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx6039\clbrdrt\brdrs\brdrw30 \clbrdrl\brdrs\brdrw15 \clbrdrb
\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw30 \cellx7209\clbrdrt\brdrs\brdrw30 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw30 \cellx9444\pard \intbl {\fs16\revised A}{\fs16 pp versions\cell }\pard \intbl {\fs16 DLL Versions\cell }\pard 
\intbl {\i\fs16 wVersionRequested}{\fs16 \cell }\pard \intbl {\i\fs16 wVersion}{\fs16 \cell }\pard \intbl {\i\fs16 wHighVersion\cell }\pard \intbl {\fs16 End Result \cell }\pard \intbl {\ul \row }\trowd \trgaph108\trleft1392 \clbrdrl\brdrs\brdrw30 
\clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx2487\clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3687\clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx5205\clbrdrl\brdrs\brdrw15 \clbrdrb
\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx6039\clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw30 \cellx7209\clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw30 \cellx9444\pard \intbl {\fs16\revised 1}{\fs16 .1\cell 
}\pard \intbl {\fs16 1.1\cell }\pard \intbl {\fs16 1.1\cell }\pard \intbl {\fs16 1.1\cell }\pard \intbl {\fs16 1.1\cell }\pard \intbl {\fs16 use 1.1\cell }\pard \intbl \row \trowd \trgaph108\trleft1392 \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw30 
\clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx2487\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx3687\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 
\cellx5205\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx6039\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw30 \cellx7209\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw30 \cellx9444\pard \intbl {\fs16\revised 1}{\fs16 .0 1.1\cell }\pard \intbl {\fs16 1.0\cell }\pard \intbl {\fs16 1.1\cell }\pard \intbl {\fs16 1.0\cell }\pard \intbl {\fs16 1.0\cell }\pard \intbl {
\fs16 use 1.0 \cell }\pard \intbl \row \pard\plain \s2\fi-1440\li1440\intbl \fs20\lang1033 {\fs16\revised 1}{\fs16 .0\cell }\pard \s2\fi-1440\li1440\intbl {\fs16 1.0 1.1\cell }\pard \s2\fi-1440\li1440\intbl {\fs16 1.0\cell }\pard \s2\fi-1440\li1440\intbl 
{\fs16 1.0\cell }\pard \s2\fi-1440\li1440\intbl {\fs16 1.1\cell }\pard \s2\fi-1440\li1440\intbl {\fs16 use 1.0\cell }\pard\plain \intbl \fs20\lang1033 \row \pard \intbl {\fs16\revised 1}{\fs16 .1\cell }\pard \intbl {\fs16 1.0 1.1\cell }\pard \intbl {
\fs16 1.1\cell }\pard \intbl {\fs16 1.1\cell }\pard \intbl {\fs16 1.1}{\fs16 \cell }\pard \intbl {\fs16 use 1.1\cell }\pard \intbl \row \pard \intbl {\fs16\revised 1}{\fs16 .1\cell }\pard \intbl {\fs16 1.0\cell }\pard \intbl {\fs16 1.1\cell }\pard \intbl 
{\fs16 1.0\cell }\pard \intbl {\fs16 1.0\cell }\pard \intbl {\fs16 Application fails\cell }\pard \intbl \row \pard \intbl {\fs16\revised 1}{\fs16 .0\cell }\pard \intbl {\fs16 1.1\cell }\pard \intbl {\fs16 1.0\cell }\pard \intbl {\fs16 ---\cell }\pard 
\intbl {\fs16 ---\cell }\pard \intbl {\fs16 WSAVERNOTSUPPORTED\cell }\pard \intbl \row \pard \intbl {\fs16\revised 1}{\fs16 .0 1.1\cell }\pard \intbl {\fs16 1.0 1.1\cell }\pard \intbl {\fs16 1.1\cell }\pard \intbl {\fs16 1.1\cell }\pard \intbl {\fs16 1.1
\cell }\pard \intbl {\fs16 use 1.1\cell }\pard \intbl \row \pard \intbl {\fs16\revised 1}{\fs16 .1 2.0\cell }\pard \intbl {\fs16 1.1\cell }\pard \intbl {\fs16 2.0\cell }\pard \intbl {\fs16 1.1\cell }\pard \intbl {\fs16 1.1\cell }\pard \intbl {\fs16 
use 1.1\cell }\pard \intbl \row \trowd \trgaph108\trleft1392 \clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw30 \clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw15 \cellx2487\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw15 
\cellx3687\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw15 \cellx5205\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw15 \cellx6039\clbrdrt\brdrs\brdrw15 \clbrdrl
\brdrs\brdrw15 \clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw30 \cellx7209\clbrdrt\brdrs\brdrw15 \clbrdrl\brdrs\brdrw15 \clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw30 \cellx9444\pard\plain \s2\fi-1440\li1440\intbl \fs20\lang1033 {\fs16\revised 2}{\fs16 .0
\cell }\pard \s2\fi-1440\li1440\intbl {\fs16 1.1\cell }\pard \s2\fi-1440\li1440\intbl {\fs16 2.0\cell }\pard \s2\fi-1440\li1440\intbl {\fs16 1.1\cell }\pard \s2\fi-1440\li1440\intbl {\fs16 1.1\cell }\pard \s2\fi-1440\li1440\intbl {\fs16 Application fails
\cell }\pard\plain \intbl \fs20\lang1033 \row \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 {\revised The following code fragment demonstrates how an application which supports only version 1.1 of Windows Sockets makes a }{\b\revised WSAStartup()}{\revised  call:
\par }\pard \s12\li1440 {\revised 
\par }\pard\plain \s29\li1440 \f5\fs20\lang1033 {\revised WORD wVersionRequested;
\par }{\revised WSADATA wsaData;
\par }{\revised int err;
\par }{\revised 
\par }{\revised wVersionRequested = MAKEWORD( 1, 1 );
\par }{\revised 
\par }{\revised err = WSAStartup( wVersionRequested, &}{\revised wsaData );
\par }{\revised if ( err != 0 ) \{
\par }{\revised     /* Tell the user that we couldn't find a useable */
\par }{\revised     /* winsock.dll.                                  */
\par }{\revised     return;
\par }{\revised \}
\par }{\revised 
\par }{\revised /* Confirm that the Windows Sockets DLL supports 1.1.*/
\par }{\revised /* Note that if the DLL supports versions greater    */
\par }{\revised /* than 1.1 in addition to 1.1, it will still return */
\par }{\revised /* 1.1 in wVersion since that is the version we      */
\par }{\revised /* requested.                                        */
\par }{\revised 
\par }{\revised if ( LOBYTE( wsaData.wVersion ) != 1 ||
\par }{\revised          HIBYTE( wsaD}{\revised ata.wVersion ) != 1 ) \{
\par }{\revised     /* Tell the user that we couldn't find a useable */
\par }{\revised     /* winsock.dll.                                  */
\par }{\revised     WSACleanup( );
\par }{\revised     return;   
\par }{\revised \}
\par }{\revised 
\par }{\revised /* The Windows Sockets DLL is acceptable.  Proceed.  */
\par }{\revised 
\par }\pard\plain \s12\li1440 \fs20\lang1033 {\revised And this code fragment demonstrates how a Windows Sockets DLL which supports only version 1.1 performs the }{\b\revised WSAStartup() }{\revised negotiation:
\par }\pard \s12\li1440 {\revised 
\par }\pard\plain \s29\li1440 \f5\fs20\lang1033 {\revised /* Make sure that the version requested is >= 1.1.   */
\par }{\revised /* The low byte is the major version and the high    */
\par }{\revised /* byte is the minor ve}{\revised rsion.                        */
\par }{\revised 
\par }{\revised if ( LOBYTE( wVersionRequested ) < 1 ||
\par }{\revised      ( LOBYTE( wVersionRequested ) == 1 &&
\par }{\revised        HIBYTE( wVersionRequested ) < 1 ) \{
\par }{\revised     return WSAVERNOTSUPPORTED;
\par }{\revised \}
\par }{\revised 
\par }{\revised /* Since we only support 1.1, set both wVersion and  */
\par }{\revised /* wHighVersion to 1.1.                              */
\par }{\revised 
\par }{\revised lpWsaData->wVersion = MAKEWORD( 1, 1 );
\par }{\revised lpWsaData->wHighVersion = MAKEWORD( 1, 1 );
\par }\pard\plain \s12\li1440 \fs20\lang1033 {\revised 
\par }\pard \s12\li1440 Once an application {\revised or DLL }has made a successful {\b WSAStartup()} call, it may proceed to make other Windows Sockets API calls as needed.  When it has finished using the services of the Windows Sockets DLL, the application {
\revised or DLL must} call {\b WSACleanup()}{\revised  in order to allow the Windows Sockets DLL to free any resources for the application.}
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 
\par \pard\plain \s12\li1440 \fs20\lang1033 Details of the actual Windows Sockets implementation are described in the WSAData structure defined as follows:
\par \pard \s12\li1440 
\par \pard\plain \s29\li1440 \f5\fs20\lang1033 struct WSAData \{
\par \tab WORD\tab \tab \tab wVersion;
\par \tab WORD\tab \tab \tab wHighVersion;
\par \tab char \tab \tab \tab szDescription[WSADESCRIPTION_LEN+1];
\par \tab char\tab \tab \tab szSystemStatus[WSASYSSTATUS_LEN+1];
\par \tab {\revised unsigned short}\tab iMaxSockets;
\par \tab {\revised unsigned short}\tab iMaxUdpDg;
\par \tab char FAR *\tab \tab lpVendorInfo{\revised ;}
\par \};
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard\plain \s19\fi-2160\li3600\tx3600 \fs20\lang1033 The members of this structure are:
\par \pard\plain \s6\fi-1440\li2880 \fs20\ul\lang1033 Element\tab Usage
\par \pard\plain \s10\fi-1440\li2880 \fs20\lang1033 wVersion\tab The version of the Windows Sockets specification that{\revised  the Windows Sockets DLL expects the caller to use.}
\par \pard \s10\fi-1440\li2880 wHighVersion\tab The highest version of the Windows Sockets specification that this DLL can support (also encoded as above).  Normally this will be the same as {\i wVersion}.
\par \pard \s10\fi-1440\li2880 szDescription\tab A null-terminated ASCII string into which the Windows Sockets DLL copies a description of the
 Windows Sockets implementation, including vendor identification.  The text (up to 256 characters in length) may contain any characters, but vendors are cautioned against including control and formatting characters: the most likely use that an application
 will put this to is to display it (possibly truncated) in a status message.
\par \pard \s10\fi-1440\li2880 szSystemStatus\tab A null-terminated ASCII string into which the Windows Sockets DLL copies relevant status or configuration information.  The Windows Sockets DLL should use this fiel
d only if the information might be useful to the user or  support staff: it should not be considered as an extension of the {\i szDescription} field.
\par \pard \s10\fi-1440\li2880 iMaxSockets\tab 
The maximum number of sockets which a single process can potentially open.  A Windows Sockets implementation may provide a global pool of sockets for allocation to any process; alternatively it may allocate per-process resources for sockets.  
The number may well reflect the way in which the Windows Sockets DLL or the networking software was configured.
  Application writers may use this number as a crude indication of whether the Windows Sockets implementation is usable by the application.  For example, an X Windows server might check {\i iMaxSockets}
 when first started: if it is less than 8, the application would display an error message instructing the user to reconfigure the networking software.  (This is a situation in which the {\i szSystemStatus}
 text might be used.)  Obviously there is no guarantee that a particular application can actually allocate {\i iMaxSock}{\i ets} sockets, since there may be other Windows Sockets applications in use.
\par \pard \s10\fi-1440\li2880 iMaxUdpDg\tab The size in bytes of the largest UDP datagram that can be sent or received by a Windows Sockets application.  If the implementation imposes no limit, {\i iMaxUdpDg}
 is zero.  In many implementations of Berkeley sockets, there is an implicit limit of 8192 bytes on UDP datagrams (which are fragmented if necessary).  A Windows Sockets implementation may impose a limit based, for instance, on the allocation of fragment 
reassembly buffers.  The minimum value of {\i iMaxUdpDg} for a compliant Windows Sockets implementation is 512.  Note that regardless of the value of {\i iMaxUdpDg}, it is inadvisable to attempt to send a {\ul broadcast}
 datagram which is larger than the Maximum Transmission Unit (MTU) for the network.  (The Windows Sockets API does not provide a mechanism to discover the MTU, but it must be no less than 512 bytes.)
\par \pard \s10\fi-1440\li2880 lpVendorInfo\tab A far pointer to a vendor-specific data structure.  The definition of this structure (if supplied) is beyond the scope of this specification.
\par \pard \s10\fi-1440\li2880 
\par \pard\plain \s12\li1440 \fs20\lang1033 {\revised An application }or DLL {\revised may call }{\b\revised WSAStartup() }{\revised more than once if it needs to obtain the WSAData structure information more than once.  However, the }{\i\revised 
wVersionRequired }{\revised parameter is assumed to be the same on all calls to }{\b\revised WSAStartup()}{\revised ; that is, an application }or DLL {\revised cannot change the version of Windows Sockets it expects after the initial call to }{\b\revised 
WSAStartup().  
\par }\pard \s12\li1440 {\b\revised 
\par }\pard \s12\li1440 {\revised There must be one }{\b\revised WSACleanup() }{\revised call corresponding to every }{\b\revised WSAStartup() }{\revised call to allow third-party DLLs to make use}{\revised 
 of a Windows Sockets DLL on behalf of an application.  This means, for example, that if an application calls }{\b\revised WSAStartup() }{\revised three times, it must call }{\b\revised WSACleanup() }{\revised three times.  The first two calls to }{
\b\revised WSACleanup() }{\revised do nothing except decrement an internal counter; the final }{\b\revised WSACleanup() }{\revised c}all for the task {\revised does all necessary resource deallocation for the task.}{\b\revised 
\par }\pard\plain \fs20\lang1033 {\revised 
\par }
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab {\b WSAStartup()} returns zero if successful.  Otherwise it returns one of the error codes listed below.  Note that the normal mechanism whereby the application calls {\b 
WSAGetLastError()} to determine the error code cannot be used, since the Windows Sockets DLL may not have established the client data area where the "last error" information is stored.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 {\b\f2 Notes For
\par }{\b\f2 Windows Sockets
\par }\pard \s22\fi-1440\li1440 {\b\f2 Suppliers}\tab Each Windows Sockets application MUST make a {\b WSAStartup()} call before issuing any other Windows Sockets API calls.  This function can thus be utilized for initialization purposes.
\par \pard\plain \s23\li1440 \fs20\lang1033 
\par Further issues are discussed in the notes for {\b WSACleanup()}.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSASYSNOTREADY\tab Indicates that the underlying network subsystem is not ready for network communication.
\par \pard \s8\fi-4320\li4320\keep\tx1440\tx4320 
\par \pard\plain \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 \fs20\lang1033 WSAVERNOTSUPPORTED\line The version of Windows Sockets API support requested is not provided by this particular Windows Sockets implementation.
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 
\par \pard \s11\fi-2880\li4320\keep\tx1440\tx4320\tx5040 WSAEINVAL\tab The Windows Sockets version specified by the application is not supported by this DLL.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b send()}, {\b sendto()}, {\b WSACleanup()}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 WSAUnhookBlockingHook {\field{\*\fldinst PAGE}{\fldrslt 111}}
\par }\pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart WSAUnhookBlockingHoo}4.3.16{\*\bkmkend WSAUnhookBlockingHoo} WSAUnhookBlockingHook()
\par \pard\plain \s3\fi-1440\li1440 \fs20\lang1033 {\b\f2 Description}\tab Restore the default blocking hook function.
\par 
\par {\b\f2  }\tab {\b #include <winsock.h>}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s4\fi-1440\li1440 \fs20\lang1033 {\b\f2  }\tab {\b int }{\b\revised PAS}{\b\revised CAL FAR }{\b WSAUnhookBlockingHook ( void );}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s5\fi-1440\li1440 \fs20\lang1033 {\b\f2 Remarks}\tab This function removes any previous blocking hook that has been installed and reinstalls the default blocking mechanism.  
\par \pard\plain \s12\li1440 \fs20\lang1033 
\par \pard \s12\li1440 {\b WSAUnhookBlockingHook()} will always install the {\ul default} mechanism, not the {\ul previous}
 mechanism.  If an application wish to nest blocking hooks - i.e. to establish a temporary blocking hook function and then revert to the previous mechanism (whether the default or one established by an earlier {\b WSASetBlockingHook()}
) - it must save and restore the value returned by {\b WSASetBlockingHook()}; it cannot use {\b WSAUnhookBlockingHook()}.
\par \pard \s12\li1440 
\par \pard \s12\li1440 {\revised In multithreaded versions of Windows such as Windows NT, there is no default blocking hook.  Calling }{\b\revised WSAUnhookBlockingHook() }{\revised 
disables any blocking hook installed by the application and any blocking calls made block the thread which made the call.}
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s7\fi-1440\li1440 \fs20\lang1033 {\b\f2 Return Value}\tab The return value is 0 if the operation was successful.  Otherwise the value SOCKET_ERROR is returned, and a specific error number may be retrieved by calling {\b WSAGetLastError()}.

\par \pard\plain \fs20\lang1033 
\par \pard\plain \s8\fi-4320\li4320\keep\tx1440\tx4320 \fs20\lang1033 {\b\f2 Error Codes}\tab WSANOTINITIALISED\tab A successful {\b WSAStartup()} must occur before using this API.
\par \pard\plain \fs20\lang1033 
\par \pard\plain \s9\fi-1440\li1440 \fs20\lang1033 {\b\f2 See Also}\tab {\b WSASetBlockingHook()}
\par \pard\plain \s253\sb120 \b\f2\lang1033 \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 Appendix A1: Error Codes {\field{\*\fldinst PAGE}{\fldrslt 113}}
\par }\pard\plain \s254\sb240 \b\f2\ul\lang1033 {\*\bkmkstart AppendixA}Appendix A.  Error Codes and Header Files
\par \pard\plain \s253\sb120 \b\f2\lang1033 {\*\bkmkend AppendixA}A.1 Error Codes
\par \pard\plain \fs20\lang1033 The following is a list of possible error codes returned by the {\b WSAGetLastError()} call, along with their explanations.  The error numbers are consistently set across all Windows Sockets-compliant implementations.
\par \pard 
\par \trowd \trgaph108\trleft-108 \clbrdrt\brdrs\brdrw30 \clbrdrl\brdrs\brdrw30 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx2052\clbrdrt\brdrs\brdrw30 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx4212\clbrdrt\brdrs\brdrw30 \clbrdrb
\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx4932\clbrdrt\brdrs\brdrw30 \clbrdrb\brdrdb\brdrw15 \clbrdrr\brdrs\brdrw30 \cellx8532\pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 Windows Sockets code\cell Berkeley equivalent\cell \pard 
\s31\keep\keepn\intbl Error\cell \pard \s31\keep\keepn\intbl Interpretation\cell \pard\plain \intbl \fs20\lang1033 \row \trowd \trgaph108\trleft-108 \clbrdrl\brdrs\brdrw30 \clbrdrr\brdrs\brdrw15 \cellx2052\clbrdrr\brdrs\brdrw15 \cellx4212\clbrdrr
\brdrs\brdrw15 \cellx4932\clbrdrr\brdrs\brdrw30 \cellx8532\pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAEINTR\cell EINTR\cell \pard \s31\keep\keepn\intbl 10004\cell \pard \s31\keep\keepn\intbl As in standard C\cell \pard\plain \intbl 
\fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAEBADF\cell EBADF\cell \pard \s31\keep\keepn\intbl 10009\cell \pard \s31\keep\keepn\intbl As in standard C\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain 
\s31\keep\keepn\intbl \f5\fs16\lang1033 {\revised WSAEACCES}\cell {\revised EACCES}\cell \pard \s31\keep\keepn\intbl {\revised 10013}\cell \pard \s31\keep\keepn\intbl {\revised As in standard C}\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain 
\s31\keep\keepn\intbl \f5\fs16\lang1033 {\revised WSAEFAULT}\cell {\revised EFAULT}\cell \pard \s31\keep\keepn\intbl {\revised 10014}\cell \pard \s31\keep\keepn\intbl {\revised As in standard C}\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain 
\s31\keep\keepn\intbl \f5\fs16\lang1033 WSAEINVAL\cell EINVAL\cell \pard \s31\keep\keepn\intbl 10022\cell \pard \s31\keep\keepn\intbl As in standard C\cell \pard\plain \intbl \fs20\lang1033 \row \trowd \trgaph108\trleft-108 \clbrdrl\brdrs\brdrw30 \clbrdrb
\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx2052\clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx4212\clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx4932\clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw30 \cellx8532\pard\plain \s31\keep\keepn\intbl 
\f5\fs16\lang1033 WSAEMFILE\cell EMFILE\cell \pard \s31\keep\keepn\intbl 10024\cell \pard \s31\keep\keepn\intbl As in standard C\cell \pard\plain \intbl \fs20\lang1033 \row \trowd \trgaph108\trleft-108 \clbrdrl\brdrs\brdrw30 \clbrdrr\brdrs\brdrw15 
\cellx2052\clbrdrr\brdrs\brdrw15 \cellx4212\clbrdrr\brdrs\brdrw15 \cellx4932\clbrdrr\brdrs\brdrw30 \cellx8532\pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAEWOULDBLOCK\cell EWOULDBLOCK\cell \pard \s31\keep\keepn\intbl 10035\cell \pard 
\s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAEINPROGRESS\cell EINPROGRESS\cell \pard \s31\keep\keepn\intbl 10036\cell \pard \s31\keep\keepn\intbl 
This error is returned if any\line Windows Sockets API function is \line called while a blocking function is\line in progress.\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAEALREADY\cell EALREADY\cell 
\pard \s31\keep\keepn\intbl 10037\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAENOTSOCK\cell ENOTSOCK\cell \pard \s31\keep\keepn\intbl 10038\cell \pard 
\s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAEDESTADDRREQ\cell EDESTADDRREQ\cell \pard \s31\keep\keepn\intbl 10039\cell \pard \s31\keep\keepn\intbl As in BSD\cell 
\pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAEMSGSIZE\cell EMSGSIZE\cell \pard \s31\keep\keepn\intbl 10040\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain 
\s31\keep\keepn\intbl \f5\fs16\lang1033 WSAEPROTOTYPE\cell EPROTOTYPE\cell \pard \s31\keep\keepn\intbl 10041\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 
WSAENOPROTOOPT\cell ENOPROTOOPT\cell \pard \s31\keep\keepn\intbl 10042\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAEPROTONOSUPPORT\cell EPROTONOSUPPORT\cell 
\pard \s31\keep\keepn\intbl 10043\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAESOCKTNOSUPPORT\cell ESOCKTNOSUPPORT\cell \pard \s31\keep\keepn\intbl 10044
\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAEOPNOTSUPP\cell EOPNOTSUPP\cell \pard \s31\keep\keepn\intbl 10045\cell \pard \s31\keep\keepn\intbl As in BSD
\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAEPFNOSUPPORT\cell EPFNOSUPPORT\cell \pard \s31\keep\keepn\intbl 10046\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 
\row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAEAFNOSUPPORT\cell EAFNOSUPPORT\cell \pard \s31\keep\keepn\intbl 10047\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl 
\f5\fs16\lang1033 WSAEADDRINUSE\cell EADDRINUSE\cell \pard \s31\keep\keepn\intbl 10048\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAEADDRNOTAVAIL\cell 
EADDRNOTAVAIL\cell \pard \s31\keep\keepn\intbl 10049\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAENETDOWN\cell ENETDOWN\cell \pard \s31\keep\keepn\intbl 
10050\cell \pard \s31\keep\keepn\intbl As in BSD.  This error may be reported at any time if the Windows Sockets implementation detects an underlying failure.\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 
WSAENETUNREACH\cell ENETUNREACH\cell \pard \s31\keep\keepn\intbl 10051\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAENETRESET\cell ENETRESET\cell \pard 
\s31\keep\keepn\intbl 10052\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAECONNABORTED\cell ECONNABORTED\cell \pard \s31\keep\keepn\intbl 10053\cell \pard 
\s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAECONNRESET\cell ECONNRESET\cell \pard \s31\keep\keepn\intbl 10054\cell \pard \s31\keep\keepn\intbl As in BSD\cell 
\pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAENOBUFS\cell ENOBUFS\cell \pard \s31\keep\keepn\intbl 10055\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain 
\s31\keep\keepn\intbl \f5\fs16\lang1033 WSAEISCONN\cell EISCONN\cell \pard \s31\keep\keepn\intbl 10056\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAENOTCONN
\cell ENOTCONN\cell \pard \s31\keep\keepn\intbl 10057\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAESHUTDOWN\cell ESHUTDOWN\cell \pard \s31\keep\keepn\intbl 
10058\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAETOOMANYREFS\cell ETOOMANYREFS\cell \pard \s31\keep\keepn\intbl 10059\cell \pard \s31\keep\keepn\intbl 
As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAETIMEDOUT\cell ETIMEDOUT\cell \pard \s31\keep\keepn\intbl 10060\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 
\row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAECONNREFUSED\cell ECONNREFUSED\cell \pard \s31\keep\keepn\intbl 10061\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl 
\f5\fs16\lang1033 WSAELOOP\cell ELOOP\cell \pard \s31\keep\keepn\intbl 10062\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAENAMETOOLONG\cell ENAMETOOLONG\cell 
\pard \s31\keep\keepn\intbl 10063\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAEHOSTDOWN\cell EHOSTDOWN\cell \pard \s31\keep\keepn\intbl 10064\cell \pard 
\s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \trowd \trgaph108\trleft-108 \clbrdrl\brdrs\brdrw30 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx2052\clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx4212\clbrdrb
\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx4932\clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw30 \cellx8532\pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAEHOSTUNREACH\cell EHOSTUNREACH\cell \pard \s31\keep\keepn\intbl 10065\cell \pard 
\s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \trowd \trgaph108\trleft-108 \clbrdrl\brdrs\brdrw30 \clbrdrr\brdrs\brdrw15 \cellx2052\clbrdrr\brdrs\brdrw15 \cellx4212\clbrdrr\brdrs\brdrw15 \cellx4932\clbrdrr\brdrs\brdrw30 
\cellx8532\pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSASYSNOTREADY\cell \cell \pard \s31\keep\keepn\intbl 10091\cell \pard \s31\keep\keepn\intbl Returned by {\b WSAStartup()} \line indicating that the network subsystem is unusable.\cell 
\pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAVERNOTSUPPORTED\cell \cell \pard \s31\keep\keepn\intbl 10092\cell \pard \s31\keep\keepn\intbl Returned by {\b WSAStartup()} \line 
indicating that the Windows Sockets\line DLL cannot support this app.\cell \pard\plain \intbl \fs20\lang1033 \row \trowd \trgaph108\trleft-108 \clbrdrl\brdrs\brdrw30 \clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx2052\clbrdrb\brdrs\brdrw15 \clbrdrr
\brdrs\brdrw15 \cellx4212\clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw15 \cellx4932\clbrdrb\brdrs\brdrw15 \clbrdrr\brdrs\brdrw30 \cellx8532\pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSANOTINITIALISED\cell \cell \pard \s31\keep\keepn\intbl 10093
\cell \pard \s31\keep\keepn\intbl Returned by any function except {\b WSAStartup()} indicating that a successful {\b WSAStartup()} has not yet been performed.\cell \pard\plain \intbl \fs20\lang1033 \row \trowd \trgaph108\trleft-108 \clbrdrl\brdrs\brdrw30 
\clbrdrr\brdrs\brdrw15 \cellx2052\clbrdrr\brdrs\brdrw15 \cellx4212\clbrdrr\brdrs\brdrw15 \cellx4932\clbrdrr\brdrs\brdrw30 \cellx8532\pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSAHOST_NOT_FOUND\cell HOST_NOT_FOUND\cell \pard \s31\keep\keepn\intbl 
11001\cell \pard \s31\keep\keepn\intbl As in BSD.\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSATRY_AGAIN\cell TRY_AGAIN\cell \pard \s31\keep\keepn\intbl 11002\cell \pard \s31\keep\keepn\intbl As in BSD
\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSANO_RECOVERY\cell NO_RECOVERY\cell \pard \s31\keep\keepn\intbl 11003\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row 
\trowd \trgaph108\trleft-108 \clbrdrl\brdrs\brdrw30 \clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw15 \cellx2052\clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw15 \cellx4212\clbrdrb\brdrs\brdrw30 \clbrdrr\brdrs\brdrw15 \cellx4932\clbrdrb\brdrs\brdrw30 \clbrdrr
\brdrs\brdrw30 \cellx8532\pard\plain \s31\keep\keepn\intbl \f5\fs16\lang1033 WSANO_DATA\cell NO_DATA\cell \pard \s31\keep\keepn\intbl 11004\cell \pard \s31\keep\keepn\intbl As in BSD\cell \pard\plain \intbl \fs20\lang1033 \row \pard\plain 
\s30\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760 \f5\fs16\lang1033 
\par \pard\plain \fs20\lang1033 
\par \pard The first set of definitions is present to resolve contentions between standard C error codes which may be defined inconsistently between various C compilers.
\par \pard 
\par \pard The second set of definitions provides Windows Sockets versions of regular Berkeley Sockets error codes.
\par \pard 
\par The third set of definitions consists of extended Windows Sockets-specific error codes.
\par 
\par \pard The fourth set of errors are returned by Windows Sockets {\b getXbyY()} and {\b WSAAsyncGetXByY()} functions, and correspond to the errors which in Berkeley software would be returned in the {\i h_errno} variable.  They 
correspond to various failures which may be returned by the Domain Name Service.  If the Windows Sockets implementation  does not use the DNS, it will use the most appropriate code.  In general, a Windows Sockets application should interpret WSAHOST_NOT_F
OUND and WSANO_DATA as indicating that the key (name, address, etc.) was not found,, while WSATRY_AGAIN and WSANO_RECOVERY suggest that the name service itself is non-operational.
\par \pard 
\par \pard The error numbers are derived from the {\b winsock.h} header file listed in section {\field{\*\fldinst ref winsock_h}{\fldrslt A.2.2}}
, and are based on the fact that Windows Sockets error numbers are computed by adding 10000 to the "normal" Berkeley error number.
\par \pard 
\par \pard Note that this table does not include all of the error codes defined in {\b winsock.h}.  This is because it includes only errors which might reasonably be returned by a Windows Sockets implementation: {\b winsock.h}
, on the other hand, includes a full set of BSD definitions to ensure compatibility with ported software.
\par \pard {\b 
\par }\pard {\b 
\par }{\b \sect }\sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 Appendix A2: Header Files {\field{\*\fldinst PAGE}{\fldrslt 113}}
\par }\pard\plain \s253\sb120 \b\f2\lang1033 A.2 Header Files
\par \pard\plain \s252 \b\f2\lang1033 A.2.1 Berkeley Header Files
\par \pard\plain \fs20\lang1033 
A Windows Sockets supplier who provides a development kit to support the development of Windows Sockets applications must supply a set of vestigial header files with names that match a number of the header files in the Berkeley software distribution.  The
se files are provided for source code compatibility only, and each consists of three lines:
\par \pard 
\par \pard\plain \s30\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760 \f5\fs16\lang1033 #ifndef _WINSOCKAPI_
\par #include <winsock.h>
\par #endif
\par \pard\plain \fs20\lang1033 
\par The header files provided for compatibility are:
\par {\b netdb.h
\par }{\b arpa/inet.h
\par }{\b sys/time.h
\par }{\b sys/socket.h}{\b 
\par }{\b netinet/in.h
\par }
\par \pard The file {\b winsock.h} contains all of the type and structure definitions, constants, macros, and function prototypes used by the Windows Sockets specification.  An application writer may choose to ignore the compatibility headers and include {\b 
winsock.h} in each source file.
\par \pard 
\par \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 winsock.h {\field{\*\fldinst PAGE}{\fldrslt 125}}
\par }\pard\plain \fs20\lang1033 
\par \pard\plain \s252 \b\f2\lang1033 {\*\bkmkstart winsock_h}A.2.2{\*\bkmkend winsock_h} Windows Sockets Header File - winsock.h
\par \pard\plain \fs20\lang1033 
\par \pard The {\b winsock.h} header file includes a number of types and definitions from the standard Windows header file {\b windows.h}.  The {\b windows.h} in the Windows 3.0 SDK (Software Developer's Kit) lacks a {\f3 #include}
 guard, so if you need to include {\b windows.h} as well as {\b winsock.h}, you should define the symbol _INC_WINDOWS before #including {\b winsock.h}, as follows:
\par \pard\plain \s32\fi-1440\li2880 \f5\fs20\lang1033 #include <windows.h>
\par #define _INC_WINDOWS
\par #include <winsock.h>
\par \pard\plain \fs20\lang1033 Users of the SDK for Windows 3.1 and later need not do this.
\par 
\par \pard {\revised A Windows Sockets DLL vendor }{\b\revised MUST NOT}{\revised  make any modifications to this header file which could impact binary compatibility of Windows Sockets applications.  The constant values, function parameters and ret}{\revised 
urn codes, and the like must remain consistent across all Windows Sockets DLL vendors.}
\par \pard\plain \s30\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760 \f5\fs16\lang1033 
\par 
\par /* WINSOCK.H--definitions to be used with the WINSOCK.DLL
\par  *
\par  * This header file corresponds to version 1.1 of the Windows Sockets specification{\revised .}
\par  *
\par  * This file includes parts which are Copyright (c) 1982-1986 Regents
\par  * of the University of California.  All rights reserved.  The
\par  * Berkeley Software License Agreement specifies the terms and
\par  * conditions for redistribution.
\par  */
\par 
\par #ifndef _WINSOCKAPI_
\par #define _WINSOCKAPI_
\par 
\par /*
\par  * Pull in WINDOWS.H if necessary
\par  */
\par #ifndef _INC_WINDOWS
\par #include <windows.h>
\par #endif /* _INC_WINDOWS */
\par 
\par /*
\par  * Basic system type definitions, taken from the BSD file sys/types.h.
\par  */
\par typedef unsigned char   u_char;
\par typedef unsigned short  u_short;
\par typedef unsigned int    u_int;
\par typedef unsigned long   u_long;
\par 
\par /*
\par  * The new type to be used in all
\par  * instances which refer to sockets.
\par  */
\par typedef u_int           SOCKET;
\par 
\par /*
\par  * Select uses arrays of SOCKETs.  These macros manipulate such
\par  * arrays.  FD_SETSIZE may be defined by the user before including
\par  * this file, but the default here should be >= 64.
\par  *
\par  * CAVEAT IMPLEMENTOR and USER: THESE MACROS AND TYPES MUST BE
\par  * INCLUDED IN WINSOCK.H EXACTLY AS SHOWN HERE.
\par  */
\par #ifndef FD_SETSIZE
\par #define FD_SETSIZE      64
\par #endif /* FD_SETSIZE */
\par 
\par typedef struct fd_set \{
\par         u_short fd_count;               /* how many are SET? */
\par         SOCKET  fd_array[FD_SETSIZE];   /* an array of SOCKETs */
\par \} fd_set;
\par 
\par extern int PASCAL FAR __WSAFDIsSet(SOCKET, fd_set FAR *);
\par 
\par #define FD_CLR(fd, set) {\revised do }\{ \\
\par     u_int __i; \\
\par     for (__i = 0; __i < ((fd_set FAR *)(set))->fd_count ; __i++) \{ \\
\par         if (((fd_set FAR *)(set))->fd_array[__i] == fd) \{ \\
\par             while (__i < ((fd_set FAR *)(set))->fd_count-1) \{ \\
\par                 ((fd_set FAR *)(set))->fd_array[__i] = \\
\par                     ((fd_set FAR *)(set))->fd_array[__i+1]; \\
\par                 __i++; \\
\par             \} \\
\par             ((fd_set FAR *)(set))->fd_count--; \\
\par             break; \\
\par         \} \\
\par     \} \\
\par \}{\revised  while(0)}
\par 
\par #define FD_SET(fd, set) {\revised do }\{ \\
\par     if (((fd_set FAR *)(set))->fd_count < FD_SETSIZE) \\
\par         ((fd_set FAR *)(set))->fd_array[((fd_set FAR *)(set))->fd_count++]=fd;\\
\par \}{\revised  while(0)}
\par 
\par #define FD_ZERO(set) {\revised (}((fd_set FAR *)(set))->fd_count=0{\revised )}
\par 
\par #define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)fd, (fd_set FAR *)set{\revised )}
\par 
\par /*
\par  * Structure used in select() call, taken from the BSD file sys/time.h.
\par  */
\par struct timeval \{
\par         long    tv_sec;         /* seconds */
\par         long    tv_usec;        /* and microseconds */
\par \};
\par 
\par /*
\par  * Operations on timevals.
\par  *
\par  * NB: timercmp does not work for >= or <=.
\par  */
\par #define timerisset(tvp)         ((tvp)->tv_sec || (tvp)->tv_usec)
\par #define timercmp(tvp, uvp, cmp) \\
\par         ((tvp)->tv_sec cmp (uvp)->tv_sec || \\
\par          (tvp)->tv_sec == (uvp)->tv_sec && (tvp)->tv_usec cmp (uvp)->tv_usec)
\par #define timerclear(tvp)         (tvp)->tv_sec = (tvp)->tv_usec = 0
\par 
\par /*
\par  * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
\par  *
\par  *
\par  * Ioctl's have the command encoded in the lower word,
\par  * and the size of any in or out parameters in the upper
\par  * word.  The high 2 bits of the upper word are used
\par  * to encode the in/out status of the parameter; for now
\par  * we restrict parameters to at most 128 bytes.
\par  */
\par #define IOCPARM_MASK    0x7f            /* parameters must be < 128 bytes */
\par #define IOC_VOID        0x20000000      /* no parameters */
\par #define IOC_OUT         0x40000000      /* copy out parameters */
\par #define IOC_IN          0x80000000      /* copy in parameters */
\par #define IOC_INOUT       (IOC_IN|IOC_OUT)
\par                                         /* 0x20000000 distinguishes new &
\par                                            old ioctl's */
\par #define _IO(x,y)        (IOC_VOID|(x<<8)|y)
\par 
\par #define _IOR(x,y,t)     (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|(x<<8)|y)
\par 
\par #define _IOW(x,y,t)     (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|(x<<8)|y)
\par 
\par #define FIONREAD    _IOR('f', 127, u_long) /* get # bytes to read *{\revised /}
\par #define FIONBIO     _IOW('f', 126, u_long) /* set/clear non-blocking i/o *{\revised /}
\par #define FIOASYNC    _IOW('f', 125, u_long) /* set/clear async i/o *{\revised /}
\par 
\par /* Socket I/O Controls */
\par #define SIOCSHIWAT  _IOW('s',  0, u_long)  /* set high watermark *{\revised /}
\par #define SIOCGHIWAT  _IOR('s',  1, u_long)  /* get high watermark *{\revised /}
\par #define SIOCSLOWAT  _IOW('s',  2, u_long)  /* set low watermark *{\revised /}
\par #define SIOCGLOWAT  _IOR('s',  3, u_long)  /* get low watermark *{\revised /}
\par #define SIOCATMARK  _IOR('s',  7, u_long)  /* at oob mark? *{\revised /}
\par 
\par /*
\par  * Structures returned by network data base library, taken from the
\par  * BSD file netdb.h.  All addresses are supplied in host order, and
\par  * returned in network order (suitable for use in system calls).
\par  */
\par 
\par struct  hostent \{
\par         char    FAR * h_name;           /* official name of host */
\par         char    FAR * FAR * h_aliases;  /* alias list */
\par         short   h_addrtype;             /* host address type *{\revised /}
\par         short   h_length;               /* length of address *{\revised /}
\par         char    FAR * FAR * h_addr_list; /* list of addresses */
\par #define h_addr  h_addr_list[0]          /* address, for backward compat */
\par \};
\par 
\par /*
\par  * It is assumed here that a network number
\par  * fits in 32 bits.
\par  */
\par struct  netent \{
\par         char    FAR * n_name;           /* official name of net */
\par         char    FAR * FAR * n_aliases;  /* alias list */
\par         short   n_addrtype;             /* net address type *{\revised /}
\par         u_long  n_net;                  /* network # */
\par \};
\par 
\par struct  servent \{
\par         char    FAR * s_name;           /* official service name */
\par         char    FAR * FAR * s_aliases;  /* alias list */
\par         short   s_port;                 /* port # *{\revised /}
\par         char    FAR * s_proto;          /* protocol to use */
\par \};
\par 
\par struct  protoent \{
\par         char    FAR * p_name;           /* official protocol name */
\par         char    FAR * FAR * p_aliases;  /* alias list */
\par         short   p_proto;                /* protocol # *{\revised /}
\par \};
\par 
\par /*
\par  * Constants and structures defined by the internet system,
\par  * Per RFC 790, September 1981, taken from the BSD file netinet/in.h.
\par  */
\par 
\par /*
\par  * Protocols
\par  */
\par #define IPPROTO_IP              0               /* dummy for IP */
\par #define IPPROTO_ICMP            1               /* control message protocol */
\par #define IPPROTO_GGP             2               /* gateway^2 (deprecated) */
\par #define IPPROTO_TCP             6               /* tcp */
\par #define IPPROTO_PUP             12              /* pup */
\par #define IPPROTO_UDP             17              /* user datagram protocol */
\par #define IPPROTO_IDP             22              /* xns idp */
\par #define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */
\par 
\par #define IPPROTO_RAW             255             /* raw IP packet */
\par #define IPPROTO_MAX             256
\par 
\par /*
\par  * Port/socket numbers: network standard functions
\par  */
\par #define IPPORT_ECHO             7
\par #define IPPORT_DISCARD          9
\par #define IPPORT_SYSTAT           11
\par #define IPPORT_DAYTIME          13
\par #define IPPORT_NETSTAT          15
\par #define IPPORT_FTP              21
\par #define IPPORT_TELNET           23
\par #define IPPORT_SMTP             25
\par #define IPPORT_TIMESERVER       37
\par #define IPPORT_NAMESERVER       42
\par #define IPPORT_WHOIS            43
\par #define IPPORT_MTP              57
\par 
\par /*
\par  * Port/socket numbers: host specific functions
\par  */
\par #define IPPORT_TFTP             69
\par #define IPPORT_RJE              77
\par #define IPPORT_FINGER           79
\par #define IPPORT_TTYLINK          87
\par #define IPPORT_SUPDUP           95
\par 
\par /*
\par  * UNIX TCP sockets
\par  */
\par #define IPPORT_EXECSERVER       512
\par #define IPPORT_LOGINSERVER      513
\par #define IPPORT_CMDSERVER        514
\par #define IPPORT_EFSSERVER        520
\par 
\par /*
\par  * UNIX UDP sockets
\par  */
\par #define IPPORT_BIFFUDP          512
\par #define IPPORT_WHOSERVER        513
\par #define IPPORT_ROUTESERVER      520
\par                                         /* 520+1 also used */
\par 
\par /*
\par  * Ports < IPPORT_RESERVED are reserved for
\par  * privileged processes (e.g. root).
\par  */
\par #define IPPORT_RESERVED         1024
\par 
\par /*
\par  * Link numbers
\par  */
\par #define IMPLINK_IP              155
\par #define IMPLINK_LOWEXPER        156
\par #define IMPLINK_HIGHEXPER       158
\par 
\par /*
\par  * Internet address (old style... should be updated)
\par  */
\par struct in_addr \{
\par         union \{
\par                 struct \{ u_char s_b1,s_b2,s_b3,s_b4; \} S_un_b;
\par                 struct \{ u_short s_w1,s_w2; \} S_un_w;
\par                 u_long S_addr;
\par         \} S_un;
\par #define s_addr  S_un.S_addr
\par                                 /* can be used for most tcp & ip code */
\par #define s_host  S_un.S_un_b.s_b2
\par                                 /* host on imp */
\par #define s_net   S_un.S_un_b.s_b1
\par                                 /* network */
\par #define s_imp   S_un.S_un_w.s_w2
\par                                 /* imp */
\par #define s_impno S_un.S_un_b.s_b4
\par                                 /* imp # */
\par #define s_lh    S_un.S_un_b.s_b3
\par                                 /* logical host */
\par \};
\par 
\par /*
\par  * Definitions of bits in internet address integers.
\par  * On subnets, the decomposition of addresses to host and net parts
\par  * is done according to subnet mask, not the masks here.
\par  */
\par #define IN_CLASSA(i)            (((long)(i) & 0x80000000) == 0)
\par #define IN_CLASSA_NET           0xff000000
\par #define IN_CLASSA_NSHIFT        24
\par #define IN_CLASSA_HOST          0x00ffffff
\par #define IN_CLASSA_MAX           128
\par 
\par #define IN_CLASSB(i)            (((long)(i) & 0xc0000000) == 0x80000000)
\par #define IN_CLASSB_NET           0xffff0000
\par #define IN_CLASSB_NSHIFT        16
\par #define IN_CLASSB_HOST          0x0000ffff
\par #define IN_CLASSB_MAX           65536
\par 
\par #define IN_CLASSC(i)            (((long)(i) & 0xc0000000) == 0xc0000000)
\par #define IN_CLASSC_NET           0xffffff00
\par #define IN_CLASSC_NSHIFT        8
\par #define IN_CLASSC_HOST          0x000000ff
\par 
\par #define INADDR_ANY              (u_long)0x00000000
\par #define INADDR_LOOPBACK         0x7f000001
\par #define INADDR_BROADCAST        (u_long)0xfffffff{\revised f}    
\par #define INADDR_NONE             0xfffffff{\revised f}
\par 
\par /*
\par  * Socket address, internet style.
\par  */
\par struct sockaddr_in \{
\par         short   sin_family;
\par         u_short sin_port;
\par         struct  in_addr sin_addr;
\par         char    sin_zero[8];
\par \};
\par 
\par #define WSADESCRIPTION_LEN      256
\par #define WSASYS_STATUS_LEN       128
\par 
\par typedef struct WSAData \{
\par         WORD                    wVersion;
\par         WORD                    wHighVersion;
\par         char                    szDescription[WSADESCRIPTION_LEN+1];
\par         char                    szSystemStatus[WSASYS_STATUS_LEN+1];
\par         unsigned short          iMaxSockets{\revised ;}
\par         unsigned short          iMaxUdpDg{\revised ;}
\par         char FAR *              lpVendorInfo;
\par \} WSADATA;
\par 
\par typedef WSADATA FAR *LPWSADATA;
\par 
\par /*
\par  * Options for use with [gs]etsockopt at the IP level.
\par  */
\par #define IP_OPTIONS      1               /* set/get IP per-packet options */
\par 
\par /*
\par  * Definitions related to sockets: types, address families, options,
\par  * taken from the BSD file sys/socket.h.
\par  */
\par 
\par /*
\par  * This is used instead of -1, since the
\par  * SOCKET type is unsigned.
\par  */
\par #define INVALID_SOCKET  (SOCKET)(~0)
\par #define SOCKET_ERROR            (-1)
\par 
\par /*
\par  * Types
\par  */
\par #define SOCK_STREAM     1               /* stream socket */
\par #define SOCK_DGRAM      2               /* datagram socket */
\par #define SOCK_RAW        3               /* raw-protocol interface */
\par #define SOCK_RDM        4               /* reliably-delivered message */
\par #define SOCK_SEQPACKET  5               /* sequenced packet stream */
\par 
\par /*
\par  * Option flags per-socket.
\par  */
\par #define SO_DEBUG        0x0001          /* turn on debugging info recording */
\par #define SO_ACCEPTCONN   0x0002          /* socket has had listen() */
\par #define SO_REUSEADDR    0x0004          /* allow local address reuse */
\par #define SO_KEEPALIVE    0x0008          /* keep connections alive */
\par #define SO_DONTROUTE    0x0010          /* just use interface addresses */
\par #define SO_BROADCAST    0x0020          /* permit sending of broadcast msgs */
\par #define SO_USELOOPBACK  0x0040          /* bypass hardware when possible */
\par #define SO_LINGER       0x0080          /* linger on close if data present */
\par #define SO_OOBINLINE    0x0100          /* leave received OOB data in line */
\par 
\par #define SO_DONTLINGER   (u_int)(~SO_LINGER)
\par 
\par /*
\par  * Additional options.
\par  */
\par #define SO_SNDBUF       0x1001          /* send buffer size */
\par #define SO_RCVBUF       0x1002          /* receive buffer size */
\par #define SO_SNDLOWAT     0x1003          /* send low-water mark */
\par #define SO_RCVLOWAT     0x1004          /* receive low-water mark */
\par #define SO_SNDTIMEO     0x1005          /* send timeout */
\par #define SO_RCVTIMEO     0x1006          /* receive timeout */
\par #define SO_ERROR        0x1007          /* get error status and clear */
\par #define SO_TYPE         0x1008          /* get socket type */
\par 
\par /*
\par  * TCP options.
\par  */
\par #define TCP_NODELAY     0x0001
\par 
\par /*
\par  * Address families.
\par  */
\par #define AF_UNSPEC       0               /* unspecified */
\par #define AF_UNIX         1               /* local to host (pipes, portals) */
\par #define AF_INET         2               /* internetwork: UDP, TCP, etc. */
\par #define AF_IMPLINK      3               /* arpanet imp addresses */
\par #define AF_PUP          4               /* pup protocols: e.g. BSP */
\par #define AF_CHAOS        5               /* mit CHAOS protocols */
\par #define AF_NS           6               /* XEROX NS protocols */
\par #define AF_{\revised ISO}          7               /* ISO protocols */{\revised 
\par }{\revised #define AF_OSI          AF_ISO          /* OSI is ISO */}
\par #define AF_ECMA         8               /* european computer manufacturers */
\par #define AF_DATAKIT      9               /* datakit protocols */
\par #define AF_CCITT        10              /* CCITT protocols, X.25 etc */
\par #define AF_SNA          11              /* IBM SNA */
\par #define AF_DECnet       12              /* DECnet */
\par #define AF_DLI          13              /* Direct data link interface */
\par #define AF_LAT          14              /* LAT */
\par #define AF_HYLINK       15              /* NSC Hyperchannel */
\par #define AF_APPLETALK    16              /* AppleTalk */
\par #define AF_NETBIOS      17              /* NetBios-style addresses *{\revised /}
\par 
\par #define AF_MAX          1{\revised 8}
\par 
\par /*
\par  * Structure used by kernel to store most
\par  * addresses.
\par  */
\par struct sockaddr \{
\par         u_short sa_family;              /* address family */
\par         char    sa_data[14];            /* up to 14 bytes of direct address */
\par \};
\par 
\par /*
\par  * Structure used by kernel to pass protocol
\par  * information in raw sockets.
\par  */
\par struct sockproto \{
\par         u_short sp_family;              /* address family */
\par         u_short sp_protocol;            /* protocol */
\par \};
\par 
\par /*
\par  * Protocol families, same as address families for now.
\par  */
\par #define PF_UNSPEC       AF_UNSPEC
\par #define PF_UNIX         AF_UNIX
\par #define PF_INET         AF_INET
\par #define PF_IMPLINK      AF_IMPLINK
\par #define PF_PUP          AF_PUP
\par #define PF_CHAOS        AF_CHAOS
\par #define PF_NS           AF_NS
\par #define PF_{\revised ISO}          AF_{\revised ISO
\par }{\revised #define PF_OSI          AF_OSI}
\par #define PF_ECMA         AF_ECMA
\par #define PF_DATAKIT      AF_DATAKIT
\par #define PF_CCITT        AF_CCITT
\par #define PF_SNA          AF_SNA
\par #define PF_DECnet       AF_DECnet
\par #define PF_DLI          AF_DLI
\par #define PF_LAT          AF_LAT
\par #define PF_HYLINK       AF_HYLINK
\par #define PF_APPLETALK    AF_APPLETALK
\par 
\par #define PF_MAX          AF_MAX
\par 
\par /*
\par  * Structure used for manipulating linger option.
\par  */
\par struct  linger \{
\par         u_short l_onoff;                /* option on/off */
\par         u_short l_linger;               /* linger time */
\par \};
\par 
\par /*
\par  * Level number for (get/set)sockopt() to apply to socket itself.
\par  */
\par #define SOL_SOCKET      0xffff          /* options for socket level */
\par 
\par /*
\par  * Maximum queue length specifiable by listen.
\par  */
\par #define SOMAXCONN       5
\par 
\par #define MSG_OOB         0x1             /* process out-of-band data */
\par #define MSG_PEEK        0x2             /* peek at incoming message */
\par #define MSG_DONTROUTE   0x4             /* send without using routing tables */
\par 
\par #define MSG_MAXIOVLEN   16
\par 
\par /*
\par  * Define constant based on rfc883, used by gethostbyxxxx() calls.
\par  */
\par #define MAXGETHOSTSTRUCT        1024
\par 
\par /*
\par  * Define flags to be used with the WSAAsyncSelect() call.
\par  */
\par #define FD_READ         0x01
\par #define FD_WRITE        0x02
\par #define FD_OOB          0x04
\par #define FD_ACCEPT       0x08
\par #define FD_CONNECT      0x10
\par #define FD_CLOSE        0x20
\par 
\par /*
\par  * All Windows Sockets error constants are biased by WSABASEERR from
\par  * the "normal"
\par  */
\par #define WSABASEERR              10000
\par /*
\par  * Windows Sockets definitions of regular Microsoft C error constants
\par  */
\par #define WSAEINTR                (WSABASEERR+4)
\par #define WSAEBADF                (WSABASEERR+9)
\par #define WSAEACCES               (WSABASEERR+13{\revised )}
\par #define WSAEFAULT               (WSABASEERR+14)
\par #define WSAEINVAL               (WSABASEERR+22)
\par #define WSAEMFILE               (WSABASEERR+24)
\par 
\par /*
\par  * Windows Sockets definitions of regular Berkeley error constants
\par  */
\par #define WSAEWOULDBLOCK          (WSABASEERR+35)
\par #define WSAEINPROGRESS          (WSABASEERR+36)
\par #define WSAEALREADY             (WSABASEERR+37)
\par #define WSAENOTSOCK             (WSABASEERR+38)
\par #define WSAEDESTADDRREQ         (WSABASEERR+39)
\par #define WSAEMSGSIZE             (WSABASEERR+40)
\par #define WSAEPROTOTYPE           (WSABASEERR+41)
\par #define WSAENOPROTOOPT          (WSABASEERR+42)
\par #define WSAEPROTONOSUPPORT      (WSABASEERR+43)
\par #define WSAESOCKTNOSUPPORT      (WSABASEERR+44)
\par #define WSAEOPNOTSUPP           (WSABASEERR+45)
\par #define WSAEPFNOSUPPORT         (WSABASEERR+46)
\par #define WSAEAFNOSUPPORT         (WSABASEERR+47)
\par #define WSAEADDRINUSE           (WSABASEERR+48)
\par #define WSAEADDRNOTAVAIL        (WSABASEERR+49)
\par #define WSAENETDOWN             (WSABASEERR+50)
\par #define WSAENETUNREACH          (WSABASEERR+51)
\par #define WSAENETRESET            (WSABASEERR+52)
\par #define WSAECONNABORTED         (WSABASEERR+53)
\par #define WSAECONNRESET           (WSABASEERR+54)
\par #define WSAENOBUFS              (WSABASEERR+55)
\par #define WSAEISCONN              (WSABASEERR+56)
\par #define WSAENOTCONN             (WSABASEERR+57)
\par #define WSAESHUTDOWN            (WSABASEERR+58)
\par #define WSAETOOMANYREFS         (WSABASEERR+59)
\par #define WSAETIMEDOUT            (WSABASEERR+60)
\par #define WSAECONNREFUSED         (WSABASEERR+61)
\par #define WSAELOOP                (WSABASEERR+62)
\par #define WSAENAMETOOLONG         (WSABASEERR+63)
\par #define WSAEHOSTDOWN            (WSABASEERR+64)
\par #define WSAEHOSTUNREACH         (WSABASEERR+65)
\par #define WSAENOTEMPTY            (WSABASEERR+66)
\par #define WSAEPROCLIM             (WSABASEERR+67)
\par #define WSAEUSERS               (WSABASEERR+68)
\par #define WSAEDQUOT               (WSABASEERR+69)
\par #define WSAESTALE               (WSABASEERR+70)
\par #define WSAEREMOTE              (WSABASEERR+71)
\par 
\par /*
\par  * Extended Windows Sockets error constant definitions
\par  */
\par #define WSASYSNOTREADY          (WSABASEERR+91)
\par #define WSAVERNOTSUPPORTED      (WSABASEERR+92)
\par #define WSANOTINITIALISED       (WSABASEERR+93)
\par 
\par /*
\par  * Error return codes from gethostbyname() and gethostbyaddr()
\par  * (when using the resolver). Note that these errors are
\par  * retrieved via WSAGetLastError() and must therefore follow
\par  * the rules for avoiding clashes with error numbers from
\par  * specific implementations or language run-time systems.
\par  * For this reason the codes are based at WSABASEERR+1001.
\par  * Note also that [WSA]NO_ADDRESS is defined only for
\par  * compatibility purposes.
\par  */
\par 
\par #define h_errno         WSAGetLastError()
\par 
\par /* Authoritative Answer: Host not found */
\par #define WSAHOST_NOT_FOUND       (WSABASEERR+1001)
\par #define HOST_NOT_FOUND          WSAHOST_NOT_FOUND
\par 
\par /* Non-Authoritative: Host not found, or SERVERFAIL */
\par #define WSATRY_AGAIN            (WSABASEERR+1002)
\par #define TRY_AGAIN               WSATRY_AGAIN
\par 
\par /* Non recoverable errors, FORMERR, REFUSED, NOTIMP */
\par #define WSANO_RECOVERY          (WSABASEERR+1003)
\par #define NO_RECOVERY             WSANO_RECOVERY
\par 
\par /* Valid name, no data record of requested type */
\par #define WSANO_DATA              (WSABASEERR+1004)
\par #define NO_DATA                 WSANO_DATA
\par 
\par /* no address, look for MX record */
\par #define WSANO_ADDRESS           WSANO_DATA
\par #define NO_ADDRESS              WSANO_ADDRESS
\par 
\par /*
\par  * Windows Sockets errors redefined as regular Berkeley error constants
\par  */
\par #define EWOULDBLOCK             WSAEWOULDBLOCK
\par #define EINPROGRESS             WSAEINPROGRESS
\par #define EALREADY                WSAEALREADY
\par #define ENOTSOCK                WSAENOTSOCK
\par #define EDESTADDRREQ            WSAEDESTADDRREQ
\par #define EMSGSIZE                WSAEMSGSIZE
\par #define EPROTOTYPE              WSAEPROTOTYPE
\par #define ENOPROTOOPT             WSAENOPROTOOPT
\par #define EPROTONOSUPPORT         WSAEPROTONOSUPPORT
\par #define ESOCKTNOSUPPORT         WSAESOCKTNOSUPPORT
\par #define EOPNOTSUPP              WSAEOPNOTSUPP
\par #define EPFNOSUPPORT            WSAEPFNOSUPPORT
\par #define EAFNOSUPPORT            WSAEAFNOSUPPORT
\par #define EADDRINUSE              WSAEADDRINUSE
\par #define EADDRNOTAVAIL           WSAEADDRNOTAVAIL
\par #define ENETDOWN                WSAENETDOWN
\par #define ENETUNREACH             WSAENETUNREACH
\par #define ENETRESET               WSAENETRESET
\par #define ECONNABORTED            WSAECONNABORTED
\par #define ECONNRESET              WSAECONNRESET
\par #define ENOBUFS                 WSAENOBUFS
\par #define EISCONN                 WSAEISCONN
\par #define ENOTCONN                WSAENOTCONN
\par #define ESHUTDOWN               WSAESHUTDOWN
\par #define ETOOMANYREFS            WSAETOOMANYREFS
\par #define ETIMEDOUT               WSAETIMEDOUT
\par #define ECONNREFUSED            WSAECONNREFUSED
\par #define ELOOP                   WSAELOOP
\par #define ENAMETOOLONG            WSAENAMETOOLONG
\par #define EHOSTDOWN               WSAEHOSTDOWN
\par #define EHOSTUNREACH            WSAEHOSTUNREACH
\par #define ENOTEMPTY               WSAENOTEMPTY
\par #define EPROCLIM                WSAEPROCLIM
\par #define EUSERS                  WSAEUSERS
\par #define EDQUOT                  WSAEDQUOT
\par #define ESTALE                  WSAESTALE
\par #define EREMOTE                 WSAEREMOTE
\par 
\par /* Socket function prototypes */
\par 
\par {\revised #ifdef __cplusplus
\par }{\revised extern "C" \{
\par }{\revised #endif}
\par 
\par SOCKET PASCAL FAR accept (SOCKET s, struct sockaddr FAR *addr,
\par                           int FAR *addrlen);
\par 
\par int PASCAL FAR bind (SOCKET s, {\revised const }struct sockaddr FAR *addr, int namelen);
\par 
\par int PASCAL FAR closesocket (SOCKET s);
\par 
\par int PASCAL FAR connect (SOCKET s, {\revised const }struct sockaddr FAR *name, int namelen);
\par 
\par int PASCAL FAR ioctlsocket (SOCKET s, long cmd, u_long FAR *argp);
\par 
\par int PASCAL FAR getpeername (SOCKET s, struct sockaddr FAR *name,
\par                             int FAR * namelen);
\par 
\par int PASCAL FAR getsockname (SOCKET s, struct sockaddr FAR *name,
\par                             int FAR * namelen);
\par 
\par int PASCAL FAR getsockopt (SOCKET s, int level, int optname,
\par                            char FAR * optval, int FAR *optlen);
\par 
\par u_long PASCAL FAR htonl (u_long hostlong);
\par 
\par u_short PASCAL FAR htons (u_short hostshort);
\par 
\par unsigned long PASCAL FAR inet_addr ({\revised const }char FAR * cp){\revised ;}
\par 
\par char FAR * PASCAL FAR inet_ntoa (struct in_addr in);
\par 
\par int PASCAL FAR listen (SOCKET s, int backlog);
\par 
\par u_long PASCAL FAR ntohl (u_long netlong);
\par 
\par u_short PASCAL FAR ntohs (u_short netshort);
\par 
\par int PASCAL FAR recv (SOCKET s, char FAR * buf, int len, int flags);
\par 
\par int PASCAL FAR recvfrom (SOCKET s, char FAR * buf, int len, int flags,
\par                          struct sockaddr FAR *from, int FAR * fromlen);
\par 
\par int PASCAL FAR select (int nfds, fd_set FAR *readfds, fd_set FAR *writefds{\revised ,}
\par                        fd_set FAR *exceptfds, {\revised const }struct timeval FAR *timeout);
\par 
\par int PASCAL FAR send (SOCKET s, {\revised const }char FAR * buf, int len, int flags);
\par 
\par int PASCAL FAR sendto (SOCKET s, {\revised const }char FAR * buf, int len, int flags,
\par                        {\revised const }struct sockaddr FAR *to, int tolen);
\par 
\par int PASCAL FAR setsockopt (SOCKET s, int level, int optname,
\par                            {\revised const }char FAR * optval, int optlen);
\par 
\par int PASCAL FAR shutdown (SOCKET s, int how);
\par 
\par SOCKET PASCAL FAR socket (int af, int type, int protocol);
\par 
\par /* Database function prototypes */
\par 
\par struct hostent FAR * PASCAL FAR gethostbyaddr({\revised const }char FAR * addr,
\par                                               int len, int type);
\par 
\par struct hostent FAR * PASCAL FAR gethostbyname({\revised const }char FAR * name);
\par 
\par int PASCAL FAR gethostname (char FAR * name, int namelen){\revised ;}
\par 
\par struct servent FAR * PASCAL FAR getservbyport(int port, {\revised const }char FAR * proto);
\par 
\par struct servent FAR * PASCAL FAR getservbyname({\revised const }char FAR * name,
\par                                               {\revised const }char FAR * proto);
\par 
\par struct protoent FAR * PASCAL FAR getprotobynumber(int proto);
\par 
\par struct protoent FAR * PASCAL FAR getprotobyname({\revised const }char FAR * name);
\par 
\par /* Microsoft Windows Extension function prototypes */
\par 
\par int PASCAL FAR WSAStartup(WORD wVersionRequired, LPWSADATA lpWSAData);
\par 
\par int PASCAL FAR WSACleanup(void);
\par 
\par void PASCAL FAR WSASetLastError(int iError);
\par 
\par int PASCAL FAR WSAGetLastError(void);
\par 
\par BOOL PASCAL FAR WSAIsBlocking(void);
\par 
\par int PASCAL FAR WSAUnhookBlockingHook(void);
\par 
\par FARPROC PASCAL FAR WSASetBlockingHook(FARPROC lpBlockFunc);
\par 
\par int PASCAL FAR WSACancelBlockingCall(void);
\par 
\par HANDLE PASCAL FAR WSAAsyncGetServByName(HWND hWnd, u_int wMsg,
\par                                         {\revised const }char FAR * name, {\revised 
\par }{\revised                                    }{\revised      const }char FAR * proto,
\par                                         char FAR * buf, int buflen);
\par 
\par HANDLE PASCAL FAR WSAAsyncGetServByPort(HWND hWnd, u_int wMsg, int port,
\par                                         {\revised const }char FAR * proto, char FAR * buf,
\par                                         int buflen);
\par 
\par HANDLE PASCAL FAR WSAAsyncGetProtoByName(HWND hWnd, u_int wMsg,
\par                                          {\revised const }char FAR * name, char FAR * buf,
\par                                          int buflen);
\par 
\par HANDLE PASCAL FAR WSAAsyncGetProtoByNumber(HWND hWnd, u_int wMsg,
\par                                            int number, char FAR * buf,
\par                                            int buflen);
\par 
\par HANDLE PASCAL FAR WSAAsyncGetHostByName(HWND hWnd, u_int wMsg,
\par                                         {\revised const }char FAR * name, char FAR * buf,
\par                                         int buflen);
\par 
\par HANDLE PASCAL FAR WSAAsyncGetHostByAddr(HWND hWnd, u_int wMsg,
\par                                         {\revised const }char FAR * addr, int len, int type,
\par                                         {\revised const }char FAR * buf, int buflen);
\par 
\par int PASCAL FAR WSACancelAsyncRequest(HANDLE hAsyncTaskHandle);
\par 
\par int PASCAL FAR WSAAsyncSelect(SOCKET s, HWND hWnd, u_int wMsg,
\par                                long lEvent);
\par 
\par {\revised #ifdef __cplusplus
\par }{\revised \}
\par }{\revised #endif}
\par 
\par /* Microsoft Windows Extended data types */
\par typedef struct sockaddr SOCKADDR;
\par typedef struct sockaddr *PSOCKADDR;
\par typedef struct sockaddr FAR *LPSOCKADDR;
\par 
\par typedef struct sockaddr_in SOCKADDR_IN;
\par typedef struct sockaddr_in *PSOCKADDR_IN;
\par typedef struct sockaddr_in FAR *LPSOCKADDR_IN;
\par 
\par typedef struct linger LINGER;
\par typedef struct linger *PLINGER;
\par typedef struct linger FAR *LPLINGER;
\par 
\par typedef struct in_addr IN_ADDR;
\par typedef struct in_addr *PIN_ADDR;
\par typedef struct in_addr FAR *LPIN_ADDR;
\par 
\par typedef struct fd_set FD_SET;
\par typedef struct fd_set *PFD_SET;
\par typedef struct fd_set FAR *LPFD_SET;
\par 
\par typedef struct hostent HOSTENT;
\par typedef struct hostent *PHOSTENT;
\par typedef struct hostent FAR *LPHOSTENT;
\par 
\par typedef struct servent SERVENT;
\par typedef struct servent *PSERVENT;
\par typedef struct servent FAR *LPSERVENT;
\par 
\par typedef struct protoent PROTOENT;
\par typedef struct protoent *PPROTOENT;
\par typedef struct protoent FAR *LPPROTOENT;
\par 
\par typedef struct timeval TIMEVAL{\revised ;}
\par typedef struct timeval *PTIMEVAL{\revised ;}
\par typedef struct timeval FAR *LPTIMEVAL{\revised ;}
\par 
\par /*
\par  * Windows message parameter composition and decomposition
\par  * macros.
\par  *
\par  * WSAMAKEASYNCREPLY is intended for use by the Windows Sockets implementation
\par  * when constructing the response to a WSAAsyncGetXByY({\revised ) routine.}
\par  */
\par #define WSAMAKEASYNCREPLY(buflen,error)     MAKELONG(buflen,error)
\par /*
\par  * WSAMAKESELECTREPLY is intended for use by the Windows Sockets implementation
\par  * when constructing the response to WSAAsyncSelect(){\revised .}
\par  */
\par #define WSAMAKESELECTREPLY(event,error)     MAKELONG(event,error)
\par /*
\par  * WSAGETASYNCBUFLEN is intended for use by the Windows Sockets application
\par  * to extract the buffer length from the lParam in the response
\par  * to a WSAGetXByY().
\par  */
\par #define WSAGETASYNCBUFLEN(lParam)           LOWORD(lParam)
\par /*
\par  * WSAGETASYNCERROR is intended for use by the Windows Sockets application
\par  * to extract the error code from the lParam in the response
\par  * to a WSAGetXByY().
\par  */
\par #define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
\par /*
\par  * WSAGETSELECTEVENT is intended for use by the Windows Sockets application
\par  * to extract the event code from the lParam in the response
\par  * to a WSAAsyncSelect().
\par  */
\par #define WSAGETSELECTEVENT(lParam)           LOWORD(lParam)
\par /*
\par  * WSAGETSELECTERROR is intended for use by the Windows Sockets application
\par  * to extract the error code from the lParam in the response
\par  * to a WSAAsyncSelect().
\par  */
\par #define WSAGETSELECTERROR(lParam)           HIWORD(lParam)
\par 
\par #endif  /* _WINSOCKAPI_ */
\par \pard \s30\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760 
\par \pard\plain \fs20\lang1033 {\b\ul {\*\bkmkstart AppendixB}\sect }\sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 Appendix B: Notes for Windows Sockets Suppliers 
{\field{\*\fldinst PAGE}{\fldrslt 131}}
\par }\pard\plain \s254\sb240 \b\f2\ul\lang1033 {\*\bkmkend AppendixB}Appendix B.  Notes for Windows Sockets Suppliers
\par \pard\plain \s253\sb120 \b\f2\lang1033 B.1 Introduction
\par \pard\plain \fs20\lang1033 A Windows Sockets implementation must implement ALL the functionality described in the Windows Sockets documentation.  Validation of compliance is discussed in section {\field{\*\fldinst ref test_suite}{\fldrslt B.8}}.
\par \pard {\b 
\par }\pard Windows Sockets Version 1.{\revised 1} implementations must support both TCP and UDP type sockets.  An implementation may support raw sockets (of type SOCK_RAW), but their use is deprecated.
\par \pard 
\par \pard 
Certain APIs documented above have special notes for Windows Sockets implementors.  A Windows Sockets implementation should pay special attention to conforming to the API as documented.  The Special Notes are provided for assistance and clarification.

\par \pard {\b 
\par }\pard\plain \s253\sb120 \b\f2\lang1033 B.2 Windows Sockets Components
\par \pard\plain \s252 \b\f2\lang1033 B.2.1 Development Components
\par \pard\plain \fs20\lang1033 The Windows Sockets development components for use by Windows Sockets application developers will be provided by each Windows Sockets supplier.  These Windows Sockets development components are:
\par \pard \fi-2880\li2880 
\par {\ul Component\tab Description
\par }Windows Sockets Documentation\tab This document
\par WINSOCK.LIB file\tab Windows Sockets API Import Library
\par WINSOCK.H file\tab Windows Sockets Header File
\par NETDB.H file\tab Berkeley Compatible Header File
\par ARPA/INET.H file\tab Berkeley Compatible Header File
\par SYS/TIME.H file\tab Berkeley Compatible Header File
\par SYS/SOCKET.H file\tab Berkeley Compatible Header File
\par NETINET/IN.H file\tab Berkeley Compatible Header File
\par 
\par \pard\plain \s252 \b\f2\lang1033 B.2.2 Run Time Components
\par \pard\plain \fi-2880\li2880 \fs20\lang1033 The run time component provided by each Windows Sockets supplier is:
\par 
\par {\ul Component\tab Description
\par }WINSOCK.DLL\tab The Windows Sockets API implementation DLL
\par 
\par \pard\plain \s253\sb120 \b\f2\lang1033 B.3 Multithreadedness and blocking routines.
\par \pard\plain \fs20\lang1033 Data areas returned by, for example, the getXbyY() routines MUST be on a per thread basis.
\par 
\par \pard Note that an application MUST be prevented from ma
king multiple nested Windows Sockets function calls.  Only one outstanding function call will be allowed for a particular task.  Any Windows Sockets call performed when an existing blocking call is already outstanding will fail with an error code of WSAEI
NPROGRESS.  There are two exceptions to this restriction: WSACancelBlockingCall() and WSAIsBlocking() may be called at any time.  Windows Sockets suppliers should note that although preliminary drafts of this specification indicated that the restriction o
nly applied to blocking function calls, and that it would be permissible to make non-blocking calls while a blocking call was in progress, this is no longer true.
\par \pard {\b 
\par }\pard 
Regarding the implementation of blocking routines, the solution in Windows Sockets is to simulate the blocking mechanism by having each routine call PeekMessage() as it waits for the completion of its operation.  In anticipation of this, the function WSAS
etBlockingHook() is provided to allow the programmer to define a special routine to be called instead of the default PeekMessage() loop.  The blocking hook functions are discussed in more detail in {\field{\*\fldinst ref WSASetBlockingHook}{\fldrslt 
4.3.13}}, {\b WSASetBlockingHook()}.
\par \pard {\b 
\par }\pard\plain \s253\sb120 \b\f2\lang1033 B.4 Database Files
\par \pard\plain \fs20\lang1033 The database routines in the {\b getXbyY()} family ({\b gethostbyaddr()}
, etc.) were originally designed (in the first Berkeley UNIX releases) as mechanisms for looking up information in text databases.  A Windows Sockets supplier may choose to employ local files OR a name service to provide some or all of this information.  
If local files exist, the format of the files must be identical to that used in BSD UNIX, allowing for the differences in text file formats.  
\par \pard {\b 
\par }\pard\plain \s253\sb120 \b\f2\lang1033 B.5 FD_ISS{\*\bkmkstart B5_FD_ISSET}{\*\bkmkend B5_FD_ISSET}ET
\par \pard\plain \fs20\lang1033 It is necessary to implement the FD_ISSET Berkeley macro using a supporting function: {\b __WSAFDIsSet()}
.  It is the responsibility of a Windows Sockets implementation to make this available as part of the Windows Sockets API.  Unlike the other functions exported by a Windows Sockets DLL, however, this function is not intended to be invoked directly by Wind
ows Sockets applications: it should be used only to support the FD_ISSET macro.  The source code for this function is listed below:
\par \pard 
\par \pard {\f3 int FAR
\par }{\f3 __WSAFDIsSet(SOCKET fd, fd_set FAR *set)
\par }{\f3 \{
\par }{\f3     int i = set->}{\f3\revised fd_}{\f3 count;
\par }{\f3 
\par }{\f3     while (i--)
\par }{\f3 \tab if (set->fd_array[i] == fd)
\par }{\f3 \tab     return 1;
\par }{\f3 
\par }{\f3     return 0;
\par }{\f3 \}
\par }\pard 
\par \pard\plain \s253\sb120 \b\f2\lang1033 B.6 Error Codes
\par \pard\plain \fs20\lang1033 In order to avoid conflict between various compiler environments Windows Sockets implementations MUST return the error codes listed in the API specification, using the manifest constants beginning with "WSA".  T
he Berkeley-compatible error code definitions are provided solely for compatibility purposes for applications which are being ported from other platforms.
\par \pard 
\par \pard\plain \s253\sb120 \b\f2\lang1033 B.7 DLL Ordinal Numbers
\par \pard\plain \fs20\lang1033 The {\b winsock.def }file for use by every Windows Sockets implementation is as follows.{\revised 
  Ordinal values starting at 1000 are reserved for Windows Sockets implementors to use for exporting private interfaces to their DLLs.  A Windows Sockets implementation must not use any ordinals 999 and below except for those APIs listed below.  }{
\revised An application which wishes to work with any Windows Sockets DLL must use only those routines listed below; using a private export makes an application dependent on a particular Windows Sockets implementation.}
\par \pard 
\par \pard\plain \s30\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760 \f5\fs16\lang1033 ;  
\par ;         File: winsock.def 
\par ;       System: MS-Windows 3.x 
\par ;      Summary: Module definition file for Windows Sockets DLL.  
\par ;  
\par 
\par LIBRARY         WINSOCK         ; Application's module name 
\par 
\par DESCRIPTION     'BSD Socket API for Windows' 
\par 
\par EXETYPE         WINDOWS         ; required for all windows applications 
\par 
\par STUB            'WINSTUB.EXE'   ; generates error message if application 
\par                                 ; is run without Windows 
\par 
\par ;CODE can be FIXED in memory because of potential upcalls 
\par CODE            PRELOAD         FIXED 
\par 
\par ;DATA must be SINGLE and at a FIXED location since this is a DLL 
\par DATA            PRELOAD         FIXED           SINGLE
\par 
\par HEAPSIZE        1024 
\par STACKSIZE       16384 
\par 
\par ; All functions that will be called by any Windows routine 
\par ; must be exported{\revised .  Any additional exports beyond those defined
\par }{\revised ; here must have ordinal numbers 1000 or above.} 
\par 
\par EXPORTS 
\par         accept                         @1 
\par         bind                           @2 
\par         closesocket                    @3 
\par         connect                        @4 
\par         getpeername                    @5 
\par         getsockname                    @6 
\par         getsockopt                     @7 
\par         htonl                          @8 
\par         htons                          @9 
\par         inet_addr                      @10 
\par         inet_ntoa                      @11 
\par         ioctlsocket                    @12 
\par         listen                         @13 
\par         ntohl                          @14 
\par         ntohs                          @15 
\par         recv                           @16 
\par         recvfrom                       @17 
\par         select                         @18 
\par         send                           @19 
\par         sendto                         @20 
\par         setsockopt                     @21 
\par         shutdown                       @22 
\par         socket                         @23 
\par 
\par         gethostbyaddr                  @51 
\par         gethostbyname                  @52 
\par         getprotobyname                 @53 
\par         getprotobynumber               @54 
\par         getservbyname                  @55 
\par         getservbyport                  @56 
\par         gethostname                    @{\revised 57}
\par 
\par         WSAAsyncSelect                 @101 
\par         WSAAsyncGetHostByAddr          @102 
\par         WSAAsyncGetHostByName          @103 
\par         WSAAsyncGetProtoByNumber       @104 
\par         WSAAsyncGetProtoByName         @105 
\par         WSAAsyncGetServByPort          @106 
\par         WSAAsyncGetServByName          @107 
\par         WSACancelAsyncRequest          @108 
\par         WSASetBlockingHook             @109 
\par         WSAUnhookBlockingHook          @110 
\par         WSAGetLastError                @111 
\par         WSASetLastError                @112 
\par         WSACancelBlockingCall          @113 
\par         WSAIsBlocking                  @114 
\par         WSAStartup                     @115 
\par         WSACleanup                     @116 
\par 
\par         __WSAFDIsSet                   @151 
\par 
\par         WEP                            @500    RESIDENTNAME 
\par 
\par ;eof 
\par 
\par \pard\plain \s253\sb120 \b\f2\lang1033 {\*\bkmkstart test_suite}B.8{\*\bkmkend test_suite} Validation Suite
\par \pard\plain \sb240 \fs20\lang1033 {\f4 T}{\f4\revised he Windows Sockets }{\f4 API }{\f4\revised Test}{\f4 er}{\f4\revised  }{\f4 (WSAT)}{\f4\revised  to ensure Windows Sockets compatibility }{\f4 
between Windows Sockets DLL implementations is currently in beta test}{\f4\revised .  This }{\f4 beta}{\f4\revised  version includes functionality testing of the Windows }{\f4\revised 
Sockets interface and is supported by a comprehensive scripting language.  }{\f4 The final version of WSAT will be available in Spring 1993.  If you wish to receive the tester or more information}{\f4\revised  on the beta}{\f4 ,}{\f4\revised 
 send email to wsat@microsoft.com. 
\par }\pard \sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 Appendix C: For Further Reference {\field{\*\fldinst PAGE}{\fldrslt 52}}
\par }\pard\plain \s254\sb240 \b\f2\ul\lang1033 Appendix C.  For Further Reference
\par \pard\plain \fs20\lang1033 
\par \pard This specification is intended to cover the Windows Sockets interface to TCP/IP in detail.  Many details of TCP/IP and Windows, however, are intentionally omitted in the interest of brevity, and this specification often assumes backgr
ound knowledge of these topics.  For more information, the following references may be helpful:
\par \pard 
\par \pard\plain \s22\fi-1440\li1440 \fs20\lang1033 Braden, R.[1989], {\i RFC 1122, Requirements for Internet Hosts--Communication Layers}, Internet Engineering Task Force.
\par \pard \s22\fi-1440\li1440 
\par \pard \s22\fi-1440\li1440 Comer, D. [1991], {\i Internetworking with TCP/IP Volume I: Principles, Protocols, and Architecture, }Prentice Hall, Englewood Cliffs, New Jersey.
\par \pard \s22\fi-1440\li1440 
\par \pard \s22\fi-1440\li1440 Comer, D. and Stevens, D. [1991], {\i Internetworking with TCP/IP Volume II: Design, Implementation, and Internals, }Prentice Hall, Englewood Cliffs, New Jersey.
\par \pard \s22\fi-1440\li1440 
\par \pard \s22\fi-1440\li1440 Comer, D. and Stevens, D. [1991], {\i Internetworking with TCP/IP Volume III: Client-Server Programming and Applications, }Prentice Hall, Englewood Cliffs, New Jersey.
\par \pard \s22\fi-1440\li1440 
\par Leffler, S. et al., {\i An Advanced 4.3BSD Interprocess Communication Tutorial.}
\par 
\par Petzold, C. [1992], {\i Programming Windows 3.1, }Microsoft Press, Redmond, Washington.
\par 
\par \pard \s22\fi-1440\li1440 Stevens, W.R. [1990], {\i Unix Network Programming, }Prentice Hall, Englewood Cliffs, New Jersey.\sect \sectd \linex0\endnhere {\header \pard\plain \s243\qr\sa120\brdrb\brdrth\brdrw30\brsp20 \tqc\tx4320\tqr\tx8640 \b\f2\lang1033 
Appendix D: Background Information {\field{\*\fldinst PAGE}{\fldrslt 52}}
\par }\pard\plain \s254\sb240 \b\f2\ul\lang1033 Appendix D.  Background Information
\par \pard\plain \s253\sb120 \b\f2\lang1033 D.1 Legal Status of Windows Sockets{\revised  }
\par \pard\plain \fs20\lang1033 {\b\revised  }{\b }{\b 
\par }\pard {\f4\revised 
The copyright for the Windows Sockets specification is owned by the specification authors listed on the title page.  Permission is granted to redistribute this specification in any form, provided that the contents of the specification are not modified.  W
}{\f4\revised indows Sockets implementors are encouraged to include this specification with their product documentation.
\par }\pard {\f4\revised 
\par }\pard {\f4\revised The Windows Sockets logo on the title page of this document is meant for use on both Windows Sockets implementations and for applications that use}{\f4\revised 
 the Windows Sockets interface.  Use of the logo is encouraged on packaging, documentation, collateral, and advertising.  The logo is 
\par }\pard {\f4\revised available on microdyne.com in pub/winsock as winsock.bmp.  The suggested color for the logo's title bar is blue, the electrical socket grey, and the text and outline black.  
\par }\pard {\f4\revised 
\par }{\f4\revised 
\par }\pard\plain \s253\sb120 \b\f2\lang1033 {\revised D.2 The Story Behind the Windows Sockets Icon
\par }\pard\plain \fs20\lang1033 {\revised 
\par }{\revised (by Alistair Banks}, Microsoft Corporation{\revised )
\par }{\revised 
\par }\pard {\f4\revised We thought we'd do a "Wind Sock" at one stage--but you try to get that into 32x32 bits! It would have}{\f4\revised  had to look wavy and colorful, and... well, it just didn}{\f4 '}{\f4\revised 
t work. Also, our graphics designers have "opinions"
\par }{\f4\revised about the icons truly representing what they are--people would have thought this was "The colorful wavy tube specification 1.0!"
\par }\pard {\f4\revised 
\par }\pard {\f4\revised I tried to explain "API" "Programming Interface" to the artist--we ended up with toolbox icons with little flying windows
\par }\pard {\f4\revised 
\par }\pard {\f4\revised Then we came to realise that we should be going after the shortened form of the name, rather the name in full... Windows Sockets... And so we w}{\f4\revised ent for that - so she drew (now remember I'm English and you're
\par }\pard {\f4\revised probably American}{\f4 )}{\f4\revised  "Windows Spanner"}{\f4 ,}{\f4\revised  a}{\f4 .}{\f4\revised k}{\f4 .}{\f4\revised a}{\f4 .}{\f4\revised  a socket}{\f4  }{\f4\revised wrench.  In the U}{\f4 .}{\f4\revised S}{\f4 .}{\f4\revised 
 you'd have been talking about the "Windows Socket spec" OK, but in England that would have been transl}{\f4 a}{\f4\revised ted as "Windows Spanner Spec 1.0" - so we went to Electrical sockets - well the first ones cam}{\f4 e}{\f4\revised 
 out looking like "Windows Pignose Spec 1.0"!!!!
\par }\pard {\f4\revised 
\par }\pard {\f4\revised So how do you use 32x32, get an international electrical socket! You take the square type (American & English OK, Europe &}{\f4\revised  Australia are too rounded)--you choose the American one, because it}{\f4 '}{\f4\revised 
s on the wall in front of you (and it}{\f4 '}{\f4\revised s more compact (but less safe, IMHO) and then you turn it upside down, thereby compromising its nationality!
\par }\pard {\f4 
\par }{\f4 [IMHO = "In My Humble Opinion"--ed.]}{\f4\revised 
\par }
\par }