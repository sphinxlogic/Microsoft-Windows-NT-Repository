{\rtf1\ansi \deff0{\fonttbl{\f0\froman Tms Rmn;}{\f1\fdecor SYMBOL;}{\f2\fswiss Helv;}{\f3\fmodern COURIER;}{\f4\fmodern lineprinter;}{\f5\fdecor ZAPFDINGBATS;}{\f6\fswiss HELVETICA;}{\f7\fnil tmsrmn;}{\f8\froman TIMES ROMAN;}
{\f9\fnil Times New Roman;}{\f10\froman ROMAN;}{\f11\fnil Arial;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;}
{\stylesheet{\s242\sl240\tqc\tx4320\tqr\tx8640 \f9 \sbasedon0\snext242 footer;}{\s252\fi-1440\li1440\sa120\sl480\tqr\tx8640 \b\f11 \sbasedon0\snext255 heading 3;}{\s253\sb120\sa240\sl480\tqr\tx8640 \b\f11 \sbasedon0\snext0 heading 2;}{
\s254\sb240\sa120\sl480\tqr\tx8640 \b\f11 \sbasedon0\snext0 heading 1;}{\s255\li720\sl240\tqr\tx8640 \f9 \sbasedon0\snext255 Normal Indent;}{\sl240\tqr\tx8640 \f9 \snext0 Normal;}{\s1\sa240\sl240\keepn \snext1 PK;}{
\s2\li576\sl240\keepn\tx1152\tx1728\tx2304\tx2880\tx3456\tx4032\tx4608\tx5184\tx5760\tx6336\tx6912 \f4\fs17 \snext2 PC;}{\s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 \f9 \sbasedon0\snext4 bullet;}{\s5\sl240\tx3600\tx7200\tqr\tx8640 \f11\fs20 
\sbasedon0\snext5 code;}{\s6\li720\sl240\tx3600\tx7200\tqr\tx8640 \f11\fs20 \sbasedon5\snext6 code2;}{\s7\sl240\tqr\tx8640 \f9 \sbasedon0\snext7 foot2;}{\s8\fi-432\li720\sa120\sl240\tx720\tqr\tx8640 \f9 \sbasedon4\snext8 bullet2;}{
\s9\li720\sa120\sl240\tx2880\tx5760 \b\f9\ul \sbasedon255\snext9 ints;}}{\info{\title Win 3.1 Robustness Work For Win32}{\author David Britton}{\operator Bob Muglia}{\creatim\yr1991\mo8\dy12\hr9\min35}{\revtim\yr1991\mo8\dy12\hr16\min8}
{\printim\yr1991\mo8\dy20\hr19\min25}{\version16}{\edmins324}{\nofpages21}{\nofwords6599}{\nofchars44532}{\vern8368}}\margl1440\margr1440\widowctrl\ftnbj\revbar1\revprop0 \sectd \linex0\endnhere\titlepg {\footer \pard\plain \s7\sl240\tqr\tx8640 \f9 
Programming Considerations For 32-Bit Windows, August 1991\tab {\field{\*\fldinst PAGE}{\fldrslt 21}}
\par }\pard\plain \sl480\tqr\tx8640 \f9 {\b 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }{\b\f11\fs36 Microsoft Corporation
\par }{\b 
\par }{\b\f11\fs36 Programming Considerations
\par For 32-Bit Windows Operating Systems
\par }{\i 
\par }{\f11\fs28 August, 1991
\par }{\i 
\par 
\par }\pard\plain \s254\sb240\sa120\sl480\tqr\tx8640 \b\f11 {\i \page }Abstract
\par \pard\plain \sl240\tqr\tx8640 \f9 The first prerelease Microsoft{\fs12\up6 \'ae} Windows{\scaps\fs12\up6 TM}
 32-Bit Software Development Kit will be available soon.  During the beta testing of Windows 3.1, developers can update application source code and make changes that will result in a robust Windows 3.1 application as well as prepare the application for tr
ansition into the the full 32-bit environment provided by the Windows 32-Bit API.  This paper is not a call to start creating 32-bit source code but rather a highlight of the changes that will benefit upd
ating source code for Windows 3.1 now and Windows 32-Bit applications later.
\par \pard\plain \s254\sb240\sa120\sl480\tqr\tx8640 \b\f11 1. Goals of Microsoft{\fs12\up6 \'ae} Windows{\scaps\fs12\up6 TM} 32-Bit API
\par \pard\plain \sl240\tqr\tx8640 \f9 The creation of the Windows 32-Bit application programming interface (Windows 32 API) focused on five goals:
\par \pard \sl240\tqr\tx8640 
\par \pard\plain \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 \f9 1.\tab Provide a 32-bit migration path for existing Windows applications
\par 2. \tab Make porting a Windows application to Windows 32 as easy as possible 
\par \pard \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 3.\tab Create an efficient mapping layer to run Windows 3.x binaries on Windows 32-Bit systems
\par 4. \tab Support a single source code base for creating Windows 3.x and Windows 32-Bit binaries
\par 5.{\f5 \tab }Offer an identical Windows 32-Bit API on both Windows NT-mode and a future release of Windows Enhanced-mode
\par \pard\plain \sl240\tqr\tx8640 \f9 
To achieve these goals, Microsoft derived the Windows 32-Bit API from the existing Windows 3.1 API, disallowing arbitrary name changes of data types, functions, and structures. At first glance, a Windows 32-Bit application is indistinguishable from an exi
sting Windows 3.0 or 3.1 (hereafter referred to as Windows 3.x) application, both from an end
-user's perspective and from a quick inspection of the source code.  A native Windows 32-Bit application (unlike its cousin which uses the Windows 3.x API) can take full advantage of large linear memory allocation, multiple threads for background tasks an
d calculations, local and remote interprocess communication via named pipes, and other features detailed in {\b\i The Windows 32-Bit API: An Overview.} {\b\i 
\par }\pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 The Windows 32-Bit API will first appear on Windows NT for uniprocessor and multiprocessor Intel386{\scaps\fs12\up6 TM} and Intel486{\scaps\fs12\up6 TM}
 systems and for new RISC-based systems.  A future version of Windows Enhanced-mode will also support the Windows 32-Bit API.  All Windows 32 features are supported by both Windows NT-Mode and a future release of Windows Enhanced-mode, including linear ad
dress space, threads, and preemptive multitasking. Windows 32-Bit applications running Windows Enhanced-mode or Windows NT-mode will be binary compatible with Intel{\fs12\up6 \'ae}
 processors and source compatible with Windows NT running on RISC processors.  
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 \column This paper concentrates on two aspects of Windows 32: 
\par \pard \sl240\tqr\tx8640 
\par \pard\plain \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 \f9 1. \tab Steps that developers can taken today while working on Windows 3.1 applications to better support binary compatibility of these applications on Windows NT; 
\par \pard \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 2. \tab 
Techniques that developers can use to create Windows code that is more portable and  that will make it easier to create Windows 32-Bit versions of the application when Windows 32-Bit Software Development Kits are available.
\par \pard\plain \s254\sb240\sa120\sl480\tqr\tx8640 \b\f11 2. Binary Compatibility
\par \pard\plain \sl240\tqr\tx8640 \f9 Windows 32-Bit systems will be able to
 run existing Windows 3.x applications with interoperability via dynamic data exchange (DDE), object linking and embedding (OLE), metafiles, and the clipboard with other Windows 3.x applications and with native Windows 32-Bit applications. Windows 3.x app
lications and Windows 32-Bit applications will exist side-by-side on the same display rather than running in separate screen groups.  Windows 3.x applications will be fully compatible with Windows NT if developers follow these rules: 
\par \pard \sl240\tqr\tx8640 {\f8 
\par }\pard\plain \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 \f9 {\f5 u} \tab Ensure that Windows 3.x applications run in Standard/Enhanced mode.
\par {\f5 u} \tab Use published Windows 3.x APIs, messages, and structures.
\par {\f5 u} \tab Do not modify WIN.INI directly; use a profile string API.
\par {\f5 u} \tab Restrict direct port I/O (only standard devices).
\par {\f5 u} \tab Do not directly access the disk controller; doing so is a security violation.
\par {\f5 u} \tab Do not modify the system date and time; doing so is a security violation.
\par \pard\plain \sl240\tqr\tx8640 \f9 Windows NT provides U.S. government-level security capabilities that preclude allowing applications direct access to hard
ware. Rules 4-6 above do not apply to future versions of Windows Enhanced-mode that will support the Windows 32-Bit API.  The restriction is a feature specific to Windows NT.
\par \pard\plain \s253\sb120\sa240\sl480\tqr\tx8640 \b\f11 2.1 Design Requirements
\par \pard\plain \sl240\tqr\tx8640 \f9 Mapping-layer technology has been offered in the past to allow Windows-based  applications to run on OS/2{\fs12\up6 \'ae}
.  Past solutions such as Windows Libraries for OS/2 (WLO) required special runtime libraries and DLLs before Windows-based applications could run on OS/2.  ISVs must ship WLO mapping-layer DLLs along with
 their applications, which complicates distributing and installing them. This approach is unacceptable on Windows 32-Bit systems.  
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 \column To achieve binary compatibility and high performance on Windows 32-Bit systems, developers of  Windows version 3.x applications:
\par \pard \sl240\tqr\tx8640 
\par \pard\plain \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 \f9 {\f5 u \tab }do not need to recompile the source code,
\par {\f5 u \tab }do not need to use special runtime libraries,
\par \pard \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 {\f5 u \tab }and do not need to develop or acquire special tools to make executables \tab   \tab    compatible.  
\par \pard\plain \sl240\tqr\tx8640 \f9 The ability to run Windows 3.x binaries lets a deve
loper update to Windows 32-Bit systems and continue to use existing Windows 3.x applications as well as  native Windows 32-Bit applications as they become available.  Native Windows 32-Bit applications will take advantage of the higher performance linear 
32-bit addressing and enormous capacity increase for data processing.  Microsoft will encourage Windows developers to test their products on pre-release versions of Windows NT through a Windows NT beta test program.
\par \pard\plain \s253\sb120\sa240\sl480\tqr\tx8640 \b\f11 2.2 Supported Features
\par \pard\plain \sl240\tqr\tx8640 \f9 The following is
 a list of many of Windows 3.x features inherently supported on Windows 32-Bit systems.  This list shows that existing Windows-applications can be binary compatible with future Windows 32-Bit systems with little work on the part of developers.  It also il
lustrates that complex windowing, graphics, and low-level operating system reliance by Windows 3.x binaries will be completely supported.
\par \pard \sl240\tqr\tx8640 
\par Major user interface features that are fully supported include:
\par 
\par \pard\plain \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 \f9 {\f5 u \tab }Multiple document interface messages and default message handling
\par {\f5 u \tab }Resource files (e.g. dialog boxes, menus, accelerator tables, and user-defined resources)
\par {\f5 u \tab }DDE messages and the DDE manager library (DDEML) API
\par {\f5 u \tab }Windows version 3.1 OLE
\par {\f5 u \tab }Metafiles
\par {\f5 u \tab }Clipboard data exchange
\par \pard\plain \sl240\tqr\tx8640 \f9 \page Major graphical interface features that are fully supported include:
\par \pard \sl240\tqr\tx8640 
\par \pard\plain \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 \f9 {\f5 u \tab }TrueType and TrueType APIs
\par {\f5 u \tab }Windows 3.x icons and cursors in existing format
\par {\f5 u \tab }{\f8 Bitmaps (BMPs) and d}evice independent bitmaps (DIBs) 
\par {\f5 u \tab }Printing by means of native Windows 32-Bit printer drivers
\par \pard\plain \sl240\tqr\tx8640 \f9 Base system functionality includes support for:
\par 
\par \pard\plain \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 \f9 {\f5 u \tab }Shared memory for interprocess communication
\par {\f5 u \tab }NetBIOS and Microsoft LAN Manager for DOS named pipe support
\par \pard \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 {\f5 u \tab }MS-DOS 5.0 interfaces (called with {\b DOS3Call} or {\b INT21})
\par \pard\plain \s253\sb120\sa240\sl480\tqr\tx8640 \b\f11 2.3 Methods to Achieve Binary Compatibility
\par \pard\plain \sl240\tqr\tx8640 \f9 
A Windows 3.x application must meet several requirements to be binary compatible on Windows NT; most relate to security.  Applications do not "own" the machine as they do in Windows 3.x.  As discussed above, directly accessing hardware 
(without a device driver) is a severe security violation on Windows NT. If direct hardware manipulation were supported, aberrant or malicious applications could affect the hardware causing system crashes or system instablity. This possibility is not accep
table in mission critical applications or on network servers, which Windows NT is designed to support.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 The Windows 32-Bit system will employ a registration database which will maintain all system and application configuration information. Files such as W
IN.INI will no longer exist in the file system; instead, calls to the profile API (for example, {\b GetProfileString}
) will be routed to the database. Therefore, applications should not attempt to create or modify *.INI files directly by means of file I/O API. The Windows 3.x profile APIs should manipulate all profile information. Installation programs that create priva
te installation files should be modified to use the profile API.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 Applications must be compatible with Windows 3.x Standard- or Enhanced-mode.  Windows 32-Bit systems will not support Windows real mode.  Applications should use only published Windows 3.x APIs, messages, and structures.
\par \pard\plain \s254\sb240\sa120\sl240\tqr\tx8640 \b\f11 \column 3. Portable Coding Techniques
\par \pard\plain \sl240\tqr\tx8640 \f9 
With the release of Windows 3.1, many applications are being updated to add support for features such as OLE and to take advantage of TrueType.  Because Windows programmers are already scrutinizing their applications' sources, now is a convenient time to 
prepare the code for the future, which offers a 32-bit environment with powerful new features.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 
The discussion below concentrates on the important issues that affect the portability of existing Windows source code to Windows 32-Bit.  Although this list may seem long and detailed,  all recommendations are useful for creating robust Windows 3.1 applic
ations.  In addition, applications will be more portable, and it will be easier to create native Windows 32-Bit applications quicker when Windows 32-Bit Software Development Kits are available.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl480\tqr\tx8640 {\b\ul Rules for Writing Portable Windows 3.x/Windows 32-Bit Source Code
\par 
\par }\pard\plain \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 \f9 {\f5 u}  \tab Parse {\i wParam} and {\i lParam} immediately in {\b WndProc} routines.
\par {\f5 u}  \tab NULL is a valid return value from {\b GetFocus} and {\b GetActiveWindow}.
\par {\f5 u}  \tab Use {\b FindWindow} instead of {\b hPrevInstance} to find other running instances.
\par {\f5 u} \tab {\b GlobalLock} and {\b malloc} will not return 64K aligned pointers.
\par \pard \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 {\f5 u}  \tab Use Windows 3.x DIB functions to initialize color bitmaps.
\par \pard \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 {\f5 u}  \tab Do not use {\b GetInstanceData;}  replace with supported IPC mechanism.
\par \pard \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 {\f5 u} \tab Do not share GDI object handles (e.g. pens, bitmaps) between processes.
\par {\f5 u}  \tab Compile warning level -W2 or higher (-W3 recommended).
\par {\f5 u}  \tab Create function prototypes for all functions.
\par {\f5 u}  \tab Review structure member alignment and data types.
\par {\f5 u}  \tab Remove hardcoded buffer sizes (for example, file names and path names).
\par {\f5 u}  \tab Do not extract private copies of WINDOWS.H definitions.
\par {\f5 u}  \tab Use unique typdefs (HPEN, HWND, not HANDLE or int).
\par \pard\plain \s253\sb120\sa240\sl480\tqr\tx8640 \b\f11 \column 3.1 A Brief Look at Windows 32-Bit
\par \pard\plain \sl240\tqr\tx8640 \f9 If you start with Windows 3.x source code, creating a native Windows 32-Bit application using the Windows 32-Bit A
PI is straightforward and requires minimal source changes.  In general, the Windows 32-Bit API simply involves widening parameters and return values to 32 bits. Over the course of a few months, Microsoft ported a range of Windows 3.x source code to Window
s 32-Bit, including the complete Windows 3.0 and Beta 3.1 software development kit sample code and relatively complex Windows 3.1 applets--Program Manager, File Manager, Cardfile, and so on.  This porting effort has validated the design of the Windows 32-
Bi
t API and proven that it is possible to quickly create Windows 32-Bit applications from Windows 3.x sources.  As an additional exercise, Microsoft modified the Windows software development kit  and system applet source code to be portable, allowing Window
s 3.1 and Windows 32-Bit binaries to be created from the same code base.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 The Windows 3.1 system applets contain more than 100,000 lines of source code. File Manager in particular contains approximately 20,000 lines of code; yet within one day it was comp
iling as a native Windows 32-Bit application.  Within a week, the File Manager could execute and display directory listings.  Changes included recoding several assembler routines in C so that the sources can be compiled for both Intel and RISC processors.
  Few changes to the original Windows 3.x C code were required, which is indicated by the short time needed to create a functional, portable version of the File Manager.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 An important porting factor is that Windows 3.x resource files containing menus, dia
log boxes, icons, accelerator tables, and so on are directly compatible with the 32-bit Resource Compiler.  You need not modify the resource files  for Windows 32-Bit.  This is not surprising, since the resource file is simply a script with no information
 that is 32-Bit sensitive.
\par \pard\plain \s253\sb120\sa240\sl480\tqr\tx8640 \b\f11 3.2 Windows 32-Bit Sample Source Code
\par \pard\plain \sl240\tqr\tx8640 \f9 The code fragment below is from the Windows 3.0 software development kit sample, GENERIC.  This code fragment compiles without modification  with either Windows 3.x or Windows 32-Bit develop
ment tools. Only one minor change to the entire GENERIC sample is required; the fragment builds completely as either a Windows 3.x or Windows 32-Bit binary.  Although the GENERIC sample is not particularly sophisticated, it does contain a menu and a dialo
g box, indicating that complex Windows functionality is easily supported.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 If we look at the code fragment through the eyes of Windows 32-Bit, we see a true 32-bit application.  Function parameters, pointers, and structure members all widened from 16 to 3
2 bits.  This widening is accomplished "under the covers" by means of typedefs in WINDOWS.H (Windows 32-Bit version).  For example, the typedef LPSTR is a linear 32-bit pointer.  The variable {\i hInst} is defined as a 32-bit HANDLE.  The window handle, {
\i hWnd},  returned by {\b CreateWindow,} is a 32-bit window handle.  The window class structure contains 32-bit handles to icons, 32-bit linear pointers to string constants, and a 32-bit stock brush handle.
\par \pard\plain \s253\sb120\sa240\sl480\tqr\tx8640 \b\f11 \column Generic Sample Application form Windows 3.0 SDK
\par \pard\plain \s5\sl240\tx3600\tx7200\tqr\tx8640 \f11\fs20 #include "windows.h"\tab   /* required for all Windows applications*/
\par #include "generic.h"\tab   /* specific to this program    */
\par 
\par HANDLE hInst;\tab   /* current instance    */
\par 
\par int PASCAL WinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow)
\par HANDLE hInstance;\tab   /* current instance     */
\par HANDLE hPrevInstance;\tab   /* previous instance    */
\par LPSTR lpCmdLine;\tab   /* command line    */
\par \pard \s5\sl240\tx3600\tx7200\tqr\tx8640 int nCmdShow;\tab \tab \tab \tab      /* show-window type (open/icon) */
\par \pard \s5\sl240\tx3600\tx7200\tqr\tx8640 \{
\par \pard \s5\sl240\tx3600\tx7200\tqr\tx8640     MSG msg;\tab \tab \tab \tab      /* message     */
\par \pard \s5\sl240\tx3600\tx7200\tqr\tx8640 
\par     if (!hPrevInstance)\tab /*{\b  }Other instances of app running? */
\par if (!InitApplication(hInstance))\tab /* Initialize shared things */
\par     return (FALSE);\tab /* Exits if unable to initialize     */
\par 
\par     /* Perform initializations that apply to a specific instance */
\par 
\par     if (!InitInstance(hInstance, nCmdShow))
\par         return (FALSE);
\par 
\par     /* Acquire and dispatch messages until a WM_QUIT message is received. */
\par 
\par     while (GetMessage(&msg,\tab  /* message structure    */
\par     NULL,\tab  /* handle of window receivieng thssage */
\par     NULL,\tab  /* lowest message to examine     */
\par     NULL))\tab  /* highest message to examine     */
\par \{
\par TranslateMessage(&msg);\tab  /* Translates virtual key codes    */
\par DispatchMessage(&msg);\tab  /* Dispatches message to window    */
\par     \}
\par     return (msg.wParam);\tab  /* Returns the value from PostQuitMessage */
\par \}
\par 
\par BOOL InitApplication(hInstance)
\par HANDLE hInstance;       \tab /* current instance     */
\par \{
\par     WNDCLASS  wc;
\par 
\par \pard \s5\sl240\tx3600\tx7200\tqr\tx8640    \column  /* Fill in window class structure with parameters that describe the       */
\par \pard \s5\sl240\tx3600\tx7200\tqr\tx8640     /* main window.       */
\par 
\par     wc.style = NULL;                    \tab /* Class style(s).    */
\par     wc.lpfnWndProc = MainWndProc;       /* Function to retrieve messages for  */
\par                                         \tab /* windows of this class.             */
\par     wc.cbClsExtra = 0;                  \tab /* No per-class extra data.           */
\par     wc.cbWndExtra = 0;                 \tab /* No per-window extra data.          */
\par     wc.hInstance = hInstance;           \tab /* Application that owns the class.   */
\par     wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
\par     wc.hCursor = LoadCursor(NULL, IDC_ARROW);
\par     wc.hbrBackground = GetStockObject(WHITE_BRUSH); 
\par     wc.lpszMenuName =  "GenericMenu";     /* Name of menu resource in .RC file. */
\par     wc.lpszClassName = "GenericWClass";  /* Name used in call to CreateWindow. */
\par 
\par     /* Register the window class and return success/failure code. */
\par     return (RegisterClass(&wc));
\par \}
\par 
\par BOOL InitInstance(hInstance, nCmdShow)
\par     HANDLE          hInstance;        \tab /* Current instance identifier.       */
\par     int             nCmdShow;           \tab /* Param for first ShowWindow() call. */
\par \{
\par     HWND            hWnd;               \tab /* Main window handle.      */
\par 
\par     /* Save the instance handle in static variable, which will be used in  */
\par     /* many subsequence calls from this application to Windows.            */
\par 
\par     hInst = hInstance;
\par 
\par     /* Create a main window for this application instance.  */
\par     hWnd = CreateWindow(
\par         "GenericWClass",                \tab /* See RegisterClass() call.          */
\par         "Generic Sample Application",   \tab /* Text for window title bar.         */
\par         WS_OVERLAPPEDWINDOW,       /* Window style.                      */
\par         CW_USEDEFAULT,               \tab /* Default hoorizontal position.       */
\par         CW_USEDEFAULT,                  \tab /* Default vertical position.         */
\par         CW_USEDEFAULT,                  \tab /* Default width.                     */
\par         CW_USEDEFAULT,                  \tab /* Default height.                    */
\par         NULL,                           \tab /* Overlapped windows have no parent. */
\par         NULL,                           \tab /* Use the window class menu.         */
\par         hInstance,                      \tab /* This instance owns this window.    */
\par         NULL                            \tab /* Pointer not needed.                */
\par     );
\par 
\par     /* If window could not be created, return "failure" */
\par     if (!hWnd)
\par         return (FALSE);
\par 
\par     /* Make the window visible; update its client area; and return "success" */
\par     ShowWindow(hWnd, nCmdShow);  \tab /* Show the window                        */
\par     UpdateWindow(hWnd);          \tab /* Sends WM_PAINT message                 */
\par     return (TRUE);               \tab /* Returns the value from PostQuitMessage */
\par \}
\par \pard\plain \s253\sb120\sa240\sl480\tqr\tx8640 \b\f11 3.3 User Interface Code
\par \pard\plain \s252\fi-1440\li1440\sa120\sl480\tqr\tx8640 \b\f11 3.3.1 Message Parameter Packing
\par \pard\plain \sl240\tqr\tx8640 \f9 With the widening of handles to 32 bits, both {\i wParam} and {\i lParam} (the additional message parameters) must be 32 bits wide.  The impact is to {\i wParam} because {\i lParam}
 is already 32 bits wide in Windows 3.x.  If in Windows 3.x applications a handle and another value were packed into the high and low 16 bits of {\b  }{\i lParam}, widening to 32 bits requires repacking some values. A 32-bit handle occupies {\i lParam}
 completely, requiring the previously packed second parameter to be moved to {\i wParam}.  A few messages have been affected by handle widening, including WM_COMMAND, which is illustrated below:
\par \pard\plain \s5\sl240\tx3600\tx7200\tqr\tx8640 \f11\fs20 
\par \pard\plain \s6\li720\sl240\tx1440\tx2880\tx7200\tqr\tx8640 \f11\fs20 WM_COMMAND
\par 
\par \pard \s6\li720\sl240\tx1440\tx2880\tx7200\tqr\tx8640 \tab {\b Win 3.x:\tab }wParam == window id
\par \pard \s6\li720\sl240\tx1440\tx2880\tx7200\tqr\tx8640      \tab \tab lParam == hwnd, command
\par 
\par \pard \s6\li720\sl240\tx1440\tx2880\tx7200\tqr\tx8640 \tab {\b Win 32-Bit: \tab }wParam == window id, command
\par \pard \s6\li720\sl240\tx1440\tx2880\tx7200\tqr\tx8640 \tab \tab lParam == hwnd
\par \pard\plain \s5\sl240\tx720\tx1440\tx2430\tx7200\tqr\tx8640 \f11\fs20 
\par \pard\plain \sl240\tqr\tx8640 \f9 The WM_COMMAND {\i window id }and {\i command} parameters remain 16 bit values in Windows 32-Bit and can therefore be packed in the widened 32-bit {\i wParam}.  The 32-bit {\i hwnd} value is now fully contained in{\i 
 lParam}
.  To minimize the affect of parameter packing differences, a set of macros has been created that parse message parameters.  In this way, you can compile source code either as a Windows 3.x application  or as a Windows 32-Bit application without unique me
ssage handling code or C compiler {\f3 #ifdef} directives.  These macros will be in the Windows 32-Bit software development kit.  Examples of macros used to parse WM_COMMAND information are:
\par \pard \sl480\tqr\tx8640 
\par \pard\plain \s6\li720\sl240\tx3600\tx7200\tqr\tx8640 \f11\fs20 GET_WM_COMMAND_ID  (wParam, lParam) // Parse control ID value
\par GET_WM_COMMAND_HWND(wParam, lParam) // Parse control HWND
\par GET_WM_COMMAND_CMD (wParam, lParam) // Parse notification command
\par 
\par \pard\plain \sl240\tqr\tx8640 \f9 The underlying macro definitions are Windows 3.x and Windows 32-Bit specific; parsing the information from {\i wParam} or {\i lParam} as appropriate for each implementation.  The imporant
 point is that you can easily create readable source code that can be compiled for Windows 3.x or Windows 32-Bit. 
\par \pard\plain \s252\fi-1440\li1440\sa120\sl480\tqr\tx8640 \b\f11 3.3.2 Parsing wParam/lParam 
\par \pard\plain \sl240\tqr\tx8640 \f9 Because of the parameter repacking of several Windows messages, parse (extract) values from {\i wParam} and {\i lParam}
 in the message handling window procedure rather than passing parameters to worker functions where extraction occurs. If only {\i wParam} or {\i lParam}
 is passed to the worker routine, under Windows 32-Bit either parameter may no longer contain the value required by
 the worker routine.  Delayed extraction of message parameter data in worker routines is not always easy to spot.  Extracting the value within the message handling procedure localizes the impact of Windows 32-Bit message repacking.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 An alternative solution is to always pass both {\i wParam} and {\i lParam}
 to worker routines.  In this way, the routine will always have access to parameter values, whether compiled for Windows 3.x or Windows 32-Bit.  This solution is less efficient because unused data is being transferred on the stack.
\par \pard\plain \s252\fi-1440\li1440\sa120\sl480\tqr\tx8640 \b\f11 3.3.3 Profile String Usage
\par \pard\plain \sl240\tqr\tx8640 \f9 
Systems offering Windows 32-Bit support will also provide a registration database.  All system and application configuration data will be stored in the database on a per user basis with appropriate security controls to assure that applications cannot corr
upt one another's data or the system's configuration data. A centralized database has a number of advantages, including simpler installation, remote administration of workstation software, remote software updating, and error logging.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 Windows 32-Bit versions of the Windows 3.x profile API (for example, {\b GetProfileString}, {\b WriteProfileString}
) route profile string requests, including private profiles (that is, *.INI files) to the registration database transparently. Therefore, do not attempt to manipulate *.INI files directly with file I/O functions. These files will not exist, and the data c
ontained in them is not accessible via file I/O calls; only the profile string API will be supported.
\par \pard\plain \s252\fi-1440\li1440\sa120\sl480\tqr\tx8640 \b\f11 3.3.4 Localized Input
\par \pard\plain \sl240\tqr\tx8640 \f9 
The Windows 32-bit model is different from Windows 3.x in that input ownership is assigned at user input time -- when the input is created -- instead of when the input is read out of the system queue.  For this reason, each thread has its own input-synchr
onized state information.  In other words, each thread has its own input-synchronized picture of the mouse capture and the active window and is aware of which window has the focus.
\par \pard \sl240\tqr\tx8640 This change adds tremendous benefit to programmers and users alike.  It i
s no longer possible for an application that fails to process messages to bottleneck the system.  Unlike Windows 3.x and OS/2 Presentation Manager, no applications will be affected by other applications that process their messages slowly or who otherwise 
fail to check their message queue.
\par \pard \sl240\tqr\tx8640 
\par \pard\plain \s1\sa240\sl240\keepn The following APIs are affected by localized input state:
\par \pard\plain \s6\li720\sl240\tx3600\tx7200\tqr\tx8640 \f11\fs20 SetFocus( HWND )
\par GetFocus( VOID )
\par SetActiveWindow( HWND )
\par GetActiveWindow( VOID )
\par GetCapture( VOID )
\par SetCapture( HWND )
\par ReleaseCapture( VOID )
\par \pard\plain \s5\sl240\tx3600\tx7200\tqr\tx8640 \f11\fs20 
\par \pard\plain \sl240\tqr\tx8640 \f9 In general, the {\b Get}  APIs query only local current thread state.  The {\b Set}
 APIs set state local to the window creator thread.  If the current thread did not create the window, then the current thread's related input state is set to NULL as if the input related state were being transferred between threads.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 Thus, the Windows 3.x semantics of APIs that return input-synchronized state are changed slightly.  For example, {\b SetFocus} can be called with an {\i hwnd} and return TRUE for success, but a follow-up call to {\b GetFocus} 
might return NULL.  More substantially, {\b GetFocus} now returns NULL if the calling thread does not have a focus window. Under Windows 3.x,  {\b GetFocus} never returns NULL because a window in the system always has the keyboard focus.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 Therefore, code applications to expect that functions such as {\b GetFocus} can return NULL as a legal value.  The return value should be tested against NULL before being used in subsequent function calls.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 Mouse capture is affected in an added dimension.  The Windows 32-Bit server i
nput thread cannot know ahead of time when an input thread will set the capture.  Also, regardless of the input state of any application, the system must allow the user direct input to any other application at any time.  Therefore, the semantics of mouse 
capture change slightly.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 The semantics of how and when the capture changes are not affected; how and when an application gets mouse input is affected.  The Windows 32-Bit server will send all mouse input between a mouse down operation and a mouse up oper
ation to the queue of the thread that created the window into which the original mouse down went.  Thus, the input thread processes mouse capture as the input is read out of the queue.  If the mouse button is down during the mouse capture, the capture win
dow sees all input generated by the mouse, no matter where the mouse is on the screen, until the mouse button goes up or the mouse capture is released.  If a thread sets the mouse capture while the mouse button is up, the mouse capture window sees mouse e
vents only as long as the mouse is over a window that thread created.
\par \pard\plain \s253\sb120\sa240\sl480\tqr\tx8640 \b\f11 3.4 Graphics Interface Code
\par \pard\plain \s252\fi-1440\li1440\sa120\sl480\tqr\tx8640 \b\f11 3.4.1 DIBs vs DDBs
\par \pard\plain \sl240\tqr\tx8640 \f9 
Beginning with Windows 3.0, device independent bitmaps (DIBs) have been the recommended format for creating and initializing bitmap data.  This format includes a header with bitmap dimensions, color resolution, and palette information supporting portabili
ty between Windows 3.x and Windows 32-Bit. Device dependent bitmaps (DDBs), as originally offered in Windows 1.x and 2.x, are not recommended.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 Because DDBs lack complete header information, applications that directly manipulate DDB data are not portable to Windows 32-Bit.  Developers are encouraged to write to the Windows 3.x DIB API (for example, {\b SetDIBitmapBits}
); these calls are portable.  Windows 32-Bit does provides, however, a subset of functionality for DDB API, such as {\b SetBitmapBits}:
\par \pard \sl240\tqr\tx8640 
\par \pard\plain \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 \f9 {\f5 u\tab }Monochrome DDBs are fully supported
\par \pard \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 {\f5 u \tab }Caching color bitmaps with {\b GetBitmapBits} and {\b SetBitmapBits} is supported
\par \pard\plain \sl240\tqr\tx8640 \f9 Caching implies that {\b GetBitmapBits}
 is used to save bitmap data on disk.  Under low memory situations in Windows versions 1.x and 2.x, the bitmap could be destroyed and easily restored with GetBitmapBits.  This implies that the DDB data is never manipulated; it is simply backed up and rest
ored on disk in its original form.  While caching is not needed in Windows 32-Bit, source code employing this technique will still be supported.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 Windows 32-Bit does not support initializing color DDBs with {\b CreateBitmap.} Such code is also not portable among Windows 3.x systems with different display drivers because DDB data is device driver dependent.
\par \pard \sl240\tqr\tx8640 
\par \pard\plain \s252\fi-1440\li1440\sa120\sl480\tqr\tx8640 \b\f11 3.4.2 Sharing Graphical Objects
\par \pard\plain \sl240\tqr\tx8640 \f9 
Windows 3.x runs all Windows applications in a shared address space.  Data can be directly manipulated, and other Windows processes can directly access per-process objects that the system created. This architecture has been exploited by some applications 
that create a single graphical object, such as a pen or a bitmap, and allow separate processes to use the pen or draw on the bitmap.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 
Windows 32-Bit applications run in separate address spaces, and graphical objects are owned by the process that creates them.  Only its owner can manipulate a graphical object.  A handle to a bitmap passed to another process cannot be used by that process
 because the original process retains ownership of the bitmap.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 Pens and brushes should be created by each process.  A cooperative process may access the bitmap data in shared memory (via standard interprocess communications) and create its 
own copy of the bitmap.  Alterations to the bitmap must be communicated between the cooperative processes via interprocess communication and a proper protocol.  One such protocol is DDE.  Windows 32-Bit will add an explicit ownership transfer API for grap
hical objects to explicitly allow cooperative applications to share graphical objects.
\par \pard\plain \s253\sb120\sa240\sl480\tqr\tx8640 \b\f11 3.5 Base System Support
\par \pard\plain \s252\fi-1440\li1440\sa120\sl480\tqr\tx8640 \b\f11 3.5.1 Instance Initialization
\par \pard\plain \sl240\tqr\tx8640 \f9 The first release of Windows (version 1.01) was designed to run in 8088-based systems, which assumed limited installed memory (512K RAM).  Functions such as {\b GetInstanceData}
 and knowledge about other instances of an application already running allowed efficient data sharing and initialization using data belonging to other running instances. On secure systems in which applications run in separate address spaces, these functio
ns no longer are appropriate.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 Therefore, applications that want to share data among several instances must replace calls to {\b GetInstanceData} with standard interprocess communication techniques such as shared memory and/or DDE.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 A Windows 32-Bit version of {\b WinMain} supports the same parameter list as does Windows 3.x:
\par \pard \sl240\tqr\tx8640 
\par \pard\plain \s6\li720\sl240\tx3600\tx7200\tqr\tx8640 \f11\fs20 int WinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow)
\par 
\par \pard\plain \sl240\tqr\tx8640 \f9 However, the parameter {\i hPrevInstance}
 always returns NULL, indicating that this is the first instance of the application, regardless of any other already-running instances. Although this situation would appear to be a problem, the initialization of most applications is handled correctly.  Un
der Windows 3.x, multiple instances can share private window classes registered by the first instance.  Under Windows 32-Bit, each instance is required to register it own window classes.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 Applications usually test {\i hPrevInstance}
 to see if they must register their window class.  This test is guaranteed to work optimally under Windows 32-Bit, always indicating the first instance of the application, and Windows 32-Bit requires that every instance register its own window classes.

\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 Some applications, however, must know if other instances ar
e running.  Sometimes data sharing is required, but typically applications that care about multiple instances are interested in assuring that only one instance of the application runs at any time.  An example is the Control Panel; another is the Task Mana
ger.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 Applications such as these cannot use {\i hPrevInstance}
 in Windows 32-Bit to test for previous instances. These applications must use an alternative method, such as creating a unique named pipe, broadcasting a unique message, or calling {\b FindWindow.}   If
 another instance is found, the application determines which instance should be terminated.
\par \pard \sl240\tqr\tx8640 
\par \pard\plain \s252\fi-1440\li1440\sa120\sl480\tqr\tx8640 \b\f11 3.5.2 Memory Manipulation
\par \pard\plain \sl240\tqr\tx8640 \f9 Under the Windows 3.x segmented memory architecture, globally allocated memory always aligns on segment boundaries.  Both {\b GlobalAlloc} and the C runtime {\b malloc}
 family of functions allocate global memory in a way that the 16-bit offset of the 32-bit segmented pointer that references the base address of this data is always 0.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 This behavior is not portable to linear memory.  Memory alloca
tion is not guaranteed to  align on 64K boundaries.  Memory is allocated with a 4K page granularity, but some objects may be packed to fit within a single page to maximize memory efficiency.  (See below for more information about pointer manipulation.)

\par \pard\plain \s252\fi-1440\li1440\sa120\sl480\tqr\tx8640 \b\f11 \column 3.5.3 Windows 32-Bit API Replacements for Int 21
\par \pard\plain \sl240\tqr\tx8640 \f9 Direct {\b INT21} calls or the use of the Windows 3.x {\b DOS3Call} API to request MS-DOS to perform file I/O operations must  be replaced by the appropriate Windows 32-Bit file I/O calls.  Windows 32-Bit offers a com
plete set of named APIs to replace nonportable {\b INT21} calls including:
\par \pard \sl240\tqr\tx8640 
\par \pard\plain \s9\li540\sa120\sl240\tx2700\tx5580 \b\f9\ul INT 21H Function\tab DOS Operation\tab Windows 32-Bit API Equivalent
\par \pard \s9\li720\sa120\sl240\tx2880\tx5760 {\plain \f9 0EH\tab Select Disk\tab SetCurrentDirectory\line 19H\tab Get Current Disk\tab GetCurrentDirectory\line 2AH\tab Get Date\tab GetDateAndTime\line 2BH\tab Set Date\tab SetDateAndTime\line 2CH\tab Get Time
\tab GetDateAndTime\line 2DH\tab Set Time\tab SetDateAndTime\line 36H\tab Get Disk Free Space\tab GetDiskFreeSpace\line 39H\tab Create Directory\tab CreateDirectory\line 3AH\tab Remove Directory\tab RemoveDirectory\line 3BH\tab Set Current Directory\tab 
SetCurrentDirectory\line 3CH\tab Create Handle\tab CreateFile\line 3DH\tab Open Handle\tab OpenFile\line 3EH\tab Close Handle\tab CloseHandle\line 3FH\tab Read Handle\tab ReadFile\line 40H\tab Write Handle\tab WriteFile\line 41H\tab Delete File\tab 
DeleteFile\line 42H\tab Move File Pointer\tab SetFilePointer\line 43H\tab Get File Attributes\tab GetAttributesFile\line 43H\tab Set File Attributes\tab SetAttributesFile\line 47H\tab Get Current Directory\tab GetCurrentDirectory\line 4EH\tab 
Find First File\tab FindFirstFile\line 4FH\tab Find Next File\tab FindNextFile\line 56H\tab Change Directory Entry\tab MoveFile\line 57H\tab Get Date/Time of File\tab GetDateAndTimeFile\line 57H\tab Set Date/Time of File\tab SetDataAndTimeFile\line 59H
\tab Get Extended Error\tab GetLastError\line 5AH\tab Create Unique File\tab GetTempFileName\line 5BH\tab Create New File\tab CreateFile\line 5CH\tab Lock\tab LockFile\line 5CH\tab Unlock\tab UnlockFile\line 67H\tab Set Handle Count\tab SetHandleCount

\par }\pard \s9\li720\sa120\sl240\tx2880\tx5760 
\par \pard\plain \sl240\tqr\tx8640 \f9 In most situations, the standard C runtime libraries are sufficient for normal file I/O.  The C runtime has the advantage of being portable across many platforms.
\par \pard\plain \s252\fi-1440\li1440\sa120\sl480\tqr\tx8640 \b\f11 \column 3.5.4 Dynamic Link Libraries
\par \pard\plain \sl240\tqr\tx8640 \f9 DLL initialization and termination functions behave differently in Windows 3.xand Windows 32-Bit in terms of how they are defined, when they are calle
d, and the information that is made available to them.  Windows 32-Bit DLLs are easier to create and have functionality not currently available in Windows 3.x.  In Windows 3.x, initialization and termination functions must be provided: the termination fun
ction must be named WEP, and the initialization function is the DLL MASM entry point.  Initialization and termination functions are optional in Windows 32-Bit DLLs.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 In Windows 3.x, the DLL initialization function is called once, when the DLL is first loa
ded in the system.  The function is not called again, even if other applications that use the DLL are invoked.  Likewise, the DLL termination function is not called until the DLL is unloaded from the system, when the last application using it terminates o
r frees the library.  The initialization and termination functions are distinct.  The startup code for the initialization function must be in assembly language, to allow access to parameters that are passed in machine registers.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 In Windows 32-Bit, the DLL initialization function is the same as the termination function, and its name is specified at link time.  Initialization or termination functionality is selected by a Boolean parameter, {\i bAttaching}
,  passed to the initialization function.  The DLL initialization function is called each time a process attaches to the DLL for the first time or detaches from the DLL for the last time.  Thus, if five processes access the same DLL, the DLL's initializat
ion function is invoked five times with the {\i bAttaching} parameter set to TRUE.  When these five processes terminate, detaching the DLL from each process causes five calls to the DLL initialization function, with the {\i bAttaching}
 parameter set to FALSE.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 Windows 3.x DLLs are typically implemented completely in assembly language or in C and linked to the standard LIBENTRY.ASM function.  This function calls {\b LibMain}
 after initializing the heap and saving appropriate registers.  In porting to Windows 32-Bit, DLLs implemented in assembly language should be rewritten in C so that they are portable to RISC-based systems.
\par \pard \sl240\tqr\tx8640 
\par Windows 3.x DLL initialization functions are passed the following information:
\par 
\par \pard\plain \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 \f9 {\f5 u\tab  }the DLL's instance handle
\par {\f5 u \tab }the DLL's data segment (DS)
\par {\f5 u \tab }the heap size specified in the DLL's .DEF file
\par {\f5 u }\tab the command line
\par \pard\plain \sl240\tqr\tx8640 \f9 \column Windows 32-Bit DLL initialization functions are passed the following information:
\par \pard \sl240\tqr\tx8640 
\par \pard\plain \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 \f9 {\f5 u \tab }the DLL's module handle
\par \pard \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 {\f5 u \tab }the {\i bAttaching} Boolean, selecting initialization or termination
\par \pard\plain \sl240\tqr\tx8640 \f9 The Windows 32-Bit module handle is analogous to the Windows 3
.x instance handle.  In Windows 32-Bit, the data segment is irrelevant because declared DLL data is either private to each process accessing the DLL or shared among cooperative processes accessing the DLL. The DLL's module definition file controls whether
 DLL data is shared or private. The heap size is not passed to the Windows 32-Bit DLL initialization function because all calls to local memory management functions operate on the default heap, which is provided to each process.  The command line does not
 need to be passed as a parameter since it can be obtained under Windows 32-Bit through an API function.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 
Although the Windows 3.x LIBENTRY.ASM routine contains nonportable assembly routines, it isolates the assembly language initialization and supports writing additional DLL-specific initialization in C via the LibMain routine.  For portability to Windows 32
-Bit,  DLL initialization code should be added to the {\b LibMain} routine and written in C. (For further information on LIBENTRY.ASM, see the Windows 3.x software development kit documentation.).
\par \pard\plain \s253\sb120\sa240\sl480\tqr\tx8640 \b\f11 3.6 C Coding Guidelines
\par \pard\plain \sl240\tqr\tx8640 \f9 
The Windows 32-Bit API was designed to simplify the creation of Windows 32-Bit applications from Windows 3.x sources.  Specific API differences have been discussed above.  Creating portable Windows code also involves writing portable C.  Fortunately, the 
similarity of Windows 3.x and Windows 32-Bit requires only that a concise set of portable C guidelines be followed.  Windows programs have generally been optimized to operate with the segmen
ted Intel architecture.  Therefore, the change from segmented to linear memory is the most significant issue in creating portable C code
\par \pard\plain \s252\fi-1440\li1440\sa120\sl480\tqr\tx8640 \b\f11 3.6.1 Pointer Manipulation
\par \pard\plain \sl240\tqr\tx8640 \f9 Windows 32-Bit supports a compatible set of memory management functions, such as {\b GlobalAlloc} and {\b GlobalLock}
, and a new set of advanced linear memory APIs.  Therefore, existing Windows applications can easily be converted to Windows 32-Bit and continue to use the Windows 3.x memory allocation and handle dereferencing API.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 As mentioned previou
sly, memory allocations are not aligned on 64K boundaries.  Therefore, any pointer arithmetic based on assumptions of segment:offset encoded pointers will fail in Windows 32-Bit.  When computing offsets to arrays of structures, do not create pointers by c
ombining a computed 16-bit offset with the high-order 16 bits of an address pointer.  This type of pointer arithmetic depends on segment:offset encoded addresses.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 \column Several other pointer characteristics should be observed:
\par \pard \sl240\tqr\tx8640 
\par \pard\plain \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 \f9 {\f5 u} \tab All pointers (even pointers to objects in the local heap) grow to 32 bits
\par \pard \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 {\f5 u} \tab Code that takes advantage of 16-bit pointer address wrapping is not appropriate with linear addresses
\par {\f5 u} \tab Structures that hold NEAR pointers in Windows 3.x will grow from 2 bytes to 4 bytes in Windows 32-Bit
\par \pard\plain \s252\fi-1440\li1440\sa120\sl480\tqr\tx8640 \b\f11 3.6.2 Promotions and Ranges
\par \pard\plain \sl240\tqr\tx8640 \f9 
Expressions involving the C integer data types (int and unsigned int) should be reviewed for portability, especially if the compiler already generates warnings about signed/unsigned mismatches or conversion warnings.  The 
int data-type grows from 16 to 32 bits, which can subtly affect applications compiled for Windows 32-Bit.  Typical problems encountered are sign extensions and assumptions (sometimes unintentional) about ranges. Loops that take advantage of 16-bit ints an
d of the fact that integer loop counters will wrap at 32767 or 65535 will experience problems when the integer loop counters grow to 32-bit and wrapping occurs at 2GB or 4GB.
\par \pard\plain \s252\fi-1440\li1440\sa120\sl480\tqr\tx8640 \b\f11 3.6.3 Structure Member Alignment
\par \pard\plain \sl240\tqr\tx8640 \f9 Data accesses to unnaturally aligned data eleme
nts are expensive on some hardware architectures and are illegal on others.  For example, on the Intel 80386 accessing a DWORD that is not 4-byte aligned results in a performance penalty.  When the same code is moved to a MIPS RISC processor, the misalign
ed access generates a fault.  The system handles the fault, and system software decodes the data. Although the code is portable, it is not efficient. Therefore,  all data elements should be aligned consistently with their type.  Alignment rules vary with 
architecture, but the following guidelines are appropriate for the Intel and MIPS processors targeted by Windows 32-Bit:
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tx720\tqr\tx8640 \tab Windows 32-Bit Structure Member Alignment
\par \pard \li1440\sl480\tx3600\tqr\tx8640 {\b char:}\tab Align on byte boundaries
\par {\b short (16-bit):}\tab Align on even byte boundaries
\par {\b int/long (32-bit):}\tab Align on 32-bit boundaries
\par {\b float/double:}\tab Align on 32-bit boundaries
\par {\b structures:}\tab Align on 32-bit boundaries
\par \pard \sl240\tx2880\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 Creating a portable structure that is both efficient in memory usage (without packing) and aligned properly is possible.
\par \pard\plain \s252\fi-1440\li1440\sa120\sl480\tqr\tx8640 \b\f11 \column 3.6.4 Unique Typedefs
\par \pard\plain \sl240\tqr\tx8640 \f9 
As illustrated in the GENERIC code fragment listed earlier in this document, unique typedefs are useful in creating portable code. Even though the typedefs can have different underlying definitions in Windows 3.x and Windows 32-bit,  Windows source code c
an remain unchanged.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 Windows offers unique typedefs for most objects defined in WINDOWS.H.  Unique typedefs such as HPEN, HBRUSH, and HWND better support portability to Windows 32-Bit than generic typedefs such as HANDLE.  Although all handles 
in Windows 3.x are interchangeable with HANDLE or unsigned int, using these basic data types affects porting to Windows 32-Bit because various objects require different typedefs under Windows 32-Bit than under Windows 3.x.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 
Just as using unique typedefs is recommended when defining (or casting) Windows objects, creating a complete set of unique typedefs for application-specific objects is also strongly recommended.  As with the Windows objects, the underlying application-spe
cific data types and structures can be modified and minimally affect source code that uses these data types.
\par \pard\plain \s252\fi-1440\li1440\sa120\sl240\tqr\tx8640 \b\f11 
\par 3.6.5 General Recommendations
\par \pard\plain \sl240\tqr\tx8640 \f9 
The following coding recommendations are well known but are occasionally ignored.  Reviewing your code and addressing the following issues will create more robust Windows 3.1 code and will create code that is more easily ported to Windows 32-Bit.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 Review hard-coded buffer sizes for file names and environment strings. Although dynamically allocating buffers to hold strings is not necessary, Windo
ws 32-Bit supports long file names (256 characters).  Therefore, buffers hard coded assuming FAT 8.3 format will not take advantage of long file name support.  Using a #define to define sizes for array allocations will assist portability of the source cod
e to Windows 32-Bit.  Windows 32-Bit will add support for "opaque" file names, which will offload details of creating and parsing pathnames from the application to the operating system.  Among the benefits is transparant support for accessing files on new
 f
ile systems such as mini or mainframe servers sharing named resources on a network.  The application is freed from knowing the file formats and network naming conventions when interacting with other PCs, VAX systems, or other "foreign" file systems.  Remo
ving hard-coded buffer sizes is the first step in taking advantage of opaque file naming.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 Compile all sources at warning level 2 (-W2), warning level 3 (-W3) is recommended.  Warning level 3 has been a problem in the past because WINDOWS.H included non-A
NSI C compliant bitfield definitions that did not pass at this level.  The latest release of the Microsoft C compiler (C 6.00a) moves this fatal error to  -W4, allowing the strict type checking of -W3.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 
Create function prototypes for all functions.  Relying on default C compiler handling is often (but not guaranteed to be) portable.  In addition to parameter assumptions, the Microsoft C compiler supports various calling conventions (_cdecl, _pascal, and 
so on), and the default calling convention may change because of future ANSI C requirements.  Using function prototypes helps isolate source code from default compiler behavior and changes in the ANSI C definition.
\par \pard \sl240\tqr\tx8640 
\par \pard \sl240\tqr\tx8640 
Until recently, the size of WINDOWS.H has been a problem for the Microsoft C compiler, causing out of heap space problems in Pass 1 and/or Pass 2 of the compiler.  This problem is corrected in the MS-DOS extender version of the MS C compiler (C 6.00ax).  
ISVs have worked around this previous limitation by extracting specific WINDOWS.H definitio
ns into their source code.  This could cause portability problems if these WINDOWS.H definitions are not updated with Windows 32-Bit definitions when the source is compiled under Windows 32-Bit.  Therefore, either remove extracted header information and r
ely on WINDOWS.H, or clearly highlight extracted information for modification when building a Windows 32-Bit version.
\par \pard\plain \s254\sb240\sa120\sl240\tqr\tx8640 \b\f11 \page 4. Summary of Compatibility Rules
\par \pard\plain \sl240\tqr\tx8640 \f9 
\par \pard \sa120\sl240\tqr\tx8640 {\b\ul Rules for Windows 3.x Binary Compatibility on Windows NT
\par }\pard\plain \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 \f9 {\f5 u} \tab Ensure that Windows 3.x applications run in Standard/Enhanced mode.
\par {\f5 u} \tab Use published Windows 3.x APIs, messages, and structures.
\par {\f5 u} \tab Do not modify WIN.INI directly; use a profile string API.
\par {\f5 u} \tab Restrict direct port I/O (only standard devices).
\par {\f5 u} \tab Do not directly access the disk controller; doing so is a security violation.
\par {\f5 u} \tab Do not modify the system date and time; doing so is a security violation.
\par \pard\plain \sa120\sl240\tqr\tx8640 \f9 {\b\ul Rules for Portable Windows 3.x/Windows 32-Bit Source Code
\par }\pard\plain \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 \f9 {\f5 u}  \tab Parse {\i wParam} and {\i lParam} immediately in {\b WndProc} routines.
\par {\f5 u}  \tab NULL is a valid return value from {\b GetFocus} and {\b GetActiveWindow}.
\par {\f5 u}  \tab Use {\b FindWindow} instead of {\b hPrevInstance} to find other running instances.
\par {\f5 u} \tab {\b GlobalLock} and {\b malloc} will not return 64K aligned pointers.
\par \pard \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 {\f5 u}  \tab Use Windows 3.x DIB functions to initialize color bitmaps.
\par \pard \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 {\f5 u}  \tab Do not use {\b GetInstanceData;}  replace with supported IPC mechanism.
\par \pard \s4\fi-432\li720\sa240\sl240\tx720\tqr\tx8640 {\f5 u} \tab Do not share GDI object handles (e.g. pens, bitmaps) between processes.
\par {\f5 u}  \tab Compile warning level -W2 or higher (-W3 recommended).
\par {\f5 u}  \tab Create function prototypes for all functions.
\par {\f5 u}  \tab Review structure member alignment and data types.
\par {\f5 u}  \tab Remove hardcoded buffer sizes (for example, file names and path names).
\par {\f5 u}  \tab Do not extract private copies of WINDOWS.H definitions.
\par {\f5 u}  \tab Use unique typdefs (HPEN, HWND, not HANDLE or int).
\par \pard\plain \s8\fi-432\li720\sa120\sl240\tx720\tqr\tx1080\tqr\tx8640 \f9 
\par }