









                  VAX SDL (Structure Definition Language)
















        Revision/Update Information:        Revision/Update Information:       This  revised  document   will
                                           supersede  information  in the
                                           ___    _________    __________                                           VAX    Structure    Definition
                                           ________                                           Language  Version  2.0.   This
                                           document   is   intended   for
                                           internal  DIGITAL distribution
                                           only.


        Operating System and Version:        Operating System and Version:      VAX/VMS Version 4.0 or later


        Software Version:        Software Version:                  VAX SDL V3.0
                                                First Printing, June 1981
                                                       Revised, June 1985


   The information in this document is subject to change  without  notice
   and  should  not  be  construed  as  a commitment by Digital Equipment
   Corporation.  Digital Equipment Corporation assumes no  responsibility
   for any errors that may appear in this document.

   The software described in this document is furnished under  a  license
   and  may  be  used or copied only in accordance with the terms of such
   license.

   No responsibility is assumed for the use or reliability of software on
   equipment that is not supplied by Digital Equipment Corporation or its
   affiliated companies.



         Copyright (c) 1981, 1985 by Digital Equipment Corporation
                            All Rights Reserved.


                             Printed in U.S.A.




   The postpaid READER'S COMMENTS form on the last page of this  document
   requests  the user's critical evaluation to assist in preparing future
   documentation.

   The following are trademarks of Digital Equipment Corporation:

        DEC                DIBOL              RSX
        DEC/CMS            EduSystem          UNIBUS
        DEC/MMS            IAS                VAX
        DECnet             MASSBUS            VMS
        DECsystem-10       PDP                VT
        DECSYSTEM-20       PDT                
        DECUS              RSTS               
        DECwriter                             















                                      CONTENTS



           1       STRUCTURE OF THIS DOCUMENT . . . . . . . . . . . . iii
           2       CONVENTIONS USED IN THIS DOCUMENT  . . . . . . . .  iv


   CHAPTER 1       OVERVIEW

           1.1     OVERVIEW . . . . . . . . . . . . . . . . . . . . . 1-1


   CHAPTER 2       USING SDL

           2.1     USING SDL  . . . . . . . . . . . . . . . . . . . . 2-1
           2.1.1     SDL Source Language Syntax . . . . . . . . . . . 2-1
           2.1.1.1   Valid Names  . . . . . . . . . . . . . . . . . . 2-1
           2.1.1.2   Keywords . . . . . . . . . . . . . . . . . . . . 2-3
           2.1.1.3   Expressions  . . . . . . . . . . . . . . . . . . 2-3
           2.1.1.4   Output Comments  . . . . . . . . . . . . . . . . 2-4
           2.1.1.5   Local Comments . . . . . . . . . . . . . . . . . 2-4
           2.1.1.6   INCLUDE statement  . . . . . . . . . . . . . . . 2-4
           2.1.2     SDL Data Types . . . . . . . . . . . . . . . . . 2-4
           2.1.2.1   Integer Data Type Keywords . . . . . . . . . . . 2-5
           2.1.2.2   Floating-Point Data Type Keywords  . . . . . . . 2-5
           2.1.2.3   Packed Decimal Data Type Keyword . . . . . . . . 2-5
           2.1.2.4   Bit-String Data Type Keyword . . . . . . . . . . 2-5
           2.1.2.5   Boolean Data Type Keyword  . . . . . . . . . . . 2-6
           2.1.2.6   Character-String Data Type Keyword . . . . . . . 2-6
           2.1.2.7   Address and Pointer Data Type Keyword  . . . . . 2-6
           2.1.2.8   User specified TYPE name . . . . . . . . . . . . 2-7
           2.1.3     Declarations . . . . . . . . . . . . . . . . . . 2-8
           2.1.3.1   MODULE Declarations  . . . . . . . . . . . . . . 2-8
           2.1.3.2   Local Symbol Declarations  . . . . . . . . . . . 2-8
           2.1.3.3   CONSTANT Declarations  . . . . . . . . . . . . . 2-8
           2.1.3.4   AGGREGATE Declarations . . . . . . . . . . . .  2-10
           2.1.3.4.1 Subaggregate Declarations  . . . . . . . . . .  2-12
           2.1.3.4.2 Data Alignment and Offsets Within Aggregates .  2-12
           2.1.3.5   Specifying the Size of an Aggregate  . . . . .  2-14
           2.1.3.6   Forcing Negative Offsets . . . . . . . . . . .  2-14
           2.1.3.7   ITEM Declarations  . . . . . . . . . . . . . .  2-15
           2.1.3.8   ENTRY Declarations . . . . . . . . . . . . . .  2-15
           2.1.4     Storage Classes  . . . . . . . . . . . . . . .  2-16
           2.1.5     Dimensions . . . . . . . . . . . . . . . . . .  2-17
           2.1.6     Prefixes and Tags  . . . . . . . . . . . . . .  2-18


   CHAPTER 3       SDL LANGUAGE AND COMMAND REFERENCE

           3.1     LANGUAGE AND COMMAND REFERENCE . . . . . . . . . . 3-1
           3.1.1     The SDL Command  . . . . . . . . . . . . . . . . 3-2
           3.1.2     Syntax Rules . . . . . . . . . . . . . . . . . . 3-6
           3.1.2.1   Names  . . . . . . . . . . . . . . . . . . . . . 3-6
           3.1.2.1.1 Expressions  . . . . . . . . . . . . . . . . . . 3-6
           3.1.2.1.2 Operators  . . . . . . . . . . . . . . . . . . . 3-7
           3.1.2.2   Output Comments  . . . . . . . . . . . . . . . . 3-7

                                     3



           3.1.2.3   Local Comments . . . . . . . . . . . . . . . . . 3-8
           3.1.3     Declarations . . . . . . . . . . . . . . . . . . 3-8
           3.1.3.1   MODULE Declarations  . . . . . . . . . . . . . . 3-8
           3.1.3.2   Local Symbol Declarations  . . . . . . . . . . . 3-9
           3.1.3.3   CONSTANT Declarations  . . . . . . . . . . . . . 3-9
           3.1.3.4   AGGREGATE Declarations . . . . . . . . . . . .  3-11
           3.1.3.4.1 STRUCTURE Declarations . . . . . . . . . . . .  3-13
           3.1.3.4.2 UNION Declarations . . . . . . . . . . . . . .  3-13
           3.1.3.5   Member Declarations  . . . . . . . . . . . . .  3-14
           3.1.3.6   Implicit Union Declarations  . . . . . . . . .  3-15
           3.1.3.6.1 DIMENSION with Implicit Union  . . . . . . . .  3-16
           3.1.3.7   ITEM Declarations  . . . . . . . . . . . . . .  3-17
           3.1.3.8   ENTRY Declarations . . . . . . . . . . . . . .  3-18
           3.1.4     Data Types . . . . . . . . . . . . . . . . . .  3-21
           3.1.5     Storage Classes  . . . . . . . . . . . . . . .  3-23
           3.1.6     Dimensions . . . . . . . . . . . . . . . . . .  3-24
           3.1.7     Prefixes and Tags  . . . . . . . . . . . . . .  3-24
           3.1.7.1   Prefixes . . . . . . . . . . . . . . . . . . .  3-24
           3.1.7.2   Tags . . . . . . . . . . . . . . . . . . . . .  3-25
           3.1.8     Translation Summaries  . . . . . . . . . . . .  3-27
           3.1.8.1   BLISS-32 Translation Summary . . . . . . . . .  3-28
           3.1.8.2   C Translation Summary  . . . . . . . . . . . .  3-30
           3.1.8.3   FORTRAN Translation Summary  . . . . . . . . .  3-32
           3.1.8.4   MACRO-32 . . . . . . . . . . . . . . . . . . .  3-34
           3.1.8.5   PL/I Translation Summary . . . . . . . . . . .  3-37
           3.1.8.6   PASCAL Translation Summary . . . . . . . . . .  3-39
           3.1.8.7   DATATRIEVE Translation Summary . . . . . . . .  3-42
           3.1.8.8   EPASCAL Translation Summary  . . . . . . . . .  3-45
           3.1.8.9   ADA Translation Summary  . . . . . . . . . . .  3-51


   CHAPTER 4       EXAMPLES

           4.1     EXAMPLES . . . . . . . . . . . . . . . . . . . . . 4-1
           4.1.1     SDL Source File Listing  . . . . . . . . . . . . 4-1
           4.1.2     BLISS-32 (BLISSF) Output . . . . . . . . . . . . 4-5
           4.1.3     C Output . . . . . . . . . . . . . . . . . . . . 4-8
           4.1.4     FORTRAN Output . . . . . . . . . . . . . . . .  4-11
           4.1.5     MACRO-32 Output  . . . . . . . . . . . . . . .  4-14
           4.1.6     PL/I Output  . . . . . . . . . . . . . . . . .  4-17
           4.1.7     PASCAL Output  . . . . . . . . . . . . . . . .  4-20
           4.1.8     DATATRIEVE Output  . . . . . . . . . . . . . .  4-24
           4.1.9     ELN Pascal Output  . . . . . . . . . . . . . .  4-27
           4.1.10    Ada Output . . . . . . . . . . . . . . . . . .  4-30


   APPENDIX A      SUMMARY OF SDL KEYWORDS 


   APPENDIX B      SDL ERROR MESSAGES AND ERROR CONDITIONS 




                                     4



   APPENDIX C      GENERATING SDL OUTPUT FOR OTHER LANGUAGES 

           C.1     REQUIREMENTS FOR WRITING A NEW SDL BACK END  . . . C-1
           C.1.1     The SDL$PUTLINE Routine  . . . . . . . . . . . . C-2
           C.1.2     Writing a Source File Header . . . . . . . . . . C-2
           C.1.3     Error Message Output . . . . . . . . . . . . . . C-3
           C.2     BUILDING A NEW SDL BACK END  . . . . . . . . . . . C-3
           C.3     THE SDL TREE . . . . . . . . . . . . . . . . . . . C-4
           C.3.1     General Format of Tree Nodes . . . . . . . . . . C-7
           C.3.2     Node Types and Definitions . . . . . . . . . .  C-10
           C.3.2.1   ROOT Nodes . . . . . . . . . . . . . . . . . .  C-10
           C.3.2.2   Comment Node . . . . . . . . . . . . . . . . .  C-10
           C.3.2.3   Constant Nodes . . . . . . . . . . . . . . . .  C-10
           C.3.2.4   Entry Nodes  . . . . . . . . . . . . . . . . .  C-11
           C.3.2.5   Item Nodes . . . . . . . . . . . . . . . . . .  C-11
           C.3.2.6   Module Nodes . . . . . . . . . . . . . . . . .  C-13
           C.3.2.7   Parameter Nodes  . . . . . . . . . . . . . . .  C-13
           C.3.2.8   Object Nodes . . . . . . . . . . . . . . . . .  C-14
           C.3.2.9   Head Nodes . . . . . . . . . . . . . . . . . .  C-15
           C.3.3     Data Type Information  . . . . . . . . . . . .  C-15
           C.3.3.1   Integers . . . . . . . . . . . . . . . . . . .  C-15
           C.3.3.2   Character Strings  . . . . . . . . . . . . . .  C-16
           C.3.3.3   Packed Decimal . . . . . . . . . . . . . . . .  C-16
           C.3.3.4   Bit Fields . . . . . . . . . . . . . . . . . .  C-16
           C.3.3.5   Boolean Data . . . . . . . . . . . . . . . . .  C-16
           C.3.3.6   Address Data . . . . . . . . . . . . . . . . .  C-16
           C.3.3.7   Structure Aggregates . . . . . . . . . . . . .  C-17
           C.3.3.8   Union Aggregates . . . . . . . . . . . . . . .  C-17
           C.3.3.9   Parameter Passing Attributes . . . . . . . . .  C-17
           C.4     SOURCES  . . . . . . . . . . . . . . . . . . . .  C-18
           C.4.1     The PL/I Output Routine  . . . . . . . . . . .  C-19























                                     5












                                  PREFACE                                  PREFACE




   This document describes the VAX Structure Definition Language (SDL), a
   translator  that transforms data definitions into statements of one or
   more target VAX source languages.  SDL is  suitable  for  systems  and
   application  programming  environments  where  an  executable  program
   consists of modules written in two or more programming languages.



   INTENDED AUDIENCE   INTENDED AUDIENCE


   It is assumed that readers are familiar with one or  more  programming
   languages  and  are  currently  involved  in multilanguage programming
   applications.  This document is not a tutorial.



   STRUCTURE OF THIS DOCUMENT   STRUCTURE OF THIS DOCUMENT

   This manual consists of the following chapters and appendixes:

        o  Chapter 1 contains a brief overview of the features  available
           in SDL.

        o  Chapter 2 provides a presentation of SDL declarations, showing
           sample SDL input lines and resulting output.

        o  Chapter 3 is a reference section that defines  the  syntax  of
           SDL declarations and options.

        o  Chapter 4 provides a complete example of an SDL input file and
           output files produced for the supported languages.

        o  Appendix A summarizes SDL keywords.

        o  Appendix B provides detailed information on extending  SDL  to
           produce output for additional target languages.



                                    iii
                                  PREFACE                                  PREFACE


        o  Appendix C describes the requirements for writing a routine to
           generate output for additional target languages.

   This  document  is  structured  so  that  information  pertaining   to
   additional   language   output   may   be  incorporated  easily.   The
   Translation Summaries at the end of  Chapter  3  describe  the  output
   generated for individual target languages.

   Examples in Chapter 4 illustrate the output generated  for  individual
   target languages using a representative source file.

   The SDL software is distributed by the Technical  Languages  Group  to
   any  interested  groups  within DIGITAL.  To request a copy of the SDL
   software, to report problems, or to obtain the source files  necessary
   to  generate  an  output  routine  for  another  language, contact the
   Technical Languages Development Group, ZK2-3/N30.



   CONVENTIONS USED IN THIS DOCUMENT   CONVENTIONS USED IN THIS DOCUMENT


   The following conventions are used in this document:


   Convention       Meaning   Convention       Meaning


   { STRUCTURE }    Stacked  items  within  braces  indicate  a   choice;
   { UNION }        one of the items must be selected.

   [ ]              Simple square brackets  indicate  that  the  enclosed
                    item(s) are optional.

   [ COMMON ]       Stacked items within brackets  indicate  an  optional
   [ GLOBAL ]       choice; only one may be selected.

   MODULE name;     Names shown in  uppercase  letters  in  examples  and
                    format  descriptions  are SDL keywords, which must be
                    specified as shown in SDL files.  Names and syntactic
                    elements   shown   in   lowercase  letters  represent
                    user-specified names and identifiers.

   arg,...          A comma  followed  by  an  ellipsis  means  that  the
                    preceding  item  may  be  repeated one or more times,
                    with commas separating two or more items.








                                     iv












                                 CHAPTER 1                                 CHAPTER 1

                                  OVERVIEW                                  OVERVIEW




   The VAX  Structure  Definition  Language  (SDL)  is  a  compiler-  and
   language-independent   data   definiton   language.   Data  structures
   declared in SDL can be translated into source  statements  of  one  or
   more  VAX  languages.  The resulting language source files can then be
   subsequently compiled or assembled and linked.

   SDL eliminates the need for multiple language declarations of the same
   data   structure.   Thus,  the  source  files  for  any  multilanguage
   implementation can be more easily maintained since only one version of
   each data structure need be modified.

   The current version  of  SDL  is  distributed  with  support  for  the
   following languages:

        o  VAX Ada

        o  VAX BLISS

        o  VAX C

        o  VAX DATATRIEVE

        o  VAX FORTRAN

        o  VAX MACRO

        o  VAX PASCAL

        o  VAX PL/I

        o  ELN Pascal

   SDL documentation provides a detailed explanation of the  requirements
   for building new language-specific modules to output source statements
   for additional languages.



                                    1-1
   OVERVIEW   OVERVIEW


   The language back ends are separate images located  in  SYS$SHARE  and
   are of the form "SDL{language}.EXE," where {language} is any string of
   characters representing the language.  For example:

        SDLFORTRA.EXE   is the FORTRAN image.
        SDLPLI.EXE      is the PL/I image.
        SDLCC.EXE       is the C image.

   SDL translates declarations of:

        o  Data structures

        o  Scalar items

        o  Named constants

        o  External entries

   Each target source language back end translates only the  declarations
   that   can   (or   need)   be  expressed  in  that  language.   Figure
   1-<sdl_translator> shows the relationship of the SDL translator to its
   input  and  output  files.  Examples 1 and 2 show a representative SDL
   source file and its PL/I output with  notes  that  highlight  some  of
   SDL's features.






























                                    1-2
                                                                 OVERVIEW                                                                 OVERVIEW


   Example 1:  Sample SDL Source File   Example 1:  Sample SDL Source File

        MODULE opr_descriptor;

        /* define constants and node structure for operators

                #max_args = 10;

                CONSTANT (fixed_binary,floating,char,untyped) 
                                EQUALS 1 INCREMENT 1;

                AGGREGATE operator STRUCTURE PREFIX "opr_";
                        flink ADDRESS;
                  blink ADDRESS;
                        opcount WORD;
                        optype CHARACTER LENGTH 1;
                        id WORD;
                        flags STRUCTURE tag "b_";
                                is_constant_size BITFIELD LENGTH 1;
                                is_terminator BITFIELD LENGTH 1;
                                context BITFIELD LENGTH 3;
                                filler BITFIELD LENGTH 8-^;
                                END;
                        #opsize = .; 
                        operands LONGWORD DIMENSION 0:#max_args-1;
                        END;

                CONSTANT opr_node_size EQUALS #opsize / 2;

                ITEM current_node_ptr ADDRESS GLOBAL;

        END_MODULE;

   The following rules apply to Examples 1 and 2:

        1.  All SDL declarations are grouped within modules.

        2.  Local  symbols  (beginning  with  #  characters)  are   known
            throughout  a  source file, and may be used to express values
                                                  #max_args            in declarations.  Note how the symbol #max_args  is  used  in
                                         operands            the declaration of the array operands, below.

        3.  CONSTANT   declarations   produce   declarations   of   named
            constants.    When  an  increment  value  is  specified,  SDL
            automatically  increments  the   initial   value   for   each
            declaration in the list.

        4.  AGGREGATE  declarations  define  data  structures  and  their
            members.

        5.  When a PREFIX option is specified, SDL forms identifier names
            for  the  target language output file(s) by concatenating the
            prefix and a data type code to  the  declared  member  names.

                                    1-3
   OVERVIEW   OVERVIEW


            Compare  these  declarations  with  the  PL/I output shown in
            Example 2.


   Example 2:  The PL/I Output for the Sample SDL Source File   Example 2:  The PL/I Output for the Sample SDL Source File

         
        /*** MODULE opr_descriptor ***/
        /* define constants and node structure for operators
        */
        %REPLACE fixed_binary BY 1;
        %REPLACE floating BY 2;
        %REPLACE char BY 3;
        %REPLACE untyped BY 4;
         
        %REPLACE opr_s_operator BY 54;
        DCL 1 operator  BASED ,
             2 opr_a_flink pointer,
             2 opr_a_blink pointer,
             2 opr_w_opcount fixed binary(15),
             2 opr_t_optype character(1),
             2 opr_w_id fixed binary(15),
             2 opr_b_flags,
              3 opr_v_is_constant_size bit(1),
              3 opr_v_is_terminator bit(1),
              3 opr_v_context bit(3),
              3 opr_v_filler bit(3),
             2 opr_l_operands (0:9) fixed binary(31);
        %REPLACE opr_node_size BY 7;
        DCL current_node_ptr pointer GLOBALREF ;

        6.  Within an aggregate, members  are  declared  with  data  type
            attributes specified by SDL keywords.

        7.  The circumflex (^) character is shorthand for the current bit
            offset  from  the most recently declared subaggregate.  Here,
                               filler            the declaration of filler pads the bit structure  to  a  byte
            boundary.

        8.  The period character is shorthand for the current byte offset
            within   the   AGGREGATE   declaration.   This  local  symbol
            declaration captures the size of the constant portion of  the
                       operator            structure  operator.   Note  how  its  value  is  used in the
                                        opr_node_size            declaration of the constant opr_node_size.

        9.  Any aggregate or scalar can have  a  dimension.   This  array
                  operands            named operands has 10 elements, with subscripts 0 through 9.

       10.  Data  need  not  be  declared  within  aggregates;  an   ITEM
                                                         current_node_ptr            declaration  such  as  this  declaration  of current_node_ptr
            defines a scalar item.



                                    1-4
                                                                 OVERVIEW                                                                 OVERVIEW


       11.  The GLOBAL keyword denotes global storage for an item  or  an
            aggregate   to   override  the  default  storage  class,  the
            interpretation of which is language specific.



















































                                    1-5












                                 CHAPTER 2                                 CHAPTER 2

                                 USING SDL                                 USING SDL




   This chapter provides a functional description of SDL, with examples.

   The basic structural unit of an  SDL  definition  file  is  a  module.
   Modules  group  declarations  of  related  identifiers and structures.
   They may correspond to assembly language MACRO-32 definition files  or
   higher-level language INCLUDE files.

   Table 2-1 shows the declarations that are valid within  a  module  and
   summarizes,  for each declaration, the SDL attributes and options that
   can be applied.  You can enter declarations in a module in any  order,
   as long as a given declaration precedes any references to it.



   2.1  SOURCE LANGUAGE SYNTAX   2.1  SOURCE LANGUAGE SYNTAX

   An  SDL  statement,  or  a  declaration,  consists  of  SDL  keywords,
   user-specified identifiers, and expressions, which are terminated by a
   semicolon.  Spaces or tabs delimit these elements in a declaration.



   2.1.1  Valid Names   2.1.1  Valid Names

   SDL names are used to specify source program identifiers and SDL local
   symbol names.  Names can consist of any of the characters A through Z,
   a through z, 0 through 9, dollar sign ($)  and  underscore  (_).   All
   source  program  identifiers  must  begin with an alphabetic letter, a
   dollar sign, or an underscore.  Local symbol names must begin  with  a
   number sign (#), which is not otherwise valid in SDL names.

   Source language identifiers are passed through exactly as  written  to
   the  target  language  back  ends,  with the addition of SDL-generated
   prefixes, if specified in the declaration.  For example, if you  enter
   an identifier in lowercase letters, it is passed through to the target
   language source files in lowercase letters.  Because of this  feature,
   SDL  is  also  case  sensitive with respect to identifiers.  If an SDL

                                    2-1
   USING SDL   USING SDL


   name refers back to a previously defined identifier, the name must  be
   a  case-sensitive match.  You can enclose a name in quotation marks if
   you need to use characters that are not valid in SDL identifiers.


           Table 2-1: Attributes and Options for SDL Declarations           Table 2-1: Attributes and Options for SDL Declarations



                                        Applicable Language Elements
                                        ----------------------------------
                                        Data        Storage             Prefix/
                                        Type        Class    Dimension  Tag
                                        Attributes  Option   Option     Options

        Valid Declarations

        MODULE declaration ;

        /*comment                       no          no       no         no

            local name declaration ;    no          no       no         no

            CONSTANT declaration ;      no          no       yes        yes

            AGGREGATE declaration ;     yes         yes      yes        yes

                member declaration ;    yes         no       yes        yes
                .
                .
                .
                subaggregate ;          yes         yes      yes        yes
                    member
                    .
                    .
                    .
                    END;
                .
                .
                .
                END;

            ITEM declaration            yes         yes      yes        yes

            ENTRY declaration           no          no       no         no

        END_MODULE;

   Note that in SDL local symbol names, uppercase and  lowercase  letters
   are  equivalent.   For  example, #ABC and #abc refer to the same local
   symbol.



                                    2-2
                                                                USING SDL                                                                USING SDL


   2.1.2  Keywords   2.1.2  Keywords

   All SDL keywords are reserved words; they can  be  entered  in  either
   uppercase  or  lowercase,  but  cannot be truncated.  Keywords are not
   allowed as program identifiers unless they are enclosed  in  quotation
   marks.  For example:

        ITEM "length" LONGWORD;

                                                                  length   This  declaration  produces  the  source  program  identifier  length.
   Appendix A summarizes SDL keywords.



   2.1.3  Expressions   2.1.3  Expressions

   Valid SDL expressions can consist of any of the following:

        o  Numeric constants,  which  can  be  expressed  using  decimal,
           hexadecimal,  octal,  binary,  or  ASCII notation.  SDL treats
           decimal constants as signed longwords.  Decimal is the default
           unless  one  of the radix specifiers %X, %O, or %B indicates a
           hexadecimal, octal,  or  binary  constant,  respectively.   %A
           indicates  an  integer  with  the ASCII value of the character
           that follows it.

        o  The following operators, which perform operations  on  numeric
           constants  or  SDL  local  symbols and declared constants with
           integer values:

                unary -
                * and /
                + and -
                @ (logical shift)
                ! (logical OR)
                & (logical AND)

        o  SDL local symbols and declared output  constants,  which  have
           integer longword values.

        o  The offset  location  symbols.   These  are  the  period  (.),
           representing  the  current  byte  offset from the origin in an
           AGGREGATE declaration; the colon (:), representing the current
           byte  offset  relative  to  the  first  member in an aggregate
           declaration; and the  circumflex  (^),  representing  the  bit
           offset  from  the  most  recent  byte-aligned  element.  These
           symbols are described more fully in Section 2.3.4.2.

        o  Parentheses, which group expressions to define  the  order  of
           evaluation.    Expressions   within   the   innermost  set  of
           parentheses are evaluated first.



                                    2-3
   USING SDL   USING SDL


   2.1.4  Output Comments   2.1.4  Output Comments

   Anything appearing after the character pair /*, up to the end  of  the
   line, is considered an output comment.

   Comments appearing on lines by themselves are normally output  in  the
   target  language  source  file  as  separate  comment lines.  Comments
   appearing at the end of a line will  be  output  at  the  end  of  the
   corresponding target source line, if possible.



   2.1.5  Local Comments   2.1.5  Local Comments

   Anything appearing after the character {, up to the end of  the  line,
   is  considered  a  comment that is local to the SDL source file and is
   not output in the target language source  file.   Local  comments  may
   appear anyplace in the source file where white space is allowed.



   2.1.6  INCLUDE Statement   2.1.6  INCLUDE Statement

   The INCLUDE statement specifies that the contents of a file are to  be
   incorporated  in  the  SDL  translation directly following the INCLUDE
   statement.  The statement has the form:

         INCLUDE "file-spec";

   Where file-spec is any valid system file  specification.   An  INCLUDE
   statement  cannot appear embedded within an AGGREGATE.  Aside from the
   aggregate restriction, an INCLUDE statement can appear  anywhere  else
   within   the   module.    If  a  directory  is  not  included  in  the
   file-specification, the current default directory is used.

   When SDL encounters an INCLUDE statement, it stops  reading  from  the
   current  file  and reads the statements in the included file.  When it
   reaches the end of the included file, SDL resumes translation with the
   next declaration after the INCLUDE statement.



   2.2  DATA TYPES   2.2  DATA TYPES

   Data type keywords specify the data types of scalar objects, which can
   be declared as members of aggregates or as individual items.  The data
   type declaration also specifies, either implicitly or explicitly,  the
   size of a member.

   The next subsections describe the data types and the keywords you  use
   to specify them.  The translation tables in the SDL Language Reference
   show the SDL translations of each data type in a given  target  source
   language.

                                    2-4
                                                                USING SDL                                                                USING SDL


   2.2.1  Integer Data Type Keywords   2.2.1  Integer Data Type Keywords

   The data type keywords BYTE, WORD, LONGWORD,  QUADWORD,  and  OCTAWORD
   declare storage units of 8, 16, 32, 64, and 128 bits, respectively, to
   represent signed integer data.  Any  of  these  data  types  may  also
   specify the keyword UNSIGNED to indicate unsigned integer data.



   2.2.2  Floating-Point Data Type Keywords   2.2.2  Floating-Point Data Type Keywords

   The  data  type  keywords  F_FLOATING,  D_FLOATING,  G_FLOATING,   and
   H_FLOATING  declare  storage  units  for  single-,  double-,  G-,  and
   H-floating-point data, respectively.



   2.2.3  Packed Decimal Data Type Keyword   2.2.3  Packed Decimal Data Type Keyword

   The DECIMAL data type keyword declares a packed decimal data item  and
   specifies the size of the item, as in this example:

        ITEM percentage DECIMAL PRECISION (3,2);

   This declaration of the item  percentage  indicates  a  decimal  value
   consisting of three decimal digits, two of which are fractional.



   2.2.4  Bit-String Data Type Keyword   2.2.4  Bit-String Data Type Keyword

   The BITFIELD  keyword  declares  a  bit  field  variable.   Bit  field
   variables  must  be members of aggregates.  You can specify the LENGTH
   option to override the default length of 1.  For example:

        AGGREGATE flags STRUCTURE;
         data_type BITFIELD LENGTH 3;
         is_variable BITFIELD;
         END;

   This example illustrates a structure with two bit field declarations.

   If you specify the  MASK  option,  SDL  generates  both  a  bit  field
   variable and a constant bit mask for the variable.  For example:

        AGGREGATE flags STRUCTURE PREFIX tst$;
             resolved BITFIELD MASK;
             psv BITFIELD MASK;
             mark1 BITFIELD MASK;
             spare_bits BITFIELD LENGTH 5;
             END;



                                    2-5
   USING SDL   USING SDL


                         resolved   The  declaration  of  resolved  in  this  example   results   in   two
   declarations  in  the  output  file:   a declaration for the bit field
   itself and a declaration of a constant mask whose value is  1.   Since
   the  PREFIX  option  is  specified for this aggregate, the identifiers
                                     tst$v_resolved       tst$m_resolved   produced for this declaration are tst$v_resolved  and  tst$m_resolved,
   where  the  tag "v_" indicates the bit field variable and the tag "m_"
   indicates the mask.  Prefixes and tags are described in more detail in
   Section 2.6.



   2.2.5  Boolean Data Type Keyword   2.2.5  Boolean Data Type Keyword

   The BOOLEAN keyword declares a Boolean data type.  This is a  one-byte
   field that can have one of two values, 0 or 1.

   For example:

        ITEM true BOOLEAN;

   This declaration produces a Boolean variable in target languages.



   2.2.6  Character-String Data Type Keyword   2.2.6  Character-String Data Type Keyword

   The CHARACTER data type keyword declares a character string of a given
   length.   You  can  specify  the LENGTH option to override the default
   length of one character.  For example:

        AGGREGATE msg_buffer STRUCTURE;
         message_text CHARACTER LENGTH 256;
         severity WORD;
         END;

   In this example, the aggregate MSG_BUFFER contains a  character-string
                  message_text   member  named  message_text  with  a  length  of  256 characters.  For
   languages that  support  varying-length  character  strings,  you  can
   specify the VARYING keyword, as follows:

        message_text CHARACTER LENGTH 256 VARYING;

                               message_text   In this example, the member message_text has a maximum length  of  256
   characters.



   2.2.7  Address and Pointer Data Type Keyword   2.2.7  Address and Pointer Data Type Keyword

   The ADDRESS data type keyword declares a data item that is an address,
   or pointer.  For example:

        ITEM list_head ADDRESS;

                                    2-6
                                                                USING SDL                                                                USING SDL


                                              list_head   This declaration specifies a pointer named list_head.

   For those languages that require the data type of the  object  pointed
   to, you can specify the data type as follows:

        size_address ADDRESS (LONGWORD);

   This declaration indicates a pointer to a longword.

   The construct is ignored for languages in which pointers are  distinct
   data types.

   The object of the ADDRESS declaration can also be specified using  the
   name of a previously defined SDL aggregate.  For example:

        AGGREGATE any_node STRUCTURE;
           flink ADDRESS (any_node);
           blink ADDRESS (any_node);
           END;

                                                            any_node   In this example, the first two members of the structure  any_node  are
   forward  and  backward  pointers  to  similar  nodes.   Note  that  an
   aggregate that is the object of an ADDRESS declaration must  have  the
   default (based) storage class.



   2.2.8  User specified TYPE name   2.2.8  User specified TYPE name

   The TYPENAME keyword is used to specify a data type name that  is  not
   an  SDL keyword.  Depending on the language being generated, this name
   may or may not override the SDL keyword datatype.  For example;

          ENTRY SYS$FAO ALIAS $FAO PARAMETER (
         CHARACTER DESCRIPTOR NAMED CTRSTR IN TYPENAME CHARDESC,
         WORD UNSIGNED NAMED OUTLEN OUT DEFAULT 0 TYPENAME NUMBER,
         CHARACTER DESCRIPTOR NAMED OUTBUF OUT TYPENAME CHARDESC,
         LONGWORD VALUE NAMED P1 TYPENAME VARIES
         ) VARIABLE RETURNS LONGWORD TYPENAME CONDVALU;

   In the above example, the entry declaration as well  as  each  of  the
   parameters  have  a  user defined TYPENAME.  The Ada language back end
   makes use of these types.  See the Ada output example in Chapter 4 for
   an example of the TYPENAME usage.



   2.3  DECLARATIONS   2.3  DECLARATIONS

   The following sections describe MODULE declarations.




                                    2-7
   USING SDL   USING SDL


   2.3.1  MODULE Declarations   2.3.1  MODULE Declarations

   A MODULE declaration groups all related symbols and  data  structures.
   No declarations (other than comments) can occur outside of a module as
   defined by the limits of the MODULE and  END_MODULE  keywords.   Local
   symbol assignments can occur outside of a module.

   You must specify a module name in the MODULE  declaration;  this  name
   corresponds to the name of a MACRO.  For example:

        MODULE $modef;

   This declaration generates the beginning of the  declaration  for  the
                         $modef   macro or module named $modef.

   You can use the IDENT option in a MODULE declaration in order to  pass
   a  version  number  or other information to the target language source
   file.  For example:

        MODULE params IDENT "V2.0";

   You  can  optionally  specify  the  module  name  on  the   END_MODULE
   statement;  this  is  particularly  useful  if you place more than one
   MODULE declaration in the same SDL source file.  The  module  name  is
   case-sensitive  and must exactly match (in case) the name specified in
   the MODULE declaration.



   2.3.2  Local Symbol Declarations   2.3.2  Local Symbol Declarations

   Local symbols are known throughout the SDL source file.  They are  not
   translatable  into  target  source  language statements.  Local symbol
   names must begin with the # character.  You  can  use  any  valid  SDL
   expression  to  assign  a  signed  integer  longword  value to a local
   symbol.  Some examples of local symbol use are:

        #max_args = 255;
        #counter = #counter + 1;

   Local symbol declarations can occur anywhere in the SDL source file.



   2.3.3  CONSTANT Declarations   2.3.3  CONSTANT Declarations

   A CONSTANT declaration generates a list of one or more named constants
   in the target language.  It specifies a name or names and the constant
   values to be assigned to them.  For example:

        CONSTANT block_node_size EQUALS 24;



                                    2-8
                                                                USING SDL                                                                USING SDL


                                               block_node_size   This declaration creates the named constant block_node_size and  gives
   it the value of 24.

   Note  the  difference  between  SDL   local   symbols   and   constant
   declarations.   CONSTANT  declarations  and  their computed values are
   translated to the target source language.  The  names  and  values  of
   local symbols, on the other hand, are never passed directly through to
   the target source languages.  The values  of  declared  constants  and
   local  symbols are available for use in SDL expressions.  For example,
   you could define the local symbol #block_size as follows:

        #block_size = 24;

                            #block_size   Subsequent references to #block_size result in the use  of  the  value
   24, as in this SDL declaration:

        CONSTANT block_node_size EQUALS #block_size;

   CONSTANT declarations can also be specified in a comma-delimited list,
   as follows:

        CONSTANT 
         xyz EQUALS 10,
         alpha EQUALS 0,
         noname EQUALS 63;

   To specify related constants with the same or incremental values,  use
   a  CONSTANT  declaration with the INCREMENT option.  In this form, the
   EQUALS expression gives the value to be assigned to  the  first  named
   constant;  values for subsequent constants are derived by incrementing
   the first value by the specified increment and assigning the result to
   the next name in the list.  For example:

        CONSTANT (
                bits,
                bytes,
                words,
                longs,
                quads,
                octas
                ) EQUALS 0 INCREMENT 1 PREFIX ctx$;

   When SDL assigns incremental values, it loops until values  have  been
   assigned to all the names in a list.  If there is no INCREMENT clause,
   then the increment value  is  0;  thus,  the  same  initial  value  is
   assigned   to   all   the   names.    If  names  are  omitted  from  a
   comma-delimited list, SDL reserves the numbers that would be  assigned
   to names in those positions.  This lets you reserve numeric values for
   later assignment of names.  For example:

        CONSTANT
         (bad_block,bad_data,,,,
          overlay,rewrite) EQUALS 0 INCREMENT 4;

                                    2-9
   USING SDL   USING SDL


                                                                bad_block   In this example, SDL assigns the values 0 and 4 to the names bad_block
        bad_data   and  bad_data,  reserves  the  values  8,  12, and 16, and assigns the
                                 overlay     rewrite   values 20 and 24 to the names overlay and rewrite.

   The COUNTER option saves the last assigned value in a specified  local
   symbol for subsequent use.  For example:

        CONSTANT (pli,c,bliss,macro) 
          EQUALS 4 INCREMENT 4 PREFIX lang$
          COUNTER #lang;

        CONSTANT (basic,pascal,fortran) 
           EQUALS #lang + 4 INCREMENT 4 PREFIX lang$;

   The constant names produced by these two declarations are:

        Constant Name     Value        Constant Name     Value

        lang$k_pli        4
        lang$k_c          8
        lang$k_bliss      12
        lang$k_macro      16
        lang$k_basic      20
        lang$k_pascal     24
        lang$k_fortran    28

   You can comment individual  declarations  in  a  CONSTANT  declaration
   list.  For example:

        CONSTANT (
                pli,    /* PL/I
                c,      /* C
                macro   /* MACRO-32
                ) EQUALS 4 INCREMENT 4 PREFIX lang$;



   2.3.4  AGGREGATE Declarations   2.3.4  AGGREGATE Declarations

   AGGREGATE declarations group related  declarations  within  a  module.
   The two types of aggregates, structures and unions, are declared using
   the keywords STRUCTURE and UNION, and differ as follows:

        o  A structure's members occupy contiguous locations in  storage;
           each  member  has  a  unique  offset from the beginning of the
           structure.

        o  A  union's  first-level  members,  on  the  other  hand,   are
           overlaid;  each  one  begins at the beginning of the union and
           thus has an offset of zero.  Thus, a union lets you  represent
           the  same storage location using different names and different
           data types.


                                    2-10
                                                                USING SDL                                                                USING SDL


   Within an aggregate, you define members using data type keywords,  and
   delimit  the  end  of  the  aggregate  with an END delimiter as in the
   example below:

        AGGREGATE dcb STRUCTURE;
                type CHARACTER;
                size WORD;
                next ADDRESS;
                END dcb;

   You must terminate an aggregate declaration with an END  keyword;  the
   aggregate  name on the END (as shown in this example) is optional.  If
   the aggregate name is used on the END statement,  it  must  match  the
   name used in the AGGREGATE declaration with respect to case.

   An aggregate must contain at least one member declaration.   The  body
   of  an  aggregate can also contain local symbol declarations, CONSTANT
   declarations, and subaggregate declarations.

   An aggregate that is the target of an ADDRESS  declaration  must  have
   the default (based) storage class.

































                                    2-11
   USING SDL   USING SDL


   2.3.4.1  Subaggregate Declarations -   2.3.4.1  Subaggregate Declarations -

   Subaggregate declarations consist of names declared with either of the
   keywords   STRUCTURE  or  UNION,  which  represent  the  type  of  the
   subaggregate.  Within an aggregate, subaggregates can be nested up  to
   eight levels deep.

        AGGREGATE tree_node STRUCTURE;
         opcode WORD;
         lang_bits UNION;
          pli_bits STRUCTURE;
              resolved BITFIELD;
              psv BITFIELD;
              mark1 BITFIELD;
              spare_bits BITFIELD LENGTH 5;
              END pli_bits;
          c_bits STRUCTURE;
              value_variable_size BITFIELD;
              psv BITFIELD;
              expanded BITFIELD;
              resolved BITFIELD;
              reduced BITFIELD;
              spare_bits BITFIELD LENGTH 3;
              END c_bits;
          END lang_bits;
        END tree_node;

                                        pli_bits       c_bits   In  this  example,  the  structures  pli_bits  and  c_bits  are   both
                                  lang_bits         lang_bits   subaggregates  of  the  union  lang_bits.  Since lang_bits is a union,
   c_bits     pli_bits   c_bits and pli_bits occupy the same storage.



   2.3.4.2  Data Alignment and Offsets Within Aggregates -   2.3.4.2  Data Alignment and Offsets Within Aggregates -

   SDL  forces  all  aggregates  and  subaggregates  to  begin  on   byte
   boundaries.  Thus, if an aggregate or subaggregate ends with bit field
   declarations that do not end on byte boundaries, SDL ensures that  the
   next  aggregate  will  begin  on a byte boundary by supplying BITFIELD
   declarations as fillers if necessary.

   When SDL adds BITFIELD declarations, it determines the length required
                                          string$v_fill_n   string   and provides a unique name of the form string$v_fill_n.  string is the
   prefix supplied in the aggregate declaration, or the aggregate name if
                                                     n   no  prefix  was  supplied.   Within an aggregate, n begins at 0 and is
   incremented for each filler required.

   Note that the subaggregates shown in  the  example  in  the  preceding
   section  declare  filler bit fields to force byte alignment at the end
   of each subaggregate; this programming practice makes  it  unnecessary
   for SDL to perform the alignment.



                                    2-12
                                                                USING SDL                                                                USING SDL


   SDL provides three ways to refer to an offset within an aggregate:

        1.  The current byte offset symbol, the  period  (.),  is  always
            equal  to  the  current  byte  offset  from the origin of the
            AGGREGATE.  If an ORIGIN attribute is present, the  value  of
            the  period  is  equal  to  the  byte  offset from the member
            specified in the attribute.

        2.  The colon (:) is similar to the period in that it equals  the
            current  byte  offset  in an AGGREGATE declaration.  However,
            the value of the colon is always relative to the first member
            of  the  aggregate; that is, the value is not affected by the
            presence of an ORIGIN attribute.

        3.  The current bit offset symbol, the circumflex (^), is  always
            equal to the current bit offset relative to the most recently
            declared aggregate.

   The current bit offset is set at 0 at the beginning of each  aggregate
   and  incremented  by  the  bit lengths of each structure member in the
   aggregate at that level.  Consider the following example:

        AGGREGATE dcb STRUCTURE PREFIX dcb$;
         .
         .
         .
         uflags STRUCTURE;
          context BITFIELD LENGTH 3;
          local BITFIELD;
          END uflags;
         flags STRUCTURE;
          extern BITFIELD;
          relo BITFIELD;
          END flags;

   In this example, the bit offsets of the members  of  these  structures
   are as follows:

        Member            Bit Offset        Member            Bit Offset

        dcb$v_context     0
        dcb$v_local       3
        dcb$v_fill_0      4
        dcb$v_extern      0
        dcb$v_relo        1
        dcb$v_fill_1      2

                                          flags   Note that SDL has forced the structure flags to be aligned on  a  byte
   boundary.





                                    2-13
   USING SDL   USING SDL


   2.3.5  Specifying the Size of an Aggregate   2.3.5  Specifying the Size of an Aggregate

   The current byte offset symbol, the period, is  useful  for  capturing
   the  size  of  an  aggregate  or a portion of it.  For example, in the
   declaration of a variable-length data structure, you can  capture  the
   size of the fixed-length portion, as shown in this example:

        AGGREGATE operator STRUCTURE PREFIX opr_;
           flink ADDRESS;
           blink ADDRESS;
           opcount WORD;
           optype CHARACTER LENGTH 1;
           id WORD;
           flags STRUCTURE;
               is_constant_size BITFIELD LENGTH 1;
               is_terminator BITFIELD LENGTH 1;
               context BITFIELD LENGTH 3;
               filler BITFIELD LENGTH 8-^;
               END;
           #opsize = .; 
           operands LONGWORD DIMENSION(#max_args);
           END;

        CONSTANT node_size EQUALS #opsize / 2;

                          #opsize   Here, the local symbol #opsize captures the byte offset following  the
                                              operator   fixed-length  portion  of  the  structure  operator.   This  value  is
   subsequently used in the CONSTANT declaration, which defines the  size
   of the constant portion of the structure in words.



   2.3.6  Forcing Negative Offsets   2.3.6  Forcing Negative Offsets

   The ORIGIN option on a subaggregate declaration lets  you  define  the
   beginning  of  an  aggregate with respect to another aggregate member.
   For example:

         AGGREGATE nodes STRUCTURE ORIGIN qflink;
          flink ADDRESS;
          blink ADDRESS;
          qflink ADDRESS;
          qblink ADDRESS;
          END;

                                                        nodes   This declaration defines the origin of the structure nodes  to  be  at
               qflink        flink     blink   the  member qflink.  Thus flink and blink may be addressed as negative
                qflink   offsets from qflink.  Note that specifying an origin does  not  change
   the  values  of  the  current  bit  and byte offset symbols (^ and :).
   These are always calculated as being relative to the beginning of  the
   aggregate.



                                    2-14
                                                                USING SDL                                                                USING SDL


   2.3.7  ITEM Declarations   2.3.7  ITEM Declarations

   ITEM declarations let you define scalar items  and  single-dimensional
   arrays  of  scalar  items  that  are  not  members of aggregates.  For
   example:

        ITEM block_list_id WORD;

   This declaration specifies a word data item that is not a member of an
   aggregate.



   2.3.8  ENTRY Declarations   2.3.8  ENTRY Declarations

   An ENTRY declaration produces an entry or function declaration in  the
   target language(s).  Options let you specify:

        o  Descriptions of the entry's parameters  (for  those  languages
           that require parameters to be described).

        o  The return data type, if the entry represents a function.

        o  The VARIABLE option, to indicate that the entry point  can  be
           invoked with a variable number of parameters.

        o  The TYPENAME keyword followed by an  identifier  to  supply  a
           named datatype that is not an SDL keyword.

   For example:

        ENTRY random PARAMETER (LONGWORD) RETURNS LONGWORD;

   The ENTRY declaration shown above illustrates an entry  point  with  a
   single  longword  parameter  that  returns  a longword value.  You can
   specify the following keywords on an ENTRY declaration to clarify  how
   a parameter is to be passed:

        o  Specify the VALUE keyword to indicate that a parameter  is  to
           be  passed by immediate value.  You must specify the data type
           of the parameter or the ANY keyword.

        o  Specify the ANY keyword to indicate that the parameter  is  of
           any  data  type.   If  VALUE  is  not  specified with ANY, the
           parameter is passed by reference.

        o  Specify the DESCRIPTOR keyword when a parameter must be passed
           by descriptor.

        o  Specify the IN and OUT keywords to indicate input  and  output
           parameters.   Both these keywords may be specified to indicate
           a parameter that is both an input and an output parameter.


                                    2-15
   USING SDL   USING SDL


        o  Specify the NAMED keyword followed by an identifier to  supply
           a name for the parameter.

        o  Specify the TYPENAME keyword  followed  by  an  identifier  to
           supply a named datatype that is not an SDL keyword.

   For example, the system service SYS$GETJPI could be declared using SDL
   as follows:

        ENTRY SYS$GETJPI ALIAS $GETJPI PARAMETER (
           LONGWORD UNSIGNED VALUE NAMED EFN DEFAULT 0 TYPENAME EFNUM,
           LONGWORD UNSIGNED NAMED PIDADR IN OUT DEFAULT 0 TYPENAME
        PROCID,
           CHARACTER DESCRIPTOR NAMED PRCNAM IN DEFAULT 0 TYPENAME
        PROCNAME,
           ANY NAMED ITMLST IN TYPENAME ITEMLIST,
           QUADWORD UNSIGNED NAMED IOSB OUT DEFAULT 0 TYPENAME IOSB,
           ADDRESS(ENTRY) NAMED ASTADR DEFAULT 0 TYPENAME ASTADR,
           LONGWORD UNSIGNED VALUE NAMED ASTPRM DEFAULT 0 TYPENAME
        USERPARM
           ) RETURNS LONGWORD TYPENAME CONDVALU;



   2.4  STORAGE CLASSES   2.4  STORAGE CLASSES

   Each target language output routine selects a default "storage  class"
   for  all scalar items and aggregates.  The storage class refers to the
   manner in which the target compiler  will  allocate  storage  for  the
   aggregate  or  item.  The default storage class is based; that is, the
   scalar items and aggregates are defined so that they describe data for
   which  storage is not allocated at compile time.  The data description
   serves as a template for storage allocated dynamically  at  run  time.
   For example, the MACRO-32 output routine places all declarations in an
   absolute program section by default and associates the names with  the
   offset  values.   The PL/I output routine uses the BASED storage class
   attribute.

   SDL provides the mechanism for  specifying  either  of  the  following
   storage classes to override the default storage class:

        o  Common storage is allocated in  an  external  program  section
           (Psect)  with  the OVR attribute and is shared by all routines
           that reference it.  You declare  data  in  common  storage  by
           using the COMMON option on an AGGREGATE or ITEM declaration.

        o  Global storage represents data in a  global  storage  location
           whose  value is defined elsewhere.  You declare global data by
           using the GLOBAL option on an AGGREGATE or ITEM declaration.

           For some  languages,  the  /GLOBALDEF  qualifier  to  the  SDL
           command  affects  declarations  of  items  and aggregates that
           specify the GLOBAL  option.   This  qualifier  causes  SDL  to

                                    2-16
                                                                USING SDL                                                                USING SDL


           generate  declarations  indicating  that  a  global  value  is
           defined in this module.

   See the translation tables in Chapter 3 for the  SDL  translations  of
   each storage class in a given target source language.

   Note that SDL  also  allows  MACRO-32  output  declarations  that  can
   generate  global  definitions  when  an  invocation  of  the  macro is
   assembled.  For example, suppose the SDL module  $IODEF  contains  the
   following constant declarations:

        CONSTANT (
         nop,
         unload,
         loadmcode,
         seek,
         spacefile,
         startmproc,
         recal,
         stop,
         drvclr,
         initialize) EQUALS 0 INCREMENT 1 PREFIX "io$";

   The  MACRO-32  output  generated  by  this  declaration  is  a   macro
   definition, which may be invoked as follows:

        $IODEF <==>

   This argument results in global constant definitions rather than local
   constant definitions.  To request that the locations of data fields be
   defined globally you add the argument <::> following  the  <==>.   The
   MACRO-32 Translation Summary in Chapter 3 describes this usage in more
   detail.

   In languages that  support  the  construct,  you  can  use  the  BASED
   pointer-name  option  on  an  AGGREGATE  declaration  to  bind a named
   pointer to that aggregate.  In all  target  languages,  the  aggregate
   resulting  from  such  a  declaration  has  the  default storage class
   (based).



   2.5  DIMENSIONS   2.5  DIMENSIONS

   Aggregates (as well as subaggregates and members of aggregates) can be
   dimensioned;  that  is,  you  can  define  an  array  of structures, a
   structure that contains one or more arrays, or an array of  structures
   each of which contains one or more arrays.  For example:






                                    2-17
   USING SDL   USING SDL



                 AGGREGATE array_info STRUCTURE;
                    bound STRUCTURE DIMENSION 8;
                        lower LONGWORD;
                        upper LONGWORD;
                        multiplier LONGWORD;
                        constant_lower BITFIELD LENGTH 1;
                        constant_upper BITFIELD LENGTH 1;
                        constant_multiplier BITFIELD LENGTH 1;
                        reserved BITFIELD LENGTH 13;
                    END bound;
                END array_info;

                                         bound   In this declaration, the subaggregate bound has eight elements.   Each
                                     upper  lower  multiplier   element  consists  of the members upper, lower, multiplier, and so on.
          bound                                           upper    lower   Since  bound  is  an  array,  each  of  its  members  (upper,   lower,
   multiplier   multiplier,  and  so  on)  can  also  be  considered an array of eight
   elements.

   When you specify a single value on a  DIMENSION  keyword,  as  in  the
   example  above,  the  output routines assume that the value represents
   the high bound value and supply a default low bound value of one.  You
   can  override  this  default by specifying both a low bound and a high
   bound as follows:

        ITEM node_pointers DIMENSION 0:255 ADDRESS;

   This  declaration  results   in   the   declaration   of   the   array
   node_pointers   node_pointers, whose low bound is 0 and whose high bound is 255.  Only
   one dimension can  be  specified  for  an  aggregate  or  item.   This
   restriction  ensures  that there will be no interlanguage conflicts in
   an array declaration.

   See the translation summaries in Chapter 3 for the SDL translations of
   array dimensions for other target source languages.



   2.6  PREFIXES AND TAGS   2.6  PREFIXES AND TAGS

   When you specify the PREFIX option in  a  declaration,  SDL  generates
   names  in  the  target source language(s) by concatenating a prefix to
   the user-specified identifier.  When  you  specify  a  prefix  for  an
   aggregate,  SDL applies the prefix to all members of the aggregate and
   to named constants declared  in  it,  but  not  to  the  name  of  the
   aggregate itself.

   The prefix consists of a user-specified string, a tag letter,  and  an
   underscore.  For example:





                                    2-18
                                                                USING SDL                                                                USING SDL



        AGGREGATE operator STRUCTURE PREFIX opr$;
                id      WORD;
                "typename" CHARACTER;
                        CONSTANT (
                                fixed_bin_,
                                float_,
                                ) EQUALS 0 INCREMENT 1;
                bits    STRUCTURE;
                        variable_size   BITFIELD;
                        size_units      BITFIELD LENGTH 3;
                        END bits;
                END operator;

   Note that the typename identifier  is  enclosed  in  quotations  marks
   because it is an SDL keyword.

   This declaration produces the following identifiers:

        operator
        opr$w_id
        opr$t_typename
        opr$k_fixed_bin_
        opr$k_float_
        opr$_bits
        opr$v_variable_size
        opr$v_size_units
        opr$v_fill_0

   As the preceding example shows, SDL uses default  codes  for  the  tag
   portion  of  a name when the TAG option is not specified.  The default
   codes are the standard VAX codes, based on the data type of  the  name
   they  represent.   For  a  list  of  these  codes, see the Default Tag
   Letters Table in Chapter 3.  You can override  the  default  codes  by
   specifying a tag, which may be null.  For example:

        CONSTANT (abc,def,ghi) 
           EQUALS 0 INCREMENT 1 PREFIX new TAG "";

                                         new_abc  new_def      new_ghi   This declaration results in the names new_abc, new_def, and new_ghi.

   You can  specify  tags  for  constants,  items,  aggregate  names,  or
   aggregate  members.   The  tag that you specify, however, affects only
   the identifier you specify it with.  For example, a tag you supply  in
   an AGGREGATE declaration affects only the aggregate name, thus, if you
   wish to change all the tags in an aggregate,  you  must  do  it  on  a
   member-by-member basis.







                                    2-19












                                 CHAPTER 3                                 CHAPTER 3

                     SDL LANGUAGE AND COMMAND REFERENCE                     SDL LANGUAGE AND COMMAND REFERENCE




   3.1  LANGUAGE AND COMMAND REFERENCE   3.1  LANGUAGE AND COMMAND REFERENCE

   This section provides concise syntax rules for SDL, including:

        o  The SDL command

        o  Syntax rules

        o  SDL declarations

        o  Storage classes

        o  Dimensions

        o  Prefixes and tags

        o  Translation tables for target output languages





















                                    3-1
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


   3.1.1  The SDL Command   3.1.1  The SDL Command

   The SDL command invokes the SDL translator to produce source files for
   one or more target languages.


   Format   Format

        SDL     file-spec,...

        File Qualifiers                          Defaults        File Qualifiers                          Defaults

        /[NO]COMMENTS                            /NOCOMMENTS
        /[NO]COPYRIGHT                           /NOCOPYRIGHT
        /[NO]DUMP                                /NODUMP
        /[NO]GLOBAL_DEFINITION                   /NOGLOBAL_DEFINITION
        /[NO]HEADER                              /HEADER
        /LANGUAGE=(language[=file-spec],...)     No languages
        /[NO]LIST[=file-spec]                    /NOLIST (interactive)
                                                 /LIST (batch)
        /[NO]MODULE                              /MODULE
        /[NO]PARSE[=file-spec]                   /PARSE
        /[NO]VMS_DEVELOPMENT                     /NOVMS_DEVELOPMENT


   Prompts   Prompts

        File: file-spec,...


   Command Parameter   Command Parameter


   file-spec,...

        The input file(s) containing SDL declarations to  be  translated.
        A  file  specification  must  specify a file name; if it does not
        include a file type, SDL uses the default file type of SDL.   You
        can  specify  multiple  input  files,  separated  by commas.  SDL
        translates each source file  individually  and  creates  separate
        output files for each.

        No wild cards are allowed in the file specification.

   File Qualifiers

        File qualifiers may be specified following  the  SDL  command  or
        they may be used to qualify individual file specifications.

   /[NO]COMMENTS

        Controls whether comments are included when  language  output  is
        generated.   For  more compact target language representation, in

                                    3-2
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


        cases where the output in  many  languages  is  to  be  saved  in
        permanent  files, use /NOCOMMENTS in order to save permanent file
        space.  /NOCOMMENTS is the default.

   /[NO]COPYRIGHT

        Controls whether a standard DIGITAL copyright header is  produced
        with  the  translated  output.  When /COPYRIGHT is specified, the
        translator precedes the output with a 20-line comment  containing
        the  standard  DIGITAL copyright claim.  By default, no copyright
        header is produced.

   /[NO]DUMP

        Controls whether the intermediate representation  of  the  source
        file  is  printed  on  the terminal.  By default, no intermediate
        representation is printed.

   /[NO]GLOBAL_DEFINITION

        Controls whether an item or aggregate declared  with  the  GLOBAL
        attribute  generates  a declaration that indicates that the value
        of the global data item is  defined  in  this  module.   In  some
        languages,  this  qualifier  has  no  effect;  see the individual
        language translation summaries in Section 3.1.8 for details.

        By default, global definitions  are  not  generated;  the  GLOBAL
        attribute   designates   global   data  whose  value  is  defined
        elsewhere.

   /[NO]HEADER

        Controls whether a header containing the date and the source file
        name  is  included  at  the  beginning  of  the  output file.  By
        default, the header is included.

   /LANGUAGE=(language[=file-spec],...)

        One or  more  of  the  language  options  listed  in  Table  3-1,
        indicating  the  target  source  languages  for  which  SDL is to
        produce output for the associated input file.   By  default,  SDL
        writes its output source files into separate files in the current
        default directory.  It uses the file name of its input  file  and
        the default file type for each compiler to name the target source
        files.

        SDL takes the language  option  specified  on  the  command,  and
        builds  the language image name by concatenating the prefix 'SDL'
        to the option.  If /LANGUAGE=FORTRA was specified,  SDL  searches
        for  and  activates  the  shareable image SDLFORTRA.EXE.  You may
        abbreviate most language options, but  SDL  will  use  the  first
        image  it  finds  that  matches the generated file specification.
        For example, if you wish to invoke the BLISSF back end instead of

                                    3-3
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


        the BLISS back end, you must spell out /LANGUAGE=BLISSF.

        By default, SDL searches for the  language  shareable  images  in
        SYS$SHARE.  By defining a logical name for the language name, you
        can override this default.  If  a  logical  name,  SDLFORTRA,  is
        defined to be MYDISK:SDLFORT.EXE, then the command

               ___________________ _______             $ SDL/LANGUAGE=FORTRA foo.sdl

        will activate the image MYDISK:SDLFORT.EXE to generate the output
        source file.

        With  /LANGUAGE,  you  can  override  the  default  output   file
        specification  for  one  or  more  target  language output files.
        Specify a  language  option  followed  by  the  destination  file
        specification  for  the  output file for that language.  You must
        separate the language from  the  destination  file  specification
        with  an equal sign (=) and separate specifications for different
        languages with commas.

        Table 3-1 summarizes the language options and default file  types
        output for each target SDL language.

   /[NO]LIST

        Controls whether a listing file is produced.

        If the SDL command is executed from interactive mode, /NOLIST  is
        the  default.   If  the  SDL command is executed from batch mode,
        /LIST is the default.

        When /LIST is in effect, the translator gives a listing file  the
        same file name as the related source file and a file type of LIS.

   /[NO]MODULE

        Controls whether an Ada package or a Pascal MODULE  is  generated
        in  the  output  source.  The default is /MODULE.  Note that this
        qualifier has no effect on languages other than PASCAL and Ada.

   /[NO]PARSE=[file-spec]

        Controls whether SDL will read or write an SDL intermediate file.
        An SDL intermediate file contains already-parsed SDL source code.
        This file is  written  with  the  /PARSE  command.   The  default
        extension for the SDL intermediate file is .SDI.

        The intermediate file produced from the /PARSE command can  later
        be used as input to SDL rather than SDL source code.  This can be
        done using the /NOPARSE command.  When this command appears in an
        SDL  command  line,  the  input file-spec is assumed to be an SDL
        intermediate file.  Again, the default extension is .SDI for  the
        input file-spec.  See examples 4 and 5 below.

                                    3-4
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


   /[NO]VMS_DEVELOPMENT

        Controls whether a MACRO output file that uses special VMS macros
        is  produced.  When /VMS_DEVELOPMENT is specified, the VMS macros
        $EQU, $DEF, $DEFINI, and $DEFEND are  used  in  the  .MAR  output
        file.  /VMS_DEVELOPMENT also causes BLISS output files to contain
        KEYWORD macros for entry declarations.  /NOVMS_DEVELOPMENT is the
        default.


               Table 3-1: SDL Language Options and File Types               Table 3-1: SDL Language Options and File Types


     Language         Option             Target File Type     Language         Option             Target File Type

     VAX BLISS-32     /LANGUAGE=BLISS    .R32
                      /LANGUAGE=BLISSF   .R32(1)
     VAX C            /LANGUAGE=CC       .H
     VAX FORTRAN      /LANGUAGE=FORTRA   .FOR
     VAX MACRO        /LANGUAGE=MACRO    .MAR
     VAX PL/I         /LANGUAGE=PLI      .PLI
     VAX PASCAL       /LANGUAGE=PASCAL   .PAS
     VAX DATATRIEVE   /LANGUAGE=DTR      .DTR
     VAX Ada          /LANGUAGE=ADA      .ADA
     ELN Pascal       /LANGUAGE=EPASCA   .PAS

   ---------------
   1 The BLISSF back end generates BLISS FIELDSETS for SDL aggregates.


   Examples   Examples

          ___ _______________________________________________________   1.   $ SDL BLOCKNODE/LANGUAGE=(PLI=PLI$:[PL1.PSRC],CC=C$:[C.CSRC])

   The SDL translator translates the  declarations  in  BLOCKNODE.SDL  to
   PL/I and C, writes the PL/I output file to PLI$:[PL1.PSRC], and writes
   the C output file to C$:[C.CSRC].

          ___ ___________________________________   2.   $ SDL VTREE.SRC/LANGUAGE=(PLI=[PLI.PSRC])

   SDL translates the declarations and writes its PL/I output file to the
   directory [PLI.PSRC].

          __________________________ ___________   3.   $ SDL/LANGUAGE=(MACRO,BLISS) IODEF,SSDEF

   SDL  translates  the  declarations  in  IODEF.SDL  and  SSDEF.SDL  and
   produces IODEF.MAR and IODEF.R32 as well as SSDEF.MAR and SSDEF.R32.

          _______________ ____   4.   $ SDL/PARSE=INTER TEST

   SDL translates the  declarations  in  the  source  file  TEST.SDL  and
   outputs an SDL intermediate file called INTER.SDI.


                                    3-5
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


          ________________________ ______ _____   5.   $ SDL/NOPARSE/LANG=(MACRO, BLISS) INTER

   SDL translates the declarations that have already been parsed  by  the
   SDL parser in INTER.SDI and produces files INTER.MAR and INTER.R32.



   3.1.2  Syntax Rules   3.1.2  Syntax Rules

   SDL declarations consist of SDL keywords, user-specified  identifiers,
   and  expressions,  terminated  by a semicolon.  Spaces or tabs delimit
   these elements in a declaration.



   3.1.2.1  Names -   3.1.2.1  Names -

   Module, aggregate, subaggregate,  constant,  item,  and  member  names
   specify  source program identifiers.  These and SDL local symbol names
   are subject to the following rules:

        o  Valid characters are A through Z, a through z,  0  through  9,
           dollar sign ($), and underscore (_).

        o  Source program  identifiers  must  begin  with  an  alphabetic
           character, a dollar sign, or an underscore.

        o  SDL local symbols must begin with a number sign (#).

        o  The names of identifiers, including names  containing  invalid
           SDL characters, can be enclosed in quotation marks.

   SDL passes all identifiers through to the source file(s) in  the  same
   case in which they are defined.



   3.1.2.1.1  Expressions -

   SDL expressions consist  of  numeric  constants,  operators,  declared
   output   constants,  and  SDL  local  symbols.   By  default,  numeric
   constants are assumed to be expressed in decimal  notation.   You  can
   override  this  default  by  prefixing  a  constant  with  one  of the
   following:

        Prefix   Interpretation   Valid Characters        Prefix   Interpretation   Valid Characters

        %X       Hexadecimal      0 through 9, A through F
        %O       Octal            0 through 7
        %B       Binary           0 and 1
        %A       ASCII value      Any ASCII character



                                    3-6
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


   SDL treats decimal constants as signed longwords.

   The %A operator takes the ASCII value  of  any  ASCII  character  that
   follows it.

   You can also use a string of  up  to  four  characters  as  a  numeric
   constant  by enclosing the string in quotation marks (").  SDL inserts
   the ASCII value of each character into the byte field corresponding to
   that character's position in the string.



   3.1.2.1.2  Operators -

   SDL supports the following operators for use  with  numeric  constants
   and  integer  variables.  They are listed in order of precedence, with
   the operators of higher precedence listed first.

        Operator     Meaning        Operator     Meaning

        unary -      Arithmetic negation
        *            Arithmetic multiplication
        /            Arithmetic division
        +            Arithmetic addition
        -            Arithmetic subtraction
        @            Logical shift--x@y shifts the value of x to the
                     right y places; if y is negative, the value of x
                     is shifted y places to the left
        &            Logical AND
        !            Logical OR

   Use  parentheses  to  group  expressions  to  define  the   order   of
   evaluation.   Expressions  within the innermost set of parentheses are
   evaluated first.



   3.1.2.2  Output Comments -   3.1.2.2  Output Comments -

   Output comments begin with a slash (/*) and terminate at  the  end  of
   the current line.  They can appear in the following contexts:

        o  Outside module declarations

        o  At the end of  a  line  containing  a  declaration;  that  is,
           following the semicolon terminator

        o  On lines by themselves between member, CONSTANT, ENTRY,  ITEM,
           or AGGREGATE declarations

        o  Between declarations within an aggregate



                                    3-7
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


        o  Following individual constant names within  a  comma-delimited
           list of CONSTANT declarations



   3.1.2.3  Local Comments -   3.1.2.3  Local Comments -

   Comments local to the SDL source file begin with the character  {  and
   extend  to  the  end of the line.  They can appear anyplace within the
   source file (not  necessarily  within  a  module)  where  white  space
   (space,  tab,  or  carriage  return)  is allowed.  SDL does not output
   local comments to target language source files.



   3.1.3  Declarations   3.1.3  Declarations

   3.1.3.1  MODULE Declarations -   3.1.3.1  MODULE Declarations -

   A MODULE declaration produces a source module.

        MODULE module-name [IDENT ident-string];
         module-body;
         .
         .
         .
        END_MODULE [ module-name ];


   module-name

        Any valid SDL identifier you want to use to identify the module.

   ident-string

        Any valid SDL identifier, or a string of any characters  enclosed
        in  quotation  marks,  that  further  identifies  the  module  or
        supplies version information.

   module-body

        One or more of the following:

        o  Local symbol declarations

        o  CONSTANT declarations

        o  ITEM declarations

        o  AGGREGATE declarations




                                    3-8
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


        o  ENTRY declarations

        o  Comments

   END_MODULE [module-name]

        Marks the end of the MODULE  declaration.   The  module-name,  if
        specified,  must  match  the  name on the most recently specified
        MODULE declaration.

   An SDL source file  may  contain  multiple  MODULE  declarations,  but
   modules may not be nested.



   3.1.3.2  Local Symbol Declarations -   3.1.3.2  Local Symbol Declarations -

   Local symbol declarations create and assign values to symbols that are
   known only within an SDL source file and are not directly translatable
   to the target language source file.

        #local-name = expression;



   #local-name

        Any valid SDL identifier.  Local names must begin with  a  number
        sign (#).

   expression

        Any valid SDL expression resulting in a longword integer value.

   A local symbol name can be assigned a value anywhere within  a  source
   file.   A  local  symbol  does  not  need  to be declared before it is
   assigned a value; however, if it is  referenced  before  it  has  been
   assigned  a  value,  SDL outputs an error message and does not produce
   any output files.



   3.1.3.3  CONSTANT Declarations -   3.1.3.3  CONSTANT Declarations -

   CONSTANT declarations generate  declarations  of  one  or  more  named
   constants.

        CONSTANT constant-name EQUALS expression 

                         [ PREFIX prefix-string ] [ TAG tag-string ] 

                         [ COUNTER #local-name ] ;


                                    3-9
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


        CONSTANT (constant-name,...) EQUALS expression

                         [ INCREMENT expression ]

                         [ PREFIX prefix-string ] [ TAG tag-string ] 
                       
                         [ COUNTER #local-name ] ;

         CONSTANT (constant-name,...) EQUALS expression,

                         [ INCREMENT expression ]
         
                         [ PREFIX prefix-string ] [ TAG tag-string ]

                         [ COUNTER #local-name ]

                  (constant-name,...) EQUALS expression,
                   .
                   .
                   .
           ;


   constant-name

        The base identifier name to  be  translated  to  the  appropriate
        declaration  for  a  named  constant.   This can be any valid SDL
        identifier.

   expression

        The value to be assigned to the constant.  This can be any  valid
        SDL expression.

   PREFIX prefix-string

        The prefix to use in forming the name.  It may be any  valid  SDL
        name,  may  or may not be enclosed in quotation marks, and may be
        null.  (See Section 3.1.7, "Prefixes and Tags.")

   TAG tag-string

        The tag to use in forming the identifier from the base name.   It
        follows  the  prefix  if  there is one.  It can have zero to four
        alphabetic characters and may or may not be enclosed in quotation
        marks.  (See Section 3.1.7, "Prefixes and Tags.")

   COUNTER #local-name

        The local symbol that is to be assigned to the last  value  which
        is assigned to a constant in the list.



                                    3-10
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


   (constant-name,...)

        A list of valid names.

        When more than one name is specified, the names must be separated
        by commas and the list enclosed in parentheses.

        A constant-name in this list  can  be  null.   The  corresponding
        value is reserved.

        If INCREMENT is not specified, all names are assigned  the  value
        specified in the EQUALS expression.

   INCREMENT expression

        The value to be added to an  expression  for  each  iteration  of
        SDL's  generation  of  named constant declarations.  It must be a
        valid SDL integer expression.   SDL  assigns  the  value  of  the
        expression  to  the  first  name  in  the  list,  increments  the
        expression by the increment value, and assigns that value to  the
        next name in the list.



   3.1.3.4  AGGREGATE Declarations -   3.1.3.4  AGGREGATE Declarations -

   AGGREGATE declarations produce declarations of structures and unions.

        AGGREGATE aggregate-name {STRUCTURE} [ COMMON             ]
                                 {UNION    } [ GLOBAL             ]
                                 {data-type} [ BASED pointer-name  ]

                                 [ DIMENSION [lbound:]hbound ] 

                                 [ MARKER marker-string ]

                                 [ PREFIX#prefix-string ]

                                 [ TAG tag-string ]

                                 [ ORIGIN member-name ] 

                                 [ FILL ] ;
        aggregate-body
           .
           .
           .
        END [ aggregate-name ];






                                    3-11
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


   aggregate-name

        Any valid SDL identifier giving the base name to be used  in  the
        declaration of the aggregate.

   STRUCTURE
   UNION
   data-type

        The type of aggregate.  (See  Section  3.1.3.6,  "Implicit  Union
        Declarations.")

   COMMON
   GLOBAL
   BASED pointer-name

        The storage class of the aggregate, if other  than  the  default.
        (See  Section  3.1.5,  "Storage Classes.") If an aggregate is the
        object of an ADDRESS declaration, it must have either the default
        or the BASED pointer-name storage class.

   DIMENSION [lbound:]hbound

        The high and low bound values of  the  aggregate  array,  if  the
        aggregate is to be an array.  (See Section 3.1.6, "Dimensions.")

   MARKER marker-string

        The preliminary marker to use in forming the name.  It may be any
        valid  SDL  name,  may or may not be enclosed in quotation marks,
        and may  be  null.   It  precedes  the  prefix  and  tag  in  the
        SDL-generated name.

   PREFIX prefix-string

        The prefix to use in forming the names of aggregate members.   It
        may  be  any  valid  SDL  name,  may  or  may  not be enclosed in
        quotation marks, and may be null.  (See Section 3.1.7,  "Prefixes
        and Tags.")

   TAG tag-string

        The tag to use in forming the identifier from the base name.   It
        follows  the  prefix  if  there is one.  It can have zero to four
        alphabetic characters and may or may not be enclosed in quotation
        marks.  (See Section 3.1.7, "Prefixes and Tags.")

   ORIGIN member-name

        The identifier of a member of this aggregate that is to  be  used
        as the origin of the aggregate.



                                    3-12
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


   FILL

        Indicates that the associated aggregate occurs only as fill;  for
        example,  the  named  aggregate is intended to force alignment on
        the following  aggregate.   For  some  languages,  the  aggregate
        declaration will not appear in the output file.

   aggregate-body

        One or more of the following:

        o  Member declarations, giving the names and data  types  of  all
           level-1 members of the aggregate

        o  Subaggregate declarations

        o  Local symbol assignments

        o  CONSTANT declarations

   END [ aggregate-name ]

        Marks the end of the aggregate or subaggregate declaration.   The
        aggregate-name,  if  specified,  must  match the name on the most
        recently specified aggregate or subaggregate declaration.



   3.1.3.4.1  STRUCTURE Declarations -

   STRUCTURE declarations produce aggregate or subaggregate  declarations
   that are structures; that is, whose members occupy consecutive storage
   locations and are not overlaid.

   Aggregate declaration:

        AGGREGATE aggregate-name STRUCTURE [other-options] ;

   Subaggregate declaration:

        member-name STRUCTURE [other-options] ;

   The COMMON, GLOBAL, BASED pointer-name, and ORIGIN options are invalid
   for a subaggregate.  All other AGGREGATE options are valid.



   3.1.3.4.2  UNION Declarations -

   UNION declarations produce aggregate or subaggregate declarations that
   are unions; that is, whose first-level members occupy the same storage
   locations.


                                    3-13
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


   Aggregate declaration:

        AGGREGATE aggregate-name UNION [other-options] ;

   Subaggregate declaration:

        member-name UNION [other-options]

   The COMMON, GLOBAL, BASED pointer-name, and ORIGIN options are invalid
   for  a  subaggregate.   All  other  AGGREGATE  options  are valid.  An
   alternative way of specifying a union is to use a "data-type" in place
   of the UNION keyword.  In this case, the declared aggregate is a union
   consisting of the given aggregate members in the form  of  an  unnamed
   structure,  in  parallel  with one member whose name and data type are
   those given in the aggregate declaration.



   3.1.3.5  Member Declarations -   3.1.3.5  Member Declarations -

   Member  declarations  produce  declarations  of  the  members  of   an
   aggregate.

        member-name { data-type #####} [ DIMENSION [lbound:]hbound ] }
                    { aggregate-name }
                                       [ PREFIX prefix-string ] 

                                       [ TAG tag-string ] 

                                       [ FILL ] ;


   member-name

        Any valid SDL identifier giving the name of the member.

   data-type

        The data type of the member.  It must be specified using  an  SDL
        data-type keyword.  (See Section 3.1.4, "Data Types.")

   aggregate-name

        The name of the previously declared structure to  be  used  as  a
        type  name.   The  name must be the full (SDL-expanded) aggregate
        name, including prefix and tag.

   DIMENSION [lbound:]hbound

        The number of elements in the member array, if the member  is  to
        be an array.  (See Section 3.1.6, "Dimensions.")



                                    3-14
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


   PREFIX prefix-string

        The prefix to use in forming the name.   For  subaggregates,  the
        prefix is used to form the names of subaggregate members.  It may
        be any valid SDL name, may or may not be  enclosed  in  quotation
        marks,  and  may  be  null.   (See  Section  3.1.7, "Prefixes and
        Tags.")

   TAG tag-string

        The tag to use in forming the identifier from the base name.   It
        follows  the  prefix  if  there is one.  It can have zero to four
        alphabetic characters and may or may not be enclosed in quotation
        marks.  (See Section 3.1.7, "Prefixes and Tags.")

   FILL

        Indicates that the associated member occurs  only  as  fill;  for
        example,  the  named member is intended to force alignment on the
        following member.  For some  languages,  the  member  declaration
        will not appear in the output file.



   3.1.3.6  Implicit Union Declarations -   3.1.3.6  Implicit Union Declarations -

   SDL allows data types on the structure declaration.  This  causes  the
   structure  declaration  to become an implicit union declaration.  This
   implicit union feature gives the maintainer of complicated  structures
   certain benefits.

        1.  SDL has the ability to detect subfield overflow  without  the
            need to define extraneous structure and union names.

        2.  User defined fill fields are not necessary.  This feature  is
            of most use for data structures containing substructures that
            are required to begin at fixed offsets.

   The following SDL  source  shows  the  syntax  of  an  implicit  union
   (structure B defines the implicit union).

            AGGREGATE A STRUCTURE;
                B STRUCTURE LONGWORD;
                    bit_string1 BITFIELD LENGTH 1;
                    bit_string2 BITFIELD LENGTH 4;
               END B;
            last_item WORD;
            END A;

   The above implicit union is a way of representing the more  cumbersome
   SDL structure

            AGGREGATE A STRUCTURE;

                                    3-15
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


                X UNION ;
                B LONGWORD;
                    Y STRUCTURE ;
                    bit_string1 BITFIELD LENGTH 1;
                    bit_string2 BITFIELD LENGTH 4;
                    END Y;
                last_item WORD;
                END X;
            END A;

   (where the names X and Y become SDL generated "filler"  names  in  the
   implicit union case).

   The user does not have to define the union X and the  structure  Y  if
   implicit  union  is  used.  By giving the structure Y a type, SDL will
   create a union of field Y with the specified  type  overlayed  with  a
   structure  containing  the fields in Y.  In some language translations
   such as BLISS and Macro, the SDL generated union and structure (X  and
   Y  above)  can  be  surpressed in the output since they are considered
   extraneous fields.  In other languages  such  as  pli  and  C,  it  is
   necessary  to  use  them  to  generate  the  correct  offsets within a
   structure.  Since  the  union  is  of  the  length  specified  in  the
   structure  type,  no  filler  is  necessary  to ensure that subsequent
   fields (last_item above) are at the correct offset.  If the fields  of
   a  structure  extend  past  the  size  specified,  SDL  will  flag the
   overflow.  What follows is the PL/I translation for the above implicit
   union example.


   ** PL/I translation **   ** PL/I translation **

        DCL 1 A  BASED ,
             2 fill_0 union,
              3 B fixed binary(31),
              3 fill_1 ,
               4 bit_string1 bit(1),
               4 bit_string2 bit(4),
               4 fill_1$$v_fill_2 bit(3),
             2 last_item fixed binary(15);

   See the specific language examples in Chapter 4 for an example  of  an
   implicit union for other languages.



   3.1.3.6.1  DIMENSION with Implicit Union -

   What follows is an example of an SDL structure defined with  type  and
   dimension.

            AGGREGATE fid STRUCTURE WORD DIMENSION 3;
                first WORD;
                second WORD;

                                    3-16
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


                third WORD;
            END fid;

   In this example, a  single  structure  is  overlaid  by  an  array  of
   elements of the type specified by the structure type.

   The fid structure is a three word field which can be  addressed  as  a
   single field or by each individual word so it is easily defined in SDL
   as represented above.  What follows is the PL/I  translation  for  the
   SDL source in the above example to illustrate the SDL interpretation.

        DCL 1 fill_0 union BASED ,
             2 fid (1:3) fixed binary(15),
             2 fill_1 ,
              3 first fixed binary(15),
              3 second fixed binary(15);
              3 third fixed binary(15);

   The implicit union feature allows structures to grow without the  need
   to  modify  any  trailing  fillers.  SDL detects any overflow that may
   occur if the structure grows past the size of its datatype.  The  size
   of  the  aggregate (in bytes) is equal to the size of the datatype (in
   bytes) multiplied by the upper dimension (if any).  If the size of the
   aggregate  is greater than the sum of the size of all its members, SDL
   will not complain.  However, if the size of the  members  exceeds  the
   size of the aggregate, then SDL will issue a message of the form

        %SDL-E-TOOMANYFIELDS, Structure fill_0 has too many fields [Line ?]

   (where fill_0 is the SDL generated name for the top union aggregate).



   3.1.3.7  ITEM Declarations -   3.1.3.7  ITEM Declarations -

   ITEM declarations translate declarations of scalar items.

        ITEM name data-type   [ COMMON ]
                              [ GLOBAL ]

                              [ DIMENSION [lbound:]hbound ] 

                              [ PREFIX prefix-string ] [ TAG tag-string ] ;


   name

        The name to be declared as a scalar item  in  the  output  source
        language(s).

        The name can be any valid SDL identifier.



                                    3-17
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


   data-type

        The data type of the member.  It must be specified using  an  SDL
        data type keyword.  (See Section 3.1.4, "Data Types.")

   COMMON
   GLOBAL

        The storage class of the item, if other than the default  storage
        class, based.  (See Section 3.1.5, "Storage Classes.")

   DIMENSION [lbound:]hbound

        The number of elements in the array, if the  item  is  to  be  an
        array.  (See Section 3.1.6, "Dimensions.")

   PREFIX prefix-string

        The prefix to use in forming the name.  It may be any  valid  SDL
        name,  may  or may not be enclosed in quotation marks, and may be
        null.  (See Section 3.1.7, "Prefixes and Tags.")

   TAG tag-string

        The code to use following the prefix in forming the identifier of
        the name.  It can have zero to four alphabetic characters and may
        or may not be enclosed in quotation marks.  (See  Section  3.1.7,
        "Prefixes and Tags.")



   3.1.3.8  ENTRY Declarations -   3.1.3.8  ENTRY Declarations -

   ENTRY declarations  produce  the  declaration  of  an  external  entry
   constant.

        ENTRY entry-name [ PARAMETER (param-desc,...) ] 

                         [ RETURNS data-type ] 

                         [ VARIABLE ] 
         
                         [ ALIAS internal-name ] 

                         [ LINKAGE link-name ] ;
         
                         [ TYPENAME type-name ] ;


   entry-name

        Any valid SDL identifier giving the name of  the  external  entry
        point.

                                    3-18
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


   PARAMETER (param-desc,...)

        Descriptions of the parameters of the  external  entry,  if  any.
        Param-desc must be specified as follows:

             { data-type [ DESCRIPTOR ] } [ IN ] [ OUT ] 
             {           [ VALUE      ] }
             {           [ REF        ] } [ NAMED param-name ]
             {                          } 
             { ANY [ VALUE ]            } [ DIMENSION expr ]  
             {     [ REF   ]            }
             {                          } [ DEFAULT constant-value ]

             {                          } [ TYPENAME type-name ]

             { structure-name           } 
                                          [ OPTIONAL ]


        data-type

             Any valid SDL data type keyword that specifies the data type
             of the parameter.

        DESCRIPTOR

             Indicates that a parameter is passed by descriptor.

        ANY

             Indicates that the parameter can have any data  type.   Note
             that  if you specify ANY, you cannot specify other data type
             keywords.

        VALUE

             Indicates that the parameter is passed by immediate value.

        REFERENCE

             Indicates that the parameter is passed by reference.

        structure-name

             The name of an SDL  structure  that  describes  a  structure
             parameter.   The  declaration  of the structure must precede
             its reference in the PARAMETER option.

        IN

             Indicates an input parameter.



                                    3-19
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


        OUT

             Indicates an output parameter.

        NAMED param-name

             Specifies the parameter name.

        DIMENSION expr

             The number of elements of an array parameter.

             If expr is an asterisk (*), the number of dimensions depends
             on the dimensions of the actual parameter.

        DEFAULT constant-value

             Specifies a default value for  a  parameter.   In  languages
             supporting   this   feature,  this  option  allows  optional
             appearance of an actual parameter.

        OPTIONAL

             Specifies that the parameter may or may not  appear  in  the
             sequence  of (keyword) parameters for a call using the entry
             point name.  This is supported  only  in  BLISS  and  BLISSF
             output.

        TYPENAME type_name

             Supplies a named datatype that is not an SDL keyword.

             The IN,  OUT,  NAMED,  DIMENSION,  or  DEFAULT  options,  if
             specified, must follow the data-type, ANY, or structure-name
             in the declaration.

   RETURNS data-type

        The data type  returned  by  the  external  entry,  if  it  is  a
        function.

   VARIABLE

        Indicates that not all parameters are  described;  that  is,  the
        entry  point has a variable number of parameters and that not all
        corresponding arguments need be present in the argument list when
        the entry point is invoked.

   ALIAS internal-name

        Indicates  an  alternate  internal  name  that  can  be  used  to
        designate the entry point.


                                    3-20
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


   LINKAGE link-name

        Indicates (in MACRO only) that  a  special  call  macro  (spelled
        "link-name") will be used in the expansion of the entry macro.

   TYPENAME type-name

        Supplies a named datatype that is not an SDL keyword.



   3.1.4  Data Types   3.1.4  Data Types

   The data type of an item or aggregate member is specified  by  one  of
   the   keywords  from  the  following  list.   Keywords  that  are  not
   self-explanatory or that require further attributes are followed by  a
   brief description.

        BYTE [ UNSIGNED ]
        WORD [ UNSIGNED ]
        LONGWORD [ UNSIGNED ]
        QUADWORD [ UNSIGNED ]
        OCTAWORD [ UNSIGNED ]

        F_FLOATING
        D_FLOATING
        G_FLOATING
        H_FLOATING


   DECIMAL PRECISION (precision,scale)   DECIMAL PRECISION (precision,scale)


   PRECISION (precision,scale)

        The   fixed-point   decimal   member's   precision   and   scale,
        respectively,  where  precision  is  the  total number of decimal
        digits and scale is the number of fractional digits.

        Both precision and  scale  must  be  specified  using  valid  SDL
        expressions.


   BITFIELD [ LENGTH length ] [ MASK ] [ SIGNED ]   BITFIELD [ LENGTH length ] [ MASK ] [ SIGNED ]


   LENGTH length

        Any valid SDL expression giving the number of  bits  in  the  bit
        field.  If no length is specified, SDL uses the default length of
        1 bit.



                                    3-21
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


   MASK

        SDL  keyword  requesting  SDL  to  generate   a   constant   mask
        representing the bits defined in this field.

   SIGNED

        SDL keyword requesting SDL to treat the output as a signed field.

   Bit fields must be aggregate members.  They cannot  be  scalar  items,
   objects  of  ADDRESS  declarations,  parameters,  or  return-types  of
   entries.


   BOOLEAN   BOOLEAN


   CHARACTER [LENGTH length] [VARYING];   CHARACTER [LENGTH length] [VARYING];


   LENGTH length

        The length of the character string.  The length can be  specified
        using  any  valid SDL expression.  If no length is specified, SDL
        uses the default length of 1 character.

   VARYING

        SDL keyword indicating that the name represents a  varying-length
        character string (for languages that support this data type).  In
        a varying-length character string, the first word of  the  string
        contains  its  current length; its declared length is the maximum
        length that it can have.


   ADDRESS [ (object-type) ]   ADDRESS [ (object-type) ]


   object-type

        The data  type  of  the  object  to  which  the  address  refers.
        Object-type must be specified as follows:

             { data-type                                   }
             {                                             }
             { ENTRY [ PARAMETER (param-desc,...) ]        }
             {     [ RETURNS data-type ]                   }
             {                                             }
             { structure-name                              }





                                    3-22
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


   data-type

        Any valid SDL data type keyword other than BITFIELD; for example,
        WORD, ADDRESS, CHARACTER, LONGWORD.

   ENTRY

        Indicates an entry point address.  If ENTRY is specified, you can
        also  specify  parameter  descriptions  and a return data type as
        described for ENTRY declarations.

   structure-name

        The name of a previously-defined SDL aggregate, which  must  have
        either  no  storage  class  attribute  or  the BASED pointer-name
        storage class.



   3.1.5  Storage Classes   3.1.5  Storage Classes

   The  default  storage  class  associated  with  any   declaration   is
   language-dependent.   In  general,  declarations  produce  a  template
   describing data for which the compiler does not  allocate  storage  at
   compile  time.  This type of storage is called "based".  Based storage
   is used if neither COMMON nor GLOBAL is specified.

   BASED pointer-name generates an aggregate declaration identical  (with
   the  exception  of  PL/I) to the declaration generated when no storage
   class is specified.  For PL/I, SDL generates the following attribute:

        BASED (pointer-name)

   COMMON generates  the  appropriate  declaration  for  shared  storage,
   usually by means of an external program section with the OVR attribute
   for an aggregate or item.

   GLOBAL generates a reference to a global symbol that has been  defined
   elsewhere.   SDL  does  not  generate  definitions  for global symbols
   directly.   However,  the  MACRO-32  output  routine   generates   all
   declarations  within macros so that they can be invoked with arguments
   that will  produce  global  definitions.   The  "MACRO-32  Translation
   Summary"  in  Section  3.1.8  describes  how  to  invoke  these  macro
   definitions to generate global symbol definitions.

   For some languages,  the  /GLOBALDEF  qualifier  to  the  SDL  command
   affects the operation of the GLOBAL attribute.  When this qualifier is
   used, GLOBAL generates a reference  to  global  data  whose  value  is
   defined  in this module.  See the individual translation summaries for
   the exact effect of /GLOBALDEF in each language.




                                    3-23
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


   A subaggregate always acquires the storage class of the  aggregate  to
   which it belongs.



   3.1.6  Dimensions   3.1.6  Dimensions

   A dimension can be applied to an aggregate, subaggregate, or item.

        DIMENSION [lbound:]hbound


   lbound

        If specified, any valid SDL expression giving the  value  of  the
        lowest-numbered   element   of  the  array.   If  lbound  is  not
        specified, SDL supplies a default lbound of one.

   hbound

        Any valid SDL expression giving the number  of  elements  in  the
        array, or, if lbound is specified, the highest-numbered element.



   3.1.7  Prefixes and Tags   3.1.7  Prefixes and Tags

   By default, SDL generates identifiers  for  declarations  using  names
   exactly  as you enter them in the SDL source file, including uppercase
   and lowercase.  You can use the PREFIX and TAG options  on  AGGREGATE,
   subaggregate, CONSTANT, and ITEM declarations to cause SDL to generate
   prefixes for data items or aggregate members.



   3.1.7.1  Prefixes -   3.1.7.1  Prefixes -

   The PREFIX option  specifies  a  character-string  prefix  to  use  in
   forming identifiers for all items and aggregate members.

        PREFIX prefix-string


   prefix-string

        A 1- to 32-character string giving the prefix to  be  applied  to
        all member names.  It can be any valid SDL identifier.

        If you specify the PREFIX option, SDL forms the output identifier
        of   each  member  using  the  prefix,  followed  by  a  tag,  an
        underscore, and the member name.



                                    3-24
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


        When  the  PREFIX  option  is  specified  for  an  aggregate   or
        subaggregate,  the  specified  prefix is used only in forming the
        names of the aggregate or subaggregate's  members,  and  not  the
        name of the aggregate or subaggregate itself.

        An existing prefix can be overridden by declaring  a  new  prefix
        for  a particular aggregate member.  If this member happens to be
        a subaggregate, the new prefix will be  applied  to  all  of  the
        members  of  that  subaggregate.   Otherwise,  if  no  prefix  is
        specified for a subaggregate, all subaggregate  members  get  the
        same prefix as that specified on the containing aggregate.



   3.1.7.2  Tags -   3.1.7.2  Tags -

   The TAG option overrides the default tags that SDL uses when it  forms
   identifiers.   You  must  use  the  TAG  option for each item, member,
   aggregate, or subaggregate name for which you want to override.

        TAG tag-string


   tag-string

        A 0- to 31-character code specifying the tag to  use  in  forming
        the name.  If the TAG option is not specified, SDL uses a default
        code based on the data type of the name.

        When you specify the TAG  option,  SDL  appends  the  tag-string,
        which may be null, and an underscore character (_) to the current
        prefix-string.  A tag option of  a  single  underscore  character
        produces a single underscore character in any resulting names.

        When the PREFIX  option  is  specified,  and  no  TAG  option  is
        specified  for  an  aggregate  member,  SDL  uses the default tag
        letters shown in table 3-2.

















                                    3-25
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


                 Table 3-2: Default Tag Letters Used by SDL                 Table 3-2: Default Tag Letters Used by SDL


     Data Type               Default     Data Type               Default
     Declaration             Tag Letter     Declaration             Tag Letter

     CONSTANT                K
                             
     BYTE [UNSIGNED]         B
     WORD [UNSIGNED]         W
     LONGWORD [UNSIGNED]     L
     QUADWORD                Q
     OCTAWORD                O
     F_FLOATING              F
     D_FLOATING              D
     G_FLOATING              G
     H_FLOATING              H
     DECIMAL                 P
     BITFIELD                V for BITFIELD offset
                             S for BITFIELD size
                             M for BITFIELD mask(1)
     CHARACTER               T
     ADDRESS                 A
     STRUCTURE               R
     UNION                   R

   ---------------
   1 Names with size and (if MASK is specified) mask tags  are  generated
     regardless of whether a PREFIX or TAG option is specified.

























                                    3-26
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


   3.1.8  Translation Summaries   3.1.8  Translation Summaries

   This  section  summarizes  how  SDL  output  routines  translate   SDL
   constructs into the following languages:

        o  VAX BLISS

        o  VAX C

        o  VAX FORTRAN

        o  VAX MACRO-32

        o  VAX PL/I

        o  VAX PASCAL

        o  VAX DATATRIEVE

        o  ELN PASCAL

        o  VAX Ada
































                                    3-27
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


   3.1.8.1  BLISS-32 Translation Summary -   3.1.8.1  BLISS-32 Translation Summary -

        SDL Declaration          BLISS-32 Output
                                 
        MODULE name              !*** MODULE name ***
        IDENT string             ! string

        /* comment               ! comment

        CONSTANT x EQUALS n;     LITERAL x = n;

        ENTRY name               EXTERNAL ROUTINE name
           PARAMETER (type,...)  EXTERNAL ROUTINE name: NOVALUE ;
             ANY                 n/a
             DESCRIPTOR          n/a
             IN                  n/a
             OUT                 n/a
             NAMED param-name    n/a
             VALUE               n/a
             REF                 n/a
             DEFAULT const-val   Used in KEYWORDMACRO under VMS_DEV
                                 option, gives "= const-val"
             TYPENAME type-name  n/a
             OPTIONAL            Used in KEYWORDMACRO output, gives 
                                 %IF NOT %NULL({name\{) %THEN, {name\{ %FI
             RETURNS data-type 
             VARIABLE            n/a
             ALIAS internal-name Used in KEYWORDMACRO under VMS_DEV
                                 option, gives name for BLISS macro
             LINKAGE             n/a
             TYPENAME type-name  n/a

        STRUCTURE                Each aggregate or member declaration  in
                                 SDL produces a BLISS-32 macro declaration 
        UNION                    of the form:

                                        MACRO name = off,pos,size,ext %;
        BYTE 
                                 off        WORD                     off
        LONGWORD                 Byte offset of this  aggregate  or 
        QUADWORD                 item within the current aggregate.
        OCTAWORD
                                 pos        BYTE UNSIGNED            pos
        WORD UNSIGNED            The bit position from the offset.
        LONGWORD UNSIGNED 
                                 size        QUADWORD UNSIGNED        size
        OCTAWORD UNSIGNED        The size of the aggregate or  item,
        F_FLOATING               in  bits, if the size is 4 bytes or
        D_FLOATING               less.    Otherwise,   this    field
        G_FLOATING               contains  0,  and SDL generates the
        H_FLOATING               size declaration:
        DECIMAL PRECISION (p,q) 


                                    3-28
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


        BITFIELD LENGTH n                  prefix$_name = size;
           MASK      
           SIGNED
        BOOLEAN                  where the size is given in bytes.
        CHARACTER LENGTH N 
                                 ext           VARYING               ext
        ADDRESS                  Contains 0 if  the  value  is  zero
                                 extended, or 1 if the value is sign
                                 extended or SIGNED bit.
                                 In the case of BLISSF output, each 
                                 aggregate and associated member 
                                 declaration in SDL produces a BLISS
                                 field declaration.  The fieldset name
                                 is generated by SDL in the form of 
                                 prefix$name_FIELDSET, where prefix is 
                                 declared for the entire aggregate and 
                                 name is the aggregate name.
              
                                          FIELD prefix$name_FIELDSET =
                                            SET
                                            member-name = [off,pos,size,ext];
                                              .
                                              . 
                                              .
                                            TES;
                                          MACRO prefix$_name = size{%;
                                          MACRO prefix$_name BLOCK 
                                          [pref$_name,BYTE]
                                                        FIELD 
                                          (prefix$name_FIELDSET){%;
        Default storage class    n/a

        COMMON storage class     n/a

        GLOBAL storage class     EXTERNAL
           with /GLOBALDEF       GLOBAL
                                  
        BASED pointer-name       n/a

        DIMENSION [lbound:]hbound


   Notes:   Notes:

        1.  The BLISS-32 output routine does not assign data  to  storage
            classes.








                                    3-29
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


   3.1.8.2  C Translation Summary -   3.1.8.2  C Translation Summary -

            SDL
        Declaration               C Output 
                                  
        MODULE name               /*** MODULE name ***/
           IDENT string           /* string */


        /* comment                /* comment */

        CONSTANT x EQUALS n       #define x n

        ENTRY name                return-type name()
               PARAMETER (type,...)
                 ANY              n/a
                 DESCRIPTOR       n/a
                 IN               n/a
                 OUT              n/a
                 NAMED param-name n/a
                 VALUE            n/a
                 REF              n/a
                 DEFAULT          n/a
                 OPTIONAL         n/a
               TYPENAME type-name n/a
               RETURNS return-type
               VARIABLE           n/a
               ALIAS              n/a
               LINKAGE            n/a
               TYPENAME type-name n/a

        STRUCTURE                 struct
          
        UNION                     union

        name BYTE                 char name
        name WORD                 short int name
        name LONGWORD             int name
        name QUADWORD             int name [2]
        name OCTAWORD             int name [4]
        name BYTE UNSIGNED        unsigned char
        name WORD UNSIGNED        unsigned short int
        name LONGWORD UNSIGNED    unsigned int
        name QUADWORD UNSIGNED    unsigned int name [2]
        name OCTAWORD UNSIGNED    unsigned int name [4]
        name F_FLOATING           float name
        name D_FLOATING           double name
        name G_FLOATING           int name [2]
        name H_FLOATING           int name [4]
        name DECIMAL precision    char name [p/2+1]
            (p,q)
        name BITFIELD LENGTH n    unsigned name:n 
            MASK

                                    3-30
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


            SIGNED                n/a
        name BOOLEAN              char name
        name CHARACTER LENGTH n   char name[n]
                                      VARYING struct{short STRING_LENGTH;
                                      char STRING_TEXT[n];} name

        name ADDRESS              object-type *name
        (object-type) 

        Default storage class     struct or union with <member-name>
                                  as the tag, and no declared variable
        names.

        COMMON storage class      extern attribute

        GLOBAL storage class      globalref attribute
          with /GLOBALDEF         globaldef attribute

        BASED pointer-name        a pointer will be generated
                                  for the based item.

        DIMENSION [lbound:]hbound the declaration specifies an array of
                                  the number of elements specified with
                                  subscripts ranging from 0 to (hbound -
                                  lbound + 1).

        ORIGIN member-name        n/a



























                                    3-31
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


   3.1.8.3  FORTRAN Translation Summary -   3.1.8.3  FORTRAN Translation Summary -

           SDL
        Declaration               FORTRAN Output
                      
        MODULE name               !*** MODULE name ***
           IDENT string           !    string

        /* comment                ! comment 

        CONSTANT x EQUALS n       PARAMETER x = n

        ENTRY name                EXTERNAL name
           PARAMETER (type,...)
             ANY                  n/a
             DESCRIPTOR           n/a
             IN                   n/a
             OUT                  n/a
             NAMED param-name     n/a
             VALUE                n/a
             REF                  n/a
             DEFAULT              n/a
             OPTIONAL             n/a
           TYPENAME type-name     n/a
           TURNS return-type      type name
           VARIABLE               n/a
           ALIAS                  n/a
           LINKAGE                n/a
           TYPENAME type-name     n/a

        STRUCTURE                 If this is a top level AGGREGATE
                                  declaration then a FORTRAN STRUCTURE
                                  declaration is generated.  If this is
                                  a subaggregate declaration, no
                                  structure is generated.

        UNION                     UNION and associated MAP declarations

        name BYTE                 BYTE name
        name WORD                 INTEGER*2 name
        name LONGWORD             INTEGER*4 name
        name QUADWORD             INTEGER*4 name(2)
        name OCTAWORD             INTEGER*4 name(4)
        name BYTE UNSIGNED        BYTE name
        name WORD UNSIGNED        INTEGER*2 name
        name LONGWORD UNSIGNED    INTEGER*4 name
        name QUADWORD UNSIGNED    INTEGER*4 name(2)
        name OCTAWORD UNSIGNED    INTEGER*4 name(4)
        name F_FLOATING           REAL*4 name
        name D_FLOATING           REAL*8 name
        name G_FLOATING           REAL*8 name
        name H_FLOATING           REAL*16 name
        DECIMAL PRECISION (p,q)   Undefined data type, error INVOUT

                                    3-32
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


        BITFIELD LENGTH n         Offset and size declarations
                                  with "V_" and "S_" tags
            MASK                  Mask declaration, with "M" tag
            SIGNED                n/a

        name BOOLEAN              BYTE name

        name CHARACTER LENGTH n   CHARACTER*n name
           VARYING                STRUCTURE/name/name
                                        INTEGER*2    LEN
                                        CHARACTER*length TXT
                                  END STRUCTURE

        name ADDRESS              INTEGER*4 name

        Default storage class     Local, static 

        COMMON storage class      COMMON /name/ name

        GLOBAL storage class       n/a
           with /GLOBALDEF         n/a

        BASED pointer-name         n/a

        DIMENSION [lbound:]hbound  name(hbound - lbound)

        ORIGIN member-name         n/a


   Notes:   Notes:

   Since Fortran does not have a comparable data type for  BITFIELD,  the
   Fortran backend translates bitfields into PARAMETERS having a value of
   the associated structure offset.   BYTE  fillers  (using  the  Fortran
   %FILL feature) are placed in the structures for alignment.



















                                    3-33
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


   3.1.8.4  MACRO-32 -   3.1.8.4  MACRO-32 -

            SDL
        Declaration                MACRO-32 Output

        MODULE name                  .MACRO name
           IDENT string              ; string

        /* comment                   ;comment

        CONSTANT x EQUALS n;         x = n

        ENTRY                        .EXTERNAL member-name

           PARAMETER (type,...)      n/a
              ANY                    n/a
              DESCRIPTOR             n/a
              IN                     n/a
              OUT                    n/a
              NAMED param-name       n/a
              VALUE                  n/a
              REF                    n/a
              DEFAULT constant-value = constant-value
              OPTIONAL               n/a
              TYPENAME type-name     n/a
              RETURNS data-type      n/a
           VARIABLE                  n/a
           ALIAS                     Macro name (default is entry name)
           LINKAGE                   Call instruction (default is CALLS)
           TYPENAME type-name        n/a

        STRUCTURE                    Each identifier produces a constant
                                     assignment equal to the byte offset
        UNION                        of the item, as follows:

        name BYTE                           name = offset-value
        name WORD 
        name LONGWORD                where offset-value is the byte 
        name QUADWORD                offset relative to the origin of the
        name OCTAWORD                level-1 aggregate.  A constant 
        name BYTE UNSIGNED           assignment of the form:
        name WORD UNSIGNED 
        name LONGWORD UNSIGNED              prefix$_name = byte-size
        name QUADWORD UNSIGNED 
        name OCTAWORD UNSIGNED       gives the size in bytes for
        name F_FLOATING              aggregates, arrays, and character
        name D_FLOATING              strings.
        name G_FLOATING 
        name H_FLOATING 
        name DECIMAL PRECISION (p,q) 
        name BITFIELD LENGTH n        Bitfield identifiers are equal to 
                                      the bit offset of the item, and a 
                                      prefix$_name identifier is equal to

                                    3-34
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


                                      the size of the bit field in bits.

          MASK                        Mask declarations are constants 
                                      with the "m_" tag.

          SIGNED                      n/a

        name BOOLEAN 
        name CHARACTER LENGTH n 
           VARYING 
        name ADDRESS 

        Default storage class         The aggregate is placed
                                      in the absolute Psect $ABS$ and 
                                      the value of the current location 
                                      counter is set to the origin at 
                                      the beginning of the aggregate.  
                                      Element names can then be used
                                      as displacements off a register 
                                      that contains the address of the 
                                      actual aggregate.

        COMMON storage class          An aggregate or item is placed in 
                                      a Psect that has the same name as
                                      the top-level aggregate or item, 
                                      and the attributes SHR, GBL, and
                                      OVR.  Constant offsets are produced
                                      for all aggregate members.

        GLOBAL storage class          Generates .EXTERNAL declaration for
                                      the top-level name, and produces 
                                      offset constants for any aggregate
                                      members.  
          with /GLOBALDEF             Generates .GLOBAL declaration and 
                                      BLKB length for top-level name, and
                                      produces offset constants for any 
                                      aggregate members.

        BASED pointer-name            n/a

        DIMENSION lbound:hbound       Offsets are appropriately adjusted 
                                      to allow for the size of the array.

        ORIGIN member-name            Aggregate members preceding member-
                                      name may be referenced using 
                                      negative offsets with member-name 
                                      as the base.







                                    3-35
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


   Notes:   Notes:

        1.  The MACRO-32 output routine produces  declarations  that  can
            generate  either  local  symbol or global symbol definitions.
            Given the SDL source:

                 MODULE simple;
                  CONSTANT bits EQUALS 4;
                  ITEM field BYTE PREFIX tst$ COMMON;
                 END_MODULE;

            The resulting SDL MACRO output is:

                   .MACRO simple,..EQU=<=>,..COL=<:>
                 bits'..equ'4
                   .SAVE
                   .PSECT tst$b_field PIC,OVR,REL,GBL,-
                                      SHR,NOEXE,RD,WRT,LONG
                 tst$b_field'..col'  lkb 1
                   .RESTORE
                 ; tst$b_field'..equ'0
                   .ENDM

            When the macro is invoked without  arguments,  the  resulting
            local definitions are:

                 bits = 4
                 tst$b_field1:
                  blkb 1

            To generate these names as global  symbols,  you  invoke  the
            macro with the arguments <==> and <::>, as follows:

                  simple ..EQU=<==> ..COL=<::>

            This invocation results in the definitions:

                 bits == 4
                 tst$b_field1::
                  blkb 1

        2.  The MACRO output routine always generates a size variable for
            bit  fields, aggregates, arrays, and character strings, using
            the tag S_ preceding the output identifier.

        3.  Under the /VMS_DEVELOPMENT option (/VMS_DEVELOPMENT qualifier
            to the SDL command), special forms of macros are produced for
            entry point declarations.






                                    3-36
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


   3.1.8.5  PL/I Translation Summary -   3.1.8.5  PL/I Translation Summary -

           SDL
        Declaration               PL/I Output

        MODULE name               / MODULE name /
           IDENT string           /  string  /

        / comment                 / comment /

        CONSTANT x EQUALS n;      %REPLACE x BY n;

        ENTRY                     ENTRY
           PARAMETER (type,...)   (parameter-descriptor,...)
             ANY                  ANY
             DESCRIPTOR           DESCRIPTOR
             IN                   n/a
             OUT                  n/a
             NAMED param-name     n/a
             VALUE                VALUE
             REF                  n/a
             DEFAULT              n/a
             OPTIONAL             n/a
           RETURNS data-type      RETURNS (returns-descriptor)
           VARIABLE               OPTIONS(VARIABLE)
           ALIAS                  n/a
           LINKAGE                n/a

        STRUCTURE                 Structure declaration. An AGGREGATE 
                                  declaration is always assigned a 
                                  level number of 1; subsequent sub-
                                  aggregates are assigned level numbers 
                                  2, 3, and so on.

        UNION                     UNION

        BYTE                      FIXED BINARY(7)
        WORD                      FIXED BINARY(15)
        LONGWORD                  FIXED BINARY(31)
        QUADWORD                  BIT(64) ALIGNED
        OCTAWORD                  BIT(128) ALIGNED
        BYTE UNSIGNED             BIT(8) ALIGNED
        WORD UNSIGNED             BIT(16) ALIGNED
        LONGWORD UNSIGNED         BIT(32) ALIGNED
        QUADWORD UNSIGNED         BIT(64) ALIGNED 
        OCTAWORD UNSIGNED         BIT(128) ALIGNED 
        F_FLOATING                FLOAT BINARY(24)
        D_FLOATING                FLOAT BINARY(53)
        G_FLOATING                FLOAT BINARY(53)
        H_FLOATING                FLOAT BINARY(113)
        DECIMAL PRECISION (p,q)   DECIMAL (p,q)

        BITFIELD LENGTH n         BIT(n)

                                    3-37
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


           MASK                   %REPLACE prefixM_name BY mask-value;
           SIGNED                 n/a
        BOOLEAN                   BIT(1) ALIGNED
        CHARACTER LENGTH n        CHARACTER(n)
           VARYING                VARYING
        ADDRESS                   POINTER

        Default storage class     BASED attribute

        COMMON storage class      STATIC EXTERNAL

        GLOBAL storage class      GLOBALREF
           with /GLOBALDEF        GLOBALDEF

        BASED pointer-name        aggregate BASED (pointer-name)

        name DIMENSION            name ([lbound]:hbound)
        [lbound:]hbound

        ORIGIN member-name        n/a


   Notes:   Notes:

        1.  In PL/I,  you  can  access  values  declared  using  the  SDL
            UNSIGNED  keyword by specifying the name in a POSINT built-in
            function.  The integer value of the name  will  be  returned.
            Note that this will work only if the sign bit is 0.

        2.  The mask-value generated by SDL for the MASK  option  of  the
            BITFIELD data type is a bit-string constant.























                                    3-38
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


   3.1.8.6  PASCAL Translation Summary -   3.1.8.6  PASCAL Translation Summary -

            SDL
        Declaration               PASCAL Output

        MODULE name               (* MODULE name *)
           IDENT string           (* string *)

        /* comment                (* comment *)

        CONSTANT x EQUALS n;       CONST x = n

        ENTRY                     { FUNCTION# } name
                                  { PROCEDURE }
           PARAMETER (type,...)   (formal param_list)
             ANY                  %REF [UNSAFE] ARRAY [A.:INTEGER] OF 
             DESCRIPTOR           $UBYTE, %STDESR for character strings,
                                  else %DESCR; [READONLY is used for 
                                  items passed by descriptor]
             IN                   Default passing mechanism (unless 
                                  overridden by OUT)
             OUT                  VAR
             NAMED param-name     Parameter name.  If none given, 
                                  names will be generated of the 
                                  form $P1,...$Pn.
             VALUE                %IMMED
             REF                  %REF
             DEFAULT value        = %IMMED value
                                  If parameter is not IN, OUT, 
                                  DESCRIPTOR, or VALUE, then it will
                                  be passed by %REF.
             OPTIONAL             n/a
             TYPENAME type-name   n/a
           RETURNS data-type      : data-type
           VARIABLE               n/a
           ALIAS internal-name    Results in EXTERNAL (entry-name) and 
                                  internal-name used as entry-name.
           LINKAGE                n/a
           TYPENAME type-name     n/a

        STRUCTURE                 RECORD

        UNION                     RECORD CASE INTEGER OF
                                  0: ...
                                  .
                                  .
                                  n: ...

        BYTE                      $BYTE -- [BYTE] -128..127
        WORD                      $WORD -- [WORD] -32768..32767
        LONGWORD                  INTEGER
        QUADWORD                  $QUAD -- RECORD L0: UNSIGNED; 
                                                  L1: INTEGER; END

                                    3-39
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


        OCTAWORD                  $OCTA -- RECORD L0,L1,L2: UNSIGNED;
                                                  L3: INTEGER; END
        BYTE UNSIGNED             $UBYTE -- [BYTE] 0..255
        WORD UNSIGNED             $UWORD -- [WORD] 0..65535
        LONGWORD UNSIGNED         UNSIGNED
        QUADWORD UNSIGNED         $UQUAD -- RECORD L0,L1: UNSIGNED; END
        OCTAWORD UNSIGNED         $UOCTA -- RECORD L0,L1,L2,L3: 
                                                      UNSIGNED; END
        F_FLOATING                SINGLE
        D_FLOATING                DOUBLE
        G_FLOATING                DOUBLE
        H_FLOATING                QUADRUPLE
        DECIMAL PRECISION (p,q)   PACKED ARRAY [1..p+2-mod(p,2)] 
                                  OF $PACKED_DEC
                                  $PACKED_DEC -- [BIT(4),UNSAFE] O..15
        BITFIELD LENGTH n         $BIT1 -- [BIT(1)] BOOLEAN
                                  $BIT2...$BIT32 -- [BIT(2),UNSAFE] 0..1 
                                     etc.
           MASK                   CONST prefixM_name = mask-value;
           SIGNED                 n/a
        BOOLEAN                   BOOLEAN
        CHARACTER LENGTH n        PACKED ARRAY [1..n] OF CHAR
           VARYING                VARYING [n] OF CHAR
        ADDRESS                   datatype
                                  If datatype is not supplied, it 
                                  defaults to $DEFPTR which is defined 
                                  as $DEFTYP; $DEFTYP is defined as 
                                  [UNSAFE] INTEGER.

        Default storage class     TYPE

        COMMON storage class      [COMMON]

        GLOBAL storage class      [EXTERNAL]
           with /GLOBALDEF        [GLOBAL]

        BASED pointer-name        TYPE pointer-name = structure-name.

        name DIMENSION            ARRAY [lbound..hbound] OF datatype
        [lbound]:hbound           If lbound is not supplied, it defaults 
                                  to 1.
        ORIGIN member-name        n/a


   Notes   Notes

        1.  Since SDL allows more than one module per  SDL  source  file,
            the PASCAL MODULE statement cannot be used.

        2.  Where type names are  required  (for  example,  in  parameter
            lists,  function  return types, and pointer data types), they
            will be generated in a TYPE block at  the  beginning  of  the
            module.   Names  will be of the form module-name$$TYPn, where

                                    3-40
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


            module-name is truncated to 20 characters if necessary, and n
            is  an  integer  beginning at 1 and incremented by 1 for each
            type generated in a module.

        3.  Bit fields cannot be over 32 bits in length,  so  type  names
            will  be  generated  for each possible bit field size, giving
            the appropriate subranges.  Bit fields  of  length  1  are  a
            special case.

        4.  The mask-value generated by SDL for the MASK  option  of  the
            BITFIELD data type is an integer.

        5.  SDL generates only single-level records  for  Pascal.   Thus,
            one avoids having to write many long intermediate field names
            in the Pascal source  program.   If  the  outer  level  is  a
            structure,  a  PACKED  RECORD  is  normally declared.  If the
            outer level is a union,  a  PACKED  RECORD  CASE  INTEGER  is
            declared.

            In the case of multiple levels of  structures  or  unions  in
            SDL, the entire aggregate is transformed into a PACKED RECORD
            CASE INTEGER.  The intermediate  field-names  are  themselves
            declared  as  BYTE_DATA  fields.  This translation scheme may
            result in several fields in the record having the same name.






























                                    3-41
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


   3.1.8.7  DATATRIEVE Translation Summary -   3.1.8.7  DATATRIEVE Translation Summary -

            SDL
        Declaration               DATATRIEVE Output


        MODULE name               ! MODULE name 
           IDENT string           ! IDENT string 

        /* comment                ! comment 

        CONSTANT x EQUALS n;      ! x=n

        ENTRY                     ! entry name
           PARAMETER (type,...)   n/a
             ANY                  n/a
             DESCRIPTOR           n/a
             IN                   n/a
             OUT                  n/a
             NAMED param-name     n/a
             VALUE                n/a
             REF                  n/a
             DEFAULT              n/a
             OPTIONAL             n/a
             TYPENAME type-name   n/a
           RETURNS data-type      n/a
           VARIABLE               n/a
           ALIAS                  n/a
           LINKAGE                n/a
           TYPENAME type-name     n/a

        STRUCTURE                 A group field declaration.  An 
                                  AGGREGATE declaration is always 
                                  assigned a level number of 1; 
                                  subsequent subaggregates are 
                                  assigned level numbers 2, 3, and
                                  so on.

        UNION                     A group field declaration, with level 
                                  numbers assigned as above.  All but 
                                  the first union member have a REDEFINES
                                  first-field-name clause.  The redefined
                                  fields cannot be larger than the first 
                                  union member.

        BYTE                      USAGE IS BYTE
        WORD                      USAGE IS WORD
        LONGWORD                  USAGE IS LONG
        QUADWORD                  USAGE IS QUAD
        OCTAWORD                  USAGE IS QUAD OCCURS 2 TIMES
        BYTE UNSIGNED             USAGE IS BYTE
        WORD UNSIGNED             USAGE IS WORD
        LONGWORD UNSIGNED         USAGE IS LONG

                                    3-42
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


        QUADWORD UNSIGNED         USAGE IS QUAD
        F_FLOATING                USAGE IS REAL
        D_FLOATING                USAGE IS DOUBLE
        G_FLOATING                USAGE IS DOUBLE
        H_FLOATING                USAGE IS QUAD OCCURS 2 TIMES
        DECIMAL PRECISION (p,q)   USAGE IS PACKED PIC 9(p-q)V9(q)
        BITFIELD LENGTH n         ! name BIT position:size
                                    (See Note 1)
           MASK                   ! maskname = value
           SIGNED                 n/a
        BOOLEAN                   USAGE IS BYTE
        CHARACTER LENGTH n        PIC X(n)
           VARYING                A group field of the form:
                                   level field-name.
                                     level+1 STRING_LENGTH USAGE IS WORD.
                                     level+1 STRING_TEXT PIC X(n).
        ADDRESS                      USAGE IS LONG

        Default storage class     n/a

        COMMON storage class      n/a

        GLOBAL storage class      n/a
           with /GLOBALDEF        n/a

        BASED pointer-name        n/a
        pointer-name              USAGE IS LONG

        name DIMENSION            OCCURS hbound-lbound+1 TIMES
        [lbound:]hbound

        ORIGIN member-name        n/a


   Notes:   Notes:

        1.  Bit fields must be an integral number of bytes, or they  must
            be  union  members,  or  they  must  be  fully contained in a
            structure composed only of bit members.  If  they  are  in  a
            structure,  bit  names  themselves are commented out, but the
            appropriate amount of storage is allocated at  the  structure
            name  level.   USAGE  IS  BYTE,  WORD,  LONG, or QUAD is used
            whenever possible to allocate the storage;  otherwise,  USAGE
            IS BYTE OCCURS n TIMES is used.

        2.  All items and aggregates are output as record definitions  in
            the following way:

                 DEFINE RECORD aggregate-name_RECORD USING
                         1 aggregate-name.
                           2 member-name datatype.
                               .
                               .

                                    3-43
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


                               .
                         ;

            The record name is composed of  the  top-level  aggregate  or
            item name and the string "_RECORD".

        3.  Any dollar signs ($)  appearing  in  names  are  replaced  by
            hyphens (-).














































                                    3-44
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


   3.1.8.8  EPASCAL Translation Summary -   3.1.8.8  EPASCAL Translation Summary -

            SDL 
        Declaration               EPASCAL Output


        MODULE name               (* MODULE name *)
           IDENT string           (* string *)

        /* comment                (* comment *)

        CONSTANT x EQUALS n;      CONST x = n

        ENTRY                     { FUNCTION  } name
                                  { PROCEDURE }

           PARAMETER (type,...)   (formal param_list) Default mechanism
                                  is VAR with no attributes.
             ANY                  With VALUE, gives an ordinary INTEGER 
                                  value parameter; otherwise a VAR 
                                  ANYTYPE parameter.
             DESCRIPTOR           For CHARACTER type, STRING($Nn) or 
                                  VARYING_STRING($Nn), n being the param-
                                  eter number; VAR ANYTYPE otherwise.
             IN                   Unless overridden by OUT, causes no VAR 
                                  to appear, also [REFERENCE] if VALUE is
                                  not specified.  If /globaldef on 
                                  command line, adds [READONLY].
             OUT                  Overrides IN and/or REFERENCE.
             NAMED param-name     Parameter name.  If none given, 
                                  names will be generated of the form 
                                  $P1,...$Pn.
             VALUE                No attributes or VAR if type can be 
                                  passed in the argument list; error 
                                  otherwise.
             REF                  Adds [REFERENCE] if necessary, unless 
                                  VAR will appear.
             DEFAULT value        := value  for integer compatible data 
                                  types. VAR parameters containing 
                                  DEFAULT 0  are treated as [OPTIONAL].
                                  Parameters with data types that 
                                  translate to BYTE_DATA with a default 
                                  0 get initialized as ':= ZERO'. 
                                  BOOLEAN parameters with DEFAULT 0 
                                  are initialized with ':= false'.
             OPTIONAL             Adds [OPTIONAL] to VAR parameters; 
                                  otherwise only allowed on types to 
                                  which integers are assignment compatible, 
                                  and generates := 0.
           RETURNS data-type      : data-type
           VARIABLE               Adds [LIST] to the last parameter.
           ALIAS internal-name    n/a
           LINKAGE                n/a

                                    3-45
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


        STRUCTURE                 RECORD

        UNION                     RECORD CASE INTEGER OF
                                  0: ...
                                  .
                                  .
                                  n: ...

        BYTE                      [BYTE] -128..127
        WORD                      [WORD] -32768..32767
        LONGWORD                  INTEGER
        QUADWORD                  LARGE_INTEGER
        OCTAWORD                  BYTE_DATA(16)
        BYTE UNSIGNED             [BYTE] 0..255
        WORD UNSIGNED             [WORD] 0..65535
        LONGWORD UNSIGNED         BYTE_DATA(4)
        QUADWORD UNSIGNED         BYTE_DATA(8)
        OCTAWORD UNSIGNED         BYTE_DATA(16)
        F_FLOATING                REAL
        D_FLOATING                DOUBLE
        G_FLOATING                DOUBLE
        H_FLOATING                BYTE_DATA(16)
        DECIMAL PRECISION (p,q)   PACKED ARRAY [1..p+2-(p mod 2)] 
                                  OF [BIT(4)]0..15
        BITFIELD LENGTH n         $BIT1 -- [BIT(1)] BOOLEAN
                                  $BIT2 -- [BIT(2)] 0..3 
                                     etc.
           MASK                   CONST prefixM_name = %xmask-value;
           SIGNED                 n/a
                                  $BIT1 -- [BIT(1)] BOOLEAN
                                  $BIT2 -- [BIT(2)] -2..1 
                                     etc.
                                  (Note - 32 bit bitfields always 
                                  [BIT(32)]INTEGER, whether or not 
                                  SIGNED is present.)
        BOOLEAN                   BOOLEAN

        CHARACTER LENGTH n        STRING(n) (CHAR if n = 1)

           VARYING                VARYING_STRING(n)

        ADDRESS                   datatype
                                  If datatype is not supplied or is 
                                  ENTRY, it defaults to ANYTYPE
        Default storage class     TYPE
        COMMON storage class      VAR [EXTERNAL]
           with /GLOBALDEF        error

        GLOBAL storage class      VAR [EXTERNAL]
           with /GLOBALDEF        VAR no attributes

        BASED pointer-name        Aggregate of default storage class.  
                                  Pointer-name is ignored.

                                    3-46
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


        name DIMENSION            ARRAY [lbound..hbound] OF datatype
        [lbound]:hbound           If lbound is not supplied, it defaults 
                                  to 1. 
        ORIGIN member-name        n/a


   Notes:   Notes:

        1.  MODULE statement

            This, as well as the SDL IDENT option is translated  directly
            to  a  comment.   An Epascal MODULE statement would not allow
            one to %include the output.

        2.  ENTRY declarations

            These  are  translated   into   a   PROCEDURE   or   FUNCTION
            declaration, depending on whether a return type is specified.
            If  the  /GLOBALDEF  option   was   specified,   a   SEPARATE
            declaration  is  generated;  otherwise  an  EXTERNAL  one  is
            generated.  The ALIAS and LINKAGE  keywords  are  ignored  on
            ENTRY declarations.

        3.  PARAMETER declarations

            These are specified  with  a  data  type  and  zero  or  more
            attribute  keywords.   Parameters  are given default names in
            Epascal of $P1, $P2, ..., but may be given an  explicit  name
            with   the  NAME  keyword.   The  default  parameter  passing
            mechanism  is  VAR  with  no  Epascal  attributes.   This  is
            consistent  with  existing  SDL files and the output produced
            for other languages.  Otherwise, the  attributes  affect  the
            parameters according to the following rules:

            o  Type ANY - If VALUE is also specified, an ordinary INTEGER
               parameter   is   declared.    Otherwise,  an  ANYTYPE  VAR
               parameter is declared.  DESCRIPTOR and DEFAULT (the latter
               unless  VALUE is also specified) attributes are disallowed
               by the SDL front end on ANY type parameters.

            o  VARIABLE  attribute  -  This  keyword  is   not   actually
               specified on a parameter, but rather on the entry.  It has
               the effect of adding the Epascal [LIST] attribute  to  the
               last  parameter.   It is not allowed if the last parameter
               is also specified with  DESCRIPTOR  or  DEFAULT  or  is  a
               conformant array type (specified with DIMENSION *).

            o  DESCRIPTOR  attribute  -  this  keyword  means  that   the
               parameter  is  to  be  passed  by a VAX descriptor.  Since
               Epascal does not support these, a VAR ANYTYPE parameter is
               normally generated in this case.  However, if the SDL data
               type is CHARACTER, a string or varying  string  conformant
               parameter   is   generated,   as   this  matches  the  VAX

                                    3-47
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


               descriptor.  Such a declaration has an extent parameter of
               $Nn, where "n" is the parameter number.  This attribute is
               not allowed by the SDL front end with the VALUE, REFERENCE
               or  DEFAULT  attributes  or  ANY type, and the Epascal SDL
               backend disallows it with the VARIABLE attribute.

            o  IN attribute - Unless overridden by OUT (in which case  IN
               has no effect), this causes the parameter to be treated as
               an input parameter, and so no  VAR  appears.   Unless  the
               VALUE  attribute  is also present, the Epascal [REFERENCE]
               attribute  is  also  added  if  the  parameter  would  not
               normally  be  passed by reference.  The Epascal [READONLY]
               attribute is added to the declaration  if  /GLOBALDEF  was
               specified;  this  causes  an Epascal routine to not make a
               copy  of  the  argument.   [READONLY]  is  not  added   if
               /GLOBALDEF  was not specified because that would cause the
               calling routine to save the argument value  unnecessarily.
               IN  isn't  allowed  by  the SDL front end with the DEFAULT
               attribute.

            o  OUT attribute - This normally has no effect in Epascal; it
               causes  the parameter to be passed with VAR semantics, but
               that's the normal case anyway.  It does, however, override
               the  REFERENCE  and  IN  attributes.   The  SDL  front end
               disallows the  combination  of  OUT  and  VALUE,  and  the
               Epascal  backend  disallows  the  combination  of  OUT and
               DEFAULT.

            o  VALUE attribute - This causes the parameter to  be  passed
               immediately  in  the  argument  list  if Epascal uses that
               method for  the  parameter's  data  type;  otherwise,  the
               Epascal  backend  generates  an  error.   Thus, no Epascal
               attributes are generated.  The  SDL  front  end  does  not
               allow  VALUE with DESCRIPTOR, OUT or REFERENCE.  Since the
               LONGWORD UNSIGNED parameters translates to BYTE_DATA(4) in
               epascal,  the  VALUE  attribute  is  ignored in this case.
               BYTE_DATA parameters are passed by REFERENCE.

            o  REFERENCE attribute - This attribute causes the  parameter
               to be passed by reference.  Therefore, unless OUT was also
               specified, or the parameter's type is of a  type  that  is
               normally  passed  by  REFERENCE,  the  Epascal [REFERENCE]
               attribute is added.  The SDL front end disallows REFERENCE
               in  combinations  with  the  VALUE,  DESCRIPTOR or DEFAULT
               attributes.

            o  DEFAULT attribute - Causes an Epascal default  initializer
               to be specified, and therefore VAR semantics are not used.
               It is only allowed on data types  to  which  integers  are
               assignment compatible, or with the ANY type in combination
               with the VALUE attribute.  The SDL front end disallows  it
               with  ANY type (unless VALUE is also present), DESCRIPTOR,
               IN,  REFERENCE  and  OPTIONAL,  and  the  Epascal  backend

                                    3-48
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


               disallows  it  with  the  VARIABLE  (except for default 0)
               attribute or conformant array types (those specified  with
               DIMENSION   *).    VAR  parameters  that  have  DEFAULT  0
               specified are treated  as  optional  parameters.   BOOLEAN
               data with a DEFAULT 0 specified get an intial value of ':=
               false'.

            o  OPTIONAL attribute - With VAR  semantics,  this  generates
               the  Epascal  [OPTIONAL] attribute.  Otherwise, it is only
               allowed  on  types  to  which  integers   are   assignment
               compatible and generates an Epascal default initializer of
               0.  The SDL front end does not  allow  it  in  conjunction
               with  the  DESCRIPTOR  or  DEFAULT  attribute, and the SDL
               Epascal backend does not  allow  it  in  conjunction  with
               conformant array types (those specified with DIMENSION *).
               It is ignored if specified on a  parameter  that  will  be
               given the [LIST] attribute.

            o  A parameter declared with the DIMENSION * attribute causes
               an   Epascal   ISO  conformant  array  declaration  to  be
               generated for the parameter.  Such a parameter has a lower
               bound  of  $Ln and an upper bound of $Un, where "n" is the
               parameter number.  Such a parameter may  not  be  declarad
               VARIABLE, OPTIONAL or DEFAULT.

        4.  Records and Variants

            SDL generates only single-level records for  Epascal.   Thus,
            one avoids having to write many long intermediate field names
            in the Epascal source program.   If  the  outer  level  is  a
            structure,  a  PACKED  RECORD  is  normally declared.  If the
            outer level is a union,  a  PACKED  RECORD  CASE  INTEGER  is
            declared.

            In the case of multiple levels of  structures  or  unions  in
            SDL, the entire aggregate is transformed into a PACKED RECORD
            CASE INTEGER.  The intermediate  field-names  are  themselves
            declared  as  BYTE_DATA  fields.  This translation scheme can
            result in several fields in a record having the same name, in
            which  case  an error message is generated.  (This message is
            rather generic).

        5.  Arrays

            An item with the SDL DIMENSION attribute is  translated  into
            an Epascal PACKED ARRAY declaration.  The default lower bound
            is 1.

        6.  Storage Classes

            In Epascal the "default storage class"  is  TYPE.   In  other
            words,  if you don't specify COMMON or GLOBAL on an item, you
            get a TYPE declaration.  If  you  do  specify  one  of  these

                                    3-49
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


            keywords,  you  get  a VAR declaration.  If /GLOBALDEF is not
            specified, the [EXTERNAL] attribute is added  in  either  VAR
            case.    If  /GLOBALDEF  is  specified,  the  COMMON  keyword
            generates an  error  message,  and  GLOBAL  adds  no  Epascal
            attribute.

        7.  ORIGIN

            This  attribute  does  not  affect  the  Epascal   generated.
            However,  if  the  origin  of  a record is specified as being
            other than its first field, it does cause a  warning  comment
            to  be  output  to the Epascal source file to the effect that
            the structure has a negative origin.   This  is  exactly  the
            behavior of the PLI backend.

        8.  Reserved Words

            SDL declarations that match Epascal reserved  words  have  an
            underscore appended to the end.

        9.  Auxiliary Type Declarations

            In a few cases, the Epascal  Backend  has  to  generate  some
            auxiliary types:

            Parameters and return types that are arrays or have the byte,
            word or bit attribute.

            Pointer associated types that are one of the above or another
            pointer.

            These type names have the following form:

                 module_name$$BYTE  for bytes
                 module_name$$UBYTE for unsigned bytes
                 module_name$$WORD  for words
                 module_name$$UWORD for unsigned words
                 module_name$$TYPn  for all other types

            These type names are only generated if they are needed.














                                    3-50
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


   3.1.8.9  ADA Translation Summary -   3.1.8.9  ADA Translation Summary -

           SDL 
        Declaration               Ada Output

        MODULE name               -- MODULE NAME
           IDENT string

        /* comment                -- comment

        CONSTANT x EQUALS n;      x :  constant := n ;

        ENTRY name                      
                                  procedure name (
                                     parameter-list
                                     ...
                                  );

                                  pragma INTERFACE (EXTERNAL, name);

                                  pragma IMPORT_VALUED_PROCEDURE 
                                     (name, "name", 
                                     ( type,...)

           PARAMETER (type,...)         parameter-name :  type;
                                        ..
             ANY                        UNSIGNED_LONGWORD ;
             DESCRIPTOR                 generates  the  DESCRIPTOR(S)  
                                        passing mechanism name in the
                                        IMPORT_VALUED_PROCEDURE pragma 
                                        for the parameter.
             IN                         Causes the in  parameter  mode  
                                        to appear on the formal
        parameter.
             OUT                        Cause the out parameter mode to 
                                        appear on the formal parameter.
             NAMED param-name           Parameter name.  If none exists,
                                        names will be generated of the 
                                        form PARAMETER_1 ...
        PARAMETER_n.
             VALUE                      generates the VALUE passing  
                                        mechanism name  in  the  
                                        IMPORT_VALUED_PROCEDURE pragma
                                        for the parameter.
             REFERENCE                  generates the REFERENCE passing
                                        mechanism name in the
                                        IMPORT_VALUED_PROCEDURE pragma 
                                        for the parameter.
             DEFAULT value              if DEFAULT 0, see the table below
                                        for the initial values of each
                                        SDL data type.  If the parameter
                                        contains  the VALUE attribute and
                                        the default value is other than

                                    3-51
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


                                        0, that  :=  value  is added to
                                        the parameter.
             OPTIONAL                   n/a
             TYPENAME type-name         Specifies a non-SDL  keyword  
                                        datatype to be used as the
                                        parameter type.
           RETURNS data-type            first parameter in the  
                                        parameter-list is the return
                                        parameter.  A comment of the form
                                        '-- return value'  is  placed
                                        along side the return parameter.
           VARIABLE                     n/a
           ALIAS internal-name          n/a
           LINKAGE                      n/a
           TYPENAME type-name           Specifies a non-SDL keyword
                                        datatype to be used as the entry
                                        type.

        STRUCTURE name                  An Ada record type will be  
                                        generated as well as a record 
                                        representation clause and an 
                                        initialization  constant for 
                                        the record.  If any sub-struc-
                                        tures exist,  the  record  types
                                        for those structures  will  be  
                                        generated first.  See the note
                                        below on structures for a dis-
                                        cussion  of structure to Ada 
                                        record translation.

        UNION                           An Ada record type is 
                                        generated depending on the 
                                        union.  See the notes below 
                                        for a discussion of union
                                        translations.

        BYTE                            SHORT_SHORT_INTEGER
        WORD                            SHORT_INTEGER
        LONGWORD                        INTEGER
        QUADWORD                        UNSIGNED_QUADWORD
        OCTAWORD                        UNSIGNED_LONGWORD_ARRAY(0 ..  3)
        BYTE UNSIGNED                   UNSIGNED_BYTE
        WORD UNSIGNED                   UNSIGNED_WORD
        LONGWORD UNSIGNED               UNSIGNED_LONGWORD
        QUADWORD UNSIGNED               UNSIGNED_QUADWORD
        OCTAWORD UNSIGNED               UNSIGNED_LONGWORD_ARRAY(0 ..  3)
        F_FLOATING                      FLOAT
        D_FLOATING                      D_FLOAT
        G_FLOATING                      G_FLOAT
        H_FLOATING                      LONG_LONG_FLOAT
        DECIMAL PRECISION (p,q)         (this type has not yet been
                                        implemented)  A comment will 
                                        appear in the output and a

                                    3-52
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


                                        message  will  be printed to
                                        this effect.
        BITFIELD LENGTH n               BOOLEAN (one bit)
                                        UNSIGNED_n (if length > 1)
           MASK                         CONST  prefixMname : constant :=
                                        16#mask-value#;
           SIGNED
        BOOLEAN                         BOOLEAN
        CHARACTER LENGTH n              STRING(1 ..  n)
           VARYING                      UNSIGNED_WORD field for the 
                                        string length will be generated 
                                        if VARYING is specified.

        ADDRESS                         ADDRESS

        Default storage class

        COMMON storage class            n/a

        GLOBAL storage class            n/a

        BASED pointer-name              n/a


        DIMENSION [lbound]:hbound       if other than BITFIELD data type,
                                        just append '_ARRAY (lbound ..
                                        hbound)' to the type.

                                        For BITFIELDS, a BIT_ARRAY will
                                        be generated of the form
                                        BIT_ARRAY(0 .. hbound*length-1).
                                        If lbound is not supplied, it 
                                        defaults to 1.
        ORIGIN member-name              n/a


   Notes:   Notes:

        1.  Ada names

            Dollar signs ($) are illegal in ada names  and  are  replaced
            with underscores(_).

        2.  Union criteria

            If the union is of the following form  it  is  treated  as  a
            record type:

                 A ... union;
                 ITEM_1 ...;           /* First member is not a union or
                                          a structure and the size of the
                                          first member is the same as the
                                          size of the union and

                                    3-53
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


                 ITEM_2 structure ...; /* Second member is a structure 
                                          and the size of the first
                 member
                                          is the same as the size of the 
                                          union.  (Needed so size based
                                          on structure components is
                                          correct.)
                             I_2_A ...;
                             I_2_B ...;
                             ...
                            end ITEM_2;
                            ITEM_3 ...;
                            ...
                            end A;

            Otherwise the union is ignored and only the first  member  is
            used.

                          Example 1 - Criteria are satisfied:
                          ---------

                              aggregate X prefix XXX$;
                                  X_1 longword unsigned;
                                  X_2_OVERLAY union;
                                      X_2 longword unsigned;
                                      X_2_FIELDS structure;
                                          X_2_B_1 byte unsigned;
                                          X_2_B_2 byte unsigned;
                                      end X_2_FIELDS;
                                      X_2_C word unsigned;
                                      X_2_D structure;
                                          X_2_D_1 bitfield(3);
                                          X_2_D_2 bitfield;
                                      end X_2_D;
                                 end X_2_OVERLAY;
                              end X;

            The X_2_OVERLAY union in this example statisfies the criteria
            above   and   would  be  treated  as  a  record  declaration.
            Something like the following would be generated:

                              type XXX_X_2_TYPE is record
                                  X_2_B_1 : BYTE;
                                  X_2_B_2 : BYTE;
                                  end record;
                           
                              type XXX_X_2_D_TYPE is record
                                  X_2_D_1 : FLAGS(1 .. 3);
                                  X_2_D_2 : BOOLEAN;
                                  end record;
                           
                              type XXX_TYPE is record
                                  X_1 : LONGWORD;

                                    3-54
                                       SDL LANGUAGE AND COMMAND REFERENCE                                       SDL LANGUAGE AND COMMAND REFERENCE


                                  X_2 : XXX_X_2_TYPE;

                              ----X_2_C overlaps X_2
                              ----
                              ----X_2_C : UNSIGNED_16;

                              ----X_2_D overlaps X_2
                              ----
                              ----X_2_D : XXX_X_2_D_TYPE;
                           
                                  end record;
                           
                          Example 2 - Criteria are not satisfied
                          ---------
                           
                              aggregate Y prefix YYY$;
                                  Y_1 longword unsigned;
                                  Y_2_OVERLAY union;
                                      Y_2_A byte unsigned;
                                      Y_2_B byte unsigned;
                                  end Y_2_OVERLAY;
                              end Y;

            In this example the second member is not  a  structure.   The
            following would be generated:
                           
                              type YYY_TYPE is record
                                  Y_1 : LONGWORD;
                                  Y_2_A : BYTE;
                           
                              ----Y_2_B overlaps Y_2_A
                              ----
                              ----Y_2_B : BYTE;
                           
                                  end record;

        3.  IN OUT parameter modes

            If no mode is explicitly given for a parameter,  the  default
            mode (in) will appear.

        4.  OPTIONAL parameters

            If there are optional parameters, two subprogram declarations
            will  be  generated  with  and  without  the  optional formal
            parameters.

        5.  Default values

            What follows is a list of SDL datatypes and the  default  Ada
            values for the initialization constant.



                                    3-55
   SDL LANGUAGE AND COMMAND REFERENCE   SDL LANGUAGE AND COMMAND REFERENCE


                 SDL TYPE    Ada INITIALIZATION                 SDL TYPE    Ada INITIALIZATION

                 address     ADDRESS_ZERO

                 byte        0

                 char        ASCII.NUL

                 decimal     NYI_PACKED_DECIMAL_ZERO

                 double      0.0

                 float       0.0

                 g_float     0.0

                 d_float     0.0

                 longword    0

                 quadword    (0, 0)

                 octaword    (0, 0, 0, 0)

                 word        0

        6.  Structure to Ada Record Translation

            For each SDL  structure,  the  corresonding  Ada  translation
            consists  of  three  parts:  1) a record type definition 2) a
            record  representation  clause  and  3)   an   initialization
            constant for the record.  The three parts are of the form

            1.  type structure-name is record member-name  :   type;  ...
                end record;

            2.  for structure-name use record member-name at offset range
                0  ..   size; ...  end record for structure-name'size use
                total-size

            3.  structure-name_INIT   :    constant   structure-name   :=
                (member-name => initial_value, ...  )

            where size is the size of the field in bits,  and  total_size
            is the size of the entire record in bits.









                                    3-56












                                 CHAPTER 4                                 CHAPTER 4

                                  EXAMPLES                                  EXAMPLES



   4.1  EXAMPLES   4.1  EXAMPLES
   4.1.1  SDL Source File Listing   4.1.1  SDL Source File Listing

        MODULE $defopr ;
         
         #array_size = 255;
         CONSTANT operand_size EQUALS 1;
         CONSTANT max_arguments EQUALS #array_size;

         ITEM block_list_id ADDRESS GLOBAL;
         
        /* assign values to context identifiers 
         
         CONSTANT (
           bits, /* 0
           bytes, /* 1
           words, /* 2
           longs, /* 3
           quads, /* 4
           octas /* 5
           ) EQUALS 0 INCREMENT 1 PREFIX ctx$;
          
         
         AGGREGATE operator STRUCTURE PREFIX opr$;
          id  WORD;
          count  WORD;
          size  WORD;
          last_use WORD;
          type  BYTE UNSIGNED;
          number  BYTE UNSIGNED;
          opcode  BYTE UNSIGNED;
          opbits  STRUCTURE;
           variable_size bitfield ;
           size_units bitfield LENGTH 3;
           offset_units bitfield LENGTH 3;
           "alias"  bitfield;
           END opbits;
          argbits  STRUCTURE;

                                    4-1
   EXAMPLES   EXAMPLES


           by_desc_ bitfield;
           by_immed_ bitfield;
           by_ref_ bitfield;
           END argbits;
          #opsize = .;
          operand WORD DIMENSION 0:#array_size-1;
          END operator;
         
         CONSTANT operator_size EQUALS #opsize/2;


         AGGREGATE token STRUCTURE PREFIX tok$  TAG "" common
            ; /* filled in by LEX
          token_id LONGWORD; /* token id
          source_line LONGWORD; /* source line number of token
          token_length LONGWORD; /* length of token string
          token_string CHARACTER LENGTH 1024; /* token string
        CONSTANT size EQUALS .; /* token size
          END;

        END_MODULE;

        MODULE externals;

         
        /* Get Job/Process Information system service 

          ENTRY SYS$GETJPI ALIAS $GETJPI PARAMETER (
         LONGWORD UNSIGNED VALUE NAMED EFN TYPENAME EFNUM,
         LONGWORD UNSIGNED NAMED PIDADR IN OUT TYPENAME PROCID,
         CHARACTER DESCRIPTOR NAMED PRCNAM IN TYPENAME PROCNAME,
         ANY NAMED ITMLST IN TYPENAME ITEMLIST,
         QUADWORD UNSIGNED NAMED IOSB OUT TYPENAME IOSB,
         ADDRESS(ENTRY) NAMED ASTADR TYPENAME ASTADR,
         LONGWORD UNSIGNED VALUE NAMED ASTPRM DEFAULT 0 TYPENAME USERPARM
         ) RETURNS LONGWORD TYPENAME CONDVALU;

        END_MODULE;

        MODULE more_examples IDENT "V1.0";

        /*
        /* CSR07 (+^o16) - Interrupt Summary 2 CSR
        /* Example of Union
        /*
         AGGREGATE isum2_word UNION;
             isum2  WORD UNSIGNED TAG""; /* InterruptSummary2CSR
             isum2_bits STRUCTURE PREFIX sgp$;
          fonterror BITFIELD MASK; /* FontError
          clipped  BITFIELD MASK; /* Clipped
          isum2_1  BITFIELD LENGTH 16-^ MASK;
          END isum2_bits;
             END isum2_word;

                                    4-2
                                                                 EXAMPLES                                                                 EXAMPLES


        /*
        /* an example with one of every data type
        /*
         AGGREGATE one_of_each STRUCTURE PREFIX sdl$; /* show all data types
          integer_types UNION; /* for fun, overlay signed and unsigned
              signed_types STRUCTURE; /* signed datatypes
           one BYTE; /* byte datatype;
           two WORD; /* word datatype;
           three LONGWORD; /* a longword datatype
           four QUADWORD; /* a quadword datatype
           five OCTAWORD; /* an octaword datatype
           END;
              unsigned_types STRUCTURE; /* unsigned data types
           uone BYTE UNSIGNED;
           utwo WORD UNSIGNED;
           uthree LONGWORD UNSIGNED;
           ufour QUADWORD UNSIGNED;
           ufive OCTAWORD UNSIGNED;
           END;
          END;
          f F_FLOATING;  /* single floating
          dg UNION DIMENSION 0:4; /* good place for a union array
           d D_FLOATING; /* double floating
           g G_FLOATING; /* grand floating
           END;
          h H_FLOATING;  /* huge floating
        #p=10; #q=5;
          dec DECIMAL PRECISION (#p,#q); /* packed decimal
          some_bits STRUCTURE;
           b1 BITFIELD MASK; /* one bit
           b2 BITFIELD LENGTH 2 MASK; /* two bits
           b3 BITFIELD MASK LENGTH 3; /* three bits
           END;
          truth BOOLEAN; /* boolean
          string CHARACTER LENGTH 32; /* character string
          vstring CHARACTER LENGTH 128 VARYING; /* character varying
          p1 ADDRESS (LONGWORD); /* pointer to longword
          p2 ADDRESS (CHARACTER LENGTH 512 DIMENSION 2)
             ;/* pointer to char string array
          p3 ADDRESS (isum2_word); /* pointer to aggregate
          p4 ADDRESS;  /* untyped pointer
          p5 ADDRESS (BYTE DIMENSION 8) DIMENSION 10
             ;/* array of pointers to an array
          END one_of_each;

        /* Example of an implicit union with dimension

            AGGREGATE fid STRUCTURE WORD DIMENSION 3 PREFIX "tst$";
                first WORD;
                second WORD;
                third WORD;
            END fid;


                                    4-3
   EXAMPLES   EXAMPLES


        END_MODULE more_examples;





















































                                    4-4
                                                                 EXAMPLES                                                                 EXAMPLES


   4.1.2  BLISS-32 (BLISSF) Output   4.1.2  BLISS-32 (BLISSF) Output

         
        !*** MODULE $defopr ***
        literal operand_size = 1;
        literal max_arguments = 255;
        external block_list_id;
        !  assign values to context identifiers 
        literal ctx$k_bits = 0;                 !  0
        literal ctx$k_bytes = 1;                !  1
        literal ctx$k_words = 2;                !  2
        literal ctx$k_longs = 3;                !  3
        literal ctx$k_quads = 4;                !  4
        literal ctx$k_octas = 5;                !  5
        literal opr$s_operand = 510;
        FIELD opr$operator_FIELDSET =
          SET
          opr$w_id = [0,0,16,1],
          opr$w_count = [2,0,16,1],
          opr$w_size = [4,0,16,1],
          opr$w_last_use = [6,0,16,1],
          opr$b_type = [8,0,8,0],
          opr$b_number = [9,0,8,0],
          opr$b_opcode = [10,0,8,0],
            opr$v_variable_size = [11,0,1,0],
            opr$v_size_units = [11,1,3,0],
            opr$v_offset_units = [11,4,3,0],
            opr$v_alias = [11,7,1,0],
          opr$r_opbits = [11,0,8,0],
            opr$v_by_desc_ = [12,0,1,0],
            opr$v_by_immed_ = [12,1,1,0],
            opr$v_by_ref_ = [12,2,1,0],
          opr$r_argbits = [12,0,8,0],
          opr$w_operand = [13,0,0,1]
          TES;
        literal opr$s_operator = 523;
        MACRO operator = BLOCK [opr$s_operator,byte] FIELD (opr$operator_FIELDSET) %;
        literal operator_size = 6;
        literal tok$k_size = 1036;              !  token size
        literal tok$s_token_string = 1024;
        FIELD tok$token_FIELDSET =          !  filled in by LEX
          SET
          tok$l_token_id = [0,0,32,1],          !  token id
          tok$l_source_line = [4,0,32,1],       !  source line number of token
          tok$l_token_length = [8,0,32,1],      !  length of token string
          tok$t_token_string = [12,0,0,0]       !  token string
          TES;
        literal tok$s_token = 1036;
        MACRO token$TYPE = BLOCK [tok$s_token,byte] FIELD (tok$token_FIELDSET) %;
        external token : token$TYPE;            !  filled in by LEX
         
        !*** MODULE externals ***
        !  Get Job/Process Information system service 

                                    4-5
   EXAMPLES   EXAMPLES


        external routine SYS$GETJPI;
         
        !*** MODULE more_examples IDENT V1.0 ***
        ! 
        !  CSR07 (+^o16) - Interrupt Summary 2 CSR
        !  Example of Union
        ! 
        literal sgp$m_fonterror = 1;
        literal sgp$m_clipped = 2;
        literal sgp$m_isum2_1 = 65532;
        FIELD isum2_word_FIELDSET =
          SET
          isum2 = [0,0,16,0],                   !  InterruptSummary2CSR
            sgp$v_fonterror = [0,0,1,0],        !  FontError
            sgp$v_clipped = [0,1,1,0],          !  Clipped
            sgp$v_isum2_1 = [0,2,14,0],
          isum2_bits = [0,0,16,0]
          TES;
        literal s_isum2_word = 2;
        MACRO isum2_word = BLOCK [s_isum2_word,byte] FIELD (isum2_word_FIELDSET) %;
        ! 
        !  an example with one of every data type
        ! 
        literal sdl$m_b1 = 1;
        literal sdl$m_b2 = 6;
        literal sdl$m_b3 = 56;
        literal sdl$s_integer_types = 31;
        literal sdl$s_dg = 40;
        literal sdl$s_h = 16;
        literal sdl$s_dec = 6;
        literal sdl$s_string = 32;
        literal sdl$s_vstring = 130;
        literal sdl$s_p5 = 40;
        FIELD sdl$one_of_each_FIELDSET =          !  show all data types
          SET
              sdl$b_one = [0,0,8,1],            !  byte datatype;
              sdl$w_two = [1,0,16,1],           !  word datatype;
              sdl$l_three = [3,0,32,1],         !  a longword datatype
              sdl$q_four = [7,0,0,0],           !  a quadword datatype
              sdl$o_five = [15,0,0,0],          !  an octaword datatype
            sdl$r_signed_types = [0,0,0,0],     !  signed datatypes
              sdl$b_uone = [0,0,8,0],
              sdl$w_utwo = [1,0,16,0],
              sdl$l_uthree = [3,0,32,0],
              sdl$q_ufour = [7,0,0,0],
              sdl$o_ufive = [15,0,0,0],
            sdl$r_unsigned_types = [0,0,0,0],   !  unsigned data types
          sdl$r_integer_types = [0,0,0,0],      !  for fun, overlay signed and unsigned
          sdl$f_f = [31,0,32,0],                !  single floating
            sdl$d_d = [35,0,0,0],               !  double floating
            sdl$g_g = [35,0,0,0],               !  grand floating
          sdl$r_dg = [35,0,0,0],                !  good place for a union array
          sdl$h_h = [75,0,0,0],                 !  huge floating

                                    4-6
                                                                 EXAMPLES                                                                 EXAMPLES


          sdl$p_dec = [91,0,0,0],               !  packed decimal
            sdl$v_b1 = [97,0,1,0],              !  one bit
            sdl$v_b2 = [97,1,2,0],              !  two bits
            sdl$v_b3 = [97,3,3,0],              !  three bits
          sdl$r_some_bits = [97,0,8,0],
          sdl$b_truth = [98,0,8,0],             !  boolean
          sdl$t_string = [99,0,0,0],            !  character string
          sdl$t_vstring = [131,0,0,0],          !  character varying
          sdl$a_p1 = [261,0,32,0],              !  pointer to longword
          sdl$a_p2 = [265,0,32,0],              !  pointer to char string array
          sdl$a_p3 = [269,0,32,0],              !  pointer to aggregate
          sdl$a_p4 = [273,0,32,0],              !  untyped pointer
          sdl$a_p5 = [277,0,0,0]                !  array of pointers to an array
          TES;
        literal sdl$s_one_of_each = 317;
        MACRO one_of_each = BLOCK [sdl$s_one_of_each,byte] FIELD (sdl$one_of_each_FIELDSET) %; !  show
        all data types
        !  Example of an implicit union with dimension
        literal tst$s_fid = 6;
        literal tst$s_fill_3 = 6;
        FIELD tst$fill_2_FIELDSET =
          SET
          w_fid = [0,0,0,1],
            tst$w_first = [0,0,16,1],
            tst$w_second = [2,0,16,1],
            tst$w_third = [4,0,16,1],
          TES;
        literal tst$s_fill_2 = 6;
        MACRO fill_2 = BLOCK [tst$s_fill_2,byte] FIELD (tst$fill_2_FIELDSET) %;

























                                    4-7
   EXAMPLES   EXAMPLES


   4.1.3  C Output   4.1.3  C Output

         
        /*** MODULE $defopr ***/
        #define operand_size 1
        #define max_arguments 255
        globalref int *block_list_id;
        /* assign values to context identifiers                                     */
        #define ctx$k_bits 0                    /* 0                                */
        #define ctx$k_bytes 1                   /* 1                                */
        #define ctx$k_words 2                   /* 2                                */
        #define ctx$k_longs 3                   /* 3                                */
        #define ctx$k_quads 4                   /* 4                                */
        #define ctx$k_octas 5                   /* 5                                */
        struct operator {
            short int opr$w_id;
            short int opr$w_count;
            short int opr$w_size;
            short int opr$w_last_use;
            unsigned char opr$b_type;
            unsigned char opr$b_number;
            unsigned char opr$b_opcode;
            struct  {
                unsigned opr$v_variable_size : 1;
                unsigned opr$v_size_units : 3;
                unsigned opr$v_offset_units : 3;
                unsigned opr$v_alias : 1;
                } opr$r_opbits;
            struct  {
                unsigned opr$v_by_desc_ : 1;
                unsigned opr$v_by_immed_ : 1;
                unsigned opr$v_by_ref_ : 1;
                unsigned opr$v_fill_0 : 5;
                } opr$r_argbits;
            short int opr$w_operand [255];
            } ;
        #define operator_size 6
        #define tok$k_size 1036                 /* token size                       */
        extern struct  {                        /* filled in by LEX                 */
            long int tok$l_token_id;            /* token id                         */
            long int tok$l_source_line;         /* source line number of token      */
            long int tok$l_token_length;        /* length of token string           */
            char tok$t_token_string [1024];     /* token string                     */
            } token;
         
        /*** MODULE externals ***/
        /* Get Job/Process Information system service                               */
        long int SYS$GETJPI() ;
         
        /*** MODULE more_examples IDENT V1.0 ***/
        /*                                                                          */
        /* CSR07 (+^o16) - Interrupt Summary 2 CSR                                  */
        /* Example of Union                                                         */

                                    4-8
                                                                 EXAMPLES                                                                 EXAMPLES


        /*                                                                          */
        #define sgp$m_fonterror 1
        #define sgp$m_clipped 2
        #define sgp$m_isum2_1 65532
        union isum2_word {
            unsigned short int isum2;           /* InterruptSummary2CSR             */
            struct  {
                unsigned sgp$v_fonterror : 1;   /* FontError                        */
                unsigned sgp$v_clipped : 1;     /* Clipped                          */
                unsigned sgp$v_isum2_1 : 14;
                } isum2_bits;
            } ;
        /*                                                                          */
        /* an example with one of every data type                                   */
        /*                                                                          */
        #define sdl$m_b1 1
        #define sdl$m_b2 6
        #define sdl$m_b3 56
        struct one_of_each {                    /* show all data types              */
            union  {                            /* for fun, overlay signed and unsigned */
                struct  {                       /* signed datatypes                 */
                    char sdl$b_one;             /* byte datatype;                   */
                    short int sdl$w_two;        /* word datatype;                   */
                    long int sdl$l_three;       /* a longword datatype              */
                    int sdl$q_four [2];         /* a quadword datatype              */
                    int sdl$o_five [4];         /* an octaword datatype             */
                    } sdl$r_signed_types;
                struct  {                       /* unsigned data types              */
                    unsigned char sdl$b_uone;
                    unsigned short int sdl$w_utwo;
                    unsigned long int sdl$l_uthree;
                    unsigned int sdl$q_ufour [2];
                    unsigned int sdl$o_ufive [4];
                    } sdl$r_unsigned_types;
                } sdl$r_integer_types;
            float sdl$f_f;                      /* single floating                  */
            union  {                            /* good place for a union array     */
                double float sdl$d_d;           /* double floating                  */
                double float sdl$g_g;           /* grand floating                   */
                } sdl$r_dg [5];
            int sdl$h_h [4];                    /* huge floating                    */
            char sdl$p_dec [6];                 /* packed decimal                   */
            struct  {
                unsigned sdl$v_b1 : 1;          /* one bit                          */
                unsigned sdl$v_b2 : 2;          /* two bits                         */
                unsigned sdl$v_b3 : 3;          /* three bits                       */
                unsigned sdl$v_fill_1 : 2;
                } sdl$r_some_bits;
            char sdl$b_truth;                   /* boolean                          */
            char sdl$t_string [32];             /* character string                 */
            struct {short string_length; char string_text[128];} sdl$t_vstring; /* character varying */
            long int *sdl$a_p1;                 /* pointer to longword              */
            char (*sdl$a_p2) [512] [2];         /* pointer to char string array     */

                                    4-9
   EXAMPLES   EXAMPLES


            union isum2_word *sdl$a_p3;         /* pointer to aggregate             */
            int *sdl$a_p4;                      /* untyped pointer                  */
            char (*sdl$a_p5 [10]) [8];          /* array of pointers to an array    */
            } ;
        /* Example of an implicit union with dimension                              */
        union fill_2 {
            short int w_fid [3];
            struct  {
                short int tst$w_first;
                short int tst$w_second;
                short int tst$w_third;
                } tst$r_fill_3;
            } ;









































                                    4-10
                                                                 EXAMPLES                                                                 EXAMPLES


   4.1.4  FORTRAN Output   4.1.4  FORTRAN Output

         
        !*** MODULE $defopr ***
         PARAMETER operand_size = '00000001'X
         PARAMETER max_arguments = '000000FF'X
         INTEGER*4 block_list_id
        !  assign values to context identifiers 
         PARAMETER ctx$k_bits = '00000000'X !  0
         PARAMETER ctx$k_bytes = '00000001'X !  1
         PARAMETER ctx$k_words = '00000002'X !  2
         PARAMETER ctx$k_longs = '00000003'X !  3
         PARAMETER ctx$k_quads = '00000004'X !  4
         PARAMETER ctx$k_octas = '00000005'X !  5
         STRUCTURE /operator/
             INTEGER*2 opr$w_id
             INTEGER*2 opr$w_count
             INTEGER*2 opr$w_size
             INTEGER*2 opr$w_last_use
             BYTE      opr$b_type
             BYTE      opr$b_number
             BYTE      opr$b_opcode
                 PARAMETER opr$S_variable_size = 1
                 PARAMETER opr$V_variable_size = 0
                 PARAMETER opr$S_size_units = 3
                 PARAMETER opr$V_size_units = 1
                 PARAMETER opr$S_offset_units = 3
                 PARAMETER opr$V_offset_units = 4
                 PARAMETER opr$S_alias = 1
                 PARAMETER opr$V_alias = 7
                 BYTE %FILL (1)
                 PARAMETER opr$S_by_desc_ = 1
                 PARAMETER opr$V_by_desc_ = 0
                 PARAMETER opr$S_by_immed_ = 1
                 PARAMETER opr$V_by_immed_ = 1
                 PARAMETER opr$S_by_ref_ = 1
                 PARAMETER opr$V_by_ref_ = 2
             INTEGER*2 opr$w_operand(0:254)
         BYTE %FILL (1)
         END STRUCTURE ! operator
         PARAMETER operator_size = '00000006'X
         PARAMETER tok$k_size = '0000040C'X !  token size
         STRUCTURE /token/   !  filled in by LEX
             INTEGER*4 tok$l_token_id  !  token id
             INTEGER*4 tok$l_source_line  !  source line number of token
             INTEGER*4 tok$l_token_length  !  length of token string
             CHARACTER*1024 tok$t_token_string !  token string
         END STRUCTURE ! token
         RECORD /token/ token
         COMMON /token/ token
         
        !*** MODULE externals ***
        !  Get Job/Process Information system service 

                                    4-11
   EXAMPLES   EXAMPLES


         INTEGER*4 SYS$GETJPI
         EXTERNAL  SYS$GETJPI
         
        !*** MODULE more_examples IDENT V1.0 ***
        ! 
        !  CSR07 (+^o16) - Interrupt Summary 2 CSR
        !  Example of Union
        ! 
         PARAMETER sgp$m_fonterror = '00000001'X
         PARAMETER sgp$m_clipped = '00000002'X
         PARAMETER sgp$m_isum2_1 = '0000FFFC'X
         STRUCTURE /isum2_word/
         UNION
             MAP
             INTEGER*2 isum2    !  InterruptSummary2CSR
             END MAP
             MAP
                 PARAMETER sgp$S_fonterror = 1
                 PARAMETER sgp$V_fonterror = 0  !  FontError
                 PARAMETER sgp$S_clipped = 1
                 PARAMETER sgp$V_clipped = 1  !  Clipped
                 PARAMETER sgp$S_isum2_1 = 14
                 PARAMETER sgp$V_isum2_1 = 2
                 BYTE %FILL (2)
             END MAP
         END UNION
         END STRUCTURE ! isum2_word
        ! 
        !  an example with one of every data type
        ! 
         PARAMETER sdl$m_b1 = '00000001'X
         PARAMETER sdl$m_b2 = '00000006'X
         PARAMETER sdl$m_b3 = '00000038'X
         STRUCTURE /one_of_each/   !  show all data types
             UNION
                 MAP
                     BYTE      sdl$b_one   !  byte datatype;
                     INTEGER*2 sdl$w_two   !  word datatype;
                     INTEGER*4 sdl$l_three   !  a longword datatype
                     INTEGER*4 sdl$q_four(2)   !  a quadword datatype
                     INTEGER*4 sdl$o_five(4)   !  an octaword datatype
                 END MAP
                 MAP
                     BYTE      sdl$b_uone
                     INTEGER*2 sdl$w_utwo
                     INTEGER*4 sdl$l_uthree
                     INTEGER*4 sdl$q_ufour(2)
                     INTEGER*4 sdl$o_ufive(4)
                 END MAP
             END UNION
             REAL*4    sdl$f_f   !  single floating
             UNION
                 MAP

                                    4-12
                                                                 EXAMPLES                                                                 EXAMPLES


                 REAL*8    sdl$d_d   !  double floating
                 END MAP
                 MAP
                 REAL*8    sdl$g_g   !  grand floating
                 END MAP
             END UNION
             REAL*16   sdl$h_h   !  huge floating
             BYTE      sdl$p_dec(6)   !  packed decimal
                 PARAMETER sdl$S_b1 = 1
                 PARAMETER sdl$V_b1 = 0   !  one bit
                 PARAMETER sdl$S_b2 = 2
                 PARAMETER sdl$V_b2 = 1   !  two bits
                 PARAMETER sdl$S_b3 = 3
                 PARAMETER sdl$V_b3 = 3   !  three bits
             BYTE      sdl$b_truth   !  boolean
             CHARACTER*32 sdl$t_string  !  character string
             STRUCTURE /sdl$t_vstring/ sdl$t_vstring
                 INTEGER*2 LEN
                 CHARACTER*128 TXT
             END STRUCTURE
        !  character varying
             INTEGER*4 sdl$a_p1   !  pointer to longword
             INTEGER*4 sdl$a_p2   !  pointer to char string array
             INTEGER*4 sdl$a_p3   !  pointer to aggregate
             INTEGER*4 sdl$a_p4   !  untyped pointer
             INTEGER*4 sdl$a_p5(1:10)  !  array of pointers to an array
         BYTE %FILL (1)
         END STRUCTURE ! one_of_each
        !  Example of an implicit union with dimension
         STRUCTURE /fill_2/
         UNION
             MAP
             INTEGER*2 w_fid(1:3)
             END MAP
             MAP
                 INTEGER*2 tst$w_first
                 INTEGER*2 tst$w_second
                 INTEGER*2 tst$w_third
             END MAP
         END UNION
         END STRUCTURE ! fill_2













                                    4-13
   EXAMPLES   EXAMPLES


   4.1.5  MACRO-32 Output   4.1.5  MACRO-32 Output

         
         .MACRO $defopr,..EQU=<=>,..COL=<:>
        operand_size'..equ'1
        max_arguments'..equ'255
         .GLOBL block_list_id
        ; block_list_id'..equ'0
        ;  assign values to context identifiers 
        ctx$k_bits'..equ'0                      ;  0
        ctx$k_bytes'..equ'1                     ;  1
        ctx$k_words'..equ'2                     ;  2
        ctx$k_longs'..equ'3                     ;  3
        ctx$k_quads'..equ'4                     ;  4
        ctx$k_octas'..equ'5                     ;  5
        opr$S_operator'..equ'523
        operator'..equ'0
        opr$w_id'..equ'0
        opr$w_count'..equ'2
        opr$w_size'..equ'4
        opr$w_last_use'..equ'6
        opr$b_type'..equ'8
        opr$b_number'..equ'9
        opr$b_opcode'..equ'10
        opr$S_opbits'..equ'1
        opr$r_opbits'..equ'11
        opr$v_variable_size'..equ'0
        opr$S_size_units'..equ'3
        opr$v_size_units'..equ'1
        opr$S_offset_units'..equ'3
        opr$v_offset_units'..equ'4
        opr$v_alias'..equ'7
        opr$S_argbits'..equ'1
        opr$r_argbits'..equ'12
        opr$v_by_desc_'..equ'0
        opr$v_by_immed_'..equ'1
        opr$v_by_ref_'..equ'2
        opr$S_operand'..equ'510
        opr$w_operand'..equ'13
        operator_size'..equ'6
        tok$k_size'..equ'1036                   ;  token size
         .SAVE
         .PSECT token PIC,OVR,REL,GBL,SHR,NOEXE,RD,WRT,LONG
        token'..col' .blkb 1036
         .RESTORE
        tok$S_token'..equ'1036
        ; token'..equ'0                         ;  filled in by LEX
        tok$l_token_id'..equ'0                  ;  token id
        tok$l_source_line'..equ'4               ;  source line number of token
        tok$l_token_length'..equ'8              ;  length of token string
        tok$S_token_string'..equ'1024
        tok$t_token_string'..equ'12             ;  token string
         .ENDM

                                    4-14
                                                                 EXAMPLES                                                                 EXAMPLES


         
         .MACRO externals,..EQU=<=>,..COL=<:>
        ;  Get Job/Process Information system service 
        ; External entry SYS$GETJPI
         .ENDM
         
         .MACRO more_examples,..EQU=<=>,..COL=<:> ; IDENT V1.0
        ; 
        ;  CSR07 (+^o16) - Interrupt Summary 2 CSR
        ;  Example of Union
        ; 
        sgp$m_fonterror'..equ'1
        sgp$m_clipped'..equ'2
        sgp$m_isum2_1'..equ'65532
        S_isum2_word'..equ'2
        isum2_word'..equ'0
        isum2'..equ'0                           ;  InterruptSummary2CSR
        sgp$S_isum2_bits'..equ'2
        isum2_bits'..equ'0
        sgp$v_fonterror'..equ'0                 ;  FontError
        sgp$v_clipped'..equ'1                   ;  Clipped
        sgp$S_isum2_1'..equ'14
        sgp$v_isum2_1'..equ'2
        ; 
        ;  an example with one of every data type
        ; 
        sdl$m_b1'..equ'1
        sdl$m_b2'..equ'6
        sdl$m_b3'..equ'56
        sdl$S_one_of_each'..equ'317
        one_of_each'..equ'0                     ;  show all data types
        sdl$S_integer_types'..equ'31
        sdl$r_integer_types'..equ'0             ;  for fun, overlay signed and unsigned
        sdl$S_signed_types'..equ'31
        sdl$r_signed_types'..equ'0              ;  signed datatypes
        sdl$b_one'..equ'0                       ;  byte datatype;
        sdl$w_two'..equ'1                       ;  word datatype;
        sdl$l_three'..equ'3                     ;  a longword datatype
        sdl$S_four'..equ'8
        sdl$q_four'..equ'7                      ;  a quadword datatype
        sdl$S_five'..equ'16
        sdl$o_five'..equ'15                     ;  an octaword datatype
        sdl$S_unsigned_types'..equ'31
        sdl$r_unsigned_types'..equ'0            ;  unsigned data types
        sdl$b_uone'..equ'0
        sdl$w_utwo'..equ'1
        sdl$l_uthree'..equ'3
        sdl$S_ufour'..equ'8
        sdl$q_ufour'..equ'7
        sdl$S_ufive'..equ'16
        sdl$o_ufive'..equ'15
        sdl$f_f'..equ'31                        ;  single floating
        sdl$S_dg'..equ'40

                                    4-15
   EXAMPLES   EXAMPLES


        sdl$r_dg'..equ'35                       ;  good place for a union array
        sdl$S_d'..equ'8
        sdl$d_d'..equ'35                        ;  double floating
        sdl$S_g'..equ'8
        sdl$g_g'..equ'35                        ;  grand floating
        sdl$S_h'..equ'16
        sdl$h_h'..equ'75                        ;  huge floating
        sdl$S_dec'..equ'6
        sdl$p_dec'..equ'91                      ;  packed decimal
        sdl$S_some_bits'..equ'1
        sdl$r_some_bits'..equ'97
        sdl$v_b1'..equ'0                        ;  one bit
        sdl$S_b2'..equ'2
        sdl$v_b2'..equ'1                        ;  two bits
        sdl$S_b3'..equ'3
        sdl$v_b3'..equ'3                        ;  three bits
        sdl$b_truth'..equ'98                    ;  boolean
        sdl$S_string'..equ'32
        sdl$t_string'..equ'99                   ;  character string
        sdl$S_vstring'..equ'130
        sdl$t_vstring'..equ'131                 ;  character varying
        sdl$a_p1'..equ'261                      ;  pointer to longword
        sdl$a_p2'..equ'265                      ;  pointer to char string array
        sdl$a_p3'..equ'269                      ;  pointer to aggregate
        sdl$a_p4'..equ'273                      ;  untyped pointer
        sdl$S_p5'..equ'40
        sdl$a_p5'..equ'277                      ;  array of pointers to an array
        ;  Example of an implicit union with dimension
        tst$S_fid'..equ'6
        w_fid'..equ'0
        tst$w_first'..equ'0
        tst$w_second'..equ'2
        tst$w_third'..equ'4
         .ENDM




















                                    4-16
                                                                 EXAMPLES                                                                 EXAMPLES


   4.1.6  PL/I Output   4.1.6  PL/I Output

         
        /*** MODULE $defopr ***/
        %REPLACE operand_size BY 1;
        %REPLACE max_arguments BY 255;
        DCL block_list_id pointer GLOBALREF ;
        /* assign values to context identifiers                                     */
        %REPLACE ctx$k_bits BY 0;               /* 0                                */
        %REPLACE ctx$k_bytes BY 1;              /* 1                                */
        %REPLACE ctx$k_words BY 2;              /* 2                                */
        %REPLACE ctx$k_longs BY 3;              /* 3                                */
        %REPLACE ctx$k_quads BY 4;              /* 4                                */
        %REPLACE ctx$k_octas BY 5;              /* 5                                */
         
        %REPLACE opr$s_operator BY 523;
        DCL 1 operator  BASED ,
             2 opr$w_id fixed binary(15),
             2 opr$w_count fixed binary(15),
             2 opr$w_size fixed binary(15),
             2 opr$w_last_use fixed binary(15),
             2 opr$b_type bit(8) aligned,
             2 opr$b_number bit(8) aligned,
             2 opr$b_opcode bit(8) aligned,
             2 opr$r_opbits ,
              3 opr$v_variable_size bit(1),
              3 opr$v_size_units bit(3),
              3 opr$v_offset_units bit(3),
              3 opr$v_alias bit(1),
             2 opr$r_argbits ,
              3 opr$v_by_desc_ bit(1),
              3 opr$v_by_immed_ bit(1),
              3 opr$v_by_ref_ bit(1),
              3 opr$v_fill_0 bit(5),
             2 opr$w_operand (0:254) fixed binary(15);
        %REPLACE operator_size BY 6;
        %REPLACE tok$k_size BY 1036;            /* token size                       */
         
        %REPLACE tok$s_token BY 1036;
        DCL 1 token  STATIC EXTERNAL ,          /* filled in by LEX                 */
             2 tok$l_token_id fixed binary(31), /* token id                         */
             2 tok$l_source_line fixed binary(31), /* source line number of token   */
             2 tok$l_token_length fixed binary(31), /* length of token string       */
             2 tok$t_token_string character(1024); /* token string                  */
         
        /*** MODULE externals ***/
        /* Get Job/Process Information system service                               */
        DCL SYS$GETJPI ENTRY (
         bit(32) aligned VALUE ,
         bit(32) aligned,
         character(*),
         any,
         bit(64) aligned,

                                    4-17
   EXAMPLES   EXAMPLES


         pointer,
         bit(32) aligned VALUE 
         )
         RETURNS (fixed binary(31));
         
        /*** MODULE more_examples IDENT V1.0 ***/
        /*                                                                          */
        /* CSR07 (+^o16) - Interrupt Summary 2 CSR                                  */
        /* Example of Union                                                         */
        /*                                                                          */
        %REPLACE sgp$m_fonterror BY '10000000000000000000000000000000'b;
        %REPLACE sgp$m_clipped BY '01000000000000000000000000000000'b;
        %REPLACE sgp$m_isum2_1 BY '00111111111111110000000000000000'b;
         
        %REPLACE s_isum2_word BY 2;
        DCL 1 isum2_word union BASED ,
             2 isum2 bit(16) aligned,           /* InterruptSummary2CSR             */
             2 isum2_bits ,
              3 sgp$v_fonterror bit(1),         /* FontError                        */
              3 sgp$v_clipped bit(1),           /* Clipped                          */
              3 sgp$v_isum2_1 bit(14);
        /*                                                                          */
        /* an example with one of every data type                                   */
        /*                                                                          */
        %REPLACE sdl$m_b1 BY '10000000000000000000000000000000'b;
        %REPLACE sdl$m_b2 BY '01100000000000000000000000000000'b;
        %REPLACE sdl$m_b3 BY '00011100000000000000000000000000'b;
         
        %REPLACE sdl$s_one_of_each BY 317;
        DCL 1 one_of_each  BASED ,              /* show all data types              */
             2 sdl$r_integer_types union,       /* for fun, overlay signed and unsigned */
              3 sdl$r_signed_types ,            /* signed datatypes                 */
               4 sdl$b_one fixed binary(7),     /* byte datatype;                   */
               4 sdl$w_two fixed binary(15),    /* word datatype;                   */
               4 sdl$l_three fixed binary(31),  /* a longword datatype              */
               4 sdl$q_four bit (64) aligned,   /* a quadword datatype              */
               4 sdl$o_five bit (128) aligned,  /* an octaword datatype             */
              3 sdl$r_unsigned_types ,          /* unsigned data types              */
               4 sdl$b_uone bit(8) aligned,
               4 sdl$w_utwo bit(16) aligned,
               4 sdl$l_uthree bit(32) aligned,
               4 sdl$q_ufour bit(64) aligned,
               4 sdl$o_ufive bit(128) aligned,
             2 sdl$f_f float binary(24),        /* single floating                  */
             2 sdl$r_dg (0:4) union,            /* good place for a union array     */
              3 sdl$d_d float binary(53),       /* double floating                  */
              3 sdl$g_g float binary(53),       /* grand floating                   */
             2 sdl$h_h float binary(113),       /* huge floating                    */
             2 sdl$p_dec fixed decimal(10,5),   /* packed decimal                   */
             2 sdl$r_some_bits ,
              3 sdl$v_b1 bit(1),                /* one bit                          */
              3 sdl$v_b2 bit(2),                /* two bits                         */
              3 sdl$v_b3 bit(3),                /* three bits                       */

                                    4-18
                                                                 EXAMPLES                                                                 EXAMPLES


              3 sdl$v_fill_1 bit(2),
             2 sdl$b_truth bit(1) aligned,      /* boolean                          */
             2 sdl$t_string character(32),      /* character string                 */
             2 sdl$t_vstring character(128) VARYING , /* character varying          */
             2 sdl$a_p1 pointer,                /* pointer to longword              */
             2 sdl$a_p2 pointer,                /* pointer to char string array     */
             2 sdl$a_p3 pointer,                /* pointer to aggregate             */
             2 sdl$a_p4 pointer,                /* untyped pointer                  */
             2 sdl$a_p5 (1:10) pointer;         /* array of pointers to an array    */
        /* Example of an implicit union with dimension                              */
         
        %REPLACE tst$s_fill_2 BY 6;
        DCL 1 fill_2 union BASED ,
             2 w_fid (1:3) fixed binary(15),
             2 tst$r_fill_3 ,
              3 tst$w_first fixed binary(15),
              3 tst$w_second fixed binary(15),
              3 tst$w_third fixed binary(15);




































                                    4-19
   EXAMPLES   EXAMPLES


   4.1.7  PASCAL Output   4.1.7  PASCAL Output

         
        MODULE SDLEXAM ;
         
        [HIDDEN] TYPE (**** Pre-declared data types ****)
         $BYTE = [BYTE] -128..127;
         $WORD = [WORD] -32768..32767;
         $QUAD = [QUAD,UNSAFE] RECORD
          L0:UNSIGNED; L1:INTEGER; END;
         $OCTA = [OCTA,UNSAFE] RECORD
          L0,L1,L2:UNSIGNED; L3:INTEGER; END;
         $UBYTE = [BYTE] 0..255;
         $UWORD = [WORD] 0..65535;
         $UQUAD = [QUAD,UNSAFE] RECORD
          L0,L1:UNSIGNED; END;
         $UOCTA = [OCTA,UNSAFE] RECORD
          L0,L1,L2,L3:UNSIGNED; END;
         $PACKED_DEC = [BIT(4),UNSAFE] 0..15;
         $DEFTYP = [UNSAFE] INTEGER;
         $DEFPTR = [UNSAFE] ^$DEFTYP;
         $BOOL = [BIT(1),UNSAFE] BOOLEAN;
         $BIT2 = [BIT(2),UNSAFE] 0..3;
         $BIT3 = [BIT(3),UNSAFE] 0..7;
         $BIT4 = [BIT(4),UNSAFE] 0..15;
         $BIT5 = [BIT(5),UNSAFE] 0..31;
         $BIT6 = [BIT(6),UNSAFE] 0..63;
         $BIT7 = [BIT(7),UNSAFE] 0..127;
         $BIT8 = [BIT(8),UNSAFE] 0..255;
         $BIT9 = [BIT(9),UNSAFE] 0..511;
         $BIT10 = [BIT(10),UNSAFE] 0..1023;
         $BIT11 = [BIT(11),UNSAFE] 0..2047;
         $BIT12 = [BIT(12),UNSAFE] 0..4095;
         $BIT13 = [BIT(13),UNSAFE] 0..8191;
         $BIT14 = [BIT(14),UNSAFE] 0..16383;
         $BIT15 = [BIT(15),UNSAFE] 0..32767;
         $BIT16 = [BIT(16),UNSAFE] 0..65535;
         $BIT17 = [BIT(17),UNSAFE] 0..131071;
         $BIT18 = [BIT(18),UNSAFE] 0..262143;
         $BIT19 = [BIT(19),UNSAFE] 0..524287;
         $BIT20 = [BIT(20),UNSAFE] 0..1048575;
         $BIT21 = [BIT(21),UNSAFE] 0..2097151;
         $BIT22 = [BIT(22),UNSAFE] 0..4194303;
         $BIT23 = [BIT(23),UNSAFE] 0..8388607;
         $BIT24 = [BIT(24),UNSAFE] 0..16777215;
         $BIT25 = [BIT(25),UNSAFE] 0..33554431;
         $BIT26 = [BIT(26),UNSAFE] 0..67108863;
         $BIT27 = [BIT(27),UNSAFE] 0..134217727;
         $BIT28 = [BIT(28),UNSAFE] 0..268435455;
         $BIT29 = [BIT(29),UNSAFE] 0..536870911;
         $BIT30 = [BIT(30),UNSAFE] 0..1073741823;
         $BIT31 = [BIT(31),UNSAFE] 0..2147483647;
         $BIT32 = [BIT(32),UNSAFE] UNSIGNED;

                                    4-20
                                                                 EXAMPLES                                                                 EXAMPLES


         
        (*** MODULE $defopr ***)
         
        CONST operand_size = 1;
         max_arguments = 255;
         
        VAR block_list_id :[EXTERNAL] $DEFPTR;
         
        (* assign values to context identifiers                                     *)
         
        CONST ctx$k_bits = 0;                 (* 0                                *)
         ctx$k_bytes = 1;                (* 1                                *)
         ctx$k_words = 2;                (* 2                                *)
         ctx$k_longs = 3;                (* 3                                *)
         ctx$k_quads = 4;                (* 4                                *)
         ctx$k_octas = 5;                (* 5                                *)
         
        TYPE operator = RECORD CASE INTEGER OF
         1: (opr$w_id : $WORD;
             opr$w_count : $WORD;
             opr$w_size : $WORD;
             opr$w_last_use : $WORD;
             opr$b_type : $UBYTE;
             opr$b_number : $UBYTE;
             opr$b_opcode : $UBYTE;
             opr$r_opbits : [BYTE(1)] RECORD END;
             opr$r_argbits : [BYTE(1)] RECORD END;
             opr$w_operand : ARRAY [0..254] OF $WORD;
             );
         2: (opr$v_variable_size : [POS(88)] $BOOL;
             opr$v_size_units : [POS(89)] $BIT3;
             opr$v_offset_units : [POS(92)] $BIT3;
             opr$v_alias : [POS(95)] $BOOL;
             opr$v_by_desc_ : [POS(96)] $BOOL;
             opr$v_by_immed_ : [POS(97)] $BOOL;
             opr$v_by_ref_ : [POS(98)] $BOOL;
             )
         END;
         
        CONST operator_size = 6;
         tok$k_size = 1036;              (* token size                       *)
         
        VAR token : RECORD                  (* filled in by LEX                 *)
             tok$l_token_id : INTEGER;   (* token id                         *)
             tok$l_source_line : INTEGER; (* source line number of token     *)
             tok$l_token_length : INTEGER; (* length of token string         *)
             tok$t_token_string : PACKED ARRAY [1..1024] OF CHAR; (* token string *)
         END;
         
        (*** MODULE externals ***)
         
        (* Get Job/Process Information system service                               *)
         

                                    4-21
   EXAMPLES   EXAMPLES


        [ASYNCHRONOUS,EXTERNAL(SYS$GETJPI)] FUNCTION $GETJPI (
         %IMMED EFN : UNSIGNED;
         VAR PIDADR : [VOLATILE]UNSIGNED;
         PRCNAM : [CLASS_S] PACKED ARRAY [$l3..$u3:INTEGER] OF CHAR;
         %REF ITMLST : [UNSAFE] ARRAY [$l4..$u4:INTEGER] OF $UBYTE;
         VAR IOSB : [VOLATILE]$UQUAD;
         %IMMED [UNBOUND, ASYNCHRONOUS] PROCEDURE ASTADR;
         %IMMED ASTPRM : UNSIGNED := %IMMED 0) : INTEGER; EXTERNAL;
         
        (*** MODULE more_examples IDENT V1.0 ***)
         
        [HIDDEN] TYPE (**** SDL-Generated type names ****)
         more_examples$$typ1 = [UNSAFE] ARRAY [1..2] OF PACKED ARRAY [1..512] OF CHAR;
         more_examples$$typ2 = [UNSAFE] ARRAY [1..8] OF $BYTE;
         
         
        (*                                                                          *)
        (* CSR07 (+^o16) - Interrupt Summary 2 CSR                                  *)
        (* Example of Union                                                         *)
        (*                                                                          *)
         
        CONST sgp$m_fonterror = 1;
         sgp$m_clipped = 2;
         sgp$m_isum2_1 = 65532;
         
        TYPE isum2_word = RECORD CASE INTEGER OF
         1: (isum2 : $UWORD;             (* InterruptSummary2CSR             *)
             );
         2: (isum2_bits : [BYTE(2)] RECORD END;
             );
         3: (sgp$v_fonterror : [POS(0)] $BOOL; (* FontError                  *)
             sgp$v_clipped : [POS(1)] $BOOL; (* Clipped                      *)
             sgp$v_isum2_1 : [POS(2)] $BIT14;
             )
         END;
         
        (*                                                                          *)
        (* an example with one of every data type                                   *)
        (*                                                                          *)
         
        CONST sdl$m_b1 = 1;
         sdl$m_b2 = 6;
         sdl$m_b3 = 56;
         
        TYPE one_of_each = RECORD CASE INTEGER OF (* show all data types         *)
         1: (sdl$r_integer_types : [BYTE(31)] RECORD END; (* for fun, overlay signed and unsigned *)
             sdl$f_f : SINGLE;           (* single floating                  *)
             sdl$r_dg : [BYTE(40)] RECORD END; (* good place for a union array *)
             sdl$h_h : QUADRUPLE;        (* huge floating                    *)
             sdl$p_dec : PACKED ARRAY [1..11] OF $PACKED_DEC; (* packed decimal *)
             sdl$r_some_bits : [BYTE(1)] RECORD END;
             sdl$b_truth : BOOLEAN;      (* boolean                          *)
             sdl$t_string : PACKED ARRAY [1..32] OF CHAR; (* character string *)

                                    4-22
                                                                 EXAMPLES                                                                 EXAMPLES


             sdl$t_vstring : VARYING [128] OF CHAR; (* character varying     *)
             sdl$a_p1 : ^INTEGER;        (* pointer to longword              *)
             sdl$a_p2 : ^more_examples$$typ1; (* pointer to char string array *)
             sdl$a_p3 : ^isum2_word ;    (* pointer to aggregate             *)
             sdl$a_p4 : $DEFPTR;         (* untyped pointer                  *)
             sdl$a_p5 : ARRAY [1..10] OF ^more_examples$$typ2; (* array of pointers to an array *)
             );
         2: (sdl$r_signed_types : [POS(0), BYTE(31)] RECORD END; (* signed datatypes *)
             sdl$d_d : DOUBLE;           (* double floating                  *)
             sdl$v_b1 : [POS(776)] $BOOL; (* one bit                         *)
             sdl$v_b2 : [POS(777)] $BIT2; (* two bits                        *)
             sdl$v_b3 : [POS(779)] $BIT3; (* three bits                      *)
             );
         3: (sdl$b_one : $BYTE;          (* byte datatype;                   *)
             sdl$w_two : $WORD;          (* word datatype;                   *)
             sdl$l_three : INTEGER;      (* a longword datatype              *)
             sdl$q_four : $QUAD;         (* a quadword datatype              *)
             sdl$o_five : $OCTA;         (* an octaword datatype             *)
             sdl$g_g : DOUBLE;           (* grand floating                   *)
             );
         4: (sdl$r_unsigned_types : [POS(0), BYTE(31)] RECORD END; (* unsigned data types *)
             );
         5: (sdl$b_uone : $UBYTE;
             sdl$w_utwo : $UWORD;
             sdl$l_uthree : UNSIGNED;
             sdl$q_ufour : $UQUAD;
             sdl$o_ufive : $UOCTA;
             )
         END;
         
        (* Example of an implicit union with dimension                              *)
         
        TYPE fill_2 = RECORD CASE INTEGER OF
         1: (w_fid : ARRAY [1..3] OF $WORD;
             );
         2: (tst$r_fill_3 : [BYTE(6)] RECORD END;
             );
         3: (tst$w_first : $WORD;
             tst$w_second : $WORD;
             tst$w_third : $WORD;
             )
         END;
         
        END.










                                    4-23
   EXAMPLES   EXAMPLES


   4.1.8  DATATRIEVE Output   4.1.8  DATATRIEVE Output

        ! NOTE: All dollar-signs ($) appearing in names have been replaced by hyphens (-)
         
        ! *** MODULE $defopr ***
        ! operand_size=1
        ! max_arguments=255
         
        DEFINE RECORD block_list_id_RECORD USING 
         1 block_list_id USAGE IS LONG. ;
        ! assign values to context identifiers 
        ! ctx$k_bits=0                          ! 0
        ! ctx$k_bytes=1                         ! 1
        ! ctx$k_words=2                         ! 2
        ! ctx$k_longs=3                         ! 3
        ! ctx$k_quads=4                         ! 4
        ! ctx$k_octas=5                         ! 5
         
        DEFINE RECORD operator_RECORD USING 
         1 operator .
          2 opr-w_id USAGE IS WORD.
          2 opr-w_count USAGE IS WORD.
          2 opr-w_size USAGE IS WORD.
          2 opr-w_last_use USAGE IS WORD.
          2 opr-b_type USAGE IS BYTE.
          2 opr-b_number USAGE IS BYTE.
          2 opr-b_opcode USAGE IS BYTE.
          2 opr-r_opbits USAGE IS BYTE .
        !    opr$v_variable_size BIT 0:1
        !    opr$v_size_units BIT 1:3
        !    opr$v_offset_units BIT 4:3
        !    opr$v_alias BIT 7:1
          2 opr-r_argbits USAGE IS BYTE .
        !    opr$v_by_desc_ BIT 0:1
        !    opr$v_by_immed_ BIT 1:1
        !    opr$v_by_ref_ BIT 2:1
        !    opr$v_fill_0 BIT 3:5
          2 opr-w_operand USAGE IS WORD OCCURS 255 TIMES . ;
        ! operator_size=6
        ! tok$k_size=1036                       ! token size
         
        DEFINE RECORD token_RECORD USING 
         1 token .                              ! filled in by LEX
          2 tok-l_token_id USAGE IS LONG.       ! token id
          2 tok-l_source_line USAGE IS LONG.    ! source line number of token
          2 tok-l_token_length USAGE IS LONG.   ! length of token string
          2 tok-t_token_string PIC X(1024). ;   ! token string
         
        ! *** MODULE externals ***
        ! Get Job/Process Information system service 
        ! SYS$GETJPI ENTRY 
         
        ! *** MODULE more_examples IDENT V1.0 ***

                                    4-24
                                                                 EXAMPLES                                                                 EXAMPLES


        !
        ! CSR07 (+^o16) - Interrupt Summary 2 CSR
        ! Example of Union
        !
        ! sgp$m_fonterror=1
        ! sgp$m_clipped=2
        ! sgp$m_isum2_1=65532
         
        DEFINE RECORD isum2_word_RECORD USING 
         1 isum2_word .
          2 isum2 USAGE IS WORD.                ! InterruptSummary2CSR
          2 isum2_bits REDEFINES isum2 USAGE IS WORD .
        !    sgp$v_fonterror BIT 0:1            !  FontError
        !    sgp$v_clipped BIT 1:1              !  Clipped
        !    sgp$v_isum2_1 BIT 2:14
        ;
        !
        ! an example with one of every data type
        !
        ! sdl$m_b1=1
        ! sdl$m_b2=6
        ! sdl$m_b3=56
         
        DEFINE RECORD one_of_each_RECORD USING 
         1 one_of_each .                        ! show all data types
          2 sdl-r_integer_types .               ! for fun, overlay signed and unsigned
           3 sdl-r_signed_types .               ! signed datatypes
            4 sdl-b_one USAGE IS BYTE.          ! byte datatype;
            4 sdl-w_two USAGE IS WORD.          ! word datatype;
            4 sdl-l_three USAGE IS LONG.        ! a longword datatype
            4 sdl-q_four USAGE IS QUAD.         ! a quadword datatype
            4 sdl-o_five USAGE IS QUAD OCCURS 2 TIMES . ! an octaword datatype
           3 sdl-r_unsigned_types REDEFINES sdl-r_signed_types . ! unsigned data types
            4 sdl-b_uone USAGE IS BYTE.
            4 sdl-w_utwo USAGE IS WORD.
            4 sdl-l_uthree USAGE IS LONG.
            4 sdl-q_ufour USAGE IS QUAD.
            4 sdl-o_ufive USAGE IS QUAD OCCURS 2 TIMES .
          2 sdl-f_f USAGE IS REAL.              ! single floating
          2 sdl-r_dg  OCCURS 5 TIMES .          ! good place for a union array
           3 sdl-d_d USAGE IS DOUBLE.           ! double floating
           3 sdl-g_g REDEFINES sdl-d_d USAGE IS DOUBLE. ! grand floating
          2 sdl-h_h USAGE IS QUAD OCCURS 2 TIMES . ! huge floating
          2 sdl-p_dec USAGE IS PACKED PIC S9(5)V9(5). ! packed decimal
          2 sdl-r_some_bits USAGE IS BYTE .
        !    sdl$v_b1 BIT 0:1                   !  one bit
        !    sdl$v_b2 BIT 1:2                   !  two bits
        !    sdl$v_b3 BIT 3:3                   !  three bits
        !    sdl$v_fill_1 BIT 6:2
          2 sdl-b_truth USAGE IS BYTE.          ! boolean
          2 sdl-t_string PIC X(32).             ! character string
          2 sdl-t_vstring .
           3 STRING_LENGTH USAGE IS WORD.

                                    4-25
   EXAMPLES   EXAMPLES


           3 STRING_TEXT PIC X(128).            ! character varying
          2 sdl-a_p1 USAGE IS LONG.             ! pointer to longword
          2 sdl-a_p2 USAGE IS LONG.             ! pointer to char string array
          2 sdl-a_p3 USAGE IS LONG.             ! pointer to aggregate
          2 sdl-a_p4 USAGE IS LONG.             ! untyped pointer
          2 sdl-a_p5 USAGE IS LONG OCCURS 10 TIMES . ; ! array of pointers to an array
        ! Example of an implicit union with dimension
         
        DEFINE RECORD fill_2_RECORD USING 
         1 fill_2 .
          2 w_fid USAGE IS WORD OCCURS 3 TIMES .
          2 tst-r_fill_3 REDEFINES w_fid .
           3 tst-w_first USAGE IS WORD.
           3 tst-w_second USAGE IS WORD.
           3 tst-w_third USAGE IS WORD. ;







































                                    4-26
                                                                 EXAMPLES                                                                 EXAMPLES


   4.1.9  ELN Pascal Output   4.1.9  ELN Pascal Output

         
        {** MODULE $defopr **}
         
        CONST operand_size = 1;
         max_arguments = 255;
         
        VAR block_list_id : [EXTERNAL] ^ANYTYPE;
         
        { assign values to context identifiers                                      }
         
        CONST ctx$k_bits = 0;                 { 0                                 }
         ctx$k_bytes = 1;                { 1                                 }
         ctx$k_words = 2;                { 2                                 }
         ctx$k_longs = 3;                { 3                                 }
         ctx$k_quads = 4;                { 4                                 }
         ctx$k_octas = 5;                { 5                                 }
         
        TYPE operator = PACKED RECORD CASE INTEGER OF
         1 : (opr$w_id : [WORD] -32768..32767;
             opr$w_count : [WORD] -32768..32767;
             opr$w_size : [WORD] -32768..32767;
             opr$w_last_use : [WORD] -32768..32767;
             opr$b_type : [BYTE] 0..255;
             opr$b_number : [BYTE] 0..255;
             opr$b_opcode : [BYTE] 0..255;
             opr$r_opbits : BYTE_DATA(1);
             opr$r_argbits : BYTE_DATA(1);
             opr$w_operand : PACKED ARRAY[0..254] OF [WORD] -32768..32767;
             );
         2 : (opr$v_variable_size : [POS(88)] BOOLEAN;
             opr$v_size_units : [POS(89),BIT(3)] 0..7;
             opr$v_offset_units : [POS(92),BIT(3)] 0..7;
             opr$v_alias : [POS(95)] BOOLEAN;
             opr$v_by_desc_ : [POS(96)] BOOLEAN;
             opr$v_by_immed_ : [POS(97)] BOOLEAN;
             opr$v_by_ref_ : [POS(98)] BOOLEAN;
             )
         END;
         
        CONST operator_size = 6;
         tok$k_size = 1036;              { token size                        }
         
        VAR token : PACKED RECORD           { filled in by LEX                  }
             tok$l_token_id : INTEGER;   { token id                          }
             tok$l_source_line : INTEGER; { source line number of token      }
             tok$l_token_length : INTEGER; { length of token string          }
             tok$t_token_string : STRING(1024); { token string               }
         END;
         
        {** MODULE externals **}
         

                                    4-27
   EXAMPLES   EXAMPLES


        { Get Job/Process Information system service                                }
         
        FUNCTION $GETJPI(
         EFN : BYTE_DATA(4);
         VAR PIDADR : BYTE_DATA(4);
         PRCNAM : STRING(<$n3>);
         VAR ITMLST : ANYTYPE;
         VAR IOSB : BYTE_DATA(8);
         VAR ASTADR : ^ANYTYPE;
         ASTPRM : BYTE_DATA(4) := ZERO) : INTEGER; EXTERNAL;
         
        {** MODULE more_examples IDENT V1.0 **}
         
        TYPE {*** SDL-Generated type names ***}
         more_examples$$typ1 = PACKED ARRAY[1..2] OF STRING(512);
         more_examples$$byte = PACKED ARRAY[1..8] OF [BYTE] -128..127;
         
         
        {                                                                           }
        { CSR07 (+^o16) - Interrupt Summary 2 CSR                                   }
        { Example of Union                                                          }
        {                                                                           }
         
        CONST sgp$m_fonterror = %x1;
         sgp$m_clipped = %x2;
         sgp$m_isum2_1 = %xFFFC;
         
        TYPE isum2_word = PACKED RECORD CASE INTEGER OF
         1 : (isum2 : [WORD] 0..65535;   { InterruptSummary2CSR              }
             );
         2 : (isum2_bits : BYTE_DATA(2);
             );
         3 : (sgp$v_fonterror : [POS(0)] BOOLEAN; { FontError                }
             sgp$v_clipped : [POS(1)] BOOLEAN; { Clipped                     }
             sgp$v_isum2_1 : [POS(2),BIT(14)] 0..16383;
             )
         END;
         
        {                                                                           }
        { an example with one of every data type                                    }
        {                                                                           }
         
        CONST sdl$m_b1 = %x1;
         sdl$m_b2 = %x6;
         sdl$m_b3 = %x38;
         
        TYPE one_of_each = PACKED RECORD CASE INTEGER OF { show all data types   }
         1 : (sdl$r_integer_types : BYTE_DATA(31); { for fun, overlay signed and unsigned }
             sdl$f_f : REAL;             { single floating                   }
             sdl$r_dg : BYTE_DATA(40);   { good place for a union array      }
             sdl$h_h : BYTE_DATA(16);    { huge floating                     }
             sdl$p_dec : PACKED ARRAY[1..11] OF [BIT(4)] 0..15;; { packed decimal }
             sdl$r_some_bits : BYTE_DATA(1);

                                    4-28
                                                                 EXAMPLES                                                                 EXAMPLES


             sdl$b_truth : BOOLEAN;      { boolean                           }
             sdl$t_string : STRING(32);  { character string                  }
             sdl$t_vstring : VARYING_STRING(128); { character varying        }
             sdl$a_p1 : ^INTEGER;        { pointer to longword               }
             sdl$a_p2 : ^more_examples$$typ1; { pointer to char string array }
             sdl$a_p3 : ^isum2_word ;    { pointer to aggregate              }
             sdl$a_p4 : ^ANYTYPE;        { untyped pointer                   }
             sdl$a_p5 : PACKED ARRAY[1..10] OF ^more_examples$$byte; { array of pointers to an array }
             );
         2 : (sdl$r_signed_types : [POS(0)] BYTE_DATA(31); { signed datatypes }
             sdl$d_d : [POS(280)] DOUBLE; { double floating                  }
             sdl$v_b1 : [POS(776)] BOOLEAN; { one bit                        }
             sdl$v_b2 : [POS(777),BIT(2)] 0..3; { two bits                   }
             sdl$v_b3 : [POS(779),BIT(3)] 0..7; { three bits                 }
             );
         3 : (sdl$b_one : [POS(0),BYTE] -128..127; { byte datatype;          }
             sdl$w_two : [POS(8),WORD] -32768..32767; { word datatype;       }
             sdl$l_three : [POS(24)] INTEGER; { a longword datatype          }
             sdl$q_four : [POS(56)] LARGE_INTEGER; { a quadword datatype     }
             sdl$o_five : [POS(120)] BYTE_DATA(16); { an octaword datatype   }
             sdl$g_g : [POS(280)] DOUBLE; { grand floating                   }
             );
         4 : (sdl$r_unsigned_types : [POS(0)] BYTE_DATA(31); { unsigned data types }
             );
         5 : (sdl$b_uone : [POS(0),BYTE] 0..255;
             sdl$w_utwo : [POS(8),WORD] 0..65535;
             sdl$l_uthree : [POS(24)] BYTE_DATA(4);
             sdl$q_ufour : [POS(56)] BYTE_DATA(8);
             sdl$o_ufive : [POS(120)] BYTE_DATA(16);
             )
         END;
         
        { Example of an implicit union with dimension                               }
         
        TYPE fill_2 = PACKED RECORD CASE INTEGER OF
         1 : (w_fid : PACKED ARRAY[1..3] OF [WORD] -32768..32767;
             );
         2 : (tst$r_fill_3 : BYTE_DATA(6);
             );
         3 : (tst$w_first : [POS(0),WORD] -32768..32767;
             tst$w_second : [POS(16),WORD] -32768..32767;
             tst$w_third : [POS(32),WORD] -32768..32767;
             )
         END;










                                    4-29
   EXAMPLES   EXAMPLES


   4.1.10  Ada Output   4.1.10  Ada Output

         
        with SYSTEM; use SYSTEM;
        package SDLEXAM is
         
        --  module $defopr
         
            OPERAND_SIZE : constant := 1;
            MAX_ARGUMENTS : constant := 255;
            BLOCK_LIST_ID :ADDRESS;
            -- assign values to context identifiers 
         
            CTX_K_BITS  : constant := 0;   --  0
            CTX_K_BYTES  : constant := 1;   --  1
            CTX_K_WORDS  : constant := 2;   --  2
            CTX_K_LONGS  : constant := 3;   --  3
            CTX_K_QUADS  : constant := 4;   --  4
            CTX_K_OCTAS  : constant := 5;   --  5
         
            type OPR_OPBITS_TYPE is
         record
             VARIABLE_SIZE : BOOLEAN;
             SIZE_UNITS : UNSIGNED_3;
             OFFSET_UNITS : UNSIGNED_3;
             ALIAS : BOOLEAN;
         end record;
         
             for OPR_OPBITS_TYPE use 
          record
              VARIABLE_SIZE at 0 range 0 .. 0;
              SIZE_UNITS at 0 range 1 .. 3;
              OFFSET_UNITS at 0 range 4 .. 6;
              ALIAS at 0 range 7 .. 7;
          end record;
             for OPR_OPBITS_TYPE'SIZE use 8;
         
            OPR_OPBITS_TYPE_INIT : constant OPR_OPBITS_TYPE := 
             (VARIABLE_SIZE => FALSE,
             SIZE_UNITS => 0,
             OFFSET_UNITS => 0,
             ALIAS => FALSE);
         
            type OPR_ARGBITS_TYPE is
         record
             BY_DESC : BOOLEAN;
             BY_IMMED : BOOLEAN;
             BY_REF : BOOLEAN;
             FILLER_1 : UNSIGNED_5;
         end record;
         
             for OPR_ARGBITS_TYPE use 
          record

                                    4-30
                                                                 EXAMPLES                                                                 EXAMPLES


              BY_DESC at 0 range 0 .. 0;
              BY_IMMED at 0 range 1 .. 1;
              BY_REF at 0 range 2 .. 2;
              FILLER_1 at 0 range 3 .. 7;
          end record;
             for OPR_ARGBITS_TYPE'SIZE use 8;
         
            OPR_ARGBITS_TYPE_INIT : constant OPR_ARGBITS_TYPE := 
             (BY_DESC => FALSE,
             BY_IMMED => FALSE,
             BY_REF => FALSE,
             FILLER_1 => 0);
         
            type OPR_OPERATOR_TYPE is
         record
             ID  : SHORT_INTEGER;
             COUNT : SHORT_INTEGER;
             SIZE : SHORT_INTEGER;
             LAST_USE : SHORT_INTEGER;
             TYP  : UNSIGNED_BYTE;
             NUMBER : UNSIGNED_BYTE;
             OPCODE : UNSIGNED_BYTE;
             OPBITS : OPR_OPBITS_TYPE;
             ARGBITS : OPR_ARGBITS_TYPE;
             OPERAND : SHORT_INTEGER_ARRAY (0 .. 254);
         end record;
         
             for OPR_OPERATOR_TYPE use 
          record
              ID  at 0 range 0 .. 15;
              COUNT at 2 range 0 .. 15;
              SIZE at 4 range 0 .. 15;
              LAST_USE at 6 range 0 .. 15;
              TYP  at 8 range 0 .. 7;
              NUMBER at 9 range 0 .. 7;
              OPCODE at 10 range 0 .. 7;
              OPBITS at 11 range 0 .. 7;
              ARGBITS at 12 range 0 .. 7;
              OPERAND at 13 range 0 .. 4079;
          end record;
             for OPR_OPERATOR_TYPE'SIZE use 4184;
         
            OPR_OPERATOR_TYPE_INIT : constant OPR_OPERATOR_TYPE := 
             (ID  => 0,
             COUNT => 0,
             SIZE => 0,
             LAST_USE => 0,
             TYP  => 0,
             NUMBER => 0,
             OPCODE => 0,
             OPBITS => OPR_OPBITS_TYPE_INIT,
             ARGBITS => OPR_ARGBITS_TYPE_INIT,
             OPERAND => (others => 0));

                                    4-31
   EXAMPLES   EXAMPLES


         
            OPERATOR_SIZE : constant := 6;
            TOK_K_SIZE  : constant := 1036;   --  token size
         
            type TOK_TOKEN_TYPE is     --  filled in by LEX
         record
             TOKEN_ID : INTEGER;    --  token id
             SOURCE_LINE : INTEGER;    --  source line number of token
             TOKEN_LENGTH : INTEGER;   --  length of token string
             TOKEN_STRING : STRING(1 .. 1024);  --  token string
         end record;
         
             for TOK_TOKEN_TYPE use 
          record
              TOKEN_ID at 0 range 0 .. 31;
              SOURCE_LINE at 4 range 0 .. 31;
              TOKEN_LENGTH at 8 range 0 .. 31;
              TOKEN_STRING at 12 range 0 .. 8191;
          end record;
             for TOK_TOKEN_TYPE'SIZE use 8288;
         
            TOK_TOKEN_TYPE_INIT : constant TOK_TOKEN_TYPE := 
             (TOKEN_ID => 0,
             SOURCE_LINE => 0,
             TOKEN_LENGTH => 0,
             TOKEN_STRING => (others => ASCII.NUL));
         

         
        --  module externals
            -- Get Job/Process Information system service 
         
            procedure GETJPI (
         STATUS : out CONDVALU_TYPE;    -- return value
         EFN : in  EFNUM_TYPE;
         PIDADR : in out PROCID_TYPE;
         PRCNAM : in  PROCNAME_TYPE;
         ITMLST : in  ITEMLIST_TYPE;
         IOSB : out IOSB_TYPE;
         ASTADR : in  AST_HANDLER;
         ASTPRM : in  USERPARM_TYPE  := USERPARM_ZERO);
         
            pragma INTERFACE (EXTERNAL, GETJPI);
         
            pragma IMPORT_VALUED_PROCEDURE (GETJPI, "$GETJPI",
         (CONDVALU_TYPE, EFNUM_TYPE, PROCID_TYPE, PROCNAME_TYPE, ITEMLIST_TYPE, IOSB_TYPE, AST_HANDLER,
        USERPARM_TYPE),
         (VALUE, VALUE, REFERENCE, DESCRIPTOR(S), REFERENCE, REFERENCE, VALUE, VALUE));
         

         
        --  module more_examples IDENT V1.0
            --

                                    4-32
                                                                 EXAMPLES                                                                 EXAMPLES


            -- CSR07 (+^o16) - Interrupt Summary 2 CSR
            -- Example of Union
            --
         
            SGP_M_FONTERROR : constant := 16#00000001#;
            SGP_M_CLIPPED : constant := 16#00000002#;
            SGP_M_ISUM2_1 : constant := 16#0000FFFC#;
         
            type ISUM2_TYPE is      --  InterruptSummary2CSR
         record
             FONTERROR : BOOLEAN;    --  FontError
             CLIPPED : BOOLEAN;    --  Clipped
             ISUM2_1 : UNSIGNED_14;
         end record;
         
             for ISUM2_TYPE use 
          record
              FONTERROR at 0 range 0 .. 0;
              CLIPPED at 0 range 1 .. 1;
              ISUM2_1 at 0 range 2 .. 15;
          end record;
             for ISUM2_TYPE'SIZE use 16;
         
            ISUM2_TYPE_INIT : constant ISUM2_TYPE := 
             (FONTERROR => FALSE,
             CLIPPED => FALSE,
             ISUM2_1 => 0);
         
            --
            -- an example with one of every data type
            --
         
            SDL_M_B1  : constant := 16#00000001#;
            SDL_M_B2  : constant := 16#00000006#;
            SDL_M_B3  : constant := 16#00000038#;
         
            type SDL_UNSIGNED_TYPES_TYPE is    --  unsigned data types
         record
             UONE : UNSIGNED_BYTE;
             UTWO : UNSIGNED_WORD;
             UTHREE : UNSIGNED_LONGWORD;
             UFOUR : UNSIGNED_QUADWORD;
             UFIVE : UNSIGNED_LONGWORD_ARRAY(0 .. 3);
         end record;
         
             for SDL_UNSIGNED_TYPES_TYPE use 
          record
              UONE at 0 range 0 .. 7;
              UTWO at 1 range 0 .. 15;
              UTHREE at 3 range 0 .. 31;
              UFOUR at 7 range 0 .. 63;
              UFIVE at 15 range 0 .. 127;
          end record;

                                    4-33
   EXAMPLES   EXAMPLES


             for SDL_UNSIGNED_TYPES_TYPE'SIZE use 248;
         
            SDL_UNSIGNED_TYPES_TYPE_INIT : constant SDL_UNSIGNED_TYPES_TYPE := 
             (UONE => 0,
             UTWO => 0,
             UTHREE => 0,
             UFOUR => (0, 0),
             UFIVE => (0, 0, 0, 0));
         
            type SDL_INTEGER_TYPES_TYPE is    --  for fun, overlay signed and unsigned
         record
             ONE  : SHORT_SHORT_INTEGER;   --  byte datatype;
             TWO  : SHORT_INTEGER;   --  word datatype;
             THREE : INTEGER;    --  a longword datatype
             FOUR : UNSIGNED_QUADWORD;   --  a quadword datatype
             FIVE : UNSIGNED_LONGWORD_ARRAY(0 .. 3); --  an octaword datatype
         
             ----Component(s) below are defined as comments since they
             ----overlap other fields
             ----
             ----UNSIGNED_TYPES : SDL_UNSIGNED_TYPES_TYPE; --  unsigned data types
         
         end record;
         
             for SDL_INTEGER_TYPES_TYPE use 
          record
              ONE  at 0 range 0 .. 7;
              TWO  at 1 range 0 .. 15;
              THREE at 3 range 0 .. 31;
              FOUR at 7 range 0 .. 63;
              FIVE at 15 range 0 .. 127;
         
              ----Component representation spec(s) below are defined as
              ----comments since they overlap other fields
              ----
              ----UNSIGNED_TYPES at 0 range 0 .. 247;
         
          end record;
             for SDL_INTEGER_TYPES_TYPE'SIZE use 248;
         
            SDL_INTEGER_TYPES_TYPE_INIT : constant SDL_INTEGER_TYPES_TYPE := 
             (ONE => 0,
             TWO  => 0,
             THREE => 0,
             FOUR => (0, 0),
             FIVE => (0, 0, 0, 0));
         
            type SDL_SOME_BITS_TYPE is
         record
             B1  : BOOLEAN;    --  one bit
             B2  : UNSIGNED_2;    --  two bits
             B3  : UNSIGNED_3;    --  three bits
             FILLER_1 : UNSIGNED_2;

                                    4-34
                                                                 EXAMPLES                                                                 EXAMPLES


         end record;
         
             for SDL_SOME_BITS_TYPE use 
          record
              B1  at 0 range 0 .. 0;
              B2  at 0 range 1 .. 2;
              B3  at 0 range 3 .. 5;
              FILLER_1 at 0 range 6 .. 7;
          end record;
             for SDL_SOME_BITS_TYPE'SIZE use 8;
         
            SDL_SOME_BITS_TYPE_INIT : constant SDL_SOME_BITS_TYPE := 
             (B1  => FALSE,
             B2  => 0,
             B3  => 0,
             FILLER_1 => 0);
         
            type SDL_ONE_OF_EACH_TYPE is    --  show all data types
         record
             INTEGER_TYPES : SDL_INTEGER_TYPES_TYPE; --  for fun, overlay signed and unsigned
             F  : FLOAT;    --  single floating
             D  : D_FLOAT;    --  double floating
         
             ----Component(s) below are defined as comments since they
             ----overlap other fields
             ----
             ----G : G_FLOAT;    --  grand floating
         
             H  : LONG_LONG_FLOAT;   --  huge floating
        --***NYI:   (dec (one_of_each) ) Datatype:  NYI_PACKED_DECIMAL
             DEC  : NYI_PACKED_DECIMAL;   --  packed decimal
             SOME_BITS : SDL_SOME_BITS_TYPE;
             TRUTH : BOOLEAN;    --  boolean
             STRING : STRING(1 .. 32);   --  character string
             VSTRING_LENGTH  : UNSIGNED_WORD;
             VSTRING : STRING(1 .. 128);   --  character varying
             P1  : ADDRESS;    --  pointer to longword
             P2  : ADDRESS;    --  pointer to char string array
             P3  : ADDRESS;    --  pointer to aggregate
             P4  : ADDRESS;    --  untyped pointer
             P5  : ADDRESS_ARRAY (1 .. 10);  --  array of pointers to an array
         end record;
         
             for SDL_ONE_OF_EACH_TYPE use 
          record
              INTEGER_TYPES at 0 range 0 .. 247;
              F  at 31 range 0 .. 31;
              D  at 35 range 0 .. 63;
         
              ----Component representation spec(s) below are defined as
              ----comments since they overlap other fields
              ----
              ----G at 35 range 0 .. 63;

                                    4-35
   EXAMPLES   EXAMPLES


         
              H  at 75 range 0 .. 127;
              DEC  at 91 range 0 .. 47;
              SOME_BITS at 97 range 0 .. 7;
              TRUTH at 98 range 0 .. 7;
              STRING at 99 range 0 .. 255;
              VSTRING_LENGTH at 131 range 0 .. 15;
              VSTRING at 133 range 0 .. 1023;
              P1  at 261 range 0 .. 31;
              P2  at 265 range 0 .. 31;
              P3  at 269 range 0 .. 31;
              P4  at 273 range 0 .. 31;
              P5  at 277 range 0 .. 319;
          end record;
             for SDL_ONE_OF_EACH_TYPE'SIZE use 2536;
         
            SDL_ONE_OF_EACH_TYPE_INIT : constant SDL_ONE_OF_EACH_TYPE := 
             (
             INTEGER_TYPES => SDL_INTEGER_TYPES_TYPE_INIT,
             F  => 0.0,
             D  => 0.0,
             H  => 0.0,
        --***NYI:   (dec (one_of_each) ) Datatype:  NYI_PACKED_DECIMAL
             DEC  => NYI_PACKED_DECIMAL_ZERO,
             SOME_BITS => SDL_SOME_BITS_TYPE_INIT,
             TRUTH => FALSE,
             STRING => (others => ASCII.NUL),
             VSTRING_LENGTH  => 0,
             VSTRING => (others => ASCII.NUL),
             P1  => ADDRESS_ZERO,
             P2  => ADDRESS_ZERO,
             P3  => ADDRESS_ZERO,
             P4  => ADDRESS_ZERO,
             P5  => (others => ADDRESS_ZERO));
         
            -- Example of an implicit union with dimension
         
            type TST_FID_COMPONENT_TYPE is
         record
             FIRST : SHORT_INTEGER;
             SECOND : SHORT_INTEGER;
             THIRD : SHORT_INTEGER;
         end record;
         
             for TST_FID_COMPONENT_TYPE use 
          record
              FIRST at 0 range 0 .. 15;
              SECOND at 2 range 0 .. 15;
              THIRD at 4 range 0 .. 15;
          end record;
             for TST_FID_COMPONENT_TYPE'SIZE use 48;
         
            TST_FID_COMPONENT_TYPE_INIT : constant TST_FID_COMPONENT_TYPE := 

                                    4-36
                                                                 EXAMPLES                                                                 EXAMPLES


             (FIRST => 0,
             SECOND => 0,
             THIRD => 0);
         
            TYPE TST_FID_TYPE is
         ARRAY (1 .. 3) of TST_FID_COMPONENT_TYPE;
         
            TST_FID_TYPE_INIT : constant TST_FID_TYPE := 
         ( others => TST_FID_COMPONENT_TYPE_INIT);
         
        end SDLEXAM;











































                                    4-37












                                 APPENDIX A                                 APPENDIX A

                          SUMMARY OF SDL KEYWORDS                          SUMMARY OF SDL KEYWORDS




        Keyword        Use        Keyword        Use

        ADDRESS        Data type keyword

        AGGREGATE      Declaration of structure or union body

        ALIAS          Option of ENTRY declaration

        ANY            Parameter-passing data type keyword

        BASED          Storage class keyword

        BITFIELD       Data type keyword

        BOOLEAN        Data type keyword

        BYTE           Data type keyword

        CHARACTER      Data type keyword

        COMMON         Storage class keyword

        CONSTANT       Named constant declaration keyword

        D_FLOATING     Data type keyword

        DECIMAL        Data type keyword

        DEFAULT        Parameter description keyword

        DESCRIPTOR     Parameter-passing keyword option

        DIMENSION      Array declaration keyword for aggregates or items

        END            Delimiter for the end of an aggregate body

        END_MODULE     Delimiter for the end of a module

                                    A-1
   SUMMARY OF SDL KEYWORDS   SUMMARY OF SDL KEYWORDS


        ENTRY          Declares an entry constant

        EQUALS         Keyword in syntax of CONSTANT statement

        F_FLOATING     Data type keyword

        G_FLOATING     Data type keyword

        GLOBAL         Storage class keyword

        H_FLOATING     Data type keyword

        IDENT          Identification option for MODULE keyword

        IN             Parameter description keyword

        INCREMENT      Option of CONSTANT declaration

        ITEM           Declaration keyword

        LENGTH         Keyword for CHARACTER and BITFIELD declarations

        LINKAGE        Option of ENTRY declaration

        LONGWORD       Data type keyword

        MASK           Option for BITFIELD declaration

        MODULE         Declaration keyword

        NAMED          Parameter description keyword

        OCTAWORD       Data type keyword

        OPTIONAL       Parameter description keyword

        ORIGIN         Keyword option for aggregate declarations

        OUT            Parameter description keyword

        PARAMETER      Option of ENTRY declaration

        PRECISION      Keyword for DECIMAL declaration

        PREFIX         Naming keyword option

        QUADWORD       Data type keyword

        REF            Parameter description keyword

        RETURNS        Option of ENTRY declaration

        SIGNED         Option for BITFIELD declaration

                                    A-2
                                                  SUMMARY OF SDL KEYWORDS                                                  SUMMARY OF SDL KEYWORDS


        STRUCTURE      Aggregate or subaggregate declaration keyword

        TAG            Naming option keyword

        TYPENAME       Named datatype that is not an  SDL  keyword.  This
                       keyword is currently on applicable for Ada output.

        UNION          Aggregate or subaggregate declaration keyword

        UNSIGNED       Integer data type declaration option

        VALUE          Parameter-passing keyword option

        VARIABLE       Option for ENTRY declarations

        VARYING        Keyword option for CHARACTER declaration

        WORD           Data type keyword




































                                    A-3












                                 APPENDIX B                                 APPENDIX B

                  SDL ERROR MESSAGES AND ERROR CONDITIONS                  SDL ERROR MESSAGES AND ERROR CONDITIONS




   This appendix summarizes the SDL diagnostic  messages.   All  messages
   that  indicate errors in SDL syntax specify the line number in the SDL
   source file at which the error occurred.


   ABORT, Fatal internal error; unable to continue execution

        Fatal        Fatal An internal error has occurred.

        User Action:        User Action:  Please report the problem to Technical Languages.


   ADROBJBAS, Address object name must have based storage class

        Error        Error An address item is pointing to an  aggregate  that  is  not
        based.

        User Action:        User Action:  Change the storage class of the aggregate to based.


   DUPCONATT, Item name has duplicate or conflicting attributes

        Error        Error A declaration contains keywords that are not compatible.

        User Action:        User Action:  Verify the syntax of the SDL  declaration,  correct
        the declaration, and invoke SDL again.


   ERREXIT, Error exit

        Fatal        Fatal Previous errors prevent continuation.

        User Action:        User Action:  Correct the errors and invoke SDL again.


   INCDEFSTRUC, Incompletely defined structure


                                    B-1
   SDL ERROR MESSAGES AND ERROR CONDITIONS   SDL ERROR MESSAGES AND ERROR CONDITIONS


        Error        Error A structure name has been referenced before  the  structure
        has been completely defined.

        User Action:        User Action:  Remove the reference and invoke SDL again.


   INFILOPN, Unable to open input file file-spec

        Fatal        Fatal SDL cannot locate or open the SDL source file.

        User Action:        User Action:  Verify that you specified the  name  of  the  input
        file correctly.


   INTOVF, Integer overflow in expression

        Error        Error Evaluation of an SDL expression resulted in  a  value  that
        does not fit in a longword.

        User Action:        User Action:  Correct the expression.


   INVBITFLD, Bitfield is not an aggregate member

        Error        Error Bit fields must be members of aggregates.  They  cannot  be
        scalar items.

        User  Action:        User  Action:   Incorporate  the  BITFIELD  declaration   in   an
        aggregate.


   INVFLDSIZ, Item name has bit field or offset length greater than 32

        Error        Error SDL cannot generate bit  fields  larger  than  32  bits  or
        cannot generate the proper bit mask.

        User Action:        User Action:  Verify the BITFIELD declaration and correct it.  If
        the  BITFIELD  declaration  occurs  within  an  aggregate and you
        specify the MASK option, verify that the bit offset of the  start
        of  the  declaration  plus  the bit field size does not exceed 32
        bits.


                                                  ________   INVOUT, Invalid attributes for output language language

        Error        Error An SDL construct or data type is invalid for the  specified
        target language.

        User Action:        User Action:  Determine whether you specified the  data  type  or
        SDL  declaration  correctly,  or  whether  you  may be requesting
        language output that you do  not  require.   Either  correct  the
        declaration  or  reissue  the  SDL  command so that the indicated
        language output routine does not execute.

                                    B-2
                                  SDL ERROR MESSAGES AND ERROR CONDITIONS                                  SDL ERROR MESSAGES AND ERROR CONDITIONS


                                                   ________   INVPARMTYP, Invalid parameter type for language language

        Error        Error A parameter specification  is  illegal  for  the  specified
        language.

        User Action:        User Action:  Modify the parameter specification and  invoke  SDL
        again.


   INVREQPARAM,  Required  parameter  encountered   after   an   optional
        parameter

        Error        Error Required parameters must not follow optional parameters.

        User Action:        User Action:  Correct the error and invoke SDL again.


                                                               ________   INVSHRIMG, Shareable image not found for specified language language

        Error        Error  SDL  cannot  find  the  image  to  support  the  specified
        language.

        User Action:        User Action:  Verify that the language image is  located  in  the
        appropriate   area.   SDL  looks  for  the  image  in  SYS$SHARE.
        Language support images are of the form,  SDLlanguage.EXE,  where
        language  is  an  identifying  character string for the language.
        For example, the FORTRAN back end is  called  SDLFORTRA.EXE,  and
        the Macro back end is called SDLMACRO.EXE.


   LISFILOPN, Unable to open listing file file-spec

        Error        Error SDL cannot open the indicated listing file.

        User Action:        User Action:  Verify that you have write access to the  directory
        to which the SDL listing file is directed.


                                                      ____   MATCHEND, End name does not match declaration name name

        Warning        Warning The name specified on the  END_MODULE  or  END  delimiter
        does not match the most recent module name or aggregate name.

        User Action:        User Action:  Verify the spelling of the name  specified  on  the
        END or END_MODULE to see that all names match.  Check whether you
        have illegally  nested  MODULE  declarations.   This  is  only  a
        warning message, but may indicate an error.


   MULTDEFSYM, Multiply defined symbol

        Error        Error A structure contains a duplicate symbol name.


                                    B-3
   SDL ERROR MESSAGES AND ERROR CONDITIONS   SDL ERROR MESSAGES AND ERROR CONDITIONS


        User Action:        User Action:  Remove the duplicate name and invoke SDL again.


   NOOUTPUT, No language output produced

        Warning        Warning There were  too  many  errors,  or  fatal  errors,  which
        prevented SDL from generating any output files.

        User  Action:        User  Action:   Correct  the  errors  indicated  by  accompanying
        messages.


   NULLSTRUC, Null structure name has no members

        Error        Error An AGGREGATE or subaggregate declaration did not  have  any
        members.

        User  Action:        User  Action:   Verify  that  the   aggregate   or   subaggregate
        declaration is correctly positioned in the file.


   OUTFILOPN, Unable to open output file file-spec

        Error        Error SDL cannot locate or open an SDL output file.

        User Action:        User Action:  Verify that you specified the  name  of  the  input
        file correctly.


   SYMTABOVR, Symbol table overflow

        Fatal        Fatal SDL exceeded its symbol table space.

        User Action:        User Action:  Reduce the size or complexity  of  the  SDL  source
        file; if possible, split the file into several different files or
        modules.


   SYNTAXERR, Syntax error

        Error        Error The SDL translator detected a syntax error.   This  message
        is  accompanied  by  a  message  indicating the type of error and
        tells you what type of token or keyword SDL expected but did  not
        find.

        User Action:        User Action:  Determine the syntax error  from  the  accompanying
        message and correct it.


   UNDEFSYM, Undefined symbol name

        Error        Error A name preceded by a number sign (#) is not defined.


                                    B-4
                                  SDL ERROR MESSAGES AND ERROR CONDITIONS                                  SDL ERROR MESSAGES AND ERROR CONDITIONS


        User Action:        User Action:  Verify  that  the  local  symbol  name  is  spelled
        correctly  and  that  it  appears before its reference in the SDL
        source file.


   WARNEXIT, Warning exit

        Warning        Warning A warning message has been issued.

        User Action:        User Action:  Output can be compiled, but  you  should  be  aware
        that results may not be as expected.


   ZERODIV, Zero divide in expression

        Error        Error An expression specified in an SDL declaration resulted in a
        divide-by-zero exception condition.

        User Action:        User Action:  Verify the expression and correct it.


   ZEROLEN, Item name has 0 or negative length

        Warning        Warning A BITFIELD or CHARACTER declaration or a DIMENSION option
        specified a length of 0 or less.

        User Action:        User Action:  Correct the declaration.  If the  length  or  bound
        value  was  specified  using  an SDL expression, verify the local
        symbol values and the results of  arithmetic  operations  in  the
        expression, if any.
























                                    B-5












                                 APPENDIX C                                 APPENDIX C

                 GENERATING SDL OUTPUT FOR OTHER LANGUAGES                 GENERATING SDL OUTPUT FOR OTHER LANGUAGES




   SDL is designed so that it can be easily extended  to  produce  output
   for  other languages.  A common "front end" reads the SDL declarations
   from a source file and creates a tree describing the declarations  and
   their  relationships.   There is a separate shareable image "back end"
   for each language for which output is  to  be  generated.   After  SDL
   builds  the  tree  describing  the  data  definitions, it invokes each
   shareable image requested by the language options specified on the SDL
   command line.

   This appendix describes how to add a language to SDL, including:

        o  The requirements for coding a "back end"

        o  The procedure for building a version of SDL that  incorporates
           the new shareable image back end

        o  The structure of the SDL tree and explanations of each field



   C.1  REQUIREMENTS FOR WRITING A NEW SDL BACK END   C.1  REQUIREMENTS FOR WRITING A NEW SDL BACK END

   The SDL front end activates each shareable image  back  end  with  two
   arguments.   The  first  argument  is the filename to be opened by the
   back end.  The second argument is a  structure  called  SDL$_SHR_DATA.
   All  data  that  is  shared  between the front and back ends of SDL is
   passed in this structure.

   An SDL back end may be written  in  any  language,  although  PL/I  is
   advised.   Arguments  to  any  routine  described in this document are
   passed by reference.  The simplest way to write an output routine  for
   another  language  is  to  use the PL/I output routine supplied in the
   distribution  kit  as  a  model  or  template.   This   source   file,
   SDLPLI.PLI,  is  commented  extensively  to  help  you  understand the
   requirements for writing an output routine.  A copy of this program is
   included in Section C.4, "Sources."


                                    C-1
   GENERATING SDL OUTPUT FOR OTHER LANGUAGES   GENERATING SDL OUTPUT FOR OTHER LANGUAGES


   Some of the following routines  have  the  argument  SDL$_SHR_DATA  in
   common.   All of the data that is shared between the SDL front end and
   back end is contained in this structure, and is passed as an argument.



   C.1.1  The SDL$PUTLINE Routine   C.1.1  The SDL$PUTLINE Routine

   SDL$PUTLINE outputs all text to the current output  source  file.   It
   has the calling sequence:

        CALL SDL$PUTLINE (outfile,string,length)


   outfile

        The output file variable.

   string

        Address of the string containing the source text  to  be  output.
        The  buffer  can have a maximum length of 1024 characters, and is
        assumed to be a character-varying string.

   length

        The line length of the output file.  SDL$PUTLINE breaks the  text
        in  the input buffer into lines of the given length as it outputs
        them.



   C.1.2  Writing a Source File Header   C.1.2  Writing a Source File Header

   All SDL back ends write a header line (in the form of  a  comment)  to
   the  source file, identifying the source file as an SDL-generated file
   and giving the date and time that the file was created.

   To write the header  line,  the  back  end  can  invoke  the  function
   SDL$HEADER as follows:

        CALL SDL$HEADER
        (SDL$_SHR_DATA,begin-comment-char,end-comment-char)


   SDL$_SHR_DATA

        A shared data structure.

   begin-comment-char

        A  character-varying  string  that  gives  the  language-specific
        character(s) that begins a comment.  This string may be null.

                                    C-2
                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES


   end-comment-char

        A  character-varying  string  that  gives  the  language-specific
        character(s) that ends a comment.  This string may be null.

   SDL$HEADER outputs a  header  to  the  target  language  output  file,
   surrounded by the appropriate comment characters.



   C.1.3  Error Message Output   C.1.3  Error Message Output

   The SDL translator issues  diagnostic  messages  for  all  SDL  syntax
   errors,  name  mismatches,  and so on.  Any language back end may also
   write messages using the  routine  ERRMSG.   ERRMSG  has  the  calling
   sequence:

        CALL ERRMSG (SDL$_SHR_DATA,msg-id,source-line,language);


   SDL$_SHR_DATA

        A shared data structure.

   msg-id

        A longword message id denoting the  unique  message  number.   At
        present, only the following id is assigned:

             SDL$_INVOUT Invalid attributes for output language

   source-line

        The line number of the SDL source file  containing  the  line  in
        error.   You can specify the field NOD$L_SRCLINE from the current
        tree node for this parameter.

   language

        The language keyword for your language back end.

   Note that any language back end may also want to  output  comments  to
   the   target  source  file  to  indicate  potential  language-specific
   problems.



   C.2  BUILDING A NEW SDL BACK END   C.2  BUILDING A NEW SDL BACK END

   To build a new SDL back end with the following procedure, you must  be
   using SDL V2.0 or a later version.



                                    C-3
   GENERATING SDL OUTPUT FOR OTHER LANGUAGES   GENERATING SDL OUTPUT FOR OTHER LANGUAGES


        1.  Copy the following files from the current SDL kit area.

                 SDLBCKOBJ.OBS     -     object modules
                 *.IN              -     include files for PL/I sources
                 LNKBCKEND.OPT     -     linker options file
                 SUPPLANG.COM      -     linker command procedure
                 SDLTRNVEC.OBJ     -     required transfer vector

        2.  Create an object library using the following command:

                   ______________ _________ _____________                 $ LIBRARY/CREATE SDLBCKLIB SDLBCKOBJ.OBS

        3.  Define the logical name SDL$LIBRARY to be the area  that  you
            have placed the above files.

        4.  Compile your back end source file.

        5.  Define a logical name to point to the backend image that  you
            wish  sdl  to activate.  If the backend is SDLMYBCK.EXE, then
            define a logical name such as

                   ______ ________ _____________________________                 $ DEFINE SDLMYBCK disk$:[directory]SDLMYBCK.EXE

            where disk$:[directory] is the location of your back end.

        6.  Link your back end with the following command

                   _________ ________                 $ @SUPPLANG SDLMYBCK

            where SDLMYBCK is the name of your back  end  object  module.
            The  name  of  your  SDL  back end must begin with the string
            'SDL', and must not exceed nine  characters  in  length  (not
            including the file extension).

   To use your new SDL back end, invoke it with the following command:

          __________________        $ SDL/LANGUAGE=MYBCK

   SDL will attach the 'SDL' prefix to your language name and search  for
   the  image  in  SYS$SHARE  by  default.   If a logical name, SDLMYBCK,
   exists, SDL will attempt to activate the  image  pointed  to  by  that
   logical name.



   C.3  THE SDL TREE   C.3  THE SDL TREE

   The tree built by the SDL front end consists of  a  linked  series  of
   nodes.   The  fields  defined  in  the  general tree node are shown in
   Figure 1.  Figure 1 is followed by:




                                    C-4
                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES


        o  Descriptions of the fields in a general tree node

        o  Descriptions of the field contents for each type of node

        o  Descriptions of field contents for specific data types

   The node declaration is in the source file SDLNODEF.IN, a  PL/I  file.
   The  routine SDL$DUMP provides a tree dump for debugging purposes.  To
   use SDL$DUMP, specify the /DUMP[=filename] switch when  invoking  SDL.
   (If  no  file  name is given, the tree will be written to SYS$OUTPUT.)
   This will cause SDL to output the tree prior to calling any back ends.











































                                    C-5
   GENERATING SDL OUTPUT FOR OTHER LANGUAGES   GENERATING SDL OUTPUT FOR OTHER LANGUAGES



                   +-------------------------------+
                   |       nod$a_flink             |
                   +-------------------------------+
                   |       nod$a_blink             |
                   +-------------------------------+
                   |  b_byte |b_type |nod$w_size   |
                   +-------------------------------+
                   |       nod$a_parent            |
                   +-------------------------------+
                   |       nod$a_child             |
                   +-------------------------------+
                   |       nod$l_srcline           |
                   +-------------------------------+
                   |       nod$l_hidim             |
                   +-------------------------------+
                   |       nod$l_lodim             |
                   +-------------------------------+
                   |       nod$l_initial           |
                   +-------------------------------+
                   |nod$t_name (34 bytes char var) |
                   +-------------------------------+
                   |nod$t_prefix(32 bytes char var)|
                   +-------------------------------+
                   |nod$t_marker(32 bytes char var)|
                   +-------------------------------+
                   |nod$t_tag (32 bytes char var)  |
                   +-------------------------------+
                   |nod$t_naked (34 bytes char var)|
                   +-------------------------------+
                   |       nod$l_offset            |
                   +-------------------------------+
                   |       nod$l_fldsiz            |
                   +-------------------------------+
                   |unused bit(16) | nod$w_datatype|
                   +-------------------------------+
                   |       nod$l_flags             |
                   +-------------------------------+
                   |       nod$l_typeinfo          |
                   +-------------------------------+
                   |       nod$l_typeinfo2         |
                   +-------------------------------+
                   |       nod$a_comment           |
                   +-------------------------------+
                   |       nod$t_typename          |
                   |       (32 bytes char var)     |
                   +-------------------------------+


                    Figure 1: Format of an SDL Tree Node                    Figure 1: Format of an SDL Tree Node



                                    C-6
                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES



   C.3.1  General Format of Tree Nodes   C.3.1  General Format of Tree Nodes

   In a tree node, the first four longwords make up the header, and their
   fields  are  always filled in.  Use of the other fields depends on the
   type of node.  Unused fields are always zero filled.

        NOD$A_FLINK      Forward link pointer to the next node.

        NOD$A_BLINK      Backward link pointer to the previous node.

        NOD$W_SIZE       Node size in bytes.

        NOD$B_TYPE       The type of node. The node types  are  expressed
                         using   the   constants   listed   below  (these
                         constants are also defined in SDLNODEF.IN).

                              Constant            Meaning                              Constant            Meaning

                              NOD$K_ROOTNODE      Root node for the tree
                              NOD$K_COMMNODE      Comment node
                              NOD$K_CONSTNODE     Constant node
                              NOD$K_ENTRYNODE     External entry node
                              NOD$K_ITEMNODE      Aggregate   or   scalar
                              item node
                              NOD$K_MODULNODE     Module node
                              NOD$K_PARMNODE      Parameter node
                              NOD$K_OBJNODE       Object type node
                              NOD$K_HEADNODE      Head of a list of nodes

                         Each of these nodes and the field usage for each
                         is  described  in detail in Section C.3.2, "Node
                         Types and Definitions.")

        NOD$A_PARENT     If the node is an item node, this points to  the
                         containing  module  if  it  is  a  level 1 item;
                         otherwise, it points to the parent aggregate  of
                         an  aggregate member. If the node is a parameter
                         node, this points to the entry node. If it is an
                         object node, this points to the ADDRESS item. In
                         all other cases, it  points  to  the  containing
                         module.

        NOD$A_CHILD      If the node is an aggregate node, this points to
                         a  list of aggregate members. For an entry node,
                         it points to the parameter list.  For  a  module
                         node,  it  points to a list of the level 1 nodes
                         contained in the module. The node pointed to  is
                         the  head  node  of  the  list;  it has no other
                         information except  forward  and  backward  link

                                    C-7
   GENERATING SDL OUTPUT FOR OTHER LANGUAGES   GENERATING SDL OUTPUT FOR OTHER LANGUAGES


                         pointers to the list elements.

        NOD$L_SRCLINE    This is the number of the  SDL  source  line  on
                         which the declaration appears.

        NOD$L_HIDIM      If a node represents an array, this is the  high
                         bound of the array's subscripts.

        NOD$L_LODIM      If a node represents an array, this is  the  low
                         bound of the array's subscripts.

        NOD$T_NAME       The complete  name  of  the  output  identifier,
                         including prefix and tag, if any.

        NOD$T_PREFIX     A prefix with the item name.

        NOD$T_TAG        A character code usually used  to  indicate  the
                         data type or usage of the item it names.

        NOD$T_TYPENAME   The name of the predefined VMS datatype.

        NOD$T_NAKED      The identifier name, without the prefix and tag.
                         This  field is available for back ends that make
                         up their own symbols from the basic  name,  such
                         as  the  size constant used in BLISS to describe
                         the number of bytes in a field.

        NOD$L_OFFSET     The offset (in bytes) from the beginning of  the
                         level-1  aggregate.  If the item is a bit field,
                         then the NOD$L_OFFSET field corresponds  to  the
                         nearest relative byte offset.

        NOD$L_FLDSIZ     The size (in bytes) of the  item;  this  is  the
                         total  size,  including any dimensioning. If the
                         item is a bit field, this is the size in bits of
                         the item.

        NOD$W_DATATYPE   Specifies the data type of the item. Data  types
                         are expressed using the following constants:

                              Constant            Data Type                              Constant            Data Type

                              TYP$K_ADDRESS       Address or pointer*
                              TYP$K_BYTE          Byte integer
                              TYP$K_BOOLEAN       Boolean
                              TYP$K_CHAR          Character (byte)*
                              TYP$K_DECIMAL       Packed decimal*
                              TYP$K_DOUBLE        Double floating
                              TYP$K_FLOAT         F-floating
                              TYP$K_GRAND         G-floating
                              TYP$K_HUGE          H-floating
                              TYP$K_LONGWORD      Longword integer
                              TYP$K_OCTAWORD      Octaword integer

                                    C-8
                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES


                              TYP$K_QUADWORD      Quadword integer
                              TYP$K_VIELD         Bit field*
                              TYP$K_WORD          Word integer
                              TYP$K_STRUCTURE     Structure aggregate*
                              TYP$K_UNION         Union aggregate*
                              TYP$K_ANY           Any longword datatype*
                              TYP$K_ENTRY         An entry constant

                         An item with an  asterisk  (*)  above  indicates
                         that  additional  information is available about
                         the data item, as described  in  Section  C.3.3,
                         "Data Type Information."

        NOD$W_FLAGS      The following flags are defined:

                              Flag                Meaning                              Flag                Meaning

                              NOD$V_VALUE         Item is a value
                              NOD$V_MASK          Bitfield has a mask
                              NOD$V_UNSIGNED      Unsigned attribute was specified
                              NOD$V_COMMON        Storage class is COMMON
                              NOD$V_GLOBAL        Storage class is GLOBAL
                              NOD$V_VARYING       String is character varying
                              NOD$V_VARIABLE      Variable option is specified for
                                                  ENTRY declaration
                              NOD$V_BASED         Storage class is based
                              NOD$V_DESC          Parameter is passed by descriptor
                              NOD$V_DIMEN         Item is an array
                              NOD$V_IN            Item is an input parameter
                              NOD$V_OUT           Item is an output parameter
                              NOD$V_BOTTOM        Item is the last element in an aggregate
                              NOD$V_BOUND         A based aggregate is bound to a pointer by
                                                  a BASED pointer-name option
                              NOD$V_REF           Parameter is passed by reference
                              NOD$V_USER_FILL     Item is used as a filler
                              NOD$V_ALIAS         Item can be accessed by an alternate
                                                  internal name
                              NOD$V_DEFAULT       Default attribute was specified for
                                                  a parameter
                              NOD$V_VARDIM        '*' was specified in a dimension attribute
                              NOD$V_OPTIONAL      Optional attribute was specified for
                                                  a parameter
                              NOD$F_SIGNED        Signed attribute was specified
                              NOD$F_LINK          Entry expands with special call macro

        NOD$L_TYPEINFO   Contains  data  type-specific  or  node-specific
                         information.

        NOD$L_TYPEINFO2  Contains data type-specific information.

        NOD$A_TYPEINFO2  Contains data type-specific information.

        NOD$A_COMMENT    Points to a string of  comment  text  associated

                                    C-9
   GENERATING SDL OUTPUT FOR OTHER LANGUAGES   GENERATING SDL OUTPUT FOR OTHER LANGUAGES


                         with this node.



   C.3.2  Node Types and Definitions   C.3.2  Node Types and Definitions

   The next subsections describe valid fields in a  tree  node  for  each
   type of node.



   C.3.2.1  ROOT Nodes   C.3.2.1  ROOT Nodes

   If NOD$B_TYPE contains the constant NOD$K_ROOTNODE, the  node  is  the
   root  node  for  the  entire  tree.   The  external  pointer  variable
   TREE_ROOT points to this node.

   The forward and backward links point to a list of module nodes.

   No other fields are used.



   C.3.2.2  Comment Node   C.3.2.2  Comment Node

   A comment node indicates a comment.  The fields used in this  type  of
   node are:

        NOD$A_COMMENT     Points to a string of text

        NOD$A_PARENT      Points to the module

        NOD$L_SRCLINE     Gives the SDL source line number

   No other fields are used.



   C.3.2.3  Constant Nodes   C.3.2.3  Constant Nodes

   If NOD$B_TYPE contains the constant NOD$K_CONSTNODE,  the  node  is  a
   constant node and the following fields are defined:

        NOD$L_TYPEINFO     Gives the value of the constant.

        NOD$T_NAME         Gives the name of the constant.

        NOD$T_PREFIX       Gives the prefix of the name.

        NOD$T_TAG          Gives the tag character part of the name.

        NOD$A_PARENT       Points to the module.


                                    C-10
                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES


        NOD$L_SRCLINE      Gives the source line number in the SDL file.

        NOD$A_COMMENT      Points to a string of text that is  a  comment
                           associated with this node.

   No other fields are used.

   The following flag is used:

        NOD$M_MASK     Indicates constant is a bit mask.



   C.3.2.4  Entry Nodes   C.3.2.4  Entry Nodes

   If NOD$B_TYPE contains NOD$K_ENTRYNODE, the node is an external  entry
   node.  The following fields are defined:

        NOD$A_CHILD        Points to a list of parameter nodes,  if  any.
                           If  the  entry  has  no parameters, this field
                           contains 0.

        NOD$W_DATATYPE     Gives the data type of the return value if the
                           entry is a function; otherwise, it is 0.

                           The fields  NOD$W_FLAGS,  NOD$L_TYPEINFO,  and
                           NOD$L_TYPEINFO2    give   data   type-specific
                           information, as described  in  Section  C.3.3,
                           "Data  Type  Information,"  if  the entry is a
                           function.

        NOD$T_NAME         Is the name of the entry.

        NOD$A_PARENT       Points to the module.

        NOD$L_SRCLINE      Gives the source line number.

        NOD$A_COMMENT      Points to a string of text that is  a  comment
                           associated with this node.

        NOD$T_TYPENAME     The name of the predefined VMS datatype.

   No other fields are used.

   The following flag is used:

        NOD$M_VARIABLE     Indicates variable number of parameters.



   C.3.2.5  Item Nodes   C.3.2.5  Item Nodes



                                    C-11
   GENERATING SDL OUTPUT FOR OTHER LANGUAGES   GENERATING SDL OUTPUT FOR OTHER LANGUAGES


   If NOD$B_TYPE contains  NOD$K_ITEMNODE,  the  node  is  an  item  node
   describing an aggregate member or a scalar item.  The following fields
   are defined:

        NOD$A_CHILD      If the item is an aggregate, this  field  points
                         to a list of its members.

        NOD$A_PARENT     Points to the parent aggregate if this node is a
                         structure  member, or to the module if this node
                         is a level-1 item.

        NOD$L_HIDIM      Gives the high bound, if this node is an array.

        NOD$L_LODIM      Gives the low bound, if this node is an array.

        NOD$T_NAME       Gives the complete  name  of  the  aggregate  or
                         member.

        NOD$T_PREFIX     Gives the prefix of the name.

        NOD$T_TAG        Gives the tag character part of the name.

        NOD$T_NAKED      Gives the "naked" name of the item, without  the
                         prefix or tag.

        NOD$W_DATATYPE   Is the data type of the item.

        NOD$T_TYPENAME   The name of the predefined VMS datatype.

                         The  fields  NOD$W_FLAGS,  NOD$L_TYPEINFO,   and
                         NOD$L_TYPEINFO2    give    data    type-specific
                         information,  as  described  in  Section  C.3.3,
                         "Data Type Information."

        NOD$L_SRCLINE    Is the SDL source line number.

        NOD$L_OFFSET     Gives the offset in bytes from the beginning  of
                         a level-1 aggregate.

        NOD$L_FLDSIZ     Gives the size of the item. The size is given in
                         bytes  for all data types except bit fields; the
                         size of a bit field is given in bits.

        NOD$A_COMMENT    Points to a string of text  that  is  a  comment
                         associated with this node.

   No other fields are used.

   The following flags are used:

        NOD$M_BASED        Indicates that the storage class is BASED.

        NOD$M_COMMON       Indicates that the storage class is common.

                                    C-12
                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES


        NOD$M_GLOBAL       Indicates that the storage class is GLOBAL.

        NOD$M_DIMEN        Indicates that the item is an array.

        NOD$M_BOTTOM       Indicates that the item node is  the  last  or
                           "bottom" one in an aggregate.

        NOD$M_UNSIGNED     Indicates  that  an  unsigned  attribute   was
                           specified.

        NOD$M_SIGNED       Indicates  that   a   signed   attribute   was
                           specified.

        NOD$M_MASK         Generates a mask definition for the bit field.



   C.3.2.6  Module Nodes   C.3.2.6  Module Nodes

   If NOD$B_TYPE contains NOD$K_MODULNODE, the node  is  a  module  node.
   The following fields are defined:

        NOD$A_CHILD      Points to a list of declarations in this module.

        NOD$T_NAME       Is the name of the module.

        NOD$L_SRCLINE    Is the SDL source line number.

        NOD$A_COMMENT    Points to a string of text  that  is  a  comment
                         associated with this node.

        NOD$T_NAKED      Contains the ident string.

   No other fields are used.



   C.3.2.7  Parameter Nodes   C.3.2.7  Parameter Nodes

   If NOD$B_TYPE contains NOD$K_PARMNODE, the  node  describes  an  entry
   parameter.  The following fields are defined:

        NOD$A_PARENT       Points to the entry node for which  this  node
                           describes a parameter.

        NOD$W_DATATYPE     Is the data type of the parameter.

                           The fields  NOD$W_FLAGS,  NOD$L_TYPEINFO,  and
                           NOD$L_TYPEINFO2    give   data   type-specific
                           information, as described  in  Section  C.3.3,
                           "Data Type Information."

        NOD$L_HIDIM        Is the high bound, for a parameter that is  an

                                    C-13
   GENERATING SDL OUTPUT FOR OTHER LANGUAGES   GENERATING SDL OUTPUT FOR OTHER LANGUAGES


                           array.

        NOD$L_LODIM        Is the low bound, for a parameter that  is  an
                           array.

        NOD$L_INITIAL      Is the initial  value  given  with  a  default
                           attribute.

        NOD$A_CHILD        Points to a list of members, if the  parameter
                           is an aggregate.

        NOD$T_NAME         Is the parameter name.

        NOD$T_TYPENAME     The name of the predefined VMS datatype.

   No other fields are used.

   The following flags are used:

        NOD$M_VALUE        Indicates that  the  parameter  is  passed  by
                           value.

        NOD$M_REF          Indicates that  the  parameter  is  passed  by
                           reference.

        NOD$M_DESC         Indicates that  the  parameter  is  passed  by
                           descriptor.

        NOD$M_IN           Indicates an input parameter.

        NOD$M_OUT          Indicates an output parameter.

        NOD$M_DEFAULT      Indicates  that  the  default  attribute   was
                           specified for a parameter.

        NOD$M_OPTIONAL     Indicates  that  the  optional  attribute  was
                           specified for a parameter.

        NOD$M_VARDIM       Indicates  that  '*'  was   specified   in   a
                           dimension attribute.



   C.3.2.8  Object Nodes   C.3.2.8  Object Nodes

   If NOD$B_TYPE contains NOD$K_OBJNODE, then the node describes the type
   of  object  pointed  to  by an ADDRESS item.  The following fields are
   defined:

        NOD$W_DATATYPE     Is the data type of the item.




                                    C-14
                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES


                           The fields  NOD$W_FLAGS,  NOD$L_TYPEINFO,  and
                           NOD$L_TYPEINFO2    give   data   type-specific
                           information, as described  in  Section  C.3.3,
                           "Data Type Information."

                           If   the   datatype   is   TYP$K_ENTRY,   then
                           NOD$A_TYPEINFO2  points to an object node that
                           is exactly the same as an entry  node,  except
                           that no name field is supplied.

                           If   the   datatype   is    TYP$K_STRUCT    or
                           TYP$K_UNION, then NOD$T_NAME contains the name
                           of  the  previously  defined  aggregate   that
                           describes  the  type  of aggregate pointed to.
                           The field NOD$A_TYPEINFO2 gives the address of
                           the previously defined aggregate node.

        NOD$L_HIDIM        Gives the high bound, if the item is an array.

        NOD$L_LODIM        Gives the low bound, if the item is an array.

        NOD$A_PARENT       Points to the address item.

   No other fields are used.



   C.3.2.9  Head Nodes   C.3.2.9  Head Nodes

   If the field NOD$B_TYPE contains NOD$K_HEADNODE, the node is the  head
   of  a  list  of  nodes.   The  forward and backward links point to the
   beginning and end of the list.  No other fields are used.



   C.3.3  Data Type Information   C.3.3  Data Type Information

   The fields NOD$W_DATATYPE, NOD$T_TYPENAME and NOD$W_FLAGS provide data
   type  information about aggregates, members, and items.  The auxiliary
   fields   NOD$L_TYPEINFO   and   NOD$L_TYPEINFO2   provide   additional
   information for various data types, as described in this section.



   C.3.3.1  Integers   C.3.3.1  Integers

   For the data types BYTE, WORD, LONGWORD, QUADWORD, and  OCTAWORD,  the
   following flag may be used:

        NOD$M_UNSIGNED     Indicates an unsigned integer.

        NOD$M_SIGNED       Indicates a signed integer.


                                    C-15
   GENERATING SDL OUTPUT FOR OTHER LANGUAGES   GENERATING SDL OUTPUT FOR OTHER LANGUAGES


   C.3.3.2  Character Strings   C.3.3.2  Character Strings

   If NOD$W_DATATYPE contains TYP$K_CHAR, then the following  fields  are
   defined:

        NOD$L_TYPEINFO     Is the length of the character string.

        NOD$M_VARYING      If set, indicates a character-varying string.



   C.3.3.3  Packed Decimal   C.3.3.3  Packed Decimal

   If NOD$W_DATATYPE contains TYP$K_DECIMAL,  the  following  fields  are
   defined:

        NOD$L_TYPEINFO      The precision of the item.

        NOD$L_TYPEINFO2     The scale of the item.



   C.3.3.4  Bit Fields   C.3.3.4  Bit Fields

   If NOD$W_DATATYPE  contains  TYP$K_VIELD,  the  following  fields  are
   defined:

        NOD$L_TYPEINFO      Contains the length of the field.

        NOD$L_TYPEINFO2     Contains  the  bit  offset  of   the   field,
                            relative  to  the  byte  offset  contained in
                            NOD$L_OFFSET.

   The fields NOD$L_TYPEINFO2 and  NOD$L_OFFSET  together  specify  exact
   offset  of  the  bit field.  NOD$L_OFFSET is in the item node for this
   item or member.



   C.3.3.5  Boolean Data   C.3.3.5  Boolean Data

   If NOD$W_DATATYPE contains TYP$K_BOOLEAN, no other fields are used.



   C.3.3.6  Address Data   C.3.3.6  Address Data

   If NOD$W_DATATYPE contains TYP$K_ADDRESS, the following field is used:

        NOD$A_TYPEINFO2     Points to a list of object  nodes.  There  is
                            actually  only  one  object  node,  but it is
                            linked into a circular list  like  all  other
                            members of the tree.

                                    C-16
                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES


   C.3.3.7  Structure Aggregates   C.3.3.7  Structure Aggregates

   If NOD$W_DATATYPE contains TYP$K_STRUCTURE, the following  fields  are
   used:

        NOD$A_CHILD         Points to a list of member elements.

        NOD$L_TYPEINFO      Gives the origin of the structure.

        NOD$A_TYPEINFO2     Points to a pointer item node that  is  bound
                            to   this  aggregate,  if  any,  by  a  BASED
                            pointer-name option.

   The following flag is used:

        NOD$M_BOUND     A based aggregate is bound  to  a  pointer  by  a
                        BASED pointer-name option.



   C.3.3.8  Union Aggregates   C.3.3.8  Union Aggregates

   If NOD$W_DATATYPE  contains  TYP$K_UNION,  the  following  fields  are
   defined:

        NOD$A_CHILD         Points to a list of member elements.

        NOD$L_TYPEINFO      Gives the origin of the union.

        NOD$A_TYPEINFO2     Points to a pointer item node that  is  bound
                            to   this  aggregate,  if  any,  by  a  BASED
                            pointer-name option.

   The following flag is used:

        NOD$M_BOUND     A based aggregate is bound  to  a  pointer  by  a
                        BASED pointer-name option.



   C.3.3.9  Parameter Passing Attributes   C.3.3.9  Parameter Passing Attributes

   If the node is a parameter, then NOD$W_DATATYPE may contain  TYP$K_ANY
   to indicate that a parameter can have any data type, and the following
   bits may be set in NOD$W_FLAGS:

        NOD$M_VALUE     Indicates  that  the  parameter  is   passed   by
                        immediate value.

        NOD$M_DESC      Indicates  that  the  parameter  is   passed   by
                        descriptor.

        NOD$M_REF       Indicates  that  the  parameter  is   passed   by

                                    C-17
   GENERATING SDL OUTPUT FOR OTHER LANGUAGES   GENERATING SDL OUTPUT FOR OTHER LANGUAGES


                        reference.



   C.4  SOURCES   C.4  SOURCES

   This section contains:

        o  A copy of the build file that generates a new SDL

        o  A copy of the PL/I back end











































                                    C-18
                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES


   C.4.1  The PL/I Output Routine   C.4.1  The PL/I Output Routine

   The contents of the PL/I output routine, SDLPLI.PLI are shown below.

        SDL$PLI: proc;
         
        %include 'sdlnodef.in';  /* node structure definition */
        %include 'sdltypdef.in'; /* data type definitions */

        %replace line_length by 132; /* output file line length */

        /* DATA and EXTERNAL ROUTINE DECLARATIONS */

        /* 
         * This external routine outputs lines to the target language
         * output file.  The first argument is the address of a buffer
         * with the output text, and the second argument is the maximum
         * line length for the output file.  Output lines are broken off
         * and output on the next line if they are too long
         */
         dcl SDL$PUTLINE entry (char(1024) var,fixed bin(31));

        /*
         * This external routine returns a header giving the name of
         * the SDL utility and the current time and date
         */
         dcl SDL$HEADER entry returns(char(1024) var);
         
        /*
         * The following external variable always points to the root of 
         * the SDL tree
         */
         dcl TREE_ROOT ptr static external;

        /*
         * The following array gives the PL/I equivalents for SDL data types
         */
         dcl types(20) char (32) var;
         
        /*
         * The following initialization of the types array is done with
         * assignments so that the numeric values of the symbols used for
         * indices do not have to be known 
         */
         
         types(typ$k_address)='pointer';
         types(typ$k_byte)='fixed binary(7)';
         types(typ$k_char)='character';
         types(typ$k_boolean)='bit(1) aligned';
         types(typ$k_decimal)='fixed decimal';
         types(typ$k_double)='float binary(53)';
         types(typ$k_float)='float binary(24)';
         types(typ$k_grand)='float binary(53)';

                                    C-19
   GENERATING SDL OUTPUT FOR OTHER LANGUAGES   GENERATING SDL OUTPUT FOR OTHER LANGUAGES


         types(typ$k_huge)='float binary(113)';
         types(typ$k_longword)='fixed binary(31)';
         types(typ$k_octaword)='bit (128) aligned';
         types(typ$k_quadword)='bit (64) aligned';
         types(typ$k_vield)='bit';
         types(typ$k_word)='fixed binary(15)';
         types(typ$k_structure)='';
         types(typ$k_union)='union';
         types(typ$k_any)='any';

        /*
         * These equivalents are used for unsigned data types
         */
         dcl unsigned (20) char (32) var;

         unsigned(typ$k_byte)='bit(8) aligned';
         unsigned(typ$k_word)='bit(16) aligned';
         unsigned(typ$k_longword)='bit(32) aligned';
         unsigned(typ$k_quadword)='bit(64) aligned';
         unsigned(typ$k_octaword)='bit(128) aligned';


        /* LOCAL VARIABLES */

         dcl xptr ptr;
         dcl buf char(1024) var;
         dcl based_string char(1024) var based;
         dcl i fixed bin(31);
        /*
         * 
         **************************** OUTPUTNODE ****************************
         * 
         * This is a recursive routine that travels through the SDL tree and
         * outputs the appropriate data declaration for each tree node.  Each
         * node describes a data object
         */

        OUTPUTNODE: proc (p,startp,level);

        /*
         * parameters: p = address of node to output
         *   startp = address of where we started (i.e. where to 
         *      stop in traversing a circular list )
         *   level = level number of aggregate (incremented by 1
         *      with each sub-aggregate
         */

          dcl (p,startp,q) ptr;
          dcl level fixed bin(31);
          dcl tmpbuf char(32) var;
         
        /*
         * Case on the node type and go do the appropriate processing 

                                    C-20
                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES


         */
          if   p^=startp then do;
         goto case(p->nod$b_type);

         
        CASE (NOD$K_ROOTNODE):  /* Root node */

        /*
         * Nothing done here except to move on to list of module
         * nodes of which this is the head
         */

         buf='';
         goto common_2;

        CASE (NOD$K_COMMNODE):  /* Comment node */

        /*
         * If we're in the middle of an aggregate, then output the previous
         * declaration before outputting this comment
         */
         if level>1 & buf^='' then  
          call sdl$putline(buf,line_length);
        /*
         * Clear the buffer and let the common stuff output the comment line
         */
         buf='';
         goto common;
         

        CASE (NOD$K_CONSTNODE):  /* Constant node */

        /*
         * Do a straightforward %replace statement for the constant node
         */
         buf='%REPLACE '||p->nod$t_name||' BY '||trim(p->
          nod$l_typeinfo)||';';
         goto common;

         
        CASE (NOD$K_ENTRYNODE):  /* Entry node */

        /*
         * Declare an external entry point
         */
         buf='DCL '||p->nod$t_name||' ENTRY ';

        /*
         * If it has parameters, then do down the parameter list
         */
         if p->nod$a_child^=null() then do;
          buf=buf||'(';
          call outputnode(p->nod$a_child->nod$a_flink,

                                    C-21
   GENERATING SDL OUTPUT FOR OTHER LANGUAGES   GENERATING SDL OUTPUT FOR OTHER LANGUAGES


           p->nod$a_child,level);
          substr(buf,length(buf),1)=')'; /* replace the comma
             appended by the parameter
             routine with a closing
             parentheses */
          end;
        /*
         * If it's a function, output the datatype
         */
         if p->nod$w_datatype^=0 then do;
          buf=buf||' RETURNS (';
          call puttype(p);
          buf=buf||')';
          end;
        /*
         * Check for options 
         */
         if p->nod$w_flags & nod$m_variable then
          buf=buf||' OPTIONS(VARIABLE)';
         buf=buf||';';
         goto common;

        CASE (NOD$K_ITEMNODE):  /* Item node */

        /*
         * If we're doing a scalar item, or at the beginning of an aggregate
         * declaration, then begin the DECLARE statement
         */
         if level=1 then  do;
          buf='DCL ';
          if p->nod$w_datatype=typ$k_structure |
             p->nod$w_datatype=typ$k_union then 
           buf=buf||'1 ';
          end;
         else do;
        /*
         * If this is an aggregate member, finish off the previous 
         * declaration with a comma and output it , then begin a new line by
         * indenting and putting in the level number 
         */
           buf=buf||',';
          call sdl$putline(buf,line_length);
          buf='   '||copy(' ',level)||trim(level)||' ';
          end;
        /*
         * No matter what, now we put in the name and the data type 
         */
         buf=buf||p->nod$t_name||' ';
         call puttype(p);
        /*
         * If there's an attached comment, append it to the output line 
         */
         if p->nod$a_comment^=null() then 

                                    C-22
                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES


          buf=buf||'/*'||p->nod$a_comment->based_string||'*/';
        /*
         * If this is an aggregate or sub-aggregate declaration, then 
         * recursively call outputnode for its members
         */
         if p->nod$w_datatype=typ$k_structure | 
            p->nod$w_datatype=typ$k_union then
          call outputnode(p->nod$a_child->nod$a_flink,
           p->nod$a_child,level+1);
        /*
         * If this is a scalar item or the end of an aggregate, then append
         * the final semicolon and output the line (warn of non-zero origins)
         */
         if level=1 then do;
          buf=buf||';';
          if (p->nod$w_datatype=typ$k_structure | 
              p->nod$w_datatype=typ$k_union) & 
              p->nod$l_typeinfo^=0 then
           buf=buf || 
           '/* WARNING: aggregate has origin of ' ||
            trim(p->nod$l_typeinfo) || ' */';
          call sdl$putline(buf,line_length);
          buf='';
          end;
         goto common_3;
         
        CASE (NOD$K_MODULNODE):  /* Module node */

        /*
         * Put out the module name as a comment 
         */
         call sdl$putline(' ',line_length);
         buf='/*** MODULE '||p->nod$t_name||' ***/';
         goto common;
         

        CASE (NOD$K_PARMNODE):  /* Parameter node */

        /*
         * If the parameter is an aggregate, then get the level number 
         */
         if level>1 | p->nod$w_datatype=typ$k_structure | 
            p->nod$b_type=typ$k_union then 
          buf=buf||trim(level)||' ';
        /*
         * Put out the item datatype and append a comma for the parameter
         * list (extra last comma will be corrected by entry routine) 
         */
         call puttype(p);
         buf=buf||',';
         goto common_2;
         


                                    C-23
   GENERATING SDL OUTPUT FOR OTHER LANGUAGES   GENERATING SDL OUTPUT FOR OTHER LANGUAGES


        CASE (NOD$K_OBJNODE):  /* Object node for pointer items */

        /*
         * Ignore object nodes-- PL/I doesn't care what a pointer is 
         * pointing to
         */
         buf='';
         goto common_2;
         

        CASE (NOD$K_HEADNODE):  /* Header node */

        /*
         * Nothing done with head nodes-- just use them to move down a 
         * circular list 
         */
         buf='';
         goto common_2;


        COMMON:

        /* 
         * If there is attached comment, then append it to end of line and 
         * output it 
         */
         if p->nod$a_comment^=null() then 
          buf=buf||'/*'||p->nod$a_comment->based_string||'*/';
         call sdl$putline(buf,line_length);
         buf='';

        COMMON_2:
        /*
         * Travel down the child node 
         */
         if p->nod$a_child^=null() then
          call outputnode(p->nod$a_child->nod$a_flink,
          p->nod$a_child,level+1);

        COMMON_3:
        /*
         * Travel across the circular list to the sibling node 
         */
         call outputnode(p->nod$a_flink,startp,level);
         end;
         return;
         
         
        /*
         ******************************* PUTTYPE ****************************
         * 
         * This routine formats the datatype information for an item 
         */

                                    C-24
                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES


        PUTTYPE: proc(p);
        /*
         * Parameter: p = pointer to current node
         */
         dcl p ptr;
         
        /*
         * If there is a dimension, append it 
         */
         if (p->nod$w_flags & nod$m_dimen) then
          buf=buf||'('||trim(p->nod$l_lodim)||':'||trim
          (p->nod$l_hidim)||') ';
        /* 
         * Check for the unsigned attribute-- if present use different
         * datatype equivalences 
         */
         if p->nod$w_flags & nod$m_unsigned then
          buf=buf||unsigned(p->nod$w_datatype);
         else
        /* 
         * Otherwise, just append from the datatype equivalenc array 
         */
          buf=buf||types(p->nod$w_datatype);
        /* 
         * Take care of special info for chars-- descriptor option and length
         */
         if  p->nod$w_datatype=typ$k_char  then
            if p->nod$w_flags&nod$m_desc then
          buf=buf||'(*)';
            else
          buf=buf||'('||trim(p->nod$l_typeinfo)||')';
        /* 
         * Add length for bit fields 
         */
         if p->nod$w_datatype=typ$k_vield  then 
          buf=buf||'('||trim(p->nod$l_typeinfo)||')';
        /* 
         * Add precision and scale for packed decimal 
         */
         if p->nod$w_datatype=typ$k_decimal then 
          buf=buf||'('||trim(p->nod$l_typeinfo)||','||
          trim(p->nod$l_typeinfo2)||')';
        /* 
         * Append optional attributes of various kinds 
         */
         if p->nod$w_flags & nod$m_varying then
          buf=buf||' VARYING ';
         if p->nod$w_flags & nod$m_value then
          buf=buf||' VALUE ';
         if p->nod$w_flags & nod$m_common then
          buf=buf||' STATIC EXTERNAL ';
         if p->nod$w_flags & nod$m_global then
          buf=buf||' GLOBALREF ';

                                    C-25
   GENERATING SDL OUTPUT FOR OTHER LANGUAGES   GENERATING SDL OUTPUT FOR OTHER LANGUAGES


         if p->nod$w_flags & nod$m_based then
          buf=buf||' BASED ';
        /* 
         * Check for descriptor-- only allowed with char 
         */
         if p->nod$w_flags & nod$m_desc then
          if p->nod$w_datatype^=typ$k_char then 
           buf=buf||' /* WARNING: Cannot output
         DESCRIPTOR for this datatype */';
         
         return;

        end PUTTYPE;
         
        end OUTPUTNODE;

         
        /*
         ******************************** TRIM ******************************
         * 
         * Makes a character string stripped of excess blanks from an integer
         */
        TRIM: proc (i) returns (char(32) var);
         dcl i fixed bin;
         dcl a char(32) var;
         a=character(i);
         a=substr(a,verify(a,' '));
         return(a);
        end TRIM;
         
         
        /* 
         * Output the little SDL header with time and date info 
         */
         call sdl$putline(' ',line_length);
         call sdl$putline('/*'||sdl$header()||'*/',line_length);
         call sdl$putline(' ',line_length);
        /* 
         * Begin at the root of the tree, and let it go 
         */
         call outputnode(tree_root->nod$a_flink,tree_root,0);
         
         return;

        end SDL$PLI;
                                   INDEX



   Ada file type, 3-5                    FORTRAN representation, 3-32
   Ada output                            MACRO-32 representation, 3-34
     request, 3-5                        PASCAL representation, 3-39
     translation summary, 3-51           PL/I representation, 3-37

                                    C-26
                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES


   Addition operator, 3-7              Based storage, 2-16
   ADDRESS declarations, 3-22          Based storage class, 3-23
     ADA representation, 3-51            ADA representation, 3-51
     BLISS-32 representation, 3-28       BLISS-32 representation, 3-28
     C representation, 3-30              C representation, 3-30
     DATATRIEVE representation, 3-42     DATATRIEVE representation, 3-42
     default tag, 3-26                   EPASCAL representation, 3-45
     EPASCAL representation, 3-45        FORTRAN representation, 3-32
     examples, 2-7                       MACRO-32 representation, 3-34
     FORTRAN representation, 3-32        PASCAL representation, 3-39
     MACRO-32 representation, 3-34       PL/I representation, 3-37
     PASCAL representation, 3-39       Binary notation, 3-6
     PL/I representation, 3-37         Bit offset symbol, 2-3
   AGGREGATE declarations, 3-11        Bit offsets, 2-13
     aggregate body, 2-10              Bit strings, 2-5
     examples, 2-10 to 2-11            BITFIELD declarations, 3-21
   Aggregates                            ADA representation, 3-51
     alignment within, 2-12              BLISS-32 representation, 3-28
     in ADDRESS declarations, 3-23       C representation, 3-30
     size of, 2-14                       DATATRIEVE representation, 3-42
   ALIAS option, 3-20                    default tag, 3-26
   Alignment, 2-12                       EPASCAL representation, 3-45
   AND operator, 3-7                     examples, 2-5
   ANY keyword, 2-16, 3-19               FORTRAN representation, 3-32
     ADA representation, 3-51            MACRO-32 representation, 3-34
     BLISS-32 representation, 3-28       offsets, examples, 2-13
     C representation, 3-30              PASCAL representation, 3-39
     DATATRIVE representation, 3-42      PL/I representation, 3-37
     EPASCAL representation, 3-45      BLISS-32 output
     FORTRAN representation, 3-32        request, 3-5
     MACRO-32 represenation, 3-34        translation summary, 3-28
     PASCAL representation, 3-39       BLISSF output, 3-28
     PL/I representation, 3-37         BOOLEAN declarations, 3-22
   Arrays, 2-17, 3-24                    ADA representation, 3-51
   ASCII constants, 2-3                  BLISS-32 representation, 3-28
   ASCII value                           C representation, 3-30
     operator, 3-6                       DATATRIEVE representation, 3-42
   Asterisk (*)                          EPASCAL representation, 3-45
     specify array dimensions, 3-20      example, 2-6
                                         FORTRAN representation, 3-32
   BASED pointer-name storage class,     MACRO-32 representation, 3-34
       3-23                              PASCAL representation, 3-39
     ADA representation, 3-51            PL/I representation, 3-37
     BLISS-32 representation, 3-28     BYTE declarations, 2-5, 3-21
     C representation, 3-30              ADA representation, 3-51
     DATATRIEVE representation, 3-42     BLISS-32 representation, 3-28
     EPASCAL representation, 3-45        C representation, 3-30







                                  Index-1
   GENERATING SDL OUTPUT FOR OTHER LANGUAGES   GENERATING SDL OUTPUT FOR OTHER LANGUAGES


     DATATRIEVE representation, 3-42     C representation, 3-30
     default tag, 3-26                   DATATRIEVE representation, 3-42
     EPASCAL representation, 3-45        default tag, 3-26
     FORTRAN representation, 3-32        EPASCAL representation, 3-45
     MACRO-32 representation, 3-34       examples, 2-8
     PASCAL representation, 3-39         FORTRAN representation, 3-32
     PL/I representation, 3-37           lists
   Byte offset symbol, 2-3                 comments, 2-10
   Byte offsets, 2-13                      counter value, 2-10
                                           examples, 2-9
   C output                              MACRO-32 representation, 3-34
     request, 3-5                        PASCAL representation, 3-39
     translation summary, 3-30           PL/I representation, 3-37
   CHARACTER declarations, 3-22          within aggregates, 3-13
     ADA representation, 3-51          Constant identifiers, 2-8
     BLISS-32 representation, 3-28       in expressions, 2-3
     C representation, 3-30            Constant nodes, C-10
     DATATRIEVE representation, 3-42   Constants
     default tag, 3-26                   numeric, 2-3, 3-6
     EPASCAL representation, 3-45      Correspondence tables, 3-27
     examples, 2-6                     COUNTER option, 2-10, 3-10
     FORTRAN representation, 3-32      Current location symbols
     MACRO-32 representation, 3-34       in expressions, 2-3
     PASCAL representation, 3-39
     PL/I representation, 3-37         D_FLOATING declarations, 2-5,
   Character strings, 2-6                  3-21
   Characters valid in identifiers,      ADA representation, 3-51
       3-6                               BLISS-32 representation, 3-28
   Comment node, C-10                    C representation, 3-30
   Comments                              DATATRIEVE representation, 3-42
     ADA representation, 3-51            default tag, 3-26
     BLISS-32 representation, 3-28       EPASCAL representation, 3-45
     C representation, 3-30              FORTRAN representation, 3-32
     DATATRIEVE representation, 3-42     MACRO-32 representation, 3-34
     EPASCAL representation, 3-45        PASCAL representation, 3-39
     FORTRAN representation, 3-32        PL/I representation, 3-37
     in CONSTANT declaration, 2-10     Data types, 2-4
     local, 2-4, 3-8                     declaration keywords, 3-21
     MACRO-32 representation, 3-34       in ADDRESS declarations, 3-22
     Output, 2-4, 3-7                    of parameters, 3-19, 3-22
     PASCAL representation, 3-39         returned by functions, 3-20
     PL/I representation, 3-37           translation summary
   COMMON storage class, 2-16, 3-23        ADA, 3-51
     ADA representation, 3-51              BLISS-32, 3-28
     BLISS-32 representation, 3-28         C, 3-30
     C representation, 3-30                DATATRIEVE, 3-42
     DATATRIEVE representation, 3-42       EPASCAL, 3-45
     EPASCAL representation, 3-45          FORTRAN, 3-32
     FORTRAN representation, 3-32          MACRO-32, 3-34
     MACRO-32 representation, 3-34         PASCAL, 3-39
     PASCAL representation, 3-39           PL/I, 3-37
     PL/I representation, 3-37         DATATRIEVE output
   CONSTANT declarations, 3-9            request, 3-5

                                  Index-2
                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES


     ADA representation, 3-51            translation summary, 3-42
     BLISS-32 representation, 3-28     DECIMAL




















































                                  Index-3
   GENERATING SDL OUTPUT FOR OTHER LANGUAGES   GENERATING SDL OUTPUT FOR OTHER LANGUAGES


     constants, 3-6                      DATATRIEVE representation, 3-42
     declarations, 3-21                  EPASCAL representation, 3-45
       ADA representation, 3-51          FORTRAN representation, 3-32
       BLISS-32 representation, 3-28     MACRO-32 representation, 3-34
       C representation, 3-30            PASCAL representation, 3-39
       DATATRIEVE representation,        PL/I representation, 3-37
           3-42                        DIMENSION keyword, 3-20
       default tag, 3-26               Dimensions, 2-17, 3-24
       EPASCAL representation, 3-45    Division operator, 3-7
       FORTRAN representation, 3-32    DTR file type, 3-5
       MACRO-32 representation, 3-34   /DUMP qualifier, C-5
       PASCAL representation, 3-39
       PL/I representation, 3-37       ELN Pascal file type, 3-5
   DECIMAL constants, 2-3              ELN Pascal output
   Decimal data, 2-5                     request, 3-5
   DECIMAL declarations                END keyword, 2-11
     examples, 2-5                     END_MODULE keyword, 2-8
   Declarations, 2-8, 3-8              ENTRY declarations, 3-18
     syntax rules, 2-2                   ADA representation, 3-51
     translation summary                 BLISS-32 representation, 3-28
       ADA, 3-51                         C representation, 3-30
       BLISS-32, 3-28                    DATATRIEVE representation, 3-42
       C, 3-30                           EPASCAL representation, 3-45
       DATATRIEVE, 3-42                  examples, 2-15
       EPASCAL, 3-45                     FORTRAN representation, 3-32
       FORTRAN, 3-32                     MACRO-32 representation, 3-34
       MACRO-32, 3-34                    PASCAL representation, 3-39
       PASCAL, 3-39                      PL/I representation, 3-37
       PL/I, 3-37                      ENTRY keyword
   DEFAULT keyword                       in ADDRESS declarations, 3-23
     ADA representation, 3-51          Entry nodes, C-11
     BLISS-32 representation, 3-28     EPASCAL output
     C representation, 3-30              request, 3-5
     DATATRIEVE representation, 3-42     translation summary, 3-45
     EPASCAL representation, 3-45      Error messages, B-1
     FORTRAN representation, 3-32        output routines, C-3
     MACRO-32 representation, 3-34     Examples, 4-1
     PASCAL representation, 3-39         Ada output, 4-30
     PL/I representation, 3-37           BLISS-32 output, 4-5
   DEFAULT option, 3-20                  C output, 4-8
   Default storage class, 2-16           DATATRIEVE output, 4-24
   DESCRIPTOR keyword, 2-16, 3-19        EPASCAL output, 4-27
     ADA representation, 3-51            FORTRAN output, 4-11
     BLISS-32 representation, 3-28       MACRO-32 output, 4-14
     C representation, 3-30              PASCAL output, 4-20
     DATATRIEVE representation, 3-42     PL/I output, 4-17
     EPASCAL representation, 3-45        SDL input, 4-1
     FORTRAN representation, 3-32      Expressions
     MACRO-32 representation, 3-34       operators, 3-7
     PASCAL representation, 3-39         parentheses, 3-7
     PL/I representation, 3-37           rules, 3-6
   DIMENSION declarations, 3-24          syntax, 2-3
     ADA representation, 3-51

                                  Index-4
                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES


     BLISS-32 representation, 3-28     F_FLOATING declarations, 2-5,
     C representation, 3-30                3-21




















































                                  Index-5
   GENERATING SDL OUTPUT FOR OTHER LANGUAGES   GENERATING SDL OUTPUT FOR OTHER LANGUAGES


     ADA representation, 3-51            FORTRAN representation, 3-32
     BLISS-32 representation, 3-28       MACRO-32 representation, 3-34
     C representation, 3-30              PASCAL representation, 3-39
     DATATRIEVE representation, 3-42     PL/I representation, 3-37
     default tag, 3-26
     EPASCAL representation, 3-45      H file type, 3-5
     FORTRAN representation, 3-32      H_FLOATING declarations, 2-5,
     MACRO-32 representation, 3-34         3-21
     PASCAL representation, 3-39         ADA representation, 3-51
     PL/I representation, 3-37           BLISS-32 representation, 3-28
   File types                            C representation, 3-30
     for SDL output files, 3-5           DATATRIEVE representation, 3-42
     LIS, 3-4                            default tag, 3-26
   Files                                 EPASCAL representation, 3-45
     SDL input and output, 3-2           FORTRAN representation, 3-32
   Fixed-point decimal data, 3-21        MACRO-32 representation, 3-34
     precision, 3-21                     PASCAL representation, 3-39
   Floating-point data, 2-5              PL/I representation, 3-37
   FOR file type, 3-5                  Head nodes, C-15
   FORTRAN output                      Hexadecimal notation, 3-6
     request, 3-5
     translation summary, 3-32         IDENT option, 2-8
   Function declarations, 2-15         Identifiers
                                         in quotation marks, 2-2
   G_FLOATING declarations, 2-5,         rules, 3-6
       3-21                              SDL--generated names, 3-24
     ADA representation, 3-51            using keywords, 2-3
     BLISS-32 representation, 3-28     IN option, 3-19
     C representation, 3-30            INCLUDE
     DATATRIEVE representation, 3-42     statement, 2-4
     default tag, 3-26                 INCREMENT option, 2-9
     EPASCAL representation, 3-45      Integer data types, 2-5
     FORTRAN representation, 3-32      ITEM declarations, 3-17
     MACRO-32 representation, 3-34       data types, 2-4
     PASCAL representation, 3-39         examples, 2-15
     PL/I representation, 3-37         Item nodes, C-12
   GLOBAL storage class, 2-16, 3-23
     ADA representation, 3-51          Keywords, 2-3
     BLISS-32 representation, 3-28       summary, A-1
     C representation, 3-30              use as identifiers, 2-3
     DATATRIEVE representation, 3-42
     effect of /GLOBALDEF, 2-17,       /LANGUAGE qualifier, 3-3
         3-23                          Languages
     EPASCAL representation, 3-45        adding output routines, C-1
     FORTRAN representation, 3-32        options, 3-5
     MACRO-32 representation, 3-34       supported, 1-1
     PASCAL representation, 3-39       LENGTH keyword
     PL/I representation, 3-37           BITFIELD declarations, 3-21
   /GLOBALDEF qualifier                    example, 2-5
     ADA representation, 3-51            CHARACTER declarations, 3-22
     BLISS-32 representation, 3-28     LINKAGE option, 3-21
     C representation, 3-30            LIS file type, 3-4
     DATATRIEVE representation, 3-42   /LIST qualifier, 3-4

                                  Index-6
                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES


     effect, 2-17, 3-23                Listing, 3-4
     EPASCAL representation, 3-45      Local comments, 3-8




















































                                  Index-7
   GENERATING SDL OUTPUT FOR OTHER LANGUAGES   GENERATING SDL OUTPUT FOR OTHER LANGUAGES


   Local symbol declarations, 2-8,     Named constants, 2-8
       3-9                             NAMED option, 3-20
     examples, 2-8                     Names, 3-6
   Local symbol names, 2-8               local symbols, 2-8
     in expressions, 2-3                 prefixes, 3-24
   Logical AND operator, 3-7           Negative offsets, 2-14
   Logical OR operator, 3-7            /[NO]COMMENTS qualifier, 3-2
   Logical shift operator, 3-7         /[NO]COPYRIGHT qualifier, 3-3
   LONGWORD declarations, 2-5, 3-21    /[NO]DUMP qualifier, 3-3
     ADA representation, 3-51          /[NO]GLOBAL_DEFINITION qualifier,
     BLISS-32 representation, 3-28         3-3
     C representation, 3-30            /[NO]HEADER qualifier, 3-3
     DATATRIEVE representation, 3-42   /[NO]MODULE qualifier, 3-4
     default tag, 3-26                 /[NO]PARSE qualifier, 3-4
     EPASCAL representation, 3-45      /[NO]VMS_DEVELOPMENT qualifier,
     FORTRAN representation, 3-32          3-5
     MACRO-32 representation, 3-34     Nodes
     PASCAL representation, 3-39         Comment, C-10
     PL/I representation, 3-37           Constant, C-10
   Lowercase letters in identifiers,     Entry, C-11
       2-2                               Head, C-15
                                         Item, C-12
   MACRO-32 output                       Module, C-13
     request, 3-5                        Object, C-14
     translation summary, 3-34           Parameter, C-13
   MAR file type, 3-5                    Root, C-10
   MASK declaration                    Numeric constants, 2-3, 3-6
     ADA representation, 3-51
     C representation, 3-30            Object nodes, C-14
     DATATRIEVE representation, 3-42   Octal notation, 3-6
     EPASCAL representation, 3-45      OCTAWORD declarations, 2-5, 3-21
     FORTRAN representation, 3-32        ADA representation, 3-51
     MACRO-32 representation, 3-34       BLISS-32 representation, 3-28
     PASCAL representation, 3-39         C representation, 3-30
     PL/I representation, 3-37           DATATRIEVE representation, 3-42
   MASK declarations, 2-5, 3-22          default tag, 3-26
     BLISS-32 representation, 3-28       EPASCAL representation, 3-45
   Member declarations, 3-14             FORTRAN representation, 3-32
     data types, 2-4                     MACRO-32 representation, 3-34
   MODULE declarations, 3-8              PASCAL representation, 3-39
     ADA representation, 3-51            PL/I representation, 3-37
     BLISS-32 representation, 3-28     Offsets
     C representation, 3-30              negative, 2-14
     DATATRIEVE representation, 3-42   Offsets in bit fields, 2-13
     EPASCAL representation, 3-45      Offsets within aggregates, 2-12
     examples, 2-8                     Operators
     FORTRAN representation, 3-32        in expressions, 2-3, 3-7
     IDENT option, 2-8                   summary, 3-7
     MACRO-32 representation, 3-34     OPTIONAL option, 3-20
     PASCAL representation, 3-39       OR operator, 3-7
     PL/I representation, 3-37         ORIGIN option, 2-14, 3-12
   Module name, 2-8                    OUT option, 3-20
   Module nodes, C-13                  Output comments, 3-7

                                  Index-8
                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES


   Modules, 2-8                        Output files (SDL)
   Multiplication operator, 3-7          file specifications, 3-5




















































                                  Index-9
   GENERATING SDL OUTPUT FOR OTHER LANGUAGES   GENERATING SDL OUTPUT FOR OTHER LANGUAGES


     listing, 3-5                        MACRO-32 representation, 3-34
   Output languages                      PASCAL representation, 3-39
     adding, C-1                         PL/I representation, 3-37
   Output routines                     REFERENCE keyword, 3-19
     requirements, C-1                 RETURNS keyword
     sample, C-19                        ADA representation, 3-51
                                         EPASCAL representation, 3-45
   Parameter data types, 2-15            PASCAL representation, 3-39
   Parameter nodes, C-13               RETURNS option, 3-20
   PARAMETER option, 2-15, 3-19,         ADA representation, 3-51
       3-22                              BLISS-32 representation, 3-28
   Parameters                            C representation, 3-30
     descriptions, 3-19, 3-22            DATATRIEVE representation, 3-42
     optional, 3-20                      EPASCAL representation, 3-45
     pass by descriptor, 3-19            FORTRAN representation, 3-32
     specify default values, 3-20        MACRO-32 representation, 3-34
     TYPE, 3-20                          PASCAL representation, 3-39
   Parentheses in expressions, 3-7       PL/I representation, 3-37
   PAS file type, 3-5                  Root nodes, C-10
   PASCAL output
     request, 3-5                      Scalar items, 2-15
     translation summary, 3-39         SDL command, 3-2
   PL/I output                           examples, 3-5
     request, 3-5                        listing, 3-4
     translation summary, 3-37           specify output files, 3-5
   PLI file type, 3-5                    target languages, 3-3
   Pointers, declarations, 2-7         SDL translation
   Precedence of operators, 3-7          to ADA, 3-51
   PRECISION                             to BLISS-32, 3-28
     keyword, 2-5                        to C, 3-30
     option, 3-21                        to DATATRIEVE, 3-42
   PREFIX option, 2-18, 3-24             to EPASCAL, 3-45
   Prefixes, 2-18, 3-24                  to FORTRAN, 3-32
   Procedure parameters, 2-15            to MACRO-32, 3-34
                                         to PASCAL, 3-39
   QUADWORD declarations, 2-5, 3-21      to PL/I, 3-37
     ADA representation, 3-51          Shift operator, 3-7
     BLISS-32 representation, 3-28     Signed integer data, 2-5
     C representation, 3-30            SIGNED keyword
     DATATRIEVE representation, 3-42     BITFIELD declarations, 3-22
     default tag, 3-26                 Sources, SDL, C-18
     EPASCAL representation, 3-45      Storage
     FORTRAN representation, 3-32        floating-point data, 2-5
     MACRO-32 representation, 3-34       integer data, 2-5
     PASCAL representation, 3-39         of structures and unions, 2-10
     PL/I representation, 3-37         Storage classes, 2-16, 3-23
                                         translation summary
   R32 file type, 3-5                      ADA, 3-51
   REF keyword                             BLISS-32, 3-28
     ADA representation, 3-51              C, 3-30
     BLISS-32 representation, 3-28         DATATRIEVE, 3-42
     C representation, 3-30                EPASCAL, 3-45
     DATATRIEVE representation, 3-42       FORTRAN, 3-32

                                  Index-10
                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES                                GENERATING SDL OUTPUT FOR OTHER LANGUAGES


     EPASCAL representation, 3-45          MACRO-32, 3-34
     FORTRAN representation, 3-32          PASCAL, 3-39




















































                                  Index-11
   GENERATING SDL OUTPUT FOR OTHER LANGUAGES   GENERATING SDL OUTPUT FOR OTHER LANGUAGES


       PL/I, 3-37                        PL/I representation, 3-37
   STRUCTURE declarations, 3-13        Unions
     ADA representation, 3-51            storage allocation, 2-10
     BLISS-32 representation, 3-28     Unsigned integers, 2-5
     C representation, 3-30            UNSIGNED keyword, 2-5, 3-21
     DATATRIEVE representation, 3-42   Uppercase letters in identifiers,
     default tag, 3-26                     2-2
     EPASCAL representation, 3-45
     examples, 2-10, 2-12              VALUE keyword, 2-16, 3-19
     FORTRAN representation, 3-32        ADA representation, 3-51
     MACRO-32 representation, 3-34       BLISS-32 representation, 3-28
     PASCAL representation, 3-39         C representation, 3-30
     PL/I representation, 3-37           DATATRIEVE representation, 3-42
     storage allocation, 2-10            EPASCAL representation, 3-45
   Subaggregate declarations, 2-12,      FORTRAN representation, 3-32
       3-13                              MACRO-32 representation, 3-34
   Subtraction operator, 3-7             PASCAL representation, 3-39
   Symbols, local, 2-8, 3-9              PL/I representation, 3-37
                                       VARIABLE option, 2-16, 3-20
   TAG option, 2-18, 3-24                ADA representation, 3-51
   Tags, 2-18, 3-25                      BLISS-32 representation, 3-28
     default tag letters, 3-26           C representation, 3-30
   Translation summaries, 3-28, 3-30,    DATATRIEVE representation, 3-42
       3-32, 3-34, 3-37, 3-39, 3-42,     EPASCAL representation, 3-45
       3-45, 3-51                        FORTRAN representation, 3-32
   Translation tables, 3-27 to 3-28,     MACRO-32 representation, 3-34
       3-30, 3-32, 3-34, 3-37, 3-39,     PASCAL representation, 3-39
       3-42, 3-45, 3-51                  PL/I representation, 3-37
   Translator (SDL), invoke, 3-2       VARYING keyword, 2-6, 3-22
   TYPE option, 3-20 to 3-21           /VMS_DEVELOPMENT qualifier
                                         effect, 3-36
   UNARY minus operator, 3-7
   UNION declarations, 3-13            WORD declarations, 2-5, 3-21
     ADA representation, 3-51            ADA representation, 3-51
     BLISS-32 representation, 3-28       BLISS-32 representation, 3-28
     C representation, 3-30              C representation, 3-30
     DATATRIEVE representation, 3-42     DATATRIEVE representation, 3-42
     default tag, 3-26                   default tag, 3-26
     EPASCAL representation, 3-45        EPASCAL representation, 3-45
     examples, 2-10                      FORTRAN representation, 3-32
     FORTRAN representation, 3-32        MACRO-32 representation, 3-34
     MACRO-32 representation, 3-34       PASCAL representation, 3-39
     PASCAL representation, 3-39         PL/I representation, 3-37











                                  Index-12
