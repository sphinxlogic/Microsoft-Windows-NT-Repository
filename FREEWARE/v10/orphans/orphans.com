$	v = 'f$verify(0)'
$	m = f$environment("message")
$ Set symbol/verb/scope=(noglobal,nolocal)	!Turn off outer verb symbols
$!
$!
$! ORPHANS.COM (by Dave's Bitshop Inc)
$! This version: 11-Feb-1994
$!
$! Revision history:
$!
$! V1.1 Joe Sander
$!	Remove SYS$SCRATCH from filespecs, it causes problems.
$!	Handle case of mail file with no folders.
$!
$! V1.2 Dave Porter
$!	Perform a few more error checks
$!
$! V1.3 Dave Porter
$!	Detect duplicate message ids (means someone's copied a 
$!	top-level mail file)
$!
$! V1.4	Dave Porter
$!	Fix typo which caused minor error ('4' instead of '$') 
$!
$! V1.5	Dave Porter
$!	. Don't upcase folder names
$!	. Insert the SET MESSAGE command that should have been there
$!
$! V1.6 Dave Porter
$!	Add SET SYMBOL/SCOPE=NOGLOBAL
$!
$! V1.7 John Francini
$!	Handle folder names containing spaces (as can be generated by
$!	DECwindows Mail or by quoting the folder name). 
$!		
$	version = "V1.7"
$!
$! This procedure will determine which MAIL$nnn...nnn.MAI files are
$! orphans i.e. have no pointers from corresponding MAIL files.
$!
$! Assumptions: all files are in the user's mail subdirectory with filetype
$! of .MAI; of these files, the ones called MAIL$nnnnnnnnnnnnnnnn.MAI are
$! individual message files, and the others are top-level V4 MAIL files.
$!
$! Who knows what will happen if there is mail activity whilst this
$! procedure is being done?  Accordingly, it doesn't actually modify anything.
$! It merely reports dangling references and orphan files, and lets you
$! actually worry about tidying up.  A command procedure is generated which
$! you can use to do the deletion if you wish.
$!
$! Don't complain to me if this deletes all your valuable mail... I won't
$! be at all sympathetic!
$!
$!
$	scratch = ""
$	utag = f$cvtime() - "-" - "-" - " " - ":" - ":" - "."
$	fx   = "''scratch'tidy%_''utag'.tmp"	! for tidying up
$	f0   = "''scratch'tidy0_''utag'.tmp"	! MAIL output (generic)
$	f1   = "''scratch'tidy1_''utag'.tmp"	! MAIL input (generic)
$	f2   = "''scratch'tidy2_''utag'.tmp"	! List of message ids
$	f3   = "''scratch'tidy3_''utag'.tmp"	! Mail msg files
$	f4   = "''scratch'tidy4_''utag'.tmp"	! Mail folder files
$	f5   = "''scratch'tidy5_''utag'.tmp"	! DELETE command file
$	on warning then goto xxx
$	on control_y then goto yyy
$	write sys$output "ORPHANS ''version'"
$	set message/severity/facility/identification/text
$	set symbol/scope=noglobal
$
$!
$! Make some warnings
$!
$	if .not. f$getdvi("sys$command","trm") then goto k1
$	read/end=yyy/prompt="Do you know what you're doing? " sys$command ok
$	if ok then goto k1
$	type sys$input

  This procedure attempts to perform a consistency check on your mail
  files.  It will not actually change anything, although it will (if
  necessary) create a command procedure which you can later execute to
  delete orphaned mail messages.  You should inspect this procedure
  before executing it, just in case something went drastically wrong.

  Note that any mail activity, including arrival of new mail messages
  or modification of existing messages or folders, can invalidate the
  results of this procedure.

  Only mail files in your mail subdirectory will be considered.

  End of warning; type Ctrl/Y to abort the run.

$k1:
$!
$! Determine mail directory spec
$!
$	maildir = ""
$	assign/user 'f0' sys$output
$	mail
 show mail_directory
$	open/read $f0 'f0'
$l1:	read/end=l2 $f0 line
$	line = f$edit(line,"compress,trim,upcase")
$	if f$extract(0,27,line) .nes. "YOUR MAIL FILE DIRECTORY IS" then goto l1
$	line = f$extract(27,99,line)
$	maildir = f$parse(line,,,"device") + f$parse(line,,,"directory")
$l2:	close $f0
$	if maildir .eqs. "" then goto udir
$	delete 'f0';*
$	write sys$output "Mail directory ",maildir
$
$!
$! List top-level mail files and mail message files. We do this with DIRECTORY
$! rather than F$SEARCH in the fond hope that we take a 'snapshot' and thus
$! have less trouble with nwe mail whislt we're working.
$!
$	directory/output='f4'/noheader/notrailer/columns=1/versions=1 -
		'maildir'*.mai/exclude=mail$%%%%%%%%%%%%%%%%.mai
$	directory/output='f3'/noheader/notrailer/columns=1/versions=1 -
		'maildir'mail$%%%%%%%%%%%%%%%%.mai
$
$!
$! We need to loop for every mail file, building up 
$! a list of all known message IDs
$!
$	mailfile_cnt = 0
$	folder_cnt   = 0
$	msgid_cnt    = 0
$	msgfile_cnt  = 0
$	open/read  $f4 'f4'	! Input: mail files
$	open/write $f2 'f2'	! Output: msg ids
$m1:	read/end=m3 $f4 line
$	mailfile = f$parse(line,,,"name")
$	if f$file_attrib(line,"org") .eqs. "IDX" then goto m2
$	write sys$output " ''mailfile'.MAI - not indexed file"
$	goto m1
$m2:	write sys$output " Mail file ",mailfile
$	mailfile_cnt = mailfile_cnt + 1
$
$! Obtain raw list of folders in this mail file
$		write sys$output "  Determining folder names..."
$		open/write $f1 'f1'
$		write $f1 "set file ''mailfile'"
$		write $f1 "directory/folder"
$		close $f1
$		assign/user 'f0' sys$output
$		assign/user 'f1' sys$input
$		mail
$
$! Digest the folder listing; first discard the heading
$		fnum = 0
$		open/read  $f0 'f0' 
$	n1:	read/end=n4 $f0 line
$		if f$extract(0,16,line) .eqs. "%MAIL-W-FILEMPTY" then goto n4
$		if f$extract(0,1,line)  .eqs. "%" then write sys$output "  
",line
$		line = f$edit(line,"upcase,compress,trim")
$		if f$extract(0,18,line) .nes. "LISTING OF FOLDERS" then goto n1
$		read/end=n4 $f0 line
$		line = f$edit(line,"upcase,compress,trim")
$		if f$extract(0,12,line) .nes. "PRESS CTRL/C" then goto n1
$
$! Now build the folder name array (folder1, folder2, ...)
$! Note we do this in memory, don't think a file is needed
$! Here we need to be smart. DECwindows Mail allows folders with spaces.
$! VAXmail is rather dumbo about the way it displays the folder names.
$! Since it knows they're a maximum of 39 characters long, it displays
$! them two-at-a-time, one starting at column 1, the other at column 41.
$! Use this nugget of wisdom to take apart each line, remove the extraneous
$! spaces, and rebuild the line with a | as the divider.  If the user has
$! vertical bars in his/her folder names, choose a different separator
$! for the symbol "separator" in the line below.
$		separator = "|"
$		fnum = 0
$	n2:	read/end=n4 $f0 line
$		linelh = f$edit(f$extract(0,39,line),"compress,trim") !Left half
$		linerh = f$edit(f$extract(40,39,line),"compress,trim") !Right 
half
$		line = linelh + separator + linerh
$		elem = 0
$	n3:	folder = f$element(elem,separator,line)
$		if folder .eqs. " " .or. folder .eqs. "" .or. -
			folder .eqs. separator then goto n2
$		fnum = fnum + 1
$		folder'fnum' = folder
$		elem = elem + 1
$		goto n3
$
$! Digestion complete, close the files
$	n4:	close $f0
$		delete 'f0';*,'f1';*
$		if fnum .ne. 0 then goto n5
$		write sys$output "  No folders"
$		goto m1
$	n5:	folder_cnt = folder_cnt + fnum
$		fnum_max = fnum
$	!***	write sys$output f$fao("  !SL folder!%S",fnum)
$
$!
$! Now, for each folder, determine IDs of external messages
$!
$		write sys$output "  Identifying external messages..."
$		fnum = 0
$		mnum = 0
$	p1:	fnum = fnum + 1
$		if fnum .gt. fnum_max then goto p4
$		folder = folder'fnum'
$		quo = ""
$		if f$edit(folder,"upcase") .nes. folder then quo = """"
$	!***	write sys$output "  Folder ",quo,folder,quo
$
$! Get a full directory listing for this folder
$			open/write $f1 'f1'
$			write $f1 "set file ''mailfile'"
$		  	write $f1 "directory/full ",quo,folder,quo
$			close $f1
$			assign/user 'f1' sys$input
$			assign/user 'f0' sys$output
$			mail
$
$! Extract message ID records and add them to the big list
$			open/read  $f0 'f0'
$		p2:	read/end=p3 $f0 line
$		        if f$extract(0,1,line) .eqs. "%" then write sys$output " 
  ",line
$			line = f$edit(line,"compress,upcase,trim")
$			x = f$locate("EXTERNAL MESSAGE ID",line)
$			if x .ge. f$length(line) then goto p2
$			line = f$extract(x,99,line)
$			xid = f$element(1,"'",line)
$			write $f2 xid," ",mailfile," ",folder
$			mnum = mnum + 1
$			goto p2
$
$! We've got the full external message list for this folder
$		p3:	close $f0
$			delete 'f0';*,'f1';*
$			goto p1
$
$!
$! End of processing this mail file
$!
$	p4:	msgid_cnt = msgid_cnt + mnum
$		goto m1
$!
$! End of all mail files
$!
$m3:	close $f2	! output ID list
$	close $f4	! input mail file list
$	delete 'f4';*
$	write sys$output f$fao("!SL mail file!%S, !SL folder!%S, !SL external 
message!%S", mailfile_cnt, folder_cnt, msgid_cnt)
$
$!
$! Sort IDs into alpha order
$!
$	write sys$output " Sorting external message ID list..."
$	sort 'f2' 'f2'
$
$!
$! Now the heavy work...
$!
$	write sys$output " Matching message IDs and external message files..."
$	f2cnt = 0
$	f3cnt = 0
$	f5cnt = 0
$	open/read $f2 'f2'	! input: message IDs
$	open/read $f3 'f3'	! input: message filespecs
$	open/write $f5 'f5'	! output: delete commands
$	xid    = ""
$	prvxid = ""
$	suffix = ""
$	high   = "ZZZZZZZZZZZZZZZZ"
$q1:	if xid .nes. "" then goto q3
$	line = high	! in case of eof
$	read/end=q2 $f2 line
$	f2cnt = f2cnt + 1
$q2:	xid      = f$element(0," ",line)
$	mailfile = f$element(1," ",line)
$	folder   = f$element(2," ",line)
$	if xid .eqs. prvxid then goto q7a
$	prvxid = xid	! keep copy for next time
$q3:	if suffix .nes. "" then goto q5
$	line = high	! in case of eof
$	read/end=q4 $f3 line
$	f3cnt = f3cnt + 1
$q4:	msgfile = f$parse(line,,,"name") 
$	suffix = msgfile - "MAIL$"
$q5:	if xid .lts. suffix then goto q6
$	if xid .gts. suffix then goto q7
$	if xid .eqs. high then goto q8	! both eofs seen
$
$! Msg id = file suffix, this one okay
$	xid    = ""
$	suffix = ""
$	goto q1
$
$! Message id < file suffix, means dangling msg ID pointer
$! Issue message and go check next msg ID against same msg file
$q6:	write sys$output " File ''mailfile', folder ''folder', message id ''xid' 
- no corresponding file"
$	xid = ""
$	goto q1
$
$! Message id > file, means file that's not referenced
$! Issue message and go check next msg file against same msg ID
$q7:	write sys$output " File ''msgfile'.MAI - corresponds to no mail message"
$	x = maildir + msgfile + ".MAI;*"
$	write $f5 "$ set file ''x' /protection=owner=rwed"
$	write $f5 "$ delete/nolog/noconfirm ''x'"
$	f5cnt = f5cnt + 1
$	suffix = ""
$	goto q1
$
$! Two consectutive message IDs were identical; usually means top-level
$! mail file has been copied
$q7a:	write sys$output " Message id ''xid' - multiple references"
$	xid = ""
$	goto q1
$
$! EOF seen on both lists
$q8:	close $f2
$	close $f3
$	close $f5
$	delete 'f2';*,'f3';*
$	if f5cnt .ne. 0 then goto q9
$	delete 'f5';*
$	goto r1
$!
$! End of processing
$!
$q9:	x = "''scratch'tidyup.tmp"
$	rename 'f5' 'x';0
$	x = f$element(0,";",f$search(x))
$	write sys$output f$fao(" !SL orphan file!%S found",f5cnt)
$	write sys$output " Type @''x' to delete them, after first"
$	write sys$output " examining the file for plausibility. Be careful!"
$
$! Consistency checks
$r1:	if f2cnt .eq. msgid_cnt then goto r2
$	write sys$output " Ooops.  Expected to process ''msgid_cnt' message IDs"
$	write sys$output " but only saw ''f2cnt' in work file.
$r2:	write sys$output "All done"
$	set message 'm'
$	exit 1+(0*f$verify(v))
$
$!
$! Errors come here
$!
$xxx:	x = "-" + f$message($status) - "%" 
$	write sys$output "%ORPHANS-E-OOPS, unexpected error"
$	write sys$output x
$yyy:	set noon
$	on control_y then goto yyy
$	if f$trnlnm("$f1") .nes. "" then close $f1
$	if f$trnlnm("$f2") .nes. "" then close $f2
$	if f$trnlnm("$f3") .nes. "" then close $f3
$	if f$trnlnm("$f4") .nes. "" then close $f4
$	if f$trnlnm("$f5") .nes. "" then close $f5
$	if f$search(fx) .nes. "" then delete 'fx';*
$	set message 'm'
$	exit %x10000002+(0*f$verify(v))
$!
$! Specific detected errors
$!
$udir:	write sys$output "%ORPHANS-F-UNKDIR, cannot determine mail directory"
$	goto yyy
$
$!
$! End of ORPHANS.COM
$!

