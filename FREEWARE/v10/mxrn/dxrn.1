$! ------------------ CUT HERE -----------------------
$ v='f$verify(f$trnlnm("SHARE_VERIFY"))'
$!
$! This archive created by VMS_SHARE Version 7.2-007  22-FEB-1990
$!   On  6-NOV-1994 09:53:03.94   By user MURPHY 
$!
$! This VMS_SHARE Written by:
$!    Andy Harper, Kings College London UK
$!
$! Acknowledgements to:
$!    James Gray       - Original VMS_SHARE
$!    Michael Bednarek - Original Concept and implementation
$!
$! TO UNPACK THIS SHARE FILE, CONCATENATE ALL PARTS IN ORDER
$! AND EXECUTE AS A COMMAND PROCEDURE  (  @name  )
$!
$! THE FOLLOWING FILE(S) WILL BE CREATED AFTER UNPACKING:
$!       1. AVL.C;13
$!       2. AVL.H;6
$!       3. BIGICON.XBM;2
$!       4. BUTDEFS.H;3
$!       5. BUTTONS.C;190
$!       6. BUTTONS.H;2
$!       7. CALVIN.ICON;2
$!       8. CHANGELOG.;2
$!       9. CHANGES.;55
$!      10. CLIENTLIB.C;173
$!      11. CODES.H;2
$!      12. COMPOSE.C;236
$!      13. COMPOSE.H;15
$!      14. CONFIG.H;26
$!      15. COPYRIGHT.;2
$!      16. COPYRIGHT.H;2
$!      17. CURSOR.C;38
$!      18. CURSOR.H;22
$!      19. DIALOGS.C;68
$!      20. DIALOGS.H;2
$!      21. DXRN.OPT;3
$!      22. ERROR_HNDS.C;48
$!      23. ERROR_HNDS.H;22
$!      24. FIXERS.;19
$!      25. IMAKEFILE.;18
$!      26. INTERNALS.C;164
$!      27. INTERNALS.H;51
$!      28. KILLFILE.C;8
$!      29. MAKE-DXRN.COM;2
$!      30. MAKE-MXRN.COM;13
$!      31. MAKE.COM;4
$!      32. MAKEFILE.;26
$!      33. MAKEFILE.DECNET;15
$!      34. MAKEFILE.MOTIF;25
$!      35. MENUS.C;153
$!      36. MENUS.H;13
$!      37. MESG.C;52
$!      38. MESG.H;3
$!      39. MODES.H;13
$!      40. MOTIF.TMPL;2
$!      41. MXRN.MAN;1
$!      42. MXRN.OPT;4
$!      43. NEWS.H;33
$!      44. NEWSRC.L;23
$!      45. NEWSRC.Y;2
$!      46. NEWSRCFILE.C;18
$!      47. NEWSRCFILE.H;2
$!      48. NEWSRC_PARSE.C;13
$!      49. NEWSRC_PARSE.H;14
$!      50. PANE.C;23
$!      51. PANE.H;2
$!      52. PANEP.H;2
$!      53. PATCHLEVEL.H;2
$!      54. README.UNIX;2
$!      55. README.VMS;2
$!      56. REFILE.C;6
$!      57. RESOURCES.C;107
$!      58. RESOURCES.H;45
$!      59. RFC977.TXT;2
$!      60. RN.BINDINGS;2
$!      61. SAVE.C;79
$!      62. SAVE.H;2
$!      63. SERVER.C;119
$!      64. SERVER.H;24
$!      65. SLIST.C;260
$!      66. SLIST.H;25
$!      67. SLISTP.H;11
$!      68. SMALLICON.XBM;2
$!      69. STRSTR.C;2
$!      70. STRTOK.C;2
$!      71. STRTOK.DOC;1
$!      72. T.H;2
$!      73. T6.C;3
$!      74. T7.C;3
$!      75. TEMPNAM.C;2
$!      76. TODO.;2
$!      77. TRANSFER.M64;1
$!      78. UTILS.C;21
$!      79. UTILS.H;33
$!      80. VPRINTF.C;2
$!      81. VPRINTF.DOC;2
$!      82. XMISC.C;72
$!      83. XMISC.H;17
$!      84. XRN.C;147
$!      85. XRN.DOC;6
$!      86. XRN.H;99
$!      87. XRN.MAN;1
$!      88. XRN.XBM;2
$!      89. XTHELPER.C;32
$!      90. XTHELPER.H;19
$!
$set="set"
$set symbol/scope=(nolocal,noglobal)
$f=f$parse("SHARE_TEMP","SYS$SCRATCH:.TMP_"+f$getjpi("","PID"))
$e="write sys$error  ""%UNPACK"", "
$w="write sys$output ""%UNPACK"", "
$ if f$trnlnm("SHARE_LOG") then $ w = "!"
$ ve=f$getsyi("version")
$ if ve-f$extract(0,1,ve) .ges. "4.4" then $ goto START
$ e "-E-OLDVER, Must run at least VMS 4.4"
$ v=f$verify(v)
$ exit 44
$UNPACK: SUBROUTINE ! P1=filename, P2=checksum
$ if f$search(P1) .eqs. "" then $ goto file_absent
$ e "-W-EXISTS, File ''P1' exists. Skipped."
$ delete 'f'*
$ exit
$file_absent:
$ if f$parse(P1) .nes. "" then $ goto dirok
$ dn=f$parse(P1,,,"DIRECTORY")
$ w "-I-CREDIR, Creating directory ''dn'."
$ create/dir 'dn'
$ if $status then $ goto dirok
$ e "-E-CREDIRFAIL, Unable to create ''dn'. File skipped."
$ delete 'f'*
$ exit
$dirok:
$ w "-I-PROCESS, Processing file ''P1'."
$ if .not. f$verify() then $ define/user sys$output nl:
$ EDIT/TPU/NOSEC/NODIS/COM=SYS$INPUT 'f'/OUT='P1'
PROCEDURE Unpacker ON_ERROR ENDON_ERROR;SET(FACILITY_NAME,"UNPACK");SET(
SUCCESS,OFF);SET(INFORMATIONAL,OFF);f:=GET_INFO(COMMAND_LINE,"file_name");b:=
CREATE_BUFFER(f,f);p:=SPAN(" ")@r&LINE_END;POSITION(BEGINNING_OF(b));
LOOP EXITIF SEARCH(p,FORWARD)=0;POSITION(r);ERASE(r);ENDLOOP;POSITION(
BEGINNING_OF(b));g:=0;LOOP EXITIF MARK(NONE)=END_OF(b);x:=ERASE_CHARACTER(1);
IF g=0 THEN IF x="X" THEN MOVE_VERTICAL(1);ENDIF;IF x="V" THEN APPEND_LINE;
MOVE_HORIZONTAL(-CURRENT_OFFSET);MOVE_VERTICAL(1);ENDIF;IF x="+" THEN g:=1;
ERASE_LINE;ENDIF;ELSE IF x="-" THEN IF INDEX(CURRENT_LINE,"+-+-+-+-+-+-+-+")=
1 THEN g:=0;ENDIF;ENDIF;ERASE_LINE;ENDIF;ENDLOOP;t:="0123456789ABCDEF";
POSITION(BEGINNING_OF(b));LOOP r:=SEARCH("`",FORWARD);EXITIF r=0;POSITION(r);
ERASE(r);x1:=INDEX(t,ERASE_CHARACTER(1))-1;x2:=INDEX(t,ERASE_CHARACTER(1))-1;
COPY_TEXT(ASCII(16*x1+x2));ENDLOOP;WRITE_FILE(b,GET_INFO(COMMAND_LINE,
"output_file"));ENDPROCEDURE;Unpacker;QUIT;
$ delete/nolog 'f'*
$ CHECKSUM 'P1'
$ IF CHECKSUM$CHECKSUM .eqs. P2 THEN $ EXIT
$ e "-E-CHKSMFAIL, Checksum of ''P1' failed."
$ ENDSUBROUTINE
$START:
$ create 'f'
X
X#if !defined(lint) && !defined(SABER)
Xstatic char XRNrcsid`5B`5D = "$Header: /net/objy27/wrld/mnt11/ricks/src/mast
Ver/xrn/avl.c,v 1.5 1993/01/11 02:14:13 ricks Exp $";
X#endif
X
X/*
X * avl package
X *
X * Copyright (c) 1988-1993, The Regents of the University of California.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X#include "copyright.h"
X#include "config.h"
X#ifndef VMS
X#include <X11/Intrinsic.h>
X#else
X#include <decw$include/Intrinsic.h>
X#endif
X#include <stdio.h>
X#include "utils.h"
X#include "avl.h"
X#include <assert.h>
X
X#ifdef ALLOC
X#undef ALLOC
X#endif
X#ifdef NIL
X#undef NIL
X#endif
X#ifdef FREE
X#undef FREE
X#endif
X#define ALLOC(type, number)  (type *) XtMalloc((unsigned) sizeof(type) * num
Vber)
X#define NIL(type)            (type *) 0
X#define FREE(item)`09     (void) XtFree((void *)item)
X
X#define XRNMAX(a,b)             ((a) > (b) ? (a) : (b))
X
X/* LINTLIBRARY */
X
X
X#define HEIGHT(node) (node == NIL(avl_node) ? -1 : (node)->height)
X#define BALANCE(node) (HEIGHT((node)->right) - HEIGHT((node)->left))
X
X#define compute_height(node) `7B`09`09`09`09\
X    int x=HEIGHT(node->left), y=HEIGHT(node->right);`09\
X    (node)->height = XRNMAX(x,y) + 1;`09`09`09\
X`7D
X
X#define COMPARE(key, nodekey, compare)`09 `09`09\
X    ((compare == avl_numcmp) ? `09`09`09`09\
X`09(int) key - (int) nodekey : `09`09`09\
X`09(*compare)(key, nodekey))
X
Xstatic avl_node *new_node();
Xstatic avl_node *find_rightmost();
Xstatic void do_rebalance();`20
Xstatic void rotate_left();
Xstatic void rotate_right();
Xstatic int do_check_tree();
X
X`0C
Xavl_tree * avl_init_table
X#if defined(__STDC__) && __STDC__
X(int (*compar)(const char *,const char *))
X#else
X(compar)
X    int (*compar)();
X#endif
X`7B
X    avl_tree *tree;
X
X    tree = ALLOC(avl_tree, 1);
X    if (! tree) `7B
X`09 return 0;
X    `7D
X    tree->root = NIL(avl_node);
X    tree->compar = compar;
X    tree->num_entries = 0;
X    return tree;
X`7D
X
Xint avl_lookup
X#if defined(STDC) && !defined(_NO_PROTO)
X(avl_tree *tree, register char *key, char **value_p)
X#else
X(tree, key, value_p)
X    avl_tree *tree;
X    register char *key;
X    char **value_p;
X#endif
X`7B
X    register avl_node *node;
X    register int (*compare)() = tree->compar, diff;
X
X    if (key == NIL(char) `7C`7C value_p == NIL(char *))
X`09return 0;
X    node = tree->root;
X    while (node != NIL(avl_node)) `7B
X`09diff = COMPARE(key, node->key, compare);
X`09if (diff == 0) `7B
X`09    /* got a match, give the user a 'value' only if non-null */
X`09    if (value_p != NIL(char *)) *value_p = node->value;
X`09    return 1;
X`09`7D
X`09node = (diff < 0) ? node->left : node->right;
X    `7D
X    return 0;
X`7D
X
Xint avl_insert
X#if defined(STDC) && !defined(_NO_PROTO)
X(avl_tree *tree, char *key, char *value)
X#else
X(tree, key, value)
X    avl_tree *tree;
X    char *key;
X    char *value;
X#endif
X`7B
X    register avl_node **node_p, *node;
X    register int stack_n = 0;
X    register int (*compare)() = tree->compar;
X    avl_node **stack_nodep`5B32`5D;
X    int diff, status;
X
X    node_p = &tree->root;
X
X    /* walk down the tree (saving the path); stop at insertion point */
X    status = 0;
X    while ((node = *node_p) != NIL(avl_node)) `7B
X`09stack_nodep`5Bstack_n++`5D = node_p;
X`09assert(stack_n < 32);
X`09diff = COMPARE(key, node->key, compare);
X`09if (diff == 0) status = 1;
X`09node_p = (diff < 0) ? &node->left : &node->right;
X    `7D
X
X    /* insert the item and re-balance the tree */
X    *node_p = new_node(key, value);
X    if (! *node_p) `7B
X`09 return -1;
X    `7D
X    do_rebalance(stack_nodep, stack_n);
X    tree->num_entries++;
X    tree->modified = 1;
X    return status;
X`7D
X/*
X * Insert a node with the key string being the value.
X * Assumes a static key input.
X */
X
Xint avl_insert_str
X#if defined(STDC) && !defined(_NO_PROTO)
X(avl_tree *tree, char *nkey)
X#else
X(tree, nkey)
X    avl_tree *tree;
X    char *nkey;
X#endif
X`7B
X    register avl_node **node_p, *node;
X    register int stack_n = 0;
X    register int (*compare)() = tree->compar;
X    avl_node **stack_nodep`5B32`5D;
X    int diff, status;
X    char *key;
X
X    key = (char *) XtNewString(nkey);
X    node_p = &tree->root;
X
X    /* walk down the tree (saving the path); stop at insertion point */
X    status = 0;
X    while ((node = *node_p) != NIL(avl_node)) `7B
X`09stack_nodep`5Bstack_n++`5D = node_p;
X`09assert(stack_n < 32);
X`09diff = COMPARE(key, node->key, compare);
X`09if (diff == 0) status = 1;
X`09node_p = (diff < 0) ? &node->left : &node->right;
X    `7D
X
X    /* insert the item and re-balance the tree */
X    *node_p = new_node(key, key);
X    if (! *node_p) `7B
X`09 return -1;
X    `7D
X    do_rebalance(stack_nodep, stack_n);
X    tree->num_entries++;
X    tree->modified = 1;
X    return status;
X`7D
X`0C
Xint avl_delete
X#if defined(STDC) && !defined(_NO_PROTO)
X(avl_tree *tree, char **key_p, char **value_p)
X#else
X(tree, key_p, value_p)
X    avl_tree *tree;
X    char **key_p;
X    char **value_p;
X#endif
X`7B
X    register avl_node **node_p, *node, *rightmost;
X    register int stack_n = 0;
X    char *key = *key_p;
X    int (*compare)() = tree->compar, diff;
X    avl_node **stack_nodep`5B32`5D;
X   `20
X    node_p = &tree->root;
X
X    /* Walk down the tree saving the path; return if not found */
X    while ((node = *node_p) != NIL(avl_node)) `7B
X`09diff = COMPARE(key, node->key, compare);
X`09if (diff == 0) goto delete_item;
X`09stack_nodep`5Bstack_n++`5D = node_p;
X`09assert(stack_n < 32);
X`09node_p = (diff < 0) ? &node->left : &node->right;
X    `7D
X    return 0;`09`09/* not found */
X
X    /* prepare to delete node and replace it with rightmost of left tree */
Xdelete_item:
X    *key_p = node->key;
X    if (value_p != 0) *value_p = node->value;
X    if (node->left == NIL(avl_node)) `7B
X`09*node_p = node->right;
X    `7D else `7B
X`09rightmost = find_rightmost(&node->left);
X`09rightmost->left = node->left;
X`09rightmost->right = node->right;
X`09rightmost->height = -2; `09/* mark bogus height for do_rebal */
X`09*node_p = rightmost;
X`09stack_nodep`5Bstack_n++`5D = node_p;
X    `7D
X    FREE(node);
X
X    /* work our way back up, re-balancing the tree */
X    do_rebalance(stack_nodep, stack_n);
X    tree->num_entries--;
X    tree->modified = 1;
X    return 1;
X`7D
X`0C
Xstatic void avl_record_gen_forward
X#if defined(STDC) && !defined(_NO_PROTO)
X(avl_node *node, avl_generator *gen)
X#else
X(node, gen)
X    avl_node *node;
X    avl_generator *gen;
X#endif
X`7B
X    if (node != NIL(avl_node)) `7B
X`09avl_record_gen_forward(node->left, gen);
X`09gen->nodelist`5Bgen->count++`5D = node;
X`09avl_record_gen_forward(node->right, gen);
X    `7D
X`7D
X
Xstatic void avl_record_gen_backward
X#if defined(STDC) && !defined(_NO_PROTO)
X(avl_node *node, avl_generator *gen)
X#else
X(node, gen)
X    avl_node *node;
X    avl_generator *gen;
X#endif
X`7B
X    if (node != NIL(avl_node)) `7B
X`09avl_record_gen_backward(node->right, gen);
X`09gen->nodelist`5Bgen->count++`5D = node;
X`09avl_record_gen_backward(node->left, gen);
X    `7D
X`7D
X
Xavl_generator * avl_init_gen
X#if defined(STDC) && !defined(_NO_PROTO)
X(avl_tree *tree, int dir)
X#else
X(tree, dir)
X    avl_tree *tree;
X    int dir;
X#endif
X`7B
X    avl_generator *gen;
X
X    /* what a hack */
X    gen = ALLOC(avl_generator, 1);
X    if (! gen) `7B
X`09 return 0;
X    `7D
X    gen->tree = tree;
X    gen->nodelist = ALLOC(avl_node *, avl_count(tree));
X    if (! gen->nodelist) `7B
X`09 return 0;
X    `7D
X    gen->count = 0;
X    if (dir == AVL_FORWARD) `7B
X`09avl_record_gen_forward(tree->root, gen);
X    `7D else `7B
X`09avl_record_gen_backward(tree->root, gen);
X    `7D
X    gen->count = 0;
X
X    /* catch any attempt to modify the tree while we generate */
X    tree->modified = 0;
X    return gen;
X`7D
X
Xint avl_gen
X#if defined(STDC) && !defined(_NO_PROTO)
X(avl_generator *gen, char **key_p, char **value_p)
X#else
X(gen, key_p, value_p)
X    avl_generator *gen;
X    char **key_p;
X    char **value_p;
X#endif
X`7B
X    avl_node *node;
X
X    if (gen->count == gen->tree->num_entries) `7B
X`09return 0;
X    `7D else `7B
X`09node = gen->nodelist`5Bgen->count++`5D;
X`09if (key_p != NIL(char *)) *key_p = node->key;
X`09if (value_p != NIL(char *)) *value_p = node->value;
X`09return 1;
X    `7D
X`7D
X
Xvoid avl_free_gen
X#if defined(STDC) && !defined(_NO_PROTO)
X(avl_generator *gen)
X#else
X(gen)
X    avl_generator *gen;
X#endif
X`7B
X    FREE(gen->nodelist);
X    FREE(gen);
X`7D
X`0C
Xstatic avl_node * find_rightmost
X#if defined(STDC) && !defined(_NO_PROTO)
X(register avl_node **node_p)
X#else
X(node_p)
X    register avl_node **node_p;
X#endif
X`7B
X    register avl_node *node;
X    register int stack_n = 0;
X    avl_node **stack_nodep`5B32`5D;
X
X    node = *node_p;
X    while (node->right != NIL(avl_node)) `7B
X`09stack_nodep`5Bstack_n++`5D = node_p;
X`09assert(stack_n < 32);
X`09node_p = &node->right;
X`09node = *node_p;
X    `7D
X    *node_p = node->left;
X
X    do_rebalance(stack_nodep, stack_n);
X    return node;
X`7D
X
Xstatic void do_rebalance
X#if defined(STDC) && !defined(_NO_PROTO)
X(register avl_node ***stack_nodep, register int stack_n)
X#else
X(stack_nodep, stack_n)
X    register avl_node ***stack_nodep;
X    register int stack_n;
X#endif
X`7B
X    register avl_node **node_p, *node;
X    register int hl, hr;
X    int height;
X
X    /* work our way back up, re-balancing the tree */
X    while (--stack_n >= 0) `7B
X`09node_p = stack_nodep`5Bstack_n`5D;
X`09node = *node_p;
X`09hl = HEIGHT(node->left);`09`09/* watch for NIL */
X`09hr = HEIGHT(node->right);`09`09/* watch for NIL */
X`09if ((hr - hl) < -1) `7B
X`09    rotate_right(node_p);
X`09`7D else if ((hr - hl) > 1) `7B
X`09    rotate_left(node_p);
X`09`7D else `7B
X`09    height = XRNMAX(hl, hr) + 1;
X`09    if (height == node->height) break;
X`09    node->height = height;
X`09`7D
X    `7D
X`7D
X`0C
Xstatic void rotate_left
X#if defined(STDC) && !defined(_NO_PROTO)
X(register avl_node **node_p)
X#else
X(node_p)
X    register avl_node **node_p;
X#endif
X`7B
X    register avl_node *old_root = *node_p, *new_root, *new_right;
X
X    if (BALANCE(old_root->right) >= 0) `7B
X`09*node_p = new_root = old_root->right;
X`09old_root->right = new_root->left;
X`09new_root->left = old_root;
X    `7D else `7B
X`09new_right = old_root->right;
X`09*node_p = new_root = new_right->left;
X`09old_root->right = new_root->left;
X`09new_right->left = new_root->right;
X`09new_root->right = new_right;
X`09new_root->left = old_root;
X`09compute_height(new_right);
X    `7D
X    compute_height(old_root);
X    compute_height(new_root);
X`7D
X
Xstatic void rotate_right
X#if defined(STDC) && !defined(_NO_PROTO)
X(avl_node **node_p)
X#else
X(node_p)
X    avl_node **node_p;
X#endif
X`7B
X    register avl_node *old_root = *node_p, *new_root, *new_left;
X
X    if (BALANCE(old_root->left) <= 0) `7B
X`09*node_p = new_root = old_root->left;
X`09old_root->left = new_root->right;
X`09new_root->right = old_root;
X    `7D else `7B
X`09new_left = old_root->left;
X`09*node_p = new_root = new_left->right;
X`09old_root->left = new_root->right;
X`09new_left->right = new_root->left;
X`09new_root->left = new_left;
X`09new_root->right = old_root;
X`09compute_height(new_left);
X    `7D
X    compute_height(old_root);
X    compute_height(new_root);
X`7D
X`0C
Xstatic void avl_walk_forward
X#if defined(STDC) && !defined(_NO_PROTO)
X(avl_node *node, void (*func)(char *,char *))
X#else
X(node, func)
X    avl_node *node;
X    void (*func)();
X#endif
X`7B
X    if (node != NIL(avl_node)) `7B
X`09avl_walk_forward(node->left, func);
X`09(*func)(node->key, node->value);
X`09avl_walk_forward(node->right, func);
X    `7D
X`7D
X
Xstatic void avl_walk_backward
X#if defined(STDC) && !defined(_NO_PROTO)
X(avl_node *node, void (*func)(char *,char *))
X#else
X(node, func)
X    avl_node *node;
X    void (*func)();
X#endif
X`7B
X    if (node != NIL(avl_node)) `7B
X`09avl_walk_backward(node->right, func);
X`09(*func)(node->key, node->value);
X`09avl_walk_backward(node->left, func);
X    `7D
X`7D
X
Xvoid avl_foreach
X#if defined(STDC) && !defined(_NO_PROTO)
X(avl_tree *tree, void (*func)(char *,char *), int direction)
X#else
X(tree, func, direction)
X    avl_tree *tree;
X    void (*func)();
X    int direction;
X#endif
X`7B
X    if (direction == AVL_FORWARD) `7B
X`09avl_walk_forward(tree->root, func);
X    `7D else `7B
X`09avl_walk_backward(tree->root, func);
X    `7D
X`7D
X
Xstatic void free_entry
X#if defined(STDC) && !defined(_NO_PROTO)
X(avl_node *node, void (*key_free)(char *), void (*value_free)(char *))
X#else
X(node, key_free, value_free)
X    avl_node *node;
X    void (*key_free)();
X    void (*value_free)();
X#endif
X`7B
X    if (node != NIL(avl_node)) `7B
X`09free_entry(node->left, key_free, value_free);
X`09free_entry(node->right, key_free, value_free);
X`09if (key_free != 0) (*key_free)(node->key);
X`09if (value_free != 0) (*value_free)(node->value);
X`09FREE(node);
X    `7D
X`7D
X   `20
Xvoid avl_free_table
X#if defined(STDC) && !defined(_NO_PROTO)
X(avl_tree *tree, void (*key_free)(char *), void (*value_free)(char *))
X#else
X(tree, key_free, value_free)
X    avl_tree *tree;
X    void (*key_free)();
X    void (*value_free)();
X#endif
X`7B
X    free_entry(tree->root, key_free, value_free);
X    FREE(tree);
X`7D
X
X
Xint avl_count
X#if defined(STDC) && !defined(_NO_PROTO)
X(avl_tree *tree)
X#else
X(tree)
X    avl_tree *tree;
X#endif
X`7B
X    return tree->num_entries;
X`7D
X`0C
Xstatic avl_node * new_node
X#if defined(STDC) && !defined(_NO_PROTO)
X(char *key, char *value)
X#else
X(key, value)
X    char *key;
X    char *value;
X#endif
X`7B
X    register avl_node *new;
X
X    new = ALLOC(avl_node, 1);
X    if (! new) `7B
X`09 return 0;
X    `7D
X    new->key = key;
X    new->value = value;
X    new->height = 0;
X    new->left = new->right = NIL(avl_node);
X    return new;
X`7D
X
Xint avl_numcmp
X#if defined(STDC) && !defined(_NO_PROTO)
X(char *x, char *y)
X#else
X(x, y)
X    char *x, *y;`20
X#endif
X`7B
X    return (int) x - (int) y;
X`7D
X`0C
Xint avl_check_tree
X#if defined(STDC) && !defined(_NO_PROTO)
X(avl_tree *tree)
X#else
X(tree)
X    avl_tree *tree;
X#endif
X`7B
X    int error = 0;
X    (void) do_check_tree(tree->root, tree->compar, &error);
X    return error;
X`7D
X
Xstatic int do_check_tree
X#if defined(STDC) && !defined(_NO_PROTO)
X(avl_node *node, int (*compar)(char *,char *), int *error)
X#else
X(node, compar, error)
X    avl_node *node;
X    int (*compar)();
X    int *error;
X#endif
X`7B
X    int l_height, r_height, comp_height, bal;
X   `20
X    if (node == NIL(avl_node)) `7B
X`09return -1;
X    `7D
X
X    r_height = do_check_tree(node->right, compar, error);
X    l_height = do_check_tree(node->left, compar, error);
X
X    comp_height = XRNMAX(l_height, r_height) + 1;
X    bal = r_height - l_height;
X   `20
X    if (comp_height != node->height) `7B
X`09(void) printf("Bad height for 0x%08x: computed=%d stored=%d\n",
X`09    node, comp_height, node->height);
X`09++*error;
X    `7D
X
X    if (bal > 1 `7C`7C bal < -1) `7B
X`09(void) printf("Out of balance at node 0x%08x, balance = %d\n",`20
X`09    node, bal);
X`09++*error;
X    `7D
X
X    if (node->left != NIL(avl_node) &&`20
X`09`09    (*compar)(node->left->key, node->key) > 0) `7B
X`09(void) printf("Bad ordering between 0x%08x and 0x%08x",`20
X`09    node, node->left);
X`09++*error;
X    `7D
X   `20
X    if (node->right != NIL(avl_node) &&`20
X`09`09    (*compar)(node->key, node->right->key) > 0) `7B
X`09(void) printf("Bad ordering between 0x%08x and 0x%08x",`20
X`09    node, node->right);
X`09++*error;
X    `7D
X
X    return comp_height;
X`7D
$ CALL UNPACK AVL.C;13 372026660
$ create 'f'
X#ifndef AVL_H
X#define AVL_H
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/avl.h,v 1.5 1993/01/
V11 02:14:15 ricks Exp $
X */
X
X/*
X * avl package
X *
X * Copyright (c) 1988-1993, The Regents of the University of California.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
Xtypedef struct avl_node_struct avl_node;
Xstruct avl_node_struct `7B
X    avl_node *left, *right;
X    char *key;
X    char *value;
X    int height;
X`7D;
X
X
Xtypedef struct avl_tree_struct avl_tree;
Xstruct avl_tree_struct `7B
X    avl_node *root;
X    int (*compar)();
X    int num_entries;
X    int modified;
X`7D;
X
X
Xtypedef struct avl_generator_struct avl_generator;
Xstruct avl_generator_struct `7B
X    avl_tree *tree;
X    avl_node **nodelist;
X    int count;
X`7D;
X
X
X#define AVL_FORWARD `090
X#define AVL_BACKWARD `091
X
X
X#if defined(__STDC__) && __STDC__
Xextern avl_tree *avl_init_table _ARGUMENTS((int (*)(const char*,const char*)
V));
X#else
Xextern avl_tree *avl_init_table ();
X#endif
Xextern int avl_delete _ARGUMENTS((avl_tree *,char **,char **));
Xextern int avl_insert _ARGUMENTS((avl_tree *,char *,char *));
Xextern int avl_insert_str _ARGUMENTS((avl_tree *,char *));
Xextern int avl_lookup _ARGUMENTS((avl_tree *,char *,char **));
Xextern int avl_count _ARGUMENTS((avl_tree *));
Xextern int avl_numcmp _ARGUMENTS((char *,char *));
Xextern int avl_gen _ARGUMENTS((avl_generator *,char **,char **));
Xextern void avl_foreach _ARGUMENTS((avl_tree *,void (*)(char *,char *),int))
V;
Xextern void avl_free_gen _ARGUMENTS((avl_generator *));
Xextern avl_generator *avl_init_gen _ARGUMENTS((avl_tree *,int));
Xextern void avl_free_table _ARGUMENTS((avl_tree *,void (*)(char *),
X    void (*)(char *)));
X
X#define avl_is_member(tree, key)`09avl_lookup(tree, key, (char **) 0)
X
X     /*
X      * Warning!  This macro does not check if the call to
X      * avl_init_gen succeeds, and it may fail if it runs out of
X      * memory.  Therefore, I don't recommend you use this macro at
X      * all.  I'm leaving it in only because it was here when I
X      * started working on the code.
X      */
X#define avl_foreach_item(table, gen, dir, key_p, value_p) `09\
X    for(gen = avl_init_gen(table, dir); `09`09`09\
X`09    avl_gen(gen, key_p, value_p) `7C`7C (avl_free_gen(gen),0);)
X
X#endif /* AVL_H */
$ CALL UNPACK AVL.H;6 1483558505
$ create 'f'
X#define bigicon_width 32
X#define bigicon_height 32
Xstatic unsigned char bigicon_bits`5B`5D = `7B
X   0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa, 0xfd, 0xff, 0xff, 0x5f,
X   0x06, 0x00, 0x00, 0xa0, 0xf5, 0xff, 0xff, 0x6f, 0xf6, 0x8c, 0x5a, 0xaf,
X   0xf5, 0xaa, 0xba, 0x6f, 0xf6, 0xac, 0xb2, 0xaf, 0xf5, 0xff, 0xff, 0x6f,
X   0xf6, 0x95, 0x9a, 0xaf, 0xf5, 0xd1, 0xda, 0x6f, 0xf6, 0x95, 0xc8, 0xaf,
X   0xf5, 0xff, 0xff, 0x6f, 0x16, 0x00, 0x00, 0xa8, 0xf5, 0xff, 0xff, 0x6f,
X   0xf6, 0xff, 0xff, 0xaf, 0x75, 0x0e, 0xd0, 0x6c, 0x96, 0xe9, 0x17, 0xaa,
X   0xf5, 0xef, 0xf7, 0x6f, 0x76, 0xcf, 0x96, 0xa8, 0x95, 0xe8, 0xf7, 0x6f,
X   0xf6, 0xef, 0x76, 0xa8, 0x95, 0x08, 0x17, 0x6b, 0x76, 0xee, 0xf7, 0xaf,
X   0xf5, 0x0f, 0x90, 0x68, 0x16, 0xf8, 0x3f, 0xaf, 0xf5, 0x8e, 0xf0, 0x6f,
X   0xf6, 0xff, 0xff, 0xaf, 0x05, 0x00, 0x00, 0x60, 0xfe, 0xff, 0xff, 0xbf,
X   0x55, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0xaa, 0xaa`7D;
X
X#define bigicon_i_width 32
X#define bigicon_i_height 32
Xstatic unsigned char bigicon_i_bits`5B`5D = `7B
X   0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55, 0x02, 0x00, 0x00, 0xa0,
X   0xf9, 0xff, 0xff, 0x5f, 0x0a, 0x00, 0x00, 0x90, 0x09, 0x73, 0xa5, 0x50,
X   0x0a, 0x55, 0x45, 0x90, 0x09, 0x53, 0x4d, 0x50, 0x0a, 0x00, 0x00, 0x90,
X   0x09, 0x6a, 0x65, 0x50, 0x0a, 0x2e, 0x25, 0x90, 0x09, 0x6a, 0x37, 0x50,
X   0x0a, 0x00, 0x00, 0x90, 0xe9, 0xff, 0xff, 0x57, 0x0a, 0x00, 0x00, 0x90,
X   0x09, 0x00, 0x00, 0x50, 0x8a, 0xf1, 0x2f, 0x93, 0x69, 0x16, 0xe8, 0x55,
X   0x0a, 0x10, 0x08, 0x90, 0x89, 0x30, 0x69, 0x57, 0x6a, 0x17, 0x08, 0x90,
X   0x09, 0x10, 0x89, 0x57, 0x6a, 0xf7, 0xe8, 0x94, 0x89, 0x11, 0x08, 0x50,
X   0x0a, 0xf0, 0x6f, 0x97, 0xe9, 0x07, 0xc0, 0x50, 0x0a, 0x71, 0x0f, 0x90,
X   0x09, 0x00, 0x00, 0x50, 0xfa, 0xff, 0xff, 0x9f, 0x01, 0x00, 0x00, 0x40,
X   0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55`7D;
$ CALL UNPACK BIGICON.XBM;2 1518162136
$ create 'f'
X#ifndef BUTDEFS_H
X#define BUTDEFS_H
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/butdefs.h,v 1.3 1993
V/01/11 02:14:16 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * butdefs.h: define buttons
X *
X */
X
X#undef lint
X#ifdef lint
X#define BUTTON(nm)
X#else
X#if defined(__STDC__) && !defined(UNIXCPP)
X#define BUTTON(nm)`09`09`09`09\
Xvoid nm##Function();`09`09`09`09\
Xstatic void nm##Action(widget, event, string, count) \
XWidget widget;`09`09`09`09`09\
XXEvent *event;`09`09`09`09`09\
XString *string;`09`09`09`09`09\
XCardinal *count;`09`09`09`09\
X`7B`09`09`09`09`09`09\
X    if (inCommand) `7B`09`09`09`09\
X`09XBell(XtDisplay(TopLevel), 0);`09`09\
X`09return;`09`09`09`09`09\
X    `7D`09`09`09`09`09`09\
X    inCommand = 1;`09`09`09`09\
X    removeTimeOut();`09`09`09`09\
X    busyCursor();`09`09`09`09\
X    nm##Function(widget, event, string, count);`09\
X    unbusyCursor();`09`09`09`09\
X    addTimeOut();`09`09`09`09\
X    inCommand = 0;`09`09`09`09\
X    return;`09`09`09`09`09\
X`7D`09`09`09`09`09`09\
X/*ARGSUSED*/                                    \
Xstatic void nm##Button(widget, client_data, call_data) \
XWidget widget;`09`09`09`09`09\
Xcaddr_t client_data;`09`09`09`09\
Xcaddr_t call_data;`09`09`09`09\
X`7B`09`09`09`09`09`09\
X    nm##Action(widget, NULL, 0, 0);`09`09\
X    return;`09`09`09`09`09\
X`7D`09`09`09`09`09`09\
Xexternaldef (nm##callbacks) XtCallbackRec nm##Callbacks`5B`5D = `7B`09\
X    `7B(XtCallbackProc)nm##Button, NULL`7D,`09`09\
X    `7BNULL, NULL`7D`09`09`09`09\
X`7D;`09`09`09`09`09`09\
Xstatic Arg nm##Args`5B`5D = `7B`09`09`09\
X    `7BXtNname,`09`09(XtArgVal) #nm`7D,`09\
X    `7BXmNlabelString,`09(XtArgVal) NULL`7D,`09\
X    `7BXmNactivateCallback, (XtArgVal) nm##Callbacks`7D,\
X    `7BXmNborderWidth,`09(XtArgVal) 1`7D,`09`09\
X`7D;
X#else
X#define BUTTON(nm)`09`09`09`09\
Xvoid nm/**/Function();`09`09`09`09\
Xstatic void nm/**/Action(widget, event, string, count) \
XWidget widget;`09`09`09`09`09\
XXEvent *event;`09`09`09`09`09\
XString *string;`09`09`09`09`09\
XCardinal *count;`09`09`09`09\
X`7B`09`09`09`09`09`09\
X    if (inCommand) `7B`09`09`09`09\
X`09XBell(XtDisplay(TopLevel), 0);`09`09\
X`09return;`09`09`09`09`09\
X    `7D`09`09`09`09`09`09\
X    inCommand = 1;`09`09`09`09\
X    removeTimeOut();`09`09`09`09\
X    busyCursor();`09`09`09`09\
X    nm/**/Function(widget, event, string, count); \
X    unbusyCursor();`09`09`09`09\
X    addTimeOut();`09`09`09`09\
X    inCommand = 0;`09`09`09`09\
X    return;`09`09`09`09`09\
X`7D`09`09`09`09`09`09\
X/*ARGSUSED*/`09`09`09`09`09\
Xstatic void nm/**/Button(widget, client_data, call_data)`09\
XWidget widget;`09`09`09`09`09\
Xcaddr_t client_data;`09`09`09`09\
Xcaddr_t call_data;`09`09`09`09\
X`7B`09`09`09`09`09`09\
X    nm/**/Action(widget, NULL, 0, 0);`09`09\
X    return;`09`09`09`09`09\
X`7D`09`09`09`09`09`09\
Xexternaldef (nm/**/callbacks) XtCallbackRec nm/**/Callbacks`5B`5D = `7B`09\
X    `7B(XtCallbackProc)nm/**/Button, NULL`7D,`09\
X    `7BNULL, NULL`7D`09`09`09`09\
X`7D;`09`09`09`09`09`09\
Xstatic Arg nm/**/Args`5B`5D = `7B`09`09`09\
X    `7BXtNname,`09`09(XtArgVal) "nm"`7D,`09\
X    `7BXmNlabelString,`09(XtArgVal) NULL`7D,`09\
X    `7BXmNactivateCallback, (XtArgVal) nm/**/Callbacks`7D,\
X    `7BXmNborderWidth,`09(XtArgVal) 1`7D,`09`09\
X`7D;
X#endif
X#endif
X
X#undef lint
X#ifdef lint
X#define BUTTON(nm)
X#else
X#if defined(__STDC__) && !defined(UNIXCPP)
X#define intBUTTON(nm)`09`09`09\
Xvoid nm##Function();`09`09`09`09\
X/*ARGSUSED*/`09`09`09`09`09\
Xstatic void nm##Action(widget, event, string, count) \
XWidget widget;`09`09`09`09`09\
XXEvent *event;`09`09`09`09`09\
XString *string;`09`09`09`09`09\
XCardinal *count;`09`09`09`09\
X`7B`09`09`09`09`09`09\
X    nm##Function(widget, event, string, count);`09\
X    return;`09`09`09`09`09\
X`7D`09`09`09`09`09`09\
Xexternaldef (nm##callbacks) XtCallbackRec nm##Callbacks`5B`5D = `7B`09\
X    `7B(XtCallbackProc)nm##Function, NULL`7D,`09\
X    `7BNULL, NULL`7D`09`09`09`09\
X`7D;`09`09`09`09`09`09\
Xstatic Arg nm##Args`5B`5D = `7B`09`09`09\
X    `7BXtNname,`09`09(XtArgVal) #nm`7D,`09\
X    `7BXmNlabelString,`09(XtArgVal) NULL`7D,`09\
X    `7BXmNactivateCallback, (XtArgVal) nm##Callbacks`7D,\
X    `7BXmNborderWidth,`09(XtArgVal) 1`7D,`09`09\
X`7D;
X#else
X#define intBUTTON(nm)`09`09`09`09\
Xvoid nm/**/Function();`09`09`09`09\
X/*ARGSUSED*/`09`09`09`09`09\
Xstatic void nm/**/Action(widget, event, string, count) \
XWidget widget;`09`09`09`09`09\
XXEvent *event;`09`09`09`09`09\
XString *string;`09`09`09`09`09\
XCardinal *count;`09`09`09`09\
X`7B`09`09`09`09`09`09\
X    nm/**/Function(widget, event, string, count); \
X    return;`09`09`09`09`09\
X`7D`09`09`09`09`09`09\
Xexternaldef (nm/**/callbacks) XtCallbackRec nm/**/Callbacks`5B`5D = `7B`09\
X    `7B(XtCallbackProc)nm/**/Function, NULL`7D,`09\
X    `7BNULL, NULL`7D`09`09`09`09\
X`7D;`09`09`09`09`09`09\
Xstatic Arg nm/**/Args`5B`5D = `7B`09`09`09\
X    `7BXtNname,`09`09(XtArgVal) "nm"`7D,`09\
X    `7BXmNlabelString, (XtArgVal) NULL`7D,`09`09\
X    `7BXmNactivateCallback, (XtArgVal) nm/**/Callbacks`7D,\
X    `7BXmNborderWidth,`09(XtArgVal) 1`7D,`09`09\
X`7D;
X#endif
X#endif
X
X#endif /* BUTDEFS_H */
$ CALL UNPACK BUTDEFS.H;3 896829184
$ create 'f'
X#if !defined(lint) && !defined(SABER)
Xstatic char XRNrcsid`5B`5D = "$Header: /net/objy27/wrld/mnt11/ricks/src/mast
Ver/xrn/buttons.c,v 1.9 1993/02/04 18:22:03 ricks Exp $";
X#endif
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * buttons.c: create and handle the buttons
X *
X */
X
X#include "copyright.h"
X#include <stdio.h>
X#ifdef __STDC__
X#include <time.h>
X#ifndef VMS
X#include <unistd.h>
X#else
X#include <unixio.h>
X#include <unixlib.h>
Xextern int sys$getmsg();
X#endif
X#include <stdlib.h>
X#endif
X#include "config.h"
X#include "utils.h"
X#ifndef VMS
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#else
X#include <decw$include/Intrinsic.h>
X#include <decw$include/StringDefs.h>
X#endif
X#ifdef MOTIF
X#include <Xm/Xm.h>
X#include <Xm/PanedW.h>
X#include <Xm/Label.h>
X#include <Xm/PushB.h>
X#include <Xm/CascadeB.h>
X#include <Xm/TextP.h>
X#include <Xm/DialogS.h>
X#if (XmVERSION == 1) && (XmREVISION == 0) /* Motif V1.0 */
X#define MOTIF_V10
X#endif
X#else
X#ifndef VMS
X#include <X11/DECwDwtApplProg.h>
X#else
X#include <decw$include:DECwDwtApplProg.h>
X#endif
X#endif /* MOTIF */
X#include "compose.h"
X#include "cursor.h"
X#include "mesg.h"
X#include "dialogs.h"
X#include "modes.h"
X#include "resources.h"
X#include "internals.h"
X#include "save.h"
X#include "error_hnds.h"
X#include "xthelper.h"
X#include "xrn.h"
X#include "news.h"
X#include "buttons.h"
X#include "newsrcfile.h"
X#include "xmisc.h"
X#include "slist.h"
X#include "butdefs.h"
X
Xextern void PaneSetMinMax();
Xextern void SetButtonBoxSize();
X
X#ifndef MOTIF
X#define XmNlabelString DwtNlabel
X#define XmNactivateCallback DwtNactivateCallback
X#define XmNborderWidth DwtNborderWidth
X#endif
X
X#define GROUP_NAME_SIZE 128
X
Xextern void resetPopupSize();
Xextern void close_server();
Xextern void EditKillFile();
X
X#ifdef VMS
X#include <descrip.h>
X#endif
X
Xstatic Widget UnSubConfirmBox = NULL;
Xstatic Widget *AddButtons = NIL(Widget);
Xstatic Widget *NgButtons = NIL(Widget);
Xstatic Widget *AllButtons = NIL(Widget);
Xstatic Widget *ArtButtons = NIL(Widget);
Xstatic Widget *ArtSpecButtons = NIL(Widget);
Xexternalref Widget ngMenus`5B5`5D;
Xexternalref Widget artMenus`5B7`5D;
Xexternalref Widget allMenus`5B5`5D;
Xexternalref Widget addMenus`5B3`5D;
Xexternalref Widget *AddPopupButtons;
Xexternalref Widget *NgPopupButtons;
Xexternalref Widget *AllPopupButtons;
Xexternalref Widget *ArtPopupButtons;
Xexternalref Widget *ArtWinPopupButtons;
X
Xstatic struct newsgroup **AddGroups =  (struct newsgroup **) 0; /* new newsg
Vroups list ...`09   */
Xstatic ng_num *NewsGroups = (ng_num *) 0; /* newsgroups list that is display
Ved */
Xstatic ng_num *AllGroups = (ng_num *) 0;  /* list of all groups so the user
V */
X`09`09`09`09`09  /* can subscribe/unsubscribe to them */
Xstatic art_num *ArticleNumbers = (art_num *) 0; /* Article numbers of displa
Vyed arts */
X
Xstatic int  GroupPosition = 0; `09/* cursor position in newsgroup window */
Xstatic int  AddGroupPosition = 0;/* cursor position in newsgroup window */
Xstatic int  GroupItems = 0;`09/* Number of groups */
Xstatic int  AddGroupItems = 0;`09/* Number of new groups */
Xstatic int  ArtPosition = 0;`09/* cursor position in article subject window
V */
Xstatic int  SubjectItems = 0;`09/* Number of subjects */
Xstatic int  AllPosition = 0;`09/* position in all groups window */
Xstatic int  AllGroupItems = 0;`09/* Number of items in All Groups strings */
X
Xstatic char LastGroup`5BGROUP_NAME_SIZE`5D;`09/* last newsgroup accessed; us
Ved to */
X`09`09`09`09/* determine whether or not to move the */
X`09`09`09`09/* cursor in the newsgroup window */
X
Xstatic art_num CurrentArticle;`09/* the number of the article currently */
X`09`09`09`09/* displayed, used for marking an article */
X`09`09`09`09/* as saved */
X
Xstatic art_num PrevArticle;`09/* the number of the article displayed */
X`09`09`09`09/* before the current one */
X
Xstatic int ArtStatus = 0;`09/* keeps track of what kind of article to */
X`09`09`09`09/* search for: next, previous, or next */
X`09`09`09`09/* unread */
Xstatic int AllStatus = 0;`09/* keeps track of which order to put the */
X`09`09`09`09/* groups in in all groups mode */
Xstatic char *LastRegexp;`09/* last regular expression searched for */
Xstatic int LastSearch;`09`09/* the direction of the last regular */
X`09`09`09`09/* expression search */
X
Xstatic int LastWasAuthor = 0;`09/* Type of last search */
Xstatic char *selList = NULL;`09/* Keeps the selected entry array */
Xstatic int selSize = 0;`09`09/* current size of the array */
Xstatic int selCount = 0;`09/* selection count */
X
Xstatic int Action;`09`09/* action to take when a confirmation box */
X`09`09`09`09/* is clicked in */
X
Xstatic int SelectionItem = -1;`09/* List item selected */
Xstatic int SelectionCount= 0;`09/* Number of items selected */
X
Xstatic int NewsgroupDisplayMode = 0;`09/* 0 for unread groups, 1 for all sub
V */
X#define XRN_JUMP 0
X#define XRN_GOTO 1
Xstatic int NewsgroupEntryMode = XRN_GOTO;
X
Xstatic Boolean oldListed = False;/* TRUE if in LIST OLD mode */
Xstatic art_num oldInitial = 0;`09/* Saved initial article # */
X
Xstatic Boolean ArtPoppedUp = False;
X
Xstatic char *SaveString = NULL;`09/* Last input to save box */
Xstatic int ArtEntry = 1;
Xstatic int currentTop = 0;`09/* Current list top entry */
Xstatic int saveTop = 0;`09`09/* saved top entry */
X
XBoolean printPending = 0;`09/* True if print file pending */
X
Xstatic Boolean unreadNews = False;`09/* True if unread news */
X
X/* article mode "modes" ... determines what to do: jump out of article */
X/* mode, change the subject string, or do nothing */
X#define art_DONE 0
X#define art_CHANGE 1
X#define art_NOCHANGE 2
X
X/* keeps track of which type of article to search for: Next, Unread, or */
X/* previous */
X#define art_NEXT 0
X#define art_UNREAD 1
X#define art_PREV 2
X#define art_CURRENT 3
X#define art_FINDUNREAD 4
X
Xint Mode = NO_MODE;`09`09`09/* current mode */
Xstatic int PreviousMode = NO_MODE;`09/* previous mode, what buttons to */
X`09`09`09`09`09/* remove */
X
X#define XRN_NO 0
X#define XRN_YES 1
X
X/* the user is in a command - eat type ahead */
Xint inCommand = 0;
Xextern Boolean ComposeActive;
X
Xstatic struct _translations `7B
X    Widget widget;
X    XtTranslations tables`5BMAX_MODE`5D;
X    char *unparsed`5BMAX_MODE`5D;
X`7D Translations`5B7`5D;
X
Xstatic void listSelect();
Xstatic void DoubleClick();
Xstatic void GetData();
Xstatic void subjSetPos();
Xstatic void resetSubjectWidget();
Xstatic void catchUpNG();
Xstatic void unsubscribeNG();
Xstatic void catchUpART();
Xstatic void catchUpPartART();
Xstatic void unsubscribeART();
Xstatic void switchToAllMode();
Xstatic void fedUpART();
Xstatic void setTitleBar();
Xextern XtActionProc slistForwardPage();
Xextern XtActionProc slistBackwardPage();
Xextern XtActionProc slistForwardLine();
Xextern XtActionProc slistBackwardLine();
Xstatic XtActionProc listForwardPage();
Xstatic XtActionProc listBackwardPage();
Xstatic XtActionProc listForwardLine();
Xstatic XtActionProc listBackwardLine();
Xstatic XtActionProc artReadCurrent();
Xstatic Boolean      artCheckReadCurrent();
X
X/* handle autorescan timeouts */
X
Xstatic XtIntervalId TimeOut = 0;
Xvoid autoRescan();
Xvoid autoExitAddMode();
X
X/*ARGSUSED*/
Xstatic void timerRoutine(data, id)
Xcaddr_t data;
XXtIntervalId *id;
X`7B
X    if (inCommand `7C`7C (Mode != NEWSGROUP_MODE && Mode != ADD_MODE)) `7B
X`09TimeOut = 0;
X`09return;
X    `7D
X    if (TimeOut != *id) `7B
X`09(void) fprintf(stderr, "bad time out, id is %d, expected %d\n", *id, Time
VOut);
X`09TimeOut = 0;
X`09return;
X    `7D
X    if (Mode == NEWSGROUP_MODE) `7B
X`09autoRescan(data, id);
X    `7D else `7B
X`09if (Mode == ADD_MODE) `7B
X`09    autoExitAddMode(data, id);
X`09`7D
X    `7D
X`7D
Xvoid addTimeOut()
X`7B
X#if defined(MOTIF) && !defined(MOTIF_V10)
X    XmProcessTraversal(TopList,XmTRAVERSE_CURRENT);
X    XmProcessTraversal(ArticleText,XmTRAVERSE_CURRENT);
X#endif
X
X    if (app_resources.rescanTime <= 0) `7B
X`09return;
X    `7D
X
X    /* do not allow recursive timeouts */
X    if (TimeOut) `7B
X`09return;
X    `7D
X
X    /* handle race conditions??? */
X    TimeOut = 1;
X
X    TimeOut = XtAddTimeOut(app_resources.rescanTime * 1000,
X`09 (XtTimerCallbackProc) timerRoutine, 0);
X    return;
X`7D
X
Xvoid removeTimeOut()
X`7B
X    XtIntervalId temp;
X
X    /* handle race conditions??? */
X    temp = TimeOut;
X    TimeOut = 0;
X
X    /* do not allow recursive timeouts */
X    if (temp) `7B
X`09XtRemoveTimeOut(temp);
X    `7D
X    return;
X`7D
X
X/*
X * The newsgroup and article command buttons
X *
X *    To add a button:
X *
X *      - add the appropriate static Arg`5B`5D for describing the button
X *`09  label and handler (define the return value of the handler)
X *      - add the variable and size to the apropriate *ButtonList
X *      - add it to the actions table and the keyactions table
X *
X */
X
XBUTTON(addQuit)
XBUTTON(addFirst)
XBUTTON(addLast)
XBUTTON(addAfter)
XBUTTON(addUnsub)
X
XBUTTON(ngExit)
XBUTTON(ngQuit)
XBUTTON(ngRead)
XBUTTON(ngOpen)
XBUTTON(ngNext)
XBUTTON(ngPrev)
XBUTTON(ngCatchUp)
XBUTTON(ngSubscribe)
XBUTTON(ngUnsub)
XBUTTON(ngGoto)
XBUTTON(ngToggleGroups)
XBUTTON(ngAllGroups)
XBUTTON(ngRescan)
XBUTTON(ngPrevGroup)
XBUTTON(ngSelect)
XBUTTON(ngMove)
XBUTTON(ngCheckPoint)
XBUTTON(ngDisconnect)
XBUTTON(ngPost)
XBUTTON(ngGripe)
X
XBUTTON(allQuit)
XBUTTON(allSub)
XBUTTON(allFirst)
XBUTTON(allLast)
XBUTTON(allAfter)
XBUTTON(allUnsub)
XBUTTON(allGoto)
XBUTTON(allOpen)
XBUTTON(allSelect)
XBUTTON(allMove)
XBUTTON(allToggle)
XBUTTON(allScroll)
XBUTTON(allScrollBack)
XBUTTON(allPost)
XBUTTON(allSearch)
XBUTTON(allContinue)
XintBUTTON(allCancelSearch)
X
XBUTTON(artQuit)
XBUTTON(artNext)
XBUTTON(artNextUnread)
XBUTTON(artPrev)
XBUTTON(artLast)
XBUTTON(artNextGroup)
XBUTTON(artGotoArticle)
XBUTTON(artCatchUp)
XBUTTON(artCatchUpAll)
XBUTTON(artFedUp)
XBUTTON(artMarkRead)
XBUTTON(artMarkUnread)
XBUTTON(artUnsub)
XBUTTON(artScroll)
XBUTTON(artScrollBack)
XBUTTON(artScrollEnd)
XBUTTON(artScrollBeginning)
XBUTTON(artScrollLine)
XBUTTON(artScrollBackLine)
XBUTTON(artScrollIndex)
XBUTTON(artScrollIndexBack)
XBUTTON(artSubNext)
XBUTTON(artSubPrev)
XBUTTON(artKillSession)
XBUTTON(artKillLocal)
XBUTTON(artKillGlobal)
XBUTTON(artKillAuthor)
XBUTTON(artEditKillFile)
XBUTTON(artEditGlobalKillFile)
XBUTTON(artSubSearch)
XBUTTON(artAuthorSearch)
XBUTTON(artContinue)
XintBUTTON(artCancelSearch)
XBUTTON(artNonSorted)
XBUTTON(artSorted)
XBUTTON(artStrictSorted)
XBUTTON(artThreadSorted)
XBUTTON(artPost)
XBUTTON(artExit)
XBUTTON(artCheckPoint)
XBUTTON(artGripe)
XBUTTON(artListOld)
X
XBUTTON(artSave)
XBUTTON(artReply)
XBUTTON(artForward)
XBUTTON(artFollowup)
XBUTTON(artFollowupReply)
XBUTTON(artCancel)
XBUTTON(artRot13)
X#ifdef XLATE
XBUTTON(artXlate)
X#endif /* XLATE */
XBUTTON(artHeader)
XBUTTON(artPrint)
X
Xstatic void doTheRightThing _ARGUMENTS((Widget, XEvent *,String *,Cardinal *
V));
Xstatic XtActionsRec TopActions`5B`5D = `7B
X    `7B"doTheRightThing",`09   (XtActionProc) doTheRightThing`7D,
X    `7B"list-forward-page",  (XtActionProc) listForwardPage`7D,
X    `7B"list-backward-page", (XtActionProc) listBackwardPage`7D,
X    `7B"list-forward-line",  (XtActionProc) listForwardLine`7D,
X    `7B"list-backward-line", (XtActionProc) listBackwardLine`7D,
X`7D;
X
Xvoid abortSet();
X
Xstatic XtActionsRec AddActions`5B`5D = `7B
X    `7B"addQuit",`09`09(XtActionProc) addQuitAction`7D,
X    `7B"addFirst",`09(XtActionProc) addFirstAction`7D,
X    `7B"addLast",`09`09(XtActionProc) addLastAction`7D,
X    `7B"addAfter",`09(XtActionProc) addAfterAction`7D,
X    `7B"addUnsub",`09(XtActionProc) addUnsubAction`7D,
X`7D;
X
Xstatic XtActionsRec NgActions`5B`5D = `7B
X    `7B"ngQuit",`09`09(XtActionProc) ngQuitAction`7D,
X    `7B"ngRead",`09`09(XtActionProc) ngReadAction`7D,
X    `7B"ngOpen",`09`09(XtActionProc) ngOpenAction`7D,
X    `7B"ngNext",`09`09(XtActionProc) ngNextAction`7D,
X    `7B"ngPrev",`09`09(XtActionProc) ngPrevAction`7D,
X    `7B"ngCatchUp",`09(XtActionProc) ngCatchUpAction`7D,
X    `7B"ngSubscribe",`09(XtActionProc) ngSubscribeAction`7D,
X    `7B"ngUnsub",`09`09(XtActionProc) ngUnsubAction`7D,
X    `7B"ngGoto",`09`09(XtActionProc) ngGotoAction`7D,
X    `7B"ngRescan",`09(XtActionProc) ngRescanAction`7D,
X    `7B"ngAllGroups",`09(XtActionProc) ngAllGroupsAction`7D,
X    `7B"ngToggleGroups",`09(XtActionProc) ngToggleGroupsAction`7D,
X    `7B"ngPrevGroup",`09(XtActionProc) ngPrevGroupAction`7D,
X    `7B"ngSelect",`09(XtActionProc) ngSelectAction`7D,
X    `7B"ngMove",`09`09(XtActionProc) ngMoveAction`7D,
X    `7B"ngExit",`09`09(XtActionProc) ngExitAction`7D,
X    `7B"ngGripe",`09`09(XtActionProc) ngGripeAction`7D,
X    `7B"ngPost",`09`09(XtActionProc) ngPostAction`7D,
X    `7B"ngDisconnect",`09(XtActionProc) ngDisconnectAction`7D,
X    `7B"ngCheckPoint",`09(XtActionProc) ngCheckPointAction`7D,
X`7D;   `20
Xstatic XtActionsRec ArtActions`5B`5D = `7B
X    `7B"artQuit",`09`09(XtActionProc) artQuitAction`7D,
X    `7B"artNextUnread",`09(XtActionProc) artNextUnreadAction`7D,
X    `7B"artScroll",`09(XtActionProc) artScrollAction`7D,
X    `7B"artScrollBack",`09(XtActionProc) artScrollBackAction`7D,
X    `7B"artScrollLine",`09(XtActionProc) artScrollLineAction`7D,
X    `7B"artScrollBackLine", (XtActionProc) artScrollBackLineAction`7D,
X    `7B"artScrollEnd",`09(XtActionProc) artScrollEndAction`7D,
X    `7B"artScrollBeginning",(XtActionProc) artScrollBeginningAction`7D,
X    `7B"artScrollIndex",`09(XtActionProc) artScrollIndexAction`7D,
X    `7B"artScrollIndexBack", (XtActionProc) artScrollIndexBackAction`7D,
X    `7B"artNext",`09`09(XtActionProc) artNextAction`7D,
X    `7B"artPrev",`09`09(XtActionProc) artPrevAction`7D,
X    `7B"artLast",`09`09(XtActionProc) artLastAction`7D,
X    `7B"artNextGroup",`09(XtActionProc) artNextGroupAction`7D,
X    `7B"artCatchUp",`09(XtActionProc) artCatchUpAction`7D,
X    `7B"artCatchUpAll",`09(XtActionProc) artCatchUpAllAction`7D,
X    `7B"artFedUp",`09(XtActionProc) artFedUpAction`7D,
X    `7B"artGotoArticle",`09(XtActionProc) artGotoArticleAction`7D,
X    `7B"artMarkRead",`09(XtActionProc) artMarkReadAction`7D,
X    `7B"artMarkUnread",`09(XtActionProc) artMarkUnreadAction`7D,
X    `7B"artUnsub",`09(XtActionProc) artUnsubAction`7D,
X    `7B"artSubNext",`09(XtActionProc) artSubNextAction`7D,
X    `7B"artSubPrev",`09(XtActionProc) artSubPrevAction`7D,
X    `7B"artKillSession",`09(XtActionProc) artKillSessionAction`7D,
X    `7B"artKillLocal",`09(XtActionProc) artKillLocalAction`7D,
X    `7B"artKillGlobal",`09(XtActionProc) artKillGlobalAction`7D,
X    `7B"artKillAuthor",`09(XtActionProc) artKillAuthorAction`7D,
X    `7B"artEditKillFile", (XtActionProc) artEditKillFileAction`7D,
X    `7B"artEditGlobalKillFile", (XtActionProc) artEditGlobalKillFileAction`7
VD,
X    `7B"artSubSearch",`09(XtActionProc) artSubSearchAction`7D,
X    `7B"artAuthorSearch",`09(XtActionProc) artAuthorSearchAction`7D,
X    `7B"artContinue",`09(XtActionProc) artContinueAction`7D,
X    `7B"artCancelSearch",`09(XtActionProc) artCancelSearchAction`7D,
X    `7B"artNonSorted",`09(XtActionProc) artNonSortedAction`7D,
X    `7B"artSorted",`09(XtActionProc) artSortedAction`7D,
X    `7B"artStrictSorted",`09(XtActionProc) artStrictSortedAction`7D,
X    `7B"artThreadSorted",`09(XtActionProc) artThreadSortedAction`7D,
X    `7B"artPost",`09`09(XtActionProc) artPostAction`7D,
X    `7B"artExit",`09`09(XtActionProc) artExitAction`7D,
X    `7B"artCheckPoint",`09(XtActionProc) artCheckPointAction`7D,
X    `7B"artSave",`09`09(XtActionProc) artSaveAction`7D,
X    `7B"artReply",`09(XtActionProc) artReplyAction`7D,
X    `7B"artForward",`09(XtActionProc) artForwardAction`7D,
X    `7B"artFollowup",`09(XtActionProc) artFollowupAction`7D,
X    `7B"artFollowupReply",(XtActionProc) artFollowupReplyAction`7D,
X    `7B"artCancel",`09(XtActionProc) artCancelAction`7D,
X    `7B"artRot13",`09(XtActionProc) artRot13Action`7D,
X#ifdef XLATE
X    `7B"artXlate",`09(XtActionProc) artXlateAction`7D,
X#endif /* XLATE */
X    `7B"artHeader",`09(XtActionProc) artHeaderAction`7D,
X    `7B"artPrint",`09(XtActionProc) artPrintAction`7D,
X    `7B"artGripe",`09(XtActionProc) artGripeAction`7D,
X    `7B"artListOld",`09(XtActionProc) artListOldAction`7D,
X    `7B"artReadCurrent",`09(XtActionProc) artReadCurrent`7D,
X`7D;
X
Xstatic XtActionsRec AllActions`5B`5D = `7B
X    `7B"allQuit",`09`09(XtActionProc) allQuitAction`7D,
X    `7B"allSub",`09`09(XtActionProc) allSubAction`7D,
X    `7B"allFirst",`09(XtActionProc) allFirstAction`7D,
X    `7B"allLast",`09`09(XtActionProc) allLastAction`7D,
X    `7B"allAfter",`09(XtActionProc) allAfterAction`7D,
X    `7B"allUnsub",`09(XtActionProc) allUnsubAction`7D,
X    `7B"allGoto",`09`09(XtActionProc) allGotoAction`7D,
X    `7B"allOpen",`09`09(XtActionProc) allOpenAction`7D,
X    `7B"allSelect",`09(XtActionProc) allSelectAction`7D,
X    `7B"allMove",`09`09(XtActionProc) allMoveAction`7D,
X    `7B"allToggle",`09(XtActionProc) allToggleAction`7D,
X    `7B"allScroll",`09(XtActionProc) allScrollAction`7D,
X    `7B"allScrollBack",`09(XtActionProc) allScrollBackAction`7D,
X    `7B"allPost",`09`09(XtActionProc) allPostAction`7D,
X    `7B"allSearch",`09(XtActionProc) allSearchAction`7D,
X    `7B"allContinue",`09(XtActionProc) allContinueAction`7D,
X    `7B"allCancelSearch", (XtActionProc) allCancelSearchAction`7D,
X`7D;
X
Xtypedef struct buttonList `7B
X    char *label;
X    Arg *buttonArgs;
X    unsigned int size;
X    char *message;
X`7D ButtonList;
X
Xexternaldef(addbuttonlist) ButtonList AddButtonList`5B`5D = `7B
X    `7B"Exit", addQuitArgs, XtNumber(addQuitArgs),
X   "Exit add mode, unsubscribe remaining groups and append to your .newsrc"`
V7D,
X#ifdef NEWBUTTONS
X    `7B"Prepend Subscribed", addFirstArgs, XtNumber(addFirstArgs),
X   "Subscribe to selected group(s), prepend to your .newsrc"`7D,
X    `7B"Append Subscribed", addLastArgs, XtNumber(addLastArgs),
X   "Subscribe to selected group(s), append to your .newsrc"`7D,
X    `7B"Position Subscribed", addAfterArgs, XtNumber(addAfterArgs),
X   "Subscribe to selected group(s), add to your .newsrc after specific group
V"`7D,
X    `7B"Append Unsubscribed", addUnsubArgs, XtNumber(addUnsubArgs),
X   "Unsubscribe to selected group(s), append to your .newsrc"`7D,
X#else
X    `7B"Subscribe First", addFirstArgs, XtNumber(addFirstArgs),
X   "Subscribe to selected group(s), add to the beginning of your .newsrc fil
Ve"`7D,
X    `7B"Subscribe Last", addLastArgs, XtNumber(addLastArgs),
X   "Subscribe to selected group(s), add to the end of your .newsrc file"`7D,
X    `7B"Add After Group", addAfterArgs, XtNumber(addAfterArgs),
X   "Subscribe to selected group(s), add after a specific group in your .news
Vrc file"`7D,
X    `7B"Add Unsubscribed", addUnsubArgs, XtNumber(addUnsubArgs),
X   "Unsubscribe to selected group(s), append to your .newsrc"`7D,
X#endif
X`7D;
X
Xstatic int AddButtonListCount = XtNumber(AddButtonList);
Xexternaldef(addpopupcount) int AddPopupCount = XtNumber(AddButtonList);
X
Xexternaldef(ngbuttonlist) ButtonList NgButtonList`5B`5D = `7B
X    `7B"Quit", ngQuitArgs, XtNumber(ngQuitArgs),
X#ifdef MOTIF
X   "Quit MXRN"`7D,
X#else
X   "Quit DXRN"`7D,
X#endif
X    `7B"Read Group", ngReadArgs, XtNumber(ngReadArgs),
X   "Read the articles in the current group"`7D,
X    `7B"Open Group", ngOpenArgs, XtNumber(ngOpenArgs),
X   "Open the current group"`7D,
X    `7B"Next", ngNextArgs, XtNumber(ngNextArgs),
X   "Move the cursor to the next group"`7D,
X    `7B"Prev", ngPrevArgs, XtNumber(ngPrevArgs),
X   "Move the cursor to the previous group"`7D,
X#ifdef NEWBUTTONS
X    `7B"Mark All Read", ngCatchUpArgs, XtNumber(ngCatchUpArgs),
X#else
X    `7B"Catch Up", ngCatchUpArgs, XtNumber(ngCatchUpArgs),
X#endif
X   "Mark all articles in the current group as read"`7D,
X    `7B"Subscribe", ngSubscribeArgs, XtNumber(ngSubscribeArgs),
X   "Subscribe to a group"`7D,
X    `7B"Unsubscribe", ngUnsubArgs, XtNumber(ngUnsubArgs),
X   "Unsubscribe to the current group"`7D,
X    `7B"Go To Group", ngGotoArgs, XtNumber(ngGotoArgs),
X   "Go to a group"`7D,
X    `7B"All Groups", ngAllGroupsArgs, XtNumber(ngAllGroupsArgs),
X   "View all available groups, with option to change subscription status"`7D
V,
X    `7B"Toggle Groups", ngToggleGroupsArgs, XtNumber(ngToggleGroupsArgs),
X   "Show/hide groups with no new articles"`7D,
X    `7B"Rescan", ngRescanArgs, XtNumber(ngRescanArgs),
X   "Query the news server for new articles and groups"`7D,
X    `7B"Last Group", ngPrevGroupArgs, XtNumber(ngPrevGroupArgs),
X   "Return to the group last visited"`7D,
X    `7B"Select Groups", ngSelectArgs, XtNumber(ngSelectArgs),
X   "Mark current selections for subsequent move operations"`7D,
X    `7B"Move", ngMoveArgs, XtNumber(ngMoveArgs),
X   "Insert previously selected groups in front of the current group"`7D,
X    `7B"Exit", ngExitArgs, XtNumber(ngExitArgs),
X#ifdef MOTIF
X   "Quit MXRN, leaving your .newsrc unchanged since the last rescan"`7D,
X#else
X   "Quit DXRN, leaving your .newsrc unchanged since the last rescan"`7D,
X#endif
X    `7B"Disconnect", ngDisconnectArgs, XtNumber(ngDisconnectArgs),
X   "Disconnect from the news server until next action"`7D,
X    `7B"Checkpoint", ngCheckPointArgs, XtNumber(ngCheckPointArgs),
X   "Save changes to your .newsrc"`7D,
X    `7B"Gripe", ngGripeArgs, XtNumber(ngGripeArgs),
X   "Mail a gripe to the XRN maintainer"`7D,
X    `7B"Post", ngPostArgs, XtNumber(ngPostArgs),
X   "Post an article to a specific group"`7D,
X`7D;
X
Xstatic int NgButtonListCount = XtNumber(NgButtonList);
Xexternaldef(ngpopupcount) int NgPopupCount = XtNumber(NgButtonList);
X
Xexternaldef(allbuttonlist) ButtonList AllButtonList`5B`5D = `7B
X    `7B"Return", allQuitArgs, XtNumber(allQuitArgs),
X   "Return to Newsgroup mode, saving changes"`7D,
X    `7B"Subscribe", allSubArgs, XtNumber(allSubArgs),
X   "Subscribe to selected group(s)"`7D,
X    `7B"Subscribe First", allFirstArgs, XtNumber(allFirstArgs),
X   "Subscribe to selected group(s), move to start of .newsrc"`7D,
X    `7B"Subscribe Last", allLastArgs, XtNumber(allLastArgs),
X   "Subscribe to selected group(s), move to end of .newsrc"`7D,
X    `7B"Subscribe After Group", allAfterArgs, XtNumber(allAfterArgs),
X   "Subscribe to selected group(s), move to after specific group in .newsrc"
V`7D,
X    `7B"Unsubscribe", allUnsubArgs, XtNumber(allUnsubArgs),
X   "Unsubscribe to the selected group(s)"`7D,
X    `7B"Go To Group", allGotoArgs, XtNumber(allGotoArgs),
X   "Go to a specific group"`7D,
X    `7B"Open Group", allOpenArgs, XtNumber(allOpenArgs),
X   "Open the current group"`7D,
X    `7B"Select Groups", allSelectArgs, XtNumber(allSelectArgs),
X   "Mark current selections for subsequent move operations"`7D,
X    `7B"Move", allMoveArgs, XtNumber(allMoveArgs),
X   "Insert previously selected group(s) in front of current group"`7D,
X    `7B"Toggle Order", allToggleArgs, XtNumber(allToggleArgs),
X   "Change order of groups: alphabetical/.newsrc order"`7D,
X    `7B"Scroll Forward", allScrollArgs, XtNumber(allScrollArgs),
X   "Scroll the All Groups screen forward"`7D,
X    `7B"Scroll Backward", allScrollBackArgs, XtNumber(allScrollBackArgs),
X   "Scroll the All Groups screen backward"`7D,
X    `7B"Post", allPostArgs, XtNumber(allPostArgs),
X   "Post an article to a specific group"`7D,
X    `7B"Search", allSearchArgs, XtNumber(allSearchArgs),
X   "Search for specific group(s)"`7D,
X    `7B"Continue", allContinueArgs, XtNumber(allContinueArgs),
X   "Continue group search"`7D,
X    `7B"Cancel Search", allCancelSearchArgs, XtNumber(allCancelSearchArgs),
X   "Cancel group search"`7D,
X`7D;
X
Xstatic int AllButtonListCount = XtNumber(AllButtonList);
Xexternaldef(allpopupcount) int AllPopupCount = XtNumber(AllButtonList);
X
Xexternaldef(artbuttonlist) ButtonList ArtButtonList`5B`5D = `7B
X    `7B"Return", artQuitArgs, XtNumber(artQuitArgs),
X   "Return to previous mode"`7D,
X    `7B"Next Unread", artNextUnreadArgs, XtNumber(artNextUnreadArgs),
X   "Display the next unread article"`7D,
X    `7B"Next", artNextArgs, XtNumber(artNextArgs),
X   "Display the next article"`7D,
X    `7B"Scroll Forward", artScrollArgs, XtNumber(artScrollArgs),
X   "Scroll displayed article forward"`7D,
X    `7B"Scroll Backward", artScrollBackArgs, XtNumber(artScrollBackArgs),
X   "Scroll displayed article backward"`7D,
X    `7B"Scroll to End", artScrollEndArgs, XtNumber(artScrollEndArgs),
X   "Scroll to end of displayed article"`7D,
X    `7B"Scroll to Beginning", artScrollBeginningArgs, XtNumber(artScrollBegi
VnningArgs),
X   "Scroll to beginning of displayed article"`7D,
X    `7B"Scroll Index", artScrollIndexArgs, XtNumber(artScrollIndexArgs),
X   "Scroll index forward one page"`7D,
X    `7B"Scroll Index Back", artScrollIndexBackArgs, XtNumber(artScrollIndexB
VackArgs),
X   "Scroll index back one page"`7D,
X    `7B"Prev", artPrevArgs, XtNumber(artPrevArgs),
X   "Display the previous article"`7D,
X    `7B"Last", artLastArgs, XtNumber(artLastArgs),
X   "Redisplay the last article displayed"`7D,
X    `7B"Next group", artNextGroupArgs, XtNumber(artNextGroupArgs),
X   "*Go to the next group, skipping newsgroup mode"`7D,
X    `7B"Catch Up",artCatchUpArgs, XtNumber(artCatchUpArgs),
X   "Mark all articles (up to the current article) in the current group as re
Vad"`7D,
X    `7B"Catch Up All",artCatchUpAllArgs, XtNumber(artCatchUpAllArgs),
X   "Mark all articles in the current group as read and return to last mode"`
V7D,
X#ifdef NEWBUTTONS
X    `7B"Next Group, Read", artFedUpArgs, XtNumber(artFedUpArgs),
X#else
X    `7B"Fed Up", artFedUpArgs, XtNumber(artFedUpArgs),
X#endif
X   "*Mark all articles in the current group as read and go to next group "`7
VD,
X    `7B"Go To Article", artGotoArticleArgs, XtNumber(artGotoArticleArgs),
X   "Display a specific article number in the current group"`7D,
X    `7B"Mark Read", artMarkReadArgs, XtNumber(artMarkReadArgs),
X   "Mark selected article(s) as read"`7D,
X    `7B"Mark Unread", artMarkUnreadArgs, XtNumber(artMarkUnreadArgs),
X   "Mark selected article(s) as unread"`7D,
X    `7B"Unsubscribe", artUnsubArgs, XtNumber(artUnsubArgs),
X   "Unsubscribe to the current group"`7D,
X    `7B"Subject Next", artSubNextArgs, XtNumber(artSubNextArgs),
X   "Search for the next article with the same subject as the displayed artic
Vle"`7D,
X    `7B"Subject Prev", artSubPrevArgs, XtNumber(artSubPrevArgs),
X   "Search for the previous article with the same subject as the displayed a
Vrticle"`7D,
X    `7B"Session Kill", artKillSessionArgs, XtNumber(artKillSessionArgs),
X   "Mark all articles in this group with the same subject as the displayed a
Vrticle as read, for this session only"`7D,
X    `7B"Local Kill", artKillLocalArgs, XtNumber(artKillLocalArgs),
X   "Mark all articles in this group with the same subject as the displayed a
Vrticle as read, forever"`7D,
X    `7B"Global Kill", artKillGlobalArgs, XtNumber(artKillGlobalArgs),
X   "Mark all articles in all groups with the same subject as the displayed a
Vrticle as read, forever"`7D,
X    `7B"Author Local Kill", artKillAuthorArgs, XtNumber(artKillAuthorArgs),
X   "Mark all articles in this group with the same author as the displayed ar
Vticle as read, forever"`7D,
X    `7B"Edit Kill File", artEditKillFileArgs, XtNumber(artEditKillFileArgs),
X   "Edit the kill file for this group"`7D,
X    `7B"Edit Global Kill File", artEditGlobalKillFileArgs,
X     XtNumber(artEditGlobalKillFileArgs), "Edit the global kill file"`7D,
X    `7B"Subject Search", artSubSearchArgs, XtNumber(artSubSearchArgs),
X   "Search index subject fields for a regular expression"`7D,
X    `7B"Author Search", artAuthorSearchArgs, XtNumber(artAuthorSearchArgs),
X   "Search index author fields for a regular expression"`7D,
X    `7B"Continue", artContinueArgs, XtNumber(artContinueArgs),
X   "Continue the regular expression subject/author search"`7D,
X    `7B"Cancel Search", artCancelSearchArgs, XtNumber(artCancelSearchArgs),
X   "Cancel subject/author search"`7D,
X    `7B"Post", artPostArgs, XtNumber(artPostArgs),
X   "Post an article to this group"`7D,
X    `7B"Article Order", artNonSortedArgs, XtNumber(artNonSortedArgs),
X   "Display articles in article number order"`7D,
X    `7B"Subject Order", artSortedArgs, XtNumber(artSortedArgs),
X   "Display articles in subject order (subsorted by article number)"`7D,
X    `7B"Strict Order", artStrictSortedArgs, XtNumber(artStrictSortedArgs),
X   "Display articles in strict subject order"`7D,
X    `7B"Thread Order", artThreadSortedArgs, XtNumber(artThreadSortedArgs),
X   "Display articles in threaded subject order"`7D,
X#ifdef NEWBUTTONS
X    `7B"Return, Unread", artExitArgs, XtNumber(artExitArgs),
X#else
X    `7B"Exit", artExitArgs, XtNumber(artExitArgs),
X#endif
X   "Return to previous mode, marking all articles in current group as unread
V"`7D,
X    `7B"Checkpoint", artCheckPointArgs, XtNumber(artCheckPointArgs),
X   "Save changes to your .newsrc"`7D,
X    `7B"Gripe", artGripeArgs, XtNumber(artGripeArgs),
X   "Mail a gripe to the XRN maintainer"`7D,
X    `7B"List All", artListOldArgs, XtNumber(artListOldArgs),
X#ifdef NEWBUTTONS
X   "List all articles in the current group"`7D,
X#else
X   "List all articles in the current group (may be slow)"`7D,
X#endif
X/* The following duplicates the artSpecButtonList - be careful */
X    `7B"Save", artSaveArgs, XtNumber(artSaveArgs),
X   "Save the displayed article in a file"`7D,
X    `7B"Reply", artReplyArgs, XtNumber(artReplyArgs),
X   "Mail a reply to the author of the displayed article"`7D,
X    `7B"Forward", artForwardArgs, XtNumber(artForwardArgs),
X   "Forward the displayed article to a user(s)"`7D,
X    `7B"Followup", artFollowupArgs, XtNumber(artFollowupArgs),
X   "Post a followup to the displayed article"`7D,
X    `7B"Followup+Reply", artFollowupReplyArgs, XtNumber(artFollowupReplyArgs
V),
X   "Post a followup and reply to the author of the displayed article"`7D,
X    `7B"Cancel", artCancelArgs, XtNumber(artCancelArgs),
X   "Cancel the displayed article"`7D,
X    `7B"Rot-13", artRot13Args, XtNumber(artRot13Args),
X   "Decrypt an encrypted joke"`7D,
X#ifdef XLATE
X    `7B"Translate", artXlateArgs, XtNumber(artXlateArgs),
X   "Translate the current article"`7D,
X#endif /*XLATE */
X    `7B"Toggle Header", artHeaderArgs, XtNumber(artHeaderArgs),
X   "Display the complete/stripped header"`7D,
X    `7B"Print", artPrintArgs, XtNumber(artPrintArgs),
X   "Print the displayed article"`7D,
X`7D;
X
Xstatic int ArtButtonListCount = XtNumber(ArtButtonList);
Xexternaldef(artpopupcount) int ArtPopupCount = XtNumber(ArtButtonList);
Xexternaldef(artwinpopupcount) int ArtWinPopupCount = XtNumber(ArtButtonList)
V;
X
Xexternaldef(artspecbuttonlist) ButtonList ArtSpecButtonList`5B`5D = `7B
X    `7B"Save", artSaveArgs, XtNumber(artSaveArgs),
X   "Save the selected article(s) in a file"`7D,
X    `7B"Reply", artReplyArgs, XtNumber(artReplyArgs),
X   "Mail a reply to the author of the displayed article"`7D,
X    `7B"Forward", artForwardArgs, XtNumber(artForwardArgs),
X   "Forward displayed article to user(s)"`7D,
X    `7B"Followup", artFollowupArgs, XtNumber(artFollowupArgs),
X   "Post a followup to the displayed article"`7D,
X    `7B"Followup+Reply", artFollowupReplyArgs, XtNumber(artFollowupReplyArgs
V),
X   "Post a followup and reply to the author of the displayed article (as one
V action)"`7D,
X    `7B"Cancel", artCancelArgs, XtNumber(artCancelArgs),
X   "Cancel the displayed article"`7D,
X    `7B"Rot-13", artRot13Args, XtNumber(artRot13Args),
X   "Crypt/decrypt the displayed article"`7D,
X#ifdef XLATE
X    `7B"Translate", artXlateArgs, XtNumber(artXlateArgs),
X   "Translate the displayed article"`7D,
X#endif /*XLATE */
X    `7B"Toggle Headers", artHeaderArgs, XtNumber(artHeaderArgs),
X   "Display all/selected headers in displayed article"`7D,
X    `7B"Print", artPrintArgs, XtNumber(artPrintArgs),
X   "Print selected article(s)"`7D,
X`7D;
X
Xexternaldef(artspecbuttonlistcount) int ArtSpecButtonListCount = XtNumber(Ar
VtSpecButtonList);
Xexternaldef(artspecpopupcount) int ArtSpecPopupCount = XtNumber(ArtButtonLis
Vt);
X
Xstatic char TopNonButtonInfo`5BLABEL_SIZE`5D;
Xstatic char BottomNonButtonInfo`5BLABEL_SIZE`5D;
Xstatic char BottomNextGroupInfo`5BLABEL_SIZE`5D;
X
X
X/*
X * handle the Enter and Leave events for the buttons
X *
X * upon entering a button, get it's info string and put in the Question labe
Vl
X * upon leaving a button, restore the old info string
X *
X */
X/*ARGSUSED*/
Xvoid topInfoHandler(widget, client_data, event)
XWidget widget;
Xcaddr_t client_data;
XXEvent *event;
X`7B
X    Arg infoLineArg`5B1`5D;
X#ifdef MOTIF
X    XmString infoString;
X    XmString defInfoString;
X#else
X    DwtCompString infoString;
X    DwtCompString defInfoString;
X#endif
X    char *str = (char *) client_data;
X    void bottomLabelHandler();
X
X    if (inCommand) return;
X    if (str`5B0`5D == '*') `7B /* Magic flag - toggle both */
X`09str++;
X`09bottomLabelHandler(BottomInfoLine, client_data, event);
X    `7D`20
X    if (event->type == LeaveNotify) `7B
X#ifdef MOTIF
X`09defInfoString = XmStringLtoRCreate(TopNonButtonInfo,
X`09`09`09`09`09   XmSTRING_DEFAULT_CHARSET);
X`09XtSetArg(infoLineArg`5B0`5D, XmNlabelString, defInfoString);
X`09XtSetValues(TopInfoLine, infoLineArg, XtNumber(infoLineArg));
X`09XmStringFree(defInfoString);
X#else
X`09defInfoString = DwtLatin1String(TopNonButtonInfo);
X`09XtSetArg(infoLineArg`5B0`5D, DwtNlabel, defInfoString);
X`09XtSetValues(TopInfoLine, infoLineArg, XtNumber(infoLineArg));
X`09XtFree(defInfoString);
X#endif
X    `7D else if (event->type == EnterNotify) `7B
X#ifdef MOTIF
X`09infoString = XmStringLtoRCreate(str, XmSTRING_DEFAULT_CHARSET);
X`09XtSetArg(infoLineArg`5B0`5D, XmNlabelString, infoString);
X`09XtSetValues(TopInfoLine, infoLineArg, XtNumber(infoLineArg));
X`09XmStringFree(infoString);
X#else
X`09infoString = DwtLatin1String(str);
X`09XtSetArg(infoLineArg`5B0`5D, DwtNlabel, infoString);
X`09XtSetValues(TopInfoLine, infoLineArg, XtNumber(infoLineArg));
X`09XtFree(infoString);
X#endif
X    `7D
X    return;
X`7D
X
X
X/*
X * handle the Enter and Leave events for the buttons
X *
X * upon entering a button, get it's info string and put in the Question labe
Vl
X * upon leaving a button, restore the old info string
X *
X */
X/*ARGSUSED*/
Xvoid
XbottomInfoHandler(widget, client_data, event)
XWidget widget;
Xcaddr_t client_data;
XXEvent *event;
X`7B
X    Arg infoLineArg`5B1`5D;
X#ifdef MOTIF
X    XmString infoString;
X    XmString defInfoString;
X#else
X    DwtCompString infoString;
X    DwtCompString defInfoString;
X#endif
X
X    if (inCommand) return;
X    if (event->type == LeaveNotify) `7B
X#ifdef MOTIF
X`09defInfoString = XmStringLtoRCreate(BottomNonButtonInfo,
X`09`09`09`09`09   XmSTRING_DEFAULT_CHARSET);
X`09XtSetArg(infoLineArg`5B0`5D, XmNlabelString, defInfoString);
X`09XtSetValues(BottomInfoLine, infoLineArg, XtNumber(infoLineArg));
X`09XmStringFree(defInfoString);
X#else
X`09defInfoString = DwtLatin1String(BottomNonButtonInfo);
X`09XtSetArg(infoLineArg`5B0`5D, DwtNlabel, defInfoString);
X`09XtSetValues(BottomInfoLine, infoLineArg, XtNumber(infoLineArg));
X`09XtFree(defInfoString);
X#endif
X    `7D else if (event->type == EnterNotify) `7B
X#ifdef MOTIF
X`09infoString = XmStringLtoRCreate(client_data,
X`09`09`09`09`09XmSTRING_DEFAULT_CHARSET);
X`09XtSetArg(infoLineArg`5B0`5D, XmNlabelString, infoString);
X`09XtSetValues(BottomInfoLine, infoLineArg, XtNumber(infoLineArg));
X`09XmStringFree(infoString);
X#else
X`09infoString = DwtLatin1String(client_data);
X`09XtSetArg(infoLineArg`5B0`5D, DwtNlabel, infoString);
X`09XtSetValues(BottomInfoLine, infoLineArg, XtNumber(infoLineArg));
X`09XtFree(infoString);
X#endif
X    `7D
X    return;
X`7D
X
X/*ARGSUSED*/
Xvoid
XbottomLabelHandler(widget, client_data, event)
XWidget widget;
Xcaddr_t client_data;
XXEvent *event;
X`7B
X    Arg infoLineArg`5B1`5D;
X#ifdef MOTIF
X    XmString infoString;
X#else
X    DwtCompString infoString;
X#endif
X
X    if (inCommand) return;
X    if (event->type == LeaveNotify) `7B
X#ifdef MOTIF
X`09infoString = XmStringLtoRCreate(BottomNonButtonInfo,
X`09`09`09`09`09   XmSTRING_DEFAULT_CHARSET);
X`09XtSetArg(infoLineArg`5B0`5D, XmNlabelString, infoString);
X`09XtSetValues(BottomInfoLine, infoLineArg, XtNumber(infoLineArg));
X`09XmStringFree(infoString);
X#else
X`09infoString = DwtLatin1String(BottomNonButtonInfo);
X`09XtSetArg(infoLineArg`5B0`5D, DwtNlabel, infoString);
X`09XtSetValues(BottomInfoLine, infoLineArg, XtNumber(infoLineArg));
X`09XtFree(infoString);
X#endif
X    `7D else if (event->type == EnterNotify) `7B
X#ifdef MOTIF
X`09infoString = XmStringLtoRCreate(BottomNextGroupInfo,
X`09`09`09`09`09XmSTRING_DEFAULT_CHARSET);
X`09XtSetArg(infoLineArg`5B0`5D, XmNlabelString, infoString);
X`09XtSetValues(BottomInfoLine, infoLineArg, XtNumber(infoLineArg));
X`09XmStringFree(infoString);
X#else
X`09infoString = DwtLatin1String(BottomNextGroupInfo);
X`09XtSetArg(infoLineArg`5B0`5D, DwtNlabel, infoString);
X`09XtSetValues(BottomInfoLine, infoLineArg, XtNumber(infoLineArg));
X`09XtFree(infoString);
X#endif
X    `7D
X    return;
X`7D
X
X
Xstatic void
XresetSelection()
X/*
X * Reset selection once it's used, so the user doesn't accidentally
X * move groups, etc.
X */
X`7B
X    selCount = 0;
X    SelectionItem = -1;
X    SListSelectAll(TopList, 0);
X    setTitleBar(NULL);
X    return;
X`7D
X
X
Xstatic void
XsetTopInfoLineHandler(widget, message)
XWidget widget;
Xchar *message;
X`7B
X    XtAddEventHandler(widget,
X`09`09      (EventMask) (EnterWindowMask`7CLeaveWindowMask),
X`09`09      False,
X`09`09      (XtEventHandler) topInfoHandler,
X`09`09      (caddr_t) message);
X    return;
X`7D
X
X
Xstatic void
XsetBottomInfoLineHandler(widget, message)
XWidget widget;
Xchar *message;
X`7B
X    XtAddEventHandler(widget,
X`09`09      (EventMask) (EnterWindowMask`7CLeaveWindowMask),
X`09`09      False,
X`09`09      (XtEventHandler) bottomInfoHandler,
X`09`09      (caddr_t) message);
X    return;
X`7D
X
X
Xstatic void
XsetBottomInfoLabelHandler()
X`7B
X    XtAddEventHandler(BottomInfoLine,
X`09`09      (EventMask) (EnterWindowMask`7CLeaveWindowMask),
X`09`09      False,
X`09`09      (XtEventHandler) bottomLabelHandler,
X`09`09      (caddr_t) NULL);
X    return;
X`7D
X
X#ifdef SWITCH_TOP_AND_BOTTOM
Xstatic void setBottomInfoLine(message)
X#else
Xstatic void setTopInfoLine(message)
X#endif
Xchar *message;
X`7B
X    Arg infoLineArg`5B1`5D;
X#ifdef MOTIF
X    XmString labelString;
X#else
X    DwtCompString labelString;
X#endif
X
X    if (!message) message = "";
X    (void) strcpy(TopNonButtonInfo, (char *) message);
X#ifdef MOTIF
X    labelString = XmStringLtoRCreate(message, XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(infoLineArg`5B0`5D, XmNlabelString, labelString);
X    XtSetValues(TopInfoLine, infoLineArg, XtNumber(infoLineArg));
X    XmStringFree(labelString);
X#else
X    labelString = DwtLatin1String(message);
X    XtSetArg(infoLineArg`5B0`5D, DwtNlabel, labelString);
X    XtSetValues(TopInfoLine, infoLineArg, XtNumber(infoLineArg));
X    XtFree(labelString);
X#endif
X    return;
X`7D
X
X
X#ifdef SWITCH_TOP_AND_BOTTOM
Xstatic void setTopInfoLine(message)
X#else
Xstatic void setBottomInfoLine(message)
X#endif
Xchar *message;
X`7B
X    Arg infoLineArg`5B1`5D;
X    char *p;
X#ifdef MOTIF
X    XmString labelString;
X#else
X    DwtCompString labelString;
X#endif
X    if (!message) message = "";
X    if ((p = strchr(message, '\n'))) `7B
X`09*p = '\0';
X`09(void) strcpy(BottomNonButtonInfo, (char *) message);
X`09(void) strcpy(BottomNextGroupInfo, (char *) p+1);
X`09*p = '\n';
X    `7D else `7B
X`09(void) strcpy(BottomNonButtonInfo, (char *) message);
X`09(void) strcpy(BottomNextGroupInfo, (char *) message);
X    `7D
X#ifdef MOTIF
X    labelString = XmStringLtoRCreate(BottomNonButtonInfo,
X`09`09XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(infoLineArg`5B0`5D, XmNlabelString, labelString);
X    XtSetValues(BottomInfoLine, infoLineArg, XtNumber(infoLineArg));
X    XmStringFree(labelString);
X#else
X    labelString = DwtLatin1String(BottomNonButtonInfo);
X    XtSetArg(infoLineArg`5B0`5D, DwtNlabel, labelString);
X    XtSetValues(BottomInfoLine, infoLineArg, XtNumber(infoLineArg));
X    XtFree(labelString);
X#endif
X    return;
X`7D
X
X#define TOP`090
X#define BOTTOM`091
X
Xstatic void
XdoButtons(resource, box, buttons, buttonList, size, infoLine)
Xchar *resource;
XWidget box;
XWidget *buttons;
XButtonList *buttonList;
Xint *size;
Xint infoLine;
X`7B
X    char *ptr, *token, *savePtr;
X    int j, i = 0;
X
X    if (resource) `7B
X`09savePtr = ptr = XtNewString(resource);
X
X`09while ((token = strtok(ptr, ", \t\n")) != NIL(char)) `7B
X`09    /* find name */
X`09    for (j = 0; j < *size; j++) `7B
X`09`09if (STREQ(token, (char *) buttonList`5Bj`5D.buttonArgs`5B0`5D.value))
V `7B
X#ifdef MOTIF
X`09`09    if (buttonList`5Bj`5D.buttonArgs`5B1`5D.value == (XtArgVal) NULL)
V `7B
X`09`09`09buttonList`5Bj`5D.buttonArgs`5B1`5D.value =
X`09`09`09    (XtArgVal)XmStringLtoRCreate(buttonList`5Bj`5D.label,
X`09`09`09    XmSTRING_DEFAULT_CHARSET);
X`09`09    `7D
X`09`09    buttons`5Bi`5D = XmCreatePushButton(box,
X`09`09`09    (char *) buttonList`5Bj`5D.buttonArgs`5B0`5D.value,
X`09`09`09    buttonList`5Bj`5D.buttonArgs,
X`09`09`09    buttonList`5Bj`5D.size);
X#else
X`09`09    if (buttonList`5Bj`5D.buttonArgs`5B1`5D.value == NULL) `7B
X`09`09`09buttonList`5Bj`5D.buttonArgs`5B1`5D.value =
X`09`09`09    (XtArgVal)DwtLatin1String(buttonList`5Bj`5D.label);
X`09`09    `7D
X`09`09    buttons`5Bi`5D = DwtPushButtonCreate(box,
X`09`09`09    (char *) buttonList`5Bj`5D.buttonArgs`5B0`5D.value,
X`09`09`09    buttonList`5Bj`5D.buttonArgs,
X`09`09`09    buttonList`5Bj`5D.size);
X#endif
X`09`09    if (infoLine == TOP) `7B
X`09`09`09setTopInfoLineHandler(buttons`5Bi`5D, buttonList`5Bj`5D.message);
X`09`09    `7D else `7B
X`09`09`09setBottomInfoLineHandler(buttons`5Bi`5D, buttonList`5Bj`5D.message)
V;
X`09`09    `7D
X`09`09    i++;
X`09`09    break;
X`09`09`7D
X`09    `7D
X`09    if (j == *size) `7B
X`09`09mesgPane(XRN_SERIOUS, "XRN error: bad button name: %s", token);
X`09    `7D
X`09    ptr = NIL(char);
X`09`7D
X`09*size = i;
X`09XtFree(savePtr);`09
X    `7D else `7B
X`09for (i = 0; i < *size; i++) `7B
X`09   `20
X#ifdef MOTIF
X`09    if (buttonList`5Bi`5D.buttonArgs`5B1`5D.value == (XtArgVal) NULL) `7B
X`09`09buttonList`5Bi`5D.buttonArgs`5B1`5D.value =
X`09`09    (XtArgVal)XmStringLtoRCreate(buttonList`5Bi`5D.label,
X`09`09    XmSTRING_DEFAULT_CHARSET);
X`09    `7D
X`09    buttons`5Bi`5D = XmCreatePushButton(box,
X`09`09`09`09(char *) buttonList`5Bi`5D.buttonArgs`5B0`5D.value,
X`09`09`09`09buttonList`5Bi`5D.buttonArgs,
X`09`09`09`09buttonList`5Bi`5D.size);
X#else
X`09    if (buttonList`5Bi`5D.buttonArgs`5B1`5D.value == NULL) `7B
X`09`09buttonList`5Bi`5D.buttonArgs`5B1`5D.value =
X`09    `09    (XtArgVal)DwtLatin1String(buttonList`5Bi`5D.label);
X`09    `7D
X`09    buttons`5Bi`5D = DwtPushButtonCreate(box,
X`09`09`09`09(char *) buttonList`5Bi`5D.buttonArgs`5B0`5D.value,
X`09`09`09`09buttonList`5Bi`5D.buttonArgs,
X`09`09`09`09buttonList`5Bi`5D.size);
X#endif
X`09    if (infoLine == TOP) `7B
X`09`09setTopInfoLineHandler(buttons`5Bi`5D, buttonList`5Bi`5D.message);
X`09    `7D else `7B
X`09`09setBottomInfoLineHandler(buttons`5Bi`5D, buttonList`5Bi`5D.message);
X`09    `7D
X`09`7D
X    `7D
X    setBottomInfoLabelHandler();
X    return;
X`7D
X
X
Xvoid
XcreateButtons(mode)
Xint mode;
X`7B
X#define SETTRANSLATIONS(w, index, mode, bind) \
X    Translations`5Bindex`5D.widget = w; \
X    Translations`5Bindex`5D.unparsed`5Bmode`5D = bind;
X
X    int i;
X
X    if (mode == -1) `7B
X`09SETTRANSLATIONS(MainWindow, 0, ADD_MODE, app_resources.addBindings);
X`09SETTRANSLATIONS(TopButtonBox, 1, ADD_MODE, app_resources.addBindings);
X`09SETTRANSLATIONS(BottomButtonBox, 2, ADD_MODE,app_resources.addBindings);
X`09SETTRANSLATIONS(TopInfoLine, 3, ADD_MODE, app_resources.addBindings);
X`09SETTRANSLATIONS(BottomInfoLine, 4, ADD_MODE, app_resources.addBindings);
X`09SETTRANSLATIONS(TopList, 5, ADD_MODE, app_resources.addBindings);
X`09SETTRANSLATIONS(ArticleText, 6, ADD_MODE, app_resources.addBindings);
X
X`09SETTRANSLATIONS(MainWindow, 0, ALL_MODE, app_resources.allBindings);
X`09SETTRANSLATIONS(TopButtonBox, 1, ALL_MODE, app_resources.allBindings);
X`09SETTRANSLATIONS(BottomButtonBox, 2, ALL_MODE,app_resources.allBindings);
X`09SETTRANSLATIONS(TopInfoLine, 3, ALL_MODE, app_resources.allBindings);
X`09SETTRANSLATIONS(BottomInfoLine, 4, ALL_MODE, app_resources.allBindings);
X`09SETTRANSLATIONS(TopList, 5, ALL_MODE, app_resources.allBindings);
X`09SETTRANSLATIONS(ArticleText, 6, ALL_MODE, app_resources.allBindings);
X
X`09SETTRANSLATIONS(MainWindow, 0, NEWSGROUP_MODE,app_resources.ngBindings);
X`09SETTRANSLATIONS(TopButtonBox,1,NEWSGROUP_MODE,app_resources.ngBindings);
X`09SETTRANSLATIONS(BottomButtonBox,2,NEWSGROUP_MODE,app_resources.ngBindings
V);
X`09SETTRANSLATIONS(TopInfoLine,3,NEWSGROUP_MODE,app_resources.ngBindings);
X`09SETTRANSLATIONS(BottomInfoLine,4,NEWSGROUP_MODE,app_resources.ngBindings)
V;
X`09SETTRANSLATIONS(TopList,5,NEWSGROUP_MODE,app_resources.ngBindings);
X`09SETTRANSLATIONS(ArticleText,6,NEWSGROUP_MODE,app_resources.ngBindings);
X
X`09SETTRANSLATIONS(MainWindow,0, ARTICLE_MODE, app_resources.artBindings);
X`09SETTRANSLATIONS(TopButtonBox,1,ARTICLE_MODE, app_resources.artBindings);
X`09SETTRANSLATIONS(BottomButtonBox,2,ARTICLE_MODE,app_resources.artBindings)
V;
X`09SETTRANSLATIONS(TopInfoLine,3,ARTICLE_MODE, app_resources.artBindings);
X`09SETTRANSLATIONS(BottomInfoLine,4,ARTICLE_MODE,app_resources.artBindings);
X`09SETTRANSLATIONS(TopList, 5, ARTICLE_MODE, app_resources.artBindings);
X`09SETTRANSLATIONS(ArticleText,6,ARTICLE_MODE,app_resources.artBindings);
X
X`09XtAddActions(TopActions, XtNumber(TopActions));
X
X`09AddButtons = ARRAYALLOC(Widget, XtNumber(AddButtonList));
X`09XtAddActions(AddActions, XtNumber(AddActions));
X
X`09doButtons(app_resources.addButtonList, TopButtonBox, AddButtons,
X`09`09  AddButtonList, &AddButtonListCount, TOP);
X
X`09NgButtons = ARRAYALLOC(Widget, XtNumber(NgButtonList));
X`09XtAddActions(NgActions, XtNumber(NgActions));
X
X`09doButtons(app_resources.ngButtonList, TopButtonBox, NgButtons,
X`09`09  NgButtonList, &NgButtonListCount, TOP);
X
X`09AllButtons = ARRAYALLOC(Widget, XtNumber(AllButtonList));
X`09XtAddActions(AllActions, XtNumber(AllActions));
X
X`09doButtons(app_resources.allButtonList, TopButtonBox, AllButtons,
X`09`09  AllButtonList, &AllButtonListCount, TOP);
X   `20
X`09ArtButtons = ARRAYALLOC(Widget, XtNumber(ArtButtonList));
X`09XtAddActions(ArtActions, XtNumber(ArtActions));
X   `20
X`09doButtons(app_resources.artButtonList, TopButtonBox, ArtButtons,
X`09`09  ArtButtonList, &ArtButtonListCount, TOP);
X   `20
X`09ArtSpecButtons = ARRAYALLOC(Widget, XtNumber(ArtSpecButtonList));
X
X`09doButtons(app_resources.artSpecButtonList, BottomButtonBox,
X`09`09  ArtSpecButtons, ArtSpecButtonList, &ArtSpecButtonListCount,
X`09`09  BOTTOM);
X
X`09XtAddCallback(TopList, SListNselectCallback, listSelect, 0);
X`09XtAddCallback(TopList, SListNdoubleClickCallback, DoubleClick, 0);
X`09XtAddCallback(TopList, SListNgetDataCallback, GetData, 0);
X    `7D
X
X    if (mode == ADD_MODE) `7B
X`09XtUnmanageChildren(AddButtons, AddButtonListCount);
X`09for (i=0; i < AddButtonListCount; i++) `7B
X`09    XtDestroyWidget(AddButtons`5Bi`5D);
X`09`7D
X`09AddButtonListCount = XtNumber(AddButtonList);
X`09doButtons(app_resources.addButtonList, TopButtonBox, AddButtons,
X`09`09AddButtonList, &AddButtonListCount, TOP);
X`09if (Mode == ADD_MODE) `7B
X`09    XtManageChildren(AddButtons, AddButtonListCount);
X`09`7D
X    `7D
X    if (mode == ALL_MODE) `7B
X`09XtUnmanageChildren(AllButtons, AllButtonListCount);
X`09for (i=0; i < AllButtonListCount; i++) `7B
X`09    XtDestroyWidget(AllButtons`5Bi`5D);
X`09`7D
X`09AllButtonListCount = XtNumber(AllButtonList);
X`09doButtons(app_resources.allButtonList, TopButtonBox, AllButtons,
X`09`09AllButtonList, &AllButtonListCount, TOP);
X`09if (Mode == ALL_MODE) `7B
X`09    XtManageChildren(AllButtons, AllButtonListCount);
X`09`7D
X    `7D
X    if (mode == ARTICLE_MODE) `7B
X`09XtUnmanageChildren(ArtButtons, ArtButtonListCount);
X`09for (i=0; i < ArtButtonListCount; i++) `7B
X`09    XtDestroyWidget(ArtButtons`5Bi`5D);
X`09`7D
X`09ArtButtonListCount = XtNumber(ArtButtonList);
X`09doButtons(app_resources.artButtonList, TopButtonBox, ArtButtons,
X`09`09ArtButtonList, &ArtButtonListCount, TOP);
X`09if (Mode == ARTICLE_MODE) `7B
X`09    XtManageChildren(ArtButtons, ArtButtonListCount);
X`09`7D
X    `7D
X    if (mode == NEWSGROUP_MODE) `7B
X`09XtUnmanageChildren(NgButtons, NgButtonListCount);
X`09for (i=0; i < NgButtonListCount; i++) `7B
X`09    XtDestroyWidget(NgButtons`5Bi`5D);
X`09`7D
X`09NgButtonListCount = XtNumber(NgButtonList);
X`09doButtons(app_resources.ngButtonList, TopButtonBox, NgButtons,
X`09`09NgButtonList, &NgButtonListCount, TOP);
X`09if (Mode == NEWSGROUP_MODE) `7B
X`09    XtManageChildren(NgButtons, NgButtonListCount);
X`09`7D
X    `7D
X    return;
X`7D
X
Xstatic void
XsetTranslations(mode)
Xint mode;
X`7B
X    Arg args`5B1`5D;
X    Arg targs`5B2`5D;
X    static int init`5BMAX_MODE`5D = `7B0,0,0,0`7D;
X    int i;
X
X    if (!init`5Bmode`5D) `7B
X`09/*
X`09 * first time:
X`09 *   parse table
X`09 *   override
X`09 *   get table back and store
X`09 */
X`09for (i = 0; i < sizeof(Translations) / sizeof(struct _translations); i++)
V `7B
X`09    XtTranslations table, table1;
X
X`09    if (Translations`5Bi`5D.unparsed`5Bmode`5D == NIL(char)) `7B
X`09`09table = 0;
X`09    `7D else `7B
X`09`09table = XtParseTranslationTable(Translations`5Bi`5D.unparsed`5Bmode`5D
V);
X`09    `7D
X#ifndef MOTIF
X`09    XtSetArg(args`5B0`5D, XtNtranslations, &table1);
X`09    XtGetValues(Translations`5Bi`5D.widget, args, XtNumber(args));
X`09    if (table1 == (XtTranslations) 0) `7B
X`09`09if (table) `7B
X`09`09    XtSetArg(args`5B0`5D, XtNtranslations, table);
X`09`09    XtSetValues(Translations`5Bi`5D.widget, args, XtNumber(args));
X`09`09`7D
X`09    `7D
X#endif /* MOTIF */
X`09    if (table) `7B
X`09`09XtOverrideTranslations(Translations`5Bi`5D.widget, table);
X`09    `7D
X`09    XtSetArg(args`5B0`5D, XtNtranslations, &table1);
X`09    XtGetValues(Translations`5Bi`5D.widget, args, XtNumber(args));
X`09    Translations`5Bi`5D.tables`5Bmode`5D = table1;
X`09    /* instead of the previous two lines:
X`09     * Translations`5Bi`5D.tables`5Bmode`5D = table;
X`09     * however, this seems to lose bindings...
X`09     */
X#ifdef MOTIF
X`09    xthHandleAllPendingEvents();
X#endif
X`09`7D
X`09init`5Bmode`5D = 1;
X    `7D else `7B
X`09/*
X`09 * second and future times:
X`09 *   install translations
X`09 */
X`09for (i = 0; i < sizeof(Translations) / sizeof(struct _translations); i++)
V `7B
X`09    if (Translations`5Bi`5D.tables`5Bmode`5D) `7B
X#ifndef MOTIF
X`09`09XtSetArg(args`5B0`5D, XtNtranslations,Translations`5Bi`5D.tables`5Bmod
Ve`5D);
X`09`09XtSetValues(Translations`5Bi`5D.widget, args, XtNumber(args));
X#else
X`09/*
X`09 * Work around motif text widget bug.. when a setvalues is done
X`09 * the text 'value' reverts to some previous value.
X`09 */
X`09`09if (Translations`5Bi`5D.widget == ArticleText) `7B
X`09`09    XtSetArg(targs`5B0`5D, XtNtranslations,
X`09`09`09Translations`5Bi`5D.tables`5Bmode`5D);
X`09`09    XtSetArg(targs`5B1`5D, XmNvalue, "");
X`09`09    XtSetValues(Translations`5Bi`5D.widget, targs, XtNumber(targs));
X`09`09`7D else `7B
X`09`09    XtSetArg(args`5B0`5D, XtNtranslations,
X`09`09`09Translations`5Bi`5D.tables`5Bmode`5D);
X`09`09    XtSetValues(Translations`5Bi`5D.widget, args, XtNumber(args));
X`09`09`7D
X#endif
X`09    `7D
X`09`7D
X    `7D
X    return;
X`7D
X
Xstatic void
XsetTitleBar(message)
Xchar *message;
X`7B
X#ifdef TITLEBAR
X    Arg infoLineArg`5B1`5D;
X    char *p;
X#ifdef MOTIF
X    XmString labelString;
X#else
X    DwtCompString labelString;
X#endif
X    static char *modeTitle`5B`5D = `7B
X`09"Newsgroup mode - select News Group to read",
X`09"Article mode - select articles to read",
X`09"Add groups mode - decide processing for new newsgroups",
X`09"All groups mode - re-order newsgroups, select groups for subscribe/unsub
Vscribe",
X`09"No mode"    `7D;
X
X    if (!message) message = modeTitle`5BMode`5D;
X#ifdef MOTIF
X    labelString = XmStringLtoRCreate(message, XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(infoLineArg`5B0`5D, XmNlabelString, labelString);
X    XtSetValues(TitleBar, infoLineArg, XtNumber(infoLineArg));
X    XmStringFree(labelString);
X#else /* MOTIF */
X    labelString = DwtLatin1String(message);
X    XtSetArg(infoLineArg`5B0`5D, DwtNlabel, labelString);
X    XtSetValues(TitleBar, infoLineArg, XtNumber(infoLineArg));
X    XtFree(labelString);
X#endif /* MOTIF */
X#endif /* TITLEBAR */
X    return;
X`7D
X
Xstatic void
XswapMode()
X/*
X * change the buttons displayed in the TopButtonBox (switch modes)
X */
X`7B
X    Arg resizeArg`5B3`5D;
X    Arg testArgs`5B1`5D;
X    Position y;
X    Dimension min = 0;
X    Dimension max = 0;
X    static Dimension buttonHeight = 0;
X    Arg labelArgs`5B1`5D;
X
X    if (PreviousMode == Mode) `7B
X`09return;
X    `7D
X
X    setTitleBar(NULL);
X#ifdef MOTIF
X    XtSetArg(resizeArg`5B0`5D, XmNrefigureMode, False);
X    XtSetValues(XtParent(TopButtonBox), resizeArg, 1);
X    XtSetArg(resizeArg`5B0`5D, XmNheight, &min);
X#else
X    XtSetArg(resizeArg`5B0`5D, DwtNheight, &min);
X#endif
X    XtGetValues(TopButtonBox, resizeArg, 1);
X    PaneSetMinMax(TopButtonBox, min, max);
X    if (buttonHeight == 0) `7B
X`09if (ArtSpecButtonListCount > 0) `7B
X#ifdef MOTIF
X`09    XtSetArg(resizeArg`5B0`5D, XmNheight, &buttonHeight);
X#else
X`09    XtSetArg(resizeArg`5B0`5D, DwtNheight, &buttonHeight);
X#endif
X`09    XtGetValues(ArtSpecButtons`5B0`5D, resizeArg, 1);
X`09    buttonHeight += 2;`09/* allow for margins */
X`09`7D else `7B
X`09    if (ArtButtonListCount > 0) `7B
X#ifdef MOTIF
X`09`09XtSetArg(resizeArg`5B0`5D, XmNheight, &buttonHeight);
X#else
X`09`09XtSetArg(resizeArg`5B0`5D, DwtNheight, &buttonHeight);
X#endif
X`09`09XtGetValues(ArtButtons`5B0`5D, resizeArg, 1);
X`09`09buttonHeight += 2;`09/* allow for margins */
X`09    `7D else `7B
X`09`09buttonHeight = 10;
X`09    `7D
X`09`7D
X`09PaneSetMinMax(BottomButtonBox, buttonHeight + 6, buttonHeight + 6);
X    `7D
X   `20
X    y = 0;
X    /*
X     * NONE -> ADD
X     *    manage add in top box
X     *    manage art in bottom box
X     *    desensitize bottom box
X     *    install add actions in top box
X     */
X    if ((PreviousMode == NO_MODE) && (Mode == ADD_MODE)) `7B
X`09XtManageChildren(AddButtons, AddButtonListCount);
X`09XtManageChildren(AddPopupButtons, AddPopupCount);
X`09XtManageChildren(ArtSpecButtons, ArtSpecButtonListCount);
X`09XtSetSensitive(BottomButtonBox, False);
X`09setTranslations(ADD_MODE);
X`09if (AddButtonListCount > 0) `7B
X`09    XtSetArg(testArgs`5B0`5D, XtNy, &y);
X`09    XtGetValues(AddButtons`5BAddButtonListCount-1`5D, testArgs,
X`09`09`09XtNumber(testArgs));
X`09    min = max = y + buttonHeight + 6;
X`09`7D else `7B
X`09    min = 1; max = 1;
X`09`7D
X`09XtManageChildren(addMenus, XtNumber(addMenus));
X`09XtUnmanageChildren(ngMenus, XtNumber(ngMenus));
X`09XtUnmanageChildren(artMenus, XtNumber(artMenus));
X`09XtUnmanageChildren(allMenus, XtNumber(allMenus));
X
X    /*   `20
X     * NONE -> NG
X     *    manage ng in top box
X     *    manage art in bottom box
X     *    desensitize bottom box
X     *    install ng actions in top box
X     */
X    `7D else if ((PreviousMode == NO_MODE) && (Mode == NEWSGROUP_MODE)) `7B
X`09XtManageChildren(NgButtons, NgButtonListCount);
X`09XtManageChildren(NgPopupButtons, NgPopupCount);
X`09XtManageChildren(ArtSpecButtons, ArtSpecButtonListCount);
X`09XtSetSensitive(BottomButtonBox, False);
X`09setTranslations(NEWSGROUP_MODE);
X`09if (NgButtonListCount > 0) `7B
X`09    XtSetArg(testArgs`5B0`5D, XtNy, &y);
X`09    XtGetValues(NgButtons`5BNgButtonListCount-1`5D, testArgs,
X`09`09`09XtNumber(testArgs));
X`09    min = max = y + buttonHeight + 6;
X`09`7D else `7B
X`09    min = 1; max = 1;
X`09`7D
X`09XtManageChildren(ngMenus, XtNumber(ngMenus));
X`09XtUnmanageChildren(artMenus, XtNumber(artMenus));
X`09XtUnmanageChildren(allMenus, XtNumber(allMenus));
X`09XtUnmanageChildren(addMenus, XtNumber(addMenus));
X    /*
X     * ADD -> NG
X     *    unmanage add in top box
X     *    manage ng in top box
X     *    install ng actions in top box
X     */
X    `7D else if ((PreviousMode == ADD_MODE) && (Mode == NEWSGROUP_MODE)) `7B
X`09XtUnmanageChildren(AddButtons, AddButtonListCount);
X`09XtUnmanageChildren(AddPopupButtons, AddPopupCount);
X`09resetPopupSize();
X`09XtManageChildren(NgButtons, NgButtonListCount);
X`09XtManageChildren(NgPopupButtons, NgPopupCount);
X`09setTranslations(NEWSGROUP_MODE);
X`09if (NgButtonListCount > 0) `7B
X`09    XtSetArg(testArgs`5B0`5D, XtNy, &y);
X`09    XtGetValues(NgButtons`5BNgButtonListCount-1`5D, testArgs,
X`09`09`09XtNumber(testArgs));
X`09    min = max = y + buttonHeight + 6;
X`09`7D else `7B
X`09    min = 1; max = 1;
X`09`7D
X`09XtManageChildren(ngMenus, XtNumber(ngMenus));
X`09XtUnmanageChildren(artMenus, XtNumber(artMenus));
X`09XtUnmanageChildren(allMenus, XtNumber(allMenus));
X`09XtUnmanageChildren(addMenus, XtNumber(addMenus));
X    /*
X     * ADD -> ART
X     *    unmanage add in top box
X     *    manage art in top box
X     *    install art actions in top box
X     */
X    `7D else if ((PreviousMode == ADD_MODE) && (Mode == ARTICLE_MODE)) `7B
X`09XtUnmanageChildren(AddButtons, AddButtonListCount);
X`09XtUnmanageChildren(AddPopupButtons, AddPopupCount);
X`09resetPopupSize();
X`09XtManageChildren(ArtButtons, ArtButtonListCount);
X`09XtManageChildren(ArtPopupButtons, ArtPopupCount);
X`09setTranslations(ARTICLE_MODE);
X`09if (ArtButtonListCount > 0) `7B
X`09    XtSetArg(testArgs`5B0`5D, XtNy, &y);
X`09    XtGetValues(ArtButtons`5BArtButtonListCount-1`5D, testArgs,
X`09`09`09XtNumber(testArgs));
X`09    min = max = y + buttonHeight + 6;
X`09`7D else `7B
X`09    min = 1; max = 1;
X`09`7D
X`09XtManageChildren(artMenus, XtNumber(artMenus));
X`09XtUnmanageChildren(allMenus, XtNumber(allMenus));
X`09XtUnmanageChildren(addMenus, XtNumber(addMenus));
X`09XtUnmanageChildren(ngMenus, XtNumber(ngMenus));
X    /*
X     * NG -> ART
X     *    unmanage ng in top box
X     *    manage art in top box
X     *    sensitize bottom box
X     *    install art actions in top box
X     *    install art actions in bottom box
X     */
X    `7D else if ((PreviousMode == NEWSGROUP_MODE) && (Mode == ARTICLE_MODE))
V `7B
X`09XtUnmanageChildren(NgButtons, NgButtonListCount);
X`09XtUnmanageChildren(NgPopupButtons, NgPopupCount);
X`09resetPopupSize();
X`09XtManageChildren(ArtButtons, ArtButtonListCount);
X`09XtManageChildren(ArtPopupButtons, ArtPopupCount);
X`09XtSetSensitive(BottomButtonBox, True);
X`09setTranslations(ARTICLE_MODE);
X`09if (ArtButtonListCount > 0) `7B
X`09    XtSetArg(testArgs`5B0`5D, XtNy, &y);
X`09    XtGetValues(ArtButtons`5BArtButtonListCount-1`5D, testArgs,
X`09`09`09XtNumber(testArgs));
X`09    min = max = y + buttonHeight + 6;
X`09`7D else `7B
X`09    min = 1; max = 1;
X`09`7D
X`09XtManageChildren(artMenus, XtNumber(artMenus));
X`09XtUnmanageChildren(allMenus, XtNumber(allMenus));
X`09XtUnmanageChildren(addMenus, XtNumber(addMenus));
X`09XtUnmanageChildren(ngMenus, XtNumber(ngMenus));
X    /*
X     * NG -> ADD
X     *    unmanage ng in top box
X     *    manage add in top box
X     *    install add actions in top box
X     */
X    `7D else if ((PreviousMode == NEWSGROUP_MODE) && (Mode == ADD_MODE)) `7B
X`09XtUnmanageChildren(NgButtons, NgButtonListCount);
X`09XtUnmanageChildren(NgPopupButtons, NgPopupCount);
X`09resetPopupSize();
X`09XtManageChildren(AddButtons, AddButtonListCount);
X`09XtManageChildren(AddPopupButtons, AddPopupCount);
X`09setTranslations(ADD_MODE);
X`09if (AddButtonListCount > 0) `7B
X`09    XtSetArg(testArgs`5B0`5D, XtNy, &y);
X`09    XtGetValues(AddButtons`5BAddButtonListCount-1`5D, testArgs,
X`09`09`09XtNumber(testArgs));
X`09    min = max = y + buttonHeight + 6;
X`09`7D else `7B
X`09    min = 1; max = 1;
X`09`7D
X`09XtManageChildren(addMenus, XtNumber(addMenus));
X`09XtUnmanageChildren(ngMenus, XtNumber(ngMenus));
X`09XtUnmanageChildren(artMenus, XtNumber(artMenus));
X`09XtUnmanageChildren(allMenus, XtNumber(allMenus));
X    /*
X     * NG -> ALL
X     *    desensitize top box
X     *    unmanage art in bottom box
X     *    manage all in bottom box
X     *    sensitize bottom box
X     *    install all actions in bottom box
X     */
X    `7D else if ((PreviousMode == NEWSGROUP_MODE) && (Mode == ALL_MODE)) `7B
X`09XtSetSensitive(BottomButtonBox, False);
X`09XtUnmanageChildren(NgButtons, NgButtonListCount);
X`09XtUnmanageChildren(NgPopupButtons, NgPopupCount);
X`09resetPopupSize();
X`09XtManageChildren(AllButtons, AllButtonListCount);
X`09XtManageChildren(AllPopupButtons, AllPopupCount);
X`09XtSetSensitive(TopButtonBox, True);
X`09setTranslations(ALL_MODE);
X`09if (AllButtonListCount > 0) `7B
X`09    XtSetArg(testArgs`5B0`5D, XtNy, &y);
X`09    XtGetValues(AllButtons`5BAllButtonListCount-1`5D, testArgs,
X`09`09`09XtNumber(testArgs));
X`09    min = max = y + buttonHeight + 6;
X`09`7D else `7B
X`09    min = 1; max = 1;
X`09`7D
X`09XtManageChildren(allMenus, XtNumber(allMenus));
X`09XtUnmanageChildren(ngMenus, XtNumber(ngMenus));
X`09XtUnmanageChildren(artMenus, XtNumber(artMenus));
X`09XtUnmanageChildren(addMenus, XtNumber(addMenus));
X    /*    `20
X     * ART -> NG
X     *    desensitize bottom box
X     *    unmanage art in top box
X     *    manage ng in top box
X     *    install ng actions in top box
X     */
X    `7D else if ((PreviousMode == ARTICLE_MODE) && (Mode == NEWSGROUP_MODE))
V `7B
X`09XtSetSensitive(BottomButtonBox, False);
X`09XtUnmanageChildren(ArtButtons, ArtButtonListCount);
X`09XtUnmanageChildren(ArtPopupButtons, ArtPopupCount);
X`09resetPopupSize();
X`09XtManageChildren(NgButtons, NgButtonListCount);
X`09XtManageChildren(NgPopupButtons, NgPopupCount);
X`09setTranslations(NEWSGROUP_MODE);
X`09if (NgButtonListCount > 0) `7B
X`09    XtSetArg(testArgs`5B0`5D, XtNy, &y);
X`09    XtGetValues(NgButtons`5BNgButtonListCount-1`5D, testArgs,
X`09`09`09XtNumber(testArgs));
X`09    min = max = y + buttonHeight + 6;
X`09`7D else `7B
X`09    min = 1; max = 1;
X`09`7D
X`09XtManageChildren(ngMenus, XtNumber(ngMenus));
X`09XtUnmanageChildren(allMenus, XtNumber(allMenus));
X`09XtUnmanageChildren(addMenus, XtNumber(addMenus));
X`09XtUnmanageChildren(artMenus, XtNumber(artMenus));
X    /*
X     * ALL -> NG
X     *    sensitize top box
X     *    unmanage all in bottom box
X     *    manage art in bottom box
X     *    desensitize bottom box
X     */
X    `7D else if ((PreviousMode == ALL_MODE) && (Mode == NEWSGROUP_MODE)) `7B
X`09XtSetSensitive(TopButtonBox, True);
X`09XtUnmanageChildren(AllButtons, AllButtonListCount);
X`09XtUnmanageChildren(AllPopupButtons, AllPopupCount);
X`09resetPopupSize();
X`09XtManageChildren(NgButtons, NgButtonListCount);
X`09XtManageChildren(NgPopupButtons, NgPopupCount);
X`09XtSetSensitive(BottomButtonBox, False);
X`09setTranslations(NEWSGROUP_MODE);
X`09if (NgButtonListCount > 0) `7B
X`09    XtSetArg(testArgs`5B0`5D, XtNy, &y);
X`09    XtGetValues(NgButtons`5BNgButtonListCount-1`5D, testArgs,
X`09`09`09XtNumber(testArgs));
X`09    min = max = y + buttonHeight + 6;
X`09`7D else `7B
X`09    min = 1; max = 1;
X`09`7D
X`09XtManageChildren(ngMenus, XtNumber(ngMenus));
X`09XtUnmanageChildren(artMenus, XtNumber(artMenus));
X`09XtUnmanageChildren(allMenus, XtNumber(allMenus));
X`09XtUnmanageChildren(addMenus, XtNumber(addMenus));
X    /*
X     * ART -> ALL (going back to previous ALL_MODE)
X     *    unmanage art in bottom box
X     *    unmanage art in top box
X     *    manage all in bottom box
X     *    manage ng in top box
X     *    desensitize top box
X     *    install all actions in bottom box
X     */
X    `7D else if ((PreviousMode == ARTICLE_MODE) && (Mode == ALL_MODE)) `7B
X`09XtSetSensitive(BottomButtonBox, False);
X`09XtUnmanageChildren(ArtButtons, ArtButtonListCount);
X`09XtUnmanageChildren(ArtPopupButtons, ArtPopupCount);
X`09resetPopupSize();
X`09XtManageChildren(AllButtons, AllButtonListCount);
X`09XtManageChildren(AllPopupButtons, AllPopupCount);
X`09XtSetSensitive(TopButtonBox, True);
X`09setTranslations(ALL_MODE);
X`09if (AllButtonListCount > 0) `7B
X`09    XtSetArg(testArgs`5B0`5D, XtNy, &y);
X`09    XtGetValues(AllButtons`5BAllButtonListCount-1`5D, testArgs,
X`09`09`09XtNumber(testArgs));
X`09    min = max = y + buttonHeight + 6;
X`09`7D else `7B
X`09    min = 1; max = 1;
X`09`7D
X`09XtManageChildren(allMenus, XtNumber(allMenus));
X`09XtUnmanageChildren(ngMenus, XtNumber(ngMenus));
X`09XtUnmanageChildren(artMenus, XtNumber(artMenus));
X`09XtUnmanageChildren(addMenus, XtNumber(addMenus));
X    /*`09
X     * ALL -> ART
X     *    unmanage ng in top box
X     *    sensitize top box
X     *    manage art in top box
X     *    unmanage all in bottom box
X     *    manage art in bottom box
X     *    install art actions in bottom box
X     */
X    `7D else if ((PreviousMode == ALL_MODE) && (Mode == ARTICLE_MODE)) `7B
X`09XtSetSensitive(TopButtonBox, True);
X`09XtUnmanageChildren(AllButtons, AllButtonListCount);
X`09XtUnmanageChildren(AllPopupButtons, AllPopupCount);
X`09resetPopupSize();
X`09XtUnmanageChildren(NgButtons, NgButtonListCount);
X`09XtUnmanageChildren(NgPopupButtons, NgPopupCount);
X`09XtManageChildren(ArtButtons, ArtButtonListCount);
X`09XtManageChildren(ArtPopupButtons, ArtPopupCount);
X`09XtManageChildren(ArtSpecButtons, ArtSpecButtonListCount);
X`09XtSetSensitive(BottomButtonBox, True);
X`09setTranslations(ARTICLE_MODE);
X`09if (ArtButtonListCount > 0) `7B
X`09    XtSetArg(testArgs`5B0`5D, XtNy, &y);
X`09    XtGetValues(ArtButtons`5BArtButtonListCount-1`5D, testArgs,
X`09`09`09XtNumber(testArgs));
X`09    min = max = y + buttonHeight + 6;
X`09`7D else `7B
X`09    min = 1; max = 1;
X`09`7D
X`09XtManageChildren(artMenus, XtNumber(artMenus));
X`09XtUnmanageChildren(ngMenus, XtNumber(ngMenus));
X`09XtUnmanageChildren(allMenus, XtNumber(allMenus));
X`09XtUnmanageChildren(addMenus, XtNumber(addMenus));
X
X    /*    `20
X     * ART -> ADD
X     *    unmanage art in top box
X     *    manage add in top box
X     *    install add actions in top box
X     */
X    `7D else if ((PreviousMode == ARTICLE_MODE) && (Mode == ADD_MODE)) `7B
X`09XtSetSensitive(BottomButtonBox, False);
X`09XtUnmanageChildren(ArtButtons, ArtButtonListCount);
X`09XtUnmanageChildren(ArtPopupButtons, ArtPopupCount);
X`09resetPopupSize();
X`09XtManageChildren(AddButtons, AddButtonListCount);
X`09XtManageChildren(AddPopupButtons, AddPopupCount);
X`09setTranslations(ADD_MODE);
X`09if (AddButtonListCount > 0) `7B
X`09    XtSetArg(testArgs`5B0`5D, XtNy, &y);
X`09    XtGetValues(AddButtons`5BAddButtonListCount-1`5D, testArgs,
X`09`09`09XtNumber(testArgs));
X`09    min = max = y + buttonHeight + 6;
X`09`7D else `7B
X`09    min = 1; max = 1;
X`09`7D
X`09XtManageChildren(addMenus, XtNumber(addMenus));
X`09XtUnmanageChildren(ngMenus, XtNumber(ngMenus));
X`09XtUnmanageChildren(addMenus, XtNumber(addMenus));
X`09XtUnmanageChildren(artMenus, XtNumber(artMenus));
X
X    `7D else `7B
X`09(void) sprintf(error_buffer, "unsupported transition: %d to %d\n",
X`09`09`09       PreviousMode, Mode);
X`09ehErrorExitXRN(error_buffer);
X    `7D
X   `20
X#ifdef MOTIF
X    if (min == 1 && max == 1) `7B
X`09SetButtonBoxSize(min, max);
X    `7D else `7B
X`09if (max != 0 && min != 0) `7B
X`09    min -= 6;
X`09    max -= 6;
X`09    SetButtonBoxSize(min ,max);
X`09`7D
X    `7D
X    XtSetArg(resizeArg`5B0`5D, XmNrefigureMode, True);
X    XtSetValues(XtParent(TopButtonBox), resizeArg, 1);
X#else
X    if (max != 0 && min != 0) `7B
X`09SetButtonBoxSize(min ,max);
X    `7D
X#endif
X    return;
X`7D
X
X
Xstatic int XRNAbort = 0;
X
Xint
XabortP()
X`7B
X    xthHandleAllPendingEvents();
X    return XRNAbort;
X`7D
X
Xvoid
XabortSet()
X`7B
X    XRNAbort = 1;
X    return;
X`7D
X
Xvoid
XabortClear()
X`7B
X    XRNAbort = 0;
X    return;
X`7D
X
X#ifdef MOTIF
XBoolean XmTextPosToXY();
Xstatic Boolean ScrollDownOnePage(w)
XWidget w;
X`7B
X    XmTextWidget widget = (XmTextWidget) w;
X    int n;
X    Position x, y;
X
X    if (XmTextPosToXY(w, XmTextGetLastPosition(w), &x, &y))
X`09return TRUE;
X
X#ifdef MOTIF_V10
X    XmTextDisableRedisplay(widget, FALSE);
X    n = XmTextNumLines(widget);
X#else
X    _XmTextDisableRedisplay(widget, FALSE);
X    n = _XmTextNumLines(widget);
X#endif
X    if (n > 1) n--;
X    XmTextScroll(w, n);
X#ifdef MOTIF_V10
X    XmTextEnableRedisplay(widget);
X#else
X    _XmTextEnableRedisplay(widget);
X#endif
X    return FALSE;
X`7D
Xstatic Boolean ScrollUpOnePage(w)
XWidget w;
X`7B
X    XmTextWidget widget = (XmTextWidget) w;
X    int n;
X    Position x,y;
X
X    if (XmTextPosToXY(w, 0, &x, &y))
X`09return TRUE;
X
X#ifdef MOTIF_V10
X    XmTextDisableRedisplay(widget, FALSE);
X    n = XmTextNumLines(widget);
X#else
X    _XmTextDisableRedisplay(widget, FALSE);
X    n = _XmTextNumLines(widget);
X#endif
X    if (n > 1) n--;
X    XmTextScroll(w, -n);
X#ifdef MOTIF_V10
X    XmTextEnableRedisplay(widget);
X#else
X    _XmTextEnableRedisplay(widget);
X#endif
X    return FALSE;
X`7D
X#else
Xextern Boolean DwtTextPosToXY();
Xstatic Boolean ScrollDownOnePage(w)
XWidget w;
X`7B
X    int n = 0;
X    int x, y;
X    Arg rowArg`5B1`5D;
X   `20
X    if (DwtTextPosToXY(w, DwtSTextGetLastPosition(w), &x, &y))
X`09return TRUE;
X
X    XtSetArg(rowArg`5B0`5D, DwtNrows, (XtArgVal) &n);
X    XtGetValues(w, rowArg, 1);
X    if (n > 1) n--;
X    DwtTextDisableRedisplay(w, FALSE);
X    (void) DwtTextScroll(w, n);
X    DwtTextEnableRedisplay(w);
X    return FALSE;
X`7D
Xstatic Boolean ScrollUpOnePage(w)
XWidget w;
X`7B
X    int n = 0;
X    int x, y;
X    Arg rowArg`5B1`5D;
X   `20
X    if (DwtTextPosToXY(w, 0, &x, &y))
X`09return TRUE;
X
X    XtSetArg(rowArg`5B0`5D, DwtNrows, (XtArgVal) &n);
X    XtGetValues(w, rowArg, 1);
X    if (n > 1) n--;
X    DwtTextDisableRedisplay(w, FALSE);
X    (void) DwtTextScroll(w, -n);
X    DwtTextEnableRedisplay(w);
X    return FALSE;
X`7D
X#endif /* MOTIF */
X
X/*ARGSUSED*/
Xstatic void
XdoTheRightThing(widget, event, string, count)
XWidget widget;
XXEvent *event;
XString *string;
XCardinal *count;
X`7B
X    void ngReadFunction(), ngOpenFunction(), artScrollFunction();
X    void artNextFunction(), artNextUnreadFunction(), artSubNextFunction();
X    void allScrollFunction();
X
X    if (inCommand) `7B
X`09XBell(XtDisplay(TopLevel), 0);
X`09return;
X    `7D
X    inCommand = 1;
X    busyCursor();
X    switch (Mode) `7B
X`09case ALL_MODE:
X`09allScrollFunction((Widget) 0);
X`09break;
X
X`09case NEWSGROUP_MODE:
X`09if (string && count && (*count == 1) &&`20
X`09    strcmp(string`5B0`5D, "jump") == 0) `7B
X`09    NewsgroupEntryMode = XRN_JUMP;
X`09`7D
X`09if (app_resources.autoRead) `7B
X`09   ngReadFunction((Widget) 0);
X`09`7D else `7B
X`09   ngOpenFunction((Widget) 0);
X`09`7D
X`09break;
X
X`09case ARTICLE_MODE:
X`09if (event &&
X`09    (event->type == ButtonPress `7C`7C event->type == ButtonRelease)) `7B
X`09    artNextFunction((Widget) 0);
X`09    break;
X`09`7D
X`09artScrollFunction((Widget) 0);
X`09break;
X    `7D
X    unbusyCursor();
X    inCommand = 0;
X    return;
X`7D
X
X/*
X *  Redraw the items between start and end in the subject list;
X *  Adjust the window so the cursor is between min and max lines.
X */
Xvoid
XupdateSubjectWidget(start, end, reset)
Xint`09start;
Xint`09end;
XBoolean reset;
X`7B
X    int i;
X   `20
X    if (start < 0) start = 0;
X    if (end > SubjectItems) end = SubjectItems;
X    for (i=start; i<end+1; i++) `7B
X`09SListUpdateLine(TopList, i);
X    `7D
X    subjSetPos(TopList, start, reset);
X    ArtPosition = start;
X    return;
X`7D
X
X/*
X * Get the nearest article to the cursor.  If there is no article on the
X * current line, search forward or backwards for a valid article, depending
X * on the value of status.  Return the text and question of the
X * article obtained.
X */
Xstatic int
XgetNearbyArticle(status, text, question, artNum)
Xint status;
Xchar **text, **question;
Xart_num *artNum;
X`7B
X    int beginning;
X   `20
X    if (status == art_PREV) `7B
X`09if (ArtPosition <= 0) `7B
X`09    /* no articles remain, jump out of article mode */
X`09    return art_DONE;
X`09`7D
X`09ArtPosition--;
X`09*artNum = ArticleNumbers`5BArtPosition`5D;
X`09gotoArticle(*artNum);
X`09subjSetPos(TopList, ArtPosition, True);
X`09while (getArticleText(text, question) != XRN_OKAY) `7B
X`09    if (ArtPosition > 0)
X`09`09ArtPosition--;
X`09    else
X`09`09return art_DONE;
X`09    *artNum = ArticleNumbers`5BArtPosition`5D;
X`09    gotoArticle(*artNum);
X`09    subjSetPos(TopList, ArtPosition, True);
X`09`7D
X`09return art_CHANGE;
X    `7D
X
X    if (status == art_NEXT) `7B
X`09ArtPosition++;
X`09if (ArtPosition >= SubjectItems) `7B
X`09    ArtPosition = SubjectItems - 1;
X`09    return art_DONE;
X`09`7D
X`09*artNum = ArticleNumbers`5BArtPosition`5D;
X`09gotoArticle(*artNum);
X`09subjSetPos(TopList, ArtPosition, True);
X`09while (getArticleText(text, question) != XRN_OKAY) `7B
X`09    ArtPosition++;
X`09    if (ArtPosition > SubjectItems) `7B
X`09`09return art_DONE;
X`09    `7D
X`09    *artNum = ArticleNumbers`5BArtPosition`5D;
X`09    gotoArticle(*artNum);`20
X`09    subjSetPos(TopList, ArtPosition, True);
X`09`7D
X`09return art_CHANGE;
X    `7D
X    if (status == art_CURRENT) `7B
X`09if (ArtPosition < 0 `7C`7C ArtPosition >= SubjectItems) `7B
X`09    ArtPosition = 0;
X`09    return art_DONE;
X`09`7D
X`09*artNum = ArticleNumbers`5BArtPosition`5D;
X`09gotoArticle(*artNum);
X`09while (getArticleText(text, question) != XRN_OKAY) `7B
X`09    ArtPosition++;
X`09    if (ArtPosition >= SubjectItems) `7B
X`09`09if (ArtPosition == 0) `7B
X`09`09    return art_DONE;
X`09`09`7D
X`09`09ArtPosition = 0;
X`09    `7D
X`09    *artNum = ArticleNumbers`5BArtPosition`5D;
X`09    gotoArticle(*artNum);`20
X`09    subjSetPos(TopList, ArtPosition, True);
X`09`7D
X`09subjSetPos(TopList, ArtPosition, True);
X`09return art_CHANGE;
X    `7D
X    if (status == art_UNREAD) `7B
X`09if (ArtPosition < 0) ArtPosition = 0;
X`09if (ArtPosition >= SubjectItems) `7B
X`09    if (ArtPosition == 0) `7B
X`09`09return art_DONE;
X`09    `7D
X`09    ArtPosition = 0;
X`09`7D
X`09beginning = ArtPosition;
X`09if (articleRead(ArticleNumbers`5BArtPosition`5D)) `7B
X`09    ArtPosition++;
X`09    if (ArtPosition >= SubjectItems) `7B
X`09`09return art_DONE;
X`09    `7D
X`09    while (articleRead(ArticleNumbers`5BArtPosition`5D) &&
X`09`09   ArtPosition != beginning) `7B
X`09`09ArtPosition++;
X`09`09if (ArtPosition >= SubjectItems) `7B
X`09`09    return art_DONE;
X`09`09`7D
X`09    `7D
X`09    if (ArtPosition == beginning) `7B
X`09`09return art_DONE;
X`09    `7D
X`09`7D
X`09/* we are at an unread article */
X`09*artNum = ArticleNumbers`5BArtPosition`5D;
X`09gotoArticle(*artNum);
X`09subjSetPos(TopList, ArtPosition, True);
X`09while (getArticleText(text, question) != XRN_OKAY) `7B
X`09    ArtPosition++;
X`09    if (ArtPosition >= SubjectItems) `7B
X`09`09if (ArtPosition == 0) `7B
X`09`09    return art_DONE;
X`09`09`7D
X`09`09ArtPosition = 0;
X`09    `7D
X`09    while (articleRead(ArticleNumbers`5BArtPosition`5D) &&
X`09`09   ArtPosition != beginning) `7B
X`09`09ArtPosition++;
X`09`09if (ArtPosition >= SubjectItems) `7B
X`09`09    return art_DONE;
X`09`09`7D
X`09    `7D
X`09    if (ArtPosition == beginning) `7B
X`09`09return art_DONE;
X`09    `7D
X`09    *artNum = ArticleNumbers`5BArtPosition`5D;
X`09    gotoArticle(*artNum);`20
X`09    subjSetPos(TopList, ArtPosition, True);
X`09`7D
X`09return art_CHANGE;
X    `7D
X    if (status == art_FINDUNREAD) `7B
X`09if (ArtPosition < 0) ArtPosition = 0;
X`09if (ArtPosition >= SubjectItems) `7B
X`09    if (ArtPosition == 0) `7B
X`09`09return art_DONE;
X`09    `7D
X`09    ArtPosition = 0;
X`09`7D
X`09beginning = ArtPosition;
X`09if (articleRead(ArticleNumbers`5BArtPosition`5D)) `7B
X`09    ArtPosition++;
X`09    if (ArtPosition >= SubjectItems) `7B
X`09`09return art_DONE;
X`09    `7D
X`09    while (articleRead(ArticleNumbers`5BArtPosition`5D) &&
X`09`09   ArtPosition != beginning) `7B
X`09`09ArtPosition++;
X`09`09if (ArtPosition >= SubjectItems) `7B
X`09`09    return art_DONE;
X`09`09`7D
X`09    `7D
X`09    if (ArtPosition == beginning) `7B
X`09`09return art_DONE;
X`09    `7D
X`09`7D
X`09/* we are at an unread article */
X`09*artNum = ArticleNumbers`5BArtPosition`5D;
X`09gotoArticle(*artNum);
X`09subjSetPos(TopList, ArtPosition, True);
X`09return art_CHANGE;
X    `7D
X    return art_CHANGE;
X`7D
X
X
X#define CHANGE 0`09`09/* subject window has changed */
X#define NOCHANGE 1`09`09/* subject window has not changed */
X#define DONE 2`09`09`09/* no new article was found */
X`09`09`09`09/* EXIT is already defined, it implies */
X`09`09`09`09/* there are no articles left at all */
X
Xstatic int
XisPrevSubject(subject, text, question, artNum)
Xchar *subject;
Xchar **text, **question;
Xart_num *artNum;
X`7B
X    char *newsubject;
X    char *newLine;
X    int save;
X
X    save = ArtPosition;
X    startSearch();
X    abortClear();
X   `20
X    for (;;) `7B
X`09if (abortP()) `7B
X`09    failedSearch();
X`09    ArtPosition = save;
X`09    return ABORT;
X`09`7D
X`09if (ArtPosition >= SubjectItems) `7B
X`09    ArtPosition = SubjectItems - 1;
X`09`7D
X`09if (ArtPosition > 0) `7B
X`09    ArtPosition--;
X`09    *artNum = ArticleNumbers`5BArtPosition`5D;
X`09    newsubject = getSubject(*artNum);
X`09    gotoArticle(*artNum);
X`09    if (utSubjectCompare(newsubject, subject) == 0) `7B
X`09`09gotoArticle(*artNum);
X`09`09subjSetPos(TopList, ArtPosition, True);
X`09`09if (getArticleText(text, question) != XRN_OKAY) `7B
X`09`09    if (ArtPosition > 0) ArtPosition--;
X`09`09    continue;
X`09`09`7D
X`09`09if (articleMarkedUnread(*artNum)) `7B
X`09`09    markArticleAsUnread(*artNum);
X`09`09`7D
X`09`09return NOCHANGE;
X`09    `7D
X`09    continue;
X`09`7D else `7B
X`09    gotoFirstArticle();
X`09    if ((newLine = getPrevSubject()) == NIL(char)) `7B
X`09`09failedSearch();
X`09`09ArtPosition = save;
X`09`09return DONE;
X`09    `7D
X`09    newLine`5B0`5D = '+';
X`09    *artNum = atol(&newLine`5B2`5D);
X`09    newsubject = getSubject(*artNum);
X`09    if (utSubjectCompare(newsubject, subject) == 0) `7B
X`09`09/* found a match, go with it*/
X`09`09gotoArticle(*artNum);
X`09`09subjSetPos(TopList, ArtPosition, True);
X`09`09(void) getArticleText(text, question);
X`09`09return CHANGE;
X`09    `7D
X`09    continue;
X`09`7D
X    `7D
X`7D
X
Xstatic int
XisNextSubject(subject, text, question, artNum)
Xchar *subject;
Xchar **text, **question;
Xart_num *artNum;
X`7B
X    char *newsubject;
X    int save = ArtPosition;
X
X    abortClear();
X   `20
X    if (ArtPosition != 0 `7C`7C
X`09(SubjectItems > 0 && articleRead(ArticleNumbers`5BArtPosition`5D))) `7B
X`09ArtPosition++;
X    `7D
X    for (;;) `7B
X
X`09if (abortP()) `7B
X`09    failedSearch();
X`09    ArtPosition = save;
X`09    return ABORT;
X`09`7D
X`09if (ArtPosition >= SubjectItems) `7B
X`09    ArtPosition = save;
X`09    return DONE;
X`09`7D
X`09*artNum = ArticleNumbers`5BArtPosition`5D;
X`09newsubject = getSubject(*artNum);
X`09if (utSubjectCompare(newsubject, subject) == 0) `7B
X`09    gotoArticle(*artNum);
X`09    subjSetPos(TopList, ArtPosition, True);
X`09    if (getArticleText(text, question) != XRN_OKAY) `7B
X`09`09if (ArtPosition > 0) ArtPosition--;
X`09    `7D
X`09    return NOCHANGE;
X`09`7D else `7B
X`09    ArtPosition++;
X`09`7D
X    `7D
X`7D
X
X
Xstatic int
XgetPrevious(artNum)
Xart_num *artNum;
X/*
X *`20
X */
X`7B
X    if (getPrevSubject()) `7B
X`09resetSubjectWidget(ALL, False);
X`09ArtPosition = 0;
X`09*artNum = ArticleNumbers`5BArtPosition`5D;
X`09return TRUE;
X    `7D
X    return FALSE;
X`7D
X
Xstatic void
XredrawAllWidget(position)
Xint position;
X/*
X * Redraw the all groups window, assuming it has changed
X */
X`7B
X    if (Mode != ALL_MODE) `7B
X`09return;
X    `7D
X
X    AllGroups = getStatusList(AllStatus);
X
X    for (AllGroupItems = 0; AllGroups`5BAllGroupItems`5D != -1; AllGroupItem
Vs++);
X
X    SListLoad(TopList, AllGroupItems);
X    currentTop = 0;
X    resetSelection();
X    subjSetPos(TopList, position, True);
X    saveTop = position;
X    return;
X`7D
X
X
X#ifdef WATCH
Xstatic int watchcount = -1;
Xstatic char **GroupList;
Xstatic char *GroupListString = 0;
X
XBoolean   watchingGroup()
X`7B
X
X    char *p;
X    int i, j;
X
X    /* if resource not defined or empty */
X    if (!app_resources.watchList `7C`7C (watchcount == -1 && GroupListString
V))
X`09return True;
X    if (GroupItems == 0)
X`09return False;
X    if (watchcount == -1)`7B
X`09char *q;
X`09char * strpbrk();
X`09int maxcount;
X
X`09GroupListString = XtNewString(app_resources.watchList);
X`09q = GroupListString;
X`09watchcount = 0;
X`09while(1)`7B
X`09    /* skip white space */
X`09    q = q + strspn(q," \t");
X`09    if( *q == '\0')
X`09`09break;
X`09    ++watchcount;
X`09    /* find end of token */
X`09    if((q = strpbrk(q," \t")) == 0)
X`09`09break;
X`09`7D
X`09GroupList = ARRAYALLOC(char *, watchcount);
X`09q = GroupListString;
X`09watchcount = -1;
X`09while(1)`7B
X`09    /* skip white space */
X`09    q = q + strspn(q," \t");
X`09    if( *q == '\0')
X`09`09break;
X`09    GroupList`5B++watchcount`5D = q;
X`09    /* find end of token */
X`09    if((q = strpbrk(q," \t")) == 0)
X`09`09break;
X`09    *q++ = '\0';
X`09`7D
X
X    `7D`09
X    for(i = 0; i <= watchcount; i++) `7B
X`09char *q;
X
X`09for (j = 0; j < GroupItems; j++) `7B
X`09    if (strcmp(GroupList`5Bi`5D, groupName(NewsGroups`5Bj`5D)) == 0) `7B
X`09`09return True;
X`09    `7D
X`09`7D
X    `7D
X    return False;
X`7D
X#endif
X
X/*
X * Rebuild the newsgroup list window.
X * Find out what groups have articles to read and build up the string.
X * Display it in the list widget.
X */
Xstatic void
XredrawNewsgroupListWidget()
X`7B
X    int i;
X
X    if (Mode != NEWSGROUP_MODE) `7B
X`09return;
X    `7D
X
X    if (NewsGroups != NIL(ng_num)) `7B
X`09FREE(NewsGroups);
X`09NewsGroups = (ng_num *)0;
X    `7D
X
X    NewsGroups = unreadGroups(NewsgroupDisplayMode, &unreadNews);
X   `20
X    GroupItems = 0;
X    for (i=0;NewsGroups`5Bi`5D >= 0;i++) `7B
X`09GroupItems++;
X    `7D
X
X    /* update the info line */
X
X    if (!unreadNews) `7B
X`09setTopInfoLine("No more unread articles in the subscribed to newsgroups")
V;
X`09if (XtIsRealized(TopLevel))
X`09    xmSetIconAndName(ReadIcon);
X    `7D else `7B
X`09if (XtIsRealized(TopLevel)) `7B
X#ifdef WATCH
X`09    if(watchingGroup())
X#endif
X`09`09xmSetIconAndName(UnreadIcon);
X#ifdef WATCH
X`09    else
X`09`09xmSetIconAndName(ReadIcon);
X#endif
X`09`7D
X    `7D
X
X    if (GroupItems > 0) `7B
X`09if (GroupPosition >= GroupItems) GroupPosition = 0;
X`09if (NewsGroups`5BGroupPosition`5D == -1) `7B
X`09    GroupPosition = 0;
X`09`7D
X`09if (STREQ(groupName(NewsGroups`5BGroupPosition`5D), LastGroup)) `7B
X`09    GroupPosition++;
X`09    if (GroupPosition >= GroupItems)
X`09`09GroupPosition = 0;
X`09`7D
X    `7D else `7B
X`09setTopInfoLine("No more unread articles in the subscribed to newsgroups")
V;
X    `7D
X   `20
X    SListLoad(TopList, GroupItems);
X    currentTop = 0;
X    subjSetPos(TopList, GroupPosition, True);
X    SelectionItem = -1;
X    SelectionCount = 0;
X    selCount = 0;
X    return;
X`7D
X
X/*
X * update the info line and update the newsgroup list window
X */
Xstatic void
XupdateNewsgroupMode()
X`7B
X    if (PreviousMode != NEWSGROUP_MODE) `7B
X`09setTopInfoLine("Questions apply to current selection or cursor position")
V;
X    `7D
X    redrawNewsgroupListWidget();
X    subjSetPos(TopList, GroupPosition, True);
X    SelectionItem = -1;
X    SelectionCount = 0;
X    selCount = 0;
X    return;
X`7D
X
X/*
X * install the newsgroup mode buttons (and the delete the previous mode butt
Vons)
X * and then go to newsgroup mode
X */
Xstatic void
XswitchToNewsgroupMode()
X`7B
X    PreviousMode = Mode;
X    Mode = NEWSGROUP_MODE;
X    LastRegexp = NIL(char);
X
X    selCount = 0;
X    SelectionItem = -1;
X
X    /* switch buttons */
X    swapMode();
X    addTimeOut();
X
X    /* update the newsgroup mode windows */
X    updateNewsgroupMode();
X   `20
X    return;
X`7D
X
X/*
X * install the article mode buttons (and delete the previous mode buttons),
X * build the subject line screen, and call ARTICLE_MODE function 'next unrea
Vd'
X */
Xstatic int
XswitchToArticleMode(readFlag)
Xint readFlag;
X`7B
X    int`09    oldMode;
X    /* change the list window */
X
X    if (ArticleNumbers != NIL(art_num)) `7B
X`09FREE(ArticleNumbers);
X    `7D
X
X    ArticleNumbers = getArticleNumbers(UNREAD, &SubjectItems);
X
X    ArtPosition = 0;
X    oldListed = False;
X    if (SubjectItems == 0) `7B
X/*
X *  No articles. report bogus group and
X *  redetermine mode
X */
X`09bogusNewsgroup();
X`09SubjectItems = 0;
X`09determineMode();
X`09return BAD_GROUP;
X    `7D
X
X    /* get rid of previous groups save file string */
X    if (app_resources.resetSave) `7B
X`09if (app_resources.saveString == NULL) `7B
X`09    app_resources.saveString = "";
X`09`7D
X`09if (SaveString) `7B
X`09    XtFree(SaveString);
X`09`7D
X`09SaveString = XtNewString(app_resources.saveString);
X    `7D
X
X    oldMode = PreviousMode;
X    PreviousMode = Mode;
X    Mode = ARTICLE_MODE;
X
X    /* switch buttons */
X    swapMode();
X
X    /*
X     * "What's the purpose of this?"  you're saying.  "It looks wrong."
X     * Well, try taking out any mention of oldMode in this function,
X     * then recompile and do the following:
X     * 1. Enter article mode
X     * 2. Clock "Next Newsgroup".
X     * 3. Click "Quit".
X     * You will be returned to all mode instead of article mode.
X     * Therefore, we've got to keep track in this function of whether
X     * we're switching from article mode to article mode, and if so,
X     * set PreviousMode truly in order for swapMode to work, but once
X     * that's done, we can put it back to what it was before).
X     */
X    if (PreviousMode == ARTICLE_MODE) `7B
X`09PreviousMode = oldMode;
X    `7D
X    setTopInfoLine("Questions apply to current selections or cursor position
V");
X
X    /* get and display the article */
X    if (ArticleNumbers == (art_num *) 0) `7B
X`09ArticleNumbers = (art_num *) XtMalloc(512);
X    `7D
X    ArtPosition = 0;
X    SListLoad(TopList, SubjectItems);
X    setBottomInfoLine(openQuestion());
X    currentTop = 0;
X    updateSubjectWidget(0, 0, True);
X    ArtEntry = 1;
X    switch (readFlag) `7B
X`09case 1:
X`09artNextUnreadFunction((Widget) 0);
X`09break;
X`09case 2:
X`09markArticleAsRead(ArticleNumbers`5B0`5D);
X`09case 0:
X`09SListSelectAll(TopList, 0);
X`09break;
X    `7D
X    if (app_resources.twoWindows) `7B
X`09XtManageChildren(ArtWinPopupButtons, ArtWinPopupCount);
X    `7D
X    return GOOD_GROUP;
X`7D
X
Xstatic void
XresetSubjectWidget(artstatus, emptyOK)
X/*
X * rebuild the subject list widget
X */
X    int artstatus;
X    Boolean emptyOK;
X`7B
X    int `09i;
X    /* change the list window */
X
X    if (ArticleNumbers != NIL(art_num)) `7B
X`09FREE(ArticleNumbers);
X    `7D
X
X    ArticleNumbers = getArticleNumbers(artstatus, &SubjectItems);
X
X    if (SubjectItems == 0) `7B
X`09if (!emptyOK)
X`09    bogusNewsgroup();
X`09SubjectItems = 0;
X`09return;
X    `7D
X
X    SListLoad(TopList, SubjectItems);
X    currentTop = 0;
X
X    if (ArtPosition >= SubjectItems)
X`09ArtPosition = SubjectItems - 1;
X    return;
X`7D
X
Xstatic void
XupdateAllWidget(left, right)
Xint left, right;
X`7B
X    while (left <= right) `7B
X`09SListUpdateLine(TopList, left);
X`09left++;
X    `7D
X    return;
X`7D
X
X/*
X * If the article to be displayed has changed, update the article
X * window and redraw the mode line
X */
Xstatic void
XredrawArticleWidget(text, question)
Xchar *text, *question;
X`7B
X#ifdef MOTIF
X    char *wrapped;
X    extern char *wrapString();
X
X    if (app_resources.autoWrap) `7B
X`09wrapped = wrapString(text);
X#ifdef MOTIF_V10
X`09XmTextDisableRedisplay(ArticleText, FALSE);
X`09XmTextSetString(ArticleText, wrapped);
X`09XmTextEnableRedisplay(ArticleText);
X#else
X`09_XmTextDisableRedisplay((XmTextWidget) ArticleText, FALSE);
X`09XmTextSetString(ArticleText, wrapped);
X`09_XmTextEnableRedisplay((XmTextWidget) ArticleText);
X`09XmTextSetCursorPosition(ArticleText, 0);
X#endif
X`09XmTextSetString(ArticleText, wrapped);
X`09XtFree(wrapped);
X    `7D else `7B
X#ifdef MOTIF_V10
X`09XmTextDisableRedisplay(ArticleText, FALSE);
X`09XmTextSetString(ArticleText, text);
X`09XmTextEnableRedisplay(ArticleText);
X#else
X`09_XmTextDisableRedisplay((XmTextWidget) ArticleText, FALSE);
X`09XmTextSetString(ArticleText, text);
X`09_XmTextEnableRedisplay((XmTextWidget) ArticleText);
X`09XmTextSetCursorPosition(ArticleText, 0);
X#endif
X`09XmTextSetString(ArticleText, text);
X    `7D
X    XmTextSetEditable(ArticleText, FALSE);
X#else
X    DwtSTextSetString(ArticleText, text);
X    DwtSTextSetEditable(ArticleText, FALSE);
X#endif
X`09
X    setBottomInfoLine(question);
X    if (app_resources.twoWindows) `7B
X`09XtPopup(ArtTopLevel, XtGrabNone);
X`09ArtPoppedUp = True;
X    `7D
X    return;
X`7D
X
X/*
X * release the storage associated with article mode
X * and go to newsgroup mode
X */
Xstatic void
XexitArticleMode()
X`7B
X    int i;
X    PrevArticle = CurrentArticle = 0;
X   `20
X    /* clear the article window */
X
X#ifdef MOTIF
X    XmTextSetString(ArticleText, NULL);
X    XmTextSetEditable(ArticleText, FALSE);
X#else
X    DwtSTextSetString(ArticleText, "");
X    DwtSTextSetEditable(ArticleText, FALSE);
X#endif
X
X    setBottomInfoLine("");
X    SListLoad(TopList, 0);
X    if (ArticleNumbers != NIL(art_num)) `7B
X`09FREE(ArticleNumbers);
X`09ArticleNumbers = NIL(art_num);
X    `7D
X
X    releaseNewsgroupResources();
X    if (app_resources.updateNewsrc == TRUE) `7B
X`09while (!updatenewsrc())
X`09    (void) ehErrorRetryXRN("Can not update .newsrc file", True);
X    `7D
X
X    if (app_resources.twoWindows && ArtPoppedUp) `7B
X`09xthUnmapWidget(ArtTopLevel);
X`09XtPopdown(ArtTopLevel);
X`09ArtPoppedUp = False;
X    `7D
X    if (PreviousMode == NEWSGROUP_MODE) `7B
X`09switchToNewsgroupMode();
X    `7D else `7B
X`09switchToAllMode();
X    `7D
X   `20
X    return;
X`7D
X   `20
X/*
X * release storage associated with add mode and go to newsgroup mode
X */
Xstatic void
XexitAddMode()
X`7B
X    int i;
X
X    SListLoad(TopList, 0);
X    if (AddGroups) `7B
X`09FREE(AddGroups);
X`09AddGroups = (struct newsgroup **) 0;
X    `7D
X
X    AddGroupItems = 0;
X    switchToNewsgroupMode();
X   `20
X    return;
X`7D
X
X/*
X * update the add mode text window to correspond to the new set of groups
X */
Xstatic void
XredrawAddListWidget(insertPoint)
Xint insertPoint;
X`7B
X    int i;   `20
X
X    if (AddGroups != (struct newsgroup **) 0) `7B
X`09FREE(AddGroups);
X`09AddGroups = (struct newsgroup **) 0;
X    `7D
X    AddGroupItems = 0;
X    AddGroups = newGroups();
X    if (AddGroups == NULL)
X`09return;
X
X    for (AddGroupItems=0;
X`09AddGroups`5BAddGroupItems`5D != NULL;
X`09AddGroupItems++);
X
X    SListLoad(TopList, AddGroupItems);
X    currentTop = 0;
X    resetSelection();
X    subjSetPos(TopList,insertPoint, True);
X    AddGroupPosition = insertPoint;
X    if (XtIsRealized(TopLevel)) `7B
X#ifdef WATCH
X`09if(watchingGroup())
X#endif
X`09    xmSetIconAndName(UnreadIcon);
X#ifdef WATCH
X`09else
X`09    xmSetIconAndName(ReadIcon);
X#endif
X    `7D
X    return;
X`7D
X
X/*
X * Display new article, mark as read.
X */
Xvoid
XfoundArticle(file, ques, artNum)
Xchar *file, *ques;
Xart_num artNum;
X`7B
X    int curArt;
X
X    PrevArticle = CurrentArticle;
X    curArt = ArticleNumbers`5BArtPosition`5D;
X    if (curArt != artNum) `7B`09/* not current pos; have to find it */
X`09for (ArtPosition = 0; ArtPosition < SubjectItems; ArtPosition++) `7B
X`09    curArt = ArticleNumbers`5BArtPosition`5D;
X`09    if (curArt == artNum) break;
X`09`7D
X`09if (curArt != artNum) `7B`09/* not in current screen, go get 'em all */
X`09    resetSubjectWidget(ALL, False);
X`09    for (ArtPosition = 0; ArtPosition < SubjectItems; ArtPosition++) `7B
X`09`09curArt = ArticleNumbers`5BArtPosition`5D;
X`09`09if (curArt == artNum) break;
X`09    `7D
X`09`7D
X    `7D
X    if (curArt != artNum) ArtPosition = 0;
X    if (articleMarkedUnread(ArticleNumbers`5BArtPosition`5D)) `7B
X`09markArticleAsRead(ArticleNumbers`5BArtPosition`5D);
X    `7D`20
X    CurrentArticle = ArticleNumbers`5BArtPosition`5D;
X    markArticleAsRead(CurrentArticle);
X
X    resetSelection();
X    updateSubjectWidget(ArtPosition, ArtPosition, True);
X    subjSetPos(TopList, ArtPosition, True);
X    redrawArticleWidget(file, ques);
X   `20
X    return;
X`7D
X
X/*
X * used when the user has elected to catch
X * up newsgroups in newsgroup mode
X */
Xstatic void
XcatchUpNG()
X`7B
X    int first;
X    int savePosition = GroupPosition;
X    int i;
X   `20
X    if (SelectionItem < 0) `7B
X`09first = SListGetHighlight(TopList);
X`09resetSelection();
X`09if (first < 0) return;
X`09if (first >= GroupItems) `7B
X`09    first = GroupItems - 1;
X`09`7D
X`09GroupPosition = first;
X`09if (gotoNewsgroup(groupName(NewsGroups`5BGroupPosition`5D)) == GOOD_GROUP
V) `7B
X`09    catchUp();
X`09`7D
X`09updateNewsgroupMode();
X`09return;
X    `7D else `7B
X`09for (i = 0; i < GroupItems; i++) `7B
X`09    if (SListIsSelected(TopList, i)) `7B
X`09`09if (gotoNewsgroup(groupName(NewsGroups`5Bi`5D)) == GOOD_GROUP) `7B
X`09`09    catchUp();
X`09`09`7D
X`09    `7D
X`09`7D
X`09resetSelection();
X    `7D
X    GroupPosition = savePosition;
X    if (GroupPosition >= GroupItems) `7B
X`09GroupPosition = GroupItems - 1;
X    `7D
X    updateNewsgroupMode();
X    return;
X`7D
X
X
X#define XRNunsub_ABORT 0
X#define XRNunsub_OK 1
Xstatic char UnsubGroup`5BGROUP_NAME_SIZE`5D;
X/*ARGSUSED*/
Xstatic void
XunsubscribeHandler(widget, client_data, call_data)
XWidget widget;
Xcaddr_t client_data;
Xcaddr_t call_data;
X`7B
X    if (inCommand) `7B
X`09XBell(XtDisplay(TopLevel), 0);
X`09return;
X    `7D
X    inCommand = 1;
X    PopDownDialog(UnSubConfirmBox);
X    busyCursor();
X    if ((int) client_data == XRNunsub_OK) `7B
X`09if (gotoNewsgroup(UnsubGroup) == GOOD_GROUP) `7B
X`09    unsubscribe();
X`09    updateNewsgroupMode();
X`09`7D
X    `7D
X    subjSetPos(TopList,GroupPosition, True);
X    unbusyCursor();
X    inCommand = 0;
X    return;
X`7D
X
X/*
X * Unsubscribe user from selected group(s)
X */
Xstatic void
XunsubscribeNG()
X`7B
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Unsubscribe",`09unsubscribeHandler, (caddr_t) XRNunsub_OK`7D,
X`09`7B"Cancel",`09unsubscribeHandler, (caddr_t) XRNunsub_ABORT`7D,
X    `7D;
X
X    if (app_resources.confirmMode & NG_UNSUBSCRIBE) `7B
X`09if (UnSubConfirmBox == (Widget) 0) `7B
X`09    UnSubConfirmBox = CreateDialog(TopLevel, "Confirm Unsubscribe",
X`09`09`09`09`09   "OK to unsubscribe?",
X`09`09`09`09`09   DIALOG_NOTEXT, args, XtNumber(args));
X`09`7D
X`09PopUpDialog(UnSubConfirmBox);
X`09return;
X    `7D
X    if (gotoNewsgroup(UnsubGroup) == GOOD_GROUP) `7B
X`09unsubscribe();
X`09updateNewsgroupMode();
X    `7D
X    return;
X`7D
X
X/*
X * Catch up group, and exit article mode
X */
Xstatic void
XcatchUpART()
X`7B
X    catchUp();
X    exitArticleMode();
X    return;  `20
X`7D
X
X/*
X * Mark all articles between 0 and ArtPosition as read.
X * Get the next unread article and display it, quit
X * if there are no more unread articles.
X */
Xstatic void
XcatchUpPartART()
X`7B
X    char *text, *question;
X    art_num artNum;
X    int i, last;
X    int save, top;
X    if (SelectionItem > 0) `7B
X`09ArtPosition = SelectionItem;
X    `7D else `7B
X`09ArtPosition = SListGetHighlight(TopList);
X    `7D
X    if (ArtPosition >= SubjectItems) `7B
X`09ArtPosition = SubjectItems - 1;
X    `7D
X    last = ArtPosition;
X    if ((top = SListGetTop(TopList)) == -1) top = 0;
X    save = ArtPosition;
X    for (i = 0; i < last; i++) `7B
X`09if (!articleRead(ArticleNumbers`5Bi`5D)) `7B
X`09    markArticleAsRead(ArticleNumbers`5Bi`5D);
X`09    if (app_resources.watchProgress) `7B
X`09`09updateSubjectWidget(i, i, False);
X`09    `7D
X`09`7D
X    `7D
X    updateSubjectWidget(0, last, True);
X    ArtPosition = save;
X    SListSetTop(TopList, top);
X    if (app_resources.autoRead) `7B
X`09if (getNearbyArticle(art_UNREAD, &text, &question, &artNum) ==`20
X`09`09art_DONE) `7B
X`09    exitArticleMode();
X`09    return;
X`09`7D
X`09foundArticle(text, question, artNum);
X    `7D else `7B
X`09if (getNearbyArticle(art_FINDUNREAD, &text, &question, &artNum) ==`20
X`09`09art_DONE) `7B
X`09    return;
X`09`7D
X`09setBottomInfoLine(currentQuestion());
X    `7D`09
X    return;
X`7D
X
Xstatic void
XfedUpART()
X`7B
X    void artQuitFunction(), artNextGroupFunction();
X    PrevArticle = CurrentArticle = 0;
X
X    resetSelection();
X    catchUp();
X    if (NewsgroupDisplayMode) `7B
X`09artQuitFunction((Widget) 0);
X    `7D else `7B
X`09artNextGroupFunction((Widget) 0);
X    `7D
X    return;
X`7D
X
X/*
X * Unsubscribe user from the current group;
X * exit article mode
X */
Xstatic void
XunsubscribeART()
X`7B
X    unsubscribe();
X    exitArticleMode();
X   `20
X    return;
X`7D
X
X
Xstatic Widget ExitConfirmBox = (Widget) 0;
Xstatic Widget CatchUpConfirmBox = (Widget) 0;
Xstatic Widget PartCatchUpConfirmBox = (Widget) 0;
Xstatic Widget FedUpConfirmBox = (Widget) 0;
Xstatic Widget EndActionBox = (Widget) 0;
X
X/*ARGSUSED*/
Xstatic void
XgeneralHandler(widget, client_data, call_data)
XWidget widget;
Xcaddr_t client_data;
Xcaddr_t call_data;
X`7B
X    if (inCommand) `7B
X`09XBell(XtDisplay(TopLevel), 0);
X`09return;
X    `7D
X    inCommand = 1;
X    busyCursor();
X    switch(Action) `7B
X`09case NG_EXIT:
X`09PopDownDialog(ExitConfirmBox);
X`09if ((int) client_data == XRN_YES) `7B
X`09    ehNoUpdateExitXRN();
X`09`7D
X`09break;
X
X`09case NG_QUIT:
X`09PopDownDialog(ExitConfirmBox);
X`09if ((int) client_data == XRN_YES) `7B
X`09    ehCleanExitXRN();
X`09`7D
X    `09break;
X
X`09case NG_CATCHUP:
X`09PopDownDialog(CatchUpConfirmBox);
X`09if ((int) client_data == XRN_YES) `7B
X`09    catchUpNG();
X`09`7D
X    `09break;
X
X`09case ART_CATCHUP:
X`09PopDownDialog(CatchUpConfirmBox);
X`09if ((int) client_data == XRN_YES) `7B
X`09    catchUpART();
X`09`7D`09   `20
X`09break;
X
X`09case ART_PART_CATCHUP:
X`09PopDownDialog(PartCatchUpConfirmBox);
X`09if ((int) client_data == XRN_YES) `7B
X`09    catchUpPartART();
X`09`7D
X`09break;
X
X`09case ART_UNSUBSCRIBE:
X`09PopDownDialog(UnSubConfirmBox);
X`09if ((int) client_data == XRN_YES) `7B
X`09    unsubscribeART();
X`09`7D
X`09break;
X
X`09case ART_FEDUP:
X`09PopDownDialog(FedUpConfirmBox);
X`09if ((int) client_data == XRN_YES) `7B
X`09    fedUpART();
X`09`7D
X`09break;
X    `7D
X    unbusyCursor();
X    inCommand = 0;
X    return;
X`7D
X
X/*
X * called when the user wants to quit xrn
X *
X *  full update the newsrc file
X *  exit
X */
X/*ARGSUSED*/
Xvoid
XngQuitFunction(widget)
XWidget widget;
X`7B
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Yes",`09generalHandler, (caddr_t) XRN_YES`7D,
X`09`7B"No",`09generalHandler, (caddr_t) XRN_NO`7D,
X    `7D;
X
X    if (Mode != NEWSGROUP_MODE) `7B
X`09return;
X    `7D
X    if (app_resources.confirmMode & NG_QUIT) `7B
X`09Action = NG_QUIT;
X`09if (ExitConfirmBox == (Widget) 0) `7B
X`09    ExitConfirmBox = CreateDialog(TopLevel, "Confirm Quit",
X`09`09`09`09`09   "Are you sure?",
X`09`09`09`09`09   DIALOG_NOTEXT, args, XtNumber(args));
X`09`7D
X`09PopUpDialog(ExitConfirmBox);
X`09return;
X    `7D
X    ehCleanExitXRN();
X`7D
X
X/*
X * called when the user wants to read a new newsgroup
X *
X * get the selected group, set the internal pointers, and go to article mode
X *
X */
X/*ARGSUSED*/
Xvoid
XngReadFunction(widget)
XWidget widget;
X`7B
X    char name`5BGROUP_NAME_SIZE`5D;
X    int `09status;
X
X    if (Mode != NEWSGROUP_MODE) `7B
X`09return;
X    `7D
X    SListSelectAll(TopList, 0);
X    if (SelectionItem < 0) `7B
X`09SelectionItem = SListGetHighlight(TopList);
X`09if (SelectionItem < 0) SelectionItem = 0;
X`09SelectionCount = 1;
X    `7D
X    if (SelectionItem >= GroupItems) `7B
X`09resetSelection();
X`09return;
X    `7D
X    GroupPosition = SelectionItem;
X    resetSelection();
X    if (GroupPosition >= 0) `7B
X`09strcpy(name, groupName(NewsGroups`5BGroupPosition`5D));
X`09setTitleBar("Opening newsgroup - please wait");
X`09if (NewsgroupEntryMode == XRN_GOTO) `7B
X`09    status = gotoNewsgroupForRead(name);
X`09`7D else `7B
X`09    status = jumpToNewsgroup(name);
X`09    NewsgroupEntryMode = XRN_GOTO;
X`09`7D
X`09if (status == GOOD_GROUP `7C`7C status == GOOD_GROUP_MARKED) `7B
X`09    if (getNewsgroup() == XRN_NOMORE) `7B
X`09`09mesgPane(XRN_SERIOUS, "Can not get the group, it may have been deleted
V");
X`09`09return;
X`09    `7D
X`09    (void) strcpy(LastGroup, name);
X`09    (void) switchToArticleMode(1);
X`09`7D
X    `7D else `7B
X`09GroupPosition = 0;
X    `7D
X    subjSetPos(TopList, 0, True);
X    return;
X`7D
X
X/*
X * called when the user wants to open a new newsgroup
X *
X * get the selected group, set the internal pointers, and go to article mode
X *
X */
X/*ARGSUSED*/
Xvoid
XngOpenFunction(widget)
XWidget widget;
X`7B
X    char name`5BGROUP_NAME_SIZE`5D;
X    int `09status;
X
X    if (Mode != NEWSGROUP_MODE) `7B
X`09return;
X    `7D
X    SListSelectAll(TopList, 0);
X    if (SelectionItem < 0) `7B
X`09SelectionItem = SListGetHighlight(TopList);
X`09if (SelectionItem < 0) SelectionItem = 0;
X`09SelectionCount = 1;
X    `7D
X    if (SelectionItem >= GroupItems) `7B
X`09resetSelection();
X`09return;
X    `7D
X    GroupPosition = SelectionItem;
X    resetSelection();
X    if (GroupPosition >= 0) `7B
X`09strcpy(name, groupName(NewsGroups`5BGroupPosition`5D));
X`09setTitleBar("Opening newsgroup - please wait");
X`09if (NewsgroupEntryMode == XRN_GOTO) `7B
X`09    status = gotoNewsgroupForRead(name);
X`09`7D else `7B
X`09    status = jumpToNewsgroup(name);
X`09    NewsgroupEntryMode = XRN_GOTO;
X`09`7D
X`09if (status == GOOD_GROUP `7C`7C status == GOOD_GROUP_MARKED) `7B
X`09    if (getNewsgroup() == XRN_NOMORE) `7B
X`09`09mesgPane(XRN_SERIOUS, "Can not get the group, it may have been deleted
V");
X`09`09return;
X`09    `7D
X`09    (void) strcpy(LastGroup, name);
X`09    (void) switchToArticleMode((status == GOOD_GROUP_MARKED) ? 2 : 0);
X`09`7D
X    `7D else `7B
X`09GroupPosition = 0;
X    `7D
X    subjSetPos(TopList, 0, True);
X    SListSelectAll(TopList, 0);
X    return;
X`7D
X
X/*
X * called when the user does not want to read a newsgroup
X *
X * if selected group, set internal group
X * call updateNewsgroupMode
X */
X/*ARGSUSED*/
Xvoid
XngNextFunction(widget)
XWidget widget;
X`7B
X    if (Mode != NEWSGROUP_MODE) `7B
X`09return;
X    `7D
X    GroupPosition++;
X    if (GroupPosition >= GroupItems) `7B
X`09GroupPosition = 0;
X    `7D
X    subjSetPos(TopList, GroupPosition, True);
X    return;
X`7D
X
X/*
X * called when the user wants to move the cursor up in
X * the newsgroup window
X *
X * if selected group, set internal group
X * call updateNewsgroupMode
X */
X/*ARGSUSED*/
Xvoid
XngPrevFunction(widget)
XWidget widget;
X`7B
X    if (Mode != NEWSGROUP_MODE) `7B
X`09return;
X    `7D
X   `20
X    GroupPosition--;
X    if (GroupPosition < 0) `7B
X`09GroupPosition = GroupItems - 1;
X    `7D
X    subjSetPos(TopList, GroupPosition, True);
X    return;
X`7D
X
X/*
X * called to catch up on all unread articles in this newsgroup
X * use a confirmation box if the user has requested it
X * if selected group, set internal group
X */
X/*ARGSUSED*/
Xvoid
XngCatchUpFunction(widget)
XWidget widget;
X`7B
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Yes",`09generalHandler, (caddr_t) XRN_YES`7D,
X`09`7B"No",`09generalHandler, (caddr_t) XRN_NO`7D,
X    `7D;
X
X    if (GroupItems <= 0) return;
X    if (Mode != NEWSGROUP_MODE) `7B
X`09return;
X    `7D
X   `20
X    if (app_resources.confirmMode & NG_CATCHUP) `7B
X`09Action = NG_CATCHUP;
X`09if (CatchUpConfirmBox == (Widget) 0) `7B
X`09    CatchUpConfirmBox = CreateDialog(TopLevel, "Confirm Catch Up",
X`09`09`09`09`09     "OK to catch up?",
X`09`09`09`09`09     DIALOG_NOTEXT, args, XtNumber(args));
X`09`7D
X`09PopUpDialog(CatchUpConfirmBox);
X
X`09return;
X    `7D
X    catchUpNG();
X
X    return;
X`7D
X
X/*
X * called to unsubscribe to a newsgroup
X *
X * if selected group, set internal group
X * do internals
X * call updateNewsgroupMode
X */
X/*ARGSUSED*/
Xvoid
XngUnsubFunction(widget)
XWidget widget;
X`7B
X    int i;
X    int savePosition = GroupPosition;
X    char *curGroup;
X
X    if (Mode != NEWSGROUP_MODE) `7B
X`09return;
X    `7D
X    if (GroupItems <= 0) `7B
X`09mesgPane(XRN_SERIOUS, "Please select a Group to unsubscribe from");
X`09return;
X    `7D
X    if (SelectionItem < 0) `7B
X`09i = SListGetHighlight(TopList);
X`09strcpy(UnsubGroup, groupName(NewsGroups`5Bi`5D));
X`09unsubscribeNG();
X    `7D else `7B
X`09for (i=0;i<GroupItems;i++) `7B
X`09    if (SListIsSelected(TopList, i)) `7B
X`09`09strcpy(UnsubGroup, groupName(NewsGroups`5Bi`5D));
X`09`09unsubscribeNG();
X`09`09return;
X`09    `7D
X`09`7D
X`09resetSelection();
X    `7D
X    GroupPosition = savePosition;
X    if (GroupPosition >= GroupItems) `7B
X`09GroupPosition = GroupItems - 1;
X    `7D
X    resetSelection();   `20
X    updateNewsgroupMode();
X
X    return;
X`7D
X
X
X#define XRNsub_ABORT 0
X#define XRNsub_LASTGROUP 1
X#define XRNsub_FIRST 2
X#define XRNsub_LAST 3
X#define XRNsub_CURRENT 4
X
Xstatic Widget SubscribeBox = (Widget) 0;
X
X/*ARGSUSED*/
Xstatic void
XsubscribeHandler(widget, client_data, call_data)
XWidget widget;
Xcaddr_t client_data;
Xcaddr_t call_data;
X`7B
X    int status = SUBSCRIBE;
X    char name`5BGROUP_NAME_SIZE`5D;
X
X    if (inCommand) `7B
X`09XBell(XtDisplay(TopLevel), 0);
X`09return;
X    `7D
X    inCommand = 1;
X    PopDownDialog(SubscribeBox);
X    busyCursor();
X    switch ((int) client_data) `7B
X`09case XRNsub_LASTGROUP:
X`09if (LastGroup`5B0`5D != '\0') `7B
X`09    if (gotoNewsgroup(LastGroup) != GOOD_GROUP) `7B
X`09`09mesgPane(XRN_SERIOUS, "Bad Group");
X`09`09unbusyCursor();
X`09`09inCommand = 0;
X`09`09return;
X`09    `7D
X`09    subscribe();
X`09    updateNewsgroupMode();
X`09`7D
X`09break;
X
X`09case XRNsub_FIRST:
X`09if (addToNewsrcBeginning(GetDialogValue(SubscribeBox),
X`09`09`09`09 status) == GOOD_GROUP) `7B
X`09    GroupPosition = 0;
X`09    updateNewsgroupMode();
X`09`7D
X`09break;
X
X`09case XRNsub_LAST:
X`09if (addToNewsrcEnd(GetDialogValue(SubscribeBox),
X`09`09`09   status) == GOOD_GROUP) `7B
X`09    updateNewsgroupMode();
X `09    subjSetPos(TopList, GroupPosition, True);
X`09`7D
X`09break;
X
X`09case XRNsub_CURRENT:
X`09if (GroupItems == 0) `7B
X`09    if (addToNewsrcEnd(GetDialogValue(SubscribeBox),
X`09`09`09`09status) == GOOD_GROUP) `7B
X`09`09updateNewsgroupMode();
X`09`09subjSetPos(TopList, GroupPosition, True);
X`09    `7D
X`09    break;
X`09`7D
X`09if (GroupPosition < 0) GroupPosition = 0;
X`09if (GroupPosition >= GroupItems) GroupPosition = GroupItems - 1;
X`09if (NewsGroups`5BGroupPosition`5D == -1) `7B
X`09    if (addToNewsrcEnd(GetDialogValue(SubscribeBox),
X`09`09`09       status) == GOOD_GROUP) `7B
X`09`09updateNewsgroupMode();
X `09    `09subjSetPos(TopList, GroupPosition, True);
X`09    `7D
X`09`7D else `7B
X
X`09    /* don't need to check for the null group here, it would have */
X`09    /* been already handled above */
X`09    if (GroupPosition == 0) `7B
X`09`09if (addToNewsrcBeginning(GetDialogValue(
X`09`09    SubscribeBox),status) == GOOD_GROUP) `7B
X`09`09    updateNewsgroupMode();
X`09`09`7D
X`09    `7D else `7B
X`09`09GroupPosition--;
X`09`09strcpy(name, groupName(NewsGroups`5BGroupPosition`5D));
X`09`09if (addToNewsrcAfterGroup(GetDialogValue(
X`09`09`09SubscribeBox), name, status) == GOOD_GROUP) `7B
X`09`09    updateNewsgroupMode();
X`09`09`7D
X`09    `7D
X    `09`7D
X`09break;
X    `7D
X    subjSetPos(TopList,GroupPosition, True);
X    unbusyCursor();
X    inCommand = 0;
X    return;
X`7D
X
X/*
X * Subscribe to a group currently unsubscribed to
X */
X/*ARGSUSED*/
Xvoid
XngSubscribeFunction(widget)
XWidget widget;
X`7B
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Cursor Position",`09subscribeHandler, (caddr_t) XRNsub_CURRENT`7D,
X`09`7B"Last Group",`09`09subscribeHandler, (caddr_t) XRNsub_LASTGROUP`7D,
X`09`7B"Cancel",`09`09subscribeHandler, (caddr_t) XRNsub_ABORT`7D,
X`09`7B"  First ",`09`09subscribeHandler, (caddr_t) XRNsub_FIRST`7D,
X`09`7B"  Last  ",`09`09subscribeHandler, (caddr_t) XRNsub_LAST`7D,
X    `7D;
X
X    if (Mode != NEWSGROUP_MODE) `7B
X`09return;
X    `7D
X   `20
X    if (SubscribeBox == (Widget) 0) `7B
X`09SubscribeBox = CreateDialog(TopLevel, "Subscribe Select",
X`09`09`09`09   "Group to subscribe to:",
X`09`09`09`09    DIALOG_TEXT, args, XtNumber(args));
X    `7D
X    PopUpDialog(SubscribeBox);
X
X    return;
X`7D
X
X#define XRNgoto_ABORT 0
X#define XRNgoto_GOTO 1
X
Xstatic Widget GotoNewsgroupBox = (Widget) 0;
X
X/*ARGSUSED*/
Xstatic void
XgotoHandler(widget, client_data, call_data)
XWidget widget;
Xcaddr_t client_data;
Xcaddr_t call_data;
X`7B
X    char *name;
X
X    if (inCommand) `7B
X`09XBell(XtDisplay(TopLevel), 0);
X`09return;
X    `7D
X    inCommand = 1;
X    PopDownDialog(GotoNewsgroupBox);
X    busyCursor();
X    resetSelection();
X    if ((int) client_data == XRNgoto_GOTO) `7B
X`09name = GetDialogValue(GotoNewsgroupBox);
X`09if (name`5B0`5D == '\0') `7B
X`09    mesgPane(XRN_INFO, "No newsgroup entered");
X`09`7D else `7B
X`09    setTitleBar("Opening newsgroup - please wait");
X`09    if (jumpToNewsgroup(name) == GOOD_GROUP) `7B
X`09    /* jumpToNewsgroup may have found a match for regex name */
X`09`09name = CurrentGroup->name;
X`09`09(void) strcpy(LastGroup, name);
X`09`09(void) switchToArticleMode(app_resources.autoRead);
X`09    `7D
X`09`7D
X    `7D
X    unbusyCursor();
X    inCommand = 0;
X    return;
X`7D
X
X/*
X * Jump to a newsgroup not displayed in newsgroup mode (either because
X * it's not subscribed to, or because all the articles have been read)
X *
X */
X/*ARGSUSED*/
Xvoid
XngGotoFunction(widget)
XWidget widget;
X`7B
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Go To Group", gotoHandler, (caddr_t) XRNgoto_GOTO`7D,
X`09`7B"Cancel",`09gotoHandler, (caddr_t) XRNgoto_ABORT`7D,
X    `7D;
X
X    if (Mode != NEWSGROUP_MODE) `7B
X`09return;
X    `7D
X    resetSelection();
X    if (GotoNewsgroupBox == (Widget) 0) `7B
X`09GotoNewsgroupBox = CreateDialog(TopLevel, "Go To Select",
X`09`09`09`09    "Group to go to:",
X`09`09`09`09    DIALOG_TEXT, args, XtNumber(args));
X    `7D
X    PopUpDialog(GotoNewsgroupBox);
X    return;
X`7D
X
Xstatic void
XswitchToAllMode()
X`7B `20
X    PreviousMode = Mode;
X    Mode = ALL_MODE;
X
X    /* switch buttons */
X    swapMode();
X   `20
X    setTopInfoLine("View all available groups, with option to subscribe");
X    redrawAllWidget(saveTop);
X
X    return;
X`7D
X
X/*ARGSUSED*/
Xvoid
XngToggleGroupsFunction(widget)
XWidget widget;
X`7B
X    if (Mode != NEWSGROUP_MODE) `7B
X`09return;
X    `7D
X    NewsgroupDisplayMode = (NewsgroupDisplayMode == 0) ? 1 : 0;
X    redrawNewsgroupListWidget();
X    return;
X`7D
X
X/*
X * Enter "all" mode.  Display all available groups to allow user to
X * subscribe/unsubscribe to them.
X */
X/*ARGSUSED*/
Xvoid
XngAllGroupsFunction(widget)
XWidget widget;
X`7B
X    if (Mode != NEWSGROUP_MODE) `7B
X`09return;
X    `7D
X    resetSelection();
X    switchToAllMode();
X    return;
X`7D
X
X/*
X * query the server to see if there are any new articles and groups
X */
X/*ARGSUSED*/
Xvoid
XngRescanFunction(widget)
XWidget widget;
X`7B
X    if (Mode != NEWSGROUP_MODE) `7B
X`09return;
X    `7D
X    resetSelection();
X    rescanServer();
X    determineMode();
X   `20
X    return;
X`7D
X
X/*ARGSUSED*/
Xvoid autoRescan(data, id)
Xcaddr_t data;
XXtIntervalId *id;
X`7B
X    if (Mode != NEWSGROUP_MODE) `7B
X`09TimeOut = 0;
X`09return;
X    `7D
X    TimeOut = 0;
X    if (!inCommand && !ComposeActive) `7B
X`09inCommand = 1;
X`09busyCursor();
X`09infoNow("automatic rescan in progress...");
X`09ngRescanFunction((Widget) 0);
X`09infoNow("automatic rescan completed");
X`09close_server();
X`09unbusyCursor();
X`09inCommand = 0;
X    `7D
X    addTimeOut();
X
X    return;
X`7D
X
X/*ARGSUSED*/
Xvoid autoExitAddMode(data, id)
Xcaddr_t data;
XXtIntervalId *id;
X`7B
X    if (Mode != ADD_MODE) `7B
X`09TimeOut = 0;
X`09return;
X    `7D
X    TimeOut = 0;
X    if (!inCommand) `7B
X`09inCommand = 1;
X`09busyCursor();
X`09exitAddMode();
X`09infoNow("Add Groups operation timed out");
X`09unbusyCursor();
X`09inCommand = 0;
X    `7D
X    addTimeOut();
X
X    return;
X`7D
X
X/*
X * put the user in the last newsgroup accessed
X */
X/*ARGSUSED*/
Xvoid
XngPrevGroupFunction(widget)
XWidget widget;
X`7B
X    if (Mode != NEWSGROUP_MODE) `7B
X`09return;
X    `7D
X    resetSelection();
X    if (LastGroup`5B0`5D != '\0') `7B
X`09setTitleBar("Opening newsgroup - please wait");
X`09if (jumpToNewsgroup(LastGroup) == GOOD_GROUP) `7B
X`09    (void) switchToArticleMode(app_resources.autoRead);
X`09`7D
X    `7D
X
X    return;
X`7D
X
X/*`20
X * save the user's selection of groups to be moved with the move
X * command
X */
X/*ARGSUSED*/
Xvoid
XngSelectFunction(widget)
XWidget widget;
X`7B
X    int i, count;
X
X    if (Mode != NEWSGROUP_MODE `7C`7C GroupItems == 0) `7B
X`09return;
X    `7D
X    if (selSize < GroupItems) `7B
X`09if (selList != NULL) FREE(selList);
X`09selList = XtMalloc(GroupItems+1);
X`09selSize = GroupItems;
X    `7D
X    count = 0;
X    for (i=0; i<GroupItems;i++) `7B
X`09if (SListIsSelected(TopList, i)) `7B
X`09    selList`5Bi`5D = 1;
X`09    count++;
X`09`7D else `7B
X`09    selList`5Bi`5D = 0;
X`09`7D
X    `7D
X    if (count == 0) `7B
X`09selList`5BSListGetHighlight(TopList)`5D = 1;
X`09count++;
X    `7D
X    resetSelection();
X    selCount = count;
X    SListSelectAll(TopList, 0);
X    return;
X`7D
X
X/*
X * Move the previously selected groups to the position before the
X * current selection
X */
X/*ARGSUSED*/
Xvoid
XngMoveFunction(widget)
XWidget widget;
X`7B
X    char newGroup`5BGROUP_NAME_SIZE`5D;
X    char oldGroup`5BGROUP_NAME_SIZE`5D;
X    int status = SUBSCRIBE;
X    int moveTo;
X    int moveFrom;
X
X    if (Mode != NEWSGROUP_MODE) `7B
X`09return;
X    `7D
X    if (selCount <= 0) `7B
X`09mesgPane(XRN_INFO, "No groups were selected");
X`09return;`09
X    `7D
X    if (SelectionItem < 0) `7B
X`09SelectionItem = SListGetHighlight(TopList);
X    `7D
X    moveTo = SelectionItem;
X    if (moveTo >= GroupItems) moveTo = GroupItems - 1;
X    if (moveTo > 0) `7B
X`09strcpy(oldGroup, groupName(NewsGroups`5BmoveTo-1`5D));
X    `7D
X    for (moveFrom = 0; moveFrom < GroupItems; moveFrom++) `7B
X`09if (selList`5BmoveFrom`5D != 0) `7B
X`09    strcpy(newGroup, groupName(NewsGroups`5BmoveFrom`5D));
X`09    if (moveTo <= 0) `7B
X`09`09moveTo = 0;
X`09`09(void) addToNewsrcBeginning(newGroup, status);
X`09`09(void) strcpy(oldGroup, newGroup);
X`09    `7D else `7B
X`09`09(void) addToNewsrcAfterGroup(newGroup, oldGroup, status);
X`09`09(void) strcpy(oldGroup, newGroup);
X`09    `7D
X`09`7D
X    `7D
X    resetSelection();
X    selCount = 0;
X    redrawNewsgroupListWidget();
X    return;
X`7D
X
X/*
X * Quit xrn, leaving the newsrc in the state it was in at
X * the last invokation of rescan.
X */
X/*ARGSUSED*/
Xvoid
XngExitFunction(widget)
XWidget widget;
X`7B
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Yes",`09generalHandler, (caddr_t) XRN_YES`7D,
X`09`7B"No",`09generalHandler, (caddr_t) XRN_NO`7D,
X    `7D;
X
X    if (Mode != NEWSGROUP_MODE) `7B
X`09return;
X    `7D
X    if (app_resources.confirmMode & NG_EXIT) `7B
X`09Action = NG_EXIT;
X`09if (ExitConfirmBox == (Widget) 0) `7B
X`09    ExitConfirmBox = CreateDialog(TopLevel, "Confirm Exit",
X`09`09`09`09`09   "Are you sure?",
X`09`09`09`09`09   DIALOG_NOTEXT, args, XtNumber(args));
X`09`7D
X`09PopUpDialog(ExitConfirmBox);
X`09return;
X    `7D
X
X    ehNoUpdateExitXRN();
X`7D
X
X/*
X * disconnect from the news server
X */
X/*ARGSUSED*/
Xvoid
XngDisconnectFunction(widget)
XWidget widget;
X`7B
X    if (Mode != NEWSGROUP_MODE) `7B
X`09return;
X    `7D
X
X    close_server();
X    return;
X`7D
X
X/*
X * update the .newsrc file
X */
X/*ARGSUSED*/
Xvoid
XngCheckPointFunction(widget)
XWidget widget;
X`7B
X    if (Mode != NEWSGROUP_MODE) `7B
X`09return;
X    `7D
X
X    while (!updatenewsrc())
X`09(void) ehErrorRetryXRN("Can not update .newsrc", True);
X
X    return;
X`7D
X
X/*
X * Allow user to gripe
X */
X/*ARGSUSED*/
Xvoid
XngGripeFunction(widget)
XWidget widget;
X`7B
X    if (Mode != NEWSGROUP_MODE) `7B
X`09return;
X    `7D
X    gripe();
X    return;
X`7D
X
X/*
X * allow user to post an article
X */
X/*ARGSUSED*/
Xvoid
XngPostFunction(widget)
XWidget widget;
X`7B
X    if (Mode != NEWSGROUP_MODE) `7B
X`09return;
X    `7D
X    post();
X   `20
X    return;
X`7D
X
X/*
X * called when the user wants to quit the current newsgroup and go to
X * the next one
X */
X/*ARGSUSED*/
Xvoid
XartQuitFunction(widget)
XWidget widget;
X`7B
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    exitArticleMode();
X   `20
X    return;
X`7D
X
X/*
X * called when the user wants to read the next article
X */
X/*ARGSUSED*/
Xvoid
XartNextFunction(widget)
XWidget widget;
X`7B
X    char *text;`09`09`09/* text of the article */
X    char *question;`09`09/* question to put in the question box */
X    art_num artNum;
X
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    if (getNearbyArticle(ArtStatus, &text, &question,
X`09`09`09 &artNum) == art_DONE) `7B
X`09exitArticleMode();
X`09return;
X    `7D
X    /* update the text window */
X    foundArticle(text, question, artNum);
X
X    ArtStatus = art_NEXT;
X    ArtEntry = 0;
X    return;
X`7D
X
X/*
X * called when the user wants to scroll the current article
X */
X/*ARGSUSED*/
Xvoid
XartScrollFunction(widget)
XWidget widget;
X`7B
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    if (!app_resources.pageArticles) `7B
X`09if (ScrollDownOnePage(ArticleText)) `7B
X`09    if (artCheckReadCurrent()) return;
X`09    if (app_resources.subjectRead == False) `7B
X`09`09artNextUnreadFunction((Widget) 0);
X`09    `7D else `7B
X`09`09if (app_resources.sortedSubjects == THREAD_SORTED) `7B
X`09`09    artNextUnreadFunction((Widget) 0);
X`09`09`7D else `7B
X`09`09    artSubNextFunction((Widget) 0);
X`09`09`7D
X`09    `7D
X`09`7D
X    `7D else `7B
X`09ScrollDownOnePage(ArticleText);
X`09return;
X    `7D
X    return;
X`7D
X
X/*
X * called when the user wants to scroll the current article
X */
X/*ARGSUSED*/
Xvoid
XartScrollBackFunction(widget)
XWidget widget;
X`7B
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    (void) ScrollUpOnePage(ArticleText);
X    return;
X`7D
X
X/*
X * called when the user wants to scroll the current article
X */
X/*ARGSUSED*/
Xvoid
XartScrollLineFunction(widget)
XWidget widget;
X`7B
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X#ifdef MOTIF
X#ifdef MOTIF_V10
X    XmTextDisableRedisplay(ArticleText, FALSE);
X#else
X    _XmTextDisableRedisplay((XmTextWidget) ArticleText, FALSE);
X#endif
X    XmTextScroll(ArticleText, 1);
X#ifdef MOTIF_V10
X    XmTextEnableRedisplay(ArticleText);
X#else
X    _XmTextEnableRedisplay((XmTextWidget) ArticleText);
X#endif
X#else
X    DwtTextDisableRedisplay(ArticleText, FALSE);
X    (void) DwtTextScroll(ArticleText, 1);
X    DwtTextEnableRedisplay(ArticleText);
X#endif
X    return;
X`7D
X
X/*
X * called when the user wants to scroll the current article
X */
X/*ARGSUSED*/
Xvoid
XartScrollBackLineFunction(widget)
XWidget widget;
X`7B
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X#ifdef MOTIF
X#ifdef MOTIF_V10
X    XmTextDisableRedisplay(ArticleText, FALSE);
X#else
X    _XmTextDisableRedisplay((XmTextWidget) ArticleText, FALSE);
X#endif
X    XmTextScroll(ArticleText, -1);
X#ifdef MOTIF_V10
X    XmTextEnableRedisplay(ArticleText);
X#else
X    _XmTextEnableRedisplay((XmTextWidget) ArticleText);
X#endif
X#else
X    DwtTextDisableRedisplay(ArticleText, FALSE);
X    (void) DwtTextScroll(ArticleText, -1);
X    DwtTextEnableRedisplay(ArticleText);
X#endif
X    return;
X`7D
X
Xvoid
XartScrollIndexFunction(widget)
XWidget widget;
X/*
X * called when the user wants to scroll the index window
X */
X`7B
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    return;
X`7D
X
X/*ARGSUSED*/
Xvoid
XartScrollIndexBackFunction(widget)
XWidget widget;
X/*
X * called when the user wants to scroll the index window
X */
X`7B
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    return;
X`7D
X
X/*
X * called when the user wants to scroll the current article
X */
X/*ARGSUSED*/
Xvoid
XartScrollEndFunction(widget)
XWidget widget;
X`7B
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X#ifdef MOTIF
X    XmTextShowPosition(ArticleText, XmTextGetLastPosition(ArticleText));
X    XmTextScroll(ArticleText, -1);
X#else
X    DwtTextShowPosition(ArticleText, DwtSTextGetLastPosition(ArticleText));
X    DwtTextScroll(ArticleText, -1);
X#endif
X    return;
X`7D
X
X
X/*ARGSUSED*/
Xvoid
XartScrollBeginningFunction(widget)
XWidget widget;
X/*
X * called when the user wants to scroll the current article
X */
X`7B
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X#ifdef MOTIF
X    XmTextShowPosition(ArticleText, 0);
X#else
X    DwtTextShowPosition(ArticleText, 0);
X#endif
X    return;
X`7D
X
X/*
X * called when the user wants to go to the next unread news
X * article in the current newsgroup
X *`20
X */
Xvoid
XartNextUnreadFunction(widget)
XWidget widget;
X`7B
X    void artNextFunction();
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    if (app_resources.nextReadsFirst) `7B
X`09ArtPosition = 0;
X    `7D
X    ArtStatus = art_UNREAD;
X    artNextFunction(widget);
X    return;
X`7D
X
X/*
X * called when the user wants to read the previous article
X */
X/*ARGSUSED*/
Xvoid
XartPrevFunction(widget)
XWidget widget;
X`7B
X    art_num artNum;
X    char *text, *question;
X
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    ArtStatus = art_PREV;
X    if (ArtPosition <= 0) `7B
X`09ArtPosition = 0;
X`09if (getPrevious(&artNum)) `7B
X`09    gotoArticle(artNum);
X`09    (void) getArticleText(&text, &question);
X`09    foundArticle(text, question, artNum);
X`09    ArtStatus = art_NEXT;
X`09    return;
X`09`7D
X`09setTopInfoLine("No previous article available");
X`09return;
X    `7D
X    ArtStatus = art_PREV;
X    if (getNearbyArticle(ArtStatus, &text, &question,
X`09`09`09 &artNum) == art_DONE) `7B
X`09exitArticleMode();
X`09return;
X    `7D
X    foundArticle(text, question, artNum);
X    ArtStatus = art_NEXT;
X   `20
X    return;
X`7D
X
X/*ARGSUSED*/
Xvoid
XartReadFunction(widget)
XWidget widget;
X/*
X * called when the user wants to read the current article
X */
X`7B
X    char *text;`09`09`09/* text of the article */
X    char *question;`09`09/* question to put in the question box */
X    art_num artNum;
X
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    ArtStatus = art_CURRENT;
X    if (getNearbyArticle(ArtStatus, &text, &question,
X`09`09`09 &artNum) == art_DONE) `7B
X`09exitArticleMode();
X`09return;
X    `7D
X    /* update the text window */
X    foundArticle(text, question, artNum);
X
X    ArtStatus = art_NEXT;
X    return;
X`7D
X
X
X/*ARGSUSED*/
Xvoid
XartNextGroupFunction(widget)
XWidget widget;
X`7B
X    void artQuitFunction();
X    char name`5BGROUP_NAME_SIZE`5D;
X    int append = 0;
X    int i;
X    struct newsgroup *LastGroupStruct = CurrentGroup;
X
X    PrevArticle = CurrentArticle = 0;
X    SubjectItems = 0;
X
X#ifdef MOTIF
X    XmTextSetString(ArticleText, NULL);
X    XmTextSetEditable(ArticleText, FALSE);
X#else
X    DwtSTextSetString(ArticleText, "");
X    DwtSTextSetEditable(ArticleText, FALSE);
X#endif
X    setBottomInfoLine("");
X    releaseNewsgroupResources();
X
X    while (1) `7B
X`09/*
X`09 * XXX if the newsgroup is fully read, then when the new newsgroup
X`09 * string is regenerated (upon entry to newsgroup mode), the string
X`09 * for this group will not be there and thus the Group Position will
X`09 * be too far forward (by one group)
X`09 */
X
X`09if (NewsGroups != NIL(ng_num)) `7B
X`09    FREE(NewsGroups);
X`09    NewsGroups = (ng_num *)0;
X`09`7D
X
X`09NewsGroups = unreadGroups(NewsgroupDisplayMode, &unreadNews);
X`09GroupItems = 0;
X`09for (i=0;NewsGroups`5Bi`5D != -1;i++) `7B
X`09    GroupItems++;
X`09`7D
X`09if (GroupPosition >= GroupItems) `7B
X`09    GroupPosition = 0;
X`09    artQuitFunction(widget);
X`09    return;
X`09`7D
X`09strcpy(name, groupName(NewsGroups`5BGroupPosition`5D));
X`09if (STREQ(name, LastGroup)) `7B
X`09    /* last group not fully read */
X`09    GroupPosition++;
X`09    if (GroupPosition >= GroupItems) `7B
X`09`09artQuitFunction(widget);
X`09`09return;
X`09    `7D
X`09    strcpy(name, groupName(NewsGroups`5BGroupPosition`5D));
X`09`7D
X
X`09if ((name == NIL(char)) `7C`7C (*name == '\0')) `7B
X`09    artQuitFunction(widget);
X`09    return;
X`09`7D
X
X`09setTitleBar("Opening newsgroup - please wait");
X`09if (gotoNewsgroup(name) != GOOD_GROUP) `7B
X`09    mesgPane(XRN_SERIOUS `7C append,
X`09`09"Bad group `60%s', skipping to next group", name);
X`09    append = XRN_APPEND;
X`09    (void) strcpy(LastGroup, name);
X`09    GroupPosition++;
X`09    continue;
X`09`7D
X
X`09if (getNewsgroup() == XRN_NOMORE) `7B
X`09    mesgPane(XRN_INFO `7C append,
X`09`09       "No unread articles in `60%s', skipping to next group",
X`09`09       name);
X`09    if (NewsgroupDisplayMode) `7B
X`09`09if (GroupPosition >= GroupItems) `7B
X`09`09    artQuitFunction(widget);
X`09`09    return;
X`09`09`7D
X`09    `7D
X`09    append = XRN_APPEND;
X`09    GroupPosition++;
X`09    continue;
X`09`7D
X
X`09if (switchToArticleMode(app_resources.autoRead) == GOOD_GROUP) `7B
X`09    (void) strcpy(LastGroup, name);
X`09    if (app_resources.updateNewsrc == TRUE) `7B
X`09`09while (!updatenewsrc())
X`09`09    ehErrorRetryXRN("Cannot update .newsrc", True);
X`09    `7D
X`09    return;
X`09`7D
X`09 /*
X`09  * Normally, I'd put a call to mesgPane in here to tell the
X`09  * user that the switchToArticleMode failed, but it isn't
X`09  * necessary because switchToArticleMode calls bogusNewsgroup
X`09  * if it fails, and bogusNewsgroup calls mesgPane with an
X`09  * appropriate message.
X`09  */
X    `7D
X`7D
X
X
X/*ARGSUSED*/
Xvoid
XartFedUpFunction(widget)
XWidget widget;
X`7B
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"No",`09generalHandler, (caddr_t) XRN_NO`7D,
X`09`7B"Yes",`09generalHandler, (caddr_t) XRN_YES`7D,
X    `7D;
X
X    if (app_resources.confirmMode & ART_FEDUP) `7B
X`09Action = ART_FEDUP;
X`09if (FedUpConfirmBox == (Widget) 0) `7B
X`09    FedUpConfirmBox = CreateDialog(TopLevel, "Confirm Fed Up",
X`09`09`09`09`09   "Are you sure?",
X`09`09`09`09`09   DIALOG_NOTEXT, args, XtNumber(args));
X`09`7D
X`09PopUpDialog(FedUpConfirmBox);
X`09return;
X    `7D
X
X    fedUpART();
X    return;
X`7D
X
X
X/*
X * called when the user wants to mark all articles in the current group as r
Vead
X */
X/*ARGSUSED*/
Xvoid
XartCatchUpFunction(widget)
XWidget widget;
X`7B
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Yes",`09generalHandler, (caddr_t) XRN_YES`7D,
X`09`7B"No",`09generalHandler, (caddr_t) XRN_NO`7D,
X    `7D;
X
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    if (SelectionItem < 0) `7B
X`09SelectionItem = SListGetHighlight(TopList);
X    `7D
X    ArtPosition++;
X    if (ArtPosition >= SubjectItems)
X`09ArtPosition = SubjectItems - 1;
X    if (app_resources.confirmMode & ART_CATCHUP) `7B
X`09Action = ART_PART_CATCHUP;
X`09if (PartCatchUpConfirmBox == (Widget) 0) `7B
X`09`09PartCatchUpConfirmBox = CreateDialog(TopLevel,
X`09`09`09`09"Position Catch Up Confirm",
X`09`09`09`09"OK to catch up to current position?",
X`09`09`09`09DIALOG_NOTEXT, args, XtNumber(args));
X`09`7D
X`09PopUpDialog(PartCatchUpConfirmBox);
X    `7D else `7B
X`09catchUpPartART();
X    `7D
X    return;
X`7D
X
X/*
X * called when the user wants to mark all articles in the current group as r
Vead
X */
X/*ARGSUSED*/
Xvoid
XartCatchUpAllFunction(widget)
XWidget widget;
X`7B
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Yes",`09generalHandler, (caddr_t) XRN_YES`7D,
X`09`7B"No",`09generalHandler, (caddr_t) XRN_NO`7D,
X    `7D;
X
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    if (app_resources.confirmMode & ART_CATCHUP) `7B
X`09Action = ART_CATCHUP;
X`09if (CatchUpConfirmBox == (Widget) 0) `7B
X`09`09CatchUpConfirmBox = CreateDialog(TopLevel,
X`09`09`09`09"Position Catch Up Confirm",
X`09`09`09`09"OK to catch up entire group?",
X`09`09`09`09DIALOG_NOTEXT, args, XtNumber(args));
X`09`7D
X`09PopUpDialog(CatchUpConfirmBox);
X    `7D else `7B
X`09catchUpART();
X    `7D
X    return;
X`7D
X
X
X/*
X
X/*
X * called when the user wants to unsubscribe to the current group
X */
X/*ARGSUSED*/
Xvoid
XartUnsubFunction(widget)
XWidget widget;
X`7B
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Yes",`09generalHandler, (caddr_t) XRN_YES`7D,
X`09`7B"No",`09generalHandler, (caddr_t) XRN_NO`7D,
X    `7D;
X
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    if (app_resources.confirmMode & ART_UNSUBSCRIBE) `7B
X`09Action = ART_UNSUBSCRIBE;
X`09if (UnSubConfirmBox == (Widget) 0) `7B
X`09    UnSubConfirmBox = CreateDialog(TopLevel, "Confirm Unsubscribe",
X`09`09`09`09"OK to unsubscribe?",
X`09`09`09`09DIALOG_NOTEXT, args, XtNumber(args));
X`09`7D
X`09PopUpDialog(UnSubConfirmBox);
X`09return;
X    `7D
X    unsubscribeART();
X    return;
X`7D
X
X/*
X * Get selection region, mark articles, redisplay subject window.
X */
Xvoid
XmarkFunction(marker)
Xchar marker;
X`7B
X    int i;
X    int count = 0;
X    int save, top;
X
X    if ((top = SListGetTop(TopList)) == -1) top = 0;
X    save = ArtPosition;
X
X    for (i = 0; i < SubjectItems; i++) `7B
X`09if (SListIsSelected(TopList,i)) `7B
X`09    markArticle(ArticleNumbers`5Bi`5D, marker);
X`09    if (app_resources.watchProgress) `7B
X`09`09updateSubjectWidget(i, i, False);
X`09    `7D
X`09    count++;
X`09`7D
X    `7D
X
X    if (!app_resources.watchProgress) `7B
X`09for (i=0; i < SubjectItems; i++) `7B
X`09    SListUpdateLine(TopList, i);
X`09`7D
X    `7D
X
X    subjSetPos(TopList, save, True);
X    ArtPosition = save;
X
X    resetSelection();
X
X    if (count == 0) `7B
X`09count = 1;
X`09markArticle(ArticleNumbers`5BArtPosition`5D, marker);
X`09SListUpdateLine(TopList, ArtPosition);
X    `7D
X
X    ArtPosition = save;
X    SListSetTop(TopList, top);
X    setBottomInfoLine(currentQuestion());
X
X    return;
X`7D
X
X
X/*
X * Mark selected article(s) as read
X */
X/*ARGSUSED*/
Xvoid
XartMarkReadFunction(widget)
XWidget widget;
X`7B
X    char marker = '+';
X
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X
X    markFunction(marker);
X    return;
X`7D
X
X
X/*
X * Mark selected article(s) as unread
X */
X/*ARGSUSED*/
Xvoid
XartMarkUnreadFunction(widget)
XWidget widget;
X`7B
X    char marker = 'u';
X
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    markFunction(marker);
X    return;
X`7D
X
X/*
X * allow user to post to the newsgroup currently being read
X */
X/*ARGSUSED*/
Xvoid
XartPostFunction(widget)
XWidget widget;
X`7B
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    post();
X   `20
X    return;
X`7D
X
X#define EA_Next 1
X#define EA_Followup 2
X#define EA_Quit 3
X#define EA_Cancel 4
X/*ARGSUSED*/
Xstatic void
XendActionHandler(widget, client_data, call_data)
XWidget widget;
Xcaddr_t client_data;
Xcaddr_t call_data;
X`7B
X    PopDownDialog(EndActionBox);
X    if (inCommand) `7B
X`09XBell(XtDisplay(TopLevel), 0);
X`09return;
X    `7D
X    inCommand = 1;
X    busyCursor();
X    switch((int) client_data) `7B
X`09case EA_Next:
X`09    artNextUnreadFunction((Widget) 0);
X`09    break;
X`09case EA_Followup:
X`09    artFollowupFunction((Widget) 0);
X`09    break;
X`09case EA_Quit:
X`09    artQuitFunction((Widget) 0);
X`09    break;
X`09case EA_Cancel:
X`09    break;
X    `7D
X    unbusyCursor();
X    inCommand = 0;
X    return;
X`7D
X
X/*ARGSUSED*/
Xvoid
XartSubNextFunction(widget)
XWidget widget;
X`7B
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Next Unread", endActionHandler, (caddr_t) EA_Next`7D,
X`09`7B"Followup",    endActionHandler, (caddr_t) EA_Followup`7D,
X`09`7B"Cancel",`09endActionHandler, (caddr_t) EA_Cancel`7D,
X`09`7B"Return",`09endActionHandler, (caddr_t) EA_Quit`7D,
X    `7D;
X
X    char *text, *question;
X    char *subject;
X    art_num artNum;
X    int status;
X   `20
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    if (SelectionItem < 0) `7B
X`09SelectionItem = SListGetHighlight(TopList);
X    `7D
X    if (SelectionItem >= 0) `7B
X`09ArtPosition = SelectionItem;
X`09resetSelection();
X    `7D
X    if (ArtPosition >= SubjectItems)
X`09ArtPosition = SubjectItems - 1;
X    artNum = ArticleNumbers`5BArtPosition`5D;
X    subject = XtNewString(getSubject(artNum));
X    (void) sprintf(error_buffer, "Subject search: %s", subject);
X    info(error_buffer);
X    status = isNextSubject(subject, &text, &question, &artNum);
X    switch (status) `7B
X`09  case ABORT:
X    `09    FREE(subject);
X`09    infoNow("search has been aborted");
X`09    return;
X`09  case NOCHANGE:
X`09    (void) sprintf(error_buffer, "Subject search: %s", subject);
X`09    info(error_buffer);
X    `09    FREE(subject);
X`09    foundArticle(text, question, artNum);
X`09    return;
X`09  case DONE:
X    `09    FREE(subject);
X`09    if (app_resources.confirmMode & ART_ENDACTION) `7B
X`09`09if (EndActionBox == (Widget) 0) `7B
X`09`09`09EndActionBox = CreateDialog(TopLevel,
X`09`09`09"End Action Select",
X`09`09`09"End of subject. Next action?",
X`09`09`09DIALOG_NOTEXT, args, XtNumber(args));
X`09`09`7D
X`09`09PopUpDialog(EndActionBox);
X`09`09return;
X`09    `7D else `7B
X`09`09ArtPosition = 0;
X`09`09infoNow("Subject has been exhausted, returning to first unread article
V");
X`09`09if (getNearbyArticle(art_UNREAD, &text, &question,
X`09`09`09&artNum) == art_DONE) `7B
X`09`09    exitArticleMode();
X`09`09    return;
X`09`09`7D
X`09`09foundArticle(text, question, artNum);
X`09`09return;
X`09    `7D
X`09  case EXIT:
X    `09    FREE(subject);
X`09    exitArticleMode();
X`09    return;
X`09`7D
X    if (getNearbyArticle(art_NEXT, &text, &question, &artNum) == art_DONE) `
V7B
X`09exitArticleMode();
X`09return;
X    `7D
X    foundArticle(text, question, artNum);
X   `20
X    return;
X`7D
X`09
X
X/*ARGSUSED*/
Xvoid
XartSubPrevFunction(widget)
XWidget widget;
X`7B
X    char *subject;
X    art_num artNum;
X    char *text, *question;
X    int status;
X
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    if (SelectionItem < 0 )`7B
X`09SelectionItem = SListGetHighlight(TopList);
X`09if (SelectionItem < 0) SelectionItem = 0;
X`09if (SelectionItem >= SubjectItems) SelectionItem = SubjectItems - 1;
X`09ArtPosition = SelectionItem;
X`09/* nothing selected, we should be on a valid article */
X
X`09if (ArtPosition >= SubjectItems) `7B
X`09    resetSelection();
X`09    return;
X`09`7D
X`09artNum = ArticleNumbers`5BArtPosition`5D;
X`09subject = XtNewString(getSubject(artNum));
X`09(void) sprintf(error_buffer, "Subject search: %s", subject);
X`09info(error_buffer);
X`09status = isPrevSubject(subject, &text, &question, &artNum);
X`09FREE(subject);
X`09switch(status) `7B
X`09  case ABORT:
X`09    infoNow("search has been aborted");
X`09    return;
X`09  case NOCHANGE:
X`09    foundArticle(text, question, artNum);
X`09    return;
X`09  case CHANGE:
X`09    ArtPosition = 0;
X`09    resetSubjectWidget(ALL, False);
X`09    foundArticle(text, question, artNum);
X`09    return;
X`09  case DONE:
X`09    infoNow("Subject has been exhausted");
X`09    return;
X`09  case EXIT:
X`09    exitArticleMode();
X`09    return;
X`09`7D
X    `7D
X    ArtPosition = SelectionItem;
X    resetSelection();
X    if (ArtPosition < 0) ArtPosition = 0;
X    if (ArtPosition >= SubjectItems) ArtPosition = SubjectItems - 1;
X    artNum = ArticleNumbers`5BArtPosition`5D;
X    gotoArticle(artNum);
X    subjSetPos(TopList, ArtPosition, True);
X    if (getArticleText(&text, &question) != XRN_OKAY) `7B
X`09if (getNearbyArticle(art_NEXT, &text, &question, &artNum) == art_DONE) `7
VB
X`09    exitArticleMode();
X`09    return;
X`09`7D
X`09infoNow(error_buffer);
X`09foundArticle(text, question, artNum);
X`09return;
X    `7D
X    infoNow(error_buffer);
X    foundArticle(text, question, artNum);
X   `20
X    return;
X`7D
X
X
Xchar *SubjectKilled;
X
X/*
X * Allow user to mark all articles with the current subject as read
X *
X * XXX get subject, kill using data structures, rebuild`20
X */
X/*ARGSUSED*/
Xstatic void
X_artKillSession(killThreads)
XBoolean killThreads;
X`7B
X    char *subject;
X    char *cursubject;
X    char *text, *question;
X    art_num artNum;
X   `20
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    if (SubjectItems <= 0) return;
X
X    if (SelectionItem > 0 && SelectionItem < SubjectItems) `7B
X`09ArtPosition = SelectionItem;
X    `7D else `7B
X`09SelectionItem = SListGetHighlight(TopList);
X`09if (SelectionItem >= 0)`20
X`09    ArtPosition = SelectionItem;
X    `7D
X    resetSelection();
X    if (ArtPosition >= SubjectItems) ArtPosition = SubjectItems - 1;
X    artNum = ArticleNumbers`5BArtPosition`5D;
X    subject = XtNewString(getSubject(artNum));
X    SubjectKilled = XtNewString(subject);
X    ArtPosition = 0;
X    while (ArtPosition < SubjectItems) `7B
X`09artNum = ArticleNumbers`5BArtPosition`5D;
X`09cursubject = getSubject(artNum);
X`09/* only kill those that have not been marked as unread */
X`09if (STREQ(subject, cursubject) && !articleMarkedUnread(artNum)) `7B
X`09    markArticleAsKilled(artNum);
X`09    SListUpdateLine(TopList, ArtPosition);
X`09    if (killThreads) `7B
X`09`09killThread(artNum);
X`09    `7D
X`09`7D
X`09ArtPosition++;
X    `7D
X    /* set the cursor back to the beginning of the subject screen */
X    clearArtCache();
X    ArtPosition = 0;
X    infoNow("Subject has been killed, returning to first unread article");
X    FREE(subject);
X
X    if (!app_resources.retainKilledArticles)
X`09resetSubjectWidget(UNKILLED, True);
X    if (app_resources.autoRead) `7B
X`09if (SubjectItems == 0 `7C`7C
X`09    getNearbyArticle(art_UNREAD, &text, &question, &artNum)
X`09`09== art_DONE) `7B
X`09    exitArticleMode();
X`09    return;
X`09`7D
X`09foundArticle(text, question, artNum);
X    `7D else `7B
X`09if (getNearbyArticle(art_FINDUNREAD, &text, &question, &artNum) ==`20
X`09`09art_DONE) `7B
X`09    return;
X`09`7D
X`09setBottomInfoLine(currentQuestion());
X    `7D`09
X    return;
X`7D
X
X/*ARGSUSED*/
Xvoid
XartKillSessionFunction(widget)
XWidget widget;
X`7B
X    if (app_resources.sortedSubjects == THREAD_SORTED) `7B
X`09_artKillSession(True);
X    `7D else `7B
X`09_artKillSession(False);
X    `7D
X    FREE(SubjectKilled);
X    return;
X`7D
X
X/*
X * Allow user to mark all articles with the current author as read
X *
X */
X/*ARGSUSED*/
Xvoid
XartKillAuthorFunction(widget)
XWidget widget;
X`7B
X    char *author;
X    char *curauthor;
X    char *text, *question;
X    art_num artNum;
X   `20
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    if (SelectionItem >= 0 && SelectionItem < SubjectItems) `7B
X`09ArtPosition = SelectionItem;
X    `7D else `7B
X`09SelectionItem = SListGetHighlight(TopList);
X`09if (SelectionItem >= 0)
X`09`09ArtPosition = SelectionItem;
X    `7D
X    if (ArtPosition >= SubjectItems) ArtPosition = SubjectItems - 1;
X    resetSelection();
X    artNum = ArticleNumbers`5BArtPosition`5D;
X    author = XtNewString(getAuthor(artNum));
X    ArtPosition = 0;
X    while (ArtPosition < SubjectItems) `7B
X`09artNum = ArticleNumbers`5BArtPosition`5D;
X`09curauthor = getAuthor(artNum);
X`09/* only kill those that have not been marked as unread */
X`09if ((STREQ(author, curauthor)) && !articleMarkedUnread(artNum)) `7B
X`09    markArticleAsKilled(artNum);
X`09    SListUpdateLine(TopList, ArtPosition);
X`09`7D
X`09ArtPosition++;
X    `7D
X    /* set the cursor back to the beginning of the subject screen */
X    clearArtCache();
X    killItem(author, KILL_LOCAL);
X    FREE(author);
X    ArtPosition = 0;
X    infoNow("Author has been killed, returning to first unread article");
X
X    if (!app_resources.retainKilledArticles)
X`09resetSubjectWidget(UNKILLED, True);
X    if (app_resources.autoRead) `7B
X`09if (SubjectItems == 0 `7C`7C`20
X`09    getNearbyArticle(art_UNREAD, &text, &question, &artNum)
X`09`09== art_DONE) `7B
X`09    exitArticleMode();
X`09    return;
X`09`7D
X`09foundArticle(text, question, artNum);
X    `7D else `7B
X`09if (getNearbyArticle(art_FINDUNREAD, &text, &question, &artNum) ==`20
X`09`09art_DONE) `7B
X`09    return;
X`09`7D
X`09setBottomInfoLine(currentQuestion());
X    `7D`09
X   `20
X    return;
X`7D
X
X/*ARGSUSED*/
Xvoid
XartKillLocalFunction(widget)
XWidget widget;
X`7B
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    _artKillSession(False);
X    killItem(SubjectKilled, KILL_LOCAL);
X    FREE(SubjectKilled);
X    return;
X`7D
X
X/*ARGSUSED*/
Xvoid
XartKillGlobalFunction(widget)
XWidget widget;
X`7B
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    _artKillSession(False);
X    killItem(SubjectKilled, KILL_GLOBAL);
X    FREE(SubjectKilled);
X    return;
X`7D
X
X/*ARGSUSED*/
Xvoid
XartEditKillFileFunction(widget)
XWidget widget;
X`7B
X    EditKillFile(CurrentGroup);
X    return;
X`7D
X
X/*ARGSUSED*/
Xvoid
XartEditGlobalKillFileFunction(widget)
XWidget widget;
X`7B
X    EditKillFile((struct newsgroup *)NULL);
X    return;
X`7D
X
X/*ARGSUSED*/
Xvoid
XartListOldFunction(widget)
XWidget widget;
X`7B
X    char *text, *question;
X    int SavePosition;
X    int status;
X    art_num artNum;
X    art_num saveArtNum;
X    struct newsgroup *newsgroup = CurrentGroup;
X    struct artStat *artstat = GETSTATUS(newsgroup);
X
X    busyCursor();
X    resetSelection();   `20
X    SavePosition = ArtPosition;
X    saveArtNum = ArticleNumbers`5BArtPosition`5D;
X
X    if (oldListed) `7B
X`09oldListed = False;
X`09artNum = newsgroup->initial = oldInitial;`09
X    `7D else `7B
X`09oldListed = True;
X`09oldInitial = newsgroup->initial;
X`09artNum = newsgroup->first;
X    `7D
X   `20
X    for (;artNum<=newsgroup->last;artNum++) `7B
X`09if (IS_UNAVAIL(artstat`5BINDEX(artNum)`5D)) `7B
X`09    continue;
X`09`7D
X`09status = moveToArticle(artNum, &text, &question);
X
X`09switch (status) `7B
X
X`09case NOMATCH:
X`09    mesgPane(XRN_SERIOUS,
X`09`09"First article (number %d) not available", artNum);
X`09    break;
X
X`09case ERROR:
X`09    break;
X
X`09case MATCH:
X`09    resetSubjectWidget(ALL, False);
X`09    ArtPosition = 0;
X`09    gotoArticle(saveArtNum);
X`09    foundArticle(text, question, saveArtNum);
X`09    unbusyCursor();
X`09    return;
X`09`7D
X    `7D
X    unbusyCursor();
X    return;
X`7D
X
X/*
X * update the .newsrc file
X */
X/*ARGSUSED*/
Xvoid
XartCheckPointFunction(widget)
XWidget widget;
X`7B
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X
X    while (!updatenewsrc())
X`09ehErrorRetryXRN("Cannot update .newsrc", True);
X
X    return;
X`7D
X
X
X#define XRNgotoArticle_ABORT`090
X#define XRNgotoArticle_DOIT`091
X
Xstatic Widget GotoArticleBox = (Widget) 0;
X
X
X/*ARGSUSED*/
Xstatic void`20
XgotoArticleHandler(widget, client_data, call_data)
XWidget widget;
Xcaddr_t client_data;
Xcaddr_t call_data;
X`7B
X    char *numberstr;
X    char *text, *question;
X    int SavePosition;
X    int status;
X    art_num artNum;
X    int i;
X
X    if (inCommand) `7B
X`09XBell(XtDisplay(TopLevel), 0);
X`09return;
X    `7D
X    inCommand = 1;
X    PopDownDialog(GotoArticleBox);
X    busyCursor();
X    SListSelectAll(TopList, 0);
X    if ((int) client_data == XRNgotoArticle_ABORT) `7B
X`09unbusyCursor();
X`09inCommand = 0;
X`09return;
X    `7D
X    SavePosition = ArtPosition;
X    numberstr = GetDialogValue(GotoArticleBox);
X    if (numberstr == NIL(char)) `7B
X`09mesgPane(XRN_INFO, "Bad article number");
X`09unbusyCursor();
X`09inCommand = 0;
X`09return;
X    `7D
X
X    artNum = atol(numberstr);
X    if (artNum == 0) `7B
X`09mesgPane(XRN_SERIOUS, "Bad article number");
X`09unbusyCursor();
X`09inCommand = 0;
X`09return;
X    `7D
X   `20
X    status = moveToArticle(artNum, &text, &question);
X
X    switch (status) `7B
X
X      case NOMATCH:
X`09mesgPane(XRN_SERIOUS, "Article number %d not available", artNum);
X`09break;
X
X      case ERROR:
X`09ArtPosition = SavePosition;
X`09break;
X
X      case MATCH:
X`09resetSubjectWidget(ACTIVE, False);
X`09if (SubjectItems > 0) `7B
X`09    for (i = 0; i < SubjectItems; i++) `7B
X`09`09if (ArticleNumbers`5Bi`5D == artNum) `7B
X`09`09    ArtPosition = i;
X`09`09    break;
X`09`09`7D
X`09    `7D
X`09`7D
X`09gotoArticle(artNum);
X`09foundArticle(text, question, artNum);
X`09break;
X    `7D
X
X    unbusyCursor();
X    inCommand = 0;
X    return;
X`7D
X
X/*ARGSUSED*/
Xvoid
XartGotoArticleFunction(widget)
XWidget widget;
X`7B
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Go To Article", gotoArticleHandler, (caddr_t) XRNgotoArticle_DOIT`7D,
X`09`7B"Cancel",`09  gotoArticleHandler, (caddr_t) XRNgotoArticle_ABORT`7D,
X    `7D;
X   `20
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    if (GotoArticleBox == (Widget) 0) `7B
X`09GotoArticleBox = CreateDialog(TopLevel, "Go To Article Select",
X`09`09`09`09"Article Number:",
X`09`09`09`09DIALOG_TEXT, args, XtNumber(args));
X    `7D
X    PopUpDialog(GotoArticleBox);
X    return;
X`7D
X
X#define XRNSearch_ABORT 0
X#define XRNSearch_FORWARD 1
X#define XRNSearch_BACK 2
X
Xstatic Widget SearchBox = (Widget) 0;
Xstatic Widget AuthorSearchBox = (Widget) 0;
X
X/*ARGSUSED*/
Xstatic void`20
XsubSearchHandler(widget, client_data, call_data)
XWidget widget;
Xcaddr_t client_data;
Xcaddr_t call_data;
X`7B
X    char *regexpr;
X    char *text, *question;
X    int SavePosition;
X    int status;
X    int direction;
X    art_num artNum;
X
X    if (inCommand) `7B
X`09XBell(XtDisplay(TopLevel), 0);
X`09return;
X    `7D
X    inCommand = 1;
X
X    busyCursor();
X    if ((int) client_data == XRNSearch_ABORT) `7B
X`09if (SearchBox) PopDownDialog(SearchBox);
X`09inCommand = 0;
X`09unbusyCursor();
X`09return;
X    `7D
X    if (SelectionItem > 0) `7B
X`09ArtPosition = SelectionItem;`20
X    `7D else `7B
X`09SelectionItem = SListGetHighlight(TopList);
X`09if (SelectionItem >= 0)
X`09    ArtPosition = SelectionItem;
X    `7D
X    if (ArtPosition >= SubjectItems) `7B
X`09ArtPosition = SubjectItems - 1;
X    `7D
X    SavePosition = ArtPosition;
X    regexpr = GetDialogValue(SearchBox);
X    if (*regexpr == 0) `7B
X`09if (LastRegexp == NIL(char)) `7B
X`09    mesgPane(XRN_INFO, "No previous regular expression");
X`09    if (SearchBox) PopDownDialog(SearchBox);
X`09    inCommand = 0;
X`09    unbusyCursor();
X`09    return;`09  `20
X`09`7D
X`09regexpr = LastRegexp;
X    `7D else `7B
X`09if (LastRegexp != NIL(char)) `7B
X`09    FREE(LastRegexp);
X`09`7D
X`09LastRegexp = XtNewString(regexpr);
X    `7D
X   `20
X    /* XXX */
X    if (SearchBox) PopDownDialog(SearchBox);
X
X    direction = ((int) client_data == XRNSearch_FORWARD) ? FORWARD : BACK;
X    LastWasAuthor = False;
X    LastSearch = direction;
X    status = subjectSearch(direction, ArticleNumbers,
X`09`09`09   &ArtPosition, LastRegexp,
X`09`09`09   &text, &question, &artNum);
X    switch (status) `7B
X      case ABORT:
X`09infoNow("search aborted");
X`09ArtPosition = SavePosition;
X`09subjSetPos(TopList, ArtPosition, True);
X`09break;
X      case NOMATCH:
X`09(void) sprintf(error_buffer, "Search for expression %s: no match was foun
Vd",
X`09`09       LastRegexp);
X`09infoNow(error_buffer);
X      case ERROR:
X`09ArtPosition = SavePosition;
X`09subjSetPos(TopList, ArtPosition, True);
X`09break;
X      case MATCH:
X`09(void) sprintf(error_buffer, "Search for expression %s", LastRegexp);
X`09infoNow(error_buffer);
X`09foundArticle(text, question, artNum);
X`09break;
X      case WINDOWCHANGE:
X`09(void) sprintf(error_buffer, "Search for expression %s", LastRegexp);
X`09infoNow(error_buffer);
X`09ArtPosition = 0;
X`09resetSubjectWidget(ALL, False);
X`09foundArticle(text, question, artNum);
X`09break;
X      case EXIT:
X`09exitArticleMode();
X`09break;
X    `7D
X    if (SearchBox) PopDownDialog(SearchBox);
X    inCommand = 0;
X    unbusyCursor();
X    return;
X`7D
X/*ARGSUSED*/
Xstatic void`20
XauthorSearchHandler(widget, client_data, call_data)
XWidget widget;
Xcaddr_t client_data;
Xcaddr_t call_data;
X`7B
X    char *regexpr;
X    char *text, *question;
X    int SavePosition;
X    int status;
X    int direction;
X    art_num artNum;
X
X    if (inCommand) `7B
X`09XBell(XtDisplay(TopLevel), 0);
X`09return;
X    `7D
X    inCommand = 1;
X
X    busyCursor();
X    if ((int) client_data == XRNSearch_ABORT) `7B
X`09if (AuthorSearchBox) PopDownDialog(AuthorSearchBox);
X`09inCommand = 0;
X`09unbusyCursor();
X`09return;
X    `7D
X    if (SelectionItem > 0) `7B
X`09ArtPosition = SelectionItem;
X    `7D else `7B
X`09SelectionItem = SListGetHighlight(TopList);
X`09if (SelectionItem >= 0)
X`09    ArtPosition = SelectionItem;
X    `7D
X    if (ArtPosition >= SubjectItems) `7B
X`09ArtPosition = SubjectItems - 1;
X    `7D
X    SavePosition = ArtPosition;
X    regexpr = GetDialogValue(AuthorSearchBox);
X    if (*regexpr == 0) `7B
X`09if (LastRegexp == NIL(char)) `7B
X`09    mesgPane(XRN_INFO, "No previous regular expression");
X`09    if (AuthorSearchBox) PopDownDialog(AuthorSearchBox);
X`09    inCommand = 0;
X`09    unbusyCursor();
X`09    return;`09  `20
X`09`7D
X`09regexpr = LastRegexp;
X    `7D else `7B
X`09if (LastRegexp != NIL(char)) `7B
X`09    FREE(LastRegexp);
X`09`7D
X`09LastRegexp = XtNewString(regexpr);
X    `7D
X   `20
X    /* XXX */
X    if (AuthorSearchBox) PopDownDialog(AuthorSearchBox);
X
X    direction = ((int) client_data == XRNSearch_FORWARD) ? FORWARD : BACK;
X    LastSearch = direction;
X    LastWasAuthor = True;
X    status = authorSearch(direction, ArticleNumbers,
X`09`09`09   &ArtPosition, LastRegexp,
X`09`09`09   &text, &question, &artNum);
X    switch (status) `7B
X      case ABORT:
X`09infoNow("search aborted");
X`09ArtPosition = SavePosition;
X`09subjSetPos(TopList, ArtPosition, True);
X`09break;
X      case NOMATCH:
X`09(void) sprintf(error_buffer, "Search for expression %s: no match was foun
Vd",
X`09`09       LastRegexp);
X`09infoNow(error_buffer);
X      case ERROR:
X`09ArtPosition = SavePosition;
X`09subjSetPos(TopList, ArtPosition, True);
X`09break;
X      case MATCH:
X`09(void) sprintf(error_buffer, "Search for expression %s", LastRegexp);
X`09infoNow(error_buffer);
X`09foundArticle(text, question, artNum);
X`09break;
X      case WINDOWCHANGE:
X`09(void) sprintf(error_buffer, "Search for expression %s", LastRegexp);
X`09infoNow(error_buffer);
X`09ArtPosition = 0;
X`09resetSubjectWidget(ALL, False);
X`09foundArticle(text, question, artNum);
X`09break;
X      case EXIT:
X`09exitArticleMode();
X`09break;
X    `7D
X    if (AuthorSearchBox) PopDownDialog(AuthorSearchBox);
X    inCommand = 0;
X    unbusyCursor();
X    return;
X`7D
X
X
X/*ARGSUSED*/
Xvoid
XartSubSearchFunction(widget)
XWidget widget;
X`7B
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Forward", subSearchHandler, (caddr_t) XRNSearch_FORWARD`7D,
X`09`7B"Back",    subSearchHandler, (caddr_t) XRNSearch_BACK`7D,
X`09`7B"Cancel",  subSearchHandler, (caddr_t) XRNSearch_ABORT`7D,
X    `7D;
X   `20
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    if (SearchBox == (Widget) 0) `7B
X`09SearchBox = CreateDialog(TopLevel, "Subject Search Expression",
X`09`09`09`09"Regular Expression?",
X`09`09`09`09DIALOG_TEXT, args, XtNumber(args));
X    `7D
X    PopUpDialog(SearchBox);
X    return;
X`7D
X
X/*ARGSUSED*/
Xvoid
XartAuthorSearchFunction(widget)
XWidget widget;
X`7B
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Forward", authorSearchHandler, (caddr_t) XRNSearch_FORWARD`7D,
X`09`7B"Back",    authorSearchHandler, (caddr_t) XRNSearch_BACK`7D,
X`09`7B"Cancel",  authorSearchHandler, (caddr_t) XRNSearch_ABORT`7D,
X    `7D;
X   `20
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    if (AuthorSearchBox == (Widget) 0) `7B
X`09AuthorSearchBox = CreateDialog(TopLevel, "Author Search Expression",
X`09`09`09`09"Regular Expression?",
X`09`09`09`09DIALOG_TEXT, args, XtNumber(args));
X    `7D
X    PopUpDialog(AuthorSearchBox);
X    return;
X`7D
X
X/*ARGSUSED*/
Xvoid
XartCancelSearchFunction(widget)
XWidget widget;
X`7B
X    abortSet();
X`7D
X
X/*
X * Continue a previously started regular expression
X * search of the subject lines.  Search for same
X * regular expression, in same direction.
X */
X/*ARGSUSED*/
Xvoid
XartContinueFunction(widget)
XWidget widget;
X`7B
X    char *text, *question;
X    int SavePosition;
X    int status;
X    art_num artNum;
X
X    if (LastRegexp == NULL) `7B
X`09mesgPane(XRN_INFO, "No previous regular expression");
X`09return;
X    `7D
X    (void) sprintf(error_buffer, "Searching for expression %s", LastRegexp);
X    info(error_buffer);
X    resetSelection();
X    SavePosition = ArtPosition;
X    if (LastWasAuthor) `7B
X`09status = authorSearch(LastSearch, ArticleNumbers,
X`09`09`09`09&ArtPosition, LastRegexp,
X`09`09`09`09&text, &question, &artNum);
X    `7D else `7B
X`09status = subjectSearch(LastSearch, ArticleNumbers,
X`09`09`09`09&ArtPosition, LastRegexp,
X`09`09`09`09&text, &question, &artNum);
X    `7D
X    switch (status) `7B
X      case ABORT:
X`09infoNow("search aborted");
X`09ArtPosition = SavePosition;
X`09subjSetPos(TopList, ArtPosition, True);
X`09return;
X      case NOMATCH:
X`09(void) sprintf(error_buffer, "Search for expression %s: no match was foun
Vd", LastRegexp);
X`09infoNow(error_buffer);
X      case ERROR:
X`09ArtPosition = SavePosition;
X`09subjSetPos(TopList, ArtPosition, True);
X`09return;
X      case MATCH:
X`09(void) sprintf(error_buffer, "Search for expression %s", LastRegexp);
X`09infoNow(error_buffer);   `20
X`09foundArticle(text, question, artNum);
X`09return;
X      case WINDOWCHANGE:
X`09(void) sprintf(error_buffer, "Search for expression %s", LastRegexp);
X`09infoNow(error_buffer);
X`09ArtPosition = 0;
X`09resetSubjectWidget(ALL, False);
X`09foundArticle(text, question, artNum);
X`09return;
X      case EXIT:
X`09exitArticleMode();
X`09return;
X    `7D
X`7D
X
X/*
X * set order of sorting in subject widget and reload
X */
X/*ARGSUSED*/
Xstatic void
XchangeSortOrder(widget, neworder)
XWidget widget;
Xint neworder;
X`7B
X    art_num artNum, newArtNum;
X    int i;
X
X    if (ArtPosition < 0) ArtPosition = 0;
X    if (ArtPosition >= SubjectItems) ArtPosition = SubjectItems - 1;
X    if (SubjectItems == 0) `7B
X`09ArtPosition = 0;
X`09app_resources.sortedSubjects = neworder;
X`09resetSubjectWidget(ACTIVE, False);
X`09return;
X    `7D
X    artNum = ArticleNumbers`5BArtPosition`5D;
X    app_resources.sortedSubjects = neworder;
X    resetSubjectWidget(ACTIVE, False);
X    if (SubjectItems <= 0) return;
X    for (i=0; i < SubjectItems; i++) `7B
X`09newArtNum = ArticleNumbers`5Bi`5D;
X`09if (newArtNum == artNum) `7B
X`09    ArtPosition = i;
X`09    subjSetPos(TopList, ArtPosition, True);
X`09    return;
X`09`7D
X    `7D
X    ArtPosition = 0;
X    subjSetPos(TopList, ArtPosition, True);
X`7D
X
Xvoid
XartNonSortedFunction(widget)
XWidget widget;
X`7B
X    changeSortOrder(widget, UNSORTED);
X`7D
X`09
Xvoid
XartSortedFunction(widget)
XWidget widget;
X`7B
X    changeSortOrder(widget, ARTICLE_SORTED);
X`7D
X`09
Xvoid
XartStrictSortedFunction(widget)
XWidget widget;
X`7B
X    changeSortOrder(widget, STRICT_SORTED);
X`7D
X`09
Xvoid
XartThreadSortedFunction(widget)
XWidget widget;
X`7B
X    changeSortOrder(widget, THREAD_SORTED);
X`7D
X`09
X/*
X * Display the article accessed before the current one
X */
X/*ARGSUSED*/
Xvoid
XartLastFunction(widget)
XWidget widget;
X`7B
X    char *text, *question;
X    art_num artNum = 0;
X    int status;
X    int SavePosition;
X
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    if (PrevArticle <= 0) `7B
X`09mesgPane(XRN_INFO, "No previous article");
X`09return;
X    `7D
X
X    SavePosition = ArtPosition;
X    artNum = PrevArticle;
X
X    status = moveToArticle(artNum, &text, &question);
X    switch (status) `7B
X
X      case NOMATCH:
X`09mesgPane(XRN_SERIOUS, "Article number %d not available", artNum);
X`09break;
X
X      case ERROR:
X`09ArtPosition = SavePosition;
X`09break;
X
X      case MATCH:
X`09gotoArticle(artNum);
X`09foundArticle(text, question, artNum);
X`09break;
X    `7D
X    return;
X`7D
X
X/*
X * Exit from the current newsgroup, marking all articles as
X * unread
X */
X/*ARGSUSED*/
Xvoid
XartExitFunction(widget)
XWidget widget;
X`7B
X    int i;
X
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    for (i = 0; i < SubjectItems; i++) `7B
X`09markArticleAsUnread(ArticleNumbers`5Bi`5D);
X    `7D
X    exitArticleMode();
X   `20
X    return;
X`7D
X
X
X/*
X * unsubscribe to the remaining groups and exit add mode
X */
X/*ARGSUSED*/
Xvoid
XaddQuitFunction(widget)
XWidget widget;
X`7B
X    char newGroup`5BGROUP_NAME_SIZE`5D;
X    int left;
X    int status = UNSUBSCRIBE;
X
X    if (Mode != ADD_MODE) `7B
X`09return;
X    `7D
X    left = 0;
X
X    /*
X     * go through the remaining groups, add them
X     * to the end of the newsrc and unsubscribe them
X     */
X    while (left < AddGroupItems) `7B
X`09(void) strcpy(newGroup, AddGroups`5Bleft`5D->name);
X`09(void) addToNewsrcEnd(newGroup, status);
X`09left++;
X    `7D
X
X    exitAddMode();
X    return;
X`7D
X
X/*
X * Find selected group(s) and add them to the .newsrc in the first position.
X * Move the cursor to the next group.
X * Update the AddGroups, going into newsgroup mode if it
X * is NULL.  Update the text window, update the insertion point.
X *
X */
X/*ARGSUSED*/
Xvoid
XaddFirstFunction(widget)
XWidget widget;
X`7B
X    char newGroup`5BGROUP_NAME_SIZE`5D;
X    char oldGroup`5BGROUP_NAME_SIZE`5D;
X    int status = SUBSCRIBE;
X    int first = 1;
X    int i, top;
X
X    if (Mode != ADD_MODE) `7B
X`09return;
X    `7D
X    if (SelectionItem == -1) `7B
X`09AddGroupPosition = SListGetHighlight(TopList);
X`09if (AddGroupPosition >= 0) `7B
X`09    strcpy(newGroup, AddGroups`5BAddGroupPosition`5D->name);
X`09    (void) addToNewsrcBeginning(newGroup, status);
X`09`7D
X    `7D else `7B
X`09for (i = 0; i < AddGroupItems; i++) `7B
X`09    if (SListIsSelected(TopList, i)) `7B
X`09`09if (first) `7B
X`09`09    strcpy(newGroup, AddGroups`5Bi`5D->name);
X`09`09    (void) addToNewsrcBeginning(newGroup, status);
X`09`09    (void) strcpy(oldGroup, newGroup);
X`09`09    first = 0;
X`09`09`7D else `7B
X`09`09    strcpy(newGroup, AddGroups`5Bi`5D->name);
X`09`09    (void) addToNewsrcAfterGroup(newGroup, oldGroup, status);
X`09`09    (void) strcpy(oldGroup, newGroup);
X`09`09`7D
X`09    `7D
X`09`7D
X    `7D
X    resetSelection();
X
X    /* update the text window */
X    if ((top = SListGetTop(TopList)) == -1) top = 0;
X    redrawAddListWidget(top);
X    if (AddGroupItems <= 0) `7B
X`09exitAddMode();
X    `7D
X    return;
X`7D
X
X/*
X * add the currently selected group(s) to the end of the .newsrc file
X * and subscribe to them.
X */
X/*ARGSUSED*/
Xvoid
XaddLastFunction(widget)
XWidget widget;
X`7B
X    char newGroup`5BGROUP_NAME_SIZE`5D;
X    int status = SUBSCRIBE;
X    int i, top;
X
X    if (Mode != ADD_MODE) `7B
X`09return;
X    `7D
X    if (SelectionItem == -1) `7B
X`09AddGroupPosition = SListGetHighlight(TopList);
X`09if (AddGroupPosition >= 0) `7B
X`09    strcpy(newGroup, AddGroups`5BAddGroupPosition`5D->name);
X`09    (void) addToNewsrcEnd(newGroup, status);
X`09`7D
X    `7D else `7B
X`09for (i = 0; i < AddGroupItems; i++) `7B
X`09    if (SListIsSelected(TopList, i)) `7B
X`09`09strcpy(newGroup, AddGroups`5Bi`5D->name);
X`09`09(void) addToNewsrcEnd(newGroup, status);
X`09    `7D
X`09`7D
X    `7D
X    resetSelection();
X    if ((top = SListGetTop(TopList)) == -1) top = 0;
X    redrawAddListWidget(top);
X    if (AddGroupItems <= 0) `7B
X`09exitAddMode();
X    `7D
X    return;
X`7D
X
X
X/* entering the name of a newsgroup to add after */
X
X#define XRNadd_ADD 1
X#define XRNadd_ABORT 0
X
Xstatic Widget AddBox = (Widget) 0;
X
X/*
X * get the newsgroup to add a new newsgroup after in the .newsrc file
X */
X/*ARGSUSED*/
Xstatic void
XaddHandler(widget, client_data, call_data)
XWidget widget;
Xcaddr_t client_data;
Xcaddr_t call_data;
X`7B
X    char newGroup`5BGROUP_NAME_SIZE`5D;
X    char oldGroup`5BGROUP_NAME_SIZE`5D;
X    int status = SUBSCRIBE;
X    int first = 1;
X    int i, top;
X
X    if (inCommand) `7B
X`09XBell(XtDisplay(TopLevel), 0);
X`09return;
X    `7D
X    inCommand = 1;
X    busyCursor();
X    PopDownDialog(AddBox);
X
X    /* Handle "Cancel" press. */
X    if (client_data == (caddr_t) XRNadd_ABORT) `7B
X`09unbusyCursor();
X`09inCommand = 0;
X`09return;
X    `7D
X    if (SelectionItem == -1) `7B
X`09AddGroupPosition = SListGetHighlight(TopList);
X`09if (AddGroupPosition >= 0)  `7B
X`09    strcpy(newGroup, AddGroups`5BAddGroupPosition`5D->name);
X`09    (void)addToNewsrcAfterGroup(newGroup,GetDialogValue(AddBox),status);
X`09    resetSelection();
X`09    if ((top = SListGetTop(TopList)) == -1) top = 0;
X`09    redrawAddListWidget(top);
X`09    if (AddGroupItems <= 0) `7B
X`09`09exitAddMode();
X`09    `7D
X`09`7D
X`09unbusyCursor();
X`09inCommand = 0;
X`09return;
X    `7D
X    for (i = 0; i < AddGroupItems; i++) `7B
X`09if (SListIsSelected(TopList, i)) `7B
X`09    if (first) `7B
X`09`09strcpy(newGroup, AddGroups`5Bi`5D->name);
X`09`09if (!addToNewsrcAfterGroup(newGroup,
X`09`09`09`09      GetDialogValue(AddBox),
X`09`09`09`09      status) == GOOD_GROUP) `7B
X`09`09    /* Avoid deadlock */
X`09`09    unbusyCursor();
X`09`09    inCommand = 0;
X`09`09    return;
X`09`09`7D else `7B
X`09`09    first = 0;
X`09`09`7D
X`09    `7D else `7B
X`09`09strcpy(newGroup, AddGroups`5Bi`5D->name);
X`09`09(void) addToNewsrcAfterGroup(newGroup, oldGroup, status);
X`09    `7D
X`09    (void) strcpy(oldGroup, newGroup);
X`09`7D
X    `7D
X    resetSelection();
X    if ((top = SListGetTop(TopList)) == -1) top = 0;
X    redrawAddListWidget(top);
X    if (AddGroupItems <= 0) `7B
X`09exitAddMode();
X    `7D
X    unbusyCursor();
X    inCommand = 0;
X    return;
X`7D
X
X/*
X * subscribe to a new newsgroup, adding after a particular group in the
X * .newsrc file
X */
X/*ARGSUSED*/
Xvoid
XaddAfterFunction(widget)
XWidget widget;
X`7B
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Add",   addHandler, (caddr_t) XRNadd_ADD`7D,
X`09`7B"Cancel", addHandler, (caddr_t) XRNadd_ABORT`7D,
X    `7D;
X
X    if (Mode != ADD_MODE) `7B
X`09return;
X    `7D
X    if (AddBox == (Widget) 0) `7B
X`09AddBox = CreateDialog(TopLevel, "Subscribe After Select",
X`09`09`09`09"After which newsgroup?",
X`09`09`09`09DIALOG_TEXT, args, XtNumber(args));
X    `7D
X    PopUpDialog(AddBox);
X    return;
X`7D
X
X
X/*
X * add a group to the end of the .newsrc file as unsubscribed
X */
X/*ARGSUSED*/
Xvoid
XaddUnsubFunction(widget)
XWidget widget;
X`7B
X    char newGroup`5BGROUP_NAME_SIZE`5D;
X    int status = UNSUBSCRIBE;
X    int i, top;
X
X    if (Mode != ADD_MODE) `7B
X`09return;
X    `7D
X    if (SelectionItem == -1) `7B
X`09AddGroupPosition = SListGetHighlight(TopList);
X`09if (AddGroupPosition >= 0) `7B
X`09    strcpy(newGroup, AddGroups`5BAddGroupPosition`5D->name);
X`09    (void) addToNewsrcEnd(newGroup, status);
X`09`7D
X    `7D else `7B`09
X`09for (i = 0; i < AddGroupItems; i++) `7B
X`09    if (SListIsSelected(TopList, i)) `7B
X`09`09strcpy(newGroup, AddGroups`5Bi`5D->name);
X`09`09(void) addToNewsrcEnd(newGroup, status);
X`09    `7D
X`09`7D
X    `7D
X    resetSelection();
X    if ((top = SListGetTop(TopList)) == -1) top = 0;
X    redrawAddListWidget(top);
X    if (AddGroupItems <= 0)`7B
X`09exitAddMode();
X    `7D
X    return;
X`7D
X
X
X#define XRNsave_ABORT 0
X#define XRNsave_SAVE  1
X
Xstatic Widget SaveBox = (Widget) 0;  /* box for typing in the name of a file
V */
X
X/*
X * handler for the save box
X */
X/*ARGSUSED*/
Xstatic void
XsaveHandler(widget, client_data, call_data)
XWidget widget;
Xcaddr_t client_data;
Xcaddr_t call_data;
X`7B
X    int i, start, end, top, current;
X
X    if (inCommand) `7B
X`09XBell(XtDisplay(TopLevel), 0);
X`09return;
X    `7D
X    inCommand = 1;
X    busyCursor();
X    if ((top = SListGetTop(TopList)) == -1) top = 0;
X    current = ArtPosition;
X    PopDownDialog(SaveBox);
X    if ((int) client_data != XRNsave_ABORT) `7B
X`09if (SelectionItem != -1) `7B
X`09    for (i = 0; i < SubjectItems; i++) `7B
X`09`09if (SListIsSelected(TopList, i)) `7B
X`09`09    start = ArticleNumbers`5Bi`5D;
X`09`09    end = start;
X`09`09    if (!saveRangeOfArticles(GetDialogValue(SaveBox),
X`09`09`09`09`09     start, end))
X`09`09`09break;
X`09`09    markArticle(ArticleNumbers`5Bi`5D, 'S');
X`09`09    SListUpdateLine(TopList, i);
X`09`09`7D
X`09    `7D`20
X`09    resetSelection();
X`09    SListSetTop(TopList, top);
X`09    setBottomInfoLine(currentQuestion());
X`09`7D else `7B
X`09    if (saveCurrentArticle(GetDialogValue(SaveBox))) `7B
X`09`09markArticle(ArticleNumbers`5Bcurrent`5D, 'S');
X`09`09SListUpdateLine(TopList, current);
X`09    `7D
X`09    resetSelection();
X`09    SListSetTop(TopList, top);
X`09    setBottomInfoLine(currentQuestion());
X`09`7D
X`09if (SaveString) `7B
X`09    XtFree(SaveString);
X`09`7D
X`09SaveString = XtNewString(GetDialogValue(SaveBox));
X    `7D
X    unbusyCursor();
X    inCommand = 0;
X    resetSaveFlag();
X    return;
X`7D   `20
X
X/*
X * query the user about saving an article
X *
X *    brings up a dialog box
X *
X *    returns: void
X *
X */
X/*ARGSUSED*/
Xvoid
XartSaveFunction(widget, ev, params, num_params)
XWidget widget;
XXEvent *ev;
XString *params;
XCardinal *num_params;
X`7B
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Save",   saveHandler, (caddr_t) XRNsave_SAVE`7D,
X`09`7B"Cancel", saveHandler, (caddr_t) XRNsave_ABORT`7D,
X    `7D;
X
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    if (num_params && *num_params == 1) `7B
X`09int i, start, end;
X`09char *ssstring;
X`09ssstring = SaveString;
X`09SaveString = XtNewString(params`5B0`5D);
X `09busyCursor();
X
X`09if (SelectionItem != -1) `7B
X`09    for (i = 0; i < SubjectItems; i++) `7B
X`09`09if (SListIsSelected(TopList, i)) `7B
X`09`09    start = ArticleNumbers`5Bi`5D;
X`09`09    end = start;
X`09`09    (void) saveRangeOfArticles(SaveString, start, end);
X`09`09`7D
X`09    `7D`20
X`09    markFunction('S');
X`09`7D else `7B
X`09    if (saveCurrentArticle(SaveString)) `7B
X`09`09markArticle(ArticleNumbers`5BArtPosition`5D, 'S');
X`09`09SListUpdateLine(TopList, ArtPosition);
X`09    `7D
X`09`7D
X`09setBottomInfoLine(currentQuestion());
X`09if (SaveString)
X`09    XtFree(SaveString);
X`09SaveString = ssstring;
X`09return;
X    `7D
X    if (SaveBox == (Widget) 0) `7B
X`09if (app_resources.saveString) `7B
X`09    if (SaveString) `7B
X`09`09XtFree(SaveString);
X`09    `7D
X`09    SaveString = XtNewString(app_resources.saveString);
X`09`7D
X`09SaveBox = CreateDialog(
X`09`09`09(app_resources.twoWindows ? ArtTopLevel : TopLevel),
X`09`09`09"Save File Name Select",
X`09`09`09"File Name?",
X`09`09`09SaveString == NULL ? DIALOG_TEXT : SaveString,
X`09`09`09args, XtNumber(args));
X    `7D else `7B
X`09SetDialogValue(SaveBox, SaveString);
X    `7D
X    PopUpDialog(SaveBox);
X    return;
X`7D
X
X#ifdef XLATE
X/*
X * translate an article
X */
X/*ARGSUSED*/
Xvoid
XartXlateFunction(widget)
XWidget widget;
X`7B
X    char *text, *question;
X
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    if (toggleXlation(&text, &question) == XRN_OKAY) `7B
X`09redrawArticleWidget(text, question);
X    `7D
X    return;
X`7D
X#endif /* XLATE */
X
X/*ARGSUSED*/
Xvoid
XartPrintFunction(widget)
XWidget widget;
X`7B
X    static char buffer`5B512`5D;
X    struct newsgroup *newsgroup = CurrentGroup;
X    art_num art = newsgroup->current;
X    int i, start, end, top;
X
X#ifdef VMS
X    int status;
X    short msglen;
X    static int printNumber = 0;
X    struct dsc$descriptor_s buf_desc = `7B sizeof(buffer)-1,
X`09DSC$K_DTYPE_T, DSC$K_CLASS_S, buffer `7D;
X
X    if ((top = SListGetTop(TopList)) == -1) top = 0;
X
X    if (!app_resources.delayedPrint) `7B
X`09printNumber++;
X`09(void) sprintf(buffer, "%sXRN_PRINT_%u.LIS", app_resources.tmpDir,
X`09`09printNumber);
X    `7D else `7B
X`09(void) sprintf(buffer, "%sXRN_PRINT_%u.LIS",
X`09`09app_resources.tmpDir, getpid());
X    `7D
X    if (SelectionItem != -1) `7B
X`09for (i = 0; i < SubjectItems; i++) `7B
X`09    if (SListIsSelected(TopList, i)) `7B
X`09`09start = ArticleNumbers`5Bi`5D;
X`09`09end = start;
X`09`09if (!saveRangeOfArticles(buffer, start, end))
X`09`09`09break;
X`09`09markArticle(ArticleNumbers`5Bi`5D, 'P');
X`09`09SET_PRINTED(newsgroup->artStatus`5BINDEX(art)`5D);
X`09`09SListUpdateLine(TopList, i);
X`09    `7D
X`09`7D`20
X`09resetSelection();
X`09SListSetTop(TopList, top);
X`09if (!app_resources.delayedPrint) `7B
X`09    (void) sprintf(buffer, "%s %sXRN_PRINT_%u.LIS",
X`09`09    app_resources.printCommand, app_resources.tmpDir,
X`09`09    printNumber);
X`09    status = system(buffer);
X`09    if (status & 1) `7B
X`09`09info("Article sucessfully queued");
X`09    `7D else `7B
X`09`09status = sys$getmsg(status, &msglen, &buf_desc, 0, 0);
X`09`09buffer`5Bmsglen`5D = '\0';
X`09`09mesgPane(XRN_SERIOUS, buffer);
X`09    `7D
X`09`7D else `7B
X`09    printPending = True;
X`09    info("Article(s) saved for printing");
X`09`7D
X    `7D else `7B
X`09if (saveCurrentArticle(buffer)) `7B
X`09    if (!app_resources.delayedPrint) `7B
X`09`09(void) sprintf(buffer, "%s %sXRN_PRINT_%u.LIS",
X`09`09    app_resources.printCommand, app_resources.tmpDir,
X`09`09    printNumber);
X`09`09status = system(buffer);
X`09`09if (status & 1) `7B
X`09`09    info("Article sucessfully queued");
X`09`09    markArticle(ArticleNumbers`5BArtPosition`5D, 'P');
X`09`09    SET_PRINTED(newsgroup->artStatus`5BINDEX(art)`5D);
X`09`09`7D else `7B
X`09`09    status = sys$getmsg(status, &msglen, &buf_desc, 0, 0);
X`09`09    buffer`5Bmsglen`5D = '\0';
X`09`09    mesgPane(XRN_SERIOUS, buffer);
X`09`09`7D
X`09    `7D else `7B
X`09`09printPending = True;
X`09`09info("Article saved for printing");
X`09    `7D
X`09`7D
X    `7D
X
X`7D
X#else /* not VMS */
X
X    if ((top = SListGetTop(TopList)) == -1) top = 0;
X
X    if (!app_resources.delayedPrint) `7B
X`09(void) sprintf(buffer, "`7C %s", app_resources.printCommand);
X    `7D else `7B
X`09(void) sprintf(buffer, "%sXrn_print_%u",
X`09`09app_resources.tmpDir, getpid());
X    `7D
X    if (SelectionItem != -1) `7B
X`09for (i = 0; i < SubjectItems; i++) `7B
X`09    if (SListIsSelected(TopList, i)) `7B
X`09`09start = ArticleNumbers`5Bi`5D;
X`09`09end = start;
X`09`09if (!saveRangeOfArticles(buffer, start, end))
X`09`09`09break;
X`09`09markArticle(ArticleNumbers`5Bi`5D, 'P');
X`09`09SET_PRINTED(newsgroup->artStatus`5BINDEX(art)`5D);
X`09`09SListUpdateLine(TopList, i);
X`09`09if (app_resources.delayedPrint) `7B
X`09`09    printPending = True;
X`09`09    info("Article(s) saved for printing");
X`09`09`7D
X`09    `7D
X`09`7D`20
X`09resetSelection();
X`09SListSetTop(TopList, top);
X    `7D else `7B
X`09if (saveCurrentArticle(buffer)) `7B
X`09    markArticle(ArticleNumbers`5BArtPosition`5D, 'P');
X`09    SET_PRINTED(newsgroup->artStatus`5BINDEX(art)`5D);
X`09    if (app_resources.delayedPrint) `7B
X`09`09printPending = True;
X`09`09info("Article saved for printing");
X`09    `7D
X`09`7D
X    `7D
X    return;
X`7D
X#endif /* VMS */
X
X/*
X * Allow user to post a reply to the currently posted article
X */
X/*ARGSUSED*/
Xvoid
XartReplyFunction(widget)
XWidget widget;
X`7B
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    reply();
X    return;
X`7D
X
X/*
X * Allow user to forward an article to a user(s)
X */
X/*ARGSUSED*/
Xvoid
XartForwardFunction(widget)
XWidget widget;
X`7B
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    forward();
X    return;
X`7D
X
X/*
X * Allow user to gripe
X */
X/*ARGSUSED*/
Xvoid
XartGripeFunction(widget)
XWidget widget;
X`7B
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    gripe();
X    return;
X`7D
X
X/*
X * Allow user to post a followup to the currently displayed article
X */
X/*ARGSUSED*/
Xvoid
XartFollowupFunction(widget)
XWidget widget;
X`7B
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    followup();
X    return;
X`7D
X
X/*
X * Post a followup and reply to the author of current article
X */
X/*ARGSUSED*/
Xvoid
XartFollowupReplyFunction(widget)
XWidget widget;
X`7B
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    followupAndReply();
X    return;
X`7D
X
X/*
X * Allow user to cancel the currently displayed article
X */
X/*ARGSUSED*/
Xvoid
XartCancelFunction(widget)
XWidget widget;
X`7B
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    cancelArticle();
X    return;
X`7D
X
X/*
X * decrypt a joke
X */
X/*ARGSUSED*/
Xvoid
XartRot13Function(widget)
XWidget widget;
X`7B
X    char *text, *question;
X
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    if (toggleRotation(&text, &question) == XRN_OKAY) `7B
X`09redrawArticleWidget(text, question);
X    `7D
X    return;
X`7D
X
X/*ARGSUSED*/
Xvoid
XartHeaderFunction(widget)
XWidget widget;
X`7B
X    char *text, *question;
X
X    if (Mode != ARTICLE_MODE) `7B
X`09return;
X    `7D
X    if (toggleHeaders(&text, &question) == XRN_OKAY) `7B
X`09redrawArticleWidget(text, question);
X    `7D
X    return;
X`7D
X
X#define SUB_STRING   "subscribed  "
X#define UNSUB_STRING "unsubscribed"
X
X/*
X * Quit all groups mode.
X */
X/*ARGSUSED*/
Xvoid
XallQuitFunction(widget)
XWidget widget;
X`7B
X    int i;
X    if (Mode != ALL_MODE) `7B
X`09return;
X    `7D
X    /* destroy strings */
X   `20
X    SListLoad(TopList, 0);
X    if (AllGroupItems > 0) `7B
X`09if (AllGroups != (ng_num *)0) `7B
X`09    FREE(AllGroups);
X`09    AllGroups = NIL(ng_num);
X`09`7D
X    `7D
X
X    switchToNewsgroupMode();
X    return;
X`7D
X
X/*
X * Make the selected group(s) subscribed to, and leave them in
X * their current position in the newsrc file.
X */
X/*ARGSUSED*/
Xvoid
XallSubFunction(widget)
XWidget widget;
X`7B
X    char newGroup`5BGROUP_NAME_SIZE`5D;
X    int i;
X
X    if (Mode != ALL_MODE) `7B
X`09return;
X    `7D
X    if (SelectionItem < 0) `7B
X`09AllPosition = SListGetHighlight(TopList);
X`09if (AllPosition >= 0) `7B
X`09    strcpy(newGroup, groupName(AllGroups`5BAllPosition`5D));
X`09    if (gotoNewsgroup(newGroup) != GOOD_GROUP) `7B
X`09`09mesgPane(XRN_SERIOUS, "Bad group: %s", newGroup);
X`09`09return;
X`09    `7D
X`09    subscribe();
X`09`7D
X    `7D else `7B
X`09AllPosition = 0;
X`09for (i = 0; i < AllGroupItems; i++) `7B
X`09    if (SListIsSelected(TopList, i)) `7B
X`09`09if (AllPosition == 0) AllPosition = i;
X`09`09strcpy(newGroup, groupName(AllGroups`5Bi`5D));
X`09`09if (gotoNewsgroup(newGroup) != GOOD_GROUP) `7B
X`09`09    mesgPane(XRN_SERIOUS, "Bad group: %s", newGroup);
X`09`09    return;
X`09`09`7D
X`09`09subscribe();
X`09    `7D
X`09`7D
X    `7D
X    updateAllWidget(SListGetTop(TopList), SListGetBottom(TopList));
X    resetSelection();
X    return;
X`7D
X
X/*
X * Mark the selected group(s) as subscribed to, and move them to the
X * beginning of the newsrc file.
X */
X/*ARGSUSED*/
Xvoid
XallFirstFunction(widget)
XWidget widget;
X`7B
X    char newGroup`5BGROUP_NAME_SIZE`5D;
X    int i;
X
X    if (Mode != ALL_MODE) `7B
X`09return;
X    `7D
X    if (SelectionItem < 0) `7B
X`09AllPosition = SListGetHighlight(TopList);
X`09if (AllPosition >= 0) `7B
X`09    strcpy(newGroup, groupName(AllGroups`5BAllPosition`5D));
X`09    (void) addToNewsrcBeginning(newGroup, SUBSCRIBE);
X`09    if (AllStatus == 0) `7B
X`09`09redrawAllWidget(saveTop);
X`09    `7D else `7B
X`09`09updateAllWidget(AllPosition, AllPosition);
X`09    `7D
X`09`7D
X    `7D else `7B
X`09AllPosition = 0;
X`09for (i = 0; i < AllGroupItems; i++) `7B
X`09    if (SListIsSelected(TopList, i)) `7B
X`09`09if (AllPosition == 0) AllPosition = i;
X`09`09strcpy(newGroup, groupName(AllGroups`5Bi`5D));
X`09`09(void) addToNewsrcBeginning(newGroup, SUBSCRIBE);
X`09`09if (AllStatus != 0) `7B
X`09`09    updateAllWidget(i,i);
X`09`09`7D
X`09    `7D
X`09`7D
X    `7D
X    resetSelection();
X    if (AllStatus == 0) `7B
X`09redrawAllWidget(saveTop);
X    `7D`20
X    subjSetPos(TopList, AllPosition, True);
X    return;
X`7D
X
X/*
X * Mark the selected group(s) as subscribed to, and move them
X * to the end of the newsrc file.
X */
X/*ARGSUSED*/
Xvoid
XallLastFunction(widget)
XWidget widget;
X`7B
X    char newGroup`5BGROUP_NAME_SIZE`5D;
X    int status = SUBSCRIBE;
X    int i;
X
X    if (Mode != ALL_MODE) `7B
X`09return;
X    `7D
X    if (SelectionItem < 0) `7B
X`09AllPosition = SListGetHighlight(TopList);
X`09if (AllPosition >= 0) `7B
X`09    strcpy(newGroup, groupName(AllGroups`5BAllPosition`5D));
X`09    (void) addToNewsrcEnd(newGroup, status);
X`09    if (AllStatus == 0) `7B
X`09`09redrawAllWidget(AllPosition);
X`09    `7D else `7B
X`09`09updateAllWidget(AllPosition, AllPosition);
X`09    `7D
X`09`7D
X    `7D else `7B
X`09AllPosition = 0;
X`09for (i = 0; i < AllGroupItems; i++) `7B
X`09    if (SListIsSelected(TopList, i)) `7B
X`09`09if (AllPosition == 0) AllPosition = i;
X`09`09strcpy(newGroup, groupName(AllGroups`5Bi`5D));
X`09`09(void) addToNewsrcEnd(newGroup, status);
X`09`09if (AllStatus != 0) `7B
X`09`09    updateAllWidget(i, i);
X`09`09`7D
X`09    `7D
X`09`7D
X    `7D
X    resetSelection();
X    if (AllStatus == 0) `7B
X`09redrawAllWidget(AllPosition);
X    `7D`20
X    subjSetPos(TopList, AllPosition, True);
X    return;
X`7D
X
Xstatic Widget AllBox = (Widget) 0;
X
X/*
X * Mark the selected group(s) as subscribed to, and place them
X * after the group name (entered in the dialog box) in the newsrc file.
X */
X/*ARGSUSED*/
Xstatic void
XallHandler(widget, client_data, call_data)
XWidget widget;
Xcaddr_t client_data;
Xcaddr_t call_data;
X`7B
X    char newGroup`5BGROUP_NAME_SIZE`5D;
X    char oldGroup`5BGROUP_NAME_SIZE`5D;
X    int i;
X    int first = 1;
X
X    if (inCommand) `7B
X`09XBell(XtDisplay(TopLevel), 0);
X`09return;
X    `7D
X    inCommand = 1;
X    PopDownDialog(AllBox);
X    busyCursor();
X
X    /* Handle "Cancel" press. */
X    if (client_data == (caddr_t) XRNadd_ABORT) `7B
X`09unbusyCursor();
X`09inCommand = 0;
X`09return;
X    `7D
X    if (SelectionItem < 0) `7B
X`09AllPosition = SListGetHighlight(TopList);
X`09if (AllPosition >= 0) `7B
X`09    strcpy(newGroup, groupName(AllGroups`5BAllPosition`5D));
X`09    if (addToNewsrcAfterGroup(newGroup, GetDialogValue(AllBox),
X`09`09`09`09      SUBSCRIBE) == GOOD_GROUP) `7B
X`09`09if (AllStatus == 0) `7B
X`09    `09    redrawAllWidget(AllPosition);
X`09`09`7D else `7B
X`09`09    updateAllWidget(AllPosition, AllPosition);
X`09`09`7D
X`09    `7D
X`09`7D
X    `7D else `7B
X`09AllPosition = 0;
X`09for (i = 0; i < AllGroupItems; i++) `7B
X`09    if (SListIsSelected(TopList, i)) `7B
X`09`09if (AllPosition == 0) AllPosition = i;
X`09`09strcpy(newGroup, groupName(AllGroups`5Bi`5D));
X`09`09if (first) `7B
X`09`09    if (addToNewsrcAfterGroup(newGroup, GetDialogValue(AllBox),
X`09`09`09`09      SUBSCRIBE) == GOOD_GROUP) `7B
X`09`09`09updateAllWidget(i, i);
X`09`09    `7D else `7B
X`09`09`09/* Avoid deadlock */
X`09`09`09unbusyCursor();
X`09`09`09inCommand = 0;
X`09`09`09return;
X`09`09    `7D
X`09`09`7D else `7B
X`09`09    strcpy(newGroup, groupName(AllGroups`5Bi`5D));
X`09`09    (void)addToNewsrcAfterGroup(newGroup, oldGroup, SUBSCRIBE);
X`09`09    updateAllWidget(i, i);
X`09`09`7D
X`09    `7D
X`09    (void) strcpy(oldGroup, newGroup);
X`09`7D
X    `7D
X    resetSelection();
X    if (AllStatus == 0) `7B
X`09redrawAllWidget(AllPosition);
X    `7D`20
X    subjSetPos(TopList, AllPosition, True);
X    unbusyCursor();
X    inCommand = 0;
X    return;
X`7D
X
X/*
X * Put up a dialog box for the user to enter a group name after which
X * the selected articles should be placed.
X */
X/*ARGSUSED*/
Xvoid
XallAfterFunction(widget)
XWidget widget;
X`7B
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Subscribe", allHandler, (caddr_t) XRNadd_ADD`7D,
X`09`7B"Cancel",    allHandler, (caddr_t) XRNadd_ABORT`7D,
X    `7D;
X
X    if (Mode != ALL_MODE) `7B
X`09return;
X    `7D
X    if (SelectionItem < 0) `7B
X`09mesgPane(XRN_INFO, "You must select a group or groups first");
X`09return;
X    `7D
X    if (AllBox == (Widget) 0) `7B
X`09AllBox = CreateDialog(TopLevel, "Move After Select",
X`09`09`09`09  "After which newsgroup?",
X`09`09`09`09  DIALOG_TEXT, args, XtNumber(args));
X    `7D
X    PopUpDialog(AllBox);
X    return;
X`7D
X
X/*
X * Mark the selected group(s) as unsubscribed, leaving their position
X * in the newsrc file unchanged.
X */
X/*ARGSUSED*/
Xvoid
XallUnsubFunction(widget)
XWidget widget;
X`7B
X    char newGroup`5BGROUP_NAME_SIZE`5D;
X    int i;
X
X    if (Mode != ALL_MODE) `7B
X`09return;
X    `7D
X    if (SelectionItem < 0) `7B
X`09AllPosition = SListGetHighlight(TopList);
X`09if (AllPosition >= 0) `7B
X`09    strcpy(newGroup, groupName(AllGroups`5BAllPosition`5D));
X`09    if (gotoNewsgroup(newGroup) != GOOD_GROUP) `7B
X`09`09mesgPane(XRN_SERIOUS, "Bad group: %s\n", newGroup);
X`09`09return;
X`09    `7D
X`09    unsubscribe();
X`09`7D
X    `7D else `7B
X`09AllPosition = 0;
X`09for (i = 0; i < AllGroupItems; i++) `7B
X`09    if (AllPosition == 0) AllPosition = i;
X`09    if (SListIsSelected(TopList, i)) `7B
X`09`09strcpy(newGroup, groupName(AllGroups`5Bi`5D));
X`09`09if (gotoNewsgroup(newGroup) != GOOD_GROUP) `7B
X`09`09    mesgPane(XRN_SERIOUS, "Bad group: %s\n", newGroup);
X`09`09    return;
X`09`09`7D
X`09`09unsubscribe();
X`09    `7D
X`09`7D
X    `7D
X    updateAllWidget(SListGetTop(TopList), SListGetBottom(TopList));
X    resetSelection();
X    return;
X`7D
X
X/*
X * called when the user wants to scroll the all groups window
X */
X/*ARGSUSED*/
Xvoid
XallScrollFunction(widget)
XWidget widget;
X`7B
X    if (Mode != ALL_MODE) `7B
X`09return;
X    `7D
X    AllPosition += 9;
X    if (AllPosition >= AllGroupItems)
X`09AllPosition = AllGroupItems - 1;
X    subjSetPos(TopList, AllPosition, True);
X    return;
X`7D
X
X/*
X * called when the user wants to scroll the all groups window
X */
X/*ARGSUSED*/
Xvoid
XallScrollBackFunction(widget)
XWidget widget;
X`7B
X    if (Mode != ALL_MODE) `7B
X`09return;
X    `7D
X    AllPosition -= 9;
X    if (AllPosition < 0)
X`09AllPosition = 0;
X    subjSetPos(TopList, AllPosition, True);
X    return;
X`7D
X
X/*
X * Go to the current newsgroup.  The current
X * group is either the first group of a selection,
X * or, if there is no selection, the group the cursor
X * is currently on (if any).
X */
X/*ARGSUSED*/
Xvoid
XallGotoFunction(widget)
XWidget widget;
X`7B
X    char newGroup`5BGROUP_NAME_SIZE`5D;
X    int gbeg, gend;
X    int i;
X
X    if (Mode != ALL_MODE) `7B
X`09return;
X    `7D
X
X    if ((saveTop = SListGetTop(TopList)) == -1) saveTop = 0;
X
X    /* get the current group name */
X
X    if (SelectionItem < 0) `7B
X`09SelectionItem = SListGetHighlight(TopList);
X`09if (SelectionItem < 0) SelectionItem = 0;
X`09SelectionCount = 1;
X    `7D
X    gbeg = SelectionItem;
X    gend = SelectionItem + SelectionCount;
X    if (gbeg >= AllGroupItems) gbeg = AllGroupItems - 1;
X    if (gend > AllGroupItems) gend = AllGroupItems;
X    resetSelection();
X    if (gbeg < 0 `7C`7C gend < 0) return;
X    saveTop = gbeg;
X
X    strcpy(newGroup, groupName(AllGroups`5Bgbeg`5D));
X
X    /* jump to the newsgroup */
X
X    setTitleBar("Opening newsgroup - please wait");
X    if (jumpToNewsgroup(newGroup) == GOOD_GROUP) `7B
X`09(void) strcpy(LastGroup, newGroup);
X`09
X`09/* free string */
X
X`09if (AllGroupItems > 0) `7B
X`09    if (AllGroups != (ng_num *)0) `7B
X`09`09FREE(AllGroups);
X`09`09AllGroups = (ng_num *) 0;
X`09    `7D
X`09`7D
X`09(void) switchToArticleMode(app_resources.autoRead);
X`09return;
X    `7D
X    return;
X`7D
X
X/*
X * Open the current newsgroup.  The current
X * group is either the first group of a selection,
X * or, if there is no selection, the group the cursor
X * is currently on (if any).
X */
X/*ARGSUSED*/
Xvoid
XallOpenFunction(widget)
XWidget widget;
X`7B
X    char newGroup`5BGROUP_NAME_SIZE`5D;
X    int gbeg, gend;
X    int i;
X
X    if (Mode != ALL_MODE) `7B
X`09return;
X    `7D
X
X    if ((saveTop = SListGetTop(TopList)) == -1) saveTop = 0;
X
X    /* get the current group name */
X
X    if (SelectionItem < 0) `7B
X`09SelectionItem = SListGetHighlight(TopList);
X`09if (SelectionItem < 0) SelectionItem = 0;
X`09SelectionCount = 1;
X    `7D
X    gbeg = SelectionItem;
X    gend = SelectionItem + SelectionCount;
X    if (gbeg >= AllGroupItems) gbeg = AllGroupItems - 1;
X    if (gend > AllGroupItems) gend = AllGroupItems;
X    resetSelection();
X    if (gbeg < 0 `7C`7C gend < 0) return;
X    strcpy(newGroup, groupName(AllGroups`5Bgbeg`5D));
X
X    /* jump to the newsgroup */
X
X    setTitleBar("Opening newsgroup - please wait");
X    if (jumpToNewsgroup(newGroup) == GOOD_GROUP) `7B
X`09(void) strcpy(LastGroup, newGroup);
X`09
X`09/* free string */
X
X`09if (AllGroupItems > 0) `7B
X`09    if (AllGroups != (ng_num *)0) `7B
X`09`09FREE(AllGroups);
X`09`09AllGroups = (ng_num *) 0;
X`09    `7D
X`09`7D
X`09(void) switchToArticleMode(0);
X`09return;
X    `7D
X    return;
X`7D
X
X/*
X * Post to the current newsgroup.  The current
X * group is either the first group of a selection,
X * or, if there is no selection, the group the cursor
X * is currently on (if any).
X */
X/*ARGSUSED*/
Xvoid
XallPostFunction(widget)
XWidget widget;
X`7B
X    char newGroup`5BGROUP_NAME_SIZE`5D;
X    int first;
X    int i;
X
X    if (Mode != ALL_MODE) `7B
X`09return;
X    `7D
X   `20
X    /* get the current group name */
X
X    if (SelectionItem < 0) `7B
X`09first = SListGetHighlight(TopList);
X`09resetSelection();
X`09if (first < 0) return;
X`09if (first >= AllGroupItems) `7B
X`09    first = AllGroupItems - 1;
X`09`7D
X`09AllPosition = first;
X`09strcpy(newGroup, groupName(AllGroups`5BAllPosition`5D));
X`09resetSelection();
X    `7D else `7B
X`09for (i = 0; i < AllGroupItems; i++) `7B
X`09    if (SListIsSelected(TopList, i)) `7B
X`09`09strcpy(newGroup, groupName(AllGroups`5Bi`5D));
X`09    `7D
X`09`7D
X`09resetSelection();
X    `7D
X    setNewsgroup(newGroup);
X    post(1);
X
X    return;
X`7D
X
X/*
X * Make note of the groups that were selected
X * to be moved.
X */
X/*ARGSUSED*/
Xvoid
XallSelectFunction(widget)
XWidget widget;
X`7B
X    int i, count;
X
X    if (Mode != ALL_MODE `7C`7C AllGroupItems == 0) `7B
X`09return;
X    `7D
X    if (selSize < AllGroupItems) `7B
X`09if (selList != NULL) FREE(selList);
X`09selList = XtMalloc(AllGroupItems+1);
X`09selSize = AllGroupItems;
X    `7D
X    count = 0;
X    for (i=0; i < AllGroupItems;i++) `7B
X`09if (SListIsSelected(TopList, i)) `7B
X`09    selList`5Bi`5D = 1;
X`09    count++;
X`09`7D else `7B
X`09    selList`5Bi`5D = 0;
X`09`7D
X    `7D
X    if (count == 0) `7B
X`09count++;
X`09selList`5BSListGetHighlight(TopList)`5D = 1;
X    `7D
X    resetSelection();
X    selCount = count;
X    return;
X`7D
X
X/*
X * Move the previously selected groups to the position before the
X * current selection
X */
X/*ARGSUSED*/
Xvoid
XallMoveFunction(widget)
XWidget widget;
X`7B
X    char newGroup`5BGROUP_NAME_SIZE`5D;
X    char oldGroup`5BGROUP_NAME_SIZE`5D;
X    int status = SUBSCRIBE;
X    int moveTo;
X    int moveFrom;
X    int first = 1;
X
X    if (Mode != ALL_MODE) `7B
X`09return;
X    `7D
X    if (selCount == 0) `7B
X`09mesgPane(XRN_INFO, "No groups were selected");
X`09return;`09
X    `7D
X    if (SelectionItem < 0) `7B
X`09mesgPane(XRN_INFO, "You must select a group to move before");
X`09return;
X    `7D
X    moveTo = SelectionItem;
X    if (moveTo >= AllGroupItems) moveTo = AllGroupItems - 1;
X    for (moveFrom = 0; moveFrom < AllGroupItems; moveFrom++) `7B
X`09if (selList`5BmoveFrom`5D != 0) `7B
X`09    currentMode(getStatusString(AllGroups`5BmoveFrom`5D),
X`09`09`09newGroup, &status);
X`09    if (moveTo <= 0) `7B
X`09`09moveTo = 0;
X`09    `09(void) addToNewsrcBeginning(newGroup, status);
X`09    `09(void) strcpy(oldGroup, newGroup);
X`09    `7D else `7B
X`09`09if (first) `7B
X`09`09    strcpy(oldGroup, groupName(AllGroups`5BmoveTo-1`5D));
X`09`09    (void) addToNewsrcAfterGroup(newGroup, oldGroup, status);
X`09`09    first = 0;
X`09`09`7D else `7B
X`09`09    currentMode(getStatusString(AllGroups`5BmoveFrom`5D),
X`09`09`09`09newGroup, &status);
X`09`09    (void) addToNewsrcAfterGroup(newGroup, oldGroup, status);
X`09`09`7D
X`09`09(void) strcpy(oldGroup, newGroup);
X`09    `7D
X`09`7D
X    `7D
X    selCount = 0;
X    resetSelection();
X    redrawAllWidget(moveTo);
X    subjSetPos(TopList, moveTo, True);
X    return;
X`7D
X
X/*`20
X * Change the order the groups appear on the screen.
X */
X/*ARGSUSED*/
Xvoid
XallToggleFunction(widget)
XWidget widget;
X`7B
X   `20
X    if (Mode != ALL_MODE) `7B
X`09return;
X    `7D
X
X    AllStatus = (AllStatus == 0) ? 1 : 0;
X
X    AllGroups = getStatusList(AllStatus);
X
X    for (AllGroupItems = 0; AllGroups`5BAllGroupItems`5D != -1; AllGroupItem
Vs++);
X
X    SListLoad(TopList, AllGroupItems);
X    currentTop = 0;
X    resetSelection();
X    subjSetPos(TopList, 0, True);
X
X    return;
X`7D
X
X#define XRNallSearch_ABORT 0
X#define XRNallSearch_FORWARD 1
X#define XRNallSearch_BACK 2
X
Xstatic Widget AllSearchBox = (Widget) 0;
X
X#undef CLEANUP
X#define CLEANUP \
X`09if (AllSearchBox) PopDownDialog(AllSearchBox); \
X`09inCommand = 0; \
X`09unbusyCursor();
X
X
Xstatic int
XgroupSearch(dir)
Xint dir;
X`7B
X#ifdef SYSV_REGEX
X    extern char *regcmp();
X    extern char *regex();
X#else
X    char *re_comp();`09`09/* regular expression routine */
X#endif
X    static char *reRet;`09`09/* returned by re_comp/regcmp */
X    char newgroup`5B128`5D;`09`09/* group name of current line */
X
X    abortClear();
X
X    if (LastRegexp != NIL(char)) `7B
X#ifdef SYSV_REGEX
X`09if ((reRet = regcmp(LastRegexp, NULL)) == NULL) `7B
X#else
X`09if ((reRet = re_comp(LastRegexp)) != NULL) `7B
X#endif
X`09    /* bad regular expression */
X#ifdef SYSV_REGEX
X`09    mesgPane(XRN_SERIOUS, "error in regular expression");
X#else
X`09    mesgPane(XRN_SERIOUS, reRet);
X#endif
X`09    failedSearch();
X`09    return ERROR;
X`09`7D
X    `7D
X
X    if (dir == FORWARD) `7B
X`09for (;;) `7B
X`09    if (abortP()) `7B
X`09`09return ABORT;
X`09    `7D
X`09    if (AllGroups`5BAllPosition`5D == -1) `7B
X`09`09if (AllPosition == 0) `7B
X
X`09`09    /* the string is null, no more articles are left */
X
X`09`09    return EXIT;
X`09`09`7D
X`09`09return NOMATCH;
X`09    `7D
X`09    AllPosition = AllPosition + 1;
X`09    if (AllGroups`5BAllPosition`5D == -1) `7B
X
X`09`09/* reached end of string */
X
X`09`09return NOMATCH;
X`09    `7D
X`09    utLowerCase(newgroup, groupName(AllGroups`5BAllPosition`5D),
X`09`09`09sizeof(newgroup) - 1);
X
X#ifdef SYSV_REGEX
X`09    if (regex(reRet, newgroup) != NULL) `7B
X#else
X`09    if (re_exec(newgroup)) `7B
X#endif
X`09`09/* found a match to the regular expression */
X
X`09`09return MATCH;
X`09    `7D
X`09`7D
X    `7D else `7B
X`09startSearch();
X`09for (;;) `7B
X`09    if (abortP()) `7B
X
X`09`09/* reset pointers back to where we began, since the */
X`09`09/* search was aborted */
X
X`09`09failedSearch();
X`09`09return ABORT;
X`09    `7D
X`09    if ((AllPosition == 0) && AllGroups`5BAllPosition`5D == -1) `7B
X
X`09`09/* no more articles remain, return to Newgroup mode */
X
X`09`09return EXIT;
X`09    `7D
X`09    if (AllPosition != 0) `7B
X
X`09`09/* we are still within the subject list */
X
X`09`09AllPosition = AllPosition - 1;
X`09`09utLowerCase(newgroup, groupName(AllGroups`5BAllPosition`5D),
X`09`09`09sizeof(newgroup) - 1);
X
X#ifdef SYSV_REGEX
X`09`09if (regex(reRet, newgroup) != NULL) `7B
X#else
X`09`09if (re_exec(newgroup)) `7B
X#endif
X`09`09    /* an article matching the regular expression was found */
X
X`09`09    return MATCH;
X`09`09`7D
X`09    `7D else `7B
X`09`09failedSearch();
X`09`09return NOMATCH;
X`09    `7D
X`09`7D
X    `7D
X`7D
X/*ARGSUSED*/
Xstatic void`20
XallSearchHandler(widget, client_data, call_data)
XWidget widget;
Xcaddr_t client_data;
Xcaddr_t call_data;
X`7B
X    char *regexpr;
X    int SavePosition;
X    int status;
X    int direction;
X
X    if (inCommand) `7B
X`09XBell(XtDisplay(TopLevel), 0);
X`09return;
X    `7D
X    inCommand = 1;
X
X    busyCursor();
X    resetSelection();
X    if ((int) client_data == XRNallSearch_ABORT) `7B
X`09CLEANUP;
X`09return;
X    `7D
X    if (AllPosition >= AllGroupItems) AllPosition = AllGroupItems - 1;
X    SavePosition = AllPosition;
X    regexpr = GetDialogValue(AllSearchBox);
X    if (*regexpr == 0) `7B
X`09if (LastRegexp == NIL(char)) `7B
X`09    mesgPane(XRN_INFO, "No previous regular expression");
X`09    CLEANUP;
X`09    return;`09  `20
X`09`7D
X`09regexpr = LastRegexp;
X    `7D else `7B
X`09if (LastRegexp != NIL(char)) `7B
X`09    FREE(LastRegexp);
X`09`7D
X`09LastRegexp = XtNewString(regexpr);
X    `7D
X   `20
X    /* XXX */
X    if (AllSearchBox) PopDownDialog(AllSearchBox);
X
X    direction = ((int) client_data == XRNallSearch_FORWARD) ? FORWARD : BACK
V;
X    LastSearch = direction;
X    status = groupSearch(direction);
X    switch (status) `7B
X      case ABORT:
X`09infoNow("search aborted");
X`09AllPosition = SavePosition;
X`09subjSetPos(TopList, AllPosition, True);
X`09break;
X      case NOMATCH:
X`09(void) sprintf(error_buffer, "Search for expression %s: no match was foun
Vd",
X`09`09       LastRegexp);
X`09AllPosition = SavePosition;
X`09subjSetPos(TopList, AllPosition, True);
X`09infoNow(error_buffer);
X      case ERROR:
X`09AllPosition = SavePosition;
X`09subjSetPos(TopList, AllPosition, True);
X`09break;
X      case MATCH:
X`09(void) sprintf(error_buffer, "Search for expression %s", LastRegexp);
X`09infoNow(error_buffer);
X`09subjSetPos(TopList, AllPosition, True);
X`09break;
X      case EXIT:
X`09break;
X    `7D
X    CLEANUP;
X    return;
X`7D
X
X
X/*ARGSUSED*/
Xvoid
XallSearchFunction(widget)
XWidget widget;
X`7B
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Forward", allSearchHandler, (caddr_t) XRNallSearch_FORWARD`7D,
X`09`7B"Back",    allSearchHandler, (caddr_t) XRNallSearch_BACK`7D,
X`09`7B"Cancel",  allSearchHandler, (caddr_t) XRNallSearch_ABORT`7D,
X    `7D;
X   `20
X    if (Mode != ALL_MODE) `7B
X`09return;
X    `7D
X    if (AllSearchBox == (Widget) 0) `7B
X`09AllSearchBox = CreateDialog(TopLevel, "Group Search Select",
X`09`09`09`09  "Regular Expression?",
X`09`09`09`09  DIALOG_TEXT, args, XtNumber(args));
X    `7D
X    PopUpDialog(AllSearchBox);
X    return;
X`7D
X
X/*ARGSUSED*/
Xvoid
XallCancelSearchFunction(widget)
XWidget widget;
X`7B
X    abortSet();
X`7D
X
X/*ARGSUSED*/
Xvoid
XallContinueFunction(widget)
XWidget widget;
X/*
X * Continue a previously started regular expression
X * search of the subject lines.  Search for same
X * regular expression, in same direction.
X */
X`7B
X    int SavePosition;
X    int status;
X
X    if (LastRegexp == NULL) `7B
X`09mesgPane(XRN_INFO, "No previous regular expression");
X`09return;
X    `7D
X    (void) sprintf(error_buffer, "Searching for expression %s", LastRegexp);
X    info(error_buffer);
X    resetSelection();
X    SavePosition = AllPosition;
X    status = groupSearch(LastSearch);
X
X    switch (status) `7B
X      case ABORT:
X`09infoNow("search aborted");
X`09AllPosition = SavePosition;
X`09subjSetPos(TopList, AllPosition, True);
X`09return;
X      case NOMATCH:
X`09(void) sprintf(error_buffer, "Search for expression %s: no match was foun
Vd", LastRegexp);
X`09AllPosition = SavePosition;
X`09subjSetPos(TopList, AllPosition, True);
X`09infoNow(error_buffer);
X      case ERROR:
X`09AllPosition = SavePosition;
X`09subjSetPos(TopList, AllPosition, True);
X`09return;
X      case MATCH:
X`09(void) sprintf(error_buffer, "Search for expression %s", LastRegexp);
X`09infoNow(error_buffer);   `20
X`09subjSetPos(TopList, AllPosition, True);
X`09return;
X      case EXIT:
X`09return;
X    `7D
X`7D
X
Xvoid
XdetermineMode()
X/*
X * determine the initial mode and set up Text, TopButtonBox, and Question
X */
X`7B
X    /* set mode, handle text and question */
X    PreviousMode = Mode;
X   `20
X    /*
X     * article specific buttons, only create them if this is the first
X     * call to 'determineMode'
X     */
X    if (PreviousMode == NO_MODE) `7B
X`09createButtons(-1);
X`09XtManageChildren(ArtSpecButtons, ArtSpecButtonListCount);
X    `7D
X    if ((AddGroups = newGroups()) != (struct newsgroup **)0) `7B
X`09Mode = ADD_MODE;
X`09swapMode();
X`09setTopInfoLine("Select groups to `60add', `60exit' unsubscribes remaining
V groups");
X`09GroupPosition = 0;
X`09redrawAddListWidget(0);
X`09if (XtIsRealized(TopLevel))
X`09    xmSetIconAndName(NewGroupsIcon);
X    `7D else `7B
X`09Mode = NEWSGROUP_MODE;
X`09GroupPosition = 0;
X`09swapMode();
X`09redrawNewsgroupListWidget();
X`09/* update the question */
X`09if (GroupItems == 0) `7B
X`09    setTopInfoLine("No more unread articles in the subscribed to newsgrou
Vps");
X`09    if (XtIsRealized(TopLevel))
X`09`09xmSetIconAndName(ReadIcon);
X`09`7D else `7B
X`09    setTopInfoLine("Questions apply to current selection or cursor positi
Von");
X`09    if (XtIsRealized(TopLevel))
X`09`09xmSetIconAndName(UnreadIcon);
X`09`7D
X    `7D
X    setBottomInfoLine("");
X    addTimeOut();
X   `20
X    return;
X`7D
X
Xstatic void
XlistSelect(w, closure, call_data)
XWidget`09`09    w;
Xcaddr_t`09`09    closure;
XSListCallbackStruct *call_data;
X`7B
X    SListCallbackStruct *cb = call_data;
X    char buffer`5B256`5D;
X
X    SelectionItem = cb->item_number;
X    SelectionCount = cb->item_count;
X#ifdef TITLEBAR
X    if (cb->select_count == 0) `7B
X`09setTitleBar(NULL);
X`09return;
X    `7D
X    if (Mode == NEWSGROUP_MODE) `7B
X`09sprintf(buffer, "Newsgroup %s %sselected",
X`09`09groupName(NewsGroups`5BSelectionItem`5D),
X`09`09(cb->select_count == 1) ? "" : "(and others) ");
X`09setTitleBar(buffer);
X    `7D
X    if (Mode == ALL_MODE) `7B
X`09sprintf(buffer, "Newsgroup %s %sselected",
X`09`09groupName(AllGroups`5BSelectionItem`5D),
X`09`09(cb->select_count == 1) ? "" : "(and others) ");
X`09setTitleBar(buffer);
X    `7D
X    if (Mode == ADD_MODE) `7B
X`09sprintf(buffer, "Newsgroup %s %sselected",
X`09`09AddGroups`5BSelectionItem`5D->name,
X`09`09(cb->select_count == 1) ? "" : "(and others) ");
X`09setTitleBar(buffer);
X    `7D
X    if (Mode == ARTICLE_MODE) `7B
X`09sprintf(buffer, "Article %d %sselected",
X`09`09ArticleNumbers`5BSelectionItem`5D,
X`09`09(cb->select_count == 1) ? "" : "(and others) ");
X`09setTitleBar(buffer);
X    `7D
X    return;
X#endif
X`7D
X
Xstatic void
XDoubleClick(w, closure, call_data)
XWidget`09`09    w;
Xcaddr_t`09`09    closure;
XSListCallbackStruct *call_data;
X`7B
X    SListCallbackStruct *cb = call_data;
X
X    SelectionItem = cb->item_number;
X
X    if (Mode == NEWSGROUP_MODE) `7B
X`09if (app_resources.autoRead) `7B
X`09   ngReadAction((Widget) 0, NULL, NULL, 0);
X`09`7D else `7B
X`09   ngOpenAction((Widget) 0, NULL, NULL, 0);
X`09`7D
X`09return;
X    `7D
X    if (Mode == ALL_MODE) `7B
X`09allGotoAction((Widget) 0, NULL, NULL, 0);
X`09return;
X    `7D
X    if (Mode == ARTICLE_MODE) `7B
X`09if (inCommand) `7B
X`09    XBell(XtDisplay(TopLevel), 0);
X`09    return;
X`09`7D
X`09inCommand = 1;
X`09busyCursor();
X`09ArtPosition = SelectionItem;
X`09if (ArtPosition >= SubjectItems) ArtPosition = SubjectItems - 1;
X`09artReadFunction((Widget) 0);
X`09unbusyCursor();
X`09inCommand = 0;
X`09return;
X    `7D
X    return;
X`7D
X
Xstatic void GetData(w, closure, call_data)
X    Widget`09`09    w;
X    caddr_t`09`09    closure;
X    SListCallbackStruct    *call_data;
X`7B
X    SListCallbackStruct *cb = call_data;
X    int item = cb->item_number;
X
X    *cb->data = " ";
X
X    if (Mode == ALL_MODE) `7B
X`09if (item >= AllGroupItems) return;
X `09*cb->data = getStatusString(AllGroups`5Bitem`5D);
X`09return;
X    `7D
X    if (Mode == NEWSGROUP_MODE) `7B
X`09if (item >= GroupItems) return;
X `09*cb->data = groupStatus(NewsGroups`5Bitem`5D);
X`09return;
X    `7D
X    if (Mode == ARTICLE_MODE) `7B
X`09if (item >= SubjectItems) return;
X `09*cb->data = getSubjectLine(ArticleNumbers`5Bitem`5D);
X`09return;
X    `7D
X    if (Mode == ADD_MODE) `7B
X`09if (item >= AddGroupItems) return;
X `09*cb->data = AddGroups`5Bitem`5D->name;
X`09return;
X    `7D
X    return;
X`7D
X
Xstatic void subjSetPos(w, position, reset)
X    Widget w;
X    int position;
X    Boolean reset;
X`7B
X    int delta;
X
X    if (reset)
X`09SListSelectAll(w, 0);
X    switch (Mode) `7B
X`09case NEWSGROUP_MODE:
X`09    GroupPosition = position;
X`09    SListHighlight(w, position);
X`09    break;
X`09case ARTICLE_MODE:
X`09    ArtPosition = position;
X`09    SListHighlight(w, position);
X`09    break;
X`09case ADD_MODE:
X`09    GroupPosition = position;
X`09    SListHighlight(w, position);
X`09    break;
X`09case ALL_MODE:
X`09    AllPosition = position;
X`09    SListHighlight(w, position);
X`09    break;
X`09default:
X`09    return;
X    `7D
X
X    if (position < app_resources.maxLines) `7B
X`09SListSetTop(w, 0);
X`09currentTop = 0;
X    `7D else `7B
X`09if ((currentTop = SListGetTop(w)) <0) currentTop = 0;
X`09delta = position - currentTop;`09/* lines above position desired */
X`09if (delta < app_resources.minLines `7C`7C delta > app_resources.maxLines)
V `7B
X`09    currentTop = position - app_resources.minLines;
X`09    SListSetTop(w, currentTop);
X`09`7D
X    `7D`20
X`7D
Xstatic XtActionProc
XlistForwardPage(widget, event, params, num_params)
XWidget widget;
XXEvent *event;
Xchar **params;
XCardinal *num_params;
X`7B
X    return (slistForwardPage(TopList, event, params, num_params));
X`7D
Xstatic XtActionProc
XlistBackwardPage(widget, event, params, num_params)
XWidget widget;
XXEvent *event;
Xchar **params;
XCardinal *num_params;
X`7B
X    return (slistBackwardPage(TopList, event, params, num_params));
X`7D
Xstatic XtActionProc
XlistForwardLine(widget, event, params, num_params)
XWidget widget;
XXEvent *event;
Xchar **params;
XCardinal *num_params;
X`7B
X    int position, delta;
X
X    slistForwardLine(TopList, event, params, num_params);
X    position = SListGetHighlight(TopList);
X    if (position < 0) position = 0;
X    if (position < app_resources.maxLines) `7B
X`09SListSetTop(TopList, 0);
X`09currentTop = 0;
X    `7D else `7B
X`09if ((currentTop = SListGetTop(TopList)) <0) currentTop = 0;
X`09delta = position - currentTop;`09/* lines above position desired */
X`09if (delta < app_resources.minLines `7C`7C delta > app_resources.maxLines)
V `7B
X`09    currentTop = position - app_resources.minLines;
X`09    SListSetTop(TopList, currentTop);
X`09`7D
X    `7D
X    return 0;
X`7D
Xstatic XtActionProc
XlistBackwardLine(widget, event, params, num_params)
XWidget widget;
XXEvent *event;
Xchar **params;
XCardinal *num_params;
X`7B
X    int position, delta;
X
X    slistBackwardLine(TopList, event, params, num_params);
X    position = SListGetHighlight(TopList);
X    if (position < 0) position = 0;
X    if (position < app_resources.maxLines) `7B
X`09SListSetTop(TopList, 0);
X`09currentTop = 0;
X    `7D else `7B
X`09if ((currentTop = SListGetTop(TopList)) <0) currentTop = 0;
X`09delta = position - currentTop;`09/* lines above position desired */
X`09if (delta < app_resources.minLines `7C`7C delta > app_resources.maxLines)
V `7B
X`09    currentTop = position - app_resources.minLines;
X`09    SListSetTop(TopList, currentTop);
X`09`7D
X    `7D
X    return 0;
X`7D
X
Xstatic XtActionProc
XartReadCurrent(widget, event, params, num_params)
XWidget widget;
XXEvent *event;
Xchar **params;
XCardinal *num_params;
X`7B
X    if (inCommand) `7B
X`09XBell(XtDisplay(TopLevel), 0);
X`09return;
X    `7D
X    inCommand = 1;
X    busyCursor();
X    ArtPosition = SListGetHighlight(TopList);
X    if (ArtPosition < 0) ArtPosition = SelectionItem;
X    if (ArtPosition < 0) return;
X    if (ArtPosition >= SubjectItems) ArtPosition = SubjectItems - 1;
X    artReadFunction((Widget) 0);
X    unbusyCursor();
X    inCommand = 0;
X`7D
Xstatic Boolean
XartCheckReadCurrent()
X`7B
X    int pos;
X    pos = SListGetHighlight(TopList);
X    if (pos < 0)
X`09pos = SelectionItem;
X    if (pos < 0)
X`09return False;
X    if (pos >= SubjectItems)
X`09pos = SubjectItems - 1;
X    if (articleRead(ArticleNumbers`5Bpos`5D))
X`09return False;
X    ArtPosition = pos;
X    artReadFunction((Widget) 0);
X    return True;
X`7D
$ CALL UNPACK BUTTONS.C;190 1412151272
$ create 'f'
X#ifndef BUTTONS_H
X#define BUTTONS_H
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/buttons.h,v 1.5 1993
V/01/11 02:14:25 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * buttons.h: create and handle the buttons
X *
X */
X
Xextern void determineMode();
Xextern void addTimeOut();
Xextern void removeTimeOut();
Xextern void abortSet();
Xextern Boolean watchingGroup();
Xextern void createButtons _ARGUMENTS((int));
X#endif /* BUTTONS_H */
$ CALL UNPACK BUTTONS.H;2 1682735010
$ create 'f'
X#define calvin_width 90
X#define calvin_height 90
X
Xstatic unsigned char calvin_bits`5B`5D = `7B
X 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x00, 0x00, 0x09, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x00, 0x00, 0x11, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x00, 0x00, 0x21, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x02, 0x00, 0x41, 0x10, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x7e, 0x00, 0x81, 0x10, 0x29, 0x01, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x8c, 0x0f, 0x01, 0x09, 0x2a, 0x01, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x18, 0x38, 0x01, 0x0a, 0x2a, 0x01, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x70, 0x60, 0x01, 0x04, 0x44, 0x81, 0x01, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0xc0, 0xc1, 0x01, 0x0c, 0x44, 0x61, 0x02, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x00, 0x06, 0x03, 0x00, 0x80, 0x1b, 0x02, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x00, 0x0c, 0x02, 0x00, 0xe0, 0x06, 0x02, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x20, 0xc0, 0x03, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x00, 0x00, 0xe0, 0x01, 0x10, 0x00, 0x0f, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0xfc, 0x87, 0x1f, 0x00, 0x10, 0x01, 0x30, 0x00, 0x00, 0x00,
X 0x00, 0xfe, 0x03, 0x0c, 0x00, 0x00, 0x10, 0x93, 0x20, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x13, 0x27, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x08, 0x35, 0x1a, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x02, 0x00, 0x00, 0x80, 0x89, 0x2c, 0x02, 0x00, 0x00, 0x00,
X 0x00, 0x80, 0xff, 0x00, 0x00, 0x00, 0x88, 0x20, 0x02, 0x00, 0x00, 0x00,
X 0x00, 0xfe, 0x02, 0x00, 0x00, 0x70, 0x84, 0xc0, 0x01, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x02, 0x00, 0x00, 0x80, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x02, 0x00, 0x00, 0xc0, 0xc7, 0x01, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x02, 0x00, 0x00, 0xf8, 0x23, 0x02, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x02, 0x00, 0x00, 0xbf, 0x23, 0x02, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x02, 0xf0, 0xe7, 0xc7, 0x22, 0x02, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x02, 0x18, 0xfc, 0x00, 0x22, 0x02, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x04, 0xee, 0x1f, 0x78, 0x11, 0x02, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0xf4, 0xfe, 0x0f, 0x88, 0x9f, 0x01, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x8e, 0x8f, 0x0f, 0x04, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0xf9, 0x8f, 0x0f, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0xbf, 0x8d, 0x0f, 0x1c, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x9f, 0xfd, 0x07, 0xe2, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x9f, 0xff, 0x03, 0x02, 0x1e, 0x01, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0xfe, 0xf1, 0x01, 0x02, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0xfe, 0x00, 0x18, 0x06, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0xbc, 0x00, 0x10, 0x39, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x88, 0x00, 0x10, 0xc1, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x88, 0x31, 0x10, 0x03, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x08, 0x0e, 0x88, 0x0c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x08, 0x00, 0x84, 0x70, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x08, 0x00, 0x83, 0x80, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x08, 0xf8, 0xc0, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x7e, 0x08, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0xc0, 0xc1, 0x10, 0x00, 0x38, 0x1c, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x20, 0x00, 0x71, 0xc0, 0x07, 0x60, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x20, 0x13, 0x81, 0x3f, 0x38, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0xe0, 0x08, 0x02, 0x07, 0xc0, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x40, 0x44, 0x82, 0x38, 0x00, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x20, 0x44, 0x44, 0xc1, 0x03, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x20, 0x46, 0xa4, 0x00, 0x1c, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x20, 0xa6, 0xa8, 0x00, 0xe0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0xc0, 0x99, 0xb0, 0x00, 0x00, 0x4f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x80, 0xc0, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0xc1, 0xff, 0x03, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x51, 0x00, 0xfc, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x4a, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x24, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0xe0, 0xff, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x20, 0x00, 0x1f, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x20, 0x00, 0xf0, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x20, 0x00, 0x80, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0xe0, 0x1f, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x20, 0xe0, 0x7f, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x20, 0x00, 0x80, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x20, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0xe0, 0xff, 0x3f, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x20, 0x00, 0xc0, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x40, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x40, 0xfc, 0x3f, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0xc0, 0x03, 0xc0, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x40, 0xfc, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x00, 0xff, 0xff, 0xfb, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x00, 0xfe, 0xff, 0x7f, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x00, 0xf8, 0xff, 0x7f, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x00, 0xf0, 0xff, 0xbf, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x00, 0x30, 0xf8, 0x40, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x00, 0xd0, 0x47, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x00, 0x20, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x00, 0x20, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x00, 0x40, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x00, 0x00, 0xc0, 0xc0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X 0x00, 0x80, 0xff, 0xff, 0x71, 0xf1, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00,
X 0x00, 0x80, 0xff, 0x7f, 0x1f, 0xce, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00
X `7D;
$ CALL UNPACK CALVIN.ICON;2 342052198
$ create 'f'
X
X$Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/ChangeLog,v 1.8 1993/02
V/04 18:21:43 ricks Exp $
X
XXRN release 6.18:
X
X- More bug fixes and cleanup than humanly possible
X`09Jonathan I. Kamens`09<jik@pit-manager.mit.edu>
X
X- Faster entry into groups with lots of 'marked as unread' articles.`09
X`09Per Hedeland`09`09<per@erix.ericsson.se>
X
X- xrn.ignoreNewsgroups - ability to specify groups (regular expressions)
X  that you never want to see (even in the new groups window).  See the
X  man page for more information.  This can really cut down the size of your
X  .newsrc file and the memory usage of XRN.
X`09Jonathan I. Kamens`09<jik@pit-manager.mit.edu>
X
X- XRN now supports _ANSI_C_SOURCE, _POSIX_SOURCE, _XOPEN_SOURCE, and other`2
V0
X  standard-based defines, and thus is less vendor-specific (but clearly some
X  still exists...).
X`09Marc Evans`09`09<evans@zk3.dec.com>
X
X- Support for Motif 1.2 and cleanup of the cancel button
X`09David Brooks`09`09<dbrooks@osf.org>
X
X- No more claims of X11R3 support.
X
X- Performance Improvements (less fetching across NNTP)
X`09Jim Graham`09`09<flar@sun.com>
X
X- Permissions of the .newsrc file are not changed - previously after an
X    update the .newsrc file would have the permissions specified in the umas
Vk
X`09Rick Spickelmier`09<ricks@objy.com>
X
X- Settable Icon Pixmap and Name for normal, busy, and unread news modes
X    - via the resources/options: iconName, iconPixmap, busyIconName,
X`09`09`09`09 busyIconPixmap, unreadIconName,
X`09`09`09`09 unreadIconPixmap
X`09Michael Salmon`09`09<Michael.Salmon@eos.ericsson.se>
X
X- Translation of Articles from ISO 646 to ISO 8859-1
X`09Michael Salmon`09`09<Michael.Salmon@eos.ericsson.se>
X
X- User settable number of characters in the subject line, via
X    the indexLineLength resource/option
X`09Michael Salmon`09`09<Michael.Salmon@eos.ericsson.se>
X
X- Support for INN (InterNet News)
X`09Brendan Kehoe`09`09<brendan@eff.org>
X
X- XRN now can refile to RMAIL folders (use @folder, like MH +folder)
X`09Michael Thomas`09`09<mike@gordian.com>
X
X- The information box now tells you that articles posted to moderated`20
X  groups are sent to the moderator.
X`09Rick Spickelmier`09<ricks@objy.com>
X
X- Xtoolkit work processes now do the prefetching of the next group
X    (can be disabled by defining NO_IMMEDIATE_WORK_PROC_PREFETCH)
X`09Marc Evans`09`09<evans@zk3.dec.com>
X`09Jonathan I. Kamens`09<jik@pit-manager.mit.edu>
X
X- XRN now puts in the display name for editorCommand:
X    xrn.editorCommand: xterm -display %D -e vi %s
X    (%s for file name - must be specified, %D for display name,`20
X    this is optional)
X`09Rick Spickelmier`09<ricks@objy.com>
X
X- New Default: xrn.onlyShow number
X    Only grab the header information for the last 'number' of articles
X    in each group.  This is useful if you have been away for a while`20
X    and only want to see that last 100 or so articles in each group.
X`09Rick Spickelmier`09<ricks@objy.com>
X
X- Support for multiple signature files
X    The appropriate signature file is the usual signature file name
X    `60`7E/.signature' followed by either a `60-' and a  newsgroup name
X    substring, or followed by a `60.' and `60followup', `60forward', `60grip
Ve',
X    `60reply' or `60post' according to the posting mode.  For example if you
X    want to post a followup article in comp.sources.x then xrn uses the
X    first valid signature file in the following order:
X
X`09`09    `7E/.signature-comp.sources.x
X`09`09    `7E/.signature-comp.sources
X`09`09    `7E/.signature-comp
X`09`09    `7E/.signature.followup
X`09`09    `7E/.signature
X
X`09Nathan Maman`09`09<Nathan.Maman@sophia.inria.fr>
X
X- Support for executable signature files.  See 'executableSignatures'
X  and 'localSignatures' in the man page.
X`09Nathan Maman`09`09<Nathan.Maman@sophia.inria.fr>
X`09David Brooks`09`09<dbrooks@osf.org>
X`09Jonathan I. Kamens`09<jik@pit-manager.mit.edu>
X
X- XRN now unconditionally saves articles when posted via `60editorCommand'.
X        Conrad Kimball`09        <cek@sdc.boeing.com>
X
X- Set up defaults for reasonable line folding (of course, it's my definition
X`09of reasonable).
X`09Rick Spickelmier`09<ricks@objy.com>
X
X- Fix for bad newsgroup names
X`09Per Hedeland`09`09<per@erix.ericsson.se>
X`09Jonathan I. Kamens`09<jik@pit-manager.mit.edu>
X`09Rick Spickelmier`09<ricks@objy.com>
X
X- XRN was reading the header information twice when `60doing the right thing
V'
X`09Per Hedeland`09`09<per@erix.ericsson.se>
X
X- More XRN icons - xrn2.icon (news) and xrn3.icon (no news)
X       Rainer Klute`09`09<klute@irb.informatik.uni-dortmund.de>
X
X- Scrolling actions now exist for the subject index window
X`09    (artScrollIndex and artScrollIndexBack)
X`09Greg Schroeder`09`09<greg@sharebase.com>
X`09
X- Support for DEC Alpha OSF/1
X`09Eric Muller`09`09<muller@src.dec.com>
X`09Rick Spickelmier`09<ricks@objy.com>
X`09Dave Hill`09`09<ddhill@aosf.gsf.dec.com>
X
X- Apollo 10.3.5 support
X`09Keith Cantrell`09`09<kcantrel@core1.hssc.ksc.nasa.gov>
X
X- Amiga-UNIX support
X`09Craig M. Votava`09`09<ihlpf!cmv>
X
X- Reconnecting to server after time out will update the internal`20
X  data structures (new articles, etc.).
X`09Rick Spickelmier`09<ricks@objy.com>
X
X- Bug fixes
X`09David Brooks`09`09<dbrooks@osf.org>
X`09Bob Ellison`09`09<ellison@sei.cmu.edu>
X`09Marc Evans`09`09<evans@decvax.dec.com>
X`09Jim Graham`09`09<flar@eng.sun.com>
X`09Jonathan I. Kamens`09<jik@pit-manager.mit.edu>
X`09Andy Linton`09`09<Andy.Linton@comp.vuw.ac.nz>
X`09Nathan Maman`09`09<Nathan.Maman@sophia.inria.fr>
X`09Dale Moore`09`09<Dale_Moore@cs.cmu.edu>
X`09Taed Nelson`09`09<nelson@berlioz.nsc.com>
X`09Michael Salmon`09`09<Michael.Salmon@eos.ericsson.se>
X        Peter J. Scott`09`09<pjs@euclid.jpl.nasa.gov>
X`09Rick Spickelmier`09<ricks@objy.com>
X`09Jean-Philippe Martin-Flatin`09<syj@ecmwf.co.uk>
X`09Philip Yzarn de Louraille`09<yzarn@chevron.com>
X`09Jason C. Austin`09`09<sun!larc.nasa.gov!j.c.austin>
X
X
XXRN release 6.17:
X
X- Bug fixes
X`09Per Hedeland                <per@erix.ericsson.se>
X`09Jonathan I. Kamens          <jik@pit-manager.mit.edu>
X`09Bill Stapleton <sun!csd4.csd.uwm.edu!wls>
X
X- extraMailHeaders
X    When replying via mail to a posting, include or do not include an
X    "X-Newsgroups:" line with the newsgroups list from the posting and a
X    "In-reply-to:" line with its message ID.
X`09Jonathan I. Kamens          <jik@pit-manager.mit.edu>
X
X- Better handling and display of INEW error conditions.
X `09Bob Ellison <ellison@sei.cmu.edu>
X
X- re-edit
X    You can now re-edit mail messages and postings when using 'editorCommand
V'
X    editors.
X `09Bob Ellison <ellison@sei.cmu.edu>
X
X- Support for RS6000
X        Marc Pawliger`09<sun!ibmpa.awdpa.ibm.com!marc>
X
XXRN release 6.17beta:
X
X- CNEWS data field fix
X  Andy Linton <sun!comp.vuw.ac.nz!Andy.Linton>
X
X- fixed DOTDIR handling
X  Andy Linton <sun!comp.vuw.ac.nz!Andy.Linton>
X
X- massive improvements to compose.c
X  Jonathan I. Kamens <jik@pit-manager.mit.edu>
X
X    Bug`09`09`09`09`09`09`09When it occurs
X    ----------------------------------------------`09-----------------
X    When aborting an article or message, no`09`09Always.
X    distinction is made between articles and
X    messages in the info messages.
X
X    When being asked to confirm sending or`09`09Non-null editorCommand.
X    re-editing an article or message, no
X    distinction is made between articles and
X    messages.
X
X    When posting a message from Newsgroup mode,`09`09Null editorCommand.
X    the cursor should be positioned on the
X    "Newsgroups:" line of the header because it
X    needs to be filled in.
X
X    When posting a message from Article mode, the`09Null editorCommand.
X    cursor should be positioned on the "Subject:"
X    line of the header because it needs to be
X    filled in.
X
X    When posting a gripe, there's an extra blank`09Always.
X    line at the top of the gripe template.
X
X    When posting a gripe, the cursor should be`09`09Null editorCommand.
X    positioned at the beginning of the first
X    field to be filled in.
X
X    When posting a followup, the signature file`09`09Null editorCommand.
X    is not included at the bottom of the message.
X
X    When sending a reply, the signature file is`09`09Null editorCommand.
X    not included at the bottom of the message.
X
X    When forwarding a message, the cursor is`09`09Null editorCommand.
X    positioned one character too far to the left
X    on the "To: " line.
X
X    When including article text in a reply,`09`09Null editorCommand,
X    followup or forwarded message, includeCommand`09non-null includeCommand.
X    is ignored.
X
X    When including the article text in a reply,`09`09Null editorCommand.
X    followup or forwarded message, the text is
X    included one line at a time and gets inserted
X    rather slowly.
X
X    I think that's probably about it.  In addition to the bugs that are
X    mentioned above, two other user-visible changes have been made:
X
X    1) The editor command is now executed with the bourne shell, rather than
X    the C shell, since that's what people expect commands run from programs
X    to be executed with.  This should probably be controllable through an X
X    resource, but if it isn't going to be, then sh is a better default than
X    csh.  In any case, if someone wants to use csh, they can put "/bin/csh
X    -fc ..." in the resource.
X
X    2) The includeCommand resource is now expected to have only *two* %s in
X    it, rather than three.  The first is replaced by the prefix, and the
X    second is replaced by the article file name.  The filter is expected to
X    output to stdout.
X
X- found serious core leaks
X  Jim Rees <rees@citi.umich.edu>
X
X- clean up of the XRN man page
X  Jonathan I. Kamens <jik@pit-manager.mit.edu>
X
X- replyTo works for mail also
X
X- check for invalid newsgroups
X
X- kill subject returns to next unread after subject entry, not first
X  unread
X
X- added support for DOTDIR
X  Michael Salmon <Michael.Salmon@eos.ericsson.se>
X
X- speed ups
X  Boyd Roberts <boyd@prl.dec.com>
X
X- 'verboseKill: false' now eliminates all messages.
X
X- i386 support
X  Jonathan I. Kamens <jik@pit-manager.mit.edu>
X
X- includeCommand resources
X  Nathan Maman                <sun!mirsa.inria.fr!Nathan.Maman>
X
X  I've added the resource `60includeCommand'.  It is a sprintf'able
X  string with `60%s' arg where the includePrefix and the article file name.
X
X  For example, you can put the following line in your .Xdefaults:
X
X      XRn.includeCommand: xmh-insert-reply -s '%s' %s
X
X- 'P' for printed
X  Nathan Maman                <sun!mirsa.inria.fr!Nathan.Maman>
X
X- XRN now detects detects write failures when updating the .newsrc file
X  (such as file system full, disk going off-line, etc).
X
X- Works around horrible parsing done in `60inews' for the newsgroups line.
X
X- new option: xrn.lockFile, xrn -lockFile
X`09set the name of the file used for locking multiple XRN runs.
X`09(use:  xrn -lockFile .xrnlock-sports -newsrcFile .newsrc-sports)
X
X- new option: ccForward resource (with the "CC" class) to cause
X  forwarded messages to be CC'd to the author.
X`09Jonathan I. Kamens <jik@pit-manager.mit.edu>
X
X- new icon
X`09sun!oskeewow.b23b.ingr.com!tracy (Robert Tracy)
X
X- changes for to allow building with X11R5
X`09Jonathan I. Kamens <jik@pit-manager.mit.edu>
X
X- improvements to the Imakefile
X`09Marc Evans <evans@decvax.dec.com>
X
X- bug fixes
X`09Jonathan I. Kamens <jik@pit-manager.mit.edu>
X`09Dale Moore <Dale.Moore@cs.cmu.edU>
X`09Mike Yang <mikey%eukanuba.wpd@sgi.com>
X`09Harper Mann <harper@mips.com>`20
X`09David Brooks`09<dbrooks@osf.org>
X`09Alec Wolman <sun!crl.dec.com!wolman>
X`09Michael Burns <sun!chem.psu.edu!burns>
X`09Boyd Roberts <sun!prl.dec.com!boyd>
X`09Andy Sherman <andys@ulysses.att.com>
X`09Tevfik Karagulle <tev@cama01.uio.no>
X`09Dave Lemke <sun!ncd.com!lemke>
X
X- new resource for use with the 'refile' option, mhPath, sets the path
X`09to use for finding 'refile'
X`09Andrew Wason <aw@rruxi.bae.bellcore.com>
X
X- new resource to watching for new news, watchUnread
XIf the resource is not set or empty, i.e.
X
XXRn*watchUnread:`09
X
Xthen the current behavior applies.  We set it in our XRn file to our
Xorganization group and the "empty" option lets users reset it to "all".
X`09`09SEI
X
X
X`0C
X
XXRN release 6.16:
X
X- never really released...
X
X`0C
X
XXRN release 6.15:
X
X- environments tested on:
X`09Ultrix: twm, MOTIF widgets
X`09Ultrix: tvtwm, MOTIF widgets
X`09Ultrix: mwm, MOTIF widgets
X`09Ultrix: mwm, DEC widgets
X`09Ultrix 3.1, 4.0, 4.1: mwm, Athena widgets
X`09Sun 4, SunOs 4.0.3c: mwm, Athena widgets
X`09Apollo Domain/OS SR10.3
X
X- Ability to change the mouse cursor color
X       (pointerForeground, pointerBackground)
X`09Casey Leedom <casey@gauss.llnl.gov>
X
X- On Apollo, the ORGANIZATION environment variable is called NEWSORG
X
X- Local time support for Ultrix and Apollo
X`09Jim Rees (rees@citi.umich.edu)
X
X- Handling of a.b.c.d format for NNTPSERVER
X`09Jim Rees (rees@citi.umich.edu)
X
X- Changes to Imakefile to support Saber
X`09Jonathan I. Kamens          <jik@pit-manager.mit.edu>
X
X- Text field in dialog boxes now resizes to fit the initial text string
X
X- The composition pane now uses the USER and FULLNAME environment variables
X`09Jonathan I. Kamens          <jik@pit-manager.mit.edu>
X
X- Follow-up to poster handled
X`09Jonathan I. Kamens          <jik@pit-manager.mit.edu>
X
X- The leaveHeaders resource now supports the 'all' (all fields) keyword
X  and the stripHeaders resource now supports the 'none' keyword.
X  See the man page for an explanation.
X`09Jonathan I. Kamens          <jik@pit-manager.mit.edu>
X
X- If you're running 1.5.11 NNTP or better, define NNTP_REREAD_ACTIVE_FILE
X  to cut down on the time it takes to do a rescan.  This assumes that
X  this works that way I was told it does...
X   `20
X- Updates to the Motif support
X`09Mike Yang                   <mikey%eukanuba.wpd@sgi.com
X
X- Support for `60vfork' - spawning processes was taking a long time
X  (spawning editors now uses vfork and a simple popen was writen
X  that uses vfork - ultrix popen uses fork, argh!!)
X
X- Carriage return (with the cursor in the message dialog) will now dismiss
X  the message dialog
X
X- The message dialog now tells you explicitly whether a mail message was
X  sent or an article was posted
X
X- Forwarding a message now creates a subject line based on the article
X  group and number
X`09Bob Ellison`09`09    <ellison@sei.cmu.edu>
X
X- a few key bindings have been added to all and add modes
X  (1 each, quit)
X
X- Lots of bug fixes
X`09Jonathan I. Kamens          <jik@pit-manager.mit.edu>
X`09Per Hedeland                <per@erix.ericsson.se>
X`09Nathan Maman`09`09    <sun!mirsa.inria.fr!Nathan.Maman>
X
X- Save now supports MH refile - specify '+folder' in the save dialog
X`09Bob Ellison
X
X- lexer modified so alt.stupid.putz`5EH`5EH`5EH`5EHkutz.putz would be accept
Ved
X
X- composition pane fixes
X`09Per Hedeland                <per@erix.ericsson.se>
X
X- save fixes (>From)
X`09Per Hedeland                <per@erix.ericsson.se>
X
X- error checking on article storage
X`09Per Hedeland                <per@erix.ericsson.se>
X
X- some (but not all) memory leaks plugged...
X
X
XXRN release 6.14:
X
X- next newsgroup / fed up cursor positioning bug fixed!
X
X- articles marked as unread will not be marked read by catch up and fed up
X
X- checkpoint button added to article mode (artCheckPoint)
X
X- line count can now be displayed in the subject index window
X    (use -displayLineCount)
X    Chris P. Ross               <cross@eng.umd.edu>
X
X- search regex groups in newsrc order
X    Per Hedeland                <per@erix.ericsson.se>
X
X- new tempnam.c function, posting bug fixed
X    Jonathan I. Kamens          <jik@pit-manager.mit.edu>
X
X- author full name is controlled by a resource now, not a config parameter
X    (+/-authorFullName)
X    Mike Yang                   <mikey%eukanuba.wpd@sgi.com
X
X- MOTIF support for the new scrolling buttons
X    Mike Yang                   <mikey%eukanuba.wpd@sgi.com
X
X- Modified Action procedure calling:
X
X    Modified the calling sequence for the Action procs so that they pass`20
X    the other parameters (event, parameters, and count) to the Function`20
X    procs.  This allows the actions to be able be given strings.  I used`20
X    this to modify artSaveFunction to save using the given argument.`20
X    In my case, I modified the app-defaults file so that F6 calls artSave`20
X    with "`7C mail dce".  `5Badded '%' in article mode to pipe the article`2
V0
X    through uudecode - ricks`5D
X    David Elliott               <dce@smsc.sony.com>
X
X- configuration now based on SYSV defined, not BSD defined
X    Casey Leedom`09`09<casey@gauss.llnl.gov>
X
X- default print command passes 8-bit characters (for French sites)
X    Marcin Skubiszewski`09`09<skubi@prl.dec.com>
X
X- toggle groups changed to List Old and the output is in a new format
X    When a group contains only old news, the corresponding line is
X    `09"       news in misc.misc ..."
X    instead of the old (and wrong)
X    `09"Unread news in misc.misc ..."
X    similarly, when a group is totally empty (which is unfrequent), the
X    line reads
X    `09"            in misc.misc ..."
X    Marcin Skubiszewski`09`09<skubi@prl.dec.com>
X
X- new button in article mode: list old (artListOld)
X    lists all articles available in the group
X    Marcin Skubiszewski`09`09<skubi@prl.dec.com>
X
X- new format for "Unread news" lines in newsgroup mode
X    `09"Unread news in misc.misc          3 articles   + 350 old"
X    where "+ 350 old" means that misc.misc contains 350 old messages.
X    This count is not always right, but it is right for the newsgroups
X    which never expire
X`09Marcin Skubiszewski <skubi@prl.dec.com>
X
X- new resources: saveString and resetSave.
X    saveString sets the default string to go in the Save dialog (the
X    default is the empty string, as before), and resetSave affects
X    whether or not the SaveString variable gets reset for each newsgroup.
X    David Elliott               <dce@smsc.sony.com>
X
X- fix so word wrapping works correctly
X    Jim Graham`09`09`09<flar@eng.sun.com>
X
X- various bug fixes
X    Marc Evans`09`09`09<evans@decvax.dec.com>
X    Mike Yang                   <mikey%eukanuba.wpd@sgi.com
X    Jonathan I. Kamens          <jik@pit-manager.mit.edu>
X    Per Hedeland                <per@erix.ericsson.se>
X    Casey Leedom`09`09<casey@gauss.llnl.gov>
X    Marcin Skubiszewski`09`09<skubi@prl.dec.com>
X    Greg McNutt`09`09`09<gcmcnutt@mlsgcm.Ebay.sun.COM>
X
X- man page updated (and flags/options now in alphabetical order)
X
X`0C
XXRN release 6.13:
X
X- signature file is not automatically included if compiled with the`20
X  INEWS_READ_SIG option (see config.h)
X   David Elliot`09`09`09<dce@smsc.sony.com>
X- display local time instead of GMT (only works for SYSV machines right now,
X  how do you do it for a non-SYSV machine?)
X  (see USE_LOCALTIME and +/-displayLocalTime)
X    Mike Yang`09`09`09<mikey%eukanuba.wpd@sgi.com>
X- the default distribution can now be set
X  (see DISTRIBUTION and -distribution)
X- C-News does not (by default) reset the low number of the newsgroups
X  in the news active file, however many sites have programs to do this.
X  If you do, define FIXED_C_NEWS_ACTIVE_FILE)
X- the goto newsgroup dialog now takes substrings and regular expressions
X- new button in newsgroup mode: 'toggle groups', display all groups that
X  are currently subscribed to.
X- SVR4 fixes
X   David Elliot`09`09`09<dce@smsc.sony.com>
X- better editorCommand failure return information
X   David Elliot`09`09`09<dce@smsc.sony.com>
X- bug fixes
X  - toggle header, rot13, typeahead
X    Per Hedeland`09`09<per@erix.ericsson.se>
X- scroll bar stuff
X    Dan R. Greening`09`09<dgreen@cs.ucla.edu>
X- scrolling
X    Jim Graham`09`09`09<flar@eng.sun.com>
X- man page has been updated somewhat (still probably a bit out of date)
X- new defines for machines that don't have TEMPNAM and STRSTR
X`09(see config.h)
X
X`0C
XXRN release 6.12:
X
X- a little faster (better use of X toolkit functions)
X- word wrapping of postings and mail fixed
X- uses less memory
X    jhsu@wsl.dec.com (define STUPIDMMU in config.h)
X- fix for C-news low article number problem:
X`09C-new does not update the low article number in the active file...
X`09murphy@ufp.dco.dec.com
X- Motif support
X`09- add -DMOTIF to the compiler flags in the Imakefile
X`09- link with -lXm rather than -lXaw and -lXmu
X`09mikey%eukanuba.wpd@sgi.com
X- icon title change for unread news
X`09mikey%eukanuba.wpd@sgi.com
X- addition of ansi-c prototypes`20
X`09mikey%eukanuba.wpd@sgi.com
X- better author parsing (for author full name)
X`09Odd Einar Aurbakken <oea@ifi.uio.no>
X- author full name in subject window (define AUTHOR_FULLNAME in config.h)
X`09(also can be controlled by a resource, mikey%eukanuba.wpd@sgi.com)
X- direct use of inews when posting (also: haozhou@acsu.buffalo.edu (hao zhou
V))
X`09Odd Einar Aurbakken <oea@ifi.uio.no>
X- verboseKill option
X`09Odd Einar Aurbakken <oea@ifi.uio.no>
X- artLast, artNext now show proper unread count
X
X
X`0C
XXRN release 6.11:
X
X- editorCommand program is now a separate process
X- groups of articles can now be saved as a group
X`09- select a group of articles, hit 'save',
X`09  if a '%d' is in the string typed into the dialog box,
X`09  it will be replaced with the article number.
X- organization can now be set from the environment
X`09(per@erix.ericsson.se)
X- xrn -help no longer removes the lock file
X- accelerators can now be specified in your resources file
X`09(jik@pit-manager.mit.edu)
X- much better error handling and recovery
X`09(jik@pit-manager.mit.edu)
X- fixed freeing of a non-malloced structure
X`09(mikey@eukanuba.wpd.sgi.com)
X- added blank lines in compositions
X`09(mikey@eukanuba.wpd.sgi.com)
X- lots of cleanup
X`09(jik@pit-manager.mit.edu)
X- fixed core dump problem
X`09(jik@pit-manager.mit.edu)
X- moved information dialog defaults to application defaults file
X`09(jik@pit-manager.mit.edu)
X- 'Message-ID' and 'Date' now added to postings and followups
X`09(drw900@anusf.anu.edu.au)
X     - in my opinion, this is really the responsibility of the NNTP
X       server and news readers/posters have no business generating`20
X       these fields...  but there are a few NNTP servers that don't
X       do it (or don't spawn an inews that does it)
X       GENERATE_EXTRA_FIELDS in config.h turns on the generation of`20
X       these 2 fields
X- got rid of 'Cc: user' on forwards
X- new resource (xrn.cc), allows the user to specify if a 'Cc' should
X  `09be added to a reply.
X- newsgroup names can now have '$' in them
X`09(dgreen@cs.ucla.edu + others)
X- "--" now separates signatures and messages when posting
X
X
X`0C
XXRN release 6.10:
X
X- usage message can be requested when another xrn is running
X`09(lock file is not checked until later on)
X- title and iconName can be specified via X resources
X`09(per@erix.ericsson.se)
X- tmpDir is now tilde expanded
X- artFedUp now allowed to have a confirm box
X- changes to XRn.ad
X`09(jik@pit-manager.mit.edu)
X- better error handling in article saving code (and faster saving)
X`09(jik@pit-manager.mit.edu)
X- better handling of form feeds in articles
X`09(per@erix.ericson.se)
X- added 'Cc: user' to mail messages
X- fixed bug that caused a core dump during automatic rescan
X`09(per@ericom.ericsson.se)
X- made prefetch_max a resource
X`09(evans@decvax.dec.com)
X- xrn.includePrefix for setting the include article text prefix
X`09(defaults to "`7C> ")
X- popups fixed
X`09(jik@pit-manager.mit.edu)
X- handles newsgroups of type 'x'
X`09(jik@pit-manager.mit.edu)
X- newsgroup names can now contain '&'
X- better handling of multiple messages in the information dialog
X- version number of XRN now stored in XRn.ad, so on startup XRN
X  can determine if the XRn.ad file is in sync with XRN
X- xrn.cancelCount for specifying how many articles to scan before
X`09popping up the 'cancel search' button
X- added another way to specify the senders actual address (RETURN_HOST,
X`09see config.h) (phil@BRL.MIL)
X- better core dump handling, now a resource (xrn.dumpCore)
X`09(jik@pit-manager.mit.edu)
X- probably more that we forgot about...
X
X
X`0C
XXRN release (6.9):
X
X- support for gould machines (Hugues.Leroy@irisa.fr)
X- fixed XRn.ad:
X`09missing colon: jqj@rt-jqj.stanford.edu (JQ Johnson)
X`09reordering bindings: he@idt.unit.no (Haavard Eidnes)
X- commented out the following from Xresources.sample:
X`09xrn.organization: UC Berkeley IC CAD Group
X`09xrn.replyTo: ricks@berkeley.edu
X  users were copying the entire file verbatim and I was getting
X  replies to articles posted by others...
X- better `60info line' messages for some of the buttons
X- bug fixes to compose (many authors)
X- ANSI-C updates for mesg.`7Bh,c`7D: Ken Raeburn <Raeburn@ATHENA.MIT.EDU>
X- bug fixes ito XFILESEARCHPATH code
X
X
XXRN release (6.8):
X
X- bug fixes
X  - signature file now in the right place (various authors)
X- XRN now detects if the application defaults file has not been installed
X- posting group fix
X- artFedUp
X- documentation on widget hierarchy
X- cancel button for stopping searches
X
X
XXRN release (6.7):
X
X- bug fixes
X  - now return to the right now after next newsgroup
X   (Jonathan I. Kamens <jik@pit-manager.mit.edu>)
X  - button box size at start is correct
X   (Jonathan I. Kamens <jik@pit-manager.mit.edu>)
X  - topLines now works
X- faster newsrc file backup
X   (Jonathan I. Kamens <jik@pit-manager.mit.edu>)
X- mail messages are now wordwrapped in the same manner that articles are
X   (Jonathan I. Kamens <jik@pit-manager.mit.edu>)
X- updated XRn.ad file
X  - default button labels, fixed key bindings, grips removed
X    (us, Salvador Pinto Abreu <spa@fctunl.rccn.pt>,
X    and Jonathan I. Kamens <jik@pit-manager.mit.edu>)
X- scroll and doTheRightThing work again (just like they did in the R3 versio
Vn)
X  - a backwards scroll function also exists, default bound to 'b'
X- SHORT_ICONNAME
X  - define this to keep your icon title small
X    (Mike Yang <mikey@wsl.dec.com>)
X- user-settable command button labels
X  - see XRn.ad
X    (Salvador Pinto Abreu <spa@fctunl.rccn.pt>)
X- select newsgroup / article
X  - click with the middle button in the index window (top text window)
X    on a newsgroup entry to enter the group, on a subject entry to read`20
X    an article (just like the old double clicking)
X    (Salvador Pinto Abreu <spa@fctunl.rccn.pt>)
X- better Imakefile`20
X  - handles the use of installed libraries better
X    (Mark Hastings <hastings@walnut.berkeley.edu>)
X  - handles saber
X   (Jonathan I. Kamens <jik@pit-manager.mit.edu>)
X- XFILESEARCHPATH added, see config.h
X   (Jonathan I. Kamens <jik@pit-manager.mit.edu>)
X
X- the name of the article text widget was changed from
X  "text" to "articleText"
X
X
XXRN release (6.6):
X
X- xmkmf
X- IBM RT AOS patches
X  (Keith Moore <moore@cs.utk.edu>)
X- titlebar removed and the title and iconName resources are set to
X  what the titlebar originally contained (you can define TITLEBAR in
X  config.h to get it back)
X- pane bug fix:
X`09Thanks!  aw@rruxi.bae.bellcore.com (Andrew Wason)
X
XXRN release (6.5):
X
XNOTES:
X
X- R3 support has not been tested
X- editorCommand has not been tested
X- VMS support has not been tested
X
X- X11R4 support (define R3 to get R3 support, see config.h)
X    - use 'xrn*ShapeStyle: Oval' to get rounded buttons
X- subscribes to groups that are entered via "goto group"
X- ALT-MAILER-2 (Marc Evans <evans@decvax.dec.com>)
X- NO_SENDMAIL removed, now use ALT-MAILER-2
X- PRINTER (???)
X- if you goto a group from all mode, exiting the group will return you to
X  all mode
X- mail messages are now folded in the same manner that article submissions
X  are folded
X- bug fixes:
X  - using wrong text widget in some 'all mode' functions
X`09(Mark J. Kilgard <@rice.edu:mjk@uncle-bens.rice.edu>)
X  - mesgPane is no longer editable
X  - freeing some already freed (or never allocated) memory
X- if the lock file is on the same host and the xrn process is no longer
X  running, the lock file will be updated and xrn will be allowed to run
X- save file name is not saved across newgroups
X
X
XXRN release (6.4):
X
X- documented xrn.info: on/off (xrn +/-info)
X- new define, FIXED_ACTIVE_FILE.  Define this if your news system
X  defines its active file format such that if the first article number
X  and the last article number are the same, there are no articles
X  available (see config.h).  This will speed up 'rescan' and startup.
X- support for Swedish characters in group names
X- new option: +/-typeAhead, +typeAhead allows typeahead, -typeAhead
X  disallows typeahead.
X- bug fixes
X  - temp files were being left around if a posting was aborted
X  - fixed bugs from interacting buttons
X  - fixed timeOut problems
X  - fixed type-ahead, DO_NOT_EAT_TYPE_AHEAD gotten rid of
X
X
XXRN release (6.3):
X
X- bug fixes
X- eats type-ahead (I think... - #define DO_NOT_EAT_TYPE_AHEAD in config.h
X`09if you don't like this feature)
X- alternate mailer - calls 'send' rather than 'sendmail',`20
X  allowing 'mh' aliases to be used (see the file ALT-MAILER)
X`09(thanks to Chris Tengi <tengi@Princeton.EDU>)
X- auto rescan (see the description of -rescanTime in the man page)
X`09(see RESCAN_TIME in config.h)
X- informational messages to the Information window can be turned off
X`09(see +/-info, xrn.info: on/off)
X- better internal specification of buttons
X- busy cursor works for key bindings and double clicking
X- new defines: RESOLVER, NO_SENDMAIL, (see the file config.h)
X`09(thanks to Greg Wohletz <greg@duke.cs.unlv.edu>)
X- new hobbes bitmaps (to keep Calvin company)
X`09(thanks to me and mead!devil!dem@decwrl.dec.com (Dave Myers))
X- cancel authorization check
X`09(thanks to <asjl@comp.vuw.ac.nz> Andy Linton)
X
X
XXRN release (6.2.1):
X
X- include config.h in cursor.c and utils.c
X- removed sys/file.h from source files (included via X11/Xos.h)
X- change #if SYSV_REGX to #ifdef SYSV_REGX in cursor.c
X- fixed app defaults installation
X- fixed width and height in app defaults
X- composition window name change to "Composition"
X- include file box would segv, fixed
X- moved getinfofromfile to internals.c so other
X  implementations of clientlib can be used
X- added v`7Bf,s`7Dprintf for those that don't have it in libc.a
X- added strtok for those that don't have it in libc.a
X- documented the new confirm boxes
X- goto article screwed up for out of range article number, fixed
X- indef's added so file/org/domain defines can be done in the
X  Imakefile
X- char -> int in compose.c
X- added button for scrolling
X
X
XXRN release (6.2):
X
Xbug fixes
X- print for VMS fixes (misinstalled patch)
X  `5Bthanks to Kevin Herbert <herbert@gr8ful.enet.dec.com>`5D
X- popup dialogs work better with sticky focus window managers
X  `5Bthanks to mikey@wsl.dec.com (Mike Yang)`5D
X- added ':' to the end of the Article %ld in %s line in saved articles
X  (allows various mail programs to work on saved articles)
X- installing add mode translations could occasionally core dump
X- next newsgroup should work better now (no core dumps or infinite loops)
X- fixed a few infinite loops
X- the articles that have been read are no longer lost when you unsubscribe
X  to a group
X
Xkey bindings are no longer lost after using pop up dialogs.
X
Xinformation box geometry can now be specified:
X`09xrn.Information.geometry:`20
X
Xarticles can now be sorted by subjects.  See xrn.sortedSubjects.
X  sorting is case insensitive and based on the first 24 characters
X
X"include file" now does tilde expansion
X
Xposting failures put you back in the composition window
X
Xdefault action for confirm dialog boxes is now 'yes'.
X
Xsupport for the macII running A/UX 1.1 (System V Rel 2 with BSD networking)
X  `5Bthanks to glenn@mathcs.emory.edu (Glenn T. Barry)`5D
X
Xsupport for HPUX
X  `5Bthanks to jp@hplb.hpl.hp.com (Julian Perry)`5D
X
Xeven better kill file support
X- regular expressions are supported in the kill pattern
X  (still missing: all the various possible commands that can be used)
X- better kill file entries generated
X
XNN 'Re`5E#:' is understood and dealt with.
X
Xconfirm boxes are now available on a per-button basis.
XSee xrn.confirm in the man page.
Xp
Xsubject next now uses a case insensitive/24 character comparision
X
Xrn bindings are in the app-defaults file and are now the default bindings
X
Xinternals
X- better 'mesgPane' interface
X  `5Bthanks to mtoy%there.esd.sgi.com@sgi.sgi.com (Michael Toy)`5D
X
X
XXRN release (6.1):
X
Xbug fixes
X  - insertion point for compose windows now in the right place
X  - tabs and new lines can now be in *ButtonList: X resources
X  - occasionally xrn would die due to not being able to open
X    the newsrc temp file - this has been fixed
X  - garbage text in error label during subject next gotten rid of
X  - group names can now be longer than 32 characters
X`09'hp-factory.software-eng.excalibur' can now be read
X  - busy cursor appears all of the times when XRN is busy
X  - top window redraws correctly - going from all/ng mode to
X    article mode, if the group was empty, you would pop back out
X    to all/ng mode, but without any text in the top window
X  - control C now aborts a subject search
X  - exiting out of All mode had some problems
X    (thanks to Rich Simoni <simoni@strat.stanford.edu>)
X
Xpopup mesg window
X  - no more output to stderr
X  - much of the error/warning output that went to the top info/help
X    label now goes to the mesg window
X
Xdefines to deal with various toolkit/window manger problems
X  - see config.h
X
Xconfirm box on XRN quit/exit
X
Xkey bindings now work in all widgets, not just the button box
X
XVMS support (thanks to Kevin Herbert <herbert@gr8ful.enet.dec.com>)
X
Xxrn checks to see if another xrn is running - the .rnlock file
X  used by rn is not used.  XRN stores the host that XRN is running
X  on in addition to the process id.
X
Xkey bindings are now exported:
X  - four new resources/command line options:
X`09addBindings, artBindings, allBindings, ngBindings
X  - see the man page for more information
X
XSet of RN-like keybindings for XRN
X  (thanks to Jeff Wallace <jeffw@scam.Berkeley.EDU>)
X
XNew configuration parameter: SUBJECTS (config.h)
X  - the number of subject lines to prefetch when doing a backwards
X    subject search.  The default is 10
X
Xturning off kill file support:
X  - for those of you that don't use kill files, the searching`20
X    for kill files can be turned off.  The kill buttons remain
X    if you want to add something to a kill file, but they will
X    not be processed.  See the +/-killFiles option.
X
XngLastGroup changed to ngPrevGroup
X  - last group confused some people who thought it meant go to
X    the last group displayed in the newsgroup index.
X
Xnew button in article specific pane: print
X  - print an article, uses the 'printCommand' resource/command line option
X    (defaults to 'enscript')
X
Xnew button in composition pane: include file
X  - includes a file in a posting - like Meta-I in the text
X    widget, but: (1) does not screw up your keyboard bindings,
X    and (2) has an accelerator.
X
Xincluding an article now only includes the text (strips the header).
X  - this can be changed via the 'includeHeader' option.
X  (thanks to Paul Raveling <raveling@isi.edu>)
X
Xthe .newsrc file can now be automatically updated when leaving article
X  mode - see the `60updateNewsrc' option.
X
Xslightly better KILL file support
X  - killing based on author name supported
X  - more formats of kill file entries supported
X
Xarticles can be saved into newsgroup `60folders', like 'xmh'.  see the
X  saveMode option (thanks to Paul Raveling <raveling@isi.edu>)
X
XMore ways to specify the domain, hidden host, new hidden path, ...
X  (thanks to Frederick M. Avolio (avolio@decuac.dec.com)
X  - see config.h
X
XUSC ISI app-defaults file for XRN included (isi.app-defaults)
X  (thanks to Paul Raveling <raveling@isi.edu>)
X
X'abort' option in the death notifier dialog now dumps core in
Xthe real stack rather than the signal stack (thanks to KJ Pires
X<kjpires@ic.Berkeley.EDU).
X
XCompiles with GCC.
X
X
XXRN release (6.0):
X
XMan page now even better reflects reality.
X
XMuch faster startup and rescan.
X
XCan specify the order and number of buttons for each mode via
XX resources or the command line: ngButtonList, addButtonList,
XallButtonList, artButtonList, artSpecButtonList.
X
XPost button exported to Newsgroup mode so you can post to
X  newsgroups with no available articles.
X
XNext Newsgroup works.`20
X
XCleaned up included articles in composition windows
X
XBug fixes
X  - fixed sending articles/messages with editorCommand
X     (always would be sent)
X  - loss of keybindings after dialog pop up attributed to
X    window manager problems (gwm, hpwm, and sometimes twm and mwm).
X    Key bindings are not lost when using dxwm, uwm.
X    `5BVERY STRANGE`5D
X
XOrganization field can be defaulted in config.h
X
XCompose windows are now topLevelShells rather than transientShells
X
X
X
XNew XRN release (5.7):
X
XBug fixes
X
X
X
XNew XRN release (5.6):
X
XKill Files
X  - new commands (session kill, local kill, global kill)
X
XBug fixes
X
X  - core dumps
X
XOrganization and Reply-To fields in postings can now be specified
Xvia X resources or the command line.
X
XMan page now better reflects reality.
X
XImakefile
X
XRCS ID's
X
X
X
XNew XRN release (5.5):
X
Xline eater bug fix
X
X
XNew XRN release (5.4):
X
XChanges from the last release of XRN:
X
X- considerably less memory usage
X
X  XRN uses a very simple data structure for storing information
X  about newsgroups and articles.  For every newsgroup, an array
X  the size of the number of articles available in that group
X  is created.  This causes XRN to grow to 2.5 to 3Meg at most
X  sites (at UCB, we have 650 groups and 2 week expiration, and
X  XRN groups to 3Meg).  However there is no reason to keep article
X  arrays for groups that you are not subscribed to.`20
X
X  Bill Webb (IBM AWD Palo Alto, ...!uunet!ibmsupt!webb) sent in a
X  set of patches to have XRN only create article arrays for subscribed
X  to groups.  This decreases the memory from 3Meg to 900k (for us).
X  The amount you save will depend on what percentage of the newsgroups
X  that you subscribe to.
X
X- better nntp server error messages (sq)
X
X  The messages XRN gives to the user for NNTP failures don't give
X  you much information.   Ian Darwin (ian@sq.sq.com) sent in a set
X  of patches to improve the error messages.
X
X- alternative newsrcfile location (uiuc)
X
X  Many people like to have xrn look for a newsrc file based on the
X  particular server being used.  Dirk Grunwald (grunwald@flute.cs.uiuc.edu)
X  sent in a set of patches to cause xrn to look for a newsrc file
X  of the form <newsrcFile>-<nntpServer> before looking for just
X  <newsrcFile>.
X
X- includeSep
X
X  A new Xdefault has been added to get rid of the "> " characters
X  put in front of included messages.  Xdefault:
X`09
X`09    includeSep: on/off
X
X  Command Line:
X
X`09    +/-includeSep
X
X- header lines are no longer broken
X
X  The last release included code to break long lines in news postings
X  to reasonable values.  Unfortunately it would also break header
X  lines (which is not allowed).  This version does not break the lines.
X
X- updated man page
X
X  The man page has been updated to reflect the current state of XRN.
X
X- double click
X
X  `5Bnote: this feature has not been added to the man page - it still
X  has some problems`5D
X
X  Double clicking on a newgroup entry will send you to the group.
X  Double clicking on an article entry will display the article.
X
X
X
X`09`09Rick Spickelmier (ricks@ic..berkeley.edu)
X`09`09Ellen Sentovich (ellen@ic..berkeley.edu)
X
$ CALL UNPACK CHANGELOG.;2 792696061
$ create 'f'
XThis document describes the changes made to mxrn/dxrn (and the original
XXRN code).
X
XThis kit identifies itself as 'V6.18-26'.
X
XThe major changes for this release were to pick up the changes from XRN
XV6.17 to V6.18. See the file 'ChangeLog' for a detailed log of edits.
X
XChanges specific to dxrn/mxrn:
X
X- Fix window sizing bug introduced in edit 25.
X
X- Change "catch up" to only mark up to the current article as read; add`20
X  "catch up all" function to mark all articles read. (The old behavior was
X  inconsistent with the rest of xrn and very destructive.)
X
X- Eliminate unecedsary resizing of the button boxes.
X
X- Correct reporting of connection refusals
X
X- Fix memory leak in article composition
X
X- Add the ability to bypass the confirmation box on external editor exit
X
X- Add progress messages to search commands
X
X- Fix handling of large (more than 40 character) group names so they aren't
X  misdiagnosed as duplicates
X
X- Fix crashes after attempting to read a bogus newsgroup (one with no availa
Vble
X  articles) and after rescans.
X
X- Use the defined editor command for killfile edits
X
X- Add menu entry for editing global killfile
X
X- add "mxrn.unsubNewGroups" resource (default false). If set to true, new
X  groups are silently unsubscribed.
X
X- save size of newsgroup list/subject list widget when settings are saved.
X
X- Fix compilation errors on Alpha/VMS; support VMS Motif 1.2.
X
X- Fix bug on big-endian machines that was causing main window to resize
X  incorrectly (too big or too small).
X
X- Fix `60List Old' failing when the first article in a group is unavailable.
X
X- Fix linux build errors
X
X- Always send MODE READER command on setup (fix for INN clients)
X
X- Add a ROT13 function to the composition window
X
X- Fix killfile editor function build errors (include types.h)
X
X- Add a function to edit the kill file for a newsgroup.
X
X- Fix sizing of the article text scrollbar on Motif 1.2 systems.
X
X- For `60Forward' operations, preset the cursor to the "To:" field.
X
X- Fix VMS DECnet transport hanging.
X
X- Fix reported portability problems - Solaris, HP-UX, SCO.
X
X- Use the highlighted newsgroup name for the default on unsubscribe
X  operations.
X
X- Fix crash in subject searches of long subject lines.
X
X- Allow longer newsrc file lines
X
X- Popup retry dialog on news server failures more quickly.
X
X- Fix additional auto-read disabled crashes.
X
X- Fix "X Error" that was occuring with two-windows mode enabled when exiting
X  at group without reading any articles.
X
X- Put the menu bar back for dxrn.
X
X- Improve handling of auto-read disabled; select the first unread after a
X  kill (but don't read it.)
X
X- Fix crash with repeated kill operations with auto-read disabled.
X
X- Handle server disconnection during welcome message without hanging.
X
X- Add "mxrn.textLines" resource for specifying the size of the text window;
X  save the current size on Save Settings.
X
X- Fix crash caused by bogus references string. (an article was posted with
X  the text under the "References" header. That was lots more than the twenty
X  words I thought was more than enough :-)
X
X- Fix positioning of dialog boxes (bug introduced with an X11R6 fix).
X
X- Rationalize button label strings, menus, and dialog box labels. ("doit"
X  is not as obvious as "OK")
X
X- Fix X11R6 portability bugs (null pointers in XtGetValue arguments lists
X  corrected to valid pointers.)
X
X- Add a current mode indication to the titlebar.
X
X- Fix hang with VMS Multinet TCP/IP when exiting or rescanning.
X
X- Save position and size of the composition window when settings are saved
X  (assumes the window is visible when save is done.)
X
X- Fix unaligned access in executableSignatures code.
X
X- Clean up ugly five-button dialog box (used during subscribe operations.)
X
X- Fix crash that was occuring with inaccessable KILL files.
X
X- Fix off-by-one in string wrapping position in postings.
X
X- Add support for a separate article display window (mxrn.twoWindows: true).
X
X- Fix bug that was causing Subject and Author search to be sticky (once you
X  did an Author search, all searches were Author searches).
X
X- Fix malloc pool corrupter bug in string pool processing.
X
X- Correct VMS resource file name
X
X- Allow an external editor to be used (on VMS) without blocking the newsread
Ver.
X
X- Check $HOME/.organization for updated organization information.
X
X- Fix VMS mail file leak (each FORWARD or REPLY was leaving a dangling file
X  open).
X
X- Clean up some redundant news server transactions. (Don't ask for the same
X  thing several times).
X
X- Allow save, rot-13, etc. buttons to appear in the middle menubar.
X
X- Fix Motif word wrapping on VMS.
X
X- Properly flush server connection on shutdown.
X
X- Allow building on VMS without TCP/IP
X
X- Decrease startup memory consumption and limit memory used during rescans.
X
X- Correct line count display to eliminate trailing blanks
X
X- Fix article list corruption that was causing articles to reappear.
X
X- Fix composition window sizing problem in the bottom button box.
X
X- Fix a compilation error on AIX.
X
X- Corrected a kill bug introduced in 6.18-11.
X
X- Fixed errors found when compiling using DEC C on VMS AXP.
X
X- Added an "author search" function.
X
X- Added support for usage of the news server overview database using the XOV
VER
X  command. (This improves newsgroup open time by decreasing the server load
X  and network traffic).
X
X- Added support for article threading using the reference fields.
X  Use "mxrn*group.name.sortedSubjects: thread" to enable this.
X  Note: this is somewhat experimental. Comments appreciated.
X
X- When an article is selected (clicked on) before starting a search, begin t
Vhe
X  search at the selected article.
X
X- Change the subject search to be case-insensitive when the search argument
V is
X  all lower case. (Mixed case is case-exact).
X
X- Reinstate the software that resets the paned window limits so that subpane
Vs
X  can be resized (this fixes a bug where the compose window buttons could no
Vt
X  be read).
X
X- Fixed a second VMS with DECnet not running crash.
X
X- Added "Followup+Reply" function that posts a followup to an article then
X  forwards it as a reply to the original author.
X
X- Properly handle INN news server "Pause" states.
X
X- Added code to delete the text cursor in the article read window.
X
X- Backed out change to "next unread" that was resetting the scan to the
X  top of the article list; made it conditional on the setting of resource
X  "nextReadsFirst" (default off).
X
X- Fixed ULTRIX DECnet NNTP code to properly shut down the server connection.
X
X- Fixed compilation problem on DEC OSF/1.
X
X- Corrected crash when attempting to post on a VMS system without DECnet
X  running.
X
X- Make xrn tolerate the bogus '.cabal' group.
X
X- Include corrections to allow mxrn to compile on Alpha/VMS.
X
X- Fix "Invalid transition - 2 to 1" error when new groups are found during
X  automatic rescans.
X
X- Added "cancel" function to subject change selections.
X
X- Fixed deadlock when canceling subject search operations.
X
X- Fixed lost editor file name when re-editing messages.
X
X- Fixed a loop in reverse subject searching.
X
X- Corrected several SunOS porting problems.
X
X- Corrected setting of default Include Prefix. (If there wasn't one in the
X  application defaults file, attempting to include text would crash.)
X
X- Fixed cursor position in compose window.
X
X- Fixed a problem that was causing the editor window to be insensitive.
X  NOTE: This change caused X resources of the form "composeTop" to stop work
Ving.
X  Change them to "mxrn.composeTop..." to correct this.
X
X- Added word wrapping support for Motif.
X
X- Fixed bug that could cause a crash after recovery from a connection loss.
X
X- Added action functions to allow manipulation of article/newsgroup list
X  directly -
X`09list-forward-page() scrolls the subject list forward a page.
X`09list-backward-page() scrolls it back.
X`09list-forward-line() moves the selected line down one entry.
X`09list-backward-line() moves it back.
X
X  For example, the following:
X`09mxrn.artBindings: \
X`09`09Ctrl<Key>osfPageDown: list-forward-page()\n\
X`09`09Ctrl<Key>osfPageUp:   list-backward-page()\n\
X`09`09Ctrl<Key>osfUp:       list-backward-line()\n\
X`09`09Ctrl<Key>osfDown:     list-forward-line()\n\
X`09`09Ctrl<Key>r:           artReadCurrent()
X `20
X`09allows you to scroll the list with Control-next-screen, and
X`09shift the selection using Control-Arrow. Control-R then reads
X`09the article that is highlighted.
X
X- Fixed crash when an out-of-range subject line was trying to be displayed.
X
X- Corrected VMS Wollongong TCP/IP socket interface channel leak.
X
X- Changed order of VMS newsrc file saving - a temporary file is created and
X  then renamed to the desired name; this helps avoid losing the newsrc file
X  when crashes happen during saving the newsrc.
X
X- Fixed SunOS compiling bug.
X
X- Fixed "all articles were killed" problem when re-entering newsgroups.
X
X- Fixed data passing problem in button definitions.`20
X
X- Fixed message posting crash in signature file processing.
X
X- Fixed a problem that was causing the low article number in a newsgroup to
X  be incorrect for specific types of news servers. This was causing "List Al
Vl
X  Articles" to fail and causing incorrect message counts to be displayed.
X
X- Fixed problem that was causing duplicate "From" lines in posted messages.
X  Some news servers were rejecting these articles.
X
X- Corrected an assertion failure when reading a newsgroup that doesn't have
X  any articles.
X
X- If the connection to the news server was lost while reading a group,`20
X  the state of the group became corrupted. (The "current" group was changed.
V)
X  This has been corrected.
X
X- Several portability problems were corrected. MXRN now compiles cleanly in
X  a strict ANSI environment.
X
X- Fixes for Alpha OSF/1.
X
X- The application was rewritten to minimize memory consumption where
X  possible.`20
X
XChanges from XRN V6.18:
X
X- Faster entry into groups with lots of 'marked as unread' articles.`09
X`09Per Hedeland`09`09<per@erix.ericsson.se>
X
X- xrn.ignoreNewsgroups - ability to specify groups (regular expressions)
X  that you never want to see (even in the new groups window).  See the
X  man page for more information.  This can really cut down the size of your
X  .newsrc file and the memory usage of XRN.
X`09Jonathan I. Kamens`09<jik@pit-manager.mit.edu>
X
X- XRN now supports _ANSI_C_SOURCE, _POSIX_SOURCE, _XOPEN_SOURCE, and other`2
V0
X  standard-based defines, and thus is less vendor-specific (but clearly some
X  still exists...).
X`09Marc Evans`09`09<evans@zk3.dec.com>
X
X- Support for Motif 1.2 and cleanup of the cancel button
X`09David Brooks`09`09<dbrooks@osf.org>
X
X- No more claims of X11R3 support.
X
X- Performance Improvements (less fetching across NNTP)
X`09Jim Graham`09`09<flar@sun.com>
X
X- Permissions of the .newsrc file are not changed - previously after an
X    update the .newsrc file would have the permissions specified in the umas
Vk
X`09Rick Spickelmier`09<ricks@objy.com>
X
X- Settable Icon Pixmap and Name for normal, busy, and unread news modes
X    - via the resources/options: iconName, iconPixmap, busyIconName,
X`09`09`09`09 busyIconPixmap, unreadIconName,
X`09`09`09`09 unreadIconPixmap
X`09Michael Salmon`09`09<Michael.Salmon@eos.ericsson.se>
X
X- Translation of Articles from ISO 646 to ISO 8859-1
X`09Michael Salmon`09`09<Michael.Salmon@eos.ericsson.se>
X
X- User settable number of characters in the subject line, via
X    the indexLineLength resource/option
X`09Michael Salmon`09`09<Michael.Salmon@eos.ericsson.se>
X
X- Support for INN (InterNet News)
X`09Brendan Kehoe`09`09<brendan@eff.org>
X
X- XRN now can refile to RMAIL folders (use @folder, like MH +folder)
X`09Michael Thomas`09`09<mike@gordian.com>
X
X- The information box now tells you that articles posted to moderated`20
X  groups are sent to the moderator.
X`09Rick Spickelmier`09<ricks@objy.com>
X
X- Xtoolkit work processes now do the prefetching of the next group
X    (can be disabled by defining NO_IMMEDIATE_WORK_PROC_PREFETCH)
X`09Marc Evans`09`09<evans@zk3.dec.com>
X`09Jonathan I. Kamens`09<jik@pit-manager.mit.edu>
X
X- XRN now puts in the display name for editorCommand:
X    xrn.editorCommand: xterm -display %D -e vi %s
X    (%s for file name - must be specified, %D for display name,`20
X    this is optional)
X`09Rick Spickelmier`09<ricks@objy.com>
X
X- New Default: xrn.onlyShow number
X    Only grab the header information for the last 'number' of articles
X    in each group.  This is useful if you have been away for a while`20
X    and only want to see that last 100 or so articles in each group.
X`09Rick Spickelmier`09<ricks@objy.com>
X
X- Support for multiple signature files
X    The appropriate signature file is the usual signature file name
X    `60`7E/.signature' followed by either a `60-' and a  newsgroup name
X    substring, or followed by a `60.' and `60followup', `60forward', `60grip
Ve',
X    `60reply' or `60post' according to the posting mode.  For example if you
X    want to post a followup article in comp.sources.x then xrn uses the
X    first valid signature file in the following order:
X
X`09`09    `7E/.signature-comp.sources.x
X`09`09    `7E/.signature-comp.sources
X`09`09    `7E/.signature-comp
X`09`09    `7E/.signature.followup
X`09`09    `7E/.signature
X
X`09Nathan Maman`09`09<Nathan.Maman@sophia.inria.fr>
X
X- Support for executable signature files.  See 'executableSignatures'
X  and 'localSignatures' in the man page.
X`09Nathan Maman`09`09<Nathan.Maman@sophia.inria.fr>
X`09David Brooks`09`09<dbrooks@osf.org>
X`09Jonathan I. Kamens`09<jik@pit-manager.mit.edu>
X
X- XRN now unconditionally saves articles when posted via `60editorCommand'.
X        Conrad Kimball`09        <cek@sdc.boeing.com>
X
X- Set up defaults for reasonable line folding (of course, it's my definition
X`09of reasonable).
X`09Rick Spickelmier`09<ricks@objy.com>
X
X- Fix for bad newsgroup names
X`09Per Hedeland`09`09<per@erix.ericsson.se>
X`09Jonathan I. Kamens`09<jik@pit-manager.mit.edu>
X`09Rick Spickelmier`09<ricks@objy.com>
X
X- XRN was reading the header information twice when `60doing the right thing
V'
X`09Per Hedeland`09`09<per@erix.ericsson.se>
X
X- More XRN icons - xrn2.icon (news) and xrn3.icon (no news)
X       Rainer Klute`09`09<klute@irb.informatik.uni-dortmund.de>
X
X- Scrolling actions now exist for the subject index window
X`09    (artScrollIndex and artScrollIndexBack)
X`09Greg Schroeder`09`09<greg@sharebase.com>
X`09
X- Support for DEC Alpha OSF/1
X`09Eric Muller`09`09<muller@src.dec.com>
X`09Rick Spickelmier`09<ricks@objy.com>
X`09Dave Hill`09`09<ddhill@aosf.gsf.dec.com>
X
X- Apollo 10.3.5 support
X`09Keith Cantrell`09`09<kcantrel@core1.hssc.ksc.nasa.gov>
X
X- Amiga-UNIX support
X`09Craig M. Votava`09`09<ihlpf!cmv>
X
X- Reconnecting to server after time out will update the internal`20
X  data structures (new articles, etc.).
X`09Rick Spickelmier`09<ricks@objy.com>
X
X- Bug fixes
X`09David Brooks`09`09<dbrooks@osf.org>
X`09Bob Ellison`09`09<ellison@sei.cmu.edu>
X`09Marc Evans`09`09<evans@decvax.dec.com>
X`09Jim Graham`09`09<flar@eng.sun.com>
X`09Jonathan I. Kamens`09<jik@pit-manager.mit.edu>
X`09Andy Linton`09`09<Andy.Linton@comp.vuw.ac.nz>
X`09Nathan Maman`09`09<Nathan.Maman@sophia.inria.fr>
X`09Dale Moore`09`09<Dale_Moore@cs.cmu.edu>
X`09Taed Nelson`09`09<nelson@berlioz.nsc.com>
X`09Michael Salmon`09`09<Michael.Salmon@eos.ericsson.se>
X        Peter J. Scott`09`09<pjs@euclid.jpl.nasa.gov>
X`09Rick Spickelmier`09<ricks@objy.com>
X`09Jean-Philippe Martin-Flatin`09<syj@ecmwf.co.uk>
X`09Philip Yzarn de Louraille`09<yzarn@chevron.com>
X`09Jason C. Austin`09`09<sun!larc.nasa.gov!j.c.austin>
X
X
$ CALL UNPACK CHANGES.;55 1414457595
$ create 'f'
X
X#if !defined(lint) && !defined(SABER)
Xstatic char XRNrcsid`5B`5D = "$Header: /net/objy27/wrld/mnt11/ricks/src/mast
Ver/xrn/clientlib.c,v 1.6 1993/01/11 02:14:30 ricks Exp $";
X#endif
X
X/*
X * nntp client interface
X *
X * Copyright (c) 1988-1993, The Regents of the University of California.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X#ifdef VMS
X#define index strchr
Xint get_dnet_socket();
Xint get_server();
Xint start_server();
Xextern int sys$open();
Xextern int sys$close();
Xextern int sys$connect();
Xextern int sys$put();
Xextern int sys$flush();
Xextern int sys$get();
Xextern int atoi();
Xextern void ehVMSerror();
X/*
X * Define UCX if you want UCX TCP/IP transport for VMS.
X * Define CMU_TCP for CMU TCP/IP transport. (Code supplied by Mike Iglesias,
X *`09`09`09`09             iglesias@draco.acs.uci.edu)
X * Define FUSION for Fusion TCP/IP. (Code Supplied by Ken Robinson,
X *`09`09`09`09     robinson@cp0201.bellcore.com)
X * Define WOLLONGONG for WIN/TCP.
X * Define MULTINET for MultiNet TCP/IP.
X *`09`09`09`09  (Code supplied by John McMahon,
X *`09`09`09`09   mcmahon@tgv.com)
X *
X * Define TCPWARE for Process Software's TCPware TCP/IP.
X *`09`09`09`09`09(Code Supplied by David C. Mores,
X *`09`09`09`09`09 mores@rapnet.sanders.lockheed.com)
X *
X * Added authinfo code so this version may be compiled with the AUTHINFO
X * macro. This will inline code to communicate with the news server and
X * pass the authinfo user and password.
X *
X * Mods made by Jim Gerland (gerland@ubvms.cc.buffalo.edu) and Rich
X * Alberth (acscrja@ubvms.cc.buffalo.edu).
X *`20
X * Note to source readers: ;-)
X * "SERIALHACK" turns on a barely-functional modem-connection-to-nntpserver
X * mode. It doesn't work terribly well but allows me to debug stuff.
X * Please don't report problems with this stuff.
X */
X
X#if defined(UCX) `7C`7C defined(CMU_TCP) `7C`7C defined(FUSION) `7C`7C defin
Ved (WOLLONGONG) `7C`7C defined(MULTINET) `7C`7C defined(TCPWARE)
X#define VMS_TCPIP
Xint get_tcp_socket();
X#endif`20
X
X#ifdef MULTINET
X#define BSD_BFUNCS
X#include "MultiNet_Common_Root:`5BMultiNet.Include.Sys`5Dtypes.h"
X#include "MultiNet_Common_Root:`5BMultiNet.Include.Sys`5Dsocket.h"
X#include "MultiNet_Common_Root:`5BMultiNet.Include.NetInet`5Din.h"
X#include "MultiNet_Common_Root:`5BMultiNet.Include`5Dnetdb.h"
X#define perror socket_perror
X#define close  socket_close
Xextern int shutdown();
Xextern void bzero();
Xextern short htons();
Xextern int socket();
Xextern void bcopy();
Xextern int connect();
Xextern int send();
Xextern int recv();
Xextern int sys$dassgn();
X#endif /* MULTINET */
X
X#ifdef TCPWARE
X#include "TCPIP_INCLUDE:types.h"
X#include "TCPIP_INCLUDE:socket.h"
X#include "TCPIP_INCLUDE:in.h"
X#include "TCPIP_INCLUDE:netdb.h"
X#define send socket_send
X#define recv socket_recv
X#endif /* TCPWARE */
X
X#define NNTP_PORT_NUMBER 119
X#define index strchr
X
X#ifdef CMU_TCP
X#include <descrip.h>
X#include <ssdef.h>
X#include <iodef.h>
X#define TCP$OPEN IO$_CREATE
X#define TCP$READ IO$_READVBLK
X#define TCP$SEND IO$_WRITEVBLK
X#define TCP$CLOSE IO$_DELETE
X#endif /* CMU_TCP */
X
X#if defined(UCX) `7C`7C defined(WOLLONGONG)
X#ifdef UCX
X#include <sys/types.h>
X#define CADDR_T
X#define __CADDR_T
X#define __SOCKET_TYPEDEFS
Xtypedef char * caddr_t;
Xtypedef unsigned short u_short;
Xtypedef unsigned long u_long;
Xtypedef unsigned char u_char;
X#endif /* UCX */
X#include <socket.h>
X#include <in.h>
X#include <netdb.h>
X#endif /* UCX or WOLLONGONG */
X
X#ifdef FUSION
X#include <fns_base:`5Bh`5Dflip.h>
X#include <fns_base:`5Bh`5Dsocket.h>
X#include <fns_base:`5Bh`5Din.h>
X#include <fns_base:`5Bh`5Dnetdb.h>
X#endif /* FUSION */
X
X#include <unixio.h>
X#include <file.h>
X#define NNTPobject "::\"0=NNTP\""
X#include <fab.h>
X#include <rab.h>
X
Xstatic struct FAB server_fab;
Xstatic struct RAB server_rab;
X
X#endif /* VMS */
X#include <stdio.h>
X
X#ifdef DECNET
X#include <netdnet/dn.h>
X#include <netdnet/dnetdb.h>
Xint get_dnet_socket();
X#endif
X
X#include "codes.h"
X#include "config.h"
X#include "utils.h"
X#include "mesg.h"
X
X#ifndef VMS
X#include <sys/socket.h>
X#include <netinet/in.h>
X#include <netdb.h>
X#ifdef __STDC__
X#include <stdlib.h>
X#include <time.h>
X#include <unistd.h>
Xint get_tcp_socket();
Xint get_server();
Xint start_server();
X#if !defined(__osf__) && !defined(linux)
Xextern void bcopy _ARGUMENTS((char *, char *, int));
X#ifndef hpux
Xextern int connect _ARGUMENTS((int, struct sockaddr*, int));
X#endif
X#endif
X#ifndef linux
Xextern void bzero _ARGUMENTS((char *, int));
X#endif
Xextern int socket _ARGUMENTS((int, int, int));
Xextern unsigned long inet_addr _ARGUMENTS((char *));
X#endif
X#endif /* VMS */
X
Xvoid close_server();
X#ifdef BSD_BFUNCS
X#ifndef memset
X#define memset(_Str_, _Chr_, _Len_) bzero(_Str_, _Len_)
X#endif
X#ifndef memcpy
X#define memcpy(_To_, _From_, _Len_) bcopy(_From_, _To_, _Len_)
X#endif
X#endif
X
Xint put_server();
X
X#ifdef SERIALHACK
Xstatic char realNNTPhost`5B128`5D;
X#endif
X
Xstatic FILE`09*ser_rd_fp = NULL;
Xstatic FILE`09*ser_wr_fp = NULL;
Xstatic Boolean`09ServerOpen = False;
Xstatic int`09sockt_rd = -1, sockt_wr = -1;
Xstatic Boolean`09VMSTcpIp = False;
Xstatic int  `09level = 0;
Xstatic int  `09inBuf = 0;
Xstatic Boolean  ignoreErrors = False;
Xchar`09*server_init_msg = NULL;
Xstatic int`09server_length = 0;
X
X#ifdef CMU_TCP
Xstatic unsigned short cmu_chan;
X$DESCRIPTOR (cmu_ip, "IP0");
Xint status;
Xstruct iosb_str `7B
X    short stat;     /* status */
X    short count;    /* Byte count */
X    int`09  info;`09    /* additional info */
X`7D;
Xstruct iosb_str iosb;
X#endif /* CMU_TCP */
X/*
X * getserverbyfile`09Get the name of a server from a named file.
X *`09`09`09Handle white space and comments.
X *`09`09`09Use NNTPSERVER environment variable if set.
X *
X *`09Parameters:`09"file" is the name of the file to read.
X *
X *`09Returns:`09Pointer to static data area containing the
X *`09`09`09first non-ws/comment line in the file.
X *`09`09`09NULL on error (or lack of entry in file).
X *
X *`09Side effects:`09None.
X */
X
Xchar *
Xgetserverbyfile(file)
Xchar`09*file;
X`7B
X    char *cp;
X    extern char *getenv(), *getinfofromfile();
X    static char`09buf`5B256`5D;
X
X    if (cp = getenv("NNTPSERVER")) `7B
X`09(void) strcpy(buf, cp);
X    `7D else `7B
X`09cp = getinfofromfile(file);
X`09if (cp == NULL) `7B
X`09    return(NULL);
X`09`7D else `7B
X`09    (void) strcpy(buf, cp);
X`09`7D
X    `7D
X    return (buf);
X`7D
X
X/*
X * server_init  Get a connection to the remote news server.
X *
X *`09Parameters:`09"machine" is the machine to connect to.
X *
X *`09Returns:`09-1 on error
X *`09`09`09server's initial response code on success.
X *
X *`09Side effects:`09Connects to server.
X *`09`09`09"ser_rd_fp" and "ser_wr_fp" are fp's
X *`09`09`09for reading and writing to server.
X */
X
X#ifndef VMS
Xserver_init(machine)
Xchar`09*machine;
X`7B
X    int`09status;
X    char line`5B256`5D;
X    char`09*cp;
X
X#ifdef NNTPVIATIP
X    ser_rd_fp = fdopen(3, "r"); /* 3 is dictated by tip(1) `7EC command */
X    ser_wr_fp = fdopen(4, "r"); /* 4 is dictated by tip(1) `7EC command */
X    (void) sprintf(line, "telnet %s %d", machine, 119);
X    put_server(line, True);
X    get_server(line, sizeof(line)); /* Trying ... */
X    get_server(line, sizeof(line)); /* Connected to ... */
X    get_server(line, sizeof(line)); /* Escape character is ... */
X#else /* NNTPVIATIP */
X    close_server();`09`09`09`09/* make sure it's closed */
X
X#ifdef DECNET
X    cp = index(machine, ':');
X
X    if (cp && cp`5B1`5D == ':') `7B
X`09*cp = '\0';
X`09sockt_rd = get_dnet_socket(machine);
X`09*cp = ':';
X    `7D else
X`09sockt_rd = get_tcp_socket(machine);
X#else  /* DECNET */
X    sockt_rd = get_tcp_socket(machine);
X#endif /* DECNET */
X
X    if (sockt_rd < 0)
X`09return (-1);
X
X    /*
X     * Now we'll make file pointers (i.e., buffered I/O) out of
X     * the socket file descriptor.  Note that we can't just
X     * open a fp for reading and writing -- we have to open
X     * up two separate fp's, one for reading, one for writing.
X     */
X
X    if ((ser_rd_fp = (FILE *) fdopen(sockt_rd, "r")) == NULL) `7B
X`09perror("server_init: fdopen #1");
X`09return (-1);
X    `7D
X
X    sockt_wr = dup(sockt_rd);
X    if ((ser_wr_fp = (FILE *) fdopen(sockt_wr, "w")) == NULL) `7B
X`09perror("server_init: fdopen #2");
X`09ser_rd_fp = NULL;`09`09/* from above */
X`09return (-1);
X    `7D
X
X#endif /* NNTPVIATIP */
X
X    ServerOpen = True;
X
X    /* Now get the server's signon message */
X
X    if (server_init_msg)
X`09XtFree(server_init_msg);
X    if (! (server_init_msg = XtMalloc(1024))) `7B
X`09perror("malloc failed.");
X`09if (ser_rd_fp) (void) fclose(ser_rd_fp);
X`09if (ser_wr_fp) (void) fclose(ser_wr_fp);
X`09ser_rd_fp = ser_wr_fp = NULL;
X`09ServerOpen = False;
X`09return (-1);
X    `7D
X    *server_init_msg = '\0';
X    server_length = 1024;
X
X    do `7B
X`09if (get_server(line, sizeof(line)) == -1) `7B
X`09    if (ser_rd_fp && feof(ser_rd_fp)) `7B
X`09`09fprintf(stderr, "Unexpected EOF on NNTP server socket -- server is pro
Vbably malfunctioning.\n");
X`09    `7D else `7B
X`09`09perror("reading from server");
X`09    `7D
X`09    if (ser_rd_fp) (void) fclose(ser_rd_fp);
X`09    if (ser_wr_fp) (void) fclose(ser_wr_fp);
X`09    ser_rd_fp = ser_wr_fp = NULL;
X`09    ServerOpen = False;
X`09    return (-1);
X`09`7D
X`09while (strlen(line)+strlen(server_init_msg)+1 >= (unsigned) server_length
V) `7B
X`09    server_length += 1024;
X`09    if (! (server_init_msg = XtRealloc(server_init_msg, server_length)))
V `7B
X`09`09if (ser_rd_fp) (void) fclose(ser_rd_fp);
X`09`09if (ser_wr_fp) (void) fclose(ser_wr_fp);
X`09`09ser_rd_fp = ser_wr_fp = NULL;
X`09`09ServerOpen = False;
X`09`09perror("realloc failed.");
X`09`09return (-1);
X`09    `7D
X`09`7D
X`09strcat(server_init_msg, line);
X`09strcat(server_init_msg, "\n");
X    `7D while (line`5B3`5D == '-');
X
X    status = atoi(line);
X    ServerOpen = True;
X
X    return status;
X`7D
X#else /* VMS */
Xserver_init(machine)
Xchar`09*machine;
X`7B
X#ifdef AUTHINFO
X/*
X * Authentication code added by Jim Gerland, gerland@ubvms.cc.buffalo.edu
X * and Rich Alberth, acscrja@ubvms.cc.buffalo.edu
X * Feb 1992
X */
X/* authinfo.h: This file should have the following character strings defined
X * as the authinfo user and authinfo pass:
X *    char *authinfo_user = "whatever";
X *    char *authinfo_pass = "whatever";
X */
X    int auth_status;`09/* status values returned by authinfo calls to
X`09`09`09 * get_server() and put_server().
X`09`09`09 */
X    char tmp_str`5B128`5D;`09/* this used as a temporary string for use by
X`09`09`09 * sprintf(). */
X#endif /* AUTHINFO */
X    int`09 status;
X    char line`5B256`5D;
X    char *cp;
X
X    close_server();`09`09`09/* make sure it's closed */
X
X    level = 0;`09`09`09`09/* Reset buffering */
X    inBuf = 0;
X
X#ifdef SERIALHACK
X    cp = strrchr(machine, '/');
X    strcpy(realNNTPhost, cp+1);
X    *cp = '\0';
X    sockt_rd = get_dnet_socket(machine);
X#else
X    cp = strrchr(machine, ':');
X    if (cp) `7B
X`09cp--;
X`09if (cp`5B1`5D == ':') `7B`09`09/* :: means DECnet */
X`09    sockt_rd = get_dnet_socket(machine);
X`09`7D
X#ifdef VMS_TCPIP
X    `7D else `7B
X`09cp = index(machine, '.');`09/* . means IP */
X`09if (cp) `7B
X`09    sockt_rd = get_tcp_socket(machine);
X`09`7D else `7B`09`09`09/* No indication; try DECnet then IP */
X`09    sockt_rd = get_dnet_socket(machine);
X`09    if (sockt_rd < 0)
X`09`09sockt_rd = get_tcp_socket(machine);
X`09`7D
X    `7D
X#else
X    `7D else `7B
X`09sockt_rd = get_dnet_socket(machine);
X    `7D
X#endif /* VMS_TCPIP */
X#endif
X
X    if (sockt_rd < 0)
X`09return (-1);
X
X    /* Now get the server's signon message */
X
X    ServerOpen = True;
X
X#ifdef SERIALHACK
X    sprintf(line, "telnet %s 119", realNNTPhost);
X    put_server(line, True);
X    get_server(line, sizeof(line)); /* Trying ... */
X    get_server(line, sizeof(line)); /* Connected to ... */
X    get_server(line, sizeof(line)); /* Escape character is ... */
X#endif
X
X    if (server_init_msg)
X`09XtFree(server_init_msg);
X    if (! (server_init_msg = XtMalloc(1024))) `7B
X`09perror("malloc failed.");
X`09if (ser_rd_fp) (void) fclose(ser_rd_fp);
X`09if (ser_wr_fp) (void) fclose(ser_wr_fp);
X`09ser_rd_fp = ser_wr_fp = NULL;
X`09ServerOpen = False;
X`09return (-1);
X    `7D
X    *server_init_msg = '\0';
X    server_length = 1024;
X
X    do `7B
X`09if (get_server(line, sizeof(line)) == -1) `7B
X`09    if (ser_rd_fp && feof(ser_rd_fp)) `7B
X`09`09fprintf(stderr, "Unexpected EOF on NNTP server socket -- server is pro
Vbably malfunctioning.\n");
X`09    `7D else `7B
X`09`09perror("reading from server");
X`09    `7D
X`09    if (ser_rd_fp) (void) fclose(ser_rd_fp);
X`09    if (ser_wr_fp) (void) fclose(ser_wr_fp);
X`09    ser_rd_fp = ser_wr_fp = NULL;
X`09    ServerOpen = False;
X`09    return (-1);
X`09`7D
X`09while (strlen(line)+strlen(server_init_msg)+1 >= (unsigned) server_length
V) `7B
X`09    server_length += 1024;
X`09    if (! (server_init_msg = XtRealloc(server_init_msg, server_length)))
V `7B
X`09`09if (ser_rd_fp) (void) fclose(ser_rd_fp);
X`09`09if (ser_wr_fp) (void) fclose(ser_wr_fp);
X`09`09ser_rd_fp = ser_wr_fp = NULL;
X`09`09perror("realloc failed.");
X`09`09ServerOpen = False;
X`09`09return (-1);
X`09    `7D
X`09`7D
X`09strcat(server_init_msg, line);
X`09strcat(server_init_msg, "\n");
X    `7D while (line`5B3`5D == '-');
X
X    status = atoi(line);
X    ServerOpen = True;
X
X#ifdef AUTHINFO
X    sprintf(tmp_str, "AUTHINFO USER %s", authinfo_user);
X    auth_status = put_server(tmp_str, True);
X    if (auth_status == -1) `7B
X`09printf("Error trying to send AUTHINFO USER message to server.\n");
X`09sys$close(&server_fab, 0, 0);
X`09ServerOpen = False;
X`09return -1;
X    `7D
X    /* wait for a 381 "PASS required" message back from the server. */
X
X    (void) get_server(tmp_str, sizeof(tmp_str));
X    if (strncmp(tmp_str, "381", 3) != 0) `7B
X`09printf("Didn't get back 381 when waiting for PASS.\n");
X`09sys$close(&server_fab, 0, 0);
X`09ServerOpen = False;
X`09return -1;
X    `7D
X    /* Send the password to the nntp server. */
X
X    sprintf(tmp_str, "AUTHINFO PASS %s", authinfo_pass);
X    auth_status = put_server(tmp_str, True);
X    if (auth_status == -1) `7B
X`09printf("Error trying to send AUTHINFO PASS message to server.\n");
X`09sys$close(&server_fab, 0, 0);
X`09ServerOpen = False;
X`09return -1;
X    `7D
X    /* wait for 281 'password correct' */
X
X    (void) get_server(tmp_str, sizeof(tmp_str));
X    if (strncmp(tmp_str, "281", 3) != 0) `7B
X`09printf("Didn't receive OK on password from nntp server.\n");
X`09sys$close(&server_fab, 0, 0);
X`09ServerOpen = False;
X`09return -1;
X    `7D
X#endif /* AUTHINFO */
X
X    return status;
X`7D
X#endif /* VMS */
X
X#ifndef VMS
X/*
X * get_tcp_socket -- get us a socket connected to the news server.
X *
X *`09Parameters:`09"machine" is the machine the server is running on.
X *
X *`09Returns:`09Socket connected to the news server if
X *`09`09`09all is ok, else -1 on error.
X *
X *`09Side effects:`09Connects to server.
X *
X *`09Errors:`09`09Printed via perror.
X *
X *  This is a rewrite of the original get_tcp_socket.  This rewrite was
X *  supplied by Casey Leedom <casey@gauss.llnl.gov>
X */
Xstatic int get_tcp_socket1 _ARGUMENTS((struct sockaddr_in *));
X
Xget_tcp_socket(machine)
Xchar`09*machine;
X`7B
X    int s;
X#ifdef h_addr
X    register char **cp;
X#endif /* h_addr */
X
X    struct sockaddr_in sin;
X#ifdef SOLARIS
X    struct servent *getservbyname _ARGUMENTS((char *, char *));
X#else
X    struct servent *getservbyname _ARGUMENTS((const char *, const char *));
X#endif
X    struct servent *sp;
X    struct hostent *gethostbyname _ARGUMENTS((const char *)), *hp;
X
X    (void) memset((char *) &sin, 0, sizeof(sin));
X    if ((sp = getservbyname("nntp", "tcp")) ==  NULL) `7B
X`09(void) fprintf(stderr, "nntp/tcp: Unknown service.\n");
X`09return (-1);
X    `7D
X
X    sin.sin_port = sp->s_port;
X    if ((sin.sin_addr.s_addr = inet_addr(machine)) != -1) `7B
X`09sin.sin_family = AF_INET;
X`09return(get_tcp_socket1(&sin));
X    `7D else `7B
X`09if ((hp = gethostbyname(machine)) == NULL) `7B
X`09    (void) fprintf(stderr, "%s: Unknown host.\n", machine);
X`09    return (-1);
X`09`7D
X`09sin.sin_family = hp->h_addrtype;
X    `7D
X
X    /*
X     * The following is kinda gross.  The name server under 4.3
X     * returns a list of addresses, each of which should be tried
X     * in turn if the previous one fails.  However, 4.2 hostent
X     * structure doesn't have this list of addresses.
X     * Under 4.3, h_addr is a #define to h_addr_list`5B0`5D.
X     * We use this to figure out whether to include the NS specific
X     * code...
X     */
X
X#if defined(h_addr)
X
X    /* attempt multiple addresses */
X
X    for (s = 0, cp = hp->h_addr_list; cp && *cp; cp++) `7B
X`09if (s < 0)
X`09    (void) fprintf(stderr,"trying alternate address for %s\n", machine);
X`09(void) memcpy((char *) &sin.sin_addr, *cp, hp->h_length);
X`09s = get_tcp_socket1(&sin);
X`09if (s >= 0)
X`09    return(s);
X    `7D
X    (void) fprintf(stderr, "giving up...\n");
X    return (-1);
X
X#else`09/* 4.2BSD hostent structure */
X
X    (void) memcpy((char *) &sin.sin_addr, hp->h_addr, hp->h_length);
X    return(get_tcp_socket1(&sin));
X
X#endif
X`7D
X
Xstatic int
Xget_tcp_socket1(sp)
Xstruct sockaddr_in *sp;
X`7B
X    int s;
X
X    s = socket(sp->sin_family, SOCK_STREAM, 0);
X    if (s < 0) `7B
X`09(void) perror("socket");
X`09return (-1);
X    `7D
X    if (connect(s, (struct sockaddr *)sp, sizeof (*sp)) < 0) `7B
X`09(void) perror("connect");
X`09(void) close(s);
X`09return(-1);
X    `7D
X    return(s);
X`7D
X#else /* VMS */
X#ifdef VMS_TCPIP
X#ifndef CMU_TCP
X/*
X * get_tcp_socket -- get us a socket connected to the news server.
X *
X *`09Parameters:`09"machine" is the machine the server is running on.
X *
X *`09Returns:`09Socket connected to the news server if
X *`09`09`09all is ok, else -1 on error.
X *
X *`09Side effects:`09Connects to server.
X *
X *`09Errors:`09`09Printed via perror.
X */
X
Xget_tcp_socket(machine)
Xchar`09*machine;
X`7B
X    int`09s;
X#ifdef h_addr
X    int x = 0;
X    register char **cp;
X#endif /* h_addr */
X
X#ifdef FUSION
X#define gethostbyname ghbyname
X#endif
X    struct`09sockaddr_in sin;
X    struct`09servent *getservbyname(), *sp;
X    struct`09hostent *gethostbyname(), *hp;
X
X    if ((hp = gethostbyname(machine)) == NULL) `7B
X`09(void) fprintf(stderr, "%s: Unknown host.\n", machine);
X`09return (-1);
X    `7D
X
X    (void) memset((char *) &sin, 0, sizeof(sin));
X    sin.sin_family = hp->h_addrtype;
X    sin.sin_port = htons(NNTP_PORT_NUMBER);
X
X    /*
X     * The following is kinda gross.  The name server under 4.3
X     * returns a list of addresses, each of which should be tried
X     * in turn if the previous one fails.  However, 4.2 hostent
X     * structure doesn't have this list of addresses.
X     * Under 4.3, h_addr is a #define to h_addr_list`5B0`5D.
X     * We use this to figure out whether to include the NS specific
X     * code...
X     */
X
X#if defined(h_addr)
X    /* get a socket and initiate connection -- use multiple addresses */
X
X    for (cp = hp->h_addr_list; cp && *cp; cp++) `7B
X`09s = socket(hp->h_addrtype, SOCK_STREAM, 0);
X`09if (s < 0) `7B
X`09    (void) perror("socket");
X`09    return (-1);
X`09`7D
X`09(void) memcpy((char *) &sin.sin_addr, *cp, hp->h_length);
X`09`09
X`09if (x < 0) `7B
X`09    (void) fprintf(stderr, "trying %s\n", machine);
X`09`7D
X`09x = connect(s, (struct sockaddr *)&sin, sizeof (sin));
X`09if (x == 0)
X`09    break;
X`09(void) fprintf(stderr, "connection to %s: ", machine);
X`09(void) perror("");
X`09(void) close(s);
X    `7D
X    if (x < 0) `7B
X`09(void) fprintf(stderr, "giving up...\n");
X`09return (-1);
X    `7D
X#else`09/* no name server */
X
X    if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) `7B /* Get the socket */
X`09(void) perror("socket");
X`09return (-1);
X    `7D
X
X    /* And then connect */
X
X    (void) memcpy((char *) &sin.sin_addr, hp->h_addr, hp->h_length);
X    if (connect(s, (struct sockaddr *) &sin, sizeof(sin)) < 0) `7B
X`09(void) perror("connect");
X`09(void) close(s);
X`09return (-1);
X    `7D
X#endif
X    VMSTcpIp = True;
X    return (s);
X`7D
X#else /* CMU_TCP */
X/*
X * get_tcp_socket -- get us a CMU TCP/IP socket connected to the news server
X *
X *`09Paremeters:`09"machine" is the machine the server is running on.
X *
X *`09Returns:`09Socket connected to the news server if
X *`09`09`09all is ok, else -1 on error.
X *
X *`09Side effects:`09Connects to server.
X *
X *`09Errors:`09`09Printed vua perror.
X */
Xget_tcp_socket (machine)
Xchar *machine;
X`7B
X    int stat;
X
X    /* first, open a channel to the IP0 device */
X    if (((stat = SYS$ASSIGN(&cmu_ip, &cmu_chan, 0, 0)) & 1) != 1)
X`09return (-1);
X
X    /* now connect to the server */
X
X    stat = SYS$QIOW (0, cmu_chan, TCP$OPEN, &iosb, 0, 0, machine,
X`09`09     NNTP_PORT_NUMBER, 0, 1, 0, 0);
X    if ((stat & 1) != 1) return (-1);
X    if (iosb.stat == SS$_ABORT) return (-1);
X    VMSTcpIp = True;
X    ServerOpen = True;
X    return (1);
X`7D
X#endif /* CMU_TCP */
X#endif /* VMS_TCPIP */
X#endif /* VMS */
X
X#if defined(DECNET) `7C`7C defined(VMS)
X/*
X * get_dnet_socket -- get us a socket connected to the news server.
X *
X *`09Parameters:`09"machine" is the machine the server is running on.
X *
X *`09Returns:`09Socket connected to the news server if
X *`09`09`09all is ok, else -1 on error.
X *
X *`09Side effects:`09Connects to server.
X *
X *`09Errors:`09`09Printed via nerror.
X */
X
Xget_dnet_socket(machine)
Xchar`09*machine;
X`7B
X#ifdef VMS
X    static char connect`5B128`5D;
X    char *ptr;
X    int`09s,colon;
X    int status;
X
X#ifdef SERIALHACK
X    strcpy(connect, machine);
X#else
X    ptr = strrchr(machine, ':');
X    if (ptr) `7B
X`09colon = ptr - machine - 1;
X    `7D else `7B
X`09colon = strlen(machine);
X    `7D
X    (void) strncpy(connect, machine, colon);
X    (void) strcpy(&connect`5Bcolon`5D, NNTPobject);
X#endif
X`09
X    memset((char *) &server_fab, 0, sizeof(server_fab));
X    memset((char *) &server_rab, 0, sizeof(server_rab));
X
X    server_fab = cc$rms_fab;
X    server_rab = cc$rms_rab;
X
X    server_fab.fab$v_put = 1;
X    server_fab.fab$v_get = 1;
X    server_fab.fab$l_fna = connect;
X    server_fab.fab$b_fns = strlen(connect);
X    status = sys$open(&server_fab, 0, 0);
X    if ((status & 1) != 1) `7B
X`09ehVMSerror("NNTP Server Open error:", server_fab.fab$l_sts,
X`09`09   server_fab.fab$l_stv);
X`09sys$close(&server_fab, 0, 0);
X`09ServerOpen = False;
X`09return (-1);
X    `7D
X    server_rab = cc$rms_rab;
X    server_rab.rab$l_fab = &server_fab;
X    status = sys$connect(&server_rab, 0, 0);
X    if ((status & 1) != 1) `7B
X`09ehVMSerror("NNTP Server Open error:", server_rab.rab$l_sts,
X`09`09   server_rab.rab$l_stv);
X`09sys$close(&server_fab, 0, 0);
X`09ServerOpen = False;
X`09return (-1);
X    `7D
X
X    s = 0;
X    VMSTcpIp = False;
X
X#else /* Not VMS */
X
X    int`09s, area, node;
X    struct sockaddr_dn sdn;
X    struct nodeent *getnodebyname(), *np;
X
X    (void) memset((char *) &sdn, 0, sizeof(sdn));
X
X    switch (s = sscanf( machine, "%d%*`5B.`5D%d", &area, &node )) `7B
X    `09case 1:`20
X`09    node = area;
X`09    area = 0;
X`09case 2:`20
X`09    node += area*1024;
X`09    sdn.sdn_add.a_len = 2;
X`09    sdn.sdn_family = AF_DECnet;
X`09    sdn.sdn_add.a_addr`5B0`5D = node % 256;
X`09    sdn.sdn_add.a_addr`5B1`5D = node / 256;
X`09    break;
X`09default:
X`09    if ((np = getnodebyname(machine)) == NULL) `7B
X`09`09(void) fprintf(stderr,`20
X`09`09`09`09    "%s: Unknown host.\n", machine);
X`09`09return (-1);
X`09    `7D else `7B
X`09`09(void) memcpy((char *) sdn.sdn_add.a_addr,`20
X`09`09`09`09`09  np->n_addr,`20
X`09`09`09`09`09  np->n_length);
X`09`09sdn.sdn_add.a_len = np->n_length;
X`09`09sdn.sdn_family = np->n_addrtype;
X`09    `7D
X`09    break;
X    `7D
X    sdn.sdn_objnum = 0;
X    sdn.sdn_flags = 0;
X    sdn.sdn_objnamel = strlen("NNTP");
X    (void) memcpy(&sdn.sdn_objname`5B0`5D, "NNTP", sdn.sdn_objnamel);
X
X#ifdef ANU_NEWS_SERVER
X    if ((s = socket(AF_DECnet, SOCK_SEQPACKET, 0)) < 0) `7B
X#else
X    if ((s = socket(AF_DECnet, SOCK_STREAM, 0)) < 0) `7B
X#endif
X    `09nerror("socket");
X    `09return (-1);
X    `7D
X
X    /* And then connect */
X
X    if (connect(s, (struct sockaddr *) &sdn, sizeof(sdn)) < 0) `7B
X    `09nerror("connect");
X    `09close(s);
X    `09return (-1);
X    `7D
X#endif /* VMS */
X
X    return (s);
X`7D
X#endif /* DECNET or VMS */
X
X/*
X * handle_server_response
X *
X *`09Print some informative messages based on the server's initial
X *`09response code.  This is here so inews, rn, etc. can share
X *`09the code.
X *
X *`09Parameters:`09"response" is the response code which the
X *`09`09`09server sent us, presumably from "server_init",
X *`09`09`09above.
X *`09`09`09"server" is the news server we got the
X *`09`09`09response code from.
X *
X *`09Returns:`09-1 if the error is fatal (and we should exit).
X *`09`09`090 otherwise.
X *
X *`09Side effects:`09None.
X */
Xint
Xhandle_server_response(response, server)
Xint`09response;
Xchar`09*server;
X`7B
X    char line`5B256`5D;
X
X    switch (response) `7B
X`09case OK_NOPOST:`09`09/* fall through */
X`09    mesgPane(XRN_INFO,`20
X`09    "NOTE: This machine does not have permission to post articles.");
X`09    mesgPane(XRN_INFO`7CXRN_APPEND,
X`09    "      Please don't waste your time trying.\n\n");
X
X`09case OK_CANPOST:
X#ifdef NOISY_OK
X`09    mesgPane(XRN_INFO,
X`09    "Connected to %s news server. Posting is permitted.\n",
X`09`09server);
X#endif
X`09    if (put_server("mode reader", True) == -1) `7B
X`09`09mesgPane(XRN_SERIOUS,
X`09`09"Error trying to send MODE READER message to server.");
X`09`09return -1;
X`09    `7D
X   `20
X`09    if (get_server(line, sizeof(line)) == -1) `7B
X`09`09mesgPane(XRN_SERIOUS,
X`09`09"Error trying to read MODE READER response from server.");
X`09`09return -1;
X`09    `7D
X   `20
X`09    return (0);
X
X`09case ERR_GOODBYE:
X`09    mesgPane(XRN_SERIOUS,
X`09    "The news service is currently not available from %s:\n%s\n\n",
X`09`09server, server_init_msg);
X`09    return(-1);
X
X`09case ERR_ACCESS:
X`09    mesgPane(XRN_SERIOUS,
X`09    "This machine does not have permission to use the %s news server:\n%s
V\n",
X`09`09server, server_init_msg);
X`09    return (-1);
X
X`09default:
X`09    mesgPane(XRN_SERIOUS,
X`09`09"Unexpected response code from %s news server:%s\n\n",
X`09`09`09server, server_init_msg);
X`09    return (-1);
X    `7D
X`09/*NOTREACHED*/
X`7D
X
X/*
X * put_server -- send a line of text to the server, terminating it
X * with CR and LF, as per ARPA standard.
X *
X *`09Parameters:`09"string" is the string to be sent to the
X *`09`09`09server.
X *`09`09`09"flush" is true if should flush the output
X *`09`09`09after send.
X *
X *`09Returns:`09Status (-1 for failure).
X *
X *`09Side effects:`09Talks to the server.
X *
X */
X
X#ifndef VMS
Xint
Xput_server(string, flushit)
Xchar *string;
XBoolean flushit;
X`7B
X    if (!ServerOpen)
X`09start_server(NIL(char));
X#ifdef DEBUG
X    (void) fprintf(stdout, ">>> %s\n", string);
X#endif
X
X    if (fprintf(ser_wr_fp, "%s\r\n", string) == EOF) `7B
X`09return -1;
X    `7D
X#ifndef ANU_NEWS_SERVER
X    if (flushit) `7B
X#endif
X`09if (fflush(ser_wr_fp) == EOF) `7B
X`09    return -1;
X`09`7D
X#ifndef ANU_NEWS_SERVER
X    `7D
X#endif
X#ifdef NNTPVIATIP
X`09`7B
X`09    char line`5B256`5D;
X`09    get_server(line, sizeof(line));
X`09`7D
X#endif
X    return 0;
X`7D
X#else /* VMS */
Xint
Xput_server(string, flushit)
Xchar *string;
XBoolean flushit;
X`7B
X    int status;
X    static char *sendString;`09`09/* Including cr/lf at end */
X    static int sendSize = 0;
X    int s;
X#ifdef SERIALHACK
X    char echobuf`5B128`5D;
X#endif
X
X    if (!ServerOpen)
X`09start_server(NIL(char));
X#ifdef DEBUG
X    (void) fprintf(stdout, ">>> %s\n", string);
X#endif
X
X    if (sendSize == 0) `7B
X`09sendSize = 128;`09`09`09/* Prob. adequate - 80 should be max */
X`09sendString = XtMalloc(128);
X    `7D
X    s = strlen(string);
X    if (s + 5 > sendSize) `7B
X`09sendSize = s + 5;
X`09sendString = XtRealloc(sendString, sendSize);
X    `7D
X#ifdef SERIALHACK
X    sprintf(sendString, "%s\r", string);
X#else
X    sprintf(sendString, "%s\r\n", string);
X#endif
X#ifdef VMS_TCPIP
X    if (VMSTcpIp) `7B
X#ifndef CMU_TCP
X`09if (send(sockt_rd, sendString, s + 2, 0) == -1) `7B
X`09    perror("Server write failed");
X`09    return -1;
X`09`7D
X#else /* CMU_TCP */
X`09status = SYS$QIOW (0, cmu_chan, TCP$SEND, &iosb, 0, 0,
X`09`09`09   sendString, s+2, 0, 0, 0, 0);
X#endif /* CMU_TCP */
X    `7D else `7B`09`09/* DECnet */
X`09server_rab.rab$l_rbf = sendString;
X#ifdef SERIALHACK
X`09server_rab.rab$w_rsz = s + 1;
X#else
X`09server_rab.rab$w_rsz = s + 2;
X#endif
X`09status = sys$put(&server_rab, 0, 0);
X`09if ((status & 1) != 1) `7B
X`09    if (!ignoreErrors) `7B
X`09`09ehVMSerror("NNTP Server Write error:", server_rab.rab$l_sts,
X`09`09`09   server_rab.rab$l_stv);
X`09    `7D
X`09    sys$close(&server_fab, 0, 0);
X`09    ServerOpen = False;
X`09    return (-1);
X`09`7D
X#ifndef SERIALHACK
X`09if (flushit) `7B
X#endif
X`09    status = sys$flush(&server_rab, 0, 0);
X`09    if ((status & 1) != 1) `7B
X`09`09if (!ignoreErrors) `7B
X`09`09    ehVMSerror("NNTP Server Write error:", server_rab.rab$l_sts,
X`09`09`09   server_rab.rab$l_stv);
X`09`09`7D
X`09`09sys$close(&server_fab, 0, 0);
X`09`09ServerOpen = False;
X`09`09return (-1);
X`09    `7D
X#ifndef SERIALHACK
X`09`7D
X#endif
X    `7D
X#else /* VMS_TCPIP */
X    server_rab.rab$l_rbf = sendString;
X#ifdef SERIALHACK
X`09server_rab.rab$w_rsz = s + 1;
X#else
X`09server_rab.rab$w_rsz = s + 2;
X#endif
X    status = sys$put(&server_rab, 0, 0);
X    if ((status & 1) != 1) `7B
X`09if (!ignoreErrors) `7B
X`09    ehVMSerror("NNTP Server Write error:", server_rab.rab$l_sts,
X`09`09`09   server_rab.rab$l_stv);
X`09`7D
X`09sys$close(&server_fab, 0, 0);
X`09ServerOpen = False;
X`09return (-1);
X    `7D
X#ifndef SERIALHACK
X    if (flushit) `7B
X#endif
X`09status = sys$flush(&server_rab, 0, 0);
X`09if ((status & 1) != 1) `7B
X`09    if (!ignoreErrors) `7B
X`09`09ehVMSerror("NNTP Server Write error:", server_rab.rab$l_sts,
X`09`09`09   server_rab.rab$l_stv);
X`09    `7D
X`09    sys$close(&server_fab, 0, 0);
X`09    ServerOpen = False;
X`09    return (-1);
X`09`7D
X#ifndef SERIALHACK
X    `7D
X#endif
X#endif /* VMS_TCPIP */
X#ifdef SERIALHACK
X    get_server(echobuf, sizeof(echobuf));
X#endif
X    return 0;
X`7D
X#endif /* VMS */
X/*
X * get_server -- get a line of text from the server.  Strips
X * CR's and LF's.
X *
X *`09Parameters:`09"string" has the buffer space for the
X *`09`09`09line received.
X *`09`09`09"size" is the size of the buffer.
X *
X *`09Returns:`09-1 on error, 0 otherwise.
X *
X *`09Side effects:`09Talks to server, changes contents of "string".
X */
X
X#ifndef VMS
Xget_server(string, size)
Xchar`09*string;
Xint`09size;
X`7B
X    register char *cp;
X
X    if (!ServerOpen)
X`09start_server(NIL(char));
X
X    if (fgets(string, size, ser_rd_fp) == NULL)
X`09return (-1);
X#ifdef NNTPVIATIP
X    for (cp = string; cp < &string`5Bsize`5D; cp++) `7B
X`09*cp = *cp & 0x7F;
X`09if (*cp == '\0') `7B
X`09    break;
X`09`7D
X    `7D
X#endif
X    if ((cp = index(string, '\r')) != NULL)
X`09*cp = '\0';
X    else if ((cp = index(string, '\n')) != NULL)
X`09*cp = '\0';
X
X#ifdef DEBUG
X    (void) fprintf(stdout, "<<< %s\n", string);
X#endif
X
X    return (0);
X`7D
X#else /* VMS */
Xget_server(string, size)
Xchar`09*string;
Xint`09size;
X`7B
X    register char *cp;
X    static char netBuf`5B8193`5D;
X    static char *bufPtr;
X    int ret;
X    int status;
X#ifdef SERIALHACK
X#include <rmsdef.h>
X#endif
X
X    if (!ServerOpen) `7B
X`09start_server(NIL(char));
X`09level = 0;
X`09inBuf = 0;
X    `7D
X
X    if (level == 0)
X`09*string = '\0';
X    if (inBuf <= 0) `7B
X#ifdef VMS_TCPIP
X`09if (!VMSTcpIp) `7B
X`09    server_rab.rab$l_ubf = netBuf;
X`09    server_rab.rab$w_usz = sizeof(netBuf) - 1;
X`09    status = sys$get(&server_rab, 0, 0);
X`09    if ((status & 1) != 1) `7B
X`09`09if (!ignoreErrors) `7B
X`09`09    ehVMSerror("NNTP Server Read error:", server_rab.rab$l_sts,
X`09`09`09   server_rab.rab$l_stv);
X`09`09`7D
X`09`09sys$close(&server_fab, 0, 0);
X`09`09ServerOpen = False;
X`09`09return (-1);
X`09    `7D
X`09    inBuf = server_rab.rab$w_rsz;
X`09`7D else `7B
X#ifndef CMU_TCP
X`09    if ((inBuf = recv(sockt_rd, netBuf, 1024, 0)) <= 0)`20
X`09`09return (-1);
X#else
X`09    status = SYS$QIOW (0, cmu_chan, TCP$READ, &iosb, 0, 0,
X`09`09`09       &netBuf, 1024, 0, 0, 0, 0);
X`09    if ((status & 1) != 1) return (-1);
X`09    if (iosb.stat == SS$_ABORT) return (-1);
X`09    inBuf = iosb.count;
X#endif`09/* CMU_TCP */
X`09`7D
X#else /* VMS_TCPIP */
X`09
X`09server_rab.rab$l_ubf = netBuf;
X`09server_rab.rab$w_usz = sizeof(netBuf) - 1;
X`09status = sys$get(&server_rab, 0, 0);
X#ifdef SERIALHACK
X`09if (status == RMS$_TNS) `7B
X`09    status = status `7C 1;
X`09`7D
X#endif
X`09if ((status & 1) != 1) `7B
X`09    if (!ignoreErrors) `7B
X`09`09ehVMSerror("NNTP Server Read error:", server_rab.rab$l_sts,
X`09`09   server_rab.rab$l_stv);
X`09    `7D
X`09    sys$close(&server_fab, 0, 0);
X`09    ServerOpen = False;
X`09    return (-1);
X`09`7D
X`09inBuf = server_rab.rab$w_rsz;
X
X#endif /* VMS_TCPIP */
X
X#ifdef SERIALHACK
X`09if (status != (RMS$_TNS `7C 1))
X`09    netBuf`5BinBuf++`5D = '\r';
X#endif
X`09netBuf`5BinBuf`5D = '\0';
X`09bufPtr = netBuf;
X`09if (*bufPtr == '\n')
X`09    bufPtr++;
X    `7D
X    if ((cp = index(bufPtr, '\r')) != NULL) `7B
X`09*cp = '\0';
X`09strcat(string, bufPtr);
X`09inBuf = inBuf - (cp - bufPtr) - 1;
X`09bufPtr = ++cp;
X`09if (*bufPtr == '\n') `7B
X`09    bufPtr++;
X`09    inBuf--;
X`09`7D
X    `7D else `7B
X`09if ((cp = index(bufPtr, '\n')) != NULL) `7B
X`09    *cp = '\0';
X`09    strcat(string, bufPtr);
X`09    inBuf = inBuf - (cp - bufPtr) - 1;
X`09    bufPtr = ++cp;
X`09    if (*bufPtr == '\n') `7B
X`09`09bufPtr++;
X`09`09inBuf--;
X`09    `7D
X`09`7D else `7B
X`09    level++;
X`09    inBuf = 0;
X`09    strcat(string, bufPtr);
X`09    ret = get_server(string, size);
X`09    level--;
X`09    return ret;
X`09`7D
X    `7D
X
X#ifdef DEBUG
X    (void) fprintf(stdout, "<<< %s\n", string);
X#endif
X    return (0);
X`7D
X#endif /* VMS */
X
X/*
X * close_server -- close the connection to the server, after sending
X *`09`09the "quit" command.
X *
X *`09Parameters:`09None.
X *
X *`09Returns:`09Nothing.
X *
X *`09Side effects:`09Closes the connection with the server.
X *`09`09`09You can't use "put_server" or "get_server"
X *`09`09`09after this routine is called.
X */
X
Xvoid
Xclose_server()
X`7B
X    char`09ser_line`5B256`5D;
X
X    if (!VMSTcpIp) `7B
X`09if (!ServerOpen)
X`09    return;
X    `7D else `7B
X`09if (!ServerOpen `7C`7C sockt_rd < 0)
X`09    return;
X    `7D
X
X    ignoreErrors = True;
X    if (put_server("QUIT", True) != -1) `7B
X#ifndef SERIALHACK
X`09while (ServerOpen) `7B
X`09    if (get_server(ser_line, sizeof(ser_line)) < 0)
X`09`09ServerOpen = False;
X`09`7D
X#else
X`09(void) get_server(ser_line, sizeof(ser_line));
X`09(void) get_server(ser_line, sizeof(ser_line));
X#endif
X    `7D
X    ignoreErrors = False;
X
X#ifndef VMS
X    if (ser_wr_fp) (void) fclose(ser_wr_fp);
X    ser_wr_fp = NULL;
X    if (ser_rd_fp) (void) fclose(ser_rd_fp);
X    ser_rd_fp = NULL;
X    if (sockt_rd > 0) `7B
X`09(void) shutdown(sockt_rd, 2);
X`09(void) close(sockt_rd);
X`09sockt_rd = -1;
X    `7D
X    if (sockt_wr > 0) `7B
X`09(void) shutdown(sockt_wr, 2);
X`09(void) close(sockt_wr);
X`09sockt_wr = -1;
X    `7D
X#else /* VMS */
X
X    if (VMSTcpIp) `7B
X`09if (ser_wr_fp) (void) fclose(ser_wr_fp);
X`09ser_wr_fp = NULL;
X`09if (ser_rd_fp) (void) fclose(ser_rd_fp);
X`09ser_rd_fp = NULL;
X    `7D else `7B
X`09sys$close(&server_fab, 0, 0);
X    `7D
X
X#ifdef VMS_TCPIP
X#ifndef CMU_TCP
X    if (VMSTcpIp) `7B
X`09(void) shutdown(sockt_rd, 2);
X`09(void) close(sockt_rd);
X`09(void) close(sockt_wr);
X    `7D
X#if defined(MULTINET) `7C`7C defined(TCPWARE) `7C`7C defined(WOLLONGONG)
X    sys$dassgn(sockt_rd);
X    sys$dassgn(sockt_wr);
X    sockt_rd = -1;
X#endif /* MULTINET etc */
X#else  /* CMU_TCP */
X    status = SYS$QIOW (0, cmu_chan, TCP$CLOSE, 0, 0, 0, 2, 0, 0, 0, 0, 0);
X#endif /* CMU_TCP */
X#endif /* VMS_TCPIP */
X#endif /* VMS */
X    ServerOpen = False;
X`7D
X
X#ifdef VMS
Xchar *
XlocalHostName()
X`7B
X    static char *ptr = NULL;
X    static char host_name`5B128`5D;
X#ifdef VMS_TCPIP
X    extern int gethostname _ARGUMENTS((char *, int));
X#endif
X
X    if (ptr == NULL) `7B
X`09ptr = getenv("SYS$CLUSTER_NODE");
X    `7D
X    if (ptr == NULL) `7B
X`09ptr = getenv("SYS$NODE");
X    `7D
X    if (ptr == NULL) `7B
X#ifdef VMS_TCPIP
X`09if (gethostname(host_name, sizeof(host_name))) `7B
X`09    strcpy(host_name, "unavailable");
X`09`7D
X#else
X`09strcpy(host_name, "unavailable");
X#endif
X`09ptr = host_name;
X    `7D
X    return ptr;
X`7D
X#endif
$ CALL UNPACK CLIENTLIB.C;173 1299891712
$ create 'f'
X#ifndef CODES_H
X#define CODES_H
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/codes.h,v 1.4 1993/0
V1/11 02:14:32 ricks Exp $
X */
X
X/*
X * Response Codes for the NNTP Server
X *
X * Copyright (c) 1988-1993, The Regents of the University of California.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * Response codes for NNTP server
X *
X * @(#)response_codes.h`091.6`09(Berkeley) 2/6/86
X *
X * First digit:
X *
X *`091xx`09Informative message
X *`092xx`09Command ok
X *`093xx`09Command ok so far, continue
X *`094xx`09Command was correct, but couldn't be performed
X *`09`09for some specified reason.
X *`095xx`09Command unimplemented, incorrect, or a
X *`09`09program error has occured.
X *
X * Second digit:
X *
X *`09x0x`09Connection, setup, miscellaneous
X *`09x1x`09Newsgroup selection
X *`09x2x`09Article selection
X *`09x3x`09Distribution
X *`09x4x`09Posting
X */
X
X#define`09CHAR_INF`09'1'
X#define`09CHAR_OK`09`09'2'
X#define`09CHAR_CONT`09'3'
X#define`09CHAR_ERR`09'4'
X#define`09CHAR_FATAL`09'5'
X
X#define`09INF_HELP`09100`09/* Help text on way */
X#define`09INF_DEBUG`09199`09/* Debug output */
X
X#define`09OK_CANPOST`09200`09/* Hello; you can post */
X#define`09OK_NOPOST`09201`09/* Hello; you can't post */
X#define`09OK_SLAVE`09202`09/* Slave status noted */
X#define`09OK_GOODBYE`09205`09/* Closing connection */
X#define`09OK_GROUP`09211`09/* Group selected */
X#define`09OK_GROUPS`09215`09/* Newsgroups follow */
X#define`09OK_ARTICLE`09220`09/* Article (head & body) follows */
X#define`09OK_HEAD`09`09221`09/* Head follows */
X#define`09OK_BODY`09`09222`09/* Body follows */
X#define`09OK_NOTEXT`09223`09/* No text sent -- stat, next, last */
X#define`09OK_NEWNEWS`09230`09/* New articles by message-id follow */
X#define`09OK_NEWGROUPS`09231`09/* New newsgroups follow */
X#define`09OK_XFERED`09235`09/* Article transferred successfully */
X#define`09OK_POSTED`09240`09/* Article posted successfully */
X
X#define CONT_XFER`09335`09/* Continue to send article */
X#define`09CONT_POST`09340`09/* Continue to post article */
X
X#define`09ERR_GOODBYE`09400`09/* Have to hang up for some reason */
X#define`09ERR_NOGROUP`09411`09/* No such newsgroup */
X#define`09ERR_NCING`09412`09/* Not currently in newsgroup */
X#define`09ERR_NOCRNT`09420`09/* No current article selected */
X#define`09ERR_NONEXT`09421`09/* No next article in this group */
X#define`09ERR_NOPREV`09422`09/* No previous article in this group */
X#define`09ERR_NOARTIG`09423`09/* No such article in this group */
X#define ERR_NOART`09430`09/* No such article at all */
X#define ERR_GOTIT`09435`09/* Already got that article, don't send */
X#define ERR_XFERFAIL`09436`09/* Transfer failed */
X#define`09ERR_XFERRJCT`09437`09/* Article rejected, don't resend */
X#define`09ERR_NOPOST`09440`09/* Posting not allowed */
X#define`09ERR_POSTFAIL`09441`09/* Posting failed */
X
X#define`09ERR_COMMAND`09500`09/* Command not recognized */
X#define`09ERR_CMDSYN`09501`09/* Command syntax error */
X#define`09ERR_ACCESS`09502`09/* Access to server denied */
X#define ERR_FAULT`09503`09/* Program fault, command not performed */
X
X#endif
$ CALL UNPACK CODES.H;2 440272868
$ create 'f'
X#if !defined(lint) && !defined(SABER)
Xstatic char XRNrcsid`5B`5D = "$Header: /net/objy27/wrld/mnt11/ricks/src/mast
Ver/xrn/compose.c,v 1.9 1993/02/04 18:22:12 ricks Exp $";
X#endif
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * compose.c: routines for composing messages and articles
X */
X
X#include "copyright.h"
X
X#include <ctype.h>
X#include <stdio.h>
X#include <time.h>
X#include "config.h"
X#include "utils.h"
X
X#ifndef VMS
X#ifdef __STDC__
X#include <unistd.h>
X#endif
X#else /* VMS */
X#include <unixio.h>
Xextern char *  localHostName();
X#ifdef __STDC__
X#define CADDR_T
X#include <unixio.h>
X#include <socket.h>
X#endif
X#endif /* VMS */
X
X#if defined(__hpux)
X#include <unistd.h>
X#endif
X
X#if defined(sun) && defined(sparc) && !defined(SOLARIS)
X#include <vfork.h>
X/*
X * Unfortunately, it's necessary to declare fclose on the Sun because
X * stdio.h in the standard Sun C library doesn't, and we need to
X * assign fclose to a function pointer variable below.
X */
Xextern int fclose _ARGUMENTS((FILE *));
X#else /* sun & ! solaris */
X#if !defined(SVR4_0) && !defined(hpux)
Xextern int vfork();
X#else /* SVR4 */
Xextern pid_t vfork(void);
X#endif /* SVR4 */
X#endif /* sun & !solaris */
X
X#ifndef i386
Xextern int getdtablesize();
X#endif
X
X#ifndef VMS
X#include <sys/wait.h>
X#include <sys/file.h>
X#include <sys/stat.h>
X#include <pwd.h>
X#else /* VMS */
X#include <stat.h>
X#include <file.h>
X#define index strchr
X#define rindex strrchr
Xextern char* getenv();
Xextern void unlink();
Xextern int sys$putmsg();
Xextern int MAIL$SEND_BEGIN();
Xextern int MAIL$SEND_ADD_ATTRIBUTE();
Xextern int MAIL$SEND_ADD_ADDRESS();
Xextern int MAIL$SEND_ADD_BODYPART();
Xextern int MAIL$SEND_MESSAGE();
Xextern int MAIL$SEND_END();
Xextern int MAIL$SEND_ABORT();
Xextern int lib$spawn();
Xextern void addTimeOut();
Xextern void removeTimeOut();
X#endif
X
X#include <signal.h>
X#ifdef RESOLVER
X#ifndef VMS
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <netdb.h>
X#endif`09/* VMS */
X#endif`09/* RESOLVER */
X
X#if defined(aiws) `7C`7C defined(DGUX)
Xstruct passwd *getpwuid();
Xstruct passwd *getpwnam();
X#endif
X
X#ifndef VMS
X#include <X11/StringDefs.h>
X#include <X11/Intrinsic.h>
X#include <X11/Shell.h>
X#else
X#include <types.h>
X#include <decw$include/StringDefs.h>
X#include <decw$include/Intrinsic.h>
X#include <decw$include/Shell.h>
X#endif
X#ifdef MOTIF
X#include <Xm/PanedW.h>
X#include <Xm/TextP.h>
X#include <Xm/RowColumn.h>
X#include <Xm/PushB.h>
X#include <Xm/Label.h>
X#include <Xm/Frame.h>
X#if (XmVERSION == 1) && (XmREVISION == 0)
X#define MOTIF_V10
X#endif
Xextern void PaneSetMinMax _ARGUMENTS((Widget, int, int));
X#else
X#ifndef DwtNmenuExtendLastRow
X#define DwtNmenuExtendLastRow "menuExtendLastRow"
X#endif
X#ifndef VMS
X#include <X11/DECwDwtWidgetProg.h>
X#include "Pane.h"
X#else
X#include <decw$include/DECwDwtWidgetProg.h>
X#include "Pane.h"
X#endif
X#endif
X
Xextern char *getinfofromfile _ARGUMENTS((char * ));
X#include "avl.h"
X#include "xthelper.h"
X#include "resources.h"
X#include "dialogs.h"
X#include "news.h"
X#include "server.h"
X#include "mesg.h"
X#include "internals.h"
X#include "xrn.h"
X#include "xmisc.h"
X#include "error_hnds.h"
X#include "butdefs.h"
X
X#ifndef R_OK
X#define F_OK            0       /* does file exist */
X#define X_OK            1       /* is it executable by caller */
X#define W_OK            2       /* writable by caller */
X#define R_OK            4       /* readable by caller */
X#endif /* R_OK */
X
X/* entire pane */
XWidget ComposeTopLevel = (Widget) 0;
XBoolean ComposeActive = False;
X/* text window */
XWidget ComposeText = (Widget) 0;
X/* buttons */
Xstatic Widget AbortButton;
Xstatic Widget SendButton;
Xstatic Widget SaveButton;
Xstatic Widget IncludeFileButton;
Xstatic Widget IncludeArticleButton;
Xstatic Widget IncludeCurrentButton;
Xstatic Widget WrapTextButton;
Xstatic Widget Rot13Button;
Xstatic int InsertionPoint = 0;
Xstatic int EditorPosition = 0;
XWidget HeaderText = (Widget) 0;
X#ifdef MOTIF
Xstatic Widget headerFrame = (Widget) 0;
Xstatic Widget textFrame = (Widget) 0;
X#endif
X
Xstatic char *CompositionString = NIL(char);
Xstatic char *HeaderString = NIL(char);
Xstatic char *TempString = NIL(char);
Xstatic int CompositionSize = 0;
Xstatic int editMessage();
X
X#define BUFFER_SIZE 1024
X
X#define POST     0
X#define FOLLOWUP 1
X#define REPLY    2
X#define FORWARD  3
X#define GRIPE    4
X#define FOLLOWUPREPLY 5
Xstatic int PostingMode = POST;
Xstatic char *PostingModeStrings`5B`5D =
X    `7B "post", "followup", "reply", "forward", "gripe", "followup-and-mail"
V `7D;
X
Xstatic Boolean IncludeCurrentMode = False;
X
X#ifdef VMS
Xstatic int spawnStat;
X#endif
X
Xstruct header `7B
X    art_num article;
X    char *artText;
X    char *newsgroups;
X    char *subject;
X    char *messageId;
X    char *followupTo;
X    char *references;
X    char *from;
X    char *replyTo;
X    char *distribution;
X    char *keywords;
X
X    char *user;
X    char *real_user;
X    char *fullname;
X    char *host;
X    char *real_host;
X    char *path;`09`09/* note: this is not used with InterNetNews */
X    char *organization;
X
X    char  *date; /* added to header structure....... */
X`7D;
X
X
X/*
X * storage for the header information needed for building, checking,
X * and repairing the header.  Once this is created, the user can go
X * to another article or another group and still use the composition
X * window
X */
X
Xstatic struct header Header = `7B0, NIL(char), NIL(char), NIL(char), NIL(cha
Vr),
X`09`09`09`09  NIL(char), NIL(char), NIL(char), NIL(char),
X`09`09`09`09  NIL(char), NIL(char), NIL(char), NIL(char),
X`09`09`09`09  NIL(char), NIL(char), NIL(char)`7D;
X
X
X#define HOST_NAME_SIZE 1024
X
Xstatic void
XsizeCompose(newSize)
Xint newSize;
X`7B
X    newSize += 10000;
X    if (newSize > CompositionSize) `7B
X`09if (CompositionString == NIL(char)) `7B
X`09    CompositionString = XtMalloc(newSize);
X`09    HeaderString = XtMalloc(newSize);
X`09    TempString= XtMalloc(newSize);
X`09`7D else `7B
X`09    CompositionString = XtRealloc(CompositionString, newSize);
X`09    HeaderString = XtRealloc(HeaderString, newSize);
X`09    TempString= XtRealloc(TempString, newSize);
X`09`7D
X`09CompositionSize = newSize;
X    `7D
X`7D
X
X/*
X * get the header and other important information for an article
X *
X * if called with article equal to zero, will only set up the non-article
X * specific entries
X *
X */
Xstatic void
XgetHeader(article)
Xart_num article;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X#ifndef VMS
X    struct passwd *pwd;
X#endif
X    char host`5BHOST_NAME_SIZE`5D, *ptr;
X    char real_host`5BHOST_NAME_SIZE`5D;
X#ifdef INN
X    char *inn_domain = (char *) GetFileConfigValue ("domain");
X    char *inn_org;
X#else
X    char path`5BHOST_NAME_SIZE`5D;
X#endif
X
X#ifndef VMS
X#if defined(RESOLVER) && !defined(RETURN_HOST)
X    struct hostent *hent;
X#endif
X#endif
X    char buffer`5B10000`5D;
X    char *getenv();
X   `20
X    if (article > 0) `7B
X`09Header.article = article;
X`09xhdr(article, "newsgroups", &Header.newsgroups);
X`09xhdr(article, "subject", &Header.subject);
X`09xhdr(article, "message-id", &Header.messageId);
X`09xhdr(article, "followup-to", &Header.followupTo);
X`09xhdr(article, "references", &Header.references);
X`09xhdr(article, "from", &Header.from);
X`09xhdr(article, "reply-to", &Header.replyTo);
X`09xhdr(article, "distribution", &Header.distribution);
X`09xhdr(article, "keywords", &Header.keywords);
X    `7D else `7B
X`09/* information for 'post' */
X`09if (newsgroup) `7B
X`09    Header.newsgroups = XtNewString(newsgroup->name);
X`09`7D else `7B
X`09    Header.newsgroups = XtNewString("");
X`09`7D
X`09Header.artText = NULL;
X    `7D
X
X    /*
X     * since I'm lazy down below, I'm going to replace NIL pointers with ""
X     */
X    if (Header.newsgroups == NIL(char)) `7B
X`09Header.newsgroups = XtNewString("");
X    `7D
X    if (Header.subject == NIL(char)) `7B
X`09Header.subject = XtNewString("");
X    `7D
X    if (Header.messageId == NIL(char)) `7B
X`09Header.messageId = XtNewString("");
X    `7D
X    if (Header.followupTo == NIL(char)) `7B
X`09Header.followupTo = XtNewString("");
X    `7D
X    if (Header.references == NIL(char)) `7B
X`09Header.references = XtNewString("");
X    `7D
X    if (Header.from == NIL(char)) `7B
X`09Header.from = XtNewString("");
X    `7D
X    if (Header.replyTo == NIL(char)) `7B
X`09Header.replyTo = XtNewString("");
X    `7D
X    if (Header.distribution == NIL(char)) `7B
X`09Header.distribution = XtNewString("");
X    `7D
X    if (Header.keywords == NIL(char)) `7B
X`09Header.keywords = XtNewString("");
X    `7D
X
X    real_host`5B0`5D = 0;
X    host`5B0`5D = 0;
X#ifdef`09UUCPNAME
X    `7B
X        FILE * uup;
X   `20
X        if ((uup = fopen(UUCPNAME, "r")) != NULL) `7B
X    `09`09char   *p;
X    `09`09char    xbuf`5BBUFSIZ`5D;
X   `20
X    `09`09while (fgets(xbuf, sizeof(xbuf), uup) != NULL) `7B
X    `09`09    if (*xbuf <= ' ' `7C`7C *xbuf == '#')
X    `09`09`09continue;
X    `09`09    break;
X    `09`09`7D
X    `09`09if (p = index(xbuf, '\n'))
X    `09`09    *p = '\0';
X    `09`09(void) strncpy(real_host, xbuf, sizeof(real_host) - 1);
X`09`09strcpy(host, real_host);
X    `09`09(void) fclose(uup);
X        `7D
X    `7D
X#endif
X    if (real_host`5B0`5D == 0) `7B
X#ifdef INN
X`09/* always let values in inn.cofnf take precedence */
X`09char *inn_fromhost = (char *) GetConfigValue("fromhost");
X`09if (inn_fromhost != NIL(char)) `7B
X`09    (void) strcpy(real_host, inn_fromhost);
X`09`7D else if (inn_domain != NIL(char)) `7B
X`09    (void) strcpy(real_host, inn_domain);
X`09`7D else `7B
X#endif /* INN */
X        if ((ptr = getenv("HIDDENHOST")) != NIL(char)) `7B
X`09    (void) strncpy(real_host, ptr, sizeof(real_host)-1);
X        `7D else if ((ptr = getinfofromfile(HIDDEN_FILE)) != NULL) `7B
X`09    (void) strncpy(real_host, ptr, sizeof(real_host) - 1);
X`09`7D else `7B
X#ifdef RETURN_HOST
X`09    (void) strcpy(real_host, RETURN_HOST);
X#else /* Not RETURN_HOST */
X#ifndef VMS
X`09    (void) gethostname(real_host, sizeof(real_host));
X#ifdef RESOLVER
X`09    hent = gethostbyname(real_host);
X`09    if (hent != NULL) `7B
X`09`09(void) strcpy(real_host,hent->h_name);
X`09    `7D
X#endif
X#else
X`09    ptr = localHostName();
X`09    if (ptr != NIL(char)) `7B
X`09`09(void) strcpy(real_host, ptr);
X`09    `7D
X`09    ptr = index(real_host, '.');
X`09    if (ptr == NIL(char)) `7B
X`09`09ptr = index(real_host, ':');
X`09`09if (ptr != NIL(char)) `7B
X`09`09    *ptr = '\0';
X`09`09`7D
X`09`09(void) strcat(real_host, DOMAIN_NAME);
X`09    `7D
X`09    utDowncase(real_host);
X#endif
X#endif /* Not RETURN_HOST */
X`09`7D
X#ifdef INN
X`09`7D
X#endif`09/* INN */
X    `7D
X   `20
X    if (app_resources.hostName != NIL(char))`7B
X`09utLowerCase(host, app_resources.hostName, sizeof(host) - 1);
X    `7D else `7B
X`09if ((ptr = getenv("HIDDENHOST")) != NIL(char)) `7B
X`09    (void) strncpy(host, ptr, sizeof(host)-1);
X`09`7D else `7B
X`09    strcpy(host, real_host);
X`09`7D
X    `7D
X
X#ifndef INN   `20
X    if ((ptr = getenv("HIDDENPATH")) != NIL(char)) `7B
X`09(void) strncpy(path, ptr, sizeof(path)-1);
X    `7D else if ((ptr = getinfofromfile(PATH_FILE)) != NULL) `7B
X`09(void) strncpy(path, ptr, sizeof(path)-1);
X    `7D else `7B
X`09(void) strncpy(path, host, sizeof(path)-1);
X    `7D
X#endif /* INN */
X
X    /* If the host name is not a full domain name, put in the domain */
X    if (index (host, '.') == NIL(char)) `7B
X        char   *domain;
X   `20
X        if ((domain = getenv ("DOMAIN")) != NIL (char)) `7B
X`09    (void) strcat(host, domain);
X#ifdef INN
X`09`7D else if (inn_domain != NIL(char)) `7B
X`09    (void) strcat(host, inn_domain);
X#endif /* INN */`09   `20
X`09`7D else if ((domain = getinfofromfile(DOMAIN_FILE)) != NULL) `7B
X`09    (void) strcat(host, domain);
X        `7D else `7B
X`09    (void) strcat (host, DOMAIN_NAME);
X`09`7D
X    `7D
X
X    Header.host = XtNewString(host);
X    Header.real_host = XtNewString(real_host);
X#ifndef INN   `20
X    Header.path = XtNewString(path);
X#endif /* INN */
X
X#ifndef VMS
X    if ((ptr = getinfofromfile(utTildeExpand("`7E/.organization"))) != NULL)
V `7B
X`09Header.organization = XtNewString(ptr);
X    `7D else
X#endif
X    if (app_resources.organization != NIL(char)) `7B
X`09Header.organization = XtNewString(app_resources.organization);
X#ifndef apollo
X    `7D else if ((ptr = getenv ("ORGANIZATION")) != NIL(char)) `7B
X#else
X    `7D else if ((ptr = getenv ("NEWSORG")) != NIL(char)) `7B
X#endif
X`09Header.organization = XtNewString(ptr);
X#ifdef INN
X    `7D else if ((inn_org = (char *) GetConfigValue("organization")) != NIL(
Vchar)) `7B
X`09Header.organization = XtNewString(inn_org);
X#endif /* INN */   `20
X#ifdef ORG_FILE
X    `7D else if ((ptr = getinfofromfile(ORG_FILE)) != NULL) `7B
X`09Header.organization = XtNewString(ptr);
X#endif /* ORG_FILE */
X    `7D else `7B
X`09Header.organization = XtNewString(ORG_NAME);
X    `7D
X#ifndef VMS
X    pwd = getpwuid(getuid());
X    if (Header.user = getenv("USER")) `7B
X`09Header.user = XtNewString(Header.user);
X    `7D else if (Header.user = pwd->pw_name) `7B
X`09Header.user = XtNewString(Header.user);
X    `7D else `7B
X`09Header.user = XtNewString("");
X    `7D
X    if (Header.real_user = pwd->pw_name) `7B
X`09Header.real_user = XtNewString(Header.real_user);
X    `7D else `7B
X`09Header.real_user = XtNewString("");
X    `7D
X    if (Header.fullname = getenv("FULLNAME")) `7B
X`09Header.fullname = XtNewString(Header.fullname);
X    `7D else if (Header.fullname = pwd->pw_gecos) `7B
X`09Header.fullname = XtNewString(Header.fullname);
X    `7D else `7B
X`09Header.fullname = XtNewString("");
X    `7D
X#else
X    Header.user = XtNewString(getenv("USER"));
X    utDowncase(Header.user);
X    Header.real_user = XtNewString(Header.user);
X
X    if (app_resources.personalName != NULL) `7B
X`09Header.fullname = XtNewString(app_resources.personalName);
X    `7D else `7B
X`09if ((Header.fullname = getenv("FULLNAME")) == NIL (char))
X`09    Header.fullname = XtNewString("");
X`09else
X`09    Header.fullname = XtNewString(Header.fullname);
X    `7D
X#endif
X    ptr = index(Header.fullname, ',');
X    if (ptr != NIL(char)) `7B
X`09*ptr = '\0';
X    `7D
X   `20
X    /* & expansion */
X    ptr = index(Header.fullname, '&');
X    if (ptr != NIL(char)) `7B
X`09char *p = buffer + (ptr - Header.fullname);
X
X`09buffer`5B0`5D = '\0';
X`09*ptr = '\0';
X`09(void) strcpy(buffer, Header.fullname);
X`09(void) strcat(buffer, Header.user);
X`09if (isascii(*p)) `7B
X`09    *p = toupper(*p);
X`09`7D
X`09ptr++;
X`09(void) strcat(buffer, ptr);
X`09FREE(Header.fullname);
X`09Header.fullname = XtNewString(buffer);
X    `7D
X   `20
X    return;
X`7D
X
X/*
X * see if a field exists in the header that begins with `60fieldName'
X *
X * returns 0 for no, non-zero for yes
X */
Xstatic int
XfieldExists(string, fieldName)
Xchar *string;
Xchar *fieldName;
X`7B
X    char *ptr;
X
X    for (ptr = string; (ptr != NIL(char)) && (*ptr != '\0'); ptr++) `7B
X`09if ((ptr`5B0`5D == '\n') && (ptr`5B1`5D == '\0')) `7B
X`09    /* end of message */
X`09    return(0);
X`09`7D
X`09if ((ptr`5B0`5D == '\n') && (ptr`5B1`5D == '\n')) `7B
X`09    /* end of header */
X`09    return(0);
X`09`7D
X
X`09/*
X`09 * see if the field name is in the string and at the beginning
X`09 * of the line and that the field name ends with a ':'
X`09 */
X`09if (((ptr == string) `7C`7C (*(ptr-1) == '\n')) &&
X`09    STREQN(fieldName, ptr, utStrlen(fieldName)) &&
X`09    (ptr`5ButStrlen(fieldName)`5D == ':')) `7B
X`09    return(1);
X`09`7D
X    `7D
X    return(0);
X`7D
X
X/*
X * add a header field to a message.
X * this is a destructive operation.
X */
Xstatic void
XaddField(string, field)
Xchar *string;
Xchar *field;
X`7B
X    char buffer`5B10000`5D;
X
X    (void) strcpy(buffer, string);
X    string`5B0`5D = '\0';
X    (void) strcat(string, field);
X    (void) strcat(string, buffer);
X
X    return;
X`7D   `20
X
X/*
X * remove all fields from a header that begin with `60fieldName'.
X * this is a destructive operation.
X */
Xstatic void
XstripField(string, fieldName)
Xchar *string;
Xchar *fieldName;
X`7B
X    char *ptr, *nl;
X
X
X    for (ptr = string; (ptr != NIL(char)) && (*ptr != '\0'); ptr = index(ptr
V, '\n')) `7B
X`09if (ptr != string) `7B
X`09    /* character after the newline */
X`09    ptr++;
X`09`7D
X`09
X`09if ((ptr`5B0`5D == '\n') && (ptr`5B1`5D == '\0')) `7B
X`09    /* end of message */
X`09    return;
X`09`7D
X`09if ((ptr`5B0`5D == '\n') && (ptr`5B1`5D == '\n')) `7B
X`09    /* end of header */
X`09    return;
X`09`7D
X
X`09/*
X`09 * make sure a ':' is at the end of the field name
X`09 */
X`09if (STREQN(fieldName, ptr, utStrlen(fieldName)) && (ptr`5ButStrlen(fieldN
Vame)`5D == ':')) `7B
X`09    nl = index(ptr, '\n');
X`09    (void) strcpy(ptr, ++nl);
X`09    if (*ptr == '\n') `7B
X`09`09return;
X`09    `7D
X`09    ptr--;
X`09`7D
X    `7D
X    return;
X`7D
X
X/*
X * remove fields from a header that begin with `60fieldName'
X * and return the removed characters in `60removed'.
X * this is a destructive operation.
X */
Xstatic void
XreturnField(string, fieldName, removed)
Xchar *string;
Xchar *fieldName;
Xchar *removed;
X`7B
X    char *ptr, *nl, *copyPtr;
X
X    *removed = '\0';
X    for (ptr = string; (ptr != NIL(char)) && (*ptr != '\0');  ptr = index(++
Vptr, '\n')) `7B
X`09if (ptr != string) `7B
X`09    /* character after the newline */
X`09    ptr++;
X`09`7D
X`09
X`09if ((ptr`5B0`5D == '\n') && (ptr`5B1`5D == '\0')) `7B
X`09    /* end of message */
X`09    return;
X`09`7D
X`09if ((ptr`5B0`5D == '\n') && (ptr`5B1`5D == '\n')) `7B
X`09    /* end of header */
X`09    return;
X`09`7D
X
X`09/*
X`09 * make sure a ':' is at the end of the field name
X`09 */
X`09if (STREQN(fieldName, ptr, utStrlen(fieldName)) &&
X`09    (ptr`5ButStrlen(fieldName)`5D == ':')) `7B
X`09    nl = index(ptr, '\n');
X`09    copyPtr = ptr + utStrlen(fieldName) + 1;
X`09    while (*copyPtr == ' ')`09`09/* strip leading spaces */
X`09`09copyPtr++;
X`09    for (; copyPtr < nl; copyPtr++)
X`09         *removed++ = *copyPtr;
X`09    *removed = '\0';
X`09    (void) strcpy(ptr, ++nl);
X`09    return;
X`09`7D
X    `7D
X    return;
X`7D
X
Xstatic void
XPopdownCompositionTopLevel()
X`7B
X    XtSetSensitive(SendButton, False);
X    XtSetSensitive(SaveButton, False);
X    XtSetSensitive(IncludeFileButton, False);
X    XtSetSensitive(IncludeArticleButton, False);
X    XtSetSensitive(IncludeCurrentButton, False);
X    XtSetSensitive(WrapTextButton, False);
X    XtSetSensitive(Rot13Button, False);
X    if (ComposeTopLevel != (Widget) 0) `7B
X`09xthUnmapWidget(ComposeTopLevel);
X`09XtPopdown(ComposeTopLevel);
X    `7D
X    ComposeActive = False;
X    return;
X`7D
X
Xstatic void
XfreeHeader()
X`7B
X    if (PostingMode != GRIPE) `7B
X`09FREE(Header.newsgroups);
X`09FREE(Header.subject);
X`09FREE(Header.messageId);
X`09FREE(Header.followupTo);
X`09FREE(Header.references);
X`09FREE(Header.from);
X`09FREE(Header.replyTo);
X`09FREE(Header.distribution);
X`09FREE(Header.keywords);
X`09FREE(Header.user);
X`09FREE(Header.real_user);
X`09FREE(Header.fullname);
X`09FREE(Header.host);
X`09FREE(Header.real_host);
X#ifndef INN`09
X`09FREE(Header.path);
X#endif /* INN */`09
X`09FREE(Header.organization);
X    `7D
X    return;
X`7D
X
X/*
X * add a subject field to the header of a message.
X * deal with supressing multiple '`5BrR`5D`5BeE`5D: ' strings
X */
Xstatic void
XbuildSubject(message)
Xchar *message;
X`7B
X    if (STREQN(Header.subject, "Re: ", 4) `7C`7C
X`09STREQN(Header.subject, "RE: ", 4) `7C`7C
X`09STREQN(Header.subject, "re: ", 4)) `7B
X`09(void) strcat(message, "Subject: ");
X    `7D else `7B
X`09(void) strcat(message, "Subject: Re: ");
X    `7D
X    (void) strcat(message, Header.subject);
X    (void) strcat(message, "\n");
X
X    return;
X`7D
X
X/*ARGSUSED*/
Xstatic void
XcompAbortFunction(widget, event, string, count)
XWidget widget;
XXEvent *event;
XString *string;
XCardinal *count;
X`7B
X    char *ptr;
X    PopdownCompositionTopLevel();
X    freeHeader();
X    switch (PostingMode) `7B
X`09case POST:
X`09case FOLLOWUP:
X`09case FOLLOWUPREPLY:
X`09    ptr = "Article";
X`09    break;
X`09default:
X`09    ptr = "Message";
X`09    break;
X    `7D
X
X    mesgPane(XRN_INFO, "%s aborted", ptr);
X
X    return;
X`7D
X
Xstatic void
XsaveMessage(fname)
Xchar *fname;
X`7B
X    FILE *fp;
X    char *file = utNameExpand(fname);
X    time_t clock;
X    char *msg;
X
X    if (file == NIL(char)) `7B
X`09mesgPane(XRN_SERIOUS, "Cannot save the article/message (%s)",
X`09`09 errmsg(errno));
X`09return;
X    `7D
X   `20
X    (void) sprintf(error_buffer, "Saving in %s", file);
X    infoNow(error_buffer);
X   `20
X#ifndef VMS
X    if ((fp = fopen(file, "a")) != NULL) `7B
X#else
X    if ((fp = fopen(file, "w")) != NULL) `7B
X#endif
X`09/* Provide initial 'From' line (note ctime() provides a newline) */
X
X`09if (Header.user == NULL) getHeader((art_num) 0);
X`09(void) time(&clock);
X`09if (fprintf(fp, "From %s %s", Header.user, ctime(&clock)) == EOF) `7B
X`09    goto finished;
X`09`7D
X
X`09/* copy body of message, protecting any embedded 'From' lines */
X
X`09msg = HeaderString;
X`09while (*msg) `7B
X`09    if (STREQN(msg, "From ", 5)) `7B
X`09`09if (fputc('>', fp) == EOF) `7B
X`09`09    goto hdrfinished;
X`09`09`7D
X`09    `7D
X`09    while (*msg) `7B
X`09`09if (fputc(*msg, fp) == EOF) `7B
X`09`09    goto hdrfinished;
X`09`09`7D
X`09`09++msg;
X`09`09if (*(msg-1) == '\n') break;
X`09    `7D
X`09`7D
X
Xhdrfinished:
X`09
X`09if (fputs("\n\n", fp) == EOF) `7B
X`09    goto finished;
X`09`7D
X
X`09msg = CompositionString;
X`09while (*msg) `7B
X`09    if (STREQN(msg, "From ", 5)) `7B
X`09`09if (fputc('>', fp) == EOF) `7B
X`09`09    goto finished;
X`09`09`7D
X`09    `7D
X`09    while (*msg) `7B
X`09`09if (fputc(*msg, fp) == EOF) `7B
X`09`09    goto finished;
X`09`09`7D
X`09`09++msg;
X`09`09if (*(msg-1) == '\n') break;
X`09    `7D
X`09`7D
X`09
X`09/* ensure there is an empty line at the end */
X
X`09if (fputs("\n\n", fp) == EOF) `7B
X`09    goto finished;
X`09`7D
X
Xfinished:
X`09(void) fclose(fp);
X
X    `7D else `7B
X`09mesgPane(XRN_SERIOUS, "Can not save the article/message (%s)",
X`09 errmsg(errno));
X    `7D
X    return;
X`7D
X
X/*ARGSUSED*/
Xstatic void
XcompSaveFunction(widget, event, string, count)
XWidget widget;
XXEvent *event;
XString *string;
XCardinal *count;
X`7B
X    char *textString;
X   `20
X#ifdef MOTIF
X    textString = xmWrapTextWidget(ComposeText);
X#else
X    textString = DwtSTextGetString(ComposeText);
X#endif
X    sizeCompose(utStrlen(textString));
X    strcpy(CompositionString, textString);
X    XtFree(textString);
X#ifdef MOTIF
X    textString = XmTextGetString(HeaderText);
X#else
X    textString = DwtSTextGetString(HeaderText);
X#endif
X    strcpy(HeaderString, textString);
X    XtFree(textString);
X    saveMessage(app_resources.savePostings);
X`7D
X
Xstatic void
XsaveDeadLetter(textString)
Xchar`09*textString;
X`7B
X    FILE *fp;
X
X#ifndef VMS
X    if ((fp = fopen(utNameExpand(app_resources.deadLetters), "a")) != NULL)
V `7B
X#else
X    if ((fp = fopen(utNameExpand(app_resources.deadLetters), "w")) != NULL)
V `7B
X#endif
X`09(void) fwrite(textString ,sizeof(char), utStrlen(textString), fp);
X`09(void) putc('\n', fp);
X`09(void) putc('\n', fp);
X`09(void) fclose(fp);
X    `7D else `7B
X`09mesgPane(XRN_SERIOUS, "Can not save the dead article/message (%s)",
X`09`09 errmsg(errno));
X    `7D
X    return;
X`7D
X
X
X/*
X * go through the string and look for fields that have not
X * been filled in and remove them
X */
X/*ARGSUSED*/
Xstatic void
XstripBlankFields(string)
Xchar *string;
X`7B
X    char *ptr, *nl, *end;
X
X    ptr = string + utStrlen(string) - 1;
X/*
X * make sure it ends with a newline
X */
X    if (*ptr != '\n') `7B
X`09ptr++;
X`09*ptr++ = '\n';
X`09*ptr++ = '\0';
X    `7D
X    for (ptr = string; (ptr != NIL(char)) && (*ptr != '\0'); ptr = index(ptr
V, '\n')) `7B
X`09if ((ptr`5B0`5D == '\n') && (ptr`5B1`5D == '\0')) `7B
X`09    ptr`5B1`5D = '\n';`09`09/* put in the missing newline */
X`09    ptr`5B2`5D = '\0';
X`09    /* end of message */
X`09    return;
X`09`7D
X`09if ((ptr`5B0`5D == '\n') && (ptr`5B1`5D == '\n')) `7B
X`09    /* end of header */
X`09    return;
X`09`7D
X
X`09if (ptr != string) `7B
X`09    /* character after the newline */
X`09    ptr++;
X`09`7D
X`09
X`09/* get the line */
X`09if ((nl = index(ptr, '\n')) == NIL(char)) `7B
X`09    /* weird */
X`09    return;
X`09`7D
X
X`09if (strncmp(ptr, "-=-=", 4) == 0 `7C`7C strncmp(ptr, "=-=-", 4) == 0) `7B
X`09    /* end of message banner */
X`09    *ptr++ = '\n';
X`09    strcpy(ptr, ++nl);
X`09    return;
X`09`7D
X`09/* ignore trailing spaces */
X`09end = nl;
X`09end--;
X`09for ( ; *end == ' '; end--) ;
X`09
X`09if ((*end == ':') && (end == index(ptr, ':'))) `7B
X`09    /* blank field */
X`09    (void) strcpy(ptr, ++nl);
X`09    if (*ptr == '\n') `7B
X`09`09return;
X`09    `7D
X`09    ptr--;
X`09`7D
X    `7D
X    return;
X`7D   `20
X
X/*
X * Remote the 'start of text' header
X */
Xstatic void
XstripHeaderField(string)
Xchar *string;
X`7B
X    char *ptr, *nl;
X
X    ptr = string + utStrlen(string) - 1;
X    for (ptr = string; (ptr != NIL(char)) && (*ptr != '\0'); ptr = index(ptr
V, '\n')) `7B
X`09if ((ptr`5B0`5D == '\n') && (ptr`5B1`5D == '\0')) `7B
X`09    ptr`5B1`5D = '\n';`09`09/* put in the missing newline */
X`09    ptr`5B2`5D = '\0';
X`09    /* end of message */
X`09    break;
X`09`7D
X
X`09if (ptr != string) `7B
X`09    /* character after the newline */
X`09    ptr++;
X`09`7D
X`09
X`09/* get the line */
X`09if ((nl = index(ptr, '\n')) == NIL(char)) `7B
X`09    /* weird */
X`09    break;
X`09`7D
X
X`09if (strncmp(ptr, "-=-=", 4) == 0 `7C`7C strncmp(ptr, "=-=-", 4) == 0) `7B
X`09    /* end of message banner */
X`09    *ptr++ = '\n';
X`09    strcpy(ptr, ++nl);
X`09    break;
X`09`7D
X    `7D
X    ptr = string + utStrlen(string) - 1;
X    while (*ptr == '\n') ptr--;
X    ptr++;
X    strcpy(ptr, "\n\n");
X    return;
X`7D   `20
X
X#ifdef VMS
X#include <ssdef.h>
X#include <descrip.h>
X#include <maildef.h>
Xstatic Widget`09mailErrorDialog = NULL;
Xstatic char`09VMSmessage`5B255`5D;
Xstatic char`09TXTmessage`5B255`5D;
Xstatic char`09*VMSmessPtr;
Xstatic int`09VMSmessSize;
Xstatic int
XgrabMessage(descr)
Xstruct`09dsc$descriptor_s *descr;
X`7B
X    char *p;
X    short s;
X    s = (short)descr->dsc$w_length;
X    p = (char *)descr->dsc$a_pointer;
X    strncpy(VMSmessPtr, p, s);   `20
X    VMSmessSize += s;
X    VMSmessage`5BVMSmessSize`5D = '\n';
X    VMSmessSize++;
X    VMSmessage`5BVMSmessSize`5D = '\0';
X    VMSmessPtr += VMSmessSize;
X    return 0;
X`7D
Xstatic unsigned int
XhandleMailSignal(sig, mech)
Xint sig`5B`5D;
Xint mech`5B`5D;
X`7B
X    sig`5B0`5D = sig`5B0`5D - 2;
X    VMSmessPtr = VMSmessage;
X    VMSmessSize = 0;
X    sys$putmsg(sig, grabMessage, 0, 0);
X    sig`5B0`5D = sig`5B0`5D + 2;
X    return SS$_CONTINUE;
X`7D
Xstatic void
XpopDownMail(widget, client_data, call_data)
XWidget widget;
Xcaddr_t client_data;
Xcaddr_t call_data;
X`7B
X    PopDownDialog(mailErrorDialog);
X    return;
X`7D
Xstatic void
XmailError()
X`7B
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Click To Continue", popDownMail, (caddr_t) -1`7D,
X    `7D;
X
X    (void) strcpy(TXTmessage,"Error sending mail:");
X    (void) strcat(TXTmessage,VMSmessage);
X    mailErrorDialog = CreateDialog(TopLevel, "Mail Error",
X`09`09`09`09   TXTmessage, DIALOG_NOTEXT,
X`09`09`09`09   args, XtNumber(args));
X    PopUpDialog(mailErrorDialog);
X    return;
X`7D
X#endif /* VMS */
X
Xstatic void
XsendFollowupMail(str)
Xchar *str;
X`7B
X    char *message;
X    char pathFormatString`5B100`5D;
X
X    message = XtMalloc(strlen(str) + 1024);
X
X    if (app_resources.replyPath != NIL(char)) `7B
X`09if (app_resources.ccForward) `7B
X`09    sprintf(pathFormatString, "To: %s\nCc: %s\n",
X`09`09app_resources.replyPath, Header.user);
X`09`7D else `7B
X`09    if (app_resources.cc == True) `7B
X`09`09sprintf(pathFormatString, "To: %s\nCc: \n",
X`09`09`09app_resources.replyPath);
X`09    `7D else `7B
X`09`09sprintf(pathFormatString, "To: %s\n",app_resources.replyPath);
X`09    `7D
X`09`7D
X    `7D else `7B
X`09if (app_resources.ccForward) `7B
X`09    sprintf(pathFormatString, "To: %s\nCc: %s\n", "%s", Header.user);
X`09`7D else `7B
X`09    if (app_resources.cc == True) `7B
X`09`09strcpy(pathFormatString, "To: %s\nCc: \n");
X`09    `7D else `7B
X`09`09strcpy(pathFormatString, "To: %s\n");
X`09    `7D
X`09`7D
X    `7D
X    (void) sprintf(message, pathFormatString,
X`09`09   (*Header.replyTo != '\0') ? Header.replyTo : Header.from);
X
X    if (app_resources.replyTo != NIL(char)) `7B
X`09 (void) strcat(message, "Reply-To: ");
X`09 (void) strcat(message, app_resources.replyTo);
X`09 (void) strcat(message, "\n");
X    `7D
X
X    buildSubject(message);
X    strcat(message, "\n");
X    strcat(message, str);
X    switch (postArticle(message, XRN_MAIL)) `7B
X`09case POST_TRYAGAIN:
X`09case POST_FAILED:
X`09    XBell(XtDisplay(TopLevel), 50);
X`09    mesgPane(XRN_SERIOUS, "Could not send reply.");
X`09    return;
X`09    break;
X`09case POST_OKAY:
X`09    mesgPane(XRN_INFO, "Mail Message Sent");
X`09    break;
X    `7D
X`7D
X/*ARGSUSED*/
Xstatic void
XcompSendFunction(widget, event, string, count)
XWidget widget;
XXEvent *event;
XString *string;
XCardinal *count;
X`7B
X    char buffer`5B10000`5D;
X    char *textString;
X    /*
X     * I am loathe to use buffers that are 1024 bytes long for the old
X     * from line, new from line and sender line, since they are almost
X     * certainly going to be much shorter than this, but this seems to
X     * be the way things are done elsewhere in this file, so I'll
X     * stick with it.
X     */
X    char oldNgString`5BBUFFER_SIZE`5D;
X    char newNgString`5BBUFFER_SIZE`5D;
X    char oldFromString`5BBUFFER_SIZE`5D, tempFromString`5BBUFFER_SIZE`5D;
X    char newFromString`5BBUFFER_SIZE`5D;
X    char senderString`5BBUFFER_SIZE`5D;
X    int mode, i,j, len, comma;
X#if defined(INN)
X    char subjString`5BBUFFER_SIZE`5D;
X#endif
X
X    if (app_resources.editorCommand == NIL(char)) `7B
X#ifdef MOTIF
X`09textString = xmWrapTextWidget(ComposeText);
X#else
X`09textString = DwtSTextGetString(ComposeText);
X#endif
X`09sizeCompose(utStrlen(textString));
X`09strcpy(CompositionString, textString);
X`09XtFree(textString);
X#ifdef MOTIF
X`09textString = XmTextGetString(HeaderText);
X#else
X`09textString = DwtSTextGetString(HeaderText);
X#endif
X`09strcpy(HeaderString, textString);
X`09XtFree(textString);
X`09stripBlankFields(HeaderString);
X`09stripHeaderField(HeaderString);
X    `7D else `7B
X`09strcpy(HeaderString, CompositionString);
X`09CompositionString`5B0`5D = '\0';
X`09stripBlankFields(HeaderString);
X`09stripHeaderField(HeaderString);
X    `7D
X   `20
X    if ((PostingMode == POST) `7C`7C (PostingMode == FOLLOWUP) `7C`7C
X`09(PostingMode == FOLLOWUPREPLY)) `7B
X`09mode = XRN_NEWS;
X`09if (app_resources.editorCommand == NIL(char)) `7B
X`09    if (!fieldExists(HeaderString, "Subject")) `7B
X`09`09if (PostingMode == POST) `7B
X`09`09    XBell(XtDisplay(TopLevel), 50);
X`09`09    (void) sprintf(buffer, "Subject: ********\n");
X`09`09    mesgPane(XRN_SERIOUS,
X`09`09`09 "The Subject field is missing in your message!");
X`09`09    addField(HeaderString, buffer);
X#ifdef MOTIF
X`09`09    XmTextSetString(HeaderText, HeaderString);
X#ifndef MOTIF_V10
X`09`09    XmTextSetCursorPosition(HeaderText, (XmTextPosition) 0);
X#endif
X`09`09    XmTextSetInsertionPosition(HeaderText, (XmTextPosition) 0);
X#else
X`09`09    DwtSTextSetString(HeaderText, HeaderString);
X`09`09    DwtTextSetInsertionPosition(HeaderText, 0);
X#endif
X`09`09    return;
X`09`09`7D
X`09`09buffer`5B0`5D = '\0';
X`09`09buildSubject(buffer);
X`09`09addField(HeaderString, buffer);
X`09    `7D
X#ifdef INN
X`09    /* Let's be more strict, since inews doesn't see empty headers.  */
X`09    returnField(HeaderString, "Subject", subjString);
X`09    if (subjString`5B0`5D == '\0') `7B
X`09`09XBell(XtDisplay(TopLevel), 0);
X`09`09mesgPane(XRN_SERIOUS, "The Subject field is empty in your message!");
X`09`09return;
X`09    `7D
X`09    sprintf(buffer, "Subject: %s\n", subjString);
X`09    addField(HeaderString, buffer);
X#endif /* INN */`09
X`09`7D
X`09if (PostingMode == FOLLOWUP `7C`7C PostingMode == FOLLOWUPREPLY) `7B
X`09    if (!fieldExists(HeaderString, "References")) `7B
X`09`09(void) sprintf(buffer, "References: %s\n", Header.messageId);
X`09`09addField(HeaderString, buffer);
X`09    `7D
X`09`7D
X
X#ifdef INEWS
X`09/*
X`09 * Extract any From: field currently in the message, and store it
X`09 * in the newFromString.
X`09 */
X`09returnField(HeaderString, "From", newFromString);
X`09/*
X`09 * This is the default that was displayed in the Composition pane
X`09 */
X`09(void) sprintf(oldFromString, "%s@%s (%s)",
X`09`09`09    Header.user, Header.host, Header.fullname);
X`09/*
X`09 * If we're using INEWS we pass on any From: header the user
X`09 * may have set explicitly.
X`09 */
X`09if (strcmp(oldFromString, newFromString)) `7B
X`09    (void) sprintf(buffer, "From: %s\n", newFromString);
X`09    addField(HeaderString, buffer);
X`09`7D
X`09/*
X`09 * Get rid of any Sender: field currently in the mesage --
X`09 * the Sender: field should not ever be inserted by the user.
X`09 */
X`09stripField("Sender:");
X#else
X`09/*
X`09 * Strip any From: field currently in the message, and store
X`09 * it in oldFromString.
X`09 */
X`09returnField(HeaderString, "From", oldFromString);
X`09/*
X`09 * If there was no From: field in the message, create a
X`09 * template one.
X`09 */
X`09if (*oldFromString == '\0')
X`09     (void) sprintf(oldFromString, "%s@%s (%s)",
X`09`09`09    Header.user, Header.host, Header.fullname);
X`09/*
X`09 * Now add into the message either the From: field that was
X`09 * pulled out or the one that was just created.
X`09 */
X`09(void) sprintf(buffer, "From: %s\n", oldFromString);
X`09addField(HeaderString, buffer);
X`09/*
X`09 * Now figure out what the default From: field should look
X`09 * like, with the real username in it (in case the user has
X`09 * specified a different username in the USER environment
X`09 * variable).
X`09 */
X`09(void) sprintf(newFromString, "%s@%s (%s)",
X`09`09       Header.real_user, Header.real_host, Header.fullname);
X`09/*
X`09 * Get rid of any Sender: field currently in the message --
X`09 * the Sender: field should not ever be inserted by the user.
X`09 */
X`09returnField(HeaderString, "Sender", senderString);
X`09/*
X`09 * If the default From: field is different from what's
X`09 * actually in the message, then insert a Sender: field with
X`09 * the default information in it.
X`09 */
X`09if (strcmp(oldFromString, newFromString)) `7B
X`09     (void) sprintf(senderString, "Sender: %s@%s (%s)\n",
X`09`09`09    Header.real_user, Header.real_host,
X`09`09`09    Header.fullname);
X`09     addField(HeaderString, senderString);
X`09`7D
X#endif /* INEWS */`09
X
X`09if (!fieldExists(HeaderString, "Newsgroups")) `7B
X`09    (void) sprintf(buffer, "Newsgroups: %s\n", Header.newsgroups);
X`09    addField(HeaderString, buffer);
X`09`7D else `7B
X`09    /*
X`09     * fix up the Newsgroups: field - inews can not handle spaces
X`09     * between group names
X`09     */
X`09    returnField(HeaderString, "Newsgroups", oldNgString);
X`09    len = strlen(oldNgString);
X`09    j = 0;
X`09    comma = 0;
X`09    for (i = 0; i < len; i++) `7B
X`09`09if (comma && (oldNgString`5Bi`5D == ' ')) continue;
X`09`09comma = 0;
X`09`09newNgString`5Bj++`5D = oldNgString`5Bi`5D;
X`09`09if (oldNgString`5Bi`5D == ',') `7B
X`09`09    comma = 1;
X`09`09`7D
X`09    `7D
X`09    newNgString`5Bj`5D = '\0';
X`09    sprintf(oldNgString, "Newsgroups: %s\n", newNgString);
X`09    addField(HeaderString, oldNgString);
X`09`7D
X
X#ifndef INN
X`09/* The inews in INN adds the Path: header for us, and has its own
X`09 * idea of policy.  We don't bother creating it, freeing it, or
X`09 * anything else in compose.c that has to do with it
X`09 */
X`09if (!fieldExists(HeaderString, "Path")) `7B
X#if defined(INEWS) `7C`7C defined(HIDE_PATH)
X`09    (void) sprintf(buffer, "Path: %s\n", Header.user);
X#else
X`09    (void) sprintf(buffer, "Path: %s!%s\n", Header.path, Header.user);
X#endif
X`09    addField(HeaderString, buffer);
X`09`7D
X#else
X`09returnField(HeaderString, "Sender", senderString);
X#endif /* INN */
X
X/*`09stripField("Message-ID:");  .............we need this !!! */
X`09stripField(HeaderString, "Relay-Version");
X`09stripField(HeaderString, "Posting-Version");
X
X`09(void) strcat (HeaderString, CompositionString);
X    `7D else `7B
X`09(void) strcat (HeaderString, CompositionString);
X`09mode = XRN_MAIL;
X    `7D
X
X    switch (postArticle(HeaderString,mode)) `7B
X`09case POST_TRYAGAIN:
X`09    return;
X
X`09case POST_FAILED:
X`09    XBell(XtDisplay(TopLevel), 50);
X`09    mesgPane(XRN_SERIOUS, "Could not post, saving to %s",
X`09`09app_resources.deadLetters);
X`09    saveDeadLetter(HeaderString);
X`09    break;
X
X`09case POST_NOTALLOWED:
X`09    mesgPane(XRN_SERIOUS,
X`09`09"Posting not allowed from this machine, saving in %s",
X`09`09 app_resources.deadLetters);
X`09    break;
X`09   `20
X`09case POST_OKAY:
X`09    if (PostingMode == FOLLOWUPREPLY) `7B
X`09`09sendFollowupMail(HeaderString);
X`09    `7D
X`09    switch (mode) `7B
X`09`09case XRN_NEWS:
X`09`09    mesgPane(XRN_INFO, "Article Posted");
X`09`09    break;
X
X`09`09case XRN_MAIL:
X`09`09    mesgPane(XRN_INFO, "Mail Message Sent");
X`09`09    break;
X`09    `7D
X`09    break;
X    `7D
X
X    if (app_resources.editorCommand == NIL(char)) `7B
X`09PopdownCompositionTopLevel();
X    `7D
X    freeHeader();
X
X    return;
X`7D
X#ifdef VMS
Xint
XmailArticle(article)
Xchar *article;
X`7B
X    struct _itemList `7B
X`09short item_size;
X`09short item_code;
X`09char* item_ptr;
X`09int   item_rtn_size;
X`09int   end_list;
X    `7D itemList;
X`09`20
X    struct _ccList `7B
X`09short item1_size;
X`09short item1_code;
X`09char* item1_ptr;
X`09int   item1_rtn_size;
X`09short item2_size;
X`09short item2_code;
X`09char* item2_ptr;
X`09int   item2_rtn_size;
X`09int   end_list;
X    `7D ccList;
X`09`20
X    FILE *fp;
X    char toString`5BBUFFER_SIZE`5D;
X    char ccString`5BBUFFER_SIZE`5D;
X    char subjString`5BBUFFER_SIZE`5D;
X    char listFileName`5B512`5D;
X    char listName`5B512`5D;
X    int  listNameSize;
X    int`09context, status;
X    char *textPtr, *nl;
X    char *toElement, *tokPtr;
X    char *p;
X    char *ccElement;
X    int mailCC = MAIL$_CC;
X    char **wrappedLines;
X    char **lines;
X    long zero = 0;
X    int lineCount;
X
X    VAXC$ESTABLISH(handleMailSignal);
X    sizeCompose(strlen(article) + 500);
X    strcpy(HeaderString, article);
X    returnField(HeaderString, "To", toString);
X
X    if (strlen(toString) == 0) `7B
X`09XBell(XtDisplay(TopLevel), 0);
X`09mesgPane(XRN_SERIOUS, "You must enter a non-Null TO field");
X`09return POST_TRYAGAIN;
X`09`7D
X
X    returnField(HeaderString, "Subject", subjString);
X    if (strlen(subjString) == 0) `7B
X`09XBell(XtDisplay(TopLevel), 0);
X`09mesgPane(XRN_SERIOUS, "You must enter a non-Null subject");
X`09return POST_TRYAGAIN;
X    `7D
X    returnField(HeaderString,"Cc", ccString);
X    context = 0;
X    status = MAIL$SEND_BEGIN(&context, &zero, &zero);
X    if ((status&1) != 1) `7B
X`09mailError();
X`09return POST_TRYAGAIN;
X    `7D
X    if (index(toString,'"') == NULL) `7B
X`09for (p = toString; *p != '\0'; p++) `7B
X`09    *p = toupper(*p);
X`09`7D
X    `7D
X    if (index(ccString,'"') == NULL) `7B
X`09for (p = ccString; *p != '\0'; p++) `7B
X`09    *p = toupper(*p);
X`09`7D
X    `7D
X    itemList.item_code = MAIL$_SEND_TO_LINE;
X    itemList.item_ptr = toString;
X    itemList.item_size = strlen(toString);
X    itemList.item_rtn_size = 0;
X    itemList.end_list = 0;
X    status = MAIL$SEND_ADD_ATTRIBUTE(&context, &itemList, &zero);
X    if ((status&1) != 1) `7B
X`09mailError();
X        MAIL$SEND_ABORT(&context, &zero, &zero);
X`09return POST_TRYAGAIN;
X    `7D
X    itemList.item_code = MAIL$_SEND_CC_LINE;
X    itemList.item_ptr = ccString;
X    itemList.item_size = strlen(ccString);
X    itemList.item_rtn_size = 0;
X    itemList.end_list = 0;
X    status = MAIL$SEND_ADD_ATTRIBUTE(&context, &itemList, &zero);
X    if ((status&1) != 1) `7B
X`09mailError();
X        MAIL$SEND_ABORT(&context, &zero, &zero);
X`09return POST_TRYAGAIN;
X    `7D
X    tokPtr = toString;
X    while ((toElement = strtok(tokPtr, ",")) != NULL) `7B
X`09itemList.item_code = MAIL$_SEND_USERNAME;
X`09if ((itemList.item_ptr = getenv(toElement)) == NULL) `7B
X`09    itemList.item_ptr = toElement;
X`09`7D
X`09itemList.item_size = strlen(itemList.item_ptr);
X`09for (p = itemList.item_ptr; *p == ' '; p++);
X`09if (*p == '@') `7B
X`09    p++;
X`09    if ((fp = fopen(p, "r","dna=.dis")) == NULL) `7B
X`09`09sprintf(VMSmessage, "Error opening distribution file %s",p);
X`09`09mailError();
X`09`09MAIL$SEND_ABORT(&context, &zero, &zero);
X`09`09return POST_TRYAGAIN;
X`09    `7D else `7B
X`09`09while (fgets(listName, 128, fp) != NULL) `7B
X`09`09    listNameSize = strlen(listName);
X`09`09    listNameSize--;`09`09`09/* strip the newline */
X`09`09    listName`5BlistNameSize`5D = '\0';
X`09`09    itemList.item_code = MAIL$_SEND_USERNAME;
X`09`09    if ((itemList.item_ptr = getenv(listName)) == NULL) `7B
X`09`09`09itemList.item_ptr = listName;
X`09`09    `7D
X`09`09    for (p = itemList.item_ptr; *p != '\0'; p++) `7B
X`09`09`09if (*p == '!')
X`09`09`09    *p = '\0';
X`09`09`09if (*p == '\t')
X`09`09`09    *p = ' ';
X`09`09    `7D
X`09`09    p = itemList.item_ptr;
X`09`09    if ((itemList.item_ptr = getenv(p)) == NULL) `7B
X`09`09`09itemList.item_ptr = p;
X`09`09    `7D
X`09`09    itemList.item_size = strlen(itemList.item_ptr);
X`09`09    itemList.item_rtn_size = 0;
X`09`09    itemList.end_list = 0;
X`09`09    status = MAIL$SEND_ADD_ADDRESS(&context, &itemList, &zero);
X`09`09    if ((status&1) != 1) `7B
X`09`09`09fclose(fp);
X`09`09`09mailError();
X`09`09`09MAIL$SEND_ABORT(&context, &zero, &zero);
X`09`09`09return POST_TRYAGAIN;
X`09`09    `7D
X`09`09`7D
X`09`09fclose(fp);
X`09    `7D
X`09`7D else `7B
X`09    itemList.item_rtn_size = 0;
X`09    itemList.end_list = 0;
X`09    status = MAIL$SEND_ADD_ADDRESS(&context, &itemList, &zero);
X`09    if ((status&1) != 1) `7B
X`09`09mailError();
X`09`09MAIL$SEND_ABORT(&context, &zero, &zero);
X`09`09return POST_TRYAGAIN;
X`09    `7D
X`09`7D
X`09tokPtr = NULL;
X    `7D
X    tokPtr = ccString;
X    while ((toElement = strtok(tokPtr, ",")) != NULL) `7B
X`09ccList.item1_code = MAIL$_SEND_USERNAME;
X`09if ((ccList.item1_ptr = getenv(toElement)) == NULL) `7B
X`09    ccList.item1_ptr = toElement;
X`09`7D
X`09ccList.item1_size = strlen(ccList.item1_ptr);
X`09for (p = ccList.item1_ptr; *p == ' '; p++);
X`09if (*p == '@') `7B
X`09    p++;
X`09    if ((fp = fopen(p, "r","dna=.dis")) == NULL) `7B
X`09`09sprintf(VMSmessage, "Error opening distribution file %s",p);
X`09`09mailError();
X`09`09MAIL$SEND_ABORT(&context, &zero, &zero);
X`09`09return POST_TRYAGAIN;
X`09    `7D else `7B
X`09`09while (fgets(listName, 128, fp) != NULL) `7B
X`09`09    listNameSize = strlen(listName);
X`09`09    listNameSize--;`09`09`09/* strip the newline */
X`09`09    listName`5BlistNameSize`5D = '\0';
X`09`09    ccList.item1_code = MAIL$_SEND_USERNAME;
X`09`09    if ((ccList.item1_ptr = getenv(listName)) == NULL) `7B
X`09`09`09ccList.item1_ptr = listName;
X`09`09    `7D
X`09`09    for (p = ccList.item1_ptr; *p != '\0'; p++) `7B
X`09`09`09if (*p == '!')
X`09`09`09    *p = '\0';
X`09`09`09if (*p == '\t')
X`09`09`09    *p = ' ';
X`09`09    `7D
X`09`09    p = ccList.item1_ptr;
X`09`09    if ((ccList.item1_ptr = getenv(p)) == NULL) `7B
X`09`09`09ccList.item1_ptr = p;
X`09`09    `7D
X`09`09    ccList.item1_size = strlen(ccList.item1_ptr);
X`09`09    ccList.item1_rtn_size = 0;
X`09`09    ccList.item2_code = MAIL$_SEND_USERNAME_TYPE;
X`09`09    ccList.item2_ptr = (char *) &mailCC;
X`09`09    ccList.item2_size = 2;
X`09`09    ccList.item2_rtn_size = 0;
X`09`09    ccList.end_list = 0;
X`09`09    status = MAIL$SEND_ADD_ADDRESS(&context, &ccList, &zero);
X`09`09    if ((status&1) != 1) `7B
X`09`09`09fclose(fp);
X`09`09`09mailError();
X`09`09`09MAIL$SEND_ABORT(&context, &zero, &zero);
X`09`09`09return POST_TRYAGAIN;
X`09`09    `7D
X`09`09`7D
X`09`09fclose(fp);
X`09    `7D
X`09`7D else `7B
X`09    ccList.item1_rtn_size = 0;
X`09    ccList.item2_code = MAIL$_SEND_USERNAME_TYPE;
X`09    ccList.item2_ptr = (char *) &mailCC;
X`09    ccList.item2_size = 2;
X`09    ccList.item2_rtn_size = 0;
X`09    ccList.end_list = 0;
X`09    status = MAIL$SEND_ADD_ADDRESS(&context, &ccList, &zero);
X`09    if ((status&1) != 1) `7B
X`09`09mailError();
X`09`09MAIL$SEND_ABORT(&context, &zero, &zero);
X`09`09return POST_TRYAGAIN;
X`09    `7D
X`09`7D
X`09tokPtr = NULL;
X    `7D
X    itemList.item_code = MAIL$_SEND_SUBJECT;
X    itemList.item_size = strlen(subjString);
X    itemList.item_ptr = subjString;
X    itemList.item_rtn_size = 0;
X    itemList.end_list = 0;
X    status = MAIL$SEND_ADD_ATTRIBUTE(&context, &itemList, &zero);
X    if ((status&1) != 1) `7B
X`09mailError();
X        MAIL$SEND_ABORT(&context, &zero, &zero);
X`09return POST_TRYAGAIN;
X    `7D
X/*
X * Iterate over the composition string, extracting records
X * delimited by newlines and sending each as a record
X *
X */
X    textPtr = HeaderString;
X    while (*textPtr == '\n')
X`09textPtr++;
X    lines = wrappedLines = wrapText(textPtr, &lineCount);
X
X    while (*lines) `7B
X`09itemList.item_code = MAIL$_SEND_RECORD;
X`09itemList.item_size = strlen(*lines);
X`09itemList.item_ptr = *lines;
X`09itemList.item_rtn_size = 0;
X`09itemList.end_list = 0;
X`09status = MAIL$SEND_ADD_BODYPART(&context, &itemList, &zero);
X`09if ((status&1) != 1) `7B
X`09    mailError();
X`09    MAIL$SEND_ABORT(&context, &zero, &zero);
X`09    return POST_FAILED;
X`09`7D
X`09
X`09FREE(*lines);
X`09lines++;
X    `7D
X    FREE(wrappedLines);
X    status = MAIL$SEND_MESSAGE(&context, &zero, &zero);
X    if ((status&1) != 1) `7B
X`09mailError();
X        MAIL$SEND_END(&context, &zero, &zero);
X`09return POST_FAILED;
X    `7D
X    MAIL$SEND_END(&context, &zero, &zero);
X    return POST_OKAY;
X`7D
X#endif
X
Xstatic void
XincludeArticleText()
X`7B
X    char line`5B256`5D, *end;
X    char *art, *art1;
X
X    sizeCompose(utStrlen(CompositionString) + utStrlen(Header.artText));
X    end = CompositionString + InsertionPoint;
X    (void) strcpy(TempString, end);
X    *end = '\0';
X
X    if (Header.artText == NULL) `7B
X`09XBell(XtDisplay(TopLevel), 0);
X`09mesgPane(XRN_SERIOUS, "No article to include");
X`09return;
X    `7D
X    if (PostingMode == REPLY && !IncludeCurrentMode) `7B
X       (void) sprintf(line, "In article %s you write:\n",
X`09`09Header.messageId );
X    `7D else `7B
X       (void) sprintf(line, "In article %s, %s writes:\n",
X`09`09   Header.messageId, Header.from);
X    `7D
X
X    (void) strcat(CompositionString, line);
X    end = CompositionString + utStrlen(CompositionString);
X    *end = '\0';
X
X    /* copy the article */
X
X    art = Header.artText;
X    if (!app_resources.includeHeader) `7B
X`09for (art1 = art + 1; *art1 != '\0'; art++, art1++) `7B
X`09    if (*art == '\n' && *art1 == '\n') `7B
X`09`09art = ++art1;
X`09`09break;
X`09    `7D
X`09`7D
X    `7D
X`09
X    if (app_resources.includeSep == TRUE && PostingMode != FORWARD) `7B
X        (void) strcat(end, app_resources.includePrefix);
X`09end += utStrlen(app_resources.includePrefix);
X    `7D
X    for (; *art != '\0'; art++) `7B
X`09*end++ = *art;
X    `09*end = '\0';
X`09if (*art == '\n')
X`09    if (app_resources.includeSep == TRUE && PostingMode != FORWARD) `7B
X`09`09(void) strcat(end, app_resources.includePrefix);
X`09`09end += utStrlen(app_resources.includePrefix);
X`09    `7D
X    `7D
X    *end++ = '\n';
X    *end = '\0';
X    /* copy back the text after the insertion point */
X    (void) strcat(end, TempString);
X    if (ComposeText != (Widget) 0) `7B
X#ifdef MOTIF
X`09XmTextSetString(ComposeText,CompositionString);
X#else
X`09DwtSTextSetString(ComposeText,CompositionString);
X#endif
X    `7D
X    return;
X`7D
X
X/*ARGSUSED*/
Xstatic void
XcompIncludeArticleFunction(widget, event, string, count)
XWidget widget;
XXEvent *event;
XString *string;
XCardinal *count;
X`7B
X    char *art;
X#ifndef MOTIF
X    Arg textPos`5B1`5D;
X#endif
X    long beforeSize, afterSize;
X   `20
X#ifdef MOTIF
X    art = xmWrapTextWidget(ComposeText);
X#else
X    art = DwtSTextGetString(ComposeText);
X#endif
X    sizeCompose(utStrlen(art));
X    strcpy(CompositionString, art);
X    XtFree(art);
X#ifdef MOTIF
X#ifdef MOTIF_V10
X    InsertionPoint = XmTextGetInsertionPosition(ComposeText);
X#else
X    InsertionPoint = XmTextGetCursorPosition(ComposeText);
X#endif
X#else
X    XtSetArg(textPos`5B0`5D, DwtNinsertionPosition, (XtArgVal) &InsertionPoi
Vnt);
X    XtGetValues(ComposeText, textPos, XtNumber(textPos));
X#endif
X
X    beforeSize = utStrlen(CompositionString);
X    includeArticleText();
X    afterSize = utStrlen(CompositionString);
X
X    InsertionPoint = InsertionPoint + afterSize - beforeSize;
X
X#ifdef MOTIF
X    XmTextSetString(ComposeText,CompositionString);
X#ifndef MOTIF_V10
X    XmTextSetCursorPosition(ComposeText, (XmTextPosition) InsertionPoint);
X#endif
X    XmTextSetInsertionPosition(ComposeText, (XmTextPosition) InsertionPoint)
V;
X#else
X    DwtSTextSetString(ComposeText,CompositionString);
X    XtSetArg(textPos`5B0`5D, DwtNinsertionPosition,`09(XtArgVal) InsertionPo
Vint);
X    XtSetValues(ComposeText, textPos, XtNumber(textPos));
X#endif
X
X    return;
X`7D
X
X/*ARGSUSED*/
Xstatic void
XcompIncludeCurrentFunction(widget, event, string, count)
XWidget widget;
XXEvent *event;
XString *string;
XCardinal *count;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X
X    if (newsgroup != NULL) `7B
X`09Header.artText = getText(newsgroup->current);
X`09getHeader(newsgroup->current);
X    `7D else `7B
X`09Header.artText = NULL;
X    `7D
X    IncludeCurrentMode = True;
X    compIncludeArticleFunction(widget, NULL, NULL, NULL);
X    IncludeCurrentMode = False;
X`7D
X
X#define XRNinclude_ABORT          0
X#define XRNinclude_DOIT           1
X
Xstatic Widget IncludeBox = (Widget) 0;  /* box for typing in the name of a f
Vile */
X
X/*ARGSUSED*/
Xstatic void
XincludeHandler(widget, client_data, call_data)
XWidget widget;
Xcaddr_t client_data;
Xcaddr_t call_data;
X/*
X * handler for the include box
X */
X`7B
X#ifndef MOTIF
X    Arg textPos`5B1`5D;
X#endif
X    char *end, *file;
X    int i;
X    FILE *filefp;
X    struct stat fileStat;
X
X    PopDownDialog(IncludeBox);
X
X    if ((int) client_data != XRNinclude_ABORT) `7B
X`09end = CompositionString + InsertionPoint;
X`09(void) strcpy(TempString, end);
X`09*end = '\0';
X
X`09/* copy the file */
X`09file = XtNewString(GetDialogValue(IncludeBox));
X`09if ((stat(file, &fileStat) != -1) &&`20
X`09    ((filefp = fopen(file, "r")) != NULL)) `7B
X`09    sizeCompose(CompositionSize + utStrlen(TempString) +`20
X`09`09`09fileStat.st_size + 10000);
X`09    end = CompositionString + InsertionPoint;
X`09    while ((i = getc(filefp)) != EOF) `7B
X`09`09*end = i;
X`09`09end++;
X`09    `7D
X`09    *end = '\0';
X`09    (void) fclose(filefp);
X`09`7D else `7B
X`09    mesgPane(XRN_SERIOUS, "Can not open `60%s' (%s)",
X`09`09     file, errmsg(errno));
X`09`7D
X`09XtFree(file);
X`09/* new insertion point */
X`09InsertionPoint = end - CompositionString;
X
X`09/* copy back the text after the insertion point */
X`09(void) strcat(end, TempString);
X
X#ifdef MOTIF
X`09XmTextSetString(ComposeText, CompositionString);
X#ifndef MOTIF_V10
X`09XmTextSetCursorPosition(ComposeText, InsertionPoint);
X#endif
X`09XmTextSetInsertionPosition(ComposeText, InsertionPoint);
X#else
X`09DwtSTextSetString(ComposeText, CompositionString);
X`09XtSetArg(textPos`5B0`5D, DwtNinsertionPosition,
X`09    (XtArgVal) utStrlen(CompositionString));
X`09XtSetValues(ComposeText, textPos, XtNumber(textPos));
X#endif
X    `7D
X
X    return;
X`7D   `20
X
X/*ARGSUSED*/
Xstatic void
XcompIncludeFileFunction(widget, event, string, count)
XWidget widget;
XXEvent *event;
XString *string;
XCardinal *count;
X`7B
X#ifndef MOTIF
X    Arg textPos`5B1`5D;
X#endif
X    char *art;
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Include",`09includeHandler, (caddr_t) XRNinclude_DOIT`7D,
X`09`7B"Cancel",`09includeHandler, (caddr_t) XRNinclude_ABORT`7D,
X    `7D;
X
X#ifdef MOTIF
X    art = xmWrapTextWidget(ComposeText);
X#else
X    art = DwtSTextGetString(ComposeText);
X#endif
X    sizeCompose(utStrlen(art));
X    strcpy(CompositionString, art);
X    XtFree(art);
X#ifdef MOTIF
X#ifdef MOTIF_V10
X    InsertionPoint = XmTextGetInsertionPosition(ComposeText);
X#else
X    InsertionPoint = XmTextGetCursorPosition(ComposeText);
X#endif
X#else
X    XtSetArg(textPos`5B0`5D, DwtNinsertionPosition, (XtArgVal) &InsertionPoi
Vnt);
X    XtGetValues(ComposeText, textPos, XtNumber(textPos));
X#endif
X   `20
X    if (IncludeBox == (Widget) 0) `7B
X`09IncludeBox = CreateDialog(ComposeTopLevel,
X`09`09`09`09 "Include File Select",
X`09`09`09`09 "    File Name?    ",
X`09`09`09`09  DIALOG_TEXT, args, XtNumber(args));
X    `7D
X    PopUpDialog(IncludeBox);
X
X    return;
X`7D
X/*ARGSUSED*/
Xstatic void
XcompWrapTextFunction(widget, event, string, count)
XWidget widget;
XXEvent *event;
XString *string;
XCardinal *count;
X`7B
X    char *textString, *ptr;
X    char **wrappedLines;
X    char **lines;
X    int size;
X    int oldBreak, oldWrap;
X#ifndef MOTIF
X    Arg textPos`5B1`5D;
X#endif
X    int lineCount;
X
X    oldBreak = app_resources.breakLength;
X    if (oldBreak == 0) app_resources.breakLength = 80;
X    oldWrap = app_resources.lineLength;
X    if (oldWrap == 0) app_resources.lineLength = 72;
X
X#ifdef MOTIF
X    textString = xmWrapTextWidget(ComposeText);
X#ifdef MOTIF_V10
X    InsertionPoint = XmTextGetInsertionPosition(ComposeText);
X#else
X    InsertionPoint = XmTextGetCursorPosition(ComposeText);
X#endif
X#else
X    textString = DwtSTextGetString(ComposeText);
X    XtSetArg(textPos`5B0`5D, DwtNinsertionPosition, (XtArgVal) &InsertionPoi
Vnt);
X    XtGetValues(ComposeText, textPos, XtNumber(textPos));
X#endif
X    lines = wrappedLines = wrapText(textString, &lineCount);
X    XtFree(textString);
X
X    size = 0;
X    while (*lines) `7B
X`09size += strlen(*lines) + 1;
X`09lines++;
X    `7D
X    sizeCompose(size);
X    ptr = CompositionString;
X    strcpy(CompositionString, textString);
X
X    lines = wrappedLines;
X    while (*lines) `7B
X`09strcpy(ptr, *lines);
X`09ptr += strlen(*lines);
X`09strcpy(ptr, "\n");
X`09ptr++;
X`09FREE(*lines);
X`09lines++;
X    `7D
X    FREE(wrappedLines);
X
X#ifdef MOTIF
X    XmTextSetString(ComposeText,CompositionString);
X#ifndef MOTIF_V10
X    XmTextSetCursorPosition(ComposeText, (XmTextPosition) InsertionPoint);
X#endif
X    XmTextSetInsertionPosition(ComposeText, (XmTextPosition) InsertionPoint)
V;
X#else
X    DwtSTextSetString(ComposeText,CompositionString);
X    XtSetArg(textPos`5B0`5D, DwtNinsertionPosition,
X`09(XtArgVal) InsertionPoint);
X    XtSetValues(ComposeText, textPos, XtNumber(textPos));
X#endif
X    app_resources.breakLength = oldBreak;
X    app_resources.lineLength = oldWrap;
X`7D
X
X/*ARGSUSED*/
Xstatic void
XcompRot13Function(widget, event, string, count)
XWidget widget;
XXEvent *event;
XString *string;
XCardinal *count;
X`7B
X    char *textString, *ptr;
X#ifndef MOTIF
X    Arg textPos`5B1`5D;
X#endif
X
X#ifdef MOTIF
X    textString = XmTextGetString(ComposeText);
X#ifdef MOTIF_V10
X    InsertionPoint = XmTextGetInsertionPosition(ComposeText);
X#else
X    InsertionPoint = XmTextGetCursorPosition(ComposeText);
X#endif
X#else
X    textString = DwtSTextGetString(ComposeText);
X    XtSetArg(textPos`5B0`5D, DwtNinsertionPosition, (XtArgVal) &InsertionPoi
Vnt);
X    XtGetValues(ComposeText, textPos, XtNumber(textPos));
X#endif
X    for (ptr = textString; *ptr != '\0'; ptr++) `7B
X`09if (isalpha(*ptr)) `7B
X`09    if ((*ptr & 31) <= 13) `7B
X`09`09*ptr = *ptr + 13;
X`09    `7D else `7B
X`09`09*ptr = *ptr - 13;
X`09    `7D
X`09`7D
X    `7D
X
X#ifdef MOTIF
X    XmTextSetString(ComposeText,textString);
X#ifndef MOTIF_V10
X    XmTextSetCursorPosition(ComposeText, (XmTextPosition) InsertionPoint);
X#endif
X    XmTextSetInsertionPosition(ComposeText, (XmTextPosition) InsertionPoint)
V;
X#else
X    DwtSTextSetString(ComposeText,textString);
X    XtSetArg(textPos`5B0`5D, DwtNinsertionPosition,
X`09(XtArgVal) InsertionPoint);
X    XtSetValues(ComposeText, textPos, XtNumber(textPos));
X#endif
X    XtFree(textString);
X`7D
X
Xstatic struct stat originalBuf;
Xstatic char FileName`5B512`5D;
X
X/* Must reset ComposeActive here, unless we call editMessage() again - ggh *
V/
X/* ARGSUSED */
Xstatic Boolean
XprocessMessage()
X`7B
X    FILE *filefp;
X    struct stat buf;
X    char *ptr, *msg_type, *confirm1, *confirm2;
X    int mode;
X
X    switch (PostingMode) `7B
X`09case POST:
X`09case FOLLOWUP:
X`09case FOLLOWUPREPLY:
X`09    msg_type = "article";
X`09    confirm1 = "Post the article?";
X`09    confirm2 = "Re-edit the article?";
X`09    break;
X`09default:
X`09    msg_type= "message";
X`09    confirm1 = "Send the message?";
X`09    confirm2 = "Re-edit the message?";
X`09    break;
X    `7D
X    if ((filefp = fopen(FileName, "r")) == NULL) `7B
X`09mesgPane(XRN_SERIOUS, "Cannot open the temp file (%s)", errmsg(errno));
X`09freeHeader();
X`09ComposeActive = False;`09`09`09`09`09    /* ggh */
X`09return True;
X    `7D
X
X    if (fstat(fileno(filefp), &buf) == -1) `7B
X`09mesgPane(XRN_SERIOUS, "Cannot stat the temp file (%s)", errmsg(errno));
X`09(void) fclose(filefp);
X`09(void) unlink(FileName);
X`09freeHeader();
X`09ComposeActive = False;`09`09`09`09`09    /* ggh */
X`09return True;
X    `7D
X
X    if (originalBuf.st_mtime == buf.st_mtime) `7B
X`09mesgPane(XRN_INFO, "No change, %s aborted.", msg_type);
X`09(void) fclose(filefp);
X`09(void) unlink(FileName);
X`09freeHeader();
X`09ComposeActive = False;`09`09`09`09`09    /* ggh */
X`09return True;
X    `7D
X
X    if (buf.st_size == 0) `7B
X`09mesgPane(XRN_INFO, "Zero size, %s aborted", msg_type);
X`09(void) fclose(filefp);
X`09(void) unlink(FileName);
X`09freeHeader();
X`09ComposeActive = False;`09`09`09`09`09    /* ggh */
X`09return True;
X    `7D
X
X    sizeCompose(buf.st_size+1);
X    ptr = ARRAYALLOC(char, (buf.st_size + 100));
X    (void) fread(ptr, sizeof(char), buf.st_size, filefp);
X    ptr`5Bbuf.st_size`5D = '\0';
X    (void) fclose(filefp);
X    stripBlankFields(ptr);
X    stripHeaderField(ptr);
X    strcpy(HeaderString, ptr);
X
X    /* pop up a confirm box */
X    if (((app_resources.confirmMode & COMP_POST) == 0) &&
X`09ConfirmationBox(TopLevel, confirm1) == XRN_CB_ABORT) `7B
X`09if (ConfirmationBox(TopLevel, confirm2) == XRN_CB_ABORT) `7B
X`09    mesgPane(XRN_SERIOUS, "Aborting the %s, saving to %s",
X`09`09     msg_type, app_resources.deadLetters);
X`09    saveDeadLetter(ptr);
X`09    FREE(ptr);
X`09    (void) unlink(FileName);`09`09`09`09    /* ggh */
X`09    freeHeader();
X`09    ComposeActive = False;`09`09`09`09    /* ggh */
X`09`7D else `7B
X`09    FREE(ptr);
X`09    editMessage(True, NULL);
X`09`7D
X`09return True;
X    `7D
X`09
X    /* send to the proper processor */
X    if ((PostingMode == GRIPE) `7C`7C
X`09(PostingMode == FORWARD) `7C`7C
X`09(PostingMode == REPLY)) `7B
X`09mode = XRN_MAIL;
X    `7D else `7B
X`09mode = XRN_NEWS;
X    `7D
X   `20
X    switch (postArticle(ptr, mode)) `7B
X`09case POST_FAILED:
X`09    XBell(XtDisplay(TopLevel), 0);
X`09    mesgPane(XRN_SERIOUS, "Could not send, saving in %s",
X`09`09 app_resources.deadLetters);
X`09    saveDeadLetter(ptr);
X`09    FREE(ptr);
X`09    (void) unlink(FileName);
X`09    freeHeader();
X`09    ComposeActive = False;
X`09    return True;
X   `20
X`09case POST_NOTALLOWED:
X`09    mesgPane(XRN_SERIOUS,
X`09`09"Posting not allowed from this machine, saving in %s",
X`09`09     app_resources.deadLetters);
X`09    (void) unlink(FileName);
X`09    freeHeader();
X`09    ComposeActive = False;
X`09    break;
X`09
X`09case POST_TRYAGAIN:
X`09    if (ConfirmationBox(TopLevel, confirm2) == XRN_CB_ABORT) `7B
X`09`09mesgPane(XRN_SERIOUS, "Aborting the %s, saving to %s",
X`09`09     msg_type, app_resources.deadLetters);
X`09`09saveDeadLetter(ptr);
X`09`09(void) unlink(FileName);
X`09`09freeHeader();
X`09`09ComposeActive = False;
X`09    `7D else `7B
X`09`09if (editMessage(True, NULL) == -1) `7B
X`09`09    FREE(ptr);
X`09`09    (void) unlink(FileName);
X`09`09    freeHeader();
X`09`09    ComposeActive = False;
X`09`09    return True;
X`09`09`7D
X`09    `7D
X`09    break;
X`09
X`09case POST_OKAY:
X`09    if (PostingMode == FOLLOWUPREPLY) `7B
X`09`09sendFollowupMail(ptr);
X`09    `7D
X`09    switch (mode) `7B
X`09`09case XRN_NEWS:
X`09`09    mesgPane(XRN_INFO, "Article Posted");
X`09`09    (void) unlink(FileName);
X`09`09    freeHeader();
X`09`09    ComposeActive = False;
X`09`09    break;
X
X`09`09case XRN_MAIL:
X`09`09    mesgPane(XRN_INFO, "Mail Message Sent");
X`09`09    (void) unlink(FileName);
X`09`09    ComposeActive = False;
X`09`09    break;
X`09    `7D
X`09    break;
X    `7D
X    FREE(ptr);
X    return True;
X`7D
X
X
Xstatic int forkpid;`20
X
X#ifndef VMS
X#ifdef __STDC__
Xstatic void
Xcatch_sigchld(signo)
Xint signo;
X`7B
X    if (signo != SIGCHLD) `7B
X`09/* whoops! */
X`09return;
X    `7D
X    (void) signal(SIGCHLD, SIG_DFL);
X    if (forkpid != wait(0)) `7B
X`09/* whoops! */
X`09return;
X    `7D
X    XtAddWorkProc((XtWorkProc)processMessage, NULL);
X    /* Don't clobber file name - user might want to re-edit the file.  ggh *
V/
X    /* FileName`5B0`5D = '\0'; `09`09`09`09`09       ggh */
X    return;
X`7D
X#else
Xstatic int
Xcatch_sigchld(signo)
Xint signo;
X`7B
X    if (signo != SIGCHLD) `7B
X`09/* whoops! */
X`09return 1;
X    `7D
X    (void) signal(SIGCHLD, SIG_DFL);
X    if (forkpid != wait(0)) `7B
X`09/* whoops! */
X`09return 1;
X    `7D
X    XtAddWorkProc((XtWorkProc)processMessage, NULL);
X    /* Don't clobber file name - user might want to re-edit the file.  ggh *
V/
X    /* FileName`5B0`5D = '\0'; `09`09`09`09`09       ggh */
X    return 1;
X`7D
X#endif /* __STDC__ */
X#else /* VMS */
Xstatic void
XspawnDone() `7B
X
X    if ((spawnStat & 1) != 1) `7B
X`09mesgPane(XRN_SERIOUS, "Error return from editor command - %d",
X`09`09spawnStat);
X    `7D
X    XtAddWorkProc((XtWorkProc)processMessage, NULL);
X`7D
X#endif
X
X/*
X * definition of the buttons
X */
Xextern int inCommand;
X
X#ifndef MOTIF
X#define XmNlabelString DwtNlabel
X#define XmNactivateCallback DwtNactivateCallback
X#define XmNborderWidth DwtNborderWidth
X#endif
X
XBUTTON(compAbort)
XBUTTON(compSend)
XBUTTON(compSave)
XBUTTON(compIncludeArticle)
XBUTTON(compIncludeCurrent)
XBUTTON(compIncludeFile)
XBUTTON(compWrapText)
XBUTTON(compRot13)
X
Xstatic XtActionsRec ComposeActions`5B`5D = `7B
X    `7B"composeAbort", (XtActionProc) compAbortAction`7D,
X    `7B"composeSend",  (XtActionProc) compSendAction`7D,
X    `7B"composeSave",   (XtActionProc) compSaveAction`7D,
X    `7B"composeIncludeCurrent", (XtActionProc) compIncludeCurrentAction`7D,
X    `7B"composeIncludeArticle", (XtActionProc) compIncludeArticleAction`7D,
X    `7B"composeIncludeFile", (XtActionProc) compIncludeFileAction`7D,
X    `7B"composeWrapText", (XtActionProc) compWrapTextAction`7D,
X    `7B"composeRot13", (XtActionProc) compRot13Action`7D,
X`7D;
X
X/* Used to fork editors when the widget editor is not being used. */
X
Xstatic int editMessage(reEdit, header)
XBoolean reEdit;
Xchar *header;
X`7B
X    char buffer`5B1024`5D;
X    FILE *filefp;
X    int sysStat;
X    int maxdesc;
X#ifdef VMS
X    struct dsc$descriptor_s cmd_desc;
X    int one = 1;`09`09/* cli$m_nowait */
X#endif
X
X    if (!reEdit) `7B
X`09(void) sprintf(buffer, "%sxrnXXXXXXX", app_resources.tmpDir);
X`09(void) mktemp(buffer);
X`09(void) sprintf(FileName, "%s.tmp", buffer);
X`09
X`09if ((filefp = fopen(FileName, "w")) == NULL) `7B
X`09    mesgPane(XRN_SERIOUS, "Can not open the temp file (%s)", errmsg(errno
V));
X`09    return(-1);
X`09`7D
X
X`09sizeCompose(utStrlen(header) + 100);
X`09(void) strcpy(CompositionString, HeaderString);
X`09(void) strcat(CompositionString, header);
X
X`09if ((PostingMode != FORWARD) && (PostingMode != POST) &&
X`09    (PostingMode != GRIPE)) `7B
X`09    includeArticleText();
X`09`7D`09   `20
X   `20
X`09(void) fwrite(CompositionString, sizeof(char), utStrlen(CompositionString
V), filefp);
X`09(void) fclose(filefp);
X`09/* Stat the file only at first edit, not at re-edits.`09       ggh */
X`09if (stat(FileName, &originalBuf) == -1) `7B`09`09    /* ggh */
X`09    mesgPane(XRN_SERIOUS, "Can not stat the temp file");    /* ggh */
X`09    return(-1);`09`09`09`09`09`09    /* ggh */
X`09`7D`09`09`09`09`09`09`09    /* ggh */
X    `7D
X`09
X    /*
X     * app_resources.editorCommand is a sprintf'able string with a %s where
V the
X     * file name should be placed.  The result should be a command that
X     * handles all editing and windowing.
X     *
X     * Examples are:
X     *
X     *   emacsclient %s
X     *   xterm -e vi %s
X     *   xterm -e microEmacs %s
X     *
X     */
X     (void) sprintf(buffer, app_resources.editorCommand, FileName);
X#ifndef VMS
X#ifdef VFORK_SUPPORTED
X    if ((forkpid = vfork()) == 0) `7B
X#else
X    if ((forkpid = fork()) == 0) `7B
X#endif
X`09int i;
X
X#ifdef hpux
X`09maxdesc = _NFILE;
X#else
X#ifdef SVR4
X#include <ulimit.h>
X`09maxdesc = ulimit(UL_GDESLIM);
X#else
X`09maxdesc = getdtablesize();
X#endif
X#endif
X`09for (i = 3; i < maxdesc; i++) `7B
X`09    (void) close(i);
X`09`7D
X`09(void) execl("/bin/csh", "csh", "-f", "-c", buffer, 0);
X`09(void) fprintf(stderr, "execl of %s failed\n", buffer);
X`09(void) _exit(127);
X    `7D
X    if (forkpid < 0) `7B
X`09sprintf(error_buffer, "Can not execute editor (%s)", errmsg(errno));
X`09infoNow(error_buffer);
X`09/* ComposeActive = False; /* Done in composePane()`09       ggh */
X`09unlink (FileName);`09  /* instead of FileName`5B0`5D = '\0'     ggh */
X`09return -1;`09`09  /* Tell composePane that we failed   ggh */
X    `7D else `7B
X#ifdef __STDC__
X`09signal(SIGCHLD, catch_sigchld);
X#else
X`09signal(SIGCHLD, (SIG_PF0) catch_sigchld);
X#endif
X    `7D
X#else
X    cmd_desc.dsc$b_class = DSC$K_CLASS_S;
X    cmd_desc.dsc$b_dtype = DSC$K_DTYPE_T;
X    cmd_desc.dsc$w_length = strlen(buffer);
X    cmd_desc.dsc$a_pointer = buffer;
X
X    sysStat = lib$spawn(&cmd_desc,0,0,&one,0,0, &spawnStat,0,spawnDone);
X    if ((sysStat & 1) != 1) `7B
X`09mesgPane(XRN_SERIOUS, "Error return from spawn - %d, aborting",
X`09`09sysStat);
X`09return(-1);
X    `7D
X#endif
X    return 1;
X`7D
X
X/*
X * brings up a new vertical pane, not moded, but maintains
X * enough state so that the current group and/or current
X * article can be changed
X *
X * only one compose pane at a time
X *
X * the pane consists of 4 parts: title bar, header window,
X * scrollable text window,  button box
X *
X * seven functions:
X *    post article
X *    followup article
X *    reply to author
X *    include the text of the article (followup and reply)
X *    include a file
X *    send a gripe
X *    forward a message
X */
Xstatic int
XcomposePane(titleString, header)
Xchar *titleString;
Xchar *header;
X`7B
X    Widget pane, buttonBox;
X    int i;
X    Arg paneArgs`5B15`5D;
X    Dimension paneWidth;
X    static Arg layoutArgs`5B`5D = `7B`09`09`09/* main window description */
X`09`09`09`09`09`09/* args set from geometry and */
X`09`7BXtNx,`09`09`09(XtArgVal) 10`7D,`09/* must stay in x/y/w/h order */
X`09`7BXtNy, `09`09`09(XtArgVal) 10`7D,
X#ifdef MOTIF
X`09`7BXtNwidth, `09`09(XtArgVal) 10`7D,
X`09`7BXtNheight, `09`09(XtArgVal) 10`7D,
X#else
X`09`7BDwtNwidth,`09`09(XtArgVal) 600`7D,
X`09`7BDwtNheight,`09`09(XtArgVal) 700`7D,
X#endif
X    `7D;
X#ifdef MOTIF
X    static Arg boxArgs`5B`5D = `7B
X`09`7BXmNresizeHeight,`09(XtArgVal) True`7D,
X`09`7BXmNresizeWidth,`09(XtArgVal) False`7D,
X`09`7BXmNadjustLast, `09(XtArgVal) False`7D,
X`09`7BXmNorientation,`09(XtArgVal) XmHORIZONTAL`7D,
X`09`7BXmNpacking,`09`09(XtArgVal) XmPACK_TIGHT`7D,
X    `7D;
X    static Arg headerArgs`5B`5D = `7B
X`09`7BXmNcolumns,`09`09(XtArgVal) 80`7D,
X`09`7BXmNrows,`09`09(XtArgVal) 10`7D,
X`09`7BXmNscrollVertical, `09(XtArgVal) TRUE`7D,
X`09`7BXmNeditMode,  `09`09(XtArgVal) XmMULTI_LINE_EDIT`7D,
X`09`7BXmNpendingDelete,`09(XtArgVal) True`7D,
X    `7D;
X    static Arg textArgs`5B`5D = `7B
X`09`7BXmNcolumns,`09`09(XtArgVal) 80`7D,
X`09`7BXmNrows,`09`09(XtArgVal) 30`7D,
X`09`7BXmNscrollVertical, `09(XtArgVal) TRUE`7D,
X`09`7BXmNeditMode,  `09`09(XtArgVal) XmMULTI_LINE_EDIT`7D,
X`09`7BXmNpendingDelete,`09(XtArgVal) True`7D,
X    `7D;
X
X    static Arg frameArgs`5B`5D = `7B
X`09`7BXmNshadowType,`09`09(XtArgVal) XmSHADOW_OUT`7D,
X    `7D;
X#else /* MOTIF */
X    Arg textPos`5B1`5D;
X
X   `20
X    static Arg boxArgs`5B`5D = `7B
X`09`7BDwtNresizeHeight,`09(XtArgVal) True`7D,
X`09`7BDwtNresizeWidth,`09(XtArgVal) False`7D,
X`09`7BDwtNorientation,`09(XtArgVal) DwtOrientationHorizontal`7D,
X`09`7BDwtNmenuPacking,`09(XtArgVal) DwtMenuPackingTight`7D,
X`09`7BDwtNmenuExtendLastRow, (XtArgVal) False`7D,
X`09`7BDwtNborderWidth,`09(XtArgVal) 3`7D,
X`09`7BDwtNentryBorder,`09(XtArgVal) 2`7D,
X`09`7BDwtNspacing,`09`09(XtArgVal) 2`7D,
X`09`7BDwtNchildOverlap,`09(XtArgVal) False`7D,
X`09`7BDwtNmenuNumColumns,`09(XtArgVal) 1`7D,
X`09`7BDwtNmin,`09`09(XtArgVal) 30`7D,
X`09`7BDwtNmenuType,`09`09(XtArgVal) DwtWorkarea`7D,
X    `7D;
X    static Arg headerArgs`5B`5D = `7B
X`09`7BDwtNcols,`09`09(XtArgVal) 80`7D,
X`09`7BDwtNrows,`09`09(XtArgVal) 10`7D,
X`09`7BDwtNwordWrap,`09`09(XtArgVal) TRUE`7D,
X`09`7BDwtNscrollVertical,`09(XtArgVal) TRUE`7D,
X    `7D;
X    static Arg textArgs`5B`5D = `7B
X`09`7BDwtNcols,`09`09(XtArgVal) 80`7D,
X`09`7BDwtNrows,`09`09(XtArgVal) 30`7D,
X`09`7BDwtNwordWrap, `09`09(XtArgVal) TRUE`7D,
X`09`7BDwtNscrollVertical,`09(XtArgVal) TRUE`7D,
X    `7D;
X
X#endif /* MOTIF */
X    if (ComposeActive) `7B
X`09mesgPane(XRN_SERIOUS, "Only one composition pane at a time");
X`09return(-1);
X    `7D
X
X    if (app_resources.editorCommand != NIL(char)) `7B
X`09ComposeActive = True;
X`09if (editMessage(False, header) == -1)`7B
X`09    ComposeActive = False;
X`09    return -1;
X`09`7D
X`09/* We aren't done composing until we get a SIGCHLD -`09       ggh */
X`09/* ComposeActive = False;`09`09`09`09       ggh */
X`09return(0);
X    `7D
X   `20
X    ComposeActive = True;
X    if (ComposeTopLevel != (Widget) 0) `7B
X`09i = 0;
X#ifdef MOTIF
X`09XtSetArg(paneArgs`5Bi`5D, XmNtitle,`09`09(XtArgVal) titleString);i++;
X#else
X`09XtSetArg(paneArgs`5Bi`5D, DwtNtitle,`09(XtArgVal) titleString);i++;
X#endif
X`09XtSetValues(ComposeTopLevel, paneArgs, i);
X    `7D else `7B
X`09i = 0;
X#ifdef MOTIF
X`09XtSetArg(paneArgs`5Bi`5D, XtNinput, `09(XtArgVal) True); i++;
X`09XtSetArg(paneArgs`5Bi`5D, XmNiconName, `09(XtArgVal) "XRN Compose"); i++;
X`09XtSetArg(paneArgs`5Bi`5D, XmNtransient,`09(XtArgVal) False); i++;
X`09XtSetArg(paneArgs`5Bi`5D, XmNtitle,`09`09(XtArgVal) titleString); i++;
X`09XtSetArg(paneArgs`5Bi`5D, XmNcursorPositionVisible, (XtArgVal) True); i++
V;
X#else
X`09XtSetArg(paneArgs`5Bi`5D, XtNinput, `09(XtArgVal) True); i++;
X`09XtSetArg(paneArgs`5Bi`5D, XtNallowShellResize, (XtArgVal) True); i++;
X`09XtSetArg(paneArgs`5Bi`5D, DwtNtitle,`09(XtArgVal) titleString);i++;
X#endif
X
X`09ComposeTopLevel = XtCreatePopupShell("composeTop",`20
X`09`09`09`09`09 topLevelShellWidgetClass,
X`09`09`09`09`09 TopLevel,
X`09`09`09`09`09 paneArgs, i);
X
X`09if (app_resources.compLayout) `7B
X`09    xthTranslateGeometry(app_resources.compLayout, layoutArgs);
X`09    XtSetValues(ComposeTopLevel, layoutArgs, XtNumber(layoutArgs));
X`09`7D
X
X#ifdef MOTIF
X`09pane = XtCreateManagedWidget("pane", xmPanedWindowWidgetClass,
X`09`09`09`09`09ComposeTopLevel, NULL, 0);
X#else
X`09i = 0;
X`09XtSetArg(paneArgs`5Bi`5D, DwtNwidth,`09(XtArgVal) 680);i++;
X`09XtSetArg(paneArgs`5Bi`5D, DwtNheight,`09(XtArgVal) 600);i++;
X`09pane = XtCreateManagedWidget("pane", panewidgetclass,
X`09`09`09`09`09ComposeTopLevel, paneArgs, i);
X#endif
X
X    /* XXX how to make a 80 column text window with scroll bar */
X`09if (app_resources.breakLength > 39) `7B
X            headerArgs`5B0`5D.value = (XtArgVal) app_resources.breakLength;
V /* set cols */
X`09    textArgs`5B0`5D.value = (XtArgVal) app_resources.breakLength;
X`09`7D else `7B
X`09    headerArgs`5B0`5D.value = (XtArgVal) 80;
X`09    textArgs`5B0`5D.value = (XtArgVal) 80;
X`09`7D
X`09if (app_resources.composeRows > 0) `7B
X`09    textArgs`5B1`5D.value = (XtArgVal) app_resources.composeRows;
X`09`7D
X#ifdef MOTIF
X`09headerFrame = XtCreateManagedWidget("headerFrame", xmFrameWidgetClass,
X`09`09`09`09`09pane, frameArgs,XtNumber(frameArgs));
X`09HeaderText = XmCreateScrolledText(headerFrame, "headerText",
X`09`09`09`09`09headerArgs, XtNumber(headerArgs));
X`09fitFrameToContents(headerFrame, HeaderText);
X#else
X`09HeaderText = DwtSTextCreate(pane, "headerText",
X`09`09`09`09`09headerArgs, XtNumber(headerArgs));
X#endif
X`09XtManageChild(HeaderText);
X#ifdef MOTIF
X`09textFrame = XtCreateManagedWidget("textFrame", xmFrameWidgetClass,
X`09`09`09`09`09pane, frameArgs,XtNumber(frameArgs));
X`09ComposeText = XmCreateScrolledText(textFrame, "composeText",`20
X`09`09`09`09`09textArgs, XtNumber(textArgs));
X`09fitFrameToContents(textFrame, ComposeText);
X#else
X`09ComposeText = DwtSTextCreate(pane, "composeText",`20
X`09`09`09`09`09textArgs, XtNumber(textArgs));
X#endif
X`09XtManageChild(ComposeText);
X#ifdef MOTIF
X`09buttonBox = XtCreateManagedWidget("box", xmRowColumnWidgetClass,
X`09`09pane, boxArgs, XtNumber(boxArgs));
X#else
X`09buttonBox = DwtMenuCreate(pane, "box", boxArgs, XtNumber(boxArgs));
X`09XtManageChild(buttonBox);
X
X`09paneWidth = 0;
X`09XtSetArg(paneArgs`5B0`5D, DwtNwidth, &paneWidth);
X`09XtGetValues(ComposeText, paneArgs, 1);
X`09XtSetArg(paneArgs`5B0`5D, DwtNwidth, paneWidth);
X`09XtSetValues(pane, paneArgs, 1);
X#endif
X
X`09if (compAbortArgs`5B1`5D.value == (XtArgVal) NULL) `7B
X#ifdef MOTIF
X`09    compAbortArgs`5B1`5D.value = (XtArgVal)XmStringLtoRCreate("Cancel",
X`09`09`09XmSTRING_DEFAULT_CHARSET);
X#else
X`09    compAbortArgs`5B1`5D.value = (XtArgVal)DwtLatin1String("Cancel");
X#endif
X`09`7D
X#ifdef MOTIF
X`09AbortButton = XtCreateManagedWidget("abort", xmPushButtonWidgetClass,
X`09`09`09buttonBox, compAbortArgs, XtNumber(compAbortArgs));
X   `20
X`09paneWidth = 0;
X`09XtSetArg(paneArgs`5B0`5D, XmNheight, &paneWidth);
X`09XtGetValues(AbortButton, paneArgs, 1);
X`09PaneSetMinMax(buttonBox, paneWidth, paneWidth+5);
X#else
X`09AbortButton = XtCreateManagedWidget("abort", pushbuttonwidgetclass,
X`09`09`09buttonBox, compAbortArgs, XtNumber(compAbortArgs));
X#endif
X`09if (compSendArgs`5B1`5D.value == (XtArgVal) NULL) `7B
X#ifdef MOTIF
X`09    compSendArgs`5B1`5D.value = (XtArgVal)XmStringLtoRCreate("Send",
X`09`09`09XmSTRING_DEFAULT_CHARSET);
X#else
X`09    compSendArgs`5B1`5D.value = (XtArgVal)DwtLatin1String("Send");
X#endif
X`09`7D
X#ifdef MOTIF
X`09SendButton = XtCreateManagedWidget("send", xmPushButtonWidgetClass,
X`09`09`09buttonBox, compSendArgs, XtNumber(compSendArgs));
X#else
X`09SendButton = XtCreateManagedWidget("send", pushbuttonwidgetclass,
X`09`09`09buttonBox, compSendArgs, XtNumber(compSendArgs));
X#endif
X   `20
X`09if (compSaveArgs`5B1`5D.value == (XtArgVal) NULL) `7B
X#ifdef MOTIF
X`09    compSaveArgs`5B1`5D.value = (XtArgVal)XmStringLtoRCreate("Save",
X`09`09`09XmSTRING_DEFAULT_CHARSET);
X#else
X`09    compSaveArgs`5B1`5D.value = (XtArgVal)DwtLatin1String("Save");
X#endif
X`09`7D
X#ifdef MOTIF
X`09SaveButton = XtCreateManagedWidget("save", xmPushButtonWidgetClass,
X`09`09`09buttonBox, compSaveArgs, XtNumber(compSaveArgs));
X#else
X`09SaveButton = XtCreateManagedWidget("save", pushbuttonwidgetclass,
X`09`09`09buttonBox, compSaveArgs, XtNumber(compSaveArgs));
X#endif
X
X`09if (compIncludeFileArgs`5B1`5D.value == (XtArgVal) NULL) `7B
X#ifdef MOTIF
X`09    compIncludeFileArgs`5B1`5D.value = (XtArgVal) XmStringLtoRCreate(
X`09`09`09"Include File",
X`09`09`09XmSTRING_DEFAULT_CHARSET);
X#else
X`09    compIncludeFileArgs`5B1`5D.value = (XtArgVal)DwtLatin1String(
X`09`09`09"Include File");
X#endif
X`09`7D
X#ifdef MOTIF
X`09IncludeFileButton = XtCreateManagedWidget("includeFile",
X`09`09`09xmPushButtonWidgetClass, buttonBox,
X`09`09`09compIncludeFileArgs, XtNumber(compIncludeFileArgs));
X#else
X`09IncludeFileButton = XtCreateManagedWidget("includeFile",
X`09`09`09pushbuttonwidgetclass, buttonBox,
X`09`09`09compIncludeFileArgs, XtNumber(compIncludeFileArgs));
X#endif
X
X`09if (compIncludeArticleArgs`5B1`5D.value == (XtArgVal) NULL) `7B
X#ifdef MOTIF
X`09    compIncludeArticleArgs`5B1`5D.value = (XtArgVal)XmStringLtoRCreate(
X`09`09`09"Include Article",
X`09`09`09XmSTRING_DEFAULT_CHARSET);
X#else
X`09    compIncludeArticleArgs`5B1`5D.value = (XtArgVal)DwtLatin1String(
X`09`09 `09"Include Article");
X#endif
X`09`7D
X#ifdef MOTIF
X`09IncludeArticleButton = XtCreateManagedWidget("includeArticle",
X`09`09`09xmPushButtonWidgetClass, buttonBox,
X`09`09`09compIncludeArticleArgs, XtNumber(compIncludeArticleArgs));
X#else
X`09IncludeArticleButton = XtCreateManagedWidget("includeArticle",
X`09`09`09pushbuttonwidgetclass, buttonBox,
X`09`09`09compIncludeArticleArgs, XtNumber(compIncludeArticleArgs));
X#endif
X`09if (compIncludeCurrentArgs`5B1`5D.value == (XtArgVal) NULL) `7B
X#ifdef MOTIF
X`09    compIncludeCurrentArgs`5B1`5D.value = (XtArgVal)XmStringLtoRCreate(
X`09`09`09"Include Current",
X`09`09`09XmSTRING_DEFAULT_CHARSET);
X#else
X`09    compIncludeCurrentArgs`5B1`5D.value = (XtArgVal)DwtLatin1String(
X`09`09`09"Include Current");
X#endif
X`09`7D
X#ifdef MOTIF
X`09IncludeCurrentButton = XtCreateManagedWidget("includeCurrent",
X`09`09`09xmPushButtonWidgetClass, buttonBox,
X`09`09`09compIncludeCurrentArgs, XtNumber(compIncludeCurrentArgs));
X#else
X`09IncludeCurrentButton = XtCreateManagedWidget("includeCurrent",
X`09`09`09pushbuttonwidgetclass, buttonBox,
X`09`09`09compIncludeCurrentArgs, XtNumber(compIncludeCurrentArgs));
X#endif
X`09if (compWrapTextArgs`5B1`5D.value == (XtArgVal) NULL) `7B
X#ifdef MOTIF
X`09    compWrapTextArgs`5B1`5D.value = (XtArgVal)XmStringLtoRCreate(
X`09`09`09"Word Wrap Text",
X`09`09`09XmSTRING_DEFAULT_CHARSET);
X#else
X`09    compWrapTextArgs`5B1`5D.value = (XtArgVal)DwtLatin1String(
X`09`09`09"Word Wrap Text");
X#endif
X`09`7D
X#ifdef MOTIF
X`09WrapTextButton = XtCreateManagedWidget("wrapText",
X`09`09`09xmPushButtonWidgetClass, buttonBox,
X`09`09`09compWrapTextArgs, XtNumber(compWrapTextArgs));
X#else
X`09WrapTextButton = XtCreateManagedWidget("wrapText",
X`09`09`09pushbuttonwidgetclass, buttonBox,
X`09`09`09compWrapTextArgs, XtNumber(compWrapTextArgs));
X#endif
X`09if (compRot13Args`5B1`5D.value == (XtArgVal) NULL) `7B
X#ifdef MOTIF
X`09    compRot13Args`5B1`5D.value = (XtArgVal)XmStringLtoRCreate(
X`09`09`09"Rot-13",
X`09`09`09XmSTRING_DEFAULT_CHARSET);
X#else
X`09    compWrapTextArgs`5B1`5D.value = (XtArgVal)DwtLatin1String(
X`09`09`09"Rot-13");
X#endif
X`09`7D
X#ifdef MOTIF
X`09Rot13Button = XtCreateManagedWidget("rot13",
X`09`09`09xmPushButtonWidgetClass, buttonBox,
X`09`09`09compRot13Args, XtNumber(compRot13Args));
X#else
X`09Rot13Button = XtCreateManagedWidget("rot13",
X`09`09`09pushbuttonwidgetclass, buttonBox,
X`09`09`09compRot13Args, XtNumber(compRot13Args));
X#endif
X`09xmIconCreate(ComposeTopLevel);
X`09XtAddActions(ComposeActions, XtNumber(ComposeActions));
X    `7D
X
X    sizeCompose(utStrlen(header));
X    (void) strcpy(CompositionString, header);
X#ifdef MOTIF
X    XmTextSetString(HeaderText,HeaderString);
X    XmTextSetString(ComposeText,CompositionString);
X#ifndef MOTIF_V10
X    if (EditorPosition < 0) `7B
X`09XmTextSetCursorPosition(HeaderText, -EditorPosition);
X`09XmProcessTraversal(HeaderText, XmTRAVERSE_CURRENT);
X`09XmTextSetCursorPosition(ComposeText, 0);
X    `7D else `7B
X`09XmTextSetCursorPosition(ComposeText, (XmTextPosition) EditorPosition);
X`09XmTextSetCursorPosition(HeaderText, 0);
X`09XmProcessTraversal(ComposeText, XmTRAVERSE_CURRENT);
X    `7D
X#endif /* MOTIF_V10 */
X#else /* MOTIF */
X    DwtSTextSetString(HeaderText,HeaderString);
X    DwtSTextSetString(ComposeText,CompositionString);
X    if (EditorPosition < 0) `7B
X`09XtSetArg(textPos`5B0`5D, DwtNinsertionPosition, (XtArgVal) -EditorPositio
Vn);
X`09XtSetValues(HeaderText, textPos, XtNumber(textPos));
X    `7D else `7B
X`09XtSetArg(textPos`5B0`5D, DwtNinsertionPosition, (XtArgVal) EditorPosition
V);
X`09XtSetValues(ComposeText, textPos, XtNumber(textPos));
X    `7D
X#endif /* MOTIF */
X
X    XtSetSensitive(SendButton, True);
X    XtSetSensitive(SaveButton, True);
X    XtSetSensitive(IncludeFileButton, True);
X    XtSetSensitive(IncludeArticleButton, (PostingMode != POST));
X    XtSetSensitive(IncludeCurrentButton, True);
X    XtSetSensitive(WrapTextButton, True);
X    XtSetSensitive(Rot13Button, True);
X    XtRealizeWidget(ComposeTopLevel);
X   `20
X
X    XtPopup(ComposeTopLevel, XtGrabNone);
X
X    return(0);
X`7D
X
X/*
X * return a string containing the contents of the users signature file
X *   (in a static buffer)
X *
X * if the signature file is bigger than MAX_SIGNATURE_SIZE, return NIL(char)
V.
X */
Xstatic char *signatureFile()
X`7B
X    char *file;
X    FILE *infofp;
X    int (*close_func)() = 0;
X    long count;
X    static char info`5BMAX_SIGNATURE_SIZE+5`5D;
X    static char *retinfo;
X    static char *sigfile = NULL;
X    char *artfile = NULL;
X    FILE *fpsave;
X    Boolean execSig;
X
X#if defined(INEWS_READS_SIG)
X    /* these posting modes do not go through INEWS, so include the signature
V */
X    if ((PostingMode != REPLY) && (PostingMode != GRIPE)) `7B
X`09return 0;
X    `7D
X#endif /* INEWS_READS_SIG */
X
X    if (sigfile != NULL) `7B
X`09FREE(sigfile);
X    `7D
X
X    if ((file = utTildeExpand(app_resources.signatureFile)) == NIL(char)) `7
VB
X`09return NIL(char);
X    `7D
X
X    /* handle multiple signatures */
X    while (1) `7B
X`09/* find an appropriate sig */
X        struct newsgroup *newsgroup = CurrentGroup;
X`09char *psigfile = NIL(char);
X`09char *ptr;
X
X`09if (!CurrentGroup) `7B
X`09    sigfile = XtMalloc(strlen(file) + 10);
X`09`7D else `7B
X`09    /* signature according to group or hierarchy */
X`09    sigfile = XtMalloc(strlen(file) + 10 + strlen(newsgroup->name));
X`09    if (app_resources.localSignatures) `7B
X`09`09ptr = localKillFile(newsgroup, FALSE);
X`09`09if (!ptr)`20
X`09`09    ptr = file;
X`09`09(void) strcpy(sigfile, ptr);
X`09`09ptr = rindex(sigfile, '/');
X`09`09ptr`5B1`5D = 0;
X`09`09ptr = (char *) (sigfile + strlen(app_resources.expandedSaveDir));
X`09`09while ((psigfile = rindex(sigfile, '/')) != NULL) `7B
X`09`09    if (psigfile < ptr) `7B
X`09`09`09psigfile = NULL;
X`09`09`09break;
X`09`09    `7D
X`09`09    psigfile`5B0`5D = 0;
X`09`09    (void) strcat(sigfile, "/SIGNATURE");
X`09`09    if (! access(sigfile, F_OK)) `7B
X`09`09`09/* FOUND */
X`09`09`09break;
X`09`09    `7D
X`09`09    psigfile`5B0`5D = 0;
X`09`09`7D
X`09    `7D else `7B
X`09`09(void) strcpy(sigfile, file);
X`09`09(void) strcat(sigfile, "-");
X`09`09ptr = rindex(sigfile, '-');
X`09`09(void) strcat(sigfile, newsgroup->name);
X`09`09(void) strcat(sigfile, ".");
X`09`09while ((psigfile = rindex(sigfile, '.')) != NIL(char)) `7B
X`09`09    if (psigfile < ptr) `7B
X`09`09`09psigfile = NIL(char);
X`09`09`09break;
X`09`09    `7D
X`09`09    psigfile`5B0`5D = 0;
X`09`09    if (! access(sigfile, F_OK)) `7B
X`09`09`09/*FOUND*/`20
X`09`09`09break;
X`09`09    `7D
X`09`09`7D
X`09    `7D
X`09`7D
X
X`09if (psigfile != NIL(char)) `7B
X`09    /*FOUND*/
X`09    break;
X`09`7D
X
X`09/* signature according to posting mode. */
X`09(void) strcpy(sigfile, file);
X`09(void) strcat(sigfile, ".");
X`09(void) strcat(sigfile, PostingModeStrings`5BPostingMode`5D);
X
X`09if (! access(sigfile, F_OK)) `7B
X`09    /*FOUND*/
X`09    break;
X`09`7D
X
X`09(void) strcpy(sigfile, file);
X`09if (! access(sigfile, F_OK)) `7B
X`09    break;
X`09`7D else `7B
X`09    return NIL(char);
X`09`7D
X    `7D
X
X    `7B
X`09char cmdbuf`5B1024`5D;
X`09char *p = rindex(sigfile, '/');
X
X`09infofp = NIL(FILE);
X
X`09if (! p) `7B
X`09     p = sigfile;
X`09`7D else `7B
X`09     p++;
X`09`7D
X
X#ifndef VMS
X`09if (Header.artText) `7B
X`09    artfile = (char *) tempnam(NULL, "XRN");
X`09    fpsave = fopen(artfile,"w");
X`09    if (fpsave) `7B
X`09`09fputs(Header.artText, fpsave);
X`09`09(void) fclose(fpsave);
X`09    `7D else `7B
X`09`09artfile = NULL;
X`09    `7D
X`09`7D
X
X`09if (app_resources.executableSignatures && (! access(sigfile, X_OK))) `7B
X`09    if (app_resources.signatureNotify) `7B
X`09`09mesgPane(XRN_INFO, "Executing signature command %s.", sigfile);
X`09    `7D
X`09    (void) sprintf(cmdbuf, "%s %s %s %s",
X`09`09`09    sigfile,
X`09`09`09    (CurrentGroup ? CurrentGroup->name : "NIL"),
X`09`09`09    PostingModeStrings`5BPostingMode`5D,
X`09`09`09    (artfile ? artfile : "NIL"));
X`09    infofp = popen(cmdbuf, "r");
X`09    close_func = pclose;
X`09    if (!infofp) `7B
X`09`09mesgPane(XRN_SERIOUS,`20
X`09`09`09 "Cannot execute signature file %s.  Reading instead.",
X`09`09`09 sigfile);
X`09    `7D
X`09`7D else `7B
X#endif
X`09    if (app_resources.signatureNotify) `7B
X`09`09mesgPane(XRN_INFO,
X`09`09`09 "Reading signature file %s.", sigfile);
X`09    `7D
X#ifndef VMS
X`09`7D
X#endif
X
X`09if (!infofp) `7B
X`09    infofp = fopen(sigfile, "r");
X`09    close_func = fclose;
X`09    if (! infofp) `7B
X`09`09mesgPane(XRN_SERIOUS, "Cannot read signature file %s.",
X`09`09`09 sigfile);
X`09`09return NIL(char);
X`09    `7D
X`09`7D
X    `7D
X
X    (void) strcpy(info, "-- \n");
X    count = fread(&info`5B4`5D, sizeof(char), sizeof(info) - 4, infofp);
X    info`5Bcount + 4`5D = '\0';
X
X    if (! feof(infofp)) `7B
X`09/* Signature file is too big */
X`09retinfo = NIL(char);
X    `7D
X    else if (strncmp(info + 4, "--\n", 3) == 0 `7C`7C
X`09     strncmp(info + 4, "-- \n", 4) == 0) `7B
X`09retinfo = info + 4;
X    `7D else `7B
X`09retinfo = info;
X    `7D
X
X    if (artfile) `7B
X`09unlink(artfile);
X`09FREE(artfile);
X    `7D
X    (void) (*close_func)(infofp);
X
X    return retinfo;
X`7D
X
X/* public functions 'reply', 'gripe', 'forward', 'followup', and 'post' */
X
Xvoid
Xreply()
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    art_num current = newsgroup->current;
X    char title`5BLABEL_SIZE`5D;
X    char pathFormatString`5B100`5D;
X    char *message, *signature;
X    int OldPostingMode = PostingMode;
X
X    if (ComposeActive) `7B
X`09mesgPane(XRN_SERIOUS, "Only one composition pane at a time");
X`09return;
X    `7D
X    getHeader(current);
X    Header.artText = getText(current);
X
X    PostingMode = REPLY;
X    message = XtMalloc(MAX_SIGNATURE_SIZE + BUFFER_SIZE +`20
X`09`09`09utStrlen(Header.artText));
X    sizeCompose(utStrlen(Header.artText) + MAX_SIGNATURE_SIZE + BUFFER_SIZE)
V;
X
X    (void) sprintf(title, "Reply to article %ld in %s", current,
X`09`09newsgroup->name);
X   `20
X    if (app_resources.replyPath != NIL(char)) `7B
X`09if (app_resources.ccForward) `7B
X`09    sprintf(pathFormatString, "To: %s\nCc: %s\n",
X`09`09app_resources.replyPath, Header.user);
X`09`7D else `7B
X`09    if (app_resources.cc == True) `7B
X`09`09sprintf(pathFormatString, "To: %s\nCc: \n",
X`09`09`09app_resources.replyPath);
X`09    `7D else `7B
X`09`09sprintf(pathFormatString, "To: %s\n",app_resources.replyPath);
X`09    `7D
X`09`7D
X    `7D else `7B
X`09if (app_resources.ccForward) `7B
X`09    sprintf(pathFormatString, "To: %s\nCc: %s\n", "%s", Header.user);
X`09`7D else `7B
X`09    if (app_resources.cc == True) `7B
X`09`09strcpy(pathFormatString, "To: %s\nCc: \n");
X`09    `7D else `7B
X`09`09strcpy(pathFormatString, "To: %s\n");
X`09    `7D
X`09`7D
X    `7D
X    (void) sprintf(message, pathFormatString,
X`09`09   (*Header.replyTo != '\0') ? Header.replyTo : Header.from);
X
X    if (app_resources.replyTo != NIL(char)) `7B
X`09 (void) strcat(message, "Reply-To: ");
X`09 (void) strcat(message, app_resources.replyTo);
X`09 (void) strcat(message, "\n");
X    `7D
X
X    if (app_resources.extraMailHeaders) `7B
X`09 (void) sprintf(&message`5Bstrlen(message)`5D,
X`09`09`09"X-Newsgroups: %s\nIn-reply-to: %s\n",
X`09`09`09Header.newsgroups, Header.messageId);
X    `7D
X
X    buildSubject(message);
X    if (app_resources.editorCommand != NULL) `7B
X`09(void) strcat(message,
X  `09`09"-=-=-=-= Enter your text below this line ");
X`09(void) strcat(message, "(don't delete this line) =-=-=-=-\n");
X    `7D
X    (void) strcat(message, "\n");
X    InsertionPoint = utStrlen(message);
X    (void) strcat(message, "\n");
X    strcpy(HeaderString, message);
X    message`5B0`5D = '\0';
X    EditorPosition = 0;
X    if ((signature = signatureFile()) != NIL(char)) `7B
X`09(void) strcpy(message, "\n");
X`09(void) strcat(message, signature);
X    `7D
X    if (composePane(title, message))
X`09 PostingMode = OldPostingMode;
X
X    FREE(message);
X    return;
X`7D
X
X
Xvoid
Xgripe()
X`7B
X    char title`5BLABEL_SIZE`5D;
X    char message`5BMAX_SIGNATURE_SIZE + 10000`5D, *signature;
X    int OldPostingMode = PostingMode;
X    char gripeTo`5B200`5D;
X   `20
X    if (ComposeActive) `7B
X`09mesgPane(XRN_SERIOUS, "Only one composition pane at a time");
X`09return;
X    `7D
X    sizeCompose(1000);
X#ifdef VMS
X    if (app_resources.replyPath != NIL(char)) `7B
X`09sprintf(gripeTo, app_resources.replyPath, GRIPES);
X    `7D else `7B
X`09strcpy(gripeTo, GRIPES);
X    `7D
X#else
X    strcpy(gripeTo, GRIPES);
X#endif
X    (void) strcpy(title, "Gripe");
X    (void) sprintf(message, "To: %s\nSubject: GRIPE about XRN %s\n\n",
X`09`09   gripeTo, XRN_VERSION);
X    if (app_resources.editorCommand != NULL) `7B
X`09(void) strcat(message,
X  `09`09"-=-=-=-= Enter your text below this line ");
X`09(void) strcat(message, "(don't delete this line) =-=-=-=-\n");
X    `7D
X    InsertionPoint = utStrlen(message);
X    (void) strcat(message, "\n");
X    (void) strcpy(HeaderString, message);
X
X    EditorPosition = 0;
X    message`5B0`5D = '\0';
X    if ((signature = signatureFile()) != NIL(char)) `7B
X`09(void) strcpy(message, "\n");
X`09(void) strcat(message, signature);
X    `7D
X
X    Header.artText = NULL;
X    PostingMode = GRIPE;
X    if (composePane(title, message))
X`09 PostingMode = OldPostingMode;
X
X    return;
X`7D
X
X
Xvoid
Xforward()
X`7B
X    char title`5BLABEL_SIZE`5D;
X    char *signature;
X    struct newsgroup *newsgroup = CurrentGroup;
X    art_num current = newsgroup->current;
X    int OldPostingMode = PostingMode;
X   `20
X    if (ComposeActive) `7B
X`09mesgPane(XRN_SERIOUS, "Only one composition pane at a time");
X`09return;
X    `7D
X    getHeader(current);
X    Header.artText = getText(current);
X    if (Header.artText == NULL) `7B
X`09XBell(XtDisplay(TopLevel), 0);
X`09mesgPane(XRN_SERIOUS, "No article to include");
X`09freeHeader();
X`09return;
X    `7D
X
X    sizeCompose(MAX_SIGNATURE_SIZE + utStrlen(Header.artText) + 1000);
X    (void) sprintf(title, "Forward article %ld in %s to a User", current,
X`09`09   newsgroup->name);
X    if (app_resources.ccForward == True) `7B
X`09(void) sprintf(HeaderString, "To: \nCc: %s\nSubject: %s - %s #%ld\n",
X`09`09       Header.user,
X`09`09       Header.subject, newsgroup->name, current);
X    `7D else `7B
X`09if (app_resources.cc == True) `7B
X`09    (void) sprintf(HeaderString,`20
X`09`09"To: \nCc: \nSubject: %s - %s #%ld\n" ,
X`09`09Header.subject, newsgroup->name, current);
X`09`7D else `7B
X`09    (void) sprintf(HeaderString, "To: \nSubject: %s - %s #%ld\n" ,
X`09`09Header.subject, newsgroup->name, current);
X`09`7D
X    `7D
X    if (app_resources.editorCommand != NULL) `7B
X`09(void) strcat(HeaderString,
X  `09`09"-=-=-=-= Enter your text below this line ");
X`09(void) strcat(HeaderString, "(don't delete this line) =-=-=-=-\n");
X    `7D
X    InsertionPoint = 0;
X    if ((signature = signatureFile()) != NIL(char)) `7B
X`09(void) strcpy(TempString, signature);
X    `7D else `7B
X`09*TempString = '\0';
X    `7D
X
X    strcpy(CompositionString, TempString);
X    EditorPosition = -4;
X    InsertionPoint = 0;
X    PostingMode = FORWARD;
X    includeArticleText();
X    strcpy(TempString, CompositionString);
X    if (composePane(title, TempString))
X`09 PostingMode = OldPostingMode;
X    return;
X`7D
X
X#ifdef GENERATE_EXTRA_FIELDS
X/*
X *  generate a message id
X */
Xstatic char genid`5B132`5D;
X
Xstatic char *gen_id()
X`7B
X    char *timestr, *cp;
X    time_t cur_time;
X
X    time(&cur_time);
X    timestr = ctime(&cur_time);
X
X    (void) sprintf(genid, "<%.4s%.3s%.2s.%.2s%.2s%.2s@%s>",
X`09`09    &timestr`5B20`5D, &timestr`5B4`5D, &timestr`5B8`5D,
X`09`09    &timestr`5B11`5D, &timestr`5B14`5D, &timestr`5B17`5D,
X`09`09    Header.host);
X    cp = &genid`5B8`5D;
X
X    if (*cp == ' ') `7B
X`09do `7B
X`09    *cp = *(cp + 1);`20
X`09`7D while (*cp++);
X    `7D
X
X    return(genid);
X`7D
X/*
X * generate a valid RFC822 date-time
X */
Xstatic char gendate`5B40`5D;
X
Xstatic char *gen_date()
X`7B
X
X    time_t clockTime;
X    char *atime, *tz;
X    struct tm *cur_time;
X
X    (void) time(&clockTime);
X    cur_time = gmtime(&clockTime);
X    if (cur_time) `7B
X`09atime = ctime(&clockTime);
X`09tz = "GMT";
X    `7D else `7B
X`09atime = asctime(localtime(&clockTime));
X`09tz = getenv(TIMEZONE_ENV);
X`09if (tz == NULL) `7B
X`09    fprintf(stderr, "xrn: TIMEZONE_ENV not set\n");`20
X`09    tz = "GMT";
X`09`7D
X    `7D
X    sprintf(gendate, "%3.3s, %2.2s %3.3s %2.2s %8.8s %s",
X`09atime, atime+8, atime+4, atime+22, atime+11, tz);
X    return(gendate);
X`7D
X#endif
X
Xstatic void
XdoFollowup(newMode)
Xint newMode;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    art_num current = newsgroup->current;
X    char buffer`5B10000`5D, title`5BLABEL_SIZE`5D;
X    char *signature;
X    int OldPostingMode = PostingMode;
X
X    if (ComposeActive) `7B
X`09mesgPane(XRN_SERIOUS, "Only one composition pane at a time");
X`09return;
X    `7D
X
X    getHeader(current);
X
X    if (! strcmp(Header.followupTo, "poster")) `7B
X`09 freeHeader();
X`09 mesgPane(XRN_INFO, "Message says to followup to poster; composing reply
V instead of followup.");
X`09 reply();
X`09 return;
X    `7D
X
X    if ((newsgroup->status & NG_UNPOSTABLE) == NG_UNPOSTABLE) `7B
X`09freeHeader();
X`09mesgPane(XRN_SERIOUS, "Can not post articles to this group");
X`09return;
X    `7D
X
X    Header.artText = getText(current);
X    sizeCompose(utStrlen(Header.artText) + MAX_SIGNATURE_SIZE + 1000);
X   `20
X    PostingMode = newMode;
X    (void) sprintf(title, "Followup to article %ld in %s",
X`09`09   current, newsgroup->name);
X
X#if defined(INEWS) `7C`7C defined(HIDE_PATH)
X    (void) sprintf(TempString, "Path: %s\n", Header.user);
X#else
X    (void) sprintf(TempString, "Path: %s!%s\n", Header.path, Header.user);
X#endif
X    if ((Header.followupTo != NIL(char)) && (*Header.followupTo != '\0')) `7
VB
X`09Header.newsgroups = XtNewString(Header.followupTo);
X    `7D
X    (void) sprintf(buffer, "Newsgroups: %s\n", Header.newsgroups);
X    (void) strcpy(TempString, buffer);
X    (void) strcat(TempString, "Distribution: ");
X    if ((Header.distribution != NIL(char)) && (*Header.distribution != '\0')
V) `7B
X`09(void) strcat(TempString, Header.distribution);
X    `7D else if (app_resources.distribution) `7B
X`09(void) strcat(TempString, app_resources.distribution);
X    `7D else `7B`09
X`09(void) strcat(TempString, DISTRIBUTION);
X    `7D
X    (void) strcat(TempString, "\n");
X    (void) sprintf(buffer, "X-Newsreader: %s\n", TITLE);
X    (void) strcat(TempString, buffer);
X    (void) strcat(TempString, "Followup-To: \n");
X    (void) sprintf(buffer, "References: %s %s\n",
X`09Header.references, Header.messageId);
X    (void) strcat(TempString, buffer);
X    (void) sprintf(buffer, "From: %s@%s (%s)\n",
X`09`09   Header.user, Header.host, Header.fullname);
X    (void) strcat(TempString, buffer);
X
X#ifdef GENERATE_EXTRA_FIELDS
X    /* stuff to generate Message-ID and Date... */
X    (void) sprintf(buffer, "Date: %s\n", gen_date());
X    (void) strcat(TempString, buffer);
X    (void) sprintf(buffer, "Message-ID: %s\n", gen_id());
X    (void) strcat(TempString, buffer);
X#endif
X
X    (void) strcat(TempString, "Reply-To: ");
X    if (app_resources.replyTo != NIL(char)) `7B
X`09(void) strcat(TempString, app_resources.replyTo);
X    `7D else `7B
X`09(void) sprintf(buffer, "%s@%s (%s)",
X`09`09       Header.user, Header.host, Header.fullname);
X`09(void) strcat(TempString, buffer);
X    `7D
X    (void) strcat(TempString, "\n");
X
X    (void) strcat(TempString, "Organization: ");
X    if (app_resources.organization != NIL(char)) `7B
X`09(void) strcat(TempString, app_resources.organization);
X    `7D else `7B
X`09if (Header.organization) `7B
X`09    (void) strcat(TempString, Header.organization);
X`09`7D else `7B
X`09    (void) strcat(TempString, ORG_NAME);
X`09`7D
X    `7D
X    (void) strcat(TempString, "\n");
X
X    buildSubject(TempString);
X   `20
X    (void) strcat(TempString, "Keywords: ");
X    if ((Header.keywords != NIL(char)) && (*Header.keywords != '\0')) `7B
X`09(void) strcat(TempString, Header.keywords);
X    `7D
X    (void) strcat(TempString, "\n");
X    if (app_resources.editorCommand != NULL) `7B
X`09(void) strcat(TempString,
X  `09`09"-=-=-=-= Enter your text below this line ");
X`09(void) strcat(TempString, "(don't delete this line) =-=-=-=-\n");
X    `7D
X    (void) strcpy(HeaderString, TempString);
X
X    EditorPosition = InsertionPoint = utStrlen(TempString);
X   `20
X#if !defined(INEWS_READS_SIG)
X    if ((signature = signatureFile()) != NIL(char)) `7B
X`09(void) strcpy(TempString, "\n");
X`09(void) strcat(TempString, signature);
X    `7D else `7B
X`09*TempString = '\0';
X    `7D
X#else
X    *TempString = '\0';
X#endif
X
X    if (composePane(title, TempString))
X`09 PostingMode = OldPostingMode;
X
X    return;
X`7D
Xvoid
Xfollowup()
X`7B
X    doFollowup(FOLLOWUP);
X`7D
X
Xvoid
XfollowupAndReply()
X`7B
X    doFollowup(FOLLOWUPREPLY);
X`7D
X
Xvoid
Xpost()
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    char title`5BLABEL_SIZE`5D, buffer`5B10000`5D;
X    char *signature;
X    int OldPostingMode = PostingMode;
X
X    if (ComposeActive) `7B
X`09mesgPane(XRN_SERIOUS, "Only one composition pane at a time");
X`09return;
X    `7D
X    if (newsgroup) `7B
X`09if ((newsgroup->status & NG_UNPOSTABLE) == NG_UNPOSTABLE) `7B
X`09    mesgPane(XRN_SERIOUS, "Can not post articles to this group");
X`09    return;
X`09`7D
X    `7D
X
X    sizeCompose(10000);
X    getHeader((art_num) 0);
X
X    if (!newsgroup) `7B
X`09FREE(Header.newsgroups);
X`09Header.newsgroups = XtNewString("");
X`09(void) strcpy(title, "Post article (no current group)");
X    `7D else `7B
X`09(void) sprintf(title, "Post article to `60%s'", newsgroup->name);
X`09Header.newsgroups = XtNewString(newsgroup->name);
X    `7D
X
X#if defined(INEWS) `7C`7C defined(HIDE_PATH)
X    (void) sprintf(TempString, "Path: %s\n", Header.user);
X#else
X    (void) sprintf(TempString, "Path: %s!%s\n", Header.path, Header.user);
X#endif
X    (void) sprintf(buffer, "Newsgroups: %s\n", Header.newsgroups);
X    (void) strcat(TempString, buffer);
X    (void) strcat(TempString, "Distribution: ");
X    if (app_resources.distribution) `7B
X`09(void) strcat(TempString, app_resources.distribution);
X    `7D else `7B`09
X`09(void) strcat(TempString, DISTRIBUTION);
X    `7D
X    (void) strcat(TempString, "\n");
X    (void) sprintf(buffer, "X-Newsreader: %s\n", TITLE);
X    (void) strcat(TempString, buffer);
X
X#ifdef GENERATE_EXTRA_FIELDS
X    /* stuff to generate Message-ID and Date... */
X    (void) sprintf(buffer, "Date: %s\n", gen_date());
X    (void) strcat(TempString, buffer);
X    (void) sprintf(buffer, "Message-ID: %s\n", gen_id());
X    (void) strcat(TempString, buffer);
X#endif
X
X    (void) strcat(TempString, "Followup-To: \n");
X    (void) sprintf(buffer, "From: %s@%s (%s)\n",
X`09`09   Header.user, Header.host, Header.fullname);
X    (void) strcat(TempString, buffer);
X    (void) strcat(TempString, "Reply-To: ");
X    if (app_resources.replyTo != NIL(char)) `7B
X`09(void) strcat(TempString, app_resources.replyTo);
X    `7D else `7B
X`09(void) sprintf(buffer, "%s@%s (%s)", Header.user, Header.host, Header.ful
Vlname);
X`09(void) strcat(TempString, buffer);
X    `7D
X    (void) strcat(TempString, "\n");
X
X    (void) strcat(TempString, "Organization: ");
X    if (app_resources.organization != NIL(char)) `7B
X`09(void) strcat(TempString, app_resources.organization);
X    `7D else `7B
X`09if (Header.organization) `7B
X`09    (void) strcat(TempString, Header.organization);
X`09`7D else `7B
X`09    (void) strcat(TempString, ORG_NAME);
X`09`7D
X    `7D
X    (void) strcat(TempString, "\n");
X    (void) strcat(TempString, "Subject: \n");
X    (void) strcat(TempString, "Keywords: \n");
X    if (app_resources.editorCommand != NULL) `7B
X`09(void) strcat(TempString,
X  `09`09"-=-=-=-= Enter your text below this line ");
X`09(void) strcat(TempString, "(don't delete this line) =-=-=-=-\n");
X    `7D
X    (void) strcpy(HeaderString, TempString);
X
X    EditorPosition = InsertionPoint = 0;
X#if !defined(INEWS_READS_SIG)
X    if ((signature = signatureFile()) != NIL(char)) `7B
X`09(void) strcpy(TempString, "\n");
X`09(void) strcat(TempString, signature);
X    `7D else `7B
X`09*TempString = '\0';
X    `7D
X#else
X    *TempString = '\0';
X#endif
X
X    PostingMode = POST;
X    if (composePane(title, TempString))
X`09 PostingMode = OldPostingMode;
X
X    return;
X`7D
X
X
Xvoid
XcancelArticle()
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    art_num current = newsgroup->current;
X    char buffer`5B10000`5D;
X    char *bufptr;
X
X    if (ComposeActive) `7B
X`09mesgPane(XRN_SERIOUS, "Only one composition pane at a time");
X`09return;
X    `7D
X    if ((newsgroup->status & NG_UNPOSTABLE) == NG_UNPOSTABLE) `7B
X`09mesgPane(XRN_SERIOUS, "Can not post articles to this group");
X`09return;
X    `7D
X
X    getHeader(current);
X
X    sizeCompose(10000);
X    /* verify that the user can cancel the article */
X    bufptr = index(Header.from, '@');
X    if (bufptr != NIL(char)) `7B
X`09bufptr++;
X`09(void) strcpy(buffer, bufptr);
X`09if ((bufptr = index(buffer, ' ')) != NIL(char)) `7B
X`09    *bufptr = '\0';
X`09`7D
X`09if (strncmp(Header.host, buffer, utStrlen(Header.host))
X`09   `7C`7C (strncmp(Header.user, Header.from, utStrlen(Header.user))`20
X`09      && strcmp(Header.user, "root"))) `7B
X`09    mesgPane(XRN_SERIOUS, "Not entitled to cancel the article");
X`09    freeHeader();
X`09    return;
X        `7D
X    `7D
X
X#if defined(INEWS) `7C`7C defined(HIDE_PATH)
X    (void) sprintf(TempString, "Path: %s\n", Header.user);
X#else
X    (void) sprintf(TempString, "Path: %s!%s\n", Header.path, Header.user);
X#endif
X    (void) sprintf(buffer, "From: %s@%s (%s)\n", Header.user, Header.host, H
Veader.fullname);
X    (void) strcat(TempString, buffer);
X    (void) sprintf(buffer, "Subject: cancel %s\n", Header.messageId);
X    (void) strcat(TempString, buffer);
X    if (*Header.followupTo != '\0') `7B
X`09Header.newsgroups = XtNewString(Header.followupTo);
X    `7D
X    (void) sprintf(buffer, "Newsgroups: %s\n", Header.newsgroups);
X    (void) strcat(TempString, buffer);
X    (void) sprintf(buffer, "References: %s %s\n",
X`09`09   Header.references, Header.messageId);
X    (void) strcat(TempString, buffer);
X
X    (void) strcat(TempString, "Distribution: ");
X    if ((Header.distribution != NIL(char)) && (*Header.distribution != '\0')
V) `7B
X`09(void) strcat(TempString, Header.distribution);
X    `7D else if (app_resources.distribution) `7B
X`09(void) strcat(TempString, app_resources.distribution);
X    `7D else `7B
X`09(void) strcat(TempString, DISTRIBUTION);
X    `7D
X    (void) strcat(TempString, "\n");
X    (void) sprintf(buffer, "Control: cancel %s\n", Header.messageId);
X    (void) strcat(TempString, buffer);
X#ifdef GENERATE_EXTRA_FIELDS
X    /* stuff to generate Message-ID and Date... */
X    (void) sprintf(buffer, "Date: %s\n", gen_date());
X    (void) strcat(TempString, buffer);
X    (void) sprintf(buffer, "Message-ID: %s\n", gen_id());
X    (void) strcat(TempString, buffer);
X#endif
X
X    freeHeader();
X
X    switch (postArticle(TempString,XRN_NEWS)) `7B
X`09case POST_FAILED:
X`09mesgPane(XRN_SERIOUS, "Could not cancel the article");
X`09break;
X
X`09case POST_NOTALLOWED:
X`09mesgPane(XRN_SERIOUS, "Posting not allowed from this machine");
X`09break;
X`09   `20
X`09case POST_OKAY:
X`09mesgPane(XRN_INFO, "Canceled the article");
X`09break;
X    `7D
X
X    return;
X`7D
$ CALL UNPACK COMPOSE.C;236 1874729054
$ create 'f'
X#ifndef COMPOSE_H
X#define COMPOSE_H
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/compose.h,v 1.5 1993
V/01/11 02:14:37 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * compose.h: functions for composing and sending messages
X */
X
Xextern void post _ARGUMENTS(());
Xextern void followup _ARGUMENTS(());
Xextern void followupAndReply _ARGUMENTS(());
Xextern void reply _ARGUMENTS(());
Xextern void cancelArticle _ARGUMENTS(());
Xextern void gripe _ARGUMENTS(());
Xextern void forward _ARGUMENTS(());
Xextern void processMessage _ARGUMENTS(());
X
X#endif /* COMPOSE_H */
$ CALL UNPACK COMPOSE.H;15 1762161391
$ create 'f'
X#ifndef CONFIG_H
X#define CONFIG_H
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/config.h,v 1.10 1993
V/02/04 18:22:14 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * config.h: configurable defaults
X */
X
X#if defined(__ultrix) && defined(__STDC__) && !defined(ultrix)
X#define ultrix
X#endif
X
X#if defined(__STDC__) && (__STDC__)
X#define STDC
X#endif
X
X/* place to report bugs and request new features */
X#ifndef GRIPES
X#define GRIPES "murphy@dco.dec.com"
X#endif
X
X/* if you want xrn to provide a titlebar */
X/* #define TITLEBAR */
X
X/* display compilation time in the XRN title bar */
X#define WANT_DATE
X
X/* if you want a short icon name */
X#define SHORT_ICONNAME
X
X/* define to use the DEC cursor font */
X#if defined(ultrix) `7C`7C defined (VMS) `7C`7C defined (__osf__)
X#define USE_DEC_CURSOR
X#endif
X
X/*
X * Note: You can probably skip ahead to the DISTRIBUTION section if you are
X * using InterNetNews - INN
X */
X
X/*
X * your internet domain name, examples are:
X *
X * .Berkeley.EDU
X * .mit.EDU
X * .CSS.GOV
X * .CS.NET
X * .BITNET
X * .UUCP
X *
X * wouldn't it be nice if there were a call like 'gethostname'
X * that would get the domain name...
X *
X * DOMAIN_NAME can be overriden with the DOMAIN environment variable`20
X * or the DOMAIN_FILE (see below)
X *
X * NOTE: use of the RESOLVER define should make DOMAIN_NAME obsolete`20
X *
X */
X#ifndef DOMAIN_NAME
X-- error - define your domain name below and delete this line --
X#define DOMAIN_NAME ".your.domain.here"
X#endif
X
X/*
X * Define RETURN_HOST if you want a default return address host name.
X * Useful if your site uses MX records or something to address all
X * mail to a pseudo host (e.g. user@Berkeley.EDU)
X */
X/*#define RETURN_HOST "NoHost.NoDomain"*/
X
X/* organization name */
X#ifndef ORG_NAME
X-- error - define your organization name below and delete this line --
X#define ORG_NAME`09"Your Company/Organization"
X#endif
X
X/* uucp netnews name (if different from your internet host name) */
X/* #define UUCPNAME  "/etc/uucpname" */
X
X/* define this if you don't want xrn to add the hostname to the Path field *
V/
X/* #define HIDE_PATH */
X
X#ifndef VMS
X/*
X * name of the nntp server is in this file - can be overriden
X * by command line option, X resource, or environment variable
X */
X#ifndef SERVER_FILE
X#define SERVER_FILE "/usr/local/lib/rn/server"
X#endif
X/*
X * name of the host to use as the users host name in the From field
X * in a composition is in thie file
X */
X#ifndef HIDDEN_FILE
X#define HIDDEN_FILE "/usr/local/lib/news/hiddenhost"
X#endif
X/*
X * name of the host to use as the users hosts name in the Path field`20
X * in a composition is in the file
X */
X#ifndef PATH_FILE
X#define PATH_FILE "/usr/local/lib/news/pathhost"
X#endif
X/*
X * name of the internet domain is in this file
X */
X#ifndef DOMAIN_FILE
X#define DOMAIN_FILE "/usr/local/lib/news/domain"
X#endif
X/*
X * name of the organization is in this file
X */
X#ifndef ORG_FILE
X#define ORG_FILE "/usr/local/lib/news/organization"
X#endif
X#else /* VMS */
X#define SERVER_FILE "SYS$LOGIN:NNTP.SERVER"
X#define HIDDEN_FILE "SYS$LOGIN:HIDDEN.HOST"
X#define PATH_FILE "SYS$LOGIN:PATH.HOST"
X#define DOMAIN_FILE "SYS$LOGIN:DOMAIN.NAME"
X#define ORG_FILE "SYS$LOGIN:ORG.NAME"
X#endif /* VMS */
X
X/* default distribution */
X#ifndef DISTRIBUTION
X#define DISTRIBUTION "world"
X#endif
X
X/*
X * maximum size of a signature file (in bytes), if file is bigger than this,
X * it is not included
X */
X#define MAX_SIGNATURE_SIZE 1000
X
X/*
X * Prefix for each line included from an article
X */
X#define INCLUDEPREFIX`09"`7C> "
X
X/*
X * for author names: email address (default) or fullname
X */
X#define AUTHOR_FULLNAME
X
X/*
X * number of article headers to prefetch when searching subjects
X * in the backwards direction
X */
X#define SUBJECTS`0910
X
X
X/*
X * use the name server to find out your official (with domain) host name
X */
X#ifndef RESOLVER
X#define RESOLVER
X#endif
X
X/*
X * For debugging only, define if you want core dumps, rather than
X * a death notification box and an attempt at updating the .newsrc
X * and cleaning up the temporary files
X *
X */
X/* #define DUMPCORE */
X
X/*
X * use MOTIF widgets
X */
X/* #define MOTIF */
X
X/*
X * for various bugs in the toolkit / widget set
X */
X/* These defines are probably no longer needed */
X/* #define TRANSLATIONBUG */`09/* DEC (VMS) X windows release`09`09*/
X/* #define ERRORBUG */`09`09/* DEC (VMS) X windows release`09`09*/
X/* #define DECFOCUSPATCH */`09/* for certain DEC window managers`09*/
X
X/*
X * If XFILESEARCHPATH is defined, then its contents are treated as a string`
V20
X * which is appended to the end of the XFILESEARCHPATH environment variable.
X * The purpose of this is that if you are planning on installing xrn
X * (and its app-defaults file) in a non-standard location, you can make`20
X * sure that it will find its app-defaults file by compiling the program`20
X * with the path to the file set in XFILESEARCHPATH (for example, when`20
X * I compile the program I #define XFILESEARCHPATH to be`20
X * "/usr/sipb/lib/%T/%N", since I install it in the Student Information`20
X * Processing Board (SIPB) filesystem.  This patch addresses a general`20
X * flaw in X11R4's (and X11R3's) handling of application defaults file --
X * there is no way for the programmer to suggest to the toolkit
X * where to look for the file without mucking with environment variables.
X *
X * (Jonathan I. Kamens <jik@pit-manager.mit.edu>)
X */
X/* #define XFILESEARCHPATH "path"*/
X
X/*
X * generate Message-ID and Date fields
X *
X *   NNTP POST should handle this, but does not for some
X *   implementations.  Do not define this if you are using INN.
X */
X/*#define GENERATE_EXTRA_FIELDS*/
X
X/*
X * environment variable containing timezone name
X *
X *   Used only with GENERATE_EXTRA_FIELDS. Since gmtime is allowed to
X *   return NULL, we must be prepared to use localtime and provide a
X *   timezone specification. This macro defines the name of the environment
X *   variable containing the time zone.
X */
X/* #define TIMEZONE_ENV "UUCP_TIME_ZONE" */
X
X/*
X * don't use the XHDR NNTP command, use HEADER and cache information...
X */
X/* #define DONT_USE_XHDR */
X
X/*
X * don't use the XHDR NNTP command for getting a single header field
X * from a single article (for performance reasons), use HEADER and`20
X * cache information...
X */
X/* #define DONT_USE_XHDR_FOR_A_SINGLE_ITEM */
X
X/*
X * the active file of most currently used news systems has a problem:
X *   if the first article number equals the last article number for a
X *   newsgroup, this means that there are 0 OR 1 ARTICLES.
X *
X * Cnews, INN, and and Bnews 2.11 (patch #19) have fixed this problem.
X */
X#ifdef INN
X#define FIXED_ACTIVE_FILE
X#endif /* INN */
X
X/*
X * deal with stupid C-news problem of NOT updating the low number
X * of the group entries in the active file - define this if you
X * have fixed the problem
X */
X/* #define FIXED_C_NEWS_ACTIVE_FILE */
X
X/*
X * old versions of NNTP (pre-1.5.11) read the 'active' file only once
X * per session, so reissuing the 'LIST' command would always return
X * the EXACT same data. New versions of NNTP will reread the file
X * for each LIST command.  If you are using 1.5.11 or greater, or INN
X * define NNTP_REREADS_ACTIVE_FILE
X */
X
X#ifdef INN
X#define NNTP_REREADS_ACTIVE_FILE
X#endif /* INN */
X
X
X/*
X * Do you want to use inews for postings?  For INN, it is suggested that you
V do.
X */
X/* #define INEWS "/usr/lib/news/inews" */
X
X/*
X * Does INEWS read the signature file? The version of INEWS for INN
X * reads the signature file by default.  If you define this incorrectly
X * you will probably end up with two signatures on postings.
X */
X/* #define INEWS_READS_SIG */
X
X/*
X * Define if you want AUTHINFO support for authorization for
X * the NNTP server. (see clientlib.c).
X */
X/* #define AUTHINFO */
X
X/*
X * display articles with local time rather than GMT
X *
X *  if you are running SunOS 3.5, get rid of the '`7C`7C defined(sun)'
X */
X#define USE_LOCALTIME
X#if defined(USE_LOCALTIME) && (defined(SYSV) `7C`7C defined(ultrix) `7C`7C d
Vefined(apollo) `7C`7C  defined(sun))
X#define REALLY_USE_LOCALTIME
X#endif
X
X/*
X * non-display defaults
X */
X#ifndef PRINTCOMMAND
X#ifndef VMS
X#define PRINTCOMMAND`09"lpr"
X#else
X#define PRINTCOMMAND   "PRINT/DELETE"
X#endif
X#endif
X
X#ifndef SENDMAIL
X#ifndef VMS
X#define SENDMAIL       "/usr/lib/sendmail -oi -t"
X#else
X#define SENDMAIL       "MAIL "
X#endif
X#endif
X
X#define SAVEMODE       "normal,headers,onedir"
X#define SAVE_DIR_DEFAULT`09ONEDIR_SAVE
X#ifndef VMS
X#define SAVEDIR        "`7E/News"
X#define NEWSRCFILE     "`7E/.newsrc"
X#define SAVENEWSRCFILE "`7E/.oldnewsrc"
X#define SIGNATUREFILE  "`7E/.signature"
X#else
X#define SAVEDIR`09       "SYS$SCRATCH:"
X#define NEWSRCFILE     "SYS$LOGIN:NEWS.RC"
X#define SAVENEWSRCFILE "SYS$LOGIN:OLDNEWS.RC"
X#define SIGNATUREFILE  "SYS$LOGIN:NEWS.SIGNATURE"
X#endif
X#define TOPLINES`09"10"
X#define MINLINES`09"3"
X#define MAXLINES`09"8"
X#define TEXTLINES`09"24"
X#define CANCELCOUNT`09"20"
X#define LINELENGTH`09"0"
X#define BREAKLENGTH`09"0"
X/* ONLYSHOW set to "0" turns off the feature */
X#define ONLYSHOW`09"0"
X/* RESCAN_TIME is in seconds, default is 300 seconds (5 minutes) */
X#define RESCAN_TIME`09"300"
X
X#ifndef VMS
X#define DEADLETTER     "`7E/dead.letter"
X#define SAVEPOSTINGS   "`7E/Articles"
X#define TEMPORARY_DIRECTORY "/tmp"
X#else
X#define DEADLETTER     "SYS$SCRATCH:DEAD.LETTER"
X#define SAVEPOSTINGS   "SYS$SCRATCH:SAVED.POSTING"
X#define TEMPORARY_DIRECTORY "SYS$SCRATCH:"
X#endif
X
X#define WATCH
X
X/* definitions to convert from e.g. ISO-646 to ISO-8859 */
X/* #define XLATE */
X/* define the strings of equivalent characters */
X#ifdef XLATE
X#ifdef SWEDISH
X/*`09Swedish ISO-646 to ISO-8859-1 */
X#define XLATE_FROM`09"`5B`5D\\`7B`7D`7C$@`5E`60`7E"
X#define XLATE_TO`09"\304\305\326\344\345\366\244\311\334\351\374"
X#endif /* SWEDISH */
X
X#ifdef NORWEGIAN
X/*
X        Norwegian ISO-646 to ISO-8859-1  - contributed by
X`09Per Steinar Iversen, iversen@vsfys1.fi.uib.no
X */
X#define XLATE_FROM   "`5B`5D\\`7B`7D`7C"
X#define XLATE_TO     "\306\305\330\346\345\370"
X#endif /* NORWEGIAN */
X
X#endif /* XLATE */
X
X
X/*
X *
X * End of User/Site Configuration Parameters
X *
X */
X
X/* SYSTEM V regex package */
X#if defined(macII) `7C`7C defined(aiws) `7C`7C defined(hpux) `7C`7C (defined
V(SYSV) && !defined(i386)) `7C`7C defined(i386)
X#define SYSV_REGEX
X#if !defined(SYSV) && !defined(linux)
X#define SYSV
X#endif
X#endif
X
X/* SYSTEM V doesn't have index/rindex...*/`09`09`09    /* ggh */
X#ifdef SYSV`09`09`09`09`09`09`09    /* ggh */
X#define index strchr`09`09`09`09`09`09    /* ggh */
X#define rindex strrchr`09`09`09`09`09`09    /* ggh */
X#endif`09`09`09`09`09`09`09`09    /* ggh */
X
X/* vfork supported */
X#if defined(ultrix) `7C`7C defined(sun) `7C`7C defined(apollo) `7C`7C (defin
Ved(sony) && !defined(SVR4))
X#define VFORK_SUPPORTED
X#endif
X
X/* define this if your popen uses vfork - ultrix uses fork... */
X#if !defined(VFORK_SUPPORTED) `7C`7C (!defined(ultrix) && (!defined(SYSV) `7
VC`7C defined(sgi)))
X#define POPEN_USES_INEXPENSIVE_FORK
X#endif
X
X/* bsd b* functions */
X#if defined(sequent) `7C`7C !defined(SYSV)
X#ifndef VMS
X#define BSD_BFUNCS
X#endif
X#endif
X
X/* v`7Bs,f`7Dprintf functions */
X#if defined(sequent) `7C`7C defined(ibm032) `7C`7C defined(hp300) `7C`7C (de
Vfined(sony) && !defined(SYSV) && !defined(_ANSI_C_SOURCE))
X#define NEED_VPRINTF
X#endif
X
X
X/*
X * define this if your system C library doesn't have the tempnam
X * function - note that there a number of buggy tempnam implementations
X * in various vendors libc's.  You might want to always define NEED_TEMPNAM
X * and not use the libc one at all.
X */
X#if defined(convex) `7C`7C (defined(sony) && !defined(SVR4)) `7C`7C (!define
Vd(sun) && !defined(ultrix) && !defined(__osf__) && !defined(SYSV) && !define
Vd(_XOPEN_SOURCE)) `7C`7C defined(ibm032) `7C`7C defined(sequent) `7C`7C defi
Vned(_IBMR2)
X#define NEED_TEMPNAM
X#else
X#define utTempnam tempnam
X#endif
X    `20
X/* strtok function */
X#if defined(sequent) `7C`7C (!defined(SYSV) && !defined(_ANSI_C_SOURCE))
X#define NEED_STRTOK
X#endif
X
X/* strstr function */
X#if !defined(_ANSI_C_SOURCE)
X#define NEED_STRSTR
X#endif
X
X#if defined(sun) `7C`7C defined(hpux) `7C`7C defined(clipper) `7C`7C (define
Vd(sony) && defined(SYSV)) `7C`7C (defined(i386) && defined(SYSV))
X#define NEED_STRCASECMP
X#endif
X
X#if defined(mips) `7C`7C defined(hpux) `7C`7C defined(sun) `7C`7C (defined(i
V386) && !defined(sequent)) `7C`7C defined(_IBMR2)
X#define USE_PUTENV
X#endif
X
X#ifndef _ARGUMENTS
X#if defined(FUNCPROTO) `7C`7C defined(__STD__) `7C`7C defined(__cplusplus) `
V7C`7C defined(c_plusplus) `7C`7C defined(STDC)
X#define _ARGUMENTS(arglist) arglist
X#else
X#define _ARGUMENTS(arglist) ()
X#endif
X#endif
X
X#endif /* CONFIG_H */
$ CALL UNPACK CONFIG.H;26 1645272606
$ create 'f'
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/COPYRIGHT,v 1.3 1993
V/01/11 02:13:55 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
$ CALL UNPACK COPYRIGHT.;2 1567576131
$ create 'f'
X#ifndef COPYRIGHT_H
X#define COPYRIGHT_H
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/copyright.h,v 1.4 19
V93/01/11 02:14:42 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*`20
X * HISTORY
X * $Log: copyright.h,v $
X * Revision 1.4  1993/01/11  02:14:42  ricks
X * XRN 6.18 beta2
X *
X * Revision 1.3  92/07/24  19:31:38  ricks
X * just to save state
X *`20
X */
X
X#if !defined(lint) && !defined(SABER)
Xstatic char *copyright = "Copyright (c) 1988-1993, Ellen M. Sentovich and Ri
Vck L. Spickelmier.";
X#endif
X
X#endif /* COPYRIGHT_H */
X
$ CALL UNPACK COPYRIGHT.H;2 1664759093
$ create 'f'
X
X#if !defined(lint) && !defined(SABER)
Xstatic char XRNrcsid`5B`5D = "$Header: /net/objy27/wrld/mnt11/ricks/src/mast
Ver/xrn/cursor.c,v 1.5 1993/01/11 02:14:44 ricks Exp $";
X#endif
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * cursor.c: routines for manipulating the cursor and/or text in a text
X *           window
X */
X
X#include "copyright.h"
X#include "config.h"
X#include <stdio.h>
X#ifdef __STDC__
X#include <stdlib.h>
X#endif
X#include "utils.h"
X#include "mesg.h"
X#include "news.h"
X#include "internals.h"
X#include "modes.h"
X#include "xrn.h"
X#include "cursor.h"
X#include "error_hnds.h"
X
X/*
X * Return the name of the group on the current line.
X * Assume there is a group there.
X */
Xvoid
XcurrentNewsgroup(mode, tstring, groupName)
Xint mode;`09`09`09/* xrn Mode */
Xchar *tstring;`09`09`09/* text string */
Xchar *groupName;`09`09/* string to return group name in */
X`7B
X    if ((mode != ALL_MODE) && (mode != ADD_MODE)) `7B
X`09if (sscanf(&tstring`5B0`5D, NEWS_GROUP_LINE, groupName) == 1) `7B
X`09    return;
X`09`7D else `7B
X`09    *groupName = '\0';
X`09    return;
X`09`7D
X    `7D else `7B
X`09(void) sscanf(&tstring`5B0`5D, "%s", groupName);
X    `7D
X    return;
X`7D
X
X/*
X * Return the status of the group on the current line.
X */
Xvoid
XcurrentMode(tstring, groupName, mode)
Xchar *tstring;
Xchar *groupName;
Xint *mode;
X`7B
X    char status`5B100`5D;
X
X    (void) sscanf(&tstring`5B0`5D, "%s %s", groupName, status);
X    if (strcmp(status,"unsubscribed") == 0) `7B
X`09*mode = UNSUBSCRIBE;
X    `7D else `7B
X`09*mode = SUBSCRIBE;
X    `7D
X    return;
X`7D
X
X/*
X * Mark the article at the current ArticlePosition as read,if it is
X * not already marked. Return the article number of the article
X * that was marked.  This subroutine only marks the text string;
X * the article is marked internally as read by calling`20
X * markArticleAsRead().
X */
Xint
XmarkStringRead(tstring)
Xchar *tstring;`09`09`09/* text string */
X`7B
X    if (tstring`5B0`5D == ' ') `7B
X`09tstring`5B0`5D = '+';
X    `7D
X    return atoi(&tstring`5B2`5D);
X`7D
X
X/*
X * Mark an article as read or unread.
X */
Xvoid
XmarkArticle(artNum, marker)
Xart_num artNum;
Xint marker;`09`09`09/* either '+' or ' ' */
X`7B
X    if (marker == '+' `7C`7C marker == 'S') `7B
X`09markArticleAsRead(artNum);
X    `7D else `7B
X`09if (marker != 'P') `7B
X`09    markArticleAsUnread(artNum);
X`09`7D
X    `7D
X    return;
X`7D
X
Xint
XsubjectSearch(dir, artnums, position, expr, text, ques, artNum)
Xint dir;`09`09`09/* direction, either FORWARD or BACK */
Xart_num *artnums;`09`09/* text string (may be changed here) */
Xint  *position;`09`09`09/* cursor position */
Xchar *expr;`09`09`09/* regular expression to search for */
Xchar **text, **ques;`09`09/* text and status line for new article */
Xart_num *artNum;`09`09/* number of new article */
X`7B
X#ifdef SYSV_REGEX
X    extern char *regcmp();
X    extern char *regex();
X#else
X    char *re_comp();`09`09/* regular expression routine */
X#endif
X    static char *reRet;`09`09/* returned by re_comp/regcmp */
X    char *newsubject;`09`09/* subject of current line */
X    char lowersubject`5B1024`5D;`09/* lowercase subject of current line */
X    char *newLine;
X    extern void abortClear();
X    extern int abortP();
X    static Boolean caseSensitive = False;
X    int num;`09`09`09/* Current article number being searched */
X    char statBuf`5B80`5D;`09`09/* message buffer */
X
X    abortClear();
X
X    if (expr != NIL(char)) `7B
X`09utLowerCase(lowersubject, expr, sizeof(lowersubject) - 1);
X`09if (strcmp(expr, lowersubject) != 0) `7B
X`09    caseSensitive = True;
X`09`7D else `7B
X`09    caseSensitive = False;
X`09`7D
X
X#ifdef SYSV_REGEX
X`09if ((reRet = regcmp(expr, NULL)) == NULL) `7B
X#else
X`09if ((reRet = re_comp(expr)) != NULL) `7B
X#endif
X`09    /* bad regular expression */
X#ifdef SYSV_REGEX
X`09    mesgPane(XRN_SERIOUS, "error in regular expression");
X#else
X`09    mesgPane(XRN_SERIOUS, reRet);
X#endif
X`09    failedSearch();
X`09    return ERROR;
X`09`7D
X    `7D
X
X    if (dir == FORWARD) `7B
X`09for (;;) `7B
X`09    if (abortP()) `7B
X`09`09return ABORT;
X`09    `7D
X`09    if (artnums`5B*position`5D == 0) `7B
X`09`09if (*position == 0) `7B
X
X`09`09    /* the string is null, no more articles are left */
X
X`09`09    return EXIT;
X`09`09`7D
X`09`09return NOMATCH;
X`09    `7D
X`09    *position = *position + 1;
X`09    if (artnums`5B*position`5D == 0) `7B
X
X`09`09/* reached end of string */
X
X`09`09return NOMATCH;
X`09    `7D
X`09    *artNum = artnums`5B*position`5D;
X`09    newsubject = getSubject(*artNum);
X`09    if (caseSensitive) `7B
X`09`09strncpy(lowersubject, newsubject, sizeof(lowersubject) - 1);
X`09    `7D else `7B
X`09`09utLowerCase(lowersubject, newsubject, sizeof(lowersubject) - 1);
X`09    `7D
X
X#ifdef SYSV_REGEX
X`09    if (regex(reRet, lowersubject) != NULL) `7B
X#else
X`09    if (re_exec(lowersubject)) `7B
X#endif
X`09`09/* found a match to the regular expression */
X
X`09`09gotoArticle(*artNum);
X`09`09if (getArticleText(text, ques) != XRN_OKAY) `7B
X
X`09`09    /* the matching article was invalid */
X
X`09`09    continue;
X`09`09`7D
X`09`09return MATCH;
X`09    `7D
X`09`7D
X    `7D else `7B
X`09startSearch();
X`09for (;;) `7B
X`09    if (abortP()) `7B
X
X`09`09/* reset pointers back to where we began, since the */
X`09`09/* search was aborted */
X
X`09`09failedSearch();
X`09`09return ABORT;
X`09    `7D
X`09    if ((*position == 0) &&
X`09`09(artnums`5B*position`5D == 0) ) `7B
X
X`09`09/* no more articles remain, return to Newgroup mode */
X
X`09`09return EXIT;
X`09    `7D
X`09    if (*position != 0) `7B
X
X`09`09/* we are still within the subject list */
X
X`09`09*position = *position - 1;
X`09`09*artNum = artnums`5B*position`5D;
X`09`09newsubject = getSubject(*artNum);
X`09`09if (caseSensitive) `7B
X`09`09    utLowerCase(lowersubject, newsubject, sizeof(lowersubject) - 1);
X`09`09`7D else `7B
X`09`09    strncpy(lowersubject, newsubject, sizeof(lowersubject) - 1);
X`09`09`7D
X
X#ifdef SYSV_REGEX
X`09`09if (regex(reRet, lowersubject) != NULL) `7B
X#else
X`09`09if (re_exec(lowersubject)) `7B
X#endif
X`09`09    /* an article matching the regular expression was found */
X
X`09`09    gotoArticle(*artNum);
X`09`09    if (getArticleText(text, ques) != XRN_OKAY) `7B
X
X`09`09`09/* article is invalid, remove it from the text string*/
X
X`09`09`09continue;
X`09`09    `7D
X`09`09    return MATCH;
X`09`09`7D
X`09    `7D else `7B
X
X`09`09/* must query the news server for articles not shown */
X`09`09/* on the current subject screen */
X
X`09`09if ((newLine = getPrevSubject()) == NIL(char)) `7B
X`09`09   `20
X`09`09    /* all articles have been exhausted, reset variables */
X`09`09    /* to what they were before the search was started */
X
X`09`09    failedSearch();
X`09`09    return NOMATCH;
X`09`09`7D
X`09`09newLine`5B0`5D = '+';
X`09`09num = atol(&newLine`5B2`5D);
X`09`09*artNum = num;
X`09`09if ((num % 100) == 0) `7B
X`09`09    sprintf(statBuf, "Now searching at article %d", num);
X`09`09    infoNow(statBuf);
X`09`09`7D
X`09`09newsubject = getSubject(*artNum);
X`09`09if (caseSensitive) `7B
X`09`09    utLowerCase(lowersubject, newsubject, sizeof(lowersubject) - 1);
X`09`09`7D else `7B
X`09`09    strncpy(lowersubject, newsubject, sizeof(lowersubject) - 1);
X`09`09`7D
X#ifdef SYSV_REGEX
X`09`09if (regex(reRet, lowersubject) != NULL) `7B
X#else
X`09`09if (re_exec(lowersubject)) `7B
X#endif
X`09`09    /* the new article (subjectline) obtained here */
X`09`09    /* does not need to be checked for validity, since */
X`09`09    /* getPrevSubject() only returns valid articles */
X
X`09`09    gotoArticle(*artNum);
X`09`09    (void) getArticleText(text, ques);
X`09`09    return WINDOWCHANGE;
X`09`09`7D
X`09`09continue;
X`09    `7D
X`09`7D
X    `7D
X`7D
X
Xint
XauthorSearch(dir, artnums, position, expr, text, ques, artNum)
Xint dir;`09`09`09/* direction, either FORWARD or BACK */
Xart_num *artnums;`09`09/* text string (may be changed here) */
Xint  *position;`09`09`09/* cursor position */
Xchar *expr;`09`09`09/* regular expression to search for */
Xchar **text, **ques;`09`09/* text and status line for new article */
Xart_num *artNum;`09`09/* number of new article */
X`7B
X#ifdef SYSV_REGEX
X    extern char *regcmp();
X    extern char *regex();
X#else
X    char *re_comp();`09`09/* regular expression routine */
X#endif
X    static char *reRet;`09`09/* returned by re_comp/regcmp */
X    char *newauthor;`09`09/* author of current line */
X    char lowerauthor`5B128`5D;`09/* lowercase author */
X    char *newLine;
X    extern void abortClear();
X    extern int abortP();
X    int num;`09`09`09/* Current article number being searched */
X    char statBuf`5B80`5D;`09`09/* message buffer */
X
X    abortClear();
X
X    if (expr != NIL(char)) `7B
X#ifdef SYSV_REGEX
X`09if ((reRet = regcmp(expr, NULL)) == NULL) `7B
X#else
X`09if ((reRet = re_comp(expr)) != NULL) `7B
X#endif
X`09    /* bad regular expression */
X#ifdef SYSV_REGEX
X`09    mesgPane(XRN_SERIOUS, "error in regular expression");
X#else
X`09    mesgPane(XRN_SERIOUS, reRet);
X#endif
X`09    failedSearch();
X`09    return ERROR;
X`09`7D
X    `7D
X
X    if (dir == FORWARD) `7B
X`09for (;;) `7B
X`09    if (abortP()) `7B
X`09`09return ABORT;
X`09    `7D
X`09    if (artnums`5B*position`5D == 0) `7B
X`09`09if (*position == 0) `7B
X
X`09`09    /* the string is null, no more articles are left */
X
X`09`09    return EXIT;
X`09`09`7D
X`09`09return NOMATCH;
X`09    `7D
X`09    *position = *position + 1;
X`09    if (artnums`5B*position`5D == 0) `7B
X
X`09`09/* reached end of string */
X
X`09`09return NOMATCH;
X`09    `7D
X`09    *artNum = artnums`5B*position`5D;
X`09    newauthor = getAuthor(*artNum);
X`09    utLowerCase(lowerauthor, newauthor, sizeof(lowerauthor) - 1);
X
X#ifdef SYSV_REGEX
X`09    if (regex(reRet, lowerauthor) != NULL) `7B
X#else
X`09    if (re_exec(lowerauthor)) `7B
X#endif
X`09`09/* found a match to the regular expression */
X
X`09`09gotoArticle(*artNum);
X`09`09if (getArticleText(text, ques) != XRN_OKAY) `7B
X
X`09`09    /* the matching article was invalid */
X
X`09`09    continue;
X`09`09`7D
X`09`09return MATCH;
X`09    `7D
X`09`7D
X    `7D else `7B
X`09startSearch();
X`09for (;;) `7B
X`09    if (abortP()) `7B
X
X`09`09/* reset pointers back to where we began, since the */
X`09`09/* search was aborted */
X
X`09`09failedSearch();
X`09`09return ABORT;
X`09    `7D
X`09    if ((*position == 0) &&
X`09`09(artnums`5B*position`5D == 0) ) `7B
X
X`09`09/* no more articles remain, return to Newgroup mode */
X
X`09`09return EXIT;
X`09    `7D
X`09    if (*position != 0) `7B
X
X`09`09/* we are still within the article list */
X
X`09`09*position = *position - 1;
X`09`09num = artnums`5B*position`5D;
X`09`09*artNum = num;
X`09`09if ((num % 100) == 0) `7B
X`09`09    sprintf(statBuf, "Now searching at article %d", num);
X`09`09    infoNow(statBuf);
X`09`09`7D
X`09`09newauthor = getAuthor(*artNum);
X`09`09utLowerCase(lowerauthor, newauthor, sizeof(lowerauthor) - 1);
X
X#ifdef SYSV_REGEX
X`09`09if (regex(reRet, lowerauthor) != NULL) `7B
X#else
X`09`09if (re_exec(lowerauthor)) `7B
X#endif
X`09`09    /* an article matching the regular expression was found */
X
X`09`09    gotoArticle(*artNum);
X`09`09    if (getArticleText(text, ques) != XRN_OKAY) `7B
X
X`09`09`09/* article is invalid, remove it from the text string*/
X
X`09`09`09continue;
X`09`09    `7D
X`09`09    return MATCH;
X`09`09`7D
X`09    `7D else `7B
X
X`09`09failedSearch();
X`09`09return NOMATCH;
X`09    `7D
X`09`7D
X    `7D
X`7D
X
X
Xint
XmoveToArticle(artNum, file, ques)
Xart_num artNum;`09`09`09/* number of new article */
Xchar **file, **ques;`09`09/* text and status line for new article */
X`7B
X    fillUpArray(artNum);
X
X    if (checkArticle(artNum) != XRN_OKAY) `7B
X`09return NOMATCH;
X    `7D
X
X    gotoArticle(artNum);
X    if (getArticleText(file, ques) != XRN_OKAY) `7B
X`09return ERROR;
X    `7D
X
X    return MATCH;
X`7D
$ CALL UNPACK CURSOR.C;38 1398351729
$ create 'f'
X#ifndef CURSOR_H
X#define CURSOR_H
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/cursor.h,v 1.4 1993/
V01/11 02:14:48 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * cursor.h: functions for manipulating the cursor and/or text in a
X *           text window
X */
X
X#include "news.h"
X
X#define BACK 0
X#define FORWARD 1
X
X#define NEWS_GROUP_LINE "%*15c%s"
X
Xextern void currentNewsgroup _ARGUMENTS((int, char *, char *));
Xextern void currentMode _ARGUMENTS((char *, char *, int *));
Xextern int markStringRead _ARGUMENTS((char *));
Xextern void markArticle _ARGUMENTS((art_num, int));
Xextern int subjectSearch _ARGUMENTS((int, int *, int *, char *, char **,
X`09`09`09  char **, art_num *));
Xextern int authorSearch _ARGUMENTS((int, int *, int *, char *, char **,
X`09`09`09  char **, art_num *));
Xextern int moveToArticle _ARGUMENTS((art_num, char **, char **));
X
X#endif /* CURSOR_H */
$ CALL UNPACK CURSOR.H;22 977957303
$ create 'f'
X
X#if !defined(lint) &&!defined(SABER)
Xstatic char XRNrcsid`5B`5D = "$Header: /net/objy27/wrld/mnt11/ricks/src/mast
Ver/xrn/dialogs.c,v 1.7 1993/02/04 18:22:16 ricks Exp $";
X#endif
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * dialogs.c: create simple moded dialog boxes
X */
X
X#include "copyright.h"
X#include "config.h"
X#include <stdio.h>
X#include "utils.h"
X#ifndef VMS
X#include <X11/StringDefs.h>
X#include <X11/Intrinsic.h>
X#else
X#include <decw$include/StringDefs.h>
X#include <decw$include/Intrinsic.h>
X#endif
X#ifdef MOTIF
X#include <Xm/PushB.h>
X#include <Xm/PushBG.h>
X#include <Xm/Text.h>
X#include <Xm/BulletinBP.h>
X#include <Xm/DialogS.h>
X#include <Xm/Label.h>
X#include <Xm/MessageB.h>
X#include <Xm/SelectioB.h>
X#include <Xm/SelectioBP.h>
X#include <Xm/RowColumn.h>
X#if (XmVERSION == 1) && (XmREVISION == 0)
X#define MOTIF_V10
X#include <X11/Protocols.h>
X#else
X#include <Xm/Protocols.h>
X#endif /* MOTIF_V10 */
X#else /* MOTIF */
X#ifndef VMS
X#include <X11/DECwDwtWidgetProg.h>
X#else
X#include <decw$include/DECwDwtWidgetProg.h>
X#endif /* VMS */
X#endif /* MOTIF */
X#ifndef VMS
X#include <X11/Shell.h>
X#else
X#include <decw$include/Shell.h>
X#endif
X#include "xthelper.h"
X#include "xmisc.h"
X#include "xrn.h"
X#include "dialogs.h"
X#include "resources.h"
X
X#ifdef MOTIF
XWidget
XCreateDialog(parent, title, question, textField, args, count)
XWidget parent;           /* parent window                         */
Xchar *title;`09`09 /* title for the dialog box              */
Xchar *question;          /* question for the dialog box           */
Xchar *textField;`09 /* default text field                    */
Xstruct DialogArg *args;  /* description of the buttons            */
Xunsigned int count;      /* number of buttons                     */
X/*
X * create a simple moded dialog box
X */
X`7B
X    Widget popup;
X    Arg dargs`5B10`5D;
X    Arg bargs`5B10`5D;
X    Widget button;
X    int i, j;
X    Dimension x, y, width;
X    char realTitle`5B80`5D;
X    XmString labelString;
X    XmString titleString;
X    static XtCallbackRec callbacks`5B`5D = `7B
X`09    `7B(XtCallbackProc) CBbusyCursor, NULL`7D,
X`09    `7BNULL, NULL`7D,
X`09    `7B(XtCallbackProc) CBunbusyCursor, NULL`7D,
X`09    `7BNULL, NULL`7D,
X    `7D;
X
X    static Arg rowArgs`5B`5D = `7B
X`09`7BXmNorientation, XmHORIZONTAL`7D,
X`09`7BXmNpacking,`09 XmPACK_COLUMN`7D,
X`09`7BXmNspacing,`09 20`7D
X    `7D;
X
X    Widget rowcol;
X    XmSelectionBoxWidget dialog;
X
X    /* override does not get titlebar, transient does */
X   `20
X    sprintf(realTitle, "%s: %s", app_resources.progName, title);
X    i = 0;
X    XtSetArg(dargs`5Bi`5D, XtNallowShellResize, True); i++;
X    XtSetArg(dargs`5Bi`5D, XmNtextColumns, 40); i++;
X    titleString = XmStringLtoRCreate(realTitle, XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(dargs`5Bi`5D, XmNdialogTitle, titleString);i++;
X    labelString = XmStringLtoRCreate(question, XmSTRING_DEFAULT_CHARSET);
X
X    /* create the dialog box */
X    if (textField != DIALOG_NOTEXT `7C`7C count > 3) `7B
X`09XtSetArg(dargs`5Bi`5D, XtNinput, True); i++;
X        XtSetArg(dargs`5Bi`5D, XmNselectionLabelString, labelString); i++;
X`09XtSetArg(dargs`5Bi`5D, XmNresizePolicy, XmRESIZE_GROW);i++;
X`09XtSetArg(dargs`5Bi`5D, XmNwidth, 200);i++;
X`09popup = (Widget) XmCreatePromptDialog(parent,title,dargs,i);
X`09if (textField != DIALOG_NOTEXT) `7B
X`09    i = 0;
X`09    XtSetArg(dargs`5Bi`5D, XmNcolumns, 25);i++;
X`09    XtSetArg(dargs`5Bi`5D, XmNvalue, textField);i++;
X`09    XtSetValues(XmSelectionBoxGetChild(popup, XmDIALOG_TEXT), dargs, i);
X`09`7D else `7B
X`09    XtUnmanageChild(XmSelectionBoxGetChild(popup, XmDIALOG_TEXT));
X`09`7D
X`09XmStringFree(labelString);
X`09XmStringFree(titleString);
X`09
X    /* Create the buttons */
X    /* Button 1: */
X`09
X`09callbacks`5B1`5D.callback = args`5B0`5D.handler;
X`09callbacks`5B1`5D.closure = args`5B0`5D.data;
X
X        labelString = XmStringLtoRCreate(args`5B0`5D.buttonName,
X`09`09`09`09`09 XmSTRING_DEFAULT_CHARSET);
X`09button = (Widget) XmSelectionBoxGetChild(popup,XmDIALOG_OK_BUTTON);
X`09j = 0;
X`09XtSetArg(bargs`5Bj`5D, XmNlabelString, labelString); j++;
X`09XtSetArg(bargs`5Bj`5D, XmNactivateCallback, callbacks);j++;
X
X`09XtSetValues(button, bargs, j);
X`09XmStringFree(labelString);
X
X    /* Button 2: */
X`09
X`09if (count < 2) `7B
X`09    XtUnmanageChild(XmSelectionBoxGetChild(popup,
X`09`09`09`09XmDIALOG_CANCEL_BUTTON));
X`09`7D else `7B
X`09    callbacks`5B1`5D.callback = args`5B1`5D.handler;
X`09    callbacks`5B1`5D.closure = args`5B1`5D.data;
X
X`09    labelString = XmStringLtoRCreate(args`5B1`5D.buttonName,
X`09`09`09`09`09 XmSTRING_DEFAULT_CHARSET);
X`09    button = (Widget) XmSelectionBoxGetChild(popup,
X`09`09`09`09`09`09`09XmDIALOG_CANCEL_BUTTON);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, XmNlabelString, labelString); j++;
X`09    XtSetArg(bargs`5Bj`5D, XmNactivateCallback, callbacks);j++;
X
X`09    XtSetValues(button, bargs, j);
X`09    XmStringFree(labelString);
X`09`7D
X    /* Button 3: */
X`09
X`09if (count < 3) `7B
X`09    XtUnmanageChild(XmSelectionBoxGetChild(popup,
X`09`09`09`09XmDIALOG_HELP_BUTTON));
X`09`7D else `7B
X`09    callbacks`5B1`5D.callback = args`5B2`5D.handler;
X`09    callbacks`5B1`5D.closure = args`5B2`5D.data;
X
X`09    labelString = XmStringLtoRCreate(args`5B2`5D.buttonName,
X`09`09`09`09`09 XmSTRING_DEFAULT_CHARSET);
X`09    button = (Widget) XmSelectionBoxGetChild(popup,
X`09`09`09`09`09`09`09XmDIALOG_HELP_BUTTON);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, XmNlabelString, labelString); j++;
X`09    XtSetArg(bargs`5Bj`5D, XmNactivateCallback, callbacks);j++;
X
X`09    XtSetValues(button, bargs, j);
X`09    XmStringFree(labelString);
X`09`7D
X
X    /* Button 4: */
X`09
X`09if (count < 5) `7B
X`09    if (count > 3) `7B
X`09`09callbacks`5B1`5D.callback = args`5B3`5D.handler;
X`09`09callbacks`5B1`5D.closure = args`5B3`5D.data;
X
X`09`09labelString = XmStringLtoRCreate(args`5B3`5D.buttonName,
X`09`09`09`09`09 XmSTRING_DEFAULT_CHARSET);
X`09`09button = (Widget) XmSelectionBoxGetChild(popup,
X`09`09`09`09`09XmDIALOG_APPLY_BUTTON);
X`09`09XtManageChild(button);
X`09`09j = 0;
X`09`09XtSetArg(bargs`5Bj`5D, XmNlabelString, labelString); j++;
X`09`09XtSetArg(bargs`5Bj`5D, XmNactivateCallback, callbacks);j++;
X
X`09`09XtSetValues(button, bargs, j);
X`09`09XmStringFree(labelString);
X`09    `7D
X`09`7D
X
X    /* Button 5: */
X
X`09if (count > 4) `7B
X`09    XmSelectionBoxWidget selb = (XmSelectionBoxWidget) popup;
X`09    selb->selection_box.adding_sel_widgets = True;
X`09    rowcol = XmCreateRowColumn(popup, "dialogrc", rowArgs,
X`09`09`09`09`09XtNumber(rowArgs));
X`09    selb->selection_box.adding_sel_widgets = False;
X
X`09    callbacks`5B1`5D.callback = args`5B3`5D.handler;
X`09    callbacks`5B1`5D.closure = args`5B3`5D.data;
X
X`09    labelString = XmStringLtoRCreate(args`5B3`5D.buttonName,
X`09`09`09`09`09 XmSTRING_DEFAULT_CHARSET);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, XmNlabelString, labelString); j++;
X`09    XtSetArg(bargs`5Bj`5D, XmNactivateCallback, callbacks);j++;
X`09    button = (Widget) XmCreatePushButtonGadget(rowcol,`20
X`09`09`09`09args`5B3`5D.buttonName, bargs, j);
X`09    XtManageChild(button);
X
X`09    callbacks`5B1`5D.callback = args`5B4`5D.handler;
X`09    callbacks`5B1`5D.closure = args`5B4`5D.data;
X
X`09    j = 0;
X`09    labelString = XmStringLtoRCreate(args`5B4`5D.buttonName,
X`09`09`09`09`09 XmSTRING_DEFAULT_CHARSET);
X`09    XtSetArg(bargs`5Bj`5D, XmNlabelString, labelString); j++;
X`09    XtSetArg(bargs`5Bj`5D, XmNactivateCallback, callbacks);j++;
X`09    button = (Widget) XmCreatePushButtonGadget(rowcol,`20
X`09`09`09`09args`5B4`5D.buttonName, bargs, j);
X`09    XtManageChild(button);
X`09    XmStringFree(labelString);
X`09    SB_ApplyButton(popup) = rowcol;
X`09    XtManageChild(rowcol);
X`09`7D
X
X    `7D else `7B`09/* No text field */
X
X`09XtSetArg(dargs`5Bi`5D, XtNinput, False); i++;
X        XtSetArg(dargs`5Bi`5D, XmNmessageString, labelString); i++;
X`09popup = (Widget) XmCreateQuestionDialog(parent,title,dargs,i);
X`09XmStringFree(labelString);
X`09XmStringFree(titleString);
X`09
X    /* Create the buttons */
X    /* Button 1: */
X`09
X`09callbacks`5B1`5D.callback = args`5B0`5D.handler;
X`09callbacks`5B1`5D.closure = args`5B0`5D.data;
X
X        labelString = XmStringLtoRCreate(args`5B0`5D.buttonName,
X`09`09`09`09`09 XmSTRING_DEFAULT_CHARSET);
X`09button = (Widget) XmMessageBoxGetChild(popup,XmDIALOG_OK_BUTTON);
X`09j = 0;
X`09XtSetArg(bargs`5Bj`5D, XmNlabelString, labelString); j++;
X`09XtSetArg(bargs`5Bj`5D, XmNactivateCallback, callbacks);j++;
X
X`09XtSetValues(button, bargs, j);
X`09XmStringFree(labelString);
X
X    /* Button 2: */
X`09
X`09if (count < 2) `7B
X`09    XtUnmanageChild(XmMessageBoxGetChild(popup,
X`09`09`09`09XmDIALOG_CANCEL_BUTTON));
X`09`7D else `7B
X`09    callbacks`5B1`5D.callback = args`5B1`5D.handler;
X`09    callbacks`5B1`5D.closure = args`5B1`5D.data;
X
X`09    labelString = XmStringLtoRCreate(args`5B1`5D.buttonName,
X`09`09`09`09`09 XmSTRING_DEFAULT_CHARSET);
X`09    button = (Widget) XmMessageBoxGetChild(popup,
X`09`09`09`09`09XmDIALOG_CANCEL_BUTTON);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, XmNlabelString, labelString); j++;
X`09    XtSetArg(bargs`5Bj`5D, XmNactivateCallback, callbacks);j++;
X
X`09    XtSetValues(button, bargs, j);
X`09    XmStringFree(labelString);
X`09`7D
X    /* Button 3: */
X`09
X`09if (count < 3) `7B
X`09    XtUnmanageChild(XmMessageBoxGetChild(popup,
X`09`09`09`09XmDIALOG_HELP_BUTTON));
X`09`7D else `7B
X`09    callbacks`5B1`5D.callback = args`5B2`5D.handler;
X`09    callbacks`5B1`5D.closure = args`5B2`5D.data;
X
X`09    labelString = XmStringLtoRCreate(args`5B2`5D.buttonName,
X`09`09`09`09`09 XmSTRING_DEFAULT_CHARSET);
X`09    button = (Widget) XmMessageBoxGetChild(popup,XmDIALOG_HELP_BUTTON);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, XmNlabelString, labelString); j++;
X`09    XtSetArg(bargs`5Bj`5D, XmNactivateCallback, callbacks);j++;
X
X`09    XtSetValues(button, bargs, j);
X`09    XmStringFree(labelString);
X`09`7D
X    `7D
X    unbusyCursor();
X    XtRealizeWidget(popup);
X#ifndef MOTIF_V10
X    if (textField != DIALOG_NOTEXT) `7B
X`09/* Doing this twice works around a Motif bug */
X`09XmProcessTraversal(XmSelectionBoxGetChild(popup, XmDIALOG_TEXT),
X`09`09`09`09XmTRAVERSE_CURRENT);
X`09XmProcessTraversal(XmSelectionBoxGetChild(popup, XmDIALOG_TEXT),
X`09`09`09`09XmTRAVERSE_CURRENT);
X    `7D
X#endif
X    return(popup);
X`7D
X#else /* not MOTIF */
XWidget
XCreateDialog(parent, title, question, textField, args, count)
XWidget parent;           /* parent window                         */
Xchar *title;             /* title of the dialog box               */
Xchar *question;`09`09 /* question for the dialog box           */
Xchar *textField;`09 /* default text field                    */
Xstruct DialogArg *args;  /* description of the buttons            */
Xunsigned int count;      /* number of buttons                     */
X/*
X * create a simple moded dialog box
X */
X`7B
X    DialogWidget popup;
X    Widget text;
X    Widget button4;
X    Widget button5;
X    Widget defaultButton;
X    Arg dargs`5B30`5D;
X    Arg bargs`5B10`5D;
X    int i, j;
X    Dimension x, y, width;
X    DwtCompString titleString;
X    DwtCompString labelString;
X    char realTitle`5B80`5D;
X    static XtCallbackRec callbacks`5B`5D = `7B
X`09    `7BbusyCursor, NULL`7D,
X`09    `7BNULL, NULL`7D,
X`09    `7BunbusyCursor, NULL`7D,
X`09    `7BNULL, NULL`7D,
X    `7D;
X
X    /* override does not get titlebar, transient does */
X   `20
X    sprintf(realTitle, "%s: %s", app_resources.progName, title);
X    i = 0;
X    XtSetArg(dargs`5Bi`5D, XtNallowShellResize, True); i++;
X    XtSetArg(dargs`5Bi`5D, DwtNchildOverlap, False); i++;
X    XtSetArg(dargs`5Bi`5D, DwtNunits, DwtFontUnits); i++;
X    titleString = DwtLatin1String(realTitle);
X    XtSetArg(dargs`5Bi`5D, DwtNtitle, titleString);i++;
X    labelString = DwtLatin1String(question);
X
X    /* create the dialog box */
X    if (textField != DIALOG_NOTEXT) `7B
X`09XtSetArg(dargs`5Bi`5D, DwtNinput, True); i++;
X        XtSetArg(dargs`5Bi`5D, DwtNlabel, labelString); i++;
X`09popup = (DialogWidget) DwtCautionBoxCreate((Widget)parent,(char *)title,
X`09`09`09dargs, i);
X`09XtFree(labelString);
X`09XtFree(titleString);
X    /* create the SText */
X`20
X`09i = 0;
X`09XtSetArg(dargs`5Bi`5D, DwtNvalue, textField);i++;
X`09XtSetArg(dargs`5Bi`5D, DwtNeditable, TRUE); i++;
X`09XtSetArg(dargs`5Bi`5D, DwtNx, 40);i++;
X`09XtSetArg(dargs`5Bi`5D, DwtNy, 100);i++;
X`09XtSetArg(dargs`5Bi`5D, DwtNrows, 1);i++;
X`09XtSetArg(dargs`5Bi`5D, DwtNcols, 40);i++;
X`09XtSetArg(dargs`5Bi`5D, DwtNresizeWidth, FALSE);i++;
X
X`09text = DwtSTextCreate(popup, "text", dargs, i);
X`09XtManageChild(text);
X`09
X`09i = 0;
X`09XtSetArg(dargs`5Bi`5D, DwtNuserData, text); i++;
X`09XtSetValues(popup, dargs, i);
X
X    /* Create the buttons */
X    /* Button 1: */
X`09
X`09callbacks`5B1`5D.callback = args`5B0`5D.handler;
X`09callbacks`5B1`5D.closure = args`5B0`5D.data;
X
X        labelString = DwtLatin1String(args`5B0`5D.buttonName);
X`09j = 0;
X`09XtSetArg(dargs`5Bj`5D, DwtNyesLabel, labelString); j++;
X`09XtSetArg(dargs`5Bj`5D, DwtNyesCallback, callbacks);j++;
X
X`09XtSetValues(popup, dargs, j);
X`09XtFree(labelString);
X
X    /* Button 2: */
X`09
X`09if (count < 2) `7B
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNdefaultPushbutton, DwtNoButton);j++;
X`09    XtSetValues(popup, bargs, j);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNdefaultButton, &defaultButton);j++;
X`09    XtGetValues(popup, bargs, j);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNdefaultPushbutton, DwtYesButton);j++;
X`09    XtSetValues(popup, bargs, j);
X`09    XtUnmanageChild(defaultButton);
X`09`7D else `7B
X`09
X`09    callbacks`5B1`5D.callback = args`5B1`5D.handler;
X`09    callbacks`5B1`5D.closure = args`5B1`5D.data;
X
X`09    labelString = DwtLatin1String(args`5B1`5D.buttonName);
X`09    j = 0;
X`09    XtSetArg(dargs`5Bj`5D, DwtNnoLabel, labelString); j++;
X`09    XtSetArg(dargs`5Bj`5D, DwtNnoCallback, callbacks);j++;
X
X`09    XtSetValues(popup, dargs, j);
X`09    XtFree(labelString);
X`09`7D
X    /* Button 3: */
X`09
X`09if (count < 3) `7B
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNdefaultPushbutton, DwtCancelButton);j++;
X`09    XtSetValues(popup, bargs, j);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNdefaultButton, &defaultButton);j++;
X`09    XtGetValues(popup, bargs, j);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNdefaultPushbutton, DwtYesButton);j++;
X`09    XtSetValues(popup, bargs, j);
X`09    XtUnmanageChild(defaultButton);
X`09`7D else `7B
X`09    callbacks`5B1`5D.callback = args`5B2`5D.handler;
X`09    callbacks`5B1`5D.closure = args`5B2`5D.data;
X
X`09    labelString = DwtLatin1String(args`5B2`5D.buttonName);
X`09    j = 0;
X`09    XtSetArg(dargs`5Bj`5D, DwtNcancelLabel, labelString); j++;
X`09    XtSetArg(dargs`5Bj`5D, DwtNcancelCallback, callbacks);j++;
X
X`09    XtSetValues(popup, dargs, j);
X`09    XtFree(labelString);
X`09`7D
X
X    /* Button 4: */
X
X`09if (count > 3) `7B
X`09    callbacks`5B1`5D.callback = args`5B3`5D.handler;
X`09    callbacks`5B1`5D.closure = args`5B3`5D.data;
X
X`09    labelString = DwtLatin1String(args`5B3`5D.buttonName);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNdefaultPushbutton, DwtCancelButton);j++;
X`09    XtSetValues(popup, bargs, j);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNdefaultButton, &defaultButton);j++;
X`09    XtGetValues(popup, bargs, j);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNdefaultPushbutton, DwtYesButton);j++;
X`09    XtSetValues(popup, bargs, j);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNx, &x); j++;
X`09    XtSetArg(bargs`5Bj`5D, DwtNy, &y); j++;
X`09    XtSetArg(bargs`5Bj`5D, DwtNwidth, &width); j++;
X`09    XtGetValues(defaultButton, bargs, j);
X`09    x = x + width + 10;
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNx, x); j++;
X`09    XtSetArg(bargs`5Bj`5D, DwtNy, y); j++;
X`09    XtSetArg(bargs`5Bj`5D, DwtNlabel, labelString); j++;
X`09    XtSetArg(bargs`5Bj`5D, DwtNactivateCallback, callbacks);j++;
X`09    button4 = DwtPushButtonGadgetCreate(popup,args`5B4`5D.buttonName,
X`09`09bargs, j);
X`09    XtManageChild(button4);
X`09    XtFree(labelString);
X`09`7D
X
X    /* Button 5: */
X
X`09if (count > 4) `7B
X`09    callbacks`5B1`5D.callback = args`5B4`5D.handler;
X`09    callbacks`5B1`5D.closure = args`5B4`5D.data;
X
X`09    labelString = DwtLatin1String(args`5B4`5D.buttonName);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNx, &x); j++;
X`09    XtSetArg(bargs`5Bj`5D, DwtNy, &y); j++;
X`09    XtSetArg(bargs`5Bj`5D, DwtNwidth, &width); j++;
X`09    XtGetValues(button4, bargs, j);
X`09    x = x + width + 10;
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNx, x); j++;
X`09    XtSetArg(bargs`5Bj`5D, DwtNy, y); j++;
X`09    XtSetArg(bargs`5Bj`5D, DwtNlabel, labelString); j++;
X`09    XtSetArg(bargs`5Bj`5D, DwtNactivateCallback, callbacks);j++;
X`09    button5 = DwtPushButtonGadgetCreate(popup,args`5B4`5D.buttonName,
X`09`09bargs, j);
X`09    XtManageChild(button5);
X`09    XtFree(labelString);
X`09`7D
X
X    `7D else `7B`09/* No text field */
X
X`09XtSetArg(dargs`5Bi`5D, DwtNinput, False); i++;
X        XtSetArg(dargs`5Bi`5D, DwtNlabel, labelString); i++;
X`09popup = (DialogWidget) DwtCautionBoxCreate(parent,title,dargs,i);
X`09XtFree(titleString);
X`09XtFree(labelString);
X`09
X    /* Create the buttons */
X    /* Button 1: */
X`09
X`09callbacks`5B1`5D.callback = args`5B0`5D.handler;
X`09callbacks`5B1`5D.closure = args`5B0`5D.data;
X
X        labelString = DwtLatin1String(args`5B0`5D.buttonName);
X`09j = 0;
X`09XtSetArg(dargs`5Bj`5D, DwtNyesLabel, labelString); j++;
X`09XtSetArg(dargs`5Bj`5D, DwtNyesCallback, callbacks);j++;
X
X`09XtSetValues(popup, dargs, j);
X`09XtFree(labelString);
X
X    /* Button 2: */
X`09
X`09if (count < 2) `7B
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNdefaultPushbutton, DwtNoButton);j++;
X`09    XtSetValues(popup, bargs, j);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNdefaultButton, &defaultButton);j++;
X`09    XtGetValues(popup, bargs, j);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNdefaultPushbutton, DwtYesButton);j++;
X`09    XtSetValues(popup, bargs, j);
X`09    XtUnmanageChild(defaultButton);
X`09`7D else `7B
X`09    callbacks`5B1`5D.callback = args`5B1`5D.handler;
X`09    callbacks`5B1`5D.closure = args`5B1`5D.data;
X
X`09    labelString = DwtLatin1String(args`5B1`5D.buttonName);
X`09    j = 0;
X`09    XtSetArg(dargs`5Bj`5D, DwtNnoLabel, labelString); j++;
X`09    XtSetArg(dargs`5Bj`5D, DwtNnoCallback, callbacks);j++;
X
X`09    XtSetValues(popup, dargs, j);
X`09    XtFree(labelString);
X`09`7D
X    /* Button 3: */
X`09
X`09if (count < 3) `7B
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNdefaultPushbutton, DwtCancelButton);j++;
X`09    XtSetValues(popup, bargs, j);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNdefaultButton, &defaultButton);j++;
X`09    XtGetValues(popup, bargs, j);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNdefaultPushbutton, DwtYesButton);j++;
X`09    XtSetValues(popup, bargs, j);
X`09    XtUnmanageChild(defaultButton);
X`09`7D else `7B
X`09    callbacks`5B1`5D.callback = args`5B2`5D.handler;
X`09    callbacks`5B1`5D.closure = args`5B2`5D.data;
X
X`09    labelString = DwtLatin1String(args`5B2`5D.buttonName);
X`09    j = 0;
X`09    XtSetArg(dargs`5Bj`5D, DwtNcancelLabel, labelString); j++;
X`09    XtSetArg(dargs`5Bj`5D, DwtNcancelCallback, callbacks);j++;
X
X`09    XtSetValues(popup, dargs, j);
X`09    XtFree(labelString);
X`09`7D
X
X    /* Button 4: */
X
X`09if (count > 3) `7B
X`09    callbacks`5B1`5D.callback = args`5B3`5D.handler;
X`09    callbacks`5B1`5D.closure = args`5B3`5D.data;
X
X`09    labelString = DwtLatin1String(args`5B3`5D.buttonName);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNdefaultPushbutton, DwtCancelButton);j++;
X`09    XtSetValues(popup, bargs, j);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNdefaultButton, &defaultButton);j++;
X`09    XtGetValues(popup, bargs, j);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNdefaultPushbutton, DwtYesButton);j++;
X`09    XtSetValues(popup, bargs, j);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNx, &x); j++;
X`09    XtSetArg(bargs`5Bj`5D, DwtNy, &y); j++;
X`09    XtSetArg(bargs`5Bj`5D, DwtNwidth, &width); j++;
X`09    XtGetValues(defaultButton, bargs, j);
X`09    x = x + width + 10;
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNx, x); j++;
X`09    XtSetArg(bargs`5Bj`5D, DwtNy, y); j++;
X`09    XtSetArg(bargs`5Bj`5D, DwtNlabel, labelString); j++;
X`09    XtSetArg(bargs`5Bj`5D, DwtNactivateCallback, callbacks);j++;
X`09    button4 = DwtPushButtonGadgetCreate(popup,args`5B4`5D.buttonName,
X`09`09bargs, j);
X`09    XtManageChild(button4);
X`09    XtFree(labelString);
X`09`7D
X
X    /* Button 5: */
X
X`09if (count > 4) `7B
X`09    callbacks`5B1`5D.callback = args`5B4`5D.handler;
X`09    callbacks`5B1`5D.closure = args`5B4`5D.data;
X
X`09    labelString = DwtLatin1String(args`5B4`5D.buttonName);
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNx, &x); j++;
X`09    XtSetArg(bargs`5Bj`5D, DwtNy, &y); j++;
X`09    XtSetArg(bargs`5Bj`5D, DwtNwidth, &width); j++;
X`09    XtGetValues(button4, bargs, j);
X`09    x = x + width + 10;
X`09    j = 0;
X`09    XtSetArg(bargs`5Bj`5D, DwtNx, x); j++;
X`09    XtSetArg(bargs`5Bj`5D, DwtNy, y); j++;
X`09    XtSetArg(bargs`5Bj`5D, DwtNlabel, labelString); j++;
X`09    XtSetArg(bargs`5Bj`5D, DwtNactivateCallback, callbacks);j++;
X`09    button5 = DwtPushButtonGadgetCreate(popup,args`5B4`5D.buttonName,
X`09`09bargs, j);
X`09    XtManageChild(button5);
X`09    XtFree(labelString);
X`09`7D
X    `7D
X    unbusyCursor();
X    XtRealizeWidget(popup);
X
X    return((Widget)popup);
X`7D
X#endif /* MOTIF */
X
X#ifdef DECFOCUSPATCH
Xvoid
XFocusPopUp(popup, data, event)
XWidget popup;
Xcaddr_t data;
XXEvent *event;
X`7B
X    if (event->type == MapNotify) `7B
X`09XSetInputFocus(XtDisplay(popup), XtWindow(popup),
X`09`09     RevertToPointerRoot,  CurrentTime);
X`09XtRemoveEventHandler(popup, XtAllEvents, True, FocusPopUp, 0);
X    `7D
X    return;
X`7D
X#endif
X
Xextern Boolean allowErrors;
Xvoid
XPopUpDialog(popup)
XWidget popup;
X`7B
X
X    unbusyCursor();
X    if (!allowErrors)
X`09xthCenterWidgetOverCursor(popup);
X    XtManageChild(popup);
X    XtPopup(XtParent(popup), XtGrabExclusive);
X#ifdef MOTIF
X#ifndef MOTIF_V10
X
X    if (XtIsSubclass(popup, xmSelectionBoxWidgetClass)) `7B
X`09Widget widget;
X
X`09widget = XmSelectionBoxGetChild(popup, XmDIALOG_TEXT);
X`09if (widget != (Widget) NULL && XtIsManaged(widget)) `7B
X`09    XmProcessTraversal(widget, XmTRAVERSE_CURRENT);
X`09    XmProcessTraversal(widget, XmTRAVERSE_CURRENT);
X`09`7D else `7B
X`09    widget = XmSelectionBoxGetChild(popup, XmDIALOG_OK_BUTTON);
X`09    if (widget != (Widget) NULL && XtIsManaged(widget)) `7B
X`09`09XmProcessTraversal(widget, XmTRAVERSE_CURRENT);
X`09`09XmProcessTraversal(widget, XmTRAVERSE_CURRENT);
X`09    `7D
X`09`7D
X    `7D
X    if (XtIsSubclass(popup, xmMessageBoxWidgetClass)) `7B
X`09Widget widget;
X
X`09widget = XmMessageBoxGetChild(popup, XmDIALOG_OK_BUTTON);
X`09if (widget != (Widget) NULL && XtIsManaged(widget)) `7B
X`09    XmProcessTraversal(widget, XmTRAVERSE_CURRENT);
X`09    XmProcessTraversal(widget, XmTRAVERSE_CURRENT);
X`09`7D
X    `7D
X#endif
X#endif
X    return;
X`7D
X
X
Xvoid
XPopDownDialog(dialog)
XWidget dialog;
X/*
X * pop down the dialog (do not destroy, it will be used again)
X */
X`7B
X    XtUnmanageChild(dialog);
X    XtUnmapWidget(XtParent(dialog));
X    XtPopdown(XtParent(dialog));
X    return;
X`7D
X
X
X
Xchar *
XGetDialogValue(popup)
XWidget popup;
X`7B
X#ifdef MOTIF
X    return XmTextGetString(XmSelectionBoxGetChild(popup, XmDIALOG_TEXT));
X#else
X    Arg`09args`5B4`5D;
X    Widget w;
X
X    XtSetArg(args`5B0`5D, DwtNuserData, &w);
X    XtGetValues(popup, args, 1);
X
X    return DwtSTextGetString(w);
X#endif
X`7D
X
Xvoid
XSetDialogValue(popup, text)
XWidget popup;
Xchar *text;
X`7B
X#ifdef MOTIF
X    XmTextSetString(XmSelectionBoxGetChild(popup, XmDIALOG_TEXT), text);
X#else
X    Arg`09args`5B4`5D;
X    Widget w;
X
X    XtSetArg(args`5B0`5D, DwtNuserData, &w);
X    XtGetValues(popup, args, 1);
X
X    DwtSTextSetString(w, text);
X#endif
X`7D
X
X/*
X * simple confirmation box
X */
X
Xint CBretVal;
X
X/* ARGSUSED */
Xstatic void
XcbHandler(widget, client_data, call_data)
XWidget widget;
Xcaddr_t client_data;
Xcaddr_t call_data;
X`7B
X    CBretVal = (int) client_data;
X    return;
X`7D
X
X
Xstatic XtCallbackRec ConfirmOkCallback`5B`5D = `7B
X`09`7B(XtCallbackProc) cbHandler, (caddr_t) XRN_CB_CONTINUE`7D,
X`09`7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec ConfirmCancelCallback`5B`5D = `7B
X`09`7B(XtCallbackProc) cbHandler, (caddr_t) XRN_CB_ABORT`7D,
X`09`7BNULL, NULL`7D,
X`7D;
Xstatic Widget ConfirmBox = NULL;
X#ifdef MOTIF
Xextern Atom XmInternAtom();
Xint
XConfirmationBox(parent, message)
XWidget parent;
Xchar *message;
X/*
X * pop up a confirmation box and return either 'XRN_CB_ABORT' or 'XRN_CB_CON
VTINUE'
X */
X`7B
X    XEvent ev;
X    XtInputMask mask;
X    Arg`09   args`5B5`5D;
X    XmString`09labelString, titleString;
X    Atom`09WmTakeFocusAtom;
X
X    CBretVal = -1;
X
X    labelString = XmStringLtoRCreate(message, XmSTRING_DEFAULT_CHARSET);
X    titleString = XmStringLtoRCreate("mxrn: Confirm", XmSTRING_DEFAULT_CHARS
VET);
X    XtSetArg(args`5B0`5D, XmNmessageString, labelString);
X    XtSetArg(args`5B1`5D, XmNokCallback, ConfirmOkCallback);
X    XtSetArg(args`5B2`5D, XmNcancelCallback, ConfirmCancelCallback);
X    XtSetArg(args`5B3`5D, XmNdefaultButtonType, XmDIALOG_OK_BUTTON);
X    XtSetArg(args`5B4`5D, XmNdialogTitle, titleString);
X    if (ConfirmBox == (Widget) NULL) `7B
X        ConfirmBox = (Widget) XmCreateQuestionDialog(parent,"confirmBox",
X`09`09`09`09    args, XtNumber(args));
X`09XtUnmanageChild(XmMessageBoxGetChild(ConfirmBox,XmDIALOG_HELP_BUTTON));
X`09WmTakeFocusAtom = XmInternAtom (XtDisplay(ConfirmBox),
X`09`09`09`09`09"WM_TAKE_FOCUS", False);
X`09XmDeactivateWMProtocol(XtParent(ConfirmBox), WmTakeFocusAtom);
X    `7D else `7B
X`09XtSetValues(ConfirmBox, args, XtNumber(args));
X    `7D
X    XmStringFree(labelString);
X    XmStringFree(titleString);
X#else /* not MOTIF */
Xint
XConfirmationBox(parent, message)
XWidget parent;
Xchar *message;
X/*
X * pop up a confirmation box and return either 'XRN_CB_ABORT' or 'XRN_CB_CON
VTINUE'
X */
X`7B
X    XEvent  ev;
X    XtInputMask mask;
X    Arg`09    args`5B7`5D;
X    DwtCompString labelString, titleString;
X
X    CBretVal = -1;
X
X    labelString = DwtLatin1String(message);
X    titleString = DwtLatin1String("dxrn: Confirm");
X    XtSetArg(args`5B0`5D, DwtNlabel, labelString);
X    XtSetArg(args`5B1`5D, DwtNyesCallback, ConfirmOkCallback);
X    XtSetArg(args`5B2`5D, DwtNnoCallback, ConfirmCancelCallback);
X    XtSetArg(args`5B3`5D, DwtNcancelCallback, ConfirmCancelCallback);
X    XtSetArg(args`5B4`5D, DwtNdefaultPushbutton, DwtYesButton);
X    XtSetArg(args`5B5`5D, DwtNstyle, DwtModeless);
X    XtSetArg(args`5B6`5D, DwtNtitle, titleString);
X    if (ConfirmBox == (Widget) NULL) `7B
X`09ConfirmBox= (Widget) DwtCautionBoxCreate(parent,"confirmBox",
X`09`09`09args, XtNumber(args));
X    `7D else `7B
X`09XtSetValues(ConfirmBox, args, XtNumber(args));
X    `7D
X    XtFree(labelString);
X    XtFree(titleString);
X#endif /* MOTIF */
X    PopUpDialog(ConfirmBox);
X
X    for(;;) `7B
X`09XtProcessEvent(XtIMAll);
X`09if (CBretVal != -1) `7B
X`09    PopDownDialog(ConfirmBox);
X`09    while ((mask = XtPending()) != 0) `7B
X`09`09if (mask == XtIMTimer) `7B
X`09`09    XtProcessEvent(XtIMAll);
X`09`09`7D else `7B
X`09`09    XtNextEvent(&ev);
X`09`09    XtDispatchEvent(&ev);
X`09`09`7D
X`09    `7D
X`09    return(CBretVal);
X`09`7D
X    `7D
X`7D
$ CALL UNPACK DIALOGS.C;68 2003217069
$ create 'f'
X#ifndef DIALOGS_H
X#define DIALOGS_H
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/dialogs.h,v 1.5 1993
V/01/11 02:14:51 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X#ifdef MOTIF
X#include <X11/Intrinsic.h>
X#else
X#ifndef VMS
X#include <X11/Intrinsic.h>
X#else
X#include <decw$include/Intrinsic.h>
X#endif
X#endif
X
X/*
X * dialogs.h: create simple moded dialog boxes
X *
X */
X
X
X/* description of a button */
Xstruct DialogArg `7B
X    char *buttonName;
X    void (*handler)();
X    caddr_t data;
X`7D;
X
X#define DIALOG_TEXT ""
X#define DIALOG_NOTEXT (char *)0
X
Xextern Widget CreateDialog _ARGUMENTS((Widget, char *, char *, char *,
X`09struct DialogArg *, unsigned int));
X
Xextern void PopUpDialog _ARGUMENTS((Widget));
Xextern void PopDownDialog _ARGUMENTS((Widget));
X
Xextern char *GetDialogValue _ARGUMENTS((Widget));
X
Xextern int ConfirmationBox _ARGUMENTS((Widget, char *));
X
Xextern void SetDialogValue _ARGUMENTS((Widget, char *));
X
X#define XRN_CB_ABORT 0
X#define XRN_CB_CONTINUE 1
X
X#endif /* DIALOGS_H */
$ CALL UNPACK DIALOGS.H;2 1494367526
$ create 'f'
XXRN.OBJ
XBUTTONS.OBJ
XCOMPOSE.OBJ
XCURSOR.OBJ
XDIALOGS.OBJ
XERROR_HNDS.OBJ
XKILLFILE.OBJ
XMENUS.OBJ
XMESG.OBJ
XNEWSRCFILE.OBJ
XNEWSRC_PARSE.OBJ
XRESOURCES.OBJ
XINTERNALS.OBJ
XSAVE.OBJ
XSERVER.OBJ
XUTILS.OBJ
XXMISC.OBJ
XXTHELPER.OBJ
XAVL.OBJ
XCLIENTLIB.OBJ
XT6.OBJ
XT7.OBJ
XPANE.OBJ
XSLIST.OBJ
XSYS$SHARE:DECW$DWTLIBSHR/SHAREABLE
XSYS$SHARE:DECW$XLIBSHR/SHAREABLE
XSYS$SHARE:VAXCRTL/SHAREABLE
X!
X! Uncomment out the library you need to use
X!
X!sys$share:ucx$ipc/library`09`09! For UCX users
X!
XMULTINET_SOCKET_LIBRARY/SHAREABLE`09! For MultiNet Users
X!
$ CALL UNPACK DXRN.OPT;3 119066177
$ create 'f'
X
X#if !defined(lint) && !defined(SABER)
Xstatic char XRNrcsid`5B`5D = "$Header: /net/objy27/wrld/mnt11/ricks/src/mast
Ver/xrn/error_hnds.c,v 1.6 1993/01/11 02:14:53 ricks Exp $";
X#endif
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * error_handlers.c: routines for error/signal handling
X *
X */
X
X#include "copyright.h"
X#include <stdio.h>
X#include "config.h"
X#include "utils.h"
X#include <signal.h>
X#ifndef VMS
X#include <X11/Intrinsic.h>
X#else
X#include <decw$include/Intrinsic.h>
X#endif
X#include <errno.h>
X#include "dialogs.h"
X#include "xmisc.h"
X#include "xthelper.h"
X#include "news.h"
X#include "internals.h"
X#include "xrn.h"
X#include "mesg.h"
X#include "error_hnds.h"
X#include "resources.h"
X#include "newsrcfile.h"
X#ifdef __STDC__
X#include <stdlib.h>
X#include <time.h>
X#ifndef VMS
X#include <unistd.h>
X#else
X#include <unixlib.h>
Xextern int sys$putmsg();
X#endif
X#endif
X
Xextern void close_server();
Xstatic int retryNotifier();
X
X/*
X * error handlers - major purpose is to close down 'rn' cleanly
X */
X
XBoolean allowErrors = False;
X
X/*ARGSUSED*/
Xstatic int
XxrnXIOError(display)
XDisplay *display;
X`7B
X    XRNState &= `7EXRN_X_UP;
X    sprintf(error_buffer, "XIO Error: %s", errmsg(errno));
X    ehErrorExitXRN(error_buffer);
X    return 0;
X`7D
X
X
X/*ARGSUSED*/
Xstatic int
XxrnXError(display, event)
XDisplay *display;
XXErrorEvent *event;
X`7B
X    char buffer`5B1024`5D;
X
X    if (allowErrors) return;
X#ifdef ERRORBUG
X`09if (event->request_code == 4) `09`09/* destroy window errors */
X`09return;`09`09`09`09`09/* Bug workaround */
X#endif
X
X    if (event->request_code == 42) return;`09/* Ignore 'set input focus' err
Vs */
X    if (event->request_code == 91) `7B`09`09/* Colormap errors */
X#ifdef MOTIF
X`09(void) fprintf(stderr, "mxrn: colormap query failure\n");
X#else
X`09(void) fprintf(stderr, "dxrn: colormap query failure\n");
X#endif
X`09return 0;
X    `7D
X    XGetErrorText(display, event->error_code, buffer, sizeof(buffer));
X#ifdef MOTIF
X    (void) fprintf(stderr, "mxrn: X Error: %s\n", buffer);
X#else
X    (void) fprintf(stderr, "dxrn: X Error: %s\n", buffer);
X#endif
X    (void) fprintf(stderr, "    serial number: %d\n", event->serial);
X    (void) fprintf(stderr, "    error code:  %d\n", (int) event->error_code)
V;
X    (void) fprintf(stderr, "    request code:  %d\n", (int) event->request_c
Vode);
X    (void) fprintf(stderr, "    minor code:  %d\n", (int) event->minor_code)
V;
X    (void) fprintf(stderr, "    resource id: %d\n", (int) event->resourceid)
V;
X    if (app_resources.dumpCore) `7B
X`09XRNState &= `7EXRN_X_UP;
X`09ehErrorExitXRN("X Error");
X    `7D else `7B
X`09retryNotifier("X Error");
X    `7D
X    return 0;
X`7D
X
Xstatic int
XxrnXtWarning()
X`7B
X/* Ignore warnings - specifically focus grabs */
X    return 0;
X`7D
X
X/*ARGSUSED*/
Xstatic int
XxrnXtError(errorMessage)
XString errorMessage;
X`7B
X#define XTERRORINTRO "X Toolkit Error: "
X    char buffer`5B80`5D;
X    if (allowErrors) return;
X
X    strcpy(buffer, XTERRORINTRO);
X    strncat(buffer, errorMessage, sizeof(buffer) - sizeof(XTERRORINTRO));
X#ifdef MOTIF
X    (void) fprintf(stderr, "mxrn: %s\n", buffer);
X#else
X    (void) fprintf(stderr, "dxrn: %s\n", buffer);
X#endif
X    if (app_resources.dumpCore) `7B
X`09XRNState &= `7EXRN_X_UP;
X`09ehErrorExitXRN(buffer);
X    `7D else `7B
X`09retryNotifier(buffer);
X    `7D
X#undef XTERRORINTRO
X`7D
X
Xvoid
XehInstallErrorHandlers()
X`7B
X#ifndef NOERRHAND
X    XtSetWarningMsgHandler((XtErrorMsgHandler)xrnXtWarning);
X    XtSetErrorHandler((XtErrorHandler)xrnXtError);
X    XSetErrorHandler(xrnXError);
X    XSetIOErrorHandler(xrnXIOError);
X#endif
X    return;
X`7D
X
X
Xstatic void
Xsig_catcher(signo)
Xint signo;
X`7B
X    char buffer`5B80`5D;
X   `20
X    /* allow HUP's and INT's to do a clean exit */
X    if ((signo == SIGHUP) `7C`7C (signo == SIGINT)) `7B
X`09ehCleanExitXRN();
X    `7D
X
X    (void) sprintf(buffer, "Caught signal (%d), cleaned up .newsrc and remov
Ved temp files", signo);
X
X    (void) signal(signo, SIG_DFL);
X    ehSignalExitXRN(buffer);
X    (void) kill(getpid(), signo);
X`7D
X
X
Xvoid
XehInstallSignalHandlers()
X`7B
X
X    if (! app_resources.dumpCore) `7B
X`09int i;
X#if defined(sun) `7C`7C defined(ultrix) `7C`7C defined(_ANSI_C_SOURCE) `7C`7
VC defined(__osf__) `7C`7C defined(sgi) `7C`7C defined(__vms)
X`09  void (*oldcatcher)();
X#else
X`09  int (*oldcatcher)();
X#endif
X
X`09for (i = 1; i <= SIGTERM; i++) `7B
X`09    switch(i) `7B
X#ifdef SIGSTOP
X`09    case SIGSTOP:
X#endif
X#ifdef SIGTSTP
X`09    case SIGTSTP:
X#endif
X#ifdef SIGCONT
X`09    case SIGCONT:
X#endif
X`09`09break;
X
X`09    case SIGPIPE:
X`09`09(void) signal(i, SIG_IGN);
X`09`09break;
X
X`09    default:
X#ifdef __STDC__
X`09`09oldcatcher = signal(i, sig_catcher);
X#else
X`09`09oldcatcher = signal(i, (SIG_PF0) sig_catcher);
X#endif
X`09`09if (oldcatcher == SIG_IGN) `7B
X`09`09    (void) signal(i, SIG_IGN);
X`09`09`7D
X`09`09break;
X`09    `7D
X`09`7D
X    `7D
X    return;
X`7D
X
X
Xstatic int retry;
Xstatic int die = 0;
X
Xstatic void
XmyAbort()
X`7B
X    die = 1;
X    return;
X`7D   `20
X
X
Xstatic void
XmyExit()
X`7B
X#ifdef VMS
X    exit(1);
X#else
X    exit(-1);
X#endif
X`7D
X
X
Xstatic void
XRetry()
X`7B
X    retry = 1;
X    return;
X`7D
X
Xstatic void
XdeathNotifier(message)
Xchar *message;
X`7B
X    XEvent ev;
X
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Exit", myAbort, (caddr_t) -1`7D,
X    `7D;
X
X    die = 0;
X   `20
X    if ((XRNState & XRN_X_UP) != XRN_X_UP) `7B
X#ifdef MOTIF
X`09(void) fprintf(stderr, "mxrn: %s\n", message);
X#else
X`09(void) fprintf(stderr, "dxrn: %s\n", message);
X#endif
X`09return;
X    `7D
X
X    /* XXX unmap icon */
X    XtMapWidget(TopLevel);
X    PopUpDialog(CreateDialog(TopLevel, "Fatal Error",
X`09`09message, DIALOG_NOTEXT, args, XtNumber(args)));
X
X    while (!die) `7B
X`09XtNextEvent(&ev);
X`09XtDispatchEvent(&ev);
X    `7D
X
X    return;
X`7D
Xstatic int
XretryNotifier(message)
Xchar *message;
X`7B
X    XEvent ev;
X    Widget dialog;
X   `20
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Exit", myAbort, (caddr_t) -1`7D,
X`09`7B"Retry", Retry, (caddr_t) -1`7D,
X    `7D;
X
X    die = retry = 0;
X   `20
X    if ((XRNState & XRN_X_UP) != XRN_X_UP) `7B
X#ifdef MOTIF
X`09(void) fprintf(stderr, "mxrn: %s\n", message);
X#else
X`09(void) fprintf(stderr, "dxrn: %s\n", message);
X#endif
X`09return 0;
X    `7D
X
X    /* XXX unmap icon */
X    XtMapWidget(TopLevel);
X    dialog = CreateDialog(TopLevel, "Warning Retry",
X`09`09`09  message, DIALOG_NOTEXT, args,
X`09`09`09  XtNumber(args));
X    PopUpDialog(dialog);
X
X    while (!retry && !die) `7B
X`09XtNextEvent(&ev);
X`09XtDispatchEvent(&ev);
X    `7D
X
X    PopDownDialog(dialog);
X   `20
X    return retry;
X`7D
X
Xstatic Widget warnWidget = (Widget) NULL;
Xstatic void unmapWarn()
X`7B
X   PopDownDialog(warnWidget);
X   XtDestroyWidget(warnWidget);
X   warnWidget = (Widget) NULL;
X`7D
Xvoid
Xwarning(message)
Xchar *message;
X`7B
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"OK", unmapWarn, (caddr_t) -1`7D,
X    `7D;
X
X    if ((XRNState & XRN_X_UP) != XRN_X_UP) `7B
X`09(void) fprintf(stderr, "%s\n", message);
X`09return;
X    `7D
X
X    /* XXX unmap icon */
X    XtMapWidget(TopLevel);
X    if (warnWidget != (Widget) NULL)
X`09return;
X    PopUpDialog(warnWidget =
X        CreateDialog(TopLevel, "Warning",
X`09`09message, DIALOG_NOTEXT, args, XtNumber(args)));
X
X    return;
X`7D
X
X
X#define XRN_NORMAL_EXIT_BUT_NO_UPDATE 2
X#define XRN_NORMAL_EXIT 1
X#define XRN_ERROR_EXIT 0
X#define XRN_SIGNAL_EXIT -1
X     `20
Xstatic void
XexitXRN(status)
Xint status;
X`7B
X    static int beenHere = 0;
X    extern Boolean printPending;
X    char buffer`5B1024`5D, pname`5B512`5D;
X#ifdef VMS
X    if (printPending) `7B
X`09printPending = False;
X`09(void) sprintf(pname, "%sXRN_PRINT_%u.LIS", app_resources.tmpDir,
X`09`09getpid());
X`09(void) sprintf(buffer, "%s %s",
X`09`09    app_resources.printCommand, pname);
X`09(void) system(buffer);
X    `7D
X#else
X    if (printPending) `7B
X`09printPending = False;
X`09(void) sprintf(pname, "%sXrn_print_%u", app_resources.tmpDir,
X`09`09getpid());
X`09(void) sprintf(buffer, "%s %s",
X`09`09    app_resources.printCommand, pname);
X`09(void) system(buffer);
X    `7D
X#endif`09
X
X    /*
X     * immediate exit, exitXRN was called as a result of something in
X     * itself
X     */`20
X    if (beenHere == 1) `7B
X`09exit(-1);
X    `7D
X   `20
X    beenHere = 1;
X
X    if ((XRNState & XRN_NEWS_UP) == XRN_NEWS_UP) `7B
X`09/* XXX is this really needed?  does free files... */
X`09releaseNewsgroupResources();
X
X`09if (status != XRN_NORMAL_EXIT_BUT_NO_UPDATE) `7B
X`09    if (!updatenewsrc()) `7B
X#ifdef MOTIF
X`09`09fprintf(stderr, "mxrn: .newsrc file update failed\n");
X#else
X`09`09fprintf(stderr, "dxrn: .newsrc file update failed\n");
X#endif
X`09    `7D
X`09`7D
X    `7D
X
X    close_server();
X
X    /* clean up the lock */
X    removeLock();
X
X    return;
X`7D
X
X
Xextern void CustomizeSave();
Xextern Boolean getUpdateStatus();
Xstatic int ExitType;
X
Xstatic Widget saveQuestion = (Widget) 0;
X
Xstatic void saveAndExit()
X`7B
X    CustomizeSave();
X    exitXRN(ExitType);
X    exit(0);
X`7D
X
Xstatic void justExit()
X`7B
X    exitXRN(ExitType);
X    exit(0);
X`7D
X
Xstatic void noExit()
X`7B
X    PopDownDialog(saveQuestion);
X`7D
X
Xstatic struct DialogArg customArgs`5B`5D = `7B
X    `7B"Yes", saveAndExit, (caddr_t) -1`7D,
X    `7B"No",  justExit,    (caddr_t) -1`7D,
X    `7B"Continue", noExit, (caddr_t) -1`7D,
X`7D;
X
Xstatic void
XcheckCustomSave(exitType)
Xint exitType;
X`7B
X    ExitType = exitType;
X
X    if (saveQuestion == (Widget) 0) `7B
X`09saveQuestion = CreateDialog(TopLevel, "Save settings",
X`09    "Customize settings have not been saved\nSave them before exiting?",
X`09    DIALOG_NOTEXT, customArgs, XtNumber(customArgs));
X    `7D
X    PopUpDialog(saveQuestion);
X    return;
X`7D
X
Xvoid
XehNoUpdateExitXRN()
X`7B
X    if (getUpdateStatus()) `7B
X`09checkCustomSave(XRN_NORMAL_EXIT_BUT_NO_UPDATE);
X    `7D else `7B
X`09exitXRN(XRN_NORMAL_EXIT_BUT_NO_UPDATE);
X`09exit(0);
X    `7D
X`7D
X
Xvoid
XehCleanExitXRN()
X`7B
X    if (getUpdateStatus()) `7B
X`09checkCustomSave(XRN_NORMAL_EXIT);
X    `7D else `7B
X`09exitXRN(XRN_NORMAL_EXIT);
X`09exit(0);
X    `7D
X`7D
X
X
Xvoid
XehErrorExitXRN(message)
Xchar *message;
X`7B
X    exitXRN(XRN_ERROR_EXIT);
X    deathNotifier(message);
X    exit(-1);
X`7D
X
Xint
XehErrorRetryXRN(message, save)
Xchar *message;
XBoolean save;
X`7B
X    int retryFlag;
X    `20
X    retryFlag = retryNotifier(message);
X
X    if (!retryFlag && save) `7B
X`09exitXRN(XRN_ERROR_EXIT);
X`09exit(-1);
X    `7D
X   `20
X    return retryFlag;
X`7D
X   `20
Xvoid
XehSignalExitXRN(message)
Xchar *message;
X`7B
X    exitXRN(XRN_SIGNAL_EXIT);
X    deathNotifier(message);
X    return;
X`7D   `20
X#ifdef VMS
X#include <descrip.h>
Xstatic char`09ErrMessage`5B255`5D;
X
Xstatic int grabErrorText(descr)
Xstruct dsc$descriptor_s *descr;
X`7B
X    char *p;
X    short s;
X    s = (short)descr->dsc$w_length;
X    p = (char *)descr->dsc$a_pointer;
X    strncpy(ErrMessage, p, s);   `20
X    ErrMessage`5Bs`5D = '\0';
X    mesgPane(XRN_SERIOUS `7C XRN_APPEND, "%s", ErrMessage);
X    return 0;
X`7D
Xvoid
XehVMSerror(text, sts, stv)
Xchar *text;
Xint sts;
Xint stv;
X`7B
X    int args`5B4`5D;
X    mesgDisableRedisplay();
X    mesgPane(XRN_SERIOUS, text);
X    args`5B0`5D = 2;
X    args`5B1`5D = sts;
X    args`5B2`5D = stv;
X    args`5B3`5D = 0;
X    sys$putmsg(args, grabErrorText, 0, 0);
X    mesgEnableRedisplay();
X`7D
X#endif
$ CALL UNPACK ERROR_HNDS.C;48 929506943
$ create 'f'
X#ifndef ERROR_HANDLERS_H
X#define ERROR_HANDLERS_H
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/error_hnds.h,v 1.5 1
V993/01/11 02:14:55 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * error_handlers.h: routines for error/signal handling
X *
X */
X
Xextern void warning _ARGUMENTS((char *));
Xextern void ehErrorExitXRN _ARGUMENTS((char *));
Xextern void ehSignalExitXRN _ARGUMENTS((char *));
Xextern void ehCleanExitXRN();
Xextern void ehNoUpdateExitXRN();
Xextern int ehErrorRetryXRN();
X
X/* install the X and Xtoolkit error handlers */
Xextern void ehInstallErrorHandlers();
X
X/* install the signal handlers */
Xextern void ehInstallSignalHandlers();
X
X#ifndef VMS
Xextern int errno, sys_nerr;
Xextern char *sys_errlist`5B`5D;
X#define errmsg(a) ((a < sys_nerr) ? sys_errlist`5Ba`5D : "unknown error")
X#else
X#include <errno.h>
X#include <perror.h>
X#ifdef __DECC
X#define errmsg(a) ((a < __ERRNO_MAX) ? strerror(a) : "unknown error")
X#else
X#define errmsg(a) ((a < sys_nerr) ? sys_errlist`5Ba`5D : "unknown error")
X#endif
Xextern void ehVMSerror _ARGUMENTS((char *, int, int));
X#endif
X
X#endif /* ERROR_HANDLERS_H */
$ CALL UNPACK ERROR_HNDS.H;22 1198807796
$ create 'f'
X
XWe would like to the thank the following people for sending us bug
Xfixes, porting to new OS's, and new features (hopefully we haven't
Xleft out too many people):
X
X    Salvador Pinto Abreu`09<spa@fctunl.rccn.pt>
X    Jeff Anton`09`09`09<anton@scam.Berkeley.EDU>
X    Jason C. Austin`09`09<sun!larc.nasa.gov!j.c.austin>
X    Frederick M. Avolio`09`09<avolio@decuac.dec.com>
X    Glenn T. Barry`09`09<glenn@mathcs.emory.edu>
X    Chip Boling`09`09`09<chip@ingr.com>
X    Stephane Bortzmeyer`09`09<bortzmeyer@cnam.fr>
X    John Brezak`09`09`09<brezak@apollo.hp.com>
X    David Brooks`09`09<dbrooks@osf.org>
X    Michael Burns`09`09<burns@chem.psu.edu>
X    Keith Cantrell`09`09<kcantrel@core1.hssc.ksc.nasa.gov>
X    Andy Cohen`09`09`09<cohen@bucrf16.bu.edu>
X    Mark Costlow`09`09<edsr!jupiter!cheeks@uunet.uu.net>
X    Ian Darwin`09`09`09<ian@sq.com>
X    Phil Dykstra`09`09<phil@BRL.MIL>
X    Greg Earle`09`09`09<earle@poseur.jpl.nasa.gov>
X    Haavard Eidnes`09`09<he@idt.unit.no>
X    David Elliott`09`09<dce@smsc.sony.com>
X    Bob Ellison`09`09`09<ellison@sei.cmu.edu>
X    Marc Evans`09`09`09<evans@Synergytics.Com>
X    Jim Graham`09`09`09<flar@eng.sun.com>
X    Dan R. Greening`09`09<dgreen@cs.ucla.edu>
X    Dirk Grunwald`09`09<grunwald.flute.cs.uiuc.edu>
X    Don Hamparian`09`09<hamparian@idicl1.idi.oclc.org>
X    Mark Hastings`09`09<hastings@walnut.berkeley.edu>
X    Per Hedeland`09`09<per@erix.ericsson.se>
X    Kevin Herbert`09`09<herbert@gr8ful.enet.dec.com>
X    Gerd Hillebrand`09`09<ggh@cs.brown.edu>
X    P. Allen Jensen`09`09<jensen%bessel@gatech.edu>
X    JQ Johnson`09`09`09<jqj@rt-jqj.stanford.edu>
X    David Joyner`09`09<david_joyner@ncsu.edu>
X    Casey Leedom`09`09<casey@gauss.llnl.gov>
X    Dave Lemke`09`09`09<lemke@ncd.com>
X    Andy Linton`09`09`09<asjl@comp.vuw.ac.nz>
X    Steve Losen`09`09`09<scl@virginia.edu>
X    Sean Kamath`09`09`09<kamath%catenary.wv.tek.com@relay.cs.net>
X    Jonathan I. Kamens`09`09<jik@pit-manager.mit.edu>
X    Tevfik Karagulle`09`09<tev@cama01.uio.no>
X    Phil Karlton`09`09<karlton@fudge.wpd.sgi.com>
X    Brendan Kehoe`09`09<brendan@eff.org>
X    Mark J. Kilgard`09`09<@rice.edu:mjk@uncle-bens.rice.edu>
X    Conrad Kimball`09        <cek@sdc.boeing.com>
X    Nathan Maman`09`09<Nathan.Maman@mirsa.inria.fr>
X    Harper Mann`09`09`09<harper@mips.com>
X    Greg McNutt`09`09`09<gcmcnutt@mlsgcm.Ebay.sun.COM>
X    Matthew Merzbacher`09`09<matthew@cs.ucla.edu>
X    Dale Moore`09`09`09<Dale.Moore@cs.cmu.edu>
X    Keith Moore`09`09`09<moore@cs.utk.edu>
X    Rick Murphy`09`09`09<murphy@ufp.dco.dec.com>
X    Taed Nelson`09`09`09<nelson@berlioz.nsc.com>
X    Jacob M. Parnas`09`09<jparnas@ibm.com>
X    Marc Pawliger`09`09<marc@ibmpa.awdpa.ibm.com>
X    Julian Perry`09`09<jp@hplb.hpl.hp.com>
X    Kurt Pires`09`09`09<kjpires@ic.Berkeley.EDU>
X    Terry Poot`09`09`09<tp@mccall.com>
X    Ken Raeburn`09`09`09<Raeburn@ATHENA.MIT.EDU>
X    Paul Raveling`09`09<raveling@isi.edu>
X    David Raz`09`09`09<draz@ee.technion.ac.il>
X    Jim Rees`09`09`09<rees@citi.umich.edu>
X    Steve Reinhardt`09`09<stever@cs.wisc.edu>
X    Boyd Roberts`09`09<boyd@prl.dec.com>
X    Eduardo Rodriguez`09`09<erodrigu@dcc.uchile.cl>
X    Chris P. Ross`09`09<cross@eng.umd.edu>
X    Michael Salmon`09`09<Michael.Salmon@eos.ericsson.se>
X    Greg Schroeder`09`09<greg@sharebase.com>
X    Andy Sherman`09`09<andys@ulysses.att.com>
X    Rich Simoni`09`09`09<simoni@strat.Stanford.EDU>
X    Bill Stapleton`09`09<wls@csd4.csd.uwm.edu>
X    Andreas Stolcke`09`09<stolcke@icsib6.berkeley.edu>
X    Ken Stone`09`09`09<ken@sdd.hp.com>
X    Marcin Skubiszewski`09`09<skubi@prl.dec.com>
X    Matt Thomas`09`09`09<thomas@mipsbx.nac.dec.com>
X    Michael Toy`09`09`09<mtoy%there.esd@sgi.com>
X    Craig M Votava`09`09<ihlpf!cmv>
X    Jeff Wallace`09`09<jeffw@scam.Berkeley.EDU>
X    Andrew Wason`09`09<aw@rruxi.bae.bellcore.com>
X    Bill Webb`09`09`09<ibmsupt!webb@uunet.uu.net>
X    Terry Weissman`09`09<weissman@wsl.dec.com>
X    Drew Whitehouse`09`09<drw900@csc2.anu.edu.au>
X    Bill Willis`09`09`09<willis@unity.ncsu.edu>
X    Greg Wohletz`09`09<greg@duke.cs.unlv.edu>
X    Alec Wolman`09`09`09<wolman@crl.dec.com>
X    Mike Yang`09`09`09<mikey%eukanuba.wpd@sgi.com>
$ CALL UNPACK FIXERS.;19 508456148
$ create 'f'
X# xrn - an X-based NNTP news reader
X#
X# Copyright (c) 1988, 1989, 1990, Ellen M. Sentovich and Rick L. Spickelmier
V.
X#
X# Permission to use, copy, modify, and distribute this software and its
X# documentation for any purpose and without fee is hereby granted, provided
X# that the above copyright notice appear in all copies and that both that
X# copyright notice and this permission notice appear in supporting
X# documentation, and that the name of the University of California not
X# be used in advertising or publicity pertaining to distribution of`20
X# the software without specific, written prior permission.  The University
X# of California makes no representations about the suitability of this
X# software for any purpose.  It is provided "as is" without express or
X# implied warranty.
X#
X# THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X# THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X# FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X# ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X# CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X#
X
X# Things you can define to specify how and what to build:
X# MXRN to build the Motif interface
X# DXRN to build the XUI interface
X# decnet to add DECnet support
X
X#define MXRN
X
X/*
X * If you use InterNetNews, set this define to the location of your
X * InterNetNews library.
X * Note: UNTESTED. Use at your own risk..
X */
X
X/* #define INN /com/projects/inn/libinn.a */
X
X#ifdef BandAidCompiler
X#include BandAidCompiler
X#endif
X
X#ifdef decnet
XDNETLIB=-ldnet
XDEPDNETLIB=/usr/lib/libdnet.a
XDNETDEF=-DDECNET
X#else
XDNETLIB=
XDEPDNETLIB=
XDNETDEF=
X#endif
X
X#ifdef MXRN
X#include "Motif.tmpl"
XDEFS = -DMOTIF $(DNETDEF)
XLOCAL_LIBRARIES = XmClientLibs $(DNETLIB)
XDEPLIBS = XmClientDepLibs $(DEPDNETLIB)
XPROGRAMS = mxrn
X#else
XDEFS = $(DNETDEF)
XDWTLIB=-ldwt
XDEPDWTLIB = /usr/lib/libdwt.a
XDEPLIBS = $(DEPDWTLIB) $(DEPXTOOLLIB) $(DEPXLIB) $(DEPDNETLIB)
XLOCAL_LIBRARIES = $(DWTLIB) $(XTOOLLIB) $(XLIB) $(XMULIB) $(DNETLIB)
XPROGRAMS = dxrn
X#endif
X
XXRN_DEFINES = $(DEFS)
X
X#if defined(XmacIIServer) `7C`7C defined(hp9000s300) `7C`7C defined(hp9000s8
V00) `7C`7C defined(SGIArchitecture)
XXRN_LOAD_FLAGS = -lPW
X#endif
X
X#if defined(aiws)
XXRN_DEFINES = -a -Nn3000 -Nd4000 $(DEFS)
X#endif
X
X#if defined(HCRevision)
XXRN_DEFINES = -DUNIXCPP -DNOSTDHDRS $(DEFS)
X#endif
X
X#if defined(gould)
XXRN_DEFINES = -DNOVOID -DLONGINT -UINTSPRINTF $(DEFS)
X#endif
X
X#if defined(OSF)
XCC=/bin/cc
XCOMP_HOST_ROOT=/bin
XXRN_DEFINES = $(DEFS) -Olimit 2000
X#endif
X
X#if defined(INN)
XEXTRA_LOAD_FLAGS = $(XRN_LOAD_FLAGS) INN
XDEFINES = $(XRN_DEFINES) -DINN
XCLIENTSRC =`20
XCLIENTOBJ =
X#else
XEXTRA_LOAD_FLAGS = $(XRN_LOAD_FLAGS)
XDEFINES = $(XRN_DEFINES)
XCLIENTSRC = clientlib.c
XCLIENTOBJ = clientlib.o
X#endif
X
X#ifdef MXRN
X           SRCS = avl.c buttons.c $(CLIENTSRC) compose.c cursor.c dialogs.c
V \
X`09`09  menus.c refile.c mesg.c error_hnds.c newsrcfile.c `09\
X`09`09  resources.c slist.c internals.c save.c server.c utils.c \
X`09`09  xmisc.c xrn.c xthelper.c killfile.c y.tab.c`20
X   `09   OBJS = avl.o buttons.o $(CLIENTOBJ) compose.o cursor.o dialogs.o \
X`09`09  menus.o refile.o mesg.o error_hnds.o newsrcfile.o `09\
X`09`09  resources.o slist.o internals.o save.o server.o utils.o \
X`09`09  xmisc.o xrn.o xthelper.o killfile.o y.tab.o`20
X#else
X           SRCS = avl.c buttons.c $(CLIENTSRC) compose.c cursor.c dialogs.c
V \
X`09`09  menus.c refile.c mesg.c error_hnds.c newsrcfile.c `09\
X`09`09  resources.c slist.c internals.c save.c server.c utils.c \
X`09`09  pane.c xmisc.c xrn.c xthelper.c killfile.c y.tab.c`20
X           OBJS = avl.o buttons.o $(CLIENTOBJ) compose.o cursor.o dialogs.o
V \
X`09`09  menus.o refile.o mesg.o error_hnds.o newsrcfile.o `09\
X`09`09  resources.o slist.o internals.o save.o server.o utils.o \
X`09`09  pane.o xmisc.o xrn.o xthelper.o killfile.o y.tab.o`20
X#endif
X
X#ifdef MXRN
XAllTarget(mxrn)
X#else
XAllTarget(dxrn)
X#endif
X
Xdepend:: y.tab.c lex.yy.c
X
X#ifdef MXRN
XComplexProgramTarget(mxrn)
X#else
XComplexProgramTarget(dxrn)
X#endif
X
Xlex.yy.c: newsrc.l
X`09lex newsrc.l
X
Xy.tab.c: newsrc.y
X`09yacc newsrc.y
X
Xy.tab.o: lex.yy.c avl.h news.h newsrcfile.h utils.h
X
Xclean::
X`09$(RM) y.tab.c lex.yy.c
X
$ CALL UNPACK IMAKEFILE.;18 1516117475
$ create 'f'
X
X#if !defined(lint) && !defined(SABER)
Xstatic char XRNrcsid`5B`5D = "$Header: /net/objy27/wrld/mnt11/ricks/src/mast
Ver/xrn/internals.c,v 1.9 1993/02/04 18:22:19 ricks Exp $";
X#endif
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * internals.c: routines for handling the internal data structures
X *    calls server routines, is calls by the user interface code
X *
X */
X
X#include "copyright.h"
X#ifdef VMS
X#include <jpidef.h>
X#include <ssdef.h>
X#ifdef MOTIF
X#include <X11/Xos.h>
X#else
X#include <decw$include/Xos.h>
X#endif
X#endif
X#include <stdio.h>
X#include <errno.h>
X#include "config.h"
X#include "utils.h"
X#include <assert.h>
X#ifndef VMS
X#include <sys/param.h>
X#include <sys/file.h>
X#include <sys/stat.h>
X#else
X#define index strchr
X#include <file.h>
X#include <ctype.h>
X#endif /* VMS */
X#ifdef __STDC__
X#include <time.h>
X#ifndef VMS
X#include <unistd.h>
X#else
X#include <unixlib.h>
Xextern int sys$getjpiw();
Xextern int unlink();
X#endif
X#include <stdlib.h>
X#endif /* __STDC__ */
X#include "avl.h"
X#include "news.h"
X#include "newsrcfile.h"
X#include "resources.h"
X#include "server.h"
X#include "mesg.h"
X#include "error_hnds.h"
X#include "save.h"
X#include "internals.h"
X#include "xrn.h"
X
X#ifdef SYSV_REGEX
X    extern char *regcmp();
X    extern char *regex();
X#else
X    extern char *re_comp();
X#endif
X
X#if !defined(hpux) && !defined(linux) && !defined(VMS) && defined(__STDC__)
Xextern int gethostname _ARGUMENTS((char *, int));
X#endif
X
X#define BUFFER_SIZE 1024
X#define FATAL 0
X#define OKAY  1
X#define MAX_GROUP_SIZE 100
X
Xextern void stop_server();
Xextern Boolean watchingGroup();
Xstruct article *currentArticles = NULL;`09/* List of article data pointers *
V/
Xstruct article *savedArt = NULL;
Xint artCount = 0;`09`09/* Count of entries available */
Xstatic char subjectline`5BBUFFER_SIZE`5D;
X
X#define SETARTICLES(newsgroup) if (currentArticles == 0) (void) getarticles(
Vnewsgroup)
X#define SETSTATUS(newsgroup) if (newsgroup->artStatus == 0) (void) getartsta
Vtus(newsgroup)
Xstatic char *strip();
X
X/*
X * length of lines in the top text window
X */
X#define LINE_LENGTH 512
X
X/*
X * next article to get when faulting in articles that are of the top
X * of the subject screen.
X */
Xstatic art_num NextPreviousArticle;
X `20
X/* storage for all newsgroups, key is the name of the group */
Xavl_tree *NewsGroupTable = NIL(avl_tree);
X
X/* storage for newsgroup message ids */
Xstatic avl_tree *msgids = NIL(avl_tree);
X
X/* number of groups in the active file */
Xint ActiveGroupsCount = 0;
X
X/* number of the group currently being processed */
Xstruct newsgroup * CurrentGroup = 0;
X
X/* number of groups in the .newsrc file */
Xng_num MaxGroupNumber = 0;
X
X/* index number of last article read */
Xstatic int PrevArtIndx`5B5`5D = `7B-1,-1,-1,-1,-1`7D;
X
X/* Storage for shared string pool */
Xavl_tree *StringPool = NIL(avl_tree);
X
X/* sprintf format string for article subjects */
Xstatic char formatString`5BLINE_LENGTH`5D;
X
X/*
X * see if another xrn is running
X */
Xvoid
XcheckLock()
X`7B
X    char *buffer = utTildeExpand(app_resources.lockFile);
X#ifdef VMS
X    char *ptr;
X    struct _itemList `7B
X`09short item_size;
X`09short item_code;
X`09void *item_ptr;
X`09int   item_rtn_size;
X`09int   end_list;
X    `7D itemList;
X#endif /* VMS */
X    char host`5B64`5D;
X    char myhost`5B64`5D;
X    int pid;
X    FILE *fp;
X
X    if (!buffer) `7B
X`09/* silently ignore this condition */
X`09return;
X    `7D
X
X#ifndef VMS
X    if (gethostname(myhost, sizeof(myhost)) == -1) `7B
X`09(void) strcpy(myhost, "bogusHost");
X    `7D
X#else
X    ptr = getenv("SYS$NODE");
X    if (ptr != NIL(char)) `7B
X`09(void) strcpy(myhost, ptr);
X`09ptr = index(myhost, ':');
X`09if (ptr != NIL(char)) `7B
X`09    *ptr = '\0';
X`09`7D
X    `7D
X
X    if (*myhost == '\0') `7B
X`09(void) strcpy(myhost, "bogusHost");
X    `7D
X#endif /* VMS */
X
X    if ((fp = fopen(buffer, "r")) == NULL) `7B
X`09if ((fp = fopen(buffer, "w")) == NULL) `7B
X`09    /* silently ignore this condition */
X`09    return;
X`09`7D
X`09(void) fprintf(fp, "%s %d\n", myhost, getpid());
X`09(void) fclose(fp);
X`09return;
X    `7D
X
X    (void) fscanf(fp, "%s %d", host, &pid);
X
X#ifndef VMS
X    /* see if I'm on the same host */
X    if (strcmp(host, myhost) == 0) `7B
X`09if ((kill(pid, 0) == -1) && (errno == ESRCH)) `7B
X`09    /* hey, it's not running.... */
X`09    /* why do it right when you can just do this... */
X`09    removeLock();
X`09    checkLock();
X`09    return;
X`09`7D
X    `7D
X#else
X    /* see if I'm on the same host */
X    if (strcmp(host, myhost) == 0) `7B
X`09int status, pidTmp;
X`09/* whoa!  I am, see if the process is mine */
X`09if (pid == getpid()) `7B
X`09    /* It's mine.. so delete it */
X`09    /* why do it right when you can just do this... */
X`09    (void) fclose(fp);
X`09    removeLock();
X`09    checkLock();
X`09    return;
X`09`7D
X`09/* whoa!  I am, see if the process is running */
X`09itemList.item_size = 4;
X`09itemList.item_code = JPI$_PID;
X`09itemList.item_ptr = &pidTmp;
X`09itemList.item_rtn_size = 0;
X`09itemList.end_list = 0;
X
X`09pidTmp = 0;
X`09status = sys$getjpiw(0, &pid, 0, &itemList, 0, 0, 0);
X`09if (status == SS$_NONEXPR) `7B
X`09    /* hey, it's not running.... */
X`09    /* why do it right when you can just do this... */
X`09    removeLock();
X`09    checkLock();
X`09    return;
X`09`7D
X    `7D
X#endif
X
X    (void) fprintf(stderr, "An XRN of yours is running on %s as process %d.\
Vn",
X`09`09   host, pid);
X    (void) fprintf(stderr, "If it is no longer running, remove %s\n",
X`09`09   buffer);
X    exit(-1);
X
X    return;
X`7D
X
X
Xvoid
XremoveLock()
X`7B
X    char *buffer = utTildeExpand(app_resources.lockFile);
X
X    if (buffer) `7B
X`09(void) unlink(buffer);
X    `7D
X    return;
X`7D
X
Xint groupCompare(str1, str2)
X#if defined(__STDC__) && __STDC__
Xconst char *str1;
Xconst char *str2;
X#else
Xchar *str1;
Xchar *str2;
X#endif
X`7B
X    if (str1 == NULL) return 1;
X    if (str2 == NULL) return -1;
X    return(strncmp(str1, str2, MAX_GROUP_SIZE));
X`7D
X
X/*
X * initialize the program and the news system
X *   read newsrc, etc
X *
X *   returns: void
X *
X */
Xvoid
XinitializeNews()
X`7B
X    start_server(app_resources.nntpServer);
X
X    do `7B
X`09 NewsGroupTable = avl_init_table(groupCompare);
X`09 if (! NewsGroupTable) `7B
X`09     ehErrorExitXRN("out of memory");
X`09 `7D
X   `20
X`09 getactive();
X`09`20
X`09 if (readnewsrc(app_resources.newsrcFile,
X`09`09`09app_resources.saveNewsrcFile))
X`09      break;
X`09`20
X`09 ehErrorRetryXRN("Can not read the .newsrc file", True);
X
X`09 avl_free_table(NewsGroupTable, XtFree, XtFree);
X    `7D while (1);
X`09
X#if !defined(FIXED_C_NEWS_ACTIVE_FILE) && !defined(FIXED_ACTIVE_FILE)
X    fixLowArticleNumbers();
X#endif
X    return;
X`7D
X
X/*
X * get the active file again and grow the Newsrc array if necessary
X */
Xvoid
XrescanServer()
X`7B
X    int old = ActiveGroupsCount;
X
X    /* update the newsrc file */
X    while (!updatenewsrc())
X`09ehErrorRetryXRN("Can not update the newsrc file", True);
X
X#if !defined(NNTP_REREADS_ACTIVE_FILE)
X    stop_server();
X    start_server(NIL(char));
X#endif
X   `20
X    getactive();
X
X    if (ActiveGroupsCount > old) `7B
X`09/* new newsgroups were found, allocate a bigger array */
X`09Newsrc = (struct newsgroup **) XtRealloc((char *) Newsrc,
X`09`09(unsigned) (sizeof(struct newsgroup *) * ActiveGroupsCount));
X    `7D
X
X#if !defined(FIXED_C_NEWS_ACTIVE_FILE) && !defined(FIXED_ACTIVE_FILE)
X    fixLowArticleNumbers();
X#endif
X    return;
X`7D
X
X#define lsDestroy(lst) \
X    if (lst != NIL(struct list)) `7B \
X`09struct list *_next; \
X`09do `7B \
X`09    _next = lst->next; \
X`09    FREE(lst); \
X`09    lst = _next; \
X`09`7D while (lst != NIL(struct list)); \
X    `7D
X
X/*
X * accurately count the number of unread articles in a group
X *
X *   returns: the number of unread articles in the group
X */
Xint
XunreadArticleCount(newsgroup)
Xstruct newsgroup *newsgroup;
X`7B
X    art_num i;
X    struct artStat *artstat = GETSTATUS(newsgroup);
X    int count = 0;
X    register struct artStat *ap;
X    register art_num`09last`09= newsgroup->last;
X    register art_num`09artn;
X
X
X    if (EMPTY_GROUP(newsgroup)) `7B
X`09return 0;
X    `7D
X   `20
X    if ((newsgroup->first == 0) && (newsgroup->last == 0)) `7B
X`09return 0;
X    `7D
X   `20
X    ap = &artstat`5BINDEX(newsgroup->first)`5D;
X
X    for (artn = newsgroup->first; artn <= last; artn++) `7B
X`09if (IS_UNREAD(*ap) && !IS_UNAVAIL(*ap)) `7B
X`09    count++;
X`09`7D
X`09ap++;
X    `7D
X    return count;
X`7D
X
X/*
X * accurately count the number of articles in a group
X *
X *   returns: the total number of articles in the group
X */
Xint
XtotalArticleCount(newsgroup)
Xstruct newsgroup *newsgroup;
X`7B
X    art_num i;
X    struct artStat *artstat = GETSTATUS(newsgroup);
X    int count = 0;
X    struct artStat *ap;
X    art_num last = newsgroup->last;
X `20
X    if (EMPTY_GROUP(newsgroup)) `7B
X`09return 0;
X    `7D
X   `20
X    if ((newsgroup->first == 0) && (newsgroup->last == 0)) `7B
X`09return 0;
X    `7D
X   `20
X    ap = &artstat`5BINDEX(newsgroup->first)`5D;
X
X    for (i = newsgroup->first; i <= last; i++) `7B
X`09if (!IS_UNAVAIL(*ap)) `7B
X`09    count++;
X`09`7D
X`09ap++;
X    `7D
X    return count;
X`7D
X
X/*
X * find the first (possibly unread) article in a group and set 'current' to
V it
X *
X * returns: void
X *
X */
Xstatic void
XsetCurrentArticle(newsgroup, mode)
Xstruct newsgroup *newsgroup;
Xint mode;
X`7B
X    struct artStat *artstat = GETSTATUS(newsgroup);
X    art_num i;
X    int start;
X
X    newsgroup->current = newsgroup->last + 1;
X   `20
X    /* if the resource 'onlyShow' is > 0, then mark all but the last
X     * 'onlyShow' articles as read */
X
X    start = newsgroup->first;
X    if (app_resources.onlyShow > 0) `7B
X`09start = MAX(start, newsgroup->last - app_resources.onlyShow);
X    `7D
X   `20
X    if (mode == UNREAD) `7B
X`09for (i = newsgroup->first; i<= newsgroup->last; i++) `7B
X`09    long indx = INDEX(i);
X`09    if (IS_UNREAD(artstat`5Bindx`5D) && !IS_UNAVAIL(artstat`5Bindx`5D)) `
V7B
X`09`09newsgroup->initial = newsgroup->current = i;
X`09`09return;
X`09    `7D
X`09`7D`20
X    `7D`20
X    if (mode == UNKILLED) `7B
X`09if (newsgroup->initial == 0)
X`09    newsgroup->initial = newsgroup->first;
X`09for (i = newsgroup->initial; i<= newsgroup->last; i++) `7B
X`09    long indx = INDEX(i);
X`09    if (IS_UNKILLED(artstat`5Bindx`5D) && IS_ACTIVE(artstat`5Bindx`5D) &&
X`09`09!IS_UNAVAIL(artstat`5Bindx`5D)) `7B
X`09`09newsgroup->current = i;
X`09`09return;
X`09    `7D
X`09`7D`20
X    `7D
X
X    if (mode == ACTIVE) `7B
X`09if (newsgroup->initial == 0)
X`09    newsgroup->initial = newsgroup->first;
X`09for (i = newsgroup->initial; i<= newsgroup->last; i++) `7B
X`09    long indx = INDEX(i);
X`09    if (IS_ACTIVE(artstat`5Bindx`5D) && !IS_UNAVAIL(artstat`5Bindx`5D)) `
V7B
X`09`09newsgroup->current = i;
X`09`09return;
X`09    `7D
X`09`7D`20
X    `7D
X
X    if (mode == ALL) `7B
X`09newsgroup->initial = newsgroup->first;
X`09for (i = newsgroup->initial; i<= newsgroup->last; i++) `7B
X`09    long indx = INDEX(i);
X`09    if (!IS_UNAVAIL(artstat`5Bindx`5D)) `7B
X`09`09newsgroup->initial = newsgroup->current = i;
X`09`09return;
X`09    `7D
X`09`7D`20
X    `7D
X
X    return;
X`7D
X
Xint
XunreadNews()
X`7B
X    int i, count = 0;
X    struct newsgroup *newsgroup;
X
X    for (i = 0; i < MaxGroupNumber; i++) `7B
X`09newsgroup = Newsrc`5Bi`5D;
X#ifdef WATCH
X`09if (IS_SUBSCRIBED(newsgroup) && watchingGroup(newsgroup->name)) `7B
X#else
X`09if (IS_SUBSCRIBED(newsgroup)) `7B
X#endif
X`09    count += unreadArticleCount(newsgroup);
X`09`7D
X    `7D
X    return count;
X`7D
X
X/*
X * build and return an array of information about groups that need to be rea
Vd
X */
Xng_num *
XunreadGroups(mode, flag)
Xint mode;
XBoolean *flag;
X`7B
X    struct newsgroup *newsgroup;
X    ng_num i;
X    int unread;
X    int subscribedGroups = 0;
X    ng_num *ar;
X
X    ar = ARRAYALLOC(ng_num, MaxGroupNumber+1);
X
X    *flag = False;
X
X    for (i = 0; i < MaxGroupNumber; i++) `7B
X`09newsgroup = Newsrc`5Bi`5D;
X
X`09if (IS_SUBSCRIBED(newsgroup) &&
X`09   (((unread = unreadArticleCount(newsgroup)) > 0) `7C`7C mode)) `7B
X`09    ar`5BsubscribedGroups++`5D = i;
X`09    if (unread > 0) *flag = True;
X`09`7D
X    `7D
X
X    ar`5BsubscribedGroups++`5D = -1;
X    return ar;
X`7D
X
X/*
X * build and return a string describing the status of a group
X */
Xchar *
XgroupStatus(which)
Xint which;
X`7B
X    static char dummy`5BLINE_LENGTH`5D;
X    struct newsgroup *newsgroup;
X    int unread, total;
X
X    dummy`5B0`5D = '\0';
X
X    if (which < 0 `7C`7C which > MaxGroupNumber)
X`09return dummy;
X
X    newsgroup = Newsrc`5Bwhich`5D;
X    total = totalArticleCount(newsgroup);
X    unread = unreadArticleCount(newsgroup);
X
X    (void) sprintf(dummy, "%6s %7s %-40s%5d article%s +%5d old",
X`09`09`09(unread > 0 ? "Unread" : ""),
X`09`09`09(total > 0 ? "news in" : ""),
X`09`09`09newsgroup->name, unread,
X`09`09`09((unread != 1) ? "s" : " "),
X`09`09`09total-unread);
X    return dummy;
X`7D
X/*
X * return the name of a newsgroup
X */
Xchar *
XgroupName(which)
Xint which;
X`7B
X    struct newsgroup *newsgroup;
X    static char *dummy = ".";
X
X    if (which < 0 `7C`7C which > MaxGroupNumber)
X`09return dummy;
X
X    newsgroup = Newsrc`5Bwhich`5D;
X    return newsgroup->name;
X`7D
X/*
X * determine the newsgroups that are not in the .newsrc file
X *
X *   returns an array containing the newsgroup structures
X */
Xstruct newsgroup **
XnewGroups()
X`7B
X    int count = 0;
X    int i;
X    avl_generator *gen;
X    char *key, *value;
X    struct newsgroup **ar;
X    struct newsgroup *newsgroup;
X
X    ar = ARRAYALLOC(struct newsgroup *, ActiveGroupsCount + 1);
X
X    gen = avl_init_gen(NewsGroupTable, AVL_FORWARD);
X    if (! gen) `7B
X`09ehErrorExitXRN("out of memory");
X    `7D
X
X    while (avl_gen(gen, &key, &value)) `7B
X`09newsgroup = (struct newsgroup *) value;
X`09if (IS_NOENTRY(newsgroup) && IS_NOTALIAS(newsgroup)) `7B
X`09    ar`5Bcount++`5D = newsgroup;
X`09`7D
X    `7D
X
X    avl_free_gen(gen);
X
X    /* no new groups return */
X    if (count == 0) `7B
X`09FREE(ar);`09
X`09return NULL;
X    `7D
X
X    if (app_resources.unsubNewGroups) `7B
X`09for (i = 0; i < count; i++) `7B
X`09    newsgroup = ar`5Bi`5D;
X`09    addToNewsrcEnd(newsgroup->name, UNSUBSCRIBE);
X`09`7D
X`09FREE(ar);`09
X`09return NULL;
X    `7D
X
X    ar`5Bcount`5D = NULL;
X    return ar;
X`7D
X
X/*
X *   release some resources
X *
X *   returns: void
X */
Xvoid
XreleaseNewsgroupResources()
X`7B
X    int i;
X
X    if (StringPool != NULL) `7B
X`09avl_free_table(StringPool, XtFree, NULL);
X    `7D
X    StringPool = avl_init_table(strcmp);
X
X    for (i = 0; i < 5; i++)`20
X`09PrevArtIndx`5Bi`5D = -1;
X    /*
X     * CurrentGroup can be invalid when called from the
X     * signal catcher
X     */
X    if (CurrentGroup != NIL(struct newsgroup) ) `7B
X`09struct newsgroup *newsgroup = CurrentGroup;
X`09struct article *articles = currentArticles;
X`09struct artStat *artstat = newsgroup->artStatus;
X`09art_num art;
X
X`09newsgroup->initial = 0;
X`09if ((newsgroup->last == 0) `7C`7C EMPTY_GROUP(newsgroup)) `7B
X`09    return;
X`09`7D
X
X`09for (art = newsgroup->first; art <= newsgroup->last; art++) `7B
X`09    long indx = INDEX(art);
X`09   `20
X`09    if (articles) `7B
X`09`09CLEAR_SUBJECT(articles`5Bindx`5D);
X`09`09CLEAR_AUTHOR(articles`5Bindx`5D);
X`09`09CLEAR_LINES(articles`5Bindx`5D);
X`09`09CLEAR_TEXT(articles`5Bindx`5D);
X`09`09CLEAR_MSGID(articles`5Bindx`5D);
X`09`09CLEAR_REFS(articles`5Bindx`5D);
X`09    `7D
X`09    if (artstat) `7B
X`09`09SET_UNFETCHED(artstat`5Bindx`5D);
X`09`09SET_UNMARKED(artstat`5Bindx`5D);
X`09    `7D
X`09`7D
X`09/* free the articles array every time */
X`09CLEAR_ARTICLES(newsgroup);
X    `7D
X
X    if (app_resources.updateNewsrc == TRUE) `7B
X`09if (!updatenewsrc()) `7B
X`09    ehErrorExitXRN("Can not update the newsrc file");
X`09`7D
X    `7D
X    CurrentGroup = NULL;
X    currentArticles = NULL;
X
X    return;
X`7D
X
Xvoid clearArtCache()
X`7B
X    int i;
X    for (i = 0; i < 5; i++)
X`09PrevArtIndx`5Bi`5D = -1;
X    return;
X`7D
X
X/*
X * update an article array if the first and/or last article numbers change
X *
X *  returns: void
X */
Xvoid
XarticleArrayResync(newsgroup, first, last, number)
Xstruct newsgroup *newsgroup;
Xart_num first, last;
Xint number;
X`7B
X    struct article *articles = currentArticles;
X    struct article *newarticles;
X    struct artStat *artstatus = newsgroup->artStatus;
X    struct artStat *newartstatus;
X    int i;
X    int newsize;
X
X    /*
X     * if there are actually no articles in the group, free up the
X     * article array and set the first/last values
X     */
X      `20
X    if (number == 0) `7B
X`09CLEAR_ARTICLES(newsgroup);
X`09CLEAR_ARTSTATUS(newsgroup);
X`09newsgroup->first = newsgroup->last + 1;
X`09return;
X    `7D
X   `20
X    /* refuse to resync if last == 0 */
X    if (last == 0) `7B
X`09return;
X    `7D
X
X    if (first > last) `7B
X`09/* all articles have been removed */
X`09CLEAR_ARTICLES(newsgroup);
X`09CLEAR_ARTSTATUS(newsgroup);
X`09newsgroup->first = newsgroup->last + 1;
X`09return;
X    `7D
X
X    /* don't allow last to go backwards!!! */
X    if (last < newsgroup->last) `7B
X`09last = newsgroup->last;
X    `7D
X
X    /* don't allow first to go backwards!!! */
X    if (first < newsgroup->first) `7B
X`09first = newsgroup->first;
X    `7D
X`09
X    if ((first != newsgroup->first) `7C`7C (last != newsgroup->last)) `7B
X
X`09/* only do this if the articles array has been allocated */
X`09if ((newsgroup == CurrentGroup) && currentArticles) `7B
X
X`09    /* the first/last values have changed, resync */
X
X`09    articles = currentArticles;
X
X`09    newsize = (last - first) + 10;
X`09    if (newsize > artCount) `7B
X`09`09newsize = MAX(newsize, 1000);
X`09`09savedArt = newarticles = ARRAYALLOC(struct article, newsize);
X`09`09artCount = newsize;
X`09    `7D else `7B
X`09`09newarticles = savedArt;
X`09    `7D
X
X`09    /*
X`09     * initialize the new article structures
X`09     */
X`09
X`09    for (i = first; i <= last; i++) `7B
X`09`09newarticles`5Bi - first`5D.subject = NIL(char);
X`09`09newarticles`5Bi - first`5D.author = NIL(char);
X`09`09newarticles`5Bi - first`5D.text = NIL(char);
X`09`09newarticles`5Bi - first`5D.lines = NIL(char);
X`09`09newarticles`5Bi - first`5D.msgid = NIL(char);
X`09`09newarticles`5Bi - first`5D.refs`5B0`5D = NIL(char);
X`09`09newarticles`5Bi - first`5D.refs`5B1`5D = NIL(char);
X`09`09newarticles`5Bi - first`5D.refs`5B2`5D = NIL(char);
X`09`09newarticles`5Bi - first`5D.parent = 0;
X`09`09newarticles`5Bi - first`5D.child = 0;
X`09    `7D
X
X`09    if ((!EMPTY_GROUP(newsgroup)) &&
X`09`09(newsgroup->first != 0) && (newsgroup->last != 0) &&
X`09`09(articles != NIL(struct article))) `7B
X`09`09for (i = first; i <= last; i++) `7B
X`09`09    if ((i >= newsgroup->first) && (i <= newsgroup->last)) `7B
X`09`09`09newarticles`5Bi - first`5D = articles`5BINDEX(i)`5D;
X`09`09    `7D
X`09`09`7D
X
X`09`09/* free up the old resources - before the new first */
X#ifdef notdef
X`09`09for (i = newsgroup->first; i < first; i++) `7B
X`09`09    long indx = INDEX(i);
X`09`09    CLEAR_SUBJECT(articles`5Bindx`5D);
X`09`09    CLEAR_AUTHOR(articles`5Bindx`5D);
X`09`09    CLEAR_LINES(articles`5Bindx`5D);
X`09`09    CLEAR_MSGID(articles`5Bindx`5D);
X`09`09    CLEAR_REFS(articles`5Bindx`5D);
X`09`09    CLEAR_TEXT(articles`5Bindx`5D);
X`09`09`7D
X#endif
X`09`09/* after the old last to the new last */
X`09`09for (i = newsgroup->last + 1; i <= last; i++) `7B
X`09`09    newarticles`5Bi - first`5D.subject = NIL(char);
X`09`09    newarticles`5Bi - first`5D.author = NIL(char);
X`09`09    newarticles`5Bi - first`5D.text = NIL(char);
X`09`09    newarticles`5Bi - first`5D.lines = NIL(char);
X`09`09    newarticles`5Bi - first`5D.msgid = NIL(char);
X`09`09    newarticles`5Bi - first`5D.refs`5B0`5D = NIL(char);
X`09`09    newarticles`5Bi - first`5D.refs`5B1`5D = NIL(char);
X`09`09    newarticles`5Bi - first`5D.refs`5B2`5D = NIL(char);
X`09`09    newarticles`5Bi - first`5D.parent = 0;
X`09`09    newarticles`5Bi - first`5D.child = 0;
X`09`09`7D
X`09    `7D
X
X`09    if (articles != NIL(struct article) &&
X`09`09articles != savedArt) `7B
X`09`09FREE(articles);
X`09    `7D
X`09    currentArticles = newarticles;
X`09`7D
X
X`09if (newsgroup->artStatus) `7B
X
X`09    /* the first/last values have changed, resync */
X
X`09    artstatus = newsgroup->artStatus;
X`09    newartstatus = ARRAYALLOC(struct artStat, (last - first) + 10);
X
X`09    /*
X`09     * initialize the new article status
X`09     */
X`09
X`09    for (i = first; i <= last; i++) `7B
X`09`09if (i < newsgroup->first) `7B
X`09`09    /* handle first decreasing... mark them as read */
X`09`09    newartstatus`5Bi - first`5D.status = ART_CLEAR_READ;
X`09`09`7D else `7B
X`09`09    newartstatus`5Bi - first`5D.status = ART_CLEAR;
X`09`09`7D
X`09    `7D
X
X`09    if ((!EMPTY_GROUP(newsgroup)) &&
X`09`09(newsgroup->first != 0) && (newsgroup->last != 0) &&
X`09`09(newsgroup->artStatus != NIL(struct artStat))) `7B
X`09`09for (i = first; i <= last; i++) `7B
X`09`09    if ((i >= newsgroup->first) && (i <= newsgroup->last)) `7B
X`09`09`09newartstatus`5Bi - first`5D = artstatus`5BINDEX(i)`5D;
X`09`09    `7D
X`09`09`7D
X`09    `7D
X`09    if (artstatus != NIL(struct artStat)) `7B
X`09`09FREE(artstatus);
X`09    `7D
X`09    newsgroup->artStatus = newartstatus;
X`09`7D
X`09newsgroup->first = first;
X`09newsgroup->last = last;
X    `7D
X    return;
X`7D
X
X
Xchar *
XlocalKillFile(newsgroup, mode)
Xstruct newsgroup *newsgroup;
Xint mode;
X`7B
X    static char buffer`5BBUFFER_SIZE`5D;
X    char *ptr;
X    int i;
X
X    if (!createNewsDir()) `7B
X`09return NIL(char);
X    `7D
X
X    (void) strcpy(buffer, app_resources.expandedSaveDir);
X    i = strlen(buffer);
X
X#ifndef VMS
X    buffer`5Bi++`5D = '/';
X
X    for (ptr = newsgroup->name; *ptr != 0; ptr++) `7B
X`09if (*ptr == '.') `7B
X`09    if (mode) `7B
X`09`09buffer`5Bi`5D = '\0';
X`09`09(void) mkdir(buffer, 0777);
X`09    `7D
X`09    buffer`5Bi`5D = '/';
X`09    i++;
X`09`7D else `7B
X`09    buffer`5Bi++`5D = *ptr;
X`09`7D
X    `7D
X    buffer`5Bi`5D = '\0';
X    if (mode) `7B
X`09(void) mkdir(buffer, 0777);
X    `7D
X    (void) strcpy(&buffer`5Bi`5D, "/KILL");
X#else
X    i = i + utGroupToVmsFilename(&buffer`5Bi`5D, newsgroup->name);
X    (void) strcpy(&buffer`5Bi`5D, ".KILL");
X#endif
X
X    return buffer;
X`7D
X
X
Xchar *
XglobalKillFile()
X`7B
X    static char buffer`5BBUFFER_SIZE`5D;
X
X    if (!createNewsDir()) `7B
X`09return NIL(char);
X    `7D
X    (void) strcpy(buffer, app_resources.expandedSaveDir);
X#ifndef VMS
X    (void) strcat(buffer, "/KILL");
X#else
X    (void) strcat(buffer, "NEWS$GLOBAL.KILL");
X#endif
X    return buffer;
X`7D
X
X/*
X * mark a thread as killed
X */
Xvoid
XkillThread(artNum)
Xart_num artNum;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    struct article *articles = GETARTICLES(newsgroup);
X    long indx = INDEX(artNum);
X
X    if (articles`5Bindx`5D.child) `7B
X`09artNum = articles`5Bindx`5D.child;
X`09while (artNum) `7B
X`09    if (!articleMarkedUnread(artNum))
X`09`09markArticleAsKilled(artNum);
X`09    indx = INDEX(artNum);
X`09    artNum = articles`5Bindx`5D.child;
X`09`7D
X    `7D
X`7D
X
X/*
X * add a kill subject/author entry to a kill file
X */
Xvoid
XkillItem(item, type)
Xchar *item;
Xint type;
X`7B
X    char input`5BBUFFER_SIZE`5D, *iptr;
X    char output`5BBUFFER_SIZE`5D, *optr;
X    FILE *fp;
X    struct newsgroup *newsgroup = CurrentGroup;
X    char *file;
X
X    if (type == KILL_LOCAL) `7B
X`09file = localKillFile(newsgroup, 1);
X    `7D else `7B
X`09file = globalKillFile();
X    `7D
X
X    if (file == NULL `7C`7C ((fp = fopen(file, "a")) == NULL)) `7B
X`09mesgPane(XRN_SERIOUS, "Can not open the %s kill file for %s",`20
X`09`09       (type == KILL_LOCAL) ? "local" : "global",
X`09`09       newsgroup->name);
X`09return;
X    `7D
X    /* get rid of all magic characters */
X    (void) strncpy(input, item, sizeof(input));
X    iptr = input;
X    optr = output;
X    while (*iptr) `7B
X`09if ((*iptr == '/')  `7C`7C
X`09    (*iptr == '\\') `7C`7C
X`09    (*iptr == '(')  `7C`7C
X`09    (*iptr == '`5B')  `7C`7C
X`09    (*iptr == '+')  `7C`7C
X`09    (*iptr == '-')  `7C`7C
X`09    (*iptr == ':')  `7C`7C
X`09    (*iptr == '.')  `7C`7C
X`09    (*iptr == '`5E')  `7C`7C
X`09    (*iptr == '*')  `7C`7C
X`09    (*iptr == '$')  `7C`7C
X`09    (*iptr == '\'') `7C`7C
X`09    (*iptr == '\"')) `7B
X`09    *iptr = '.';
X`09`7D
X`09*optr++ = *iptr++;
X    `7D
X    *optr = '\0';
X
X    fprintf(fp, "/%.24s/:j\n", output);
X    (void) fclose(fp);
X    return;
X`7D
X
X
X/*
X * kill all subjects in the newsgroup that match the kill
X * orders in fp.
X */
X
Xstatic void
XkillArticles(newsgroup, fp)
Xstruct newsgroup *newsgroup;
XFILE *fp;
X`7B
X    char string`5BBUFFER_SIZE`5D, pattern`5BBUFFER_SIZE`5D, commands`5BBUFFE
VR_SIZE`5D;
X    char dummy`5BBUFFER_SIZE`5D;
X    art_num i, start = newsgroup->current;
X    char *subject, *author, *subj, *ptr, *pptr;
X    int scount = 0, kcount = 0, ucount = 0, mcount = 0;
X    int append;
X    char *reRet;
X    char type;
X
X    mesgDisableRedisplay();
X
X    info("processing KILL file");
X
X    /* XXX don't reprocess global each time, keep in persistent hash table *
V/
X
X    string`5B0`5D = '\0';
X    while (fgets(string, sizeof(string), fp) != NULL) `7B
X`09append = 0;
X
X`09/*
X`09 * see if there is a 'THRU artnum' line, if so,
X`09 * only compare subjects from that article on
X`09 * XXX need to update THRU
X`09 */
X`09if (STREQN(string, "THRU", 4)) `7B
X`09    i = atol(&string`5B5`5D);
X`09    /* if THRU is less than current, ignore it */
X`09    if (i + 1 > newsgroup->current) `7B
X`09`09start = i + 1;
X`09    `7D else `7B
X`09`09start = newsgroup->current;
X`09    `7D
X`09    continue;
X`09`7D
X
X`09if (*string == '&') `7B
X`09    /* 'rn' switch setting, ignore */
X`09    continue;
X`09`7D
X
X
X`09/*
X`09 * process kill file request should be in the form
X`09 */
X`09ptr = string + 1;
X`09pptr = pattern;
X
X`09while (*ptr && (*ptr != '/' `7C`7C ((*ptr == '/') && *(ptr - 1) == '\\'))
V) `7B
X`09   *pptr++ = *ptr;
X`09   ptr++;
X`09`7D
X`09*pptr = '\0';
X
X`09if (!*ptr) `7B
X`09    /* empty line - ignore it. */
X`09    continue;
X`09`7D
X
X`09/* rn puts ': *' in front of patterns, xrn doesn't */
X`09if (strncmp(pattern, ": *", 3) == 0) `7B
X`09    /* deal with overlapping strings */
X`09    (void) strcpy(dummy, pattern + 3);
X`09    (void) strcpy(pattern, dummy);
X`09`7D
X
X`09/* XXX kludge to deal with :.*checks */
X`09if (*pattern == ':') `7B
X`09    /* deal with overlapping strings */
X`09    (void) strcpy(dummy, pattern + 1);
X`09    (void) strcpy(pattern, dummy);
X`09`7D
X
X#ifdef SYSV_REGEX
X`09if ((reRet = regcmp(pattern, NULL)) == NULL) `7B
X`09    mesgPane(XRN_SERIOUS, "Bad KILL file pattern: %s", string);
X#else
X`09if ((reRet = re_comp(pattern)) != NIL(char)) `7B
X`09    mesgPane(XRN_SERIOUS, "Bad KILL file pattern: %s\n%s", string, reRet)
V;
X#endif
X`09    continue;
X`09`7D
X
X`09ptr++;`09/* skip past the slash */
X`09(void) strcpy(commands, ptr);
X`09if ((ptr = index(commands, ':')) == NIL(char)) `7B
X`09    mesgPane(XRN_SERIOUS, "Malformed KILL file entry (command): %s (%s)",
X`09`09     string, commands);
X`09    continue;
X`09`7D
X`09ptr++;`09/* skip past the colon */
X`09type = *ptr;
X
X`09switch (type) `7B
X`09    case 'j':
X`09    case 'm':
X`09    case 's':
X`09        break;
X`09    default:
X`09        mesgPane(XRN_INFO,
X`09`09`09 "unknown KILL file option: %s", string);
X`09        break;
X`09`7D
X
X`09for (i = start; i <= newsgroup->last; i++) `7B
X
X`09    /* short cut */
X`09    if (IS_UNAVAIL(newsgroup->artStatus`5BINDEX(i)`5D) `7C`7C
X`09`09((type == 'j') && IS_READ(newsgroup->artStatus`5BINDEX(i)`5D)) `7C`7C
X`09`09((type == 'm') && IS_UNREAD(newsgroup->artStatus`5BINDEX(i)`5D))) `7B
X`09`09continue;
X`09    `7D
X
X`09    if (currentArticles`5BINDEX(i)`5D.subject `7C`7C
X`09        currentArticles`5BINDEX(i)`5D.author) `7B
X
X`09`09subject = currentArticles`5BINDEX(i)`5D.subject;
X`09`09author = currentArticles`5BINDEX(i)`5D.author;
X
X`09`09if (subject) `7B
X`09`09    subj = strip(subject, FALSE);
X`09`09`7D
X
X#ifdef SYSV_REGEX
X`09`09if ((subject && (regex(reRet, subj) != NULL)) `7C`7C
X`09`09    (author  && (regex(reRet, author) != NULL))) `7B
X#else
X`09`09if ((subject && re_exec(subj)) `7C`7C
X`09`09    (author  && re_exec(author))) `7B
X#endif
X`09`09    switch (type) `7B
X`09`09`09case 'j':
X`09`09`09    SET_READ(newsgroup->artStatus`5BINDEX(i)`5D);
X`09`09`09    mesgPane(XRN_INFO `7C append, "killed - %s",
X`09`09`09`09     subject);
X`09`09`09    append = XRN_APPEND;
X`09`09`09    kcount++;
X`09`09`09    break;
X
X`09`09`09case 'm':
X`09`09`09    SET_UNREAD(newsgroup->artStatus`5BINDEX(i)`5D);
X`09`09`09    mesgPane(XRN_INFO `7C append, "marked unread - %s",
X`09`09`09`09     subject);
X`09`09`09    append = XRN_APPEND;
X`09`09`09    mcount++;
X`09`09`09    break;
X
X`09`09`09case 's':
X`09`09`09    (void) saveArticle(NIL(char), newsgroup, i);
X`09`09`09    mesgPane(XRN_INFO `7C append, "saved - %s",
X`09`09`09`09     subject);
X`09`09`09    append = XRN_APPEND;
X`09`09`09    scount++;
X`09`09`09    break;
X
X`09`09`09default:
X`09`09`09    ucount++;
X`09`09`09    break;
X`09`09    `7D
X`09`09`7D
X`09    `7D
X`09`7D
X    `7D
X
X    append = 0;
X
X#define printcount(c,m) \
X    if( c != 0 ) \
X    `7B`09\
X`09mesgPane(XRN_INFO `7C append, m, c, \
X`09`09 ((c==1) ? "" : "s"), \
X`09`09 newsgroup->name); \
X`09append = XRN_APPEND; \
X    `7D
X
X    if (app_resources.verboseKill == True) `7B
X`09printcount(kcount, "killed %d article%s in %s");
X`09printcount(mcount, "marked %d article%s unread in %s");
X`09printcount(scount, "saved %d article%s in %s");
X`09printcount(ucount, "matched %d article%s with unknown option in %s");
X    `7D
X
X#undef printcount
X
X    mesgEnableRedisplay();
X
X    return;
X`7D
X
X/*
X * mark articles as read if in the kill files
X */
Xstatic void
XcheckKillFiles(newsgroup)
Xstruct newsgroup *newsgroup;
X`7B
X    FILE *fp;
X    char *file;
X   `20
X    file = globalKillFile();
X    if (file && ((fp = fopen(file, "r")) != NULL)) `7B
X`09killArticles(newsgroup, fp);
X`09(void) fclose(fp);
X    `7D
X
X    file = localKillFile(newsgroup, 0);
X    if (file && ((fp = fopen(file, "r")) != NULL)) `7B
X`09killArticles(newsgroup, fp);
X`09(void) fclose(fp);
X    `7D
X
X    return;
X`7D
X
X/*
X * Find the sort order for this newsgroup and set it up
X */
X
Xstatic void
XsetSortOrder(name)
Xchar *name;
X`7B
X    char rname`5B200`5D;
X    char *type;
X    XrmValue value;
X    XrmValue converted;
X
X#ifdef MOTIF
X    sprintf(rname, "mxrn.%s.sortedSubjects", name);
X#else
X    sprintf(rname, "dxrn.%s.sortedSubjects", name);
X#endif
X    if (XrmGetResource(XtDatabase(XtDisplay(TopLevel)),
X`09`09`09rname, "SortedSubjects", &type, &value)) `7B
X`09converted.addr = NULL;
X`09converted.size = 0;
X`09XtConvert(TopLevel, type, &value, "SortedSubjects", &converted);
X`09if (converted.addr) `7B
X`09    app_resources.sortedSubjects = (int) *((int *)(converted.addr));
X`09`7D else `7B
X`09    app_resources.sortedSubjects = app_resources.defSortedSubjects;
X`09`7D
X    `7D else `7B
X`09app_resources.sortedSubjects = app_resources.defSortedSubjects;
X    `7D
X`7D   `20
X
Xstatic void
XsetUpGroup(newsgroup, killfilesp)
Xstruct newsgroup *newsgroup;
Xint killfilesp;`09`09/* check kill files? no for jumpToNewsgroup */
X`7B
X    art_num first, last;
X    int number;
X   `20
X    /* get the latest group information */
X    if (getgroup(newsgroup, &first, &last, &number)) `7B
X`09return;
X    `7D
X    if (!EMPTY_GROUP(newsgroup)) `7B
X        CurrentGroup = newsgroup;
X`09articleArrayResync(newsgroup, first, last, number);
X`09currentArticles = GETARTICLES(newsgroup);
X`09newsgroup->artStatus = GETSTATUS(newsgroup);
X`09newsgroup->initial = 0;
X`09setCurrentArticle(newsgroup, UNREAD);
X`09NextPreviousArticle = newsgroup->current;
X`09if (!getoverview(newsgroup, newsgroup->current,
X`09`09`09 newsgroup->last, False)) `7B
X`09    getsubjectlist(newsgroup, newsgroup->current,
X`09`09`09newsgroup->last, False);
X`09    getauthorlist(newsgroup, newsgroup->current,
X`09`09`09newsgroup->last, False);
X`09    getlineslist(newsgroup, newsgroup->current,
X`09`09`09newsgroup->last, False);
X`09    getmsgidlist(newsgroup, newsgroup->current,
X`09`09`09newsgroup->last, False);
X`09    getrefslist(newsgroup, newsgroup->current,
X`09`09`09newsgroup->last, False);
X`09`7D
X`09if (killfilesp && (app_resources.killFiles == TRUE)) `7B
X`09    checkKillFiles(newsgroup);
X`09`7D
X    `7D
X    setSortOrder(newsgroup->name);
X    return;
X`7D
X
X/*
X * goto a particular newsgroup
X */
Xint
XgotoNewsgroup(name)
Xchar *name;
X`7B
X    char *ptr;
X    struct newsgroup *newsgroup;
X
X    if (!avl_lookup(NewsGroupTable, name, &ptr)) `7B
X`09mesgPane(XRN_SERIOUS, "Newsgroup `60%s' does not exist", name);
X`09return BAD_GROUP;
X    `7D
X
X    newsgroup = (struct newsgroup *) ptr;
X    CurrentGroup = newsgroup;
X    setSortOrder(newsgroup->name);
X    return GOOD_GROUP;
X`7D
X   `20
X/*
X * goto a particular newsgroup
X *   if all of the articles have been read, unmark the last one
X */
Xint
XgotoNewsgroupForRead(name)
Xchar *name;
X`7B
X    char *ptr;
X    struct newsgroup *newsgroup;
X    art_num i;
X
X    if (!avl_lookup(NewsGroupTable, name, &ptr)) `7B
X`09mesgPane(XRN_SERIOUS, "Newsgroup `60%s' does not exist", name);
X`09return BAD_GROUP;
X    `7D
X
X    newsgroup = (struct newsgroup *) ptr;
X    CurrentGroup = newsgroup;
X   `20
X    if (EMPTY_GROUP(newsgroup)) `7B
X`09mesgPane(XRN_SERIOUS,
X`09    "Cannot go to the newsgroup, no articles available");
X`09CurrentGroup = NULL;
X`09return BAD_GROUP;
X    `7D
X    /*
X     * if there are no unread articles, find the last available one
X     * and mark it as unread
X     *
X     * XXX bug if the last article becomes unavailable
X     */
X    if (unreadArticleCount(newsgroup) == 0) `7B
X`09if (newsgroup->artStatus == NIL(struct artStat)) `7B
X`09    mesgPane(XRN_SERIOUS,
X`09`09"Cannot go to the newsgroup, no articles available");
X`09    CurrentGroup = NULL;
X`09    return BAD_GROUP;
X`09`7D`09   `20
X`09assert(newsgroup->artStatus != NIL(struct artStat));
X`09for (i = newsgroup->last; i >= newsgroup->first; i--) `7B
X`09    if (!IS_UNAVAIL(newsgroup->artStatus`5BINDEX(i)`5D)) `7B
X`09`09SET_UNREAD(newsgroup->artStatus`5BINDEX(i)`5D);
X`09`09return GOOD_GROUP_MARKED;
X`09    `7D
X`09`7D
X    `7D
X    return GOOD_GROUP;
X`7D
X
X/*
X * set the current state to indicate that we're in a particular newsgroup
X */
Xint
XsetNewsgroup(name)
Xchar *name;
X`7B
X    char *ptr;
X    struct newsgroup *newsgroup;
X
X    if (!avl_lookup(NewsGroupTable, name, &ptr)) `7B
X`09mesgPane(XRN_SERIOUS, "Newsgroup `60%s' does not exist", name);
X`09return BAD_GROUP;
X    `7D
X
X    newsgroup = (struct newsgroup *) ptr;
X    CurrentGroup = newsgroup;
X    setSortOrder(newsgroup->name);
X    return GOOD_GROUP;
X`7D
X
Xstatic struct newsgroup *
XfindNewsGroupMatch(name)
Xchar *name;
X`7B
X    static char *reRet;
X    int i;
X
X    /* no single character queries, to comfusing */
X    if (strlen(name) == 1) `7B
X`09return NIL(struct newsgroup);
X    `7D
X
X#ifdef SYSV_REGEX
X    if ((reRet = regcmp(name, NULL)) == NULL) `7B
X`09return NIL(struct newsgroup);
X    `7D
X#else
X    if ((reRet = re_comp(name)) != NULL) `7B
X`09return NIL(struct newsgroup);
X    `7D
X#endif
X
X
X    for (i = 0; i < MaxGroupNumber; i++) `7B
X`09struct newsgroup *newsgroup = Newsrc`5Bi`5D;
X#ifdef SYSV_REGEX
X`09if (regex(reRet, newsgroup->name) != NULL) `7B
X`09    return newsgroup;
X`09`7D
X#else
X`09if (re_exec(newsgroup->name)) `7B
X`09    return newsgroup;
X`09`7D
X#endif
X`09   `20
X    `7D
X
X    return NIL(struct newsgroup);
X`7D
X
X/*
X * goto a particular newsgroup
X *   if all of the articles have been read, unmark the last one
X */
Xint
XjumpToNewsgroup(name)
Xchar *name;
X`7B
X    char *ptr;
X    struct newsgroup *newsgroup;
X    art_num i;
X   `20
X    if (!avl_lookup(NewsGroupTable, name, &ptr)) `7B
X`09/* is not the full name, try regexp matching */
X`09if ((newsgroup = findNewsGroupMatch(name)) == NIL(struct newsgroup)) `7B
X`09    mesgPane(XRN_SERIOUS, "Newsgroup `60%s' does not exist", name);
X`09    return BAD_GROUP;
X`09`7D
X    `7D else `7B
X`09newsgroup = (struct newsgroup *) ptr;
X    `7D
X
X    CurrentGroup = newsgroup;
X
X    if (EMPTY_GROUP(newsgroup)) `7B
X`09mesgPane(XRN_SERIOUS, "Cannot go to the newsgroup, no articles available"
V);
X`09return BAD_GROUP;
X    `7D
X
X    SETARTICLES(newsgroup);
X
X    if (!IS_SUBSCRIBED(newsgroup)) `7B
X`09updateArticleArray(newsgroup, True);
X    `7D
X
X    /*
X     * if there are no unread articles, find the last available one
X     * and mark it as unread
X     *
X     * XXX bug if the last article becomes unavailable
X     */
X    if (unreadArticleCount(newsgroup) == 0) `7B
X`09if (newsgroup->artStatus == NIL(struct artStat)) `7B
X`09    mesgPane(XRN_SERIOUS, "Cannot go to the newsgroup, no articles availa
Vble");
X`09    return BAD_GROUP;
X`09`7D
X`09assert(newsgroup->artStatus != NIL(struct artStat));
X`09for (i = newsgroup->last; i >= newsgroup->first; i--) `7B
X`09    if (!IS_UNAVAIL(newsgroup->artStatus`5BINDEX(i)`5D)) `7B
X`09`09SET_UNREAD(newsgroup->artStatus`5BINDEX(i)`5D);
X`09`09break;
X`09    `7D
X`09`7D
X    `7D
X    setUpGroup(newsgroup, 0);
X    return GOOD_GROUP;
X`7D
X   `20
X/*
X * get the newsgroup
X *
X * returns:  XRN_NOMORE - bad group
X *           XRN_OKAY   - okay
X */
Xint
XgetNewsgroup()
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X
X    if (IS_SUBSCRIBED(newsgroup) && (unreadArticleCount(newsgroup) > 0)) `7B
X`09setUpGroup(newsgroup, 1);
X`09return XRN_OKAY;
X    `7D
X   `20
X    return XRN_NOMORE;
X`7D
X
X/*
X * mark all articles in a newsgroup as read
X *
X *   other functions will take care of releasing resources
X *
X *   returns: void
X *
X */
Xvoid
XcatchUp()
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    art_num art;
X
X    SETSTATUS(newsgroup);
X    if (!newsgroup->artStatus)
X`09return;
X    for (art = newsgroup->first; art <= newsgroup->last; art++) `7B
X`09if (IS_UNMARKED(newsgroup->artStatus`5BINDEX(art)`5D)) `7B
X`09    SET_READ(newsgroup->artStatus`5BINDEX(art)`5D);
X`09`7D else `7B
X`09    SET_UNREAD(newsgroup->artStatus`5BINDEX(art)`5D);
X`09    SET_UNMARKED(newsgroup->artStatus`5BINDEX(art)`5D);
X`09`7D
X    `7D
X`7D
X
X
Xint
Xissubscribed()
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X
X    if (IS_SUBSCRIBED(newsgroup)) `7B
X`09return 1;
X    `7D else `7B
X`09return 0;
X    `7D
X`7D
X
X/*
X * subscribe to a newsgroup
X *
X *   returns: void
X *
X */
Xvoid
Xsubscribe()
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X   `20
X    if (!IS_SUBSCRIBED(newsgroup)) `7B
X`09SET_SUB(newsgroup);
X`09updateArticleArray(newsgroup, True);
X    `7D
X    return;
X`7D
X
X/*
X * unsubscribe to a newsgroup
X *
X *   returns: void
X *
X */
Xvoid
Xunsubscribe()
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X   `20
X    SET_UNSUB(newsgroup);
X    return;
X`7D
X
X/*
X * build a string that is used as the question for what
X * to do at the end of an article
X *
X *   returns: the question in a static area
X *
X */
Xstatic char *
XbuildQuestion(newsgroup)
Xstruct newsgroup *newsgroup;
X`7B
X    static char dummy`5BLABEL_SIZE`5D;
X    art_num i;
X    struct artStat *artstat = GETSTATUS(newsgroup);
X    long unread = 0;
X    ng_num number;
X    struct newsgroup *nextnewsgroup;
X    int found;
X   `20
X    for (i = newsgroup->first; i <= newsgroup->last; i++) `7B
X`09long indx = INDEX(i);
X`09if (IS_UNREAD(artstat`5Bindx`5D) && !IS_UNAVAIL(artstat`5Bindx`5D)) `7B
X`09    unread++;
X`09`7D
X    `7D
X`09   `20
X    found = 0;
X    for (number = CurrentGroup->newsrc + 1; number < MaxGroupNumber;
X`09 number++) `7B
X`09nextnewsgroup = Newsrc`5Bnumber`5D;
X`09/* find a group that is subscribed to and has unread articles */
X`09if (IS_SUBSCRIBED(nextnewsgroup) && (unreadArticleCount(nextnewsgroup) >
V 0)) `7B
X`09    found = 1;
X`09    break;
X`09`7D
X    `7D
X`09   `20
X    if (found) `7B
X`09if (unread <= 0) `7B
X`09    (void) sprintf(dummy, "Article %ld in %s\nNext group: %s, with %d art
Vicles",
X`09`09`09   newsgroup->current, newsgroup->name,
X`09`09`09   nextnewsgroup->name, unreadArticleCount(nextnewsgroup));
X`09`7D else `7B
X`09    (void) sprintf(dummy, "Article %ld in %s (%ld remaining)\nNext group:
V %s, with %d articles",
X`09`09`09   newsgroup->current, newsgroup->name, unread,
X`09`09`09   nextnewsgroup->name, unreadArticleCount(nextnewsgroup));
X`09`7D
X    `7D else `7B
X`09if (unread <= 0) `7B
X`09    (void) sprintf(dummy, "Article %ld in %s",
X`09`09`09   newsgroup->current, newsgroup->name);
X`09`7D else `7B
X`09    (void) sprintf(dummy, "Article %ld in %s (%ld remaining)",
X`09`09`09   newsgroup->current, newsgroup->name, unread);
X`09`7D
X    `7D
X    return dummy;
X`7D
X
Xchar *currentQuestion()
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    return buildQuestion(newsgroup);
X`7D
X
X/*
X * build a string that is used as the question for what
X * to do at the end of an article
X *
X *   returns: the question in a static area
X *
X */
Xchar *
XopenQuestion()
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    static char dummy`5BLABEL_SIZE`5D;
X    art_num i;
X    struct artStat *artstat = GETSTATUS(newsgroup);
X    long unread = 0;
X    ng_num number;
X    struct newsgroup *nextnewsgroup;
X    int found;
X
X    for (i = newsgroup->first; i <= newsgroup->last; i++) `7B
X`09long indx = INDEX(i);
X`09if (IS_UNREAD(artstat`5Bindx`5D) && !IS_UNAVAIL(artstat`5Bindx`5D)) `7B
X`09    unread++;
X`09`7D
X    `7D
X`09   `20
X    found = 0;
X    for (number = CurrentGroup->newsrc + 1; number < MaxGroupNumber;
X`09 number++) `7B
X`09nextnewsgroup = Newsrc`5Bnumber`5D;
X`09/* find a group that is subscribed to and has unread articles */
X`09if (IS_SUBSCRIBED(nextnewsgroup) && (unreadArticleCount(nextnewsgroup) >
V 0)) `7B
X`09    found = 1;
X`09    break;
X`09`7D
X    `7D
X`09   `20
X    if (found) `7B
X`09if (unread <= 0) `7B
X`09    (void) sprintf(dummy, "Group %s\nNext group: %s, with %d articles",
X`09`09`09   newsgroup->name,
X`09`09`09   nextnewsgroup->name, unreadArticleCount(nextnewsgroup));
X`09`7D else `7B
X`09    (void) sprintf(dummy, "Group %s (%ld remaining)\nNext group: %s, with
V %d articles",
X`09`09`09   newsgroup->name, unread,
X`09`09`09   nextnewsgroup->name, unreadArticleCount(nextnewsgroup));
X`09`7D
X    `7D else `7B
X`09if (unread <= 0) `7B
X`09    (void) sprintf(dummy, "Group %s", newsgroup->name);
X`09`7D else `7B
X`09    (void) sprintf(dummy, "Group %s (%ld remaining)",
X`09`09`09   newsgroup->name, unread);
X`09`7D
X    `7D
X    return dummy;
X`7D
X
Xstatic void
XhandleXref(article)
Xart_num article;
X`7B
X    char *string, *ptr, *token, group`5BGROUP_NAME_SIZE`5D, *gptr;
X    int count, number;
X    struct newsgroup *newsgroup;
X
X   `20
X    xhdr(article, "xref", &string);
X
X    if (string == NIL(char)) `7B
X`09/* no xrefs */
X`09return;
X    `7D
X
X    /*
X     * an xrefs line is of the form:
X     *
X     *   host group:number group:number .... group:number
X     */
X
X    if ((ptr = index(string, ' ')) == NIL(char)) `7B
X`09FREE(string);
X`09return;
X    `7D
X
X    while ((token = strtok(ptr, " ")) != NIL(char)) `7B
X`09ptr = NIL(char);
X`09
X`09count = sscanf(token, "%`5B`5E: `5D:%d", group, &number);
X`09if (count != 2) `7B
X`09    /* bogus entry */
X`09    continue;
X`09`7D
X
X`09if (!avl_lookup(NewsGroupTable, group, &gptr)) `7B
X`09    /* bogus group */
X`09    continue;
X`09`7D
X
X`09/* only Xref groups that are subscribed to */
X`09
X`09newsgroup = (struct newsgroup *) gptr;
X
X`09if (IS_SUBSCRIBED(newsgroup) &&
X`09    (number >= newsgroup->first) && (number <= newsgroup->last)) `7B
X`09    SETSTATUS(newsgroup);`09/* defer until we have to do this */
X
X`09    SET_READ(newsgroup->artStatus`5BINDEX(number)`5D);
X`09`7D
X    `7D
X    FREE(string);
X    return;
X`7D
X
X/*
X * get the next article
X *
X * returns: XRN_ERROR - article has been canceled
X *          XRN_OKAY  - article returned
X */
Xint
XgetArticleText(text, question)
Xchar **text;
Xchar **question;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    struct article *articles = GETARTICLES(newsgroup);
X    struct artStat *artstat = GETSTATUS(newsgroup);
X    long indx = CURRENT;
X    int header, rotation;
X#ifdef XLATE
X    int`09xlation;
X#endif /* XLATE */
X    int i;
X    static int artIndex = -1;
X
X/*
X *  Point to next cell in the index array, wrapping around.
X */
X    if (artIndex < 4) `7B
X`09artIndex++;
X    `7D else `7B
X`09artIndex = 0;
X    `7D
X/*
X *  Is this article one of the last five read? If so, re-use the
X *  stored article array
X */
X    for (i = 0; i < 5; i++) `7B
X`09if (PrevArtIndx`5Bi`5D == indx) `7B
X`09    artIndex = i;
X`09    break;
X`09`7D
X    `7D
X/*
X *  If No match found, we free the article text for the current
X *  cell in the storage array. Else, it's left in the cache.
X */
X    if ((PrevArtIndx`5BartIndex`5D != -1) && (PrevArtIndx`5BartIndex`5D != i
Vndx)) `7B
X`09if (PrevArtIndx`5BartIndex`5D < 0 `7C`7C
X`09    PrevArtIndx`5BartIndex`5D > newsgroup->last - newsgroup->first) `7B
X`09`09PrevArtIndx`5BartIndex`5D = -1;
X`09`7D else `7B
X`09    CLEAR_TEXT(articles`5BPrevArtIndx`5BartIndex`5D`5D);
X`09    SET_UNFETCHED(artstat`5BPrevArtIndx`5BartIndex`5D`5D);
X`09    PrevArtIndx`5BartIndex`5D = -1;
X`09`7D
X    `7D
X
X    if (IS_UNFETCHED(artstat`5Bindx`5D)) `7B
X`09
X`09/* get the article and handle unavailable ones.... */
X`09header = (IS_ALL_HEADERS(artstat`5Bindx`5D) ? FULL_HEADER : NORMAL_HEADER
V);
X`09rotation = (IS_ROTATED(artstat`5Bindx`5D) ? ROTATED : NOT_ROTATED);
X#ifdef XLATE
X`09xlation = (IS_XLATED(artstat`5Bindx`5D) ? XLATED : NOT_XLATED);
X`09if ((articles`5Bindx`5D.text = getarticle(newsgroup->current,`20
X`09`09`09`09         &articles`5Bindx`5D.position,
X`09`09`09`09`09 header, rotation,xlation)) == NIL(char)) `7B
X#else /* XLATE */
X`09if ((articles`5Bindx`5D.text = getarticle(newsgroup->current,`20
X`09`09`09`09         &articles`5Bindx`5D.position,
X`09`09`09`09`09 header, rotation)) == NIL(char)) `7B
X#endif /* XLATE */
X`09    SET_UNAVAIL(artstat`5Bindx`5D);
X`09    mesgPane(XRN_SERIOUS, "Can not get the next article, it was canceled
V by the author or a file system filled");
X`09    return XRN_ERROR;
X`09`7D
X`09SET_FETCHED(artstat`5Bindx`5D);
X    `7D else `7B
X`09if (articles`5Bindx`5D.text == NIL(char)) `7B
X`09    /* refetch the text */
X`09    SET_UNFETCHED(artstat`5Bindx`5D);
X`09    return getArticleText(text, question);
X`09`7D`09   `20
X    `7D
X
X    *text = articles`5Bindx`5D.text;
X    SET_READ(artstat`5Bindx`5D);
X    *question = buildQuestion(newsgroup);
X    handleXref(newsgroup->current);
X/*
X *  Save the index of this article in the
X *  cache array
X */
X    PrevArtIndx`5BartIndex`5D = indx;
X    return XRN_OKAY;
X`7D
X
X
Xint
XtoggleHeaders(text, question)
Xchar **text;
Xchar **question;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    struct article *articles = GETARTICLES(newsgroup);
X    struct artStat *artstat = GETSTATUS(newsgroup);
X    long indx = CURRENT;
X    int i;
X/*
X *  Find the article in the storage array and "forget" it.
X */
X    for (i = 0; i < 5; i++) `7B
X`09if (PrevArtIndx`5Bi`5D == indx) `7B
X`09    CLEAR_TEXT(articles`5BCURRENT`5D);
X`09    SET_UNFETCHED(artstat`5BCURRENT`5D);
X`09    PrevArtIndx`5Bi`5D = -1;
X`09    break;
X`09`7D
X    `7D
X
X    if (IS_ALL_HEADERS(artstat`5BCURRENT`5D)) `7B
X`09SET_STRIPPED_HEADERS(artstat`5BCURRENT`5D);
X    `7D else `7B
X`09SET_ALL_HEADERS(artstat`5BCURRENT`5D);
X    `7D`09
X    CLEAR_TEXT(articles`5BCURRENT`5D);
X    SET_UNFETCHED(artstat`5BCURRENT`5D);
X    return getArticleText(text, question);
X`7D
X
X
Xint
XtoggleRotation(text, question)
Xchar **text;
Xchar **question;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    struct article *articles = GETARTICLES(newsgroup);
X    struct artStat *artstat = GETSTATUS(newsgroup);
X
X    if (IS_ROTATED(artstat`5BCURRENT`5D)) `7B
X`09SET_UNROTATED(artstat`5BCURRENT`5D);
X    `7D else `7B
X`09SET_ROTATED(artstat`5BCURRENT`5D);
X    `7D`09
X    CLEAR_TEXT(articles`5BCURRENT`5D);
X    SET_UNFETCHED(artstat`5BCURRENT`5D);
X    return getArticleText(text, question);
X`7D
X
X#ifdef XLATE
Xint
XtoggleXlation(text, question)
Xchar **text;
Xchar **question;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    struct article *articles = GETARTICLES(newsgroup);
X    struct artStat *artstat = GETSTATUS(newsgroup);
X
X    if (IS_XLATED(artstat`5BCURRENT`5D)) `7B
X`09SET_UNXLATED(artstat`5BCURRENT`5D);
X    `7D else `7B
X`09SET_XLATED(artstat`5BCURRENT`5D);
X    `7D`09
X    CLEAR_TEXT(articles`5BCURRENT`5D);
X    SET_UNFETCHED(artstat`5BCURRENT`5D);
X    return getArticleText(text, question);
X`7D
X#endif /* XLATE */
X
X/*
X * mark the articles in a group that have been read
X *
X *   returns: void
X *
X */
X#if defined(STDC) && !defined(_NO_PROTO)
Xvoid
XupdateArticleArray(struct newsgroup *newsgroup, int force)
X#else
Xvoid
XupdateArticleArray(newsgroup, force)
Xstruct newsgroup *newsgroup;    /* newsgroup to update article array for   *
V/
Xint force;`09`09`09/* True to force update */
X#endif
X`7B
X    struct list *item;
X    art_num art;
X    extern void XtFree();
X#ifndef FIXED_C_NEWS_ACTIVE_FILE
X    art_num first, last;
X    int number;
X#endif
X
X    if (newsgroup->last == 0) `7B
X`09return;
X    `7D
X
X    if (EMPTY_GROUP(newsgroup)) `7B
X`09currentArticles = NIL(struct article);
X`09newsgroup->artStatus = NIL(struct artStat);
X`09return;
X    `7D
X
X    if (newsgroup->nglist == NIL(struct list)) `7B
X`09return;
X    `7D
X
X    if (!IS_SUBSCRIBED(newsgroup) && !force) `7B
X`09currentArticles = NIL(struct article);
X`09newsgroup->artStatus = NIL(struct artStat);
X`09return;
X    `7D
X
X#ifndef FIXED_C_NEWS_ACTIVE_FILE
X    /* get the group range to fix c-news low number problem */
X    if ((XRNState & XRN_NEWS_UP) == XRN_NEWS_UP) `7B
X`09(void) getgroup(newsgroup, &first, &last, &number);
X`09articleArrayResync(newsgroup, first, last, number);
X`09if ((newsgroup->first == 0 && newsgroup->last == 0) `7C`7C number == 0) `
V7B
X`09    lsDestroy(newsgroup->nglist);
X`09    newsgroup->nglist = NIL(struct list);
X`09    return;
X`09`7D
X    `7D
X#endif
X
X    SETSTATUS(newsgroup);
X
X    /* process the .newsrc line */
X
X    for (item = newsgroup->nglist; item != NIL(struct list); item = item->ne
Vxt) `7B
X`09switch (item->type) `7B
X`09    case SINGLE:
X`09    if (item->contents.single > newsgroup->last) `7B
X`09`09/* something really bad has happened, reset */
X`09`09mesgPane(XRN_SERIOUS, "Article numbering problem, marking all articles
V in %s as unread",
X`09`09`09       newsgroup->name);
X`09`09for (art = newsgroup->first; art <= newsgroup->last; art++) `7B
X`09`09    if (newsgroup->artStatus != NIL(struct artStat))
X`09`09`09newsgroup->artStatus`5BINDEX(art)`5D.status = ART_CLEAR;
X`09`09`7D
X`09`09lsDestroy(newsgroup->nglist);
X`09`09newsgroup->nglist = NIL(struct list);
X`09`09return;
X`09    `7D
X`09    if (item->contents.single >= newsgroup->first) `7B
X`09`09newsgroup->artStatus`5BINDEX(item->contents.single)`5D.status = ART_CL
VEAR_READ;
X`09    `7D
X`09    break;
X
X`09    case RANGE:
X`09    if ((item->contents.range.start > newsgroup->last) `7C`7C
X`09`09(item->contents.range.end > newsgroup->last)) `7B
X`09`09/* something really bad has happened, reset */
X`09`09if (newsgroup->first != 0 && newsgroup->last !=0)
X`09`09    mesgPane(XRN_SERIOUS,
X`09"Article numbering problem, marking all articles in %s as unread\n",
X`09`09`09       newsgroup->name);
X`09`09for (art = newsgroup->first; art <= newsgroup->last; art++) `7B
X`09`09    if (newsgroup->artStatus != NIL(struct artStat))
X`09`09`09newsgroup->artStatus`5BINDEX(art)`5D.status = ART_CLEAR;
X`09`09`7D
X`09`09lsDestroy(newsgroup->nglist);
X`09`09newsgroup->nglist = NIL(struct list);
X`09`09return;
X`09    `7D
X`09    if (item->contents.range.start < newsgroup->first) `7B
X`09`09item->contents.range.start = newsgroup->first;
X`09    `7D
X`09   `20
X`09    if (item->contents.range.end < newsgroup->first) `7B
X`09`09break;
X`09    `7D
X`09    for (art = item->contents.range.start; art <= item->contents.range.en
Vd; art++) `7B
X`09`09newsgroup->artStatus`5BINDEX(art)`5D.status = ART_CLEAR_READ;
X`09    `7D
X`09`7D
X    `7D
X
X    lsDestroy(newsgroup->nglist);
X    newsgroup->nglist = NIL(struct list);
X   `20
X    return;
X`7D
X
X/*
X * mark an article as read
X */
Xvoid
XmarkArticleAsRead(article)
Xart_num article;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X
X    SETSTATUS(newsgroup);
X    SET_READ(newsgroup->artStatus`5BINDEX((art_num) article)`5D);
X    SET_UNMARKED(newsgroup->artStatus`5BINDEX((art_num) article)`5D);
X    if (app_resources.xrefMarkRead) `7B
X`09handleXref(article);
X    `7D
X    return;
X`7D
X
X/*
X * mark an article as unread
X */
Xvoid
XmarkArticleAsUnread(article)
Xart_num article;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X
X    SETSTATUS(newsgroup);
X    SET_UNREAD(newsgroup->artStatus`5BINDEX((art_num) article)`5D);
X    SET_MARKED(newsgroup->artStatus`5BINDEX((art_num) article)`5D);
X    return;
X`7D
X
X/*
X * mark an article as killed
X */
Xvoid
XmarkArticleAsKilled(article)
Xart_num article;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X
X    SETSTATUS(newsgroup);
X    SET_READ(newsgroup->artStatus`5BINDEX((art_num) article)`5D);
X    SET_KILLED(newsgroup->artStatus`5BINDEX((art_num) article)`5D);
X    SET_UNMARKED(newsgroup->artStatus`5BINDEX((art_num) article)`5D);
X    return;
X`7D
X
X/*
X * mark an article as unkilled
X */
Xvoid
XmarkArticleAsUnkilled(article)
Xart_num article;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X
X    SETSTATUS(newsgroup);
X    SET_UNREAD(newsgroup->artStatus`5BINDEX((art_num) article)`5D);
X    SET_UNKILLED(newsgroup->artStatus`5BINDEX((art_num) article)`5D);
X    SET_MARKED(newsgroup->artStatus`5BINDEX((art_num) article)`5D);
X    return;
X`7D
X
X/*
X * Return TRUE if article is read
X */
XBoolean
XarticleRead(article)
Xart_num article;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X
X    SETSTATUS(newsgroup);
X    return(IS_READ(newsgroup->artStatus`5BINDEX((art_num) article)`5D)  `7C`
V7C
X    `09   IS_MARKED(newsgroup->artStatus`5BINDEX((art_num) article)`5D));
X`7D
X
X/*
X * Return TRUE if article is marked unread
X */
XBoolean
XarticleMarkedUnread(article)
Xart_num article;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    struct artStat *artstat = GETSTATUS(newsgroup);
X    long indx = INDEX((art_num) article);
X
X    return (IS_UNREAD(artstat`5Bindx`5D) && IS_MARKED(artstat`5Bindx`5D));
X`7D
X
X
X/*
X * handle adding items to the newsrc
X *
X *   3 cases
X *
X *   1. add to the beginning
X *        move 0 to MaxGroupNumber-1 down 1, update newsrc fields
X *        update 0
X *        inc MaxGroupNumber
X *   2. add to the end
X *        inc MaxGroupNumber
X *        update MaxGroupNumber-1
X *   3. add after a group (newloc is the current location of the group)
X *      move newloc+1 to end down 1, update newsrc fields
X *      update newloc
X *      in MaxGroupNumber
X *
X *   And the case of 'subscribe' (assumes it moves)
X *
X *   1. add to the beginning
X *        move 0 to oldloc-1 down 1, update newsrc fields
X *        update 0
X *   2. add to the end
X *        move oldloc+1 to MaxGroupNumber-1 update 1, update newsrc fields
X *        upadte MaxGroupNumber-1
X *   3. add after a group
X *
X */
X
Xint
XaddToNewsrcBeginning(newGroup, status)
Xchar *newGroup;
Xint status;
X`7B
X    char *ptr;
X    struct newsgroup *newsgroup;
X    ng_num i;
X   `20
X    if (!avl_lookup(NewsGroupTable, newGroup, &ptr)) `7B
X`09mesgPane(XRN_SERIOUS, "Newsgroup `60%s' does not exist", newGroup);
X`09return BAD_GROUP;
X    `7D
X   `20
X    newsgroup = (struct newsgroup *) ptr;
X
X    CLEAR_NOENTRY(newsgroup);
X    if (status == SUBSCRIBE) `7B
X`09SET_SUB(newsgroup);
X    `7D else `7B
X`09SET_UNSUB(newsgroup);
X    `7D
X    if (newsgroup->newsrc == NOT_IN_NEWSRC) `7B
X`09for (i = MaxGroupNumber - 1; i >= 0; i--) `7B
X`09    Newsrc`5Bi + 1`5D = Newsrc`5Bi`5D;
X`09    Newsrc`5Bi + 1`5D->newsrc = i + 1;
X`09`7D
X   `20
X`09MaxGroupNumber++;
X`09
X    `7D else `7B
X`09for (i = newsgroup->newsrc - 1; i >= 0; i--) `7B
X`09    Newsrc`5Bi + 1`5D = Newsrc`5Bi`5D;
X`09    Newsrc`5Bi + 1`5D->newsrc = i + 1;
X`09`7D
X    `7D
X   `20
X    newsgroup->newsrc = 0;
X    Newsrc`5B0`5D = newsgroup;
X   `20
X    return GOOD_GROUP;
X`7D
X
X
Xint
XaddToNewsrcEnd(newGroup, status)
Xchar *newGroup;
Xint status;
X`7B
X    char *ptr;
X    struct newsgroup *newsgroup;
X    ng_num i;
X   `20
X    if (!avl_lookup(NewsGroupTable, newGroup, &ptr)) `7B
X`09mesgPane(XRN_SERIOUS, "Newsgroup `60%s' does not exist", newGroup);
X`09return BAD_GROUP;
X    `7D
X   `20
X    newsgroup = (struct newsgroup *) ptr;
X
X    CLEAR_NOENTRY(newsgroup);
X    if (status == SUBSCRIBE) `7B
X`09SET_SUB(newsgroup);
X    `7D else `7B
X`09SET_UNSUB(newsgroup);
X    `7D
X    if (newsgroup->newsrc == NOT_IN_NEWSRC) `7B
X`09MaxGroupNumber++;
X    `7D else `7B
X`09for (i = newsgroup->newsrc + 1; i < MaxGroupNumber; i++) `7B
X`09    Newsrc`5Bi - 1`5D = Newsrc`5Bi`5D;
X`09    Newsrc`5Bi - 1`5D->newsrc = i - 1;
X`09`7D
X    `7D
X   `20
X    newsgroup->newsrc = MaxGroupNumber - 1;
X    Newsrc`5BMaxGroupNumber - 1`5D = newsgroup;
X   `20
X    return GOOD_GROUP;
X`7D
X
X
Xint
XaddToNewsrcAfterGroup(newGroup, afterGroup, status)
Xchar *newGroup;
Xchar *afterGroup;
Xint status;
X`7B
X    char *ptr;
X    struct newsgroup *newsgroup, *ng;
X    ng_num newloc, i;
X   `20
X    if (!avl_lookup(NewsGroupTable, newGroup, &ptr)) `7B
X`09mesgPane(XRN_SERIOUS, "Newsgroup `60%s' does not exist", newGroup);
X`09return BAD_GROUP;
X    `7D
X   `20
X    newsgroup = (struct newsgroup *) ptr;
X
X    CLEAR_NOENTRY(newsgroup);
X    if (status == SUBSCRIBE) `7B
X`09SET_SUB(newsgroup);
X    `7D else `7B
X`09SET_UNSUB(newsgroup);
X    `7D
X    if (!avl_lookup(NewsGroupTable, afterGroup, &ptr)) `7B
X`09mesgPane(XRN_SERIOUS, "Newsgroup `60%s' does not exist", afterGroup);
X`09return BAD_GROUP;
X    `7D
X   `20
X    ng = (struct newsgroup *) ptr;
X    newloc = ng->newsrc;
X
X    if (newloc == NOT_IN_NEWSRC) `7B
X`09mesgPane(XRN_SERIOUS, "Newsgroup `60%s' is not in your .newsrc file", aft
VerGroup);
X`09return BAD_GROUP;
X    `7D
X
X    if (newsgroup->newsrc == NOT_IN_NEWSRC) `7B
X`09for (i = MaxGroupNumber - 1; i >= newloc + 1; i--) `7B
X`09    Newsrc`5Bi + 1`5D = Newsrc`5Bi`5D;
X`09    Newsrc`5Bi + 1`5D->newsrc = i + 1;
X`09`7D
X
X`09MaxGroupNumber++;
X`09newsgroup->newsrc = newloc + 1;
X`09Newsrc`5Bnewloc + 1`5D = newsgroup;
X
X    `7D else `7B
X`09
X`09if (newloc + 1 < newsgroup->newsrc) `7B
X`09    for (i = newsgroup->newsrc - 1; i >= newloc + 1; i--) `7B
X`09`09Newsrc`5Bi + 1`5D = Newsrc`5Bi`5D;
X`09`09Newsrc`5Bi + 1`5D->newsrc = i + 1;
X`09    `7D
X`09    newsgroup->newsrc = newloc + 1;
X`09    Newsrc`5Bnewloc + 1`5D = newsgroup;
X`09   `20
X`09`7D else if (newsgroup->newsrc < newloc + 1) `7B
X`09    for (i = newsgroup->newsrc + 1; i < newloc + 1; i++) `7B
X`09`09Newsrc`5Bi - 1`5D = Newsrc`5Bi`5D;
X`09`09Newsrc`5Bi - 1`5D->newsrc = i - 1;
X`09    `7D
X`09    newsgroup->newsrc = newloc;
X`09    Newsrc`5Bnewloc`5D = newsgroup;
X`09`7D
X`09/* if its in the correct location already, don't touch it */
X    `7D
X   `20
X    return GOOD_GROUP;
X`7D
X
X`09
X/*
X * build and return an array that shows the subscription status
X * of all newsgroups; assumes all groups have been subscribed or
X * unsubscribed to by this time.
X *
X *   if sorted is non-zero, the list is sorted alphabetically, if
X *    zero, the list is returned as it exists in the newsrc file
X */
Xng_num *
XgetStatusList(sorted)
Xint sorted;
X`7B
X    int i, count = 0;
X    avl_generator *gen;
X    char *key, *value;
X    ng_num *ar;
X
X    ar = ARRAYALLOC(ng_num, ActiveGroupsCount + 1);
X
X    if (sorted) `7B
X`09gen = avl_init_gen(NewsGroupTable, AVL_FORWARD);
X
X`09while (avl_gen(gen, &key, &value)) `7B
X`09    struct newsgroup *newsgroup = (struct newsgroup *) value;
X`09   `20
X`09    if (IS_NOTALIAS(newsgroup)) `7B
X`09`09ar`5Bcount++`5D = newsgroup->newsrc;
X`09    `7D
X`09`7D
X`09avl_free_gen(gen);
X`09
X    `7D else `7B
X`09for (i = 0; i < MaxGroupNumber; i++) `7B
X`09    struct newsgroup *newsgroup = (struct newsgroup *) Newsrc`5Bi`5D;
X`09   `20
X`09    if (IS_NOTALIAS(newsgroup)) `7B
X`09`09ar`5Bcount++`5D = i;
X`09    `7D
X`09`7D
X    `7D`09   `20
X   `20
X    ar`5Bcount++`5D = -1;
X    return ar;
X`7D
X
X/*
X * build and return a string that shows the subscription status
X * of a newsgroup.
X */
Xchar *
XgetStatusString(which)
Xint which;
X`7B
X    struct newsgroup *newsgroup;
X    static char dummy`5BLINE_LENGTH`5D;
X
X    dummy`5B0`5D = '\0';
X    if (which < 0 `7C`7C which > MaxGroupNumber)
X`09return dummy;
X
X    newsgroup = Newsrc`5Bwhich`5D;
X`09   `20
X    if (IS_NOTALIAS(newsgroup)) `7B
X`09(void) sprintf(dummy, "%-60s%s",
X`09`09newsgroup->name,
X`09`09IS_SUBSCRIBED(newsgroup) ? "subscribed  " : "unsubscribed");
X    `7D
X    return dummy;
X`7D
X/*
X * build and return the subjects string
X */
Xart_num *
XgetUnSortedArticles(mode, count)
Xint mode;
Xint *count;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    struct article *articles = GETARTICLES(newsgroup);
X    struct artStat *artstat = GETSTATUS(newsgroup);
X    art_num i;
X    int`09    j;
X    char *start, *end;
X    art_num *ar;
X
X    *count = 0;
X    if (EMPTY_GROUP(newsgroup)) `7B
X`09return NIL(art_num);
X    `7D
X
X    if (mode == ALL) `7B
X`09newsgroup->initial = newsgroup->current = NextPreviousArticle;
X    `7D else `7B
X`09setCurrentArticle(newsgroup, mode);
X    `7D
X
X    if (newsgroup->current > newsgroup->last) `7B
X`09return NIL(art_num);
X    `7D
X
X    NextPreviousArticle = newsgroup->current;
X
X    if ((newsgroup->last - newsgroup->current + 1) < 0) `7B
X`09(void) sprintf(error_buffer, "Active File Error: last - current + 1 < 0 (
V%s)\n",
X`09`09`09       newsgroup->name);
X`09ehErrorExitXRN(error_buffer);
X    `7D
X`09
X/*
X * Allocate an array to store the article numbers.
X */
X    ar = ARRAYALLOC(art_num, (newsgroup->last - newsgroup->current + 3));
X    for (i = 0; i <= (newsgroup->last - newsgroup->current);i++) `7B
X`09ar`5Bi`5D = 0;
X    `7D
X
X    j = 0;
X    for (i = newsgroup->current; i <= newsgroup->last; i++) `7B
X`09long indx = INDEX(i);
X`09
X`09/* canceled and empty articles will not have a subject entry */
X`09if (articles`5Bindx`5D.subject != NIL(char)) `7B
X`09   `20
X`09    /* don't put articles in the string if already read ... */
X`09    if ((mode == ALL) `7C`7C
X`09        (mode == UNKILLED && IS_UNKILLED(artstat`5Bindx`5D) &&
X`09`09`09`09     IS_ACTIVE(artstat`5Bindx`5D)) `7C`7C
X`09`09(mode == ACTIVE && IS_ACTIVE(artstat`5Bindx`5D)) `7C`7C
X`09        (mode == UNREAD && IS_UNREAD(artstat`5Bindx`5D))) `7B
X`09`09if (mode != UNKILLED)
X`09`09    SET_ACTIVE(artstat`5Bindx`5D);
X`09`09ar`5Bj`5D = i;
X`09`09j++;
X`09    `7D
X`09`7D else `7B
X`09    /* if you can't get the subject, mark the article as unavailable */
X`09    SET_UNAVAIL(artstat`5Bindx`5D);
X`09`7D
X    `7D
X
X    *count = j;
X    return ar;
X`7D
X
X
Xstruct entry `7B
X    int startingArticle;
X    art_num *articleList;
X    int used;
X    int left;
X    int size;
X`7D;
X
Xstatic void
Xvalfree(ptr)
Xchar *ptr;
X`7B
X    struct entry *val = (struct entry *) ptr;
X    XtFree((char *) val->articleList);
X    XtFree((char *) val);
X    return;
X`7D
X
X
X#if defined(STDC) && !defined(_NO_PROTO)
Xstatic int
XpteCompare(const void *a, const void *b)
X#else
Xstatic int
XpteCompare(a, b)
Xvoid *a, *b;
X#endif
X`7B
X    struct entry **pa = (struct entry **) a;
X    struct entry **pb = (struct entry **) b;
X
X    return (*pa)->startingArticle - (*pb)->startingArticle;
X`7D
X
X
X/*
X * XXX AVL TREE is the wrong data structure here, hash table would be
X * better.... no need for ordering based on subject string
X */
X/*
X * build and return the subjects string
X */
Xstatic art_num *
XgetSortedArticles(mode, count)
Xint mode;
Xint *count;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    struct article *articles = GETARTICLES(newsgroup);
X    struct artStat *artstat = GETSTATUS(newsgroup);
X    struct article *art;
X    art_num i;
X    int j, k;
X    art_num *ar;
X
X    struct entry *pte;
X    struct entry **pteArray;
X
X    avl_generator *gen;
X    char *key, *ptr, *p;
X    avl_tree *tree;
X    char curSub`5B81`5D;
X    int treeSize, sz;
X    char buffer`5BLINE_LENGTH`5D;
X
X    *count = 0;
X    if (EMPTY_GROUP(newsgroup)) `7B
X`09return NIL(art_num);
X    `7D
X
X    tree = avl_init_table(utSubjectCompare);
X
X    if (mode == ALL) `7B
X`09newsgroup->initial = newsgroup->current = NextPreviousArticle;
X    `7D else `7B
X`09setCurrentArticle(newsgroup, mode);
X    `7D
X
X    if (newsgroup->current > newsgroup->last) `7B
X`09return NIL(art_num);
X    `7D
X
X    NextPreviousArticle = newsgroup->current;
X
X    if ((newsgroup->last - newsgroup->current + 1) < 0) `7B
X`09(void) sprintf(error_buffer, "Active File Error: last - current + 1 < 0 (
V%s)\n",
X`09`09`09       newsgroup->name);
X`09ehErrorExitXRN(error_buffer);
X    `7D
X`09
X    /*`20
X     * build the subject groups`20
X     */
X    for (i = newsgroup->current; i <= newsgroup->last; i++) `7B
X`09long indx = INDEX(i);
X
X`09/* canceled and empty articles will not have a subject entry */
X`09if (articles`5Bindx`5D.subject != NIL(char)) `7B
X
X`09    /* don't put articles in the string if already read ... */
X`09    if ((mode == ALL) `7C`7C
X`09        (mode == UNKILLED && IS_UNKILLED(artstat`5Bindx`5D) &&
X`09`09`09`09     IS_ACTIVE(artstat`5Bindx`5D)) `7C`7C
X`09`09(mode == ACTIVE && IS_ACTIVE(artstat`5Bindx`5D)) `7C`7C
X`09        (mode == UNREAD && IS_UNREAD(artstat`5Bindx`5D))) `7B
X`09`09if (mode != UNKILLED)
X`09`09    SET_ACTIVE(artstat`5Bindx`5D);
X`09`09(void) strncpy(curSub, getSubject(i), sizeof(curSub));
X`09`09curSub`5Bsizeof(curSub)-1`5D = '\0';
X
X`09`09if (avl_lookup(tree, curSub, &ptr)) `7B
X`09`09    /* add to the end */
X`09`09    pte = (struct entry *) ptr;
X`09`09    if (pte->left <= 0) `7B
X`09`09`09pte->left = pte->size;
X`09`09`09pte->size = pte->size * 2;
X`09`09`09pte->articleList =
X`09`09`09`09(art_num *) XtRealloc((char *)pte->articleList,
X`09`09`09`09`09     pte->size * sizeof(art_num));
X`09`09    `7D
X`09`09    pte->articleList`5Bpte->used`5D = i;
X`09`09    pte->used++;
X`09`09    pte->left--;
X`09`09`7D else `7B
X`09`09    /* create new */
X`09`09    pte = ALLOC(struct entry);
X`09`09    pte->startingArticle = i;
X`09`09    pte->articleList = ARRAYALLOC(art_num, 32);
X`09`09    pte->used = 1;
X`09`09    pte->size = 32;
X`09`09    pte->left = pte->size - pte->used;
X`09`09    pte->articleList`5B0`5D = i;
X`09`09    (void) avl_insert(tree, XtNewString(curSub), (char *) pte);
X`09`09`7D
X`09    `7D
X`09`7D else `7B
X`09    /* if you can't get the subject, mark the article as unavailable */
X`09    SET_UNAVAIL(artstat`5Bindx`5D);
X`09`7D
X    `7D
X
X    i = 0;
X    treeSize = avl_count(tree);
X    if (treeSize == 0) `7B`09`09/* No articles */
X`09avl_free_table(tree, XtFree, valfree);
X`09return NIL(art_num);
X    `7D
X
X    pteArray = ARRAYALLOC(struct entry *, treeSize);
X    gen = avl_init_gen(tree, AVL_FORWARD);
X    while (avl_gen(gen, &key, &ptr)) `7B
X`09pteArray`5Bi++`5D = (struct entry *) ptr;
X    `7D
X    avl_free_gen(gen);
X
X    /* sort by article number */
X    if (app_resources.sortedSubjects == ARTICLE_SORTED)
X`09qsort((void *) pteArray, treeSize, sizeof(struct pte *), pteCompare);
X
X/*
X * Allocate a pointer array - with an end null string followed by
X * an end pointer of NULL
X */
X
X    ar = ARRAYALLOC(art_num, (newsgroup->last - newsgroup->current + 3));
X    for (i = 0; i <= (newsgroup->last - newsgroup->current);i++) `7B
X`09ar`5Bi`5D = 0;
X    `7D
X
X    j = 0;
X    for (i = 0; i < treeSize; i++) `7B
X`09for (k = 0; k < pteArray`5Bi`5D->used; k++) `7B
X`09    ar`5Bj++`5D = pteArray`5Bi`5D->articleList`5Bk`5D;
X`09`7D
X    `7D
X
X    avl_free_table(tree, XtFree, valfree);
X    FREE(pteArray);
X    ar`5Bj`5D = 0;
X    *count = j;
X    return ar;
X`7D
X
X/*
X * Build a list of article numbers in threaded order
X */
Xstatic art_num *
XgetThreadedArticles(mode, count)
Xint mode;
Xint *count;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    struct article *articles = GETARTICLES(newsgroup);
X    struct artStat *artstat = GETSTATUS(newsgroup);
X    struct article *art, *art1;
X    art_num i, num;
X    int j, k;
X    art_num *ar;
X    int num_arts = 0;
X    struct entry *pte;
X    struct entry **pteArray;
X    avl_generator *gen;
X    char *key, *ptr, *p;
X    avl_tree *tree;
X    char curSub`5B81`5D;
X    int treeSize, sz;
X    char buffer`5BLINE_LENGTH`5D;
X
X    *count = 0;
X    if (EMPTY_GROUP(newsgroup)) `7B
X`09return NIL(art_num);
X    `7D
X
X    if (mode == ALL) `7B
X`09newsgroup->initial = newsgroup->current = NextPreviousArticle;
X    `7D else `7B
X`09setCurrentArticle(newsgroup, mode);
X    `7D
X
X    if (newsgroup->current > newsgroup->last) `7B
X`09return NIL(art_num);
X    `7D
X
X    NextPreviousArticle = newsgroup->current;
X
X    if ((newsgroup->last - newsgroup->current + 1) < 0) `7B
X`09(void) sprintf(error_buffer, "Active File Error: last - current + 1 < 0 (
V%s)\n",
X`09`09`09       newsgroup->name);
X`09ehErrorExitXRN(error_buffer);
X    `7D
X`09
X/*
X * Allocate an array to store the article numbers.
X */
X    ar = ARRAYALLOC(art_num, (newsgroup->last - newsgroup->current + 3));
X    for (i = 0; i <= (newsgroup->last - newsgroup->current);i++) `7B
X`09ar`5Bi`5D = 0;
X    `7D
X
X    msgids = avl_init_table(strcmp);
X    if (msgids == NULL) `7B
X`09(void) sprintf(error_buffer, "Can't build message ID hash table for %s\n"
V,
X`09`09`09       newsgroup->name);
X`09ehErrorExitXRN(error_buffer);
X    `7D
X
X    /*`20
X     * Step 1: Initialize and build the message ID lookup table
X     */
X    num_arts = 0;
X    for (i = newsgroup->current; i <= newsgroup->last; i++) `7B
X`09long indx = INDEX(i);
X
X`09/* canceled and empty articles will not have a subject entry */
X`09if (articles`5Bindx`5D.subject != NIL(char)) `7B
X
X`09    /* don't put articles in the string if already read ... */
X`09    if ((mode == ALL) `7C`7C
X`09        (mode == UNKILLED && IS_UNKILLED(artstat`5Bindx`5D) &&
X`09`09`09`09     IS_ACTIVE(artstat`5Bindx`5D)) `7C`7C
X`09`09(mode == ACTIVE && IS_ACTIVE(artstat`5Bindx`5D)) `7C`7C
X`09        (mode == UNREAD && IS_UNREAD(artstat`5Bindx`5D))) `7B
X`09`09if (mode != UNKILLED)
X`09`09    SET_ACTIVE(artstat`5Bindx`5D);
X`09`09avl_insert(msgids, articles`5Bindx`5D.msgid, (char *)&articles`5Bindx`
V5D);
X`09`09articles`5Bindx`5D.parent = 0;
X`09`09articles`5Bindx`5D.child = 0;
X`09`09ar`5Bnum_arts++`5D = i;
X`09    `7D
X`09`7D else `7B
X`09    /* if you can't get the subject, mark the article as unavailable */
X`09    SET_UNAVAIL(artstat`5Bindx`5D);
X`09`7D
X    `7D
X
X    /*`20
X     * Step 2: find parents and link articles
X     */
X    for (i = 0; i < num_arts; i++) `7B
X`09long indx = INDEX(ar`5Bi`5D);
X
X`09if (avl_lookup(msgids, articles`5Bindx`5D.refs`5B0`5D, &ptr) `7C`7C
X`09    avl_lookup(msgids, articles`5Bindx`5D.refs`5B1`5D, &ptr) `7C`7C
X`09    avl_lookup(msgids, articles`5Bindx`5D.refs`5B2`5D, &ptr)) `7B
X`09    art1 = art = (struct article *) ptr;
X`09    articles`5Bindx`5D.parent = ar`5Bi`5D;
X`09    /*
X`09     * Find end of child chain
X`09     */
X`09    while (art1->child) `7B
X`09`09art1 = &articles`5BINDEX(art1->child)`5D;
X`09    `7D
X`09    art1->child = ar`5Bi`5D;
X`09`7D`20
X    `7D
X
X    /*`20
X     * Step 3: subject sort toplevel articles (no parents)
X     */
X    tree = avl_init_table(utSubjectCompare);
X
X    for (i = 0; i < num_arts; i++) `7B
X`09long indx = INDEX(ar`5Bi`5D);
X
X`09if (!articles`5Bindx`5D.parent) `7B
X`09    (void) strncpy(curSub, getSubject(ar`5Bi`5D), sizeof(curSub));
X`09    curSub`5Bsizeof(curSub)-1`5D = '\0';
X
X`09    if (avl_lookup(tree, curSub, &ptr)) `7B
X`09`09/* add to the end */
X`09`09pte = (struct entry *) ptr;
X`09`09if (pte->left <= 0) `7B
X`09`09    pte->left = pte->size;
X`09`09    pte->size = pte->size * 2;
X`09`09    pte->articleList =
X`09`09`09(art_num *) XtRealloc((char *)pte->articleList,
X`09`09`09`09`09     pte->size * sizeof(art_num));
X`09`09`7D
X`09`09pte->articleList`5Bpte->used`5D = ar`5Bi`5D;
X`09`09pte->used++;
X`09`09pte->left--;
X`09    `7D else `7B
X`09`09/* create new */
X`09`09pte = ALLOC(struct entry);
X`09`09pte->startingArticle = ar`5Bi`5D;
X`09`09pte->articleList = ARRAYALLOC(art_num, 32);
X`09`09pte->used = 1;
X`09`09pte->size = 32;
X`09`09pte->left = pte->size - pte->used;
X`09`09pte->articleList`5B0`5D = ar`5Bi`5D;
X`09`09(void) avl_insert(tree, XtNewString(curSub), (char *) pte);
X`09    `7D
X`09`7D
X    `7D
X    i = 0;
X
X    treeSize = avl_count(tree);
X    if (treeSize == 0) `7B`09`09/* No articles */
X`09avl_free_table(tree, XtFree, valfree);
X`09return NIL(art_num);
X    `7D
X
X    pteArray = ARRAYALLOC(struct entry *, treeSize);
X    gen = avl_init_gen(tree, AVL_FORWARD);
X    while (avl_gen(gen, &key, &ptr)) `7B
X`09pteArray`5Bi++`5D = (struct entry *) ptr;
X    `7D
X    avl_free_gen(gen);
X
X    /* sort by article number */
X    qsort((void *) pteArray, treeSize, sizeof(struct pte *), pteCompare);
X
X    /*`20
X     * Step 4: generate output in thread order
X     */
X    for (i = 0; i <= (newsgroup->last - newsgroup->current);i++) `7B
X`09ar`5Bi`5D = 0;
X    `7D
X
X    j = 0;
X    for (i = 0; i < treeSize; i++) `7B
X`09for (k = 0; k < pteArray`5Bi`5D->used; k++) `7B
X`09    ar`5Bj++`5D = num = pteArray`5Bi`5D->articleList`5Bk`5D;
X`09    art1 = &articles`5BINDEX(num)`5D;
X`09    while (art1->child) `7B
X`09`09ar`5Bj++`5D = art1->child;
X`09`09art1 = &articles`5BINDEX(art1->child)`5D;
X`09    `7D
X`09`7D
X    `7D
X
X    avl_free_table(tree, XtFree, valfree);
X    avl_free_table(msgids, NULL, NULL);
X    FREE(pteArray);
X    ar`5Bj`5D = 0;
X    *count = j;
X    return ar;
X`7D
X
X
Xart_num *
XgetArticleNumbers(mode, count)
Xint mode;
Xint *count;
X`7B
X    if (app_resources.displayLineCount) `7B
X`09sprintf(formatString,"  %%5ld:%%-%d\056%ds %%6.6s %%-%d.%ds",
X`09`09app_resources.subjectLength, app_resources.subjectLength,
X`09`09app_resources.authorLength, app_resources.authorLength);
X    `7D else `7B
X`09sprintf(formatString,"  %%5ld:%%-%d\056%ds  %%-%d.%ds",
X`09`09app_resources.subjectLength, app_resources.subjectLength,
X`09`09app_resources.authorLength, app_resources.authorLength);
X    `7D
X    if (app_resources.sortedSubjects == THREAD_SORTED) `7B
X`09return getThreadedArticles(mode, count);
X    `7D`20
X    if (app_resources.sortedSubjects) `7B
X`09return getSortedArticles(mode, count);
X    `7D else `7B
X`09return getUnSortedArticles(mode, count);
X    `7D
X`7D
X
X/*
X * set the internal pointers to a particular article
X */
Xvoid
XgotoArticle(article)
Xart_num article;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X
X    newsgroup->current = (art_num) article;
X    NextPreviousArticle = (art_num) article;
X    return;
X`7D
X
X/*
X * set the internal pointers to the first article
X */
Xvoid
XgotoFirstArticle()
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    art_num article = newsgroup->initial;
X
X    newsgroup->current = (art_num) article;
X    NextPreviousArticle = (art_num) article;
X    return;
X`7D
X
Xint
XcheckArticle(art)
Xart_num art;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X
X    /* Check if requested article is not available */
X    if (art < newsgroup->first `7C`7C art > newsgroup->last) `7B
X        return XRN_ERROR;
X    `7D
X    return XRN_OKAY;
X`7D   `20
X
X/*
X * first and last are the same and there are no articles
X *
X * representation bug in the news system active file
X *
X */
Xvoid
XbogusNewsgroup()
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X
X    if (newsgroup->artStatus != NIL(struct artStat)) `7B
X`09SET_READ(newsgroup->artStatus`5BLAST`5D);
X`09SET_UNAVAIL(newsgroup->artStatus`5BLAST`5D);
X    `7D
X
X    currentArticles = NULL;
X    mesgPane(XRN_INFO, "No articles in `60%s', probably killed or canceled",
V newsgroup->name);
X   `20
X    return;
X`7D
X
X
X#define STRIPLEADINGSPACES   for (; *start == ' '; start++);
X#define STRIPENDINGSPACES  for ( ; *end == ' '; *end = '\0', end--);
X
Xstatic char *
Xstrip(str, striprefs)
Xchar *str;
XBoolean striprefs;
X`7B
X    register char *start, *end, *ptr;
X    static char work`5BBUFFER_SIZE`5D;
X
X    if (str == NIL(char)) `7B
X`09return NIL(char);
X    `7D
X    (void) strncpy(work, str, BUFFER_SIZE);
X    start = work;
X    work`5BBUFFER_SIZE - 1`5D = '\0';
X    end = index(start, '\0') - 1;
X
X    STRIPLEADINGSPACES;
X
X    /*
X     * strip leading '`5BrR`5D`5BeE`5D: ' and 'Re`5EN: ' -
X     * only if striprefs is TRUE (want to be able to kill follow-ups)
X     */
X    if (striprefs) `7B
X`09while (STREQN(start, "Re: ", 4) `7C`7C
X`09       STREQN(start, "RE: ", 4) `7C`7C
X`09       STREQN(start, "re: ", 4) `7C`7C
X`09       STREQN(start, "Re: ", 4)) `7B
X`09    start += 4;
X`09
X`09    /* strip leading spaces after '`5BrR`5De: ' */
X`09    STRIPLEADINGSPACES;
X`09`7D
X
X`09while (STREQN(start, "Re`5E", 3)) `7B
X`09    start += 3;
X`09    ptr = index(start, ':');
X`09    if (ptr != NIL(char)) `7B
X`09`09start = ptr + 1;
X`09    `7D
X`09    STRIPLEADINGSPACES;
X`09`7D
X
X`09for (end = start; (end = index(end, '(')) != NULL;)
X`09  if (STREQN(end,"(was:",5)
X`09      `7C`7C  STREQN(end,"(Was:",5)
X`09      `7C`7C  STREQN(end,"(WAS:",5)) `7B
X`09      *end = '\0';
X`09      break;
X`09  `7D
X`09  else ++end;
X    `7D
X
X    end = index(start, '\0') - 1;
X    STRIPENDINGSPACES;
X
X    return start;
X`7D
X
X/*
X * return the subject of an article with trailing/leading spaces stripped,
X * leading '`5BrR`5De: ' stripped, and trailing ' (`5BwW`5Das: ' stripped
X */
Xchar *
XgetSubject(article)
Xart_num article;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    art_num artnum = (art_num) article;
X
X    SETARTICLES(newsgroup);
X
X    return strip(currentArticles`5BINDEX(artnum)`5D.subject, True);
X`7D
X
X/*
X * return the author of an article
X */
Xchar *
XgetAuthor(article)
Xart_num article;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    struct article *articles = GETARTICLES(newsgroup);
X
X    return articles`5BINDEX((art_num) article)`5D.author;
X`7D
X
X/*
X * return the text of an article
X */
Xchar *
XgetText(article)
Xart_num article;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    struct article *articles = GETARTICLES(newsgroup);
X
X    return articles`5BINDEX((art_num) article)`5D.text;
X`7D
X
X/*
X * get the previous subject (article number is NextPreviousArticle).
X * only called when going off the top of the subject string
X *
X *   returns a point to a static area
X *
X *  NextPreviousArticle is set to current on building the subject string.
X *  NextPreviousArticle is decremented by this routine.
X */
Xchar *
XgetPrevSubject()
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    struct article *articles = GETARTICLES(newsgroup);
X
X    /* search for the next available article in the reverse direction */
X    for (NextPreviousArticle--;
X`09 NextPreviousArticle >= newsgroup->first; NextPreviousArticle--) `7B
X`09long indx = INDEX(NextPreviousArticle);
X`09
X`09if (NextPreviousArticle < newsgroup->initial)
X`09    newsgroup->initial = NextPreviousArticle;
X
X`09/* get the subject (and author) if it does not already exist */
X`09if (articles`5Bindx`5D.subject == NIL(char)) `7B
X
X`09    /* get the subject and a few more */
X`09    getsubjectlist(newsgroup,
X`09`09`09   MAX(newsgroup->first, NextPreviousArticle - SUBJECTS),
X`09`09`09   NextPreviousArticle, False);
X`09`7D
X
X`09if (articles`5Bindx`5D.author == NIL(char)) `7B
X`09    getauthorlist(newsgroup,
X`09`09`09  MAX(newsgroup->first, NextPreviousArticle - SUBJECTS),
X`09`09`09   NextPreviousArticle, False);
X
X`09`7D
X
X`09if (articles`5Bindx`5D.lines == NIL(char)) `7B
X`09    getlineslist(newsgroup,
X`09`09`09 MAX(newsgroup->first, NextPreviousArticle - SUBJECTS),
X`09`09`09 NextPreviousArticle, False);
X`09`7D
X
X`09if (articles`5Bindx`5D.msgid == NIL(char)) `7B
X`09    getmsgidlist(newsgroup,
X`09`09`09 MAX(newsgroup->first, NextPreviousArticle - SUBJECTS),
X`09`09`09 NextPreviousArticle, False);
X`09`7D
X
X`09if (articles`5Bindx`5D.refs`5B0`5D == NIL(char)) `7B
X`09    getrefslist(newsgroup,
X`09`09`09 MAX(newsgroup->first, NextPreviousArticle - SUBJECTS),
X`09`09`09 NextPreviousArticle, False);
X`09`7D
X
X`09if (articles`5Bindx`5D.subject) `7B
X`09    (void) getSubjectLine(NextPreviousArticle);
X`09    return subjectline;
X`09`7D
X`09/* continue on */
X    `7D
X
X    return NIL(char);
X`7D
X
X
Xstatic art_num justInCase;   /* old NextPreviousArticle, just in case the se
Varch fails */
X
Xvoid
XstartSearch()
X/* the front-end is about to do an article search, save the starting point *
V/
X`7B
X    justInCase = NextPreviousArticle;
X    return;
X`7D
X
X
Xvoid
XfailedSearch()
X/* the article search failed, restore the original point */
X`7B
X    NextPreviousArticle = justInCase;
X    return;
X`7D
X
X
Xvoid
XfillUpArray(art)
Xart_num art;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X
X    if (art < newsgroup->current) `7B
X`09if (!getoverview(newsgroup, art, newsgroup->current - 1, False)) `7B
X`09    getsubjectlist(newsgroup, art, newsgroup->current - 1, False);
X`09    getauthorlist(newsgroup, art, newsgroup->current - 1, False);
X`09    getlineslist(newsgroup, art, newsgroup->current - 1, False);
X`09    getmsgidlist(newsgroup, art, newsgroup->current - 1, False);
X`09    getrefslist(newsgroup, art, newsgroup->current - 1, False);
X`09`7D
X    `7D
X    return;
X`7D
X
X
X/*
X * getinfofromfile`09Get a string from a named file
X *`09`09`09Handle white space and comments.
X *
X *`09Parameters:`09"file" is the name of the file to read.
X *
X *`09Returns:`09Pointer to static data area containing the
X *`09`09`09first non-ws/comment line in the file.
X *`09`09`09NULL on error (or lack of entry in file).
X *
X *`09Side effects:`09None.
X */
X
Xchar *
Xgetinfofromfile(file)
Xchar`09*file;
X`7B
X`09register FILE`09*fp;
X`09register char`09*cp;
X`09static char`09buf`5B256`5D;
X`09char`09`09*getenv();
X
X`09if (file == NULL)
X`09`09return (NULL);
X
X`09fp = fopen(file, "r");
X`09if (fp == NULL)
X`09`09return (NULL);
X
X`09while (fgets(buf, sizeof (buf), fp) != NULL) `7B
X`09`09if (*buf == '\n' `7C`7C *buf == '#')
X`09`09`09continue;
X`09`09cp = index(buf, '\n');
X`09`09if (cp)
X`09`09`09*cp = '\0';
X`09`09(void) fclose(fp);
X`09`09return (buf);
X`09`7D
X
X`09(void) fclose(fp);
X`09return (NULL);`09`09`09 /* No entry */
X`7D
X
Xchar *
XgetSubjectLine(art)
Xart_num art;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    struct article *articles = GETARTICLES(newsgroup);
X    struct artStat *artstat = GETSTATUS(newsgroup);
X    long indx = INDEX(art);
X
X    subjectline`5B0`5D = '\0';
X    if (art < newsgroup->first `7C`7C art > newsgroup->last)
X`09return subjectline;
X    if (app_resources.displayLineCount) `7B
X`09(void) sprintf(subjectline, formatString,`20
X`09`09       art,
X`09`09       (articles`5Bindx`5D.subject != NIL(char) ?
X`09`09       articles`5Bindx`5D.subject : " "),
X`09`09       (articles`5Bindx`5D.lines != NIL(char) ?
X`09`09       articles`5Bindx`5D.lines : " "),
X`09`09       (articles`5Bindx`5D.author == NIL(char) ?
X`09`09       "(none)" : articles`5Bindx`5D.author));
X    `7D else `7B
X`09(void) sprintf(subjectline, formatString,
X`09`09       art,
X`09`09       (articles`5Bindx`5D.subject != NIL(char) ?
X`09`09       articles`5Bindx`5D.subject : " "),
X`09`09       (articles`5Bindx`5D.author == NIL(char) ?
X`09`09       "(none)" : articles`5Bindx`5D.author));
X    `7D
X    /* mark articles if they have already been read */
X    if (IS_READ(artstat`5Bindx`5D)) `7B
X`09subjectline`5B0`5D = '+';
X    `7D else `7B
X`09subjectline`5B0`5D = ' ';
X    `7D
X    if (IS_KILLED(artstat`5Bindx`5D)) `7B
X`09subjectline`5B0`5D = 'k';
X    `7D
X    if (IS_UNREAD(artstat`5Bindx`5D) && IS_MARKED(artstat`5Bindx`5D)) `7B
X`09subjectline`5B0`5D = 'u';
X    `7D
X    if (IS_SAVED(artstat`5Bindx`5D)) `7B
X`09subjectline`5B1`5D = 'S';
X    `7D else if(IS_PRINTED(artstat`5Bindx`5D)) `7B
X`09subjectline`5B1`5D = 'P';
X    `7D else `7B
X`09subjectline`5B1`5D = ' ';
X    `7D
X    return subjectline;
X`7D
$ CALL UNPACK INTERNALS.C;164 252308054
$ create 'f'
X#ifndef INTERNALS_H
X#define INTERNALS_H
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/internals.h,v 1.4 19
V93/01/11 02:15:00 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X
X/*
X * internals.h: news system interface
X */
X
X/*
X * Get datatype definitions we need for prototyping
X */
X#include "news.h"
X
X#define XRN_ERROR 0
X#define XRN_NOMORE 0
X#define XRN_OKAY   1
X
X/*`20
X * kill file stuff
X */
X#define KILL_GLOBAL 0
X#define KILL_LOCAL 1
Xextern void killItem _ARGUMENTS((char *, int));
Xextern char *localKillFile _ARGUMENTS((struct newsgroup*, int));
Xextern char *globalKillFile ();
Xextern void killThread _ARGUMENTS((int));
X
X/*
X * routines for adding newsgroups to the newsrc file
X */
X`20
X/* 'status' values for the 'add' functions */
X#define SUBSCRIBE 1
X#define UNSUBSCRIBE 0
X                                                         `20
Xextern int addToNewsrcAfterGroup _ARGUMENTS((char *, char *, int));
Xextern int addToNewsrcEnd _ARGUMENTS((char *, int));
Xextern int addToNewsrcBeginning _ARGUMENTS((char *, int));
X
X
X/*
X * routines for doing newsgroup management
X */
X
X/* jump/goto/add newsgroup codes */
X#define BAD_GROUP -1
X#define GOOD_GROUP 1
X#define GOOD_GROUP_MARKED 2
X
X/* set the internal group to 'name', with prefetch invalidation */
Xextern int gotoNewsgroup _ARGUMENTS((char *));
Xextern int gotoNewsgroupForRead _ARGUMENTS((char *));
X/* same thing, but without prefetch invalidation */
Xextern int setNewsgroup _ARGUMENTS((char *));
X
X/* set the internal group to 'name', and if all of the articles are read, un
Vmark the last one */
Xextern int jumpToNewsgroup _ARGUMENTS((char *));
X
X/* getNewsgroup returns 0 if a bad group, 1 if okay */
Xextern int getNewsgroup();
X
X/* subscribe to the current newsgroup */
Xextern void subscribe();
X/* unsubscribe to the current newsgroup */
Xextern void unsubscribe();
X
X/* check subscription status */
Xextern int issubscribed();
X
X/* updates the .newsrc file so that the current newsgroup is marked as all r
Vead */
Xextern void catchUpAll();
Xextern void catchUp();
X
X
X/*
X * routines for doing article management
X */
X
Xextern void gotoArticle _ARGUMENTS((art_num));
Xextern void gotoFirstArticle();
X
Xextern int getArticleText _ARGUMENTS((char **, char **));
Xextern int toggleHeaders _ARGUMENTS((char **, char **));
Xextern int toggleRotation _ARGUMENTS((char **, char **));
Xextern char *openQuestion();
Xextern char *currentQuestion();
X
X/* mark articles */
Xextern void markArticleAsRead _ARGUMENTS((art_num));
Xextern void markArticleAsUnread _ARGUMENTS((art_num));
Xextern void markArticleAsKilled _ARGUMENTS((art_num));
Xextern void markArticleAsUnkilled _ARGUMENTS((art_num));
X
X/* get a single subject line, stripped of leading/trailing spaces, Re: */
Xextern char *getSubject _ARGUMENTS((art_num));
Xextern char *getAuthor _ARGUMENTS((art_num));
Xextern char *getText _ARGUMENTS((art_num));
Xextern char *getSubjectLine _ARGUMENTS((art_num));
X
Xextern Boolean articleRead _ARGUMENTS((art_num));
Xextern Boolean articleMarkedUnread _ARGUMENTS((art_num));
X
X/* get the subject line for the previous subject (and get the article too) *
V/
X/* only called when going off the top of the subject string */
Xextern char *getPrevSubject();
X
Xextern void startSearch();
Xextern void failedSearch();
X
X/*
X * information gathering routines
X */
X
Xextern void checkLock();
Xextern void removeLock();
X `20
X/* read the .newsrc file, find out what to read */
Xextern void initializeNews();
X
X/* query the server for new information */
Xextern void rescanServer();
X
X/* return the new newsgroups string */
Xextern struct newsgroup **newGroups();
X
X/* return the unread newsgroups list */
Xextern ng_num *unreadGroups _ARGUMENTS((int, Boolean *));
X
X/* return the group status string */
Xextern char *groupStatus _ARGUMENTS((int));
Xextern char *groupName _ARGUMENTS((int));
X
X/* return the subject string */
X#define ALL 0
X#define UNREAD 1
X#define UNKILLED 2
X#define ACTIVE 3
X
Xextern art_num *getArticleNumbers _ARGUMENTS((int, int *));
X/* Types of subject sorting */
X#define UNSORTED 0
X#define ARTICLE_SORTED 1
X#define STRICT_SORTED 2
X#define THREAD_SORTED 3
X
X/* build and return the status list */
Xextern ng_num *getStatusList _ARGUMENTS((int));
Xextern char *getStatusString _ARGUMENTS((int));
X
Xextern void bogusNewsgroup();
X
Xextern void releaseNewsgroupResources();
Xextern void clearArtCache();
X
Xextern void fillUpArray _ARGUMENTS((art_num));
X
X#define GETARTICLES(newsgroup) (currentArticles) ? \
X`09(currentArticles) : getarticles(newsgroup)
Xstruct article *getarticles _ARGUMENTS((struct newsgroup *));
X
X#define GETSTATUS(newsgroup) (newsgroup->artStatus) ? \
X`09(newsgroup->artStatus) : getartstatus(newsgroup)
X
Xstruct artStat *getartstatus _ARGUMENTS((struct newsgroup *));
X
Xextern int checkArticle _ARGUMENTS((art_num));
X#ifdef XLATE
Xextern int toggleXlation _ARGUMENTS((char **, char **));
X#endif
X
X#endif /* INTERNALS_H */
$ CALL UNPACK INTERNALS.H;51 1064501575
$ create 'f'
X
X#if !defined(lint) && !defined(SABER)
Xstatic char XRNrcsid`5B`5D = "$Header: /net/objy27/wrld/mnt11/ricks/src/mast
Ver/xrn/killfile.c,v 1.1 1993/01/11 02:15:02 ricks Exp $";
X#endif
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * killfile.c: kill file editor
X */
X
X#include "copyright.h"
X#include <stdio.h>
X#ifndef VMS
X#include <sys/types.h>
X#include <sys/stat.h>
X#else /* VMS */
X#include <descrip.h>
X#include <types.h>
X#include <stat.h>
X#endif /* VMS */
X#include "config.h"
X#include "utils.h"
X#ifndef VMS
X#include <X11/cursorfont.h>
X#include <X11/StringDefs.h>
X#include <X11/Intrinsic.h>
X#include <X11/Shell.h>
X#else
X#include <decw$include/cursorfont.h>
X#include <decw$include/StringDefs.h>
X#include <decw$include/Intrinsic.h>
X#include <decw$include/Shell.h>
X#endif
X#ifdef MOTIF
X#include <Xm/PanedW.h>
X#include <Xm/PushB.h>
X#include <Xm/RowColumn.h>
X#include <Xm/TextP.h>
X#include <Xm/Label.h>
X#include <Xm/Frame.h>
X#if (XmVERSION == 1) && (XmREVISION == 0)
X#define MOTIF_V10
X#endif
X#else /* MOTIF */
X#ifndef DwtNmenuExtendLastRow
X#define DwtNmenuExtendLastRow "menuExtendLastRow"
X#endif
X#ifndef VMS
X#include <X11/DECwDwtWidgetProg.h>
X#else
X#include <decw$include/DECwDwtWidgetProg.h>
X#endif /* VMS */
X#include "Pane.h"
X#endif /* MOTIF */
X#include <time.h>
X#include <signal.h>
X#include "xthelper.h"
X#include "resources.h"
X#include "xrn.h"
X#include "xmisc.h"
X#include "butdefs.h"
X#include "news.h"
X#include "mesg.h"
X#include "error_hnds.h"
X#include "internals.h"
X
Xextern void addTimeOut();
Xextern void removeTimeOut();
X#ifdef VMS
Xextern int lib$spawn();
X#endif
Xchar error_buffer`5B2048`5D;
X
X/* entire widget */
Xstatic Widget KillTopLevel = (Widget) 0;
X/* text window */
Xstatic Widget KillText = (Widget) 0;
Xstatic Widget editDismiss;
Xstatic Widget editSave;
Xstatic Boolean KillMapped = False;
Xstatic char KillFileName`5B512`5D;
X
X
X#ifndef VMS
X
Xstatic pid_t forkpid;
X
X#ifdef __STDC__
Xstatic void
Xcatch_sigchld(signo)
Xint signo;
X`7B
X    if (signo != SIGCHLD) `7B
X`09/* whoops! */
X`09return;
X    `7D
X    (void) signal(SIGCHLD, SIG_DFL);
X    if (forkpid != wait(0)) `7B
X`09/* whoops! */
X`09return;
X    `7D
X    return;
X`7D
X#else
Xstatic int
Xcatch_sigchld(signo)
Xint signo;
X`7B
X    if (signo != SIGCHLD) `7B
X`09/* whoops! */
X`09return 1;
X    `7D
X    (void) signal(SIGCHLD, SIG_DFL);
X    if (forkpid != wait(0)) `7B
X`09/* whoops! */
X`09return 1;
X    `7D
X    return 1;
X`7D
X#endif /* __STDC__ */
X#endif /* VMS */
X
X/*ARGSUSED*/
Xstatic void
XeditDismissFunction(widget, event, string, count)
XWidget widget;
XXEvent *event;
XString *string;
XCardinal *count;
X`7B
X    KillMapped = False;
X    XtUnmapWidget(KillTopLevel);
X    return;
X`7D
X
X/*ARGSUSED*/
Xstatic void
XeditSaveFunction(widget, event, string, count)
XWidget widget;
XXEvent *event;
XString *string;
XCardinal *count;
X`7B
X    FILE *fp;
X    char *str = NULL;
X    char *ptr = NULL;
X
X#ifdef MOTIF
X    ptr = str = XmTextGetString(KillText);
X#else
X    ptr = str = DwtSTextGetString(KillText);
X#endif
X    if ((fp = fopen(KillFileName, "w")) != NULL) `7B
X`09while (*str) `7B
X`09    if (fputc(*str, fp) == EOF) `7B
X`09`09mesgPane(XRN_SERIOUS, "Error writing kill file (%s): %s",
X`09`09`09 KillFileName, errmsg(errno));
X`09`09break;
X`09    `7D
X`09    ++str;
X`09`7D
X        --str;
X`09if (*str != '\n') fputc('\n', fp);
X`09fclose(fp);
X    `7D else `7B
X`09mesgPane(XRN_SERIOUS, "Can not open the kill file (%s): %s",
X`09`09KillFileName, errmsg(errno));
X    `7D
X    if (ptr) XtFree(ptr);
X
X    KillMapped = False;
X    XtUnmapWidget(KillTopLevel);
X    return;
X`7D
X
X#ifndef MOTIF
X#define XmNlabelString DwtNlabel
X#define XmNactivateCallback DwtNactivateCallback
X#define XmNborderWidth DwtNborderWidth
X#endif
X
XBUTTON(editDismiss)
XBUTTON(editSave)
X
X/* Used to fork editors when the widget editor is not being used. */
X
Xstatic void
XexternalKillFileEdit()
X`7B
X    char buffer`5B1024`5D;
X    int sysStat;
X    int maxdesc;
X#ifdef VMS
X    struct dsc$descriptor_s cmd_desc;
X    int one = 1;`09`09/* cli$m_nowait */
X#endif
X`09
X    /*
X     * app_resources.editorCommand is a sprintf'able string with a %s where
V the
X     * file name should be placed.  The result should be a command that
X     * handles all editing and windowing.
X     *
X     * Examples are:
X     *
X     *   emacsclient %s
X     *   xterm -e vi %s
X     *   xterm -e microEmacs %s
X     *
X     */
X     (void) sprintf(buffer, app_resources.editorCommand, KillFileName);
X#ifndef VMS
X#ifdef VFORK_SUPPORTED
X    if ((forkpid = vfork()) == 0) `7B
X#else
X    if ((forkpid = fork()) == 0) `7B
X#endif
X`09int i;
X
X#ifdef hpux
X`09maxdesc = _NFILE;
X#else
X#ifdef SVR4
X#include <ulimit.h>
X`09maxdesc = ulimit(UL_GDESLIM);
X#else
X`09maxdesc = getdtablesize();
X#endif
X#endif
X`09for (i = 3; i < maxdesc; i++) `7B
X`09    (void) close(i);
X`09`7D
X`09(void) execl("/bin/csh", "csh", "-f", "-c", buffer, 0);
X`09(void) fprintf(stderr, "execl of %s failed\n", buffer);
X`09(void) _exit(127);
X    `7D
X    if (forkpid < 0) `7B
X`09sprintf(error_buffer, "Can not execute editor (%s)", errmsg(errno));
X`09infoNow(error_buffer);
X`09return;
X    `7D else `7B
X#ifdef __STDC__
X`09signal(SIGCHLD, catch_sigchld);
X#else
X`09signal(SIGCHLD, (SIG_PF0) catch_sigchld);
X#endif
X    `7D
X#else /* VMS */
X    cmd_desc.dsc$b_class = DSC$K_CLASS_S;
X    cmd_desc.dsc$b_dtype = DSC$K_DTYPE_T;
X    cmd_desc.dsc$w_length = strlen(buffer);
X    cmd_desc.dsc$a_pointer = buffer;
X
X    sysStat = lib$spawn(&cmd_desc,0,0,&one);
X    if ((sysStat & 1) != 1) `7B
X`09mesgPane(XRN_SERIOUS, "Error return from spawn - %d, aborting",
X`09`09sysStat);
X`09return;
X    `7D
X#endif
X    return;
X`7D
X
Xvoid
XEditKillFile(group)
Xstruct newsgroup *group;
X/*
X * brings up a new vertical pane, not moded
X *
X * the pane consists of 3 parts: title bar, scrollable text window,
X * button box
X */
X`7B
X    static Widget pane, buttonBox, label;
X    Arg paneArgs`5B4`5D;
X    Position x = 0;
X    Position y = 0;
X    Dimension width = 0;
X    Dimension height = 0;
X#ifdef MOTIF
X    Widget frame;
X#endif
X    int c, i;
X    static char *ptr = NULL;
X    char *end;
X    static int ptrlen = 0;
X    struct stat buf;
X    FILE *filefp;
X    char labelString`5B128`5D;
X
X    static Arg labelArgs`5B`5D = `7B
X#ifdef MOTIF
X`09`7BXmNlabelString, (XtArgVal) NULL`7D,
X`09`7BXmNskipAdjust, (XtArgVal) True`7D,
X#else
X`09`7BDwtNlabel,`09(XtArgVal) NULL`7D,
X#endif
X    `7D;
X    static Arg boxArgs`5B`5D = `7B
X#ifdef MOTIF
X`09`7BXmNnumColumns,`09`09(XtArgVal) 1`7D,
X`09`7BXmNadjustLast, `09(XtArgVal) False`7D,
X`09`7BXmNorientation,`09(XtArgVal) XmHORIZONTAL`7D,
X`09`7BXmNpacking,`09`09(XtArgVal) XmPACK_COLUMN`7D,
X`09`7BXmNallowResize,`09(XtArgVal) True`7D,
X`09`7BXmNskipAdjust, `09(XtArgVal) True`7D,
X#else
X`09`7BDwtNresizeHeight,`09(XtArgVal) True`7D,
X`09`7BDwtNresizeWidth,`09(XtArgVal) False`7D,
X`09`7BDwtNorientation,`09(XtArgVal) DwtOrientationHorizontal`7D,
X`09`7BDwtNmenuPacking,`09(XtArgVal) DwtMenuPackingTight`7D,
X`09`7BDwtNmenuExtendLastRow, (XtArgVal) False`7D,
X`09`7BDwtNborderWidth,`09(XtArgVal) 3`7D,
X`09`7BDwtNentryBorder,`09(XtArgVal) 2`7D,
X`09`7BDwtNchildOverlap,`09(XtArgVal) False`7D,
X`09`7BDwtNmenuNumColumns,`09(XtArgVal) 4`7D,
X`09`7BDwtNmin,`09`09(XtArgVal) 30`7D,
X#endif
X    `7D;
X    static Arg shellArgs`5B`5D = `7B
X`09`7BXtNinput, (XtArgVal) True`7D,
X`09`7BXtNsaveUnder, (XtArgVal) False`7D,
X    `7D;
X    static Arg textArgs`5B`5D = `7B
X#ifdef MOTIF
X`09`7BXmNrows,`09`09(XtArgVal) 20`7D,
X`09`7BXmNcolumns,`09`09(XtArgVal) 80`7D,
X`09`7BXmNwordWrap, `09`09(XtArgVal) FALSE`7D,
X`09`7BXmNscrollVertical, `09(XtArgVal) TRUE`7D,
X`09`7BXmNscrollHorizontal, `09(XtArgVal) TRUE`7D,
X`09`7BXmNeditMode,  `09`09(XtArgVal) XmMULTI_LINE_EDIT`7D,
X`09`7BXmNeditable,`09`09(XtArgVal) TRUE`7D,
X#else
X`09`7BDwtNrows,`09`09(XtArgVal) 20`7D,
X`09`7BDwtNcols,`09`09(XtArgVal) 80`7D,
X`09`7BDwtNwordWrap, `09`09(XtArgVal) FALSE`7D,
X`09`7BDwtNscrollVertical, `09(XtArgVal) TRUE`7D,
X`09`7BDwtNeditable,`09`09(XtArgVal) TRUE`7D,
X#endif
X    `7D;
X
X
X    if (ptr) `7B
X`09ptr`5B0`5D = '\0';
X    `7D
X    if (group) `7B
X`09strcpy(KillFileName, localKillFile(group, 1));
X    `7D else `7B
X`09strcpy(KillFileName, globalKillFile());
X    `7D
X    if (app_resources.editorCommand != NIL(char)) `7B
X`09externalKillFileEdit();
X`09return;
X    `7D
X    if ((stat(KillFileName, &buf) != -1) &&
X`09((filefp = fopen(KillFileName, "r")) != NULL)) `7B
X`09buf.st_size = buf.st_size + 2;
X`09if (ptrlen == 0) `7B
X`09    ptr = XtMalloc(buf.st_size);
X`09    ptrlen = buf.st_size;
X`09`7D else `7B
X`09    if (buf.st_size > ptrlen) `7B
X`09`09ptr = XtRealloc(ptr, buf.st_size);
X`09`09ptrlen = buf.st_size;
X`09    `7D
X`09`7D
X`09end = ptr;
X`09while ((c = getc(filefp)) != EOF) `7B
X`09    *end = c;
X`09    end++;
X`09`7D
X`09*end = '\0';
X`09(void) fclose(filefp);
X    `7D
X    sprintf(labelString, "Editing Kill File for group %s", group->name);
X#ifdef MOTIF
X    labelArgs`5B0`5D.value = (XtArgVal) XmStringLtoRCreate(labelString,
X`09`09XmSTRING_DEFAULT_CHARSET);
X#else
X    labelArgs`5B0`5D.value = (XtArgVal) DwtLatin1String(labelString);
X#endif
X
X    if (KillTopLevel != (Widget) 0 && !KillMapped) `7B
X#ifdef MOTIF
X`09XmTextSetString(KillText, ptr);
X`09XtSetValues(label, labelArgs, XtNumber(labelArgs));
X`09XmStringFree((XmString)labelArgs`5B0`5D.value);
X#else
X`09DwtSTextSetString(KillText, ptr);
X`09XtSetValues(label, labelArgs, XtNumber(labelArgs));
X`09XtFree(labelArgs`5B0`5D.value);
X#endif
X`09XtMapWidget(KillTopLevel);
X#if defined(MOTIF) && !defined(MOTIF_V10)
X`09XmProcessTraversal(KillText, XmTRAVERSE_CURRENT);
X#endif
X`09KillMapped = True;
X`09return;
X    `7D
X    if (KillTopLevel == (Widget) 0) `7B
X`09KillTopLevel = XtCreatePopupShell("Kill File Edit",
X`09`09`09`09topLevelShellWidgetClass,
X`09`09`09`09TopLevel, shellArgs, XtNumber(shellArgs));
X
X`09XtSetArg(paneArgs`5B0`5D, XtNx, &x);
X`09XtSetArg(paneArgs`5B1`5D, XtNy, &y);
X`09XtSetArg(paneArgs`5B2`5D, XtNwidth, &width);
X`09XtSetArg(paneArgs`5B3`5D, XtNheight, &height);
X`09XtGetValues(TopLevel, paneArgs, XtNumber(paneArgs));
X`09XtSetArg(paneArgs`5B0`5D, XtNx, x);
X`09XtSetArg(paneArgs`5B1`5D, XtNy, y);
X`09XtSetArg(paneArgs`5B2`5D, XtNwidth, width);
X`09XtSetArg(paneArgs`5B3`5D, XtNheight, height);
X#ifdef MOTIF
X`09pane = XtCreateManagedWidget("pane", xmPanedWindowWidgetClass,
X`09`09`09`09    KillTopLevel, paneArgs, XtNumber(paneArgs));
X#else
X`09pane = DwtPaneCreate(KillTopLevel, "killEditPane",`20
X`09`09`09`09    paneArgs, 3);
X`09XtManageChild(pane);
X#endif
X
X#ifdef MOTIF
X`09label = XtCreateManagedWidget("label", xmLabelWidgetClass, pane,
X`09`09`09`09      labelArgs, XtNumber(labelArgs));
X
X`09XmStringFree((XmString)labelArgs`5B0`5D.value);
X`09frame = XtCreateManagedWidget("killFrame", xmFrameWidgetClass,
X`09`09`09`09`09pane, NULL, 0);
X`09KillText = XmCreateScrolledText(frame, "text",`20
X`09`09`09`09`09 textArgs, XtNumber(textArgs));
X`09XmTextSetString(KillText, ptr);
X#else
X`09label = DwtLabelCreate(pane, "label",`20
X`09`09`09`09      labelArgs, XtNumber(labelArgs));
X
X`09XtFree(labelArgs`5B0`5D.value);
X`09XtManageChild(label);
X`09KillText = DwtSTextCreate(pane, "text",`20
X`09`09`09`09`09 textArgs, XtNumber(textArgs));
X`09DwtSTextSetString(KillText, ptr);
X#endif
X`09XtManageChild(KillText);
X
X#ifdef MOTIF
X`09buttonBox = XtCreateManagedWidget("box", xmRowColumnWidgetClass, pane,
X`09`09`09`09`09  boxArgs, XtNumber(boxArgs));
X`09editSaveArgs`5B1`5D.value = (XtArgVal) XmStringLtoRCreate(
X`09`09`09`09`09`09"Save",
X`09`09`09`09`09`09XmSTRING_DEFAULT_CHARSET);
X`09editSave = XtCreateManagedWidget("save", xmPushButtonWidgetClass,
X`09`09`09      buttonBox, editSaveArgs, XtNumber(editSaveArgs));
X   `20
X`09XmStringFree((XmString) editSaveArgs`5B1`5D.value);
X`09editDismissArgs`5B1`5D.value = (XtArgVal) XmStringLtoRCreate(
X`09`09`09`09`09`09"Dismiss",
X`09`09`09`09`09`09XmSTRING_DEFAULT_CHARSET);
X`09editDismiss = XtCreateManagedWidget("dismiss", xmPushButtonWidgetClass,
X`09`09`09      buttonBox, editDismissArgs, XtNumber(editDismissArgs));
X   `20
X`09XmStringFree((XmString) editDismissArgs`5B1`5D.value);
X#else
X`09buttonBox = DwtMenuCreate(pane, "box",`20
X`09`09`09`09`09  boxArgs, XtNumber(boxArgs));
X`09XtManageChild(buttonBox);
X`09editSaveArgs`5B1`5D.value = (XtArgVal) DwtLatin1String("Save");
X`09XtManageChild(DwtPushButtonCreate(buttonBox, "save",
X`09`09`09      editSaveArgs, XtNumber(editSaveArgs)));
X   `20
X`09XtFree(editSaveArgs`5B1`5D.value);
X`09editDismissArgs`5B1`5D.value = (XtArgVal) DwtLatin1String("Dismiss");
X`09XtManageChild(DwtPushButtonCreate(buttonBox, "dismiss",
X`09`09`09      editDismissArgs, XtNumber(editDismissArgs)));
X   `20
X`09XtFree(editDismissArgs`5B1`5D.value);
X#endif
X`09XtRealizeWidget(KillTopLevel);
X
X`09XtPopup(KillTopLevel, XtGrabNone);
X#if defined(MOTIF) && !defined(MOTIF_V10)
X`09XmProcessTraversal(editDismiss, XmTRAVERSE_CURRENT);
X#endif
X`09KillMapped = True;
X
X`09/* xthCenterWidgetOverCursor(KillTopLevel); */
X
X    `7D
X    return;
X`7D
X
$ CALL UNPACK KILLFILE.C;8 1293271486
$ create 'f'
X$ cc/nolist avl
X$ cc/nolist buttons/opt=noinline`09! makes the compile faster
X$ cc/nolist clientlib
X$ cc/nolist compose
X$ cc/nolist cursor
X$ cc/nolist dialogs
X$ cc/nolist error_hnds
X$ cc/nolist internals
X$ cc/nolist killfile
X$ cc/nolist menus
X$ cc/nolist mesg
X$ cc/nolist newsrcfile
X$ cc/nolist newsrc_parse
X$ cc/nolist pane
X$ cc/nolist resources
X$ cc/nolist save
X$ cc/nolist server
X$ cc/nolist slist
X$ cc/nolist t6
X$ cc/nolist t7
X$ cc/nolist utils
X$ cc/nolist xmisc
X$ cc/nolist xrn
X$ cc/nolist xthelper
X$ link/exe=dxrn sys$input/opt
Xxrn,buttons,compose,cursor,dialogs,error_hnds,menus,mesg
Xnewsrcfile,newsrc_parse,resources,internals,save,server,utils
Xxmisc,xthelper,avl,clientlib,t6,t7,pane,slist,killfile
Xsys$share:decw$dwtlibshr/share
Xsys$share:decw$xlibshr/share
Xsys$share:vaxcrtl/share
X!
X! Remove this or put in your TCP/IP library
X!
Xsys$share:ucx$ipc/library
X!
X! For example, to use Multinet:
X!
X!multinet_socket_library/share
X$ exit
$ CALL UNPACK MAKE-DXRN.COM;2 2081980159
$ create 'f'
X$ ! As distributed, this command file will build mxrn for`20
X$ ! DECwindows/Motif V1.0 or later.
X$ !
X$ ! This file is conditionalized to compile and link properly for
X$ ! either VAX C on OpenVMS VAX or DEC C on OpenVMS AXP.
X$ !
X$ ! Include the following line if you're using a Motif Developer's kit
X$ !@sys$common:`5Bdecw$motif`5Ddxm_logicals
X$ ! Otherwise, the following two lines
X$ define x11 decw$include
X$ define xm decw$include
X$ define sys sys$Library
X$ !
X$ is_alpha = "false"
X$ if f$getsyi("hw_model") .eq. 0 then is_alpha = "true"
X$ if f$getsyi("hw_model") .gt. 1023 then is_alpha = "true"
X$
X$ CFLAGS = "/DEFINE=(MOTIF)"
X$ if is_alpha`20
X$ then`20
X$   CFLAGS = CFLAGS + "/PREFIX=ALL"
X$   CRTL = ""
X$ endif
X$!
X$ if p1 .eqs. "LINK" then goto link
X$ cc/nolist 'CFLAGS avl
X$ cc/nolist 'CFLAGS buttons/opt=noinline`09! Makes the compile faster
X$ cc/nolist 'CFLAGS clientlib/define=(MOTIF,UCX)
X$ cc/nolist 'CFLAGS compose
X$ cc/nolist 'CFLAGS cursor
X$ cc/nolist 'CFLAGS dialogs
X$ cc/nolist 'CFLAGS error_hnds
X$ cc/nolist 'CFLAGS internals
X$ cc/nolist 'CFLAGS killfile
X$ cc/nolist 'CFLAGS menus
X$ cc/nolist 'CFLAGS mesg
X$ cc/nolist 'CFLAGS newsrcfile
X$ cc/nolist 'CFLAGS newsrc_parse
X$ cc/nolist 'CFLAGS resources
X$ cc/nolist 'CFLAGS save
X$ cc/nolist 'CFLAGS server
X$ cc/nolist 'CFLAGS slist
X$ cc/nolist 'CFLAGS t6
X$ cc/nolist 'CFLAGS t7
X$ cc/nolist 'CFLAGS utils
X$ cc/nolist 'CFLAGS xmisc
X$ cc/nolist 'CFLAGS xrn
X$ cc/nolist 'CFLAGS xthelper
X$link:
X$ if is_alpha then goto link_alpha
X$ !
X$ ! Link for OpenVMS VAX
X$ !
X$ link/exe=mxrn sys$input/opt
Xxrn,buttons,compose,cursor,dialogs,error_hnds,menus,mesg
Xnewsrcfile,newsrc_parse,resources,internals,save,server,utils
Xxmisc,xthelper,avl,clientlib,t6,t7,slist,killfile
X!use these libraries for Motif Developer's kit V1.0:
X!Xm:DECW$MOTIF$XM.OLB/LIBRARY
X!Xt:DECW$MOTIF$XT.OLB/LIBRARY
X!Xt:CLIB.OLB/LIBRARY
X!
X!use these for Motif Developer's kit V1.1.
X!
X!sys$share:decw$motif$dxmshr/shareable
X!sys$share:decw$motif$xmshr/shareable
X!sys$share:decw$motif$xtshr/shareable
X!
X!use these for DECwindows/Motif V1.0
Xsys$share:decw$dxmlibshr/shareable
Xsys$share:decw$xmlibshr/shareable
Xsys$share:decw$xtshr/shareable
X!
X!use these for either version.
X!
Xsys$share:decw$xlibshr/shareable
Xsys$share:vaxcrtl/share
X!
X! Remove this or put in your TCP/IP library
X!
Xsys$share:ucx$ipc/library
X!
X! For example, to use Multinet:
X!
X!multinet_socket_library/share
X$ exit
X$ !
X$ ! Link for OpenVMS AXP
X$ !
X$link_alpha:
X$ if f$search("sys$share:decw$dxmlibshr12.exe") .nes. ""
X$ then
X$ link/exe=mxrn sys$input/opt
Xxrn,buttons,compose,cursor,dialogs,error_hnds,menus,mesg
Xnewsrcfile,newsrc_parse,resources,internals,save,server,utils
Xxmisc,xthelper,avl,clientlib,t6,t7,slist,killfile
Xsys$share:decw$dxmlibshr12.exe/share
Xsys$share:decw$xmlibshr12.exe/share
Xsys$share:decw$xtlibshrr5.exe/share
Xsys$share:decw$xlibshr.exe/share
X!
X! Remove this or put in your TCP/IP library
X!
Xsys$share:ucx$ipc_shr/share
X!
X! For example, to use Multinet:
X!
X!multinet_socket_library/share
X$ else
X$ link/exe=mxrn sys$input/opt
Xxrn,buttons,compose,cursor,dialogs,error_hnds,menus,mesg
Xnewsrcfile,newsrc_parse,resources,internals,save,server,utils
Xxmisc,xthelper,avl,clientlib,t6,t7,slist,killfile
Xsys$share:decw$dxmlibshr.exe/share
Xsys$share:decw$xmlibshr.exe/share
Xsys$share:decw$xtshr.exe/share
Xsys$share:decw$xlibshr.exe/share
X!
X! Remove this or put in your TCP/IP library
X!
Xsys$share:ucx$ipc_shr/share
X!
X! For example, to use Multinet:
X!
X!multinet_socket_library/share
X$ endif
X$ exit
$ CALL UNPACK MAKE-MXRN.COM;13 1912816301
$ create 'f'
X$ ! MAKE.COM for MXRN/DXRN
X$ ! Contributed by Patrick L. Mahan, mahan@tgv.com
X$ !
X$ !
X$ ! I have include in this message a new DCL make procedure for`20
X$ ! DXRN/MXRN.  It consolidates both make-dxrn.com and make-mxrn.com
X$ ! together into one package.  I call it MAKE.COM and it supports
X$ ! the following:
X$ !
X$ !`09$ @MAKE`09`09! will build DXRN
X$ ! `09$ @MAKE MOTIF`09! will build MXRN
X$ !`09$ @MAKE CLEAN`09! cleans out *.LIS, *.OBJ files
X$ !`09$ @MAKE CLOBBER`09! cleans out *.exe then does a clean
X$ !
X$ ! Thought this might make it easier on people who build this stuff
X$ SAVE_VERIFY='F$VERIFY(0)
X$ if p1 .Eqs. "CLEAN" then goto clean
X$ if p1 .Eqs. "CLOBBER" then goto clobber
X$ if p1 .Eqs. "MOTIF"`20
X$ Then
X$`09program = "MXRN"
X$`09interface = "DECwindows/Motif"
X$`09define/nolog X11 DECW$INCLUDE
X$`09define/nolog XM  DECW$INCLUDE
X$ Else
X$`09program = "DXRN"
X$`09interface = "DECwindows"
X$ Endif
X$!
X$!`09Compile the XRN with the user requested Interface
X$!
X$ Set Symbol/Scope=NoGlobal
X$!
X$!  Determine if we are compiling on the Alpha or VAX
X$!
X$ If F$GetSYI("HW_MODEL") .Gt. 1024
X$ Then
X$`09program = "MXRN"
X$`09interface = "DECwindows/Motif"
X$!
X$!`09The following command is setup to build for using the
X$!`09MultiNet BSD Socket library.  If you are using some other
X$!`09vendor's socket library of Digital's then this line
X$!`09should change. `20
X$!
X$`09CC := CC/PREFIX=ALL
X$ EndIf
X$!
X$!  Check to see if we are running above OpenVMS v6.0.
X$!  If so, then we can only build MXRN
X$!
X$ ver = F$Extract(1,999,F$GetSYI("VERSION"))
X$ If F$Locate("6.",ver) .Ne. F$Length(ver)
X$ Then
X$`09program = "MXRN"
X$`09interface = "DECwindows/Motif"
X$ EndIf
X$!
X$!  Get the compiler options via the logical name COPTS
X$!
X$ If program .Eqs. "MXRN"
X$ Then
X$ `09cc_options = f$trnlnm("COPTS") + "/define=(MOTIF, MULTINET)"
X$ Else
X$`09cc_options = f$trnlnm("COPTS") + "/define=(MULTINET)
X$ Endif
X$!
X$!  Get the linker options via the logical name LOPTS
X$!
X$ link_options = f$trnlnm("LOPTS")
X$!
X$!  Compile the "C" files
X$!
X$! procedure target`09command `09`09`09depends upon
X$! CALL MAKE FILE.OBJ`09"CC ''cc_options' FILE.C"`09FILE.C
X$ write sys$output "Making XRN with ''interface' interface"
X$ CALL MAKE AVL.OBJ  `09`09"CC ''cc_options' AVL"`09AVL.C
X$ CALL MAKE BUTTONS.OBJ  `09"CC ''cc_options'/OPTION=NOINLINE BUTTONS"`09BUT
VTONS.C
X$ CALL MAKE CLIENTLIB.OBJ  `09"CC ''cc_options' CLIENTLIB"`09CLIENTLIB.C
X$ CALL MAKE COMPOSE.OBJ  `09"CC ''cc_options' COMPOSE"`09COMPOSE.C
X$ CALL MAKE CURSOR.OBJ  `09"CC ''cc_options' CURSOR"`09CURSOR.C
X$ CALL MAKE DIALOGS.OBJ  `09"CC ''cc_options' DIALOGS"`09DIALOGS.C
X$ CALL MAKE ERROR_HNDS.OBJ  `09"CC ''cc_options' ERROR_HNDS"`09ERROR_HNDS.C
X$ CALL MAKE INTERNALS.OBJ  `09"CC ''cc_options' INTERNALS"`09INTERNALS.C
X$ CALL MAKE KILLFILE.OBJ  `09"CC ''cc_options' KILLFILE"`09KILLFILE.C
X$ CALL MAKE MENUS.OBJ  `09`09"CC ''cc_options' MENUS"`09MENUS.C
X$ CALL MAKE MESG.OBJ  `09`09"CC ''cc_options' MESG"`09`09MESG.C
X$ CALL MAKE NEWSRCFILE.OBJ  `09"CC ''cc_options' NEWSRCFILE"`09NEWSRCFILE.C
X$ CALL MAKE NEWSRC_PARSE.OBJ`09"CC ''cc_options' NEWSRC_PARSE"`09NEWSRC_PARS
VE.C
X$ If program .Nes. "MXRN" then -
X  CALL MAKE PANE.OBJ  `09`09"CC ''cc_options' PANE"`09`09PANE.C
X$ CALL MAKE RESOURCES.OBJ  `09"CC ''cc_options' RESOURCES"`09RESOURCES.C
X$ CALL MAKE SAVE.OBJ  `09`09"CC ''cc_options' SAVE"`09`09SAVE.C
X$ CALL MAKE SERVER.OBJ  `09"CC ''cc_options' SERVER"`09SERVER.C
X$ CALL MAKE SLIST.OBJ  `09`09"CC ''cc_options' SLIST"`09SLIST.C
X$ CALL MAKE T6.OBJ  `09`09"CC ''cc_options' T6"`09`09T6.C
X$ CALL MAKE T7.OBJ  `09`09"CC ''cc_options' T7"`09`09T7.C
X$ CALL MAKE UTILS.OBJ  `09`09"CC ''cc_options' UTILS"`09UTILS.C
X$ CALL MAKE XMISC.OBJ  `09`09"CC ''cc_options' XMISC"`09XMISC.C
X$ CALL MAKE XRN.OBJ  `09`09"CC ''cc_options' XRN"`09`09XRN.C
X$ CALL MAKE XTHELPER.OBJ  `09"CC ''cc_options' XTHELPER"`09XTHELPER.C
X$!
X$! If you are building XRN to use with MultiNet on an Alpha then you
X$! will need to uncomment the following lines.  This is because we
X$! need to tell DEC C to only prefix ANSI routines with DECC$ in order
X$! to prevent the common socket routines (socket, accept, connect, etc)
X$! from being prefix with DECC$.  This allows us to use the MultiNet
X$! socket library instead.  However, a side effect is that certain
X$! routines will not get the DECC$ prefix and the linker will complain.
X$! To get around this we create Alpha transfer vectors that will allow
X$! us to access the proper DEC C routines.
X$ If F$GetSYI("HW_MODEL") .Gt. 1024 Then -
X  CALL MAKE TRANSFER.OBJ`09"MACRO/ALPHA/NOLIST TRANSFER.M64" TRANSFER.M64
X$!
X$! *WARNING, also uncomment the line "!TRANSFER.OBJ" from the
X$! MXRN.OPT file in order to include this file in the link.
X$!
X$ write sys$output "Building ''program'"
X$ CALL MAKE 'program'.EXE`09"LINK ''link_options' ''program'/OPT" *.OBJ
X$!
X$ exit
X$!
X$ Clobber:`09! Delete executables, Purge directory and clean up object files
V and listings
X$ Delete/noconfirm/log *.exe;*
X$!
X$ Clean:`09! Purge directory, clean up object files and listings
X$ Purge
X$ Delete/noconfirm/log *.lis;*
X$ Delete/noconfirm/log *.obj;*
X$!
X$ exit
X$!
X$MAKE: SUBROUTINE   !SUBROUTINE TO CHECK DEPENDENCIES
X$ V = 'F$Verify(0)
X$! P1 = What we are trying to make
X$! P2 = Command to make it
X$! P3 - P8  What it depends on
X$
X$ If F$Search(P1) .Eqs. "" Then Goto Makeit
X$ Time = F$CvTime(F$File(P1,"RDT"))
X$arg=3
X$Loop:
X$`09Argument = P'arg
X$`09If Argument .Eqs. "" Then Goto Exit
X$`09El=0
X$Loop2:
X$`09File = F$Element(El," ",Argument)
X$`09If File .Eqs. " " Then Goto Endl
X$`09AFile = ""
X$Loop3:
X$`09OFile = AFile
X$`09AFile = F$Search(File)
X$`09If AFile .Eqs. "" .Or. AFile .Eqs. OFile Then Goto NextEl
X$`09If F$CvTime(F$File(AFile,"RDT")) .Ges. Time Then Goto Makeit
X$`09Goto Loop3
X$NextEL:
X$`09El = El + 1
X$`09Goto Loop2
X$EndL:
X$ arg=arg+1
X$ If arg .Le. 8 Then Goto Loop
X$ Goto Exit
X$
X$Makeit:
X$ Set Verify
X$ 'P2
X$ VV='F$Verify(0)
X$Exit:
X$ If V Then Set Verify
X$ENDSUBROUTINE
$ CALL UNPACK MAKE.COM;4 410219563
$ create 'f'
X#
X# xrn - an X-based NNTP news reader
X#
X# Copyright (c) 1988, 1989, 1990, Ellen M. Sentovich and Rick L. Spickelmier
V.
X#
X# Permission to use, copy, modify, and distribute this software and its
X# documentation for any purpose and without fee is hereby granted, provided
X# that the above copyright notice appear in all copies and that both that
X# copyright notice and this permission notice appear in supporting
X# documentation, and that the name of the University of California not
X# be used in advertising or publicity pertaining to distribution of`20
X# the software without specific, written prior permission.  The University
X# of California makes no representations about the suitability of this
X# software for any purpose.  It is provided "as is" without express or
X# implied warranty.
X#
X# THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X# THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X# FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X# ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X# CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X#
X# The following may need changing for your site:
X#
X# CC, DEST, LD, LDFLAGS, LIBS, MANDIR, MANSUFFIX, INCLUDES
X#
X# The libraries -lPW and -lBSD should be included for machines running
X# HP-UX.  This may apply to other SYSV systems.
X#
X
X#           CC = gcc
X
X          SHELL = `09/bin/sh
X
X        DEFINES =
X           DEST = /usr/local/bin
X           HDRS = avl.h buttons.h codes.h compose.h config.h copyright.h \
X`09`09  cursor.h dialogs.h error_hnds.h internals.h mesg.h \
X`09`09  modes.h news.h newsrcfile.h resources.h save.h server.h \
X`09`09  utils.h xmisc.h xrn.h xthelper.h slist.h slistP.h Pane.h \
X`09`09  PaneP.h
X         CFLAGS = $(INCLUDES) $(STD_DEFINES) $(DEFINES)
X       INCLUDES =
X        INSTALL = cp
X        LDFLAGS =`20
X         DWTLIB = -ldwt
X           XLIB = -lX11
X           LIBS = $(DWTLIB) $(XLIB)
X       INCLUDES =`20
X       MANDIR = /usr/man/man1
X      MANPAGE = mxrn.man
X    MANSUFFIX = 1
X       RM_CMD = rm *.CKP *.ln *.BAK *.bak *.o core errs ,* *`7E *.a \
X`09`09`09.emacs_* tags TAGS make.log MakeOut
X`20
X        OBJS = avl.o buttons.o clientlib.o compose.o cursor.o dialogs.o \
X`09       menus.o mesg.o error_hnds.o newsrcfile.o resources.o \
X`09       internals.o refile.o save.o server.o utils.o xmisc.o xrn.o    \
X`09       xthelper.o killfile.o pane.o slist.o
X
X       PRINT = pr
X     PROGRAM = dxrn
X        SRCS = avl.c buttons.c clientlib.c compose.c \
X`09       cursor.c dialogs.c error_hnds.c internals.c menus.c mesg.c \
X`09       newsrcfile.c refile.c resources.c save.c server.c utils.c \
X`09       pane.c slist.c xmisc.c xrn.c xthelper.c killfile.c
X
X
Xall:`09`09$(PROGRAM)
X
X$(PROGRAM):     $(OBJS) y.tab.o
X`09`09@echo "Linking $(PROGRAM) ..."
X`09`09$(CC) $(LDFLAGS) $(OBJS) y.tab.o $(LIBS) -o $(PROGRAM)
X`09`09@echo "done"
X
Xlex.yy.c:`09newsrc.l
X`09`09lex newsrc.l
X
Xy.tab.c:`09newsrc.y
X`09`09yacc newsrc.y
X
Xy.tab.o:`09lex.yy.c avl.h news.h newsrcfile.h utils.h
X
Xclean:;`09`09@rm -f $(OBJS) core y.tab.o y.tab.c lex.yy.c
X
Xinstall:`09$(PROGRAM)
X`09`09@echo Installing $(PROGRAM) in $(DEST)
X`09`09@if `5B $(DEST) ! = . `5D; then \
X`09`09(rm -f $(DEST)/$(PROGRAM); \
X`09`09$(INSTALL) $(PROGRAM) $(DEST); \
X`09`09chmod 755 $(DEST)/$(PROGRAM)); fi
X
Xinstall-man:`09$(MANPAGE)
X`09`09@cp $(MANPAGE) $(MANDIR)/`60basename $(MANPAGE) .man`60.$(MANSUFFIX)
X
Xprint:;`09`09@$(PRINT) $(HDRS) $(SRCS) newsrc.l newsrc.y
X
Xtags:           $(HDRS) $(SRCS) newsrc.l newsrc.y
X`09`09@ctags $(HDRS) $(SRCS) newsrc.l newsrc.y
X
X
$ CALL UNPACK MAKEFILE.;26 255531666
$ create 'f'
X#
X# xrn - an X-based NNTP news reader
X#
X# Copyright (c) 1988, 1989, 1990, Ellen M. Sentovich and Rick L. Spickelmier
V.
X#
X# Permission to use, copy, modify, and distribute this software and its
X# documentation for any purpose and without fee is hereby granted, provided
X# that the above copyright notice appear in all copies and that both that
X# copyright notice and this permission notice appear in supporting
X# documentation, and that the name of the University of California not
X# be used in advertising or publicity pertaining to distribution of`20
X# the software without specific, written prior permission.  The University
X# of California makes no representations about the suitability of this
X# software for any purpose.  It is provided "as is" without express or
X# implied warranty.
X#
X# THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X# THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X# FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X# ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X# CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X#
X# The following may need changing for your site:
X#
X# CC, DEST, LD, LDFLAGS, LIBS, MANDIR, MANSUFFIX, INCLUDES
X#
X# The libraries -lPW and -lBSD should be included for machines running
X# HP-UX.  This may apply to other SYSV systems.
X#
X
X#           CC = gcc
X
X          SHELL = `09/bin/sh
X
X        DEFINES = -DDECNET
X           DEST = /usr/local/bin
X           HDRS = avl.h buttons.h codes.h compose.h config.h copyright.h \
X`09`09  cursor.h dialogs.h error_hnds.h internals.h mesg.h \
X`09`09  modes.h news.h newsrcfile.h resources.h save.h server.h \
X`09`09  utils.h xmisc.h xrn.h xthelper.h slist.h slistP.h Pane.h \
X`09`09  PaneP.h
X         CFLAGS = $(INCLUDES) $(STD_DEFINES) $(DEFINES)
X       INCLUDES =
X        INSTALL = cp
X        LDFLAGS =`20
X         DWTLIB = -ldwt
X           XLIB = -lX11
X        DNETLIB = -ldnet
X           LIBS = $(DWTLIB) $(XLIB) $(DNETLIB)
X       INCLUDES =`20
X       MANDIR = /usr/man/man1
X      MANPAGE = mxrn.man
X    MANSUFFIX = 1
X       RM_CMD = rm *.CKP *.ln *.BAK *.bak *.o core errs ,* *`7E *.a \
X`09`09`09.emacs_* tags TAGS make.log MakeOut
X`20
X        OBJS = avl.o buttons.o clientlib.o compose.o cursor.o dialogs.o \
X`09       menus.o mesg.o error_hnds.o newsrcfile.o resources.o \
X`09       internals.o refile.o save.o server.o utils.o xmisc.o xrn.o    \
X`09       xthelper.o killfile.o pane.o slist.o
X
X       PRINT = pr
X     PROGRAM = dxrn
X        SRCS = avl.c buttons.c clientlib.c compose.c \
X`09       cursor.c dialogs.c error_hnds.c internals.c menus.c mesg.c \
X`09       newsrcfile.c refile.c resources.c save.c server.c utils.c \
X`09       pane.c slist.c xmisc.c xrn.c xthelper.c killfile.c
X
X
Xall:`09`09$(PROGRAM)
X
X$(PROGRAM):     $(OBJS) y.tab.o
X`09`09@echo "Linking $(PROGRAM) ..."
X`09`09$(CC) $(LDFLAGS) $(OBJS) y.tab.o $(LIBS) -o $(PROGRAM)
X`09`09@echo "done"
X
Xlex.yy.c:`09newsrc.l
X`09`09lex newsrc.l
X
Xy.tab.c:`09newsrc.y
X`09`09yacc newsrc.y
X
Xy.tab.o:`09lex.yy.c avl.h news.h newsrcfile.h utils.h
X
Xclean:;`09`09@rm -f $(OBJS) core y.tab.o y.tab.c lex.yy.c
X
Xinstall:`09$(PROGRAM)
X`09`09@echo Installing $(PROGRAM) in $(DEST)
X`09`09@if `5B $(DEST) ! = . `5D; then \
X`09`09(rm -f $(DEST)/$(PROGRAM); \
X`09`09$(INSTALL) $(PROGRAM) $(DEST); \
X`09`09chmod 755 $(DEST)/$(PROGRAM)); fi
X
Xinstall-man:`09$(MANPAGE)
X`09`09@cp $(MANPAGE) $(MANDIR)/`60basename $(MANPAGE) .man`60.$(MANSUFFIX)
X
Xprint:;`09`09@$(PRINT) $(HDRS) $(SRCS) newsrc.l newsrc.y
X
Xtags:           $(HDRS) $(SRCS) newsrc.l newsrc.y
X`09`09@ctags $(HDRS) $(SRCS) newsrc.l newsrc.y
X
X
$ CALL UNPACK MAKEFILE.DECNET;15 1312541555
$ create 'f'
X#
X# xrn - an X-based NNTP news reader
X#
X# Copyright (c) 1988, 1989, 1990, Ellen M. Sentovich and Rick L. Spickelmier
V.
X#
X# Permission to use, copy, modify, and distribute this software and its
X# documentation for any purpose and without fee is hereby granted, provided
X# that the above copyright notice appear in all copies and that both that
X# copyright notice and this permission notice appear in supporting
X# documentation, and that the name of the University of California not
X# be used in advertising or publicity pertaining to distribution of`20
X# the software without specific, written prior permission.  The University
X# of California makes no representations about the suitability of this
X# software for any purpose.  It is provided "as is" without express or
X# implied warranty.
X#
X# THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X# THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X# FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X# ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X# RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X# CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X#
X# The following may need changing for your site:
X#
X# CC, DEST, LD, LDFLAGS, LIBS, MANDIR, MANSUFFIX, INCLUDES
X#
X# The libraries -lPW and -lBSD should be included for machines running
X# HP-UX.  This may apply to other SYSV systems.
X#
X
X#           CC = gcc
X
X          SHELL = `09/bin/sh
X
X# for DECnet, define DECNET.
X#       DEFINES = -DMOTIF -DDECNET
X# if you don't want DECnet support, use this:
X        DEFINES = -DMOTIF
X           DEST = /usr/local/bin
X           HDRS = avl.h buttons.h codes.h compose.h config.h copyright.h \
X`09`09  cursor.h dialogs.h error_hnds.h internals.h mesg.h \
X`09`09  modes.h news.h newsrcfile.h resources.h save.h server.h \
X`09`09  utils.h xmisc.h xrn.h xthelper.h slist.h slistP.h
X         CFLAGS = $(INCLUDES) $(STD_DEFINES) $(DEFINES)
X       INCLUDES =
X        INSTALL = cp
X        LDFLAGS =`20
X# If you're using DECnet, use this line
X#       DNETLIB = -ldnet
X# Else, use this one.
X        DNETLIB =
X           XLIB = -lX11 -lXmu
X#Use the following two lines for Motif developer's kits, else the next ones.
X#       XTOOLLIB = /usr/lib/DXM/lib/Xt/libXt.a
X#       MTOOLLIB = /usr/lib/DXM/lib/Xm/libXm.a
X       XTOOLLIB = -lXt
X       MTOOLLIB = -lXm
X           LIBS = $(MTOOLLIB) $(XTOOLLIB) $(XLIB) $(DNETLIB)
X
X# Uncomment the next line for the developer's kits.
X#       INCLUDES = -I/usr/lib/DXM/lib/Xt -I/usr/lib/DXM/lib
X       MANDIR = /usr/man/man1
X      MANPAGE = mxrn.man
X    MANSUFFIX = 1
X       RM_CMD = rm *.CKP *.ln *.BAK *.bak *.o core errs ,* *`7E *.a \
X`09`09`09.emacs_* tags TAGS make.log MakeOut
X`20
X        OBJS = avl.o buttons.o clientlib.o compose.o cursor.o dialogs.o \
X`09       mesg.o error_hnds.o menus.o newsrcfile.o resources.o \
X`09       internals.o refile.o save.o server.o utils.o xmisc.o xrn.o    \
X`09       xthelper.o killfile.o slist.o`20
X
X       PRINT = pr
X     PROGRAM = mxrn
X        SRCS = avl.c buttons.c clientlib.c compose.c \
X`09       cursor.c dialogs.c error_hnds.c internals.c menus.c mesg.c \
X`09       newsrcfile.c resources.c refile.c save.c server.c utils.c \
X`09       slist.c xmisc.c xrn.c xthelper.c killfile.c
X
X
Xall:`09`09$(PROGRAM)
X
X$(PROGRAM):     $(OBJS) y.tab.o
X`09`09@echo "Linking $(PROGRAM) ..."
X`09`09$(CC) $(LDFLAGS) $(OBJS) y.tab.o $(LIBS) -o $(PROGRAM)
X`09`09@echo "done"
X
Xlex.yy.c:`09newsrc.l
X`09`09lex newsrc.l
X
Xy.tab.c:`09newsrc.y
X`09`09yacc newsrc.y
X
Xy.tab.o:`09lex.yy.c avl.h news.h newsrcfile.h utils.h
X
Xclean:;`09`09@rm -f $(OBJS) core y.tab.o y.tab.c lex.yy.c
X
Xinstall:`09$(PROGRAM)
X`09`09@echo Installing $(PROGRAM) in $(DEST)
X`09`09@if `5B $(DEST) != . `5D; then \
X`09`09(rm -f $(DEST)/$(PROGRAM); \
X`09`09$(INSTALL) $(PROGRAM) $(DEST); \
X`09`09chmod 755 $(DEST)/$(PROGRAM)); fi
X
Xinstall-man:`09$(MANPAGE)
X`09`09@cp $(MANPAGE) $(MANDIR)/`60basename $(MANPAGE) .man`60.$(MANSUFFIX)
X
Xprint:;`09`09@$(PRINT) $(HDRS) $(SRCS) newsrc.l newsrc.y
X
Xtags:           $(HDRS) $(SRCS) newsrc.l newsrc.y
X`09`09@ctags $(HDRS) $(SRCS) newsrc.l newsrc.y
X
X
$ CALL UNPACK MAKEFILE.MOTIF;25 1986600353
$ create 'f'
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988, 1989, 1990, Ellen M. Sentovich and Rick L. Spickelmie
Vr.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * menus.c: create the menus
X *
X */
X
X#include "copyright.h"
X#include <stdio.h>
X#include "config.h"
X#ifndef VMS
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#else
X#include <decw$include/Intrinsic.h>
X#include <decw$include/StringDefs.h>
X#endif
X#ifdef MOTIF
X#include <Xm/BulletinB.h>
X#include <Xm/RowColumn.h>
X#include <Xm/PushB.h>
X#include <Xm/PushBG.h>
X#include <Xm/CascadeB.h>
X#include <Xm/CascadeBG.h>
X#include <Xm/ScrolledW.h>
X#include <Xm/List.h>
X#include <Xm/Label.h>
X#include <Xm/LabelG.h>
X#include <Xm/Text.h>
X#include <Xm/Separator.h>
X#include <Xm/ToggleB.h>
X#include <Xm/ToggleBG.h>
X#include <Xm/Form.h>
X#if (XmVERSION == 1) && (XmREVISION == 0)
X#define MOTIF_V10
X#endif
X#else
X#ifndef VMS
X#include <X11/DECwDwtWidgetProg.h>
X#else
X#include <decw$include:DECwDwtWidgetProg.h>
X#endif
X#endif /* MOTIF */
X#include "xmisc.h"
X#include "xrn.h"
X#include "utils.h"
X#include "resources.h"
X#include "mesg.h"
X#include "modes.h"
X#include "error_hnds.h"
X#ifdef __STDC__
X#include <stdlib.h>
X#endif
X#include "menus.h"
X#include "buttons.h"
X#include "slist.h"
X
XXmString addItems`5B50`5D;
XXmString removeItems`5B50`5D;
X#ifdef MOTIF
XXmFontList fontList;
X#else
XDwtFontList fontList;
X#endif
X
Xstatic Boolean updatesDone = False;
X
Xstatic XrmDatabase`09xrmDB;
Xextern char`09`09customName`5B512`5D;
Xextern int`09`09Mode;`09`09`09/* Current mode */
XXFontStruct *font;
Xtypedef struct buttonDefs `7B
X    char *name;
X    char *label;
X    int  addPos;
X    int  removePos;
X    XmString listString;
X`7D ButtonDefs;
X
XButtonDefs addButtons`5B`5D = `7B
X    `7B"addQuit","Quit",0,0,NULL`7D,
X    `7B"addFirst","Add First",0,0,NULL`7D,
X    `7B"addLast","Add Last",0,0,NULL`7D,
X    `7B"addAfter","Add After Group",0,0,NULL`7D,
X    `7B"addUnsub","Add Unsubscribed",0,0,NULL`7D,
X`7D;
XButtonDefs ngButtons`5B`5D = `7B
X    `7B"ngExit","Exit",0,0,NULL`7D,
X    `7B"ngQuit","Quit",0,0,NULL`7D,
X    `7B"ngRead","Read Group",0,0,NULL`7D,
X    `7B"ngOpen","Open Group",0,0,NULL`7D,
X    `7B"ngNext","Next",0,0,NULL`7D,
X    `7B"ngPrev","Prev",0,0,NULL`7D,
X    `7B"ngCatchUp","Catch Up",0,0,NULL`7D,
X    `7B"ngSubscribe","Subscribe",0,0,NULL`7D,
X    `7B"ngUnsub","Unsubscribe",0,0,NULL`7D,
X    `7B"ngGoto","Go To Group",0,0,NULL`7D,
X    `7B"ngToggleGroups","Toggle Groups",0,0,NULL`7D,
X    `7B"ngAllGroups","All Groups",0,0,NULL`7D,
X    `7B"ngRescan","Rescan",0,0,NULL`7D,
X    `7B"ngPrevGroup","Prev Group",0,0,NULL`7D,
X    `7B"ngSelect","Select Groups",0,0,NULL`7D,
X    `7B"ngMove","Move",0,0,NULL`7D,
X    `7B"ngDisconnect","Disconnect",0,0,NULL`7D,
X    `7B"ngCheckPoint","Checkpoint",0,0,NULL`7D,
X    `7B"ngPost","Post",0,0,NULL`7D,
X    `7B"ngGripe","Gripe",0,0,NULL`7D,
X`7D;
X
XButtonDefs allButtons`5B`5D = `7B
X    `7B"allQuit","Quit",0,0,NULL`7D,
X    `7B"allSub","Subscribe",0,0,NULL`7D,
X    `7B"allFirst","Subscribe First",0,0,NULL`7D,
X    `7B"allLast","Subscribe Last",0,0,NULL`7D,
X    `7B"allAfter","Subscribe After Group",0,0,NULL`7D,
X    `7B"allUnsub","Unsubscribe",0,0,NULL`7D,
X    `7B"allGoto","Go To Group",0,0,NULL`7D,
X    `7B"allOpen","Open Group",0,0,NULL`7D,
X    `7B"allSelect","Select Groups",0,0,NULL`7D,
X    `7B"allMove","Move",0,0,NULL`7D,
X    `7B"allToggle","Toggle Order",0,0,NULL`7D,
X    `7B"allScroll","Scroll Forward",0,0,NULL`7D,
X    `7B"allScrollBack","Scroll Backward",0,0,NULL`7D,
X    `7B"allSearch","Search",0,0,NULL`7D,
X    `7B"allContinue","Continue",0,0,NULL`7D,
X    `7B"allCancelSearch","Cancel Search",0,0,NULL`7D,
X`7D;
X
XButtonDefs artButtons`5B`5D = `7B
X    `7B"artQuit","Quit",0,0,NULL`7D,
X    `7B"artNext","Next",0,0,NULL`7D,
X    `7B"artNextUnread","Next Unread",0,0,NULL`7D,
X    `7B"artPrev","Prev",0,0,NULL`7D,
X    `7B"artLast","Last",0,0,NULL`7D,
X    `7B"artNextGroup","Next Group",0,0,NULL`7D,
X    `7B"artGotoArticle","Go To Article",0,0,NULL`7D,
X    `7B"artCatchUp","Catch Up",0,0,NULL`7D,
X    `7B"artCatchUpAll","Catch Up All",0,0,NULL`7D,
X    `7B"artFedUp","Fed Up",0,0,NULL`7D,
X    `7B"artMarkRead","Mark Read",0,0,NULL`7D,
X    `7B"artMarkUnread","Mark Unread",0,0,NULL`7D,
X    `7B"artUnsub","Unsubscribe",0,0,NULL`7D,
X    `7B"artScroll","Scroll Forward",0,0,NULL`7D,
X    `7B"artScrollBack","Scroll Backward",0,0,NULL`7D,
X    `7B"artScrollEnd","Scroll To End",0,0,NULL`7D,
X    `7B"artScrollBeginning","Scroll To Start",0,0,NULL`7D,
X    `7B"artSubNext","Subject Next",0,0,NULL`7D,
X    `7B"artSubPrev","Subject Prev",0,0,NULL`7D,
X    `7B"artKillSession","Session Kill",0,0,NULL`7D,
X    `7B"artKillLocal","Local Kill",0,0,NULL`7D,
X    `7B"artKillGlobal","Global Kill",0,0,NULL`7D,
X    `7B"artKillAuthor","Author Kill",0,0,NULL`7D,
X    `7B"artEditKillFile","Edit Kill File",0,0,NULL`7D,
X    `7B"artEditGlobalKillFile","Edit Global Kill File",0,0,NULL`7D,
X    `7B"artSubSearch","Subject Search",0,0,NULL`7D,
X    `7B"artAuthorSearch","Author Search",0,0,NULL`7D,
X    `7B"artContinue","Continue Search",0,0,NULL`7D,
X    `7B"artCancelSearch","Cancel Search",0,0,NULL`7D,
X    `7B"artNonSorted", "Article Order",0,0,NULL`7D,
X    `7B"artSorted","Subject Order",0,0,NULL`7D,
X    `7B"artStrictSorted","Strict Order",0,0,NULL`7D,
X    `7B"artThreadSorted","Thread Order",0,0,NULL`7D,
X    `7B"artPost","Post",0,0,NULL`7D,
X    `7B"artExit","Exit",0,0,NULL`7D,
X    `7B"artCheckPoint","CheckPoint newsrc",0,0,NULL`7D,
X    `7B"artGripe","Gripe",0,0,NULL`7D,
X    `7B"artListOld","List Old",0,0,NULL`7D,
X    `7B"artSave","Save",0,0,NULL`7D,
X    `7B"artReply","Reply",0,0,NULL`7D,
X    `7B"artForward","Forward",0,0,NULL`7D,
X    `7B"artFollowup","Followup",0,0,NULL`7D,
X    `7B"artFollowupReply","Followup and Reply",0,0,NULL`7D,
X    `7B"artCancel","Cancel",0,0,NULL`7D,
X    `7B"artRot13","Rot-13",0,0,NULL`7D,
X    `7B"artHeader","Toggle Header",0,0,NULL`7D,
X    `7B"artPrint","Print",0,0,NULL`7D,
X`7D;
XButtonDefs `09*currentButtons;
Xstatic int`09currentCount;
Xstatic int`09menuMode;
X#define addMenu 1
X#define addPop 2
X#define allMenu 3
X#define allPop 4
X#define artMenu 5
X#define artPop 6
X#define ngMenu 7
X#define ngPop 8
X
Xstatic Widget ngPulldowns`5B5`5D;
Xstatic Widget artPulldowns`5B7`5D;
Xstatic Widget allPulldowns`5B5`5D;
Xstatic Widget addPulldowns`5B3`5D;
Xstatic Widget tempPulldown;
Xstatic Widget tempMenu;
X
Xstatic Widget customDialog = NULL;
Xstatic Widget addLabel;
Xstatic Widget addScroll;
Xstatic Widget addList;
Xstatic Widget removeLabel;
Xstatic Widget removeScroll;
Xstatic Widget removeList;
Xstatic Widget okButton;
Xstatic Widget applyButton;
Xstatic Widget cancelButton;
Xstatic int AddCount = 0;
Xstatic int NgCount;
Xstatic int AllCount;
Xstatic int ArtCount;
Xstatic int ArtSpecCount;
X
Xstatic Widget readDialog = (Widget) 0;
Xstatic Widget crSubjReadButton;
Xstatic Widget crRetainKillButton;
Xstatic Widget crAuthorFullButton;
Xstatic Widget crLineCountButton;
Xstatic Widget crAutoWrapButton;
Xstatic Widget crKillButton;
Xstatic Widget crPageArtButton;
Xstatic Widget crAutoReadButton;
Xstatic Widget crWatchProgressButton;
Xstatic Widget crUpdateButton;
Xstatic Widget crOkButton;
Xstatic Widget crApplyButton;
Xstatic Widget crCancelButton;
X
Xstatic Widget postDialog = (Widget) 0;
Xstatic Widget cpLineLength;
Xstatic Widget cpWrapLength;
Xstatic Widget cpSigFile;
Xstatic Widget cpSavePost;
Xstatic Widget cpDeadLetters;
Xstatic Widget cpEditCmd;
Xstatic Widget cpOrganization;
Xstatic Widget cpReplyTo;
Xstatic Widget cpInclSepButton;
Xstatic Widget cpIncludePrefix;
Xstatic Widget cpOkButton;
Xstatic Widget cpApplyButton;
Xstatic Widget cpCancelButton;
X
Xstatic Widget mailDialog = (Widget) 0;
Xstatic Widget cmReplyPath;
Xstatic Widget cmMailer;
Xstatic Widget cmPersonal;
Xstatic Widget cmHostName;
Xstatic Widget cmCCButton;
Xstatic Widget cmOkButton;
Xstatic Widget cmApplyButton;
Xstatic Widget cmCancelButton;
X
Xstatic Widget confirmDialog = (Widget) 0;
Xstatic Widget confQuitButton;
Xstatic Widget confExitButton;
Xstatic Widget confCatchUpButton;
Xstatic Widget confArtCatchUpButton;
Xstatic Widget confUnsubButton;
Xstatic Widget confArtUnsubButton;
Xstatic Widget confArtEndButton;
Xstatic Widget confEditButton;
Xstatic Widget confOverButton;
Xstatic Widget ccSaveForm;
Xstatic Widget ccSaveRadio;
Xstatic Widget ccSaveMbxButton;
Xstatic Widget ccSaveHeadersButton;
Xstatic Widget ccSaveSubdirsButton;
Xstatic Widget ccSaveOneDirButton;
Xstatic Widget ccOkButton;
Xstatic Widget ccApplyButton;
Xstatic Widget ccCancelButton;
X
Xstatic Widget generalDialog = NULL;
Xstatic Widget cgTopLines;
Xstatic Widget cgMinLines;
Xstatic Widget cgMaxLines;
Xstatic Widget cgNNTP;
Xstatic Widget cgNewsrc;
Xstatic Widget cgSaveNewsrc;
Xstatic Widget cgTempDir;
Xstatic Widget cgSaveDir;
Xstatic Widget cgPrtCmd;
Xstatic Widget cgRescan;
Xstatic Widget cgMouseBox;
Xstatic Widget cgWhichMb2Button;
Xstatic Widget cgWhichMb3Button;
Xstatic Widget cgInfoButton;
Xstatic Widget cgOkButton;
Xstatic Widget cgApplyButton;
Xstatic Widget cgCancelButton;
X
Xstatic void makeAddMenus()
X`7B
X    int i = -1;
X    Arg cb`5B2`5D;
X    XmString label;
X
X    menuPulldown(add,File);
X`09menuBtn(add,Quit,"Exit - Unsubscribe Remaining Entries");
X    menuPulldown(add,Add);
X `09menuBtn(add,First,"Subscribe, Add At Start");
X `09menuBtn(add,Last,"Subscribe, Add At End");
X `09menuBtn(add,After,"Subscribe, Add At Custom Position");
X `09menuBtn(add,Unsub,"Unsubscribe, Add At End");
X    menuPulldown(add,Customize);
X`09subMenuPulldown(add,addNg,"Newsgroup Mode");
X`09subMenuBtn(add,ngMenus,addNgMenus,"Menu Buttons...");
X`09subMenuBtn(add,ngPopups,addNgPopups,"Popup Buttons...");
X`09subMenuPulldown(add,addArt,"Article Mode");
X`09subMenuBtn(add,artMenus,addArtMenus,"Menu Buttons...");
X`09subMenuBtn(add,artPopups,addArtPopups,"Popup Buttons...");
X`09subMenuPulldown(add,addAll,"All Groups Mode");
X`09subMenuBtn(add,allMenus,addAllMenus,"Menu Buttons...");
X`09subMenuBtn(add,allPopups,addAllPopups,"Popup Buttons...");
X`09subMenuPulldown(add,addArt,"Add Groups Mode");
X`09subMenuBtn(add,addMenus,addAddMenus,"Menu Buttons...");
X`09subMenuBtn(add,addPopups,addAddPopups,"Popup Buttons...");
X`09menuBtn(add,ConfirmCustom, "Controls...");
X`09menuBtn(add,PostCustom, "Posting...");
X`09menuBtn(add,ReadCustom, "Reading...");
X`09menuBtn(add,MailCustom, "Mailing..");
X`09menuBtn(add,General,"General...");
X`09menuBtn(add,SaveCustom,"Save Current Settings");
X`7D
X
Xstatic void makeNgMenus()
X`7B
X    int i = -1;
X    Arg cb`5B2`5D;
X    XmString label;
X
X    menuPulldown(ng,File);
X`09menuBtn(ng,Quit,"Quit");
X `09menuBtn(ng,Exit,"Quit Without Saving Changes");
X    menuPulldown(ng,Group);
X`09menuBtn(ng,Read,"Read Group");
X`09menuBtn(ng,Open,"Open Group");
X`09menuBtn(ng,CatchUp,"Catch Up Group");
X`09menuBtn(ng,Subscribe,"Subscribe");
X`09menuBtn(ng,Unsub,"Unsubscribe");
X`09menuBtn(ng,Goto,"Go To Group");
X`09menuBtn(ng,Rescan,"Rescan Server");
X`09menuBtn(ng,Disconnect,"Disconnect From Server");
X `09menuBtn(ng,CheckPoint,"Save Changes To .newsrc");
X`09menuBtn(ng,AllGroups,"View All Groups");
X `09menuBtn(ng,ToggleGroups,"Toggle Read Groups");
X    menuPulldown(ng,Move);
X`09menuBtn(ng,Select,"Select Groups To Move");
X`09menuBtn(ng,Move,"Move Selected Groups");
X    menuPulldown(ng,Send);
X    `09menuBtn(ng,Gripe,"Mail Gripe to Maintainer");
X`09menuBtn(ng,Post,"Post An Article");
X    menuPulldown(ng,Customize);
X`09subMenuPulldown(ng,ngNg,"Newsgroup Mode");
X`09subMenuBtn(ng,ngMenus,ngNgMenus,"Menu Buttons...");
X`09subMenuBtn(ng,ngPopups,ngNgPopups,"Popup Buttons...");
X`09subMenuPulldown(ng,ngArt,"Article Mode");
X`09subMenuBtn(ng,artMenus,ngArtMenus,"Menu Buttons...");
X`09subMenuBtn(ng,artPopups,ngArtPopups,"Popup Buttons...");
X`09subMenuPulldown(ng,ngAll,"All Groups Mode");
X`09subMenuBtn(ng,allMenus,ngAllMenus,"Menu Buttons...");
X`09subMenuBtn(ng,allPopups,ngAllPopups,"Popup Buttons...");
X`09subMenuPulldown(ng,ngArt,"Add Groups Mode");
X`09subMenuBtn(ng,addMenus,ngAddMenus,"Menu Buttons...");
X`09subMenuBtn(ng,addPopups,ngAddPopups,"Popup Buttons...");
X`09menuBtn(ng,ConfirmCustom, "Controls...");
X`09menuBtn(ng,PostCustom, "Posting...");
X`09menuBtn(ng,ReadCustom, "Reading...");
X`09menuBtn(ng,MailCustom, "Mailing..");
X`09menuBtn(ng,General,"General...");
X`09menuBtn(ng,SaveCustom,"Save Current Settings");
X`7D
X
Xvoid makeArtMenus()
X`7B
X    int i = -1;
X    Arg cb`5B2`5D;
X    XmString label;
X
X    menuPulldown(art,File);
X `09menuBtn(art,CheckPoint,"Save Changes To .newsrc");
X   `09menuBtn(art,Quit,"Return To Last Mode");
X `09menuBtn(art,Exit,"Return To Last Mode, Mark All Unread");
X    menuPulldown(art,Read);
X`09menuBtn(art,NextUnread,"Next Unread");
X`09menuBtn(art,SubNext,"Next With Same Subject");
X`09menuBtn(art,SubPrev,"Previous With Same Subject");
X`09menuBtn(art,Next,"Next Article");
X`09menuBtn(art,Prev,"Previous Article");
X `09menuBtn(art,Last,"Go To Last Article Read");
X    menuPulldown(art,Group);
X`09menuBtn(art,NextGroup,"Go To Next Group");
X`09menuBtn(art,CatchUp,"Catch Up");
X`09menuBtn(art,CatchUpAll,"Catch Up All Articles In This Group");
X `09menuBtn(art,FedUp,"Go To Next Group, Mark All Read");
X`09menuBtn(art,Unsub,"Unsubscribe");
X`09subMenuPulldown(art,artSort,"Article Sort Order");
X`09subMenuBtn(art,artNonSorted,artNonSorted,"Article Number Order");
X`09subMenuBtn(art,artSorted,artSorted,"Subject Sorted");
X`09subMenuBtn(art,artStrictSorted,artStrictSorted,"Strict Subject Sorted");
X`09subMenuBtn(art,artThreadSorted,artThreadSorted,"Thread Sorted");
X
X    menuPulldown(art,Article);
X`09menuBtn(art,GotoArticle,"Go To Article");
X`09menuBtn(art,MarkRead,"Mark Selected Articles Read");
X`09menuBtn(art,MarkUnread,"Mark Selected Articles Unread");
X`09menuBtn(art,Post,"Post New Article");
X`09menuBtn(art,Print,"Print Article");
X`09menuBtn(art,Save,"Save Article");
X `09menuBtn(art,Reply,"Mail Reply To Article");
X `09menuBtn(art,Forward,"Forward Article");
X `09menuBtn(art,Followup,"Post Followup To Article");
X `09menuBtn(art,FollowupReply,"Followup And Reply To Article");
X `09menuBtn(art,Rot13,"Encode/Decode Article");
X`09menuBtn(art,Header,"Toggle Full/Stripped Header");
X        menuBtn(art,ListOld,"List All Articles");
X `09menuBtn(art,Gripe,"Mail Gripe To Maintainer");
X    menuPulldown(art,Kill);
X`09menuBtn(art,KillSession,"This Session Only");
X`09menuBtn(art,KillLocal,"This Group Only");
X`09menuBtn(art,KillGlobal,"All Groups");
X`09menuBtn(art,KillAuthor,"All Articles With This Author");
X`09menuBtn(art,EditKillFile,"Edit This Group's Kill File");
X`09menuBtn(art,EditGlobalKillFile,"Edit The Global Kill File");
X    menuPulldown(art,Search);
X`09menuBtn(art,SubSearch,"Subject Search");
X`09menuBtn(art,AuthorSearch,"Author Search");
X`09menuBtn(art,Continue,"Continue Search");
X`09menuBtn(art,CancelSearch,"Cancel Search");
X    menuPulldown(art,Customize);
X`09subMenuPulldown(art,artNg,"Newsgroup Mode");
X`09subMenuBtn(art,ngMenus,artNgMenus,"Menu Buttons...");
X`09subMenuBtn(art,ngPopups,artNgPopups,"Popup Buttons...");
X`09subMenuPulldown(art,artArt,"Article Mode");
X`09subMenuBtn(art,artMenus,artArtMenus,"Menu Buttons...");
X`09subMenuBtn(art,artPopups,artArtPopups,"Popup Buttons...");
X`09subMenuPulldown(art,artAll,"All Groups Mode");
X`09subMenuBtn(art,allMenus,artAllMenus,"Menu Buttons...");
X`09subMenuBtn(art,allPopups,artAllPopups,"Popup Buttons...");
X`09subMenuPulldown(art,artArt,"Add Groups Mode");
X`09subMenuBtn(art,addMenus,artAddMenus,"Menu Buttons...");
X`09subMenuBtn(art,addPopups,artAddPopups,"Popup Buttons...");
X`09menuBtn(art,ConfirmCustom, "Controls...");
X`09menuBtn(art,PostCustom, "Posting...");
X`09menuBtn(art,ReadCustom, "Reading...");
X`09menuBtn(art,MailCustom, "Mailing..");
X`09menuBtn(art,General,"General...");
X`09menuBtn(art,SaveCustom,"Save Current Settings");
X`7D
Xvoid makeArtArtMenus(ArtMenuBar)
XWidget ArtMenuBar;
X`7B
X    int i = -1;
X    Widget TempMenuBar;
X    Widget saveArtPulldowns`5B7`5D;
X    Widget saveArtMenus`5B7`5D;
X
X    TempMenuBar = MenuBar;
X    MenuBar = ArtMenuBar;
X    for (i = 0; i < XtNumber(artPulldowns); i++) `7B
X`09saveArtPulldowns`5Bi`5D = artPulldowns`5Bi`5D;
X`09saveArtMenus`5Bi`5D = artMenus`5Bi`5D;
X    `7D
X    makeArtMenus();
X    MenuBar = TempMenuBar;
X    for (i = 0; i < XtNumber(artPulldowns); i++) `7B
X`09XtManageChild(artMenus`5Bi`5D);
X`09artPulldowns`5Bi`5D = saveArtPulldowns`5Bi`5D;
X`09artMenus`5Bi`5D = saveArtMenus`5Bi`5D;
X    `7D
X`7D
Xstatic void makeAllMenus()
X`7B
X    int i = -1;
X    Arg cb`5B2`5D;
X    XmString label;
X
X    menuPulldown(all,File);
X`09menuBtn(all,Quit,"Return To Newsgroup Mode");
X`09menuBtn(all,Goto,"Go To Group");
X`09menuBtn(all,Goto,"Open Group");
X    menuPulldown(all,Subscribe);
X`09menuBtn(all,Sub,"Subscribe");
X`09menuBtn(all,First,"Subscribe, Move To Start");
X`09menuBtn(all,Last,"Subscribe, Move To End");
X`09menuBtn(all,After,"Subscribe, Move To Custom Position");
X`09menuBtn(all,Unsub,"Unsubscribe");
X    menuPulldown(all,Move);
X`09menuBtn(all,Select,"Select Groups To Move");
X`09menuBtn(all,Move,"Move Groups");
X`09menuBtn(all,Toggle,"Toggle .newsrc/Alphabetical Order");
X    menuPulldown(all,Search);
X`09menuBtn(all,Search,"Search For Group");
X        menuBtn(all,Continue,"Continue Search");
X        menuBtn(all,CancelSearch,"Cancel Search");
X    menuPulldown(all,Customize);
X`09subMenuPulldown(all,allNg,"Newsgroup Mode");
X`09subMenuBtn(all,ngMenus,allNgMenus,"Menu Buttons...");
X`09subMenuBtn(all,ngPopups,allNgPopups,"Popup Buttons...");
X`09subMenuPulldown(all,allArt,"Article Mode");
X`09subMenuBtn(all,artMenus,allArtMenus,"Menu Buttons...");
X`09subMenuBtn(all,artPopups,allArtPopups,"Popup Buttons...");
X`09subMenuPulldown(all,allAll,"All Groups Mode");
X`09subMenuBtn(all,allMenus,allAllMenus,"Menu Buttons...");
X`09subMenuBtn(all,allPopups,allAllPopups,"Popup Buttons...");
X`09subMenuPulldown(all,allArt,"Add Groups Mode");
X`09subMenuBtn(all,addMenus,allAddMenus,"Menu Buttons...");
X`09subMenuBtn(all,addPopups,allAddPopups,"Popup Buttons...");
X`09menuBtn(all,ConfirmCustom, "Controls...");
X`09menuBtn(all,PostCustom, "Posting...");
X`09menuBtn(all,ReadCustom, "Reading...");
X`09menuBtn(all,MailCustom, "Mailing..");
X`09menuBtn(all,General,"General...");
X`09menuBtn(all,SaveCustom,"Save Current Settings");
X`7D
X
Xvoid
XmakeMenus()
X`7B
X
X    AddCount = AddPopupCount;`09`09`09`09/* store original counters */
X    NgCount = NgPopupCount;
X    AllCount = AllPopupCount;
X    ArtCount = ArtPopupCount;
X    ArtSpecCount = ArtSpecPopupCount;
X    font = XLoadQueryFont(XtDisplay(TopLevel),
X`09"-*-Menu-Medium-R-Normal--*-120-*-*-M-*");
X    if (font == NULL) `7B
X        font = XLoadQueryFont(XtDisplay(TopLevel),
X`09    "-*-Helvetica-Bold-R-Normal--*-120-*");
X`09if (font == NULL) `7B
X`09    font = XLoadQueryFont(XtDisplay(TopLevel),
X`09`09"-*-*-Bold-R-Normal--*-120-*");
X`09    if (font == NULL) `7B
X`09`09font = XLoadQueryFont(XtDisplay(TopLevel),"fixed");
X`09    `7D
X        `7D
X    `7D
X    if (font == NULL) `7B
X`09printf("Can't find any fonts!");
X`09exit(0);
X    `7D
X#ifdef MOTIF
X    fontList = XmFontListCreate(font, XmSTRING_DEFAULT_CHARSET);
X#else
X    fontList = DwtCreateFontList(font, 1); /* ISO_LATIN1 */
X#endif
X
X    makeAddMenus();
X    makeNgMenus();
X    makeArtMenus();
X    makeAllMenus();
X
X`7D
Xstatic Widget popup_menu;
X
X#ifdef MOTIF
Xstatic XtEventHandler
Xpop_up(widget, closure, event, dispatch)
XWidget widget;
XXtPointer closure;
XXButtonEvent *event;
XBoolean *dispatch;
X`7B
X    if (event->button != app_resources.popupButton)
X`09return;
X
X    if (!XtIsRealized(popup_menu))
X`09XtRealizeWidget(popup_menu);
X
X    XmMenuPosition(popup_menu, event);
X    XtManageChild(popup_menu);
X`7D
X#else /* MOTIF */
Xstatic void
Xpop_up(widget, event, params, num_params)
XWidget`09widget;
XXButtonEvent *event;
Xchar`09*params;
Xint`09num_params;
X`7B
X    if (event->button != app_resources.popupButton)
X`09return;
X
X    if (!XtIsRealized(popup_menu))
X`09XtRealizeWidget(popup_menu);
X
X    DwtMenuPosition(popup_menu, event);
X    XtManageChild(popup_menu);
X`7D
Xstatic void motionhint(m,closure,event)
X    MenuWidget m;
X    Opaque closure;
X    XPointerMovedEvent *event;
X`7B
X    if (event->is_hint == NotifyHint) `7B
X`09if (event->state & Button1Mask `7C`7C event->state & Button2Mask `7C`7C
X`09`09event->state & Button3Mask) `7B
X`09    event->state `7C= Button2Mask;`09/* hack in MB2 for XUI */
X`09`7D
X    `7D
X`7D`09   `20
X#endif /* MOTIF */
X
Xstatic char popup2Trans`5B`5D = "<Btn2Down>:pop_up()";
Xstatic char popup3Trans`5B`5D = "<Btn3Down>:pop_up()";
X
Xstatic XtTranslations popupParsed;
X
Xstatic XtActionsRec popupAction`5B`5D = `7B
X    `7B"pop_up", (XtActionProc)pop_up`7D,
X`7D;
Xexternalref XtCallbackRec artSubNextCallbacks`5B`5D;
Xexternalref XtCallbackRec artQuitCallbacks`5B`5D;
X
Xvoid makePopup(parent)
XWidget`09parent;
X`7B
X    Arg args`5B10`5D;
X    Widget pop;
X    int i;
X
X    if (AddCount == 0) `7B
X`09AddCount = AddPopupCount;`09`09/* store original counters */
X`09NgCount = NgPopupCount;
X`09AllCount = AllPopupCount;
X`09ArtCount = ArtPopupCount;
X`09ArtSpecCount = ArtSpecPopupCount;
X    `7D else `7B
X`09AddPopupCount = AddCount;`09`09/* restore original counters */
X`09NgPopupCount = NgCount;
X`09AllPopupCount = AllCount;
X`09ArtPopupCount = ArtCount;
X`09ArtSpecPopupCount = ArtSpecCount;
X    `7D
X#ifndef MOTIF
X    XtAddActions(popupAction, XtNumber(popupAction));
X    if (app_resources.popupButton == 3) `7B
X`09popupParsed = XtParseTranslationTable(popup3Trans);
X    `7D else `7B
X`09popupParsed = XtParseTranslationTable(popup2Trans);
X    `7D
X    XtOverrideTranslations(parent, popupParsed);
X
X    if (app_resources.popupButton == 2) `7B
X`09popup_menu = DwtMenuPopupCreate(parent,"popup", NULL, 0);
X    `7D else `7B
X`09i = 0;
X`09XtSetArg(args`5Bi`5D, DwtNwidth, 5);i++;
X`09XtSetArg(args`5Bi`5D, DwtNheight, 5);i++;
X`09XtSetArg(args`5Bi`5D, XtNallowShellResize, True);i++;
X`09XtSetArg(args`5Bi`5D, XtNoverrideRedirect, True);i++;
X`09pop = XtCreatePopupShell("popShell", menupopupWidgetClass,`20
X`09`09`09`09 parent, args, i);
X`09i = 0;
X`09XtSetArg(args`5Bi`5D, DwtNmenuType, DwtMenuPopup);i++;
X`09popup_menu = XtCreateWidget("popup", menuwidgetclass, pop, args, i);
X`09XGrabButton(`09`09`09/* Do a grab for the button */
X`09    XtDisplay(popup_menu),`09/* event that pops the menu up */
X`09    app_resources.popupButton,`09/* for the parent of the shell */
X`09    AnyModifier,`09`09/* widget */
X`09    XtWindow(parent),
X`09    True,
X`09    ButtonReleaseMask `7C PointerMotionHintMask,
X`09    GrabModeAsync,
X`09    GrabModeAsync,
X`09    None,
X`09    None);
X        XtAddEventHandler(popup_menu, PointerMotionHintMask`7CButtonMotionMa
Vsk,
X`09`09FALSE, motionhint, NULL);
X    `7D
X#else
X    if (app_resources.popupButton == 2) `7B
X`09XtSetArg(args`5B0`5D, XmNwhichButton, Button2);
X    `7D else `7B
X`09XtSetArg(args`5B0`5D, XmNwhichButton, Button3);
X    `7D
X    popup_menu = XmCreatePopupMenu(parent, "popup", args, 1);
X    XtAddEventHandler(parent, ButtonPressMask, False, (XtEventHandler) pop_u
Vp,
X`09`09`09popup_menu);
X#endif
X    AddPopupButtons = ARRAYALLOC(Widget, AddPopupCount);
X    doPopups(app_resources.addPopupList, popup_menu, AddPopupButtons,
X`09`09AddButtonList, &AddPopupCount);
X
X    NgPopupButtons = ARRAYALLOC(Widget, NgPopupCount);
X    doPopups(app_resources.ngPopupList, popup_menu, NgPopupButtons,
X`09`09NgButtonList, &NgPopupCount);
X
X    AllPopupButtons = ARRAYALLOC(Widget, AllPopupCount);
X    doPopups(app_resources.allPopupList, popup_menu, AllPopupButtons,
X`09`09AllButtonList, &AllPopupCount);
X
X    ArtPopupButtons = ARRAYALLOC(Widget, ArtPopupCount);
X    doPopups(app_resources.artPopupList, popup_menu, ArtPopupButtons,
X`09`09ArtButtonList, &ArtPopupCount);
X`7D
X
Xvoid makeArtPopup(parent)
XWidget`09parent;
X`7B
X    Arg args`5B10`5D;
X    Widget pop;
X    int i;
X
X    if (!app_resources.twoWindows) return;
X    ArtWinPopupCount = ArtCount;
X#ifndef MOTIF
X    XtOverrideTranslations(parent, popupParsed);
X
X    if (app_resources.popupButton == 2) `7B
X`09popup_menu = DwtMenuPopupCreate(parent,"popup", NULL, 0);
X    `7D else `7B
X`09i = 0;
X`09XtSetArg(args`5Bi`5D, DwtNwidth, 5);i++;
X`09XtSetArg(args`5Bi`5D, DwtNheight, 5);i++;
X`09XtSetArg(args`5Bi`5D, XtNallowShellResize, True);i++;
X`09XtSetArg(args`5Bi`5D, XtNoverrideRedirect, True);i++;
X`09pop = XtCreatePopupShell("popShell", menupopupWidgetClass,`20
X`09`09`09`09 parent, args, i);
X`09i = 0;
X`09XtSetArg(args`5Bi`5D, DwtNmenuType, DwtMenuPopup);i++;
X`09popup_menu = XtCreateWidget("popup", menuwidgetclass, pop, args, i);
X`09XGrabButton(`09`09`09/* Do a grab for the button */
X`09    XtDisplay(popup_menu),`09/* event that pops the menu up */
X`09    app_resources.popupButton,`09/* for the parent of the shell */
X`09    AnyModifier,`09`09/* widget */
X`09    XtWindow(parent),
X`09    True,
X`09    ButtonReleaseMask `7C PointerMotionHintMask,
X`09    GrabModeAsync,
X`09    GrabModeAsync,
X`09    None,
X`09    None);
X        XtAddEventHandler(popup_menu, PointerMotionHintMask`7CButtonMotionMa
Vsk,
X`09`09FALSE, motionhint, NULL);
X    `7D
X#else
X    if (app_resources.popupButton == 2) `7B
X`09XtSetArg(args`5B0`5D, XmNwhichButton, Button2);
X    `7D else `7B
X`09XtSetArg(args`5B0`5D, XmNwhichButton, Button3);
X    `7D
X    popup_menu = XmCreatePopupMenu(parent, "popup", args, 1);
X    XtAddEventHandler(parent, ButtonPressMask, False, (XtEventHandler) pop_u
Vp,
X`09`09`09popup_menu);
X#endif
X    ArtWinPopupButtons = ARRAYALLOC(Widget, ArtWinPopupCount);
X    doPopups(app_resources.artPopupList, popup_menu, ArtWinPopupButtons,
X`09ArtButtonList, &ArtWinPopupCount);
X`7D
X
Xstatic void
XdoPopups(resource, box, buttons, buttonList, size)
Xchar *resource;
XWidget box;
XWidget *buttons;
XButtonList *buttonList;
Xint *size;
X`7B
X    char *ptr, *token, *savePtr;
X    int j, i = 0;
X
X    if (resource) `7B
X`09savePtr = ptr = XtNewString(resource);
X
X`09while ((token = strtok(ptr, ", \t\n")) != NIL(char)) `7B
X`09    /* find name */
X`09    for (j = 0; j < *size; j++) `7B
X`09`09if (STREQ(token, (char *) buttonList`5Bj`5D.buttonArgs`5B0`5D.value))
V `7B
X#ifdef MOTIF
X`09`09    if (buttonList`5Bj`5D.buttonArgs`5B1`5D.value == (XtArgVal) NULL)
V `7B
X`09`09`09buttonList`5Bj`5D.buttonArgs`5B1`5D.value =
X`09`09`09    (XtArgVal)XmStringLtoRCreate(
X`09`09`09`09buttonList`5Bj`5D.label, XmSTRING_DEFAULT_CHARSET);
X`09`09    `7D
X`09`09    buttons`5Bi`5D = XmCreatePushButtonGadget(box,
X`09`09`09`09    (char *)buttonList`5Bj`5D.buttonArgs`5B0`5D.value,
X`09`09`09`09    buttonList`5Bj`5D.buttonArgs,
X`09`09`09`09    buttonList`5Bj`5D.size);
X#else
X`09`09    if (buttonList`5Bj`5D.buttonArgs`5B1`5D.value == NULL) `7B
X`09`09`09buttonList`5Bj`5D.buttonArgs`5B1`5D.value =
X`09`09`09    (XtArgVal)DwtLatin1String(buttonList`5Bj`5D.label);
X`09`09    `7D
X`09`09    buttons`5Bi`5D = DwtPushButtonGadgetCreate(box,
X`09`09`09`09    (char *) buttonList`5Bj`5D.buttonArgs`5B0`5D.value,
X`09`09`09`09    buttonList`5Bj`5D.buttonArgs,
X`09`09`09`09    buttonList`5Bj`5D.size);
X#endif
X`09`09    i++;
X`09`09    break;
X`09`09`7D
X`09    `7D
X`09    if (j == *size && buttonList == ArtButtonList) `7B
X`09`09for (j = 0; j < ArtSpecButtonListCount; j++) `7B
X`09`09    if (STREQ(token,
X`09`09`09(char *) ArtSpecButtonList`5Bj`5D.buttonArgs`5B0`5D.value)) `7B
X#ifdef MOTIF
X`09`09`09if (ArtSpecButtonList`5Bj`5D.buttonArgs`5B1`5D.value == (XtArgVal)
V NULL) `7B
X`09`09    `09    ArtSpecButtonList`5Bj`5D.buttonArgs`5B1`5D.value =
X`09`09`09        (XtArgVal)XmStringLtoRCreate(
X`09`09`09    ArtSpecButtonList`5Bj`5D.label, XmSTRING_DEFAULT_CHARSET);
X`09`09`09`7D
X`09`09    `09buttons`5Bi`5D = XmCreatePushButtonGadget(box,
X`09`09`09    (char *)ArtSpecButtonList`5Bj`5D.buttonArgs`5B0`5D.value,
X`09`09`09    ArtSpecButtonList`5Bj`5D.buttonArgs,
X`09`09`09    ArtSpecButtonList`5Bj`5D.size);
X#else
X`09`09`09if (ArtSpecButtonList`5Bj`5D.buttonArgs`5B1`5D.value == NULL) `7B
X`09`09    `09   ArtSpecButtonList`5Bj`5D.buttonArgs`5B1`5D.value =
X`09`09`09      (XtArgVal)DwtLatin1String(ArtSpecButtonList`5Bj`5D.label);
X`09`09`09`7D
X`09`09    `09buttons`5Bi`5D = DwtPushButtonGadgetCreate(box,
X`09`09`09    (char *)ArtSpecButtonList`5Bj`5D.buttonArgs`5B0`5D.value,
X`09`09`09    ArtSpecButtonList`5Bj`5D.buttonArgs,
X`09`09`09    ArtSpecButtonList`5Bj`5D.size);
X#endif
X`09`09    `09i++;
X`09`09    `09break;
X`09`09    `7D
X`09        `7D
X`09`09if (j == ArtSpecButtonListCount) `7B
X`09`09    j = *size;
X`09`09`7D
X`09    `7D
X`09    if (j == *size) `7B
X`09`09mesgPane(XRN_SERIOUS, "XRN error: bad button name: %s", token);
X`09    `7D
X`09    ptr = NIL(char);
X`09`7D
X`09*size = i;
X`09XtFree(savePtr);
X`09
X    `7D else `7B
X`09for (i = 0; i < *size; i++) `7B
X`09   `20
X#ifdef MOTIF
X`09    if (buttonList`5Bi`5D.buttonArgs`5B1`5D.value == (XtArgVal) NULL) `7B
X`09        buttonList`5Bi`5D.buttonArgs`5B1`5D.value =
X`09    `09    (XtArgVal) XmStringLtoRCreate(buttonList`5Bi`5D.label,
X`09`09`09`09XmSTRING_DEFAULT_CHARSET);
X`09    `7D
X`09    buttons`5Bi`5D = XmCreatePushButtonGadget(box,
X`09`09`09`09(char *) buttonList`5Bi`5D.buttonArgs`5B0`5D.value,
X`09`09`09`09buttonList`5Bi`5D.buttonArgs,
X`09`09`09`09buttonList`5Bi`5D.size);
X#else
X`09    if (buttonList`5Bi`5D.buttonArgs`5B1`5D.value == NULL) `7B
X`09`09buttonList`5Bi`5D.buttonArgs`5B1`5D.value =
X`09    `09    (XtArgVal)DwtLatin1String(buttonList`5Bi`5D.label);
X`09    `7D
X`09    buttons`5Bi`5D = DwtPushButtonGadgetCreate(box,
X`09`09`09`09(char *)buttonList`5Bi`5D.buttonArgs`5B0`5D.value,
X`09`09`09`09buttonList`5Bi`5D.buttonArgs,
X`09`09`09`09buttonList`5Bi`5D.size);
X#endif
X`09`7D
X    `7D
X    return;
X`7D
Xvoid
XresetPopupSize()
X`7B
X#ifndef MOTIF
X    static Arg popupResizeArg`5B`5D = `7B
X`09`7BDwtNheight, 0`7D,
X    `7D;
X    XtSetValues(popup_menu, popupResizeArg, XtNumber(popupResizeArg));
X#endif
X`7D
X
Xstatic void makeGeneralMenu()
X`7B
X    Arg arg`5B20`5D;
X    int i;
X    XmString str;
X
X    i = 0;
X#ifdef MOTIF
X    str = XmStringLtoRCreate("mxrn: Customize/General",XmSTRING_DEFAULT_CHAR
VSET);
X#else
X    str = DwtLatin1String("dxrn: Customize/General");
X#endif
X    XtSetArg(arg`5Bi`5D, XmNborderWidth, `091);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNautoUnmanage,`09False);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNfractionBase,`0960);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNresizePolicy,`09XmRESIZE_GROW);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNfontList,`09fontList);`09i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNunitType,`09Xm100TH_FONT_UNITS);i++;
X    XtSetArg(arg`5Bi`5D, XmNdialogStyle,`09XmDIALOG_APPLICATION_MODAL);i++;
X#ifdef MOTIF_V10
X    XtSetArg(arg`5Bi`5D, XmNwidth,`09`09620*16);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNheight,`09`09420*16);`09i++;
X#endif
X#else
X    XtSetArg(arg`5Bi`5D, DwtNunits,`09`09DwtPixelUnits);`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNwidth,`09`09620);`09`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNheight,`09420);`09`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNdialogTitle,`09str);`09`09i++;
X    generalDialog = XmCreateFormDialog(TopLevel, "generalCustom",arg,i);
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Top Lines", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`094);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`094);`09`09i++;
X    XtManageChild(
X`09XmCreateLabel(generalDialog, "topLinesLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`095);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0919);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`093);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment, XmATTACH_NONE);i++;
X    XtManageChild(
X`09cgTopLines = XmCreateText(generalDialog, "topLines", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("Min Lines", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0927);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`094);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment, XmATTACH_NONE);i++;
X    XtManageChild(
X`09XmCreateLabel(generalDialog, "minLinesLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`095);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0936);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`093);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment, XmATTACH_NONE);i++;
X    XtManageChild(
X`09cgMinLines = XmCreateText(generalDialog, "minLines", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("Max Lines", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0943);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`094);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment, XmATTACH_NONE);i++;
X    XtManageChild(
X`09XmCreateLabel(generalDialog, "maxLinesLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`095);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0952);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`093);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment, XmATTACH_NONE);i++;
X    XtManageChild(
X`09cgMaxLines = XmCreateText(generalDialog, "maxLines", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("NNTP Server", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`094);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`099);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment, XmATTACH_NONE);i++;
X    XtManageChild(
X`09XmCreateLabel(generalDialog, "nntpServerLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`0940);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0919);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`098);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment, XmATTACH_NONE);i++;
X    XtManageChild(
X`09cgNNTP = XmCreateText(generalDialog, "nntpServer", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("Newsrc File", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`094);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0914);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment, XmATTACH_NONE);i++;
X    XtManageChild(
X`09XmCreateLabel(generalDialog, "newsrcFileLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`0940);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0919);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0913);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment, XmATTACH_NONE);i++;
X    XtManageChild(
X`09cgNewsrc = XmCreateText(generalDialog, "newsrcFile", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("Saved Newsrc File", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`094);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0919);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment, XmATTACH_NONE);i++;
X    XtManageChild(
X`09XmCreateLabel(generalDialog, "saveNewsrcLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`0940);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0919);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0918);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment, XmATTACH_NONE);i++;
X    XtManageChild(
X`09cgSaveNewsrc = XmCreateText(generalDialog, "saveNewsrc", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("Temp Directory", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`094);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0924);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment, XmATTACH_NONE);i++;
X    XtManageChild(
X`09XmCreateLabel(generalDialog, "tempDirLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`0940);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0919);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0923);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment, XmATTACH_NONE);i++;
X    XtManageChild(
X`09cgTempDir = XmCreateText(generalDialog, "tempDir", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("Save Directory", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`094);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0929);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment, XmATTACH_NONE);i++;
X    XtManageChild(
X`09XmCreateLabel(generalDialog, "saveDirLabel", arg, i));`09    /* ggh */
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`0940);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0919);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0928);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment, XmATTACH_NONE);i++;
X    XtManageChild(
X`09cgSaveDir = XmCreateText(generalDialog, "saveDir", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("Print Command", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`094);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0934);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment, XmATTACH_NONE);i++;
X    XtManageChild(
X`09XmCreateLabel(generalDialog, "printCommandLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`0940);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0919);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0933);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment, XmATTACH_NONE);i++;
X    XtManageChild(
X`09cgPrtCmd= XmCreateText(generalDialog, "printCommand", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("Rescan Time", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`094);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0939);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment, XmATTACH_NONE);i++;
X    XtManageChild(
X`09XmCreateLabel(generalDialog, "rescanTimeLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`095);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0919);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0938);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment, XmATTACH_NONE);i++;
X    XtManageChild(
X`09cgRescan = XmCreateText(generalDialog, "rescanTime", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("Popup Menu Button", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0927);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0939);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment, XmATTACH_NONE);i++;
X    XtManageChild(
X`09XmCreateLabel(generalDialog, "popupMenuLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNborderWidth,`0925);`09`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0944);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0938);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNorientation, `09XmHORIZONTAL);`09i++;
X#ifdef MOTIF_V10
X    XtSetArg(arg`5Bi`5D, XmNentryClass, `09xmToggleButtonWidgetClass);i++;
X#endif
X    XtManageChild(
X`09cgMouseBox = XmCreateRadioBox(generalDialog, "mouseBox", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("MB2", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09i++;
X    XtManageChild(
X`09cgWhichMb2Button = XmCreateToggleButton(cgMouseBox, "whichMb2", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("MB3", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09i++;
X    XtManageChild(
X`09cgWhichMb3Button = XmCreateToggleButton(cgMouseBox, "whichMb2", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Display Informational Messages in Message Wind
Vow",
X`09`09`09`09XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0947);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`094);`09`09i++;
X    XtManageChild(
X`09cgInfoButton = XmCreateToggleButton(generalDialog, "infoMsgs", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("OK", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`096);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_NONE);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`09100);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNshowAsDefault,`09True);`09`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`0920);`09`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNactivateCallback,cgOKCallback); i++;
X    XtManageChild(
X`09cgOkButton = XmCreatePushButton(generalDialog, "cgokButton", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Apply", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNactivateCallback,cgApplyCallback);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0923);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_NONE);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`09144);`09`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`0922);`09`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNfontList,`09fontList);`09i++;
X    XtManageChild(
X`09cgApplyButton = XmCreatePushButton(generalDialog, "cgapplyButton",
X`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Cancel", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNactivateCallback,cgCancelCallback);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0942);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_NONE);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`09144);`09`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`0922);`09`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNfontList,`09fontList);`09i++;
X    XtManageChild(
X`09cgCancelButton = XmCreatePushButton(generalDialog, "cgcancelButton",
X`09`09arg,i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNdefaultButton, cgOkButton);i++;
X    XtSetArg(arg`5Bi`5D, XmNcancelButton,  cgCancelButton);i++;
X    XtSetValues(generalDialog, arg, i);
X
X#ifndef MOTIF_V10
X    i = 0;
X    str = XmStringLtoRCreate(" ", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString, `09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09cgPrtCmd);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopWidget,`09cgMouseBox);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_FORM);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightOffset,`0966);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNx,`09`096000);`09`09i++;`20
X    XtSetArg(arg`5Bi`5D, XmNy,`09`096000);`09`09i++;`20
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`091411);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`0928);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`0999);`09`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNx,`09`0960);`09`09i++;`20
X    XtSetArg(arg`5Bi`5D, XmNy,`09`0960);`09`09i++;`20
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`0914);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`091);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`091);`09`09i++;
X#endif
X
X    XtManageChild(
X`09XmCreateLabel(generalDialog, "dummyLabel", arg, i));
X    XmStringFree(str);
X#endif
X`7D
Xstatic void makeConfirmMenu()
X`7B
X    Arg arg`5B20`5D;
X    int i;
X    XmString str;
X
X    i = 0;
X#ifdef MOTIF
X    str = XmStringLtoRCreate("mxrn: Customize/Confirm",XmSTRING_DEFAULT_CHAR
VSET);
X#else
X    str = DwtLatin1String("dxrn: Customize/Confirm");
X#endif
X    XtSetArg(arg`5Bi`5D, XmNborderWidth, `091);`09`09i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNunitType,`09Xm100TH_FONT_UNITS);i++;
X    XtSetArg(arg`5Bi`5D, XmNdialogStyle,`09XmDIALOG_APPLICATION_MODAL);i++;
X#ifdef MOTIF_V10
X    XtSetArg(arg`5Bi`5D, XmNwidth,`09`09650*16);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNheight,`09`09410*16);`09`09i++;
X#endif
X#else
X    XtSetArg(arg`5Bi`5D, DwtNunits,`09`09DwtFontUnits);`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNwidth,`09`09650);`09`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNheight,`09410);`09`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNautoUnmanage,`09False);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNresizePolicy,`09XmRESIZE_GROW);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNfractionBase,`0960);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNfontList,`09fontList);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNdialogTitle,`09str);`09`09i++;
X    confirmDialog = XmCreateFormDialog(TopLevel, "generalConfirm",arg,i);
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Confirm Quit", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION); i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION); i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`095);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`093);`09`09i++;
X    XtManageChild(
X`09confQuitButton = XmCreateToggleButton(confirmDialog, "confQuit",
X`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Confirm Exit", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0936);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`093);`09i++;
X    XtManageChild(
X`09confExitButton = XmCreateToggleButton(confirmDialog, "confQuit",
X`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Confirm NG Catch Up", XmSTRING_DEFAULT_CHARSET
V);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_OPPOSITE_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,  XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09confQuitButton);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0910);`09i++;
X    XtManageChild(
X`09confCatchUpButton = XmCreateToggleButton(confirmDialog, "confCatchUp",
X`09`09`09`09`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Confirm Article Catch Up", XmSTRING_DEFAULT_CH
VARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_OPPOSITE_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09confExitButton);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0910);`09i++;
X    XtManageChild(
X`09confArtCatchUpButton = XmCreateToggleButton(confirmDialog,
X`09`09"confArtCatchUp", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Confirm NG Unsubscribe", XmSTRING_DEFAULT_CHAR
VSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_OPPOSITE_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09confCatchUpButton);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0917);`09i++;
X    XtManageChild(
X`09confUnsubButton = XmCreateToggleButton(confirmDialog, "confUnsub",
X`09`09`09`09`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Confirm Article Unsubscribe", XmSTRING_DEFAULT
V_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_OPPOSITE_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09confArtCatchUpButton);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0917);`09i++;
X    XtManageChild(
X`09confArtUnsubButton = XmCreateToggleButton(confirmDialog,
X`09`09"confArtUnsub", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Action Prompt At Subject Change",
X`09XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_OPPOSITE_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09confUnsubButton);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0924);`09i++;
X    XtManageChild(
X`09confArtEndButton = XmCreateToggleButton(confirmDialog, "confArtEnd",
X`09`09`09`09`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Confirm Save file Overwrite",
X`09`09XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_OPPOSITE_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09confArtUnsubButton);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0924);`09i++;
X    XtManageChild(
X`09confOverButton = XmCreateToggleButton(confirmDialog, "confOver",
X`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Prompt Before Posting After Editor Exits",
X`09XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_OPPOSITE_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09confArtEndButton);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0931);`09i++;
X    XtManageChild(
X`09confEditButton = XmCreateToggleButton(confirmDialog, "confEdit",
X`09`09`09`09`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_FORM);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_FORM);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0937);i++;
X    XtManageChild(
X`09XmCreateSeparator(confirmDialog, "saveSep", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("Save Mode", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0939);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0924);`09i++;
X    XtManageChild(
X`09XmCreateLabel(confirmDialog, "saveModeLabel", arg, i));
X    XmStringFree(str);
X
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNborderWidth,`0925);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNresizePolicy,`09XmRESIZE_GROW);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0944);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`095);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightPosition,  55);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNunitType,`09Xm100TH_FONT_UNITS);i++;
X
X    XtManageChild(
X`09ccSaveForm = XmCreateForm(confirmDialog, "saveForm", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("Mailbox", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`095);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0925);`09i++;
X    XtManageChild(
X`09ccSaveMbxButton = XmCreateToggleButton(ccSaveForm, "ccSaveMbx",
X`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Headers", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0924);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0925);`09i++;
X    XtManageChild(
X`09ccSaveHeadersButton = XmCreateToggleButton(ccSaveForm, "ccSaveHeaders",
X`09`09`09`09`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X
X    XtSetArg(arg`5Bi`5D, XmNborderWidth,`0925);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNorientation,`09XmHORIZONTAL);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_FORM);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0950);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNradioAlwaysOne, False); i++;
X#ifdef MOTIF_V10
X    XtSetArg(arg`5Bi`5D, XmNentryClass, `09xmToggleButtonWidgetClass);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`0920);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`0920);`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`09200);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`09200);`09i++;
X#endif
X    XtManageChild(
X`09ccSaveRadio = XmCreateRadioBox(ccSaveForm, "saveRadio", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("Subdirectory", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtManageChild(
X`09ccSaveSubdirsButton = XmCreateToggleButton(ccSaveRadio, "saveSubdirs",
X`09`09`09`09`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("One Directory", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtManageChild(
X`09ccSaveOneDirButton = XmCreateToggleButton(ccSaveRadio, "saveOneDir",
X`09`09`09`09`09`09arg, i));
X    XmStringFree(str);
X
X#else /* MOTIF */
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, DwtNborderWidth,`091);`09`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNx,`09`09165);`09`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNy,`09`09425);`09`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNorientation,`09DwtOrientationHorizontal);`09i++
V;
X    XtSetArg(arg`5Bi`5D, DwtNmenuIsHomogeneous,False);`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNfont,`09`09fontList);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0937);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`095);`09i++;
X    XtManageChild(ccSaveForm =
X`09DwtMenuCreate(confirmDialog, "saveBox", arg,i)
X`09);
X
X    i = 0;
X    str = DwtLatin1String("Mailbox");
X    XtSetArg(arg`5Bi`5D, DwtNlabel,`09`09str);`09i++;
X    XtManageChild(
X`09ccSaveMbxButton = DwtToggleButtonCreate(ccSaveForm, "ccSaveMbx",
X`09`09arg, i));
X    XtFree(str);
X
X    i = 0;
X    str = DwtLatin1String("Headers");
X    XtSetArg(arg`5Bi`5D, DwtNlabel,`09`09str);`09i++;
X    XtManageChild(
X`09ccSaveHeadersButton = DwtToggleButtonCreate(ccSaveForm, "ccSaveHeaders",
X`09`09`09`09`09`09arg, i));
X    XtFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, DwtNborderWidth,`092);`09`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNorientation,`09DwtOrientationHorizontal);`09i++
V;
X    XtSetArg(arg`5Bi`5D, DwtNfont,`09`09fontList);`09i++;
X    XtManageChild(ccSaveRadio =
X`09DwtRadioBoxCreate(ccSaveForm, "saveRadio", arg,i)
X`09);
X
X    i = 0;
X    str = DwtLatin1String("Subdirectory");
X    XtSetArg(arg`5Bi`5D, DwtNlabel,`09`09str);`09i++;
X    XtManageChild(
X`09ccSaveSubdirsButton = DwtToggleButtonCreate(ccSaveRadio, "saveSubdirs",
X`09`09`09`09`09`09arg, i));
X    XtFree(str);
X
X    i = 0;
X    str = DwtLatin1String("One Directory");
X    XtSetArg(arg`5Bi`5D, DwtNlabel,`09`09str);`09i++;
X    XtManageChild(
X`09ccSaveOneDirButton = DwtToggleButtonCreate(ccSaveRadio, "saveOneDir",
X`09`09`09`09`09`09arg, i));
X    XtFree(str);
X
X#endif /* MOTIF */
X
X    i = 0;
X    str = XmStringLtoRCreate("OK", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNshowAsDefault,`09True);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`09200);`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`092);`09`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0910);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNactivateCallback,ccOKCallback); i++;
X
X    XtManageChild(
X`09ccOkButton = XmCreatePushButton(confirmDialog, "ccokButton", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Apply", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNactivateCallback,ccApplyCallback);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`09266);`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`092);`09`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0925);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomWidget,`09ccCancelButton);i++;
X    XtManageChild(
X`09ccApplyButton = XmCreatePushButton(confirmDialog, "ccapplyButton",
X`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Cancel", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNactivateCallback,ccCancelCallback);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`09266);`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`092);`09`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0940);`09i++;
X    XtManageChild(
X`09ccCancelButton = XmCreatePushButton(confirmDialog, "cgcancelButton",
X`09`09arg,i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNdefaultButton, ccOkButton);i++;
X    XtSetArg(arg`5Bi`5D, XmNcancelButton,  ccCancelButton);i++;
X    XtSetValues(confirmDialog, arg, i);
X
X#ifndef MOTIF_V10
X    i = 0;
X    str = XmStringLtoRCreate(" ", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_FORM);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopWidget,`09ccSaveForm);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09confOverButton);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`0960);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`0914);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightOffset,`0960);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNx,`09`096814);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNy,`09`093400);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`09800);`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`091);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`091);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightOffset,`091);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNx,`09`0968);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNy,`09`0934);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`098);`09i++;
X#endif
X    XtManageChild(
X`09XmCreateLabel(confirmDialog, "dummyLabel", arg, i));
X    XmStringFree(str);
X#endif
X`7D
Xstatic void makeMailMenu()
X`7B
X    Arg arg`5B20`5D;
X    int i;
X    XmString str;
X
X    i = 0;
X#ifdef MOTIF
X    str = XmStringLtoRCreate("mxrn: Customize/Mail",XmSTRING_DEFAULT_CHARSET
V);
X#else
X    str = DwtLatin1String("dxrn: Customize/Mail");
X#endif
X    XtSetArg(arg`5Bi`5D, XmNborderWidth, `091);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNautoUnmanage,`09False);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNfractionBase,`0960);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNresizePolicy,`09XmRESIZE_GROW);`09i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNunitType,`09Xm100TH_FONT_UNITS);i++;
X    XtSetArg(arg`5Bi`5D, XmNdialogStyle,`09XmDIALOG_APPLICATION_MODAL);i++;
X#ifdef MOTIF_V10
X    XtSetArg(arg`5Bi`5D, XmNwidth,`09`09620*16);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNheight,`09`09290*16);`09i++;
X#endif
X#else
X    XtSetArg(arg`5Bi`5D, DwtNunits,`09`09DwtFontUnits);`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNwidth,`09`09620);`09`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNheight,`09290);`09`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNfontList,`09fontList);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNdialogTitle,`09str);`09`09i++;
X    mailDialog = XmCreateFormDialog(TopLevel, "generalConfirm",arg,i);
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Reply Path", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`094);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`095);`09i++;
X    XtManageChild(
X`09XmCreateLabel(mailDialog, "replyLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`0940);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`093);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0919);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X
X    XtManageChild(
X`09cmReplyPath = XmCreateText(mailDialog, "replyPath", arg, i));
X
X#ifndef VMS
X    i = 0;
X    str = XmStringLtoRCreate("Mailer", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0914);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`095);`09i++;
X    XtManageChild(
X`09XmCreateLabel(mailDialog, "mailerLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`0940);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0919);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0913);`09i++;
X
X    XtManageChild(
X`09cmMailer = XmCreateText(mailDialog, "Mailer", arg, i));
X
X#else
X    i = 0;
X    str = XmStringLtoRCreate("Personal Name", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0914);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`095);`09i++;
X    XtManageChild(
X`09XmCreateLabel(mailDialog, "persLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`0940);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0919);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0913);`09i++;
X
X    XtManageChild(
X`09cmPersonal = XmCreateText(mailDialog, "Personal", arg, i));
X
X#endif
X    i = 0;
X    str = XmStringLtoRCreate("Host Name", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0924);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`095);`09i++;
X    XtManageChild(
X`09XmCreateLabel(mailDialog, "hostLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`0940);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0919);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0923);`09i++;
X
X    XtManageChild(
X`09cmHostName = XmCreateText(mailDialog, "hostName", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("Include CC in Mail headers",
X`09`09XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0937);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`091);`09i++;
X
X    XtManageChild(
X`09cmCCButton = XmCreateToggleButton(mailDialog, "cmCC", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("OK", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`096);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`09100);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNshowAsDefault,`09True);`09`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`092);`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNy,`09`094900);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNactivateCallback,cmOKCallback); i++;
X
X    XtManageChild(
X`09cmOkButton = XmCreatePushButton(mailDialog, "cmokButton", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Apply", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNy,`09`094900);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`09144);`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`092);`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0923);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNactivateCallback,cmApplyCallback); i++;
X
X    XtManageChild(
X`09cmApplyButton = XmCreatePushButton(mailDialog, "cmApplyButton",
X`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Cancel", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNy,`09`095011);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNx,`09`095255);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0942);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`09144);`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`092);`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNactivateCallback,cmCancelCallback); i++;
X
X    XtManageChild(
X`09cmCancelButton = XmCreatePushButton(mailDialog, "cmCancelButton",
X`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNdefaultButton, cmOkButton);i++;
X    XtSetArg(arg`5Bi`5D, XmNcancelButton,  cmCancelButton);i++;
X    XtSetValues(mailDialog, arg, i);
X
X#ifndef MOTIF_V10
X    i = 0;
X    str = XmStringLtoRCreate("   ", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_FORM);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09cmHostName);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopWidget,`09cmHostName);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`0999);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightOffset,`0966);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNy,`09`096000);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNx,`09`096000);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`091300);`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`091);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightOffset,`091);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNy,`09`0960);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNx,`09`0960);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`0913);`09i++;
X#endif
X    XtManageChild(
X`09XmCreateLabel(mailDialog, "dummyLabel", arg, i));
X
X    XmStringFree(str);
X#endif
X`7D
X
Xstatic void makePostMenu()
X`7B
X    Arg arg`5B20`5D;
X    int i;
X    XmString str;
X
X    i = 0;
X#ifdef MOTIF
X    str = XmStringLtoRCreate("mxrn: Customize/Post",XmSTRING_DEFAULT_CHARSET
V);
X#else
X    str = DwtLatin1String("dxrn: Customize/Post");
X#endif
X    XtSetArg(arg`5Bi`5D, XmNborderWidth,`091);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNautoUnmanage,`09False);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNfractionBase,`0960);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNresizePolicy,`09XmRESIZE_GROW);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNunitType,`09Xm100TH_FONT_UNITS);i++;
X    XtSetArg(arg`5Bi`5D, XmNdialogStyle,`09XmDIALOG_APPLICATION_MODAL);i++;
X#ifdef MOTIF_V10
X    XtSetArg(arg`5Bi`5D, XmNwidth,`09`09650*16);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNheight,`09`09420*16);`09i++;
X#endif
X#else
X    XtSetArg(arg`5Bi`5D, DwtNunits,`09`09DwtFontUnits);`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNwidth,`09`09650);`09`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNheight,`09420);`09`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNfontList,`09fontList);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNdialogTitle,`09str);`09`09i++;
X    postDialog = XmCreateFormDialog(TopLevel, "customizePost",arg,i);
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Line Length", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`094);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`094);`09i++;
X    XtManageChild(
X`09XmCreateLabel(postDialog, "lineLengthLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`095);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`093);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0919);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtManageChild(
X`09cpLineLength = XmCreateText(postDialog, "cpLineLength", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("Wrap Length", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0927);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`094);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtManageChild(
X`09XmCreateLabel(postDialog, "wrapLengthLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`095);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`093);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0937);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtManageChild(
X`09cpWrapLength = XmCreateText(postDialog, "cpWrapLength", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("Signature File", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0911);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`094);`09i++;
X    XtManageChild(
X`09XmCreateLabel(postDialog, "sigFileLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`0940);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0919);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0910);`09i++;
X    XtManageChild(
X`09cpSigFile = XmCreateText(postDialog, "cpSigFile", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("Save Postings", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0917);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`094);`09i++;
X    XtManageChild(
X`09XmCreateLabel(postDialog, "savePostLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`0940);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0919);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0916);`09i++;
X    XtManageChild(
X`09cpSavePost = XmCreateText(postDialog, "cpSavePost", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("Dead Letters", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0923);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`094);`09i++;
X    XtManageChild(
X`09XmCreateLabel(postDialog, "deadLettersLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`0940);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0919);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0922);`09i++;
X    XtManageChild(
X`09cpDeadLetters = XmCreateText(postDialog, "cpDeadLetters", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("Editor Command", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0929);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`094);`09i++;
X    XtManageChild(
X`09XmCreateLabel(postDialog, "editorCommandLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`0940);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0919);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0928);`09i++;
X    XtManageChild(
X`09cpEditCmd = XmCreateText(postDialog, "cpEditCmd", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("Organization", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0935);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`094);`09i++;
X    XtManageChild(
X`09XmCreateLabel(postDialog, "orgLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`0940);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0919);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0934);`09i++;
X    XtManageChild(
X`09cpOrganization = XmCreateText(postDialog, "cpOrganization",
X`09`09arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("Reply To", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0941);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`094);`09i++;
X    XtManageChild(
X`09XmCreateLabel(postDialog, "cpReplyLabel", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`0940);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0941);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0919);`09i++;
X    XtManageChild(
X`09cpReplyTo = XmCreateText(postDialog, "cpReplyTo", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("Include Separator", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0947);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`091);`09i++;
X    XtManageChild(
X`09cpInclSepButton = XmCreateToggleButton(postDialog, "cpInclSep",
X`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Include Prefix", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0948);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0919);`09i++;
X    XtManageChild(
X`09XmCreateLabel(postDialog, "cpIncludePrefix", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNcolumns,`095);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0947);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0931);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtManageChild(
X`09cpIncludePrefix = XmCreateText(postDialog, "cpIncPrefix", arg, i));
X
X    i = 0;
X    str = XmStringLtoRCreate("OK", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`096);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`09100);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNshowAsDefault,`09True);`09`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`092);`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNy,`09`094900);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNactivateCallback,cpOKCallback); i++;
X
X    XtManageChild(
X`09cpOkButton = XmCreatePushButton(postDialog, "cpokButton", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Apply", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNy,`09`094900);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`09144);`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`092);`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0923);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNactivateCallback,cpApplyCallback); i++;
X
X    XtManageChild(
X`09cpApplyButton = XmCreatePushButton(postDialog, "cpApplyButton",
X`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Cancel", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNy,`09`095011);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNx,`09`095255);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0942);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`09144);`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`092);`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNactivateCallback,cpCancelCallback); i++;
X    XtManageChild(
X`09cpCancelButton = XmCreatePushButton(postDialog, "cpCancelButton",
X`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNdefaultButton, cpOkButton);i++;
X    XtSetArg(arg`5Bi`5D, XmNcancelButton,  cpCancelButton);i++;
X    XtSetValues(postDialog, arg, i);
X
X#ifndef MOTIF_V10
X    i = 0;
X    str = XmStringLtoRCreate(" ", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_FORM);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09cpReplyTo);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopWidget,`09cpReplyTo);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNx,`09`096000);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNy,`09`096000);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`0999);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightOffset,`0966);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`091000);`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNx,`09`0960);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNy,`09`0960);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`091);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightOffset,`091);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`0910);`09i++;
X#endif
X    XtManageChild(
X`09XmCreateLabel(postDialog, "dummyLabel", arg, i));
X    XmStringFree(str);
X#endif
X`7D
Xstatic void makeReadMenu()
X`7B
X    Arg arg`5B20`5D;
X    int i;
X    XmString str;
X
X    i = 0;
X#ifdef MOTIF
X    str = XmStringLtoRCreate("mxrn: Customize/Read", XmSTRING_DEFAULT_CHARSE
VT);
X#else
X    str = DwtLatin1String("dxrn: Customize/Read");
X#endif
X    XtSetArg(arg`5Bi`5D, XmNdialogTitle,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNborderWidth,`091);`09i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNunitType,`09Xm100TH_FONT_UNITS);i++;
X#ifdef MOTIF_V10
X    XtSetArg(arg`5Bi`5D, XmNwidth,`09`09500*16);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNheight,`09`09310*16);`09i++;
X#endif
X#else
X    XtSetArg(arg`5Bi`5D, DwtNunits,`09`09DwtFontUnits);`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNwidth,`09`09500);`09`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNheight,`09310);`09`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNautoUnmanage,`09False);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNresizePolicy,`09XmRESIZE_GROW);i++;
X    XtSetArg(arg`5Bi`5D, XmNfractionBase,`0960);`09i++;
X    readDialog = XmCreateFormDialog(TopLevel, "customizeRead",arg,i);
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Subject Read", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`095);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`093);`09i++;
X    XtManageChild(
X`09crSubjReadButton = XmCreateToggleButton(readDialog, "crSubjRead",
X`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Retain Killed", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0936);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`093);`09i++;
X    XtManageChild(
X`09crRetainKillButton = XmCreateToggleButton(readDialog, "crRetainKill",
X`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Full Name", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_OPPOSITE_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09crSubjReadButton);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0911);`09i++;
X    XtManageChild(
X`09crAuthorFullButton = XmCreateToggleButton(readDialog, "crAuthorFull",
X`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Show Line Count", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_OPPOSITE_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09crRetainKillButton);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNrightOffset,`09200);`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNrightOffset,`092);`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0911);`09i++;
X    XtManageChild(
X`09crLineCountButton = XmCreateToggleButton(readDialog, "crLineCount",
X`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Auto Wrap", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_OPPOSITE_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09crAuthorFullButton);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0919);`09i++;
X    XtManageChild(
X`09crAutoWrapButton = XmCreateToggleButton(readDialog, "crAutoWrap",
X`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Use Kill Files", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment, XmATTACH_OPPOSITE_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09crLineCountButton);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0919);`09i++;
X    XtManageChild(
X`09crKillButton = XmCreateToggleButton(readDialog, "crKill",
X`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Page Articles", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_OPPOSITE_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09crAutoWrapButton);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0927);`09i++;
X    XtManageChild(
X`09crPageArtButton = XmCreateToggleButton(readDialog, "crPageArt",
X`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Read First Article", XmSTRING_DEFAULT_CHARSET)
V;
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_OPPOSITE_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09crKillButton);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0927);`09i++;
X    XtManageChild(
X`09crAutoReadButton = XmCreateToggleButton(readDialog, "crAutoRead",
X`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Watch Kill Progress", XmSTRING_DEFAULT_CHARSET
V);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_OPPOSITE_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09crAutoReadButton);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0935);`09i++;
X    XtManageChild(
X`09crWatchProgressButton = XmCreateToggleButton(readDialog,
X`09`09"crWatchProgress", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Update Newsrc when\nExiting Group",
X`09`09XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_OPPOSITE_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_POSITION);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`09-10);`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`09-1);`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09crPageArtButton);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopPosition,`0935);`09i++;
X    XtManageChild(
X`09crUpdateButton = XmCreateToggleButton(readDialog, "crUpdate",
X`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("OK", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNactivateCallback,crOKCallback); i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`09200);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNshowAsDefault,`09True);`09`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`092);`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0910);`09i++;
X    XtManageChild(
X`09crOkButton = XmCreatePushButton(readDialog, "crokButton", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Apply", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNactivateCallback,crApplyCallback); i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`09266);`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`092);`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0924);`09i++;
X    XtManageChild(
X`09crApplyButton = XmCreatePushButton(readDialog, "crApplyButton", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Cancel", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNactivateCallback,crCancelCallback); i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`09266);`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`092);`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0940);`09i++;
X    XtManageChild(
X`09crCancelButton = XmCreatePushButton(readDialog, "crCancelButton",
X`09`09arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNdefaultButton, crOkButton);i++;
X    XtSetArg(arg`5Bi`5D, XmNcancelButton,  crCancelButton);i++;
X    XtSetValues(readDialog, arg, i);
X
X#ifndef MOTIF_V10
X    i = 0;
X    str = XmStringLtoRCreate(" ", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_WIDGET);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_FORM);i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);i++;
X    XtSetArg(arg`5Bi`5D, XmNtopWidget,`09crWatchProgressButton);i++;
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09crWatchProgressButton);i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`0960);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`09800);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightOffset,`0960);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`091);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`098);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightOffset,`091);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09i++;
X#endif
X    XtManageChild(
X`09XmCreateLabel(readDialog, "dummyLabel", arg, i));
X    XmStringFree(str);
X#endif
X`7D
Xstatic void updateText(widget, field)
XWidget widget;
Xchar **field;
X`7B
X    char *tempStr;
X    char *p;
X    char *old;
X    char *new;
X
X#ifdef MOTIF
X    tempStr = XmTextGetString(widget);
X#else
X    tempStr = DwtSTextGetString(widget);
X#endif
X
X    old = *field;
X    if (tempStr == NULL `7C`7C strlen(tempStr) == 0) `7B
X`09*field = NULL;
X`09new = NULL;
X    `7D else `7B
X`09p = tempStr;
X`09while (*p == ' ') p++;
X`09if (strlen(p) == 0) `7B
X`09    *field = NULL;
X`09    new = NULL;
X`09`7D else `7B
X`09    *field = XtNewString(p);
X`09    new = p;
X`09`7D
X    `7D
X    if (old == NULL && new == NULL) `7B
X`09XtFree(tempStr);
X`09return;
X    `7D
X    if ( (old == NULL && new != NULL) `7C`7C
X`09 (old != NULL && new == NULL) `7C`7C
X`09 (strcmp(old, new) != 0)) `7B
X`09updatesDone = True;
X    `7D
X    XtFree(tempStr);
X`7D
Xstatic int getInt(widget,def)
XWidget widget;
Xint def;
X`7B
X    int ret;
X    char *tempStr;
X
X    ret = def;
X#ifdef MOTIF
X    tempStr = XmTextGetString(widget);
X#else
X    tempStr = DwtSTextGetString(widget);
X#endif
X    if (tempStr != NULL && strlen(tempStr) != 0) `7B
X`09ret = atoi(tempStr);
X    `7D
X    XtFree(tempStr);
X    if (ret != def)
X`09updatesDone = True;
X    return ret;
X`7D
Xstatic void updateBoolean(widget, field)
XWidget widget;
XBoolean *field;
X`7B
X    Boolean old, new;
X
X    old = *field;
X    new = XmToggleButtonGetState(widget);
X
X    if (old != new)
X`09updatesDone = True;
X
X    *field = new;
X`7D
Xstatic void UpdateGeneral()
X`7B
X    int topLines, minLines, maxLines;
X    int rescanTime;
X
X    topLines = getInt(cgTopLines, app_resources.topLines);
X    minLines = getInt(cgMinLines, app_resources.minLines);
X    maxLines = getInt(cgMaxLines, app_resources.maxLines);
X    if (topLines < 3) `7B
X`09warning("Top Lines must be greater than 3. Top/Min/Max Lines not changed"
V);
X    `7D else `7B
X`09if (topLines > 40) `7B
X`09    warning("Top Lines must be less than 40. Top/Min/Max Lines not change
Vd.");
X`09`7D else `7B
X`09    if (minLines > topLines) `7B
X`09`09warning("Min Lines must be > Top Lines. Top/Min/Max Lines not changed"
V);
X`09    `7D else `7B
X`09`09if (maxLines >= topLines) `7B
X`09`09    warning("Max lines must be < Top Lines. Top/Min/Max Lines not chan
Vged.");
X`09`09`7D else `7B
X`09`09    if (maxLines < minLines) `7B
X`09`09`09warning("Max Lines must be >= Min Lines. Top/Min/Max not changed");
X`09`09    `7D else `7B
X`09`09`09app_resources.topLines = topLines;
X`09`09`09app_resources.minLines = minLines;
X`09`09`09app_resources.maxLines = maxLines;
X`09`09    `7D
X`09`09`7D
X`09    `7D
X`09`7D
X    `7D
X    updateText(cgNNTP,&app_resources.nntpServer);
X    updateText(cgNewsrc,&app_resources.newsrcFile);
X    updateText(cgSaveNewsrc,&app_resources.saveNewsrcFile);
X    updateText(cgTempDir,&app_resources.tmpDir);
X    updateText(cgSaveDir,&app_resources.saveDir);
X    updateText(cgPrtCmd,&app_resources.printCommand);
X    rescanTime = getInt(cgRescan,app_resources.rescanTime);
X    app_resources.rescanTime = rescanTime;
X    if (XmToggleButtonGetState(cgWhichMb2Button)) `7B
X`09if (app_resources.popupButton != 2)
X`09    updatesDone = True;
X`09app_resources.popupButton = 2;
X    `7D else `7B
X`09if (app_resources.popupButton != 3)
X`09    updatesDone = True;
X`09app_resources.popupButton = 3;
X    `7D
X    updateBoolean(cgInfoButton, &app_resources.info);
X`7D
Xstatic void UpdateConfirm()
X`7B
X    int oldSaveMode = app_resources.saveMode;
X    int oldConfirmMode = app_resources.confirmMode;
X
X    app_resources.saveMode = 0;
X    if (XmToggleButtonGetState(ccSaveMbxButton)) `7B
X`09app_resources.saveMode `7C= MAILBOX_SAVE;
X    `7D
X    if (XmToggleButtonGetState(ccSaveHeadersButton)) `7B
X`09app_resources.saveMode &= `7ENOHEADERS_SAVE;
X`09app_resources.saveMode `7C= HEADERS_SAVE;
X    `7D else `7B
X`09app_resources.saveMode &= `7EHEADERS_SAVE;
X`09app_resources.saveMode `7C= NOHEADERS_SAVE;
X    `7D
X    if (XmToggleButtonGetState(ccSaveSubdirsButton)) `7B
X`09app_resources.saveMode &= `7ESAVE_DIR_DEFAULT;
X`09app_resources.saveMode &= `7EONEDIR_SAVE;
X`09app_resources.saveMode `7C= SUBDIRS_SAVE;
X    `7D
X    if (XmToggleButtonGetState(ccSaveOneDirButton)) `7B
X`09app_resources.saveMode &= `7ESAVE_DIR_DEFAULT;
X`09app_resources.saveMode &= `7ESUBDIRS_SAVE;
X`09app_resources.saveMode `7C= ONEDIR_SAVE;
X    `7D
X    if (app_resources.saveMode != oldSaveMode)
X`09updatesDone = True;
X
X    if (XmToggleButtonGetState(confQuitButton))
X`09app_resources.confirmMode `7C= NG_QUIT;
X    if (XmToggleButtonGetState(confExitButton))
X`09app_resources.confirmMode `7C= NG_EXIT;
X    if (XmToggleButtonGetState(confCatchUpButton))
X`09app_resources.confirmMode `7C= NG_CATCHUP;
X    if (XmToggleButtonGetState(confArtCatchUpButton))
X`09app_resources.confirmMode `7C= ART_CATCHUP;
X    if (XmToggleButtonGetState(confUnsubButton))
X`09app_resources.confirmMode `7C= NG_UNSUBSCRIBE;
X    if (XmToggleButtonGetState(confArtUnsubButton))
X`09app_resources.confirmMode `7C= ART_UNSUBSCRIBE;
X    if (XmToggleButtonGetState(confArtEndButton))
X`09app_resources.confirmMode `7C= ART_ENDACTION;
X    if (XmToggleButtonGetState(confOverButton))
X`09app_resources.confirmMode `7C= ART_SAVE;
X    if (!XmToggleButtonGetState(confEditButton))
X`09app_resources.confirmMode `7C= COMP_POST;
X    if (app_resources.confirmMode != oldConfirmMode)
X`09updatesDone = True;
X`7D
Xstatic void UpdateMail()
X`7B
X
X    updateText(cmReplyPath,&app_resources.replyPath);
X#ifndef VMS
X    updateText(cmMailer,&app_resources.mailer);
X#else
X    updateText(cmPersonal,&app_resources.personalName);
X#endif
X
X    updateText(cmHostName,&app_resources.hostName);
X
X    updateBoolean(cmCCButton, &app_resources.cc);
X`7D
X
Xstatic void UpdatePost()
X`7B
X    int lineLength, breakLength;
X
X    lineLength = getInt(cpLineLength,app_resources.lineLength);
X    if (lineLength && (lineLength < 40 `7C`7C lineLength > 250)) `7B
X`09warning("Line length out of range. Use 40 thru 250");
X    `7D else `7B
X`09if (lineLength != app_resources.lineLength)
X`09    updatesDone = True;
X        app_resources.lineLength = lineLength;
X    `7D
X    breakLength = getInt(cpWrapLength,app_resources.breakLength);
X    if (breakLength && (breakLength < lineLength)) `7B
X`09warning("Wrap length must be greater than Line Length");
X    `7D else `7B
X`09if (breakLength > 250) `7B
X`09    warning("Break length out of range. Must be less than 250");
X   `09`7D else `7B
X`09if (breakLength != app_resources.breakLength)
X`09    updatesDone = True;
X`09    app_resources.breakLength = breakLength;
X`09`7D
X    `7D
X    updateText(cpSigFile,&app_resources.signatureFile);
X    updateText(cpSavePost,&app_resources.savePostings);
X    updateText(cpDeadLetters,&app_resources.deadLetters);
X    updateText(cpEditCmd,&app_resources.editorCommand);
X    updateText(cpOrganization,&app_resources.organization);
X    updateText(cpReplyTo,&app_resources.replyTo);
X    updateBoolean(cpInclSepButton, &app_resources.includeSep);
X    updateText(cpIncludePrefix,&app_resources.includePrefix);
X`7D
Xstatic void UpdateRead()
X`7B
X    updateBoolean(crSubjReadButton, &app_resources.subjectRead);
X    updateBoolean(crRetainKillButton, &app_resources.retainKilledArticles);
X    updateBoolean(crAuthorFullButton, &app_resources.authorFullName);
X    updateBoolean(crLineCountButton, &app_resources.displayLineCount);
X    updateBoolean(crAutoWrapButton, &app_resources.autoWrap);
X    updateBoolean(crKillButton, &app_resources.killFiles);
X    updateBoolean(crPageArtButton, &app_resources.pageArticles);
X    updateBoolean(crAutoReadButton, &app_resources.autoRead);
X    updateBoolean(crWatchProgressButton, &app_resources.watchProgress);
X    updateBoolean(crUpdateButton, &app_resources.updateNewsrc);
X`7D
X
Xstatic void CustomizeGeneral()
X`7B
X    char tempStr`5B20`5D;
X
X    if (generalDialog == 0) `7B
X`09makeGeneralMenu();
X    `7D
X    sprintf(tempStr,"%d",app_resources.topLines);
X    XmTextSetString(cgTopLines, tempStr);
X    sprintf(tempStr,"%d",app_resources.minLines);
X    XmTextSetString(cgMinLines,tempStr);
X    sprintf(tempStr,"%d",app_resources.maxLines);
X    XmTextSetString(cgMaxLines,tempStr);
X    XmTextSetString(cgNNTP, app_resources.nntpServer);
X    XmTextSetString(cgNewsrc, app_resources.newsrcFile);
X    XmTextSetString(cgSaveNewsrc, app_resources.saveNewsrcFile);
X    XmTextSetString(cgTempDir, app_resources.tmpDir);
X    XmTextSetString(cgSaveDir, app_resources.saveDir);
X    XmTextSetString(cgPrtCmd, app_resources.printCommand);
X    sprintf(tempStr,"%d",app_resources.rescanTime);
X    XmTextSetString(cgRescan,tempStr);
X    if (app_resources.popupButton == 2) `7B
X`09XmToggleButtonSetState(cgWhichMb2Button, True, False);
X`09XmToggleButtonSetState(cgWhichMb3Button, False, False);
X    `7D else `7B
X`09XmToggleButtonSetState(cgWhichMb2Button, False, False);
X`09XmToggleButtonSetState(cgWhichMb3Button, True, False);
X    `7D
X    XmToggleButtonSetState(cgInfoButton, app_resources.info, False);/* ggh *
V/
X    XtManageChild(generalDialog);
X    XtRealizeWidget(XtParent(generalDialog));
X`7D
Xstatic void CustomizeConfirm()
X`7B
X    if (confirmDialog == 0) `7B
X`09makeConfirmMenu();
X    `7D
X    XmToggleButtonSetState(confQuitButton,
X`09(app_resources.confirmMode & NG_QUIT) ? True : False, False);
X    XmToggleButtonSetState(confExitButton,
X`09(app_resources.confirmMode & NG_EXIT) ? True : False, False);
X    XmToggleButtonSetState(confCatchUpButton,
X`09(app_resources.confirmMode & NG_CATCHUP) ? True : False, False);
X    XmToggleButtonSetState(confArtCatchUpButton,
X`09(app_resources.confirmMode & ART_CATCHUP) ? True : False, False);
X    XmToggleButtonSetState(confUnsubButton,
X`09(app_resources.confirmMode & NG_UNSUBSCRIBE) ? True : False, False);
X    XmToggleButtonSetState(confArtUnsubButton,
X`09(app_resources.confirmMode & ART_UNSUBSCRIBE) ? True : False, False);
X    XmToggleButtonSetState(confArtEndButton,
X`09(app_resources.confirmMode & ART_ENDACTION) ? True : False, False);
X    XmToggleButtonSetState(confOverButton,
X`09(app_resources.confirmMode & ART_SAVE) ? True : False, False);
X    XmToggleButtonSetState(confEditButton,
X`09(app_resources.confirmMode & COMP_POST) ? False : True, False);
X
X    XmToggleButtonSetState(ccSaveMbxButton,
X`09(app_resources.saveMode & MAILBOX_SAVE) ? True : False, False);
X    XmToggleButtonSetState(ccSaveHeadersButton,
X`09(app_resources.saveMode & HEADERS_SAVE) ? True : False, False);
X    XmToggleButtonSetState(ccSaveSubdirsButton,
X`09(app_resources.saveMode & SUBDIRS_SAVE) ? True : False, False);
X    XmToggleButtonSetState(ccSaveOneDirButton,
X`09(app_resources.saveMode & ONEDIR_SAVE) ? True : False, False);
X
X    XtManageChild(confirmDialog);
X    XtRealizeWidget(XtParent(confirmDialog));
X`7D
Xstatic void CustomizeMail()
X`7B
X    if (mailDialog == 0) `7B
X`09makeMailMenu();
X    `7D
X
X    XmTextSetString(cmReplyPath, app_resources.replyPath);
X#ifndef VMS
X    XmTextSetString(cmMailer, app_resources.mailer);
X#else
X    XmTextSetString(cmPersonal, app_resources.personalName);
X#endif
X    XmTextSetString(cmHostName, app_resources.hostName);
X    XmToggleButtonSetState(cmCCButton,
X`09`09app_resources.cc, False);
X
X    XtManageChild(mailDialog);
X    XtRealizeWidget(XtParent(mailDialog));
X`7D
Xstatic void CustomizePost()
X`7B
X    char tempStr`5B20`5D;
X
X    if (postDialog == 0) `7B
X`09makePostMenu();
X    `7D
X
X    sprintf(tempStr,"%d",app_resources.lineLength);
X    XmTextSetString(cpLineLength,tempStr);
X    sprintf(tempStr,"%d",app_resources.breakLength);
X    XmTextSetString(cpWrapLength,tempStr);
X    XmTextSetString(cpSigFile, app_resources.signatureFile);
X    XmTextSetString(cpSavePost, app_resources.savePostings);
X    XmTextSetString(cpDeadLetters, app_resources.deadLetters);
X    XmTextSetString(cpEditCmd, app_resources.editorCommand);
X    XmTextSetString(cpOrganization, app_resources.organization);
X    XmTextSetString(cpReplyTo, app_resources.replyTo);
X    XmToggleButtonSetState(cpInclSepButton,
X`09`09app_resources.includeSep, False);`09`09    /* ggh */
X    XmTextSetString(cpIncludePrefix, app_resources.includePrefix);
X
X
X    XtManageChild(postDialog);
X    XtRealizeWidget(XtParent(postDialog));
X`7D
Xstatic void CustomizeRead()
X`7B
X    if (readDialog == 0) `7B
X`09makeReadMenu();
X    `7D
X
X    XmToggleButtonSetState(crSubjReadButton,
X`09`09app_resources.subjectRead, False);
X    XmToggleButtonSetState(crRetainKillButton,
X`09`09app_resources.retainKilledArticles, False);
X    XmToggleButtonSetState(crAuthorFullButton,
X`09`09app_resources.authorFullName, False);
X    XmToggleButtonSetState(crLineCountButton,
X`09`09app_resources.displayLineCount, False);
X    XmToggleButtonSetState(crAutoWrapButton,
X`09`09app_resources.autoWrap, False);
X    XmToggleButtonSetState(crKillButton,
X`09`09app_resources.killFiles, False);
X    XmToggleButtonSetState(crPageArtButton,
X`09`09app_resources.pageArticles, False);
X    XmToggleButtonSetState(crAutoReadButton,
X`09`09app_resources.autoRead, False);
X    XmToggleButtonSetState(crWatchProgressButton,
X`09`09app_resources.watchProgress, False);
X    XmToggleButtonSetState(crUpdateButton,
X`09`09app_resources.updateNewsrc, False);
X
X    XtManageChild(readDialog);
X    XtRealizeWidget(XtParent(readDialog));
X`7D
X
Xstatic void putNullStr(name, src)
Xchar *name;
Xchar *src;
X`7B
X    char resName`5B512`5D;
X    char *trim;
X    char *value;
X
X    strcpy(resName, app_resources.progName);
X    strcat(resName, ".");
X    strcat(resName, name);
X
X    if (src != NULL) `7B
X`09value = XtNewString(src);
X`09trim = utTrimSpaces(value);
X`09XrmPutStringResource(&xrmDB, resName, trim);
X`09XtFree(value);
X    `7D else `7B
X`09XrmPutStringResource(&xrmDB, resName, "");
X    `7D
X`7D
Xstatic void putStr(name, src)
Xchar *name;
Xchar *src;
X`7B
X    char resName`5B512`5D;
X    char *trim;
X    char *value;
X
X    strcpy(resName, app_resources.progName);
X    strcat(resName, ".");
X    strcat(resName, name);
X
X    if (src != NULL && *src != '\0') `7B
X`09value = XtNewString(src);
X`09trim = utTrimSpaces(value);
X`09XrmPutStringResource(&xrmDB, resName, trim);
X`09XtFree(value);
X    `7D`20
X`7D
Xstatic void putBool(name, src)
Xchar *name;
XBoolean src;
X`7B
X    char resName`5B512`5D;
X
X    strcpy(resName, app_resources.progName);
X    strcat(resName, ".");
X    strcat(resName, name);
X
X    if (src) `7B
X`09XrmPutStringResource(&xrmDB, resName, "on");
X    `7D else `7B
X`09XrmPutStringResource(&xrmDB, resName, "off");
X    `7D
X`7D
Xstatic void putInt(name, src)
Xchar *name;
Xint src;
X`7B
X    char resName`5B512`5D;
X    char numStr`5B20`5D;
X
X    strcpy(resName, app_resources.progName);
X    strcat(resName, ".");
X    strcat(resName, name);
X
X    sprintf(numStr, "%d", src);
X    XrmPutStringResource(&xrmDB, resName, numStr);
X`7D
Xvoid CustomizeSave()
X`7B
X    char tmpStr`5B512`5D;
X#if defined(MOTIF_V10) && (XtSpecificationRelease == 3)
X    static int width = 0;`09/* Gross hack dept: real X11R3 measures */
X    static int height = 0;`09/* using Dimension (shorts) but Motif V1.0 */
X    static int x = 0;`09`09/* uses ints. So we use int and zero 'em */
X    static int y = 0;`09`09/* first so the high order word is OK.   */
X    static int rows = 0;
X#else /* Not X11R3 */
X    static Dimension width = 0;
X    static Dimension height = 0;
X    static Position x = 0;
X    static Position y = 0;
X    static Dimension rows = 0;
X#endif
X    static Arg sizeArgs`5B`5D = `7B
X`09`7BXtNwidth, (XtArgVal) &width`7D,
X`09`7BXtNheight,(XtArgVal) &height`7D,
X    `7D;
X    static Arg rowArgs`5B`5D = `7B
X#ifdef MOTIF
X`09`7BXmNrows, (XtArgVal) &rows`7D,
X#else
X`09`7BDwtNrows, (XtArgVal) &rows`7D,
X#endif
X    `7D;
X
X    xrmDB = XrmGetFileDatabase(customName);
X#ifndef VMS
X    if (xrmDB != NULL) `7B
X`09sprintf(tmpStr, "%s.old", customName);
X`09utCopyFile(customName, tmpStr);
X    `7D
X#endif
X    XtGetValues(MainWindow, sizeArgs, XtNumber(sizeArgs));
X    XtTranslateCoords(TopLevel, 0, 0, &x, &y);
X    sprintf(tmpStr, "%dx%d+%d+%d", width, height, x, y);
X    if (!app_resources.twoWindows) `7B
X`09putStr("layout", tmpStr);
X    `7D else `7B
X`09putStr("indexLayout", tmpStr);
X`09XtGetValues(ArtMainWindow, sizeArgs, XtNumber(sizeArgs));
X`09XtTranslateCoords(ArtTopLevel, 0, 0, &x, &y);
X`09sprintf(tmpStr, "%dx%d+%d+%d", width, height, x, y);
X`09putStr("artLayout", tmpStr);
X    `7D
X    if (ComposeTopLevel && XtIsRealized(ComposeTopLevel)) `7B
X`09XtGetValues(ComposeTopLevel, sizeArgs, XtNumber(sizeArgs));
X`09XtTranslateCoords(ComposeTopLevel, 0, 0, &x, &y);
X`09sprintf(tmpStr, "%dx%d+%d+%d", width, height, x, y);
X`09putStr("compLayout", tmpStr);
X    `7D
X    app_resources.topLines =  SListGetRows(TopList);
X    putInt("topLines",app_resources.topLines);
X    XtGetValues(ArticleText, rowArgs, XtNumber(rowArgs));
X    putInt("textLines", rows + 1);
X    putNullStr("replyPath",app_resources.replyPath);
X    putNullStr("saveDir",app_resources.saveDir);
X    putStr("newsrcFile",app_resources.newsrcFile);
X    putStr("saveNewsrcFile",app_resources.saveNewsrcFile);
X    putStr("signatureFile",app_resources.signatureFile);
X    putStr("nntpServer",app_resources.nntpServer);
X    tmpStr`5B0`5D = '\0';
X    if (app_resources.saveMode & MAILBOX_SAVE) `7B
X`09strcpy(tmpStr, "mailbox,");
X    `7D
X    if (app_resources.saveMode & NOHEADERS_SAVE) `7B
X`09strcat(tmpStr,"noheaders,");
X    `7D
X    if (app_resources.saveMode & HEADERS_SAVE) `7B
X`09strcat(tmpStr,"headers,");
X    `7D
X    if (app_resources.saveMode & SUBDIRS_SAVE) `7B
X`09strcat(tmpStr,"subdirs");
X    `7D else `7B
X`09if (app_resources.saveMode & ONEDIR_SAVE) `7B
X`09    strcat(tmpStr,"onedir");
X`09`7D else `7B
X`09    strcat(tmpStr, "default");
X`09`7D
X    `7D
X    putStr("saveMode", tmpStr);
X
X    putStr("savePostings",app_resources.savePostings);
X    putStr("deadLetters",app_resources.deadLetters);
X    putInt("minLines",app_resources.minLines);
X    putInt("maxLines",app_resources.maxLines);
X#ifndef VMS
X    putNullStr("mailer",app_resources.mailer);
X#else
X    putNullStr("personalName",app_resources.personalName);
X#endif
X    putBool("subjectRead",app_resources.subjectRead);
X    putBool("info",app_resources.info);
X    putStr("tmpDir",app_resources.tmpDir);
X    tmpStr`5B0`5D = '\0';
X    if (app_resources.confirmMode & NG_QUIT)
X`09strcat(tmpStr,"ngQuit,");
X    if (app_resources.confirmMode & NG_EXIT)
X`09strcat(tmpStr,"ngExit,");
X    if (app_resources.confirmMode & NG_CATCHUP)
X`09strcat(tmpStr,"ngCatchUp,");
X    if (app_resources.confirmMode & ART_CATCHUP)
X`09strcat(tmpStr,"artCatchUp,");
X    if (app_resources.confirmMode & NG_UNSUBSCRIBE)
X`09strcat(tmpStr,"ngUnsub,");
X    if (app_resources.confirmMode & ART_UNSUBSCRIBE)
X`09strcat(tmpStr,"artUnsub,");
X    if (app_resources.confirmMode & ART_ENDACTION)
X`09strcat(tmpStr,"artEndAction,");
X    if (app_resources.confirmMode & ART_SAVE)
X`09strcat(tmpStr,"artSave,");
X    tmpStr`5Bstrlen(tmpStr)-1`5D = '\0';
X    putNullStr("confirm", tmpStr);
X
X    putBool("killFiles",app_resources.killFiles);
X    putStr("editorCommand",app_resources.editorCommand);
X    putStr("organization",app_resources.organization);
X    putNullStr("replyTo",app_resources.replyTo);
X    putBool("includeHeader",app_resources.includeHeader);
X    putBool("includeSep",app_resources.includeSep);
X    putBool("updateNewsrc",app_resources.updateNewsrc);
X    putInt("compLineLength",app_resources.lineLength);
X    putInt("compBreakLength",app_resources.breakLength);
X    putInt("rescanTime",app_resources.rescanTime);
X    putBool("pageArticles",app_resources.pageArticles);
X    putBool("authorFullName",app_resources.authorFullName);
X    putBool("displayLineCount",app_resources.displayLineCount);
X    putBool("autoRead",app_resources.autoRead);
X    putBool("autoWrap",app_resources.autoWrap);
X    putBool("cc",app_resources.cc);
X    putBool("retainKilled",app_resources.retainKilledArticles);
X    putStr("addButtonList",app_resources.addButtonList);
X    putStr("ngButtonList",app_resources.ngButtonList);
X    putStr("allButtonList",app_resources.allButtonList);
X    putStr("artButtonList",app_resources.artButtonList);
X    putStr("artSpecButtonList",app_resources.artSpecButtonList);
X    putStr("printCommand",app_resources.printCommand);
X    putNullStr("includePrefix",app_resources.includePrefix);
X    putNullStr("hostName",app_resources.hostName);
X    putNullStr("replyPath",app_resources.replyPath);
X    putStr("addPopupList",app_resources.addPopupList);
X    putStr("ngPopupList",app_resources.ngPopupList);
X    putStr("allPopupList",app_resources.allPopupList);
X    putStr("artPopupList",app_resources.artPopupList);
X    putInt("popupButton",app_resources.popupButton);
X
X    XrmPutFileDatabase(xrmDB, customName);
X    xrmDB = NULL;
X    updatesDone = False;
X`7D
XBoolean getUpdateStatus()
X`7B
X    return updatesDone;
X`7D
Xstatic void menuOK()
X`7B
X    UpdateMenu();
X    XtUnmanageChild(customDialog);
X`7D
Xstatic void menuApply()
X`7B
X    UpdateMenu();
X`7D
Xstatic void menuCancel()
X`7B
X    XtUnmanageChild(customDialog);
X`7D
Xstatic void cgOK()
X`7B
X    UpdateGeneral();
X    XtUnmanageChild(generalDialog);
X`7D
Xstatic void cgApply()
X`7B
X    UpdateGeneral();
X`7D
Xstatic void cgCancel()
X`7B
X    XtUnmanageChild(generalDialog);
X`7D
Xstatic void ccOK()
X`7B
X    UpdateConfirm();
X    XtUnmanageChild(confirmDialog);
X`7D
Xstatic void ccApply()
X`7B
X    UpdateConfirm();
X`7D
Xstatic void ccCancel()
X`7B
X    XtUnmanageChild(confirmDialog);
X`7D
Xstatic void cmOK()
X`7B
X    UpdateMail();
X    XtUnmanageChild(mailDialog);
X`7D
Xstatic void cmApply()
X`7B
X    UpdateMail();
X`7D
Xstatic void cmCancel()
X`7B
X    XtUnmanageChild(mailDialog);
X`7D
Xstatic void cpOK()
X`7B
X    UpdatePost();
X    XtUnmanageChild(postDialog);
X`7D
Xstatic void cpApply()
X`7B
X    UpdatePost();
X`7D
Xstatic void cpCancel()
X`7B
X    XtUnmanageChild(postDialog);
X`7D
Xstatic void crOK()
X`7B
X    UpdateRead();
X    XtUnmanageChild(readDialog);
X`7D
Xstatic void crApply()
X`7B
X    UpdateRead();
X`7D
Xstatic void crCancel()
X`7B
X    XtUnmanageChild(readDialog);
X`7D
X`0C
Xstatic void makeCustomMenu()
X`7B
X    Arg arg`5B20`5D;
X    int i;
X    XmString str;
X
X    i = 0;
X#ifdef MOTIF
X    str = XmStringLtoRCreate("mxrn: Customize/Menus", XmSTRING_DEFAULT_CHARS
VET);
X#else
X    str = DwtLatin1String("dxrn: Customize/Menus");
X#endif
X    XtSetArg(arg`5Bi`5D, XmNborderWidth,`091);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNautoUnmanage,`09False);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNdialogTitle,`09str);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNresizePolicy,`09XmRESIZE_GROW);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNfractionBase,`09100);`09`09`09i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNdialogStyle,`09XmDIALOG_APPLICATION_MODAL);i++;
X    XtSetArg(arg`5Bi`5D, XmNunitType,`09Xm100TH_FONT_UNITS);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNwidth, `09`09550*16); `09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNheight,`09`09430*16);`09`09`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, DwtNwidth, `09550);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNheight,`09430);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNunits,`09`09DwtFontUnits);`09`09i++;
X#endif
X    customDialog = XmCreateFormDialog(TopLevel, "customDialog",arg,i);
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Click on these items to\nadd them to the menu"
V,
X`09XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_FORM);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_FORM);`09`09i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`090);`09`09`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`091);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`091);`09`09`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_POSITION);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightPosition,`0950);`09`09`09i++;
X    XtManageChild(addLabel =
X`09XmCreateLabel(customDialog,"addLabel",arg,i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate(
X`09"Click on these items to\nremove them from the menu",
X`09XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_WIDGET);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_FORM);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`090);`09`09`09i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`090);`09`09`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`091);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightOffset,`091);`09`09`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09addLabel);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_FORM);`09`09i++;
X    XtManageChild(removeLabel =
X`09XmCreateLabel(customDialog,"removeLabel",arg,i));
X    XmStringFree(str);
X
X#ifdef MOTIF
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNborderWidth,`0925);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_FORM);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_WIDGET);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`09800);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`0950);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopWidget,`09addLabel);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNscrollBarDisplayPolicy,`09XmSTATIC);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNvisualPolicy,`09XmVARIABLE);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNscrollingPolicy, XmAPPLICATION_DEFINED);i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_POSITION);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightPosition,`0950);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightOffset,`09400);`09`09`09i++;
X    XtManageChild(addScroll =
X`09XmCreateScrolledWindow(customDialog,"addScroll", arg, i));
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNautomaticSelection, False);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNlistSizePolicy, XmCONSTANT);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNselectionPolicy,XmSINGLE_SELECT);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNvisibleItemCount,10);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNscrollBarDisplayPolicy, XmSTATIC);`09i++;
X    XtManageChild(
X`09addList = XmCreateList(addScroll,"addList", arg, i));
X#else
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_FORM);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_WIDGET);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`098);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`095);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopWidget,`09addLabel);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_NONE);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_POSITION);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightPosition,`0950);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightOffset,`091);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNwidth,`09`09200);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNsingleSelection,True);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNhorizontal,`09True);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNvisibleItemCount,10);`09`09`09i++;
X    XtManageChild(
X`09addList = DwtListBoxCreate(customDialog,"addList", arg, i));
X#endif
X
X#ifdef MOTIF
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNborderWidth,`0925);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_WIDGET);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09addScroll);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_WIDGET);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopWidget,`09removeLabel);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNscrollBarDisplayPolicy,`09XmSTATIC);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNvisualPolicy,`09XmVARIABLE);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_FORM);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightOffset,`09800);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNscrollingPolicy,XmAPPLICATION_DEFINED);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`09800);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`0950);`09`09`09i++;
X
X    XtManageChild(removeScroll =
X`09XmCreateScrolledWindow(customDialog,"removeScroll", arg, i));
X
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNautomaticSelection, False);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNlistSizePolicy, XmCONSTANT);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNselectionPolicy,XmSINGLE_SELECT);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNvisibleItemCount,10);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNscrollBarDisplayPolicy, XmSTATIC);`09i++;
X
X    XtManageChild(
X`09removeList = XmCreateList(removeScroll, "removeList", arg, i));
X#else
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_WIDGET);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09addList);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_WIDGET);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopWidget,`09removeLabel);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_FORM);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightOffset,`094);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`094);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`095);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNwidth,`09`09200);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNsingleSelection,True);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNhorizontal,`09True);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNvisibleItemCount,10);`09`09`09i++;
X
X    XtManageChild(
X`09removeList = DwtListBoxCreate(customDialog, "removeList", arg, i));
X#endif
X
X    i = 0;
X    str = XmStringLtoRCreate("OK", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_NONE);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`097);`09`09`09i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`0952);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNshowAsDefault,`09True);`09`09`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`095);`09`09`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNactivateCallback,menuOKCallback); `09i++;
X
X    XtManageChild(
X`09okButton = XmCreatePushButton(customDialog, "okButton", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Apply", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_NONE);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0944);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);`09i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`09142);`09`09`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`095);`09`09`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNactivateCallback,menuApplyCallback); `09i++;
X    XtManageChild(
X`09applyButton = XmCreatePushButton(customDialog, "applyButton", arg, i));
X    XmStringFree(str);
X
X    i = 0;
X    str = XmStringLtoRCreate("Cancel", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_POSITION);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_NONE);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftPosition,`0978);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment,XmATTACH_NONE);`09`09i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`09142);`09`09`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`095);`09`09`09i++;
X#endif
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNactivateCallback,menuCancelCallback); `09i++;
X    XtManageChild(
X`09cancelButton = XmCreatePushButton(customDialog, "cancelButton", arg,i));
X    XmStringFree(str);
X
X#ifndef MOTIF_V10
X    i = 0;
X    str = XmStringLtoRCreate(" ", XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(arg`5Bi`5D, XmNlabelString,`09str);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftAttachment,`09XmATTACH_WIDGET);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopAttachment,`09XmATTACH_WIDGET);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomAttachment,XmATTACH_FORM);`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightAttachment, XmATTACH_FORM);`09i++;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09removeScroll); `09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopWidget,`09removeScroll);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`09128);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`0920);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightOffset,`0950);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`09471);`09`09`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, XmNleftWidget,`09removeList); `09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopWidget,`09removeList);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNbottomOffset,`091);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNleftOffset,`091);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNrightOffset,`091);`09`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNtopOffset,`095);`09`09`09i++;
X#endif
X
X    XtManageChild(
X`09XmCreateLabel(customDialog, "dummyLabel", arg, i));
X    XmStringFree(str);
X#endif
X
X    i = 0;
X
X    XtSetArg(arg`5Bi`5D, XmNdefaultButton, okButton);`09`09i++;
X    XtSetArg(arg`5Bi`5D, XmNcancelButton, cancelButton);`09`09i++;
X    XtSetValues(customDialog, arg, i);
X`7D
Xstatic void LoadCustomList(string)
Xchar`09*string;
X`7B
X    int i, j, add, rem;
X    char *ptr, *token, *savePtr;
X    Arg arg`5B10`5D;
X
X    if (customDialog == 0) `7B
X`09makeCustomMenu();
X    `7D
X    i = 0;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNsingleSelectionCallback, addCallback);`09i++;
X#else
X    XtSetArg(arg`5Bi`5D, DwtNsingleCallback, addCallback);`09`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNsingleConfirmCallback, addCallback);`09i++;
X#endif
X    XtSetValues(addList, arg, i);
X    i = 0;
X#ifdef MOTIF
X    XtSetArg(arg`5Bi`5D, XmNsingleSelectionCallback, removeCallback);i++;
X#else
X    XtSetArg(arg`5Bi`5D, DwtNsingleCallback, removeCallback);`09i++;
X    XtSetArg(arg`5Bi`5D, DwtNsingleConfirmCallback, removeCallback);i++;
X#endif
X    XtSetValues(removeList, arg, i);
X    for (i = 0; i < currentCount;i++) `7B
X`09if (currentButtons`5Bi`5D.listString == NULL)
X`09    currentButtons`5Bi`5D.listString =
X`09      XmStringLtoRCreate(currentButtons`5Bi`5D.label,
X`09`09`09XmSTRING_DEFAULT_CHARSET);
X`09if (string != NULL) `7B
X`09    currentButtons`5Bi`5D.addPos = -1;
X`09    currentButtons`5Bi`5D.removePos = -1;
X`09`7D else `7B
X`09    currentButtons`5Bi`5D.addPos = -1;
X`09    currentButtons`5Bi`5D.removePos = i;
X`09`7D
X    `7D
X    add = 0;
X    rem = 0;
X
X    if (string != NULL) `7B
X`09savePtr = ptr = XtNewString(string);
X
X`09while ((token = strtok(ptr, ", \t\n")) != NIL(char)) `7B
X`09    for (j = 0; j < currentCount; j++) `7B`09
X`09`09if (STREQ(token, (char *) currentButtons`5Bj`5D.name)) `7B
X`09`09    currentButtons`5Bj`5D.removePos = rem;
X`09`09    removeItems`5Brem`5D = currentButtons`5Bj`5D.listString;
X`09`09    rem++;
X`09`09    break;
X`09`09`7D
X`09    `7D
X`09    ptr = NULL;
X`09`7D
X`09XtFree (savePtr);
X`09for (i = 0; i < currentCount; i++) `7B
X`09    if (currentButtons`5Bi`5D.removePos == -1) `7B
X`09`09currentButtons`5Bi`5D.addPos = add;
X`09`09addItems`5Badd`5D = currentButtons`5Bi`5D.listString;
X`09`09add++;
X`09    `7D
X`09`7D
X    `7D else `7B
X`09for (rem = 0; rem < currentCount; rem++)
X`09    removeItems`5Brem`5D = currentButtons`5Brem`5D.listString;
X    `7D
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNitems, addItems);i++;
X    XtSetArg(arg`5Bi`5D, XmNitemCount, add); i++;
X    XtSetValues(addList, arg, i);
X    i = 0;
X    XtSetArg(arg`5Bi`5D, XmNitems, removeItems);i++;
X    XtSetArg(arg`5Bi`5D, XmNitemCount, rem); i++;
X    XtSetValues(removeList, arg, i);
X`7D
Xstatic void addClick(w, call_data, click)
XWidget `09`09`09w;
Xcaddr_t`09`09`09call_data;
X#ifdef MOTIF
XXmListCallbackStruct `09*click;
X#else
XDwtListBoxCallbackStruct *click;
X#endif
X`7B
X    int i, add, rem, addCount, removeCount;
X#ifdef MOTIF
X    int selItem = click->item_position - 1;
X    Arg arg`5B10`5D;
X#else
X    int selItem = click->item_number - 1;
X#endif
X    int item;
X
X    XmListDeselectAllItems(w);
X    addCount = add = 0;
X    removeCount = rem = 0;
X    for (i = 0; i < currentCount; i++) `7B
X`09if (currentButtons`5Bi`5D.addPos != -1) `7B
X`09    addCount++;
X`09`7D
X`09if (currentButtons`5Bi`5D.removePos != -1) `7B
X`09    removeCount++;
X`09`7D
X`09if (currentButtons`5Bi`5D.addPos == selItem) `7B
X`09    item = i;
X`09`7D
X    `7D
X
X    for (i = 0; i < currentCount; i++) `7B
X`09if (currentButtons`5Bi`5D.addPos > selItem) `7B
X`09    currentButtons`5Bi`5D.addPos = currentButtons`5Bi`5D.addPos - 1;
X`09`7D
X    `7D
X    currentButtons`5Bitem`5D.removePos = removeCount;
X    currentButtons`5Bitem`5D.addPos = -1;
X
X    addCount = addCount - 1;
X    removeCount = removeCount + 1;
X    for (i = 0; i < currentCount; i++) `7B
X`09if ((add = currentButtons`5Bi`5D.addPos) != -1) `7B
X`09    addItems`5Badd`5D = currentButtons`5Bi`5D.listString;
X`09`7D
X`09if ((rem = currentButtons`5Bi`5D.removePos) != -1) `7B
X`09    removeItems`5Brem`5D = currentButtons`5Bi`5D.listString;
X`09`7D
X    `7D
X#ifdef MOTIF
X    XmListDeletePos(addList, selItem+1);
X    if (removeCount > 1) `7B
X        XmListAddItem(removeList, removeItems`5BremoveCount-1`5D, 0);
X    `7D else `7B
X`09i = 0;
X`09XtSetArg(arg`5Bi`5D, XmNitems, removeItems);i++;
X`09XtSetArg(arg`5Bi`5D, XmNitemCount, removeCount); i++;
X`09XtSetValues(removeList, arg, i);
X    `7D
X#else
X    DwtListBoxDeletePos(addList, selItem+1);
X    DwtListBoxAddItem(removeList, removeItems`5BremoveCount-1`5D, removeCoun
Vt);
X#endif
X`7D
Xstatic void removeClick(w, call_data, click)
XWidget `09`09`09w;
Xcaddr_t`09`09`09call_data;
X#ifdef MOTIF
XXmListCallbackStruct `09*click;
X#else
XDwtListBoxCallbackStruct `09*click;
X#endif
X`7B
X    int i, add, rem, addCount, removeCount;
X#ifdef MOTIF
X    int selItem = click->item_position - 1;
X    Arg arg`5B10`5D;
X#else
X    int selItem = click->item_number - 1;
X#endif
X    int item;
X
X    XmListDeselectAllItems(w);
X    addCount = add = 0;
X    removeCount = rem = 0;
X    for (i = 0; i < currentCount; i++) `7B
X`09if (currentButtons`5Bi`5D.addPos != -1) `7B
X`09    addCount++;
X`09`7D
X`09if (currentButtons`5Bi`5D.removePos != -1) `7B
X`09    removeCount++;
X`09`7D
X`09if (currentButtons`5Bi`5D.removePos == selItem) `7B
X`09    item = i;
X`09`7D
X    `7D
X    for (i = 0; i < currentCount; i++) `7B
X`09if (currentButtons`5Bi`5D.removePos > selItem) `7B
X`09    currentButtons`5Bi`5D.removePos = currentButtons`5Bi`5D.removePos - 1
V;
X`09`7D
X    `7D
X
X    currentButtons`5Bitem`5D.addPos = addCount;
X    currentButtons`5Bitem`5D.removePos = -1;
X
X    addCount = addCount + 1;
X    removeCount = removeCount - 1;
X    for (i = 0; i < currentCount; i++) `7B
X`09if ((add = currentButtons`5Bi`5D.addPos) != -1) `7B
X`09    addItems`5Badd`5D = currentButtons`5Bi`5D.listString;
X`09`7D
X`09if ((rem = currentButtons`5Bi`5D.removePos) != -1) `7B
X`09    removeItems`5Brem`5D = currentButtons`5Bi`5D.listString;
X`09`7D
X    `7D
X#ifdef MOTIF
X    XmListDeletePos(removeList, selItem+1);
X    if (addCount > 1) `7B
X        XmListAddItem(addList, addItems`5BaddCount-1`5D, 0);
X    `7D else `7B
X`09i = 0;
X`09XtSetArg(arg`5Bi`5D, XmNitems, addItems);i++;
X`09XtSetArg(arg`5Bi`5D, XmNitemCount, addCount); i++;
X`09XtSetValues(addList, arg, i);
X    `7D
X#else
X    DwtListBoxDeletePos(removeList, selItem+1);
X    DwtListBoxAddItem(addList, addItems`5BaddCount-1`5D, addCount);
X#endif
X`7D
Xstatic void CustomizeAddMenus()
X`7B
X    currentButtons = addButtons;
X    currentCount = XtNumber(addButtons);
X    menuMode = addMenu;
X    LoadCustomList(app_resources.addButtonList);
X    XtManageChild(customDialog);
X    XtRealizeWidget(XtParent(customDialog));
X`7D
Xstatic void CustomizeAddPopups()
X`7B
X    currentButtons = addButtons;
X    currentCount = XtNumber(addButtons);
X    menuMode = addPop;
X    LoadCustomList(app_resources.addPopupList);
X    XtManageChild(customDialog);
X    XtRealizeWidget(XtParent(customDialog));
X`7D
Xstatic void CustomizeAllMenus()
X`7B
X    currentButtons = allButtons;
X    currentCount = XtNumber(allButtons);
X    menuMode = allMenu;
X    LoadCustomList(app_resources.allButtonList);
X    XtManageChild(customDialog);
X    XtRealizeWidget(XtParent(customDialog));
X`7D
Xstatic void CustomizeAllPopups()
X`7B
X    currentButtons = allButtons;
X    currentCount = XtNumber(allButtons);
X    menuMode = allPop;
X    LoadCustomList(app_resources.allPopupList);
X    XtManageChild(customDialog);
X    XtRealizeWidget(XtParent(customDialog));
X`7D
Xstatic void CustomizeArtMenus()
X`7B
X    currentButtons = artButtons;
X    currentCount = XtNumber(artButtons);
X    menuMode = artMenu;
X    LoadCustomList(app_resources.artButtonList);
X    XtManageChild(customDialog);
X    XtRealizeWidget(XtParent(customDialog));
X`7D
Xstatic void CustomizeArtPopups()
X`7B
X    currentButtons = artButtons;
X    currentCount = XtNumber(artButtons);
X    menuMode = artPop;
X    LoadCustomList(app_resources.artPopupList);
X    XtManageChild(customDialog);
X    XtRealizeWidget(XtParent(customDialog));
X`7D
Xstatic void CustomizeNgMenus()
X`7B
X    currentButtons = ngButtons;
X    currentCount = XtNumber(ngButtons);
X    menuMode = ngMenu;
X    LoadCustomList(app_resources.ngButtonList);
X    XtManageChild(customDialog);
X    XtRealizeWidget(XtParent(customDialog));
X`7D
Xstatic void CustomizeNgPopups()
X`7B
X    currentButtons = ngButtons;
X    currentCount = XtNumber(ngButtons);
X    menuMode = ngPop;
X    LoadCustomList(app_resources.ngPopupList);
X    XtManageChild(customDialog);
X    XtRealizeWidget(XtParent(customDialog));
X`7D
Xstatic void UpdateMenu()
X`7B
X    char menuString`5B2048`5D;
X    int i,j;
X
X    menuString`5B0`5D = '\0';
X
X    updatesDone = True;
X    for (i = 0; i < currentCount; i++) `7B
X        for (j = 0; j < currentCount; j++) `7B
X`09    if (currentButtons`5Bj`5D.removePos == i) `7B
X`09`09strcat(menuString,currentButtons`5Bj`5D.name);
X`09`09strcat(menuString,",");
X`09`09break;
X`09    `7D
X`09`7D
X    `7D
X    menuString`5Bstrlen(menuString)-1`5D = '\0';
X    switch (menuMode) `7B
X`09case addMenu:
X`09    app_resources.addButtonList = XtNewString(menuString);
X`09    createButtons(ADD_MODE);
X`09    break;
X`09case addPop:
X`09    app_resources.addPopupList = XtNewString(menuString);
X`09    XtUnmanageChildren(AddPopupButtons, AddPopupCount);
X`09    AddPopupCount = AddCount;
X`09    doPopups(app_resources.addPopupList, popup_menu, AddPopupButtons,
X`09`09AddButtonList, &AddPopupCount);
X`09    if (Mode == ADD_MODE) `7B
X`09`09XtManageChildren(AddPopupButtons, AddPopupCount);
X`09`09resetPopupSize();
X`09    `7D
X`09    break;
X`09case allMenu:
X`09    app_resources.allButtonList = XtNewString(menuString);
X`09    createButtons(ALL_MODE);
X`09    break;
X`09case allPop:
X`09    app_resources.allPopupList = XtNewString(menuString);
X`09    XtUnmanageChildren(AllPopupButtons, AllPopupCount);
X`09    AllPopupCount = AllCount;
X`09    doPopups(app_resources.allPopupList, popup_menu, AllPopupButtons,
X`09`09AllButtonList, &AllPopupCount);
X`09    if (Mode == ALL_MODE) `7B
X`09`09XtManageChildren(AllPopupButtons, AllPopupCount);
X`09`09resetPopupSize();
X`09    `7D
X`09    break;
X`09case artMenu:
X`09    app_resources.artButtonList = XtNewString(menuString);
X`09    createButtons(ARTICLE_MODE);
X`09    break;
X`09case artPop:
X`09    app_resources.artPopupList = XtNewString(menuString);
X`09    XtUnmanageChildren(ArtPopupButtons, ArtPopupCount);
X`09    ArtPopupCount = ArtCount;
X`09    ArtSpecPopupCount = ArtSpecCount;
X`09    doPopups(app_resources.artPopupList, popup_menu, ArtPopupButtons,
X`09`09ArtButtonList, &ArtPopupCount);
X`09    if (Mode == ARTICLE_MODE) `7B
X`09`09XtManageChildren(ArtPopupButtons, ArtPopupCount);
X`09`09resetPopupSize();
X`09    `7D
X`09    break;
X`09case ngMenu:
X`09    app_resources.ngButtonList = XtNewString(menuString);
X`09    createButtons(NEWSGROUP_MODE);
X`09    break;
X`09case ngPop:
X`09    app_resources.ngPopupList = XtNewString(menuString);
X`09    XtUnmanageChildren(NgPopupButtons, NgPopupCount);
X`09    NgPopupCount = NgCount;
X`09    doPopups(app_resources.ngPopupList, popup_menu, NgPopupButtons,
X`09`09NgButtonList, &NgPopupCount);
X`09    if (Mode == NEWSGROUP_MODE) `7B
X`09`09XtManageChildren(NgPopupButtons, NgPopupCount);
X`09`09resetPopupSize();
X`09    `7D
X`09    break;
X    `7D
X`7D
$ CALL UNPACK MENUS.C;153 88002847
$ create 'f'
X/* menus.h - definitions for menu processing */
X#ifndef _menus_h
X#define _menus_h
X/*
X * Redefinitions for Motif widgets to ease XUI port
X */
X#ifndef MOTIF
X#define XmCreatePushButton DwtPushButtonCreate
X#define XmCreatePushButtonGadget DwtPushButtonGadgetCreate
X#define XmCreateLabel DwtLabelCreate
X#define XmCreateLabelGadget DwtLabelGadgetCreate
X#define XmCreateBulletinBoardDialog DwtDialogBoxPopupCreate
X#define XmCreateScrolledList DwtListBoxCreate
X#define XmCreateFormDialog DwtAttachedDBPopupCreate
X#define XmCreateForm DwtAttachedDBCreate
X#define XmCreateRadioBox DwtRadioBoxCreate
X#define XmCreateText DwtSTextCreate
X#define XmCreateToggleButton DwtToggleButtonCreate
X#define XmCreateSeparator DwtSeparatorCreate
X#define XmToggleButtonGetState DwtToggleButtonGetState
X#define XmToggleButtonSetState DwtToggleButtonSetState
X#define XmTextSetString DwtSTextSetString
X#define XmTextGetString DwtSTextGetString
X#define XmStringLtoRCreate(a,b) DwtLatin1String(a)
X#define XmStringFree XtFree
X#define XmNx DwtNx
X#define XmNy DwtNy
X#define XmNwidth DwtNwidth
X#define XmNheight DwtNheight
X#define XmNlabelString DwtNlabel
X#define XmString DwtCompString
X#define XmNborderWidth DwtNborderWidth
X#define XmNresizePolicy DwtNresize
X#define XmRESIZE_GROW DwtResizeGrowOnly
X#define XmNautoUnmanage DwtNautoUnmanage
X#define XmNcolumns DwtNcols
X#define XmNorientation DwtNorientation
X#define XmHORIZONTAL DwtOrientationHorizontal
X#define XmNfontList DwtNfont
X#define XmNdialogStyle DwtNstyle
X#define XmNdialogTitle DwtNtitle
X#define XmDIALOG_APPLICATION_MODAL DwtModal
X#define XmNvisibleItemCount DwtNvisibleItemsCount
X#define XmNactivateCallback DwtNactivateCallback
X#define XmNdefaultButton DwtNdefaultButton
X#define XmNcancelButton DwtNcancelButton
X#define XmNitems DwtNitems
X#define XmNitemCount DwtNitemsCount
X#define XmNsingleSelectionCallback DwtNsingleCallback
X#define XmListDeselectAllItems DwtListBoxDeselectAllItems
X#define XmNfractionBase DwtNfractionBase
X#define XmNleftAttachment DwtNadbLeftAttachment
X#define XmNrightAttachment DwtNadbRightAttachment
X#define XmNtopAttachment DwtNadbTopAttachment
X#define XmNbottomAttachment DwtNadbBottomAttachment
X#define XmNleftPosition DwtNadbLeftPosition
X#define XmNrightPosition DwtNadbRightPosition
X#define XmNtopPosition DwtNadbTopPosition
X#define XmNbottomPosition DwtNadbBottomPosition
X#define XmNleftOffset DwtNadbLeftOffset
X#define XmNrightOffset DwtNadbRightOffset
X#define XmNtopOffset DwtNadbTopOffset
X#define XmNbottomOffset DwtNadbBottomOffset
X#define XmNleftWidget DwtNadbLeftWidget
X#define XmNtopWidget DwtNadbTopWidget
X#define XmNbottomWidget DwtNadbBottomWidget
X#define XmATTACH_POSITION DwtAttachPosition
X#define XmATTACH_NONE DwtAttachNone
X#define XmATTACH_FORM DwtAttachAdb
X#define XmATTACH_WIDGET DwtAttachWidget
X#define XmATTACH_OPPOSITE_WIDGET DwtAttachOppWidget
X#define XmNshowAsDefault DwtNshownAsDefault
X#define XmNunitType DwtNunits
X#define Xm100TH_FONT_UNITS DwtFontUnits
X#define XmNradioAlwaysOne DwtNradioAlwaysOne
X#endif
X
X/*
X * Forward declarations
X */
X
Xstatic void UpdateMenu();
Xstatic void makeCustomMenu();
Xstatic void makeGeneralMenu();
Xstatic void doPopups();
Xstatic void CustomizeAddMenus();
Xstatic void CustomizeAddPopups();
Xstatic void CustomizeAllMenus();
Xstatic void CustomizeAllPopups();
Xstatic void CustomizeArtMenus();
Xstatic void CustomizeArtPopups();
Xstatic void CustomizeNgMenus();
Xstatic void CustomizeNgPopups();
Xstatic void CustomizeGeneral();
Xstatic void CustomizeConfirm();
Xstatic void CustomizePost();
Xstatic void CustomizeMail();
Xstatic void CustomizeRead();
Xvoid CustomizeSave();
Xstatic void menuOK();
Xstatic void menuApply();
Xstatic void menuCancel();
Xstatic void cgOK();
Xstatic void cgApply();
Xstatic void cgCancel();
Xstatic void ccOK();
Xstatic void ccApply();
Xstatic void ccCancel();
Xstatic void cmOK();
Xstatic void cmApply();
Xstatic void cmCancel();
Xstatic void cpOK();
Xstatic void cpApply();
Xstatic void cpCancel();
Xstatic void crOK();
Xstatic void crApply();
Xstatic void crCancel();
Xstatic void addClick();
Xstatic void removeClick();
Xstatic void cmOK();
Xstatic void cmApply();
Xstatic void cmCancel();
X
X/*
X * Callbacks
X */
Xstatic XtCallbackRec addMenusCallbacks`5B`5D = `7B
X    `7BCustomizeAddMenus, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec addPopupsCallbacks`5B`5D = `7B
X    `7BCustomizeAddPopups, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec artMenusCallbacks`5B`5D = `7B
X    `7BCustomizeArtMenus, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec artPopupsCallbacks`5B`5D = `7B
X    `7BCustomizeArtPopups, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec ngMenusCallbacks`5B`5D = `7B
X    `7BCustomizeNgMenus, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec ngPopupsCallbacks`5B`5D = `7B
X    `7BCustomizeNgPopups, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec allMenusCallbacks`5B`5D = `7B
X    `7BCustomizeAllMenus, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec allPopupsCallbacks`5B`5D = `7B
X    `7BCustomizeAllPopups, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec artGeneralCallbacks`5B`5D = `7B
X    `7BCustomizeGeneral, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec addGeneralCallbacks`5B`5D = `7B
X    `7BCustomizeGeneral, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec ngGeneralCallbacks`5B`5D = `7B
X    `7BCustomizeGeneral, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec allGeneralCallbacks`5B`5D = `7B
X    `7BCustomizeGeneral, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec artConfirmCustomCallbacks`5B`5D = `7B
X    `7BCustomizeConfirm, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec addConfirmCustomCallbacks`5B`5D = `7B
X    `7BCustomizeConfirm, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec ngConfirmCustomCallbacks`5B`5D = `7B
X    `7BCustomizeConfirm, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec allConfirmCustomCallbacks`5B`5D = `7B
X    `7BCustomizeConfirm, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec artPostCustomCallbacks`5B`5D = `7B
X    `7BCustomizePost, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec addPostCustomCallbacks`5B`5D = `7B
X    `7BCustomizePost, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec ngPostCustomCallbacks`5B`5D = `7B
X    `7BCustomizePost, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec allPostCustomCallbacks`5B`5D = `7B
X    `7BCustomizePost, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec artMailCustomCallbacks`5B`5D = `7B
X    `7BCustomizeMail, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec addMailCustomCallbacks`5B`5D = `7B
X    `7BCustomizeMail, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec ngMailCustomCallbacks`5B`5D = `7B
X    `7BCustomizeMail, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec allMailCustomCallbacks`5B`5D = `7B
X    `7BCustomizeMail, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec artReadCustomCallbacks`5B`5D = `7B
X    `7BCustomizeRead, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec addReadCustomCallbacks`5B`5D = `7B
X    `7BCustomizeRead, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec ngReadCustomCallbacks`5B`5D = `7B
X    `7BCustomizeRead, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec allReadCustomCallbacks`5B`5D = `7B
X    `7BCustomizeRead, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec addSaveCustomCallbacks`5B`5D = `7B
X    `7BCustomizeSave, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec allSaveCustomCallbacks`5B`5D = `7B
X    `7BCustomizeSave, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec artSaveCustomCallbacks`5B`5D = `7B
X    `7BCustomizeSave, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
Xstatic XtCallbackRec ngSaveCustomCallbacks`5B`5D = `7B
X    `7BCustomizeSave, NULL`7D,
X    `7BNULL, NULL`7D,
X`7D;
X
Xstatic XtCallbackRec menuOKCallback`5B`5D = `7B
X    `7BmenuOK, NULL`7D,
X    `7BNULL, NULL`7D
X`7D;
Xstatic XtCallbackRec menuApplyCallback`5B`5D = `7B
X    `7BmenuApply, NULL`7D,
X    `7BNULL, NULL`7D
X`7D;
Xstatic XtCallbackRec menuCancelCallback`5B`5D = `7B
X    `7BmenuCancel, NULL`7D,
X    `7BNULL, NULL`7D
X`7D;
Xstatic XtCallbackRec cgOKCallback`5B`5D = `7B
X    `7BcgOK, NULL`7D,
X    `7BNULL, NULL`7D
X`7D;
Xstatic XtCallbackRec cgApplyCallback`5B`5D = `7B
X    `7BcgApply, NULL`7D,
X    `7BNULL, NULL`7D
X`7D;
Xstatic XtCallbackRec cgCancelCallback`5B`5D = `7B
X    `7BcgCancel, NULL`7D,
X    `7BNULL, NULL`7D
X`7D;
Xstatic XtCallbackRec ccOKCallback`5B`5D = `7B
X    `7BccOK, NULL`7D,
X    `7BNULL, NULL`7D
X`7D;
Xstatic XtCallbackRec ccApplyCallback`5B`5D = `7B
X    `7BccApply, NULL`7D,
X    `7BNULL, NULL`7D
X`7D;
Xstatic XtCallbackRec ccCancelCallback`5B`5D = `7B
X    `7BccCancel, NULL`7D,
X    `7BNULL, NULL`7D
X`7D;
Xstatic XtCallbackRec cmOKCallback`5B`5D = `7B
X    `7BcmOK, NULL`7D,
X    `7BNULL, NULL`7D
X`7D;
Xstatic XtCallbackRec cmApplyCallback`5B`5D = `7B
X    `7BcmApply, NULL`7D,
X    `7BNULL, NULL`7D
X`7D;
Xstatic XtCallbackRec cmCancelCallback`5B`5D = `7B
X    `7BcmCancel, NULL`7D,
X    `7BNULL, NULL`7D
X`7D;
Xstatic XtCallbackRec cpOKCallback`5B`5D = `7B
X    `7BcpOK, NULL`7D,
X    `7BNULL, NULL`7D
X`7D;
Xstatic XtCallbackRec cpApplyCallback`5B`5D = `7B
X    `7BcpApply, NULL`7D,
X    `7BNULL, NULL`7D
X`7D;
Xstatic XtCallbackRec cpCancelCallback`5B`5D = `7B
X    `7BcpCancel, NULL`7D,
X    `7BNULL, NULL`7D
X`7D;
Xstatic XtCallbackRec crOKCallback`5B`5D = `7B
X    `7BcrOK, NULL`7D,
X    `7BNULL, NULL`7D
X`7D;
Xstatic XtCallbackRec crApplyCallback`5B`5D = `7B
X    `7BcrApply, NULL`7D,
X    `7BNULL, NULL`7D
X`7D;
Xstatic XtCallbackRec crCancelCallback`5B`5D = `7B
X    `7BcrCancel, NULL`7D,
X    `7BNULL, NULL`7D
X`7D;
Xstatic XtCallbackRec addCallback`5B`5D = `7B
X    `7BaddClick, NULL`7D,
X    `7BNULL, NULL`7D
X`7D;
Xstatic XtCallbackRec removeCallback`5B`5D = `7B
X    `7BremoveClick, NULL`7D,
X    `7BNULL, NULL`7D
X`7D;
X
X/*
X * External data from buttons.c
X */
Xexternaldef(ngmenus) Widget ngMenus`5B5`5D;
Xexternaldef(artmenus) Widget artMenus`5B7`5D;
Xexternaldef(allmenus) Widget allMenus`5B5`5D;
Xexternaldef(allmenus) Widget addMenus`5B3`5D;
Xexternaldef(addpopupbuttons) Widget *AddPopupButtons = NIL(Widget);
Xexternaldef(ngpopupbuttons)  Widget *NgPopupButtons = NIL(Widget);
Xexternaldef(allpopupbuttons) Widget *AllPopupButtons = NIL(Widget);
Xexternaldef(artpopupbuttons) Widget *ArtPopupButtons = NIL(Widget);
Xexternaldef(artwinpopupbuttons) Widget *ArtWinPopupButtons = NIL(Widget);
X
Xexternalref XtCallbackRec addQuitCallbacks`5B`5D;
Xexternalref XtCallbackRec addFirstCallbacks`5B`5D;
Xexternalref XtCallbackRec addLastCallbacks`5B`5D;
Xexternalref XtCallbackRec addAfterCallbacks`5B`5D;
Xexternalref XtCallbackRec addUnsubCallbacks`5B`5D;
Xexternalref XtCallbackRec ngExitCallbacks`5B`5D;
Xexternalref XtCallbackRec ngQuitCallbacks`5B`5D;
Xexternalref XtCallbackRec ngReadCallbacks`5B`5D;
Xexternalref XtCallbackRec ngOpenCallbacks`5B`5D;
Xexternalref XtCallbackRec ngNextCallbacks`5B`5D;
Xexternalref XtCallbackRec ngPrevCallbacks`5B`5D;
Xexternalref XtCallbackRec ngCatchUpCallbacks`5B`5D;
Xexternalref XtCallbackRec ngSubscribeCallbacks`5B`5D;
Xexternalref XtCallbackRec ngUnsubCallbacks`5B`5D;
Xexternalref XtCallbackRec ngGotoCallbacks`5B`5D;
Xexternalref XtCallbackRec ngToggleGroupsCallbacks`5B`5D;
Xexternalref XtCallbackRec ngAllGroupsCallbacks`5B`5D;
Xexternalref XtCallbackRec ngRescanCallbacks`5B`5D;
Xexternalref XtCallbackRec ngPrevGroupCallbacks`5B`5D;
Xexternalref XtCallbackRec ngSelectCallbacks`5B`5D;
Xexternalref XtCallbackRec ngMoveCallbacks`5B`5D;
Xexternalref XtCallbackRec ngDisconnectCallbacks`5B`5D;
Xexternalref XtCallbackRec ngCheckPointCallbacks`5B`5D;
Xexternalref XtCallbackRec ngPostCallbacks`5B`5D;
Xexternalref XtCallbackRec ngGripeCallbacks`5B`5D;
Xexternalref XtCallbackRec allQuitCallbacks`5B`5D;
Xexternalref XtCallbackRec allSubCallbacks`5B`5D;
Xexternalref XtCallbackRec allFirstCallbacks`5B`5D;
Xexternalref XtCallbackRec allLastCallbacks`5B`5D;
Xexternalref XtCallbackRec allAfterCallbacks`5B`5D;
Xexternalref XtCallbackRec allUnsubCallbacks`5B`5D;
Xexternalref XtCallbackRec allGotoCallbacks`5B`5D;
Xexternalref XtCallbackRec allOpenCallbacks`5B`5D;
Xexternalref XtCallbackRec allSelectCallbacks`5B`5D;
Xexternalref XtCallbackRec allMoveCallbacks`5B`5D;
Xexternalref XtCallbackRec allToggleCallbacks`5B`5D;
Xexternalref XtCallbackRec allScrollCallbacks`5B`5D;
Xexternalref XtCallbackRec allScrollBackCallbacks`5B`5D;
Xexternalref XtCallbackRec allSearchCallbacks`5B`5D;
Xexternalref XtCallbackRec allContinueCallbacks`5B`5D;
Xexternalref XtCallbackRec allCancelSearchCallbacks`5B`5D;
Xexternalref XtCallbackRec artQuitCallbacks`5B`5D;
Xexternalref XtCallbackRec artNextCallbacks`5B`5D;
Xexternalref XtCallbackRec artNextUnreadCallbacks`5B`5D;
Xexternalref XtCallbackRec artPrevCallbacks`5B`5D;
Xexternalref XtCallbackRec artLastCallbacks`5B`5D;
Xexternalref XtCallbackRec artNextGroupCallbacks`5B`5D;
Xexternalref XtCallbackRec artGotoArticleCallbacks`5B`5D;
Xexternalref XtCallbackRec artCatchUpCallbacks`5B`5D;
Xexternalref XtCallbackRec artCatchUpAllCallbacks`5B`5D;
Xexternalref XtCallbackRec artFedUpCallbacks`5B`5D;
Xexternalref XtCallbackRec artMarkReadCallbacks`5B`5D;
Xexternalref XtCallbackRec artMarkUnreadCallbacks`5B`5D;
Xexternalref XtCallbackRec artUnsubCallbacks`5B`5D;
Xexternalref XtCallbackRec artScrollCallbacks`5B`5D;
Xexternalref XtCallbackRec artScrollBackCallbacks`5B`5D;
Xexternalref XtCallbackRec artScrollEndCallbacks`5B`5D;
Xexternalref XtCallbackRec artScrollBeginningCallbacks`5B`5D;
Xexternalref XtCallbackRec artSubNextCallbacks`5B`5D;
Xexternalref XtCallbackRec artSubPrevCallbacks`5B`5D;
Xexternalref XtCallbackRec artKillSessionCallbacks`5B`5D;
Xexternalref XtCallbackRec artKillLocalCallbacks`5B`5D;
Xexternalref XtCallbackRec artKillGlobalCallbacks`5B`5D;
Xexternalref XtCallbackRec artKillAuthorCallbacks`5B`5D;
Xexternalref XtCallbackRec artEditKillFileCallbacks`5B`5D;
Xexternalref XtCallbackRec artEditGlobalKillFileCallbacks`5B`5D;
Xexternalref XtCallbackRec artSubSearchCallbacks`5B`5D;
Xexternalref XtCallbackRec artAuthorSearchCallbacks`5B`5D;
Xexternalref XtCallbackRec artContinueCallbacks`5B`5D;
Xexternalref XtCallbackRec artCancelSearchCallbacks`5B`5D;
Xexternalref XtCallbackRec artNonSortedCallbacks`5B`5D;
Xexternalref XtCallbackRec artSortedCallbacks`5B`5D;
Xexternalref XtCallbackRec artStrictSortedCallbacks`5B`5D;
Xexternalref XtCallbackRec artThreadSortedCallbacks`5B`5D;
Xexternalref XtCallbackRec artPostCallbacks`5B`5D;
Xexternalref XtCallbackRec artExitCallbacks`5B`5D;
Xexternalref XtCallbackRec artCheckPointCallbacks`5B`5D;
Xexternalref XtCallbackRec artGripeCallbacks`5B`5D;
Xexternalref XtCallbackRec artListOldCallbacks`5B`5D;
Xexternalref XtCallbackRec artSaveCallbacks`5B`5D;
Xexternalref XtCallbackRec artReplyCallbacks`5B`5D;
Xexternalref XtCallbackRec artForwardCallbacks`5B`5D;
Xexternalref XtCallbackRec artFollowupCallbacks`5B`5D;
Xexternalref XtCallbackRec artFollowupReplyCallbacks`5B`5D;
Xexternalref XtCallbackRec artCancelCallbacks`5B`5D;
Xexternalref XtCallbackRec artRot13Callbacks`5B`5D;
Xexternalref XtCallbackRec artHeaderCallbacks`5B`5D;
Xexternalref XtCallbackRec artPrintCallbacks`5B`5D;
Xtypedef struct buttonList `7B
X    char *label;
X    Arg *buttonArgs;
X    unsigned int size;
X    char *message;
X`7D ButtonList;
Xexternalref ButtonList AddButtonList`5B`5D;
Xexternalref int AddPopupCount;
Xexternalref ButtonList NgButtonList`5B`5D;
Xexternalref int NgPopupCount;
Xexternalref ButtonList AllButtonList`5B`5D;
Xexternalref int AllPopupCount;
Xexternalref ButtonList ArtButtonList`5B`5D;
Xexternalref int ArtPopupCount;
Xexternalref int ArtWinPopupCount;
Xexternalref ButtonList ArtSpecButtonList`5B`5D;
Xexternalref int ArtSpecPopupCount;
Xexternalref int ArtSpecButtonListCount;
X
X#ifdef __STDC__
X#ifdef MOTIF
X#define menuBtn(type, lbl, text)`09`09`09`09`09\
X    label = XmStringLtoRCreate(text, XmSTRING_DEFAULT_CHARSET);`09`09\
X    XtSetArg(cb`5B0`5D, XmNlabelString, label);`09`09`09`09\
X    XtSetArg(cb`5B1`5D, XmNactivateCallback, type##lbl##Callbacks);`09`09\
X    if (app_resources.useGadgets)`09`09`09`09`09\
X`09XtManageChild(XmCreatePushButtonGadget(`09`09`09`09\
X`09`09type##Pulldowns`5Bi`5D, #lbl, cb, 2));`09`09`09\
X    else`09`09`09`09`09`09`09`09\
X`09XtManageChild(XmCreatePushButton(type##Pulldowns`5Bi`5D, #lbl, cb, 2));\
X    XmStringFree(label)
X
X#define menuPulldown(type, lbl)`09`09`09`09`09`09\
X    i++;`09`09`09`09`09`09`09`09\
X    type##Pulldowns`5Bi`5D = XmCreatePulldownMenu(MenuBar,#lbl, NULL, 0);`09
V\
X    XtManageChild(XmCreateSeparator(type##Pulldowns`5Bi`5D, "sep", NULL, 0))
V;\
X    label = XmStringLtoRCreate(#lbl, XmSTRING_DEFAULT_CHARSET);`09\
X    XtSetArg(cb`5B0`5D, XmNlabelString, label);`09`09`09`09\
X    XtSetArg(cb`5B1`5D, XmNsubMenuId, type##Pulldowns`5Bi`5D);`09`09`09\
X    if (app_resources.useGadgets)`09`09`09`09`09\
X`09type##Menus`5Bi`5D = XmCreateCascadeButtonGadget(MenuBar, #lbl, cb, 2);\
X    else`09`09`09`09`09`09`09`09\
X`09type##Menus`5Bi`5D = XmCreateCascadeButton(MenuBar, #lbl, cb, 2);`09\
X    XmStringFree(label)
X
X#define subMenuPulldown(type,name,lbl)`09`09`09`09`09\
X    tempPulldown = XmCreatePulldownMenu(type##Pulldowns`5Bi`5D, #name,NULL,0
V);\
X    label = XmStringLtoRCreate(lbl,XmSTRING_DEFAULT_CHARSET);`09`09\
X    XtSetArg(cb`5B0`5D, XmNlabelString, label);`09`09`09`09\
X    XtSetArg(cb`5B1`5D, XmNsubMenuId, tempPulldown);`09`09`09\
X    if (app_resources.useGadgets)`09`09`09`09`09\
X`09tempMenu = XmCreateCascadeButtonGadget(type##Pulldowns`5Bi`5D, #name, cb,
V 2);\
X    else`09`09`09`09`09`09`09`09\
X`09tempMenu = XmCreateCascadeButton(type##Pulldowns`5Bi`5D, #name, cb, 2);\
X    XtManageChild(tempMenu);`09`09`09`09`09`09\
X    XmStringFree(label);
X
X#define subMenuBtn(type,sub,name,lbl)`09`09`09`09`09\
X    label = XmStringLtoRCreate(lbl,XmSTRING_DEFAULT_CHARSET);`09`09\
X    XtSetArg(cb`5B0`5D, XmNlabelString, label);`09`09`09`09\
X    XtSetArg(cb`5B1`5D, XmNactivateCallback, sub##Callbacks);`09`09\
X    if (app_resources.useGadgets)`09`09`09`09`09\
X`09XtManageChild(XmCreatePushButtonGadget(tempPulldown, #name, cb, 2));\
X    else`09`09`09`09`09`09`09`09\
X`09XtManageChild(XmCreatePushButton(tempPulldown, #name, cb, 2));`09\
X    XmStringFree(label);
X
X#else
X#define menuBtn(type, lbl, text)`09`09`09`09`09\
X    label = DwtLatin1String(text);`09`09`09`09`09\
X    XtSetArg(cb`5B0`5D, DwtNlabel, label);`09`09`09`09`09\
X    XtSetArg(cb`5B1`5D, DwtNactivateCallback, type##lbl##Callbacks);`09\
X    if (app_resources.useGadgets)`09`09`09`09`09\
X`09XtManageChild(DwtPushButtonGadgetCreate(type##Pulldowns`5Bi`5D, #lbl, cb,
V 2));\
X    else`09`09`09`09`09`09`09`09\
X`09XtManageChild(DwtPushButtonCreate(type##Pulldowns`5Bi`5D, #lbl, cb, 2));\
X    XtFree(label)
X
X#define menuPulldown(type, lbl)`09`09`09`09`09`09\
X    i++;`09`09`09`09`09`09`09`09\
X    type##Pulldowns`5Bi`5D = DwtMenu(MenuBar,#lbl, 0, 0, `09`09`09\
X`09DwtMenuPulldown, DwtOrientationVertical, NULL, NULL, NULL);`09\
X    label = DwtLatin1String(#lbl);`09`09`09`09`09\
X    XtSetArg(cb`5B0`5D, DwtNlabel, label);`09`09`09`09`09\
X    XtSetArg(cb`5B1`5D, DwtNsubMenuId, type##Pulldowns`5Bi`5D);`09`09`09\
X    type##Menus`5Bi`5D = DwtPullDownMenuEntryCreate(MenuBar,#lbl, cb, 2);`09
V\
X    XtFree(label)
X
X#define subMenuPulldown(type,name,lbl)`09`09`09`09`09\
X    tempPulldown = DwtMenu(type##Pulldowns`5Bi`5D, #name,0,0,`09`09\
X`09DwtMenuPulldown, DwtOrientationVertical, NULL, NULL, NULL);`09\
X    label = DwtLatin1String(lbl);`09`09`09`09`09\
X    XtSetArg(cb`5B0`5D, DwtNlabel, label);`09`09`09`09`09\
X    XtSetArg(cb`5B1`5D, DwtNsubMenuId, tempPulldown);`09`09`09\
X    tempMenu = DwtPullDownMenuEntryCreate(type##Pulldowns`5Bi`5D, #name, cb,
V 2);\
X    XtManageChild(tempMenu);`09`09`09`09`09`09\
X    XtFree(label);
X
X#define subMenuBtn(type,sub,name,lbl)`09`09`09`09`09\
X    label = DwtLatin1String(lbl);`09`09`09`09`09\
X    XtSetArg(cb`5B0`5D, DwtNlabel, label);`09`09`09`09`09\
X    XtSetArg(cb`5B1`5D, DwtNactivateCallback, sub##Callbacks);`09`09\
X    if (app_resources.useGadgets)`09`09`09`09`09\
X`09XtManageChild(DwtPushButtonGadgetCreate(tempPulldown, #name, cb, 2));\
X    else`09`09`09`09`09`09`09`09\
X`09XtManageChild(DwtPushButtonCreate(tempPulldown, #name, cb, 2));`09\
X    XtFree(label);
X
X#endif
X#else /* STDC */
X#ifdef MOTIF
X#define menuBtn(type, lbl, text)`09`09`09`09`09\
X    label = XmStringLtoRCreate(text, XmSTRING_DEFAULT_CHARSET);`09`09\
X    XtSetArg(cb`5B0`5D, XmNlabelString, label);`09`09`09`09\
X    XtSetArg(cb`5B1`5D, XmNactivateCallback, type/**/lbl/**/Callbacks);`09\
X    if (app_resources.useGadgets)`09`09`09`09`09\
X`09XtManageChild(XmCreatePushButtonGadget(type/**/Pulldowns`5Bi`5D, "lbl", c
Vb, 2));\
X    else`09`09`09`09`09`09`09`09\
X`09XtManageChild(XmCreatePushButton(type/**/Pulldowns`5Bi`5D, "lbl", cb, 2))
V;\
X    XmStringFree(label)
X
X#define menuPulldown(type, lbl)`09`09`09`09`09`09\
X    i++;`09`09`09`09`09`09`09`09\
X    type/**/Pulldowns`5Bi`5D = XmCreatePulldownMenu(MenuBar,"lbl", NULL, 0);
V\
X    XtManageChild(XmCreateSeparator(type/**/Pulldowns`5Bi`5D, "sep", NULL, 0
V));\
X    label = XmStringLtoRCreate("lbl", XmSTRING_DEFAULT_CHARSET);`09\
X    XtSetArg(cb`5B0`5D, XmNlabelString, label);`09`09`09`09\
X    XtSetArg(cb`5B1`5D, XmNsubMenuId, type/**/Pulldowns`5Bi`5D);`09`09\
X    if (app_resources.useGadgets)`09`09`09`09`09\
X`09type/**/Menus`5Bi`5D = XmCreateCascadeButtonGadget(MenuBar, "lbl", cb, 2)
V;\
X    else`09`09`09`09`09`09`09`09\
X`09type/**/Menus`5Bi`5D = XmCreateCascadeButton(MenuBar, "lbl", cb, 2);\
X    XmStringFree(label)
X
X#define subMenuPulldown(type,name,lbl)`09`09`09`09`09\
X    tempPulldown = XmCreatePulldownMenu(type/**/Pulldowns`5Bi`5D, "name",NUL
VL,0);\
X    label = XmStringLtoRCreate(lbl,XmSTRING_DEFAULT_CHARSET);`09`09\
X    XtSetArg(cb`5B0`5D, XmNlabelString, label);`09`09`09`09\
X    XtSetArg(cb`5B1`5D, XmNsubMenuId, tempPulldown);`09`09`09\
X    if (app_resources.useGadgets)`09`09`09`09`09\
X`09tempMenu = XmCreateCascadeButtonGadget(type/**/Pulldowns`5Bi`5D, "name",
V cb, 2);\
X    else`09`09`09`09`09`09`09`09\
X`09tempMenu = XmCreateCascadeButton(type/**/Pulldowns`5Bi`5D, "name", cb, 2)
V;\
X    XtManageChild(tempMenu);`09`09`09`09`09`09\
X    XmStringFree(label);
X
X#define subMenuBtn(type,sub,name,lbl)`09`09`09`09`09\
X    label = XmStringLtoRCreate(lbl,XmSTRING_DEFAULT_CHARSET);`09`09\
X    XtSetArg(cb`5B0`5D, XmNlabelString, label);`09`09`09`09\
X    XtSetArg(cb`5B1`5D, XmNactivateCallback, sub/**/Callbacks);`09`09\
X    if (app_resources.useGadgets)`09`09`09`09`09\
X`09XtManageChild(XmCreatePushButtonGadget(tempPulldown, "name", cb, 2));\
X    else`09`09`09`09`09`09`09`09\
X`09XtManageChild(XmCreatePushButton(tempPulldown, "name", cb, 2));`09\
X    XmStringFree(label);
X
X#else
X#define menuBtn(type, lbl, text)`09`09`09`09`09\
X    label = DwtLatin1String(text);`09`09`09`09`09\
X    XtSetArg(cb`5B0`5D, DwtNlabel, label);`09`09`09`09`09\
X    XtSetArg(cb`5B1`5D, DwtNactivateCallback, type/**/lbl/**/Callbacks);`09\
X    if (app_resources.useGadgets)`09`09`09`09`09\
X`09XtManageChild(DwtPushButtonGadgetCreate(type/**/Pulldowns`5Bi`5D, "lbl",
V cb, 2));\
X    else`09`09`09`09`09`09`09`09\
X`09XtManageChild(DwtPushButtonCreate(type/**/Pulldowns`5Bi`5D, "lbl", cb, 2)
V);\
X    XtFree(label)
X
X#define menuPulldown(type, lbl)`09`09`09`09`09`09\
X    i++;`09`09`09`09`09`09`09`09\
X    type/**/Pulldowns`5Bi`5D = DwtMenu(MenuBar,"lbl", 0, 0, `09`09\
X`09DwtMenuPulldown, DwtOrientationVertical, NULL, NULL, NULL);`09\
X    label = DwtLatin1String("lbl");`09`09`09`09`09\
X    XtSetArg(cb`5B0`5D, DwtNlabel, label);`09`09`09`09`09\
X    XtSetArg(cb`5B1`5D, DwtNsubMenuId, type/**/Pulldowns`5Bi`5D);`09`09\
X    type/**/Menus`5Bi`5D = DwtPullDownMenuEntryCreate(MenuBar,"lbl", cb, 2);
V\
X    XtFree(label)
X
X#define subMenuPulldown(type,name,lbl)`09`09`09`09`09\
X    tempPulldown = DwtMenu(type/**/Pulldowns`5Bi`5D, "name",0,0,`09`09\
X`09DwtMenuPulldown, DwtOrientationVertical, NULL, NULL, NULL);`09\
X    label = DwtLatin1String(lbl);`09`09`09`09`09\
X    XtSetArg(cb`5B0`5D, DwtNlabel, label);`09`09`09`09`09\
X    XtSetArg(cb`5B1`5D, DwtNsubMenuId, tempPulldown);`09`09`09\
X    tempMenu = DwtPullDownMenuEntryCreate(type/**/Pulldowns`5Bi`5D, "name",
V cb, 2);\
X    XtManageChild(tempMenu);`09`09`09`09`09`09\
X    XtFree(label);
X
X#define subMenuBtn(type,sub,name,lbl)`09`09`09`09`09\
X    label = DwtLatin1String(lbl);`09`09`09`09`09\
X    XtSetArg(cb`5B0`5D, DwtNlabel, label);`09`09`09`09`09\
X    XtSetArg(cb`5B1`5D, DwtNactivateCallback, sub/**/Callbacks);`09`09\
X    if (app_resources.useGadgets)`09`09`09`09`09\
X`09XtManageChild(DwtPushButtonGadgetCreate(tempPulldown, "name", cb, 2));\
X    else`09`09`09`09`09`09`09`09\
X`09XtManageChild(DwtPushButtonCreate(tempPulldown, "name", cb, 2));\
X    XtFree(label);
X
X#endif
X#endif /* STDC */
X
X#endif /* _menus_h */
$ CALL UNPACK MENUS.H;13 777740726
$ create 'f'
X
X#if !defined(lint) && !defined(SABER)
Xstatic char XRNrcsid`5B`5D = "$Header: /net/objy27/wrld/mnt11/ricks/src/mast
Ver/xrn/mesg.c,v 1.6 1993/01/11 02:15:02 ricks Exp $";
X#endif
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * mesg.c: message box
X */
X
X#include "copyright.h"
X#include <stdio.h>
X#include "config.h"
X#include "utils.h"
X#ifndef VMS
X#include <X11/cursorfont.h>
X#include <X11/StringDefs.h>
X#include <X11/Intrinsic.h>
X#include <X11/Shell.h>
X#else
X#include <decw$include/cursorfont.h>
X#include <decw$include/StringDefs.h>
X#include <decw$include/Intrinsic.h>
X#include <decw$include/Shell.h>
X#endif
X#ifdef MOTIF
X#include <Xm/PanedW.h>
X#include <Xm/PushB.h>
X#include <Xm/RowColumn.h>
X#include <Xm/TextP.h>
X#include <Xm/Label.h>
X#include <Xm/Frame.h>
X#if (XmVERSION == 1) && (XmREVISION == 0)
X#define MOTIF_V10
X#endif
X#else /* MOTIF */
X#ifndef DwtNmenuExtendLastRow
X#define DwtNmenuExtendLastRow "menuExtendLastRow"
X#endif
X#ifndef VMS
X#include <X11/DECwDwtWidgetProg.h>
X#else
X#include <decw$include/DECwDwtWidgetProg.h>
X#endif /* VMS */
X#include "Pane.h"
X#endif /* MOTIF */
X#include "xthelper.h"
X#include "resources.h"
X#include "xrn.h"
X#include "mesg.h"
X#if defined(__STDC__) && !defined(NOSTDHDRS)
X#include <stdarg.h>
X#else
X#include <varargs.h>
X#endif
X#include <time.h>
X#include "xmisc.h"
X#include "butdefs.h"
X
Xextern void addTimeOut();
Xextern void removeTimeOut();
X
Xchar error_buffer`5B2048`5D;
X
X/* entire widget */
Xstatic Widget MesgTopLevel = (Widget) 0;
X/* text window */
Xstatic Widget MesgText = (Widget) 0;
Xstatic Widget dismiss;
X
Xstatic Boolean MesgMapped = False;
X
X#define MESG_SIZE 4096
Xstatic char MesgString`5BMESG_SIZE`5D;
X/*
X * If you have a window larger than 512 characters across, or there is
X * an info message to be displayed that is longer than 512 characters,
X * then someone should be shot!
X */
Xstatic char InfoString`5B512`5D;
X
X/* whether or not we should hold off redisplaying the pane */
Xstatic int delay_redisplay = 0;
X
X/*ARGSUSED*/
Xstatic void
XdismissFunction(widget, event, string, count)
XWidget widget;
XXEvent *event;
XString *string;
XCardinal *count;
X`7B
X    MesgMapped = False;
X    XtUnmapWidget(MesgTopLevel);
X    return;
X`7D
X
X#ifndef MOTIF
X#define XmNlabelString DwtNlabel
X#define XmNactivateCallback DwtNactivateCallback
X#define XmNborderWidth DwtNborderWidth
X#endif
X
XBUTTON(dismiss)
X
Xstatic void displayMesgString()
X`7B
X    if (delay_redisplay `7C`7C (! MesgText))
X`09return;
X
X#ifdef MOTIF
X    XmTextSetString(MesgText, MesgString);
X    XmTextShowPosition(MesgText, (XmTextPosition) strlen(MesgString));
X#else
X    DwtSTextSetString(MesgText, MesgString);
X    DwtTextShowPosition(MesgText, strlen(MesgString));
X#endif
X`7D
X
Xvoid mesgDisableRedisplay()
X`7B
X    delay_redisplay = 1;
X    return;
X`7D
X
Xvoid mesgEnableRedisplay()
X`7B
X    delay_redisplay = 0;
X    displayMesgString();
X    return;
X`7D
X
X/*ARGSUSED*/
X/*VARARGS2*/
X#if defined(__STDC__) && !defined(NOSTDHDRS)
Xvoid
XmesgPane(int type, char *fmtString, ...)
X#else
Xvoid
XmesgPane(type, fmtString, va_alist)
Xint type;`09`09/* XRN_INFO, XRN_SERIOUS */
Xchar *fmtString;
X#endif
X#if !defined(__STDC__) `7C`7C defined(NOSTDHDRS)
X    va_dcl
X#endif
X/*
X * brings up a new vertical pane, not moded
X *
X * the pane consists of 3 parts: title bar, scrollable text window,
X * button box
X */
X`7B
X    va_list args;
X    Widget pane, buttonBox, label;
X    Arg paneArgs`5B4`5D;
X    Position x = 0;`09`09`09`09`09`09    /* ggh */
X    Position y = 0;`09`09`09`09`09`09    /* ggh */
X    Dimension width = 0;`09`09`09`09`09    /* ggh */
X    Dimension height = 0;`09`09`09`09`09    /* ggh */
X#ifdef MOTIF
X    Widget frame;
X#endif
X    static Arg labelArgs`5B`5D = `7B
X#ifdef MOTIF
X`09`7BXmNlabelString, (XtArgVal) NULL`7D,
X`09`7BXmNskipAdjust, (XtArgVal) True`7D,
X#else
X`09`7BDwtNlabel,`09(XtArgVal) NULL`7D,
X#endif
X    `7D;
X    static Arg boxArgs`5B`5D = `7B
X#ifdef MOTIF
X`09`7BXmNnumColumns,`09`09(XtArgVal) 1`7D,
X`09`7BXmNadjustLast, `09(XtArgVal) False`7D,
X`09`7BXmNorientation,`09(XtArgVal) XmHORIZONTAL`7D,
X`09`7BXmNpacking,`09`09(XtArgVal) XmPACK_COLUMN`7D,
X`09`7BXmNallowResize,`09(XtArgVal) True`7D,
X`09`7BXmNskipAdjust, `09(XtArgVal) True`7D,
X#else
X`09`7BDwtNresizeHeight,`09(XtArgVal) True`7D,
X`09`7BDwtNresizeWidth,`09(XtArgVal) False`7D,
X`09`7BDwtNorientation,`09(XtArgVal) DwtOrientationHorizontal`7D,
X`09`7BDwtNmenuPacking,`09(XtArgVal) DwtMenuPackingTight`7D,
X`09`7BDwtNmenuExtendLastRow, (XtArgVal) False`7D,
X`09`7BDwtNborderWidth,`09(XtArgVal) 3`7D,
X`09`7BDwtNentryBorder,`09(XtArgVal) 2`7D,
X`09`7BDwtNchildOverlap,`09(XtArgVal) False`7D,
X`09`7BDwtNmenuNumColumns,`09(XtArgVal) 4`7D,
X`09`7BDwtNmin,`09`09(XtArgVal) 30`7D,
X#endif
X    `7D;
X    static Arg shellArgs`5B`5D = `7B
X`09`7BXtNinput, (XtArgVal) True`7D,
X`09`7BXtNsaveUnder, (XtArgVal) False`7D,
X    `7D;
X    static Arg textArgs`5B`5D = `7B
X#ifdef MOTIF
X`09`7BXmNrows,`09`09(XtArgVal) 10`7D,
X`09`7BXmNcolumns,`09`09(XtArgVal) 80`7D,
X`09`7BXmNwordWrap, `09`09(XtArgVal) TRUE`7D,
X`09`7BXmNscrollVertical, `09(XtArgVal) TRUE`7D,
X`09`7BXmNeditMode,  `09`09(XtArgVal) XmMULTI_LINE_EDIT`7D,
X`09`7BXmNeditable,`09`09(XtArgVal) FALSE`7D,
X#else
X`09`7BDwtNrows,`09`09(XtArgVal) 10`7D,
X`09`7BDwtNcols,`09`09(XtArgVal) 80`7D,
X`09`7BDwtNwordWrap, `09`09(XtArgVal) TRUE`7D,
X`09`7BDwtNscrollVertical, `09(XtArgVal) TRUE`7D,
X`09`7BDwtNeditable,`09`09(XtArgVal) FALSE`7D,
X#endif
X    `7D;
X    time_t tm;
X    char addBuff2`5BMESG_SIZE`5D;
X
X#if defined(__STDC__) && !defined(NOSTDHDRS)
X    va_start(args, fmtString);
X#else   `20
X    va_start(args);
X#endif
X
X    tm = time(0);
X
X    if ((XRNState & XRN_X_UP) != XRN_X_UP) `7B
X`09(void) fprintf(stderr, "%-24.24s: ", ctime(&tm));
X`09(void) vfprintf(stderr, fmtString, args);
X`09(void) fprintf(stderr, "\n");
X`09return;
X    `7D
X
X    if ((type == XRN_INFO) && (app_resources.info == False)) `7B
X`09(void) vsprintf(InfoString, fmtString, args);
X`09infoNow(InfoString);
X`09return;
X    `7D
X
X    if (MesgTopLevel != (Widget) 0 && !MesgMapped) `7B
X`09(void) vsprintf(addBuff2, fmtString, args);
X`09(void) sprintf(MesgString, "%-24.24s: %s", ctime(&tm), addBuff2);
X#ifdef MOTIF
X`09XmTextSetString(MesgText, MesgString);
X`09XmTextShowPosition (MesgText, (XmTextPosition) strlen(MesgString));
X#else
X`09DwtSTextSetString(MesgText, MesgString);
X`09DwtTextShowPosition(MesgText, strlen(MesgString));
X#endif
X`09XtMapWidget(MesgTopLevel);
X#if defined(MOTIF) && !defined(MOTIF_V10)
X`09XmProcessTraversal(dismiss, XmTRAVERSE_CURRENT);
X#endif
X`09MesgMapped = True;
X`09return;
X    `7D
X    if (MesgTopLevel == (Widget) 0) `7B
X`09MesgTopLevel = XtCreatePopupShell("Information", topLevelShellWidgetClass
V,
X`09`09`09`09`09  TopLevel, shellArgs, XtNumber(shellArgs));
X
X`09XtSetArg(paneArgs`5B0`5D, XtNx, &x);
X`09XtSetArg(paneArgs`5B1`5D, XtNy, &y);
X`09XtSetArg(paneArgs`5B2`5D, XtNwidth, &width);
X`09XtSetArg(paneArgs`5B3`5D, XtNheight, &height);
X`09XtGetValues(TopLevel, paneArgs, XtNumber(paneArgs));
X`09XtSetArg(paneArgs`5B0`5D, XtNx, x);
X`09XtSetArg(paneArgs`5B1`5D, XtNy, y);
X`09XtSetArg(paneArgs`5B2`5D, XtNwidth, width);
X`09XtSetArg(paneArgs`5B3`5D, XtNheight, height);
X#ifdef MOTIF
X`09pane = XtCreateManagedWidget("pane", xmPanedWindowWidgetClass,
X`09`09`09`09    MesgTopLevel, paneArgs, XtNumber(paneArgs));
X#else
X`09pane = DwtPaneCreate(MesgTopLevel, "mesgPane",`20
X`09`09`09`09    paneArgs, 3);
X`09XtManageChild(pane);
X#endif
X
X`09(void) vsprintf(addBuff2, fmtString, args);
X`09(void) sprintf(MesgString, "%-24.24s: %s", ctime(&tm), addBuff2);
X
X`09if (labelArgs`5B0`5D.value == 0) `7B
X#ifdef MOTIF
X`09    labelArgs`5B0`5D.value = (XtArgVal) XmStringLtoRCreate(
X`09`09"Information (can be left up or dismissed)",
X`09`09XmSTRING_DEFAULT_CHARSET);
X#else
X`09    labelArgs`5B0`5D.value = (XtArgVal) DwtLatin1String(
X`09`09"Information (can be left up or dismissed)");
X#endif
X`09`7D
X#ifdef MOTIF
X`09label = XtCreateManagedWidget("label", xmLabelWidgetClass, pane,
X`09`09`09`09      labelArgs, XtNumber(labelArgs));
X
X`09XmStringFree((XmString)labelArgs`5B0`5D.value);
X`09frame = XtCreateManagedWidget("mesgFrame", xmFrameWidgetClass,
X`09`09`09`09`09pane, NULL, 0);
X`09MesgText = XmCreateScrolledText(frame, "text",`20
X`09`09`09`09`09 textArgs, XtNumber(textArgs));
X#else
X`09label = DwtLabelCreate(pane, "label",`20
X`09`09`09`09      labelArgs, XtNumber(labelArgs));
X
X`09XtFree(labelArgs`5B0`5D.value);
X`09XtManageChild(label);
X`09MesgText = DwtSTextCreate(pane, "text",`20
X`09`09`09`09`09 textArgs, XtNumber(textArgs));
X#endif
X`09XtManageChild(MesgText);
X
X#ifdef MOTIF
X`09buttonBox = XtCreateManagedWidget("box", xmRowColumnWidgetClass, pane,
X`09`09`09`09`09  boxArgs, XtNumber(boxArgs));
X`09dismissArgs`5B1`5D.value = (XtArgVal) XmStringLtoRCreate(
X`09`09`09`09`09`09"Dismiss",
X`09`09`09`09`09`09XmSTRING_DEFAULT_CHARSET);
X`09dismiss = XtCreateManagedWidget("dismiss", xmPushButtonWidgetClass,
X`09`09`09      buttonBox, dismissArgs, XtNumber(dismissArgs));
X   `20
X`09XmStringFree((XmString) dismissArgs`5B1`5D.value);
X#else
X`09buttonBox = DwtMenuCreate(pane, "box",`20
X`09`09`09`09`09  boxArgs, XtNumber(boxArgs));
X`09XtManageChild(buttonBox);
X`09dismissArgs`5B1`5D.value = (XtArgVal) DwtLatin1String("Dismiss");
X`09XtManageChild(DwtPushButtonCreate(buttonBox, "dismiss",
X`09`09`09      dismissArgs, XtNumber(dismissArgs)));
X   `20
X`09XtFree(dismissArgs`5B1`5D.value);
X#endif
X`09XtRealizeWidget(MesgTopLevel);
X
X`09XtPopup(MesgTopLevel, XtGrabNone);
X#if defined(MOTIF) && !defined(MOTIF_V10)
X`09XmProcessTraversal(dismiss, XmTRAVERSE_CURRENT);
X#endif
X`09MesgMapped = True;
X
X`09/* xthCenterWidgetOverCursor(MesgTopLevel); */
X
X`09displayMesgString();
X    `7D else `7B
X`09long len;
X`09long newlen;
X`09char addBuff`5BMESG_SIZE`5D;
X
X`09(void) vsprintf(addBuff2, fmtString, args);
X`09(void) sprintf(addBuff, "%-24.24s: %s", ctime(&tm), addBuff2);
X`09len = strlen(MesgString);
X`09newlen = strlen(addBuff);
X
X`09if ((len + 10 + newlen) > MESG_SIZE) `7B
X`09    (void) strcpy(MesgString, addBuff);
X`09`7D else `7B`09
X`09    if (! (type & XRN_APPEND)) `7B
X`09`09(void) strcat(&MesgString`5Blen`5D, "\n--------\n");
X`09`09(void) strcat(&MesgString`5Blen + 10`5D, addBuff);
X`09    `7D else `7B
X`09`09(void) strcat(&MesgString`5Blen`5D, "\n");
X`09`09(void) strcat(&MesgString`5Blen + 1`5D, addBuff);
X`09    `7D
X`09`7D
X
X`09displayMesgString();
X    `7D
X   `20
X    return;
X`7D
X
X
Xvoid
Xinfo(msg)
Xchar *msg;
X/*
X * put an informational 'msg' into the top information label
X */
X`7B
X    Arg infoLineArg`5B1`5D;
X#ifdef MOTIF
X    XmString labelString;
X#else
X    DwtCompString labelString;
X#endif
X
X    if ((XRNState & XRN_X_UP) == XRN_X_UP) `7B
X#ifdef MOTIF
X`09labelString = XmStringLtoRCreate(msg, XmSTRING_DEFAULT_CHARSET);
X`09XtSetArg(infoLineArg`5B0`5D, XmNlabelString, labelString);
X`09XtSetValues(TopInfoLine, infoLineArg, XtNumber(infoLineArg));
X`09XmStringFree(labelString);
X#else
X`09labelString = DwtLatin1String(msg);
X`09XtSetArg(infoLineArg`5B0`5D, DwtNlabel, labelString);
X`09XtSetValues(TopInfoLine, infoLineArg, XtNumber(infoLineArg));
X`09XtFree(labelString);
X#endif
X    `7D else `7B
X`09(void) fprintf(stderr, "XRN: %s\n", msg);
X    `7D
X    return;
X`7D
X
X
Xvoid
XinfoNow(msg)
Xchar *msg;
X/*
X * put an informational 'msg' into the top information label and force an up
Vdate
X */
X`7B
X    info(msg);
X    if ((XRNState & XRN_X_UP) == XRN_X_UP) `7B
X`09xthHandleAllPendingEvents();
X    `7D
X    return;
X`7D
X
$ CALL UNPACK MESG.C;52 2070842528
$ create 'f'
X#ifndef MESG_H
X#define MESG_H
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/mesg.h,v 1.5 1993/01
V/11 02:15:04 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * mesg.h: display info, warning, and error messages
X *
X */
X
X#define XRN_INFO `091<<0
X#define XRN_SERIOUS `091<<1
X#define XRN_APPEND`091<<2
X
Xextern void info _ARGUMENTS((char *));
Xextern void infoNow _ARGUMENTS((char *));
X#if defined(__STDC__) && !defined(NOSTDHDRS)
Xextern void mesgPane _ARGUMENTS((int, char *, ...));
X#else
Xextern void mesgPane();`09/* can't have a prototype here because we */
X`09`09`09/* can't know the type of "va_alist"      */
X#endif
Xextern void mesgDisableRedisplay(), mesgEnableRedisplay();
X
Xextern char error_buffer`5B2048`5D;
X
X#endif /* MESG_H */
$ CALL UNPACK MESG.H;3 102425870
$ create 'f'
X#ifndef MODES_H
X#define MODES_H
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/modes.h,v 1.4 1993/0
V1/11 02:15:05 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * modes.h: definitions of the various XRN modes
X */
X
X/* definition of the modes */
X#define NEWSGROUP_MODE  0
X#define ARTICLE_MODE    1
X#define ADD_MODE        2
X#define ALL_MODE        3
X#define NO_MODE         4
X#define MAX_MODE        4
X
X#define ABORT -1
X#define ERROR 0
X#define NOMATCH 1
X#define MATCH 2
X#define WINDOWCHANGE 3
X#define EXIT 4
X
X#define BACK 0
X#define FORWARD 1
X
X#endif /* MODES_H */
$ CALL UNPACK MODES.H;13 2137344251
$ create 'f'
X#ifndef UsrIncDir
X#define UsrIncDir $(DESTDIR)/usr/include
X#endif
X#ifndef TestSrcDir
X#define TestSrcDir $(TOP)/tests
X#endif
X#ifndef SharedLibXm
X#if HasSunOSSharedLibraries
X#define SharedLibXm YES
X#else
X#define SharedLibXm NO
X#endif
X#endif
X#ifndef SharedLibMrm
X#if HasSunOSSharedLibraries
X#define SharedLibMrm YES
X#else
X#define SharedLibMrm NO
X#endif
X#endif
X#ifndef SharedLibUil
X#if HasSunOSSharedLibraries
X#define SharedLibUil YES
X#else
X#define SharedLibUil NO
X#endif
X#endif
X#ifndef SharedXmRev
X#define SharedXmRev 4.0
X#endif
X#ifndef SharedMrmRev
X#define SharedMrmRev 4.0
X#endif
X#ifndef SharedUilRev
X#define SharedUilRev 4.0
X#endif
X#ifndef XmClientDepLibs
X#define XmClientDepLibs $(DEPMRMLIB) $(DEPXMLIB) $(DEPXMULIB) $(DEPXTOOLLIB)
V $(DEPXLIB)
X#endif
X#ifndef XmClientLibs
X#define XmClientLibs $(MRMLIB) $(XMLIB) $(XMULIB) $(XTOOLLIB) $(XLIB)
X#endif
X
X#if SHAPE
X    MWM_DEFINES = -DSHAPE
X#else
X    MWM_DEFINES = /*nothing*/
X#endif
X
X      USRINCDIR = UsrIncDir
X        TESTSRC = TestSrcDir
X     MWIDGETSRC = $(LIBSRC)/Xm
X   MRESOURCESRC = $(LIBSRC)/Mrm
X         UILSRC = $(CLIENTSRC)/uil
X            UIL = $(UILSRC)/uil
X
X#ifndef _Use
X#ifdef UseInstalled
X#define _Use(a,b) a
X#else
X#define _Use(a,b) b
X#endif
X#endif
X
X#if SharedLibXm
X       DEPXMLIB = /*_Use($(USRLIBDIR),$(MWIDGETSRC))/libXm.so.$(SOXMREV)*/
X          XMLIB = _Use(-lXm,-L$(MWIDGETSRC) -lXm)
X#else
X       DEPXMLIB = _Use($(USRLIBDIR),$(MWIDGETSRC))/libXm.a
X          XMLIB = LoaderLibPrefix _Use(-lXm,$(MWIDGETSRC)/libXm.a)
X#endif
X#if SharedLibMrm
X      DEPMRMLIB = /*_Use($(USRLIBDIR),$(MRESOURCESRC))/libMrm.so.$(SOMRMREV)
V*/
X         MRMLIB = _Use(-lMrm,-L$(MRESOURCESRC) -lMrm)
X#else
X      DEPMRMLIB = _Use($(USRLIBDIR),$(MRESOURCESRC))/libMrm.a
X         MRMLIB = LoaderLibPrefix _Use(-lMrm,$(MRESOURCESRC)/libMrm.a)
X#endif
X#if SharedLibUil
X      DEPUILLIB = /*_Use($(USRLIBDIR),$(UILSRC))/libUil.so.$(SOUILREV)*/
X         UILLIB = _Use(-lUil,-L$(UILSRC) -lUil)
X#else
X      DEPUILLIB = _Use($(USRLIBDIR),$(UILSRC))/libUil.a
X         UILLIB = LoaderLibPrefix _Use(-lUil,$(UILSRC)/libUil.a)
X#endif
X
X  LINTMRESOURCE = _Use($(USRLIBDIR),$(MRESOURCESRC))/llib-libMrm.ln
XLINTXMWIDGETLIB = _Use($(USRLIBDIR),$(MWIDGETSRC))/llib-libXm.ln
X     LINTUILLIB = _Use($(USRLIBDIR),$(UILSRC))/llib-lUil.ln
X
X#if HasSunOSSharedLibraries
X        SOXMREV = SharedXmRev
X       SOMRMREV = SharedMrmRev
X       SOUILREV = SharedUilRev
X#endif
$ CALL UNPACK MOTIF.TMPL;2 1898664293
$ create 'f'
X.TH MXRN 1 "3 Mar 1993" "X"
X.\" $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/xrn.man,v 1.9 1993/
V02/04 18:22:44 ricks Exp $
X.\"
X.\" xrn - an X-based NNTP news reader
X.\"
X.\" Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X.\"
X.\" Permission to use, copy, modify, and distribute this software and its
X.\" documentation for any purpose and without fee is hereby granted, provide
Vd
X.\" that the above copyright notice appear in all copies and that both that
X.\" copyright notice and this permission notice appear in supporting
X.\" documentation, and that the name of the University of California not
X.\" be used in advertising or publicity pertaining to distribution of`20
X.\" the software without specific, written prior permission.  The University
X.\" of California makes no representations about the suitability of this
X.\" software for any purpose.  It is provided "as is" without express or
X.\" implied warranty.
X.\"
X.\" THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X.\" THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`2
V0
X.\" FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X.\" ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X.\" RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X.\" CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X.\" CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X.\"
X.ds XR \fImxrn\fP
X.ds NS `60.newsrc'
X.ds NG \fBNewsgroup\fP
X.ds AR \fBArticle\fP
X.ds AL \fBAll\fP
X.ds AD \fBAdd\fP
X.ds XD `60`7E/.Xdefaults'
X.\"
X.SH NAME
Xmxrn/dxrn \- an X-based interface to the USENET news system that uses the
XNNTP remote news server
X.\"
X.SH SYNOPSIS
X\*(XR is an X-based interface to the USENET news system
Xthat uses the NNTP remote news server for accessing newsgroups
Xand articles.
XBy using the NNTP server, users can read news from personal workstations
Xwith the program accessing the news groups and articles from a central
Xrepository on the local area network.
XThis manual page applies to version 6.18.
X.\"
X.SH DESCRIPTION
X.PP
X.nh
X\*(XR
X`5B-addBindings bindings`5D
X`5B-addButtonList list`5D
X`5B-addPopupList list`5D
X.br
X`5B-allBindings bindings`5D
X`5B-allButtonList list`5D
X`5B-allPopupList list`5D
X.br
X`5B-artBindings bindings`5D
X`5B-artButtonList list`5D
X`5B-artPopupList list`5D
X.br
X`5B-artSpecButtonList list`5D
X`5B+/-authorFullName`5D
X`5B-authorLength len`5D
X.br
X`5B+/-autoRead`5D
X`5B+/-autoWrap`5D
X`5B+/-busyIcon`5D
X`5B-busyIconName`5D
X.br
X`5B-busyIconPixmap`5D
X`5B+/-cc`5D
X`5B+/-ccForward`5D
X`5B-compBreakLength len`5D
X.br
X`5B-compLineLength len`5D
X`5B-compRows rows`5D
X`5B+/-confirm list`5D`20
X.br
X`5B-deadLetters file`5D
X`5B-defaultlines num`5D
X`5B+/-delayedPrint`5D
X.br
X`5B+/-displayLineCount`5D
X`5B+/-displayLocalTime`5D
X.br
X`5B-distribution dist`5D
X`5B+/-dumpCore`5D
X`5B-editorCommand command`5D
X.br
X`5B+/-executableSignatures`5D
X`5B+/-extraMailHeaders`5D
X`5B-hostName hostname`5D
X.br
X`5B-iconGeometry +X+Y`5D`20
X`5B-ignoreNewsgroups list`5D
X`5B-includeCommand command`5D
X.br
X`5B+/-includeHeader`5D
X`5B-includePrefix "prefix text"`5D
X`5B+/-includeSep`5D
X.br
X`5B+/-info`5D
X`5B+/-killFiles`5D`20
X`5B-layout geometry`5D
X`5B-leaveHeaders list`5D
X.br
X`5B+/-localSignatures`5D
X`5B-lockFile name`5D
X`5B-mailer "mailer command"`5D
X.br
X`5B-maxLines number`5D`20
X`5B-mhPath path`5D
X`5B-minLines number`5D
X`5B-newsrcFile file`5D`20
X.br
X`5B-ngBindings bindings`5D
X`5B-ngButtonList list`5D
X`5B-ngPopupList list`5D
X.br
X`5B-nntpServer name`5D`20
X`5B-onlyShow num`5D
X`5B-organization organization`5D
X.br
X`5B+/-pageArticles`5D
X`5B-personalName "name"`5D
X`5B-pointerBackground`5D
X.br
X`5B-pointerForeground`5D
X`5B-popupButton button`5D
X`5B-printCommand command`5D
X.br
X`5B-replyPath mailPath`5D
X`5B-replyTo name`5D
X`5B-rescanTime time`5D
X`5B+/-resetSave`5D
X.br
X`5B+/-retainKilled`5D
X`5B-retryLimit count`5D
X`5B-retryPopupCount count`5D
X.br
X`5B-retryPopupTimeout secs`5D
X`5B-retryPause secs`5D
X`5B-saveDir directory`5D
X.br
X`5B-saveMode mode`5D
X`5B-saveNewsrcFile file`5D`20
X`5B-savePostings file`5D`20
X.br
X`5B-saveString string`5D
X`5B-signatureFile file`5D`20
X`5B+/-signatureNotify`5D`20
X.br
X`5B-sortedSubjects sort-type`5D
X`5B-stripHeaders list`5D
X`5B-subjectLength len`5D
X.br
X`5B+/-subjectRead`5D`20
X`5B-tmpDir directory`5D
X`5B-topLines number`5D
X.br
X`5B-unreadIconName "name"`5D
X`5B-unreadIconPixmap pixmap`5D
X`5B+/-updateNewsrc`5D
X.br
X`5B+/-useGadgets`5D
X`5B+/-verboseKill`5D
X`5B+/-watchProgress`5D
X`5B-watchUnread list`5D
X.br
X`5B+/-xrefMarkRead`5D
X.\"
X
XAlong with the standard toolkit options:
Xdisplay, geometry, xrm, and iconic.
X.\"
X.SH BASIC OPERATION
X.PP
X\fBDon't let the size of this manual page alarm you.\fP
X\*(XR is easy to learn on-line without reading
Xthe documentation.
XThis manual page describes many features that may be obvious to the
Xcasual observer, along with a large section on customization
X(such as choosing colors and fonts).
XIt also describes how to use scroll bars, buttons, and select text;
Xif you have used an X toolkit application before, the section
Xtitled "BUTTONS, SCROLL BARS, and SELECTION" can be skipped.
X.PP
X\*(XR uses the \*(NS file to determine what groups need to be read.
XIf the \*(NS file does not exist, it is created, and the
Xuser is subscribed to the news group `60news.announce.newusers'.
X.PP
X\*(XR has four modes of operation: \*(AD, \*(NG, \*(AL,
Xand \*(AR modes.
X\*(AD mode will be entered on startup if there are any groups
Xthat the news system knows about that are not in the \*(NS file
X(\fIi.e.,\fP new groups).
XIn \*(AD mode, the user is given a list of new groups.
XGroups can then be subscribed to and placed in the \*(NS file
Xat the first position, the last position, or after a group already
Xin the \*(NS file.
XWhen \*(AD mode is exited, any remaining groups are
Xadded unsubscribed, so the user is not asked about them the
Xnext time \*(XR is started.
XOn exit from \*(AD mode, or on startup if there are no new groups,
X\*(NG mode is entered.
X\*(NG mode displays the subscribed to groups that have unread
Xarticles and the range of available articles.
XThe basic functions available in this mode allow the user to
Xread a group, mark all articles in a group as read, unsubscribe from a group
V,
Xmove the cursor around the newsgroup window,
Xchange the order of the list of newsgroups,
Xre-visit the most recently visited group, and quit \*(XR.
XIn addition, the user can
Xsubscribe to a group and specify its position in the \*(NS file,`20
Xquery the news server for new articles and groups, and
Xgo to groups that are either not subscribed to or currently have
Xno unread articles (\fIi.e.,\fP groups not displayed on the screen).
X.br
XFrom \*(NG mode the user can go into \*(AL mode.
XIn \*(AL mode the user is presented with a sorted list of
Xall known groups and their subscription status (subscribed
Xor unsubscribed) and can change their status or location
Xin the \*(NS file.
XOn exiting \*(AL mode the user is placed back in \*(NG mode.
X.br
XIn order to read the articles in a particular group, the user goes
Xfrom \*(NG mode to \*(AR mode.
XIn \*(AR mode the user can sequence through the articles in
Xthe group forward or backward, mark a group of articles
Xas read or unread, mark all articles in the current group
Xas read, unsubscribe to the current group,`20
Xreturn to the last article visited, search forward or backward
Xfor an article subject (either for the exact subject or for
Xa regular expression in the subject), locally kill all articles with a
Xparticular subject, and quit (saving all changes) or exit
X(leaving all articles marked unread).
XIn addition, the user can save the current
Xarticle in a file, post an article to the group, post a followup
Xto the current article, mail a reply to the author of an article, and
Xreturn to \*(NG mode.
X.\"
X.SH NEWS SYSTEM
X.sp
XThe news system is a set of bulletins, discussion groups, program sources,
Xand other bits of information distributed around the world under the
Xname `60USENET'.
XThe information is generally called `60news' and is broken up into
X`60newsgroups'.
XEach newsgroup deals with a subject or set of subjects.
XThe subjects for newsgroups are varied:  from discussions about particular
Xversions of UNIX to movie reviews, from information on the X window system
Xto commentary on current social and political issues.
X.PP
XFor information on what newsgroups are available, answers to commonly
Xasked questions, and newsgroup etiquette, read the articles in the
Xnewsgroup `60news.announce.newsusers'.  Users who are new to the USENET
Xare strongly encouraged to become familiar with the contents of the
Xarticles in `60news.announce.newusers' before posting any messages.
X.\"
X.SH NEWS SERVER
X.PP
XIn order to run \*(XR, you must have access to an NNTP news server.
XIf you do not have access to such a server and would like to set one
Xup, see the "USENET Software:
XHistory and Sources" posting in news.announce.newusers for information
Xabout where to get the appropriate software.
XEither the file `60/usr/local/lib/rn/server' (this filename may be
Xconfigured differently at some sites) must contain the name
Xof the server machine, the environment variable NNTPSERVER must be
Xset to the name of the server machine, the
X\fBnntpServer\fP Xdefault must be set to the name of the server machine,
Xor the `60-nntpServer' flag must be specified on the command line
X(with the order of precedence being command line,
XXdefault, environment variable, file).
XThe name can be the actual host name of the NNTP server
X(i.e. shambhala.berkeley.edu) or the internet number (i.e. 128.32.132.54).
XIf someone else has installed \*(XR at your site,
Xthen it is probably already configured to use the correct news server
Xand you don't have to worry about it.
X.\"
X.SH SCREEN LAYOUT
X.PP
XThe screen displayed by \*(XR consists of seven sections:
Xa title bar, two scrollable text windows, two information bars,
Xand two button boxes.
XThe title bar displays the current version of the program.
XThe top text window displays information based on the mode.
XIn \*(AD mode, the window displays all groups that are
Xnot currently in the \*(NS file, one per line.
XIn \*(NG mode, the
Xwindow displays the groups containing unread articles;
Xeach group represented by a line of the form:
X.sp
X.ce 100
XUnread news in <group name>           <num> article(s) + <old> old
X.ce 0
X.sp
X<group name> is the name of the group,
X<num> is the number of unread articles, and <old> is the number of
Xread articles that are still available (i.e. have not been expired) on
Xthe news server.  If "List old" is toggled on, then the word "Unread"
Xwill not appear on the lines of newsgroups with no unread articles,
Xand furthermore, the words "news in" will not appear on the lines of
Xnewsgroups with no available articles at all.
X.PP
XIn \*(AR mode, the window displays a list of subjects
Xfor the articles in the current group, with each subject line
Xbeing represented by a line of the form:
X.sp
X.ce 100
X`5B+u`5D`5BSP`5D <num>    <subject of the article> `5B<lines>`5D <author>
X.ce 0
X.sp
Xwhere <num> is the article number, <lines> is the number of lines in
Xthe article (when available), and <author> is the author of the
Xarticle.  A `60+' in the first position
Xmeans that the article has been read, a `60u' in the first position
Xmeans that the article has been marked as unread, a 'S' in the second
Xposition means that the article has been saved to a file, and a 'P' in
Xthe second position means that the article has been printed.
X.PP
Xin the top button box, and error messages.
XThe top button box has buttons that are specific to the mode
Xand apply to the information in the top text window.
XThe bottom text window displays articles in \*(AR mode
Xand a list of all known groups and their subscription status in \*(AL
Xmode.
XThe bottom information bar displays information about the mode,
Xthe buttons in the bottom button box, and error messages.
XThe bottom button box has buttons that are specific to the mode
Xand apply to the information in the bottom text window.
X.SH BUTTONS, SCROLL BARS, AND SELECTION
X.PP
XAll button and text selection commands are done with the
Xleft mouse button.
XSingle-line text selection is accomplished by
Xclicking the left mouse button on the desired line.
XMultiple-line selection is accomplished by clicking the
Xleft mouse button on the first line, holding the button down,
Xdragging the mouse to the last line, and releasing the mouse button.
XExtended selection can be done by clicking on an article or range of
Xarticles, then using shift-click to add or remove an article from the
Xselection.
XSelected lines appear in reverse video (the foreground and background
Xcolors are switched).
XThe text windows are scrolled with the scroll bar on the
Xright side of the window.
XClicking the left mouse button in the scroll bar will scroll the
Xtext up or down some fraction of a page; the `60slider' or `60elevator' in t
Vhe
Xscrollbar can be dragged to perform more rapid scrolls.
X.\"
X.SH MODES
X.PP
XThe next few sections describe the individual modes in \*(XR.
XEach button in the various modes is described with the label for the button
Xand the name of the button.
XThe name of the button can be used in X resources, in the button
Xlists, and in the bindings tables.`20
X.br
XNote that not all buttons will appear in the button boxes; you can use the
Xcustomization menus to determine which functions appear in the button boxes
Xand popup menus. See the section of this manual titled `60CUSTOMIZATIONS' fo
Vr
Xfurther information.
X.\"
X.SH ADD MODE
X.PP
X\*(AD mode is entered when new groups have been detected
X(groups that the news system knows about but are not in the \*(NS file).
X.br
XThis allows you to determine what to do to these groups (subscribe or ignore
Xthem).
X.IP "Quit (addQuit)"
XAdd remaining groups in the list to \*(NS as unsubscribed;
Xgo to group mode.
X.IP "Add First (addFirst)"
XAdd the current group(s) to the beginning of the \*(NS file and
Xmark as subscribed.
XThe current group is the selected group(s), or the group
Xon the line containing the cursor.
X.IP "Add Last (addLast)"
XAdd the current group(s) to the end of the \*(NS file and
Xmark as subscribed.
X.IP "Add After Group (addAfter)"
XAdd the current group(s) after a group already in the \*(NS.
XA dialog box is used to allow the user to enter the name of the
Xgroup to add the group after.
XThe mouse cursor must be in the dialog box
Xfor \*(XR to accept text (however, it does not have to be
Xin the type-in area).
XThe dialog box has two options: \fBabort\fP and \fBadd\fP.
XNo other buttons on the screen will work until the user
Xhas selected an option in the dialog box.
XHitting carriage return is the same as clicking the
X\fBadd\fP button (in all \*(XR dialog boxes hitting carriage
Xreturn is the same as clicking in the rightmost button of the
Xdialog box).
X.IP "Add Unsubscribed (addUnsub)"
XAdd the current group(s) to the end of the \*(NS file
Xand mark as unsubscribed.
X
X.SH NEWSGROUP MODE
X.PP
X\*(NG mode is normally the mode that \*(XR starts up in. The window at the
Xtop of the screen displays the list of subscribed groups that have new news
Xarticles (ones that you haven't read) and provides control over which groups
Xare visited.
X.br
XDouble clicking the left mouse button on a newsgroup entry will enter the
Xnewsgroup.
X.IP "exit (ngExit)"
XQuit \*(XR, leaving the \*(NS file unchanged since the
Xlast `60rescan' operation or `60checkpoint'.
XIf `60updateNewsrc' is on, then the \*(NS file is kept up to
Xdate with the last time \*(AR mode was exited.
X.IP "Quit (ngQuit)"
XQuit \*(XR. The \*(NS file is updated to account for the articles read
Xand \*(XR exits.
X.IP "Read Group (ngRead)"
XRead the articles in the current group.
XThe current group is either the one selected (if one is selected)
Xor the first group in the list. The first article in the group is read, if
Xthe `60Auto Read' flag is turned on. The `60Open Newsgroup' function can be
V used
Xto avoid reading the first article.
X.br
XIf all groups have been read, the user can still access
Xgroups by using the \fBgoto newsgroup\fP command.
X.IP "Open Group (ngOpen)"
XOpen a newsgroup without reading the first article. This command is useful
Xfor groups with large articles, such as source groups, where you may not wan
Vt
Xto read the initial article.
X.br
XThe current group is either the one selected (if one is selected)
Xor the first group in the list.`20
X.IP "Next (ngNext)"
XMove the cursor to the next group, leaving the articles in
Xthe current group untouched.
X.IP "Prev (ngPrev)"
XMove the cursor to the previous group, leaving the articles in
Xthe current group untouched.
X.IP "Catch Up (ngCatchUp)"
XMark all articles in the current group as read.
X.IP "Subscribe (ngSubscribe)"
XSubscribe to a group.
XA dialog box is used to allow the user to enter the
Xname of the group.
XThe dialog box has the following options:
X\fBabort\fP,`20
X\fBprev group\fP (subscribe to the previous group visited),
X\fBfirst\fP (put group in the beginning of the \*(NS file),
X\fBlast\fP (put group in the end of the \*(NS file), and
X\fBcurrent position\fP (put group at the position of the cursor).
XThis command can also be used to change the position of a subscribed
Xgroup.
XHitting carriage return after typing in the name is the same as
Xclicking the \fBcurrent position\fP button.
X.IP "Unsubscribe (ngUnsub)"
XUnsubscribe from the current group.
X.IP "Goto Newsgroup (ngGoto)"
XGo to an arbitrary newsgroup. The first unread article is displayed.
XIf all articles in the group have been read, the last
Xarticle in the group is displayed.
XThe name specified can be a substring of the group name or
Xa regular expression.
X.IP "Toggle Groups (ngToggleGroups)"
XToggle group display mode from verbose mode (showing information on all
Xsubscribed groups) to normal mode (showing information only on subscribed
Xgroups with new news).
X.IP "All Groups (ngAllGroups)"
XDisplay all of the groups that exist, their subscription status,
Xand a set of buttons for changing the status.
X.IP "Rescan (ngRescan)"
XQuery the server for any new groups or articles.
X.IP "Prev Group (ngPrevGroup)"
XRe-visit the previous group visited.
X.IP "Select Groups (ngSelect)"
XRecords the groups currently selected.
XIf no groups are selected, nothing is recorded.
X.IP "Move (ngMove)"
XMoves the groups previously selected with the
X\fBselect groups\fP command to the current cursor position.
XIf the cursor is currently inside the groups
Xto be moved, no groups are moved.
XIf any other button is invoked after
X\fBselect groups\fP and before \fBmove\fP,
Xthe selection is lost, and no groups are
Xmoved.
X.IP "Checkpoint (ngCheckPoint)"
XUpdate the \*(NS file. `20
X\*(XR normally updates the \*(NS file on `60rescan' and `60quit'
Xin \*(NG mode.`20
XThis allows you to update the \*(NS file without exiting \*(XR
Xor reconnecting to the server (see also 'artCheckPoint').
X.IP "Post (ngPost)"
XPost an article to a newsgroup. `20
XSee "post" under \*(AR mode for more information.
X.IP "Gripe (ngGripe)"
XSend a gripe (bug, bug fix, complaint, feature request, etc.) to
Xthe authors of the program.
X.\"
X.SH ALL MODE
X.PP
X\*(AL mode allows the user to change both the subscription status
Xand the \*(NS file position of any available group.
XAll operations can apply to multiple groups.
XThus, the user should never have to use a text editor on the \*(NS file.
X.br
XDouble-clicking on a newsgroup name in the list will cause the group
Xto be read. You can use the `60open group' function to open a group without
Xreading the first article.
X.IP "Quit (allQuit)"
XUpdate the \*(NS file and return to group mode.
X.IP "Subscribe (allSub)"
XSubscribe to the current group, leaving it
Xat its current position in the \*(NS file.
X.IP "Subscribe First (allFirst)"
XSubscribe to the current group and add it to
Xthe beginning of the \*(NS file.
X.IP "Subscribe Last (allLast)"
XSubscribe to the current group and add it to the end of the \*(NS file.
X.IP "Subscribe After Group (allAfter)"
XSubscribe to the current group and add it after a particular group
Xin the \*(NS file (which is entered with the use of a dialog box).
X.IP "Unsubscribe (allUnsub)"
XUnsubscribe the current group.
X.IP "Goto Group (allGoto)"
XGo to the current newsgroup.
X.IP "Open Group (allOpen)"
XOpen a newsgroup without automatically reading the first article.
XThe currently selected group (or the first group in the selection) is opened
V.
X.IP "Select Groups (allSelect)"
X.IP "Move (allMove)"
XSame as the "select groups" and "move" buttons in \*(NG mode.
XThese functions are used to re-order groups.
X.IP "Toggle Order (allToggle)"
XToggle the order of the newsgroups in the window between \*(NS order
Xand alphabetical order.
X.IP "Scroll Forward (allScroll)"
XScroll the all groups window forward a page.
X.IP "Scroll Backward (allScrollBack)"
XScroll the all groups window backwards a page.
X.IP "Search (allSearch)"
XSearch the all groups window for a group.
X.IP "Continue Search (allContinue)"
XContinue the all groups search.
X.IP "Cancel Search (allCancelSearch)"
XCancel the all groups search.
X.\"
X.SH ARTICLE MODE
X.PP
X\*(AR mode is used for reading and manipulating articles in a single group.
XWhen a group is entered, the list of article subjects
Xdisplayed contains those from the first unread
Xarticle to the last available article.
XPrevious articles can be obtained by using the \fBprev\fP or
X\fBsubject previous\fP commands.
XDouble clicking the left mouse button on an article entry will display the
Xarticle.
X.IP "Quit (artQuit)"
XUpdate the \*(NS file and return to group mode.
X.IP "Next (artNext)"
XDisplay the selected article, if any; otherwise,
Xdisplay the next article in the current group.
XReturn to \*(NG mode after the last article has been reached.
X.IP "Next Unread (artNextUnread)"
XDisplay the selected article if it is unread; otherwise,
Xdisplay the first unread article AFTER the cursor position.
XIf no unread articles exist, \*(XR returns to \*(NG mode.
X.IP "Prev (artPrev)"
XDisplay the selected article, if any; otherwise,
Xdisplay the previous article in the current group.
X.IP "Last (artLast)"
XDisplay the last article accessed before the
Xcurrently displayed one.
XThis command only keeps track of one previously
Xaccessed article, so invoking it repeatedly
Xsimply toggles the display between two articles.
X.IP "Next Newsgroup (artNextGroup)"
XGo directly to the next newsgroup with unread news
X(bypass newsgroup mode).
X.IP "Goto Article (artGotoArticle)"
XGo to the specified article number. Articles read in previous sessions can
Xbe accessed using this command.
X.IP "Catch Up (artCatchUp)"
XMark all articles in the current group as read;
Xreturn to \*(NG mode.
XIf a particular article is selected, catch up from the
Xbeginning of the group to the selected article.
X.IP "Fed Up (artFedUp)"
XMark all articles in the current group as read;
Xgo to the next newsgroup.
X.IP "Mark Read (artMarkRead)"
XMark an article (or group of articles) as read.
XThis command marks either the selected article(s)
Xor the article the cursor is on, and leaves
Xthe cursor at its current position.
X.IP "Mark Unread (artMarkUnread)"
XMark an article (or group of articles) and unread.
XThis command marks either the selected article(s)
Xor the article the cursor is on, and
Xleaves the cursor at its current position.
XWhen an article is marked as unread, a 'u' is
Xplaced in the far left column next to the article's
Xsubject.
XThe \fBnext\fP, \fBprev\fP, \fBsubject next\fP,
Xand \fBsubject prev\fP buttons will all display
Xthis article if they come across it, but the
X\fBnext unread\fP button will not.
XThe only way to mark an article as read once
Xit has been marked with a 'u' is to use the
X\fBmark read\fP function.
X.IP "Unsubscribe (artUnsub)"
XUnsubscribe from the current group; return to \*(NG mode.
X.IP "Scroll Forward (artScroll)"
XScroll the article text forward a page.
X.IP "Scroll Backward (artScrollBack)"
XScroll the article text backward a page.
X.IP "Scroll End (artScrollEnd)"
XScroll the article text to the end.
X.IP "Scroll Beginning (artScrollBeginning)"
XScroll the article text to the beginning.
X.IP "Scroll Line (artScrollLine)"
XScroll the article text forward one line.
X.IP "Scroll Back Line (artScrollBackLine)"
XScroll the article text backward one line.
X.IP "Subject Next (artSubNext)"
XFind and display the next article with the same subject as the current artic
Vle
X(stripping the '`5BrR`5D`5BeE`5D:' garbage).
XIf there are no more articles with the current subject and
Xthere are more unread articles, the first unread article is
Xselected.
XIf there are no more articles with the current subject and there
Xare no more unread articles, \*(AR mode is exited.
X.IP "Subject Prev (artSubPrev)"
XFind and display the previous article with the same subject
Xas the current article. The search will proceed past the current list of
Xarticles to scan articles read in previous sessions.
X.IP "Session Kill (artKillSession)"
XMark all articles with the current subject as read, for
Xthis session only.
X.IP "Local Kill (artKillLocal)"
XMark all articles with the current subject as read for this group,
Xand for this and all future sessions.
X.IP "Global Kill (artKillGlobal)"
XMark all articles with the current subject as read for all groups,
Xand for this and all future sessions.
X.IP "Author Kill (artKillAuthor)"
XMark all articles by the current author as read for this session only.
X.IP "Subject Search (artSubSearch)"
XBegin a regular expression subject search.
XWhen this button is invoked, a window pops up
Xquerying the user for a regular expression (of the
Xform used in \fBed\fP), and a direction in which to
Xsearch.
XIf a regular expression is not typed in, the
Xlast regular expression is used, and the search direction
Xis the one specified in the dialog box (this
Xcan be used to switch the direction of the search
Xwithout retyping the expression).
X.IP "Continue (artContinue)"
XContinue the last regular expression search
Xby searching for the same regular expression
Xin the same direction.
X.IP "Cancel Search (artCancelSearch)"
XCancel the regular expression search.
X.IP "Article Order (artNonSorted)"
XChange the order of entries in the subject window to be sorted by
Xarticle number.
X.IP "Subject Order (artSorted)"
XChange the order of entries in the subject window to be sorted by
Xarticle number, with groups of articles with the same subject
Xgrouped together.
Xor sorted by subject.
X.IP "Strict Order (artStrictSorted)"
XChange the order of entries in the subject window to be sorted by
Xthe subject only. (This can be useful for sources groups).
X.IP "Post (artPost)"
XPost an article to the current group.
XA scrollable, editable text window will appear with
Xa header and the user's appropriate signature file included.
XThe appropriate signature file is the usual signature file name
X`60`7E/.signature' followed by either a `60-' and a  newsgroup name
Xsubstring, or followed by a `60.' and `60followup', `60forward', `60gripe',
X`60reply' or `60post' according to the posting mode.  For example if you
Xwant to post a followup article in comp.sources.x then xrn uses the
Xfirst valid signature file in the following order:
X.sp
X.in +0.5i
X.nf
X`7E/.signature-comp.sources.x
X`7E/.signature-comp.sources
X`7E/.signature-comp
X`7E/.signature.followup
X`7E/.signature
X.fi
X.in -0.5i
X.sp
XAn appropriate header will be generated with a number
Xof blank header fields that if left blank will be
Xdeleted from the posting.
XThe editor defaults to the standard Xtoolkit editor,
Xand the default can be overridden
Xby using the command line option -editorCommand or by
Xsetting the same Xdefault (see the section on command
Xline arguments).
XThe mouse buttons can be used to select text in this window (which can then
V be
Xplaced in a file, for example).
X.sp
XThere are four buttons at the bottom of the window: \fBabort\fP,
X\fBsend\fP (to post the article), \fBsave\fP (to save the article
Xin a file), and \fBinclude\fP (include the text of the article in
Xthe reply or followup).
XThe \fBinclude article\fP button is
Xomitted if there is no current article (e.g. if the user is sending a
X"Gripe" or if "post" was selected from \*(NG mode).
XOnly one article or message window can be active at a time.
XOnly one post (or followup or reply) window can be active at a time.
X.IP "Exit (artExit)"
XExit article mode, marking all articles listed
Xin the top window as unread.
X.IP "Checkpoint (artCheckPoint)"
XUpdate the \*(NS file. `20
X\*(XR normally updates the \*(NS file on `60rescan' and `60quit'
Xin \*(NG mode.`20
XThis allows you to update the \*(NS file without exiting \*(XR
Xor reconnecting to the server (see also 'ngCheckPoint').
X.IP "Gripe (artGripe)"
XSend a gripe (bug, bug fix, complaint, feature request, etc.) to
Xthe authors of the program.
X.IP "List Old (artListOld)"
XList all articles available in the group, even those that have been read.
XNote that this button does not toggle (clicking this button twice will no
Xput you back to where you were).
X.IP "Save (artSave)"
XSave the current article in a file, or use the current article
Xas standard input to a command.
XThe save command will pop up a dialog box for the filename.
XThe dialog box has two buttons: \fBabort\fP and \fBsave\fP.
XIf the filename begins with a `60`7C', the article will be sent to the comma
Vnd
Xspecified after the `60`7C'.
XOtherwise, the article will be appended to the file specified.
XIf the name is relative (does not begin with `60/' or `60`7E'), it will be
Xprepended by `60`7E/News/'.
XIf the name begins with a `60+' the name is assumed to be a MH mail
Xfolder and a `60refile' command will be done on the article.
XIf no name is specified, it will be saved in `60`7E/News/<groupname>', where
X`60<groupname>' is the name of the current group with the first letter
Xcapitalized (following the
X.IR rn (1)
Xarticle saving conventions).
XIf \-saveMode is set to `60subdirs', then `60`7E/News/<groupname>/' will
Xbe used instead of `60`7E/News/'. Multiple articles can be selected and save
Vd
Xwith one command. If the filename contains the characters `60%d', the articl
Ve
Xnumber will replace that string; otherwise, the group of articles will be
Xappended into a single save file.
XFor VMS, piping of articles to commands (`60`7C') is not supported.
XFile names are used as given. If no filename is given in a `60save' command,
Xthe group name will be used for a filename (with second and subsequent perio
Vds
Xconverted to underscores; for example, `60comp.os_vms'. Subdirs save mode on
XVMS uses the group name to create a subdirectory for saving the articles.
X.IP "Reply (artReply)"
XReply (by mail) to the author of the current article.
XSee \fBpost\fP for a description of how to create and send a message.
X.IP "Forward (artForward)"
XSend the current article to another person via mail.
X.IP "Followup (artFollowup)"
XPost a followup article to the current article.
XSee \fBpost\fP for a description of how to create and send an article.
X.IP "Cancel (artCancel)"
XCancel the current article.
X.IP "Rot-13 (artRot13)"
XDecrypt a encrypted article.
XIn the newsgroup `60rec.humor', occasionally articles are submitted
Xthat may offend certain people or groups of people.
XIn order to minimize the offense, these articles are posted in
Xan encrypted form.
XThis button will decrypt them.
X.IP "Translate (artXlate)"
XTranslate article from ISO 646 to ISO 8859-1.
X.IP "Toggle Header (artHeader)"
XShow the full text of an article, including the full header.
X.IP "Print Article (artPrint)"
XSend the article to the printer (see the `60printCommand' command
Xline option).
X
X.SH CUSTOMIZING MXRN
X.PP
XColors, fonts, and other \*(XR options can be
Xspecified on the command line or using X resources.
XWith the exception of the display name, all \*(XR options
Xcan be specified using X resources.
XOptions specified on the command line take precedence over those specified
Xusing X resources. In addition, \*(XR has a set of customization screens
Xthat can be used to tailor the environment without editing resource files.
XFor each customization entry below, the corresponding resource entry and
Xcustomization menu entry are described.
X
X.SH CUSTOMIZATIONS
X.PP
XThe majority of the customization functions are available in any \*(XR mode
Xby selecting the entries from the `60Customize' menu. For each of the
Xentries in this menu, the section below describes the function and the
Xassociated command-line argument. Note that the case of the entries given
Xfor the resource file and command line are case-sensitive - they must be
Xentered exactly as given.
X.br
XThe following sections describe the fields on each of the customization
Xscreens and their function.
X.TP 5
X.B Customize/Controls
XThis box provides a series of options for functions that the user wishes
Xto confirm before actions are taken. These boxes pop up to ask the user to
Xverify the invocation of "dangerous" actions (such as \fBcatch up\fP
Xand \fBunsubscribe\fP). It also provides control of `60save' functions.
X.TP 10
X.B Confirm Exit
XIf active, provides a dialog box to allow you to confirm `60quit' operations
V.
X.TP 10
X.B Confirm Exit
XIf active, provides a dialog box to allow you to confirm `60exit' operations
V.
X.TP 10
X.B Confirm NG Catch Up
XIf active, provides a dialog box to allow you to confirm `60Catch Up' operat
Vions
Xin \*(NG mode.
X.TP 10
X.B Confirm Article Catch Up
XIf active, provides a dialog box to allow you to confirm `60Catch Up' operat
Vions
Xin \*(AR mode.
X.TP 10
X.B Confirm NG Unsubscribe
XIf active, provides a dialog box to allow you to confirm `60Unsubscribe'
Xoperations in \*(NG mode.
X.TP 10
X.B Confirm Article Unsubscribe
XIf active, provides a dialog box to allow you to confirm `60Unsubscribe'
Xoperations in \*(AR mode.
X.TP 10
X.B Action Prompt at Subject Change
XIf active, provides a dialog box to allow you to decide what to do when
Xthe subject changes when reading articles.
X.TP 10
X.B Confirm Save file Overwrite
XIf active, allows you to specify what to do when a save operation finds
Xthe file you've specified already exists (replace, append, or quit).
XThe default is to append to the existing file.
X.TP 5
X.B Customize/Controls Save fields
XThese fields modify the behavior of save operations.
X.TP 10
X.B Mailbox
XIf enabled, articles are saved in 'mailbox' format - with a date header
Xline and other data to make the saved file appear to be in a format similar
Xto mail storage.
X.TP 10
X.B Headers
XIf enabled, all the header lines are saved with the article. If disabled,
Xthe article is saved as displayed (with any headers stripped as controled
Xby the `60leave headers' and `60strip headers' customizations applied.)
X.TP 10
X.B Subdirectory/One Directory
XThese controls determine how articles are saved if no directory path is
Xgiven; if `60Subdirectory' is enabled, the article is saved in a subdirector
Vy
Xof your news directory - this subdirectory is determined from the newsgroup
Xname. If `60One Directory' is enabled, the file is saved in the news directo
Vry.
XIf neither is enabled, the file is saved in your current working directory.
X.br
X.TP 5
X.B Customize/Posting
XThis box provides a series of options for controlling the posting of
Xarticles and followups.
X.TP 10
X.B Line Length/Wrap Length
XThese fields determine the behavior of word wrapping of articles.
XAny line that exceeds `60Wrap Length' characters in width will be word-wrapp
Ved
Xat the first space past the column determined by `60Line Length'.`20
XIf they are both zero, no word-wrapping takes place.
X.TP 10
X.B Signature File
XThis field provides the path to the file containing your `60signature' - any
Xpostings or mailings have the contents of this file appended. Generally used
Xto add mail address and witty sayings. The length of
Xthis file is limited to avoid `60War and Peace' signatures.
XDefaults to `60`7E/.signature'. (SYS$LOGIN:NEWS.SIGNATURE on VMS).
X.TP 10
X.B Save Postings
XThis field gives the file name of the file to use to save postings (used
Xwhen the `60save' function in the composition window is invoked.
XDefaults to `60`7E/Articles'. (SYS$SCRATCH:SAVED.POSTING on VMS.)
XNote that this is the default name used when you do not specify a
Xfile name during a save operation.
X.TP 10
X.B Dead Letters
XThis field gives the file name of the file to use to save an article that
Xcould not be posted due to an error.
XDefaults to `60`7E/dead.letters'. (SYS$SCRATCH:DEAD.LETTER on VMS).
X.TP 10
X.B Editor Command
XThis entry allows use an alternate editor for creating postings, followups,
Xforwards, gripes, and replies.
XThe entry must be a sprintf format string that contains a `60%s' where
Xthe file name should be placed. Examples are:
X.sp
X.in +0.25i
X.nf
Xxterm -e vi %s
Xxterm -e microEmacs %s
Xemacsclient %s
Xedit/tpu/display=decwindows %s `5Bonly VMS could be this verbose :-)`5D
X.fi
X.in -0.25i
X.sp
XThe resulting command should handle all editing and windowing.
XThe article being followed up or replied to is automatically included.
X.br
X.TP 10
X.B Organization
XThis field provides a value for the `60Organization' header field in posting
Vs
Xand followups. Usually set to the name of your company or other organization
V.
X.TP 10
X.B Reply To
XThis entry provides a specific address for the the Reply-To header field in
Xpostings and followups. Most news readers use this address for `60reply'
Xcommands.
X.TP 10
X.B Include Separator
XInclude or do not include the prefix text ("`7C> ") in front of included
Xarticles. The default is to include the prefix text ("`7C> ").
X.TP 10
X.B Include Prefix
XChange the standard prefix for each line of included text from the
Xdefault, "`7C> ", to the given text string.
X.br
X.TP 5
X.B Customize/Reading
XThis box provides a series of options for controlling the reading of article
Vs.
X.TP 10
X.B Subject Read
XSpecifies the action to take when using the `60doTheRightThing' function to
Xread articles. If this button is enabled, at the end of the article a
X\fBsubject next\fP function is performed. If disabled, a \fBnext unread\fP
Xfunction is performed.
X.TP 10
X.B Retain Killed
XIf enabled, articles that are killed are left in the subject listing.
XIf disabled, these articles are removed from the list.
X.TP 10
X.B Full Name
XDisplay the full name of the author or the user/hostname of the author.
XIf enabled, the entry contains the author's personal name. If disabled,
Xthe entry contains the author's path name.
X.TP 10
X.B Show Line Count
XIf enabled, the number of lines in the article (when available) is displayed
Xin the subject lines.
X.TP 10
X.B Auto Wrap
XIf enabled, articles being read are word-wrapped to fit in the space specifi
Ved
Xby the `60Line Length'. If disabled, a horizontal scrollbar is used to view
V the
Xarticle contents.
X.TP 10
X.B Use Kill Files
XEnable or disable use of kill files. If disabled, the kill files will be
Xignored.
X.TP 10
X.B Page Articles
XWhen the `60doTheRightThing' function is used to read articles, specifies
Xthe action at the end of the article. If enabled, the function will stop
Xat the end of the article. If disabled, the next article will be read.
X.TP 10
X.B Read First Article
XIf enabled, the first article in the newsgroup is read when it is opened.
XIf disabled, no articles are read.
X.TP 10
X.B Update Newsrc
XIf enabled, the \*(NS file is updated when leaving \*(AR mode.
X.TP 10
X.B Watch Kill Progress
XIf enabled, the screen is updated as each article is killed during kill
Xoperations; if disabled, the screen is updated only at the end of the
Xoperation.
X.br
X.TP 5
X.B Customize/Mailing
XThis box provides a series of options for controlling the mailing of article
Vs.
X.TP 10
X.B Reply Path
XThe path to use for mailing replies. This should be a sprintf-able string.
XThis format string is used to build a mail address
Xacceptable to mail for replies. For example, `60IN%%"%s"'.
X.br
XThe address in the articles `60Reply-To' header replaces the `60%s' in the s
Vtring
Xand the resulting line is used to provide a mail address. You must double
Xany "%" characters that appear in this string other than the "%s".
X.TP 10
X.B Personal Name
X(VMS Only) Sets your 'real' name for use in postings.`20
X.TP 10
X.B Mailer
X(UNIX Only) Specifies the command to use for mailing replies.
XThis command must take all of it's input from standard input
X(\*(XR will not build a command line).
XThe default is `60/usr/lib/sendmail -oi -t'.
X.TP 10
X.B Host Name
XSets the name of your internet host. Used for postings to specify a useful
Xpath name when the default isn't useful.
X.TP 10
X.B Include CC
XIf enabled, a `60Cc:' line is provided in the header for forwards and replie
Vs.
X.br
X.TP 5
X.B Customize/General
XThis box provides a series of options for controlling the general behavior
Xof \*(XR.
X.TP 10
X.B Top/Min/Max Lines
XThese entries control the size and behavior of the window containing the
Xlist of newsgroups and articles. `60Top Lines' specifies the number of entri
Ves
Xin the list. As articles are read, the list scrolls to maintain the current
Xarticle between `60Min Lines' and `60Max Lines'. For example, setting `60Top
V Lines'
Xto 10, `60Min Lines' to 2, and `60Max Lines' to 8 will cause the top window
V to
Xscroll unless the current article is between lines 2 and 8. This type of
Xsetting minimizes the number of times the top window must be repainted.
X.TP 10
X.B NNTP Server`20
XSupplies the name of the the NNTP server to use (name or internet number).
XIf the entry ends in two colons (`60::'), DECnet is assumed as the transport
V.
XOtherwise, TCP/IP is assumed.
X.TP 10
X.B Newsrc File
XName of the the \*(NS file to use. This file contains information on your
Xsubscribed groups and which articles have been read.
XDefaults to `60`7E/.newsrc'. (SYS$LOGIN:NEWS.RC on VMS).
XIf a file with a name of the form `60<newsrcFile>-<nntpServer>'
Xis found, it will be used. For example, .newsrc-fumble for news server node
X`60fumble'.
X.TP 10
X.B Saved Newsrc File
XSpecifies the name of the backup \*(NS file.
X.br
XBefore the \*(NS file is modified, it is saved in a backup file.
XThis entry allows you to control the name of this backup file.
XDefaults to `60`7E/.oldnewsrc'. (SYS$LOGIN:OLDNEWS.RC on VMS).
X.TP 10
X.B Temp Directory
XSpecifies the directory to use for the temporary storage of articles fetched
Xfrom the server.
XIf this option and the corresponding Xdefault do not exist,
X\*(XR will look for the environment variable \fBTMPDIR\fP.
XThe default is `60/tmp'. (SYS$SCRATCH: on VMS.)
X.B Save Directory
XSpecifies the article saving directory.
XDefaults to `60`7E/News' when \-saveMode specifies `60onedir', or`20
X`60`7E/News/newsgroup' when \-saveMode specifies `60subdirs'.
XFor VMS, defaults to SYS$SCRATCH:.`20
X.TP 10
X.B Print Command
XSet the command used for printing articles.  The article is sent
Xto the command via standard input.
XDefaults to `60lpr'. (PRINT/DELETE on VMS).
X.TP 10
X.B Rescan Time
XAmount of idle time (in seconds) before checking for new articles.
XThis rescan is only performed in \*(NG mode.
X.TP 10
X.B Popup Button
XSpecifies which mouse button will pop up the popup menus. Defaults to the
Xstandard button for the widget set being used (MB2 for XUI, MB3 for Motif).
X.TP 10
X.B Display Informational Messages
XIf enabled, display all informative messages in the message pane. If disable
Vd,
Xinformation messages are displayed in the top information line only.
XDefaults to display all information in the message pane.
X
X.SH OTHER CUSTOMIZATIONS
XThe following arguments can be provided on the command line to further
Xcustomize \*(XR. Entries in your application defaults file can be used
Xto specify these as well.
X.TP 10
X.B Watch Progress
XIf enabled, when 'Catch Up' is used to catch up to a selected position
Xin a group, the display is 'animated' so you can watch the progress of
Xthe operation.
X.br
XThe associated customization file entry is `60watchProgress'. The command li
Vne
Xargument can be \+watchProgress (enabled) or \-watchProgress (disabled).
X.TP 10
X.B -authorLength
X.B -subjectLength
XSpecifies the width of the `60subject' and `60author' fields in the subject
Xlisting.
X.TP 10
X.B \-busyIcon
XWhen set to "on", the icon image will invert when \*(XR is busy.
X.TP 10
X.B \-ccForward
XWhen set to "on", you will be included as a CC entry in forwarded articles.
X.TP 10
X.B \-compRows rows
XSpecifies the number of rows in the message composition window.
X.TP 10
X.B \-distribution
XSpecifies the default distribution for articles. The default is `60world'.
X.TP 10
X.B \-display display
Xspecification of the X display. (Not for VMS).
X.TP 10
X.B +/-dumpCore
XDump core when a signal is detected.  The X resources class for the
X"dumpCore" X resource is "Debug". `60\+dumpCore' disables the default signal
Xhandler.
X.TP 10
X.B -iconGeometry +X+Y
Xspecification of the initial \*(XR icon location.
XThe window manager may choose to ignore this specification.
X.TP 10
X.B -iconName name
Xspecification of the initial \*(XR icon name.
XThe window manager may choose to ignore this specification.
X.TP 10
X.B -iconic
Xstart up \*(XR with the window iconified.
X.TP 10
X.B \-layout =WxH+X+Y
Xspecification of the \*(XR window size and location.
XThe window manager may choose to ignore this specification.
XUsing the Customize/Save menu item saves the current geometry automatically.
X.TP 10
X.B \-leaveHeaders list
Xthe header fields to leave in the article; a comma separated case-insensitiv
Ve
Xlist of field names (\fIi.e.,\fP subject,from,organization).
XThis option takes precedence over `60stripHeaders'.
XIf the word `60all' is specified instead of a list of fields, then all heade
Vrs
Xwill be retained (This can be used in user X resources to override
Xa resource specified in the global \*(XR application defaults, or on
Xthe command line to override a resource specified in either the application
Xdefaults or the user X resources.).
X.B -lockFile name
XSpecifies the name of the lock file to use. The lock file is used to
Xavoid you running \*(XR multiple times, thus losing updates to your newsrc
Xfile.
X.TP 10
X.B -resetSave
XIf set to "on", the string in the save dialog box will be reset when you
Xexit article mode. Normally, the string is retained between entries.
X`5BExcept when the saveString is specified - see below`5D.
X.TP 10
X.B -retryPopupCount
X.B -retryPopupTimeout
X.B -retryPause
X.B -retryLimit
XSpecifies the action to be taken when the connection to the NNTP server is
Xlost. \*(XR will pause for `60retryPause' seconds between retries. A connect
Vion
Xattempt is made `60retryPopupCount' times before posting a popup window that
Xallows the user the opportunity to give up. After `60retryPopupTimout' secon
Vds,
Xthis dialog box is automatically dismissed and another retry is attempted.
XAfter trying this `60retryLimit' times, \*(XR exits.
X.TP 10
X.B \-saveString
XProvides a default value for the filename in the save dialog box.
X.TP 10
X.B \+sortedSubjects
XSpecifies the subject sorting type to be used. Use "\+sortedSubjects" to
Xgroup articles with the same subject, and "\-sortedSubjects" to display
Xarticles in article number order.
X.br
XThe associated customization file entry is `60sortedSubjects'. The command l
Vine
Xargument can be \+sortedSubjects (enabled) or \-sortedSubjects (disabled).
X.br
XWhen used in the customization file, the following values can be used:
X.b
X.nf
X       Value                                 Sort by
X    none (or off, unsorted, false)         article number
X    subject (or on, true, article, sorted) related subjects
X    strict                                 subject only
X
XYou can specify specific sorting types by including the
Xgroup name or hierarchy in the customization entry.
XFor example:
Xmxrn*sortedSubjects: subject
Xmxrn.comp.sources.x.sortedSubjects: strict
Xmxrn*binaries*sortedSubjects: strict
Xmxrn.rec.humor.funny.sortedSubjects: none
X.fi
XThis would cause most groups to appear with subject sorting, `60comp.sources
V.x'
Xto appear in strict order, binaries groups (like `60comp.binaries.ibm-pc') i
Vn
Xstrict order, and `60rec.humor.funny' in article number order.
X.b
X.TP 10
X.B \-saveDir
XSpecifies the default directory for saving articles.
X.br
XYou can specify save directories on a newsgroup basis by including the
Xgroup name or hierarchy in the customization entry.
XFor example:
Xmxrn*saveDir: `7E/News
Xmxrn.comp.sources.x.saveDir: `7E/X-sources
Xmxrn*binaries*saveDir: `7E/binaries
X.fi
XThis would cause most groups to default to `60`7E/News' for saving;
X'comp.sources.x' and binaries groups are placed in separate directories.
X.b
X.TP 10
X.B \-stripHeaders list
Xthe header fields to strip from the article; a comma separated case-insensit
Vive
Xlist of field names (\fIi.e.,\fP keywords,message-id).
XIf the word `60none' is specified instead of a list of fields,
Xthen no headers will be stripped
X(This can be used in user X resources to override
Xa resource specified in the global \*(XR application defaults, or on
Xthe command line to override a resource specified in either the
Xapplication defaults or the user X resources.).
X.TP 10
X.B -unreadIconName name
Xspecification of the \*(XR icon name when there are groups with unread artic
Vles.
XThe window manager may choose to ignore this specification.
X.TP 10
X.B -useGadgets
XIf set to "on", gadgets will be used to create the pulldown menus. Saves a
Xbit of memory - the trade-off is that the gadgets are less customizable.
X.TP 10
X.B -watchUnread
XSpecifies a list of newsgroup names to monitor. If given, this list of
Xgroups will be scanned in newsgroup mode; if any contain new news, the
Xicon title will change to the unread title. If not given, all groups
Xare watched.
X.TP 10
X.B -ngButtonList list
X.TP 10
X.B -artButtonList list
X.TP 10
X.B -artSpecButtonList list
X.TP 10
X.B -addButtonList list
X.TP 10
X.B -allButtonList list
Xuse the given list of buttons for the particular
Xmode in the order given rather than all of the buttons for the
Xmode in the default order.
XThe list is a comma separated list of button names.
XThe names of the buttons appear next after the button label
Xin the button descriptions above.
XFor example, a list of buttons for \*(NG mode might be:
XngQuit,ngRead,ngCatchUp,ngRescan,ngSubscribe,ngPost
XCustomization menus exist for buttons and menus for each mode.
X.TP 10
X.B -ngBindings bindings
X.TP 10
X.B -allBindings bindings
X.TP 10
X.B -addBindings bindings
X.TP 10
X.B -artBindings bindings
Xuse the given bindings for the key/mouse bindings for
Xthe particular mode.
XSee the X toolkit documentation on `60Translation Tables'`20
Xfor information on the format of `60bindings'.
XThe actions defined in \*(XR are the same as the button names.
XFor example, a set of bindings for \*(NG mode might be:
X.nf
X    mxrn.ngBindings: \\
X       <Key>Q:`09`09ngQuit()`09\\n\\
X       <Key>N:`09`09ngRead()`09\\n\\
X       <Key>P:`09`09ngPrev()
X.fi
X.TP 10
X.B -ngPopupList list
X.TP 10
X.B -artPopupList list
X.TP 10
X.B -addPopupList list
X.TP 10
X.B -allPopupList list
XSpecifies the list of buttons to appear in the popup menu for
Xthe given mode. The list is a comma separated list of button names.
XThe names of the buttons appear next after the button label
Xin the button descriptions above.
XFor example, a list of buttons for \*(NG mode might be:
XngQuit,ngRead,ngCatchUp,ngRescan,ngSubscribe,ngPost
XCustomization menus exist for the menus for each mode.
X.\"
X.SH X RESOURCES
X.PP
X\*(XR takes a number of specifications for colors, fonts, border widths,
Xand other program options.
X.pp
XThe format for an \*(XR X resource is:
X.sp
X.ce 100
Xdxrn.x.y....z.a: value
Xor..
Xmxrn.x.y....z.a: value
X.ce 0
X.sp
XWhere \fIx.y....z\fP specifies the path from the top level of
X\*(XR to a particular item
X(think of \*(XR as a hierarchical collection of windows, panes, and buttons,
Xand \fIx.y....z\fP is a path from the top of the hierarchy to a node
Xin the hierarchy),
X\fIa\fP is the type of default (\fIi.e.,\fP font, border,
Xforeground, background, borderWidth), and \fIvalue\fP is the value of
Xthe default (\fIi.e,.\fP a color name or hex representation, a font name,
Xa numeric value).
XSpecifying a default for a item at some point in the hierarchy will set
Xthat default for all items from that point down in the hierarchy.
XA higher level default can be overridden by specifying
Xa default at a lower level directly.
X.sp
XMXRN/DXRN widget hierarchy:
X.nf
X...mxrn or dxrn (Shell)
X  main  (Main Window)
X    MenuBar (Menu Bar)
X    vpane (Paned)
X    titlebar (Label)  (optional)
X    index (Text) (enclosed in topFrame for mxrn).
X    indexinfo (Label)
X    indexbuttons (Box)
X      buttonName (Pushbutton)
X    articleText (Text) (enclosed in botFrame for mxrn).
X    textinfo (Label)
X    textbuttons (Box)
X      buttonName (Pushbutton)
X
XcomposeTop (Shell)
X  pane (Paned)
X    headerText (Text) (enclosed in headerFrame for mxrn)
X    composeText (Text) (enclosed in textFrame for mxrn)
X    box (menu/RowColumn)
X       abort (Pushbutton)
X       send (Pushbutton)
X       save (Pushbutton)
X       includeArticle (Pushbutton)
X       includeFile (Pushbutton)
X       wrapText (PushButton)
Xdialogs...
X.fi
X.sp
XExamples of defaults are:
X.in +0.3i
X.nf
X#bindings for article mode
Xmxrn.artBindings:`09\\
X  <Key>0x20:`09doTheRightThing() \\n\\
X  Alt<Key>N:`09artNext()`09\\n\\
X  <Key>N:`09artSubNext()`09\\n\\
X  Alt<Key>P:`09artPrev()`09\\n\\
X  <Key>P:`09artSubPrev()`09\\n\\
X  Alt<Key>F:`09artFollowup()`09\\n\\
X  Alt<Key>R:`09artReply()`09\\n\\
X  Alt<Key>W:`09artSave()`09\\n\\
X  Alt<Key>C:`09artCancel()`09\\n\\
X  Alt<Key>V:`09artHeader()`09\\n\\
X  Ctrl<Key>X:`09artRot13()`09\\n\\
X  Alt<Key>u:`09artUnsub()`09\\n\\
X  Ctrl<Key>Z:`09artQuit()\\n
X\\n
X#
X#layout/scrolling control for toplevel widget
X#
Xmxrn.topLines:`0910
Xmxrn.minLines:`093
Xmxrn.maxLines:`098
X#
X# which button pops up the popup menus
X#
Xmxrn.popupButton:`092
Xmxrn.saveMode:`09onedir
Xmxrn.includePrefix:`09>
X#
X# list of popup menus. best set using customize
X#
Xmxrn.ngPopupList:`09ngQuit,ngRead,ngSubscribe,ngUnsub,ngCatchUp
Xmxrn.artPopupList:`09artQuit,artNext,artPrev,artNextUnread
X#
X# your name. please don't use mine!
X#
Xmxrn.personalName:`09Rick Murphy
Xmxrn.includeHeader:`09off
Xmxrn.includeSep:`09on
X#
X# don't update newsrc each newsgroup
X#
Xmxrn.updateNewsrc:`09off
X#
X# inhibit info messages, use kill files.
X#
Xmxrn.info:`09off
Xmxrn.killFiles:`09on
X#
X# list of buttons in various modes
X#
Xmxrn.artButtonList:`09artQuit,artFedUp,artPost
Xmxrn.ngButtonList:`09ngQuit,ngRead,ngSubscribe,ngUnsub,ngCatchUp
X#
X# leading text for 'reply' functions
X#
Xmxrn.replyPath:`09decuac::"%s"
Xmxrn.lineLength:`0972
Xmxrn.breakLength:`0980
Xmxrn.pageArticles:`09off
Xmxrn.rescanTime:`091800
Xmxrn.subjectRead:`09on
Xmxrn.replyTo:`09`09murphy@ufp.dco.dec.com
Xmxrn.organization:`09Digital Equipment Corporation, Landover MD
Xmxrn.geometry:`09`09617x750+248+214
Xmxrn.confirm:`09ngCatchUp,artCatchUp
Xmxrn.sortedSubjects:`09on
X#
X# examples of how to color pushbuttons.
X# for `60dxrn' ignore the shadowColor entries.
X#
Xmxrn*background:`09SkyBlue
Xmxrn*foreground:`09white
Xmxrn*artPrint.background:`09#e0e000
Xmxrn*artPrint.foreground:`09black
Xmxrn*artPrint.bottomShadowColor:`09#005400
Xmxrn*artPrint.topShadowColor:`09yellow
Xmxrn*artQuit.background:`09red
Xmxrn*artQuit.foreground:`09White
Xmxrn*artQuit.bottomShadowColor:`09#770000
Xmxrn*artQuit.topShadowColor:`09#ffb3cc
Xmxrn*ngRead.background:`09#00d800
Xmxrn*ngRead.foreground:`09black
Xmxrn*ngRead.bottomShadowColor:`09#005400
Xmxrn*ngRead.topShadowColor:`09green
Xmxrn*ngRescan.background:`09#e0e000
Xmxrn*ngRescan.foreground:`09black
Xmxrn*ngRescan.bottomShadowColor:`09#005400
Xmxrn*ngRescan.topShadowColor:`09yellow
Xmxrn*XmPushButton.background:`09#00d800
Xmxrn*XmPushButton.foreground:`09black
Xmxrn*XmPushButton.font:`09*-*-Menu-Medium-R-Normal-*-*-100-*-*-*-*-*-ISOLATI
VN1
X#
X# resources for the newsgroup/subject list
X#`20
Xmxrn*index.background:`09black
Xmxrn*index.foreground:`09white
X#
X# a fixed font is strongly recommended
X#
Xmxrn*index.font:`09*-*-*-Medium-R-Normal-*-*-120-*-*-M-*
Xmxrn*index.fontList:`09*-*-*-Medium-R-Normal-*-*-120-*-*-M-*
Xmxrn*XmText.background:`09black
Xmxrn*XmText.foreground:`09white
Xmxrn*XmText.font:`09*-*-*-Medium-R-Normal-*-*-120-*-*-M-*
Xmxrn*XmText.fontList:`09*-*-*-Medium-R-Normal-*-*-120-*-*-M-*
XcomposeTop*headerText*fontList:`09*-*-*-Medium-R-Normal-*-*-120-*-*-M-*
XcomposeTop*composeText*fontList:*-*-*-Medium-R-Normal-*-*-120-*-*-M-*
Xmxrn*pointerForeground:`09red
Xmxrn*leaveHeaders:`09subject, newsgroups, from, reply-to
Xmxrn*sortedSubjects:`09on
X#
X# the following is recommended for VMS users. Otherwise,
X# the `60delete' key deletes the wrong way!
X#
X*XmText.translations:`09\\
X#override \\n\\
X   Shift<Key>Delete:`09delete-previous-character()\\n\\
X`09<Key>Delete:`09delete-previous-character()\\n\\
X   Shift<Key>Linefeed:`09delete-next-word()\\n\\
X`09<Key>Linefeed:`09delete-previous-word()\\n\\
X   Shift<Key>BackSpace:`09end-of-line()\\n\\
X`09<Key>BackSpace:`09beginning-of-line()\\n\\
X    Ctrl<Key>e:         end-of-line()\\n\\
X    Ctrl<Key>j:         delete-previous-word()\\n\\
X    Ctrl<Key>h:         beginning-of-line()\\n\\
X    Ctrl<Key>r:         redraw-display()\\n\\
X    Ctrl<Key>u:         delete-to-start-of-line()\\n
X\\n
X.fi
X.in -0.3i
X
X.SH FILES
X.PP
X`7E/.newsrc`09`09description of the groups and the articles read in
X.br
X`09`09`09each group (SYS$LOGIN:NEWS.RC for VMS)
X.br
X`7E/.oldnewsrc`09`09backup of `7E/.newsrc (created at startup)
X.br
X`09`09`09(SYS$LOGIN:OLDNEWS.RC on VMS)
X.br
X`7E/.signature`09`09signature for use when sending messages
X.br
X`09`09`09(SYS$LOGIN:NEWS.SIGNATURE on VMS)
X.br
X`7E/News`09`09`09directory where articles are saved
X.br
X`09`09`09(SYS$SCRATCH: on VMS)
X.br
X`7E/Articles`09`09where `60saved' postings and messages are stored
X.br
X`09`09`09(SYS$SCRATCH:SAVED.POSTING on VMS)
X.br
X`7E/dead.letter`09`09where failed postings and messages are stored
X.br
X`09`09`09(SYS$SCRATCH:DEAD.LETTERS on VMS)
X.br
X`7E/.xrnlock`09`09lock file (SYS$LOGIN:XRN.LOCK on VMS)
X.br
X/usr/local/lib/rn/server`09location of the news server hostname
X.br
X`09`09`09(optional) (SYS$LOGIN:NNTP.SERVER on VMS)
X.br
X/usr/local/lib/news/hiddenhost`09location of the hiddenhost name
X.br
X`09`09`09(optional) (SYS$LOGIN:HIDDEN.HOST on VMS)
X.br
X/usr/local/lib/news/pathhost`09location of the path host name
X.br
X`09`09`09(optional) (SYS$LOGIN:PATH.HOST on VMS)
X.br
X/usr/local/lib/news/domain`09location of the domain name
X.br
X`09`09`09(optional) (SYS$LOGIN:DOMAIN.NAME on VMS)
X.br
X/etc/uucpname`09`09location of the UUCP name for your host
X.br
X`09`09`09(optional)
X.br
X/usr/lib/sendmail`09`09default mailer
X.br
XCHANGES`09`09`09list of changes from the previous version
X.br
XTODO`09`09`09list of bugs and things to do
X
X.SH ENVIRONMENT VARIABLES
X.PP
XNote: environment variables are implemented as logical names on VMS.
X.br
XNNTPSERVER`09`09hostname of the news server
X.br
XTMPDIR`09`09temporary directory
X.br
XDOMAIN`09`09name of your internet domain (".Berkeley.EDU", ".orst.edu")
X.br
XHIDDENHOST`09full domain-style name of the host that you want your return pa
Vth to be from ("decvax.dec.com", "Berkeley.EDU")
X.br
XHIDDENPATH`09name of the host that you want put in the Path field of message
Vs.
X.br
XUSER`09`09login name of the user.
X.br
XHOME`09`09home directory of the user.
X.br
XFULLNAME`09full name of the user, used for the From field of messages.
X.SH SEE ALSO
Xreadnews(1), rn(1), vnews(1), X(1), nntpd(8)
X
X.SH COMMENTS
X.PP
XThe name (\*(XR) is a bit of a misnomer.
X\*(XR is not an X interface to `60rn' (the terminal-based news reading
Xprogram by Larry Wall), but is an X-based news reader that has
Xhad part of the functionality of `60rn' added since a number of our
Xusers are (were?) `60rn' users (all of the code is new).
XMuch of the `60rn' functionality that \*(XR currently has was not in the ori
Vginal
Xplan (KILL files, for example).
X.sp
XThe user interface look and feel is modeled after that of `60XMH'
X(by Terry Weissman).
X.sp
XThe \*(NS file is updated on executing the `60quit' command in \*(NG
Xmode, during every `60rescan', and by `60checkpoint'.
XIf the `60updateNewsrc' option is set, the \*(NS file will be updated
Xevery time \*(AR mode is exited.
X.sp
X\*(XR catches signals and X errors and will clean up on error exit
X(remove temporary files, update the \*(NS file).
XThe cleanup will be done and then a death notifier box will
Xbe posted (if the signal is SIGHUP or SIGINT,
Xthe death notifier will be skipped
Xand the program will exit).
XThe "click to exit" button must be pressed in the death notifier box
Xfor the program to exit.
X.sp
XXREFS are handled by \*(XR, however only articles that
Xare actually read (not marked as read by 'catchup' or 'mark as read')
Xhave their XREFS chased and only groups that are currently subscribed
Xto have XREFed articles marked as read.
X.sp
XThe default specifications for color and fonts can be confusing
X(thousands of different X resources can be specified for \*(XR,
Xno two users' \*(XR displays need to be the same).
X.sp
X\*(XR uses the XHDR command of the Berkeley NNTP news server
X(XHDR is not part of the protocol defined by RFC 977).
X\*(XR will detect the presence of this command and complain
Xif it does not exist.
X.sp
XSince the NNTP protocol does not define a unique response code
Xfor server timeout, timeout recovery may not work if the format
Xof the timeout error message changes.
X.sp
X\*(XR assumes a `60smart' or `60lucky' mailer.
X.sp
X\*(XR notices that the `60.newsrc' file has been updated by another program
V while
X\*(XR is running and informs the user (and gives the user the option to quit
Xwithout updating the `60.newsrc' or to continue on).
X.sp
XArticle temporary files can be removed and \*(XR will recover.
X.sp
X\*(XR strips `60<character>`5EH' from articles.
X.sp
XThe v`7Bf,s`7Dprintf implementation included with \*(XR is from`20
XRobert A. Larson <blarson@skat.usc.edu>.
X.sp
XThe strtok implementation included with \*(XR is from
XHenry Spencer <henry@zoo.toronto.edu>.
X
X.SH BUGS
X.PP
X.sp`20
XSee TODO for a full list of bugs and things that need to be done.
X.sp
XIncomplete KILL file support.
X.sp
XSee config.h for a list of defines you may want to use based
Xon problems that may exist in your version of the X11 toolkit and widgets.
X.sp
XReport bugs and requests for features to `60murphy@ufp.dco.dec.com'
X(...decwrl!ufp.enet!murphy)
X.sp
X.\"
X.SH "ORIGINAL AUTHORS"
XEllen M Sentovich (UC Berkeley, ellen@ic.berkeley.edu, ...!ucbvax!ic!ellen)
X.br
XRick L Spickelmier (formerly UC Berkeley, now Objectivity, Inc.,
Xricks@berkeley.edu, ...!ucbvax!ricks, ricks@objy.com)
X.br
XSee the FIXERS/CHANGES files for a listing of those who have really
Xbeen doing most of the work over the last year or so!
X.br
XRick Murphy (DEC, Landover MD) VMS, XUI, and Motif port.
Xnote: Ellen Sentovich and Rick Spickelmier are responsible for writing the
Xcode. Rick Murphy is responsible for writing the bugs. Don't bother the
XBerkeley folks with reports of dxrn or mxrn bugs.
$ CALL UNPACK MXRN.MAN;1 578125936
$ create 'f'
XXRN.OBJ
XBUTTONS.OBJ
XCOMPOSE.OBJ
XCURSOR.OBJ
XDIALOGS.OBJ
XERROR_HNDS.OBJ
XKILLFILE.OBJ
XMENUS.OBJ
XMESG.OBJ
XNEWSRCFILE.OBJ
XNEWSRC_PARSE.OBJ
XRESOURCES.OBJ
XINTERNALS.OBJ
XSAVE.OBJ
XSERVER.OBJ
XUTILS.OBJ
XXMISC.OBJ
XXTHELPER.OBJ
XAVL.OBJ
XCLIENTLIB.OBJ
XT6.OBJ
XT7.OBJ
XSLIST.OBJ
XTRANSFER.OBJ
X!
X!use these libraries for Motif Developer's kit V1.0:
X!
X!Xm:DECW$MOTIF$XM.OLB/LIBRARY
X!Xt:DECW$MOTIF$XT.OLB/LIBRARY
X!Xt:CLIB.OLB/LIBRARY
X!
X!use these for Motif Developer's kit V1.1.
X!
X!sys$share:decw$motif$dxmshr/shareable
X!sys$share:decw$motif$xmshr/shareable
X!sys$share:decw$motif$xtshr/shareable
X!
X!use these for DECwindows/Motif V1.0
X!
XSYS$SHARE:DECW$DXMLIBSHR/SHAREABLE
XSYS$SHARE:DECW$XMLIBSHR/SHAREABLE
XSYS$SHARE:DECW$XTSHR/SHAREABLE
XSYS$SHARE:DECW$XLIBSHR/SHAREABLE
X!
X! Uncomment out the library you need to use
X!
X!sys$share:ucx$ipc/library`09`09! For UCX users
X!
XMULTINET_SOCKET_LIBRARY/SHAREABLE`09! For MultiNet Users
X!
$ CALL UNPACK MXRN.OPT;4 409530436
$ create 'f'
X#ifndef NEWS_H
X#define NEWS_H
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/news.h,v 1.4 1993/01
V/11 02:15:07 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X
X#ifndef AVL_H
X#include "avl.h"
X#endif
X
X/*
X * news.h: internal data structures
X *
X */
X
X
Xtypedef int art_num;`09/* easy way to pick out variables refering to article
Vs */
Xtypedef short ng_num;`09/* easy way to pick out newsgroup variables
V            */
X
Xextern avl_tree *NewsGroupTable;
Xextern int ActiveGroupsCount;
Xextern avl_tree *StringPool;
X
X/* this is indexed via 'current - first' */
Xstruct artStat `7B
X    unsigned int status;
X        /* ART_* */
X`7D;
X
X
X/* this is indexed via 'current - first' */
Xstruct article `7B
X    int position;`09/* header/body separation point (bytes)`09*/
X    char *subject;      /* subject line`09`09`09`09*/
X    char *author;       /* author name`09`09`09`09*/
X    char *lines;        /* number of lines in the article`09*/
X    char *text;`09`09/* text of the article`09`09`09*/
X    char *msgid;`09/* message ID`09`09`09`09*/
X    char *refs`5B3`5D;`09/* references`09`09`09`09*/
X    art_num parent;`09/* article number of parent`09`09*/
X    art_num child;`09/* first child of a chain`09`09*/
X`7D;
X
X
Xstruct newsgroup `7B
X    char *name;        /* name of the group
V                                 */
X    ng_num newsrc;     /* index of this group into Newsrc
V                   */
X    unsigned short status;
X        /* NG_* */
X    art_num first;     /* first available article number
V                    */
X    art_num last;      /* last article number
V                               */
X    art_num current;   /* current article number
V                            */
X    art_num initial;   /* art-num when first loaded`09`09`09    */
X    struct artStat *artStatus;/* List of per-article status info`09    */
X    struct list *nglist;  /* newsgroup entry for unsubscribed groups
V        */
X`7D;
X
X/* handle first and/or last article number changes */
Xextern void articleArrayResync _ARGUMENTS((struct newsgroup *, art_num, art_
Vnum, int));
Xextern void updateArticleArray _ARGUMENTS((struct newsgroup *, int));
X
X/*
X * NOTE: if first > last, that means that there are no articles available fo
Vr
X * the group and no articles array will exist
X */
X
X
X/* article has been read / is unread */
X#define ART_READ      0x0001
X#define ART_UNREAD    0x0002
X/* printed */
X#define ART_PRINTED   0x0004
X#define ART_UNPRINTED 0x0008
X/* article has been fetched / is unfetched */
X#define ART_FETCHED   0x0010
X#define ART_UNFETCHED 0x0020
X/* article is not available */
X#define ART_UNAVAIL   0x0040
X
X/* headers */
X#define ART_ALL_HEADERS      0x0100
X#define ART_STRIPPED_HEADERS 0x0200
X
X/* rotation */
X#define ART_ROTATED   0x0400
X#define ART_UNROTATED 0x0800
X
X/* saved */
X#define ART_SAVED   0x4000
X#define ART_UNSAVED 0x8000
X
X/* marked */
X#define ART_MARKED   0x1000
X#define ART_UNMARKED 0x2000
X
X/* killed */
X#define ART_KILLED   0x10000
X#define ART_UNKILLED 0x20000
X
X#define ART_ACTIVE   0x40000
X#define ART_INACTIVE 0x80000
X
X/* Translated */
X#define ART_XLATED`090x100000
X#define ART_UNXLATED`090x200000
X
X#define ART_CLEAR       (ART_UNREAD `7C ART_UNFETCHED `7C ART_STRIPPED_HEADE
VRS `7C ART_UNROTATED `7C ART_UNMARKED `7C ART_UNKILLED `7C ART_INACTIVE `7C
V ART_UNXLATED)
X#define ART_CLEAR_READ  (ART_READ `7C ART_UNFETCHED `7C ART_STRIPPED_HEADERS
V `7C ART_UNROTATED `7C ART_UNMARKED `7C ART_UNKILLED `7C ART_INACTIVE `7C AR
VT_UNXLATED)
X
X/* helper macros */
X#define IS_READ(art)       (((art).status & ART_READ) == ART_READ)
X#define IS_UNREAD(art)     (((art).status & ART_UNREAD) == ART_UNREAD)
X#define IS_PRINTED(art)    (((art).status & ART_PRINTED) == ART_PRINTED)
X#define IS_UNPRINTED(art)  (((art).status & ART_UNPRINTED) == ART_UNPRINTED)
X#define IS_FETCHED(art)    (((art).status & ART_FETCHED) == ART_FETCHED)
X#define IS_UNFETCHED(art)  (((art).status & ART_UNFETCHED) == ART_UNFETCHED)
X#define IS_UNAVAIL(art)    (((art).status & ART_UNAVAIL) == ART_UNAVAIL)
X#define IS_ALL_HEADERS(art) (((art).status & ART_ALL_HEADERS) == ART_ALL_HEA
VDERS)
X#define IS_ROTATED(art)    (((art).status & ART_ROTATED) == ART_ROTATED)
X#define IS_SAVED(art)      (((art).status & ART_SAVED) == ART_SAVED)
X#define IS_MARKED(art)     (((art).status & ART_MARKED) == ART_MARKED)
X#define IS_UNMARKED(art)   (((art).status & ART_UNMARKED) == ART_UNMARKED)
X#define IS_KILLED(art)     (((art).status & ART_KILLED) == ART_KILLED)
X#define IS_UNKILLED(art)   (((art).status & ART_UNKILLED) == ART_UNKILLED)
X#define IS_ACTIVE(art)     (((art).status & ART_ACTIVE) == ART_ACTIVE)
X#define IS_INACTIVE(art)   (((art).status & ART_INACTIVE) == ART_INACTIVE)
X#define IS_XLATED(art)     (((art).status & ART_XLATED) == ART_XLATED)
X `20
X `20
X#define SET_READ(art)`09   ((art).status &= `7EART_UNREAD, (art).status `7C=
V ART_READ)
X#define SET_UNREAD(art)    ((art).status &= `7EART_READ, (art).status `7C= A
VRT_UNREAD)
X#define SET_PRINTED(art) ((art).status &= `7EART_PRINTED, (art).status `7C=
V ART_PRINTED)
X#define SET_UNPRINTED(art) ((art).status &= `7EART_UNPRINTED, (art).status `
V7C= ART_UNPRINTED)
X#define SET_FETCHED(art)   ((art).status &= `7EART_UNFETCHED, (art).status `
V7C= ART_FETCHED)
X#define SET_UNFETCHED(art) ((art).status &= `7EART_FETCHED, (art).status `7C
V= ART_UNFETCHED)
X#define SET_STRIPPED_HEADERS(art) ((art).status &= `7EART_ALL_HEADERS, (art)
V.status `7C= ART_STRIPPED_HEADERS)
X#define SET_ALL_HEADERS(art) ((art).status &= `7EART_STRIPPED_HEADERS, (art)
V.status `7C= ART_ALL_HEADERS)
X#define SET_UNROTATED(art) ((art).status &= `7EART_ROTATED, (art).status `7C
V= ART_UNROTATED)
X#define SET_ROTATED(art)   ((art).status &= `7EART_UNROTATED, (art).status `
V7C= ART_ROTATED)
X#define SET_UNAVAIL(art)   ((art).status `7C= ART_UNAVAIL)
X#define SET_AVAIL(art)     ((art).status &= `7EART_UNAVAIL)
X#define SET_SAVED(art)     ((art).status &= `7EART_UNSAVED, (art).status `7C
V= ART_SAVED)
X#define SET_MARKED(art)    ((art).status &= `7EART_UNMARKED, (art).status `7
VC= ART_MARKED)
X#define SET_UNMARKED(art)  ((art).status &= `7EART_MARKED, (art).status `7C=
V ART_UNMARKED)
X#define SET_KILLED(art)    ((art).status &= `7EART_UNKILLED, (art).status `7
VC= ART_KILLED)
X#define SET_UNKILLED(art)  ((art).status &= `7EART_KILLED, (art).status `7C=
V ART_UNKILLED)
X#define SET_ACTIVE(art)    ((art).status &= `7EART_INACTIVE, (art).status `7
VC= ART_ACTIVE)
X#define SET_INACTIVE(art)  ((art).status &= `7EART_ACTIVE, (art).status `7C=
V ART_INACTIVE)
X#define SET_UNXLATED(art) ((art).status &= `7EART_XLATED, (art).status `7C=
V ART_UNXLATED)
X#define SET_XLATED(art) ((art).status &= `7EART_UNXLATED, (art).status `7C=
V ART_XLATED)
X
X#define CLEAR_TEXT(art) \
X  if ((art).text != NIL(char)) `7B \
X      FREE((art).text); \
X      (art).text = NIL(char); \
X  `7D`09
X
X#define CLEAR_SUBJECT(art) (art).subject = NIL(char)`20
X
X#define CLEAR_AUTHOR(art) (art).author = NIL(char)
X
X#define CLEAR_LINES(art) (art).lines = NIL(char)
X`20
X#define CLEAR_MSGID(art) (art).msgid = NIL(char)
X
X#define CLEAR_REFS(art) \
X`09(art).refs`5B0`5D = NIL(char); \
X`09(art).refs`5B1`5D = NIL(char); \
X`09(art).refs`5B2`5D = NIL(char);
X
X/* newsgroup is subscribed/unsubscribed to */
X#define NG_SUB      0x0001
X#define NG_UNSUB    0x0002
X/* no entry in the .newsrc for this group */
X#define NG_NOENTRY  0x0004
X/* newsgroup can be posted to / can not be posted to / is moderated */
X#define NG_POSTABLE 0x0008
X#define NG_UNPOSTABLE 0x0010
X#define NG_MODERATED 0x0020
X/* newsgroup is an alias */
X#define NG_ALIAS    0x0040
X#define NG_ALIASSEEN 0x0080
X
X#define IS_SUBSCRIBED(ng) (((ng)->status & NG_SUB) == NG_SUB)
X#define IS_NOENTRY(ng)    (((ng)->status & NG_NOENTRY) == NG_NOENTRY)
X#define IS_ALIAS(ng)`09  (((ng)->status & NG_ALIAS) == NG_ALIAS)
X#define IS_NOTALIAS(ng)`09  (((ng)->status & NG_ALIAS) == 0)
X `20
X#define SET_SUB(ng)    ((ng)->status &= `7ENG_UNSUB, (ng)->status `7C= NG_SU
VB)
X#define SET_UNSUB(ng)  ((ng)->status &= `7ENG_SUB, (ng)->status `7C= NG_UNSU
VB)
X#define CLEAR_NOENTRY(ng) ((ng)->status &= `7ENG_NOENTRY)
X
X#define EMPTY_GROUP(ng) ((ng)->last < (ng)->first `7C`7C (ng)->last == 0)
X `20
X#define CLEAR_ARTICLES(ng) currentArticles = NIL(struct article)
X
X#define CLEAR_ARTSTATUS(ng) \
X  if ((ng)->artStatus != NIL(struct artStat)) `7B \
X      FREE((ng)->artStatus); \
X      (ng)->artStatus = NIL(struct artStat); \
X  `7D`09
X
X#define INDEX(artnum)  (artnum - newsgroup->first)
X#define CURRENT        INDEX(newsgroup->current)
X#define LAST           INDEX(newsgroup->last)
X
Xextern struct newsgroup *CurrentGroup;`09/* Current group */
X
Xextern ng_num MaxGroupNumber;       /* size of the newsrc array
V                  */
X
Xextern struct newsgroup **Newsrc;   /* sequence list for .newsrc file
V            */
X
X#define NOT_IN_NEWSRC -1            /* must be less than 0 */
X
X/* not a valid group (must be less than 0) */
X#define NO_GROUP -1
X
X
X#define GROUP_NAME_SIZE 128
X
X#endif /* NEWS_H */
$ CALL UNPACK NEWS.H;33 302139486
$ create 'f'
X/* Bug in some(?) versions of lex makes /`7Bsep`7D not work in    */
X/* the expressions below, thus the silliness with unput() etc */
X
X/* FLEX (gnu lex) has some detailed, Posix-related changes    */
X/* classic lex, implied below */
X
X%`7B
X#ifdef FLEX_SCANNER
Xint yylineno = 1;
X#define YYLINE yylineno++
X#undef yywrap
X#else
X#define YYLINE
X#ifdef YYLMAX
X#undef YYLMAX
X#define YYLMAX 1000
X#endif
X#endif
X%`7D
X
Xletter            `5Ba-zA-Z`5D
Xany               `5B`5E \t\n`5D
Xdigit             `5B0-9`5D
Xsep               `5B:!`5D
X%%
X                  yyin = Newsrcfp;
X`5E`5B \t`5D*"\n"       YYLINE;
X"\n"              `7BYYLINE; return(EOL); `7D;
X"-"               return(DASH);
X","               return(COMMA);
X`7Bsep`7D             `7Byylval.character = yytext`5B0`5D; return(SEPARATOR)
V; `7D; `20
X`7Bdigit`7D+          `7Byylval.integer = atoi((char *)yytext); return(NUMBE
VR); `7D;
X`7Bletter`7D`7Bany`7D+`7Bsep`7D `7C
X`5E`7Bany`7D+`7Bsep`7D      `7B
X`09`09    char c = yytext`5Byyleng - 1`5D;
X                    yytext`5Byyleng-1`5D = '\0';
X                    yylval.string = (char *) XtNewString((char *) yytext);
X`09`09    unput(c);
X                    return(NAME);
X                  `7D;
X`5B \t`5D             ;
X`5E"options ".*"\n" `7B
X`09`09    YYLINE;
X                    optionsLine = (char *) XtNewString((char *)yytext);
X                    optionsLine`5ButStrlen(optionsLine) - 1`5D = '\0';
X                  `7D;
X%%
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/newsrc.l,v 1.3 1993/
V01/11 02:15:09 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
Xyywrap()
X`7B
X    return(1);
X`7D
X
X/*ARGSUSED*/
Xyyerror(s)
Xchar *s;
X`7B
X    /* lint/kludge */
X#ifdef lint
X    (void) yyinput();
X    (void) yyoutput(0);
X    (void) yyunput(0);
X#endif /* lint */
X`7D
X
$ CALL UNPACK NEWSRC.L;23 1265375800
$ create 'f'
X%`7B
X#if !defined(lint) && !defined(SABER)
Xstatic char XRNrcsid`5B`5D = "$Header: /net/objy27/wrld/mnt11/ricks/src/mast
Ver/xrn/newsrc.y,v 1.4 1993/01/11 02:15:12 ricks Exp $";
X#endif
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * newsrc.y - yacc parser for the newsrc file
X */
X
X#include "copyright.h"
X#include <stdio.h>
X#include "config.h"
X#include "utils.h"
X#include "avl.h"
X#include "mesg.h"
X#include "news.h"
X#include "newsrcfile.h"
X
Xextern int yylineno;
X
X%`7D
X   `20
X%union `7B
X    int integer;
X    char *string;
X    char character;
X    struct list *item;
X`7D
X
X
X%token <string>     NAME
X%token <character>  SEPARATOR
X%token <integer>    NUMBER
X%token EOL
X%token DASH
X%token COMMA
X
X%type <item> artlist
X%type <item> articles
X
X%start goal
X
X%%
Xgoal        : newsrc_file ;
X
Xnewsrc_file : newsrc_line
X            `7C newsrc_file newsrc_line ;
X
Xnewsrc_line : NAME SEPARATOR artlist EOL
X                `7B
X`09`09    struct newsgroup *newsgroup;
X`09`09    char *dummy;
X
X`09`09    if (!avl_lookup(NewsGroupTable, $1, &dummy)) `7B
X`09`09`09mesgPane(XRN_SERIOUS, "Bogus newsgroup `60%s', removing from the ne
Vwsrc file", $1);
X`09`09    `7D else `7B
X`09`09`09newsgroup = (struct newsgroup *) dummy;
X`09`09`09if (IS_NOENTRY(newsgroup)) `7B
X`09`09`09    CLEAR_NOENTRY(newsgroup);
X`09`09`09    newsgroup->status `7C= ($2 == ':' ? NG_SUB : NG_UNSUB);
X`09`09`09    newsgroup->nglist = $3;
X`09`09`09    updateArticleArray(newsgroup, False);
X`09`09`09    newsgroup->newsrc = MaxGroupNumber;
X`09`09`09    Newsrc`5BMaxGroupNumber++`5D = newsgroup;
X`09`09`09`7D else `7B
X`09`09`09    mesgPane(XRN_SERIOUS, "Duplicate entry for `60%s', using first
V one",
X`09`09`09`09`09   $1);
X`09`09`09`7D
X`09`09    `7D
X`09`09    XtFree($1);
X`09        `7D
X            `7C NAME SEPARATOR EOL
X                `7B
X`09`09    struct newsgroup *newsgroup;
X`09`09    char *dummy;
X
X`09`09    if (!avl_lookup(NewsGroupTable, $1, &dummy)) `7B
X`09`09`09mesgPane(XRN_SERIOUS, "Bogus newsgroup `60%s', removing from the ne
Vwsrc file", $1);
X`09`09    `7D else `7B
X`09`09`09newsgroup = (struct newsgroup *) dummy;
X`09`09`09if (IS_NOENTRY(newsgroup)) `7B
X`09`09`09    CLEAR_NOENTRY(newsgroup);
X`09`09`09    newsgroup->status `7C= ($2 == ':' ? NG_SUB : NG_UNSUB);
X`09`09`09    newsgroup->nglist = NIL(struct list);
X`09`09`09    updateArticleArray(newsgroup, False);
X`09`09`09    newsgroup->newsrc = MaxGroupNumber;
X`09`09`09    Newsrc`5BMaxGroupNumber++`5D = newsgroup;
X`09`09`09`7D else `7B
X`09`09`09    mesgPane(XRN_SERIOUS, "Duplicate entry for `60%s', using first
V one",
X`09`09`09`09`09  $1);
X`09`09`09`7D
X`09`09    `7D
X`09`09    XtFree($1);
X`09        `7D
X`09    `7C error EOL `7B
X`09`09mesgPane(XRN_SERIOUS, "Unable to parse line %d in newsrc file, ignorin
Vg",
X`09`09`09    yylineno - 1);`09/* yylineno stepped at EOL */
X`09`09yyerrok;
X`09`09yyclearin;
X`09    `7D
X            ;
X
Xartlist      : articles
X                `7B
X`09`09    $$ = $1;
X`09`09`7D
X            `7C artlist COMMA articles
X                `7B
X`09`09    struct list *temp;
X
X`09`09    $$ = $1;
X`09`09    for (temp = $$; temp != NIL(struct list); temp = temp->next) `7B
X`09`09`09if (temp->next == NIL(struct list)) `7B
X`09`09`09    temp->next = $3;
X`09`09`09    break;
X`09`09`09`7D
X`09`09    `7D
X`09`09`7D
X            ;
X
Xarticles  : NUMBER
X                `7B
X`09`09    $$ = ALLOC(struct list);
X`09`09    $$->type = SINGLE;
X`09`09    $$->contents.single = (art_num) $1;
X`09`09    $$->next = NIL(struct list);
X`09`09`7D
X            `7C NUMBER DASH NUMBER
X                `7B
X`09`09    $$ = ALLOC(struct list);
X`09`09    $$->type = RANGE;
X`09`09    $$->contents.range.start = (art_num) $1;
X`09`09    $$->contents.range.end = (art_num) $3;
X`09`09    $$->next = NIL(struct list);
X`09`09`7D
X            ;
X
X  `20
X%%
X#include "lex.yy.c"
X
$ CALL UNPACK NEWSRC.Y;2 136395672
$ create 'f'
X
X#if !defined(lint) && !defined(SABER)
Xstatic char XRNrcsid`5B`5D = "$Header: /net/objy27/wrld/mnt11/ricks/src/mast
Ver/xrn/newsrcfile.c,v 1.5 1993/01/11 02:15:13 ricks Exp $";
X#endif
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * newsrcfile.c: routines for reading and updating the newsrc file
X *
X */
X
X#include "copyright.h"
X#include <stdio.h>
X#include "config.h"
X#include "utils.h"
X#include <errno.h>
X#ifndef VMS
X#include <sys/stat.h>
X#else
X#include <stat.h>
X#define index strchr
X#endif
X#ifdef __STDC__
X#include <time.h>
X#ifndef VMS
X#include <unistd.h>
X#else
X#include <stdlib.h>
X#include <unixio.h>
Xextern int unlink();
X#endif
X#endif /* __STDC__ */
X#include "news.h"
X#include "error_hnds.h"
X#include "mesg.h"
X#include "xrn.h"
X#include "dialogs.h"
X#include "resources.h"
X#include "newsrcfile.h"
X
X#ifndef R_OK
X#define R_OK            4       /* readable by caller */
X#endif /* R_OK */
X
Xextern int yyparse();
X
Xchar *NewsrcFile;    /* newsrc file name    */
XFILE *Newsrcfp;      /* newsrc file pointer */
Xchar *optionsLine;   /*`60options' line       */
Xstruct newsgroup **Newsrc;   /* sequence list for .newsrc file */
Xstruct stat fbuf;
X
X#define OKAY  1
X#define FATAL 0
X
X
Xstatic void
XreportWriteError(name)
Xchar *name;
X`7B
X    mesgPane(XRN_SERIOUS,
X`09 "Cannot write the .newsrc file (%s): %s", name,
X`09 errmsg(errno));
X`7D
X
X/*
X * copy newsrc file to .oldnewsrc file
X */
Xint
XcopyNewsrcFile(old, save)
Xchar *old;   /* name of file to save */
Xchar *save;  /* name of file to save to */
X`7B
X    FILE *orig, *new;
X    char buf`5BBUFSIZ`5D;
X    char *newFile;
X    int num_read;
X
X    if ((orig = fopen(old, "r")) == NULL) `7B
X`09mesgPane(XRN_SERIOUS,
X`09`09 "Cannot open the .newsrc file (%s) for copying: %s", old,
X`09`09 errmsg(errno));
X`09return FATAL;
X    `7D
X
X    if ((newFile = utNameExpand(save)) == NIL(char)) `7B
X`09mesgPane(XRN_SERIOUS,
X`09`09 "Cannot expand the .newsrc save file name (%s)", save);
X`09return FATAL;
X    `7D
X
X    if (STREQ(newFile, "")) `7B
X`09 mesgPane(XRN_SERIOUS, "hmmm.... file name is \"\"\n");
X`09 return FATAL;
X    `7D
X
X    /* if .oldnewsrc is a link to .newsrc we could have trouble, so unlink i
Vt */
X    (void) unlink(newFile);
X   `20
X    if ((new = fopen(newFile, "w")) == NULL) `7B
X`09mesgPane(XRN_SERIOUS, "Cannot open the .newsrc save file (%s): %s",
X`09`09 save, errmsg(errno));
X`09return FATAL;
X    `7D
X
X    while (num_read = fread(buf, sizeof(char), BUFSIZ, orig)) `7B
X`09 if (! fwrite(buf, sizeof(char), num_read, new)) `7B
X`09      mesgPane(XRN_SERIOUS,
X`09`09       "Error writing to .newsrc save file (%s): %s",
X`09`09       save, errmsg(errno));
X`09      return FATAL;
X`09 `7D
X    `7D
X
X    (void) fclose(orig);
X    if (fclose(new) == EOF) `7B
X`09 mesgPane(XRN_SERIOUS, "Error writing to .newsrc save file (%s): %s",
X`09`09  save, errmsg(errno));
X`09 return FATAL;
X    `7D
X
X    return OKAY;
X`7D
X
X/*
X * read, parse, and process the .newsrc file
X *
X *   returns: 0 for fatal error, non-zero for okay
X *
X */
Xint
Xreadnewsrc(newsrcfile, savenewsrcfile)
Xchar *newsrcfile;
Xchar *savenewsrcfile;
X`7B
X    struct stat buf;
X    char *name;
X    char *nntp;
X    int nameLth;
X#ifdef VMS
X    int nntp_len;
X    char *nntp_end;
X#endif
X   `20
X    /* create the Newsrc array structure */
X    Newsrc = ARRAYALLOC(struct newsgroup *, ActiveGroupsCount);
X
X    optionsLine = NIL(char);
X
X    if ((NewsrcFile = utNameExpand(newsrcfile)) == NIL(char)) `7B
X`09mesgPane(XRN_SERIOUS,
X`09`09 "Cannot expand the .newsrc file name (%s)", newsrcfile);
X`09return FATAL;
X    `7D
X
X    /* check for .newsrc-NNTPSERVER */
X
X    if (app_resources.nntpServer) `7B
X`09nntp = app_resources.nntpServer;
X    `7D else `7B
X        nntp = getenv("NNTPSERVER");
X    `7D
X
X    if (nntp) `7B
X#ifdef VMS
X`09if (nntp_end = index(nntp,':')) `7B  /* Look for the : in the name */
X`09    nntp_len = nntp_end-nntp;`09   /* Get the length of the first
X`09`09`09`09`09      part */
X`09`7D else nntp_len = strlen(nntp);`09   /* If no colon, use the whole
X`09`09`09`09`09      string */
X`09nameLth = strlen(NewsrcFile) + nntp_len;
X#else
X        nameLth = strlen(NewsrcFile) + strlen(nntp);
X#endif
X        name = ARRAYALLOC(char, nameLth + 20);
X        (void) strcpy(name, NewsrcFile);
X        (void) strcat(name, "-");
X#ifdef VMS
X`09(void) strncat(name, nntp, nntp_len);
X#else
X        (void) strcat(name, nntp);
X#endif
X     `20
X        if (access(name, R_OK) != 0) `7B
X`09    NewsrcFile = (char *) XtNewString(NewsrcFile);
X`09`7D else `7B
X`09    NewsrcFile = (char *) XtNewString(name);
X        `7D
X`09FREE(name);
X    `7D else `7B
X        NewsrcFile = (char *) XtNewString(NewsrcFile);
X    `7D
X
X    if (access(NewsrcFile, R_OK) != 0) `7B
X`09if (errno != ENOENT) `7B
X`09    mesgPane(XRN_SERIOUS, "Cannot read newsrc file (%s): %s",
X`09`09     NewsrcFile, errmsg(errno));
X`09    return FATAL;
X`09`7D
X`09mesgPane(XRN_INFO, "Creating a newsrc (%s) file for you", NewsrcFile);
X`09if ((Newsrcfp = fopen(NewsrcFile, "w")) == NULL) `7B
X`09    mesgPane(XRN_SERIOUS, "Cannot create a newsrc file (%s): %s",
X`09`09     NewsrcFile, errmsg(errno));
X`09    return(FATAL);
X`09`7D
X`09(void) fprintf(Newsrcfp, "news.announce.newusers:\n");
X#if !defined(VMS) && !defined(sco)
X`09(void) fstat((int) fileno(Newsrcfp), &fbuf);
X`09(void) fchmod((int) fileno(Newsrcfp), fbuf.st_mode);
X#endif
X`09(void) fclose(Newsrcfp);
X    `7D
X
X    if (stat(NewsrcFile, &buf) == -1) `7B
X`09mesgPane(XRN_SERIOUS, "Cannot stat %s: %s", NewsrcFile, errmsg(errno));
X`09return FATAL;
X    `7D
X
X    if (buf.st_size == 0) `7B
X`09mesgPane(XRN_SERIOUS, "%s is zero length, aborting", NewsrcFile);
X`09return FATAL;
X    `7D
X
X    if ((Newsrcfp = fopen(NewsrcFile, "r")) == NULL) `7B
X`09mesgPane(XRN_SERIOUS,
X`09`09 "Cannot open the newsrc file for reading, %s: %s",
X`09`09 NewsrcFile, errmsg(errno));
X`09return FATAL;
X    `7D
X
X    if (yyparse() != 0) `7B
X`09mesgPane(XRN_SERIOUS,
X`09`09 "Cannot parse the newsrc file (%s) -- error on line %ld",
X`09`09 NewsrcFile, MaxGroupNumber + 1);
X`09return FATAL;
X    `7D
X
X#if !defined(VMS) && !defined(sco)
X    (void) fstat((int) fileno(Newsrcfp), &fbuf);
X    (void) fchmod((int) fileno(Newsrcfp), fbuf.st_mode);
X#endif
X
X    (void) fclose(Newsrcfp);
X    if (!copyNewsrcFile(NewsrcFile, savenewsrcfile))
X`09 return FATAL;
X
X    Newsrcfp = NIL(FILE);
X
X    return(OKAY);
X`7D
X
Xint
XngEntryFprintf(newsrcfp, newsgroup)
XFILE *newsrcfp;
Xstruct newsgroup *newsgroup;
X`7B
X    int first = 1;
X    struct list *item;
X
X    /* process the .newsrc line */
X
X    for (item = newsgroup->nglist; item != NIL(struct list); item = item->ne
Vxt) `7B
X`09if (first)
X`09    first = 0;
X`09else
X`09    if (fprintf(newsrcfp, ",") == EOF) `7B
X`09`09return 0;
X`09    `7D
X
X`09switch (item->type) `7B
X`09    case SINGLE:
X`09    if (fprintf(newsrcfp, "%d", item->contents.single) == EOF) `7B
X`09`09return 0;
X`09    `7D
X`09    break;
X
X`09    case RANGE:
X`09    if (item->contents.range.start != item->contents.range.end) `7B
X`09`09if (fprintf(newsrcfp, "%d-%d",
X`09`09`09`09       item->contents.range.start,
X`09`09`09`09       item->contents.range.end) == EOF) `7B
X`09`09    return 0;
X`09`09`7D
X`09    `7D else `7B
X`09`09if (fprintf(newsrcfp, "%d", item->contents.range.start) == EOF) `7B
X`09`09    return 0;
X`09`09`7D
X`09    `7D
X`09    break;
X`09`7D
X    `7D
X    return 1;
X`7D
X
X/*
X * write out an up to date copy of the .newsrc file
X *
X *   returns: 0 for fatal error, non-zero for okay
X *
X */
Xint
Xupdatenewsrc()
X`7B
X    ng_num indx;
X
X    static FILE *newsrcfp;       /* file pointer for the newsc file      */
X    static struct stat lastStat; /* last stat done on the file           */
X    struct stat currentStat;     /* current stat                         */
X    static int done = 0;
X    static char tempfile`5B4096`5D;
X
X    if (!done) `7B
X        (void) stat(NewsrcFile, &lastStat);
X`09/* must be in the same filesystem so `60rename' will work */
X#ifndef VMS
X`09(void) sprintf(tempfile, "%s.temp", NewsrcFile);
X#else
X`09(void) sprintf(tempfile, "%s-temp", NewsrcFile);
X#endif /* VMS */
X`09done = 1;
X    `7D
X
X    (void) stat(NewsrcFile, &currentStat);
X
X    if (currentStat.st_mtime > lastStat.st_mtime) `7B
X`09if (ConfirmationBox(TopLevel, ".newsrc file updated by another program, c
Vontinue?") == XRN_CB_ABORT) `7B
X`09    ehNoUpdateExitXRN();
X`09`7D
X    `7D
X
X    if ((newsrcfp = fopen(tempfile, "w")) == NULL) `7B
X`09mesgPane(XRN_SERIOUS,
X`09`09 "Cannot open the .newsrc temporary file (%s): %s", tempfile,
X`09`09 errmsg(errno));
X`09return(FATAL);
X    `7D
X    /* set access mode of the temp file to be the same as the original file
V */
X    chmod(tempfile, currentStat.st_mode);
X
X    /*
X     * handle outputing the options line
X     */
X    if (optionsLine != NIL(char)) `7B
X`09if (fprintf(newsrcfp, "%s\n", optionsLine) == EOF) `7B
X`09    reportWriteError(NewsrcFile);
X`09    return(FATAL);
X`09`7D
X    `7D
X
X    for (indx = 0; indx < MaxGroupNumber; indx++) `7B
X`09struct newsgroup *newsgroup = Newsrc`5Bindx`5D;
X`09int nocomma = 1, inrange = 1;
X`09art_num lastread = 1, j;
X
X`09if (IS_ALIAS(newsgroup) && IS_NOENTRY(newsgroup)) `7B
X`09    continue;
X`09`7D
X`09if (fprintf(newsrcfp, "%s%c", newsgroup->name,
X`09       (IS_SUBSCRIBED(newsgroup) ? ':' : '!')) == EOF) `7B
X`09    reportWriteError(NewsrcFile);
X`09    return(FATAL);
X`09`7D
X
X`09if (newsgroup->last == 0) `7B
X`09    if (fprintf(newsrcfp, "\n") == EOF) `7B
X`09`09reportWriteError(NewsrcFile);
X`09`09return(FATAL);
X`09    `7D
X`09    continue;
X`09`7D
X
X`09if (newsgroup->artStatus == NIL(struct artStat)) `7B
X`09    if (newsgroup->nglist) `7B
X`09`09if (fprintf(newsrcfp, " ") == EOF) `7B
X`09`09    reportWriteError(NewsrcFile);
X`09`09    return(FATAL);
X`09`09`7D
X`09`09if (!ngEntryFprintf(newsrcfp, newsgroup)) `7B
X`09`09    reportWriteError(NewsrcFile);
X`09`09    return(FATAL);
X`09`09`7D
X`09`09if (fprintf(newsrcfp, "\n") == EOF) `7B
X`09`09    reportWriteError(NewsrcFile);
X`09`09    return(FATAL);
X`09`09`7D
X`09    `7D else `7B
X`09`09if (fprintf(newsrcfp, " 1-%d\n", newsgroup->last) == EOF) `7B
X`09`09    reportWriteError(NewsrcFile);
X`09`09    return(FATAL);
X`09`09`7D
X`09    `7D
X`09    continue;
X`09`7D
X`09
X`09if (newsgroup->last >= newsgroup->first) `7B
X
X`09    for (j = newsgroup->first; j <= newsgroup->last; j++) `7B
X`09`09if (inrange && IS_UNREAD(newsgroup->artStatus`5BINDEX(j)`5D) &&
X`09`09    !IS_UNAVAIL(newsgroup->artStatus`5BINDEX(j)`5D)) `7B
X`09`09    if (lastread == j - 1) `7B
X`09`09`09if (fprintf(newsrcfp, "%c%ld",
X`09`09`09       (nocomma ? ' ' : ','), lastread) == EOF) `7B
X`09`09`09    reportWriteError(NewsrcFile);
X`09`09`09    return(FATAL);
X`09`09`09`7D
X`09`09`09nocomma = 0;
X`09`09    `7D else `7B
X`09`09`09if ((j - 1) > 0) `7B
X`09`09`09    if (fprintf(newsrcfp, "%c%ld-%ld",
X`09`09`09`09   (nocomma ? ' ' : ','), lastread,
X`09`09`09`09   j - 1) == EOF) `7B
X`09`09`09`09reportWriteError(NewsrcFile);
X`09`09`09`09return(FATAL);
X`09`09`09    `7D
X`09`09`09    nocomma = 0;
X`09`09`09`7D
X`09`09    `7D
X
X`09`09    inrange = 0;
X`09`09`7D else if (!inrange && IS_READ(newsgroup->artStatus`5BINDEX(j)`5D))
V `7B
X`09`09    inrange = 1;
X`09`09    lastread = j;
X`09`09`7D
X`09    `7D
X`09   `20
X`09    if (inrange) `7B
X`09`09if (lastread == newsgroup->last) `7B
X`09`09    if (fprintf(newsrcfp, "%c%ld",
X`09`09`09   (nocomma ? ' ' : ','), lastread) == EOF) `7B
X`09`09`09reportWriteError(NewsrcFile);
X`09`09`09return(FATAL);
X`09`09    `7D
X`09`09`7D else `7B
X`09`09    if (fprintf(newsrcfp, "%c%ld-%ld",
X`09`09`09   (nocomma ? ' ' : ','), lastread,
X`09`09`09   newsgroup->last) == EOF) `7B
X`09`09`09reportWriteError(NewsrcFile);
X`09`09`09return(FATAL);
X`09`09    `7D
X`09`09`7D
X`09    `7D
X`09`7D else `7B
X`09    if (newsgroup->last > 1) `7B
X`09`09if (fprintf(newsrcfp, " 1-%ld", newsgroup->last) == EOF) `7B
X`09`09    reportWriteError(NewsrcFile);
X`09`09    return(FATAL);
X`09`09`7D
X`09    `7D
X`09`7D
X`09   `20
X`09if (fprintf(newsrcfp, "\n") == EOF) `7B
X`09    reportWriteError(NewsrcFile);
X`09    return(FATAL);
X`09`7D
X    `7D
X#if !defined(VMS) && !defined(sco)
X    (void) fchmod((int) fileno(newsrcfp), fbuf.st_mode);
X#endif
X
X    if (fclose(newsrcfp) == EOF) `7B
X`09reportWriteError(NewsrcFile);
X`09return(FATAL);
X    `7D
X
X#if defined(ISC_TCP) `7C`7C defined(VMS)
X    /* the following added to fix a bug in ISC TCP/IP rename() - jrh@dell.de
Vll.com (James Howard) */
X    if (unlink(NewsrcFile) != 0) `7B
X`09mesgPane(XRN_SERIOUS, "Error unlinking %s: %s", NewsrcFile,
X`09`09 errmsg(errno));
X    `7D
X#endif /* ISC_TCP or VMS */
X
X    if (rename(tempfile, NewsrcFile) != 0) `7B
X`09mesgPane(XRN_SERIOUS, "Rename of %s to %s failed: %s", tempfile,
X`09`09       NewsrcFile, errmsg(errno));
X`09return(FATAL);
X    `7D
X
X    (void) stat(NewsrcFile, &lastStat);
X
X    return(OKAY);
X`7D
$ CALL UNPACK NEWSRCFILE.C;18 1998746064
$ create 'f'
X#ifndef NEWSRCFILE_H
X#define NEWSRCFILE_H
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/newsrcfile.h,v 1.4 1
V993/01/11 02:15:15 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X
X#ifndef NEWS_H
X#include "news.h"
X#endif
X
X/*
X * newsrcfile.h: handle the newsrc file (reading and updating)
X */
X
X/* return 1 for okay, 0 for fatal error */
Xextern int readnewsrc _ARGUMENTS((char *, char *));
Xextern int updatenewsrc();
Xextern int copyNewsrcFile _ARGUMENTS((char *, char *));
X
Xextern char *NewsrcFile;
Xextern FILE *Newsrcfp;
Xextern char *optionsLine;
X
X/* values for 'type' */
X#define SINGLE 1
X#define RANGE  2
X
Xstruct list `7B
X    int type;
X    union `7B
X`09art_num single;
X`09struct rn `7B
X`09    art_num start;
X`09    art_num end;
X`09`7D range;
X    `7D contents;
X    struct list *next;
X`7D;
X
X#endif /* NEWSRCFILE_H */
$ CALL UNPACK NEWSRCFILE.H;2 1663988668
$ create 'f'
X#if !defined(lint) && !defined(SABER)
Xstatic char XRNrcsid`5B`5D = "$Header: /net/objy27/wrld/mnt11/ricks/src/mast
Ver/xrn/newsrc.y,v 1.4 1993/01/11 02:15:12 ricks Exp $";
X#endif
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993,Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use,copy,modify,and distribute this software and its
X * documentation for any purpose and without fee is hereby granted,provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation,and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific,written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE,INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS,IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL,INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE,DATA OR PROFITS,WHETHER IN AN ACTION OF
X * CONTRACT,NEGLIGENCE OR OTHER TORTIOUS ACTION,ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * newsrc.y - yacc parser for the newsrc file
X */
X
X#include "copyright.h"
X#include <stdio.h>
X#include "config.h"
X#include "utils.h"
X#include "avl.h"
X#include "mesg.h"
X#include "news.h"
X#include "newsrcfile.h"
X
Xextern int yylineno;
X
Xtypedef union  `7B
X    int integer;
X    char *string;
X    char character;
X    struct list *item;
X`7D YYSTYPE;
X#define NAME 257
X#define SEPARATOR 258
X#define NUMBER 259
X#define EOL 260
X#define DASH 261
X#define COMMA 262
X#define yyclearin yychar = -1
X#define yyerrok yyerrflag = 0
Xextern int yychar;
Xextern short yyerrflag;
X#ifndef YYMAXDEPTH
X#define YYMAXDEPTH 150
X#endif
XYYSTYPE yylval,yyval;
X#define YYERRCODE 256
X
X#include "newsrc_parse.h"
X
Xshort yyexca`5B`5D =`7B-1,1,0,-1,-2,0,`7D;
X#define YYNPROD 11
X#define YYLAST 27
Xshort yyact`5B`5D=`7B13,8,14,15,12,10,17,12,7,5,4,11,3,2,1,6,9,0,0,0,0,0,0,0
V,0,0,16`7D;
Xshort yypact`5B`5D=`7B
X-247,-1000,-247,-1000,-250,-259,-1000,-255,-1000,-260,
X-1000,-1000,-258,-1000,-252,-253,-1000,-1000 `7D;
Xshort yypgo`5B`5D=`7B0,16,11,14,13,12 `7D;
Xshort yyr1`5B`5D=`7B0,3,4,4,5,5,5,1,1,2,2`7D;
Xshort yyr2`5B`5D=`7B0,1,1,2,4,3,2,1,3,1,3`7D;
Xshort yychk`5B`5D=`7B-1000,-3,-4,-5,257,256,-5,258,260,-1,
X 260,-2,259,260,262,261,-2,259`7D;
Xshort yydef`5B`5D=`7B0,-2,1,2,0,0,3,0,6,0,5,7,9,4,0,0,8,10`7D;
X#define YYFLAG -1000
X#define YYERROR goto yyerrlab
X#define YYACCEPT return(0)
X#define YYABORT return(1)
X
X/*`09parser for yacc output`09*/
X
X#ifdef YYDEBUG
Xint yydebug = 0; /* 1 for debugging */
X#endif
XYYSTYPE yyv`5BYYMAXDEPTH`5D; /* where the values are stored */
Xint yychar = -1; /* current input token number */
Xint yynerrs = 0;  /* number of errors */
Xshort yyerrflag = 0;  /* error recovery flag */
X
Xyyparse() `7B
X`09short yys`5BYYMAXDEPTH`5D;
X`09short yyj,yym;
X`09register YYSTYPE *yypvt;
X`09register short yystate,*yyps,yyn;
X`09register YYSTYPE *yypv;
X`09register short *yyxi;
X
X`09yystate = 0;
X`09yychar = -1;
X`09yynerrs = 0;
X`09yyerrflag = 0;
X`09yyps= &yys`5B-1`5D;
X`09yypv= &yyv`5B-1`5D;
X
X yystack:    /* put a state and value onto the stack */
X
X`09`09if( ++yyps> &yys`5BYYMAXDEPTH`5D ) `7B yyerror( "yacc stack overflow"
V ); return(1); `7D
X`09`09*yyps = yystate;
X`09`09++yypv;
X`09`09*yypv = yyval;
X
X yynewstate:
X
X`09yyn = yypact`5Byystate`5D;
X
X`09if( yyn<= YYFLAG ) goto yydefault; /* simple state */
X
X`09if( yychar<0 ) if( (yychar=yylex())<0 ) yychar=0;
X`09if( (yyn += yychar)<0 `7C`7C yyn >= YYLAST ) goto yydefault;
X
X`09if( yychk`5B yyn=yyact`5B yyn `5D `5D == yychar )`7B /* valid shift */
X`09`09yychar = -1;
X`09`09yyval = yylval;
X`09`09yystate = yyn;
X`09`09if( yyerrflag > 0 ) --yyerrflag;
X`09`09goto yystack;
X`09`09`7D
X
X yydefault:
X`09/* default state action */
X
X`09if( (yyn=yydef`5Byystate`5D) == -2 ) `7B
X`09`09if( yychar<0 ) if( (yychar=yylex())<0 ) yychar = 0;
X`09`09/* look through exception table */
X
X`09`09for( yyxi=yyexca; (*yyxi!= (-1)) `7C`7C (yyxi`5B1`5D!=yystate) ; yyxi
V += 2 ) ; /* VOID */
X
X`09`09while( *(yyxi+=2) >= 0 )`7B
X`09`09`09if( *yyxi == yychar ) break;
X`09`09`09`7D
X`09`09if( (yyn = yyxi`5B1`5D) < 0 ) return(0);   /* accept */
X`09`09`7D
X
X`09if( yyn == 0 )`7B /* error */
X`09`09/* error ... attempt to resume parsing */
X
X`09`09switch( yyerrflag )`7B
X
X`09`09case 0:   /* brand new error */
X
X`09`09`09yyerror( "syntax error" );
X`09`09yyerrlab:
X`09`09`09++yynerrs;
X
X`09`09case 1:
X`09`09case 2: /* incompletely recovered error ... try again */
X
X`09`09`09yyerrflag = 3;
X
X`09`09`09/* find a state where "error" is a legal shift action */
X
X`09`09`09while ( yyps >= yys ) `7B
X`09`09`09   yyn = yypact`5B*yyps`5D + YYERRCODE;
X`09`09`09   if( yyn>= 0 && yyn < YYLAST && yychk`5Byyact`5Byyn`5D`5D == YYER
VRCODE )`7B
X`09`09`09      yystate = yyact`5Byyn`5D;  /* simulate a shift of "error" */
X`09`09`09      goto yystack;
X`09`09`09      `7D
X`09`09`09   yyn = yypact`5B*yyps`5D;
X
X`09`09`09   /* the current yyps has no shift on "error",pop stack */
X
X`09`09`09   --yyps;
X`09`09`09   --yypv;
X`09`09`09   `7D
X
X`09`09`09/* there is no state on the stack with an error shift ... abort */
X
X`09yyabort:
X`09`09`09return(1);
X
X
X`09`09case 3:  /* no shift yet; clobber input char */
X
X`09`09`09if( yychar == 0 ) goto yyabort; /* don't discard EOF,quit */
X`09`09`09yychar = -1;
X`09`09`09goto yynewstate;   /* try again in the same state */
X
X`09`09`09`7D
X`09`09`7D
X
X`09/* reduction by production yyn */
X
X`09`09yyps -= yyr2`5Byyn`5D;
X`09`09yypvt = yypv;
X`09`09yypv -= yyr2`5Byyn`5D;
X`09`09yyval = yypv`5B1`5D;
X`09`09yym=yyn;
X`09`09`09/* consult goto table to find next state */
X`09`09yyn = yyr1`5Byyn`5D;
X`09`09yyj = yypgo`5Byyn`5D + *yyps + 1;
X`09`09if( yyj>=YYLAST `7C`7C yychk`5B yystate = yyact`5Byyj`5D `5D != -yyn )
V yystate = yyact`5Byypgo`5Byyn`5D`5D;
X`09`09switch(yym)`7B
X`09`09`09
Xcase 4:
X`7B
X`09`09    struct newsgroup *newsgroup;
X`09`09    char *dummy;
X
X`09`09    if (!avl_lookup(NewsGroupTable,yypvt`5B-3`5D.string,&dummy)) `7B
X`09`09`09mesgPane(XRN_SERIOUS,"Bogus newsgroup `60%s',removing from the news
Vrc file",yypvt`5B-3`5D.string);
X`09`09    `7D else `7B
X`09`09`09newsgroup = (struct newsgroup *) dummy;
X`09`09`09if (IS_NOENTRY(newsgroup)) `7B
X`09`09`09    CLEAR_NOENTRY(newsgroup);
X`09`09`09    newsgroup->status `7C= (yypvt`5B-2`5D.character == ':' ? NG_SUB
V : NG_UNSUB);
X`09`09`09    newsgroup->nglist = yypvt`5B-1`5D.item;
X`09`09`09    updateArticleArray(newsgroup,False);
X`09`09`09    newsgroup->newsrc = MaxGroupNumber;
X`09`09`09    Newsrc`5BMaxGroupNumber++`5D = newsgroup;
X`09`09`09`7D else `7B
X`09`09`09    mesgPane(XRN_SERIOUS,"Duplicate entry for `60%s',using first on
Ve",
X`09`09`09`09`09   yypvt`5B-3`5D.string);
X`09`09`09`7D
X`09`09    `7D
X`09`09    XtFree(yypvt`5B-3`5D.string);
X`09        `7D break;
Xcase 5:
X`7B
X`09`09    struct newsgroup *newsgroup;
X`09`09    char *dummy;
X
X`09`09    if (!avl_lookup(NewsGroupTable,yypvt`5B-2`5D.string,&dummy)) `7B
X`09`09`09mesgPane(XRN_SERIOUS,"Bogus newsgroup `60%s',removing from the news
Vrc file",yypvt`5B-2`5D.string);
X`09`09    `7D else `7B
X`09`09`09newsgroup = (struct newsgroup *) dummy;
X`09`09`09if (IS_NOENTRY(newsgroup)) `7B
X`09`09`09    CLEAR_NOENTRY(newsgroup);
X`09`09`09    newsgroup->status `7C= (yypvt`5B-1`5D.character == ':' ? NG_SUB
V : NG_UNSUB);
X`09`09`09    newsgroup->nglist = NIL(struct list);
X`09`09`09    updateArticleArray(newsgroup,False);
X`09`09`09    newsgroup->newsrc = MaxGroupNumber;
X`09`09`09    Newsrc`5BMaxGroupNumber++`5D = newsgroup;
X`09`09`09`7D else `7B
X`09`09`09    mesgPane(XRN_SERIOUS,"Duplicate entry for `60%s',using first on
Ve",
X`09`09`09`09`09  yypvt`5B-2`5D.string);
X`09`09`09`7D
X`09`09    `7D
X`09`09    XtFree(yypvt`5B-2`5D.string);
X`09        `7D break;
Xcase 6:
X`7B
X`09`09mesgPane(XRN_SERIOUS,"Unable to parse line %d in newsrc file,ignoring"
V,
X`09`09`09    yylineno - 1);`09/* yylineno stepped at EOL */
X`09`09yyerrok;
X`09`09yyclearin;
X`09    `7D break;
Xcase 7:
X`7B
X`09`09    yyval.item = yypvt`5B-0`5D.item;
X`09`09`7D break;
Xcase 8:
X`7B
X`09`09    struct list *temp;
X
X`09`09    yyval.item = yypvt`5B-2`5D.item;
X`09`09    for (temp = yyval.item; temp != NIL(struct list); temp = temp->nex
Vt) `7B
X`09`09`09if (temp->next == NIL(struct list)) `7B
X`09`09`09    temp->next = yypvt`5B-0`5D.item;
X`09`09`09    break;
X`09`09`09`7D
X`09`09    `7D
X`09`09`7D break;
Xcase 9:
X`7B
X`09`09    yyval.item = ALLOC(struct list);
X`09`09    yyval.item->type = SINGLE;
X`09`09    yyval.item->contents.single = (art_num) yypvt`5B-0`5D.integer;
X`09`09    yyval.item->next = NIL(struct list);
X`09`09`7D break;
Xcase 10:
X`7B
X`09`09    yyval.item = ALLOC(struct list);
X`09`09    yyval.item->type = RANGE;
X`09`09    yyval.item->contents.range.start = (art_num) yypvt`5B-2`5D.integer
V;
X`09`09    yyval.item->contents.range.end = (art_num) yypvt`5B-0`5D.integer;
X`09`09    yyval.item->next = NIL(struct list);
X`09`09`7D break;`20
X`09`09`7D
X`09`09goto yystack;  /* stack new state and value */
X
X`09`7D
$ CALL UNPACK NEWSRC_PARSE.C;13 1048105742
$ create 'f'
X#include <stdio.h>
Xstatic int yylook();
Xstatic int yyback();
Xextern int atoi();
X#define U(x) ((x)&0377)
X#define NLSTATE yyprevious=YYNEWLINE
X#define BEGIN yybgin = yysvec + 1 +
X#define INITIAL 0
X#define YYLERR yysvec
X#define YYSTATE (yyestate-yysvec-1)
X#define YYOPTIM 1
X#define YYLMAX 1000
X#define output(c) putc(c,yyout)
X#define input() (((yytchar=yysptr>yysbuf?U(*--yysptr):getc(yyin))==10?(yylin
Veno++,yytchar):yytchar)==EOF?0:yytchar)
X#define unput(c) `7Byytchar= (c);if(yytchar=='\n')yylineno--;*yysptr++=yytch
Var;`7D
X#define yymore() (yymorfg=1)
X#define ECHO fprintf(yyout,"%s",yytext)
X#define REJECT `7B nstr = yyreject(); goto yyfussy;`7D
Xint yyleng; extern char yytext`5B`5D;
Xint yymorfg;
Xextern char *yysptr,yysbuf`5B`5D;
Xint yytchar;
XFILE *yyin,*yyout;
Xextern int yylineno;
Xstruct yysvf `7B`20
X`09struct yywork *yystoff;
X`09struct yysvf *yyother;
X`09int *yystops;`7D;
Xstruct yysvf *yyestate;
Xextern struct yysvf yysvec`5B`5D,*yybgin;
X#define YYNEWLINE 10
Xyylex()`7B
Xint nstr; extern int yyprevious;
Xyyin = Newsrcfp;
Xwhile((nstr = yylook()) >= 0)
Xyyfussy: switch(nstr)`7B
Xcase 0:return(0);
Xcase 1:break;
Xcase 2:return(EOL); break;
Xcase 3:return(DASH);break;
Xcase 4:return(COMMA);break;
Xcase 5:yylval.character = yytext`5B0`5D; return(SEPARATOR);break;
Xcase 6:yylval.integer = atoi((char *)yytext); return(NUMBER);break;
Xcase 7:
Xcase 8:`09`7B
X`09char c = yytext`5Byyleng - 1`5D;
X`09yytext`5Byyleng-1`5D = '\0';
X`09yylval.string = XtNewString((char *) yytext);
X`09unput(c);
X`09return(NAME);
X`09`7D break;
Xcase 9:break;
Xcase 10: `7B
X`09optionsLine = XtNewString((char *)yytext);
X`09optionsLine`5ButStrlen(optionsLine) - 1`5D = '\0';
X`09`7D break;
Xcase -1: break;
Xdefault: fprintf(yyout,"bad switch yylook %d",nstr);
X`7D return(0); `7D
X/* end of yylex */
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/newsrc.l,v 1.3 1993/
V01/11 02:15:09 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993,Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use,copy,modify,and distribute this software and its
X * documentation for any purpose and without fee is hereby granted,provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation,and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific,written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE,INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS,IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL,INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE,DATA OR PROFITS,WHETHER IN AN ACTION OF
X * CONTRACT,NEGLIGENCE OR OTHER TORTIOUS ACTION,ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*ARGSUSED*/
Xyyerror(s)
Xchar *s;
X`7B `7D
X
Xint yyvstop`5B`5D =`7B0,9,0,2,0,5,0,4,0,3,0,6,0,9,0,1,2,0,5,0,4,0,3,0,6,0,8,
X0,1,0,8,0,7,0,7,8,0,10,0,0`7D;
X#define YYTYPE unsigned char
Xstruct yywork `7B YYTYPE verify,advance; `7D yycrank`5B`5D =`7B
X0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,1,4,11,21,11,22,13,0,13,0,
X14,0,14,0,15,0,15,0,0,0,16,0,16,0,0,0,18,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,
X0,0,1,3,1,5,11,21,0,0,13,0,0,0,14,0,0,0,15,0,20,0,20,0,16,0,1,6,1,7,18,0,
X0,0,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,5,16,16,0,0,0,0,0,0,
X0,0,20,0,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,
X1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,0,0,0,0,0,0,0,0,
X0,0,0,0,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,
X1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,2,10,0,0,0,0,18,25,
X0,0,0,0,0,0,0,0,2,11,2,12,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
X9,19,0,0,10,10,0,0,0,0,17,23,19,0,19,0,9,0,9,0,10,0,10,0,2,13,17,0,17,0,23,0
V,
X23,0,24,0,24,0,25,0,25,0,0,0,0,0,2,14,2,15,0,0,0,0,2,16,0,0,19,0,19,26,9,0,
X9,19,10,0,10,20,0,0,17,0,17,24,23,0,23,27,24,0,24,27,25,0,25,27,
X2,17,0,0,0,0,9,19,0,0,10,10,26,0,26,0,17,23,27,0,27,0,28,0,
X28,0,29,0,29,0,30,0,30,0,31,0,31,0,0,0,9,19,0,0,10,10,0,0,
X0,0,17,23,32,0,32,0,0,0,26,0,26,26,0,0,27,0,27,27,28,0,28,27,
X29,0,29,27,30,0,30,27,31,0,31,27,0,0,0,0,33,33,0,0,2,18,0,0,
X0,0,32,33,32,27,0,0,33,33,33,34,0,0,0,0,0,0,0,0,0,0,0,0,
X0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
X33,33,0,0,0,0,0,0,0,0,0,0,25,28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,33,33,
X0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,29,
X33,33,0,0,0,0,0,0,0,0,0,0,0,0,29,30,30,31,0,0,0,0,0,0,0,0,0,0,0,0,31,32,
X0,0`7D;
Xstruct yysvf yysvec`5B`5D =`7B
X0,0,0,yycrank+1,0,0,yycrank+-123,0,0,yycrank+0,0,yyvstop+1,
Xyycrank+0,0,yyvstop+3,yycrank+0,0,yyvstop+5,yycrank+0,0,yyvstop+7,
Xyycrank+0,0,yyvstop+9,yycrank+86,0,yyvstop+11,yycrank+-143,0,0,
Xyycrank+-145,0,0,yycrank+3,0,yyvstop+13,yycrank+0,0,yyvstop+15,
Xyycrank+-5,yysvec+10,yyvstop+18,yycrank+-7,yysvec+10,yyvstop+20,
Xyycrank+-9,yysvec+10,yyvstop+22,yycrank+-12,yysvec+10,yyvstop+24,
Xyycrank+-148,0,0,yycrank+-15,yysvec+17,0,yycrank+-141,yysvec+9,0,
Xyycrank+-33,yysvec+10,yyvstop+26,yycrank+0,yysvec+11,0,
Xyycrank+0,0,yyvstop+28,yycrank+-150,yysvec+17,0,
Xyycrank+-152,yysvec+17,yyvstop+30,yycrank+-154,yysvec+17,0,
Xyycrank+-185,yysvec+9,yyvstop+32,yycrank+-188,yysvec+17,yyvstop+34,
Xyycrank+-190,yysvec+17,0,yycrank+-192,yysvec+17,0,yycrank+-194,yysvec+17,0,
Xyycrank+-196,yysvec+17,0,yycrank+-205,yysvec+17,0,yycrank+-231,0,0,
Xyycrank+0,0,yyvstop+37,0,0,0`7D;
Xstruct yywork *yytop = yycrank+311;
Xstruct yysvf *yybgin = yysvec+1;
Xchar yymatch`5B`5D =`7B00,01,01,01,01,01,01,01,01,011,012,01,01,01,01,01,
X01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,011,'!',01,01,01,01,01,01,
X01,01,01,01,01,01,01,01,'0','0','0','0','0','0','0','0',
X'0','0','!',01,01,01,01,01,01,'A','A','A','A','A','A','A',
X'A','A','A','A','A','A','A','A','A','A','A','A','A','A','A','A',
X'A','A','A',01,01,01,01,01,01,'A','A','A','A','A','A','A',
X'A','A','A','A','A','A','A','A','A','A','A','A','A','A','A','A',
X'A','A','A',01,01,01,01,01,01,01,01,01,01,01,01,01,
X01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,
X01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,
X01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,
X01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,
X01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,
X01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,
X01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,
X01,01,01,01,01,01,01,01,0`7D;
Xchar yyextra`5B`5D =`7B0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0`7D;
X
Xint yylineno =1;
X#define YYU(x) x
X#define NLSTATE yyprevious=YYNEWLINE
Xchar yytext`5BYYLMAX`5D;
Xstruct yysvf *yylstate `5BYYLMAX`5D,**yylsp,**yyolsp;
Xchar yysbuf`5BYYLMAX`5D;
Xchar *yysptr = yysbuf;
Xint *yyfnd;
Xextern struct yysvf *yyestate;
Xint yyprevious = YYNEWLINE;
Xstatic int yylook()`7B
X`09register struct yysvf *yystate,**lsp;
X`09register struct yywork *yyt;
X`09struct yysvf *yyz;
X`09int yych;
X`09struct yywork *yyr;
X`09char *yylastch;
X`09/* start off machines */
X`09if (!yymorfg)
X`09`09yylastch = yytext;
X`09else `7B
X`09`09yymorfg=0;
X`09`09yylastch = yytext+yyleng;
X`09`09`7D
X`09for(;;)`7B
X`09`09lsp = yylstate;
X`09`09yyestate = yystate = yybgin;
X`09`09if (yyprevious==YYNEWLINE) yystate++;
X`09`09for (;;)`7B
X`09`09`09yyt = yystate->yystoff;
X`09`09`09if(yyt == yycrank)`7B`09`09/* may not be any transitions */
X`09`09`09`09yyz = yystate->yyother;
X`09`09`09`09if(yyz == 0)break;
X`09`09`09`09if(yyz->yystoff == yycrank)break;
X`09`09`09`09`7D
X`09`09`09*yylastch++ = yych = input();
X`09`09tryagain:
X`09`09`09yyr = yyt;
X`09`09`09if ( (int)yyt > (int)yycrank)`7B
X`09`09`09`09yyt = yyr + yych;
X`09`09`09`09if (yyt <= yytop && yyt->verify+yysvec == yystate)`7B
X`09`09`09`09`09if(yyt->advance+yysvec == YYLERR)`09/* error transitions */
X`09`09`09`09`09`09`7Bunput(*--yylastch);break;`7D
X`09`09`09`09`09*lsp++ = yystate = yyt->advance+yysvec;
X`09`09`09`09`09goto contin;
X`09`09`09`09`09`7D
X`09`09`09`09`7D
X#ifdef YYOPTIM
X`09`09`09else if((int)yyt < (int)yycrank) `7B`09`09/* r < yycrank */
X`09`09`09`09yyt = yyr = yycrank+(yycrank-yyt);
X`09`09`09`09yyt = yyt + yych;
X`09`09`09`09if(yyt <= yytop && yyt->verify+yysvec == yystate)`7B
X`09`09`09`09`09if(yyt->advance+yysvec == YYLERR)`09/* error transitions */
X`09`09`09`09`09`09`7Bunput(*--yylastch);break;`7D
X`09`09`09`09`09*lsp++ = yystate = yyt->advance+yysvec;
X`09`09`09`09`09goto contin;
X`09`09`09`09`09`7D
X`09`09`09`09yyt = yyr + YYU(yymatch`5Byych`5D);
X`09`09`09`09if(yyt <= yytop && yyt->verify+yysvec == yystate)`7B
X`09`09`09`09`09if(yyt->advance+yysvec == YYLERR)`09/* error transition */
X`09`09`09`09`09`09`7Bunput(*--yylastch);break;`7D
X`09`09`09`09`09*lsp++ = yystate = yyt->advance+yysvec;
X`09`09`09`09`09goto contin;
X`09`09`09`09`09`7D
X`09`09`09`09`7D
X`09`09`09if ((yystate = yystate->yyother) && (yyt= yystate->yystoff) != yycr
Vank)`7B
X`09`09`09`09goto tryagain;
X`09`09`09`09`7D
X#endif
X`09`09`09else
X`09`09`09`09`7Bunput(*--yylastch);break;`7D
X`09`09contin:
X`09`09`09;
X`09`09`09`7D
X`09`09while (lsp-- > yylstate)`7B
X`09`09`09*yylastch-- = 0;
X`09`09`09if (*lsp != 0 && (yyfnd= (*lsp)->yystops) && *yyfnd > 0)`7B
X`09`09`09`09yyolsp = lsp;
X`09`09`09`09if(yyextra`5B*yyfnd`5D)`7B`09`09/* must backup */
X`09`09`09`09`09while(yyback((*lsp)->yystops,-*yyfnd) != 1 && lsp > yylstate)
V`7B
X`09`09`09`09`09`09lsp--;
X`09`09`09`09`09`09unput(*yylastch--);
X`09`09`09`09`09`09`7D
X`09`09`09`09`09`7D
X`09`09`09`09yyprevious = YYU(*yylastch);
X`09`09`09`09yylsp = lsp;
X`09`09`09`09yyleng = yylastch-yytext+1;
X`09`09`09`09yytext`5Byyleng`5D = 0;
X`09`09`09`09return(*yyfnd++);
X`09`09`09`09`7D
X`09`09`09unput(*yylastch);
X`09`09`09`7D
X`09`09if (yytext`5B0`5D == 0  /* && feof(yyin) */)
X`09`09`09`7B
X`09`09`09yysptr=yysbuf;
X`09`09`09return(0);
X`09`09`09`7D
X`09`09yyprevious = yytext`5B0`5D = input();
X`09`09if (yyprevious>0)
X`09`09`09output(yyprevious);
X`09`09yylastch=yytext;
X`09`09`7D
X`09`7D
Xstatic int yyback(p,m)
X`09int *p;
X`7B
Xif (p==0) return(0);
Xwhile (*p)
X`09`7B
X`09if (*p++ == m)
X`09`09return(1);
X`09`7D
Xreturn(0);
X`7D
Xyyinput()`7B return(input());`7D
Xyyoutput(c)
Xint c; `7Boutput(c); `7D
Xyyunput(c)
Xint c; `7Bunput(c);`7D
$ CALL UNPACK NEWSRC_PARSE.H;14 2021105830
$ create 'f'
X#ifdef VMS
X/*
X * Note: Using #module in Unix will get interpreted by the preprocessor as a
V`20
X *`09 control line and blow up. Do not uncomment the following line.
X *
X * module PANE "3.2"
X */
X#else
X#ifndef lint
Xstatic char rcsid`5B`5D = "$Header: Pane.c,v 1.1 89/01/03 16:59:31 gringort
V Exp $";
X#endif lint
X#endif VMS
X/*
X * Copyright 1988, 1989 by Digital Equipment Corporation, Maynard, Massachus
Vetts.
X *`20
X *                         All Rights Reserved
X *`20
X * Permission to use, copy, modify, and distribute this software and its`20
X * documentation for any purpose and without fee is hereby granted,`20
X * provided that the above copyright notice appear in all copies and that
X * both that copyright notice and this permission notice appear in`20
X * supporting documentation, and that the name of Digital Equipment
X * Corporation not be used in advertising or publicity pertaining to
X * distribution of the software without specific, written prior permission.
V `20
X *`20
X *`20
X * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
X * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
X * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
X * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
X * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
X * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
X * SOFTWARE.
X */
X/*
X * V1.0a    12-Jan-1988`09MRR
X *`09    Add our logicals to #includes.
X * V1.0b    26-Feb-1988`09RDB
X *`09    Fix bugs with allowresizing & geometry manager
X * V1.0c    01-Mar-1988`09PMB
X *`09    Merge with latest copy of pane widget.
X * V1.0d    17-Mar-1988`09RDB
X *`09    fix major bugs and enhancements
X * V1.1`09    1-Apr-1988`09MR
X *`09    Make work with BL7.2 - add class_part_initialize,
X *`09    add time argument to AcceptFocus.
X * V1.2`09    13-Apr-1988`09JV
X *`09    Make work with BL7.6 - changed DwtNcallback to DwtNmapCallback
X * V1.3`09    20-Apr-1988`09MRR
X *`09    Upward compatibility support.
X * V1.4`09    13-Jun-1988`09MRR
X *`09    Add help support.
X * V1.5`09    30-Jun-1988`09MRR
X *`09    Support for Help-MBx.
X * V1.6`09    19-Jul-1988`09MRR
X *`09    Help modifier changed to @Help.
X * V1.7`09    20-Jul-1988`09RDB
X *`09    Initialization Bug
X * V1.8`09    01-Sep-1988`09RDB
X *`09    Resize on DwtPaneSetMax error
X *`09    Knob draging problem
X * V1.9`09    07-Sep-1988`09RDB
X *`09    Color changes on 8 plane GPX on Knob drag
X * V1.10    08-Sep-1988`09RDB
X *`09    Extra knob appearing when managing and unmanaging widgets
X * V1.11    06-Oct-1988 RDB
X *`09    During Resize check if widget height also changed.
X * V1.12    19-Oct-1988`09RDB
X *`09    change cursor to vertical or horizontial cursor and`20
X *`09    MB2 & MB3 pushes fixed
X * V1.13    31-Oct-1988 RDB
X *`09    Add DwtPaneAddChild calls
X * V1.14    01-Nov-1988`09RDB
X *`09    Change resize to resizable and allowresizing to resize
X * V1.15    07-Nov-1988`09RDB
X *`09    Allow shared panes
X * V1.16    29-Nov-1988 RDB
X *`09    Add Destory routine
X *`09    Add SetValues routine
X *`09    Fix SetConstraintValues routine
X *`09    Add DeleteChild routine
X *`09    Add FocusCallbacks
X *`09    Add MapCallbacks
X *`09    Fix FocusNext, FocusPrev routines
X *`09    Fix compiledtextbindings
X *`09    Add VMS routines for all the public routines.
X * V1.17    06-Jan-1989`09JG
X *`09    Make work on PMAX
X * V2.0     15-Feb-1989 MRR
X *`09    AcceptFocus should return what child's accept_focus returns.
X * V2.1     22-Feb-1989 RDB
X *`09    Fix set min and max resize but when pane is shared
X * V2.2`09    1-Mar-1989`09MRR
X *`09    GC's gotten with XtGetGC should be removed with XtDestroyGC,
X *`09    not XFreeGC.
X * V2.3`09    7-Mar-1989`09RDB
X *`09    Orientation (w) defined incorrectly
X * V2.4`09    9-Mar-1989`09MRR
X *`09    CvtStringToOrientation and DwtPrivate no longer needed.
X * V2.5`09    9-Mar-1989`09MRR
X *`09    Copy DwtUpdateCallback here and rename as LclUpdateCallback.
X * V2.6`09    14-Mar-1989`09RDB
X *`09    Change the default width and height to be 200 instead of 100
X * V2.7`09    23-Mar-1989`09RDB
X *`09    change resource default for Foreground
X * V2.8`09    24-mar-1989`09RDB
X *`09    Make knobs mullions
X * V2.9`09    30-Mar-1989`09RDB
X *`09    Redo definitions for panewidgetclass, panewidgetclassrec, mullions
X *`09    Style guide compliancy on vertical & horizontal cursor
X * V2.10    04-Apr-1989`09RDB
X *`09    Change MullionSize to be something like borderwidth &
X *`09    add MullionLength to be the total height of a mullion
X * V2.11    05-Apr-1989`09RDb
X *`09    Make LclUpdateCallback static
X * V2.12    03-May-1989`09RDB
X *`09    MB2 & MB3 cursor changes
X * V2.13    12-May-1989`09RDB
X *`09    make widget_size the PanePart not PaneRec
X * V2.14    15-May-1989`09RDB
X *`09    Geometry Manager doesn't allow widgets to resize
X *`09    DwtPaneMakeViewable error in selecting right subwidget
X * V3.0`09    22-Aug-1989 MRR
X *`09    Copied to V3 library.
X * V3.1`09    29-Aug-1989`09RDB
X *`09    Fix DwtPaneMakeViewable error in setting the widget position
X * V3.2`09    30-AUG-1989 RDB
X *`09    Remove Const from Joel
X * V3.3`09    23-Oct-1989`09RDB
X *`09    New version of pane widget
X */
X#define PANE
X
X#ifdef VMS
X#include <decw$include/DwtWidget.h>
X#include <DECW$CURSOR.h>
X#include "PaneP.h"
X#include "Pane.h"
X#else
X#define NOT_VMS_V1 /* required for part offsets to work before Ultrix 2.2 */
V`20
X#include <X11/DwtWidget.h>
X#include <X11/Convert.h>
X#include <X11/decwcursor.h>
X#include "PaneP.h"
X#include "Pane.h"
X#endif
X
X#ifdef __STDC__
X#undef DwtField
X#undef DwtPartOffset
X#define DwtField(widget, offsetrecord, part, variable, type) \
X`09(*(type *)(((char *) (widget)) + offsetrecord`5BDwt##part##Index`5D + \
X`09`09XtOffset(part##Part *, variable)))
X#define DwtPartOffset(part, variable) \
X        ((Dwt##part##Index) << HALFLONGBITS) + XtOffset(part##Part *, variab
Vle)
X#endif
X
X#define NoMask                     0L
X`20
X#ifndef VMS
Xextern char *DwtDescToNull();  /* jmg */
X#endif VMS
X`20
X/*
X * 'Length' is defined as height for vpanes, and width for hpanes.  'Breadth
V'
X * is the other dimension.
X */
X`20
X#define DwtPaneIndex (DwtConstraintIndex + 1)
X`20
X/* Macros to access pane fields */
X#define PaneField(w,class,field,type)`09`09`09`09\
X`09DwtField((w),`09`09`09`09`09`09\
X`09`09 ((PaneClass)(w)->core.widget_class)->`09`09\
X`09`09 `09pane_class.paneoffsets,class,`09`09\
X`09`09 field,`09`09`09`09`09`09\
X`09`09 type)
X`20
X#define X(w)`09`09PaneField(w,Core,x,Position)
X#define Y(w)`09`09PaneField(w,Core,y,Position)
X`20
X#define Width(w)`09`09PaneField(w,Core,width,Dimension)
X#define Height(w)`09`09PaneField(w,Core,height,Dimension)
X#define BackgroundPixel(w)`09PaneField(w,Core,background_pixel,Pixel)
X`20
X#define Children(w)`09`09PaneField(w,Composite,children,WidgetList)
X#define NumChildren(w)`09`09PaneField(w,Composite,num_children,Cardinal)
X`20
X#define MullionSize(w)`09`09PaneField(w,Pane,mullionsize,Dimension)
X#define MullionLength(w)`09PaneField(w,Pane,mullionlength,Dimension)
X#define LeftMullion(w)`09`09PaneField(w,Pane,leftmullion,Boolean)
X#define Orientation(w)`09`09PaneField(w,Pane,orientation,unsigned char)
X#define PaneNumChildren(w)`09PaneField(w,Pane,num_children,Cardinal)
X#define PaneChildren(w)`09`09PaneField(w,Pane,children,WidgetList)
X#define InterSub(w)`09`09PaneField(w,Pane,intersub,Dimension)
X#define ResizeMode(w)`09`09PaneField(w,Pane,resize_mode,unsigned char)
X#define Foreground(w)`09`09PaneField(w,Pane,foreground,Pixel)
X#define InvGC(w)`09`09PaneField(w,Pane,invgc,GC)
X#define WhichAdjust(w)`09`09PaneField(w,Pane,whichadjust,Widget)
X#define OrigLoc(w)`09`09PaneField(w,Pane,origloc,Position)
X#define OverrideText(w)`09`09PaneField(w,Pane,overridetext,Boolean)
X#define LastHadFocus(w)`09`09PaneField(w,Pane,lasthadfocus,Widget)
X#define HelpCallback(w)`09`09PaneField(w,Pane,helpcallback,DwtCallbackStruct
V)
X`20
X#define FindLength(width, height) \
X    ((Orientation(pane) == DwtOrientationVertical) ? (height) : (width))
X#define FindBreadth(width, height) \
X    ((Orientation(pane) == DwtOrientationVertical) ? (width) : (height))
X`20
X#define FindWidth(length, breadth) \
X    ((Orientation(pane) == DwtOrientationVertical) ? (breadth) : (length))
X#define FindHeight(length, breadth) \
X    ((Orientation(pane) == DwtOrientationVertical) ? (length) : (breadth))
X`20
X#define FindStartLoc(x, y) \
X    ((Orientation(pane) == DwtOrientationVertical) ? (y) : (x))
X`20
X/* Use direct method for Length, safe because core fields guaranteed
X * to be a same offset */
X#define Length(widget)`09FindLength(widget->core.width, widget->core.height)
X#define Breadth(widget)`09FindBreadth(widget->core.width, widget->core.heigh
Vt)
X#define StartLoc(widget)FindStartLoc(widget->core.x, widget->core.y)
X
X#define EventToTime(evtTime, event)`09`09`09`09`09  \
X    switch ((event)->type) `7B`09`09`09`09`09`09  \
X        case KeyPress: `09`09`09`09`09`09`09  \
X        case KeyRelease: `09`09`09`09`09`09  \
X`09`09(evtTime) = (event)->xkey.time; break;`09`09`09  \
X        case ButtonPress: `09`09`09`09`09`09  \
X        case ButtonRelease: `09`09`09`09`09`09  \
X `09`09(evtTime) = (event)->xbutton.time; break;`09`09  \
X`09case MotionNotify: `09`09`09`09`09`09  \
X`09`09(evtTime) = (event)->xmotion.time; break;`09`09  \
X`09case EnterNotify: `09`09`09`09`09`09  \
X`09case LeaveNotify: `09`09`09`09`09`09  \
X`09`09(evtTime) = (event)->xcrossing.time; break;`09`09  \
X`09case PropertyNotify:`09`09`09`09`09`09  \
X`09`09(evtTime) = (event)->xproperty.time; break;`09`09  \
X`09case SelectionClear: `09`09`09`09`09`09  \
X`09`09(evtTime) = (event)->xselectionclear.time; break; `09  \
X`09case SelectionRequest: `09`09`09`09`09`09  \
X`09`09(evtTime) = (event)->xselectionrequest.time; break;`09  \
X`09case SelectionNotify: `09`09`09`09`09`09  \
X`09`09(evtTime) = (event)->xselection.time; break;`09`09  \
X`09default: `09`09`09`09`09`09`09  \
X`09`09(evtTime) = CurrentTime; break;`09`09`09`09  \
X    `7D
X`20
Xstatic Dimension`09resource_min`09    = 1;
Xstatic Dimension`09resource_max`09    = 10000;
Xstatic Dimension`09resource_mullion    = 2;
Xstatic short`09`09resource_spacing = 1;
Xstatic unsigned char`09resource_vert = DwtOrientationVertical;
Xstatic Position `09resource_0_position `09= 0;
X`20
Xstatic DwtPartResource resources`5B`5D = `7B
X`20
X    `7B`09DwtNorientation, `09`09`09/* fixed -- jg */
X`09DwtCOrientation,
X`09XtROrientation,`20
X`09sizeof(unsigned char),
X`09DwtPartOffset(Pane,orientation),`20
X`09DwtROrientation,`20
X`09(caddr_t) &resource_vert`7D,
X`20
X    `7B`09DwtNmullionSize, `09`09`09/* fixed -- jg */
X`09DwtCMullionSize,`20
X`09XtRDimension,`20
X`09sizeof(Dimension),
X`09DwtPartOffset(Pane,mullionsize),`20
X`09XtRDimension,`20
X`09(caddr_t) &resource_mullion`7D,
X`20
X    `7B`09DwtNforeground,  `09`09`09/* fixed -- jg */
X`09DwtCForeground,`20
X`09XtRPixel,`20
X`09sizeof(Pixel),
X`09DwtPartOffset(Pane,foreground),`20
X`09XtRString,`20
X`09DwtSForegroundDefault`7D,
X`20
X    `7B`09DwtNspacing,  `09`09`09/* fixed -- jg */
X`09DwtCSpacing,`20
X`09XtRShort,`20
X`09sizeof(short),
X`09DwtPartOffset(Pane,intersub),`20
X`09XtRShort,`20
X`09(caddr_t) &resource_spacing`7D,
X`20
X    `7B`09DwtNresize, `09`09`09/* fixed -- jg */
X`09DwtCResize,`20
X`09DwtRResize,`20
X`09sizeof(int),
X`09DwtPartOffset(Pane,resize_mode),
X`09XtRImmediate,`20
X`09(caddr_t) DwtResizeGrowOnly`7D,
X`20
X    `7B`09DwtNoverrideText,`09`09/* fixed -- jg */
X`09DwtCOverrideText,`20
X`09XtRBoolean,`20
X`09sizeof(Boolean),
X`09DwtPartOffset(Pane,overridetext),`20
X`09XtRImmediate,`20
X`09(caddr_t) FALSE`7D,
X`20
X    `7B   DwtNmapCallback,
X`09XtCCallback,`20
X`09XtRCallback,`20
X`09sizeof(DwtCallbackPtr),
X`09DwtPartOffset(Pane,map_callback),`20
X`09XtRCallback,`20
X`09(caddr_t) NULL`7D,`09/* fixed -- jg */
X`20
X    `7B   DwtNunmapCallback,
X`09XtCCallback,`20
X`09XtRCallback,`20
X`09sizeof(DwtCallbackPtr),
X`09DwtPartOffset(Pane,unmap_callback),`20
X`09XtRCallback,`20
X`09(caddr_t) NULL`7D,
X`20
X    `7B`09DwtNfocusCallback,`09/* fixed -- jg */
X`09XtCCallback,`20
X`09XtRCallback,`20
X`09sizeof(DwtCallbackPtr),
X`09DwtPartOffset(Pane,focus_callback),`20
X`09XtRCallback,`20
X`09(caddr_t) NULL`7D,
X`20
X    `7B`09DwtNhelpCallback,`09/* fixed -- jg */
X`09XtCCallback,`20
X`09XtRCallback,`20
X`09sizeof(DwtCallbackPtr),
X`09DwtPartOffset(Pane,helpcallback),`20
X`09XtRCallback,`20
X`09(caddr_t) NULL`7D,
X`7D;
X`20
Xstatic XtResource constraints`5B`5D = `7B
X    `7B`09DwtNmin,`20
X`09DwtCMin,
X`09XtRDimension,`20
X`09sizeof(Dimension),
X`09XtOffset(Constraints,min),`20
X`09XtRDimension,`20
X`09(caddr_t) &resource_min`7D,
X`20
X    `7B`09DwtNmax,`20
X`09DwtCMax,`20
X`09XtRDimension,`20
X`09sizeof(Dimension),
X`09XtOffset(Constraints,max),`20
X`09XtRDimension,`20
X`09(caddr_t) &resource_max`7D,
X`20
X    `7B`09DwtNposition,
X`09DwtCPosition,
X`09XtRPosition,`20
X`09sizeof(Position),
X`09XtOffset(Constraints,position),`20
X`09XtRPosition,
X`09(caddr_t) &resource_0_position`7D,
X`20
X    `7B`09DwtNresizable,
X`09XtCBoolean,`20
X`09XtRBoolean,`20
X`09sizeof(Boolean),
X`09XtOffset(Constraints,resizable),`20
X`09XtRImmediate,`20
X`09(caddr_t) TRUE`7D,
X`20
X    `7B`09DwtNsharedFlag,
X`09DwtCSharedFlag,`20
X`09XtRInt,`20
X`09sizeof(int),
X`09XtOffset(Constraints,sharedflag),`20
X`09XtRImmediate,`20
X`09(caddr_t) NoSharedPaneMask`7D,
X`20
X`7D;
X`20
X/*  0xff09 = Tab  */
Xstatic char *textbindings =
X    "Shift<KeyPress>0xff09:`09focus-prev()\n\
X     <KeyPress>0xff09: `09`09focus-next()";
X`20
X`20
Xstatic XtTranslations compiledtextbindings = NULL;
X   `20
Xstatic void LclUpdateCallback();
Xstatic void Help();
Xstatic void HandleMullionEvents();
Xstatic void HandleCancelMullionEvents();
Xstatic void GrabFocus();
Xstatic void FocusNext();
Xstatic void FocusPrev();
Xstatic Boolean AcceptFocus();
Xstatic XtGeometryResult GeometryManager();
Xstatic Boolean SetConstraintValues();
Xstatic void MullionInitialize();
Xstatic void ChangeManaged();
Xstatic void InsertChild();
Xstatic void DeleteChild();
X`20
Xstatic char DefaultMullionTranslation`5B`5D =
X       "<EnterWindow>:`09`09`09                mullion-enter()\n\
X        <LeaveWindow>:`09`09`09`09`09mullion-exit()\n\
X        `7EShift `7ECtrl `7EMod1 `7E@Help<Btn1Down>:            mullion-star
Vt()\n\
X        `7EShift `7ECtrl `7EMod1 `7E@Help Button1<PtrMoved>:    mullion-adju
Vst()\n\
X        `7EShift `7ECtrl `7EMod1 `7E@Help <Btn1Up>:             mullion-end(
V)\n\
X        `7EShift `7ECtrl `7EMod1 `7E@Help<Btn2Down>:            mullion-canc
Vel()\n\
X        `7EShift `7ECtrl `7EMod1 `7E@Help<Btn3Down>:            mullion-canc
Vel()\n\
X        @Help<Btn1Up>:`09`09`09`09`09Help()";
X`20
Xstatic char DefaultTranslation`5B`5D =
X    "@Help<BtnDown>:    `09`09`09`09Help()";
X`20
Xstatic XtActionsRec ActionsTable`5B`5D =`20
X    `7B
X`09`7B"mullion-enter",`09`09(XtActionProc) HandleMullionEvents`7D,
X`09`7B"mullion-exit",`09`09(XtActionProc) HandleMullionEvents`7D,
X`09`7B"mullion-start",`09`09(XtActionProc) HandleMullionEvents`7D,
X`09`7B"mullion-adjust",`09`09(XtActionProc) HandleMullionEvents`7D,
X`09`7B"mullion-end",`09`09(XtActionProc) HandleMullionEvents`7D,
X`09`7B"mullion-cancel",`09`09(XtActionProc) HandleCancelMullionEvents`7D,
X`09`7B"grab-focus",`09`09(XtActionProc) GrabFocus`7D,
X`09`7B"focus-next",`09`09(XtActionProc) FocusNext`7D,
X`09`7B"focus-prev",`09`09(XtActionProc) FocusPrev`7D,
X    `09`7B"Help",                `09(XtActionProc) Help`7D,
X        `7BNULL, NULL`7D
X    `7D;
X`20
Xstatic Cursor VPaneCursor=NULL, HPaneCursor=NULL;
X`0C
Xexternaldef(panewidgetclassrec) PaneClassRec panewidgetclassrec = `7B
X  `7B
X/* core_class fields      */
X    /* superclass         */    (WidgetClass) &constraintClassRec,
X    /* class_name         */    "Pane",
X    /* widget_size        */`09sizeof(PanePart),
X    /* class_initialize   */    ClassInitialize,
X    /* class_part_initial */`09NULL,
X    /* class_inited       */`09FALSE,
X    /* initialize         */    Initialize,
X    /* initialize_hook    */`09NULL,
X    /* realize            */    Realize,
X    /* actions            */    ActionsTable,
X    /* num_actions`09  */`09XtNumber(ActionsTable),
X    /* resources          */    (XtResource *) resources,
X    /* num_resources      */    XtNumber(resources),
X    /* xrm_class          */    NULLQUARK,
X    /* compress_motion`09  */`09TRUE,
X    /* compress_exposure  */`09TRUE,
X    /* compress_enterleave*/`09TRUE,
X    /* visible_interest   */    FALSE,
X    /* destroy            */    Destroy,
X    /* resize             */    Resize,
X    /* expose             */    NULL,
X    /* set_values         */    SetValues,
X    /* set_values_hook    */    NULL,
X    /* set_values_almost  */    NULL,
X    /* get_values_hook    */    NULL,
X    /* accept_focus       */    AcceptFocus,
X    /* version`09`09  */`09XtVersionDontCheck,
X    /* callbacks          */    NULL,
X    /* tm_table           */    DefaultTranslation,
X    /* disp accelerator   */    NULL,
X    /* extension`09  */`09NULL
X  `7D,`7B
X/* composite_class fields */
X    /* geometry_manager   */    GeometryManager,
X    /* change_managed     */    ChangeManaged,
X    /* insert_child`09  */`09InsertChild,
X    /* delete_child`09  */`09DeleteChild,
X    /* extension`09  */`09NULL
X  `7D,`7B
X/* constraint_class fields */
X    /* constraint resource list            */ (XtResourceList) constraints,
X    /* number of constraints in list       */ XtNumber(constraints),
X    /* size of constraint record           */ sizeof(ConstraintsRec),
X    /* constraint initialization           */ NULL,
X    /* constraint destroy proc             */ NULL,
X    /* constraint set_values proc          */ SetConstraintValues,
X    /* extension`09`09`09   */ NULL
X  `7D,`7B
X    /* offsets`09`09  */`09NULL,
X    /* mumble`09`09  */`090`09/* Make C compiler happy   */
X  `7D
X`7D;
X`20
Xexternaldef(panewidgetclass) PaneClass panewidgetclass = &panewidgetclassrec
V;
X`20
Xstatic struct _WidgetClassRec mullionClassRec = `7B
X    /* superclass         */  (WidgetClass) &widgetClassRec,
X    /* class name         */   "Mullion",
X    /* size               */   sizeof(MullionRec),
X    /* class initialize   */   NULL,
X    /* class_part_initial */   NULL,
X    /* class_inited       */   FALSE,
X    /* initialize         */   MullionInitialize,
X    /* initialize_hook    */   NULL,
X    /* realize            */   XtInheritRealize,
X    /* actions            */   ActionsTable,
X    /* num_actions        */   XtNumber(ActionsTable),
X    /* resources`09  */   NULL,
X    /* num_resources      */   0,
X    /* xrm_class          */   NULLQUARK,
X    /* compress_motion    */   TRUE,
X    /* compress_exposure  */   TRUE,
X    /* compress enterleave*/   TRUE,
X    /* visible_interest   */   FALSE,
X    /* destroy            */   NULL,
X    /* resize             */   NULL,
X    /* expose             */   NULL,
X    /* set_values         */   NULL,
X    /* set_values_hook    */   NULL,
X    /* set_values_almost  */   NULL,
X    /* get_values_hook    */   NULL,
X    /* accept_focus       */   NULL,
X    /* version`09`09  */   XtVersionDontCheck,
X    /* callbacks          */   NULL,
X    /* tm_table           */   DefaultMullionTranslation,
X    /* query_geometry`09  */   XtInheritQueryGeometry,
X    /* display_accelerator*/   NULL,
X    /* extension`09  */   NULL
X`7D;
X`20
Xstatic WidgetClass mullionWidgetClass = (WidgetClass) &mullionClassRec;
X`20
X#define DataFromWidget(subwidget) (Constraints)subwidget->core.constraints
X`20
Xstatic void MullionInitialize(unused_request, w)
XWidget unused_request, w;
X`7B
X    PaneWidget pane = (PaneWidget) w->core.parent;
X    w->core.border_pixel = Foreground(pane);
X    w->core.border_width = MullionSize(pane);
X    w->core.width = FindWidth(InterSub(pane),Breadth(pane));
X    w->core.height = FindHeight(InterSub(pane),Breadth(pane));
X    w->core.x = w->core.y = -99;
X`7D
X`20
X`0C
X/*
X * Figure out what length of the window we're actually using.  Ideally, this
X * will be the same as the window's length, but it will often be different
X * (for example, when we don't have enough windows to take up the entire
X * window's length.)
X */
X`20
Xstatic Dimension LengthUsed(pane)
XPaneWidget pane;
X`7B
X    Dimension result;
X    int i, cnt;
X    Constraints subdata, nextsubdata;
X    Boolean allfixed;
X
X    if (PaneNumChildren(pane) == 0) return 0;
X    result = 0;
X    for (i=0 ; i<PaneNumChildren(pane); i++)
X`09`7B
X`09result += Length(PaneChildren(pane)`5Bi`5D);
X`09subdata = DataFromWidget(PaneChildren(pane)`5Bi`5D);
X`09if (i < PaneNumChildren(pane) - 1)`20
X`09    `7B`20
X`09    result += MullionLength(pane);
X`09    `7D`20
X`09`7D
X    return result;
X`7D
X`20
X`20
X`0C
X/*
X * Set the dheight field of each subwidget to be the appropriate height if w
Ve
X * want to move the border below the given subwidget by the given number of
X * pixels.
X */
X`20
Xstatic void RefigureDlengths(pane, sub, delta)
XPaneWidget pane;
XWidget sub;
Xint delta;
X`7B
X    int cur_above, min_above, max_above;
X    int cur_below, min_below, max_below;
X    int used;
X    Boolean currentlyabove;
X    Widget subwidget;
X    Constraints subdata;
X    int i, which, temp, newlength;
X   `20
X    /*
X     * if we allow resizing of the pane we will just reset the child`20
X     * between the min and the max if it isn't already.
X     */
X    if (ResizeMode(pane) != DwtResizeFixed) `7B
X`09for (i=0 ; i<PaneNumChildren(pane) ; i++) `7B
X`09    subwidget = PaneChildren(pane)`5Bi`5D;
X`09    subdata = DataFromWidget(subwidget);
X`09    /*
X`09     * This only looks tough. If the ResizeMode(pane) == GrowOnly and
X`09     * the length is less than 0 then DONT reset the dlength to be the
X`09     * new length. Otherwise make the newlength the dlength.
X`09     */
X`09    if (ResizeMode(pane) != DwtResizeGrowOnly &&
X`09`09    Length(subwidget) > subdata->dlength)
X`09`09`09subdata->dlength = Length(subwidget);
X`09    /* if the subwidget cannot be resized set the min and max to
X`09     * the created length of the widget.
X`09     */`20
X`09    if (subdata->resizable)
X`09`09`7B
X`09`09if (subdata->dlength < subdata->min)
X`09`09    subdata->dlength = subdata->min;
X`09`09if (subdata->dlength >subdata->max)
X`09`09    subdata->dlength = subdata->max;
X`09`09`7D
X`09    else
X`09`09`7B
X`09`09subdata->min = subdata->max = subdata->dlength;
X`09`09`7D
X`09`7D/* end for */
X`09return;
X    `7D
X    /* Ok no resizing allowed so we have to be a little more particular
X     */
X    cur_above = min_above = max_above = 0;
X    cur_below = min_below = max_below = 0;
X    currentlyabove = TRUE;
X    /* Find the length above & including the changed widget & the length
X     * below this widget. Total above & below on current, maximium and
X     * minimium
X     */
X    for (i=0 ; i<PaneNumChildren(pane) ; i++) `7B
X`09subwidget = PaneChildren(pane)`5Bi`5D;
X`09subdata = DataFromWidget(subwidget);
X`09if (currentlyabove) `7B
X`09    cur_above += Length(subwidget);
X`09    min_above += subdata->min;
X`09    max_above += subdata->max;
X`09`7D else `7B
X`09    cur_below += Length(subwidget);
X`09    min_below += subdata->min;
X`09    max_below += subdata->max;
X`09`7D
X`09if (subwidget == sub) `7B
X`09    which = i;
X`09    currentlyabove = FALSE;
X`09`7D
X    `7D /* end for loop */
X    if (currentlyabove)
X`09XtWarning("Never found the subwidget in Pane.");
X    used = LengthUsed(pane);
X    if (used < Length(pane)) min_below -= Length(pane) - used;
X    else max_below += used - Length(pane);
X    if (delta < min_above - cur_above) delta = min_above - cur_above;
X    if (delta < cur_below - max_below) delta = cur_below - max_below;
X    if (delta > max_above - cur_above) delta = max_above - cur_above;
X    if (delta > cur_below - min_below) delta = cur_below - min_below;
X    temp = delta;
X    /* a for loop is easier to read here. Also why continue if temp = 0?
X     * And further more there is no good reason to reset temp.
X     */
X    for (i = which; i >= 0; i--)
X`09`7B
X`09subwidget = PaneChildren(pane)`5Bi`5D;
X`09subdata = DataFromWidget(subwidget);
X`09/* only make changes if we can resize this widget
X`09 */
X`09if (subdata->resizable)
X`09    `7B
X`09    newlength = Length(subwidget) + temp;
X`09    if (newlength < (int) subdata->min) newlength = subdata->min;
X`09    if (newlength > (int) subdata->max) newlength = subdata->max;
X`09    subdata->dlength = newlength;
X`09    `7D
X`09else
X`09    `7B
X`09    subdata->min = subdata->max = subdata->dlength = Length(subwidget);
X`09    `7D
X`09temp -= (subdata->dlength - Length(subwidget));
X`09`7D
X    /* take what ever was gained on the top and put it on the bottom
X     */
X    temp = -delta;
X    for (i = which+1; i < PaneNumChildren(pane); i++)
X`09`7B
X`09subwidget = PaneChildren(pane)`5Bi`5D;
X`09subdata = DataFromWidget(subwidget);
X`09/* only make changes if we can resize this widget
X`09 */
X`09if (subdata->resizable)
X`09    `7B
X`09    newlength = Length(subwidget) + temp;
X`09    if (newlength < (int) subdata->min) newlength = subdata->min;
X`09    if (newlength > (int) subdata->max) newlength = subdata->max;
X`09    subdata->dlength = newlength;
X`09    `7D
X`09else
X`09    `7B
X`09    subdata->min = subdata->max = subdata->dlength = Length(subwidget);
X`09    `7D
X`09temp -= (subdata->dlength - Length(subwidget));
X`09`7D
X`7D
X`20
X`20
X`0C
Xstatic void TryToFillPane(pane)
XPaneWidget pane;
X`7B
X    int used, length;
X    length = Length(pane);
X    used = LengthUsed(pane);
X    if (PaneNumChildren(pane) > 0)
X`09RefigureDlengths(pane, PaneChildren(pane)`5BPaneNumChildren(pane)-1`5D,
X`09`09`09 length - used);
X`7D
X`20
X`0C
Xstatic void CommitNewSizes(pane, dontnotify)
XPaneWidget pane;
XWidget dontnotify;
X`7B
X    XWindowChanges changes;
X    Position loc;
X    int i, cnt;`20
X    Widget subwidget, nextsubwidget, mullion;
X    Constraints subdata, nextsubdata;
X    Boolean allfixed;
X    loc = 0;
X    for (i=0 ; i<PaneNumChildren(pane) ; i++)`20
X`09`7B
X`09/* Do the subwidget first
X`09 */
X`09subwidget = PaneChildren(pane)`5Bi`5D;
X`09subdata = DataFromWidget(subwidget);
X`09/* depending on the orientation we'll change the subwidgets
X`09 * x, width or y, height.
X`09 */
X`09changes.x = FindWidth(loc, 0);
X`09changes.y = FindHeight(loc, 0);
X`09changes.width = FindWidth(subdata->dlength, Breadth(pane));
X`09changes.height = FindHeight(subdata->dlength, Breadth(pane));
X`09changes.border_width = 0;
X`09if (changes.x != subwidget->core.x `7C`7C changes.y != subwidget->core.y
V `7C`7C
X`09      changes.width != subwidget->core.width `7C`7C
X`09      changes.height != subwidget->core.height `7C`7C
X`09      changes.border_width != subwidget->core.border_width)`20
X`09    `7B
X`09    subwidget->core.x = changes.x;
X`09    subwidget->core.y = changes.y;
X`09    subwidget->core.width = changes.width;
X`09    subwidget->core.height = changes.height;
X`09    subwidget->core.border_width = changes.border_width;
X`09    if (XtIsRealized(subwidget))   `20
X`09`09`7B
X`09`09XConfigureWindow(XtDisplay(subwidget), XtWindow(subwidget),
X`09`09    (unsigned) CWX `7CCWY `7C CWWidth `7C CWHeight `7C CWBorderWidth,
X`09`09    &changes);
X`09`09`7D
X`09    if (subwidget != dontnotify &&
X`09`09 XtClass(subwidget)->core_class.resize != (XtWidgetProc) NULL)
X`09`09`7B
X`09`09(*(subwidget->core.widget_class->core_class.resize))(subwidget);
X`09`09`7D
X`09    `7D
X`09loc += Length(subwidget);
X
X`09/* Now position the mullion`20
X`09 */
X`09mullion = subdata->mullion;
X`20
X`09/* Get any new width and height
X`09 */
X`09changes.width = FindWidth(InterSub(pane),Breadth(pane));
X`09changes.height = FindHeight(InterSub(pane),Breadth(pane));
X`09changes.border_width = MullionSize(pane);
X`20
X`09/* Move this mullion where they can't get to it if
X`09 * the subwidget is the last child
X`09 */
X`09if (i < PaneNumChildren(pane) - 1)`20
X`09    `7B`20
X`09    changes.x = FindWidth(loc, 0);
X`09    changes.y = FindHeight(loc, 0);
X`09    loc += MullionLength(pane);
X`09    `7D`20
X`09else`20
X`09    `7B
X    `09    changes.x = changes.y = -99;
X`09    loc += InterSub(pane);
X`09    `7D
X`09    mullion->core.x = changes.x;
X`09    mullion->core.y = changes.y;
X`09    mullion->core.width = changes.width;
X`09    mullion->core.height = changes.height;
X`09    mullion->core.border_width = changes.border_width;
X`09    if (XtIsRealized(mullion))
X`09`09`7B
X`09`09XConfigureWindow(XtDisplay(mullion), XtWindow(mullion),
X`09`09    (unsigned) CWX `7C CWY `7C CWWidth `7C CWHeight `7C CWBorderWidth,
X`09`09    &changes);
X`09`09XRaiseWindow(XtDisplay(mullion), XtWindow(mullion));
X`09`09`7D
X    `7D
X`7D
X`20
X`20
X`0C
X/*
X * Invert the given border.
X */
X`20
Xstatic void InvertIt(pane, loc, mullionlength)
XPaneWidget pane;
XPosition loc;
XDimension mullionlength;
X`7B
X    loc += mullionlength / 2 + 1;   /* Deal with X's definition that wide */
X`09`09`09`09    /* lines are centered around the */
X`09`09`09`09    /* specified points.  */
X`20
X    XDrawLine(XtDisplay(pane), XtWindow(pane), InvGC(pane),
X`09      FindWidth(loc, 0), FindHeight(loc, 0),
X`09      FindWidth(loc, Breadth(pane)), FindHeight(loc, Breadth(pane)));
X`7D
X`20
X`20
X`0C
X/*
X * Move the magic borders to the location specified by the current dlength
X * values.`20
X */
X`20
Xstatic void MoveMagicBorders(pane)
XPaneWidget pane;
X`7B
X    Position loc;
X    int i, cnt;
X    Constraints subdata, nextsubdata;
X    Boolean allfixed;
X
X    loc = 0;
X    for (i=0 ; i<PaneNumChildren(pane) ; i++)
X`09`7B
X`09subdata = DataFromWidget(PaneChildren(pane)`5Bi`5D);
X`09loc += subdata->dlength;
X`09if (loc != subdata->magicborder)`20
X`09    `7B
X`09    if (PaneChildren(pane)`5Bi`5D == WhichAdjust(pane))
X`09`09`7B
X`09`09if (subdata->magicborder != OrigLoc(pane))`20
X`09`09    InvertIt(pane, subdata->magicborder, MullionLength(pane));
X`09`09if (loc != OrigLoc(pane))`20
X`09`09    InvertIt(pane, loc, MullionLength(pane));`20
X`09`09`7D
X`09    else
X`09`09`7B
X`09`09if (subdata->magicborder !=`20
X`09`09   (StartLoc(PaneChildren(pane)`5Bi`5D) + Length(PaneChildren(pane)`5B
Vi`5D)))
X`09`09    InvertIt(pane, subdata->magicborder, MullionLength(pane));
X`09`09if (loc !=`20
X`09`09   (StartLoc(PaneChildren(pane)`5Bi`5D) + Length(PaneChildren(pane)`5B
Vi`5D)))
X`09`09    InvertIt(pane, loc, MullionLength(pane));
X`09`09`7D
X`09    subdata->magicborder = loc;
X`09    `7D
X`09if (i < PaneNumChildren(pane) - 1)`20
X`09    `7B
X`09    loc += MullionLength(pane);
X`09    `7D
X`09else`20
X`09    `7B
X`09    loc += InterSub(pane);
X`09    `7D
X`09`7D
X`7D
X`20
X`0C
X/*
X * Turn on the magic borders.
X */
X`20
Xstatic void DrawMagicBorders(pane)
XPaneWidget pane;
X`7B
X    Position loc;
X    int i, cnt;
X    Constraints subdata, nextsubdata;
X    Boolean allfixed;
X
X    loc = 0;
X    for (i=0 ; i<PaneNumChildren(pane) ; i++) `7B
X`09subdata = DataFromWidget(PaneChildren(pane)`5Bi`5D);
X`09loc += subdata->dlength;
X`09subdata->magicborder = loc;
X`09if (i < PaneNumChildren(pane) - 1)`20
X`09    `7B`20
X`09    loc += MullionLength(pane);
X`09    `7D`20
X`09else`20
X`09    `7B
X`09    loc += InterSub(pane);
X`09    `7D
X    `7D
X`7D
X`20
X`0C
X/*
X * Turn off the magic borders.
X */
X`20
Xstatic void EraseMagicBorders(pane)
XPaneWidget pane;
X`7B
X    int`09`09i;
X    Constraints subdata;
X    for (i=0 ; i<PaneNumChildren(pane) ; i++)`20
X`09`7B
X`09if (PaneChildren(pane)`5Bi`5D == WhichAdjust(pane))
X`09    `7B
X`09    subdata = DataFromWidget(PaneChildren(pane)`5Bi`5D);
X`09    if (subdata->magicborder != OrigLoc(pane))
X`09`09InvertIt(pane, subdata->magicborder, MullionLength(pane));
X`09    `7D
X`09else
X`09    `7B
X`09    subdata = DataFromWidget(PaneChildren(pane)`5Bi`5D);
X`09    if (subdata->magicborder !=`20
X`09       (StartLoc(PaneChildren(pane)`5Bi`5D) + Length(PaneChildren(pane)`5
VBi`5D)))
X`09`09InvertIt(pane, subdata->magicborder, MullionLength(pane));
X`09    `7D
X`09`7D
X    XClearWindow(XtDisplay(pane), XtWindow(pane));
X`7D
X`20
X`20
X`0C
X/*
X * Find where (lengthwise) in the pane window the given event is pointing.
X * (The event was delivered to the given widget.)
X */
X`20
Xstatic Position FindWherePointing(pane, widget, event)
XPaneWidget pane;
XWidget widget;
XXEvent *event;
X`7B
X    Position x, y;
X    x = event->xbutton.x;
X    y = event->xbutton.y;
X    while (widget != (Widget) pane) `7B
X`09x += widget->core.x;
X`09y += widget->core.y;
X`09widget = widget->core.parent;
X    `7D
X    return FindLength(x, y);
X`7D
X`20
X`20
X`0C
X/*
X * Given that the button down event was delivered to the mullion,
X * figure out which window is above the border that the user is trying to
X * adjust. `20
X */
X`20
Xstatic Widget FindWhichAdjust(pane, widget, event)
XPaneWidget pane;
XWidget widget;
XXEvent *event;
X`7B
X    Widget result;
X    Position where, loc;
X    int i;
X    Constraints subdata;
X
X    where = FindWherePointing(pane, widget, event);
X    loc = MullionLength(pane)/2 + 1;
X    result = PaneChildren(pane)`5B0`5D;
X    for (i=0 ; i<PaneNumChildren(pane) ; i++) `7B
X`09widget = PaneChildren(pane)`5Bi`5D;
X`09if (loc < where) result = widget;
X`09    else break;
X`09subdata = DataFromWidget(widget);
X`09loc += Length(widget) + MullionLength(pane);
X    `7D
X    return result;
X`7D
X`20
X`0C
X/*
X * Handle button events in the mullion window.
X */
X`20
Xstatic void HandleMullionEvents(widget, event)
XWidget widget;
XXEvent *event;
X`7B
X    PaneWidget pane = (PaneWidget) widget->core.parent;
X    if (PaneNumChildren(pane) == 0) return;
X    switch (event->type) `7B
X      case EnterNotify:
X`09if (Orientation(pane) == DwtOrientationVertical)
X`09    `7B
X`09    XDefineCursor (XtDisplay(widget->core.parent), XtWindow(widget->core.
Vparent), VPaneCursor);
X`09    `7D
X`09else
X`09    `7B
X`09    XDefineCursor (XtDisplay(widget->core.parent), XtWindow(widget->core.
Vparent), HPaneCursor);
X`09    `7D
X`09LeftMullion(pane) = False;
X`09break;
X      case LeaveNotify:
X`09if (WhichAdjust(pane) == NULL)
X`09    `7B
X`09    XUndefineCursor (XtDisplay(widget->core.parent), XtWindow(widget->cor
Ve.parent));
X`09    `7D
X`09else
X`09    `7B
X`09    LeftMullion(pane) = True;
X`09    `7D
X`09break;
X      case ButtonPress:
X`09WhichAdjust(pane) = FindWhichAdjust(pane, widget, event);
X/*
X * The OrigLoc is the Origicnal location of the dividing line between two pa
Vnes. It is
X * calculated by adding the starting location (x or y depending on orientati
Von) to
X * the length (width or height depending on orientation)`20
X */
X`09OrigLoc(pane) = StartLoc(WhichAdjust(pane)) + Length(WhichAdjust(pane));
X`09RefigureDlengths(pane, WhichAdjust(pane), 0);
X`09DrawMagicBorders(pane);
X`09break;
X      case MotionNotify:
X`09if (WhichAdjust(pane) == NULL) break;
X`09RefigureDlengths(pane, WhichAdjust(pane),
X`09`09`09 FindWherePointing(pane, widget, event) -
X`09`09`09     OrigLoc(pane));
X`09MoveMagicBorders(pane);
X`09break;
X      case ButtonRelease:
X/*`20
X * make sure the operation wasn't canceled`20
X*/
X`09if (WhichAdjust(pane) != NULL)`20
X`09    `7B
X`09    RefigureDlengths(pane, WhichAdjust(pane),
X`09`09`09     FindWherePointing(pane, widget, event) -
X`09`09`09`09 OrigLoc(pane));
X`09    MoveMagicBorders(pane);
X`09    EraseMagicBorders(pane);
X`09    CommitNewSizes(pane, (Widget) NULL);
X`09    WhichAdjust(pane) = NULL;
X`09    `7D
X`09if (LeftMullion(pane))
X`09    `7B
X`09    XUndefineCursor (XtDisplay(widget->core.parent), XtWindow(widget->cor
Ve.parent));
X`09    LeftMullion(pane) = False;
X`09    `7D
X`09break;
X    `7D
X`7D
X`20
X/*
X * Handle cancel (MB2 & MB3 press) button events in the mullion window.
X */
X`20
Xstatic void HandleCancelMullionEvents(widget)
XWidget widget;
X`7B
X    PaneWidget pane = (PaneWidget) widget->core.parent;
X    if (PaneNumChildren(pane) == 0) return;
X    if (LeftMullion(pane))
X`09`7B
X`09EraseMagicBorders(pane);
X`09XUndefineCursor (XtDisplay(widget->core.parent), XtWindow(widget->core.pa
Vrent));
X`09LeftMullion(pane) = False;
X`09`7D
X    WhichAdjust(pane) = NULL;
X`7D
X`0C
Xstatic void ClassInitialize(unused_w)
XWidget unused_w;
X`7B
X    DwtResolvePartOffsets(panewidgetclass,
X`09`09 &panewidgetclassrec.pane_class.paneoffsets);
X    compiledtextbindings = XtParseTranslationTable (textbindings);
X`7D
X   `20
X`20
X`20
X`20
X`0C
X/*
X * Initialize this instance of pane.
X */
X`20
Xstatic void Initialize(unused_request, w)
XWidget unused_request, w;
X`7B
X    PaneWidget pane = (PaneWidget) w;
X    XGCValues values;
X`20
X/*
X**  Create the pane cursors...
X*/
X    if (VPaneCursor == NULL)
X`09`7B
X    /*
X     *  Local data for the pane cursor
X     *`09Note: Normally one would do this sort of thing in ClassInitialize b
Vut,
X     *`09setting up cursors requires a live widget which ClassInit doesn't h
Vave.
X     */
X`09XColor cursor_fore, cursor_back;
X`09Font   cursor_font;
X`09int    cursor_wait;
X`20
X    /*
X    **  Set up the colors
X    */
X`09cursor_fore.pixel = 0;
X`09cursor_fore.red   = 65535;
X`09cursor_fore.green = 65535;
X`09cursor_fore.blue  = 65535;
X`20
X`09cursor_back.pixel = 0;
X`09cursor_back.red   = 0;
X`09cursor_back.green = 0;
X`09cursor_back.blue  = 0;
X`20
X`09cursor_font = XLoadFont (XtDisplay(w), "decw$cursor");
X`09cursor_wait = decw$c_vpane_cursor;
X`09VPaneCursor = XCreateGlyphCursor (XtDisplay(w), cursor_font, cursor_font,
V cursor_wait,`20
X`09`09`09`09`09`09     cursor_wait + 1, &cursor_fore, &cursor_back);
X`09cursor_wait = decw$c_hpane_cursor;
X`09HPaneCursor = XCreateGlyphCursor (XtDisplay(w), cursor_font, cursor_font,
V cursor_wait,`20
X`09`09`09`09`09`09     cursor_wait + 1, &cursor_fore, &cursor_back);
X`09XUnloadFont (XtDisplay(w), cursor_font);
X`09`7D
X`20
X    if (Width(pane) == 0) Width(pane) = 200; /* Better default?%%% */
X    if (Height(pane) == 0) Height(pane) = 200;
X    PaneNumChildren(pane) = 0;
X    PaneChildren(pane) = NULL;
X    WhichAdjust(pane) = NULL;
X    OrigLoc(pane) = 0;
X    LastHadFocus(pane) = NULL;
X    MullionLength(pane) = (MullionSize(pane) * 2) + InterSub(pane);
X    values.function = GXinvert;
X    values.foreground = BackgroundPixel(pane) `5E Foreground(pane);
X    if (values.foreground == 0) values.foreground = 1;
X    values.line_width = InterSub(pane);
X    if (values.line_width == 1)
X`09values.line_width = 0;`09/* Take advantage of fast server lines. */
X    values.plane_mask = BackgroundPixel(pane) `5E Foreground(pane);
X    values.fill_style = FillSolid;
X    values.subwindow_mode = IncludeInferiors;
X    InvGC(pane) = XtGetGC(w,
X`09`09`09       (XtGCMask) GCFunction `7C GCForeground
X`09`09`09       `7C GCLineWidth `7C GCPlaneMask `7C GCFillStyle
X`09`09`09       `7C GCSubwindowMode,
X`09`09`09       &values);
X`7D
X`20
X`0C
X/*
X * Realize the pane widget.
X */
X`20
Xstatic void Realize(w, vMask, attributes)
XWidget w;
XMask *vMask;
XXSetWindowAttributes *attributes;
X`7B
X    PaneWidget pane = (PaneWidget) w;
X    Mask valueMask = *vMask;
X`20
X    if (ResizeMode(pane) != DwtResizeFixed) `7B
X/*
X * For now the ResizeMode is forced to DwtResizeFixed so that you can move t
Vhe
X * mullion once you get this beast up. If the user wants to change the pane
V widget
X * back he should call DwtPaneAllowResizing, do the work in adjusting the wi
Vdget
X * and then reset the value back.
X *`20
X * This needs to be changed and modeled after the DIALOG widget. See the`20
X * adapt_to_kids routine.
X */
X`09ResizeMode(pane) = DwtResizeFixed;
X`09TryToFillPane(pane);
X`09CommitNewSizes(pane, (Widget) NULL);
X    `7D
X   `20
X    attributes->bit_gravity = NorthWestGravity;
X    attributes->background_pixel = Foreground(pane);
X    valueMask `7C= CWBitGravity `7C CWBackPixel;
X   `20
X    XtCreateWindow(w, (unsigned int) InputOutput, (Visual *) CopyFromParent,
X`09`09   valueMask, attributes);
X`7D
X`20
X`0C
X/*
X * Destroy the pane widget.
X */
X`20
Xstatic void Destroy(w)
XWidget w;
X`7B
X    PaneWidget pane = (PaneWidget) w;
X`20
X/* Free the memory allocated for the children that are displayed and those i
Vn`20
X * the composite field. We created and allocated space for them it so we
X * must Free it.
X */
X    XtFree((char *)Children(pane));
X    XtFree((char *)PaneChildren(pane));
X`20
X/*
X * Remove all callbacks that were created
X */
X    XtRemoveAllCallbacks ((Widget)pane, DwtNhelpCallback);
X    XtRemoveAllCallbacks ((Widget)pane, DwtNfocusCallback);
X    XtRemoveAllCallbacks ((Widget)pane, DwtNmapCallback);
X    XtRemoveAllCallbacks ((Widget)pane, DwtNunmapCallback);
X/*
X *  Free the InvGC that was created
X */
X    XtDestroyGC (InvGC(pane));
X`7D
X`20
X`0C
X/*
X * The purpose of this routine is to check and see in the Vertical`20
X * orientation if a change in width will also change a subwidgets height
X */
X`20
Xstatic void CheckHeightChanges(pane)
X    PaneWidget pane;
X`7B
X    XtWidgetGeometry intended, reply;
X    Widget subwidget;
X    Constraints subdata;
X    int i;
X`20
X    if (Orientation(pane) != DwtOrientationVertical) return;`20
X`20
X    intended.request_mode = CWWidth;`09`09/* ask about this width */
X`20
X    for (i=0 ; i<PaneNumChildren(pane); i++)`20
X`09`7B
X`09subwidget = PaneChildren(pane)`5Bi`5D;
X`09subdata = DataFromWidget(subwidget);
X`09if (!subdata->resizable)
X`09    `7B
X`09    intended.width = Width(pane);   /* if it affects the size */
X`09`09`09`09`09    /* he'll tell us */
X`20
X`09    switch (XtQueryGeometry (subwidget, &intended, &reply))
X`09`09`7B
X`09`09case XtGeometryAlmost:`09`09/* he wants to compromise */
X`20
X`09`09    if ((reply.request_mode & CWHeight) &&
X`09`09`09    subwidget->core.height != reply.height)
X`09`09`09`7B
X`09`09`09/* take height he suggests */
X`09`09`09subwidget->core.height = reply.height;`09
X`09`09`09RefigureDlengths(pane,subwidget,subdata->dlength -
X`09`09`09`09`09    reply.height);
X`09`09`09`7D
X`09`09    break;
X`20
X`09`09case XtGeometryYes:
X`09`09case XtGeometryNo:
X`09`09`09/* he agrees, no problem w/ */
X`09`09`09/* current height */
X`09`09    break;
X`09`09`7D /* end case */
X`09    `7D /* end if */
X`09`7D /* end for loop */
X`7D
X`20
X`0C
X/*
X * The pane widget has been resized; handle everything.
X */
X`20
Xstatic void Resize(w)
XWidget w;
X`7B
X    PaneWidget pane = (PaneWidget) w;
X    CheckHeightChanges(pane);
X    TryToFillPane(pane);
X    CommitNewSizes(pane, (Widget) NULL);
X`7D
X`20
X`0C
X/*
X * Resources in the pane widget have changed; handle it.
X */
X`20
Xstatic Boolean SetValues (old, unused_request, new)
X    Widget old, unused_request, new;
X`7B
X    PaneWidget`09oldpane = (PaneWidget) old;
X    PaneWidget`09newpane = (PaneWidget) new;
X    Boolean`09redisplay = FALSE;
X    XGCValues`09values;
X`20
X/*
X * Update the callbacks
X */
X    LclUpdateCallback (`09    &(oldpane->pane.map_callback),
X`09`09`09 (Widget) newpane, &(newpane->pane.map_callback), DwtNmapCallback);
X    LclUpdateCallback (`09    &(oldpane->pane.unmap_callback),
X`09`09`09 (Widget) newpane, &(newpane->pane.unmap_callback), DwtNunmapCallba
Vck);
X    LclUpdateCallback (`09    &(oldpane->pane.helpcallback),
X`09`09`09 (Widget) newpane, &(newpane->pane.helpcallback), DwtNhelpCallback)
V;
X    LclUpdateCallback (`09    &(oldpane->pane.focus_callback),
X`09`09`09 (Widget) newpane, &(newpane->pane.focus_callback), DwtNfocusCallba
Vck);
X`20
X/*
X * For now ignore orientation changes
X */
X    if (Orientation(newpane) != Orientation(oldpane))
X`09`7B
X`09Orientation(newpane) = Orientation(oldpane);
X`09`7D
X`20
X/*
X * For now ignore resize mode change
X */
X    if (ResizeMode(newpane) != ResizeMode(oldpane))
X`09`7B
X`09ResizeMode(newpane) = ResizeMode(oldpane);
X`09`7D
X/*
X * Something should be done with foreground here but I don't think that work
Vs
X * anyway so wait till you fix it latter
X */
X`20
X/*
X * Check the mullion and spacing for changes. If so set redisplay
X */
X    if ((MullionSize(newpane) != MullionSize(oldpane)) `7C`7C
X`09(InterSub(newpane) != InterSub(oldpane)))
X`09    `7B
X/*
X * Change the inverted lines width to InterSub new length
X */
X`09    if (InterSub(newpane) != InterSub(oldpane))
X`09`09`7B
X`09`09values.line_width = InterSub(newpane);
X`09`09if (values.line_width == 1)
X`09`09    values.line_width = 0;`09/* Take advantage of fast server lines. *
V/
X`09`09XChangeGC (XtDisplay(newpane),InvGC(newpane), GCLineWidth, &values);
X`09`09`7D
X#ifdef bugfixed
X/*
X * Currently there is a bug in the XConfirgureWindow which prevents reseting
V of
X * the border width. In the mean time don't allow any change in MullionSize.
X */
X`09    MullionLength(newpane) = (MullionSize(newpane) * 2) + InterSub(newpan
Ve);
X#else
X`09    MullionSize(newpane) = MullionSize(oldpane);
X#endif
X/*`20
X * if the mullions need to be changed in width and or height they will be ch
Vanged
X * in the CommitNewSizes routine.`20
X */
X`09    redisplay = TRUE;
X`09    TryToFillPane(newpane);
X`09    CommitNewSizes(newpane, (Widget) NULL);
X`09    `7D
X`20
X    return redisplay;
X`7D`09
X
X/*
X * SetValue on the callback is interpreted as replacing
X * all callbacks
X */
X
Xstatic void
XLclUpdateCallback (rstruct, s, sstruct, argname)
X    DwtCallbackStructPtr rstruct;`09`09/* the real callback list */
X    Widget s;`09`09`09`09`09/* the scratch widget*/
X    DwtCallbackStructPtr sstruct;`09`09/* the scratch callback list */
X    char           *argname;
X`7B
X    DwtCallbackPtr list;
X
X    /*
X     * if a new callback has been specified in the scratch widget,
X     * remove and deallocate old callback and init new`20
X     */
X    if (rstruct->ecallback != sstruct->ecallback)
X    `7B
X`09list = (DwtCallbackPtr)sstruct->ecallback;
X`09/*
X`09 *  Copy the old callback list into the new widget, since
X`09 *  XtRemoveCallbacks needs the "real" widget
X    `09 */
X        *sstruct = *rstruct;
X`09XtRemoveAllCallbacks(s, argname);
X`09sstruct->ecallback = NULL;
X`09XtAddCallbacks(s, argname, list);
X    `7D
X`7D
X`20
X`20
X`20
X`0C
Xstatic Boolean SetConstraintValues(current, unused_widget, newWidget)
X    Widget   current, unused_widget, newWidget;
X`7B
X    Constraints cur, new;
X    Cardinal`09position;
X    Dimension`09min, max;
X    Boolean`09resizable;
X    Cardinal`09sharedflag;
X    Boolean`09do_add_widget = FALSE;
X`20
X    cur = DataFromWidget(current);
X    new = DataFromWidget(newWidget);
X    position = new->position;
X    min = new->min;
X    max = new->max;
X    resizable = new->resizable;
X    sharedflag = new->sharedflag;
X`20
X    if (max == 0)
X`09max = resource_max;
X    if (min == 0)
X`09min = resource_min;
X/*
X * We have to reset all of these because the address of newWidget what is`20
X * acutally stored in the pane widget. If you use the current widget you'll
X * stack dump.
X */
X    if (position != cur->position)
X`09`7B
X`09do_add_widget = TRUE;
X`09new->position = cur->position;
X`09`7D
X    if (min != cur->min)
X`09`7B
X`09do_add_widget = TRUE;
X`09new->min = cur->min;
X`09`7D
X    if (max != cur->max)
X`09`7B
X`09do_add_widget = TRUE;
X`09new->max = cur->max;
X`09`7D
X    if (resizable != cur->resizable)
X`09`7B
X`09do_add_widget = TRUE;
X`09new->resizable = cur->resizable;
X`09`7D
X    if (sharedflag != cur->sharedflag)
X`09`7B
X`09do_add_widget = TRUE;
X`09new->sharedflag = cur->sharedflag;
X`09`7D
X`20
X/*`20
X * This is just like DwtPaneAddWidget so I'll just call it and`20
X * let it take care of everything.
X */
X    if (do_add_widget)
X`09`7B
X`09DwtPaneAddWidget (newWidget, position, min, max, resizable, sharedflag);
X`09/* We must reset all of these because it is possible they have changed
X`09 * and if we don't change them they will just get changed back to what
X`09 * they were when we leave this routine.
X`09 */
X`09current->core.x = newWidget->core.x;
X`09current->core.y = newWidget->core.y;
X`09current->core.width = newWidget->core.width;
X`09current->core.height = newWidget->core.height;
X`09`7D
X    return TRUE;
X`7D
X`20
X`0C
X/*
X * One of our subwidgets is trying to resize itself. For now we will only
X * deal with DwtResizeFixed. Anything else won't work right.
X */
X`20
Xstatic XtGeometryResult GeometryManager(subwidget, request, reply)
XWidget subwidget;
XXtWidgetGeometry *request, *reply;
X`7B
X    XtGeometryResult result;
X    PaneWidget pane = (PaneWidget) subwidget->core.parent;
X    Constraints subdata;
X    Dimension rlength, rbreadth;
X
X    if ((request->request_mode & CWWidth) == 0)
X`09request->width = subwidget->core.width;
X    if ((request->request_mode & CWHeight) == 0)
X`09request->height = subwidget->core.height;
X    rlength = FindLength(request->width, request->height);
X    rbreadth = FindBreadth(request->width, request->height);
X    subdata = DataFromWidget(subwidget);
X    result = XtGeometryAlmost;
X    if (rlength < subdata->min)`20
X`09`7B
X`09rlength = subdata->min;
X`09`7D`20
X    else if (rlength > subdata->max)`20
X`09`7B
X`09rlength = subdata->max;
X`09`7D;
X    if (rbreadth > Breadth(pane))
X`09`7B
X`09    result = XtGeometryNo;
X`09    rbreadth = Breadth(pane);
X`09`7D;
X    if (rbreadth == Breadth(pane))`20
X`09`7B
X`09if (subdata->dlength == rlength)
X`09    `7B
X`09    /*
X`09     * I know this seams bizare since everthing looks like it is`20
X`09     * already set. However the Text widget does things in a funny
X`09     * order and it resets the height back so we must redo the`20
X`09     * CommitNewSizes to get the widget back in sinc with the
X`09     * constraint.
X`09     */
X`09    CommitNewSizes(pane, (Widget) NULL);`20
X`09    result = XtGeometryDone;
X`09    `7D
X`09else
X`09    `7B
X`09    RefigureDlengths(pane, subwidget, rlength - subdata->dlength);
X`09    CommitNewSizes(pane, (Widget) NULL);`20
X`09    if (subdata->dlength == FindLength(request->width, request->height))`
V20
X`09`09result = XtGeometryDone;
X`09    `7D;
X`09`7D
X    if (result != XtGeometryDone)`20
X`09`7B
X`09*reply = *request;
X`09rbreadth = Breadth(pane);
X`09reply->width = FindWidth(rlength, rbreadth);
X`09reply->height = FindHeight(rlength, rbreadth);
X`09`7D
X    return result;
X`7D
X`20
X`20
X`20
X`0C
X/*
X * One of our subwidgets has changed its managed status.
X */
X`20
Xstatic void ChangeManaged(w)
XWidget w;
X`7B
X    XWindowChanges changes;
X    PaneWidget pane = (PaneWidget) w;
X    Widget subwidget, cursubwidget;
X    Constraints subdata, cursubdata;
X    int position, i;
X`20
X    PaneNumChildren(pane) = 0;
X    for (i=(NumChildren(pane)+1)/2 ; i<NumChildren(pane); i++)`20
X`09`7B
X`09subwidget = Children(pane)`5Bi`5D;
X`09if (XtClass (subwidget) == mullionWidgetClass)
X`09    `7B
X`09    continue;
X`09    `7D
X`09subdata = DataFromWidget(subwidget);
X`20
X/*`20
X * Recreate the PaneChildren list by only adding those subwidgets which are
X * managed and if shared, are in view. If a subwidget fails the test
X * move his mullion into oblivion. Like the rest of the mullions that don't
V need`20
X * to be seen.
X */
X`09if (subwidget->core.managed &&`20
X`09`09(subdata->sharedflag == NoSharedPaneMask `7C`7C
X`09`09subdata->sharedflag == (SharedPaneMask `7C ViewableInPaneMask)))
X`09    `7B
X`09    if (subdata->sharedflag & SharedPaneMask)
X`09`09`7B
X`09`09XtSetMappedWhenManaged (subwidget, TRUE);
X`09`09`7D
X`09    /*
X`09     * NOTE:The only reason we do the realizing here is because if
X`09     *`09    it isn't realized the mullions don't show up on top. Once
X`09     *`09    mullions are removed you can get rid of this if statement
X`09     */
X`09    if (XtIsRealized(pane) && !(XtIsRealized(subwidget)))
X`09`09`7B
X`09`09XtRealizeWidget(subwidget);
X`09`09`7D;
X`09    PaneChildren(pane)`5B(PaneNumChildren(pane))++`5D = subwidget;
X`09    `7D
X`09else if (subwidget->core.being_destroyed)
X`09    `7B
X`09/*
X`09 * This subwidget is in the process of being destroyed.
X`09 * If this widget is shared then give the pane to first subwidget sharing
V`20
X`09 * the same position.
X`09 */
X`09    for (position=(NumChildren(pane)/2)+subdata->position;`20
X`09`09 position <= NumChildren(pane);`20
X`09`09 position++)
X`09`09`7B
X`09`09cursubwidget = Children(pane) `5Bposition-1`5D;
X`09`09cursubdata = DataFromWidget (cursubwidget);
X`09`09if (cursubdata->position != subdata->position `7C`7C
X`09`09    cursubwidget == subwidget)
X`09`09    continue;
X`09`09DwtPaneMakeViewable (cursubwidget);
X`09    /*
X`09     * It is necessary to add the subwidget to the PaneChildren list if
X`09     * we have already gone passed it. It will be in the correct order
X`09     * since PaneChildren are based on position.
X`09     */
X`09`09if (position < i)
X`09`09    PaneChildren(pane)`5B(PaneNumChildren(pane))++`5D = subwidget;
X`09`09break;
X`09`09`7D
X`09    `7D
X`09else
X`09    `7B
X`09    /*
X`09     * UnMap any shared panes that aren't used
X`09     */
X`09    if (subdata->sharedflag & SharedPaneMask)
X`09`09`7B
X`09`09XtSetMappedWhenManaged (subwidget, FALSE);
X`09`09XtSetMappedWhenManaged (subdata->mullion, FALSE);
X`09`09`7D
X`09    else
X`09`09`7B
X`09`09/*
X`09`09 * Move the mullion widget into oblivion
X`09`09 */
X`09`09changes.x = changes.y = -99;
X`09`09if (changes.x != subdata->mullion->core.x `7C`7C`20
X`09`09`09changes.y != subdata->mullion->core.y)
X`09`09    `7B
X`09`09    subdata->mullion->core.x = changes.x;
X`09`09    subdata->mullion->core.y = changes.y;
X`09`09    if (XtIsRealized(subdata->mullion))
X`09`09`09XConfigureWindow(XtDisplay(subdata->mullion),`20
X`09`09`09`09XtWindow(subdata->mullion), CWX `7C CWY, &changes);
X`09`09    `7D
X`09`09`7D
X`09    `7D
X    `7D
X/*
X * Ok now you only have those children that are managed so fill the pane.
X */
X    TryToFillPane(pane);
X    CommitNewSizes(pane, (Widget) NULL);
X`7D
X`20
X`0C
Xstatic void RememberFocus(w, unused_tag, cb)
XWidget w;
Xcaddr_t unused_tag;
XDwtAnyCallbackStruct * cb;
X`7B
X    DwtAnyCallbackStruct focus_cb;
X    PaneWidget pane = (PaneWidget) XtParent(w);
X    LastHadFocus(pane) = w;
X`20
X    focus_cb.reason = DwtCRFocus;
X    focus_cb.event = cb->event;
X    XtCallCallbacks ((Widget)pane, DwtNfocusCallback, cb);
X`7D
X`20
X`20
X`0C
X/*
X * A new subwidget has been added.
X */
Xstatic DwtCallback focus_cb`5B2`5D = `7BRememberFocus, NULL, NULL`7D;
X`20
Xstatic void InsertChild(subwidget)
XWidget subwidget;
X`7B
X    PaneWidget pane = (PaneWidget) subwidget->core.parent;
X    Widget cursubwidget;
X    Constraints subdata, cursubdata;
X    int i, position;
X`20
X`20
X    /* check for mullion class here since when we create the mullion this co
Vde
X     * will get called again. Get the desired length from the actual length
X     * and then create a mullion for this widget. Finally position the widge
Vt
X     * where the user wants it
X     */
X    if (XtClass(subwidget) != mullionWidgetClass)`20
X`09`7B
X`09subdata = (Constraints)subwidget->core.constraints;
X`09subdata->dlength = Length(subwidget);
X`09if (subdata->max == 0)
X`09    subdata->max = resource_max;
X`09if (subdata->min == 0)
X`09    subdata->min = resource_min;
X`09if (subdata->max < subdata->min)`20
X`09    subdata->max = subdata->min;
X`20
X`09subdata->mullion = XtCreateWidget("mullion", (WidgetClass) mullionWidgetC
Vlass, (Widget) pane,
X`09`09`09`09       (ArgList) NULL, (Cardinal) 0);
X`09XtManageChild(subdata->mullion);
X`09if (subdata->position)
X`09    `7B
X`09    position = subdata->position + ((NumChildren(pane)+1)/2);
X`09    if (position > (NumChildren(pane)+1))
X`09`09`7B
X`09`09position = (NumChildren(pane)+1);
X`09`09`7D
X`09    `7D
X`09else
X`09    `7B
X`09    position = (NumChildren(pane)+1);`20
X`09    `7D
X`09subdata->position = position - ((NumChildren(pane)+1)/2);`20
X`09position--;
X`09`7D`20
X    else`20
X`09`7B
X`09position = (NumChildren(pane)/2);
X`09`7D
X    Children(pane) =`20
X        (WidgetList) XtRealloc((caddr_t) Children(pane),
X    `09(unsigned) (NumChildren(pane) + 1) * sizeof(Widget));
X`20
X    /* Ripple children up one space from "position" */
X    for (i = NumChildren(pane); i > position; i--)
X`09`7B
X`09if (XtClass (Children(pane)`5Bi-1`5D) != mullionWidgetClass &&
X`09    XtClass (subwidget) != mullionWidgetClass)
X`09    `7B
X`09    cursubwidget = Children(pane)`5Bi-1`5D;
X`09    cursubdata = (Constraints)cursubwidget->core.constraints;
X`09    /*`20
X`09     * Check to see if the position of the current subwidget is less
X`09     * than that of the subwidget we are creating. If it is then that
X`09     * means there are other subwidgets below this one which are also
X`09     * shared and I should exit at this point to store this new`20
X`09     * subwidget in the list of children.
X`09     */
X`09    if (cursubdata->position < subdata->position)
X`09`09`7B
X`09`09break;
X`09`09`7D
X`09    else`20
X`09`09`7B
X`09`09/*
X`09`09 * Check to see if the position of the current subwidget and
X`09`09 * the created subwidget are the same. If they are and`20
X`09`09 * the new one is shared, then set the old one to
X`09`09 * shared as well. Also set the current subwidgets inview to
X`09`09 * false if the subwidget will be in view.
X`09`09 *
X`09`09 * Otherwise, if the subwidget isn't shared the new one just`20
X`09`09 * wants the currents ones position so bump it up by one.
X`09`09 */
X`09`09if ((cursubdata->position == subdata->position) &&`20
X`09`09`09(subdata->sharedflag & SharedPaneMask))
X`09`09    `7B
X`09`09    if (subdata->sharedflag & ViewableInPaneMask)`20
X`09`09`09`7B
X`09`09`09cursubdata->sharedflag = SharedPaneMask;
X`09`09`09`7D
X`09`09    else
X`09`09`09`7B
X`09`09`09/*`20
X`09`09`09 * Only set those that aren't shared. Those that are`20
X`09`09`09 * shared are already set and since the new one does
X`09`09`09 * not want to be viewable we will just keep what we
X`09`09`09 * have.
X`09`09`09 */
X`09`09`09if (cursubdata->sharedflag == NoSharedPaneMask)
X`09`09`09    `7B
X`09`09`09    cursubdata->sharedflag = SharedPaneMask `7C ViewableInPaneMask;
X`09`09`09    `7D
X`09`09`09`7D
X`09`09    `7D
X`09`09else if (subdata->sharedflag == NoSharedPaneMask)
X`09`09    `7B
X`09`09    cursubdata->position++;
X`09`09    `7D
X`09`09`7D /* end else */
X`09    `7D /* end if */
X        Children(pane)`5Bi`5D = Children(pane)`5Bi-1`5D;
X`09`7D
X    Children(pane)`5Bi`5D = subwidget;
X    NumChildren(pane)++;
X    PaneChildren(pane) = (WidgetList)
X`09XtRealloc((char *)PaneChildren(pane),
X`09`09  (Cardinal) NumChildren(pane) * sizeof(Widget));
X`20
X    /* this allows text widgets tabs to work like normal`20
X     */
X    if (OverrideText(pane) && XtIsSubclass(subwidget, textwidgetclass))`20
X`09`7B
X`09XtOverrideTranslations(subwidget, compiledtextbindings);
X`09if (LastHadFocus(pane) == NULL)
X`09    LastHadFocus(pane) = subwidget;
X`09`7D
X    if (XtHasCallbacks(subwidget, DwtNfocusCallback) != XtCallbackNoList)
X`09XtAddCallbacks(subwidget, DwtNfocusCallback, focus_cb);
X`7D
X   `20
X`20
X`0C
X/*
X * A subwidget has been removed.
X */
X`20
Xstatic void DeleteChild(subwidget)`20
XWidget subwidget;
X`7B
X    PaneWidget pane = (PaneWidget) subwidget->core.parent;
X    Constraints subdata;
X    int i, position;
X`20
X/*
X * Destroy will destroy mullion and the child. If it is a mullion being`20
X * deleted skip the stuff about subdata and shared position.
X */
X    if (XtClass(subwidget) != mullionWidgetClass)`20
X`09`7B
X`09subdata = DataFromWidget(subwidget);
X    /*`20
X     * destory the mullion`20
X     */
X`09XtDestroyWidget (subdata->mullion);
X`09`7D
X/*
X * Ok now we need to remove this widget from the composite list`20
X */
X    for (position = 0; position < NumChildren(pane); position++)`20
X`09`7B
X        if (Children(pane) `5Bposition`5D == subwidget)`20
X`09    `7B
X            break;
X`09    `7D
X`09`7D
X`20
X    if (position == NumChildren(pane)) return;
X`20
X    /* Ripple children down one space from "position" */
X    NumChildren(pane)--;
X    for (i = position; i < NumChildren(pane); i++)`20
X`09`7B
X        Children(pane) `5Bi`5D = Children(pane) `5Bi+1`5D;
X`09`7D
X`7D`20
X`20
X`20
X`0C
X/*---------------------------------------------------*/
X/* this routine will be called from the widget's     */
X/* main event handler via the translation manager.   */
X/*---------------------------------------------------*/
X`20
Xstatic void Help(w, event)
XWidget w;
XXEvent *event;
X`7B
X    DwtAnyCallbackStruct temp;
X`20
X    temp.reason = DwtCRHelpRequested;
X    temp.event = event;
X`20
X    if (XtClass(w) == (WidgetClass) panewidgetclass)
X`09`7B
X    `09XtCallCallbacks(w, DwtNhelpCallback, &temp);
X`09`7D
X    else
X`09`7B
X`09XtCallCallbacks(XtParent(w), DwtNhelpCallback, &temp);
X`09`7D;
X`7D
X`20
X`0C
X/*
X *************************************************************************
X *
X * Public creation entry points
X *
X *************************************************************************
X */
X/*
X * low level create entry point
X */
X`20
XWidget DwtPaneCreate (p, name, al, ac)
X    Widget  p;`09`09`09`09/* parent widget */
X    char    *name;`09`09`09/* pane widget name */
X    ArgList al;
X    Cardinal ac;   `20
X`7B
X    return XtCreateWidget(name, (WidgetClass) panewidgetclass, p, al, ac);
X`7D
X`20
X#ifdef  VMS
XWidget DWT$PANE_CREATE (p, name$dsc, al, ac)
X    Widget`09`09`09*p;`09`09/* parent widget */
X    struct dsc$descriptor_s    `09*name$dsc;
X    ArgList`09`09`09al;
X    int`09`09`09`09*ac;   `20
X`7B
X    PaneWidget pane;
X    char *name;
X`20
X    name  = DwtDescToNull(name$dsc);       `20
X    pane = (PaneWidget) XtCreateWidget(name, (WidgetClass) panewidgetclass,
V *p, al, *ac);
X`20
X    XtFree(name);
X    return (Widget) pane;
X`7D
X#endif  /* VMS */`20
X`0C   `20
X/*
X * high level pane create routine
X */
X`20
XWidget DwtHVPane(p,`20
X`09      name,`20
X`09      x, y,`20
X`09      width, height,
X`09      orientation,
X`09      mapcallback, helpcallback)
X`20
X    Widget         p;`09`09`09`09/* parent widget */
X    char          *name;`09`09`09/* pane widget name */
X    Position`09   x, y;`09`09`09/* location of pane widget */
X    Dimension`09   width, height;`09`09/* size of pane widget */
X    int`09`09   orientation;`09`09`09/* horizontal or vertical
X    DwtCallbackPtr mapcallback;`09`09`09/* callback for data struct */
X    DwtCallbackPtr helpcallback;`09`09/* help requested */
X`7B
X    Arg al`5B25`5D;
X    Cardinal ac = 0;
X`20
X    /*
X     * set up the parameters we are given
X     */
X`20
X    XtSetArg (al`5Bac`5D, XtNname,`09`09name);`09`09ac++;
X    XtSetArg (al`5Bac`5D, XtNx,`09`09x);`09`09ac++;
X    XtSetArg (al`5Bac`5D, XtNy,`09`09y);`09`09ac++;
X    XtSetArg (al`5Bac`5D, XtNwidth,`09`09width);`09`09ac++;
X    XtSetArg (al`5Bac`5D, XtNheight,`09height);`09ac++;
X    XtSetArg (al`5Bac`5D, DwtNorientation,`09orientation);`09ac++;
X`20
X`20
X    if (mapcallback != NULL)`20
X`09`7B
X`09XtSetArg (al`5Bac`5D, DwtNmapCallback,     mapcallback);
X`09ac++;
X`09`7D
X`20
X    if (helpcallback != NULL)`20
X`09`7B
X`09XtSetArg (al`5Bac`5D, DwtNhelpCallback,    helpcallback);
X`09ac++;
X`09`7D
X`20
X    return XtCreateWidget (name, (WidgetClass) panewidgetclass, p, al, ac);
X`7D
X
X#ifdef  VMS`20
XWidget DWT$H_V_PANE(p,`20
X`09      name$dsc,`20
X`09      x, y,`20
X`09      width, height,
X`09      orientation,
X`09      mapcallback, helpcallback)
X`20
X    Widget        *p;`09`09`09`09/* parent widget */
X    struct dsc$descriptor_s  `09*name$dsc;`09/* form widget name */
X    Position`09  *x, *y;`09`09`09/* location of form widget */
X    Dimension`09  *width, *height;`09`09/* size of the widget */
X    int`09`09  *orientation;`09`09`09/* pane orientation */
X    DwtCallbackPtr *mapcallback;`09`09/* callback */
X    DwtCallbackPtr *helpcallback;`09`09/* help requested */
X`7B
X    PaneWidget pane;
X    Arg al`5B25`5D;
X    int ac = 0;
X    char    *name;
X`20
X    name  = DwtDescToNull(name$dsc);
X    /*
X     * set up the parameters we are given
X     */
X`20
X    XtSetArg (al`5Bac`5D, XtNname,`09      name);`09    ac++;
X    XtSetArg (al`5Bac`5D, XtNname,`09`09name);`09`09ac++;
X    XtSetArg (al`5Bac`5D, XtNx,`09`09x);`09`09ac++;
X    XtSetArg (al`5Bac`5D, XtNy,`09`09y);`09`09ac++;
X    XtSetArg (al`5Bac`5D, XtNwidth,`09`09width);`09`09ac++;
X    XtSetArg (al`5Bac`5D, XtNheight,`09height);`09ac++;
X    XtSetArg (al`5Bac`5D, DwtNorientation,`09orientation);`09ac++;
X`20
X`20
X    if (mapcallback != NULL)`20
X`09`7B
X`09XtSetArg (al`5Bac`5D, DwtNmapCallback,     mapcallback);
X`09ac++;
X`09`7D
X`20
X    if (helpcallback != NULL)`20
X`09`7B
X`09XtSetArg (al`5Bac`5D, DwtNhelpCallback,    helpcallback);
X`09ac++;
X`09`7D
X`20
X    pane = (PaneWidget)XtCreateWidget (name, (WidgetClass) panewidgetclass,
V *p, al, ac);
X`20
X    XtFree(name);
X    return (Widget) pane;
X`7D
X#endif  /* VMS */`20
X`0C   `20
X/*
X * high level pane add widget routine
X */
X`20
Xvoid DwtPaneAddWidget(subwidget, position, min, max, resizable, sharedflag)
X    Widget`09subwidget;
X    Cardinal`09position;
X    Dimension`09min, max;
X    Boolean`09resizable;
X    Cardinal`09sharedflag;
X`7B
X    XWindowChanges changes;
X    PaneWidget`09pane = (PaneWidget) subwidget->core.parent;
X    Widget`09cursubwidget;
X    Constraints subdata, cursubdata, cursubdata2;
X    int`09`09i, curpos, lastsharedposition;
X    Boolean`09subnotfound=TRUE, subnotplaced=TRUE, cursubnotreset=TRUE;
X`20
X/*
X * Get the position the window is currently in
X */
X    subdata = DataFromWidget(subwidget);
X    curpos = subdata->position;
X`20
X/*
X * Compare that to the position the user desires and change the windows arou
Vnd
X */
X    if (position > (NumChildren(pane)/2))
X`09position = (NumChildren(pane)/2);
X    if (position != curpos && position != 0)
X`09`7B
X`09if (position < curpos)
X`09    `7B
X`09    for (i = NumChildren(pane); i >= position*2; i--)
X`09`09`7B
X`09`09cursubwidget = Children(pane)`5Bi-1`5D;
X`09`09cursubdata = DataFromWidget(cursubwidget);
X`09`09/*`20
X`09`09 * Check to see if the position of the current subwidget is less
X`09`09 * than that of the subwidget. If it is then that
X`09`09 * means there are other subwidgets below this one which are also
X`09`09 * shared and I should exit at this point to store this new`20
X`09`09 * subwidget in the list of children.
X`09`09 */
X`09`09if (cursubdata->position < position)
X`09`09    `7B
X`09`09    Children(pane)`5Bi`5D = subwidget;
X`09`09    subdata->position = position;
X`09`09    break;
X`09`09    `7D
X`09`09/*
X`09`09 * if subwidget came from a shared position we need to make`20
X`09`09 * sure that at least one of the old widgets that shared the`20
X`09`09 * position will now be displayed
X`09`09 */
X`09`09if (cursubdata->position == subdata->position &&`20
X`09`09`09subdata->sharedflag & SharedPaneMask)
X`09`09    `7B
X`09`09    if (cursubnotreset)
X`09`09`09`7B
X`09`09`09cursubdata->sharedflag = SharedPaneMask `7C ViewableInPaneMask;
X`09`09`09cursubnotreset = FALSE;
X`09`09`09`7D
X`09`09    `7D
X`09`09/*
X`09`09 * move the subwidgets up one unless`20
X`09`09 * the current subwidget is subwidget we are trying to change or
X`09`09 * the current subs position > the current position or
X`09`09 */
X`09`09if (cursubwidget == subwidget `7C`7C subnotfound)
X`09`09    `7B
X`09`09    if (cursubwidget == subwidget)
X`09`09`09`7B
X`09`09`09subnotfound = FALSE;
X`09`09`09continue;
X`09`09`09`7D
X`09`09    `7D
X`09`09else
X`09`09    `7B
X`09`09    Children(pane)`5Bi`5D = Children(pane)`5Bi-1`5D;
X`09`09    `7D
X`09`09/*
X`09`09 * Reposition the current subwidgets position as appropriate
X`09`09 */
X`09`09if (subnotfound)
X`09`09    `7B
X`09`09    /*
X`09`09     * This is a little tricky here. This will before you find
X`09`09     * the subwidget. If the subwidget was not formerly`20
X`09`09     * shared and is not to be shared `7C`7C the subwidget was formerl
Vy
X`09`09     * shared and will be shared at its new position we will not
X`09`09     * change the position. For the other two conditions we do.
X`09`09     * In one case it is necessary to subtract and the other add
X`09`09     * to the position
X`09`09     */
X`09`09    if ((subdata->sharedflag == NoSharedPaneMask) &&
X`09`09`09(sharedflag & SharedPaneMask))
X`09`09`09    cursubdata->position--;
X`09`09    else if ((subdata->sharedflag & SharedPaneMask) &&
X`09`09`09(sharedflag == NoSharedPaneMask))
X`09`09`09    cursubdata->position++;
X`09`09    `7D
X`09`09else
X`09`09    `7B
X`09`09    /*
X`09`09     * Only change the position if our subwidget wont be shared.
X`09`09     * Otherwise the position will still be occupied.
X`09`09     */
X`09`09    if (sharedflag == NoSharedPaneMask)
X`09`09`09cursubdata->position++;
X`09`09    `7D
X`09`09/*
X`09`09 * Check to see if the position of the current subwidget and
X`09`09 * the subwidget's new position are the same. If they are and`20
X`09`09 * the new one is shared, then set the old one to
X`09`09 * shared as well. Also set the current subwidgets inview to
X`09`09 * false if the subwidget will be in view.
X`09`09 *
X`09`09 * Otherwise, if the subwidget isn't shared the new one just`20
X`09`09 * wants the currents ones position so bump it up by one.
X`09`09 */
X`09`09if(cursubdata->position == position &&`20
X`09`09`09sharedflag & SharedPaneMask)
X`09`09    `7B
X`09`09    if (sharedflag & ViewableInPaneMask)`20
X`09`09`09`7B
X`09`09`09cursubdata->sharedflag = SharedPaneMask;
X`09`09`09`7D
X`09`09    else
X`09`09`09`7B
X`09`09`09/*`20
X`09`09`09 * Only set those that aren't shared. Those that are`20
X`09`09`09 * shared are already set and since the new one does
X`09`09`09 * not want to be viewable we will just keep what we
X`09`09`09 * have.
X`09`09`09 */
X`09`09`09if (cursubdata->sharedflag == NoSharedPaneMask)
X`09`09`09    `7B
X`09`09`09    cursubdata->sharedflag = SharedPaneMask `7C ViewableInPaneMask;
X`09`09`09    `7D
X`09`09`09`7D
X`09`09    `7D
X`09`09`7D   /* end for loop */
X`09    `7D
X`09else`09/* position > curpos */
X`09    `7B
X`09    for (i = (NumChildren(pane)/2)+curpos; i <= NumChildren(pane); i++)
X`09`09`7B
X`09`09cursubwidget = Children(pane)`5Bi-1`5D;
X`09`09cursubdata = DataFromWidget(cursubwidget);
X`09`09/*
X`09`09 * Even though you start at the current position it is possible
X`09`09 * for the position to be less than the current position due to
X`09`09 * shared panes.
X`09`09 */
X`09`09if (cursubdata->position < curpos `7C`7C cursubwidget == subwidget
X`09`09    `7C`7C (subnotfound))
X`09`09    `7B
X`09`09    if (cursubwidget == subwidget)
X`09`09`09    subnotfound = FALSE;
X`09`09    continue;
X`09`09    `7D
X`09`09/*
X`09`09 * if subwidget came from a shared position we need to make`20
X`09`09 * sure that at least one of the old widgets that shared the`20
X`09`09 * position will now be displayed
X`09`09 */
X`09`09if (cursubdata->position == subdata->position &&`20
X`09`09`09subdata->sharedflag & SharedPaneMask)
X`09`09    `7B
X`09`09    if (cursubnotreset)
X`09`09`09`7B
X`09`09`09cursubdata->sharedflag = SharedPaneMask `7C ViewableInPaneMask;
X`09`09`09cursubnotreset = FALSE;
X`09`09`09`7D
X`09`09    `7D
X`09`09/*
X`09`09 * move the subwidgets up one unless`20
X`09`09 * the current subwidget is subwidget we are trying to change or
X`09`09 * the current subs position > the desired position or
X`09`09 * the current subs position = the desired postion and the sub
X`09`09 *   we were working with was previously shared.
X`09`09 */
X`09`09if (cursubdata->position > position `7C`7C
X`09`09     ((subdata->sharedflag & SharedPaneMask) &&`20
X`09`09       cursubdata->position == position))
X`09`09    `7B
X`09`09    /*`20
X`09`09     * Place subwidget only once after you moved all subs
X`09`09     */
X`09`09    if (subnotplaced)
X`09`09`09`7B
X`09`09`09Children(pane)`5Bi-2`5D = subwidget;
X`09`09`09subdata->position = position;
X`09`09`09subnotplaced=FALSE;
X`09`09`09`7D
X`09`09    `7D
X`09`09else
X`09`09    `7B
X`09`09    Children(pane)`5Bi-2`5D = Children(pane)`5Bi-1`5D;
X`09`09    `7D
X`09`09/*
X`09`09 * Reposition the current subwidgets position as appropriate
X`09`09 */
X`09`09if (subnotplaced)
X`09`09    `7B
X`09`09    /*
X`09`09     * Only change the position if our subwidget wasn't shared.
X`09`09     * Otherwise the position will still be occupied.
X`09`09     */
X`09`09    if (subdata->sharedflag == NoSharedPaneMask)
X`09`09`09cursubdata->position--;
X`09`09    `7D
X`09`09else
X`09`09    `7B
X`09`09    /*
X`09`09     * This is a little tricky here. This will happen after you
X`09`09     * placed the subwidget. If the subwidget was not formerly`20
X`09`09     * shared and is not to be shared `7C`7C the subwidget was formerl
Vy
X`09`09     * shared and will be shared at its new position we will not
X`09`09     * change the position. For the other two conditions we do.
X`09`09     * In one case it is necessary to subtract and the other add
X`09`09     * to the position
X`09`09     */
X`09`09    if ((subdata->sharedflag == NoSharedPaneMask) &&
X`09`09`09(sharedflag & SharedPaneMask))
X`09`09`09    cursubdata->position--;
X`09`09    else if ((subdata->sharedflag & SharedPaneMask) &&
X`09`09`09(sharedflag == NoSharedPaneMask))
X`09`09`09    cursubdata->position++;
X`09`09    `7D
X`09`09/*
X`09`09 * Check to see if the position of the current subwidget and
X`09`09 * the subwidget's new position are the same. If they are and`20
X`09`09 * the new one is shared, then set the old one to
X`09`09 * shared as well. Also set the current subwidgets inview to
X`09`09 * false if the subwidget will be in view.
X`09`09 *
X`09`09 * Otherwise, if the subwidget isn't shared the new one just`20
X`09`09 * wants the currents ones position so bump it up by one.
X`09`09 */
X`09`09if(cursubdata->position == position &&`20
X`09`09`09sharedflag & SharedPaneMask)
X`09`09    `7B
X`09`09    if (sharedflag & ViewableInPaneMask)`20
X`09`09`09`7B
X`09`09`09cursubdata->sharedflag = SharedPaneMask;
X`09`09`09`7D
X`09`09    else
X`09`09`09`7B
X`09`09`09/*`20
X`09`09`09 * Only set those that aren't shared. Those that are`20
X`09`09`09 * shared are already set and since the new one does
X`09`09`09 * not want to be viewable we will just keep what we
X`09`09`09 * have.
X`09`09`09 */
X`09`09`09if (cursubdata->sharedflag == NoSharedPaneMask)
X`09`09`09    `7B
X`09`09`09    cursubdata->sharedflag = SharedPaneMask `7C ViewableInPaneMask;
X`09`09`09    `7D
X`09`09`09`7D
X`09`09    `7D
X`09`09`7D   /* end for loop */
X`09    `7D`09`09`09   `20
X`09/*
X`09 * Now that the position has been properly set we can take care of`20
X`09 * the shared flag.`20
X`09 */
X`09subdata->sharedflag = sharedflag;
X`09/*
X`09 * Just for grins lets loop back through and make sure that if a`20
X`09 * subwidget says that it is shared it really is.
X`09 */
X`09for (i=NumChildren(pane)/2; i<NumChildren(pane); i++)`20
X`09    `7B
X`09    cursubwidget = Children(pane)`5Bi`5D;
X`09    cursubdata = DataFromWidget(cursubwidget);
X`09    if (cursubdata->sharedflag & SharedPaneMask)
X`09`09`7B
X`09`09if (i+1 != NumChildren(pane))`09/* Dont check passed bountry */
X`09`09    `7B
X`09`09    cursubdata2 = DataFromWidget(Children(pane)`5Bi+1`5D);
X`09`09    if (cursubdata->position == cursubdata2->position)
X`09`09`09lastsharedposition = cursubdata->position;
X`09`09    `7D
X`09`09if (lastsharedposition != cursubdata->position)
X`09`09    `7B
X`09`09    cursubdata->sharedflag = NoSharedPaneMask;
X`09`09    XtSetMappedWhenManaged (cursubwidget, TRUE);
X`09`09    `7D
X`09`09`7D
X`09    `7D
X`09`7D
X    else
X`09`7B
X`09/*
X`09 * There was no change in position so if the user wants this subwidget
X`09 * to be viewable lets do it for him.
X`09 */
X`09if (sharedflag & ViewableInPaneMask)
X`09    DwtPaneMakeViewable (subwidget);
X`09`7D
X`20
X    subdata->resizable = resizable;
X    if (max == 0)
X`09max = resource_max;
X    if (min == 0)
X`09min = resource_min;
X    if (max < min)`20
X`09max = min;
X    if (subdata->resizable)
X`09`7B
X`09subdata->min = min;
X`09subdata->max = max;
X`09`7D
X    if (subwidget->core.managed)
X`09`7B
X`09PaneNumChildren(pane) = 0;
X`09for (i=NumChildren(pane)/2; i<NumChildren(pane); i++)`20
X`09    `7B
X`09    cursubwidget = Children(pane)`5Bi`5D;
X`09    cursubdata = DataFromWidget(cursubwidget);
X`20
X    /*`20
X     * Recreate the PaneChildren list by only adding those subwidgets which
V are
X     * managed and if shared, are in view. If a subwidget fails the test
X     * move his mullion into oblivion. Like the rest of the mullions that do
Vn't need`20
X     * to be seen.
X     */
X`09    if (cursubwidget->core.managed &&`20
X`09`09    (cursubdata->sharedflag == NoSharedPaneMask `7C`7C
X`09`09    cursubdata->sharedflag == (SharedPaneMask `7C ViewableInPaneMask))
V)
X`09`09`7B
X`09`09if (cursubdata->sharedflag & SharedPaneMask)
X`09`09    `7B
X`09`09    XtSetMappedWhenManaged (cursubwidget, TRUE);
X`09`09    `7D
X`09`09PaneChildren(pane)`5B(PaneNumChildren(pane))++`5D = cursubwidget;
X`09`09`7D
X`09    else
X`09`09`7B
X`09`09/*
X`09`09 * UnMap any shared panes that aren't used
X`09`09 */
X`09`09if (cursubdata->sharedflag & SharedPaneMask)
X`09`09    `7B
X`09`09    XtSetMappedWhenManaged (cursubwidget, FALSE);
X`09`09    XtSetMappedWhenManaged (cursubdata->mullion, FALSE);
X`09`09    `7D
X`09`09else
X`09`09    `7B
X`09`09    /*
X`09`09     * Move the mullion widget into oblivion
X`09`09     */
X`09`09    changes.x = changes.y = -99;
X`09`09    if (changes.x != cursubdata->mullion->core.x `7C`7C`20
X`09`09`09    changes.y != cursubdata->mullion->core.y)
X`09`09`09`7B
X`09`09`09cursubdata->mullion->core.x = changes.x;
X`09`09`09cursubdata->mullion->core.y = changes.y;
X`09`09`09if (XtIsRealized(cursubdata->mullion))
X`09`09`09    XConfigureWindow(XtDisplay(cursubdata->mullion),`20
X`09`09`09`09    XtWindow(cursubdata->mullion), CWX `7C CWY, &changes);
X`09`09`09`7D
X`09`09    `7D
X`09`09`7D
X`09    `7D /* end for loop */
X`09`7D /* end if subwidget is managed */
X    /*
X     * Ok now you only have those children that are managed so fill the pane
V.
X     */
X/*
X * Check to see if the dlength for the subwidget is greater than the max. If
V it
X * is then I must call RefigureDlengths instead of TryToFillPane. TryToFillP
Vane
X * will use the current length which hasn't been change so it will pass a de
Vlta
X * change to RefigureDlengths of 0 which does zippo. Since I know the amount
V I
X * need to change I'll just call RefigureDlengths directly.
X */
X`09if (subdata->dlength > subdata->max)
X`09    `7B
X`09    RefigureDlengths (pane, subwidget, subdata->dlength - subdata->max);
X`09    `7D
X`09else if (subdata->dlength < subdata->min)
X`09    `7B
X`09    RefigureDlengths (pane, subwidget, subdata->dlength - subdata->min);
X`09    `7D
X`09else
X`09    `7B
X`09    TryToFillPane(pane);
X`09    `7D
X`09CommitNewSizes(pane, (Widget) NULL);
X`7D
X
X#ifdef  VMS`20
Xvoid DWT$PANE_ADD_WIDGET(subwidget,`20
X`09      position,
X`09      min, max,`20
X`09      resizable,
X`09      sharedflag)
X`20
X    Widget        *subwidget;`09`09`09/* widget */
X    Cardinal`09  *position;`09`09`09/* position of the subwidget */
X    Dimension`09  *min, *max;`09`09`09/* min & max size of the widget */
X    Boolean`09  *resizable;`09`09`09/* is the widget resizeable */
X    Cardinal`09  *sharedflag;`09`09`09/* shared flag */
X`7B
X    DwtPaneAddWidget (*subwidget,*position,*min,*max,*resizable,*sharedflag)
V;
X`7D
X#endif  /* VMS */`20
X`20
Xvoid DwtPaneGetMinMax(subwidget, min, max)
XWidget subwidget;
XDimension *min, *max;
X`7B
X    Constraints subdata;
X    subdata = DataFromWidget(subwidget);
X    if (subdata) `7B
X`09*min = subdata->min;
X`09*max = subdata->max;
X    `7D else
X`09XtWarning("DwtPaneGetMinMax called with bad widget.");
X`7D
X
X#ifdef  VMS`20
Xvoid DWT$PANE_GET_MIN_MAX(subwidget,`20
X`09      min, max)
X    Widget        subwidget;`09`09`09/* widget */
X    Dimension`09  *min, *max;`09`09`09/* min & max size of the widget */
X`7B
X    Constraints subdata;
X    subdata = DataFromWidget(subwidget);
X    if (subdata) `7B
X`09*min = subdata->min;
X`09*max = subdata->max;
X    `7D else
X`09XtWarning("DwtPaneGetMinMax called with bad widget.");
X`7D
X#endif  /* VMS */`20
X`20
X`0C
X/*
X * NOTE: In setting the min or max in DwtPaneSetMinMax, DwtPaneSetMin, or
X *`09DwtPaneSetMax we donot check for valid min, max values. Values less
X *`09than 1 will certianly cause stack dumps and min > max will also`20
X *`09cause some form of headache, though I haven't tried it yet. Most
X *`09DW code doesn't check for valid attributes so I see no reason to
X *`09do so here either.
X */
X`20
Xvoid DwtPaneSetMinMax(subwidget, min, max)
XWidget subwidget;
XDimension min, max;
X`7B
X    PaneWidget pane = (PaneWidget) subwidget->core.parent;
X    Constraints subdata;
X`20
X    if (max == 0)
X`09max = resource_max;
X    if (min == 0)
X`09min = resource_min;
X    if (max < min)`20
X`09max = min;
X    subdata = DataFromWidget(subwidget);
X    if (subdata->resizable)
X`09`7B
X`09subdata->min = min;
X`09subdata->max = max;
X`09`7D
X
X    if (subdata->sharedflag & SharedPaneMask)
X`09`7B
X`09Widget subwidget2;
X`09Constraints subdata2;
X`09int i, visable_child=NULL;
X
X`09for (i=(NumChildren(pane)+1)/2 ; i<NumChildren(pane); i++)`20
X`09    `7B
X`09    subwidget2 = Children(pane)`5Bi`5D;
X`09    if (XtClass (subwidget) == mullionWidgetClass)
X`09`09`7B
X`09`09continue;
X`09`09`7D
X`09    subdata2 = DataFromWidget(subwidget2);
X`09    if ((subdata2->position != subdata->position) `7C`7C
X`09`09(subwidget2 == subwidget))
X`09`09`7B
X`09`09continue;
X`09`09`7D;
X`09    subdata2->min = subdata->min;
X`09    subdata2->max = subdata->max;
X`09    if (subdata2->sharedflag & ViewableInPaneMask)
X`09`09`7B
X`09`09visable_child = i;
X`09`09`7D
X`09    `7D
X`09if (visable_child != NULL)
X`09    `7B
X`09    subwidget = Children(pane)`5Bvisable_child`5D;
X`09    subdata = DataFromWidget(subwidget);
X`09    `7D
X`09`7D
X    /* only try to fill pane and commit sizes if we really need to
X     */
X    if (subdata->dlength < subdata->min `7C`7C subdata->dlength > subdata->m
Vax)
X`09`7B
X/*
X * Check to see if the dlength for the subwidget is greater than the max. If
V it
X * is then I must call RefigureDlengths instead of TryToFillPane. TryToFillP
Vane
X * will use the current length which hasn't been change so it will pass a de
Vlta
X * change to RefigureDlengths of 0 which does zippo. Since I know the amount
V I
X * need to change I'll just call RefigureDlengths directly.
X */
X`09if (subdata->dlength > subdata->max)
X`09    `7B
X`09    RefigureDlengths (pane, subwidget, subdata->dlength - subdata->max);
X`09    `7D
X`09else if (subdata->dlength < subdata->min)
X`09    `7B
X`09    RefigureDlengths (pane, subwidget, subdata->dlength - subdata->min);
X`09    `7D
X`09else
X`09    `7B
X`09    TryToFillPane(pane);
X`09    `7D
X`09CommitNewSizes(pane, (Widget) NULL);
X`09`7D
X`7D
X`20
X#ifdef  VMS
Xvoid DWT$PANE_SET_MIN_MAX(subwidget,`20
X`09      min, max)
X    Widget        *subwidget;`09`09`09/* widget */
X    Dimension`09  *min, *max;`09`09`09/* min & max size of the widget */
X`7B
X    DwtPaneSetMinMax(*subwidget,*min,*max);
X`7D
X#endif  /* VMS */`20
X
Xvoid DwtPaneSetConstraints(subwidget, min, max, height, resizable)
XWidget subwidget;
XDimension min, max, height;
XBoolean resizable;
X`7B
X    PaneWidget pane = (PaneWidget) subwidget->core.parent;
X    Constraints subdata;
X`20
X    if (max == 0)
X`09max = resource_max;
X    if (min == 0)
X`09min = resource_min;
X    if (max < min)`20
X`09max = min;
X
X    subdata = DataFromWidget(subwidget);
X    subdata->min = min;
X    subdata->max = max;
X
X    /* only try to fill pane and commit sizes if we really need to
X     */
X    if (subdata->dlength != height)
X`09`7B
X/*
X * Check to see if the dlength for the subwidget is greater than the max. If
V it
X * is then I must call RefigureDlengths instead of TryToFillPane. TryToFillP
Vane
X * will use the current length which hasn't been change so it will pass a de
Vlta
X * change to RefigureDlengths of 0 which does zippo. Since I know the amount
V I
X * need to change I'll just call RefigureDlengths directly.
X */
X`09if (subdata->dlength > height)
X`09    `7B
X`09    RefigureDlengths (pane, subwidget, subdata->dlength - height);
X`09    `7D
X`09else if (subdata->dlength < height)
X`09    `7B
X`09    RefigureDlengths (pane, subwidget, subdata->dlength - height);
X`09    `7D
X`09else
X`09    `7B
X`09    TryToFillPane(pane);
X`09    `7D
X`09CommitNewSizes(pane, (Widget) NULL);
X`09`7D
X    subdata->resizable = resizable;
X`7D
X`0C
Xvoid DwtPaneSetMin(subwidget, min)
XWidget subwidget;
XDimension min;
X`7B
X    PaneWidget pane = (PaneWidget) subwidget->core.parent;
X    Constraints subdata;
X    if (min == 0)
X`09min = resource_min;
X    subdata = DataFromWidget(subwidget);
X    if (subdata->resizable)
X`09`7B
X`09subdata->min = min;
X`09if (subdata->max < subdata->min)
X`09    subdata->max = subdata->min;
X`09`7D
X
X    if (subdata->sharedflag & SharedPaneMask)
X`09`7B
X`09Widget subwidget2;
X`09Constraints subdata2;
X`09int i, visable_child=NULL;
X
X`09for (i=(NumChildren(pane)+1)/2 ; i<NumChildren(pane); i++)`20
X`09    `7B
X`09    subwidget2 = Children(pane)`5Bi`5D;
X`09    if (XtClass (subwidget) == mullionWidgetClass)
X`09`09`7B
X`09`09continue;
X`09`09`7D
X`09    subdata2 = DataFromWidget(subwidget2);
X`09    if ((subdata2->position != subdata->position) `7C`7C
X`09`09(subwidget2 == subwidget))
X`09`09`7B
X`09`09continue;
X`09`09`7D;
X`09    subdata2->min = subdata->min;
X`09    if (subdata2->sharedflag & ViewableInPaneMask)
X`09`09`7B
X`09`09visable_child = i;
X`09`09`7D
X`09    `7D
X`09if (visable_child != NULL)
X`09    `7B
X`09    subwidget = Children(pane)`5Bvisable_child`5D;
X`09    subdata = DataFromWidget(subwidget);
X`09    `7D
X`09`7D
X
X    if (subdata->dlength < subdata->min)
X`09`7B
X`09RefigureDlengths (pane, subwidget, subdata->dlength - subdata->min);
X`09CommitNewSizes(pane, (Widget) NULL);
X`09`7D
X`7D
X`20
X#ifdef  VMS
Xvoid DWT$PANE_SET_MIN(subwidget, min)
X    Widget        *subwidget;`09`09`09/* widget */
X    Dimension`09  *min;`09`09`09`09/* min size of the widget */
X`7B
X    DwtPaneSetMin(*subwidget,*min);
X`7D
X#endif  /* VMS */`20
X`0C
Xvoid DwtPaneSetMax(subwidget, max)
XWidget subwidget;
XDimension max;
X`7B
X    PaneWidget pane = (PaneWidget) subwidget->core.parent;
X    Constraints subdata;
X    if (max == 0)
X`09max = resource_max;
X    subdata = DataFromWidget(subwidget);
X    if (max < subdata->min)`20
X`09max = subdata->min;
X    if (subdata->resizable)
X`09`7B
X`09subdata->max = max;
X`09`7D
X    if (subdata->sharedflag & SharedPaneMask)
X`09`7B
X`09Widget subwidget2;
X`09Constraints subdata2;
X`09int i, visable_child=NULL;
X
X`09for (i=(NumChildren(pane)+1)/2 ; i<NumChildren(pane); i++)`20
X`09    `7B
X`09    subwidget2 = Children(pane)`5Bi`5D;
X`09    if (XtClass (subwidget) == mullionWidgetClass)
X`09`09`7B
X`09`09continue;
X`09`09`7D
X`09    subdata2 = DataFromWidget(subwidget2);
X`09    if ((subdata2->position != subdata->position) `7C`7C
X`09`09(subwidget2 == subwidget))
X`09`09`7B
X`09`09continue;
X`09`09`7D;
X`09    subdata2->max = subdata->max;
X`09    if (subdata2->sharedflag & ViewableInPaneMask)
X`09`09`7B
X`09`09visable_child = i;
X`09`09`7D
X`09    `7D
X`09if (visable_child != NULL)
X`09    `7B
X`09    subwidget = Children(pane)`5Bvisable_child`5D;
X`09    subdata = DataFromWidget(subwidget);
X`09    `7D
X`09`7D
X    if (subdata->dlength > subdata->max)
X`09`7B
X`09RefigureDlengths (pane, subwidget, subdata->dlength - subdata->max);
X`09CommitNewSizes(pane, (Widget) NULL);
X`09`7D
X`7D
X`20
X#ifdef  VMS
Xvoid DWT$PANE_SET_MAX(subwidget, max)
X    Widget        *subwidget;`09`09`09/* widget */
X    Dimension`09  *max;`09`09`09`09/* max size of the widget */
X`7B
X    DwtPaneSetMax(*subwidget,*max);
X`7D
X#endif  /* VMS */`20
X`0C
X/* this needs to be incorporated into set values */
Xvoid DwtPaneAllowResizing(pane, allowtype)
XPaneWidget pane;
Xint allowtype;
X`7B
X    ResizeMode(pane) = allowtype;
X    if (!allowtype) TryToFillPane(pane);
X`7D
X`20
X`20
X`0C
Xvoid DwtPaneMakeViewable(subwidget)
XWidget subwidget;
X`7B
X    PaneWidget pane = (PaneWidget) subwidget->core.parent;
X    Constraints cursubdata, subdata;
X    Widget cursubwidget, curmullion, mullion;
X    XWindowChanges changes;
X    int`09viewable, notviewable, position;
X`20
X/*
X * The current subwidget is the one occuppying the same position in the`20
X * PaneChildren Widget list. If not then we need to go down the list till we
X * find the one that is sharing this position
X */
X    subdata = DataFromWidget(subwidget);
X    for (position = subdata->position; position > 0; position--)
X`09`7B
X`09cursubwidget = PaneChildren(pane)`5Bposition - 1`5D;
X`09cursubdata = DataFromWidget(cursubwidget);
X`09if (cursubdata->position == subdata->position)
X`09    break;
X`09`7D;
X`20
X/*
X * If this subwidget is the one currently displayed or is not in a shared pa
Vne
X * or it is not managed then don't bother doing any of this work.
X */
X    if (subwidget == cursubwidget `7C`7C !subwidget->core.managed `7C`7C`20
X`09    subdata->sharedflag == NoSharedPaneMask)
X`09return;
X`20
X    viewable = SharedPaneMask `7C ViewableInPaneMask;
X    notviewable = SharedPaneMask;
X`20
X/*
X * Get the subdata of widget currently viewable and set the mullions
X */
X    curmullion = cursubdata->mullion;
X    mullion = subdata->mullion;
X`20
X`20
X/*
X * Set the changes based on the current widget attributes
X */
X    changes.x = cursubwidget->core.x;
X    changes.y = cursubwidget->core.y;
X    changes.width = cursubwidget->core.width;
X    changes.height = cursubwidget->core.height;
X    changes.border_width = 0;
X    if (changes.x != subwidget->core.x `7C`7C changes.y != subwidget->core.y
V `7C`7C
X`09  changes.width != subwidget->core.width `7C`7C
X`09  changes.height != subwidget->core.height `7C`7C
X`09  changes.border_width != subwidget->core.border_width)`20
X`09`7B
X`09subwidget->core.x = changes.x;
X`09subwidget->core.y = changes.y;
X`09subwidget->core.width = changes.width;
X`09subwidget->core.height = changes.height;
X`09subwidget->core.border_width = changes.border_width;
X`09if (XtIsRealized(subwidget))   `20
X`09    `7B
X`09    XConfigureWindow(XtDisplay(subwidget), XtWindow(subwidget),
X`09`09`09     CWX `7CCWY `7C CWWidth `7C CWHeight `7C CWBorderWidth,
X`09`09`09     &changes);
X`09    `7D
X`09if (XtClass(subwidget)->core_class.resize != (XtWidgetProc) NULL)
X`09    `7B
X`09    (*(subwidget->core.widget_class->core_class.resize))(subwidget);
X`09    `7D
X`09`7D
X`20
X/*
X * Set the current widgets and subwidget's shared pane attributes
X */
X    cursubdata->sharedflag = notviewable;
X    subdata->sharedflag = viewable;
X
X/*
X * Set the min and the max values based on the currently visable widget
X */
X    subdata->min = cursubdata->min;
X    subdata->max = cursubdata->max;
X`20
X/*
X * Unmap the current widget and map the subwidget by setting mapped_when_man
Vaged
X */
X    XtSetMappedWhenManaged (subwidget, TRUE);
X    XtSetMappedWhenManaged (cursubwidget, FALSE);
X`20
X/*
X * If the cursubwidget was the last to have focus change it to the subwidget
X */
X    if (LastHadFocus(pane) == cursubwidget)
X`09LastHadFocus(pane) = subwidget;
X`20
X/*
X * Set the changes based on the current mullions attributes
X */
X    changes.x = curmullion->core.x;
X    changes.y = curmullion->core.y;
X    if (changes.x != mullion->core.x `7C`7C changes.y != mullion->core.y)`20
X`09`7B
X`09mullion->core.x = changes.x;
X`09mullion->core.y = changes.y;
X`09if (XtIsRealized(subwidget))   `20
X`09    `7B
X`09    XConfigureWindow(XtDisplay(mullion), XtWindow(mullion),
X`09`09`09     CWX `7C CWY, &changes);
X`09    `7D
X`09`7D
X/*
X * Unmap the current widget and map the subwidget by setting mapped_when_man
Vaged
X */
X    XtSetMappedWhenManaged (mullion, TRUE);
X    XtSetMappedWhenManaged (curmullion, FALSE);
X`20
X    PaneChildren(pane)`5Bposition -  1`5D = subwidget;
X   `20
X`7D
X`20
X#ifdef  VMS
Xvoid DWT$PANE_MAKE_VIEWABLE(subwidget)
X    Widget        *subwidget;`09`09`09/* widget */
X`7B
X    DwtPaneMakeViewable(*subwidget);
X`7D
X#endif  /* VMS */`20
X`0C
Xunsigned int PaneInitializeForDRM ()
X`7B
Xint`09stat;
X`20
X/*  Initialize DRM
V                                                            */
X/*  This MUST be done before the XtInitialize call...
V                         */
X/*
V                                                                         `20
V  */
XDwtInitializeDRM ();
X`20
Xstat = DwtRegisterClass (DRMwcUnknown, "pane_widget",
X`09"DwtPaneCreate", DwtPaneCreate,  panewidgetclass);
X`20
Xif (stat != DRMSuccess)
X`09`7B
X`09printf ("pane widget registration failed\n");
X`09return stat;
X`09`7D;
X`20
Xreturn stat;
X`7D
X`0C
X#define AcceptFocusProc(w) ((w)->core.widget_class->core_class.accept_focus)
Xstatic Boolean AcceptFocus(w, time)
XWidget w;
XTime *time;
X`7B
X    PaneWidget pane = (PaneWidget) w;
X    int i;
X    Boolean took_focus;
X
X    if (LastHadFocus(pane) == NULL) `7B
X`09for (i=0 ;
X`09     i<PaneNumChildren(pane) && LastHadFocus(pane) == NULL;
X`09     i++) `7B
X`09    if (AcceptFocusProc(PaneChildren(pane)`5Bi`5D))
X`09`09LastHadFocus(pane) = PaneChildren(pane)`5Bi`5D;
X`09`7D
X`09if (LastHadFocus(pane) == NULL) return ((Boolean) FALSE);
X    `7D
X    if (AcceptFocusProc(LastHadFocus(pane)) != NULL)
X`09`7B
X`09took_focus = (*AcceptFocusProc(LastHadFocus(pane)))(LastHadFocus(pane), t
Vime);
X`09return (took_focus);
X`09`7D
X    return ((Boolean) FALSE);
X`7D
X`20
X`20
X`0C
Xstatic void GrabFocus(w, event)
XWidget w;
XXEvent *event;
X`7B
X    Time time;
X`20
X    EventToTime(time,event);  /* get the time out of the event */
X    AcceptFocus(XtParent(w), &time);
X`7D
X`20
X`20
X`0C
Xstatic void FocusNext(w, event)
XWidget w;
XXEvent *event;
X`7B
X    PaneWidget pane = (PaneWidget) XtParent(w);
X    Time time;
X    int i, j;
X    EventToTime(time,event);  /* get the time out of the event */
X    for (i=0 ; i<PaneNumChildren(pane); i++)
X`09if (PaneChildren(pane)`5Bi`5D == w) break;
X    for (j=i+1 ; j<PaneNumChildren(pane) ; j++) `7B
X`09if (AcceptFocusProc(PaneChildren(pane)`5Bj`5D) != NULL) `7B
X`09    LastHadFocus(pane) = PaneChildren(pane)`5Bj`5D;
X`09    AcceptFocus(XtParent(w), &time);
X`09    return;
X`09`7D
X    `7D
X`7D
X`20
X`0C
Xstatic void FocusPrev(w, event)
XWidget w;
XXEvent *event;
X`7B
X    PaneWidget pane = (PaneWidget) XtParent(w);
X    Time time;
X    int i, j;
X    EventToTime(time,event);  /* get the time out of the event */
X    for (i=0 ; i<PaneNumChildren(pane); i++)
X`09if (PaneChildren(pane)`5Bi`5D == w) break;
X    for (j=i-1 ; j>=0 ; j--) `7B
X`09if (AcceptFocusProc(PaneChildren(pane)`5Bj`5D) != NULL) `7B
X`09    LastHadFocus(pane) = PaneChildren(pane)`5Bj`5D;
X`09    AcceptFocus(XtParent(w), &time);
X`09    return;
X`09`7D
X    `7D
X`7D
X`20
X/*  DEC/CMS REPLACEMENT HISTORY, Element PANE.C */
X/*  *3    30-AUG-1989 15:59:18 BRINKLEY "const removed" */
X/*  *2    29-AUG-1989 16:42:50 BRINKLEY "bug fixed" */
X/*  *1    22-AUG-1989 16:55:37 RYAN "Initial elements for V3" */
X/*  DEC/CMS REPLACEMENT HISTORY, Element PANE.C */
$ CALL UNPACK PANE.C;23 1579969367
$ create 'f'
X/*
X* $Header: Pane.h,v 1.4 88/02/26 13:50:51 weissman Exp $
X*/
X
X/*
X * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
X *`20
X *                         All Rights Reserved
X *`20
X * Permission to use, copy, modify, and distribute this software and its`20
X * documentation for any purpose and without fee is hereby granted,`20
X * provided that the above copyright notice appear in all copies and that
X * both that copyright notice and this permission notice appear in`20
X * supporting documentation, and that the name of Digital Equipment
X * Corporation not be used in advertising or publicity pertaining to
X * distribution of the software without specific, written prior permission.
V `20
X *`20
X *`20
X * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
X * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
X * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
X * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
X * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
X * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
X * SOFTWARE.
X */
X/*
X * V1.0a 17-Mar-1988`09RDB
X *`09fix major bugs and enhancements
X * V1.4`09 03-Nov-1988`09RDB
X *`09updates and revisions
X * V2.0`09 04-Apr-1989`09RDB
X *`09updates and revisions
X * V2.1`09 11-Apr-1989`09RDB
X *`09add leftmullion
X */
X
X#ifndef _DwtPane_h
X#define _DwtPane_h
X
X#define NoSharedPaneMask`090L
X#define`09SharedPaneMask`09`09(1L<<0)
X#define`09ViewableInPaneMask`09(1L<<1)
X
X/***********************************************************************
X *
X * Pane Widget (subclass of CompositeClass)
X *
X ***********************************************************************/
X
X/* New fields */
X#define DwtNmullionSize`09`09"mullionSize"
X#define DwtNmin`09`09`09"min"
X#define DwtNmax`09`09`09"max"
X#define DwtNoverrideText`09"overrideText"
X#define DwtNposition`09`09"position"
X#define DwtNsharedFlag`09`09"sharedFlag"
X
X#define DwtCMullionSize`09`09"MullionSize"
X#define DwtCMin`09`09`09"Min"
X#define DwtCMax`09`09`09"Max"
X#define DwtCOverrideText`09"OverrideText"
X#define DwtCPosition`09`09"Position"
X#define DwtCSharedFlag`09`09"SharedFlag"
X
X/*
X * New fields for the Pane widget class record`20
X */
Xtypedef struct `7B
X    DwtOffsetPtr`09paneoffsets;
X    int mumble;   /* No new procedures */
X`7D PaneClassPart;
X`20
X/*`20
X * Full class record declaration
X */
Xtypedef struct _PaneClassRec `7B
X    CoreClassPart`09core_class;
X    CompositeClassPart  composite_class;
X    ConstraintClassPart constraint_class;
X    PaneClassPart`09pane_class;
X`7D PaneClassRec, *PaneClass;
X`20
X`20
X/*
X * New fields for the Pane widget record
X */
Xtypedef struct _PanePart `7B
X    DwtCallbackStruct helpcallback,`09/* Help callback */
X                      map_callback,     /* about to be mapped */
X`09`09      unmap_callback,   /* just been unmapped */
V                           `20
X`09`09      focus_callback;`09/* grabbed input focus */
X    unsigned char orientation;`09`09/* Horizontal or Vertical pane. */
X    Pixel foreground;`09`09/* Foreground color for mullions, borders, etc. *
V/
X    Dimension mullionsize;`09/* Size of mullions. same as borderwidth */
X    Dimension mullionlength;`09/* Actual Size of mullions. */
X    Boolean leftmullion;`09/* Have we actually left the mullion area */
X    short intersub;`09`09/* Number of pixels between subwidgets. */
X    WidgetList children;`09/* List of subwidgets. */
X    Cardinal num_children;`09/* Number of subwidgets. */
X    int resize_mode;`09`09/* If TRUE, children are allowed to change */
X`09`09`09`09/* their length to whatever they want, and */
X`09`09`09`09/* we don't attempt to make things add up to */
X`09`09`09`09/* the correct total length. */
X    GC invgc;`09`09`09/* GC to use to draw magic borders */
X    Widget whichadjust;`09`09/* Which window we're currently dragging. */
X    Position origloc;`09`09/* Where the button was originally pressed. */
X    Boolean overridetext;`09/* Whether to override text bindings. */
X    Widget lasthadfocus;`09/* The last widget to which we gave focus. */
X`7D PanePart;
X`20
X/****************************************************************
X *
X * Full instance record declaration
X *
X ****************************************************************/
X`20
Xtypedef struct _PaneRec `7B
X    CorePart`09    core;
X    CompositePart   composite;
X    ConstraintPart  constraint;
X    PanePart`09    pane;
X`7D PaneRec, *PaneWidget;
X`20
X/*`20
X * Data to be kept for each child.
X */
Xtypedef struct _ConstraintsRec `7B
X    Dimension min, max;`09`09/* Limits on length of this widget. */
X    Dimension dlength;`09`09/* Desired length for this widget. */
X    Widget mullion;`09`09/* Widget used for the mullion below this */
X`09`09`09`09/* widget (if any) */
X    Position magicborder;`09/* Where the last magic border was drawn. */
X    Position position;`09`09/* Where to place this beast */
X    Cardinal sharedflag;`09/* The position is shared with another widget */
X`09`09`09`09/* Also is the subwidget viewable */
X    Boolean resizable;`09`09/* allow widget to be resized by pane? */
X
X`7D ConstraintsRec,*Constraints;
X`20
X#ifndef PANE
Xexternal PaneClassRec panewidgetclassrec;
Xexternal PaneClass panewidgetclass;
X#endif
X
Xextern Widget DwtPaneCreate(); /* parent,name,arglist,argCount */
X    /* Widget parent; */
X    /* char   *name; */
X    /* Arg    *arglist; */
X    /* int    argCount; */
X
Xextern Widget DwtHVPane(); /* parent, name, x, y, width, height, orientation
V, mapcallback, helpcallback */
X    /* Widget`09`09parent; */
X    /* char`09`09*name; */
X    /* Position`09`09x, y; */
X    /* Dimension`09width, height; */
X    /* int`09`09orientation; */
X    /* DwtCallBackPtr`09mapcallback, helpcallback; */
X
Xextern void DwtPaneAddWidget(); /* subwidget, position, min, max, resizeable
V, sharedflag */
X    /* Widget subwidget; */
X    /* Cardinal position */
X    /* Dimension *min, *max; */
X    /* Boolean resizable */
X    /* Cardinal`09sharedflag */
X
Xextern void DwtPaneGetMinMax(); /* subwidget, min, max */
X    /* Widget subwidget; */
X    /* Dimension *min, *max; */
X
Xextern void DwtPaneSetMinMax(); /* subwidget, min, max */
X    /* Widget subwidget; */
X    /* Dimension min, max; */
X
Xextern void DwtPaneSetConstraints(); /* subwidget, min, max, height, resizab
Vle */
X    /* Widget subwidget; */
X    /* Dimension min, max, height; */
X    /* Boolean resizable */
X
Xextern void DwtPaneSetMin(); /* subwidget, min*/
X    /* Widget subwidget; */
X    /* Dimension min; */
X
Xextern void DwtPaneSetMax(); /* subwidget, max */
X    /* Widget subwidget; */
X    /* Dimension max; */
X
Xextern void DwtPaneAllowResizing(); /* pane, allow */
X    /* PaneWidget pane; */
X    /* int allowtype; */
X
Xextern void DwtPaneMakeViewable(); /* subwidget*/
X    /* Widget subwidget; */
X
Xextern unsigned int PaneInitializeForDRM();
X
X#endif _DwtPane_h
X/* DON'T ADD STUFF AFTER THIS #endif */
X
X/*  DEC/CMS REPLACEMENT HISTORY, Element PANE.H */
X/*  *6    11-APR-1989 11:27:31 BRINKLEY "leftmullion added" */
X/*  *5     5-APR-1989 09:40:03 BRINKLEY "final standard I hope" */
X/*  *4    30-MAR-1989 14:16:55 BRINKLEY "definitions of global variables fix
Ved" */
X/*  *3    28-MAR-1989 11:07:53 BRINKLEY "Style Guide Conformity" */
X/*  *2     6-JAN-1989 12:35:18 BRINKLEY "new version of pane widget" */
X/*  *1    20-DEC-1988 14:51:23 RYAN "Initial elements for V2" */
X/*  DEC/CMS REPLACEMENT HISTORY, Element PANE.H */
$ CALL UNPACK PANE.H;2 842797116
$ create 'f'
X/*
X * $Header: PaneP.h,v 1.2 89/01/05 17:58:38 gringort Exp $
X */
X`20
X/*
X * Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachus
Vetts.
X *`20
X *                         All Rights Reserved
X *`20
X * Permission to use, copy, modify, and distribute this software and its`20
X * documentation for any purpose and without fee is hereby granted,`20
X * provided that the above copyright notice appear in all copies and that
X * both that copyright notice and this permission notice appear in`20
X * supporting documentation, and that the name of Digital Equipment
X * Corporation not be used in advertising or publicity pertaining to
X * distribution of the software without specific, written prior permission.
V `20
X *`20
X *`20
X * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
X * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
X * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
X * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
X * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
X * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
X * SOFTWARE.
X */
X/*`20
X * PanePrivate.h - Private definitions for Pane widget
X *`20
X * Author:`09Terry Weissman
X * `09`09Digital Equipment Corporation
X * `09`09Western Software Laboratory
X * Date:`09Tue 6 Oct 1987
X *
X * V1.0d 17-Mar-1988`09RDB
X *`09fix major bugs and enhancements
X * V1.1  15-Apr-1988`09MRR
X *`09Upward compatibility support.
X * V1.4`09 02-Nov-1988`09RDB
X *`09Apply standards to definitions
X * V1.5`09 06-Jan-1988`09JG
X *`09Modify for PMAX
X */
X`20
X#ifndef _DwtPanePrivate_h
X#define _DwtPanePrivate_h
X`20
X/***********************************************************************
X *
X * Pane Widget Private Data
X *
X ***********************************************************************/
X`20
Xtypedef struct _MullionPart `7B
X    DwtCallbackStruct helpcallback;
X`7D MullionPart;
X`20
Xtypedef struct _MullionRec `7B
X    CorePart`09core;
X    MullionPart`09mullion;
X`7D MullionRec, *MullionWidget;
X/* $Log:`09PaneP.h,v $
X * Revision 1.2  89/01/05  17:58:38  gringort
X * fixed position
X *`20
X * Revision 1.1  89/01/03  16:59:56  gringort
X * Initial revision
X *`20
X * Revision 1.3  88/02/26  13:29:52  weissman
X * Add focus handling to subwindows.
X *`20
X * Revision 1.2  87/12/16  15:31:12  weissman
X * Conversion to BL6.
X *`20
X * Revision 1.1  87/12/16  15:31:12  asente
X * Initial revision
X *`20
X * Revision 1.1  87/11/12  13:36:57  susan
X * Initial revision
X *`20
X * Revision 1.1  87/11/04  15:03:12  chow
X * Initial revision
X *`20
X * Revision 1.1  87/11/01  12:25:01  haynes
X * Initial revision
X *`20
X *  */
X`20
X`20
X#endif _DwtPanePrivate_h
X/* DON'T ADD STUFF AFTER THIS #endif */
X`20
X/*  DEC/CMS REPLACEMENT HISTORY, Element PANEP.H */
X/*  *4    30-MAR-1989 14:17:07 BRINKLEY "definitions of global variables fix
Ved" */
X/*  *3    28-MAR-1989 11:07:58 BRINKLEY "Style Guide Conformity" */
X/*  *2     6-JAN-1989 12:36:17 BRINKLEY "new version" */
X/*  *1    20-DEC-1988 14:51:26 RYAN "Initial elements for V2" */
X/*  DEC/CMS REPLACEMENT HISTORY, Element PANEP.H */
$ CALL UNPACK PANEP.H;2 1211786543
$ create 'f'
X#define XRNPATCHLEVEL 0
$ CALL UNPACK PATCHLEVEL.H;2 458967483
$ create 'f'
XHOW TO GET AND MAKE MXRN (for UNIX systems:)
X--------------------------------------------
X
XHow to get mxrn:
X
X% ftp decuac.dec.com (192.5.214.1)
Xuser: anonymous
Xpassword: guest
Xftp> cd pub/DEC
Xftp> binary
Xftp> get dxrn.tar.Z
Xftp> quit
X% uncompress dxrn.tar.Z
X% tar xf dxrn.tar
X
X
XHow to install mxrn:
X
X0. See the file CHANGES for a list of changes from the last release.
X
X1. Does an NNTP server (version 1.5 or greater) exist on your network?
X   - if not, get the NNTP server code and install it
X     (via anonymous ftp from ucbvax.berkeley.edu)
X   - make sure that XHDR (in nntp/common/conf.h) was defined
X     when your NNTP server was installed.
X     (XRN will tell you if it has not been defined)
X
X2. Look at `60config.h' and make the necessary modifications
X   (default settings, location of various files, domain name, etc.)
X   `5Bif you are running SunOS 3.5, check out USE_LOCALTIME`5D
X   Specific things to look for -`20
X`09- The ORGANIZATION define
X`09- The DOMAIN define
X`09- The INEWS define (if that's how you post news).
X
X3. Make xrn
X  `20
X   a. Build the Makefile
X
X      1. Edit 'Imakefile' to configure for what you want to build -
X`09 add '#define MXRN' for example, to build MXRN. Add
X`09 '#define decnet' for DECnet transport.
X
X      2. If you have X11 installed, build the Makefile:
X  `20
X`09      xmkmf`20
X
X   b. If you don't have xmkmf, but the X libraries are installed in the
X      `60right places':
X
X`09  make -f Makefile.motif
X`09(for dxrn, 'make').
X
X4. Installl mxrn
X
X   make install
X
X5. Initial setup
X
X   Invoke mxrn with a pointer to the nntp server you're using to get started
V.
X   (mxrn -nntpServer node-name) You can then use the customize windows to
X   customize things to your liking.
X
XIf you have problems, mail to 'murphy@dco.dec.com'.
$ CALL UNPACK README.UNIX;2 809649505
$ create 'f'
XHOW TO GET AND MAKE MXRN (for VMS systems:)
X--------------------------------------------
X
XNOTE:   DXRN and MXRN are really the same thing, except for
Xthe interface method.   DXRN is for "DECwindows", and MXRN
Xis for "DECwindows/MOTIF".   For the purpose of this help file,
Xwe'll simply refer to DXRN.  `20
X
X
XHow to get dxrn:
X
X% ftp decuac.dec.com (192.5.214.1)
Xuser: anonymous
Xpassword: guest
Xftp> cd pub/DEC
Xftp> get dxrn.share
Xftp> quit
X
X`5BThe dxrn kit is also available from the vmsnet.sources archive; see the
Xperiodic posting in vmsnet.announce.newusers for information on how
Xto access the archives.`5D
X
X$ @DXRN.SHARE    (it is a vms SHARE file that will self-unpack into
X                  lots of files)
X
X
XHow to install DXRN:
X
X0. See the file "CHANGES." for a list of changes from the last release.
X
X1. Does an NNTP server (version 1.5 or greater) exist on your network?
X   (the nntp server can be unix *OR* vms-based...)
X
X   - if not, get the NNTP server code and install it
X     (via anonymous ftp from ucbvax.berkeley.edu - for UNIX systems only)
X
X   - make sure that XHDR (in nntp/common/conf.h) was defined
X     when your NNTP server was installed.
X     (XRN will tell you if it has not been defined)
X
X   - Note:  for VMS users, the NNTP server code supplied with the
X     publically-available ANU-NEWS program works very well, and
X     will run under many transports (MULTInet, CMU, UCX, FUSION, WIN,..)
X     DECnet transport can also be used to ULTRIX and other NNTP servers.
X
X   - The ANU-NEWS kit can be found on sao.aarnet.edu.au, or on the
X     DECUS VAX SIG tapes. Also from kuhub.cc.ukans.edu.
X
X2. Look at the file "CONFIG.H" and make the necessary modifications
X   (default settings, location of various files, domain name, etc.)
X   For use with an ANU News server, you MUST define TIMEZONE_ENV and
X   GENERATE_EXTRA_FIELDS. TIMEZONE_ENV must be set to the name of`20
X   a logical name that will contain the local timezone.
X   Specific things to look for -`20
X`09- The ORGANIZATION define
X`09- The DOMAIN define
X`09- The INEWS define (if that's how you post news).
X
X   For VMS, edit clientlib.c to define the proper symbol for the`20
X   TCP/IP system that you're using. (There's a block of header comments
X   describing how to do this. See below for more information).
X  `20
X3. Make DXRN
X
X   a. First, you must choose your transport.
X
X      1  By default, DXRN will be compiled for use via DECNET.  If
X         you want another transport (Multinet, UCX, etc..), you'll
X         have to edit the file "CLIENTLIB.C", and add a  "#define"
X         statement that corresponds to the transport you want to use.
X         (See the comments in the CLIENTLIB.C file..)
X
X      2. Additionally, edit MAKE-DXRN.COM (or MAKE-MXRN.COM) to
X         refer to the proper "library" to link with.  (by default,
X         this refers to the UCX tcp/ip library...   if you want to
X         use DECNET, comment out the library line completely)
X         Once again, look at the comments in the file.
X
X
X   b. Compile the image.  (make sure you have a "C" compiler!)
X
X      2. Execute the command file that will compile the correct image
X         for you.
X
X         a. If you are running DECWINDOWS, execute   MAKE-DXRN.COM.
X            (creates DXRN.EXE)
X
X         b. If you are running DECWINDOWS/MOTIF, execute  MAKE-MXRN.COM.
X            Note:  MAKE-MXRN.COM has a few items that may need to be
X            edited, for example, depending on whether or not you have
X            the motif developers kit installed, etc.
X            (creates MXRN.EXE)
X   `20
X   c. Build a foreign command.
X
X      1. To use mxrn (or dxrn), you'll need to create a foreign command
X         (either at the user or system level, it does not matter...)
X
X         $ dxrn :== $<location>:dxrn.exe
X
X      2. For a list of options, run it with
X
X         $ dxrn -?
X
X      3. Invoke dxrn with the name of the news server on the command line.
X`09 '$ dxrn -nntpServer foo.bar.baz'. If you use the customize menus
X         to save the settings, the nntp server name wil be saved and won't
X`09 need to be specified all the time. You can also use a logical name
X`09 for the NNTP server.
X
X         Example:
X
X           $ define NNTPSERVER "myvax.mydept.mycollege.edu"
X           $ dxrn
X
X       4. If you are not on a WORKSTATION (for example, you're
X          using an X-TERMINAL, you may possibly need to set your
X          DISPLAY before running DXRN (depending on whether or not
X          you're actually using an X-bases SESSION or not....).
X
X          $ set display/create/node=nnn.nnn.nnn.nnn/trans=TCPIP   (tcp/ip)
X          $ set display/create/node=LAT_08002bnnnnnn/trans=LAT   (X via LAT)
X
X
XIf you have problems, mail to 'murphy@dco.dec.com'.
$ CALL UNPACK README.VMS;2 2032096368
$ create 'f'
X
X#if !defined(lint) && !defined(SABER)
Xstatic char XRNrcsid`5B`5D = "$Header: /net/objy27/wrld/mnt11/ricks/src/mast
Ver/xrn/refile.c,v 1.6 1993/01/11 02:15:17 ricks Exp $";
X#endif
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/* MH and RMAIL refiling:`20
X *
X *   MH: Bob Ellison <ellison@sei.cmu.edu>
X *   RMAIL:  Michael Thomas <mike@gordian.com>
X */
X
X#include "config.h"
X#include <stdio.h>
X#include "utils.h"
X#include <string.h>
X#include <ctype.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#ifdef SYSV
X#include <fcntl.h>
X#else
X#include <sys/file.h>
X#endif
X#if defined(_XOPEN_SOURCE)
X#include <stdlib.h>
X#else
X    char *getenv();
X#endif
X#if defined(_OSF_SOURCE)
X#include <string.h>
X#else
X#if defined(ultrix)
X    char *index();
X#endif
X#endif
X#include <errno.h>
X
X#include "xrn.h"
X#include "dialogs.h"
X#include "error_hnds.h"
X#include "mesg.h"
X#include "resources.h"
X
Xextern char *strpbrk();
X
X#ifndef S_ISDIR
X#define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)
X#endif
X
X#if defined(hpux) `7C`7C (defined(sony) && defined(SYSV))`09`09    /* ggh */
X
X/* horrible strcasecmp */
X
Xint strcasecmp(const char *str1,const char *str2)
X`7B
X    char    tmp1`5B1024`5D, tmp2`5B1024`5D;
X    int     i,result;
X
X    for (i = 0; str1`5Bi`5D != '\0'; i++) `7B
X`09if (isupper(str1`5Bi`5D)) `7B
X`09    tmp1`5Bi`5D = tolower(str1`5Bi`5D);
X`09`7D else `7B
X`09    tmp1`5Bi`5D = str1`5Bi`5D;
X`09`7D
X    `7D
X    tmp1`5Bi`5D = '\0';
X
X    for (i = 0; str2`5Bi`5D != '\0'; i++) `7B
X`09if (isupper(str2`5Bi`5D)) `7B
X`09    tmp2`5Bi`5D = tolower(str2`5Bi`5D);
X`09`7D else `7B
X`09    tmp2`5Bi`5D = str2`5Bi`5D;
X`09`7D
X    `7D
X    tmp2`5Bi`5D = '\0';
X
X    return strcmp(tmp1, tmp2);
X`7D
X#endif
X
X
X/* replacement for MH routine */
Xstatic char * m_find(p)
Xchar *p;
X`7B
X    FILE *F;
X    char *home, *mhprofile;
X    char fullname `5B100`5D;
X    static char buf`5B512`5D;
X    char *q,*s;
X    char *getenv();
X
X    mhprofile = getenv("MH");
X    if (!mhprofile) `7B
X`09home = getenv("HOME");
X`09if (!home) `7B
X`09    return 0;
X`09`7D
X`09(void) sprintf(fullname, "%s/.mh_profile", home);
X    `7D
X    else`09/* either an absolute pathname, or relative to current dir */
X`09(void) strcpy(fullname, mhprofile);
X
X    F = fopen(fullname, "r");
X    if(F == NULL) `7B
X`09return 0;
X    `7D
X    while (fgets(buf, 512, F) != NULL) `7B
X`09q = index(buf,':');
X        if(q != 0) `7B
X`09    *q = '\0';
X`09    s = ++q;
X`09    if (strcasecmp(buf, p) == 0) `7B
X`09        q += strspn(q," \t");
X`09        s = strpbrk(q," \n\t");
X`09        if(s) `7B
X`09`09    *s = '\0';
X`09`09`7D
X`09        (void) fclose(F);
X`09        return q;
X`09    `7D
X        `7D
X    `7D
X    (void) fclose(F);
X    return 0;
X`7D
X
X
Xint MHrefile(folder, arttext)
Xchar *folder;
Xchar *arttext;
X`7B
X    char *p,*q;
X    char  *userpath;
X    char *getenv();
X    char *m_find();
X    char tmp`5B512`5D;
X    char fullpath`5B512`5D;
X    char fullpath2`5B512`5D;
X    char newfolders`5B512`5D;
X    char msg`5B512`5D;
X    struct stat st;
X    char *artfile = NULL;
X    FILE *fpsave;
X  `20
X    p = getenv("HOME");
X    if(p == 0) `7B
X`09return 0;
X    `7D
X    userpath = m_find("path");
X    if(userpath == 0) `7B
X`09(void) strcpy(fullpath, p);
X    `7D else if (userpath`5B0`5D == '/') `7B
X`09(void) strcpy(fullpath, userpath);
X    `7D else `7B
X`09if (userpath`5B0`5D == '/')
X`09    (void) strcpy(fullpath, userpath);
X`09else
X`09    (void) sprintf(fullpath, "%s/%s", p, userpath);
X    `7D
X    if((stat(fullpath,&st) == -1) `7C`7C !S_ISDIR(st.st_mode)) `7B
X`09mesgPane(XRN_SERIOUS, "No Mail directory `60%s'", fullpath);     `20
X`09return 0;
X    `7D
X    (void) sprintf(fullpath2, "%s/%s", fullpath, (folder+1));
X    if (stat(fullpath2,&st) == -1 && errno == ENOENT) `7B
X`09(void) sprintf(msg,"No such folder - %s - Create it?",fullpath2);
X`09if (ConfirmationBox(TopLevel, msg)  == XRN_CB_ABORT) `7B
X`09    return 0;
X`09`7D
X`09(void) strcpy(newfolders, (folder+1));
X`09q = strtok(newfolders, "/");
X`09while (q) `7B
X`09    (void) strcat(fullpath, "/");
X`09    (void) strcat(fullpath, q);
X`09    if(stat(fullpath, &st) == -1) `7B
X`09        if(errno == ENOENT)`7B
X`09`09    mkdir(fullpath, 0777);
X`09        `7D else `7B
X`09`09    mesgPane(XRN_SERIOUS,`20
X`09`09      "Can not create folder `60%s. Errno: %d'", fullpath, errno);
X`09`09    return 0;
X`09        `7D
X`09     `7D else if (!S_ISDIR(st.st_mode)) `7B
X`09        mesgPane(XRN_SERIOUS,`20
X`09 `09    "Can not create folder.  Not a directory `60%s'", fullpath);
X`09        return 0;
X`09    `7D
X`09    q = strtok(0, "/");
X        `7D
X    `7D else if (!S_ISDIR(st.st_mode)) `7B
X        mesgPane(XRN_SERIOUS, "Not a folder %s'", fullpath2);
X        return 0;
X    `7D
X    artfile = (char *) tempnam(p,"XRN");
X    if ((fpsave = fopen(artfile, "w")) == NULL) `7B
X`09(void) sprintf(error_buffer, "Cannot create temp file: %s",
X`09`09`09errmsg(errno));
X`09mesgPane(XRN_SERIOUS, error_buffer);
X`09free(artfile);
X`09return 0;
X    `7D
X
X    if (fputs(arttext, fpsave) == EOF) `7B
X`09(void) sprintf(error_buffer, "Cannot write temp file: %s",
X`09`09`09errmsg(errno));
X`09mesgPane(XRN_SERIOUS, error_buffer);
X`09free(artfile);
X`09return 0;
X    `7D
X    (void) fclose(fpsave);
X
X    if (stat(artfile, &st) == -1) `7B
X`09(void) sprintf(error_buffer, "Cannot stat temp file: %s",
X`09`09`09errmsg(errno));
X`09mesgPane(XRN_SERIOUS, error_buffer);
X`09free(artfile);
X        return 0;
X    `7D
X
X    if (app_resources.mhPath)
X`09(void) sprintf(tmp, "%s/refile -f %s %s", app_resources.mhPath,
X`09`09       artfile, folder);
X    else
X`09(void) sprintf(tmp, "refile -f %s %s", artfile, folder);
X
X    (void) system(tmp);
X    unlink(artfile);
X    free(artfile);
X    return 1;
X`7D
X
X/*`20
X * Refile an article in EMACS RMAIL format
X */
X
X/*ARGSUSED*/
Xint RMAILrefile
X#ifndef _NO_PROTO
X(char *fullpath, char *folder, char *artfile, long pos)
X#else
X(fullpath, folder, artfile, pos)
Xchar *fullpath, *folder, *artfile;
Xlong pos;
X#endif
X`7B
X    char msg`5B512`5D;
X    struct stat st;
X    extern int errno;
X    FILE * fp;
X    int artfd, rv, n;
X
X    if (stat(fullpath,&st) == -1 && errno == ENOENT) `7B
X`09(void) sprintf(msg,"No such folder - %s - Create it?",fullpath);
X`09if (ConfirmationBox (TopLevel, msg)  == XRN_CB_ABORT) `7B
X`09    return 0;
X`09`7D
X`09if ((fp = fopen (fullpath, "w")) == NULL) `7B
X`09    mesgPane(XRN_SERIOUS,`20
X`09`09     "Can not create folder `60%s. Errno: %d'", fullpath, errno);
X`09    return 0;
X`09`7D
X`09/* Produce the header */
X`09fprintf (fp, "BABYL OPTIONS:\n");
X`09fprintf (fp, "Version: 5\n");
X`09fprintf (fp, "Labels:\n");
X`09fprintf (fp, "Note: This is RMAIL file produced by XRN:\n");
X`09fprintf (fp, "Note: if your are seeing this it means the file\n");
X`09fprintf (fp, "Note: has no messages in it.\n\037");
X    `7D else `7B
X`09if ((fp = fopen (fullpath, "a")) == NULL) `7B
X`09    mesgPane(XRN_SERIOUS,`20
X`09`09     "Can not open folder `60%s. Errno: %d'", fullpath, errno);
X`09    return 0;
X`09`7D
X    `7D
X    if ((artfd = open(artfile, 0)) < 0) `7B
X`09mesgPane(XRN_SERIOUS, "Cannot open the article temporary file: %s",
X`09`09 errmsg(errno));
X`09return(0);
X    `7D
X    /* Format the header */
X    fprintf (fp, "\014\n1,,\n");
X    /* insert from 0 to pos (from getarticle) for the header */
X    n = 0;
X    while ((rv = read (artfd, msg, n + 512 > pos ? pos - n : 512)) > 0) `7B
X`09if (! fwrite (msg, n+512 > pos ? pos - n : 512, 1, fp)) `7B
X`09    mesgPane(XRN_SERIOUS, "Cannot write RMAIL file: %s",
X`09`09     errmsg(errno));
X`09    break;
X`09`7D
X`09n += rv;
X    `7D
X    /* reseek start of file */
X    lseek (artfd, (off_t) 0, 0);
X    fprintf (fp, "\n*** EOOH ***\n");
X    /* insert the article */
X    while ((rv = read (artfd, msg, 512)) > 0)
X`09if (! fwrite (msg, rv, 1, fp)) `7B
X`09    mesgPane(XRN_SERIOUS, "Cannot write RMAIL file: %s",
X`09`09     errmsg(errno));
X`09    break;
X`09`7D
X    close (artfd);
X    /* insert the article end mark */
X    fprintf (fp, "\037");
X    fclose (fp);
X    return 1;
X`7D
X
$ CALL UNPACK REFILE.C;6 421800960
$ create 'f'
X
X#if !defined(lint) && !defined(SABER)
Xstatic char XRNrcsid`5B`5D = "$Header: /net/objy27/wrld/mnt11/ricks/src/mast
Ver/xrn/resources.c,v 1.7 1993/02/04 18:22:22 ricks Exp $";
X#endif
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * resources.c: routines for handling resource management
X */
X
X#include "copyright.h"
X#include "config.h"
X#include <stdio.h>
X#include <string.h>
X#include "xrn.h"
X#include "utils.h"
X#ifndef VMS
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#include <X11/Shell.h>
X#else
X#include <decw$include/Intrinsic.h>
X#include <decw$include/StringDefs.h>
X#include <decw$include/Shell.h>
X#endif
X#include "avl.h"
X#include "xthelper.h"
X#include "mesg.h"
X#include "resources.h"
X#include "error_hnds.h"
X#include "news.h"
X#include "internals.h"
X#ifdef VMS
X#define index strchr
X#endif /* VMS */
X
X#define fixupString(field)`09`09`09`09`09\
X    if (app_resources.field && *app_resources.field == '\0')`09\
X`09app_resources.field = NULL;
X/*
X * resources and command list
X */
X
X/* extra name and class specifications */
X#define XtNaddBindings`09`09"addBindings"
X#define XtCAddBindings`09`09"AddBindings"
X#define XtNaddButtonList`09"addButtonList"
X#define XtCAddButtonList`09"AddButtonList"
X#define XtNaddPopupList`09`09"addPopupList"
X#define XtCAddPopupList`09`09"AddPopupList"
X#define XtNallBindings`09`09"allBindings"
X#define XtCAllBindings`09`09"AllBindings"
X#define XtNallButtonList`09"allButtonList"
X#define XtCAllButtonList`09"AllButtonList"
X#define XtNallPopupList`09`09"allPopupList"
X#define XtCAllPopupList`09`09"AllPopupList"
X#define XtNartBindings`09`09"artBindings"
X#define XtCArtBindings`09`09"ArtBindings"
X#define XtNartButtonList`09"artButtonList"
X#define XtCArtButtonList`09"ArtButtonList"
X#define XtNartLayout`09`09"artLayout"
X#define XtCArtLayout`09`09"ArtLayout"
X#define XtNartPopupList`09`09"artPopupList"
X#define XtCArtPopupList`09`09"ArtPopupList"
X#define XtNartSpecButtonList`09"artSpecButtonList"
X#define XtCArtSpecButtonList`09"ArtSpecButtonList"
X#define XtNauthorFullName`09"authorFullName"
X#define XtCAuthorFullName`09"AuthorFullName"
X#define XtNauthorLength`09`09"authorLength"
X#define XtCAuthorLength`09`09"AuthorLength"
X#define XtNautoRead`09`09"autoRead"
X#define XtCAutoRead`09`09"AutoRead"
X#define XtNautoWrap`09`09"autoWrap"
X#define XtCAutoWrap`09`09"AutoWrap"
X#define XtNbusyIcon`09`09"busyIcon"
X#define XtCBusyIcon`09`09"BusyIcon"
X#define XtNbusyIconName`09`09"busyIconName"
X#define XtCBusyIconName`09`09"BusyIconName"
X#define XtNbusyIconPixmap`09"busyIconPixmap"
X#define XtCBusyIconPixmap`09"BusyIconPixmap"
X#define XtNcalvin`09`09"calvin"
X#define XtCCalvin`09`09"Calvin"
X#define XtNcancelCount`09`09"cancelCount"
X#define XtCCancelCount`09`09"CancelCount"
X#define XtNcc`09`09`09"cc"
X#define XtCCc`09`09`09"Cc"
X#define XtNccForward`09`09"ccForward"
X#define XtCCcForward`09`09"CcForward"
X#define XtNcompBreakLength`09"compBreakLength"
X#define XtCCompBreakLength`09"CompBreakLength"
X#define XtNcompLayout`09`09"compLayout"
X#define XtCCompLayout`09`09"CompLayout"
X#define XtNcompLineLength`09"compLineLength"
X#define XtCCompLineLength`09"CompLineLength"
X#define XtNcompRows`09`09"compRows"
X#define XtCCompRows`09`09"CompRows"
X#define XtNconfirm`09`09"confirm"
X#define XtCConfirm`09`09"Confirm"
X#define XtNdeadLetters`09`09"deadLetters"
X#define XtCDeadLetters`09`09"DeadLetters"
X#define XtCDebug       `09`09"Debug"
X#define XtNdefaultLines`09`09"defaultLines"
X#define XtCDefaultLines`09`09"DefaultLines"
X#define XtNdelayedPrint`09`09"delayedPrint"
X#define XtCDelayedPrint`09`09"DelayedPrint"
X#define XtNdisplayLineCount`09"displayLineCount"
X#define XtCDisplayLineCount`09"DisplayLineCount"
X#ifdef REALLY_USE_LOCALTIME
X#define XtNdisplayLocalTime`09"displayLocalTime"
X#define XtCDisplayLocalTime`09"DisplayLocalTime"
X#endif
X#define XtNdistribution`09`09"distribution"
X#define XtCDistribution`09`09"Distribution"
X#define XtNdumpCore`09`09"dumpCore"
X#define XtNeditorCommand `09"editorCommand"
X#define XtCEditorCommand`09"EditorCommand"
X#define XtNexecutableSignatures "executableSignatures"
X#define XtCExecutableSignatures "ExecutableSignatures"
X#define XtNextraMailHeaders`09"extraMailHeaders"
X#define XtCExtraMailHeaders`09"ExtraMailHeaders"
X#define XtNhostName`09`09"hostName"
X#define XtCHostName`09`09"HostName"
X#define XtNiconGeometry`09`09"iconGeometry"
X#define XtCIconGeometry`09`09"IconGeometry"
X#define XtNignoreNewsgroups`09"ignoreNewsgroups"
X#define XtCIgnoreNewsgroups`09"IgnoreNewsgroups"
X#define XtNincludeCommand`09"includeCommand"
X#define XtCIncludeCommand`09"IncludeCommand"
X#define XtNincludeHeader`09"includeHeader"
X#define XtCIncludeHeader`09"IncludeHeader"
X#define XtNincludePrefix`09"includePrefix"
X#define XtCIncludePrefix`09"IncludePrefix"
X#define XtNincludeSep`09`09"includeSep"
X#define XtCIncludeSep`09`09"IncludeSep"
X#define XtNindexLayout`09`09"indexLayout"
X#define XtCIndexLayout`09`09"IndexLayout"
X#define XtNinfo`09`09`09"info"
X#define XtCInfo`09`09`09"Info"
X#define XtNkillFiles`09`09"killFiles"
X#define XtCKillFiles`09`09"KillFiles"
X#define XtNlayout`09`09"layout"
X#define XtCLayout`09`09"Layout"
X#define XtNleaveHeaders`09`09"leaveHeaders"
X#define XtCLeaveHeaders`09`09"LeaveHeaders"
X#define XtNlocalSignatures`09"localSignatures"
X#define XtCLocalSignatures`09"LocalSignatures"
X#define XtNlockFile`09`09"lockFile"
X#define XtCLockFile`09`09"LockFile"
X#ifndef VMS
X#define XtNmailer`09`09"mailer"
X#define XtCMailer`09`09"Mailer"
X#endif
X#define XtNmaxLines`09`09"maxLines"
X#define XtCMaxLines`09`09"MaxLines"
X#define XtNmhPath`09`09"mhPath"
X#define XtCMhPath`09`09"MhPath"
X#define XtNminLines`09`09"minLines"
X#define XtCMinLines`09`09"MinLines"
X#define XtNnewsrcFile`09`09"newsrcFile"
X#define XtCNewsrcFile`09`09"NewsrcFile"
X#define XtNnextReadsFirst`09"nextReadsFirst"
X#define XtCNextReadsFirst`09"NextReadsFirst"
X#define XtNngBindings`09`09"ngBindings"
X#define XtCNgBindings`09`09"NgBindings"
X#define XtNngButtonList`09`09"ngButtonList"
X#define XtCNgButtonList`09`09"NgButtonList"
X#define XtNngPopupList`09`09"ngPopupList"
X#define XtCNgPopupList`09`09"NgPopupList"
X#define XtNnntpServer`09`09"nntpServer"
X#define XtCNntpServer`09`09"NntpServer"
X#define XtNonlyShow`09`09"onlyShow"
X#define XtCOnlyShow`09`09"OnlyShow"
X#define XtNorganization`09`09"organization"
X#define XtCOrganization`09`09"Organization"
X#define XtNpageArticles`09`09"pageArticles"
X#define XtCPageArticles`09`09"PageArticles"
X#ifdef VMS
X#define XtNpersonalName`09`09"personalName"
X#define XtCPersonalName`09`09"personalName"
X#endif
X#define XtNpointerBackground`09"pointerBackground"
X#define XtCPointerBackground`09"PointerBackground"
X#define XtNpointerForeground`09"pointerForeground"
X#define XtCPointerForeground`09"PointerForeground"
X#define XtNpopupButton`09`09"popupButton"
X#define XtCPopupButton`09`09"PopupButton"
X#define XtNprintCommand`09`09"printCommand"
X#define XtCPrintCommand`09`09"PrintCommand"
X#define XtNreplyPath`09`09"replyPath"
X#define XtCReplyPath`09`09"ReplyPath"
X#define XtNreplyTo`09`09"replyTo"
X#define XtCReplyTo`09`09"ReplyTo"
X#define XtNrescanTime`09`09"rescanTime"
X#define XtCRescanTime`09`09"RescanTime"
X#define XtNresetSave`09`09"resetSave"
X#define XtCResetSave`09`09"ResetSave"
X#define XtNretainKilled`09`09"retainKilled"
X#define XtCRetainKilled`09`09"RetainKilled"
X#define XtNretryLimit`09`09"retryLimit"
X#define XtCRetryLimit`09`09"RetryLimit"
X#define XtNretryPopupCount`09"retryPopupCount"
X#define XtCRetryPopupCount`09"RetryPopupCount"
X#define XtNretryPopupTimeout`09"retryPopupTimeout"
X#define XtCRetryPopupTimeout`09"RetryPopupTimeout"
X#define XtNretryPause`09`09"retryPause"
X#define XtCRetryPause`09`09"RetryPause"
X#define XtNsaveDir`09`09"saveDir"
X#define XtCSaveDir`09`09"SaveDir"
X#define XtNsaveMode`09`09"saveMode"
X#define XtCSaveMode`09`09"SaveMode"
X#define XtNsaveNewsrcFile`09"saveNewsrcFile"
X#define XtCSaveNewsrcFile`09"SaveNewsrcFile"
X#define XtNsavePostings`09`09"savePostings"
X#define XtCSavePostings`09`09"SavePostings"
X#define XtNsaveString`09`09"saveString"
X#define XtCSaveString`09`09"SaveString"
X#define XtNsignatureFile`09"signatureFile"
X#define XtCSignatureFile`09"SignatureFile"
X#define XtNsignatureNotify`09"signatureNotify"
X#define XtCSignatureNotify`09"SignatureNotify"
X#define XtNsortedSubjects`09"sortedSubjects"
X#define XtCSortedSubjects`09"SortedSubjects"
X#define XtRSortedSubjects`09"SortedSubjects"
X#define XtNstripHeaders`09`09"stripHeaders"
X#define XtCStripHeaders`09`09"StripHeaders"
X#define XtNsubjectLength`09"subjectLength"
X#define XtCSubjectLength`09"SubjectLength"
X#define XtNsubjectRead`09`09"subjectRead"
X#define XtCSubjectRead`09`09"SubjectRead"
X#define XtNtextLines`09`09"textLines"
X#define XtCTextLines`09`09"TextLines"
X#define XtNtmpDir`09`09"tmpDir"
X#define XtCTmpDir`09`09"TmpDir"
X#define XtNtopLines`09`09"topLines"
X#define XtCTopLines`09`09"TopLines"
X#define XtNtwoWindows`09`09"twoWindows"
X#define XtCTwoWindows`09`09"TwoWindows"
X#define XtNunsubNewGroups`09"unsubNewGroups"
X#define XtCUnsubNewGroups`09"UnsubNewGroups"
X#define XtNunreadIconName`09"unreadIconName"
X#define XtCUnreadIconName`09"UnreadIconName"
X#define XtNunreadIconPixmap`09"unreadIconPixmap"
X#define XtCUnreadIconPixmap`09"UnreadIconPixmap"
X#define XtNupdateNewsrc`09`09"updateNewsrc"
X#define XtCUpdateNewsrc`09`09"UpdateNewsrc"
X#define XtNuseGadgets`09`09"useGadgets"
X#define XtCUseGadgets`09`09"UseGadgets"
X#define XtNverboseKill`09`09"verboseKill"
X#define XtCVerboseKill`09`09"VerboseKill"
X#define XtNversion`09`09"version"
X#define XtCVersion`09`09"Version"
X#define XtNwatchProgress`09"watchProgress"
X#define XtCWatchProgress`09"WatchProgress"
X#ifdef WATCH
X#define XtNwatchUnread`09`09"watchUnread"
X#define XtCWatchUnread`09`09"WatchUnread"
X#endif
X#define XtNxrefMarkRead`09`09"xrefMarkRead"
X#define XtCXrefMarkRead`09`09"XrefMarkRead"
X
Xstatic Boolean defaultFalse = False;
Xstatic Boolean defaultTrue  = True;
X
X#ifndef XtRBitmap
X#define XtRBitmap "Bitmap"
X#endif
X
Xapp_resourceRec app_resources;
Xchar title`5BLABEL_SIZE`5D;
Xstatic char unreadTitle`5B`5D = UNREADTITLE;
X
Xstatic char defaultNgButtons`5B`5D =
X"ngQuit,ngRead,ngSubscribe,ngUnsub,ngCatchUp,ngGoto,ngRescan,ngCheckPoint,ng
VSelect,ngMove,ngPost";
X
Xstatic char defaultNgPopups`5B`5D =
X"ngQuit,ngRead,ngSubscribe,ngUnsub,ngCatchUp,ngGoto,ngRescan,ngCheckPoint,ng
VPost";
X
Xstatic char defaultArtButtons`5B`5D =
X"artQuit,artNext,artPrev,artNextUnread,artSubNext,artSubPrev,artLast,artNext
VGroup,artCatchUp,artMarkRead,artMarkUnread";
X
Xstatic char defaultArtPopups`5B`5D =
X"artQuit,artNext,artPrev,artNextUnread,artSubNext,artSubPrev,artLast,artNext
VGroup,artSave,artReply,artForward,artFollowup,artMarkUnread";
X
X/*
X * resources 'xrn' needs to get, rather than ones that the individual
X * widgets will handle
X */
Xstatic XtResource resources`5B`5D = `7B
X
X   `7BXtNaddBindings, XtCAddBindings, XtRString, sizeof(char *),
X      XtOffset(app_res,addBindings), XtRString, (caddr_t) NULL`7D,
X
X   `7BXtNaddButtonList, XtCAddButtonList, XtRString, sizeof(char *),
X      XtOffset(app_res,addButtonList), XtRString, (caddr_t) NULL`7D,
X
X   `7BXtNaddPopupList, XtCAddPopupList, XtRString, sizeof(char *),
X      XtOffset(app_res,addPopupList), XtRString, (caddr_t) NULL`7D,
X
X   `7BXtNallBindings, XtCAllBindings, XtRString, sizeof(char *),
X      XtOffset(app_res,allBindings), XtRString, (caddr_t) NULL`7D,
X
X   `7BXtNallButtonList, XtCAllButtonList, XtRString, sizeof(char *),
X      XtOffset(app_res,allButtonList), XtRString, (caddr_t) NULL`7D,
X
X   `7BXtNallPopupList, XtCAllPopupList, XtRString, sizeof(char *),
X      XtOffset(app_res,allPopupList), XtRString, (caddr_t) NULL`7D,
X
X   `7BXtNartBindings, XtCArtBindings, XtRString, sizeof(char *),
X      XtOffset(app_res,artBindings), XtRString, (caddr_t) NULL`7D,
X
X   `7BXtNartButtonList, XtCArtButtonList, XtRString, sizeof(char *),
X      XtOffset(app_res,artButtonList), XtRString, (caddr_t) defaultArtButton
Vs`7D,
X
X   `7BXtNartPopupList, XtCArtPopupList, XtRString, sizeof(char *),
X      XtOffset(app_res,artPopupList), XtRString, (caddr_t) defaultArtPopups`
V7D,
X
X   `7BXtNartLayout, XtCArtLayout, XtRString,  sizeof(char *),
X      XtOffset(app_res,artLayout), XtRString, (caddr_t) NULL`7D,
X  `20
X   `7BXtNartSpecButtonList, XtCArtSpecButtonList, XtRString, sizeof(char *),
X      XtOffset(app_res,artSpecButtonList), XtRString, (caddr_t) NULL`7D,
X
X   `7BXtNauthorFullName, XtCAuthorFullName, XtRBoolean, sizeof(Boolean),
X     XtOffset(app_res,authorFullName), XtRBoolean, (caddr_t) &defaultFalse`7
VD,
X
X   `7BXtNauthorLength, XtCAuthorLength, XtRInt, sizeof(int),
X      XtOffset(app_res,authorLength), XtRImmediate, (caddr_t) 0`7D,
X
X   `7BXtNautoRead, XtCAutoRead, XtRBoolean, sizeof(Boolean),
X     XtOffset(app_res,autoRead), XtRBoolean, (caddr_t) &defaultTrue`7D,
X
X   `7BXtNautoWrap, XtCAutoWrap, XtRBoolean, sizeof(Boolean),
X     XtOffset(app_res,autoWrap), XtRBoolean, (caddr_t) &defaultTrue`7D,
X
X   `7BXtNbusyIcon, XtCBusyIcon, XtRBoolean, sizeof(Boolean),
X     XtOffset(app_res,busyIcon), XtRBoolean, (caddr_t) &defaultFalse`7D,
X
X   `7BXtNbusyIconName,  XtCBusyIconName,  XtRString,  sizeof(char *),
X      XtOffset(app_res,busyIconName), XtRString, (caddr_t) NULL`7D,
X
X   `7BXtNbusyIconPixmap,  XtCBusyIconPixmap,  XtRBitmap,  sizeof(char *),
X      XtOffset(app_res,busyIconPixmap), XtRPixmap, (caddr_t) NULL`7D,
X
X   `7BXtNcalvin, XtCCalvin, XtRBoolean, sizeof(Boolean),
X      XtOffset(app_res,calvin), XtRBoolean, (caddr_t) &defaultFalse`7D,
X  `20
X   `7BXtNcancelCount, XtCCancelCount, XtRInt, sizeof(int),
X      XtOffset(app_res,cancelCount), XtRString, (caddr_t) CANCELCOUNT`7D,
X
X   `7BXtNcc, XtCCc, XtRBoolean, sizeof(Boolean),
X     XtOffset(app_res,cc), XtRBoolean, (caddr_t) &defaultTrue`7D,
X
X   `7BXtNccForward, XtCCcForward, XtRBoolean, sizeof(Boolean),
X     XtOffset(app_res,ccForward), XtRBoolean, (caddr_t) &defaultFalse`7D,
X
X   `7BXtNcompBreakLength, XtCCompBreakLength, XtRInt, sizeof(int),
X      XtOffset(app_res,breakLength), XtRString, (caddr_t) BREAKLENGTH`7D,
X
X   `7BXtNcompLayout, XtCCompLayout, XtRString,  sizeof(char *),
X      XtOffset(app_res,compLayout), XtRString, (caddr_t) NULL`7D,
X  `20
X   `7BXtNcompLineLength, XtCCompLineLength, XtRInt, sizeof(int),
X      XtOffset(app_res,lineLength), XtRString, (caddr_t) LINELENGTH`7D,
X  `20
X   `7BXtNcompRows, XtCCompRows, XtRInt, sizeof(int),
X      XtOffset(app_res,composeRows), XtRImmediate, (caddr_t) 30`7D,
X  `20
X   `7BXtNconfirm, XtCConfirm, XtRString, sizeof(char *),
X      XtOffset(app_res,confirm), XtRString, (caddr_t) NULL`7D,
X
X   `7BXtNdeadLetters, XtCDeadLetters, XtRString, sizeof(char *),
X      XtOffset(app_res,deadLetters), XtRString, (caddr_t) DEADLETTER`7D,
X
X   `7BXtNdumpCore, XtCDebug, XtRBoolean, sizeof(Boolean),
X      XtOffset(app_res,dumpCore), XtRBoolean, (caddr_t)
X#ifdef DUMPCORE
X`09`09`09`09`09`09`09&defaultTrue`7D,
X#else
X`09`09`09`09`09`09`09&defaultFalse`7D,
X#endif
X
X   `7BXtNdefaultLines, XtCDefaultLines, XtRInt, sizeof(int),
X      XtOffset(app_res,defaultLines), XtRString, (caddr_t) MINLINES`7D,
X
X   `7BXtNdelayedPrint, XtCDelayedPrint, XtRBoolean, sizeof(Boolean),
X     XtOffset(app_res, delayedPrint), XtRBoolean, (caddr_t) &defaultFalse`7D
V,
X
X   `7BXtNdisplayLineCount, XtCDisplayLineCount, XtRBoolean, sizeof(Boolean),
X     XtOffset(app_res,displayLineCount), XtRBoolean, (caddr_t) &defaultFalse
V`7D,
X
X#ifdef REALLY_USE_LOCALTIME
X   `7BXtNdisplayLocalTime, XtCDisplayLocalTime, XtRBoolean, sizeof(Boolean),
X     XtOffset(app_res,displayLocalTime), XtRBoolean, (caddr_t) &defaultTrue`
V7D,
X#endif
X
X   `7BXtNdistribution, XtCDistribution, XtRString, sizeof(char *),
X      XtOffset(app_res,distribution), XtRString, (caddr_t) NULL`7D,
X  `20
X   `7BXtNeditorCommand, XtCEditorCommand, XtRString, sizeof(char *),
X      XtOffset(app_res,editorCommand), XtRString, (caddr_t) NULL`7D,
X
X   `7BXtNexecutableSignatures, XtCExecutableSignatures, XtRBoolean, sizeof(B
Voolean),
X      XtOffset(app_res,executableSignatures), XtRBoolean, (caddr_t) &default
VFalse`7D,
X  `20
X   `7BXtNextraMailHeaders, XtCExtraMailHeaders, XtRBoolean, sizeof(Boolean),
X     XtOffset(app_res,extraMailHeaders), XtRBoolean, (caddr_t) &defaultFalse
V`7D,
X
X   `7BXtNhostName, XtCHostName, XtRString, sizeof(char *),
X      XtOffset(app_res,hostName), XtRString, (caddr_t) NULL`7D,
X
X   `7BXtNiconGeometry,  XtCIconGeometry,  XtRString,  sizeof(char *),
X      XtOffset(app_res,iconGeometry), XtRString, (caddr_t) NULL`7D,
X  `20
X   `7BXtNiconPixmap,  XtCIconPixmap,  XtRBitmap,  sizeof(char *),
X      XtOffset(app_res,iconPixmap), XtRPixmap, (caddr_t) NULL`7D,
X
X   `7BXtNiconName,  XtCIconName,  XtRString,  sizeof(char *),
X      XtOffset(app_res,iconName), XtRString,
X#ifdef SHORT_ICONNAME
X#ifndef MOTIF
X`09(caddr_t) "dxrn"`7D,
X#else
X`09(caddr_t) "mxrn"`7D,
X#endif
X#else
X`09(caddr_t) title`7D,
X#endif
X
X   `7BXtNignoreNewsgroups, XtCIgnoreNewsgroups, XtRString, sizeof(char *),
X      XtOffset(app_res,ignoreNewsgroups), XtRString, (caddr_t) NULL`7D,
X  `20
X   `7BXtNincludeCommand, XtCIncludeCommand, XtRString, sizeof(char *),
X      XtOffset(app_res,includeCommand), XtRString, (caddr_t) NULL`7D,
X
X   `7BXtNincludeHeader, XtCIncludeHeader, XtRBoolean, sizeof(Boolean),
X     XtOffset(app_res,includeHeader), XtRBoolean, (caddr_t) &defaultFalse`7D
V,
X
X   `7BXtNincludePrefix, XtCIncludePrefix, XtRString, sizeof(char *),
X     XtOffset(app_res,includePrefix), XtRString, (caddr_t) INCLUDEPREFIX`7D,
X
X   `7BXtNincludeSep, XtCIncludeSep, XtRBoolean, sizeof(Boolean),
X     XtOffset(app_res,includeSep), XtRBoolean, (caddr_t) &defaultTrue`7D,
X
X   `7BXtNindexLayout, XtCIndexLayout, XtRString,  sizeof(char *),
X      XtOffset(app_res,indexLayout), XtRString, (caddr_t) NULL`7D,
X  `20
X   `7BXtNinfo, XtCInfo, XtRBoolean, sizeof(Boolean),
X      XtOffset(app_res,info), XtRBoolean, (caddr_t) &defaultTrue`7D,
X  `20
X   `7BXtNkillFiles, XtCKillFiles, XtRBoolean, sizeof(Boolean),
X      XtOffset(app_res,killFiles), XtRBoolean, (caddr_t) &defaultTrue`7D,
X
X   `7BXtNlayout, XtCLayout, XtRString,  sizeof(char *),
X      XtOffset(app_res,mainLayout), XtRString, (caddr_t) NULL`7D,
X  `20
X   `7BXtNleaveHeaders, XtCLeaveHeaders, XtRString, sizeof(char *),
X      XtOffset(app_res,leaveHeaders), XtRString, (caddr_t) NULL`7D,
X  `20
X   `7BXtNlocalSignatures, XtCLocalSignatures, XtRBoolean, sizeof(Boolean),
X      XtOffset(app_res,localSignatures), XtRBoolean, (caddr_t) &defaultFalse
V`7D,
X  `20
X   `7BXtNlockFile, XtCLockFile, XtRString, sizeof(char *),
X#ifndef VMS
X      XtOffset(app_res,lockFile), XtRString, (caddr_t) "`7E/.xrnlock"`7D,
X#else
X      XtOffset(app_res,lockFile), XtRString, (caddr_t) "sys$login:xrn.lock"`
V7D,
X#endif
X
X#ifndef VMS
X   `7BXtNmailer, XtCMailer, XtRString, sizeof(char *),
X      XtOffset(app_res,mailer), XtRString, (caddr_t) SENDMAIL`7D,
X#endif
X
X   `7BXtNmaxLines, XtCMaxLines, XtRInt, sizeof(int),
X      XtOffset(app_res,maxLines), XtRImmediate, (caddr_t) -1`7D,
X  `20
X   `7BXtNmhPath, XtCMhPath, XtRString, sizeof(String),
X      XtOffset(app_res,mhPath), XtRString, (caddr_t) NULL`7D,
X
X   `7BXtNminLines, XtCMinLines, XtRInt, sizeof(int),
X      XtOffset(app_res,minLines), XtRImmediate, (caddr_t) -1`7D,
X
X   `7BXtNnewsrcFile, XtCNewsrcFile, XtRString, sizeof(char *),
X      XtOffset(app_res,newsrcFile), XtRString, (caddr_t) NEWSRCFILE`7D,
X  `20
X   `7BXtNngBindings, XtCNgBindings, XtRString, sizeof(char *),
X      XtOffset(app_res,ngBindings), XtRString, (caddr_t) NULL`7D,
X
X   `7BXtNngButtonList, XtCNgButtonList, XtRString, sizeof(char *),
X      XtOffset(app_res,ngButtonList), XtRString, (caddr_t) defaultNgButtons`
V7D,
X
X   `7BXtNngPopupList, XtCNgPopupList, XtRString, sizeof(char *),
X      XtOffset(app_res,ngPopupList), XtRString, (caddr_t) defaultNgPopups`7D
V,
X
X   `7BXtNnntpServer, XtCNntpServer, XtRString, sizeof(char *),
X      XtOffset(app_res,nntpServer), XtRString, (caddr_t) NULL`7D,
X  `20
X   `7BXtNonlyShow, XtCOnlyShow, XtRInt, sizeof(int),
X      XtOffset(app_res,onlyShow), XtRString, (caddr_t) ONLYSHOW`7D,
X
X   `7BXtNorganization, XtCOrganization, XtRString, sizeof(char *),
X      XtOffset(app_res,organization), XtRString, (caddr_t) NULL`7D,
X  `20
X   `7BXtNpageArticles, XtCPageArticles, XtRBoolean, sizeof(Boolean),
X      XtOffset(app_res,pageArticles), XtRBoolean, (caddr_t) &defaultTrue`7D,
X
X#ifdef VMS
X   `7BXtNpersonalName, XtCPersonalName, XtRString, sizeof(char *),
X      XtOffset(app_res,personalName), XtRImmediate, (caddr_t) NULL`7D,
X#endif  `20
X
X#ifdef MOTIF
X   `7BXtNpopupButton,  XtCPopupButton,  XtRInt,`09 sizeof(int),
X      XtOffset(app_res, popupButton), XtRImmediate, (caddr_t) 3`7D,
X#else
X   `7BXtNpopupButton,  XtCPopupButton,  XtRInt,`09 sizeof(int),
X      XtOffset(app_res, popupButton), XtRImmediate, (caddr_t) 2`7D,
X#endif
X
X   `7BXtNpointerForeground, XtCPointerForeground, XtRPixel, sizeof(Pixel),
X      XtOffset(app_res,pointer_foreground), XtRString, "white"`7D,
X
X   `7BXtNpointerBackground, XtCPointerBackground, XtRPixel, sizeof(Pixel),
X      XtOffset(app_res,pointer_background), XtRString, "black"`7D,
X
X   `7BXtNprintCommand, XtCPrintCommand, XtRString, sizeof(char *),
X      XtOffset(app_res,printCommand), XtRString, (caddr_t) PRINTCOMMAND`7D,
X
X   `7BXtNreplyPath, XtCReplyPath, XtRString, sizeof(char *),
X      XtOffset(app_res,replyPath), XtRString, (caddr_t) NULL`7D,
X
X   `7BXtNreplyTo, XtCReplyTo, XtRString, sizeof(char *),
X      XtOffset(app_res,replyTo), XtRString, (caddr_t) NULL`7D,
X  `20
X   `7BXtNresetSave, XtCResetSave, XtRBoolean, sizeof(Boolean),
X      XtOffset(app_res,resetSave), XtRBoolean, (caddr_t) &defaultTrue`7D,
X
X   `7BXtNrescanTime, XtCRescanTime, XtRInt, sizeof(int),
X      XtOffset(app_res,rescanTime), XtRString, (caddr_t) RESCAN_TIME`7D,
X
X   `7BXtNretainKilled, XtCRetainKilled, XtRBoolean, sizeof(Boolean),
X     XtOffset(app_res,retainKilledArticles),
X     XtRBoolean, (caddr_t) &defaultFalse`7D,
X
X   `7BXtNretryLimit, XtCRetryLimit, XtRInt, sizeof(int),
X      XtOffset(app_res,retryLimit), XtRImmediate, (caddr_t) 10`7D,
X
X   `7BXtNretryPopupCount, XtCRetryPopupCount, XtRInt, sizeof(int),
X      XtOffset(app_res,retryPopupCount), XtRImmediate, (caddr_t) 1`7D,
X
X   `7BXtNretryPopupTimeout, XtCRetryPopupTimeout, XtRInt, sizeof(int),
X      XtOffset(app_res,retryPopupTimeout), XtRImmediate, (caddr_t) 60`7D,
X
X   `7BXtNretryPause, XtCRetryPause, XtRInt, sizeof(int),
X      XtOffset(app_res,retryPause), XtRImmediate, (caddr_t) 60`7D,
X
X   `7BXtNsaveDir,  XtCSaveDir,  XtRString, sizeof(char *),
X      XtOffset(app_res,saveDir), XtRString, (caddr_t) SAVEDIR`7D,
X  `20
X   `7BXtNsaveNewsrcFile, XtCSaveNewsrcFile, XtRString, sizeof(char *),
X      XtOffset(app_res,saveNewsrcFile), XtRString, (caddr_t) SAVENEWSRCFILE`
V7D,
X  `20
X   `7BXtNsaveMode, XtCSaveMode, XtRString, sizeof(char *),
X      XtOffset(app_res,strSaveMode), XtRString, (caddr_t) SAVEMODE`7D,
X  `20
X   `7BXtNsavePostings, XtCSavePostings, XtRString, sizeof(char *),
X      XtOffset(app_res,savePostings), XtRString, (caddr_t) SAVEPOSTINGS`7D,
X  `20
X   `7BXtNsaveString, XtCSaveString, XtRString, sizeof(char *),
X      XtOffset(app_res,saveString), XtRString, (caddr_t) ""`7D,
X
X   `7BXtNsignatureFile, XtCSignatureFile, XtRString, sizeof(char *),
X      XtOffset(app_res,signatureFile), XtRString, (caddr_t) SIGNATUREFILE`7D
V,
X  `20
X   `7BXtNsignatureNotify, XtCSignatureNotify, XtRBoolean, sizeof(Boolean),
X      XtOffset(app_res,signatureNotify), XtRBoolean, (caddr_t) &defaultFalse
V`7D,
X  `20
X   `7BXtNsortedSubjects, XtCSortedSubjects, XtRSortedSubjects, sizeof(int),
X     XtOffset(app_res,defSortedSubjects), XtRString, (caddr_t) "off"`7D,
X
X   `7BXtNstripHeaders, XtCStripHeaders, XtRString, sizeof(char *),
X      XtOffset(app_res,stripHeaders), XtRString, (caddr_t) NULL`7D,
X  `20
X   `7BXtNsubjectLength, XtCSubjectLength, XtRInt, sizeof(int),
X      XtOffset(app_res,subjectLength), XtRImmediate, (caddr_t) 0`7D,
X  `20
X   `7BXtNsubjectRead, XtCSubjectRead, XtRBoolean, sizeof(Boolean),
X      XtOffset(app_res,subjectRead), XtRBoolean, (caddr_t) &defaultFalse`7D,
X  `20
X   `7BXtNtextLines, XtCTextLines, XtRInt, sizeof(int),
X      XtOffset(app_res,textLines), XtRString, (caddr_t) TEXTLINES`7D,
X  `20
X   `7BXtNtitle,  XtCTitle,  XtRString,  sizeof(char *),
X      XtOffset(app_res,title), XtRString, (caddr_t) title`7D,
X  `20
X   `7BXtNtmpDir, XtCTmpDir, XtRString, sizeof(char *),
X      XtOffset(app_res,tmpDir), XtRString, (caddr_t) NULL`7D,
X
X   `7BXtNtopLines, XtCTopLines, XtRInt, sizeof(int),
X      XtOffset(app_res,topLines), XtRString, (caddr_t) TOPLINES`7D,
X
X   `7BXtNtwoWindows, XtCTwoWindows, XtRBoolean, sizeof(Boolean),
X      XtOffset(app_res,twoWindows), XtRBoolean, (caddr_t) &defaultFalse`7D,
X
X   `7BXtNunreadIconName,  XtCUnreadIconName,  XtRString,  sizeof(char *),
X      XtOffset(app_res,unreadIconName), XtRString,
X#ifdef SHORT_ICONNAME
X#ifndef MOTIF
X`09(caddr_t) "dxrn (New News)"`7D,
X#else
X`09(caddr_t) "mxrn (New News)"`7D,
X#endif
X#else
X`09(caddr_t) unreadTitle`7D,
X#endif
X  `20
X   `7BXtNunreadIconPixmap,  XtCUnreadIconPixmap,  XtRBitmap,  sizeof(char *)
V,
X      XtOffset(app_res,unreadIconPixmap), XtRPixmap, (caddr_t) NULL`7D,
X
X   `7BXtNunsubNewGroups, XtCUnsubNewGroups, XtRBoolean, sizeof(Boolean),
X      XtOffset(app_res,unsubNewGroups), XtRBoolean, (caddr_t) &defaultFalse`
V7D,
X
X   `7BXtNupdateNewsrc, XtCUpdateNewsrc, XtRBoolean, sizeof(Boolean),
X     XtOffset(app_res,updateNewsrc), XtRBoolean, (caddr_t) &defaultFalse`7D,
X
X   `7BXtNuseGadgets, XtCUseGadgets, XtRBoolean, sizeof(Boolean),
X     XtOffset(app_res,useGadgets), XtRBoolean, (caddr_t) &defaultFalse`7D,
X
X   `7BXtNverboseKill, XtCVerboseKill, XtRBoolean, sizeof(Boolean),
X     XtOffset(app_res,verboseKill), XtRBoolean, (caddr_t) &defaultFalse`7D,
X
X   `7BXtNversion, XtCVersion, XtRString, sizeof(char *),
X     XtOffset(app_res,version), XtRString, (caddr_t) NULL`7D,
X
X   `7BXtNwatchProgress, XtCWatchProgress, XtRBoolean, sizeof(Boolean),
X     XtOffset(app_res,watchProgress), XtRBoolean, (caddr_t) &defaultFalse`7D
V,
X
X   `7BXtNnextReadsFirst, XtCNextReadsFirst, XtRBoolean, sizeof(Boolean),
X     XtOffset(app_res,nextReadsFirst), XtRBoolean, (caddr_t) &defaultFalse`7
VD,
X
X#ifdef WATCH
X   `7BXtNwatchUnread, XtCWatchUnread, XtRString, sizeof(char *),
X      XtOffset(app_res,watchList), XtRString, (caddr_t) NULL`7D,
X#endif
X
X   `7BXtNxrefMarkRead, XtCXrefMarkRead, XtRBoolean, sizeof(Boolean),
X     XtOffset(app_res,xrefMarkRead), XtRBoolean, (caddr_t) &defaultFalse`7D,
X`7D;
X
X/*
X * allowed command line options
X */
X
Xstatic char don`5B`5D = "on";
Xstatic char doff`5B`5D  = "off";
X
X#ifndef VMS
Xstatic XrmOptionDescRec optionList`5B`5D = `7B
X`7B"-addBindings",`09XtNaddBindings,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-addButtonList",`09XtNaddButtonList,`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-addPopupList",`09XtNaddPopupList,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-allBindings",`09XtNallBindings,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-allButtonList",`09XtNallButtonList,`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-allPopupList",`09XtNallPopupList,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-artBindings",`09XtNartBindings,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-artButtonList",`09XtNartButtonList,`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-artPopupList",`09XtNartPopupList,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-artSpecButtonList",`09XtNartSpecButtonList,`09XrmoptionSepArg,(caddr_t)
V NULL`7D,
X`7B"-authorFullName",`09XtNauthorFullName,`09XrmoptionNoArg, (caddr_t) doff`
V7D,
X`7B"+authorFullName",`09XtNauthorFullName,`09XrmoptionNoArg, (caddr_t) don`7
VD,
X`7B"-authorLength",`09XtNauthorLength,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-autoRead",`09`09XtNautoRead,`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+autoRead",`09`09XtNautoRead,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-autoWrap",`09`09XtNautoWrap,`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+autoWrap",`09`09XtNautoWrap,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-busyIcon",`09`09XtNbusyIcon,`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+busyIcon",`09`09XtNbusyIcon,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-busyIconName",`09XtNbusyIconName,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-busyIconPixmap",`09XtNbusyIconPixmap,`09XrmoptionSepArg,(caddr_t) NULL`
V7D,
X`7B"-calvin",`09`09XtNcalvin,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-cancelCount",`09XtNcancelCount,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-cc",`09`09`09XtNcc,`09`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+cc",`09`09`09XtNcc,`09`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-ccForward",`09`09XtNccForward,`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+ccForward",`09`09XtNccForward,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-compBreakLength",`09XtNcompBreakLength,`09XrmoptionSepArg,(caddr_t) NUL
VL`7D,
X`7B"-compLineLength",`09XtNcompLineLength,`09XrmoptionSepArg,(caddr_t) NULL`
V7D,
X`7B"-compRows",`09`09XtNcompRows,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-confirm",`09`09XtNconfirm,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-deadLetters",`09XtNdeadLetters,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-dumpCore",`09`09XtNdumpCore,`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+dumpCore",`09`09XtNdumpCore,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-defaultLines",`09XtNdefaultLines,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-delayedPrint",`09XtNdelayedPrint,`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+delayedPrint",`09XtNdelayedPrint,`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-displayLineCount",`09XtNdisplayLineCount,`09XrmoptionNoArg, (caddr_t) d
Voff`7D,
X`7B"+displayLineCount",`09XtNdisplayLineCount,`09XrmoptionNoArg, (caddr_t) d
Von`7D,
X#ifdef REALLY_USE_LOCALTIME
X`7B"-displayLocalTime",`09XtNdisplayLocalTime,`09XrmoptionNoArg, (caddr_t) d
Voff`7D,
X`7B"+displayLocalTime",`09XtNdisplayLocalTime,`09XrmoptionNoArg, (caddr_t) d
Von`7D,
X#endif
X`7B"-distribution",`09XtNdistribution,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-editorCommand",`09XtNeditorCommand,`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-executableSignatures",XtNexecutableSignatures,XrmoptionNoArg,(caddr_t)
V doff`7D,
X`7B"+executableSignatures",XtNexecutableSignatures,XrmoptionNoArg,(caddr_t)
V don`7D,
X`7B"-extraMailHeaders",`09XtNextraMailHeaders,`09XrmoptionNoArg, (caddr_t) d
Voff`7D,
X`7B"+extraMailHeaders",`09XtNextraMailHeaders,`09XrmoptionNoArg, (caddr_t) d
Von`7D,
X`7B"-hostName",`09`09XtNhostName,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-iconGeometry",`09XtNiconGeometry,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-iconName",           XtNiconName, `09`09XrmoptionSepArg,(caddr_t) NULL`
V7D,
X`7B"-iconPixmap",`09`09XtNiconPixmap, `09`09XrmoptionSepArg,(caddr_t) NULL`7
VD,
X`7B"-ignoreNewsgroups",`09XtNignoreNewsgroups,`09XrmoptionSepArg,(caddr_t) N
VULL`7D,
X`7B"-includeCommand",`09XtNincludeCommand,`09XrmoptionSepArg,(caddr_t) NULL`
V7D,
X`7B"-includeHeader",`09XtNincludeHeader,`09XrmoptionNoArg, (caddr_t) doff`7D
V,
X`7B"+includeHeader",`09XtNincludeHeader,`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-includePrefix",`09XtNincludePrefix,`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-includeSep",`09`09XtNincludeSep,`09`09XrmoptionNoArg, (caddr_t) doff`7D
V,
X`7B"+includeSep",`09`09XtNincludeSep,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-info",`09`09XtNinfo,`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+info",`09`09XtNinfo,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-killFiles",`09`09XtNkillFiles,`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+killFiles",`09`09XtNkillFiles,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-layout",`09`09XtNlayout,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-leaveHeaders",`09XtNleaveHeaders,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-localSignatures",`09XtNlocalSignatures,`09XrmoptionNoArg, (caddr_t) dof
Vf`7D,
X`7B"+localSignatures",`09XtNlocalSignatures,`09XrmoptionNoArg, (caddr_t) don
V`7D,
X`7B"-lockFile",`09`09XtNlockFile,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-mailer",`09`09XtNmailer,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-maxLines",`09`09XtNmaxLines,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-mhPath",`09`09XtNmhPath,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-minLines",`09`09XtNminLines,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-newsrcFile",`09`09XtNnewsrcFile,`09`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-ngBindings",`09`09XtNngBindings,`09`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-ngButtonList",`09XtNngButtonList,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-ngPopupList",`09XtNngPopupList,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-nntpServer",`09`09XtNnntpServer,`09`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-onlyShow",`09`09XtNonlyShow,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-organization",`09XtNorganization,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-pageArticles",`09XtNpageArticles,`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+pageArticles",`09XtNpageArticles,`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-popupButton",`09XtNpopupButton,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-pointerBackground",`09XtNpointerBackground,`09XrmoptionSepArg,(caddr_t)
V NULL`7D,
X`7B"-pointerForeground",`09XtNpointerForeground,`09XrmoptionSepArg,(caddr_t)
V NULL`7D,
X`7B"-printCommand",`09XtNprintCommand,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-replyPath",`09`09XtNreplyPath,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-replyTo",`09`09XtNreplyTo,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-resetSave",`09`09XtNresetSave,`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+resetSave",`09`09XtNresetSave,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-rescanTime",`09`09XtNrescanTime,`09`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-retainKilled",`09XtNretainKilled,`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+retainKilled",`09XtNretainKilled,`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-retryLimit",`09`09XtNretryLimit,`09`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-retryPopupCount",`09XtNretryPopupCount,`09XrmoptionSepArg,(caddr_t) NUL
VL`7D,
X`7B"-retryPopupTimeout",`09XtNretryPopupTimeout,`09XrmoptionSepArg,(caddr_t)
V NULL`7D,
X`7B"-retryPause",`09`09XtNretryPause,`09`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-saveDir",`09`09XtNsaveDir,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-saveNewsrcFile",`09XtNsaveNewsrcFile,`09XrmoptionSepArg,(caddr_t) NULL`
V7D,
X`7B"-saveMode",`09`09XtNsaveMode,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-savePostings",`09XtNsavePostings,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-saveString",`09`09XtNsaveString,`09`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-signatureFile",`09XtNsignatureFile,`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-signatureNotify",`09XtNsignatureNotify,`09XrmoptionNoArg, (caddr_t) dof
Vf`7D,
X`7B"+signatureNotify",`09XtNsignatureNotify,`09XrmoptionNoArg, (caddr_t) don
V`7D,
X`7B"-sortedSubjects",`09XtNsortedSubjects,`09XrmoptionNoArg, (caddr_t) doff`
V7D,
X`7B"+sortedSubjects",`09XtNsortedSubjects,`09XrmoptionNoArg, (caddr_t) don`7
VD,
X`7B"-stripHeaders",`09XtNstripHeaders,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-subjectLength",`09XtNsubjectLength,`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-subjectRead",`09XtNsubjectRead,`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+subjectRead",`09XtNsubjectRead,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-textLines",`09`09XtNtextLines,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-tmpDir",`09`09XtNtmpDir,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-topLines",`09`09XtNtopLines,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-unreadIconName",`09XtNunreadIconName,`09XrmoptionSepArg,(caddr_t) NULL`
V7D,
X`7B"-unreadIconPixmap",`09XtNunreadIconPixmap,`09XrmoptionSepArg,(caddr_t) N
VULL`7D,
X`7B"-updateNewsrc",`09XtNupdateNewsrc,`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+updateNewsrc",`09XtNupdateNewsrc,`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-useGadgets",`09`09XtNuseGadgets,`09`09XrmoptionNoArg, (caddr_t) doff`7D
V,
X`7B"+useGadgets",`09`09XtNuseGadgets,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-verboseKill",`09XtNverboseKill,`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+verboseKill",`09XtNverboseKill,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-watchProgress",`09XtNwatchProgress,`09XrmoptionNoArg, (caddr_t) doff`7D
V,
X`7B"+watchProgress",`09XtNwatchProgress,`09XrmoptionNoArg, (caddr_t) don`7D,
X#ifdef WATCH
X`7B"-watchUnread",`09XtNwatchUnread,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X#endif
X`7B"-xrefMarkRead",`09XtNxrefMarkRead,`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+xrefMarkRead",`09XtNxrefMarkRead,`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-nextReadsFirst",`09XtNnextReadsFirst,`09XrmoptionNoArg, (caddr_t) doff`
V7D,
X`7B"+nextReadsFirst",`09XtNnextReadsFirst,`09XrmoptionNoArg, (caddr_t) don`7
VD,
X`7D; `20
X#else
Xstatic XrmOptionDescRec optionList`5B`5D = `7B
X`7B"-addbindings",`09XtNaddBindings,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-addbuttonlist",`09XtNaddButtonList,`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-addpopuplist",`09XtNaddPopupList,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-allbindings",`09XtNallBindings,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-allbuttonlist",`09XtNallButtonList,`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-allpopuplist",`09XtNallPopupList,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-artbindings",`09XtNartBindings,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-artbuttonlist",`09XtNartButtonList,`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-artpopuplist",`09XtNartPopupList,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-artspecbuttonlist",`09XtNartSpecButtonList,`09XrmoptionSepArg,(caddr_t)
V NULL`7D,
X`7B"-authorfullname",`09XtNauthorFullName,`09XrmoptionNoArg, (caddr_t) doff`
V7D,
X`7B"+authorfullname",`09XtNauthorFullName,`09XrmoptionNoArg, (caddr_t) don`7
VD,
X`7B"-authorlength",`09XtNauthorLength,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-autoread",`09`09XtNautoRead,`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+autoread",`09`09XtNautoRead,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-autowrap",`09`09XtNautoWrap,`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+autowrap",`09`09XtNautoWrap,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-busyicon",`09`09XtNbusyIcon,`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+busyicon",`09`09XtNbusyIcon,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-busyiconname",`09XtNbusyIconName,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-busyiconpixmap",`09XtNbusyIconPixmap,`09XrmoptionSepArg,(caddr_t) NULL`
V7D,
X`7B"-calvin",`09`09XtNcalvin,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-cancelcount",`09XtNcancelCount,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-cc",`09`09`09XtNcc,`09`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+cc",`09`09`09XtNcc,`09`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-ccforward",`09`09XtNccForward,`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+ccforward",`09`09XtNccForward,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-compbreaklength",`09XtNcompBreakLength,`09XrmoptionSepArg,(caddr_t) NUL
VL`7D,
X`7B"-complinelength",`09XtNcompLineLength,`09XrmoptionSepArg,(caddr_t) NULL`
V7D,
X`7B"-comprows",`09`09XtNcompRows,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-confirm",`09`09XtNconfirm,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-deadletters",`09XtNdeadLetters,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-dumpcore",`09`09XtNdumpCore,`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+dumpcore",`09`09XtNdumpCore,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-defaultlines",`09XtNdefaultLines,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-delayedprint",`09XtNdelayedPrint,`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+delayedprint",`09XtNdelayedPrint,`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-displaylinecount",`09XtNdisplayLineCount,`09XrmoptionNoArg, (caddr_t) d
Voff`7D,
X`7B"+displaylinecount",`09XtNdisplayLineCount,`09XrmoptionNoArg, (caddr_t) d
Von`7D,
X#ifdef REALLY_USE_LOCALTIME
X`7B"-displaylocaltime",`09XtNdisplayLocalTime,`09XrmoptionNoArg, (caddr_t) d
Voff`7D,
X`7B"+displaylocaltime",`09XtNdisplayLocalTime,`09XrmoptionNoArg, (caddr_t) d
Von`7D,
X#endif
X`7B"-distribution",`09XtNdistribution,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-editorcommand",`09XtNeditorCommand,`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-executablesignatures",XtNexecutableSignatures,XrmoptionNoArg,(caddr_t)
V doff`7D,
X`7B"+executablesignatures",XtNexecutableSignatures,XrmoptionNoArg,(caddr_t)
V don`7D,
X`7B"-extramailheaders",`09XtNextraMailHeaders,`09XrmoptionNoArg, (caddr_t) d
Voff`7D,
X`7B"+extramailheaders",`09XtNextraMailHeaders,`09XrmoptionNoArg, (caddr_t) d
Von`7D,
X`7B"-hostname",`09`09XtNhostName,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-icongeometry",`09XtNiconGeometry,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-iconname",           XtNiconName, `09`09XrmoptionSepArg,(caddr_t) NULL`
V7D,
X`7B"-iconpixmap",`09`09XtNiconPixmap, `09`09XrmoptionSepArg,(caddr_t) NULL`7
VD,
X`7B"-ignorenewsgroups",`09XtNignoreNewsgroups,`09XrmoptionSepArg,(caddr_t) N
VULL`7D,
X`7B"-includecommand",`09XtNincludeCommand,`09XrmoptionSepArg,(caddr_t) NULL`
V7D,
X`7B"-includeheader",`09XtNincludeHeader,`09XrmoptionNoArg, (caddr_t) doff`7D
V,
X`7B"+includeheader",`09XtNincludeHeader,`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-includeprefix",`09XtNincludePrefix,`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-includesep",`09`09XtNincludeSep,`09`09XrmoptionNoArg, (caddr_t) doff`7D
V,
X`7B"+includesep",`09`09XtNincludeSep,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-info",`09`09XtNinfo,`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+info",`09`09XtNinfo,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-killfiles",`09`09XtNkillFiles,`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+killfiles",`09`09XtNkillFiles,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-layout",`09`09XtNlayout,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-leaveheaders",`09XtNleaveHeaders,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-localsignatures",`09XtNlocalSignatures,`09XrmoptionNoArg, (caddr_t) dof
Vf`7D,
X`7B"+localsignatures",`09XtNlocalSignatures,`09XrmoptionNoArg, (caddr_t) don
V`7D,
X`7B"-lockfile",`09`09XtNlockFile,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-maxlines",`09`09XtNmaxLines,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-mhpath",`09`09XtNmhPath,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-minlines",`09`09XtNminLines,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-newsrcfile",`09`09XtNnewsrcFile,`09`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-ngbindings",`09`09XtNngBindings,`09`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-ngbuttonlist",`09XtNngButtonList,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-ngpopuplist",`09XtNngPopupList,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-nntpserver",`09`09XtNnntpServer,`09`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-onlyshow",`09`09XtNonlyShow,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-organization",`09XtNorganization,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-pagearticles",`09XtNpageArticles,`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+pagearticles",`09XtNpageArticles,`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-personalname",`09XtNpersonalName,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-popupbutton",`09XtNpopupButton,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-pointerbackground",`09XtNpointerBackground,`09XrmoptionSepArg,(caddr_t)
V NULL`7D,
X`7B"-pointerforeground",`09XtNpointerForeground,`09XrmoptionSepArg,(caddr_t)
V NULL`7D,
X`7B"-printcommand",`09XtNprintCommand,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-replypath",`09`09XtNreplyPath,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-replyto",`09`09XtNreplyTo,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-resetsave",`09`09XtNresetSave,`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+resetsave",`09`09XtNresetSave,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-rescantime",`09`09XtNrescanTime,`09`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-retainkilled",`09XtNretainKilled,`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+retainkilled",`09XtNretainKilled,`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-retrylimit",`09`09XtNretryLimit,`09`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-retrypopupcount",`09XtNretryPopupCount,`09XrmoptionSepArg,(caddr_t) NUL
VL`7D,
X`7B"-retrypopuptimeout",`09XtNretryPopupTimeout,`09XrmoptionSepArg,(caddr_t)
V NULL`7D,
X`7B"-retrypause",`09`09XtNretryPause,`09`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-savedir",`09`09XtNsaveDir,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-savenewsrcfile",`09XtNsaveNewsrcFile,`09XrmoptionSepArg,(caddr_t) NULL`
V7D,
X`7B"-savemode",`09`09XtNsaveMode,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-savepostings",`09XtNsavePostings,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-savestring",`09`09XtNsaveString,`09`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-signaturefile",`09XtNsignatureFile,`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-signaturenotify",`09XtNsignatureNotify,`09XrmoptionNoArg, (caddr_t) dof
Vf`7D,
X`7B"+signaturenotify",`09XtNsignatureNotify,`09XrmoptionNoArg, (caddr_t) don
V`7D,
X`7B"-sortedsubjects",`09XtNsortedSubjects,`09XrmoptionNoArg, (caddr_t) doff`
V7D,
X`7B"+sortedsubjects",`09XtNsortedSubjects,`09XrmoptionNoArg, (caddr_t) don`7
VD,
X`7B"-stripheaders",`09XtNstripHeaders,`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-subjectlength",`09XtNsubjectLength,`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-subjectread",`09XtNsubjectRead,`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+subjectread",`09XtNsubjectRead,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-textlines",`09`09XtNtextLines,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-tmpdir",`09`09XtNtmpDir,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-toplines",`09`09XtNtopLines,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-unreadiconname",`09XtNunreadIconName,`09XrmoptionSepArg,(caddr_t) NULL`
V7D,
X`7B"-unreadiconpixmap",`09XtNunreadIconPixmap,`09XrmoptionSepArg,(caddr_t) N
VULL`7D,
X`7B"-updatenewsrc",`09XtNupdateNewsrc,`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+updatenewsrc",`09XtNupdateNewsrc,`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-usegadgets",`09`09XtNuseGadgets,`09`09XrmoptionNoArg, (caddr_t) doff`7D
V,
X`7B"+usegadgets",`09`09XtNuseGadgets,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-verbosekill",`09XtNverboseKill,`09`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+verbosekill",`09XtNverboseKill,`09`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-watchprogress",`09XtNwatchProgress,`09XrmoptionNoArg, (caddr_t) doff`7D
V,
X`7B"+watchprogress",`09XtNwatchProgress,`09XrmoptionNoArg, (caddr_t) don`7D,
X#ifdef WATCH
X`7B"-watchunread",`09XtNwatchUnread,`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X#endif
X`7B"-xrefmarkread",`09XtNxrefMarkRead,`09XrmoptionNoArg, (caddr_t) doff`7D,
X`7B"+xrefmarkread",`09XtNxrefMarkRead,`09XrmoptionNoArg, (caddr_t) don`7D,
X`7B"-nextreadsfirst",`09XtNnextReadsFirst,`09XrmoptionNoArg, (caddr_t) doff`
V7D,
X`7B"+nextreadsfirst",`09XtNnextReadsFirst,`09XrmoptionNoArg, (caddr_t) don`7
VD,
X`7D; `20
X#endif
X
Xstatic XrmOptionDescRec defOptionList`5B`5D = `7B
X`7B"+rv",`09`09`09"*reverseVideo",`09XrmoptionNoArg, (caddr_t) "off"`7D,
X`7B"+synchronous",`09"*synchronous",`09`09XrmoptionNoArg, (caddr_t) "off"`7D
V,
X`7B"-background",`09`09"*background",`09`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-bd",`09`09`09"*borderColor",`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-bg",`09`09`09"*background",`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-bordercolor",`09"*borderColor",`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-borderwidth",`09".borderWidth",`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-bw",`09`09`09".borderWidth",`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-display",`09`09".display",`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-fg",`09`09`09"*foreground",`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-fn",`09`09`09"*font",`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-font",`09`09"*font",`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-foreground",`09`09"*foreground",`09`09XrmoptionSepArg,(caddr_t) NULL`7D
V,
X`7B"-geometry",`09`09".geometry",`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-iconic",`09`09".iconic",`09`09XrmoptionNoArg, (caddr_t) "on"`7D,
X`7B"-name",`09`09".name",`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-reverse",`09`09"*reverseVideo",`09XrmoptionNoArg, (caddr_t) "on"`7D,
X`7B"-rv",`09`09`09"*reverseVideo",`09XrmoptionNoArg, (caddr_t) "on"`7D,
X`7B"-selectiontimeout",`09".selectionTimeout",`09XrmoptionSepArg,(caddr_t) N
VULL`7D,
X`7B"-synchronous",`09"*synchronous",`09`09XrmoptionNoArg, (caddr_t) "on"`7D,
X`7B"-title",`09`09".title",`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-xnllanguage",`09".xnlLanguage",`09`09XrmoptionSepArg,(caddr_t) NULL`7D,
X`7B"-xrm",`09`09NULL,`09`09`09XrmoptionResArg,(caddr_t) NULL`7D,
X`7D;
Xstatic void
Xusage(ac, av)
Xint ac;
Xchar **av;  /* program name */
X/*
X * print out the usage message
X *
X *   returns: void
X *  `20
X */
X`7B
X    int i;
X
X    (void) printf("Unknown options:");
X    for (i = 1; i <= ac - 1; i++) `7B
X`09if (index(av`5Bi`5D, ':') == NIL(char)) `7B
X`09    printf(" %s", av`5Bi`5D);
X`09`7D
X    `7D
X    printf("\n");
X    printf("usage: %s `5Boptions`5D `5B-display host:display`5D\n",
X`09`09app_resources.progName);
X    printf("   -addBindings\t\tAdd mode bindings\n");
X    printf("   -addButtonList\tList of Add mode buttons\n");
X    printf("   -addPopupList\tList of Add mode popup buttons\n");
X    printf("   -allBindings\t\tAll mode bindings\n");
X    printf("   -allButtonList\tList of All mode buttons\n");
X    printf("   -allPopupList\tList of All mode popup buttons\n");
X    printf("   -artBindings\t\tArticle mode bindings\n");
X    printf("   -artButtonList\tList of Article mode buttons (top box)\n");
X    printf("   -artPopupList\tList of Article mode popup buttons\n");
X    printf("   -artSpecButtonList\tList of Article mode buttons (bottom box)
V\n");
X    printf("   +/-authorFullName\tUse author's fullname in article list\n");
X    printf("   +/-autoRead\t\tRead first article when opening group\n");
X#ifdef MOTIF
X    printf("   +/-autoWrap\t\tWord wrap articles\n");
X#endif
X    printf("   +/-busyIcon\t\tInvert icon image when busy\n");
X    printf("   -busyIconName\tIcon name used when busy\n");
X    printf("   -busyIconPixmap\tIcon pixmap used when busy\n");
X    printf("   +/-cc\t\tInclude 'Cc: user' in replies\n");
X    printf("   +/-ccForward\t\tInclude 'Cc: user' in forwarded messages\n");
V   `20
X    printf("   -compBreakLength\tLength of line at which line wrapping begin
Vs\n");
X    printf("   -compLineLength\tLength of lines for article postings\n");
X    printf("   -compRows\t\tNumber of composition text rows\n");
X    printf("   -confirm\t\tTurn on/off confirmation boxes\n");
X    printf("   -deadLetters file\tFile to store failed postings/messages\n")
V;
X    printf("   -defaultLines number\tDefault number of lines above cursor\n"
V);
X    printf("   +/-delayedPrint\tDelay print file until exit\n");
X    printf("   +/-displayLineCount\tDisplay line count in the subject index\
Vn");
X#ifdef REALLY_USE_LOCALTIME
X    printf("   +/-displayLocalTime\tDisplay local time in the Date: field\n"
V);
X#endif
X    printf("   -distribution\tDefault distribution for messages\n");
X#ifdef DUMPCORE
X    printf("   +/-dumpCore\t\tDump core on error exit\n");
X#endif
X    printf("   -editorCommand\tEditor to use (defaults to the toolkit editor
V)\n");
X    printf("   +/-executableSignatures Execute signature file to get signatu
Vre text\n");
X    printf("   -hostName\t\tOverride your host's default name\n");
X    printf("   -iconGeometry +X+Y\tPosition of icon\n");
X    printf("   -ignoreNewsgroups\tRegexps of newsgroups to ignore\n");
X    printf("   +/-includeHeader\tInclude original article's header\n");
X    printf("   -includePrefix\tPrefix `5B\"%s\"`5D for included lines\n",
X`09   INCLUDEPREFIX);
X    printf("   +/-includeSep\tPut '>' in front of included lines\n");
X    printf("   +/-info\t\tPut all information in the message pane\n");
X    printf("   +/-killFiles\t\tTurn on/off the use of kill files\n");
X    printf("   -layout WxH+X+Y\tSize and position of window\n");
X    printf("   -leaveHeaders list\tHeaders to leave\n");
X    printf("   +/-localSignatures\tSearch for signature files as for local k
Vill files\n");
X    printf("   -lockFile\t\tname of the XRN lock file\n");
X#ifndef VMS
X    printf("   -mailer\t\tMailer to use\n");
X#endif
X    printf("   -maxLines number\tMaximum number of lines above cursor\n");
X    printf("   -minLines number\tMinimum number of lines above cursor\n");
X    printf("   -newsrcFile file\t.newsrc filename\n");
X    printf("   +/-nextReadsFirst\tNext Unread reads first unread article\n")
V;
X    printf("   -ngBindings\t\tNewsgroup mode bindings\n");
X    printf("   -ngButtonList\tList of Newsgroup mode buttons\n");
X    printf("   -ngPopupList\t\tList of Newsgroup mode popup buttons\n");
X    printf("   -nntpServer name\tNNTP server\n");
X    printf("   -onlyShow\t\tmark all but the last N articles in each group a
Vs read\n");
X    printf("   -organization\tName of your organization\n");
X#ifdef VMS
X    printf("   -personalName\t\tYour name\n");
X#endif
X    printf("   +/-pageArticles\tSpacebar scrolls the current article\n");
X    printf("   -pointerBackground color background color of mouse cursor\n")
V;
X    printf("   -pointerForeground color foreground color of mouse cursor\n")
V;
X    printf("   -popupButton\t\tButton for popup menus (2 or 3)\n");
X    printf("   -printCommand\tCommand to use to print out an article\n");
X    printf("   -replyPath\t\tProvide default path for mail replies\n");
X    printf("   -replyTo\t\tValue used for the Reply-To field\n");
X    printf("   -rescanTime\t\tIdle time before checking for new articles\n")
V;
X    printf("   +/-resetSave\t\treset the save dialog string on each posting\
Vn");
X    printf("   +/-retainKilled\tRetain killed articles in subject list\n");
X    printf("   -retryLimit\t\tNumber of times to retry failed connection\n")
V;
X    printf("   -retryPopupCount\tNumber of times to retry before allowing ab
Vort\n");
X    printf("   -retryPopupTimeout\tNumber of seconds to wait before continui
Vng\n");
X    printf("   -retryPause\t\tNumber of seconds between retries\n");
X    printf("   -saveDir directory\tDirectory for saving files\n");
X    printf("   -saveMode mode\tMethod of saving articles\n");
X    printf("   -saveNewsrcFile file\tSaved .newsrc filename\n");
X    printf("   -savePostings file\tFile to save postings/messages\n");
X    printf("   -saveString\t\tstring to use in the save dialog\n");
X    printf("   -signatureFile file\tSignature file for posting\n");
X    printf("   +/-signatureNotify\tNotify user which signature file is being
V used\n");
X    printf("   +/-sortedSubjects\tSort or do not sort the subjects\n");
X    printf("   -stripHeaders list\tHeaders to strip\n");
X    printf("   -subjectLength\tLength of subject lines\n");
X    printf("   +/-subjectRead\tChange default from next unread to subject ne
Vxt\n");
X    printf("   -textLines number\tNumber of lines used by the text window\n"
V);
X    printf("   -tmpDir\t\tTemporary article directory\n");
X    printf("   -topLines number\tNumber of lines used by the top window\n");
X    printf("   +/-unreadIconName\tIcon name used when unread articles\n");
X    printf("   -unreadIconPixmap\tIcon pixmap used when unread articles\n");
X    printf("   +/-updateNewsrc\tUpdate the .newsrc file each time a group is
V exited\n");
X    printf("   +/-useGadgets\tUse gadget buttons instead of widgets\n");
X    printf("   +/-verboseKill\tList subjects when killing articles\n");
X    printf("   +/-watchProgress\tWatch catch-up progress\n");
X#ifdef WATCH
X    printf("   -watchUnread\t\tList of news groups to monitor\n");
X#endif
X    printf("   +/-xrefMarkRead\tCrossref articles marked read\n");
X
X    ehErrorExitXRN("Unrecognized command - exiting.");
X`7D
X
Xstatic int
XstrncmpIgnoringCase(str1, str2, length)
Xchar *str1;
Xchar *str2;
Xint  length;
X`7B
X    register int i, diff;
X    for (i = 0; i < length; i++, str1++, str2++) `7B
X`09diff = ((*str1 >= 'A' && *str1 <= 'Z') ? (*str1 + 'a' - 'A') : *str1) -
X`09       ((*str2 >= 'A' && *str2 <= 'Z') ? (*str2 + 'a' - 'A') : *str2);
X`09if (diff) return diff;
X    `7D
X    return 0;
X`7D
X
Xstatic void
XCvtStringToSortedSubjects(args, num_args, fromVal, toVal)
XXrmValuePtr args;
XCardinal *num_args;
XXrmValuePtr fromVal;
XXrmValuePtr toVal;
X`7B
X
X    char *ptr;
X    static int result;
X    result = -1;
X
X    if (*num_args != 0) `7B
X`09XtWarningMsg("cvtStringToSortedSubjects", "wrongParameters",
X`09`09     "conversionError",
X`09`09     "String to Sorted Subjects conversion needs no extra arguments",
X`09`09      NULL, NULL);
X    `7D
X
X    ptr = (char *) fromVal->addr;
X    if ((strncmpIgnoringCase("off", ptr, 3) == 0) `7C`7C
X`09(strncmpIgnoringCase("none", ptr, 4) == 0) `7C`7C
X`09(strncmpIgnoringCase("unsorted", ptr, 8) == 0) `7C`7C
X`09(strncmpIgnoringCase("false", ptr, 5) == 0)) `7B
X`09result = UNSORTED;
X    `7D else `7B
X`09if ((strncmpIgnoringCase("on", ptr, 2) == 0) `7C`7C
X`09    (strncmpIgnoringCase("true", ptr, 6) == 0) `7C`7C
X`09    (strncmpIgnoringCase("sorted", ptr, 6) == 0) `7C`7C
X`09    (strncmpIgnoringCase("article", ptr, 7) == 0) `7C`7C
X`09    (strncmpIgnoringCase("subject", ptr, 7) == 0)) `7B
X`09    result = ARTICLE_SORTED;
X`09`7D else `7B
X`09    if (strncmpIgnoringCase("strict", ptr, 6) == 0) `7B
X`09`09result = STRICT_SORTED;
X`09    `7D else `7B
X`09`09if (strncmpIgnoringCase("thread", ptr, 6) == 0) `7B
X`09`09    result = THREAD_SORTED;
X`09`09`7D
X`09    `7D
X`09`7D
X    `7D
X    if (result != -1) `7B
X`09toVal->size = sizeof(int);
X`09toVal->addr = (caddr_t) &result;
X    `7D else `7B
X`09toVal->size = 0;
X`09toVal->addr = NULL;
X#ifdef MOTIF
X`09XtStringConversionWarning((char *) fromVal->addr, "SortedSubjects");
X#else
X`09printf("Can't convert string %s to subject sort type\n",
X`09`09(char *) fromVal->addr);
X#endif
X    `7D
X`7D
X
Xextern XrmDatabase XtDatabase();
Xstatic XrmDatabase`09xrmDB;
Xstatic XrmDatabase`09sysDB;
Xchar   customName`5B512`5D;
X
XWidget
XXrnInitialize(argc, argv)
Xunsigned int argc;
Xchar **argv;
X/*
X * initialize the toolkit, parse the command line, and handle the Xdefaults
X *
X *   returns: top level widget
X *
X */
X`7B
X    Widget widget;
X    int uargc;
X    char *ptr;
X    static Arg shell_args`5B`5D = `7B
X`09`7BXtNinput, (XtArgVal)True`7D,
X`09`7BXtNiconName, (XtArgVal) NULL`7D,
X`09`7BXtNtitle, (XtArgVal) NULL`7D,
X    `7D;
X
X#ifdef BSD_BFUNCS
X    bzero((char *) &app_resources, sizeof(app_resources));
X#else
X    memset((char *) &app_resources, 0, sizeof(app_resources));
X#endif
X
X    /* set up the program name */
X#ifndef VMS
X    if ((ptr = rindex(argv`5B0`5D, '/')) == NIL(char)) `7B
X`09app_resources.progName = XtNewString(argv`5B0`5D);
X    `7D else `7B
X`09ptr++;
X`09app_resources.progName = XtNewString(ptr);
X    `7D
X    customName`5B0`5D = '\0';
X#ifdef USE_XAPPLRESDIR
X/*
X * I've had several complaints about this not working
X * because XAPPLRESDIR isn't a simple directory, or isn't
X * writable. So .. it's gone (but not forgotten).
X */
X    if ((ptr = getenv("XAPPLRESDIR")) != NULL) `7B
X`09strcpy(customName, ptr);
X    `7D else `7B
X`09strcpy(customName, "`7E");
X    `7D
X#else /* USE_XAPPLRESDIR */
X    strcpy(customName, "`7E");
X#endif /* USE_XAPPLRESDIR */
X
X#ifdef MOTIF
X    strcat(customName, "/.mxrn");
X#else
X    strcat(customName, "/.dxrn");
X#endif
X    ptr = utNameExpand(customName);
X    strcpy(customName, ptr);   `20
X#else /* VMS */
X#ifdef MOTIF
X    app_resources.progName = XtNewString("mxrn");
X    (void) strcpy(argv`5B0`5D, "mxrn");
X    (void) strcpy(customName, "decw$user_defaults:mxrn.dat");
X#else
X    app_resources.progName = XtNewString("dxrn");
X    (void) strcpy(argv`5B0`5D, "dxrn");
X    (void) strcpy(customName, "decw$user_defaults:dxrn.dat");
X#endif
X#endif
X
X    StringPool = NULL;
X
X    XrmInitialize();
X#ifdef MOTIF
X    widget = XtInitialize(app_resources.progName, "mxrn",
X#else
X    widget = XtInitialize(app_resources.progName, "dxrn",
X#endif
X`09`09`09  defOptionList, XtNumber(defOptionList),
X`09`09`09  (int *) &argc, argv);
X
X    XtAddConverter(XtRString, XtRSortedSubjects, CvtStringToSortedSubjects,
X`09(XtConvertArgList) NULL, (Cardinal) 0);
X    xrmDB = XrmGetFileDatabase(customName);
X    sysDB = XtDatabase(XtDisplay(widget));
X    if (sysDB != NULL) `7B
X#ifdef MOTIF
X`09XrmPutStringResource(&sysDB, "*XmText*font",
X`09`09"*-*-*-Medium-R-Normal-*-*-120-*-*-M-*-ISO8859-1");
X`09XrmPutStringResource(&sysDB, "*XmText*fontList",
X`09`09"*-*-*-Medium-R-Normal-*-*-120-*-*-M-*-ISO8859-1");
X`09XrmPutStringResource(&sysDB, "*index*fontList",
X`09`09"*-*-*-Medium-R-Normal-*-*-120-*-*-M-*-ISO8859-1");
X#else
X`09XrmPutStringResource(&sysDB, "*headerText*font",
X`09`09"*-*-*-Medium-R-Normal-*-*-120-*-*-M-*-ISO8859-1");
X`09XrmPutStringResource(&sysDB, "*composeText*font",
X`09`09"*-*-*-Medium-R-Normal-*-*-120-*-*-M-*-ISO8859-1");
X`09XrmPutStringResource(&sysDB, "*text*font",
X`09`09"*-*-*-Medium-R-Normal-*-*-120-*-*-M-*-ISO8859-1");
X`09XrmPutStringResource(&sysDB, "*index*font",
X`09`09"*-*-*-Medium-R-Normal-*-*-120-*-*-M-*-ISO8859-1");
X#endif
X    `7D
X    if (xrmDB != NULL && sysDB != NULL) `7B
X`09XrmMergeDatabases(xrmDB, &sysDB);
X    `7D
X
X    /*
X     * Parse the remaining command line arguments
X     */
X
X    uargc = argc;
X    XrmParseCommand(&sysDB, optionList, XtNumber(optionList),
X`09app_resources.progName, &uargc, argv);
X    argc = uargc;
X
X    if (argc > 1) `7B
X`09usage(argc, argv);
X    `7D
X
X#if defined(__DATE__) && defined(WANT_DATE)
X#ifdef MOTIF
X    (void) sprintf(title, "mxrn - version %s (compiled on %s)",
X`09`09   XRN_VERSION, __DATE__);
X#else
X    (void) sprintf(title, "dxrn - version %s (compiled on %s)",
X`09`09   XRN_VERSION, __DATE__);
X#endif
X#else
X#ifdef MOTIF
X    (void) sprintf(title, "mxrn - version %s",
X`09`09   XRN_VERSION);
X#else
X    (void) sprintf(title, "dxrn - version %s",
X`09`09   XRN_VERSION);
X#endif
X#endif
X
X    /* get the resources needed by xrn itself */
X    XtGetApplicationResources(widget, (caddr_t) &app_resources,
X`09`09`09      resources, XtNumber(resources), 0, 0);
X
X    /*
X     * Convert empty strings to default values
X     */
X
X    fixupString(nntpServer);
X    fixupString(leaveHeaders);
X    fixupString(stripHeaders);
X#ifdef VMS
X    fixupString(personalName);
X#endif
X    fixupString(confirm);
X    fixupString(editorCommand);
X    fixupString(organization);
X    fixupString(distribution);
X    fixupString(replyTo);
X    fixupString(printCommand);
X    fixupString(hostName);
X    fixupString(replyPath);
X#ifdef WATCH
X    fixupString(watchList);
X#endif
X
X    /*`20
X     * check and set the lock file - must be after the application resources
X     * are processed
X     */
X    checkLock();
X
X    /* set up the titles */
X    shell_args`5B1`5D.value = (XtArgVal) app_resources.iconName;
X    shell_args`5B2`5D.value = (XtArgVal) app_resources.title;
X
X    XtSetValues(widget, shell_args, XtNumber(shell_args));
X
X    /* article saving mode */
X
X    app_resources.saveMode = 0;
X    if (utSubstring(app_resources.strSaveMode, "mailbox") == 1) `7B
X`09app_resources.saveMode `7C= MAILBOX_SAVE;
X    `7D else `7B
X`09app_resources.saveMode `7C= NORMAL_SAVE;
X    `7D
X    if (utSubstring(app_resources.strSaveMode, "noheaders") == 1) `7B
X`09app_resources.saveMode `7C= NOHEADERS_SAVE;
X    `7D else `7B
X`09app_resources.saveMode `7C= HEADERS_SAVE;
X    `7D
X
X    if (utSubstring(app_resources.strSaveMode, "subdirs") == 1) `7B
X`09app_resources.saveMode `7C= SUBDIRS_SAVE;
X    `7D else if (utSubstring(app_resources.strSaveMode, "onedir") == 1) `7B
X`09app_resources.saveMode `7C= ONEDIR_SAVE;
X    `7D else `7B
X`09app_resources.saveMode `7C= SAVE_DIR_DEFAULT;
X    `7D
X
X#define ariN app_resources.ignoreNewsgroups
X#define ariNL app_resources.ignoreNewsgroupsList
X
X    if (ariN) `7B
X`09char *str = XtNewString(ariN);
X`09int i = 1;
X`09
X`09if (! (strtok(str, ", \n\t"))) `7B
X`09    XtFree(str);
X`09    goto no_ignored_newsgroups;
X`09`7D
X`09while (strtok((char *) 0, ", \n\t")) `7B
X`09    i++;
X`09`7D
X
X`09ariNL = (char **) XtMalloc(sizeof(char *) * (i + 1));
X`09if (! ariNL) `7B
X`09    ehErrorExitXRN("out of memory");
X`09`7D
X
X`09XtFree(str);
X
X`09for (i = 0, str = strtok(ariN, ", \n\t"); str;
X`09    str = strtok((char *) 0, ", \n\t")) `7B
X`09    ariNL`5Bi++`5D = str;
X#ifdef DEBUG
X`09    fprintf(stderr, "Ignoring \"%s\" groups.\n", str);
X#endif
X`09`7D
X`09ariNL`5Bi++`5D = 0;
X    `7D
X    else `7B
Xno_ignored_newsgroups:
X`09ariNL = (char **) XtMalloc(sizeof(char *));
X`09ariNL`5B0`5D = 0;
X    `7D
X
X#undef ariN
X#undef ariNL
X
X    /* header stripping mode */
X
X    /* STRIP_HEADERS with a NIL table will leave all headers (nothing to str
Vip) */
X    app_resources.headerTree = avl_init_table(strcmp);
X    if (! app_resources.headerTree) `7B
X`09 ehErrorExitXRN("out of memory");
X    `7D
X    app_resources.headerMode = STRIP_HEADERS;
X
X    /*
X     * A leaveHeaders value of "all" cancels leaveHeaders, and a
X     * stripHeaders value of "none" cancels stripHeaders.
X     */
X
X    if (app_resources.leaveHeaders) `7B
X`09utDowncase(app_resources.leaveHeaders);
X`09if (! strcmp(app_resources.leaveHeaders, "all"))
X`09    app_resources.leaveHeaders = NIL(char);
X    `7D
X    if (app_resources.stripHeaders) `7B
X`09utDowncase(app_resources.stripHeaders);
X`09if (! strcmp(app_resources.stripHeaders, "none"))
X`09    app_resources.stripHeaders = NIL(char);
X    `7D
X
X    if ((app_resources.leaveHeaders != NIL(char)) &&
X`09(app_resources.stripHeaders != NIL(char))) `7B
X`09ehErrorExitXRN("Only one of 'stripHeaders, leaveHeaders' allowed\n");
X     `7D `20
X
X    if (app_resources.leaveHeaders != NIL(char)) `7B
X`09char *p, *token;
X`09
X`09app_resources.headerMode = LEAVE_HEADERS;
X`09p = app_resources.leaveHeaders;
X`09while ((token = strtok(p, ", \t\n")) != NIL(char)) `7B
X`09    utDowncase(token);
X`09    if (avl_insert(app_resources.headerTree, token, (char *) 1) < 0) `7B
X`09`09 ehErrorExitXRN("out of memory");
X`09    `7D
X`09    p = NIL(char);
X`09`7D
X`09
X    `7D else if (app_resources.stripHeaders != NIL(char)) `7B
X`09char *p, *token;
X`09
X`09app_resources.headerMode = STRIP_HEADERS;
X`09p = app_resources.stripHeaders;
X`09while ((token = strtok(p, ", \t\n")) != NIL(char)) `7B
X`09    utDowncase(token);
X`09    if (avl_insert(app_resources.headerTree, token, (char *) 1) < 0) `7B
X`09`09 ehErrorExitXRN("out of memory");
X`09    `7D
X`09    p = NIL(char);
X`09`7D
X    `7D
X
X    /* confirm boxes */
X
X    app_resources.confirmMode = 0;
X
X    if (app_resources.confirm != NIL(char)) `7B
X`09char *p, *token;
X
X`09p = app_resources.confirm;
X`09while ((token = strtok(p, ", \t\n")) != NIL(char)) `7B
X`09    if (strcmp(token, "ngQuit") == 0) `7B
X`09`09app_resources.confirmMode `7C= NG_QUIT;
X`09    `7D else if (strcmp(token, "ngExit") == 0) `7B
X`09`09app_resources.confirmMode `7C= NG_EXIT;
X`09    `7D else if (strcmp(token, "ngCatchUp") == 0) `7B
X`09`09app_resources.confirmMode `7C= NG_CATCHUP;
X`09    `7D else if (strcmp(token, "artCatchUp") == 0) `7B
X`09`09app_resources.confirmMode `7C= ART_CATCHUP;
X`09    `7D else if (strcmp(token, "artFedUp") == 0) `7B
X`09`09app_resources.confirmMode `7C= ART_FEDUP;
X`09    `7D else if (strcmp(token, "ngUnsub") == 0) `7B
X`09`09app_resources.confirmMode `7C= NG_UNSUBSCRIBE;
X`09    `7D else if (strcmp(token, "artUnsub") == 0) `7B
X`09`09app_resources.confirmMode `7C= ART_UNSUBSCRIBE;
X`09    `7D else if (strcmp(token, "artEndAction") == 0) `7B
X`09`09app_resources.confirmMode `7C= ART_ENDACTION;
X`09    `7D else if (strcmp(token, "artSave") == 0) `7B
X`09`09app_resources.confirmMode `7C= ART_SAVE;
X`09    `7D else if (strcmp(token, "post") == 0) `7B
X`09`09app_resources.confirmMode `7C= COMP_POST;
X`09    `7D else `7B
X`09`09mesgPane(XRN_SERIOUS, "unknown confirm button: %s", token);
X`09    `7D
X`09    p = NIL(char);
X`09`7D
X    `7D
X
X    /* temporary directory */
X
X    if (app_resources.tmpDir == NIL(char)) `7B
X`09char *p = getenv("TMPDIR");
X
X`09if (p == NIL(char)) `7B
X`09    /*`20
X`09     * XXX added to deal with a possible compiler problem on
X`09     * the IBM RT running AOS using the hc2.1s compiler
X`09     * (reported by Jay Ford <jnford@jay.weeg.uiowa.edu>).
X`09     */
X`09    char *tmp_ptr = TEMPORARY_DIRECTORY;
X`09    app_resources.tmpDir = XtNewString(tmp_ptr);
X`09`7D else `7B
X`09    app_resources.tmpDir = XtNewString(p);
X`09`7D
X    `7D
X
X#ifdef VMS
X    app_resources.tmpDir = XtNewString(utTildeExpand(app_resources.tmpDir));
X#else
X    `7B
X`09char tmpDir`5B128`5D, *p;
X`09strcpy(tmpDir, utTildeExpand(app_resources.tmpDir));
X`09p = tmpDir + strlen(tmpDir) - 1;
X`09if (*p != '/') `7B
X`09    *(++p) = '/';
X`09    *(++p) = '\0';
X`09`7D
X`09app_resources.tmpDir = XtNewString(tmpDir);
X    `7D
X#endif
X
X    /* reply path */
X
X    if (app_resources.replyPath == NIL(char)) `7B
X`09char *p = getenv("REPLYPATH");
X
X`09if (p != NIL(char)) `7B
X`09    app_resources.replyPath = XtNewString(p);
X`09`7D
X    `7D
X    /* top list line limits */
X    if (app_resources.topLines < 3)
X`09app_resources.topLines = 3;
X    if (app_resources.minLines == -1)
X`09app_resources.minLines = app_resources.topLines/2;
X
X    if (app_resources.maxLines == -1)
X`09app_resources.maxLines = app_resources.topLines/2;
X
X    if (app_resources.textLines < 3)
X`09app_resources.textLines = 3;
X
X    if (app_resources.popupButton != 2 &&
X        app_resources.popupButton != 3) `7B
X#ifdef MOTIF
X`09printf("Invalid popup button, default 3 used.\n");
X        app_resources.popupButton = 3;
X#else
X`09printf("Invalid popup button, default 2 used.\n");
X        app_resources.popupButton = 2;
X#endif
X    `7D
X#ifdef VMS
X    ptr = getenv("FULLNAME");
X    if (ptr != NULL) `7B
X`09app_resources.personalName = XtNewString(ptr);
X    `7D
X#endif
X
X    /* delete empty editorCommand */
X    if (app_resources.editorCommand != NIL(char) &&
X       *app_resources.editorCommand == '\0') `7B
X`09app_resources.editorCommand = NIL(char);
X    `7D
X    /* line breaking */
X
X    if (app_resources.editorCommand != NIL(char)) `7B
X`09app_resources.breakLength = 0;
X`09app_resources.lineLength = 0;
X    `7D
X
X    if (app_resources.authorLength == 0) `7B
X`09if (app_resources.displayLineCount)
X`09    app_resources.authorLength = 20;
X`09else
X`09    app_resources.authorLength = 24;
X    `7D
X
X    if (app_resources.subjectLength == 0) `7B
X`09if (app_resources.displayLineCount)
X`09    app_resources.subjectLength = 52;
X`09else
X`09    app_resources.subjectLength = 53;
X    `7D
X    return widget;
X`7D
$ CALL UNPACK RESOURCES.C;107 621359191
$ create 'f'
X#ifndef RESOURCES_H
X#define RESOURCES_H
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/resources.h,v 1.6 19
V93/02/04 18:22:24 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X
X#ifndef _XtIntrinsic_h
X#include <X11/Intrinsic.h>
X#endif
X
X#ifndef AVL_H
X#include "avl.h"
X#endif
X
X/*
X * resources.h: resources for xrn
X */
X
X
Xtypedef struct `7B
X    char *progName;
X    char* version;
X    avl_tree *headerTree;
X    int headerMode;
X    char *mainLayout;
X    char *iconGeometry;
X    char *iconName;
X    Pixmap iconPixmap;
X    char *busyIconName;
X    Pixmap busyIconPixmap;
X    char *unreadIconName;
X    Pixmap unreadIconPixmap;
X    char *title;
X    Pixel pointer_foreground;
X    Pixel pointer_background;
X    char *saveDir;
X    char *expandedSaveDir;
X    char *newsrcFile;
X    char *saveNewsrcFile;
X    char *signatureFile;
X    Boolean signatureNotify;
X    Boolean executableSignatures;
X    Boolean localSignatures;
X    char *nntpServer;
X    int topLines;
X    int saveMode;
X    char *leaveHeaders;
X    char *stripHeaders;
X    char *savePostings;
X    char *deadLetters;
X    int minLines;
X    int maxLines;
X    int defaultLines;
X    int cancelCount;
X#ifndef VMS
X    char *mailer;
X#else
X    char *personalName;
X#endif
X    Boolean iconOnStart;
X    Boolean subjectRead;
X    Boolean info;
X    char *tmpDir;
X    char *confirm;
X    int confirmMode;
X    Boolean killFiles;
X    Boolean calvin;
X    char *editorCommand;
X    char *includeCommand;
X    char *strSaveMode;
X    char *organization;
X    char *distribution;
X    char *replyTo;
X    Boolean includeHeader;
X    Boolean extraMailHeaders;
X    char* includePrefix;
X#ifdef WATCH
X    char *watchList;
X#endif
X    Boolean includeSep;
X    Boolean updateNewsrc;
X    int lineLength;
X    int breakLength;
X    int rescanTime;
X    Boolean pageArticles;
X    int sortedSubjects;
X    int defSortedSubjects;
X    char *addButtonList;
X    char *ngButtonList;
X    char *allButtonList;
X    char *artButtonList;
X    char *artSpecButtonList;
X    char *printCommand;
X    char *ngBindings;
X    char *allBindings;
X    char *addBindings;
X    char *artBindings;
X    char *addPopupList;
X    char *ngPopupList;
X    char *allPopupList;
X    char *artPopupList;
X    int  popupButton;
X    char *hostName;
X    char *replyPath;
X    Boolean dumpCore;
X    Boolean verboseKill;
X    Boolean cc;
X    Boolean ccForward;
X    Boolean retainKilledArticles;
X    Boolean useGadgets;
X    Boolean autoRead;
X    Boolean authorFullName;
X#ifdef REALLY_USE_LOCALTIME
X    Boolean displayLocalTime;
X#endif
X    Boolean displayLineCount;
X    Boolean resetSave;
X    char *saveString;
X    char *lockFile;
X    char *mhPath;
X    int onlyShow;
X    Boolean autoWrap;
X    int subjectLength;
X    int authorLength;
X    int retryPopupCount;
X    int retryPopupTimeout;
X    int retryPause;
X    int retryLimit;
X    int composeRows;
X    Boolean busyIcon;
X    Boolean watchProgress;
X    Boolean delayedPrint;
X    Boolean xrefMarkRead;
X    char *ignoreNewsgroups;
X    char **ignoreNewsgroupsList;
X    Boolean nextReadsFirst;
X    Boolean twoWindows;
X    char *artLayout;
X    char *compLayout;
X    char *indexLayout;
X    int textLines;
X    Boolean unsubNewGroups;
X`7D app_resourceRec, *app_res;
X
Xextern app_resourceRec app_resources;
X
Xextern Widget XrnInitialize _ARGUMENTS((unsigned int,char **));
X
X/* article save options */
X
X#define MAILBOX_SAVE   0x01
X#define NORMAL_SAVE    0x02
X#define HEADERS_SAVE   0x10
X#define NOHEADERS_SAVE 0x20
X
X#define ONEDIR_SAVE    0x100
X#define SUBDIRS_SAVE   0x200
X
X/* confirm box options */
X
X#define NG_EXIT 0x01
X#define NG_QUIT 0x02
X#define NG_CATCHUP 0x04
X#define NG_UNSUBSCRIBE 0x08
X#define ART_CATCHUP 0x10
X#define ART_PART_CATCHUP 0x20
X#define ART_UNSUBSCRIBE 0x40
X#define ART_FEDUP 0x80
X#define ART_ENDACTION 0x100
X#define ART_SAVE 0x200
X#define COMP_POST 0x400
X
X/* header options */
X
X#define STRIP_HEADERS  0
X#define LEAVE_HEADERS  1
X
X#endif /* RESOURCES_H */
$ CALL UNPACK RESOURCES.H;45 1414111105
$ create 'f'
X`0D
X`0D
XNetwork Working Group                      Brian Kantor (U.C. San Diego)`0D
XRequest for Comments: 977                   Phil Lapsley (U.C. Berkeley)`0D
X                                                           February 1986`0D
X`0D
X                     Network News Transfer Protocol`0D
X                                    `0D
X                A Proposed Standard for the Stream-Based`0D
X                          Transmission of News`0D
X`0D
XStatus of This Memo`0D
X`0D
X   NNTP specifies a protocol for the distribution, inquiry, retrieval,`0D
X   and posting of news articles using a reliable stream-based`0D
X   transmission of news among the ARPA-Internet community.  NNTP is`0D
X   designed so that news articles are stored in a central database`0D
X   allowing a subscriber to select only those items he wishes to read.`0D
X   Indexing, cross-referencing, and expiration of aged messages are also`0D
X   provided. This RFC suggests a proposed protocol for the ARPA-Internet`0D
X   community, and requests discussion and suggestions for improvements.`0D
X   Distribution of this memo is unlimited.`0D
X`0D
X1.  Introduction`0D
X`0D
X   For many years, the ARPA-Internet community has supported the`0D
X   distribution of bulletins, information, and data in a timely fashion`0D
X   to thousands of participants.  We collectively refer to such items of`0D
X   information as "news".  Such news provides for the rapid`0D
X   dissemination of items of interest such as software bug fixes, new`0D
X   product reviews, technical tips, and programming pointers, as well as`0D
X   rapid-fire discussions of matters of concern to the working computer`0D
X   professional. News is very popular among its readers.`0D
X`0D
X   There are popularly two methods of distributing such news: the`0D
X   Internet method of direct mailing, and the USENET news system.`0D
X`0D
X1.1.  Internet Mailing Lists`0D
X`0D
X   The Internet community distributes news by the use of mailing lists.`0D
X   These are lists of subscriber's mailbox addresses and remailing`0D
X   sublists of all intended recipients.  These mailing lists operate by`0D
X   remailing a copy of the information to be distributed to each`0D
X   subscriber on the mailing list.  Such remailing is inefficient when a`0D
X   mailing list grows beyond a dozen or so people, since sending a`0D
X   separate copy to each of the subscribers occupies large quantities of`0D
X   network bandwidth, CPU resources, and significant amounts of disk`0D
X   storage at the destination host.  There is also a significant problem`0D
X   in maintenance of the list itself: as subscribers move from one job`0D
X   to another; as new subscribers join and old ones leave; and as hosts`0D
X   come in and out of service.`0D
X`0D
X`0D
X`0D
X`0D
XKantor & Lapsley                                                `5BPage 1`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X1.2.  The USENET News System`0D
X`0D
X   Clearly, a worthwhile reduction of the amount of these resources used`0D
X   can be achieved if articles are stored in a central database on the`0D
X   receiving host instead of in each subscriber's mailbox. The USENET`0D
X   news system provides a method of doing just this.  There is a central`0D
X   repository of the news articles in one place (customarily a spool`0D
X   directory of some sort), and a set of programs that allow a`0D
X   subscriber to select those items he wishes to read.  Indexing,`0D
X   cross-referencing, and expiration of aged messages are also provided.`0D
X`0D
X1.3.  Central Storage of News`0D
X`0D
X   For clusters of hosts connected together by fast local area networks`0D
X   (such as Ethernet), it makes even more sense to consolidate news`0D
X   distribution onto one (or a very few) hosts, and to allow access to`0D
X   these news articles using a server and client model.  Subscribers may`0D
X   then request only the articles they wish to see, without having to`0D
X   wastefully duplicate the storage of a copy of each item on each host.`0D
X`0D
X1.4.  A Central News Server`0D
X`0D
X   A way to achieve these economies is to have a central computer system`0D
X   that can provide news service to the other systems on the local area`0D
X   network.  Such a server would manage the collection of news articles`0D
X   and index files, with each person who desires to read news bulletins`0D
X   doing so over the LAN.  For a large cluster of computer systems, the`0D
X   savings in total disk space is clearly worthwhile.  Also, this allows`0D
X   workstations with limited disk storage space to participate in the`0D
X   news without incoming items consuming oppressive amounts of the`0D
X   workstation's disk storage.`0D
X`0D
X   We have heard rumors of somewhat successful attempts to provide`0D
X   centralized news service using IBIS and other shared or distributed`0D
X   file systems.  While it is possible that such a distributed file`0D
X   system implementation might work well with a group of similar`0D
X   computers running nearly identical operating systems, such a scheme`0D
X   is not general enough to offer service to a wide range of client`0D
X   systems, especially when many diverse operating systems may be in use`0D
X   among a group of clients.  There are few (if any) shared or networked`0D
X   file systems that can offer the generality of service that stream`0D
X   connections using Internet TCP provide, particularly when a wide`0D
X   range of host hardware and operating systems are considered.`0D
X`0D
X   NNTP specifies a protocol for the distribution, inquiry, retrieval,`0D
X   and posting of news articles using a reliable stream (such as TCP)`0D
X   server-client model. NNTP is designed so that news articles need only`0D
X`0D
X`0D
XKantor & Lapsley                                                `5BPage 2`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X   be stored on one (presumably central) host, and subscribers on other`0D
X   hosts attached to the LAN may read news articles using stream`0D
X   connections to the news host.`0D
X`0D
X   NNTP is modelled upon the news article specifications in RFC 850,`0D
X   which describes the USENET news system.  However, NNTP makes few`0D
X   demands upon the structure, content, or storage of news articles, and`0D
X   thus we believe it easily can be adapted to other non-USENET news`0D
X   systems.`0D
X`0D
X   Typically, the NNTP server runs as a background process on one host,`0D
X   and would accept connections from other hosts on the LAN.  This works`0D
X   well when there are a number of small computer systems (such as`0D
X   workstations, with only one or at most a few users each), and a large`0D
X   central server.`0D
X`0D
X1.5.  Intermediate News Servers`0D
X`0D
X   For clusters of machines with many users (as might be the case in a`0D
X   university or large industrial environment), an intermediate server`0D
X   might be used.  This intermediate or "slave" server runs on each`0D
X   computer system, and is responsible for mediating news reading`0D
X   requests and performing local caching of recently-retrieved news`0D
X   articles.`0D
X`0D
X   Typically, a client attempting to obtain news service would first`0D
X   attempt to connect to the news service port on the local machine.  If`0D
X   this attempt were unsuccessful, indicating a failed server, an`0D
X   installation might choose to either deny news access, or to permit`0D
X   connection to the central "master" news server.`0D
X`0D
X   For workstations or other small systems, direct connection to the`0D
X   master server would probably be the normal manner of operation.`0D
X`0D
X   This specification does not cover the operation of slave NNTP`0D
X   servers.  We merely suggest that slave servers are a logical addition`0D
X   to NNTP server usage which would enhance operation on large local`0D
X   area networks.`0D
X`0D
X1.6.  News Distribution`0D
X`0D
X   NNTP has commands which provide a straightforward method of`0D
X   exchanging articles between cooperating hosts. Hosts which are well`0D
X   connected on a local area or other fast network and who wish to`0D
X   actually obtain copies of news articles for local storage might well`0D
X   find NNTP to be a more efficient way to distribute news than more`0D
X   traditional transfer methods (such as UUCP).`0D
X`0D
X`0D
XKantor & Lapsley                                                `5BPage 3`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X   In the traditional method of distributing news articles, news is`0D
X   propagated from host to host by flooding - that is, each host will`0D
X   send all its new news articles on to each host that it feeds.  These`0D
X   hosts will then in turn send these new articles on to other hosts`0D
X   that they feed.  Clearly, sending articles that a host already has`0D
X   obtained a copy of from another feed (many hosts that receive news`0D
X   are redundantly fed) again is a waste of time and communications`0D
X   resources, but for transport mechanisms that are single-transaction`0D
X   based rather than interactive (such as UUCP in the UNIX-world <1>),`0D
X   distribution time is diminished by sending all articles and having`0D
X   the receiving host simply discard the duplicates.  This is an`0D
X   especially true when communications sessions are limited to once a`0D
X   day.`0D
X`0D
X   Using NNTP, hosts exchanging news articles have an interactive`0D
X   mechanism for deciding which articles are to be transmitted.  A host`0D
X   desiring new news, or which has new news to send, will typically`0D
X   contact one or more of its neighbors using NNTP.  First it will`0D
X   inquire if any new news groups have been created on the serving host`0D
X   by means of the NEWGROUPS command.  If so, and those are appropriate`0D
X   or desired (as established by local site-dependent rules), those new`0D
X   newsgroups can be created.`0D
X`0D
X   The client host will then inquire as to which new articles have`0D
X   arrived in all or some of the newsgroups that it desires to receive,`0D
X   using the NEWNEWS command.  It will receive a list of new articles`0D
X   from the server, and can request transmission of those articles that`0D
X   it desires and does not already have.`0D
X`0D
X   Finally, the client can advise the server of those new articles which`0D
X   the client has recently received.  The server will indicate those`0D
X   articles that it has already obtained copies of, and which articles`0D
X   should be sent to add to its collection.`0D
X`0D
X   In this manner, only those articles which are not duplicates and`0D
X   which are desired are transferred.`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
XKantor & Lapsley                                                `5BPage 4`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X2.  The NNTP Specification`0D
X`0D
X2.1.  Overview`0D
X`0D
X   The news server specified by this document uses a stream connection`0D
X   (such as TCP) and SMTP-like commands and responses.  It is designed`0D
X   to accept connections from hosts, and to provide a simple interface`0D
X   to the news database.`0D
X`0D
X   This server is only an interface between programs and the news`0D
X   databases. It does not perform any user interaction or presentation-`0D
X   level functions. These "user-friendly" functions are better left to`0D
X   the client programs, which have a better understanding of the`0D
X   environment in which they are operating.`0D
X`0D
X   When used via Internet TCP, the contact port assigned for this`0D
X   service is 119.`0D
X`0D
X2.2.  Character Codes`0D
X`0D
X   Commands and replies are composed of characters from the ASCII`0D
X   character set.  When the transport service provides an 8-bit byte`0D
X   (octet) transmission channel, each 7-bit character is transmitted`0D
X   right justified in an octet with the high order bit cleared to zero.`0D
X`0D
X2.3.  Commands`0D
X`0D
X   Commands consist of a command word, which in some cases may be`0D
X   followed by a parameter.  Commands with parameters must separate the`0D
X   parameters from each other and from the command by one or more space`0D
X   or tab characters.  Command lines must be complete with all required`0D
X   parameters, and may not contain more than one command.`0D
X`0D
X   Commands and command parameters are not case sensitive. That is, a`0D
X   command or parameter word may be upper case, lower case, or any`0D
X   mixture of upper and lower case.`0D
X`0D
X   Each command line must be terminated by a CR-LF (Carriage Return -`0D
X   Line Feed) pair.`0D
X`0D
X   Command lines shall not exceed 512 characters in length, counting all`0D
X   characters including spaces, separators, punctuation, and the`0D
X   trailing CR-LF (thus there are 510 characters maximum allowed for the`0D
X   command and its parameters).  There is no provision for continuation`0D
X   command lines.`0D
X`0D
X`0D
X`0D
X`0D
XKantor & Lapsley                                                `5BPage 5`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X2.4.  Responses`0D
X`0D
X   Responses are of two kinds, textual and status.`0D
X`0D
X2.4.1.  Text Responses`0D
X`0D
X   Text is sent only after a numeric status response line has been sent`0D
X   that indicates that text will follow.  Text is sent as a series of`0D
X   successive lines of textual matter, each terminated with CR-LF pair.`0D
X   A single line containing only a period (.) is sent to indicate the`0D
X   end of the text (i.e., the server will send a CR-LF pair at the end`0D
X   of the last line of text, a period, and another CR-LF pair).`0D
X`0D
X   If the text contained a period as the first character of the text`0D
X   line in the original, that first period is doubled.  Therefore, the`0D
X   client must examine the first character of each line received, and`0D
X   for those beginning with a period, determine either that this is the`0D
X   end of the text or whether to collapse the doubled period to a single`0D
X   one.`0D
X`0D
X   The intention is that text messages will usually be displayed on the`0D
X   user's terminal whereas command/status responses will be interpreted`0D
X   by the client program before any possible display is done.`0D
X`0D
X2.4.2.  Status Responses`0D
X`0D
X   These are status reports from the server and indicate the response to`0D
X   the last command received from the client.`0D
X`0D
X   Status response lines begin with a 3 digit numeric code which is`0D
X   sufficient to distinguish all responses.  Some of these may herald`0D
X   the subsequent transmission of text.`0D
X`0D
X   The first digit of the response broadly indicates the success,`0D
X   failure, or progress of the previous command.`0D
X`0D
X      1xx - Informative message`0D
X      2xx - Command ok`0D
X      3xx - Command ok so far, send the rest of it.`0D
X      4xx - Command was correct, but couldn't be performed for`0D
X            some reason.`0D
X      5xx - Command unimplemented, or incorrect, or a serious`0D
X            program error occurred.`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
XKantor & Lapsley                                                `5BPage 6`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X   The next digit in the code indicates the function response category.`0D
X`0D
X      x0x - Connection, setup, and miscellaneous messages`0D
X      x1x - Newsgroup selection`0D
X      x2x - Article selection`0D
X      x3x - Distribution functions`0D
X      x4x - Posting`0D
X      x8x - Nonstandard (private implementation) extensions`0D
X      x9x - Debugging output`0D
X`0D
X   The exact response codes that should be expected from each command`0D
X   are detailed in the description of that command.  In addition, below`0D
X   is listed a general set of response codes that may be received at any`0D
X   time.`0D
X`0D
X   Certain status responses contain parameters such as numbers and`0D
X   names. The number and type of such parameters is fixed for each`0D
X   response code to simplify interpretation of the response.`0D
X`0D
X   Parameters are separated from the numeric response code and from each`0D
X   other by a single space. All numeric parameters are decimal, and may`0D
X   have leading zeros. All string parameters begin after the separating`0D
X   space, and end before the following separating space or the CR-LF`0D
X   pair at the end of the line. (String parameters may not, therefore,`0D
X   contain spaces.) All text, if any, in the response which is not a`0D
X   parameter of the response must follow and be separated from the last`0D
X   parameter by a space.  Also, note that the text following a response`0D
X   number may vary in different implementations of the server. The`0D
X   3-digit numeric code should be used to determine what response was`0D
X   sent.`0D
X`0D
X   Response codes not specified in this standard may be used for any`0D
X   installation-specific additional commands also not specified. These`0D
X   should be chosen to fit the pattern of x8x specified above.  (Note`0D
X   that debugging is provided for explicitly in the x9x response codes.)`0D
X   The use of unspecified response codes for standard commands is`0D
X   prohibited.`0D
X`0D
X   We have provided a response pattern x9x for debugging.  Since much`0D
X   debugging output may be classed as "informative messages", we would`0D
X   expect, therefore, that responses 190 through 199 would be used for`0D
X   various debugging outputs.  There is no requirement in this`0D
X   specification for debugging output, but if such is provided over the`0D
X   connected stream, it must use these response codes.  If appropriate`0D
X   to a specific implementation, other x9x codes may be used for`0D
X   debugging.  (An example might be to use e.g., 290 to acknowledge a`0D
X   remote debugging request.)`0D
X`0D
X`0D
XKantor & Lapsley                                                `5BPage 7`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X2.4.3.  General Responses`0D
X`0D
X   The following is a list of general response codes that may be sent by`0D
X   the NNTP server.  These are not specific to any one command, but may`0D
X   be returned as the result of a connection, a failure, or some unusual`0D
X   condition.`0D
X`0D
X   In general, 1xx codes may be ignored or displayed as desired;  code`0D
X   200 or 201 is sent upon initial connection to the NNTP server`0D
X   depending upon posting permission; code 400 will be sent when the`0D
X   NNTP server discontinues service (by operator request, for example);`0D
X   and 5xx codes indicate that the command could not be performed for`0D
X   some unusual reason.`0D
X`0D
X      100 help text`0D
X      190`0D
X        through`0D
X      199 debug output`0D
X`0D
X      200 server ready - posting allowed`0D
X      201 server ready - no posting allowed`0D
X`0D
X      400 service discontinued`0D
X`0D
X      500 command not recognized`0D
X      501 command syntax error`0D
X      502 access restriction or permission denied`0D
X      503 program fault - command not performed`0D
X`0D
X3.  Command and Response Details`0D
X`0D
X   On the following pages are descriptions of each command recognized by`0D
X   the NNTP server and the responses which will be returned by those`0D
X   commands.`0D
X`0D
X   Each command is shown in upper case for clarity, although case is`0D
X   ignored in the interpretation of commands by the NNTP server.  Any`0D
X   parameters are shown in lower case.  A parameter shown in `5Bsquare`0D
X   brackets`5D is optional.  For example, `5BGMT`5D indicates that the`0D
X   triglyph GMT may present or omitted.`0D
X`0D
X   Every command described in this section must be implemented by all`0D
X   NNTP servers.`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
XKantor & Lapsley                                                `5BPage 8`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X   There is no prohibition against additional commands being added;`0D
X   however, it is recommended that any such unspecified command begin`0D
X   with the letter "X" to avoid conflict with later revisions of this`0D
X   specification.`0D
X`0D
X   Implementors are reminded that such additional commands may not`0D
X   redefine specified status response codes.  Using additional`0D
X   unspecified responses for standard commands is also prohibited.`0D
X`0D
X3.1.  The ARTICLE, BODY, HEAD, and STAT commands`0D
X`0D
X   There are two forms to the ARTICLE command (and the related BODY,`0D
X   HEAD, and STAT commands), each using a different method of specifying`0D
X   which article is to be retrieved.  When the ARTICLE command is`0D
X   followed by a message-id in angle brackets ("<" and ">"), the first`0D
X   form of the command is used; when a numeric parameter or no parameter`0D
X   is supplied, the second form is invoked.`0D
X`0D
X   The text of the article is returned as a textual response, as`0D
X   described earlier in this document.`0D
X`0D
X   The HEAD and BODY commands are identical to the ARTICLE command`0D
X   except that they respectively return only the header lines or text`0D
X   body of the article.`0D
X`0D
X   The STAT command is similar to the ARTICLE command except that no`0D
X   text is returned.  When selecting by message number within a group,`0D
X   the STAT command serves to set the current article pointer without`0D
X   sending text. The returned acknowledgement response will contain the`0D
X   message-id, which may be of some value.  Using the STAT command to`0D
X   select by message-id is valid but of questionable value, since a`0D
X   selection by message-id does NOT alter the "current article pointer".`0D
X`0D
X3.1.1.  ARTICLE (selection by message-id)`0D
X`0D
X   ARTICLE <message-id>`0D
X`0D
X   Display the header, a blank line, then the body (text) of the`0D
X   specified article.  Message-id is the message id of an article as`0D
X   shown in that article's header.  It is anticipated that the client`0D
X   will obtain the message-id from a list provided by the NEWNEWS`0D
X   command, from references contained within another article, or from`0D
X   the message-id provided in the response to some other commands.`0D
X`0D
X   Please note that the internally-maintained "current article pointer"`0D
X   is NOT ALTERED by this command. This is both to facilitate the`0D
X   presentation of articles that may be referenced within an article`0D
X`0D
X`0D
XKantor & Lapsley                                                `5BPage 9`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X   being read, and because of the semantic difficulties of determining`0D
X   the proper sequence and membership of an article which may have been`0D
X   posted to more than one newsgroup.`0D
X`0D
X3.1.2.  ARTICLE (selection by number)`0D
X`0D
X   ARTICLE `5Bnnn`5D`0D
X`0D
X   Displays the header, a blank line, then the body (text) of the`0D
X   current or specified article.  The optional parameter nnn is the`0D
X`0D
X   numeric id of an article in the current newsgroup and must be chosen`0D
X   from the range of articles provided when the newsgroup was selected.`0D
X   If it is omitted, the current article is assumed.`0D
X`0D
X   The internally-maintained "current article pointer" is set by this`0D
X   command if a valid article number is specified.`0D
X`0D
X   `5Bthe following applies to both forms of the article command.`5D A`0D
X   response indicating the current article number, a message-id string,`0D
X   and that text is to follow will be returned.`0D
X`0D
X   The message-id string returned is an identification string contained`0D
X   within angle brackets ("<" and ">"), which is derived from the header`0D
X   of the article itself.  The Message-ID header line (required by`0D
X   RFC850) from the article must be used to supply this information. If`0D
X   the message-id header line is missing from the article, a single`0D
X   digit "0" (zero) should be supplied within the angle brackets.`0D
X`0D
X   Since the message-id field is unique with each article, it may be`0D
X   used by a news reading program to skip duplicate displays of articles`0D
X   that have been posted more than once, or to more than one newsgroup.`0D
X`0D
X3.1.3.  Responses`0D
X`0D
X   220 n <a> article retrieved - head and body follow`0D
X           (n = article number, <a> = message-id)`0D
X   221 n <a> article retrieved - head follows`0D
X   222 n <a> article retrieved - body follows`0D
X   223 n <a> article retrieved - request text separately`0D
X   412 no newsgroup has been selected`0D
X   420 no current article has been selected`0D
X   423 no such article number in this group`0D
X   430 no such article found`0D
X`0D
X`0D
X`0D
X`0D
X`0D
XKantor & Lapsley                                               `5BPage 10`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X3.2.  The GROUP command`0D
X`0D
X3.2.1.  GROUP`0D
X`0D
X   GROUP ggg`0D
X`0D
X   The required parameter ggg is the name of the newsgroup to be`0D
X   selected (e.g. "net.news").  A list of valid newsgroups may be`0D
X   obtained from the LIST command.`0D
X`0D
X   The successful selection response will return the article numbers of`0D
X   the first and last articles in the group, and an estimate of the`0D
X   number of articles on file in the group.  It is not necessary that`0D
X   the estimate be correct, although that is helpful; it must only be`0D
X   equal to or larger than the actual number of articles on file.  (Some`0D
X   implementations will actually count the number of articles on file.`0D
X   Others will just subtract first article number from last to get an`0D
X   estimate.)`0D
X`0D
X   When a valid group is selected by means of this command, the`0D
X   internally maintained "current article pointer" is set to the first`0D
X   article in the group.  If an invalid group is specified, the`0D
X   previously selected group and article remain selected.  If an empty`0D
X   newsgroup is selected, the "current article pointer" is in an`0D
X   indeterminate state and should not be used.`0D
X`0D
X   Note that the name of the newsgroup is not case-dependent.  It must`0D
X   otherwise match a newsgroup obtained from the LIST command or an`0D
X   error will result.`0D
X`0D
X3.2.2.  Responses`0D
X`0D
X   211 n f l s group selected`0D
X           (n = estimated number of articles in group,`0D
X           f = first article number in the group,`0D
X           l = last article number in the group,`0D
X           s = name of the group.)`0D
X   411 no such news group`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
XKantor & Lapsley                                               `5BPage 11`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X3.3.  The HELP command`0D
X`0D
X3.3.1.  HELP`0D
X`0D
X   HELP`0D
X`0D
X   Provides a short summary of commands that are understood by this`0D
X   implementation of the server. The help text will be presented as a`0D
X   textual response, terminated by a single period on a line by itself.`0D
X`0D
X   3.3.2.  Responses`0D
X`0D
X   100 help text follows`0D
X`0D
X3.4.  The IHAVE command`0D
X`0D
X3.4.1.  IHAVE`0D
X`0D
X   IHAVE <messageid>`0D
X`0D
X   The IHAVE command informs the server that the client has an article`0D
X   whose id is <messageid>.  If the server desires a copy of that`0D
X   article, it will return a response instructing the client to send the`0D
X   entire article.  If the server does not want the article (if, for`0D
X   example, the server already has a copy of it), a response indicating`0D
X   that the article is not wanted will be returned.`0D
X`0D
X   If transmission of the article is requested, the client should send`0D
X   the entire article, including header and body, in the manner`0D
X   specified for text transmission from the server. A response code`0D
X   indicating success or failure of the transferral of the article will`0D
X   be returned.`0D
X`0D
X   This function differs from the POST command in that it is intended`0D
X   for use in transferring already-posted articles between hosts.`0D
X   Normally it will not be used when the client is a personal`0D
X   newsreading program.  In particular, this function will invoke the`0D
X   server's news posting program with the appropriate settings (flags,`0D
X   options, etc) to indicate that the forthcoming article is being`0D
X   forwarded from another host.`0D
X`0D
X   The server may, however, elect not to post or forward the article if`0D
X   after further examination of the article it deems it inappropriate to`0D
X   do so.  The 436 or 437 error codes may be returned as appropriate to`0D
X   the situation.`0D
X`0D
X   Reasons for such subsequent rejection of an article may include such`0D
X`0D
X`0D
XKantor & Lapsley                                               `5BPage 12`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X   problems as inappropriate newsgroups or distributions, disk space`0D
X   limitations, article lengths, garbled headers, and the like.  These`0D
X   are typically restrictions enforced by the server host's news`0D
X   software and not necessarily the NNTP server itself.`0D
X`0D
X3.4.2.  Responses`0D
X`0D
X   235 article transferred ok`0D
X   335 send article to be transferred.  End with <CR-LF>.<CR-LF>`0D
X   435 article not wanted - do not send it`0D
X   436 transfer failed - try again later`0D
X   437 article rejected - do not try again`0D
X`0D
X   An implementation note:`0D
X`0D
X   Because some host news posting software may not be able to decide`0D
X   immediately that an article is inappropriate for posting or`0D
X   forwarding, it is acceptable to acknowledge the successful transfer`0D
X   of the article and to later silently discard it.  Thus it is`0D
X   permitted to return the 235 acknowledgement code and later discard`0D
X   the received article.  This is not a fully satisfactory solution to`0D
X   the problem.  Perhaps some implementations will wish to send mail to`0D
X   the author of the article in certain of these cases.`0D
X`0D
X3.5.  The LAST command`0D
X`0D
X3.5.1.  LAST`0D
X`0D
X   LAST`0D
X`0D
X   The internally maintained "current article pointer" is set to the`0D
X   previous article in the current newsgroup.  If already positioned at`0D
X   the first article of the newsgroup, an error message is returned and`0D
X   the current article remains selected.`0D
X`0D
X   The internally-maintained "current article pointer" is set by this`0D
X   command.`0D
X`0D
X   A response indicating the current article number, and a message-id`0D
X   string will be returned.  No text is sent in response to this`0D
X   command.`0D
X`0D
X3.5.2.  Responses`0D
X`0D
X   223 n a article retrieved - request text separately`0D
X           (n = article number, a = unique article id)`0D
X`0D
X`0D
X`0D
XKantor & Lapsley                                               `5BPage 13`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X   412 no newsgroup selected`0D
X   420 no current article has been selected`0D
X   422 no previous article in this group`0D
X`0D
X3.6.  The LIST command`0D
X`0D
X3.6.1.  LIST`0D
X`0D
X   LIST`0D
X`0D
X   Returns a list of valid newsgroups and associated information.  Each`0D
X   newsgroup is sent as a line of text in the following format:`0D
X`0D
X      group last first p`0D
X`0D
X   where <group> is the name of the newsgroup, <last> is the number of`0D
X   the last known article currently in that newsgroup, <first> is the`0D
X   number of the first article currently in the newsgroup, and <p> is`0D
X   either 'y' or 'n' indicating whether posting to this newsgroup is`0D
X   allowed ('y') or prohibited ('n').`0D
X`0D
X   The <first> and <last> fields will always be numeric.  They may have`0D
X   leading zeros.  If the <last> field evaluates to less than the`0D
X   <first> field, there are no articles currently on file in the`0D
X   newsgroup.`0D
X`0D
X   Note that posting may still be prohibited to a client even though the`0D
X   LIST command indicates that posting is permitted to a particular`0D
X   newsgroup. See the POST command for an explanation of client`0D
X   prohibitions.  The posting flag exists for each newsgroup because`0D
X   some newsgroups are moderated or are digests, and therefore cannot be`0D
X   posted to; that is, articles posted to them must be mailed to a`0D
X   moderator who will post them for the submitter.  This is independent`0D
X   of the posting permission granted to a client by the NNTP server.`0D
X`0D
X   Please note that an empty list (i.e., the text body returned by this`0D
X   command consists only of the terminating period) is a possible valid`0D
X   response, and indicates that there are currently no valid newsgroups.`0D
X`0D
X3.6.2.  Responses`0D
X`0D
X   215 list of newsgroups follows`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
XKantor & Lapsley                                               `5BPage 14`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X3.7.  The NEWGROUPS command`0D
X`0D
X3.7.1.  NEWGROUPS`0D
X`0D
X   NEWGROUPS date time `5BGMT`5D `5B<distributions>`5D`0D
X`0D
X   A list of newsgroups created since <date and time> will be listed in`0D
X   the same format as the LIST command.`0D
X`0D
X   The date is sent as 6 digits in the format YYMMDD, where YY is the`0D
X   last two digits of the year, MM is the two digits of the month (with`0D
X   leading zero, if appropriate), and DD is the day of the month (with`0D
X   leading zero, if appropriate).  The closest century is assumed as`0D
X   part of the year (i.e., 86 specifies 1986, 30 specifies 2030, 99 is`0D
X   1999, 00 is 2000).`0D
X`0D
X   Time must also be specified.  It must be as 6 digits HHMMSS with HH`0D
X   being hours on the 24-hour clock, MM minutes 00-59, and SS seconds`0D
X   00-59.  The time is assumed to be in the server's timezone unless the`0D
X   token "GMT" appears, in which case both time and date are evaluated`0D
X   at the 0 meridian.`0D
X`0D
X   The optional parameter "distributions" is a list of distribution`0D
X   groups, enclosed in angle brackets.  If specified, the distribution`0D
X   portion of a new newsgroup (e.g, 'net' in 'net.wombat') will be`0D
X   examined for a match with the distribution categories listed, and`0D
X   only those new newsgroups which match will be listed.  If more than`0D
X   one distribution group is to be listed, they must be separated by`0D
X   commas within the angle brackets.`0D
X`0D
X   Please note that an empty list (i.e., the text body returned by this`0D
X   command consists only of the terminating period) is a possible valid`0D
X   response, and indicates that there are currently no new newsgroups.`0D
X`0D
X3.7.2.  Responses`0D
X`0D
X   231 list of new newsgroups follows`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
XKantor & Lapsley                                               `5BPage 15`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X3.8.  The NEWNEWS command`0D
X`0D
X3.8.1.  NEWNEWS`0D
X`0D
X   NEWNEWS newsgroups date time `5BGMT`5D `5B<distribution>`5D`0D
X`0D
X   A list of message-ids of articles posted or received to the specified`0D
X   newsgroup since "date" will be listed. The format of the listing will`0D
X   be one message-id per line, as though text were being sent.  A single`0D
X   line consisting solely of one period followed by CR-LF will terminate`0D
X   the list.`0D
X`0D
X   Date and time are in the same format as the NEWGROUPS command.`0D
X`0D
X   A newsgroup name containing a "*" (an asterisk) may be specified to`0D
X   broaden the article search to some or all newsgroups.  The asterisk`0D
X   will be extended to match any part of a newsgroup name (e.g.,`0D
X   net.micro* will match net.micro.wombat, net.micro.apple, etc). Thus`0D
X   if only an asterisk is given as the newsgroup name, all newsgroups`0D
X   will be searched for new news.`0D
X`0D
X   (Please note that the asterisk "*" expansion is a general`0D
X   replacement; in particular, the specification of e.g., net.*.unix`0D
X   should be correctly expanded to embrace names such as net.wombat.unix`0D
X   and net.whocares.unix.)`0D
X`0D
X   Conversely, if no asterisk appears in a given newsgroup name, only`0D
X   the specified newsgroup will be searched for new articles. Newsgroup`0D
X   names must be chosen from those returned in the listing of available`0D
X   groups.  Multiple newsgroup names (including a "*") may be specified`0D
X   in this command, separated by a comma.  No comma shall appear after`0D
X   the last newsgroup in the list.  `5BImplementors are cautioned to keep`0D
X   the 512 character command length limit in mind.`5D`0D
X`0D
X   The exclamation point ("!") may be used to negate a match. This can`0D
X   be used to selectively omit certain newsgroups from an otherwise`0D
X   larger list.  For example, a newsgroups specification of`0D
X   "net.*,mod.*,!mod.map.*" would specify that all net.<anything> and`0D
X   all mod.<anything> EXCEPT mod.map.<anything> newsgroup names would be`0D
X   matched.  If used, the exclamation point must appear as the first`0D
X   character of the given newsgroup name or pattern.`0D
X`0D
X   The optional parameter "distributions" is a list of distribution`0D
X   groups, enclosed in angle brackets.  If specified, the distribution`0D
X   portion of an article's newsgroup (e.g, 'net' in 'net.wombat') will`0D
X   be examined for a match with the distribution categories listed, and`0D
X   only those articles which have at least one newsgroup belonging to`0D
X`0D
X`0D
XKantor & Lapsley                                               `5BPage 16`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X   the list of distributions will be listed.  If more than one`0D
X   distribution group is to be supplied, they must be separated by`0D
X   commas within the angle brackets.`0D
X`0D
X   The use of the IHAVE, NEWNEWS, and NEWGROUPS commands to distribute`0D
X   news is discussed in an earlier part of this document.`0D
X`0D
X   Please note that an empty list (i.e., the text body returned by this`0D
X   command consists only of the terminating period) is a possible valid`0D
X   response, and indicates that there is currently no new news.`0D
X`0D
X3.8.2.  Responses`0D
X`0D
X   230 list of new articles by message-id follows`0D
X`0D
X3.9.  The NEXT command`0D
X`0D
X3.9.1.  NEXT`0D
X`0D
X   NEXT`0D
X`0D
X   The internally maintained "current article pointer" is advanced to`0D
X   the next article in the current newsgroup.  If no more articles`0D
X   remain in the current group, an error message is returned and the`0D
X   current article remains selected.`0D
X`0D
X   The internally-maintained "current article pointer" is set by this`0D
X   command.`0D
X`0D
X   A response indicating the current article number, and the message-id`0D
X   string will be returned.  No text is sent in response to this`0D
X   command.`0D
X`0D
X3.9.2.  Responses`0D
X`0D
X   223 n a article retrieved - request text separately`0D
X           (n = article number, a = unique article id)`0D
X   412 no newsgroup selected`0D
X   420 no current article has been selected`0D
X   421 no next article in this group`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
XKantor & Lapsley                                               `5BPage 17`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X3.10.  The POST command`0D
X`0D
X3.10.1.  POST`0D
X`0D
X   POST`0D
X`0D
X   If posting is allowed, response code 340 is returned to indicate that`0D
X   the article to be posted should be sent. Response code 440 indicates`0D
X   that posting is prohibited for some installation-dependent reason.`0D
X`0D
X   If posting is permitted, the article should be presented in the`0D
X   format specified by RFC850, and should include all required header`0D
X   lines. After the article's header and body have been completely sent`0D
X   by the client to the server, a further response code will be returned`0D
X   to indicate success or failure of the posting attempt.`0D
X`0D
X   The text forming the header and body of the message to be posted`0D
X   should be sent by the client using the conventions for text received`0D
X   from the news server:  A single period (".") on a line indicates the`0D
X   end of the text, with lines starting with a period in the original`0D
X   text having that period doubled during transmission.`0D
X`0D
X   No attempt shall be made by the server to filter characters, fold or`0D
X   limit lines, or otherwise process incoming text.  It is our intent`0D
X   that the server just pass the incoming message to be posted to the`0D
X   server installation's news posting software, which is separate from`0D
X   this specification.  See RFC850 for more details.`0D
X`0D
X   Since most installations will want the client news program to allow`0D
X   the user to prepare his message using some sort of text editor, and`0D
X   transmit it to the server for posting only after it is composed, the`0D
X   client program should take note of the herald message that greeted it`0D
X   when the connection was first established. This message indicates`0D
X   whether postings from that client are permitted or not, and can be`0D
X   used to caution the user that his access is read-only if that is the`0D
X   case. This will prevent the user from wasting a good deal of time`0D
X   composing a message only to find posting of the message was denied.`0D
X   The method and determination of which clients and hosts may post is`0D
X   installation dependent and is not covered by this specification.`0D
X`0D
X3.10.2.  Responses`0D
X`0D
X   240 article posted ok`0D
X   340 send article to be posted. End with <CR-LF>.<CR-LF>`0D
X   440 posting not allowed`0D
X   441 posting failed`0D
X`0D
X`0D
X`0D
XKantor & Lapsley                                               `5BPage 18`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X   (for reference, one of the following codes will be sent upon initial`0D
X   connection; the client program should determine whether posting is`0D
X   generally permitted from these:) 200 server ready - posting allowed`0D
X   201 server ready - no posting allowed`0D
X`0D
X3.11.  The QUIT command`0D
X`0D
X3.11.1.  QUIT`0D
X`0D
X   QUIT`0D
X`0D
X   The server process acknowledges the QUIT command and then closes the`0D
X   connection to the client.  This is the preferred method for a client`0D
X   to indicate that it has finished all its transactions with the NNTP`0D
X   server.`0D
X`0D
X   If a client simply disconnects (or the connection times out, or some`0D
X   other fault occurs), the server should gracefully cease its attempts`0D
X   to service the client.`0D
X`0D
X3.11.2.  Responses`0D
X`0D
X   205 closing connection - goodbye!`0D
X`0D
X3.12.  The SLAVE command`0D
X`0D
X3.12.1.  SLAVE`0D
X`0D
X   SLAVE`0D
X`0D
X   Indicates to the server that this client connection is to a slave`0D
X   server, rather than a user.`0D
X`0D
X   This command is intended for use in separating connections to single`0D
X   users from those to subsidiary ("slave") servers.  It may be used to`0D
X   indicate that priority should therefore be given to requests from`0D
X   this client, as it is presumably serving more than one person.  It`0D
X   might also be used to determine which connections to close when`0D
X   system load levels are exceeded, perhaps giving preference to slave`0D
X   servers.  The actual use this command is put to is entirely`0D
X   implementation dependent, and may vary from one host to another.  In`0D
X   NNTP servers which do not give priority to slave servers, this`0D
X   command must nonetheless be recognized and acknowledged.`0D
X`0D
X3.12.2.  Responses`0D
X`0D
X   202 slave status noted`0D
X`0D
X`0D
XKantor & Lapsley                                               `5BPage 19`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X4.  Sample Conversations`0D
X`0D
X   These are samples of the conversations that might be expected with`0D
X   the news server in hypothetical sessions.  The notation C: indicates`0D
X   commands sent to the news server from the client program; S: indicate`0D
X   responses received from the server by the client.`0D
X`0D
X4.1.  Example 1 - relative access with NEXT`0D
X`0D
X   S:      (listens at TCP port 119)`0D
X`0D
X   C:      (requests connection on TCP port 119)`0D
X   S:      200 wombatvax news server ready - posting ok`0D
X`0D
X   (client asks for a current newsgroup list)`0D
X   C:      LIST`0D
X   S:      215 list of newsgroups follows`0D
X   S:      net.wombats 00543 00501 y`0D
X   S:      net.unix-wizards 10125 10011 y`0D
X           (more information here)`0D
X   S:      net.idiots 00100 00001 n`0D
X   S:      .`0D
X`0D
X   (client selects a newsgroup)`0D
X   C:      GROUP net.unix-wizards`0D
X   S:      211 104 10011 10125 net.unix-wizards group selected`0D
X           (there are 104 articles on file, from 10011 to 10125)`0D
X`0D
X   (client selects an article to read)`0D
X   C:      STAT 10110`0D
X   S:      223 10110 <23445@sdcsvax.ARPA> article retrieved - statistics`0D
X           only (article 10110 selected, its message-id is`0D
X           <23445@sdcsvax.ARPA>)`0D
X`0D
X   (client examines the header)`0D
X   C:      HEAD`0D
X   S:      221 10110 <23445@sdcsvax.ARPA> article retrieved - head`0D
X           follows (text of the header appears here)`0D
X   S:      .`0D
X`0D
X   (client wants to see the text body of the article)`0D
X   C:      BODY`0D
X   S:      222 10110 <23445@sdcsvax.ARPA> article retrieved - body`0D
X           follows (body text here)`0D
X   S:      .`0D
X`0D
X   (client selects next article in group)`0D
X`0D
X`0D
XKantor & Lapsley                                               `5BPage 20`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X   C:      NEXT`0D
X   S:      223 10113 <21495@nudebch.uucp> article retrieved - statistics`0D
X           only (article 10113 was next in group)`0D
X`0D
X   (client finishes session)`0D
X   C:      QUIT`0D
X   S:      205 goodbye.`0D
X`0D
X4.2.  Example 2 - absolute article access with ARTICLE`0D
X`0D
X   S:      (listens at TCP port 119)`0D
X`0D
X   C:      (requests connection on TCP port 119)`0D
X   S:      201 UCB-VAX netnews server ready -- no posting allowed`0D
X`0D
X   C:      GROUP msgs`0D
X   S:      211 103 402 504 msgs Your new group is msgs`0D
X           (there are 103 articles, from 402 to 504)`0D
X`0D
X   C:      ARTICLE 401`0D
X   S:      423 No such article in this newsgroup`0D
X`0D
X   C:      ARTICLE 402`0D
X   S:      220 402 <4105@ucbvax.ARPA> Article retrieved, text follows`0D
X   S:      (article header and body follow)`0D
X   S:      .`0D
X`0D
X   C:      HEAD 403`0D
X   S:      221 403 <3108@mcvax.UUCP> Article retrieved, header follows`0D
X   S:      (article header follows)`0D
X   S:      .`0D
X`0D
X   C:      QUIT`0D
X   S:      205 UCB-VAX news server closing connection.  Goodbye.`0D
X`0D
X4.3.  Example 3 - NEWGROUPS command`0D
X`0D
X   S:      (listens at TCP port 119)`0D
X`0D
X   C:      (requests connection on TCP port 119)`0D
X   S:      200 Imaginary Institute News Server ready (posting ok)`0D
X`0D
X   (client asks for new newsgroups since April 3, 1985)`0D
X   C:      NEWGROUPS 850403 020000`0D
X`0D
X   S:      231 New newsgroups since 03/04/85 02:00:00 follow`0D
X`0D
X`0D
X`0D
XKantor & Lapsley                                               `5BPage 21`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X   S:      net.music.gdead`0D
X   S:      net.games.sources`0D
X   S:      .`0D
X`0D
X   C:      GROUP net.music.gdead`0D
X   S:      211 0 1 1 net.music.gdead Newsgroup selected`0D
X           (there are no articles in that newsgroup, and`0D
X           the first and last article numbers should be ignored)`0D
X`0D
X   C:      QUIT`0D
X   S:      205 Imaginary Institute news server ceasing service.  Bye!`0D
X`0D
X4.4.  Example 4 - posting a news article`0D
X`0D
X   S:      (listens at TCP port 119)`0D
X`0D
X   C:      (requests connection on TCP port 119)`0D
X   S:      200 BANZAIVAX news server ready, posting allowed.`0D
X`0D
X   C:      POST`0D
X   S:      340 Continue posting; Period on a line by itself to end`0D
X   C:      (transmits news article in RFC850 format)`0D
X   C:      .`0D
X   S:      240 Article posted successfully.`0D
X`0D
X   C:      QUIT`0D
X   S:      205 BANZAIVAX closing connection.  Goodbye.`0D
X`0D
X4.5.  Example 5 - interruption due to operator request`0D
X`0D
X   S:      (listens at TCP port 119)`0D
X`0D
X   C:      (requests connection on TCP port 119)`0D
X   S:      201 genericvax news server ready, no posting allowed.`0D
X`0D
X           (assume normal conversation for some time, and`0D
X           that a newsgroup has been selected)`0D
X`0D
X   C:      NEXT`0D
X   S:      223 1013 <5734@mcvax.UUCP> Article retrieved; text separate.`0D
X`0D
X   C:      HEAD`0D
X   C:      221 1013 <5734@mcvax.UUCP> Article retrieved; head follows.`0D
X`0D
X   S:      (sends head of article, but halfway through is`0D
X           interrupted by an operator request.  The following`0D
X           then occurs, without client intervention.)`0D
X`0D
X`0D
XKantor & Lapsley                                               `5BPage 22`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X   S:      (ends current line with a CR-LF pair)`0D
X   S:      .`0D
X   S:      400 Connection closed by operator.  Goodbye.`0D
X   S:      (closes connection)`0D
X`0D
X4.6.  Example 6 - Using the news server to distribute news between`0D
X      systems.`0D
X`0D
X   S:      (listens at TCP port 119)`0D
X`0D
X   C:      (requests connection on TCP port 119)`0D
X   S:      201 Foobar NNTP server ready (no posting)`0D
X`0D
X   (client asks for new newsgroups since 2 am, May 15, 1985)`0D
X   C:      NEWGROUPS 850515 020000`0D
X   S:      235 New newsgroups since 850515 follow`0D
X   S:      net.fluff`0D
X   S:      net.lint`0D
X   S:      .`0D
X`0D
X   (client asks for new news articles since 2 am, May 15, 1985)`0D
X   C:      NEWNEWS * 850515 020000`0D
X   S:      230 New news since 850515 020000 follows`0D
X   S:      <1772@foo.UUCP>`0D
X   S:      <87623@baz.UUCP>`0D
X   S:      <17872@GOLD.CSNET>`0D
X   S:      .`0D
X`0D
X   (client asks for article <1772@foo.UUCP>)`0D
X   C:      ARTICLE <1772@foo.UUCP>`0D
X   S:      220 <1772@foo.UUCP> All of article follows`0D
X   S:      (sends entire message)`0D
X   S:      .`0D
X`0D
X   (client asks for article <87623@baz.UUCP>`0D
X   C:      ARTICLE <87623@baz.UUCP>`0D
X   S:      220 <87623@baz.UUCP> All of article follows`0D
X   S:      (sends entire message)`0D
X   S:      .`0D
X`0D
X   (client asks for article <17872@GOLD.CSNET>`0D
X   C:      ARTICLE <17872@GOLD.CSNET>`0D
X   S:      220 <17872@GOLD.CSNET> All of article follows`0D
X   S:      (sends entire message)`0D
X   S:      .`0D
X`0D
X`0D
X`0D
X`0D
XKantor & Lapsley                                               `5BPage 23`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X   (client offers an article it has received recently)`0D
X   C:      IHAVE <4105@ucbvax.ARPA>`0D
X   S:      435 Already seen that one, where you been?`0D
X`0D
X   (client offers another article)`0D
X   C:      IHAVE <4106@ucbvax.ARPA>`0D
X   S:      335 News to me!  <CRLF.CRLF> to end.`0D
X   C:      (sends article)`0D
X   C:      .`0D
X   S:      235 Article transferred successfully.  Thanks.`0D
X`0D
X   (or)`0D
X`0D
X   S:      436 Transfer failed.`0D
X`0D
X   (client is all through with the session)`0D
X   C:      QUIT`0D
X   S:      205 Foobar NNTP server bids you farewell.`0D
X`0D
X4.7.  Summary of commands and responses.`0D
X`0D
X   The following are the commands recognized and responses returned by`0D
X   the NNTP server.`0D
X`0D
X4.7.1.  Commands`0D
X`0D
X   ARTICLE`0D
X   BODY`0D
X   GROUP`0D
X   HEAD`0D
X   HELP`0D
X   IHAVE`0D
X   LAST`0D
X   LIST`0D
X   NEWGROUPS`0D
X   NEWNEWS`0D
X   NEXT`0D
X   POST`0D
X   QUIT`0D
X   SLAVE`0D
X   STAT`0D
X`0D
X4.7.2.  Responses`0D
X`0D
X   100 help text follows`0D
X   199 debug output`0D
X`0D
X`0D
X`0D
XKantor & Lapsley                                               `5BPage 24`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X   200 server ready - posting allowed`0D
X   201 server ready - no posting allowed`0D
X   202 slave status noted`0D
X   205 closing connection - goodbye!`0D
X   211 n f l s group selected`0D
X   215 list of newsgroups follows`0D
X   220 n <a> article retrieved - head and body follow 221 n <a> article`0D
X   retrieved - head follows`0D
X   222 n <a> article retrieved - body follows`0D
X   223 n <a> article retrieved - request text separately 230 list of new`0D
X   articles by message-id follows`0D
X   231 list of new newsgroups follows`0D
X   235 article transferred ok`0D
X   240 article posted ok`0D
X`0D
X   335 send article to be transferred.  End with <CR-LF>.<CR-LF>`0D
X   340 send article to be posted. End with <CR-LF>.<CR-LF>`0D
X`0D
X   400 service discontinued`0D
X   411 no such news group`0D
X   412 no newsgroup has been selected`0D
X   420 no current article has been selected`0D
X   421 no next article in this group`0D
X   422 no previous article in this group`0D
X   423 no such article number in this group`0D
X   430 no such article found`0D
X   435 article not wanted - do not send it`0D
X   436 transfer failed - try again later`0D
X   437 article rejected - do not try again.`0D
X   440 posting not allowed`0D
X   441 posting failed`0D
X`0D
X   500 command not recognized`0D
X   501 command syntax error`0D
X   502 access restriction or permission denied`0D
X   503 program fault - command not performed`0D
X`0D
X4.8.  A Brief Word about the USENET News System`0D
X`0D
X   In the UNIX world, which traditionally has been linked by 1200 baud`0D
X   dial-up telephone lines, the USENET News system has evolved to handle`0D
X   central storage, indexing, retrieval, and distribution of news.  With`0D
X   the exception of its underlying transport mechanism (UUCP), USENET`0D
X   News is an efficient means of providing news and bulletin service to`0D
X   subscribers on UNIX and other hosts worldwide.  The USENET News`0D
X`0D
X`0D
X`0D
X`0D
XKantor & Lapsley                                               `5BPage 25`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X   system is discussed in detail in RFC 850.  It runs on most versions`0D
X   of UNIX and on many other operating systems, and is customarily`0D
X   distributed without charge.`0D
X`0D
X   USENET uses a spooling area on the UNIX host to store news articles,`0D
X   one per file. Each article consists of a series of heading text,`0D
X   which contain the sender's identification and organizational`0D
X   affiliation, timestamps, electronic mail reply paths, subject,`0D
X   newsgroup (subject category), and the like.  A complete news article`0D
X   is reproduced in its entirety below.  Please consult RFC 850 for more`0D
X   details.`0D
X`0D
X      Relay-Version: version B 2.10.3 4.3bsd-beta 6/6/85; site`0D
X      sdcsvax.UUCP`0D
X      Posting-Version: version B 2.10.1 6/24/83 SMI; site unitek.uucp`0D
X      Path:sdcsvax!sdcrdcf!hplabs!qantel!ihnp4!alberta!ubc-vision!unitek`0D
X      !honman`0D
X      From: honman@unitek.uucp (Man Wong)`0D
X      Newsgroups: net.unix-wizards`0D
X      Subject: foreground -> background ?`0D
X      Message-ID: <167@unitek.uucp>`0D
X      Date: 25 Sep 85 23:51:52 GMT`0D
X      Date-Received: 29 Sep 85 09:54:48 GMT`0D
X      Reply-To: honman@unitek.UUCP (Hon-Man Wong)`0D
X      Distribution: net.all`0D
X      Organization: Unitek Technologies Corporation`0D
X      Lines: 12`0D
X`0D
X      I have a process (C program) which generates a child and waits for`0D
X      it to return.  What I would like to do is to be able to run the`0D
X      child process interactively for a while before kicking itself into`0D
X      the background so I can return to the parent process (while the`0D
X      child process is RUNNING in the background).  Can it be done?  And`0D
X      if it can, how?`0D
X`0D
X      Please reply by E-mail.  Thanks in advance.`0D
X`0D
X      Hon-Man Wong`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
XKantor & Lapsley                                               `5BPage 26`5D
V`0D
X`0C`0D
X`0D
X`0D
XRFC 977                                                    February 1986`0D
XNetwork News Transfer Protocol`0D
X`0D
X`0D
X5.  References`0D
X`0D
X   `5B1`5D  Crocker, D., "Standard for the Format of ARPA Internet Text`0D
X        Messages", RFC-822, Department of Electrical Engineering,`0D
X        University of Delaware, August, 1982.`0D
X`0D
X   `5B2`5D  Horton, M., "Standard for Interchange of USENET Messages",`0D
X        RFC-850, USENET Project, June, 1983.`0D
X`0D
X   `5B3`5D  Postel, J., "Transmission Control Protocol- DARPA Internet`0D
X        Program Protocol Specification", RFC-793, USC/Information`0D
X        Sciences Institute, September, 1981.`0D
X`0D
X   `5B4`5D  Postel, J., "Simple Mail Transfer Protocol", RFC-821,`0D
X        USC/Information Sciences Institute, August, 1982.`0D
X`0D
X6.  Acknowledgements`0D
X`0D
X   The authors wish to express their heartfelt thanks to those many`0D
X   people who contributed to this specification, and especially to Erik`0D
X   Fair and Chuq von Rospach, without whose inspiration this whole thing`0D
X   would not have been necessary.`0D
X`0D
X7.  Notes`0D
X`0D
X   <1> UNIX is a trademark of Bell Laboratories.`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
X`0D
XKantor & Lapsley                                               `5BPage 27`5D
V`0D
X`0C`0D
$ CALL UNPACK RFC977.TXT;2 1260644331
$ create 'f'
XReturn-Path: jeffw@scam.Berkeley.EDU
XReceived: by shambhala.Berkeley.EDU (5.57/1.28)
X`09id AA20375; Sat, 30 Sep 89 15:29:29 PDT
XReceived: by scam.Berkeley.EDU (5.57/1.26)
X`09id AA11975; Sat, 30 Sep 89 15:28:51 PDT
XMessage-Id: <8909302228.AA11975@scam.Berkeley.EDU>
XTo: Rick L. Spickelmier <ricks@shambhala.Berkeley.EDU>
XSubject: Re: More comments from the world's pickiest xrn user`20
XIn-Reply-To: Your message of Sat, 30 Sep 89 12:02:42 -0700`20
X`09     <8909301902.AA19694@shambhala.Berkeley.EDU>`20
XDate: Sat, 30 Sep 89 15:28:49 -0800
XFrom: Jeff Wallace <jeffw@scam.Berkeley.EDU>
X
X
X>Could you send me your 'rn'-like bindings?
X>
X>`09`09Rick
X
X
X/*
X * Missing commands: 1, `5E, $, !, `5EK
X */`20
Xxrn.ngBindings: \
X  <Key>0x20:`09doTheRightThing()`09\n\
X  <Key>y:`09doTheRightThing()`09\n\
X  :<Key>u:`09ngUnsub()`09\n\
X  :<Key>c:`09ngCatchUp()`09\n\
X  <Key>n:`09ngNext()`09\n\
X  <Key>p:`09ngPrev()`09\n\
X  <Key>-:`09ngPrevGroup()`09\n\
X  :<Key>g:`09ngGoto()`09\n\
X  :<Key>L:`09ngAllGroups()`09\n\
X  <Key>q:`09ngQuit()
X
X/*
X * Commands that don't exist in xrn: number (goto article), `5ER, `5EB
X * `5EL, `5E, $, Y, `5EK
X */
Xxrn.artBindings: \
X  <Key>0x20:`09doTheRightThing()`09\n\
X  :<Key>n:`09doTheRightThing()`09\n\
X  :<Key>N:`09artNext()`09\n\
X  `5E<Key>N:`09artSubNext()`09\n\
X  <Key>P:`09artPrev()`09\n\
X  `5E<Key>P:`09artSubPrev()`09\n\
X  :<Key>-:`09artLast()`09\n\
X  :<Key>/:`09artSubSearch()`09\n\
X  <Key>f:`09artFollowup()`09\n\
X  <Key>r:`09artReply()`09\n\
X  <Key>s:`09artSave()`09\n\
X  <Key>w:`09artSave()`09\n\
X  <Key>`7C:`09artSave()`09\n\
X  :<Key>C:`09artCancel()`09\n\
X  :<Key>v:`09artHeader()`09\n\
X  `5E<Key>X:`09artRot13()`09\n\
X  :<Key>X:`09artRot13()`09\n\
X  :<Key>c:`09artCatchUp()`09\n\
X  :<Key>j:`09artMarkRead()`09\n\
X  <Key>m:`09artMarkUnread()`09\n\
X  :<Key>k:`09artKillSession()`09\n\
X  :<Key>K:`09artKillLocal()`09\n\
X  :<Key>u:`09artUnsub()`09\n\
X  <Key>q:`09artQuit()
X
XThey don't all behave precisely as in rn, but they are all close
Xto what an rn user expects.
X
XJeff
$ CALL UNPACK RN.BINDINGS;2 1229026236
$ create 'f'
X
X#if !defined(lint) && !defined(SABER)
Xstatic char XRNrcsid`5B`5D = "$Header: /net/objy27/wrld/mnt11/ricks/src/mast
Ver/xrn/save.c,v 1.6 1993/01/11 02:15:23 ricks Exp $";
X#endif
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * save.c: routines for saving articles and sending articles to processes
X */
X
X#include "copyright.h"
X#include <ctype.h>
X#include <stdio.h>
X#include "config.h"
X#include "utils.h"
X#ifndef VMS
X#include <sys/param.h>
X#include <sys/stat.h>
X#else
X#define MAXPATHLEN 512
X#define index strchr
X#include <stat.h>
X#ifdef __STDC__
X#include <unixlib.h>
Xextern int time();
X#endif
X#endif /* VMS */
X#include <errno.h>
X
X#ifdef sco
X#define MAXPATHLEN 512
X#endif
X
X#include "news.h"
X#include "resources.h"
X#include "dialogs.h"
X#include "error_hnds.h"
X#include "internals.h"
X#include "server.h"
X#include "mesg.h"
X#include "save.h"
X#include "xmisc.h"
X#include "xrn.h"
X
Xextern int errno;
X#ifndef VMS
Xextern int refile();
X#endif
X
X#define BUFFER_SIZE 1024
X
X
X#ifndef VMS
X/*
X * send the current article to 'command'
X *
X *   returns: the exit status of the command
X *
X */
Xstatic int
XprocessArticle(command, artfile)
Xchar *command;
Xchar *artfile;
X`7B
X    FILE *process;
X    extern FILE *popen();`09/* sequent */
X    char *artPtr;
X    int c, status;
X
X    if ((process = popen(command, "w")) == NULL) `7B
X`09mesgPane(XRN_SERIOUS, "can not start `60%s'", command);
X`09return(0);
X    `7D
X
X    artPtr = artfile;
X    while ((c = *artPtr) != '\0') `7B
X`09(void) putc((char) c, process);
X`09artPtr++;
X    `7D
X
X    status = pclose(process);
X
X    return(status);
X`7D
X#endif /* VMS */
X
X/*
X * make sure that the news directory exists before trying to update it
X *
X *   returns: 0 for failure, 1 for okay
X */
Xint
XcreateNewsDir()
X`7B
X    static int done = 0;
X    char *newdir;
X
X    if (done) `7B
X`09return(1);
X    `7D
X    if ((newdir = utTildeExpand(app_resources.saveDir)) == NIL(char)) `7B
X`09mesgPane(XRN_SERIOUS, "Cannot create save directory `60%s'",
X`09`09 app_resources.saveDir);
X`09return(0);
X    `7D
X    if ((mkdir(newdir, 0777) == -1) && (errno != EEXIST)) `7B
X`09mesgPane(XRN_SERIOUS, "Cannot create save directory `60%s': %s",
X`09`09       app_resources.saveDir, errmsg(errno));
X`09return(0);
X    `7D
X    done = 1;
X    if (app_resources.expandedSaveDir)
X`09XtFree(app_resources.expandedSaveDir);
X    app_resources.expandedSaveDir = (char *) XtNewString(newdir);
X
X    return(1);
X`7D
X
X
X#ifdef VMS
Xstatic void
XVmsMakeDirName(dummy, savedir, Group)
X    char *dummy;
X    char *savedir;
X    char *Group;
X`7B
X    int temp;
X    (void) strcpy(dummy, savedir);`09/* Copy save directory name */
X    temp = strlen(dummy);`09`09/* Fetch the length */
X    if (dummy`5Btemp-1`5D == '`5D') `7B`09`09/* If a directory spec, */
X        dummy`5Btemp-1`5D = '.';`09`09/*  Convert to a .  */
X    `7D else `7B
X`09(void) strcat(dummy, "`5B.");`09/* Else, start directory */
X    `7D
X    (void) strcat(dummy, Group);`09/* Add the group name */
X    (void) strcat(dummy, "`5D");`09`09/* Now terminate the string */
X`7D
X#endif /* VMS */
X
X#ifndef VMS
X/*
X * expand a file name for 'saving' a file
X *
X *   returns: the name of the file or NIL(char) if the filename is bad
X *            (i.e. `7Euser/xx where 'user' is not a valid user name)
X *            the area returned is static
X *
X */
Xstatic char *
XbuildFileName(filename, savedir, group)
Xchar *filename;    /* file name, possibly with a '`7E' */
Xchar *savedir;     /* save directory                 */
Xchar *group;       /* name of the news group         */
X`7B
X    char Group`5BGROUP_NAME_SIZE`5D;
X#ifdef aiws
X    static char dummy`5BMAXPATH`5D;
X#else
X    static char dummy`5BMAXPATHLEN`5D;
X#endif /* aiws */
X
X    /* Make a local copy of the group name for modification */
X    (void) strncpy(Group, group, sizeof(Group));
X    /* upcase the first letter of the group name (same as 'rn') */
X    if (islower(Group`5B0`5D)) `7B
X`09Group`5B0`5D = toupper(Group`5B0`5D);
X    `7D
X
X    if ((filename == NIL(char)) `7C`7C (*filename == '\0')) `7B
X`09if (app_resources.saveMode & ONEDIR_SAVE)`7B
X`09    (void) sprintf(dummy, "%s/%s", savedir, Group);
X`09`7D else `7B
X`09    /* use "saveDir/group" */
X`09    (void) sprintf(dummy, "%s/%s", savedir, group);
X`09    (void) mkdir(utTildeExpand(dummy), 0777);
X`09    (void) strcat(dummy, "/");
X`09    (void) strcat(dummy, Group);
X`09`7D
X`09return(utTildeExpand(dummy));
X    `7D
X
X    if ((filename`5B0`5D == '/') `7C`7C (filename`5B0`5D == '`7E')) `7B
X`09return(utTildeExpand(filename));
X    `7D
X
X    if (app_resources.saveMode & ONEDIR_SAVE) `7B
X`09(void) sprintf(dummy, "%s/%s", savedir, filename);
X    `7D else `7B
X`09/* use "saveDir/group/filename" */
X`09(void) sprintf(dummy, "%s/%s", savedir, group);
X`09(void) mkdir(utTildeExpand(dummy), 0777);
X`09(void) strcat(dummy, "/");
X`09(void) strcat(dummy, filename);
X    `7D
X    return(utTildeExpand(dummy));
X`7D
X#else /* VMS */
Xstatic char *
XbuildFileName(filename, savedir, group)
Xchar *filename;    /* file name, possibly with a '`7E' */
Xchar *savedir;     /* save directory                 */
Xchar *group;       /* name of the news group         */
X/*
X * expand a file name for 'saving' a file
X *
X *   returns: the name of the file or NIL(char) if the filename is bad
X *            (i.e. `7Euser/xx where 'user' is not a valid user name)
X *            the area returned is static
X *
X */
X`7B
X    char Group`5BGROUP_NAME_SIZE`5D;
X    static char dummy`5BMAXPATHLEN`5D;
X    char *dot;`09   /* Pointer to dots to convert to underscores */
X
X    /* First, use the generic group to filename conversion routine and
X       convert the group name to a filename */
X    (void) utGroupToVmsFilename(Group, group);
X
X    /* If we are in ONEDIR_SAVE mode, find the first underscore character
X       and convert it (back) to a dot.  This is done for compatibility with
X       VNEWS. */
X    if (app_resources.saveMode & ONEDIR_SAVE) `7B
X`09if (dot = index(Group, '_')) `7B
X`09    *dot = '.';
X`09`7D
X    `7D
X
X    if ((filename == NIL(char)) `7C`7C (*filename == '\0')) `7B
X`09if (app_resources.saveMode & ONEDIR_SAVE)`7B
X`09    (void) sprintf(dummy, "%s%s", savedir, Group);
X`09`7D else `7B
X`09    /* use "saveDir/group" */
X`09    VmsMakeDirName(dummy, savedir, Group);
X`09    (void) mkdir(utTildeExpand(dummy), 0777);
X`09    (void) strcat(dummy, Group);
X`09    if (!(app_resources.saveMode & ONEDIR_SAVE)) `7B
X`09`09(void) strcat(dummy, ".ART");
X`09    `7D
X`09`7D
X`09return(utTildeExpand(dummy));
X    `7D
X
X    if ((index(filename, ':')) `7C`7C (index(filename, '`5B'))
X`09`09`7C`7C (index(filename, '<'))) `7B
X`09return(utTildeExpand(filename));
X    `7D
X
X    if (app_resources.saveMode & ONEDIR_SAVE) `7B
X`09(void) sprintf(dummy, "%s%s", savedir, filename);
X    `7D else `7B
X`09/* use "saveDir/group/filename" */
X`09VmsMakeDirName(dummy, savedir, Group);
X`09(void) mkdir(utTildeExpand(dummy), 0777);
X`09(void) strcat(dummy, filename);
X    `7D
X    return(utTildeExpand(dummy));
X`7D
X#endif /* VMS */
X
Xint
XsaveArticleByNumber(filename, art)
Xchar *filename;
Xart_num art;
X`7B
X    return saveArticle(filename, CurrentGroup, art);
X`7D
X
X
Xint
XsaveRangeOfArticles(filenameTemplate, start, end)
Xchar *filenameTemplate;
Xart_num start;
Xart_num end;
X/*
X * save the a range of articles from start to end,
X *
X * filenameTemplate is a sprintf compatible string
X *
X *   examples:  "mg.%d", "`7C save-it"
X *
X *     %d will be filled in with the article number
X *
X *   returns: 1 for OKAY, 0 for FAILURE
X *
X */
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    /* art_num save_current = newsgroup->current; */
X    art_num i;
X    char buffer`5B1024`5D;
X    int status;
X
X    for (i = start; i <= end; i++) `7B
X`09(void) sprintf(buffer, filenameTemplate, i);
X`09if (!(status = saveArticle(buffer, newsgroup, i)))
X`09    break;
X    `7D
X    return(status);
X`7D
X
X
X#define XRNsave_OVERWRITE 1
X#define XRNsave_APPEND 2
X#define XRNsave_ABORT 3
Xstatic Widget OverBox = (Widget) 0;`09/* for overwrite dialog */
Xstatic int OverVal;
Xstatic Boolean useSavedValue = False;
X
Xvoid
XresetSaveFlag()
X`7B
X    useSavedValue = False;
X`7D
X
Xstatic void
XoverwriteHandler(widget, client_data, call_data)
XWidget widget;
Xcaddr_t client_data;
Xcaddr_t call_data;
X`7B
X    OverVal = (int) client_data;
X    if (OverVal == XRNsave_OVERWRITE `7C`7C OverVal == XRNsave_APPEND) `7B
X`09useSavedValue = True;
X    `7D
X    return;
X`7D
X
Xstatic int overwriteOK()
X`7B
X    XEvent ev;
X    static struct DialogArg args`5B`5D = `7B
X`09`7B"Overwrite", overwriteHandler, (caddr_t) XRNsave_OVERWRITE`7D,
X`09`7B"Append",    overwriteHandler, (caddr_t) XRNsave_APPEND`7D,
X`09`7B"Abort",     overwriteHandler, (caddr_t) XRNsave_ABORT`7D,
X    `7D;
X
X    if (useSavedValue)
X`09return OverVal;
X
X    if (OverBox == (Widget) 0) `7B
X`09OverBox = CreateDialog(TopLevel,
X`09`09"Overwrite Confirm",
X`09`09"File already exists. Overwrite or append?",
X`09`09DIALOG_NOTEXT, args, XtNumber(args));
X    `7D
X    OverVal = -1;
X    PopUpDialog(OverBox);
X    for (;;) `7B
X`09XtNextEvent(&ev);
X`09(void) XtDispatchEvent(&ev);
X`09if (OverVal != -1) `7B
X`09    PopDownDialog(OverBox);
X`09    return(OverVal);
X`09`7D
X    `7D
X`7D
Xint
XsaveArticle(filename, newsgroup, art)
Xchar *filename;
Xstruct newsgroup *newsgroup;
Xart_num art;
X`7B
X    char timeString`5BBUFFER_SIZE`5D;
X    char fromString`5BBUFFER_SIZE`5D;
X    extern char *ctime();
X    int error = 0;
X    time_t clockTime;
X    int pos;
X    char *artfile, *fullName;
X    char *artPtr, *strPtr, *endPtr, saveEnd;
X    FILE *fpsave;
X#ifdef XLATE
X    int xlation;
X#endif
X    int rotation;
X    Boolean needRefetch = False;
X    char mode`5B2`5D;
X    Boolean appending;
X    struct stat buf;
X    char *defDir;
X#ifdef VMS
X    char *p;
X    Boolean decnet = False;
X#endif
X    char rname`5B200`5D;
X    char *type;
X    XrmValue value;
X
X#ifdef MOTIF
X    sprintf(rname, "mxrn.%s.saveDir", newsgroup->name);
X#else
X    sprintf(rname, "dxrn.%s.saveDir", newsgroup->name);
X#endif
X
X    if (XrmGetResource(XtDatabase(XtDisplay(TopLevel)),
X`09`09rname, "SaveDir", &type, &value)) `7B
X`09defDir = value.addr;
X    `7D else `7B
X`09defDir = app_resources.saveDir;
X    `7D
X
X    if ((filename != NIL(char)) && (*filename != '\0')) `7B
X`09filename = utTrimSpaces(filename);
X    `7D
X
X    /* get the FULL article */
X
X    rotation = (IS_ROTATED(newsgroup->artStatus`5BINDEX(art)`5D) ? ROTATED :
V NOT_ROTATED);
X#ifdef XLATE
X    xlation = (IS_XLATED(newsgroup->artStatus`5BINDEX(art)`5D) ? XLATED : NO
VT_XLATED);
X#endif
X/*
X * Try to get the article out of the cache
X * but only if --
X * Unrotated and
X *   No strip/leave headers or
X *   Headers not being saved
X */
X    needRefetch = False;
X    if (rotation == ROTATED)
X`09needRefetch = True;
X#ifdef XLATE
X    if (xlation == XLATED)
X`09needRefetch = True;
X#endif
X    if ((app_resources.saveMode & HEADERS_SAVE) == HEADERS_SAVE) `7B
X`09if (app_resources.leaveHeaders != NULL `7C`7C
X`09    app_resources.stripHeaders != NULL) `7B
X`09    needRefetch = True;
X`09`7D
X    `7D
X    if (needRefetch) `7B
X#ifdef XLATE
X`09artfile = getarticle(art, &pos, FULL_HEADER, rotation, xlation);
X#else
X`09artfile = getarticle(art, &pos, FULL_HEADER, rotation);
X#endif
X    `7D else `7B
X        if ((artfile = getText(art)) == NULL) `7B
X#ifdef XLATE
X`09    artfile = getarticle(art, &pos, FULL_HEADER, rotation, xlation);
X#else
X`09    artfile = getarticle(art, &pos, FULL_HEADER, rotation);
X#endif
X`09`7D else `7B
X`09    artfile = (char *) XtNewString(artfile);
X`09    for (pos = 0, strPtr = artfile; *strPtr; pos++, strPtr++) `7B
X`09`09if (artfile`5Bpos`5D == '\n' && artfile`5Bpos+1`5D == '\n') `7B
X`09`09    pos = pos + 2;
X`09`09    break;
X`09`09`7D
X`09    `7D
X`09`7D
X    `7D
X
X    if (artfile == NULL) `7B
X`09mesgPane(XRN_SERIOUS, "Could not get article %d to save",art);
X        return(0);
X    `7D
X   `20
X#ifndef VMS
X    /*`20
X     * check a few special cases before actually saving the article
X     * to a plain text file:
X     *
X     * - pipe it to a command
X     * - file it to an mh folder
X     * - file it to an RMAIL folder
X     */
X    if ((filename != NIL(char)) && (filename`5B0`5D == '`7C')) `7B
X`09int status;
X`09(void) sprintf(error_buffer, "Piping article %ld into command `60%s'...
V     ",
X`09`09       art, &filename`5B1`5D);
X`09infoNow(error_buffer);
X    `09status = processArticle(utTrimSpaces(&filename`5B1`5D), artfile);
X`09FREE(artfile);
X`09if (status) `7B
X`09    (void) sprintf(error_buffer, "`60%s' exited with status %d",
X`09`09`09`09&filename`5B1`5D, status);
X`09`7D else `7B
X`09    (void) strcpy(&error_buffer`5Bstrlen(error_buffer) - 4`5D, "done");
X`09`7D
X`09info(error_buffer);
X`09return(status == 0);
X    `7D
X
X    if ((filename != NIL(char)) && (filename`5B0`5D == '+')) `7B
X`09int status = MHrefile(filename, artfile);
X`09FREE(artfile);
X`09(void) sprintf(error_buffer, "MH refile to folder %s done", filename);
X`09infoNow(error_buffer);
X`09return(status);
X    `7D
X#endif
X
X    /* XXX not quite right, don't want to try to create it if not used... */
X    if (!createNewsDir()) `7B
X`09FREE(artfile);
X`09return(0);
X    `7D
X   `20
X    if ((fullName = buildFileName(filename, defDir, newsgroup->name)) == NIL
V(char)) `7B
X`09mesgPane(XRN_SERIOUS, "Cannot figure out file name `60%s': %s",
X`09`09filename, errmsg(errno));
X`09FREE(artfile);
X`09return(0);
X    `7D
X
X
X#ifndef VMS
X    if (filename != NIL(char) && filename `5B0`5D == '@') `7B
X`09int status;
X`09if ((fullName = buildFileName(filename+1, app_resources.saveDir,
X`09`09`09`09      newsgroup->name)) == NIL(char)) `7B
X`09    mesgPane(XRN_SERIOUS, "Cannot figure out file name `60%s'",
X`09`09`09filename+1);
X`09    (void) unlink(artfile);
X`09    FREE(artfile);
X`09    return(0);
X`09`7D
X`09status = RMAILrefile(fullName, filename+1, artfile, pos);
X`09(void) sprintf(error_buffer, "RMAIL refile to folder %s done",
X`09`09`09filename+1);
X`09infoNow(error_buffer);
X`09(void) unlink(artfile);
X`09FREE(artfile);
X`09return(status);
X    `7D
X#endif
X
X#ifdef VMS
X    for (p = fullName; *p != '\0'; p++) `7B
X`09if (*p == ':' && *(p+1) == ':') `7B
X`09    decnet = True;
X`09`7D
X    `7D
X#endif
X    if (stat(fullName, &buf) == 0) `7B
X`09if (app_resources.confirmMode & ART_SAVE) `7B
X`09    switch (overwriteOK()) `7B
X`09`09case XRNsave_ABORT:
X`09`09return(0);
X
X`09`09case XRNsave_OVERWRITE:
X`09`09(void) strcpy(mode, "w");
X`09`09appending = 0;
X`09`09busyCursor();
X`09`09break;
X`09   `20
X`09`09case XRNsave_APPEND:
X`09`09(void) strcpy(mode, "a");
X`09`09appending = 1;
X`09`09busyCursor();
X`09`09break;
X`09    `7D
X`09`7D else `7B
X`09    appending = 1;
X`09    (void) strcpy(mode, "a");
X`09`7D
X    `7D else `7B
X`09appending = 0;
X`09(void) strcpy(mode, "a");
X    `7D
X   `20
X#ifdef VMS
X    /*
X     * Always do append over DECnet
X     */
X
X    if (decnet) (void) strcpy(mode, "a");
X#endif
X
X    if ((fpsave = fopen(fullName, mode)) == NULL) `7B
X`09if (appending) `7B
X`09    (void) sprintf(error_buffer, "Cannot append to file `60%s': %s",
X`09`09fullName, errmsg(errno));
X`09`7D else `7B
X`09    (void) sprintf(error_buffer, "Cannot create file `60%s': %s",
X`09`09fullName, errmsg(errno));
X`09`7D
X`09mesgPane(XRN_SERIOUS, error_buffer);
X`09FREE(artfile);
X`09return(0);
X    `7D
X
X    if (!appending) `7B
X`09(void) sprintf(error_buffer, "Saving article %ld in file `60%s'...     ",
X`09`09`09   art, fullName);
X    `7D else `7B
X`09(void) sprintf(error_buffer, "Appending article %ld to file `60%s'...
V     ",
X`09`09       art, fullName);
X`09if ((app_resources.saveMode & MAILBOX_SAVE) != MAILBOX_SAVE) `7B
X#ifdef VMS
X`09    if (!decnet) `7B
X`09`09fprintf(fpsave, "\014\n");
X`09    `7D
X#else
X`09    fprintf(fpsave,"\014\n");
X#endif
X`09`7D
X    `7D`09
X    `20
X    infoNow(error_buffer);
X
X    artPtr = artfile;
X    if ((app_resources.saveMode & MAILBOX_SAVE) == MAILBOX_SAVE) `7B
X`09int found = 0;
X
X`09strcpy(fromString, "Unknown");
X`09/*
X`09 * Temporarily terminate at the end of the header so the
X`09 * scans below don't have to read the entire article.
X`09 */
X`09endPtr = artPtr + pos;
X`09saveEnd = *endPtr;
X`09*endPtr = '\0';
X`09(void) time(&clockTime);
X`09(void) strcpy(timeString, ctime(&clockTime));
X`09timeString`5Bstrlen(timeString) - 1`5D = '\0';  /* get rid of the newline
V */
X
X`09/*
X`09 * Scan the header lines, looking for 'Reply-To', 'From', and 'Path'
X`09 * headers, looking for a usable 'From' header to be fabricated.
X`09 */
X        artPtr = artfile;
X`09while (artPtr && *artPtr != '\0') `7B
X`09    if (STREQN(artPtr, "Reply-To:", 9)) `7B
X`09`09found = 1;
X`09`09if (strPtr = index(artPtr, '\n'))
X`09`09    *strPtr = '\0';
X`09`09(void) sscanf(artPtr + 10, "%s", fromString);
X`09`09if (strPtr) *strPtr = '\n';
X`09`09break;
X`09    `7D
X`09    artPtr = index(artPtr, '\n');
X`09    if (artPtr) artPtr++;
X`09`7D
X`09if (!found) `7B
X`09    artPtr = artfile;
X`09    while (artPtr && *artPtr != '\0') `7B
X`09`09if (STREQN(artPtr, "From:", 5)) `7B
X`09`09    found = 1;
X`09`09    if (strPtr = index(artPtr, '\n'))
X`09`09`09*strPtr = '\0';
X`09`09    (void) sscanf(artPtr + 6, "%s", fromString);
X`09`09    if (strPtr) *strPtr = '\n';
X`09`09    break;
X`09`09`7D
X`09`09artPtr = index(artPtr, '\n');
X`09`09if (artPtr) artPtr++;
X`09    `7D
X`09`7D
X`09if (!found) `7B
X`09    artPtr = artfile;
X`09    while (artPtr && *artPtr != '\0') `7B
X`09`09if (STREQN(artPtr, "Path:", 5)) `7B
X`09`09    found = 1;
X`09`09    if (strPtr = index(artPtr, '\n'))
X`09`09`09*strPtr = '\0';
X`09`09    (void) sscanf(artPtr + 6, "%s", fromString);
X`09`09    if (strPtr) *strPtr = '\n';
X`09`09    break;
X`09`09`7D
X`09`09artPtr = index(artPtr, '\n');
X`09`09if (artPtr) artPtr++;
X`09    `7D
X`09`7D
X`09if (fprintf(fpsave, "From %s %s\n", fromString, timeString) == EOF) `7B
X`09    error++;
X`09    goto finished;
X`09`7D
X        *endPtr = saveEnd;
X    `7D
X
X    if ((app_resources.saveMode & MAILBOX_SAVE) == MAILBOX_SAVE) `7B
X`09if (fprintf(fpsave, "Article: %ld of %s\n",
X`09`09`09art, newsgroup->name) == EOF) `7B;
X`09    error++;
X`09    goto finished;
X`09`7D
X    `7D else `7B
X`09if (fprintf(fpsave, "Article %ld of %s:\n",
X`09`09art, newsgroup->name) == EOF) `7B;
X`09    error++;
X`09    goto finished;
X`09`7D
X    `7D
X
X    artPtr = artfile;
X    if ((app_resources.saveMode & HEADERS_SAVE) != HEADERS_SAVE) `7B
X`09artPtr += pos;
X    `7D
X
X    while (*artPtr != '\0') `7B
X`09strPtr = index(artPtr, '\n');
X`09if (strPtr) *strPtr = '\0';
X`09if (fputs(artPtr, fpsave) == EOF) `7B
X`09    error++;
X`09    goto finished;
X`09`7D
X`09if (fprintf(fpsave, "\n") == EOF) `7B
X`09    error++;
X`09    goto finished;
X`09`7D
X`09artPtr = artPtr + strlen(artPtr) + 1;
X    `7D
X
X    if (fprintf(fpsave, "\n\n") == EOF) `7B
X`09error++;
X`09goto finished;
X    `7D
Xfinished:
X    if (fclose(fpsave) == EOF) `7B
X`09error++;
X    `7D
X
X    FREE(artfile);
X
X    (void) strcpy(&error_buffer`5ButStrlen(error_buffer) - 4`5D,`20
X`09error ? "aborted" : "done");
X    if (error) `7B
X`09info(error_buffer);
X`09(void) sprintf(error_buffer, "Error writing to file `60%s': %s",
X`09`09`09fullName, errmsg(errno));
X`09mesgPane(XRN_SERIOUS, error_buffer);
X`09return 0;
X    `7D else `7B
X`09info(error_buffer);
X`09SET_SAVED(newsgroup->artStatus`5BINDEX(art)`5D);
X`09useSavedValue = True;
X`09OverVal = XRNsave_APPEND;
X`09return 1;
X    `7D
X`7D
X
X/*
X * save the current article in 'filename' (if it begins with '`7C', send it
V to
X *   a process)
X *
X *   returns: 1 for OKAY, 0 for FAILURE
X *
X */
Xint
XsaveCurrentArticle(filename)
Xchar *filename;
X`7B
X    struct newsgroup *newsgroup = CurrentGroup;
X    char formattedName`5B1000`5D;
X
X    sprintf(formattedName, filename, newsgroup->current);
X    return saveArticle(formattedName, newsgroup, newsgroup->current);
X`7D
$ CALL UNPACK SAVE.C;79 1785996530
$ create 'f'
X#ifndef SAVE_H
X#define SAVE_H
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/save.h,v 1.4 1993/01
V/11 02:15:25 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * save.h: routines for saving articles and sending articles to processes
X */
X
X
Xextern int saveCurrentArticle _ARGUMENTS((char *));
Xextern int saveArticleByNumber _ARGUMENTS((char *, art_num));
Xextern int saveRangeOfArticles _ARGUMENTS((char *, art_num, art_num));
Xextern int createNewsDir();
Xextern int saveArticle _ARGUMENTS((char *, struct newsgroup *, art_num));
Xextern void resetSaveFlag();
X#endif /* SAVEARTICLE_H */
$ CALL UNPACK SAVE.H;2 273817466
$ create 'f'
X
X#if !defined(lint) && !defined(SABER)
Xstatic char XRNrcsid`5B`5D = "$Header: /net/objy27/wrld/mnt11/ricks/src/mast
Ver/xrn/server.c,v 1.10 1993/02/04 18:22:28 ricks Exp $";
X#endif
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * server.c: routines for communicating with the NNTP remote news server
X *
X */
X
X#include "copyright.h"
X#include <ctype.h>
X#include <stdio.h>
X#include <assert.h>
X#ifndef VMS
X#include <sys/param.h>
X#include <sys/wait.h>
X#else
X#define MAXPATHLEN 512
X#define index strchr
X#endif /* VMS */
X#include <errno.h>
X#include "config.h"
X#include "utils.h"
X#include "xrn.h"
X#include "avl.h"
X#include "news.h"
X#include "mesg.h"
X#include "error_hnds.h"
X#include "resources.h"
X#include "server.h"
X#include "dialogs.h"
X#include "xthelper.h"
X#include "xmisc.h"
X
X#if defined(sun) && defined(sparc) && !defined(SOLARIS)
X#include <vfork.h>
X#endif
X
X#ifdef INEWS
X#include <sys/stat.h>
X#endif
X
X#define BUFFER_SIZE 1024
X#define MESSAGE_SIZE 1024
X#define MAXFIELDS 9
X#define DEFREFS 20
X
X#ifdef __STDC__
X#include <stdlib.h>
X#include <time.h>
X#ifndef VMS
X#include <unistd.h>
X#else
Xextern void sleep();
Xextern int mailArticle();
X#endif
X#ifdef VFORK_SUPPORTED
X#ifndef SVR4_0
Xextern int vfork();
X#else
Xextern pid_t vfork(void);
X#endif
X#endif
X#else
X#if !defined(VMS) && !defined(SVR4) && !defined(ultrix)
X#if defined(__convexc__)
Xextern unsigned sleep();
X#else
X#if !defined(__osf__)
Xextern void sleep();
X#endif
X#endif
X#endif
X#endif
X
Xextern Boolean allowErrors;
Xextern struct article *currentArticles;
Xextern struct article *savedArt;
Xextern int artCount;
X
Xint ServerDown = 0;
Xstatic char mybuf`5BMESSAGE_SIZE+100`5D =`20
X`09"The news server is not responding correctly, aborting\n";
X
Xstatic struct newsgroup *currentNewsgroup = 0;
X#define SETNEWSGROUP(n) (((n) == currentNewsgroup) ? 0 : getgroup((n), 0, 0,
V 0))
X
X/*
X * get data from the server (active file, article)
X *
X *  on error, sets 'ServerDown'
X *
X *   returns: void
X */
Xstatic void
Xget_data_from_server(str, size)
Xchar *str;     /* string for message to be copied into */
Xint size;      /* size of string                       */
X`7B
X    xthHandleAllPendingEvents();
X    str`5B0`5D = '\0';
X    if (ServerDown) return;
X    if (get_server(str, size) < 0) `7B
X`09ServerDown = 1;
X    `7D else `7B
X`09ServerDown = 0;
X    `7D
X    return;
X`7D
X
X
Xstatic void
Xcheck_time_out(command, response, size, pause)
Xchar *command;  /* command to resend           */
Xchar *response; /* response from the command   */
Xint size;       /* size of the response buffer */
XBoolean pause;`09/* True if pause should be checked */
X`7B
X    /*
X     * try to recover from a timeout
X     *
X     *   this assumes that the timeout message stays the same
X     *   since the error number (503) is used for more than just
X     *   timeout
X     *
X     *   Message is:
X     *     503 Timeout ...
X     */
X
X    int old = ActiveGroupsCount;
X    struct newsgroup *wanted = currentNewsgroup;
X    char message`5B512`5D;
X    int status;
X
X    if (ServerDown `7C`7C STREQN(response, "503 Timeout", 11)) `7B
X
X        if (XtIsRealized(TopLevel)) `7B
X`09    xmSetIconAndName(LostIcon);
X`09    XFlush(XtDisplay(TopLevel));
X`09`7D
X`09mesgPane(XRN_SERIOUS, "Lost connection to the NNTP server, attempting to
V reconnect");
X`09start_server(NIL(char));
X
X`09mesgPane(XRN_INFO, "Reconnected to the NNTP server");
X        if (XtIsRealized(TopLevel)) `7B
X`09    xmSetIconAndName(UnreadIcon);
X`09    XFlush(XtDisplay(TopLevel));
X`09`7D
X
X`09/*
X`09 * if it was an ARTICLE or XHDR or HEAD command, then you must get the
X`09 * server into the right state (GROUP mode), so resend the last
X`09 * group command
X`09 */
X`09if (STREQN(command, "ARTICLE", 7) `7C`7C STREQN(command,"XHDR", 4) `7C`7C
X`09    STREQN(command, "HEAD", 4) `7C`7C STREQN(command,"XOVER", 5)) `7B
X`09    if (wanted) `7B
X`09`09currentNewsgroup = 0;
X`09`09if (getgroup(wanted, NIL(art_num), NIL(art_num), NIL(int))
X`09`09`09== NO_GROUP) `7B
X`09`09    return;
X`09`09`7D`09`09
X`09`09currentNewsgroup = wanted;
X`09`09/* XXX should do some processing of changed first/last numbers */
X`09    `7D
X`09`7D
X
X`09
X`09if (put_server(command, True) == -1)
X`09    ServerDown = True;
X`09get_data_from_server(response, size);
X    `7D
X    if (pause && STREQN(response, "400 ", 4)) `7B
X        if (XtIsRealized(TopLevel)) `7B
X`09    xmSetIconAndName(LostIcon);
X`09    XFlush(XtDisplay(TopLevel));
X`09`7D
X`09sprintf(message, "Error from news server: %s - retry?", response);
X`09status = ConfirmationBox(TopLevel, message);
X`09if (!status)
X`09    ehCleanExitXRN();
X`09
X`09if (put_server(command, True) == -1)
X`09    ServerDown = True;
X`09get_data_from_server(response, size);
X    `7D
X   `20
X    return;
X`7D
X
X/*
X * retrieve article number 'artnumber' in the current group, update structur
Ve
X *
X *   returns:  article text or NIL(char) if the article is not avaiable
X *
X */
Xchar *
X#ifdef XLATE
Xgetarticle(artnumber, position, header, rotation,xlation)
X#else
Xgetarticle(artnumber, position, header, rotation)
X#endif
Xart_num artnumber; /* number of article in the current group to retrieve */
Xint *position;`09   /* byte position of header/body seperation            */
Xint header, rotation;
X#ifdef XLATE
Xint xlation;
X#endif
X`7B
X    char command`5BMESSAGE_SIZE`5D, message`5BMESSAGE_SIZE`5D, *msg;
X#ifdef REALLY_USE_LOCALTIME
X    char temp`5BMESSAGE_SIZE`5D;
X#endif
X    static char`09*artstring = NULL;
X    char *newartstring = NULL;
X    static int`09artstringsize = 0;
X    char *ptr;
X    char *endPtr;
X    int  segSize;
X    char field`5BBUFFER_SIZE`5D;
X    int byteCount = 0, lineCount = 0;
X    int last_stripped = 0;
X
X    if (artstring == NULL) `7B
X`09artstring = XtMalloc(100000);
X        artstringsize = 100000;
X    `7D
X    *position = 0;
X    *artstring = '\0';
X   `20
X    /* send ARTICLE */
X    (void) sprintf(command, "ARTICLE %ld", artnumber);
X    if (put_server(command, True) == -1)
X`09ServerDown = True;
X    get_data_from_server(message, sizeof(message));
X
X    check_time_out(command, message, sizeof(message), True);
X
X    if (*message != CHAR_OK) `7B
X`09/* can't get article */
X`09return(NIL(char));
X    `7D
X
X    endPtr = artstring;
X    for (;;) `7B
X`09if (byteCount + MESSAGE_SIZE > artstringsize) `7B
X`09    newartstring = XtMalloc(artstringsize + 100000);
X`09    artstringsize += 100000;
X`09    strcpy (newartstring, artstring);
X`09    XtFree(artstring);
X`09    artstring = newartstring;
X`09    endPtr = artstring + byteCount;
X`09`7D
X`09get_data_from_server(message, sizeof(message));
X`09if (ServerDown) `7B
X`09    check_time_out(command, message, sizeof(message), False);
X`09    if (*message != CHAR_OK) `7B
X`09`09/* can't get article */
X`09`09return(NIL(char));
X`09    `7D
X`09    byteCount = 0;
X`09    endPtr = artstring;
X`09    continue;
X`09`7D`09   `20
X
X`09/* the article is ended by a '.' on a line by itself */
X`09if ((message`5B0`5D == '.') && (message`5B1`5D == '\0')) `7B
X`09    /* check for a bogus message */
X`09    if (byteCount == 0) `7B
X`09`09return(NIL(char));
X`09    `7D
X`09    break;
X`09`7D
X
X`09msg = &message`5B0`5D;
X
X`09/* find header/body seperation */
X`09if (*position == 0) `7B
X`09    if (*msg == '\0') `7B
X`09`09*position = byteCount;
X`09    `7D
X`09`7D
X`09     `20
X`09if (*msg == '.') `7B
X`09    msg++;
X`09`7D
X
X`09if (*msg != '\0') `7B
X`09    /* strip leading `5EH */
X`09    while (*msg == '\b') `7B
X`09`09msg++;
X`09    `7D
X`09    /* strip '<character>`5EH' */
X`09    for (ptr = index(msg + 1, '\b'); ptr != NIL(char); ptr = index(ptr, '
V\b')) `7B
X`09`09if (ptr - 1 < msg) `7B
X`09`09    /* too many backspaces, kill all leading back spaces */
X`09`09    while (*ptr == '\b') `7B
X`09`09        (void) strcpy(ptr, ptr + 1);
X`09`09`09ptr++;
X`09`09    `7D
X`09`09    break;
X`09`09`7D
X`09`09(void) strcpy(ptr - 1, ptr + 1);
X`09`09ptr--;
X`09    `7D
X
X#ifdef REALLY_USE_LOCALTIME
X  `09    if (app_resources.displayLocalTime && !strncmp(msg, "Date: ", 6)) `
V7B
X`09`09  tconvert(temp, msg+6);
X`09`09  (void) strcpy(msg+6, temp);
X`09    `7D
X#endif
X`09    /* strip the headers */
X`09    if ((*position == 0) && (header == NORMAL_HEADER)) `7B
X`09`09if ((*msg == ' ') `7C`7C (*msg == '\t')) `7B /* continuation line */
X`09`09    if (last_stripped)
X`09`09`09continue;
X`09`09`7D else `7B
X`09`09    if ((ptr = index(msg, ':')) == NIL(char)) `7B
X`09`09`09continue;    /* weird header line, skip */
X`09`09    `7D
X`09`09    if (*(ptr+1) == '\0') `7B
X`09`09`09continue;    /* empty field, skip */
X`09`09    `7D
X`09`09    (void) strncpy(field, msg, (int) (ptr - msg));
X`09`09    field`5B(int) (ptr - msg)`5D = '\0';
X`09`09    utDowncase(field);
X`09`09    if (avl_lookup(app_resources.headerTree, field, &ptr)) `7B
X`09`09`09if (app_resources.headerMode == STRIP_HEADERS) `7B
X`09`09`09    last_stripped = 1;
X`09`09`09    continue;
X`09`09`09`7D else `7B
X`09`09`09    last_stripped = 0;
X`09`09`09`7D
X`09`09    `7D else `7B
X`09`09`09if (app_resources.headerMode == LEAVE_HEADERS) `7B
X`09`09`09    last_stripped = 1;
X`09`09`09    continue;
X`09`09`09`7D else `7B
X`09`09`09    last_stripped = 0;
X`09`09`09`7D
X`09`09    `7D
X`09`09`7D
X`09    `7D
X
X`09    /* handle rotation of the article body */
X`09    if ((rotation == ROTATED) && (*position != 0)) `7B
X`09`09for (ptr = msg; *ptr != '\0'; ptr++) `7B
X`09`09    if (isalpha(*ptr)) `7B
X`09`09`09if ((*ptr & 31) <= 13) `7B
X`09`09`09    *ptr = *ptr + 13;
X`09`09`09`7D else `7B
X`09`09`09    *ptr = *ptr - 13;
X`09`09`09`7D
X`09`09    `7D
X`09`09`7D
X`09    `7D
X
X#ifdef XLATE
X`09    /* handle translation of the article body */
X`09    if ((xlation == XLATED) && (*position != 0))
X`09`09utXlate(msg);
X#endif /* XLATE */
X
X`09    /* handle `5EL (poorly?) */
X`09    if (*msg == '\014') `7B
X`09`09int i, lines;
X`09`09lines = articleLines();
X`09`09lines -= lineCount % lines;
X`09`09for (i = 0; i < lines; i++) `7B
X`09`09    (void) strcpy(endPtr, "\n");
X`09`09    endPtr++;
X`09`09`7D
X`09`09byteCount += lines;
X`09`09lineCount += lines;
X`09`09msg++;
X`09    `7D
X`09    (void) strcpy(endPtr, msg);
X`09`7D
X`09segSize = utStrlen(msg);
X`09byteCount += segSize + 1;
X`09endPtr += segSize;
X`09*endPtr++ = '\n';
X`09*endPtr = '\0';
X`09lineCount++;
X    `7D
X
X    return( (char *) XtNewString(artstring));
X`7D
X
X/*
X * enter a new group and get its statistics (and update the structure)
X *   allocate an array for the articles and process the .newsrc article
X *   info for this group
X *
X *   returns: NO_GROUP on failure, 0 on success
X *
X */
Xint
Xgetgroup(newsgroup, first, last, number)
Xstruct newsgroup *newsgroup;    /* group                      */
Xart_num *first; `09`09/* first article in the group */
Xart_num *last;  `09`09/* last article in the group  */
Xint *number;    `09`09/* number of articles in the group,
X`09`09`09`09 if 0, first and last are bogus */
X`7B
X    char command`5BMESSAGE_SIZE`5D, message`5BMESSAGE_SIZE`5D;
X    char group`5BGROUP_NAME_SIZE`5D;
X    static long code, num, count, frst, lst;
X
X    if (!newsgroup) `7B
X`09newsgroup = currentNewsgroup;
X    `7D
X
X    if (!newsgroup) `7B
X`09/* this shouldn't ever happen, but let's be cautious */
X`09ehErrorExitXRN("getgroup(NIL) called with no currentNewsgroup");
X    `7D
X
X    (void) sprintf(command, "GROUP %s", newsgroup->name);
X    if (put_server(command, True) == -1)
X`09ServerDown = True;
X
X    get_data_from_server(message, sizeof(message));
X
X    check_time_out(command, message, sizeof(message), True);
X   `20
X    if (*message != CHAR_OK) `7B
X`09if (atoi(message) != ERR_NOGROUP) `7B
X
X`09    (void) strcat(mybuf, "`09Request was: ");
X`09    (void) strcat(mybuf, command);
X`09    (void) strcat(mybuf, "\n");
X`09    (void) strcat(mybuf, "`09Failing response was: ");
X`09    (void) strcat(mybuf, message);
X`09    ehErrorExitXRN(mybuf);
X`09`7D
X`09mesgPane(XRN_SERIOUS,
X`09"Can't get the group \"%s\", looks like it was deleted out from under us"
V,
X`09`09`09newsgroup->name);
X`09
X`09/* remove the group from active use ??? */
X`09
X`09return(NO_GROUP);
X    `7D
X    currentNewsgroup = newsgroup;
X
X    /* break up the message */
X#if GROUP_NAME_SIZE <= 127
X`09"GROUP_NAME_SIZE is too small" /* this will produce a compilation */
X`09     /* error */
X#endif
X    count = sscanf(message, "%ld %ld %ld %ld %127s",
X`09`09   &code, &num, &frst, &lst, group);
X    assert(count == 5);
X
X    if (number != NIL(int)) `7B
X`09*number = num;
X    `7D
X    if (first != NIL(art_num)) `7B
X`09*first = frst;
X    `7D
X    if (last != NIL(art_num)) `7B
X`09*last = lst;
X    `7D
X
X    return(0);
X`7D
X
X
Xstatic Boolean error_retry = False;
X/*
X * get a list of all active newsgroups and create a structure for each one
X *
X *   returns: void
X */
Xvoid
Xgetactive()
X`7B
X    char command`5BMESSAGE_SIZE`5D, message`5BMESSAGE_SIZE`5D, group`5BGROUP
V_NAME_SIZE`5D;
X    char type`5BMESSAGE_SIZE`5D;
X    struct newsgroup *newsgroup;
X    long first, last;
X    char *ptr;
X    int error_count = 0;
X#ifdef SYSV_REGEX
X    extern char *regcmp();
X    extern char *regex();
X    static char **re_cache = 0;
X#else
X    extern char *re_comp();
X#endif
X    char **re_list = app_resources.ignoreNewsgroupsList, **re_ptr;
X
X#ifdef SYSV_REGEX
X    if (!re_cache && re_list) `7B
X`09int i = 0, re_num;
X`09while (re_list`5Bi`5D) `7B
X`09    i++;
X`09`7D
X`09re_cache = (char **) XtMalloc(sizeof(char *) * (i + 1));
X`09if (!re_cache) `7B
X`09    ehErrorExitXRN("out of memory");
X`09`7D
X`09for (re_num = 0; re_num < i; re_num++) `7B
X`09    if (re_cache`5Bre_num`5D = regcmp(re_list`5Bre_num`5D, 0)) `7B
X`09`09re_num++;
X`09    `7D
X`09`7D
X`09re_cache`5Bre_num`5D = 0;
X    `7D
X    re_list = re_cache;
X#endif
X
X    /*
X     * It *is* necessary to reset currentNewsgroup to 0 when getactive
X     * is called, even though the NNTP server does not forget its idea
X     * of the current newsgroup when a LIST command is issued.  To
X     * understand why this is so, imagine the following sequence of
X     * events:
X     *
X     * 1) User reads newsgroup foo.bar.
X     * 2) User exits from newsgroup, but currentNewsgroup remains
X     *    foo.bar.
X     * 3) User rescans.
X     * 4) The active file that gets sent as a result of the LIST
X     *    command says that there are new articles in foo.bar.
X     * 5) HOWEVER, even though the active file says that, the NNTP
X     *    server has not yet realized that, because it doesn't update
X     *    its idea of what's in the current newsgroup unless a GROUP
X     *    command is issued, i.e., it ignores the LIST data it sends
X     *    over the wire.
X     * 6) User tries to reenter newsgroup.
X     * 7) Since currentNewsgroup is set to foo.bar, xrn doesn't send
X     *    GROUP command.  Therefore, NNTP server does not update its
X     *    idea of low and high articles for the newsgroup.
X     * 8) Therefore, the XHDR commands to get header information from
X     *    the new articles fail, because the server doesn't know that
X     *    those articles exist.
X     *
X     * We solve this problem by always requiring a GROUP command when
X     * first accessing a group after a LIST command, by setting
X     * currentNewsgroup to 0.
X     */
X
X    currentNewsgroup = 0;
X    (void) strcpy(command, "LIST");
X    if (put_server(command, True) == -1)
X`09ServerDown = True;
X    get_data_from_server(message, sizeof(message));
X
X    check_time_out(command, message, sizeof(message), True);
X   `20
X    if (*message != CHAR_OK) `7B
X
X`09(void) strcat(mybuf, "\tRequest was: ");
X`09(void) strcat(mybuf, command);
X`09(void) strcat(mybuf, "\n");
X`09(void) strcat(mybuf, "\tFailing response was: ");
X`09(void) strcat(mybuf, message);
X`09ehErrorExitXRN(mybuf);
X    `7D
X
X    for (;;) `7B
X`09get_data_from_server(message, sizeof(message));
X`09if (ServerDown) `7B
X`09    check_time_out(command, message, sizeof(message));
X`09    continue;
X`09`7D
X`09
X`09/* the list is ended by a '.' at the beginning of a line */
X`09if ((message`5B0`5D == '.') && (message`5B1`5D == '\0')) `7B
X`09    break;
X`09`7D
X
X`09if (*message == '\0') `7B
X`09    continue;
X`09`7D
X`09/* server returns: group last first y/m/x/=otherGroup */
X#if GROUP_NAME_SIZE <= 127
X`09"GROUP_NAME_SIZE is too small" /* this will produce a compilation */
X`09     `09`09`09       /* error */
X#endif
X`09if (sscanf(message, "%127s %ld %ld %s", group, &last, &first, type) != 4)
V `7B
X`09    mesgPane(XRN_SERIOUS, "Bogus active file entry, skipping\n%s", messag
Ve);
X`09    error_count++;
X`09    if (error_count++ > 20) `7B`09/* More than 20 bad entries in a row */
X`09`09if (!error_retry) `7B
X`09`09    mesgPane(XRN_SERIOUS, "Too many errors.. attempting restart");
X`09`09    error_retry = True;
X`09`09    start_server(NIL(char));
X`09`09    getactive();`09`09
X`09`09    return;
X`09`09`7D else `7B
X`09`09    ehErrorExitXRN("Repeated errors from getactive(); exiting");
X`09`09`7D
X`09    `7D
X`09    continue;
X`09`7D
X
X`09error_count = 0;
X`09if (type`5B0`5D == 'x') `7B
X`09    /* bogus newsgroup, pay no attention to it */
X`09    continue;
X`09`7D
X
X`09if (type`5B0`5D == '=') `7B
X`09    /* This newsgroup doesn't exist, it's just an alias */
X`09    continue;
X`09`7D
X
X#ifndef NO_BOGUS_GROUP_HACK
X`09/* determine if the group name is screwed up - check for jerks who
X`09 * create group names like: alt.music.enya.puke.puke.pukeSender:`20
X`09 * - note that there is a ':' in the name of the group... */
X
X`09if (strpbrk(group, ":! \n\t")) `7B
X`09    /* bogus newsgroup - can't have a separator */
X`09    continue;
X`09`7D
X#endif /* NO_BOGUS_GROUP_HACK */
X
X`09for (re_ptr = re_list; re_ptr && *re_ptr; re_ptr++) `7B
X#ifdef SYSV_REGEX
X`09    if (regex(*re_ptr, group))
X#else
X`09    if ((! re_comp(*re_ptr)) && re_exec(group))
X#endif
X`09    `7B
X#ifdef DEBUG
X`09`09fprintf(stderr, "Ignoring %s.\n", group);
X#endif
X`09`09break;
X`09    `7D
X`09`7D
X`09if (re_ptr && *re_ptr) `7B
X`09    continue;
X`09`7D
X
X `09if (first == 0) `7B
X`09    first = 1;
X`09`7D
X
X`09if (!avl_lookup(NewsGroupTable, group, &ptr)) `7B
X
X`09    /* no entry, create a new group */
X`09    newsgroup = ALLOC(struct newsgroup);
X`09    newsgroup->name = (char *) XtNewString(group);
X`09    newsgroup->newsrc = NOT_IN_NEWSRC;
X`09    newsgroup->status = NG_NOENTRY;
X`09    newsgroup->first = first;
X`09    newsgroup->last = last;
X`09    newsgroup->initial = first;
X`09    newsgroup->nglist = 0;
X`09    newsgroup->artStatus = NULL;
X`09   `20
X`09    switch (type`5B0`5D) `7B
X`09`09case 'y':
X`09`09newsgroup->status `7C= NG_POSTABLE;
X`09`09break;
X
X`09`09case 'm':
X`09`09newsgroup->status `7C= NG_MODERATED;
X`09`09break;
X
X`09`09case 'n':
X`09`09newsgroup->status `7C= NG_UNPOSTABLE;
X`09`09break;
X
X#ifndef INN
X`09`09case '=':
X`09`09newsgroup->status `7C= NG_ALIAS;
X#endif
X`09`09default:
X
X`09`09/*
X`09`09fprintf(stderr, "unexpected type (%s) for newsgroup %s\n",
X`09`09`09type, newsgroup->name);
X`09`09*/
X`09`09break;
X
X`09    `7D
X`09
X`09    if (avl_insert(NewsGroupTable, newsgroup->name,
X`09`09`09   (char *) newsgroup) < 0) `7B
X`09`09 ehErrorExitXRN("out of memory");
X`09    `7D
X
X`09    ActiveGroupsCount++;
X`09   `20
X`09`7D else `7B
X`09   `20
X`09    /*
X`09     * entry exists, use it; must be a rescanning call
X`09     *
X`09     * just update the first and last values and adjust the
X`09     * articles array
X`09     */
X`09   `20
X`09    newsgroup = (struct newsgroup *) ptr;
X
X`09    /*
X`09     * only allow last to increase or stay the same
X`09     * - don't allow bogus last values to trash a group
X`09     */
X`09    if (IS_SUBSCRIBED(newsgroup) && last >= newsgroup->last) `7B
X`09`09/* XXX really should save up the resync and use the GROUP info also */
X`09`09articleArrayResync(newsgroup, first, last, 1);
X`09    `7D
X`09`7D
X    `7D
X
X    error_retry = False;
X    return;
X`7D
X
X#if !defined(FIXED_C_NEWS_ACTIVE_FILE) && !defined (FIXED_ACTIVE_FILE)
X/*
X * check the case where the first article number information is not
X * being updated.
X *
X * also check the case where the first and last article numbers are equal
X * - unfortunately, this means two different things:
X *   1) there are no articles in the group
X *   2) there is one article in the group
X *
X * - so, to get rid of the ambiguity, we make a GROUP call
X *   and look at the 'number' of articles field to determine
X *   whether there are 0 or 1 articles
X */
Xvoid
XfixLowArticleNumbers()
X`7B
X    avl_generator *gen;
X    char *key, *value;
X    art_num first, last;
X    int number;
X
X    /* check out first == last groups */
X    gen = avl_init_gen(NewsGroupTable, AVL_FORWARD);
X    if (! gen) `7B
X`09 ehErrorExitXRN("out of memory");
X    `7D
X
X    while (avl_gen(gen, &key, &value)) `7B
X`09struct newsgroup *newsgroup = (struct newsgroup *) value;
X
X`09if (IS_SUBSCRIBED(newsgroup)) `7B
X`09    if (getgroup(newsgroup, &first, &last, &number) != 0) continue;
X`09    if (newsgroup->artStatus) `7B
X`09`09articleArrayResync(newsgroup, first, last, number);
X`09    `7D else `7B
X`09`09newsgroup->first = first;
X`09`09newsgroup->last = last;
X`09    `7D
X`09    if (newsgroup->initial < newsgroup->first)
X`09`09newsgroup->initial = newsgroup->first;
X`09`7D
X    `7D
X    avl_free_gen(gen);
X
X    return;
X`7D
X#endif
Xstatic int popupCount = 0;
Xextern Boolean CBretVal;`09`09/* Confirmation box value;set from timer */
Xstatic XtIntervalId tryTimer = 0;
X
Xstatic void popDown()
X`7B
X    CBretVal = True;
X    tryTimer = 0;
X`7D
Xstatic Boolean AnotherTry(errorType)
Xint errorType;
X`7B
X    int i;
X    Boolean status;
X
X    popupCount++;
X    if (popupCount < app_resources.retryPopupCount) `7B
X`09for (i = 0; i < app_resources.retryPause; i++) `7B
X`09    xthHandleAllPendingEvents();
X`09    sleep(1);
X`09`7D
X`09return True;
X    `7D
X    allowErrors = True;
X    if (app_resources.retryPopupTimeout > 0) `7B
X`09tryTimer = XtAddTimeOut(app_resources.retryPopupTimeout * 1000,
X`09`09`09`09(XtTimerCallbackProc) popDown, 0);
X    `7D
X    if (errorType == 0) `7B
X`09status = ConfirmationBox (TopLevel,
X`09"Failed to reconnect to the NNTP server (server_init), retry?");
X    `7D else `7B
X`09status = ConfirmationBox (TopLevel,
X`09"Invalid response from the NNTP server (server_init), retry?");
X    `7D
X    if (tryTimer != 0) `7B
X`09XtRemoveTimeOut(tryTimer);
X`09tryTimer = 0;
X    `7D
X    popupCount = 0;
X    allowErrors = False;
X    return status;
X`7D
X
X/*
X * initiate a connection to the news server
X *
X * nntpserver is the name of an alternate server (use the default if NULL)
X *
X * the server eventually used is remembered, so if this function is called
X * again (for restarting after a timeout), it will use it.
X *
X *   returns: void
X *
X */
Xvoid
Xstart_server(nntpserver)
Xchar *nntpserver;
X`7B
X    static char *server = NIL(char);   /* for restarting */
X    int response, retryLimit;
X
X    if (server == NIL(char)) `7B
X`09
X`09if (nntpserver != NIL(char)) `7B
X`09    server = nntpserver;
X`09
X`09`7D else `7B
X`09   `20
X`09    /* Note: INN's getserverbyfile will ignore the filename argument */
X`09    if ((server = getserverbyfile(SERVER_FILE)) == NULL) `7B
X`09`09mesgPane(XRN_SERIOUS, "Can't get the name of the news server from `60%
Vs'.%s",
X`09`09`09 SERVER_FILE,
X#ifndef VMS
X`09`09"Either fix this file, or put NNTPSERVER in your environment."
X#else
X`09`09"Either fix this file, or define logical NNTPSERVER"
X#endif
X`09`09);
X`09`09ehErrorExitXRN("");
X`09    `7D
X`09`7D
X    `7D
X
X    for (retryLimit = 0;
X`09 retryLimit < app_resources.retryLimit * app_resources.retryPopupCount;
X`09 retryLimit++) `7B
X`09if ((response = server_init(server)) < 0) `7B
X`09    if (XtIsRealized(TopLevel) && retryLimit == 0) `7B
X`09`09xmSetIconAndName(LostIcon);
X`09`09XFlush(XtDisplay(TopLevel));
X`09    `7D
X`09    close_server();
X`09    if (!AnotherTry(0)) `7B
X`09`09ehCleanExitXRN(1);
X`09    `7D
X`09    continue;
X`09`7D
X`09if (handle_server_response(response, server) < 0) `7B
X`09    close_server();
X`09    if (!AnotherTry(1)) `7B
X`09`09ehCleanExitXRN();
X`09    `7D
X`09    continue;
X`09`7D else `7B
X`09    ServerDown = False;
X`09    popupCount = 0;
X`09    return;
X`09`7D
X    `7D
X   `20
X    ehCleanExitXRN();
X    ServerDown = True;
X    popupCount = 0;
X    return;
X`7D
X
X/*
X * close an outstanding connection to the NNTP server
X */
Xvoid stop_server()
X`7B
X    currentNewsgroup = 0;
X    close_server();
X`7D
X
X/*
X * get a list of subject lines for the current group in the range
X *  'first' to 'last'
X *
X *   returns: void
X *
X * Note that XHDR is not part of the rfc977 standard, but is implemented
X * by the Berkeley NNTP server
X *
X */
Xvoid
Xgetsubjectlist(newsgroup, artfirst, artlast, unreadonly)
Xstruct newsgroup *newsgroup;
Xart_num artfirst;
Xart_num artlast;
Xint unreadonly;
X`7B
X    char command`5BMESSAGE_SIZE`5D, message`5BMESSAGE_SIZE`5D;
X    char *subjectline;
X    art_num number;
X    art_num first, last;
X
X    if (SETNEWSGROUP(newsgroup)) `7B
X`09return;
X    `7D
X
X    first = artfirst;
X    while (first <= artlast) `7B
X`09if (currentArticles`5BINDEX(first)`5D.subject != NIL(char) `7C`7C
X`09    (unreadonly && IS_READ(newsgroup->artStatus`5BINDEX(first)`5D))) `7B
X`09     first++;
X`09     continue;
X`09`7D
X`09for (last = first + 1; last <= artlast; last++) `7B
X`09    if (currentArticles`5BINDEX(last)`5D.subject != NIL(char) `7C`7C
X`09`09(unreadonly && IS_READ(newsgroup->artStatus`5BINDEX(last)`5D))) `7B
X`09`09break;
X`09    `7D
X`09`7D
X`09last--;
X
X`09(void) sprintf(command, "XHDR subject %ld-%ld", first, last);
X`09if (put_server(command, True) == -1)
X`09    ServerDown = True;
X`09get_data_from_server(message, sizeof(message));
X
X`09check_time_out(command, message, sizeof(message), True);
X
X`09/* check for errors */
X`09if (*message != CHAR_OK) `7B
X`09    mesgPane(XRN_SERIOUS,
X"XRN: serious error, your NNTP server does not have XHDR support.\n\
XEither you are running a pre-1.5 NNTP server or XHDR has\n\
Xnot been defined in 'nntp/common/conf.h'\n\
XXRN requires XHDR support to run.");
X`09    return;
X`09`7D
X
X`09for(;;) `7B
X
X`09    get_data_from_server(message, sizeof(message));
X
X`09    if (ServerDown) `7B
X`09`09check_time_out(command, message, sizeof(message), False);
X`09`09continue;
X`09    `7D
X`09
X`09    if ((message`5B0`5D == '.') && (message`5B1`5D == '\0')) `7B
X`09`09break;
X`09    `7D
X
X`09    /*
X`09     * message is of the form:
X`09     *
X`09     *    Number SubjectLine
X`09     *
X`09     *    203 Re: Gnumacs Bindings
X`09     *
X`09     * must get the number since not all subjects will be returned
X`09     */
X
X`09    number = atol(message);
X`09    subjectline = index(message, ' ');
X
X`09    if (number == 0 `7C`7C subjectline == NULL) `7B
X`09`09mesgPane(XRN_SERIOUS,
X`09`09    "Bogus subject returned from server (%s), continuing..",
X`09`09     message);
X`09`09continue;
X`09    `7D
X`09    currentArticles`5BINDEX(number)`5D.subject = string_pool(++subjectlin
Ve);
X`09    SET_AVAIL(newsgroup->artStatus`5BINDEX(number)`5D);
X`09`7D
X`09first = last + 1;
X    `7D
X    return;
X`7D
X
X/*
X * get a list of author lines for the current group in the range
X *  'first' to 'last'
X *
X *   returns: void
X *
X * Note that XHDR is not part of the rfc977 standard, but is implemented
X * by the Berkeley NNTP server
X *
X */
Xvoid
Xgetauthorlist(newsgroup, artfirst, artlast, unreadonly)
Xstruct newsgroup *newsgroup;
Xart_num artfirst;
Xart_num artlast;
Xint unreadonly;
X`7B
X    char command`5BMESSAGE_SIZE`5D, message`5BMESSAGE_SIZE`5D;
X    char *author, *end, *brackbeg, *brackend;
X    art_num number;
X    art_num first, last;
X
X    if (SETNEWSGROUP(newsgroup)) `7B
X`09return;
X    `7D
X    first = artfirst;
X    while (first <= artlast) `7B
X`09if (currentArticles`5BINDEX(first)`5D.author != NIL(char) `7C`7C
X`09    (unreadonly && IS_READ(newsgroup->artStatus`5BINDEX(first)`5D))) `7B
X`09    first++;
X`09    continue;
X`09`7D
X
X`09for (last = first + 1; last <= artlast; last++) `7B
X`09    if (currentArticles`5BINDEX(last)`5D.author != NIL(char) `7C`7C
X`09`09(unreadonly && IS_READ(newsgroup->artStatus`5BINDEX(last)`5D))) `7B
X`09`09break;
X`09    `7D
X`09`7D
X`09last--;
X
X`09(void) sprintf(command, "XHDR from %ld-%ld", first, last);
X`09if (put_server(command, True) == -1)
X`09    ServerDown = True;
X`09get_data_from_server(message, sizeof(message));
X
X`09check_time_out(command, message, sizeof(message), True);
X
X`09/* check for errors */
X`09if (*message != CHAR_OK) `7B
X`09    mesgPane(XRN_SERIOUS,
X"XRN: serious error, your NNTP server does not have XHDR support.\n\
XEither you are running a pre-1.5 NNTP server or XHDR has\n\
Xnot been defined in 'nntp/common/conf.h'\n\
XXRN requires XHDR support to run.");
X`09    return;
X`09`7D
X   `20
X`09for(;;) `7B
X
X`09    get_data_from_server(message, sizeof(message));
X`09    if (ServerDown) `7B
X`09`09check_time_out(command, message, sizeof(message), False);
X`09`09continue;
X`09    `7D
X`09
X`09    if ((message`5B0`5D == '.') && (message`5B1`5D == '\0')) `7B
X`09`09break;
X`09    `7D
X
X`09    /*
X`09     * message is of the form:
X`09     *
X`09     *    Number Author
X`09     *
X`09     *    201 ricks@shambhala (Rick L. Spickelmier)
X`09     *    202 Jens Thommasen <jens@ifi.uio.no>
X`09     *    203 <oea@ifi.uio.no>
X`09     *    302 "Rein Tollevik" <rein@ifi.uio.no>
X`09     *
X`09     * must get the number since not all authors will be returned
X`09     */
X
X`09    number = atol(message);
X`09    if (app_resources.authorFullName) `7B
X`09`09/* Can be made fancyer at the expence of extra cpu time */
X`09`09author = index(message, ' ');
X`09`09if (author == NIL(char)) `7B
X`09`09    strcat(message, " (None) ");
X`09`09    author = index(message, ' ');
X`09`09`7D
X`09`09assert(author != NIL(char));
X`09`09author++;
X
X`09`09/* First check for case 1, user@domain ("name") -> name */
X
X`09`09brackbeg = index(message, '(');
X`09`09brackend = index(message, '\0') - sizeof(char);
X`09`09/* brackend now points at the last ')' if this is case 1 */
X`09`09if (brackbeg != NIL(char) && (brackend > brackbeg) &&
X`09`09    (*brackend == ')')) `7B
X`09`09    author = brackbeg + sizeof(char);
X
X`09`09    /* Remove surrounding quotes ? */
X`09`09    if ((*author == '"') && (*(brackend - sizeof(char)) == '"')) `7B
X`09`09`09author++;
X`09`09`09brackend--;
X`09`09    `7D
X
X`09`09    /* Rather strip trailing spaces here */
X
X`09`09    *brackend = '\0';
X`09`09`7D else `7B
X`09`09    /* Check for case 2, "name" <user@domain> -> name */
X`09`09    brackbeg = index(message, '<');
X`09`09    if (brackbeg != NIL(char) && (index(brackbeg, '>') != NIL(char))
X`09`09`09&& (brackbeg > message)) `7B
X`09`09`09while (*--brackbeg == ' ')
X`09`09`09    ;
X
X`09`09`09/* Remove surrounding quotes ? */
X`09`09`09if ((*brackbeg == '"') && (*author ==  '"')) `7B
X`09`09`09    *brackbeg = '\0';
X`09`09`09    author++;
X
X`09`09`09    /* Rather strip trailing spaces here */
X
X`09`09`09`7D else `7B
X`09`09`09    *++brackbeg = '\0';
X`09`09`09`7D
X`09`09    `7D else `7B
X
X`09`09`09/*`20
X`09`09`09 * Check for case 3, <user@domain> -> usr@domain
X`09`09`09 *
X`09`09`09 * Don't need to do this again:
X`09`09`09 * brackbeg = index(message, '<');
X`09`09`09 */
X
X`09`09`09brackend = index(message, '>');
X`09`09`09if ((author == brackbeg) && (brackend != NIL(char))) `7B
X`09`09`09    author++;
X`09`09`09    *brackend = '\0';
X`09`09`09`7D else `7B
X`09`09`09    if ((end = index(author, ' ')) != NIL(char)) `7B
X`09`09`09`09*end = '\0';
X`09`09`09    `7D
X`09`09`09`7D
X`09`09    `7D
X`09`09`7D
X`09    `7D else `7B
X`09`09if ((author = index(message, '<')) == NIL(char)) `7B
X`09`09    /* first form */
X`09`09    author = index(message, ' ');
X`09`09    if (author == NIL(char)) `7B
X`09`09`09strcat(message, " (None) ");
X`09`09`09author = index(message, ' ');
X`09`09    `7D
X`09`09    assert(author != NIL(char));
X`09`09    author++;
X`09`09    if ((end = index(author, ' ')) != NIL(char)) `7B
X`09`09`09*end = '\0';
X`09`09    `7D
X`09`09`7D else `7B
X`09`09    /* second form */
X`09`09    author++;
X`09`09    if ((end = index(author, '>')) != NIL(char)) `7B
X`09`09`09*end = '\0';
X`09`09    `7D
X`09`09`7D
X`09    `7D
X`09    /*
X`09     * do a final trimming - just in case the authors name ends
X`09     * in spaces or tabs - it does happen
X`09     */
X`09    end = author + strlen(author) - 1;
X`09    while ((end > author) && ((*end == ' ') `7C`7C (*end == '\t'))) `7B
X`09`09*end = '\0';
X`09`09end--;
X`09    `7D
X`09    currentArticles`5BINDEX(number)`5D.author = string_pool(author);
X`09`7D
X`09first = last + 1;
X    `7D
X    return;
X`7D
X
X/*
X * get a list of number of lines per message for the current group in the
X *  range 'first' to 'last'
X *
X *   returns: void
X *
X * Note that XHDR is not part of the rfc977 standard, but is implemented
X * by the Berkeley NNTP server
X *
X */
Xvoid
Xgetlineslist(newsgroup, artfirst, artlast, unreadonly)
Xstruct newsgroup *newsgroup;
Xart_num artfirst;
Xart_num artlast;
Xint unreadonly;
X`7B
X    char command`5BMESSAGE_SIZE`5D, message`5BMESSAGE_SIZE`5D;
X    char *numoflines, *end;
X    art_num number;
X    int lcv;
X    art_num first, last;
X`20
X    if (SETNEWSGROUP(newsgroup)) `7B
X`09return;
X    `7D
X
X    if (!app_resources.displayLineCount) `7B
X`09return;
X    `7D
X
X    first = artfirst;
X    while (first <= artlast) `7B
X`09if (currentArticles`5BINDEX(first)`5D.lines != NIL(char) `7C`7C
X`09    (unreadonly && IS_READ(newsgroup->artStatus`5BINDEX(first)`5D))) `7B
X`09    first++;
X`09    continue;
X`09`7D
X
X`09for (last = first + 1; last <= artlast; last++) `7B
X`09    if (currentArticles`5BINDEX(last)`5D.lines != NIL(char) `7C`7C
X`09`09(unreadonly && IS_READ(newsgroup->artStatus`5BINDEX(last)`5D))) `7B
X`09`09break;
X`09    `7D
X`09`7D
X`09last--;
X
X`09(void) sprintf(command, "XHDR lines %ld-%ld", first, last);
X`09if (put_server(command, True) == -1)
X`09    ServerDown = True;
X`09get_data_from_server(message, sizeof(message));
X
X`09check_time_out(command, message, sizeof(message), True);
X
X`09/* check for errors */
X`09if (*message != CHAR_OK) `7B
X`09    mesgPane(XRN_SERIOUS,
X"XRN: serious error, your NNTP server does not have XHDR support.\n\
XEither you are running a pre-1.5 NNTP server or XHDR has\n\
Xnot been defined in 'nntp/common/conf.h'\n\
XXRN requires XHDR support to run.");
X`09    return;
X`09`7D
X
X`09for(;;) `7B
X
X`09    get_data_from_server(message, sizeof(message));
X`09    if (ServerDown) `7B
X`09`09check_time_out(command, message, sizeof(message), False);
X`09`09continue;
X`09    `7D
X
X`09    if ((message`5B0`5D == '.') && (message`5B1`5D == '\0')) `7B
X`09`09break;
X`09    `7D
X
X`09    /*
X`09     * message is of the form:
X`09     *
X`09     *    Number NumberOfLines
X`09     *
X`09     *    203 ##
X`09     *
X`09     * must get the number since not all subjects will be returned
X`09     */
X
X`09    number = atol(message);
X`09    numoflines = index(message, ' ');
X`09    assert(numoflines != NIL(char));
X`09    numoflines++;
X`09    if ((end = index(numoflines, ' ')) != NIL(char)) `7B
X`09`09*end = '\0';
X`09    `7D
X`09    if (numoflines`5B0`5D != '(') `7B
X`09`09numoflines`5ButStrlen(numoflines)+1`5D = '\0';
X`09`09numoflines`5ButStrlen(numoflines)`5D = '`5D';
X`09`09for (lcv = utStrlen(numoflines); lcv >= 0; lcv--) `7B
X`09`09    numoflines`5Blcv+1`5D = numoflines`5Blcv`5D;
X`09`09`7D
X`09`09numoflines`5B0`5D = '`5B';
X`09    `7D else `7B
X`09`09numoflines`5B0`5D = '`5B';
X`09`09numoflines`5ButStrlen(numoflines)-1`5D = '`5D';
X`09    `7D
X`09    if (strcmp(numoflines, "`5Bnone`5D") == 0) `7B
X`09`09(void) strcpy(numoflines, "`5B?`5D");
X`09    `7D
X`09    currentArticles`5BINDEX(number)`5D.lines = string_pool(numoflines);
X`09`7D
X`09first = last + 1;
X    `7D
X    return;
X`7D
X
X/*
X * get a list of message IDs for the current group in the range
X *  'first' to 'last'
X *
X *   returns: void
X *
X * Note that XHDR is not part of the rfc977 standard, but is implemented
X * by the Berkeley NNTP server
X *
X */
Xvoid
Xgetmsgidlist(newsgroup, artfirst, artlast, unreadonly)
Xstruct newsgroup *newsgroup;
Xart_num artfirst;
Xart_num artlast;
Xint unreadonly;
X`7B
X    char command`5BMESSAGE_SIZE`5D, message`5BMESSAGE_SIZE`5D;
X    char *messageid;
X    art_num number;
X    art_num first, last;
X
X    if (SETNEWSGROUP(newsgroup)) `7B
X`09return;
X    `7D
X
X    first = artfirst;
X    while (first <= artlast) `7B
X`09if (currentArticles`5BINDEX(first)`5D.msgid != NIL(char) `7C`7C
X`09    (unreadonly && IS_READ(newsgroup->artStatus`5BINDEX(first)`5D))) `7B
X`09     first++;
X`09     continue;
X`09`7D
X`09for (last = first + 1; last <= artlast; last++) `7B
X`09    if (currentArticles`5BINDEX(last)`5D.msgid != NIL(char) `7C`7C
X`09`09(unreadonly && IS_READ(newsgroup->artStatus`5BINDEX(last)`5D))) `7B
X`09`09break;
X`09    `7D
X`09`7D
X`09last--;
X
X`09(void) sprintf(command, "XHDR Message-ID %ld-%ld", first, last);
X`09if (put_server(command, True) == -1)
X`09    ServerDown = True;
X`09get_data_from_server(message, sizeof(message));
X
X`09check_time_out(command, message, sizeof(message), True);
X
X`09/* check for errors */
X`09if (*message != CHAR_OK) `7B
X`09    mesgPane(XRN_SERIOUS,
X"XRN: serious error, your NNTP server does not have XHDR support.\n\
XEither you are running a pre-1.5 NNTP server or XHDR has\n\
Xnot been defined in 'nntp/common/conf.h'\n\
XXRN requires XHDR support to run.");
X`09    return;
X`09`7D
X
X`09for(;;) `7B
X
X`09    get_data_from_server(message, sizeof(message));
X
X`09    if (ServerDown) `7B
X`09`09check_time_out(command, message, sizeof(message), False);
X`09`09continue;
X`09    `7D
X`09
X`09    if ((message`5B0`5D == '.') && (message`5B1`5D == '\0')) `7B
X`09`09break;
X`09    `7D
X
X`09    /*
X`09     * message is of the form:
X`09     *
X`09     *    Number MessageID
X`09     *
X`09     *    203 <12345@foo.bar.baz>
X`09     *
X`09     */
X
X`09    number = atol(message);
X`09    messageid = index(message, ' ');
X
X`09    if (number == 0 `7C`7C messageid == NULL) `7B
X`09`09mesgPane(XRN_SERIOUS,
X`09`09    "Bogus message ID returned from server (%s), continuing..",
X`09`09     message);
X`09`09continue;
X`09    `7D
X`09    currentArticles`5BINDEX(number)`5D.msgid = string_pool(++messageid);
X`09`7D
X`09first = last + 1;
X    `7D
X    return;
X`7D
X
X/*
X * split - divide a string into fields, like awk split()
X * Copied from Geoffrey Collyer's `60nov' package.
X */
Xstatic int`09`09`09/* number of fields, including overflow */
Xsplit(string, fields, nfields, sep)
Xchar *string;
Xchar *fields`5B`5D;`09`09`09/* list is not NULL-terminated */
Xint nfields;`09`09`09/* number of entries available in fields`5B`5D */
Xchar *sep;`09`09`09/* "" white, "c" single char, "ab" `5Bab`5D+ */
X`7B
X`09register char *p = string;
X`09register char c;`09`09`09/* latest character */
X`09register char sepc = sep`5B0`5D;
X`09register char sepc2;
X`09register int fn;
X`09register char **fp = fields;
X`09register char *sepp;
X`09register int trimtrail;
X
X`09/* white space */
X`09if (sepc == '\0') `7B
X`09`09while ((c = *p++) == ' ' `7C`7C c == '\t')
X`09`09`09continue;
X`09`09p--;
X`09`09trimtrail = 1;
X`09`09sep = " \t";`09/* note, code below knows this is 2 long */
X`09`09sepc = ' ';
X`09`7D else
X`09`09trimtrail = 0;
X`09sepc2 = sep`5B1`5D;`09`09/* now we can safely pick this up */
X
X`09/* catch empties */
X`09if (*p == '\0')
X`09`09return(0);
X
X`09/* single separator */
X`09if (sepc2 == '\0') `7B
X`09`09fn = nfields;
X`09`09for (;;) `7B
X`09`09`09*fp++ = p;
X`09`09`09fn--;
X`09`09`09if (fn == 0)
X`09`09`09`09break;
X`09`09`09while ((c = *p++) != sepc)
X`09`09`09`09if (c == '\0')
X`09`09`09`09`09return(nfields - fn);
X`09`09`09*(p-1) = '\0';
X`09`09`7D
X`09`09/* we have overflowed the fields vector -- just count them */
X`09`09fn = nfields;
X`09`09for (;;) `7B
X`09`09`09while ((c = *p++) != sepc)
X`09`09`09`09if (c == '\0')
X`09`09`09`09`09return(fn);
X`09`09`09fn++;
X`09`09`7D
X`09`09/* not reached */
X`09`7D
X
X`09/* two separators */
X`09if (sep`5B2`5D == '\0') `7B
X`09`09fn = nfields;
X`09`09for (;;) `7B
X`09`09`09*fp++ = p;
X`09`09`09fn--;
X`09`09`09while ((c = *p++) != sepc && c != sepc2)
X`09`09`09`09if (c == '\0') `7B
X`09`09`09`09`09if (trimtrail && **(fp-1) == '\0')
X`09`09`09`09`09`09fn++;
X`09`09`09`09`09return(nfields - fn);
X`09`09`09`09`7D
X`09`09`09if (fn == 0)
X`09`09`09`09break;
X`09`09`09*(p-1) = '\0';
X`09`09`09while ((c = *p++) == sepc `7C`7C c == sepc2)
X`09`09`09`09continue;
X`09`09`09p--;
X`09`09`7D
X`09`09/* we have overflowed the fields vector -- just count them */
X`09`09fn = nfields;
X`09`09while (c != '\0') `7B
X`09`09`09while ((c = *p++) == sepc `7C`7C c == sepc2)
X`09`09`09`09continue;
X`09`09`09p--;
X`09`09`09fn++;
X`09`09`09while ((c = *p++) != '\0' && c != sepc && c != sepc2)
X`09`09`09`09continue;
X`09`09`7D
X`09`09/* might have to trim trailing white space */
X`09`09if (trimtrail) `7B
X`09`09`09p--;
X`09`09`09while ((c = *--p) == sepc `7C`7C c == sepc2)
X`09`09`09`09continue;
X`09`09`09p++;
X`09`09`09if (*p != '\0') `7B
X`09`09`09`09if (fn == nfields+1)
X`09`09`09`09`09*p = '\0';
X`09`09`09`09fn--;
X`09`09`09`7D
X`09`09`7D
X`09`09return(fn);
X`09`7D
X
X`09/* n separators */
X`09fn = 0;
X`09for (;;) `7B
X`09`09if (fn < nfields)
X`09`09`09*fp++ = p;
X`09`09fn++;
X`09`09for (;;) `7B
X`09`09`09c = *p++;
X`09`09`09if (c == '\0')
X`09`09`09`09return(fn);
X`09`09`09sepp = sep;
X`09`09`09while ((sepc = *sepp++) != '\0' && sepc != c)
X`09`09`09`09continue;
X`09`09`09if (sepc != '\0')`09/* it was a separator */
X`09`09`09`09break;
X`09`09`7D
X`09`09if (fn < nfields)
X`09`09`09*(p-1) = '\0';
X`09`09for (;;) `7B
X`09`09`09c = *p++;
X`09`09`09sepp = sep;
X`09`09`09while ((sepc = *sepp++) != '\0' && sepc != c)
X`09`09`09`09continue;
X`09`09`09if (sepc == '\0')`09/* it wasn't a separator */
X`09`09`09`09break;
X`09`09`7D
X`09`09p--;
X`09`7D
X
X`09/* not reached */
X`7D
X
X/*
X * get a list of reference lines for the current group in the range
X *  'first' to 'last'
X *
X *   returns: void
X *
X * Note that XHDR is not part of the rfc977 standard, but is implemented
X * by the Berkeley NNTP server
X *
X */
Xvoid
Xgetrefslist(newsgroup, artfirst, artlast, unreadonly)
Xstruct newsgroup *newsgroup;
Xart_num artfirst;
Xart_num artlast;
Xint unreadonly;
X`7B
X    char command`5BMESSAGE_SIZE`5D, message`5BMESSAGE_SIZE`5D;
X    char *refstr;
X    char *refs`5BDEFREFS`5D;
X    int nrefs;
X    int i, j;
X    art_num number;
X    art_num first, last;
X
X    if (SETNEWSGROUP(newsgroup)) `7B
X`09return;
X    `7D
X
X    first = artfirst;
X    while (first <= artlast) `7B
X`09if (currentArticles`5BINDEX(first)`5D.refs`5B0`5D != NIL(char) `7C`7C
X`09    (unreadonly && IS_READ(newsgroup->artStatus`5BINDEX(first)`5D))) `7B
X`09     first++;
X`09     continue;
X`09`7D
X`09for (last = first + 1; last <= artlast; last++) `7B
X`09    if (currentArticles`5BINDEX(last)`5D.refs`5B0`5D != NIL(char) `7C`7C
X`09`09(unreadonly && IS_READ(newsgroup->artStatus`5BINDEX(last)`5D))) `7B
X`09`09break;
X`09    `7D
X`09`7D
X`09last--;
X
X`09(void) sprintf(command, "XHDR references %ld-%ld", first, last);
X`09if (put_server(command, True) == -1)
X`09    ServerDown = True;
X`09get_data_from_server(message, sizeof(message));
X
X`09check_time_out(command, message, sizeof(message), True);
X
X`09/* check for errors */
X`09if (*message != CHAR_OK) `7B
X`09    mesgPane(XRN_SERIOUS,
X"XRN: serious error, your NNTP server does not have XHDR support.\n\
XEither you are running a pre-1.5 NNTP server or XHDR has\n\
Xnot been defined in 'nntp/common/conf.h'\n\
XXRN requires XHDR support to run.");
X`09    return;
X`09`7D
X
X`09for(;;) `7B
X
X`09    get_data_from_server(message, sizeof(message));
X
X`09    if (ServerDown) `7B
X`09`09check_time_out(command, message, sizeof(message), False);
X`09`09continue;
X`09    `7D
X`09
X`09    if ((message`5B0`5D == '.') && (message`5B1`5D == '\0')) `7B
X`09`09break;
X`09    `7D
X
X`09    /*
X`09     * message is of the form:
X`09     *
X`09     *    Number refs
X`09     *
X`09     *    203 <12345@foo.bar.baz>
X`09     *
X`09     */
X
X`09    number = atol(message);
X`09    refstr = index(message, ' ');
X
X`09    if (number == 0 `7C`7C refstr == NULL) `7B
X`09`09mesgPane(XRN_SERIOUS,
X`09`09    "Bogus message ID returned from server (%s), continuing..",
X`09`09     message);
X`09`09continue;
X`09    `7D
X
X`09    currentArticles`5BINDEX(number)`5D.refs`5B0`5D =`20
X`09    currentArticles`5BINDEX(number)`5D.refs`5B1`5D =`20
X`09    currentArticles`5BINDEX(number)`5D.refs`5B2`5D = string_pool("");
X`09    nrefs = split(++refstr, refs, DEFREFS, " ,");
X`09    if (nrefs > DEFREFS) nrefs = DEFREFS;
X`09    for (i = 0, j = nrefs - 1; i <= 2 && j >= 0; j--, i++) `7B
X`09`09currentArticles`5BINDEX(number)`5D.refs`5Bi`5D = string_pool(refs`5Bj`
V5D);
X`09    `7D
X`09`7D
X`09first = last + 1;
X    `7D
X    return;
X`7D
X
X
X/*
X * get the overview data for a list of articles.
X *
X *   returns: status
X *
X * This function requires a NNTP server that supports XOVER and an overview
X * database.`20
X *
X */
XBoolean
Xgetoverview(newsgroup, artfirst, artlast, unreadonly)
Xstruct newsgroup *newsgroup;
Xart_num artfirst;
Xart_num artlast;
Xint unreadonly;
X`7B
X    char command`5BMESSAGE_SIZE`5D, message`5BMESSAGE_SIZE`5D;
X    char *subjectline;
X    char *fields`5BMAXFIELDS`5D, *refs`5BDEFREFS`5D;
X    char authorline`5BMESSAGE_SIZE`5D;
X    char *author, *end, *brackbeg, *brackend;
X    char *numoflines;
X    int nf, nrefs, len;
X    int i, j;
X    int lcv;
X    art_num number;
X    art_num first, last;
X
X    if (SETNEWSGROUP(newsgroup)) `7B
X`09return False;
X    `7D
X
X    first = artfirst;
X    while (first <= artlast) `7B
X`09if (currentArticles`5BINDEX(first)`5D.subject != NIL(char) `7C`7C
X`09    (unreadonly && IS_READ(newsgroup->artStatus`5BINDEX(first)`5D))) `7B
X`09     first++;
X`09     continue;
X`09`7D
X`09for (last = first + 1; last <= artlast; last++) `7B
X`09    if (currentArticles`5BINDEX(last)`5D.subject != NIL(char) `7C`7C
X`09`09(unreadonly && IS_READ(newsgroup->artStatus`5BINDEX(last)`5D))) `7B
X`09`09break;
X`09    `7D
X`09`7D
X`09last--;
X
X`09for (i = first; i < last; i++) `7B
X`09    SET_UNAVAIL(newsgroup->artStatus`5BINDEX(i)`5D);
X`09`7D
X`09(void) sprintf(command, "XOVER %ld-%ld", first, last);
X`09if (put_server(command, True) == -1)
X`09    ServerDown = True;
X`09get_data_from_server(message, sizeof(message));
X
X`09check_time_out(command, message, sizeof(message), True);
X
X`09/* check for errors */
X`09if (*message != CHAR_OK) `7B
X`09    return False;
X`09`7D
X
X`09for(;;) `7B
X`09    get_data_from_server(message, sizeof(message));
X
X`09    if (ServerDown) `7B
X`09`09check_time_out(command, message, sizeof(message), False);
X`09`09continue;
X`09    `7D
X`09
X`09    if ((message`5B0`5D == '.') && (message`5B1`5D == '\0')) `7B
X`09`09break;
X`09    `7D
X
X`09    /*
X`09     * message is of the form:
X`09     *
X`09     *    Number Subj(tab)Author(tab)date(tab)refs(tab)bytes(tab)lines
X`09     *
X`09     * must get the number since not all subjects will be returned
X`09     */
X
X`09    len = strlen(message);
X`09    if (len > 0 && message`5Blen-1`5D == '\n')
X`09`09message`5Blen-1`5D = '\0';`09/* make field count straightforward */
X`09    nf = split(message, fields, MAXFIELDS, "\t");
X`09    if (nf < MAXFIELDS - 1)`09/* only "others" fields are optional */
X`09`09continue;`09`09/* skip this line */
X`09    while (nf < MAXFIELDS)
X`09`09fields`5Bnf++`5D = "";`09/* fake missing fields */
X
X`09    number = atol(fields`5B0`5D);
X`09    subjectline = fields`5B1`5D;
X
X`09    if (number == 0 `7C`7C *subjectline == '\0') `7B
X`09`09mesgPane(XRN_SERIOUS,
X`09`09    "Bogus overview data returned from server (%s), continuing",
X`09`09     message);
X`09`09continue;
X`09    `7D
X
X`09    currentArticles`5BINDEX(number)`5D.subject = string_pool(subjectline)
V;
X`09    SET_AVAIL(newsgroup->artStatus`5BINDEX(number)`5D);
X
X`09    strcpy(authorline, fields`5B2`5D);
X`09    author = authorline;
X`09    if (app_resources.authorFullName) `7B
X`09`09/* Can be made fancyer at the expence of extra cpu time */
X`09`09if (author`5B0`5D == '\0') `7B
X`09`09    strcpy(authorline, "(None)");
X`09`09`7D
X
X`09`09/* First check for case 1, user@domain ("name") -> name */
X
X`09`09brackbeg = index(authorline, '(');
X`09`09brackend = index(authorline, '\0') - sizeof(char);
X`09`09/* brackend now points at the last ')' if this is case 1 */
X`09`09if (brackbeg != NIL(char) && (brackend > brackbeg) &&
X`09`09    (*brackend == ')')) `7B
X`09`09    author = brackbeg + sizeof(char);
X
X`09`09    /* Remove surrounding quotes ? */
X`09`09    if ((*author == '"') && (*(brackend - sizeof(char)) == '"')) `7B
X`09`09`09author++;
X`09`09`09brackend--;
X`09`09    `7D
X
X`09`09    /* Rather strip trailing spaces here */
X
X`09`09    *brackend = '\0';
X`09`09`7D else `7B
X`09`09    /* Check for case 2, "name" <user@domain> -> name */
X`09`09    brackbeg = index(authorline, '<');
X`09`09    if (brackbeg != NIL(char) && (index(brackbeg, '>') != NIL(char))
X`09`09`09&& (brackbeg > authorline)) `7B
X`09`09`09while (*--brackbeg == ' ')
X`09`09`09    ;
X
X`09`09`09/* Remove surrounding quotes ? */
X`09`09`09if ((*brackbeg == '"') && (*author ==  '"')) `7B
X`09`09`09    *brackbeg = '\0';
X`09`09`09    author++;
X
X`09`09`09    /* Rather strip trailing spaces here */
X
X`09`09`09`7D else `7B
X`09`09`09    *++brackbeg = '\0';
X`09`09`09`7D
X`09`09    `7D else `7B
X
X`09`09`09/*`20
X`09`09`09 * Check for case 3, <user@domain> -> usr@domain
X`09`09`09 *
X`09`09`09 * Don't need to do this again:
X`09`09`09 * brackbeg = index(authorline, '<');
X`09`09`09 */
X
X`09`09`09brackend = index(authorline, '>');
X`09`09`09if ((author == brackbeg) && (brackend != NIL(char))) `7B
X`09`09`09    author++;
X`09`09`09    *brackend = '\0';
X`09`09`09`7D else `7B
X`09`09`09    if ((end = index(author, ' ')) != NIL(char)) `7B
X`09`09`09`09*end = '\0';
X`09`09`09    `7D
X`09`09`09`7D
X`09`09    `7D
X`09`09`7D
X`09    `7D else `7B
X`09`09if ((author = index(authorline, '<')) == NIL(char)) `7B
X`09`09    /* first form */
X`09`09    author = authorline;
X`09`09    if (*author == '\0') `7B
X`09`09`09strcpy(authorline, "(None)");
X`09`09`09author = authorline;
X`09`09    `7D
X`09`09    if ((end = index(author, ' ')) != NIL(char)) `7B
X`09`09`09*end = '\0';
X`09`09    `7D
X`09`09`7D else `7B
X`09`09    /* second form */
X`09`09    if ((end = index(author, '>')) != NIL(char)) `7B
X`09`09`09*end = '\0';
X`09`09    `7D
X`09`09`7D
X`09    `7D
X`09    /*
X`09     * do a final trimming - just in case the authors name ends
X`09     * in spaces or tabs - it does happen
X`09     */
X`09    end = author + strlen(author) - 1;
X`09    while ((end > author) && ((*end == ' ') `7C`7C (*end == '\t'))) `7B
X`09`09*end = '\0';
X`09`09end--;
X`09    `7D
X`09    currentArticles`5BINDEX(number)`5D.author = string_pool(author);
X
X`09    numoflines = fields`5B7`5D;
X`09    if ((end = index(numoflines, '\t')) != NIL(char) `7C`7C
X`09`09(end = index(numoflines,  ' ')) != NIL(char)) `7B
X`09`09*end = '\0';
X`09    `7D
X`09    if (numoflines`5B0`5D != '(') `7B
X`09`09numoflines`5ButStrlen(numoflines)+1`5D = '\0';
X`09`09numoflines`5ButStrlen(numoflines)`5D = '`5D';
X`09`09for (lcv = utStrlen(numoflines); lcv >= 0; lcv--) `7B
X`09`09    numoflines`5Blcv+1`5D = numoflines`5Blcv`5D;
X`09`09`7D
X`09`09numoflines`5B0`5D = '`5B';
X`09    `7D else `7B
X`09`09numoflines`5B0`5D = '`5B';
X`09`09numoflines`5ButStrlen(numoflines)-1`5D = '`5D';
X`09    `7D
X`09    if (strcmp(numoflines, "`5Bnone`5D") == 0) `7B
X`09`09(void) strcpy(numoflines, "`5B?`5D");
X`09    `7D
X`09    currentArticles`5BINDEX(number)`5D.lines = string_pool(numoflines);
X`09    currentArticles`5BINDEX(number)`5D.msgid = string_pool(fields`5B4`5D)
V;
X`09    currentArticles`5BINDEX(number)`5D.refs`5B0`5D =`20
X`09    currentArticles`5BINDEX(number)`5D.refs`5B1`5D =`20
X`09    currentArticles`5BINDEX(number)`5D.refs`5B2`5D = string_pool("");
X`09    nrefs = split(fields`5B5`5D, refs, DEFREFS, " ,");
X`09    if (nrefs > DEFREFS) nrefs = DEFREFS;
X`09    for (i = 0, j = nrefs - 1; i <= 2 && j >= 0; j--, i++) `7B
X`09`09currentArticles`5BINDEX(number)`5D.refs`5Bi`5D = string_pool(refs`5Bj`
V5D);
X`09    `7D
X`09`7D
X`09first = last + 1;
X    `7D
X    return;
X`7D
X
X#ifndef INEWS
Xstatic void
XsendLine(str)
Xchar *str;
X`7B
X    if (*str == '.') `7B
X`09char *str2 = XtMalloc(utStrlen(str) + 2); /* one for the extra period,
X`09`09`09`09`09`09   * and one for the null at
X`09`09`09`09`09`09   * the end */
X`09str2`5B0`5D = '.';
X`09strcpy(str2 + 1, str);
X`09if (put_server(str, False) == -1)
X`09    ServerDown = True;
X`09XtFree(str2);
X    `7D else `7B
X`09if (put_server(str, False) == -1)
X`09    ServerDown = True;
X    `7D
X    return;
X`7D
X#endif
X
Xstatic char *
XgetLine(ptr)
Xchar **ptr;
X`7B
X    static char line`5B512`5D;
X    char *end = index(*ptr, '\n');
X
X    if (end) `7B
X`09(void) strncpy(line, *ptr, end - *ptr);
X`09line`5Bend - *ptr`5D = '\0';
X`09*ptr = end + 1;
X    `7D else `7B
X`09(void) strcpy(line, *ptr);
X`09*ptr = 0;
X    `7D
X    return line;
X`7D
X
X
X/*
X * Takes a block of text, wraps the text based on lineLength and
X * breakLength resources, and returns a NULL-terminated allocated
X * array of allocated strings representing the wrapped lines.  The
X * procedure which calls wrapText should use the wrapped Text and then
X * free each string and free the array.
X */
Xchar **
XwrapText(ptr, lineCount)
Xchar *ptr;
Xint *lineCount;
X`7B
X    long c = 0;`09`09`09/* current line length */
X    char **lines, *this_line;
X    long num_lines = 0;
X    long breakAt = app_resources.breakLength;
X
X    lines = (char **) XtMalloc((Cardinal) 0);
X
X    if (app_resources.breakLength && app_resources.lineLength) `7B
X`09/*
X`09 * Do text wrapping.
X`09 */
X`09this_line = XtMalloc((Cardinal) (app_resources.breakLength + 1));
X
X`09while (*ptr != '\0') `7B
X`09    if (c >= breakAt) `7B
X`09`09/*
X`09`09 * Everything after the first line in a paragraph
X`09`09 * should be wrapped at lineLength, not breakLength.
X`09`09 * This prevents the last line of a paragraph from
X`09`09 * ending up a little bit longer than all the other
X`09`09 * lines (and extending into the margin), but not quite
X`09`09 * breakLength characters lines long.
X`09`09 */
X`09`09breakAt = app_resources.lineLength;
X`09`09/* backoff to app_resources.lineLength */
X`09`09ptr -= c - breakAt;
X`09`09c = app_resources.lineLength;
X`09`09for (; c > 0 && *ptr != ' ' && *ptr != '\t'; ptr--) `7B
X`09`09     c--;
X`09`09`7D
X
X`09`09if (c == 0) `7B
X`09`09    /* pathological, cut to app_resources.lineLength */
X`09`09    c = app_resources.lineLength;
X`09`09    ptr += app_resources.lineLength - 1;
X`09`09`7D
X
X`09`09/* output */
X`09`09this_line`5Bc`5D = '\0';
X`09`09lines = (char **) XtRealloc((char *) lines, (Cardinal)
X`09`09`09`09     (sizeof(char *) * ++num_lines));
X`09`09lines`5Bnum_lines-1`5D = this_line;
X`09`09this_line = XtMalloc((Cardinal)
X`09`09`09`09      (app_resources.breakLength + 1));
X`09`09c = 0;
X`09`09if (strncmp(lines`5Bnum_lines-1`5D,
X`09`09`09    app_resources.includePrefix,
X`09`09`09    utStrlen(app_resources.includePrefix)) == 0) `7B
X`09`09    strcpy(this_line, app_resources.includePrefix);
X`09`09    c += utStrlen(app_resources.includePrefix);
X`09`09`7D
X
X`09`09/*
X`09`09 * Delete any extra spaces, tabs or carriage returns at`20
X`09`09 * the beginning of the next line.  This is necessary
X`09`09 * because we may break a line in the middle of a
X`09`09 * multi-space word break (e.g. the end of a sentence),
X`09`09 * or right before the paragraph-ending carriage
X`09`09 * return, which we've already printed as part of the
X`09`09 * line above.
X`09`09 */
X`09`09while ((*ptr == ' ') `7C`7C (*ptr == '\t') `7C`7C (*ptr == '\n')) `7B
X`09`09    ptr++;
X`09`09    if (*(ptr-1) == '\n')
X`09`09`09/* We only one to get rid of one carriage return */
X`09`09`09break;
X`09`09`7D
X`09      `20
X`09`09continue;
X`09    `7D
X
X`09    if (*ptr == '\n') `7B
X`09`09this_line`5Bc`5D = '\0';
X`09`09lines = (char **) XtRealloc((char *) lines, (Cardinal)
X`09`09`09`09`09    (sizeof(char *) * ++num_lines));
X`09`09lines`5Bnum_lines-1`5D = this_line;
X`09`09this_line = XtMalloc((Cardinal)
X`09`09`09`09      (app_resources.breakLength + 1));
X`09`09if (c == 0)
X`09`09     breakAt = app_resources.breakLength;
X`09`09c = 0, ptr++;
X`09`09continue;
X`09    `7D
X
X#ifdef notdef
X`09    if (*ptr == '\t') `7B
X`09`09c += c % 8;
X`09`09continue;
X`09    `7D
X#endif
X`09 `20
X`09    this_line`5Bc++`5D = *ptr++;
X`09`7D
X
X`09if (c != 0) `7B
X`09    this_line`5Bc`5D = '\0';
X`09    lines = (char **) XtRealloc((char *) lines, (Cardinal)
X`09`09`09`09`09 (sizeof(char *) * ++num_lines));
X`09    lines`5Bnum_lines-1`5D = this_line;
X`09`7D
X    `7D else `7B
X`09/*
X`09 * Don't do text wrapping, just break the text at linefeeds.
X`09 */
X`09while (*ptr) `7B
X`09    c = 0;
X`09    for (; *ptr && (*ptr != '\n'); ptr++, c++) ;
X`09    if (c `7C`7C *ptr) `7B
X`09`09this_line = XtMalloc((Cardinal) (c + 1));
X`09`09lines = (char **) XtRealloc((char *) lines,
X`09`09`09`09`09     (Cardinal) (sizeof(char *) *
X`09`09`09`09`09`09`09 ++num_lines));
X`09`09strncpy(this_line, (char *) ptr-c, c);
X`09`09this_line`5Bc`5D = '\0';
X`09`09lines`5Bnum_lines-1`5D = this_line;
X`09`09if (*ptr)
X`09`09    ptr++;
X`09    `7D
X`09`7D
X    `7D
X    `20
X    lines = (char **) XtRealloc((char *) lines,
X`09`09`09`09 (Cardinal) (sizeof(char *) * ++num_lines));
X    lines`5Bnum_lines-1`5D = NULL;
X
X    *lineCount = num_lines;
X    return(lines);
X`7D
X
X#ifdef MOTIF
Xchar* wrapString(ptr)
Xchar *ptr;
X/*
X * Wrap a string and return the wrapped version.
X * only used on Motif to eliminate need for horizontal
X * scroll bar (enabling wrap in the widget is too slow)
X */
X`7B
X    unsigned int c = 0;`09`09/* current line length */
X    char *this_line;
X    char *wrappedText, *w;
X    int breakLength;
X    int i, sizeNeeded, thisSize, sizeLeft;
X
X    sizeNeeded = 0;
X
X    breakLength = xthTextWidth(ArticleText) + 1;
X
X    sizeNeeded = strlen(ptr) + 1000;
X    wrappedText = w = XtMalloc(sizeNeeded);
X    sizeLeft = sizeNeeded;
X    *w = '\0';
X    this_line = XtMalloc((Cardinal) (breakLength + 1));
X
X    /*
X     * Do text wrapping.
X     */
X
X    while (*ptr != '\0') `7B
X`09if (c >= breakLength) `7B
X`09    for (; c > 0 && *ptr != ' ' && *ptr != '\t'; ptr--) `7B
X`09`09c--;
X`09    `7D
X
X`09    if (c == 0) `7B
X`09`09/* pathological, cut to breakLength */
X`09`09c = breakLength;
X`09`09ptr += breakLength - 1;
X`09    `7D
X
X`09    /* output */
X`09    this_line`5Bc`5D = '\0';
X`09    thisSize = strlen(this_line);
X`09    if (w != wrappedText) `7B
X`09`09*w++ = '\n';
X`09`09sizeLeft--;
X`09    `7D
X`09    if (sizeLeft < breakLength * 2) `7B
X`09`09sizeNeeded += 1000;
X`09`09sizeLeft += 1000;
X`09`09wrappedText = XtRealloc(wrappedText, sizeNeeded);
X`09`09w = wrappedText + strlen(wrappedText);
X`09    `7D
X`09    strcpy(w, this_line);
X`09    w += thisSize;
X`09    sizeLeft -= thisSize;
X`09    this_line`5B0`5D = '\0';
X`09    c = 0;
X
X`09    /*
X`09     * Delete any extra spaces, tabs or carriage returns at`20
X`09     * the beginning of the next line.  This is necessary
X`09     * because we may break a line in the middle of a
X`09     * multi-space word break (e.g. the end of a sentence),
X`09     * or right before the paragraph-ending carriage
X`09     * return, which we've already printed as part of the
X`09     * line above.
X`09     */
X`09    while ((*ptr == ' ') `7C`7C (*ptr == '\t') `7C`7C (*ptr == '\n')) `7B
X`09`09ptr++;
X`09`09if (*(ptr-1) == '\n')
X`09`09    /* We only one to get rid of one carriage return */
X`09`09    break;
X`09    `7D
X`09      `20
X`09    continue;
X`09`7D
X
X`09if (*ptr == '\n') `7B
X`09    this_line`5Bc`5D = '\0';
X`09    thisSize = strlen(this_line);
X`09    if (w != wrappedText) `7B
X`09`09*w++ = '\n';
X`09`09sizeLeft--;
X`09    `7D
X`09    if (sizeLeft < breakLength * 2) `7B
X`09`09sizeNeeded += 1000;
X`09`09sizeLeft += 1000;
X`09`09wrappedText = XtRealloc(wrappedText, sizeNeeded);
X`09`09w = wrappedText + strlen(wrappedText);
X`09    `7D
X`09    strcpy(w, this_line);
X`09    w += thisSize;
X`09    sizeLeft -= thisSize;
X`09    this_line`5B0`5D = '\0';
X
X`09    c = 0, ptr++;
X`09    continue;
X`09`7D
X
X`09this_line`5Bc++`5D = *ptr++;
X    `7D
X
X    if (c != 0) `7B
X`09this_line`5Bc`5D = '\0';
X`09thisSize = strlen(this_line);
X`09if (w != wrappedText) `7B
X`09    *w++ = '\n';
X`09    sizeLeft--;
X`09`7D
X`09if (sizeLeft < breakLength * 2) `7B
X`09    sizeNeeded += 1000;
X`09    sizeLeft += 1000;
X`09    wrappedText = XtRealloc(wrappedText, sizeNeeded);
X`09    w = wrappedText + strlen(wrappedText);
X`09`7D
X`09strcpy(w, this_line);
X`09w += thisSize;
X`09sizeLeft -= thisSize;
X`09this_line`5B0`5D = '\0';
X    `7D
X    *w++ = '\n';
X    *w++ = '\0';
X    FREE(this_line);
X    return(wrappedText);
X`7D
X#endif /* MOTIF */
X#ifndef VMS
X
Xint
XmailArticle(article)
Xchar *article;
X`7B
X#ifdef sequent
X     extern FILE *popen _ARGUMENTS((const char *, const char *)); /* sequent
V */
X#endif
X
X     FILE *fp;
X     char **lines_ptr, **lines;
X     char *ptr;
X     int lineCount;
X    `20
X     if ((fp = (FILE *) popen(app_resources.mailer, "w")) == NULL)
X`09  return POST_FAILED;
X
X     /* First, send everything up to the first blank line without any */
X     /* wrapping. `09`09`09`09`09`09      */
X     while (1) `7B
X`09  ptr = index(article, '\n');
X`09  if ((ptr == article) `7C`7C (ptr == NULL))
X`09       /* line has nothing but newline or end of article */
X`09       break;
X`09  (void) fwrite(article, sizeof(char), (unsigned) (ptr - article + 1), fp
V);
X`09  article = ptr + 1;
X     `7D
X    `20
X     lines_ptr = lines = wrapText(article, &lineCount);
X     while (*lines) `7B
X`09  (void) fwrite(*lines, sizeof(char), utStrlen(*lines), fp);
X`09  (void) fwrite("\n", sizeof(char), 1, fp); /* wrapText deletes newlines
V */
X`09  FREE(*lines);
X`09  lines++;
X     `7D
X     FREE(lines_ptr);
X
X     return pclose(fp) ? POST_FAILED : POST_OKAY;
X`7D
X#endif
X
X
Xint
XpostArticle(article, mode)
Xchar *article;
Xint mode;   /* XRN_NEWS or XRN_MAIL */
X/*
X * post an article
X *
X *   returns 1 for success, 0 for failure
X */
X`7B
X    char command`5BMESSAGE_SIZE`5D, message`5BMESSAGE_SIZE`5D;
X    char *ptr, *saveptr;
X    char **lines, **lines_ptr;
X    int lineCount;
X
X#ifdef INEWS
X    char *tempfile;
X    int exitstatus;
X    char buffer`5B1024`5D;
X    FILE *inews;
X    extern char * utTempnam();
X#endif
X   `20
X    if (mode == XRN_MAIL) `7B
X`09return mailArticle(article);
X    `7D
X
X#ifdef INEWS
X    tempfile = XtNewString(utTempnam(app_resources.tmpDir, "xrn"));
X    (void) sprintf(buffer, "%s -h > %s 2>&1",INEWS, tempfile);
X    if ((inews = (FILE *) popen(buffer, "w")) == NULL) `7B
X        mesgPane(XRN_SERIOUS, "Failed to start inews\n");
X`09(void) unlink(tempfile);
X`09FREE(tempfile);
X        return(POST_FAILED);
X    `7D
X#else
X
X    (void) strcpy(command, "POST");
X    if (put_server(command, True) == -1)
X`09ServerDown = True;
X    get_data_from_server(message, sizeof(message));
X
X    check_time_out(command, message, sizeof(message), True);
X
X    if (*message != CHAR_CONT) `7B
X`09mesgPane(XRN_SERIOUS,
X`09    "Your message could not be posted due to the following error:\r%s",
X`09`09message);
X`09mesgPane(XRN_SERIOUS,
X`09    "Please contact your news system adminstrator for assistance.");
X`09if (atoi(message) == ERR_NOPOST) `7B
X`09    return(POST_NOTALLOWED);
X`09`7D else `7B
X`09    return(POST_FAILED);
X`09`7D
X    `7D
X#endif
X
X    ptr = article;
X
X    while (1) `7B
X`09char *line;
X
X`09saveptr = ptr;
X
X`09line = getLine(&ptr);
X`09if (index(line, ':') `7C`7C (*line == ' ') `7C`7C (*line == '\t')) `7B
X#ifdef INEWS
X`09    fputs(line, inews);
X`09    fputc('\n', inews);
X#else
X`09    sendLine(line);
X#endif
X`09    continue;
X`09`7D
X`09break;
X    `7D
X
X    if (*saveptr != '\n') `7B
X`09 /* if the skipped line was not blank, point back to it */
X`09 ptr = saveptr;
X    `7D
X
X    lines_ptr = lines = wrapText(ptr, &lineCount);
X#ifdef INEWS
X    sprintf(command,"Lines: %d\n",lineCount);
X    fputs(command, inews);
X    fputs("\n\n", inews);
X#else
X    sprintf(command,"Lines: %d\n",lineCount);
X    sendLine(command);
X    sendLine("");`09`09/* send a blank line */
X#endif
X
X    while (*lines) `7B
X#ifdef INEWS
X         fputs(*lines, inews);
X`09 fputc('\n', inews);
X#else
X`09 sendLine(*lines);
X#endif
X`09 XtFree(*lines);
X`09 lines++;
X    `7D
X    FREE(lines_ptr);
X   `20
X#ifdef INEWS
X    if (exitstatus = pclose(inews)) `7B
X`09FILE *filefp;
X`09char *p;
X`09struct stat buf;
X`09char temp`5B1024`5D;
X`09(void) sprintf(temp, "\n\ninews exit value: %d\n", exitstatus);
X`09if ((filefp = fopen(tempfile, "r")) != NULL) `7B
X`09    if (fstat(fileno(filefp), &buf) != -1) `7B
X`09`09p = XtMalloc(buf.st_size + utStrlen(temp) + 10);
X`09`09(void) fread(p, sizeof(char), buf.st_size, filefp);
X`09`09p`5Bbuf.st_size`5D = '\0';
X`09`09(void) strcat(p, temp);
X`09`09(void) fclose(filefp);
X`09`09mesgPane(XRN_SERIOUS, "INEWS Serious Error: %s", p);
X`09    `7D
X`09`7D
X`09(void) unlink(tempfile);
X`09FREE(tempfile);
X`09return(POST_FAILED);
X    `7D
X#else
X    if (put_server(".", True) == -1)
X`09ServerDown = True;
X
X#ifdef SERIALHACK
X    get_data_from_server(message, sizeof(message));
X#endif
X
X    get_data_from_server(message, sizeof(message));
X    if (ServerDown) `7B
X`09mesgPane(XRN_SERIOUS, "NNTP Server connection lost");
X`09check_time_out(".", message, sizeof(message), False);
X`09return(POST_FAILED);
X    `7D`09
X    if (*message != CHAR_OK) `7B
X`09mesgPane(XRN_SERIOUS, "NNTP Serious Error: %s", message);
X`09return(POST_FAILED);
X    `7D
X#endif
X
X    return(POST_OKAY);
X`7D
X
X
X#ifdef DONT_USE_XHDR_FOR_A_SINGLE_ITEM
X
Xvoid
Xxhdr(article, field, string)
Xart_num article;
Xchar *field;
Xchar **string;
X/*
X * get header information about 'article'
X *
X *   the results are stored in 'string'
X */
X`7B
X    char command`5BBUFFER_SIZE`5D, message`5BMESSAGE_SIZE`5D;
X    char buffer`5BBUFFER_SIZE`5D;
X    char *ptr, *cmp;
X    Boolean found = 0;
X    Boolean current = 0;
X`20
X    *string = 0;
X    if (currentNewsgroup == NULL) `7B
X`09return;
X    `7D
X
X    buffer`5B0`5D = '\0';
X    /*
X     * In some implementations of NNTP, the XHDR request on a
X     * single article can be *very* slow, so we do a HEAD request
X     * instead and just search for the appropriate field.
X     */
X
X    (void) sprintf(command, "HEAD %ld", article);
X    if (put_server(command, True) == -1)
X`09ServerDown = True;
X    get_data_from_server(message, sizeof(message));
X   `20
X    check_time_out(buffer, message, sizeof(message), True);
X   `20
X    /* check for errors */
X    if (*message != CHAR_OK) `7B
X`09/* can't get header */
X`09*string = NIL(char);
X`09return;
X    `7D
X   `20
X    for (;;) `7B
X`09get_data_from_server(message, sizeof(message));
X`09if (ServerDown `7C`7C STREQN(message, "503 Timeout", 11)) `7B
X`09    check_time_out(buffer, message, sizeof(message), False);
X`09    continue;
X`09`7D
X
X`09/* the header information is ended by a '.' on a line by itself */
X
X`09if ((message`5B0`5D == '.') && (message`5B1`5D == '\0')) `7B
X`09    break;
X`09`7D
X
X`09if (!found) `7B
X`09    for (ptr = message, cmp = field; *ptr; ptr++, cmp++) `7B
X`09`09/* used to be 'mklower' */
X`09`09if (tolower(*cmp) != tolower(*ptr))
X`09`09    break;
X`09    `7D
X`09    if (*cmp == 0 && *ptr == ':') `7B
X`09`09while (*++ptr == ' ')
X`09`09    ;
X`09`09strcat(buffer, ptr);
X`09`09found = True;
X`09`09current = True;
X`09    `7D
X`09`7D
X`09if (current) `7B
X`09    if (message`5B0`5D != '\t') `7B
X`09`09current = False;
X`09    `7D else `7B
X`09`09ptr = message;
X`09`09while (*++ptr == '\t')
X`09`09    ;
X`09`09strcat(buffer, " ");
X`09`09strcat(buffer, ptr);
X`09    `7D
X`09`7D
X`09`09
X    `7D
X
X    if (found)
X`09*string = XtNewString(buffer);
X    else
X`09*string = NIL(char);
X
X    return;
X`7D
X
X#else
X
Xvoid
Xxhdr(article, field, string)
Xart_num article;
Xchar *field;
Xchar **string;
X/*
X * get header information about 'article'
X *
X *   the results are stored in 'string'
X */
X`7B
X    char buffer`5BBUFFER_SIZE`5D, message`5BMESSAGE_SIZE`5D, *ptr;
X   `20
X    (void) sprintf(buffer, "XHDR %s %ld", field, article);
X    if (put_server(buffer, True) == -1)
X`09ServerDown = True;
X    get_data_from_server(message, sizeof(message));
X   `20
X    check_time_out(buffer, message, sizeof(message), True);
X   `20
X    /* check for errors */
X    if (*message != CHAR_OK) `7B
X`09fprintf(stderr, "NNTP error: %s\n", message);
X`09*string = NIL(char);
X`09mesgPane(XRN_SERIOUS,
X"XRN: serious error, your NNTP server does not have XHDR support.\n\
XEither you are running a pre-1.5 NNTP server or XHDR has\n\
Xnot been defined in 'nntp/common/conf.h'\n\
XXRN requires XHDR support to run.");
X`09return;
X    `7D
X   `20
X    get_data_from_server(message, sizeof(message));
X    check_time_out(buffer, message, sizeof(message), False);
X
X    /* no information */
X    if (*message == '.') `7B
X`09*string = NIL(char);
X`09return;
X    `7D
X
X    ptr = index(message, ' ');
X
X    /* malformed entry */
X    if (ptr == NIL(char)) `7B
X`09mesgPane(XRN_SERIOUS,
X"XRN debugging message: malformed XHDR return\n\
Xcommand: %s, return: %s",
X`09`09       buffer, message);
X`09get_data_from_server(message, sizeof(message));
X`09return;
X    `7D
X
X    ptr++;
X
X    /* no information */
X    if (STREQ(ptr, "(none)")) `7B
X`09*string = NIL(char);
X`09/* ending '.' */
X`09do `7B
X`09    get_data_from_server(message, sizeof(message));
X`09    if (ServerDown) `7B
X`09`09check_time_out(buffer, message, sizeof(message), False);
X`09`09continue;
X`09    `7D
X`09`7D while (*message != '.');
X`09return;
X    `7D
X
X    *string = (char *) XtNewString(ptr);
X
X    /* ending '.' */
X    do `7B
X`09get_data_from_server(message, sizeof(message));
X`09if (ServerDown) `7B
X`09    check_time_out(buffer, message, sizeof(message), False);
X`09    continue;
X`09`7D
X    `7D while (*message != '.');
X
X    return;
X`7D
X#endif
X
Xstruct article *
Xgetarticles(newsgroup)
Xstruct newsgroup *newsgroup;
X`7B
X    register art_num first = newsgroup->first, last = newsgroup->last, art;
X    int newsize;
X
X    if (last >= first && last != 0) `7B
X`09register struct article`09*ap;
X
X`09newsize = last - first + 1;
X`09if (newsize > artCount) `7B
X`09    if (savedArt) FREE(savedArt);
X`09    newsize = artCount = MAX(newsize, 1000);
X`09    currentArticles = savedArt = ARRAYALLOC(struct article, newsize+10);
X`09`7D else `7B
X`09    currentArticles = savedArt;
X`09`7D
X
X`09ap = &currentArticles`5BINDEX(first)`5D;
X   `20
X`09for (art = first; art <= last; art++) `7B
X`09    ap->subject = NIL(char);
X`09    ap->author = NIL(char);
X`09    ap->lines = NIL(char);
X`09    ap->msgid = NIL(char);
X`09    ap->refs`5B0`5D = NIL(char);
X`09    ap->refs`5B1`5D = NIL(char);
X`09    ap->refs`5B2`5D = NIL(char);
X`09    ap->parent = 0;
X`09    ap->child = 0;
X`09    ap->text = NIL(char);
X`09    ap++;
X`09`7D
X    `7D
X    return(currentArticles);
X`7D
X
Xstruct artStat *
Xgetartstatus(newsgroup)
Xstruct newsgroup *newsgroup;
X`7B
X    register art_num first = newsgroup->first, last = newsgroup->last, art;
X
X    if (last >= first && last != 0) `7B
X`09register struct artStat *ap;
X`09newsgroup->artStatus = ARRAYALLOC(struct artStat, last - first + 1);
X
X`09ap = &newsgroup->artStatus`5BINDEX(first)`5D;
X   `20
X`09for (art = first; art <= last; art++) `7B
X`09    ap->status = ART_CLEAR;
X`09    ap++;
X`09`7D
X    `7D
X    return(newsgroup->artStatus);
X`7D
X
X#ifdef VFORK_SUPPORTED
X#ifndef POPEN_USES_INEXPENSIVE_FORK
X
Xstatic int popen_pid = 0;
X
X#if defined(STDC) && !defined(_NO_PROTO)
XFILE  *`09popen(const char *__command, const char *__type )
X#else
XFILE *
Xpopen(__command, __type)
Xchar *__command;
Xchar *__type;
X#endif
X`7B
X    int pipes`5B2`5D;
X    int itype = (strcmp(__type, "w") == 0 ? 1 : 0);
X
X    if (pipe(pipes) == -1)
X`09return NULL;
X
X    switch (popen_pid = vfork()) `7B
X    case -1:
X`09(void)close(pipes`5B0`5D);
X`09(void)close(pipes`5B1`5D);
X`09return NULL;
X
X    case 0:
X`09if (itype) `7B
X`09    dup2(pipes`5B0`5D, fileno(stdin));
X`09    close(pipes`5B1`5D);
X`09`7D else `7B
X`09    dup2(pipes`5B1`5D, fileno(stdout));
X`09    close(pipes`5B0`5D);
X`09`7D
X`09execl("/bin/sh", "/bin/sh", "-c", __command, 0);
X`09fprintf(stderr, "XRN Error: failed the execlp");
X`09_exit(-1);
X`09/* NOTREACHED */
X
X    default:
X`09    if (itype) `7B
X`09`09close(pipes`5B0`5D);
X`09`09return fdopen(pipes`5B1`5D, "w");
X`09    `7D else `7B
X`09`09close(pipes`5B1`5D);
X`09`09return fdopen(pipes`5B0`5D, "w");
X`09    `7D
X    `7D
X`7D
X
X#if defined(STDC) && !defined(_NO_PROTO)
Xint
Xpclose( FILE *__stream )
X#else
Xint
Xpclose(__stream)
XFILE *__stream;
X#endif
X`7B
X    int pd = 0;
X#if defined (ultrix) && defined (STDC)
X    union wait status;
X#else
X    int`09status;
X#endif
X    int`09err;
X
X    err = fclose(__stream);
X
X    do `7B
X`09if ((pd = wait(&status)) == -1)`09`7B
X`09    err = EOF;
X`09    break;
X`09`7D
X    `7D while (pd != popen_pid);
X
X    if (err == EOF)
X`09return  -1;
X`09
X#if defined(ultrix) && defined(STDC)
X    return WEXITSTATUS(status);
X#else
X    if (status)
X`09status >>= 8;`09/* exit status in high byte */
X
X    return status;
X#endif
X`7D
X#endif
X#endif
$ CALL UNPACK SERVER.C;119 2053029306
$ create 'f'
X#ifndef SERVER_H
X#define SERVER_H
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/server.h,v 1.7 1993/
V02/04 18:22:30 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * server.h: routines for communicating with the NNTP remote news server
X *
X */
X
X#include "codes.h"
X
X/*
X * function definitions for the nntp server (in nntp/clientlib.c)
X */
X `20
Xextern void close_server();
Xextern int get_server _ARGUMENTS((char *, int));
Xextern char *getserverbyfile _ARGUMENTS((char *));
Xextern int put_server _ARGUMENTS((char *, Boolean));
Xextern int server_init _ARGUMENTS((char *));
Xextern void start_server();
X
X/* get the list of active news groups from the news server */
Xextern void getactive();
X
X/* see if the subscribed to groups have 0 or 1 article */
Xextern void fixLowArticleNumbers();
X
X/* get a single article in the current group from the news server */
X#ifdef XLATE
Xextern char *getarticle _ARGUMENTS((art_num, int *, int, int, int));
X#else
Xextern char *getarticle _ARGUMENTS((art_num, int *, int, int));
X#endif
X#define FULL_HEADER   1
X#define NORMAL_HEADER 2
X#define NOT_ROTATED   1
X#define ROTATED       2
X#define NOT_XLATED    1
X#define XLATED        2
X
X/*
X * tell the server that the next set of article requests will be for this gr
Voup
X *  returns NO_GROUP on failure
X */
Xextern int getgroup _ARGUMENTS((struct newsgroup *, art_num *, art_num *, in
Vt *number));
X
X/* get a list of subject lines for a range of articles in the current group
V from the server */
Xextern void getsubjectlist _ARGUMENTS((struct newsgroup *,art_num,art_num,in
Vt));
Xextern void getauthorlist _ARGUMENTS((struct newsgroup *,art_num,art_num,int
V));
Xextern void getlineslist _ARGUMENTS((struct newsgroup *,art_num,art_num,int)
V);
Xextern void getmsgidlist _ARGUMENTS((struct newsgroup *,art_num,art_num,int)
V);
Xextern void getrefslist _ARGUMENTS((struct newsgroup *,art_num,art_num,int))
V;
Xextern Boolean getoverview _ARGUMENTS((struct newsgroup *,art_num,art_num,in
Vt));
X
X/* xhdr commands */
Xextern void xhdr _ARGUMENTS((art_num, char *, char **));
X
X/* post article */
Xextern int postArticle _ARGUMENTS((char *, int));
X
X/* wrap article text buffer */
Xextern char** wrapText _ARGUMENTS((char *, int *));
Xextern char*  wrapString _ARGUMENTS((char *));
X
X/* in clientlib.c */
Xextern int handle_server_response _ARGUMENTS((int, char *));
X
X#define XRN_MAIL`09 0
X#define XRN_NEWS`09 1
X
X#define POST_FAILED      0
X#define POST_OKAY        1
X#define POST_NOTALLOWED  2
X#define POST_TRYAGAIN`09 3
X
X#endif /* SERVER_H */
$ CALL UNPACK SERVER.H;24 57308590
$ create 'f'
X/* SList.c
X
X****************************************************************************
V*
X*                                                                        `20
V  *
X*  COPYRIGHT (c) 1989  BY
V                                                   *
X*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
V                   *
X*  ALL RIGHTS RESERVED.
V                                                     *
X*                                                                        `20
V  *
X*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
V    *
X*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
V    *
X*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
V    *
X*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
V    *
X*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY
V    *
X*  TRANSFERRED.
V                                                             *`20
X*                                                                        `20
V  *
X*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
V    *
X*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
V    *
X*  CORPORATION.
V                                                             *
X*                                                                        `20
V  *
X*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
V    *
X*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
V                  *
X*                                                                        `20
V  *
X****************************************************************************
V*
X
X        This module implements the SList widget.
X
XThe SList widget can be used to present a list of options to the user.
XBy using Button1 on the mouse, the user can select one or more options,
Xand can scroll through the list using the scrollbar or keyboard.
X
XThe widget has a callback that is used to ask the application for
Xthe contents of the list items when it is necessary for refreshing the
Xdisplay (or when initially displaying the list).
X
XThe SList widget can be created by calls to XtCreateWidget or in UIL.  Its
Xinterface with the application is simple and consists of the following calls
V:
X
XSListInitializeForDRM() - must be called before any SList widgets are
X    created, if you are using UIL to create them.
X               `20
XSListCreate(pW, nameP, argsP, argCnt) - is a convenience routine (also
X    used by UIL/DRM) to create a SList widget.  You will probably not
X    call this routine directly from an application.
X
XSListLoad(w, sLineCnt) - may be called at any time to pass a
X    new count to the SList widget.  If the
X    SList widget is visible, it is repainted with the new list contents.
X
XSListSelectAll(w, select) - may be called at any time to select or
X    unselect all the entries in the list.
X
XSListUnhighlight(w) - may be called to unhighlight the highlighted line,
X    if any.
XSListHighlight(w) - Select the highlighted line.
X
XThere are three callbacks made by the widget:
X
X(1) select_callback is made whenever the user upclicks MB1 in the list.
X(2) double_click_callback is made whenever the user double-clicks on an
X    item in the list.
X(3) get_data_callback is used to determine the contents of a list item
X    for display.
X
XMODIFICATION HISTORY:
X
X*/
X#include "config.h"
X#define SLIST
X#ifdef MOTIF
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#include <X11/IntrinsicP.h>
X#include <X11/ShellP.h>
X#include <X11/Xatom.h>
X#include <Xm/Xm.h>
Xextern void _XmDrawShadow();
X#if (XmVERSION == 1) && (XmREVISION == 0)
X#define MOTIF_V10
X#endif
X#if (XmVERSION > 1) `7C`7C (XmREVISION > 1)
X/* For Motif 1.2 */
X#include <Xm/PrimitiveP.h>
X#endif
X#include <Xm/XmP.h>
X#include <Xm/ScrollBar.h>
X#include <Xm/ScrolledW.h>
X#ifdef USE_MRM
X#include <Mrm/MrmAppl.h>
X#endif
X#else
X#ifdef unix
X#include <X11/DECwDwtWidgetProg.h>
X#include <X11/Xatom.h>
X#else
X#include <decw$include/DECwDwtWidgetProg.h>
X#include <decw$include/Xatom.h>
X#endif
X#endif /* MOTIF */
X#include "slistP.h"
X#ifndef MIN
X#define MIN(a,b) (((a)<(b))?(a):(b))
X#endif
X`0C
X/*
X * Forward declarations
X */
Xstatic int ComputeMaxYAdjust();
Xstatic int YToLine();
Xstatic void SetYAdjust();
Xstatic void Flip();
Xstatic void Draw();
Xstatic void CallSelectCallbacks();
Xstatic void CallDoubleClickCallbacks();
Xstatic void CallGetDataCallback();
Xstatic void SetLineSelection();
Xstatic void NewScrollPosition();
Xstatic void NewSelectPosition();
Xstatic XtCallbackProc scrollCallback();
Xstatic void Mb1PressInList();
Xstatic void ClickTimer();
Xstatic void ButtonReleaseHandler();
Xstatic void ButtonPressHandler();
Xstatic void PointerMotionHandler();
Xstatic void DrawExposedLines();
Xstatic void SaveExposeRegion();
Xstatic void StartScrollGrop();
Xstatic void Repaint();
Xstatic void DoExpose();
Xstatic XtGeometryResult QueryGeometry();
Xstatic void DoInitialize();
Xstatic void DoRealize();
Xstatic void DoResize();
Xstatic void DoDestroy();
XXtActionProc slistForwardPage();
XXtActionProc slistBackwardPage();
XXtActionProc slistForwardLine();
XXtActionProc slistBackwardLine();
Xstatic void ClassInitialize();
X
Xstatic XtCallbackRec VSCallBack`5B`5D =`20
X`7B
X    `7B(XtCallbackProc)   scrollCallback, (caddr_t) NULL`7D,
X    `7BNULL,              (caddr_t) NULL`7D,
X`7D;
X#if defined (MOTIF) && !defined (MOTIF_V10)
Xstatic char slistBindings`5B`5D =
X    "Shift `7EMeta `7EAlt <Key>Tab: PrimitivePrevTabGroup()\n\
X     `7EMeta `7EAlt <Key>Tab:       PrimitiveNextTabGroup()\n\
X     <FocusIn>:                 PrimitiveFocusIn()\n\
X     <FocusOut>:                PrimitiveFocusOut()\n\
X     <Key>osfPageDown:          forward-page()\n\
X     <Key>osfPageUp:            backward-page()\n\
X     <Key>osfDown:              forward-line()\n\
X     <Key>osfUp:                backward-line()";
X#else
Xstatic char slistBindings`5B`5D =
X    "Ctrl `7EShift `7EMeta `7EAlt <Key>Next: forward-page()\n\
X     Ctrl `7EShift `7EMeta `7EAlt <Key>Prior:backward-page()\n\
X     Ctrl `7EShift `7EMeta `7EAlt <Key>Down: forward-line()\n\
X     Ctrl `7EShift `7EMeta `7EAlt <Key>Up:   backward-line()";
X#endif
X
Xstatic XtActionsRec slistActionsTable`5B`5D = `7B
X    `7B"forward-page",    (XtActionProc) slistForwardPage`7D,
X    `7B"backward-page",   (XtActionProc) slistBackwardPage`7D,
X    `7B"forward-line",    (XtActionProc) slistForwardLine`7D,
X    `7B"backward-line",   (XtActionProc) slistBackwardLine`7D,
X#if defined (MOTIF) && !defined (MOTIF_V10)
X    `7B"PrimitiveFocusIn",(XtActionProc) _XmPrimitiveFocusIn`7D,
X    `7B"PrimitiveFocusOut",(XtActionProc) _XmPrimitiveFocusOut`7D,
X#endif
X`7D;
X`0C
X/*
X * Widget resource tables
X */
X#ifndef XtCCallback
X#define XtCCallback "Callback"
X#endif
X#ifndef XtRCallback
X#define XtRCallback "Callback"
X#endif
X#define Offset(x) XtOffset(SListWidget, x)
X
X#ifdef MOTIF_V10
Xextern void _XmForegroundColorDefault();
X#endif
X
Xstatic XtResource resources`5B`5D = `7B
X#ifdef MOTIF
X  `7BXmNfont, XmCFontList, XmRFontList, sizeof(XmFontList *),
X      Offset(slist.fontRecP), XmRString, "fixed"`7D,
X  `7BSListNcols, SListCCols, XtRInt, sizeof(int),
X      Offset(slist.cols), XtRImmediate, (caddr_t)1`7D,
X  `7BSListNrows, SListCRows, XmRInt, sizeof(int),
X      Offset(slist.rows), XmRImmediate, (caddr_t)1`7D,
X  `7BSListNselectCallback, XmCCallback, XmRCallback, sizeof(XtCallbackList),
X      Offset(slist.selectCallback), XmRCallback, (caddr_t)0`7D,
X  `7BSListNdoubleClickCallback, XmCCallback, XmRCallback, sizeof(XtCallbackL
Vist),
X      Offset(slist.doubleClickCallback), XmRCallback, (caddr_t)0`7D,
X  `7BSListNgetDataCallback, XmCCallback, XmRCallback, sizeof(XtCallbackList)
V,
X      Offset(slist.getDataCallback), XmRCallback, (caddr_t)0`7D,
X#ifdef MOTIF
X#ifdef MOTIF_V10
X  `7BSListNforeground, SListCForeground, XmRPixel, sizeof(Pixel),
X      Offset(slist.foreground), XmRCallProc,
X      (caddr_t) _XmForegroundColorDefault`7D,
X#else
X  `7BSListNforeground, SListCForeground, XmRPixel, sizeof(Pixel),
X      Offset(slist.foreground), XmRString, XtExtdefaultforeground`7D,
X#endif
X#endif
X  `7BSListNtextMarginWidth, SListCTextMarginWidth, XmRInt, sizeof(int),
X      Offset(slist.textMarginWidth), XmRImmediate, (caddr_t)4`7D,
X  `7BSListNdoubleClickDelay, SListCDoubleClickDelay, XmRInt, sizeof(int),
X      Offset(slist.ClickInterval), XmRImmediate, (caddr_t) 250`7D
X#else
X  `7BDwtNfont, DwtCFontList, DwtRFontList, sizeof(DwtFontRec *),
X      Offset(slist.fontRecP), XtRString, "fixed"`7D,
X  `7BSListNcols, SListCCols, XtRInt, sizeof(int),
X      Offset(slist.cols), XtRImmediate, (caddr_t)1`7D,
X  `7BSListNrows, SListCRows, XtRInt, sizeof(int),
X      Offset(slist.rows), XtRImmediate, (caddr_t)1`7D,
X  `7BSListNselectCallback, XtCCallback, XtRCallback, sizeof(DwtCallbackPtr),
X      Offset(slist.selectCallback), XtRCallback, (caddr_t)0`7D,
X  `7BSListNdoubleClickCallback, XtCCallback, XtRCallback, sizeof(DwtCallback
VPtr),
X      Offset(slist.doubleClickCallback), XtRCallback, (caddr_t)0`7D,
X  `7BSListNgetDataCallback, XtCCallback, XtRCallback, sizeof(XtCallbackList)
V,
X      Offset(slist.getDataCallback), XtRCallback, (caddr_t)0`7D,
X  `7BSListNforeground, SListCForeground, XtRPixel, sizeof(Pixel),
X      Offset(slist.foreground), XtRString, DwtSForegroundDefault`7D,
X  `7BSListNtextMarginWidth, SListCTextMarginWidth, XtRInt, sizeof(int),
X      Offset(slist.textMarginWidth), XtRImmediate, (caddr_t)4`7D,
X  `7BSListNdoubleClickDelay, SListCDoubleClickDelay, XtRInt, sizeof(int),
X      Offset(slist.ClickInterval), XtRImmediate, (caddr_t) 250`7D
X#endif
X`7D;
X`0C
X/*
X * The widget class record
X */
Xexternaldef(slistwidgetclassrec)
XSListClassRec slistwidgetclassrec = `7B
X    `7B/* core_class fields       */
X#ifdef MOTIF
X        /* superclass           */      (WidgetClass) &xmPrimitiveClassRec,
X#else
X        /* superclass           */      (WidgetClass) &widgetClassRec,
X#endif
X        /* class_name           */      "SList",
X        /* widget_size          */      sizeof(SListWidgetRec),
X        /* class_initialize     */      ClassInitialize,
X        /* class_part_initialize */     NULL,
X        /* class_inited         */      FALSE,
X        /* initialize           */      (XtInitProc) DoInitialize,
X        /* initialize_hook      */      NULL,
X        /* realize              */      (XtRealizeProc) DoRealize,
X        /* actions              */      NULL,
X        /* num_actions          */      0,
X        /* resources            */      (XtResource *) resources,
X        /* num_resources        */      (int) XtNumber(resources),
X        /* xrm_class            */      NULLQUARK,
X        /* compress_motion      */      TRUE,
X        /* compress_exposure    */      TRUE,
X        /* compress_enterleave  */      FALSE,
X        /* visible_interest     */      FALSE,
X        /* destroy              */      (XtWidgetProc) DoDestroy,
X        /* resize               */      (XtWidgetProc) DoResize,
X        /* expose               */      (XtExposeProc) DoExpose,
X        /* set_values           */      NULL,
X        /* set_values_hook      */      NULL,
X        /* set_values_almost    */      XtInheritSetValuesAlmost,`20
X        /* get_values_hook      */      NULL,
X        /* accept_focus         */      NULL,
X        /* version              */      (XtVersionType) XtVersionDontCheck,
X        /* callback_private     */      NULL,
X        /* tm_table             */      NULL,
X        /* query_geometry       */      QueryGeometry,
X        /* display_accelerator  */      NULL,
X        /* extension            */      NULL
X  `7D,
X#ifdef MOTIF
X  `7B     /* border_highlight     */      (XtWidgetProc) _XtInherit,
X        /* border_unhighlight   */      (XtWidgetProc) _XtInherit,
X        /* translations         */      NULL,
X        /* arm_and_activate     */      (XtActionProc) _XtInherit,
X        /* syn_resources        */      NULL,
X        /* num_syn_resources    */      0,
X        /* extension            */      NULL,
X  `7D,
X#endif
X  `7B`09/* translations`09`09*/`09NULL,
X  `7D
X`7D;
X
Xexternaldef (slistwidgetclass)
XSListClass slistwidgetclass = &slistwidgetclassrec;
X`0C
X/*
X * Widget private routines
X */
X
Xstatic void CheckSize(w)
X    SListWidget w;
X`7B
X#ifndef MOTIF
X    if (!XtIsRealized(w)) return;
X/*
X * Hacky: handle resizing of the parent widget by resizing myself
X */
X    if (w->core.parent->core.width  != w->slist.parentWidth `7C`7C
X        w->core.parent->core.height != w->slist.parentHeight) `7B
X`09w->core.width = w->slist.vScroll->core.x - 2;
X`09w->core.height = w->core.parent->core.height - 2 * w->core.border_width;
X`09w->slist.knownHeight = 0;
X`09DoResize(w);`09`09
X`09w->slist.parentWidth = w->core.parent->core.width;
X`09w->slist.parentHeight = w->core.parent->core.height;
X    `7D
X#endif
X`7D
Xstatic int ComputeMaxYAdjust(w)
X    SListWidget w;
X`7B
X    int maxYAdjust = w->slist.LineCnt*w->slist.cellHeight - w->slist.textHei
Vght;
X
X    if (maxYAdjust < 0) maxYAdjust = 0;
X
X    return (maxYAdjust);
X`7D
Xstatic int YToLine(w, y)
X    SListWidget w;
X    int y;
X`7B
X    int line;
X
X    if (y < 0) line = -1;
X    else if (y >= w->slist.textHeight)
X        line = w->slist.topLine + w->slist.rows - 1;
X    else `7B
X        line = (y + w->slist.YAdjust) / w->slist.cellHeight;
X        if (line < 0) line = -1;
X        else if (line >= w->slist.LineCnt) line = -1;
X    `7D
X
X    return (line);
X`7D
X`0C
Xstatic void SetYAdjust(w, yAdjust)
X    SListWidget w;
X    int yAdjust;
X`7B
X    int maxYAdjust = ComputeMaxYAdjust (w);
X
X    if (yAdjust > maxYAdjust) yAdjust = maxYAdjust;
X    if (yAdjust < 0) yAdjust = 0;
X
X    w->slist.YAdjust = yAdjust;
X`7D
X`0C
Xstatic void Flip(w, line)
X    SListWidget w;
X    int line;
X`7B
X    if (line < 0 `7C`7C line >= w->slist.LineCnt `7C`7C
X`09line < w->slist.topLine `7C`7C line > w->slist.topLine + w->slist.rows)
X`09return;
X
X    if (XtIsRealized (w)) XFillRectangle (XtDisplay (w), XtWindow(w),
X        w->slist.flipgc,
X        w->slist.leftMarginWidth + w->slist.textX + 1,
X        (line - w->slist.topLine) * w->slist.cellHeight + w->slist.textY + 1
V,
X        w->slist.textWidth - w->slist.leftMarginWidth - w->slist.textX - 2,
X        w->slist.cellHeight - 2);
X`7D
X
Xstatic void Draw(w, line)
X    SListWidget w;
X    int line;
X`7B
X    int select;
X    char *text;
X
X    int x = w->slist.leftMarginWidth + w->slist.textX + 1;
X    int y = (line - w->slist.topLine) * w->slist.cellHeight +
X`09w->slist.textY + 1;
X    int maxCols, textWidth;
X
X    textWidth = w->core.width - w->slist.leftMarginWidth -
X#ifdef MOTIF
X        2*w->primitive.shadow_thickness -
X#endif
X`092 * w->core.border_width + 6;
X    maxCols = (textWidth / w->slist.cellWidth) - 1;
X
X    if (!XtIsRealized (w)) return;
X
X    if (line - w->slist.topLine >= w->slist.rows) return;
X
X    if (line < 0 `7C`7C y < 0 `7C`7C y >= (int) w->core.height) return;
X    if (line >= w->slist.LineCnt) `7B
X        XClearArea (XtDisplay (w), XtWindow (w), x, y,`20
X            w->slist.textWidth - x - 1,
X            w->slist.cellHeight - 2, 0);
X`09return;
X    `7D
X
X    select = w->slist.selectMapP`5Bline`5D;
X    CallGetDataCallback(w, line, &text);
X    if (text == NULL) text = "-----";
X    if (select) `7B
X        XFillRectangle (XtDisplay (w), XtWindow (w),
X            w->slist.normgc, x, y,
X            w->slist.textWidth - x - 1,
X            w->slist.cellHeight - 2);
X    `7D else `7B
X        XClearArea (XtDisplay (w), XtWindow (w), x, y,`20
X            w->slist.textWidth - x - 1,
X            w->slist.cellHeight - 2, 0);
X    `7D
X    XDrawString (
X        XtDisplay (w), XtWindow (w),
X        (select ? w->slist.invgc : w->slist.normtxtgc),
X        x + w->slist.textMarginWidth,
X        y + w->slist.yFontAdjust, text, MIN(strlen(text), maxCols));
X`7D
X`0C
Xstatic void CallSelectCallbacks(w, eventP)
X    SListWidget w;
X    XEvent *eventP;
X`7B
X    SListCallbackStruct cbData;
X
X    cbData.reason = SListCRSelect;
X    cbData.event = eventP;
X    cbData.select = w->slist.selectParity;
X    if (w->slist.upLine >= w->slist.downLine) `7B
X        cbData.item_number = w->slist.downLine;
X        cbData.item_count = w->slist.upLine - w->slist.downLine + 1;
X`09cbData.select_count = SListGetSelectionCount(w);
X    `7D else `7B
X        cbData.item_number = w->slist.upLine;
X        cbData.item_count = w->slist.downLine - w->slist.upLine + 1;
X`09cbData.select_count = SListGetSelectionCount(w);
X    `7D
X    XtCallCallbacks ((Widget) w, SListNselectCallback, &cbData);
X`7D
Xstatic void CallDoubleClickCallbacks(w, eventP)
X    SListWidget w;
X    XEvent *eventP;
X`7B
X    SListCallbackStruct cbData;
X
X    cbData.reason = SListCRDoubleClick;
X    cbData.event = eventP;
X    cbData.item_number = w->slist.downLine;
X    cbData.item_count = 1;
X    XtCallCallbacks ((Widget) w, SListNdoubleClickCallback, &cbData);
X`7D
X
Xstatic void CallGetDataCallback(w, line, ptr)
XSListWidget w;
Xint line;
Xchar **ptr;
X`7B
X    SListCallbackStruct cbData;
X
X    cbData.reason = SListCRGetData;
X    cbData.event = NULL;
X    cbData.select = 0;
X    cbData.item_number = line;
X    cbData.item_count = 1;
X    cbData.data = ptr;
X    *ptr = NULL;
X    XtCallCallbacks ((Widget) w, SListNgetDataCallback, &cbData);
X`7D
X
Xstatic void SetLineSelection(w, line, selected)
X    SListWidget w;
X    int line, selected;
X`7B
X    int select;
X
X    if ((line == -1) `7C`7C (line == w->slist.LineCnt)) return;
X    select = w->slist.selectMapP`5Bline`5D;
X
X    if (select == selected) return;
X
X    w->slist.selectMapP`5Bline`5D = selected;
X    Flip (w, line);
X`7D
X`0C
Xstatic void NewScrollPosition(w, y)
X    SListWidget w;
X    int y;
X`7B   `20
X    int maxY = w->slist.rows * w->slist.cellHeight;
X    int maxTop = w->slist.LineCnt - w->slist.rows;
X    Arg vsbArg`5B1`5D;
X   `20
X    if (y < 0 `7C`7C y >= maxY) `7B`20
X        if (y < 0) `7B
X            if (w->slist.topLine) `7B
X`09`09w->slist.topLine--;
X                w->slist.YAdjust -= w->slist.cellHeight;
X                if (w->slist.YAdjust < 0) w->slist.YAdjust = 0;
X                StartScrollGrop(w);
X`09`09if (w->slist.vScroll != (Widget) NULL) `7B
X#ifdef MOTIF
X`09`09    XtSetArg(vsbArg`5B0`5D, XmNvalue, w->slist.topLine);
X#else
X`09`09    XtSetArg(vsbArg`5B0`5D, DwtNvalue, w->slist.topLine);
X#endif
X`09`09    XtSetValues(w->slist.vScroll, vsbArg, 1);
X`09`09`7D
X            `7D
X        `7D else `7B
X            maxY = ComputeMaxYAdjust(w);
X`09    if (w->slist.topLine < maxTop) `7B
X`09`09w->slist.topLine++;
X                w->slist.YAdjust += w->slist.cellHeight;
X                if (w->slist.YAdjust > maxY) w->slist.YAdjust = maxY;
X                StartScrollGrop(w);
X`09`09if (w->slist.vScroll != (Widget) NULL) `7B
X#ifdef MOTIF
X`09`09    XtSetArg(vsbArg`5B0`5D, XmNvalue, w->slist.topLine);
X#else
X`09`09    XtSetArg(vsbArg`5B0`5D, DwtNvalue, w->slist.topLine);
X#endif
X`09`09    XtSetValues(w->slist.vScroll, vsbArg, 1);
X`09`09`7D
X            `7D
X        `7D
X    `7D
X`7D
X
Xstatic void NewSelectPosition(w, y)
X    SListWidget w;
X    int y;
X`7B
X    int line;
X
X    if (y < 0) y = 0;
X    if (y >= w->slist.textHeight) y = w->slist.textHeight;
X    line = YToLine (w, y);
X    if (line == -1) line = 0;
X
X    while (line != w->slist.mouseLine) `7B
X        if (w->slist.mouseLine < line)
X            if (w->slist.mouseLine < w->slist.downLine) `7B
X                int select = w->slist.selectMapP`5Bw->slist.mouseLine`5D;
X                SetLineSelection (w, (w->slist.mouseLine)++, select);
X            `7D else SetLineSelection (w, ++(w->slist.mouseLine), w->slist.s
VelectParity);
X        else
X            if (w->slist.mouseLine > w->slist.downLine) `7B
X                int select = w->slist.selectMapP`5Bw->slist.mouseLine`5D;
X                SetLineSelection (w, (w->slist.mouseLine)--, select);
X            `7D else SetLineSelection (w, --(w->slist.mouseLine), w->slist.s
VelectParity);
X    `7D
X`7D  `20
X`0C
Xstatic XtCallbackProc scrollCallback(w, closure, call_data)
X    Widget w;
X    caddr_t closure;
X#ifdef MOTIF
X    XmScrollBarCallbackStruct *call_data;
X#else
X    DwtScrollBarCallbackStruct *call_data;
X#endif
X`7B
X    SListWidget sl = (SListWidget) closure;
X
X    switch (call_data->reason) `7B
X#ifdef MOTIF
X        case XmCR_INCREMENT:
X        case XmCR_DECREMENT:
X        case XmCR_PAGE_INCREMENT:
X        case XmCR_PAGE_DECREMENT:
X        case XmCR_DRAG:
X#else
X        case DwtCRUnitInc:
X        case DwtCRUnitDec:
X        case DwtCRPageInc:
X        case DwtCRPageDec:
X        case DwtCRDrag:
X#endif
X`09    if (call_data->value < 0) call_data->value = 0;
X`09    if (call_data->value >= sl->slist.LineCnt)
X`09`09call_data->value = sl->slist.LineCnt - 1;
X`09    sl->slist.topLine = call_data->value;
X            sl->slist.YAdjust = call_data->value * sl->slist.cellHeight;
X            StartScrollGrop (sl);
X            break;
X
X    `7D
X    return 0;
X`7D
X
Xstatic void Mb1PressInList(w, eventP)
X    SListWidget w;
X    XButtonEvent *eventP;
X`7B
X    int line;
X    int needsRepaint = 0;
X
X    CheckSize(w);
X    w->slist.mouseLine = w->slist.downLine = w->slist.upLine = line =
X        YToLine (w, eventP->y - w->slist.textY);
X    /*
X     * check for pending timer
X     */
X    if (w->slist.ClickTimerID != 0) `7B
X        if (w->slist.downLine != w->slist.ClickLine) `7B  /* Same line? */
X            XtRemoveTimeOut(w->slist.ClickTimerID);     /* No, not a double
V click */
X            CallSelectCallbacks(w, NULL);       /* deliver initial selection
V */
X            w->slist.ClickTimerID = 0;          /* Zap the click timer */
X        `7D else `7B
X            w->slist.listIsGrabbed = 1;         /* grabbed (for up-click) */
X            return;                             /* else wait for up-click */
X        `7D
X    `7D
X    /*
X     * On MB1 down, deselect all. No deselect for Shift-MB1.
X     */
X    if (!(eventP->state & ShiftMask)) `7B
X        w->slist.highlightedLine = -1;
X        for (line=0;line <w->slist.LineCnt; line++) `7B
X            if (w->slist.selectMapP`5Bline`5D != 0) `7B
X                needsRepaint = 1;
X            `7D
X            w->slist.selectMapP`5Bline`5D = 0;
X        `7D
X    `7D
X    if (needsRepaint)
X        Repaint (w);
X
X    w->slist.listIsGrabbed = 1;
X
X    w->slist.mouseLine = w->slist.downLine = w->slist.upLine = line =
X        YToLine (w, eventP->y - w->slist.textY);
X
X    if ((line != -1) && (line < w->slist.LineCnt)) `7B
X        w->slist.selectParity = (w->slist.selectMapP`5Bline`5D == 0);
X        SetLineSelection (w, line, w->slist.selectParity);
X    `7D else w->slist.selectParity = 1;
X`7D
X
Xstatic void ClickTimer(w, id)
X    SListWidget w;
X    XtIntervalId id;
X`7B
X/*
X * Here when the timer expires
X */
X
X    if (w->slist.downLine != -1) `7B
X`09if (w->slist.DownCount > 1) `7B
X`09    CallDoubleClickCallbacks (w, NULL); /* call double click procs */
X`09`7D else `7B
X`09    CallSelectCallbacks (w, NULL);  /* call select procs */
X`09`7D
X    `7D
X    w->slist.ClickTimerID = 0;
X`7D
Xstatic void ButtonReleaseHandler(w, closure, eventP)
X    SListWidget w;
X    Opaque closure;
X    XButtonEvent *eventP;
X`7B
X    if (w->slist.listIsGrabbed) `7B
X        int y = eventP->y - w->slist.textY;
X
X        /* If we're still Scrolling, treat the upclick as though it were
X         * at the top or bottom edge of the list.  This prevents unseen
X         * lines from being selected. */
X
X        if (y < 0)  `7B
X`09    Flip(w, 0);
X`09    y = 0;
X`09`7D
X        else if (y >= w->slist.textHeight) y = w->slist.textHeight - 1;
X        w->slist.upLine = YToLine(w, y);
X        if (w->slist.upLine == -1)
X                w->slist.upLine = w->slist.LineCnt - 1;
X        NewScrollPosition (w, 0);           /* shut off scrolling */
X
X        w->slist.listIsGrabbed = 0;
X        if (w->slist.upLine != w->slist.downLine) `7B     /* same line? if n
Vot...*/
X            if (w->slist.ClickTimerID != 0) `7B           /* timer pending?
V */
X                XtRemoveTimeOut(w->slist.ClickTimerID);/* Then cancel it */
X                w->slist.ClickTimerID = 0;
X            `7D
X            CallSelectCallbacks (w, eventP);    /* call select procs */
X        `7D else `7B
X/*
X * same line - initiate double-click timer
X */
X            if (w->slist.ClickTimerID == 0) `7B           /* first time */
X                w->slist.ClickTimerID = XtAppAddTimeOut (
X`09`09`09`09XtWidgetToApplicationContext((Widget) w),
X                                (unsigned long) w->slist.ClickInterval,
X                                (XtTimerCallbackProc) ClickTimer,
X                                (caddr_t) w);
X                w->slist.DownCount = 1;
X                w->slist.DownTime = eventP->time;
X                w->slist.ClickLine = w->slist.upLine;
X            `7D else `7B
X                w->slist.DownCount++;                   /* count another dow
Vn */
X            `7D
X        `7D
X    `7D`20
X`7D
X
Xstatic void ButtonPressHandler(w, closure, eventP)
X    SListWidget w;
X    Opaque closure;
X    XButtonEvent *eventP;
X`7B
X
X    /* Handle chorded cancel by turning the ButtonPress into a ButtonRelease
V. */
X
X    if (w->slist.listIsGrabbed) `7B
X        ButtonReleaseHandler (w, closure, eventP);
X        return;
X    `7D
X
X    if (!w->slist.LineCnt) return;                      /* nothing to do */
X
X    if (eventP->button == Button1)
X        Mb1PressInList (w, eventP);
X
X`7D
X
Xstatic void PointerMotionHandler(w, closure, eventP)
X    SListWidget w;
X    Opaque closure;
X    XMotionEvent *eventP;
X`7B
X    if (w->slist.listIsGrabbed) `7B
X        NewSelectPosition (w, eventP->y - w->slist.textY);
X        NewScrollPosition (w, eventP->y - w->slist.textY);
X    `7D`20
X`7D
X`0C
Xstatic void DrawExposedLines(w)
X    SListWidget w;
X`7B
X    int line, LineCnt;
X    char *exposeMapP;
X
X    if (!w->slist.anyAreExposed) return;        /* nothing to do */
X
X    LineCnt = w->slist.LineCnt;
X    for (line=0, exposeMapP=w->slist.exposeMapP; line<LineCnt; line++, expos
VeMapP++)
X        if (*exposeMapP) `7B
X            Draw (w, line);
X            *exposeMapP = 0;
X        `7D
X
X    w->slist.anyAreExposed = 0;
X`7D
X
Xstatic void SaveExposeRegion(w, x, vY, width, height)
X    SListWidget w;
X    int x, vY, width, height;
X`7B
X    int firstLine, lastLine, line;
X
X    firstLine = (vY - w->slist.textY) / w->slist.cellHeight;
X    if (firstLine < 0) firstLine = 0;
X    if (firstLine >= w->slist.LineCnt) return;
X
X    lastLine = (vY - w->slist.textY + height - 1) / w->slist.cellHeight;
X    if (lastLine >= w->slist.LineCnt) lastLine = w->slist.LineCnt - 1;
X    if (lastLine < 0) return;
X
X    for (line=firstLine; line <= lastLine; line++) `7B
X        w->slist.exposeMapP`5Bline`5D = 1;
X        w->slist.anyAreExposed = 1;
X    `7D
X`7D
X
Xstatic void StartScrollGrop(w)
X    SListWidget w;
X`7B
X    SaveExposeRegion (w, 0, w->slist.YAdjust, w->slist.textWidth,
X        w->slist.textHeight);
X
X    DrawExposedLines (w);
X`7D
X`0C
Xstatic void Repaint(w)
X    SListWidget w;
X`7B
X    if (XtIsRealized (w)) XClearArea (XtDisplay (w), XtWindow(w),
X        w->slist.textX, w->slist.textY,
X        w->slist.textWidth, w->slist.textHeight, 0);
X
X    SaveExposeRegion (w, 0, w->slist.YAdjust, w->slist.textWidth,
X        w->slist.textHeight);
X
X    DrawExposedLines (w);
X`7D
X
Xstatic void DoExpose(w, eventP)
X    SListWidget w;
X    XEvent *eventP;
X`7B
X    CheckSize(w);
X    if (!XtIsRealized(w)) return;
X
X/*    if (XtIsRealized (w)) XClearArea (XtDisplay (w), XtWindow (w),
X        eventP->xexpose.x,
X        eventP->xexpose.y,`20
X        eventP->xexpose.width, eventP->xexpose.height, 0);*/
X
X#ifdef MOTIF
X    _XmDrawShadow(XtDisplay(w), XtWindow(w),
X`09w->primitive.top_shadow_GC, w->primitive.bottom_shadow_GC,
X`09w->primitive.shadow_thickness, 0, 0, w->core.width, w->core.height);
X#endif
X    SaveExposeRegion (w,
X        eventP->xexpose.x,
X        eventP->xexpose.y + w->slist.YAdjust,
X        eventP->xexpose.width,
X        eventP->xexpose.height);
X
X    /* If this is not a primary Expose event, simply return. */
X
X    if (eventP->xexpose.count) return;
X
X    DrawExposedLines (w);
X`7D
Xstatic XtGeometryResult QueryGeometry(w, proposed, answer)
XSListWidget w;
XXtWidgetGeometry *proposed, *answer;
X`7B
X#define Set(bit) (proposed->request_mode & bit)
X
X    /* Return preferred width + Height */
X    answer->request_mode = CWWidth `7C CWHeight;
X
X    answer->width = w->slist.cellWidth * w->slist.cols +
X        w->slist.leftMarginWidth +`20
X#ifdef MOTIF
X        2*w->primitive.shadow_thickness +
X#endif
X`092 * w->core.border_width + 6;
X
X#ifdef MOTIF
X    answer->height = w->slist.rows * w->slist.cellHeight +
X        4*w->primitive.shadow_thickness;
X#else
X    answer->height = w->slist.rows * w->slist.cellHeight + 2;
X#endif
X
X    if (Set(CWWidth) && proposed->width == answer->width &&
X        Set(CWHeight) && proposed->height == answer->height) `7B
X        return XtGeometryYes;
X    `7D`20
X    if (answer->width == w->core.width && answer->height == w->core.height)
V `7B
X        return XtGeometryNo;
X    `7D
X    return XtGeometryAlmost;
X`7D
X#undef Set
X`0C
Xstatic void DoInitialize(request, w)
X    SListWidget request, w;
X`7B
X    XFontStruct *fontP;
X    XGCValues`09values;
X    short`09fontIndex;
X    Arg         vsbArgs`5B50`5D;
X    int         i;
X    int         requiredWidth;
X    unsigned long charWidth = 0;
X
X    w->slist.YAdjust = 0;
X    w->slist.listIsGrabbed = 0;
X    w->slist.selectMapP =       (char*) 0;
X    w->slist.LineCnt = w->slist.anyAreExposed = 0;
X    w->slist.exposeMapP = (char*) 0;
X    w->slist.mapLen =   0;
X
X    w->slist.topLine = 0;
X    w->slist.highlightedLine =  -1;
X
X    w->slist.ClickTimerID = w->slist.DownCount = w->slist.ClickLine = 0;
X
X#ifdef MOTIF
X    if (w->slist.fontRecP == NULL) `7B
X        fontP = XLoadQueryFont(XtDisplay(w), "fixed");
X    `7D else `7B
X        _XmFontListSearch((XmFontList)w->slist.fontRecP, "default",
X`09`09 &fontIndex, &fontP);
X    `7D
X    if (!fontP)
X        fontP = XLoadQueryFont(XtDisplay(w), "fixed");
X    w->slist.fontP = fontP;
X#else
X    /* Simply use the first font in the font list. */
X
X    if (w->slist.fontRecP == NULL) `7B
X        fontP = w->slist.fontP = XLoadQueryFont(XtDisplay(w), "fixed");
X    `7D else `7B
X        fontP = w->slist.fontP = w->slist.fontRecP->font;
X    `7D
X#endif
X    /* Compute some useful constants. */
X
X    w->slist.cellHeight = fontP->max_bounds.descent + fontP->max_bounds.asce
Vnt + 2;
X    w->slist.yFontAdjust = fontP->max_bounds.ascent;
X
X    /* Make a reasonable initial size for the widget if none was specified.
V */
X
X    if ((!XGetFontProperty(fontP, XA_QUAD_WIDTH, &charWidth)) `7C`7C charWid
Vth==0)`7B
X        if (fontP->per_char && fontP->min_char_or_byte2 <= '0' &&
X                               fontP->max_char_or_byte2 >= '0')
X            charWidth = fontP->per_char`5B'0' - fontP->min_char_or_byte2`5D.
Vwidth;
X        else
X            charWidth = fontP->max_bounds.width;
X    `7D
X    if (charWidth <= 0) charWidth = 1;
X    requiredWidth = w->slist.cols * charWidth +
X#ifdef MOTIF
X`092*w->primitive.shadow_thickness +
X#endif
X        2 * (w->core.border_width + 6);
X
X    if ((int) w->core.width < requiredWidth) `7B
X        w->core.width =  requiredWidth;
X    `7D
X    w->slist.cellWidth = charWidth;
X
X    if (!w->slist.rows) `7B
X        w->slist.rows = (int) w->core.height / w->slist.cellHeight;
X    `7D else `7B
X#ifdef MOTIF
X        w->core.height = w->slist.rows * w->slist.cellHeight +
X`09    4 * w->primitive.shadow_thickness;
X#else
X        w->core.height = w->slist.rows * w->slist.cellHeight + 2;
X#endif
X    `7D
X
X    w->slist.leftMarginWidth = w->core.border_width;
X    w->slist.knownHeight = w->core.height;
X    w->slist.knownWidth = w->core.width;
X#ifdef MOTIF
X    w->slist.textX = w->slist.textY = 2 * w->core.border_width +`20
X`09w->primitive.shadow_thickness;
X    w->slist.textWidth = w->core.width - 4*w->core.border_width -`20
X`092 * w->primitive.shadow_thickness;
X#else
X    w->slist.textX = w->slist.textY = 0;
X    w->slist.textWidth = w->core.width;
X#endif
X    w->slist.textHeight = w->slist.rows * w->slist.cellHeight;
X
X    /* Load graphics contexts. */
X
X    values.font = fontP->fid;
X    values.foreground = w->slist.foreground;
X    values.background = w->core.background_pixel;
X    values.function = GXcopy;
X    w->slist.normgc = XtGetGC ((Widget) w,
X        GCFont `7C GCForeground `7C GCBackground `7C GCFunction, &values);
X
X    w->slist.normtxtgc = XtGetGC ((Widget) w,
X        GCFont `7C GCForeground `7C GCBackground `7C GCFunction, &values);
X
X    values.font = fontP->fid;
X    values.foreground = w->core.background_pixel;
X    values.background = w->slist.foreground;
X    values.function = GXcopy;
X    w->slist.invgc = XtGetGC((Widget) w,
X        GCFont `7C GCForeground `7C GCBackground `7C GCFunction, &values);
X
X    values.function = GXinvert;
X    values.plane_mask = w->core.background_pixel `5E w->slist.foreground;
X    w->slist.flipgc = XtGetGC ((Widget) w,
X        GCFunction `7C GCPlaneMask, &values);
X
X    i = 0;
X    VSCallBack`5B0`5D.closure = (caddr_t)w;
X#ifdef MOTIF
X    XtSetArg(vsbArgs`5Bi`5D, XmNorientation,      XmVERTICAL);
V              i++;
X    XtSetArg(vsbArgs`5Bi`5D, XmNheight,           w->core.height);
V          i++;
X    XtSetArg(vsbArgs`5Bi`5D, XmNvalue,            w->slist.YAdjust);
V        i++;
X    if (w->slist.LineCnt > w->slist.rows) `7B
X        XtSetArg(vsbArgs`5Bi`5D, XmNminimum,      0);
V                       i++;
X        XtSetArg(vsbArgs`5Bi`5D, XmNmaximum,      w->slist.LineCnt);
V        i++;
X        XtSetArg(vsbArgs`5Bi`5D, XmNsliderSize,   w->slist.rows);
V           i++;
X    `7D else `7B
X        XtSetArg(vsbArgs`5Bi`5D, XmNminimum,      0);
V                       i++;
X        XtSetArg(vsbArgs`5Bi`5D, XmNmaximum,      5);
V                       i++;
X        XtSetArg(vsbArgs`5Bi`5D, XmNsliderSize,   5);
V                       i++;
X    `7D
X    XtSetArg(vsbArgs`5Bi`5D, XmNincrement, 1);
V                              i++;
X    XtSetArg(vsbArgs`5Bi`5D, XmNpageIncrement, w->slist.rows-1);
V            i++;
X    XtSetArg(vsbArgs`5Bi`5D, XmNincrementCallback, VSCallBack);
V             i++;
X    XtSetArg(vsbArgs`5Bi`5D, XmNdecrementCallback, VSCallBack);
V             i++;
X    XtSetArg(vsbArgs`5Bi`5D, XmNpageIncrementCallback, VSCallBack);
V         i++;
X    XtSetArg(vsbArgs`5Bi`5D, XmNpageDecrementCallback, VSCallBack);
V         i++;
X    XtSetArg(vsbArgs`5Bi`5D, XmNdragCallback,    VSCallBack);
V               i++;
X    w->slist.vScroll = XtCreateManagedWidget("vpaneScroll",
X        xmScrollBarWidgetClass, XtParent (w), vsbArgs, i);
X
X    XmScrolledWindowSetAreas(XtParent(w), (Widget) NULL, w->slist.vScroll,
X`09`09(Widget) w);
X#else
X    XtSetArg(vsbArgs`5Bi`5D, DwtNorientation,     DwtOrientationVertical);
V  i++;
X    XtSetArg(vsbArgs`5Bi`5D, DwtNheight,          w->core.height);
V          i++;
X    XtSetArg(vsbArgs`5Bi`5D, DwtNvalue,           w->slist.YAdjust);
V        i++;
X    if (w->slist.LineCnt > w->slist.rows) `7B
X        XtSetArg(vsbArgs`5Bi`5D, DwtNminValue,    0);
V                       i++;
X        XtSetArg(vsbArgs`5Bi`5D, DwtNmaxValue,    w->slist.LineCnt);
V        i++;
X        XtSetArg(vsbArgs`5Bi`5D, DwtNshown,       w->slist.rows);
V           i++;
X`09XtSetArg(vsbArgs`5Bi`5D, DwtNpageInc,     w->slist.rows-1);`09`09i++;
X    `7D else `7B
X        XtSetArg(vsbArgs`5Bi`5D, DwtNminValue,    0);
V                       i++;
X        XtSetArg(vsbArgs`5Bi`5D, DwtNmaxValue,    1);
V                       i++;
X    `7D
X    XtSetArg(vsbArgs`5Bi`5D, DwtNinc,             1);
V                       i++;
X    XtSetArg(vsbArgs`5Bi`5D, DwtNunitIncCallback, VSCallBack);
V              i++;
X    XtSetArg(vsbArgs`5Bi`5D, DwtNunitDecCallback, VSCallBack);
V              i++;
X    XtSetArg(vsbArgs`5Bi`5D, DwtNpageIncCallback, VSCallBack);
V              i++;
X    XtSetArg(vsbArgs`5Bi`5D, DwtNpageDecCallback, VSCallBack);
V              i++;
X    XtSetArg(vsbArgs`5Bi`5D, DwtNdragCallback,    VSCallBack);
V              i++;
X    w->slist.vScroll = XtCreateManagedWidget("vpaneScroll",
X        scrollwidgetclass, XtParent (w), vsbArgs, i);
X    DwtScrollWindowSetAreas(XtParent(w), NULL, w->slist.vScroll, w);
X    w->slist.parentWidth = w->slist.parentHeight = 0;
X#endif
X    XtAugmentTranslations((Widget) w,
X`09(XtTranslations) slistwidgetclassrec.slist_class.translations);
X`7D
X`0C
Xstatic void DoRealize(w, maskP, attributesP)
X    SListWidget w;
X    Mask *maskP;
X    XSetWindowAttributes *attributesP;
X`7B
X
X    Boolean ResizeNeeded = False;
X
X    if (w->core.width != w->slist.knownWidth `7C`7C
X        w->core.height != w->slist.knownHeight)
X            ResizeNeeded = True;
X
X    /* Make sure the window is automatically cleared whenever it is resized.
V */
X
X    *maskP `7C= CWBitGravity;
X    attributesP->bit_gravity = ForgetGravity;
X
X    XtCreateWindow ((Widget) w, InputOutput, CopyFromParent, *maskP,attribut
VesP);
X
X    /* Establish passive button grabs and declare event handlers. */
X
X    XGrabButton (
X        XtDisplay (w),                                  /* display */
X        1,                                              /* button_grab */
X        AnyModifier,                                    /* modifiers */
X        XtWindow (w),                                   /* window */
X        0,                                              /* owner_events */
X        (ButtonPressMask `7C ButtonReleaseMask `7C Button1MotionMask),
X                                                        /* event_mask */
X        GrabModeAsync,                                  /* pointer_mode */
X        GrabModeAsync,                                  /* keyboard_mode */
X        None,                                           /* confine_to */
X        None);                                          /* cursor */
X
X    XtAddRawEventHandler ((Widget) w, ButtonPressMask, 0,`20
X`09`09`09`09(XtEventHandler) ButtonPressHandler, 0);
X    XtAddRawEventHandler ((Widget) w, PointerMotionMask, 0,
X`09`09`09`09(XtEventHandler) PointerMotionHandler, 0);
X    XtAddRawEventHandler ((Widget) w, ButtonReleaseMask, 0,`20
X`09`09`09`09(XtEventHandler) ButtonReleaseHandler, 0);
X
X    w->slist.leftMarginWidth = w->core.border_width;
X
X    if (ResizeNeeded)
X        DoResize (w);
X`7D
X
Xstatic void DoResize(w)
X    SListWidget w;
X`7B
X    Arg vsbArgs`5B30`5D;
X    int i;
X    Boolean resized = False;
X
X    if (w->core.height != w->slist.knownHeight) `7B
X        resized = True;
X        w->slist.knownHeight = w->core.height;
X        SetYAdjust (w, 0);
X#ifdef MOTIF
X        w->slist.rows =`09(int) (w->core.height -`20
X`09`092*w->primitive.shadow_thickness) / w->slist.cellHeight;
X#else
X        w->slist.rows = w->core.height / w->slist.cellHeight;
X#endif
X`09w->slist.textHeight = w->slist.rows * w->slist.cellHeight;
X        if (w->slist.vScroll != (Widget) NULL) `7B
X            i = 0;
X#ifdef MOTIF
X            XtSetArg(vsbArgs`5Bi`5D, XmNvalue, 0);i++;
X            XtSetArg(vsbArgs`5Bi`5D, XmNincrement, 1);i++;
X            XtSetArg(vsbArgs`5Bi`5D, XmNpageIncrement, w->slist.rows-1);i++;
X            if (w->slist.LineCnt > w->slist.rows) `7B
X                XtSetArg(vsbArgs`5Bi`5D, XmNminimum,0);i++;
X                XtSetArg(vsbArgs`5Bi`5D, XmNmaximum,w->slist.LineCnt);i++;
X                XtSetArg(vsbArgs`5Bi`5D, XmNsliderSize, w->slist.rows);i++;
X            `7D else `7B
X                XtSetArg(vsbArgs`5Bi`5D, XmNminimum,0);i++;
X                XtSetArg(vsbArgs`5Bi`5D, XmNmaximum,5);i++;
X                XtSetArg(vsbArgs`5Bi`5D, XmNsliderSize,5);i++;
X            `7D
X            XtSetValues(w->slist.vScroll, vsbArgs, i);
X#else
X            XtSetArg(vsbArgs`5Bi`5D, DwtNvalue, 0);i++;
X            if (w->slist.LineCnt > w->slist.rows) `7B
X                XtSetArg(vsbArgs`5Bi`5D, DwtNminValue,0);i++;
X                XtSetArg(vsbArgs`5Bi`5D, DwtNmaxValue,w->slist.LineCnt);i++;
X                XtSetArg(vsbArgs`5Bi`5D, DwtNshown, w->slist.rows);i++;
X`09`09XtSetArg(vsbArgs`5Bi`5D, DwtNpageInc, w->slist.rows-1);i++;
X            `7D else `7B
X                XtSetArg(vsbArgs`5Bi`5D, DwtNminValue,0);i++;
X                XtSetArg(vsbArgs`5Bi`5D, DwtNmaxValue,1);i++;
X            `7D
X            XtSetValues(w->slist.vScroll, vsbArgs, i);
X#endif
X        `7D
X    `7D
X    if (w->core.width != w->slist.knownWidth) `7B
X        resized = True;
X        w->slist.textWidth = w->core.width - 2 * (w->slist.textX);
X        w->slist.knownWidth = w->core.width;
X    `7D
X    if (resized && w->core.window != (Window) NULL) `7B
X        XMoveResizeWindow(XtDisplay(w), XtWindow(w),
X                w->core.x, w->core.y, w->core.width, w->core.height);
X     `7D
X`7D
X
Xstatic void DoDestroy(w)
X    SListWidget w;
X`7B
X`7D
XXtActionProc slistForwardPage(widget, event, params, num_params)
XWidget widget;
XXEvent *event;
Xchar **params;
XCardinal *num_params;
X`7B
X    SListWidget w = (SListWidget) widget;
X    int topLine = w->slist.topLine;
X
X    if (topLine < 0) topLine = -1;
X    else if (topLine > w->slist.LineCnt) topLine = w->slist.LineCnt;
X    SListSetTop(w, topLine + w->slist.rows - 1);
X    return 0;
X`7D
XXtActionProc slistBackwardPage(widget, event, params, num_params)
XWidget widget;
XXEvent *event;
Xchar **params;
XCardinal *num_params;
X`7B
X    SListWidget w = (SListWidget) widget;
X    int topLine;
X
X    topLine = w->slist.topLine;
X    if (topLine < 0) topLine = -1;
X    else if (topLine > w->slist.LineCnt) topLine = w->slist.LineCnt;
X    SListSetTop(w, topLine - w->slist.rows + 1);
X    return 0;
X`7D
XXtActionProc slistForwardLine(widget, event, params, num_params)
XWidget widget;
XXEvent *event;
Xchar **params;
XCardinal *num_params;
X`7B
X    SListWidget w = (SListWidget) widget;
X    int topLine = SListGetHighlight(w);
X    int line;
X    Boolean needsRepaint = 0;
X
X    if (topLine >= 0) SListUnhighlight(w, topLine);
X    for (line=0;line <w->slist.LineCnt; line++) `7B
X`09if (w->slist.selectMapP`5Bline`5D != 0 && line != topLine) `7B
X`09    needsRepaint = 1;
X`09`7D
X`09w->slist.selectMapP`5Bline`5D = 0;
X    `7D
X    if (needsRepaint)
X        Repaint (w);
X
X    if (topLine < 0) topLine = w->slist.topLine;
X    if (topLine < 0) topLine = -1;
X    topLine++;
X    if (topLine >= w->slist.LineCnt) topLine = w->slist.LineCnt - 1;
X    if (topLine < w->slist.topLine)
X`09SListSetTop(w, topLine);
X    if (topLine >= (w->slist.topLine + w->slist.rows)) `7B
X`09SListSetTop(w, topLine - w->slist.rows + 1);
X    `7D
X    SListHighlight(w, topLine);
X    return 0;
X`7D
XXtActionProc slistBackwardLine(widget, event, params, num_params)
XWidget widget;
XXEvent *event;
Xchar **params;
XCardinal *num_params;
X`7B
X    SListWidget w = (SListWidget) widget;
X    int topLine = SListGetHighlight(w);
X
X    int line;
X    Boolean needsRepaint = 0;
X
X    if (topLine >= 0) SListUnhighlight(w, topLine);
X    for (line=0;line <w->slist.LineCnt; line++) `7B
X`09if (w->slist.selectMapP`5Bline`5D != 0 && line != topLine) `7B
X`09    needsRepaint = 1;
X`09`7D
X`09w->slist.selectMapP`5Bline`5D = 0;
X    `7D
X    if (needsRepaint)
X        Repaint (w);
X
X    if (topLine < 0) topLine = w->slist.topLine;
X    if (topLine < 0) topLine = 0;
X    topLine--;
X    if (topLine < 0) topLine = 0;
X    SListHighlight(w, topLine);
X    if (topLine < w->slist.topLine)
X`09SListSetTop(w, topLine);
X    if (topLine >= (w->slist.topLine + w->slist.rows)) `7B
X`09SListSetTop(w, topLine - w->slist.rows + 1);
X    `7D
X    return 0;
X`7D
X`0C
Xstatic void ClassInitialize()
X`7B
X    slistwidgetclassrec.core_class.actions = slistActionsTable;
X    slistwidgetclassrec.core_class.num_actions = XtNumber(slistActionsTable)
V;
X    slistwidgetclassrec.slist_class.translations =
X`09(String) XtParseTranslationTable(slistBindings);
X    XtAddActions(slistActionsTable, XtNumber(slistActionsTable));
X`7D
X`0C
X/*
X * Public routines
X */
Xvoid SListLoad(w, LineCnt)
X    SListWidget w;
X    int LineCnt;
X`7B
X    int line;
X    char *exposeMapP;
X    char *selectMapP;
X    Arg vsbArgs`5B10`5D;
X    int i;
X
X    w->slist.LineCnt = LineCnt;
X    w->slist.topLine = 0;
X
X    /* Reallocate the expose and select maps if not big enough. */
X
X    if (w->slist.mapLen < LineCnt) `7B
X        w->slist.mapLen = LineCnt + 100;
X        XtFree (w->slist.exposeMapP);
X        w->slist.exposeMapP =  XtMalloc (w->slist.mapLen);
X        XtFree (w->slist.selectMapP);
X        w->slist.selectMapP =  XtMalloc (w->slist.mapLen);
X    `7D
X
X    /* Clear the maps. */
X
X    for (line=0, exposeMapP=w->slist.exposeMapP, selectMapP = w->slist.selec
VtMapP;
X         line<LineCnt; line++) `7B
X        *(exposeMapP++) = 0;
X        *(selectMapP++) = 0;
X    `7D
X
X    w->slist.highlightedLine = -1;
X    w->slist.anyAreExposed = w->slist.YAdjust = 0;
X    SetYAdjust (w, 0);
X    if (w->slist.vScroll != (Widget) NULL) `7B
X        i = 0;
X#ifdef MOTIF
X        XtSetArg(vsbArgs`5Bi`5D, XmNvalue, 0);i++;
X        XtSetArg(vsbArgs`5Bi`5D, XmNincrement, 1);i++;
X        XtSetArg(vsbArgs`5Bi`5D, XmNpageIncrement, w->slist.rows-1);i++;
X        if (w->slist.LineCnt > w->slist.rows) `7B
X            XtSetArg(vsbArgs`5Bi`5D, XmNminimum,0);i++;
X            XtSetArg(vsbArgs`5Bi`5D, XmNmaximum,w->slist.LineCnt);i++;
X            XtSetArg(vsbArgs`5Bi`5D, XmNsliderSize, w->slist.rows);i++;
X        `7D else `7B
X            XtSetArg(vsbArgs`5Bi`5D, XmNminimum,0);i++;
X            XtSetArg(vsbArgs`5Bi`5D, XmNmaximum,5);i++;
X            XtSetArg(vsbArgs`5Bi`5D, XmNsliderSize,5);i++;
X        `7D
X#else
X        XtSetArg(vsbArgs`5Bi`5D, DwtNvalue, 0);i++;
X        XtSetArg(vsbArgs`5Bi`5D, DwtNminValue, 0);i++;
X        if (w->slist.LineCnt > w->slist.rows) `7B
X            XtSetArg(vsbArgs`5Bi`5D, DwtNminValue, 0);i++;
X            XtSetArg(vsbArgs`5Bi`5D, DwtNmaxValue, w->slist.LineCnt);i++;
X            XtSetArg(vsbArgs`5Bi`5D, DwtNshown, w->slist.rows);i++;
X`09    XtSetArg(vsbArgs`5Bi`5D, DwtNpageInc, w->slist.rows-1);i++;
X        `7D else `7B
X            XtSetArg(vsbArgs`5Bi`5D, DwtNminValue, 0);i++;
X            XtSetArg(vsbArgs`5Bi`5D, DwtNmaxValue, 1);i++;
X        `7D
X#endif
X        XtSetValues(w->slist.vScroll, vsbArgs, i);
X    `7D
X
X    Repaint (w);
X`7D
X
Xint SListGetTop(w)
X    SListWidget w;
X`7B
X    int topLine = w->slist.topLine;
X
X    if (topLine < 0) topLine = -1;
X    else if (topLine > w->slist.LineCnt) topLine = w->slist.LineCnt;
X    return topLine;
X`7D
Xint SListGetBottom(w)
X    SListWidget w;
X`7B
X    int botLine = w->slist.topLine + w->slist.rows;
X
X    if (botLine < 0) botLine = -1;
X    else if (botLine > w->slist.LineCnt) botLine = w->slist.LineCnt;
X    return botLine;
X`7D
Xint SListGetRows(w)
X    SListWidget w;
X`7B
X    return w->slist.rows;
X`7D
Xvoid SListSetTop(w, item)
X    SListWidget w;
X    int item;
X`7B
X    int topLine;
X    Arg vsbArg`5B1`5D;
X
X    topLine = w->slist.topLine;
X    if (topLine < 0) topLine = -1;
X    else if (topLine > w->slist.LineCnt) topLine = w->slist.LineCnt;
X    if (item > w->slist.LineCnt - w->slist.rows)
X        item = w->slist.LineCnt - w->slist.rows;
X    if (item < 0) item = 0;
X    if (item == topLine) return;
X    w->slist.YAdjust = item * w->slist.cellHeight;
X    w->slist.topLine = item;
X    if (w->slist.vScroll != (Widget) NULL) `7B
X#ifdef MOTIF
X        XtSetArg(vsbArg`5B0`5D, XmNvalue, item);
X#else
X        XtSetArg(vsbArg`5B0`5D, DwtNvalue, item);
X#endif
X        XtSetValues(w->slist.vScroll, vsbArg, 1);
X    `7D
X    Repaint(w);
X`7D
Xvoid SListUpdateLine(w, line)
X    SListWidget w;
X    int line;
X`7B
X    Draw(w, line);
X`7D
Xvoid SListSelectAll(w, select)
X    SListWidget w;
X    int select;
X`7B
X    int line;
X    int needsRepaint = 0;
X
X    for (line=0; line <w->slist.LineCnt; line++) `7B
X        if (line != w->slist.highlightedLine &&
X            w->slist.selectMapP`5Bline`5D != select) `7B
X            needsRepaint = 1;
X            w->slist.selectMapP`5Bline`5D = select;
X        `7D
X    `7D
X    if (needsRepaint)
X        Repaint (w);
X`7D
X
Xvoid SListUnhighlight(w)
X    SListWidget w;
X`7B
X    if (w->slist.highlightedLine == -1) return;
X
X    SetLineSelection(w, w->slist.highlightedLine, False);
X    w->slist.highlightedLine = -1;
X`7D
Xvoid SListHighlight(w, line)
X    SListWidget w;
X    int line;
X`7B
X    if (line == w->slist.highlightedLine) return;       /* don't set it agai
Vn */
X    if (w->slist.highlightedLine != -1) `7B
X        SetLineSelection(w, w->slist.highlightedLine, False);
X    `7D   `20
X
X    w->slist.highlightedLine = line;
X    SetLineSelection(w, line, True);
X`7D
Xint SListGetHighlight(w)
X    SListWidget w;
X`7B
X    return w->slist.highlightedLine;
X`7D
X
XWidget SListCreate(pW, nameP, argsP, argCnt)
X    Widget pW;
X    char *nameP;
X    Arg *argsP;
X    int argCnt;
X`7B
X    return (XtCreateWidget (nameP, (WidgetClass) slistwidgetclass, pW,
X`09`09argsP, argCnt));
X`7D
X
XBoolean SListIsSelected(sl, line)
X    SListWidget sl;
X    int line;
X`7B
X    if (line > sl->slist.mapLen `7C`7C line < 0)
X        return False;
X
X    return sl->slist.selectMapP`5Bline`5D;
X`7D
Xint SListGetSelectionCount(sl)
X    SListWidget sl;
X`7B
X    int count = 0;
X    int i;
X
X    for (i=0;i < sl->slist.LineCnt; i++) `7B
X`09if (sl->slist.selectMapP`5Bi`5D) count++;`20
X    `7D
X    return count;
X`7D
X#ifndef MOTIF
Xvoid SListInitializeForDRM()
X`7B
X    DwtRegisterClass (DRMwcUnknown, "SList", "SListCreate", SListCreate,
X        slistwidgetclass);
X`7D
X#else
X#ifdef USE_MRM
Xvoid SListInitializeForMRM()
X`7B
X    MrmRegisterClass (MrmwcUnknown, "SList", "SListCreate", SListCreate,
X        slistwidgetclass);
X`7D
X#endif
X#endif
$ CALL UNPACK SLIST.C;260 1243666833
$ create 'f'
X/* slist.h */
X
X#ifndef _SList_h
X#define _Slist_h
X
X/* Resource names */
X
X#define SListNforeground                "foreground"
X#define SListNpointerForeground         "pointerForeground"
X#define SListNselectCallback            "selectCallback"
X#define SListNdoubleClickCallback       "doubleClickCallback"
X#define SListNcurrentPixmap             "currentPixmap"
X#define SListNscrollbarLines            "scrollbarLines"
X#define SListNstepperScrollFactor       "stepperScrollFactor"
X#define SListNtextMarginWidth           "textMarginWidth"
X#define SListNdoubleClickDelay          "doubleClickDelay"
X#define SListNseparatorWidth            "separatorWidth"
X#define SListNcols`09`09`09"cols"
X#define SListNrows`09`09`09"rows"
X#define SListNgetDataCallback`09`09"getDataCallback"
X
X/* Resource classes */
X
X#define SListCForeground                "Foreground"
X#define SListCPointerForeground         "PointerForeground"
X#define SListCCurrentPixmap             "CurrentPixmap"
X#define SListCScrollbarLines            "ScrollbarLines"
X#define SListCScrollFactor              "ScrollFactor"
X#define SListCTextMarginWidth           "TextMarginWidth"
X#define SListCDoubleClickDelay`09`09"DoubleClickDelay"
X#define SListCSeparatorWidth            "SeparatorWidth"
X#define SListCCols`09`09`09"Cols"
X#define SListCRows`09`09`09"Rows"
X
X/* Callback structures */
X
Xtypedef struct `7B
X    int         reason;
X    XEvent      *event;
X    int         item_number;            /* Item number selected */
X    short`09select_count;`09`09/* Total number selected */
X    short       item_count;             /* Number of items selected this tim
Ve */
X    Boolean     select;                 /* true for select,
X`09`09`09`09`09   false for deselect */
X    char`09**data;`09`09`09/* pointer to data storage for
X`09`09`09`09`09   getData callbacks */
X`7D SListCallbackStruct;
X
X/* Callback reasons */
X
X#define SListCRSelect           1
X#define SListCRDoubleClick      2
X#define SListCRGetData`09`093
X
Xvoid SListLoad(/* widget, lineCount */);
Xvoid SListSetTop(/* widget, item */);
Xint  SListGetTop(/* widget */);
Xint  SListGetRows(/* widget */);
Xint  SListGetBottom(/* widget */);
Xvoid SListUpdateLine(/* widget, line */);
Xvoid SListSelectAll(/* widget, select */);
Xvoid SListUnhighlight(/* widget */);
Xvoid SListHighlight(/* widget , line */);
Xint  SListGetHighlight(/* widget */);
XBoolean SListIsSelected(/* widget, line */);
Xint SListGetSelectionCount(/* widget */);
XWidget SListCreate(/*widget, name, args, argCnt */);
Xvoid SListInitializeForDRM();
X
X#ifndef SLIST
Xtypedef struct SListClassRec *slistwidgetclassrec;
Xexternalref WidgetClass slistwidgetclass;
X#endif
X
X#endif /* _SList_h */
$ CALL UNPACK SLIST.H;25 957962597
$ create 'f'
X  /* slistP.h */
X
X#ifndef _SListp_h
X#define _Slistp_h
X#include "slist.h"
X
Xtypedef struct `7B
X    String`09`09translations;
X`7D SListClassPart;
X
Xtypedef struct _SListClassRec `7B
X    CoreClassPart       core_class;
X#ifdef MOTIF
X    XmPrimitiveClassPart primitive_class;
X#endif
X    SListClassPart      slist_class;
X`7D SListClassRec, *SListClass;
X
Xtypedef struct _SListPart
X`7B
X    /* Resource fields */
X#ifdef MOTIF
X    XmFontList          *fontRecP;      /* font */
X#else
X    DwtFontRec          *fontRecP;      /* font */
X#endif
X    Pixel               foreground;     /* foreground color */
X    int                 textMarginWidth; /* text margin width in pixels */
X    int                 cols;           /* initial number of columns */
X    int                 rows;           /* initial number of rows */
X#ifdef MOTIF
X    XmAnyCallbackStruct selectCallback; /* Mb1 callback */
X    XmAnyCallbackStruct doubleClickCallback; /* double click callback */
X    XmAnyCallbackStruct getDataCallback;/* get data callback */
X#else
X    DwtCallbackStruct   selectCallback; /* Mb1 callback */
X    DwtCallbackStruct   doubleClickCallback; /* double click callback */
X    DwtCallbackStruct`09getDataCallback;/* get data callback */
X#endif
X
X    /* Private fields */
X    Widget              vScroll;        /* Vertical Scrollbar */
X    XFontStruct         *fontP;         /* font */
X    int                 cellHeight;     /* cell height in pixels */
X    int                 cellWidth;      /* cell width in pixels */
X    int                 yFontAdjust;    /* adjustment for text positioning *
V/
X    int`09`09`09topLine;`09/* top line of the window */
X    int                 textX;          /* boundaries of text window */
X    int                 textY;
X    int                 textWidth;
X    int                 textHeight;
X#ifndef MOTIF
X    int`09`09`09parentWidth;`09/* known parent size */
X    int`09`09`09parentHeight;`09/* for conforming when resized */
X#endif
X    int                 leftMarginWidth; /* scrollbar plus left margin */
X    GC                  normgc;         /* normal graphics context */
X    GC                  normtxtgc;      /* text graphics context */
X    GC                  invgc;          /* text reverse graphics context */
X    GC                  flipgc;         /* invert graphics context */
X    int                 knownHeight;    /* last known core.height */
X    int                 knownWidth;     /* last known core.width */
X    int                 LineCnt;        /* entries used in text array */
X    int                 listIsGrabbed;  /* we are doing a drag select (T/F)
V */
X    int                 mouseLine;      /* line where mouse last seen */
X    int                 highlightedLine; /* line which is highlighted (or -1
V) */
X    int                 YAdjust;        /* in pixels */
X    int                 anyAreExposed;  /* some exposures are pending */
X    char                *exposeMapP;    /* expose bytemap */
X    char                *selectMapP;    /* select bytemap */
X    int                 mapLen;         /* allocated bytemap length */
X    int                 selectParity;   /* flavor of drag select (1/0) */
X    int                 downLine;       /* line where drag select started */
X    int                 upLine;         /* line where drag select ended */
X    int                 ClickInterval;  /* double click delay */
X    XtIntervalId        ClickTimerID;   /* id for click timer */
X    int                 DownCount;      /* count of downclicks */
X    Time                DownTime;       /* time of downclick */
X    int                 ClickLine;      /* line number of first click */
X`7D SListPart;
X
X/****************************************************************
X *
X * Full instance record declaration
X *
X ****************************************************************/
X`20
Xtypedef struct _SListRec `7B
X    CorePart            core;           /* Core widget fields */
X#ifdef MOTIF
X    XmPrimitivePart     primitive;      /* Primitive widget fields */
X#endif
X    SListPart           slist;          /* SList widget fields */
X`7D SListWidgetRec, *SListWidget;
X
X#endif /* _SListp_h */
$ CALL UNPACK SLISTP.H;11 374330256
$ create 'f'
X#define smallicon_width 17
X#define smallicon_height 17
Xstatic unsigned char smallicon_bits`5B`5D = `7B
X   0xaa, 0xaa, 0xfe, 0x55, 0x55, 0xff, 0xff, 0xff, 0xff, 0x19, 0x55, 0xff,
X   0x55, 0xb5, 0xff, 0x15, 0xb5, 0xff, 0x59, 0xa5, 0xff, 0xff, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0x15, 0x2d, 0xff, 0x91, 0xad, 0xff, 0xd1, 0x69, 0xff,
X   0x15, 0x21, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xaa, 0xaa, 0xfe,
X   0x55, 0x55, 0xff`7D;
X
X
X#define smallicon_i_width 17
X#define smallicon_i_height 17
Xstatic unsigned char smallicon_i_bits`5B`5D = `7B
X   0x55, 0x55, 0x01, 0xaa, 0xaa, 0x00, 0x00, 0x00, 0x00, 0xe6, 0xaa, 0x00,
X   0xaa, 0x4a, 0x00, 0xea, 0x4a, 0x00, 0xa6, 0x5a, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0xea, 0xd2, 0x00, 0x6e, 0x52, 0x00, 0x2e, 0x96, 0x00,
X   0xea, 0xde, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x55, 0x01,
X   0xaa, 0xaa, 0x00`7D;
$ CALL UNPACK SMALLICON.XBM;2 1031351593
$ create 'f'
X#include "config.h"
X
X#ifdef NEED_STRSTR
X#include <stdio.h>
X#ifndef __STDC__
X#define CONST
X#else
X#define CONST const
X#endif
X
X/*
X===========================================================================
XMarc Evans - WB1GRH - evans@decvax.DEC.COM  `7C Synergytics     (603)635-887
V6
X      Unix and X Software Contractor        `7C 21 Hinds Ln, Pelham, NH 0307
V6
X===========================================================================
X
X*/
X
Xchar * strstr(s1, s2)
Xregister char CONST *s1, *s2;
X`7B
X    register int n = strlen(s2);
X    char *rs = (*s1) ? NULL : s2;
X
X    while (*s1)
X    `7B   if (strncmp(s2,s1,n) == 0L)
X`09`7B   rs = s1;
X`09    break;
X`09`7D
X`09++s1;
X    `7D
X    return(rs);
X`7D
X#endif
$ CALL UNPACK STRSTR.C;2 824845269
$ create 'f'
X#include "config.h"
X
X#ifdef NEED_STRTOK
X
X#include <stdio.h>
X#ifndef __STDC__
X#define CONST
X#else
X#define CONST const
X#endif
X
X
X/*
X * Get next token from string s (NULL on 2nd, 3rd, etc. calls),
X * where tokens are nonempty strings separated by runs of
X * chars from delim.  Writes NULs into s to end tokens.  delim need not
X * remain constant from call to call.
X */
X
Xstatic char *scanpoint = NULL;
X
Xchar *`09`09`09`09/* NULL if no token left */
Xstrtok(s, delim)
Xchar *s;
Xregister CONST char *delim;
X`7B
X`09register char *scan;
X`09char *tok;
X`09register CONST char *dscan;
X
X`09if (s == NULL && scanpoint == NULL)
X`09`09return NULL;
X`09if (s != NULL)
X`09`09scan = s;
X`09else
X`09`09scan = scanpoint;
X
X`09/*
X`09 * Scan leading delimiters.
X`09 */
X`09for (; *scan != '\0'; scan++) `7B
X`09`09for (dscan = delim; *dscan != '\0'; dscan++)
X`09`09`09if (*scan == *dscan)
X`09`09`09`09break;
X`09`09if (*dscan == '\0')
X`09`09`09break;
X`09`7D
X`09if (*scan == '\0') `7B
X`09`09scanpoint = NULL;
X`09`09return NULL;
X`09`7D
X
X`09tok = scan;
X
X`09/*
X`09 * Scan token.
X`09 */
X`09for (; *scan != '\0'; scan++) `7B
X`09`09for (dscan = delim; *dscan != '\0';)`09/* ++ moved down. */
X`09`09`09if (*scan == *dscan++) `7B
X`09`09`09`09scanpoint = scan+1;
X`09`09`09`09*scan = '\0';
X`09`09`09`09return tok;
X`09`09`09`7D
X`09`7D
X
X`09/*
X`09 * Reached end of string.
X`09 */
X`09scanpoint = NULL;
X`09return tok;
X`7D
X#endif
$ CALL UNPACK STRTOK.C;2 622878883
$ create 'f'
X
X`5Bnote: only the strtok function from this package is included
X with XRN.  The entire package can be found on uunet.uu.net in
X comp.sources.unix/volume4/stringlib.Z - ricks`5D
X
XThis is a public-domain reimplementation of string(3) and friends, notably
Xmemory(3) and bstring(3) (except ffs).  Not derived from licensed software.
XThis code may be used on any computer system for any purpose by anyone.
X
XRelative to my old net.sources posting, this one adds some functions and
Xfixes one or two obscure bugs.  There has been another string library
Xposted in recent times, with many more functions; I haven't inspected it
Xand can't comment on its relationship to mine.  Alas, the manual pages
Xfor this stuff are copyright by various people other than me, so I can't
Xinclude them.  See your local Unix manuals.
X
XThis distribution implements precisely the union of the string functions
Xof the SVID, 4BSD, X3J11, and V7.  Included is a large test program that
Xexercises everything quite thoroughly.  (Note that some existing libraries,
Xincluding e.g. V7, flunk one or more of these tests.)
X
XIn the event of conflict between the definitions from various places, the
Xnewer or more portable one is chosen.  That is, X3J11 overrules the SVID,
Xwhich in turn overrules older Unixes.
X
XThe code is written for maximal portability.  Some efficiency has been
Xsacrificed in the cause of meticulously avoiding possible portability
Xproblems.  For example, this code never assumes that a pointer can be
Xmoved past the end of an array and then backed up.  Many of these functions
Xcan be implemented more efficiently if machine-dependent assumptions are
Xmade; memcpy is a particular glaring case.
X
XSimplistically:  put this stuff into a source directory, inspect Makefile
Xfor compilation options that need changing to suit your local environment,
Xand then do "make r".  This compiles the functions and the test program and
Xruns the tests.  If there are no complaints, put string.h in /usr/include
X(you may also want to "make memory.h" and put it in /usr/include) and add
Xthe functions (*.o except for tester.o) to your C library.  The internal
Xinterdependencies are:
X
X`09index`09needs`09strchr
X`09rindex`09needs`09strrchr
X`09bcopy`09needs`09memcpy
X`09bcmp`09needs`09memcmp
X`09bzero`09needs`09memset
X
XI haven't included an implementation of Berkeley's ffs function partly
Xbecause it's not trivial to do in a portable way, and partly because I
Xdon't really see it as a string function.
X
XA weakness in the tester program is that it uses quite short strings for
Xeverything, and pays no real attention to alignment issues.  Optimized
Ximplementations of things like memcpy would need a more elaborate set of
Xtest cases to put them through their full paces.
X
X`09`09`09`09Henry Spencer @ U of Toronto Zoology
X`09`09`09`09`7Ballegra,ihnp4,decvax,pyramid`7D!utzoo!henry
X`09`09`09`09Wed Jun 25 19:21:34 EDT 1986
X
$ CALL UNPACK STRTOK.DOC;1 1610972017
$ create 'f'
X/*#define`09DEBUG`091`09`09`09`09`09`09*/
X/*
X *`09`09`09`09T . H
X *
X * Definitions for T.
X */
X
X#define`09EOS`09`090`09`09/* End of string`09`09*/
X#ifndef`09vax11c
X#define`09MAXMEM`09`09100`09`09/* Remember one hundred pages`09*/
X#else
X#define`09MAXMEM`09`091000`09`09/* Big memory */
X#endif
X#define`09ROWS`09`0924`09`09/* Screen size rows (up/down)`09*/
X#define`09COLS`09`0980`09`09/* Screen size columns (across)`09*/
X#define`09HUGE`09`0932767`09`09/* A very large number`09`09*/
X#define`09MASK`09`090100000`09`09/* High bit for short int's`09*/
X
X#define`09rsx_or_vax11c`091`09`09/* Hack to allow RSX code for VMS */
X#ifndef`09rsx
X#ifndef`09vax11c
X#undef`09rsx_or_vax11c
X#endif
X#endif
X
X#ifdef`09vms
X/*
X * Special definitions for RMS I/O package
X */
Xtypedef struct rfa_struct `7B
X`09unsigned short int`09word`5B3`5D;
X`7D RFAVALUE;
X#define`09FILETYPE`09char
X#define`09FWILD`09`09rms_fwild
X#define`09FNEXT`09`09rms_fnext
X#define`09FGETNAME`09rms_getname
X#define`09FWILDMODE`09"r"
X#define`09kbin`09`09kbgetc
X#else
X/*
X * Normal I/O
X */
X#define`09RFAVALUE`09long
X#define`09FILETYPE`09FILE
X#define`09FWILD`09`09fwild
X#define`09FNEXT`09`09fnext
X#define`09FGETNAME`09fgetname
X#define`09FWILDMODE`09"run"
X#endif
X/*
X * Define information to seek within records
X */
X
Xtypedef struct `7B
X`09RFAVALUE record_rfa;`09`09/* Returned by ftell()`09`09*/
X`09short int buff_offset;`09`09/* Offset in buff`5B`5D of record`09*/
X`09`09`09`09`09/*   < 0 if <Form-Feed> start`09*/
X`09short int line_offset;`09`09/* Offset in textline`5B`5D`09`09*/
X`09`09`09`09`09/*   < 0 if saved character`09*/
X`7D RFA;
X
X/*
X * Things for screen handling
X */
X
X#define`09IS_VT52`09`09(64+1)
X#ifndef vax11c
X#define`09IS_VT100`09(96+1)
X#else
X#define`09IS_VT100_START`09(96+1)
X#define IS_VT100_END`09(101+1)
X#endif
X
X#define`09HELPROW`093
X
Xextern`09char`09`09rx_pattern`5B`5D;`09/* Grep pattern stored here`09*/
X
X#ifdef`09DEBUG
Xextern int`09`09debug;`09`09/* Set for debugging`09`09*/
X#ifdef`09vax11c
X#define`09_tracef`09`09printf
X#endif
X#endif
$ CALL UNPACK T.H;2 1667148149
$ create 'f'
X/*
X *`09re_comp(pattern)
X *`09char *pattern;
X *
X * Compile the regular expression pattern.  Return TRUE if success.
X * The compiled pattern is stored in a global character vector 'rx_pattern'
X *
X * If an error occurred, re_comp() returns FALSE and rx_pattern contains
X * an error message.
X *
X *
X * Syntax errors print a message and return 0.  Size errors abort.
X *
X *
X * External routines:
X *`09warn`09`09`09Print warning/error messages
X *`09fatal`09`09`09Fatal error exit
X *
X * Regular expressions are defined as follows:
X *
X * x`09An ordinary character (not mentioned below) matches that character.
X * '\'`09The backslash quotes any character.  "\$" matches a dollar-sign.
X * '`5E'`09A circumflex at the beginning of an expression matches the
X * `09  beginning of a line.
X * '$'`09A dollar-sign at the end of an expression matches the end of
X * `09  a line.
X * '.'`09A period matches any character except "new-line".
X * ':a'`09A colon matches a class of characters described by the following
X * ':d'`09  character.  ":a" matches any alphabetic, ":d" matches digits,
X * ':n'`09  ":n" matches alphanumerics, ": " matches spaces, tabs, and
X * ': '`09  other control characters, such as new-line.
X * '*'`09An expression followed by an asterisk matches zero or more
X * `09  occurrances of that expression: "fo*" matches "f", "fo"
X * `09  "foo", etc.
X * '+'`09An expression followed by a plus sign matches one or more
X * `09  occurrances of that expression: "fo+" matches "fo", etc.
X * '-'`09An expression followed by a minus sign optionally matches
X * `09  the expression.
X * '`5B`5D'`09A string enclosed in square brackets matches any character in
X * `09  that string, but no others.  If the first character in the
X * `09  string is a circumflex, the expression matches any character
X * `09  except "new-line" and the characters in the string.  For
X * `09  example, "`5Bxyz`5D" matches "xx" and "zyx", while "`5B`5Exyz`5D"
X * `09  matches "abc" but not "axb".  A range of characters may be
X * `09  specified by two characters seperated by "-".  Note that,
X * `09  `5Ba-z`5D matches alphabetics, while `5Bz-a`5D never matches.
X *`20
X * The concatenation of regular expressions is a regular expression.
X */
X
X#include`09<stdio.h>
X#ifdef vms
X#include`09<ctype.h>
X#include`09<string.h>
X#define`09FALSE`090
X#define`09TRUE`091
X#endif
X#include`09"t.h"
X
X#define PMAX`09256`09`09`09/* The longest pattern`09`09*/
X
X/*
X * Note: the following must be identical in re_grep() and re_comp().
X */
X
X#define CHAR`091
X#define BOL`092
X#define EOL`093
X#define`09ANY`094
X#define CLASS`095
X#define`09NCLASS`096
X#define STAR`097
X#define`09PLUS`098
X#define`09MINUS`099
X#define`09ALPHA`0910
X#define`09DIGIT`0911
X#define`09NALPHA`0912
X#define`09PUNCT`0913
X#define`09CDIGIT`0914`09`09/* Not used`09`09`09`09*/
X#define RANGE`0915
X#define`09ENDPAT`0916
X
Xstatic char`09*rx_pp;`09`09`09/* Work area pointer`09`09*/
Xchar`09`09rx_pattern`5BPMAX`5D;`09/* Pattern output here`09`09*/
Xstatic char`09*rx_bad();
Xstatic`09`09rx_store();
Xstatic char`09*rx_cclass();`09`09/* Compile class routine`09*/
X
Xchar *
Xre_comp(pattern)
Xchar`09`09*pattern;`09/* Pattern to compile`09`09`09*/
X/*
X * Compile the pattern.
X */
X`7B
X`09register char`09*s;`09`09/* Source string pointer`09*/
X`09register char`09*lp;`09`09/* Last pattern pointer`09`09*/
X`09register int`09c;`09`09/* Current character`09`09*/
X`09int`09`09o;`09`09/* Temp`09`09`09`09*/
X`09char`09`09*spp;`09`09/* Save beginning of pattern`09*/
X
X`09s = pattern;
X`09rx_pp = rx_pattern;
X`09while (c = *s++) `7B
X`09`09/*
X`09`09 * STAR, PLUS and MINUS are special.
X`09`09 */
X`09`09if (c == '*' `7C`7C c == '+' `7C`7C c == '-') `7B
X`09`09`09if (rx_pp == rx_pattern `7C`7C (o=rx_pp`5B-1`5D) == BOL `7C`7C
X`09`09`09`09`09o == EOL `7C`7C o == STAR `7C`7C
X`09`09`09`09`09o == PLUS `7C`7C o == MINUS)
X`09`09`09`09return(rx_bad("Illegal occurrance op.", s));
X`09`09`09rx_store(ENDPAT);
X`09`09`09rx_store(ENDPAT);
X`09`09`09/*
X`09`09`09 * Save the pattern's end and move it down one byte.
X`09`09`09 */
X`09`09`09spp = rx_pp;
X`09`09`09while (--rx_pp > lp)
X`09`09`09`09*rx_pp = rx_pp`5B-1`5D;
X`09`09`09*rx_pp = (c == '*') ? STAR :
X`09`09`09`09(c == '-') ? MINUS : PLUS;
X`09`09`09rx_pp = spp;`09`09/* Restore pattern end`09*/
X`09`09`09continue;
X`09`09`7D
X`09`09/*
X`09`09 * All the rest.
X`09`09 */
X`09`09lp = rx_pp;`09`09`09/* Remember start`09*/
X`09`09switch(c) `7B
X
X`09`09case '`5E':
X`09`09`09rx_store(BOL);
X`09`09`09break;
X
X`09`09case '$':
X`09`09`09rx_store(EOL);
X`09`09`09break;
X
X`09`09case '.':
X`09`09`09rx_store(ANY);
X`09`09`09break;
X
X`09`09case '`5B':
X`09`09`09if ((s = rx_cclass(s)) == 0)
X`09`09`09`09return("glump");
X`09`09`09break;
X
X`09`09case ':':
X`09`09`09if (*s) `7B
X`09`09`09`09c = *s++;
X`09`09`09`09switch(tolower(c)) `7B
X
X`09`09`09`09case 'a':
X`09`09`09`09`09rx_store(ALPHA);
X`09`09`09`09`09break;
X
X`09`09`09`09case 'd':
X`09`09`09`09`09rx_store(DIGIT);
X`09`09`09`09`09break;
X
X`09`09`09`09case 'n':
X`09`09`09`09`09rx_store(NALPHA);
X`09`09`09`09`09break;
X
X`09`09`09`09case ' ':
X`09`09`09`09`09rx_store(PUNCT);
X`09`09`09`09`09break;
X
X`09`09`09`09default:
X`09`09`09`09`09return(rx_bad("Unknown : type", s));
X
X`09`09`09`09`7D
X`09`09`09`09break;
X`09`09`09`7D
X`09`09`09else`09return(rx_bad("No : type", s));
X
X`09`09case '\\':
X`09`09`09if (*s)
X`09`09`09`09c = *s++;
X
X`09`09default:
X`09`09`09rx_store(CHAR);
X`09`09`09rx_store(tolower(c));
X`09`09`7D
X`09`7D
X`09rx_store(ENDPAT);
X`09rx_store(EOS);`09`09`09`09/* Terminate string`09*/
X`09return (NULL);
X`7D
X
Xstatic char *
Xrx_cclass(src)
Xchar`09`09*src;`09`09/* Class start`09`09`09`09*/
X/*
X * Compile a class (within `5B`5D)
X */
X`7B
X`09register char`09*s;`09`09/* Pattern pointer`09`09*/
X`09register char`09*cp;`09`09/* Pattern start`09`09*/
X`09register int`09c;`09`09/* Current character`09`09*/
X`09int`09`09o;`09`09/* Temp`09`09`09`09*/
X
X`09s = src;
X`09o = CLASS;
X`09if (*s == '`5E') `7B
X`09`09++s;
X`09`09o = NCLASS;
X`09`7D
X`09rx_store(o);
X`09cp = rx_pp;
X`09rx_store(0);`09`09`09`09/* Byte count`09`09*/
X`09while ((c = *s++) && c!='`5D') `7B
X`09`09if (c == '\\') `7B`09`09/* Store quoted char`09*/
X`09`09`09if ((c = *s++) == '\0')`09/* Gotta get something`09*/
X`09`09`09`09return(rx_bad("Class terminates badly", s));
X`09`09`09else`09rx_store(tolower(c));
X`09`09`7D
X`09`09else if (c == '-' &&
X`09`09`09`09(rx_pp - cp) > 1 && *s != '`5D' && *s != '\0') `7B
X`09`09`09c = rx_pp`5B-1`5D;`09`09/* Range start`09`09*/
X`09`09`09rx_pp`5B-1`5D = RANGE;`09/* Range signal`09`09*/
X`09`09`09rx_store(c);`09`09/* Re-store start`09*/
X`09`09`09c = *s++;`09`09/* Get end char and`09*/
X`09`09`09rx_store(tolower(c));`09/* Store it`09`09*/
X`09`09`7D
X`09`09else `7B
X`09`09`09rx_store(tolower(c));`09/* Store normal char`09*/
X`09`09`7D
X`09`7D
X`09if (c != '`5D')
X`09`09return(rx_bad("Unterminated class", s));
X`09if ((c = (rx_pp - cp)) >= 256)
X`09`09return(rx_bad("Class too large", s));
X`09if (c == 0)
X`09`09return(rx_bad("Empty class", s));
X`09*cp = c;
X`09return(s);
X`7D
X
Xstatic
Xrx_store(op)
X`7B
X`09if (rx_pp >= &rx_pattern`5BPMAX`5D)
X`09`09perror("?RXCOMP-F-Pattern too complex");
X`09*rx_pp++ = op;
X`7D
X
Xstatic char *
Xrx_bad(message, stopbyte)
Xchar`09`09*message;`09/* Error message`09`09`09*/
Xchar`09`09*stopbyte;`09/* Pattern end`09`09`09`09*/
X`7B
X`09strcpy(rx_pattern, "Regular expression error \"");
X`09strcat(rx_pattern, message);
X`09strcat(rx_pattern, "\", stopped at \"");
X`09strcat(rx_pattern, &stopbyte`5B-1`5D);
X`09strcat(rx_pattern, "\"");
X`09return (rx_pattern);
X`7D
X
$ CALL UNPACK T6.C;3 1746555182
$ create 'f'
X#
X/*
X *`09`09`09`09T 7 . C
X *
X *`09char *
X *`09re_exec(string, pattern)
X *`09char`09`09*string;`09-- Where to search for it
X *`09char`09`09*pattern;`09-- What to search for
X *
X * Apply the regular expression (pattern`5B`5D) to the argument string`5B`5D
V.
X * Return 0 if it fails.  If successful, return a pointer to the string.
X * that matched.  Regular expressions are defined in rxcomp().
X *
X * Globals unique to this routine are preceeded by "re_".
X */
X
X#include`09<stdio.h>
X#ifdef`09vms
X#include`09<ctype.h>
X#define`09FALSE`090
X#define`09TRUE`091
X#endif
X#include`09"t.h"
X
X/*
X * The following must be identical in rxcomp().
X */
X
X#define CHAR`091
X#define BOL`092
X#define EOL`093
X#define`09ANY`094
X#define CLASS`095
X#define`09NCLASS`096
X#define STAR`097
X#define`09PLUS`098
X#define`09MINUS`099
X#define`09ALPHA`0910
X#define`09DIGIT`0911
X#define`09NALPHA`0912
X#define`09PUNCT`0913
X#define`09CDIGIT`0914`09`09/* Not used in this version`09`09*/
X#define RANGE`0915
X#define`09ENDPAT`0916
X
Xstatic char`09*re_string;`09`09/* Remember start loc.`09`09*/
Xstatic char`09*re_pmatch();
Xextern void`09abort();
X
Xchar *
Xre_exec(string)
Xchar`09`09*string;`09`09/* The string to look for`09*/
X/*
X * Match the string, return TRUE if it does.
X */
X`7B
X`09char *pattern = rx_pattern;
X`09register char`09*l;`09`09/* Line pointer`09`09`09*/
X
X`09re_string = string;
X`09for (l = string; *l; l++) `7B
X`09`09if (re_pmatch(l, string, pattern))
X`09`09`09return(l);
X`09`7D
X`09return(NULL);
X`7D
X
Xstatic char *
Xre_pmatch(line, start, pattern)
Xchar`09`09*line;`09`09/* (partial) line to match`09`09*/
Xchar`09`09*start;`09`09/* Invariant line start`09`09`09*/
Xchar`09`09*pattern;`09/* (partial) pattern to match`09`09*/
X/*
X * Do the actual work of matching (recursively).  Line is the current
X * piece of information to match.  Start is the entire line -- as passed
X * to t_rxgrep().  This is needed for the :c scan.
X */
X`7B
X`09register char`09*l;`09`09/* Current line pointer`09`09*/
X`09register char`09*p;`09`09/* Current pattern pointer`09*/
X`09register char`09c;`09`09/* Current character`09`09*/
X`09char`09`09*e;`09`09/* End for STAR and PLUS match`09*/
X`09int`09`09op;`09`09/* Pattern operation`09`09*/
X`09int`09`09n;`09`09/* Class counter`09`09*/
X`09char`09`09*are;`09`09/* Start of STAR match`09`09*/
X`09char`09`09*commapos;`09/* Comma position for :c match`09*/
X
X`09l = line;
X`09p = pattern;
X`09commapos = 0;`20
X`09while ((op = *p++) != ENDPAT) `7B
X`09`09switch(op) `7B
X
X`09`09case CHAR:
X`09`09`09if (tolower(*l++) != *p++)
X`09`09`09`09return(0);
X`09`09`09break;
X
X`09`09case BOL:
X`09`09`09if (l != re_string)
X`09`09`09`09return(0);
X`09`09`09break;
X
X`09`09case EOL:
X`09`09`09if (*l != '\0')
X`09`09`09`09return(0);
X`09`09`09break;
X
X`09`09case ANY:
X`09`09`09if (*l++ == '\0')
X`09`09`09`09return(0);
X`09`09`09break;
X
X`09`09case DIGIT:
X`09`09`09if ((c = *l++) < '0' `7C`7C (c > '9'))
X`09`09`09`09return(0);
X`09`09`09break;
X
X`09`09case ALPHA:
X`09`09`09c = tolower(*l++);
X`09`09`09if (c < 'a' `7C`7C c > 'z')
X`09`09`09`09return(0);
X`09`09`09break;
X
X`09`09case NALPHA:
X`09`09`09c = tolower(*l++);
X`09`09`09if (c >= 'a' && c <= 'z')
X`09`09`09`09break;
X`09`09`09else if (c < '0' `7C`7C c > '9')
X`09`09`09`09return(0);
X`09`09`09break;
X
X`09`09case PUNCT:
X`09`09`09c = *l++;
X`09`09`09if (c == 0 `7C`7C c > ' ')
X`09`09`09`09return(0);
X`09`09`09break;
X
X`09`09case CLASS:
X`09`09case NCLASS:
X`09`09`09c = tolower(*l++);
X`09`09`09n = *p++ & 0377;
X`09`09`09do `7B
X`09`09`09`09if (*p == RANGE) `7B
X`09`09`09`09`09p += 3;
X`09`09`09`09`09n -= 2;
X`09`09`09`09`09if (c >= p`5B-2`5D && c <= p`5B-1`5D)
X`09`09`09`09`09`09break;
X`09`09`09`09`7D
X`09`09`09`09else if (c == *p++)
X`09`09`09`09`09break;
X`09`09`09`7D while (--n > 1);
X`09`09`09if ((op == CLASS) == (n <= 1))
X`09`09`09`09return(0);
X`09`09`09if (op == CLASS)
X`09`09`09`09p += n - 2;
X`09`09`09break;
X
X`09`09case MINUS:
X`09`09`09e = re_pmatch(l, start, p);
X`09`09`09while (*p++ != ENDPAT);`09/* Skip over pattern`09*/
X`09`09`09if (e)`09`09`09/* Got a match?`09`09*/
X`09`09`09`09l = e;`09`09/* Yes, update string`09*/
X`09`09`09break;`09`09`09/* Always succeeds`09*/
X
X`09`09case PLUS:`09`09`09/* One or more ...`09*/
X`09`09`09if ((l = re_pmatch(l, start, p)) == 0)
X`09`09`09`09return(0);`09/* Gotta have a match`09*/
X`09`09case STAR:`09`09`09/* Zero or more ...`09*/
X`09`09`09are = l;`09`09/* Remember line start`09*/
X`09`09`09while (*l && (e = re_pmatch(l, start, p)))
X`09`09`09`09l = e;`09`09/* Get longest match`09*/
X`09`09`09while (*p++ != ENDPAT);`09/* Skip over pattern`09*/
X`09`09`09while (l >= are) `7B`09/* Try to match rest`09*/
X`09`09`09`09if (e = re_pmatch(l, start, p))
X`09`09`09`09`09return(e);
X`09`09`09`09--l;`09`09/* Nope, try earlier`09*/
X`09`09`09`7D
X`09`09`09return(0);`09`09/* Nothing else worked`09*/
X
X`09`09default:
X`09`09`09abort();`09`09/* Illegal op code`09*/
X`09`09`7D
X`09`7D
X`09return(l);
X`7D
$ CALL UNPACK T7.C;3 221413240
$ create 'f'
X#include "config.h"
X#include "utils.h"
X
X/* from Jonathan I. Kamens          <jik@pit-manager.mit.edu> */
X
X#ifdef NEED_TEMPNAM
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <sys/file.h>
X#include <stdio.h>
X
X#ifndef P_tmpdir
X#define P_tmpdir`09"/usr/tmp/"
X#endif
X
Xstatic char check_directory(dir)
Xchar *dir;
X`7B
X     struct stat statbuf;
X
X     if (! dir)
X`09  return 0;
X     else if (stat(dir, &statbuf) < 0)
X`09  return 0;
X     else if ((statbuf.st_mode & S_IFMT) != S_IFDIR)
X`09  return 0;
X     else if (access(dir, W_OK `7C X_OK) < 0)
X`09  return 0;
X     else
X`09  return 1;
X`7D
X
X/* function for creating temporary filenames */
Xchar *utTempnam(dir, pfx)
Xchar *dir, *pfx;
X`7B
X     extern char *getenv();
X     char *tmpdir = NULL, *env, *filename;
X     static char unique_letters`5B4`5D = "AAA";
X     char addslash = 0;
X    `20
X     /*
X      * If a directory is passed in, verify that it exists and is a
X      * directory and is writeable by this process.  If no directory
X      * is passed in, or if the directory that is passed in does not
X      * exist, check the environment variable TMPDIR.  If it isn't
X      * set, check the predefined constant P_tmpdir.  If that isn't
X      * set, use "/tmp/".
X      */
X
X     if (dir && check_directory(dir))
X`09  tmpdir = dir;
X     else if ((env = getenv("TMPDIR")) && check_directory(env))
X`09  tmpdir = env;
X#ifdef P_tmpdir
X     else if (check_directory(P_tmpdir))
X`09  tmpdir = P_tmpdir;
X#endif
X     else
X`09  tmpdir = "/tmp/";
X    `20
X     /*
X      * OK, now that we've got a directory, figure out whether or not
X      * there's a slash at the end of it.
X      */
X     if (tmpdir`5Bstrlen(tmpdir) - 1`5D != '/')
X`09  addslash = 1;
X
X     /*
X      * Now figure out the set of unique letters.
X      */
X     unique_letters`5B0`5D++;
X     if (unique_letters`5B0`5D > 'Z') `7B
X`09  unique_letters`5B0`5D = 'A';
X`09  unique_letters`5B1`5D++;
X`09  if (unique_letters`5B1`5D > 'Z') `7B
X`09       unique_letters`5B1`5D = 'A';
X`09       unique_letters`5B2`5D++;
X`09       if (unique_letters`5B2`5D > 'Z') `7B
X`09`09    unique_letters`5B2`5D++;
X`09       `7D
X`09  `7D
X     `7D
X
X     /*
X      * Allocate a string of sufficient length.
X      */
X     filename = XtMalloc(strlen(tmpdir) + addslash + utStrlen(pfx) + 10);
X    `20
X     /*
X      * And create the string.
X      */
X     (void) sprintf(filename, "%s%s%s%sa%05d", tmpdir, addslash ? "/" : "",
X`09`09    pfx ? pfx : "", unique_letters, getpid());
X
X     return filename;
X`7D
X
X#endif
$ CALL UNPACK TEMPNAM.C;2 1563433097
$ create 'f'
X
X$Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/TODO,v 1.7 1993/02/04 1
V8:21:50 ricks Exp $
X
XThe Ever growing list of things that should be done and things that would`20
Xbe nice if they were done.... (and even worse, it's not up to date)
X
X- getarticle return
X- read updated .newsrc file (XRN detects this, but should allow you to rerea
Vd)
X- prefetch should occur at end of list, not largest number (sorted subject..
V.)
X- spawn child for posting, sigchld in parent for confirmation...
X- clean up KILL file support
X   - handle '`7B' correctly
X        The regular expression \`7B<m>,<n>\`7D is supposed to match between
X        m and n occurences of the previous character. To kill an expression
X        of the form "`7Bfoo`7D", xrn requires the braces to be quoted. Rn, o
Vn
X        the other hand complains if the braces are quoted.  Rn, on
X        the other hand complains if the braces are quoted since the
X        expression is not valid.  Test: /`7Bfoo`7D/:j
X   - allow field names (Subject/From) in an entry
X   - prompt for KILL expression in article mode
X`09local kill (current subject and typein)
X`09global kill (current subject and typein)
X`09local author kill (current subject and typein)
X`09global author kill (current subject and typein)
X   - kill author globally...
X   - edit kill file
X   - closer to RN
X- look at input during prefetch to see if it should be cancelled (or handled
V).
X- remove tmp files as you go, not at the end of the group
X  (necessary for large groups with large postings)
X- replace popen of mailer with something better so status code can be checke
Vd
X- fixup postArticle to do Header fixup, not sendFunction...
X- check if follow-to is same as newsgroup, warn if not, option to turn this
V off.
X- warn if followup will go to more than one group.
X- option to capitalize, not-cap the group name when saving.
X- xrn.slowLink - don't refetch article for saving
X- thread support
X- break up buttons.c into multiple files
X`09generic stuff, art buttons, all buttons, ng buttons, add buttons, ...
X- XHDR message on server timeout
X- handle =ng in active file
X- command to skip quoted/included sections
X- user selectable cursors
X- text and reference based searching
X- strip leading and trailing spaces from newsgroup name in the Newsgroups fi
Veld
X- control C to disconnect/reconnect and return to top level...
X- allow partial selection on subject line - partial selection determines
X  what amount of the subject or author is to be killed....
X- local server (clientlib.c replaced with something that accesses local file
Vs)
X
$ CALL UNPACK TODO.;2 1325809584
$ create 'f'
X`09.TITLE`09TRANSFER_ALPHA
X;+ ---
X;
X;`09These Alpha transfer vectors are used because when compiling
X;`09XRN for use with MultiNet, the compiler options are that are
X;`09needed are /STAND=VAXC/PREFIX=ANSI which causes problems in
X;`09that certain functions don't get the DECC$ prefix.  This
X;`09allows us to use those functions anyways.
X;
X;- ---
X
X;+ ---
X;
X;`09Vector Generating Macro for Alpha/VMS
X;
X;- ---
X`09.MACRO`09TRANSFER_VECTOR, NAME, FUNCTION_NAME
X
X`09.PSECT $LINK$,NOWRT,NOEXE
X`09.CODE_ADDRESS`09`09'FUNCTION_NAME'`09`09;Transfer to here
X`09.ADDRESS`09`09'FUNCTION_NAME'`09`09;New Procedure Descr
X
X`09.PROCEDURE_DESCRIPTOR`09'NAME', _'NAME'`09`09;Define Name
X`09.WORD`09`09`09`5EX1808`09`09`09;Flags, Kind=NULL
X`09.WORD`09`09`090
X`09.WORD`09`09`0926`09`09`09;Entry_RA
X`09.WORD`09`09`090`09`09`09;No signature
X`09.ADDRESS`09`09_'NAME'`09`09`09;Code Address
X
X`09.PSECT $CODE,PIC,SHR,EXE,NORD,NOWRT
X_'NAME':
X`09LDQ`09R28,-16(R27)`09;Get the Code Address
X`09LDQ`09R27, -8(R27)
X`09JMP`09R31,   (R28)`09;Jump there
X`09.ENDM
X
X
X`09TRANSFER_VECTOR CLOSE,`09`09DECC$CLOSE
X`09TRANSFER_VECTOR FSTAT,`09`09DECC$FSTAT
X`09TRANSFER_VECTOR ACCESS,`09`09DECC$ACCESS
X`09TRANSFER_VECTOR CHMOD,`09`09DECC$CHMOD
X`09TRANSFER_VECTOR DELETE,`09`09DECC$DELETE
X`09TRANSFER_VECTOR GETPID,`09`09DECC$GETPID
X`09TRANSFER_VECTOR MKTEMP,`09`09DECC$MKTEMP
X`09TRANSFER_VECTOR STAT,`09`09DECC$STAT
X`09TRANSFER_VECTOR SLEEP,`09`09DECC$SLEEP
X`09TRANSFER_VECTOR MKDIR,`09`09DECC$MKDIR
X`09TRANSFER_VECTOR KILL,`09`09DECC$KILL
X
X`09.END
X
$ CALL UNPACK TRANSFER.M64;1 739717129
$ create 'f'
X#if !defined(lint) && !defined(SABER)
Xstatic char XRNrcsid`5B`5D = "$Header: /net/objy27/wrld/mnt11/ricks/src/mast
Ver/xrn/utils.c,v 1.8 1993/02/04 18:22:34 ricks Exp $";
X#endif
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X
X/*
X * utils.c: random utility functions for xrn
X */
X
X#include "copyright.h"
X#include <string.h>
X#include <stdio.h>
X#include <ctype.h>
X#include "config.h"
X#include "utils.h"
X#include "news.h"
X#ifndef VMS
X#include <sys/param.h>
X#include <pwd.h>
X#else
X#define MAXPATHLEN 512
X#define index strchr
X#endif /* VMS */
X
X#ifdef sco
X#define MAXPATHLEN 512
X#endif
X
X#ifdef aiws
Xstruct passwd *getpwuid();
Xstruct passwd *getpwnam();
X#endif /* aiws */
X
X#if defined(sun)
X#include <string.h>
X#endif
X
X#if defined(apollo)
X#include <string.h>
X#include <sys/time.h>
X#endif
X
X#include <time.h>
X#ifdef __STDC__
X#ifndef VMS
X#include <unistd.h>
X#endif
X#endif
X
X#define USER_NAME_SIZE 32
X
X#ifdef SYSV_REGEX
X/*`20
X * kludge alert:  this is here because (on A/UX 1.1) linking with
X * the PW lib (necessary to get the regular expression routines,`20
X * regcmp/regex), causes symbol 'Error' to be undefined.
X * `09glenn@mathcs.emory.edu 10/17/89`20
X *
X * SYSV_REGEX may be overkill, need for macII and HPUX
X *    (Andy.Linton@comp.vuw.ac.nz 11/8/89)
X */
Xint Error;`20
X#endif
X
X/*
X * trim leading and trailing spaces from a string (and newlines)
X *
X *   NOTE: this function modifies the argument
X *
X *   returns: the modified string
X *
X */
Xchar *
XutTrimSpaces(str)
Xchar *str;
X`7B
X    char *end = &str`5ButStrlen(str) - 1`5D;
X
X    while ((*str == ' ') `7C`7C (*str == '\n') `7C`7C (*str == '\t')) `7B
X`09str++;
X    `7D
X    while ((*end == ' ') `7C`7C (*end == '\n') `7C`7C (*end == '\t')) `7B
X`09*end = '\0';
X`09end--;
X`09if (end == str) return (str);
X    `7D
X    return(str);
X`7D
X
X
X/*
X * tilde expand a file name
X *
X *   returns: the expanded name of the file (in a static buffer)
X *            or NIL(char)`20
X */
Xchar *
XutTildeExpand(filename)
Xchar *filename;    /* file name, possibly with a '`7E'             */
X`7B
X#ifdef aiws
X    static char dummy`5BMAXPATH`5D;
X#else
X    static char dummy`5BMAXPATHLEN`5D;
X#endif /* aiws */
X    char username`5BUSER_NAME_SIZE`5D, *loc;
X    struct passwd *pw;
X   `20
X    if ((filename == NIL(char)) `7C`7C STREQ(filename, "")) `7B
X`09return(NIL(char));
X    `7D
X
X    if (filename`5B0`5D != '`7E') `7B
X`09(void) strcpy(dummy, filename);
X`09return(dummy);
X    `7D
X
X    /* tilde at the beginning now */
X    if (filename`5B1`5D == '/' `7C`7C filename`5B1`5D == '\0') `7B
X`09/* current user */
X`09char *home, *getenv _ARGUMENTS((const char *));
X`09
X`09if ((home = getenv("HOME")) == NIL(char)) `7B
X#ifndef VMS
X`09    /* fall back on /etc/passwd */
X`09    if ((pw = getpwuid(getuid())) == NIL(struct passwd)) `7B
X`09`09return(NIL(char));
X`09    `7D
X`09    (void) sprintf(dummy, "%s%s", pw->pw_dir, &filename`5B1`5D);
X#else
X`09    return (NIL(char));
X#endif
X`09`7D else `7B
X`09    (void) sprintf(dummy, "%s%s", home, &filename`5B1`5D);
X`09`7D
X`09   `20
X    `7D else `7B
X`09if ((loc = index(filename, '/')) == NIL(char)) `7B
X`09    /* error - bad filename */
X`09    return(NIL(char));
X`09`7D
X`09(void) strncpy(username, &filename`5B1`5D, loc - &filename`5B1`5D);
X`09username`5Bloc - &filename`5B1`5D`5D = '\0';
X#ifndef VMS
X`09if ((pw = getpwnam(username)) == NIL(struct passwd)) `7B
X`09    return(NIL(char));
X`09`7D
X`09(void) sprintf(dummy, "%s%s", pw->pw_dir, loc);
X#else
X`09return(getenv("USER"));
X#endif
X    `7D
X    return(dummy);
X`7D
X
Xchar *
XutNameExpand(filename)
Xchar *filename;    /* file name, possibly with a '`7E'             */
X/*
X * Use DOTDIR to expand a startup file name only if the filename is a
X * relative pathname. Otherwise call utTildeExpand()
X *
X *   returns: the expanded name of the file (in a static buffer)
X *            or NIL(char)`20
X */
X`7B
X#ifdef aiws
X    static char dummy2`5BMAXPATH`5D;
X#else
X    static char dummy2`5BMAXPATHLEN`5D;
X#endif /* aiws */
X    char *dotdir, *getenv _ARGUMENTS((const char *));
X   `20
X    if ((filename == NIL(char)) `7C`7C STREQ(filename, "")) `7B
X`09return(NIL(char));
X    `7D
X
X    if (filename`5B0`5D != '`7E' && filename`5B0`5D != '/')    `7B
X`09if ((dotdir = getenv("DOTDIR")) != NIL(char)) `7B
X`09    (void) sprintf(dummy2, "%s/%s", dotdir, filename);
X`09    return(dummy2);
X`09`7D
X`09return (utTildeExpand(filename));
X    `7D else `7B
X`09return(utTildeExpand(filename));
X    `7D
X`7D
X
X
Xint
XutSubstring(string, sub)
Xchar *string;
Xchar *sub;
X`7B
X    int i;
X    int srcLen = utStrlen(string);
X    int subLen = utStrlen(sub);
X
X    if (srcLen < subLen)
X`09return(0);
X   `20
X    for (i = 0; i < srcLen - subLen + 1; i++) `7B
X`09if (STREQN(&string`5Bi`5D, sub, utStrlen(sub))) `7B
X`09    return(1);
X`09`7D
X    `7D
X    return(0);
X`7D
X
X/*
X * down case the characters in a string (in place)
X */
Xvoid
XutDowncase(string)
Xchar *string;
X`7B
X    for ( ; *string != '\0'; string++) `7B
X`09if (isupper(*string)) `7B
X`09    *string = tolower(*string);
X`09`7D
X    `7D
X    return;
X`7D
X
X/*
X * like strncpy but lowercases too
X */
Xvoid
XutLowerCase(dst, src, size)
Xchar *dst;
Xchar *src;
X`7B
X    for ( ; size > 0 && *src != '\0'; src++, dst++, size--) `7B
X`09if (isupper(*src)) `7B
X`09    *dst = tolower(*src);
X`09`7D else `7B
X`09    *dst = *src;
X`09`7D
X    `7D
X    *dst = '\0';
X    return;
X`7D
X
X#ifdef VMS   `20
Xint
XutGroupToVmsFilename(filename,group)
X    char *filename;
X    char *group;
X`7B
X    char *ptr;
X    int i=0;
X
X    for (ptr = group; *ptr != 0; ptr++)
X    `7B
X`09if (isalnum(*ptr))
X`09`7B
X`09    filename`5Bi++`5D = *ptr;
X`09`7D
X`09else
X`09`7B
X`09    switch (*ptr)
X`09    `7B
X`09`09case '.' :
X`09`09    filename`5Bi++`5D = '_';
X`09`09    break;
X`09`09case '-' :
X`09`09    filename`5Bi++`5D = '-';
X`09`09    break;
X`09`09default :
X`09`09    i = i + sprintf(&filename`5Bi`5D, "$X%X$", *ptr);
X`09`09    break;
X`09    `7D
X`09`7D
X    `7D
X    filename`5Bi`5D = 0;
X    return (i);
X`7D
X#endif
X
X
X#ifdef VMS   `20
Xextern int delete();
Xint unlink(foo)
Xchar *foo;
X`7B
X    while (!delete(foo));
X    return 0;
X`7D
X#endif /* VMS */
X
X
X/* case insensitive comparision for subjects */
X
Xint
XutSubjectCompare(str1, str2)
X#if defined(__STDC__) && __STDC__
Xconst char *str1;
Xconst char *str2;
X#else
Xchar *str1, *str2;
X#endif
X`7B
X    char c1, c2;
X
X    while (True) `7B
X`09if (!*str1 && !*str2) `7B
X`09    return 0;
X`09`7D
X`09if (!*str1) `7B
X`09    return -1;
X`09`7D
X`09if (!*str2) `7B
X`09    return 1;
X`09`7D
X`09if (isupper(*str1)) `7B
X`09    c1 = tolower(*str1);
X`09`7D else `7B
X`09    c1 = *str1;
X`09`7D
X`09if (isupper(*str2)) `7B
X`09    c2 = tolower(*str2);
X`09`7D else `7B
X`09    c2 = *str2;
X`09`7D
X`09if (c1 != c2) `7B
X`09    return (c1 - c2);
X`09`7D
X`09str1++;
X`09str2++;
X    `7D
X`7D
X
Xvoid
XutCopyFile(old, save)
Xchar *old;   /* name of file to save */
Xchar *save;  /* name of file to save to */
X`7B
X    FILE *orig, *new;
X    char buf`5BBUFSIZ`5D;
X    char *newFile;
X    int num_read;
X
X    if ((orig = fopen(old, "r")) == NULL) `7B
X`09return;
X    `7D
X
X    if ((newFile = utNameExpand(save)) == NIL(char)) `7B
X`09return;
X    `7D
X
X    /* if .old is a link to new we could have trouble, so unlink it */
X    (void) unlink(newFile);
X   `20
X    if ((new = fopen(newFile, "w")) == NULL) `7B
X`09fclose(orig);
X`09return;
X    `7D
X
X    while (num_read = fread(buf, sizeof(char), BUFSIZ, orig)) `7B
X`09(void) fwrite(buf, sizeof(char), num_read, new);
X    `7D
X
X    (void) fclose(orig);
X    (void) fclose(new);
X
X    return;
X`7D
X
X#ifdef NEED_STRNCASECMP
X
Xstrncasecmp(str1,str2,len)
Xchar  *str1, *str2;
Xint   len;
X`7B
X      char    *tmp1,*tmp2;
X      int     i,result;
X      if ((tmp1 = (char *)malloc(len+1)) == NULL) `7B
X              perror("strncasecmp");
X              exit(1);
X      `7D
X      if ((tmp2 = (char *)malloc(len+1)) == NULL) `7B
X              free(tmp1);
X              perror("strncasecmp");
X              exit(1);
X      `7D
X      for (i = 0; i < len && str1`5Bi`5D != '\0'; i++)
X              if (isupper(str1`5Bi`5D))
X                      tmp1`5Bi`5D = tolower(str1`5Bi`5D);
X              else
X                      tmp1`5Bi`5D = str1`5Bi`5D;
X      tmp1`5Bi`5D = '\0';
X      for (i = 0; i < len && str2`5Bi`5D != '\0'; i++)
X              if (isupper(str2`5Bi`5D))
X                      tmp2`5Bi`5D = tolower(str2`5Bi`5D);
X              else
X                      tmp2`5Bi`5D = str2`5Bi`5D;
X      tmp2`5Bi`5D = '\0';
X      result = strncmp(tmp1,tmp2,len);
X      free(tmp1);
X      free(tmp2);
X      return result;
X`7D
X#endif /* NEED_STRNCASECMP */
X
X
X#ifdef REALLY_USE_LOCALTIME
Xstatic int days`5B`5D = `7B 31,28,31,30,31,30,31,31,30,31,30,31`7D;
X
X/**********************************************************************
XThis function performs the function of mktime as declared in time.h,
Xbut which has no definition.  It's the inverse of gmtime.
X**********************************************************************/
X
Xtime_t
XmakeTime(tmp)
Xstruct tm *tmp;
X`7B
X  time_t ret;
X  int i;
X
X  if (tmp->tm_year < 70) return 0;
X  ret = ((tmp->tm_year-70) / 4)*(366+365+365+365);
X  switch ((tmp->tm_year-70) % 4) `7B
X  case 1:
X    ret += 365;
X    break;
X  case 2:
X    ret += 365+365;
X    if (tmp->tm_mon > 1) `7B
X      ret += 1;
X    `7D
X    break;
X  case 3:
X    ret += 365+366+365;
X  `7D
X  for (i=0; i<tmp->tm_mon; i++) `7B
X    ret += days`5Bi`5D;
X  `7D
X  ret += tmp->tm_mday-1;
X  ret = ret*24+tmp->tm_hour;
X  if (tmp->tm_isdst) `7B
X    ret -= 1;
X  `7D
X  ret = ret*60+tmp->tm_min;
X  ret = ret*60+tmp->tm_sec;
X  return ret;
X`7D
X
X/**********************************************************************
XThis (ugly) function takes a source of the form "31 Aug 90 16:47:06 GMT"
Xand writes into dest the equivalent in local time.  If an invalid
Xsource is given, the dest is a copy of the source.
X
XOptionally, there may be a "XXX, " prepending the source where XXX is
Xa weekday name.
X**********************************************************************/
X
Xchar *getzonename();
X
Xtconvert(dest, source)
Xchar *dest, *source;
X`7B
X  char *p, *fmt;
X  int h, m, s, day, mon, year;
X  struct tm *tmp, t;
X  time_t then;
X  int doWeekDay;
X#if defined(apollo)
X  int daylight;
X#endif
X
X  strcpy(dest, source);
X
X  /* Parse date */
X  p = source;
X  if (!strncasecmp(p, "mon, ", 5) `7C`7C
X      !strncasecmp(p, "tue, ", 5) `7C`7C
X      !strncasecmp(p, "wed, ", 5) `7C`7C
X      !strncasecmp(p, "thu, ", 5) `7C`7C
X      !strncasecmp(p, "fri, ", 5) `7C`7C
X      !strncasecmp(p, "sat, ", 5) `7C`7C
X      !strncasecmp(p, "sun, ", 5)) `7B
X    p += 5;
X    doWeekDay = 1;
X  `7D else `7B
X/*    doWeekDay = 0; */
X    doWeekDay = 1;`09`09/* Let's put the weekday in all postings */
X  `7D
X  while (*p == ' ') `7B
X    p++;
X  `7D
X  if (!sscanf(p, "%d", &day)) `7B
X    return;
X  `7D
X  while (*p != ' ' && *p != '\0') `7B
X    p++;
X  `7D
X  if (*p == '\0') `7B
X    return;
X  `7D
X  while (*p == ' ' && *p != '\0') `7B
X    p++;
X  `7D
X  if (*p == '\0') `7B
X    return;
X  `7D
X  if (!strncasecmp(p, "jan", 3)) `7B
X    mon = 0;
X  `7D else if (!strncasecmp(p, "feb", 3)) `7B
X    mon = 1;
X  `7D else if (!strncasecmp(p, "mar", 3)) `7B
X    mon = 2;
X  `7D else if (!strncasecmp(p, "apr", 3)) `7B
X    mon = 3;
X  `7D else if (!strncasecmp(p, "may", 3)) `7B
X    mon = 4;
X  `7D else if (!strncasecmp(p, "jun", 3)) `7B
X    mon = 5;
X  `7D else if (!strncasecmp(p, "jul", 3)) `7B
X    mon = 6;
X  `7D else if (!strncasecmp(p, "aug", 3)) `7B
X    mon = 7;
X  `7D else if (!strncasecmp(p, "sep", 3)) `7B
X    mon = 8;
X  `7D else if (!strncasecmp(p, "oct", 3)) `7B
X    mon = 9;
X  `7D else if (!strncasecmp(p, "nov", 3)) `7B
X    mon = 10;
X  `7D else if (!strncasecmp(p, "dec", 3)) `7B
X    mon = 11;
X  `7D else `7B
X    return;
X  `7D
X  while (*p != ' ' && *p != '\0') `7B
X    p++;
X  `7D
X  if (*p == '\0') `7B
X    return;
X  `7D
X  if (!sscanf(p, "%d", &year)) `7B
X    return;
X  `7D
X  year = year % 100;
X
X  /* Parse time */
X  p = strrchr(source, ':');
X  if (!p) `7B
X    return;
X  `7D
X  p--;
X  while (p > source && *p != ':') `7B
X    p--;
X  `7D
X  while (p > source && *p != ' ') `7B
X    p--;
X  `7D
X  if (!p) `7B
X    return;
X  `7D
X  sscanf(p, "%d", &h);
X  p = strchr(p, ':');
X  if (!p++) `7B
X    return;
X  `7D
X  sscanf(p, "%d", &m);
X  p = strchr(p, ':');
X  if (!p++) `7B
X    return;
X  `7D
X  sscanf(p, "%d", &s);
X  p = strchr(p, ' ');
X  if (!p++) `7B
X    return;
X  `7D
X
X  /* Confirm GMT */
X  if (strcmp(p, "GMT")) `7B
X    return;
X  `7D
X
X  t.tm_sec = s;
X  t.tm_min = m;
X  t.tm_hour = h;
X  t.tm_mday = day;
X  t.tm_mon = mon;
X  t.tm_year = year;
X  t.tm_isdst = 0;
X  then = makeTime(&t);
X  tmp = localtime(&then);
X `20
X/* ascftime is non-standard, sigh.
X  ascftime(dest, "%e %b %y %H:%M:%S %Z", tmp);
X*/
X  fmt = asctime(tmp);
X  /* Make this look like the original format */
X  p = dest;
X  if (doWeekDay) `7B
X    switch (tmp->tm_wday) `7B
X    case 0:
X      strcpy(dest, "Sun, ");
X      break;
X    case 1:
X      strcpy(dest, "Mon, ");
X      break;
X    case 2:
X      strcpy(dest, "Tue, ");
X      break;
X    case 3:
X      strcpy(dest, "Wed, ");
X      break;
X    case 4:
X      strcpy(dest, "Thu, ");
X      break;
X    case 5:
X      strcpy(dest, "Fri, ");
X      break;
X    case 6:
X      strcpy(dest, "Sat, ");
X      break;
X    `7D
X    p += 5;
X  `7D
X  if (*(fmt+8) == ' ') `7B
X    strncpy(p, fmt+9, 2);
X    p += 2;
X  `7D else `7B
X    strncpy(p, fmt+8, 3);
X    p += 3;
X  `7D
X  strncpy(p, fmt+4, 4);
X  p += 4;
X  if ((tmp->tm_year % 100) < 10) `7B
X    sprintf(p, "0%d", tmp->tm_year % 100);
X  `7D else `7B
X    sprintf(p, "%d", tmp->tm_year % 100);
X  `7D
X  strcat(dest, fmt+10);
X  p = strrchr(dest, ' ');
X#if defined(sun) && !defined(SYSV)`09`09`09`09    /* ggh */
X  strcpy(p+1, tmp->tm_zone);
X#else
X#if defined(ultrix)
X  (void) strcpy(p+1, getzonename(tmp->tm_isdst));
X#else
X#if defined(apollo)
X  daylight = tmp->tm_isdst;
X#endif
X  if (daylight) `7B
X    strcpy(p+1, tzname`5B1`5D);
X  `7D else `7B
X    strcpy(p+1, tzname`5B0`5D);
X  `7D
X#endif
X#endif
X
X  if (*dest == ' ') `7B
X    p = dest;
X    while (*p != '\0') `7B
X      *p = *(p+1);
X      p++;
X    `7D
X  `7D
X`7D
X
X#if defined(apollo) `7C`7C defined(ultrix) `7C`7C defined(SYSV)
X#if !defined(_POSIX_SOURCE) && !defined(__STDC__)
X
Xextern char *timezone();
X
X#if defined(ultrix) && defined(mips)
Xchar * getzonename(isdst)
Xint isdst;
X`7B
X    static char *name`5B2`5D;
X    time_t then = 0;
X    struct tm *tm;
X
X    if (isdst)
X`09isdst = 1;
X
X    if (name`5Bisdst`5D != NULL)
X`09return name`5Bisdst`5D;
X
X    tm = localtime(&then);
X    if (tm->tm_isdst == isdst) `7B
X`09name`5Bisdst`5D = XtNewString(tm->tm_zone);
X    `7D else `7B
X`09name`5Bisdst`5D = XtNewString(timezone(tm->tm_gmtoff/60, isdst));
X    `7D
X    return name`5Bisdst`5D;
X`7D
X#else /* ultrix && mips */
Xchar *
Xgetzonename(isdst)
Xint isdst;
X`7B
X    static char *name`5B2`5D;
X    struct timezone tz;
X
X    if (isdst)
X`09isdst = 1;
X
X    if (name`5Bisdst`5D != NULL)
X`09return name`5Bisdst`5D;
X
X    gettimeofday(NULL, &tz);
X    name`5Bisdst`5D = XtNewString(timezone(tz.tz_minuteswest, isdst));
X    return name`5Bisdst`5D;
X`7D
X#endif /* ultrix  && mips */
X#else /* POSIX */
X#include <sys/time.h>
Xchar *
Xgetzonename(isdst)
Xint isdst;
X`7B
X    if (isdst)
X`09isdst = 1;
X
X    return tzname`5Bisdst`5D;
X`7D
X#endif /* POSIX or STDC */
X#endif /* apollo or ultrix or SYSV */
X#endif /* REALLY_USE_LOCALTIME */
X
Xchar *
Xstring_pool(key)
Xchar *key;
X`7B
X    char *tmp;
X
X    if (StringPool == NULL)
X`09StringPool = avl_init_table(strcmp);
X
X    if (!avl_lookup(StringPool, key, &tmp)) `7B
X`09avl_insert_str(StringPool, key);
X`09avl_lookup(StringPool, key, &tmp);
X    `7D
X    return tmp;
X`7D
X
X#ifdef XLATE
X
X#define UC(x)`09(unsigned char)(x)
X/* translate a character string in place */
X
Xstatic Boolean`09inited = 0;
Xstatic char`09xlate`5B 256 `5D;
Xstatic char`09unxlate`5B 256 `5D;
X
Xstatic void
XXlateInit()
X`7B
X    char`09*to = XLATE_TO, *from = XLATE_FROM;
X    int`09`09i;
X
X    for ( i = 256; --i >= 0; )
X`09xlate`5B i `5D = unxlate`5B i `5D = i;
X
X    while (*to && *from) `7B
X`09unxlate`5B UC(*to) `5D = *from;
X`09xlate`5B UC(*from++) `5D = *to++;
X    `7D
X    inited = 1;
X`7D
X
Xvoid
XutXlate(s)
Xchar *s;
X`7B
X    if (!inited) XlateInit();
X
X    do `7B
X`09*s = xlate`5B UC(*s) `5D;
X    `7D while(*++s);
X`7D
X
Xvoid
XutUnXlate(s)
Xchar *s;
X`7B
X    if (!inited) XlateInit();
X
X    do `7B
X`09*s = unxlate`5B UC(*s) `5D;
X    `7D while(*++s);
X`7D
X#endif /* XLATE */
$ CALL UNPACK UTILS.C;21 1459958631
$ create 'f'
X#ifndef UTILS_H
X#define UTILS_H
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/utils.h,v 1.8 1993/0
V2/04 18:22:36 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * utils.h: random utility functions and macros for xrn
X */
X
X/*
X * for XtMalloc, etc.
X */
X#ifndef MOTIF
X#ifndef VMS
X#include <X11/Intrinsic.h>
X#else`09/* VMS */
X#include <decw$include:Intrinsic.h>
X#endif`09/* VMS */
X#else`09/* MOTIF */
X#include <X11/Intrinsic.h>
X#endif`09/* MOTIF */
X
X#ifndef MAX
X#define MAX(a,b) (((a)>(b))?(a):(b))
X#endif
X
X#if defined(_ANSI_C_SOURCE)
X#if defined(__STDC__)
Xtypedef void    (*SIG_PF0) (int);
X#else /* __STDC__ */
Xtypedef void    (*SIG_PF0) ();
X#endif /* __STDC__ */
X#else /* _ANSI_C_SOURCE */
X#if defined(SYSV) `7C`7C defined(SVR4)
X#if defined(__STDC__)
Xtypedef void    (*SIG_PF0) (int, ...);
X#else /* __STDC__ */
Xtypedef void    (*SIG_PF0) ();
X#endif /* __STDC__ */
X#else /* SYSV `7C`7C SVR4 */
X#if defined(__STDC__)
Xtypedef int     (*SIG_PF0) (int, ...);
X#else /* __STDC__ */
Xtypedef int     (*SIG_PF0) ();
X#endif /* __STDC__ */
X#endif /* SYSV `7C`7C SVR4 */
X#endif /* _ANSI_C_SOURCE, SYSV/SVR4, __STDC__ */
X
X#if !defined(_POSIX_SOURCE)
Xextern char *strtok _ARGUMENTS((char *, char const *));
Xextern char *getenv _ARGUMENTS((const char *));
X#else
X#ifndef NOSTDHDRS
X#include <stdlib.h>
X#endif /* NOSTDHDRS */
X#endif /* !_POSIX_SOURCE */
X#if !defined(_XOPEN_SOURCE)
Xextern char *mktemp _ARGUMENTS((char *));
X#else
X#define mktemp(string)    tmpnam(string)
X#endif
X#if !defined(_OSF_SOURCE)
Xextern char *index _ARGUMENTS((const char *, int));
Xextern char *rindex _ARGUMENTS((const char *, int));
X#else
X#include <string.h>
X#endif
X
X#ifdef macII
Xextern int strcmp();
X#endif
X
X/* allocation macros */
X#define ALLOC(type)           (type *) XtMalloc((unsigned) sizeof(type))
X#define ARRAYALLOC(type, sz)  (type *) XtMalloc((unsigned) (sizeof(type) * (
Vsz)))
X#define NIL(type)             (type *) 0
X#define FREE(item)            if ((char *) item != NIL(char)) XtFree((char *
V) item), item = 0
X#ifdef VMS
Xextern int utGroupToVmsFilename(char *filename, char *group);
X#endif
X#define STREQ(a,b)            (strcmp(a, b) == 0)
X#define STREQN(a,b,n)         (strncmp(a, b, n) == 0)
X
Xextern char *utTrimSpaces _ARGUMENTS((char *));
Xextern char *utNameExpand _ARGUMENTS((char *));
Xextern char *utTildeExpand _ARGUMENTS((char *));
Xextern int utSubstring _ARGUMENTS((char *, char *));
Xextern void utDowncase _ARGUMENTS((char *));
Xextern void utLowerCase _ARGUMENTS((char *, char *, int));
Xextern void utCopyFile _ARGUMENTS((char *, char *));
X
X#define utStrlen(s)`09((s) ? strlen(s) : 0)
X
X#if defined(__STDC__) && __STDC__
Xextern int utSubjectCompare _ARGUMENTS((const char *, const char *));
X#else
Xextern int utSubjectCompare ();
X#endif
X
X#ifdef NEED_TEMPNAM
Xextern char *tempnam _ARGUMENTS((char *, char *));
X#endif
X
X#ifdef SYSV_REGEX
Xextern char *regcmp();
X#else
Xextern char *re_comp();
Xextern int re_exec();
X#endif
X
X#if !defined(ultrix) && !defined(VMS) && !defined(__osf__)
X#if defined(__STDC__)
Xextern FILE * popen _ARGUMENTS((const char *, const char *));
X#else
Xextern FILE * popen _ARGUMENTS((char *, char *));
X#endif
Xextern int pclose _ARGUMENTS((FILE *));
X#endif
X
X# if defined(NEED_STRCASECMP) && !defined(__osf__)
Xextern int strcasecmp _ARGUMENTS((const char *, const char *));
Xextern int strncasecmp _ARGUMENTS((const char *, const char *, size_t));
X#endif
X
X#if defined __STDC__ && !defined(VMS)
X#include <sys/time.h>
Xextern int gettimeofday _ARGUMENTS((struct timeval *, struct timezone *));
X#endif
X
Xextern int tconvert _ARGUMENTS((char *, char *));
Xextern char * string_pool _ARGUMENTS((char *));
X#ifdef XLATE
Xextern void utXlate _ARGUMENTS((char *));
Xextern void utUnXlate _ARGUMENTS ((char *));
X#endif
X
X#endif /* UTILS_H */
$ CALL UNPACK UTILS.H;33 21820656
$ create 'f'
X#include "config.h"
X
X#ifdef NEED_VPRINTF
X
X#include <stdio.h>
X
X/* Portable vfprintf  by Robert A. Larson <blarson@skat.usc.edu> */
X
X/* Copyright 1989 Robert A. Larson.
X * Distribution in any form is allowed as long as the author
X * retains credit, changes are noted by their author and the
X * copyright message remains intact.  This program comes as-is
X * with no warentee of fitness for any purpouse.
X *
X * Thanks to Doug Gwen, Chris Torek, and others who helped clarify
X * the ansi printf specs.
X *
X * Please send any bug fixes and improvments to blarson@skat.usc.edu .
X * The use of goto is NOT a bug.
X */
X
X/* Feb`097, 1989`09`09blarson`09`09First usenet release */
X
X/* This code implements the vsprintf function, without relying on
X * the existance of _doprint or other system specific code.
X *
X * Define NOVOID if void * is not a supported type.
X *
X * Two compile options are available for efficency:
X *`09INTSPRINTF`09should be defined if sprintf is int and returns
X *`09`09`09the number of chacters formated.
X *`09LONGINT`09`09should be defined if sizeof(long) == sizeof(int)
X *
X *`09They only make the code smaller and faster, they need not be
X *`09defined.
X *
X * UNSIGNEDSPECIAL should be defined if unsigned is treated differently
X * than int in argument passing.  If this is definded, and LONGINT is not,
X * the compiler must support the type unsingned long.
X *
X * Most quirks and bugs of the available sprintf fuction are duplicated,
X * however * in the width and precision fields will work correctly
X * even if sprintf does not support this, as will the n format.
X *
X * Bad format strings, or those with very long width and precision
X * fields (including expanded * fields) will cause undesired results.
X */
X
X/*`20
X * XRN changes (submitted by users) 2/1/91
X *
X *  - inclusion of config.h
X *  - addition of #ifdef NEED_VPRINTF / #endif (set by config.h)
X *  - changed #ifdef __STDC__ around varargs.h / stdargs.h to
X *     #if defined(__STDC__) && !defined(NOSTDHDRS)
X *  - addition stdargs / varargs
X *  - combined vprintf.c and vsprintf.c into 1 file
X */
X
X#ifdef OSK`09`09/* os9/68k can take advantage of both */
X#define LONGINT
X#define INTSPRINTF
X#endif
X
X/* This must be a typedef not a #define! */
X#define NOVOID
X#ifdef NOVOID
Xtypedef char *pointer;
X#else
Xtypedef void *pointer;
X#endif
X
X#ifdef`09INTSPRINTF
X#define Sprintf(string,format,arg)`09(sprintf((string),(format),(arg)))
X#else
X#define Sprintf(string,format,arg)`09(\
X`09sprintf((string),(format),(arg)),\
X`09strlen(string)\
X)
X#endif
X
X#if defined(__STDC__) && !defined(NOSTDHDRS)
X#include <stdarg.h>
X#else
X#include <varargs.h>
X#endif
X
Xtypedef int *intp;
X
Xint vsprintf(dest, format, args)
Xchar *dest;
Xregister char *format;
Xva_list args;
X`7B
X    register char *dp = dest;
X    register char c;
X    register char *tp;
X    char tempfmt`5B64`5D;
X#ifndef LONGINT
X    int longflag;
X#endif
X
X    tempfmt`5B0`5D = '%';
X    while(c = *format++) `7B
X`09if(c=='%') `7B
X`09    tp = &tempfmt`5B1`5D;
X#ifndef LONGINT
X`09    longflag = 0;
X#endif
Xcontinue_format:
X`09    switch(c = *format++) `7B
X`09`09case 's':
X`09`09    *tp++ = c;
X`09`09    *tp = '\0';
X`09`09    dp += Sprintf(dp, tempfmt, va_arg(args, char *));
X`09`09    break;
X`09`09case 'u':
X`09`09case 'x':
X`09`09case 'o':
X`09`09case 'X':
X#ifdef UNSIGNEDSPECIAL
X`09`09    *tp++ = c;
X`09`09    *tp = '\0';
X#ifndef LONGINT
X`09`09    if(longflag)
X`09`09`09dp += Sprintf(dp, tempfmt, va_arg(args, unsigned long));
X`09`09    else
X#endif
X`09`09`09dp += Sprintf(dp, tempfmt, va_arg(args, unsigned));
X`09`09    break;
X#endif
X`09`09case 'd':
X`09`09case 'c':
X`09`09case 'i':
X`09`09    *tp++ = c;
X`09`09    *tp = '\0';
X#ifndef LONGINT
X`09`09    if(longflag)
X`09`09`09dp += Sprintf(dp, tempfmt, va_arg(args, long));
X`09`09    else
X#endif
X`09`09`09dp += Sprintf(dp, tempfmt, va_arg(args, int));
X`09`09    break;
X`09`09case 'f':
X`09`09case 'e':
X`09`09case 'E':
X`09`09case 'g':
X`09`09case 'G':
X`09`09    *tp++ = c;
X`09`09    *tp = '\0';
X`09`09    dp += Sprintf(dp, tempfmt, va_arg(args, double));
X`09`09    break;
X`09`09case 'p':
X`09`09    *tp++ = c;
X`09`09    *tp = '\0';
X`09`09    dp += Sprintf(dp, tempfmt, va_arg(args, pointer));
X`09`09    break;
X`09`09case '-':
X`09`09case '+':
X`09`09case '0':
X`09`09case '1':
X`09`09case '2':
X`09`09case '3':
X`09`09case '4':
X`09`09case '5':
X`09`09case '6':
X`09`09case '7':
X`09`09case '8':
X`09`09case '9':
X`09`09case '.':
X`09`09case ' ':
X`09`09case '#':
X`09`09case 'h':
X`09`09    *tp++ = c;
X`09`09    goto continue_format;
X`09`09case 'l':
X#ifndef LONGINT
X`09`09    longflag = 1;
X`09`09    *tp++ = c;
X#endif
X`09`09    goto continue_format;
X`09`09case '*':
X`09`09    tp += Sprintf(tp, "%d", va_arg(args, int));
X`09`09    goto continue_format;
X`09`09case 'n':
X`09`09    *va_arg(args, intp) = dp - dest;
X`09`09    break;
X`09`09case '%':
X`09`09default:
X`09`09    *dp++ = c;
X`09`09    break;
X`09    `7D
X`09`7D else *dp++ = c;
X    `7D
X    *dp = '\0';
X    return dp - dest;
X`7D
X
X
Xint vfprintf(dest, format, args)
XFILE *dest;
Xregister char *format;
Xva_list args;
X`7B
X    register char c;
X    register char *tp;
X    register int count = 0;
X    char tempfmt`5B64`5D;
X#ifndef LONGINT
X    int longflag;
X#endif
X
X    tempfmt`5B0`5D = '%';
X    while(c = *format++) `7B
X`09if(c=='%') `7B
X`09    tp = &tempfmt`5B1`5D;
X#ifndef LONGINT
X`09    longflag = 0;
X#endif
Xcontinue_format:
X`09    switch(c = *format++) `7B
X`09`09case 's':
X`09`09    *tp++ = c;
X`09`09    *tp = '\0';
X`09`09    count += fprintf(dest, tempfmt, va_arg(args, char *));
X`09`09    break;
X`09`09case 'u':
X`09`09case 'x':
X`09`09case 'o':
X`09`09case 'X':
X#ifdef UNSIGNEDSPECIAL
X`09`09    *tp++ = c;
X`09`09    *tp = '\0';
X#ifndef LONGINT
X`09`09    if(longflag)
X`09`09`09count += fprintf(dest, tempfmt, va_arg(args, unsigned long));
X`09`09    else
X#endif
X`09`09`09count += fprintf(dest, tempfmt, va_arg(args, unsigned));
X`09`09    break;
X#endif
X`09`09case 'd':
X`09`09case 'c':
X`09`09case 'i':
X`09`09    *tp++ = c;
X`09`09    *tp = '\0';
X#ifndef LONGINT
X`09`09    if(longflag)
X`09`09`09count += fprintf(dest, tempfmt, va_arg(args, long));
X`09`09    else
X#endif
X`09`09`09count += fprintf(dest, tempfmt, va_arg(args, int));
X`09`09    break;
X`09`09case 'f':
X`09`09case 'e':
X`09`09case 'E':
X`09`09case 'g':
X`09`09case 'G':
X`09`09    *tp++ = c;
X`09`09    *tp = '\0';
X`09`09    count += fprintf(dest, tempfmt, va_arg(args, double));
X`09`09    break;
X`09`09case 'p':
X`09`09    *tp++ = c;
X`09`09    *tp = '\0';
X`09`09    count += fprintf(dest, tempfmt, va_arg(args, pointer));
X`09`09    break;
X`09`09case '-':
X`09`09case '+':
X`09`09case '0':
X`09`09case '1':
X`09`09case '2':
X`09`09case '3':
X`09`09case '4':
X`09`09case '5':
X`09`09case '6':
X`09`09case '7':
X`09`09case '8':
X`09`09case '9':
X`09`09case '.':
X`09`09case ' ':
X`09`09case '#':
X`09`09case 'h':
X`09`09    *tp++ = c;
X`09`09    goto continue_format;
X`09`09case 'l':
X#ifndef LONGINT
X`09`09    longflag = 1;
X`09`09    *tp++ = c;
X#endif
X`09`09    goto continue_format;
X`09`09case '*':
X`09`09    tp += Sprintf(tp, "%d", va_arg(args, int));
X`09`09    goto continue_format;
X`09`09case 'n':
X`09`09    *va_arg(args, intp) = count;
X`09`09    break;
X`09`09case '%':
X`09`09default:
X`09`09    putc(c, dest);
X`09`09    count++;
X`09`09    break;
X`09    `7D
X`09`7D else `7B
X`09    putc(c, dest);
X`09    count++;
X`09`7D
X    `7D
X    return count;
X`7D
X
Xvprintf(format, args)
Xchar *format;
Xva_list args;
X`7B
X    return vfprintf(stdout, format, args);
X`7D
X
X#endif
$ CALL UNPACK VPRINTF.C;2 1732592220
$ create 'f'
XPortable vsprintf, vfprintf, and vprintf  by Robert A. Larson
X`09<blarson@skat.usc.edu>
X
XCopyright 1989 Robert A. Larson.
XDistribution in any form is allowed as long as the author
Xretains credit, changes are noted by their author and the
Xcopyright message remains intact.  This program comes as-is
Xwith no warentee of fitness for any purpouse.
X
XThanks to Doug Gwen, Chris Torek, and others who helped clarify
Xthe ansi printf specs.
X
XPlease send any bug fixes and improvments to blarson@skat.usc.edu .
XThe use of goto is NOT a bug.
X
X
XFeb  9, 1989`09`09blarson`09`09First usenet release
X
XThis code implements the vsprintf function, without relying on
Xthe existance of _doprint or other system specific code.
X
XDefine NOVOID if void * is not a supported type.
X
XTwo compile options are available for efficency:
X`09INTSPRINTF`09should be defined if sprintf is int and returns
X`09`09`09the number of chacters formated.
X`09LONGINT`09`09should be defined if sizeof(long) == sizeof(int)
X
X`09They only make the code smaller and faster, they need not be`20
X`09defined.
X
XUNSIGNEDSPECIAL should be defined if unsigned is treated differently
Xthan int in argument passing.  If this is definded, and LONGINT is not,
Xthe compiler must support the type unsigned long.
X
XMost quirks and bugs of the available sprintf and fprintf fuction are
Xduplicated, however * in the width and precision fields will work
Xcorrectly even if sprintf does not support this, and the %n format
Xwill always work in vsprintf.  %n and return count will work properly
Xin vfprintf and vprintf only if fprintf returns the number of
Xcharacters formatted.
X
XBad format strings, or those with very long width and precision
Xfields (including expanded * fields) will cause undesired results.
$ CALL UNPACK VPRINTF.DOC;2 187493732
$ create 'f'
X
X#if !defined(lint) && !defined(SABER)
Xstatic char XRNrcsid`5B`5D = "$Header: /net/objy27/wrld/mnt11/ricks/src/mast
Ver/xrn/xmisc.c,v 1.6 1993/02/04 18:22:38 ricks Exp $";
X#endif
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * xmisc.c: routines for handling miscellaneous x functions
X *
X */
X
X#include "copyright.h"
X#ifndef VMS
X#include <X11/X.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#else
X#include <decw$include/X.h>
X#include <decw$include/Xlib.h>
X#include <decw$include/Xutil.h>
X#endif
X#include "config.h"
X#include <stdio.h>
X#include "utils.h"
X#ifndef VMS
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#include <X11/Shell.h>
X#ifdef USE_DEC_CURSOR
X#include <X11/decwcursor.h>
X#else
X#include <X11/cursorfont.h>
X#endif /* USE_DEC_CURSOR */
X#else
X#include <decw$include/Intrinsic.h>
X#include <decw$include/StringDefs.h>
X#include <decw$include/Shell.h>
X#ifdef USE_DEC_CURSOR
X#include <decw$cursor.h>
X#else
X#include <decw$include/cursorfont.h>
X#endif /* USE_DEC_CURSOR */
X#endif
X#ifdef MOTIF
X#include <Xm/Xm.h>
X#include <Xm/PushB.h>
X#include <Xm/Text.h>
X#if (XmVERSION == 1) && (XmREVISION == 0)
X#define MOTIF_V10
X#endif
X#ifdef VMS
X#include <Xm/XmP.h>
X#include <Xm/TextP.h>
X#endif
X#else
X#ifndef VMS
X#include <X11/DwtAppl.h>
X#else
X#include <decw$include/DwtAppl.h>
X#endif
X#endif
X#include "xthelper.h"
X#include "resources.h"
X#include "news.h"
X#include "internals.h"
X#include "xrn.h"
X#include "xmisc.h"
X
X
X/* XRN icon */
X
X#include "xrn.xbm"
X#include "calvin.icon"
X#include "bigicon.xbm"
X#include "smallicon.xbm"
X
X#define MOTIF_WM 1
X#define DEC_WM 2
X
X#ifndef XtNiconifyPixmap
X#define XtNiconifyPixmap "iconifyPixmap"
X#endif
X
Xstatic Pixmap icon_pixmap = (Pixmap) 0;
Xstatic Pixmap big_pixmap = (Pixmap) 0;
Xstatic Pixmap small_pixmap = (Pixmap) 0;
Xstatic Pixmap icon_i_pixmap = (Pixmap) 0;
Xstatic Pixmap big_i_pixmap = (Pixmap) 0;
Xstatic Pixmap small_i_pixmap = (Pixmap) 0;
Xstatic int WhichWM = -1;
X
X
Xstatic Pixmap
Xgetpm()
X`7B
X    unsigned int width, height;
X    unsigned char *bits;
X
X    if (app_resources.calvin) `7B
X`09width = calvin_width;
X`09height = calvin_height;
X`09bits = calvin_bits;
X    `7D else `7B
X`09width = xrn_width;
X`09height = xrn_height;
X`09bits = xrn_bits;
X    `7D
X
X    return XCreateBitmapFromData(XtDisplay(TopLevel), XtScreen(TopLevel)->ro
Vot,
X`09`09`09`09 (char *) bits, width, height);
X`7D
X
Xvoid
XxmSetIconAndName(it)
XIconType it;
X`7B
X    static char`09*PrevName = NULL, *OldName = NULL;
X    static Pixmap     PrevPm = None, OldPm = None;
X    char`09*name;
X    Pixmap`09pm;
X    Arg`09`09arg;
X#ifdef MOTIF
X    static`09char *lostName = "mxrn: Connection Lost";
X    static`09char *newName = "mxrn (New Groups)";
X#else
X    static`09char *lostName = "dxrn: Connection Lost";
X    static`09char *newName = "dxrn (New Groups)";
X#endif
X
X    if (OldPm == None) `7B
X`09XtSetArg(arg, XtNiconPixmap, &OldPm);
X  `09XtGetValues(TopLevel, &arg, 1);
X `09PrevPm = OldPm;
X    `7D
X
X    if (app_resources.iconPixmap == None) `7B
X`09app_resources.iconPixmap = getpm();
X    `7D
X
X    if (app_resources.unreadIconPixmap == None) `7B
X`09app_resources.unreadIconPixmap = app_resources.iconPixmap;
X    `7D
X
X    switch (it) `7B
X`09case InitIcon :
X`09    PrevPm = pm = app_resources.iconPixmap;
X`09    PrevName = name = OldName = app_resources.iconName;
X`09    break;
X`09case UnreadIcon :
X`09    PrevPm = pm = app_resources.unreadIconPixmap;
X`09    PrevName = name = app_resources.unreadIconName;
X`09    break;
X`09case ReadIcon :
X`09    PrevPm = pm = app_resources.iconPixmap;
X`09    PrevName = name = app_resources.iconName;
X`09    break;
X`09case BusyIcon :
X`09    if ((pm = app_resources.busyIconPixmap) == None)
X`09`09pm = OldPm;
X`09    if ((name = app_resources.busyIconName) == NULL)
X `09`09name = OldName;
X `09    break;
X`09case LostIcon:
X`09    pm = PrevPm;
X`09    name = lostName;
X`09    break;
X`09case NewGroupsIcon:
X`09    pm = PrevPm;
X`09    name = newName;
X`09    break;
X `09case PrevIcon :
X `09    pm = PrevPm;
X `09    name = PrevName;
X `09    break;
X    `7D
X
X    if (OldPm != pm) `7B
X `09XtSetArg(arg, XtNiconPixmap, pm);
X  `09XtSetValues(TopLevel, &arg, 1);
X `09OldPm = pm;
X    `7D
X
X    if (name == NULL) `7B
X `09name = app_resources.iconName;
X    `7D
X
X    if (OldName != name) `7B
X `09XSetIconName(XtDisplay(TopLevel),XtWindow(TopLevel),name);
X `09XFlush(XtDisplay(TopLevel));
X`09OldName = name;
X    `7D
X`7D
X`20
Xvoid
XxmIconCreate(whichWidget)
XWidget whichWidget;
X`7B
X    unsigned char *bits, *i_bits;
X    int width, height;
X    Arg arg`5B2`5D;
X    XIconSize *icon_size_list;
X    int numsizes;
X    Display *dpy;
X   `20
X    if (WhichWM == -1) `7B
X`09dpy = XtDisplay(whichWidget);
X`09if (XGetIconSizes(dpy, RootWindow(dpy, DefaultScreen(dpy)),
X`09`09`09&icon_size_list, &numsizes)) `7B
X`09    if (numsizes > 0) `7B
X`09`09if (icon_size_list`5B0`5D.width_inc > 1) `7B
X`09`09    WhichWM = DEC_WM;
X`09`09`7D else `7B
X`09`09    WhichWM = MOTIF_WM;
X`09`09`7D
X`09    `7D else `7B
X`09`09WhichWM = MOTIF_WM;
X`09    `7D
X`09    XFree(icon_size_list);
X`09`7D else `7B
X`09    WhichWM = MOTIF_WM;
X        `7D
X    `7D`09
X`09
X    if (app_resources.calvin) `7B
X`09width = calvin_width;
X`09height = calvin_height;
X`09bits = calvin_bits;
X`09i_bits = calvin_bits;
X    `7D else `7B
X`09width = xrn_width;
X`09height = xrn_height;
X`09bits = xrn_bits;
X`09i_bits = xrn_i_bits;
X    `7D
X
X    if (WhichWM != DEC_WM) `7B
X`09
X    /* XXX user sets iconPixmap resource, converter does the right thing.. *
V/
X`09XtSetArg(arg`5B0`5D, XtNiconPixmap, &icon_pixmap);
X`09XtGetValues(whichWidget, arg, 1);
X`09if (icon_pixmap == (Pixmap) 0) `7B
X`09    icon_pixmap = XCreateBitmapFromData(XtDisplay(TopLevel),
X`09`09`09`09       XtScreen(TopLevel)->root,
X`09`09`09`09       (char *) bits, width, height);
X`09    icon_i_pixmap = XCreateBitmapFromData(XtDisplay(TopLevel),
X`09`09`09`09       XtScreen(TopLevel)->root,
X`09`09`09`09       (char *) i_bits, width, height);
X`09    XtSetArg(arg`5B0`5D, XtNiconPixmap, icon_pixmap);
X`09    XtSetValues(whichWidget, arg, 1);
X`09`7D
X
X    `7D else `7B
X`09/* DEC window manager */
X`09if (big_pixmap == (Pixmap) 0) `7B
X`09    big_pixmap = XCreateBitmapFromData(XtDisplay(TopLevel),
X`09`09`09`09       XtScreen(TopLevel)->root,
X`09`09`09`09       (char *) bigicon_bits,
X`09`09`09`09       bigicon_width, bigicon_height);
X`09`7D
X`09if (big_i_pixmap == (Pixmap) 0) `7B
X`09    big_i_pixmap = XCreateBitmapFromData(XtDisplay(TopLevel),
X`09`09`09`09       XtScreen(TopLevel)->root,
X`09`09`09`09       (char *) bigicon_i_bits,
X`09`09`09`09       bigicon_i_width, bigicon_i_height);
X`09`7D
X`09if (small_pixmap == (Pixmap) 0) `7B
X`09    small_pixmap = XCreateBitmapFromData(XtDisplay(TopLevel),
X`09`09`09`09       XtScreen(TopLevel)->root,
X`09`09`09`09       (char * ) smallicon_bits,
X`09`09`09`09       smallicon_width, smallicon_height);
X`09`7D
X`09if (small_i_pixmap == (Pixmap) 0) `7B
X`09    small_i_pixmap = XCreateBitmapFromData(XtDisplay(TopLevel),
X`09`09`09`09       XtScreen(TopLevel)->root,
X`09`09`09`09       (char * ) smallicon_i_bits,
X`09`09`09`09       smallicon_i_width, smallicon_i_height);
X`09`7D
X`09XtSetArg(arg`5B0`5D, XtNiconPixmap, big_pixmap);
X`09XtSetArg(arg`5B1`5D, XtNiconifyPixmap, small_pixmap);
X`09XtSetValues(whichWidget, arg, 2);
X    `7D
X    xmSetIconAndName(InitIcon);
X    if (app_resources.iconGeometry != NIL(char)) `7B
X`09int scr, x, y, junk;
X`09Arg args`5B2`5D;
X
X`09for(scr = 0;`09/* yyuucchh */
X`09    XtScreen(TopLevel) != ScreenOfDisplay(XtDisplay(TopLevel), scr);
X`09    scr++);
X
X`09    XGeometry(XtDisplay(TopLevel), scr, app_resources.iconGeometry,
X`09`09  "", 0, 0, 0, 0, 0, &x, &y, &junk, &junk);
X`09    XtSetArg(args`5B0`5D, XtNiconX, x);
X`09    XtSetArg(args`5B1`5D, XtNiconY, y);
X`09    XtSetValues(whichWidget, args, XtNumber(args));
X    `7D
X    return;
X`7D
X
X
Xstatic Boolean grabbed = False;
Xstatic Widget grabWidget = (Widget) 0;
X#ifndef USE_DEC_CURSOR
X/*`20
X * create the normal and busy xrn cursors
X */
X
Xvoid
XbusyCursor()
X`7B
X    static Cursor BusyCursor = (Cursor) 0;
X    Arg args`5B2`5D;
X   `20
X    /* define an appropriate busy cursor */
X    if (BusyCursor == (Cursor) 0) `7B
X`09XColor colors`5B2`5D;
X
X`09colors`5B0`5D.pixel = app_resources.pointer_foreground;
X`09colors`5B1`5D.pixel = app_resources.pointer_background;
X`09XQueryColors(XtDisplay(TopLevel),
X`09`09     DefaultColormap(XtDisplay(TopLevel),
X`09`09`09`09     DefaultScreen(XtDisplay(TopLevel))),
X`09`09     colors, 2);
X`09BusyCursor = XCreateFontCursor(XtDisplay(TopLevel), XC_watch);
X`09XRecolorCursor(XtDisplay(TopLevel), BusyCursor,
X`09`09       &colors`5B0`5D, &colors`5B1`5D);
X#ifdef MOTIF
X`09grabWidget = XtCreateWidget("grabWidget", xmPushButtonWidgetClass,
X`09`09`09`09    TopLevel, NULL, 0);
X#else
X`09grabWidget = DwtPushButtonCreate(TopLevel, "grabWidget", NULL, 0);
X#endif
X    `7D
X    XDefineCursor(XtDisplay(TopLevel), XtWindow(TopLevel), BusyCursor);
X    XDefineCursor(XtDisplay(TopLevel), XtWindow(TopList), BusyCursor);
X    if (app_resources.twoWindows && XtIsRealized(ArtTopLevel)) `7B
X`09XDefineCursor(XtDisplay(TopLevel), XtWindow(ArticleText), BusyCursor);
X    `7D
X    if (ComposeTopLevel != (Widget) 0) `7B
X`09XDefineCursor(XtDisplay(ComposeTopLevel),
X`09`09XtWindow(ComposeTopLevel), BusyCursor);
X`09XDefineCursor(XtDisplay(ComposeText),
X`09`09XtWindow(ComposeText), BusyCursor);
X`09XDefineCursor(XtDisplay(HeaderText),
X`09`09XtWindow(HeaderText), BusyCursor);
X    `7D
X    if (!grabbed) `7B
X`09XtAddGrab(grabWidget, True, False);
X`09grabbed = True;
X    `7D
X    if (app_resources.busyIcon) `7B
X`09if (WhichWM == DEC_WM) `7B
X`09    XtSetArg(args`5B0`5D, XtNiconPixmap, big_i_pixmap);
X`09    XtSetArg(args`5B1`5D, XtNiconifyPixmap, small_i_pixmap);
X`09    XtSetValues(TopLevel, args, 2);
X`09    if (ComposeTopLevel != (Widget) 0)
X`09`09XtSetValues(ComposeTopLevel, args, 2);
X`09`7D else `7B
X`09    XtSetArg(args`5B0`5D, XtNiconPixmap, icon_i_pixmap);
X`09    XtSetValues(TopLevel, args, 1);
X`09    if (ComposeTopLevel != (Widget) 0)
X`09`09XtSetValues(ComposeTopLevel, args, 1);
X`09`7D
X    `7D
X    XFlush(XtDisplay(TopLevel));
X   `20
X    return;
X`7D
X#else /* USE_DEC_CURSOR */
X/*`20
X * create the normal and busy xrn cursors
X */
X
Xvoid
XbusyCursor()
X`7B
X    static Cursor BusyCursor = (Cursor) 0;
X    static Font cursorFont;
X    static XColor colors`5B2`5D;
X    Arg args`5B2`5D;
X
X    /* define an appropriate busy cursor */
X    if (BusyCursor == (Cursor) 0) `7B
X`09colors`5B0`5D.pixel = app_resources.pointer_foreground;
X`09colors`5B1`5D.pixel = app_resources.pointer_background;
X`09XQueryColors(XtDisplay(TopLevel),
X`09`09     DefaultColormap(XtDisplay(TopLevel),
X`09`09`09`09     DefaultScreen(XtDisplay(TopLevel))),
X`09`09     colors, 2);
X`09cursorFont = XLoadFont(XtDisplay(TopLevel), "decw$cursor");
X`09BusyCursor = XCreateGlyphCursor(XtDisplay(TopLevel),
X`09`09`09cursorFont, cursorFont,
X`09`09`09decw$c_wait_cursor, decw$c_wait_cursor+1,
X`09`09`09&colors`5B0`5D, &colors`5B1`5D);
X#ifdef MOTIF
X`09grabWidget = XtCreateWidget("grabWidget", xmPushButtonWidgetClass,
X`09`09`09`09    TopLevel, NULL, 0);
X#else
X`09grabWidget = DwtPushButtonCreate(TopLevel, "grabWidget", NULL, 0);
X#endif
X    `7D
X    XDefineCursor(XtDisplay(TopLevel), XtWindow(TopLevel), BusyCursor);
X    XDefineCursor(XtDisplay(TopLevel), XtWindow(TopList), BusyCursor);
X    if (app_resources.twoWindows && XtIsRealized(ArtTopLevel)) `7B
X`09XDefineCursor(XtDisplay(TopLevel), XtWindow(ArticleText), BusyCursor);
X    `7D
X    if (ComposeTopLevel != (Widget) 0) `7B
X`09XDefineCursor(XtDisplay(ComposeTopLevel),
X`09`09XtWindow(ComposeTopLevel), BusyCursor);
X`09XDefineCursor(XtDisplay(ComposeText),
X`09`09XtWindow(ComposeText), BusyCursor);
X`09XDefineCursor(XtDisplay(HeaderText),
X`09`09XtWindow(HeaderText), BusyCursor);
X    `7D
X    if (!grabbed) `7B
X`09XtAddGrab(grabWidget, True, False);
X`09grabbed = True;
X    `7D
X    if (app_resources.busyIcon) `7B
X`09if (WhichWM == DEC_WM) `7B
X`09    XtSetArg(args`5B0`5D, XtNiconPixmap, big_i_pixmap);
X`09    XtSetArg(args`5B1`5D, XtNiconifyPixmap, small_i_pixmap);
X`09    XtSetValues(TopLevel, args, 2);
X`09    if (ComposeTopLevel != (Widget) 0)
X`09`09XtSetValues(ComposeTopLevel, args, 2);
X`09`7D else `7B
X`09    XtSetArg(args`5B0`5D, XtNiconPixmap, icon_i_pixmap);
X`09    XtSetValues(TopLevel, args, 1);
X`09    if (ComposeTopLevel != (Widget) 0)
X`09`09XtSetValues(ComposeTopLevel, args, 1);
X`09`7D
X    `7D
X    XFlush(XtDisplay(TopLevel));
X   `20
X    return;
X`7D
X#endif
X
Xvoid
XunbusyCursor()
X`7B
X    Arg args`5B2`5D;
X    XUndefineCursor(XtDisplay(TopLevel), XtWindow(TopLevel));
X    XUndefineCursor(XtDisplay(TopLevel), XtWindow(TopList));
X    if (app_resources.twoWindows && XtIsRealized(ArtTopLevel)) `7B
X`09XUndefineCursor(XtDisplay(TopLevel), XtWindow(ArticleText));
X    `7D
X    if (ComposeTopLevel != (Widget) 0) `7B
X`09XUndefineCursor(XtDisplay(ComposeTopLevel), XtWindow(ComposeTopLevel));
X`09XUndefineCursor(XtDisplay(ComposeText), XtWindow(ComposeText));
X`09XUndefineCursor(XtDisplay(HeaderText), XtWindow(HeaderText));
X    `7D
X    if (grabbed) `7B
X`09XtRemoveGrab(grabWidget);
X    `7D
X    grabbed = False;
X    if (app_resources.busyIcon) `7B
X`09if (WhichWM == DEC_WM) `7B
X`09    XtSetArg(args`5B0`5D, XtNiconPixmap, big_pixmap);
X`09    XtSetArg(args`5B1`5D, XtNiconifyPixmap, small_pixmap);
X`09    XtSetValues(TopLevel, args, 2);
X`09    if (ComposeTopLevel != (Widget) 0)
X`09`09XtSetValues(ComposeTopLevel, args, 2);
X`09`7D else `7B
X`09    XtSetArg(args`5B0`5D, XtNiconPixmap, icon_pixmap);
X`09    XtSetValues(TopLevel, args, 1);
X`09    if (ComposeTopLevel != (Widget) 0)
X`09`09XtSetValues(ComposeTopLevel, args, 1);
X`09`7D
X    `7D
X    XFlush(XtDisplay(TopLevel));
X   `20
X    return;
X`7D
X
X/*ARGSUSED*/
Xvoid
XCBbusyCursor(widget, client_data, call_data)
XWidget widget;
Xcaddr_t client_data;
Xcaddr_t call_data;
X`7B
X    busyCursor();
X    return;
X`7D
X
X
X/*ARGSUSED*/
Xvoid
XCBunbusyCursor(widget, client_data, call_data)
XWidget widget;
Xcaddr_t client_data;
Xcaddr_t call_data;
X`7B
X    unbusyCursor();
X    return;
X`7D
X
X/*`20
X * find out the number of lines in the article display
X */
X
Xint
XarticleLines()
X`7B
X    Dimension height = 0;
X    Arg arg`5B1`5D;
X
X#ifdef MOTIF
X    XtSetArg(arg`5B0`5D, XmNrows, &height);
X#else
X    XtSetArg(arg`5B0`5D, DwtNrows, &height);
X#endif
X    XtGetValues(ArticleText, arg, 1);
X    if (height < 1 `7C`7C height > 60) height = 60;
X    return(height);
X`7D
X/*
X * the following hack allows X11R3 stuff (XUI) to build
X * on systems with X11R4 header files (MOTIF).
X * Brought to you because XUI apps won't build on systems
X * with MOTIF installed otherwise.
X */
X
X#ifndef MOTIF
X#ifndef XtWindowOfObject
X#include <X11/IntrinsicP.h>
X#include <X11/CoreP.h>
XWindow XtWindowOfObject(object)
XWidget object;
X`7B
X    return object->core.window;
X`7D
X#endif /* XtWindowOfObject */
X#endif /* MOTIF */
X
X#if defined(MOTIF)
X
X/*
X * Function to wrap the text in a text widget (insert proper hard returns)
X */
X
Xchar *
XxmWrapTextWidget(tw)
XWidget tw;
X`7B
X#if !defined(MOTIF_V10)
Xchar`09`09*oldtextPtr,
X`09`09*newtextPtr;
XCardinal`09numlines,
X`09`09maxnewlines,
X`09`09numnewlinesinserted=0,
X`09`09line,
X`09`09numchars,
X`09`09newlen=0,
X`09`09oldlen;
XXmTextPosition`09startpos = 0,
X`09`09nextstartpos,
X`09`09oldtoppos,
X`09`09newtoppos;
Xlong      `09byte_count, cvt_status;
XXmTextWidget`09textwidget = (XmTextWidget) tw;
X#ifdef VMS
XOutputData`09outData;
X#endif
X
X/*
X** The following contstant is defined in Xm/TextOutP.h
X** Note: this is the unsigned int equivalent of -1
X*/
X#define XRNPASTENDPOS 2147483647
X
X    /* If wordwrap off, just bail out */
X#ifndef VMS
X    if (!_XmTextShouldWordWrap(textwidget))
X`09return (XmTextGetString((Widget)textwidget));
X#else
X    outData = ((XmTextRec *)textwidget)->text.output->data;
X    if ((!outData->wordwrap) `7C`7C outData->scrollhorizontal)
X`09return (XmTextGetString(tw));
X#endif
X
X    /* turn off text widget display or SetTopCharacter calls will scroll */
X    _XmTextDisableRedisplay(textwidget,False);
X
X    /* get original text string */
X    oldtextPtr = XmTextGetString(tw);
X
X    /* get number of lines in the line number table - one windowfull */
X    numlines = _XmTextNumLines(textwidget);
X
X    /* get position of top line so we can put it back at the end */
X    oldtoppos = XmTextGetTopCharacter(tw);
X
X    /*
X     ** No way to get total # of lines, so make initial allocation at 3 page
Vs.
X     ** Realloc if we run out of room
X     */
X    maxnewlines = numlines * 3;
X    oldlen = strlen(oldtextPtr);
X    newtextPtr = XtMalloc(oldlen + maxnewlines);
X    newtextPtr`5B0`5D = '\0';
X
X    /* set top position to very beginning */
X    XmTextSetTopCharacter(tw, 0);
X
X    /* get line info for first line */
X    _XmTextLineInfo(textwidget,0,&startpos,NULL);
X`09
X    /* do until no more lines */
X    do `7B
X`09/* for each window full */
X`09for (line=1;line<=numlines;line++) `7B
X`09    /*
X`09     * Skip this for the last line of the window,
X`09     * unless it's the only line
X`09     */
X`09    if ((line < numlines) `7C`7C (numlines == 1)) `7B
X`09`09_XmTextLineInfo(textwidget,line,&nextstartpos,NULL);
X`09`09/* if no more lines, break */
X`09`09if (nextstartpos == XRNPASTENDPOS) `7B
X`09`09    break;
X`09`09`7D else `7B
X`09`09    /*
X`09`09     * append line to new buffer - if soft wrapped, add a`20
X`09`09     * NEWLINE
X`09`09    */
X`09`09    numchars = nextstartpos-startpos;
X`09`09    memcpy(&newtextPtr`5Bnewlen`5D, &oldtextPtr`5Bstartpos`5D,`20
X`09`09`09   numchars);
X`09`09    newlen += numchars;
X`09`09    if (oldtextPtr`5Bnextstartpos-1`5D != '\n') `7B
X`09`09`09newtextPtr`5Bnewlen`5D = '\n';
X`09`09`09newlen++;
X`09`09`09numnewlinesinserted++;
X`09`09    `7D;
X`09`09    startpos = nextstartpos;
X`09`09`7D;
X`09    `7D;
X`09`7D;
X`09/* if not out of lines yet ... */
X`09if (nextstartpos != XRNPASTENDPOS) `7B
X`09    /*
X`09     * position to next windowfull -
X`09     * forces text widget to format lines
X`09     */
X`09    XmTextScroll(tw,numlines-1);
X`09    numlines = _XmTextNumLines(textwidget);
X`09    /* if need more memory, get it */
X`09    if (numnewlinesinserted + numlines > maxnewlines) `7B
X`09`09maxnewlines = numnewlinesinserted * 2;`09/* double it */
X`09`09newtextPtr = XtRealloc(newtextPtr, oldlen+maxnewlines);
X`09    `7D;
X`09`7D;
X    `7D while (nextstartpos != XRNPASTENDPOS);
X
X    /* append the last line */
X    numchars = strlen(&oldtextPtr`5Bstartpos`5D);
X    if (numchars > 0) `7B
X`09memcpy(&newtextPtr`5Bnewlen`5D, &oldtextPtr`5Bstartpos`5D, numchars);
X`09newlen += numchars;
X    `7D;
X
X    /* NULL terminate the string */
X    newtextPtr`5Bnewlen`5D = '\0';
X
X    /* reset the top position and turn the display back on */
X    XmTextSetTopCharacter(tw, oldtoppos);
X    _XmTextEnableRedisplay(textwidget);
X
X    XtFree(oldtextPtr);
X    return(newtextPtr);
X
X#else /* MOTIF_V10 */
X    return(XmTextGetString(tw));
X#endif /* MOTIF_V10 */
X`7D
X#endif /* MOTIF */
$ CALL UNPACK XMISC.C;72 1329665766
$ create 'f'
X#ifndef XMISC_H
X#define XMISC_H
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/xmisc.h,v 1.5 1993/0
V1/11 02:15:47 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * xmisc.h: routines for handling miscellaneous x functions
X *
X */
X
X/* create the icon and the handlers for it */
Xextern void xmIconCreate();
X
X/* set icon name and pixmap */
Xtypedef enum `7BInitIcon, ReadIcon, UnreadIcon, BusyIcon, NewGroupsIcon,
X`09      LostIcon, PrevIcon`7D IconType;
Xextern void xmSetIconAndName _ARGUMENTS((IconType));
X
Xextern void unbusyCursor();
Xextern void busyCursor();
X
X/* suitable for call back use */
Xextern void CBunbusyCursor _ARGUMENTS((Widget, caddr_t, caddr_t));
Xextern void CBbusyCursor _ARGUMENTS((Widget, caddr_t, caddr_t));
X
X/* find out the number of lines in the article display */
Xextern int articleLines();
X
X/* Word wrap a motif widget */
X#if defined(MOTIF)
Xextern char * xmWrapTextWidget _ARGUMENTS((Widget));
X#endif
X
X#endif /* XMISC_H */
$ CALL UNPACK XMISC.H;17 877553924
$ create 'f'
X#if !defined(lint) && !defined(SABER)
Xstatic char XRNrcsid`5B`5D = "$Header: /net/objy27/wrld/mnt11/ricks/src/mast
Ver/xrn/xrn.c,v 1.7 1993/02/04 18:22:42 ricks Exp $";
X#endif
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * xrn.c: set up the main screens
X *
X */
X
X#include "copyright.h"
X#include "config.h"
X#include <stdio.h>
X#include "utils.h"
X#ifndef VMS
X#include <X11/Intrinsic.h>
X#include <X11/Xutil.h>
X#include <X11/StringDefs.h>
X#include <X11/Xatom.h>
X#include <X11/Shell.h>
X#else
X#include <decw$include/Intrinsic.h>
X#include <decw$include/Xutil.h>
X#include <decw$include/StringDefs.h>
X#include <decw$include/Xatom.h>
X#include <decw$include/Shell.h>
X#endif
X#ifdef MOTIF
X#include <Xm/Xm.h>
X#include <Xm/MainW.h>
X#include <Xm/PanedW.h>
X#include <Xm/Label.h>
X#include <Xm/TextP.h>
X#include <Xm/RowColumn.h>
X#include <Xm/Frame.h>
X#include <Xm/ScrolledW.h>
X#if (XmVERSION == 1) && (XmREVISION == 0)
X#define MOTIF_V10
X#endif
X#else
X#ifndef VMS
X#include <X11/DECwDwtWidgetProg.h>
X#include "Pane.h"
X#else
X#include <decw$include/DECwDwtWidgetProg.h>
X#include "Pane.h"
X#endif`09/* VMS */
X#endif`09/* MOTIF */
X
X#include "slist.h"
X#include "xthelper.h"
X#include "xmisc.h"
X#include "resources.h"
X#include "news.h"
X#include "internals.h"
X#include "error_hnds.h"
X#include "buttons.h"
X#include "xrn.h"
X
X#ifdef __STDC__
X#include <stdlib.h>
X#endif
X
Xvoid PaneSetMinMax();
X
X#ifndef MOTIF
X#ifndef DwtNmenuExtendLastRow
X#define DwtNmenuExtendLastRow "menuExtendLastRow"
X#endif
X#endif
X
X#ifdef XFILESEARCHPATH
Xstatic void AddPathToSearchPath();
X#endif
X
Xextern void makeMenus();
Xextern void makeArtArtMenus();
Xextern void makePopup();
Xextern void makeArtPopup();
X
X
X/* global variables that represent the widgets that are dynamically changed
V */
X
XWidget TopLevel;
XWidget MainWindow;`09/* Main Window`09`09`09`09     */
XWidget ArtTopLevel;`09/* Article Shell       `09`09`09     */
XWidget ArtMainWindow;`09/* Article Window`09`09`09     */
XWidget ArtWindow;`09/* Article pane`09`09`09`09     */
XWidget Frame;`09`09/* Pane widget `09`09`09`09     */
XWidget TopButtonBox;`09/* button box containing the command buttons */
XWidget BottomButtonBox;`09/* button box containing the article buttons */
XWidget TopInfoLine;`09/* top button info line                      */
XWidget BottomInfoLine;`09/* bottom button info line                   */
XWidget TopList;`09`09/* newsgroup and article subject display     */
XWidget ScrollWindow;`09/* Scrolled window for top list`09`09     */
XWidget ArticleText;`09/* article display                           */
XWidget PopupMenu;`09/* the popup menus `09`09`09     */
XWidget MenuBar;`09`09/* the menu bar`09`09`09`09     */
XWidget ArtMenuBar;`09/* the menu bar`09`09`09`09     */
X#ifdef MOTIF
XWidget TopShadowFrame;`09/* Frame around list Widget`09`09     */
XWidget BotShadowFrame;`09/* Frame around text Widget`09`09     */
X#endif
X#ifdef TITLEBAR
XWidget TitleBar;`09/* The titlebar`09`09`09`09     */
X#endif
Xint XRNState;`09`09/* XRN status: news and x                    */
Xstatic Boolean oneTime = True;`09/* Set true if resize tried`09     */
X
Xstatic Arg frameArgs`5B`5D = `7B`09`09`09/* main window description */
X`09`09`09`09`09`09/* args set from geometry and */
X`09`7BXtNx,`09`09`09(XtArgVal) 10`7D,`09/* must stay in x/y/w/h order */
X`09`7BXtNy, `09`09`09(XtArgVal) 10`7D,
X#ifdef MOTIF
X`09`7BXtNwidth, `09`09(XtArgVal) 10`7D,
X`09`7BXtNheight, `09`09(XtArgVal) 10`7D,
X#else
X`09`7BDwtNwidth,`09`09(XtArgVal) 600`7D,
X`09`7BDwtNheight,`09`09(XtArgVal) 700`7D,
X#endif
X`7D;
X
X/*ARGSUSED*/
Xmain(argc, argv)
Xint argc;
Xchar **argv;
X`7B
X    int i;
X    Arg resizeArg`5B3`5D;
X    Dimension width, height, borderWidth;
X    extern char title`5B`5D;
X    static Arg fontArgs`5B2`5D;
X    static Arg labelArgs`5B1`5D;
X    static Dimension fontHeight, fontWidth, listHeight;
X    static Dimension paneHeight = 0, paneWidth;
X#ifdef MOTIF
X    static XmString labelString;
X#else
X    static DwtCompString labelString;
X#endif
X
X#ifndef MOTIF
X    static Arg mainArgs`5B`5D = `7B
X`09`7BDwtNacceptFocus,`09(XtArgVal) True`7D,
X`09`7BXtNsensitive,`09`09(XtArgVal) True`7D,
X    `7D;
X#endif
X    static Arg infoArgs`5B`5D = `7B
X`09`7BXtNheight,`09`09(XtArgVal) 40`7D,
X    `7D;
X#ifndef MOTIF
X    static Arg menuArgs`5B`5D = `7B
X`09`7BDwtNx,`09`09    0`7D,
X`09`7BDwtNy,`09`09    0`7D,
X`09`7BDwtNspacing,`09    20`7D,
X`09`7BDwtNorientation,   DwtOrientationHorizontal`7D,
X    `7D;
X#endif
X
X    static Arg topBoxArgs`5B`5D = `7B
X#ifdef MOTIF
X`09`7BXmNresizeHeight,`09(XtArgVal) True`7D,
X`09`7BXmNresizeWidth,`09(XtArgVal) False`7D,
X`09`7BXmNnumColumns,`09`09(XtArgVal) 3`7D,
X`09`7BXmNadjustLast,`09`09(XtArgVal) False`7D,
X`09`7BXmNorientation, `09(XtArgVal) XmHORIZONTAL`7D,
X`09`7BXmNpacking,`09`09(XtArgVal) XmPACK_TIGHT`7D,
X`09`7BXmNheight,`09`09(XtArgVal) 80`7D,
X#else
X`09`7BDwtNorientation, `09(XtArgVal) DwtOrientationHorizontal`7D,
X`09`7BDwtNmenuPacking,`09(XtArgVal) DwtMenuPackingTight`7D,
X`09`7BDwtNmenuNumColumns,`09(XtArgVal) 4`7D,
X`09`7BDwtNmenuExtendLastRow, (XtArgVal) False`7D,
X`09`7BDwtNborderWidth,`09(XtArgVal) 3`7D,
X`09`7BDwtNentryBorder,`09(XtArgVal) 2`7D,
X`09`7BDwtNspacing,`09`09(XtArgVal) 2`7D,
X`09`7BDwtNchildOverlap,`09(XtArgVal) False`7D,
X#endif
X    `7D;
X    static Arg bottomBoxArgs`5B`5D = `7B
X#ifdef MOTIF
X`09`7BXmNresizeHeight,`09(XtArgVal) False`7D,
X`09`7BXmNresizeWidth,`09(XtArgVal) True`7D,
X`09`7BXmNadjustLast,`09`09(XtArgVal) False`7D,
X`09`7BXmNorientation, `09(XtArgVal) XmHORIZONTAL`7D,
X`09`7BXmNpacking,`09`09(XtArgVal) XmPACK_TIGHT`7D,
X#else
X`09`7BDwtNorientation, `09(XtArgVal) DwtOrientationHorizontal`7D,
X`09`7BDwtNmenuPacking,`09(XtArgVal) DwtMenuPackingTight`7D,
X`09`7BDwtNmenuExtendLastRow, (XtArgVal) False`7D,
X`09`7BDwtNborderWidth,`09(XtArgVal) 3`7D,
X`09`7BDwtNentryBorder,`09(XtArgVal) 2`7D,
X`09`7BDwtNspacing,`09`09(XtArgVal) 2`7D,
X`09`7BDwtNchildOverlap,`09(XtArgVal) False`7D,
X`09`7BDwtNmenuNumColumns,`09(XtArgVal) 1`7D,
X#endif
X   `7D;
X    static Arg listArgs`5B`5D = `7B`09`09`09/* newsgroup/subject list window
V */
X`09`7BSListNrows, `09`09(XtArgVal) 10`7D,
X`09`7BSListNcols,`09`09(XtArgVal) 83`7D,
X    `7D;
X#ifdef MOTIF
X    Arg articleTextArgs`5B10`5D;
X#else
X    static Arg articleTextArgs`5B`5D = `7B`09`09/* article/all text window *
V/
X`09`7BDwtNrows,`09`09(XtArgVal) 24`7D,
X`09`7BDwtNcols,`09`09(XtArgVal) 80`7D,
X`09`7BDwtNwordWrap, `09`09(XtArgVal) TRUE`7D,
X`09`7BDwtNscrollVertical,`09(XtArgVal) TRUE`7D,
X`09`7BDwtNeditable,`09`09(XtArgVal) FALSE`7D,
X    `7D;
X#endif
X
X#ifdef MOTIF
X    static Arg scrollWinArgs`5B`5D = `7B
X`09`7BXmNscrollBarDisplayPolicy,`09(XtArgVal) XmSTATIC`7D,
X`09`7BXmNscrollBarPlacement,`09`09(XtArgVal) XmBOTTOM_RIGHT`7D,
X`09`7BXmNscrollingPolicy,`09`09(XtArgVal) XmAPPLICATION_DEFINED`7D,
X    `7D;
X#else
X    static Arg scrollWinArgs`5B`5D = `7B
X`09`7BDwtNshownValueAutomaticVert,`09(XtArgVal) False`7D,
X`09`7BDwtNshownValueAutomaticHoriz,`09(XtArgVal) False`7D,
X    `7D;
X#endif
X
X    static Arg artTopArgs`5B`5D = `7B
X`09`7BXtNinput,`09`09`09(XtArgVal) True`7D,
X`09`7BXtNallowShellResize,`09`09(XtArgVal) True`7D,
X#ifdef MOTIF
X`09`7BXmNiconName,`09`09`09(XtArgVal) "mxrn article"`7D,
X`09`7BXmNtitle,`09`09`09(XtArgVal) "mxrn Article Text"`7D,
X`09`7BXmNtransient,`09`09`09(XtArgVal) False`7D,
X`09`7BXmNdeleteResponse,`09`09(XtArgVal) XmUNMAP`7D,
X#else
X#ifndef DwtNiconName
X#define DwtNiconName "iconName"
X#endif
X`09`7BDwtNiconName,`09`09`09(XtArgVal) "dxrn article"`7D,
X`09`7BDwtNtitle,`09`09`09(XtArgVal) "dxrn Article Text"`7D,
X#endif
X    `7D;
X
X    static Arg shellArgs`5B`5D = `7B
X`09`7BXtNallowShellResize,`09`09(XtArgVal) True`7D,
X    `7D;
X
X    XRNState = 0;
X
X#ifdef XFILESEARCHPATH
X    AddPathToSearchPath(XFILESEARCHPATH);
X#endif
X   `20
X    TopLevel = XrnInitialize(argc, argv);
X   `20
X    ehInstallSignalHandlers();
X    ehInstallErrorHandlers();
X#ifdef DEBUG
X    XSynchronize(XtDisplay(TopLevel), True);
X#endif
X
X    if (app_resources.twoWindows) `7B
X`09if (app_resources.indexLayout) `7B
X`09    xthTranslateGeometry(app_resources.indexLayout, frameArgs);
X`09    XtSetValues(TopLevel, frameArgs, XtNumber(frameArgs));
X`09`7D
X    `7D else `7B
X`09if (app_resources.mainLayout) `7B
X`09    xthTranslateGeometry(app_resources.mainLayout, frameArgs);
X`09    XtSetValues(TopLevel, frameArgs, XtNumber(frameArgs));
X`09`7D
X    `7D
X   `20
X    if (app_resources.twoWindows) `7B
X`09XtSetValues(TopLevel, shellArgs, XtNumber(shellArgs));
X    `7D
X#ifdef MOTIF
X    MainWindow = XmCreateMainWindow(TopLevel, "main", NULL, 0);
X#else
X    MainWindow = DwtMainWindowCreate(TopLevel, "main",
X`09`09`09`09`09mainArgs, XtNumber(mainArgs));
X#endif
X    XtManageChild(MainWindow);
X
X    if (app_resources.twoWindows) `7B
X`09ArtTopLevel = XtCreatePopupShell("articleView",
X`09`09`09topLevelShellWidgetClass, TopLevel,
X`09`09`09artTopArgs, XtNumber(artTopArgs));
X`09if (app_resources.artLayout) `7B
X`09    xthTranslateGeometry(app_resources.artLayout, frameArgs);
X`09    XtSetValues(ArtTopLevel, frameArgs, XtNumber(frameArgs));
X`09`7D
X#ifdef MOTIF
X`09ArtMainWindow = XmCreateMainWindow(ArtTopLevel, "article", NULL, 0);
X`09XtManageChild(ArtMainWindow);
X`09ArtWindow = XtCreateManagedWidget("artpane", xmPanedWindowWidgetClass,
X`09`09`09ArtMainWindow, NULL, 0);
X#else
X`09ArtMainWindow = DwtMainWindowCreate(ArtTopLevel, "article", NULL, 0);
X`09XtManageChild(ArtMainWindow);
X`09ArtWindow = DwtPaneCreate(ArtMainWindow, "artpane", NULL, 0);
X`09XtManageChild(ArtWindow);
X`09DwtPaneAllowResizing(ArtWindow, DwtResizeShrinkWrap);
X#endif
X    `7D
X    /* create the pane and its widgets */
X   `20
X#ifdef MOTIF
X    Frame = XtCreateManagedWidget("vpane", xmPanedWindowWidgetClass, MainWin
Vdow,
X`09`09`09`09  frameArgs, XtNumber(frameArgs));
X#else
X    Frame = (Widget) DwtPaneCreate(MainWindow, "vpane", frameArgs,
X`09`09`09`09`09XtNumber(frameArgs));
X    XtManageChild(Frame);
X    DwtPaneAllowResizing(Frame, DwtResizeShrinkWrap);
X#endif
X   `20
X#ifdef MOTIF
X    MenuBar = XmCreateMenuBar(MainWindow,"MenuBar", NULL, 0);
X    XtManageChild(MenuBar);
X    makeMenus();
X    XmMainWindowSetAreas(MainWindow, MenuBar, NULL, NULL, NULL, Frame);
X    if (app_resources.twoWindows) `7B
X`09ArtMenuBar = XmCreateMenuBar(ArtMainWindow,"MenuBar", NULL, 0);
X`09XtManageChild(ArtMenuBar);
X`09makeArtArtMenus(ArtMenuBar);
X`09XmMainWindowSetAreas(ArtMainWindow, ArtMenuBar, NULL, NULL, NULL,
X`09`09`09`09ArtWindow);
X    `7D
X#else
X    MenuBar = DwtMenuBarCreate(MainWindow, "MenuBar",
X`09menuArgs, XtNumber(menuArgs));
X    XtManageChild(MenuBar);
X    makeMenus();
X    DwtMainSetAreas(MainWindow, MenuBar, Frame, NULL, NULL, NULL);
X    if (app_resources.twoWindows) `7B
X`09ArtMenuBar = DwtMenuBarCreate(ArtMainWindow, "MenuBar",
X`09`09menuArgs, XtNumber(menuArgs));
X`09XtManageChild(ArtMenuBar);
X`09makeArtArtMenus(ArtMenuBar);
X`09DwtMainSetAreas(ArtMainWindow, ArtMenuBar, ArtWindow, NULL, NULL, NULL);
X    `7D
X#endif
X
X#ifdef TITLEBAR
X#ifdef MOTIF
X    labelString = XmStringLtoRCreate(title, XmSTRING_DEFAULT_CHARSET);
X    XtSetArg(labelArgs`5B0`5D, XmNlabelString, labelString);
X    TitleBar = XtCreateManagedWidget("titlebar", xmLabelWidgetClass, Frame,
X`09`09`09`09     labelArgs, XtNumber(labelArgs));
X    XmStringFree(labelString);
X    XtSetArg(fontArgs`5B0`5D, XmNheight, &fontHeight);
X    XtGetValues(TitleBar, fontArgs, 1);
X    PaneSetMinMax(TitleBar, fontHeight, fontHeight);
X    paneHeight = fontHeight * 6;
X#else /* MOTIF */
X    labelString = DwtLatin1String(title);
X    XtSetArg(labelArgs`5B0`5D, DwtNlabel, labelString);
X    TitleBar = DwtLabelCreate(Frame, "titlebar",`20
X`09`09`09`09     labelArgs, XtNumber(labelArgs));
X    XtFree(labelString);
X    XtManageChild(TitleBar);
X    XtSetArg(fontArgs`5B0`5D, DwtNheight, &fontHeight);
X    XtGetValues(TitleBar, fontArgs, 1);
X    PaneSetMinMax(TitleBar, fontHeight, fontHeight);
X    paneHeight = fontHeight * 6;
X#endif /* MOTIF */
X#endif /* TITLEBAR */
X
X    listArgs`5B0`5D.value = (XtArgVal) app_resources.topLines;
X#ifdef MOTIF
X    TopShadowFrame = XtCreateManagedWidget("topFrame", xmFrameWidgetClass,
X`09`09`09`09`09   Frame, NULL, 0);
X    ScrollWindow = (Widget) XtCreateManagedWidget("topScroll",
X`09`09xmScrolledWindowWidgetClass, TopShadowFrame,
X`09`09scrollWinArgs, XtNumber(scrollWinArgs));
X#else
X    ScrollWindow = (Widget) DwtScrollWindowCreate(Frame, "topScroll",
X`09`09`09    scrollWinArgs, XtNumber(scrollWinArgs));
X    XtManageChild(ScrollWindow);
X#endif
X    TopList = SListCreate(ScrollWindow, "index", listArgs, XtNumber(listArgs
V));
X    XtManageChild(TopList);
X
X#ifdef MOTIF
X    fitFrameToContents(TopShadowFrame, TopList);
X    XtSetArg(fontArgs`5B0`5D, XmNheight, &listHeight);
X    XtSetArg(fontArgs`5B1`5D, XmNwidth,  &fontWidth);
X    XtGetValues(TopShadowFrame, fontArgs, 2);
X    PaneSetMinMax(TopShadowFrame, listHeight+2, listHeight+2);
X#else
X    XtSetArg(fontArgs`5B0`5D, DwtNheight, &listHeight);
X    XtSetArg(fontArgs`5B1`5D, DwtNwidth,  &fontWidth);
X    XtGetValues(TopList, fontArgs, 2);
X    PaneSetMinMax(ScrollWindow, listHeight, listHeight);
X#endif
X#ifdef TITLEBAR
X    paneHeight = paneHeight + listHeight + 6;
X    if (fontWidth > paneWidth)
X`09paneWidth = fontWidth;
X#else
X    paneHeight = listHeight + 6;
X#endif
X
X#ifdef MOTIF
X    TopInfoLine = XtCreateManagedWidget("indexinfo", xmLabelWidgetClass, Fra
Vme,
X`09`09`09`09`09infoArgs, XtNumber(infoArgs));
X
X#ifndef TITLEBAR
X    XtSetArg(fontArgs`5B0`5D, XmNheight, &fontHeight);
X    XtGetValues(TopInfoLine, fontArgs, 1);
X    fontHeight = fontHeight/2;
X#endif
X    PaneSetMinMax(TopInfoLine, fontHeight, fontHeight);
X
X    TopButtonBox = XtCreateManagedWidget("indexbuttons",
X`09`09`09`09`09  xmRowColumnWidgetClass, Frame,
X`09`09`09`09`09  topBoxArgs, XtNumber(topBoxArgs));
X    PaneSetMinMax(TopButtonBox, fontHeight*2, fontHeight*2);
X
X    /* article display text window */
X
X    if (app_resources.twoWindows) `7B
X        BotShadowFrame = XtCreateManagedWidget("botFrame", xmFrameWidgetClas
Vs,
X`09`09`09`09`09   ArtWindow, NULL, 0);
X    `7D else `7B
X        BotShadowFrame = XtCreateManagedWidget("botFrame", xmFrameWidgetClas
Vs,
X`09`09`09`09`09   Frame, NULL, 0);
X    `7D
X    i = 0;
X    XtSetArg(articleTextArgs`5Bi`5D, XmNrows, app_resources.textLines);i++;
X    XtSetArg(articleTextArgs`5Bi`5D, XmNcolumns, 83);i++;
X    XtSetArg(articleTextArgs`5Bi`5D, XmNeditMode, XmMULTI_LINE_EDIT); i++;
X    XtSetArg(articleTextArgs`5Bi`5D, XmNwordWrap, FALSE);i++;
X    XtSetArg(articleTextArgs`5Bi`5D, XmNscrollHorizontal,
X`09!app_resources.autoWrap);i++;
X    XtSetArg(articleTextArgs`5Bi`5D, XmNeditable, FALSE); i++;
X    XtSetArg(articleTextArgs`5Bi`5D, XmNcursorPositionVisible, FALSE); i++;
X    ArticleText = XmCreateScrolledText(BotShadowFrame, "text",`20
X`09articleTextArgs, i);
X    XtManageChild(ArticleText);
X    XtSetValues(ArticleText, articleTextArgs, i);
X
X    fitFrameToContents(BotShadowFrame, ArticleText);
X   `20
X    if (app_resources.twoWindows) `7B
X`09BottomInfoLine = XtCreateManagedWidget("textinfo", xmLabelWidgetClass,
X`09`09`09`09`09   ArtWindow, infoArgs,
X`09`09`09`09`09   XtNumber(infoArgs));
X    `7D else `7B
X`09BottomInfoLine = XtCreateManagedWidget("textinfo", xmLabelWidgetClass,
X`09`09`09`09`09   Frame, infoArgs, XtNumber(infoArgs));
X    `7D`20
X    PaneSetMinMax(BottomInfoLine, fontHeight, fontHeight);
X    if (app_resources.twoWindows) `7B
X`09BottomButtonBox = XtCreateManagedWidget("textbuttons",
X`09`09`09`09`09     xmRowColumnWidgetClass, ArtWindow,
X`09`09`09`09`09     bottomBoxArgs,
X`09`09`09`09`09     XtNumber(bottomBoxArgs));
X    `7D else `7B
X`09BottomButtonBox = XtCreateManagedWidget("textbuttons",
X`09`09`09`09`09     xmRowColumnWidgetClass, Frame,
X`09`09`09`09`09     bottomBoxArgs,
X`09`09`09`09`09     XtNumber(bottomBoxArgs));
X    `7D
X
X    XtSetArg(fontArgs`5B0`5D, XmNheight, &listHeight);
X    XtGetValues(BottomButtonBox, fontArgs, 1);
X    PaneSetMinMax(BottomButtonBox, listHeight, listHeight);
X#else
X    TopInfoLine = DwtLabelCreate(Frame, "indexinfo",`20
X`09`09`09`09`09infoArgs, XtNumber(infoArgs));
X
X    XtManageChild(TopInfoLine);
X#ifndef TITLEBAR
X    XtSetArg(fontArgs`5B0`5D, DwtNheight, &fontHeight);
X    XtGetValues(TopInfoLine, fontArgs, 1);
X    paneHeight = paneHeight + fontHeight * 3;
X    if (fontWidth > paneWidth)
X`09paneWidth = fontWidth;
X#endif
X    PaneSetMinMax(TopInfoLine, fontHeight, fontHeight);
X    TopButtonBox = DwtMenuBarCreate(Frame, "indexbuttons",
X`09`09`09`09`09  topBoxArgs, XtNumber(topBoxArgs));
X    XtSetArg(fontArgs`5B0`5D, DwtNheight, &listHeight);
X    XtGetValues(TopButtonBox, fontArgs, 1);
X    if (app_resources.twoWindows) `7B
X`09paneHeight = paneHeight + listHeight * 3; /* one button box, total 3 line
Vs*/
X    `7D else `7B
X`09paneHeight = paneHeight + listHeight * 5; /* two button boxes, total 5 li
Vnes*/
X    `7D
X    /* article display text window */
X
X    XtManageChild(TopButtonBox);
X    articleTextArgs`5B0`5D.value = app_resources.textLines;
X    if (app_resources.twoWindows) `7B
X`09ArticleText = DwtSTextCreate(ArtWindow, "text",
X`09`09articleTextArgs, XtNumber(articleTextArgs));
X    `7D else `7B
X`09ArticleText = DwtSTextCreate(Frame, "text",
X`09`09articleTextArgs, XtNumber(articleTextArgs));
X    `7D
X    XtSetValues(ArticleText, articleTextArgs, XtNumber(articleTextArgs));
X    XtManageChild(ArticleText);
X   `20
X    XtSetArg(fontArgs`5B0`5D, DwtNheight, &listHeight);
X    XtSetArg(fontArgs`5B1`5D, DwtNwidth,  &fontWidth);
X    XtGetValues(ArticleText, fontArgs, 2);
X    if (app_resources.twoWindows) `7B
X`09BottomInfoLine = DwtLabelCreate(ArtWindow, "textinfo",`20
X`09`09`09`09`09   infoArgs, XtNumber(infoArgs));
X    `7D else `7B
X`09paneHeight = paneHeight + listHeight;
X`09if (fontWidth > paneWidth)
X`09    paneWidth = fontWidth;
X`09BottomInfoLine = DwtLabelCreate(Frame, "textinfo",`20
X`09`09`09`09`09   infoArgs, XtNumber(infoArgs));
X    `7D
X    XtManageChild(BottomInfoLine);
X    PaneSetMinMax(BottomInfoLine, fontHeight, fontHeight);
X    if (app_resources.twoWindows) `7B
X`09BottomButtonBox = DwtMenuBarCreate(ArtWindow, "textbuttons",
X`09`09`09`09`09     bottomBoxArgs,
X`09`09`09`09`09     XtNumber(bottomBoxArgs));
X    `7D else `7B
X`09BottomButtonBox = DwtMenuBarCreate(Frame, "textbuttons",
X`09`09`09`09`09     bottomBoxArgs,
X`09`09`09`09`09     XtNumber(bottomBoxArgs));
X    `7D
X    XtManageChild(BottomButtonBox);
X    DwtPaneSetMinMax(BottomButtonBox, fontHeight, fontHeight);
X
X    paneWidth += 20;
X    paneHeight += 50;
X    if (paneHeight > 860) paneHeight = 860;
X    XtSetArg(fontArgs`5B0`5D, DwtNheight, paneHeight);
X    XtSetArg(fontArgs`5B1`5D, DwtNwidth,  paneWidth);
X    XtSetValues(Frame, fontArgs, 2);
X    XtSetValues(XtParent(Frame), fontArgs, 2);
X#endif
X
X    /* initialize the news system, read the newsrc file */
X    initializeNews();
X    XRNState `7C= XRN_NEWS_UP;
X
X    /* create the icon */
X    xmIconCreate(TopLevel);
X    if (app_resources.twoWindows)
X`09xmIconCreate(ArtTopLevel);
X    /*
X     * This next call doesn't do anything by default, unless you
X     * modify the application defaults file, because there are no
X     * accelerators for Text in it.  However, it makes it possible for
X     * users to add accelerators to their own resources, so that, for
X     * example, they can use the arrow keys to scroll through the
X     * index window rather than through the article text.  To do that,
X     * they would put the following in their resources:
X     *
X     * xrn*index.accelerators: #override \n\
X     * `09`09<Key>Down:`09next-line() \n\
X     * `09`09<Key>Up:`09previous-line()
X     */
X#ifdef notdef
X    XtInstallAccelerators(ArticleText, Text);
X#endif
X   `20
X#if defined(MOTIF) && defined(EDITRES) && XtSpecificationRelease == 5
X    /* Enable editres interaction (needs X11R5 Xmu; Xaw already has this) */
X    `7B
X`09extern void _XEditResCheckMessages();
X
X`09XtAddEventHandler(TopLevel, (EventMask)0, True,
X`09`09`09  _XEditResCheckMessages, NULL);
X    `7D
X#endif
X
X    XtRealizeWidget(TopLevel);
X    makePopup(Frame);
X    if (app_resources.twoWindows)
X`09makeArtPopup(ArtWindow);
X
X    XChangeProperty(XtDisplay(TopLevel), XtWindow(TopLevel),
X`09`09    XA_WM_NAME, XA_STRING, 8, PropModeReplace,
X`09`09`09(unsigned char *) title, strlen(title));
X
X#ifdef MOTIF
X    XChangeProperty(XtDisplay(TopLevel), XtWindow(TopLevel),
X`09`09    XA_WM_ICON_NAME, XA_STRING, 8, PropModeReplace,
X`09`09`09(unsigned char *) "mxrn", 4);
X#else
X    XChangeProperty(XtDisplay(TopLevel), XtWindow(TopLevel),
X`09`09    XA_WM_ICON_NAME, XA_STRING, 8, PropModeReplace,
X`09`09`09(unsigned char *) "dxrn", 4);
X#endif
X
X    /* set up the text window, mode buttons, and question */
X    determineMode();
X
X    unbusyCursor();
X    addTimeOut();
X    XRNState `7C= XRN_X_UP;
X
X#ifdef MOTIF_V10
X    XtSetArg(resizeArg`5B0`5D, XmNrefigureMode, False);
X    XtSetValues(XtParent(TopButtonBox), resizeArg, 1);
X    XtSetArg(resizeArg`5B0`5D, XmNrefigureMode, True);
X    XtSetValues(XtParent(TopButtonBox), resizeArg, 1);
X#endif
X
X    XtMainLoop();
X    exit(0);
X`7D      `20
X#ifdef MOTIF
Xstatic Boolean resetLimits(w)
XWidget w;
X`7B
X    Arg minmax`5B5`5D;
X    int i = 0;
X    if (w == BottomButtonBox `7C`7C w == BottomInfoLine) return True;
X#ifndef MOTIF_V10
X    XtSetArg(minmax`5Bi`5D, XmNpaneMinimum, 1);i++;
X    XtSetArg(minmax`5Bi`5D, XmNpaneMaximum, 5000);i++;
X    XtSetArg(minmax`5Bi`5D, XmNskipAdjust, False);i++;
X    XtSetArg(minmax`5Bi`5D, XmNallowResize, (XtArgVal) True);i++;
X    XtSetValues(w, minmax, i);
X#endif
X    return True;
X`7D
Xvoid PaneSetMinMax(w, min, max)
XWidget w;
XDimension min;
XDimension max;
X`7B
X    Arg minmax`5B5`5D;
X    int i = 0;
X#ifdef MOTIF_V10
X    if (max <= min) max = min + 1;
X    XtSetArg(minmax`5Bi`5D, XmNminimum, (XtArgVal) min);i++;
X    XtSetArg(minmax`5Bi`5D, XmNmaximum, (XtArgVal) max);i++;
X    XtSetArg(minmax`5Bi`5D, XmNskipAdjust, (XtArgVal) True);i++;
X#else
X    if (max <= min) max = min + 1;
X    XtSetArg(minmax`5Bi`5D, XmNpaneMinimum, (XtArgVal) min);i++;
X    XtSetArg(minmax`5Bi`5D, XmNpaneMaximum, (XtArgVal) max);i++;
X    XtSetArg(minmax`5Bi`5D, XmNskipAdjust, (XtArgVal) True);i++;
X#endif
X    XtSetArg(minmax`5Bi`5D, XmNheight,  (XtArgVal) min);i++;
X    XtSetValues(w, minmax, i);
X#ifndef MOTIF_V10
X    XtAddWorkProc((XtWorkProc)resetLimits, w);
X#endif
X`7D
Xstatic Boolean resetBox(height)
Xint height;
X`7B
X    Arg minmax`5B5`5D;
X    int i;
X    Dimension current = 0;
X    Dimension width = 0;
X    Dimension curHeight = 0;
X    Dimension borderWidth = 0;
X`20
X    XtSetArg(minmax`5B0`5D, XmNheight, &current);
X    XtSetArg(minmax`5B1`5D, XmNwidth, &width);
X    XtSetArg(minmax`5B2`5D, XmNborderWidth, &borderWidth);
X
X    XtGetValues(TopButtonBox, minmax, 1);
X    if (oneTime && current != height) `7B
X`09oneTime = False;
X`09XtGetValues(MainWindow, minmax, 3);
X`09if (app_resources.twoWindows) `7B
X`09    if (app_resources.indexLayout) `7B
X`09`09width = frameArgs`5B2`5D.value;
X`09    `7D
X`09`7D else `7B
X`09    if (app_resources.mainLayout) `7B
X`09`09width = frameArgs`5B2`5D.value;
X`09    `7D
X`09`7D
X`09XtResizeWidget(MainWindow, width, current + 1, borderWidth);
X`09return 0;
X    `7D
X    i = 0;
X#ifndef MOTIF_V10
X    XtSetArg(minmax`5Bi`5D, XmNpaneMinimum, (XtArgVal) 1);i++;
X    XtSetArg(minmax`5Bi`5D, XmNpaneMaximum, (XtArgVal) 5000);i++;
X#else
X    XtSetArg(minmax`5Bi`5D, XmNminimum, (XtArgVal) 1);i++;
X    XtSetArg(minmax`5Bi`5D, XmNmaximum, (XtArgVal) 5000);i++;
X#endif
X    XtSetArg(minmax`5Bi`5D, XmNskipAdjust, (XtArgVal) False);i++;
X    XtSetArg(minmax`5Bi`5D, XmNallowResize, (XtArgVal) True);i++;
X    XtSetArg(minmax`5Bi`5D, XmNheight, (XtArgVal) (height+2));i++;
X    XtSetValues(TopButtonBox, minmax, i);
X#ifndef MOTIF_V10
X    XtSetArg(minmax`5B0`5D, XmNskipAdjust, False);
X    if (!app_resources.twoWindows)
X`09XtSetValues(BottomButtonBox, minmax, 1);
X    XtSetValues(TopInfoLine, minmax, 1);
X    if (!app_resources.twoWindows)
X`09XtSetValues(BottomInfoLine, minmax, 1);
X    XtSetValues(TopList, minmax, 1);
X    if (!app_resources.twoWindows) `7B
X`09XtSetValues(TopShadowFrame, minmax, 1);
X`09XtSetValues(TopInfoLine, minmax, 1);
X    `7D
X#ifdef TITLEBAR
X    XtSetValues(TitleBar, minmax, 1);
X#endif
X#endif /* MOTIF_V10 */
X    return True;
X`7D
Xvoid SetButtonBoxSize(min, max)
XDimension min, max;
X`7B
X    Arg minmax`5B5`5D;
X    int i;
X    Dimension height = 0;`09`09`09`09`09    /* ggh */
X    Dimension width = 0;`09`09`09`09`09    /* ggh */
X    Dimension borderWidth = 0;`09`09`09`09`09    /* ggh */
X
X    XtSetArg(minmax`5B0`5D, XmNheight,  (XtArgVal) &height);
X    XtGetValues(TopButtonBox, minmax, 1);
X    if (height >= min) return;
X    if ((min - height) < 4) return;
X#ifndef MOTIF_V10
X    XtSetArg(minmax`5B0`5D, XmNskipAdjust, True);
X    if (!app_resources.twoWindows)
X`09XtSetValues(BottomButtonBox, minmax, 1);
X    XtSetValues(TopInfoLine, minmax, 1);
X    if (!app_resources.twoWindows)
X`09XtSetValues(BottomInfoLine, minmax, 1);
X    if (!app_resources.twoWindows)
X`09XtSetValues(TopShadowFrame, minmax, 1);
X#ifdef TITLEBAR
X    XtSetValues(TitleBar, minmax, 1);
X#endif
X    if (app_resources.twoWindows) `7B
X`09XtSetValues(TopShadowFrame, minmax, 1);
X`09XtSetValues(TopInfoLine, minmax, 1);
X    `7D
X#endif /* MOTIF_V10 */
X
X    i = 0;
X#ifdef MOTIF_V10
X    if (max <= min) max = min + 1;
X    XtSetArg(minmax`5Bi`5D, XmNminimum, (XtArgVal) min);i++;
X    XtSetArg(minmax`5Bi`5D, XmNmaximum, (XtArgVal) max);i++;
X    XtSetArg(minmax`5Bi`5D, XmNskipAdjust, (XtArgVal) True);i++;
X#else
X    if (max < min) max = min + 1;
X    XtSetArg(minmax`5Bi`5D, XmNallowResize, (XtArgVal) True);i++;
X    XtSetArg(minmax`5Bi`5D, XmNskipAdjust, (XtArgVal) True);i++;
X    XtSetArg(minmax`5Bi`5D, XmNpaneMinimum, (XtArgVal) min);i++;
X    XtSetArg(minmax`5Bi`5D, XmNpaneMaximum, (XtArgVal) max);i++;
X#endif
X    XtSetArg(minmax`5Bi`5D, XmNheight,  (XtArgVal) min);i++;
X    XtSetValues(TopButtonBox, minmax, i);
X    XtAddWorkProc((XtWorkProc)resetBox, (void *) min);
X`7D
X#else /* MOTIF */
Xstatic Boolean resetLimits(w)
XWidget w;
X`7B
X    Arg minmax`5B5`5D;
X    XtSetArg(minmax`5B0`5D, DwtNresizable, True);
X    XtSetArg(minmax`5B1`5D, DwtNmin, 1);
X    XtSetArg(minmax`5B2`5D, DwtNmax, 5000);
X    XtSetValues(w, minmax, 3);
X    return True;
X`7D
Xvoid PaneSetMinMax(w, min, max)
XWidget w;
XDimension min;
XDimension max;
X`7B
X    Arg minmax`5B5`5D;
X
X    if (max <= min) max = min + 1;
X    XtSetArg(minmax`5B0`5D, DwtNresizable, (XtArgVal) False);
X    XtSetArg(minmax`5B1`5D, DwtNmin, (XtArgVal) min);
X    XtSetArg(minmax`5B2`5D, DwtNmax, (XtArgVal) max);
X    XtSetValues(w, minmax, 3);
X`7D
Xstatic Boolean resetBox(height)
Xint height;
X`7B
X    Arg minmax`5B5`5D;
X    int i;
X
X    DwtPaneSetConstraints(TopButtonBox, 1, 5000, height, True);
X
X    i = 0;
X    XtSetArg(minmax`5Bi`5D, DwtNmin, (XtArgVal) 1);i++;
X    XtSetArg(minmax`5Bi`5D, DwtNmax, (XtArgVal) 5000);i++;
X    XtSetArg(minmax`5Bi`5D, DwtNresizable, (XtArgVal) True);i++;
X    XtSetValues(TopInfoLine, minmax, i);
X    XtSetValues(TopList, minmax, i);
X    if (!app_resources.twoWindows)
X`09XtSetValues(ScrollWindow, minmax, i);
X#ifdef TITLEBAR
X    XtSetValues(TitleBar, minmax, i);
X#endif
X    return True;
X`7D
Xvoid SetButtonBoxSize(min, max)
XDimension min, max;
X`7B
X    Arg minmax`5B5`5D;
X    int i;
X
X    if (max <= min) max = min + 1;
X    XtSetArg(minmax`5B0`5D, DwtNresizable, False);
X    XtSetValues(TopInfoLine, minmax, 1);
X    XtSetValues(TopList, minmax, 1);
X    if (!app_resources.twoWindows) `20
X`09XtSetValues(ScrollWindow, minmax, 1);
X#ifdef TITLEBAR
X    XtSetValues(TitleBar, minmax, 1);
X#endif
X    DwtPaneSetConstraints(TopButtonBox, min, max, min, False);
X    XtAddWorkProc(resetBox, min);
X`7D
X#endif /* MOTIF */
X#ifdef XFILESEARCHPATH
Xstatic void
XAddPathToSearchPath(path)
Xchar *path;
X`7B
X     char *old, *new;
X
X     old = getenv("XFILESEARCHPATH");
X     if (old) `7B
X#ifdef USE_PUTENV
X`09  /* +1 for =, +2 for :, +3 for null */
X`09  new = XtMalloc((Cardinal) (strlen("XFILESEARCHPATH") +
X`09`09`09`09     strlen(old) +
X`09`09`09`09     strlen(path) + 3));
X`09  (void) strcpy(new, "XFILESEARCHPATH");
X`09  (void) strcat(new, "=");
X`09  (void) strcat(new, old);
X`09  (void) strcat(new, ":");
X`09  (void) strcat(new, path);
X`09  putenv(new);
X#else
X`09  /* +1 for colon, +2 for null */
X`09  new = XtMalloc((Cardinal) (strlen(old) + strlen(path) + 2));
X`09  (void) strcpy(new, old);
X`09  (void) strcat(new, ":");
X`09  (void) strcat(new, path);
X`09  setenv("XFILESEARCHPATH", new, 1);
X#endif
X     `7D
X     else `7B
X#ifdef USE_PUTENV
X`09  new = XtMalloc((Cardinal) (strlen("XFILESEARCHPATH") +
X`09`09`09`09     strlen(path) + 2));
X`09  (void) strcpy(new, "XFILESEARCHPATH");
X`09  (void) strcat(new, "=");
X`09  (void) strcat(new, path);
X`09  putenv(new);
X#else
X`09  setenv("XFILESEARCHPATH", path, 1);
X#endif
X     `7D
X`7D
X#endif
$ CALL UNPACK XRN.C;147 1599698167
$ create 'f'
X
X
X
X   3 Mar 1993                                                         MXRN(1
V)
X
X
X
X   NAME
X     mxrn/dxrn - an X-based interface to the USENET news system that uses th
Ve
X     NNTP remote news server
X
X   SYNOPSIS
X     mxrn is an X-based interface to the USENET news system that uses the
X     NNTP remote news server for accessing newsgroups and articles.  By usin
Vg
X     the NNTP server, users can read news from personal workstations with th
Ve
X     program accessing the news groups and articles from a central repositor
Vy
X     on the local area network.  This manual page applies to version 6.18.
X
X   DESCRIPTION
X
X     mxrn `5B-addBindings bindings`5D `5B-addButtonList list`5D `5B-addPopup
VList list`5D
X     `5B-allBindings bindings`5D `5B-allButtonList list`5D `5B-allPopupList
V list`5D
X     `5B-artBindings bindings`5D `5B-artButtonList list`5D `5B-artPopupList
V list`5D
X     `5B-artSpecButtonList list`5D `5B+/-authorFullName`5D `5B-authorLength
V len`5D
X     `5B+/-autoRead`5D `5B+/-autoWrap`5D `5B+/-busyIcon`5D `5B-busyIconName`
V5D
X     `5B-busyIconPixmap`5D `5B+/-cc`5D `5B+/-ccForward`5D `5B-compBreakLengt
Vh len`5D
X     `5B-compLineLength len`5D `5B-compRows rows`5D `5B+/-confirm list`5D
X     `5B-deadLetters file`5D `5B-defaultlines num`5D `5B+/-delayedPrint`5D
X     `5B+/-displayLineCount`5D `5B+/-displayLocalTime`5D
X     `5B-distribution dist`5D `5B+/-dumpCore`5D `5B-editorCommand command`5D
X     `5B+/-executableSignatures`5D `5B+/-extraMailHeaders`5D `5B-hostName ho
Vstname`5D
X     `5B-iconGeometry +X+Y`5D `5B-ignoreNewsgroups list`5D `5B-includeComman
Vd command`5D
X     `5B+/-includeHeader`5D `5B-includePrefix "prefix text"`5D `5B+/-include
VSep`5D
X     `5B+/-info`5D `5B+/-killFiles`5D `5B-layout geometry`5D `5B-leaveHeader
Vs list`5D
X     `5B+/-localSignatures`5D `5B-lockFile name`5D `5B-mailer "mailer comman
Vd"`5D
X     `5B-maxLines number`5D `5B-mhPath path`5D `5B-minLines number`5D `5B-ne
VwsrcFile file`5D
X     `5B-ngBindings bindings`5D `5B-ngButtonList list`5D `5B-ngPopupList lis
Vt`5D
X     `5B-nntpServer name`5D `5B-onlyShow num`5D `5B-organization organizatio
Vn`5D
X     `5B+/-pageArticles`5D `5B-personalName "name"`5D `5B-pointerBackground`
V5D
X     `5B-pointerForeground`5D `5B-popupButton button`5D `5B-printCommand com
Vmand`5D
X     `5B-replyPath mailPath`5D `5B-replyTo name`5D `5B-rescanTime time`5D `5
VB+/-resetSave`5D
X     `5B+/-retainKilled`5D `5B-retryLimit count`5D `5B-retryPopupCount count
V`5D
X     `5B-retryPopupTimeout secs`5D `5B-retryPause secs`5D `5B-saveDir direct
Vory`5D
X     `5B-saveMode mode`5D `5B-saveNewsrcFile file`5D `5B-savePostings file`5
VD
X     `5B-saveString string`5D `5B-signatureFile file`5D `5B+/-signatureNotif
Vy`5D
X     `5B-sortedSubjects sort-type`5D `5B-stripHeaders list`5D `5B-subjectLen
Vgth len`5D
X     `5B+/-subjectRead`5D `5B-tmpDir directory`5D `5B-topLines number`5D
X     `5B-unreadIconName "name"`5D `5B-unreadIconPixmap pixmap`5D `5B+/-updat
VeNewsrc`5D
X     `5B+/-useGadgets`5D `5B+/-verboseKill`5D `5B+/-watchProgress`5D `5B-wat
VchUnread list`5D
X     `5B+/-xrefMarkRead`5D
X
X     Along with the standard toolkit options: display, geometry, xrm, and
X     iconic.
X
X   BASIC OPERATION
X
X     Don't let the size of this manual page alarm you.  mxrn is easy to lear
Vn
X     on-line without reading the documentation.  This manual page describes
X     many features that may be obvious to the casual observer, along with a
X     large section on customization (such as choosing colors and fonts).  It
X
X
X   X
V                                                                        1
X
X
X
X
X
X
X   MXRN(1)                                                         3 Mar 199
V3
X
X
X     also describes how to use scroll bars, buttons, and select text; if you
X     have used an X toolkit application before, the section titled "BUTTONS,
X     SCROLL BARS, and SELECTION" can be skipped.
X
X     mxrn uses the `60.newsrc' file to determine what groups need to be read
V.
X     If the `60.newsrc' file does not exist, it is created, and the user is
X     subscribed to the news group `60news.announce.newusers'.
X
X     mxrn has four modes of operation: Add, Newsgroup, All, and Article
X     modes.  Add mode will be entered on startup if there are any groups tha
Vt
X     the news system knows about that are not in the `60.newsrc' file (i.e.,
X     new groups).  In Add mode, the user is given a list of new groups.
X     Groups can then be subscribed to and placed in the `60.newsrc' file at
V the
X     first position, the last position, or after a group already in the
X     `60.newsrc' file.  When Add mode is exited, any remaining groups are ad
Vded
X     unsubscribed, so the user is not asked about them the next time mxrn is
X     started.  On exit from Add mode, or on startup if there are no new
X     groups, Newsgroup mode is entered.  Newsgroup mode displays the
X     subscribed to groups that have unread articles and the range of
X     available articles.  The basic functions available in this mode allow
X     the user to read a group, mark all articles in a group as read,
X     unsubscribe from a group, move the cursor around the newsgroup window,
X     change the order of the list of newsgroups, re-visit the most recently
X     visited group, and quit mxrn.  In addition, the user can subscribe to a
X     group and specify its position in the `60.newsrc' file, query the news
X     server for new articles and groups, and go to groups that are either no
Vt
X     subscribed to or currently have no unread articles (i.e., groups not
X     displayed on the screen).
X     From Newsgroup mode the user can go into All mode.  In All mode the use
Vr
X     is presented with a sorted list of all known groups and their
X     subscription status (subscribed or unsubscribed) and can change their
X     status or location in the `60.newsrc' file.  On exiting All mode the us
Ver
X     is placed back in Newsgroup mode.
X     In order to read the articles in a particular group, the user goes from
X     Newsgroup mode to Article mode.  In Article mode the user can sequence
X     through the articles in the group forward or backward, mark a group of
X     articles as read or unread, mark all articles in the current group as
X     read, unsubscribe to the current group, return to the last article
X     visited, search forward or backward for an article subject (either for
X     the exact subject or for a regular expression in the subject), locally
X     kill all articles with a particular subject, and quit (saving all
X     changes) or exit (leaving all articles marked unread).  In addition, th
Ve
X     user can save the current article in a file, post an article to the
X     group, post a followup to the current article, mail a reply to the
X     author of an article, and return to Newsgroup mode.
X
X   NEWS SYSTEM
X
X     The news system is a set of bulletins, discussion groups, program
X     sources, and other bits of information distributed around the world
X     under the name `60USENET'.  The information is generally called `60news
V' and
X     is broken up into `60newsgroups'.  Each newsgroup deals with a subject
V or
X     set of subjects.  The subjects for newsgroups are varied:  from
X     discussions about particular versions of UNIX to movie reviews, from
X
X
X   2
V                                                                        X
X
X
X
X
X
X
X   3 Mar 1993                                                         MXRN(1
V)
X
X
X     information on the X window system to commentary on current social and
X     political issues.
X
X     For information on what newsgroups are available, answers to commonly
X     asked questions, and newsgroup etiquette, read the articles in the
X     newsgroup `60news.announce.newsusers'.  Users who are new to the USENET
X     are strongly encouraged to become familiar with the contents of the
X     articles in `60news.announce.newusers' before posting any messages.
X
X   NEWS SERVER
X
X     In order to run mxrn, you must have access to an NNTP news server.  If
X     you do not have access to such a server and would like to set one up,
X     see the "USENET Software: History and Sources" posting in
X     news.announce.newusers for information about where to get the
X     appropriate software.  Either the file `60/usr/local/lib/rn/server' (th
Vis
X     filename may be configured differently at some sites) must contain the
X     name of the server machine, the environment variable NNTPSERVER must be
X     set to the name of the server machine, the nntpServer Xdefault must be
X     set to the name of the server machine, or the `60-nntpServer' flag must
V be
X     specified on the command line (with the order of precedence being
X     command line, Xdefault, environment variable, file).  The name can be
X     the actual host name of the NNTP server (i.e. shambhala.berkeley.edu) o
Vr
X     the internet number (i.e. 128.32.132.54).  If someone else has installe
Vd
X     mxrn at your site, then it is probably already configured to use the
X     correct news server and you don't have to worry about it.
X
X   SCREEN LAYOUT
X
X     The screen displayed by mxrn consists of seven sections: a title bar,
X     two scrollable text windows, two information bars, and two button boxes
V.
X     The title bar displays the current version of the program.  The top tex
Vt
X     window displays information based on the mode.  In Add mode, the window
X     displays all groups that are not currently in the `60.newsrc' file, one
X     per line.  In Newsgroup mode, the window displays the groups containing
X     unread articles; each group represented by a line of the form:
X
X        Unread news in <group name>           <num> article(s) + <old> old
X
X     <group name> is the name of the group, <num> is the number of unread
X     articles, and <old> is the number of read articles that are still
X     available (i.e. have not been expired) on the news server.  If "List
X     old" is toggled on, then the word "Unread" will not appear on the lines
X     of newsgroups with no unread articles, and furthermore, the words "news
X     in" will not appear on the lines of newsgroups with no available
X     articles at all.
X
X     In Article mode, the window displays a list of subjects for the article
Vs
X     in the current group, with each subject line being represented by a lin
Ve
X     of the form:
X
X          `5B+u`5D`5BSP`5D <num>    <subject of the article> `5B<lines>`5D <
Vauthor>
X
X     where <num> is the article number, <lines> is the number of lines in th
Ve
X
X
X   X
V                                                                        3
X
X
X
X
X
X
X   MXRN(1)                                                         3 Mar 199
V3
X
X
X     article (when available), and <author> is the author of the article.  A
X     `60+' in the first position means that the article has been read, a `60
Vu' in
X     the first position means that the article has been marked as unread, a
X     'S' in the second position means that the article has been saved to a
X     file, and a 'P' in the second position means that the article has been
X     printed.
X
X     in the top button box, and error messages.  The top button box has
X     buttons that are specific to the mode and apply to the information in
X     the top text window.  The bottom text window displays articles in
X     Article mode and a list of all known groups and their subscription
X     status in All mode.  The bottom information bar displays information
X     about the mode, the buttons in the bottom button box, and error
X     messages.  The bottom button box has buttons that are specific to the
X     mode and apply to the information in the bottom text window.
X
X   BUTTONS, SCROLL BARS, AND SELECTION
X
X     All button and text selection commands are done with the left mouse
X     button.  Single-line text selection is accomplished by clicking the lef
Vt
X     mouse button on the desired line.  Multiple-line selection is
X     accomplished by clicking the left mouse button on the first line,
X     holding the button down, dragging the mouse to the last line, and
X     releasing the mouse button.  Extended selection can be done by clicking
X     on an article or range of articles, then using shift-click to add or
X     remove an article from the selection.  Selected lines appear in reverse
X     video (the foreground and background colors are switched).  The text
X     windows are scrolled with the scroll bar on the right side of the
X     window.  Clicking the left mouse button in the scroll bar will scroll
X     the text up or down some fraction of a page; the `60slider' or `60eleva
Vtor'
X     in the scrollbar can be dragged to perform more rapid scrolls.
X
X   MODES
X
X     The next few sections describe the individual modes in mxrn.  Each
X     button in the various modes is described with the label for the button
X     and the name of the button.  The name of the button can be used in X
X     resources, in the button lists, and in the bindings tables.
X     Note that not all buttons will appear in the button boxes; you can use
X     the customization menus to determine which functions appear in the
X     button boxes and popup menus. See the section of this manual titled
X     `60CUSTOMIZATIONS' for further information.
X
X   ADD MODE
X
X     Add mode is entered when new groups have been detected (groups that the
X     news system knows about but are not in the `60.newsrc' file).
X     This allows you to determine what to do to these groups (subscribe or
X     ignore them).
X
X     Quit (addQuit)
X          Add remaining groups in the list to `60.newsrc' as unsubscribed; g
Vo
X          to group mode.
X
X
X
X   4
V                                                                        X
X
X
X
X
X
X
X   3 Mar 1993                                                         MXRN(1
V)
X
X
X     Add First (addFirst)
X          Add the current group(s) to the beginning of the `60.newsrc' file
V and
X          mark as subscribed.  The current group is the selected group(s), o
Vr
X          the group on the line containing the cursor.
X
X     Add Last (addLast)
X          Add the current group(s) to the end of the `60.newsrc' file and ma
Vrk
X          as subscribed.
X
X     Add After Group (addAfter)
X          Add the current group(s) after a group already in the `60.newsrc'.
V  A
X          dialog box is used to allow the user to enter the name of the grou
Vp
X          to add the group after.  The mouse cursor must be in the dialog bo
Vx
X          for mxrn to accept text (however, it does not have to be in the
X          type-in area).  The dialog box has two options: abort and add.  No
X          other buttons on the screen will work until the user has selected
X          an option in the dialog box.  Hitting carriage return is the same
X          as clicking the add button (in all mxrn dialog boxes hitting
X          carriage return is the same as clicking in the rightmost button of
X          the dialog box).
X
X     Add Unsubscribed (addUnsub)
X          Add the current group(s) to the end of the `60.newsrc' file and ma
Vrk
X          as unsubscribed.
X
X
X   NEWSGROUP MODE
X
X     Newsgroup mode is normally the mode that mxrn starts up in. The window
X     at the top of the screen displays the list of subscribed groups that
X     have new news articles (ones that you haven't read) and provides contro
Vl
X     over which groups are visited.
X     Double clicking the left mouse button on a newsgroup entry will enter
X     the newsgroup.
X
X     exit (ngExit)
X          Quit mxrn, leaving the `60.newsrc' file unchanged since the last
X          `60rescan' operation or `60checkpoint'.  If `60updateNewsrc' is on
V, then
X          the `60.newsrc' file is kept up to date with the last time Article
X          mode was exited.
X
X     Quit (ngQuit)
X          Quit mxrn. The `60.newsrc' file is updated to account for the
X          articles read and mxrn exits.
X
X     Read Group (ngRead)
X          Read the articles in the current group.  The current group is
X          either the one selected (if one is selected) or the first group in
X          the list. The first article in the group is read, if the `60Auto
X          Read' flag is turned on. The `60Open Newsgroup' function can be us
Ved
X          to avoid reading the first article.
X          If all groups have been read, the user can still access groups by
X          using the goto newsgroup command.
X
X
X
X   X
V                                                                        5
X
X
X
X
X
X
X   MXRN(1)                                                         3 Mar 199
V3
X
X
X     Open Group (ngOpen)
X          Open a newsgroup without reading the first article. This command i
Vs
X          useful for groups with large articles, such as source groups, wher
Ve
X          you may not want to read the initial article.
X          The current group is either the one selected (if one is selected)
X          or the first group in the list.
X
X     Next (ngNext)
X          Move the cursor to the next group, leaving the articles in the
X          current group untouched.
X
X     Prev (ngPrev)
X          Move the cursor to the previous group, leaving the articles in the
X          current group untouched.
X
X     Catch Up (ngCatchUp)
X          Mark all articles in the current group as read.
X
X     Subscribe (ngSubscribe)
X          Subscribe to a group.  A dialog box is used to allow the user to
X          enter the name of the group.  The dialog box has the following
X          options: abort, prev group (subscribe to the previous group
X          visited), first (put group in the beginning of the `60.newsrc' fil
Ve),
X          last (put group in the end of the `60.newsrc' file), and current
X          position (put group at the position of the cursor).  This command
X          can also be used to change the position of a subscribed group.
X          Hitting carriage return after typing in the name is the same as
X          clicking the current position button.
X
X     Unsubscribe (ngUnsub)
X          Unsubscribe from the current group.
X
X     Goto Newsgroup (ngGoto)
X          Go to an arbitrary newsgroup. The first unread article is
X          displayed.  If all articles in the group have been read, the last
X          article in the group is displayed.  The name specified can be a
X          substring of the group name or a regular expression.
X
X     Toggle Groups (ngToggleGroups)
X          Toggle group display mode from verbose mode (showing information o
Vn
X          all subscribed groups) to normal mode (showing information only on
X          subscribed groups with new news).
X
X     All Groups (ngAllGroups)
X          Display all of the groups that exist, their subscription status,
X          and a set of buttons for changing the status.
X
X     Rescan (ngRescan)
X          Query the server for any new groups or articles.
X
X     Prev Group (ngPrevGroup)
X          Re-visit the previous group visited.
X
X     Select Groups (ngSelect)
X
X
X   6
V                                                                        X
X
X
X
X
X
X
X   3 Mar 1993                                                         MXRN(1
V)
X
X
X          Records the groups currently selected.  If no groups are selected,
X          nothing is recorded.
X
X     Move (ngMove)
X          Moves the groups previously selected with the select groups comman
Vd
X          to the current cursor position.  If the cursor is currently inside
X          the groups to be moved, no groups are moved.  If any other button
X          is invoked after select groups and before move, the selection is
X          lost, and no groups are moved.
X
X     Checkpoint (ngCheckPoint)
X          Update the `60.newsrc' file. mxrn normally updates the `60.newsrc'
V file
X          on `60rescan' and `60quit' in Newsgroup mode. This allows you to u
Vpdate
X          the `60.newsrc' file without exiting mxrn or reconnecting to the
X          server (see also 'artCheckPoint').
X
X     Post (ngPost)
X          Post an article to a newsgroup. See "post" under Article mode for
X          more information.
X
X     Gripe (ngGripe)
X          Send a gripe (bug, bug fix, complaint, feature request, etc.) to
X          the authors of the program.
X
X   ALL MODE
X
X     All mode allows the user to change both the subscription status and the
X     `60.newsrc' file position of any available group.  All operations can
X     apply to multiple groups.  Thus, the user should never have to use a
X     text editor on the `60.newsrc' file.
X     Double-clicking on a newsgroup name in the list will cause the group to
X     be read. You can use the `60open group' function to open a group withou
Vt
X     reading the first article.
X
X     Quit (allQuit)
X          Update the `60.newsrc' file and return to group mode.
X
X     Subscribe (allSub)
X          Subscribe to the current group, leaving it at its current position
X          in the `60.newsrc' file.
X
X     Subscribe First (allFirst)
X          Subscribe to the current group and add it to the beginning of the
X          `60.newsrc' file.
X
X     Subscribe Last (allLast)
X          Subscribe to the current group and add it to the end of the
X          `60.newsrc' file.
X
X     Subscribe After Group (allAfter)
X          Subscribe to the current group and add it after a particular group
X          in the `60.newsrc' file (which is entered with the use of a dialog
X          box).
X
X
X
X   X
V                                                                        7
X
X
X
X
X
X
X   MXRN(1)                                                         3 Mar 199
V3
X
X
X     Unsubscribe (allUnsub)
X          Unsubscribe the current group.
X
X     Goto Group (allGoto)
X          Go to the current newsgroup.
X
X     Open Group (allOpen)
X          Open a newsgroup without automatically reading the first article.
X          The currently selected group (or the first group in the selection)
X          is opened.
X
X     Select Groups (allSelect)
X
X     Move (allMove)
X          Same as the "select groups" and "move" buttons in Newsgroup mode.
X          These functions are used to re-order groups.
X
X     Toggle Order (allToggle)
X          Toggle the order of the newsgroups in the window between `60.newsr
Vc'
X          order and alphabetical order.
X
X     Scroll Forward (allScroll)
X          Scroll the all groups window forward a page.
X
X     Scroll Backward (allScrollBack)
X          Scroll the all groups window backwards a page.
X
X     Search (allSearch)
X          Search the all groups window for a group.
X
X     Continue Search (allContinue)
X          Continue the all groups search.
X
X     Cancel Search (allCancelSearch)
X          Cancel the all groups search.
X
X   ARTICLE MODE
X
X     Article mode is used for reading and manipulating articles in a single
X     group.  When a group is entered, the list of article subjects displayed
X     contains those from the first unread article to the last available
X     article.  Previous articles can be obtained by using the prev or subjec
Vt
X     previous commands.  Double clicking the left mouse button on an article
X     entry will display the article.
X
X     Quit (artQuit)
X          Update the `60.newsrc' file and return to group mode.
X
X     Next (artNext)
X          Display the selected article, if any; otherwise, display the next
X          article in the current group.  Return to Newsgroup mode after the
X          last article has been reached.
X
X     Next Unread (artNextUnread)
X
X
X   8
V                                                                        X
X
X
X
X
X
X
X   3 Mar 1993                                                         MXRN(1
V)
X
X
X          Display the selected article if it is unread; otherwise, display
X          the first unread article AFTER the cursor position.  If no unread
X          articles exist, mxrn returns to Newsgroup mode.
X
X     Prev (artPrev)
X          Display the selected article, if any; otherwise, display the
X          previous article in the current group.
X
X     Last (artLast)
X          Display the last article accessed before the currently displayed
X          one.  This command only keeps track of one previously accessed
X          article, so invoking it repeatedly simply toggles the display
X          between two articles.
X
X     Next Newsgroup (artNextGroup)
X          Go directly to the next newsgroup with unread news (bypass
X          newsgroup mode).
X
X     Goto Article (artGotoArticle)
X          Go to the specified article number. Articles read in previous
X          sessions can be accessed using this command.
X
X     Catch Up (artCatchUp)
X          Mark all articles in the current group as read; return to Newsgrou
Vp
X          mode.  If a particular article is selected, catch up from the
X          beginning of the group to the selected article.
X
X     Fed Up (artFedUp)
X          Mark all articles in the current group as read; go to the next
X          newsgroup.
X
X     Mark Read (artMarkRead)
X          Mark an article (or group of articles) as read.  This command mark
Vs
X          either the selected article(s) or the article the cursor is on, an
Vd
X          leaves the cursor at its current position.
X
X     Mark Unread (artMarkUnread)
X          Mark an article (or group of articles) and unread.  This command
X          marks either the selected article(s) or the article the cursor is
X          on, and leaves the cursor at its current position.  When an articl
Ve
X          is marked as unread, a 'u' is placed in the far left column next t
Vo
X          the article's subject.  The next, prev, subject next, and subject
X          prev buttons will all display this article if they come across it,
X          but the next unread button will not.  The only way to mark an
X          article as read once it has been marked with a 'u' is to use the
X          mark read function.
X
X     Unsubscribe (artUnsub)
X          Unsubscribe from the current group; return to Newsgroup mode.
X
X     Scroll Forward (artScroll)
X          Scroll the article text forward a page.
X
X     Scroll Backward (artScrollBack)
X
X
X   X
V                                                                        9
X
X
X
X
X
X
X   MXRN(1)                                                         3 Mar 199
V3
X
X
X          Scroll the article text backward a page.
X
X     Scroll End (artScrollEnd)
X          Scroll the article text to the end.
X
X     Scroll Beginning (artScrollBeginning)
X          Scroll the article text to the beginning.
X
X     Scroll Line (artScrollLine)
X          Scroll the article text forward one line.
X
X     Scroll Back Line (artScrollBackLine)
X          Scroll the article text backward one line.
X
X     Subject Next (artSubNext)
X          Find and display the next article with the same subject as the
X          current article (stripping the '`5BrR`5D`5BeE`5D:' garbage).  If t
Vhere are
X          no more articles with the current subject and there are more unrea
Vd
X          articles, the first unread article is selected.  If there are no
X          more articles with the current subject and there are no more unrea
Vd
X          articles, Article mode is exited.
X
X     Subject Prev (artSubPrev)
X          Find and display the previous article with the same subject as the
X          current article. The search will proceed past the current list of
X          articles to scan articles read in previous sessions.
X
X     Session Kill (artKillSession)
X          Mark all articles with the current subject as read, for this
X          session only.
X
X     Local Kill (artKillLocal)
X          Mark all articles with the current subject as read for this group,
X          and for this and all future sessions.
X
X     Global Kill (artKillGlobal)
X          Mark all articles with the current subject as read for all groups,
X          and for this and all future sessions.
X
X     Author Kill (artKillAuthor)
X          Mark all articles by the current author as read for this session
X          only.
X
X     Subject Search (artSubSearch)
X          Begin a regular expression subject search.  When this button is
X          invoked, a window pops up querying the user for a regular
X          expression (of the form used in ed), and a direction in which to
X          search.  If a regular expression is not typed in, the last regular
X          expression is used, and the search direction is the one specified
X          in the dialog box (this can be used to switch the direction of the
X          search without retyping the expression).
X
X     Continue (artContinue)
X          Continue the last regular expression search by searching for the
X
X
X   10
V                                                                       X
X
X
X
X
X
X
X   3 Mar 1993                                                         MXRN(1
V)
X
X
X          same regular expression in the same direction.
X
X     Cancel Search (artCancelSearch)
X          Cancel the regular expression search.
X
X     Article Order (artNonSorted)
X          Change the order of entries in the subject window to be sorted by
X          article number.
X
X     Subject Order (artSorted)
X          Change the order of entries in the subject window to be sorted by
X          article number, with groups of articles with the same subject
X          grouped together.  or sorted by subject.
X
X     Strict Order (artStrictSorted)
X          Change the order of entries in the subject window to be sorted by
X          the subject only. (This can be useful for sources groups).
X
X     Post (artPost)
X          Post an article to the current group.  A scrollable, editable text
X          window will appear with a header and the user's appropriate
X          signature file included.  The appropriate signature file is the
X          usual signature file name `60`7E/.signature' followed by either a
V `60-'
X          and a  newsgroup name substring, or followed by a `60.' and
X          `60followup', `60forward', `60gripe', `60reply' or `60post' accord
Ving to the
X          posting mode.  For example if you want to post a followup article
X          in comp.sources.x then xrn uses the first valid signature file in
X          the following order:
X
X               `7E/.signature-comp.sources.x
X               `7E/.signature-comp.sources
X               `7E/.signature-comp
X               `7E/.signature.followup
X               `7E/.signature
X
X          An appropriate header will be generated with a number of blank
X          header fields that if left blank will be deleted from the posting.
X          The editor defaults to the standard Xtoolkit editor, and the
X          default can be overridden by using the command line option
X          -editorCommand or by setting the same Xdefault (see the section on
X          command line arguments).  The mouse buttons can be used to select
X          text in this window (which can then be placed in a file, for
X          example).
X
X          There are four buttons at the bottom of the window: abort, send (t
Vo
X          post the article), save (to save the article in a file), and
X          include (include the text of the article in the reply or followup)
V.
X          The include article button is omitted if there is no current
X          article (e.g. if the user is sending a "Gripe" or if "post" was
X          selected from Newsgroup mode).  Only one article or message window
X          can be active at a time.  Only one post (or followup or reply)
X          window can be active at a time.
X
X     Exit (artExit)
X
X
X   X                                                                       1
V1
X
X
X
X
X
X
X   MXRN(1)                                                         3 Mar 199
V3
X
X
X          Exit article mode, marking all articles listed in the top window a
Vs
X          unread.
X
X     Checkpoint (artCheckPoint)
X          Update the `60.newsrc' file. mxrn normally updates the `60.newsrc'
V file
X          on `60rescan' and `60quit' in Newsgroup mode. This allows you to u
Vpdate
X          the `60.newsrc' file without exiting mxrn or reconnecting to the
X          server (see also 'ngCheckPoint').
X
X     Gripe (artGripe)
X          Send a gripe (bug, bug fix, complaint, feature request, etc.) to
X          the authors of the program.
X
X     List Old (artListOld)
X          List all articles available in the group, even those that have bee
Vn
X          read.  Note that this button does not toggle (clicking this button
X          twice will no put you back to where you were).
X
X     Save (artSave)
X          Save the current article in a file, or use the current article as
X          standard input to a command.  The save command will pop up a dialo
Vg
X          box for the filename.  The dialog box has two buttons: abort and
X          save.  If the filename begins with a `60`7C', the article will be
V sent
X          to the command specified after the `60`7C'.  Otherwise, the articl
Ve
X          will be appended to the file specified.  If the name is relative
X          (does not begin with `60/' or `60`7E'), it will be prepended by
X          `60`7E/News/'.  If the name begins with a `60+' the name is assume
Vd to be
X          a MH mail folder and a `60refile' command will be done on the
X          article.  If no name is specified, it will be saved in
X          `60`7E/News/<groupname>', where `60<groupname>' is the name of the
X          current group with the first letter capitalized (following the
X          rn(1) article saving conventions).  If -saveMode is set to
X          `60subdirs', then `60`7E/News/<groupname>/' will be used instead o
Vf
X          `60`7E/News/'. Multiple articles can be selected and saved with on
Ve
X          command. If the filename contains the characters `60%d', the artic
Vle
X          number will replace that string; otherwise, the group of articles
X          will be appended into a single save file.  For VMS, piping of
X          articles to commands (`60`7C') is not supported.  File names are u
Vsed
X          as given. If no filename is given in a `60save' command, the group
X          name will be used for a filename (with second and subsequent
X          periods converted to underscores; for example, `60comp.os_vms'.
X          Subdirs save mode on VMS uses the group name to create a
X          subdirectory for saving the articles.
X
X     Reply (artReply)
X          Reply (by mail) to the author of the current article.  See post fo
Vr
X          a description of how to create and send a message.
X
X     Forward (artForward)
X          Send the current article to another person via mail.
X
X     Followup (artFollowup)
X          Post a followup article to the current article.  See post for a
X          description of how to create and send an article.
X
X
X   12
V                                                                       X
X
X
X
X
X
X
X   3 Mar 1993                                                         MXRN(1
V)
X
X
X     Cancel (artCancel)
X          Cancel the current article.
X
X     Rot-13 (artRot13)
X          Decrypt a encrypted article.  In the newsgroup `60rec.humor',
X          occasionally articles are submitted that may offend certain people
X          or groups of people.  In order to minimize the offense, these
X          articles are posted in an encrypted form.  This button will decryp
Vt
X          them.
X
X     Translate (artXlate)
X          Translate article from ISO 646 to ISO 8859-1.
X
X     Toggle Header (artHeader)
X          Show the full text of an article, including the full header.
X
X     Print Article (artPrint)
X          Send the article to the printer (see the `60printCommand' command
X          line option).
X
X
X   CUSTOMIZING MXRN
X
X     Colors, fonts, and other mxrn options can be specified on the command
X     line or using X resources.  With the exception of the display name, all
X     mxrn options can be specified using X resources.  Options specified on
X     the command line take precedence over those specified using X resources
V.
X     In addition, mxrn has a set of customization screens that can be used t
Vo
X     tailor the environment without editing resource files.  For each
X     customization entry below, the corresponding resource entry and
X     customization menu entry are described.
X
X
X   CUSTOMIZATIONS
X
X     The majority of the customization functions are available in any mxrn
X     mode by selecting the entries from the `60Customize' menu. For each of
V the
X     entries in this menu, the section below describes the function and the
X     associated command-line argument. Note that the case of the entries
X     given for the resource file and command line are case-sensitive - they
X     must be entered exactly as given.
X     The following sections describe the fields on each of the customization
X     screens and their function.
X
X     Customize/Controls
X          This box provides a series of options for functions that the user
X          wishes to confirm before actions are taken. These boxes pop up to
X          ask the user to verify the invocation of "dangerous" actions (such
X          as catch up and unsubscribe). It also provides control of `60save'
X          functions.
X
X     Confirm Exit
X               If active, provides a dialog box to allow you to confirm
X               `60quit' operations.
X
X
X   X                                                                       1
V3
X
X
X
X
X
X
X   MXRN(1)                                                         3 Mar 199
V3
X
X
X     Confirm Exit
X               If active, provides a dialog box to allow you to confirm
X               `60exit' operations.
X
X     Confirm NG Catch Up
X               If active, provides a dialog box to allow you to confirm
X               `60Catch Up' operations in Newsgroup mode.
X
X     Confirm Article Catch Up
X               If active, provides a dialog box to allow you to confirm
X               `60Catch Up' operations in Article mode.
X
X     Confirm NG Unsubscribe
X               If active, provides a dialog box to allow you to confirm
X               `60Unsubscribe' operations in Newsgroup mode.
X
X     Confirm Article Unsubscribe
X               If active, provides a dialog box to allow you to confirm
X               `60Unsubscribe' operations in Article mode.
X
X     Action Prompt at Subject Change
X               If active, provides a dialog box to allow you to decide what
X               to do when the subject changes when reading articles.
X
X     Confirm Save file Overwrite
X               If active, allows you to specify what to do when a save
X               operation finds the file you've specified already exists
X               (replace, append, or quit).  The default is to append to the
X               existing file.
X
X     Customize/Controls Save fields
X          These fields modify the behavior of save operations.
X
X     Mailbox   If enabled, articles are saved in 'mailbox' format - with a
X               date header line and other data to make the saved file appear
X               to be in a format similar to mail storage.
X
X     Headers   If enabled, all the header lines are saved with the article.
X               If disabled, the article is saved as displayed (with any
X               headers stripped as controled by the `60leave headers' and
X               `60strip headers' customizations applied.)
X
X     Subdirectory/One Directory
X               These controls determine how articles are saved if no
X               directory path is given; if `60Subdirectory' is enabled, the
X               article is saved in a subdirectory of your news directory -
X               this subdirectory is determined from the newsgroup name. If
X               `60One Directory' is enabled, the file is saved in the news
X               directory.  If neither is enabled, the file is saved in your
X               current working directory.
X
X     Customize/Posting
X          This box provides a series of options for controlling the posting
X          of articles and followups.
X
X
X   14
V                                                                       X
X
X
X
X
X
X
X   3 Mar 1993                                                         MXRN(1
V)
X
X
X     Line Length/Wrap Length
X               These fields determine the behavior of word wrapping of
X               articles.  Any line that exceeds `60Wrap Length' characters i
Vn
X               width will be word-wrapped at the first space past the column
X               determined by `60Line Length'. If they are both zero, no word
V-
X               wrapping takes place.
X
X     Signature File
X               This field provides the path to the file containing your
X               `60signature' - any postings or mailings have the contents of
X               this file appended. Generally used to add mail address and
X               witty sayings. The length of this file is limited to avoid
X               `60War and Peace' signatures.  Defaults to `60`7E/.signature'
V.
X               (SYS$LOGIN:NEWS.SIGNATURE on VMS).
X
X     Save Postings
X               This field gives the file name of the file to use to save
X               postings (used when the `60save' function in the composition
X               window is invoked.  Defaults to `60`7E/Articles'.
X               (SYS$SCRATCH:SAVED.POSTING on VMS.) Note that this is the
X               default name used when you do not specify a file name during
V a
X               save operation.
X
X     Dead Letters
X               This field gives the file name of the file to use to save an
X               article that could not be posted due to an error.  Defaults t
Vo
X               `60`7E/dead.letters'. (SYS$SCRATCH:DEAD.LETTER on VMS).
X
X     Editor Command
X               This entry allows use an alternate editor for creating
X               postings, followups, forwards, gripes, and replies.  The entr
Vy
X               must be a sprintf format string that contains a `60%s' where
V the
X               file name should be placed. Examples are:
X
X                 xterm -e vi %s
X                 xterm -e microEmacs %s
X                 emacsclient %s
X                 edit/tpu/display=decwindows %s `5Bonly VMS could be this ve
Vrbose :-)`5D
X
X              The resulting command should handle all editing and windowing.
X              The article being followed up or replied to is automatically
X              included.
X
X     Organization
X               This field provides a value for the `60Organization' header
X               field in postings and followups. Usually set to the name of
X               your company or other organization.
X
X     Reply To  This entry provides a specific address for the the Reply-To
X               header field in postings and followups. Most news readers use
X               this address for `60reply' commands.
X
X     Include Separator
X               Include or do not include the prefix text ("`7C> ") in front
V of
X
X
X   X                                                                       1
V5
X
X
X
X
X
X
X   MXRN(1)                                                         3 Mar 199
V3
X
X
X               included articles. The default is to include the prefix text
X               ("`7C> ").
X
X     Include Prefix
X               Change the standard prefix for each line of included text fro
Vm
X               the default, "`7C> ", to the given text string.
X
X     Customize/Reading
X          This box provides a series of options for controlling the reading
X          of articles.
X
X     Subject Read
X               Specifies the action to take when using the `60doTheRightThin
Vg'
X               function to read articles. If this button is enabled, at the
X               end of the article a subject next function is performed. If
X               disabled, a next unread function is performed.
X
X     Retain Killed
X               If enabled, articles that are killed are left in the subject
X               listing.  If disabled, these articles are removed from the
X               list.
X
X     Full Name Display the full name of the author or the user/hostname of
X               the author.  If enabled, the entry contains the author's
X               personal name. If disabled, the entry contains the author's
X               path name.
X
X     Show Line Count
X               If enabled, the number of lines in the article (when
X               available) is displayed in the subject lines.
X
X     Auto Wrap If enabled, articles being read are word-wrapped to fit in th
Ve
X               space specified by the `60Line Length'. If disabled, a
X               horizontal scrollbar is used to view the article contents.
X
X     Use Kill Files
X               Enable or disable use of kill files. If disabled, the kill
X               files will be ignored.
X
X     Page Articles
X               When the `60doTheRightThing' function is used to read article
Vs,
X               specifies the action at the end of the article. If enabled,
X               the function will stop at the end of the article. If disabled
V,
X               the next article will be read.
X
X     Read First Article
X               If enabled, the first article in the newsgroup is read when i
Vt
X               is opened.  If disabled, no articles are read.
X
X     Update Newsrc
X               If enabled, the `60.newsrc' file is updated when leaving Arti
Vcle
X               mode.
X
X     Watch Kill Progress
X
X
X   16
V                                                                       X
X
X
X
X
X
X
X   3 Mar 1993                                                         MXRN(1
V)
X
X
X               If enabled, the screen is updated as each article is killed
X               during kill operations; if disabled, the screen is updated
X               only at the end of the operation.
X
X     Customize/Mailing
X          This box provides a series of options for controlling the mailing
X          of articles.
X
X     Reply Path
X               The path to use for mailing replies. This should be a
X               sprintf-able string.  This format string is used to build a
X               mail address acceptable to mail for replies. For example,
X               `60IN%%"%s"'.
X               The address in the articles `60Reply-To' header replaces the
X               `60%s' in the string and the resulting line is used to provid
Ve a
X               mail address. You must double any "%" characters that appear
X               in this string other than the "%s".
X
X     Personal Name
X               (VMS Only) Sets your 'real' name for use in postings.
X
X     Mailer    (UNIX Only) Specifies the command to use for mailing replies.
X               This command must take all of it's input from standard input
X               (mxrn will not build a command line).  The default is
X               `60/usr/lib/sendmail -oi -t'.
X
X     Host Name Sets the name of your internet host. Used for postings to
X               specify a useful path name when the default isn't useful.
X
X     Include CC
X               If enabled, a `60Cc:' line is provided in the header for
X               forwards and replies.
X
X     Customize/General
X          This box provides a series of options for controlling the general
X          behavior of mxrn.
X
X     Top/Min/Max Lines
X               These entries control the size and behavior of the window
X               containing the list of newsgroups and articles. `60Top Lines'
X               specifies the number of entries in the list. As articles are
X               read, the list scrolls to maintain the current article betwee
Vn
X               `60Min Lines' and `60Max Lines'. For example, setting `60Top
V Lines'
X               to 10, `60Min Lines' to 2, and `60Max Lines' to 8 will cause
V the
X               top window to scroll unless the current article is between
X               lines 2 and 8. This type of setting minimizes the number of
X               times the top window must be repainted.
X
X     NNTP Server
X               Supplies the name of the the NNTP server to use (name or
X               internet number).  If the entry ends in two colons (`60::'),
X               DECnet is assumed as the transport.  Otherwise, TCP/IP is
X               assumed.
X
X
X
X   X                                                                       1
V7
X
X
X
X
X
X
X   MXRN(1)                                                         3 Mar 199
V3
X
X
X     Newsrc File
X               Name of the the `60.newsrc' file to use. This file contains
X               information on your subscribed groups and which articles have
X               been read.  Defaults to `60`7E/.newsrc'. (SYS$LOGIN:NEWS.RC o
Vn
X               VMS).  If a file with a name of the form `60<newsrcFile>-
X               <nntpServer>' is found, it will be used. For example,
X               .newsrc-fumble for news server node `60fumble'.
X
X     Saved Newsrc File
X               Specifies the name of the backup `60.newsrc' file.
X               Before the `60.newsrc' file is modified, it is saved in a bac
Vkup
X               file.  This entry allows you to control the name of this
X               backup file.  Defaults to `60`7E/.oldnewsrc'.
X               (SYS$LOGIN:OLDNEWS.RC on VMS).
X
X     Temp Directory
X               Specifies the directory to use for the temporary storage of
X               articles fetched from the server.  If this option and the
X               corresponding Xdefault do not exist, mxrn will look for the
X               environment variable TMPDIR.  The default is `60/tmp'.
X               (SYS$SCRATCH: on VMS.) Save Directory Specifies the article
X               saving directory.  Defaults to `60`7E/News' when -saveMode
X               specifies `60onedir', or `60`7E/News/newsgroup' when -saveMod
Ve
X               specifies `60subdirs'.  For VMS, defaults to SYS$SCRATCH:.
X
X     Print Command
X               Set the command used for printing articles.  The article is
X               sent to the command via standard input.  Defaults to `60lpr'.
X               (PRINT/DELETE on VMS).
X
X     Rescan Time
X               Amount of idle time (in seconds) before checking for new
X               articles.  This rescan is only performed in Newsgroup mode.
X
X     Popup Button
X               Specifies which mouse button will pop up the popup menus.
X               Defaults to the standard button for the widget set being used
X               (MB2 for XUI, MB3 for Motif).
X
X     Display Informational Messages
X               If enabled, display all informative messages in the message
X               pane. If disabled, information messages are displayed in the
X               top information line only.  Defaults to display all
X               information in the message pane.
X
X
X   OTHER CUSTOMIZATIONS
X     The following arguments can be provided on the command line to further
X     customize mxrn. Entries in your application defaults file can be used t
Vo
X     specify these as well.
X
X     Watch Progress
X               If enabled, when 'Catch Up' is used to catch up to a selected
X               position in a group, the display is 'animated' so you can
X
X
X   18
V                                                                       X
X
X
X
X
X
X
X   3 Mar 1993                                                         MXRN(1
V)
X
X
X               watch the progress of the operation.
X               The associated customization file entry is `60watchProgress'.
X               The command line argument can be +watchProgress (enabled) or
X               -watchProgress (disabled).
X
X     -authorLength
X               -subjectLength Specifies the width of the `60subject' and
X               `60author' fields in the subject listing.
X
X     -busyIcon When set to "on", the icon image will invert when mxrn is
X               busy.
X
X     -ccForward
X               When set to "on", you will be included as a CC entry in
X               forwarded articles.
X
X     -compRows rows
X               Specifies the number of rows in the message composition
X               window.
X
X     -distribution
X               Specifies the default distribution for articles. The default
X               is `60world'.
X
X     -display display
X               specification of the X display. (Not for VMS).
X
X     +/-dumpCore
X               Dump core when a signal is detected.  The X resources class
X               for the "dumpCore" X resource is "Debug". `60+dumpCore' disab
Vles
X               the default signal handler.
X
X     -iconGeometry +X+Y
X               specification of the initial mxrn icon location.  The window
X               manager may choose to ignore this specification.
X
X     -iconName name
X               specification of the initial mxrn icon name.  The window
X               manager may choose to ignore this specification.
X
X     -iconic   start up mxrn with the window iconified.
X
X     -layout =WxH+X+Y
X               specification of the mxrn window size and location.  The
X               window manager may choose to ignore this specification.  Usin
Vg
X               the Customize/Save menu item saves the current geometry
X               automatically.
X
X     -leaveHeaders list
X               the header fields to leave in the article; a comma separated
X               case-insensitive list of field names (i.e.,
X               subject,from,organization).  This option takes precedence ove
Vr
X               `60stripHeaders'.  If the word `60all' is specified instead o
Vf a
X               list of fields, then all headers will be retained (This can b
Ve
X
X
X   X                                                                       1
V9
X
X
X
X
X
X
X   MXRN(1)                                                         3 Mar 199
V3
X
X
X               used in user X resources to override a resource specified in
X               the global mxrn application defaults, or on the command line
X               to override a resource specified in either the application
X               defaults or the user X resources.).  -lockFile name Specifies
X               the name of the lock file to use. The lock file is used to
X               avoid you running mxrn multiple times, thus losing updates to
X               your newsrc file.
X
X     -resetSave
X               If set to "on", the string in the save dialog box will be
X               reset when you exit article mode. Normally, the string is
X               retained between entries.  `5BExcept when the saveString is
X               specified - see below`5D.
X
X     -retryPopupCount
X               -retryPopupTimeout -retryPause -retryLimit Specifies the
X               action to be taken when the connection to the NNTP server is
X               lost. mxrn will pause for `60retryPause' seconds between
X               retries. A connection attempt is made `60retryPopupCount' tim
Ves
X               before posting a popup window that allows the user the
X               opportunity to give up. After `60retryPopupTimout' seconds, t
Vhis
X               dialog box is automatically dismissed and another retry is
X               attempted.  After trying this `60retryLimit' times, mxrn exit
Vs.
X
X     -saveString
X               Provides a default value for the filename in the save dialog
X               box.
X
X     +sortedSubjects
X               Specifies the subject sorting type to be used. Use
X               "+sortedSubjects" to group articles with the same subject, an
Vd
X               "-sortedSubjects" to display articles in article number order
V.
X               The associated customization file entry is `60sortedSubjects'
V.
X               The command line argument can be +sortedSubjects (enabled) or
X               -sortedSubjects (disabled).
X               When used in the customization file, the following values can
X               be used:
X                      Value                                 Sort by
X                   none (or off, unsorted, false)         article number
X                   subject (or on, true, article, sorted) related subjects
X                   strict                                 subject only
X
X               You can specify specific sorting types by including the
X               group name or hierarchy in the customization entry.
X               For example:
X               mxrn*sortedSubjects: subject
X               mxrn.comp.sources.x.sortedSubjects: strict
X               mxrn*binaries*sortedSubjects: strict
X               mxrn.rec.humor.funny.sortedSubjects: none
X               This would cause most groups to appear with subject sorting,
X               `60comp.sources.x' to appear in strict order, binaries groups
X               (like `60comp.binaries.ibm-pc') in strict order, and
X               `60rec.humor.funny' in article number order.
X
X
X
X   20
V                                                                       X
X
X
X
X
X
X
X   3 Mar 1993                                                         MXRN(1
V)
X
X
X     -saveDir  Specifies the default directory for saving articles.
X               You can specify save directories on a newsgroup basis by
X               including the group name or hierarchy in the customization
X               entry.  For example: mxrn*saveDir: `7E/News
X               mxrn.comp.sources.x.saveDir: `7E/X-sources
X               mxrn*binaries*saveDir: `7E/binaries
X               This would cause most groups to default to `60`7E/News' for
X               saving;
X
X     -stripHeaders list
X               the header fields to strip from the article; a comma separate
Vd
X               case-insensitive list of field names (i.e., keywords,message-
X               id).  If the word `60none' is specified instead of a list of
X               fields, then no headers will be stripped (This can be used in
X               user X resources to override a resource specified in the
X               global mxrn application defaults, or on the command line to
X               override a resource specified in either the application
X               defaults or the user X resources.).
X
X     -unreadIconName name
X               specification of the mxrn icon name when there are groups wit
Vh
X               unread articles.  The window manager may choose to ignore thi
Vs
X               specification.
X
X     -useGadgets
X               If set to "on", gadgets will be used to create the pulldown
X               menus. Saves a bit of memory - the trade-off is that the
X               gadgets are less customizable.
X
X     -watchUnread
X               Specifies a list of newsgroup names to monitor. If given, thi
Vs
X               list of groups will be scanned in newsgroup mode; if any
X               contain new news, the icon title will change to the unread
X               title. If not given, all groups are watched.
X
X     -ngButtonList list
X
X     -artButtonList list
X
X     -artSpecButtonList list
X
X     -addButtonList list
X
X     -allButtonList list
X               use the given list of buttons for the particular mode in the
X               order given rather than all of the buttons for the mode in th
Ve
X               default order.  The list is a comma separated list of button
X               names.  The names of the buttons appear next after the button
X               label in the button descriptions above.  For example, a list
X               of buttons for Newsgroup mode might be:
X               ngQuit,ngRead,ngCatchUp,ngRescan,ngSubscribe,ngPost
X               Customization menus exist for buttons and menus for each mode
V.
X
X     -ngBindings bindings
X
X
X   X                                                                       2
V1
X
X
X
X
X
X
X   MXRN(1)                                                         3 Mar 199
V3
X
X
X
X     -allBindings bindings
X
X     -addBindings bindings
X
X     -artBindings bindings
X               use the given bindings for the key/mouse bindings for the
X               particular mode.  See the X toolkit documentation on
X               `60Translation Tables' for information on the format of
X               `60bindings'.  The actions defined in mxrn are the same as th
Ve
X               button names.  For example, a set of bindings for Newsgroup
X               mode might be:
X                   mxrn.ngBindings: \
X                      <Key>Q:      ngQuit()  \n\
X                      <Key>N:      ngRead()  \n\
X                      <Key>P:      ngPrev()
X
X     -ngPopupList list
X
X     -artPopupList list
X
X     -addPopupList list
X
X     -allPopupList list
X               Specifies the list of buttons to appear in the popup menu for
X               the given mode. The list is a comma separated list of button
X               names.  The names of the buttons appear next after the button
X               label in the button descriptions above.  For example, a list
X               of buttons for Newsgroup mode might be:
X               ngQuit,ngRead,ngCatchUp,ngRescan,ngSubscribe,ngPost
X               Customization menus exist for the menus for each mode.
X
X   X RESOURCES
X
X     mxrn takes a number of specifications for colors, fonts, border widths,
X     and other program options.  The format for an mxrn X resource is:
X
X                              dxrn.x.y....z.a: value
X                                       or..
X                              mxrn.x.y....z.a: value
X
X     Where x.y....z specifies the path from the top level of mxrn to a
X     particular item (think of mxrn as a hierarchical collection of windows,
X     panes, and buttons, and x.y....z is a path from the top of the hierarch
Vy
X     to a node in the hierarchy), a is the type of default (i.e., font,
X     border, foreground, background, borderWidth), and value is the value of
X     the default (i.e,. a color name or hex representation, a font name, a
X     numeric value).  Specifying a default for a item at some point in the
X     hierarchy will set that default for all items from that point down in
X     the hierarchy.  A higher level default can be overridden by specifying
V a
X     default at a lower level directly.
X
X     MXRN/DXRN widget hierarchy:
X       main  (Main Window)
X
X
X   22
V                                                                       X
X
X
X
X
X
X
X   3 Mar 1993                                                         MXRN(1
V)
X
X
X         MenuBar (Menu Bar)
X         vpane (Paned)
X         titlebar (Label)  (optional)
X         index (Text) (enclosed in topFrame for mxrn).
X         indexinfo (Label)
X         indexbuttons (Box)
X           buttonName (Pushbutton)
X         articleText (Text) (enclosed in botFrame for mxrn).
X         textinfo (Label)
X         textbuttons (Box)
X           buttonName (Pushbutton)
X
X     composeTop (Shell)
X       pane (Paned)
X         headerText (Text) (enclosed in headerFrame for mxrn)
X         composeText (Text) (enclosed in textFrame for mxrn)
X         box (menu/RowColumn)
X            abort (Pushbutton)
X            send (Pushbutton)
X            save (Pushbutton)
X            includeArticle (Pushbutton)
X            includeFile (Pushbutton)
X            wrapText (PushButton)
X     dialogs...
X
X     Examples of defaults are:
X        #bindings for article mode
X        mxrn.artBindings:   \
X          <Key>0x20:   doTheRightThing() \n\
X          Alt<Key>N:   artNext() \n\
X          <Key>N: artSubNext()   \n\
X          Alt<Key>P:   artPrev() \n\
X          <Key>P: artSubPrev()   \n\
X          Alt<Key>F:   artFollowup()  \n\
X          Alt<Key>R:   artReply()     \n\
X          Alt<Key>W:   artSave() \n\
X          Alt<Key>C:   artCancel()    \n\
X          Alt<Key>V:   artHeader()    \n\
X          Ctrl<Key>X:  artRot13()     \n\
X          Alt<Key>u:   artUnsub()     \n\
X          Ctrl<Key>Z:  artQuit()\n
X        \n
X        #
X        #layout/scrolling control for toplevel widget
X        #
X        mxrn.topLines: 10
X        mxrn.minLines: 3
X        mxrn.maxLines: 8
X        #
X        # which button pops up the popup menus
X        #
X        mxrn.popupButton:   2
X        mxrn.saveMode: onedir
X        mxrn.includePrefix: >
X
X
X   X                                                                       2
V3
X
X
X
X
X
X
X   MXRN(1)                                                         3 Mar 199
V3
X
X
X        #
X        # list of popup menus. best set using customize
X        #
X        mxrn.ngPopupList:   ngQuit,ngRead,ngSubscribe,ngUnsub,ngCatchUp
X        mxrn.artPopupList:  artQuit,artNext,artPrev,artNextUnread
X        #
X        # your name. please don't use mine!
X        #
X        mxrn.personalName:  Rick Murphy
X        mxrn.includeHeader: off
X        mxrn.includeSep:    on
X        #
X        # don't update newsrc each newsgroup
X        #
X        mxrn.updateNewsrc:  off
X        #
X        # inhibit info messages, use kill files.
X        #
X        mxrn.info:     off
X        mxrn.killFiles:     on
X        #
X        # list of buttons in various modes
X        #
X        mxrn.artButtonList: artQuit,artFedUp,artPost
X        mxrn.ngButtonList:  ngQuit,ngRead,ngSubscribe,ngUnsub,ngCatchUp
X        #
X        # leading text for 'reply' functions
X        #
X        mxrn.replyPath:     decuac::"%s"
X        mxrn.lineLength:    72
X        mxrn.breakLength:   80
X        mxrn.pageArticles:  off
X        mxrn.rescanTime:    1800
X        mxrn.subjectRead:   on
X        mxrn.replyTo:       murphy@ufp.dco.dec.com
X        mxrn.organization:  Digital Equipment Corporation, Landover MD
X        mxrn.geometry:      617x750+248+214
X        mxrn.confirm:  ngCatchUp,artCatchUp
X        mxrn.sortedSubjects:     on
X        #
X        # examples of how to color pushbuttons.
X        # for `60dxrn' ignore the shadowColor entries.
X        #
X        mxrn*background:    SkyBlue
X        mxrn*foreground:    white
X        mxrn*artPrint.background:     #e0e000
X        mxrn*artPrint.foreground:     black
X        mxrn*artPrint.bottomShadowColor:   #005400
X        mxrn*artPrint.topShadowColor: yellow
X        mxrn*artQuit.background: red
X        mxrn*artQuit.foreground: White
X        mxrn*artQuit.bottomShadowColor:    #770000
X        mxrn*artQuit.topShadowColor:  #ffb3cc
X        mxrn*ngRead.background:  #00d800
X
X
X   24
V                                                                       X
X
X
X
X
X
X
X   3 Mar 1993                                                         MXRN(1
V)
X
X
X        mxrn*ngRead.foreground:  black
X        mxrn*ngRead.bottomShadowColor:     #005400
X        mxrn*ngRead.topShadowColor:   green
X        mxrn*ngRescan.background:     #e0e000
X        mxrn*ngRescan.foreground:     black
X        mxrn*ngRescan.bottomShadowColor:   #005400
X        mxrn*ngRescan.topShadowColor: yellow
X        mxrn*XmPushButton.background: #00d800
X        mxrn*XmPushButton.foreground: black
X        mxrn*XmPushButton.font:  *-*-Menu-Medium-R-Normal-*-*-100-*-*-*-*-*-
VISOLATIN1
X        #
X        # resources for the newsgroup/subject list
X        #
X        mxrn*index.background:   black
X        mxrn*index.foreground:   white
X        #
X        # a fixed font is strongly recommended
X        #
X        mxrn*index.font:    *-*-*-Medium-R-Normal-*-*-120-*-*-M-*
X        mxrn*index.fontList:     *-*-*-Medium-R-Normal-*-*-120-*-*-M-*
X        mxrn*XmText.background:  black
X        mxrn*XmText.foreground:  white
X        mxrn*XmText.font:   *-*-*-Medium-R-Normal-*-*-120-*-*-M-*
X        mxrn*XmText.fontList:    *-*-*-Medium-R-Normal-*-*-120-*-*-M-*
X        composeTop*headerText*fontList:    *-*-*-Medium-R-Normal-*-*-120-*-*
V-M-*
X        composeTop*composeText*fontList:*-*-*-Medium-R-Normal-*-*-120-*-*-M-
V*
X        mxrn*pointerForeground:  red
X        mxrn*leaveHeaders:  subject, newsgroups, from, reply-to
X        mxrn*sortedSubjects:     on
X        #
X        # the following is recommended for VMS users. Otherwise,
X        # the `60delete' key deletes the wrong way!
X        #
X        *XmText.translations:    \
X        #override \n\
X           Shift<Key>Delete:     delete-previous-character()\n\
X             <Key>Delete:   delete-previous-character()\n\
X           Shift<Key>Linefeed:   delete-next-word()\n\
X             <Key>Linefeed: delete-previous-word()\n\
X           Shift<Key>BackSpace:  end-of-line()\n\
X             <Key>BackSpace:     beginning-of-line()\n\
X            Ctrl<Key>e:         end-of-line()\n\
X            Ctrl<Key>j:         delete-previous-word()\n\
X            Ctrl<Key>h:         beginning-of-line()\n\
X            Ctrl<Key>r:         redraw-display()\n\
X            Ctrl<Key>u:         delete-to-start-of-line()\n
X        \n
X
X
X   FILES
X
X     `7E/.newsrc      description of the groups and the articles read in
X                    each group (SYS$LOGIN:NEWS.RC for VMS)
X     `7E/.oldnewsrc        backup of `7E/.newsrc (created at startup)
X
X
X   X                                                                       2
V5
X
X
X
X
X
X
X   MXRN(1)                                                         3 Mar 199
V3
X
X
X                    (SYS$LOGIN:OLDNEWS.RC on VMS)
X     `7E/.signature        signature for use when sending messages
X                    (SYS$LOGIN:NEWS.SIGNATURE on VMS)
X     `7E/News              directory where articles are saved
X                    (SYS$SCRATCH: on VMS)
X     `7E/Articles          where `60saved' postings and messages are stored
X                    (SYS$SCRATCH:SAVED.POSTING on VMS)
X     `7E/dead.letter       where failed postings and messages are stored
X                    (SYS$SCRATCH:DEAD.LETTERS on VMS)
X     `7E/.xrnlock          lock file (SYS$LOGIN:XRN.LOCK on VMS)
X     /usr/local/lib/rn/server location of the news server hostname
X                    (optional) (SYS$LOGIN:NNTP.SERVER on VMS)
X     /usr/local/lib/news/hiddenhost     location of the hiddenhost name
X                    (optional) (SYS$LOGIN:HIDDEN.HOST on VMS)
X     /usr/local/lib/news/pathhost  location of the path host name
X                    (optional) (SYS$LOGIN:PATH.HOST on VMS)
X     /usr/local/lib/news/domain    location of the domain name
X                    (optional) (SYS$LOGIN:DOMAIN.NAME on VMS)
X     /etc/uucpname       location of the UUCP name for your host
X                    (optional)
X     /usr/lib/sendmail        default mailer
X     CHANGES             list of changes from the previous version
X     TODO           list of bugs and things to do
X
X
X   ENVIRONMENT VARIABLES
X
X     Note: environment variables are implemented as logical names on VMS.
X     NNTPSERVER          hostname of the news server
X     TMPDIR         temporary directory
X     DOMAIN         name of your internet domain (".Berkeley.EDU",
X     ".orst.edu")
X     HIDDENHOST     full domain-style name of the host that you want your
X     return path to be from ("decvax.dec.com", "Berkeley.EDU")
X     HIDDENPATH     name of the host that you want put in the Path field of
X     messages.
X     USER      login name of the user.
X     HOME      home directory of the user.
X     FULLNAME  full name of the user, used for the From field of messages.
X
X   SEE ALSO
X     readnews(1), rn(1), vnews(1), X(1), nntpd(8)
X
X
X   COMMENTS
X
X     The name (mxrn) is a bit of a misnomer.  mxrn is not an X interface to
X     `60rn' (the terminal-based news reading program by Larry Wall), but is
V an
X     X-based news reader that has had part of the functionality of `60rn' ad
Vded
X     since a number of our users are (were?) `60rn' users (all of the code i
Vs
X     new).  Much of the `60rn' functionality that mxrn currently has was not
V in
X     the original plan (KILL files, for example).
X
X     The user interface look and feel is modeled after that of `60XMH' (by
X
X
X   26
V                                                                       X
X
X
X
X
X
X
X   3 Mar 1993                                                         MXRN(1
V)
X
X
X     Terry Weissman).
X
X     The `60.newsrc' file is updated on executing the `60quit' command in
X     Newsgroup mode, during every `60rescan', and by `60checkpoint'.  If the
X     `60updateNewsrc' option is set, the `60.newsrc' file will be updated ev
Very
X     time Article mode is exited.
X
X     mxrn catches signals and X errors and will clean up on error exit
X     (remove temporary files, update the `60.newsrc' file).  The cleanup wil
Vl
X     be done and then a death notifier box will be posted (if the signal is
X     SIGHUP or SIGINT, the death notifier will be skipped and the program
X     will exit).  The "click to exit" button must be pressed in the death
X     notifier box for the program to exit.
X
X     XREFS are handled by mxrn, however only articles that are actually read
X     (not marked as read by 'catchup' or 'mark as read') have their XREFS
X     chased and only groups that are currently subscribed to have XREFed
X     articles marked as read.
X
X     The default specifications for color and fonts can be confusing
X     (thousands of different X resources can be specified for mxrn, no two
X     users' mxrn displays need to be the same).
X
X     mxrn uses the XHDR command of the Berkeley NNTP news server (XHDR is no
Vt
X     part of the protocol defined by RFC 977).  mxrn will detect the presenc
Ve
X     of this command and complain if it does not exist.
X
X     Since the NNTP protocol does not define a unique response code for
X     server timeout, timeout recovery may not work if the format of the
X     timeout error message changes.
X
X     mxrn assumes a `60smart' or `60lucky' mailer.
X
X     mxrn notices that the `60.newsrc' file has been updated by another prog
Vram
X     while mxrn is running and informs the user (and gives the user the
X     option to quit without updating the `60.newsrc' or to continue on).
X
X     Article temporary files can be removed and mxrn will recover.
X
X     mxrn strips `60<character>`5EH' from articles.
X
X     The v`7Bf,s`7Dprintf implementation included with mxrn is from Robert A
V.
X     Larson <blarson@skat.usc.edu>.
X
X     The strtok implementation included with mxrn is from Henry Spencer
X     <henry@zoo.toronto.edu>.
X
X
X   BUGS
X
X     See TODO for a full list of bugs and things that need to be done.
X
X     Incomplete KILL file support.
X
X
X
X   X                                                                       2
V7
X
X
X
X
X
X
X   MXRN(1)                                                         3 Mar 199
V3
X
X
X     See config.h for a list of defines you may want to use based on problem
Vs
X     that may exist in your version of the X11 toolkit and widgets.
X
X     Report bugs and requests for features to `60murphy@ufp.dco.dec.com'
X     (...decwrl!ufp.enet!murphy)
X
X
X   ORIGINAL AUTHORS
X     Ellen M Sentovich (UC Berkeley, ellen@ic.berkeley.edu,
X     ...!ucbvax!ic!ellen)
X     Rick L Spickelmier (formerly UC Berkeley, now Objectivity, Inc.,
X     ricks@berkeley.edu, ...!ucbvax!ricks, ricks@objy.com)
X     See the FIXERS/CHANGES files for a listing of those who have really bee
Vn
X     doing most of the work over the last year or so!
X     Rick Murphy (DEC, Landover MD) VMS, XUI, and Motif port.  note: Ellen
X     Sentovich and Rick Spickelmier are responsible for writing the code.
X     Rick Murphy is responsible for writing the bugs. Don't bother the
X     Berkeley folks with reports of dxrn or mxrn bugs.
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X   28
V                                                                       X
X
X
X`1B9`1B9
$ CALL UNPACK XRN.DOC;6 589441144
$ create 'f'
X#ifndef XRN_H
X#define XRN_H
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/xrn.h,v 1.5 1993/01/
V11 02:15:51 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-2093, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X#ifndef MOTIF
X#define XRN_VERSION "6.18-26 (for XUI)"
X#define TITLE "dxrn 6.18-26"
X#define UNREADTITLE "dxrn 6.18-26 (New News)"
X#else
X#define XRN_VERSION "6.18-26 (for Motif)"
X#define TITLE "mxrn 6.18-26"
X#define UNREADTITLE "mxrn 6.18-26 (New News)"
X#endif
X
X#ifndef VMS
X#include <X11/Intrinsic.h>
X#else
X#include <decw$include/Intrinsic.h>
X#endif
X
X/*
X * xrn.h: set up the main screens
X *
X */
X
X/* global variables that represent the widgets that are dynamically changed
V */
X
Xextern Widget TopLevel;
Xextern Widget MainWindow;`09/* Main window widget */
Xextern Widget Frame;
Xextern Widget MenuBar;`09`09/* Top menu bar */
Xextern Widget TopButtonBox;`09/* button box containing the command buttons *
V/
Xextern Widget BottomButtonBox;`09/* button box containing the article specif
Vic buttons */
Xextern Widget TopInfoLine;      /* top button info line
V                      */
Xextern Widget BottomInfoLine;   /* bottom button info line
V                   */
Xextern Widget TopList;`09`09/* scrollable list window                    */
Xextern Widget ArticleText;
Xextern Widget PopupMenu;`09/* the Popup */
Xextern Widget ArtTopLevel;`09/* Article window */
Xextern Widget ArtWindow;`09/* Article window paned widget */
Xextern Widget ArtMainWindow;`09/* Article Main window widget */
Xextern Widget ComposeTopLevel;`09/* composition frame */
Xextern Widget ComposeText;`09/* composition article */
Xextern Widget HeaderText;`09/* composition header */
X#ifdef TITLEBAR
Xextern Widget TitleBar;
X#endif
X
Xextern int XRNState;
X
Xextern int inCommand;`09`09/* executing a button function`09`09     */
X
X#define XRN_X_UP    0x01
X#define XRN_NEWS_UP 0x10
X
X#define LABEL_SIZE 512
X
X#endif /* XRN_H */
$ CALL UNPACK XRN.H;99 359414143
$ create 'f'
X.TH MXRN 1 "3 Mar 1993" "X"
X.\" $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/xrn.man,v 1.9 1993/
V02/04 18:22:44 ricks Exp $
X.\"
X.\" xrn - an X-based NNTP news reader
X.\"
X.\" Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X.\"
X.\" Permission to use, copy, modify, and distribute this software and its
X.\" documentation for any purpose and without fee is hereby granted, provide
Vd
X.\" that the above copyright notice appear in all copies and that both that
X.\" copyright notice and this permission notice appear in supporting
X.\" documentation, and that the name of the University of California not
X.\" be used in advertising or publicity pertaining to distribution of`20
X.\" the software without specific, written prior permission.  The University
X.\" of California makes no representations about the suitability of this
X.\" software for any purpose.  It is provided "as is" without express or
X.\" implied warranty.
X.\"
X.\" THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X.\" THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`2
V0
X.\" FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X.\" ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X.\" RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X.\" CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X.\" CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X.\"
X.ds XR \fImxrn\fP
X.ds NS `60.newsrc'
X.ds NG \fBNewsgroup\fP
X.ds AR \fBArticle\fP
X.ds AL \fBAll\fP
X.ds AD \fBAdd\fP
X.ds XD `60`7E/.Xdefaults'
X.\"
X.SH NAME
Xmxrn/dxrn \- an X-based interface to the USENET news system that uses the
XNNTP remote news server
X.\"
X.SH SYNOPSIS
X\*(XR is an X-based interface to the USENET news system
Xthat uses the NNTP remote news server for accessing newsgroups
Xand articles.
XBy using the NNTP server, users can read news from personal workstations
Xwith the program accessing the news groups and articles from a central
Xrepository on the local area network.
XThis manual page applies to version 6.18.
X.\"
X.SH DESCRIPTION
X.PP
X.nh
X\*(XR
X`5B-addBindings bindings`5D
X`5B-addButtonList list`5D
X`5B-addPopupList list`5D
X.br
X`5B-allBindings bindings`5D
X`5B-allButtonList list`5D
X`5B-allPopupList list`5D
X.br
X`5B-artBindings bindings`5D
X`5B-artButtonList list`5D
X`5B-artPopupList list`5D
X.br
X`5B-artSpecButtonList list`5D
X`5B+/-authorFullName`5D
X`5B-authorLength len`5D
X.br
X`5B+/-autoRead`5D
X`5B+/-autoWrap`5D
X`5B+/-busyIcon`5D
X`5B-busyIconName`5D
X.br
X`5B-busyIconPixmap`5D
X`5B+/-cc`5D
X`5B+/-ccForward`5D
X`5B-compBreakLength len`5D
X.br
X`5B-compLineLength len`5D
X`5B-compRows rows`5D
X`5B+/-confirm list`5D`20
X.br
X`5B-deadLetters file`5D
X`5B-defaultlines num`5D
X`5B+/-delayedPrint`5D
X.br
X`5B+/-displayLineCount`5D
X`5B+/-displayLocalTime`5D
X.br
X`5B-distribution dist`5D
X`5B+/-dumpCore`5D
X`5B-editorCommand command`5D
X.br
X`5B+/-executableSignatures`5D
X`5B+/-extraMailHeaders`5D
X`5B-hostName hostname`5D
X.br
X`5B-iconGeometry +X+Y`5D`20
X`5B-ignoreNewsgroups list`5D
X`5B-includeCommand command`5D
X.br
X`5B+/-includeHeader`5D
X`5B-includePrefix "prefix text"`5D
X`5B+/-includeSep`5D
X.br
X`5B+/-info`5D
X`5B+/-killFiles`5D`20
X`5B-layout geometry`5D
X`5B-leaveHeaders list`5D
X.br
X`5B+/-localSignatures`5D
X`5B-lockFile name`5D
X`5B-mailer "mailer command"`5D
X.br
X`5B-maxLines number`5D`20
X`5B-mhPath path`5D
X`5B-minLines number`5D
X`5B-newsrcFile file`5D`20
X.br
X`5B-ngBindings bindings`5D
X`5B-ngButtonList list`5D
X`5B-ngPopupList list`5D
X.br
X`5B-nntpServer name`5D`20
X`5B-onlyShow num`5D
X`5B-organization organization`5D
X.br
X`5B+/-pageArticles`5D
X`5B-personalName "name"`5D
X`5B-pointerBackground`5D
X.br
X`5B-pointerForeground`5D
X`5B-popupButton button`5D
X`5B-printCommand command`5D
X.br
X`5B-replyPath mailPath`5D
X`5B-replyTo name`5D
X`5B-rescanTime time`5D
X`5B+/-resetSave`5D
X.br
X`5B+/-retainKilled`5D
X`5B-retryLimit count`5D
X`5B-retryPopupCount count`5D
X.br
X`5B-retryPopupTimeout secs`5D
X`5B-retryPause secs`5D
X`5B-saveDir directory`5D
X.br
X`5B-saveMode mode`5D
X`5B-saveNewsrcFile file`5D`20
X`5B-savePostings file`5D`20
X.br
X`5B-saveString string`5D
X`5B-signatureFile file`5D`20
X`5B+/-signatureNotify`5D`20
X.br
X`5B-sortedSubjects sort-type`5D
X`5B-stripHeaders list`5D
X`5B-subjectLength len`5D
X.br
X`5B+/-subjectRead`5D`20
X`5B-tmpDir directory`5D
X`5B-topLines number`5D
X.br
X`5B-unreadIconName "name"`5D
X`5B-unreadIconPixmap pixmap`5D
X`5B+/-updateNewsrc`5D
X.br
X`5B+/-useGadgets`5D
X`5B+/-verboseKill`5D
X`5B+/-watchProgress`5D
X`5B-watchUnread list`5D
X.br
X`5B+/-xrefMarkRead`5D
X.\"
X
XAlong with the standard toolkit options:
Xdisplay, geometry, xrm, and iconic.
X.\"
X.SH BASIC OPERATION
X.PP
X\fBDon't let the size of this manual page alarm you.\fP
X\*(XR is easy to learn on-line without reading
Xthe documentation.
XThis manual page describes many features that may be obvious to the
Xcasual observer, along with a large section on customization
X(such as choosing colors and fonts).
XIt also describes how to use scroll bars, buttons, and select text;
Xif you have used an X toolkit application before, the section
Xtitled "BUTTONS, SCROLL BARS, and SELECTION" can be skipped.
X.PP
X\*(XR uses the \*(NS file to determine what groups need to be read.
XIf the \*(NS file does not exist, it is created, and the
Xuser is subscribed to the news group `60news.announce.newusers'.
X.PP
X\*(XR has four modes of operation: \*(AD, \*(NG, \*(AL,
Xand \*(AR modes.
X\*(AD mode will be entered on startup if there are any groups
Xthat the news system knows about that are not in the \*(NS file
X(\fIi.e.,\fP new groups).
XIn \*(AD mode, the user is given a list of new groups.
XGroups can then be subscribed to and placed in the \*(NS file
Xat the first position, the last position, or after a group already
Xin the \*(NS file.
XWhen \*(AD mode is exited, any remaining groups are
Xadded unsubscribed, so the user is not asked about them the
Xnext time \*(XR is started.
XOn exit from \*(AD mode, or on startup if there are no new groups,
X\*(NG mode is entered.
X\*(NG mode displays the subscribed to groups that have unread
Xarticles and the range of available articles.
XThe basic functions available in this mode allow the user to
Xread a group, mark all articles in a group as read, unsubscribe from a group
V,
Xmove the cursor around the newsgroup window,
Xchange the order of the list of newsgroups,
Xre-visit the most recently visited group, and quit \*(XR.
XIn addition, the user can
Xsubscribe to a group and specify its position in the \*(NS file,`20
Xquery the news server for new articles and groups, and
Xgo to groups that are either not subscribed to or currently have
Xno unread articles (\fIi.e.,\fP groups not displayed on the screen).
X.br
XFrom \*(NG mode the user can go into \*(AL mode.
XIn \*(AL mode the user is presented with a sorted list of
Xall known groups and their subscription status (subscribed
Xor unsubscribed) and can change their status or location
Xin the \*(NS file.
XOn exiting \*(AL mode the user is placed back in \*(NG mode.
X.br
XIn order to read the articles in a particular group, the user goes
Xfrom \*(NG mode to \*(AR mode.
XIn \*(AR mode the user can sequence through the articles in
Xthe group forward or backward, mark a group of articles
Xas read or unread, mark all articles in the current group
Xas read, unsubscribe to the current group,`20
Xreturn to the last article visited, search forward or backward
Xfor an article subject (either for the exact subject or for
Xa regular expression in the subject), locally kill all articles with a
Xparticular subject, and quit (saving all changes) or exit
X(leaving all articles marked unread).
XIn addition, the user can save the current
Xarticle in a file, post an article to the group, post a followup
Xto the current article, mail a reply to the author of an article, and
Xreturn to \*(NG mode.
X.\"
X.SH NEWS SYSTEM
X.sp
XThe news system is a set of bulletins, discussion groups, program sources,
Xand other bits of information distributed around the world under the
Xname `60USENET'.
XThe information is generally called `60news' and is broken up into
X`60newsgroups'.
XEach newsgroup deals with a subject or set of subjects.
XThe subjects for newsgroups are varied:  from discussions about particular
Xversions of UNIX to movie reviews, from information on the X window system
Xto commentary on current social and political issues.
X.PP
XFor information on what newsgroups are available, answers to commonly
Xasked questions, and newsgroup etiquette, read the articles in the
Xnewsgroup `60news.announce.newsusers'.  Users who are new to the USENET
Xare strongly encouraged to become familiar with the contents of the
Xarticles in `60news.announce.newusers' before posting any messages.
X.\"
X.SH NEWS SERVER
X.PP
XIn order to run \*(XR, you must have access to an NNTP news server.
XIf you do not have access to such a server and would like to set one
Xup, see the "USENET Software:
XHistory and Sources" posting in news.announce.newusers for information
Xabout where to get the appropriate software.
XEither the file `60/usr/local/lib/rn/server' (this filename may be
Xconfigured differently at some sites) must contain the name
Xof the server machine, the environment variable NNTPSERVER must be
Xset to the name of the server machine, the
X\fBnntpServer\fP Xdefault must be set to the name of the server machine,
Xor the `60-nntpServer' flag must be specified on the command line
X(with the order of precedence being command line,
XXdefault, environment variable, file).
XThe name can be the actual host name of the NNTP server
X(i.e. shambhala.berkeley.edu) or the internet number (i.e. 128.32.132.54).
XIf someone else has installed \*(XR at your site,
Xthen it is probably already configured to use the correct news server
Xand you don't have to worry about it.
X.\"
X.SH SCREEN LAYOUT
X.PP
XThe screen displayed by \*(XR consists of seven sections:
Xa title bar, two scrollable text windows, two information bars,
Xand two button boxes.
XThe title bar displays the current version of the program.
XThe top text window displays information based on the mode.
XIn \*(AD mode, the window displays all groups that are
Xnot currently in the \*(NS file, one per line.
XIn \*(NG mode, the
Xwindow displays the groups containing unread articles;
Xeach group represented by a line of the form:
X.sp
X.ce 100
XUnread news in <group name>           <num> article(s) + <old> old
X.ce 0
X.sp
X<group name> is the name of the group,
X<num> is the number of unread articles, and <old> is the number of
Xread articles that are still available (i.e. have not been expired) on
Xthe news server.  If "List old" is toggled on, then the word "Unread"
Xwill not appear on the lines of newsgroups with no unread articles,
Xand furthermore, the words "news in" will not appear on the lines of
Xnewsgroups with no available articles at all.
X.PP
XIn \*(AR mode, the window displays a list of subjects
Xfor the articles in the current group, with each subject line
Xbeing represented by a line of the form:
X.sp
X.ce 100
X`5B+u`5D`5BSP`5D <num>    <subject of the article> `5B<lines>`5D <author>
X.ce 0
X.sp
Xwhere <num> is the article number, <lines> is the number of lines in
Xthe article (when available), and <author> is the author of the
Xarticle.  A `60+' in the first position
Xmeans that the article has been read, a `60u' in the first position
Xmeans that the article has been marked as unread, a 'S' in the second
Xposition means that the article has been saved to a file, and a 'P' in
Xthe second position means that the article has been printed.
X.PP
Xin the top button box, and error messages.
XThe top button box has buttons that are specific to the mode
Xand apply to the information in the top text window.
XThe bottom text window displays articles in \*(AR mode
Xand a list of all known groups and their subscription status in \*(AL
Xmode.
XThe bottom information bar displays information about the mode,
Xthe buttons in the bottom button box, and error messages.
XThe bottom button box has buttons that are specific to the mode
Xand apply to the information in the bottom text window.
X.SH BUTTONS, SCROLL BARS, AND SELECTION
X.PP
XAll button and text selection commands are done with the
Xleft mouse button.
XSingle-line text selection is accomplished by
Xclicking the left mouse button on the desired line.
XMultiple-line selection is accomplished by clicking the
Xleft mouse button on the first line, holding the button down,
Xdragging the mouse to the last line, and releasing the mouse button.
XExtended selection can be done by clicking on an article or range of
Xarticles, then using shift-click to add or remove an article from the
Xselection.
XSelected lines appear in reverse video (the foreground and background
Xcolors are switched).
XThe text windows are scrolled with the scroll bar on the
Xright side of the window.
XClicking the left mouse button in the scroll bar will scroll the
Xtext up or down some fraction of a page; the `60slider' or `60elevator' in t
Vhe
Xscrollbar can be dragged to perform more rapid scrolls.
X.\"
X.SH MODES
X.PP
XThe next few sections describe the individual modes in \*(XR.
XEach button in the various modes is described with the label for the button
Xand the name of the button.
XThe name of the button can be used in X resources, in the button
Xlists, and in the bindings tables.`20
X.br
XNote that not all buttons will appear in the button boxes; you can use the
Xcustomization menus to determine which functions appear in the button boxes
Xand popup menus. See the section of this manual titled `60CUSTOMIZATIONS' fo
Vr
Xfurther information.
X.\"
X.SH ADD MODE
X.PP
X\*(AD mode is entered when new groups have been detected
X(groups that the news system knows about but are not in the \*(NS file).
X.br
XThis allows you to determine what to do to these groups (subscribe or ignore
Xthem).
X.IP "Quit (addQuit)"
XAdd remaining groups in the list to \*(NS as unsubscribed;
Xgo to group mode.
X.IP "Add First (addFirst)"
XAdd the current group(s) to the beginning of the \*(NS file and
Xmark as subscribed.
XThe current group is the selected group(s), or the group
Xon the line containing the cursor.
X.IP "Add Last (addLast)"
XAdd the current group(s) to the end of the \*(NS file and
Xmark as subscribed.
X.IP "Add After Group (addAfter)"
XAdd the current group(s) after a group already in the \*(NS.
XA dialog box is used to allow the user to enter the name of the
Xgroup to add the group after.
XThe mouse cursor must be in the dialog box
Xfor \*(XR to accept text (however, it does not have to be
Xin the type-in area).
XThe dialog box has two options: \fBabort\fP and \fBadd\fP.
XNo other buttons on the screen will work until the user
Xhas selected an option in the dialog box.
XHitting carriage return is the same as clicking the
X\fBadd\fP button (in all \*(XR dialog boxes hitting carriage
Xreturn is the same as clicking in the rightmost button of the
Xdialog box).
X.IP "Add Unsubscribed (addUnsub)"
XAdd the current group(s) to the end of the \*(NS file
Xand mark as unsubscribed.
X
X.SH NEWSGROUP MODE
X.PP
X\*(NG mode is normally the mode that \*(XR starts up in. The window at the
Xtop of the screen displays the list of subscribed groups that have new news
Xarticles (ones that you haven't read) and provides control over which groups
Xare visited.
X.br
XDouble clicking the left mouse button on a newsgroup entry will enter the
Xnewsgroup.
X.IP "exit (ngExit)"
XQuit \*(XR, leaving the \*(NS file unchanged since the
Xlast `60rescan' operation or `60checkpoint'.
XIf `60updateNewsrc' is on, then the \*(NS file is kept up to
Xdate with the last time \*(AR mode was exited.
X.IP "Quit (ngQuit)"
XQuit \*(XR. The \*(NS file is updated to account for the articles read
Xand \*(XR exits.
X.IP "Read Group (ngRead)"
XRead the articles in the current group.
XThe current group is either the one selected (if one is selected)
Xor the first group in the list. The first article in the group is read, if
Xthe `60Auto Read' flag is turned on. The `60Open Newsgroup' function can be
V used
Xto avoid reading the first article.
X.br
XIf all groups have been read, the user can still access
Xgroups by using the \fBgoto newsgroup\fP command.
X.IP "Open Group (ngOpen)"
XOpen a newsgroup without reading the first article. This command is useful
Xfor groups with large articles, such as source groups, where you may not wan
Vt
Xto read the initial article.
X.br
XThe current group is either the one selected (if one is selected)
Xor the first group in the list.`20
X.IP "Next (ngNext)"
XMove the cursor to the next group, leaving the articles in
Xthe current group untouched.
X.IP "Prev (ngPrev)"
XMove the cursor to the previous group, leaving the articles in
Xthe current group untouched.
X.IP "Catch Up (ngCatchUp)"
XMark all articles in the current group as read.
X.IP "Subscribe (ngSubscribe)"
XSubscribe to a group.
XA dialog box is used to allow the user to enter the
Xname of the group.
XThe dialog box has the following options:
X\fBabort\fP,`20
X\fBprev group\fP (subscribe to the previous group visited),
X\fBfirst\fP (put group in the beginning of the \*(NS file),
X\fBlast\fP (put group in the end of the \*(NS file), and
X\fBcurrent position\fP (put group at the position of the cursor).
XThis command can also be used to change the position of a subscribed
Xgroup.
XHitting carriage return after typing in the name is the same as
Xclicking the \fBcurrent position\fP button.
X.IP "Unsubscribe (ngUnsub)"
XUnsubscribe from the current group.
X.IP "Goto Newsgroup (ngGoto)"
XGo to an arbitrary newsgroup. The first unread article is displayed.
XIf all articles in the group have been read, the last
Xarticle in the group is displayed.
XThe name specified can be a substring of the group name or
Xa regular expression.
X.IP "Toggle Groups (ngToggleGroups)"
XToggle group display mode from verbose mode (showing information on all
Xsubscribed groups) to normal mode (showing information only on subscribed
Xgroups with new news).
X.IP "All Groups (ngAllGroups)"
XDisplay all of the groups that exist, their subscription status,
Xand a set of buttons for changing the status.
X.IP "Rescan (ngRescan)"
XQuery the server for any new groups or articles.
X.IP "Prev Group (ngPrevGroup)"
XRe-visit the previous group visited.
X.IP "Select Groups (ngSelect)"
XRecords the groups currently selected.
XIf no groups are selected, nothing is recorded.
X.IP "Move (ngMove)"
XMoves the groups previously selected with the
X\fBselect groups\fP command to the current cursor position.
XIf the cursor is currently inside the groups
Xto be moved, no groups are moved.
XIf any other button is invoked after
X\fBselect groups\fP and before \fBmove\fP,
Xthe selection is lost, and no groups are
Xmoved.
X.IP "Checkpoint (ngCheckPoint)"
XUpdate the \*(NS file. `20
X\*(XR normally updates the \*(NS file on `60rescan' and `60quit'
Xin \*(NG mode.`20
XThis allows you to update the \*(NS file without exiting \*(XR
Xor reconnecting to the server (see also 'artCheckPoint').
X.IP "Post (ngPost)"
XPost an article to a newsgroup. `20
XSee "post" under \*(AR mode for more information.
X.IP "Gripe (ngGripe)"
XSend a gripe (bug, bug fix, complaint, feature request, etc.) to
Xthe authors of the program.
X.\"
X.SH ALL MODE
X.PP
X\*(AL mode allows the user to change both the subscription status
Xand the \*(NS file position of any available group.
XAll operations can apply to multiple groups.
XThus, the user should never have to use a text editor on the \*(NS file.
X.br
XDouble-clicking on a newsgroup name in the list will cause the group
Xto be read. You can use the `60open group' function to open a group without
Xreading the first article.
X.IP "Quit (allQuit)"
XUpdate the \*(NS file and return to group mode.
X.IP "Subscribe (allSub)"
XSubscribe to the current group, leaving it
Xat its current position in the \*(NS file.
X.IP "Subscribe First (allFirst)"
XSubscribe to the current group and add it to
Xthe beginning of the \*(NS file.
X.IP "Subscribe Last (allLast)"
XSubscribe to the current group and add it to the end of the \*(NS file.
X.IP "Subscribe After Group (allAfter)"
XSubscribe to the current group and add it after a particular group
Xin the \*(NS file (which is entered with the use of a dialog box).
X.IP "Unsubscribe (allUnsub)"
XUnsubscribe the current group.
X.IP "Goto Group (allGoto)"
XGo to the current newsgroup.
X.IP "Open Group (allOpen)"
XOpen a newsgroup without automatically reading the first article.
XThe currently selected group (or the first group in the selection) is opened
V.
X.IP "Select Groups (allSelect)"
X.IP "Move (allMove)"
XSame as the "select groups" and "move" buttons in \*(NG mode.
XThese functions are used to re-order groups.
X.IP "Toggle Order (allToggle)"
XToggle the order of the newsgroups in the window between \*(NS order
Xand alphabetical order.
X.IP "Scroll Forward (allScroll)"
XScroll the all groups window forward a page.
X.IP "Scroll Backward (allScrollBack)"
XScroll the all groups window backwards a page.
X.IP "Search (allSearch)"
XSearch the all groups window for a group.
X.IP "Continue Search (allContinue)"
XContinue the all groups search.
X.IP "Cancel Search (allCancelSearch)"
XCancel the all groups search.
X.\"
X.SH ARTICLE MODE
X.PP
X\*(AR mode is used for reading and manipulating articles in a single group.
XWhen a group is entered, the list of article subjects
Xdisplayed contains those from the first unread
Xarticle to the last available article.
XPrevious articles can be obtained by using the \fBprev\fP or
X\fBsubject previous\fP commands.
XDouble clicking the left mouse button on an article entry will display the
Xarticle.
X.IP "Quit (artQuit)"
XUpdate the \*(NS file and return to group mode.
X.IP "Next (artNext)"
XDisplay the selected article, if any; otherwise,
Xdisplay the next article in the current group.
XReturn to \*(NG mode after the last article has been reached.
X.IP "Next Unread (artNextUnread)"
XDisplay the selected article if it is unread; otherwise,
Xdisplay the first unread article AFTER the cursor position.
XIf no unread articles exist, \*(XR returns to \*(NG mode.
X.IP "Prev (artPrev)"
XDisplay the selected article, if any; otherwise,
Xdisplay the previous article in the current group.
X.IP "Last (artLast)"
XDisplay the last article accessed before the
Xcurrently displayed one.
XThis command only keeps track of one previously
Xaccessed article, so invoking it repeatedly
Xsimply toggles the display between two articles.
X.IP "Next Newsgroup (artNextGroup)"
XGo directly to the next newsgroup with unread news
X(bypass newsgroup mode).
X.IP "Goto Article (artGotoArticle)"
XGo to the specified article number. Articles read in previous sessions can
Xbe accessed using this command.
X.IP "Catch Up (artCatchUp)"
XMark all articles in the current group as read;
Xreturn to \*(NG mode.
XIf a particular article is selected, catch up from the
Xbeginning of the group to the selected article.
X.IP "Fed Up (artFedUp)"
XMark all articles in the current group as read;
Xgo to the next newsgroup.
X.IP "Mark Read (artMarkRead)"
XMark an article (or group of articles) as read.
XThis command marks either the selected article(s)
Xor the article the cursor is on, and leaves
Xthe cursor at its current position.
X.IP "Mark Unread (artMarkUnread)"
XMark an article (or group of articles) and unread.
XThis command marks either the selected article(s)
Xor the article the cursor is on, and
Xleaves the cursor at its current position.
XWhen an article is marked as unread, a 'u' is
Xplaced in the far left column next to the article's
Xsubject.
XThe \fBnext\fP, \fBprev\fP, \fBsubject next\fP,
Xand \fBsubject prev\fP buttons will all display
Xthis article if they come across it, but the
X\fBnext unread\fP button will not.
XThe only way to mark an article as read once
Xit has been marked with a 'u' is to use the
X\fBmark read\fP function.
X.IP "Unsubscribe (artUnsub)"
XUnsubscribe from the current group; return to \*(NG mode.
X.IP "Scroll Forward (artScroll)"
XScroll the article text forward a page.
X.IP "Scroll Backward (artScrollBack)"
XScroll the article text backward a page.
X.IP "Scroll End (artScrollEnd)"
XScroll the article text to the end.
X.IP "Scroll Beginning (artScrollBeginning)"
XScroll the article text to the beginning.
X.IP "Scroll Line (artScrollLine)"
XScroll the article text forward one line.
X.IP "Scroll Back Line (artScrollBackLine)"
XScroll the article text backward one line.
X.IP "Subject Next (artSubNext)"
XFind and display the next article with the same subject as the current artic
Vle
X(stripping the '`5BrR`5D`5BeE`5D:' garbage).
XIf there are no more articles with the current subject and
Xthere are more unread articles, the first unread article is
Xselected.
XIf there are no more articles with the current subject and there
Xare no more unread articles, \*(AR mode is exited.
X.IP "Subject Prev (artSubPrev)"
XFind and display the previous article with the same subject
Xas the current article. The search will proceed past the current list of
Xarticles to scan articles read in previous sessions.
X.IP "Session Kill (artKillSession)"
XMark all articles with the current subject as read, for
Xthis session only.
X.IP "Local Kill (artKillLocal)"
XMark all articles with the current subject as read for this group,
Xand for this and all future sessions.
X.IP "Global Kill (artKillGlobal)"
XMark all articles with the current subject as read for all groups,
Xand for this and all future sessions.
X.IP "Author Kill (artKillAuthor)"
XMark all articles by the current author as read for this session only.
X.IP "Subject Search (artSubSearch)"
XBegin a regular expression subject search.
XWhen this button is invoked, a window pops up
Xquerying the user for a regular expression (of the
Xform used in \fBed\fP), and a direction in which to
Xsearch.
XIf a regular expression is not typed in, the
Xlast regular expression is used, and the search direction
Xis the one specified in the dialog box (this
Xcan be used to switch the direction of the search
Xwithout retyping the expression).
X.IP "Continue (artContinue)"
XContinue the last regular expression search
Xby searching for the same regular expression
Xin the same direction.
X.IP "Cancel Search (artCancelSearch)"
XCancel the regular expression search.
X.IP "Article Order (artNonSorted)"
XChange the order of entries in the subject window to be sorted by
Xarticle number.
X.IP "Subject Order (artSorted)"
XChange the order of entries in the subject window to be sorted by
Xarticle number, with groups of articles with the same subject
Xgrouped together.
Xor sorted by subject.
X.IP "Strict Order (artStrictSorted)"
XChange the order of entries in the subject window to be sorted by
Xthe subject only. (This can be useful for sources groups).
X.IP "Post (artPost)"
XPost an article to the current group.
XA scrollable, editable text window will appear with
Xa header and the user's appropriate signature file included.
XThe appropriate signature file is the usual signature file name
X`60`7E/.signature' followed by either a `60-' and a  newsgroup name
Xsubstring, or followed by a `60.' and `60followup', `60forward', `60gripe',
X`60reply' or `60post' according to the posting mode.  For example if you
Xwant to post a followup article in comp.sources.x then xrn uses the
Xfirst valid signature file in the following order:
X.sp
X.in +0.5i
X.nf
X`7E/.signature-comp.sources.x
X`7E/.signature-comp.sources
X`7E/.signature-comp
X`7E/.signature.followup
X`7E/.signature
X.fi
X.in -0.5i
X.sp
XAn appropriate header will be generated with a number
Xof blank header fields that if left blank will be
Xdeleted from the posting.
XThe editor defaults to the standard Xtoolkit editor,
Xand the default can be overridden
Xby using the command line option -editorCommand or by
Xsetting the same Xdefault (see the section on command
Xline arguments).
XThe mouse buttons can be used to select text in this window (which can then
V be
Xplaced in a file, for example).
X.sp
XThere are four buttons at the bottom of the window: \fBabort\fP,
X\fBsend\fP (to post the article), \fBsave\fP (to save the article
Xin a file), and \fBinclude\fP (include the text of the article in
Xthe reply or followup).
XThe \fBinclude article\fP button is
Xomitted if there is no current article (e.g. if the user is sending a
X"Gripe" or if "post" was selected from \*(NG mode).
XOnly one article or message window can be active at a time.
XOnly one post (or followup or reply) window can be active at a time.
X.IP "Exit (artExit)"
XExit article mode, marking all articles listed
Xin the top window as unread.
X.IP "Checkpoint (artCheckPoint)"
XUpdate the \*(NS file. `20
X\*(XR normally updates the \*(NS file on `60rescan' and `60quit'
Xin \*(NG mode.`20
XThis allows you to update the \*(NS file without exiting \*(XR
Xor reconnecting to the server (see also 'ngCheckPoint').
X.IP "Gripe (artGripe)"
XSend a gripe (bug, bug fix, complaint, feature request, etc.) to
Xthe authors of the program.
X.IP "List Old (artListOld)"
XList all articles available in the group, even those that have been read.
XNote that this button does not toggle (clicking this button twice will no
Xput you back to where you were).
X.IP "Save (artSave)"
XSave the current article in a file, or use the current article
Xas standard input to a command.
XThe save command will pop up a dialog box for the filename.
XThe dialog box has two buttons: \fBabort\fP and \fBsave\fP.
XIf the filename begins with a `60`7C', the article will be sent to the comma
Vnd
Xspecified after the `60`7C'.
XOtherwise, the article will be appended to the file specified.
XIf the name is relative (does not begin with `60/' or `60`7E'), it will be
Xprepended by `60`7E/News/'.
XIf the name begins with a `60+' the name is assumed to be a MH mail
Xfolder and a `60refile' command will be done on the article.
XIf no name is specified, it will be saved in `60`7E/News/<groupname>', where
X`60<groupname>' is the name of the current group with the first letter
Xcapitalized (following the
X.IR rn (1)
Xarticle saving conventions).
XIf \-saveMode is set to `60subdirs', then `60`7E/News/<groupname>/' will
Xbe used instead of `60`7E/News/'. Multiple articles can be selected and save
Vd
Xwith one command. If the filename contains the characters `60%d', the articl
Ve
Xnumber will replace that string; otherwise, the group of articles will be
Xappended into a single save file.
XFor VMS, piping of articles to commands (`60`7C') is not supported.
XFile names are used as given. If no filename is given in a `60save' command,
Xthe group name will be used for a filename (with second and subsequent perio
Vds
Xconverted to underscores; for example, `60comp.os_vms'. Subdirs save mode on
XVMS uses the group name to create a subdirectory for saving the articles.
X.IP "Reply (artReply)"
XReply (by mail) to the author of the current article.
XSee \fBpost\fP for a description of how to create and send a message.
X.IP "Forward (artForward)"
XSend the current article to another person via mail.
X.IP "Followup (artFollowup)"
XPost a followup article to the current article.
XSee \fBpost\fP for a description of how to create and send an article.
X.IP "Cancel (artCancel)"
XCancel the current article.
X.IP "Rot-13 (artRot13)"
XDecrypt a encrypted article.
XIn the newsgroup `60rec.humor', occasionally articles are submitted
Xthat may offend certain people or groups of people.
XIn order to minimize the offense, these articles are posted in
Xan encrypted form.
XThis button will decrypt them.
X.IP "Translate (artXlate)"
XTranslate article from ISO 646 to ISO 8859-1.
X.IP "Toggle Header (artHeader)"
XShow the full text of an article, including the full header.
X.IP "Print Article (artPrint)"
XSend the article to the printer (see the `60printCommand' command
Xline option).
X
X.SH CUSTOMIZING MXRN
X.PP
XColors, fonts, and other \*(XR options can be
Xspecified on the command line or using X resources.
XWith the exception of the display name, all \*(XR options
Xcan be specified using X resources.
XOptions specified on the command line take precedence over those specified
Xusing X resources. In addition, \*(XR has a set of customization screens
Xthat can be used to tailor the environment without editing resource files.
XFor each customization entry below, the corresponding resource entry and
Xcustomization menu entry are described.
X
X.SH CUSTOMIZATIONS
X.PP
XThe majority of the customization functions are available in any \*(XR mode
Xby selecting the entries from the `60Customize' menu. For each of the
Xentries in this menu, the section below describes the function and the
Xassociated command-line argument. Note that the case of the entries given
Xfor the resource file and command line are case-sensitive - they must be
Xentered exactly as given.
X.br
XThe following sections describe the fields on each of the customization
Xscreens and their function.
X.TP 5
X.B Customize/Controls
XThis box provides a series of options for functions that the user wishes
Xto confirm before actions are taken. These boxes pop up to ask the user to
Xverify the invocation of "dangerous" actions (such as \fBcatch up\fP
Xand \fBunsubscribe\fP). It also provides control of `60save' functions.
X.TP 10
X.B Confirm Exit
XIf active, provides a dialog box to allow you to confirm `60quit' operations
V.
X.TP 10
X.B Confirm Exit
XIf active, provides a dialog box to allow you to confirm `60exit' operations
V.
X.TP 10
X.B Confirm NG Catch Up
XIf active, provides a dialog box to allow you to confirm `60Catch Up' operat
Vions
Xin \*(NG mode.
X.TP 10
X.B Confirm Article Catch Up
XIf active, provides a dialog box to allow you to confirm `60Catch Up' operat
Vions
Xin \*(AR mode.
X.TP 10
X.B Confirm NG Unsubscribe
XIf active, provides a dialog box to allow you to confirm `60Unsubscribe'
Xoperations in \*(NG mode.
X.TP 10
X.B Confirm Article Unsubscribe
XIf active, provides a dialog box to allow you to confirm `60Unsubscribe'
Xoperations in \*(AR mode.
X.TP 10
X.B Action Prompt at Subject Change
XIf active, provides a dialog box to allow you to decide what to do when
Xthe subject changes when reading articles.
X.TP 10
X.B Confirm Save file Overwrite
XIf active, allows you to specify what to do when a save operation finds
Xthe file you've specified already exists (replace, append, or quit).
XThe default is to append to the existing file.
X.TP 5
X.B Customize/Controls Save fields
XThese fields modify the behavior of save operations.
X.TP 10
X.B Mailbox
XIf enabled, articles are saved in 'mailbox' format - with a date header
Xline and other data to make the saved file appear to be in a format similar
Xto mail storage.
X.TP 10
X.B Headers
XIf enabled, all the header lines are saved with the article. If disabled,
Xthe article is saved as displayed (with any headers stripped as controled
Xby the `60leave headers' and `60strip headers' customizations applied.)
X.TP 10
X.B Subdirectory/One Directory
XThese controls determine how articles are saved if no directory path is
Xgiven; if `60Subdirectory' is enabled, the article is saved in a subdirector
Vy
Xof your news directory - this subdirectory is determined from the newsgroup
Xname. If `60One Directory' is enabled, the file is saved in the news directo
Vry.
XIf neither is enabled, the file is saved in your current working directory.
X.br
X.TP 5
X.B Customize/Posting
XThis box provides a series of options for controlling the posting of
Xarticles and followups.
X.TP 10
X.B Line Length/Wrap Length
XThese fields determine the behavior of word wrapping of articles.
XAny line that exceeds `60Wrap Length' characters in width will be word-wrapp
Ved
Xat the first space past the column determined by `60Line Length'.`20
XIf they are both zero, no word-wrapping takes place.
X.TP 10
X.B Signature File
XThis field provides the path to the file containing your `60signature' - any
Xpostings or mailings have the contents of this file appended. Generally used
Xto add mail address and witty sayings. The length of
Xthis file is limited to avoid `60War and Peace' signatures.
XDefaults to `60`7E/.signature'. (SYS$LOGIN:NEWS.SIGNATURE on VMS).
X.TP 10
X.B Save Postings
XThis field gives the file name of the file to use to save postings (used
Xwhen the `60save' function in the composition window is invoked.
XDefaults to `60`7E/Articles'. (SYS$SCRATCH:SAVED.POSTING on VMS.)
XNote that this is the default name used when you do not specify a
Xfile name during a save operation.
X.TP 10
X.B Dead Letters
XThis field gives the file name of the file to use to save an article that
Xcould not be posted due to an error.
XDefaults to `60`7E/dead.letters'. (SYS$SCRATCH:DEAD.LETTER on VMS).
X.TP 10
X.B Editor Command
XThis entry allows use an alternate editor for creating postings, followups,
Xforwards, gripes, and replies.
XThe entry must be a sprintf format string that contains a `60%s' where
Xthe file name should be placed. Examples are:
X.sp
X.in +0.25i
X.nf
Xxterm -e vi %s
Xxterm -e microEmacs %s
Xemacsclient %s
Xedit/tpu/display=decwindows %s `5Bonly VMS could be this verbose :-)`5D
X.fi
X.in -0.25i
X.sp
XThe resulting command should handle all editing and windowing.
XThe article being followed up or replied to is automatically included.
X.br
X.TP 10
X.B Organization
XThis field provides a value for the `60Organization' header field in posting
Vs
Xand followups. Usually set to the name of your company or other organization
V.
X.TP 10
X.B Reply To
XThis entry provides a specific address for the the Reply-To header field in
Xpostings and followups. Most news readers use this address for `60reply'
Xcommands.
X.TP 10
X.B Include Separator
XInclude or do not include the prefix text ("`7C> ") in front of included
Xarticles. The default is to include the prefix text ("`7C> ").
X.TP 10
X.B Include Prefix
XChange the standard prefix for each line of included text from the
Xdefault, "`7C> ", to the given text string.
X.br
X.TP 5
X.B Customize/Reading
XThis box provides a series of options for controlling the reading of article
Vs.
X.TP 10
X.B Subject Read
XSpecifies the action to take when using the `60doTheRightThing' function to
Xread articles. If this button is enabled, at the end of the article a
X\fBsubject next\fP function is performed. If disabled, a \fBnext unread\fP
Xfunction is performed.
X.TP 10
X.B Retain Killed
XIf enabled, articles that are killed are left in the subject listing.
XIf disabled, these articles are removed from the list.
X.TP 10
X.B Full Name
XDisplay the full name of the author or the user/hostname of the author.
XIf enabled, the entry contains the author's personal name. If disabled,
Xthe entry contains the author's path name.
X.TP 10
X.B Show Line Count
XIf enabled, the number of lines in the article (when available) is displayed
Xin the subject lines.
X.TP 10
X.B Auto Wrap
XIf enabled, articles being read are word-wrapped to fit in the space specifi
Ved
Xby the `60Line Length'. If disabled, a horizontal scrollbar is used to view
V the
Xarticle contents.
X.TP 10
X.B Use Kill Files
XEnable or disable use of kill files. If disabled, the kill files will be
Xignored.
X.TP 10
X.B Page Articles
XWhen the `60doTheRightThing' function is used to read articles, specifies
Xthe action at the end of the article. If enabled, the function will stop
Xat the end of the article. If disabled, the next article will be read.
X.TP 10
X.B Read First Article
XIf enabled, the first article in the newsgroup is read when it is opened.
XIf disabled, no articles are read.
X.TP 10
X.B Update Newsrc
XIf enabled, the \*(NS file is updated when leaving \*(AR mode.
X.TP 10
X.B Watch Kill Progress
XIf enabled, the screen is updated as each article is killed during kill
Xoperations; if disabled, the screen is updated only at the end of the
Xoperation.
X.br
X.TP 5
X.B Customize/Mailing
XThis box provides a series of options for controlling the mailing of article
Vs.
X.TP 10
X.B Reply Path
XThe path to use for mailing replies. This should be a sprintf-able string.
XThis format string is used to build a mail address
Xacceptable to mail for replies. For example, `60IN%%"%s"'.
X.br
XThe address in the articles `60Reply-To' header replaces the `60%s' in the s
Vtring
Xand the resulting line is used to provide a mail address. You must double
Xany "%" characters that appear in this string other than the "%s".
X.TP 10
X.B Personal Name
X(VMS Only) Sets your 'real' name for use in postings.`20
X.TP 10
X.B Mailer
X(UNIX Only) Specifies the command to use for mailing replies.
XThis command must take all of it's input from standard input
X(\*(XR will not build a command line).
XThe default is `60/usr/lib/sendmail -oi -t'.
X.TP 10
X.B Host Name
XSets the name of your internet host. Used for postings to specify a useful
Xpath name when the default isn't useful.
X.TP 10
X.B Include CC
XIf enabled, a `60Cc:' line is provided in the header for forwards and replie
Vs.
X.br
X.TP 5
X.B Customize/General
XThis box provides a series of options for controlling the general behavior
Xof \*(XR.
X.TP 10
X.B Top/Min/Max Lines
XThese entries control the size and behavior of the window containing the
Xlist of newsgroups and articles. `60Top Lines' specifies the number of entri
Ves
Xin the list. As articles are read, the list scrolls to maintain the current
Xarticle between `60Min Lines' and `60Max Lines'. For example, setting `60Top
V Lines'
Xto 10, `60Min Lines' to 2, and `60Max Lines' to 8 will cause the top window
V to
Xscroll unless the current article is between lines 2 and 8. This type of
Xsetting minimizes the number of times the top window must be repainted.
X.TP 10
X.B NNTP Server`20
XSupplies the name of the the NNTP server to use (name or internet number).
XIf the entry ends in two colons (`60::'), DECnet is assumed as the transport
V.
XOtherwise, TCP/IP is assumed.
X.TP 10
X.B Newsrc File
XName of the the \*(NS file to use. This file contains information on your
Xsubscribed groups and which articles have been read.
XDefaults to `60`7E/.newsrc'. (SYS$LOGIN:NEWS.RC on VMS).
XIf a file with a name of the form `60<newsrcFile>-<nntpServer>'
Xis found, it will be used. For example, .newsrc-fumble for news server node
X`60fumble'.
X.TP 10
X.B Saved Newsrc File
XSpecifies the name of the backup \*(NS file.
X.br
XBefore the \*(NS file is modified, it is saved in a backup file.
XThis entry allows you to control the name of this backup file.
XDefaults to `60`7E/.oldnewsrc'. (SYS$LOGIN:OLDNEWS.RC on VMS).
X.TP 10
X.B Temp Directory
XSpecifies the directory to use for the temporary storage of articles fetched
Xfrom the server.
XIf this option and the corresponding Xdefault do not exist,
X\*(XR will look for the environment variable \fBTMPDIR\fP.
XThe default is `60/tmp'. (SYS$SCRATCH: on VMS.)
X.B Save Directory
XSpecifies the article saving directory.
XDefaults to `60`7E/News' when \-saveMode specifies `60onedir', or`20
X`60`7E/News/newsgroup' when \-saveMode specifies `60subdirs'.
XFor VMS, defaults to SYS$SCRATCH:.`20
X.TP 10
X.B Print Command
XSet the command used for printing articles.  The article is sent
Xto the command via standard input.
XDefaults to `60lpr'. (PRINT/DELETE on VMS).
X.TP 10
X.B Rescan Time
XAmount of idle time (in seconds) before checking for new articles.
XThis rescan is only performed in \*(NG mode.
X.TP 10
X.B Popup Button
XSpecifies which mouse button will pop up the popup menus. Defaults to the
Xstandard button for the widget set being used (MB2 for XUI, MB3 for Motif).
X.TP 10
X.B Display Informational Messages
XIf enabled, display all informative messages in the message pane. If disable
Vd,
Xinformation messages are displayed in the top information line only.
XDefaults to display all information in the message pane.
X
X.SH OTHER CUSTOMIZATIONS
XThe following arguments can be provided on the command line to further
Xcustomize \*(XR. Entries in your application defaults file can be used
Xto specify these as well.
X.TP 10
X.B Watch Progress
XIf enabled, when 'Catch Up' is used to catch up to a selected position
Xin a group, the display is 'animated' so you can watch the progress of
Xthe operation.
X.br
XThe associated customization file entry is `60watchProgress'. The command li
Vne
Xargument can be \+watchProgress (enabled) or \-watchProgress (disabled).
X.TP 10
X.B -authorLength
X.B -subjectLength
XSpecifies the width of the `60subject' and `60author' fields in the subject
Xlisting.
X.TP 10
X.B \-busyIcon
XWhen set to "on", the icon image will invert when \*(XR is busy.
X.TP 10
X.B \-ccForward
XWhen set to "on", you will be included as a CC entry in forwarded articles.
X.TP 10
X.B \-compRows rows
XSpecifies the number of rows in the message composition window.
X.TP 10
X.B \-distribution
XSpecifies the default distribution for articles. The default is `60world'.
X.TP 10
X.B \-display display
Xspecification of the X display. (Not for VMS).
X.TP 10
X.B +/-dumpCore
XDump core when a signal is detected.  The X resources class for the
X"dumpCore" X resource is "Debug". `60\+dumpCore' disables the default signal
Xhandler.
X.TP 10
X.B -iconGeometry +X+Y
Xspecification of the initial \*(XR icon location.
XThe window manager may choose to ignore this specification.
X.TP 10
X.B -iconName name
Xspecification of the initial \*(XR icon name.
XThe window manager may choose to ignore this specification.
X.TP 10
X.B -iconic
Xstart up \*(XR with the window iconified.
X.TP 10
X.B \-layout =WxH+X+Y
Xspecification of the \*(XR window size and location.
XThe window manager may choose to ignore this specification.
XUsing the Customize/Save menu item saves the current geometry automatically.
X.TP 10
X.B \-leaveHeaders list
Xthe header fields to leave in the article; a comma separated case-insensitiv
Ve
Xlist of field names (\fIi.e.,\fP subject,from,organization).
XThis option takes precedence over `60stripHeaders'.
XIf the word `60all' is specified instead of a list of fields, then all heade
Vrs
Xwill be retained (This can be used in user X resources to override
Xa resource specified in the global \*(XR application defaults, or on
Xthe command line to override a resource specified in either the application
Xdefaults or the user X resources.).
X.B -lockFile name
XSpecifies the name of the lock file to use. The lock file is used to
Xavoid you running \*(XR multiple times, thus losing updates to your newsrc
Xfile.
X.TP 10
X.B -resetSave
XIf set to "on", the string in the save dialog box will be reset when you
Xexit article mode. Normally, the string is retained between entries.
X`5BExcept when the saveString is specified - see below`5D.
X.TP 10
X.B -retryPopupCount
X.B -retryPopupTimeout
X.B -retryPause
X.B -retryLimit
XSpecifies the action to be taken when the connection to the NNTP server is
Xlost. \*(XR will pause for `60retryPause' seconds between retries. A connect
Vion
Xattempt is made `60retryPopupCount' times before posting a popup window that
Xallows the user the opportunity to give up. After `60retryPopupTimout' secon
Vds,
Xthis dialog box is automatically dismissed and another retry is attempted.
XAfter trying this `60retryLimit' times, \*(XR exits.
X.TP 10
X.B \-saveString
XProvides a default value for the filename in the save dialog box.
X.TP 10
X.B \+sortedSubjects
XSpecifies the subject sorting type to be used. Use "\+sortedSubjects" to
Xgroup articles with the same subject, and "\-sortedSubjects" to display
Xarticles in article number order.
X.br
XThe associated customization file entry is `60sortedSubjects'. The command l
Vine
Xargument can be \+sortedSubjects (enabled) or \-sortedSubjects (disabled).
X.br
XWhen used in the customization file, the following values can be used:
X.b
X.nf
X       Value                                 Sort by
X    none (or off, unsorted, false)         article number
X    subject (or on, true, article, sorted) related subjects
X    strict                                 subject only
X
XYou can specify specific sorting types by including the
Xgroup name or hierarchy in the customization entry.
XFor example:
Xmxrn*sortedSubjects: subject
Xmxrn.comp.sources.x.sortedSubjects: strict
Xmxrn*binaries*sortedSubjects: strict
Xmxrn.rec.humor.funny.sortedSubjects: none
X.fi
XThis would cause most groups to appear with subject sorting, `60comp.sources
V.x'
Xto appear in strict order, binaries groups (like `60comp.binaries.ibm-pc') i
Vn
Xstrict order, and `60rec.humor.funny' in article number order.
X.b
X.TP 10
X.B \-saveDir
XSpecifies the default directory for saving articles.
X.br
XYou can specify save directories on a newsgroup basis by including the
Xgroup name or hierarchy in the customization entry.
XFor example:
Xmxrn*saveDir: `7E/News
Xmxrn.comp.sources.x.saveDir: `7E/X-sources
Xmxrn*binaries*saveDir: `7E/binaries
X.fi
XThis would cause most groups to default to `60`7E/News' for saving;
X'comp.sources.x' and binaries groups are placed in separate directories.
X.b
X.TP 10
X.B \-stripHeaders list
Xthe header fields to strip from the article; a comma separated case-insensit
Vive
Xlist of field names (\fIi.e.,\fP keywords,message-id).
XIf the word `60none' is specified instead of a list of fields,
Xthen no headers will be stripped
X(This can be used in user X resources to override
Xa resource specified in the global \*(XR application defaults, or on
Xthe command line to override a resource specified in either the
Xapplication defaults or the user X resources.).
X.TP 10
X.B -unreadIconName name
Xspecification of the \*(XR icon name when there are groups with unread artic
Vles.
XThe window manager may choose to ignore this specification.
X.TP 10
X.B -useGadgets
XIf set to "on", gadgets will be used to create the pulldown menus. Saves a
Xbit of memory - the trade-off is that the gadgets are less customizable.
X.TP 10
X.B -watchUnread
XSpecifies a list of newsgroup names to monitor. If given, this list of
Xgroups will be scanned in newsgroup mode; if any contain new news, the
Xicon title will change to the unread title. If not given, all groups
Xare watched.
X.TP 10
X.B -ngButtonList list
X.TP 10
X.B -artButtonList list
X.TP 10
X.B -artSpecButtonList list
X.TP 10
X.B -addButtonList list
X.TP 10
X.B -allButtonList list
Xuse the given list of buttons for the particular
Xmode in the order given rather than all of the buttons for the
Xmode in the default order.
XThe list is a comma separated list of button names.
XThe names of the buttons appear next after the button label
Xin the button descriptions above.
XFor example, a list of buttons for \*(NG mode might be:
XngQuit,ngRead,ngCatchUp,ngRescan,ngSubscribe,ngPost
XCustomization menus exist for buttons and menus for each mode.
X.TP 10
X.B -ngBindings bindings
X.TP 10
X.B -allBindings bindings
X.TP 10
X.B -addBindings bindings
X.TP 10
X.B -artBindings bindings
Xuse the given bindings for the key/mouse bindings for
Xthe particular mode.
XSee the X toolkit documentation on `60Translation Tables'`20
Xfor information on the format of `60bindings'.
XThe actions defined in \*(XR are the same as the button names.
XFor example, a set of bindings for \*(NG mode might be:
X.nf
X    mxrn.ngBindings: \\
X       <Key>Q:`09`09ngQuit()`09\\n\\
X       <Key>N:`09`09ngRead()`09\\n\\
X       <Key>P:`09`09ngPrev()
X.fi
X.TP 10
X.B -ngPopupList list
X.TP 10
X.B -artPopupList list
X.TP 10
X.B -addPopupList list
X.TP 10
X.B -allPopupList list
XSpecifies the list of buttons to appear in the popup menu for
Xthe given mode. The list is a comma separated list of button names.
XThe names of the buttons appear next after the button label
Xin the button descriptions above.
XFor example, a list of buttons for \*(NG mode might be:
XngQuit,ngRead,ngCatchUp,ngRescan,ngSubscribe,ngPost
XCustomization menus exist for the menus for each mode.
X.\"
X.SH X RESOURCES
X.PP
X\*(XR takes a number of specifications for colors, fonts, border widths,
Xand other program options.
X.pp
XThe format for an \*(XR X resource is:
X.sp
X.ce 100
Xdxrn.x.y....z.a: value
Xor..
Xmxrn.x.y....z.a: value
X.ce 0
X.sp
XWhere \fIx.y....z\fP specifies the path from the top level of
X\*(XR to a particular item
X(think of \*(XR as a hierarchical collection of windows, panes, and buttons,
Xand \fIx.y....z\fP is a path from the top of the hierarchy to a node
Xin the hierarchy),
X\fIa\fP is the type of default (\fIi.e.,\fP font, border,
Xforeground, background, borderWidth), and \fIvalue\fP is the value of
Xthe default (\fIi.e,.\fP a color name or hex representation, a font name,
Xa numeric value).
XSpecifying a default for a item at some point in the hierarchy will set
Xthat default for all items from that point down in the hierarchy.
XA higher level default can be overridden by specifying
Xa default at a lower level directly.
X.sp
XMXRN/DXRN widget hierarchy:
X.nf
X...mxrn or dxrn (Shell)
X  main  (Main Window)
X    MenuBar (Menu Bar)
X    vpane (Paned)
X    titlebar (Label)  (optional)
X    index (Text) (enclosed in topFrame for mxrn).
X    indexinfo (Label)
X    indexbuttons (Box)
X      buttonName (Pushbutton)
X    articleText (Text) (enclosed in botFrame for mxrn).
X    textinfo (Label)
X    textbuttons (Box)
X      buttonName (Pushbutton)
X
XcomposeTop (Shell)
X  pane (Paned)
X    headerText (Text) (enclosed in headerFrame for mxrn)
X    composeText (Text) (enclosed in textFrame for mxrn)
X    box (menu/RowColumn)
X       abort (Pushbutton)
X       send (Pushbutton)
X       save (Pushbutton)
X       includeArticle (Pushbutton)
X       includeFile (Pushbutton)
X       wrapText (PushButton)
Xdialogs...
X.fi
X.sp
XExamples of defaults are:
X.in +0.3i
X.nf
X#bindings for article mode
Xmxrn.artBindings:`09\\
X  <Key>0x20:`09doTheRightThing() \\n\\
X  Alt<Key>N:`09artNext()`09\\n\\
X  <Key>N:`09artSubNext()`09\\n\\
X  Alt<Key>P:`09artPrev()`09\\n\\
X  <Key>P:`09artSubPrev()`09\\n\\
X  Alt<Key>F:`09artFollowup()`09\\n\\
X  Alt<Key>R:`09artReply()`09\\n\\
X  Alt<Key>W:`09artSave()`09\\n\\
X  Alt<Key>C:`09artCancel()`09\\n\\
X  Alt<Key>V:`09artHeader()`09\\n\\
X  Ctrl<Key>X:`09artRot13()`09\\n\\
X  Alt<Key>u:`09artUnsub()`09\\n\\
X  Ctrl<Key>Z:`09artQuit()\\n
X\\n
X#
X#layout/scrolling control for toplevel widget
X#
Xmxrn.topLines:`0910
Xmxrn.minLines:`093
Xmxrn.maxLines:`098
X#
X# which button pops up the popup menus
X#
Xmxrn.popupButton:`092
Xmxrn.saveMode:`09onedir
Xmxrn.includePrefix:`09>
X#
X# list of popup menus. best set using customize
X#
Xmxrn.ngPopupList:`09ngQuit,ngRead,ngSubscribe,ngUnsub,ngCatchUp
Xmxrn.artPopupList:`09artQuit,artNext,artPrev,artNextUnread
X#
X# your name. please don't use mine!
X#
Xmxrn.personalName:`09Rick Murphy
Xmxrn.includeHeader:`09off
Xmxrn.includeSep:`09on
X#
X# don't update newsrc each newsgroup
X#
Xmxrn.updateNewsrc:`09off
X#
X# inhibit info messages, use kill files.
X#
Xmxrn.info:`09off
Xmxrn.killFiles:`09on
X#
X# list of buttons in various modes
X#
Xmxrn.artButtonList:`09artQuit,artFedUp,artPost
Xmxrn.ngButtonList:`09ngQuit,ngRead,ngSubscribe,ngUnsub,ngCatchUp
X#
X# leading text for 'reply' functions
X#
Xmxrn.replyPath:`09decuac::"%s"
Xmxrn.lineLength:`0972
Xmxrn.breakLength:`0980
Xmxrn.pageArticles:`09off
Xmxrn.rescanTime:`091800
Xmxrn.subjectRead:`09on
Xmxrn.replyTo:`09`09murphy@ufp.dco.dec.com
Xmxrn.organization:`09Digital Equipment Corporation, Landover MD
Xmxrn.geometry:`09`09617x750+248+214
Xmxrn.confirm:`09ngCatchUp,artCatchUp
Xmxrn.sortedSubjects:`09on
X#
X# examples of how to color pushbuttons.
X# for `60dxrn' ignore the shadowColor entries.
X#
Xmxrn*background:`09SkyBlue
Xmxrn*foreground:`09white
Xmxrn*artPrint.background:`09#e0e000
Xmxrn*artPrint.foreground:`09black
Xmxrn*artPrint.bottomShadowColor:`09#005400
Xmxrn*artPrint.topShadowColor:`09yellow
Xmxrn*artQuit.background:`09red
Xmxrn*artQuit.foreground:`09White
Xmxrn*artQuit.bottomShadowColor:`09#770000
Xmxrn*artQuit.topShadowColor:`09#ffb3cc
Xmxrn*ngRead.background:`09#00d800
Xmxrn*ngRead.foreground:`09black
Xmxrn*ngRead.bottomShadowColor:`09#005400
Xmxrn*ngRead.topShadowColor:`09green
Xmxrn*ngRescan.background:`09#e0e000
Xmxrn*ngRescan.foreground:`09black
Xmxrn*ngRescan.bottomShadowColor:`09#005400
Xmxrn*ngRescan.topShadowColor:`09yellow
Xmxrn*XmPushButton.background:`09#00d800
Xmxrn*XmPushButton.foreground:`09black
Xmxrn*XmPushButton.font:`09*-*-Menu-Medium-R-Normal-*-*-100-*-*-*-*-*-ISOLATI
VN1
X#
X# resources for the newsgroup/subject list
X#`20
Xmxrn*index.background:`09black
Xmxrn*index.foreground:`09white
X#
X# a fixed font is strongly recommended
X#
Xmxrn*index.font:`09*-*-*-Medium-R-Normal-*-*-120-*-*-M-*
Xmxrn*index.fontList:`09*-*-*-Medium-R-Normal-*-*-120-*-*-M-*
Xmxrn*XmText.background:`09black
Xmxrn*XmText.foreground:`09white
Xmxrn*XmText.font:`09*-*-*-Medium-R-Normal-*-*-120-*-*-M-*
Xmxrn*XmText.fontList:`09*-*-*-Medium-R-Normal-*-*-120-*-*-M-*
XcomposeTop*headerText*fontList:`09*-*-*-Medium-R-Normal-*-*-120-*-*-M-*
XcomposeTop*composeText*fontList:*-*-*-Medium-R-Normal-*-*-120-*-*-M-*
Xmxrn*pointerForeground:`09red
Xmxrn*leaveHeaders:`09subject, newsgroups, from, reply-to
Xmxrn*sortedSubjects:`09on
X#
X# the following is recommended for VMS users. Otherwise,
X# the `60delete' key deletes the wrong way!
X#
X*XmText.translations:`09\\
X#override \\n\\
X   Shift<Key>Delete:`09delete-previous-character()\\n\\
X`09<Key>Delete:`09delete-previous-character()\\n\\
X   Shift<Key>Linefeed:`09delete-next-word()\\n\\
X`09<Key>Linefeed:`09delete-previous-word()\\n\\
X   Shift<Key>BackSpace:`09end-of-line()\\n\\
X`09<Key>BackSpace:`09beginning-of-line()\\n\\
X    Ctrl<Key>e:         end-of-line()\\n\\
X    Ctrl<Key>j:         delete-previous-word()\\n\\
X    Ctrl<Key>h:         beginning-of-line()\\n\\
X    Ctrl<Key>r:         redraw-display()\\n\\
X    Ctrl<Key>u:         delete-to-start-of-line()\\n
X\\n
X.fi
X.in -0.3i
X
X.SH FILES
X.PP
X`7E/.newsrc`09`09description of the groups and the articles read in
X.br
X`09`09`09each group (SYS$LOGIN:NEWS.RC for VMS)
X.br
X`7E/.oldnewsrc`09`09backup of `7E/.newsrc (created at startup)
X.br
X`09`09`09(SYS$LOGIN:OLDNEWS.RC on VMS)
X.br
X`7E/.signature`09`09signature for use when sending messages
X.br
X`09`09`09(SYS$LOGIN:NEWS.SIGNATURE on VMS)
X.br
X`7E/News`09`09`09directory where articles are saved
X.br
X`09`09`09(SYS$SCRATCH: on VMS)
X.br
X`7E/Articles`09`09where `60saved' postings and messages are stored
X.br
X`09`09`09(SYS$SCRATCH:SAVED.POSTING on VMS)
X.br
X`7E/dead.letter`09`09where failed postings and messages are stored
X.br
X`09`09`09(SYS$SCRATCH:DEAD.LETTERS on VMS)
X.br
X`7E/.xrnlock`09`09lock file (SYS$LOGIN:XRN.LOCK on VMS)
X.br
X/usr/local/lib/rn/server`09location of the news server hostname
X.br
X`09`09`09(optional) (SYS$LOGIN:NNTP.SERVER on VMS)
X.br
X/usr/local/lib/news/hiddenhost`09location of the hiddenhost name
X.br
X`09`09`09(optional) (SYS$LOGIN:HIDDEN.HOST on VMS)
X.br
X/usr/local/lib/news/pathhost`09location of the path host name
X.br
X`09`09`09(optional) (SYS$LOGIN:PATH.HOST on VMS)
X.br
X/usr/local/lib/news/domain`09location of the domain name
X.br
X`09`09`09(optional) (SYS$LOGIN:DOMAIN.NAME on VMS)
X.br
X/etc/uucpname`09`09location of the UUCP name for your host
X.br
X`09`09`09(optional)
X.br
X/usr/lib/sendmail`09`09default mailer
X.br
XCHANGES`09`09`09list of changes from the previous version
X.br
XTODO`09`09`09list of bugs and things to do
X
X.SH ENVIRONMENT VARIABLES
X.PP
XNote: environment variables are implemented as logical names on VMS.
X.br
XNNTPSERVER`09`09hostname of the news server
X.br
XTMPDIR`09`09temporary directory
X.br
XDOMAIN`09`09name of your internet domain (".Berkeley.EDU", ".orst.edu")
X.br
XHIDDENHOST`09full domain-style name of the host that you want your return pa
Vth to be from ("decvax.dec.com", "Berkeley.EDU")
X.br
XHIDDENPATH`09name of the host that you want put in the Path field of message
Vs.
X.br
XUSER`09`09login name of the user.
X.br
XHOME`09`09home directory of the user.
X.br
XFULLNAME`09full name of the user, used for the From field of messages.
X.SH SEE ALSO
Xreadnews(1), rn(1), vnews(1), X(1), nntpd(8)
X
X.SH COMMENTS
X.PP
XThe name (\*(XR) is a bit of a misnomer.
X\*(XR is not an X interface to `60rn' (the terminal-based news reading
Xprogram by Larry Wall), but is an X-based news reader that has
Xhad part of the functionality of `60rn' added since a number of our
Xusers are (were?) `60rn' users (all of the code is new).
XMuch of the `60rn' functionality that \*(XR currently has was not in the ori
Vginal
Xplan (KILL files, for example).
X.sp
XThe user interface look and feel is modeled after that of `60XMH'
X(by Terry Weissman).
X.sp
XThe \*(NS file is updated on executing the `60quit' command in \*(NG
Xmode, during every `60rescan', and by `60checkpoint'.
XIf the `60updateNewsrc' option is set, the \*(NS file will be updated
Xevery time \*(AR mode is exited.
X.sp
X\*(XR catches signals and X errors and will clean up on error exit
X(remove temporary files, update the \*(NS file).
XThe cleanup will be done and then a death notifier box will
Xbe posted (if the signal is SIGHUP or SIGINT,
Xthe death notifier will be skipped
Xand the program will exit).
XThe "click to exit" button must be pressed in the death notifier box
Xfor the program to exit.
X.sp
XXREFS are handled by \*(XR, however only articles that
Xare actually read (not marked as read by 'catchup' or 'mark as read')
Xhave their XREFS chased and only groups that are currently subscribed
Xto have XREFed articles marked as read.
X.sp
XThe default specifications for color and fonts can be confusing
X(thousands of different X resources can be specified for \*(XR,
Xno two users' \*(XR displays need to be the same).
X.sp
X\*(XR uses the XHDR command of the Berkeley NNTP news server
X(XHDR is not part of the protocol defined by RFC 977).
X\*(XR will detect the presence of this command and complain
Xif it does not exist.
X.sp
XSince the NNTP protocol does not define a unique response code
Xfor server timeout, timeout recovery may not work if the format
Xof the timeout error message changes.
X.sp
X\*(XR assumes a `60smart' or `60lucky' mailer.
X.sp
X\*(XR notices that the `60.newsrc' file has been updated by another program
V while
X\*(XR is running and informs the user (and gives the user the option to quit
Xwithout updating the `60.newsrc' or to continue on).
X.sp
XArticle temporary files can be removed and \*(XR will recover.
X.sp
X\*(XR strips `60<character>`5EH' from articles.
X.sp
XThe v`7Bf,s`7Dprintf implementation included with \*(XR is from`20
XRobert A. Larson <blarson@skat.usc.edu>.
X.sp
XThe strtok implementation included with \*(XR is from
XHenry Spencer <henry@zoo.toronto.edu>.
X
X.SH BUGS
X.PP
X.sp`20
XSee TODO for a full list of bugs and things that need to be done.
X.sp
XIncomplete KILL file support.
X.sp
XSee config.h for a list of defines you may want to use based
Xon problems that may exist in your version of the X11 toolkit and widgets.
X.sp
XReport bugs and requests for features to `60murphy@ufp.dco.dec.com'
X(...decwrl!ufp.enet!murphy)
X.sp
X.\"
X.SH "ORIGINAL AUTHORS"
XEllen M Sentovich (UC Berkeley, ellen@ic.berkeley.edu, ...!ucbvax!ic!ellen)
X.br
XRick L Spickelmier (formerly UC Berkeley, now Objectivity, Inc.,
Xricks@berkeley.edu, ...!ucbvax!ricks, ricks@objy.com)
X.br
XSee the FIXERS/CHANGES files for a listing of those who have really
Xbeen doing most of the work over the last year or so!
X.br
XRick Murphy (DEC, Landover MD) VMS, XUI, and Motif port.
Xnote: Ellen Sentovich and Rick Spickelmier are responsible for writing the
Xcode. Rick Murphy is responsible for writing the bugs. Don't bother the
XBerkeley folks with reports of dxrn or mxrn bugs.
$ CALL UNPACK XRN.MAN;1 578125936
$ create 'f'
X
X/*
X * Contributed by:
X *
X * -------------------------------------------------------------------------
V-
X * Bob Tracy           `7C     "Failure is the foundation of success, and
X * b23b!oskeewow!tracy `7C      success is the lurking-place of failure."
X * x8588               `7C                            W. Sommerset Maughm
X * -------------------------------------------------------------------------
V-
X *
X */
X
X#define xrn_width 50
X#define xrn_height 50
Xstatic unsigned char xrn_bits`5B`5D = `7B
X   0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xfd, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
X   0xaa, 0xfe, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xfd, 0xaa, 0xaa, 0xaa,
X   0xaa, 0xaa, 0xaa, 0xfe, 0x55, 0xff, 0xff, 0xff, 0xff, 0x57, 0xfd, 0xaa,
X   0x01, 0x00, 0x00, 0x00, 0xac, 0xfe, 0xd5, 0xff, 0xff, 0xff, 0xff, 0x5b,
X   0xfd, 0x6a, 0x00, 0x00, 0x00, 0x00, 0xab, 0xfe, 0xd5, 0xff, 0xff, 0xff,
X   0xff, 0x5a, 0xfd, 0xea, 0x51, 0x99, 0x51, 0xeb, 0xaa, 0xfe, 0xd5, 0x1b,
X   0x5d, 0x55, 0xf7, 0x5a, 0xfd, 0xea, 0x5b, 0x99, 0x55, 0xf6, 0xaa, 0xfe,
X   0xd5, 0xff, 0xff, 0xff, 0xff, 0x5a, 0xfd, 0xea, 0xff, 0x4a, 0xcb, 0xff,
X   0xaa, 0xfe, 0xd5, 0xff, 0xe8, 0xdc, 0xff, 0x5a, 0xfd, 0xea, 0xff, 0xca,
X   0xcc, 0xff, 0xaa, 0xfe, 0xd5, 0xff, 0xff, 0xff, 0xff, 0x5a, 0xfd, 0xea,
X   0xff, 0xff, 0xff, 0xff, 0xaa, 0xfe, 0xd5, 0x00, 0x00, 0x00, 0xc0, 0x5a,
X   0xfd, 0xea, 0x00, 0x00, 0x00, 0xc0, 0xaa, 0xfe, 0xd5, 0xff, 0xff, 0xff,
X   0xff, 0x5a, 0xfd, 0xea, 0xb5, 0xef, 0xdf, 0xef, 0xaa, 0xfe, 0xd5, 0x49,
X   0x16, 0x21, 0xc3, 0x5a, 0xfd, 0xea, 0xff, 0xff, 0xff, 0xff, 0xaa, 0xfe,
X   0xd5, 0x99, 0x46, 0x0b, 0xd3, 0x5a, 0xfd, 0xea, 0xff, 0xff, 0xff, 0xff,
X   0xaa, 0xfe, 0xd5, 0xd7, 0x07, 0x00, 0xd3, 0x5a, 0xfd, 0xea, 0x29, 0x06,
X   0x00, 0xcf, 0xaa, 0xfe, 0xd5, 0xff, 0xc7, 0x3d, 0xff, 0x5a, 0xfd, 0xea,
X   0xe7, 0xc7, 0x1c, 0xc3, 0xaa, 0xfe, 0xd5, 0x19, 0x86, 0x13, 0xff, 0x5a,
X   0xfd, 0xea, 0xff, 0xe7, 0x3b, 0xc3, 0xaa, 0xfe, 0xd5, 0x19, 0xe7, 0x1f,
X   0xef, 0x5a, 0xfd, 0xea, 0xc7, 0xc6, 0x01, 0xff, 0xaa, 0xfe, 0xd5, 0xff,
X   0x07, 0x00, 0xc3, 0x5a, 0xfd, 0xea, 0x11, 0xfe, 0xff, 0xff, 0xaa, 0xfe,
X   0xd5, 0xcf, 0x47, 0x0a, 0xf7, 0x5a, 0xfd, 0xea, 0xff, 0xff, 0xff, 0xcb,
X   0xaa, 0xfe, 0xd5, 0xbb, 0x5f, 0x6c, 0xff, 0x5a, 0xfd, 0xea, 0x41, 0x06,
X   0x01, 0xc3, 0xaa, 0xfe, 0xd5, 0xff, 0xff, 0xff, 0xff, 0x5a, 0xfd, 0xea,
X   0xaf, 0x47, 0x12, 0xc3, 0xaa, 0xfe, 0xd5, 0x11, 0xde, 0xb5, 0xef, 0x56,
X   0xfd, 0xea, 0xff, 0xff, 0xff, 0xff, 0xaa, 0xfe, 0xd5, 0xff, 0xff, 0xff,
X   0xff, 0x55, 0xfd, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xfe, 0x55, 0x55,
X   0x55, 0x55, 0x55, 0x55, 0xfd, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xfe,
X   0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xfd, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
X   0xaa, 0xfe`7D;
X
X#define xrn_i_width 50
X#define xrn_i_height 50
Xstatic unsigned char xrn_i_bits`5B`5D = `7B
X   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x02, 0x55, 0x55, 0x55, 0x55, 0x55,
X   0x55, 0x01, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x02, 0x55, 0x55, 0x55,
X   0x55, 0x55, 0x55, 0x01, 0xaa, 0x00, 0x00, 0x00, 0x00, 0xa8, 0x02, 0x55,
X   0xfe, 0xff, 0xff, 0xff, 0x53, 0x01, 0x2a, 0x00, 0x00, 0x00, 0x00, 0xa4,
X   0x02, 0x95, 0xff, 0xff, 0xff, 0xff, 0x54, 0x01, 0x2a, 0x00, 0x00, 0x00,
X   0x00, 0xa5, 0x02, 0x15, 0xae, 0x66, 0xae, 0x14, 0x55, 0x01, 0x2a, 0xe4,
X   0xa2, 0xaa, 0x08, 0xa5, 0x02, 0x15, 0xa4, 0x66, 0xaa, 0x09, 0x55, 0x01,
X   0x2a, 0x00, 0x00, 0x00, 0x00, 0xa5, 0x02, 0x15, 0x00, 0xb5, 0x34, 0x00,
X   0x55, 0x01, 0x2a, 0x00, 0x17, 0x23, 0x00, 0xa5, 0x02, 0x15, 0x00, 0x35,
X   0x33, 0x00, 0x55, 0x01, 0x2a, 0x00, 0x00, 0x00, 0x00, 0xa5, 0x02, 0x15,
X   0x00, 0x00, 0x00, 0x00, 0x55, 0x01, 0x2a, 0xff, 0xff, 0xff, 0x3f, 0xa5,
X   0x02, 0x15, 0xff, 0xff, 0xff, 0x3f, 0x55, 0x01, 0x2a, 0x00, 0x00, 0x00,
X   0x00, 0xa5, 0x02, 0x15, 0x4a, 0x10, 0x20, 0x10, 0x55, 0x01, 0x2a, 0xb6,
X   0xe9, 0xde, 0x3c, 0xa5, 0x02, 0x15, 0x00, 0x00, 0x00, 0x00, 0x55, 0x01,
X   0x2a, 0x66, 0xb9, 0xf4, 0x2c, 0xa5, 0x02, 0x15, 0x00, 0x00, 0x00, 0x00,
X   0x55, 0x01, 0x2a, 0x28, 0xf8, 0xff, 0x2c, 0xa5, 0x02, 0x15, 0xd6, 0xf9,
X   0xff, 0x30, 0x55, 0x01, 0x2a, 0x00, 0x38, 0xc2, 0x00, 0xa5, 0x02, 0x15,
X   0x18, 0x38, 0xe3, 0x3c, 0x55, 0x01, 0x2a, 0xe6, 0x79, 0xec, 0x00, 0xa5,
X   0x02, 0x15, 0x00, 0x18, 0xc4, 0x3c, 0x55, 0x01, 0x2a, 0xe6, 0x18, 0xe0,
X   0x10, 0xa5, 0x02, 0x15, 0x38, 0x39, 0xfe, 0x00, 0x55, 0x01, 0x2a, 0x00,
X   0xf8, 0xff, 0x3c, 0xa5, 0x02, 0x15, 0xee, 0x01, 0x00, 0x00, 0x55, 0x01,
X   0x2a, 0x30, 0xb8, 0xf5, 0x08, 0xa5, 0x02, 0x15, 0x00, 0x00, 0x00, 0x34,
X   0x55, 0x01, 0x2a, 0x44, 0xa0, 0x93, 0x00, 0xa5, 0x02, 0x15, 0xbe, 0xf9,
X   0xfe, 0x3c, 0x55, 0x01, 0x2a, 0x00, 0x00, 0x00, 0x00, 0xa5, 0x02, 0x15,
X   0x50, 0xb8, 0xed, 0x3c, 0x55, 0x01, 0x2a, 0xee, 0x21, 0x4a, 0x10, 0xa9,
X   0x02, 0x15, 0x00, 0x00, 0x00, 0x00, 0x55, 0x01, 0x2a, 0x00, 0x00, 0x00,
X   0x00, 0xaa, 0x02, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x01, 0xaa, 0xaa,
X   0xaa, 0xaa, 0xaa, 0xaa, 0x02, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x01,
X   0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x02, 0x55, 0x55, 0x55, 0x55, 0x55,
X   0x55, 0x01`7D;
$ CALL UNPACK XRN.XBM;2 1966857867
$ create 'f'
X
X#if !defined(lint) && !defined(SABER)
Xstatic char XRNrcsid`5B`5D = "$Header: /net/objy27/wrld/mnt11/ricks/src/mast
Ver/xrn/xthelper.c,v 1.4 1993/01/11 02:15:55 ricks Exp $";
X#endif
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * xthelper.c: routines for simplifying the use of the X toolkit
X *
X */
X
X#include "copyright.h"
X#include "config.h"
X#include <stdio.h>
X#include "utils.h"
X#ifndef VMS
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#else
X#include <decw$include/Intrinsic.h>
X#include <decw$include/StringDefs.h>
X#endif
X#ifdef MOTIF
X#include <Xm/Xm.h>
X#endif
X#include "xmisc.h"
X#include "xrn.h"
X#include "xthelper.h"
X
X
Xvoid
XxthCenterWidget(widget, x, y)
XWidget widget;
Xint x, y;
X`7B
X#ifdef MOTIF
X    Arg sargs`5B3`5D;
X#else
X    Arg sargs`5B2`5D;
X#endif
X    Arg gargs`5B2`5D;
X    Dimension height, width;
X
X    XtSetArg(gargs`5B0`5D, XtNwidth, &width);
X    XtSetArg(gargs`5B1`5D, XtNheight, &height);
X    XtGetValues(widget, gargs, XtNumber(gargs));
X
X    x -= width / 2;
X    y -= height / 2;
X    if (x +  width  > WidthOfScreen(XtScreen(widget))) `7B
X`09x = WidthOfScreen(XtScreen(widget)) - width;
X    `7D
X    if (y + height > HeightOfScreen(XtScreen(widget))) `7B
X`09y = HeightOfScreen(XtScreen(widget)) - height;
X    `7D
X    if (x < 0) `7B
X`09x = 0;
X    `7D
X    if (y < 0) `7B
X`09y = 0;
X    `7D
X    XtSetArg(sargs`5B0`5D, XtNx, x);
X    XtSetArg(sargs`5B1`5D, XtNy, y);
X#ifdef MOTIF
X    XtSetArg(sargs`5B2`5D, XmNdefaultPosition, False);
X#endif
X    XtSetValues(widget, sargs, XtNumber(sargs));
X    return;
X`7D
X
Xvoid
XxthCenterWidgetOverCursor(widget)
XWidget widget;
X/*
X * center a window over the cursor
X *
X *   returns: void
X *
X */
X`7B
X    Window root, child;
X    int x, y, dummy;
X    unsigned int mask;
X
X    (void) XQueryPointer(XtDisplay(TopLevel), XtWindow(TopLevel),
X`09`09`09 &root, &child,
X`09`09`09 &x, &y, &dummy, &dummy,
X`09`09`09 &mask);
X
X    xthCenterWidget(widget, x, y);
X    return;
X`7D
X
Xvoid
XxthHandleAllPendingEvents()
X`7B
X   `20
X    if ((XRNState & XRN_X_UP) == XRN_X_UP) `7B
X`09while (XtPending()) `7B
X`09    XtProcessEvent(XtIMAll);
X`09`7D
X    `7D
X    return;
X`7D
X#ifdef MOTIF
X
Xint xthTextWidth(widget)
XWidget widget;
X`7B
X    Arg arg`5B1`5D;
X    short int cols = 0;
X
X    XtSetArg(arg`5B0`5D, XmNcolumns, &cols);
X    XtGetValues(widget, arg, 1);
X    return cols;
X`7D
X
X/*
X * Fit a frame to its contents.
X */
Xvoid fitFrameToContents(frame, contents)
XWidget frame;
XWidget contents;
X`7B
X    Arg args`5B3`5D;
X    Dimension width, height, borderWidth;
X
X    /* get width & height from contents */
X    XtSetArg(args`5B0`5D, XmNheight,&height);
X    XtSetArg(args`5B1`5D, XmNwidth, &width);
X    XtGetValues(contents, args, 2);
X
X    /* get borderWidth from frame */
X    XtSetArg(args`5B0`5D, XmNborderWidth, &borderWidth);
X    XtGetValues(frame, args, 1);
X
X    XtSetArg(args`5B0`5D, XmNwidth, width);
X    XtSetArg(args`5B1`5D, XmNheight, height);
X    XtSetArg(args`5B2`5D, XmNborderWidth, borderWidth);
X    XtSetValues(frame, args, 3);
X`7D
X#endif
X
X/*
X * Tell an ICCCM-compliant window manager that we are
X * withdrawing the window.  This is done by sending`20
X * a fake unmap-notify event.
X */
Xvoid xthUnmapWidget(w)
XWidget w;
X`7B
X    XEvent event;
X    Screen *scr;
X
X    XtUnmapWidget(w);
X    scr = XtScreen(w);
X    event.xunmap.type = UnmapNotify;
X    event.xunmap.serial = XLastKnownRequestProcessed(XtDisplay(w));
X    event.xunmap.send_event = True;
X    event.xunmap.display = XtDisplay(w);
X    event.xunmap.event = XRootWindowOfScreen(scr);
X    event.xunmap.window = XtWindow(w);
X    event.xunmap.from_configure = False;
X
X    XSendEvent(
X`09XtDisplay(w), XRootWindowOfScreen(scr),`20
X`09False,`20
X`09SubstructureRedirectMask`7CSubstructureNotifyMask,`20
X`09&event
X`09);
X`7D
X
X/*`20
X * Translate a geometry string and load up x/y/w/h arg list
X */
X
Xvoid
XxthTranslateGeometry(geometry, frameArgs)
Xchar *geometry;
XArg frameArgs`5B`5D;
X`7B
X    if (geometry != NIL(char)) `7B
X`09int bmask;
X`09bmask = XParseGeometry(geometry,        /* geometry specification */
X`09`09       (int *) &frameArgs`5B0`5D.value,    /* x      */
X`09`09       (int *) &frameArgs`5B1`5D.value,    /* y      */
X`09      (unsigned int *) &frameArgs`5B2`5D.value,    /* width  */
X`09      (unsigned int *) &frameArgs`5B3`5D.value);   /* height */
X
X`09/* handle negative x and y values */
X`09if ((bmask & XNegative) == XNegative) `7B
X`09    frameArgs`5B0`5D.value = (XtArgVal) ((int) frameArgs`5B0`5D.value +`2
V0
X`09    `09`09`09DisplayWidth(XtDisplay(TopLevel),
X`09`09`09        DefaultScreen(XtDisplay(TopLevel))));
X`09    frameArgs`5B0`5D.value = (XtArgVal) ((int) frameArgs`5B0`5D.value -
X`09`09`09`09`09     (int) frameArgs`5B2`5D.value);
X`09`7D
X`09if ((bmask & YNegative) == YNegative) `7B
X`09    frameArgs`5B1`5D.value = (XtArgVal) ((int) frameArgs`5B1`5D.value +
X`09`09`09`09DisplayHeight(XtDisplay(TopLevel),
X`09`09`09`09DefaultScreen(XtDisplay(TopLevel))));
X`09    frameArgs`5B1`5D.value = (XtArgVal) ((int) frameArgs`5B1`5D.value -
X`09`09`09`09`09     (int) frameArgs`5B3`5D.value);
X`09`7D
X    `7D
X`7D   `20
$ CALL UNPACK XTHELPER.C;32 2088540103
$ create 'f'
X#ifndef XTHELPER_H
X#define XTHELPER_H
X
X/*
X * $Header: /net/objy27/wrld/mnt11/ricks/src/master/xrn/xthelper.h,v 1.4 199
V3/01/11 02:15:57 ricks Exp $
X */
X
X/*
X * xrn - an X-based NNTP news reader
X *
X * Copyright (c) 1988-1993, Ellen M. Sentovich and Rick L. Spickelmier.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the University of California not
X * be used in advertising or publicity pertaining to distribution of`20
X * the software without specific, written prior permission.  The University
X * of California makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty.
X *
X * THE UNIVERSITY OF CALIFORNIA DISCLAIMS ALL WARRANTIES WITH REGARD TO`20
X * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND`20
X * FITNESS, IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE FOR
X * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN`20
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X/*
X * xthelper.h: routines for simplifying the use of the X toolkit
X *
X */
X
Xextern void xthCenterWidgetOverCursor _ARGUMENTS((Widget));
Xextern void xthCenterWidget _ARGUMENTS((Widget, int, int));
Xextern void xthHandleAllPendingEvents();
X#ifdef MOTIF
Xextern int xthTextWidth _ARGUMENTS((Widget));
Xextern void fitFrameToContents _ARGUMENTS((Widget, Widget));
X#endif
Xextern void xthUnmapWidget _ARGUMENTS((Widget));
Xextern void xthTranslateGeometry ();
X#endif /* XTHELPER_H */
$ CALL UNPACK XTHELPER.H;19 857353176
$ v=f$verify(v)
$ EXIT
