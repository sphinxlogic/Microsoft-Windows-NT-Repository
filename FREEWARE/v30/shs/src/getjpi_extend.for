	OPTIONS		/EXTEND_SOURCE
	SUBROUTINE	GETJPI_EXTEND
C+
C
C FUNCTIONAL DESCRIPTION:
C
C       GETJPI_EXTEND.FOR - To Retrive extensive Process(es) informations, 
C	including ws size, ws quota, ws extend, image name besides pid, 
C	process name, state, current priority, IO(buffer IO + direct IO) CPU 
C	consume time, page faults, pages in memory, root job type.
C
C	If 'SYS$OUTPUT' is terminal and terminal column size <> 132,
C	set the terminal to 132.  
C
C	Process(es) context is supplied by calling program via common blocks.
C	
C
C FORMAL PARAMETERS:
C
C     {parameters}
C
C COMMON BLOCKS:
C
C     NODE_INFO
C     SORT_ORDER
C     PAGE_QUAL
C
C AUTHOR:
C	
C     James Shen (jshen1@ford.com)
C
C CREATION DATE: Sept, 1995
C
C MODIFIED BY:
C
C        : VERSION
C 01    - J.Shen  10/06/1995   	Added JPI$_GETJPI_CONTROL_FLAGS item code.
C                        	Incresed process/node limit 512->2048.
C
C-
	IMPLICIT	NONE

CDEC$ OPTIONS /ALIGN=COMMON=NATURAL

	COMMON	//	LUN, CONTEXT
	COMMON	/NODE_INFO/  NODENAME, NODENAME_LEN
	COMMON  /SORT_ORDER/ ORDER
	COMMON  /PAGE_INFO / PAGE_PRESENT

CDEC$ END OPTIONS
                                   
        INCLUDE         '($DVIDEF)'
        INCLUDE         '($DCDEF)'
	INCLUDE		'($IODEF)'
	INCLUDE		'($TTDEF)'
	INCLUDE		'($JPIDEF)'
	INCLUDE		'($SSDEF)'
	INCLUDE		'($SYIDEF)'
	INCLUDE		'($RMSDEF)'
	INCLUDE		'($LIBDEF)'
	INCLUDE		'($SYSSRVNAM)'
	INCLUDE		'SHSINC.FOR'

CDEC$   OPTIONS/ALIGN=(STRUCTURE=NATURAL)
	STRUCTURE /PROCESS/
	  INTEGER*4	PID
	  CHARACTER*15	PRCNAM
	  BYTE		%FILL
	  INTEGER*4	PNAME_LEN,
	2		STATE,
	2		CURPRIORITY,
	2		BUFIOCNT,
	2		DIOCNT,
	2		CPUTIME,
	2		PAGEFAULT,
	2		PPAGES,
	2		GPAGES,
	2		PRCMODE,
	2		WSSIZE,
	2		WSQUOTA,
	2		WSEXTENT
	  CHARACTER*132	IMAGENAME
	  INTEGER*4	IMAGE_LEN
	  CHARACTER*8	TERMINAL
	  INTEGER*4	TERMINAL_LEN
	END STRUCTURE
CDEC$   END OPTIONS

        RECORD /DVIITMLIST/     DVILIST(2)	
	RECORD /CHARACTERISTICS/TTCHAR	
	RECORD /JPIITMLIST/	JPILIST(18)
	RECORD /SYIITMLIST/	SYILIST(5)
	RECORD /IOSB_STAT/	TTIOSB
	RECORD /IOSB/		JPISTAT,
	2			SYISTAT
        RECORD /PROCESS/        PROCESS(2048)            !Maxium 2048 Proc/node

	EXTERNAL        SCH$C_COLPG,
	2               SCH$C_MWAIT,
	2               SCH$C_CEF,
	2               SCH$C_PFW,
	2               SCH$C_LEF,
	2               SCH$C_LEFO,
	2               SCH$C_HIB,
	2               SCH$C_HIBO,
	2               SCH$C_SUSP,
	2               SCH$C_SUSPO,
	2               SCH$C_FPG,
	2               SCH$C_COM,
	2               SCH$C_COMO,
	2               SCH$C_CUR
C+
C DECLARE FUNCTIONS
C-
	INTEGER*4	LIB$SUBX,
	2		LIB$GET_INPUT,
	2	       	SHS_PROC_SORTBY_KEY_EXTEND
C+
C LOCAL VARIALBES
C-
	INTEGER*4	ORDER
	LOGICAL*4	PAGE_PRESENT
        INTEGER*4       DVI_CLASS, DVI_CLASS_LEN
	BYTE		PAGE_LENGTH
	INTEGER*2	OUTPUT_CHAN
	INTEGER*4	LUN
	INTEGER*4	CONTEXT
	INTEGER*4	STATUS
	INTEGER*4	JPIFLAGS
	INTEGER*2	CPU_DAY, CPU_HOUR, CPU_MIN, CPU_SEC, CPU_MIL_SEC
	DATA		CPU_DAY, CPU_HOUR, CPU_MIN, CPU_SEC, CPU_MIL_SEC  /5*0/
	CHARACTER*5	STATE_ASCII
	CHARACTER*1	PRCMODE_INDICATOR
	CHARACTER*(*)	ESC_BRACKET_WIDE
	PARAMETER	( ESC_BRACKET_WIDE = CHAR(27)//'[?3h' )
	CHARACTER*(*)	HINT_LINE
        PARAMETER       ( HINT_LINE = '                                     '//
	2		'                 '//CHAR(27)//'[7m'//
	2               'Press RETURN to continue'//CHAR(27)//'[27m')
	CHARACTER*(*)	HEADER_STRING 
	PARAMETER	(HEADER_STRING ='  Pid    Process Name    State  Pri'//
	2		'  Terminal      I/O       CPU         WSext'//
	2		'  WSquo WSsize Page flts Ph.Mem'//
	2		'  Image Name       Mode' )

	CHARACTER*5	ARCHNAME
	BYTE		ARCH_LEN
	INTEGER*2	HWMODEL
	CHARACTER*6	NODENAME
	INTEGER*2	NODENAME_LEN
	CHARACTER*32	HWNAME
	INTEGER*4	HWNAME_LEN
	CHARACTER*4	VERSION
	INTEGER*2	VERSION_LEN
	INTEGER*4	BOOTIME(2), UPTIME(2), CURTIME(2)
	CHARACTER*13    UPTIME_ASCII
	CHARACTER*23	CURTIME_ASCII
	INTEGER*4	ZERO(2)
	DATA		ZERO /0,0/

	LOGICAL*4	DONE /.FALSE./
	LOGICAL*4	POST_HEADER
	LOGICAL*4	DCTERM /.TRUE./
	LOGICAL*4	CLR_SCREEN /.TRUE./
	CHARACTER*1	RESPONSE
	BYTE		RESPONSE_LENGTH
	INTEGER*2	I, J
	INTEGER*4	RESULT, PROC_INDEX, K 
	INTEGER*4	Q, P /0/		!Page length controller  
	SAVE		P, CLR_SCREEN
	INTEGER*4	LOWER, UPPER, STEP
	
        !
        ! Find out device class of SYS$OUTPUT
        !
        !********************************************
        ! Initialize DVI item list
        !********************************************
        DVILIST(1).BUFLEN    = 4
        DVILIST(1).CODE      = DVI$_DEVCLASS
        DVILIST(1).BUFADR    = %LOC(DVI_CLASS)
        DVILIST(1).RETLENADR = %LOC(DVI_CLASS_LEN)
        DVILIST(2).END_LIST  = 0

        STATUS = SYS$GETDVIW  ( ,,
	2                       'SYS$OUTPUT',
	2                       DVILIST,,,,,)
        IF ((.NOT. STATUS) .AND. ( STATUS .NE. SS$_IVDEVNAM) 
	2	.AND. (STATUS .NE. SS$_NOSUCHDEV )) THEN
          CALL LIB$SIGNAL(%VAL(STATUS))
        END IF

        IF (( STATUS .NE. SS$_IVDEVNAM) .AND. (DVI_CLASS .EQ. DC$_TERM)) THEN
          DCTERM = .TRUE.
        ELSE
	  DCTERM = .FALSE.
        END IF

	POST_HEADER = .TRUE.
	DONE = .FALSE.
	PROC_INDEX = 0
	DO WHILE (.NOT. DONE)	
	  PROC_INDEX = PROC_INDEX + 1
	  !*********************************************
	  ! Construct & Initialize JPI Item List
	  !*********************************************
	  JPILIST(1).BUFLEN	= 4
	  JPILIST(1).CODE	= IAND('FFFF'X, JPI$_GETJPI_CONTROL_FLAGS)
	  JPILIST(1).BUFADR	= %LOC(JPIFLAGS)
	  JPILIST(1).RETLENADR	= 0
	  JPILIST(2).BUFLEN	= 4
	  JPILIST(2).CODE	= JPI$_PID
	  JPILIST(2).BUFADR	= %LOC(PROCESS(PROC_INDEX).PID)
	  JPILIST(2).RETLENADR	= 0
	  JPILIST(3).BUFLEN	= LEN(PROCESS(PROC_INDEX).PRCNAM)
	  JPILIST(3).CODE	= JPI$_PRCNAM
	  JPILIST(3).BUFADR	= %LOC(PROCESS(PROC_INDEX).PRCNAM)
	  JPILIST(3).RETLENADR	= %LOC(PROCESS(PROC_INDEX).PNAME_LEN)
	  JPILIST(4).BUFLEN	= 4
	  JPILIST(4).CODE	= JPI$_STATE
	  JPILIST(4).BUFADR	= %LOC(PROCESS(PROC_INDEX).STATE)
	  JPILIST(4).RETLENADR	= 0
	  JPILIST(5).BUFLEN	= 4
	  JPILIST(5).CODE	= JPI$_PRI
	  JPILIST(5).BUFADR	= %LOC(PROCESS(PROC_INDEX).CURPRIORITY)
	  JPILIST(5).RETLENADR	= 0
	  JPILIST(6).BUFLEN	= 4
	  JPILIST(6).CODE	= JPI$_BUFIO
	  JPILIST(6).BUFADR	= %LOC(PROCESS(PROC_INDEX).BUFIOCNT)
	  JPILIST(6).RETLENADR	= 0
	  JPILIST(7).BUFLEN	= 4
	  JPILIST(7).CODE	= JPI$_CPUTIM
	  JPILIST(7).BUFADR	= %LOC(PROCESS(PROC_INDEX).CPUTIME)
	  JPILIST(7).RETLENADR	= 0
	  JPILIST(8).BUFLEN	= 4
	  JPILIST(8).CODE	= JPI$_PAGEFLTS
	  JPILIST(8).BUFADR	= %LOC(PROCESS(PROC_INDEX).PAGEFAULT)
	  JPILIST(8).RETLENADR	= 0
	  JPILIST(9).BUFLEN	= 4
	  JPILIST(9).CODE	= JPI$_PPGCNT
	  JPILIST(9).BUFADR	= %LOC(PROCESS(PROC_INDEX).PPAGES)
	  JPILIST(9).RETLENADR	= 0
	  JPILIST(10).BUFLEN	= 4
	  JPILIST(10).CODE	= JPI$_GPGCNT
	  JPILIST(10).BUFADR	= %LOC(PROCESS(PROC_INDEX).GPAGES)
	  JPILIST(10).RETLENADR	= 0
	  JPILIST(11).BUFLEN	= 4
	  JPILIST(11).CODE	= JPI$_MODE
	  JPILIST(11).BUFADR	= %LOC(PROCESS(PROC_INDEX).PRCMODE)
	  JPILIST(11).RETLENADR	= 0
	  JPILIST(12).BUFLEN	= 4
	  JPILIST(12).CODE	= JPI$_DIRIO
	  JPILIST(12).BUFADR	= %LOC(PROCESS(PROC_INDEX).DIOCNT)
	  JPILIST(12).RETLENADR	= 0
	  JPILIST(13).BUFLEN	= 4
	  JPILIST(13).CODE	= JPI$_WSSIZE
	  JPILIST(13).BUFADR	= %LOC(PROCESS(PROC_INDEX).WSSIZE)
	  JPILIST(13).RETLENADR	= 0
	  JPILIST(14).BUFLEN	= 4
	  JPILIST(14).CODE	= JPI$_WSQUOTA
	  JPILIST(14).BUFADR	= %LOC(PROCESS(PROC_INDEX).WSQUOTA)
	  JPILIST(14).RETLENADR	= 0
	  JPILIST(15).BUFLEN	= 4
	  JPILIST(15).CODE	= JPI$_WSEXTENT
	  JPILIST(15).BUFADR	= %LOC(PROCESS(PROC_INDEX).WSEXTENT)
	  JPILIST(15).RETLENADR	= 0
	  JPILIST(16).BUFLEN	= 132
 	  JPILIST(16).CODE	= JPI$_IMAGNAME
	  JPILIST(16).BUFADR	= %LOC(PROCESS(PROC_INDEX).IMAGENAME)
	  JPILIST(16).RETLENADR	= %LOC(PROCESS(PROC_INDEX).IMAGE_LEN)
	  JPILIST(17).BUFLEN	= 4
	  JPILIST(17).CODE	= JPI$_TERMINAL
	  JPILIST(17).BUFADR	= %LOC(PROCESS(PROC_INDEX).TERMINAL)
	  JPILIST(17).RETLENADR	= %LOC(PROCESS(PROC_INDEX).TERMINAL_LEN)
	  JPILIST(18).END_LIST	= 0
                   
	  JPIFLAGS = JPI$M_IGNORE_TARGET_STATUS

	  STATUS = SYS$GETJPIW(,	
	2			CONTEXT,,
	2			JPILIST,
	2			JPISTAT,,)

	  IF (STATUS) THEN
	    IF ( .NOT. JPISTAT.STATUS) THEN
	      IF ( JPISTAT.STATUS .EQ. SS$_NOMOREPROC) THEN
		DONE = .TRUE.
	      ELSE
	        CALL LIB$SIGNAL(%VAL( JPISTAT.STATUS))
	      END IF
	    ELSE
	      IF (POST_HEADER) THEN
		IF ( DCTERM ) THEN
		  !
	          ! Sense the Termainal Width, it = 132 ?
		  ! Terminal Page Length
	 	  !
		  STATUS = SYS$ASSIGN('SYS$OUTPUT', OUTPUT_CHAN,,)
		  IF ( .NOT. STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
	
		  STATUS = SYS$QIOW( ,
	2			    %VAL(OUTPUT_CHAN),
	2			    %VAL(IO$_SENSEMODE),
	2			    TTIOSB,,,
	2			    TTCHAR,
	2			    %VAL(8),,,,)	! TTCHAR buffer size
		  IF ( .NOT. STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
		  IF ( .NOT. TTIOSB.STATUS) CALL LIB$SIGNAL(%VAL(STATUS))

		  PAGE_LENGTH = TTCHAR.LENGTH(4)
		  
		  IF ( PAGE_PRESENT .AND. CLR_SCREEN) CLR_SCREEN = .TRUE.
		  IF ( .NOT. PAGE_PRESENT) CLR_SCREEN = .FALSE.

		  IF ( TTCHAR.WIDTH .NE. 132 .OR. CLR_SCREEN) THEN
		    TTCHAR.WIDTH = 132
		    STATUS = SYS$QIOW(  ,
	2				%VAL(OUTPUT_CHAN),
	2				%VAL(IO$_SETMODE),
	2				TTIOSB,,,
	2				TTCHAR,
	2				%VAL(8),,,,)
		    IF ( .NOT. STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
		    IF ( .NOT. TTIOSB.STATUS) CALL LIB$SIGNAL(%VAL(TTIOSB.STATUS))
		

		    WRITE( LUN, 1000) ESC_BRACKET_WIDE
1000		    FORMAT ( 1X, A )
		    CLR_SCREEN = .FALSE.
		  END IF
		END IF		  

		!**************************************
		! Construct Item List For Syi	
		!**************************************	  
	        SYILIST(1).BUFLEN    = 2
		SYILIST(1).CODE	     = SYI$_HW_MODEL
		SYILIST(1).BUFADR    = %LOC(HWMODEL)
		SYILIST(1).RETLENADR = 0	
	        SYILIST(2).BUFLEN    = 4
		SYILIST(2).CODE	     = SYI$_NODE_SWVERS
		SYILIST(2).BUFADR    = %LOC(VERSION)
		SYILIST(2).RETLENADR = %LOC(VERSION_LEN)	
	        SYILIST(3).BUFLEN    = 8
		SYILIST(3).CODE	     = SYI$_BOOTTIME
		SYILIST(3).BUFADR    = %LOC(BOOTIME)
		SYILIST(3).RETLENADR = 0
	        SYILIST(4).BUFLEN    = 32
		SYILIST(4).CODE	     = SYI$_HW_NAME
		SYILIST(4).BUFADR    = %LOC(HWNAME)
		SYILIST(4).RETLENADR = %LOC(HWNAME_LEN)
		SYILIST(5).END_LIST  = 0

		STATUS = SYS$GETSYIW(,,
	2			     NODENAME(1:NODENAME_LEN),
	2			     SYILIST,
	2			     SYISTAT,,)

		IF ( .NOT. STATUS) THEN
		  CALL LIB$SIGNAL(%VAL(STATUS))
		ELSE IF ( .NOT. SYISTAT.STATUS) THEN
		  CALL LIB$SIGNAL(%VAL(JPISTAT.STATUS))
		ELSE
		  STATUS = SYS$GETTIM(CURTIME)
		  IF ( .NOT. STATUS) CALL LIB$SIGNAL(%VAL(STATUS))

		  STATUS = SYS$ASCTIM(, CURTIME_ASCII,
	2				CURTIME,
	2				0)
		  IF ( .NOT. STATUS) CALL LIB$SIGNAL(%VAL(STATUS))

		  STATUS = LIB$SUBX( CURTIME,
	2			     BOOTIME,
	2			     UPTIME)	

		  ! If resultant time is is absolute format (positive value
		  ! means nost significant bit is not set), convert to 
		  ! delta time
		  IF ( .NOT. ( BTEST( UPTIME(2),31 ))) THEN
		    STATUS = LIB$SUBX(  ZERO,
	2				UPTIME,
	2				UPTIME)
		    IF ( .NOT. STATUS) CALL LIB$SIGNAL(%VAL(STATUS))
	          END IF	

		  STATUS = SYS$ASCTIM(, UPTIME_ASCII,
	2				UPTIME,
	2				0)
		  IF ( .NOT. STATUS) CALL LIB$SIGNAL(%VAL(STATUS))

		  IF (HWMODEL .EQ. 0  .OR. HWMODEL .GE. 1024) THEN
		    ARCHNAME = 'Alpha'
		    ARCH_LEN = 5
	 	  ELSE
		    ARCHNAME = 'VAX'
	  	    ARCH_LEN = 3
		  END IF

		  IF (PAGE_PRESENT .AND. 
	2		(P .EQ. PAGE_LENGTH-4 .OR. P .EQ. PAGE_LENGTH-3 .OR. 
	2		P .EQ. PAGE_LENGTH-2 .OR. P .EQ. PAGE_LENGTH-1)) THEN
		    P = PAGE_LENGTH - P - 1
	            DO Q = 1, P 		! Pad nice several lines
			TYPE *, ' '
		    END DO
	    	    P = 0
                    STATUS = LIB$GET_INPUT( RESPONSE,
	2                                   HINT_LINE,
	2                                   RESPONSE_LENGTH)
                    IF ( STATUS .EQ. SS$_NORMAL .OR. STATUS .EQ. LIB$_INPSTRTRU) THEN
                      IF (RESPONSE_LENGTH .NE. 0 ) CALL SYS$EXIT(%VAL(1))
                    ELSE IF ( STATUS .EQ. RMS$_EOF .OR. STATUS .EQ. RMS$_TNS) THEN
                      CALL SYS$EXIT(%VAL(1))
                    ELSE
                      CALL LIB$SIGNAL(%VAL(STATUS))
		    END IF
	          END IF

		  WRITE( LUN, 1005) ARCHNAME(1:ARCH_LEN), VERSION, 
	2		NODENAME(:NODENAME_LEN), HWNAME(:HWNAME_LEN), 
	2		CURTIME_ASCII, UPTIME_ASCII
1005		  FORMAT (X , /, 13X, A,'/VMS ', A5, ' on node ', A, X, '-', X,
	2		A, 2X, A, '   Uptime ', A)
		  WRITE( LUN, 1010) HEADER_STRING
1010		  FORMAT ( 1X, A)

		  P = P + 3

		END IF
		POST_HEADER = .FALSE.
              END IF
            END IF
          ELSE IF ( STATUS .EQ. SS$_NOMOREPROC) THEN
            DONE = .TRUE.
          END IF
	END DO

C+
C  CALL FUNCTION SHS_PROC_SORTBY_KEY ENTRY SHS_PROC_SORTBY_KEY_EXTEND
C-
        IF ( PROC_INDEX .GT. 2) THEN
          STATUS = SHS_PROC_SORTBY_KEY_EXTEND( PROCESS,
	2                                      PROC_INDEX-1)
          IF ( .NOT. STATUS ) CALL LIB$STOP(%VAL(STATUS))
        END IF

	IF (ORDER .EQ. SHS_ASCENDING) THEN
          LOWER = 1
          UPPER = PROC_INDEX - 1
          STEP  = 1
	ELSE IF ( ORDER .EQ. SHS_DESCENDING) THEN
          LOWER = PROC_INDEX - 1
          UPPER = 1
          STEP  = -1
	END IF

	DO 2000, K = LOWER, UPPER, STEP

          IF ((PAGE_PRESENT) .AND. (P .EQ. PAGE_LENGTH - 1)) THEN
            P = 0
            STATUS = LIB$GET_INPUT(RESPONSE,
	2                          HINT_LINE,
	2                          RESPONSE_LENGTH)
            IF ( STATUS .EQ. SS$_NORMAL .OR. STATUS .EQ. LIB$_INPSTRTRU) THEN
              IF (RESPONSE_LENGTH .NE. 0 ) CALL SYS$EXIT(%VAL(1))
            ELSE IF ( STATUS .EQ. RMS$_EOF .OR. STATUS .EQ. RMS$_TNS) THEN
              CALL SYS$EXIT(%VAL(1))
            ELSE
              CALL LIB$SIGNAL(%VAL(STATUS))
            END IF
          END IF
	
          CPU_MIL_SEC = JMOD(PROCESS(K).CPUTIME, 100)
          RESULT = PROCESS(K).CPUTIME/100
          IF ( RESULT .GE. 1) THEN
            CPU_SEC = JMOD( RESULT, 60)
            RESULT = RESULT/60
            IF ( RESULT .GE. 1) THEN
              CPU_MIN = JMOD( RESULT, 60)
              RESULT = RESULT/60
              IF ( RESULT .GE. 1) THEN
                CPU_HOUR = JMOD( RESULT, 24)
                CPU_DAY  = RESULT/24
              END IF
            END IF
          END IF

	  DO WHILE ( PROCESS(K).TERMINAL_LEN .LT. 8) 
	    PROCESS(K).TERMINAL_LEN = PROCESS(K).TERMINAL_LEN + 1
	    PROCESS(K).TERMINAL(PROCESS(K).TERMINAL_LEN:PROCESS(K).TERMINAL_LEN) = ' '
	  END DO

	  DO WHILE ( PROCESS(K).PNAME_LEN .LT. 15)
	    PROCESS(K).PNAME_LEN = PROCESS(K).PNAME_LEN +1
	    PROCESS(K).PRCNAM(PROCESS(K).PNAME_LEN:PROCESS(K).PNAME_LEN) = ' '	
          END DO	

	  IF (PROCESS(K).STATE .EQ. %LOC(SCH$C_COLPG))  THEN
	    STATE_ASCII = 'COLPG'
	  ELSE IF (PROCESS(K).STATE .EQ. %LOC(SCH$C_MWAIT))  THEN 
	    STATE_ASCII = 'MWAIT'
	  ELSE IF (PROCESS(K).STATE .EQ. %LOC(SCH$C_CEF))  THEN  	 
	    STATE_ASCII = 'CEF  '
	  ELSE IF (PROCESS(K).STATE .EQ. %LOC(SCH$C_PFW))  THEN 
	    STATE_ASCII = 'PFW  '
	  ELSE IF (PROCESS(K).STATE .EQ. %LOC(SCH$C_LEF))  THEN
	    STATE_ASCII = 'LEF  '
	  ELSE IF (PROCESS(K).STATE .EQ. %LOC(SCH$C_LEFO)) THEN
	    STATE_ASCII = 'LEFO '
	  ELSE IF (PROCESS(K).STATE .EQ. %LOC(SCH$C_HIB))  THEN
	    STATE_ASCII = 'HIB  '
	  ELSE IF (PROCESS(K).STATE .EQ. %LOC(SCH$C_HIBO)) THEN
	    STATE_ASCII = 'HIBO '
	  ELSE IF (PROCESS(K).STATE .EQ. %LOC(SCH$C_SUSP)) THEN
	    STATE_ASCII = 'SUSP '
	  ELSE IF (PROCESS(K).STATE .EQ. %LOC(SCH$C_SUSPO)) THEN
	    STATE_ASCII = 'SUSPO'
          ELSE IF (PROCESS(K).STATE .EQ. %LOC(SCH$C_FPG))  THEN
  	    STATE_ASCII = 'FPG  '
	  ELSE IF (PROCESS(K).STATE .EQ. %LOC(SCH$C_COM))  THEN
	    STATE_ASCII = 'COM  '
	  ELSE IF (PROCESS(K).STATE .EQ. %LOC(SCH$C_COMO)) THEN
	    STATE_ASCII = 'COMO '
	  ELSE IF (PROCESS(K).STATE .EQ. %LOC(SCH$C_CUR))  THEN
	    STATE_ASCII = 'CUR  '
	  ELSE 
	    STATE_ASCII = '*****'	! Should never happened
	  END IF
		
	  IF (PROCESS(K).PRCMODE .EQ. JPI$K_OTHER   )  THEN
	    PRCMODE_INDICATOR = 'O'
	  ELSE IF (PROCESS(K).PRCMODE .EQ. JPI$K_NETWORK )  THEN    
	    PRCMODE_INDICATOR = 'N'
	  ELSE IF (PROCESS(K).PRCMODE .EQ. JPI$K_BATCH   ) THEN   
	    PRCMODE_INDICATOR = 'B'
	  ELSE IF (PROCESS(K).PRCMODE .EQ. JPI$K_INTERACTIVE) THEN 
	    PRCMODE_INDICATOR = 'I'
	  ELSE
	    PRCMODE_INDICATOR = '*' 	!Should never happened
	  END IF

	  !
	  ! Remove device & directory specificition of image name
	  ! Remove image name file extention & version #
	  !
	  IF ( PROCESS(K).IMAGE_LEN .EQ. 0) THEN
	    DO WHILE ( PROCESS(K).IMAGE_LEN .LT. 19) 
	      PROCESS(K).IMAGE_LEN = PROCESS(K).IMAGE_LEN +1
	      PROCESS(K).IMAGENAME(PROCESS(K).IMAGE_LEN:PROCESS(K).IMAGE_LEN) = ' '
	    END DO
	  END IF

    	  J = 1
	  I = INDEX(PROCESS(K).IMAGENAME(1:PROCESS(K).IMAGE_LEN),']')
          DO WHILE (I .NE. 0)
            J = J + I
            I = INDEX(PROCESS(K).IMAGENAME(J:PROCESS(K).IMAGE_LEN),']')
          END DO

          I = INDEX (PROCESS(K).IMAGENAME(J:PROCESS(K).IMAGE_LEN), '.EXE')
          IF (I .NE. 0) THEN
            PROCESS(K).IMAGENAME(1:) = PROCESS(K).IMAGENAME(J:J+I-2) 
            PROCESS(K).IMAGE_LEN = I-1
	    DO WHILE ( PROCESS(K).IMAGE_LEN .LT. 19)
	      PROCESS(K).IMAGE_LEN = PROCESS(K).IMAGE_LEN + 1
	      PROCESS(K).IMAGENAME(PROCESS(K).IMAGE_LEN:PROCESS(K).IMAGE_LEN) = ' '
	    END DO 
          END IF

	  WRITE (LUN, 1015)  PROCESS(K).PID, PROCESS(K).PRCNAM, STATE_ASCII, 
	2	PROCESS(K).CURPRIORITY, PROCESS(K).TERMINAL,
	2	PROCESS(K).BUFIOCNT+PROCESS(K).DIOCNT, CPU_DAY, CPU_HOUR, 
	2	CPU_MIN, CPU_SEC, CPU_MIL_SEC, PROCESS(K).WSEXTENT, 
	2	PROCESS(K).WSQUOTA, PROCESS(K).WSSIZE, PROCESS(K).PAGEFAULT, 
	2	PROCESS(K).PPAGES+PROCESS(K).GPAGES, 
	2	PROCESS(K).IMAGENAME(1:19),PRCMODE_INDICATOR
1015	  FORMAT (1X, Z8.8, 1X, A, 1X, A , 3X , I2, 2X , A,  
	2		1X, I8 , I4, 1X , I2.2,':', I2.2,':', I2.2 ,'.', 
	2	    	I2.2, 2X, I6, 1X, I6, 2X, I5, 1X,
	2               I9, 1X, I6 , 1X , A19, 1X, A) 

	  IF (PAGE_PRESENT) P = P + 1
	  !************************************************
	  ! Reset The Cpu Time For Each Process
	  !************************************************
	  CPU_DAY  	= 0 
	  CPU_HOUR 	= 0
	  CPU_MIN	= 0
	  CPU_SEC	= 0
	  CPU_MIL_SEC  	= 0
	  RESULT	= 0
2000	CONTINUE
	RETURN
	END
