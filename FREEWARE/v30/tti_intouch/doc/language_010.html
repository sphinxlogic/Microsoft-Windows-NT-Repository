<!-- LANGUAGE_010.HTML continuation of DOCDATA:[DOC.INTOUCH]LANGUAGE.HTML -->
<html>
<head>
<title>INTOUCH&#174; 4GL </title>
</head>
<body background="/white.gif">
<h1 align="center">INTOUCH<sup>&#174;</sup> 4GL <br> A Guide to the INTOUCH Language</h1>

<hr> <a href="LANGUAGE_009.HTML#bottom_009">Previous page...</a> 
<a href="LANGUAGE_CONTENTS.HTML">Table of Contents</a>

<hr size=5>

<a name="heading_9.15.9"><h2>9.15.9 ASK SYSTEM, PASS: SUCCESS</h2></a>
<a name="index_x_593"></a>
<a name="index_x_594"></a>
<h2>FORMAT:</h2>

<p><pre>
        ASK SYSTEM, PASS: SUCCESS num_var 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  OPEN #1: NAME 'report.lis', ACCESS OUTPUT 
            PRINT #1: 'sample report' 
            CLOSE #1 
            PASS 'PRINT/HOLD REPORT.LIS' 
            ASK SYSTEM, PASS: SUCCESS okay 
            IF  okay  THEN 
              PRINT 'Report queued for printing' 
            ELSE 
              PRINT 'Unable to queue report for printing' 
            END IF 
        20  END 
 
        RNH 
        Report queued for printing 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
This statement asks the operating system to return a <b>TRUE</b>
(1) if true or <b>FALSE</b> (0) if false indicating whether or 
not the last PASS command executed successfully. 
</dl>

<p>

<a name="heading_9.15.10"><h2>9.15.10 ASK SYSTEM: PROCESS</h2></a>
<a name="index_x_595"></a>
<a name="index_x_596"></a>
<h2>FORMAT:</h2>

<p><pre>
        ASK SYSTEM: PROCESS str_var 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  ASK SYSTEM: PROCESS process$ 
        20  PRINT 'Process is: '; process$ 
        30  END 
 
        RNH 
        Process is: TESTER_13B_3 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
<b>ASK SYSTEM: PROCESS</b> <i>str_var</i> asks the operating 
system for the current process name. 
</dl>

<p>

<a name="heading_9.15.11"><h2>9.15.11 SET SYSTEM: PROCESS</h2></a>
<a name="index_x_597"></a>
<a name="index_x_598"></a>
<h2>FORMAT:</h2>

<p><pre>
        SET SYSTEM: PROCESS str_expr 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  ASK SYSTEM: PROCESS process$ 
            curr_process$ = process$ 
            PRINT 'Current process is: '; curr_process$ 
        20  new_process$ = 'DO_TEST' 
            SET SYSTEM: PROCESS new_process$ 
            ASK SYSTEM: PROCESS process$ 
            PRINT 'New process is: '; process$ 
        30  SET SYSTEM: PROCESS curr_process$ 
            ASK SYSTEM: PROCESS process$ 
            PRINT 'Old process restored: '; process$ 
        40  END 
 
        RNH 
        Current process is: TESTER_13B_3 
        New process is: DO_TEST 
        Old process restored: TESTER_13B_3 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
<b>SET SYSTEM: PROCESS</b> <i>str_expr</i> changes the 
operating system process name to <i>str_expr</i>. 
</dl>

<p>

<a name="heading_9.15.12"><h2>9.15.12 ASK SYSTEM: RIGHTS</h2></a>
<a name="index_x_599"></a>
<a name="index_x_600"></a>
<h2>FORMAT:</h2>

<p><pre>
        ASK SYSTEM: RIGHTS str_var 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  ASK SYSTEM: RIGHTS process_rights$ 
            PRINT 'Your process rights are: '; process_rights$ 
        20  END 
 
        RNH 
        Your process rights are: FAST_ACCESS,TEST_ACCESS 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
<b>ASK SYSTEM: RIGHTS</b> asks the operating system to return a 
list of the rights explicitly granted to the calling process. 
</dl>

<p>

<a name="heading_9.15.13"><h2>9.15.13 ASK SYSTEM, SYMBOL: VALUE</h2></a>
<a name="index_x_601"></a>
<a name="index_x_602"></a>
<h2>FORMAT:</h2>

<p><pre>
        ASK SYSTEM, SYMBOL str_expr: VALUE str_var 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  ASK SYSTEM, SYMBOL 'INTOUCH': VALUE symbol$ 
            PRINT 'Value of symbol INTOUCH is: '; symbol$ 
        20  END 
 
        RNH 
        Value of symbol INTOUCH is: $intouch_image: 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
This statement asks the operating system to translate the symbol name 
in <i>str_expr</i> and place the result into the variable specified by 
<i>str_var</i>. 
</dl>

<p>

<a name="heading_9.15.14"><h2>9.15.14 SET SYSTEM, SYMBOL: VALUE</h2></a>
<a name="index_x_603"></a>
<a name="index_x_604"></a>
<h2>FORMAT:</h2>

<p><pre>
        SET SYSTEM, SYMBOL str_expr1: VALUE str_expr2 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  SET SYSTEM, SYMBOL 'mysym': VALUE 'hello' 
            ASK SYSTEM, SYMBOL 'mysym': VALUE z$ 
            PRINT 'Symbol set to '; z$ 
        20  END 
 
        RNH 
        Symbol set to HELLO 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
This statement sets the operating system symbol name in <i>str_expr1</i>
to the value in <i>str_expr2</i>. 
</dl>

<p>

<a name="heading_9.15.15"><h2>9.15.15 ASK SYSTEM: USER</h2></a>
<a name="index_x_605"></a>
<a name="index_x_606"></a>
<h2>FORMAT:</h2>

<p><pre>
        ASK SYSTEM: USER str_var 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  ASK SYSTEM : USER uname$ 
        20  PRINT 'User is: '; uname$ 
        30  END 
 
        RNH 
        User is: TESTER 
</pre>

<h2>PURPOSE:</h2>

<dl>
<dd>

<p>
This statement returns the operating system name or ID for the user.  
Under VMS this is the <b>Username</b>. 
</dl>

<p>

<a name="heading_9.16"><h1>9.16 ASK | SET WINDOW</h1></a>

<p>
There are various ASK WINDOW and SET WINDOW statements.  These are 
described in the following sections.  The ASK/SET WINDOW statements 
ask about and reset different screen features. 

<p>

<a name="heading_9.16.1"><h2>9.16.1 ASK WINDOW AREA</h2></a>
<a name="index_x_607"></a>
<a name="index_x_608"></a>
<h2>FORMAT:</h2>

<p><pre>
        ASK WINDOW AREA row, col, row, col: DATA str_var 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  CLEAR 
        20  PRINT AT 10, 4: 'Mary had a'; 
            PRINT AT 11, 4: 'little lamb'; 
        30  ASK WINDOW AREA 10, 4, 11, 15: DATA x$ 
        40  PRINT 
            PRINT x$ 
        50  END 
 
        RNH 
           Mary had a 
           little lamb 
        Mary had a 
                  little lamb 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
This statement reads the text displayed on the screen within the area 
defined by the given upper-left/lower-right coordinates into a string 
variable, <i>str_var</i>.  The coordinates are specified by upper-left 
row, upper-left column, lower-right row, lower-right column.  The statement 
returns a &lt;LF&gt; delimited string.  No screen attributes are stored. 
</dl>

<p>

<a name="heading_9.16.2"><h2>9.16.2 SET WINDOW AREA</h2></a>
<a name="index_x_609"></a>
<a name="index_x_610"></a>
<h2>FORMAT:</h2>

<p><pre>
        SET WINDOW AREA row, col, row, col: DATA str_expr 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  CLEAR 
        20  x$ = 'Mary had a' + chr$(10) + 'little lamb' 
        30  SET WINDOW AREA 6, 5, 7, 15: DATA x$ 
        40  END 
 
        RNH 
 
            Mary had a 
            little lamb 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
This statement sets the screen within the area defined by the given 
upper-left/lower-right coordinates to the  specified string.  This 
is the mirror image of ASK WINDOW AREA row, col, row, col: DATA str_var. 
</dl>

<p>

<a name="heading_9.16.3"><h2>9.16.3 ASK WINDOW: COLUMN</h2></a>
<a name="index_x_611"></a>
<a name="index_x_612"></a>
<h2>FORMAT:</h2>

<p><pre>
        ASK WINDOW: COLUMN num_var 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  CLEAR 
            PRINT AT 5,10:; 
        20  ASK WINDOW: COLUMN cur_col 
        30  PRINT 'Cursor is at column'; cur_col 
        40  END 
 
        RNH 
        Cursor is at column 10 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
This statement returns the current column of the cursor's position. 
</dl>

<p>

<a name="heading_9.16.4"><h2>9.16.4 SET WINDOW: COLUMN</h2></a>
<a name="index_x_613"></a>
<a name="index_x_614"></a>
<h2>FORMAT:</h2>

<p><pre>
        SET WINDOW: COLUMN num_expr 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  CLEAR 
            PRINT AT 5,10:; 
        20  SET WINDOW: COLUMN 4 
        30  PRINT 'Hi!' 
        40  END 
 
        RNH 
           Hi! 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
This statement positions the cursor at the <i>num_expr</i> column 
within the current row. 
</dl>

<p>

<a name="heading_9.16.5"><h2>9.16.5 ASK | SET WINDOW: CURRENT</h2></a>
<a name="index_x_615"></a>
<a name="index_x_616"></a>
<a name="index_x_617"></a>
<h2>FORMAT:</h2>

<p><pre>
        ASK WINDOW: CURRENT str_var 
        SET WINDOW: CURRENT str_var 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  CLEAR 
            PRINT AT 1,20, UNDERLINE: 'Sample screen' 
        20  DO 
              LINE INPUT 'Name', AT 5,1, LENGTH 30: name$       
              IF  _BACK  OR  _EXIT  THEN  EXIT DO 
              IF  _HELP  THEN 
                ASK WINDOW: CURRENT old_w$ 
                CLEAR AREA BOX: 1, 5, 10, 50 
                PRINT AT 3, 10, REVERSE: 'This is some help' 
                DELAY 
                SET WINDOW: CURRENT old_w$ 
                REPEAT DO 
              END IF 
        30  END DO 
        40  END 
 
        RNH 
 
            +--------------------------------------------+ 
            |                                            | 
            |    This is some help                       | 
            |                                            | 
        Name|                                            | 
            |                                            | 
            |                                            | 
            +--------------------------------------------+ 
 
 
                        Press the RETURN key to continue 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
<b>ASK WINDOW: CURRENT</b> and <b>SET WINDOW: CURRENT</b>
allow you to save the image of the current screen and later restore it easily. 
This is useful for help messages and menus, where you must temporarily change 
the screen and then want to restore it back to what it was. 
</dl>

<p>

<a name="heading_9.16.6"><h2>9.16.6 ASK WINDOW: DATA</h2></a>
<a name="index_x_618"></a>
<a name="index_x_619"></a>
<h2>FORMAT:</h2>

<p><pre>
        ASK WINDOW: DATA str_var 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  CLEAR 
        20  PRINT AT 10, 4: 'Mary had a'; 
            PRINT AT 11, 4: 'little lamb'; 
        30  ASK WINDOW: DATA x$ 
        40  PRINT 
        50  PRINT x$ 
        60  END 
 
        RNH 
           Mary had a 
           little lamb 
        . 
        . 
        . 
 
        Mary had a 
                     little lamb 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
This statement reads the text displayed on the whole screen into a string 
variable.  The statement returns a &lt;LF&gt; delimited string. 
No screen attributes are stored. 
</dl>

<p>

<a name="heading_9.16.7"><h2>9.16.7 SET WINDOW: DATA</h2></a>
<a name="index_x_620"></a>
<a name="index_x_621"></a>
<h2>FORMAT:</h2>

<p><pre>
        SET WINDOW: DATA str_expr 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  CLEAR 
        20  x$ = 'Mary had a' + chr$(10) + 'little lamb' 
        30  SET WINDOW: DATA x$ 
        40  END 
 
        RNH 
        Mary had a 
        little lamb 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
This statement sets the whole screen to the specified string.  This 
is the mirror image of ASK WINDOW: DATA str_var. 
</dl>

<p>

<a name="heading_9.16.8"><h2>9.16.8 ASK | SET WINDOW: KEYMAP</h2></a>
<a name="index_x_622"></a>
<a name="index_x_623"></a>
<a name="index_x_624"></a>
<h2>FORMAT:</h2>

<p><pre>
        ASK WINDOW: KEYMAP str_var 
        SET WINDOW: KEYMAP str_expr 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  PRINT 'Save the current keymap, reset keymap to default value.' 
            ASK WINDOW: KEYMAP old_keymap$ 
            SET WINDOW: KEYMAP '' 
 
            PRINT 'Changing DOWN key to be the EXIT key' 
            SET WINDOW KEYSTROKE 'down': VALUE '_exit' 
            LINE INPUT 'Press the DOWN key': down$ 
 
            PRINT 'Changing dollar sign key to *' 
            SET WINDOW KEYSTROKE '$': VALUE '*' 
            LINE INPUT 'Press the dollar sign key, then RETURN': e$ 
 
            PRINT 'Restore saved keymap' 
            SET WINDOW: KEYMAP old_keymap$ 
            LINE INPUT 'Press the DOWN key': down$ 
            LINE INPUT 'Press the dollar sign key, then RETURN' : e$ 
        20  END 
 
        RNH 
        Save the current keymap, reset keymap to default value. 
        Changing DOWN key to be the EXIT key 
        Press the DOWN key? EXIT 
        Changing dollar sign key to * 
        Press the dollar sign key, then RETURN? * 
        Restore saved keymap 
        Press the DOWN key? 
        Press the dollar sign key, then RETURN? $ 
 
        INTOUCH 
</pre>

<h2>PURPOSE:</h2>

<dl>
<dd>

<p>
To allow a generalized routine to save the current keymap, change the 
meaning of keys, and then restore the original keymap when done. 
</dl>
<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
<b>ASK WINDOW: KEYMAP</b> and <b>SET WINDOW: KEYMAP</b>
allow you to save the image of the keymap and later restore it.  This is 
helpful for applications where you must temporarily change the meaning of 
the keys using the SET WINDOW KEYSTROKE statement.  You can restore the 
keymap to its default setting by using SET WINDOW: KEYMAP. 
</dl>

<p>

<a name="heading_9.16.9"><h2>9.16.9 SET WINDOW KEYSTROKE: VALUE</h2></a>
<a name="index_x_625"></a>
<a name="index_x_626"></a>
<h2>FORMAT:</h2>

<p><pre>
        SET WINDOW KEYSTROKE str_expr1: VALUE str_expr2 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  PRINT 'Saving the current keymap.' 
            ASK WINDOW: KEYMAP old_keymap$ 
            SET WINDOW: KEYMAP '' 
 
            PRINT 'Changing DOWN key to be the EXIT key' 
            SET WINDOW KEYSTROKE 'down': VALUE '_exit' 
            LINE INPUT 'Press the DOWN key': down$ 
 
            PRINT 'Changing dollar sign key to *' 
            SET WINDOW KEYSTROKE '$': VALUE '*' 
            LINE INPUT 'Press the dollar sign key, then RETURN': e$ 
 
            PRINT 'Restoring saved keymap.' 
            SET WINDOW: KEYMAP old_keymap$ 
            LINE INPUT 'Press the DOWN key': down$ 
            LINE INPUT 'Press the dollar sign key, then RETURN' : e$ 
        20  END 
 
        RNH 
        Saving the current keymap. 
        Changing DOWN key to be the EXIT key 
        Press the DOWN key? EXIT 
        Changing dollar sign key to * 
        Press the dollar sign key, then RETURN? * 
        Restoring saved keymap. 
        Press the DOWN key? 
        Press the dollar sign key, then RETURN? $ 
 
        INTOUCH 
</pre>

<h2>PURPOSE:</h2>

<dl>
<dd>

<p>
<b>SET WINDOW KEYSTROKE</b> allows you to change the meaning of 
a keystroke within an INTOUCH program.  This allows you to completely 
redefine the keyboard for a given application. 
</dl>
<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
<i>str_expr1</i> describes the name of the key that you want to change. 
It can be a single keystroke name, or a comma separated list of names. 
Keystroke names can be a single letter, or the name of the letter (such 
as <kbd>Tab</kbd>, or <kbd>Ctrl/Z</kbd>). 

<p>
<i>str_expr2</i> defines the new meaning of the keystroke.  A keystroke 
meaning consists of one or two components.  The keystroke value, and the 
keystroke concept.  For example, the <kbd>Ctrl/Z</kbd> key usually has a value 
of CHR$(26), and the concept of EXIT.  The keystroke value and/or the 
keystroke concept can be changed.  If changing both a value and a concept, 
separate the two with a comma.  You can restore the original meaning of the 
key by using " ". 

<p>
The following keystroke concepts are supported: 
<p><a name="table_9-1"></a>
<table border>
  <caption><b>Table 9-1 Supported Keystroke Concepts</b></caption>
  <tr>
    <th align=center>Concept name </th>
    <th align=center>Description </th>
  </tr>
  <tr>
    <td>_EXIT </td>
    <td>an EXIT key</td>
  </tr>
  <tr>
    <td>_BACK </td>
    <td> a BACK key</td>
  </tr>
  <tr>
    <td>_HELP </td>
    <td>a HELP key</td>
  </tr>
  <tr>
    <td>_IGNORE </td>
    <td>ignore this keystroke</td>
  </tr>
  <tr>
    <td>_INVALID </td>
    <td>beep when pressed</td>
  </tr>
  <tr>
    <td>_TERMINATOR </td>
    <td>keystroke is a line terminator</td>
  </tr>
</table>
</dl>

<a name="heading_9.16.10"><h2>9.16.10 ASK WINDOW: ROW</h2></a>
<a name="index_x_627"></a>
<a name="index_x_628"></a>
<h2>FORMAT:</h2>

<p><pre>
        ASK WINDOW: ROW num_var 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  CLEAR 
            PRINT AT 5,10:; 
        20  ASK WINDOW: ROW cur_row 
        30  PRINT 'Cursor is at row'; cur_row 
        40  END 
 
        RNH 
        Cursor is at row 5 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
This statement returns the current row of the cursor's position. 
</dl>

<p>

<a name="heading_9.16.11"><h2>9.16.11 SET WINDOW: ROW</h2></a>
<a name="index_x_629"></a>
<a name="index_x_630"></a>
<h2>FORMAT:</h2>

<p><pre>
        SET WINDOW: ROW num_expr 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  CLEAR 
        20  SET WINDOW: ROW 3 
        30  PRINT 'Hi!' 
        40  END 
 
        RNH 
 
        Hi! 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
This statement positions the cursor at the <i>num_expr</i> row 
within the current column. 
</dl>

<p>

<a name="heading_9.16.12"><h2>9.16.12 ASK WINDOW: TYPEAHEAD</h2></a>
<a name="index_x_631"></a>
<a name="index_x_632"></a>
<h2>FORMAT:</h2>

<p><pre>
        ASK WINDOW: TYPEAHEAD str_var 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  DO 
              GOSUB process 
              ASK WINDOW: TYPEAHEAD z$ 
              IF  POS(UCASE$(z$), 'STA') &gt; 0  THEN  GOSUB show_status 
              IF  POS(z$, CHR$(26)) &gt; 0  THEN  EXIT DO 
            LOOP 
            STOP 
 
            ROUTINE process 
              DELAY 1                     ! simulated processing 
              PRINT '.'; 
            END ROUTINE 
 
            ROUTINE show_status 
              PRINT 
              PRINT 'Showing status' 
              SET WINDOW: TYPEAHEAD '' 
            END ROUTINE 
        20  END 
 
        RNH 
        .......       (type <b>STA</b>) 
        showing status 
        .......       (press <kbd>CTRL/Z</kbd> ) 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
<b>ASK WINDOW: TYPEAHEAD</b> gets data from the typeahead buffer. 
You can use this statement to determine, for example, whether the user has 
typed <kbd>Ctrl/Z</kbd> or other special keystrokes.  Asking for typeahead data 
does not lose what is already in the typeahead buffer. 
</dl>

<p>

<a name="heading_9.16.13"><h2>9.16.13 SET WINDOW: TYPEAHEAD</h2></a>
<a name="index_x_633"></a>
<a name="index_x_634"></a>
<h2>FORMAT:</h2>

<p><pre>
        SET WINDOW: TYPEAHEAD str_expr 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  SET WINDOW: TYPEAHEAD 'FRED' + CHR$(13) 
            INPUT 'Name': name$ 
            PRINT name$ 
        20  END 
 
        RNH 
        Name? FRED 
        FRED 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
<b>SET WINDOW: TYPEAHEAD</b> puts data into the typeahead buffer 
as though the user had typed the data in from the terminal. 
</dl>

<p>

<a name="heading_9.17"><h1>9.17 ASK | SET ZONEWIDTH</h1></a>

<a name="heading_9.17.1"><h2>9.17.1 ASK ZONEWIDTH</h2></a>
<a name="index_x_635"></a>
<a name="index_x_636"></a>
<h2>FORMAT:</h2>

<p><pre>
        ASK ZONEWIDTH num_var 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  ASK ZONEWIDTH x 
            PRINT 'The current print zone width is'; x 
        20  END 
 
        RNH 
        The current print zone width is 20 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
<b>ASK ZONEWIDTH</b> finds the print zone width of the device 
specified and assigns the value to the numeric variable, <i>num_var</i>. 
</dl>

<p>

<a name="heading_9.17.2"><h2>9.17.2 SET ZONEWIDTH</h2></a>
<a name="index_x_637"></a>
<a name="index_x_638"></a>
<h2>FORMAT:</h2>

<p><pre>
        SET ZONEWIDTH num_expr 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  PRINT 1,2,3                                           
        20  SET ZONEWIDTH 10                                          
            PRINT 1,2,3                                               
        30  SET ZONEWIDTH 20 
        40 END                                                       
        RNH                                                          
        1                   2                   3                    
        1         2         3                                        
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
<b>SET ZONEWIDTH</b> sets the print zone width of the device 
specified to the number designated.  <i>num_expr</i> indicates the 
width to set the device's print zones. 
</dl>

<p><hr size=5>
<a name="chapter_10"><h1>Chapter 10<br>Defining Arrays</h1></a>
<a name="index_x_639"></a>
<a name="index_x_640"></a>

<p>
<b>Arrays</b> are a type of variable.  They are used to store and 
manipulate tables of variable information.  An array must be defined before 
it is used in a program.  Array variables are described in 
Section 3.2.5.1, Arrays. 

<p>

<a name="heading_10.1"><h1>10.1 Dimensioning Arrays</h1></a>
<a name="index_x_641"></a>
<a name="index_x_642"></a>

<p>
Arrays are dimensioned with a <b>DIM</b> statement.  The 
<b>REDIM</b> statement can be used to redimension an array--that 
is, to change the dimensions of an array which has been defined with the 
DIM statement.  The <b>OPTION BASE</b> statement changes the 
default low bound.  By default, the low bound is 1. 

<p>
About arrays: 
<dl>
<dd>

<ul>
  <li> The highest bound allowed is 2147483648. 
  <li> The lowest bound allowed is -2147483647. 
  <li> Each array can have up to 32 dimensions. 
  <li> See Section 3.2.5.1, Arrays for more information on 
        the storage allocation of arrays. 
  <li> If an array element outside of the specified bounds is referenced, 
        an exception is generated. 
</ul>

</dl>

<p>

<a name="heading_10.1.1"><h2>10.1.1 DIM</h2></a>
<a name="index_x_643"></a>
<a name="index_x_644"></a>
<a name="index_x_645"></a>
<h2>FORMAT:</h2>

<p><pre>
        DIM [INTEGER | REAL | STRING] 
                  array_name ([int_expr TO] int_expr [, ...]) 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  DIM name$(4) 
        20  FOR i = 1 TO 4 
              INPUT 'Enter a name': name$(i) 
            NEXT i 
        30  PRINT 
        40  FOR i = 1 TO 4 
              PRINT i; ' '; name$(i) 
            NEXT i 
        50  END 
 
        RNH 
        Enter a name? Jim 
        Enter a name? Jane 
        Enter a name? Bob 
        Enter a name? Betty 
 
         1  Jim 
         2  Jane 
         3  Bob 
         4  Betty 
</pre>

<h2>PURPOSE:</h2>

<dl>
<dd>

<p>
Use <b>DIM</b> to dimension arrays.  Arrays are used to store 
tables of variable information.  You must dimension an array before you 
can use it. 
</dl>
<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
The simplest version of a DIM statement is: 

<p><pre>
        DIM array_name(int_expr) 
</pre>

<p>
<i>array_name</i> is the name of the array being defined.  The array 
name must meet the rules for variable names.  <i>int_expr</i> is the 
high bound for the array---the highest element allowed in a dimension.  
The low bound is the lowest element allowed in a dimension.  The low bound 
defaults to 1.  For example: 

<p><pre>
        DIM NAME$(4) 
</pre>

<p>
This statement defines a one-dimensional array with four elements: 

<p><pre>
        NAME$(1) 
        NAME$(2) 
        NAME$(3) 
        NAME$(4) 
</pre>

<p>
<b>Multiple Dimensions</b>

<p>
An array can have up to 32 dimensions.  A high bound must be specified 
for each dimension. 

<p><pre>
        DIM array_name(int_expr [, int_expr, ...]) 
</pre>

<p>
For example: 

<p><pre>
        10  DIM name$(4,2) 
</pre>

<p>
This statement defines the following two-dimensional array: 

<p><pre>
        NAME$(1,1)   NAME$(1,2) 
        NAME$(2,1)   NAME$(2,2) 
        NAME$(3,1)   NAME$(3,2) 
        NAME$(4,1)   NAME$(4,2) 
</pre>

<p>
<b>Low Bounds</b>

<p>
The low bound is the lowest element a dimension can have.  Low bounds can 
be specified for each dimension of an array.  If no low bound is specified, 
the default is 1.  To specify a low bound, use the following format: 

<p><pre>
        DIM array_name (int_ expr TO int_expr) 
</pre>

<p>
The number preceding TO is the low bound.  For example: 

<p><pre>
        10  DIM name$(4,18 TO 20) 
</pre>

<p>
This statement creates an array whose first dimension contains elements 
1-4 and whose second dimension contains elements 18-20: 

<p><pre>
        NAME$(1,18)   NAME$(1,19)   NAME$(1,20)   
        NAME$(2,18)   NAME$(2,19)   NAME$(2,20)   
        NAME$(3,18)   NAME$(3,19)   NAME$(3,20)   
        NAME$(4,18)   NAME$(4,19)   NAME$(4,20)   
</pre>

</dl>

<a name="heading_10.1.2"><h2>10.1.2 REDIM</h2></a>
<a name="index_x_646"></a>
<a name="index_x_647"></a>
<a name="index_x_648"></a>
<h2>FORMAT:</h2>

<p><pre>
        REDIM array_name (int_expr, int_expr...) ... 
 
             OR 
 
        REDIM array_name [( [int_expr TO] int_expr, 
                      [int_expr TO] int_expr... )] ... 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  DIM name$(2) 
            INPUT 'How many names': num 
            REDIM name$(num) 
        20  FOR i = 1 TO num 
              INPUT 'Enter a name': name$(i) 
            NEXT i 
        30  DO 
              PRINT 
              FOR i = 1 TO num 
                IF  name$(i) = ''  THEN 
                  PRINT i; ' '; 'empty slot' 
                ELSE 
                  PRINT i; ' '; name$(i) 
                END IF 
              NEXT i 
              PRINT 
              INPUT 'How many names': num 
              IF  _BACK  or  _EXIT  THEN  EXIT DO 
              REDIM name$(num) 
            LOOP 
        40  END 
 
        RNH 
        How many names? 3 
        Enter a name? Tim 
        Enter a name? Sammy 
        Enter a name? Fred 
 
         1  Tim 
         2  Sammy 
         3  Fred 
 
        How many names? 4 
 
         1  Tim 
         2  Sammy 
         3  Fred 
         4  empty slot 
 
        How many names? exit 
</pre>

<h2>PURPOSE:</h2>

<dl>
<dd>

<p>
The <b>REDIM</b> statement is used to change the size of an array. 
</dl>

<p>
<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
REDIM redimensions arrays.  REDIM can only be used on arrays that have 
already been dimensioned with the DIM statement.  The REDIM statement has 
the same rules, options and limits as the DIM statement. 

<p>
You can dynamically expand arrays as needed.  If you REDIM a single 
dimension array or the first dimension of a multi dimensioned array to a 
larger size, the old values are kept.  If you REDIM any array to a smaller 
size or REDIM two or more dimensions in a multi dimensioned array to a 
larger size, the old values are lost. 

<p>
If your application depends on REDIM initializing all array values, change 
your code as follows: 

<p><pre>
        <b>Old Code:</b>       REDIM X(100) 
 
        <b>New Code:</b>       REDIM X(1) 
                        REDIM X(100) 
</pre>

<p>
The REDIM X(1) forces all array values to be initialized by the second 
REDIM statement. 
</dl>

<p>
<a name="bottom_010"></a>
<p>
<hr> <a href="language_011.html">Next page...</a> | 
<a href="language_contents.html">Table of Contents</a>
</body>
</html>
