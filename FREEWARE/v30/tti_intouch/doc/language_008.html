<!-- LANGUAGE_008.HTML continuation of DOCDATA:[DOC.INTOUCH]LANGUAGE.HTML -->
<html>
<head>
<title>INTOUCH&#174; 4GL </title>
</head>
<body background="/white.gif">
<h1 align="center">INTOUCH<sup>&#174;</sup> 4GL <br> A Guide to the INTOUCH Language</h1>

<hr> <a href="LANGUAGE_007.HTML#bottom_007">Previous page...</a> 
<a href="LANGUAGE_CONTENTS.HTML">Table of Contents</a>

<hr size=5>

<a name="index_x_442"></a>

<p><pre>
        CLEAR AREA [, attr_list:] row_1, col_1, row_2, col_2 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  CLEAR 
            CLEAR AREA REVERSE: 5, 10, 11, 60 
            PRINT AT 7, 20: 'Cleared area is in Reverse video' 
        20  END 
 
        RNH 
 
                  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 
                 |                                                 | 
                     Cleared area is in Reverse video 
                 |                                                 | 
 
                 |                                                 | 
                  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 
</pre>

<a name="index_x_443"></a>
<a name="index_x_444"></a>
<a name="index_x_445"></a>
<a name="index_x_446"></a>
<a name="index_x_447"></a>
<a name="index_x_448"></a>
<a name="index_x_449"></a>
<a name="index_x_450"></a>
<a name="index_x_451"></a>
<dl>
<dd>

<p>
<b>CLEAR AREA</b> allows the following attributes to be used when 
clearing an area: <b>[BOLD]</b>, <b>[BLINK]</b>, <b>[REVERSE]</b>, 
<b>[UNDERLINE]</b>.  Multiple attributes used in one statement are separated 
by commas. 
</dl>

<p>
<h2>BOX Option</h2>

<a name="index_x_452"></a>
<a name="index_x_453"></a>
<a name="index_x_454"></a>
<dl>
<dd>

<p>
The <b>BOX</b> option creates an empty box with a frame.  

<p>
<a name="index_x_455"></a>
The <b>[BOLD]</b>, <b>[BLINK]</b>, <b>[REVERSE]</b> and 
<b>[UNDERLINE]</b> attributes can also be used with the BOX option. 
Separate attributes in one statement with commas. 
</dl>

<p>
<h2>FORMAT:</h2>

<p><pre>
        CLEAR AREA BOX [, attr_list:] row_1, col_1, row_2, col_2 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  CLEAR 
            CLEAR AREA BOX, BOLD: 5, 10, 11, 60 
        20  PRINT AT 7, 20: 'Inside the box' 
            PRINT AT 12, 1: 'Outside the box' 
        30  END 
 
        RNH 
 
                 +-------------------------------------------------+ 
                 |                                                 | 
                 |         Inside the box                          | 
                 |                                                 | 
                 |                                                 | 
                 |                                                 | 
                 +-------------------------------------------------+ 
        Outside the box 
</pre>

<a name="heading_6.6"><h1>6.6 OPTION COMMUNICATE ON | OFF</h1></a>
<a name="index_x_456"></a>
<a name="index_x_457"></a>
<a name="index_x_458"></a>
<a name="index_x_459"></a>
<a name="index_x_460"></a>
<a name="index_x_461"></a>

<p>
Some VMS facilities can broadcast messages to your terminal.  INTOUCH 
will trap those messages and display them within the message area.  
Broadcast messages (communications) will stay on the screen until 
another message of any type is displayed. 

<p>
<h2>FORMAT:</h2>

<p><pre>
        OPTION COMMUNICATE ON | OFF 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  CLEAR 
            OPTION COMMUNICATE OFF 
            PRINT AT 1,1: 
        20  INPUT 'Enter your name': name$ 
            PRINT name$ 
            OPTION COMMUNICATE ON 
        30  INPUT 'Enter your name': name$ 
            PRINT name$ 
        40  END 
 
        RNH 
 
        Enter your name? Tester 
        Tester 
        Enter your name? 
 
 
           .New mail on node FAST from FAST::MOLLY        (12:01:08) 
</pre>

<h2>PURPOSE:</h2>

<dl>
<dd>

<p>
Determines whether to display messages broadcast to the terminal. 
</dl>

<p>
<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
The <b>OPTION COMMUNICATE</b> statement turns the display of 
messages ON or OFF.  The default is OPTION COMMUNICATE ON.  If there is 
a message (such as a mail message), INTOUCH displays it in the message 
area (at the bottom of the screen).  If you enter OPTION COMMUNICATE 
OFF, INTOUCH will not display messages. 
</dl>

<p><hr size=5>
<a name="chapter_7"><h1>Chapter 7<br>Program Directives</h1></a>

<p>

<a name="heading_7.1"><h1>7.1 Compile Directives</h1></a>
<a name="index_x_462"></a>
<a name="index_x_463"></a>

<p>
The following sections describe the directives that are available for 
use in your programs.  These directives are invoked when the compiler 
OLDs in a program and/or when a program is compiled. 

<p>

<a name="heading_7.1.1"><h2>7.1.1 %MESSAGE</h2></a>
<a name="index_x_464"></a>
<a name="index_x_465"></a>
<h2>FORMAT:</h2>

<p><pre>
        %MESSAGE 'quoted_text' 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  %MESSAGE 'Including HELP module' 
        20  %INCLUDE 'tti_run:help' 
        30  END 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
This compiler directive displays a message, <i>quoted_text</i>, 
on the message line.  The message is displayed when a program is OLD'ed 
into a workspace or compiled. 
</dl>

<p>

<a name="heading_7.1.2"><h2>7.1.2 %MESSAGE ERROR</h2></a>
<a name="index_x_466"></a>
<a name="index_x_467"></a>
<h2>FORMAT:</h2>

<p><pre>
        %MESSAGE ERROR: 'quoted_text' 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  %MESSAGE ERROR: 'Using experimental HELP module' 
        20  %INCLUDE 'tti_run:help' 
        30  END 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
This compiler directive rings the bell and displays an error message, 
<i>quoted_text</i>, on the message line.  The message is displayed 
when a program is OLD'ed into a workspace or compiled. 
</dl>

<p>

<a name="heading_7.1.3"><h2>7.1.3 %INCLUDE</h2></a>
<a name="index_x_468"></a>
<a name="index_x_469"></a>
<h2>FORMAT:</h2>

<p><pre>
        %INCLUDE 'file_spec' 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        1000  %INCLUDE 'tti_run:example' 
</pre>

<h2>PURPOSE:</h2>

<dl>
<dd>

<p>
<b>%INCLUDE</b> allows you to put common subroutines into a 
separate file to be shared among applications. 
</dl>
<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
%INCLUDE includes a source code, <i>file_spec</i>, file into the 
current INTOUCH program.  The included file cannot contain line numbers. 
<a name="index_x_470"></a>
The default extension for the included file is <b>.INC</b>. 
</dl>

<p>

<a name="heading_7.1.4"><h2>7.1.4 %INCLUDE CONDITIONAL</h2></a>
<a name="index_x_471"></a>
<a name="index_x_472"></a>
<h2>FORMAT:</h2>

<p><pre>
        %include CONDITIONAL: 'file_spec' 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
If the file to be included, <i>file_spec</i>, does not exist, no error 
is generated.  This allows programs to conditionally include modules. 

<p>
<b>%INCLUDE CONDITIONAL</b> includes a source code, 
<i>file_spec</i>, file into the current INTOUCH program if the file 
to be included is found.  The included file cannot contain line numbers. 
<a name="index_x_473"></a>
The default extension for the included file is <b>.INC</b>. 
</dl>

<p>

<a name="heading_7.1.5"><h2>7.1.5 %DEBUG</h2></a>
<a name="index_x_474"></a>
<a name="index_x_475"></a>
<h2>FORMAT:</h2>

<p><pre>
        %DEBUG INTOUCH_statement 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  %DEBUG PRINT 'DEBUG Items' 
        20  END 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
The <b>%DEBUG</b> directive gives an error <u>only</u>
if an image compile (/COMPILE) is being done.  Use this directive to make 
sure that DEBUG code does not show up in production applications. 
</dl>

<p><hr size=5>
<a name="chapter_8"><h1>Chapter 8<br>Assigning Variables</h1></a>
<a name="index_x_476"></a>

<p>
Variables specify storage locations.  Numeric and string variables are 
assigned values with the LET statement.  String variables can also be 
assigned values with the LSET, RSET and CSET statements. 

<p>
The LET statement assigns the value of an expression to a variable.  
The expression is evaluated and its value is stored in the location 
specified by the variable.  The data types of the expression and 
the variable must match.  Thus, you must assign a string variable 
string values and you must assign numeric variables numeric 
values.  A string variable must end with a dollar sign "$" unless 
you declare it.  An integer variable must end with a percent sign 
(%) unless you declare it. 

<p>
<a name="index_x_477"></a>
The DECLARE statement allows you to dispense with data type 
designations.  DECLARE declares a variable as either string, 
integer or real.  Once the variable has been declared, you do not 
need to attach a $ or % to it.  Functions, arrays, etc., can also be 
declared with the DECLARE statement. 

<p>

<a name="heading_8.1"><h1>8.1 DECLARE</h1></a>
<a name="index_x_478"></a>
<a name="index_x_479"></a>
<h2>FORMAT:</h2>

<p><pre>
        DECLARE [STRING | INTEGER | REAL | DYNAMIC] var, var... 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  DECLARE STRING name, sex 
            DECLARE INTEGER age 
            DECLARE REAL amount 
            DECLARE DYNAMIC anything 
        20  INPUT 'Enter your name': name 
            INPUT 'Enter your age': age 
            INPUT 'Enter your sex': sex 
            INPUT 'Enter an amount': amount 
        30  PRINT 
            PRINT name; ' is a'; AGE; 'year old '; sex 
            PRINT name; ' entered the amount'; amount 
        40  anything = 4 + 5 
            PRINT 'This dynamic variable contains: '; anything 
            anything = 'kitty' 
            PRINT 'Now it contains a string value: '; anything 
        50  END 
 
        RNH 
        Enter your name? Sammy 
        Enter your age? 28 
        Enter your sex? male 
        Enter an amount? 25.38 
 
        Sammy is a 28 year old male 
        Sammy entered the amount 25.38 
        This dynamic variable contains:  9 
        Now it contains a string value: kitty 
</pre>

<h2>PURPOSE:</h2>

<dl>
<dd>

<p>
Use <b>DECLARE</b> to specify the data types of variables, 
functions, etc.  Once you have declared the data type of a variable or 
function, you do not have to designate them with a trailing $ or %. 
</dl>
<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
<a name="index_x_480"></a>
<a name="index_x_481"></a>
<a name="index_x_482"></a>
<a name="index_x_483"></a>
DECLARE declares the data type of a variable or function.  The 
<b>STRING</b> option indicates that the following are string 
variables or functions.  <b>INTEGER</b> declares integer numeric. 
<b>REAL</b> indicates real numeric.  Only one of the three data 
type options can be used in each DECLARE statement.  Any number of variables 
can be declared with a DECLARE statement. 

<p>
<b>DECLARE DYNAMIC</b> declares one or more variables to be of 
type DYNAMIC.  A variable of type DYNAMIC receives the data type of the 
data that you put into it. 

<p>
<a name="index_x_484"></a>
You can find out the current data type of a dynamic variable with the 
DTYPE function.  (See DTYPE(expr)) 
</dl>

<p>

<a name="heading_8.1.1"><h2>8.1.1 DECLARE STRUCTURE</h2></a>
<a name="index_x_485"></a>
<a name="index_x_486"></a>
<h2>FORMAT:</h2>

<p><pre>
        DECLARE STRUCTURE struc_name1 [, struc_name2 ...] 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  DECLARE STRUCTURE str 
            OPEN STRUCTURE cl: NAME 'tti_run:client' 
            ASK STRUCTURE cl: ID cl_id$ 
            SET STRUCTURE str: ID cl_id$ 
        20  EXTRACT STRUCTURE str 
            END EXTRACT 
            FOR EACH str 
              PRINT str(#1); ' '; str(#2) 
            NEXT str 
        30  END 
 
        RNH 
        20000 Smith 
        20001 Jones 
        20002 Kent 
        23422 Johnson 
        32001 Waters 
        43223 Errant 
        80542 Brock 
        80543 Cass 
        80544 Porter 
        80561 Derringer 
        80573 Farmer 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
<b>DECLARE STRUCTURE</b> declares one or more symbols to be of 
type <b>STRUCTURE</b>.  Once you have declared a symbol to be 
of type STRUCTURE, you can use it in statements such as 
SET STRUCTURE..ID to write generalized routines where you do not 
know at compile time which structure you are going to use. 

<p>
Usage example:  This statement could be used in the situation where you 
have a transaction structure and a transaction history structure and, 
optionally, want a report on one or the other.  You could use one report 
program and the DECLARE STRUCTURE statement to declare which structure 
to use when the user makes the report selection. 
</dl>

<p>

<a name="heading_8.1.2"><h2>8.1.2 DECLARE PREFIX</h2></a>
<a name="index_x_487"></a>
<a name="index_x_488"></a>
<h2>FORMAT:</h2>

<p><pre>
        DECLARE PREFIX str_expr 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        irp$total   prefix is IRP 
        doit$now$   prefix is DOIT 
        doing_it$   there is no prefix 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
Any variable that contains as part of the body of its name a "$" is 
<a name="index_x_489"></a>
said to be a PREFIXED variable. 

<p>
<a name="index_x_490"></a>
In some cases, you might want an IMPLICIT prefix for variables in a 
routine.  To declare an IMPLICIT prefix: 

<p><pre>
        DECLARE PREFIX prefix_name 
</pre>

</dl>
<h2>EXAMPLE:</h2>

<p><pre>
        PRINT total    &lt;--&gt;  PRINT doit$total 
        PRINT name$    &lt;--&gt;  PRINT doit$name$ 
        PRINT xyz$sum  &lt;--&gt;  PRINT xyz$sum    (prefix is explicitly given) 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
The <b>DECLARE PREFIX</b> statement causes all non-prefixed variable 
references, structure name references and field name references to inherit 
a prefix (i.e. "DOIT").  

<p>
Declared prefixes are local to the routine that they are declared in.  For 
this first release, nested declared prefixes are not supported.  The 
following statements turn OFF any declared prefixing: 

<p><pre>
        ROUTINE routine_name 
        END ROUTINE 
        DECLARE PREFIX none 
</pre>

<p>
In addition, at run time, prefixing is turned off before and after a string 
is <b>EXECUTE</b>d.  (See Section 11.3 for 
information on the EXECUTE statement.)  This allows you to locally prefix 
executed code: 

<p><pre>
        10  a = 100 
        20  EXECUTE 'DECLARE PREFIX excode \ a = 45 \ PRINT a' 
        30  PRINT a 
        40  EXECUTE 'PRINT excode$a' 
        50  END 
 
        RNH 
        45 
        100 
        45 
</pre>

<p>
If you want the same prefix to be used throughout an entire procedure, 
you need to put a DECLARE PREFIX at the beginning of the procedure and 
after every ROUTINE statement. 

<p>
When referencing structure field names and using a prefix, you must: 

<p><pre>
        STRUC(#'field_name') 
 
               so: 
 
        VEND(city)  --&gt; vend(#'city') 
</pre>

<p>
Without the quotes, CITY would receive a prefix and would be an invalid 
field name. 

<p>
Prefixing also applies to structure names.  Therefore, if the structure 
is not opened within the prefixed routine that references it, you must 
have opened the structure with an explicit prefix. 

<p><pre>
        10  OPEN STRUCTURE ar$cust : NAME 'tti_run::customer', ACCESS INPUT 
            GOSUB find_customer 
            STOP 
 
       100  ROUTINE find_customer 
              DECLARE PREFIX find 
              c$ = '13727' 
              SET STRUCTURE ar$cust, FIELD custnbr : KEY c$ 
              PRINT ar$cust(#'name') 
            END ROUTINE 
       999  END 
</pre>

</dl>

<a name="heading_8.2"><h1>8.2 OPTION Statements</h1></a>

<p>

<a name="heading_8.2.1"><h2>8.2.1 OPTION REQUIRE DECLARE</h2></a>
<a name="index_x_491"></a>
<a name="index_x_492"></a>
<h2>FORMAT:</h2>

<p><pre>
        OPTION REQUIRE DECLARE 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  OPTION REQUIRE DECLARE 
        20  DECLARE STRING name, comment 
        30  INPUT 'Please enter your name': name 
        40  LINE INPUT 'Enter a comment in quotes': comment 
        50  PRINT name; ' says, '; comment 
        60  END 
 
        RNH 
        Please enter your name? George 
        Enter a comment in quotes? 'Have a nice day!' 
        George says, 'Have a nice day!' 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
<b>OPTION REQUIRE DECLARE</b> causes INTOUCH to require all 
variables in the program to be declared.  If the OPTION REQUIRE DECLARE 
statement is used and a variable is left undeclared, INTOUCH will 
return an error when program execution is attempted.  The OPTION 
REQUIRE DECLARE statement should occur before any DECLARE statements 
and before any variables are assigned. 
</dl>

<p>

<a name="heading_8.2.2"><h2>8.2.2 OPTION BASE</h2></a>
<a name="index_x_493"></a>
<a name="index_x_494"></a>
<h2>FORMAT:</h2>

<p><pre>
        OPTION BASE  [0 | 1] 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
<b>OPTION BASE</b> sets the lowest subscript or base for arrays. 
The base can be either zero or one.  If you use OPTION BASE 0, the lowest 
element of an array has the subscript zero (0).  If you use OPTION BASE 1, 
the lowest element is subscript one (1). 

<p>
See Section 10.1.3 for an example and detailed 
information on this statement. 
</dl>

<p>

<a name="heading_8.3"><h1>8.3 LET</h1></a>
<a name="index_x_495"></a>
<a name="index_x_496"></a>
<h2>FORMAT:</h2>

<p><pre>
        [LET] var = expr 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  INPUT 'Last name': last$ 
            INPUT 'First name': first$ 
            LET name$ = first$ &amp; ' ' &amp; last$ 
            PRINT name$ 
        20  END 
 
        RNH 
        Last name? Taylor 
        First name? Rick 
        Rick Taylor 
</pre>

<h2>PURPOSE:</h2>

<dl>
<dd>

<p>
Use the <b>LET</b> statement to store information into a variable 
or data structure. 
</dl>
<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
<i>var</i> is the variable being assigned a value.  <i>expr</i>
is an expression.   The expression is evaluated and its result is assigned 
to the variable.  The expression can be any INTOUCH expression (see 
Section 3.2.) The variable and the expression data 
types must match.  For instance, if <i>var</i> is a string variable, 
<i>expr</i> must be a string expression. 

<p>
<b>NOTE: </b> The keyword LET is optional.  For example: 

<p><pre>
        LET name$ = first$ &amp; ' ' &amp; last$ 
</pre>

can be stated as: 

<p><pre>
        name$ = first$ &amp; ' ' &amp; last$ 
</pre>

<p>
When INTOUCH executes the LET statement, it first evaluates the expression 
on the right side of the equal sign.  It then assigns this value to the 
variable on the left side of the equal sign.  The variable represents a 
location in memory.  The value of the expression is stored in this location. 
Each time a new value is assigned, the old value is lost and the new value 
is stored in its memory location. 

<p>
<b>Assigning Numeric Values</b>

<ul>
  <li> Assigning a numeric value to a string variable results in an error. 
  <li> Assigning a real value to an integer variable causes the real number 
        to be rounded to the nearest integer and assigned. 
</ul>

<p><pre>
        10  INPUT 'Amount': amount 
            LET rounded% = amount 
        20  PRINT 'Real numeric amount:'; amount 
            PRINT 'Integer amount (after rounding):'; rounded% 
        30  END 
 
        RNH 
        Amount? 1.54 
        Real numeric amount: 1.54 
        Integer amount (after rounding): 2 
</pre>

<p>
<b>Assigning String Values</b>

<ul>
  <li> Assigning a string value to a numeric variable results in an error. 
  <li> String variables are dynamic in length.  String variables can be 
        assigned values of up to 65535 characters in length. 
</ul>

</dl>

<p>

<a name="heading_8.4"><h1>8.4 LSET, RSET and CSET</h1></a>
<a name="index_x_497"></a>
<a name="index_x_498"></a>
<a name="index_x_499"></a>
<a name="index_x_500"></a>

<p>
LSET, RSET and CSET assign string values to variables.  LSET left-justifies 
the new value.  RSET right-justifies and CSET center-justifies it.  These 
statements can only be used to assign <i>string</i> values. 

<p>
LSET, RSET and CSET justify the new value <i>within</i> the length of 
the previous value.  For example, in the following program, HEADING$ has a 
length of twenty characters and consists of twenty dots: 

<p><pre>
        10  heading$ = REPEAT$('.', 20)          ! Twenty dots 
        20  PRINT '('; heading$; ')' 
        30  END 
 
        RNH 
        (....................) 
</pre>

<p>
In the following example, the RSET statement is used to assign the new 
value 'Page 12' to HEADING$.  INTOUCH uses the current length of HEADING$, 
20 characters, and replaces it with the new value, 'Page 12'.  INTOUCH 
<i>right-justifies</i> this value by padding it with 13 leading spaces. 
Thus, HEADING$ still has a length of twenty characters. 

<p><pre>
        10  heading$ = REPEAT$('.', 20)          ! Twenty dots 
            PRINT '('; heading$; ')' 
        20  RSET heading$ = 'Page 12' 
            PRINT '('; heading$; ')' 
        30  END 
 
        RNH 
        (....................) 
        (             Page 12) 
</pre>

<p>

<a name="heading_8.4.1"><h2>8.4.1 LSET</h2></a>
<a name="index_x_501"></a>
<a name="index_x_502"></a>
<h2>FORMAT:</h2>

<p><pre>
        LSET str_var = str_expr 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  heading$ = REPEAT$('.', 20)          ! Twenty dots 
        20  PRINT '('; heading$; ')' 
        30  LSET heading$ = 'Page 12' 
            PRINT '('; heading$; ')' 
        40  END 
 
        RNH 
        (....................) 
        (Page 12             ) 
</pre>

<h2>PURPOSE:</h2>

<dl>
<dd>

<p>
Use <b>LSET</b> to left-justify string data. 
</dl>
<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
When INTOUCH executes an LSET statement, it evaluates the string expression 
on the right side of the equal sign.  INTOUCH assigns the new value to the 
string variable and left-justifies this value within the length of the old 
value.  If the new value has leading or trailing spaces, these spaces are 
carried over and the string is justified with those spaces.  LSET can only 
be used with strings. 
</dl>

<p>

<a name="heading_8.4.2"><h2>8.4.2 RSET </h2></a>
<a name="index_x_503"></a>
<a name="index_x_504"></a>
<h2>FORMAT:</h2>

<p><pre>
        RSET str_var = str_expr 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  heading$ = REPEAT$('.', 20)          ! Twenty dots 
        20  PRINT '('; heading$ ;')' 
        30  RSET heading$ = 'Page 12' 
            PRINT '(' ; heading$ ; ')' 
        40  END 
 
        RNH 
        (....................) 
        (             Page 12) 
</pre>

<h2>PURPOSE:</h2>

<dl>
<dd>

<p>
Use <b>RSET</b> to right-justify string data. 
</dl>
<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
When INTOUCH executes the RSET statement, it evaluates the string expression 
on the right side of the equal sign.  INTOUCH assigns the new value to the 
string variable and right-justifies this value within the length of the old 
value.  If the new value has leading or trailing spaces, these spaces are 
carried over and the string is justified with those spaces.  RSET can only 
be used with strings. 
</dl>

<p>

<a name="heading_8.4.3"><h2>8.4.3 CSET</h2></a>
<a name="index_x_505"></a>
<a name="index_x_506"></a>
<h2>FORMAT:</h2>

<p><pre>
        CSET str_var = str_expr 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  heading$ = REPEAT$('.', 20)          ! Twenty dots 
        20  PRINT '('; heading$; ')' 
        30  CSET heading$ = 'Page 12' 
            PRINT '('; heading$; ')' 
        40  END 
 
        RNH 
        (....................) 
        (       Page 12      ) 
</pre>

<h2>PURPOSE:</h2>

<dl>
<dd>

<p>
Use <b>CSET</b> to center string data. 
</dl>
<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
When INTOUCH executes the CSET statement, it evaluates the expression on 
the right side of the equal sign.  Next, INTOUCH assigns the new value to 
the string variable and centers it within the length of the old value.  If 
the string value has leading or trailing spaces, the spaces are carried 
over and the string is centered with those spaces.  CSET can only be used 
with strings. 
</dl>

<p>

<a name="heading_8.5"><h1>8.5 LSET, RSET, CSET FILL</h1></a>
<a name="index_x_507"></a>
<a name="index_x_508"></a>
<a name="index_x_509"></a>
<a name="index_x_510"></a>
<a name="index_x_511"></a>
<a name="index_x_512"></a>
<h2>FORMAT:</h2>

<p><pre>
        LSET | RSET | CSET FILL str_expr: str_var = expr 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  heading$ = REPEAT$('.', 20)          ! Twenty dots 
        20  PRINT '('; heading$; ')' 
        30  CSET FILL '*': heading$ = 'Page 12' 
            PRINT '('; heading$; ')' 
        40  END 
 
        RNH 
        (....................) 
        (*******Page 12******) 
</pre>

<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
The value of <i>expr</i> is left-justified, right-justified or 
centered inside the <i>str_var</i>.  The remaining part of the 
string is filled with the pattern specified by <i>str_expr</i>. 
If <i>str_expr</i> is the null string, no filling occurs---the 
remaining part of the string is left as is. 
</dl>

<p>

<a name="heading_8.6"><h1>8.6 DATA, READ, RESTORE Statements</h1></a>

<p>

<a name="heading_8.6.1"><h2>8.6.1 READ</h2></a>
<a name="index_x_513"></a>
<a name="index_x_514"></a>
<a name="index_x_515"></a>
<a name="index_x_516"></a>
<h2>FORMAT:</h2>

<p><pre>
        DATA [num_const | str_const] [,[num_const | str_const]...] 
                      . 
                      . 
                      . 
        READ [num_var | str_var] [,[num_var | str_var]...] 
</pre>

<h2>EXAMPLE:</h2>

<p><pre>
        10  DIM months$(6) 
        20  DATA January, February, March 
        30  DATA April, May, June 
        40  FOR i = 1 TO 6 
              READ months$(i) 
              PRINT months$(i) 
            NEXT i 
        50  END 
 
        RNH 
        January 
        February 
        March 
        April 
        May 
        June 
</pre>

<h2>PURPOSE:</h2>

<dl>
<dd>

<p>
Use <b>DATA</b> and <b>READ</b> statements to assign 
data to variables in cases where the data will not change with successive 
runs of the program. 
</dl>
<h2>DESCRIPTION:</h2>

<dl>
<dd>

<p>
The READ and DATA statements assign data to variables.  DATA specifies a 
list of data to assign.  The data must be given as constants and can be 
string, numeric or integer types.  Multiple data items must be separated 
by commas. 

<p>
The READ statement specifies a list of variables to assign data to. 
The variables can be string, numeric or integer variables.  They can 
be substrings, array elements, etc.. 

<p>
When INTOUCH executes the first READ statement, it goes to the first 
DATA statement and assigns the items in the DATA list to the variables 
in the READ list.  The first variable in the READ list is assigned 
the first value in the DATA list.  The second variable in the READ 
list is assigned the second value in the DATA list, and so on. 

<p><pre>
        DATA constant, constant, constant, constant... 
        .          
        .       |         |         |         | 
        .                                   
        READ variable, variable, variable, variable... 
</pre>

<p>
If the data item contains a commas, the data item should be enclosed with 
single or double quotes.  For example: 

<p><pre>
        10  DIM amounts$(3) 
        20  DATA '$25,000', '$250,000', '$2,500,000' 
        30  READ amounts$(1), amounts$(2), amounts$(3) 
        40  PRINT amounts$(1), amounts$(2), amounts$(3) 
        50  END 
 
        RNH 
        $25,000             $250,000            $2,500,000 
</pre>

<p>
The variable types and data types must match or an exception will result. 
For example, if the third item in the DATA list is a string constant, and 
the third variable in the READ list is a numeric variable, an exception 
will result. 

<p>
When the second READ statement is executed, INTOUCH starts reading from 
the first unread data item in the DATA list.  For example: 

<p><pre>
         10  DIM months$(4) 
         20  DATA January, February, March, April, May, June 
         30  READ months$(1), months$(2) 
         40  READ months$(3), months$(4) 
         50  PRINT months$(1), months$(2), months$(3), months$(4) 
         60  END 
 
         RNH 
         January     February      March      April 
</pre>

<p>
In the example above, when the first READ statement is executed, INTOUCH 
reads the months January and February.  When the second READ statement is 
executed, INTOUCH will continue at the first unread month--March--and 
read it into months$(3). 

<p>
If you attempt to read more data than exists, that is, if your READ list 
has more items than than your DATA list, an exception will result.  You 
<a name="index_x_517"></a>
can avoid this by using the <b>RESTORE</b> statement to restore 
the DATA list and read from the beginning again. 

<p>
The READ and DATA statements must occur in the same program unit.  For 
example, you cannot not have your DATA statements in the main program unit 
and your matching READ statements in a subprogram. 

<p>
See Section 8.6.2 for information on using RESTORE. 
</dl>

<p>
<a name="bottom_008"></a>
<p>
<hr> <a href="language_009.html">Next page...</a> | 
<a href="language_contents.html">Table of Contents</a>
</body>
</html>
