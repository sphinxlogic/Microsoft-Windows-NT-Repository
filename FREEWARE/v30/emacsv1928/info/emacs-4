This is Info file ../info/emacs, produced by Makeinfo-1.54 from the
input file emacs.texi.


File: emacs,  Node: Using Region,  Next: Marking Objects,  Prev: Transient Mark,  Up: Mark

Operating on the Region
=======================

   Once you have a region and the mark is active, here are some of the
ways you can operate on the region:

   * Kill it with `C-w' (*note Killing::.).

   * Save it in a register with `C-x r s' (*note Registers::.).

   * Save it in a buffer or a file (*note Accumulating Text::.).

   * Convert case with `C-x C-l' or `C-x C-u' (*note Case::.).

   * Indent it with `C-x TAB' or `C-M-\' (*note Indentation::.).

   * Fill it as text with `M-x fill-region' (*note Filling::.).

   * Print hardcopy with `M-x print-region' (*note Hardcopy::.).

   * Evaluate it as Lisp code with `M-x eval-region' (*note Lisp
     Eval::.).

   Most commands that operate on the text in the region have the word
`region' in their names.


File: emacs,  Node: Marking Objects,  Next: Mark Ring,  Prev: Using Region,  Up: Mark

Commands to Mark Textual Objects
================================

   Here are the commands for placing point and the mark around a textual
object such as a word, list, paragraph or page.

`M-@'
     Set mark after end of next word (`mark-word').  This command and
     the following one do not move point.

`C-M-@'
     Set mark after end of next Lisp expression (`mark-sexp').

`M-h'
     Put region around current paragraph (`mark-paragraph').

`C-M-h'
     Put region around current Lisp defun (`mark-defun').

`C-x h'
     Put region around entire buffer (`mark-whole-buffer').

`C-x C-p'
     Put region around current page (`mark-page').

   `M-@' (`mark-word') puts the mark at the end of the next word, while
`C-M-@' (`mark-sexp') puts it at the end of the next Lisp expression.
These commands handle arguments just like `M-f' and `C-M-f'.

   Other commands set both point and mark, to delimit an object in the
buffer.  For example, `M-h' (`mark-paragraph') moves point to the
beginning of the paragraph that surrounds or follows point, and puts
the mark at the end of that paragraph (*note Paragraphs::.).  It
prepares the region so you can indent, case-convert, or kill a whole
paragraph.

   `C-M-h' (`mark-defun') similarly puts point before and the mark
after the current or following defun (*note Defuns::.).  `C-x C-p'
(`mark-page') puts point before the current page, and mark at the end
(*note Pages::.).  The mark goes after the terminating page delimiter
(to include it), while point goes after the preceding page delimiter
(to exclude it).  A numeric argument specifies a later page (if
positive) or an earlier page (if negative) instead of the current page.

   Finally, `C-x h' (`mark-whole-buffer') sets up the entire buffer as
the region, by putting point at the beginning and the mark at the end.

   In Transient Mark mode, all of these commands activate the mark.


File: emacs,  Node: Mark Ring,  Next: Global Mark Ring,  Prev: Marking Objects,  Up: Mark

The Mark Ring
=============

   Aside from delimiting the region, the mark is also useful for
remembering a spot that you may want to go back to.  To make this
feature more useful, each buffer remembers 16 previous locations of the
mark, in the "mark ring".  Commands that set the mark also push the old
mark onto this ring.  To return to a marked location, use `C-u C-SPC'
(or `C-u C-@'); this is the command `set-mark-command' given a numeric
argument.  It moves point to where the mark was, and restores the mark
from the ring of former marks.  Thus, repeated use of this command
moves point to all of the old marks on the ring, one by one.  The mark
positions you move through in this way are not lost; they go to the end
of the ring.

   Each buffer has its own mark ring.  All editing commands use the
current buffer's mark ring.  In particular, `C-u C-SPC' always stays in
the same buffer.

   Many commands that can move long distances, such as `M-<'
(`beginning-of-buffer'), start by setting the mark and saving the old
mark on the mark ring.  This is to make it easier for you to move back
later.  Searches set the mark if they move point.  You can tell when a
command sets the mark because it displays `Mark Set' in the echo area.

   If you want to move back to the same place over and over, the mark
ring may not be convenient enough.  If so, you can record the position
in a register for later retrieval (*note RegPos::.).

   The variable `mark-ring-max' specifies the maximum number of entries
to keep in the mark ring.  If that many entries exist and another one
is pushed, the last one in the list is discarded.  Repeating `C-u
C-SPC' circulates through the positions currently in the ring.

   The variable `mark-ring' holds the mark ring itself, as a list of
marker objects in the order most recent first.  This variable is local
in every buffer.


File: emacs,  Node: Global Mark Ring,  Prev: Mark Ring,  Up: Mark

The Global Mark Ring
====================

   In addition to the ordinary mark ring that belongs to each buffer,
Emacs has a single "global mark ring".  It records a sequence of
buffers in which you have recently set the mark, so you can go back to
those buffers.

   Setting the mark always makes an entry on the current buffer's mark
ring.  If you have switched buffers since the previous mark setting, the
new mark position makes an entry on the global mark ring also.  The
result is that the global mark ring records a sequence of buffers that
you have been in, and, for each buffer, a place where you set the mark.

   The command `C-x C-SPC' (`pop-global-mark') jumps to the buffer and
position of the latest entry in the global ring.  It also rotates the
ring, so that successive uses of `C-x C-SPC' take you to earlier and
earlier buffers.


File: emacs,  Node: Killing,  Next: Yanking,  Prev: Mark,  Up: Top

Deletion and Killing
====================

   Most commands which erase text from the buffer save it in the kill
ring so that you can move or copy it to other parts of the buffer.
These commands are known as "kill" commands.  The rest of the commands
that erase text do not save it in the kill ring; they are known as
"delete" commands.  (This distinction is made only for erasure of text
in the buffer.)  If you do a kill or delete command by mistake, you can
use the `C-x u' (`undo') command to undo it (*note Undo::.).

   The delete commands include `C-d' (`delete-char') and DEL
(`delete-backward-char'), which delete only one character at a time,
and those commands that delete only spaces or newlines.  Commands that
can destroy significant amounts of nontrivial data generally kill.  The
commands' names and individual descriptions use the words `kill' and
`delete' to say which they do.

* Menu:

* Deletion::            Commands for deleting small amounts of text and
                          blank areas.
* Killing by Lines::    How to kill entire lines of text at one time.
* Other Kill Commands:: Commands to kill large regions of text and
                          syntactic units such as words and sentences.


File: emacs,  Node: Deletion,  Next: Killing by Lines,  Up: Killing

Deletion
--------

`C-d'
     Delete next character (`delete-char').

`DEL'
     Delete previous character (`delete-backward-char').

`M-\'
     Delete spaces and tabs around point (`delete-horizontal-space').

`M-SPC'
     Delete spaces and tabs around point, leaving one space
     (`just-one-space').

`C-x C-o'
     Delete blank lines around the current line (`delete-blank-lines').

`M-^'
     Join two lines by deleting the intervening newline, along with any
     indentation following it (`delete-indentation').

   The most basic delete commands are `C-d' (`delete-char') and DEL
(`delete-backward-char').  `C-d' deletes the character after point, the
one the cursor is "on top of".  This doesn't move point.  DEL deletes
the character before the cursor, and moves point back.  You can delete
newlines like any other characters in the buffer; deleting a newline
joins two lines.  Actually, `C-d' and DEL aren't always delete
commands; when given arguments, they kill instead, since they can erase
more than one character this way.

   The other delete commands are those which delete only whitespace
characters: spaces, tabs and newlines.  `M-\'
(`delete-horizontal-space') deletes all the spaces and tab characters
before and after point.  `M-SPC' (`just-one-space') does likewise but
leaves a single space after point, regardless of the number of spaces
that existed previously (even zero).

   `C-x C-o' (`delete-blank-lines') deletes all blank lines after the
current line.  If the current line is blank, it deletes all blank lines
preceding the current line as well (leaving one blank line, the current
line).

   `M-^' (`delete-indentation') joins the current line and the previous
line, by deleting a newline and all surrounding spaces, usually leaving
a single space.  *Note M-^: Indentation.


File: emacs,  Node: Killing by Lines,  Next: Other Kill Commands,  Prev: Deletion,  Up: Killing

Killing by Lines
----------------

`C-k'
     Kill rest of line or one or more lines (`kill-line').

   The simplest kill command is `C-k'.  If given at the beginning of a
line, it kills all the text on the line, leaving it blank.  When used
on a blank line, it kills the whole line including its newline.  To kill
an entire non-blank line, go to the beginning and type `C-k' twice.

   More generally, `C-k' kills from point up to the end of the line,
unless it is at the end of a line.  In that case it kills the newline
following point, thus merging the next line into the current one.
Spaces and tabs that you can't see at the end of the line are ignored
when deciding which case applies, so if point appears to be at the end
of the line, you can be sure `C-k' will kill the newline.

   When `C-k' is given a positive argument, it kills that many lines
and the newlines that follow them (however, text on the current line
before point is spared).  With a negative argument -N, it kills N lines
preceding the current line (together with the text on the current line
before point).  Thus, `C-u - 2 C-k' at the front of a line kills the
two previous lines.

   `C-k' with an argument of zero kills the text before point on the
current line.

   If the variable `kill-whole-line' is non-`nil', `C-k' at the very
beginning of a line kills the entire line including the following
newline.  This variable is normally `nil'.


File: emacs,  Node: Other Kill Commands,  Prev: Killing by Lines,  Up: Killing

Other Kill Commands
-------------------

`C-w'
     Kill region (from point to the mark) (`kill-region').

`M-d'
     Kill word (`kill-word').  *Note Words::.

`M-DEL'
     Kill word backwards (`backward-kill-word').

`C-x DEL'
     Kill back to beginning of sentence (`backward-kill-sentence').
     *Note Sentences::.

`M-k'
     Kill to end of sentence (`kill-sentence').

`C-M-k'
     Kill sexp (`kill-sexp').  *Note Lists::.

`M-z CHAR'
     Kill through the next occurrence of CHAR (`zap-to-char').

   A kill command which is very general is `C-w' (`kill-region'), which
kills everything between point and the mark.  With this command, you
can kill any contiguous sequence of characters, if you first set the
region around them.

   A convenient way of killing is combined with searching: `M-z'
(`zap-to-char') reads a character and kills from point up to (and
including) the next occurrence of that character in the buffer.  A
numeric argument acts as a repeat count.  A negative argument means to
search backward and kill text before point.

   Other syntactic units can be killed: words, with `M-DEL' and `M-d'
(*note Words::.); sexps, with `C-M-k' (*note Lists::.); and sentences,
with `C-x DEL' and `M-k' (*note Sentences::.).

   You can use kill commands in read-only buffers.  They don't actually
change the buffer, and they beep to warn you of that, but they do copy
the text you tried to kill into the kill ring, so you can yank it into
other buffers.  Most of the kill commands move point across the text
they copy in this way, so that successive kill commands build up a
single kill ring entry as usual.


File: emacs,  Node: Yanking,  Next: Accumulating Text,  Prev: Killing,  Up: Top

Yanking
=======

   "Yanking" means reinserting text previously killed.  This is what
some systems call "pasting".  The usual way to move or copy text is to
kill it and then yank it elsewhere one or more times.

`C-y'
     Yank last killed text (`yank').

`M-y'
     Replace text just yanked with an earlier batch of killed text
     (`yank-pop').

`M-w'
     Save region as last killed text without actually killing it
     (`kill-ring-save').

`C-M-w'
     Append next kill to last batch of killed text (`append-next-kill').

* Menu:

* Kill Ring::		Where killed text is stored.  Basic yanking.
* Appending Kills::	Several kills in a row all yank together.
* Earlier Kills::	Yanking something killed some time ago.


File: emacs,  Node: Kill Ring,  Next: Appending Kills,  Up: Yanking

The Kill Ring
-------------

   All killed text is recorded in the "kill ring", a list of blocks of
text that have been killed.  There is only one kill ring, shared by all
buffers, so you can kill text in one buffer and yank it in another
buffer.  This is the usual way to move text from one file to another.
(*Note Accumulating Text::, for some other ways.)

   The command `C-y' (`yank') reinserts the text of the most recent
kill.  It leaves the cursor at the end of the text.  It sets the mark at
the beginning of the text.  *Note Mark::.

   `C-u C-y' leaves the cursor in front of the text, and sets the mark
after it.  This happens only if the argument is specified with just a
`C-u', precisely.  Any other sort of argument, including `C-u' and
digits, specifies an earlier kill to yank (*note Earlier Kills::.).

   To copy a block of text, you can use `M-w' (`kill-ring-save'), which
copies the region into the kill ring without removing it from the
buffer.  This is approximately equivalent to `C-w' followed by `C-x u',
except that `M-w' does not alter the undo history and does not
temporarily change the screen.


File: emacs,  Node: Appending Kills,  Next: Earlier Kills,  Prev: Kill Ring,  Up: Yanking

Appending Kills
---------------

   Normally, each kill command pushes a new entry onto the kill ring.
However, two or more kill commands in a row combine their text into a
single entry, so that a single `C-y' yanks all the text as a unit, just
as it was before it was killed.

   Thus, if you want to yank text as a unit, you need not kill all of it
with one command; you can keep killing line after line, or word after
word, until you have killed it all, and you can still get it all back at
once.

   Commands that kill forward from point add onto the end of the
previous killed text.  Commands that kill backward from point add text
onto the beginning.  This way, any sequence of mixed forward and
backward kill commands puts all the killed text into one entry without
rearrangement.  Numeric arguments do not break the sequence of
appending kills.  For example, suppose the buffer contains this text:

     This is a line -!-of sample text.

with point shown by -!-.  If you type `M-d M-DEL M-d M-DEL', killing
alternately forward and backward, you end up with `a line of sample' as
one entry in the kill ring, and `This is  text.' in the buffer.  (Note
the double space, which you can clean up with `M-SPC' or `M-q'.)

   Another way to kill the same text is to move back two words with
`M-b M-b', then kill all four words forward with `C-u M-d'.  This
produces exactly the same results in the buffer and in the kill ring.
`M-f M-f C-u M-DEL' kills the same text, all going backward; once
again, the result is the same.  The text in the kill ring entry always
has the same order that it had in the buffer before you killed it.

   If a kill command is separated from the last kill command by other
commands (not just numeric arguments), it starts a new entry on the kill
ring.  But you can force it to append by first typing the command
`C-M-w' (`append-next-kill') right before it.  The `C-M-w' tells the
following command, if it is a kill command, to append the text it kills
to the last killed text, instead of starting a new entry.  With
`C-M-w', you can kill several separated pieces of text and accumulate
them to be yanked back in one place.


File: emacs,  Node: Earlier Kills,  Prev: Appending Kills,  Up: Yanking

Yanking Earlier Kills
---------------------

   To recover killed text that is no longer the most recent kill, use
the `M-y' command (`yank-pop').  It takes the text previously yanked
and replaces it with the text from an earlier kill.  So, to recover the
text of the next-to-the-last kill, first use `C-y' to yank the last
kill, and then use `M-y' to replace it with the previous kill.  `M-y'
is allowed only after a `C-y' or another `M-y'.

   You can understand `M-y' in terms of a "last yank" pointer which
points at an entry in the kill ring.  Each time you kill, the "last
yank" pointer moves to the newly made entry at the front of the ring.
`C-y' yanks the entry which the "last yank" pointer points to.  `M-y'
moves the "last yank" pointer to a different entry, and the text in the
buffer changes to match.  Enough `M-y' commands can move the pointer to
any entry in the ring, so you can get any entry into the buffer.
Eventually the pointer reaches the end of the ring; the next `M-y'
moves it to the first entry again.

   `M-y' moves the "last yank" pointer around the ring, but it does not
change the order of the entries in the ring, which always runs from the
most recent kill at the front to the oldest one still remembered.

   `M-y' can take a numeric argument, which tells it how many entries
to advance the "last yank" pointer by.  A negative argument moves the
pointer toward the front of the ring; from the front of the ring, it
moves "around" to the last entry and continues forward from there.

   Once the text you are looking for is brought into the buffer, you can
stop doing `M-y' commands and it will stay there.  It's just a copy of
the kill ring entry, so editing it in the buffer does not change what's
in the ring.  As long as no new killing is done, the "last yank"
pointer remains at the same place in the kill ring, so repeating `C-y'
will yank another copy of the same previous kill.

   If you know how many `M-y' commands it would take to find the text
you want, you can yank that text in one step using `C-y' with a numeric
argument.  `C-y' with an argument restores the text the specified
number of entries back in the kill ring.  Thus, `C-u 2 C-y' gets the
next to the last block of killed text.  It is equivalent to `C-y M-y'.
`C-y' with a numeric argument starts counting from the "last yank"
pointer, and sets the "last yank" pointer to the entry that it yanks.

   The length of the kill ring is controlled by the variable
`kill-ring-max'; no more than that many blocks of killed text are saved.

   The actual contents of the kill ring are stored in a variable named
`kill-ring'; you can view the entire contents of the kill ring with the
command `C-h v kill-ring'.


File: emacs,  Node: Accumulating Text,  Next: Rectangles,  Prev: Yanking,  Up: Top

Accumulating Text
=================

   Usually we copy or move text by killing it and yanking it, but there
are other methods convenient for copying one block of text in many
places, or for copying many scattered blocks of text into one place.  To
copy one block to many places, store it in a register (*note
Registers::.).  Here we describe the commands to accumulate scattered
pieces of text into a buffer or into a file.

`M-x append-to-buffer'
     Append region to contents of specified buffer.

`M-x prepend-to-buffer'
     Prepend region to contents of specified buffer.

`M-x copy-to-buffer'
     Copy region into specified buffer, deleting that buffer's old
     contents.

`M-x insert-buffer'
     Insert contents of specified buffer into current buffer at point.

`M-x append-to-file'
     Append region to contents of specified file, at the end.

   To accumulate text into a buffer, use `M-x append-to-buffer'.  This
reads a buffer name, them inserts a copy of the region into the buffer
specified.  If you specify a nonexistent buffer, `append-to-buffer'
creates the buffer.  The text is inserted wherever point is in that
buffer.  If you have been using the buffer for editing, the copied text
goes into the middle of the text of the buffer, wherever point happens
to be in it.

   Point in that buffer is left at the end of the copied text, so
successive uses of `append-to-buffer' accumulate the text in the
specified buffer in the same order as they were copied.  Strictly
speaking, `append-to-buffer' does not always append to the text already
in the buffer--only if point in that buffer is at the end.  However, if
`append-to-buffer' is the only command you use to alter a buffer, then
point is always at the end.

   `M-x prepend-to-buffer' is just like `append-to-buffer' except that
point in the other buffer is left before the copied text, so successive
prependings add text in reverse order.  `M-x copy-to-buffer' is similar
except that any existing text in the other buffer is deleted, so the
buffer is left containing just the text newly copied into it.

   To retrieve the accumulated text from another buffer, use `M-x
insert-buffer'; this too takes BUFFERNAME as an argument.  It inserts a
copy of the text in buffer BUFFERNAME into the selected buffer.  You
can alternatively select the other buffer for editing, then optionally
move text from it by killing.  *Note Buffers::, for background
information on buffers.

   Instead of accumulating text within Emacs, in a buffer, you can
append text directly into a file with `M-x append-to-file', which takes
FILENAME as an argument.  It adds the text of the region to the end of
the specified file.  The file is changed immediately on disk.

   You should use `append-to-file' only with files that are *not* being
visited in Emacs.  Using it on a file that you are editing in Emacs
would change the file behind Emacs's back, which can lead to losing
some of your editing.


File: emacs,  Node: Rectangles,  Next: Registers,  Prev: Accumulating Text,  Up: Top

Rectangles
==========

   The rectangle commands operate on rectangular areas of the text: all
the characters between a certain pair of columns, in a certain range of
lines. Commands are provided to kill rectangles, yank killed rectangles,
clear them out, fill them with blanks or text, or delete them. Rectangle
commands are useful with text in multicolumn formats, and for changing
text into or out of such formats.

   When you must specify a rectangle for a command to work on, you do it
by putting the mark at one corner and point at the opposite corner.  The
rectangle thus specified is called the "region-rectangle" because you
control it in about the same way the region is controlled.  But
remember that a given combination of point and mark values can be
interpreted either as a region or as a rectangle, depending on the
command that uses them.

   If point and the mark are in the same column, the rectangle they
delimit is empty.  If they are in the same line, the rectangle is one
line high.  This asymmetry between lines and columns comes about
because point (and likewise the mark) is between two columns, but within
a line.

`C-x r k'
     Kill the text of the region-rectangle, saving its contents as the
     "last killed rectangle" (`kill-rectangle').

`C-x r d'
     Delete the text of the region-rectangle (`delete-rectangle').

`C-x r y'
     Yank the last killed rectangle with its upper left corner at point
     (`yank-rectangle').

`C-x r o'
     Insert blank space to fill the space of the region-rectangle
     (`open-rectangle').  This pushes the previous contents of the
     region-rectangle rightward.

`M-x clear-rectangle'
     Clear the region-rectangle by replacing its contents with spaces.

`M-x string-rectangle RET STRING RET'
     Insert STRING on each line of the region-rectangle.

   The rectangle operations fall into two classes: commands deleting and
inserting rectangles, and commands for blank rectangles.

   There are two ways to get rid of the text in a rectangle: you can
discard the text (delete it) or save it as the "last killed" rectangle.
The commands for these two ways are `C-x r d' (`delete-rectangle') and
`C-x r k' (`kill-rectangle').  In either case, the portion of each line
that falls inside the rectangle's boundaries is deleted, causing
following text (if any) on the line to move left into the gap.

   Note that "killing" a rectangle is not killing in the usual sense;
the rectangle is not stored in the kill ring, but in a special place
that can only record the most recent rectangle killed.  This is because
yanking a rectangle is so different from yanking linear text that
different yank commands have to be used and yank-popping is hard to
make sense of.

   To yank the last killed rectangle, type `C-x r y'
(`yank-rectangle').  Yanking a rectangle is the opposite of killing
one.  Point specifies where to put the rectangle's upper left corner.
The rectangle's first line is inserted there, the rectangle's second
line is inserted at a position one line vertically down, and so on.  The
number of lines affected is determined by the height of the saved
rectangle.

   You can convert single-column lists into double-column lists using
rectangle killing and yanking; kill the second half of the list as a
rectangle and then yank it beside the first line of the list.  *Note
Two-Column::, for another way to edit multi-column text.

   You can also copy rectangles into and out of registers with `C-x r r
R' and `C-x r i R'.  *Note Rectangle Registers: RegRect.

   There are two commands for making with blank rectangles: `M-x
clear-rectangle' to blank out existing text, and `C-x r o'
(`open-rectangle') to insert a blank rectangle.  Clearing a rectangle
is equivalent to deleting it and then inserting a blank rectangle of
the same size.

   The command `M-x string-rectangle' is similar to `C-x r o', but it
inserts a specified string instead of blanks.  You specify the string
with the minibuffer.  Since the length of the string specifies how many
columns to insert, the width of the region-rectangle does not matter
for this command.  What does matter is the position of the left edge
(which specifies the column position for the insertion in each line)
and the range of lines that the rectangle occupies.  The previous
contents of the text beyond the insertion column are pushed rightward.


File: emacs,  Node: Registers,  Next: Display,  Prev: Rectangles,  Up: Top

Registers
*********

   Emacs "registers" are places you can save text or positions for
later use.  Once you save text or a rectangle in a register, you can
copy it into the buffer once or many times; you can move point to a
position saved in a register once or many times.

   Each register has a name which is a single character.  A register can
store a piece of text, a rectangle, a position, a window configuration,
or a file name, but only one thing at any given time.  Whatever you
store in a register remains there until you store something else in that
register.  To see what a register R contains, use `M-x view-register'.

`M-x view-register RET R'
     Display a description of what register R contains.

* Menu:

* Position: RegPos.           Saving positions in registers.
* Text: RegText.              Saving text in registers.
* Rectangle: RegRect.         Saving rectangles in registers.
* Configurations: RegConfig.  Saving window configurations in registers.
* Files: RegFiles.            File names in registers.
* Bookmarks::                 Bookmarks are like registers, but persistent.


File: emacs,  Node: RegPos,  Next: RegText,  Up: Registers

Saving Positions in Registers
=============================

   Saving a position records a place in a buffer so that you can move
back there later.  Moving to a saved position switches to that buffer
and moves point to that place in it.

`C-x r SPC R'
     Save position of point in register R (`point-to-register').

`C-x r j R'
     Jump to the position saved in register R (`jump-to-register').

   To save the current position of point in a register, choose a name R
and type `C-x r SPC R'.  The register R retains the position thus saved
until you store something else in that register.

   The command `C-x r j R' moves point to the position recorded in
register R.  The register is not affected; it continues to record the
same position.  You can jump to the saved position any number of times.


File: emacs,  Node: RegText,  Next: RegRect,  Prev: RegPos,  Up: Registers

Saving Text in Registers
========================

   When you want to insert a copy of the same piece of text several
times, it may be inconvenient to yank it from the kill ring, since each
subsequent kill moves that entry further down the ring.  An alternative
is to store the text in a register and later retrieve it.

`C-x r s R'
     Copy region into register R (`copy-to-register').

`C-x r i R'
     Insert text from register R (`insert-register').

   `C-x r s R' stores a copy of the text of the region into the
register named R.  Given a numeric argument, `C-x r s R' deletes the
text from the buffer as well.

   `C-x r i R' inserts in the buffer the text from register R.
Normally it leaves point before the text and places the mark after, but
with a numeric argument (`C-u') it puts point after the text and the
mark before.


File: emacs,  Node: RegRect,  Next: RegConfig,  Prev: RegText,  Up: Registers

Saving Rectangles in Registers
==============================

   A register can contain a rectangle instead of linear text.  The
rectangle is represented as a list of strings.  *Note Rectangles::, for
basic information on how to specify a rectangle in the buffer.

`C-x r r R'
     Copy the region-rectangle into register R
     (`copy-region-to-rectangle').  With numeric argument, delete it as
     well.

`C-x r i R'
     Insert the rectangle stored in register R (if it contains a
     rectangle) (`insert-register').

   The `C-x r i R' command inserts a text string if the register
contains one, and inserts a rectangle if the register contains one.

   See also the command `sort-columns', which you can think of as
sorting a rectangle.  *Note Sorting::.


File: emacs,  Node: RegConfig,  Next: RegFiles,  Prev: RegRect,  Up: Registers

Saving Window Configurations in Registers
=========================================

   You can save the window configuration of the selected frame in a
register, or even the configuration of all windows in all frames, and
restore the configuration later.

`C-x r w R'
     Save the state of the selected frame's windows in register R
     (`window-configuration-to-register').

`C-x r f R'
     Save the state of all frames, including all their windows, in
     register R (`frame-configuration-to-register').

   Use `C-x r j R' to restore a window or frame configuration.  This is
the same command used to restore a cursor position.  When you restore a
frame configuration, any existing frames not included in the
configuration become invisible.  If you wish to delete these frames
instead, use `C-u C-x r j R'.


File: emacs,  Node: RegFiles,  Next: Bookmarks,  Prev: RegConfig,  Up: Registers

Keeping File Names in Registers
===============================

   If you visit certain file names frequently, you can visit them more
conveniently if you put their names in registers.  Here's the Lisp code
used to put a file name in a register:

     (set-register ?R '(file . NAME))

For example,

     (set-register ?z '(file . "/gd/gnu/emacs/19.0/src/ChangeLog"))

puts the file name shown in register `z'.

   To visit the file whose name is in register R, type `C-x r j R'.
(This is the same command used to jump to a position or restore a frame
configuration.)


File: emacs,  Node: Bookmarks,  Prev: RegFiles,  Up: Registers

Bookmarks
=========

   "Bookmarks" are somewhat like registers in that they record
positions you can jump to.  Unlike registers, they have long names, and
they persist automatically from one Emacs session to the next.  The
prototypical use of bookmarks is to record "where you were reading" in
various files.

`C-x r m RET'
     Set the bookmark for the visited file, at point.

`C-x r m BOOKMARK RET'
     Set the bookmark named BOOKMARK at point (`bookmark-set').

`C-x r b BOOKMARK RET'
     Jump to the bookmark named BOOKMARK (`bookmark-jump').

`C-x r l'
     List all bookmarks (`list-bookmarks').

`M-x bookmark-save'
     Save all the current bookmark values in the default bookmark file.

   The prototypical use for bookmarks is to record one current position
in each of several files.  So the command `C-x r m', which sets a
bookmark, uses the visited file name as the default for the bookmark
name.  If you name each bookmark after the file it points to, then you
can conveniently revisit any of those files with `C-x r b', and move to
the position of the bookmark at the same time.

   To display a list of all your bookmarks in a separate buffer, type
`C-x r l' (`list-bookmarks').  If you switch to that buffer, you can
use it to edit your bookmark definitions.  Type `C-h m' in that buffer
for more information about its special editing commands.

   When you kill Emacs, Emacs offers to save your bookmark values in
your default bookmark file, `~/.emacs-bkmrks', if you have changed any
bookmark values.  You can also save the bookmarks at any time with the
`M-x bookmark-save' command.  The bookmark commands load your default
bookmark file automatically.  This saving and loading is how bookmarks
persist from one Emacs session to the next.

   If you set the variable `bookmark-save-flag' to 1, then each command
that sets a bookmark will also save your bookmarks; this way, you don't
lose any bookmark values even if Emacs crashes.  (The value, if a
number, says how many bookmark modifications should go by between
saving.)

   Bookmark position values are saved with surrounding context, so that
`bookmark-jump' can find the proper position even if the file is
modified slightly.  The variable `bookmark-search-size' says how many
characters of context to record, on each side of the bookmark's
position.

   Here are some additional commands for working with bookmarks:

`M-x bookmark-load RET FILENAME RET'
     Load a file named FILENAME that contains a list of bookmark
     values.  You can use this command, as well as `bookmark-write', to
     work with other files of bookmark values in addition to your
     default bookmark file.

`M-x bookmark-write RET FILENAME RET'
     Save all the current bookmark values in the file FILENAME.

`M-x bookmark-delete RET BOOKMARK RET'
     Delete the bookmark named BOOKMARK.

`M-x bookmark-locate RET BOOKMARK RET'
     Insert in the buffer the name of the file that bookmark BOOKMARK
     points to.

`M-x bookmark-insert RET BOOKMARK RET'
     Insert in the buffer the *contents* of the file that bookmark
     BOOKMARK points to.


File: emacs,  Node: Display,  Next: Search,  Prev: Registers,  Up: Top

Controlling the Display
***********************

   Since only part of a large buffer fits in the window, Emacs tries to
show the part that is likely to be interesting.  The display control
commands allow you to specify which part of the text you want to see.

`C-l'
     Clear screen and redisplay, scrolling the selected window to center
     point vertically within it (`recenter').

`C-v'
     Scroll forward (a windowful or a specified number of lines)
     (`scroll-up').

`NEXT'
     Likewise, scroll forward.

`M-v'
     Scroll backward (`scroll-down').

`PRIOR'
     Likewise, scroll backward.

`ARG C-l'
     Scroll so point is on screen line ARG (`recenter').

`C-x <'
     Scroll text in current window to the left (`scroll-left').

`C-x >'
     Scroll to the right (`scroll-right').

`C-x $'
     Make deeply indented lines invisible (`set-selective-display').

   The names of all scroll commands are based on the direction that the
text moves in the window.  Thus, the command to scrolling forward is
called `scroll-up', since the text moves up.

* Menu:

* Scrolling::	           Moving text up and down in a window.
* Horizontal Scrolling::   Moving text left and right in a window.
* Selective Display::      Hiding lines with lots of indentation.
* European Display::	   Displaying (and entering) European characters.
* Optional Mode Line::     Optional mode line display features.
* Display Vars::           Information on variables for customizing display.


File: emacs,  Node: Scrolling,  Next: Horizontal Scrolling,  Up: Display

Scrolling
=========

   If a buffer contains text that is too large to fit entirely within a
window that is displaying the buffer, Emacs shows a contiguous portion
of the text.  The portion shown always contains point.

   "Scrolling" means moving text up or down in the window so that
different parts of the text are visible.  Scrolling forward means that
text moves up, and new text appears at the bottom.  Scrolling backward
moves text down and new text appears at the top.

   Scrolling happens automatically if you move point past the bottom or
top of the window.  You can also explicitly request scrolling with the
commands in this section.

`C-l'
     Clear screen and redisplay, scrolling the selected window to center
     point vertically within it (`recenter').

`C-v'
     Scroll forward (a windowful or a specified number of lines)
     (`scroll-up').

`NEXT'
     Likewise, scroll forward.

`M-v'
     Scroll backward (`scroll-down').

`PRIOR'
     Likewise, scroll backward.

`ARG C-l'
     Scroll so point is on line ARG (`recenter').

`C-M-l'
     Scroll heuristically to bring useful information onto the screen
     (`reposition-window').

   The most basic scrolling command is `C-l' (`recenter') with no
argument.  It clears the entire screen and redisplays all windows.  In
addition, it scrolls the selected window so that point is halfway down
from the top of the window.

   The scrolling commands `C-v' and `M-v' let you move all the text in
the window up or down a few lines.  `C-v' (`scroll-up') with an
argument shows you that many more lines at the bottom of the window,
moving the text and point up together as `C-l' might.  `C-v' with a
negative argument shows you more lines at the top of the window.  `M-v'
(`scroll-down') is like `C-v', but moves in the opposite direction.
The function keys NEXT and PRIOR are equivalent to `C-v' and `M-v'.

   To read the buffer a windowful at a time, use `C-v' with no argument.
It takes the last two lines at the bottom of the window and puts them at
the top, followed by nearly a whole windowful of lines not previously
visible.  If point was in the text scrolled off the top, it moves to the
new top of the window.  `M-v' with no argument moves backward with
overlap similarly.  The number of lines of overlap across a `C-v' or
`M-v' is controlled by the variable `next-screen-context-lines'; by
default, it is two.

   Another way to do scrolling is with `C-l' with a numeric argument.
`C-l' does not clear the screen when given an argument; it only scrolls
the selected window.  With a positive argument N, it repositions text
to put point N lines down from the top.  An argument of zero puts point
on the very top line.  Point does not move with respect to the text;
rather, the text and point move rigidly on the screen.  `C-l' with a
negative argument puts point that many lines from the bottom of the
window.  For example, `C-u - 1 C-l' puts point on the bottom line, and
`C-u - 5 C-l' puts it five lines from the bottom.  Just `C-u' as
argument, as in `C-u C-l', scrolls point to the center of the screen.

   The `C-M-l' command (`reposition-window') scrolls the current window
heuristically in a way designed to get useful information onto the
screen.  For example, in a Lisp file, this command tries to get the
entire current defun onto the screen if possible.

   Scrolling happens automatically if point has moved out of the visible
portion of the text when it is time to display.  Usually the scrolling
is done so as to put point vertically centered within the window.
However, if the variable `scroll-step' has a nonzero value, an attempt
is made to scroll the buffer by that many lines; if that is enough to
bring point back into visibility, that is what is done.


File: emacs,  Node: Horizontal Scrolling,  Next: Selective Display,  Prev: Scrolling,  Up: Display

Horizontal Scrolling
====================

`C-x <'
     Scroll text in current window to the left (`scroll-left').

`C-x >'
     Scroll to the right (`scroll-right').

   The text in a window can also be scrolled horizontally.  This means
that each line of text is shifted sideways in the window, and one or
more characters at the beginning of each line are not displayed at all.
When a window has been scrolled horizontally in this way, text lines
are truncated rather than continued (*note Continuation Lines::.), with
a `$' appearing in the first column when there is text truncated to the
left, and in the last column when there is text truncated to the right.

   The command `C-x <' (`scroll-left') scrolls the selected window to
the left by N columns with argument N.  This moves part of the
beginning of each line off the left edge of the window.  With no
argument, it scrolls by almost the full width of the window (two
columns less, to be precise).

   `C-x >' (`scroll-right') scrolls similarly to the right.  The window
cannot be scrolled any farther to the right once it is displayed
normally (with each line starting at the window's left margin);
attempting to do so has no effect.  This means that you don't have to
calculate the argument precisely for `C-x >'; any sufficiently large
argument will restore normally display.


File: emacs,  Node: Selective Display,  Next: European Display,  Prev: Horizontal Scrolling,  Up: Display

Selective Display
=================

   Emacs has the ability to hide lines indented more than a certain
number of columns (you specify how many columns).  You can use this to
get an overview of a part of a program.

   To hide lines, type `C-x $' (`set-selective-display') with a numeric
argument N.  Then lines with at least N columns of indentation
disappear from the screen.  The only indication of their presence is
that three dots (`...') appear at the end of each visible line that is
followed by one or more invisible ones.

   The commands `C-n' and `C-p' move across the invisible lines as if
they were not there.

   The invisible lines are still present in the buffer, and most editing
commands see them as usual, so you may find point in the middle of
invisible text.  When this happens, the cursor appears at the end of the
previous line, after the three dots.  If point is at the end of the
visible line, before the newline that ends it, the cursor appears before
the three dots.

   To make all lines visible again, type `C-x $' with no argument.


File: emacs,  Node: European Display,  Next: Optional Mode Line,  Prev: Selective Display,  Up: Display

European Character Set Display
==============================

   Some European languages use accented letters and other special
symbols.  The ISO 8859 Latin-1 character set defines character codes for
many European languages in the range 160 to 255.

   Emacs can display those characters according to Latin-1, provided the
terminal or font in use supports them.  The `M-x
standard-display-european' command toggles European character display
mode.  With a numeric argument, `M-x standard-display-european' enables
European character display if and only if the argument is positive.

   Some operating systems let you specify the language you are using by
setting a locale.  Emacs handles one common special case of this: if
your locale name for character types contains the string `8859-1' or
`88591', Emacs automatically enables European character display mode
when it starts up.

   Load the library `iso-syntax' to specify the correct syntactic
properties and case conversion table for the Latin-1 character set.

   If your keyboard can send character codes 128 and up to represent
ISO Latin-1 characters, execute the following expression to enable
Emacs to understand them:

     (set-input-mode (car (current-input-mode))
                     (nth 1 (current-input-mode))
                     0)

Otherwise, you can load the library `iso-transl' to turn the key `C-x
8' into a "compose character" prefix for entry of the extra ISO Latin-1
printing characters.  `C-x 8' is good for insertion (in the minibuffer
as well as other buffers), for searching, and in any other context
where a key sequence is allowed.  The ALT modifier key, if you have
one, serves the same purpose as `C-x 8'; use ALT together with an
accent character to modify the following letter.

   If you enter non-ASCII ISO Latin-1 characters often, you might find
ISO Accents mode convenient.  When this minor mode is enabled, the
characters ``', `'', `"', `^', `/' and `~' modify the following letter
by adding the corresponding diacritical mark to it, if possible.  To
enable or disable ISO Accents mode, use the command `M-x
iso-accents-mode'.  This command affects only the current buffer.

   To enter one of those six special characters, type the character,
followed by a space.  Some of those characters have a corresponding
"dead key" accent character in the ISO Latin-1 character set; to enter
that character, type the corresponding ASCII character twice.  For
example, `''' enters the Latin-1 character acute-accent (character code
0264).

   In addition to the accented letters, you can use these special
sequences in ISO Accents mode to enter certain other ISO Latin-1
characters:

`/A'
     `A' with ring.

`~C'
     `C' with cedilla.

`~D'
     `D' with stroke.

`/E'
     `AE' ligature.

`/a'
     `a' with ring.

`~c'
     `c' with cedilla.

`~d'
     `d' with stroke.

`/e'
     `ae' ligature.

`"s'
     German sharp `s'.

`~<'
     Left guillemet.

`~>'
     Right guillemet.

   This feature is available whenever a key sequence is expected: for
ordinary insertion, for searching, and for certain command arguments.


File: emacs,  Node: Optional Mode Line,  Next: Display Vars,  Prev: European Display,  Up: Display

Optional Mode Line Features
===========================

   To add the current line number of point to the mode line, enable Line
Number mode with the command `M-x line-number-mode'.  The line number
appears before the buffer percentage POS, with the letter `L' to
indicate what it is.  *Note Minor Modes::, for more information about
minor modes and about how to use this command.

   If the buffer is very large (larger than the value of
`line-number-display-limit'), then the line number doesn't appear.
Emacs doesn't compute the line number when the buffer is large, because
that would be too slow.

   Emacs can optionally display the time and system load in all mode
lines.  To enable this feature, type `M-x display-time'.  The
information added to the mode line usually appears after the buffer
name, before the mode names and their parentheses.  It looks like this:

     HH:MMpm L.LL

Here HH and MM are the hour and minute, followed always by `am' or
`pm'.  L.LL is the average number of running processes in the whole
system recently.  (Some fields may be missing if your operating system
cannot support them.)

   The word `Mail' appears after the load level if there is mail for
you that you have not read yet.

