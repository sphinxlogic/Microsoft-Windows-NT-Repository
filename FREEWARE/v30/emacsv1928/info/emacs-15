This is Info file ../info/emacs, produced by Makeinfo-1.54 from the
input file emacs.texi.


File: emacs,  Node: Mayan Calendar,  Prev: From Other Calendar,  Up: Other Calendars

Converting from the Mayan Calendar
----------------------------------

   Here are the commands to select dates based on the Mayan calendar:

`g m l'
     Move to a date specified by the long count calendar
     (`calendar-goto-mayan-long-count-date').

`g m n t'
     Move to the next occurrence of a place in the tzolkin calendar
     (`calendar-next-tzolkin-date').

`g m p t'
     Move to the previous occurrence of a place in the tzolkin calendar
     (`calendar-previous-tzolkin-date').

`g m n h'
     Move to the next occurrence of a place in the haab calendar
     (`calendar-next-haab-date').

`g m p h'
     Move to the previous occurrence of a place in the haab calendar
     (`calendar-previous-haab-date').

`g m n c'
     Move to the next occurrence of a place in the calendar round
     (`calendar-next-calendar-round-date').

`g m p c'
     Move to the previous occurrence of a place in the calendar round
     (`calendar-previous-calendar-round-date').

   To understand these commands, you need to understand the Mayan
calendars.  The "long count" is a counting of days with these units:

     1 kin = 1 day   1 uinal = 20 kin   1 tun = 18 uinal
     1 katun = 20 tun   1 baktun = 20 katun

Thus, the long count date 12.16.11.16.6 means 12 baktun, 16 katun, 11
tun, 16 uinal, and 6 kin.  The Emacs calendar can handle Mayan long
count dates as early as 7.17.18.13.1, but no earlier.  When you use the
`g m l' command, type the Mayan long count date with the baktun, katun,
tun, uinal, and kin separated by periods.

   The Mayan tzolkin calendar is a cycle of 260 days formed by a pair of
independent cycles of 13 and 20 days.  Since this cycle repeats
endlessly, Emacs provides commands to move backward and forward to the
previous or next point in the cycle.  Type `g m p t' to go to the
previous tzolkin date; Emacs asks you for a tzolkin date and moves point
to the previous occurrence of that date.  Similarly, type `g m n t' to
go to the next occurrence of a tzolkin date.

   The Mayan haab calendar is a cycle of 365 days arranged as 18 months
of 20 days each, followed a 5-day monthless period.  Like the tzolkin
cycle, this cycle repeats endlessly, and there are commands to move
backward and forward to the previous or next point in the cycle.  Type
`g m p h' to go to the previous haab date; Emacs asks you for a haab
date and moves point to the previous occurrence of that date.
Similarly, type `g m n h' to go to the next occurrence of a haab date.

   The Maya also used the combination of the tzolkin date and the haab
date.  This combination is a cycle of about 52 years called a *calendar
round*.  If you type `g m p c', Emacs asks you for both a haab and a
tzolkin date and then moves point to the previous occurrence of that
combination.  Use `g m p c' to move point to the next occurrence of a
combination.  These commands signal an error if the haab/tzolkin date
combination you have typed is impossible.

   Emacs uses strict completion (*note Strict Completion::.) whenever it
asks you to type a Mayan name, so you don't have to worry about
spelling.


File: emacs,  Node: Diary,  Next: Appointments,  Prev: Other Calendars,  Up: Calendar/Diary

The Diary
=========

   The Emacs diary keeps track of appointments or other events on a
daily basis, in conjunction with the calendar.  To use the diary
feature, you must first create a "diary file" containing a list of
events and their dates.  Then Emacs can automatically pick out and
display the events for today, for the immediate future, or for any
specified date.

   By default, Emacs uses `~/diary' as the diary file.  This is the
same file that the `calendar' utility uses.  A sample `~/diary' file is:

     12/22/1988  Twentieth wedding anniversary!!
     &1/1.       Happy New Year!
     10/22       Ruth's birthday.
     * 21, *:    Payday
     Tuesday--weekly meeting with grad students at 10am
              Supowit, Shen, Bitner, and Kapoor to attend.
     1/13/89     Friday the thirteenth!!
     &thu 4pm    squash game with Lloyd.
     mar 16      Dad's birthday
     April 15, 1989 Income tax due.
     &* 15       time cards due.

This example uses extra spaces to align the event descriptions of most
of the entries.  Such formatting is purely a matter of taste.

   Although you probably will start by creating a diary manually, Emacs
provides a number of commands to let you view, add, and change diary
entries.

* Menu:

* Diary Commands::         Viewing diary entries and associated calendar dates.
* Format of Diary File::   Entering events in your diary.
* Date Formats::	   Various ways you can specify dates.
* Adding to Diary::	   Commands to create diary entries.
* Special Diary Entries::  Anniversaries, blocks of dates, cyclic entries, etc.


File: emacs,  Node: Diary Commands,  Next: Format of Diary File,  Up: Diary

Commands Displaying Diary Entries
---------------------------------

   Once you have created a `~/diary' file, you can use the calendar to
view it.  You can also view today's events outside of Calendar mode.

`d'
     Display all diary entries for the selected date
     (`view-diary-entries').

`Mouse-2 Diary'
     Display all diary entries for the date you click on.

`s'
     Display the entire diary file (`show-all-diary-entries').

`m'
     Mark all visible dates that have diary entries
     (`mark-diary-entries').

`u'
     Unmark the calendar window (`calendar-unmark').

`M-x print-diary-entries'
     Print hard copy of the diary display as it appears.

`M-x diary'
     Display all diary entries for today's date.

   Displaying the diary entries with `d' shows in a separate window the
diary entries for the selected date in the calendar.  The mode line of
the new window shows the date of the diary entries and any holidays
that fall on that date.  If you specify a numeric argument with `d', it
shows all the diary entries for that many successive days.  Thus, `2 d'
displays all the entries for the selected date and for the following
day.

   Another way to display the diary entries for a date is to click
`Mouse-2' on the date, and then choose `Diary' from the menu that
appears.

   To get a broader view of which days are mentioned in the diary, use
the `m' command.  This displays the dates that have diary entries fall
in a different face (or places a `+' after these dates, if display with
multiple faces is not available).  The command applies both to the
currently visible months and to other months that subsequently become
visible by scrolling.  To turn marking off and erase the current marks,
type `u', which also turns off holiday marks (*note Holidays::.).

   To see the full diary file, rather than just some of the entries, use
the `s' command.

   Display of selected diary entries uses the selective display feature
to hide entries that don't apply.  This is the same feature that Outline
mode uses to show part of an outline (*note Outline Mode::.).

   The diary buffer as you see it is an illusion, so simply printing the
buffer does not print what you see on your screen.  There is a special
command to print hard copy of the diary buffer *as it appears*; this
command is `M-x print-diary-entries'.  It sends the data directly to
the printer.  You can customize it like `lpr-region' (*note
Hardcopy::.).

   The command `M-x diary' displays the diary entries for the current
date, independently of the calendar display, and optionally for the next
few days as well; the variable `number-of-diary-entries' specifies how
many days to include.  *Note Calendar/Diary Options:
(elisp)Calendar/Diary Options.

   If you put `(diary)' in your `.emacs' file, this automatically
displays a window with the day's diary entries, when you enter Emacs.
The mode line of the displayed window shows the date and any holidays
that fall on that date.


File: emacs,  Node: Format of Diary File,  Next: Date Formats,  Prev: Diary Commands,  Up: Diary

The Diary File
--------------

   Your "diary file" is a file that records events associated with
particular dates.  The name of the diary file is specified by the
variable `diary-file'; `~/diary' is the default.  The `calendar'
utility program supports a subset of the format allowed by the Emacs
diary facilities, so you can use that utility to view the diary file,
with reasonable results aside from the entries it cannot understand.

   Each entry in the diary file describes one event and consists of one
or more lines.  An entry always begins with a date specification at the
left margin.  The rest of the entry is simply text to describe the
event.  If the entry has more than one line, then the lines after the
first must begin with whitespace to indicate they continue a previous
entry.  Lines that do not begin with valid dates and do not continue a
preceding entry are ignored.

   You can inhibit the marking of certain diary entries in the calendar
window; to do this, insert an ampersand (`&') at the beginning of the
entry, before the date.  This has no effect on display of the entry in
the diary window; it affects only marks on dates in the calendar
window.  Nonmarking entries are especially useful for generic entries
that would otherwise mark many different dates.

   If the first line of a diary entry consists only of the date or day
name with no following blanks or punctuation, then the diary window
display doesn't include that line; only the continuation lines appear.
For example, this entry:

     02/11/1989
           Bill B. visits Princeton today
           2pm Cognitive Studies Committee meeting
           2:30-5:30 Liz at Lawrenceville
           4:00pm Dentist appt
           7:30pm Dinner at George's
           8:00-10:00pm concert

appears in the diary window without the date line at the beginning.
This style of entry looks neater when you display just a single day's
entries, but can cause confusion if you ask for more than one day's
entries.

   You can edit the diary entries as they appear in the window, but it
is important to remember that the buffer displayed contains the *entire*
diary file, with portions of it concealed from view.  This means, for
instance, that the `C-f' (`forward-char') command can put point at what
appears to be the end of the line, but what is in reality the middle of
some concealed line.

   *Be careful when editing the diary entries!*  Inserting additional
lines or adding/deleting characters in the middle of a visible line
cannot cause problems, but editing at the end of a line may not do what
you expect.  Deleting a line may delete other invisible entries that
follow it.  Before editing the diary, it is best to display the entire
file with `s' (`show-all-diary-entries').


File: emacs,  Node: Date Formats,  Next: Adding to Diary,  Prev: Format of Diary File,  Up: Diary

Date Formats
------------

   Here are some sample diary entries, illustrating different ways of
formatting a date.  The examples all show dates in American order
(month, day, year), but Calendar mode supports European order (day,
month, year) as an option.

     4/20/93  Switch-over to new tabulation system
     apr. 25  Start tabulating annual results
     4/30  Results for April are due
     */25  Monthly cycle finishes
     Friday  Don't leave without backing up files

   The first entry appears only once, on April 20, 1993.  The second and
third appear every year on the specified dates, and the fourth uses a
wildcard (asterisk) for the month, so it appears on the 25th of every
month.  The final entry appears every week on Friday.

   You can use just numbers to express a date, as in `MONTH/DAY' or
`MONTH/DAY/YEAR'.  This must be followed by a nondigit.  In the date
itself, MONTH and DAY are numbers of one or two digits.  The optional
YEAR is also a number, and may be abbreviated to the last two digits;
that is, you can use `11/12/1989' or `11/12/89'.

   Dates can also have the form `MONTHNAME DAY' or `MONTHNAME DAY,
YEAR', where the month's name can be spelled in full or abbreviated to
three characters (with or without a period).  Case is not significant.

   A date may be "generic"; that is, partially unspecified.  Then the
entry applies to all dates that match the specification.  If the date
does not contain a year, it is generic and applies to any year.
Alternatively, MONTH, DAY, or YEAR can be a `*'; this matches any
month, day, or year, respectively.  Thus, a diary entry `3/*/*' matches
any day in March of any year; so does `march *'.

   If you prefer the European style of writing dates--in which the day
comes before the month--type `M-x european-calendar' while in the
calendar, or set the variable `european-calendar-style' to `t' *before*
using any calendar or diary command.  This mode interprets all dates in
the diary in the European manner, and also uses European style for
displaying diary dates.  (Note that there is no comma after the
MONTHNAME in the European style.)  To go back to the (default) American
style of writing dates, type `M-x american-calendar'.

   You can use the name of a day of the week as a generic date which
applies to any date falling on that day of the week.  You can abbreviate
the day of the week to three letters (with or without a period) or spell
it in full; case is not significant.


File: emacs,  Node: Adding to Diary,  Next: Special Diary Entries,  Prev: Date Formats,  Up: Diary

Commands to Add to the Diary
----------------------------

   While in the calendar, there are several commands to create diary
entries:

`i d'
     Add a diary entry for the selected date (`insert-diary-entry').

`i w'
     Add a diary entry for the selected day of the week
     (`insert-weekly-diary-entry').

`i m'
     Add a diary entry for the selected day of the month
     (`insert-monthly-diary-entry').

`i y'
     Add a diary entry for the selected day of the year
     (`insert-yearly-diary-entry').

   You can make a diary entry for a specific date by selecting that date
in the calendar window and typing the `i d' command.  This command
displays the end of your diary file in another window and inserts the
date; you can then type the rest of the diary entry.

   If you want to make a diary entry that applies to a specific day of
the week, select that day of the week (any occurrence will do) and type
`i w'.  This inserts the day-of-week as a generic date; you can then
type the rest of the diary entry.  You can make a monthly diary entry in
the same fashion.  Select the day of the month, use the `i m' command,
and type rest of the entry.  Similarly, you can insert a yearly diary
entry with the `i y' command.

   All of the above commands make marking diary entries by default.  To
make a nonmarking diary entry, give a numeric argument to the command.
For example, `C-u i w' makes a nonmarking weekly diary entry.

   When you modify the diary file, be sure to save the file before
exiting Emacs.


File: emacs,  Node: Special Diary Entries,  Prev: Adding to Diary,  Up: Diary

Special Diary Entries
---------------------

   In addition to entries based on calendar dates, the diary file can
contain "special entries" for regular events such as anniversaries.
These entries are based on Lisp expressions (sexps) that Emacs evaluates
as it scans the diary file.  Instead of a date, a special entry contains
`%%' followed by a Lisp expression which must begin and end with
parentheses.  The Lisp expression determines which dates the entry
applies to.

   Calendar mode provides commands to insert certain commonly used
special entries:

`i a'
     Add an anniversary diary entry for the selected date
     (`insert-anniversary-diary-entry').

`i b'
     Add a block diary entry for the current region
     (`insert-block-diary-entry').

`i c'
     Add a cyclic diary entry starting at the date
     (`insert-cyclic-diary-entry').

   If you want to make a diary entry that applies to the anniversary of
a specific date, move point to that date and use the `i a' command.
This displays the end of your diary file in another window and inserts
the anniversary description; you can then type the rest of the diary
entry.  The entry looks like this:

     %%(diary-anniversary 10 31 1948) Arthur's birthday

This entry applies to October 31 in any year after 1948; `10 31 1948'
specifies the date.  (If you are using the European calendar style, the
month and day are interchanged.)  The reason this expression requires a
beginning year is that advanced diary functions can use it to calculate
the number of elapsed years.

   A "block" diary entry applies to a specified range of consecutive
dates.  Here is a block diary entry that applies to all dates from June
24, 1990 through July 10, 1990:

     %%(diary-block 6 24 1990 7 10 1990) Vacation

The `6 24 1990' indicates the starting date and the `7 10 1990'
indicates the stopping date.  (Again, if you are using the European
calendar style, the month and day are interchanged.)

   To insert a block entry, place point and the mark on the two dates
that begin and end the range, and type `i b'.  This command displays
the end of your diary file in another window and inserts the block
description; you can then type the diary entry.

   "Cyclic" diary entries repeat after a fixed interval of days.  To
create one, select the starting date and use the `i c' command.  The
command prompts for the length of interval, then inserts the entry,
which looks like this:

     %%(diary-cyclic 50 3 1 1990) Renew medication

This entry applies to March 1, 1990 and every 50th day following; `3 1
1990' specifies the starting date.  (If you are using the European
calendar style, the month and day are interchanged.)

   All three of these commands make marking diary entries.  To insert a
nonmarking entry, give a numeric argument to the command.  For example,
`C-u i a' makes a nonmarking anniversary diary entry.

   Marking sexp diary entries in the calendar is *extremely*
time-consuming, since every date visible in the calendar window must be
individually checked.  So it's a good idea to make sexp diary entries
nonmarking (with `&') when possible.

   Another sophisticated kind of sexp entry, a "floating" diary entry,
specifies a regularly-occurring event by offsets specified in days,
weeks, and months.  It is comparable to a crontab entry interpreted by
the `cron' utility.  Here is a nonmarking, floating diary entry that
applies to the last Thursday in November:

     &%%(diary-float 11 4 -1) American Thanksgiving

The 11 specifies November (the eleventh month), the 4 specifies Thursday
(the fourth day of the week, where Sunday is numbered zero), and the -1
specifies "last" (1 would mean "first", 2 would mean "second", -2 would
mean "second-to-last", and so on).  The month can be a single month or
a list of months.  Thus you could change the 11 above to `'(1 2 3)' and
have the entry apply to the last Thursday of January, February, and
March.  If the month is `t', the entry applies to all months of the
year.

   Most generally, special diary entries can perform arbitrary
computations to determine when they apply.  *Note Sexp Diary Entries:
(elisp)Sexp Diary Entries.


File: emacs,  Node: Appointments,  Next: Daylight Savings,  Prev: Diary,  Up: Calendar/Diary

Appointments
============

   If you have a diary entry for an appointment, and that diary entry
begins with a recognizable time of day, Emacs can warn you, several
minutes beforehand, that that appointment is pending.  Emacs alerts you
to the appointment by displaying a message in the mode line.

   To enable appointment notification, you must enable the time display
feature of Emacs, `M-x display-time' (*note Mode Line::.).  You must
also add the function `appt-make-list' to the `diary-hook', like this:

     (add-hook 'diary-hook 'appt-make-list)

   With these preparations done, when you display the diary (either with
the `d' command in the calendar window or with the `M-x diary'
command), it sets up an appointment list of all the diary entries found
with recognizable times of day, and reminds you just before each of
them.

   For example, suppose the diary file contains these lines:

     Monday
       9:30am Coffee break
      12:00pm Lunch

Then on Mondays, after you have displayed the diary, you will be
reminded at 9:20am about your coffee break and at 11:50am about lunch.

   You can write times in conventional American am/pm style, or 24-hour
European/military style.  You need not be consistent; your diary file
can have a mixture of the two styles.

   Emacs updates the appointments list automatically just after
midnight.  This also displays the next day's diary entries in the diary
buffer, unless you set `appt-display-diary' to `nil'.

   You can also use the appointment notification facility like an alarm
clock.  The command `M-x appt-add' adds entries to the appointment list
without affecting your diary file.  You delete entries from the
appointment list with `M-x appt-delete'.

   You can turn off the appointment notification feature at any time by
setting `appt-issue-message' to `nil'.


File: emacs,  Node: Daylight Savings,  Prev: Appointments,  Up: Calendar/Diary

Daylight Savings Time
=====================

   Emacs understands the difference between standard time and daylight
savings time--the times given for sunrise, sunset, solstices,
equinoxes, and the phases of the moon take that into account.  The rules
for daylight savings time vary from place to place and have also varied
historically from year to year.  To do the job properly, Emacs needs to
know which rules to use.

   Some operating systems keep track of the rules that apply to the
place where you are; on these systems, Emacs gets the information it
needs from the system automatically.  If some or all of this
information is missing, Emacs fills in the gaps with the rules
currently used in Cambridge, Massachusetts.  If the resulting rules are
not what you want, you can tell Emacs the rules to use by setting
certain variables.

   These values should be Lisp expressions that refer to the variable
`year', and evaluate to the Gregorian date on which daylight savings
time starts or (respectively) ends, in the form of a list `(MONTH DAY
YEAR)'.  The values should be `nil' if your area does not use daylight
savings time.

   Emacs uses these expressions to determine the starting date of
daylight savings time for the holiday list and for correcting times of
day in the solar and lunar calculations.

   The values for Cambridge, Massachusetts are as follows:

     (calendar-nth-named-day 1 0 4 year)
     (calendar-nth-named-day -1 0 10 year)

That is, the first 0th day (Sunday) of the fourth month (April) in the
year specified by `year', and the last Sunday of the tenth month
(October) of that year.  If daylight savings time were changed to start
on October 1, you would set `calendar-daylight-savings-starts' to this:

     (list 10 1 year)

   If there is no daylight savings time at your location, or if you want
all times in standard time, set `calendar-daylight-savings-starts' and
`calendar-daylight-savings-ends' to `nil'.

   The variable `calendar-daylight-time-offset' specifies the
difference between daylight savings time and standard time, measured in
minutes.  The value for Cambridge, Massachusetts is 60.

   The two variables `calendar-daylight-savings-starts-time' and
`calendar-daylight-savings-ends-time' specify the number of minutes
after midnight local time when the transition to and from daylight
savings time should occur.  For Cambridge, both variables' values are
120.


File: emacs,  Node: GNUS,  Next: Shell,  Prev: Calendar/Diary,  Up: Top

GNUS
====

   GNUS is an Emacs subsystem for reading and responding to netnews.
You can use GNUS to browse through news groups, look at summaries of
articles in specific group, and read articles of interest.  You can
respond to authors or write replies to all the readers of a news group.

   This section introduces GNUS and describes several basic features.
Full documentation will appear elsewhere.

   To start GNUS, type `M-x gnus RET'.

* Menu:

* Buffers of GNUS::	   The Newsgroups, Summary and Article buffers.
* GNUS Startup::	   What you should know about starting GNUS.
* Summary of GNUS::	   A short description of the basic GNUS commands.


File: emacs,  Node: Buffers of GNUS,  Next: GNUS Startup,  Up: GNUS

GNUS's Three Buffers
--------------------

   GNUS creates and uses three Emacs buffers, each with its own
particular purpose and its own major mode.

   The "Newsgroup buffer" contains a list of newsgroups.  This is the
first buffer that GNUS displays when it starts up.  Normally the list
contains only the newsgroups to which you subscribe (which are listed in
your `.newsrc' file) and which contain unread articles.  Use this
buffer to select a specific newsgroup.

   The "Summary buffer" lists the articles in a single newsgroup,
including their subjects, their numbers, and who posted them.  GNUS
creates a Summary buffer for a newsgroup when you select the group in
the Newsgroup buffer.  Use this buffer to select an article.

   The "Article buffer" displays the text of an article.  You rarely
need to select this buffer because you can scroll through it while
remaining in the Summary buffer.


File: emacs,  Node: GNUS Startup,  Next: Summary of GNUS,  Prev: Buffers of GNUS,  Up: GNUS

When GNUS Starts Up
-------------------

   At startup, GNUS reads your `.newsrc' news initialization file and
attempts to communicate with the local news server, which is a
repository of news articles.  The news server need not be the same
computer you are logged in on.

   If you start GNUS and connect to the server, but do not see any
newsgroups listed in the Newsgroup buffer, type `L' to get a listing of
all the newsgroups.  Then type `u' to unsubscribe from the newsgroups
you don't want to read.  (You can move point to a particular group
using `n' and `p' or the usual Emacs commands.)

   When you quit GNUS with `q', it automatically records in your
`.newsrc' initialization file the subscribed or unsubscribed status of
all newsgroups, except for groups you have "killed".  (You do not need
to edit this file yourself, but you may.)  When new newsgroups come
into existence, GNUS subscribes to them automatically; if you don't
want to read them, use `u' to unsubscribe from them.


File: emacs,  Node: Summary of GNUS,  Prev: GNUS Startup,  Up: GNUS

Summary of GNUS Commands
------------------------

   Reading news is a two step process:

  1. Choose a newsgroup in the Newsgroup buffer.

  2. Select articles from the Summary buffer.  Each article selected is
     displayed in the Article buffer in a large window, below the
     Summary buffer in its small window.

   Each GNUS buffer has its own special commands, but commands that do
the similar things have similar key bindings.  Here are commands for the
Newsgroup and Summary buffers:

`z'
     In the Newsgroup buffer, suspend GNUS.  You can return to GNUS
     later by selecting the Newsgroup buffer and typing `g' to get
     newly arrived articles.

`q'
     In the Newsgroup buffer, update your `.newsrc' initialization file
     and quit GNUS.

     In the Summary buffer, exit the current newsgroup and return to the
     Newsgroup buffer.  Thus, typing `q' twice quits GNUS.

`L'
     In the Newsgroup buffer, list all the newsgroups available on your
     news server (except those you have killed).  This may be a long
     list!

`l'
     In the Newsgroup buffer, list only the newsgroups to which you
     subscribe and which contain unread articles.

`u'
     In the Newsgroup buffer, unsubscribe from (or subscribe to) the
     newsgroup listed in the line that point is on.  When you quit GNUS
     by typing `q', GNUS lists in your `.newsrc' file which groups you
     have subscribed to.  The next time you start GNUS, you won't see
     this group initially, because GNUS normally displays only
     subscribed-to groups.

`C-k'
     In the Newsgroup buffer, "kill" the current line's newsgroup--don't
     even list it in `.newsrc' from now on.  This affects future GNUS
     sessions as well as the present session.

     When you quit GNUS by typing `q', GNUS writes information in the
     file `.newsrc' describing all newsgroups except those you have
     "killed."

`SPC'
     In the Newsgroup buffer, select the group on the line under the
     cursor and display the first unread article in that group.

     In the Summary buffer,

        * Select the article on the line under the cursor if none is
          selected.

        * Scroll the text of the selected article (if there is one).

        * Select the next unread article if at the end of the current
          article.

     Thus, you can move through all the articles by repeatedly typing
     SPC.

`DEL'
     In the Newsgroup Buffer, move point to the previous newsgroup
     containing unread articles.

     In the Summary buffer, scroll the text of the article backwards.

`n'
     Move point to the next unread newsgroup, or select the next unread
     article.

`p'
     Move point to the previous unread newsgroup, or select the previous
     unread article.

`C-n'
`C-p'
     Move point to the next or previous item, even if it is marked as
     read.  This does not select the article or newsgroup on that line.

`s'
     In the Summary buffer, do an incremental search of the current
     text in the Article buffer, just as if you switched to the Article
     buffer and typed `C-s'.

`M-s REGEXP RET'
     In the Summary buffer, search forward for articles containing a
     match for REGEXP.

`C-c C-s C-n'
`C-c C-s C-s'
`C-c C-s C-d'
`C-c C-s C-a'
     In the Summary buffer, sort the list of articles by number,
     subject, date, or author.

`C-M-n'
`C-M-p'
     In the Summary buffer, read the next or previous article with the
     same subject as the current article.


File: emacs,  Node: Shell,  Next: Emacs Server,  Prev: GNUS,  Up: Top

Running Shell Commands from Emacs
=================================

   Emacs has commands for passing single command lines to inferior shell
processes; it can also run a shell interactively with input and output
to an Emacs buffer named `*shell*'.

`M-! CMD RET'
     Run the shell command line CMD and display the output
     (`shell-command').

`M-| CMD RET'
     Run the shell command line CMD with region contents as input;
     optionally replace the region with the output
     (`shell-command-on-region').

`M-x shell'
     Run a subshell with input and output through an Emacs buffer.  You
     can then give commands interactively.

* Menu:

* Single Shell::           How to run one shell command and return.
* Interactive Shell::      Permanent shell taking input via Emacs.
* Shell Mode::             Special Emacs commands used with permanent shell.
* History: Shell History.  Repeating previous commands in a shell buffer.
* Options: Shell Options.  Options for customizing Shell mode.
* Remote Host::            Connecting to another computer.


File: emacs,  Node: Single Shell,  Next: Interactive Shell,  Up: Shell

Single Shell Commands
---------------------

   `M-!' (`shell-command') reads a line of text using the minibuffer
executes it as a shell command in a subshell made just for this
command.  Standard input for the command comes from the null device.
If the shell command produces any output, the output goes into an Emacs
buffer named `*Shell Command Output*', which is displayed in another
window but not selected.  A numeric argument, as in `M-1 M-!', directs
this command to insert any output into the current buffer.  In that
case, point is left before the output and the mark is set after the
output.

   If the shell command line ends in `&', it runs asynchronously.

   `M-|' (`shell-command-on-region') is like `M-!' but passes the
contents of the region as the standard input to the shell command,
instead of no input.  If a numeric argument is used, meaning insert the
output in the current buffer, then the old region is deleted first and
the output replaces it as the contents of the region.

   Both `M-!' and `M-|' use `shell-file-name' to specify the shell to
use.  This variable is initialized based on your `SHELL' environment
variable when Emacs is started.  If the file name does not specify a
directory, the directories in the list `exec-path' are searched; this
list is initialized based on the environment variable `PATH' when Emacs
is started.  Your `.emacs' file can override either or both of these
default initializations.

   Both `M-!' and `M-|' wait for the shell command to complete.  To
stop waiting, type `C-g' to quit; that terminates the shell command
with the signal `SIGINT'--the same signal that `C-c' normally generates
in the shell.  Emacs waits until the command actually terminates.  If
the shell command doesn't stop (because it ignores the `SIGINT'
signal), type `C-g' again; this sends the command a `SIGKILL' signal
which is impossible to ignore.


File: emacs,  Node: Interactive Shell,  Next: Shell Mode,  Prev: Single Shell,  Up: Shell

Interactive Inferior Shell
--------------------------

   To run a subshell interactively, putting its typescript in an Emacs
buffer, use `M-x shell'.  This creates (or reuses) a buffer named
`*shell*' and runs a subshell with input coming from and output going
to that buffer.  That is to say, any "terminal output" from the subshell
goes into the buffer, advancing point, and any "terminal input" for the
subshell comes from text in the buffer.  To give input to the subshell,
go to the end of the buffer and type the input, terminated by RET.

   Emacs does not wait for the subshell to do anything.  You can switch
windows or buffers and edit them while the shell is waiting, or while
it is running a command.  Output from the subshell waits until Emacs
has time to process it; this happens whenever Emacs is waiting for
keyboard input or for time to elapse.

   To make multiple subshells, rename the buffer `*shell*' to something
different using `M-x rename-uniquely'.  Then type `M-x shell' again to
create a new buffer `*shell*' with its own subshell.  If you rename
this buffer as well, you can create a third one, and so on.  All the
subshells run independently and in parallel.

   The file name used to load the subshell is the value of the variable
`explicit-shell-file-name', if that is non-`nil'.  Otherwise, the
environment variable `ESHELL' is used, or the environment variable
`SHELL' if there is no `ESHELL'.  If the file name specified is
relative, the directories in the list `exec-path' are searched; this
list is initialized based on the environment variable `PATH' when Emacs
is started.  Your `.emacs' file can override either or both of these
default initializations.

   As soon as the subshell is started, it is sent as input the contents
of the file `~/.emacs_SHELLNAME', if that file exists, where SHELLNAME
is the name of the file that the shell was loaded from.  For example,
if you use bash, the file sent to it is `~/.emacs_bash'.

   `cd', `pushd' and `popd' commands given to the inferior shell are
watched by Emacs so it can keep the `*shell*' buffer's default
directory the same as the shell's working directory.  These commands
are recognized syntactically by examining lines of input that are sent.
If you use aliases for these commands, you can tell Emacs to recognize
them also.  For example, if the value of the variable
`shell-pushd-regexp' matches the beginning of a shell command line,
that line is regarded as a `pushd' command.  Change this variable when
you add aliases for `pushd'.  Likewise, `shell-popd-regexp' and
`shell-cd-regexp' are used to recognize commands with the meaning of
`popd' and `cd'.  These commands are recognized only at the beginning
of a shell command line.

   If Emacs gets an error while trying to handle what it believes is a
`cd', `pushd' or `popd' command, it runs the hook
`shell-set-directory-error-hook' (*note Hooks::.).

   If Emacs does not properly track changes in the current directory of
the subshell, use the command `M-x dirs' to ask the shell what its
current directory is.  This command works for shells that support the
most common command syntax; it may not work for unusual shells.


File: emacs,  Node: Shell Mode,  Next: Shell History,  Prev: Interactive Shell,  Up: Shell

Shell Mode
----------

   Shell buffer use Shell mode, which defines several special keys
attached to the `C-c' prefix.  They are chosen to resemble the usual
editing and job control characters present in shells that are not under
Emacs, except that you must type `C-c' first.  Here is a complete list
of the special key bindings of Shell mode:

`RET'
     At end of buffer send line as input; otherwise, copy current line
     to end of buffer and send it (`comint-send-input').  When a line is
     copied, any text at the beginning of the line that matches the
     variable `shell-prompt-pattern' is left out; this variable's value
     should be a regexp string that matches the prompts that your shell
     uses.

`TAB'
     Complete the command name or file name before point in the shell
     buffer (`comint-dynamic-complete').  TAB also completes history
     references (*note History References::.) and environment variable
     names.

     The variable `shell-completion-fignore' specifies a list of file
     name extensions to ignore in Shell mode completion.  The default
     setting ignores file names ending in `~', `#' or `%'.  Other
     related Comint modes use the variable `comint-completion-fignore'
     instead.

`M-?'
     Display temporarily a list of the possible completions of the file
     name before point in the shell buffer
     (`comint-dynamic-list-filename-completions').

`C-d'
     Either delete a character or send EOF
     (`comint-delchar-or-maybe-eof').  Typed at the end of the shell
     buffer, `C-d' sends EOF to the subshell.  Typed at any other
     position in the buffer, `C-d' deletes a character as usual.

`C-c C-a'
     Move to the beginning of the line, but after the prompt if any
     (`comint-bol').

`C-c C-u'
     Kill all text pending at end of buffer to be sent as input
     (`comint-kill-input').

`C-c C-w'
     Kill a word before point (`backward-kill-word').

`C-c C-c'
     Interrupt the shell or its current subjob if any
     (`comint-interrupt-subjob').

`C-c C-z'
     Stop the shell or its current subjob if any (`comint-stop-subjob').

`C-c C-\'
     Send quit signal to the shell or its current subjob if any
     (`comint-quit-subjob').

`C-c C-o'
     Kill the last batch of output from a shell command
     (`comint-kill-output').  This is useful if a shell command spews
     out lots of output that just gets in the way.

`C-c C-r'
`C-M-l'
     Scroll to display the beginning of the last batch of output at the
     top of the window; also move the cursor there
     (`comint-show-output').

`C-c C-e'
     Scroll to put the end of the buffer at the bottom of the window
     (`comint-show-maximum-output').

`C-c C-f'
     Move forward across one shell command, but not beyond the current
     line (`shell-forward-command').  The variable
     `shell-command-regexp' specifies how to recognize the end of a
     command.

`C-c C-b'
     Move backward across one shell command, but not beyond the current
     line (`shell-backward-command').

`M-x dirs'
     Ask the shell what its current directory is, so that Emacs can
     agree with the shell.

`M-x send-invisible RET TEXT RET'
     Send TEXT as input to the shell, after reading it without echoing.
     This is useful when a shell command runs a program that asks for
     a password.

     Alternatively, you can arrange for Emacs to notice password prompts
     and turn off echoing for them, as follows:

          (add-hook `comint-output-filter-functions
                    `comint-watch-for-password-prompt)

`M-x comint-continue-subjob'
     Continue the shell process.  This is useful if you accidentally
     suspend the shell process.(1)

`M-x shell-strip-ctrl-m'
     Discard all control-m characters from the shell output.

   Shell mode also customizes the paragraph commands so that only shell
prompts start new paragraphs.  Thus, a paragraph consists of an input
command plus the output that follows it in the buffer.

   Shell mode is a derivative of Comint mode, a general purpose mode for
communicating with interactive subprocesses.  Most of the features of
Shell mode actually come from Comint mode, as you can see from the
command names listed above.  The specialization of Shell mode in
particular include the choice of regular expression for detecting
prompts, the directory tracking feature, and a few user commands.

   Other Emacs features that use variants of Comint mode include GUD
(*note Debuggers::.) and `M-x run-lisp' (*note External Lisp::.).

   You can use `M-x comint-run' to execute any program of your choice
in a subprocess using unmodified Comint mode--without the
specializations of Shell mode.

   ---------- Footnotes ----------

   (1)  You should not suspend the shell process.  Suspending a subjob
of the shell is a completely different matter--that is normal practice,
but you must use the shell to continue the subjob; this command won't
do it.


File: emacs,  Node: Shell History,  Next: Shell Options,  Prev: Shell Mode,  Up: Shell

Shell Command History
---------------------

   Shell buffers support three ways of repeating earlier commands.  You
can use the same keys used in the minibuffer; these work much as they do
in the minibuffer, inserting text from prior commands while point
remains always at the end of the buffer.  You can move through the
buffer to previous inputs in their original place, then resubmit them or
copy them to the end.  Or you can use a `!'-style history reference.

* Menu:

* Ring: Shell Ring.             Fetching commands from the history list.
* Copy: Shell History Copying.  Moving to a command and then copying it.
* History References::          Expanding `!'-style history references.


File: emacs,  Node: Shell Ring,  Next: Shell History Copying,  Up: Shell History

Shell History Ring
..................

`M-p'
     Fetch the next earlier old shell command.

`M-n'
     Fetch the next later old shell command.

`M-r REGEXP RET'
`M-s REGEXP RET'
     Search backwards or forwards for old shell commands that match
     REGEXP.

   Shell buffers provide a history of previously entered shell
commands.  To reuse shell commands from the history, use the editing
commands `M-p', `M-n', `M-r' and `M-s'.  These work just like the
minibuffer history commands except that they operate on the text at the
end of the shell buffer, where you would normally insert text to send
to the shell.

   `M-p' fetches an earlier shell command to the end of the shell
buffer.  Successive use of `M-p' fetches successively earlier shell
commands, each replacing any text that was already present as potential
shell input.  `M-n' does likewise except that it finds successively
more recent shell commands from the buffer.

   The history search commands `M-r' and `M-s' read a regular
expression and search through the history for a matching command.  Aside
from the choice of which command to fetch, they work just like `M-p'
and `M-r'.  If you enter an empty regexp, these commands reuse the same
regexp used last time.

   When you find the previous input you want, you can resubmit it by
typing RET, or you can edit it first and then resubmit it if you wish.

   These commands get the text of previous shell commands from a special
history list, not from the shell buffer itself.  Thus, editing the shell
buffer, or even killing large parts of it, does not affect the history
that these commands access.

   Some shells store their command histories in files so that you can
refer to previous commands from previous shell sessions.  Emacs reads
the command history file for your chosen shell, to initialize its own
command history.  The file name is `~/.bash_history' for bash,
`~/.sh_history' for ksh, and `~/.history' for other shells.


File: emacs,  Node: Shell History Copying,  Next: History References,  Prev: Shell Ring,  Up: Shell History

Shell History Copying
.....................

`C-c C-p'
     Move point to the previous prompt (`comint-previous-prompt').

`C-c C-n'
     Move point to the following prompt (`comint-next-prompt').

`C-c RET'
     Copy the input command which point is in, inserting the copy at
     the end of the buffer (`comint-copy-old-input').  This is useful
     if you move point back to a previous command.  After you copy the
     command, you can submit the copy as input with RET.  If you wish,
     you can edit the copy before resubmitting it.

   Moving to a previous input and then copying it with `C-c RET'
produces the same results--the same buffer contents--that you would get
by using `M-p' enough times to fetch that previous input from the
history list.  However, `C-c RET' copies the text from the buffer,
which can be different from what is in the history list if you edit the
input text in the buffer after it has been sent.


File: emacs,  Node: History References,  Prev: Shell History Copying,  Up: Shell History

Shell History References
........................

   Various shells including csh and bash support "history references"
that begin with `!' and `^'.  Shell mode can understands these
constructs and perform the history substitution for you.  If you insert
a history reference and type TAB, this searches the input history for a
matching command, performs substitution if necessary, and places the
result in the buffer in place of the history reference.  For example,
you can fetch the most recent command beginning with `mv' with `! m v
TAB'.  You can edit the command if you wish, and then resubmit the
command to the shell by typing RET.

   History references take effect only following a shell prompt.  The
variable `shell-prompt-pattern' specifies how to recognize a shell
prompt.  Comint modes in general use the variable
`comint-prompt-regexp' to specify how to find a prompt; Shell mode uses
`shell-prompt-pattern' to set up the local value of
`comint-prompt-regexp'.

   Shell mode can optionally expand history references in the buffer
when you send them to the shell.  To request this, set the variable
`comint-input-autoexpand' to `input'.

   You can make SPC perform history expansion by binding SPC to the
command `comint-magic-space'.


File: emacs,  Node: Shell Options,  Next: Remote Host,  Prev: Shell History,  Up: Shell

Shell Mode Options
------------------

   If the variable `comint-scroll-to-bottom-on-input' is non-`nil',
insertion and yank commands scroll the selected window to the bottom
before inserting.

   If `comint-scroll-show-maximum-output' is non-`nil' (which is the
default), then scrolling due to arrival of output tries to place the
last line of text at the bottom line of the window, so as to show as
much useful text as possible.  (This mimics the scrolling behavior of
many terminals.)

   By setting `comint-scroll-to-bottom-on-output', you can opt for
having point jump to the end of the buffer whenever output arrives--no
matter where in the buffer point was before.  If the value is `this',
point jumps in the selected window.  If the value is `all', point jumps
in each window that shows the comint buffer.  If the value is `other',
point jumps in all nonselected windows that show the current buffer.
The default value is `nil', which means point does not jump to the end.

   The variable `comint-input-ignoredups' controls whether successive
identical inputs are stored in the input history.  A non-`nil' value
means to omit an input that is the same as the previous input.  The
default is `nil', which means to store each input even if it is equal
to the previous input.

   Three variables customize file name completion.  The variable
`comint-completion-addsuffix' controls whether completion inserts a
space or a slash to indicate a fully completed file or directory name
(non-`nil' means do insert a space or slash).
`comint-completion-recexact', if non-`nil', directs TAB to choose the
shortest possible completion if the usual Emacs completion algorithm
cannot add even a single character.  `comint-completion-autolist', if
non-`nil', says to list all the possible completions whenever
completion is not exact.

   The command `comint-dynamic-complete-variable' does variable name
completion using the environment variables as set within Emacs.  The
variables controlling filename completion apply to variable name
completion too.  This command is normally available through the menu
bar.

   Command completion normally considers only executable files.  If you
set `shell-command-execonly' to `nil', it considers nonexecutable files
as well.

   You can now configure the behavior of `pushd'.  Variables control
whether `pushd' behaves like `cd' if no argument is given
(`shell-pushd-tohome'), pop rather than rotate with a numeric argument
(`shell-pushd-dextract'), and only add directories to the directory
stack if they are not already on it (`shell-pushd-dunique').  The
values you choose should match the underlying shell, of course.

