This is Info file ../info/emacs, produced by Makeinfo-1.54 from the
input file emacs.texi.


File: emacs,  Node: Intro,  Next: Glossary,  Prev: Copying,  Up: Top

Introduction
************

   You are reading about GNU Emacs, the GNU incarnation of the advanced,
self-documenting, customizable, extensible real-time display editor
Emacs.  (The `G' in `GNU' is not silent.)

   We say that Emacs is a "display" editor because normally the text
being edited is visible on the screen and is updated automatically as
you type your commands.  *Note Display: Screen.

   We call it a "real-time" editor because the display is updated very
frequently, usually after each character or pair of characters you
type.  This minimizes the amount of information you must keep in your
head as you edit.  *Note Real-time: Basic.

   We call Emacs advanced because it provides facilities that go beyond
simple insertion and deletion: controlling subprocesses; automatic
indentation of programs; viewing two or more files at once; and dealing
in terms of characters, words, lines, sentences, paragraphs, and pages,
as well as expressions and comments in several different programming
languages.

   "Self-documenting" means that at any time you can type a special
character, `Control-h', to find out what your options are.  You can
also use it to find out what any command does, or to find all the
commands that pertain to a topic.  *Note Help::.

   "Customizable" means that you can change the definitions of Emacs
commands in little ways.  For example, if you use a programming
language in which comments start with `<**' and end with `**>', you can
tell the Emacs comment manipulation commands to use those strings
(*note Comments::.).  Another sort of customization is rearrangement of
the command set.  For example, if you prefer the four basic cursor
motion commands (up, down, left and right) on keys in a diamond pattern
on the keyboard, you can rebind the keys that way.  *Note
Customization::.

   "Extensible" means that you can go beyond simple customization and
write entirely new commands, programs in the Lisp language to be run by
Emacs's own Lisp interpreter.  Emacs is an "on-line extensible" system,
which means that it is divided into many functions that call each
other, any of which can be redefined in the middle of an editing
session.  Almost any part of Emacs can be replaced without making a
separate copy of all of Emacs.  Most of the editing commands of Emacs
are written in Lisp already; the few exceptions could have been written
in Lisp but are written in C for efficiency.  Although only a programmer
can write an extension, anybody can use it afterward.

   When run under the X Window System, Emacs provides its own menus and
convenient bindings to mouse buttons.  But Emacs can provide many of the
benefits of a window system on a text-only terminal.  For instance, you
can look at or edit several files at once, move text between them, and
edit files at the same time as you run shell commands.


File: emacs,  Node: Screen,  Next: User Input,  Prev: Concept Index,  Up: Top

The Organization of the Screen
******************************

   On a text-only terminal, the Emacs display occupies the whole screen.
On the X Window System, Emacs creates its own X windows to use.  We use
the term "frame" to mean an entire text-only screen or an entire X
window used by Emacs.  Emacs uses both kinds of frames in the same way
to display your editing.  Emacs normally starts out with just one frame,
but under X you can create additional frames if you wish.  *Note
Frames::.

   When you start Emacs, the entire frame except for the last line is
devoted to the text you are editing.  This area is called "window".
The last line is a special "echo area" or "minibuffer window" where
prompts appear and where you can enter responses.  You can subdivide
the large text window horizontally or vertically into multiple text
windows, each of which can be used for a different file (*note
Windows::.).  In this manual, the word "window" always refers to the
subdivisions of a frame within Emacs.

   The window that the cursor is in is the "selected window", in which
editing takes place.  Most Emacs commands implicitly apply to the text
in the selected window (though mouse commands generally operate on
whatever window you click them in, whether selected or not).  The other
windows display text for reference only, unless/until you select them.
If you use multiple frames under the X Window System, then giving the
input focus to a particular frame selects a window in that frame.

   Each window's last line is a "mode line" which describes what is
going on in that window.  It appears in inverse video if the terminal
supports that, and contains text that starts like `-----Emacs:
SOMETHING'.  Its purpose is to indicate what buffer is being displayed
above it in the window; what major and minor modes are in use; and
whether the buffer contains unsaved changes.

* Menu:

* Point::	The place in the text where editing commands operate.
* Echo Area::   Short messages appear at the bottom of the screen.
* Mode Line::	Interpreting the mode line.


File: emacs,  Node: Point,  Next: Echo Area,  Up: Screen

Point
=====

   Within Emacs, the terminal's cursor shows the location at which
editing commands will take effect.  This location is called "point".
Many Emacs commands move point through the text, so that you can edit at
different places in it.  You can also place point by clicking mouse
button 1.

   While the cursor appears to point AT a character, you should think
of point as BETWEEN two characters; it points BEFORE the character that
appears under the cursor.  For example, if your text looks like `frob'
with the cursor over the `b', then point is between the `o' and the
`b'.  If you insert the character `!' at that position, the result is
`fro!b', with point between the `!' and the `b'.  Thus, the cursor
remains over the `b', as before.

   Sometimes people speak of "the cursor" when they mean "point", or
speak of commands that move point as "cursor motion" commands.

   Terminals have only one cursor, and when output is in progress it
must appear where the typing is being done.  This does not mean that
point is moving.  It is only that Emacs has no way to show you the
location of point except when the terminal is idle.

   If you are editing several files in Emacs, each in its own buffer,
each buffer has its own point location.  A buffer that is not currently
displayed remembers where point is in case you display it again later.

   When there are multiple windows in a frame, each window has its own
point location.  The cursor shows the location of point in the selected
window.  This also is how you can tell which window is selected.  If the
same buffer appears in more than one window, each window has its own
position for point in that buffer.

   When there are multiple frames, each frame can display one cursor.
The cursor in the selected frame is solid; the cursor in other frames is
a hollow box, and appears in the window that would be selected if you
give the input focus to that frame.

   The term `point' comes from the character `.', which was the command
in TECO (the language in which the original Emacs was written) for
accessing the value now called `point'.


File: emacs,  Node: Echo Area,  Next: Mode Line,  Prev: Point,  Up: Screen

The Echo Area
=============

   The line at the bottom of the frame (below the mode line) is the
"echo area".  It is used to display small amounts of text for several
purposes.

   "Echoing" means displaying the characters that you type.  Outside
Emacs, the operating system normally echoes all your input.  Emacs
handles echoing differently.

   Single-character commands do not echo in Emacs, and multi-character
commands echo only if you pause while typing them.  As soon as you pause
for more than a second in the middle of a command, Emacs echoes all the
characters of the command so far.  This is to "prompt" you for the rest
of the command.  Once echoing has started, the rest of the command
echoes immediately as you type it.  This behavior is designed to give
confident users fast response, while giving hesitant users maximum
feedback.  You can change this behavior by setting a variable (*note
Display Vars::.).

   If a command cannot be executed, it may print an "error message" in
the echo area.  Error messages are accompanied by a beep or by flashing
the screen.  Also, any input you have typed ahead is thrown away when
an error happens.

   Some commands print informative messages in the echo area.  These
messages look much like error messages, but they are not announced with
a beep and do not throw away input.  Sometimes the message tells you
what the command has done, when this is not obvious from looking at the
text being edited.  Sometimes the sole purpose of a command is to print
a message giving you specific information--for example, `C-x =' prints
a message describing the character position of point in the text and
its current column in the window.  Commands that take a long time often
display messages ending in `...' while they are working, and add `done'
at the end when they are finished.

   The echo area is also used to display the "minibuffer", a window that
is used for reading arguments to commands, such as the name of a file
to be edited.  When the minibuffer is in use, the echo area begins with
a prompt string that usually ends with a colon; also, the cursor
appears in that line because it is the selected window.  You can always
get out of the minibuffer by typing `C-g'.  *Note Minibuffer::.


File: emacs,  Node: Mode Line,  Prev: Echo Area,  Up: Screen

The Mode Line
=============

   Each text window's last line is a "mode line" which describes what
is going on in that window.  When there is only one text window, the
mode line appears right above the echo area.  The mode line is in
inverse video if the terminal supports that, it starts and ends with
dashes, and it contains text like `Emacs: SOMETHING'.

   A few special editing modes, such as Dired and Rmail, display
something else in place of `Emacs: SOMETHING'.  The rest of the mode
line still has the usual meaning.

   Normally, the mode line looks like this:

     --CH-Emacs: BUF      (MAJOR MINOR)----POS------

This gives information about the buffer being displayed in the window:
the buffer's name, what major and minor modes are in use, whether the
buffer's text has been changed, and how far down the buffer you are
currently looking.

   CH contains two stars `**' if the text in the buffer has been edited
(the buffer is "modified"), or `--' if the buffer has not been edited.
For a read-only buffer, it is `%*' if the buffer is modified, and `%%'
otherwise.

   BUF is the name of the window's "buffer".  In most cases this is the
same as the name of a file you are editing.  *Note Buffers::.

   The buffer displayed in the selected window (the window that the
cursor is in) is also Emacs's selected buffer, the one that editing
takes place in.  When we speak of what some command does to "the
buffer", we are talking about the currently selected buffer.

   POS tells you whether there is additional text above the top of the
window, or below the bottom.  If your buffer is small and it is all
visible in the window, POS is `All'.  Otherwise, it is `Top' if you are
looking at the beginning of the buffer, `Bot' if you are looking at the
end of the buffer, or `NN%', where NN is the percentage of the buffer
above the top of the window.

   MAJOR is the name of the "major mode" in effect in the buffer.  At
any time, each buffer is in one and only one of the possible major
modes.  The major modes available include Fundamental mode (the least
specialized), Text mode, Lisp mode, C mode, Texinfo mode, and many
others.  *Note Major Modes::, for details of how the modes differ and
how to select one.

   Some major modes display additional information after the major mode
name.  For example, Rmail buffers display the current message number and
the total number of messages.  Compilation buffers and Shell buffers
display the status of the subprocess.

   MINOR is a list of some of the "minor modes" that are turned on at
the moment in the window's chosen buffer.  For example, `Fill' means
that Auto Fill mode is on.  `Abbrev' means that Word Abbrev mode is on.
`Ovwrt' means that Overwrite mode is on.  *Note Minor Modes::, for
more information.  `Narrow' means that the buffer being displayed has
editing restricted to only a portion of its text.  This is not really a
minor mode, but is like one.  *Note Narrowing::.  `Def' means that a
keyboard macro is being defined.  *Note Keyboard Macros::.

   In addition, if Emacs is currently inside a recursive editing level,
square brackets (`[...]') appear around the parentheses that surround
the modes.  If Emacs is in one recursive editing level within another,
double square brackets appear, and so on.  Since recursive editing
levels affect Emacs globally, not just one buffer, the square brackets
appear in every window's mode line or not in any of them.  *Note
Recursive Edit::.

   *Note Optional Mode Line::, for features that add other handy
information to the mode line, such as the current line number of point,
the current time, and whether new mail for you has arrived.


File: emacs,  Node: User Input,  Next: Keys,  Prev: Screen,  Up: Top

Kinds of User Input
===================

   GNU Emacs uses an extension of the ASCII character set for keyboard
input; it also accepts non-character input events including function
keys and mouse button actions.

   ASCII consists of 128 character codes.  Some of these codes are
assigned graphic symbols such as `a' and `='; the rest are control
characters, such as `Control-a' (usually written `C-a' for short).
`C-a' gets its name from the fact that you type it by holding down the
CTRL key and then pressing `a'.

   Some control characters have special names, and special keys you can
type them with: for example, RET, TAB, LFD, DEL and ESC.  The space
character is usually referred to below as SPC, even though strictly
speaking it is a graphic character whose graphic happens to be blank.

   On ASCII terminals, there are only 32 possible control characters.
These are the control variants of letters and `@[]\^_'.  In addition,
the shift key is meaningless with control characters: `C-a' and `C-A'
are the same character, and Emacs cannot distinguish them.

   But the Emacs character set has room for control variants of all
characters, and for distinguishing between `C-a' and `C-A'.  X Windows
makes it possible to enter all these characters.  For example, `C--'
(that's Control-Minus) and `C-5' are meaningful Emacs commands under X.

   Another Emacs character set extension is that characters have
additional modifier bits.  Only one modifier bit is commonly used; it is
called Meta.  Every character has a Meta variant; examples include
`Meta-a' (normally written `M-a', for short), `M-A' (not the same
character as `M-a', but those two characters normally have the same
meaning in Emacs), `M-RET', and `M-C-a'.  For reasons of tradition, we
usually write `C-M-a' rather than `M-C-a'; logically speaking, the
order in which the modifier keys CTRL and META are mentioned does not
matter.

   Some terminals have a META key, and allow you to type Meta
characters by holding this key down.  Thus, `Meta-a' is typed by
holding down META and pressing `a'.  The META key works much like the
SHIFT key.  Such a key is not always labeled META, however, as this
function is often a special option for a key with some other primary
purpose.

   If there is no META key, you can still type Meta characters using
two-character sequences starting with ESC.  Thus, to enter `M-a', you
could type `ESC a'.  To enter `C-M-a', you would type `ESC C-a'.  ESC
is allowed on terminals with Meta keys, too, in case you have formed a
habit of using it.

   X Windows provides several other modifier keys that can be applied to
any input character.  These are called SUPER, HYPER and ALT.  We write
`s-', `H-' and `A-' to say that a character uses these modifiers.
Thus, `s-H-C-x' is short for `Super-Hyper-Control-x'.  Not all X
terminals actually provide keys for these modifier flags, and the
standard key bindings of Emacs do not include such characters.  But you
can assign them meanings of your own by customizing Emacs.

   Keyboard input includes keyboard keys that are not characters at all:
for example function keys and arrow keys.  Mouse buttons are also
outside the gamut of characters.  You can modify these events with the
modifier keys CONTROL, META, SUPER, HYPER and ALT like keyboard
characters.  But these inputs do not have numeric character codes.
Instead, Emacs represents them by their names (actually, Lisp objects
called "symbols").

   Input characters and non-character inputs are collectively called
"input events".  *Note Input Events: (elisp)Input Events, for more
information.  If you are not doing Lisp programming, but simply want to
redefine the meaning of some characters or non-character events, see
*Note Customization::.

   ASCII terminals cannot really send anything to the computer except
ASCII characters.  These terminals use a sequence of characters to
represent each function key.  But that is invisible to the Emacs user,
because the keyboard input routines recognize these special sequences
and converts them to names before any other part of Emacs gets to see
them.


File: emacs,  Node: Keys,  Next: Commands,  Prev: User Input,  Up: Top

Keys
====

   A "key sequence" ("key", for short) is a sequence of input events
that are meaningful as a unit--as "a single command." Some Emacs
command sequences are just one character or one event; for example,
just `C-f' is enough to move forward one character.  But Emacs also has
commands that take two or more events to invoke.

   If a sequence of events is enough to invoke a command, it is a
"complete key".  Examples of complete keys include `C-a', `X', RET,
NEXT (a function key), DOWN (an arrow key), `C-x C-f' and `C-x 4 C-f'.
If it isn't long enough to be complete, we call it a "prefix key".  The
above examples show that `C-x' and `C-x 4' are prefix keys.  Every key
sequence is either a complete key or a prefix key.

   Most single characters constitute complete keys in the standard Emacs
command bindings.  A few of them are prefix keys.  A prefix key combines
with the following input event to make a longer key sequence, which may
itself be complete or a prefix.  For example, `C-x' is a prefix key, so
`C-x' and the next input event combine to make a two-character key
sequence.  Most of these key sequences are complete keys, including
`C-x C-f' and `C-x b'.  A few, such as `C-x 4' and `C-x r', are
themselves prefix keys that lead to three-character key sequences.
There's no limit to the length of a key sequence, but in practice
people rarely use sequences longer than four events.

   By contrast, you can't add more events onto a complete key.  For
example, the two-character sequence `C-f C-k' is not a key, because the
`C-f' is a complete key in itself.  It's impossible to give `C-f C-k'
an independent meaning as a command.  `C-f C-k' is two key sequences,
not one.

   All told, the prefix keys in Emacs are `C-c', `C-h', `C-x', `C-x
C-a', `C-x n', `C-x r', `C-x v', `C-x 4', `C-x 5', `C-x 6', and ESC.
But this is not cast in concrete; it is just a matter of Emacs's
standard key bindings.  If you customize Emacs, you can make new prefix
keys, or eliminate these.  *Note Key Bindings::.

   If you do make or eliminate prefix keys, that changes the set of
possible key sequences.  For example, if you redefine `C-f' as a
prefix, `C-f C-k' automatically becomes a key (complete, unless you
define it too as a prefix).  Conversely, if you remove the prefix
definition of `C-x 4', then `C-x 4 f' (or `C-x 4 ANYTHING') is no
longer a key.

   Typing the help character (`C-h') after a prefix character usually
displays a list of the commands starting with that prefix.  There are a
few prefix characters for which this doesn't work--for historical
reasons, they have other meanings for `C-h' which are not easy to
change.


File: emacs,  Node: Commands,  Next: Text Characters,  Prev: Keys,  Up: Top

Keys and Commands
=================

   This manual is full of passages that tell you what particular keys
do.  But Emacs does not assign meanings to keys directly.  Instead,
Emacs assigns meanings to named "commands", and then gives keys their
meanings by "binding" them to commands.

   Every command has a name chosen by a programmer.  The name is usually
made of a few English words separated by dashes; for example,
`next-line' or `forward-word'.  A command also has a "function
definition" which is a Lisp program; this is what makes the command do
what it does.  In Emacs Lisp, a command is actually a special kind of
Lisp function; one which specifies how to read arguments for it and
call it interactively.  For more information on commands and functions,
see *Note What Is a Function: (elisp)What Is a Function.  (The
definition we use in this manual is simplified slightly.)

   The bindings between keys and commands are recorded in various tables
called "keymaps".  *Note Keymaps::.

   When we say that "`C-n' moves down vertically one line" we are
glossing over a distinction that is irrelevant in ordinary use but is
vital in understanding how to customize Emacs.  It is the command
`next-line' that is programmed to move down vertically.  `C-n' has this
effect *because* it is bound to that command.  If you rebind `C-n' to
the command `forward-word' then `C-n' will move forward by words
instead.  Rebinding keys is a common method of customization.

   In the rest of this manual, we usually ignore this subtlety to keep
things simple.  To give the information needed for customization, we
state the name of the command which really does the work in parentheses
after mentioning the key that runs it.  For example, we will say that
"The command `C-n' (`next-line') moves point vertically down," meaning
that `next-line' is a command that moves vertically down and `C-n' is a
key that is standardly bound to it.

   While we are on the subject of information for customization only,
it's a good time to tell you about "variables".  Often the description
of a command will say, "To change this, set the variable `mumble-foo'."
A variable is a name used to remember a value.  Most of the variables
documented in this manual exist just to facilitate customization: some
command or other part of Emacs examines the variable and behaves
differently according to the value that you set.  Until you are
interested in customizing, you can ignore the information about
variables.  When you are ready to be interested, read the basic
information on variables, and then the information on individual
variables will make sense.  *Note Variables::.


File: emacs,  Node: Text Characters,  Next: Entering Emacs,  Prev: Commands,  Up: Top

Character Set for Text
======================

   Emacs buffers use an 8-bit character set, because bytes have 8 bits.
ASCII graphic characters in Emacs buffers are displayed with their
graphics.  The newline character (which has the same character code as
LFD) is displayed by starting a new line.  The tab character is
displayed by moving to the next tab stop column (normally every 8
columns).  Other control characters are displayed as a caret (`^')
followed by the non-control version of the character; thus, `C-a' is
displayed as `^A'.  Non-ASCII characters 128 and up are displayed with
octal escape sequences; thus, character code 243 (octal) is displayed
as `\243'.

   You can customize the display of these character codes (or ASCII
characters) by creating a "display table".  *Note Display Tables:
(elisp)Display Tables.  This is useful for editing files that use 8-bit
European character sets.  *Note European Display::.


File: emacs,  Node: Entering Emacs,  Next: Exiting,  Prev: Text Characters,  Up: Top

Entering and Exiting Emacs
**************************

   The usual way to invoke Emacs is with the shell command `emacs'.
Emacs clears the screen and then displays an initial help message and
copyright notice.  Some operating systems discard all type-ahead when
Emacs starts up; they give Emacs no way to prevent this.  Therefore, it
is advisable to wait until Emacs clears the screen before typing your
first editing command.

   If you run Emacs from a shell window under the X Window System, run
it in the background with `emacs&'.  This way, Emacs does not tie up
the shell window, so you can use that to run other shell commands while
Emacs operates its own X windows.  You can begin typing Emacs commands
as soon as you direct your keyboard input to the Emacs frame.

   When Emacs starts up, it makes a buffer named `*scratch*'.  That's
the buffer you start out in.  The `*scratch*' buffer uses Lisp
Interaction mode; you can use it to type Lisp expressions and evaluate
them, or you can ignore that capability and simply doodle.  (You can
specify a different major mode for this buffer by setting the variable
`initial-major-mode' in your init file.  *Note Init File::.)

   It is possible to specify files to be visited, Lisp files to be
loaded, and functions to be called, by giving Emacs arguments in the
shell command line.  *Note Command Arguments::.  But we don't recommend
doing this.  The feature exists mainly for compatibility with other
editors.

   Many other editors are designed to be started afresh each time you
want to edit.  You edit one file and then exit the editor.  The next
time you want to edit either another file or the same one, you must run
the editor again.  With these editors, it makes sense to use a command
line argument to say which file to edit.

   But starting a new Emacs each time you want to edit a different file
does not make sense.  For one thing, this would be annoyingly slow.  For
another, this would fail to take advantage of Emacs's ability to visit
more than one file in a single editing session.  And it would lose the
other accumulated context, such as registers, undo history, and the mark
ring.

   The recommended way to use GNU Emacs is to start it only once, just
after you log in, and do all your editing in the same Emacs session.
Each time you want to edit a different file, you visit it with the
existing Emacs, which eventually comes to have many files in it ready
for editing.  Usually you do not kill the Emacs until you are about to
log out.  *Note Files::, for more information on visiting more than one
file.


File: emacs,  Node: Exiting,  Next: Basic,  Prev: Entering Emacs,  Up: Top

Exiting Emacs
=============

   There are two commands for exiting Emacs because there are two kinds
of exiting: "suspending" Emacs and "killing" Emacs.

   "Suspending" means stopping Emacs temporarily and returning control
to its parent process (usually a shell), allowing you to resume editing
later in the same Emacs job, with the same buffers, same kill ring,
same undo history, and so on.  This is the usual way to exit.

   "Killing" Emacs means destroying the Emacs job.  You can run Emacs
again later, but you will get a fresh Emacs; there is no way to resume
the same editing session after it has been killed.

`C-z'
     Suspend Emacs (`suspend-emacs') or iconify a frame
     (`iconify-or-deiconify-frame').

`C-x C-c'
     Kill Emacs (`save-buffers-kill-emacs').

   To suspend Emacs, type `C-z' (`suspend-emacs').  This takes you back
to the shell from which you invoked Emacs.  You can resume Emacs with
the shell command `%emacs' in most common shells.

   On systems that do not support suspending programs, `C-z' starts an
inferior shell that communicates directly with the terminal.  Emacs
waits until you exit the subshell.  (The way to do that is probably
with `C-d' or `exit', but it depends on which shell you use.)  The only
way on these systems to get back to the shell from which Emacs was run
(to log out, for example) is to kill Emacs.

   Suspending also fails if you run Emacs under a shell that doesn't
support suspending programs, even if the system itself does support it.
In such a case, you can set the variable `cannot-suspend' to a
non-`nil' value to force `C-z' to start an inferior shell.  (One might
also describe Emacs's parent shell as "inferior" for failing to support
job control properly, but that is a matter of taste.)

   When Emacs communicates directly with an X server and creates its own
dedicated X windows, `C-z' has a different meaning.  Suspending an
applications that uses its own X windows is not meaningful or useful.
Instead, `C-z' runs the command `iconify-or-deiconify-frame', which
temporarily closes up the selected Emacs frame.  The way to get back to
a shell window is with the window manager.

   To kill Emacs, type `C-x C-c' (`save-buffers-kill-emacs').  A
two-character key is used for this to make it harder to type.  This
command first offers to save any modified file-visiting buffers.  If you
do not save them all, it asks for reconfirmation with `yes' before
killing Emacs, since any changes not saved will be lost forever.  Also,
if any subprocesses are still running, `C-x C-c' asks for confirmation
about them, since killing Emacs will kill the subprocesses immediately.

   There is no way to restart an Emacs session once you have killed it.
You can, however, arrange for Emacs to record certain session
information, such as which files are visited, when you kill it, so that
the next time you restart Emacs it will try to visit the same files and
so on.  *Note Saving Emacs Sessions::.

   The operating system usually listens for certain special characters
whose meaning is to kill or suspend the program you are running.  This
operating system feature is turned off while you are in Emacs.  The
meanings of `C-z' and `C-x C-c' as keys in Emacs were inspired by the
use of `C-z' and `C-c' on several operating systems as the characters
for stopping or killing a program, but that is their only relationship
with the operating system.  You can customize these keys to run any
commands of your choice (*note Keymaps::.).


File: emacs,  Node: Basic,  Next: Minibuffer,  Prev: Exiting,  Up: Top

Basic Editing Commands
**********************

   We now give the basics of how to enter text, make corrections, and
save the text in a file.  If this material is new to you, you might
learn it more easily by running the Emacs learn-by-doing tutorial.  To
use the tutorial, run Emacs and type `Control-h t'
(`help-with-tutorial').

   To clear the screen and redisplay, type `C-l' (`recenter').

* Menu:

* Inserting Text::     Inserting text by simply typing it.
* Moving Point::       How to move the cursor to the place where you want to
		         change something.
* Erasing::	       Deleting and killing text.
* Undo::               Undoing previous changes.
* Files: Basic Files.  Visiting, creating, and saving files.
* Help: Basic Help.    Asking what a character does.
* Blank Lines::        Commands to make or delete blank lines.
* Continuation Lines:: Lines too wide for the screen.
* Position Info::      What page, line, row, or column is point on?
* Arguments::	       Numeric arguments for repeating a command.


File: emacs,  Node: Inserting Text,  Next: Moving Point,  Up: Basic

Inserting Text
==============

   To insert printing characters into the text you are editing, just
type them.  This inserts the characters you type into the buffer at the
cursor (that is, at "point"; *note Point::.).  The cursor moves
forward, and any text after the cursor moves forward too.  If the text
in the buffer is `FOOBAR', with the cursor before the `B', then if you
type `XX', you get `FOOXXBAR', with the cursor still before the `B'.

   To "delete" text you have just inserted, use DEL.  DEL deletes the
character *before* the cursor (not the one that the cursor is on top of
or under; that is the character AFTER the cursor).  The cursor and all
characters after it move backwards.  Therefore, if you type a printing
character and then type DEL, they cancel out.

   To end a line and start typing a new one, type RET.  This inserts a
newline character in the buffer.  If point is in the middle of a line,
RET splits the line.  Typing DEL when the cursor is at the beginning of
a line deletes the preceding newline, thus joining the line with the
preceding line.

   Emacs can split lines automatically when they become too long, if you
turn on a special minor mode called "Auto Fill" mode.  *Note Filling::,
for how to use Auto Fill mode.

   If you prefer to have text characters replace (overwrite) existing
text rather than shove it to the right, you can enable Overwrite mode,
a minor mode.  *Note Minor Modes::.

   Direct insertion works for printing characters and SPC, but other
characters act as editing commands and do not insert themselves.  If you
need to insert a control character or a character whose code is above
200 octal, you must "quote" it by typing the character `Control-q'
(`quoted-insert') first.  (This character's name is normally written
`C-q' for short.)  There are two ways to use `C-q':

   * `C-q' followed by any non-graphic character (even `C-g') inserts
     that character.

   * `C-q' followed by three octal digits inserts the character with
     the specified character code.

A numeric argument to `C-q' specifies how many copies of the quoted
character should be inserted (*note Arguments::.).

   Customization information: DEL in most modes runs the command
`delete-backward-char'; RET runs the command `newline', and
self-inserting printing characters run the command `self-insert', which
inserts whatever character was typed to invoke it.  Some major modes
rebind DEL to other commands.


File: emacs,  Node: Moving Point,  Next: Erasing,  Prev: Inserting Text,  Up: Basic

Changing the Location of Point
==============================

   To do more than insert characters, you have to know how to move point
(*note Point::.).  The simplest way to do this is with arrow keys, or by
clicking the left mouse button where you want to move to.

   There are also control and meta characters for cursor motion.  Some
are equivalent to the arrow keys (these date back to the days before
terminals had arrow keys, and are usable on terminals which don't have
them).  Others do more sophisticated things.

`C-a'
     Move to the beginning of the line (`beginning-of-line').

`C-e'
     Move to the end of the line (`end-of-line').

`C-f'
     Move forward one character (`forward-char').

`C-b'
     Move backward one character (`backward-char').

`M-f'
     Move forward one word (`forward-word').

`M-b'
     Move backward one word (`backward-word').

`C-n'
     Move down one line, vertically (`next-line').  This command
     attempts to keep the horizontal position unchanged, so if you
     start in the middle of one line, you end in the middle of the
     next.  When on the last line of text, `C-n' creates a new line and
     moves onto it.

`C-p'
     Move up one line, vertically (`previous-line').

`M-r'
     Move point to left margin, vertically centered in the window
     (`move-to-window-line').  Text does not move on the screen.

     A numeric argument says which screen line to place point on.  It
     counts screen lines down from the top of the window (zero for the
     top line).  A negative argument counts lines from the bottom (-1
     for the bottom line).

`M-<'
     Move to the top of the buffer (`beginning-of-buffer').  With
     numeric argument N, move to N/10 of the way from the top.  *Note
     Arguments::, for more information on numeric arguments.

`M->'
     Move to the end of the buffer (`end-of-buffer').

`M-x goto-char'
     Read a number N and move point to character number N.  Position 1
     is the beginning of the buffer.

`M-x goto-line'
     Read a number N and move point to line number N.  Line 1 is the
     beginning of the buffer.

`C-x C-n'
     Use the current column of point as the "semipermanent goal column"
     for `C-n' and `C-p' (`set-goal-column').  Henceforth, those
     commands always move to this column in each line moved into, or as
     close as possible given the contents of the line.  This goal
     column remains in effect until canceled.

`C-u C-x C-n'
     Cancel the goal column.  Henceforth, `C-n' and `C-p' once again
     try to stick to a fixed horizontal position, as usual.

   If you set the variable `track-eol' to a non-`nil' value, then `C-n'
and `C-p' when at the end of the starting line move to the end of
another line.  Normally, `track-eol' is `nil'.  *Note Variables::, for
how to set variables such as `track-eol'.

   Normally, `C-n' on the last line of a buffer appends a newline to
it.  If the variable `next-line-add-newlines' is `nil', then `C-n' gets
an error instead (like `C-p' on the first line).


File: emacs,  Node: Erasing,  Next: Undo,  Prev: Moving Point,  Up: Basic

Erasing Text
============

`DEL'
     Delete the character before point (`delete-backward-char').

`C-d'
     Delete the character after point (`delete-char').

`C-k'
     Kill to the end of the line (`kill-line').

`M-d'
     Kill forward to the end of the next word (`kill-word').

`M-DEL'
     Kill back to the beginning of the previous word
     (`backward-kill-word').

   You already know about the DEL key which deletes the character
before point (that is, before the cursor).  Another key, `Control-d'
(`C-d' for short), deletes the character after point (that is, the
character that the cursor is on).  This shifts the rest of the text on
the line to the left.  If you type `C-d' at the end of a line, it joins
together that line and the next line.

   To erase a larger amount of text, use the `C-k' key, which kills a
line at a time.  If you type `C-k' at the beginning or middle of a
line, it kills all the text up to the end of the line.  If you type
`C-k' at the end of a line, it joins that line and the next line.

   *Note Killing::, for more flexible ways of killing text.


File: emacs,  Node: Undo,  Next: Basic Files,  Prev: Erasing,  Up: Basic

Undoing Changes
===============

   You can undo all the recent changes in the buffer text, up to a
certain point.  Each buffer records changes individually, and the undo
command always applies to the current buffer.  Usually each editing
command makes a separate entry in the undo records, but some commands
such as `query-replace' make many entries, and very simple commands
such as self-inserting characters are often grouped to make undoing less
tedious.

`C-x u'
     Undo one batch of changes--usually, one command worth (`undo').

`C-_'
     The same.

   The command `C-x u' or `C-_' is how you undo.  The first time you
give this command, it undoes the last change.  Point moves back to
where it was before the command that made the change.

   Consecutive repetitions of `C-_' or `C-x u' undo earlier and earlier
changes, back to the limit of the undo information available.  If all
recorded changes have already been undone, the undo command prints an
error message and does nothing.

   Any command other than an undo command breaks the sequence of undo
commands.  Starting from that moment, the previous undo commands become
ordinary changes that you can undo.  Thus, to redo changes you have
undone, type `C-f' or any other command that will harmlessly break the
sequence of undoing, then type more undo commands.

   If you notice that a buffer has been modified accidentally, the
easiest way to recover is to type `C-_' repeatedly until the stars
disappear from the front of the mode line.  At this time, all the
modifications you made have been canceled.  Whenever an undo command
makes the stars disappear from the mode line, it means that the buffer
contents are the same as they were when the file was last read in or
saved.

   If you do not remember whether you changed the buffer deliberately,
type `C-_' once.  When you see the last change you made undone, you
will see whether it was an intentional change.  If it was an accident,
leave it undone.  If it was deliberate, redo the change as described
above.

   Not all buffers record undo information.  Buffers whose names start
with spaces don't; these buffers are used internally by Emacs and its
extensions to hold text that users don't normally look at or edit.

   You cannot undo mere cursor motion; only changes in the buffer
contents save undo information.  However, some cursor motion commands
set the mark, so if you use these commands from time to time, you can
move back to the neighborhoods you have moved through by popping the
mark ring (*note Mark Ring::.).

   When the undo information for a buffer becomes too large, Emacs
discards the oldest undo information from time to time (during garbage
collection).  You can specify how much undo information to keep by
setting two variables: `undo-limit' and `undo-strong-limit'.  Their
values are expressed in units of bytes of space.

   The variable `undo-limit' sets a soft limit: Emacs keeps undo data
for enough commands to reach this size, and perhaps exceed it, but does
not keep data for any earlier commands beyond that.  Its default value
is 20000.  The variable `undo-strong-limit' sets a stricter limit: the
command which pushes the size past this amount is itself forgotten.
Its default value is 30000.

   Regardless of the values of those variables, the most recent change
is never discarded, so there is no danger that garbage collection
occurring right after an unintentional large change might prevent you
from undoing it.

   The reason the `undo' command has two keys, `C-x u' and `C-_', set
up to run it is that it is worthy of a single-character key, but on
some keyboards it is not obvious how to type `C-_'.  `C-x u' is an
alternative you can type straightforwardly on any terminal.


File: emacs,  Node: Basic Files,  Next: Basic Help,  Prev: Undo,  Up: Basic

Files
=====

   The commands described above are sufficient for creating and altering
text in an Emacs buffer; the more advanced Emacs commands just make
things easier.  But to keep any text permanently you must put it in a
"file".  Files are named units of text which are stored by the
operating system for you to retrieve later by name.  To look at or use
the contents of a file in any way, including editing the file with
Emacs, you must specify the file name.

   Consider a file named `/usr/rms/foo.c'.  In Emacs, to begin editing
this file, type

     C-x C-f /usr/rms/foo.c RET

Here the file name is given as an "argument" to the command `C-x C-f'
(`find-file').  That command uses the "minibuffer" to read the
argument, and you type RET to terminate the argument (*note
Minibuffer::.).

   Emacs obeys the command by "visiting" the file: creating a buffer,
copying the contents of the file into the buffer, and then displaying
the buffer for you to edit.  If you alter the text, you can "save" the
new text in the file by typing `C-x C-s' (`save-buffer').  This makes
the changes permanent by copying the altered buffer contents back into
the file `/usr/rms/foo.c'.  Until you save, the changes exist only
inside Emacs, and the file `foo.c' is unaltered.

   To create a file, just visit the file with `C-x C-f' as if it
already existed.  This creates an empty buffer in which you can insert
the text you want to put in the file.  The file is actually created when
you save this buffer with `C-x C-s'.

   Of course, there is a lot more to learn about using files.  *Note
Files::.


File: emacs,  Node: Basic Help,  Next: Blank Lines,  Prev: Basic Files,  Up: Basic

Help
====

   If you forget what a key does, you can find out with the Help
character, which is `C-h'.  Type `C-h k' followed by the key you want
to know about; for example, `C-h k C-n' tells you all about what `C-n'
does.  `C-h' is a prefix key; `C-h k' is just one of its subcommands
(the command `describe-key').  The other subcommands of `C-h' provide
different kinds of help.  Type `C-h' twice to get a description of all
the help facilities.  *Note Help::.


File: emacs,  Node: Blank Lines,  Next: Continuation Lines,  Prev: Basic Help,  Up: Basic

Blank Lines
===========

   Here are special commands and techniques for putting in and taking
out blank lines.

`C-o'
     Insert one or more blank lines after the cursor (`open-line').

`C-x C-o'
     Delete all but one of many consecutive blank lines
     (`delete-blank-lines').

   When you want to insert a new line of text before an existing line,
you can do it by typing the new line of text, followed by RET.
However, it may be easier to see what you are doing if you first make a
blank line and then insert the desired text into it.  This is easy to do
using the key `C-o' (`open-line'), which inserts a newline after point
but leaves point in front of the newline.  After `C-o', type the text
for the new line.  `C-o F O O' has the same effect as `F O O RET',
except for the final location of point.

   You can make several blank lines by typing `C-o' several times, or
by giving it a numeric argument to tell it how many blank lines to make.
*Note Arguments::, for how.  If you have a fill prefix, then `C-o'
command inserts the fill prefix on the new line, when you use it at the
beginning of a line.  *Note Fill Prefix::.

   The easy way to get rid of extra blank lines is with the command
`C-x C-o' (`delete-blank-lines').  `C-x C-o' in a run of several blank
lines deletes all but one of them.  `C-x C-o' on a solitary blank line
deletes that blank line.  When point is on a nonblank line, `C-x C-o'
deletes any blank lines following that nonblank line.


File: emacs,  Node: Continuation Lines,  Next: Position Info,  Prev: Blank Lines,  Up: Basic

Continuation Lines
==================

   If you add too many characters to one line without breaking it with
RET, the line will grow to occupy two (or more) lines on the screen,
with a `\' at the extreme right margin of all but the last of them.
The `\' says that the following screen line is not really a distinct
line in the text, but just the "continuation" of a line too long to fit
the screen.  Continuation is also called "line wrapping".

   Sometimes it is nice to have Emacs insert newlines automatically when
a line gets too long.  Continuation on the screen does not do that.  Use
Auto Fill mode (*note Filling::.) if that's what you want.

   As an alternative to continuation, Emacs can display long lines by
"truncation".  This means that all the characters that do not fit in
the width of the screen or window do not appear at all.  They remain in
the buffer, temporarily invisible.  `$' is used in the last column
instead of `\' to inform you that truncation is in effect.

   Truncation instead of continuation happens whenever horizontal
scrolling is in use, and optionally in all side-by-side windows (*note
Windows::.).  You can enable truncation for a particular buffer by
setting the variable `truncate-lines' to non-`nil' in that buffer.
(*Note Variables::.)  Altering the value of `truncate-lines' makes it
local to the current buffer; until that time, the default value is in
effect.  The default is initially `nil'.  *Note Locals::.

   *Note Display Vars::, for additional variables that affect how text
is displayed.

