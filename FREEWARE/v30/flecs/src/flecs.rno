.INDENT 0
.NNM
.LM 5
.RM 70
.SKIP 20
.C
^^FLECS:
.SKIP
.C
USER'S MANUAL\\
.SKIP 5
.C
^UNIVERSITY OF ^OREGON ^EDITION
.SKIP
.C
^THIS MANUAL CORRESPONDS TO VERSION 22 OF ^FLECS.
.C
(^REVISED ^OCTOBER 1, 1975)
.SKIP 10
.BR
	^AUTHOR:		^TERRY ^BEYER
.SKIP
.BR
	^ADDRESS:	^COMPUTING ^CENTER
.BR
			^UNIVERSITY OF ^OREGON
.BR
			^EUGENE, ^OREGON 97403
.SKIP
.BR
	^TELEPHONE:	(503) 686-4416
.SKIP
.BR
	^PUBLISHED BY:	^DEPARTMENT OF ^COMPUTER ^SCIENCE
.BR
			^UNIVERSITY OF ^OREGON
.SKIP 5
.P
^NEITHER THE AUTHOR NOR THE ^UNIVERSITY OF ^OREGON SHALL BE LIABLE
FOR ANY DIRECT OR INDIRECT, INCIDENTAL, CONSEQUENTIAL, OR SPECIFIC
DAMAGES OF ANY KIND OR FROM ANY CAUSE WHATSOEVER ARISING OUT OF OR IN
ANY WAY CONNECTED WITH THE USE OR PERFORMANCE OF THE ^FLECS SYSTEM
OR ITS DOCUMENTATION.
.P
^THIS MANUAL IS IN THE PUBLIC DOMAIN AND MAY BE ALTERED OR REPRODUCED
WITHOUT THE EXPLICIT PERMISSION OF THE AUTHOR. ^PLEASE COMMUNICATE
ANY ERRORS, AMBIGUITIES, OR OMISSIONS TO THE AUTHOR.
.PAGE
.BR
^^ACKNOWLEDGEMENTS\\
.INDENT 5
.P
^THE AUTHOR IS INDEBTED TO MANY PEOPLE FOR ASSISTANCE OF ONE FORM
OR ANOTHER DURING THE COURSE OF THIS PROJECT. ^MIKE ^DUNLAP, ^KEVIN
^MC^COY, AND ^PETER ^MOULTON DESERVE SPECIAL THANKS FOR MANY
HELPFUL AND FRUITFUL DISCUSSIONS, SUGGESTIONS, AND ENCOURAGEMENTS.
^I AM GRATEFUL TO MY WIFE, ^KATHLEEN, WHO ASSISTED IN MANY WAYS
INCLUDING SHIELDING ME FROM THE HARSH REALITY OF ^^JCL\\ AND 360
^ASSEMBLY ^LANGUAGE. ^TEXT PREPARATION WAS ADROITLY ACCOMPLISHED
BY ^MARVA ^VAN^NATTA, ^ALLYENE ^TOM, ^DIANE ^LANE, AND ^KATHLEEN
^BEYER.
.P
^THIS PROJECT WAS INITIATED WHILE THE AUTHOR WAS WORKING UNDER A
GRANT PROVIDED BY THE ^OFFICE OF ^SCIENTIFIC AND ^SCHOLARLY ^RESEARCH
OF THE ^GRADUATE ^SCHOOL AT THE ^UNIVERSITY OF ^OREGON. ^WORK ON THE
PROJECT HAS ALSO BEEN SUPPORTED IN PART BY THE ^DEPARTMENT OF ^COMPUTER
^SCIENCE AND BY THE ^COMPUTING ^CENTER OF THE ^UNIVERSITY OF ^OREGON
.PAGE
.NM 0
.TITLE #####FLECS USER'S MANUAL
.BR
1.0  ^^INTRODUCTION\\
.BR
.INDEX 1.0 ^^INTRODUCTION\\
.P
^FORTRAN CONTAINS FOUR BASIC MECHANISMS FOR CONTROLLING PROGRAM
FLOW:  ^^CALL/RETURN, IF, DO\\, AND VARIOUS FORMS OF THE ^^GO TO\\.
.P
^FLECS IS A LANGUAGE EXTENSION OF ^FORTRAN WHICH HAS ADDITIONAL CONTROL
MECHANISMS. ^THESE MECHANISMS MAKE IT EASIER TO WRITE ^FORTRAN BY
ELIMINATING MUCH OF THE CLERICAL DETAIL ASSOCIATED WITH CONSTRUCTING
^FORTRAN PROGRAMS. ^FLECS IS ALSO EASIER TO READ AND COMPREHEND THAN
^FORTRAN.
.P
^THIS MANUAL IS INTENDED TO BE A BRIEF BUT COMPLETE INTRODUCTION TO
^FLECS. ^IT IS NOT INTENDED TO BE A PRIMER ON ^FLECS OR STRUCTURED
PROGRAMMING. ^THE READER IS ASSUMED TO BE A KNOWLEDGEABLE ^FORTRAN
PROGRAMMER.
.P
^FOR PROGRAMMERS TO WHOM TRANSPORTABILITY OF THEIR PROGRAMS IS A
CONCERN, IT SHOULD BE NOTED THAT THE ^FLECS TRANSLATOR SOURCE CODE
IS IN THE PUBLIC DOMAIN AND IS MADE FREELY AVAILABLE. ^THE TRANSLATOR
WAS WRITTEN WITH TRANSPORTABILITY IN MIND AND REQUIRES LITTLE EFFORT
TO MOVE FROM ONE MACHINE TO ANOTHER. ^THOSE INTERESTED IN MOVING
^FLECS TO ANOTHER MACHINE OR IN HAVING THEIR OWN COPY OF ^FLECS SHOULD
CONTACT THE AUTHOR.
.P
^THE MANNER OF IMPLEMENTATION OF ^FLECS IS THAT OF A PREPROCESSOR WHICH
TRANSLATES ^FLECS PROGRAMS INTO ^FORTRAN PROGRAMS. ^THE RESULTING
^FORTRAN PROGRAM IS THEN PROCESSED IN THE USUAL WAY. ^THE TRANSLATOR
ALSO PRODUCES A NICELY FORMATTED LISTING OF THE ^FLECS PROGRAM WHICH
GRAPHICALLY PRESENTS THE CONTROL STRUCTURES USED.
.SKIP
.TEST PAGE 5
.INDEX 2.0 ^^RETENTION OF FEATURES\\
.SKIP
.BR
2.0  ^^RETENTION OF FORTRAN FEATURES\\
.BR
.P
^THE ^FLECS TRANSLATOR EXAMINES EACH STATEMENT IN THE ^FLECS PROGRAM
TO SEE IF IT IS AN ^^EXTENDED STATEMENT\\ (A STATEMENT VALID IN ^FLECS
BUT NOT IN ^FORTRAN). ^IF IT IS RECOGNIZED AS AN EXTENDED STATEMENT,
THE TRANSLATOR GENERATES THE CORRESPONDING ^FORTRAN STATEMENTS. ^IF,
HOWEVER, THE STATEMENT IS NOT RECOGNIZED AS AN EXTENDED STATEMENT,
THE TRANSLATOR ASSUMES IT MUST BE A ^FORTRAN STATEMENT AND PASSES IT
THROUGH UNALTERED. ^THUS ^^THE FLECS SYSTEM DOES NOT RESTRICT THE USE
OF FORTRAN STATEMENTS\\, IT SIMPLY PROVIDES A SET OF ADDITIONAL STATEMENTS
WHICH MAY BE USED. ^IN PARTICULAR, ^^GO TO\\S, ARITHMATIC ^I^FS, ^^CALL\\S,
ARITHMETIC STATEMENT FUNCTIONS, AND ANY OTHER ^FORTRAN STATEMENTS, COMPILER
DEPENDENT OR OTHERWISE, MAY BE USED IN A ^FLECS PROGRAM.
.PAGE
.INDEX 3.0 ^^CORRELATION OF SOURCES\\
.SKIP
.BR
3.0  ^^CORRELATION OF FLECS AND FORTRAN SOURCES\\
.BR
.P
^ONE DIFFICULTY OF PREPROCESSOR SYSTEMS LIKE ^FLECS IS THAT ERROR
MESSAGES WHICH COME FROM THE ^FORTRAN COMPILER MUST BE RELATED BACK TO
THE ORIGINAL ^FLECS SOURCE PROGRAM. ^THIS DIFFICULTY IS REDUCED BY
ALLOWING THE PLACEMENT OF ^^LINE NUMBERS\\ (NOT TO BE CONFUSED WITH
^FORTRAN STATEMENT NUMBERS) ON ^FLECS SOURCE STATEMENTS. ^THESE LINE
NUMBERS THEN APPEAR ON THE LISTING AND IN THE ^FORTRAN SOURCE. ^WHEN
AN ERROR MESSAGE IS PRODUCED BY EITHER THE ^FLECS TRANSLATOR OR THE
^FORTRAN COMPILER, IT WILL INCLUDE THE LINE NUMBER OF THE OFFENDING
^FLECS SOURCE STATEMENT, MAKING IT EASY TO LOCATE ON THE LISTING.
.P
^IF THE PROGRAMMER CHOOSES NOT TO SUPPLY LINE NUMBERS, THE TRANSLATOR
WILL ASSIGN SEQUENTIAL NUMBERS AND PLACE THEM ON THE LISTING AND IN THE
^FORTRAN SOURCE. ^THUS, ERRORS FROM THE COMPILER MAY STILL BE RELATED
TO THE ^FLECS PROGRAM.
.P
^DETAILS OF LINE NUMBERING ARE MACHINE DEPENDENT AND ARE GIVEN IN
SECTION 10. ^ON MOST CARD ORIENTED SYSTEMS, THE LINE NUMBERS MAY BE
PLACED IN COLLUMNS 76-80 OF EACH CARD. ^OTHER SYSTEMS MAY HAVE SPECIAL
PROVISIONS FOR LINE NUMBERS.
.P
^THE BEGINNING ^FLECS PROGRAMMER SHOULD DISCOVER AND MAKE SPECIAL NOTE
OF THE DETAILS OF THE MECHANISMS BY WHICH ^FORTRAN COMPILER ERROR MESSAGES
MAY BE TRACED BACK TO THE ^FLECS LISTING ON THE SYSTEM BEING USED.
.SKIP
.TEST PAGE 6
.BR
.INDEX 4.0 ^^STRUCTURED STATEMENTS\\
.SKIP
.BR
4.0  ^^STRUCTURED STATEMENTS\\
.BR
.P
^A BASIC NOTION OF ^FLECS IS THAT OF THE ^^STRUCTURED STATEMENT\\ WHICH
CONSISTS OF A ^^CONTROL PHRASE\\ AND ITS ^^SCOPE\\. ^FORTRAN HAS TWO
STRUCTURED STATEMENTS, THE LOGICAL ^^IF\\ AND THE ^^DO\\. ^THE FOLLOWING
EXAMPLES ILLUSTRATE THIS TERMINOLOGY:
.SKIP
.BR
	<STRUCTURED STATEMENT> ::= <CONTROL PHRASE> <SCOPE>
.SKIP
.BR
	<CONTROL PHRASE> ::= <KEYWORD> <SPECIFICATION>
.SKIP
.BR
	<KEYWORD> ::= <^^DO>, <IF>\\
.SKIP
.BR
	<SPECIFICATION> ::= <(^^X .EQ. Y\\)>
.SKIP
.BR
	<SCOPE> ::= <^^U=V+W\\>
.SKIP
.BR
	<KEWORD>  <SPECIFICATION>
.BR
	^^DO	   30 I=1,N\\	>CONTROL PHRASE
.BR
		   ^^A(I) = B(I)+C\\
.BR
				>SCOPE		>STRUCTURED STATEMENT
.BR
		  ^^L(I)=I-K(I)
.BR
30		  CONTINUE\\
.BR
^NOTE THAT EACH STRUCTURED STATEMENT CONSISTS OF A CONTROL PHRASE WHICH
CONTROLS THE EXECUTION OF A SET OF ONE OR MORE STATEMENTS CALLED ITS
SCOPE. ^ALSO NOTE THAT EACH CONTROL PHRASE CONSISTS OF A ^^KEYWORD\\
PLUS SOME ADDITIONAL INFORMATION CALLED THE ^^SPECIFICATION\\.
^A STATEMENT WHICH DOES NOT CONSIST OF A CONTROL PHRASE AND A SCOPE IS
SAID TO BE A ^^SIMPLE STATEMENT\\. ^EXAMPLES OF SIMPLE STATEMENTS ARE
ASSIGNMENT STATEMENTS, SUBROUTINE ^^CALL\\S, ARITHMATIC ^^IF\\S, AND
^^GO TO\\S.
.TEST PAGE 5
.P
^THE PROBLEM WITH THE ^FORTRAN LOGICAL ^I^F STATEMENT IS THAT ITS SCOPE
MAY CONTAIN ONLY A SINGLE SIMPLE STATEMENT. ^THIS RESTRICTION IS
ELIMINATED IN THE CASE OF THE ^D^O, BUT AT THE COST OF CLERICAL
DETAIL (HAVING TO STOP THINKING ABOUT THE PROBLEM WHILE A STATEMENT
NUMBER IS INVENTED). ^NOTE ALSO THAT THE ^I^F SPECIFICATION IS ENCLOSED
IN PARENTHESES WHILE THE ^D^O SPECIFICATION IS NOT.
.TEST PAGE 5
.P
^IN ^FLECS THERE IS A UNIFORM CONVENTION FOR WRITING CONTROL PHRASES
AND INDICATING THEIR SCOPES. ^TO WRITE A STRUCTURED STATEMENT, THE
KEYWORD IS PLACED ON A LINE BEGINNING IN COLLUMN 7 FOLLOWED BY ITS
SPECIFICATION ENCLOSED IN PARENTHESES. ^THE REMAINDER OF THE LINE IS
LEFT BLANK. ^THE STATEMENTS COMPRISING THE SCOPE ARE PLACED ON SUCCESSIVE
LINES. ^THE END OF THE SCOPE IS INDICATED BY A ^^FIN\\ STATEMENT.
^THIS CREATES A ^^MULTI-LINE STRUCTURED STATEMENT.\\
.TEST PAGE 10
.BR
.SKIP
^EXAMPLES OF MULTI-LINE STRUCTURED STATEMENTS:
.SKIP
.BR
	^^IF (X .EQ. Y)
.BR
	.    U = V+W
.BR
	.   R = S+T
.BR
	...FIN
.BR
.SKIP
.BR
	DO (I = 1,N)
.BR
	.  A(I) = B(I)+C
.BR
	.  C = C*2.14 - 3.14
.BR
	...FIN
.BR
.SKIP
.BR
\\^NOTE:  THE STATEMENT NUMBER HAS BEEN ELIMINATED FROM THE ^^DO\\
SPECIFICATION SINCE IT IS NO LONGER NECESSARY, THE END OF THE LOOP
BEING SPECIFIED BY THE ^^FIN\\.
.SKIP 2
.BR
^NESTING OF STRUCTURED STATEMENTS IS PERMITTED TO ANY DEPTH.
.TEST PAGE 12
.SKIP
.BR
^EXAMPLE OF NESTED STRUCTURED STATEMENTS:
.SKIP
.BR
	^^IF (X .EQ. Y)
.BR
	.    U = V+W
.BR
	.    DO	(I = 1,N)
.BR
	.    . A(I) = B(I)+C
.BR
	.   . C = C*2.14 - 3.14
.BR
	.   ...FIN
.BR
	.   R = S+T
.BR
	...FIN\\
.BR
.TEST PAGE 10
.P
^WHEN THE SCOPE OF A CONTROL PHRASE CONSISTS OF A SINGLE ^^SIMPLE\\
STATEMENT, IT MAY BE PLACED ON THE SAME LINE AS THE CONTROL PHRASE
AND THE ^^FIN\\ MAY BE DISPENSED WITH. ^THIS CREATES A ^^ONE-LINE
STRUCTURED STATEMENT\\.
.SKIP
.BR
^EXAMPLES OF ONE-LINE STRUCTURED STATEMENTS:
.SKIP
.BR
	^^IF(X .EQ. Y)	U = V+W
.SKIP
.BR
	DO (I = 1,N)	A(I) = B(I)+C\\
.SKIP
.BR
.P
^SINCE EACH CONTROL PHRASE MUST BEGIN ON A NEW LINE, IT IS NOT POSSIBLE
TO HAVE A ONE-LINE STRUCTURED STATEMENT WHOSE SCOPE CONSISTS OF A
STRUCTURED STATEMENT.
.SKIP
.BR
^EXAMPLE OF AN INVALID CONSTRUCTION:
.BR
.SKIP
.BR
	^^IF (X .EQ. Y)  DO (I = 1,N)  A(I) = B(I)+C
.BR
.SKIP
\\^TO ACHIEVE THE ABOVE DESIRED EFFECT, THE ^^IF\\ MUST BE WRITTEN IN A
MULTI-LINE FORM.
.BR
.SKIP
^EXAMPLE OF A VALID CONSTRUCTION:
.BR
.SKIP
	^^IF (X .EQ. Y)
.BR
	.   DO  (I = 1,N) A(I) = B(I)+C
.BR
	...FIN\\
.BR
.TEST PAGE 5
.P
^IN ADDITION TO ^I^F AND ^D^O, ^FLECS PROVIDES SEVERAL USEFUL STRUCTURED
STATEMENTS NOT AVAILABLE IN ^FORTRAN. ^AFTER A BRIEF EXCURSION INTO THE
SUBJECT OF INDENTATION, WE WILL PRESENT THESE ADDITIONAL STRUCTURES.
.TEST PAGE 8
.INDEX 5.0 ^^INDENTATION
.SKIP
.BR
5.0  ^^INDENTATION, LINES AND THE LISTING\\
.BR
.P
^IN THE EXAMPLES OF MULTI-LINE STRUCTURED STATEMENTS ABOVE, THE STATEMENTS
IN THE SCOPE WERE INDENTED AND AN "^L" SHAPED LINE WAS DRAWN CONNECTING
THE KEYWORD OF THE CONTROL PHRASE TO THE MATCHING ^^FIN\\. ^THE
RESULTING GRAPHIC EFFECT HELPS TO REVEAL THE STRUCTURE OF THE PROGRAM.
^THE RULES FOR USING INDENTATION AND ^^FIN\\S ARE QUITE SIMPLE AND
UNIFORM. ^THE CONTROL PHRASE OF A MULTI-LINE STRUCTURED STATEMENT
ALWAYS CAUSES INDENTATION OF THE STATEMENTS THAT FOLLOW. ^NOTHING ELSE
CAUSES INDENTATION. ^A LEVEL OF INDENTATION (I. E. A SCOPE) IS ALWAYS
TERMINATED WITH A ^^FIN\\. ^NOTHING ELSE TERMINATES A LEVEL OF
INDENTATION.
.TEST PAGE 5
.P
^WHEN WRITING A ^FLECS PROGRAM ON PAPER THE PROGRAMMER SHOULD ADOPT
THE INDENTATION AND LINE DRAWING CONVENTIONS SHOWN BELOW. ^WHEN
PREPARING A ^FLECS SOURCE PROGRAM IN MACHINE READABLE FORM, HOWEVER,
EACH STATEMENT SHOULD BEGIN IN COLLUMN 7. ^WHEN THE ^FLECS
TRANSLATOR PRODUCES THE LISTING, IT WILL REINTRODUCE THE CORRECT
INDENTATION AND PRODUCE THE CORRESPONDING LINES. ^IF THE PROGRAMMER
ATTEMPTS TO INTRODUCE HIS OWN INDENTATION WITH THE USE OF LEADING
BLANKS, THE PROGRAM WILL BE TRANSLATED CORRECTLY, BUT THE RESULTING
LISTING WILL BE IMPROPERLY INDENTED.
.TEST PAGE 10
.SKIP
.BR
^EXAMPLE OF INDENTATION:
.BR
.SKIP
	1.	^PROGRAM AS WRITTEN ON PAPER BY PROGRAMMER
.BR
.SKIP
		^^IF (X .EQ. Y)
.BR
		.    U=V+W
.BR
		.    DO (I=1,N)
.BR
		.    .  A(I)=B(I)+C
.BR
		.    .  C=C*2.14-3.14
.BR
		.    ...^^FIN\\
.BR
		.    ^^R=S+T\\
.BR
		....^^FIN\\
.BR
.SKIP
	2.	^PROGRAM AS ENTERED INTO COMPUTER
.BR
.SKIP
		^^IF (X.EQ.Y)
.BR
		U = V+W
.BR
		DO (I = 1,N)
.BR
		A(I) = B(I)+C
.BR
		C = C*2.14-3.14
.BR
		FIN\\
.BR
	3.	^PROGRAM AS LISTED BY ^FLECS TRANSLATOR.
.BR
.SKIP
		^^IF (X.EQ.Y)
.BR
		.  U = V+W
.BR
		.  DO (I = 1,N)
.BR
		.  .  A(I) = B(I)+C
.BR
		.  .  C = C*2.14-3.14
.BR
		.  ...FIN
.BR
		.  R = S+T
.BR
		...FIN\\
.BR
.TEST PAGE 5
.P
^THE CORRECTLY INDENTED LISTING IS A TREMENDOUS AID IN READING AND WORKING
WITH PROGRAMS. ^EXCEPT FOR THE DOTS AND SPACES USED FOR INDENTATION, THE
LINES ARE LISTED EXACTLY AS THEY APPEAR IN THE SOURCE PROGRAM. ^THAT IS,
THE INTERNAL SPACING OF COLLUMNS 7-72 IS PRESERVED. ^THERE IS SELDOM
ANY NEED TO REFER TO A STRAIGHT LISTING OF THE UNINDENTED SOURCE.
.TEST PAGE 5
.P
^COMMENT LINES ARE TREATED IN THE FOLLOWING WAY ON THE LISTING TO PREVENT
INTERRUPTION OF THE DOTTED LINES INDICATING SCOPE. ^A COMMENT LINE WHICH
CONTAINS ONLY BLANKS IN COLLUMNS 2 THROUGH 6 WILL BE LISTED WITH
COLLUMNS 7 THROUGH 72 INDENTED AT THE THEN-CURRENT LEVEL OF INDENTATION
AS IF THE LINE WERE AN EXECUTABLE STATEMENT. ^IF, HOWEVER ONE OR MORE
NON-BLANK CHARACTERS APPEAR IN COLLUMNS 2 THROUGH 6 OF A COMMENT CARD,
IT WILL BE LISTED WITHOUT INDENTATION. ^BLANK LINES MAY BE INSERTED IN THE
SOURCE AND WILL BE TREATED AS EMPTY COMMENTS.
.TEST PAGE 10
.INDEX 6.0 ^^CONTROL STRUCTURES\\
.SKIP
.BR
.SKIP
6.0  ^^CONTROL STRUCTURES\\
.BR
.P
^THE COMPLETE SET OF CONTROL STRUCTURES PROVIDED BY ^FLECS IS GIVEN
BELOW. ^THE SYMBOL L IS USED TO INDICATE A LOGICAL EXPRESSION. ^THE
SYMBOL S IS USED TO INDICATE A SCOPE OF ONE OR MORE STATEMENTS.
^SOME STATEMENTS, AS INDICATED BELOW, DO NOT HAVE A ONE-LINE CONSTRUCTION.
.TEST PAGE 5
.INDEX 6.1 ^DECISION ^STRUCTURES
.SKIP
.BR
6.1  ^DECISION ^STRUCTURES
.BR
.P
^DECISION STRUCTURES ARE STRUCTURED STATEMENTS WHICH CONTROL THE
EXECUTION OF THEIR SCOPES ON THE BASIS OF A LOGICAL EXPRESSION OR
TEST.
.TEST PAGE 5
.INDEX 6.1.1 ^^IF\\
.SKIP
.BR
6.1.1  ^^IF\\
.BR
.P
^DESCRIPTION:  THE ^^IF\\ STATEMENT CAUSES A LOGICAL EXPRESSION TO
BE EVALUATED. ^IF THE VALUE IS TRUE, THE SCOPE IS EXECUTED ONCE AND
CONTROL PASSES TO THE NEXT STATEMENT. ^IF THE VALUE IS FALSE, CONTROL
PASSES DIRECTLY TO THE NEXT STATEMENT WITHOUT EXECUTION OF THE SCOPE.
.TEST PAGE 5
.SKIP
.BR
^GENERAL ^FORM:
.BR
.SKIP
	^^IF\\ (L)  S
.BR
.SKIP
^EXAMPLES:
.BR
.SKIP
	^^IF (X.EQ.Y) U = V+W
.BR
.SKIP
	IF (T.GT.0 .AND. S.LT.R)
.BR
	.  I = I+1
.BR
	.  Z= 0.1
.BR
	...FIN\\
.TEST PAGE 5
.INDEX  6.1.2 ^^UNLESS\\
.SKIP
.BR
6.1.2  ^^UNLESS\\
.BR
.P
^DESCRIPTION:  ^^"UNLESS\\ (L)"  IS FUNCTIONALLY EQUIVALENT TO
 "^^IF(.NOT.\\(L))", BUT IS MORE CONVENIENT IN SOME CONTEXTS.
.SKIP
.BR
^GENERAL ^FORM:
.BR
.SKIP
	^^UNLESS\\  (L)  S
.TEST PAGE 10
.BR
.SKIP
^EXAMPLES:
.BR
.SKIP
	^^UNLESS (X.NE.Y) U = V+W
.BR
.SKIP
	UNLESS (T.LE.0 .OR. S.GE.R)
.BR
	.  I = I+1
.BR
	.  Z = 0.1
.BR
	...FIN\\
.TEST PAGE 5
.INDEX 6.1.3 ^^WHEN...ELSE\\
.SKIP
.BR
6.1.3  ^^WHEN...ELSE\\
.P
^DESCRIPTION:  ^THE ^^WHEN...ELSE\\ STATEMENTS CORRESPOND TO THE
^^IF...THEN...ELSE\\ STATEMENTS OF ^^ALGOL, PL/1, PASCAL\\, ETC.
^IN ^FLECS, BOTH THE ^^WHEN\\ AND THE ^^ELSE\\ ACT AS STRUCTURED
STATEMENTS ALTHOUGH ONLY THE ^^WHEN\\ HAS A SPECIFICATION. ^THE
^^ELSE\\ STATEMENT MUST IMMEDIATELY FOLLOW THE SCOPE OF THE WHEN.
^THE SPECIFIER OF THE ^^WHEN\\ IS EVALUATED AND EXACTLY ONE OF
THE TWO SCOPES IS EXECUTED. ^THE SCOPE OF THE ^^WHEN\\ STATEMENT
IS EXECUTED IF THE EXPRESSION IS TRUE AND THE SCOPE OF THE ^^ELSE\\
STATEMENT IS EXECUTED IF THE EXPRESSION IS FALSE. ^IN EITHER CASE,
CONTROL THEN PASSES TO THE NEXT STATEMENT FOLLOWING THE ^^ELSE\\
STATEMENT.
.TEST PAGE 5
.SKIP
.BR
^GENERAL ^FORM:
.BR
.SKIP
	^^WHEN\\ (L)  S1
.BR
	^^ELSE\\  S2
.BR
.TEST PAGE 10
.SKIP
.BR
^EXAMPLES:
.BR
.SKIP
	^^WHEN (X.EQ.Y) U = V+W
.BR
	ELSE U = V-W
.BR
.SKIP
	WHEN (X.EQ.Y)
.BR
	.  U = V+W
.BR
	.  T = T+1.5
.BR
	...FIN
.BR
	ELSE U = V-W
.BR
.SKIP
	WHEN (X.EQ.Y) U = V+W
.BR
	ELSE
.BR
	.  U = V-W
.BR
	.  T = T+1.5
.BR
	...FIN
.BR
.SKIP
	WHEN (X.EQ.Y)
.BR
	.  U = V+W
.BR
	.  T = T-1.5
.BR
	...FIN
.BR
	ELSE
.BR
	.  U = V-W
.BR
	.  T = T+1.5
.BR
	...FIN\\
.BR
.TEST PAGE 5
.P
^NOTE:  ^^WHEN\\ AND ^^ELSE\\ ALWAYS COME AS A PAIR OF STATEMENTS, NEVER
SEPARATELY. ^EITHER THE ^^WHEN\\ OR THE ^^ELSE\\ OR BOTH MAY ASSUME THE
MULTI-LINE FORM. ^^ELSE\\ IS CONSIDERED TO BE A CONTROL PHRASE, HENCE
CANNOT BE PLACED ON THE SAME LINE AS THE ^^WHEN\\. ^THUS:
.BR
"^^WHEN\\ (L)  S1  ^^ELSE\\  S2 " IS ^^NOT\\ VALID.
.BR
.TEST PAGE 10
.INDEX 6.1.4 ^^CONDITIONAL\\
.SKIP
.BR
6.1.4  ^^CONDITIONAL\\
.BR
.P
^DESCRIPTION:  ^THE ^^CONDITIONAL\\ STATEMENT IS BASED ON THE ^^LISP\\
CONDITIONAL. ^A LIST OF LOGICAL EXPRESSIONS IS EVALUATED ONE BY ONE
UNTIL THE FIRST EXPRESSION TO BE TRUE IS ENCOUNTERED. ^THE SCOPE
CORRESPONDING TO THAT EXPRESSION IS EXECUTED, AND CONTROL THEN PASSES
TO THE FIRST STATEMENT FOLLOWING THE ^^CONDITIONAL\\. ^IF ALL EXPRESSIONS
ARE FALSE, NO SCOPE IS EXECUTED. (^SEE, HOWEVER, THE NOTE ABOUT
^^OTHERWISE\\ BELOW.)
.TEST PAGE 10
.SKIP
.BR
^GENERAL ^FORM:
.BR
.SKIP
	^^CONDITIONAL\\
.BR
	. (L1)  S1
.BR
	. (L2)  S2
.BR
	.  .    .
.BR
	.  .    .
.BR
	. (LN)  SN
.BR
	...^^FIN\\
.BR
.SKIP
.TEST PAGE 10
.BR
^EXAMPLES:
.BR
.SKIP
	^^CONDITIONAL
.BR
	.  (X.LT.-5.0) U = U+W
.BR
	.  (X.LE.1.0) U = U+W+Z
.BR
	.  (X.LE.10.5) U = U-Z
.BR
	...FIN
.BR
.SKIP
	CONDITIONAL
.BR
	.  (A.EQ.B) Z = 1.0
.BR
	.  (A.LE.C)
.BR
	.  .  Y = 2.0
.BR
	.  .  Z = 3.4
.BR
	.  ...FIN
.BR
	.  (A.GT.C .AND. A.LT.B) Z = 6.2
.BR
	.  (OTHERWISE) Z = 0.0
.BR
	...FIN\\
.BR
.SKIP
.TEST PAGE 5
.P
^NOTES:  ^THE ^^CONDITIONAL\\ ITSELF DOES NOT POSSESS A ONE-LINE FORM.
^HOWEVER, EACH "(LI) SI " IS TREATED AS A STRUCTURED STATEMENT AND MAY
BE IN ONE-LINE OR MULTI-LINE FORM.
.TEST PAGE 5
.P
^THE RESERVED WORD ^^OTHERWISE\\ REPRESENTS A CATCHALL CONDITION. THAT IS,
 "(^^OTHERWISE\\) SN " IS EQUIVALENT TO "(.^^TRUE\\.) SN " IN A 
^^CONDITIONAL\\ STATEMENT.
.TEST PAGE 10
.INDEX 6.1.5 ^^SELECT\\
.SKIP
.BR
6.1.5  ^^SELECT\\
.BR
.P
^DESCRIPTION: THE ^^SELECT\\ STATEMENT IS SIMILAR TO THE ^^CONDITIONAL\\
BUT IS MORE SPECIALIZED. ^IT ALLOWS AN EXPRESSION TO BE TESTED FOR
EQUALITY TO EACH EXPRESSION IN A LIST OF EXPRESSIONS. ^WHEN THE FIRST
MATCHING EXPRESSION IS ENCOUNTERED, A CORRESPONDING SCOPE IS EXECUTED
AND THE ^^SELECT\\ STATEMENT TERMINATES. ^IN THE DESCRIPTION BELOW,
 E, E1,...EN REPRESENT ARBITRARY BUT COMPATIBLE EXPRESSIONS. ^ANY TYPE
OF EXPRESSION (INTEGER, REAL, COMPLEX,...) IS ALLOWED AS LONG AS THE
UNDERLYING ^FORTRAN SYSTEM ALLOWS SUCH EXPRESSIONS TO BE COMPARED WITH
AN .^^EQ\\. OR ^^.NE\\. OPERATOR.
.TEST PAGE 10
.SKIP
.BR
^GENERAL ^FORM:
.BR
.SKIP
	^^SELECT\\ (E)
.BR
	.  (E1)  S1
.BR
	.  (E2)  S2
.BR
	.   .    .
.BR
	.   .    .
.BR
	.  (EN)  SN
.BR
	...^^FIN\\
.TEST PAGE 10
.SKIP
.BR
^EXAMPLE:
.BR
.SKIP
	^^SELECT (OPCODE(PC))
.BR
	.  (JUMP)  PC = AD
.BR
	.  (ADD)
.BR
	.  .  A = A+B
.BR
	.  .  PC = PC+1
.BR
	.  ...FIN
.BR
	.  (SKIP)  PC = PC+2
.BR
	.  (STOP)  CALL STOPCD
.BR
	...FIN\\
.BR
.SKIP
.TEST PAGE 3
.P
^NOTES:  ^AS IN THE CASE OF ^^CONDITIONAL\\, AT MOST ONE OF THE SI WILL
BE EXECUTED.
.TEST PAGE 4
.P
^THE CATCHALL ^^OTHERWISE\\ MAY ALSO BE USED IN A ^^SELECT\\ STATEMENT.
^THUS "(^^OTHERWISE\\) SN " IS EQUIVALENT TO "(E) SN " WITHIN A
"^^SELECT\\ (E)" STATEMENT.
.TEST PAGE 5
.P
^THE  EXPRESSION "E" IS REEVALUATED FOR EACH COMPARISON IN THE LIST, THUS
LENGTHY, TIME CONSUMING, OR IRREPRODUCIBLE EXPRESSIONS SHOULD BE
PRECOMPUTED, ASSIGNED TO A VARIABLE, AND THE VARIABLE USED IN THE
SPECIFICATION PORTION OF THE ^^SELECT\\ STATEMENT.
.TEST PAGE 10
.INDEX 6.2 ^^LOOP\\ ^STRUCTURES
.SKIP
.BR
6.2  ^^LOOP\\ ^STRUCTURES
.BR
.P
^THE STRUCTURED STATEMENTS DESCRIBED BELOW ALL HAVE A SCOPE WHICH IS
EXECUTED A VARIABLE NUMBER OF TIMES DEPENDING ON SPECIFIED CONDITIONS.
.P
^OF THE FIVE LOOPS PRESENTED THE MOST USEFUL ARE THE ^^DO, WHILE\\, AND
AND ^^REPEAT UNTIL\\ LOOPS. ^TO AVOID CONFUSION, THE ^^REPEAT WHILE\\
AND ^^UNTIL\\ LOOPS SHOULD INITIALLY BE IGNORED.
.TEST PAGE 10
.INDEX 6.2.1 ^D^O
.SKIP
.BR
6.2.1  ^D^O
.BR
.P
^DESCRIPTION:  THE ^FLECS ^D^O LOOP IS FUNCTIONALLY IDENTICAL TO THE
^FORTRAN ^D^O LOOP. ^THE ONLY DIFFERENCES ARE SYNTACTIC. ^IN THE
^FLECS ^D^O LOOP, THE STATEMENT NUMBER IS OMITTED FROM THE ^D^O
STATEMENT, THE INCREMENTATION PARAMETERS ARE ENCLOSED IN PARENTHESES,
AND THE SCOPE IS INDICATED BY EITHER THE ONE-LINE OR MULTI-LINE
CONVENTION.  ^THE SYMBOL I REPRESENTS ANY LEGAL INCREMENTATION
SPECIFICATION.
.TEST PAGE 5
.SKIP
.BR
^GENERAL ^FORM:
.BR
.SKIP
	^D^O (I) S
.BR
.SKIP
.TEST PAGE 10
^EXAMPLES:
.BR
.SKIP
	^^DO (I = 1,N) A(I) = 0.0
.BR
.SKIP
	DO (J = 3,K,3)
.BR
	.  B(J) = B(J-1)*B(J-2)
.BR
	.  C(J) = SIN(B(J))
.BR
	...FIN\\
.BR
.TEST PAGE 5
.INDEX 6.2.2 ^^WHILE\\
.SKIP
.BR
6.2.2  ^^WHILE\\
.BR
.P
^DESCRIPTION:  THE ^^WHILE\\ LOOP CAUSES ITS SCOPE TO BE REPEATEDLY
EXECUTED WHILE A SPECIFIED  CONDITION IS TRUE. ^THE CONDITION IS CHECKED
PRIOR TO THE FIRST EXECUTION OF THE SCOPE, THUS IF THE CONDITION IS
INITIALLY FALSE THE SCOPE WILL NOT BE EXECUTED AT ALL.
.TEST PAGE 5
.SKIP
.BR
^GENERAL ^FORM:
.BR
.SKIP
	^^WHILE\\ (L) S
.BR
.TEST PAGE 10
.SKIP
^EXAMPLES:
.BR
.SKIP
	^^WHILE (X.LT.A(I)) I = I+1
.BR
.SKIP
	WHILE (P.NE.0)
.BR
	.  VAL(P) = VAL(P)+1
.BR
	.  P = LINK(P)
.BR
	...FIN\\
.BR
.SKIP
.TEST PAGE 5
.INDEX 6.2.3 ^^REPEAT WHILE\\
.SKIP
.BR
6.2.3  ^^REPEAT WHILE\\
.BR
.P
^DESCRIPTION:  ^BY USING THE ^^REPEAT\\ VERB, THE TEST CAN BE LOGICALLY
MOVED TO THE END OF THE LOOP. ^THE ^^REPEAT WHILE\\ LOOP CAUSES ITS
SCOPE TO BE REPEATEDLY EXECUTED WHILE A SPECIFIED CONDITION REMAINS
TRUE. ^THE CONDITION IS NOT CHECKED UNTIL AFTER THE FIRST EXECUTION
OF THE SCOPE. ^THUS THE SCOPE WILL ALWAYS BE EXECUTED AT LEAST ONCE
AND THE CONDITION INDICATES UNDER WHAT CONDITIONS THE SCOPE IS TO BE
REPEATED. ^NOTE:  "^^REPEAT WHILE\\(L)" IS FUNCTIONALLY EQUIVALENT TO
"^^REPEAT UNTIL(.NOT.\\(L))".
.TEST PAGE 5
.SKIP
.BR
^GENERAL ^FORM:
.BR
.SKIP
	^^REPEAT WHILE\\ (L) S
.BR
.SKIP
.TEST PAGE 10
.BR
^EXAMPLES:
.BR
.SKIP
	^^REPEAT WHILE(N.EQ.M(I)) I = I+1
.BR
.SKIP
	REPEAT WHILE (LINK(Q).NE.0)
.BR
	.  R = LINK(Q)
.BR
	.  LINK(Q) = P
.BR
	.  P = Q
	.  Q = R
.BR
	...FIN\\
.TEST PAGE 5
.INDEX 6.2.4 ^^UNTIL\\
.SKIP
.BR
6.2.4  ^^UNTIL\\
.BR
.P
^DESCRIPTION:  ^THE ^^UNTIL\\ LOOP CAUSES ITS SCOPE TO BE REPEATEDLY
EXECUTED UNTIL A SPECIFIED CONDITION BECOMES TRUE. ^THE CONDITION IS
CHECKED PRIOR TO THE FIRST EXECUTION OF THE SCOPE, THUS IF THE CONDITION
IS INITIALLY TRUE, THE SCOPE WILL NOT BE EXECUTED AT ALL. ^NOTE THAT
"^^UNTIL\\ (L)" IS FUNCTIONALLY EQUIVALENT TO "^^WHILE (.NOT.\\(L))".
.TEST PAGE 5
.SKIP
.BR
^GENERAL ^FORM:
.BR
.SKIP
	^^UNTIL\\ (L) S
.BR
.SKIP
.TEST PAGE 10
.BR
^EXAMPLES:
.BR
.SKIP
	^^UNTIL (X.EQ.A(I)) I = I+1
.BR
.SKIP
	UNTIL (P.EQ.0)
.BR
	.  VAL(P) = VAL(P)+1
.BR
	.  P = LINK(P)
.BR
	...FIN\\
.BR
.SKIP
.TEST PAGE 5
.INDEX 6.2.5 ^^REPEAT UNTIL\\
.SKIP
.BR
6.2.5  ^^REPEAT UNTIL\\
.BR
.P
^DESCRIPTION:  ^BY USING THE ^^REPEAT\\ VERB, THE TEST CAN BE LOGICALLY
MOVED TO THE END OF THE LOOP. ^THE ^^REPEAT UNTIL\\ LOOP CAUESE ITS
SCOPE TO BE REPEATEDLY EXECUTED UNTIL A SPECIFIED CONDITION BECOMES
TRUE. ^THE CONDITION IS NOT CHECKED UNTIL AFTER THE FIRST EXECUTION
OF THE SCOPE. ^THUS THE SCOPE WILL ALWAYS BE EXECUTED AT LEAST ONCE AND
THE CONDITION INDICATES UNDER WHAT CIRCUMSTANCES THE ^^REPETITION\\
OF THE SCOPE IS TO BE TERMINATED.
.TEST PAGE 5
.SKIP
.BR
^GENERAL ^FORM:
.BR
.SKIP
	^^REPEAT UNTIL\\ (L) S
.BR
.SKIP
.TEST PAGE 10
^EXAMPLES:
.BR
.SKIP
	^^REPEAT UNTIL (N.EQ.M(I)) I = I+1
.BR
.SKIP
	REPEAT UNTIL (LINK(Q).EQ.0)
.BR
	.  R = LINK(Q)
.BR
	.  LINK(Q) = P
.BR
	.  P = Q
.BR
	.  Q = R
.BR
	...FIN
.BR
.TEST PAGE 5
.INDEX 7.0 ^^INTERNAL PROCEDURES\\
.SKIP
.BR
7.0  ^^INTERNAL PROCEDURES\\
.BR
.P
^IN ^FLECS A SEQUENCE OF STATEMENTS MAY BE DECLARED AN ^^INTERNAL PROCEDURE\\
AND GIVEN A NAME. ^THE PROCEDURE MAY THEN BE INVOKED FROM ANY POINT IN THE
PROGRAM BY SIMPLY GIVING ITS NAME.
.TEST PAGE 5
.P
^^PROCEDURE NAMES\\ MAY BE ANY STRING OF LETTERS, DIGITS, AND HYPHENS
(I.E. MINUS SIGNS) BEGINNING WITH A LETTER AND CONTAINING AT LEAST ONE
HYPHEN. ^INTERNAL BLANKS ARE NOT ALLOWED. ^THE ONLY RESTRICTION ON THE
LENGTH OF A NAME IS THAT IT MAY NOT BE CONTINUED ONTO A SECOND LINE.
.TEST PAGE 10
.SKIP
.BR
^EXAMPLES OF VALID INTERNAL PROCEDURE NAMES:
.BR
.SKIP
	^^INITIALIZE-ARRAYS
.BR
	GIVE-WARNING
.BR
	SORT-INTO-DESCENDING-ORDER
.BR
	INITIATE-PHASE-3\\
.BR
.SKIP
.TEST PAGE 5
.P
^A ^^PROCEDURE DECLARATION\\ CONSISTS OF THE KEYWORD "^^TO\\" FOLLOWED BY
THE PROCEDURE NAME AND ITS SCOPE. ^THE SET OF STATEMENTS COMPRISING THE
PROCEDURE IS CALLED ITS SCOPE. ^IF THE SCOPE CONSISTS OF A SINGLE SIMPLE
STATEMENT IT MAY BE PLACED ON THE SAME LINE AS THE "^^TO\\" AND PROCEDURE
NAME, OTHERWISE THE STATEMENTS OF THE SCOPE ARE PLACED ON THE FOLLOWING
LINES AND TERMINATED WITH A ^^FIN\\ STATEMENT. ^THESE RULES ARE ANALOGOUS
TO THE RULES FOR FORMING THE SCOPE OF A STRUCTURED STATEMENT.
.TEST PAGE 5
.SKIP
.BR
^GENERAL ^FORM OF PROCEDURE DECLARATION:
.BR
.SKIP
	^^TO\\ PROCEDURE-NAME
.BR
.SKIP
.TEST PAGE 10
^EXAMPLES OF PROCEDURE DECLARATIONS:
.BR
.SKIP
	^^TO RESET-POINTER P = 0
.BR
.SKIP
	TO DO-NOTHING CONTINUE
.BR
.SKIP
	TO SUMMARIZE-FILE
.BR
	.  INITIALIZE-SUMMARY
.BR
	.  OPEN-FILE
.BR
	.  REPEAT UNTIL (EOF)
.BR
	.  .  ATTEMPT-TO-READ-RECORD
.BR
	.  .  WHEN (EOF) CLOSE-FILE
.BR
	.  .  ELSE UPDATE-SUMMARY
.BR
	.  ...FIN
.BR
	.  OUTPUT-SUMMARY
.BR
	...FIN\\
.P
^AN ^^INTERNAL PROCEDURE REFERENCE\\ IS A PROCEDURE NAME APPEARING WHERE
AN EXECUTABLE STATEMENT WOULD BE EXPECTED. ^IN FACT AN INTERNAL PROCEDURE
REFERENCE IS AN EXECUTABLE SIMPLE STATEMENT AND THUS MAY BE USED IN THE
SCOPE OF A STRUCTURED STATEMENT AS IN THE LAST EXAMPLE ABOVE. ^WHEN
CONTROL REACHES A PROCEDURE REFERENCE DURING EXECUTION OF A ^FLECS
PROGRAM, A RETURN ADDRESS IS SAVED AND CONTROL IS TRANSFERRED TO THE FIRST
STATEMENT IN THE SCOPE OF THE PROCEDURE. ^WHEN CONTROL REACHES THE END
OF THE SCOPE, CONTROL IS TRANSFERRED BACK TO THE STATEMENT LOGICALLY
FOLLOWING THE PROCEDURE REFERENCE.
.TEST PAGE 5
.P
^A TYPICAL ^FLECS PROGRAM OR SUBPROGRAM CONSISTS OF A SEQUENCE OF ^FORTRAN
DECLARATIONS (E.G. ^^INTEGER, DIMENSION, COMMON\\, ETC.) FOLLOWED BY A
SEQUENCE OF EXECUTABLE STATEMENTS CALLED THE BODY OF THE PROGRAM FOLLOWED
BY THE ^FLECS INTERNAL PROCEDURE DECLARATIONS, IF ANY, AND FINALLY THE
^^END\\ STATEMENT.
.TEST PAGE 10
.P
^HERE IS A COMPLETE (BUT UNINTERESTING) ^FLECS PROGRAM WHICH ILLUSTRATES
THE PLACEMENT OF THE PROCEDURE DECLARATIONS.
.NO JUSTIFY
.NO FILL
.SKIP
0010 ^^C INTERACTIVE PROGRAM FOR PDP-11 TO COMPUTE X**2.
0020 C 0 IS USED AS A SENTINEL VALUE TO TERMINATE EXECUTION.
0030		REAL X,XSQ
0040		REPEAT UNTIL (X.EQ.0)
0050		.  GET-A-VALUE-OF-X
0060		.  IF (X.NE.0)
0070		.  .  COMPUTE-RESULT
0080		.  .  TYPE-RESULT
0090		.  ...FIN
0100		...FIN
0110		CALL EXIT
.SKIP
    ----------------------------------------------
.SKIP
0120		TO GET-A-VALUE-OF-X
0130		.  TYPE 10
0140 10 		.  FORMAT (' X = ',$)
0150		.  ACCEPT 20,X
0160 20		.  FORMAT (F)
0170		...FIN
.SKIP
	----------------------------------------------
.SKIP
0180		TO COMPUTE-RESULT XSQ = X*X
.SKIP
	----------------------------------------------
.SKIP
0190		TO TYPE-RESULT
0200		.  TYPE 30, XSQ
0210 30		.  FORMAT(' X-SQUARED = ',F7.2)
0220		...FIN
0230		END\\
.PAGE
.FILL
.JUSTIFY
.BR
^NOTES CONCERNING INTERNAL PROCEDURES:
.BR
.SKIP
1.  ^ALL INTERNAL PROCEDURE DECLARATIONS MUST BE PLACED AT THE END OF THE
PROGRAM JUST PRIOR TO THE ^^END\\ STATEMENT. ^THE APPEARENCE OF THE FIRST
"^^TO\\" STATEMENT TERMINATES THE BODY OF THE PROGRAM. ^THE TRANSLATOR
EXPECTS TO SEE NOTHING BUT PROCEDURE DECLARATIONS FORM THAT POINT ON.
.SKIP
2.  ^THE ORDER OF THE DECLARATIONS IS NOT IMPORTANT. ^ALPHABETICAL BY NAME
IS AN EXCELLENT ORDER FOR PROGRAMS WITH A LARGE NUMBER OF PROCEDURES.
.SKIP
3.  ^PROCEDURE DECLARATIONS MAY NOT BE NESTED. ^IN OTHER WORDS, THE SCOPE
OF A PROCEDURE MAY NOT CONTAIN A PROCEDURE DECLARATION. ^IT MAY OF COURSE
CONTAIN EXECUTABLE PROCEDURE REFERENCES.
.SKIP
4.  ^ANY PROCEDURE MAY CONTAIN REFERENCES TO ANY OTHER PROCEDURES
(EXCLUDING ITSELF).
.SKIP
5.  ^DYNAMIC RECURSION OF PROCEDURE REFERENCING IS NOT PERMITTED.
.SKIP
6.  ^ALL PROGRAM VARIABLES WITHIN A MAIN OR SUBPROGRAM ARE GLOBAL
AND ARE ACCESSABLE TO THE STATEMENTS IN ALL PROCEDURES DECLARED
WITHIN THAT SAME MAIN OR SUB PROGRAM.
.SKIP
7.  ^THERE IS NO FORMAL MECHANISM FOR DEFINING OR PASSING PARAMETERS
TO AN INTERNAL PROCEDURE. ^WHEN PARAMETER PASSING IS NEEDED, THE
^FORTRAN FUNCTION OR SUBROUTINE SUBPROGRAM MECHANISM MAY BE USED OR THE
PROGRAMMER MAY INVENT HIS OWN PARAMETER PASSING METHODS USING THE
GLOBAL NATURE OF VARIABLES OVER INTERNAL PROCEDURES.
.SKIP
8.  ^THE ^FLECS TRANSLATOR SEPARATES PROCEDURE DECLARATIONS ON THE LISTING
BY DASHED LINES AS SHOWN IN THE PRECEDING EXAMPLE.
.PAGE
.INDEX 8.0 ^^RESTRICTIONS AND NOTES\\
.BR
8.0  ^^RESTRICTIONS AND NOTES\\
.BR
.P
^IF ^FLECS WERE IMPLEMENTED BY A NICE INTELLIGENT COMPILER THIS SECTION
WOULD BE MUCH SHORTER. ^CURRENTLY, HOWEVER, ^FLECS IS IMPLEMENTED BY
A STURDY BUT NAIVE TRANSLATOR. ^THUS THE ^FLECS PROGRAMMER MUST OBSERVE
THE FOLLOWING RESTRICTIONS.
.SKIP
1.  ^FLECS MUST INVENT MANY STATEMENT NUMBERS IN CREATING THE ^FORTRAN
PROGRAM. ^IT DOES SO BY BEGINNING WITH A LARGE NUMBER (USUALLY 99999)
AND GENERATING SUCCESSIVELY SMALLER NUMBERS AS IT NEEDS THEM. ^DO NOT
USE A NUMBER WHICH WILL BE GENERATED BY THE TRANSLATOR. ^A GOOD RULE
OF THUMB IS TO ^^AVOID USING 5 DIGIT STATEMENT NUMBERS\\.
.SKIP
2.  ^THE ^FLECS TRANSLATOR MUST GENERATE INTEGER VARIABLE NAMES. ^IT
DOES SO BY USING NAMES OF THE FORM "^INNNNN" WHERE NNNNN IS A 5 DIGIT
NUMBER RELATED TO A GENERATED STATEMENT NUMBER. ^^DO NOT USE VARIABLES
OF THE FORM I\\NNNNN ^^AND AVOID CAUSING THEM TO BE DECLARED OTHER THAN
INTEGERS\\. ^FOR EXAMPLE, THE DECLARATION "^^IMPLICIT REAL (A-Z\\)""
LEADS TO TROUBLE. ^TRY "^^IMPLICIT REAL (A-H,J-Z\\)" INSTEAD.
.SKIP
3.  ^THE TRANSLATOR DOES NOT RECOGNIZE CONTINUATION LINES IN THE SOURCE
FILE. ^THUS ^FORTRAN STATEMENTS MAY BE CONTINUED SINCE THE STATEMENT AND
ITS CONTINUATIONS WILL BE PASSED THROUGH THE TRANSLATOR WITHOUT ALTERATION
(SEE SECTION 2.). ^HOWEVER, ^^AN EXTENDED FLECS STATEMENT WHICH REQUIRES
TRANSLATION MAY NOT BE CONTINUED\\. ^THE REASONS ONE MIGHT WISH TO CONTINUE
A ^FLECS STATEMENT ARE:  1) ^IT IS A STRUCTURED STATEMENT OR PROCEDURE
DECLARATION WITH A ONE STATEMENT SCOPE TOO LONG TO FIT ON A LINE; 2) IT
CONTAINS AN EXCESSIVELY LONG SPECIFICATION PORTION; OR 3) BOTH OF THE
ABOVE. ^PROBLEM 1 CAN BE AVOIDED BY GOING TO THE MULTI-LINE FORM.
^FREQUENTLY PROBLEM 2 CAN BE AVOIDED WHEN THE SPECIFICATION IS AN EXPRESSION
(LOGICAL OR OTHERWISE) BY ASSIGNING THE EXPRESSION TO A VARIABLE IN A
PRECEDING STATEMENT AND THEN USING THE VARIABLE AS THE SPECIFICATION.
.SKIP
4.  ^^BLANKS ARE MEANINGFUL SEPARATORS IN FLECS STATEMENTS: DO NOT PUT
THEM IN DUMB PLACES\\ LIKE THE MIDDLE OF IDENTIFIERS OR KEY WORDS AND ^D^O
USE THEM TO SEPARATE DISTINCT WORDS LIKE ^^REPEAT\\ AND ^^UNTIL\\.
.TEST PAGE 5
.SKIP
5.  ^LET ^FLECS INDENT THE LISTING. ^^START ALL STATEMENTS IN COLLUMN\\
7 AND THE LISTING WILL ALWAYS REVEAL THE TRUE STRUCTURE OF THE PROGRAM
(AS UNDERSTOOD BY THE TRANSLATOR, OF COURSE).
.TEST PAGE 5
.SKIP
6.  ^AS FAR AS THE TRANSLATOR IS CONCERNED, ^^FORMAT\\ STATEMENTS ARE
EXECUTABLE ^FORTRAN STATEMENTS SINCE ^FLECS DOESN'T RECOGNIZE THEM AS
EXTENDED ^FLECS STATEMENTS. ^THUS ^^ONLY PLACE FORMAT STATEMENTS WHERE
AN EXECUTABLE FORTRAN STATEMENT WOULD BE ACCEPTABLE\\. ^DO NOT PUT
THEM BETWEEN THE END OF A ^^WHEN\\ STATEMENT  AND THE BEGINNING OF AN
^^ELSE\\ STATEMENT. ^DO NOT PUT THEM BETWEEN PROCEDURE DECLARATIONS.
.SKIP
.TEST PAGE 10
.NO FILL
.NO JUSTIFY
^INCORRECT EXAMPLES:		^CORRECT EXAMPLES:
.SKIP
	^^WHEN (FLAG) WRITE(3,30)		WHEN (FLAG)
30	FORMAT(7H TITLE:)			.  WRITE(3,30)
	ELSE LINE = LINE+1		30	.  FORMAT(7H TITLE:)
						...FIN
						ELSE LINE = LINE+1
.SKIP
	TO WRITE-HEADER				TO WRITE-HEADER
	.  PAGE = PAGE+1			.  PAGE = PAGE+1
	.  WRITE(3,40)H,PAGE			.  WRITE(3,40)H,PAGE
	...FIN				40	.  FORMAT(70A1,I3)
40	FORMAT(70A1,I3)				...FIN\\
.SKIP
.FILL
.JUSTIFY
.TEST PAGE 5
7.  ^THE TRANSLATOR, BEING SIMPLE-MINDED, RECOGNIZES EXTENDED ^FLECS
STATEMENTS BY THE PROCESS OF SCANNING THE FIRST IDENTIFIER ON THE LINE.
^IF THE IDENTIFIER IS ONE OF THE ^FLECS KEYWORDS ^^IF, WHEN, UNLESS,
FIN\\, ETC., THE LINE IS ASSUMED TO BE A ^FLECS STATEMENT AND IS TREATED
AS SUCH. ^THUS THE ^^FLECS KEYWORDS ARE RESERVED AND MAY NOT BE USED AS
VARIABLE NAMES\\. ^IN CASE OF NECESSITY, A VARIABLE NAME, LIKE ^^WHEN\\,
MAY BE SLIPPED PAST THE TRANSLATOR BY EMBEDDING A BLANK WITHIN IT. ^THUS
"^^WH EN\\" WILL LOOK LIKE "^^WH\\" FOLLOWED BY "^^EN\\" TO THE TRANSLATOR
WHICH IS BLANK SENSITIVE, BUT LIKE "^^WHEN\\" TO THE COMPILER WHICH
IGNORES BLANKS.
.TEST PAGE 5
.SKIP
8.  ^IN SCANNING A PARENTHESIZED SPECIFICATION, THE TRANSLATOR SCANS FROM
LEFT TO RIGHT TO FIND THE PARENTHESIS WHICH MATCHES THE INITIAL LEFT
PARENTHESIS OF THE SPECIFICATION. ^THE TRANSLATOR, HOWEVER, IS IGNORANT
OF ^FORTRAN SYNTAX INCLUDING THE CONCEPT OF ^HOLLERITH CONSTANTS AND WILL
TREAT ^HOLLERITH PARENTHESES AS SYNTACTIC PARENTHESES. ^THUS, ^^AVOID
PLACING HOLLERITH CONSTANTS CONTAINING UNBALANCED PARENTHESES WHITHIN
SPECIFICATIONS\\. ^IF NECESSARY, ASSIGN SUCH CONSTANTS TO A VARIABLE, USING
A ^^DATA\\ OR ASSIGNMENT STATEMENT, AND PLACE THE VARIABLE IN THE
SPECIFICATION.
.TEST PAGE 5
.SKIP
.NO FILL
.NO JUSTIFY
^INCORRECT EXAMPLE:			^CORRECT EXAMPLE
.SKIP
^^IF (J.EQ.'(')			LP = '('
					IF(J.EQ.LP)\\
.SKIP
.FILL
.JUSTIFY
.TEST PAGE 5
9.  ^THE ^FLECS TRANSLATOR WILL NOT SUPPLY THE STATEMENTS NECESSARY
TO CAUSE APPROPRIATE TERMINATION OF MAIN AND SUB-PROGRAMS. ^THUS IT
IS ^^NECESSARY TO INCLUDE THE APPROPRIATE RETURN, STOP, OR CALL EXIT
STATEMENTS PRIOR TO THE FIRST INTERNAL PROCEDURE DECLARATION\\. ^FAILURE
TO DO SO WILL RESULT IN CONTROL ENTERING THE SCOPE OF THE FIRST PROCEDURE
AFTER ELAVING THE BODY OF THE PROGRAM. ^DO NOT PLACE SUCH STATEMENTS
BETWEEN THE PROCEDURE DECLARATION AND THE ^^END\\ STATEMENT.
.TEST PAGE 5
.INDEX 9.0 ^^ERRORS\\
.SKIP
.BR
9.0  ^^ERRORS\\
.BR
.P
^THIS SECTION PROVIDES A FRAMEWORK FOR UNDERSTANDING THE ERROR HANDLING
MECHANISMS OF VERSION 22 OF THE ^FLECS ^TRANSLATOR. ^THE SYSTEM DESCRIBED
BELOW IS AT AN EARLY POINT IN EVOLUTION, BUT HAS PROVEN TO BE QUITE
WORKABLE.
.TEST PAGE 5
.P
^THE ^FLECS TRANSLATOR EXAMINES A ^FLECS PROGRAM ON A LINE BY LINE BASIS.
^AS EACH LINE IS ENCOUNTERED IT IS FIRST SUBJECTED TO A LIMITED ^^SYNTAX\\
ANALYSIS FOLLOWED BY A ^^CONTEXT\\ ANALYSIS. ^ERRORS MAY BE DETECTED DURING
EITHER OF THESE ANALYSES. ^IT IS ALSO POSSIBLE TO ERRORS TO GO UNDETECTED
BY THE TRANSLATOR.
.TEST PAGE 5
.INDEX 9.1 ^SYNTAX ^ERRORS
.SKIP
.BR
9.1  ^SYNTAX ^ERRORS
.BR
.P
^WHEN A SYNTAX ERROR IS DETECTED BY THE TRANSLATOR, IT ^^IGNORES THE
STATEMENT\\. ^ON THE ^FLECS LISTING THE LINE NUMBER OF THE STATEMENT
IS OVERPRINTED WITH -'S TO INDICATE THAT THE STATEMENT HAS BEEN
IGNORED. ^THE NATURE OF THE SYNTAX ERROR IS GIVEN IN A MESSAGE ON THE
FOLLOWING LINE.
.TEST PAGE 5
.P
^THE FACT THAT A STATEMENT HAS BEEN IGNORED MAY, OF COURSE, CAUSE SOME
CONTEXT ERRORS IN LATER STATEMENTS. ^FOR EXAMPLE, THE CONTROL PHRASE
"^^WHEN (X(I).LT.(3+4)\\" HAS A MISSING RIGHT PARENTHESIS. ^THIS
STATEMENT WILL BE IGNORED, CAUSING AS A MINIMUM THE FOLLOWING ^^ELSE\\
TO BE OUT OF CONTEXT. ^THE PROGRAMMER SHOULD OF COURSE BE AWARE OF
SUCH EFFECTS. ^MORE IS SAID ABOUT THEM IN THE NEXT SECTION.
.TEST PAGE 5
.INDEX 9.2 ^CONTEXT ^ERRORS
.SKIP
.BR
9.2  ^CONTEXT ^ERRORS
.BR
.P
^IF A STATEMENT SUCCESSFULLY PASSES THE SYNTAX ANALYSIS, IT IS CHECKED
TO SEE IF IT IS IN THE APPROPRIATE CONTEXT WITHIN THE PROGRAM. ^FOR
EXAMPLE AN ^^ELSE\\ MUST APPEAR FOLLOWING A ^^WHEN\\ AND NOWHERE ELSE.
^IF AN ^^ELSE\\ DOES NOT APPEAR AT THE APPROPRIATE POINT OR IF IT
APPEARS AT SOME OTHER POINT, THEN A CONTEXT ERROR HAS OCCURRED.
^A FREQUENT SOURCE OF CONTEXT ERROR IN THE INITIAL STAGES OF DEVELOPEMENT
OF A PROGRAM COMES FROM MISCOUNTING THE NUMBER OF ^^FIN\\'S NEEDED AT
SOME POINT IN THE PROGRAM.
.TEST PAGE 5
.P
^WHITH THE EXCEPTION OF EXCESS ^^FIN\\'S WHICH DO NOT MATCH ANY PRECEDING
CONTROL PHRASE AND ARE IGNORED (AS INDICATED BY OVERPRINTING THE LINE
NUMBER), ALL CONTEXT ERRORS ARE TREATED WITH A UNIFORM STRATEGY. ^WHEN AN
OUT-OF-CONTEXT SOURCE STATEMENT IS ENCOUNTERED, THE TRANSLATOR GENERATES
A "^^STATEMENT(S) NEEDED\\" MESSAGE. ^IT THEN INVENTS AND PROCESSES A
SEQUENCE OF STATEMENTS WHICH, IF THEY HAD BEEN INCLUDED AT THAT POINT IN
THE PROGRAM. WOULD HAVE PLACED THE ORIGINAL SOURCE STATEMENT IN A CORRECT
CONTEXT. ^A MESSAGE IS GIVEN FOR EACH SUCH STATEMENT INVENTED. ^THE ORIGINAL
SOURCE STATEMENT IS THEN PROCESSED IN THE NEWLY CREATED CONTEXT.
.TEST PAGE 5
.P
^BY INVENTING STATEMENTS THE TRANSLATOR IS NOT TRYING TO PATCH UP THE
PROGRAM SO THAT IT WILL RUN CORRECTLY, IT IS SIMPLY TRYING TO ADJUST THE
LOCAL CONTEXT SO THAT THE ORIGINAL SOURCE STATEMENT AND THE STATEMENTS
WHICH FOLLOW WOULD BE ACCEPTABLE ON A CONTEXT BASIS. ^AS IN THE CASE OF
CONTEXT ERRORS GENERATED BY IGNORING A SYNTACTICALLY INCORRECT STATEMENT,
SUCH AN ADJUSTMENT OF CONTEXT FREQUENTLY CAUSES FURTHER CONTEXT ERRORS
LATER ON. ^THIS IS CALLED ^^PROPAGATION OF CONTEXT ERRORS\\.
.P
^ONE NICE FEATURE OF THE CONTEXT ADJUSTMENT STRATEGY IS THAT CONTEXT ERRORS
CANNOT PROPAGATE PAST A RECOGNIZABLE PROCEDURE DECLARATION. ^THIS IS BECAUSE
THE "^^TO\\" DECLARATION IS IN CONTEXT ONLY AT INDENTENTATION LEVEL 0.
^THUS TO PLACE IT IN CONTEXT, THE TRANSLATOR MUST INVENT ENOUGH STATEMENTS
TO TERMINATE ALL OPEN CONTROL STRUCTURES WHICH PRECEDE THE "^^TO\\".
^THE PROGRAMMER WHO MODULARIZES HIS PROGRAM INTO A COLLECTION OF
RELATIVELY SHORT INTERNAL PROCEDURES, LIMITS THE POTENTIAL FOR PROPAGATION
OF CONTEXT ERRORS.
.TEST PAGE 10
.INDEX 9.3 ^UNDETECTED ^ERRORS
.SKIP
.BR
9.3  ^UNDETECTED ^ERRORS
.BR
.P
^THE ^FLECS TRANSLATOR IS IGNORANT OF MOST DETAILS OF ^FORTRAN SYNTAX.
^THUS MOST ^FORTRAN SYNTAX ERRORS WILL BE DETECTED BY THE ^FORTRAN
COMPILER NOT THE ^FLECS TRANSLATOR. ^IN ADDITION THERE ARE TWO MAJOR
CLASSES OF ^FLECS ERRORS WHICH WILL BE CAUGHT BY THE COMPILER AND NOT
THE TRANSLATOR.
.TEST PAGE 5
.P
^THE FIRST CLASS OF UNDETECTED ERRORS INVOLVE MISSPELLED ^FLECS
KEYWORDS. ^A MISSPELLED KEYWORD WILL NOT BE RECOGNIZED BY THE TRANSLATOR.
^THE LINE ON WHICH IT OCCURS WILL BE ASSUMED TO BE A ^FORTRAN STATEMENT
AND WILL BE PASSED UNALTERED TO THE COMPILER WHICH WILL NO DOUBT OBJECT
TO IT. ^FOR EXAMPLE A COMMON ERROR IS TO SPELL ^^UNTIL\\ WITH TWO
^L'S. ^SUCH STATEMENTS ARE PASSED TO THE COMPILER, WHICH THEN PRODUCES AN
ERROR MESSAGE. ^THE FACT THAT AN INTENDED CONTROL PHRASE WAS NOT RECOGNIZED
FREQUENTLY CAUSES A LATER CONTEXT ERROR SINCE A LEVEL OF INDENTATION WILL
NOT BE TRIGGERED.
.TEST PAGE 5
.P
^THE SECOND CLASS OF UNDETECTED ERRORS INVOLVES UNBALANCED PARENTHESES.
(^SEE ALSO NOTE 8 IN SECTION 8.0.) ^WHEN SCANNING A PARENTHESIZED
SPECIFICATION, THE TRANSLATOR IS LOOKING FOR A MATCHING RIGHT
PARENTHESIS. ^IF THE MATCHING PARENTHESIS IS ENCOUNTERED BEFORE THE END
OF THE LINE THE REMAINDER OF THE LINE IS SCANNED. ^IF THE REMAINDER IS
BLANK OR CONSISTS OF A RECOGNIZABLE INTERNAL PROCEDURE REFERENCE, ALL IS
WELL. ^IF NEITHER OF THE ABOVE TWO CASES HOLD, THE REMAINDER OF THE LINE IS
^^ASSUMED\\ (WITHOUT CHECKING) TO BE A SIMPLE ^FORTRAN STATEMENT WHICH IS
PASSED TO THE ^COMPILER. ^OF COURSE, THIS ASSUMPTION MAY BE WRONG. ^THUS
THE STATEMENT:
.SKIP
.BR
"^^WHEN (X.LT.A(I)+Z)) X = 0\\"
.BR
.SKIP
IS BROKEN INTO
.SKIP
.BR
	KEYWORD "^^WHEN\\"
.BR
	SPECIFICATION "^^(X.LT.A(I)+Z\\"
.BR
	^FORTRAN STATEMENT ") ^X = 0"
.BR
.SKIP
^NEEDLESS TO SAY THE COMPILER WILL OBJECT TO ") ^X = 0" AS A STATEMENT.
.TEST PAGE 5
.P
^PROGRAMMERS ON BATCH ORIENTED SYSTEMS HAVE LESS DIFFICULTY WITH
UNDECTED ERRORS DUE TO THE PRACTICE OF RUNNING THE PROGRAM THROUGH BOTH
THE TRANSLATOR AND THE COMPILER EACH TIME A RUN IS SUBMITTED. ^THE
COMPILER ERRORS USUALLY POINT OUT ANY ERRORS UNDECTED BY THE TRANSLATOR.
.TEST PAGE 5
.P
^PROGRAMMERS ON TIMESHARING SYSTEMS TEND TO HAVE A BIT MORE DIFFICULTY
SINCE AN UNDETECTED ERROR IN ONE LINE MAY TRIGGER A CONTEXT ERROR IN A
MUCH LATER LINE. ^NOTICING THE CONTEXT ERROR, THE PROGRAMMER DOES NOT
PROCEED WITH COMPILATION AND HENCE IS NOT WARNED BY THE COMPILER OF
THE GENUINE CAUSE OF THE ERROR. ^ONE INDICATION OF THE TRUE SOURCE OF
THE ERROR MAY BE AN INDENTATION FAILURE AT THE CORRESPONDING POINT IN
THE LISTING.
.TEST PAGE 5
.INDEX 9.4 ^OTHER ^ERRORS
.SKIP
.BR
9.4  ^OTHER ^ERRORS
.BR
.P
^THE TRANSLATOR DETECTS A VARIETY OF OTHER ERRORS SUCH AS MULTIPLY
DEFINED, OR UNDEFINED PROCEDURE REFERENCES. ^THE ERROR MESSAGES ARE
SELF-EXPLANATORY. (^REALLY AND TRULY!)
.PAGE
.SUBTITLE #####^APPENDIX 2: ^REFERENCES
.INDEX ^APPENDIX 2: ^REFERENCES
.SKIP
.BR
.BR
		^AVAILABLE ^DOCUMENTATION ^CONCERNING ^FLECS
.BR
		(^AS OF ^DECEMBER 1974)
.BR
.SKIP
^BEYER, ^T., ^FLECS ^USERS ^MANUAL (^UNIVERSITY OF ^OREGON ^EDITION)
.BR
.SKIP
.LM 10
^CONTAINS A CONCISE DESCRIPTION OF THE FLECS EXTENSION OF ^FORTRAN
AND OF THE DETAILS NECESSARY TO RUNNING A ^FLECS PROGRAM ON THE
^^PDP\\-10 OR THE ^^IBM\\ ^S/360 AT ^OREGON.
.SKIP
.LM 5
^BEYER, T., ^FLECS: ^SYSTEM ^MODIFICATION ^GUIDE
.SKIP
.LM 10
^CONTAINS INFORMATION OF INTEREST TO ANYONE WHO WISHES TO INSTALL OR
ADAPT THE ^FLECS SYSTEM TO A NEW MACHINE OR OPERATING SYSTEM. ^ALSO OF
INTEREST TO THOSE WHO WISH TO IMPROVE THE EFFICIENCY OF THE SYSTEM BY
REWRITING PORTIONS OF THE SYSTEM IN ASSEMBLY LANGUAGE.
.LM 5
.PAGE
.SUBTITLE #####^^INDEX\\
.REQUIRE 'FLECS.RNX'
