<chapter>(Programming Notes\prognot)<p>        This section is aimed at programmers. Whether you want to extend    EMU, pick it apart and recycle code or are just interested in it's    mechanisms, this chapter is for you - you sad case.<p>    <head1>(General Notes)    EMU is entirely written in Macro. The choice of language was easy;    In spite of protestations to the contrary, MACRO produces    tighter, faster code than any other language, however in the    transition to Alpha, this may no longer be the case. That and the    fact that MACRO was the only language I could write in made the    choice obvious.    The only external software EMU relies on is VMS (V6.0 or later),    DECnet (any phase, any version) and UCX (any version). In many    ways, this is the hard way but it also allowed any broken feature    to be fixed at home. (which is where most of this was written).    It is quite modular - or not, depending on how you measure    modularity. Essentially, I tried to make discrete functions as    discrete modules and document the interface to each one. Each    standalone program is an individual file. Library routines are    (generally) functionally grouped together into single files. All    files have a standard format and are extensively commented. The    block comments are structured such that a simple DCL procedure can    extract them and create help files. A quick tour at this level    can be obtained by: $HELP/LIBR=EMU5_HLP:EMU_ROUTINES.HLB<head1>(Acknowledgements)    EMU was conceived and written by myself, however there were very    important contributions by others along the way. Some are as    follows: Adrian Challinor for education on CALLS vs. CALLG, Alan    Rawson for the DECnet NCB, Eric Von Dijk for a clever use of flags,    Simon Stevens for help in documenting the undocumented, The Dutch    PTT for knowingly letting me write this while paying me for other    work and Bank America for unknowingly supplying the same facility.<p>    Special mention of Ron James who at one point attempted to convert    this to C and in the effort discovered a number of very useful    techniques. While I couldn't use his code, (can't read C!), I am    grateful for the opportunity to steal all his ideas. Finally Keith    O'Brien to whom I owe a great debt. From teaching me MACRO (his    fault!) to advice on technique, to writing a good third of the    previous version, his influence and code remain a large part of    the present system. It is entirely true to say that without    Keith's generosity and patience, EMU would not exist beyond a bunch    of disconnected code. <head1>(System Tour)    Following is a rather wordy explanation of how the system works    at code level. This is the $0.25 tour - it is brief and skips    sometimes important detail but should be useful as an introduction    and supplements reading of the code (or mode correctly the code    comments).<head2>(Startup and Shutdown)         Executing START_EMU.COM gives options to clear the databases and start    from fresh and then runs EMU_CONTROL detached. This process reads    EMU5_DAT:PRCTBL.DAT, a list of processes it should start. It is    a 2 phase startup with a flag being set by RELATER indicating when    EMU_CONTROL should continue with phase 2. EMU_CONTROL acquires an    exclusive lock (which if it doesn't get, exits without doing    anything) and for each process started, creates  a termination    mailbox. If a process exits with error, EMU_CONTROL restarts it.    All activity is written to EMU5_LOG:EMU_CONTROL.LOG which you can    only read when the system is not running (one of the less useful    design features). Every process tries to acquire the CONTROL lock    and if it gets it, runs it's exit procedure and stops. Thus to    stop the system gracefully, delete the EMU_CONTROL process (which    EMU_STOP.COM does).<head2>(LISTEN)    The central process at this point is LISTENV5. It:    <list>(unnumbered)<le>creates a section for Ethernet buffers and maps to it.<le>creates a table of Ethernet buffer addresses. <le>Creates the PSR table by reading EMU5_DAT:PSRTBL.DAT. This file    specifies which process (PSR) will receive which frames read from    Ethernet.<le>Starts the Ethernet controller in promiscuous mode and queues all    (32) buffers to it. Each buffer is associated with a flag.<le>when an Ethernet read completes, the flag is set and the flag is    used as an index to the buffer section to quickly locate which    buffer has been written.<le>the buffer is scanned and compared with the PSRTBL to determine    which, if any PSR should process this buffer. For any PSR this is    destined for, a corresponding flag is set in the buffer and at end    all corresponding flags are set to wake up the PSR(s). <le>at end of each loop, Listen scans for returned buffers and reques    them to the Ethernet. <le>Any PSR woken up, scans the Ethernet buffer table for the    buffer(s) it should process, processes them and sets a flag in the    buffer indicating it is finished. When all the flags LISTEN set in    it's area are matched by FLAGS set in the PSR area, the buffer is    free.<endlist>    Other detail in this process: LISTEN tracks the number of buffers    outstanding to any process and should it reach it's (settable)    limit does not pass any more buffers to it and counts a discard.     <p>    LISTEN validates each frame for validity by checking:<list>(unnumbered)<le>Top 3 bytes of source address .eq. 0<le>Top 3 bytes of destination address .eq. 0<le> Protocol type field (or 802.3 len) .eq. 0<endlist>    If any of the above are true, an error is counted and the frame    discarded (requed without further processing).<p>    There is a hook for special processing. Most frames that are not    multicast are discarded but there are some exceptions. The    hardcoded filter in use now is to catch and process all ICMP and    ARP frames under IP. A hook for OSI error frames is present also    but not used.<Head2>(PSR)    Protocol Specific Routines are just that - each one processes a    specific protocol - or more accurately a specific frame. Thus    PSRMOP processes MOP SYSID broadcasts, PSRLAT processes LAT    service announcements etc. The essential purpose for a PSR is to     extract the (protocol specific) address in use and any other    useful information that may be present and store this in it's    database. Each protocol address may appear only once in the    database. A mechanism termed BOXID is used to 'tie' multiple    addresses on a single device together where this is possible. <Head3>(PSR Tour)  	    PSRs are all implemented using identical mechanisms and if I was    a better programmer, they would probably use shared code. As it    stands it is more like copied code. Follows here is a list of    generic activities any PSR will perform and following that, the    specific parts of those PSRs that currently exist.<list>(unnumbered)<le>Set local symbols THIS_PROCESS, and THIS_PROCESS_FLAG. Allows    common code later.<le>Request CONTROL_LOCK. When received, it means the control process    has died and we join in the mass suicide. Once the exit procedure    is enabled, that will run just before death.<le>Map to all common sections:<list>(unnumbered)    <le>Ethernet buffers    <le>Control Section    <le>PSRTBL<endlist><le>Map to our DB. Each PSR conceptually owns it's database. All other    processes that map to it use a BLOCKING AST and common procedure    to ensure that when this PSR wants exclusive access, it can regain    it. Thus each PSR uses a unique procedure to map to it's own DB.    To ensure no stale data is included, once the PSR maps and loads    the latest file in (if present), the file is deleted.<le>Enable the exit handler. This procedure (unique to each PSR)    analyses the in memory DB, sets the size it should be on next    startup and writes it all out to file. The process then dies.<le>Map to common event flags used. EMU uses all 64 CEFs available.<le>Initialise our area in PSTRTBL. This is where LISTEN stores    buffer counts associated with this PSR.<le>Send a message to the relater telling it we are alive, well and    waiting for work.<le>Wait for our flag to be set indicating a message is waiting for    us to process. The flag is set by the Listener when it determines    a frame in the EBUFFS area should be processed by this PSR.<le>Here starts the part that is unique to each PSR though the logic    is common:    <list>(unnumbered)    <le>Clear the flag    <le>Call LOCATE_PSR. This routine searches the specified PSRDB for    the specified address and if not found, creates a new record. If    created, it assigns the next (unique) BOXID or optionally assigns    one provided in the call, initialises the PSR record header and    indicates a new record was created. If the record is found it    simply increments the access count and exits normally.    <le>If the record is created, the PSR stores parts of the    Ethernet frame in the PSRREC and finishes this section. If the    record is not created, those parts of the frame that are recorded    are checked against the frame and if changed, overwrites the old    data and sets a flag indicating this record is updated.    <endlist><le>ensure we are in the relater DB. If we are the relater has set a    flag in this record indicating such. If not create a relater frame    with our address in it. Some PSRs are able to detect that    this frame also belongs in another PSRDB. If so, again the    corresponding bits in this record will indicate if it is in that    DB and if not, include this information in the relater frame. Some    protocols send node names in the frame. The NAMER DB is implemented    as a pseudo PSR and as such, if the name has not been sent or it    has changed, include this in the relater frame. At end, if a    relater frame has been created for any of the above reasons, send    it.<le>Clear our bit in the Ethernet frame indicating we are finished    with the buffer and go back for more. If no more buffers waiting,    wait for the next time the flag is set.<endlist><head3>(PSR Database)    Each PSR implements a separate database in shared memory only. It    is recorded to file on shutdown and reloaded and erased on    startup. The PSR conceptually owns the database and is responsible    for it's sizing and if necessary, resizing. Any process mapping to    a PSR database uses a common routine that ensures the PSR created    the database and allows the PSR to regain exclusive access should    it be deemed necessary. Details of the contents follow:<p>    All PSRDB databases have a commonly formatted first record:<table>(PSR First Record\PSRREC)    <table_setup>(3\25\5)    <table_heads>(EMU Symbol\Length\Description)    <table_row>(COM_DBHDR_L_ENTRIES\0\Number of physical entries)    <table_row>(COM_DBHDR_L_RECSIZE\4\Size of each record)    <table_row>(COM_DBHDR_L_MAXENTRIES\8\Max number of physical entries)    <table_row>(COM_DBHDR_L_FLAG\12\EMUPID of the DB owner)    <endtable>   This allows common routines to map and search the DBs.<p>    The remainder of the DB is specific to each PSR. A common header    is used for each record:<table>(PSR Common Record Header\psrcrech)    <table_setup>(3\25\5)    <table_heads>(EMU Symbol\Offset\Description)    <table_row>(COM_HDR_L_FLAGS\0\ PSRID)    <table_row>(COM_HDR_L_BOXID\4\ Unique device id             )    <table_row>(COM_HDR_L_PTYBITS\8\ Other protocols present      )    <table_row>(COM_HDR_L_SYSCTL\12\ System control flags (SYSDEF))    <table_row>(COM_HDR_Q_LSTHRD\16\ Last time heard              )    <table_row>(COM_HDR_Q_LSTALT\24\ Time last alert sent         )    <table_row>(COM_HDR_Q_FSTHRD\32\ Time 1st heard               )    <table_row>(COM_HDR_L_STATUS\40\ Current status               )    <table_row>(COM_HDR_L_ACNT\44\ Count of access this rec     )    <table_row>(COM_HDR_L_LEN\48\ Len of KEY - Protocol addr   )    <table_row>(COM_HDR_L_HOWSET\52\ How this addr found          )    <table_row>(COM_HDR_Q_LOCKFIELD\56\ Count of current accesses     )    <table_row>(COM_HDR_L_READLOCK\56\ Count of read accessors      )    <table_row>(COM_HDR_L_WRITELOCK\60\ Count of write accessors     )    <endtable><p>    Notes:<list>(numbered)<le>PSRID is the ID assigned to the PSR at generation. It corresponds    to the flag used to wake the process up (and other uses).<le>BOXID is as described above: an assigned (and changeable) ID that    associates records in this and other PSRDBs with a specific device    (computer, comms device etc.)<le>PTYBITS. A bit pattern in which a bit is set to indicate the    protocols this BOXID is running. The bit set corresponds to the    associated PSRID.<le>SYSCTL. System Control Flags. These are:<list>(unnumbered)<le> bit 0       ; Rec is deleted<le> bit 1       ; Update this rec in DB. Forces update on next cycle.<le> bit 3       ; Don't poll. Exactly that. Don't poll this device.There is no interface to control this as yet.<le> bit 4       ; Pseudo node (alias)<le> bit 5       ; Rec has been added to CNTDB. Hmmm ... this is afacility not yet complete.<le> bit 6       ; Disable CNTPOLL. Same as 5<le> bit 7       ; Propagated PSRDB -> EMUDB. If during polling astation does not answer (see EMU_CONFIGMON) this bit (when 0) forcesan EMUDB record to be created with the address only. As will bedescribed later, EMUDB is the configuration database built solely bypolling. It naturally does not create records when nothing isreceived via polling but this flag forces the address to appear in theDB.<endlist><le>Last heard, Last alert and 1st Heard are all standard VMS binary    times showing exactly what they describe. <le>Current status. Not used. Intended to hold the latest state    determined for an address (available or not etc) and used to alert    when status changes.<le>Count of accesses. Each time a lookup finds this record, this    field is incremented. As the search is sequential, it was thought    that sorting the records accesses most often to the top of the    section would speed up searching. It is probably true but as the    search time is insignificant, this remains a solution looking for    a problem.<le>Len of Key. Essentially the len of the protocol address that forms    the primary key for this record. Some addresses are variable    length and this field also allow a common routine to do all the    searching.<le>How this address found. Originally a debug filed showing the    process that caused this record to be created. As this screwed up    other processing, it was changed to reflect the owning PSR and as such is    a useless waste of space.<le>Locking. Each .long is a count of readers/writers currently    accessing this record. The locking routine is such that is allows    shared reads or shared writes but not shared read/write. The    mechanism determines the access required and if not currently    allowed, waits a short time and then completes (usually).<endlist>    The remainder of each PSR rec is specific to that PSR. Each is    documented in the corresponding PSR source file.          <head4>(PSR Mapping)    As indicated, mapping to the PSRDBs (in fact, individual memory    sections) uses common routines. MAPLVB_DB routine in file    MAP_SECTIONS.MAR is used by any process other than the PSR owner    to map to a particular PSRDB. The address of a MAP_STRUCTURE is    passed to this routine and if successful, returns the section    addresses in the structure:<table>(Map Structure\MPSEC)    <table_setup>(3\20\5)    <table_heads>(EMU Symbol\Access\Description)    <table_row>(SYS_MAP_Q_ADDR\Write\ Returned 1st and last addresses of section)    <table_row>(SYS_MAP_L_PID\Read\ PID of DB to map to)    <table_row>(SYS_MAP_L_KEY\Read\ Offset in DB rec where primary key found)    <table_row>(SYS_MAP_L_LCKID\Write\VMS assigned Lock id )    <table_row>(SYS_MAP_L_SPR\None\ Spare/Align)    <table_row>(SYS_MAP_L_LOCK\Read\ Address of Lock name)    <table_row>(SYS_MAP_L_SEC\Read\ Address of section name)    <endtable>    The routine always sets up a Blocking AST to allow the PSR owner    to regain exclusive access if required. If not supplied, UNMAPLVB    is set as the routine which runs as a result of receiving the    blocking AST.<p>    In addition, the Lock Value Block is written by the PSR owner when    it has exclusive access. The value written is the size (in pages)    of the section and all other users read this to determine section    size to map to. Should resizing occur the PSR:<list>(numbered)<le>Request the lock in EX mode thus causing the blocking AST to    deliver to all other processes mapped.<le>The blocking AST routine runs, withdrawing from the section and    reques the lock request in CW mode.<le>The PSR writes out it's memory section, deletes the memory section    and calculates a new size. The section is created, the size is    written to the LVB and the lock is converted to CW.<le>All other processes the acquire the lock, map the section using    the size in the LVB and normal relations resume.<endlist>      <Head2>(Relater Tour)    The relater is process which receives frames from PSRs and    constructs what might be called the device level database. This    database relates the disparate addresses together and forms a view     of the network as boxes. A box in EMU terminology is a device    running one or more protocols that is detected by the system.<p>    When a PSR receives a frame from the Listener, one of the main    checks it does is to determine if the relater knows about this    address. If not a frame is sent and the relater acknowledges    receipt by setting the corresponding bit in the PTYBITS field in    the PSR record. It also creates (or adds to) a relater DB record.<p>    The theory is simple (and at odds with the code!): Any frame    contains the protocol and address it is running on. In some cases,    it can be detected that other protocols are also present. For    example any Ethernet address beginning with AA-00-04-00 runs DECnet    regardless of the protocol the address was received on.    Additionally some protocols send the node name in the frame. This    information is sent to the relater where it assigns a BOXID,    creates the PSR records (if necessary) and stores the related    BOXIDs in a single relater record. The Relater DB is implemented    as a PSRDB but most of the common fields are not used. The data    part is an array in which a BOXID appears in the position    corresponding to the protocol. For example, if a MOPSYSID frame    containing Ethernet address    AA-00-04-00-14-04 is received from the Listener by PSRMOP, the MOP    processor recognises this as a MOP address, a DECnet address and    an Ethernet address and sends this to the relater along with the    assigned BOXID. The MOP address will exist (it has been created by    the sending process) but the others may or may not. The relater    searches it's own database for this BOXID on this protocol and if    not found, creates a new record. Each other address appearing in    the relater frame is searches for in the corresponding DB and if    found, the BOXID is added to the relater record at the offset    corresponding to the PID of the DB. If not found it    is created then added. BOXIDs are allowed to be duplicated within    any single PSRdb in the case where a device can run multiple    address (IP for example). In the case where disparate addresses    are related together and the BOXIDs don't match, one is changed.<P>    The relater then becomes the focus of most user oriented searches.    If an IP address is searched for and found, the corresponding    relater record is located and what appears on the screen is not    simply the IP address but the entire family of protocols running    on the device that IP address appears on.<head3>(Relater Frame)    Following is a list and explanation of each field that can    appear. This is constructed piece by piece by calling    CREATE_RELATER_FRAME repeatedly until all information is included    and then calling SEND_RELATER_FRAME to dispatch it.<list>(unnumbered)<le>BOXID. longword. Sending process's current BOXID<le>Sender. longword   Sending PSRID<le>Message type. longword. Symbol  Add, Delete or Start.     The targets are either Added to all PSRs or Deleted from all PSRs.     In the case of start, only the sender field is used.<le>Targets. longword. Number of targets to follow.<le>Follows is a list of PSR/Addr targets. It is an unaligned    structure:<list>(unnumbered)<le>.long process id (SYS_C_PID_xxxx) of target PSR<le>.long len of following addr<le>protocol address of the record in this PSR. This is in the    format expected in the receiving PSR. That is:<list>(unnumbered)<le>DECnet addresses are 2 bytes<le>IP addresses are 4 bytes<le>NOVELL addresses are 10 bytes<le>OSI address are variable lens<le>and so on.<endlist><endlist><endlist>    Maximum relater frame len is 512 bytes. If it is assumed the    average len of  an address is 8 bytes (actually a bit high) then    this leaves room for up to 31 relationships in 1 frame. In the    unlikely event this is not enough,  the sender can continue in    another frame - Each relationship is an independent item.<head2>(Configuration Pollers)    There are 2 and are distinguished from other possible pollers such    as Counter pollers or Test pollers (neither of which exist much    beyond a twinkle in the eye). The Configuration pollers are    divided into WAN and LAN types largely because WAN traffic tends    to be relatively heavy and across slower and more expensive links    as compared to LAN types. The LAN types (Ethernet, LAT, MOP, SCS    and IPX) are polled for more often than the WAN types (DECnet, IP    and OSI). Other than that, they are identical in structure. <p>    Each protocol poller is implemented separately and it is beyond    the scope of this section to describe them completely,    particularly as this is done in the source code already    (EMU_CONFIGMON.MAR). This section is more an overview on approach.<p>    In general, each protocol has a routine that is called giving the    address to poll and the address of a buffer to place the received    data in. In the more complex protocols (WAN mostly) a function code    is also implemented such that a section is polled for on each    call. The LAN protocols tend to be quite simple and the data is    formatted directly from the received frame and sent to the    database. The WAN protocols are much more complicated and    intervening routines format the data into standard arrangements    before they are written. In all cases, the resulting data is    written to EMUDB.<p>    Developers Note: The access routines are functionally standalone    and could be incorporated into, and used by other management    packages. It is the purpose here to supply these difficult and    often tedious routines for other purposes beyond EMU. Some of the    modules to look in (should you be so sad as to pursue this) are:<list>(unnumbered)<le>EMU_CMIP.MAR<le>GETSNMP.MAR and GETSNMPROW.MAR<le>EMU_MOP.MAR<le>GETDN4.MAR<le>GETOSI.MAR<le>EMU_IPX.MAR<endlist>    Should you manage to get through this code, the idea will be    obvious and all the others should be easily located. It is not    intended to take a unix approach here (It was tough for me so it    should be tough for you) but simply to avoid repeating what has been    said better elsewhere and cluttering up what is intended to be a    succinct description.  <head2>(Main Database - EMUDB)    EMUDB is a disk resident, RMS indexed file and contains all the    system knows about the network it is sitting on. Each record    contains exactly one parameter from exactly one address and is    indexed by BOXID. If the system crashes and the PSRs cannot save    their data, EMUDB is useless as the main index is lost. There is a    possibility of rebuilding the PSRDBs from EMUDB and an effort is    underway to complete that but as of now, if the system crashes,    delete everything and start over. EMUDB fields are as follows:<list>(unnumbered)<le>Protocol: The EMU assigned PID this entry is associated with. The    list of PIDS assigned is in _EMUSYSDEF.MAR<le>BOXID   :System generated unique physical device id<le>Table   :EMU defined table this param is in. Tables are defined    in _EMUDBDEF.MAR.<le>Instance: The specific instance of an entity. This is a 16    bit CRC of the parameter value.<le>Param   : The parameter number of this particular instance.    If the protocol assigns parameter numbers, these are used. If not,    EMU defines them.<endlist>         The primary key is concatenation of all of the above and dups    are not allowed. Any other key or combination may be duplicated    A 6th .long is provided in the key field for use as processing    flags. This field is defined as part of the key but never used    as such.<p>    Following this is the value of the specified parameter. It is kept    in 'simplified' protocol specific format.    All access to (and complete descriptions of) the DB is through     common routines found in EMUDB_ACCESS.MAR     <head2>(User Interface)    This is currently SMG and can be run multiple times on the same    node without interference between them. It is implement carefully    to preserve the boundary between the system and the interface as    it was intended from the outset to replace it. This has not    happened for a variety of reasons. Laziness, ineptitude and trying    to regain a life are just a few. However, it is ready for some    enterprising soul...<head3>(Query Overview)    A query is started by filling out a QUERY_STRUCTURE. This    structure is passed to the search routines and is updated on each    'find'. It allows for any single database to be searched either    forward or backward, the relater record to be looked up (thus    finding all BOX data) and finally formatting and presenting the    data as a series of menu selected items. The formatting routines    are protocol specific and are often (especially in the ASN.1 encoded    protocols - SNMP and CMIP) hugely complex. Full explanations    are provided in the sources - see EMU_UILIB.MAR.<head3>(Report Overview)    A report is generated from a report parameter file. This file is    created using the menus which select the parameters to include in    the report. The report is generated in spreadsheet format, that is    it is easily imported to Excel or other PeeWee program. See    EMU_RPT.MAR for full details. EMU_REPORTING.MAR provides a DCL    interface to the report subsystem. <head2>(Alert Mechanism)    A basic alert mechanism (that doesn't work very well) is in    EMU_ALTLIB.MAR and is executed with ALERT.MAR, a standalone    process that fields alerts, stores and displays them. Essentially,    an alert generator acquires an alert packet (memory section),    fills in the alert parameters and signals ALERT to process it.    The ALERT process then stores the raw frame on disk, then    translates and displays the alert if an alert display process is    running. A number of unused mechanisms are in play here and need    some explanation: <p>    What is present is the lower layer of a 2 layer process. What is    intended is a smarter alert than is present on most systems    however this part has never been completed. The raw alert, as    stored and displayed, is intended to be further processed to    allow a much wider context to be alerted. The concept of 'related'    and 'recent' events is built in but not implemented in this    version. The definition of recent and related are in the    architecture section of this manual. Currently, the usefulness of    this process is it's ability to review all events recorded. As a    monitor, it is limited (generous!) and some work is required to    remove restrictions on parameter specification.      <head1>(Summary)    EMU was originally conceived as a tool to assist me in my day to    day job as a network manager and to that end it has been very    successful. As it developed (and became an end in itself) it    became a commercial endeavour and managed some limited success here    also. Along the way it also served as a teaching tool and hobby.    In this it was successful. Finally it became an imprisonment, an    activity that demanded more time and effort than anyone could    supply. This aspect of it was entirely successful. Now it is a    gift - Anyone who uses, develops it or even has an interest is    welcome to do as they see fit. I would be pleased to hear from you    and if time permits, (I have a life now!) assist in your endeavour.    I can be contacted at system@ccci4.demon.co.uk.         The code is well documented and as readable as Macro code can be.    It is also modular enough to take functions out and reuse them    elsewhere. EMU was very much a reaction to the poor quality of    network management packages available - a situation that IMHO has    not changed. Without prejudice to any group, I would suggest that    not enough network people can program or even understand what can    be done with a good system and programmers in general do not    understand what network managers need. That is the gap I am    attempting to bridge however, it is a bridge too far. The multiple    skills required and the sheer size is beyond a single person    working part time.                                 