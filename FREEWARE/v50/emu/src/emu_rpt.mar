	.TITLE EMU_RPT  
	.IDENT /V01-001/
;	© 2000 P. Beaudoin
;  This software is supplied as is and the usual warranty
;  is implied - none. You may use, abuse, modify or
;  or ignore this software as you see fit but are
;  encouraged to give credit, as is good practice
;  when stealing with permission
; 
; Modifications
; 001 	Apr 1998		PB	Creation		
;++
;1 EMU_RPT  
; 1. Interactive programme to create and generate reports on the contents of
;    the EMU databases.
; 2. Collection of routines to implement the interactive and callable
;    versions oF the reporting subsystem
;
;2 Inputs  
;	Files
;		MAPPER.DAT. EMU paramater file
;		*.RPT. Previously created report param files
;       Interactive
;	Top level menu:
;	     1. Display: 
;		Displays currently loaded or created report param file
;	     2. Load: 
;		Loads a previously created and saved report param file.
;		File names are displayed in menu for selection.
;	     3. Create:
;		Displays contents of MAPPER.DAT in menus. Paramaters
;		selected are included in report. If a param is
;		selected that is already in the report params, it is removed. 
;            4. Save:
;		Saves the cuurent report params in a file with type RPT.
;		The file name is selected by user.
;	     5. Create report:
;		Creates a raw report as per report params selected.
;	     6. Pre-defined reports:
;		Displays a menu of predefined reports. Selection causes
;		the selected report to be created
;
;2 Output
; Report param file format:
;	Field		Siz		Desc
;	Param		8	The table.param of a param from MAPPER.DAT
;	Max Size	4	Max size outp field this param
;	Flags		4	Bit field:
;				Bit		When set
;				0	If not present do not include this box
; Report Format
;	Comma seperated list of params selected by report params.
;	Formated such that each line contains 1 instance of each param
;	selected. If param does not exist or has already been displayed
;	then blank field is produced.
;3 Example_output
;       If a report asking for DECnet address and IP address is requested
;	and the box has 1 decnet address and 3 IP addresses then the 
;	following 4 records are written:
;	DECnet Address,IP Address
;	50.1,165.47.1.1
;	,165.47.1.2
;	,165.47.1.3
;	,,
;2 Returns
;	ANY from $RMS
;2 Callable_interface.
;  A routine callable from DCL is provided. This works in a similar manner to 
;  the interactive version with the following limits:
;	The caller specifies the param file and report file.
;	The param file must have been previously created using the interactive
;	version.
;--
	.LIBRARY	/EMU5_LIB:EMU5.MLB/

	$RMSDEF
	$TRMDEF		; Terminal Modifiers
	$DSCDEF		; Declare DSC sysmbols
	$SMGDEF		; Declare SMG symbols
	$IODEF
	$SSDEF
	EMUCTRLDEF
	EMUSYSDEF
	EMUDBDEF
	EMUUIDEF
	EMUPSRDEF
	EMURLTDEF
	EMUIPCDEF
;
; TEMP SYMBOLS
RPT_PRM_C_SECSIZ	= 16		; Pages
RPT_PRM_C_ITMSIZ 	= 32		; Bytes
RPT_PRM_L_TBL		= 0
RPT_PRM_L_PARAM		= 4
RPT_PRM_L_FLAGS		= 8
RPT_PRM_L_MAXLEN	= 12
RPT_PRM_L_PROTID 	= 16
RPT_SEC_C_MAXID		= 64
;
RPT_PRMFLG_V_DEL	= 0		; Rec is deleted
RPT_PRMFLG_M_DEL	= 1		; Rec is deleted
RPT_PRMFLG_V_MLS	= 1		; Max len is set
RPT_PRMFLG_M_MLS	= 2		; Max len is set
;

RPT_SEC_L_STA          =  0       ; Status of last sea
RPT_SEC_L_RECCNT       =  4       ; Number of retrieved recs this scan
; Note the key struc follows _EMUDBDEF
RPT_SEC_B24_KEY        =  8       ; Location of EMUDB key
RPT_SEC_L_PROTID       =  8	 ; Pid table belongs to
RPT_SEC_L_BOXID        =  12	 ; 
RPT_SEC_L_TBL	       =  16	 ; Table to get from
RPT_SEC_L_INST	       =  20	 ; 
RPT_SEC_L_PARAM	       =  24	 ; Param to get 
RPT_SEC_L_FLAG	       =  28	 ;  
;
RPT_SEC_L_LEN          =  32      ; Len of final formatted param
RPT_SEC_Q_RFA          =  36      ; LAST REC
RPT_SEC_C_DATA         =  44      ; displayed data here
RPT_SEC_C_MAXDATA      = 212      ; Max size any single data item
RPT_SEC_C_SIZE         = 256      ; Size of 1 PID's area
	.PSECT EMU_RPT_DATA,WRT,NOEXE,QUAD,pic
RPTSEC_A:	.QUAD	0
RPTPRM_A:	.QUAD	0
RABSEC_A:	.QUAD	0
RECSEC_A:	.QUAD	0
INADDR:		.QUAD	0
TEMPDESC:	.QUAD	0
TMPFIL:		.BLKB	20
TMPFILDESC:     .LONG	.-TMPFIL
		.ADDRESS  TMPFIL

DBTBL:
; Ordering in this table is important - the order in which they
; appear is the order in which the PID was assigned
		.BLKB	SYS_MAP_C_MAPSIZ 	; 0 = invalid
		.BLKB	SYS_MAP_C_MAPSIZ        ; = listener (no db)
;
                .QUAD	0
		.LONG	SYS_PID_C_PSRDN4
		.LONG	PSR_DN4_W_ADDR
		.LONG	0			; Lock ID
		.LONG	0			; Spare/align
		.ADDRESS EMU_DN4DB
		.ADDRESS EMU_PSRDN4
;
                .QUAD	0
		.LONG	SYS_PID_C_PSRDN5
		.LONG	PSR_DN5_B20_ADDR
		.LONG	0			; Lock ID
		.LONG	0			; Spare/align
		.ADDRESS EMU_DN5DB
		.ADDRESS EMU_PSRDN5
;
                .QUAD	0
		.LONG	SYS_PID_C_PSRSCS
		.LONG	PSR_SCS_EA_ADDR
		.LONG	0			; Lock ID
		.LONG	0			; Spare/align
		.ADDRESS EMU_SCSDB
		.ADDRESS EMU_PSRSCS
;
                .QUAD	0
		.LONG	SYS_PID_C_PSRLAT
		.LONG	PSR_LAT_EA_ADDR
		.LONG	0			; Lock ID
		.LONG	0			; Spare/align
		.ADDRESS EMU_LATDB
		.ADDRESS EMU_PSRLAT
;
                .QUAD	0
		.LONG	SYS_PID_C_PSRMOP
		.LONG	PSR_MOP_EA_ADDR
		.LONG	0			; Lock ID
		.LONG	0			; Spare/align
		.ADDRESS EMU_MOPDB
		.ADDRESS EMU_PSRMOP
;
                .QUAD	0
		.LONG	SYS_PID_C_PSRIP
		.LONG	PSR_IP_L_ADDR
		.LONG	0			; Lock ID
		.LONG	0			; Spare/align
		.ADDRESS EMU_IPDB
		.ADDRESS EMU_PSRIP
;
                .QUAD	0
		.LONG	SYS_PID_C_PSRIPX
		.LONG	PSR_IPX_L_NET
		.LONG	0			; Lock ID
		.LONG	0			; Spare/align
		.ADDRESS EMU_IPXDB
		.ADDRESS EMU_PSRIPX
;

		.BLKB	SYS_MAP_C_MAPSIZ 	; 9 = DNS
		.BLKB	SYS_MAP_C_MAPSIZ 	; 10 = DTS
		.BLKB	SYS_MAP_C_MAPSIZ 	; 11 = ARP
;
                .QUAD	0
		.LONG	SYS_PID_C_PSRETH
		.LONG	PSR_ETH_EA_ADDR 
		.LONG	0			; Lock ID
		.LONG	0			; Spare/align
		.ADDRESS EMU_ETHDB
		.ADDRESS EMU_PSRETH
;
		.BLKB	SYS_MAP_C_MAPSIZ 	; 13 = unassigned  

                .QUAD	0
		.LONG	SYS_PID_C_PSRBRD
		.LONG	PSR_BRD_EA_ADDR 
		.LONG	0			; Lock ID
		.LONG	0			; Spare/align
		.ADDRESS EMU_BRDDB
		.ADDRESS EMU_PSRBRD
;
		.BLKB	SYS_MAP_C_MAPSIZ 	; 15 = unassigned  
		.BLKB	SYS_MAP_C_MAPSIZ 	; 16 = unassigned  
;
                .QUAD	0
		.LONG	SYS_PID_C_NAMER
		.LONG	NAM_DB_AS_NAME
		.LONG	0			; Lock ID
		.LONG	0			; Spare/align
		.ADDRESS EMU_NAMERDB
		.ADDRESS EMU_NAMER

MAPRELATER:
                .QUAD	0
		.LONG	SYS_PID_C_RELATER
		.LONG	0
		.LONG	0			; Lock ID
		.LONG	0			; Spare/align
		.ADDRESS EMU_RELATERDB
		.ADDRESS EMU_RELATER

DBTBL_DESC:	.LONG 	.-DBTBL
		.ADDRESS  DBTBL

; Files
; Report item list
RPTITMFAB: 
	$FAB 	FAC = <GET,PUT,UPD>,-	; Access
		SHR = <GET,PUT,UPD>,-	; Sharing
		FOP = CTG,-		;Make contiguous
		DNM = <EMU5_ROOT:[DAT]OUTP.RPTP>		;Def filtype
RPTITMRAB:	$RAB	FAB = RPTITMFAB		; pointer to FAB
; Report output file

RPTFAB:	
		$FAB	FAC = <GET,PUT,DEL>,-        ; Access
			SHR = <GET,PUT,DEL>,-
			RAT = <CR>,-
			MRS = RPTREC_SIZE,-
			ORG = SEQ,-
			DNM = <EMU5_ROOT:[RPT]EMU_RPT.RPT>
RPTRAB:	
		$RAB	FAB = RPTFAB,-            ; Record 
			RAC = SEQ,-
       			RBF = RPTREC,-			; 
       			UBF = RPTREC,-			; 
       			USZ = RPTREC_SIZE,-		; 
       			RSZ = RPTREC_SIZE   		; 
		

RPTREC:	 .BLKB	1024   
RPTREC_SIZE = .-RPTREC
RPTDESC:	.LONG	.-RPTREC
		.ADDRESS  RPTREC



	.ALIGN	LONG
MAPPERFAB:	
	$FAB	FAC = <GET,PUT,UPD,DEL>,-	; Access
		SHR = <GET,PUT,UPD,DEL,MSE>,-	; Share with ...
		FOP = CIF,-			; Create if doesn't exist
		ORG = IDX,-			; Keyed file (Finally)
		MRS = 128,-                       ; Largest rec
		GBC = 10,-                        ; Use global buffers
		DNM = <EMU5_DAT:MAPPER.DAT>,-	; Default Filename 
		FNM = <MAPPER>,-			; Filename 
		XAB = MAPPERXAB0                  ; Keys

MAPPERRAB:	$RAB	FAB = MAPPERFAB,-		; pointer to FAB
		RBF = MAPPERREC_BUF,-		; i/o buffer 
		RSZ = MAPPERREC_SIZE,-		; Write this many bytes
		UBF = MAPPERREC_BUF,-		; i/o buffer 
		USZ = MAPPERREC_SIZE,-		; 
		RAC = KEY,-			; Keyed file
		KBF = MAPPERREC_BUF,-			; Key location
		KSZ = 8

MAPPERXAB0:	$XABKEY	REF = 0,-  		; TBL,PARAM
		DTP = BN8,-             ; Key = 4 bytes binary (ascending)
		POS = 0,-               ; Key position
		SIZ = 8,-                 ; Key len (dups not allowed)
		NXT = MAPPERXAB1

MAPPERXAB1:	$XABKEY	REF = 1,-  	; TBL
		DTP = BN4,-             ; Key = 4 bytes binary (ascending)
		POS = 0,-               ; Key position
		SIZ = 4,-               ; Key len (dups allowed)
		FLG = DUP,-
		NXT = MAPPERXAB2

MAPPERXAB2:	$XABKEY	REF = 2,-  	; PARAM
		DTP = BN4,-             ; Key = 4 bytes binary (ascending)
		POS = 4,-               ; Key position
		SIZ = 4,-               ; Key len (dups allowed)
		FLG = DUP
;
MAPPERREC_BUF:	
MAPPER_KEY:
MAPPER_TBL:		.LONG	0	; Table 
MAPPER_PARAM:		.LONG	0	; Paramater
MAPPER_SEC:		.QUAD	0	; Prives req'ed to detect. VMS sec
MAPPER_KEYWLEN:		.LONG	0	; Len of following string
MAPPER_KEYW:		.BLKB	32      ; Standard keyword this param
MAPPER_FMTTYP:		.LONG	0	; Either len of following or rtn num.
MAPPER_FMTSTR:		.BLKB	72	; FAO directive str

MAPPERREC_SIZE = .-MAPPERREC_BUF        ; = 128
PARAMTBL:	.LONG
	.ALIGN	LONG
; The reporting routines open EMUBDB and access is directly rather
; than using the ACCESS routines as they have special requirements.
; Briefly:
; The file is opened and for each RPTITM param, the RAB is coppied to VM 
; so that at end of VM build, there is 1 initalised RAB / param in the 
; section. This allow reporting to maintain the myriad of pointers
; necessary to order the output.
;
EMUDBFAB:	$FAB	FAC = <GET,PUT,UPD,DEL>,-	; Access
		SHR = <GET,PUT,UPD,DEL,MSE>,-	; Share with ...
		ORG = IDX,-			; Keyed file (Finally)
		MRS = 768,-                     ; Largest rec
		RFM = VAR,-			; Variable len
		GBC = 10,-                      ; Use global buffers
		DNM = <EMU5_DAT:EMUDB.DAT>,-	; Default Filename 
		FNM = <EMUDB>,-			; Filename 
		FOP = CIF,-			; Create if doesn't exist
		XAB = EMUDBXAB0                  ; Keys
; Read RAB
EMUDBRAB:	$RAB	FAB = EMUDBFAB,-		; pointer to FAB
		RBF = EMUDBREC_BUF,-		; i/o buffer 
		RSZ = EMUDBREC_SIZE,-		; Write this many bytes
		UBF = EMUDBREC_BUF,-		; i/o buffer 
		USZ = EMUDBREC_SIZE,-		; 
		RAC = KEY,-			; Keyed file
		ROP = NXT,-
		KBF = KEY_BUF,-
		KSZ = 12


;
EMUDBXAB0:	$XABKEY	REF = 0,-  		; PROTOCOL
		DTP = BN4,-             ; Key = 4 bytes binary (ascending)
		POS = 0,-               ; Key position
		SIZ = 4,-               ; Key len
                FLG = <DUP>,-		; Duplicates, changes allowed
		NXT = EMUDBXAB1
;
EMUDBXAB1:	$XABKEY	REF = 1,-  		; BOXID
		DTP = BN4,-             ; Key = 4 byte binary (ascending)
		POS = 4,-               ; Key position
		SIZ = 4,-               ; Key len
                FLG = <DUP,CHG>,-	; Duplicates, changes allowed
		NXT = EMUDBXAB2
;
EMUDBXAB2:	$XABKEY	REF = 2,-  		; TABLE
		DTP = BN4,-             ; Key = 4 byte binary (ascending)
		POS = 8,-               ; Key position
		SIZ = 4,-               ; Key len
                FLG = <DUP,CHG>,-	; Duplicates, changes allowed
		NXT = EMUDBXAB3
;
EMUDBXAB3:	$XABKEY	REF = 3,-  		; Instance
		DTP = BN4,-             ; Key = 4 byte binary (ascending)
		POS = 12,-              ; Key position
		SIZ = 4,-               ; Key len
                FLG = <DUP,CHG>,-	; Duplicates, changes allowed
		NXT = EMUDBXAB4
;
EMUDBXAB4:	$XABKEY	REF = 4,-  		; Paramater
		DTP = BN4,-             ; Key = 4 byte binary (ascending)
		POS = 16,-              ; Key position
		SIZ = 4,-               ; Key len
                FLG = <DUP,CHG>,-	; Duplicates, changes allowed
		NXT = EMUDBXAB5
;
EMUDBXAB5:	$XABKEY	REF = 5,-  	; Protocol,boxid
		DTP = BN8,-             ; Key = 4 byte binary (ascending)
		POS = 0,-              ; Key position
		SIZ = 8,-               ; Key len
                FLG = <DUP,CHG>,-		; Duplicates, changes allowed
		NXT = EMUDBXAB6
;
EMUDBXAB6:	$XABKEY	REF = 6,-  	; Unique param
		DTP = STG,-             ; String
		POS = 0,-               ; Key position
		SIZ = 20,-              ; Key len 
                FLG = <CHG>,-		; No Duplicates, changes allowed
		NXT = EMUDBXAB7
;
EMUDBXAB7:	$XABKEY	REF = 7,-  	; BOXID,TABLE
		DTP = BN8,-             ; 8 BYTES
                FLG = <DUP,CHG>,-	; Duplicates, changes allowed
		POS = 4,-               ; Key position
		SIZ = 8,-                 ; Key len 
		NXT = EMUDBXAB8
;
EMUDBXAB8:	$XABKEY	REF = 8,-  	 ; TABLE,PARAM
		DTP = STG-               ; 8 BYTES
                FLG = <DUP,CHG>,-	 ; Duplicates, changes allowed
		POS = <8,16>-            ; Key position
		SIZ = <4,4>,-              ; Key len 
		NXT = EMUDBXAB9
;
EMUDBXAB9:	$XABKEY	REF = 9,-  	 ; BOXID TABLE,PARAM
		DTP = STG,-               ; 12 BYTES
                FLG = <DUP,CHG>,-	 ; Duplicates, changes allowed
		POS = <4,8,16>-            ; Key position
		SIZ = <4,4,4>,-              ; Key len 
		NXT = EMUDBXAB10

EMUDBXAB10:	$XABKEY	REF = 10,-  	 ; Flag field
		DTP = BN4-               ; 4 BYTES
                FLG = <DUP,CHG>,-	 ; Duplicates, changes allowed
		POS = 20,-            	 ; Key position
		SIZ = 4               	 ; Key len 

EMUDBREC_BUF:	.BLKB	768		; 
EMUDBREC_SIZE = .-EMUDBREC_BUF
EMUDBREC_BUF_DESC:
		.LONG	 EMUDBREC_SIZE
		.ADDRESS EMUDBREC_BUF
KEY_BUF:	.BLKB	24
;	

; Virtual Display Parameters
;
REPORT_DISP:	.LONG		; Virtual Display ID
REPORT_ROWS: 	.LONG 	0       ; Dynamic
REPORT_COLS: 	.LONG 	66      ;
REPORT_DISP2:	.LONG		; Display 2
REPORT_ROW2:	.LONG 	0       ; Dynamic
REPORT_COL2:	.LONG  	66      ; Position for DISP2
REPORT_DISP3:	.LONG		; Display 3
REPORT_ROW3:	.LONG 	3
REPORT_COL3:	.LONG	132      ; Position for DISP3
;
;
; Menu Items
;
; 
MENU_STRUCT:
		.LONG			; Virtual display ID
KB_BOARD:	.LONG           	; Virtual Keyboard ID
MSTYPE:		.LONG	SMG$K_VERTICAL	; Menu type   
MSCNT:		.LONG	0		; Number of items
MSSIZE:		.LONG	0		; Size of item
MSFLAG:		.LONG	SUI_MEN_C_CHECK ; Check for privs
MSPRIV:		.LONG	0               ; addr of priv list
MSITEMS:	.LONG	0               ; addr of display items

REPORT_MAIN_MENU:
	.LONG	SMG$K_VERTICAL	; Menu type   
	.LONG	5		; Number of items
	.LONG	16		; Size of item
	.LONG	SUI_MEN_C_NOCHECK ; Don't Check for privs
REPORT_MAIN_PRIVS:	
	.QUAD	0 		; None Required
PARAM_SEL_MENU:
	.LONG	SMG$K_VERTICAL	; Menu type   
	.LONG	0		; Number of items
	.LONG	48		; Size of item
	.LONG	SUI_MEN_C_CHECK ; Check for privs
REPORT_MAIN_ITEMS:
	.ASCII	/Display_Reports /
	.ASCII	/Load_Saved_List /
	.ASCII	/Create_New_list /
	.ASCII	/Save_Current    /
	.ASCII	/Create_Report   /

; 
;Menu Display Characteristics
;
M_DCS:		.WORD	48                  ; size of element
		.BYTE	DSC$K_DTYPE_T
		.BYTE	DSC$K_CLASS_A
MADDR:		.ADDRESS DYNMEN             ; Pointer
		.WORD	0		    ; DIGITS, SCALE
		.BYTE	DSC$K_DTYPE_T	    ; AFLAGS
		.BYTE	DSC$K_CLASS_S	    ; DIMCT
;		.LONG	^X01E00000          ; DIMCT,AFLAGS,DIGITS,SCALE
MSIZE:		.LONG   0		    ; Size of array
		.LONG	48
		.LONG 	1		    ; 
		.LONG	48
		.LONG 	1		    ; 

MAXDYN_ITEMS = 200
DYNMEN:		.BLKB	48*MAXDYN_ITEMS		; Dynamic menu items here
DYNCHOICE:	.BLKQ	MAXDYN_ITEMS            ; Dyn choice index
; Optional Display Characteristics
;
BORDER:		.LONG	SMG$M_BORDER
REVERSE:	.LONG	SMG$M_REVERSE
HORIZONTAL:	.LONG	SMG$K_HORIZONTAL
VERTICAL:	.LONG	SMG$K_VERTICAL
BLOCK:		.LONG	SMG$K_BLOCK
W2:		.LONG 2
W3:    		.LONG 3
BOLD:		.LONG	SMG$M_BOLD
SPACING:	.LONG	SMG$M_DOUBLE_SPACE
FORMAT:		.LONG	SMG$M_FIXED_FORMAT
ERASE:		.LONG	SMG$M_ERASE_MENU
CURSOR_FLAGS:	.LONG	<SMG$M_CURSOR_OFF!SMG$M_SCROLL_JUMP>
CURSON:		.LONG	<SMG$M_CURSOR_ON!SMG$M_SCROLL_JUMP>
UPCASE:		.LONG	TRM$M_TM_CVTLOW 	;Convert lower to upper case
DELITM:		.LONG	SMG$M_REMOVE_ITEM       ; Remove selected item from menu
SAVE_DISP:	.LONG	0		; Saved char
SCR_WID:	.LONG	132
SCR_HEIGHT:	.LONG	48
CURCOL:		.LONG   1
CURROW:		.LONG   3
SAVE_ID:	.LONG	0
REPORT_MAIN_CHOICE: .WORD	0
SEC_TBL_CHOICE: .WORD	0
TBL_CHOICE:	.WORD	0
PRM_CHOICE:	.WORD	0
CHOICE:		.WORD
	.ALIGN	LONG
;
; Pasteboard Paramenters
;
PB_BOARD:	.LONG 		; Pasteboard ID
PB_COL:		.LONG	1      
PB_ROW:		.LONG 	5
PB_COL2:	.LONG	66      ; Position for DISP2
PB_ROW2:	.LONG 	5
PB_COL3:	.LONG	1      ; Position for DISP3
PB_ROW3:	.LONG 	1
;
; Virtual Keyboard Parameters
;
KB_BUF:		.BLKB	80	; Input buffer
KB_DES:		.LONG	.-KB_BUF
		.ADDRESS KB_BUF
;
; FAO
FAOBUF:		.BLKB	132
FAODESC:
FAOLEN: 	.LONG		.-FAOBUF
        	.ADDRESS        FAOBUF
FAOLIST:	.BLKB	2048		; up to 256 params/line
TITLELIST:	.BLKB	2048		; Title desc here
TITLE_STRINGS:	.BLKB	8192            ; Title strings here
TITLE_STRING_LEN =.-TITLE_STRINGS
; Prompt strings and parameters
;
DYNCTLDESC:	.LONG	0
		.ADDRESS DYNCTLSTR
DYNCTLSTR:	.BLKQ	256			; Build dyn str here
BOXIDITM:	.ASCII	/!UL|/
DYNITM:		.ASCII	/!AD|/
TITLP1:		.ASCII	/Box ID/
TITLP1_LEN =.-TITLP1
EXITMSG:	.ASCII	/Press Return/
NEWFILEMSG:	.ASCID	/Creating new File .../
LISTENDMSG:	.ASCID	\ End of list. Any key to Continue\
FILNAMPRMPT:	.ASCID	/Report Name [<CR> to exit]: /
FILCRTMSG:	.ASCID	/ Creating Report ... /

PARAMNAMPRMPT:	.ASCID	/Name of param file: /
;
CANTRPTMSG:	.ASCID	/ Can't Report on this table. <CR> to continue/
ITMCNTMSG:	.ASCID	/ Report Paramater File. !UL Items/
RPTDELCURSTR:	.ASCID	/ Save changes [Y]? /
RPTDELCNTSTR:	.ASCID	/ DELETED !UL file!%S ... /
RPTPURGESTR:	.ASCID	/ Purge old versions [N]? /
RPTPRMRECSTR:	.ASCID	/ !AC !32<!AD!> !XL !XL/
RPTTITLESTR:	.ASCID	/ !AC !AD/
FILWRTERR:	.ASCID	/ Could not write file. Error = !XL.../
FILDELERR:	.ASCID	/ Could not DELETE file. Error = !XL.../
FILDELSTR:	.ASCID	/ DELETED !AS ... /
FILRDERR:	.ASCID	/ Could not read file. Error = !XL.../  
TBL2PIDERR:	.ASCID	/ Error in TBL2PID. <Any Key> to exit /
XLTPIDERR:	.ASCID	/ Error in XLTPID. <Any Key> to exit /
INSTTBLERR:	.ASCID	/ Error in Instance table. <Any Key> to exit /
RPTDELSTR:	.ASCID	/ Delete [N]?/
DELERRSTR:	.ASCID	/ Could not delete record. Error = !XL.../  
MAXLENPRMPT:	.ASCID	/ Maximum output len [None] ? /
NOITMMSG:	.ASCID	/ Please either create or load a report before creation/
RPTERRMSG:	.ASCII	/error   /
STATHDR1:	.ASCID	/      Selected From    Lines Written/
STATHDR:	.ASCID	/        Database        To  Report/
STATMSG:	.ASCID	\           !18<!UL!> !18<!UL!> \
RPTEXMSG:	.ASCID	/ Report created. Exit status !XL/
;
; Lock Names
EMU_IPDB:	
		.ASCID	\EMU_IPDB\            ; Lock name
EMU_IPXDB:	
		.ASCID	\EMU_IPXDB\            ; Lock name
EMU_MOPDB:	
		.ASCID	\EMU_MOPDB\            ; Lock name
EMU_BRDDB:	
		.ASCID	\EMU_BRDDB\            ; Lock name
EMU_SCSDB:	
		.ASCID	\EMU_SCSDB\            ; Lock name
EMU_DN5DB:	
		.ASCID	\EMU_DN5DB\            ; Lock name
EMU_DN4DB:	
		.ASCID	\EMU_DN4DB\            ; Lock name
EMU_LATDB:	
		.ASCID	\EMU_LATDB\            ; Lock name
EMU_ETHDB:	
		.ASCID	\EMU_ETHDB\            ; Lock name
EMU_NAMERDB:		
		.ASCID	/EMU_NAMERDB/	; DB Lock name 
EMU_RELATERDB:		
		.ASCID	/EMU_RELATERDB/	; DB Lock name 
; Section names
; Section Names
EMU_RPTPRM:	.ASCID	/EMU_RPTPRM/
EMU_RPTSEC:  	.ASCID	/EMU_RPTSEC/
EMU_RABSEC:  	.ASCID	/EMU_RABSEC/
EMU_RECSEC:  	.ASCID	/EMU_RECSEC/

EMU_RELATER:
		.ASCID	/EMU_RELATER/
EMU_PSRIP:
		.ASCID	/EMU_PSRIP/
EMU_PSRIPX:
		.ASCID	/EMU_PSRIPX/
EMU_PSRMOP:
		.ASCID	/EMU_PSRMOP/
EMU_PSRBRD:
		.ASCID	/EMU_PSRBRD/
EMU_NAMER:
		.ASCID	/EMU_NAMER/
EMU_PSRSCS:	
		.ASCID	\EMU_PSRSCS\  		; Section name
EMU_PSRDN5:	
		.ASCID	\EMU_PSRDN5\  		; Section name
EMU_PSRDN4:	
		.ASCID	\EMU_PSRDN4\  		; Section name
EMU_PSRLAT:	
		.ASCID	\EMU_PSRLAT\  		; Section name
EMU_PSRETH:	
		.ASCID	\EMU_PSRETH\  		; Section name
RPTFILDEF:	.ASCID  /EMU5_DAT:*.RPTP/
RPTRESDEF:	.ASCID  /EMU5_RPT:*.RPT;*/

; TPU
TPU_INFILE:		.ASCII	/EMU5_RPT:/
TPU_DIRSPEC = .-TPU_INFILE
TPUFILE:		.BLKB	128
TPU_INFILE_DESC:	.LONG 	.-TPU_INFILE
			.ADDRESS  TPU_INFILE
TPU_OUTFILE_DESC:	.QUAD
;
; Misc data areas
	.ALIGN	LONG
INSTTBL:	.BLKQ	64
INSTTBL_LEN = .-INSTTBL
INSTTBLCNT:	.LONG	0
;
STATCNT:
FRMDB:		.LONG	0
TORPT:		.LONG	0
RECCNT:		.LONG	0
RDSTA:		.LONG	0
PURVER:		.ASCII	/;-1 /		; .long !
GBLSIZ:		.LONG   0
RPTITMCNT:	.LONG   0
RPTMAXITM:	.LONG	0
OUTINT:		.LONG
LVL1TBL:	.LONG	^X01000000
LNCNT:		.LONG	
PIDNAM:		.LONG
RPCASE:		.LONG
RELENTCNT:	.LONG
PXLTOPT:	.LONG	<DB_XLTOPT_M_NOTRAN!DB_XLTOPT_M_SUPKEW>
BYTCNT:		.WORD

;
;	.End data definitions
;
	.PSECT EMU_RPT_CODE,EXE,pic
	.CALL_ENTRY	MAX_ARGS=0, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=EMU_RPT
;
; Open file 
;
	BSBW	REPORT_CREATE_ENVIRONMENT
;
; Display Menu
10$:
	MOVAL	MENU_STRUCT,R1
	MOVAL	REPORT_DISP,SUI_MEN_L_DISPLAY(R1)
	MOVQ	REPORT_MAIN_MENU,SUI_MEN_L_MTYPE(R1)  		; Type,count
	MOVQ	REPORT_MAIN_MENU+8,SUI_MEN_L_ITEMSIZ(R1)       ; Size,check flag
	MOVAL	REPORT_MAIN_PRIVS,SUI_MEN_L_PRIVLST(R1)        ; privs
	MOVAL	REPORT_MAIN_ITEMS,SUI_MEN_L_MENU(R1)        	; Display items
; Make menu
	CLRW	REPORT_MAIN_CHOICE
	PUSHAL	REPORT_MAIN_CHOICE
	PUSHAL	MENU_STRUCT
	CALLS	#2,G^SUI_MAKE_MENU
	BLBS	R0,90$				; Assume any error = ^Z
80$:
	PUSHAL	REPORT_DISP                        ; EXIT
	CALLS	#1,G^SMG$DELETE_VIRTUAL_DISPLAY
	PUSHAL	REPORT_DISP2
	CALLS	#1,G^SMG$DELETE_VIRTUAL_DISPLAY
	PUSHAL	REPORT_DISP3
	CALLS	#1,G^SMG$DELETE_VIRTUAL_DISPLAY
	RET
90$:

	CASEW	REPORT_MAIN_CHOICE,#1,#5
100$:
	.WORD	101$-100$
	.WORD	102$-100$
	.WORD	103$-100$
	.WORD	104$-100$
	.WORD	105$-100$
	.WORD	106$-100$
	RET
101$:
	CALLS	#0,G^EMU_RPT_DISPLAY_REPORT
	BRW	10$
102$:
	PUSHAL	TEMPDESC
	CALLS	#1,G^EMU_RPT_GETPFILE 
        BLBS	R0,1021$
	BRW	10$
1021$:
	PUSHAL	RPTPRM_A
	PUSHAL	TEMPDESC
	PUSHAL	RPTITMCNT
	CALLS	#3,G^EMU_RPT_LOAD
	BLBC	R0,1022$
; Display results
	CALLS	#0,G^EMU_RPT_DISPLAY
1022$:
	BRW	10$
103$:
	CALLS	#0,G^EMU_RPT_CREATE_NEW
	BRW	10$
104$:
	CALLS	#0,G^EMU_RPT_SAVE
	BRW	10$
105$:
; Get file name
	PUSHAL	REPORT_DISP
	CALLS	#1,G^SMG$ERASE_DISPLAY
	PUSHAL	BYTCNT
	PUSHAL	REPORT_DISP
	PUSHAL	FILNAMPRMPT
	CALLS	#3,G^RPT_READ_PROMPT
	BLBC	R0,1051$		; Exit on error
	TSTW	BYTCNT			; Any input?
	BNEQ	1052$ 			; Br if some
1051$:
	BRW	10$                   ; exit if none
1052$:
	PUSHAL	FILCRTMSG
        PUSHAL	REPORT_DISP
	CALLS	#2,G^SMG$PUT_LINE

	MOVZWL	BYTCNT,TEMPDESC
	MOVAL	KB_BUF,TEMPDESC+4
	PUSHAL	TEMPDESC
	PUSHAL	RPTITMCNT
	PUSHAL	RPTPRM_A
	CALLS	#3,G^EMU_RPT_CREATE_REPORT
; Display exit status
	MOVL	#132,FAODESC
	PUSHL	R0
	PUSHAL	FAODESC
	PUSHAL	FAODESC
	PUSHAL	RPTEXMSG
	CALLS	#4,G^SYS$FAO

	PUSHAL	FAODESC
        PUSHAL	REPORT_DISP3
	CALLS	#2,G^SMG$PUT_LINE


	BRW	10$
106$:
	CALLS	#0,G^EMU_RPT_PREDEF
	BRW	10$
;
	.CALL_ENTRY	MAX_ARGS=3, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=EMU_RPT_GETRABSPACE 
;++
;2 EMU_RPT_GETRABSPACE 
;  Create section of size RAB$C_BLN * @4(AP).
;  The number of RABs specified by P1 are coppied from 8(ap) to 
;  the section effectively cloning the RAB the specifed number of times.
;  The file is then opened and all RABS connected.
;  A section sufficient to hold 1 EMUDB rec (768 bytes) per RAB is 
;  also created. 
;3 Inputs
;	.address count of items in RPTITM
;	.address of RAB to clone
;	.address of FAB to open
;3 Outputs
; The section is created and loaded with the RABs
;3 Returns
;  Any from  SYS$EXPREG, SYS$CRMPSC $RMS
;-- 
; Get RAB  mem and init section

	MULL3	@4(AP),#RAB$C_BLN,GBLSIZ   ; Size in bytes
	DIVL	#512,GBLSIZ				     ; Pages
	INCL	GBLSIZ					     ; Round up
; Get Memory
	CLRQ	-(SP)			; p0 space, access mode
	PUSHAL	INADDR			; returned address
	PUSHL	GBLSIZ          	; no. of pages
	CALLS	#4, G^SYS$EXPREG	; Expand process space
	BLBS	R0,110$
	RET
; map section	
110$:
	CLRQ	-(SP)			; pfc, protection
	CLRL	-(SP)			; virtual block number
	PUSHL	GBLSIZ			; no. of pages
	CLRQ	-(SP)			; channel, rel page no.
	CLRL	-(SP)			; version id
	PUSHAL	EMU_RABSEC			; section name
	PUSHL	#<SEC$M_GBL!SEC$M_DZRO!SEC$M_WRT!SEC$M_PAGFIL!SEC$M_SYSGBL>
	CLRL	-(SP)			; access mode
	PUSHAL	RABSEC_A			; returned address
	PUSHAL	INADDR			; in address
	CALLS	#12, G^SYS$CRMPSC	; create section
	BLBS	R0,120$
	RET
120$:
200$:
; init section. For Number specified copy the RAB  to the 
; correct place in the RABSEC just created.
	MOVL	RABSEC_A,R6
        MOVL	@4(AP),R11		; Number of items
210$:
	MOVC3	#RAB$C_BLN,@8(AP),(R6)
        ADDL	#RAB$C_BLN,R6
	SOBGTR	R11,210$
; Open file
	$OPEN	FAB=@12(AP)
	BLBS	R0,300$
	RET
300$:
; Connect all rabs
	MOVL	RABSEC_A,R6
        MOVL	@4(AP),R11		; Number of items
310$:
	$CONNECT RAB=R6
	BLBC	R0,320$
        ADDL	#RAB$C_BLN,R6
	SOBGTR	R11,310$
	BRW	400$
320$:
	RET

400$:
; Get REC  mem 

	MULL3	@4(AP),#DB_REC_C_MRS,GBLSIZ    	; Size in bytes
	DIVL	#512,GBLSIZ			; Pages
	INCL	GBLSIZ				; Round up
; Get Memory
	CLRQ	-(SP)			; p0 space, access mode
	PUSHAL	INADDR			; returned address
	PUSHL	GBLSIZ          	; no. of pages
	CALLS	#4, G^SYS$EXPREG	; Expand process space
	BLBS	R0,410$
	RET
; map section	
410$:
	CLRQ	-(SP)			; pfc, protection
	CLRL	-(SP)			; virtual block number
	PUSHL	GBLSIZ			; no. of pages
	CLRQ	-(SP)			; channel, rel page no.
	CLRL	-(SP)			; version id
	PUSHAL	EMU_RECSEC			; section name
	PUSHL	#<SEC$M_GBL!SEC$M_DZRO!SEC$M_WRT!SEC$M_PAGFIL!SEC$M_SYSGBL>
	CLRL	-(SP)			; access mode
	PUSHAL	RECSEC_A			; returned address
	PUSHAL	INADDR			; in address
	CALLS	#12, G^SYS$CRMPSC	; create section
	BLBS	R0,420$
	RET
420$:
	MOVL	#SS$_NORMAL,R0
	RET

	.CALL_ENTRY	MAX_ARGS=1, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=EMU_RPT_GETRSPACE 
;++
;2 EMU_RPT_GETRSPACE 
;  Create section of size RPT_SEC_C_SIZE(256 Bytes) * RPTITMCNT to store 
;  results of paramater retrievals. 1 instance of each param that 
;  exists for the current boxid is stored here. 
;  Init the section with params from PRM section.
; Also init the dynamic control string with 1x '!AD,' per item
; And inits the instance table
;3 Inputs
;	.address count of items in RPTITM
;3 Outputs
; The reporting section is created and initalized.
; The dynamic record string is created
; The instance table is initalised
;3 Returns
;  Any from  SYS$EXPREG, SYS$CRMPSC
;-- 
; Get mem and init section

	MULL3	@4(AP),#RPT_SEC_C_SIZE,GBLSIZ   ; Size in bytes
	DIVL	#512,GBLSIZ				     ; Pages
	INCL	GBLSIZ					     ; Round up
; Get Memory
	CLRQ	-(SP)			; p0 space, access mode
	PUSHAL	INADDR			; returned address
	PUSHL	GBLSIZ          	; no. of pages
	CALLS	#4, G^SYS$EXPREG	; Expand process space
	BLBS	R0,110$
	RET
; map section	
110$:
	CLRQ	-(SP)			; pfc, protection
	CLRL	-(SP)			; virtual block number
	PUSHL	GBLSIZ			; no. of pages
	CLRQ	-(SP)			; channel, rel page no.
	CLRL	-(SP)			; version id
	PUSHAL	EMU_RPTSEC			; section name
	PUSHL	#<SEC$M_GBL!SEC$M_DZRO!SEC$M_WRT!SEC$M_PAGFIL!SEC$M_SYSGBL>
	CLRL	-(SP)			; access mode
	PUSHAL	RPTSEC_A			; returned address
	PUSHAL	INADDR			; in address
	CALLS	#12, G^SYS$CRMPSC	; create section
	BLBS	R0,120$
	RET
120$:
200$:
; init section. For each entry in RPTPRM_A copy the tbl.param.pid to the 
; correct place in the RPTSEC just created.
	MOVL	RPTPRM_A,R6
	MOVL	RPTSEC_A,R7
        MOVL	RPTITMCNT,R11		; Number of items
210$:
	MOVL	RPT_PRM_L_TBL(R6),RPT_SEC_L_TBL(R7)
	MOVL	RPT_PRM_L_PARAM(R6),RPT_SEC_L_PARAM(R7)
	MOVL	RPT_PRM_L_PROTID(R6),RPT_SEC_L_PROTID(R7)
        ADDL	#RPT_PRM_C_ITMSIZ,R6
	ADDL	#RPT_SEC_C_SIZE,R7
	SOBGTR	R11,210$
; Control string
; This string  translates each record, There is 1 '!AD,' per param.
; processing builds a list of params and formats it though $FAO such that
; any missing param produces ',' and any present produce 'xxxx,'
	MOVAL	DYNCTLSTR,R6
	MOVL	RPTITMCNT,R11
	MOVL	BOXIDITM,(R6)+			; Fixed param 1
300$:
	MOVL	DYNITM,(R6)+
	SOBGTR	R11,300$
	MULL3	RPTITMCNT,#4,DYNCTLDESC		; Set len
	ADDL	#4,DYNCTLDESC			; Include fixed param 1
; Instance table
; Clear any previous entries
	CLRL	INSTTBLCNT
	MOVAL	INSTTBL,R7
	MOVC5	#0,#0,#0,#INSTTBL_LEN,(R7)
	MOVL	RPTPRM_A,R6

        MOVL	RPTITMCNT,R11		; Number of items
310$:
	CMPL	RPT_PRM_L_TBL(R6),(R7)	; Entry in table?
	BEQL	330$
320$:
	TSTL	(R7)			; Any entry here?
	BNEQ	350$			; br if yes
	MOVL	RPT_PRM_L_TBL(R6),(R7)	; Put entry in table
	INCL	INSTTBLCNT              ; Count it
330$:
	MOVAL	INSTTBL,R7              ; Reset to top
        ADDL	#RPT_PRM_C_ITMSIZ,R6
	SOBGTR	R11,310$
	MOVL	#SS$_NORMAL,R0
	RET
350$:
	ADDL	#8,R7
	BRW	310$

	.CALL_ENTRY	MAX_ARGS=1, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=EMU_RPT_GETPSPACE 
;++
;2 EMU_RPT_GETPSPACE 
;  Create section of size RPT_PRM_SECSIZ (16 pages) to store selected params
;  Format is same as for report param file. If saved, this section is 
; written to file.
;3 Inputs
;	Addr of quad 1st and last addresses of created section
;3 Outputs
;	Section is created
;	1st and last Vaddresses are written to P2
;3 Returns
;  Any from  SYS$EXPREG, SYS$CRMPSC
;-- 

; Get mem for param storage.

	CLRQ	-(SP)			; p0 space, access mode
	PUSHAL	INADDR			; returned address
	PUSHL	#RPT_PRM_C_SECSIZ       ; no. of pages
 	CALLS	#4, G^SYS$EXPREG	; Expand process space
	BLBS	R0,10$
	RET
10$:
; map section	
	CLRQ	-(SP)			; pfc, protection
	CLRL	-(SP)			; virtual block number
	PUSHL	#RPT_PRM_C_SECSIZ       ; no. of pages
 	CLRQ	-(SP)			; channel, rel page no.
	CLRL	-(SP)			; version id
	PUSHAL	EMU_RPTPRM			; section name
	PUSHL	#<SEC$M_GBL!SEC$M_DZRO!SEC$M_WRT!SEC$M_PAGFIL!SEC$M_SYSGBL>
	CLRL	-(SP)			; access mode
	PUSHL	4(AP)			; returned address
	PUSHAL	INADDR			; in address
	CALLS	#12, G^SYS$CRMPSC	; create section
	BLBS	R0,20$
	RET
20$:
	MULL3	#512,#RPT_PRM_C_SECSIZ,R1
	DIVL3	#RPT_PRM_C_ITMSIZ,R1,RPTMAXITM  	; Max entries
        CLRL	RPTITMCNT				; None yet
	MOVL	#SS$_NORMAL,R0
	RET

	.CALL_ENTRY	MAX_ARGS=0, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=EMU_RPT_DISPLAY
;++
;2 EMU_RPT_DISPLAY
;  Displays the current report param file in the right screen as:
;   Protocol	ParamName  Flags	Spare
;--
	PUSHAL	REPORT_DISP2
	CALLS	#1,G^SMG$ERASE_DISPLAY

	MOVL	#132,FAODESC
	PUSHL	RPTITMCNT
	PUSHAL	FAODESC
	PUSHAL	FAODESC
	PUSHAL	ITMCNTMSG
	CALLS	#4,G^SYS$FAO

	PUSHAL	FAODESC
        PUSHAL	REPORT_DISP2
	CALLS	#2,G^SMG$PUT_LINE

	MOVL	RPTITMCNT,R11		; Any items to display?
	BNEQ	10$                    ; Br if some
	MOVL	#SS$_NORMAL,R0
	RET
10$:
        TSTW	MAPPERFAB+FAB$W_IFI     ; File open?
	BNEQ    30$                    	; Br if so
	$OPEN	FAB = MAPPERFAB		; Open input file
	BLBS	R0,20$
	RET
20$:
 	$CONNECT RAB = MAPPERRAB		;Connect input stream
	BLBS	R0,30$
	RET
30$:
	MOVL	RPTPRM_A,R6			; top of table
	CLRL	MAPPERRAB+RAB$L_ROP		; No Options
	BISL	#RAB$M_RRL,MAPPERRAB+RAB$L_ROP	; Read if locked
        MOVB	#8,MAPPERRAB+RAB$B_KSZ
	MOVB 	#RAB$C_KEY,MAPPERRAB+RAB$B_RAC  ; Keyed lookup
	CLRB	MAPPERRAB+RAB$B_KRF                 	
	MOVL	RPTPRM_A,R6			; Top of param list
	MOVL	RPTITMCNT,R11			; Count of items
130$:	
	BBC	#RPT_PRMFLG_V_DEL,RPT_PRM_L_FLAGS(R6),135$ ; Br if not deleted
	ADDL	#RPT_PRM_C_ITMSIZ,R6
	BRB	130$
135$:	
	MOVQ	(R6),MAPPER_KEY
	$GET	RAB=MAPPERRAB
	BLBS	R0,140$
	RET					; Should never happen!

140$:
; xlate pid
	PUSHAL	PIDNAM			; outp
	PUSHL	RPT_PRM_L_PROTID(R6)	; Pid 
	CALLS	#2,G^XLATE_PSRID
	BLBS	R0,145$
;
	PUSHAL	BYTCNT
	PUSHAL	REPORT_DISP2
	PUSHAL	XLTPIDERR 
	CALLS	#3,G^RPT_READ_PROMPT
	RET
145$:
; Print this param
	MOVAL	MAPPERREC_BUF,R7
	MOVL	#132,FAODESC
	PUSHL	RPT_PRM_L_MAXLEN(R6)
	PUSHL	RPT_PRM_L_FLAGS(R6)
	ADDL3	R7,#DB_MAP_A64_KEYW,-(SP)
	PUSHL	DB_MAP_L_KEYWLEN(R7)		; Table LEN
	PUSHAL	PIDNAM
	PUSHAL	FAODESC
	PUSHAL	FAODESC
	PUSHAL	RPTPRMRECSTR
	CALLS	#8,G^SYS$FAO
	BLBS	R0,150$
150$:
	PUSHAL	FAODESC
        PUSHAL	REPORT_DISP2
	CALLS	#2,G^SMG$PUT_LINE
160$:
	ADDL	#RPT_PRM_C_ITMSIZ,R6
	SOBGTR	R11,170$
;
	MOVL	#SS$_NORMAL,R0
	RET
170$:
	BRW	130$


	.CALL_ENTRY	MAX_ARGS=0, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=EMU_RPT_WRITE_TITLES
;++
;2 EMU_RPT_WRITE_TITLES
;  Formats param file items into titles used in report as :
;  ' Protocol ParamName'
;   There is 1 title /entry. The pointers (len and addr) are held in
;   titlelist, and the translated strings in title_strings. This routine
;   builds these areas and the caller may then simply print them any number
;   of times therafter.
;3  Input
;   No params passed in. All I/O is hardcoded in this routine.
;   Areas Used:
;   report param section
;   MAPPER.dat 
;3 Output
;  The titles are translated into TITLES_STRINGS, and the pointers are
;  held in TITLELIST. Passing TITLLIST and the dynamic control string
;  build in GETRSPACE will produce 1 line of comma seperated titles.
;3 Returns
;  Any from $RMS, $FAO
;--

	MOVL	RPTITMCNT,R11		; Any items to display?
	BNEQ	10$                    ; Br if some
	MOVL	#SS$_NORMAL,R0
	RET
10$:
        TSTW	MAPPERFAB+FAB$W_IFI     ; File open?
	BNEQ    30$                    	; Br if so
	$OPEN	FAB = MAPPERFAB		; Open input file
	BLBS	R0,20$
	RET
20$:
 	$CONNECT RAB = MAPPERRAB		;Connect input stream
	BLBS	R0,30$
	RET
30$:
	MOVAL	TITLELIST,R8			; Pointers here
	MOVAL	TITLE_STRINGS,R9		; Strings
	MOVL	#TITLE_STRING_LEN,R10		; Max outp space
; Fixed 1st param
	MOVL	#TITLP1_LEN,(R8)+
	MOVAL	TITLP1,(R8)+

	MOVL	RPTPRM_A,R6			; top of table
	CLRL	MAPPERRAB+RAB$L_ROP		; No Options
	BISL	#RAB$M_RRL,MAPPERRAB+RAB$L_ROP	; Read if locked
        MOVB	#8,MAPPERRAB+RAB$B_KSZ
	MOVB 	#RAB$C_KEY,MAPPERRAB+RAB$B_RAC  ; Keyed lookup
	CLRB	MAPPERRAB+RAB$B_KRF                 	
	MOVL	RPTPRM_A,R6			; Top of param list
	MOVL	RPTITMCNT,R11			; Count of items
130$:	
	BBC	#RPT_PRMFLG_V_DEL,RPT_PRM_L_FLAGS(R6),135$ ; Br if not deleted
	ADDL	#RPT_PRM_C_ITMSIZ,R6
	BRB	130$
135$:	
	MOVQ	(R6),MAPPER_KEY
	$GET	RAB=MAPPERRAB
	BLBS	R0,140$
	RET					; Should never happen!

140$:
; xlate pid
	PUSHAL	PIDNAM			; outp
	PUSHL	RPT_PRM_L_PROTID(R6)	; Pid 
	CALLS	#2,G^XLATE_PSRID
	BLBS	R0,145$
;
	PUSHAL	BYTCNT
	PUSHAL	REPORT_DISP2
	PUSHAL	XLTPIDERR 
	CALLS	#3,G^RPT_READ_PROMPT
	RET
145$:
; Print this param
; Set up outp desc
	MOVL	R10,(R8)		; Len
	MOVL	R9,4(R8)

	MOVAL	MAPPERREC_BUF,R7
	MOVL	#132,FAODESC
	PUSHL	RPT_PRM_L_MAXLEN(R6)
	PUSHL	RPT_PRM_L_FLAGS(R6)
	ADDL3	R7,#DB_MAP_A64_KEYW,-(SP)
	PUSHL	DB_MAP_L_KEYWLEN(R7)		; Table LEN
	PUSHAL	PIDNAM
	PUSHL	R8
	PUSHL	R8
	PUSHAL	RPTTITLESTR
	CALLS	#8,G^SYS$FAO
	BLBS	R0,150$
150$:
; Adjust pointers
	SUBL	(R8),R10		; Len left
	ADDL	(R8),R9                 ; Next string here
	ADDL	#8,R8			; Next pointer here
	

160$:
	ADDL	#RPT_PRM_C_ITMSIZ,R6
	SOBGTR	R11,170$
;
	MOVL	#SS$_NORMAL,R0
	RET
170$:
	BRW	130$









	.CALL_ENTRY	MAX_ARGS=0, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=EMU_RPT_DISPLAY_REPORT
;++
;2 EMU_RPT_DISPLAY_REPORT
; A menu containing all previously CREATED reports is displayed. Any item
; selected causes that report to be displayed in the TPU editor.
;3 Inputs
;  	None
;3 Outputs
;  A new version of the selected report is always created. At edit exit
; user may purge all previous versions.
;3 Returns
;  SS$_NORMAL
;--
; Display all saved files in menu. If any selected open file and 
; load contents into report param area. 
	MULL3	#MAXDYN_ITEMS,#32,TEMPDESC	; Size of array
	MOVAL	DYNMEN,TEMPDESC+4			; Addr

        CLRL	-(SP)                   ; Full file name
	PUSHL	#32			; Return 32 char/file
	PUSHAL	RPTITMCNT		; Number of files
	PUSHAL	TEMPDESC		; Array pointer
	PUSHAL	RPTRESDEF		; type desc
	CALLS	#5,G^FILELIST
	BLBS	R0,210$

; Create menu
210$:
	MOVAL	DYNMEN,MADDR		; Menu location
	MOVW	#32,M_DCS		; SIze of items
	MULL3	#32,RPTITMCNT,MSIZE              ; Total size
 	PUSHAL	REVERSE                 	; Create menu
	PUSHAL	W3                              ; Menu options ...
	CLRL	-(SP)
	PUSHAL	SPACING
	PUSHAL	VERTICAL
	PUSHAL	M_DCS
	PUSHAL	REPORT_DISP
	CALLS	#7,G^SMG$CREATE_MENU            ; 
	BLBS	R0,220$
	RET
220$:
	PUSHAL	CHOICE
	PUSHAL	REPORT_DISP
	PUSHAL	KB_BOARD
	CALLS	#3,G^SMG$SELECT_FROM_MENU
	BLBS	R0,230$
	CLRL    RPTITMCNT
	RET
230$:
	MOVZWL	CHOICE,R11
	DECL	R11
	MULL	#32,R11		; Offset
	MOVAL	DYNMEN,R6	;
	ADDL	R11,R6		; Location of string
	LOCC	#^A/ /,#32,(R6)
	TSTL	R0
	BNEQ	240$
	RET				; ERROR
240$:
; InFile is the full file (with version)
; Outfile is same without version
	SUBL3	R6,R1,R7		
	MOVC3	R7,(R6),TPUFILE			; Move name
        ADDL3	#TPU_DIRSPEC,R7,TPU_INFILE_DESC	; SET SIZE
	MOVQ	TPU_INFILE_DESC,TPU_OUTFILE_DESC
	LOCC	#^A/;/,#32,(R6)         	; Find version
	SUBL3	R6,R1,TPU_OUTFILE_DESC
        ADDL	#TPU_DIRSPEC,TPU_OUTFILE_DESC	; SET SIZE



        PUSHAL	SAVE_ID
	PUSHAL	PB_BOARD
	CALLS	#2,G^SMG$SAVE_PHYSICAL_SCREEN

	PUSHAL	CURSON                    	; Cursor on
	PUSHAL	PB_BOARD
	CALLS	#2, G^SMG$SET_CURSOR_MODE


	PUSHAL	TPU_OUTFILE_DESC 
	PUSHAL	TPU_INFILE_DESC
	CALLS	#2,G^TPU$EDIT

        PUSHAL	SAVE_ID
	PUSHAL	PB_BOARD
	CALLS	#2,G^SMG$RESTORE_PHYSICAL_SCREEN

	PUSHAL	CURSOR_FLAGS                    	; Cursor off
	PUSHAL	PB_BOARD
	CALLS	#2, G^SMG$SET_CURSOR_MODE
; A new file is always created - the call to TPU always sets the buffer as 
; modified. Unless the user 'quits' out, a new version is created.
; Ask user if changes are to be saved (def = yes)
; If no then delete current version
; If yes ask if files should be purged (def = no)
; If yes then delete ;-1 version until no more
	PUSHL	#TRM$M_TM_CVTLOW
	PUSHAL	BYTCNT
	PUSHAL	REPORT_DISP
	PUSHAL	RPTDELCURSTR 
	CALLS	#4,G^RPT_READ_PROMPT
	BLBS	R0,300$
	RET
300$:
	TSTW	BYTCNT
	BEQL	304$
	CMPB	KB_BUF,#^A/N/
	BEQLU	305$
304$:
	BRW	350$
; delete current version
305$:
	MOVQ	TPU_OUTFILE_DESC,R6             ; r6 = ln, r7 = addr
	MOVB	#^A/;/,(R7)[R6]
	MOVL	R7,RPTFAB+FAB$L_FNA             ; File name
	ADDB3	#1,R6,RPTFAB+FAB$B_FNS          ; File name size
	$ERASE	FAB=RPTFAB
	BLBS	R0,320$

	MOVL	#132,FAODESC
	PUSHL	R0
        PUSHAL	FAODESC
	PUSHAL	FAODESC
	PUSHAL	FILDELERR
	CALLS	#4,G^SYS$FAO
	BLBS	R0,310$
	RET
310$:

	PUSHAL	BYTCNT
	PUSHAL	REPORT_DISP
	PUSHAL	FAODESC 
	CALLS	#3,G^RPT_READ_PROMPT
	RET
320$:
	MOVL	#132,FAODESC
	PUSHAL	TPU_OUTFILE_DESC
        PUSHAL	FAODESC
	PUSHAL	FAODESC
	PUSHAL	FILDELSTR
	CALLS	#4,G^SYS$FAO
	BLBS	R0,330$
	RET
330$:

	PUSHAL	BYTCNT
	PUSHAL	REPORT_DISP
	PUSHAL	FAODESC 
	CALLS	#3,G^RPT_READ_PROMPT
	RET
350$:
	PUSHL	#TRM$M_TM_CVTLOW
	PUSHAL	BYTCNT
	PUSHAL	REPORT_DISP
	PUSHAL	RPTPURGESTR 
	CALLS	#4,G^RPT_READ_PROMPT
	BLBS	R0,360$
	RET
360$:
	TSTW	BYTCNT
	BEQL	370$
	CMPB	KB_BUF,#^A/Y/
	BEQLU	380$
370$:
	MOVL	#SS$_NORMAL,R0
	RET
380$:

; delete all -1 versions
	MOVQ	TPU_OUTFILE_DESC,R6             ; r6 = ln, r7 = addr
	ADDL3	R6,R7,R8
	MOVL	PURVER,(R8)			; Set version to ;-1
	MOVL	R7,RPTFAB+FAB$L_FNA             ; File name
	ADDB3	#3,R6,RPTFAB+FAB$B_FNS          ; File name size
	CLRL	R9				; Delete count
390$:
	$ERASE	FAB=RPTFAB
	BLBC	R0,400$
	INCL	R9
	BRB	390$


400$:
	MOVL	#132,FAODESC
	PUSHL	R9
        PUSHAL	FAODESC
	PUSHAL	FAODESC
	PUSHAL	RPTDELCNTSTR
	CALLS	#4,G^SYS$FAO
	BLBS	R0,410$
	RET
410$:

	PUSHAL	BYTCNT
	PUSHAL	REPORT_DISP
	PUSHAL	FAODESC 
	CALLS	#3,G^RPT_READ_PROMPT
	RET



	.CALL_ENTRY	MAX_ARGS=5, -
			HOME_ARGS=TRUE, - 
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=RPT_READ_PROMPT 


;2 RPT_READ_PROMPT
; Displays the prompt specified by the input on the specified 
; display, waits for user input and returns the input in KB_BUF.
;	
;3 Input
;	P1. address of desc pointing to ascii string to display
;	P2. address of display
;	P3. address of bytcnt, where READ_STRING writes the count 
;	    of user input bytes.
;	P4. address of case flag. Optional. May be 1 of:
;		0		Not uppercased
;		TRM$M_TM_CVTLOW Uppercased
;	P5. Address of desc pointing to where READ_STRING 
;	    places the user input. If not present input is 
;	    placed in KB_BUF
;3 Output
;	The prompt is displayed on the specified display
;	Any user input is returned in KB_BUF
;
;3 Return
;	Any return from SMG$READ_STRING
;--
		MOVL	#TRM$M_TM_CVTLOW,RPCASE	; Set def		
		MOVAL	KB_DES,R6		; Set def outp
		CMPL	#4,(AP)                  ; Present?
		BGTR	20$			; No options
		MOVL	16(AP),RPCASE		; Set case
;
		CMPL	#5,(AP)                  ; Present?
		BNEQ	20$			; Br if not
		MOVL	20(AP),R6               ; Set oupt
20$:
		PUSHL	8(AP)                   ; Output display
		CLRL	-(SP)                   ; Blank 
		PUSHL	12(AP)                  ; Bytes to display
		CLRL	-(SP)                   ; Blank 
		CLRL	-(SP)                   ; Blank 
		PUSHAL	RPCASE                  ; Case 
		CLRL	-(SP)                   ; Blank 
		PUSHL	4(AP)                 	; Output DSC
		PUSHL	R6                      ; Input buf
		PUSHAL	KB_BOARD                ; Input ID
		CALLS	#10,G^SMG$READ_STRING
		RET                             ; Any error handled by caller
		  




	.CALL_ENTRY	MAX_ARGS=0, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=EMU_RPT_CREATE_NEW 
;++
;2 EMU_RPT_CREATE_NEW
;  Create new report param file. Params are selected from menu and added
; to the section. The section can be saved using EMU_RPT_SAVE.
;3 Inputs
;	None
;3 Outputs
;	RPTPRM section is cleared at begin and selectied items are then added
;	Current items is cleared then incermented for each add
;	If existing item is selected again, option to modify or delete
;	is offered
;3 Returns
;  Any from  SYS$EXPREG, SYS$CRMPSC
;-- 
	TSTL	RPTPRM_A
	BNEQ	100$
	PUSHAL	RPTPRM_A
	CALLS	#1,G^EMU_RPT_GETPSPACE
	BLBS	R0,100$
	RET
100$:
	CLRL	RPTITMCNT

110$:
; Get the table to list
	PUSHAL	PARAMTBL
	CALLS	#1,G^EMU_RPT_GETTABLE
	BLBS	R0,200$
	RET
200$:
; Got table. 

; Get params and put in menu
; As the table came from MAPPER is is safe to ASSUME it is open
;
	MOVB 	#RAB$C_KEY,MAPPERRAB+RAB$B_RAC
	BISL	#RAB$M_RRL,MAPPERRAB+RAB$L_ROP	; Read if locked
	MOVB 	#1,MAPPERRAB+RAB$B_KRF
	MOVB 	#4,MAPPERRAB+RAB$B_KSZ
	MOVAL	MAPPERREC_BUF,R6                      ; Key (rec) buf
	MOVL	PARAMTBL,DB_MAP_L_TBL(R6)             ; Set tabl
        CLRL	R11
	MOVAL	DYNCHOICE,R8
	MOVAL	DYNMEN,R7   			; Menu items

220$:
	$GET	RAB=MAPPERRAB
    	BLBS	R0,230$
	BRW	300$
230$:
; Place index in choice tbl, string in menu.
	CMPL	PARAMTBL,DB_MAP_L_TBL(R6)
	BEQLU	235$
	BRW	300$
235$:
; Check if too many items
	INCL	R11
	CMPL	R11,#MAXDYN_ITEMS
	BLEQ	240$
	MOVL	#SS$_BUFFEROVF,R0
	RET
240$:
	MOVC5	DB_MAP_L_KEYWLEN(R6),DB_MAP_A64_KEYW(R6),#^A/ /,#48,(R7)
	ADDL	#48,R7
	MOVQ	(R6),(R8)+
	CMPL	#1,R11
	BNEQ	220$
; Change to seq access on 2nd and subsequent reads
	MOVB 	#RAB$C_SEQ,MAPPERRAB+RAB$B_RAC
	BRW	220$
300$:
; Calc menu size
	MULL	#48,R11
	BNEQ	305$
; If recs for this table are not in MAPPER then inform user - can't report
	PUSHAL	BYTCNT
	PUSHAL	REPORT_DISP2
	PUSHAL	CANTRPTMSG 
	CALLS	#3,G^RPT_READ_PROMPT
	BRW	110$
305$:
	MOVW	#48,M_DCS			; Item size
	MOVAL	DYNMEN,MADDR
	MOVL	R11,MSIZE
	pushal	cursor_flags                    ; Turn cursor off
	pushal	PB_BOARD
	calls	#2, g^smg$set_cursor_mode
	BSBW	RPT_ERROR_CHK
310$:
 	PUSHAL	REVERSE                 	; Create menu
	PUSHAL	W3                              ; Menu options ...
	CLRL	-(SP)
	PUSHAL	SPACING
	PUSHAL	VERTICAL
	PUSHAL	M_DCS
	PUSHAL	REPORT_DISP
	CALLS	#7,G^SMG$CREATE_MENU            ; 
	BSBW	RPT_ERROR_CHK
	PUSHAL	PRM_CHOICE
	PUSHAL	PRM_CHOICE
	PUSHAL	REPORT_DISP
	PUSHAL	KB_BOARD
	CALLS	#4,G^SMG$SELECT_FROM_MENU
	BLBS	R0,320$			; Assume any error = eof
	BRW	110$
320$:
	MOVZWL	PRM_CHOICE,R1
	DECL	R1
	MOVAL	DYNCHOICE,R8                    ; Index
	MULL	#8,R1
	ADDL	R1,R8
; Process the selected param
	PUSHL	R8				; Addr of param
	CALLS	#1,G^EMU_RPT_PROC_PARAM	; Do it
	BRW	310$

	.CALL_ENTRY	MAX_ARGS=1, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=EMU_RPT_PROC_PARAM 
;++
;2 EMU_RPT_PROC_PARAM
;  Process a selected paramater into the report pram list. 
;  Possible actions:
;	Param is not in list - add it
;	Param is in list - delete it. 
;3 Inputs
;	.address of .quad tbl.param
;3 Outputs
;	report param list section may be modified
;3 Returns
;-- 
	MOVL	4(AP),R8		; Param
	MOVL	RPTPRM_A,R6		; List
	MOVL	RPTITMCNT,R11		; Items
	BEQL	220$			; Br if none
	CLRL	R10			; Save deleted space here
100$:
	BBC	#RPT_PRMFLG_V_DEL,8(R6),110$	; Br if not deleted
	MOVL	R6,R10				; Save deleted space
	ADDL	#RPT_PRM_C_ITMSIZ,R6
	BRB	100$
110$:
	CMPL	(R6),(R8)
	BNEQU	120$
	CMPL	4(R6),4(R8)
	BEQLU	300$

120$:
	ADDL	#RPT_PRM_C_ITMSIZ,R6
	SOBGTR	R11,100$
	BRW	200$

200$:
; Item does not exist - add it
	TSTL	R10			; Deleted space?
	BEQL	210$
	MOVL	R10,R6			; Replace with deleted
210$:
	CMPL	RPTITMCNT,RPTMAXITM
	BLSSU	220$
	MOVL	#SS$_BUFFEROVF,R0
	RET
220$:
	INCL	RPTITMCNT		; Items
	MOVQ	(R8),(R6)
	CLRQ	RPT_PRM_L_FLAGS(R6)     ; Clear opts
;Get associated pid and store it.
             
	ADDL3	#RPT_PRM_L_PROTID,R6,-(SP)
	PUSHL	(R8)
	CALLS	#2,G^XLATE_TBL2PID
	BLBS	R0,230$
	PUSHAL	BYTCNT
	PUSHAL	REPORT_DISP2
	PUSHAL	TBL2PIDERR 
	CALLS	#3,G^RPT_READ_PROMPT
	RET
230$:

	CALLS	#0,G^EMU_RPT_DISPLAY
	RET

300$:
; Item exists - Ask user for modifications/delete
;	PUSHAL	BYTCNT
;	PUSHAL	REPORT_DISP2
;	PUSHAL	MAXLENPRMPT 
;	CALLS	#3,G^RPT_READ_PROMPT
;	BLBS	R0,310$
;	BRW	400$
;310$:
;	TSTW	BYTCNT
;	BEQL	320$
;	CVTWL	BYTCNT,KB_DES		; Reset Len
;
;	ADDL3	RPT_PRM_L_MAXLEN,R6,-(SP) ; Output
;	PUSHAL	KB_DES			; Input
;	CALLS	#2,G^OTS$CVT_TU_L	; Convert to Bin
;	MOVL	#80,KB_DES		; Rest Len
;	BLBC	R0,300$			; On error try again
;	BISL	#RPT_PRMFLG_M_MLS,RPT_PRM_L_FLAGS(R6)    ; Signal set
;320$:
;	PUSHL	#TRM$M_TM_CVTLOW			; Uppercase
;	PUSHAL	BYTCNT
;	PUSHAL	REPORT_DISP2
;	PUSHAL	RPTDELSTR
;	CALLS	#4,G^RPT_READ_PROMPT
;	BLBS	R0,330$
;	BRW	400$
;330$:
;	TSTW	BYTCNT
;	BEQL	340$
;        CMPB	#^A/Y/,KB_BUF
;	BNEQ	340$
	BISL	#RPT_PRMFLG_M_DEL,RPT_PRM_L_FLAGS(R6)    ; delete
        DECL	RPTITMCNT
340$:
400$:
	CALLS	#0,G^EMU_RPT_DISPLAY
	RET

	.CALL_ENTRY	MAX_ARGS=4, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=EMU_RPT_CREATE_REPORT 
;++
;2 EMU_RPT_CREATE_REPORT
;  Create report from report param file. 
;3 Inputs
;	.address of .quad 1st and last address of RPTPRM section. Must
;	have been previously created/loaded.
;	.address of .long number of items in RPTPRM
;	.address of desc pointing to output filename. Optional. if missing
;	defaults to EMU5_ROOT:[RPT]EMU_RPT.RPT
;	.long interactive interactive flag. If present, stats are not
;	kept or displayed. Used when calling this routine from DCL
;	interface.
;3 Outputs
;	Report file is created. Format is 1 instance per param per rec as
;	'|' seperated list with the boxid as 1st paramater. 
;3 Description
;	A VM section is created of size (No. of items in RPTPRM*RAB$C_BLN)+1
;	and this section is initalised with 1 copy of the EMUDBRAB /param.
;	This allows each param to be selected in the order necessary for 
;	output.
;
;	Another VM section is created of size (No. of items *RPT_SEC_C_SIZE)
;	To store intermdediate results and signals to other processing
;	any further actions to take. See EMU_RPT_GETRSPACE.
;	
;	The instance table is set up. This table tracks the current 
;	instance in any table. It is used to align params that may 
;	appear many times in one box.table combination.
;	At init (here) the table is loaded with 1 instance of each 
;	table in the RTPPRM section. (that is if a table appears more
;	than once there it appears only once here). Each entry is a quad
;	with the table as the 1st long and the current instance as the 2nd.
;	When a param is read that has an instance (not all do) the table is
;	checked. If the instance has not been set, it is set. If it has been
;	set, the current rec is checked for match. If not the read is 
;	'defferred'. That is each time this param is read this rec will be 
;	returned until it is used. If match then process param.
;
;	The RPTITM section is scanned for each entry in RELATER and 
;	the next param is read. For each matching param, it is formatted
;	into RTPSEC and after each single pass of RPTITM, a line is 
;	written with all params found. If no params were found, the next
;	RELATER rec is accessed and procedure loops until no more 
;	RELATER entries. The resulting display (in Excel) should look 
;	something like:
; 
;Box ID  DECnet IV|DECnet V   |SCS Address|SCS Name|Lan Address | IP Addr |Name
;  201   1.1     49:00 ...   08-00-2b... CCCIx    08-00-2b...   1.2.3.4  CCCI4
;  201           49:01 ...                        AA-00-04...   1.2.3.5  ccci4.com
;  201							    1.2.3.6
;  201							    1.2.3.7
;  302   1.2     49:00 ...   08-00-2b... CCCIx    08-00-2b...            CCCI2
;  302           49:01 ...                        AA-00-04...            CCCI2
;	
;	The actual output is a '|' seperated list that can be easily
;	processed further for content and/or format.
;3 Returns
;	SS$_ITEMNOTFOUND	NUMBER OF ITEMS INPUT WAS = 0
;  Any from  SYS$EXPREG, SYS$CRMPSC
;-- 

	MOVL	@8(AP),RPTITMCNT
	BNEQ	10$
	MOVL	#SS$_ITEMNOTFOUND,R0
	RET

10$:
	MOVQ	@4(AP),RPTPRM_A			; Ensure variable is present..
						; ..If called from DCL interface
	CMPL	#4,(AP)				; Interactive?
	BEQLU	15$                             ; Br if not
; Set up counts
	PUSHL	#1 				; Init stats
	CALLS	#1,G^EMU_RPT_DISPSTATS
; Get mem
15$:
	PUSHAL	RPTITMCNT
	CALLS	#1,G^EMU_RPT_GETRSPACE
	BLBS	R0,20$
	RET
20$:
40$:
	MOVQ	@12(AP),R6
	MOVL	R7,RPTFAB+FAB$L_FNA
	MOVB	R6,RPTFAB+FAB$B_FNS

; Create output file 
	$CREATE	FAB=RPTFAB
	BLBS	R0,50$
	BRW	1000$
50$:
	$CONNECT RAB=RPTRAB
	BLBS	R0,60$
	BRW	1000$
60$:
	PUSHAL	EMUDBFAB
	PUSHAL	EMUDBRAB
	PUSHAL	RPTITMCNT
	CALLS	#3,G^EMU_RPT_GETRABSPACE
	BLBS	R0,70$
	BRW	1000$
70$:


140$:
; Write titles
; Set up string
	CALLS	#0,G^EMU_RPT_WRITE_TITLES	; Sets up title strings
; Make temp adjustment to Control string
	MOVL	DYNITM,DYNCTLSTR			; Change to string

	MOVL	#1024,RPTDESC			; Max size
	PUSHAL	TITLELIST
	PUSHAL	RPTDESC
	PUSHAL	RPTDESC
	PUSHAL	DYNCTLDESC
	CALLS	#4,G^SYS$FAOL
	BLBS	R0,145$
	BRW	1000$
145$:
	MOVW	RPTDESC,RPTRAB+RAB$W_RSZ
	$PUT	RAB=RPTRAB
	BLBS	R0,150$
	BRW	1000$
	
150$:	
; Undo temp adjustment to Control string
	MOVL	BOXIDITM,DYNCTLSTR			; Change to string
; Map all sections. Any section unavailable will not be represented in the 
; final report. 

	PUSHAL	DBTBL_DESC
	CALLS	#1,MAP_ALL_DB

210$:
	CLRL	FAOLIST				; No ids yet
	MOVAL	MAPRELATER,R6			; 
	MOVL	SUI_QRY_Q_DBASE(R6),R9		; Top of table
	MOVL	COM_DBHDR_L_ENTRIES(R9),RELENTCNT	; Entries
	BNEQ	220$				; br if Some
	CLRL	R1				; No pointer
	MOVL	#SS$_ITEMNOTFOUND,R0		; 
	BRW	1000$				; Clear up and exit
220$:
; R6 = Current relater rec
; R8 = relater entries remaining
	ADDL3	#RLT_C_RECSIZE,R9,R6                	; 1st entry
300$:
; Here at start of new rec
	BBC	#SYS_COM_V_DELETE,COM_HDR_L_SYSCTL(R6),320$ ; Br if not deleted
310$:
	ADDL	#RLT_C_RECSIZE,R6				; Next entry
	SOBGTR	RELENTCNT,300$
	MOVL	#SS$_NORMAL,R0
	BRW	1000$				; Clear up and exit
320$:
; R6 = Current relater rec
; R7 = relater rec size
; R8 = relater entries remaining
; R9
; R10 = CURRENT RPT structure
; R11 = Items left to process
	INCL	FAOLIST				; New boxid
	MOVL	RPTSEC_A,R10
	MOVL	RPTITMCNT,R11
330$:
; Init all fields
	CLRL	RPT_SEC_L_STA(R10)		; Init Status
	CLRL	RPT_SEC_L_RECCNT(R10)		; No recs
	CLRL	RPT_SEC_L_INST(R10)		; No instance
	CLRL	RPT_SEC_L_FLAG(R10)		; No flag
	CLRL	RPT_SEC_L_LEN(R10)		; No data
        ADDL	#RPT_SEC_C_SIZE,R10		; Next 
        SOBGTR	R11,330$       			; Loop for all
; 
	ADDL3	#RLT_DB_TL_BOXIDS,R6,R7         ; BOXID Table


400$:
; Scan down RPTSEC and for each param check if this box has a 
; boxid in PID location sepecified by RPT_SEC_L_PROTID;
; That is to say - does this box run this protocol?
; Reset all Instances
	MOVAL	INSTTBL,R4
        MOVL	INSTTBLCNT,R11		; Number of items
405$:
	CLRL	4(R4) 
        ADDL	#8,R4
	SOBGTR	R11,405$

	MOVL	RPTSEC_A,R10
	CLRL	R11			; Loop control
410$:
	MOVL	RPT_SEC_L_PROTID(R10),R9
	TSTL	(R7)[R9]		; BOXID here?
	BNEQ	430$			; Br if present

420$:
        ADDL	#RPT_SEC_C_SIZE,R10		; Next 
	AOBLSS	RPTITMCNT,R11,410$
	BRW	500$				; Finished this Scan
430$:
; Get next rec this box,tbl,param. If current status is SUCCESS 
; or INIT (0) then there may be more items. If not - skip.
	TSTL	RPT_SEC_L_STA(R10)
	BEQL	435$				; BR  if INIT
	BLBC	RPT_SEC_L_STA(R10),420$		; Br if not good
	CLRL	RDSTA				; Assume normal read
	CMPL	#SS$_NORMAL,RPT_SEC_L_STA(R10)	; Was normal?
	BEQLU	435$				; Br if was
	MOVL	#1,RDSTA			; Force re-read
435$:
; Set boxid. The tbl.param has been set by section init. This completes
; the EMUDB key. 
	MOVL	(R7)[R9],RPT_SEC_L_BOXID(R10)	; Set BOXID 
;
; Copy key to keybuf
440$:
; Determine outp rec
	MOVL	RECSEC_A,R1      			; REC Table
	MULL3	#DB_REC_C_MRS,R11,R2                    ; Offset to this one
	ADDL3	R1,R2,EMUDBREC_BUF_DESC+4                 ; REC addr

	MOVL	EMUDBREC_BUF_DESC+4,R8

; Determine RAB
	MOVL	RABSEC_A,R1      			; RAB Table
	MULL3	#RAB$C_BLN,R11,R2                       ; Offset to this one
	ADDL	R1,R2                                   ; RAB addr
; Determine read status
; If last read on this RAB was for this BOX,TBL,Param but NOT instance
; then return this rec again (no read).
	MOVZWL	RAB$W_RSZ(R2),EMUDBREC_BUF_DESC		; Reset len
	MOVL	#SS$_NORMAL,R0				; Simulate good read
	TSTL	RDSTA                                   ; If next rec read...
	BNEQ	445$                                    ;    Skip read
; Set Key
	MOVQ	RPT_SEC_L_PROTID(R10),(R8)
	MOVQ	RPT_SEC_L_TBL(R10),8(R8)
	MOVQ	RPT_SEC_L_PARAM(R10),16(R8)
	MOVL	#DB_REC_C_MRS,EMUDBREC_BUF_DESC         ; Reset desc
; Read

	PUSHL	RDSTA					; Read status
	PUSHL	R2
	ADDL3	#RPT_SEC_L_RECCNT,R10,-(SP)		; Record count
	PUSHAL	EMUDBREC_BUF_DESC			; Write rec here
	CALLS	#4,G^EMU_RPT_READ

; Check if wanted rec before error check
445$:
	CMPL	RPT_SEC_L_BOXID(R10),DB_REC_L_BOXID(R8)
	BNEQ	450$
	CMPL	RPT_SEC_L_TBL(R10),DB_REC_L_TABLE(R8)
	BNEQ	450$
	CMPL	RPT_SEC_L_PARAM(R10),DB_REC_L_PARAM(R8)
	BNEQ	450$
	BLBS	R0,460$

450$:
	MOVL	#SS$_ITEMNOTFOUND,RPT_SEC_L_STA(R10)
	CLRL	RPT_SEC_L_LEN(R10)
	BRW	420$
460$:
; Check instance
	PUSHL	R8				; Current rec
	CALLS	#1,EMU_RPT_CHECK_INSTANCE
        BLBS	R0,465$                         ; Br if inst match
	CMPL	#SS$_IDMISMATCH,R0              ; Br if Table OK
	BEQLU	463$

	PUSHAL	BYTCNT
	PUSHAL	REPORT_DISP2
	PUSHAL	INSTTBLERR 
	CALLS	#3,G^RPT_READ_PROMPT
	RET

463$:
	MOVL	#SS$_WASSET,RPT_SEC_L_STA(R10)  ; No - reserve read
	CLRL	RPT_SEC_L_LEN(R10)              ; No param
	BRW	420$
        
465$:
	CMPL	#4,(AP)				; Interactive?
	BEQLU	466$                             ; Br if not

	INCL	FRMDB
	CALLS	#0,G^EMU_RPT_DISPSTATS
466$:
; Save key
	MOVQ	(R8),RPT_SEC_L_PROTID(R10)
	MOVQ	8(R8),RPT_SEC_L_TBL(R10)
	MOVQ	16(R8),RPT_SEC_L_PARAM(R10)

; Format this param
; Setup desc in section for this pid
	MOVL	#RPT_SEC_C_MAXDATA,TEMPDESC 		; Max len
	ADDL3	#RPT_SEC_C_DATA,R10,TEMPDESC+4           ; Write here

	PUSHL	PXLTOPT			; Supress keyword, No def xlate
	PUSHL	#RPT_SEC_C_MAXDATA	; Line len
	PUSHAL	LNCNT
	PUSHAL	TEMPDESC
	PUSHAL	EMUDBREC_BUF_DESC
	CALLS	#5,G^PARAMXLT
	CMPL	#SS$_NORMAL,R0
	BEQLU	470$
; On any error print 'error  ' on report
	MOVL	#8,RPT_SEC_L_LEN(R10)		; Len of message
	MOVQ	RPTERRMSG,RPT_SEC_C_DATA(R10)   ; Message
	MOVL	#SS$_NORMAL,RPT_SEC_L_STA(R10)  ; Signal write this param
	BRW	420$				; Next pid
470$:
; Successful xlate:
	MOVL	TEMPDESC,RPT_SEC_L_LEN(R10)	; Len of message
	MOVL	#SS$_NORMAL,RPT_SEC_L_STA(R10)  ; Signal write this param
	BRW	420$


500$:
; Here after each cycle through the report section table
; We have processed each param 1 time and any results are
; in the section.
; Print the line. If no returns will result in blank line
; Check all results. If any success cycle again, else next relater
	MOVL	RPTSEC_A,R10
	CLRL	R11				; Flag
	MOVL	RPTITMCNT,R9                    ;
	MOVAL	FAOLIST,R8
	ADDL	#4,R8				; Skip over fixed param 1	
530$:
        TSTL	RPT_SEC_L_STA(R10)
	BEQL	540$			  	; Br if status was INIT
        BLBC	RPT_SEC_L_STA(R10),540$  	; Br if status was bad
	INCL	R11				; Indicate 1 more good one
540$:
        MOVL	RPT_SEC_L_LEN(R10),(R8)+             ; Len of this param on list
	ADDL3	#RPT_SEC_C_DATA,R10,(R8)+       ; Addr this param on list

        ADDL	#RPT_SEC_C_SIZE,R10		; Next PID
        SOBGTR	R9,530$       ; Loop for all
	TSTL	R11		; ANy params?
	BNEQ	550$		; Br if some
	BRW	310$			; Next relater
550$:
; Format record
	MOVL	#1024,RPTDESC			; Max size
	PUSHAL	FAOLIST
	PUSHAL	RPTDESC
	PUSHAL	RPTDESC
     	PUSHAL	DYNCTLDESC
	CALLS	#4,G^SYS$FAOL
	BLBS	R0,560$
	BRW	1000$
560$:
	MOVW	RPTDESC,RPTRAB+RAB$W_RSZ
	$PUT	RAB=RPTRAB
	BLBS	R0,570$
	BRW	1000$
570$:
	CMPL	#4,(AP)				; Interactive?
	BEQLU	580$                             ; Br if not

	INCL	TORPT
	CALLS	#0,G^EMU_RPT_DISPSTATS
580$:
	BRW	400$			; Cycle
	


1000$:
; Here at exit.
	MOVL	R0,R6	       		; Save exit status
	$CLOSE	FAB=RPTFAB
	$CLOSE	FAB=EMUDBFAB

 	CLRQ	-(SP)          		; No return, no access mode
	PUSHAL	RPTSEC_A      		; Delete these pages
	CALLS   #3,G^SYS$DELTVA		; ASSUME success
	CLRQ	RPTSEC_A      		; Signal deleted

	CLRQ	-(SP)          		; No return, no access mode
	PUSHAL	RPTPRM_A      		; Delete these pages
	CALLS   #3,G^SYS$DELTVA		; ASSUME success
	CLRQ	RPTPRM_A      		; Signal deleted

	CLRQ	-(SP)          		; No return, no access mode
	PUSHAL	RABSEC_A		; Delete these pages
	CALLS   #3,G^SYS$DELTVA		; ASSUME success
	CLRQ	RABSEC_A      		; Signal deleted

	CLRQ	-(SP)          		; No return, no access mode
	PUSHAL	RECSEC_A		; Delete these pages
	CALLS   #3,G^SYS$DELTVA		; ASSUME success
	CLRQ	RECSEC_A      		; Signal deleted

	MOVL	R6,R0
	RET

	.CALL_ENTRY	MAX_ARGS=1, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=EMU_RPT_CHECK_INSTANCE
;++
;2 EMU_RPT_CHECK_INSTANCE
;  Check to ensure that when multiple instances are present, the params
;  are printed in correct order. 
;3 Inputs
;	EMUDB record
;3 Outputs
;	If the instance is not set in the table (=0) then it is 
;	is set by coppying the instance from the rec to the table.
;4 Instance_table
;	A table containing 1 entry per EMU table beinfg processed is 
;	created at init. The table is 1x .long table ID followed by 1
;	x .long current instance. The current instance is cleared 
;	for all entries after each cycle through the RPTPRM section.
;	That is, after each line is prionted in the report.
;3 Returns
;	SS$_NORMAL		Instance matches (or new inst set)
;	SS$_IDMISMATCH		Instance did not match
;	SS$_ITEMNOTFOUND	Big screw up. Did not find table that 
;				has to be here
;-- 
	MOVL	4(AP),R8
	MOVAL	INSTTBL,R7
        MOVL	INSTTBLCNT,R11		; Number of items
310$:
	CMPL	DB_REC_L_TABLE(R8),(R7)   ; This table?
	BEQLU	350$
	ADDL	#8,R7
	SOBGTR	R11,310$
	MOVL	#SS$_ITEMNOTFOUND,R0
	RET
350$:
	TSTL	4(R7)			; Instance set?
	BNEQ	370$			; Br if set
	MOVL	DB_REC_L_INST(R8),4(R7) ; Set it
360$:
        MOVL	#SS$_NORMAL,R0
	RET
370$:
	CMPL	DB_REC_L_INST(R8),4(R7) 
        BEQLU	360$
	MOVL	#SS$_IDMISMATCH,R0
	RET

	.CALL_ENTRY	MAX_ARGS=1, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=EMU_RPT_DISPSTATS
;++
;2 EMU_RPT_DISPSTATS
;  Displays statistics in top display to record progress when 
;  creating new report.
;3 Inputs
;	Init Flag. Optional. If present the counts and display are 
;	cleared and titles written.
;3 Outputs
;	Display on DISP1
;3 Returns
;	Any from $FAO
;-- 
	BLBS	(AP),100$
10$:
	PUSHAL	CURCOL			; Column (1)
	PUSHAL	CURROW			; Row (2)
	PUSHAL	REPORT_DISP3
	CALLS	#3,G^SMG$SET_CURSOR_ABS

	MOVL	#132,FAODESC
	PUSHAL	STATCNT
        PUSHAL	FAODESC
	PUSHAL	FAODESC
	PUSHAL	STATMSG
	CALLS	#4,G^SYS$FAOL
	BLBS	R0,20$
	RET
20$:
	PUSHAL	FAODESC
        PUSHAL	REPORT_DISP3
	CALLS	#2,G^SMG$PUT_LINE
        RET


100$:

	CLRQ	FRMDB

	PUSHAL	REPORT_DISP3
	CALLS	#1,G^SMG$ERASE_DISPLAY
	PUSHAL	STATHDR1
        PUSHAL	REPORT_DISP3
	CALLS	#2,G^SMG$PUT_LINE
	PUSHAL	STATHDR
        PUSHAL	REPORT_DISP3
	CALLS	#2,G^SMG$PUT_LINE
  	BRW	10$


	.CALL_ENTRY	MAX_ARGS=3, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=EMU_RPT_LOAD 
;++
;2 EMU_RPT_LOAD
;  Specified file is opened and loaded into RPTPRM section. 
;3 Inputs
;	.addr item count
;	.addr of desc pointing to report param file name.
;	.addr of quad 1st and last addr of RPTITM secion. If 
;	section does not exist, it is created 
;3 Outputs
;	If RPTITM secion does not exist it is created
;	The specified param file is opened and overwrites any
;	data in RPTITM section.
;	The count of items is returned in P1
;	The quad addresses of section is returned if created
;3 Returns
;  Any from  SYS$EXPREG, SYS$CRMPSC
;-- 
	TSTL	@12(AP)
	BNEQ	10$
	PUSHL	12(AP)
	CALLS	#1,G^EMU_RPT_GETPSPACE
	BLBS	R0,10$
	RET
10$:
        MOVQ	@8(AP),R6
	MOVL	R7,RPTITMFAB+FAB$L_FNA	; Location of name
	MOVB	R6,RPTITMFAB+FAB$B_FNS	; Size of name
	$OPEN	FAB=RPTITMFAB
	BLBS	R0,100$
	RET
100$:
	$CONNECT RAB=RPTITMRAB
	BLBS	R0,110$
	RET
110$:
	MOVW	#RPT_PRM_C_ITMSIZ,RPTITMRAB+RAB$W_RSZ
	MOVW	#RPT_PRM_C_ITMSIZ,RPTITMRAB+RAB$W_USZ
; Loop to READ recs
	MOVL	@12(AP),R11
	MOVL	4(AP),R10
	CLRL	R10
250$:
	MOVL	R11,RPTITMRAB+RAB$L_UBF             ; This rec
	$GET	RAB=RPTITMRAB
	BLBC	R0,260$				; Assume err = EOF
	ADDL	#RPT_PRM_C_ITMSIZ,R11
	AOBLEQ	#RPT_SEC_C_MAXID,R10,250$
	$CLOSE	FAB=RPTITMFAB
	MOVL	#SS$_BUFFEROVF,R0
	RET
260$:
	$CLOSE	FAB=RPTITMFAB
	MOVL	R10,@4(AP)
	MOVL	#SS$_NORMAL,R0
	RET



	.CALL_ENTRY	MAX_ARGS=1, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=EMU_RPT_GETPFILE 
;++
;2 EMU_RPT_GETPFILE
;  Displays menu of previously created param files. If selected, the choice
;  is returned in a desc.
;3 Inputs
;	addr of .quad where desc is written
;3 Outputs
;	the len and address of the choice string is written in the desc.
;3 Returns
;  Any from  SMG$. Note SMG$_EOF indicates no selection made.
;-- 

; Here test if there are any items in PRMSEC. If so confirm overwrite.


	CLRL	RPTITMCNT

; Display all saved files in menu. If any selected open file and 
; load contents into report param area. 
	MULL3	#MAXDYN_ITEMS,#32,TEMPDESC	; Size of array
	MOVAL	DYNMEN,TEMPDESC+4			; Addr


	PUSHL	#32			; Return 32 char/file
	PUSHAL	RPTITMCNT		; Number of files
	PUSHAL	TEMPDESC		; Array pointer
	PUSHAL	RPTFILDEF		; type desc
	CALLS	#4,G^FILELIST
	BLBS	R0,210$

; Create menu
210$:
	MOVAL	DYNMEN,MADDR		; Menu location
	MOVW	#32,M_DCS		; SIze of items
	MULL3	#32,RPTITMCNT,MSIZE              ; Total size
 	PUSHAL	REVERSE                 	; Create menu
	PUSHAL	W3                              ; Menu options ...
	CLRL	-(SP)
	PUSHAL	SPACING
	PUSHAL	VERTICAL
	PUSHAL	M_DCS
	PUSHAL	REPORT_DISP
	CALLS	#7,G^SMG$CREATE_MENU            ; 
	BLBS	R0,220$
	RET
220$:
	PUSHAL	CHOICE
	PUSHAL	REPORT_DISP
	PUSHAL	KB_BOARD
	CALLS	#3,G^SMG$SELECT_FROM_MENU
	BLBS	R0,230$
	CLRL    RPTITMCNT
	RET
230$:
	MOVZWL	CHOICE,R11
	DECL	R11
	MULL	#32,R11		; Offset
	MOVAL	DYNMEN,R4	;
	ADDL	R11,R4		; Location of string
	LOCC	#^A/ /,#32,(R4)
	TSTL	R0
	BNEQ	240$
	RET				; ERROR
240$:
	MOVQ	@4(AP),R6
	MOVL	R4,R7			; Location of name
	SUBL3	R4,R1,R6			; Size of name
	MOVQ	R6,@4(AP)
	MOVL	#SS$_NORMAL,R0
	RET

	.CALL_ENTRY	MAX_ARGS=0, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=EMU_RPT_PREDEF 
;++
;2 EMU_RPT_CREATE_PREDEF
;  Displays further menu of 'canned' reports. Upon selection that report is 
; created
;3 Inputs
;	None
;3 Outputs
;	report
;3 Returns
;  Any from  SYS$EXPREG, SYS$CRMPSC
;-- 
	RET

	.CALL_ENTRY	MAX_ARGS=0, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=EMU_RPT_SAVE 
;++
;2 EMU_RPT_SAVE
;	Saves contents of RPTPRM section to file. File name is set by
;	user - no check for dups. File type is always .RPTP Saved in
;	EMU5_DAT.
;3 Inputs
;	None
;3 Outputs
;	Report param file
;3 Returns
;  Any from  SYS$EXPREG, SYS$CRMPSC
;-- 
;  Save list
	TSTL	RPTITMCNT
	BNEQ	100$
	RET
100$:
	PUSHAL	REPORT_DISP
	CALLS	#1,G^SMG$ERASE_DISPLAY
	PUSHAL	REPORT_DISP
	CALLS	#1,G^SMG$HOME_CURSOR

	PUSHAL	BYTCNT
	PUSHAL	REPORT_DISP
	PUSHAL	PARAMNAMPRMPT
	CALLS	#3,RPT_READ_PROMPT 
	BLBS	R0,110$
	RET
110$:
	TSTW	BYTCNT
	BEQL	100$

; Open the file
	MOVAL	KB_BUF,RPTITMFAB+FAB$L_FNA	; Location of name
	MOVB	BYTCNT,RPTITMFAB+FAB$B_FNS	; Size of name
	$CREATE	FAB=RPTITMFAB
	BLBS	R0,120$
	RET
120$:
	$CONNECT RAB=RPTITMRAB

150$:
	MOVL	RPTPRM_A,R11
	MOVL	RPTITMCNT,R9
	MOVW	#RPT_PRM_C_ITMSIZ,RPTITMRAB+RAB$W_USZ
	MOVW	#RPT_PRM_C_ITMSIZ,RPTITMRAB+RAB$W_RSZ

250$:
	MOVL	R11,RPTITMRAB+RAB$L_UBF             ; This rec
	MOVL	R11,RPTITMRAB+RAB$L_RBF             ; This rec
	$PUT	RAB=RPTITMRAB
	BLBC	R0,260$				; Assume err = EOF
	ADDL	#RPT_PRM_C_ITMSIZ,R11
	SOBGTR	R9,250$
	$CLOSE	FAB=RPTITMFAB
	MOVL	#SS$_NORMAL,R0
	RET
260$:
	MOVL	R0,R6
	$CLOSE	FAB=RPTITMFAB
	MOVL	R6,R0
	RET

	.CALL_ENTRY	MAX_ARGS=1, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=EMU_RPT_GETTABLE 
;++
;2 EMU_RPT_GETTABLE 
; Routine to display all possible tables in a menu and after selection, set
; the chosen table in the DB_MAP_L_TBL field in the input param
;3 Inputs:
;	.address of .long where .long table is written
;3 Outputs:
; 	.long value of the table (symbols in _EMUDBDEF)
;3 Returns:
;	SS$_NORMAL	did it
;	Any from $RMS, $SMG
;--
        TSTW	MAPPERFAB+FAB$W_IFI
	BNEQ    10$
	$OPEN	FAB = MAPPERFAB		;Open input file
	BLBS	R0,5$
	RET
5$:
 	$CONNECT RAB = MAPPERRAB	;Connect input stream
	BLBS	R0,10$
	RET
10$:
        MOVB	#4,MAPPERRAB+RAB$B_KSZ
	MOVB	#1,MAPPERRAB+RAB$B_KRF                 	
	MOVB 	#RAB$C_KEY,MAPPERRAB+RAB$B_RAC
	MOVAL	MAPPERREC_BUF,R6
	MOVL	LVL1TBL,DB_MAP_L_TBL(R6)
	MOVAL	DYNMEN,R7   			; Menu items
	MOVAL	DYNCHOICE,R8                    ; Index
	CLRL	R11
20$:
	$GET	RAB=MAPPERRAB
    	BLBS	R0,30$
	BRW	100$
30$:
; Place index in choice tbl, string in menu.
; Check if too many items
	CMPL	LVL1TBL,DB_MAP_L_TBL(R6)
	BEQLU	35$
	BRW	100$
35$:
	INCL	R11
	CMPL	R11,#MAXDYN_ITEMS
	BLEQ	40$
	MOVL	#SS$_BUFFEROVF,R0
	RET
40$:
	MOVC5	DB_MAP_L_KEYWLEN(R6),DB_MAP_A64_KEYW(R6),#^A/ /,#48,(R7)
	ADDL	#48,R7
	MOVQ	(R6),(R8)+
	CMPL	#1,R11
	BNEQ	20$
; Change to seq access on 2nd and subsequent reads
	MOVB 	#RAB$C_SEQ,MAPPERRAB+RAB$B_RAC
	BRW	20$
100$:
; Calc menu size
	MULL	#48,R11
	MOVW	#48,M_DCS			; Item size
	MOVAL	DYNMEN,MADDR
	MOVL	R11,MSIZE
	pushal	cursor_flags                    ; Turn cursor off
	pushal	PB_BOARD
	calls	#2, g^smg$set_cursor_mode
	BSBW	RPT_ERROR_CHK
 	PUSHAL	REVERSE                 	; Create menu
	PUSHAL	W3                              ; Menu options ...
	CLRL	-(SP)
	PUSHAL	SPACING
	PUSHAL	VERTICAL
	PUSHAL	M_DCS
	PUSHAL	REPORT_DISP
	CALLS	#7,G^SMG$CREATE_MENU            ; 
	BSBW	RPT_ERROR_CHK
	PUSHAL	TBL_CHOICE
	PUSHAL	TBL_CHOICE
	PUSHAL	REPORT_DISP
	PUSHAL	KB_BOARD
	CALLS	#4,G^SMG$SELECT_FROM_MENU
	BLBS	R0,130$			; Assume any error = eof
	RET
130$:
	MOVZWL	TBL_CHOICE,R1
	DECL	R1
	MOVAL	DYNCHOICE,R8                    ; Index
; If the top byte of the .quad @ this choice - 0 then this is the table
	MULL3	#8,R1,R2
	ADDL	R2,R8
        TSTB    7(R8)
	BNEQ	150$
	MOVL	4(R8),@4(AP)
	MOVL	#SS$_NORMAL,R0
	RET
150$:
	MOVB 	#RAB$C_KEY,MAPPERRAB+RAB$B_RAC
	MOVAL	MAPPERREC_BUF,R6
	MOVL	4(R8),DB_MAP_L_TBL(R6)
	MOVL	4(R8),R10
	MOVAL	DYNMEN,R7   			; Menu items
	MOVAL	DYNCHOICE,R8                    ; Index
	CLRL	R11
160$:
	$GET	RAB=MAPPERRAB
    	BLBS	R0,170$
	BRW	200$
170$:
; Place index in choice tbl, string in menu.
; Check if too many items
	CMPL	R10,DB_MAP_L_TBL(R6)
	BEQLU	175$
	BRW	200$
175$:
	INCL	R11
	CMPL	R11,#MAXDYN_ITEMS
	BLEQ	180$
	MOVL	#SS$_BUFFEROVF,R0
	RET
180$:
	MOVC5	DB_MAP_L_KEYWLEN(R6),DB_MAP_A64_KEYW(R6),#^A/ /,#48,(R7)
	ADDL	#48,R7
	MOVQ	(R6),(R8)+
	CMPL	#1,R11
	BNEQ	160$
; Change to seq access on 2nd and subsequent reads
	MOVB 	#RAB$C_SEQ,MAPPERRAB+RAB$B_RAC
	BRW	160$
200$:
; Calc menu size
	MULL	#48,R11
	MOVW	#48,M_DCS			; Item size

	MOVAL	DYNMEN,MADDR
	MOVL	R11,MSIZE
	pushal	cursor_flags                    ; Turn cursor off
	pushal	PB_BOARD
	calls	#2, g^smg$set_cursor_mode
	BSBW	RPT_ERROR_CHK
 	PUSHAL	REVERSE                 	; Create menu
	PUSHAL	W3                              ; Menu options ...
	CLRL	-(SP)
	PUSHAL	SPACING
	PUSHAL	VERTICAL
	PUSHAL	M_DCS
	PUSHAL	REPORT_DISP
	CALLS	#7,G^SMG$CREATE_MENU            ; 
	BSBW	RPT_ERROR_CHK
	PUSHAL	SEC_TBL_CHOICE
	PUSHAL	SEC_TBL_CHOICE
	PUSHAL	REPORT_DISP
	PUSHAL	KB_BOARD
	CALLS	#4,G^SMG$SELECT_FROM_MENU
	BLBS	R0,230$			; Assume any error = eof
	RET
230$:
	MOVZWL	SEC_TBL_CHOICE,R1
	DECL	R1
	MOVAL	DYNCHOICE,R8                    ; Index
; If the top byte of the .quad @ this choice - 0 then this is the table
	MULL3	#8,R1,R2
	ADDL	R2,R8
        TSTB    7(R8)
	BEQL	250$
	BRW	150$
250$:
	MOVL	4(R8),@4(AP)
	MOVL	#SS$_NORMAL,R0
	RET

	.CALL_ENTRY	MAX_ARGS=4, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=EMU_RPT_READ  
;++
;2 EMU_RPT_READ  
; Routine to read from EMUDB. Records are scanned and returned 1 by 1 
; in sort order as specified by the key of reference. 
; Each record is checked against the current privs of the caller
; and if insufficient, the record is (silently) skipped.
; The RECCNT param directs this routine to perform either a keyed read
; (RECCNT = 0) or a seq read. 
; NOTE: The record is unlocked as soon as it is written to the caller's 
; buffer. 
; The key of reference in this routine is fixed as 9, (DB_REC_KEY_BX_TAB_PAR)


;
;3 Inputs
; 1 .long	Output buffer
;   .address of descriptor pointing to buffer where record is written
;   If this is a keyed read (reccnt = 0) the routine expects the key
;   information IN RECORD FORMAT. That is:
;    Protocol	.long 	ignored
;    Boxid	.long   Used
;    Table	.long   Used
;    Instance	.long   Ignored
;    Param	.long   Used
;    Flags	.long   Ignored
;
;    the len of the returned record is written in the descriptor.
;
; 2. .address record count. Count of recs returned kept here. Used to 
;	determine ROP field.
; 3. Address of RAB to use. 
; 4. RFA read. If = 0 then normal read. If = 1 then return last record
;    read
;3 Returns
; R0 = status:
;	SS$_NORMAL	 Record found, filters passed and written to outp
;	SS$_INSFMAP      Could not find map record
;	SS$_BADPARAM	 Unknown key
;   Any error returned by RMS
;
;--
	MOVQ	@4(AP),R6			; Outp
	MOVL	12(AP),R8			; Rab
; Set defaults
	CLRL    RAB$L_ROP(R8) 	        	; Clear all opts
	BISL    #RAB$M_RRL,RAB$L_ROP(R8)        ; Read if read locked
	TSTL	@8(AP)                          ; 1st interation?
	BEQL	5$                              ; Br if yes
	MOVB	#RAB$C_SEQ,RAB$B_RAC(R8)        ; Seq read
	TSTL	16(AP)				; RFA read?
	BEQL	2$				; Br no
	MOVB	#RAB$C_RFA,RAB$B_RAC(R8)        ; RFA read
2$:
	BRW	150$			 
5$:
	MOVB	#RAB$C_KEY,RAB$B_RAC(R8)   	; Indexed read
	MOVAL	KEY_BUF,R2                      ; Fill key buffer
	MOVL	DB_REC_L_BOXID(R7),(R2)+
	MOVL	DB_REC_L_TABLE(R7),(R2)+
	MOVL	DB_REC_L_PARAM(R7),(R2)
        MOVAL	KEY_BUF,RAB$L_KBF(R8)                ; Set key buf
	MOVB	#12,RAB$B_KSZ(R8)               ; Key size
	MOVB	#DB_REC_KEY_BX_TAB_PAR,RAB$B_KRF(R8)   ; Key of reference
	BRW	200$

150$:

200$:
; See if this rec exists
	MOVL	R7,RAB$L_UBF(R8)  		; Buffer addr
	MOVW	R6,RAB$W_USZ(R8)  		; Buffer size
	$GET	RAB=(R8)
	BLBS	R0,210$
	RET					; Return with any error
210$:
; Get map rec for this table.param
	$RELEASE RAB=(R8) 		; Unlock

	PUSHL	RAB$L_UBF(R8)			; Record addr
	CALLS	#1,EMUDB_GETMAP		; Returns pointer in r1
	BLBS	R0,220$                 ; Br if xlate available
  	MOVL	#SS$_INSFMAP,R0
	RET

220$:
; Check privs
	$CHECK_PRIVILEGEW_S PRVADR= DB_MAP_Q_SECURE(R1)    ; Check for priv
	BLBS	R0,230$                          ; Br if priv
;        BRW	200$				 ; Ignore this rec
230$:
	MOVZWL	RAB$W_RSZ(R8),@4(AP)		; Return len
	INCL	@8(AP)				; Count returned record
	MOVL	#SS$_NORMAL,R0
	RET


;
REPORT_CREATE_ENVIRONMENT:
	.JSB_ENTRY	INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			OUTPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

;
; Create Virtual Display
;

; Save the current screen set up. Attempt to set it to 48x132. Restore
; on exit
	CLRL	-(SP)                         ; 1st row
	CLRL	-(SP)                         ; Last row
	PUSHAL	SAVE_DISP		      ; Saved screen ID
	PUSHAL 	PB_BOARD		      ; Our id
	CALLS	#4,G^SMG$SAVE_PHYSICAL_SCREEN
	BLBS	R0,30$
	RET
30$:
; 
	CLRL	-(SP)                         ; No colour change
	CLRL	-(SP)                         ;      "
	PUSHAL	REPORT_ROWS	      	      ; Actual height set
	PUSHAL	SCR_HEIGHT		      ; Try for 48
	PUSHAL	REPORT_COLS			      ; Actual wid
	PUSHAL  SCR_WID			      ; Try 132
	PUSHAL	PB_BOARD
	CALLS	#7,G^SMG$CHANGE_PBD_CHARACTERISTICS
	BLBS	R0,40$
	RET
40$:
	SUBL	#5,REPORT_ROWS			; Set our page len
	MOVL	REPORT_ROWS,REPORT_ROW2			; Set our page len



	PUSHAL	BORDER
	PUSHAL	REPORT_DISP
	PUSHAL	REPORT_COLS
        PUSHAL	REPORT_ROWS
	CALLS	#4,G^SMG$CREATE_VIRTUAL_DISPLAY
	BSBW	RPT_ERROR_CHK            		; Error Check
	PUSHAL	BORDER
	PUSHAL	REPORT_DISP2
	PUSHAL	REPORT_COL2
        PUSHAL	REPORT_ROW2
	CALLS	#4,G^SMG$CREATE_VIRTUAL_DISPLAY
	BSBW	RPT_ERROR_CHK
	PUSHAL	BORDER
	PUSHAL	REPORT_DISP3
	PUSHAL	REPORT_COL3
        PUSHAL	REPORT_ROW3
	CALLS	#4,G^SMG$CREATE_VIRTUAL_DISPLAY
	BSBW	RPT_ERROR_CHK
;
; Create Pasteboard
;
	PUSHAL	PB_BOARD
	CALLS	#1,G^SMG$CREATE_PASTEBOARD
	BSBW	RPT_ERROR_CHK
;
; Create Virtual Keyboard
;
	PUSHAL	KB_BOARD
	CALLS	#1,G^SMG$CREATE_VIRTUAL_KEYBOARD
	BSBW	RPT_ERROR_CHK
;
; Associate the pasteboard and Virtual Display
;
	PUSHAL	PB_COL		;Column
	PUSHAL	PB_ROW		;Row
	PUSHAL	PB_BOARD
	PUSHAL	REPORT_DISP
	CALLS	#4,G^SMG$PASTE_VIRTUAL_DISPLAY
	BSBW	RPT_ERROR_CHK
	PUSHAL	PB_COL2		;Column
	PUSHAL	PB_ROW2		;Row
	PUSHAL	PB_BOARD
	PUSHAL	REPORT_DISP2
	CALLS	#4,G^SMG$PASTE_VIRTUAL_DISPLAY
	BSBW	RPT_ERROR_CHK
	PUSHAL	PB_COL3		;Column
	PUSHAL	PB_ROW3		;Row
	PUSHAL	PB_BOARD
	PUSHAL	REPORT_DISP3
	CALLS	#4,G^SMG$PASTE_VIRTUAL_DISPLAY
	BSBW	RPT_ERROR_CHK
50$:	RSB
RPT_ERROR_CHK:
	.JSB_ENTRY	INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, OUTPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

		BLBC	R0,10$
		RSB
10$:
	MOVL	R0,R6			; Save Error
	PUSHAL	REPORT_DISP
	CALLS	#1,G^SMG$DELETE_VIRTUAL_DISPLAY
	PUSHAL	REPORT_DISP2
	CALLS	#1,G^SMG$DELETE_VIRTUAL_DISPLAY
	PUSHAL	REPORT_DISP3
	CALLS	#1,G^SMG$DELETE_VIRTUAL_DISPLAY
	MOVL	R6,R0			; Restore
		RET

	.END 
