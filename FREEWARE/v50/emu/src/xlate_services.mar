 	.TITLE	XLATE_SERVICES
	.IDENT /V01-001/
;	© 2000 P. Beaudoin
;  This software is supplied as is and the usual warranty
;  is implied - none. You may use, abuse, modify or
;  or ignore this software as you see fit but are
;  encouraged to give credit, as is good practice
;  when stealing with permission
; 
; Modifications:
; 1-1	Aug 1996	PB	Create v5 
;++
;1 XLATE_SERVICES
; This module contains routines used to translate internal or otherwise
; coded fields into printable strings. Each routine is documented
; seperately.
; NOTE: Translation table routines are held in module EMU_XLTTBL
;--
	.LIBRARY        /SYS$LIBRARY:LIB.MLB/
;	.library	/lib$:macrolib.mlb/
	.LIBRARY        /EMU5_LIB:EMU5.MLB/
        $IODEF                          ;Define I/O functions and modifiers
	$SECDEF				; Global Section 
	$PRTDEF				; Protection Codes
	$SSDEF
	$NMADEF
	EMUIPCDEF			; IPC buffers
	EMUSYSDEF
	EMUCTRLDEF
	EMURLTDEF
	EMUDBDEF
	EMUCMIPDEF
	EMUPSRDEF
	EMUUIDEF
;

	.PSECT	XLATE_SERVICE_DATA,WRT,NOEXE,PIC,SHR,QUAD
;
; Quad data areas  
	.ALIGN	QUAD
RESULT:		.QUAD	0
ASN1TAG:	.BLKL	8
CONTEXT:	.LONG	0
NAMELIST:	.BLKL	128	; List of names
DADDR:		.QUAD	0
QRESULT:	.QUAD	0
;
; Section areas

DBMAP:
                .QUAD	0
		.LONG	0			;SYS_PID_C_xxxx
		.LONG	PSR_IP_L_ADDR           ; Offset to key
		.LONG	0			; Lock ID
		.LONG	0			; Spare/align
		.ADDRESS EMU_IPDB               ; Lock Name
		.ADDRESS EMU_PSRIP              ; DB name 
MAPNAMER:
                .QUAD	0
		.LONG	SYS_PID_C_NAMER
		.LONG	0
		.LONG	0			; Lock ID
		.LONG	0			; Spare/align
		.ADDRESS EMU_NAMERDB
		.ADDRESS EMU_NAMER
MAPRELATER:
                .QUAD	0
		.LONG	SYS_PID_C_RELATER
		.LONG	0
		.LONG	0			; Lock ID
		.LONG	0			; Spare/align
		.ADDRESS EMU_RELATERDB
		.ADDRESS EMU_RELATER

LOCKTBL:
	.LONG		0               ; Undefined
	.LONG		0               ; Listener (no db)
	.ADDRESS	EMU_DN4DB	;	2
	.ADDRESS	EMU_DN5DB	;	3
	.ADDRESS	EMU_SCSDB	;	4
	.ADDRESS	EMU_LATDB	;	5
	.ADDRESS	EMU_MOPDB	;	6
	.ADDRESS	EMU_IPDB		;	7
	.LONG		0               ; Undefined
	.LONG		0               ; Undefined
	.LONG		0               ; Undefined
	.LONG		0               ; Undefined
	.ADDRESS	EMU_ETHDB	;	12
	.LONG		0               ; Undefined
	.LONG		0               ; 
	.LONG		0               ;
	.LONG		0               ;
	.ADDRESS	EMU_RELATERDB	;	17
	.ADDRESS	EMU_NAMERDB		;	18
DBTBL:
	.LONG		0               ; Undefined
	.LONG		0               ; Listener (no db)
	.ADDRESS	EMU_PSRDN4	;	2
	.ADDRESS	EMU_PSRDN5	;	3
	.ADDRESS	EMU_PSRSCS	;	4
	.ADDRESS	EMU_PSRLAT	;	5
	.ADDRESS	EMU_PSRMOP	;	6
	.ADDRESS	EMU_PSRIP	;	7
	.LONG		0		;	8
	.LONG		0		;	9
	.LONG		0		;	9
	.LONG		0		;	9
	.ADDRESS	EMU_PSRETH	;	12
	.LONG		0 		;	PSRREC
	.LONG		0               ;	Spare
	.LONG		0               ;
	.LONG		0               ;
	.ADDRESS	EMU_RELATER		;	17
	.ADDRESS	EMU_NAMER		;	18
OFFSETTBL:
	.LONG		0               ; Undefined
	.LONG		0               ; Listener (no db)
	.LONG	PSR_DN4_W_ADDR    
	.LONG	PSR_DN5_B20_ADDR 
	.LONG	PSR_SCS_EA_ADDR	  
	.LONG	PSR_LAT_EA_ADDR   
	.LONG	PSR_MOP_EA_ADDR   
	.LONG	PSR_IP_L_ADDR	  
	.LONG		0               ; Undefined
	.LONG		0               ; Undefined
	.LONG		0               ; Undefined
	.LONG		0               ; Undefined
	.LONG	PSR_ETH_EA_ADDR   
	.LONG		0               ; Undefined
	.LONG		0               ; Undefined
	.LONG		0               ; Undefined
	.LONG		0               ; Undefined
	.LONG		0               ; Undefined
	.LONG		0               ; Undefined



EMU_IPDB:	
		.ASCID	\EMU_IPDB\            ; Lock name
EMU_SCSDB:	
		.ASCID	\EMU_SCSDB\            ; Lock name
EMU_MOPDB:	
		.ASCID	\EMU_MOPDB\            ; Lock name
EMU_DN5DB:	
		.ASCID	\EMU_DN5DB\            ; Lock name
EMU_DN4DB:	
		.ASCID	\EMU_DN4DB\            ; Lock name
EMU_LATDB:	
		.ASCID	\EMU_LATDB\            ; Lock name
EMU_ETHDB:	
		.ASCID	\EMU_ETHDB\            ; Lock name
EMU_NAMERDB:		
		.ASCID	/EMU_NAMERDB/	; DB Lock name 
EMU_RELATERDB:		
		.ASCID	/EMU_RELATERDB/	; DB Lock name 
; Section names
EMU_RELATER:
		.ASCID	/EMU_RELATER/
EMU_PSRIP:
		.ASCID	/EMU_PSRIP/
EMU_NAMER:
		.ASCID	/EMU_NAMER/
EMU_PSRSCS:	
		.ASCID	\EMU_PSRSCS\  		; Section name
EMU_PSRDN5:	
		.ASCID	\EMU_PSRDN5\  		; Section name
EMU_PSRMOP:	
		.ASCID	\EMU_PSRMOP\  		; Section name
EMU_PSRDN4:	
		.ASCID	\EMU_PSRDN4\  		; Section name
EMU_PSRLAT:	
		.ASCID	\EMU_PSRLAT\  		; Section name
EMU_PSRETH:	
		.ASCID	\EMU_PSRETH\  		; Section name

LANTYPTBL:
	.ASCII	/Unknown /
	.ASCII	/OTHER   /		;1	; None of the following
	.ASCII	/REG 1822/		;2
	.ASCII	/HDH 1822/	        ;3
	.ASCII	/DDN_X25 /	        ;4
	.ASCII	/877X25  /		;5
	.ASCII	/ETHERNET/	        ;6
	.ASCII	/ISO88023/	        ;7
	.ASCII	/ISO88024/	        ;8      
	.ASCII	/TKENRING/	        ;9
	.ASCII	/ISO88026/		;10
	.ASCII	/STARLAN /	     	;11
	.ASCII	/PROT10MB/	        ;12
	.ASCII	/PROT80MB/	        ;13
	.ASCII	/HYPCHANN/		;14
	.ASCII	/FDDI    /		;15
	.ASCII	/LAPB    /		;16
	.ASCII	/SDLC    /		;17
	.ASCII	/DS1     /		;18	; T1
	.ASCII	/E1      /		;19      ; European equiv T1
	.ASCII	/BAS_ISDN/	        ;20
	.ASCII	/PRIMISDN/		;21      ; Proprieary serial
	.ASCII	/PPPSERIL/	        ;22
	.ASCII	/PPP     /		;23
	.ASCII	/LOOPBACK/	        ;24    
	.ASCII	/EON     /		;25      ; CLNP over IP
	.ASCII	/ENET_3MB/	        ;26
	.ASCII	/NSIP    /	        ;27      ; XNS over IP
	.ASCII	/SLIP    /	        ;28      ; Generic SLIP
	.ASCII	/ULTRA   /	        ;29      ; ULTRA Technologies
	.ASCII	/DS3     /	        ;30      ; T3
	.ASCII	/SIP     /	        ;31      ; SMDS
	.ASCII	/FRAMERLY/	        ;32
MAXLANTYP = 32
LANTYPSIZ = 8
; Counters kept:
	.ALIGN 	LONG
; Files
	.ALIGN 	LONG
MAPPERFAB:	
	$FAB	FAC = <GET,PUT,UPD,DEL>,-	; Access
		SHR = <GET,PUT,UPD,DEL,MSE>,-	; Share with ...
		ORG = IDX,-			; Keyed file (Finally)
		RFM = FIX,-
		MRS = 128,-                       ; Largest rec
		GBC = 10,-                        ; Use global buffers
		DNM = <EMU5_Dat:MAPPER.DAT>,-	; Default Filename 
		FNM = <MAPPER>,-			; Filename 
		XAB = MAPPERXAB0                  ; Keys

MAPPERRAB:	$RAB	FAB = MAPPERFAB,-		; pointer to FAB
		RBF = MAPPERREC_BUF,-		; i/o buffer 
		RSZ = MAPPERREC_SIZE,-		; Write this many bytes
		UBF = MAPPERREC_BUF,-		; i/o buffer 
		USZ = MAPPERREC_SIZE,-		; 
		ROP = <NLK,RRL>,-			; Do not lock rec
		RAC = KEY,-			; Keyed file
		KBF = MAPKEY_BUF,-			; Key location
		KSZ = 8

MAPPERRAB2:	$RAB	FAB = MAPPERFAB,-		; pointer to FAB
		RBF = MAPPERBUF2,-		; i/o buffer 
		RSZ = MAPPERREC_SIZE,-		; Write this many bytes
		UBF = MAPPERBUF2,-		; i/o buffer 
		USZ = MAPPERREC_SIZE,-		; 
		ROP = <NLK,RRL>,-			; Do not lock rec
		RAC = KEY,-			; Keyed file
		KBF = MAPPERBUF2,-			; Key location
		KRF = 2,-
		KSZ = 4

MAPPERXAB0:	$XABKEY	REF = 0,-  		; TBL,PARAM
		DTP = BN8,-             ; Key = 4 bytes binary (ascending)
		POS = 0,-               ; Key position
		SIZ = 8,-                 ; Key len (dups not allowed)
		NXT = MAPPERXAB1

MAPPERXAB1:	$XABKEY	REF = 1,-  	; TBL
		DTP = BN4,-             ; Key = 4 bytes binary (ascending)
		POS = 0,-               ; Key position
		SIZ = 4,-               ; Key len (dups allowed)
		FLG = DUP,-
		NXT = MAPPERXAB2

MAPPERXAB2:	$XABKEY	REF = 2,-  	; Param
		DTP = BN4,-             ; Key = 4 bytes binary (ascending)
		POS = 4,-               ; Key position
		SIZ = 4,-               ; Key len (dups allowed)
		FLG = DUP
;
MAPPERREC_BUF:	
MAPPER_KEY:
MAPKEY_BUF:
MAPPER_TBL:		.LONG	0	; Table 
MAPPER_PARAM:		.LONG	0	; Paramater
MAPPER_SEC:		.QUAD	0	; Prives req'ed to detect. VMS sec
MAPPER_KEYW_LEN:	.LONG	0	; Len of following string
MAPPER_KEYW:		.BLKB	32      ; Standard keyword this param
MAPPER_FMTTYP:		.LONG	0	; Either len of following of rtn num.
MAPPER_FMTSTR:		.BLKB	68	; FAO directive str
MAPPER_RPTLVL:		.LONG	0
MAPPERREC_SIZE = .-MAPPERREC_BUF        ; = 128
MAPPERBUF2:	.BLKB	MAPPERREC_SIZE

; Local Entity name table. Part of this param is an object id of which
; the 1st 8 bytes are constant. If the total len is < 12 (all known 
; instances), this table contains pointers to the string translation.
; Structure for each entry:
;	len of following object id	.long
;	object id			.long
;	len of xlate string		.long
;	addr of xlate string		.long
;
ENNTBL:
        .LONG 1
        .BYTE 01,0,0,0
        .LONG 6
        .ADDRESS ENN_DDCMP
;
        .LONG 2
        .BYTE 01,0,0,0
        .LONG 11
        .ADDRESS ENN_DDCMPPORT
;
        .LONG 2
        .BYTE 01,1,0,0
        .LONG 11
        .ADDRESS ENN_DDCMPLINK

;

        .LONG 1
        .BYTE 02,0,0,0
        .LONG 8
        .ADDRESS ENN_csma_cd

        .LONG 2
        .BYTE 02,00,0,0
        .LONG 13
        .ADDRESS ENN_csma_cdport

        .LONG 2
        .BYTE 02,01,0,0
        .LONG 16
        .ADDRESS ENN_csma_cdstation

        .LONG 1
        .BYTE 04,0,0,0
        .LONG 8
        .ADDRESS ENN_rout

        .LONG 2
        .BYTE 04,00,0,0
        .LONG 13
        .ADDRESS ENN_routport

        .LONG 2
        .BYTE 04,01,0,0
        .LONG 28
        .ADDRESS ENN_routpermittedneighbour

        .LONG 2
        .BYTE 04,02,0,0
        .LONG 16
        .ADDRESS ENN_routcircuit

        .LONG 3
        .BYTE 04,02,00,0
        .LONG 26
        .ADDRESS ENN_routcircuitadjacency

        .LONG 3
        .BYTE 04,02,01,0
        .LONG 34
        .ADDRESS ENN_routcircuitreachaddr

        .LONG 2
        .BYTE 04,03,0,0
        .LONG 25
        .ADDRESS ENN_routDestinationnode

        .LONG 2
        .BYTE 04,04,0,0
        .LONG 25
        .ADDRESS ENN_routdestinationarea

        .LONG 1
        .BYTE 05,0,0,0
        .LONG 13
        .ADDRESS ENN_X25Protocol

        .LONG 2
        .BYTE 05,00,0,0
        .LONG 17
        .ADDRESS ENN_x25ProtocolDTE

        .LONG 3
        .BYTE 05,00,00,0
        .LONG 21
        .ADDRESS ENN_x25protocolDTEPVC

        .LONG 2
        .BYTE 05,01,0,0
        .LONG 19
        .ADDRESS ENN_x25protocolGroup

        .LONG 1
        .BYTE 06,0,0,0
        .LONG 4
        .ADDRESS ENN_NSP

        .LONG 2
        .BYTE 06,00,0,0
        .LONG 9
        .ADDRESS ENN_NSPPort

        .LONG 2
        .BYTE 06,01,0,0
        .LONG 27
        .ADDRESS ENN_NSPLocalServiceProvider

        .LONG 3
        .BYTE 06,01,00,0
        .LONG 51
        .ADDRESS ENN_NSPLclSvcPrvdrRemSrvcProv

        .LONG 1
        .BYTE 07,0,0,0
        .LONG 14
        .ADDRESS ENN_OSITrans

        .LONG 2
        .BYTE 07,00,0,0
        .LONG 19
        .ADDRESS ENN_OSITransport

        .LONG 2
        .BYTE 07,01,0,0
        .LONG 25
        .ADDRESS ENN_OSITransLocalNSAP

        .LONG 3
        .BYTE 07,01,00,0
        .LONG 38
        .ADDRESS ENN_OSITransLclNSAPremnsap

        .LONG 2
        .BYTE 07,02,0,0
        .LONG 23
        .ADDRESS ENN_OSITranstemplate

        .LONG 1
        .BYTE 08,0,0,0
        .LONG 16
        .ADDRESS ENN_sescon

        .LONG 2
        .BYTE 08,00,0,0
        .LONG 21
        .ADDRESS ENN_sesconport

        .LONG 2
        .BYTE 08,01,0,0
        .LONG 34
        .ADDRESS ENN_sesconTransService

        .LONG 2
        .BYTE 08,04,0,0
        .LONG 28
        .ADDRESS ENN_sesconApplication

        .LONG 2
        .BYTE 08,05,0,0
        .LONG 34
        .ADDRESS ENN_sesconTowerMaint

        .LONG 1
        .BYTE 9,0,0,0
        .LONG 10
        .ADDRESS ENN_DNSCLRK

        .LONG 2
        .BYTE 9,1,0,0
        .LONG 26
        .ADDRESS ENN_DNSCLRKKNS

        .LONG 2
        .BYTE 9,2,0,0
        .LONG 31
        .ADDRESS ENN_DNSCLRKRCS

        .LONG 2
        .BYTE 9,3,0,0
        .LONG 28
        .ADDRESS ENN_DNSCLRKMNS

        .LONG 1
        .BYTE 10,0,0,0
        .LONG 5
        .ADDRESS ENN_DTSS

        .LONG 2
        .BYTE 10,01,0,0
        .LONG 16
        .ADDRESS ENN_DTSSGlobalSet

        .LONG 2
        .BYTE 10,02,0,0
        .LONG 15
        .ADDRESS ENN_DTSSLOcalset

        .LONG 1
        .BYTE 12,0,0,0
        .LONG 14
        .ADDRESS ENN_modcon

        .LONG 2
        .BYTE 12,00,0,0
        .LONG 32
        .ADDRESS ENN_Modconcallcontrolport

        .LONG 2
        .BYTE 12,01,0,0
        .LONG 24
        .ADDRESS ENN_Modcondataport

        .LONG 2
        .BYTE 12,02,0,0
        .LONG 23
        .ADDRESS ENN_Modcontemplate

        .LONG 2
        .BYTE 12,03,0,0
        .LONG 19
        .ADDRESS ENN_modconline

        .LONG 1
        .BYTE 14,00,0,0
        .LONG 17
        .ADDRESS ENN_EVD

        .LONG 2
        .BYTE 14,00,0,0
        .LONG 33
        .ADDRESS ENN_EVDOS

        .LONG 2
        .BYTE 14,01,0,0
        .LONG 23
        .ADDRESS ENN_EVDRLY

        .LONG 3
        .BYTE 14,01,1,0
        .LONG 31
        .ADDRESS ENN_EVDRLYLOG

        .LONG 2
        .BYTE 14,02,0,0
        .LONG 22
        .ADDRESS ENN_EVDSINK

        .LONG 3
        .BYTE 14,02,1,0
        .LONG 37
        .ADDRESS ENN_EVDSINKIBS


        .LONG 1
        .BYTE 15,0,0,0
        .LONG 21
        .ADDRESS ENN_Applicationloopback

        .LONG 1
        .BYTE 16,0,0,0
        .LONG 4
        .ADDRESS ENN_Mop

        .LONG 2
        .BYTE 16,00,0,0
        .LONG 11
        .ADDRESS ENN_MOPClient

        .LONG 2
        .BYTE 16,01,0,0
        .LONG 12
        .ADDRESS ENN_MOPCircuit

        .LONG 3
        .BYTE 16,01,00,0
        .LONG 22
        .ADDRESS ENN_MopCircuitoperation

        .LONG 3
        .BYTE 16,01,01,0
        .LONG 20
        .ADDRESS ENN_MopCircuitStation

        .LONG 1
        .BYTE 20,0,0,0
        .LONG 11
        .ADDRESS ENN_X25Server

        .LONG 2
        .BYTE 20,00,0,0
        .LONG 18
        .ADDRESS ENN_x25serverclient

        .LONG 1
        .BYTE 21,0,0,0
        .LONG 11
        .ADDRESS ENN_x25Access

        .LONG 2
        .BYTE 21,00,0,0
        .LONG 20
        .ADDRESS ENN_X25AccessTemplate

        .LONG 2
        .BYTE 21,01,0,0
        .LONG 18
        .ADDRESS ENN_x25AccessFilter

        .LONG 2
        .BYTE 21,02,0,0
        .LONG 29
        .ADDRESS ENN_x25accessreachaddr

        .LONG 2
        .BYTE 21,03,0,0
        .LONG 16
        .ADDRESS ENN_X25accessport

        .LONG 2
        .BYTE 21,04,0,0
        .LONG 14
        .ADDRESS ENN_X25DTEclass

        .LONG 2
        .BYTE 21,07,0,0
        .LONG 23
        .ADDRESS ENN_X25AccessApplication

        .LONG 1
        .BYTE 22,0,0,0
        .LONG 11
        .ADDRESS ENN_X25client

        .LONG 1
        .BYTE 27,0,0,0
        .LONG 11
        .ADDRESS ENN_DNSSRV

        .LONG 2
        .BYTE 27,1,0,0
        .LONG 24
        .ADDRESS ENN_DNSSRVCS

        .LONG 1
        .BYTE 35,0,0,0
        .LONG 5
        .ADDRESS ENN_FDDI

        .LONG 2
        .BYTE 35,00,0,0
        .LONG 12
        .ADDRESS ENN_FDDIStation

        .LONG 2
        .BYTE 35,01,0,0
        .LONG 10
        .ADDRESS ENN_FDDIPORT

	.LONG	0			; End of tbl


;
; Return messages
		.blkb	3		; align
TEMPSTR_AC:	.BYTE	0		; Convert following to .ascic
TEMPSTR:	.BLKB	32
TEMPSTR_D:	.LONG	.-TEMPSTR
		.ADDRESS  TEMPSTR
UNKNWNE:	.ASCID	/(!XB!XB)/	;
UNKNWNI:	.ASCID	/(!XB)/	;
UNKNWNS:	.ASCID	/(!XB!XB!XB!XB!XB)/	;
CNTRSTR:	.ASCID	/!XB-!XB-!XB-!XB-!XB-!XB /
FAODEFNAM:	.ASCID	/!UB:./
FAOAD:		.ASCII	/!AD /
FAOUL:		.ASCII	/!UL /
FAOUB:		.ASCII	/!UB /
FAOXB:		.ASCII	/!XB /
FAOMAC:		.ASCII	/!XB-/
FAOBRI:		.ASCII	/!UW:/
FAOXL:		.ASCII	/!XL /
COLON:		.ASCII	/::/
DASH:		.ASCII	/-/
FAOACSEP:	.ASCII	/!AC./
FAOUBSEP:        .ASCII	/!UB./
ASCSTR:		.ASCID	/ !AC/
ASDSTR:		.ASCID	/ !AD/
ASSTR:		.ASCID	/ !AS/
UBSTR:		.ASCID	/ !UB/
UICSTR:		.ASCID	/ !%U/
ULSTR:		.ASCID	/ !UL/
ULSTRSEP:	.ASCII	/!UL./
UIDSTR:		.ASCID	/ !XB!XB!XB!XB-!XB!XB-!XB!XB-!XB!XB-!XB!XB!XB!XB!XB!XB/
booltbl:
		.ascic	/False  /
		.ascic	/True   /
verstr:		.ASCID	/ !AD!UB.!UB.!UB/
PSRIPADDR:	.ASCID	/!UB.!UB.!UB.!UB/
PSRETHADDR:	.ASCID	/!XB-!XB-!XB-!XB-!XB-!XB/
PSRDN4ADDR:	.ASCID	/!UW.!UW/
PSRBRDROOT:	.ASCID	/!UW:!XB-!XB-!XB-!XB-!XB-!XB/
PSRSCSREC:	.ASCID	/!XB-!XB-!XB-!XB-!XB-!XB,!UW/
PSRLATREC:	.ASCID	/!XB-!XB-!XB-!XB-!XB-!XB/
PSRMOPREC:	.ASCID	/!XB-!XB-!XB-!XB-!XB-!XB,!AS/
PSRIPXREC:	.ASCID	/!XL:!XB-!XB-!XB-!XB-!XB-!XB:!UW/
PSRIPXADDR:	.ASCID	/!XL:!XB-!XB-!XB-!XB-!XB-!XB:!UW/
PSRNAMREC:	.ASCID	/!AD (!AC)/
PSRNAMADDR:	.ASCID	/PID: !XL KEY2: !XL NAME: !AD/
BLANK1:		.ASCID	/,/
BLANK2:		.ASCID	/,,/
SCNRECSTR:	.ASCID	/!64<!AD.!AD!> !AC  !XL/
	.align	long

FAOLEN:		.LONG
FAOLIST:	.BLKL	64
FAOSTR:		.BLKB	64
FAOSTR_D:	.LONG	.-FAOSTR 		; Dynamic
		.ADDRESS  FAOSTR
TEMPDESC:	.QUAD	0
TEMPDESC2:	.QUAD	0
; Time
CMP_TIMELEN:	.LONG		; Len of converted time str
CMP_TIMEBUF:	.BLKB	24
CMP_TIMEBUF_D:	.LONG	.-CMP_TIMEBUF
		.ADDRESS  CMP_TIMEBUF
; Note:
; VMS Cannot interpret a UTC time before 17-Nov-1858 (Smithsonian). This rarely
; comes up except when a 0 UTC time is specified. (04-oct-1582).
; The conversion algorithm thus checks for this value and if it matches, returns
; the correct string date.
 
TIMZEROB:	.BYTE 	^XF0,^XD8,^XFF,^XFF,^XFF,^XFF,^XFF,^XFF,-
			^X00,^X00,^X00,^X00,^X00,^X00,^X00,^X10

TIMZEROA:	.ASCII	/1582-10-04-23:59:59.1001/
;
; Tables
	.align	long
STPTBL:
	.ASCII	/dec     /
	.ASCII	/802.1d  /

DEFVALSTR:	.ASCII	/Default /
DEFVALSTR_LEN = .-DEFVALSTR
RETLEN:		.LONG
DBXLTTBL:
		.LONG	0
		.LONG	0
		.ASCIC	/DN4/
		.ASCIC	/DN5/
		.ASCIC	/SCS/
		.ASCIC	/LAT/
		.ASCIC	/MOP/
		.ASCIC	/IP /
		.ASCIC	/IPX/
		.ASCIC	/DNS/
		.ASCIC	/DTS/
		.ASCIC	/ARP/
		.ASCIC	/ETH/
		.LONG	0
		.ASCIC	/BRD/
		.LONG	0
		.LONG	0
		.ASCIC	/RLT/
		.ASCIC	/NAM/
MAX_DBXLTTBL = 18


IDPTBL:
; Format:
; Each entry is a .long in form:
;	Byte	Meaning
;	0	AFI value
;	1	IDP len
;	2	padding value
;	3	Not used
	.BYTE	^x49,1,0,0	; Local
	.BYTE	^x37,8,0,0        ; x.121 
	.BYTE	^x53,8,1,0        ; x.121 
	.BYTE	^x39,3,0,0        ; ISO DCC
	.BYTE	^x41,5,0,0        ; F.69
	.BYTE	^x55,5,1,0        ; F.69
	.BYTE	^x43,7,0,0        ; E.163
	.BYTE	^x57,7,1,0        ; E.163
	.BYTE	^x45,9,0,0        ; E.164
	.BYTE	^x59,9,1,0        ; E.164
	.BYTE	^x47,3,0,0        ; ISO 6523-ICD
	.LONG	0		; Terminator
XLATE_CIRCTYP_TBL:
	.ADDRESS	CIRCTYP0
	.ADDRESS	CIRCTYP1
	.ADDRESS	CIRCTYP2
	.ADDRESS	CIRCTYP3
	.ADDRESS	CIRCTYP4
	.ADDRESS	CIRCTYP5
	.ADDRESS	CIRCTYP6
CIRCTYP_MAX = 6
CIRCTYP_SIZ = 20
CIRCTYP0:
	.ASCII	/CSMACD              /
CIRCTYP1:
	.ASCII	/DDCMP               /
CIRCTYP2:
	.ASCII	/HDLC                /
CIRCTYP3:
	.ASCII	/X.25 Static Incoming/
CIRCTYP4:
	.ASCII	/X.25 Static Outgoing/
CIRCTYP5:
	.ASCII	/X.25 DA             /
CIRCTYP6:
	.ASCII	/X.25 Permanent      /

; SNMP Interface type table
SNMP_IFXLATE_TABLE:
	.ASCII	/OTHER                   /	; 1
	.ASCII	/REGULAR1822             /	; 2
	.ASCII	/HDH1822                 /	; 3
	.ASCII	/DDN_X25                 /	; 4
	.ASCII	/RFC877_X25              /	; 5
	.ASCII	/ETHERNET_CSMACD         /	; 6
	.ASCII	/ISO88023_CSMACD         /	; 7
	.ASCII	/ISO88024_TOKENBUS       /	; 8
	.ASCII	/ISO88025_TOKENRING      /	; 9
	.ASCII	/ISO88026_MAN            /	; 10
	.ASCII	/STARLAN                 /	; 11
	.ASCII	/PROTEON_10MBIT          /	; 12
	.ASCII	/PROTEON_80MBIT          /	; 13
	.ASCII	/HYPERCHANNEL            /	; 14
	.ASCII	/FDDI                    /	; 15
	.ASCII	/LAPB                    /	; 16
	.ASCII	/SDLC                    /	; 17
	.ASCII	/DS1                     /	; 18
	.ASCII	/E1                      /	; 19
	.ASCII	/BASICISDN               /	; 20
	.ASCII	/PRIMARYISDN             / 	; 21      
	.ASCII	/PROPPOINTTOPOINTSERIAL  /	; 22      
	.ASCII	/PPP                     /	; 23
	.ASCII	/SOFTWARELOOPBACK        /	; 24
	.ASCII	/EON                     /	; 25
	.ASCII	/ETHERNET_3MBIT          /	; 26
	.ASCII	/NSIP                    /	; 27 
	.ASCII	/SLIP                    /	; 28
	.ASCII	/ULTRA                   /	; 29
	.ASCII	/DS3                     /	; 30
	.ASCII	/SIP                     /	; 31
	.ASCII	/FRAME_RELAY             /	; 32
	.ASCII	/RS232                   /
	.ASCII	/PARALLEL                /
	.ASCII	/ARCNET                  /
	.ASCII	/ARCNETPLUS              /
	.ASCII	/ATM                     /
	.ASCII	/MIOX25                  /
	.ASCII	/SONET                   /
	.ASCII	/X25PLE                  /
	.ASCII	/ISO8802LLC              /
	.ASCII	/LOCALTALK               /
	.ASCII	/SMDSDXI                 /
	.ASCII	/FRAMERELAYSERVICE       /
	.ASCII	/V35                     /
	.ASCII	/HSSI                    /
	.ASCII	/HIPPI                   /
	.ASCII	/MODEM                   /
	.ASCII	/AAL5                    /
	.ASCII	/SONETPATH               /
	.ASCII	/SONETVT                 /
	.ASCII	/SMDSICIP                /
	.ASCII	/PROPVIRTUAL             /
	.ASCII	/PROPMULTIPLEXOR         /
SNMP_IFXLATE_ENTRIES = 54
SNMP_IFXLATE_SIZE = 24   
;			
; Local Entity Name translation.
; The ENNTBL: COntains pointers to these strings
ENN_DDCMP:
        .ASCII /DDCMP /
ENN_DDCMPPORT:
        .ASCII /DDCMP Port /
ENN_DDCMPLINK:
        .ASCII /DDCMP Link /
ENN_DNSCLRK:
        .ASCII /DNS Clerk /
ENN_DNSCLRKKNS:
        .ASCII /DNS Clerk Known Namespace /
ENN_DNSCLRKRCS:
        .ASCII /DNS Clerk Remote Clearinghouse /
ENN_DNSCLRKMNS:
        .ASCII /DNS Clerk Manual Nameserver /
ENN_DNSSRV:
        .ASCII /DNS Server /
ENN_DNSSRVCS:
        .ASCII /DNS Server Clearinghouse/
ENN_EVD:
        .ASCII /Event Dispatcher /
ENN_EVDOS:
        .ASCII /Event Dispatcher Outbound Stream /
ENN_EVDRLY:
        .ASCII /Event Dispatcher Relay /
ENN_EVDRLYLOG:
        .ASCII /Event Dispatcher Relay Logging /
ENN_EVDSINK:
        .ASCII /Event Dispatcher Sink /
ENN_EVDSINKIBS:
        .ASCII /Event Dispatcher Sink Inbound Stream /


ENN_csma_cd:
        .ASCII /csma-cd /
ENN_csma_cdport:
        .ASCII /csma-cd port /
ENN_csma_cdstation:
        .ASCII /csma-cd station /

ENN_FDDI:
        .ASCII /FDDI /
ENN_FDDIport:
        .ASCII /FDDI port /
ENN_FDDIstation:
        .ASCII /FDDI station /
ENN_rout:
        .ASCII /routing /
ENN_routport:
        .ASCII /routing port /
ENN_routpermittedneighbour:
        .ASCII /routing permitted neighbour /
ENN_routcircuit:
        .ASCII /routing circuit /
ENN_routcircuitadjacency:
        .ASCII /routing circuit adjacency /
ENN_routcircuitreachaddr:
        .ASCII /routing circuit reachable address /
ENN_routDestinationnode:
        .ASCII /routing Destination node /
ENN_routdestinationarea:
        .ASCII /routing destination area /
ENN_X25Protocol:
        .ASCII /X25 Protocol /
ENN_x25ProtocolDTE:
        .ASCII /x25 Protocol DTE /
ENN_x25protocolDTEPVC:
        .ASCII /x25 protocol DTE PVC / 
ENN_x25protocolGroup:
        .ASCII /x25 protocol Group /
ENN_NSP:
        .ASCII /NSP /
ENN_NSPPort:
        .ASCII /NSP Port /
ENN_NSPLocalServiceProvider:
        .ASCII /NSP Local Service Provider /
ENN_NSPLclSvcPrvdrRemSrvcProv:
        .ASCII /NSP Local Service Provider Remote Service Provider /
ENN_OSITrans:
        .ASCII /OSI Transport /
ENN_OSITransport:
        .ASCII /OSI Transport port /
ENN_OSITransLocalNSAP:
        .ASCII /OSI Transport Local NSAP /
ENN_OSITransLclNSAPremnsap:
        .ASCII /OSI Transport Local NSAP remote nsap /
ENN_OSITranstemplate:
        .ASCII /OSI Transport template /
ENN_sescon:
        .ASCII /Session Control /
ENN_sesconport:
        .ASCII /Session Control port /
ENN_sesconTransService:
        .ASCII /Session Control Transport Service /
ENN_sesconApplication:
        .ASCII /Session Control Application /
ENN_sesconTowerMaint:
        .ASCII /Session Control Tower Maintenance /
ENN_DTSS:
        .ASCII /DTSS /
ENN_DTSSGlobalSet:
        .ASCII /DTSS Global Set /
ENN_DTSSLOcalset:
        .ASCII /DTSS LOcal set /
ENN_modcon:
        .ASCII /Modem Connect /
ENN_Modconcallcontrolport:
        .ASCII /Modem connect call control port /
ENN_Modcondataport:
        .ASCII /Modem connect data port /
ENN_Modcontemplate:
        .ASCII /Modem connect template /
ENN_modconline:
        .ASCII /modem connect line /
ENN_Applicationloopback:
        .ASCII /Application loopback /
ENN_Mop:
        .ASCII /Mop /
ENN_MOPClient:
        .ASCII /MOP Client /
ENN_MOPCircuit:
        .ASCII /MOP Circuit /
ENN_MopCircuitoperation:
        .ASCII /Mop Circuit operation /
ENN_MopCircuitStation:
        .ASCII /Mop Circuit Station /
ENN_X25Server:
        .ASCII /X25 Server /
ENN_x25serverclient:
        .ASCII /x25 server client /
ENN_x25Access:
        .ASCII /x25 Access /
ENN_X25AccessTemplate:
        .ASCII /X25 Access Template /
ENN_x25AccessFilter:
        .ASCII /x25 Access Filter /
ENN_x25accessreachaddr:
        .ASCII /x25 access reachable addr /
ENN_X25accessport:
        .ASCII /X25 access port /
ENN_X25DTEclass:
        .ASCII /X25 DTE class /
ENN_X25AccessApplication:
        .ASCII /X25 Access Application /
ENN_X25client:
        .ASCII /X25 client /
	
	.ALIGN	LONG
WEEKDAYTBL:
	.ASCII	/NULL/
	.ASCII	/MON /
	.ASCII	/TUE /
	.ASCII	/WED /
	.ASCII	/THU /
	.ASCII	/FRI /
	.ASCII	/SAT /
	.ASCII	/SUN /


; Bitptoascic:
INT:            .LONG
INT2:           .LONG
OUTNUM_D:       .LONG   3
                .ADDRESS OUTNUM
OUTNUM:         .BLKB   3              ; Output from .LONG conversion
; Misc
CMIP_TAG_UNOCT:		.WORD	0,4		; Universal octect string tag
CMIP_TAG_LATSTR:	.WORD	1,20		; Application latin string tag

;
	.PSECT	XLATE_SERVICE_CODE,NOWRT,EXE,PIC,SHR,QUAD


	.CALL_ENTRY	MAX_ARGS=2, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=XLATE_TBL2PID 
;++
;2 XLATE_TBL2PID
; Routine to translate a mpper rec format tbl.param to pid the table is 
; associated with. This is essentialy the reverse of the table names in
; _EMUDBDEF. 
;3 Input
;	.long table
;	.address of .long pointing to outp area
;3 Output
;	The pid this table belongs to is written in P2
;3 Return
;	SS$_NORMAL		Pid written
;	SS$_ITEMNOTFOUND        Unknown table
;
;--
; If the table < 65536 then it is SNMP (IP)
       	CMPL	4(AP),#65536
	BGEQU	10$
	MOVL	#SYS_PID_C_PSRIP,@8(AP)
	MOVL	#SS$_NORMAL,R0
        RET
10$:
; Check all other single level tables:
	CMPL	4(AP),#DB_FAC_C_ETH
	BNEQU	20$
	MOVL	#SYS_PID_C_PSRETH,@8(AP)
	MOVL	#SS$_NORMAL,R0
        RET
20$:
	CMPL	4(AP),#DB_FAC_C_SCS
	BNEQU	30$
	MOVL	#SYS_PID_C_PSRSCS,@8(AP)
	MOVL	#SS$_NORMAL,R0
        RET
30$:
	CMPL	4(AP),#DB_FAC_C_MOP
	BNEQU	40$
	MOVL	#SYS_PID_C_PSRMOP,@8(AP)
	MOVL	#SS$_NORMAL,R0
        RET
40$:
	CMPL	4(AP),#DB_FAC_C_IPX
	BNEQU	50$
	MOVL	#SYS_PID_C_PSRIPX,@8(AP)
	MOVL	#SS$_NORMAL,R0
        RET
50$:
	CMPL	4(AP),#DB_FAC_C_BRD
	BNEQU	55$
	MOVL	#SYS_PID_C_PSRBRD,@8(AP)
	MOVL	#SS$_NORMAL,R0
        RET
55$:
; Multiple level tables
; OSI Tables are hardcoded in range DB_FAC_C_DN5_TBLOFFS - DB_FAC_C_DN5_HIGHEST 
; DN4 Tables are hardcoded in range DB_FAC_C_DN4_TBLOFFS - DB_FAC_C_DN4_HIGHEST 
; OSI Tables are hardcoded in range DB_FAC_C_LAT_TBLOFFS - DB_FAC_C_LAT_HIGHEST 

	CMPL	4(AP),#DB_FAC_C_DN5_TBLOFFS
	BGEQU	60$
	MOVL	#SS$_ITEMNOTFOUND,R0
        RET
60$:
	CMPL	4(AP),#DB_FAC_C_DN5_HIGHEST
	BGTRU	70$
	MOVL	#SYS_PID_C_PSRDN5,@8(AP)
	MOVL	#SS$_NORMAL,R0
        RET
70$:
	CMPL	4(AP),#DB_FAC_C_DN4_TBLOFFS
	BGEQU	80$
	MOVL	#SS$_ITEMNOTFOUND,R0
        RET
80$:
	CMPL	4(AP),#DB_FAC_C_DN4_HIGHEST
	BGTRU	90$
	MOVL	#SYS_PID_C_PSRDN4,@8(AP)
	MOVL	#SS$_NORMAL,R0
        RET
90$:
	CMPL	4(AP),#DB_FAC_C_LAT_TBLOFFS
	BGEQU	100$
	MOVL	#SS$_ITEMNOTFOUND,R0
        RET
100$:
	CMPL	4(AP),#DB_FAC_C_LAT_HIGHEST
	BGTRU	110$
	MOVL	#SYS_PID_C_PSRLAT,@8(AP)
	MOVL	#SS$_NORMAL,R0
        RET
110$:
	MOVL	#SS$_ITEMNOTFOUND,R0
        RET


	.CALL_ENTRY	MAX_ARGS=2, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=XLATE_SCANNEREREC 
;++
;2 XLATE_SCANNERREC
; Routine to translate a scanner record into pritable string
;3 Input
;	.address of scanner record
;	.address of desc pointing to outp area
;3 Output
; 	4 scanner rec fields are translated:
;		Table                >  xlates to table name
;		Paramater            >  Xlates to keyword ala PARAMXLT
;		Destination PID
;		Flags
;3 Return
;	Any from RMS, XLATE_PSRID, $FAO
;--
        TSTW	MAPPERFAB+FAB$W_IFI	; File open?
	BNEQU	20$			; Br if open
	$OPEN	FAB = MAPPERFAB		;Open input file
	BLBS	R0,10$
	RET
10$:
 	$CONNECT RAB = MAPPERRAB	;Connect input stream
	BLBS	R0,20$
	RET
20$:
 	$CONNECT RAB = MAPPERRAB2	;Connect input stream
	BLBS	R0,25$
	RET
25$:
; Get tbl xlation
        MOVL	4(AP),R6
	MOVL	SCN_REC_L_TABLE(R6),MAPPERBUF2
	$GET	RAB=MAPPERRAB2
	BLBS	R0,30$
30$:
100$:
	CLRB	MAPPERRAB+RAB$B_KRF		; Key = 1
	MOVB	#8,MAPPERRAB+RAB$B_KSZ		; Key size
; Get tbl.param xlation
        MOVL	4(AP),R6
	MOVL	SCN_REC_L_TABLE(R6),MAPKEY_BUF   
	MOVL	SCN_REC_L_PARAM(R6),MAPKEY_BUF+4   
	$GET	RAB=MAPPERRAB
	BLBS	R0,110$
	RET
110$:
; Get PID xlation
	PUSHAL	DADDR			; Spare here
	PUSHL	SCN_REC_L_DESTPID(R6)   
	CALLS	#2,G^XLATE_PSRID
	BLBS	R0,120$
	RET
120$:
200$:
	MOVAL	MAPPERBUF2,R9
	PUSHL	SCN_REC_L_FLAGS(R6)
	PUSHAL	DADDR			; Spare
	PUSHAL	MAPPER_KEYW
	PUSHL	MAPPER_KEYW_LEN
	ADDL3	#DB_MAP_A64_KEYW,R9,-(SP)
	PUSHL	DB_MAP_L_KEYWLEN(R9)
	PUSHL	8(AP)
	PUSHL	8(AP)
	PUSHAL	SCNRECSTR
	CALLS	#9,G^SYS$FAO
	RET


	.CALL_ENTRY	MAX_ARGS=2, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=XLATE_PSRID 
;++
;2 XLATE_PSRID
; Routine to translate A PSRID to a 4 byte .ascic string.
;3 Input
;	.long PSR ID to translate (See _EMUSYSDEF)
;	.address of .long where a 4 byte .ascic translation is written
;3 Output
;	If successful, the output param is written with the translation.
;	It is always a count of 3 followed by 3 ascii characters.
;3 Return
;	SS$_NORMAL		OK
;	SS$_ITEMNOTFOUND        Unknown/invalid PSR ID
;--
; Lookup protocol name
	CMPL	4(AP),#MAX_DBXLTTBL
	BGTR	10$
	MOVAL	DBXLTTBL,R3		; Get table
	MULL3	#4,4(AP),R2             ; Make offset
	ADDL	R2,R3                   ; Addr
	TSTL	(R3)			; Valid?
	BEQL	10$
	MOVL	(R3),@8(AP)               ; return
	MOVL	#SS$_NORMAL,R0
        RET
10$:
	MOVL	#SS$_ITEMNOTFOUND,R0
	RET

	.CALL_ENTRY	MAX_ARGS=2, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=XLATE_BRIDGE
;++
;2 XLATE_BRIDGE
; Routine to translate the params found in the Bridge DB
; Following params are translated:
; 1	Root id. Made of:
; 	Root priority
; 	Ethernet address  
; 	Ethernet address  (Low long)
; 2	STP type (dec or 802)
; 3	Cost to root
;3 Inputs
;	.address of emudb record
;	.address of desc pointing to area where 8 byte string is written
;3 Output
; The param is translated to printable  string and placed in output
;3 Returns
;  	SS$_NORMAL	OK
;	SS$_BADPARAM	Table is not bridge
;			Param number is not in range of 1-6
;	SS$_BUFFEROVF	Outp buffer too small
; 	Any from $FAO
;--
	MOVL	4(AP),R6
	CMPL	#DB_FAC_C_BRD,DB_REC_L_TABLE(R6)
	BEQLU	100$
	MOVL	#SS$_BADPARAM,R0
	RET
100$:  
        CASEL   DB_REC_L_PARAM(R6),#1,#2 ; Select routine 
200$:
	.WORD	201$-200$	; Root
	.WORD	202$-200$	; STP Typ
	.WORD	203$-200$	; Cost to Root
	MOVL	#SS$_BADPARAM,R0
	RET
201$:                           ; ROOT
	ADDL3	#DB_C_KSZ,R6,R1
	MOVZBL	7(R1),-(SP)
	MOVZBL	6(R1),-(SP)
	MOVZBL	5(R1),-(SP)
	MOVZBL	4(R1),-(SP)
	MOVZBL	3(R1),-(SP)
	MOVZBL	2(R1),-(SP)
; Reverse bytes for prio...
	CLRL	INT
	MOVB	(R1),INT+1
	MOVB	1(R1),INT
	PUSHL	INT
	PUSHL	8(AP)
	PUSHL	8(AP)
	PUSHAL	PSRBRDROOT
	CALLS	#10,G^SYS$FAO
        RET
202$:                           ; STP
	MOVQ	@8(AP),R1
	CMPL	#8,R1
	BLEQ	2021$
	MOVL	#SS$_BUFFEROVF,R0
	RET
2021$:
	MOVAL	STPTBL,R3                ; xlate tbl
	ADDL3	#DB_C_KSZ,R6,R1	
	MOVZWL	(R1),R1     		 ; Value
	CMPL	#1,R1                    ; Must be 0 or 1
	BGEQU	2022$                    ; Br ok
	MOVL	#SS$_BADPARAM,R0
	RET
2022$:
	MOVQ	(R3)[R1],(R2)
	MOVL	#8,@8(AP)
	MOVL	#SS$_NORMAL,R0
	RET
203$:           		; Cost
; Reverse bytes for cost...
	CLRL	INT
	ADDL3	#DB_C_KSZ,R6,R1	
	MOVB	3(R1),INT
	MOVB	2(R1),INT+1
	MOVB	1(R1),INT+2
	MOVB	(R1),INT+3
	PUSHL	INT
	PUSHL	8(AP)
	PUSHL	8(AP)
	PUSHAL	ULSTR
	CALLS	#4,G^SYS$FAO
  	RET

	.CALL_ENTRY	MAX_ARGS=2, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=XLATE_LAN_TYPE
;++
;2 XLATE_LAN_TYPE
; Routine to translate the LAN type code to displayable string.
; Table is hard coded in this routine.
;3 Table
;	0 = Unknown 
;	1 = Ethernet
;	2 = FDDI    
;	3 = Tkn Ring
;

;3 Inputs:
;	.address of .word EMU defined LAN type code
;	.address of desc pointing to area where 8 byte string is written
;3 Outputs
;	Translation is written to output
;3 Returns:
;	SS$_NORMAL	OK
;	SS$_BADPARAM	Input code was not 0 - MAXLANTYP (3)
;	SS$_ACCVIO	Could not write outp
;--
	MOVZWL	@4(AP),R6
	CMPL	R6,#MAXLANTYP		; Valid range?
	BLEQ	10$
	MOVL	#SS$_BADPARAM,R0
	RET
10$:
	MOVAL	LANTYPTBL,R7
	MULL	#LANTYPSIZ,R6
	ADDL	R6,R7
	MOVQ	@8(AP),R1
        PROBEW  #0,#LANTYPSIZ,(R2)      ; Write outp?
        BNEQ    20$              	; Br if yes
	MOVL	#SS$_ACCVIO,R0
	RET
20$:
	MOVQ	(R7),(R2)        	; Move string
	MOVL    #LANTYPSIZ,@8(AP)       ; Write ret len
	MOVL	#SS$_NORMAL,R0
	RET



	.CALL_ENTRY	MAX_ARGS=2, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=WEEKDAY
;++
;2 WEEKDAY 
; Routine to translate a .quad abs system time to the day of the 
; week this date occured on. 
;3 Inputs:
;	.address of .quad absolute system time
;	.address of .long where 4 bytes .ascii day is written.
;	The day is always 3 ascii characters and 1 space in len
;3 Outputs
;	Translation is written to output
;3 Returns:
;	SS$_NORMAL	OK
;	any from LIB$_DAY_OF_WEEK
;
;--	 
	PUSHAL	INT     		; Numeric day return
	PUSHL	4(AP)
	CALLS	#2,G^LIB$DAY_OF_WEEK
	BLBS	R0,10$
	RET
10$:
	MOVL	INT,R2                  ; Translate numeric to day
	MOVAL	WEEKDAYTBL,R1
	MOVL	(R1)[R2],@8(AP)
	MOVL	#SS$_NORMAL,R0
	RET



	.CALL_ENTRY	MAX_ARGS=2, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=SNMP_IFXLATE
;++
;2 SNMP_IFXLATE 
; Routine to translate the SNMP standard interface type code to an
; ascii string suitable for display. The length written is always 
; SNMP_IFXLATE_SIZE = 24 bytes.
;3 Inputs:
;	.long	interface code
;	.address of descriptor pointing to where translation is written
;3 Outputs
;	Translation is written to descriptor
;3 Returns:
;	SS$_NORMAL	OK
;	SS$_BUFFEROVF	Oupt buffer to small
;       SS$_BADPARAM	Code < 1 
;3 Description
; The translation table is hardcoded in this routine for performance 
; reasons. If the translation is not in the table, 'OTHER' is returned.
;--	 
	TSTL	4(AP)
	BNEQ	10$
	MOVL	#SS$_BADPARAM,R0
	RET
10$:
	MOVL	4(AP),R6                       ; Code
	CMPL	#SNMP_IFXLATE_ENTRIES,R6          ; In table?
	BGTRU	100$                           ; Br if so
	MOVL	#1,R6	                       ; Set to 'OTHER'
100$:
	DECL	R6
	MULL	#SNMP_IFXLATE_SIZE,R6          ; Ofset into table
	MOVAL	SNMP_IFXLATE_TABLE,R7
	ADDL	R6,R7                          ; This entry
;
	MOVQ	@8(AP),R8
	CMPL	#SNMP_IFXLATE_SIZE,R8		; Outp big enough?
	BLSS	110$
	MOVL	#SS$_BUFFEROVF,R0
	RET
110$:
	MOVC3	#SNMP_IFXLATE_SIZE,(R7),(R9)
	MOVL	#SNMP_IFXLATE_SIZE,@8(AP)
	MOVL	#SS$_NORMAL,R0
	RET

	.CALL_ENTRY	MAX_ARGS=4, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=ADDR2NAME 
;++
;2 ADDR2NAME
; Routine to return name for input address.  
;3 Inputs:
;	.long protocol (SYS_PID_C_xxxx of the PSR)
;	.long len of following address
;	.address of protocol address  (net format)
;	.address of descriptor pointing to where name is written
;3 Outputs
;	If name is found, it is written to descriptor
;	If not found the address is translated to printable string
;	and returned in the descriptor
;3 Returns:
;	SS$_NORMAL		OK   Name is written
;	SS$_LOGNAME		OK  Address is written
;	SS$_ITEMNOTFOUND        Specified address not found
;	SS$_BUFFEROVF		Oupt buffer to small
;	SS$_VALNOTVALID		Undefined SYS_PID_C_xxxx
;	Any from MAP/UNMAP routines
;3 Description
; The specified database is searched for the sepecified address. If
; the db entry is found it performs a NAME_LOOKUP using default 
; preferences. If not, the address is translated to a printable string
; and returned.
;--
; set up and map
	MOVL	4(AP),R6		; PID
	MOVAL	OFFSETTBL,R2
	TSTL	(R2)[R6] 
	BNEQ	100$
	MOVL	#SS$_VALNOTVALID,R0
	RET
100$:
	MOVAL	DBMAP,R3
	CMPL	R6,SYS_MAP_L_PID(R3) 		; Map to same as previous?
	BEQL	130$
110$:
	TSTL	DBMAP				; Have mem?
	BNEQ	120$
	MOVL	R6,SYS_MAP_L_PID(R3) 
	MOVL	(R2)[R6],SYS_MAP_L_KEY(R3)
	MOVAL	LOCKTBL,R2
	MOVL	(R2)[R6],SYS_MAP_L_LOCK(R3)
	MOVAL	DBTBL,R2
	MOVL	(R2)[R6],SYS_MAP_L_SEC(R3)
;
	PUSHL	R3			; Map structure
        CALLS	#1,G^MAPLVB_DB          ; Map db
	BLBS	R0,135$
120$:
	PUSHL	R3			; Map structure
        CALLS	#1,G^UNMAPLVB_DB        ; UnMap db
	BLBS	R0,110$
	RET

130$:
	TSTL	DBMAP			; Have mem?
	BEQL	110$			; Br if not
135$:
	PUSHL	R3			; DB addr
	PUSHL	12(AP)			; Protocol addr
	PUSHL	SYS_MAP_L_KEY(R3)    	; Key location
	PUSHL	8(AP)			; len
	CALLS	#4,G^LOCATE_PSRREC      ; Get boxid
	BLBS	R0,150$                 ; br if Got it
	CMPL    #SS$_ITEMNOTFOUND,R0    ; Not found?
	BEQLU	140$                    
	RET				; Other error
; Translate and return address
140$:
	PUSHL	16(AP)
	PUSHL	12(AP)
	PUSHL	8(AP)
	PUSHL	4(AP)
	CALLS	#4,G^XLATE_ADDR
	RET
150$:
; Found addr - retrieve relater record
	MOVL	R1,R5			; Save PSR
	TSTL	MAPRELATER		; Mapped relater?
	BNEQ	160$			; Br if mapped
;
	PUSHAL	MAPRELATER		; Map structure	
        CALLS	#1,G^MAPLVB_DB          ; Map db
	BLBS	R0,160$
	RET
160$:
	MOVAL	MAPRELATER,R2
	ADDL3	#COM_HDR_L_FLAGS,R1,-(SP)	; This protocol
	PUSHAL	MAPRELATER                      ; Sea relater
	ADDL3	#COM_HDR_L_BOXID,R1,-(SP)       ; This box
	CALLS	#3,G^LOCATE_RELATER_BOXID
	BLBC	R0,140$

	PUSHL	16(AP)
	PUSHL	R1
	CALLS	#2,G^NAME_LOOKUP
	BLBC	R0,140$			; Assume error = not found
	RET

	.CALL_ENTRY	MAX_ARGS=4, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=NAME_LOOKUP  
;++
;2 NAME_LOOKUP 
; Routine to return name for input BOXID.  
;3 Inputs:
;	.address of PSRREC
;	.address of descriptor pointing to where name is written
;    	---------- Optional ---------------------
;	.long flags
;	.address of .long where context is written
;4 Flags
;	Bit		When set
;	0		Exact match only. If set context is ignored
;	1		Preference order 1 (see description)
;
;3 Outputs
;	Name is written to descriptor
;	COntext, if present and appropriate is written
;3 Returns:
;	SS$_NORMAL		OK
;	SS$_ITEMNOTFOUND        did not find matching name
;	SS$_BUFFEROVF		Oupt buffer to small
;       SS$_BADPARAM		Invalid flag field
;				- both bits are set 
;				- Bits other than 0-1 are set
;3 Description
; A name lookup is essentialy BOXID to NAME translation. The default 
; preference order for returning a name is:
;	User set preferred name
;	Name on protocol specified by input PSRREC
;	Any name on this box
; The flags field changes this ordering:
; Bit 0	Exact match is just that. BOXID and Protocol must match 
; Bit 1	Preference order 1 is:
;	Name on protocol specified by input PSRREC
;	User set preferred name
;	Any name on this box
; If the context field is present, it is checked on input and if not 0
; starts the new search from where last one left off. On output it is 
; written with the address of the last record matching search criteria.
;--	 
	TSTL	MAPNAMER		; Mapped?
	BNEQ	100$			; Br if mapped
	PUSHAL	MAPNAMER		; Map structure
        CALLS	#1,G^MAPLVB_DB          ; Map db
	BLBS	R0,100$
	RET
100$:
	CLRL	CONTEXT
	CLRL	R10			; Found secondary name
	CMPL	#4,(AP)			; Context present?
	BNEQ	110$
	MOVL	@16(AP),CONTEXT		; Use context provided
110$:
	MOVL	4(AP),R6		; Relater
; Get name boxid from this rec
	ADDL3	#RLT_DB_TL_BOXIDS,R6,R5
	MOVL	#SYS_PID_C_NAMER,R1
	TSTL	(R5)[R1]
	BNEQ	120$
	MOVL	#SS$_ITEMNOTFOUND,R0
	RET
120$:
; calc addr of this entry
	MULL	#4,R1
	ADDL	R5,R1
	PUSHAL	CONTEXT
	PUSHAL	MAPNAMER                ; Sea NAME db
	PUSHL	R1			; (Boxid) 
	CALLS	#3,G^LOCATE_BOXID
	CMPL	#SS$_NORMAL,R0		; Did rec exist?
	BEQL	200$			; Br if so

	CLRL	R1			; Signal to select from list
	TSTL	R10			; ANy in list?
        BEQL	140$			; Br if none
	BRW	1000$			; End processing
140$:
	RET
200$:
; Addr of found rec in R1
	MOVL	R1,CONTEXT		; Save context
	CMPL	#3,(AP)			; Flags present?
	BGTR	300$			; Br if no
        CASEL   12(AP),#0,#2		; Select routine for mess type
210$:
        .WORD   300$-210$       ; none   (Default processing)
        .WORD   260$-210$       ; exact
        .WORD   270$-210$       ; preference 1
	MOVL	#SS$_BADPARAM,R0
	RET

260$:   			; Exact match
	CMPL	COM_HDR_L_FLAGS(R6),NAM_DB_L_PID(R1)
	BNEQU	110$		; Br if no match
	BRW	1000$		; Found  - end processing
270$:                           ; Prefers exact match
	CMPL	COM_HDR_L_FLAGS(R6),NAM_DB_L_PID(R1)
	BEQLU	275$		; Br no match
	BRW	1000$		; Found  - end processing
275$:
; Save this potential name 
	MOVL	R1,R10
	BRW	110$		; Get another

300$:
	TSTL	NAM_DB_L_PID(R1) 	; Prefered name?
	BEQL	310$			; Br no match
	BRW	1000$			; Found  - end processing
310$:
; Save this potential name
	MOVL	R1,R10
	BRW	110$			; Get another
	

	
1000$:
; Return either name in R1 or secondary
	TSTL	R1              ; Specifc name ?
	BNEQ	1010$           ; No - use 2nd
	MOVL	R10,R1		; Use specific
1010$:
	MOVQ	@8(AP),R6	
	SUBL3	#8,COM_HDR_L_LEN(R1),R2		; Len of name
	CMPL	R2,R6
	BLEQU	1020$
	MOVL	#SS$_BUFFEROVF,R0
	RET
1020$:
	MOVL	R2,@8(AP)			; Len
	MOVC3	R6,NAM_DB_AS_NAME(R1),(R7)      ; Name
	CMPL	#4,(AP)				; Context present?
	BNEQ	1030$                   	; BR Not
	MOVL	CONTEXT,@16(AP)         	; Return context
1030$:
	MOVL	#SS$_NORMAL,R0
	RET


	.CALL_ENTRY	MAX_ARGS=2, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=FORMAT_DECNET_ADDR 
;++
;2 FORMAT_DECNET_ADDR  
; Routine to format the specified DECnet address into 
; printable string. 
;3 Inputs:
;	.address of EMUDB rec
;	.address of descriptor where string is written
;3 Outputs:
;	printable string 
;3 Returns:
;	Any return from $FAO
	MOVL	4(AP),R6		; Tag start
	CLRQ	DADDR
	MOVZWL	DB_C_KSZ(R6),DADDR	; Get addr in  quad
	EDIV    #1024,DADDR,R1,R2       ; R1 = area, r2 = node

	PUSHL	R2
	PUSHL	R1
	PUSHL	8(AP)
	PUSHL	8(AP)
	PUSHAL	PSRDN4ADDR
	CALLS	#5,G^SYS$FAO
        RET

	.CALL_ENTRY	MAX_ARGS=2, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=FORMAT_ADDR 
;++
;2 FORMAT_ADDR  
; Routine to format the specified protocol address into 
; printable string. 
;3 Inputs:
;	.address of QUERY_STRUCTURE
;	.address of descriptor where string is written
;3 Outputs:
;	printable string 
;3 Returns:
;	SS$_ACCVIO	Can't read PSRrec header
;	Any return from $FAO
;3 Description
;   A paramater in the query structure is the address if the current 
; PSRrec being displayed. This record contains sufficient information
; to determine the address type and len.  
;--
	MOVQ	@4(AP),R6		; db
	MOVL	COM_DBHDR_L_FLAG(R6),R1 ; PID
	MOVL	4(AP),R6
	ADDL	#SUI_QRY_L_CONTEXT,R6	; Addr of addr of rec
	MOVL	(R6),R6			; Addr of rec
	PROBER  #0,#COM_HDR_C_SIZE,(R6) ; Read header?
        BNEQ	10$
	MOVL	#SS$_ACCVIO,R0
	RET
10$:
	CASEL	R1,#0,#12
90$:
	.WORD	100$-90$	; Undef
	.WORD	101$-90$	; Listen ( no db)
	.WORD	102$-90$	; dn4
	.WORD	103$-90$	; DN5
	.WORD	104$-90$	; scs
	.WORD	105$-90$	; lat
	.WORD	106$-90$	; mop
	.WORD	107$-90$	; ip
	.WORD	108$-90$	; ipx
	.WORD	109$-90$	; dns
	.WORD	110$-90$	; dts
	.WORD	111$-90$	; arp
	.WORD	112$-90$	; eth
100$:
101$:
	MOVL	#SS$_BADPARAM,R0
	RET

102$:
	MOVZWL  PSR_DN4_W_ADDR(R6),DADDR            ; Decnet addr
        EDIV    #1024,DADDR,R1,R2
	PUSHL	R2
	PUSHL	R1
	PUSHL	8(AP)
	PUSHL	8(AP)
	PUSHAL	PSRDN4ADDR
	CALLS	#5,G^SYS$FAO
        RET
103$:
	PUSHL	8(AP)		; Outp
	ADDL3	#PSR_DN5_B20_ADDR,R6,-(SP)
	PUSHL	COM_HDR_L_LEN(R6)
	CALLS	#3,G^XLATE_NSAP
        RET
104$:
	ADDL3	#PSR_SCS_EA_ADDR,R6,R7		; Addr
        BRW	1000$

105$:
	ADDL3	#PSR_LAT_EA_ADDR,R6,R7		; Addr
	BRW	1000$

106$:
	ADDL3	#PSR_MOP_EA_ADDR,R6,R7		; Addr
	BRW	1000$
107$:
	ADDL3	#PSR_IP_L_ADDR,R6,R3
	PUSHL	3(R3)
	PUSHL	2(R3)
	PUSHL	1(R3)
	PUSHL	(R3)
	PUSHL	8(AP)
	PUSHL	8(AP)
	PUSHAL	PSRIPADDR
	CALLS	#7,G^SYS$FAO
	RET
108$:
109$:
110$:
111$:
	MOVL	#SS$_BADPARAM,R0
	RET
112$:
	ADDL3	#PSR_ETH_EA_ADDR,R6,R7	; Addr
	BRW	1000$

1000$:
; Common Ethernet translation
	

	MOVZBL	5(R7),-(SP)                     ; Addr
	MOVZBL	4(R7),-(SP)                     ;
	MOVZBL	3(R7),-(SP)                     ;
	MOVZBL	2(R7),-(SP)                     ;
	MOVZBL	1(R7),-(SP)                     ;
	MOVZBL	(R7),-(SP)                      ;
	PUSHL   8(AP)
	PUSHL	8(AP)
	PUSHAL	PSRETHADDR
	CALLS	#9,G^SYS$FAO
        RET


	.CALL_ENTRY	MAX_ARGS=2, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=BLANK_PSR_ERPT 
;++
;2 BLANK_PSR_ERPT 
; Routine to Insert the correct number of commas in a blank record
; for the specified PSR in the the Excel list
;3 Inputs:
;	.long PSRPID
;	.address of descriptor where string is written
;3 Outputs:
;	printable string 
;3 Returns:
;	Any return from $FAO
;3 Description
; In order to retain the necessary formatting fo the excel list, the correct
; number of seperators must be included. The caller calls either this routine
; when there is no record, or FORMAT_PST_ERPT when there is. As long as 1 is 
; called the formatting is maintained.
; In the case of 1 param, a 0 len string is returned (the .long @8(AP) is
; cleared. If 2 params a string containing 1 comma is returned, if 3 params
; 2 commans and so on. 
;--
	MOVL	4(AP),R6		; db
10$:
	CASEL	R6,#0,#18
90$:
	.WORD	100$-90$	; Undef
	.WORD	101$-90$	; Listen ( no db)
	.WORD	102$-90$	; dn4
	.WORD	102$-90$	; DN5
	.WORD	103$-90$	; scs
	.WORD	102$-90$	; lat
	.WORD	103$-90$	; mop
	.WORD	102$-90$	; ip
	.WORD	102$-90$	; ipx
	.WORD	102$-90$	; dns
	.WORD	102$-90$	; dts
	.WORD	102$-90$	; arp
	.WORD	102$-90$	; eth
	.WORD	100$-90$	; REC (no)
	.WORD	102$-90$	; Bridge
	.WORD	100$-90$	; Unassigned
	.WORD	100$-90$	; Unassigned
	.WORD	100$-90$	; Relater (no)
	.WORD	102$-90$	; Name
100$:
101$:
	MOVL	#SS$_BADPARAM,R0
	RET

102$:
; 1 param , no comma
	CLRL	@8(AP)
	MOVL	#SS$_NORMAL,R0
        RET
103$:
; 2 Params, 1 comma
	MOVQ	BLANK1,@8(AP)
	MOVL	#SS$_NORMAL,R0
        RET




	.CALL_ENTRY	MAX_ARGS=2, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=FORMAT_PSR_ERPT 
;++
;2 FORMAT_PSR_ERPT 
; Routine to format the specified PSR rec into a string suitable for output
; to the Excel list
;3 Inputs:
;	.address of PSR rec
;	.address of descriptor where string is written
;3 Outputs:
;	printable string 
;3 Returns:
;	SS$_ACCVIO	Can't read PSRrec header
;	Any return from $FAO
;3 Description
;   A paramater in the query structure is the address if the current 
; PSRrec being displayed. This record contains sufficient information
; to determine the address type and len.  
;--
	MOVL	4(AP),R6		; db
	PROBER  #0,#COM_HDR_C_SIZE,(R6) ; Read header?
        BNEQ	10$
	MOVL	#SS$_ACCVIO,R0
	RET
10$:
	CASEL	COM_HDR_L_FLAGS(R6),#0,#18
90$:
	.WORD	100$-90$	; Undef
	.WORD	101$-90$	; Listen ( no db)
	.WORD	102$-90$	; dn4
	.WORD	103$-90$	; DN5
	.WORD	104$-90$	; scs
	.WORD	105$-90$	; lat
	.WORD	106$-90$	; mop
	.WORD	107$-90$	; ip
	.WORD	108$-90$	; ipx
	.WORD	109$-90$	; dns
	.WORD	110$-90$	; dts
	.WORD	111$-90$	; arp
	.WORD	112$-90$	; eth
	.WORD	113$-90$	; REC (no)
	.WORD	114$-90$	; Bridge
	.WORD	115$-90$	; Unassigned
	.WORD	116$-90$	; Unassigned
	.WORD	117$-90$	; Relater (no)
	.WORD	118$-90$	; Name
100$:
101$:
	MOVL	#SS$_BADPARAM,R0
	RET

102$:
	MOVZWL  PSR_DN4_W_ADDR(R6),DADDR            ; Decnet addr
        EDIV    #1024,DADDR,R1,R2
	PUSHL	R2
	PUSHL	R1
	PUSHL	8(AP)
	PUSHL	8(AP)
	PUSHAL	PSRDN4ADDR
	CALLS	#5,G^SYS$FAO
        RET
103$:
	PUSHL	8(AP)		; Outp
	ADDL3	#PSR_DN5_B20_ADDR,R6,-(SP)
	PUSHL	COM_HDR_L_LEN(R6)
	CALLS	#3,G^XLATE_NSAP
        RET
104$:
; Addr,no
	MOVZWL	PSR_SCS_W_CLUID(R6),-(SP)	; Number
	ADDL3	#PSR_SCS_EA_ADDR,R6,R7		; Addr
	MOVZBL	5(R7),-(SP)                     ; Addr
	MOVZBL	4(R7),-(SP)                     ;
	MOVZBL	3(R7),-(SP)                     ;
	MOVZBL	2(R7),-(SP)                     ;
	MOVZBL	1(R7),-(SP)                     ;
	MOVZBL	(R7),-(SP)                      ;
	PUSHL   8(AP)
	PUSHL	8(AP)
	PUSHAL	PSRSCSREC
	CALLS	#10,G^SYS$FAO
        RET
105$:
	ADDL3	#PSR_LAT_EA_ADDR,R6,R7		; Addr
	MOVZBL	5(R7),-(SP)                     ; Addr
	MOVZBL	4(R7),-(SP)                     ;
	MOVZBL	3(R7),-(SP)                     ;
	MOVZBL	2(R7),-(SP)                     ;
	MOVZBL	1(R7),-(SP)                     ;
	MOVZBL	(R7),-(SP)                      ;
	PUSHL   8(AP)
	PUSHL	8(AP)
	PUSHAL	PSRLATREC
	CALLS	#9,G^SYS$FAO
        RET
106$:
; addr,device (translated)
; Translate device


;	.LONG address of .BYTE input pointing to SYSID  (read only)
; 	.ADDRESS - Desc pointing to output area         (read/write)
	MOVL	#32,TEMPSTR_D
	PUSHAL	TEMPSTR_D			; Outp
	ADDL3	#PSR_MOP_B_DEVID,R6,-(SP)	; Device code
	CALLS	#2,G^MOP_DEVXLT
	BLBS	R0,10610$
	RET
10610$:
	PUSHAL	TEMPSTR_D			; Translated device
	ADDL3	#PSR_MOP_EA_ADDR,R6,R7		; Addr
	MOVZBL	5(R7),-(SP)                     ; Addr
	MOVZBL	4(R7),-(SP)                     ;
	MOVZBL	3(R7),-(SP)                     ;
	MOVZBL	2(R7),-(SP)                     ;
	MOVZBL	1(R7),-(SP)                     ;
	MOVZBL	(R7),-(SP)                      ;
	PUSHL   8(AP)
	PUSHL	8(AP)
	PUSHAL	PSRMOPREC
	CALLS	#10,G^SYS$FAO
        RET
107$:
	ADDL3	#PSR_IP_L_ADDR,R6,R3
	PUSHL	3(R3)
	PUSHL	2(R3)
	PUSHL	1(R3)
	PUSHL	(R3)
	PUSHL	8(AP)
	PUSHL	8(AP)
	PUSHAL	PSRIPADDR
	CALLS	#7,G^SYS$FAO
	RET
108$:
	MOVZWL	PSR_IPX_W_SERVICE(R6),-(SP)     ; Service code (may xlate some time)
	ADDL3	#PSR_IPX_EA_ADDR,R6,R7		; Addr
	MOVZBL	5(R7),-(SP)                     ; Addr
	MOVZBL	4(R7),-(SP)                     ;
	MOVZBL	3(R7),-(SP)                     ;
	MOVZBL	2(R7),-(SP)                     ;
	MOVZBL	1(R7),-(SP)                     ;
	MOVZBL	(R7),-(SP)                      ;
	PUSHL	PSR_IPX_L_NET(R6)		; Net number
	PUSHL   8(AP)
	PUSHL	8(AP)
	PUSHAL	PSRIPXREC
	CALLS	#11,G^SYS$FAO
        RET
109$:
110$:
111$:
	MOVL	#SS$_BADPARAM,R0
	RET
112$:

	ADDL3	#PSR_ETH_EA_ADDR,R6,R7	; Addr
	MOVZBL	5(R7),-(SP)                     ; Addr
	MOVZBL	4(R7),-(SP)                     ;
	MOVZBL	3(R7),-(SP)                     ;
	MOVZBL	2(R7),-(SP)                     ;
	MOVZBL	1(R7),-(SP)                     ;
	MOVZBL	(R7),-(SP)                      ;
	PUSHL   8(AP)
	PUSHL	8(AP)
	PUSHAL	PSRETHADDR
	CALLS	#9,G^SYS$FAO
        RET
113$:
	MOVL	#SS$_BADPARAM,R0
	RET
114$:
	ADDL3	#PSR_BRD_EA_ADDR,R6,R7	; Addr
	MOVZBL	5(R7),-(SP)                     ; Addr
	MOVZBL	4(R7),-(SP)                     ;
	MOVZBL	3(R7),-(SP)                     ;
	MOVZBL	2(R7),-(SP)                     ;
	MOVZBL	1(R7),-(SP)                     ;
	MOVZBL	(R7),-(SP)                      ;
	PUSHL   8(AP)
	PUSHL	8(AP)
	PUSHAL	PSRETHADDR
	CALLS	#9,G^SYS$FAO
        RET
115$:
116$:
117$:
	MOVL	#SS$_BADPARAM,R0
	RET
118$:
; Name. Place the associated (translated) PID in brackets: VAX1 (SCS)
	PUSHAL	TEMPSTR
	PUSHL	NAM_DB_L_PID(R6)
	CALLS	#2,G^XLATE_PSRID 
	BLBS	R0,11810$
	RET
11810$:
        PUSHAL	TEMPSTR				; Translated PID
	ADDL3	#NAM_DB_AS_NAME,R6,-(SP)	; Addr
	SUBL3	#8,COM_HDR_L_LEN(R6),-(SP)	; Len of name
	PUSHL   8(AP)
	PUSHL	8(AP)
	PUSHAL	PSRNAMREC
	CALLS	#6,G^SYS$FAO
        RET

	.CALL_ENTRY	MAX_ARGS=4, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=XLATE_ADDR 
;++
;2 XLATE_ADDR  
; Routine to format the specified protocol address into 
; printable string. 
;3 Inputs:
;	.long	 PID
;	.long	len of following addr
;	.address of protocol address
;	.address of descriptor where string is written
;3 Outputs:
;	printable string 
;3 Returns:
;	SS$_ACCVIO	Can't read PSRrec input
;	SS$_BADPARAM	Unrecognised or invalid DB
;	Any return from $FAO
;3 Description
;	Translate the input protocol address using the routine specified
;	by the PID. The PID is the SYS_PID_C_xxxx of the db this 
;	address normaly appears in.
;--
;
	MOVL	4(AP),R1		; PID
	MOVL	12(AP),R6		; Input
10$:
	CASEL	R1,#0,#18
90$:
	.WORD	100$-90$	; Undef
	.WORD	101$-90$	; Listen ( no db)
	.WORD	102$-90$	; dn4
	.WORD	103$-90$	; DN5
	.WORD	104$-90$	; scs
	.WORD	105$-90$	; lat
	.WORD	106$-90$	; mop
	.WORD	107$-90$	; ip
	.WORD	108$-90$	; ipx
	.WORD	109$-90$	; dns
	.WORD	110$-90$	; dts
	.WORD	111$-90$	; arp
	.WORD	112$-90$	; eth
	.WORD	113$-90$	; rec
	.WORD	114$-90$	; brd
	.WORD	115$-90$	; una1
	.WORD	116$-90$	; una2
	.WORD	117$-90$	; rel
	.WORD	118$-90$	; name
100$:
101$:
	MOVL	#SS$_BADPARAM,R0
	RET

102$:
	MOVZWL  (R6),DADDR            ; Decnet addr
        EDIV    #1024,DADDR,R1,R2
	PUSHL	R2
	PUSHL	R1
	PUSHL	16(AP)
	PUSHL	16(AP)
	PUSHAL	PSRDN4ADDR
	CALLS	#5,G^SYS$FAO
        RET
103$:
	PUSHL	16(AP)		; Outp
	PUSHL	12(AP)		; NSAP
	PUSHL	8(AP)		; len
	CALLS	#3,G^XLATE_NSAP
        RET
104$:
        BRW	1000$

105$:
	BRW	1000$

106$:
	BRW	1000$
107$:
	PUSHL	3(R6)
	PUSHL	2(R6)
	PUSHL	1(R6)
	PUSHL	(R6)
	PUSHL	16(AP)
	PUSHL	16(AP)
	PUSHAL	PSRIPADDR
	CALLS	#7,G^SYS$FAO
	RET
108$:
	PUSHL	(R6)                    ; NET
	PUSHL	9(R6)
	PUSHL	8(R6)
	PUSHL	7(R6)
	PUSHL	6(R6)
	PUSHL	5(R6)
	PUSHL	4(R6)
	MOVZWL	10(R6),-(SP)		; Service
	PUSHL	16(AP)
	PUSHL	16(AP)
	PUSHAL	PSRIPXADDR
	CALLS	#11,G^SYS$FAO
	RET

109$:
110$:
111$:
	MOVL	#SS$_BADPARAM,R0
	RET
112$:
	BRW	1000$

1000$:
; Common Ethernet translation
	

	MOVZBL	5(R6),-(SP)                     ; Addr
	MOVZBL	4(R6),-(SP)                     ;
	MOVZBL	3(R6),-(SP)                     ;
	MOVZBL	2(R6),-(SP)                     ;
	MOVZBL	1(R6),-(SP)                     ;
	MOVZBL	(R6),-(SP)                      ;
	PUSHL   16(AP)
	PUSHL	16(AP)
	PUSHAL	PSRETHADDR
	CALLS	#9,G^SYS$FAO
        RET
113$:
114$:
115$:
116$:
117$:
	MOVL	#SS$_BADPARAM,R0
	RET
118$:
; Name
; Pid,Key2,.ascii name
	ADDL3	#8,R6,-(SP)
	SUBL3	#8,8(AP),-(SP)
	PUSHL	4(R6)
	PUSHL	(R6)
	PUSHL   16(AP)
	PUSHL	16(AP)
	PUSHAL	PSRNAMADDR
	CALLS	#7,G^SYS$FAO
        RET






	.CALL_ENTRY	MAX_ARGS=3, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=MAKE_PTYTYP  
;++
;2 MAKE_PTYTYP  
; Routine to translate VMS Ethernet header to EMU Internal protocol type.
;3 Inputs:
;	.address of EMU EBUFF
;	.address of .quad where internal type is written
;3 Outputs:
;	Internal type 
;3 Returns:
;	SS$_NORMAL	OK
;3 Description
; There are 2 Ethernet frame types with one type in two parts. Effectively
; 3 types. In order to speed processing convert to a standard internal.
; As in P5 receive:
; Type		 position	Len		Desc
; Enet II	12		2	The familiar 2 byte field
; IEEE		12		3	3 bytes are: DSAP,SSAP,CTRL
; IEEE SNAP	12		8	When DSAP, SSAP = AAAA then
;					5 byte field follows CTRL (ofset 15)
; These are converted to an internal format used ONLY in this context:
; Type		Byte 0 		Remainder of quad
; Enet		  1		bytes 6,7 = bytes 12,13 of original
; IEEE		  2		Byte 7 = DSAP (byte 12 of original
; SNAP		  3		Bytes 3 - 7 = bytes 15 - 20 or original
;--  
; 
	MOVL	4(AP),R6                        ; EBUFF
	MOVL	8(AP),R8                        ; Outp
	CLRQ	(R8)  	       			; Init 

	TSTL	IPC_ETH_L_TYPIND(R6)          	; Control field = 0?
	BNEQ	10$		       		; Br if not
	MOVW	IPC_ETH_W_PTY(R6),SYS_ETP_W_ETYPII(R8) 	; Move in protocol type
	MOVB	#SYS_ETP_C_ETHERNET,(R8)	; Ethernet II
	MOVL	#SS$_NORMAL,R0
	RET
10$:
	CMPW	IPC_ETH_W_PTY(R6),#SYS_ETP_C_SNAPVAL  	; SNAP frame?
	BEQL	20$		       			; Br if so
	MOVB	IPC_ETH_W_PTY(R6),SYS_ETP_B_DSAP(R8) 	; Move DSAP
	MOVB	#SYS_ETP_C_IEEE,(R8)			; 802.3
	MOVL	#SS$_NORMAL,R0
	RET
20$:
	MOVB	#SYS_ETP_C_SNAP,(R8)			; SNAP Type
	ADDL3	R6,#IPC_ETH_5_SNAPPID,R1                ; Inpt addr
	ADDL3	R8,#SYS_ETP_5_EPID,R2                  ; Outp addr
	MOVL	(R1),(R2)	 		; Move in protocol type
	MOVB	4(R1),4(R2)			; Move in protocol type
	MOVL	#SS$_NORMAL,R0
	RET
 

	.PSECT	XLATE_ENETPTY,NOWRT,EXE,SHR,PIC,LONG
	.sbttl	XLATE_SERVICES5_C ()
	.CALL_ENTRY	MAX_ARGS=3, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=XLATE_ENETPTY 
; Modifications
;	01-001	PB     			Creation
;	01-002	PB	NOV 1992	Table is loaded at init only
;					table size is now variable
;		      			added option to force table rebuild 
;		      			Simpler return coding
;	01-003  PB      26_Apr-1993     Handler returns correct error. Removed
;					access and param checks.
;	01-004  PB      16-AUG-1993     If translation not found return
;					converted input in brackets. (xxxx)
;	02-001	PB	AUG 1996	Converted for V5
;++ 
;2 XLATE_ENETPTY
; Routine to translate the EMU formatted protocol type  field to
; the registered name and optionaly, Ethernet frame type.
; The routine /file combination now handles:
; Ethernet type II (2 byte protocol type)
; IEEE 802.3	(1 byte DSAP)
; IEEE SNAP  (5 byte PID)
;3 Inputs
; 		.address of .QUAD input. EMU Formatted protocol type 
;		.address of desc pointing to outp. May be up to 255 bytes.
;		.long by val optional flag field
;4 Input_format
;  field	ofs	len		desc
; type		0	1	EMU defined frame type: type2, IEEE or extended
; ETYYPE	6	2	2 byte protocol field when type2
; DSAP		7	1	1 byte Destination SAP when IEEE
; SNAP		3	5	5 byte extended PID when SNAP
; Bytes 1,2 never written
;4 Optional_flag 
;	bit			When Set
;	0		Include frame type translation
;
;3 Outputs	
;	.ASCIC registered name
;--
; **************OBSOLETE******************
;****** FOLLOWING CALL REDIRECTS PROCESSING **************
; AT SOME FUTURE TIME REMOVE THIS ROUTINE AND REPLACE ALL CALLS TO IT
; WITH FOLLOWING:
	PUSHL	8(AP)
	PUSHL	4(AP)
	CALLS	#2,G^XLTTBL_XLTPTY
	RET
; *************************************************************
        .CALL_ENTRY     MAX_ARGS=3, -
                        HOME_ARGS=TRUE, -
                        INPUT   =<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
                        PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
                        LABEL=EMU_BITPTOASCIC 
; Modifications:
; 02-apr-1997	PB	Changed output to ascii (not ascic)
;++ 
;2 EMU_BITPTOASCIC 
; Translate group bits. This routine searches a bit pattern and returns an
; .ascii string showing bits found to be set. 
;3 Inputs
;       .long   addresss of bit pattern to search
;       .long   value of number of bits to search
;       .long   address of desc pointing to outp
;
;3 Ouputs
;       .ASCII   Comma seperated list of bits set. On overflow the last
;                char is '+'.
;3 Abstract
;The returned string is formed as follows:
; 
; While limit .lt.  Number of bits to search:
;       Find first bit set.
;       Translate bit No. to ascii and place in str+1
;       Br to Lastbitset
;   Lastbitset:
;       Find next bit clear
;       Translate bit No. - 1 to acsii and add '-bit' to str
;       Br to lastbitclear
;   Lastbitclear:
;       Find next bit set
;       Add ',' to str
;       Translate bit No. to ascii and add to str
;       Br to lastbitset
; Calc len of resulting str and put in first byte to form .ascic
; End
;-- 
; R2 = Index into bitp
; R3=(Enabled Group bit pattern)
; R4 = outp len
; R5 = (.ascic output)
; R10 = written byte count (1st byt of outp) 
; R11 = Number of bits to search


        MOVL    4(AP),R3
        MOVL    8(AP),R11       ; Number of bits
        MOVQ    @12(AP),R4      ; R4 = len, R5 = addr outp
; Check params
        DIVL3   #8,R11,R1       ; Make bytes from bits
        INCL    R1
        PROBER  #0,R1,(R3)      ; Read Bits?
        BEQL    1$              ; Br if no
        PROBEW  #0,R4,(R5)      ; Write outp?
        BNEQ    2$              ; Br if yes
1$:
        MOVL    #SS$_ACCVIO,R0
        RET
2$:
        CLRL    R2              ; Start at begin

; Find first set
10$:
        BBS     R2,(R3),20$     ; Br when set bit found
        AOBLEQ  R11,R2,10$
        MOVQ    @12(AP),R6      ; Get original desc
        SUBL3	R7,R5,@12(AP)   ; return written len
        MOVL    #SS$_NORMAL,R0  ; None found 
        RET
20$:
        MOVL    R2,INT          ; Current bit position
        BSBW    100$            ; Convert an place in outp
        CMPL    R2,R11          ; Last Bit?
        BLSS    25$
        MOVQ    @12(AP),R6      ; Get original desc
        SUBL3	R7,R5,@12(AP)   ; return written len
        MOVL    #SS$_NORMAL,R0
        RET
25$:
        DECL    R4              ; check space
        BGTR    27$             ; OK    
        MOVL    #SS$_BUFFEROVF,R0	; ran out
	RET
27$:
        INCL    R2              ; Next bit
        MOVB    #^A/-/,(R5)     ; Move seperator
; Check next bit if set 
        BBS     R2,(R3),30$     ; Br if set bit found
        MOVB    #^A/,/,(R5)     ; Replace seperator
30$:
; Find next clear
        INCB    R5              ; Move outp pointer
35$:
        BBC     R2,(R3),40$     ; Br when clr bit found
        AOBLEQ  R11,R2,35$       ; loop to end
; No more clear bits - rest of bits set
        MOVL    8(AP),INT       ; Get value of last bi
        bsbw    100$            ; Print last value
        MOVQ    @12(AP),R6      ; Get original desc
        SUBL3	R7,R5,@12(AP)   ; return written len
        MOVL    #SS$_NORMAL,R0  ; Exit
        RET
40$:
        DECL    R2              ; Last bit set
        CMPL    R2,INT          ; Same bit?
        BEQLU   50$             ; Yes - dont print
        MOVL    R2,INT          ; Current bit position
        BSBW    100$            ; Convert an place in outp
; Find next set
50$:
        INCL    R2
52$:
        BBS     R2,(R3),20$     ; Br when set bit found
        AOBLEQ  R11,R2,52$
        MOVQ    @12(AP),R6      ; Get original desc
        SUBL3	R7,R5,@12(AP)   ; return written len
        MOVL    #SS$_NORMAL,R0  ; No more set
        RET     
100$:
        .JSB_ENTRY      INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>,-
			OUTPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
; CHeck if outp area exceeded
; If so add '+' to outp and signal overflow
        SUBL    #3,R4           ; Will write 3 digits
        BLEQ    110$            ; Yes - error   
        PUSHAL  OUTNUM_D        ; Output
        PUSHAL  INT             ; Input
        CALLS   #2,G^OTS$CVT_L_TU
        BLBS    R0,105$
        RET
105$:
        MOVW    OUTNUM,(R5)+   	; Move Hi digits
        MOVB    OUTNUM+2,(R5)+  ; Move Lo digi
        RSB
110$:
        MOVB    #^A/+/,(R5)     ; Add seperator
        MOVQ    @12(AP),R6      ; Get original desc
        SUBL3	R7,R5,@12(AP)   ; return written len
        MOVL    #SS$_BUFFEROVF,R0
        RET

	.CALL_ENTRY	MAX_ARGS=12, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=ASCII_STRING  

;++ 
;2 ASCII_STRING
; Translate ascii string. This routine is provided to get around the 
; limitations of the translation routine. It can only translate
; a paramater and does not differentiate between params that need address
; input or value input. That routine is always value input. Ascii strings
; are address. Very simply, this routine takes the input param desc and
; FAOs it into the output desc.
;3 Input
; addr of desc pointing to ascii string
; addr of des pointing to output.
;3 Output
; Ascii string
;3 Return
; Any return from $FAO
;--
	MOVL	4(AP),R6
	MOVL	8(AP),R8
	PUSHL	R6
	PUSHL	R8
	PUSHL	R8
	PUSHAL	ASSTR
	CALLS	#4,G^SYS$FAO
	RET


 
	.CALL_ENTRY	MAX_ARGS=12, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=EADRTOASCII  

;++ 
;2 EADRTOASCII
; Translate net formatted Ethernet addr to readable form.
;3 Example
; 5634122B0008 (6 bytes) is translated to 08-00-2B-12-34-56<SP> (18 Bytes)
;
;3 Inputs
;	.long	addresss of 6 bytes Ethernet address in hex
;	.long	address of descriptor to write (17 or 18 bytes) return to
;	.long	(option)Value flags. If present then return .ascic
;
;3 Ouputs:
;	.ASCII  Ethernet address  or .ASCIC Ethernet address
;-- 
	MOVL	8(AP),R8	; Get desc
	CMPL	#3,(AP)		; Args
	BNEQ	10$
	INCL	4(R8)		; Move outp field over 1 byte
10$:
	MOVL	4(AP),R6
	CVTBL	5(R6),-(SP)
	CVTBL	4(R6),-(SP)
	CVTBL	3(R6),-(SP)
	CVTBL	2(R6),-(SP)
	CVTBL	1(R6),-(SP)
	CVTBL	(R6),-(SP)
	PUSHL	R8
	PUSHL	R8
	PUSHAL	CNTRSTR
	CALLS	#9,G^SYS$FAO
	BLBC	R0,30$
	CMPL	#3,(AP)		; Args
	BNEQ	30$             ; Br if option not present
        DECL	4(R8)		; Reset to begin
	MOVB	#18,@4(R8)      ; Place byte count (make .ascic)
	INCL	(R8)		; Adjust returned len
30$:
	RET

	.CALL_ENTRY	MAX_ARGS=12, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=ASCTOBITP
;++ 
;2 ASCTOBITP
; Translate comma seperated list of decimal numbers to bit pattern. 
; valid inputs are 0-255 ',' and '-'
; 
;3 Inputs
;	.long	address of desc pointing to inpt
;	.long	addresss of 32 byte bit pattern to return
; 
;3 Ouputs
;	.blkb	32 bytes wherein a bit is set if the input specified this
;		number.
;--

	MOVQ	@4(AP),R6	;  R6 = Len , R7 = address of input
	MOVL	8(AP),R8	;  Outp addr
	ADDL3	R6,R7,R11	; R11 = last byte
10$:
	CMPL	R7,R11
	BLSSU	20$
; Set bit found in INT
	BBSS	INT,(R8),15$
15$:
	MOVL	#SS$_NORMAL,R0
	RET
20$:
	CMPB	#^A/,/,(R7)
	BEQLU	100$
	CMPB	#^A/-/,(R7)
	BEQLU	200$
; Must be number
30$:
	CLRL	R4		; Char count
35$:
	CMPB	#^A/,/,(R7)[R4]
	BEQLU	40$
	CMPB	#^A/-/,(R7)[R4]
	BEQLU	40$
	AOBLSS	R6,R4,35$ 		; count char
40$:
; Translate number
	PUSHAL	INT
	PUSHL	R7
	PUSHL	R4
	CALLS	#3,G^LIB$CVT_DTB
	BLBS	R0,50$
	MOVL	#SS$_BADPARAM,R0
	RET
50$:
	ADDL	R4,R7		; Next char
	SUBL	R4,R6		; Reset to remaining len
	BRW	10$
100$:
; Set bit found in INT
	BBSS	INT,(R8),110$
110$:	INCL	R7
	DECL	R6
	BRW	10$
200$:
; Translate next num and set all bits in range INT to INT2
  	INCL	R7		; Next char
	DECL	R6
	CLRL	R4		; Char count
210$:
	CMPB	#^A/,/,(R7)[R4] ; Must be either No. or ','
	BEQLU	240$
        AOBLSS	R6,R4,210$
240$:
	PUSHAL	INT2
	PUSHL	R7
	PUSHL	R4
	CALLS	#3,G^LIB$CVT_DTB
	BLBS	R0,250$
	MOVL	#SS$_BADPARAM,R0
	RET
250$:
	CMPL	INT,INT2
	BGTRU	270$
	BBSS	INT,(R8),260$
260$:
	INCL	INT
	BRB	250$
270$:
	ADDL	R4,R7			; Next char
	INCL	R7			; Skip ','
	SUBL	R4,R6
	DECL	R6
	BRW	10$

; Here on unhandled error
; Returns SS$_ABORT 
	.CALL_ENTRY	MAX_ARGS=12, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=XLATE_SERVICES_HANDLER
        $UNWIND_S			; Unwind stack to caller
	MOVL	CHF$L_SIG_NAME,R0	; Error
	RET				; Suicide



	.CALL_ENTRY	MAX_ARGS=3, -
			HOME_ARGS=TRUE, - 
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=XLATE_CIRCTYP  
;++
;2 XLATE_CIRCTYP
; Routine to translate CMIP Routing circuit type code to .ascii string
;3 Inputs
;	.address of descriptor pointing to EMUDB formatted record
;	.address Descriptor pointing to output
;3 Outputs
; 	The translated cic type is written in the output field
;	The output len is written in the descriptor 
;3 Returns
; 	SS$_NORMAL	all is well
;	SS$_BADPARAM	Unrecognised type
;	SS$_ACCVIO	Can't read/write inpt/outp
;	SS$_BUFFEROVF	Outp too small
;--
	MOVQ	@4(AP),R8			; REC desc
	PROBER	#0,R8,(R9)			; Check for write access
	BEQL	10$				; No
	MOVQ	@8(AP),R6			; Outp desc
	PROBER	#0,R6,(R7)			; Check for write access
	BNEQ	20$				; OK
10$:
	MOVL	#SS$_ACCVIO,R0
	RET
20$:

	MOVZBL	DB_REC_C_CDATA(R9),R1          ; circ type
	BLSS	30$				; Br if < 0
	CMPL	#CIRCTYP_MAX,R1
	BLSS	30$
	MOVAL	XLATE_CIRCTYP_TBL,R2		; Lookup table
	MOVL	(R2)[R1],R3			; Addr of xlation
        CMPL	#CIRCTYP_SIZ,R6			; ENough room?
	BGTR	40$
	MOVC3	#CIRCTYP_SIZ,(R3),(R7)
	MOVL	#CIRCTYP_SIZ,@8(AP)
	MOVL	#SS$_NORMAL,R0
	RET

30$:
	MOVL	#SS$_BADPARAM,R0
	RET
40$:
	MOVL	#SS$_BUFFEROVF,R0
	RET
 
	.CALL_ENTRY	MAX_ARGS=3, -
			HOME_ARGS=TRUE, - 
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=XLATE_CMP_VER    
;++
;2 XLATE_CMP_VER
; Routine to translate CMIP Version code to .ascii string
;3 Inputs
;	.address of descriptor pointing to EMUDB formatted param
;	.address Descriptor pointing to output
;4 Input_format
;	.word	tag class    	(must be 1)
;	.word	tag value       (must be 33)
;	.long	len of data     (must be 4)
;	.var	data
;3 Outputs
; 	The translated Version is written in the output field
;	The output len is written in the descriptor 
;4 Format
; Version if a 4 byte code:
;	Byte		Description
;	0	Status. One of V(Approved),T(Field Test),X(Draft)
;	1	Major
;	2	Minor
;	3	ECO
;3 Returns
;	SS$_ACCVIO	Can't read/write inpt/outp
;	Any return from $FAO
;--
	MOVQ	@4(AP),R8			; REC desc
	PROBER	#0,R8,(R9)			; Check for write access
	BEQL	10$				; No
	MOVQ	@8(AP),R6			; Outp desc
	PROBER	#0,R6,(R7)			; Check for write access
	BNEQ	20$				; OK
10$:
	MOVL	#SS$_ACCVIO,R0
	RET
20$:
  	MOVAL	FAOLIST,R10
	ADDL3	#8,R9,R1          		; Start of string
	MOVL	#1,(R10)+			; Len of string
	MOVL	R1,(R10)+			; 1st char
	INCL	R1				; 1st digit
	MOVZBL	(R1)+,(R10)+
	MOVZBL	(R1)+,(R10)+
	MOVZBL	(R1)+,(R10)+
;
	PUSHAL	FAOLIST	
	PUSHL	8(AP)
	PUSHL	8(AP)
	PUSHAL	VERSTR
        CALLS	#4,SYS$FAOL
	RET


	.CALL_ENTRY	MAX_ARGS=2, -
			HOME_ARGS=TRUE, - 
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=XLATE_CMIP_ADDRESS    
;++
;2 XLATE_CMIP_ADDRESS
; Routine to translate CMIP address code(s) to .ascii NSAP string
;3 Inputs
;	.address of descriptor pointing to EMUDB formatted record
;	.address Descriptor pointing to output
;3 Outputs
; 	The translated NSAP(s) is/are written in the output field
;	The output len is written in the descriptor 
;4 Format
; There is a wealth of other informattion in this block that requires
; further translation. In this version we simply extract all NSAPs (assumed
; to be any octect string with len >4) format them and return. Each NSAP
; found is returned as a null terminated string.
;3 Returns
;	SS$_ACCVIO	Can't read/write inpt/outp
;	SS$_NODATA	No data in record
;	Any return from XLATE_NSAP
;--
	CLRL	R11				; Outp accumulator
	MOVQ	@4(AP),R6			; Inpt desc
	PROBER	#0,R6,(R7)			; Check for read access
	BEQL	10$				; No
	MOVQ	@8(AP),R8			; Outp desc
	PROBEW	#0,R8,(R9)			; Check for write access
	BNEQ	15$				; OK
10$:
	MOVL	#SS$_ACCVIO,R0
	RET
15$:
	ADDL	#DB_C_KSZ,R7			; Start of data
	SUBL	#DB_C_KSZ,R6			; Deduct
	BGTR	20$
	MOVL	#SS$_NODATA,R0
	RET

20$:
; Find next NSAP
	CMPL	(R7),CMIP_TAG_UNOCT		; Octet str?
	BNEQU	100$
	CMPL	4(R7),#4
	BLEQU	100$
; Assume we have found NSAP
	MOVQ	R8,TEMPDESC2
	PUSHAL	TEMPDESC2
	ADDL3	#8,R7,-(SP)
	PUSHL	4(R7)
	CALLS	#3,G^XLATE_NSAP
	BLBS	R0,50$
	MOVL	R11,@8(AP)		; Return len
	RET
50$:
	ADDL3	#1,TEMPDESC2,R1			; Len written + null
	ADDL	R1,R11				; Accumulate
	ADDL3	TEMPDESC2,TEMPDESC2+4,R2
	CLRB	(R2)
; Next outp
	ADDL	R1,R9
	SUBL	R1,R8
100$:
; Next input
	ADDL3	#8,4(R7),R1
	ADDL	R1,R7
	SUBL	R1,R6
	BGEQ	20$
	MOVL	R11,@8(AP)		; Return len
	MOVL	#SS$_NORMAL,R0
	RET


	.CALL_ENTRY	MAX_ARGS=2, -
			HOME_ARGS=TRUE, - 
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=XLATE_CMIP_STRINGS    
;++
;2 XLATE_CMIP_STRINGS
; Routine to extract printable strings from  CMIP encoded frame.
;3 Inputs
;	.address of descriptor pointing to EMUDB formatted record
;	.address Descriptor pointing to output
;3 Outputs
; 	The string(s) is/are written in the output field
;	The output len is written in the descriptor 
;4 Format
; Each string found is returned as a null terminated string.
;3 Returns
;	SS$_ACCVIO	Can't read/write inpt/outp
;	SS$_NODATA	No data in record
;	Any return from XLATE_NSAP
;--
	CLRL	R11				; Outp accumulator
	MOVQ	@4(AP),R6			; Inpt desc
	PROBER	#0,R6,(R7)			; Check for read access
	BEQL	10$				; No
	MOVQ	@8(AP),R8			; Outp desc
	PROBEW	#0,R8,(R9)			; Check for write access
	BNEQ	15$				; OK
10$:
	MOVL	#SS$_ACCVIO,R0
	RET
15$:
	ADDL	#DB_C_KSZ,R7			; Start of data
	SUBL	#DB_C_KSZ,R6			; Deduct
	BGTR	20$
	MOVL	#SS$_NODATA,R0
	RET

20$:
; Find next string
	CMPL	(R7),CMIP_TAG_LATSTR		; str?
	BNEQU	100$
	CMPL	4(R7),#4
	BLEQU	100$
; We have found a string
; Check len
	CMPL	4(R7),R8
	BLSS	30$
	MOVL	R11,@8(AP)		; Return len
	MOVL	#SS$_BUFFEROVF,R0
	RET
30$:
	ADDL	4(R7),R11		; Accumulate len
	INCL	R11                     ; + Terminator
	MOVL	4(R7),R1		; Loop control
	ADDL3	#8,R7,R2
40$:
	MOVB	(R2)+,(R9)+
	SOBGTR	R1,40$
	CLRB	(R9)+
	ADDL3	#1,4(R7),R2
	SUBL	R2,R8
100$:
; Next input
	ADDL3	#8,4(R7),R1
	ADDL	R1,R7
	SUBL	R1,R6
	BGEQ	20$
	MOVL	R11,@8(AP)		; Return len
	MOVL	#SS$_NORMAL,R0
	RET






	.CALL_ENTRY	MAX_ARGS=3, -
			HOME_ARGS=TRUE, - 
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=XLATE_CMIP_VERSION    
;++
;2 XLATE_CMIP_VERSION
; Routine to translate CMIP Version code to .ascii string
;3 Inputs
;	.address of descriptor pointing to EMUDB formatted record
;	.address Descriptor pointing to output
;3 Outputs
; 	The translated Version is written in the output field
;	The output len is written in the descriptor 
;4 Format
; Version if a 4 byte code:
;	Byte		Description
;	0	Status. One of V(Approved),T(Field Test),X(Draft)
;	1	Major
;	2	Minor
;	3	ECO
;3 Returns
;	SS$_ACCVIO	Can't read/write inpt/outp
;	Any return from $FAO
;--
	MOVQ	@4(AP),R8			; REC desc
	PROBER	#0,R8,(R9)			; Check for write access
	BEQL	10$				; No
	MOVQ	@8(AP),R6			; Outp desc
	PROBER	#0,R6,(R7)			; Check for write access
	BNEQ	20$				; OK
10$:
	MOVL	#SS$_ACCVIO,R0
	RET
20$:
  	MOVAL	FAOLIST,R10
	ADDL3	#DB_REC_C_CDATA,R9,R1          ; Start of string
	MOVL	#1,(R10)+			; Len of string
	MOVL	R1,(R10)+			; addr of str
	INCL	R1				; 1st digit
	MOVZBL	(R1)+,(R10)+
	MOVZBL	(R1)+,(R10)+
	MOVZBL	(R1)+,(R10)+
;
	PUSHAL	FAOLIST	
	PUSHL	8(AP)
	PUSHL	8(AP)
	PUSHAL	VERSTR
        CALLS	#4,SYS$FAOL
	RET
	.CALL_ENTRY	MAX_ARGS=3, -
			HOME_ARGS=TRUE, - 
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=XLATE_NSAP 
;++
;2 XLATE_NSAP
; Routine to translate binary NSAP into OSI standard output format
;3 Inputs
; 	.long 	 len of binary NSAP in network format (byte reversed) 
;	.address Location of NSAP to translate
;	.address Descriptor pointing to output
;3 Outputs
; 	The translated NSAP is written in the output field
;	The output len is written in the descriptor 
;	If the len = 1 and the 1st byte in the input string = 0
;	then the string 'default value' is returned
;3 Returns
; 	SS$_NORMAL	all is well
;	SS$_BADPARAM	Unrecognised AFI
;	SS$_ACCVIO	Can't read/write inpt/outp
;	Any from $FAO 
;3 Example
; 	490032AA000400C5C815
;	Is translated to:
;	49::00-50:AA-00-04-00-C5-C8:21
;3 Description
; There are 3 parts:
; IDP
; Address
; Selector
; The 1st byte defines the len of the AFI. This is looked up in a table.
; This len (+1) is the len of the addr+selector
; The selector is always 1. In the example then:
; IDP	49::00-32     (Note the IDP is UB as is the SEL - all others XB)
; Addr  AA-00-04-00-C5-C8
; Sel	21
;--
	PROBER	#0,#4,4(AP)			; Check for read access
	BEQL	10$				; No
	PROBER	#0,#4,@8(AP)			; Check for read access
	BEQL	10$				; No
	MOVQ	@12(AP),R6			; Outp desc
	PROBER	#0,R6,(R7)			; Check for write access
	BNEQ	30$				; OK
10$:
	MOVL	#SS$_ACCVIO,R0
	RET
20$:
	MOVL	#SS$_BADPARAM,R0
	RET

30$:
	MOVL	4(AP),R11			; Total len
	CMPL	#1,R11                          ; Check for len = 1
	BNEQ	35$
	BRW     100$				; Br if so
35$:
	MOVAL	IDPTBL,R10			; Lookup IDP len
	MOVL	8(AP),R8			; Input NSAP
40$:
	TSTL	(R10)				; End of table?
	BEQL	20$                            	; Br if so
	CMPB	(R8),(R10)			; Found this AFI?
	BEQLU	50$
	ADDL	#4,R10
	BRB	40$
50$:
	MOVZBL	1(R10),R10			; Len of IDP
	SUBL	R10,R11				; R11 = NSAP - IDP
	DECL	R11				; Last digit is selector
	MOVAL	FAOLIST,R9			; Build list here
	MOVAL	FAOSTR,R4			; Control string
60$:
; AFI
	MOVZBL	(R8)+,(R9)+   			; Digit
	MOVW	FAOXB,(R4)+                     ; Control str
	MOVB	FAOXB+2,(R4)+
	SOBGTR	R10,60$
	MOVW	COLON,(R4)+			; Seperator
70$:
; Addr
	MOVZBL	(R8)+,(R9)+   			; Digit
	MOVW	FAOXB,(R4)+                     ; Control str
	MOVB	FAOXB+2,(R4)+
	MOVB	DASH,(R4)+			; Seperator
	SOBGTR	R11,70$
	DECL	R4				; Remove last '-'
	MOVB	COLON,(R4)+			; Seperator
; Selector
	MOVZBL	(R8)+,(R9)+   			; Digit
	MOVW	FAOXB,(R4)+                     ; Control str
	MOVB	FAOXB+2,(R4)+

; Calc len of control str
	MOVAL	FAOSTR,R3			; Control string
        SUBL3	R3,R4,FAOSTR_D			; Len used
	PUSHAL	FAOLIST	
	PUSHL	12(AP)
	PUSHL	12(AP)
	PUSHAL	FAOSTR_D
        CALLS	#4,SYS$FAOL
	RET
100$:
; If the 1st byte = 0 then return default strng. else badparam
	MOVL	8(AP),R8			; Input NSAP
	TSTB	(R8)
	BNEQ	110$
	MOVQ	@12(AP),R1
	MOVL	#DEFVALSTR_LEN,@12(AP)
	MOVQ	DEFVALSTR,(R2)
	MOVL	#SS$_NORMAL,R0
	RET
110$:
	MOVL	#SS$_BADPARAM,R0
	RET
	

	.CALL_ENTRY	MAX_ARGS=3, -
			HOME_ARGS=TRUE, - 
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=XLATE_FULLNAME  
;++
;2 XLATE_XTRFULLNAME  
; Extract CMIP encoded fullname to .ascii string
;3 Input
; Addr of EMU encoded start of DNS fullname. 1st 16 bytes are 
; binary UID followed by DNS encoded fullname. IF 1st char of name is not
; '01' then return '0:.
; Addr of desc pointing to area where .ascii string is written
; The descriptor is written with the resulting length
;3 Output
; .ascii string of assembled name in format SN:.sn.sn.sn
; where SN is a simplename component
;3 Return
;	SS$_NOTRAN  	Unable to translate (not implemented)
;	SS$_DATACHECK 	Input format error or routine error.
;	Any return from $FAO
;--
	MOVL	4(AP),R7		; input addr
	MOVQ	8(AP),R8		; Outp desc
	MOVL	4(R7),R6			; Total len	
	ADDL	#24,R7                  ; Skip UID,header
	CMPB	#1,(R7)			; DNS name ?
	BEQLU	1$			; Br if not
	BRW	300$			; Not present
1$:
	SUBL	#16,R6			; TOTAL Len
	ADDL3	R6,R7,R3			; Last addr
	MOVAL	FAOLIST,R11		; Build param list here
	MOVAL	FAOSTR,R10		; Build control str here
	CLRL	FAOSTR_D		; No params yet
;	
; Process flag byte
; Flag is bot 4 bits (hi 4 are reserved)
; 0 = null (not present)
; 1 = normal (Latin-1 pritable string)
; 2 = quoted
; 3 = bin
; 4 = wildcard
; 5 = ellipsis (Full-depth wildcard?)
5$:
	EXTZV	#0,#4,(R7),R1		; Extract flag
	CASEB	R1,#0,#5		; Select processing routine
10$:                             
	.WORD	100$-10$                         
	.WORD	101$-10$                         
	.WORD	102$-10$                         
	.WORD	103$-10$                         
	.WORD	104$-10$                         
	.WORD	105$-10$                         
	MOVL	#SS$_DATACHECK,R0        ; Screwed up
	RET
100$:
; Null
;	CLRL	(R11)+			; Param	
;	MOVL	FAOUBSEP,(R10)+		; Control
;	ADDL	#4,FAOSTR_D		; Reset len of control str
	INCL	R7			; Move to next flag 
	CMPL	R7,R3                   ; any frame left?
	BLSSU	5$                      ; Br if yes
	BRW	200$			; End processing
101$:
; Normal
	MOVZBL	1(R7),R1		; Get len of str
	ADDL3	#1,R7,(R11)+		; Param - addr of counted str
	MOVL	FAOACSEP,(R10)+		; Control
	ADDL	#4,FAOSTR_D		; Reset len of control str
	ADDL	#2,R1			; Flag, count byte
	ADDL	R1,R7			; Next flag
	CMPL	R7,R3                   ; any frame left?
	BLSSU	5$                      ; Br if yes
	BRW	200$			; End processing
102$:
103$:
104$:
105$:
	MOVL	#SS$_NOTRAN,R0		; Not implemented
	RET
200$:
	MOVL	8(AP),R1
	PUSHAL	FAOLIST
	PUSHL	R1
	PUSHL	R1
	PUSHAL	FAOSTR_D
	CALLS	#4,G^SYS$FAOL
	DECL	@8(AP)			; Remove final '.'
	RET				; Any error is returned
300$:
; Here when the default '0' is present:
	MOVL	8(AP),R1
	PUSHL	#0
	PUSHL	R1
	PUSHL	R1
	PUSHAL	FAODEFNAM
	CALLS	#4,G^SYS$FAO
	RET				; Any error is returned



	.CALL_ENTRY	MAX_ARGS=2, -
			HOME_ARGS=TRUE, - 
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=XLATE_SNMP
;++
;2 XLATE_SNMP
; Routine to translate return from GETSNMP5
; to printable string
;3 Input
; 	.address of descriptor pointing to EMUDB Rec containing 
;	SNMP encoded paramater
;	.address of descriptor pointing to output
;4 Input_format
;	Standard EMUDB header followed by:
;	ASN.1 encoded paramater (single param per record):
;	Tag, Len, Value
; 	This is stored unformatted and this routine 'explodes' and
;	formats the paramater according to ASN.1/SNMP/EMU rules.
;
;3 Output
;	.ascii string translated paramater is returned in the outp desc.
;	The outp desc is written with the resulting len.
;
;3 Return
;	SS$_NORMAL	Successfully translated all primatives (may be 0)
;	SS$_BADPARAM	Unknown SNMP encoding
;	SS$_BUFFEROVF	Output too small to contain translation
;
;--   
	MOVQ	@4(AP),R6		; R6 = len, R7 = addr



; Process the tag @r7. Return info about tag, len, value
10$:
	MOVAL	FAOSTR,R11			; Build control string here	
	MOVAL	FAOLIST,R10			; Build param list here
	CLRL	FAOSTR_D			; No params yet
	PUSHAL	ASN1TAG		; Return info here
	PUSHL	R7              ; Current tag
	CALLS  #2,G^PROCESS_ASN1_TAG 
	BLBS	R0,20$
; Some error status
	RET
20$:
; SNMP does not provide sufficient info for formatting by itself. The 
; TYPE param used here is derived (and possibly edited) from the MIB.
;
	CASEB	(R7),#2,#4		; Select routine
100$:
	.WORD	102$-100$ 	; Integer
	.WORD	103$-100$       ; Bit str
	.WORD	104$-100$       ; Octet str
	.WORD	105$-100$       ; NULL
	.WORD	106$-100$       ; ObjId
	CASEB	(R7),#64,#3		; Select routine
200$:
	.WORD	201$-200$ 	; IpAddr
	.WORD	202$-200$       ; counter (integer)
	.WORD	202$-200$       ; Guage (integer)
	.WORD	203$-200$       ; TimeTics (Integer)
	CASEB	(R7),#193,#4		; Select routine
300$:
	.WORD	301$-300$ 	; MacAddr
	.WORD	302$-300$       ; Printable string
	.WORD	302$-300$       ; Table Top
	.WORD	304$-300$       ; Table entry
	.WORD	305$-300$       ; Bridge ID
; Unrecognised param type
	MOVL	#SS$_NOTRAN,R0
	RET
102$:
	PUSHAL 	RESULT
	PUSHL	R7
	CALLS	#2,G^CVT_SNMPINT  
	BLBS	R0,1021$
	RET
1021$:
	MOVL	FAOUL,(R11)+	; Control string 	
	ADDL	#4,FAOSTR_D	; Len of string
	MOVL	RESULT,(R10)+	; param list 
        BRW	500$		; Next param

103$:		       ; Bit str
	PUSHAL 	RESULT
	PUSHL	R7
	CALLS	#2,G^CVT_SNMPINT 
	BLBS	R0,1031$
	RET
1031$:
	MOVL	FAOUL,(R11)+	; Control string 	
	ADDL	#4,FAOSTR_D	; Len of string
	MOVL	RESULT,(R10)+	; param list 
        BRW	500$		; Next param
104$:		       ; Octet str
	TSTL	2(R7)			; Value present?
	BNEQ	10405$			; Br if present
	BRW	500$			; Else ignore
10405$:
	ADDL3	#2,R7,R2   		; offs to val
	CLRL	R3			; Loop control
10410$:
	MOVZBL	(R2)[R3],(R10)+         ; Put data on stack
	MOVL	FAOMAC,(R11)+           ; Control string
	ADDL	#4,FAOSTR_D         ; Adjust size of control string
	AOBLSS	#5,R3,10410$            ; Do 1st 5
	MOVZBL	(R2)[R3],(R10)+         ; Put data on stack
	MOVL	FAOXB,(R11)+            ; Control string
	ADDL	#4,FAOSTR_D         ; Adjust size of control string
	BRW	500$

105$:		       					   ; NULL
        BRW	500$					   ; Next param
106$:		       					   ; ObjId
	MOVAL	ASN1TAG,R1  
	ADDL3	#2,R7,R2   		; offs to val
	MOVZBL	1(R7),R1	        ; Len
	ADDL3	R2,R1,R3		; Loop ctrl
10610$:
	BBS	#7,(R2),10630$		; If hi bit set this is not simple
	MOVL	FAOUBSEP,(R11)+
	ADDL	#4,FAOSTR_D
	MOVZBL	(R2),(R10)+
10620$:
	AOBLEQ	R3,R2,10610$            ; Loop for all bytes
	BRW	500$                    ; Print
10630$:
	CLRQ	RESULT
	MOVB	(R2),RESULT		; Get value in low .long
	ASHL	#25,RESULT,RESULT	; Shift out hi bit
	ASHQ	#7,RESULT,RESULT	; Shift low 7 bits into hi .long
10640$:
	INCL	R2			; Next byte
	DECL	R3			; One less count
	CLRL	RESULT
	MOVB	(R2),RESULT		; Get value in low .long
	ASHL	#25,RESULT,RESULT	; Shift out hi bit
	ASHQ	#7,RESULT,RESULT	; Shift low 7 bits into hi .long
	BBS	#7,(R2),10640$		; If hi bit set then br
	MOVL	RESULT,(R10)+           ; Final result
	MOVL	ULSTRSEP,(R11)+          ; Control strin
	ADDL	#4,FAOSTR_D
	BRW	10610$		

201$:		       		; IpAddr
	ADDL3	#2,R7,R2	; offs to val
	CLRL	R3			; Loop control
20110$:
	MOVZBL	(R2)[R3],(R10)+         ; Mov byte
	MOVL	FAOUBSEP,(R11)+            ; Move control
	ADDL	#4,FAOSTR_D        ; Len of control str
	AOBLSS	#4,R3,20110$		; Loop
	BRW	500$
	
202$:		       ; counter (integer)
203$:		       ; Guage (integer)
204$:		       ; TimeTics (Integer)
	BRW	102$
301$:  			; Mac Address
	TSTL	2(R7)			   ; Value present?
	BNEQ	30105$					   ; Br if present
	BRW	500$					   ; Else ignore
30105$:
	ADDL3	#2,R7,R2   ; offs to val
	CLRL	R3			; Loop control
31010$:
	MOVZBL	(R2)[R3],(R10)+         ; Put data on stack
	MOVL	FAOMAC,(R11)+           ; Control string
	ADDL	#4,FAOSTR_D         ; Adjust size of control string
	AOBLSS	#5,R3,31010$            ; Do 1st 5
	MOVZBL	(R2)[R3],(R10)+         ; Put data on stack
	MOVL	FAOXB,(R11)+            ; Control string
	ADDL	#4,FAOSTR_D         ; Adjust size of control string
	BRW	500$
302$:
; Printable string
	MOVL	FAOAD,(R11)+	; Control string 	
	ADDL	#4,FAOSTR_D	; Len of string
	MOVZBL	1(R7),(R10)+	; Len
	ADDL3	#2,R7,(R10)+   	; addr of string
        BRW	500$					   ; Next param
303$:                                   ; table top
304$:                                   ; table entry
	brw	500$                    ; ignore
305$:  			; Bridge ID
	TSTL	2(R7)			   ; Value present?
	BNEQ	30505$					   ; Br if present
	BRW	500$					   ; Else ignore
30505$:
	ADDL3	#2,R7,R2   ; offs to val
; Top 2 bytes are bridge priority 
; Reverse bytes
	CLRL	R3  			; temp outp
	MOVB	(R2),R3			; Hi byte
	ROTL	#8,R3,R3		; Shift up
	MOVB	1(R2),R3		; Lo byte
	MOVL	R3,(R10)+            	; Bri id top word
	MOVL	FAOBRI,(R11)+           ; control
	ADDL	#4,FAOSTR_D         ; Adjust size of control string
	ADDL	#2,R2			; Move pointer	
	CLRL	R3			; Loop control (rest is mac addr)
30510$:
	
	MOVZBL	(R2)[R3],(R10)+         ; Put data on stack
	MOVL	FAOMAC,(R11)+           ; Control string
	ADDL	#4,FAOSTR_D        ; Adjust size of control string
	AOBLSS	#5,R3,30510$            ; Do 1st 5
	MOVZBL	(R2)[R3],(R10)+         ; Put data on stack
	MOVL	FAOXB,(R11)+            ; Control string
	ADDL	#4,FAOSTR_D        ; Adjust size of control string
	BRW	500$

500$:
; Print 1 line /item
	PUSHAL	FAOLIST
	PUSHL	8(AP)
	PUSHL	8(AP)
	PUSHAL	FAOSTR_D
	CALLS	#4,G^SYS$FAOL
	RET
;
	.CALL_ENTRY	MAX_ARGS=2, -
			HOME_ARGS=TRUE, - 
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=XLATE_CMIP
;++
;2 XLATE_CMIP
; Routine to translate results from CMIP_XTRPRIMITIVES  (which see)
; to printable string
;3 Input
; 	.address of descriptor pointing to CMIP encoded paramater
;	.address of descriptor pointing to output
;4 Input_format
;	A list of CMIP primatives
;	for each primitive found: 
;	unaligned sequence of tag,len,value 
;	tag = .WORD Class
;	      .WORD Tag value (stripped) 
;	len = .long
;	Value = ASN.1 encoded stripped of all protocol.
;	The total len is the len of the record - key
;

;3 Output
;	.ascii string translated paramater
; 	Each primative is prefixed by ':' to allow following processers
;	to distinguish the parts.  
;3 Return
;	SS$_NORMAL	Successfully translated all primatives (may be 0)
;	SS$_BADPARAM	Unknown CMIP encoding
;	SS$_BUFFEROVF	Output too small to contain translation
;
;3 Routines
;   Any special notes are documented below this entry.
;--   
	MOVQ	@4(AP),R6		; R6 = len, R7 = addr
	MOVQ	@8(AP),R8   		; R8 = len, r9 = addr
	CLRL	@8(AP)			; No outp yet
10$:
	
20$:
; Attempt to format
	CLRL	FAOLEN
	TSTL	4(R7)			; If param len = 0
	BNEQ	25$
	BRW	30000$			; Then skip extract/proc
25$:
	CASEW	(R7),#0,#3		; Select processing routine for class
30$:                             
	.WORD	1000$-30$               ; Universal          
	.WORD	2000$-30$               ; Application          
	.WORD	3000$-30$               ; Context specific          
	.WORD	4000$-30$               ; Private          
	MOVL	#SS$_BADPARAM,R0        ; Screwed up
	RET
1000$:					; Universal
	CASEW	2(R7),#1,#16		; Select processing for universal tag
1010$:                             
	.WORD	1100$-1010$  		; Boolean                       
	.WORD	1200$-1010$             ; Integer            
	.WORD	1300$-1010$             ; Bitstring            
	.WORD	1400$-1010$             ; Octet string            
	.WORD	1500$-1010$             ; Null            
	.WORD	1600$-1010$             ; Obj id            
	.WORD	1700$-1010$             ; Obj desc            
	.WORD	1800$-1010$             ; External       
	.WORD	1011$-1010$             ; RES            
	.WORD	1011$-1010$             ; RES            
	.WORD	1011$-1010$             ; RES            
	.WORD	1011$-1010$             ; RES            
	.WORD	1011$-1010$             ; RES            
	.WORD	1011$-1010$             ; RES            
	.WORD	1011$-1010$             ; RES            
	.WORD	1116$-1010$             ; SEQ            
	.WORD	1117$-1010$             ; SET            
1011$:
	MOVL	#SS$_BADPARAM,R0        ; Screwed up
	RET
		
; FOrmat routines for universal tags
1100$:  				; MUST BE either 0,1
	TSTB	8(R7)
	BEQL	1110$
	CMPB	#1,8(R7)
	BEQL	1110$
	MOVL	#SS$_DATACHECK,R0
	RET
1110$:
	MOVAL	BOOLTBL,R1
	MOVZBL	8(R7),R2		; Data
	MULL	#8,R2
	ADDL	R1,R2			; Addr of translated string
	MOVAL	FAOLIST,R10
	MOVL	R2,(R10)+		; Addr of string on list
	MOVQ	R8,TEMPDESC
	PUSHAL	FAOLIST
	PUSHAL	TEMPDESC
	PUSHAL	FAOLEN
	PUSHAL	ASCSTR
	CALLS	#4,G^SYS$FAOL
	BRW	30000$
1200$:                    		; Integer
	MOVQ	R8,TEMPDESC
	PUSHAL	TEMPDESC
	PUSHL	R7
	CALLS	#2,G^CMP_INTEGER
	BRW	30000$

	
1300$:
	MOVL	#64,FAOSTR_D
	PUSHAL	FAOSTR_D
	MULL3	#8,4(R7),-(SP)	; Number of bits
	ADDL3	#8,R7,-(SP)
	CALLS	#3,G^EMU_BITPTOASCIC
	BLBS	R0,1301$
	RET
1301$:
	MOVQ	R8,TEMPDESC
	PUSHAL	FAOSTR_D
	PUSHAL	TEMPDESC
	PUSHAL	FAOLEN
	PUSHAL	ASSTR
	CALLS	#4,G^SYS$FAO
	BRW	30000$
1400$:
	MOVL 	4(R7),R4		; Total len
	BEQL	1420$			; Br if none
	DECL	R4			; Make index
	ADDL3	#8,R7,R3		; start
	MOVAL	FAOLIST,R10		; List of params
	MOVAL	FAOSTR,R2		; Control params
	CLRL	FAOSTR_D		; None yet
1410$:
	MOVZBL	(R3)[R4],(R10)+         ; Param
	MOVL	FAOXB,(R2)+          	; Control string
	ADDL	#4,FAOSTR_D		; COntrol str len
	SOBGEQ	R4,1410$                ; Loop for all
	MOVQ	R8,TEMPDESC
	PUSHAL	FAOLIST
	PUSHAL	TEMPDESC
	PUSHAL	FAOLEN
	PUSHAL	FAOSTR_D
	CALLS	#4,G^SYS$FAOL
1420$:
	BRW	30000$


1500$:
	MOVL	#SS$_NOTRAN,R0
	RET
1600$: 						; Object ID
; This is similar to SNMP ObjId in that it is a tree of numbers 
; used to uniquely identify an object. In CMIP it is more limited
; and therfore simpler to implemnent. This routine assumes:
;	the 1st 8 bytes are the DEC identifier (Checked, if not then exit)
;	there are no more than 4  iterations therafter (total len <= 12)
;
	TSTL	4(R7)
	BNEQ	1610$      	; Br if value present
	BRW	30000$
1610$:
	MOVQ	R8,TEMPDESC
	PUSHAL	TEMPDESC
	PUSHL	R7
	CALLS	#2,G^CMP_OBJID
	BRW	30000$

1700$:
1800$:
	MOVL	#SS$_NOTRAN,R0
	RET
1116$:                                  ; Sequence of -
1117$:					; Set of - list of printable strings
	MOVL 	4(R7),R4	; Total len
	BEQL	11172$			; Br if none
	ADDL3	#8,R7,R6	; start
	MOVAL	FAOLIST,R10		; List of params
	MOVAL	FAOSTR,R9		; Control params
	CLRL	FAOSTR_D		; None yet
11171$:
	MOVL	R6,(R10)+               ; Param
	MOVL	FAOACSEP,(R9)+          ; Control string
	ADDL	#4,FAOSTR_D		; COntrol str len
	MOVZBL	(R6),R1			; Get param len
	INCL	R1			; Include count
	ADDL	R1,R6			; Next param
	SUBL	R1,R4                   ; Deduct processed from total 
	BGTR	11171$			; br if more
	MOVQ	R8,TEMPDESC
	PUSHAL	FAOLIST
	PUSHAL	TEMPDESC
	PUSHAL	FAOLEN
	PUSHAL	FAOSTR_D
	CALLS	#4,G^SYS$FAOL
11172$:
	BRW	30000$

2000$:					 ; Application
; Format routines for Application tags
	CASEW	2(R7),#0,#66		; Select processing for application tag
2900$:
	.WORD	2100$-2900$	; Null - Null entity class 
	.WORD	2101$-2900$	; BOOLEAN
	.WORD	2102$-2900$	; UNSIGNEDINT16	
	.WORD	2103$-2900$	; UNSIGNEDINT32	
	.WORD	2104$-2900$	; UNSIGNEDINT64	
	.WORD	2105$-2900$	; SIGNEDINT16	
	.WORD	2106$-2900$	; SIGNEDINT32	
	.WORD	2107$-2900$	; SIGNEDINT64	
	.WORD	2108$-2900$	; OCTET	
	.WORD	2109$-2900$	; OCTETSTRING	
	.WORD	21010$-2900$	; ENUMERATION	
	.WORD	21011$-2900$	; NULL	
	.WORD	21012$-2900$	; NUMERICSTRING	
	.WORD	21013$-2900$	; BITSET	
	.WORD	21014$-2900$	; RECORD	
	.WORD	21015$-2900$	; SEQUENCE	
	.WORD	21016$-2900$	; char abstime
	.WORD	21017$-2900$	; bin abstine
	.WORD	21018$-2900$	; char reltime
	.WORD	21019$-2900$	; bin reltime
	.WORD	21020$-2900$	; latin (printable string)
	.WORD	21021$-2900$	; SET	
	.WORD	21022$-2900$	; UNSIGNEDINT8
	.WORD	21023$-2900$	; SIGNEDINT8	
	.WORD	21024$-2900$	; Unassigned	
	.WORD	21025$-2900$	; Unassigned	
	.WORD	21026$-2900$	; simple name
	.WORD	21027$-2900$	; full name
	.WORD	21028$-2900$	; UID -16 bytes
	.WORD	21029$-2900$	; known			- implict null - wildcard
	.WORD	21030$-2900$	; entity name    		- sequence of objid
	.WORD	21031$-2900$	; local entity name	-   "
	.WORD	21032$-2900$	; default - implicit null
	.WORD	21033$-2900$	; version number		- 4 bytes (Status(V) maj,min,ECO)
	.WORD	21034$-2900$	; ID			- LAN addr
	.WORD	21035$-2900$	; DTE addr
	.WORD	21036$-2900$	; file spec
	.WORD	21037$-2900$	; NSAP addr
	.WORD	21038$-2900$	; NET Ent Title
	.WORD	21039$-2900$	; area addr
	.WORD	21040$-2900$	; counter16
	.WORD	21041$-2900$	; counter32
	.WORD	21042$-2900$	; counter64
	.WORD	21043$-2900$	; addr prefix
	.WORD	21044$-2900$	; Towerset
	.WORD	21045$-2900$	; endusersepc
	.WORD	21046$-2900$	; transport selector
	.WORD	21047$-2900$	; phaseIV name
	.WORD	21048$-2900$	; PhasIV addr
	.WORD	21049$-2900$	; implementation          - set of component
	.WORD	21050$-2900$	; version edit number	- seq
	.WORD	21051$-2900$	; component name          - record containing component name, version
	.WORD	21052$-2900$	; DNS timstamp            -14 bytes
	.WORD	21053$-2900$	; entity class 		- obj id
	.WORD	21054$-2900$	; bit string
	.WORD	21055$-2900$	; floor	 - seq of {protocol(protocolIdentifier), addr } see prottabl
	.WORD	21056$-2900$	; Protocol tower   set of floor (55)
	.WORD	21057$-2900$	; EVENTCLASS	
	.WORD	21058$-2900$	; EVENTINSTANCE	
	.WORD	21059$-2900$	; SUBRANGE	
	.WORD	21060$-2900$	; RANGE	
	.WORD	21061$-2900$	; CMIPMESSAGE	
	.WORD	21062$-2900$	; IPADDRESS	
	.WORD	21063$-2900$	; ID802_SNAP	
	.WORD	21064$-2900$	; IDENETV2_TYPE	
	.WORD	21065$-2900$	; FDDITIMER	
	.WORD	21066$-2900$	; EnetProtType
        BRW	10000$		; No formatter

2100$:				; Null - Null entity class 
	BRW	10000$
2101$:				; BOOLEAN
	MOVAL	BOOLTBL,R1
	MOVZBL	8(R7),R2		; Data
	MULL	#8,R2
	ADDL	R1,R2			; Addr of translated string
	MOVAL	FAOLIST,R10
	MOVL	R2,(R10)+		; Addr of string on list
	MOVQ	R8,TEMPDESC
	PUSHAL	FAOLIST
	PUSHAL	TEMPDESC
	PUSHAL	FAOLEN
	PUSHAL	ASCSTR
	CALLS	#4,G^SYS$FAOL
	BRW	30000$


2102$:				; UNSIGNEDINT16	
2103$:				; UNSIGNEDINT32	
2104$:				; UNSIGNEDINT64	
2105$:				; SIGNEDINT16	
2106$:				; SIGNEDINT32	
2107$:				; SIGNEDINT64	
	MOVQ	R8,TEMPDESC
	PUSHAL	TEMPDESC
	PUSHL	R7
	CALLS	#2,G^CMP_INTEGER
	BRW	30000$
2108$:				; OCTET	
2109$:				; OCTETSTRING	
21010$:				; ENUMERATION	
21011$:				; NULL	
21012$:				; NUMERICSTRING	
	MOVL	#SS$_NOTRAN,R0
	RET
21013$:				; BITSET	
	MOVQ	R8,TEMPDESC
	PUSHAL	TEMPDESC
	MULL3	#8,4(R7),-(SP)	; Number of bits
	ADDL3	#8,R7,-(SP)
	CALLS	#3,G^EMU_BITPTOASCIC
	BRW	30000$

21014$:				; RECORD	
	MOVL	#SS$_NOTRAN,R0
	RET
21015$:				; SEQUENCE	
	blbs	r0,21016$

21016$:				; char abstime
	MOVL	#SS$_NOTRAN,R0
	RET

21017$:				; bin abstine
	CLRL	-(SP)		; Default conversion
	ADDL3	#8,R7,-(SP)	; Input time
	PUSHAL	CMP_TIMEBUF_D
	PUSHAL	CMP_TIMELEN  
	CALLS	#4,G^SYS$ASCUTC
	BLBS	R0,210175$
; Check for UTC time 0
	ADDL3	#8,R7,R1	; Input time
	CMPL	(R1),TIMZEROB	; 
	BNEQU	210171$
	CMPL	4(R1),TIMZEROB+4	; 
	BNEQU	210171$
	CMPL	8(R1),TIMZEROB+8	; 
	BNEQU	210171$
	CMPL	12(R1),TIMZEROB+12	; 
	BNEQU	210171$
        MOVC3	#24,TIMZEROA,CMP_TIMEBUF
	MOVL	#24,CMP_TIMELEN
	BRW	210175$
210171$:
	RET
210175$:
	MOVAL	FAOLIST,R10
	MOVL	CMP_TIMELEN,(R10)+		; Len of str
	MOVAL	CMP_TIMEBUF,(R10)+		; Addr
	MOVQ	R8,TEMPDESC
	PUSHAL	FAOLIST
	PUSHAL	TEMPDESC
	PUSHAL	FAOLEN
	PUSHAL	ASDSTR
	CALLS	#4,G^SYS$FAOL
	BRW	30000$

21018$:				; char reltime
	BRW	10000$
21019$:				; bin reltime
;++
;4 BinRelTime(UTC)
; The botton 64 bits of the 128 bit UTC are converted to negative.
; If the result is 0, -1 is used to force relative time.
; The result is then  processed through $ASCTIM.  
; Note: Strangely, certain values are supplied as negative numbers
; this is not in accordance with the doc. As such, first test for
; a neg number and skip to $ASCTIM if so
;-- 
	TSTL	12(R7)				; High long of value
	BGEQ	210191$                         ; Br if >= 0
	MOVQ	8(R7),QRESULT                   ; Move value
	BRB	210193$                         ; Br to convert
210191$:
	CLRQ	DADDR                           ; Spare quad
	PUSHAL	QRESULT                         ; Result here
	ADDL3	#8,R7,-(SP)    			; Param
	PUSHAL	DADDR                           ; Subr + val from 0
	CALLS	#3,G^LIB$SUBX                   ;
	BLBS	R0,210192$                      ; br no err
	RET
210192$:
	TSTL	QRESULT+4                       ; Result >= 0?
	BNEQ	210193$                         ; Br if not
	MOVL	#-1,QRESULT			; MAKE -1
	MOVL	#-1,QRESULT+4			; MAKE -1
210193$:
	CLRL	-(SP)				; Default conversion
	PUSHAL	QRESULT
	PUSHAL	CMP_TIMEBUF_D
	PUSHAL	CMP_TIMELEN  
	CALLS	#4,G^SYS$ASCTIM
	BLBS	R0,210194$
	RET
210194$:
	MOVAL	FAOLIST,R10
	MOVL	CMP_TIMELEN,(R10)+		; Len of str
	MOVAL	CMP_TIMEBUF,(R10)+		; Addr
	MOVQ	R8,TEMPDESC
	PUSHAL	FAOLIST
	PUSHAL	TEMPDESC
	PUSHAL	FAOLEN
	PUSHAL	ASDSTR
	CALLS	#4,G^SYS$FAOL
	BRW	30000$

21020$:				; latin (printable string)
	MOVAL	FAOLIST,R10
	MOVL	4(R7),(R10)+		; Len of str
	ADDL3	#8,R7,(R10)+		; Addr of string on list
	MOVQ	R8,TEMPDESC
	PUSHAL	FAOLIST
	PUSHAL	TEMPDESC
	PUSHAL	FAOLEN
	PUSHAL	ASDSTR
	CALLS	#4,G^SYS$FAOL
	BRW	30000$

21021$:				; SET	
	MOVL	#SS$_NOTRAN,R0
	RET

21022$:				; UNSIGNEDINT8
21023$:				; SIGNEDINT8	
	MOVQ	R8,TEMPDESC
	PUSHAL	TEMPDESC
	PUSHL	R7
	CALLS	#2,G^CMP_INTEGER
	BRW	30000$
21024$:				; Unassigned	
21025$:				; Unassigned	
	MOVL	#SS$_NOTRAN,R0
	RET
21026$:				; simple name
	MOVAL	FAOLIST,R10
	ADDL3	#9,R7,(R10)+		; Start of simple name
	MOVQ	R8,TEMPDESC
	PUSHAL	FAOLIST
	PUSHAL	TEMPDESC
	PUSHAL	FAOLEN
	PUSHAL	ASCSTR
	CALLS	#4,G^SYS$FAOL
	BRW	30000$
	
21027$:				; full name


	MOVQ	R8,TEMPDESC
	PUSHAL	TEMPDESC		; Write string here
	PUSHL	R7                      ; Input
	CALLS	#2,G^XLATE_FULLNAME
	MOVL	TEMPDESC,FAOLEN
	BRW	30000$

; 
21028$:				; UID -16 bytes
	MOVAL	FAOLIST,R10
	ADDL3	#8,R7,R1		; Start of UID
	MOVL	#16,R2			; Loop control
210281$:
	MOVZBL	(R1)+,(R10)+
	SOBGTR	R2,210281$
	MOVQ	R8,TEMPDESC
	PUSHAL	FAOLIST
	PUSHAL	TEMPDESC
	PUSHAL	FAOLEN
	PUSHAL	UIDSTR
	CALLS	#4,G^SYS$FAOL
	BRW	30000$

21029$:				; known		- implict null - wildcard
	MOVL	#SS$_NOTRAN,R0
	RET
21030$:				; entity name    - sequence of objid
; Constructed tag. Signal no outp and carry on.
	CLRL	FAOLEN
	MOVL	#SS$_NORMAL,R0
	BRW	30000$
21031$:				; local entity name	-   "
; Constructed tag. Signal no outp and carry on.
	CLRL	FAOLEN
	MOVL	#SS$_NORMAL,R0
	BRW	30000$
	

21032$:				; default - implicit null
	MOVQ	R8,R1
	MOVL	#DEFVALSTR_LEN,FAOLEN
	MOVQ	DEFVALSTR,(R2)
	MOVL	#SS$_NORMAL,R0
	BRW	30000$
21033$:				; version number		- 4 bytes (Status(V) maj,min,ECO)
	MOVQ	R8,TEMPDESC
	PUSHAL	TEMPDESC        	; outp
	PUSHL	R7
	CALLS	#2,G^XLATE_CMP_VER  
	MOVL	TEMPDESC,FAOLEN 	; Place ret len in expected area
	BRW	30000$


21034$:				; ID			- LAN addr
	MOVQ	R8,TEMPDESC
	PUSHAL	TEMPDESC        ; outp
	ADDL3	#8,R7,-(SP)     ; inpt
	CALLS	#2,G^EADRTOASCII  
	MOVL	TEMPDESC,FAOLEN ; Place ret len in expected area
	BRW	30000$
		
21035$:				; DTE addr   - Implicit Latin1 String
	BRW	21020$          ; Do Latin1 translation

21036$:				; file spec
	MOVAL	FAOLIST,R10
	MOVL	4(R7),(R10)+		; Len of str
	ADDL3	#8,R7,(R10)+		; Addr of string on list
	MOVQ	R8,TEMPDESC
	PUSHAL	FAOLIST
	PUSHAL	TEMPDESC
	PUSHAL	FAOLEN
	PUSHAL	ASDSTR
	CALLS	#4,G^SYS$FAOL
	BRW	30000$


21037$:				; NSAP addr
	MOVQ	R8,TEMPDESC
	PUSHAL	TEMPDESC
	ADDL3	#8,R7,-(SP)
	PUSHL	4(R7)
	CALLS	#3,G^XLATE_NSAP 
	BRW	30000$
21038$:				; NET Ent Title
21039$:				; area addr
	MOVL	#SS$_NOTRAN,R0
	RET
21040$:				; counter16
21041$:				; counter32
21042$:				; counter64
	MOVQ	R8,TEMPDESC
	PUSHAL	TEMPDESC
	PUSHL	R7
	CALLS	#2,G^CMP_INTEGER
	BRW	30000$
21043$:				; addr prefix
21044$:				; Towerset
	MOVL	#SS$_NOTRAN,R0
	RET
21045$:				; endusersepc
	MOVQ	R8,TEMPDESC
	PUSHAL	TEMPDESC
	PUSHL	R7
	CALLS	#2,G^CMP_APPL_45	
	BRW	20000$
21046$:				; transport selector
	MOVL	#SS$_NOTRAN,R0
	RET
21047$:				; phaseIV name
	MOVAL	FAOLIST,R10
	MOVL	4(R7),(R10)+		; Len of str
	ADDL3	#8,R7,(R10)+		; Addr of string on list
	MOVQ	R8,TEMPDESC
	PUSHAL	FAOLIST
	PUSHAL	TEMPDESC
	PUSHAL	FAOLEN
	PUSHAL	ASDSTR
	CALLS	#4,G^SYS$FAOL
	BRW	30000$
21048$:				; PhasIV addr
	MOVQ	R8,TEMPDESC
; Reverse bytes
	CLRQ	DADDR
	MOVB   8(R7),DADDR+1            ; Decnet addr
	MOVB   9(R7),DADDR            ; Decnet addr
        EDIV    #1024,DADDR,R1,R2
	PUSHL	R2
	PUSHL	R1
	PUSHAL	TEMPDESC
	PUSHAL	FAOLEN
	PUSHAL	PSRDN4ADDR
	CALLS	#5,G^SYS$FAO
	BRW	30000$


21049$:				; implementation          - set of component
21050$:				; version edit number	- seq
21051$:				; component name          - record containing component name, version
21052$:				; DNS timstamp            -14 bytes
21053$:				; entity class 		- obj id
21054$:				; bit string
21055$:				; floor	 - seq of {protocol(protocolIdentifier), addr } see prottabl
21056$:				; Protocol tower   set of floor (55)
21057$:				; EVENTCLASS	
21058$:				; EVENTINSTANCE	
21059$:				; SUBRANGE	
21060$:				; RANGE	
21061$:				; CMIPMESSAGE	
21062$:				; IPADDRESS	
21063$:				; ID802_SNAP	
21064$:				; IDENETV2_TYPE	
21065$:				; FDDITIMER	
21066$:				; EnetProtType
	MOVL	#SS$_NOTRAN,R0
	RET




3000$:                                   ; Context specific
4000$:                                   ; Private



10000$:
	BRW	20000$
20000$:
	ADDL	FAOLEN,R9		; Move outp pointer
	CLRB	(R9)+			; Indicate end of this param
	SUBL	FAOLEN,R8		; Deduct used
	DECL	R8			; 1 more for null
	ADDL3	#8,4(R7),R1		; Len of input processed
	ADDL	R1,R7			; Move input
	SUBL	R1,R6			; Deduct
	BGTR	20010$  
; return len
	MOVQ	@8(AP),R1   		; Original
        SUBL3	R2,R9,@8(AP)
	MOVL	#SS$_NORMAL,R0
	RET
20010$:
	BRW	20$
30000$:
; Complete processing for this param
	BLBS	R0,300010$
	RET
300010$:
	BRW	20000$



	.CALL_ENTRY	MAX_ARGS=3, -
			HOME_ARGS=TRUE, - 
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=CMP_OBJID
;++
;2 CMP_OBJID
; Format CMIP object id
; To simplify, the following assumtions are made:
;	The object id is <= 12 bytes in total. At present the 
;	longest known is 11 and not expected to increase
;	beyond 4
;	The 1st 8 bytes are the DEC id and introducer:
;	2B	 iso, Identified org
;	0C	 ECMA
;	02	 Member Company
;	87	 Dec ...
;	73	 ... (1011)
;	02	 EMA
;	01	 Entities
;	01	 Node
;	Following above are the subidentifiers:
;				SubSub
;					Ssubsubsub
;						And so on
;	This routine translates the subidentifiers into 
;	the coresponding entity name. 
; Input
; 	.address of EMU encoded CMIP primative
;	.address of desc pointing to outp
; Output
;	The object id is looked up in a table and if found, the 
;	output is written with the string.
;
; 	SS$_ITEMNOTFOUND Not in table
; 	SS$_INTOVF	 Subidentifiers are > 4 bytes long 
;	SS$_BUFFEROVF	 Output is too small
;	SS$_NORMAL	 OK
;--
	MOVL	4(AP),R7
	CMPL	#12,4(R7)
	BGEQ	10$      	; Br if value not too long
	MOVL	#SS$_INTOVF,R0
	RET
10$:
	SUBL3	#8,4(R7),R2	; Len of subid
	ADDL3	R7,#16,R3	; Addr
	MOVAL	ENNTBL,R8
20$:
	TSTL	(R8)
	BEQL	100$
	CMPL	R2,(R8)		; Check len
	BNEQ	40$
	MOVL	R2,R4		; Make index
	DECL	R4
	ADDL3	#4,R8,R9
30$:
	CMPB	(R3)[R4],(R9)[R4]
	BNEQU	40$
	SOBGEQ	R4,30$
; Found match
	MOVL	8(R8),FAOLEN            ; Return len
	MOVQ	@8(AP),R9
	CMPL	8(R8),R9		; Enough room?
	BGTRU	35$                     ; Br if not
        MOVC3	FAOLEN,@12(R8),(R10)     ; Move string
	MOVL	#SS$_NORMAL,R0
	RET
35$:
	CLRL	FAOLEN            	; Return 0 len
	MOVL	#SS$_BUFFEROVF,R0
	RET
40$:	
	ADDL	#16,R8
	BRW	20$
100$:
	MOVL	#SS$_ITEMNOTFOUND,R0
	RET
;
	.CALL_ENTRY	MAX_ARGS=3, -
			HOME_ARGS=TRUE, - 
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=CMP_INTEGER
;++
;2 CMP_INTEGER
; Format any ASN1 integer 
; Input
; 	.address of EMU encoded CMIP primative
;	.address of desc pointing to outp
; Output
; The input integer is byte reversed and translated to the output string
; Returns
; 	SS$_INTOVF	Integer is > 4 bytes long (vax compatibility)
;	SS$_BUFFEROVF	Output is too small
;	SS$_NORMAL	Formatted correctly or len = 0
;--
	MOVL	4(AP),R6
	MOVQ	@8(AP),TEMPDESC
        MOVL  	4(R6),R1                        ; Get len
        BEQL    50$                             ; Br if len = 0
        CMPL    #4,R1
        BGEQ    30$                             ; Br if len <= 4
20$:
        MOVL    #SS$_INTOVF,R0
        RET
30$:
        DECL    R1                              ; Make Inpt index
        ADDL    #8,R6                           ; Addr of value
        MOVAL	INT,R5
        CLRL    (R5)                          ; Clear value
40$:
; Reverse byte order
        MOVB    (R6)+,(R5)[R1]          ; Move value
        SOBGEQ  R1,40$
	PUSHL	INT
	PUSHAL	TEMPDESC
	PUSHAL	FAOLEN
	PUSHAL	ULSTR
	CALLS	#4,G^SYS$FAO
	RET
50$:
        MOVL    #SS$_NORMAL,R0
        RET


	.CALL_ENTRY	MAX_ARGS=2, -
			HOME_ARGS=TRUE,-
			 INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>,-
			 PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>,-
			 LABEL=CVT_SNMPINT  
;++
;2 CVT_SNMPINT
;   
; CONVERT ASN.1 From SNMP Integer to VMS .quad integer
;3 inputs
;	addr of asn1 encoded integer
;	addr of outp .quad
; The input integer is expected to be in format:
;	tag	1 byte
;	len	1 byte
;	value	for len
;3 returns:
; 	r0 = normal or overflow
;       .quad converted int 
;3 Status Returns
; SS$_NORMAL	- OK
; SS$_INTOVF	- Len > 8 bytes or = 0
;--
	MOVL	4(AP),R6
	TSTB	1(R6)			; len of param
	BNEQ	10$				; Br if not 0
	MOVL	#SS$_INTOVF,R0
	RET

10$:
	CMPB	#8,1(R6) 		; len of param
	BGEQ	20$				; Br if len <= 4
	MOVL	#SS$_INTOVF,R0
	RET
20$:
	MOVZBL	1(R6),R1 		; Make index
	ADDL3	#2,R6,R2                ; Input int
	DECL	R1			; Make Inpt index
	MOVL	8(AP),R5		; Outp
	CLRQ	(R5)                    ; Clear value

40$:
; Reverse byte order
	MOVB	(R2)+,(R5)[R1]			; Move value
	SOBGEQ	R1,40$
        MOVL	#SS$_NORMAL,R0
	RET

	.CALL_ENTRY	MAX_ARGS=3, -
			HOME_ARGS=TRUE, - 
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=CMP_APPL_45
;++
;2 CMP_APPL_45
; Translate CMIP tag application 45 (end user spec)
;3 Input
; .address of EMU formatted CMIP param
; .address of desc pointing to outp
;3 Output
; Ascii translation is written 
;3 Return
; 	SS$_BADPARAM          Not right Introducer (0..3))
; 	SS$_NODATA		Input len = 0
; 	any return from $FAO
;--
 	MOVL	4(AP),R7		; Input

	MOVL 	4(R7),R4	; Total len
	BNEQ	5$			; Br if some
	MOVL	#SS$_NODATA,R0
	RET

5$:
	ADDL3	#8,R7,R6		; start
	CASEB   (R6),#0,#3
9$:
	.WORD	10$-9$        	; Number
	.WORD	11$-9$          ; Name
	.WORD	12$-9$          ; UIC
	.WORD	13$-9$          ; Fullname
	MOVL	#SS$_BADPARAM,R0
	RET
10$:
	MOVQ	@8(AP),TEMPDESC  ; Outp
	MOVZBL	1(R6),-(SP)	; number
	PUSHAL	TEMPDESC
	PUSHAL	FAOLEN
	PUSHAL	UBSTR
	CALLS	#4,G^SYS$FAO
	RET
11$:
	MOVQ	@8(AP),TEMPDESC  ; Outp
	ADDL3	#2,R6,-(SP)	; Counted str
	PUSHAL	TEMPDESC
	PUSHAL	FAOLEN
	PUSHAL	ASCSTR
	CALLS	#4,G^SYS$FAO
	RET
12$:
	MOVQ	@8(AP),TEMPDESC  ; Outp
	PUSHL	2(R6)		; UIC
	PUSHAL	TEMPDESC
	PUSHAL	FAOLEN
	PUSHAL	UICSTR
	CALLS	#4,G^SYS$FAO
	RET
13$:
; Make desc
	MOVQ	@8(AP),TEMPDESC  ; Outp
	SUBL3	#2,4(R7),TEMPDESC2	; Len
	ADDL3	#2,R6,TEMPDESC2+4       ; Addr
	PUSHAL	TEMPDESC2	
	PUSHAL	TEMPDESC
	CALLS	#2,G^XLATE_FULLNAME
	MOVL	TEMPDESC,FAOLEN
	RET

	.CALL_ENTRY	MAX_ARGS=3, -
			HOME_ARGS=TRUE, - 
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=ASCIPADDR2NET
;++
;2 ASCIPADDR2NET
; Translate Ascii IP addr to net format.
; EG.
; 138.204.204.1 (Up to 15 Bytes)  is translated to 01CCCC8A (4 bytes)
; Routine accepts 'X' in dont care positions and returns '0' in those positions
; to facilitate wild card searches.
;3 Inputs:
;	.long	address of Desc pointing to IP adres to xlate
;	.long	addresss of 4 byte area to write translation to 
;3 Ouputs:
;	4 byt net format IP address
;
;3 Return
;	SS$_BADPARAM	Input is not in form DD.DD.DD.DD
;			where D is either valid Decimal char (0-255) or 'X'
; 
;--
	MOVQ	@4(AP),R6
	MOVL	8(AP),R8
        ADDL3	R6,R7,R10	; Addr of last inpt byte
	CLRL	R11             ; Group counter (4)
10$:
	CLRL	R9		; Char count
20$:
	CMPB	(R7),#^A/X/	; is it 'X'?
	BEQLU	50$		; Skip
	CMPB	(R7),#^A/./	; is it '.'?
	BEQLU	30$		; Yes
	INCL	R9		; Count char
	AOBLSS	R10,R7,20$	; Next char

30$:
	PUSHAL	INT    	; Write here
	SUBL3	R9,R7,-(SP)     ; Inpt
	PUSHL	R9		; convert R9 bytes
	CALLS	#3,G^LIB$CVT_DTB
	BLBS	R0,60$
40$:
	MOVL	#SS$_BADPARAM,R0
	RET
50$:
	CLRL	INT
	INCL	R7			; Skip char
60$:
	CMPL	INT,#255
	BGTRU	40$			; Out of range
	MOVB	INT,(R8)+
	INCL	R7			; Skip past '.'
	AOBLSS	#4,R11,10$		; Do 4 times
	MOVL	#SS$_NORMAL,R0
	RET


	.END	
