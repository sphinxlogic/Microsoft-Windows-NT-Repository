	.TITLE PARAMXLT  
	.IDENT /V01-001/
;	© 2000 P. Beaudoin
;  This software is supplied as is and the usual warranty
;  is implied - none. You may use, abuse, modify or
;  or ignore this software as you see fit but are
;  encouraged to give credit, as is good practice
;  when stealing with permission
; 
; Modifications
; 001 	Oct 1996		PB	Creation		
;++
;1 PARAMXLT  
; Routine to translate paramaters in EMUDB to printable strings.
;2 Inputs
;	.address of desc pointing to EMUDB record
;	.address of desc pointing to output area
;	.address of .long where number of lines returned is written
;	.long value of line length
;	.long value options
;3 Options
; 	Bit			When set
;	0		Do not translate if no translation rec available
;	1		Multiple params on single line
;	7		Supress keyword  (data only)
;	8		Supress data (keyword only)
;	15		Include keyword in index
;	16		Include data in index
; Options may be used in any combination.
;4 Examples
; When input is an IP sysdesc and the data is: "Large string ...(80 char)..end"
; with no options and line len of 80 produces:
; 2 strings: 1. Sysdecs = Large string ... (58 Char)
;	     2. (19 char)..end
;
; Same as above with option bit 7 set:
; 2 strings: 1. Large string ... (68 Char)
;	     2. (9 char)..end
; 
; Same as above with option bit 7 and 15 set:
; 3 strings: 
;	     1. Large string ... (68 Char)
;	     3. (9 char)..end
;	     3. <X>(sysdesc)
; Options producing extra output append that output after xlation.
;
; Same as above with bit 0 set and no translation:
; 1 string:
;	     1. IP systable, param 1 len = 80 data (1st 16 bytes in hex)
;	 This the translated table and paramater, shows the len of data
;	 and the 1st 16 bytes of the data. If the data is less than 16
;	 bytes long the entire paramater is shown.
;
;2 Outputs
;	Printable translation of data with keyword prepended
;		1. Lines created are formatted according to len param
;		input. If generated line len > desired len, line is 
;		broken into multiple lines. Line(s) are returned
;		as unaligned counted strings.
;               2. Keyword may be supressed. 
;		3. Additional output may be generated by using options
;		field:
;		DECDOC options:
;		Include keyword in index
;		Include data in index
;		Generate new page tag as 1st item
;		Generate new page tag as last item
;2 Returns:
;	SS$_NORMAL		OK
;	RMS$_RNF   	        Translation rec not found
;	SS$_ACCVIO		Could not read input or write output
;	SS$_BUFFEROVF		Output too small (partial return)
;	SS$_NOPRIV		User does not have sufficient priv to access.
;	SS$_BADPARAM		Unkown option
;	SS$_NOTRAN		Not yet implemented
; Any RMS error returned in accessing the translation file.
;--
; Abstract:
	.LIBRARY	/EMU5_LIB:EMU5.MLB/

	$RMSDEF
	$DSCDEF		; Declare DSC sysmbols
	$IODEF
	$SSDEF
	EMUCTRLDEF
	EMUSYSDEF
	EMUDBDEF
;

	.PSECT PARAMXLT_DATA,WRT,NOEXE,QUAD,pic
OUTPSTR:	.BLKB	1024		; Common string output
OUTPSTR_D:	.LONG	.-OUTPSTR
		.ADDRESS  OUTPSTR
TEMPDESC:	.QUAD	0
TEMPDESC2:	.QUAD	0
MAPKEY_BUF:	.QUAD	0
FAOLIST:	.BLKL	64
MULLEN:		.LONG	0
NOTRANSSTR:	.ASCID	/!32<Paramater !UL.!UL (!UL)!>: X'!#(XB)' /
TRANSTR:	.ASCID	/!32<!AD!>: !AS/
TRANSTR2:	.ASCID	\!/!32* : !AS\
	.ALIGN	LONG
MAPPERFAB:	
	$FAB	FAC = <GET,PUT,UPD,DEL>,-	; Access
		SHR = <GET,PUT,UPD,DEL,MSE>,-	; Share with ...
		ORG = IDX,-			; Keyed file (Finally)
		RFM = FIX,-
		MRS = 128,-                       ; Largest rec
		GBC = 10,-                        ; Use global buffers
		DNM = <EMU5_Dat:MAPPER.DAT>,-	; Default Filename 
		FNM = <MAPPER>,-			; Filename 
		XAB = MAPPERXAB0                  ; Keys

MAPPERRAB:	$RAB	FAB = MAPPERFAB,-		; pointer to FAB
		RBF = MAPPERREC_BUF,-		; i/o buffer 
		RSZ = MAPPERREC_SIZE,-		; Write this many bytes
		UBF = MAPPERREC_BUF,-		; i/o buffer 
		USZ = MAPPERREC_SIZE,-		; 
		ROP = <NLK,RRL>,-			; Do not lock rec
		RAC = KEY,-			; Keyed file
		KBF = MAPKEY_BUF,-			; Key location
		KSZ = 8

MAPPERXAB0:	$XABKEY	REF = 0,-  		; TBL,PARAM
		DTP = BN8,-             ; Key = 4 bytes binary (ascending)
		POS = 0,-               ; Key position
		SIZ = 8,-                 ; Key len (dups not allowed)
		NXT = MAPPERXAB1

MAPPERXAB1:	$XABKEY	REF = 1,-  	; TBL
		DTP = BN4,-             ; Key = 4 bytes binary (ascending)
		POS = 0,-               ; Key position
		SIZ = 4,-               ; Key len (dups allowed)
		FLG = DUP,-
		NXT = MAPPERXAB2

MAPPERXAB2:	$XABKEY	REF = 2,-  	; PARAM
		DTP = BN4,-             ; Key = 4 bytes binary (ascending)
		POS = 4,-               ; Key position
		SIZ = 4,-               ; Key len (dups allowed)
		FLG = DUP

;
MAPPERREC_BUF:	
MAPPER_KEY:
MAPPER_TBL:		.LONG	0	; Table 
MAPPER_PARAM:		.LONG	0	; Paramater
MAPPER_SEC:		.QUAD	0	; Prives req'ed to detect. VMS sec
MAPPER_KEYW_LEN:	.LONG	0	; Len of following string
MAPPER_KEYW:		.BLKB	32      ; Standard keyword this param
MAPPER_FMTTYP:		.LONG	0	; Either len of following of rtn num.
MAPPER_FMTSTR:		.BLKB	68	; FAO directive str
MAPPER_RPTLVL:		.LONG	0
MAPPERREC_SIZE = .-MAPPERREC_BUF        ; = 128
;	
; Misc
;
;	.End data definitions
;
	.PSECT PARAMXLT_CODE,EXE,pic
	.CALL_ENTRY	MAX_ARGS=5, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=PARAMXLT      
;
; For now use direct file access. At a later time, move to subr that builds
; section.
        TSTW	MAPPERFAB+FAB$W_IFI	; File open?
	BNEQU	10$			; Br if open
	$OPEN	FAB = MAPPERFAB		;Open input file
	BSBW	ERROR_CHK
 	$CONNECT RAB = MAPPERRAB	;Connect input stream
	BSBW	ERROR_CHK
10$:
	MOVQ	@4(AP),R6		; R6 = LEN , R7 = ADDR
	PUSHL	R7			; Record addr
	CALLS	#1,PARAMXLT_GETMAP		; Returns pointer in r1
	BLBS	R0,100$                 ; Br if xlate available
	BBS	#DB_XLTOPT_V_NOTRAN,20(AP),20$  ; Br if default xlater not wanted
	PUSHAL	OUTPSTR_D  
	PUSHL	4(AP)
	CALLS	#2,PARAMXLT_DEFTRANS  		
	BSBW	ERROR_CHK
	MOVQ	OUTPSTR_D,R6
	MOVQ	@8(AP),R10                      ; OUTP
	MOVC3	R6,(R7),(R11)
	MOVL	R6,@8(AP)			; Final count
	
	MOVL	#SS$_NORMAL,R0
	RET
20$:
	MOVL	#RMS$_RNF,R0
	RET
100$:
; We have a map rec. There are 2 types: string fmt and rtn fmt.
; If this is string, the control string is in the rec - simply do the FAO.
; If rtn then set up and call the routine as in FMTTYP param.
;
; Check if keyword only wanted....
	CMPL	#5,(AP)			; Options present?
	BLSSU	105$			; Br not
	BBC	#DB_XLTOPT_V_SUPDAT,20(AP),105$	; Br if supress data not present
; Return keyword only
	MOVL	R1,R10			; Mapper rec
	MOVQ	@8(AP),R6                      ; OUTP
	MOVC3	DB_MAP_L_KEYWLEN(R10),DB_MAP_A64_KEYW(R10),(R7)
	MOVL	DB_MAP_L_KEYWLEN(R10),@8(AP)			; Final count
	MOVL	#SS$_NORMAL,R0
	RET


105$:
	BBS	#31,DB_MAP_L_FMTTYP(R1),200$	; Br if routine xlate
	MOVL	R1,R10				; Mapper rec
	PUSHAL	FAOLIST                         ; FAO list
	PUSHL	R10                              ; Mapper
	PUSHL	R7	                        ; Data
	CALLS	#3,PARAMXLT_MAKEFAO             ; Make formatter list
	BLBS	R0,110$				; Br if OK
	RET
110$:
	MOVL	DB_MAP_L_FMTTYP(R10),TEMPDESC	; Len of control str
	ADDL3	#DB_MAP_A32_FMTSTR,R10,TEMPDESC+4 ; Addr
	MOVL	#1024,OUTPSTR_D
	PUSHAL	FAOLIST
	PUSHAL	OUTPSTR_D
	PUSHAL	OUTPSTR_D  
	PUSHAL	TEMPDESC
	CALLS	#4,G^SYS$FAOL
	BLBS	R0,150$
; Log	error
	RET
150$:
; Process any options.
       BRW	FINAL_FORMAT
200$:
	CASEW	DB_MAP_L_FMTTYP(R1),#0,#24
290$:
	.WORD	300$-290$
	.WORD	301$-290$
	.WORD	302$-290$
	.WORD	303$-290$
	.WORD	304$-290$
	.WORD	305$-290$
	.WORD	306$-290$
	.WORD	307$-290$
	.WORD	308$-290$
	.WORD	309$-290$
	.WORD	310$-290$
	.WORD	311$-290$
	.WORD	312$-290$
	.WORD	313$-290$
	.WORD	314$-290$
	.WORD	315$-290$
	.WORD	316$-290$
	.WORD	317$-290$
	.WORD	318$-290$
	.WORD	319$-290$
	.WORD	320$-290$
	.WORD	321$-290$
	.WORD	322$-290$
	.WORD	323$-290$
	.WORD	324$-290$
	MOVL	#SS$_BADPARAM,R0
	RET
300$:
	MOVL	#1024,OUTPSTR_D
	MOVQ    @4(AP),R1    			; xlate rec desc
	PUSHL	#1				; Full xlate flag
	PUSHAL	OUTPSTR_D                       ; Outp str
	ADDL3	#DB_C_KSZ,R2,-(SP)		; Input .quad
	CALLS	#3,G^XLATE_ENETPTY 
	BLBS	R0,3001$
	RET
3001$:
	BRW	FINAL_FORMAT

301$:
	MOVL	#1024,OUTPSTR_D
	MOVQ    @4(AP),R1    			; xlate rec desc
	PUSHAL	OUTPSTR_D                       ; Outp str
	SUBL3	#DB_C_KSZ,R1,R3			; Len (Bytes)
	MULL3	#8,R3,-(SP)			; Len (bits)
	ADDL3	#DB_C_KSZ,R2,-(SP)		; Addr
	CALLS	#3,G^EMU_BITPTOASCIC   
	BLBS	R0,3001$
	RET
302$:
	MOVL	#1024,OUTPSTR_D
	MOVQ    @4(AP),R1    			; rec desc
	PUSHAL	OUTPSTR_D                       ; Outp str
	ADDL3	#DB_C_KSZ,R2,-(SP)		; Input eaddr
	CALLS	#2,G^EADRTOASCII   
	BLBS	R0,3041$
	RET

303$:
;	CALLS	#2,G^ASCTOBITP     
; Above are not yet implemented
	MOVL	#SS$_NOTRAN,R0
	RET
304$:
	MOVL	#1024,OUTPSTR_D
	MOVQ    @4(AP),R1
	SUBL3	#DB_C_KSZ,R1,TEMPDESC   
	ADDL3	#DB_C_KSZ,R2,TEMPDESC+4   
	PUSHAL	OUTPSTR_D  
	PUSHAL	TEMPDESC
	CALLS	#2,G^XLATE_CMIP    
	BLBS	R0,3041$
	RET
3041$:
	BRW	FINAL_FORMAT
305$:
	MOVL	#1024,OUTPSTR_D    ; Output
	MOVQ    @4(AP),R1          ; Input Record
	PUSHAL	OUTPSTR_D
	ADDL3	#DB_REC_C_CDATA,R2,-(SP)        ; Addr
	PUSHL	DB_REC_L_CLEN(R2)  		; Len
	CALLS	#3,G^XLATE_NSAP    
	BLBS	R0,3041$
	RET
306$:
	MOVL	#1024,OUTPSTR_D
	PUSHAL	OUTPSTR_D  
	PUSHL	4(AP)			; Input
	CALLS	#2,G^XLATE_CIRCTYP
	BLBS	R0,3041$
	RET
307$:
	MOVL	#1024,OUTPSTR_D
	PUSHAL	OUTPSTR_D  
	PUSHL	4(AP)			; Input
	CALLS	#2,G^XLATE_CMIP_VERSION
	BLBS	R0,3041$
	RET
308$:
	MOVL	#1024,OUTPSTR_D
	MOVQ    @4(AP),R1
	SUBL3	#DB_C_KSZ,R1,TEMPDESC   
	ADDL3	#DB_C_KSZ,R2,TEMPDESC+4   
	PUSHAL	OUTPSTR_D  
	PUSHAL	TEMPDESC
	CALLS	#2,G^XLATE_SNMP    
	BLBS	R0,3081$
	RET
3081$:
	BRW	FINAL_FORMAT
309$:                                  ; NML encoded hardware addr
	MOVL	#1024,OUTPSTR_D
	MOVQ    @4(AP),R1
	PUSHAL	OUTPSTR_D  
	ADDL3	#DB_C_KSZ,R2,-(SP)
	CALLS	#2,G^EMU_NML_XLT_HADDR     
	BLBS	R0,3081$
	RET

310$:                                  ; NML encoded host id
	MOVL	#1024,OUTPSTR_D
	MOVQ    @4(AP),R1
	PUSHAL	OUTPSTR_D  
	ADDL3	#DB_C_KSZ,R2,-(SP)
	CALLS	#2,G^EMU_NML_XLT_HOSTID     
	BLBS	R0,3081$
	RET

311$:
	MOVL	#1024,OUTPSTR_D
	MOVQ    @4(AP),R1
	PUSHAL	OUTPSTR_D  
	ADDL3	#DB_C_KSZ,R2,-(SP)
	CALLS	#2,G^EMU_LAT_XLT_GROUP    
	BLBS	R0,3081$
	RET
312$:
	MOVL	#1024,OUTPSTR_D
	MOVQ    @4(AP),R1                       ; EMUDB desc
	SUBL3	#DB_C_KSZ,R1,TEMPDESC		; Len
	ADDL3	#DB_C_KSZ,R2,TEMPDESC+4		; Addr
	PUSHAL	OUTPSTR_D                       ; Outp
	PUSHAL	TEMPDESC
	CALLS	#2,G^ASCII_STRING    
	BLBS	R0,3121$
	RET
3121$:
	BRW	FINAL_FORMAT
313$:
	MOVL	#1024,OUTPSTR_D
	PUSHAL	OUTPSTR_D                       ; Outp
	PUSHL	4(AP)				; EMUDB rec
	CALLS	#2,G^MOP_XLATE    
	BLBS	R0,3121$
	RET
314$:
	MOVL	#1024,OUTPSTR_D
	PUSHAL	OUTPSTR_D                       ; Outp
	PUSHL	4(AP)				; EMUDB rec
	CALLS	#2,G^EMU_NML_XLT_CHANNEL  	; NICE Channel range    
	BLBS	R0,3121$
	RET
315$:
	MOVL	#1024,OUTPSTR_D
	MOVQ    @4(AP),R1
	ADDL	#DB_C_KSZ,R2     ; addr of ASN.1 code
	PUSHAL	OUTPSTR_D  
	MOVZBL	2(R2),-(SP)	 ; Value
	CALLS	#2,G^SNMP_IFXLATE  
	BLBS	R0,3121$
	RET
316$:				; LAN Address type 
	MOVL	#1024,OUTPSTR_D    ; Output
	MOVQ    @4(AP),R1          ; Input Record
	PUSHAL	OUTPSTR_D
	ADDL3	#DB_C_KSZ,R2,-(SP)        ; Addr
	CALLS	#2,G^XLATE_LAN_TYPE    
	BLBS	R0,3161$
	RET
3161$:
	BRW	FINAL_FORMAT
317$:				   ; Bridge
	MOVL	#1024,OUTPSTR_D    ; Output
	MOVQ	@4(AP),R1        	   ; EMUDB rec
	PUSHAL	OUTPSTR_D
	PUSHL	R2
	CALLS	#2,G^XLATE_BRIDGE   
	BLBS	R0,3161$
	RET
318$:				   ; Bridge
	MOVL	#1024,OUTPSTR_D    ; Output
	MOVQ	@4(AP),R1        	   ; EMUDB rec
	PUSHAL	OUTPSTR_D
	PUSHL	R2
	CALLS	#2,G^FORMAT_DECNET_ADDR   
	BLBS	R0,3161$
	RET
319$:				   ; Bridge
	MOVL	#1024,OUTPSTR_D    ; Output
	MOVQ	@4(AP),R1        	   ; EMUDB rec
	PUSHAL	OUTPSTR_D
	ADDL3	#DB_C_KSZ,R2,-(SP)        ; Addr
	CALLS	#2,G^XLTTBL_XLTSAP   
	BLBS	R0,3161$
	RET

320$:                                  ; NML encoded OBJ id
	MOVL	#1024,OUTPSTR_D
	MOVQ    @4(AP),R1
	PUSHAL	OUTPSTR_D  
	ADDL3	#DB_C_KSZ,R2,-(SP)
	CALLS	#2,G^EMU_NML_XLT_OBJECT     
	BLBS	R0,3201$
	RET
3201$:
	BRW	FINAL_FORMAT
321$:                                  ; SNMP encoded bridge id
	MOVL	#1024,OUTPSTR_D
	MOVQ    @4(AP),R1
	PUSHAL	OUTPSTR_D  
	ADDL3	#DB_C_KSZ,R2,-(SP)
	CALLS	#2,G^SNMP_XLT_BRIDGEID     
	BLBS	R0,FINAL_FORMAT
	RET
322$:                                  ; SNMP encoded bridge id
	MOVL	#1024,OUTPSTR_D
	PUSHAL	OUTPSTR_D  
	PUSHL	4(AP)			; Input
	CALLS	#2,G^XLATE_CMIP_ADDRESS     
	BLBS	R0,FINAL_FORMAT
	RET
323$:                                  ; SNMP encoded bridge id
	MOVL	#1024,OUTPSTR_D
	PUSHAL	OUTPSTR_D  
	PUSHL	4(AP)			; Input
	CALLS	#2,G^XLATE_CMIP_STRINGS     
	BLBS	R0,FINAL_FORMAT
	RET
324$:                                  ; SNMP encoded bridge id
	MOVL	#1024,OUTPSTR_D
	PUSHAL	OUTPSTR_D  
	PUSHL	4(AP)			; Input
	CALLS	#2,G^XLT_CMIPTBL     
	BLBS	R0,FINAL_FORMAT
	RET
  
FINAL_FORMAT:
; return in caller's buffer all formatted data broken up (if necessary)
; into multple lines. Each line is ascii linelen long and the total number
; of lines is returned.
	TSTL	OUTPSTR_D
	BNEQ	50$
	BBS	#DB_XLTOPT_V_NOTRAN,20(AP),20$  ; Br if default xlater not wanted
	PUSHAL	OUTPSTR_D  
	PUSHL	4(AP)
	CALLS	#2,PARAMXLT_DEFTRANS  		
	BSBW	ERROR_CHK
	MOVQ	OUTPSTR_D,R6
	MOVQ	@8(AP),R10                      ; OUTP
	MOVC3	R6,(R7),(R11)
	MOVL	R6,@8(AP)			; Final count
	MOVL	#SS$_NORMAL,R0
	RET
20$:
	MOVL	#SS$_NOTRAN,R0
	RET
50$:
; Check if multiple params are present. As of now only CMIP will return
; multiple params. End of each param is signaled by NULL. If any NULLs 
; present then branch
        PUSHAL	OUTPSTR_D
	CALLS	#1,G^PARAMXLT_FIND_NULL
	BLBS	R0,100$
; No nulls
	BBS	#DB_XLTOPT_V_SUPKEW,20(AP),60$  ; Br if default KEYW not wanted

	MOVAL	MAPPERREC_BUF,R1		; 
	PUSHAL	OUTPSTR_D			; Value
	ADDL3	R1,#DB_MAP_A64_KEYW,-(SP)		; Addr keyword
	PUSHL	DB_MAP_L_KEYWLEN(R1)		; Len  keyword
        PUSHL	8(AP)
	PUSHL	8(AP)
	PUSHAL	TRANSTR
	CALLS	#6,G^SYS$FAO
	RET

60$:
; Copy translated string to output
	MOVQ	@8(AP),R6	; output
	MOVQ	OUTPSTR_D,R8	; Input
	CMPL	R6,R8		; Outp big enough?
	BGEQU	70$
	MOVC3	R6,(R9),(R7)    ; Move only what outp can handle
	MOVL	#SS$_BUFFEROVF,R0  ; Signal truncation
	RET
70$:
	MOVC3	R8,(R9),(R7)    ; Move full string
	MOVL	R8,@8(AP)	; Return len
	MOVL	#SS$_NORMAL,R0
	RET



100$:
; If caller wants all param on single line then convert all NULLs to ' '
        CMPL	#5,(AP)
	BNEQ	200$
	BBC	#DB_XLTOPT_V_1LINE,20(AP),200$
	PUSHL	20(AP)
	PUSHL	8(AP)		; output
	PUSHAL	OUTPSTR_D	; Input
	CALLS	#3,G^PARAMXLT_STRIP_NULL
	RET
200$:
	PUSHL	20(AP)
	PUSHL	8(AP)		; output
	PUSHAL	OUTPSTR_D	; Input
	CALLS	#3,G^PARAMXLT_MULTIPLE_PARAMS
	RET

	.CALL_ENTRY	MAX_ARGS=3, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=PARAMXLT_MULTIPLE_PARAMS 
;++
;2 PARAMXLT_MULTIPLE_PARAMS 
; Called when a single string contains multiple params that should be broken
; into multiple lines.
;3 Input
;  .address of desc pointing to input string
;  .address of desc pointing to output string 
;  .long formatting options
;3 Output
; The input string is translated as normal with the keyword  preceding
; the list of NULL terminated params. Each NULL is replaced by <CR,LF>
; and blanks in place of the keyword.
;4 Example 
; An OSI Address param contains 4 addresses when displayed produces:
;
; Address            : 49::00-32:aa-00-04-00-12-34:21 
;		     : 49::00-32:aa-00-04-00-12-34:20 
;		     : 49::00-32:aa-00-04-00-12-33:21 
;		     : 49::00-32:aa-00-04-00-12-33:20 
;3 Return
;	SS$_NORMAL 	OK
;	SS$_BUFFEROVF	Outp string too small
;	SS$_NOOPER	Either input or outp str was len = 0
;--
	MOVQ	@4(AP),R6
	MOVQ	@8(AP),R8
	CLRL	R10			; Len accumulator
; Copy keyw and 1st param to outp
10$:
	MOVQ	R6,TEMPDESC
	PUSHAL	TEMPDESC
	CALLS	#1,G^PARAMXLT_FIND_NULL
	BLBS	R0,15$
	BRW	100$			; Br on last found
15$:
	SUBL3	R7,R1,R11		
	BNEQ	17$			; Br if inpt len .ne. 0
	INCL	R7			; Next inpt
	DECL	R6			; Deduct processed
	BRW	10$
17$:
	INCL	R11			; Distance to next param
	MOVL	R7,TEMPDESC+4		; Addr of input
	SUBL3	R7,R1,TEMPDESC		; Len
	MOVQ	R8,TEMPDESC2

	BBS	#DB_XLTOPT_V_SUPKEW,12(AP),30$  ; Br if default KEYW not wanted
; IF this is the 1st param include the keyword 
	TSTL	R10			; 
	BNEQ	20$                     ; Br if some output already

	MOVAL	MAPPERREC_BUF,R1		; 
	PUSHAL	TEMPDESC
	ADDL3	R1,#DB_MAP_A64_KEYW,-(SP)		; Addr keyword
	PUSHL	DB_MAP_L_KEYWLEN(R1)		; Len  keyword
	PUSHAL	TEMPDESC2
	PUSHAL	TEMPDESC2
	PUSHAL	TRANSTR
	CALLS	#6,G^SYS$FAO
	BLBS	R0,50$
	RET

20$:
	PUSHAL	TEMPDESC
	PUSHAL	TEMPDESC2
	PUSHAL	TEMPDESC2
	PUSHAL	TRANSTR2
	CALLS	#4,G^SYS$FAO
	BLBS	R0,50$
	RET
30$:
	CMPL	R6,R8
	BLSS	40$
	MOVL	#SS$_BUFFEROVF,R0
	RET
40$:
	MOVQ	R6,TEMPDESC
	PUSHL	12(AP)
	PUSHAL	TEMPDESC	  ; output
	PUSHAL	TEMPDESC	  ; Input
	CALLS	#3,G^PARAMXLT_STRIP_NULL
        BLBS	R0,45$
	RET
45$:

	MOVC3	R6,(R7),(R9)	
	MOVL	R6,TEMPDESC2
	BRB	50$

50$:
	ADDL	TEMPDESC2,R10		; Accumulate
	ADDL	R11,R7			; Next in
	SUBL	R11,R6			;
	BLEQ	100$			; Br none left
	ADDL	TEMPDESC2,R9		; Next out
	SUBL	TEMPDESC2,R8		; Deduct used
	BRW	10$                     ; Next param
100$:
; Last param
	MOVL	R10,@8(AP)		; return Len 
	MOVL	#SS$_NORMAL,R0
	RET


	.CALL_ENTRY	MAX_ARGS=1, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=PARAMXLT_STRIP_NULL 
;++
;2 PARAMXLT_STRIP_NULL 
; Convert  all nulls found in the input string to ' ' (space).
;3 Input
;  .address of desc pointing to input string
;3 Output
; 	All nulls are replaced with spaces 
;3 Return
;	SS$_NORMAL 	 OK
;--
	MOVQ	@4(AP),R6
	DECL 	R6
10$:
	CMPB	#0,(R7)[R6]
	BEQL	40$
30$:
	SOBGEQ	R6,10$
	MOVL	#SS$_NORMAL,R0
	RET
40$:
	MOVB	#^A/ /,(R7)[R6]
        BRB	30$


	.CALL_ENTRY	MAX_ARGS=1, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=PARAMXLT_FIND_NULL 
;++
;2 PARAMXLT_FIND_NULL 
; Search the input string for the next occurence of NULL. If found
; returns the address of the NULL in R1.
;3 Input
;  .address of desc pointing to string to search
;3 Output
;  R1 = address of 1st NULL found (if found)
;  R1 = 0 if not found
;3 Return
;	SS$_NORMAL 	 if NULL found
;	SS$_ITEMNOTFOUND if NULL not found
;--
	MOVQ	@4(AP),R6
	LOCC    #0,R6,(R7)
        TSTL	R0
	BNEQ	100$
	MOVL	#SS$_ITEMNOTFOUND,R0
	RET
100$:
	MOVL	#SS$_NORMAL,R0
	RET

	.CALL_ENTRY	MAX_ARGS=3, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=PARAMXLT_MAKEFAO 
;++
;2 PARAMXLT_MAKEFAO 
;  Make a list of paramaters from the data suitable for input to $FAO
;  The control string is scanned and the appropriate paramater
; is added to the list. Supported types are:
;	!AC		Add Address of string to list
;	!UL		Add longword value to list
;	!UB		unsigned byte
;	!UW		unsigned word
;	!XL		Add longword value to list
;	!XB		unsigned byte
;	!XW		unsigned word
;3 Inputs
;	address of EMUDB format record
;	address of MAP record
;	address of resulting list
;3 Outputs
; 	The list is written with the paramaters
;3 Returns  
;	SS$_NORMAL	List written
;	SS$_BADPARAM	Unsupported paramter type
;--
	MOVL	4(AP),R6	; Data rec
	MOVL	8(AP),R7	; Map rec
	MOVL	12(AP),R8	; FAOlist
	ADDL	#DB_C_KSZ,R6 			; Start of data
	MOVL	DB_MAP_L_FMTTYP(R7),R11		; Len of string
	ADDL	#DB_MAP_A32_FMTSTR,R7		; Start of control string
	CLRL	R4				; Loop control
; Find FAO params
100$:
	CMPB	#^A/!/,(R7)[R4]
	BEQLU	150$
110$:
	AOBLSS	R11,R4,100$
	MOVL	#SS$_NORMAL,R0
	RET
150$:
	ADDL3	R4,R7,R1 		; Point to directive
	INCL	R1                      ; After '!'
	CMPW	#^A/AC/,(R1)           ; .ascic?
	BEQLU	200$			; Br if .ascic
	CMPW	#^A/UL/,(R1)           ; .long ?
	BEQLU	210$			; Br if Ulong
	CMPW	#^A/XL/,(R1)           ; .long ?
	BEQLU	210$			; Br if xlong
	CMPW	#^A/UW/,(R1)           ; .word ?
	BEQLU	220$			; Br if uword
	CMPW	#^A/XW/,(R1)           ; .word ?
	BEQLU	220$			; Br if xword
	CMPW	#^A/UB/,(R1)           ; .long ?
	BEQLU	230$			; Br if ubyte
	CMPW	#^A/XB/,(R1)           ; .long ?
	BEQLU	230$			; Br if xbyte
	CMPW	#^A/%D/,(R1)           ; Time ?
	BEQLU	240$			; Br if time
	MOVL	#SS$_BADPARAM,R0
	RET
200$:
	MOVL	R6,(R8)+		; Add addr to list
        MOVZBL	(R6),R1			; Get len
	INCL	R1			; Include count
	ADDL	R1,R6			; Next (if any) data item
	BRB	110$			; Next control
210$:
	MOVL	(R6)+,(R8)+		; Add value to list
	BRB	110$			; Next control
220$:
	MOVZWL	(R6)+,(R8)+		; Add value to list
	BRB	110$			; Next control
230$:
	MOVZBL	(R6)+,(R8)+		; Add value to list
	BRB	110$			; Next control

240$:
	MOVL	R6,(R8)+		; Add addr to list
	BRB	110$			; Next control
		


	.CALL_ENTRY	MAX_ARGS=5, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=PARAMXLT_GETMAP
; Routine to look up translation rec for this param.
; Inputs:
;	Addr of DB rec
; Outputs:
;	R1 = pointer to map rec (if found)
; Returns:
; 	SS$_NORMAL		rec found, pointer written
;	SS$_ACCVIO		Can't read DB rec (Header only)
;	ANY RMS ERROR		Rec not found, R1 = 0

	PROBER	#0,#DB_C_KSZ,@4(AP)
	BNEQ	10$
	MOVL	#SS$_ACCVIO,R0
	RET
10$:
        MOVL	4(AP),R6
	MOVL	DB_REC_L_TABLE(R6),MAPKEY_BUF   
	MOVL	DB_REC_L_PARAM(R6),MAPKEY_BUF+4   
	$GET	RAB=MAPPERRAB
	BLBS	R0,20$
	CLRL	R1
	RET					; Return RMS error
20$:
	MOVAL	MAPPERREC_BUF,R1		; Return pointer
	MOVL	#SS$_NORMAL,R0
	RET


ERROR_CHK:
	.JSB_ENTRY	INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			OUTPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

		BLBC	R0,10$
		RSB
10$:
		RET
; Callable routines

	.CALL_ENTRY	MAX_ARGS=1, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=PARAMXLT_CHECKSECURE
; Checks security access to this param.
; Inputs:
;	.addr EMUDB rec
; Outputs:
;	none
; Returns:
;	SS$_NORMAL	OK
;	SS$_NOPRIV	Not allowed
; Locate the PHD and extract current privs.
; use this as a mask and clear the set bits in the DB rec.
; If any remain set, this process does not have req'd privs.
; 	MOVL	#SS$_NORMAL,R0
	RET
;
	.CALL_ENTRY	MAX_ARGS=1, HOME_ARGS=TRUE, -
			INPUT=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			PRESERVE=<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>, -
			LABEL=PARAMXLT_DEFTRANS 
;++
;3 PARAMXLT_DEFTRANS 
; Routine to format a rec when both:
;		 1. No map rec exists
;		 2. Caller specifies default translation
;4 Inputs:
;	.addr of descriptor pointing to emudbrec  (full rec)
;	.addr of descriptor pointing to output
;4 outputs:
;	.ascii string in common area in format:
;	Paramater Tbl.Param (len) x'data'
;    where:
;	Tbl is the EMU defined table this paramater is in
;	Param is the Network defined paramater number
;	Len is the total len of data
;	data is the hexidicimal translation of up to the 1st 16 bytes
;
;4 Returns:
;	SS$_NORMAL 	OK
;--  
	MOVQ	@4(AP),R6	; Input
	MOVAL	FAOLIST,R10
	MOVL	DB_REC_L_TABLE(R7),(R10)+
	MOVL	DB_REC_L_PARAM(R7),(R10)+
; Calc size of data
	SUBL3	#DB_C_KSZ,R6,R1
	MOVL	R1,(R10)+
	TSTL	R1
	BEQL	100$		; Br if no data
	CMPL	#16,R1
	BGTR	10$
	MOVL	#16,R1
10$:
	MOVL	R1,(R10)+	; Number of params to follow
	ADDL	#DB_C_KSZ,R7	; Start of data
20$:
	MOVZBL	(R7)+,(R10)+
	SOBGTR	R1,20$
100$:
	MOVL	#1024,OUTPSTR_D
	PUSHAL	FAOLIST
	PUSHAL	OUTPSTR_D
	PUSHAL	OUTPSTR_D  
	PUSHAL	NOTRANSSTR
	CALLS	#4,G^SYS$FAOL
	RET
	.END 
