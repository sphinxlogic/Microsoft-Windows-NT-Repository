$!
$! COMBINE_FEEDBACK.COM
$!
$! This command procedure is intended for use by sites which cannot, for
$! some reason, achieve the long periods of uptime that AUTOGEN likes
$! for its feedback mechanism.
$!
$! It examines all the AUTOGEN feedback data files generated by separate
$! runs of AUTOGEN (or from feedback generation at shutdown time) and
$! combines the data from the separate files so it will be acceptable to
$! AUTOGEN.
$!
$! The general idea is:
$!	o  For peak values, keep track of the highest value seen
$!	o  For counters, keep a running total
$!	o  For "current" values, use the value from the file which was
$!	   most-recently generated, since it's most likely to represent
$!	   the present conditions
$!
$! Rules for combining values (based on pseudo-parameter name suffixes):
$!
$!	_NODE, _SID, _NAME	Must be the same in all files, or issue an
$!				error message about the potential problem,
$!				and use the one from the latest file
$!
$!	_CUR,BAP_MIN,BAP_MAX,	Use the value from the file with the latest
$!	_MIN_PA,_MAX_PA,	date
$!	CODE_SIZE,DATA_SIZE
$!
$!	_PEAK, _INUSE, SIZE,	Select the highest value found
$!	_PAGES, PAGELETS
$!
$!	_UPTIME, FAIL,		Total the values from all the files
$!	FAILPAGES, REQUESTS,
$!	_IO, HITS, ATTEMPTS,
$!	_CNT
$!
$!	FEEDBACK_TIME		Replace with the time this procedure is run;
$!				use values in files to determine which one
$!				is the most-recent (latest) file
$!
$!	(anything else)		Use the value from the latest file, with a
$!				warning message
$!
$! If parameter P1 contains the string VERBOSE, a note is made of the type of
$! action taken for each different parameter.  I use this to see if the action
$! is correct for new parameters in a new VMS release that happen to fall under
$! one of the existing rules.
$!
$! Author: Keith Parris  parris@encompasserve.org or keithparris@yahoo.com
$! http://www.geocities.com/keithparris/ or http://encompasserve.org/~parris/
$!         
$!		Version 1.4, Oct. 1998, as of VMS 7.2 EFT2
$	say = "write sys$output"
$	verbose = "F"
$	if f$edit(f$extract(0,4,p1),"UPCASE") .eqs. "VERB" then verbose = "T"
$! Do some sanity checking
$	if f$search("SYS$SYSTEM:AGEN$FEEDBACK.DAT;*") .eqs. ""
$	then	!No feedback files out there at all
$	    say ""
$	    say "No AUTOGEN feedback files found."
$	    say ""
$	    goto OOPS
$	endif
$	if f$search("SYS$SYSTEM:AGEN$FEEDBACK.DAT;-1") .eqs. ""
$	then	!Only 1 feedback file (maybe from our last combination...)
$	    say ""
$	    say "Only one AUTOGEN feedback file found; can't summarize."
$	    say ""
$	    goto OOPS
$	endif
$! Do some cleanup in case we were Control-Y'd before
$	close/nolog out
$	close/nolog in
$	file = f$search("X.Y",1)	!Reset the search context
$! Initialization
$	this_is_latest_file = "F"
$	problem_found = "F"
$	file_count = 0	!Count the valid feedback files we find
$	open/write out SYS$SYSTEM:AGEN_COMBINED_FEEDBACK.DAT
$	param_count = 1
$	param_name_1 = "FEEDBACK_TIME"
$	time = f$time()
$	value_feedback_time = """" + time + """"
$	write out "! This file was created by COMBINE_FEEDBACK.COM at ",time,"."
$	write out "! The values represent the combined data from the following"
$	write out "! individual feedback collection dates/files:
$! Read each AGEN$FEEDBACK.DAT file we find in SYS$SYSTEM
$ FILE_LOOP:
$	file = f$search("SYS$SYSTEM:AGEN$FEEDBACK.DAT;*",1)
$	if file .eqs. "" then goto PHASE_2
$	say "Reading file ",	f$element(1,"]",file)
$	open/read in 'file'
$	read/end=FILE_EOF in rec
$	if f$extract(0,47,rec) .eqs. -
		"! This file was created by COMBINE_FEEDBACK.COM"
$	then
$! See if they want to incorporate the summary data from an earlier run
$	    summary_time = f$extract(51,23,rec)
$	    say -
"  Do you wish to include summarized feedback information generated by"
$	    inquire ans -
		"  COMBINE_FEEDBACK.COM at ''summary_time'? [N]"
$	    if .not. ans
$	    then
$		say "  You may wish to delete ",file
$		goto FILE_EOF
$	    endif
$	endif
$	file_count = file_count + 1	!Count this as a valid file
$	goto HANDLE_RECORD	!Jump into the loop
$ RECORD_LOOP:
$	read/end=FILE_EOF in rec
$ HANDLE_RECORD:
$	rec = f$edit(rec,"trim,uncomment")
$	if f$length(rec) .eqs. 0 then goto RECORD_LOOP	!Ignore comment lines
$! Determine the parameter name
$	param_name = f$edit(f$element(0,"=",rec),"trim,upcase")
$	pn_len = f$length(param_name)
$	param_value = f$edit(f$element(1,"=",rec),"trim")
$! If we haven't seen this parameter name before, add it to our "array"
$	if f$type(value_'param_name') .eqs. ""
$	then
$	    param_count = param_count + 1
$	    param_name_'param_count' = param_name
$	endif
$! There's one special parameter case:  We need to do special processing for
$! the feedback time, to see if this file is the latest we've seen so far.
$	if param_name .eqs. "FEEDBACK_TIME"
$	then
$	    feedback_time = param_value - """" - """"
$	    write out "!   ",feedback_time,"  ",file
$	    say "  Processing feedback data generated ",feedback_time
$	    feedback_time_comp = f$cvtime(feedback_time)
$	    if f$type(latest_feedback_time_comp) .nes. ""
$	    then	!Symbol already exists
$		if feedback_time_comp .gts. latest_feedback_time_comp
$		then
$		    this_is_latest_file = "T"
$		    latest_feedback_time_comp = feedback_time_comp
$		else
$		    this_is_latest_file = "F"
$		endif
$	    else
$		this_is_latest_file = "T"
$		latest_feedback_time_comp = feedback_time_comp
$	    endif
$	    goto RECORD_LOOP
$	endif
$!
$! Handle the various parameters here, based on their suffixes
$!
$!	_NODE, _SID, _NAME	Must be the same in all files, or issue an
$!				error message about the potential problem,
$!				and use the one from the latest file
$!
$	if f$extract(pn_len-5,5,param_name) .eqs. "_NODE"	.or. -
	   f$extract(pn_len-4,4,param_name) .eqs. "_SID"	.or. -
	   f$extract(pn_len-5,5,param_name) .eqs. "_NAME"
$	then
$	    if f$type(value_'param_name') .nes. ""
$	    then
$		if value_'param_name' .nes. param_value
$		then
$		    say ""
$		    say "  Mismatch of values for parameter ''param_name' found"
$		    say "  in AGEN$FEEDBACK.DAT files.  Summary may not be valid."
$		    if this_is_latest_file then value_'param_name' = param_value
$		    problem_found = "T"
$		endif
$	    else
$		if verbose then write sys$output "Parameter ",param_name,-
	    " -- same in all files, or use latest and issue warning"
$		value_'param_name' = param_value
$	    endif
$	    goto RECORD_LOOP
$	endif
$!
$!	_CUR,BAP_MIN,BAP_MAX,	Use the value from the file with the latest
$!	_MIN_PA,_MAX_PA,	date
$!	CODE_SIZE,DATA_SIZE
$!
$	if f$extract(pn_len-4,4,param_name) .eqs. "_CUR"	.or. -
	   f$extract(pn_len-7,7,param_name) .eqs. "BAP_MIN"	.or. -
	   f$extract(pn_len-7,7,param_name) .eqs. "BAP_MAX"	.or. -
	   f$extract(pn_len-6,6,param_name) .eqs. "MIN_PA"	.or. -
	   f$extract(pn_len-6,6,param_name) .eqs. "MAX_PA"	.or. -
	   f$extract(pn_len-9,9,param_name) .eqs. "CODE_SIZE"	.or. -
	   f$extract(pn_len-9,9,param_name) .eqs. "DATA_SIZE"
$	then
$	    if f$type(value_'param_name') .eqs. "" .or. this_is_latest_file
$	    then
$		if verbose .and. f$type(value_'param_name') .eqs. "" then -
		    write sys$output "Parameter ",param_name,-
			" -- use value from most-recent file"
$		value_'param_name' = param_value
$	    endif
$	    goto RECORD_LOOP
$	endif
$!
$!	_PEAK, _INUSE, SIZE, _PAGES	Select the highest value found
$!
$	if f$extract(pn_len-5,5,param_name) .eqs. "_PEAK"	.or. -
	   f$extract(pn_len-6,6,param_name) .eqs. "_INUSE"	.or. -
	   f$extract(pn_len-4,4,param_name) .eqs. "SIZE"	.or. -
	   f$extract(pn_len-6,6,param_name) .eqs. "_PAGES"	.or. -
	   f$extract(pn_len-8,8,param_name) .eqs. "PAGELETS"
$	then
$	    if f$type(value_'param_name') .nes. ""
$	    then
$		if param_value .gt. value_'param_name'
$		then
$		    value_'param_name' = param_value
$		endif
$	    else
$		if verbose then write sys$output "Parameter ",param_name,-
		    " -- select highest value encountered"
$		value_'param_name' = param_value
$	    endif
$	    goto RECORD_LOOP
$	endif
$!
$!	_UPTIME, FAIL,		Total the values from all the files
$!	FAILPAGES, REQUESTS,
$!	_IO, HITS, ATTEMPTS,
$!	_CNT
$!
$	if f$extract(pn_len-7,7,param_name) .eqs. "_UPTIME"	.or. -
	   f$extract(pn_len-4,4,param_name) .eqs. "FAIL"	.or. -
	   f$extract(pn_len-9,9,param_name) .eqs. "FAILPAGES"	.or. -
	   f$extract(pn_len-8,8,param_name) .eqs. "REQUESTS"	.or. -
	   f$extract(pn_len-3,3,param_name) .eqs. "_IO"		.or. -
	   f$extract(pn_len-4,4,param_name) .eqs. "HITS"	.or. -
	   f$extract(pn_len-8,8,param_name) .eqs. "ATTEMPTS"	.or. -
	   f$extract(pn_len-4,4,param_name) .eqs. "_CNT"
$	then
$	    if f$type(value_'param_name') .nes. ""
$	    then
$		value_'param_name' = f$integer(value_'param_name') + 'param_value'
$	    else
$		if verbose then write sys$output "Parameter ",param_name,-
		    " -- total the values from all files"
$		value_'param_name' = param_value
$	    endif
$	    goto RECORD_LOOP
$	endif
$!
$!	(anything else)		Use the value from the latest file, with a
$!				warning message
$!
$	if f$type(value_'param_name') .eqs. ""
$	then
$    	    say ""
$	    say "  Unrecognized parameter: ",param_name,"
$	    say "  -- will use value from latest file."
$	    value_'param_name' = param_value
$	    problem_found = "T"
$	else
$	    if this_is_latest_file then -
		value_'param_name' = param_value
$	endif
$	goto RECORD_LOOP
$!
$! Reached the end of an individual feedback file.  Look for another.
$ FILE_EOF:
$	close in
$	goto FILE_LOOP
$!
$! Have now read all feedback files.  Generate the summary information.
$!
$ PHASE_2:
$	i = 0
$ PARAM_LOOP:
$	i = i + 1
$	if i .le. param_count
$	then
$	    param_name = param_name_'i'
$	    write out param_name," = ",VALUE_'param_name'
$	    goto PARAM_LOOP
$	endif
$	close out
$! See if any errors occurred
$	if file_count .eq. 0
$	then
$	    say ""
$	    say "No valid AUTOGEN feedback files were found; can't summarize."
$	    say ""
$	    goto ABORT
$	endif
$	if file_count .eq. 1
$	then
$	    say ""
$	    say -
	"Only one valid AUTOGEN feedback file was found; can't summarize."
$	    say ""
$	    goto ABORT
$	endif
$	if problem_found
$	then
$	    inquire ans -
		"Do you wish to use the results of this run anyway? [N]"
$	    if .not. ans
$	    then
$		say ""
$		say "The results of this run are found in the file"
$		say "SYS$SYSTEM:AGEN_COMBINED_FEEDBACK.DAT, should you"
$		say "wish to examine them."
$	        say ""
$		say "Your SYS$SYSTEM:AGEN$FEEDBACK.DAT files have not"
$		say "been modified or superseded by a new version."
$		say ""
$		goto QUIT
$	    endif
$	endif
$	date = f$cvtime(time,"ABSOLUTE","DATE")
$	version = "*"
$	if f$search("SYS$SYSTEM:AGEN$FEEDBACK.OLD_''date'") .nes. "" then -
		version = "0"	!In case this is run twice in one day
$	rename SYS$SYSTEM:AGEN$FEEDBACK.DAT;* -
	       SYS$SYSTEM:AGEN$FEEDBACK.OLD_'date';'version'
$	say ""
$	say "Individual feedback files have all be renamed to"
$	say "SYS$SYSTEM:AGEN$FEEDBACK.OLD_''date'.  You may wish to delete"
$	say "these files after running AUTOGEN."
$	if f$search("SYS$SYSTEM:AGEN_COMBINED_FEEDBACK.DAT;-1") .nes. "" then -
	    purge/nolog SYS$SYSTEM:AGEN_COMBINED_FEEDBACK.DAT
$	rename SYS$SYSTEM:AGEN_COMBINED_FEEDBACK.DAT -
	       SYS$SYSTEM:AGEN$FEEDBACK.DAT;
$	say ""
$	say "A new version of SYS$SYSTEM:AGEN$FEEDBACK.DAT has been"
$	say "created from the contents of the individual files.  You"
$	say "may wish to examine this file before running AUTOGEN."
$ QUIT:
$	say ""
$	say "COMBINE_FEEDBACK done.
$	exit
$ ABORT:
$	delete sys$system:AGEN_COMBINED_FEEDBACK.DAT;*
$ OOPS:
$	say "COMBINE_FEEDBACK aborted."
$	exit

