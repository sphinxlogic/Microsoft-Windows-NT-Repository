<!-- LANGUAGE_021.HTML continuation of DOCDATA:[DOC.INTOUCH]LANGUAGE.HTML -->
<html>
<head>
<title>INTOUCH&#174; 4GL </title>
</head>
<body background="/white.gif">
<h1 align="center">INTOUCH<sup>&#174;</sup> 4GL <br> A Guide to the INTOUCH Language</h1>

<hr> <a href="LANGUAGE_020.HTML#bottom_020">Previous page...</a> 
<a href="LANGUAGE_CONTENTS.HTML">Table of Contents</a>

<hr size=5>

<a name="index_x_1345"></a>
<a name="index_x_1346"></a>
<a name="index_x_1347"></a>

<p>
Given an angle in radians, returns the number of degrees. 

<p>
<h2>DIV0(num_expr1, num_expr2)</h2>

<a name="index_x_1348"></a>
<a name="index_x_1349"></a>

<p>
The DIV0 function divides num_expr1 by num_expr2.  If num_expr2 (divisor) 
is 0, 0 is returned. 

<p><pre>
        10  PRINT DIV0(0.8, 0.000004) 
            PRINT DIV0(0.8, 0.0) 
            PRINT DIV0(6, 3) 
            PRINT DIV0(6, 0) 
        20  END 
 
        RNH 
         200000 
         0 
         2 
         0 
</pre>

<h2>DTYPE(expr)</h2>

<a name="index_x_1350"></a>
<a name="index_x_1351"></a>

<p>
The DTYPE function returns as an integer value, the data type of an 
expression or dynamic variable:  1 = string, 2 = integer, 3 = real. 

<p><pre>
        10  DECLARE DYNAMIC x 
        20  x = 45.6 
        30  PRINT DTYPE(x) 
        40  END 
 
        RNH 
        3 
</pre>

<h2>EDIT$(str_expr,int_expr)</h2>

<a name="index_x_1352"></a>
<a name="index_x_1353"></a>
<a name="index_x_1354"></a>

<p>
EDIT$ performs one or more editing operations, depending on the value of 
the integer expression, on the supplied string argument.  The integer 
expression is one of the integers below, or a sum of integers below for 
the desired edit functions: 
<p><a name="table_a-4"></a>
<table border>
  <caption><b>Table A-4 EDIT$ Function - Operation Values</b></caption>
  <tr>
    <th align=center>Value </th>
    <th align=center>Edit Operation </th>
  </tr>
  <tr>
    <td>1 </td>
    <td>Trim parity bits.</td>
  </tr>
  <tr>
    <td>2 </td>
    <td>Discard all spaces and tabs.</td>
  </tr>
  <tr>
    <td>4 </td>
    <td>Discard characters: CR, LF, FF, ESC, RUBOUT and NULL.</td>
  </tr>
  <tr>
    <td>8 </td>
    <td>Discard leading spaces and tabs.</td>
  </tr>
  <tr>
    <td>16 </td>
    <td>Reduce spaces and tabs to One space.</td>
  </tr>
  <tr>
    <td>32 </td>
    <td>Convert lower case to upper case.</td>
  </tr>
  <tr>
    <td>64 </td>
    <td>Convert "[" to "(" and "]" to ")".</td>
  </tr>
  <tr>
    <td>128 </td>
    <td>Discard trailing spaces and tabs.</td>
  </tr>
  <tr>
    <td>256 </td>
    <td>Do not alter characters inside quotes.</td>
  </tr>
</table>

<p>
<h2>ELEMENTS(str_expr1 [, str_expr2])</h2>

<a name="index_x_1355"></a>
<a name="index_x_1356"></a>

<p>
Returns the number of elements in a string expression which contains a 
list of elements.  Str_expr1 is the string containing the list of elements.  
Str_expr2 is the separator.  A comma is the default separator. 
<dl>
<dd>

<ul>
  <li>Leading and trailing spaces are removed from the text. 
  <li>Quoted data is treated as one element. 
</ul>

</dl>

<p>
<h2>ELEMENT$(str_expr1, num_expr [, str_expr2])</h2>

<a name="index_x_1357"></a>
<a name="index_x_1358"></a>

<p>
ELEMENT$ returns the element from str_expr1 which is specified by the 
num_expr.  Str_expr1 contains a set of elements with separators between 
them.  The default separator is a comma: 

<p><pre>
        10  LET a$ = ELEMENT$('ADD,DEL,EXIT',2) 
        20  PRINT a$ 
        30  END 
 
        RNH 
        DEL 
</pre>

<p>
You can specify a separator other than the comma with str_expr2.  

<p><pre>
        10  LET sentence$ = 'This is a test.' 
        20  LET a$ = ELEMENT$(sentence$,2,' ') 
        30  PRINT a$ 
 
        RNH 
        is 
</pre>

<p>
More than one separator in a row returns a null for the corresponding 
element.  

<p><pre>
        10  LET sentence$ = 'This,, is, a, test'  
            PRINT ELEMENT$(sentence$, 2) 
        20  END 
 
        RNH 
 
</pre>

<h2>ENCODE$(num_expr, num_int)</h2>

<a name="index_x_1359"></a>
<a name="index_x_1360"></a>

<p>
Returns a string containing a number converted to the base specified.  
Num_expr is the value to convert.  Num_int is the base to convert.  For 
instance, '2' indicates binary, etc. 

<p>
<h2>EPS(num_expr)</h2>

<a name="index_x_1361"></a>
<a name="index_x_1362"></a>

<p>
INTOUCH carries 15 digits of precision.  The EPS(number) returns the 
smallest value, which when added to "number" yields the next number. 

<p>
<h2>EVAL(str_expr)</h2>

<a name="index_x_1363"></a>
<a name="index_x_1364"></a>

<p>
This function evaluates the expression described in str_expr, and returns 
the result.  If the variable being assigned the result is dynamic, the 
function puts the result in whatever data type the expression result was in. 
If the variable is NOT dynamic, and the result is the wrong data type, a 
"Data type mismatch" error is returned. 

<p><pre>
        10  LINE INPUT 'Enter an expression': a$ 
            PRINT 'The result is '; EVAL(a$) 
        20  END 
 
        RNH 
        Enter an expression?  5 + 4 
        The result is  9 
</pre>

<h2>EXLABEL$</h2>

<a name="index_x_1365"></a>
<a name="index_x_1366"></a>

<p>
EXLABEL$ returns the label and line number executing when the last 
exception occurred, e.g., DO_INPUT.4 

<p>
<h2>EXLINE</h2>

<a name="index_x_1367"></a>
<a name="index_x_1368"></a>
<a name="index_x_1369"></a>

<p>
EXLINE returns the line number executing when the last exception occurred. 

<p>
<h2>EXP(num_expr)</h2>

<a name="index_x_1370"></a>
<a name="index_x_1371"></a>

<p>
EXP function returns the value of the mathematical constant, "e", raised 
to a specified power. 

<p>
<h2>EXTEXT$(int_expr)</h2>

<a name="index_x_1372"></a>
<a name="index_x_1373"></a>

<p>
EXTEXT$ returns explanatory text associated with a specified exception 
number. 

<p>
<h2>EXTYPE</h2>

<a name="index_x_1374"></a>
<a name="index_x_1375"></a>

<p>
EXTYPE returns the number of the last exception that occurred.  It is 
returned as an integer. 

<p>
<h2>FALSE</h2>

<a name="index_x_1376"></a>
<a name="index_x_1377"></a>

<p>
Returns the constant 0.  It is returned as an integer. 

<p>
<h2>FILESPEC$(str_expr1 [, str_expr2 [, str_expr3]])</h2>

<a name="index_x_1378"></a>
<a name="index_x_1379"></a>

<p>
FILESPEC$ parses a file specification and returns either a full file 
specification or specific file specification fields. 

<p>
Str_expr1 is the file specification to be parsed.  If no file specification 
is given, the device and directory you are currently running from are returned. 

<p>
Str_expr2 is a list of field names, separated by commas, which are to be 
returned.  The field names are: 
<table border>
  <tr>
    <td> </td>
    <td>DEVICE </td>
    <td>device name</td>
  </tr>
  <tr>
    <td> </td>
    <td>DIRECTORY </td>
    <td>directory name</td>
  </tr>
  <tr>
    <td> </td>
    <td>NAME </td>
    <td>file name</td>
  </tr>
  <tr>
    <td> </td>
    <td>TYPE </td>
    <td>type or extension name</td>
  </tr>
  <tr>
    <td> </td>
    <td>VERSION </td>
    <td>file version number</td>
  </tr>
  <tr>
    <td> </td>
    <td>LOCATION </td>
    <td>device and directory names</td>
  </tr>
  <tr>
    <td> </td>
    <td>ALL or "" </td>
    <td>full file specification</td>
  </tr>
</table>

<p>
Str_expr3 is the default file specification.  This parameter is optional. 

<p>
FILESPEC$ can be used in various formats. 

<p><pre>
        10  PRINT FILESPEC$('x.y', 'ALL') 
            PRINT FILESPEC$('', 'ALL') 
        20  END 
 
        RNH 
        USER:[FRED]X.Y; 
        USER:[FRED].; 
</pre>

<p>

<pre>
        10  x$ = 'TTI_RUN:CLIENT' 
            PRINT FILESPEC$(x$, 'ALL', '.dat') 
        20  END 
 
        RNH 
        STORAGE:[INTOUCH]CLIENT.DAT; 
</pre>

<p>

<pre>
        10  PRINT FILESPEC$('tti_run:client', 'ALL', '.dat') 
            PRINT FILESPEC$('tti_run:client', 'LOCATION') 
            PRINT FILESPEC$('tti_run:client', 'LOCATION, NAME') 
            PRINT FILESPEC$('tti_run:client.dat;1') 
        20  END 
 
        RNH 
        STORAGE:[INTOUCH]CLIENT.DAT;  
        STORAGE:[INTOUCH] 
        STORAGE:[INTOUCH]CLIENT 
        STORAGE:[INTOUCH]CLIENT.DAT;1 
</pre>

<h2>FINDFILE$(str_expr [, int_expr])</h2>

<a name="index_x_1380"></a>
<a name="index_x_1381"></a>

<p>
Given a file name to find, returns the complete file specification of 
the first file found that matches the name given.  If no file is found, 
the function returns a null string. 

<p>
<b>FINDFILE$</b> calls can be nested if the inner call has 
only one argument (i.e., the file specification, but no index number). 
<table border>
  <tr>
    <td> </td>
    <td>str_expr </td>
    <td>The name of the file to search for. This can be just part of the full file specification.</td>
  </tr>
  <tr>
    <td> </td>
    <td>int_expr </td>
    <td>Which file specification to return if multiple files are found. This parameter is optional. The default is to return the first file found.</td>
  </tr>
  <tr>
    <td> </td>
    <td>Result </td>
    <td>The complete file specification of the file found.</td>
  </tr>
</table>

<p><pre>
        10  PRINT FINDFILE$('tti_run:*.int') 
 
        RNH 
        DUA0:[INTOUCH]ALIENS.INT;5 
</pre>

<p>

<pre>
        10  DO 
              LINE INPUT 'File.Spec': spec$ 
              IF  _EXIT  THEN  EXIT DO         
              FOR i = 1 TO 9999 
                file$ = FINDFILE$(spec$, i) 
                IF  file$ = ''  THEN  EXIT FOR 
                PRINT file$ 
              NEXT i 
            LOOP 
        20  END 
 
        RNH 
        File specification? TTI_RUN:CLIENT.* 
        DUA0:[INTOUCH]CLIENT.DAT;7 
        DUA0:[INTOUCH]CLIENT.DEF;3 
        DUA0:[INTOUCH]CLIENT.INT;1 
        DUA0:[INTOUCH]CLIENT.SAV;1 
        DUA0:[INTOUCH]CLIENT.STR;16 
</pre>

<h2>FORMAT$(expr, str_expr)</h2>

<a name="index_x_1382"></a>
<a name="index_x_1383"></a>

<p>
Given an expression and a format, returns the result of the expression 
in the format indicated. 

<p>
The '@' format character causes the character not to be translated 
by the formatter.  The '&lt;' and '&gt;'are treated like an '@' character. 
You can justify a character string, but avoid zero suppression and 
zero insertion. 

<p>
The FORMAT$ function takes an expression of any data type for 
the data to format (the first argument), including string expressions. 

<p><pre>
        10  z$ = FORMAT$('1234567', '###~-####') 
            PRINT 'Phone number: '; z$ 
        20  END 
 
        RNH 
        Phone number: 123-4567 
</pre>

<p>
The FORMAT$ function returns all asterisks "*" in the case of overflow. 

<p><pre>
        10  z$ = FORMAT$(12.23,'#.##') 
            PRINT z$ 
        20  END 
 
        RNH 
        **** 
</pre>

<p>
FORMAT$() returns the same string data as given by the following: 

<p><pre>
        PRINT USING str_expr: expr 
</pre>

<p>
<a name="index_x_1384"></a>
<a name="index_x_1385"></a>
The FORMAT$ function supports the DATE format and date arguments. 
Given a date in YYMMDD or CCYYMMDD format, FORMAT$ returns the date in 
the date format requested. 

<p><pre>
        FORMAT$(z$, '{DATE [argument]}?') 
</pre>

<p>
The <b>?</b> can be replaced with a mask. 
If no date argument is provided, the default is MDCY. 

<p><pre>
        10  z1$ = FORMAT$('950401', '{DATE MDCY}?') 
            z2$ = FORMAT$('950401', '{DATE MDCY}##/##/####') 
            z3$ = FORMAT$('19950401', '{DATE MDCY}?') 
            z4$ = FORMAT$('19950401', '{DATE MDCY}##/##/####') 
        20  PRINT z1$, z2$ 
            PRINT z3$, z4$ 
        30  END 
 
        RNH 
        04011995            04/01/1995 
        04011995            04/01/1995 
</pre>

<p><a name="table_a-5"></a>
<table border>
  <caption><b>Table A-5 FORMAT$ Function - Date Arguments</b></caption>
  <tr>
    <th align=center>DATE <br> Argument </th>
    <th align=center>YYMMDD <br> Input </th>
    <th align=center>Result </th>
    <th align=center>CCYYMMDD <br> Input </th>
    <th align=center>Result </th>
  </tr>
  <tr>
    <td>none </td>
    <td>950207 </td>
    <td>02071995 </td>
    <td>19950207 </td>
    <td>02071995</td>
  </tr>
  <tr>
    <td>YMD </td>
    <td>950207 </td>
    <td>950207 </td>
    <td>19950207 </td>
    <td>950207</td>
  </tr>
  <tr>
    <td>CYMD </td>
    <td>950207 </td>
    <td>19950207 </td>
    <td>19950207 </td>
    <td>19950207</td>
  </tr>
  <tr>
    <td>MDY </td>
    <td>950207 </td>
    <td>022195 </td>
    <td>19950207 </td>
    <td>022195</td>
  </tr>
  <tr>
    <td>MDCY </td>
    <td>950207 </td>
    <td>02071995 </td>
    <td>19950207 </td>
    <td>02071995</td>
  </tr>
  <tr>
    <td>DMY </td>
    <td>950207 </td>
    <td>070295 </td>
    <td>19950207 </td>
    <td>070295</td>
  </tr>
  <tr>
    <td>DMCY </td>
    <td>950207 </td>
    <td>07021995 </td>
    <td>19950207 </td>
    <td>07021995</td>
  </tr>
  <tr>
    <td>DMONY </td>
    <td>950207 </td>
    <td>07-Feb-95 </td>
    <td>19950207 </td>
    <td>07-Feb-95</td>
  </tr>
  <tr>
    <td>DMONCY </td>
    <td>950207 </td>
    <td>07-Feb-1995 </td>
    <td>19950207 </td>
    <td>07-Feb-1995</td>
  </tr>
  <tr>
    <td>MONTHDY </td>
    <td>950207 </td>
    <td>February 7, 95 </td>
    <td>19950207 </td>
    <td>February 7, 95</td>
  </tr>
  <tr>
    <td>MONTHDCY </td>
    <td>950207 </td>
    <td>February 7, 1995 </td>
    <td>19950207 </td>
    <td>February 7, 1995</td>
  </tr>
</table>

<p>
<a name="index_x_1386"></a>
<a name="index_x_1387"></a>
The FORMAT$ function supports character rotation.  The ROTATE option rotates 
the last nn characters of a string to the first position in the string. 

<p><pre>
        FORMAT$(z$, '{ROTATE n}?') 
</pre>

<p>
The <b>?</b> can be replaced with a mask. 

<p><pre>
        10  z1$ = FORMAT$('5552527800', '{ROTATE 3}?') 
            z2$ = FORMAT$('5552527800', '{ROTATE 3}###~ ###~-####') 
            z3$ = FORMAT$('TuneTommy', '{ROTATE 5}?') 
            z4$ = FORMAT$('TuneTommy', '{ROTATE 5}#####~ ####') 
        20  PRINT z1$, z2$ 
            PRINT z3$, z4$ 
        30  END 
 
        RNH 
        8005552527            800 555-2527 
        TommyTune             Tommy Tune 
</pre>

<p>
<a name="index_x_1388"></a>
<a name="index_x_1389"></a>
The FORMAT$ function supports the TIME format. 
Given a military standard time in HHMM, HH:MM, HHMMSS or HH:MM:SS format, 
FORMAT$ returns the time as HH:MM AM/PM or HH:MM:SS AM/PM. 

<p><pre>
        FORMAT$(z$, '{TIME}?') 
</pre>

<p><pre>
        10  t1$ = FORMAT$('1022', '{TIME}?') 
            t2$ = FORMAT$('19:45:36', '{TIME}?') 
        20  PRINT t1$ 
            PRINT t2$ 
        30  END 
 
        RNH 
        10:22 AM 
        07:45:36 PM 
</pre>

<p>
<a name="index_x_1390"></a>
<a name="index_x_1391"></a>
The FORMAT$ function supports the ZIPCODE format. 
Given a 5, 6 or 9 digit zipcode, FORMAT$ returns a formatted zipcode. 

<p><pre>
        FORMAT$(z$, '{ZIPCODE}?') 
</pre>

<p><pre>
        10  z1$ = FORMAT$('92126', '{ZIPCODE}?') 
            z2$ = FORMAT$('K8A3P9', '{ZIPCODE}?') 
            z3$ = FORMAT$('931327845', '{ZIPCODE}?') 
        20  PRINT '5 character zipcode : '; z1$ 
            PRINT '6 character zipcode : '; z2$ 
            PRINT '9 character zipcode : '; z3$ 
        30  END 
 
        RNH 
        5 character zipcode : 92126 
        6 character zipcode : K8A 3P9 
        9 character zipcode : 93132-7845 
</pre>

<h2>FP(num_expr)</h2>

<a name="index_x_1392"></a>
<a name="index_x_1393"></a>

<p>
Given a number, returns the fractional part of the number. 

<p>
<h2>FULLTIME$[(float_expr, [int_var])]</h2>

<a name="index_x_1394"></a>
<a name="index_x_1395"></a>

<p>
Given the number of seconds since the INTOUCH base date, this function 
returns the date and time in one of the formats given below. 

<p>
Where float_expr is the number of seconds since the INTOUCH base date. 
The default is the current date and time.  January 1, 1600 00:00:00 is 
considered the second 0. 
<p><a name="table_a-6"></a>
<table border>
  <caption><b>Table A-6 FULLTIME$ Function - Integer Values</b></caption>
  <tr>
    <th align=center>Value (int_var) </th>
    <th align=center>Output Data Format </th>
  </tr>
  <tr>
    <td>0 </td>
    <td>CCYYMDD HHMMSS</td>
  </tr>
  <tr>
    <td>1 </td>
    <td>MMDDCCYY HHMMSS</td>
  </tr>
  <tr>
    <td>2 </td>
    <td>DDMMCCYY HHMMSS</td>
  </tr>
  <tr>
    <td>3 </td>
    <td>DD-Mon-CCYY HH:MM:SS</td>
  </tr>
  <tr>
    <td>4 </td>
    <td>Month DD, CCYY HH:MM:SS</td>
  </tr>
</table>

<p><pre>
        10  PRINT FULLTIME$ 
        20  sec = SECONDS('19910621 115042') 
        30  PRINT FULLTIME$(sec, 0) 
        40  PRINT FULLTIME$(sec, 1) 
        50  PRINT FULLTIME$(sec, 2) 
        60  PRINT FULLTIME$(sec, 3) 
        70  PRINT FULLTIME$(sec, 4) 
        80  END 
 
        RNH 
        19910621 123756 
        19910621 115042 
        06211991 115042 
        21061991 115042 
        21-Jun-1991 11:50:42 
        June 21, 1991 11:50:42 
</pre>

<h2>HASH$(str_expr1 [, str_expr2 [, int_expr]])</h2>

<a name="index_x_1396"></a>
<a name="index_x_1397"></a>

<p>
This function changes the plain text in str_expr1 into a hashed eight-byte 
string value.  It can be used to develop one-way hashed passwords.  The 
optional text in str_expr2 and optional int_expr can be used to further make 
the hashed value unique. 

<p><pre>
        10  password$ = HASH$('TRUTH') 
            INPUT 'Password': pwd$ 
            IF  HASH$(pwd$) = password$  THEN 
              PRINT 'That was the correct password.' 
            ELSE        
              PRINT 'That was not the correct password.' 
            END IF 
        20  END      
 
        RNH 
        Password?  MONEY 
        That was not the correct password. 
</pre>

<h2>INT(num_expr)</h2>

<a name="index_x_1398"></a>
<a name="index_x_1399"></a>

<p>
INT returns the whole portion of a real number as a real number. 

<p>
<h2>INTEGER(num_expr)</h2>

<a name="index_x_1400"></a>
<a name="index_x_1401"></a>

<p>
INTEGER changes any numeric expression into an integer value and assigns 
the integer value to the variable specified. 

<p>
<h2>IP(num_expr)</h2>

<a name="index_x_1402"></a>
<a name="index_x_1403"></a>

<p>
IP truncates the value of a real number at the decimal point and returns 
the integer portion. 

<p>
<h2>ITEM(str_expr1, str_expr2)</h2>

<a name="index_x_1404"></a>
<a name="index_x_1405"></a>

<p>
The ITEM function returns the number of the first item that matches the 
whole or partial item name given.  A negative number is returned if more 
than one item matches. 

<p><pre>
        10  z = ITEM('ADD,EXIT,EXTRACT,MODIFY', 'MOD')   
            PRINT z 
        20  END 
 
        RNH 
        4 
 
 
 
        10  z = ITEM('ADD,EXIT,EXTRACT,MODIFY', 'EX') 
            PRINT z 
        20  END 
 
        RNH 
        -2 
</pre>

<h2>LBOUND(array_name [,int_expr])</h2>

<a name="index_x_1406"></a>
<a name="index_x_1407"></a>

<p>
Given an array and a dimension number, returns the low bound for that 
dimension.  The default dimension is 1. 

<p>
<h2>LCASE$(str_expr)</h2>

<a name="index_x_1408"></a>
<a name="index_x_1409"></a>

<p>
LCASE returns a string expression with all letters in lower case. 

<p>
<h2>LEFT[$](str_expr, int_expr)</h2>

<a name="index_x_1410"></a>
<a name="index_x_1411"></a>

<p>
LEFT$ returns the leftmost <b>nn</b> characters from a string.  
Int_expr is the last character position to be included in the resulting string. 

<p>
<h2>LEN(str_expr)</h2>

<a name="index_x_1412"></a>
<a name="index_x_1413"></a>

<p>
LEN returns the length of a string.  It returns an integer. 

<p>
<h2>LOG(num_expr)</h2>

<a name="index_x_1414"></a>
<a name="index_x_1415"></a>

<p>
LOG returns the natural logarithm of a specified number. 

<p>
<h2>LOG2(num_expr)</h2>

<a name="index_x_1416"></a>
<a name="index_x_1417"></a>

<p>
LOG2 returns a number's base 2 logarithm. 

<p>
<h2>LOG10(num_expr)</h2>

<a name="index_x_1418"></a>
<a name="index_x_1419"></a>

<p>
LOG10 returns a number's common logarithm. 

<p>
<h2>LPAD$(text_str, size [, pad_str])</h2>

<a name="index_x_1420"></a>
<a name="index_x_1421"></a>

<p>
LPAD$ pads a string on the left with pad characters.  The default pad 
character is a space.  

<p><pre>
        10  PRINT LPAD$('123', 6, '0') 
        20  END 
        RNH 
 
        000123 
</pre>

<h2>LTRIM$(str_expr)</h2>

<a name="index_x_1422"></a>
<a name="index_x_1423"></a>
<a name="index_x_1424"></a>

<p>
Removes all leading spaces (those on the left side of the string). 

<p>
<h2>MATCH(str_expr1, str_expr2)</h2>

<a name="index_x_1425"></a>
<a name="index_x_1426"></a>

<p>
Str_expr1 contains a list of elements separated by commas.  Str_expr2 
contains a string.  MATCH compares str_expr2 with each of the elements in 
str_expr1 and gives the number of the element that matches. 

<p>
Quoted data is treated as one element; the quotes are not removed. 

<p><pre>
        10  INPUT 'Which procedure (ADD,DEL,QUIT)': pro$ 
        20  LET x = MATCH('ADD,DEL,QUIT', pro$) 
        30  ON x GOSUB 50, 70, 90 
        40  GOTO 10 
        50  PRINT 'Adding...' 
        60  RETURN 
        70  PRINT 'Deleting...' 
        80  RETURN 
        90  END 
</pre>

<h2>MAX(num_expr, num_expr)</h2>

<a name="index_x_1427"></a>
<a name="index_x_1428"></a>

<p>
MAX(x,y) returns the larger of the two values x and y. 

<p>
<h2>MAXLEN(str_var)</h2>

<a name="index_x_1429"></a>
<a name="index_x_1430"></a>

<p>
Returns the maximum number of characters that a string variable can contain. 
Since all string variables are variable length, with a maximum of 65535, 
this function always returns 65535. 

<p>
<h2>MAXNUM</h2>

<a name="index_x_1431"></a>
<a name="index_x_1432"></a>

<p>
Returns the largest number available in this implementation of INTOUCH. 

<p>
<h2>MAXSIZE(array_name)</h2>

<a name="index_x_1433"></a>
<a name="index_x_1434"></a>

<p>
Returns the total number of elements that can be contained in an array. 

<p>
<h2>MID[$](str_expr, int_expr1 [,int_expr2])</h2>

<a name="index_x_1435"></a>
<a name="index_x_1436"></a>

<p>
MID$ or MID returns a substring from the middle characters of a specified 
string, leaving the string unchanged. Int_expr1 is the starting position of 
the substring, and int_expr2 is the length of the substring. 
MID$(str_expr,int_expr1) will return the rest of the string. 

<p><pre>
        10  a$ = 'beginmiddleend' 
            middle$ = MID$(a$, 6, 6) 
            end$ = MID$(a$, 6) 
            PRINT middle$, end$ 
        20  END 
 
        RNH 
        middle     middleend 
</pre>

<h2>MIN(num_expr1, num_expr2)</h2>

<a name="index_x_1437"></a>
<a name="index_x_1438"></a>

<p>
MIN(x,y) returns the lesser of the values x and y. 

<p>
<h2>MOD(num_expr1, num_expr2)</h2>

<a name="index_x_1439"></a>
<a name="index_x_1440"></a>

<p>
Gives the remainder of one number divided by another. 

<p>
<h2>ORD(str_expr)</h2>

<a name="index_x_1441"></a>
<a name="index_x_1442"></a>

<p>
Given the ASCII name of a character, returns the location of that character 
in the ASCII character table.  It returns an integer number. 

<p>
<h2>ORDNAME$(int_expr)</h2>

<a name="index_x_1443"></a>
<a name="index_x_1444"></a>

<p>
Given the location of a character in the ASCII character table, returns 
the name of that character. 

<p>
<h2>PARSE$(str_expr)</h2>

<a name="index_x_1445"></a>
<a name="index_x_1446"></a>

<p>
PARSE$ splits a string into tokens and returns each token separated by a 
space.  Letters are upper-cased, except within quotes.  Tail comments 
are ignored.  Embedded "$" characters are allowed.  The maximum line 
length is 1024 characters. 

<p><pre>
        a$ = 'company$ = abc$ +"and sons" !rnn' 
        PRINT PARSE$(a$) 
 
        RNH 
        COMPANY$ = ABC$ + "and sons" 
</pre>

<h2>PATTERN(str_expr1, str_expr2)</h2>

<a name="index_x_1447"></a>
<a name="index_x_1448"></a>

<p>
Matches any characters in text (str_expr1) with the pattern (str_expr2). 
Str_expr1 is the text to search and str_expr2 is the pattern being 
searched for.  Returns the location of the first character in the text 
that contains the pattern.  If the characters cannot be found, returns zero. 

<p>
<b>PATTERN Options and Examples</b>

<p>
Pattern options can be mixed and matched with unlimited complexity. 
<h2>?</h2>

<dl>
<dd>

<p>
Matches any character in the text. 

<p><pre>
        10  IF  PATTERN('The quick brown fox', &amp; 
               'f?x') &gt; 0  THEN 
               PRINT 'Found' 
            END IF 
        20  END 
                                 
        RNH 
        Found 
</pre>

</dl>
<h2>*</h2>

<dl>
<dd>

<p>
Matches zero or more of a character that precedes the asterisk. 

<p><pre>
        10  IF  PATTERN('aaa   03/26/92', 'a* *03/26/92') &gt; 0  THEN 
              PRINT 'The date is found' 
            END IF 
        20  END 
                
        RNH 
        The date is found 
</pre>

</dl>
<h2>{}</h2>

<dl>
<dd>

<p>
Used to define a group of characters.  The characters in the enclosed 
group can be ranges such as {a-z} or individual characters such as {AQX}. 

<p><pre>
        10  text$ = 'A1N5V7N0' 
            rule_str$ = '{A-Z}{0-9}{A-Z}{0-9}{A-Z}{0-9}{A-Z}{0-9}' 
            IF  PATTERN(text$, rule_str$) &gt; 0  THEN  
              PRINT 'Driver's licence is correct' 
            END IF 
        20  END  
 
        RNH 
        Driver's licence is correct 
</pre>

</dl>
<h2>{^}</h2>

<dl>
<dd>

<p>
Looks for characters that are NOT {^A-Z}.  The result of line 30 below 
shows the difference between using '?' and {^}. 

<p><pre>
        10  PRINT PATTERN('Mary J. Smith','{^Mar}') 
        20  PRINT PATTERN('Mary J. Smith','J. {^S}') 
        30  PRINT PATTERN('Mary J. Smith','J. S?') 
        40  END 
 
        RNH 
        4 
        0  
        6 
</pre>

</dl>
<h2>~</h2>

<dl>
<dd>

<p>
The '~' (quote) character looks for a pattern of text that IS an * (stands 
for itself). 

<p><pre>
        10  text$ = '$4,670.00' 
            IF  PATTERN(text$, '$~4, 670.00') &gt; 0  THEN 
              PRINT 'Your text is correct' 
            END IF 
        20  END 
                     
        RNH 
        Your text is correct 
</pre>

</dl>
<h2>{&lt;cc|ccc|c&gt;}</h2>

<dl>
<dd>

<p>
Looks for text in str_expr1 that matches the enclosed groups. 

<p><pre>
        10  text$ = 'The area code is 619' 
            IF  PATTERN(text$, 'is {&lt;619|714|916&gt;}') &gt; 0  THEN 
              PRINT 'Your area code is on the list' 
            END IF 
        20  END 
                       
        RNH 
        Your area code is on the list 
</pre>

</dl>

<p>
<h2>PI</h2><a name="bottom_021"></a>
<p>
<hr> <a href="language_022.html">Next page...</a> | 
<a href="language_contents.html">Table of Contents</a>
</body>
</html>
