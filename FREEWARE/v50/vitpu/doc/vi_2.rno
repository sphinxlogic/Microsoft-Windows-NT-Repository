.if system
.I-1
2 Set_options
.else system
.send toc .ifnot global
.hl 1 ^*Set options\*
.send toc .endif global
.endif system
.s
The ":set", EX, command allows you to change the behavior of VI under certain
circumstances.  There are several characteristics that you may or may not
wish to make use of.  Therefore, these can be altered by setting options.
Below is a list of options that you can set using the ":set" command.
Some of these options are either ON or OFF, and some have values.  The
proper syntax for changing the option therefore varies, and is outlined
with each option.
.s
.if system
.I-1
3 Auto_Send_to_DCL
.else system
.send toc .ifnot global
.hl 2 ^*Auto Send to DCL\*
.send toc .endif global
.endif system
.s
.LT
:set [no]senddcl            Determines whether or not pressing
                            <RETURN> while in the DCL buffer, and
                            while in insert mode, causes the
                            current line to be sent to the DCL
                            subprocess.  If senddcl is in effect,
                            then pressing return while you are in
                            the DCL buffer will cause the current
                            line to be sent to the DCL
                            subprocess.  The line typed, as well
                            as the output from the DCL command is
                            part of the undo region that is
                            deleted if you use undo after the DCL
                            command output appears in the DCL
                            buffer.  See the HELP section on the
                            DCL process for more information.
.EL
.if system
.I-1
3 Auto_line_wrap
.else system
.send toc .ifnot global
.hl 2 ^*Auto line wrap\*
.send toc .endif global
.endif system
.s
.LT
:set wrapmargin=integer     Sets the number of columns from the
                            right margin at which VI will wrap
                            text to the beginning of the next
                            line.  Normally, no wrapping is done,
                            i.e. wrapmargin=0 is in effect. 
.EL
.if system
.I-1
3 Auto_write
.else system
.send toc .ifnot global
.hl 2 ^*Auto write\*
.send toc .endif global
.endif system
.s
.LT
:set [no]autowrite          Determines whether or not modified
                            buffers are automatically written out
                            when you map a different buffer to
                            the window that a modified buffer is
                            mapped to. 
.EL
.if system
.I-1
3 Case_insensitive_search
.else system
.send toc .ifnot global
.hl 2 ^*Case insensitive search\*
.send toc .endif global
.endif system
.s
.LT
:set [no]ignorecase         Determines whether or not case is
                            ignored during string search
                            operations.  Normally, case is
                            ignored. 
.EL
.if system
.I-1
3 Change_file_list
.else system
.send toc .ifnot global
.hl 2 ^*Change file list\*
.send toc .endif global
.endif system
.s
.LT
:set file[s] <file spec>    Changes the list of files to edit to
                            be those specified by <file spec>.
                            <file spec> should be a single
                            filespec, or a comma separated list. 
.EL
.if system
.I-1
3 Error_bells
.else system
.send toc .ifnot global
.hl 2 ^*Error Bells\*
.send toc .endif global
.endif system
.s
.LT
:set [no]errorbells         Determines whether or not a bell is
                            sounded when certain errors occur.
.EL
.if system
.I-1
3 Expand_tabs
.else system
.send toc .ifnot global
.hl 2 ^*Expand tabs\*
.send toc .endif global
.endif system
.s
.LT
:set [no]tabs               Determines whether or not tabs are
                            expanded to the proper number of
                            spaces as you type.  "notabs" will
                            cause tabs to be expanded. 
.EL
.if system
.I-1
3 Line_report
.else system
.send toc .ifnot global
.hl 2 ^*Line report\*
.send toc .endif global
.endif system
.s
.LT
:set report=integer         Sets the number of lines at which VI
                            will tell you what you did.  E.g. if
                            you type, 2yy, then VI will quietly
                            yank 2 lines.  If you type, 10yy,
                            then VI will tell you "10 lines
                            yanked", providing report is set to
                            some number less than 10. The same
                            thing occurs for deletion, and put
                            operations. If more than 'report'
                            lines are added/deleted, then VI
                            tells you about it.  Report is set to
                            5 by default. 
.EL
.if system
.I-1
3 No_write
.else system
.send toc .ifnot global
.hl 2 ^*No write\*
.send toc .endif global
.endif system
.s
.LT
:set [no]write              Modifies the internal TPU flags for
                            the current buffer that tell TPU
                            whether or not to ignore
                            modifications to a buffer.  This flag
                            is examined during exit from VI to
                            determine whether or not to prompt
                            you to write out the buffer.  ":quit"
                            will ignore modified buffers that
                            have this flag set. 
.EL
.if system
.I-1
3 Paragraph_delimiters
.else system
.send toc .ifnot global
.hl 2 ^*Paragraph delimiters\*
.send toc .endif global
.endif system
.s
.LT
:set paragraphs=<pairs>     Sets pairs of characters that are
                            assumed to occur at the beginning of
                            the line following a ".".  It is
                            usually the case that these pairs of
                            characters are RUNOFF commands.  In
                            VI under UNIX, these pairs are NROFF
                            formatting commands.  A single
                            character, as in .P, should be
                            followed by a space in the string of
                            pairs of characters.  If a paragraph
                            movement (i.e. } or {) fails to
                            locate any of the specified patterns,
                            then the next blank line will be
                            searched for. 
.EL
.if system
.I-1
3 Read_only_files
.else system
.send toc .ifnot global
.hl 2 ^*Read Only Files\*
.send toc .endif global
.endif system
.s
.LT
:set [no]readonly           Changes the /READONLY attributes of a 
                            buffer.  If /READONLY is present on
                            the command line when the editor
                            starts, then all buffers during that
                            session of the editor will be created 
                            with the attribute, readonly.  These
                            buffers can not be written out on
                            exit, and if any are modified, you
                            must use the :q! command to exit the
                            editor.  A buffer that is :set
                            noreadonly will be written out apon
                            exit.
.EL
.if system
.I-1
3 Regular_expression_use
.else system
.send toc .ifnot global
.hl 2 ^*Regular expression use\*
.send toc .endif global
.endif system
.s
.LT
:set [no]magic              Determines whether or not regular
                            expressions are used in search
                            strings.  By default, regular
                            expressions are used. 
.EL
.if system
.I-1
3 Screen_length
.else system
.send toc .ifnot global
.hl 2 ^*Screen length\*
.send toc .endif global
.endif system
.s
.LT
:set window=lines           Sets the length of the screen in
                            lines that is used by VI.  The UNIX
                            version of VI chooses to use the
                            bottom of the screen as the base of a
                            small window.  The TPU version uses
                            the top of the screen.  The maximum
                            number of lines is terminal
                            dependent, the minimum is 3. 
.EL
.if system
.I-1
3 Screen_width
.else system
.send toc .ifnot global
.hl 2 ^*Screen width\*
.send toc .endif global
.endif system
.s
.LT
:set width=cols             Sets the width of the current window
                            to the specified value. The maximum
                            setting is terminal dependent, while
                            the minimum is left up to the user. 
.EL
.if system
.I-1
3 Scroll_amount
.else system
.send toc .ifnot global
.hl 2 ^*Scroll amount\*
.send toc .endif global
.endif system
.s
.LT
:set scroll=integer         Sets the default number of lines that
                            the window scrolls when ^D or ^U is
                            typed.  This number can also be set
                            by preceeding ^D or ^U with a count. 
.EL
.if system
.I-1
3 Section_delimiters
.else system
.send toc .ifnot global
.hl 2 ^*Section delimiters\*
.send toc .endif global
.endif system
.s
.LT
:set sections=<pairs>       Sets pairs of characters that are
                            assumed to occur at the beginning of
                            the line following a ".".  It is
                            usually the case that these pairs of
                            characters are RUNOFF commands.  In
                            VI under UNIX, these pairs are NROFF
                            formatting commands.  A single
                            character, as in .P, should be
                            followed by a space in the string of
                            pairs of characters.  There are some
                            pairs of characters that are
                            exceptions.  The pair of characters,
                            +c, really means a single '{' at the
                            beginning of the line.  The pair of
                            characters, +f, really means the
                            string, subroutine, or the string,
                            function, anywhere in the line.  The
                            pair of characters, +t, really means
                            the string, procedure, at the
                            beginning of the line.  If a section
                            movement (i.e. ]] or [[) fails, then
                            the next blank line will also be
                            searched for. 
.EL
.if system
.I-1
3 Shift_width
.else system
.send toc .ifnot global
.hl 2 ^*Shift width\*
.send toc .endif global
.endif system
.s
.LT
:set shiftwidth=integer     Sets the number of columns that text
                            is to be shifted by when the shift
                            left or shift right commands are
                            executed.
.EL 
.if system
.I-1
3 Show_settings
.else system
.send toc .ifnot global
.hl 2 ^*Show settings\*
.send toc .endif global
.endif system
.s
.LT
:set all                    Displays the current values of the
                            options.
.EL
.if system
.I-1
3 Tab_stops
.else system
.send toc .ifnot global
.hl 2 ^*Tab stops\*
.send toc .endif global
.endif system
.s
.LT
:set tabstops=integer       Sets the number of columns on the
                            screen that is used to represent a
                            tabstop.  The default is eight. 
.EL
.if system
.I-1
3 Tag_Case
.else system
.send toc .ifnot global
.hl 2 ^*Tag Case\*
.send toc .endif global
.endif system
.s
.LT
:set [no]tagcase            Determines whether or not the case of
                            a tag is recognized when searching
                            for it.  For case insensitive
                            languages or facilities, set
                            notagcase should be used, otherwise
                            the default, tagcase, is sufficient. 
.EL
.if system
.I-1
3 Tags_files
.else system
.send toc .ifnot global
.hl 2 ^*Tags files\*
.send toc .endif global
.endif system
.s
.LT
:set tags=<file list>       Sets the list of files that are used
                            to resolve tag references.  Each file
                            name should be separated by a space. 
.EL
.if system
.I-1
3 Type_ahead
.else system
.send toc .ifnot global
.hl 2 ^*Type ahead\*
.send toc .endif global
.endif system
.s
.LT
:set [no]update             Determines whether or not an explicit
                            TPU UPDATE is done after each
                            keystroke.  Normally, TPU will
                            process typeahead by not updating the
                            window until there is no typeahead.
                            ":set update" will foil these
                            attempts, and force an update to
                            occur after each keystroke during
                            command level processing. 
.EL
.if system
.I-1
3 Undo_and_maps
.else system
.send toc .ifnot global
.hl 2 ^*Undo and maps\*
.send toc .endif global
.endif system
.s
.LT
:set [no]undomap            Controls whether or not an attempt
                            is made to make it possible to undo
                            all buffer operations that occur
                            during the execution of a map or
                            learned key sequence (see the :map
                            and :learn commands). Normally, maps
                            are undoable because a copy of the
                            entire buffer is saved before a map
                            is executed.  While editing large
                            buffers, this makes it rather slow to
                            use maps, so you can turn this
                            feature off when it is deemed not
                            necessary. 
.EL
.if system
.I-1
3 Wrap_on_search
.else system
.send toc .ifnot global
.hl 2 ^*Wrap on search\*
.send toc .endif global
.endif system
.s
.LT
:set [no]wrapscan           Determines whether or not search
                            operations are continued at the
                            end/beginning of a buffer by moving
                            to the beginning/end, respecively.
                            Normally, wrapscan is in effect. 
.EL
.ifnot system
.send toc .ifnot global
.hl 1 ^*Additional key strokes\*
.send toc .endif global
.else system
.I-1
2 Additional_key_strokes
.s
.endif system
There are some additional key strokes available that pertain to using added
features of this version of VI.  Below is an outline of the added key strokes.
.ifnot system
.send toc .ifnot global
.hl 2 ^*Key pad keys used\*
.send toc .endif global
.else system
.s
.endif system
.lm+5
.LT
KP0                         Temporarily creates a window that
                            is the size of the entire
                            screen, and maps the current
                            buffer to that window.  Use KP1
                            (Delete window) to remove this
                            window, and uncover the windows
                            that were occluded by the
                            created window.  This command only
                            works when there is more than one
                            window on the screen.

KP1                         Delete the current window from
                            the screen and release its space
                            to one of the surrounding
                            windows. 

KP2                         Split the current window into
                            two windows divided by a status
                            line place at the line that the
                            cursor currently occupies. 

KP3                         Move down the screen to the next
                            window.

KP4                         Shrink the size of the current
                            window by one line, making the
                            window above, or below larger.
                            An attempt is made to shrink the
                            window by pulling up the bottom
                            line, if that fails, then an
                            attempt is made to pull down the
                            top line.  If that fails, then
                            the window can not be shrunk. 

KP5                         Enlarge the current window by
                            one line.  The same algorithym
                            as for shrink is used to
                            determine how to alter the size
                            of the window. 

KP6                         Move up the screen to the next
                            window.

PF1                         When using VI on a VT100 series
                            terminal, it is not possible to
                            have TPU recognize the ESCAPE
                            character, ASCII 27, it its
                            primary processing loop.  When
                            using a VT200 series terminal,
                            this is circumvented by using
                            F11 as if it were ESCAPE.  PF1
                            provides this functionality for
                            the VT100 series of terminals. 

PF2                         PF2 envokes the help facilities
                            available for VI.

.EL
.ifnot system
.send toc .ifnot global
.hl 2 ^*Keyboard keys used\*
.send toc .endif global
.else system
.s
.lm-5
KEY BOARD KEYS USED
.lm+5
.endif system
.s
.LT
CTRL-X                      The CTRL-X key is used to send a
                            DCL command to the DCL subprocess
                            that is bound to the DCL buffer.

CTRL-R                      The CTRL-R key is used to remember
                            a learn sequence any bind it to a
                            key.  The :learn command initiates
                            the learning process.
.EL
.lm-5
.ifnot system
.send toc .ifnot global
.hl 1 ^*Windows and buffers\*
.send toc .endif global
.else system
.I-1
2 Windows_and_buffers
.s
.endif system
The multiple window features of this implementation of VI make it possible to
view multiple portions of a single file, or different portions of different
files simultaneously.  It is also possible to yank/delete text from one
window/buffer and place it into another buffer.  To accomplish this, all
named buffers, and numbered, deletion buffers are globally available.  I.E.
there are no buffers that are local to a buffer, with a single exception being
the information pertaining to the undo operation.
.s
If you type 'u' while in a buffer different from the one that you made
the last change in, you will see the message
.s
.lm+5
Undo not in this buffer.
.s
.lm-5
displayed at the bottom of the screen.
.s
For more information on using multiple buffers and window, consult the
section on additional key strokes.
.ifnot system
.send toc .ifnot global
.hl 1 ^*Display differences\*
.send toc .endif global
.else system
.I-1
2 Display_differences
.s
.endif system
Due to certain characteristics of the TPU screen management facilities,
certain activities on the display differ from those found in UNIX VI.  One
difference is TPU's inability to display control characters in an expanded
format, such as "^H" for a literal backspace character in the text.  While
commands are being entered in EX mode, you will see that control characters
are displayed as "^?" where the "?" character is replaced by the appropriate
character corresponding to the control character typed.  This type of
expansion is possible here, but it is not possible to do it in the text
buffers displayed on the screen. If a key typed does not correspond to a
printable ASCII character, then a backward question mark will be displayed
when that key is typed. 
.ifnot system
.send toc .ifnot global
.hl 1 ^*Tag files\*
.send toc .endif global
.else system
.I-1
2 Tag_files
.s
.endif system
A tags file is a file that contains one or more lines each of which contains 3
columns of text.  Each column is separated by exactly one tab character. The
first column of text is the "tag" string.  The second column is the file with
which that tag is associated, and the remainder of the line contains an EX mode
command that will perform an action associated with that tag. Usually, the
action locates a specific line in the file that is associated with the tag.  VI
will position the cursor at the bottom of the buffer prior to the execution of
the EX mode command.  Typically, a tags file is used to locate the definition
of a languange procedure, or text formatter macro. 
.s
A simple tags file can be constructed by using a program to analyze the text
of a file, and locate the lines that should be tagged.  In the UNIX operating
system, there is a program called CTAGS(1) that analyzes C language source
files, and creates a 'tags' file that allows access to the functions contained
in the files specified.
.ifnot system
.send toc .ifnot global
.hl 1 ^*Kept Editors\*
.send toc .endif global
.else system
.I-1
2 Kept_Editors
.s
.endif system
VAX/VMS and TPU support the notion of a "Kept Editor".  A "Kept Editor" is
a subprocess that can be ATTACH'd to and from at will.  The
VI$ROOT:[EXE]VI.COM command procedure takes care of all of the details of
carrying out the operation of the "Kept Editor".  It knows how to locate,
and attach to an existing "Kept Editor", and how to automatically create
a new one if there is not one running.
.ifnot system
.send toc .ifnot global
.hl 1 ^*Other TPU's\*
.send toc .endif global
.else system
.I-1
2 Other_Tpus
.s
.endif system
If you wish to use other TPU applications, besides VI, there is a
program that can help in the negotiation of which CALL_USER routines and which
section file to use.  VI$ROOT:[SRC]VI.MAR is the source to this program.  It
translates the logical names VISECINI and VI$CALLUSER instead of the normal
TPUSECINI and TPU$CALLUSER logical names.  VI$ROOT:[EXE]VI.CLD is a CLD file
that makes VI.EXE accessable to your current process.  You
can make VI.EXE by using the command "@MAKE EXE" from within the VI$ROOT:[SRC]
directory.  Then you will need to use the command
.s
.lm+5
$ SET COMMAND VI$ROOT:[EXE]VI
.lm-5
.s
If you desire to use VI$ROOT:[EXE]VI.COM to run VI in a subprocess, then
you should install VI.CLD into SYS$SHARE:DCLTABLES.EXE.  See the Command
Language Definition manual for more information on doing this, if you
are not familiar with the procedure.  This is necessary because the command
tables are not propagated to a subprocess when it is created.
.ifnot system
.send toc .ifnot global
.hl 1 ^*The DCL buffer\*
.send toc .endif global
.else system
.I-1
2 DCL_buffer
.s
.endif system
There is a special buffer that is always associated with a DCL subprocess.
The "DCL buffer" can be used as an alternate method of collecting DCL output
if the filter_region (!<movement><command>) and read_from_command (:r!<command>)
capabilities do not fit your needs.  Any line in any buffer can be sent to
the DCL subprocess by placing the cursor on that line, and typing a ^X
(Control-X).
.s
When you type ^X, several actions can happen.  If you are not
already in the DCL buffer, then the current window will be split, and the
top window will be mapped to the DCL buffer, and you will be positioned there.
In either case, the command will be copied into the DCL buffer, and will also
be sent to the DCL subprocess.  If the subprocess does not exist, then it
will be created.  There are several ways that any one of these steps can
fail.  If they do, an appropriate diagnostic will be issued to allow you
to resolve the problem.
.s
The setable option, senddcl, allows you to use the DCL buffer interactively,
somewhat. When senddcl is in effect, you can place yourself in insert mode,
using A, a, I, i, R, O, or o, and then type a DCL command. When you press enter
at the end of the line, that line is sent to the DCL subprocess as input.  The
output of the DCL command is placed into the DCL buffer as if you had typed it
in addition to the command line.  Thus, undo will allow you to remove both the
command line, and the output from the DCL buffer with a minimum of trouble. 
.ifnot system
.send toc .ifnot global
.hl 1 ^*TPU bugs revealed\*
.send toc .endif global
.else system
.I-1
2 TPU_Bugs_Revealed
.s
.endif system
There are several problems with TPU that cause problems with this implementation
of VI.  Outlined below are some of the more major problems.  There are probably
some that I have forgotten by now.
.s
Every place that there is a TPU statement of the form:
.s
.lm+5
EXECUTE (COMPILE ("vi$global_var := ...."));
.lm-5
.s
there is a statement preceeding that line that initializes vi$global_var to
zero.  This is necessary to get around a bug in TPU that causes the storage
that vi$global_var is associated with before the EXECUTE (COMPILE ()), to
not be disassociated.  TPU would randomly scribble on string and buffer
descriptors until it would stop with an "internal error, please SPR this",
message.
.s
Another problems has to do with the KEY_NAME() values of keys.  It appears
that GET_INFO (DEFINED_KEY...) does not return proper KEY_NAME() values
for certain keys.  In particular, you will notice that maps to keys like
q, v, and others will be displayed with the key as a backward question
mark, instead of the proper letter, when you issue the :map command to
display the current maps.  This is currently (apparently) unsurmountable.
Some trickery (hacking I like to call it) could be done to coerce the
bogus key values into something reasonable, but I decided not to do that.
.s
Still another problem has to do with the fact that ASCII (CTRL_?_KEY) always
returns ASCII(0) instead of ASCII(1) through ASCII(26) as would be convienent.
I have written some code (hacks at best) to get around this problem by
normalizing the values around the value of CTRL_A_KEY.  An expression of
the form:
.s
.lm+5
keyname-CTRL_A_KEY/(CTRL_B_KEY-CTRL_A_KEY)
.lm-5
.s
will result in a value of 0 through 25 when keyname has a value in the
range of CTRL_A_KEY to CTRL_Z_KEY.  This code is really bogus, but I
did not see a more feasible way of doing this.  KEY_NAME() values should
really comprise another TPU data type so that ASCII could distinguish
between those values and integer values.  Then it could return the entire
string that represents the key stroke, e.g. "<ESC>[23~".
.s
TPU's pattern matching code is mostly broken.  The regular expression compiler
in VI generates TPU patterns that correspond to the RE's passed to it.  The
biggest problem with the TPU pattern matching is that it does not know how to
back out of a match, and try an alternative.  If two adjacent pieces of an RE
have a non-null intersection, then they can cause a pattern match failure
because the first pattern can consume a character that would match the
second pattern.  The SEARCH() routine will not backout of a match once
it has been made (even in the somewhat 'kludgy' incremental mode).
.s
The first time that you here a bell sound because you hit ESCAPE an extra
time, the screen will scroll up one line.  You MUST use ^L to redraw the
screen or you will be off by one line.  This is a bug in the screen management
routines used by TPU.
