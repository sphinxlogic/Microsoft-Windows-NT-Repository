!
!
!                   The VI EDITOR written in VAXTPU
!
!   Written by Gregg Wonderly
!   Mathematics Department
!   Oklahoma State University
!   Stillwater Oklahoma, 74078
!
!   internet: gregg@nemo.math.okstate.edu
!   uucp: okstate!nemo.math.okstate.edu!gregg
!
!   Version number 2, edit 657, 19-JUL-1989 22:42:46.87
!
!   This program is the property of the author, and you should refrain
!   from trying to make a profit from it (that's not nice).
!
!   You can pass it around freely, as you should have gotten it for free.
!   All I ask is that you give credit where credit is due.
!
!
!
!	Initialize TPU for VI emulation.
!
PROCEDURE vi$init_vars
	LOCAL
		i;

	vi$find_rng := 0;
	vi$_version := "VAX/TPU -- VI Version 2, Edit 657";
	message_buffer := 0;
	message_window := 0;
	vi$did_mess := 0;

	command_buffer := 0;
	command_window := 0;

	show_buffer := 0;
	info_window := 0;

	choice_buffer := 0;
	choice_window := 0;

	vi$last_mapped := 0;
	vi$delete_empty := 0;

	vi$last_insert := 0;

	vi$bracket_chars := "{}()[]";		! The recognized brackets.

	! interline movement that is backwards, or different than the others

	vi$paren_cnt := 0;
	vi$abbr_ := "";
	vi$back_moves := "bB0FT^(";
	vi$weird_moves := "ft$DeE%?";
	vi$weird2_moves := "h";
	vi$dot_keys := "iIdpPDxXaAcCoOrRSs<>~&";

	vi$_lower_chars := "abcdefghijklmnopqrstuvwxyz";
	vi$_upper_chars := "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	vi$_letter_chars := vi$_lower_chars + vi$_upper_chars;
	vi$_numeric_chars := "0123456789";
	vi$_alpha_chars := vi$_letter_chars + "_" + vi$_numeric_chars;
	vi$_sym_chars := vi$_alpha_chars + "$";
	vi$_ctl_chars := "";
	i := 0;
	LOOP
		EXITIF (i = 32);
	   	vi$_ctl_chars := vi$_ctl_chars + ASCII (i);
		i := i + 1;
	ENDLOOP;

	vi$_space_chars := " " + ASCII(9) + vi$_ctl_chars;
	vi$_space_tab := " " + ASCII(9);
	vi$_punct_chars := "!@`~#$%^&*()-=+{}[];:'""\|,.?/><";
	vi$_ex_separs := ", " + ASCII(9);
	vi$_ascii_chars := "";
	vi$_ws := ",./?;:'""\|[]{}-=+)(*&^%$#@!~`" + vi$_space_chars;
	vi$no_space := " " + ASCII(9) + ASCII (10) + ASCII(11) + ASCII(13);
	i := 0;
	LOOP
		EXITIF (i = 256);
		vi$_ascii_chars := vi$_ascii_chars + ASCII (i);
		i := i + 1;
	ENDLOOP;

	vi$pch := ASCII(9);
	i := 32;
	LOOP
		EXITIF (i = 256);
		vi$pch := vi$pch + ASCII (i);
	  	i := i + 1;
	ENDLOOP;

	vi$m_level := 0;
	vi$in_learn := 0;
	vi$playing_back := 0;

	vi$dcl_buf := 0;
	vi$dcl_process := 0;
	vi$send_dcl := 1;

	vi$tag_buf := 0;
	vi$tag_files := "tags";
	vi$tag_case := EXACT;
	vi$in_ws := 0;
	vi$in_global := 0;
	vi$in_occlusion := 0;
	vi$old_occ_win := 0;
	vi$occluding_win := 0;
	vi$error_bells := 1;
	vi$show_mode := 0;
	vi$auto_indent := 0;

	vi$tmp_key_buf := 0;

	vi$last_mess := "";

	vi$max_offset := 0;
	vi$new_offset := 1;

	vi$append_it := 0;
	vi$old_place := 0;
	vi$select_pos := 0;

	vi$term_vt200 := 0;
	vi$scr_width := 0;
	vi$scr_length := 0;

	vi$para_str := "P ";
	vi$para_pat := LINE_BEGIN & ((".P")|LINE_END);
	vi$sect_str := "CHHLPG+c";
	vi$sect_pat := LINE_BEGIN & ((".CH"| ".HL"| ".PG"| "{")|LINE_END);
	vi$last_cmd := 0;
	vi$last_filter := 0;

	vi$replace_separ := 0;
	vi$replace_source := 0;
	vi$replace_dest := 0;

	VI$DELETE_TYPE  := 1;
	VI$CHANGE_TYPE  := 2;
	VI$OTHER_TYPE   := 3;
	VI$YANK_TYPE    := 4;
	VI$FILTER_TYPE  := 5;
	VI$SHIFT_TYPE   := 6;
	vi$command_type := VI$OTHER_TYPE;

	vi$cu_cwd			:= 1;
	vi$cu_trnlnm_job	:= 2;
	vi$cu_trnlnm_proc	:= 3;
	vi$cu_trnlnm_sys	:= 4;
	vi$cu_trnlnm_group	:= 5;
	vi$cu_getmsg		:= 6;
	vi$cu_set_sysdisk	:= 7;
	vi$cu_sleep			:= 8;
	vi$cu_pasthru_on	:= 9;
	vi$cu_pasthru_off	:= 10;
	vi$cu_spawn			:= 11;

	vi$filter_proc := 0;
	vi$filter_buf := 0;

	vi$push_key_buf := 0;

	o1 := 0; o2 := 0; o3 := 0; o4 := 0; o5 := 0;
	o6 := 0; o7 := 0; o8 := 0; o9 := 0;

	p1 := 0; p2 := 0; p3 := 0; p4 := 0; p5 := 0;
	p6 := 0; p7 := 0; p8 := 0; p9 := 0;

	vi$ex_mode_buffer := 0;
	vi$global_var := 0;
	vi$macro_active := "$$active_macro$$";
	vi$_find_pat := 0;
	vi$wrap_scan := 1;

	vi$last_key := 0; 
	vi$last_keys := 0;
	vi$cur_keys := 0;
	vi$key_buf := 0;
	vi$min_update := 1;
	vi$tab_amount := 8;
	vi$shift_width := 8;
	vi$spaces := "                                                    ";
	vi$use_tabs := 1;
	vi$in_show_match := 0;
	vi$report := 5;
	vi$auto_write := 0;
	vi$ignore_case := EXACT;
	vi$wrap_margin := 0;
	vi$magic := 1;
	vi$undo_map := 1;

	vi$undo_line_str := 0;
	vi$undo_line_mark := 0;
	vi$undo_line := 0;
	vi$undo_offset := 0;

	vi$how_much_scroll := 12;

	vi$search_string := 0;
	vi$last_search_dir := 1;

	vi$undo_start := 0;
	vi$undo_end := 0;
	vi$undo_buffer := 0;
	vi$undo_valid := 0;

	VI$HERE := 0;
	VI$AFTER := 1;

	VI$LINE_MODE := 1;
	VI$IN_LINE_MODE := 2;

	vi$cur_level := 0;

	vi$global_mark := 0;
	vi$yank_mode := 0;
	vi$temp_buf := 0;
	vi$cur_text := "";		! Where text to PUT comes from.

	! The ten deletion buffers.

	vi$del_buf_1 := 0; vi$del_buf_2 := 0; vi$del_buf_3 := 0;
	vi$del_buf_4 := 0; vi$del_buf_5 := 0; vi$del_buf_6 := 0;
	vi$del_buf_7 := 0; vi$del_buf_8 := 0; vi$del_buf_9 := 0;

	! Named buffers accessible from the keyboard characters.

	vi$ins_buf_a := 0; vi$ins_buf_b := 0; vi$ins_buf_c := 0;
	vi$ins_buf_d := 0; vi$ins_buf_e := 0; vi$ins_buf_f := 0;
	vi$ins_buf_g := 0; vi$ins_buf_h := 0; vi$ins_buf_i := 0;
	vi$ins_buf_j := 0; vi$ins_buf_k := 0; vi$ins_buf_l := 0;
	vi$ins_buf_m := 0; vi$ins_buf_n := 0; vi$ins_buf_o := 0;
	vi$ins_buf_p := 0; vi$ins_buf_q := 0; vi$ins_buf_r := 0;
	vi$ins_buf_s := 0; vi$ins_buf_t := 0; vi$ins_buf_u := 0;
	vi$ins_buf_v := 0; vi$ins_buf_w := 0; vi$ins_buf_x := 0;
	vi$ins_buf_y := 0; vi$ins_buf_z := 0;

	! The 26 marks available

	vi$mark_a := 0; vi$mark_b := 0; vi$mark_c := 0; vi$mark_d := 0;
	vi$mark_e := 0; vi$mark_f := 0; vi$mark_g := 0; vi$mark_h := 0;
	vi$mark_i := 0; vi$mark_j := 0; vi$mark_k := 0; vi$mark_l := 0;
	vi$mark_m := 0; vi$mark_n := 0; vi$mark_o := 0; vi$mark_p := 0;
	vi$mark_q := 0; vi$mark_r := 0; vi$mark_s := 0; vi$mark_t := 0;
	vi$mark_u := 0; vi$mark_v := 0; vi$mark_w := 0; vi$mark_x := 0;
	vi$mark_y := 0; vi$mark_z := 0;

	vi$endpos := 0;
	vi$new_endpos := 0;
	vi$start_pos := 0;

	VI$ALPHA_TYPE := 1;
	VI$PUNCT_TYPE := 2;
	VI$SPACE_TYPE := 3;
	VI$EOL_TYPE := 4;

	vi$temp_buf_num := 1;
	vi$last_s_func := 0;
	vi$last_s_char := 0;

	vi$active_count := 0;
	vi$cmd_keys := "c_keys";
	vi$move_keys := "m_keys";
	vi$edit_keys := "e_keys";

ENDPROCEDURE;      

!
!	Map all of the key bindings into the proper key maps.
!
!		The "c_keys" map is used for command mode key processing.
!		The "e_keys" map is used during line editing.
!		The "m_keys" map is used to determine movement associated with
!		             a particular key.
!
PROCEDURE vi$init_keys

	! Define all of the command mode keys.

	vi$cmd_keys := CREATE_KEY_MAP ("c_keys");

	DEFINE_KEY ("vi$make_full_screen", KP0, "", vi$cmd_keys);
	DEFINE_KEY ("vi$delete_window", KP1, "", vi$cmd_keys);
	DEFINE_KEY ("vi$split_here", KP2, "", vi$cmd_keys);
	DEFINE_KEY ("vi$next_window", KP3, "", vi$cmd_keys);
	DEFINE_KEY ("vi$shrink_window(vi$cur_active_count)", KP4,
			"", vi$cmd_keys);
	DEFINE_KEY ("vi$enlarge_window(vi$cur_active_count)", KP5,
			"", vi$cmd_keys);
	DEFINE_KEY ("vi$previous_window", KP6, "", vi$cmd_keys);

	DEFINE_KEY ("vi$prev_screen", CTRL_B_KEY, "vi$prev_screen", vi$cmd_keys);
	DEFINE_KEY ("vi$screen_forward", CTRL_D_KEY,
		"vi$screen_forward", vi$cmd_keys);
	DEFINE_KEY ("vi$pull_push_line (1)", CTRL_E_KEY,
		"vi$pull_push_line (1)", vi$cmd_keys);
	DEFINE_KEY ("vi$next_screen", CTRL_F_KEY, "vi$next_screen", vi$cmd_keys);
	DEFINE_KEY ("vi$what_line", CTRL_G_KEY, "vi$what_line", vi$cmd_keys);
	DEFINE_KEY ("vi$move_left", CTRL_H_KEY, "vi$move_left", vi$cmd_keys);
	DEFINE_KEY ("vi$move_down", CTRL_J_KEY, "vi$move_down", vi$cmd_keys);
	DEFINE_KEY ("refresh;vi$pasthru_on", CTRL_L_KEY, "refresh", vi$cmd_keys);
	DEFINE_KEY ("vi$move_down", CTRL_N_KEY, "vi$move_down", vi$cmd_keys);
	DEFINE_KEY ("vi$move_up", CTRL_P_KEY, "vi$move_up", vi$cmd_keys);
	DEFINE_KEY ("vi$remember", CTRL_R_KEY, "vi$remember", vi$cmd_keys);
	DEFINE_KEY ("vi$screen_backward", CTRL_U_KEY,
		"vi$screen_backward", vi$cmd_keys);
	DEFINE_KEY ("vi$send_to_dcl (CURRENT_LINE)", CTRL_X_KEY,
		"vi$send_to_dcl (CURRENT_LINE)", vi$cmd_keys);
	DEFINE_KEY ("vi$pull_push_line (-1)", CTRL_Y_KEY,
		"vi$pull_push_line (-1)", vi$cmd_keys);
	DEFINE_KEY ("vi$to_tag(0, 0)", KEY_NAME(ASCII(29)),
		"vi$to_tag(0, 0)", vi$cmd_keys);
	DEFINE_KEY ("vi$move_prev_buf (0)", KEY_NAME(ASCII(30)),
		"vi$move_prev_buf (0)", vi$cmd_keys);
	DEFINE_KEY ("vi$do_help('')", PF2, "vi$do_help('')", vi$cmd_keys);
	DEFINE_KEY ("vi$on_escape", PF1, "vi$on_escape", vi$cmd_keys);
	DEFINE_KEY ("vi$on_escape", F11, "vi$on_escape", vi$cmd_keys);
	DEFINE_KEY ("vi$_go_to_marker", KEY_NAME ("'"),
		"vi$_go_to_marker", vi$cmd_keys);
	DEFINE_KEY ("vi$_go_to_marker", KEY_NAME ("`"),
		"vi$_go_to_marker", vi$cmd_keys);
	DEFINE_KEY ("vi$select_buffer", KEY_NAME ('"'),
		"vi$select_buffer", vi$cmd_keys);
	DEFINE_KEY ("vi$_match_brackets", KEY_NAME ('%'),
		"vi$_match_brackets", vi$cmd_keys);
	DEFINE_KEY ("vi$_change_case", KEY_NAME ('~'),
		"vi$_change_case", vi$cmd_keys);
	DEFINE_KEY ("vi$region_left", KEY_NAME ('<'),
		"vi$region_left", vi$cmd_keys);
	DEFINE_KEY ("vi$region_right", KEY_NAME ('>'),
		"vi$region_right", vi$cmd_keys);
	DEFINE_KEY ("vi$_next_line", KEY_NAME ('+'), "vi$_next_line", vi$cmd_keys);
	DEFINE_KEY ("vi$do_macro('k^', 0)", KEY_NAME ('-'),
		"vi$do_macro('k^', 0)", vi$cmd_keys);
	DEFINE_KEY ("vi$_paragraph (-1)", KEY_NAME ('{'),
		"vi$_paragraph (-1)", vi$cmd_keys);
	DEFINE_KEY ("vi$_section (-1)", KEY_NAME ('['),
		"vi$_section (-1)", vi$cmd_keys);
	DEFINE_KEY ("vi$_begin_sentence", KEY_NAME ('('),
		"vi$_begin_sentence", vi$cmd_keys);
	DEFINE_KEY ("vi$_paragraph (1)", KEY_NAME ('}'),
		"vi$_paragraph (1)", vi$cmd_keys);
	DEFINE_KEY ("vi$_section (1)", KEY_NAME (']'),
		"vi$_section (1)", vi$cmd_keys);
	DEFINE_KEY ("vi$_end_sentence", KEY_NAME (')'),
		"vi$_end_sentence", vi$cmd_keys);
	DEFINE_KEY ("vi$insert_after", KEY_NAME ('a'),
		"vi$insert_after", vi$cmd_keys);
	DEFINE_KEY ("vi$do_macro('$a', 0)", KEY_NAME ('A'),
		"vi$do_macro('$a', 0)", vi$cmd_keys);
	DEFINE_KEY ("vi$_word_back", KEY_NAME ('b'),
		"vi$_word_back", vi$cmd_keys);
	DEFINE_KEY ("vi$_full_word_back", KEY_NAME ('B'),
		"vi$_full_word_back", vi$cmd_keys);
	DEFINE_KEY ("vi$_change", KEY_NAME ('c'),
		"vi$_change", vi$cmd_keys);
	DEFINE_KEY ("vi$do_macro ('c$', 0)", KEY_NAME ('C'),
		"vi$do_macro ('c$', 0)", vi$cmd_keys);
	DEFINE_KEY ("vi$_delete (0, -1)", KEY_NAME ('d'),
		"delete", vi$cmd_keys);
	DEFINE_KEY ("vi$_delete (KEY_NAME('$'), -1)", KEY_NAME ('D'),
		"delete_eol", vi$cmd_keys);
	DEFINE_KEY ("vi$_word_end", KEY_NAME ('e'),
		"vi$_word_end", vi$cmd_keys);
	DEFINE_KEY ("vi$_full_word_end", KEY_NAME ('E'),
		"vi$_full_word_end", vi$cmd_keys);
	DEFINE_KEY ("vi$_find_char (0)", KEY_NAME ('f'),
		"vi$_find_char (0)", vi$cmd_keys);
	DEFINE_KEY ("vi$_back_find_char (0)", KEY_NAME ('F'),
		"vi$_back_find_char (0)", vi$cmd_keys);
	DEFINE_KEY ("vi$go_to_line", KEY_NAME ('G'),
		"vi$go_to_line", vi$cmd_keys);
	DEFINE_KEY ("vi$move_left", KEY_NAME ('h'),
		"vi$move_left", vi$cmd_keys);
	DEFINE_KEY ("vi$home", KEY_NAME ('H'), "vi$home", vi$cmd_keys);
	DEFINE_KEY ("vi$insert_here", KEY_NAME ('i'),
		"vi$insert_here", vi$cmd_keys);
	DEFINE_KEY ("vi$insert_at_begin", KEY_NAME ('I'),
		"vi$insert_at_begin", vi$cmd_keys);                     
	DEFINE_KEY ("vi$move_down", KEY_NAME ('j'),
		"vi$move_down", vi$cmd_keys);
	DEFINE_KEY ("vi$_join_lines", KEY_NAME ('J'),
		"vi$_join_lines", vi$cmd_keys);
	DEFINE_KEY ("vi$move_up", KEY_NAME ('k'), "vi$move_up", vi$cmd_keys);
	DEFINE_KEY ("vi$move_right", KEY_NAME ('l'), "vi$move_right", vi$cmd_keys);
	DEFINE_KEY ("vi$last", KEY_NAME ('L'), "vi$last", vi$cmd_keys);
	DEFINE_KEY ("vi$_set_mark", KEY_NAME ('m'), "vi$_set_mark", vi$cmd_keys);
	DEFINE_KEY ("vi$middle", KEY_NAME ('M'), "vi$middle", vi$cmd_keys);
	DEFINE_KEY ("vi$_search_next(vi$last_search_dir)", KEY_NAME('n'),
		"vi$_search_next(vi$last_search_dir)", vi$cmd_keys);
	DEFINE_KEY ("vi$_search_next(-vi$last_search_dir)", KEY_NAME('N'),
		"vi$_search_next(-vi$last_search_dir)", vi$cmd_keys);
	DEFINE_KEY ("vi$open_below", KEY_NAME ('o'), "vi$open_below", vi$cmd_keys);
	DEFINE_KEY ("vi$open_here", KEY_NAME ('O'), "vi$open_here", vi$cmd_keys);
	DEFINE_KEY ("vi$put_here (VI$HERE, -1)", KEY_NAME ('P'),
		"vi$put_here (VI$HERE, -1)", vi$cmd_keys);
	DEFINE_KEY ("vi$put_after (-1)", KEY_NAME ('p'),
		"vi$put_after (-1)", vi$cmd_keys);
	DEFINE_KEY ("vi$_replace_char", KEY_NAME ('r'),
		"vi$_replace_char", vi$cmd_keys);
	DEFINE_KEY ("vi$_replace_str", KEY_NAME ('R'),
		"vi$_replace_str", vi$cmd_keys);
	DEFINE_KEY ("vi$do_macro('cl', 0)", KEY_NAME ('s'),
		"vi$do_macro('cl', 0)", vi$cmd_keys);
	DEFINE_KEY ("vi$_big_s", KEY_NAME ('S'), "vi$_big_s", vi$cmd_keys);
	DEFINE_KEY ("vi$_to_char (0)", KEY_NAME ('t'),
		"vi$_to_char (0)", vi$cmd_keys);
	DEFINE_KEY ("vi$_back_to_char (0)", KEY_NAME ('T'),
		"vi$_back_to_char (0)", vi$cmd_keys);
	DEFINE_KEY ("vi$perform_undo", KEY_NAME ('u'),
		"vi$perform_undo", vi$cmd_keys);
	DEFINE_KEY ("vi$undo_one_line", KEY_NAME ('U'),
		"vi$undo_one_line", vi$cmd_keys);
	DEFINE_KEY ("vi$_word_forward", KEY_NAME ('w'),
		"vi$_word_forward", vi$cmd_keys);
	DEFINE_KEY ("vi$_full_word_forward", KEY_NAME ('W'),
		"vi$_full_word_forward", vi$cmd_keys);
	DEFINE_KEY ("vi$do_macro ('dl', 0)", KEY_NAME ('x'),
		"vi$do_macro ('dl', 0)", vi$cmd_keys);
	DEFINE_KEY ("vi$do_macro ('dh', 0)", KEY_NAME ('X'),
		"vi$do_macro ('dh', 0)", vi$cmd_keys);
	DEFINE_KEY ("vi$_yank (0, -1)", KEY_NAME ('y'),
		"vi$_yank (0, -1)", vi$cmd_keys);
	DEFINE_KEY ("vi$_yank (KEY_NAME('y'), -1)", KEY_NAME ('Y'),
		"vi$_yank (KEY_NAME('y'), -1)", vi$cmd_keys);
	DEFINE_KEY ("vi$_ZZ (0)", KEY_NAME ('Z'), "vi$_ZZ", vi$cmd_keys);
	DEFINE_KEY ("vi$_z_move", KEY_NAME ('z'), "vi$_z_move", vi$cmd_keys);
	DEFINE_KEY ("vi$_to_column", KEY_NAME ('|'),
		"vi$_to_column", vi$cmd_keys);
	DEFINE_KEY ("vi$_next_line", RET_KEY, "vi$_next_line", vi$cmd_keys);
	DEFINE_KEY ("vi$repeat_count", KEY_NAME ('0'),
		"vi$repeat_count", vi$cmd_keys);
	DEFINE_KEY ("vi$repeat_count", KEY_NAME ('1'),
		"vi$repeat_count", vi$cmd_keys);
	DEFINE_KEY ("vi$repeat_count", KEY_NAME ('2'),
		"vi$repeat_count", vi$cmd_keys);
	DEFINE_KEY ("vi$repeat_count", KEY_NAME ('3'),
		"vi$repeat_count", vi$cmd_keys);
	DEFINE_KEY ("vi$repeat_count", KEY_NAME ('4'),
		"vi$repeat_count", vi$cmd_keys);
	DEFINE_KEY ("vi$repeat_count", KEY_NAME ('5'),
		"vi$repeat_count", vi$cmd_keys);
	DEFINE_KEY ("vi$repeat_count", KEY_NAME ('6'),
		"vi$repeat_count", vi$cmd_keys);
	DEFINE_KEY ("vi$repeat_count", KEY_NAME ('7'),
		"vi$repeat_count", vi$cmd_keys);
	DEFINE_KEY ("vi$repeat_count", KEY_NAME ('8'),
		"vi$repeat_count", vi$cmd_keys);
	DEFINE_KEY ("vi$repeat_count", KEY_NAME ('9'),
		"vi$repeat_count", vi$cmd_keys);
	DEFINE_KEY ("vi$move_left", F12, "vi$move_left", vi$cmd_keys);
	DEFINE_KEY ("vi$move_left", LEFT, "vi$move_left", vi$cmd_keys);
	DEFINE_KEY ("vi$move_right", RIGHT, "vi$move_right", vi$cmd_keys);
	DEFINE_KEY ("vi$move_up", UP, "vi$move_up", vi$cmd_keys);
	DEFINE_KEY ("vi$move_down", DOWN, "vi$move_down", vi$cmd_keys);
	DEFINE_KEY ("vi$move_left", DEL_KEY, "vi$move_left", vi$cmd_keys);
	DEFINE_KEY ("vi$move_right", KEY_NAME (' '), "vi$move_right", vi$cmd_keys);
	DEFINE_KEY ("vi$ex_mode", DO, "vi$ex_mode", vi$cmd_keys);
	DEFINE_KEY ("vi$ex_mode", KEY_NAME(':'), "vi$ex_mode", vi$cmd_keys);
	DEFINE_KEY ("vi$_repeat_torf_back", KEY_NAME(','),
		"vi$_repeat_torf_back", vi$cmd_keys);
	DEFINE_KEY ("vi$_repeat_torf", KEY_NAME(';'),
		"vi$_repeat_torf", vi$cmd_keys);
	DEFINE_KEY ("vi$_search(1)", KEY_NAME('/'),
		"vi$_search(1)", vi$cmd_keys);
	DEFINE_KEY ("vi$_search(-1)", KEY_NAME('?'),
		"vi$_search(-1)", vi$cmd_keys);
	DEFINE_KEY ("vi$_eol", KEY_NAME('$'), "vi$_eol", vi$cmd_keys);
	DEFINE_KEY ("vi$_bol (1)", KEY_NAME('^'), "vi$_bol (1)", vi$cmd_keys);
	DEFINE_KEY ("vi$do_macro(vi$last_keys, 0)", KEY_NAME('.'),
		"vi$do_macro(vi$last_keys, 0)", vi$cmd_keys);
	DEFINE_KEY ("vi$macro", KEY_NAME('@'), "vi$macro", vi$cmd_keys);
	DEFINE_KEY ("vi$repeat_subs", KEY_NAME('&'), "vi$repeat_subs", vi$cmd_keys);
	DEFINE_KEY ("vi$region_filter", KEY_NAME('!'),
		"vi$region_filter", vi$cmd_keys);

	! Define all of the insert-mode keys

	vi$edit_keys := CREATE_KEY_MAP ("e_keys");

	! These maps are not really active, but the comment fields are used
	! during the execution of "vi$line_edit".

	DEFINE_KEY ("vi$_dummy", F12, "bs", vi$edit_keys);
	DEFINE_KEY ("vi$_dummy", PF1, "escape", vi$edit_keys);
	DEFINE_KEY ("vi$_dummy", F11, "escape", vi$edit_keys);
	DEFINE_KEY ("vi$_dummy", KEY_NAME (ASCII(27)), "escape", vi$edit_keys);
	DEFINE_KEY ("vi$_dummy", KEY_NAME (ASCII(0)), "reinsert", vi$edit_keys);
	DEFINE_KEY ("vi$_dummy", RET_KEY, "eol", vi$edit_keys);
	DEFINE_KEY ("vi$_dummy", TAB_KEY, "tab", vi$edit_keys);
	DEFINE_KEY ("vi$_dummy", CTRL_D_KEY, "detab", vi$edit_keys);
	DEFINE_KEY ("vi$_dummy", CTRL_H_KEY, "bs", vi$edit_keys);
	DEFINE_KEY ("vi$_dummy", CTRL_T_KEY, "entab", vi$edit_keys);
	DEFINE_KEY ("vi$_dummy", CTRL_V_KEY, "vquote", vi$edit_keys);
	DEFINE_KEY ("vi$_dummy", CTRL_W_KEY, "bword", vi$edit_keys);
	DEFINE_KEY ("vi$_dummy", DEL_KEY, "bs", vi$edit_keys);

	! Define all of the delete mode mappings

	vi$move_keys := CREATE_KEY_MAP ("m_keys");

	DEFINE_KEY ("vi$downline(1)", RET_KEY, "vi$downline(1)", vi$move_keys);
	DEFINE_KEY ("vi$right", KEY_NAME (" "), "vi$right", vi$move_keys);
	DEFINE_KEY ("vi$eol", KEY_NAME("$"), "vi$eol", vi$move_keys);
	DEFINE_KEY ("vi$to_marker", KEY_NAME ("'"), "vi$to_marker", vi$move_keys);
	DEFINE_KEY ("vi$to_marker", KEY_NAME ("`"), "vi$to_marker", vi$move_keys);
	DEFINE_KEY ("vi$first_no_space (1)", KEY_NAME("^"),
		"vi$first_no_space (1)", vi$move_keys);
	DEFINE_KEY ("vi$fol", KEY_NAME("0"), "vi$fol", vi$move_keys);
	DEFINE_KEY ("vi$upline", KEY_NAME ("-"), "vi$upline", vi$move_keys);
	DEFINE_KEY ("vi$downline(1)", KEY_NAME ("+"),
		"vi$downline(1)", vi$move_keys);
	DEFINE_KEY ("vi$search(1)", KEY_NAME ("/"), "vi$search(1)", vi$move_keys);
	DEFINE_KEY ("vi$search(-1)", KEY_NAME ("?"), "vi$search(-1)", vi$move_keys);
	DEFINE_KEY ("vi$match_brackets", KEY_NAME ("%"),
		"vi$match_brackets", vi$move_keys);
	DEFINE_KEY ("vi$full_word_move(-1)", KEY_NAME ("B"),
		"vi$full_word_move(-1)", vi$move_keys);
	DEFINE_KEY ("vi$word_move(-1)", KEY_NAME ("b"),
		"vi$word_move(-1)", vi$move_keys);
	DEFINE_KEY ("vi$_dummy", KEY_NAME ("c"),
		"vi$_dummy", vi$move_keys);
	DEFINE_KEY ("vi$word_end", KEY_NAME ("e"), "vi$word_end", vi$move_keys);
	DEFINE_KEY ("vi$full_word_end", KEY_NAME ("E"),
		"vi$full_word_end", vi$move_keys);
	DEFINE_KEY ("vi$back_find_char(0)", KEY_NAME ("F"),
		"vi$back_find_char(0)", vi$move_keys);
	DEFINE_KEY ("vi$find_char(0)", KEY_NAME ("f"),
		"vi$find_char(0)", vi$move_keys);
	DEFINE_KEY ("vi$to_line (vi$active_count)", KEY_NAME ("G"),
			"vi$to_line (vi$active_count)", vi$move_keys);
	DEFINE_KEY ("vi$to_home", KEY_NAME ("H"), "vi$to_home", vi$move_keys);
	DEFINE_KEY ("vi$left", KEY_NAME ("h"), "vi$left", vi$move_keys);
	DEFINE_KEY ("vi$downline(1)", KEY_NAME ("j"),
		"vi$downline(1)", vi$move_keys);
	DEFINE_KEY ("vi$upline", KEY_NAME ("k"), "vi$upline", vi$move_keys);
	DEFINE_KEY ("vi$right", KEY_NAME ("l"), "vi$right", vi$move_keys);
	DEFINE_KEY ("vi$to_middle", KEY_NAME ("M"), "vi$to_middle", vi$move_keys);
	DEFINE_KEY ("vi$to_last", KEY_NAME ("L"), "vi$to_last", vi$move_keys);
	DEFINE_KEY ("vi$search_next(vi$last_search_dir)", KEY_NAME('n'),
			"vi$search_next(vi$last_search_dir)", vi$move_keys);
	DEFINE_KEY ("vi$search_next(-vi$last_search_dir)", KEY_NAME('N'),
			"vi$search_next(-vi$last_search_dir)", vi$move_keys);
	DEFINE_KEY ("vi$to_char(0)", KEY_NAME ("t"), "vi$to_char(0)", vi$move_keys);
	DEFINE_KEY ("vi$back_to_char(0)", KEY_NAME ("T"),
		"vi$back_to_char(0)", vi$move_keys);
	DEFINE_KEY ("vi$word_move(1)", KEY_NAME ("w"),
		"vi$word_move(1)", vi$move_keys);
	DEFINE_KEY ("vi$full_word_move(1)", KEY_NAME ("W"),
		"vi$full_word_move(1)", vi$move_keys);
	DEFINE_KEY ("vi$downline", KEY_NAME(">"), "vi$downline(0)", vi$move_keys);
	DEFINE_KEY ("vi$downline", KEY_NAME("<"), "vi$downline(0)", vi$move_keys);
	DEFINE_KEY ("vi$downline(0)", KEY_NAME("d"),
		"vi$downline(0)", vi$move_keys);
	DEFINE_KEY ("vi$downline(0)", KEY_NAME("y"),
		"vi$downline(0)", vi$move_keys);
	DEFINE_KEY ("vi$downline(0)", KEY_NAME("!"),
		"vi$downline(0)", vi$move_keys);
	DEFINE_KEY ("vi$to_column", KEY_NAME ('|'), "vi$to_column", vi$move_keys);
	DEFINE_KEY ("vi$repeat_torf", KEY_NAME(';'),
		"vi$repeat_torf", vi$move_keys);
	DEFINE_KEY ("vi$repeat_torf_back", KEY_NAME(','),
		"vi$repeat_torf_back", vi$move_keys);
	DEFINE_KEY ("vi$paragraph (1)", KEY_NAME ('}'),
		"vi$paragraph (1)", vi$move_keys);
	DEFINE_KEY ("vi$section (1)", KEY_NAME (']'),
		"vi$section (1)", vi$move_keys);
	DEFINE_KEY ("vi$end_sentence", KEY_NAME (')'),
		"vi$end_sentence", vi$move_keys);
	DEFINE_KEY ("vi$paragraph (-1)", KEY_NAME ('{'),
		"vi$paragraph (-1)", vi$move_keys);
	DEFINE_KEY ("vi$section (-1)", KEY_NAME ('['),
		"vi$section (-1)", vi$move_keys);
	DEFINE_KEY ("vi$begin_sentence", KEY_NAME ('('),
		"vi$begin_sentence", vi$move_keys);

ENDPROCEDURE;

!
!	This procedure is called by the CTRL-` keystroke to swap the current
!	buffer with the previous one.
!
PROCEDURE vi$move_prev_buf (bang)
	LOCAL
		outf,
	   	buf;

	IF (vi$last_mapped = 0) OR
							(GET_INFO (vi$last_mapped, "TYPE") <> BUFFER) THEN
		vi$info ("No alternate buffer!");
		RETURN;
	ENDIF;
	buf := vi$last_mapped;
	IF (NOT bang) AND (vi$check_auto_write) THEN
		RETURN;
	ENDIF;
	MAP (CURRENT_WINDOW, buf);
	vi$set_status_line (CURRENT_WINDOW);
	vi$pos_in_middle (MARK (NONE));
	outf := GET_INFO (CURRENT_BUFFER, "OUTPUT_FILE");
	IF outf = 0 THEN
		outf := GET_INFO (CURRENT_BUFFER, "NAME");
	ENDIF;
	vi$info ('"'+outf+'"');
ENDPROCEDURE;

!
!	This procedure is used to return the current mark in the buffer, after
!	moving to the mark passed.  This routine is used by the majority of the
!	procedures that perform movement, and then return the location they
!	stopped at, but do not change the current location in the buffer.
!
PROCEDURE vi$retpos (pos)
	LOCAL
		endpos;

	ON_ERROR
	ENDON_ERROR

	endpos := MARK (NONE);

	! If the marker is zero, then there is no way to position to it.

	IF (pos <> 0) THEN
		POSITION (pos);
	ENDIF;
	RETURN (endpos);
ENDPROCEDURE;

!
!	This procedure is called whenever ESCAPE is pressed while in command mode.
!	The current active count should be zeroed, and possibly other things.
!
PROCEDURE vi$on_escape
	vi$active_count := 0;
	vi$beep;
ENDPROCEDURE;

!
!
!
!
PROCEDURE vi$do_help (init_command)
	LOCAL
		buf,
		win;

	buf := CURRENT_BUFFER;
	MAP (info_window, show_buffer);
	vi$pasthru_off;
	HELP_TEXT ("vi$root:[doc]vi.hlb","VI " + init_command,ON,show_buffer);
	vi$pasthru_on;
	UNMAP (info_window);
	POSITION (buf);
ENDPROCEDURE;

!
!	This is the main processing loop, this function should never be exited.
!	This means that the TPU "ABORT" builtin can not be used anywhere.
!
PROCEDURE vi$command_mode (l_key)
	LOCAL
		key,
		last_len,
		win,
		cwin,
		bol,
		pos,
		repos,
		prog;

	IF (NOT vi$min_update) THEN
		UPDATE (CURRENT_WINDOW);
	ENDIF;

	! Get the key to process (last key pressed).

	key := l_key;

	! Save the key for '.' repeats.

	vi$push_a_key (key);

	! Save the key so that vi$last_key behaves as LAST_KEY would.

	vi$last_key := key;

	! Initialize macro level counter.

	vi$m_level := 0;

	! Set up so that 'U' works.  Note that there is a problem with U after u
	! when a :s or & was the last thing done.  The vi$undo_line mark is moved
	! from the beginning of the line to the end of the line by the undo code.
	! The fix is not obvious at this point.

	pos := MARK (NONE);
	POSITION (LINE_BEGIN);
	bol := MARK (NONE);
	repos := 0;
	IF (GET_INFO (vi$undo_line_mark, "TYPE") = MARKER) THEN
		POSITION (vi$undo_line_mark);
		POSITION (LINE_BEGIN);
		IF (bol <> MARK (NONE)) THEN
			repos := 1;
		ENDIF;
	ELSE
		repos := 1;
	ENDIF;

	IF (repos) THEN
		POSITION (bol);
		vi$move_horizontal (1);
		vi$undo_line_mark := MARK (NONE);
		vi$undo_line_str  := vi$current_line;
	ENDIF;
	POSITION (pos);

	! Get the key's program.

	prog := LOOKUP_KEY (KEY_NAME (key), PROGRAM, vi$cmd_keys);

	! If prog = 0 then key is undefined, so ignore it.

	IF (prog <> 0) THEN

		IF (vi$did_mess) THEN
			vi$did_mess := 0;
			MESSAGE ("");
		ENDIF;

		vi$command_type := VI$OTHER_TYPE;

		! Otherwise, do the program for that key.

		EXECUTE (prog);

		! If this is a key that can change the buffer, then
		! save the sequence of keys so that '.' causes them to
		! be repeated.

		IF (INDEX (vi$dot_keys, ASCII (key)) <> 0) THEN
			vi$copy_keys (vi$last_keys, vi$cur_keys);
		ENDIF;
	ELSE

		! Zap the repeat count so that next command doesn't repeat.

		vi$active_count := 0;
		vi$beep;
	ENDIF;

	! Make sure we are not past end of line or at EOB.

	vi$check_rmarg;

	IF (INDEX ("0123456789", ASCII (key)) = 0) OR (vi$active_count = 0) THEN
		ERASE (vi$cur_keys);
	ENDIF;
ENDPROCEDURE;

!
!	Perform a macro command string that is either a string, or a buffer
!	containing KEY_NAME values (as in execution of the '.' command).
!       
PROCEDURE vi$do_macro (commands, save_buffer)
	LOCAL
		typ,
		old_global,
		pos,
		key,
		prog;

	IF (vi$m_level > 30) THEN
		vi$info ("Infinite loop detected in key macro sequence!");
		RETURN;
	ENDIF;
	vi$m_level := vi$m_level + 1;
	vi$new_offset := 1;

	pos := MARK (NONE);

	! If "commands" is a string then we must generate a buffer to
	! place the commands into so that they can be read with "vi$read_a_key".

	IF (GET_INFO (commands, "TYPE") = STRING) THEN
		IF (vi$tmp_key_buf = 0) THEN
			vi$tmp_key_buf := vi$init_buffer ("$$tmp_key_buf$$", "");
		ELSE
			ERASE (vi$tmp_key_buf);
		ENDIF;

		IF vi$tmp_key_buf = 0 THEN
			vi$info ("Can't do key macro: "+commands);
			RETURN;
		ENDIF;

		vi$str_to_keybuf (commands, vi$tmp_key_buf);
		vi$insert_macro_keys (vi$tmp_key_buf);
	ELSE
		vi$insert_macro_keys (commands);
	ENDIF;

	POSITION (pos);

	IF vi$undo_map THEN
		old_global := vi$in_global;
		IF (save_buffer AND (NOT old_global)) THEN
			vi$save_for_undo (CURRENT_BUFFER, VI$LINE_MODE, 1);
			vi$in_global := 1;
		ENDIF;
	ENDIF;

	LOOP

		! Stop when all levels of macro are completed.

		EXITIF (vi$key_buf = 0);
		key := vi$read_a_key;

		! Get that keys program.

		prog := LOOKUP_KEY (key, PROGRAM, vi$cmd_keys);

		! If prog = 0 then key is undefined, so ignore it.

		IF (prog <> 0) THEN

			! Otherwise, do the program for that key.

			EXECUTE (prog);
		ELSE
			vi$info ("Key '"+ASCII(key)+"' is undefined!");
			vi$abort (0);
		ENDIF;
	ENDLOOP;

	IF (vi$in_global) THEN
		vi$undo_start := BEGINNING_OF (CURRENT_BUFFER);
		vi$undo_end := END_OF (CURRENT_BUFFER);
		vi$in_global := old_global;
	ENDIF;
ENDPROCEDURE;

!
!	This function handles the macro capability that allows the text in
!	a named or numbered buffer to be executed as a sequence of commands
!	by type an '@' and then the letter or number indicating the buffer to
!	execute the contents of.
!
PROCEDURE vi$macro
	LOCAL
		line,
		buf_name,
		bpos,
		cnt,
		ccnt,
		pos,
		buf,
		mode,
		ch;

	IF (vi$m_level > 30) THEN
		vi$info ("Infinite loop detected in macro key sequence!");
		RETURN;
	ENDIF;
	vi$m_level := vi$m_level + 1;

	ch := vi$read_a_key;

	IF (INDEX ("123456789", ASCII(ch)) <> 0) THEN

		! Selected a deletion buffer.

		buf_name := "vi$del_buf_"+ASCII(ch);
	ELSE
		IF (INDEX (vi$_letter_chars, ASCII(ch)) <> 0) THEN

			! Selected a named buffer.

			IF (INDEX (vi$_upper_chars, ASCII(ch)) <> 0) THEN
				ch := SUBSTR (vi$_lower_chars,
							INDEX (vi$_upper_chars, ASCII(ch)), 1);
			ENDIF;

			buf_name := "vi$ins_buf_"+ASCII(ch);
		ELSE
			vi$info ("Invalid buffer!");
			RETURN;
		ENDIF;
	ENDIF;

	vi$global_var := 0;
	EXECUTE (COMPILE ("vi$global_var := "+buf_name+";"));
	buf := vi$global_var;
	IF (buf = 0) THEN
		vi$info ("There is no text in that buffer!");
		RETURN;
	ENDIF;

	pos := MARK (NONE);
	POSITION (BEGINNING_OF (buf));

	!  Get and skip the buffer mode indicator.

	mode := INT (vi$current_line);
	MOVE_VERTICAL (1);

	! Get the number of lines to do.

	cnt := GET_INFO (CURRENT_BUFFER, "RECORD_COUNT") - 2;
	ccnt := 0;

	LOOP
		line := vi$current_line;

		IF (ccnt = cnt) THEN
		   	IF mode = VI$LINE_MODE THEN
				line := line + ASCII (13);
			ENDIF;
		ELSE
			line := line + ASCII (13);
		ENDIF;

		ccnt := ccnt + 1;
		bpos := MARK (NONE);
		POSITION (pos);
		vi$do_macro (line, 1);

		EXITIF (ccnt = cnt);

		pos := MARK (NONE);
		POSITION (bpos);
		MOVE_VERTICAL (1);
	ENDLOOP;
ENDPROCEDURE;

!
!	This procedure handles the operation of the U command.  U undoes all
!	changes performed on a line, providing the cursor has not left that
!	line.
!
PROCEDURE vi$undo_one_line
	LOCAL
		nstr,
		npos,
		repos,
		pos;

	pos := MARK (NONE);
	POSITION (LINE_BEGIN);
	npos := MARK (NONE);
	repos := 1;
	IF (GET_INFO (vi$undo_line_mark, "TYPE") = MARKER) THEN
		POSITION (vi$undo_line_mark);
		POSITION (LINE_BEGIN);
		IF (npos <> MARK (NONE)) THEN
			repos := 0;
		ENDIF;
	ELSE
		repos := 0;
	ENDIF;

	IF (repos) THEN
		nstr := vi$current_line;
		ERASE_LINE;
		COPY_TEXT (vi$undo_line_str);
		SPLIT_LINE;
		MOVE_VERTICAL (-1);
		vi$kill_undo;
		vi$undo_end := 0;
		vi$undo_line_str := nstr;
		vi$undo_line_mark := MARK (NONE);
	ELSE
		vi$undo_line_mark := 0;
	ENDIF;
ENDPROCEDURE;

!
!	This procedure takes a range or string of data, and squirrels it away
!	to be restored when an undo operation is performed.
!
PROCEDURE vi$save_for_undo (undo_data, btype, save_line_info)
	LOCAL
		pos;

	pos := MARK (NONE);

	IF (vi$in_global) THEN
		RETURN;
	ENDIF;

	IF (save_line_info) THEN
		vi$undo_line := vi$cur_line_no;
		vi$undo_offset := CURRENT_OFFSET;
	ELSE
		vi$undo_line := 0;
	ENDIF;

	IF vi$undo_buffer = 0 THEN
		vi$undo_buffer := vi$init_buffer ("$$vi$undo_buffer$$", "");
		IF vi$undo_buffer = 0 THEN
			vi$info ("Error creating undo buffer!");
			RETURN;
		ENDIF;
	ENDIF;

	vi$type2buf (STR (btype), vi$undo_buffer);
	vi$cp2buf (undo_data, vi$undo_buffer);

	vi$undo_valid := 1;

	POSITION (pos);
ENDPROCEDURE;

!
!	Disallow the data last saved with vi$save_for_undo() from being restored
!	during an undo operation.
!
PROCEDURE vi$kill_undo
	IF (NOT vi$in_global) THEN
		vi$undo_valid := 0;
		vi$undo_line := 0;
	ENDIF;
ENDPROCEDURE;

!
!	Perform the operation of undoing the last change.  This operation is
!	actually comprised of 3 separate operations.  The first operation is
!	to restore any text saved by vi$save_for_undo().  The next operation is
!	to vi$save_for_undo() any text delimited by vi$undo_start and vi$undo_end.
!	vi$undo_start marks the location where step 1 is performed.  vi$undo_end
!	determines whether or not there is text to save and then delete.  If
!	it has a non-zero value, then the range delimited by it and vi$undo_start
!	is saved (using vi$save_for_undo()), and then deleted.
!
PROCEDURE vi$perform_undo
	LOCAL
		done_pos,
		cbuf,
		pos,
		undo_line,
		undo_offset,
		cline,
		coff,
		btype,
		errno,
		undo_mode,
		saved_text,
		new_start,
		new_end,
		era_range;

	vi$new_offset := 1;
	new_start := 0;
	cline := vi$cur_line_no;
	coff := CURRENT_OFFSET;
	undo_line := vi$undo_line;
	undo_offset := vi$undo_offset;

	IF (GET_INFO (vi$undo_start, "BUFFER") <> CURRENT_BUFFER) OR
			((NOT vi$undo_valid) AND (vi$undo_end = 0)) THEN
		vi$beep;
		RETURN;
	ENDIF;

	IF (vi$undo_valid) THEN
		cbuf := CURRENT_BUFFER;

		POSITION (BEGINNING_OF (vi$undo_buffer));
		undo_mode := INT (vi$current_line);
		ERASE_LINE;

		POSITION (vi$undo_start);

		IF MARK (NONE) = BEGINNING_OF (CURRENT_BUFFER) THEN
			new_start := 1;
		ELSE
			MOVE_HORIZONTAL (-1);
			new_start := MARK (NONE);
			MOVE_HORIZONTAL (1);
		ENDIF;

		SET (INSERT, CURRENT_BUFFER);
		COPY_TEXT (vi$undo_buffer);

		APPEND_LINE;
		MOVE_HORIZONTAL (-1);
		new_end := MARK (NONE);

		POSITION (BEGINNING_OF (vi$undo_buffer));
		COPY_TEXT (STR (undo_mode));
		SPLIT_LINE;

		POSITION (new_end);
	ENDIF;

	! Use flag to determine whether or not to kill buffer contents.

	saved_text := 0;

	IF (vi$undo_start <> 0) AND (vi$undo_end <> 0) THEN
		saved_text := 1;
		pos := MARK (NONE);

		POSITION (vi$undo_end);
		IF (CURRENT_OFFSET <> 0) THEN
			btype := VI$IN_LINE_MODE;
		ELSE
			btype := VI$LINE_MODE;
		ENDIF;

		POSITION (pos);

		era_range := CREATE_RANGE (vi$undo_start, vi$undo_end, NONE);

		IF era_range <> 0 THEN
			POSITION (vi$undo_start);
			vi$save_for_undo (era_range, btype, 1);
			ERASE (era_range);
		ENDIF;
	ENDIF;

	IF (GET_INFO (new_start, "TYPE") <> INTEGER) THEN
		POSITION (new_start);
		vi$move_horizontal (1);
		vi$undo_start := MARK (NONE);
		vi$undo_end := new_end;
	ELSE
		IF new_start = 1 THEN
			vi$undo_start := BEGINNING_OF (CURRENT_BUFFER);
			vi$undo_end := new_end;
		ELSE
			vi$undo_end := 0;
		ENDIF;
	ENDIF;

	IF (saved_text = 0) THEN
		vi$kill_undo;
	ENDIF;

	IF (vi$undo_start <> 0) THEN
		POSITION (vi$undo_start);
	ENDIF;

	! If undoing a macro then reposition to the place where we started.

	IF (undo_line <> 0) THEN
		vi$move_to_line (undo_line);
		vi$move_horizontal (undo_offset);
		vi$pos_in_middle (MARK (NONE));
		vi$undo_line := undo_line;
		vi$undo_offset := undo_offset;
	ENDIF;
ENDPROCEDURE;

!
!	This function performs the operations associated with the ^Y and ^E
!	keystrokes.
!
PROCEDURE vi$pull_push_line (direction)

	LOCAL
		currow,
		limit,
		n_lines,
		pos;

	ON_ERROR
		! Ignore "ATTEMPT to move past TOP/BOTTOM of buffer"
	ENDON_ERROR;

	! Get the number of lines to move.

	n_lines := vi$cur_active_count * direction;

	! Mark the destination position for the case where we are at the top or
	! bottom of the window.

	MOVE_VERTICAL (n_lines);
	pos := MARK (NONE);

	! Return to the old position.

	MOVE_VERTICAL (-n_lines);

	! Get the current screen row

	currow := GET_INFO (CURRENT_WINDOW, "CURRENT_ROW");

	! Get the proper border value based on the direction.

	IF (n_lines < 0) THEN
		limit := GET_INFO (CURRENT_WINDOW, "VISIBLE_BOTTOM");
	ELSE
		limit := GET_INFO (CURRENT_WINDOW, "VISIBLE_TOP");
	ENDIF;

	! If we are NOT at the top or bottom, then the current row is the dest.

	IF (n_lines > 0) THEN
		IF (currow - limit) >= n_lines THEN
			pos := MARK (NONE);
	   	ENDIF;
	ELSE
		IF vi$abs (currow - limit) >= vi$abs (n_lines) THEN
			pos := MARK (NONE);
		ENDIF;
	ENDIF;

	! Scroll the window.  If the scroll fails, then move the cursor.

	POSITION (LINE_BEGIN);
	IF (SCROLL (CURRENT_WINDOW, n_lines) <> n_lines) THEN
		POSITION (pos);
		MOVE_VERTICAL (n_lines);
	ELSE

		! Otherwise the position we wanted is visible, so move there.

		POSITION (pos);
		IF (n_lines < 0) AND ((currow - limit) > n_lines) THEN
			MOVE_VERTICAL (limit - currow);
		ENDIF;
	ENDIF;
ENDPROCEDURE;

!
!	Move to the location indicated by a '|' command.
!
PROCEDURE vi$_to_column
	vi$beep_position (vi$to_column, 0, 1);
ENDPROCEDURE;

!
!	Return the marker indicating the column selected by vi$active_count
!
PROCEDURE vi$to_column
	LOCAL
		pos,
		act_count;

	act_count := vi$cur_active_count;
	pos := MARK (NONE);

	IF (act_count <= LENGTH (vi$current_line)) THEN
		pos := MARK (NONE);
		MOVE_HORIZONTAL (act_count - CURRENT_OFFSET - 1);
		RETURN (vi$retpos (pos));
	ENDIF;
	RETURN (0);
ENDPROCEDURE;

!
!	Perform the operations associated with 'ZZ' (write and exit) command.
!
PROCEDURE vi$_ZZ (rkey)
	 LOCAL
		prcnam,
		ans,
		cur_buf,
		read_z,
		buf,
		errno;

	ON_ERROR
		errno := ERROR;
		IF errno = TPU$_NOPARENT THEN

			!  Use vi$quit so that buffers not written will not be written
			!  automatically.

			vi$quit;
		ENDIF;
	ENDON_ERROR;

	read_z := rkey;

	IF (read_z <> KEY_NAME ('Z')) THEN
		read_z := vi$read_a_key;
	ENDIF;

	IF (read_z = KEY_NAME ('Z')) THEN
		cur_buf := CURRENT_BUFFER;

		IF (GET_INFO (cur_buf, "MODIFIED")) AND
							(GET_INFO (cur_buf, "SYSTEM") = 0) THEN

			IF (vi$can_write (cur_buf)) THEN
				IF (GET_INFO (cur_buf, "NO_WRITE") = 0) THEN
					vi$info ("Writing out """+GET_INFO (cur_buf, "NAME")+"""");
					WRITE_FILE (cur_buf);
				ENDIF;
			ELSE
				RETURN;
			ENDIF;
		ENDIF;

		buf := GET_INFO (BUFFERS, "FIRST");
		LOOP
			EXITIF (buf = 0);
			IF (GET_INFO (buf, "MODIFIED")) AND
								(GET_INFO (buf, "SYSTEM") = 0) THEN

				ans := vi$read_line ("Write """+GET_INFO (buf, "NAME")+"""? ");

				CHANGE_CASE (ans, LOWER);
				IF SUBSTR (ans, 1, 1) = "y" THEN
					IF (vi$can_write (buf)) THEN
						IF (GET_INFO (buf, "NO_WRITE") = 0) THEN
							vi$info ("Writing out """+
												GET_INFO (buf, "NAME")+"""");
							WRITE_FILE (buf);
						ENDIF;
					ELSE
						RETURN;
					ENDIF;
				ENDIF;
			ENDIF;
			buf := GET_INFO (BUFFERS, "NEXT");
		ENDLOOP;

		IF (vi$get_attach_parm ("TPU$NOSUBPROC") = " ") THEN
			prcnam := vi$get_attach_parm ("TPU$ATTACH_NAME");
			vi$pasthru_off;
			IF (prcnam = " ") THEN
				ATTACH;
			ELSE       
				ATTACH (prcnam);
			ENDIF;
			vi$pasthru_on;
			vi$process_args;
		ELSE
			vi$do_quit ("q", "q");
		ENDIF;
	ENDIF;

	vi$kill_undo;
	vi$undo_end := 0;
	vi$active_count := 0;
ENDPROCEDURE;

!
!	Process the job logical names that are used to pass parameters between
!	the parent process and the editor.
!
PROCEDURE vi$process_args

	LOCAL
		buf,
		bufn,
		errno,
		startup_cmd,
		new_output,
		find_text,
		new_lineno,
		input_file;

	ON_ERROR

		errno := ERROR;

		SET (SUCCESS, ON);
		vi$system_message (errno);
		RETURN;

	ENDON_ERROR;

	startup_cmd := vi$get_attach_parm ("TPU$NEWCMD");

	IF startup_cmd = " " THEN
		input_file := vi$get_attach_parm ("TPU$ARGS");

		IF (input_file <> " ") THEN
			new_output := vi$get_attach_parm ("TPU$OUTPUT");

			!  When a file is specified, and a new output file is also
			!  specified, then we will attempt to erase any existing
			!  buffer's contents so that MAIL will actually be able to
			!  be used over and over during an editor's life.

			IF (new_output <> " ") THEN
				bufn := FILE_PARSE (input_file,"","",NAME) +
						FILE_PARSE (input_file,"","",TYPE);
				buf := vi$find_buffer_by_name (bufn);
				IF buf <> 0 THEN
			   		IF (GET_INFO (buf, "MODIFIED") = 0) OR
										GET_INFO (buf, "NO_WRITE") THEN
						ERASE (buf);
					ELSE
						vi$info (
				"Buffer is modified, original contents not destroyed!");
					ENDIF;
				ENDIF;
			ENDIF;

			vi$get_file (input_file);

			IF (new_output <> " ") THEN
				SET (OUTPUT_FILE, CURRENT_BUFFER, new_output);
				vi$status_lines (CURRENT_BUFFER);

				!  Set the buffer to be modified so that the file will
				!  be written on exit.

				SPLIT_LINE;
				APPEND_LINE;
			ENDIF;
		ENDIF;
	ELSE
		new_output := vi$get_attach_parm ("TPU$OUTPUT");
		IF (new_output <> " ") THEN
			SET (OUTPUT_FILE, CURRENT_BUFFER, new_output);
			vi$status_lines (CURRENT_BUFFER);

			!  Set the buffer to be modified so that the file will
			!  be written on exit.

			SPLIT_LINE;
			APPEND_LINE;
		ENDIF;

		vi$do_cmd_line (startup_cmd);
	ENDIF;

	new_lineno := vi$get_attach_parm ("TPU$LINE");

	IF (new_lineno = " ") THEN
		find_text := vi$get_attach_parm ("TPU$SEARCH");
		IF (find_text <> " ") THEN
			IF SUBSTR (find_text, 1, 1) = "/" THEN
				SET (FORWARD, CURRENT_BUFFER);
				vi$last_search_dir := 1;
			ELSE
				SET (REVERSE, CURRENT_BUFFER);
				vi$last_search_dir := -1;
			ENDIF;
			vi$search_string := SUBSTR (find_text, 2, LENGTH (find_text)-1);
			vi$beep_position (vi$find_str (vi$search_string, 0, 0), 1, 1);
		ENDIF;
	ELSE
		vi$beep_position (vi$to_line (INT (new_lineno)), 1, 1);
	ENDIF;
ENDPROCEDURE;

!
!  A special procedure to trap any errors in translating logical names, and
!  just ignore them, and return a " " string on error.
!
PROCEDURE vi$get_attach_parm (parm)
	LOCAL
		rstr,
		errno,
		blank;

	ON_ERROR
		errno := ERROR;
		RETURN (blank);
	ENDON_ERROR;

	blank := " ";

	rstr := CALL_USER (vi$cu_trnlnm_job, parm);
	RETURN (rstr);
ENDPROCEDURE;

!
!	Perform the operations associated with the 'z' key command.
!
PROCEDURE vi$_z_move

	LOCAL
		pos,
		crow,
		old_scroll,
		scrl_value,
		scroll_top,
		scroll_bottom,
		scroll_amount,
		win_size,
		next_key,
		cur_window;

!	ON_ERROR
!		MESSAGE ("LINE: "+str(ERROR_LINE));
!	ENDON_ERROR;

	win_size := 0;
	LOOP
		next_key := vi$read_a_key;
		EXITIF INDEX (vi$_numeric_chars, ASCII (next_key)) = 0;
		win_size := win_size * 10 + INT (ASCII (KEY_NAME (next_key)));
	ENDLOOP;

	IF (next_key = F11) OR ((next_key <> RET_KEY) AND
					(next_key <> KEY_NAME ('.')) AND
					(next_key <> KEY_NAME ('+')) AND
					(next_key <> KEY_NAME ('-'))) THEN
		vi$active_count := 0;
		RETURN;
	ENDIF;

	pos := MARK (NONE);
	IF (vi$active_count > 0) THEN
		vi$old_place := MARK (NONE);
		pos := vi$to_line (vi$cur_active_count);
	ENDIF;

	cur_window := CURRENT_WINDOW;
	scroll_top    := GET_INFO (cur_window, "SCROLL_TOP");
	scroll_bottom := GET_INFO (cur_window, "SCROLL_BOTTOM");
	scroll_amount := GET_INFO (cur_window, "SCROLL_AMOUNT");

	IF (win_size > 0) THEN
		vi$do_set_window (win_size);
	ENDIF;

	scrl_value := GET_INFO (cur_window, "VISIBLE_LENGTH");

	IF next_key = KEY_NAME ('-') THEN
		SET (SCROLLING, cur_window, ON, scrl_value, 0, 0);
	ELSE
		IF (next_key = KEY_NAME ('+')) OR (next_key = RET_KEY) THEN
			SET (SCROLLING, cur_window, ON, 0, scrl_value, 0);
		ELSE
			SET (SCROLLING, cur_window, ON, scrl_value/2, scrl_value/2, 0);
		ENDIF;
	ENDIF;

	POSITION (pos);
	vi$update (cur_window);

	SET (SCROLLING, cur_window, ON, scroll_top, scroll_bottom, scroll_amount);
ENDPROCEDURE;

!
!	Perform the 'r' command
!
PROCEDURE vi$_replace_char

	LOCAL
		act_cnt,
		key,
		pos;

	ON_ERROR;
		POSITION (pos);
		RETURN;
	ENDON_ERROR;

	pos := MARK (NONE);
	act_cnt := vi$cur_active_count;
	IF (vi$show_mode) THEN
		vi$mess_select (BOLD);
		MESSAGE (FAO ("!7*	REPLACE"));
		vi$mess_select (REVERSE);
	ENDIF;
	key := vi$read_a_key;

	IF (key = F11) THEN
		IF (vi$show_mode) THEN
			MESSAGE ("");
		ENDIF;
		RETURN;
	ENDIF;

	IF (key = TAB_KEY) THEN
		 key := ASCII (9);
	ELSE    
		IF (key = RET_KEY) THEN
			 key := ASCII (13);
		ELSE
			IF (key = DEL_KEY) THEN
				 key := ASCII (8);
			ELSE
				key := ASCII (key);
			ENDIF;
		ENDIF;
	ENDIF;

	IF ((CURRENT_OFFSET + act_cnt) <= LENGTH (vi$current_line)) THEN
		IF (key = ASCII (13)) THEN
			MOVE_HORIZONTAL (act_cnt);
		ELSE
			MOVE_HORIZONTAL (act_cnt - 1);
		ENDIF;
		vi$save_for_undo (CREATE_RANGE (pos, MARK(NONE), NONE),
														VI$IN_LINE_MODE, 1);
		IF (key = ASCII (13)) THEN
			MOVE_HORIZONTAL (-act_cnt);
		ELSE
			MOVE_HORIZONTAL (-(act_cnt-1));
		ENDIF;
		IF (MARK (NONE) <> BEGINNING_OF (CURRENT_BUFFER)) THEN
			MOVE_HORIZONTAL (-1);
			vi$undo_start := MARK (NONE);
			MOVE_HORIZONTAL (1);
		ELSE
			vi$undo_start := 0;
		ENDIF;

		SET (OVERSTRIKE, CURRENT_BUFFER);
		LOOP
			IF (key = ASCII (13)) THEN
				SPLIT_LINE;
				ERASE_CHARACTER (1);
			ELSE
				COPY_TEXT (key);
			ENDIF;
			act_cnt := act_cnt - 1;
			EXITIF act_cnt = 0;
		ENDLOOP;

		IF (key = ASCII (13)) THEN
			MOVE_HORIZONTAL (1);
		ENDIF;

		MOVE_HORIZONTAL (-1);
		vi$undo_end := MARK (NONE);

		SET (INSERT, CURRENT_BUFFER);
		IF (vi$undo_start = 0) THEN
			vi$undo_start := BEGINNING_OF (CURRENT_BUFFER);
		ELSE
			pos := MARK (NONE);
			POSITION (vi$undo_start);
			MOVE_HORIZONTAL (1);
			vi$undo_start := MARK (NONE);
			POSITION (pos);
		ENDIF;
	ELSE
		POSITION (pos);
	ENDIF;

	IF (vi$show_mode) THEN
		MESSAGE ("");
	ENDIF;
	RETURN;
ENDPROCEDURE

!
!	Perform the 'R' command
!
PROCEDURE vi$_replace_str

	LOCAL
		replace,
		max_mark,
		start_pos,
		spos,
		pos,
		max_col;

	pos := MARK (NONE);
	max_col := CURRENT_OFFSET;
	start_pos := max_col;
	POSITION (LINE_END);
	max_mark := MARK(NONE);
	vi$undo_end := MARK (NONE);
	POSITION (pos);
	vi$update (CURRENT_WINDOW);
	replace := CURRENT_LINE;
	spos := vi$get_undo_start;
	vi$save_for_undo (CREATE_RANGE (pos, max_mark, NONE), VI$IN_LINE_MODE, 1);

	vi$line_edit (max_col, start_pos, max_mark, replace);
	IF (CURRENT_CHARACTER = "") THEN
		MOVE_HORIZONTAL (1);
		pos := MARK (NONE);
		MOVE_HORIZONTAL (-1);
	ELSE
		pos := MARK (NONE);
	ENDIF;
	vi$undo_start := vi$set_undo_start (spos);
	POSITION (pos);
ENDPROCEDURE;

!
!	As in REAL vi, this procedure does not recognize a repeat count.
!	A simple loop would make it possible to use the repeat count contained
!	in "vi$active_count".  A macro is used so that all of the crap for undo
!	need not be placed here.
!
PROCEDURE vi$_change_case
	LOCAL      
		pos;

	vi$active_count := 0;
	pos := INDEX (vi$_lower_chars, CURRENT_CHARACTER);
	IF pos <> 0 THEN
		vi$do_macro ("r"+SUBSTR (vi$_upper_chars, pos, 1)+"l", 0);
	ELSE
		pos := INDEX (vi$_upper_chars, CURRENT_CHARACTER);
		IF pos <> 0 THEN
			vi$do_macro ("r"+SUBSTR (vi$_lower_chars, pos, 1)+"l", 0);
		ELSE
			vi$kill_undo;
			vi$undo_end := 0;
			MOVE_HORIZONTAL (1);
		ENDIF;
	ENDIF;

ENDPROCEDURE;

!
!
!
PROCEDURE vi$init_action (olen)
	LOCAL
		nchar;

	olen := GET_INFO (CURRENT_BUFFER, "RECORD_COUNT");

	IF (vi$select_pos = 0) THEN
		nchar := vi$read_a_key;
		IF (INDEX ("123456789", ASCII(nchar)) <> 0) THEN
			vi$active_count := INDEX (vi$_numeric_chars, ASCII(nchar)) - 1;
			LOOP
				nchar := vi$read_a_key;
				EXITIF (INDEX (vi$_numeric_chars, ASCII(nchar)) = 0);
				vi$active_count := vi$active_count *
						10 + (INDEX (vi$_numeric_chars, ASCII (nchar)) - 1);
			ENDLOOP;
		ENDIF;
	ELSE
		nchar := KEY_NAME (".");
	ENDIF;
	RETURN (nchar);
ENDPROCEDURE;

!
!
!
PROCEDURE vi$get_prog (nchar)
	IF (vi$select_pos = 0) THEN
		RETURN (LOOKUP_KEY (KEY_NAME (nchar), COMMENT, vi$move_keys));
	ELSE
		RETURN ("vi$get_select_pos");
	ENDIF;
ENDPROCEDURE;

!
!
!
PROCEDURE vi$do_movement (prog, mtype)

	vi$endpos := 0;
	vi$new_endpos := 0;
	vi$command_type := mtype;

	EXECUTE (COMPILE ("vi$endpos := " + prog));

	IF vi$new_endpos <> 0 THEN
		vi$endpos := vi$new_endpos;
	ENDIF;
ENDPROCEDURE;

!
!	Perform the operations associated with the 'c' command.
!
PROCEDURE vi$_change

	LOCAL
		max_mark,
		max_col,
		start_col,
		start_offset,
		end_offset,
		start_line,
		end_line,
		cha_range,
		pos,
		olen,
		prog,
		do_back,
		nchar;

	ON_ERROR;
		vi$info ("Error occured during change, at line: "+STR(ERROR_LINE));
		POSITION (vi$start_pos);
		RETURN;
	ENDON_ERROR;

	vi$new_offset := 1;
	nchar := vi$init_action (olen);

	IF (nchar = KEY_NAME ('c')) THEN
		vi$_big_s;
		RETURN;
	ENDIF;

	! If the movement will be backwards, then the region must not include
	! the current character.

	do_back := vi$get_direction (nchar);

	IF do_back THEN
		vi$move_horizontal (-1);
		vi$start_pos := MARK (NONE);
		vi$move_horizontal (1);
	ELSE
		vi$start_pos := MARK (NONE);
	ENDIF;

	prog := vi$get_prog (nchar);

	IF prog <> "" THEN
		vi$do_movement (prog, VI$CHANGE_TYPE);

		POSITION (vi$start_pos);
		start_offset := CURRENT_OFFSET;
		POSITION (LINE_BEGIN);
		start_line := MARK (NONE);
		POSITION (vi$start_pos);

		IF (vi$endpos <> 0) THEN
			POSITION (vi$endpos);
			POSITION (LINE_BEGIN);
			end_line := MARK (NONE);
			POSITION (vi$endpos);

			IF (MARK (NONE) <> BEGINNING_OF (CURRENT_BUFFER)) AND
						(NOT do_back) AND
						(INDEX (vi$weird_moves, ASCII (nchar)) = 0) THEN
				vi$move_horizontal (-1);
			ENDIF;
			end_offset := CURRENT_OFFSET + 1;

			cha_range := CREATE_RANGE (vi$start_pos, MARK (NONE), NONE);

			IF (start_line <> end_line) THEN
				IF (cha_range <> 0) THEN
					POSITION (vi$start_pos);

					vi$undo_start := vi$get_undo_start;
					vi$save_for_undo (cha_range, vi$yank_mode, 0);

					vi$type2buf (STR(vi$yank_mode), vi$temp_buf);
					vi$cur_text := vi$cp2buf (cha_range, vi$temp_buf);

					ERASE (cha_range);

					IF (vi$while_not_esc = 0) THEN
					   	vi$undo_end := 0;
					ELSE
						vi$undo_end := MARK (NONE);
						vi$undo_start := vi$set_undo_start (vi$undo_start);
						POSITION (vi$undo_end);
						IF (CURRENT_CHARACTER = "") THEN
							MOVE_HORIZONTAL (1);
						ENDIF;
					ENDIF;
				ELSE
					vi$info ("Internal error while changing!");
				ENDIF;
			ELSE
				IF (cha_range <> 0) THEN
					IF (start_offset < end_offset) THEN
						max_col := end_offset;
						MOVE_HORIZONTAL (1);
						max_mark := MARK (NONE);
						MOVE_HORIZONTAL (-1);
						start_col := start_offset;
					ELSE
						POSITION (vi$start_pos);
						MOVE_HORIZONTAL (1);
						max_col := CURRENT_OFFSET;
						max_mark := MARK (NONE);
						POSITION (vi$start_pos);
						start_col := end_offset - 1; 
					ENDIF;

					cha_range := SUBSTR (vi$current_line, start_col + 1,
													max_col - start_col);

					vi$type2buf (STR (vi$yank_mode), vi$temp_buf);
					vi$cur_text := vi$cp2buf (cha_range, vi$temp_buf);

					vi$save_for_undo (cha_range, vi$yank_mode, 0);

					SET (OVERSTRIKE, CURRENT_BUFFER);
					COPY_TEXT ("$");
					SET (INSERT, CURRENT_BUFFER);

					IF (start_offset < end_offset) THEN
						POSITION (vi$start_pos);
					ELSE
						POSITION (vi$endpos);
					ENDIF;

					vi$update (CURRENT_WINDOW);

					vi$undo_start := vi$get_undo_start;

					if (vi$line_edit (max_col, start_col, max_mark, 0) = 0) THEN
						vi$undo_end := 0;
					ELSE
						vi$undo_end := MARK (NONE);
					   	IF (CURRENT_CHARACTER = "") THEN
							MOVE_HORIZONTAL (1);
						ENDIF;
					ENDIF;

					pos := MARK (NONE);

					vi$undo_start := vi$set_undo_start (vi$undo_start);
					POSITION (pos);
				ELSE
					vi$info ("Internal error while changing!");
				ENDIF;
			ENDIF;
		ELSE
			vi$abort (0);
		ENDIF;
	ELSE
		vi$abort (0);
	ENDIF;

	vi$check_length (olen);
ENDPROCEDURE;

!
!	Decide which direction the movement will be based on whether or not
!	the last movement was a t, T, f, F, or other backward movement.
!
PROCEDURE vi$get_direction (nchar)
	LOCAL
		do_back;

	do_back := 0;

	IF ((ASCII (nchar) = ",") AND ((vi$last_s_func = "vi$find_char") OR
										(vi$last_s_func = "vi$to_char"))) OR
		((ASCII (nchar) = ";") AND ((vi$last_s_func = "vi$back_find_char") OR
									(vi$last_s_func = "vi$back_to_char"))) THEN
		do_back := 1;
	ENDIF;

	IF (INDEX (vi$back_moves + vi$weird2_moves, ASCII(nchar)) <> 0) THEN
		do_back := 1;
	ENDIF;

	IF (ASCII (nchar) = 'G') AND (vi$cur_line_no > vi$active_count) AND
	                                            (vi$active_count > 0) THEN
		do_back := 1;
	ENDIF;

	RETURN (do_back);
ENDPROCEDURE;

!
!	Given the fact that a select range is active, modify vi$start_pos
!	to be the start of that range, and return the end of the select
!	range.
!
PROCEDURE vi$get_select_pos
	LOCAL
		pos,
		rng;

	rng := SELECT_RANGE;
	IF (rng <> 0) THEN
		pos := MARK (NONE);
		vi$select_pos := 0;
		vi$start_pos := BEGINNING_OF (rng);
		POSITION (END_OF (rng));
		MOVE_HORIZONTAL (1);
		MESSAGE ("");
		RETURN (vi$retpos (pos));
	ELSE
		vi$select_pos := 0;
		vi$info ("No region selected!");
	ENDIF;
	RETURN (0);
ENDPROCEDURE;

!
!	Perform the operations associated with the 'S' command.
!
PROCEDURE vi$_big_s
	LOCAL
		max_mark,
		start_pos,
		max_col,
		rng,
	  	start,
		tend,
		pos;

	POSITION (LINE_BEGIN);

	IF (MARK (NONE) <> BEGINNING_OF (CURRENT_BUFFER)) THEN
		MOVE_HORIZONTAL (-1);
		vi$undo_start := MARK (NONE);
		MOVE_HORIZONTAL (1);
	ELSE
		vi$undo_start := 0;
	ENDIF;

	IF (MARK (NONE) = BEGINNING_OF (CURRENT_BUFFER)) THEN
		vi$undo_end := 0;
	ENDIF;

	start := MARK (NONE);
	MOVE_VERTICAL (vi$cur_active_count - 1);
	IF (LENGTH (vi$current_line) > 0) THEN
		POSITION (LINE_END);
		MOVE_HORIZONTAL (-1);
	ENDIF;

	tend := MARK (NONE);
	rng := CREATE_RANGE (start, tend, NONE);
	POSITION (start);
	vi$save_for_undo (rng, VI$IN_LINE_MODE, 1);

	ERASE (rng);

	max_col := CURRENT_OFFSET;
	start_pos := max_col;
	max_mark := MARK(NONE);

	vi$update (CURRENT_WINDOW);

	IF (vi$line_edit (max_col, start_pos, max_mark, 0) <> 0) THEN
		vi$undo_end := MARK (NONE);
		IF (CURRENT_CHARACTER = "") THEN
			MOVE_HORIZONTAL (1);
		ENDIF;
	ELSE
		vi$undo_end := 0;
	ENDIF;
	pos := MARK (NONE);
	vi$undo_start := vi$set_undo_start (vi$undo_start);
	POSITION (pos);
ENDPROCEDURE;

!
!	This function performs the operations associated with the '"' command
!	that allows one of the 26 named buffers, or one of the 10 delete
!	buffers to be the target of a 'd', 'D', 'x', 'X', 'y', 'Y', 'p' or 'P'
!	command.
!
PROCEDURE vi$select_buffer
	LOCAL
		numeric,
		asc_action,
		action,
		prog,
		buf_name,
		nchar;

	ON_ERROR;
		RETURN;
	ENDON_ERROR;

	nchar := ASCII (vi$read_a_key);
	action := vi$read_a_key;
	asc_action := ASCII (action);
	numeric := (INDEX (vi$_numeric_chars, asc_action) <> 0);

	IF numeric THEN
		vi$active_count := INDEX (vi$_numeric_chars, asc_action) - 1;
		LOOP
			action := vi$read_a_key;
			asc_action := ASCII (action);
		   	EXITIF (INDEX (vi$_numeric_chars, asc_action) = 0);
			vi$active_count := (vi$active_count * 10) +
									(INDEX (vi$_numeric_chars, asc_action) - 1);
		ENDLOOP;
	ENDIF;

	IF	(asc_action <> 'P') AND (asc_action <> 'p') AND (asc_action <> 'd') AND
		(asc_action <> 'D') AND (asc_action <> 'y') AND (asc_action <> 'Y') AND
		(asc_action <> 'x') AND (asc_action <> 'X') AND (NOT numeric) THEN

		vi$info ("Unrecognized buffer action, ignoring: '"+asc_action+"'");

		RETURN;
	ENDIF;

	IF (INDEX ("123456789", nchar) <> 0) THEN

		IF	(asc_action <> 'P') AND (asc_action <> 'p') THEN
			RETURN;
		ENDIF;

		! Selected a deletion buffer.

		buf_name := "vi$del_buf_"+nchar;

	ELSE
		IF (INDEX (vi$_letter_chars, nchar) <> 0) THEN

			! Selected a named buffer.

			IF (INDEX (vi$_upper_chars, nchar) <> 0) THEN
				nchar := SUBSTR (vi$_lower_chars,
							INDEX (vi$_upper_chars, nchar), 1);
				vi$append_it := 1;
			ENDIF;
			buf_name := "vi$ins_buf_"+nchar;

			! Only create a buffer if we are going to put something into it.

			IF	(asc_action <> 'P') AND (asc_action <> 'p') THEN
				EXECUTE (COMPILE ('vi$get_ins_buf(' +
											buf_name + ', "'+buf_name+'");'));
			ELSE
				vi$global_var := 0;
				EXECUTE (COMPILE ("vi$global_var:="+buf_name));
				IF (vi$global_var = 0) THEN
					vi$info ("There is nothing in that buffer!");
					RETURN;
				ENDIF;
			ENDIF;
		ELSE
			vi$info ("Invalid buffer!");
			RETURN;
		ENDIF;              
	ENDIF;

	! We now have a buffer, and the next command key, so envoke the
	! proper code.

	vi$do_buf_act (asc_action, 'P', "vi$put_here (VI$HERE, "+buf_name+");");
	vi$do_buf_act  (asc_action, 'p', "vi$put_after ("+buf_name+");");
	vi$do_buf_act  (asc_action, 'd', "vi$_delete (0, "+buf_name+");");
	vi$do_buf_act  (asc_action, 'D',
								"vi$_delete (KEY_NAME('$'), "+buf_name+");");
	vi$do_buf_act  (asc_action, 'x', "vi$_delete ('l', "+buf_name+");");
	vi$do_buf_act  (asc_action, 'X', "vi$_delete ('h', "+buf_name+");");
	vi$do_buf_act  (asc_action, 'y', "vi$_yank (0, "+buf_name+");");
	vi$do_buf_act  (asc_action, 'Y', "vi$_yank ('y', "+buf_name+");");
	vi$do_buf_act  (asc_action, 'Y', "vi$_yank (KEY_NAME('y'), "+buf_name+");");
ENDPROCEDURE;

!
!	Perform action based on key typed and passed data
!
PROCEDURE vi$do_buf_act (act_type, look_for, what_to_do)

	IF (act_type = look_for) THEN
		EXECUTE (COMPILE (what_to_do));
	ENDIF;
ENDPROCEDURE;

!
!	Create a buffer named 'bname' providing that there is not already a
!	buffer by that name.
!
PROCEDURE vi$get_ins_buf (buf, bname)

	IF (buf = 0) THEN
		buf := vi$init_buffer (bname, "");
	ENDIF;

	IF buf = 0 THEN
		vi$info ("Error creating named buffer!");
	ENDIF;
ENDPROCEDURE;

!
!	Perform the delete command tied to the 'd' key.
!
PROCEDURE vi$_delete (opchar, dest_buf)

	LOCAL
		olen,
		old_offset,
		new_offset,
		era_range,
		opos,
		prog,
		do_back,
		nchar;

	ON_ERROR;
		vi$info ("Error occured during delete, at line: "+STR(ERROR_LINE));
		POSITION (vi$start_pos);
		RETURN;
	ENDON_ERROR;

	vi$new_offset := 1;
	nchar := opchar;

	opos := MARK (NONE);
	IF (nchar = 0) THEN
		nchar := vi$init_action (olen);
	ELSE
		olen := GET_INFO (CURRENT_BUFFER, "RECORD_COUNT");
	ENDIF;

	! If the movement will be backwards, then the region must not include
	! the current character.

	old_offset := -1;
	new_offset := -1;

	do_back := vi$get_direction (nchar);

	IF do_back THEN
		old_offset := CURRENT_OFFSET;
		vi$move_horizontal (-1);
		new_offset := CURRENT_OFFSET;
	ENDIF;

	vi$start_pos := MARK (NONE);

	! For "dh" or "X" (a macro of "dh"), we must let vi$left do the movement.

	IF (INDEX (vi$weird2_moves, ASCII(nchar)) <> 0) AND
												(old_offset <> new_offset) THEN
		MOVE_HORIZONTAL (1);
	ENDIF;

	prog := vi$get_prog (nchar);

	IF prog <> "" THEN
		vi$do_movement (prog, VI$DELETE_TYPE);

		IF (vi$endpos <> 0) THEN
			IF (do_back) AND (vi$yank_mode = VI$LINE_MODE) THEN
				POSITION (vi$start_pos);
				vi$move_vertical (1);
				IF (LENGTH(vi$current_line) > 0) THEN
					MOVE_HORIZONTAL (-1);
				ENDIF;
				vi$start_pos := MARK (NONE);
			ENDIF;

			POSITION (vi$endpos);

			IF (MARK (NONE) <> BEGINNING_OF (CURRENT_BUFFER)) AND
						(NOT do_back) AND
						(INDEX (vi$weird_moves, ASCII (nchar)) = 0) THEN
				MOVE_HORIZONTAL (-1);
			ENDIF;

			era_range := CREATE_RANGE (vi$start_pos, MARK (NONE), NONE);

			IF (era_range <> 0) THEN
				IF (GET_INFO (dest_buf, "TYPE") = INTEGER) THEN
					vi$cur_text := vi$put2del_buf (vi$yank_mode, era_range);
				ELSE
				   	vi$type2buf (STR (vi$yank_mode), dest_buf);
					vi$cur_text := vi$cp2buf (era_range, dest_buf);
				ENDIF;

				vi$undo_end := 0;
				POSITION (BEGINNING_OF (era_range));
				vi$save_for_undo (era_range, vi$yank_mode, 1);
				vi$undo_start := vi$start_pos;
				ERASE (era_range);
			ELSE
				vi$info ("Internal error while deleting!");
			ENDIF;

			POSITION (vi$start_pos);
		ELSE
			vi$abort (0);
			POSITION (opos);
		ENDIF;
	ELSE
		POSITION (opos);
		vi$abort (0);
	ENDIF;

	vi$check_length (olen);
ENDPROCEDURE;

!
!	This procedure checks a change in the size of the buffer, and reports
!	the change if it is greater than the number set with ":set report"
!
PROCEDURE vi$check_length (olen)
	LOCAL
		nlen;

	nlen := GET_INFO (CURRENT_BUFFER, "RECORD_COUNT");

	IF (nlen - vi$report) >= olen THEN
		vi$info (STR (nlen - olen) + " more lines!");
	ELSE
		IF (nlen + vi$report <= olen) THEN
			vi$info (STR (olen - nlen) + " fewer lines!");
		ENDIF;
	ENDIF;
ENDPROCEDURE;  

!
!	Perform the yank command tied to the 'y' key.
!
PROCEDURE vi$_yank (opchar, dest_buf)

	LOCAL
		old_offset,
		new_offset,
		pos,
		oline,
		nline,
		yank_range,
		prog,
		do_back,
		nchar;

	ON_ERROR;
		vi$info ("Error occured during yank, at line: "+STR(ERROR_LINE));
		POSITION (vi$start_pos);
		RETURN;
	ENDON_ERROR;

	nchar := opchar;
	pos := MARK (NONE);

	IF nchar = 0 THEN
		nchar := vi$init_action (oline);
	ENDIF;

	old_offset := -1;
	new_offset := -1;

	! If the movement will be backwards, then the region must not include
	! the current character.

	do_back := vi$get_direction (nchar);

	IF do_back THEN
		old_offset := CURRENT_OFFSET;
		vi$move_horizontal (-1);
		new_offset := CURRENT_OFFSET;
	ENDIF;

	vi$start_pos := MARK (NONE);

	! For "yl" and similar moves, we must let vi$left to the movement.

	IF (INDEX (vi$weird2_moves, ASCII(nchar)) <> 0) AND
												(old_offset <> new_offset) THEN
		MOVE_HORIZONTAL (1);
	ENDIF;

	prog := vi$get_prog (nchar);

	IF prog <> "" THEN
		vi$do_movement (prog, VI$YANK_TYPE);

		oline := vi$cur_line_no;
		IF (vi$endpos <> 0) THEN
			POSITION (vi$endpos);
			nline := vi$abs (vi$cur_line_no - oline);
			IF (nline >= vi$report) THEN
				vi$info (STR (nline) + " lines yanked");
			ENDIF;
			IF (MARK (NONE) <> BEGINNING_OF (CURRENT_BUFFER)) AND
						(NOT do_back) AND
						(INDEX (vi$weird_moves, ASCII (nchar)) = 0) THEN
				MOVE_HORIZONTAL (-1);
			ENDIF;

			yank_range := CREATE_RANGE (vi$start_pos, MARK (NONE), NONE);

			IF (yank_range <> 0) THEN
				IF (GET_INFO (dest_buf, "TYPE") = INTEGER) THEN
					vi$cur_text := vi$put2yank_buf (yank_range, vi$temp_buf);
				ELSE
					vi$cur_text := vi$put2yank_buf (yank_range, dest_buf);
				ENDIF;
			ELSE
				vi$info ("Internal error while yanking!");
			ENDIF;
		ELSE
			vi$abort (0);
		ENDIF;

		POSITION (pos);
	ELSE
		vi$abort (0);
	ENDIF;

ENDPROCEDURE;

!
!	Return the absolute value of the value passed.
!
PROCEDURE vi$abs (val)
	IF val < 0 THEN
		RETURN (-val);
	ENDIF;
	RETURN (val);
ENDPROCEDURE;

!
!	Given a range of a buffer, or a string, place it into the "kill-ring"
!	sliding the text back one slot that is already there.
!
PROCEDURE vi$put2del_buf (mode, string_parm)

	LOCAL
		local_str,
		pos;

	pos := MARK (NONE);

	IF (mode = VI$LINE_MODE) THEN

		! Slide each range back one slot, throwing away the last.

		vi$mv2buf (vi$del_buf_8, vi$del_buf_9);
		vi$mv2buf (vi$del_buf_7, vi$del_buf_8);
		vi$mv2buf (vi$del_buf_6, vi$del_buf_7);
		vi$mv2buf (vi$del_buf_5, vi$del_buf_6);
		vi$mv2buf (vi$del_buf_4, vi$del_buf_5);
		vi$mv2buf (vi$del_buf_3, vi$del_buf_4);
		vi$mv2buf (vi$del_buf_2, vi$del_buf_3);
		vi$mv2buf (vi$del_buf_1, vi$del_buf_2);

		! Place the new text at the front.

		vi$type2buf (STR(mode), vi$del_buf_1);
		vi$cp2buf (string_parm, vi$del_buf_1);
	ENDIF;

	! Save the text so that a normal 'p' or 'P' command also works.

	vi$type2buf (STR(mode), vi$temp_buf);
	vi$cp2buf (string_parm, vi$temp_buf);

	POSITION (pos);
	RETURN (vi$temp_buf);
ENDPROCEDURE;

!
!	Copy the text specified by source into the delete buffer given by
!	dest.  If dest is zero, the it will be set to the value of a newly
!	created buffer.
!
PROCEDURE vi$cp2buf (source, dest)
	LOCAL
		pos;

	pos := MARK (NONE);

	IF (source <> 0) THEN
		IF (dest = 0) THEN
			dest := vi$init_buffer ("TEMP_BUF_"+str(vi$temp_buf_num), "");
			vi$temp_buf_num := vi$temp_buf_num + 1;
		ENDIF;

		POSITION (dest);
		COPY_TEXT (source);
	ENDIF;

	POSITION (pos);
	RETURN (dest);
ENDPROCEDURE;

!
!	vi$mv2buf is like vi$cp2buf except that vi$mv2buf erases the buffer before
!	performing the copy.
!
PROCEDURE vi$mv2buf (source, dest)
	LOCAL
		pos;

	pos := MARK (NONE);

	IF (source <> 0) THEN
		IF (dest = 0) THEN
			dest := vi$init_buffer ("TEMP_BUF_"+str(vi$temp_buf_num), "");
			vi$temp_buf_num := vi$temp_buf_num + 1;
		ELSE
			ERASE (dest);
		ENDIF;

		POSITION (dest);
		COPY_TEXT (source);
	ENDIF;

	POSITION (pos);
ENDPROCEDURE;

!
!	Given the string representation of either VI$LINE_MODE or VI$IN_LINE_MODE,
!	place that text into the buffer given by dest.
!
PROCEDURE vi$type2buf (source, dest)
	LOCAL
		pos;

	pos := MARK (NONE);

	IF (source <> 0) THEN
		IF (dest = 0) THEN
			dest := vi$init_buffer ("TEMP_BUF_"+str(vi$temp_buf_num), "");
			vi$temp_buf_num := vi$temp_buf_num + 1;
		ELSE
			ERASE (dest);
		ENDIF;

		POSITION (BEGINNING_OF (dest));
		COPY_TEXT (source);
		SPLIT_LINE;
	ENDIF;

	POSITION (pos);
ENDPROCEDURE;

!
!	Save a piece of yanked text including the mode that it was yanked.
!
PROCEDURE vi$put2yank_buf (string_parm, dest_buf)

	LOCAL
		pos;

	pos := MARK (NONE);

	! Set type of text in buffer.

	IF (vi$append_it = 0) THEN
		vi$type2buf (STR (vi$yank_mode), dest_buf);
	ELSE

		! If empty buffer then put in type.

		IF (GET_INFO (dest_buf, "RECORD_COUNT") < 2) THEN
			vi$type2buf (STR (vi$yank_mode), dest_buf);
		ENDIF;
		vi$append_it := 0;
	ENDIF;
	vi$cp2buf (string_parm, dest_buf);
	POSITION (pos);

	RETURN (dest_buf);
ENDPROCEDURE;

!
!	This is a debugging procedure used to view the contents of a buffer.
!	It displays the buffer indicated by 'buf', and sets the status line
!	of the window displayed to contain the text given by 'stat_line'.
!
PROCEDURE vi$show_buf (buf, stat_line)
	LOCAL
		this_key,
		pos,
		new_win;

	IF (GET_INFO (buf, "TYPE") <> BUFFER) THEN
		vi$info ("show_buf called with non_buffer, message: "+stat_line);
		RETURN;
	ENDIF;

	pos := MARK (NONE);
	new_win := CREATE_WINDOW (1, 23, ON);
	MAP (new_win, buf);
	POSITION (buf);
	SET (STATUS_LINE, new_win, REVERSE, stat_line +
				", BUFFER NAME: '"+GET_INFO (buf, "NAME")+"'");
	vi$pos_in_middle (MARK (NONE));
	UPDATE (new_win);
	LOOP
		vi$info ("Press RETURN to continue editing...");
		this_key := READ_KEY;
		EXITIF (this_key = RET_KEY);

		IF (this_key = CTRL_D_KEY) OR
		   (this_key = CTRL_U_KEY) OR
		   (this_key = CTRL_F_KEY) OR
		   (this_key = CTRL_B_KEY) OR
		   (this_key = KEY_NAME ('h')) OR
		   (this_key = KEY_NAME ('j')) OR
		   (this_key = KEY_NAME ('k')) OR
		   (this_key = KEY_NAME ('l')) THEN

			EXECUTE (LOOKUP_KEY (this_key, PROGRAM, vi$cmd_keys));
			UPDATE (new_win);
		ENDIF;
	ENDLOOP;

	UNMAP (new_win);
	DELETE (new_win);
	POSITION (pos);
	UPDATE (CURRENT_WINDOW);
ENDPROCEDURE;

!
!	This procedure moves the cursor down the number of lines indicated by
!	vi$active count.  The parameter passed is used by delete and yank
!	operations to differentiate them from normal cursor movement.
!
PROCEDURE vi$downline (adj)

	LOCAL
		pos,
		tabstops,
		cur_off,
		offset;

	!  Ignore error messages

	ON_ERROR
		vi$active_count := 0;
		POSITION (pos);
		RETURN (0);
	ENDON_ERROR;

	pos := MARK (NONE);

	POSITION (LINE_BEGIN);
	vi$start_pos := MARK (NONE);

	POSITION (pos);

	tabstops := GET_INFO (CURRENT_BUFFER, "TAB_STOPS");

	IF (GET_INFO (tabstops, "TYPE") <> STRING) THEN
		offset := CURRENT_OFFSET;
		cur_off := GET_INFO (SCREEN, "CURRENT_COLUMN") - 1;
		MOVE_VERTICAL (vi$cur_active_count + adj);
		POSITION (LINE_BEGIN);
		IF (vi$new_offset = 1) THEN
			vi$max_offset := cur_off;
			vi$new_offset := 0;
		ELSE
			IF (cur_off < vi$max_offset) THEN
				cur_off := vi$max_offset;
			ENDIF;
		ENDIF;

		!  Save the beginning of the line as the new beginning.

		vi$new_endpos := MARK (NONE);
		IF (vi$new_endpos = END_OF (CURRENT_BUFFER)) THEN
			POSITION (pos);
			vi$yank_mode := VI$LINE_MODE;
			RETURN (0);
		ENDIF;
		vi$to_offset (vi$current_line, cur_off, tabstops);
	ELSE
		MOVE_VERTICAL (vi$cur_active_count + adj);
	ENDIF;

	vi$yank_mode := VI$LINE_MODE;
	RETURN (vi$retpos (pos));
ENDPROCEDURE;       

!
! Move left one location.  Do not wrap at edge of the screen.
!
PROCEDURE vi$left

	LOCAL
		pos;

	!  Ignore error messages

	ON_ERROR
		vi$active_count := 0;
		POSITION (pos);
		RETURN (0);
	ENDON_ERROR;

	pos := MARK (NONE);

	vi$new_offset := 1;
	IF (CURRENT_OFFSET < vi$active_count) OR (CURRENT_OFFSET = 0) THEN
		vi$active_count := 0;
		RETURN (0);
	ENDIF;

	MOVE_HORIZONTAL (-vi$cur_active_count);
	vi$yank_mode := VI$IN_LINE_MODE;
	RETURN (vi$retpos (pos));
ENDPROCEDURE;

!
! Move right one location.  Stop at the end of the line, but, do not
! wrap at edge of the screen.
!
PROCEDURE vi$right

	LOCAL
		pos,
		line,
		offset;

	!  Ignore error messages

	ON_ERROR
		vi$active_count := 0;
		POSITION (pos);
		RETURN (0);
	ENDON_ERROR

	pos := MARK (NONE);

	line := CURRENT_LINE;
	offset := CURRENT_OFFSET;

	! This makes it possible to use the "s" command at the end of the line.

	IF (vi$command_type <> VI$OTHER_TYPE) THEN
		offset := offset - 1;
		IF (LENGTH (CURRENT_LINE) = 0) THEN
			COPY_TEXT (" ");
			MOVE_HORIZONTAL (-1);	
			vi$start_pos := MARK (NONE);
		ENDIF;
	ENDIF;

	IF (vi$active_count < (LENGTH (line) - offset - 
									(vi$command_type = VI$OTHER_TYPE))) THEN
		MOVE_HORIZONTAL (vi$cur_active_count);
	ELSE
		vi$active_count := 0;
		RETURN (0);
	ENDIF;

	vi$new_offset := 1;

	vi$yank_mode := VI$IN_LINE_MODE;
	RETURN (vi$retpos (pos));
ENDPROCEDURE;

!
! Move up one row, staying in the same column.  Scroll if necessary.
!
PROCEDURE vi$upline

	LOCAL
		pos,
		tabstops,
		offset,
		cur_off;

	!  Ignore error messages

	ON_ERROR
		vi$active_count := 0;
		POSITION (pos);
		RETURN (0);
	ENDON_ERROR;

	pos := MARK (NONE);

	tabstops := GET_INFO (CURRENT_BUFFER, "TAB_STOPS");

	POSITION (LINE_END);
	vi$new_endpos := MARK(NONE);

	POSITION (pos);

	! We must understand it (i.e. it must be an integer) inorder to process
	! the tabs properly.

	IF (GET_INFO (tabstops, "TYPE") <> STRING) THEN
		offset := CURRENT_OFFSET;

		cur_off := GET_INFO (SCREEN, "CURRENT_COLUMN") - 1;
		MOVE_VERTICAL(-vi$cur_active_count);
		POSITION (LINE_BEGIN);

		IF vi$new_offset = 1 THEN
			vi$max_offset := cur_off;
			vi$new_offset := 0;
		ENDIF;

		IF (cur_off < vi$max_offset) THEN
			cur_off := vi$max_offset;
		ENDIF;

		!  Save the beginning of the line as the new beginning.

		vi$start_pos := MARK (NONE);
		vi$to_offset (CURRENT_LINE, cur_off, tabstops);
	ELSE
		MOVE_VERTICAL (-vi$cur_active_count);
	ENDIF;
	vi$yank_mode := VI$LINE_MODE;
	RETURN (vi$retpos (pos));
ENDPROCEDURE;

!
!	Move the cursor to the offset given by 'offset' counting tabs as expanded
!	spaces.
!
PROCEDURE vi$to_offset (line, offset, tabstops)
	LOCAL
		cur_ch,
		col,
		diff,
		len,
		tab,
		idx;

	idx := 1;
	col := 0;
	len := LENGTH (line);
	tab := ASCII (9);

	LOOP
		EXITIF (len < idx) OR (col >= offset);
		IF (SUBSTR (line, idx, 1) = tab) THEN
			diff := (((col+tabstops)/tabstops)*tabstops)-col;
		ELSE
			diff := 1;
		ENDIF;
		col := col + diff;
		idx := idx + 1;
	ENDLOOP;

	!  Move N characters to the right.

	MOVE_HORIZONTAL (idx - 1);
ENDPROCEDURE;

!
!	Search for a text string.  This procedure is activated by typing
!	either a '/' or a '?'.
!
PROCEDURE vi$search (direction)
	LOCAL
		where,
		i,
		pos,
		ch,
		sstr,
		cnt,
		add_spec,
		prompt;

	pos := MARK (NONE);

	IF (direction > 0) THEN
		prompt := "/";
	ELSE
		prompt := "?";
	ENDIF;

	IF (vi$read_a_line (prompt, sstr) = 0) THEN
		RETURN (0);
	ENDIF;

	i := 1;
	LOOP
		EXITIF (i > LENGTH (sstr));
		ch := SUBSTR (sstr, i, 1);
		IF (ch = "\") THEN
			i := i + 1;
		ELSE
			EXITIF (ch = prompt);
		ENDIF;
		i := i + 1;
	ENDLOOP;

	! If the search string is followed by the delimiter, then allow an
	! additional line offset specification.

	add_spec := 0;
	IF (ch = prompt) THEN
		add_spec := SUBSTR (sstr, i+1, 255);
		sstr := SUBSTR (sstr, 1, i-1);
	ENDIF;

	IF (direction > 0) THEN
		SET (FORWARD, CURRENT_BUFFER);
		vi$last_search_dir := 1;
		vi$move_horizontal (1);
	ELSE
		SET (REVERSE, CURRENT_BUFFER);
		vi$last_search_dir := -1;
	ENDIF;

	IF sstr <> "" THEN
		vi$search_string := sstr;
	ELSE
		IF vi$search_string = 0 THEN
			vi$info ("No previous string to search for!");
			POSITION (pos);
			RETURN (0);
		ENDIF;
	ENDIF;

	! Search for the nth occurance.

	cnt := vi$cur_active_count;
	LOOP
		where := vi$find_str (vi$search_string, 0, 0);
		EXITIF (where = 0);
		POSITION (BEGINNING_OF (where));
		IF (CURRENT_DIRECTION = FORWARD) THEN
			MOVE_HORIZONTAL (1);
		ELSE
			MOVE_HORIZONTAL (-1);
		ENDIF;
		cnt := cnt - 1;
		EXITIF cnt = 0;
	ENDLOOP;

	! Check to see that we found one.

	IF (where = 0) THEN
		vi$info ("String not found");
	ELSE

		! Check for a relative line number after the search string.

		IF add_spec <> 0 THEN
			POSITION (where);
			IF add_spec = "-" THEN
				add_spec := "-1";
			ELSE
				IF (SUBSTR (add_spec, 1, 1) = "+") THEN
					IF (add_spec = "+") THEN
						add_spec := "1";
					ENDIF;
				ELSE
		   			add_spec := SUBSTR (add_spec, 2, 255);
				ENDIF;
			ENDIF;

			i := INT (add_spec);
			MOVE_VERTICAL (i);
			vi$_bol (0);
			where := MARK (NONE);
		ELSE
			POSITION (BEGINNING_OF (where));
			bpos := MARK (NONE);
			POSITION (END_OF (where));
			vi$find_rng := CREATE_RANGE (bpos, MARK(NONE), BOLD);
		ENDIF;
	ENDIF;   

	POSITION (pos);

	! On success then return the position we moved to.

	RETURN (where);
ENDPROCEDURE;

!
!	Search for the next occurence of the previously searched for string.
!	The procedure is actived by typing an 'n' or 'N' keystroke.
!
PROCEDURE vi$search_next (direction)
	LOCAL
		prompt,
		where,
		pos,
		cnt,
		sstr;

	pos := MARK (NONE);

	IF vi$search_string = 0 THEN
		vi$info ("No previous string to search for!");
		POSITION (pos);
		RETURN (0);
	ENDIF;

	IF (direction > 0) THEN
		prompt := "/" + vi$search_string;
		SET (FORWARD, CURRENT_BUFFER);
		IF (MARK (NONE) <> END_OF (CURRENT_BUFFER)) THEN
			MOVE_HORIZONTAL (1);
		ELSE
			IF (vi$wrap_scan = 1) THEN
		   		POSITION (BEGINNING_OF (CURRENT_BUFFER));
			ENDIF;
		ENDIF;
	ELSE
		prompt := "?" + vi$search_string;
		SET (REVERSE, CURRENT_BUFFER);
		IF (MARK (NONE) <> BEGINNING_OF (CURRENT_BUFFER)) THEN
			IF (SUBSTR (prompt, 1, 3) = "?\<") THEN
				MOVE_HORIZONTAL (-2);
			ELSE
				MOVE_HORIZONTAL (-1);
			ENDIF;
		ELSE
			IF (vi$wrap_scan = 1) THEN
				POSITION (END_OF (CURRENT_BUFFER));
			ENDIF;
		ENDIF;
	ENDIF;

	MESSAGE (prompt);

	! On success then return the position we moved to.

	cnt := vi$cur_active_count;
	LOOP
		where := vi$find_str (vi$search_string, 0, 0);
		EXITIF (where = 0);
		POSITION (BEGINNING_OF (where));
		IF (CURRENT_DIRECTION = FORWARD) THEN
			MOVE_HORIZONTAL (1);
		ELSE    
	   		MOVE_HORIZONTAL (-1);
		ENDIF;
		cnt := cnt - 1;
		EXITIF cnt = 0;
	ENDLOOP;

	IF (where = 0) THEN
		vi$info ("String not found");
	ELSE
		POSITION (BEGINNING_OF (where));
		bpos := MARK (NONE);
		POSITION (END_OF (where));
		vi$find_rng := CREATE_RANGE (bpos, MARK(NONE), BOLD);
	ENDIF;

	POSITION (pos);
	RETURN (where);
ENDPROCEDURE;

!
!	This procedure can be used to find a string of text (using RE's).
!	The current direction of the BUFFER is used to determine which way
!	the search goes.  'replace' is used by the replace code to indicate
!	that wrap scan should be performed.
!
PROCEDURE vi$find_str (sstr, replace, do_parens)
	LOCAL
		pos,
		new_pat,      
		start,
		where;

	ON_ERROR
	ENDON_ERROR;

	pos := MARK (NONE);
	vi$paren_cnt := 0;
	IF vi$magic THEN
		new_pat := vi$re_pattern_gen (sstr, vi$paren_cnt, do_parens);
	ELSE
		new_pat := vi$pattern_gen (sstr);
	ENDIF;

	IF (new_pat <> 0) THEN
		EXECUTE (COMPILE ("vi$_find_pat := " + new_pat));
		where := SEARCH (vi$_find_pat, CURRENT_DIRECTION, vi$ignore_case);
		IF (where = 0) AND (vi$wrap_scan = 1) AND (replace = 0) THEN
			IF (CURRENT_DIRECTION = FORWARD) THEN
				POSITION (BEGINNING_OF (CURRENT_BUFFER));
			ELSE
				POSITION (END_OF (CURRENT_BUFFER));
			ENDIF;
			vi$info ("Search wrapped at buffer boundry!");
			where := SEARCH (vi$_find_pat, CURRENT_DIRECTION, vi$ignore_case);
		ENDIF;
	ELSE
		where := 0;
	ENDIF;

	IF (where <> 0) AND (vi$in_ws) THEN
		POSITION (BEGINNING_OF (where));
		IF (CURRENT_OFFSET <> 0) OR
								(INDEX (vi$_ws, CURRENT_CHARACTER) <> 0) THEN
			MOVE_HORIZONTAL (1);
		ENDIF;
		start := MARK (NONE);
		POSITION (END_OF (where));
		IF (CURRENT_OFFSET <> LENGTH (CURRENT_LINE)) THEN
			MOVE_HORIZONTAL (-1);
		ENDIF;
		where := CREATE_RANGE (start, MARK (NONE), NONE);
		POSITION (pos);
	ENDIF;
	RETURN (where);
ENDPROCEDURE;

!
!	Generate a TPU pattern string, not using RE's, i.e. :set nomagic is
!	in effect when this routine is used.
!
PROCEDURE vi$pattern_gen (pat)

	LOCAL
		first,		! First pattern to be done
		part_pat,
		chno,
		startchar,
		haveany,
		regular,
		tstr,
		endchar,
		str_pat,
		cur_pat,	! The current pattern to be extracted
		cur_char,	! The current character in the regular
					! expression being examined
		new_pat,	! The output pattern
		pos;       	! The position within the regular
					! expression string that we are examining
					! currently

	IF (INDEX (pat, "$") <> 0) OR (INDEX (pat, "^") <> 0) THEN
		new_pat := "";
	ELSE
		new_pat := '"'+pat+'"';
		RETURN (new_pat);
	ENDIF;

	pos := 1;

	IF SUBSTR (pat, pos, 1) = "^" THEN
		IF LENGTH (pat) > 1 THEN
			new_pat := "line_begin & '";
		ELSE
			new_pat := "line_begin";
		ENDIF;
		pos := pos + 1;
	ENDIF;

	LOOP
		EXITIF (pos > LENGTH (pat));

		regular := 0;
		cur_pat := "";
		cur_char := substr (pat, pos, 1);

		IF (cur_char = "$") AND (pos+1 >= LENGTH (pat)) THEN
			IF pos <> 1 THEN
				cur_pat := "' & line_end";
			ELSE
				cur_pat := "line_end";
			ENDIF;
		ELSE
			cur_pat := cur_char;
			regular := 1;
		ENDIF;

		IF (regular) THEN
			new_pat := new_pat + cur_pat;
		ELSE
			IF new_pat = "" THEN
				new_pat := cur_pat;
			ELSE
				new_pat := new_pat + "&" + cur_pat;
			ENDIF;
		ENDIF;

		pos := pos + 1;

	ENDLOOP;

	IF (regular) THEN
		new_pat := new_pat + "'";
	ENDIF;
	RETURN (new_pat);
ENDPROCEDURE;
!
!
! TPU pattern generator.  Generates a pattern string from the passed
! RE string.  The function is used when :set magic is in effect.
!
PROCEDURE vi$re_pattern_gen (pat, paren_cnt, do_parens)

	LOCAL
		first,      ! First pattern to be done
		part_pat,
		chno,
		startchar,
		haveany,
		regular,
		tstr,
		endchar,
		pat_str,
		str_pat,
		cur_pat, ! The current pattern to be extracted
		cur_char,    ! The current character in the regular
					! expression being examined
		new_pat,    ! The output pattern
		in_ws,
		pos;        ! The position within the regular
					! expression string that we are examining
					! currently

	vi$in_ws := 0;
	IF ((INDEX (pat, "$") <> 0) OR (INDEX (pat, "[") <> 0) OR
					(INDEX (pat, "^") <> 0) OR (INDEX (pat, ".") <> 0) OR
						(INDEX (pat, "*") <> 0) OR (INDEX (pat, "\") <> 0) OR
						(INDEX (pat, '"') <> 0)) THEN
		new_pat := "";
	ELSE
		new_pat := '"'+pat+'"';
		RETURN (new_pat);
	ENDIF;

	in_ws := 0;
	pos := 1;

	IF SUBSTR (pat, pos, 1) = "^" THEN
		new_pat := "line_begin";
		pos := pos + 1;
	ENDIF;

	LOOP
		EXITIF (pos > LENGTH (pat));

		regular := 0;
		cur_pat := "";
		cur_char := substr (pat, pos, 1);
		pat_str := "";

		IF (cur_char = "$") AND (pos = LENGTH (pat)) THEN
			cur_pat := "line_end";
		ELSE
			IF cur_char = "[" THEN
				pos := pos + 1;

				IF SUBSTR (pat, pos, 1) = "^" THEN
					pos := pos + 1;
					part_pat := "notany('";
				ELSE
					part_pat := "any('";
				ENDIF;

				LOOP
					EXITIF pos > LENGTH (pat);
					EXITIF SUBSTR (pat, pos, 1) = "]";

					IF SUBSTR (pat, pos, 1) = "\" THEN
						pos := pos + 1;
						IF pos > LENGTH (pat) THEN
							vi$info ("Missing character after \");
							RETURN (0);
						ENDIF;
					ENDIF;

					startchar := SUBSTR (pat, pos, 1);
					pat_str := pat_str + startchar;
					IF startchar = "'" THEN
						pat_str := pat_str + "'";
					ENDIF;

					IF (SUBSTR (pat, pos+1, 1) = '-') THEN
						pos := pos + 2;
						IF (pos >= LENGTH (pat)) THEN
							vi$info ("Missing character after '-'");
							RETURN (0);
						ENDIF;

						endchar := SUBSTR (pat, pos, 1);

						chno := 1;
						LOOP
							EXITIF (ASCII(chno) = startchar);
							chno := chno + 1;
						ENDLOOP;

						LOOP   
							chno := chno + 1;
							IF (chno > 255) THEN
								vi$info (
									"Invalid character sequence for '-'");
								RETURN (0);
							ENDIF;

							EXITIF (ASCII (chno-1) = endchar);
							pat_str := pat_str + ASCII (chno);
							IF ASCII (chno) = "'" THEN
								pat_str := pat_str + "'";
							ENDIF;
						ENDLOOP;
					ENDIF;
					pos := pos + 1;
				ENDLOOP;

				IF pat_str = "" THEN
					vi$info ("No text found between []");
					RETURN (0);
				ENDIF;

				IF (SUBSTR (pat, pos+1, 1) = "*") THEN
					IF (part_pat = "notany('") THEN
						cur_pat := cur_pat + "(scan('"+pat_str+"')|"""")";
					ELSE
						cur_pat := cur_pat + "(span('"+pat_str+"')|"""")";
					ENDIF;
					pos := pos + 1;
				ELSE
					cur_pat := part_pat + pat_str + "')";
				ENDIF;
			ELSE

				tstr := '"';
				haveany := 0;
				regular := 1;

				LOOP
					cur_char := SUBSTR (pat, pos, 1);
					EXITIF (cur_char = "[") OR
							((cur_char = "$") AND (pos = LENGTH (pat)));
					EXITIF (pos > LENGTH (pat));

					IF cur_char = "\" THEN
						pos := pos + 1;
						startchar := SUBSTR (pat, pos, 1);
						IF (do_parens) THEN
							IF (startchar = "(") THEN
								paren_cnt := paren_cnt + 1;

								IF tstr = '"' THEN
									tstr := '""@o'+STR(paren_cnt)+'&"';
								ELSE
									tstr := tstr + '"@o'+STR(paren_cnt)+'&"';
								ENDIF;
							ELSE
								IF (startchar = ")") THEN
									IF (paren_cnt = 0) THEN
										vi$info (
											FAO ("No previous ""\("" near: !AS",
											SUBSTR (pat, pos, LENGTH(pat)-pos))
										);
										RETURN (0);
									ENDIF;

									IF tstr = '"' THEN
										tstr := '""@p'+STR(paren_cnt)+'&"';
									ELSE
										tstr := tstr + '"@p' + 
													STR(paren_cnt)+'&"';
									ENDIF;
								ELSE
									IF (startchar = "<") THEN
										in_ws := 1;
										vi$in_ws := 1;
										tstr := tstr +
											'"&(line_begin | any (vi$_ws))&"';
									ELSE
										IF (startchar = ">") THEN
											in_ws := 0;
											tstr := tstr +
												'"&(line_end | any (vi$_ws))&"';
										ELSE
											tstr := tstr + SUBSTR (pat, pos, 1);
										ENDIF;
									ENDIF;
								ENDIF;
							ENDIF;
						ELSE
							IF (startchar = "<") THEN
								in_ws := 1;
								vi$in_ws := 1;
								tstr := tstr +
									'"&(line_begin | any (vi$_ws))&"';
							ELSE
								IF (startchar = ">") THEN
									in_ws := 0;
									tstr := tstr
										+ '"&(line_end | any (vi$_ws))&"';
								ELSE
									tstr := tstr + startchar;
								ENDIF;
							ENDIF;
						ENDIF;
					ELSE
						IF (cur_char = ".") THEN
							cur_char := "longer_than_1";
						ENDIF;

						IF (SUBSTR (pat, pos+1, 1) = '*') THEN
							pos := pos + 1;

							IF (LENGTH (cur_char) > 1) THEN
								cur_pat := "span(vi$pch)";
							ELSE
								cur_pat := "span('"+cur_char+"')";
							ENDIF;
							tstr := tstr+'"&'+cur_pat+'&"';
							haveany := 0;
						ELSE
							IF (LENGTH (cur_char) > 1) THEN
								IF (haveany) THEN
									tstr := tstr +'"&'+"arb(1)"+'&"';
									haveany := 0;
								ELSE
									IF (LENGTH (tstr)>0) and (tstr <> '"') THEN
										tstr := tstr +'"&'+"arb(1)"+'&"';
									ELSE
										tstr := "arb(1)"+'&"';
									ENDIF
								ENDIF;
							ELSE
								IF (cur_char = """") THEN
									tstr := tstr + '""';
									haveany := haveany + 2;
								ELSE
									tstr := tstr + cur_char;
									haveany := haveany + 1;
								ENDIF;
							ENDIF;
						ENDIF;
					ENDIF;
					pos := pos + 1;
				ENDLOOP;
				cur_pat := tstr + '"';
				pos := pos - 1;
			ENDIF;
		ENDIF;

		IF (regular) THEN
			IF new_pat = "" THEN
				new_pat := cur_pat;
			ELSE
				IF (LENGTH (tstr) > 1) THEN
					new_pat := new_pat + "&" + cur_pat;
				ENDIF;
			ENDIF;
		ELSE
			IF new_pat = "" THEN
				new_pat := cur_pat;
			ELSE
				new_pat := new_pat + "&" + cur_pat;
			ENDIF;
		ENDIF;
		pos := pos + 1;

	ENDLOOP;

	IF (in_ws) THEN
		vi$info ("Missing \> in pattern!");
		RETURN (0);
	ENDIF;

	RETURN (new_pat);
ENDPROCEDURE;

!
!	Match brackets when '%' is typed.
!
PROCEDURE vi$_match_brackets
	vi$beep_position (vi$match_brackets, 1, 1);
ENDPROCEDURE;

!
!	Perform the actual match bracket operation.
!
PROCEDURE vi$match_brackets
	LOCAL
		newpos,
		ind_pos,
		found,
		cur_ch,
		cur_dir,
		pos;

	ON_ERROR
		IF ERROR = TPU$_CONTROLC THEN
			vi$beep;
			vi$pasthru_on;
			RETURN (0);
		ENDIF;
	ENDON_ERROR;

	found := 1;
	MESSAGE ("");
	pos := MARK (NONE);
	cur_ch := CURRENT_CHARACTER;
	ind_pos := INDEX (vi$bracket_chars, cur_ch);

	IF (ind_pos = 0) THEN
		newpos := SEARCH (ANCHOR & SCAN (")") & ARB (1), FORWARD, EXACT);
		found := 0;
		IF newpos <> 0 THEN
			found := 1;
			IF vi$in_show_match = 0 THEN
				vi$old_place := pos;
			ENDIF;
			POSITION (END_OF (newpos));
			RETURN (vi$retpos (pos));
		ELSE
			POSITION (pos);
			RETURN (0);
		ENDIF;
	ENDIF;

	IF ((ind_pos/2)*2 <> ind_pos) THEN
		cur_dir := FORWARD;
	ELSE
		cur_dir := REVERSE;
	ENDIF;     

	SET (TIMER, ON, "Searching...");
	newpos := vi$do_match (CURRENT_CHARACTER, cur_dir, 0);
	SET (TIMER, OFF);

	IF (GET_INFO (newpos, "TYPE") = MARKER) THEN
		RETURN (vi$retpos (pos));
	ELSE
		IF (newpos = 0) AND NOT (vi$in_show_match) THEN
			vi$info ("No matching bracket");
		ENDIF;
		POSITION (pos);
	ENDIF;
	RETURN (0);
ENDPROCEDURE;
!
!
!  This procedure knows how to traverse nested brackets to find the matching
!  bracket.  It takes the character that the cursor is positioned on, and
!  finds the matching one.  It recognizes '{}', '[]', '()' pairs.
!
PROCEDURE vi$do_match (bracket, cur_dir, level)

	LOCAL
		dgrp,
		dest_char,
		sel_reg,
		ind_pos,
		next_pos,
		possibles,
		cur_ch;

	ON_ERROR
		RETURN (0);
	ENDON_ERROR;

	IF level > 30 THEN
		vi$info ("Too many nested levels");
		RETURN (-1);
	ENDIF;

	! Identify the desired search direction based on the character.

	ind_pos := INDEX (vi$bracket_chars, bracket);
	dest_char := SUBSTR ("}{)(][", ind_pos, 1);

	IF cur_dir = FORWARD THEN
		MOVE_HORIZONTAL (1);
	ELSE
		MOVE_HORIZONTAL (-1);
	ENDIF;

	dgrp := bracket + dest_char;
	LOOP
		sel_reg := SEARCH (ANY (dgrp), cur_dir, EXACT);

		IF sel_reg = 0 THEN
			RETURN (0);
		ENDIF;

		POSITION (BEGINNING_OF (sel_reg));

		IF (CURRENT_CHARACTER = dest_char) THEN
			RETURN (MARK (NONE));
		ELSE
			IF (((INDEX ("([{", CURRENT_CHARACTER) <> 0) AND
							(cur_dir = FORWARD)) OR
					((INDEX (")}]", CURRENT_CHARACTER) <> 0) AND
							(cur_dir = REVERSE))) THEN

				IF (INDEX (vi$bracket_chars, CURRENT_CHARACTER)-1)/2 <=
							(INDEX (vi$bracket_chars, dest_char)-1)/2 THEN

					next_pos := vi$do_match (CURRENT_CHARACTER,
					   										cur_dir, level+1);

					IF (next_pos <> 0) AND (next_pos <> -1) THEN
						POSITION (next_pos);
					ELSE
						RETURN (next_pos);
					ENDIF;
				ENDIF;
			ELSE
				IF (INDEX (vi$bracket_chars, CURRENT_CHARACTER) = 0) THEN
					vi$info ("Unknown bracket character: '"+
													CURRENT_CHARACTER+"'");
					RETURN (-1);
				ENDIF;
			ENDIF;

			IF cur_dir = FORWARD THEN
				MOVE_HORIZONTAL (1);
			ELSE
				MOVE_HORIZONTAL (-1);
			ENDIF;
		ENDIF;
	ENDLOOP;
ENDPROCEDURE;

!
!	Move to the top line of the window when 'H' is pressed.
!
PROCEDURE vi$home
	POSITION (vi$to_home);
ENDPROCEDURE;

!
!	Perform the actual movement for the 'H' command and return the marker.
!
PROCEDURE vi$to_home

	LOCAL
		pos;

	ON_ERROR
		! Ignore attempt to move beyond end of buffer errors.
	ENDON_ERROR;

	pos := MARK (NONE);
	MOVE_VERTICAL ( GET_INFO (CURRENT_WINDOW, "VISIBLE_TOP") -
					GET_INFO (CURRENT_WINDOW, "CURRENT_ROW"));

	vi$yank_mode := VI$LINE_MODE;
	RETURN (vi$retpos(pos));
ENDPROCEDURE

!
!	Position the cursor into the middle of the current window when 'M' is
!	pressed.
!
PROCEDURE vi$middle
	POSITION (vi$to_middle);
ENDPROCEDURE;

!
!	Perform the actual movement of the 'M' command.
!
PROCEDURE vi$to_middle

	LOCAL
		len,
		cur,
		top,
		pos;

	ON_ERROR
		! Ignore attempt to move beyond end of buffer errors.
	ENDON_ERROR;

	pos := MARK (NONE);

	len := GET_INFO (CURRENT_WINDOW, "VISIBLE_LENGTH");
	cur := GET_INFO (CURRENT_WINDOW, "CURRENT_ROW");
	top := GET_INFO (CURRENT_WINDOW, "VISIBLE_TOP");

	MOVE_VERTICAL ((top + len/2 - 1) - cur);

	vi$yank_mode := VI$LINE_MODE;
	RETURN (vi$retpos(pos));
ENDPROCEDURE;

!
!	Move the the last line of the current window when 'L' is pressed.
!
PROCEDURE vi$last
	POSITION (vi$to_last);
ENDPROCEDURE;

!
!	Perform the actual movement associated with the 'L' command.
!
PROCEDURE vi$to_last

	LOCAL
		pos;

	ON_ERROR
		! Ignore attempt to move beyond end of buffer errors.
	ENDON_ERROR;

	pos := MARK (NONE);
	MOVE_VERTICAL ( GET_INFO (CURRENT_WINDOW, "VISIBLE_BOTTOM") -
					GET_INFO (CURRENT_WINDOW, "CURRENT_ROW"));

	vi$yank_mode := VI$LINE_MODE;
	RETURN (vi$retpos (pos));
ENDPROCEDURE

!
!	Move to the end of the current line when '$' is pressed.
!
PROCEDURE vi$_eol
	POSITION (vi$eol);
ENDPROCEDURE;

!
!	Perform the actual movement associated with the '$' command.
!
PROCEDURE vi$eol
	LOCAL
		cnt,
		pos;

	ON_ERROR
		POSITION (pos);
		vi$active_count := 0;
		RETURN (0);
	ENDON_ERROR;

	pos := MARK (NONE);
	POSITION (LINE_BEGIN);
	cnt := vi$active_count;
	IF cnt = 0 THEN
		cnt := 1;
	ENDIF;
	MOVE_VERTICAL (cnt - 1);
	IF (CURRENT_CHARACTER = "") THEN
		RETURN (0);
	ENDIF;

	POSITION (LINE_END);
	vi$check_rmarg;

	IF (vi$active_count > 0) THEN
		vi$yank_mode := VI$LINE_MODE;
	ELSE
		vi$yank_mode := VI$IN_LINE_MODE;
	ENDIF;
	vi$active_count := 0;
	RETURN (vi$retpos (pos));
ENDPROCEDURE;

!
!	Move the first non-blank character of the line when '^' is typed.
!
PROCEDURE vi$_bol (use_cur_active)
	vi$beep_position (vi$first_no_space (use_cur_active), 0, 1);
ENDPROCEDURE;

!
!	Move the beginning of the line when '0' is typed.
!
PROCEDURE vi$fol
	LOCAL
		pos;

	pos := MARK (NONE);
	POSITION (LINE_BEGIN);
	vi$yank_mode := VI$IN_LINE_MODE;
	vi$new_offset := 1;
	RETURN (vi$retpos (pos));
ENDPROCEDURE;

!
!	Move the the location searched for.
!
PROCEDURE vi$_search (direction)
	LOCAL
		opos,
		pos;

	opos := MARK (NONE);
	pos := vi$search(direction);

	IF (vi$beep_position (pos, 1, 0) <> 0) THEN
		POSITION (opos);
		vi$pos_in_middle (pos);
	ENDIF;
ENDPROCEDURE;

!
!	Move to the next location of the string previously searched for.
!
PROCEDURE vi$_search_next (direction)
	LOCAL
		opos,
		pos;

	opos := MARK(NONE);
	pos := vi$search_next(direction);

	IF (vi$beep_position (pos, 1, 0) <> 0) THEN
		POSITION (opos);
		vi$pos_in_middle (pos);
	ENDIF;
ENDPROCEDURE;

!         
!	Repeat the last 't' or 'f' command backwards.
!
PROCEDURE vi$_repeat_torf_back
	vi$beep_position (vi$repeat_torf_back, 0, 1);
ENDPROCEDURE

!
!	Repeat the last 't' or 'f' command.
!
PROCEDURE vi$_repeat_torf
	vi$beep_position (vi$repeat_torf, 0, 1);
ENDPROCEDURE

!
!	Return the location found by repeating the last 't', 'f', 'T' or 'F'
!	command backwards.
!
PROCEDURE vi$repeat_torf_back
	LOCAL
		ch,
		old_func,
		back_func;

	IF vi$last_s_func = 0 THEN
		RETURN (0);
	ENDIF;

	old_func := vi$last_s_func;
	IF (vi$last_s_func = "vi$back_find_char") THEN
		back_func := "vi$find_char";
	ENDIF;

	IF (vi$last_s_func = "vi$find_char") THEN
		back_func := "vi$back_find_char";
	ENDIF;

	IF (vi$last_s_func = "vi$back_to_char") THEN
		back_func := "vi$to_char";
	ENDIF;

	IF (vi$last_s_func = "vi$to_char") THEN
		back_func := "vi$back_to_char";
	ENDIF;

	vi$global_var := 0;
	ch := vi$last_s_char;
	IF (ch = "'") THEN
		ch := "''";
	ENDIF;

	EXECUTE (COMPILE (
		"vi$global_var := " + back_func + "('"+ ch + "')"));
	vi$last_s_func := old_func;
	RETURN (vi$global_var);
ENDPROCEDURE

!
!	Return the location found by repeating the last 't', 'f', 'T' or 'F'
!	command.
!
PROCEDURE vi$repeat_torf

	LOCAL
		ch;

	vi$global_var := 0;
	ch := vi$last_s_char;
	IF (ch = "'") THEN
		ch := "''";
	ENDIF;
	IF (vi$last_s_func <> 0) THEN
		EXECUTE (COMPILE (
			"vi$global_var := " + vi$last_s_func + "('"+ ch + "')"));
	ELSE
		vi$beep;
	ENDIF;
	RETURN (vi$global_var);
ENDPROCEDURE

!
!	Return the value of a positive integer that is represented as a string.
!	If the string is not a valid integer, then -1 is retured.
!
PROCEDURE vi$number_from_string (str_num)
	ON_ERROR
		RETURN (-1);
	ENDON_ERROR;

	RETURN (INT (str_num));
ENDPROCEDURE;

!
!	Move to the line indicated by 'line_no', and return the marker that
!	indicates the beginning of that line.
!
PROCEDURE vi$mark_line (line_no)

	LOCAL
		pos;

	ON_ERROR
		POSITION (pos);
		RETURN (0);
	ENDON_ERROR;

	pos := MARK (NONE);
	POSITION (BEGINNING_OF (CURRENT_BUFFER));
	MOVE_VERTICAL (line_no - 1);
	RETURN (vi$retpos (pos));
ENDPROCEDURE;

!
!	Perform an EX mode command after a ':' is typed.
!
PROCEDURE vi$ex_mode
	LOCAL
		cmd_str;

	IF (vi$read_a_line (":", cmd_str) <> 0) and (cmd_str <> "") THEN
		vi$do_cmd_line (cmd_str);
	ENDIF;
ENDPROCEDURE;

!
!
!
PROCEDURE vi$read_a_line (prompt, cmd_str)
	LOCAL
		cmd_idx,
		addch,
		ch,
		did_ctl_v,
		win,
		pos;

	win := CURRENT_WINDOW;
	pos := MARK (NONE);

	POSITION (END_OF (command_buffer));
	MAP (command_window, command_buffer);
	COPY_TEXT (prompt);
	SET (OVERSTRIKE, CURRENT_BUFFER);

	cmd_str := "";
	cmd_idx := 0;
	LOOP
		vi$update (CURRENT_WINDOW);
		ch := vi$read_a_key;

		did_ctl_v := 0;
		IF ch = CTRL_V_KEY THEN
			COPY_TEXT ("^");
			did_ctl_v := 1;
			MOVE_HORIZONTAL (-1);
			vi$update (CURRENT_WINDOW);
			ch := vi$read_a_key;
			ERASE_CHARACTER (1);
		ENDIF;

		EXITIF ((ch = RET_KEY) OR (ch = F11)) AND (did_ctl_v = 0);

		IF (ch = RET_KEY) THEN ch := CTRL_M_KEY; ENDIF;
		IF (ch = F12) THEN ch := CTRL_H_KEY; ENDIF;
		IF (ch = F11) THEN ch := KEY_NAME (ASCII (27)); ENDIF;

		IF ((ch = DEL_KEY) OR (ch = CTRL_H_KEY)) AND (did_ctl_v = 0) THEN
			IF cmd_idx = 0 THEN
				UNMAP (command_window);
				UNMAP (message_window);
				MAP (message_window, message_buffer);
				POSITION (win);
				POSITION (pos);
				RETURN (0);
			ENDIF;
			ch := SUBSTR (cmd_str, cmd_idx, 1);
			cmd_idx := cmd_idx - 1;
			IF (INDEX (vi$_ctl_chars, ch) <> 0) THEN
				MOVE_HORIZONTAL (-2);
			ELSE
				MOVE_HORIZONTAL (-1);
			ENDIF;
			cmd_str := SUBSTR (cmd_str, 1, cmd_idx);
		ELSE
			IF (INT(ch) <= INT(KEY_NAME (ASCII (31)))) AND
								(INT (ch) >= INT(CTRL_A_KEY)) THEN
				IF ch = TAB_KEY THEN
					addch := 9;
					COPY_TEXT (ASCII(addch));
				ELSE
					addch := ((INT(ch) - INT(CTRL_A_KEY)) / 256) + 1;
					COPY_TEXT ("^");
					COPY_TEXT (ASCII (addch + 64));
				ENDIF;
				cmd_str := cmd_str + ASCII (addch);
				cmd_idx := cmd_idx + 1;
				IF ch = 27 THEN ch := F11; ENDIF;
			ELSE
				IF (ch = UP) THEN
					vi$next_in_cmd (cmd_str, cmd_idx, prompt, -1);
				ELSE
					IF (ch = DOWN) THEN
						vi$next_in_cmd (cmd_str, cmd_idx, prompt, 1);
					ELSE
						COPY_TEXT (ASCII(ch));
						cmd_str := cmd_str + ASCII (ch);
						cmd_idx := cmd_idx + 1;
					ENDIF;
				ENDIF;
			ENDIF;
		ENDIF;
	ENDLOOP;

	ERASE_CHARACTER (LENGTH (CURRENT_LINE) - CURRENT_OFFSET);
	vi$update (CURRENT_WINDOW);

	IF (cmd_idx > 0) THEN
		POSITION (END_OF (command_buffer));
		LOOP
			MOVE_VERTICAL (-1);
			EXITIF (CURRENT_LINE <> prompt);
			ERASE_LINE;
		ENDLOOP;

		IF (CURRENT_LINE <> prompt + cmd_str) THEN
			MOVE_VERTICAL (1);
			COPY_TEXT (prompt + cmd_str);
		ENDIF;
	ENDIF;

	UNMAP (command_window);
	UNMAP (message_window);
	MAP (message_window, message_buffer);

	POSITION (win);
	POSITION (pos);

	RETURN (cmd_idx > 0);
ENDPROCEDURE;

!
!	This procedure looks from the next occurence of 'prompt' at the
!	beginning of the line, in the direction dir (1 or -1).  If prompt
!	is found, then cmd_str is set to the contents of that line, minus
!	the text of the prompt, and cmd_idx is set to the length of cmd_str.
!	The cursor is left positioned at the end of the line found, or if
!	none is found, it is not moved.
!
PROCEDURE vi$next_in_cmd (cmd_str, cmd_idx, prompt, dir)
	LOCAL
		pos,
		len;

	ON_ERROR
		POSITION (pos);
		RETURN;
	ENDON_ERROR;

	pos := MARK (NONE);
	len := LENGTH (prompt);

	POSITION (LINE_BEGIN);
	LOOP
		EXITIF (MARK (NONE) = BEGINNING_OF (CURRENT_BUFFER)) AND (dir = -1);
		EXITIF (MARK (NONE) = END_OF (CURRENT_BUFFER)) AND (dir = 1);
		MOVE_VERTICAL (DIR);
		IF SUBSTR (CURRENT_LINE, 1, len) = prompt THEN
			cmd_str := SUBSTR (CURRENT_LINE, len+1,
											LENGTH (CURRENT_LINE) - len + 1);
			cmd_idx := LENGTH (cmd_str);
			POSITION (LINE_END);
			RETURN;
		ENDIF;
	ENDLOOP;
	POSITION (pos);
ENDPROCEDURE;

!
!	Perform a whole series of command separated by '|'s.
!
PROCEDURE vi$do_cmd_line (cmd)
	LOCAL
		ch,
		retval,
		idx,
		strg;

	idx := 1;
	strg := "";

	LOOP
		EXITIF (idx > LENGTH (cmd));
		ch := SUBSTR (cmd, idx, 1);
		IF (ch = "|") THEN
			retval := vi$do_command (strg);
			IF (retval > 1) THEN
				RETURN (retval);
			ENDIF;
			strg := "";
		ELSE
			IF (ch = "\") THEN
				idx := idx + 1;
				IF (SUBSTR (cmd, idx, 1) = "|") THEN
					strg := strg + "|";
				ELSE
					strg := strg + "\" + SUBSTR (cmd, idx, 1);
				ENDIF;
			ELSE            
				strg := strg + ch;
			ENDIF;
		ENDIF;
		idx := idx + 1;
	ENDLOOP;

	IF (strg <> "") THEN
		IF (vi$do_command (strg) <> 0) THEN
			RETURN (1);
		ENDIF;
	ENDIF;
	RETURN (0);
ENDPROCEDURE;

!
!	Perform an EX (not all are implemented) command as given in "cmd".
!
PROCEDURE vi$do_command (cmd)
	LOCAL
		rng,
		outf,       
		mode,
		token_1,
		token_2,
		token_3,
		res_spec,
		start_mark,
		end_mark,
		start_line,
		end_line,
		work_range,
		whole_range,
		buf,
		spos,
		rest,
		separ,
		no_spec,
		ch,
		i,
		j,
		olen,
		bang,
		num,  
		pos;

	olen := GET_INFO (CURRENT_BUFFER, "RECORD_COUNT");

	! Start at beginning of string and look for a range of lines.

	i := 1;

	pos := MARK (NONE);
	num := vi$get_line_spec (i, cmd);

	IF (num < 0) THEN
		vi$info ("search line not found!");
		POSITION (pos);
		RETURN (1);
	ENDIF;

	no_spec := 0;
	IF (num <= 0) THEN
		IF (vi$parse_next_ch (i, cmd, "%")) THEN
			start_line := 1;
			end_line := GET_INFO (CURRENT_BUFFER, "RECORD_COUNT");
		ELSE
			no_spec := 1;
			start_line := vi$cur_line_no;
			end_line := start_line;
		ENDIF;
	ELSE
		start_line := num;
		IF (vi$parse_next_ch (i, cmd, ",")) THEN
			num := vi$get_line_spec (i, cmd);
			IF (num < 0) THEN
				vi$info ("Invalid line range specification!");
				RETURN (1);
			ENDIF;
			end_line := num;
		ELSE
			end_line := start_line;
		ENDIF;
	ENDIF;

	POSITION (pos);

	work_range := 0;
	whole_range := 0;

	IF (start_line > end_line) THEN
		vi$info ("Bad range of lines!");
		RETURN (1);
	ENDIF;

	start_mark := vi$mark_line (start_line);
	end_mark := vi$mark_line (end_line);

	IF (start_mark = 0) OR (end_mark = 0) THEN
		vi$info ("Bad range of lines!");
		RETURN (1);
	ENDIF;

	work_range := CREATE_RANGE (start_mark, end_mark, NONE);

	pos := MARK (NONE);
	POSITION (end_mark);

	IF (end_mark <> END_OF (CURRENT_BUFFER)) THEN
		MOVE_VERTICAL (1);
	ENDIF;

	IF (MARK(NONE) <> BEGINNING_OF (CURRENT_BUFFER)) THEN
		MOVE_HORIZONTAL (-1);
	ENDIF;

	whole_range := CREATE_RANGE (start_mark, MARK (NONE), NONE);
	POSITION (pos);

	!	If there is no command then move to the line indicated.

	rest := vi$rest_of_line (cmd, i);
	EDIT (rest, COLLAPSE);
	IF rest = "" THEN
		vi$old_place := MARK (NONE);
		POSITION (start_mark);
		RETURN (0);
	ENDIF;

	token_1 := vi$get_cmd_token (vi$_lower_chars, cmd, i);

	IF (vi$leading_str (token_1, "version") AND (LENGTH (token_1) > 2)) THEN
		vi$info (vi$_version);
		RETURN (0);
	ENDIF;

	IF (token_1 = "help") THEN
		RETURN (vi$do_help (vi$rest_of_line (cmd, i)));
	ENDIF;

	IF (token_1 = "show") THEN
		RETURN (vi$do_show (cmd, i));
	ENDIF;

	! Check for substitution alias.

	IF (token_1 = "") AND (vi$parse_next_ch (i, cmd, "&")) THEN
		RETURN (vi$do_subs_alias (cmd, i, start_line, end_line, whole_range));
	ENDIF;

	IF (token_1 = "") AND (vi$parse_next_ch (i, cmd, "@")) THEN
		RETURN (vi$do_macro_buffer (cmd, i));
	ENDIF;        

	IF (token_1 = "learn") THEN
		RETURN (vi$do_learn (cmd, i));
	ENDIF;

	IF (token_1 = "unlearn") THEN
		RETURN (vi$do_unlearn (cmd, i));
	ENDIF;

	IF (token_1 = "v") OR (token_1 = "g") THEN
		IF (no_spec) THEN
			start_line := 1;
			end_line := GET_INFO (CURRENT_BUFFER, "RECORD_COUNT");
			whole_range := CURRENT_BUFFER;
		ENDIF;
		RETURN (vi$do_global (cmd, i,
								token_1, start_line, end_line, whole_range));
	ENDIF;

	IF (token_1 = "sh") OR (token_1 = "dcl") THEN
		RETURN (vi$spawn (0));
	ENDIF;                                              

	IF (vi$leading_str (token_1, "unabbr") AND (LENGTH (token_1) > 4)) THEN
		RETURN (vi$do_unabbr (cmd, i));
	ENDIF;

	IF (vi$leading_str (token_1, "abbr") AND (LENGTH (token_1) > 3)) THEN
		RETURN (vi$do_abbr (cmd, i));
	ENDIF;

	IF (vi$leading_str (token_1, "edit")) OR (token_1 = "vi") THEN
		RETURN (vi$do_edit (cmd, i, token_1));
	ENDIF;

	IF (token_1 = "") THEN
		IF (vi$parse_next_ch (i, cmd, "!")) THEN
			RETURN (vi$do_subproc (cmd, i));
		ENDIF;
	ENDIF;

	IF (vi$leading_str (token_1, "copy")) THEN
		RETURN (vi$do_copy (cmd, i, whole_range, olen, start_line, end_line));
	ENDIF;

	IF (vi$leading_str (token_1, "move")) THEN
		RETURN (vi$do_move (cmd, i, whole_range, start_line, end_line));
	ENDIF;

	IF (vi$leading_str (token_1, "select")) AND (LENGTH (token_1) > 2) THEN
		RETURN (vi$do_select);
	ENDIF;

	IF (token_1 = "fill") THEN
		RETURN (vi$do_fill (cmd, i, whole_range, olen));
	ENDIF;

	IF ((LENGTH (token_1) > 1) AND (vi$leading_str (token_1, "upper") OR
									vi$leading_str (token_1, "lower") OR
				   	  				vi$leading_str (token_1, "invert"))) THEN
		RETURN (vi$do_case (token_1, whole_range));
	ENDIF;

	IF (token_1 = "s") THEN
		RETURN (vi$do_substitute (start_line, end_line, whole_range, i, cmd));
	ENDIF;

	IF (token_1 = "d") THEN
		RETURN (vi$do_delete (start_mark, whole_range, olen));
	ENDIF;

	! Do the write file command.  You can write either a buffer, or a
	! portion of one.

	IF (vi$leading_str (token_1, "write")) THEN
		RETURN (vi$do_write (cmd, i, no_spec, token_1, whole_range));
	ENDIF;

	IF (token_1 = "wq") THEN
		RETURN (vi$do_wq (cmd, i, no_spec, token_1, whole_range));
	ENDIF;

	IF (token_1 = "p") THEN
		RETURN (vi$do_print (start_mark, start_line, end_line));
	ENDIF;

	! Read in a file to the current buffer.

	IF (vi$leading_str (token_1, "read")) THEN
		RETURN (vi$do_read (cmd, i, start_line, olen));
	ENDIF;

	IF (vi$leading_str (token_1, "file")) THEN
		RETURN (vi$do_file_ex (cmd, i));
	ENDIF;                        

	IF (vi$leading_str (token_1, "buffer")) THEN
		RETURN (vi$do_buffer (cmd, i, token_1));
	ENDIF;         

	IF (token_1 = "so") THEN
		RETURN (vi$do_file (vi$rest_of_line (cmd, i), 1));
	ENDIF;                       

	IF (vi$leading_str (token_1, "messages")) THEN
		RETURN (vi$do_messages);
	ENDIF;            

	IF (vi$leading_str (token_1, "delbuf")) THEN
		RETURN (vi$do_delbuf (cmd, i));
	ENDIF;

	IF (vi$leading_str (token_1, "xit")) THEN
		RETURN (vi$_ZZ (KEY_NAME ('Z')));
	ENDIF;

	IF (token_1 = "rew") THEN
		RETURN (vi$_first_file (vi$parse_next_ch (i, cmd, "!")));
	ENDIF;

	IF (vi$leading_str (token_1, "prev")) THEN
		RETURN (vi$_previous_file (vi$parse_next_ch (i, cmd, "!")));
	ENDIF;

	IF (vi$leading_str (token_1, "next")) THEN
		RETURN (vi$_next_file (vi$parse_next_ch (i, cmd, "!")));
	ENDIF;

	IF (token_1 = "tag") OR (token_1 = "ta") THEN
		token_1 := vi$parse_next_ch (i, cmd, "!");
		vi$skip_white (cmd, i);
		IF (vi$rest_of_line (cmd, i) = "") THEN
			RETURN (vi$do_tag (0));
		ELSE
			RETURN (vi$do_tag (vi$rest_of_line (cmd, i)));
		ENDIF;
	ENDIF;

	IF (token_1 = "map") THEN
		RETURN (vi$map_keys (cmd, i));
	ENDIF;         

	IF (token_1 = "unmap") THEN
		RETURN (vi$unmap_keys (cmd, i));
	ENDIF;

	IF (token_1 = "set") OR (token_1 = "se") THEN
		RETURN (vi$set_commands (cmd, i));
	ENDIF;

	IF (token_1 = "tpu") THEN
		RETURN (vi$do_tpu (cmd, i, no_spec, whole_range));
	ENDIF;

	IF (token_1 = "cd") OR (token_1 = "chdir") THEN
		RETURN (vi$do_cd (cmd, i));
	ENDIF;

	! Quit the current editor session.

	IF (vi$leading_str (token_1, "quit")) THEN
		RETURN (vi$do_quit (cmd, token_1));
	ENDIF;

	vi$info ("Unrecognized command! ("+cmd+")");
	RETURN (1);
ENDPROCEDURE;

!
!
!
PROCEDURE vi$do_unlearn (cmd, i)
	LOCAL
		keyn,
		com;

	vi$info ("Press the key you want to unlearn: ");
	keyn := vi$read_a_key;

	IF (keyn = F11) OR (ASCII (27) = ASCII (keyn)) THEN
		vi$info ("UNLEARN aborted!");
		RETURN (1);
	ENDIF;

	com := LOOKUP_KEY (keyn, COMMENT, vi$cmd_keys);
	IF (com <> "learn_sequence") THEN
		vi$info ("That key is not a learned KEY!");
		RETURN (1);
	ENDIF;

	UNDEFINE_KEY (keyn, vi$cmd_keys);
ENDPROCEDURE;

!
!
!
PROCEDURE vi$do_learn (cmd, i)
	LOCAL
		keyn,
		strg;

	vi$info ("Type KEY sequence, and press CTRL-R to remember sequence");
	vi$in_learn := 1;
	LEARN_BEGIN (EXACT);
	RETURN (1);
ENDPROCEDURE;

!
!	Remember the keystrokes that have been typed.
!
PROCEDURE vi$remember

	LOCAL
		learn_seq,
		key,
		keyn,
		com;

	ON_ERROR
		RETURN (1);
	ENDON_ERROR;

	IF (vi$in_learn = 0) THEN
		RETURN (0);
	ENDIF;

	learn_seq := LEARN_END;
	vi$info ("Press key to bind sequence to: ");
	keyn := vi$read_a_key;

	IF (keyn = F11) OR (ASCII (27) = ASCII (keyn)) THEN
		vi$info ("LEARN aborted!");
		com := LEARN_END;
		vi$in_learn := 0;
		RETURN (1);
	ENDIF;

	com := LOOKUP_KEY (keyn, COMMENT, vi$cmd_keys);
	IF (com = "active_macro") THEN
		vi$info ("That key is a mapped key, you must unmap it first");
		RETURN (1);
	ENDIF;

	key := "vi$ls_"+vi$key_map_name (keyn);
	vi$global_var := learn_seq;
	EXECUTE (COMPILE (key+":=vi$global_var"));
	vi$in_learn := 0;
	DEFINE_KEY ("vi$play_back("+key+")", keyn, "learn_sequence", vi$cmd_keys);
	vi$info ("Sequence bound to key");
	RETURN (1);
ENDPROCEDURE;

!
!	Play back the program sequence for a learned set of keystrokes.
!
PROCEDURE vi$play_back (prog)
	LOCAL
		cnt,
		old_play_back,
		old_global;

	IF (vi$m_level > 30) THEN
		vi$info ("Infinite loop in key macro sequence (repeated > 30)!");
		RETURN;
	ENDIF;
	vi$m_level := vi$m_level + 1;

	MESSAGE ("undomap: "+str(vi$undo_map)+", global: "+str(vi$in_global));
	IF vi$undo_map THEN
		old_global := vi$in_global;
		IF (NOT old_global) THEN
			vi$save_for_undo (CURRENT_BUFFER, VI$LINE_MODE, 1);
			vi$in_global := 1;
			MESSAGE ("saved changes "+str(old_global)+"  "+str (vi$in_global));
		ENDIF;
	ENDIF;

	cnt := vi$cur_active_count;

	old_play_back := vi$playing_back;
	vi$playing_back := 1;

	LOOP
		EXITIF (cnt = 0);
		EXECUTE (prog);
		cnt := cnt - 1;
	ENDLOOP;
	vi$playing_back := old_play_back;
	vi$m_level := vi$m_level - 1;

	vi$in_global := old_global;
	IF (NOT vi$in_global) THEN
		vi$undo_start := BEGINNING_OF (CURRENT_BUFFER);
		vi$undo_end := END_OF (CURRENT_BUFFER);
	ENDIF;
ENDPROCEDURE;

!
!	Remove an abbreviation
!
PROCEDURE vi$do_unabbr (cmd, i)
	LOCAL
		separ,                         
		junk,
		idx,
		ch,
		abbr,
		abbrn;

	abbr := "";
	abbrn := "";

	junk := vi$skip_separ (cmd, i, vi$_space_tab, separ);
	IF (LENGTH (junk) = 0) THEN
		vi$info ("Abbreviation name required!");    
		RETURN (1);
	ENDIF;

	idx := 1;
	LOOP
		EXITIF idx > LENGTH (junk);
		ch := SUBSTR (junk, idx, 1);
		IF (INDEX (vi$_alpha_chars, ch) = 0) THEN
			vi$info ("Invalid character in UNABBR name, '"+ch+
														"', is not valid.");
			RETURN (1);
		ENDIF;
		IF (INDEX (vi$_upper_chars, ch) <> 0) THEN
			abbrn := abbrn + "_";
		ENDIF;
		abbrn := abbrn + ch;
		idx := idx + 1;
	ENDLOOP;
	EXECUTE (COMPILE ("VI$ABBR_"+abbrn+":=0;"));
	RETURN (0);
ENDPROCEDURE;

!
!	Create an abbreviation
!
PROCEDURE vi$do_abbr (cmd, i)
	LOCAL
		separ,
		abbr,
		nabbr,
		junk,                      
		idx,
		ch,
		abbrn;

	abbr := "";
	abbrn := "";

	! Check for query.

	junk := vi$skip_separ (cmd, i, vi$_space_tab, separ);
	IF (LENGTH (junk) = 0) THEN
		vi$show_abbrevs;
		RETURN (0);
	ENDIF;

	!  Check that the abbrievation name can be part of a variable name

	idx := 1;
	LOOP
		EXITIF idx > LENGTH (junk);
		ch := SUBSTR (junk, idx, 1);
		IF (INDEX (vi$_alpha_chars, ch) = 0) THEN
			vi$info ("Invalid character in ABBR name, '"+ch+"', is not valid.");
			RETURN (1);
		ENDIF;
		IF (INDEX (vi$_upper_chars+"_", ch) <> 0) THEN
			abbrn := abbrn + "_";
		ENDIF;
		abbrn := abbrn + ch;
		idx := idx + 1;
	ENDLOOP;

	abbr := vi$rest_of_line (cmd, i);

	nabbr := vi$dbl_chars ('"', abbr);
	EXECUTE (COMPILE ("VI$ABBR_"+abbrn+":="""+nabbr+""""));
	RETURN (0);
ENDPROCEDURE;

PROCEDURE vi$dbl_chars (dch, line)

	LOCAL
		ch,
		idx,
		nstr;

	!  Double all '"' quotes.

	idx := 1;
	nstr := "";
	LOOP

		EXITIF idx > LENGTH (line);
		ch := SUBSTR (line, idx, 1);
		IF (ch = dch) THEN
			ch := dch+dch;
		ENDIF;
		nstr := nstr + ch;
		idx := idx + 1;
	ENDLOOP;

	RETURN (nstr);
ENDPROCEDURE;
!
!	Execute the contents of the buffers named following an '@'.
!
PROCEDURE vi$do_macro_buffer (cmd, i)
	LOCAL
		line,
		mode,
		buf_name,
		pos,
		buf,
		ch;

	ON_ERROR
	ENDON_ERROR;

	vi$skip_white (cmd, i);

	LOOP
		ch := vi$next_char (cmd, i);
		EXITIF (ch = "");

		IF (INDEX ("123456789", ch) <> 0) THEN

			! Selected a deletion buffer.

			buf_name := "vi$del_buf_" + ch;
		ELSE
			IF (INDEX (vi$_letter_chars, ch) <> 0) THEN

				! Selected a named buffer.

				CHANGE_CASE (ch, LOWER);

				buf_name := "vi$ins_buf_" + ch;
			ELSE
				vi$info ("Invalid buffer!");
				RETURN;
			ENDIF;
		ENDIF;

		vi$global_var := 0;
		EXECUTE (COMPILE ("vi$global_var := "+buf_name+";"));
		buf := vi$global_var;
		IF (buf = 0) THEN
			vi$info ("There is no text in that buffer!");
			RETURN;
		ENDIF;

		pos := MARK (NONE);
		POSITION (BEGINNING_OF (buf));

		!  Skip the buffer mode indicator.

		mode := INT (vi$current_line);
		MOVE_VERTICAL (1);
		line := vi$current_line;

		IF mode = VI$LINE_MODE THEN
			line := line + ASCII (13);
		ENDIF;

		POSITION (pos);
		vi$do_macro (line, 1);
	ENDLOOP; 

ENDPROCEDURE;

!
!	Do the ex mode 'g' and 'v' commands
!
PROCEDURE vi$do_global (cmd, i, cmd_ch, sline, eline, rng)
	LOCAL
		dell,
		prt,
		out,
		pwin,
		pbuf,
		obuf,
		cmd_str,
		sch_str,
		subs_str,
		sch,
		separ,
		ch,
		nsubs,
		lpos,
		opos,
		spos,
		epos,
		pos,
		olen,
		fpos;

	out := 0;
	pos := MARK (NONE);
	olen := GET_INFO (CURRENT_BUFFER, "RECORD_COUNT");
	vi$skip_white (cmd, i);
	IF NOT vi$parse_next_ch (i, cmd, "/") THEN
		vi$info ("/ Search string must follow global!");
		RETURN (1);
	ENDIF;

	sch := SUBSTR (cmd, i-1, 1);
	sch_str := "";
	LOOP
		EXITIF (vi$parse_next_ch (i, cmd, sch));
		EXITIF (LENGTH (cmd) < i);
		ch := SUBSTR (cmd, i, 1);
		IF (ch = "\") THEN
			sch_str := sch_str + SUBSTR (cmd, i, 2);
			i := i + 1;
		ELSE
			sch_str := sch_str + ch;
		ENDIF;
		i := i + 1;
	ENDLOOP;

	IF (LENGTH (cmd) < i) THEN
		vi$info ("Incomplete command! ("+cmd+")");
		RETURN (1);
	ENDIF;

	vi$save_for_undo (CURRENT_BUFFER, VI$LINE_MODE, 1);
	cmd_str := vi$rest_of_line (cmd, i);

	spos := BEGINNING_OF (CURRENT_BUFFER);
	epos := END_OF (CURRENT_BUFFER);

	IF (rng <> 0) THEN
		spos := BEGINNING_OF (rng);
		epos := END_OF (rng);
	ENDIF;
	opos := spos;

	SET (FORWARD, CURRENT_BUFFER);
	POSITION (spos);

	subs := SUBSTR (cmd_str, 1, 1) = "s";
	dell := cmd_str = "d";
	prt := cmd_str = "p";

	IF subs THEN
		nsubs := 0;
		subs_str := SUBSTR (cmd_str, 2, 255);
		separ := SUBSTR (subs_str, 2, 1);
		IF (SUBSTR (cmd_str,1,1)+SUBSTR (subs_str, 1, 2) = "s"+separ+separ) THEN
			subs_str := separ+sch_str+separ+SUBSTR (subs_str, 3, 255);
		ENDIF;
	ENDIF;

	IF prt THEN
		pwin := CURRENT_WINDOW;
		obuf := CURRENT_BUFFER;
		pbuf := vi$init_buffer ("$$prt_temp$$", "");
		MAP (pwin, pbuf);
		UPDATE (pwin);
		POSITION (spos);
	ENDIF;

	LOOP
		fpos := vi$find_str (sch_str, 1, 0);
		EXITIF (fpos = 0) AND (cmd_ch = "g");
		EXITIF (fpos = epos);
		IF (fpos <> 0) AND (eline <> 0) THEN
			POSITION (fpos);
			EXITIF (vi$cur_line_no > eline);
		ENDIF;
		
		IF cmd_ch = "g" THEN
			POSITION (fpos);
			POSITION (LINE_BEGIN);	
			IF dell THEN
				ERASE_LINE;
			ELSE
				IF subs THEN
					lpos := vi$global_subs (subs_str, nsubs);
					POSITION (LINE_BEGIN);
					MOVE_VERTICAL (1);
				ELSE
					IF prt THEN
						vi$prt_line (fpos, CURRENT_LINE, pbuf, pwin);
						MOVE_VERTICAL (1);
					ELSE
						vi$info ("Bad command for global! ("+cmd_str+")");
						vi$kill_undo;
						vi$undo_end := 0;
						RETURN (1);
					ENDIF;
				ENDIF;
			ENDIF;
		ELSE
			IF cmd_ch = "v" THEN
				IF (fpos = 0) THEN
					fpos := epos;
				ENDIF;
				POSITION (fpos);
				POSITION (LINE_BEGIN);
				fpos := MARK (NONE);
				POSITION (opos);

				LOOP
					IF (MARK (NONE) = epos) OR
								((eline <> 0) AND (vi$cur_line_no > eline)) THEN
						out := 1;
						EXITIF 1;
					ENDIF;
					EXITIF (fpos = MARK(NONE));

					IF dell THEN
						ERASE_LINE;
					ELSE         
						IF subs THEN
							lpos := vi$global_subs (subs_str, nsubs);
							POSITION (LINE_BEGIN);
							MOVE_VERTICAL (1);
						ELSE
							IF prt THEN
								POSITION (fpos);
								vi$prt_line (fpos, CURRENT_LINE, pbuf, pwin);
								MOVE_VERTICAL (1);
							ELSE
								vi$info
									("Bad command for global! ("+cmd_str+")");
								vi$kill_undo;
								vi$undo_end := 0;
								RETURN (1);
							ENDIF;
						ENDIF;
					ENDIF;
				ENDLOOP;

				EXITIF out;

				IF (MARK (NONE) <> epos) THEN
					MOVE_VERTICAL (1);
				ENDIF;
				opos := MARK (NONE);
			ENDIF;
		ENDIF;
	ENDLOOP;

	IF prt THEN
		MESSAGE ("[Hit ENTER to continue]");
		LOOP
			EXITIF (vi$read_a_key = RET_KEY);
		ENDLOOP;
		MESSAGE (" ");
		MAP (pwin, obuf);
		DELETE (pbuf);
		POSITION (opos);
	ENDIF;

	IF subs THEN
		vi$info (STR (nsubs) + " substitutions.");
	ENDIF;

	IF (subs OR dell) THEN
		POSITION (lpos);
		vi$undo_end := END_OF (CURRENT_BUFFER);
		vi$undo_start := BEGINNING_OF (CURRENT_BUFFER);
		vi$check_length (olen);
	ENDIF;

	RETURN (1);
ENDPROCEDURE;  

!
!	Do print line for g and v EX-mode commands.
!
PROCEDURE vi$prt_line (opos, pline, pbuf, pwin)
	POSITION (pbuf);
	COPY_TEXT (pline);
	SPLIT_LINE;
	UPDATE (pwin);
	POSITION (opos);
ENDPROCEDURE;

!
!   Print the range of lines indicated, in the current window.
!
PROCEDURE vi$do_print (where, startl, endl)

	ON_ERROR
		RETURN;
	ENDON_ERROR;

	POSITION (where);

	SET (FORWARD, CURRENT_BUFFER);
	POSITION (LINE_BEGIN);
	SCROLL (CURRENT_WINDOW, endl-startl);
	vi$info ("[Hit ENTER to continue]");
	LOOP
		EXITIF vi$read_a_key = RET_KEY;
	ENDLOOP;
	vi$pos_in_middle (MARK (NONE));

	RETURN (0);                
ENDPROCEDURE;

!
!	Change the current working directory to the string given.  A simple
!	effort is made to translate the string given, but no other effort is
!	made to decode the actual logicals emmbeded in the string.
!
PROCEDURE vi$do_cd (cmd, i)

	LOCAL
		old_dir,
		sysdisk,
		retval,
		orig_nam,
		colon,
	 	directory_name;

	ON_ERROR
	ENDON_ERROR;


	vi$skip_white (cmd, i);
	directory_name := vi$rest_of_line (cmd, i);

	orig_nam := directory_name;
	directory_name := CALL_USER (vi$cu_trnlnm_proc, orig_nam);
	IF (directory_name = "") THEN
		directory_name := CALL_USER (vi$cu_trnlnm_job, orig_nam);
		IF (directory_name = "") THEN
			directory_name := CALL_USER (vi$cu_trnlnm_group, orig_nam);
			IF (directory_name = "") THEN
				directory_name := CALL_USER (vi$cu_trnlnm_sys, orig_nam);
			ENDIF;
		ENDIF;
	ENDIF;

	IF (directory_name = "") THEN
		directory_name := orig_nam;
	ENDIF;

	colon := INDEX (directory_name, ":");
	sysdisk := CALL_USER (vi$cu_trnlnm_proc, "SYS$DISK");

	IF (colon <> 0) THEN
		sysdisk := SUBSTR (directory_name, 1, colon);
		directory_name := SUBSTR (directory_name, colon+1, 255);
		EDIT (sysdisk, UPPER,COLLAPSE);
		retval := CALL_USER (vi$cu_set_sysdisk, sysdisk);
	ENDIF;

	TRANSLATE (directory_name, "  ", "[]");
	EDIT (directory_name, UPPER,COLLAPSE);
	directory_name := '[' + directory_name + ']';
	old_dir := CALL_USER (vi$cu_cwd, directory_name);
	vi$info ("New directory is " + CALL_USER (vi$cu_trnlnm_proc, "SYS$DISK") +
			CALL_USER (vi$cu_cwd, ""));

	RETURN (1);
ENDPROCEDURE;

!
!	The show command...
!
PROCEDURE vi$do_show (cmd, i)

	LOCAL
		act;

	vi$skip_white (cmd, i);
	act := vi$rest_of_line (cmd, i);
	CHANGE_CASE (act, LOWER);
	IF (vi$leading_str (act, "files")) THEN
		vi$_show_files;
	ELSE
		IF (vi$leading_str (act, "buffers")) THEN
			vi$_show_buffers;
		ELSE
			IF (vi$leading_str (act, "tags")) THEN
				vi$_show_tags;
			ENDIF;
		ENDIF;
	ENDIF;
	RETURN (0);
ENDPROCEDURE;

!
!	Show the current list of abbreviations that are known
!
PROCEDURE vi$show_abbrevs
	LOCAL
		buf,
		loc,
		varn,
		rvar,
		i,
		idx,
		ch, 
		strg,
		vars,
		errno,
		pos;

	ON_ERROR
		errno := ERROR;
		IF (errno <> TPU$_MULTIPLENAMES) AND
											(errno <> TPU$_STRNOTFOUND) THEN
			vi$info (CALL_USER (vi$cu_getmsg, STR(errno)));
	  		POSITION (pos);
			RETURN;
		ENDIF;
	ENDON_ERROR;

	pos := MARK (NONE);
	buf := choice_buffer;

	ERASE (buf);
	vars := EXPAND_NAME ("VI$ABBR_", VARIABLES);
	IF (vars = "") THEN
		vi$info ("Humm, there are not any abbreviations!");
		RETURN (1);
	ENDIF;
	POSITION (buf);
	COPY_TEXT (vars);
	POSITION (BEGINNING_OF (buf));
	LOOP
		loc := SEARCH (" ", FORWARD, EXACT);
		EXITIF loc = 0;
		POSITION (BEGINNING_OF (loc));
		ERASE_CHARACTER (1);
		SPLIT_LINE;
	ENDLOOP;

	POSITION (BEGINNING_OF (buf));

	LOOP
		EXITIF (MARK (NONE) = END_OF (CURRENT_BUFFER));

		IF (CURRENT_LINE = "VI$ABBR_") THEN
			ERASE_LINE;
		ELSE
			vi$global_var := 0;
			EXECUTE (COMPILE ("vi$global_var := "+CURRENT_LINE));
			varn := SUBSTR (CURRENT_LINE, 9, 500);
			rvar := "";
			idx := 1;
			LOOP
				EXITIF (vi$global_var = 0);
				EXITIF (idx > LENGTH (VARN));
				ch := SUBSTR (VARN, idx, 1);
				IF (ch = "_") THEN
					ch := SUBSTR (VARN, idx+1, 1);
					IF (INDEX (vi$_upper_chars+"_", ch) <> 0) THEN
						rvar := rvar + ch;
					ELSE
						EDIT (ch, LOWER);
						rvar := rvar + ch;
					ENDIF;
					idx := idx + 1;
				ELSE
					EDIT (ch, LOWER);
					rvar := rvar + ch;
				ENDIF;
				idx := idx + 1;
			ENDLOOP;
			ERASE_LINE;
			IF (vi$global_var <> 0) THEN
				strg := FAO ("!20AS = >!AS<", rvar, vi$global_var);
				COPY_TEXT (strg);
				SPLIT_LINE;
			ENDIF;
		ENDIF;
	ENDLOOP;
	POSITION (BEGINNING_OF (buf));
	POSITION (pos);
	vi$show_list (buf, 
		"                              Current Abbreviations" +
		"                           ",
		info_window);
	RETURN (0);
ENDPROCEDURE;

!
!	Show the current buffers and their attributes
!
PROCEDURE vi$_show_buffers
	LOCAL
		mod,
		nr,
		sys,
		pos,
		buf,
		bn;

	buf := GET_INFO (BUFFERS, "FIRST");
	ERASE (choice_buffer);
	pos := MARK (NONE);
	POSITION (choice_buffer);
	LOOP
		LOOP
			EXITIF (buf = 0);
			EXITIF (GET_INFO (buf, "SYSTEM") = 0);
			buf := GET_INFO (BUFFERS, "NEXT");
		ENDLOOP;
		EXITIF (buf = 0);

		mod := "Not ";
		IF GET_INFO (buf, "MODIFIED") THEN
			mod := "";
		ENDIF;

		nr := "";
		IF GET_INFO (buf, "NO_WRITE") THEN
			nr := "  No Write";
		ENDIF;

		COPY_TEXT (FAO ("Name: !20AS   Lines: !5UL   !ASModified!AS",
			GET_INFO (buf, "NAME"), GET_INFO (buf, "RECORD_COUNT"),
			mod, nr));

		SPLIT_LINE;

		IF GET_INFO (buf, "OUTPUT_FILE") = 0 THEN
			COPY_TEXT ("[No output file]");
		ELSE
			COPY_TEXT (FAO ("Output file: !AS",GET_INFO (buf, "OUTPUT_FILE")));
		ENDIF;

		SPLIT_LINE;
		SPLIT_LINE;
		buf := GET_INFO (BUFFERS, "NEXT");
	ENDLOOP;

	POSITION (BEGINNING_OF (choice_buffer));
	POSITION (pos);
	vi$show_list (choice_buffer, 
		"                   Current buffers and associated information" +
		"                  ",
		info_window);
	RETURN (0);
ENDPROCEDURE;

!
!	Perform the EX mode "&" command.
!
PROCEDURE vi$do_subs_alias (cmd, i, start_line, end_line, whole_range)
	IF vi$replace_separ = 0 THEN
		vi$info ("No previous substitution!");
		RETURN;
	ENDIF;

	! Rebuild a proper substitute command.

	cmd := SUBSTR (cmd, 1, i-2) + "s" +
				vi$replace_separ + vi$replace_source +
				vi$replace_separ + vi$replace_dest +
				vi$replace_separ + SUBSTR (cmd, i, 255);

	RETURN (vi$do_substitute (start_line, end_line, whole_range, i, cmd));
ENDPROCEDURE;

!
!	Perform the EX mode "!" command.
!
PROCEDURE vi$do_subproc (cmd, i)
	LOCAL
		tstr,
		errno,
		ncmd;

	cmd := vi$rest_of_line (cmd, i);
	IF cmd = "!" THEN
		cmd := vi$last_cmd;
	ELSE
		vi$last_cmd := cmd;
	ENDIF;

	IF cmd = 0 THEN
		vi$info ("No command on command line!");
		RETURN (1);
	ENDIF;

	IF cmd = "" THEN
		vi$info ("Use "":sh"" to get an interactive CLI");
		RETURN (1);
	ENDIF;

	IF (vi$process_special (cmd, ncmd)) THEN
		vi$mess_select (NONE);
		vi$info (":!"+ncmd);
		UPDATE (message_window);
	ENDIF;	    

	vi$pasthru_off;
	ncmd := vi$dbl_chars ('"', ncmd);
	vi$spawn ('@VI$ROOT:[EXE]DOSPAWN "'+ncmd+'"');
	vi$pasthru_on;
	vi$mess_select (REVERSE);
	RETURN (0);
ENDPROCEDURE;

!
!	This procedure looks at the characters in cmd, and translates occurances
!	of the characters % and # to the names of the current buffers file, and
!	the previously edited buffers file, respectively.
!
PROCEDURE vi$process_special (cmd, ncmd)

	LOCAL
		idx,
		redo,
		ch;

	ncmd := "";
	idx := 1;
	redo := 0;

	LOOP
		EXITIF idx > LENGTH (cmd);
		ch := SUBSTR (cmd, idx, 1);
		IF (ch = "%") THEN
			ch := GET_INFO (CURRENT_BUFFER, "OUTPUT_FILE");
			redo := 1;
		ELSE
			IF(ch = "#") THEN
				IF vi$last_mapped <> 0 THEN
					ch := GET_INFO (vi$last_mapped, "OUTPUT_FILE");
					redo := 1;
				ENDIF;
			ENDIF;
		ENDIF;
		ncmd := ncmd + ch;
		idx := idx + 1;
	ENDLOOP;

	RETURN (redo);
ENDPROCEDURE;  
!
!	Perform the EX mode copy command.
!
PROCEDURE vi$do_copy (cmd, i, whole_range, olen, start_line, end_line)
	LOCAL      
		spos,  
		dest;

	vi$skip_white (cmd, i);
	dest := vi$get_line_spec (i, cmd);

	IF (dest > GET_INFO (CURRENT_BUFFER, "RECORD_COUNT")) THEN
		dest := GET_INFO (CURRENT_BUFFER, "RECORD_COUNT");
	ENDIF;

	IF ((dest < start_line) OR (dest > end_line)) AND (dest > 0) THEN
		vi$move_to_line (dest + 1);
		spos := vi$get_undo_start;
		COPY_TEXT (whole_range);
		vi$kill_undo;
		MOVE_HORIZONTAL (-1);
		vi$undo_end := MARK (NONE);
		vi$undo_start := vi$set_undo_start (spos);
	ELSE
		vi$info ("Error in copy range!");
		RETURN (1);
	ENDIF;

	vi$check_length (olen);
	RETURN (1);
ENDPROCEDURE;  

!
!	Perform the EX mode move command.
!
PROCEDURE vi$do_move (cmd, i, whole_range, start_line, end_line)
	LOCAL
		dest;

	vi$skip_white (cmd, i);
	dest := vi$get_line_spec (i, cmd);

	IF (dest > GET_INFO (CURRENT_BUFFER, "RECORD_COUNT")) THEN
		dest := GET_INFO (CURRENT_BUFFER, "RECORD_COUNT");
	ENDIF;

	IF ((dest < start_line) OR (dest > end_line)) AND (dest > 0) THEN
		vi$move_to_line (dest+1);
		vi$undo_end := 0;
		vi$kill_undo;
		MOVE_TEXT (whole_range);
	ELSE
		vi$info ("Error in move range!");
		RETURN (1);
	ENDIF;
	RETURN (0);
ENDPROCEDURE;

!
!	Perform the EX mode select command.
!
PROCEDURE vi$do_select
	IF vi$select_pos = 0 THEN
		vi$select_pos := SELECT (REVERSE);
		vi$info ("Selection started!");
	ELSE
		vi$select_pos := 0;
		vi$info ("Selection canceled!");
	ENDIF;
	RETURN (1);
ENDPROCEDURE;

!
!	Perform the EX mode fill command.
!
PROCEDURE vi$do_fill (cmd, i, whole_range, olen)
	LOCAL  
		separ,
		token_1,
		token_2;

	token_1 := vi$skip_separ (cmd, i, vi$_space_tab, separ);
	token_2 := vi$skip_separ (cmd, i, vi$_space_tab, separ);
	IF token_1 = "" THEN              
		token_1 := 0;
	ELSE
		token_1 := INT (token_1);
	ENDIF;

	IF token_2 = "" THEN
		token_2 := 0;
	ELSE
		token_2 := INT (token_2);
	ENDIF;

	IF (vi$select_pos <> 0) THEN
		cmd := SELECT_RANGE;
		IF (cmd = 0) THEN
			vi$info ("Nothing selected!");
			RETURN (1);
		ENDIF;
		vi$select_pos := 0;
		vi$fill_region (token_1, token_2, cmd);
		MESSAGE ("");
	ELSE
		vi$fill_region (token_1, token_2, whole_range);
	ENDIF;

	vi$info ("Fill complete!");
	sleep (1);
	vi$check_length (olen);
	RETURN (0);
ENDPROCEDURE;

!
!	Perform the EX mode upper, lower, and insert commands.
!
PROCEDURE vi$do_case (token_1, whole_range)
	LOCAL
		rng,
		mode,
		pos,
		cmd;

	IF (vi$select_pos <> 0) THEN
		rng := SELECT_RANGE;
		vi$select_pos := 0;
		mode := VI$IN_LINE_MODE;
		vi$update (CURRENT_WINDOW);
	ELSE
		rng := whole_range;
		mode := VI$LINE_MODE;
	ENDIF;

	cmd := UPPER;
	IF SUBSTR (token_1, 1, 1) = "l" THEN
		cmd := LOWER;
	ELSE
		IF (SUBSTR (token_1, 1, 1) = "i") THEN
			cmd := INVERT;
		ENDIF;
	ENDIF;	

	vi$undo_start := BEGINNING_OF (rng);
	vi$undo_end := END_OF (rng);
	pos := MARK (NONE);
	POSITION (BEGINNING_OF (rng));
	vi$save_for_undo (rng, mode, 1);
	POSITION (pos);
	CHANGE_CASE (rng, cmd);
	rng := 0;
	RETURN (0);
ENDPROCEDURE;

!
!	Perform the EX mode delete command.
!
PROCEDURE vi$do_delete (start_mark, whole_range, olen)
	POSITION (start_mark);
	IF (MARK (NONE) <> BEGINNING_OF (CURRENT_BUFFER)) THEN
		MOVE_HORIZONTAL (-1);
		vi$undo_start := MARK (NONE);
	ELSE
		vi$undo_start := 0;
	ENDIF;

	vi$save_for_undo (whole_range, VI$LINE_MODE, 1);
	vi$undo_end := 0;
	ERASE (whole_range);
	IF (vi$undo_start <> 0) THEN
		POSITION (vi$undo_start);
		MOVE_HORIZONTAL (1);
		vi$undo_start := MARK (NONE);
	ELSE
		vi$undo_start := BEGINNING_OF (CURRENT_BUFFER);
	ENDIF;
	vi$check_length (olen);
	RETURN (0);
ENDPROCEDURE;

!
!	Perform the EX mode write command.
!
PROCEDURE vi$do_write (cmd, i, no_spec, token_1, whole_range)
	LOCAL
		range_used,
		outf,
		res_spec,
		ncmd,
		buf,
		win,
		owin,
		bang,
		proc,
		token_2;

	ON_ERROR
		IF ERROR = TPU$_PARSEFAIL THEN
			vi$info ("Don't understand filename, '"+token_2+"'");
			RETURN (1);
		ENDIF;
	ENDON_ERROR;

	bang := vi$parse_next_ch (i, cmd, "!");
	vi$skip_white (cmd, i);

	IF (vi$parse_next_ch (i, cmd, "!")) THEN
		buf := vi$init_buffer ("$$filt_temp$$", "");
		win := CREATE_WINDOW (1, vi$scr_length-1, ON);
		owin := CURRENT_WINDOW;
		IF (buf = 0) OR (win = 0) THEN
			vi$info ("Can't get buffer and window for command!");
			RETURN (1);
		ENDIF;

		SET (STATUS_LINE, win, REVERSE,
							"*Output from command: "+vi$rest_of_line (cmd,i));
		MAP (win, buf);
		UPDATE (win);
		vi$pasthru_off;
		proc := CREATE_PROCESS (buf, vi$rest_of_line (cmd, i));
		IF proc <> 0 THEN
			SEND (whole_range, proc);
			IF proc <> 0 THEN
				SEND_EOF (proc);
			ENDIF;
		ENDIF;
		UPDATE (win);
		vi$info ("[Hit RETURN to continue]");
		LOOP
			EXITIF vi$read_a_key = RET_KEY;
		ENDLOOP;

		vi$pasthru_on;
		UNMAP (win);
		DELETE (win);
		DELETE (buf);
		POSITION (owin);
		RETURN (1);
	ENDIF;

	range_used := 0;
	IF (no_spec) AND (vi$select_pos <> 0) THEN
		whole_range := SELECT_RANGE;
		no_spec := 0;
		range_used := 1;    
	ENDIF;

	vi$skip_white (cmd, i);
	ncmd := vi$rest_of_line (cmd, i);
	vi$process_special (ncmd, token_2);

	IF (token_2 <> "") THEN
		res_spec := FILE_PARSE (token_2);

		outf := FILE_SEARCH ("");
		outf := FILE_SEARCH (res_spec);
		IF (outf <> "") AND
				(outf <> GET_INFO (CURRENT_BUFFER, "OUTPUT_FILE")) AND
				NOT bang THEN
			vi$info (token_2 +
						' exists - use "' +
						token_1 +
						'! ' +
						token_2 +
						'" to overwrite.');
			RETURN (1);
		ELSE
			vi$info ("Writing out """+res_spec+"""");
			IF (no_spec = 0) THEN
				WRITE_FILE (whole_range, res_spec);
			ELSE
			   	WRITE_FILE (CURRENT_BUFFER, res_spec);
			ENDIF;
		ENDIF;
	ELSE
		IF (no_spec = 0) THEN
			IF bang THEN
				vi$info ('Use "w!" to write partial buffer');
				outf := "";
			ELSE
				outf := GET_INFO (CURRENT_BUFFER, "OUTPUT_FILE");
				IF outf <> "" THEN
					vi$info ("Writing out """+outf+"""");
					outf := WRITE_FILE (whole_range, outf);
				ELSE
					vi$info ("Buffer has no output file!");
				ENDIF;
			ENDIF;     
		ELSE           
			IF (vi$can_write (CURRENT_BUFFER)) THEN
				vi$info ("Writing out """+
								GET_INFO (CURRENT_BUFFER, "NAME")+"""");
				outf := WRITE_FILE (CURRENT_BUFFER);
				IF (outf = "") THEN
					MESSAGE ("");
				ENDIF;
			ELSE
				RETURN;
			ENDIF
		ENDIF;

		IF (outf <> "") THEN
			SET (OUTPUT_FILE, CURRENT_BUFFER, outf);
		ENDIF;
	ENDIF;

	IF range_used THEN
		vi$select_pos := 0;
	ENDIF;

	vi$kill_undo;
	vi$undo_end := 0;

	! Always leave message visible

	RETURN (1);
ENDPROCEDURE;

!
!	Check to see if a buffer is readonly or not.
!
PROCEDURE vi$can_write (buf)
	LOCAL
		bmode;

	bmode := vi$getbufmode (buf);
	IF (bmode) THEN
		vi$info (FAO ("!AS is set readonly", GET_INFO (buf, "NAME")));
	ENDIF;

	RETURN (bmode = 0);
ENDPROCEDURE;

!
!	Perform the EX mode read command.
!           
PROCEDURE vi$do_read (cmd, i, start_line, olen)
	LOCAL
		outf,
		spos,
		epos,      
		ret,
		i2,
		token_2,
		token_3;

	token_3 := vi$rest_of_line (cmd, i);
	vi$process_special (token_3, token_2);
	i2 := 1;
	vi$skip_white (token_3, i2);
	IF (vi$parse_next_ch (i2, token_3, "!")) THEN
		POSITION (LINE_BEGIN);
		vi$move_vertical (1);
		SPLIT_LINE;
		MOVE_HORIZONTAL (-1);
		vi$kill_undo;
		epos := MARK (NONE);
		spos := MARK (NONE);
		vi$undo_start := vi$get_undo_start;
		ret := vi$filter_region (CREATE_RANGE (spos, epos, NONE),
				vi$rest_of_line (token_3, i2));
		MOVE_HORIZONTAL (-1);
		vi$undo_end := MARK (NONE);
		vi$undo_start := vi$set_undo_start (vi$undo_start);
		POSITION (vi$undo_start);
		i := i2;
		RETURN (ret);
	ENDIF;	

	token_3 := vi$rest_of_line (cmd, i);
	vi$process_special (token_3, token_2);

	IF (token_2 <> "") THEN
		token_2 := FILE_PARSE (token_2);
		outf := FILE_SEARCH ("");
		outf := FILE_SEARCH (token_2);
		IF (outf <> "") THEN
			IF (start_line > 0) THEN
				POSITION (BEGINNING_OF (CURRENT_BUFFER));
				MOVE_VERTICAL (start_line - 1);
			ENDIF;
			POSITION (LINE_BEGIN);
			IF (MARK (NONE) = END_OF (CURRENT_BUFFER)) THEN
				SPLIT_LINE;
			ELSE
				MOVE_VERTICAL (1);
			ENDIF;          
			MOVE_HORIZONTAL (-1);
			spos := MARK (NONE);
			MOVE_HORIZONTAL (1);
			outf := READ_FILE (outf);
			IF (outf <> "") THEN
				MOVE_HORIZONTAL (-1);
				vi$undo_end := MARK (NONE);
				vi$kill_undo;
				POSITION (spos);
				MOVE_HORIZONTAL (1);
				vi$undo_start := MARK (NONE);
			ENDIF;
		ELSE
			vi$info (token_2 + " does not exist!");
		ENDIF;
	ELSE
		vi$info ("Filename required!");
	ENDIF;
	vi$check_length (olen);

	! Always leave last message visible

	RETURN (1);
ENDPROCEDURE;

!
!	Perform the EX mode file command.
!
PROCEDURE vi$do_file_ex (cmd, i)
	LOCAL
		token_2;

	ON_ERROR
		IF ERROR = TPU$_PARSEFAIL THEN
			vi$info ("Don't understand filename: "+token_2);
		ENDIF;
	ENDON_ERROR;

	token_2 := vi$rest_of_line (cmd, i);
	IF (token_2 <> "") THEN
		token_2 := FILE_PARSE (token_2);
		SET (OUTPUT_FILE, CURRENT_BUFFER, token_2);
		vi$status_lines (CURRENT_BUFFER);
	ENDIF;
	vi$what_line;

	RETURN (1);
ENDPROCEDURE;

!
!	Perform the EX mode buffer command.
!
PROCEDURE vi$do_buffer (cmd, i, token_1)

	LOCAL
		buf,
		cbuf,
		bang,
		separ,
		token_2,
		token_3;

	ON_ERROR
		IF ERROR = TPU$_PARSEFAIL THEN
			vi$info ("Don't understand filename given!");
			RETURN (1);
		ENDIF;
	ENDON_ERROR;

	bang := vi$parse_next_ch (i, cmd, "!");
	buf := 0;
	cbuf := CURRENT_BUFFER;

	token_2 := vi$skip_separ (cmd, i, vi$_space_tab, separ);
	token_3 := vi$skip_separ (cmd, i, vi$_space_tab, separ);

	IF (vi$rest_of_line (cmd, i) <> "") THEN
		vi$info ("Too many paramters!");
		RETURN (1);
	ENDIF;

	IF (token_2 <> "") THEN
		IF (token_3 = "") THEN
			buf := vi$find_buffer_by_name (token_2);
			IF buf = 0 THEN
				buf := vi$_create_buffer (token_2, 0, 0);
		   	ENDIF;
		ELSE
			token_3 := FILE_PARSE (token_3);
			buf := vi$_create_buffer (token_2, token_3, token_3);
		ENDIF;

		IF (buf <> 0) THEN
			POSITION (cbuf);
			IF (vi$check_auto_write) THEN
				RETURN;
			ENDIF;
			MAP (CURRENT_WINDOW, buf);
			vi$set_status_line (CURRENT_WINDOW);
		ENDIF;
	ELSE
		vi$what_line;
	ENDIF;

	vi$kill_undo;
	vi$undo_end := 0;
	RETURN (1);
ENDPROCEDURE;

!
!	Perform the EX mode "vi" and/or "edit" commands.
!
PROCEDURE vi$do_edit (cmd, i, token_1)
	LOCAL
		buf,
		bang,
		num,
		look,
		ch,
		endch,
		token_2;

	num := -1;
	look := -1;

	bang := vi$parse_next_ch (i, cmd, "!");
	vi$skip_white (cmd, i);
	IF vi$parse_next_ch (i, cmd, "+") THEN
		! Get a goto spec.
		IF vi$parse_next_ch (i, cmd, "/") THEN
			! Get a search string
			look := "";
			IF vi$parse_next_ch (i, cmd, '"') THEN
				endch := '"';
			ELSE
				endch := " ";
			ENDIF;
			LOOP
				ch := vi$next_char (cmd, i);
				EXITIF (endch = ch) OR (ch = "");
				IF (ch = "/") THEN
					ch := vi$next_char (cmd, i);
					IF ch <> '"' THEN
						ch := "/" + ch;
					ENDIF;
				ENDIF;
				look := look + ch;
			ENDLOOP;
			vi$skip_white (cmd, i);
		ELSE
			! Get a number
			num := "";
			LOOP
				EXITIF INDEX (vi$_numeric_chars, SUBSTR (cmd, i, 1)) = 0;
				num := num + vi$next_char (cmd, i);
			ENDLOOP;
			vi$skip_white (cmd, i);
			num := INT (num);
		ENDIF;
	ENDIF;
	token_2 := vi$rest_of_line (cmd, i);

	! Check for use of % as file name, this means current file, so it is
	! synonomous with specifying no filename.

	IF (token_2 = "") OR (token_2 = "%") THEN
		IF (NOT bang) AND (GET_INFO (CURRENT_BUFFER, "MODIFIED")) THEN
			vi$info ("No write since last change, use """ +
					 token_1 + "!"" to override");
			RETURN (1);
		ENDIF;

		token_2 := GET_INFO (CURRENT_BUFFER, "FILE_NAME");
		IF (token_2 = 0) OR (token_2 = "") THEN
			vi$info ("Buffer has no file!");
			RETURN (1);
		ENDIF;

		! Get everything but the version.

		token_2 := FILE_PARSE (token_2, "", "", DEVICE) +
			   		 FILE_PARSE (token_2, "", "", DIRECTORY) +
					 FILE_PARSE (token_2, "", "", NAME) +
					 FILE_PARSE (token_2, "", "", TYPE);

		buf := CURRENT_BUFFER;
		MAP (CURRENT_WINDOW, MESSAGE_BUFFER);
		POSITION (MESSAGE_BUFFER);
		DELETE (buf);
	ENDIF;

	! Check for abbreviation for previous file, and just swap buffers if
	! that is the case.

	IF (token_2 = "#") THEN
		vi$move_prev_buf (bang);
	ELSE
		vi$get_file (token_2);
		vi$pos_in_middle (MARK (NONE));
		vi$kill_undo;
		vi$undo_end := 0;
	ENDIF;
	IF (num <> -1) THEN
		vi$move_to_line (num);
		vi$pos_in_middle (MARK (NONE));
	ELSE
		IF (look <> -1) THEN
			vi$search_string := look;
			num := vi$find_str (look, 0, 0);
			IF (num <> 0) THEN
				vi$beep_position (num, 1, 1);
				vi$pos_in_middle (MARK (NONE));
			ENDIF;
		ENDIF;
	ENDIF;
	RETURN (1);
ENDPROCEDURE;

!
!	Perform the EX mode messages command.
!
PROCEDURE vi$do_messages
	vi$last_mapped := CURRENT_BUFFER;
	MAP (CURRENT_WINDOW, MESSAGE_BUFFER);
	POSITION (MESSAGE_BUFFER);
	vi$set_status_line (CURRENT_WINDOW);
	vi$kill_undo;
	vi$undo_end := 0;
	RETURN (0);
ENDPROCEDURE;

!                       
!	Perform the EX mode tag command.
!
PROCEDURE vi$do_tag (tag_str, bang);
	vi$load_tags;
	RETURN (vi$to_tag (tag_str, bang));
ENDPROCEDURE;

!
!	Load the tags files into a buffer
!
PROCEDURE vi$load_tags
	LOCAL
		idx,
		fname,
		ch,
		flist,
		pos;

	ON_ERROR
	ENDON_ERROR;

	pos := MARK (NONE);
	ERASE (vi$tag_buf);

	POSITION (BEGINNING_OF (vi$tag_buf));
	idx := 0;
	fname := "";

	flist := vi$tag_files + " ";
	LOOP
		EXITIF (idx > LENGTH(flist));
		ch := SUBSTR (flist, idx, 1);
		IF (INDEX (vi$_space_tab, ch) <> 0) AND (fname <> "") THEN
			vi$info_success_off;
			fname := FILE_PARSE (fname);
			IF (fname <> "") AND (FILE_SEARCH (fname) <> "") THEN
				READ_FILE (FILE_PARSE (fname));
			ENDIF;
			vi$info_success_on;
			fname := "";
		ELSE
			IF (INDEX (vi$_space_tab, ch) = 0) THEN
				fname := fname + ch;
			ENDIF;
		ENDIF;
		idx := idx + 1;
	ENDLOOP;

	POSITION (pos);
	RETURN (0);
ENDPROCEDURE;          

!
!	Position to the tag given or use the current symbol in the buffer
!
PROCEDURE vi$to_tag (tag, bang)
	LOCAL
		fname,
		sch_pat,
		tloc,
		pos;

	ON_ERROR
	ENDON_ERROR;

	pos := MARK (NONE);

	! Read the symbol name from the CURRENT location in the buffer.

	IF (tag = 0) THEN
		tag := vi$sym_name;
	ENDIF;

	IF (tag = "") THEN
		vi$info ("Bad tag name");
		POSITION (pos);
		RETURN (1);                                         
	ENDIF;

	POSITION (BEGINNING_OF (vi$tag_buf));
	IF (MARK (NONE) = END_OF (vi$tag_buf)) THEN
		vi$info ("NO tags file!");
		POSITION (pos);
		RETURN (1);
	ENDIF;

	vi$global_var := 0;
	EXECUTE (COMPILE ("vi$global_var := LINE_BEGIN & '"+tag+ASCII(9)+"'"));

	vi$info_success_off;
	tloc := SEARCH (vi$global_var, FORWARD, vi$tag_case);
	vi$info_success_on;

	IF (tloc <> 0) THEN
		POSITION (END_OF (tloc));
		MOVE_HORIZONTAL (1);
		fname := vi$space_word;
		sch_pat := SUBSTR (CURRENT_LINE, CURRENT_OFFSET+2, 1024);
		POSITION (pos);

		IF (NOT bang) AND (vi$check_auto_write) THEN
			RETURN (1);
		ENDIF;

		IF (vi$get_file (fname) > 0) THEN
			POSITION (END_OF (CURRENT_BUFFER));
			IF (vi$do_cmd_line (sch_pat)) THEN
				POSITION (BEGINNING_OF (CURRENT_BUFFER));
				vi$info ("Tag not found!");
				RETURN (1);
			ENDIF;
			vi$pos_in_middle (MARK (NONE));
		ENDIF;
	ELSE
		POSITION (pos);
		vi$info ("Tag not in tags file");
		RETURN (1);
	ENDIF;
	RETURN (0);
ENDPROCEDURE;

!
!	Return the word that is spanned by characters in the symbol set.
!
PROCEDURE vi$sym_name
	LOCAL
		ch;

	ch := "";
	LOOP
		EXITIF INDEX (vi$_sym_chars, CURRENT_CHARACTER) = 0;
		ch := ch + CURRENT_CHARACTER;
		MOVE_HORIZONTAL (1);
	ENDLOOP;
	RETURN (ch);
ENDPROCEDURE;

!
!	Return the word that is spanned by non-blank characters.
!
PROCEDURE vi$space_word
	LOCAL
		ch;

	ch := "";
	LOOP
		EXITIF (CURRENT_CHARACTER = " ") OR (CURRENT_CHARACTER = ASCII (9));
		ch := ch + CURRENT_CHARACTER;
		MOVE_HORIZONTAL (1);
	ENDLOOP;
	RETURN (ch);
ENDPROCEDURE;

!
!	Perform the EX mode tpu command.
!          
PROCEDURE vi$do_tpu (cmd, i, no_spec, whole_range)

	ON_ERROR
		RETURN (1);
	ENDON_ERROR;

	IF no_spec AND (vi$rest_of_line (cmd, i) <> "") THEN
		EXECUTE (COMPILE (vi$rest_of_line (cmd, i)));
	ELSE
		vi$info ("Compiling...");
		IF no_spec AND (vi$rest_of_line (cmd, i) = "") THEN
			IF (vi$select_pos <> 0) THEN
				EXECUTE (COMPILE (SELECT_RANGE));
				vi$select_pos := 0;
				MESSAGE ("");
			ELSE
				vi$info ("Nothing selected to compile!");
				RETURN (1);
			ENDIF;
		ELSE
			COMPILE (whole_range);
		ENDIF;
	ENDIF;         

	RETURN (1);
ENDPROCEDURE;

!
!
!
PROCEDURE vi$do_wq (cmd, i, no_spec, token_1, whole_range)
	vi$do_write (cmd, i, no_spec, token_1, whole_range);
	vi$do_quit (cmd, token_1);
	RETURN (1);
ENDPROCEDURE;
!
!	Perform the EX mode quit command.
!
PROCEDURE vi$do_quit (cmd, token_1)
	LOCAL
		buf;

	buf := GET_INFO (BUFFERS, "FIRST");
	LOOP
		EXITIF buf = 0;
		IF GET_INFO (buf, "MODIFIED") AND
										(NOT GET_INFO (buf, "SYSTEM")) THEN
			IF NOT GET_INFO (buf, "NO_WRITE") THEN
				IF INDEX (cmd, "!") <> 0 THEN
					SET (NO_WRITE, buf);
				ELSE
					vi$info ("No write of buffer """+GET_INFO (buf, "NAME") +
							 """ since last change, use """+token_1 + 
							 "!"" to override.");
					RETURN (1);
				ENDIF;
			ENDIF;
		ENDIF;
		buf := GET_INFO (BUFFERS, "NEXT");
	ENDLOOP;
	vi$quit;
	RETURN (1);
ENDPROCEDURE;

!
!  Delete the buffer given by the name passed as the parameter.  The buffer
!  must not be the current buffer, or if it is, there must be more than
!  one buffer on the screen.
!
PROCEDURE vi$do_delbuf (cmd, i)

	LOCAL
		win,
		confirm,
		possible_buffer,
		possible_buffer_name,
		found_a_buffer,
		how_many_buffers,
		this_buffer,                          
		loop_buffer,
		bang,
		buffer_name;

	! Get the buffer name, solving abiguity problems.

	bang := vi$parse_next_ch (i, cmd, "!");
	vi$skip_white (cmd, i);
	buffer_name := vi$rest_of_line (cmd, i);
	CHANGE_CASE (buffer_name, UPPER);	! for messages
	loop_buffer := vi$find_buffer_by_name (buffer_name);

	IF (loop_buffer <> 0) THEN
		buffer_name := GET_INFO (loop_buffer, "NAME");

		! Now, we must first delete all windows mapped to this buffer.

		win := GET_INFO (WINDOWS, "FIRST");
		LOOP
			EXITIF (win = 0);
			EXITIF (GET_INFO (loop_buffer, "MAP_COUNT") = 0);

			! See if current window is mapped to this buffer.

			IF (GET_INFO (win, "BUFFER") = loop_buffer) THEN

				! If so, there must be a previous or a next window to move to.
				! If there is not, then we can not delete the buffer until
				! another buffer (and window) are available to move to.

				IF (vi$prev_win (win) <> 0) OR (vi$next_win(win) <> 0) THEN
					POSITION (win);
					vi$del_win (win);

					! Restart at beginning of list.  Deleting a window will
					! make "NEXT" not work.

					win := GET_INFO (WINDOWS, "FIRST");
				ELSE
					vi$info ("Can't unmap all windows that are mapped to """ +
														buffer_name + """!");
					RETURN (1);
				ENDIF;
			ELSE
				win := GET_INFO (WINDOWS, "NEXT");
			ENDIF;
		ENDLOOP;
	ELSE
		vi$info ("No such buffer, "+buffer_name);
		RETURN (1);
	ENDIF;

	CHANGE_CASE (buffer_name, UPPER);
	IF (GET_INFO (loop_buffer, "MAP_COUNT") = 0) THEN
		IF (GET_INFO (loop_buffer, "MODIFIED") AND NOT bang) THEN
			confirm := READ_LINE ("Delete modified buffer, """+
														buffer_name+"""? ");

		    EDIT (confirm, UPPER);
		    IF (SUBSTR (confirm, 1, 1) <> "Y") THEN
			    vi$info ("Buffer NOT deleted!");
			    RETURN (1);
		    ENDIF;
		ENDIF;

		DELETE (loop_buffer);
		vi$info ("Buffer, """+buffer_name+""", deleted!");
	ELSE
		vi$info ("Can't delete """+buffer_name+
										""", it is still mapped to a window!");
		RETURN (1);
	ENDIF;

!	Normally we would return 0, but the above message must remain visible.

	RETURN (1);
ENDPROCEDURE;
!
!	Return the proper value of a MARKER that indicates the previous position
!	in the current buffer.
!
PROCEDURE vi$get_undo_start
	LOCAL
		pos;

	IF (MARK (NONE) = BEGINNING_OF (CURRENT_BUFFER)) THEN
		RETURN (0);
	ELSE
		MOVE_HORIZONTAL (-1);
		pos := MARK (NONE);
		MOVE_HORIZONTAL (1);
		RETURN (pos);
	ENDIF;
ENDPROCEDURE;

!
!	Use "spos" to determine where "vi$undo_start" should be set.
!
PROCEDURE vi$set_undo_start (spos)
	IF spos = 0 THEN
		RETURN (BEGINNING_OF (CURRENT_BUFFER));
	ELSE
		POSITION (spos);
		MOVE_HORIZONTAL (1);
		RETURN (MARK (NONE));
	ENDIF;
ENDPROCEDURE;

!
!  If this was real VI under UNIX, all you would need to do is filter text
!  through NROFF...  sigh...  I guess you can't have it all?
!
PROCEDURE vi$fill_region (leftm, rightm, rng)
	LOCAL
		pos,
		tend,
		spos,
		beg;

	IF (leftm = 0) THEN                                             
		leftm := 1;
	ENDIF;

	IF (rightm = 0) THEN
		rightm := vi$scr_width - vi$wrap_margin;
	ENDIF;

	POSITION (BEGINNING_OF (rng));
	LOOP
		EXITIF (CURRENT_CHARACTER <> " ") AND (CURRENT_CHARACTER <> ASCII (9));
		MOVE_HORIZONTAL (1);
		EXITIF (MARK (NONE) = END_OF (rng));
	ENDLOOP;

	beg := MARK (NONE);
	POSITION (END_OF (rng));
	MOVE_HORIZONTAL (-1);
	tend := MARK (NONE);
	rng := CREATE_RANGE (beg, tend, NONE);
	POSITION (BEGINNING_OF (rng));
	vi$save_for_undo (rng, VI$IN_LINE_MODE, 1);
	spos := vi$get_undo_start;

	FILL (rng, " ", leftm, rightm);
	vi$undo_end := MARK (NONE);
	vi$undo_start := vi$set_undo_start (spos);
	POSITION (vi$undo_start);
ENDPROCEDURE;

!
!	Given a buffer name, return the buffer TYPE variable for that buffer.
!
PROCEDURE vi$find_buffer_by_name (bname_param)
	LOCAL
		cnt,
		bname,
		possible,
		pbuf,
		buf;

	bname := bname_param;
	CHANGE_CASE (bname, UPPER);
	buf := GET_INFO (BUFFERS, "FIRST");
	cnt := 0;

	LOOP
		EXITIF buf = 0;
		possible := GET_INFO (buf, "NAME");
		EXITIF bname = possible;
		IF vi$leading_str (bname, possible) THEN
			cnt := cnt + 1;
			pbuf := buf;
		ENDIF;
		buf := GET_INFO (BUFFERS, "NEXT");
	ENDLOOP;

	IF buf = 0 THEN
		IF cnt = 1 THEN
			buf := pbuf;
		ENDIF;
	ENDIF;

	RETURN (buf);
ENDPROCEDURE;

!
!	Effect a key mapping, and squirl away the original mapping so that
!	it can be restore later.
!
PROCEDURE vi$map_keys (cmd, i)
	LOCAL
		comment_string,
		separ,
		pos,
		buf,
		map_type,
		keyn,
		key;

	map_type := vi$cmd_keys;
	IF (vi$parse_next_ch (i, cmd, "!")) THEN
		map_type := vi$edit_keys;
	ENDIF;

	IF SUBSTR (cmd, i, 1) <> " " THEN
		vi$show_maps;
		RETURN(1);
	ENDIF;

	vi$skip_white (cmd, i);

	IF (i > LENGTH (cmd)) THEN
		vi$show_maps;
		RETURN (1);
	ENDIF;

	key := KEY_NAME (SUBSTR (cmd, i, 1));
	i := i + 1;
	comment_string := LOOKUP_KEY (key, COMMENT, map_type);

	vi$skip_white (cmd, i);

	key := INT (key);
	IF (key < 32) THEN
		key := ((INT(CTRL_B_KEY) - INT(CTRL_A_KEY)) *
										(key - 1)) + INT(CTRL_A_KEY);
	ENDIF;

	keyn := vi$key_map_name (key);

	IF (map_type = vi$edit_keys) AND (comment_string <> 0) AND
			(comment_string <> "") AND (comment_string <> "active_macro") THEN
		vi$info ("You can't redefine that key!");
		RETURN (1);
	ENDIF;

	vi$global_var := 0;
	buf := 0;

	! The callable TPU interface can create certain problems, as it
	! may cause the key definitions to hang around when the map
	! buffers have actually been deleted.  Mail can do this!  As a
	! result, the following code detects when the map buffer is
	! missing, and creates a new one.  The original meaning of
	! any key that is mapped in this way is necessarily lost.

	IF comment_string = "active_macro" THEN
		EXECUTE (COMPILE ("vi$global_var := vi$$key_map_buf_" +
							keyn + map_type + ";"));
		buf := vi$global_var;

		! If buf is zero at this point, then the key map buffer
		! has been deleted.

	ELSE
		EXECUTE (COMPILE (
			"vi$global_var := vi$init_buffer ('vi$$key_map_" +
												keyn + map_type + "', '');"));

		IF (vi$global_var = 0) THEN
			vi$info ("Can't create buffer for key map!");
			RETURN;
		ENDIF;

		EXECUTE (COMPILE ("vi$$key_map_buf_" +
									keyn + map_type + " := vi$global_var;"));

		! Pass the flag.

		buf := 1;
	ENDIF;

	! New key map, save old map into keymap buffer.

	IF (GET_INFO (buf, "TYPE") = INTEGER) THEN
		buf := vi$global_var;
		pos := MARK (NONE);
		POSITION (buf);
		SPLIT_LINE;
		COPY_TEXT (comment_string);
	ELSE

		! Old map should be erased first.

		IF (GET_INFO (buf, "TYPE") = BUFFER) THEN
			pos := MARK (NONE);
			POSITION (BEGINNING_OF (buf));
			LOOP
				EXITIF (CURRENT_LINE = "");
				ERASE_LINE;
			ENDLOOP;
		ELSE

			! Key map buffer has been deleted, create a new one.

			EXECUTE (COMPILE (
				"vi$global_var := vi$init_buffer ('vi$$key_map_" +
												keyn + map_type + "', '');"));

			IF (vi$global_var = 0) THEN
				vi$info ("Can't create buffer for key map!");
				RETURN;
			ENDIF;

			EXECUTE (COMPILE ("vi$$key_map_buf_" +
									keyn + map_type + " := vi$global_var;"));
			buf := vi$global_var;
			pos := MARK (NONE);
			POSITION (buf);
			SPLIT_LINE;
			COPY_TEXT ("vi$lost_definition");
		ENDIF;
	ENDIF;

	POSITION (BEGINNING_OF (buf));

	LOOP
		EXITIF (i > LENGTH (cmd));
		COPY_TEXT (STR (INT (KEY_NAME (SUBSTR (cmd, i, 1)))));
		SPLIT_LINE;
		i := i + 1;
	ENDLOOP;

	POSITION (BEGINNING_OF (buf));
	POSITION (pos);

	vi$info_success_off;

	IF (map_type = vi$edit_keys) THEN
		EXECUTE (COMPILE
			("DEFINE_KEY ('vi$insert_macro_keys (vi$$key_map_buf_" + keyn +
			map_type + ")', KEY_NAME(" + STR(key) + "), 'active_macro', vi$edit_keys);"));
	ELSE
		EXECUTE (COMPILE ("DEFINE_KEY ('vi$do_macro (vi$$key_map_buf_" + keyn +
			map_type + ", 1)', KEY_NAME(" + STR(key) +
			"), 'active_macro', vi$cmd_keys);"));
	ENDIF;

	vi$info_success_on;
	RETURN (0);
ENDPROCEDURE;

!
!	Unmap a key mapping and restore the original if one existed.
!
PROCEDURE vi$unmap_keys (cmd, i)
	LOCAL
		comment_string,
		separ,
		pos,
		buf,
		map_type,
		keyn,
		key;

	map_type := vi$cmd_keys;
	IF (SUBSTR (cmd, i, 1) = "!") THEN
		map_type := vi$edit_keys;
		i := i + 1;
	ELSE
		IF SUBSTR (cmd, i, 1) <> " " THEN
			vi$info ("Bad command!");
			RETURN;
		ENDIF;
	ENDIF;

	vi$skip_white (cmd, i);

	key := KEY_NAME (SUBSTR (cmd, i ,1));

	comment_string := LOOKUP_KEY (key, COMMENT, map_type);

	IF comment_string <> "active_macro" THEN
		vi$info ("Key not currently mapped!");
		RETURN;
	ENDIF;

	key := INT (key);
	IF (key < 32) THEN
		key := ((INT(CTRL_B_KEY) - INT(CTRL_A_KEY)) *
										(key - 1)) + INT(CTRL_A_KEY);
	ENDIF;

	keyn := vi$key_map_name (key);

	vi$global_var := 0;
	EXECUTE (COMPILE ("vi$global_var := vi$$key_map_buf_" +
													keyn + map_type + ";"));
	buf := vi$global_var;

	pos := MARK (NONE);
	POSITION (END_OF (buf));
	MOVE_VERTICAL (-1);

	vi$info_success_off;
	EXECUTE (COMPILE ("DEFINE_KEY ('"+CURRENT_LINE +
		"', "+STR(key)+", '"+CURRENT_LINE+"', '" + map_type + "')"));
	vi$info_success_on;

	POSITION (pos);
	DELETE (buf);

	vi$info ("Key now unmapped!");
ENDPROCEDURE;

!
!
!
PROCEDURE vi$lost_definition
	vi$info ("Key definition lost!");
ENDPROCEDURE;

!
!	Show current keyboard mappings.
!
PROCEDURE vi$show_maps
	LOCAL
		com,
		key_type,
		keyn,
		key,
	   	bpos,
		npos,
		pos,
		buf;

	pos := MARK (NONE);
	buf := choice_buffer;

	POSITION (buf);
	ERASE (buf);

	key_type := vi$cmd_keys;
	COPY_TEXT ("COMMAND KEY MAPS:");
	SPLIT_LINE;
	LOOP
		keyn := GET_INFO (DEFINED_KEY, "first", key_type);
		LOOP
			EXITIF (keyn = 0);
			com := LOOKUP_KEY (keyn, COMMENT, key_type);

			IF (com = "active_macro") THEN
				key := vi$key_map_name (keyn);
				vi$global_var := 0;
				EXECUTE (COMPILE ("vi$global_var:=vi$$key_map_buf_"+
															key+key_type));
				IF (vi$global_var <> 0) AND
						(GET_INFO (vi$global_var, "TYPE") = BUFFER) THEN
					key := vi$ascii_name (keyn);
					COPY_TEXT (" "+key+SUBSTR ("   ", 1, 4-LENGTH(key))+'"');
					npos := MARK (NONE);
					POSITION (BEGINNING_OF (vi$global_var));
					LOOP
						keyn := CURRENT_LINE;
						EXITIF (LENGTH (keyn) < 8);
						bpos := MARK (NONE);
						POSITION (npos);
						COPY_TEXT (vi$ascii_name (INT(keyn)));
						POSITION (bpos);
						MOVE_VERTICAL (1);
					ENDLOOP;
					POSITION (npos);
					COPY_TEXT ('"');
					SPLIT_LINE;
				ENDIF;
			ENDIF;
			keyn := GET_INFO (DEFINED_KEY, "next", key_type);
		ENDLOOP;
		EXITIF (key_type = vi$edit_keys);
		key_type := vi$edit_keys;
		SPLIT_LINE;
		COPY_TEXT ("EDITING KEY MAPS:");
		SPLIT_LINE;
	ENDLOOP;

	APPEND_LINE;
	POSITION (BEGINNING_OF (buf));
	POSITION (pos);
	vi$show_list (buf, 
		"                                 Current MAPPINGS" +
		"                           ",
		info_window);
	RETURN (0);

ENDPROCEDURE;

!
!	Generate a unique string based on a KEY_NAME value.
!
PROCEDURE vi$key_map_name (key)
	LOCAL
		k;

	k := key;
	IF (GET_INFO (key, "TYPE") = KEYWORD) THEN
		k := INT (key);
	ENDIF;
	RETURN (SUBSTR(FAO("!XL", k),1,6));
ENDPROCEDURE;

!
!	Increment "i" until it is no longer indexing a blank or tab in "cmd".
!
PROCEDURE vi$skip_white (cmd, i)

	LOOP
		EXITIF i > LENGTH (cmd);
		EXITIF (INDEX (vi$_space_tab, SUBSTR(cmd, i, 1)) = 0);
		i := i + 1;
	ENDLOOP;
ENDPROCEDURE;

!
!	Given a string, extract a line specification that is either absolute,
!	relative, or an RE pattern expression.
!
PROCEDURE vi$get_line_spec (idx, cmd)
	LOCAL
		ch,
		sch,
		num;

	num := 0;

	ch := SUBSTR (cmd, idx, 1);

	IF (ch = "/") OR (ch = "?") THEN
		idx := idx + 1;
		sch := ch;
		num := "";
		LOOP
			EXITIF (vi$parse_next_ch (idx, cmd, sch));
			EXITIF (LENGTH (cmd) < idx);
			ch := SUBSTR (cmd, idx, 1);
			IF (ch = "\") THEN
				num := num + SUBSTR (cmd, idx, 2);
				idx := idx + 1;
			ELSE
				num := num + ch;
			ENDIF;
			idx := idx + 1;
		ENDLOOP;

		IF (LENGTH (cmd) < idx - 1) THEN
			vi$info ("Oops, improper expression!");
			RETURN (-1);
		ENDIF;

		ch := SUBSTR (cmd, idx, 1);

		IF sch = "?" THEN
			SET (REVERSE, CURRENT_BUFFER);
		ELSE
			SET (FORWARD, CURRENT_BUFFER);
		ENDIF;

		num := vi$find_str (num, 0, 0);

		IF (num <> 0) THEN
			num := BEGINNING_OF (num);
			POSITION (num);
			num := vi$cur_line_no;
		ELSE
			RETURN (-1);
		ENDIF;
	ELSE
		IF (ch = "'") THEN
			ch := SUBSTR (cmd, idx+1, 1);
			idx := idx + 2;
			vi$global_var := 0;
			EXECUTE (COMPILE ("vi$global_var:=vi$mark_"+ch));
			IF (vi$global_var <> 0) THEN
				POSITION (vi$global_var);
				num := vi$cur_line_no;
			ELSE
				RETURN (-1);
			ENDIF;
		ELSE
			LOOP
				ch := SUBSTR (cmd, idx, 1);
				EXITIF (INDEX (vi$_numeric_chars, ch) = 0);
				IF (num < 0) THEN
					num := INT (ch);
				ELSE
					num := num * 10 + INT (ch);
				ENDIF;
				idx := idx + 1;
			ENDLOOP;
		ENDIF;
	ENDIF;

	IF (ch = ".") THEN
		num := vi$cur_line_no;
		idx := idx + 1;         
		IF (vi$parse_next_ch (idx, cmd, "+")) THEN
			num := num + vi$get_line_spec (idx, cmd);
		ENDIF;
	ELSE
		IF (ch = "$") THEN
			num := GET_INFO (CURRENT_BUFFER, "RECORD_COUNT");
			idx := idx + 1;
		ELSE
			IF (ch = "+") THEN
				num := num + vi$get_line_spec (idx, cmd);
			ENDIF;
		ENDIF;
	ENDIF;

	RETURN (num);
ENDPROCEDURE;

!
!	If the character at location "idx" in "cmd" is "try", then increment
!	"idx" and return TRUE, otherwise return FALSE.
!
PROCEDURE vi$parse_next_ch (idx, cmd, try)
	IF (SUBSTR (cmd, idx, 1) = try) THEN
		idx := idx + 1;
		RETURN (1);
	ENDIF;

	RETURN (0);
ENDPROCEDURE;

!
!	A function to get the string, in "cmd", that is spanned by the characters 
!	in "mask".  "idx" is incremented to point past this string, and the string 
!	is returned as the function value.
!
PROCEDURE vi$get_cmd_token (mask, cmd, idx)
	LOCAL
		token,
		ch;

	token := "";

	vi$skip_white (cmd, idx);

	LOOP
		EXITIF (idx > LENGTH (cmd));
		ch := SUBSTR (cmd, idx, 1);
		EXITIF (INDEX (mask, ch) = 0);
		token := token + ch;
		idx := idx + 1;
	ENDLOOP;

	RETURN (token);
ENDPROCEDURE;

!
!	A function to see if the string "token" is a lead substring of "cmd".
!
PROCEDURE vi$leading_str (token, cmd)
	RETURN ((token <> "") AND (INDEX (cmd, token) = 1));
ENDPROCEDURE;

!
!	A routine that looks for the first occurance of a character in
!	"seps", in "cmd", and then changes "idx" to reflect that locatation.
!	"separ" will contain the character in "seps" that was actually found.
!
PROCEDURE vi$skip_separ (cmd, idx, seps, separ)
	LOCAL
		nch,
		retstr;                                              

	retstr := "";
	separ := "";
	vi$skip_white (cmd, idx);

	LOOP
		EXITIF (idx > LENGTH (cmd));
		nch := SUBSTR (cmd, idx, 1);
		idx := idx + 1;
		IF (INDEX (seps, nch) <> 0) OR (nch = " ") OR (nch = ASCII (9)) THEN
			separ := nch;
			RETURN (retstr);
		ENDIF;
		retstr := retstr + nch;
	ENDLOOP;
	RETURN (retstr);
ENDPROCEDURE;

!
!	A procedure that returns the characters occuring at index, "idx", and
!	after in the string "cmd".
!
PROCEDURE vi$rest_of_line (cmd, idx)
	RETURN (SUBSTR (cmd, idx, LENGTH (cmd)-idx + 1));
ENDPROCEDURE;

!
!  SET (INFORMATIONAL/SUCCESS) short procedures.
!
PROCEDURE vi$info_success_off vi$info_off; vi$success_off; ENDPROCEDURE;
PROCEDURE vi$info_success_on vi$info_on; vi$success_on; ENDPROCEDURE;
PROCEDURE vi$success_off SET (SUCCESS, OFF); ENDPROCEDURE;
PROCEDURE vi$success_on SET (SUCCESS, ON); ENDPROCEDURE;
PROCEDURE vi$info_off SET (INFORMATIONAL, OFF); ENDPROCEDURE;
PROCEDURE vi$info_on SET (INFORMATIONAL, ON); ENDPROCEDURE;

!
!	Called from vi$do_global to perform a substitution during a global command.
!
PROCEDURE vi$global_subs (cmd, nsubs)

	LOCAL
		idx,
		result_text,
		replace_text,
		hrange,
		ch,
		pos,
		spos,
		epos,
		lpos,
		source,
		scount,
		dest,
		query,
		doglobal,
		replace,
		separ;

	idx := 1;

	separ := vi$next_char (cmd, idx);

	source := "";
	dest   := "";
	doglobal := 0;
	query  := 0;

	LOOP
		IF (idx > LENGTH (cmd)) THEN
			vi$info ("Insufficent arguments!");
			RETURN (0);
		ENDIF;

		ch := SUBSTR (cmd, idx, 1);
		EXITIF ch = separ;
		source := source + ch;
		idx := idx + 1;
	ENDLOOP;

	idx := idx + 1;
	LOOP
		EXITIF idx > LENGTH (cmd);
		ch := SUBSTR (cmd, idx, 1);
		EXITIF ch = separ;
		dest := dest + ch;
		idx := idx + 1;
	ENDLOOP;

	idx := idx + 1;
	LOOP
		EXITIF idx > LENGTH (cmd);
		ch := SUBSTR (cmd, idx, 1);
		IF (ch = "q") or (ch = "c") THEN
			query := 1;
		ELSE
			IF ch = "g" THEN
				doglobal := 1;
			ELSE
				vi$info ("Unrecognized command qualifier '"+ch+"'");
				RETURN (0);
			ENDIF;
		ENDIF;
		idx := idx + 1;
	ENDLOOP;

	vi$replace_source := source;
	vi$replace_dest := dest;

	lpos := vi$perform_subs (source, dest, vi$cur_line_no,
			 									scount, doglobal, query);
	nsubs := nsubs + scount;

	RETURN (lpos);
ENDPROCEDURE;
!            
!	Called from vi$do_command to parse the rest of the command line,
!	this procedure then envokes lower level routines to perform the work
!	of a substitution command.
!
PROCEDURE vi$do_substitute (start_line, end_line, whole_range, idx, cmd)

	LOCAL
		result_text,
		replace_text,
		hrange,
		ch,
		pos,
		spos,
		epos,
		lpos,
		source,
		scount,
		dest,
		query,
		doglobal,
		replace,
		separ;

	pos := MARK (NONE);
	POSITION (END_OF (whole_range));
	epos := MARK (NONE);
	POSITION (pos);

	separ := vi$next_char (cmd, idx);
	vi$replace_separ := separ;

	source := "";
	dest   := "";
	doglobal := 0;
	query  := 0;

	LOOP
		IF (idx > LENGTH (cmd)) THEN
			vi$info ("Insufficent arguments!");
			RETURN (1);
		ENDIF;

		ch := SUBSTR (cmd, idx, 1);
		EXITIF (ch = separ);
		IF (ch <> "\") THEN
			source := source + ch;
		ELSE
			idx := idx + 1;
			IF (idx > LENGTH (cmd)) THEN
				vi$info ("Missing char after '\'");
				RETURN (1);
			ENDIF;
			source := source + SUBSTR (cmd, idx, 1);
		ENDIF;
		idx := idx + 1;
	ENDLOOP;

	idx := idx + 1;

	LOOP
		IF (idx > LENGTH (cmd)) THEN
			vi$info ("Insufficent arguments!");
			RETURN (1);
		ENDIF;

		ch := SUBSTR (cmd, idx, 1);
		EXITIF (ch = separ);
		IF (ch <> "\") THEN
			dest := dest + ch;
		ELSE
			idx := idx + 1;
			IF (idx > LENGTH (cmd)) THEN
				vi$info ("Missing char after '\'");
				RETURN (1);
			ENDIF;
			dest := dest + SUBSTR (cmd, idx, 1);
		ENDIF;
		idx := idx + 1;
	ENDLOOP;

	idx := idx + 1;
	LOOP
		EXITIF idx > LENGTH (cmd);
		ch := SUBSTR (cmd, idx, 1);
		IF (ch = "q") OR (ch = "c") THEN
			query := 1;
		ELSE
			IF ch = "g" THEN
				doglobal := 1;
			ELSE
				vi$info ("Unrecognized command qualifier '"+ch+"'");
				RETURN (1);
			ENDIF;
		ENDIF;
		idx := idx + 1;
	ENDLOOP;

	POSITION (pos);
	vi$save_for_undo (whole_range, VI$LINE_MODE, 1);
	vi$move_to_line (start_line);

	IF MARK (NONE) <> BEGINNING_OF (CURRENT_BUFFER) THEN
		MOVE_HORIZONTAL (-1);
		spos := MARK (NONE);
		MOVE_HORIZONTAL (1);
	ELSE
		spos := 0;
	ENDIF;

	vi$replace_source := source;
	vi$replace_dest := dest;

	scount := 0;
	lpos := vi$perform_subs (source, dest, end_line, scount, doglobal, query);

	IF (scount = 0) THEN
		vi$kill_undo;
		vi$undo_end := 0;
		POSITION (pos);
	ELSE
		vi$undo_end := epos;
		IF (spos = 0) THEN
			vi$undo_start := BEGINNING_OF (CURRENT_BUFFER);
		ELSE
			POSITION (spos);
			MOVE_HORIZONTAL (1);
			vi$undo_start := MARK (NONE);
		ENDIF;
		vi$pos_in_middle (lpos);
		vi$info (FAO ("!UL substitution!%S!", scount));
	ENDIF;

	RETURN (1);
ENDPROCEDURE;

!
!	Repeat the last substitute command that was issued at the ":" prompt.
!
!	The function mapped to '&'.
!
PROCEDURE vi$repeat_subs
	LOCAL
		scount,
		doglobal,
		query,
		lpos,
		spos,
		pos,
		epos,
		here;

	IF (vi$replace_separ = 0) THEN
		vi$info ("No previous substitution!");
		RETURN;
	ENDIF;

	doglobal := 0;
	query := 0;
	here := vi$cur_line_no;
	vi$save_for_undo (CURRENT_LINE, VI$LINE_MODE, 1);

	pos := MARK (NONE);
	POSITION (LINE_BEGIN);

	spos := vi$get_undo_start;

	POSITION (LINE_END);
	IF (LENGTH (CURRENT_LINE) > 0) THEN
		MOVE_HORIZONTAL (-1);
	ENDIF;
	epos := MARK (NONE);
	POSITION (pos);

	lpos := vi$perform_subs (vi$replace_source, vi$replace_dest,
												here, scount, doglobal, query);

	IF (scount = 0) THEN
		vi$kill_undo;
		vi$undo_end := 0;
	ELSE
		vi$undo_end := epos;
		vi$undo_start := vi$set_undo_start (spos);
		POSITION (lpos);
	ENDIF;

	RETURN (lpos);
ENDPROCEDURE;

!
!	Perform a substitution from the current location to "end_line".
!	Use source as the search string, and dest as the substitution
!	spec.  "global" indicates whether or not all occurances on a line
!	are examined, and "query" indicates whether or not to prompt before
!	performing the substitution.  On return, "scount" will hold the
!	number of substitutions actually performed.
!
PROCEDURE vi$perform_subs (source, dest, end_line, scount, doglobal, query)

	LOCAL
		result_text,
		replace_text,
		answer,
		fcnt,
		lpos,
		hrange,
		replace,
		fpos,
		quit_now,
		cwin,
		pos;

	SET (FORWARD, CURRENT_BUFFER);
	scount := 0;
	fcnt := 0;
	quit_now := 0;
	pos := MARK (NONE);

	LOOP
		fpos := vi$find_str (source, 1, 1);
		EXITIF (fpos = 0);
		fcnt := fcnt + 1;
		POSITION (BEGINNING_OF (fpos));

		IF vi$cur_line_no > end_line THEN
			POSITION (pos);
			EXITIF (1);
		ENDIF;
		result_text := SUBSTR (fpos, 1, LENGTH (fpos));
		replace_text := vi$substitution (result_text, dest);
		POSITION (BEGINNING_OF (fpos));

		replace := 1;
		IF (query) THEN
			POSITION (BEGINNING_OF (fpos));
			hrange := CREATE_RANGE (BEGINNING_OF (fpos),
													END_OF (fpos), REVERSE);
			cwin := GET_INFO (WINDOWS, "FIRST");
			LOOP
				EXITIF (cwin = 0);
				IF (GET_INFO (cwin, "VISIBLE")) THEN
					UPDATE (cwin);
				ENDIF;
				cwin := GET_INFO (WINDOWS, "NEXT");
			ENDLOOP;

			answer := vi$read_line ("Replace y/n/a/q? ");

			CHANGE_CASE (answer, LOWER);
			IF (answer = "") OR (INDEX ("yes", answer) <> 1) THEN
				replace := 0;
			ENDIF;
			IF (INDEX ("quit", answer) = 1) THEN
				quit_now := 1;
			ENDIF;
			IF (INDEX ("all", answer) = 1) THEN
				query := 0;
				replace := 1;
			ENDIF;
		ENDIF;

		IF replace THEN

!			This is a hack necessary to fix TPU's pattern matching.
!			The length of the text matched by only "line_begin" and
!			"line_end" has length == 1 instead of 0 as one would expect.

			IF (source <> "^") AND (source <> "$") AND (source <> "") THEN
				ERASE_CHARACTER (LENGTH (result_text));
			ENDIF;
			COPY_TEXT (replace_text);
			pos := MARK (NONE);
			scount := scount + 1;
		ELSE
			MOVE_HORIZONTAL (1);
		ENDIF;

		IF NOT doglobal THEN
			POSITION (LINE_BEGIN);
			EXITIF MARK (NONE) = END_OF (CURRENT_BUFFER);
			MOVE_VERTICAL (1);
		ENDIF;
		EXITIF quit_now;
	ENDLOOP;

	IF fcnt = 0 THEN
		vi$info ("string not found!");
	ENDIF;

	RETURN (pos);
ENDPROCEDURE;

!
!	Move horizontal, ignoring errors
!
PROCEDURE vi$move_horizontal (cnt)
	ON_ERROR
	ENDON_ERROR;

	MOVE_HORIZONTAL (cnt);
ENDPROCEDURE;

!
!	Move vertical, ignoring errors
!
PROCEDURE vi$move_vertical (cnt)
	ON_ERROR
	ENDON_ERROR;

	MOVE_VERTICAL (cnt);
ENDPROCEDURE;

!
!	Move to the indicated line number.
!
PROCEDURE vi$move_to_line (line_no)
	LOCAL
		pos;

	ON_ERROR
		POSITION (pos);
		RETURN (0);
	ENDON_ERROR;

	pos := MARK (NONE);
	POSITION (BEGINNING_OF (CURRENT_BUFFER));
	MOVE_VERTICAL (line_no - 1);

	RETURN (MARK (NONE));
ENDPROCEDURE;

!
!	Give a source string, and a "dest" substitution spec, perform the
!	RE style substitution, and return the resultant string.
!
PROCEDURE vi$substitution (source, dest)

	LOCAL
		cur_char,
		result,
		idx;

	idx := 0;
	result := "";

	LOOP
		EXITIF (idx > LENGTH(dest));

		cur_char := SUBSTR (dest, idx, 1);
		IF (cur_char = "&") THEN
			result := result + source;
			idx := idx + 1;
		ELSE
			IF (cur_char = '\') THEN
				cur_char := SUBSTR(dest, idx+1, 1);
				IF (INDEX ("123456789", cur_char) > 0) THEN
					vi$global_var := 0;
					IF INT(cur_char) > 1 THEN
						EXECUTE (COMPILE ("vi$global_var := SUBSTR (p" +
							cur_char +", LENGTH (o"+cur_char+")+1,512);"));
					ELSE
						EXECUTE (COMPILE ("vi$global_var := SUBSTR (p" +
							cur_char +", LENGTH (o"+cur_char+"),512);"));
					ENDIF;
					result := result + vi$global_var;
				ELSE
					IF (cur_char = "&") THEN
						result := result + cur_char;
					ELSE
						result := result + "\" + cur_char;
					ENDIF;
				ENDIF;
				idx := idx + 2;
			ELSE
				result := result + cur_char;
				idx := idx + 1;
			ENDIF;
		ENDIF;
	ENDLOOP;

	RETURN (result);
ENDPROCEDURE;

!          
!	Get the next character from a string at idx, and point past the character
!
PROCEDURE vi$next_char (cmd, idx)

	IF idx <= LENGTH (cmd) THEN
		idx := idx + 1;
		RETURN (SUBSTR (cmd, idx -1, 1));
	ENDIF;

	RETURN ("");
ENDPROCEDURE;

!
!  Process all set commands in the string cmd
!
PROCEDURE vi$set_commands (cmd, i)
	LOCAL                                    
		err,
		separ,
		token_1;

	ON_ERROR
		RETURN;
	ENDON_ERROR;

	LOOP
		token_1 := vi$skip_separ (cmd, i, "= "+ASCII(9), separ);
		EDIT (token_1, COLLAPSE);

		EXITIF token_1 = "";

		err :=  vi$set_one (token_1, separ, cmd, i);
		EXITIF err;
	ENDLOOP;
	RETURN (err);
ENDPROCEDURE

!
!  Process a single set command and return success or failure.
!
PROCEDURE vi$set_one (token_1, separ, cmd, i)

	LOCAL
		val,
		errno,
		curwin,
		curbuf,
		buf,
		use_fortran,
		oldscrlen,
		npat,
		pstr,
		token_2;

	ON_ERROR
		errno := ERROR;
		vi$info ("ERROR at line: "+STR(ERROR_LINE)+", "+
								call_user(vi$cu_getmsg,STR(errno)));
		RETURN (1);
	ENDON_ERROR;

	token_2 := "";

	IF (token_1 = "all") THEN
		vi$show_settings;
		RETURN (0);
	ENDIF;

	IF (token_1 = "tags") THEN
		vi$tag_files := vi$rest_of_line (cmd, i);
		i := LENGTH (cmd) + 1;
		RETURN (vi$load_tags);
	ENDIF;

	IF (token_1 = "notagcase") OR (token_1 = "notc") THEN
		vi$tag_case := NO_EXACT;
		RETURN (0);
	ENDIF;

	IF (token_1 = "tagcase") OR (token_1 = "tc") THEN
		vi$tag_case := EXACT;
		RETURN (0);
	ENDIF;

	IF (token_1 = "senddcl") THEN
		vi$send_dcl := 1;
		RETURN (0);
	ENDIF;

	IF (token_1 = "nosenddcl") THEN
		vi$send_dcl := 0;
		RETURN (0);
	ENDIF;

	IF (token_1 = "empty") THEN
		vi$delete_empty := 0;
		RETURN (0);
	ENDIF;

	IF (token_1 = "noempty") THEN
		vi$delete_empty := 1;
		RETURN (0);
	ENDIF;

	IF (token_1 = "files") OR (token_1 = "file") THEN
		val := vi$expand_file_list (vi$rest_of_line (cmd, i));
		vi$info (FAO ("!UL file!%S selected", val, 0));
		RETURN (2);
	ENDIF;

	IF (token_1 = "notabs") THEN
		vi$use_tabs := 0;
		RETURN (0);
	ENDIF;

	IF (token_1 = "tabs") THEN
		vi$use_tabs := 1;
		RETURN (0);
	ENDIF;

	IF (token_1 = "noreadonly") OR (token_1 = "noro") THEN
		SET (NO_WRITE, CURRENT_BUFFER, OFF);
		vi$setbufmode (CURRENT_BUFFER, 0);
		vi$status_lines (CURRENT_BUFFER);
		RETURN (0);
	ENDIF;
		
	IF (token_1 = "readonly") OR (token_1 = "ro") THEN
		vi$setbufmode (CURRENT_BUFFER, 1);
		vi$status_lines (CURRENT_BUFFER);
		RETURN (0);
	ENDIF;
		
	IF (token_1 = "write") OR (token_1 = "wr") THEN
		SET (NO_WRITE, CURRENT_BUFFER, OFF);
		vi$status_lines (CURRENT_BUFFER);
		RETURN (0);                          
	ENDIF;

	IF (token_1 = "nowrite") OR (token_1 = "nowr") THEN
		SET (NO_WRITE, CURRENT_BUFFER, ON);
		vi$status_lines (CURRENT_BUFFER);
		RETURN (0);
	ENDIF;

	IF (token_1 = "width") THEN
		token_2 := vi$skip_separ (cmd, i, "= "+ASCII(9), separ);
		val := INT (token_2);
		SET (WIDTH, CURRENT_WINDOW, val);
		vi$scr_width := val;
		RETURN (0);
	ENDIF;

	IF (token_1 = "window") THEN
		token_2 := vi$skip_separ (cmd, i, "= "+ASCII(9), separ);
		val := INT (token_2);
		RETURN (vi$do_set_window (val));
	ENDIF;

	IF (token_1 = "ts") OR (token_1 = "tabstops") THEN
		token_2 := vi$skip_separ (cmd, i, "=  "+ASCII(9), separ);
		val := INT (token_2);
		SET (TAB_STOPS, CURRENT_BUFFER, val);
		vi$tab_amount := val;
		RETURN (0);
	ENDIF;                             

	IF (token_1 = "sw") OR (token_1 = "shiftwidth") then
		token_2 := vi$skip_separ (cmd, i, "= "+ASCII(9), separ);
		vi$shift_width := INT (token_2);
		RETURN (0);
	ENDIF; 

	IF (token_1 = "noautoindent") OR (token_1 = "noai") THEN
		vi$auto_indent := 0;
		RETURN (0);
	ENDIF;

	IF (token_1 = "autoindent") OR (token_1 = "ai") THEN
		vi$auto_indent := 1;
		RETURN (0);
	ENDIF;

	IF (token_1 = "noundomap") OR (token_1 = "noum") THEN
		vi$undo_map := 0;                    
		RETURN (0);
	ENDIF;

	IF (token_1 = "undomap") OR (token_1 = "um") THEN
		vi$undo_map := 1;
		RETURN (0);
	ENDIF;

	IF (token_1 = "scroll") THEN
		token_2 := vi$skip_separ (cmd, i, "= "+ASCII(9), separ);
		vi$how_much_scroll := INT (token_2);
		RETURN (0);
	ENDIF;

	IF (token_1 = "report") THEN
		token_2 := vi$skip_separ (cmd, i, "= "+ASCII(9), separ);
		vi$report := INT (token_2);
		RETURN (0);
	ENDIF;

	IF (token_1 = "aw") OR (token_1 = "autowrite") THEN
		vi$auto_write := 1;                  
		RETURN (0);
	ENDIF;

	IF (token_1 = "noaw") OR (token_1 = "noautowrite") THEN
		vi$auto_write := 0;
		RETURN (0);
	ENDIF;

	IF (token_1 = "noic") OR (token_1 = "noignorecase") THEN
		vi$ignore_case := EXACT;
		RETURN (0);
	ENDIF;

	IF (token_1 = "ic") OR (token_1 = "ignorecase") THEN
		vi$ignore_case := NO_EXACT;
		RETURN (0);
	ENDIF;

	IF (token_1 = "magic") THEN
		vi$magic := 1;
		RETURN (0);
	ENDIF;

	IF (token_1 = "nomagic") THEN
		vi$magic := 0;
		RETURN (0);
	ENDIF;

	IF (token_1 = "noerrorbells") OR (token_1 = "noeb") THEN
		vi$error_bells := 0;
		RETURN (0);
	ENDIF;

	IF (token_1 = "errorbells") OR (token_1 = "eb") THEN
		vi$error_bells := 1;
		RETURN (0);
	ENDIF;

	IF (token_1 = "nowrapscan") OR (token_1 = "nows") THEN
		vi$wrap_scan := 0;
		RETURN (0);
	ENDIF;

	IF (token_1 = "wrapscan") OR (token_1 = "ws") THEN
		vi$wrap_scan := 1;
		RETURN (0);
	ENDIF;

	IF (token_1 = "noupdate") THEN
		vi$min_update := 1;
		RETURN (0);
	ENDIF;

	IF (token_1 = "update") THEN
		vi$min_update := 0;
		RETURN (0);
	ENDIF;

	IF (token_1 = "noshowmode") OR (token_1 = "nosm") THEN
		vi$show_mode := 0;                   
		RETURN (0);
	ENDIF;

	IF (token_1 = "showmode") OR (token_1 = "sm") THEN
		vi$show_mode := 1;
		RETURN (0);
	ENDIF;

	IF (token_1 = "wrapmargin") OR (token_1 = "wm") THEN
		token_2 := vi$skip_separ (cmd, i, "= "+ASCII(9), separ);
		vi$wrap_margin := INT (token_2);
		RETURN (0);
	ENDIF;

	IF (token_1 = "sections") OR (token_1 = "sect") THEN
		pstr := "LINE_BEGIN&((";
		use_fortran := 0;
		vi$sect_str := "";
		LOOP
			EXITIF (SUBSTR (cmd, i, 1) = " ") OR (i >= LENGTH (cmd));
			npat := SUBSTR (cmd, i, 2);
			vi$sect_str := vi$sect_str + npat;
			EDIT (npat, COLLAPSE);
			IF (npat = "+c") OR (npat = "+C") THEN
				pstr := pstr + '"{"';
			ELSE
				IF (npat = "+f") OR (npat = "+F") THEN
					use_fortran := 1;
					npat := "";
				ELSE
					IF (npat = "+t") OR (npat = "+T") THEN
						pstr := pstr + '"PROCEDURE"';
					ELSE
						pstr := pstr + '".' + npat + '"';
					ENDIF;
				ENDIF;
			ENDIF;
			i := i + 2;
			EXITIF (SUBSTR (cmd, i, 1) = " ") OR (i >= LENGTH (cmd));
			IF (npat <> "") THEN
				pstr := pstr + "|";
			ENDIF;
		ENDLOOP;
		pstr := pstr + ")";
		IF (use_fortran) THEN
			pstr := '("FUNCTION"|"SUBROUTINE")|('+ pstr + "))|LINE_END)";
		ENDIF;
		EXECUTE (COMPILE ("vi$sect_pat:="+pstr+";"));
		RETURN (0);
	ENDIF;

	IF (token_1 = "paragraphs") OR (token_1 = "para") THEN
		pstr := 'LINE_BEGIN&((';
		vi$para_str := "";
		LOOP
			EXITIF (SUBSTR (cmd, i, 1) = " ") OR (i >= LENGTH (cmd));
			npat := SUBSTR (cmd, i, 2);
			vi$para_str := vi$para_str + npat;
			EDIT (npat, COLLAPSE);
			pstr := pstr + '".' + npat + '"';
			i := i + 2;
			EXITIF (SUBSTR (cmd, i, 1) = " ") OR (i >= LENGTH (cmd));
			IF (npat <> "") THEN
				pstr := pstr + "|";
			ENDIF;
		ENDLOOP;
		pstr := pstr + ")|LINE_END)";
		EXECUTE (COMPILE ("vi$para_pat:="+pstr+";"));
		RETURN (0);     
	ENDIF;              

	IF (token_1 = "number") OR
			(token_1 = "optimize") OR
			(token_1 = "noautoprint") OR
			(token_1 = "novice") OR
			(token_1 = "slowopen") OR
			(token_1 = "noslowopen") OR
			(token_1 = "beautify") OR
			(token_1 = "taglength") OR
			(token_1 = "directory") OR
			(token_1 = "noprompt") OR
			(token_1 = "edcompatible") OR
			(token_1 = "term") OR
			(token_1 = "noredraw") OR
			(token_1 = "redraw") OR
			(token_1 = "terse") OR
			(token_1 = "flash") OR
			(token_1 = "noremap") OR
			(token_1 = "timeout") OR
			(token_1 = "hardtabs") OR
			(token_1 = "ttytype") OR
			(token_1 = "warn") OR
			(token_1 = "nowarn") OR
			(token_1 = "lisp") OR
	   		(token_1 = "list") OR
			(token_1 = "sh") OR
			(token_1 = "shell") OR
			(token_1 = "mesg") OR
			(token_1 = "nomesg") OR
			(token_1 = "showmatch") THEN
		vi$not_implemented (token_1);
		RETURN (1);
	ENDIF;

	vi$info ("Unrecognized option ("+token_1+
									"), use `set all' to see options.");
	RETURN (1);

ENDPROCEDURE;

!
!	Set the window length to the integer value passed.
!
PROCEDURE vi$do_set_window (len)
	LOCAL
		buf,
		curwin,
		curbuf;

	curwin := CURRENT_WINDOW;
	curbuf := CURRENT_BUFFER;

	IF (vi$prev_win (curwin) = 0) AND (vi$next_win (curwin) = 0)
											AND (NOT vi$in_occlusion) THEN
		IF len < 3 THEN
			len := 3;
		ENDIF;

		IF len > GET_INFO (SCREEN, "VISIBLE_LENGTH") THEN
			len := GET_INFO (SCREEN, "VISIBLE_LENGTH");
		ENDIF;

		oldscrlen := vi$scr_length;
		vi$scr_length := len;

		ADJUST_WINDOW (curwin, 0, vi$scr_length - oldscrlen);

		buf := GET_INFO (message_window, "BUFFER");
		UNMAP (message_window);
		DELETE (message_window);
		message_window := CREATE_WINDOW (vi$scr_length - 1, 2, ON);
		MAP (message_window, buf);
		SET (STATUS_LINE, message_window, NONE, "");
		ADJUST_WINDOW (message_window, 1, 0);

		DELETE (command_window);
		command_window := CREATE_WINDOW (vi$scr_length, 1, OFF);

		buf := GET_INFO (info_window, "BUFFER");
		DELETE (info_window);
		info_window := CREATE_WINDOW (1, vi$scr_length - 1, ON);
		SET (STATUS_LINE, info_window, NONE, "");

		SET (PROMPT_AREA, vi$scr_length, 1, REVERSE);

		POSITION (curbuf);
		POSITION (curwin);
		UNMAP (curwin);
		MAP (curwin, curbuf);
	ELSE
		vi$info (
		"Can't change length of screen while multiple windows visible!");
		RETURN (1);
	ENDIF;

	vi$how_much_scroll := vi$scr_length / 2;
	RETURN (0);
ENDPROCEDURE;

!
!	Show the current settings when ":set all" is issued.
!
PROCEDURE vi$show_settings
	LOCAL
		bname,
		readonly,
		obuf,
		ic,
		ostat,
		ovid,
		buf;

	buf := vi$init_buffer ("$$vi_set_all$$", "");

	ostat := GET_INFO (CURRENT_WINDOW, "STATUS_LINE");
	IF (ostat = 0) THEN
		ostat := "";
	ENDIF;
	ovid := GET_INFO (CURRENT_WINDOW, "STATUS_VIDEO");
	IF (ovid = 0) THEN
		ovid := NONE;
	ENDIF;
	SET (STATUS_LINE, CURRENT_WINDOW, NONE, "");
	SET (STATUS_LINE, CURRENT_WINDOW, REVERSE, 
		"                      Current settings of VI options");
	SET (EOB_TEXT, buf,
				"                      [Hit ENTER to continue editing]");
	obuf := CURRENT_BUFFER;
	POSITION (buf);

	IF vi$ignore_case = EXACT THEN
		ic := 2;
	ELSE
		ic := 0;
	ENDIF;

	COPY_TEXT (FAO (
	"!20<wrapmargin=!UL!>!20<tabstop=!UL!>!20<!ASmagic!>!20<!ASignorecase!>",
			vi$wrap_margin, vi$tab_amount,
			SUBSTR ("no", 1, (1-vi$magic)*2),
		 	SUBSTR ("no", 1, ic)));

	SPLIT_LINE;

	COPY_TEXT (FAO (
	"!20<shiftwidth=!UL!>!20<scroll=!UL!>!20<report=!UL!>!20<!ASautowrite!>",
			vi$shift_width, vi$how_much_scroll, vi$report,
			SUBSTR ("no", 1, (1-vi$auto_write)*2)));

	SPLIT_LINE;

	COPY_TEXT (FAO (
			"!20<!ASwrapscan!>!20<!ASupdate!>!20<!AStabs!>!20<!ASundomap!>",
			SUBSTR ("no", 1, (1-vi$wrap_scan)*2),
			SUBSTR ("no", 1, (vi$min_update)*2),
			SUBSTR ("no", 1, (1-vi$use_tabs)*2),
			SUBSTR ("no", 1, (1-vi$undo_map)*2)
		));

	SPLIT_LINE;

	IF vi$tag_case = EXACT THEN
		ic := 0;
	ELSE
		ic := 2;
	ENDIF;

	COPY_TEXT (FAO (
			"!20<!AStagcase!>!20<window=!UL!>!20<width=!UL!>tags=!AS",
			SUBSTR ("no", 1, ic),
			GET_INFO (CURRENT_WINDOW, "VISIBLE_LENGTH"),
			GET_INFO (CURRENT_WINDOW, "WIDTH"),
			vi$tag_files
		));

	SPLIT_LINE;

	COPY_TEXT (FAO (
			"!20<!ASerrorbells!>!20<paragraphs=!AS!>!20<sections=!AS!>"+
				"!20<!ASsenddcl!>",
			SUBSTR ("no", 1, (1-vi$error_bells)*2),
			vi$para_str,           
			vi$sect_str,
			SUBSTR ("no", 1, (1-vi$send_dcl)*2)
		));

	SPLIT_LINE;

	readonly := vi$getbufmode (obuf);
	COPY_TEXT (FAO (
		"!20<!ASshowmode!>!20<!ASautoindent!>!20<!ASempty!>!20<!ASreadonly!>",
			SUBSTR ("no", 1, (1-vi$show_mode)*2),
			SUBSTR ("no", 1, (1-vi$auto_indent)*2),
			SUBSTR ("no", 1, (vi$delete_empty)*2),
			SUBSTR ("no", 1, (1-readonly)*2)
		));

	SPLIT_LINE;

	MAP (CURRENT_WINDOW, buf);
	UPDATE (CURRENT_WINDOW);
	LOOP
		EXITIF vi$read_a_key = RET_KEY;
	ENDLOOP;

	SET (STATUS_LINE, CURRENT_WINDOW, NONE, "");
	SET (STATUS_LINE, CURRENT_WINDOW, ovid, ostat);
	MAP (CURRENT_WINDOW, obuf);
	POSITION (obuf);
	DELETE (buf);
ENDPROCEDURE;

!
!
!
PROCEDURE vi$makebufname (buf)
	LOCAL
		i,
		ch,
		bname,
		nname;

	nname := "";
	bname := GET_INFO (buf, "NAME");

	i := 1;
	LOOP
		EXITIF i > LENGTH (bname);
		ch := SUBSTR (bname, i, 1);
		IF INDEX (vi$_sym_chars, ch) <> 0 THEN
			nname := nname + ch;
		ENDIF;
		i := i + 1;
	ENDLOOP;

	RETURN (nname);
ENDPROCEDURE;

!
!
!
PROCEDURE vi$getbufmode (buf)
	LOCAL
		nname;

	ON_ERROR
		RETURN (1);
	ENDON_ERROR;

	IF (GET_INFO (buf, "SYSTEM")) THEN
		RETURN (1);
	ELSE
		nname := vi$makebufname (buf);
		vi$global_var := 0;
		EXECUTE (COMPILE ("vi$global_var := vi$bmode_"+nname));
		RETURN (vi$global_var);
	ENDIF;
ENDPROCEDURE;

!
!
!
PROCEDURE vi$setbufmode (buf, bmode)
	LOCAL
		nname;

	nname := vi$makebufname (buf);
	EXECUTE (COMPILE ("vi$bmode_"+nname+":="+STR(bmode)));
ENDPROCEDURE;

!
!	Function to say that a particular command is not implemented.
!
PROCEDURE vi$not_implemented (cmd)
	vi$info (cmd + " is not implemented!");
ENDPROCEDURE;

!
!	The function mapped to 't'.
!
PROCEDURE vi$_to_char (char_to_find)
	LOCAL
		char_val;

	char_val := char_to_find;
	vi$beep_position (vi$to_char (char_val), 0, 1);
ENDPROCEDURE;

!
!	Function performing task for 't'.
!
PROCEDURE vi$to_char (ch_to_find)

	LOCAL
		char_to_find,
		act_count,
		pos,
		found;

	char_to_find := ch_to_find;
	IF char_to_find = 0 THEN
		char_to_find := vi$read_char_to_find;
	ENDIF;

	vi$last_s_char := char_to_find;
	vi$last_s_func := "vi$to_char";

	pos := MARK(NONE);

	act_count := vi$cur_active_count;

	IF (MARK (NONE) = END_OF (CURRENT_BUFFER)) THEN
		RETURN (0);
	ENDIF;

	MOVE_HORIZONTAL (1);

	IF char_to_find <> ASCII(27) THEN
		found := 0;
		LOOP
			EXITIF (CURRENT_OFFSET >= LENGTH (vi$current_line));
			MOVE_HORIZONTAL (1);
			found := 1;
			IF (CURRENT_CHARACTER = char_to_find) THEN
				act_count := act_count - 1;
				EXITIF (act_count = 0);
			ENDIF;
			found := 0;
		ENDLOOP;

		IF (NOT found) THEN
			POSITION (pos);
			RETURN (0);
		ELSE
			vi$move_horizontal (-1);
		ENDIF;
	ENDIF;

	vi$yank_mode := VI$IN_LINE_MODE;
	RETURN (vi$retpos (pos));

ENDPROCEDURE;

!
!	The function mapped to 'T'.
!
PROCEDURE vi$_back_to_char (char_to_find)

	LOCAL
		char_val;

	char_val := char_to_find;
	vi$beep_position (vi$back_to_char (char_val), 0, 1);
ENDPROCEDURE;

!
!	Function performing task for 'T'.
!
PROCEDURE vi$back_to_char (ch_to_find)

	LOCAL
		char_to_find,
		act_count,
		pos,
		found;

	char_to_find := ch_to_find;
	IF char_to_find = 0 THEN
		char_to_find := vi$read_char_to_find;
	ENDIF;

	vi$last_s_char := char_to_find;
	vi$last_s_func := "vi$back_to_char";

	pos := MARK(NONE);

	IF (CURRENT_OFFSET = 0) THEN
		RETURN (0);
	ENDIF;

	vi$move_horizontal (-1);
	IF (CURRENT_CHARACTER <> char_to_find) THEN
		vi$move_horizontal (1);
	ENDIF;

	act_count := vi$cur_active_count;

	IF char_to_find <> ASCII(27) THEN
		found := 0;
		LOOP
			EXITIF (CURRENT_OFFSET = 0);
			vi$move_horizontal (-1);
			found := 1;
			IF (CURRENT_CHARACTER = char_to_find) THEN
				act_count := act_count - 1;
				EXITIF (act_count = 0);
			ENDIF;
			found := 0;
		ENDLOOP;

		IF (NOT found) THEN
			POSITION (pos);
			RETURN (0);
		ELSE
			MOVE_HORIZONTAL(1);
		ENDIF;
	ENDIF;

	vi$yank_mode := VI$IN_LINE_MODE;
	RETURN (vi$retpos (pos));
ENDPROCEDURE;

!
!	The function mapped to 'f'.
!
PROCEDURE vi$_find_char (char_to_find)

	LOCAL
		char_val;

	char_val := char_to_find;
	vi$beep_position (vi$find_char (char_val), 0, 1);
ENDPROCEDURE;

!
!	Function performing task for 'f'.
!
PROCEDURE vi$find_char (ch_to_find)

	LOCAL
		char_to_find,
		act_count,
		pos,
		found;

	char_to_find := ch_to_find;
	IF char_to_find = 0 THEN
		char_to_find := vi$read_char_to_find;
	ENDIF;

	vi$last_s_char := char_to_find;
	vi$last_s_func := "vi$find_char";

	act_count := vi$cur_active_count;

	IF char_to_find <> ASCII(27) THEN
		pos := MARK(NONE);
		found := 0;
		LOOP
			EXITIF (CURRENT_OFFSET >= LENGTH (vi$current_line));
			MOVE_HORIZONTAL (1);
			found := 1;
			IF (CURRENT_CHARACTER = char_to_find) THEN
				act_count := act_count - 1;
				EXITIF (act_count = 0);
			ENDIF;
			found := 0;
		ENDLOOP;

		IF (NOT found) THEN
			POSITION (pos);
			RETURN (0);
		ENDIF;
	ELSE
		RETURN (0);
	ENDIF;

	vi$yank_mode := VI$IN_LINE_MODE;
	RETURN (vi$retpos(pos));
ENDPROCEDURE;

!
!	The function mapped to 'F'.
!
PROCEDURE vi$_back_find_char (char_to_find)

	LOCAL
		char_val;

	char_val := char_to_find;
	vi$beep_position (vi$back_find_char (char_val), 0, 1);
ENDPROCEDURE;

!
!	Function performing task for 'F'.
!
PROCEDURE vi$back_find_char (ch_to_find)

	LOCAL
		char_to_find,
		act_count,
		pos,
		found;

	char_to_find := ch_to_find;
	IF char_to_find = 0 THEN
		char_to_find := vi$read_char_to_find;
	ENDIF;

	vi$last_s_char := char_to_find;
	vi$last_s_func := "vi$back_find_char";

	act_count := vi$cur_active_count;

	IF char_to_find <> ASCII(27) THEN
		pos := MARK(NONE);

		LOOP
			found := 0;
			EXITIF CURRENT_OFFSET = 0;
			vi$move_horizontal (-1);
			found := 1;
			IF (CURRENT_CHARACTER = char_to_find) THEN
				act_count := act_count - 1;
				EXITIF act_count = 0;
			ENDIF;
		ENDLOOP;

		IF (NOT found) THEN
			POSITION (pos);
			RETURN (0);
		ENDIF;
	ENDIF;

	vi$yank_mode := VI$IN_LINE_MODE;
	RETURN (vi$retpos (pos));
ENDPROCEDURE;

!
!	Function to read a key, and change TAB_KEY to ASCII (9).  Currently
!	used by f, F, t and T commands only.
!
PROCEDURE vi$read_char_to_find
	LOCAL
		rkey;

	rkey := vi$read_a_key;
	IF (rkey = TAB_KEY) THEN
		RETURN (ASCII (9));
	ELSE
		IF (rkey = RET_KEY) THEN
			RETURN (ASCII (13));
		ELSE
			IF (rkey = DEL_KEY) THEN
				RETURN (ASCII (8));
			ENDIF;
		ENDIF;
	ENDIF;
	RETURN (ASCII (rkey));
ENDPROCEDURE;
!
!	The function mapped to 'G'.
!
PROCEDURE vi$go_to_line
	LOCAL
		opos,
		curline,
		pos;

	opos := MARK (NONE);
	IF (vi$beep_position (vi$to_line (vi$active_count), 1, 1) <> 0) THEN
		pos := MARK (NONE);
		POSITION (opos);
		vi$pos_in_middle (pos);
	ENDIF;

	vi$active_count := 0;
ENDPROCEDURE;

!
!   Move to line in file.  vi$active_count holds the line number to GO TO.
!	If VI$ACTIVE_COUNT is zero, we move to the end of the file.
!
PROCEDURE vi$to_line (cnt)

	LOCAL
		this_pos,			! Saved position in case of botch
		last_line,			! Last line in the buffer
		win_len;			! Length of CURRENT_WINDOW

	ON_ERROR
		vi$info (FAO ("No such line: !SL", VI$ACTIVE_COUNT));
		POSITION (this_pos);
		cnt := 0;
		RETURN;
	ENDON_ERROR;

	this_pos := MARK(NONE);
	POSITION (LINE_BEGIN);
	vi$start_pos := MARK (NONE);

	IF cnt = 0 THEN
		POSITION (END_OF (CURRENT_BUFFER));
	ELSE
		last_line := GET_INFO (CURRENT_BUFFER, "RECORD_COUNT");

		IF cnt > last_line THEN
			IF last_line > 0 THEN
				vi$info ("Not that many lines in buffer");
				POSITION (this_pos);
				RETURN (0);
			ENDIF;
		ELSE
			POSITION (BEGINNING_OF (CURRENT_BUFFER));
			win_len := GET_INFO (CURRENT_WINDOW, "VISIBLE_LENGTH");
			MOVE_VERTICAL (cnt - 1);
		ENDIF;
	ENDIF;

	IF (MARK (NONE) <> END_OF (CURRENT_BUFFER)) THEN
		IF (MARK (NONE) = BEGINNING_OF (CURRENT_BUFFER)) THEN
			vi$new_endpos := MARK (NONE);
		ELSE
			MOVE_VERTICAL (1);
			vi$new_endpos := MARK (NONE);
			MOVE_VERTICAL (-1);
		ENDIF;
	ENDIF;

	vi$yank_mode := VI$LINE_MODE;
	RETURN (vi$retpos (this_pos));
ENDPROCEDURE;

!
!	Set a marker in the current buffer.
!
PROCEDURE vi$_set_mark

	LOCAL
		mark_char,
		mark_name,
		key_pressed;

	key_pressed := vi$read_a_key;

	mark_char := ASCII (key_pressed);
	IF (INDEX (vi$_lower_chars, mark_char) <> 0) THEN
		mark_name := "vi$mark_" + mark_char;
		EXECUTE (COMPILE (mark_name + " := MARK(NONE);"));
	ELSE
		vi$info ("Invalid marker key!");
	ENDIF;

ENDPROCEDURE;

!
!	Function mapped to "'" and "`".
!
PROCEDURE vi$_go_to_marker
	LOCAL
		opos,
		pos;

	opos := MARK (NONE);
	IF (vi$beep_position (vi$to_marker, 1, 1) <> 0) THEN
		pos := MARK (NONE);
		POSITION (opos);
		vi$pos_in_middle (pos);
	ENDIF;
ENDPROCEDURE;

!
!	Function to move the marker indicated by the next keystroke.
!
PROCEDURE vi$to_marker

	LOCAL
		mode_key,
		pos,
		mark_name,
		mark_char,
		key_pressed;

	ON_ERROR;
		vi$info ("Mark not set!");
		RETURN (0);
	ENDON_ERROR;

	mode_key := vi$last_key;
	key_pressed := vi$read_a_key;

	mark_char := ASCII (key_pressed);
	IF (INDEX (vi$_lower_chars+"'`", mark_char) = 0) THEN
		vi$info ("Invalid marker key!");
		RETURN (0);
	ENDIF; 

	pos := MARK (NONE);
	IF (key_pressed <> F11) THEN
		IF (mark_char = "'") OR (mark_char = "`") THEN
			IF (vi$old_place <> 0) THEN
				IF (GET_INFO (vi$old_place, "BUFFER") = CURRENT_BUFFER) THEN
					POSITION (vi$old_place);
				ELSE
		   			vi$info ("Previous place not in this buffer!");
					RETURN (0);
				ENDIF;
			ELSE
				vi$info ("No previous mark to return to!");
				RETURN (0);
			ENDIF;
		ELSE
			mark_name := "vi$mark_" + mark_char;
			EXECUTE (COMPILE ("vi$global_mark := "+mark_name+";"));

			IF (vi$global_mark <> 0) AND (GET_INFO (vi$global_mark, "BUFFER") =
															CURRENT_BUFFER) THEN
				POSITION (vi$global_mark);
				vi$yank_mode := VI$LINE_MODE;
			ELSE
				vi$info ("Invalid mark for this buffer!");
				RETURN (0);
			ENDIF;
		ENDIF;

		IF ASCII (mode_key) = "'" THEN
			POSITION (LINE_BEGIN);
			POSITION (vi$first_no_space (0));
		ENDIF;

		IF (MARK (NONE) <> END_OF (CURRENT_BUFFER)) THEN
			MOVE_VERTICAL (1);
			vi$new_endpos := MARK (NONE);
			MOVE_VERTICAL (-1);
		ENDIF;

		RETURN (vi$retpos (pos));
	ENDIF;

	POSITION (pos);
	RETURN (0);
ENDPROCEDURE;

!
!	Maintain the repeat count in vi$active_count.  If VI$ACTIVE_COUNT is ZERO,
!	and '0' is typed, this means move to beginning of the line.
!
PROCEDURE vi$repeat_count

	IF vi$active_count = 0 THEN
		vi$active_count := INT (ASCII (KEY_NAME (vi$last_key)));
		IF vi$active_count = 0 THEN
			vi$beep_position (vi$fol, 0, 1);
		ENDIF;
	ELSE
		vi$active_count := vi$active_count * 10 +
									INT (ASCII (KEY_NAME (vi$last_key)));
	ENDIF;

ENDPROCEDURE;

!
!	The function mapped to <CR>.
!
PROCEDURE vi$_next_line
	POSITION (vi$beg_next);
ENDPROCEDURE;

!
!	Move the cursor to the beginning of the next line
!
PROCEDURE vi$beg_next
	LOCAL
		pos;

	ON_ERROR
		RETURN (MARK (NONE));
	ENDON_ERROR;

	pos := MARK (NONE);
	MOVE_VERTICAL (vi$cur_active_count);
	POSITION (LINE_BEGIN);
	POSITION (vi$first_no_space (0));
	vi$yank_mode := VI$LINE_MODE;
	vi$new_offset := 1;
	RETURN (vi$retpos (pos));

ENDPROCEDURE;

!                                 
!	This function moves to the first non-blank character of a line
!
PROCEDURE vi$first_no_space (use_cur_active)

	LOCAL
		pos,
		t_range;

	ON_ERROR
		! Ignore string not found messages.

		IF ERROR <> TPU$_STRNOTFOUND THEN
			POSITION (pos);
			RETURN (0);
		ENDIF;
	ENDON_ERROR;

	pos := MARK (NONE);
	IF (use_cur_active) THEN
		MOVE_VERTICAL (vi$cur_active_count - 1);
	ENDIF;
	POSITION (LINE_BEGIN);

	IF (LENGTH (CURRENT_LINE) > 0) THEN
		IF t_range = 0 THEN
			t_range :=
				SEARCH (ANCHOR & SPAN (vi$no_space) &
										NOTANY(vi$no_space), FORWARD);
		ENDIF;

		IF t_range <> 0 THEN
			POSITION (END_OF (t_range));
		ELSE
			! If that fails, then search for a blank line with extra white
			! space, and move to the end of the white space.

			t_range := SEARCH (ANCHOR & SPAN (vi$no_space), FORWARD);

			IF t_range <> 0 THEN
				POSITION (END_OF (t_range));
			ENDIF;
		ENDIF;
	ENDIF;

	vi$yank_mode := VI$IN_LINE_MODE;
	RETURN (vi$retpos (pos));
ENDPROCEDURE;

!
!	Move by a section in the indicated direction
!
PROCEDURE vi$_section (dir)
	LOCAL
		ch;

	ch := vi$read_a_key;
	IF ((ASCII(ch) = "]") AND (dir = 1)) OR
		((ASCII(ch) = "[") AND (dir = -1)) THEN
		vi$beep_position (vi$section (dir), 1, 1);
	ELSE
		vi$beep;
	ENDIF;
ENDPROCEDURE;

!
!	Sound a bell.
!
PROCEDURE vi$beep
	LOCAL
		ln,
		pos;

	IF (vi$error_bells = 0) THEN
		RETURN;
	ENDIF;

	pos := MARK (NONE);
	POSITION (message_buffer);
	ln := vi$current_line;
	SET (BELL, ALL, ON);
	POSITION (pos);
	vi$info (ln);
	SET (BELL, ALL, OFF);
	SET (BELL, BROADCAST, ON);
ENDPROCEDURE;

!
!	Mapped to '}' and '{', moves by a paragraph in the indicated direction.
!
PROCEDURE vi$_paragraph(dir)
	vi$beep_position (vi$paragraph(dir), 1, 1);
ENDPROCEDURE;

!
!	Mapped to ( moves backward a sentence
!
PROCEDURE vi$_begin_sentence
	vi$beep_position (vi$begin_sentence, 1, 1);
ENDPROCEDURE;

!
!	Mapped to ) moves forward a sentence
!
PROCEDURE vi$_end_sentence
	vi$beep_position (vi$end_sentence, 1, 1);
ENDPROCEDURE;

!
!	Move backward a sentence.
!
PROCEDURE vi$begin_sentence
	LOCAL
		rng,
		spos,
		pos;

	ON_ERROR;
	ENDON_ERROR;

	pos := MARK (NONE);

	MOVE_HORIZONTAL (-1);

	LOOP;
		rng := SEARCH (
			(("" | " " | ASCII (9)) & ANY (vi$_upper_chars)),
			REVERSE, EXACT);

		EXITIF rng = 0;

		POSITION (BEGINNING_OF (rng));
		IF INDEX (vi$_space_tab, CURRENT_CHARACTER) = 0 THEN
			MOVE_HORIZONTAL (-1);
		ENDIF;
		IF INDEX (vi$_space_tab, CURRENT_CHARACTER) <> 0 THEN
			IF (CURRENT_CHARACTER = " ") THEN
				MOVE_HORIZONTAL (-1);
				IF INDEX (vi$_space_tab, CURRENT_CHARACTER) <> 0 THEN
					MOVE_HORIZONTAL (-1);
					IF INDEX ("?.!", CURRENT_CHARACTER) <> 0 THEN
						MOVE_HORIZONTAL (3);
						RETURN (vi$retpos (pos));
					ENDIF;
				ENDIF;
			ELSE
				MOVE_HORIZONTAL (1);
				RETURN (vi$retpos (pos));
			ENDIF;
		ENDIF;
		POSITION (BEGINNING_OF (rng));
		MOVE_HORIZONTAL (-1);
	ENDLOOP;

	RETURN (0);
ENDPROCEDURE;

!
!	Move to next paragraph
!
PROCEDURE vi$paragraph (dir)
	RETURN (vi$para_sect (dir, vi$para_pat));
ENDPROCEDURE;

!
!	Find next paragraph or section.
!
PROCEDURE vi$para_sect (dir, pat)
	LOCAL
		loc,
		direct,
		pos;

	pos := MARK (NONE);

	IF (dir < 0) THEN
		direct := REVERSE;
		MOVE_VERTICAL (-1);
	ELSE
		direct := FORWARD;
		MOVE_VERTICAL (1);
	ENDIF;

	loc := SEARCH (pat, direct, NO_EXACT);

	IF (loc <> 0) THEN
		RETURN (BEGINNING_OF (loc));
	ENDIF;

	POSITION (pos);
	RETURN (0);
ENDPROCEDURE;

!
!	Move to next section
!
PROCEDURE vi$section (dir)
	RETURN (vi$para_sect (dir, vi$sect_pat));
ENDPROCEDURE;

!
!	Move forward a sentence.
!
PROCEDURE vi$end_sentence
	LOCAL
		rng,
		spos,
		pos;

	ON_ERROR;
	ENDON_ERROR;

	pos := MARK (NONE);

	MOVE_HORIZONTAL (1);

	LOOP;
		rng := SEARCH (ANY (vi$_upper_chars), FORWARD, EXACT);

		EXITIF rng = 0;

		POSITION (BEGINNING_OF (rng));
		IF INDEX (vi$_space_tab, CURRENT_CHARACTER) = 0 THEN
			MOVE_HORIZONTAL (-1);
		ENDIF;
		IF INDEX (vi$_space_tab, CURRENT_CHARACTER) <> 0 THEN
			IF (CURRENT_CHARACTER = " ") THEN
				MOVE_HORIZONTAL (-1);
				IF INDEX (vi$_space_tab, CURRENT_CHARACTER) <> 0 THEN
					MOVE_HORIZONTAL (-1);
					IF INDEX ("?.!", CURRENT_CHARACTER) <> 0 THEN
						MOVE_HORIZONTAL (3);
						RETURN (vi$retpos (pos));
					ENDIF;
				ENDIF;
			ELSE
				MOVE_HORIZONTAL (1);
				RETURN (vi$retpos (pos));
			ENDIF;
		ENDIF;
		POSITION (BEGINNING_OF (rng));
		MOVE_HORIZONTAL (1);
	ENDLOOP;

	RETURN (0);
ENDPROCEDURE;

!
!	This function returns the value in vi$active count.  It takes into
!	account that when vi$active_count is zero, it should really be
!	one.
!
PROCEDURE vi$cur_active_count
	LOCAL
		resp,
		old_cnt;

	old_cnt := vi$active_count;
	vi$active_count := 0;
	IF old_cnt <= 0 THEN
		old_cnt := 1;
	ENDIF;

	RETURN (old_cnt);
ENDPROCEDURE;

!
!	The function mapped to 'p'.
!
PROCEDURE vi$put_after (dest_buf)

	LOCAL
		source,
		pos;

	source := vi$cur_text;

	IF (GET_INFO (dest_buf, "TYPE") = BUFFER) THEN
		source := dest_buf;
	ENDIF;

	IF (GET_INFO (source, "TYPE") = BUFFER) THEN
		pos := MARK (NONE);
		POSITION (BEGINNING_OF (source));
		vi$yank_mode := INT (vi$current_line);
		POSITION (pos);
	ENDIF;

	IF (source = "") THEN
		RETURN;
	ENDIF;

	IF (vi$yank_mode = VI$LINE_MODE) THEN
		IF (MARK(NONE) <> END_OF (CURRENT_BUFFER)) THEN
			MOVE_VERTICAL (1);
		ENDIF;
	ELSE
		IF (LENGTH (CURRENT_LINE) > 0) THEN
			MOVE_HORIZONTAL (1);
		ENDIF;
	ENDIF;

	vi$put_here (VI$AFTER, source);
ENDPROCEDURE;

!
!	The function mapped to 'P'.
!
PROCEDURE vi$put_here (here_or_below, dest_buf)
	LOCAL
		olen,
		source,
		pos;

	source := vi$cur_text;
	olen := GET_INFO (CURRENT_BUFFER, "RECORD_COUNT");

	IF (GET_INFO (dest_buf, "TYPE") = BUFFER) THEN
		source := dest_buf;
	ENDIF;

	IF (GET_INFO (source, "TYPE") = BUFFER) THEN
		pos := MARK (NONE);
		POSITION (BEGINNING_OF (source));
		IF (MARK (NONE) = END_OF (source)) THEN
			RETURN;
		ENDIF;
		vi$yank_mode := INT (vi$current_line);
		ERASE_LINE;
		POSITION (pos);
	ELSE
		IF (source = "") THEN
			RETURN;
		ENDIF;
	ENDIF;

	IF source = 0 THEN
		vi$info ("Bad buffer for put!");
		RETURN;
	ENDIF;

	IF (vi$yank_mode = VI$LINE_MODE) THEN
		POSITION (LINE_BEGIN);
	ENDIF;

	pos := vi$get_undo_start;

	COPY_TEXT (source);
	APPEND_LINE;
	MOVE_HORIZONTAL (-1);
	vi$undo_end := MARK (NONE);
	MOVE_HORIZONTAL (1);

	vi$kill_undo;

	IF (here_or_below = VI$AFTER) AND (vi$yank_mode = VI$LINE_MODE) THEN
		POSITION (LINE_BEGIN);
	ENDIF;

	vi$undo_start := vi$set_undo_start (pos);

	! Put the mode back into the buffer.

	IF (GET_INFO (source, "TYPE") = BUFFER) THEN
	   	POSITION (BEGINNING_OF (source));
		COPY_TEXT (STR (vi$yank_mode));
		SPLIT_LINE;
		POSITION (vi$undo_start);
	ENDIF;

	IF (here_or_below = VI$AFTER) AND (vi$yank_mode = VI$IN_LINE_MODE) THEN
		POSITION (vi$undo_end);
	ENDIF;

	vi$check_length (olen);
ENDPROCEDURE;

!
!	Function mapped to 'o'.
!
PROCEDURE vi$open_below
	LOCAL
		uline;

	ON_ERROR
		! Ignore attempt to move past EOB errors
	ENDON_ERROR;

	uline := vi$cur_line_no;
	MOVE_VERTICAL (1);
	vi$open_here;
	vi$undo_line := uline;

ENDPROCEDURE;

!
!	Function mapped to 'O'
!
PROCEDURE vi$open_here

	LOCAL
		uline,
		offs,
		cnt,
		epos,
		spos;

	uline := vi$cur_line_no;
	offs := CURRENT_OFFSET;

	POSITION (LINE_BEGIN);

	IF (MARK (NONE) <> BEGINNING_OF (CURRENT_BUFFER)) THEN
		MOVE_HORIZONTAL (-1);
		spos := MARK (NONE);
		MOVE_HORIZONTAL (1);
	ELSE
		spos := 0;
	ENDIF;

	SPLIT_LINE;

	MOVE_VERTICAL (-1);

	cnt := vi$while_not_esc;

	IF (cnt <> 0) THEN
		IF (LENGTH(vi$current_line) > 0) THEN
			MOVE_HORIZONTAL (1);
		ENDIF;
	ENDIF;
	epos := MARK (NONE);
	vi$undo_end := MARK (NONE);

	vi$undo_start := vi$set_undo_start (spos);

	POSITION (epos);

	vi$kill_undo;

	vi$undo_line := uline;
	vi$undo_offset := offs;                            
ENDPROCEDURE;

!
!	This function guards the right margin, and the end of the buffer so
!	that the cursor never is displayed past those boundries.
!
PROCEDURE vi$check_rmarg

	ON_ERROR;
		! ignore "Can't return line and end of buffer" messages
		RETURN;
	ENDON_ERROR;

	IF (LENGTH (vi$current_line) > 0) THEN
		IF (CURRENT_OFFSET = LENGTH (vi$current_line)) THEN
			MOVE_HORIZONTAL (-1);
		ENDIF;
	ENDIF;

	IF (MARK (NONE) = END_OF (CURRENT_BUFFER)) THEN
		MOVE_VERTICAL (-1);
	ENDIF;
ENDPROCEDURE;

!
!	The function mapped to 'h'.
!
PROCEDURE vi$move_left
	vi$beep_position (vi$left, 0, 1);
ENDPROCEDURE;

!
!	The function mapped to 'l'.
!
PROCEDURE vi$move_right
	vi$beep_position (vi$right, 0, 1);
ENDPROCEDURE;

!
!	The function mapped to 'j'
!
PROCEDURE vi$move_down
	LOCAL
		save_mark;

	save_mark := 0;

	IF (vi$active_count >= vi$report) THEN
		save_mark := 1;
	ENDIF;

	vi$beep_position (vi$downline (0), save_mark, 1);
ENDPROCEDURE;

!
!	The function mapped to 'k'.
!
PROCEDURE vi$move_up
	LOCAL
		save_mark;

	save_mark := 0;

	IF (vi$active_count >= vi$report) THEN
		save_mark := 1;
	ENDIF;

	vi$beep_position (vi$upline, save_mark, 1);
ENDPROCEDURE;

!
!	The function mapped to 'i'.
!
PROCEDURE vi$insert_here
	LOCAL
		act_cnt,
		rnge,
		ccnt,
		epos,
		spos;

	vi$kill_undo;

	IF (MARK (NONE) <> BEGINNING_OF (CURRENT_BUFFER)) THEN
		MOVE_HORIZONTAL (-1);
		spos := MARK (NONE);
		MOVE_HORIZONTAL (1);
	ELSE
		spos := 0;
	ENDIF;

	vi$undo_start := MARK (NONE);

	ccnt := vi$while_not_esc;

	vi$undo_end := 0;

	IF (ccnt > 0) THEN
		epos := MARK (NONE);
		IF (MARK (NONE) <> BEGINNING_OF (CURRENT_BUFFER)) THEN
			MOVE_HORIZONTAL (1);
		ENDIF;
	ELSE
		epos := 0;
		IF (CURRENT_OFFSET <> 0) THEN
			MOVE_HORIZONTAL (-1);
		ENDIF;
	ENDIF;

	act_cnt := vi$cur_active_count;
	IF epos <> 0 THEN

		IF spos <> 0 THEN
			POSITION (spos);
			MOVE_HORIZONTAL (1);
		ELSE
			POSITION (BEGINNING_OF (CURRENT_BUFFER));
		ENDIF;
		vi$undo_start := MARK (NONE);

		POSITION (epos);

		IF (vi$undo_start = 0) OR (epos = 0) THEN
			vi$info ("Ooops, bad markers in vi$insert_here");
			RETURN ;
		ENDIF;

		rnge := CREATE_RANGE (vi$undo_start, epos, NONE);

		LOOP
			EXITIF act_cnt < 2;
			MOVE_HORIZONTAL (1);

			IF rnge = 0 THEN
				vi$info ("Ooops, generated a bad range in vi$insert_here");
				RETURN ;
			ENDIF;

			COPY_TEXT (rnge);
			act_cnt := act_cnt - 1;
			MOVE_HORIZONTAL (-1);
		ENDLOOP;

		vi$undo_end := MARK (NONE);
		IF (CURRENT_OFFSET = LENGTH (vi$current_line)) THEN
			MOVE_HORIZONTAL (1);
		ENDIF;     
	ENDIF;
ENDPROCEDURE;

!
!	The function mapped to 'I'
!
PROCEDURE vi$insert_at_begin

	POSITION (LINE_BEGIN);
	vi$_bol (0);
	vi$insert_here;

ENDPROCEDURE;

!
!	The function mapped to 'a'
!
PROCEDURE vi$insert_after

	LOCAL
		cline,
		coff;

	coff := CURRENT_OFFSET;
	cline := vi$cur_line_no;

	IF (LENGTH (vi$current_line) > 0) THEN
		IF (CURRENT_OFFSET < LENGTH(vi$current_line)) THEN
			MOVE_HORIZONTAL (1);
		ENDIF;
	ENDIF;
	vi$insert_here;
	vi$undo_offset := coff;
	vi$undo_line := cline;

ENDPROCEDURE;

!
!  A do nothing function
!
PROCEDURE vi$_dummy
ENDPROCEDURE;

!
!  Do the command line input processing
!
PROCEDURE vi$while_not_esc

	LOCAL
		max_mark,
		start_pos,
		max_col;

	max_col := CURRENT_OFFSET;
	start_pos := max_col;
	max_mark := MARK(NONE);
	vi$update (CURRENT_WINDOW);

	RETURN (vi$line_edit (max_col, start_pos, max_mark, 0));
ENDPROCEDURE;

!
!	Insert text into the buffer using standard VI insertion.
!	Used by CHANGE, APPEND, INSERT, and REPLACE functions.
!
PROCEDURE vi$line_edit (max_col, start_pos, max_mark, replace)

	LOCAL
		chcnt,
		offset,
		seen_eol,
		col,
		cnt,
		tabstops,
		current_mark,
		desc,
		start_ins,
		ins_text,
		should_wrap,
		abbrs,
		rchar,
		abbrlen,
		cabbr,
		cmode,
		pos,
		did_ai, 
		in_char;

	ON_ERROR
	ENDON_ERROR;

	! If show mode is in effect the show the mode.

	IF (vi$show_mode) THEN
		vi$mess_select (BOLD);
		MESSAGE (FAO ("!7*	INSERT"));
		vi$mess_select (REVERSE);
	ENDIF;

	chcnt := 0;
	seen_eol := 0;

	! Get the list of current abbreviation variable names.

	abbrs := EXPAND_NAME ("vi$abbr_", VARIABLES) + " ";

	cabbr := "";
	abbrlen := 0;

	! Now decide whether we are entering from a change or replace command
	! verses an insert or append command.  If it is change or replace, then
	! we must set the buffer to overstrike so that we can type over things
	! until we get to the right marker, max_col.

	SET (INSERT, CURRENT_BUFFER);
	IF (max_col > CURRENT_OFFSET) OR (replace <> 0) THEN
		SET (OVERSTRIKE, CURRENT_BUFFER);
	ENDIF;

	! Save the starting position for repeat_last_typed_text.

	start_ins := vi$get_undo_start();

	! Add the initial auto indent margin.

	chcnt := vi$do_auto_indent(0);
	did_ai := (chcnt <> 0);
	IF (did_ai) THEN
		max_col := CURRENT_OFFSET;
		max_mark := MARK (NONE);
	ENDIF;

	LOOP		! Until escape is pressed.
		LOOP	! Until we are not reinserting previously typed text.
			in_char := vi$read_a_key;
			desc := LOOKUP_KEY (KEY_NAME (in_char), COMMENT, vi$edit_keys);
			IF (desc = "entab") THEN
				IF (vi$auto_indent = 0) THEN
					EXITIF (1);
				ENDIF;
				vi$do_entab;
				max_col := CURRENT_OFFSET;
				max_mark := MARK (NONE);
			ELSE
				IF (desc = "detab") THEN
					IF (vi$auto_indent = 0) THEN
						EXITIF (1);
					ENDIF;
					vi$do_detab;
					max_col := CURRENT_OFFSET;
					max_mark := MARK (NONE);
				ELSE
					EXITIF (desc <> "reinsert");

					IF max_mark <> MARK (NONE) THEN
						current_mark := MARK (NONE);
						POSITION (max_mark);
						MOVE_HORIZONTAL (-1);

						ERASE (CREATE_RANGE (MARK (NONE), current_mark, NONE));
					ENDIF;

					SET (INSERT, CURRENT_BUFFER);
					COPY_TEXT (vi$last_insert);
					APPEND_LINE;

					max_col := CURRENT_OFFSET;
					start_pos := CURRENT_OFFSET;
					max_mark := MARK(NONE);
					chcnt := chcnt + 1;
				ENDIF;
			ENDIF;
		ENDLOOP;

		! Out when escape is pressed.

		EXITIF desc = "escape";

		! Catch maps.

		IF (desc = "active_macro") THEN
			EXECUTE (LOOKUP_KEY (KEY_NAME (in_char), PROGRAM, vi$edit_keys));
		ELSE

			! If this is a typing key....

			IF (desc <> "eol") AND (desc <> "bword") AND (desc <> "bs") THEN

				! Check if :set wm is in effect, and we are at the right margin.

				should_wrap := (vi$wrap_margin <> 0) AND
							((CURRENT_OFFSET + vi$wrap_margin) > vi$scr_width);

				! If we should do line wrapping.

				IF (should_wrap) THEN

					! Backup over the last word.

					offset := 0;
					MOVE_HORIZONTAL (-1);

					LOOP
						EXITIF (CURRENT_OFFSET = 0);
						EXITIF (INDEX (vi$_space_tab, CURRENT_CHARACTER) <> 0);
						MOVE_HORIZONTAL (-1);
						offset := offset + 1;
					ENDLOOP;           

					! Trim off the white space.

					IF (offset <> 0) THEN
						ERASE_CHARACTER (1);
						LOOP
							EXITIF (CURRENT_OFFSET = 0);
							MOVE_HORIZONTAL (-1);
							EXITIF (
								INDEX (vi$_space_tab, CURRENT_CHARACTER) = 0);
							ERASE_CHARACTER (1);
						ENDLOOP;
					ENDIF;

					! Split the line at the proper place, and reset the
					! markers.

					IF (CURRENT_OFFSET <> 0) THEN
						MOVE_HORIZONTAL (1);
						SPLIT_LINE;
						max_col := CURRENT_OFFSET;
						start_pos := CURRENT_OFFSET;
						max_mark := MARK(NONE);
						MOVE_HORIZONTAL (offset);
					ELSE          
						MOVE_HORIZONTAL (offset);
						SPLIT_LINE;
						max_col := CURRENT_OFFSET;
						start_pos := CURRENT_OFFSET;
						max_mark := MARK(NONE);
					ENDIF;

					! After spliting, put in the left margin.

					did_ai := (vi$do_auto_indent(1) <> 0);
				ENDIF;            

				! Make sure the window is up to date.

				vi$update (CURRENT_WINDOW);

				! If the key was ^V then read another.

				IF desc = "vquote" THEN
					COPY_TEXT ("^");
					MOVE_HORIZONTAL (-1);
					vi$update (CURRENT_WINDOW);
					in_char := vi$read_a_key;
					IF (GET_INFO (CURRENT_BUFFER, "MODE") = INSERT) THEN
						ERASE_CHARACTER (1);
					ENDIF;
				ENDIF;

				! Insert a tab?

				IF in_char = TAB_KEY THEN

					! Check for a completed abbreviation.

					vi$abbr (abbrs, 0, cabbr, abbrlen);

					! Check whether to use a tab or expand to spaces.

					IF (vi$use_tabs = 1) THEN
						COPY_TEXT (ASCII (9));
					ELSE
						cnt := 0;
						col := GET_INFO (SCREEN, "CURRENT_COLUMN");
						tabstops := GET_INFO (CURRENT_BUFFER, "TAB_STOPS");

						IF (GET_INFO (tabstops, "TYPE") <> STRING) THEN
							LOOP
								EXITIF (col - ((col / tabstops) *
															tabstops) = 0);
								cnt := cnt + 1;
								col := col + 1;
							ENDLOOP;	

							chcnt := chcnt + cnt;
							LOOP
								EXITIF (cnt < 0);
								IF (CURRENT_OFFSET = max_col) AND
												((replace = 0) OR seen_eol) THEN
									SET (INSERT, CURRENT_BUFFER);
								ELSE
									IF CURRENT_OFFSET > max_col THEN
										max_col := CURRENT_OFFSET;
										max_mark := MARK (NONE);;
									ENDIF;
								ENDIF;
								COPY_TEXT (" ");
								cnt := cnt - 1;
							ENDLOOP
						ELSE

							! Give up on windows with weird tab stops.

							COPY_TEXT (ASCII (9));
						ENDIF;
					ENDIF;
					chcnt := chcnt + 1;
				ELSE

					! If it is a CONTROL key, then normalize the value to be
					! 1-26.

					in_char := INT (in_char);
					IF (in_char <= INT(CTRL_Z_KEY)) AND
									(in_char >= INT(CTRL_A_KEY)) THEN
						in_char := (in_char - INT(CTRL_A_KEY)) /
									(INT(CTRL_B_KEY) - INT(CTRL_A_KEY)) + 1;
					ENDIF;

					! Get the character we really want to insert.

					rchar := vi$ascii(in_char);

					! If the character is a word separator, then check to see
					! if an abbreviation preceeded this key.

					IF (INDEX (vi$_ws, rchar) <> 0) THEN
						chcnt := chcnt + vi$abbr (abbrs, rchar, cabbr, abbrlen);
					ELSE

						! Otherwise put the character into the buffer.

						COPY_TEXT (rchar);

						! Add the current character to the string that is
						! going to contain the trailing portion of the variable
						! name for the abbreviation.

						IF (INDEX(vi$_upper_chars, rchar) <> 0) THEN
							cabbr := cabbr + "_";
						ENDIF;
						cabbr := cabbr + rchar;
						abbrlen := abbrlen + 1;

						! Count the number of characters typed in.

						chcnt := chcnt + 1;
					ENDIF;
				ENDIF;

				! See if time to make the transition from OVERSTRIKE to
				! INSERT modes.

				IF (CURRENT_OFFSET = max_col) AND
									((replace = 0) OR seen_eol) THEN
					SET (INSERT, CURRENT_BUFFER);
				ELSE

					! Move the indicators up when necessary.

					IF CURRENT_OFFSET > max_col THEN
						max_col := CURRENT_OFFSET;
						max_mark := MARK (NONE);
					ENDIF;
				ENDIF;
			ELSE

				! Check for a backspace.

				IF desc = "bs" THEN

					! If it is possible to backspace.

					IF start_pos < CURRENT_OFFSET THEN

						! Delete backspace and the character before it in
						! the key buffer that is remembering all of the
						! keystrokes typed.

						vi$del_a_key;
						vi$del_a_key;

						! Transition back to overstrike.

						SET (OVERSTRIKE, CURRENT_BUFFER);

						! Backspace on the screen, and decrement char count.

						MOVE_HORIZONTAL (-1);
						chcnt := chcnt - 1;
					ENDIF;
				ELSE

					! Check for RETURN.

					IF desc = "eol" THEN

						! If not up to the max_mark, then there is trailing
						! text to erase, so do that first.

						IF (max_mark <> MARK (NONE)) AND (replace = 0) THEN
							current_mark := MARK (NONE);
							POSITION (max_mark);
							MOVE_HORIZONTAL (-1);
							ERASE (CREATE_RANGE (MARK (NONE),
														current_mark, NONE));
						ENDIF;

						! Now check for an abbreviation, and inc the count..

						chcnt := vi$abbr (abbrs, 0, cabbr, abbrlen) + 1;

						! Split the line

						SPLIT_LINE;

						! Set flag for REPLACE so that we do not write over
						! unreplaced, but overstruck text.

						seen_eol := 1;

						! Check for the DCL buffer activity

						IF (CURRENT_BUFFER = vi$dcl_buf) AND (vi$send_dcl) THEN
							MOVE_VERTICAL (-1);
							vi$send_to_dcl (CURRENT_LINE);
							MOVE_VERTICAL (1);
						ENDIF;

						! Update all of the indicators and transition to
						! INSERT mode.

						max_col := CURRENT_OFFSET;
						start_pos := CURRENT_OFFSET;
						max_mark := MARK(NONE);
						SET (INSERT, CURRENT_BUFFER);

						! Add left margin if needed.

						did_ai := (vi$do_auto_indent(1) <> 0);

						! End of input if DCL buffer and flag set.

						IF (CURRENT_BUFFER = vi$dcl_buf) AND (vi$send_dcl) THEN
							EXITIF (1);
						ENDIF;
					ELSE

						! Check for CTRL-W, backup over word.

						IF (desc = "bword") THEN

							! Backup over whitespace.

							LOOP
								EXITIF start_pos = CURRENT_OFFSET;
								MOVE_HORIZONTAL (-1);
								chcnt := chcnt - 1;
								EXITIF (INDEX (vi$_space_tab,
													CURRENT_CHARACTER) = 0);
								SET (OVERSTRIKE, CURRENT_BUFFER);
							ENDLOOP;

							! Backup over nonblank chars.

							LOOP
								EXITIF start_pos = CURRENT_OFFSET;
								SET (OVERSTRIKE, CURRENT_BUFFER);
								IF (INDEX (vi$_space_tab,
											CURRENT_CHARACTER) <> 0) THEN
									chcnt := chcnt + 1;
									MOVE_HORIZONTAL (1);
									EXITIF (1);
								ENDIF;
								MOVE_HORIZONTAL (-1);
								chcnt := chcnt - 1;
							ENDLOOP;
						ENDIF;
					ENDIF;                 
				ENDIF;
			ENDIF;
		ENDIF;

		! Make sure everything is visible.

		vi$update (CURRENT_WINDOW);
	ENDLOOP;

	! Must get a new offset for the cursor now.

	vi$new_offset := 1;

	! If we are not at the rightmost position that text was typed to, then
	! we must delete the garbage out to the right.

	IF max_mark <> MARK (NONE) THEN
		current_mark := MARK (NONE);

		! If we are in REPLACE, then the text out there should be replaced
		! with the stuff that was there originally.

		IF (NOT seen_eol) AND (replace <> 0) THEN
			SET (OVERSTRIKE, CURRENT_BUFFER);
			COPY_TEXT (SUBSTR (replace, CURRENT_OFFSET + 1,
												max_col - CURRENT_OFFSET));
			POSITION (current_mark);
		ELSE

			! Otherwise we erase the stuff.

			POSITION (max_mark);
			IF (MARK(NONE) <> BEGINNING_OF (CURRENT_BUFFER)) THEN
				MOVE_HORIZONTAL (-1);
			ENDIF;
			ERASE (CREATE_RANGE (MARK (NONE), current_mark, NONE));
		ENDIF;
	ENDIF;

	! When INSERT is ended, the cursor moves back one position, providing
	! we are not at the beginning of the line.

	IF (MARK(NONE) <> BEGINNING_OF (CURRENT_BUFFER)) THEN
		IF (chcnt <> 0) THEN
			MOVE_HORIZONTAL (-1);
		ENDIF;
	ELSE
		chcnt := 0;
	ENDIF;

	! Save the text that we typed for later repeat.

	pos := MARK (NONE);
	start_ins := vi$set_undo_start (start_ins);
	ins_text := CREATE_RANGE (start_ins, pos, REVERSE);

	! Save last inserted text to buffer.

	ERASE (vi$last_insert);

	POSITION (vi$last_insert);
	COPY_TEXT (ins_text);
	SPLIT_LINE; 
	POSITION (BEGINNING_OF (vi$last_insert));

	POSITION (pos);

	SET (INSERT, CURRENT_BUFFER);

	! If :set sm, then remove the MODE displayed.

	IF (vi$show_mode) THEN
		MESSAGE ("");
	ENDIF;

	! Function value is approximately the number of characters typed.  This
	! is mainly for check for NONE verses SOME.

	RETURN (chcnt);
ENDPROCEDURE;

!
!	Create the initial left margin of auto indent.
!
PROCEDURE vi$do_auto_indent(forceit)
	LOCAL
		d_rng,
		d_strt,
		d_text,
		pos,
		istr;

	ON_ERROR
		RETURN (0);
	ENDON_ERROR;

	IF (vi$auto_indent = 0) THEN
		RETURN;
	ENDIF;

	IF (LENGTH (CURRENT_LINE) > 0) AND (forceit = 0) THEN
		  RETURN;
	ENDIF;                                                  

	pos := MARK (NONE);
	MOVE_VERTICAL (-1);
	d_strt := MARK (NONE);
	istr := vi$get_leading_blank;
	d_text := (CURRENT_CHARACTER = "");

	IF (CURRENT_OFFSET > 0) THEN
		MOVE_HORIZONTAL (-1);
		d_rng := CREATE_RANGE (d_strt, MARK(NONE), NONE);
	ELSE
		d_rng := 0;
	ENDIF;

	POSITION (pos);
	POSITION (LINE_BEGIN);
	COPY_TEXT (istr);
	POSITION (pos);

	IF (d_text) AND (d_rng <> 0) THEN
		ERASE (d_rng);
	ENDIF;

	vi$update (CURRENT_WINDOW);
	RETURN (LENGTH (istr));
ENDPROCEDURE;

!
!	Insert another tab while :set ai is active.
!
PROCEDURE vi$do_entab
	vi$do_ai_tabbing (1);
ENDPROCEDURE;

!
!	Remove a tab while :set ai is active.
!
PROCEDURE vi$do_detab
	vi$do_ai_tabbing (0);
ENDPROCEDURE;

!
!	Get the leading whitespace from the current line.  Used during :set ai
!	to findout how to indent on the current line.
!
PROCEDURE vi$get_leading_blank
	LOCAL
		ln,
		ch,
		idx;

	ln := vi$current_line;

	rstr := "";
	idx := 1;
	LOOP
		ch := SUBSTR (ln, idx, 1);
		IF (ch = "") THEN
			RETURN (rstr);
		ENDIF;
		EXITIF (INDEX (vi$_space_tab, ch) = 0);
		rstr := rstr + ch;
		idx := idx + 1;
	ENDLOOP;

	RETURN (rstr);     
ENDPROCEDURE;

!
!	Check the current line, and see if it is completely whitespace to
!	determine how to alter its indention.
!
PROCEDURE vi$check_leading_blank
	LOCAL
		ln,
		ch,
		idx;

	ln := vi$current_line;

	idx := 1;
	LOOP
		ch := SUBSTR (ln, idx, 1);
		IF (ch = "") THEN
			RETURN (1);
		ENDIF;
		EXITIF (INDEX (vi$_space_tab, ch) = 0);
		idx := idx + 1;
	ENDLOOP;

	RETURN (0);
ENDPROCEDURE;

!
!	Do :set ai entabbing or detabbing.
!
PROCEDURE vi$do_ai_tabbing (mode)
	LOCAL
		needed,
		copy_line,
		exitnow,
		cur_tabs,
		tab_len;

	IF NOT vi$check_leading_blank THEN
		vi$beep;
		RETURN;
	ENDIF;

	cur_tabs := GET_INFO (CURRENT_BUFFER, "TAB_STOPS");

	IF (GET_INFO (cur_tabs, "TYPE") = STRING) THEN
		vi$info ("Can't do auto indent in buffer with uneven tabstops.");
		RETURN;
	ELSE
		tab_len := cur_tabs;
	ENDIF;    

	exitnow := 0;

	copy_line := vi$current_line;

	IF (copy_line <> "") OR (mode = 1) THEN

		! Copy line is truncated to have no leading spaces.

		needed := vi$vis_indent (copy_line, tab_len);

		IF mode = 1 THEN
			needed := needed + vi$shift_width;
		ELSE
			needed := needed - vi$shift_width;
		ENDIF;

		IF (needed < 0) THEN
			needed := 0;
		ENDIF;

		ERASE_LINE;
		COPY_TEXT (vi$get_tabs (needed, tab_len)+copy_line);

		MOVE_HORIZONTAL (1);
		IF (MARK (NONE) <> END_OF(CURRENT_BUFFER)) THEN
			MOVE_HORIZONTAL (-1);
			SPLIT_LINE;
		ENDIF;
		MOVE_HORIZONTAL (-1);
		vi$update (CURRENT_WINDOW);
	ELSE
		vi$beep;
	ENDIF;

ENDPROCEDURE;

!
!	Check to see if 'cabbr' is a known abbreviation, and substitute the
!	proper text if it is.
!
PROCEDURE vi$abbr (abbrs, rchar, cabbr, abbrlen)
	LOCAL
		strg;

	strg := "";

	IF (abbrlen > 0) THEN
		EDIT (cabbr, UPPER);
		IF (INDEX (abbrs, "VI$ABBR_"+cabbr+" ") <> 0) THEN
			vi$global_var := 0;
			EXECUTE (COMPILE ("vi$global_var := vi$abbr_"+cabbr+";"));
			IF (vi$global_var <> 0) THEN
				ERASE_CHARACTER (-abbrlen);
				strg := vi$global_var;
				COPY_TEXT (strg);
			ENDIF;
		ENDIF;
		cabbr := "";
		abbrlen := 0;
	ENDIF;
	IF (rchar <> 0) THEN
		COPY_TEXT (rchar);
	ENDIF;
	RETURN (LENGTH (strg) + (rchar <> 0));
ENDPROCEDURE;

!
!	Return a string describing the KEY_NAME passed.  For control characters,
!	it is "^?" where the '?' is A-Z.  Otherwise, the value returned by the
!	ASCII() builtin is used.
!
PROCEDURE vi$ascii_name (key_n)
	LOCAL
		key;

	key := key_n;
	IF (GET_INFO (key, "TYPE") = KEYWORD) THEN
		key := INT (key);
	ENDIF;
	key := (key - INT(CTRL_A_KEY)) / (INT(CTRL_B_KEY) - INT(CTRL_A_KEY));
	IF (key > 31) OR (key < 0) THEN
		key := ASCII (key_n);
	ELSE
		key := "^" + ASCII(key+65);
	ENDIF;

	RETURN (key);
ENDPROCEDURE;

!
!	Perform some mapping of keys to different ASCII values.
!
PROCEDURE vi$ascii (key_n)
	IF key_n = F12 THEN
		RETURN (ASCII (8));
	ENDIF;
	IF key_n = F11 THEN
		RETURN (ASCII (27));
	ENDIF;
	IF key_n = PF1 THEN
		RETURN (ASCII (27));
	ENDIF;
	IF key_n = RET_KEY THEN
		RETURN (ASCII (13));
	ENDIF;
	IF key_n = TAB_KEY THEN
		RETURN (ASCII (9));
	ENDIF;
	RETURN (ASCII (key_n));
ENDPROCEDURE;

!                         
!	Move up by screens
!
PROCEDURE vi$prev_screen
	ON_ERROR
	ENDON_ERROR;

	MOVE_VERTICAL (-vi$cur_active_count *
						GET_INFO (CURRENT_WINDOW, "VISIBLE_LENGTH"));

	vi$beep_position (vi$first_no_space(0), 0, 1);
ENDPROCEDURE;

!
!	Move down by screens
!
PROCEDURE vi$next_screen
	ON_ERROR
	ENDON_ERROR;

	MOVE_VERTICAL (vi$cur_active_count *
						(GET_INFO (CURRENT_WINDOW, "VISIBLE_LENGTH") + 2));

	vi$beep_position (vi$first_no_space(0), 0, 1);
ENDPROCEDURE;

!
! Scroll forward one screen
!
PROCEDURE vi$screen_forward

	vi$scroll_screen (1);

ENDPROCEDURE;

!                         
! Scroll back one screen
!
PROCEDURE vi$screen_backward

	vi$scroll_screen (-1);

ENDPROCEDURE;

!
!	Scroll the screen up or down depending on the sign of "how_many_screens"
!	The magnitude actually has effect as well, but is never greater than 1
!	in this use.
!
PROCEDURE vi$scroll_screen (how_many_screens)

	LOCAL
		scroll_window,			! Window to be scrolled
		this_window,			! Current window
		this_column,			! Current column in scroll_window
		this_row,				! Current row in scroll_window
		old_scroll_top,			! Original value of scroll_top
		old_scroll_bottom,   	! Original value of scroll_bottom
		old_scroll_amount;		! Original value of scroll_amount

	! Trap and ignore messages about move beyond buffer boundaries -
	! just move to top or bottom line of buffer

	ON_ERROR
	ENDON_ERROR;

	this_window := CURRENT_WINDOW;

	scroll_window := this_window;

	IF vi$active_count <> 0 THEN
		vi$how_much_scroll := vi$cur_active_count;
	ENDIF;

	this_row := GET_INFO (scroll_window, "CURRENT_ROW");

	IF this_row = 0	THEN
		this_row := GET_INFO (scroll_window, "VISIBLE_TOP");
	ENDIF;

	this_column := GET_INFO (scroll_window, "CURRENT_COLUMN");
	POSITION (LINE_BEGIN);

	old_scroll_top := GET_INFO (scroll_window, "SCROLL_TOP");
	old_scroll_bottom := GET_INFO (scroll_window, "SCROLL_BOTTOM");
	old_scroll_amount := GET_INFO (scroll_window, "SCROLL_AMOUNT");

	SET (SCROLLING, scroll_window, ON,
					this_row - GET_INFO (scroll_window, "VISIBLE_TOP"),
					GET_INFO (scroll_window, "VISIBLE_BOTTOM") - this_row, 0);

	MOVE_VERTICAL (how_many_screens * vi$how_much_scroll);
	vi$update (scroll_window);

	IF this_window <> CURRENT_WINDOW THEN
		POSITION (this_window);
	ENDIF;

	SET (SCROLLING, scroll_window, ON, old_scroll_top, old_scroll_bottom,
															old_scroll_amount);
ENDPROCEDURE;

!
!	Move forward logical words
!
PROCEDURE vi$_word_forward
	vi$beep_position (vi$word_move (1), 0, 1);
ENDPROCEDURE;

!
!   Move backward logical words
!
PROCEDURE vi$_word_back
	vi$beep_position (vi$word_move(-1), 0, 1);
ENDPROCEDURE;

!
!	Move by logical word taking into account the repeat count
!
PROCEDURE vi$word_move(dir)
	LOCAL
		old_pos,
		pos;

	old_pos := MARK (NONE);

	IF vi$active_count <= 0 THEN
		vi$active_count := 1;
	ENDIF;

	LOOP
		pos := vi$move_logical_word (dir);
		EXITIF pos = 0;
		POSITION (pos);
		vi$active_count := vi$active_count - 1;
		EXITIF vi$active_count = 0;
	ENDLOOP;

	vi$yank_mode := VI$IN_LINE_MODE;
	RETURN (vi$retpos (old_pos));
ENDPROCEDURE;

!             
!	Move to end of logical word
!
PROCEDURE vi$_word_end
	vi$beep_position (vi$word_end, 0, 1);
ENDPROCEDURE;

!
!	Move to end of physical word
!             
PROCEDURE vi$_full_word_end
	vi$beep_position (vi$full_word_end, 0, 1);
ENDPROCEDURE;       

!
!	Move to the end of the current word.
!
PROCEDURE vi$word_end
	LOCAL
		old_pos,
		pos;

	old_pos := MARK (NONE);

	IF vi$active_count <= 0 THEN
		vi$active_count := 1;
	ENDIF;

	LOOP
		pos := vi$move_logical_end;
		EXITIF pos = 0;
		POSITION (pos);
		vi$active_count := vi$active_count - 1;
		EXITIF vi$active_count = 0;
	ENDLOOP;

	vi$yank_mode := VI$IN_LINE_MODE;
	RETURN (vi$retpos (old_pos));
ENDPROCEDURE;

!
!	Move to the end of a blank (eol is also considered blank) terminated word.
!
PROCEDURE vi$full_word_end

	LOCAL
		old_pos,
		pos;

	old_pos := MARK (NONE);

	IF vi$active_count <= 0 THEN
		vi$active_count := 1;
	ENDIF;

	LOOP     
		pos := vi$move_full_end;
		EXITIF pos = 0;
		POSITION (pos);
		vi$active_count := vi$active_count - 1;
		EXITIF vi$active_count = 0;
	ENDLOOP;

	vi$yank_mode := VI$IN_LINE_MODE;
	RETURN (vi$retpos (old_pos));
ENDPROCEDURE;

!
!	Move forward by ONE white-space delimited word
!
PROCEDURE vi$_full_word_forward
	vi$beep_position (vi$full_word_move (1), 0, 1);
ENDPROCEDURE;       

!
!
!	Move backward by ONE white-space delimited word
!
PROCEDURE vi$_full_word_back
	vi$beep_position (vi$full_word_move (-1), 0, 1);
ENDPROCEDURE;

!             
!	Move by physical word taking the repeat count into account
!
PROCEDURE vi$full_word_move (dir)

	LOCAL
		old_pos,  
		pos;

	old_pos := MARK (NONE);

	IF vi$active_count <= 0 THEN
		vi$active_count := 1;
	ENDIF;

	LOOP
		pos := vi$move_full_word (dir);
		EXITIF pos = 0;
		POSITION (pos);
		vi$active_count := vi$active_count - 1;
		EXITIF vi$active_count = 0;
	ENDLOOP;

	vi$yank_mode := VI$IN_LINE_MODE;
	RETURN (vi$retpos (old_pos));
ENDPROCEDURE;

!
!	Move the cursor by BLANK separated words.  DIRECTION is either
!	+1, or -1 to indicate the direction (forward, or backword respectfully)
!	to move
!
PROCEDURE vi$move_full_word (direction)

	LOCAL
		typ,                             
		pos;

	pos := MARK (NONE);

	IF (direction = -1) THEN
		LOOP
			EXITIF (MARK (NONE) = BEGINNING_OF (CURRENT_BUFFER));
			MOVE_HORIZONTAL (-1);
			typ := vi$get_type (CURRENT_CHARACTER);
			EXITIF (typ <> VI$SPACE_TYPE) AND (typ <> VI$EOL_TYPE);
		ENDLOOP;
	ENDIF;

	LOOP
		EXITIF ((MARK (NONE) = BEGINNING_OF (CURRENT_BUFFER)) AND
				(direction = -1));
		EXITIF ((MARK (NONE) = END_OF (CURRENT_BUFFER)) AND
				(direction = 1));
		EXITIF (CURRENT_CHARACTER = "");
		EXITIF vi$get_type (CURRENT_CHARACTER) = VI$SPACE_TYPE;
		MOVE_HORIZONTAL (direction);
	ENDLOOP;

	! A hack to make change work like it is supposed to with "cw".

	IF (vi$command_type = VI$CHANGE_TYPE) AND (direction = 1) THEN
		vi$new_endpos := MARK (NONE);
	ENDIF;

	IF (direction = 1) THEN
		LOOP
			EXITIF (MARK (NONE) = END_OF (CURRENT_BUFFER));
			EXITIF (CURRENT_CHARACTER = "") AND 
										(vi$command_type <> VI$OTHER_TYPE);
			MOVE_HORIZONTAL (1);
			EXITIF vi$get_type (CURRENT_CHARACTER) <> VI$SPACE_TYPE;
		ENDLOOP;
	ELSE
		IF (MARK (NONE) <> BEGINNING_OF (CURRENT_BUFFER)) THEN
			MOVE_HORIZONTAL (1);
		ENDIF;
	ENDIF;

	RETURN (vi$retpos(pos));
ENDPROCEDURE;

!
!  	Move the cursor by logical words.  Note that words in this case are
!	delimited by a change from one type of character to another.  The
!	predefined types
!            
!		VI$ALPHA_TYPE, VI$PUNCT_TYPE, and VI$SPACE_TYPE
!
!	are used to detect transitions from one word to the next;
!
PROCEDURE vi$move_logical_word (direction)

	LOCAL
		this_type,
		this_char,
		typec,
		pos;

	pos := MARK (NONE);

	!	If direction is back, then skip SPACE characters until no space
	!	is found.

	IF (direction = -1) THEN
		LOOP
			EXITIF (MARK (NONE) = BEGINNING_OF (CURRENT_BUFFER));
			MOVE_HORIZONTAL (-1);
			typec := vi$get_type (CURRENT_CHARACTER);
			EXITIF (typec <> VI$SPACE_TYPE) AND (typec <> VI$EOL_TYPE);
		ENDLOOP;
	ENDIF;

	IF (MARK (NONE) <> END_OF (CURRENT_BUFFER)) THEN
		this_char := CURRENT_CHARACTER;
		this_type := vi$get_type (this_char);
	ENDIF;

	LOOP
		EXITIF ((MARK (NONE) = BEGINNING_OF (CURRENT_BUFFER)) AND
				(direction = -1));

		EXITIF ((MARK (NONE) = END_OF (CURRENT_BUFFER)) AND
				(direction = 1));

		MOVE_HORIZONTAL (direction);
		EXITIF (vi$get_type (CURRENT_CHARACTER) <> this_type);
	ENDLOOP;

	! A hack to make change work like it is supposed to with "cw".

	IF (vi$command_type = VI$CHANGE_TYPE) AND (direction = 1) THEN
		vi$new_endpos := MARK (NONE);
	ENDIF;

	IF (direction = 1) THEN
		LOOP
			EXITIF (MARK (NONE) = BEGINNING_OF (CURRENT_BUFFER)) AND
					(direction = -1);
			EXITIF (MARK (NONE) = END_OF (CURRENT_BUFFER)) AND
					(direction = 1);
			typec := vi$get_type(CURRENT_CHARACTER);
			EXITIF (typec  < VI$SPACE_TYPE);
			EXITIF (vi$command_type <> VI$OTHER_TYPE) AND
												(typec <> VI$SPACE_TYPE);
			MOVE_HORIZONTAL (1);
			EXITIF (MARK (NONE) = END_OF (CURRENT_BUFFER));
		ENDLOOP;
	ELSE
		IF (MARK (NONE) <> BEGINNING_OF (CURRENT_BUFFER)) THEN
			MOVE_HORIZONTAL (1);
		ENDIF;
	ENDIF;

	RETURN (vi$retpos (pos));
ENDPROCEDURE;

!
!	Move the cursor by BLANK separated words.  DIRECTION is either
!	+1, or -1 to indicate the direction (forward, or backword respectfully)
!	to move
!
PROCEDURE vi$move_full_end

	LOCAL
		ctype,
		pos;

	pos := MARK (NONE);

	IF (pos = END_OF (CURRENT_BUFFER)) THEN
		RETURN (0);
	ENDIF;

	LOOP
		MOVE_HORIZONTAL (1);
		EXITIF (MARK (NONE) = END_OF (CURRENT_BUFFER));
		ctype := vi$get_type (CURRENT_CHARACTER);
		EXITIF (ctype <> VI$SPACE_TYPE) AND (ctype <> VI$EOL_TYPE);
	ENDLOOP;

	LOOP
		EXITIF (MARK (NONE) = END_OF (CURRENT_BUFFER));
		ctype := vi$get_type (CURRENT_CHARACTER);
		EXITIF (ctype = VI$EOL_TYPE) OR (ctype = VI$SPACE_TYPE);
		MOVE_HORIZONTAL (1);
	ENDLOOP;

	MOVE_HORIZONTAL (-1);
	RETURN (vi$retpos(pos));
ENDPROCEDURE;

!
!  	Move the cursor by logical words.  Note that words in this case are
!	delimited by a change from one type of character to another.  The
!	predefined types
!
!		VI$ALPHA_TYPE, VI$PUNCT_TYPE, and VI$SPACE_TYPE
!
!	are used to detect transitions from one word to the next;
!
PROCEDURE vi$move_logical_end

	LOCAL
		ctype,
		this_type,
		this_char,
		pos;

	pos := MARK (NONE);

	IF (pos = END_OF (CURRENT_BUFFER)) THEN
		RETURN (0);
	ENDIF;

	LOOP
		MOVE_HORIZONTAL (1);
		EXITIF (MARK (NONE) = END_OF (CURRENT_BUFFER));
		ctype := vi$get_type (CURRENT_CHARACTER);
		EXITIF (ctype <> VI$SPACE_TYPE) AND (ctype <> VI$EOL_TYPE);
	ENDLOOP;

	this_char := CURRENT_CHARACTER;
	this_type := vi$get_type (this_char);

	LOOP
		EXITIF (MARK (NONE) = END_OF (CURRENT_BUFFER));
		EXITIF (CURRENT_CHARACTER) = "";
		EXITIF (vi$get_type (CURRENT_CHARACTER) <> this_type);
		MOVE_HORIZONTAL (1);
	ENDLOOP;

	MOVE_HORIZONTAL (-1);
	RETURN (vi$retpos (pos));
ENDPROCEDURE;

!
!	Return the logical type of the character passed.  This is typically used
!	by the move_by_word routines to determine when a word ends.
!
PROCEDURE vi$get_type (this_char)

	LOCAL
		this_type;

	IF (this_char = "") THEN
		RETURN (VI$EOL_TYPE);
	ENDIF;

	this_type := VI$SPACE_TYPE;

	IF (INDEX (vi$_alpha_chars, this_char) <> 0) THEN
		this_type := VI$ALPHA_TYPE;
	ELSE
		IF (INDEX (vi$_punct_chars, this_char) <> 0) THEN
		   	this_type := VI$PUNCT_TYPE;
		ENDIF;
	ENDIF;   

	RETURN (this_type);
ENDPROCEDURE;

!
!	This procedure determines what line the cursor is currently positioned
!	on. and then prints that information, along with other items of interest
!	in the message window.
!
PROCEDURE vi$what_line

	LOCAL
		bmode,
		percent,
		mod,
		outfile,
		lines,
		nowr,
		pos,
		cnt;

	ON_ERROR;
		lines := GET_INFO (CURRENT_BUFFER, "RECORD_COUNT");
		IF (cnt) > lines THEN
			cnt := lines;
		ENDIF;

		IF lines = 0 THEN
			percent := 0;
		ELSE
			percent := (cnt*100)/lines;
		ENDIF;

		vi$info (FAO ("!ASLine !UL of !UL, !UL%, !AS!AS!AS",
							nowr, cnt, lines, percent, bmode, mod, outfile));

		SET (TIMER, OFF);
		RETURN;
	ENDON_ERROR;

	IF (vi$getbufmode (CURRENT_BUFFER)) THEN
		bmode := "[readonly] ";
	ELSE
		bmode := "";
	ENDIF;

	nowr := " ";
	IF (GET_INFO (CURRENT_BUFFER, "NO_WRITE")) AND (bmode = "") THEN
		nowr := "*";
	ENDIF;

	mod := "";
	IF GET_INFO (CURRENT_BUFFER, "MODIFIED") THEN
		mod := "[modified] ";
	ENDIF;

	pos := MARK(NONE);
	POSITION (LINE_BEGIN);

	cnt := 0;
	lines := 0;
	outfile := GET_INFO (CURRENT_BUFFER, "OUTPUT_FILE");
	IF (outfile = 0) THEN
		outfile := "Not Edited";
	ELSE
		outfile := """"+outfile+"""";
	ENDIF;

	cnt := vi$cur_line_no;

	POSITION (pos);

	lines := GET_INFO (CURRENT_BUFFER, "RECORD_COUNT");
	IF (cnt) > lines THEN
		cnt := lines;
	ENDIF;

	IF lines = 0 THEN
		percent := 0;
	ELSE
		percent := (cnt*100)/lines;
	ENDIF;

	vi$info (FAO ("!ASLine !UL of !UL, !UL%, !AS!AS!AS",
							nowr, cnt, lines, percent, bmode, mod, outfile));
	SET (TIMER, OFF);
ENDPROCEDURE;

!
PROCEDURE vi$file_info

	LOCAL
		bmode,
		outfile;

	IF (vi$getbufmode (CURRENT_BUFFER)) THEN
		bmode := "[readonly] ";
	ELSE
		bmode := "";
	ENDIF;

	outfile := GET_INFO (CURRENT_BUFFER, "OUTPUT_FILE");
	IF (outfile = 0) THEN
		outfile := "Not Edited";
	ELSE
		outfile := """"+outfile+"""";
	ENDIF;

	vi$info (FAO ("!AS!AS !UL lines", outfile, bmode,
			GET_INFO (CURRENT_BUFFER, "RECORD_COUNT")));
ENDPROCEDURE;

!
!	This function moves to "pos" if it is non-zero.  If "pos" is zero, then
!	any current macro is aborted, and the current position is not changed.
!	"save_pos" is a boolean value that indicates whether or not the current
!	location is remembered so that it can be returned to later with the
!	"'" (go to marker) command.
!
PROCEDURE vi$beep_position (pos, save_pos, dobeep)
	IF (pos <> 0) THEN
		IF save_pos THEN
			vi$old_place := MARK (NONE);
		ENDIF;
		POSITION (pos);
	ELSE
		IF dobeep THEN
			vi$beep;
		ENDIF;
		RETURN (vi$abort (0));
	ENDIF;
	RETURN (pos);
ENDPROCEDURE;

!
!	This function implements the command mode function of joining the
!	current line with the one below it.
!
!	The undo operation consists of deleting the line created by joining
!	the two lines, and then inserting the original contents of the two
!	joined lines.
!
PROCEDURE vi$_join_lines

	LOCAL                                        
		start,
		spos,
		epos,
		pos,
		plen,
		len;

	ON_ERROR
		!  Throw away moved beyond end of buffer messages.
		RETURN;
	ENDON_ERROR;

	spos := MARK (NONE);
	POSITION (LINE_BEGIN);
	pos := MARK (NONE);
	IF (MARK (NONE) <> END_OF (CURRENT_BUFFER)) THEN
		MOVE_VERTICAL (1);
		IF (MARK (NONE) <> END_OF (CURRENT_BUFFER)) THEN
			MOVE_VERTICAL (1);
			MOVE_HORIZONTAL (-1);
			epos := MARK (NONE);
			POSITION (spos);
			vi$save_for_undo (CREATE_RANGE (pos, epos, NONE),
															VI$LINE_MODE, 1);
			POSITION (pos);
		ELSE
			RETURN;
		ENDIF;        
	ELSE
		RETURN;
	ENDIF;

	POSITION (LINE_END);

	LOOP
		EXITIF (CURRENT_OFFSET = 0);
		MOVE_HORIZONTAL (-1);
		EXITIF INDEX (vi$_space_tab, CURRENT_CHARACTER) = 0;
		ERASE_CHARACTER (1);    
	ENDLOOP;

	plen := LENGTH (vi$current_line);
	vi$_next_line;

	IF (CURRENT_OFFSET > 0) AND (plen > 0) THEN
		ERASE_CHARACTER (-CURRENT_OFFSET);
	ENDIF;

	len := LENGTH (vi$current_line);
	APPEND_LINE;

	IF (len > 0) AND (plen > 0) THEN
		COPY_TEXT (" ");
		MOVE_HORIZONTAL (-1);
	ELSE
		vi$check_rmarg;
	ENDIF;

	pos := MARK (NONE);

	POSITION (LINE_BEGIN);
	vi$undo_start := MARK (NONE);
	POSITION (LINE_END);
	vi$undo_end := MARK (NONE);

	POSITION (pos);
ENDPROCEDURE;

!
!	This function filters the selected region through the command
!	given.
!
PROCEDURE vi$region_filter

	LOCAL
		era_range,
		prog,
	   	nchar,
		copy_line,
		orig_pos,
		last_pos,
		pos,
		exitnow,
		olen,
		this_pos,
		cur_tabs;

	vi$start_pos := MARK (NONE);
	pos := MARK (NONE);
	nchar := vi$init_action (olen);
	prog := vi$get_prog (nchar);

	IF prog <> "" THEN
		vi$do_movement (prog, VI$FILTER_TYPE);

		IF (vi$endpos <> 0) THEN
			POSITION (vi$endpos);
			POSITION (LINE_BEGIN);
			vi$endpos := MARK (NONE);
			POSITION (vi$start_pos);
			POSITION (LINE_BEGIN);

			IF (MARK (NONE) = vi$endpos) THEN
				MOVE_VERTICAL (1);
				vi$endpos := MARK (NONE);
			ENDIF;

			POSITION (vi$endpos);

			vi$move_horizontal (-1);
			era_range := CREATE_RANGE (vi$start_pos, MARK (NONE), NONE);
			MOVE_HORIZONTAL (1);

			IF (era_range <> 0) THEN
				vi$undo_end := 0;
				POSITION (vi$start_pos);
				vi$save_for_undo (era_range, VI$LINE_MODE, 1);

				POSITION (vi$start_pos);
				POSITION (LINE_BEGIN);

				orig_pos := vi$get_undo_start;

				IF (vi$filter_region (era_range, 0) = 0) THEN
					vi$kill_undo;
					vi$undo_end := 0;
					POSITION (pos);
				   	RETURN (vi$abort (0));
				ENDIF;

				IF (MARK (NONE) <> BEGINNING_OF (CURRENT_BUFFER)) THEN
					MOVE_HORIZONTAL (-1);
				ENDIF;

				vi$undo_end := MARK (NONE);

				vi$undo_start := vi$set_undo_start (orig_pos);
				vi$check_length (olen);
			ELSE
				vi$info ("Internal error while filtering!");
			ENDIF;
		ELSE
			vi$abort (0);
		ENDIF;
	ELSE
		vi$abort (0);
	ENDIF;

ENDPROCEDURE;

!
!	Filter the region of text indicated by "region", using the command
!	given in cmd_parm.
!
PROCEDURE vi$filter_region (region, cmd_parm)
	LOCAL
		cmd;

	ON_ERROR
		vi$info ("ERROR filtering text!");
		RETURN (0);
	ENDON_ERROR;

	cmd := cmd_parm;

	IF (vi$filter_buf = 0) THEN
		vi$filter_buf := vi$init_buffer ("$$filter_buffer$$", "");
		IF (vi$filter_buf = 0) THEN
			vi$info ("Can't create buffer, filter aborted!");
			RETURN (0);
		ENDIF;
	ELSE   
		ERASE (vi$filter_buf);
	ENDIF;

	IF (cmd = 0) THEN
		IF (vi$read_a_line ("!", cmd) = 0) THEN
			RETURN (0);
		ENDIF;
	ENDIF;

	vi$info_success_off;
	IF (vi$filter_proc = 0) THEN
		IF cmd = "!" THEN
			cmd := vi$last_filter;
			IF (cmd = 0) THEN
				vi$info ("No previous command to use!");
				RETURN (0);
			ENDIF;
		ELSE
			vi$last_filter := cmd;
		ENDIF;

		vi$filter_proc := CREATE_PROCESS (vi$filter_buf, cmd);

		IF (vi$filter_proc = 0) THEN
			vi$info ("Can't create process, filter aborted!");
			RETURN (0);
		ENDIF;  
	ENDIF;

	SEND (region, vi$filter_proc);
	IF vi$filter_proc <> 0 THEN
		DELETE (vi$filter_proc);
		vi$filter_proc := 0;
	ENDIF;

	vi$info_success_on;

	ERASE (region);
	COPY_TEXT (vi$filter_buf);
	RETURN (1);
ENDPROCEDURE;

!
!   Shift the selected text region one SHIFT_WIDTH to the right.
!
PROCEDURE vi$region_right
	vi$region_shift(1);
ENDPROCEDURE

!
!   Shift the selected text region one SHIFT_WIDTH to the left.
!
PROCEDURE vi$region_left
	vi$region_shift (0);
ENDPROCEDURE

!
!	This function shifts the selected region right or left based on
!	the mode passed.
!
!	Parameters:
!		mode			0 indicates a left shift, 1 indicates right.
!
PROCEDURE vi$region_shift (mode)

	LOCAL
		act_char,
		needed,
		era_range,
		prog,
		nchar,
		copy_line,
		tab_len,
		oline,
		nline,
		state,
		orig_pos,
		last_pos,
		exitnow,
		this_pos,
		cur_tabs;

	ON_ERROR;
		IF state <> 0 THEN
			IF (ERROR = TPU$_ENDOFBUF) AND (state = 2) THEN
				exitnow := 1;
			ELSE
				orig_pos := 0;
			ENDIF;
		ELSE
			vi$info ("Error occured during shift, at line: "+
														STR(ERROR_LINE));
			POSITION (vi$start_pos);
			RETURN;
		ENDIF;
	ENDON_ERROR;

	vi$start_pos := MARK (NONE);
	nchar := vi$init_action (state);
	state := 0;

	IF ((mode = 1) AND (ASCII (nchar) = '<')) OR
	   								((mode = 0) AND (ASCII (nchar) = '>')) THEN
		RETURN;
	ENDIF;

	prog := vi$get_prog (nchar);

	IF prog <> "" THEN
		vi$do_movement (prog, VI$SHIFT_TYPE);

		oline := vi$cur_line_no;
		IF (vi$endpos <> 0) THEN
			POSITION (vi$endpos);
			POSITION (LINE_BEGIN);
			nline := vi$abs (vi$cur_line_no - oline);
			vi$endpos := MARK (NONE);
			POSITION (vi$start_pos);
			POSITION (LINE_BEGIN);

			IF (MARK (NONE) = vi$endpos) THEN
				MOVE_VERTICAL (1);
				vi$endpos := MARK (NONE);
			ENDIF;

			POSITION (vi$endpos);

			vi$move_horizontal (-1);
			era_range := CREATE_RANGE (vi$start_pos, MARK (NONE), NONE);
			MOVE_HORIZONTAL (1);

			IF (era_range <> 0) THEN
				vi$undo_end := 0;
				POSITION (vi$start_pos);
				vi$save_for_undo (era_range, vi$yank_mode, 1);

				POSITION (vi$start_pos);
				POSITION (LINE_BEGIN);

				orig_pos := vi$get_undo_start;

				cur_tabs := GET_INFO (CURRENT_BUFFER, "TAB_STOPS");

				IF (GET_INFO (cur_tabs, "TYPE") = STRING) THEN
					vi$info ("Can't shift region with uneven tabstops.");
					RETURN;
				ELSE
					tab_len := cur_tabs;
				ENDIF;

				state := 2;
				exitnow := 0;

				LOOP
					EXITIF MARK (NONE) = vi$endpos;
					EXITIF MARK (NONE) = END_OF (CURRENT_BUFFER);
					EXITIF (exitnow = 1);

					copy_line := vi$current_line;

					IF (copy_line <> "") THEN

						! Copy line is truncated to have no leading spaces.

						needed := vi$vis_indent (copy_line, tab_len);

						IF mode = 1 THEN
							needed := needed + vi$shift_width;
						ELSE
							needed := needed - vi$shift_width;
						ENDIF;

						IF (needed < 0) THEN
							needed := 0;
						ENDIF;

						ERASE_LINE;
						COPY_TEXT (vi$get_tabs (needed, tab_len)+copy_line);

						MOVE_HORIZONTAL (1);
						IF (MARK (NONE) <> END_OF(CURRENT_BUFFER)) THEN
							MOVE_HORIZONTAL (-1);
							SPLIT_LINE;
						ENDIF;
					ELSE
						MOVE_VERTICAL (1);
					ENDIF;
					POSITION (LINE_BEGIN);
				ENDLOOP;

				MOVE_HORIZONTAL (-1);
				vi$undo_end := MARK (NONE);

				vi$undo_start := vi$set_undo_start (orig_pos);
				POSITION (vi$undo_start);
				IF (nline >= vi$report) THEN
					act_char := ">";
					IF mode = 0 THEN
						act_char := "<";
					ENDIF;
					vi$info (STR (nline) + " lines " + act_char + "'d");
				ENDIF;
			ELSE
				vi$info ("Internal error while shifting!");
			ENDIF;
		ELSE
			vi$abort (0);
		ENDIF;
	ELSE
		vi$abort (0);
	ENDIF;

ENDPROCEDURE;

!
!  This procedure is called to calculate the number of spaces
!  occupied on the screen by the leading white space of "line".  "tabstops"
!  holds the number of spaces a tab displays as obtained with a call to
!  GET_INFO (CURRENT_BUFFER, "TAB_STOPS").  Line is stripped of the leading
!  space on return, and the function returns the number of spaces occupied
!  on the screen.
!
PROCEDURE vi$vis_indent (line, tabstops)
	LOCAL
		idx,
		cur_ch,
		cnt;

	idx := 1;
	cnt := 0;

	LOOP
		cur_ch := SUBSTR (line, idx, 1);
		EXITIF (cur_ch = "");
		EXITIF (INDEX (vi$_space_tab, cur_ch) = 0);

		IF (cur_ch = " ") THEN
			cnt := cnt + 1;
		ELSE                                                 
			cnt := cnt + (tabstops - (cnt - ((cnt / tabstops) * tabstops)));
		ENDIF;

		idx := idx + 1;
	ENDLOOP;

	! Truncate the line removing the leading whitespace.

	line := SUBSTR (line, idx, LENGTH (line) - idx + 1);
	RETURN (cnt);
ENDPROCEDURE;

!
!  This procedure builds a string with as many tabs as possible to create
!  the indentation level given by "len".  "tabstops" is the number of spaces
!  a tab produces on the screen.
!
PROCEDURE vi$get_tabs (len, tabstops)
	LOCAL
		tab_text,
		rstr;

	rstr := "";

	! Select the proper tabbing text based on the setting of vi$use_tabs

	tab_text := ASCII (9);
	IF (vi$use_tabs = 0) THEN
		tab_text := SUBSTR (vi$spaces, 1, tabstops);
	ENDIF;

	LOOP
		EXITIF (len = 0);
		IF (len >= tabstops) THEN
			len := len - tabstops;
			rstr := rstr + tab_text;
		ELSE
			rstr := rstr + SUBSTR (vi$spaces, 1, len);
			len := 0;
		ENDIF;
	ENDLOOP;

	RETURN (rstr);
ENDPROCEDURE;

!
!   This function should be used to abort the current keyboard stream.
!   It will assure that a macro does not continue to operate after a
!   failure.
!
PROCEDURE vi$abort (n)
	vi$key_buf := 0;
	RETURN (n);
ENDPROCEDURE;

!
!	Decide what the current line number is.
!
PROCEDURE vi$cur_line_no
	LOCAL
		pos,
		cnt,
		val,
		opos;

	ON_ERROR
		POSITION (pos);
		IF (val > 1) THEN
			val := val / 2;
			cnt := cnt - val;
		ELSE
			POSITION (opos);
			RETURN (cnt);
		ENDIF;
	ENDON_ERROR;

	opos := MARK (NONE);
	val := GET_INFO (CURRENT_BUFFER, "RECORD_COUNT") * 2 / 3;
	IF (val = 0) THEN
		val := 1;
	ENDIF;
	cnt := 1;
	LOOP
		pos := MARK (NONE);
		MOVE_VERTICAL (-val);
		cnt := cnt + val;
	ENDLOOP;
ENDPROCEDURE;

!
!	Copy a buffer of keys for use later.  This routine is used mostly to
!	make a copy of the last series of keystrokes from repeating when '.'
!	is typed.
!
PROCEDURE vi$copy_keys (to_keys, from_keys)
	LOCAL
		pos;

	pos := MARK (NONE);
	ERASE (to_keys);
	POSITION (to_keys);
	COPY_TEXT (from_keys);
	POSITION (BEGINNING_OF (to_keys));
	POSITION (pos);
ENDPROCEDURE;

!
!	Convert a string of characters into a buffer of key strokes.
!
PROCEDURE vi$str_to_keybuf (tstring, tbuf)
	LOCAL
		pos,
		idx;

	idx := 1;
	pos := MARK (NONE);
	POSITION (BEGINNING_OF (tbuf));

	! Note that a bug in TPU causes ill behavior if you try to ERASE
	! a buffer that TPU has never written anything into.

	SPLIT_LINE;
	APPEND_LINE;
	ERASE (tbuf);

	LOOP
		EXITIF idx > LENGTH (tstring);
		COPY_TEXT (STR (INT (KEY_NAME (SUBSTR (tstring, idx, 1)))));

		! Move to EOB so next COPY_TEXT will insert a new line.

		MOVE_HORIZONTAL (1);
		idx := idx + 1;
	ENDLOOP;

	!  There must be 2 lines (the first should be blank) at the end of the
	!  buffer to make it appear exactly as a key mapping.

	SPLIT_LINE;
	SPLIT_LINE;

	POSITION (pos);
ENDPROCEDURE;

!
!	Save the key passed into the push back buffer.
!
PROCEDURE vi$push_a_key (ch)
	LOCAL
		pos;

	pos := MARK (NONE);
	POSITION (vi$cur_keys);
	COPY_TEXT (STR (INT (ch)));
	MOVE_HORIZONTAL (1);
	POSITION (pos);
ENDPROCEDURE;

!
!	Insert the buffer passed into the stream of key_board characters so
!	that they act as a macro.
!
PROCEDURE vi$insert_macro_keys (key_buf)
	LOCAL
		spos,
		pos;

	IF vi$push_key_buf = 0 THEN
		vi$push_key_buf := vi$init_buffer ("$$push_key_buf$$", "");
	ENDIF;

	pos := MARK (NONE);

	IF (vi$key_buf <> 0) THEN
		IF (vi$key_buf = vi$push_key_buf) THEN
			POSITION (vi$push_key_buf);
			MOVE_HORIZONTAL (-1);
			spos := MARK (NONE);
			MOVE_HORIZONTAL (1);
			SET (INSERT, CURRENT_BUFFER);
			COPY_TEXT (key_buf);

			!  Remove blank line at end, and possible DEFINE_KEY mapping.

			MOVE_VERTICAL (-1);
			ERASE_LINE;
			MOVE_VERTICAL (-1);
			ERASE_LINE;

			POSITION (spos);
			MOVE_HORIZONTAL (1);
		ELSE
			POSITION (vi$key_buf);
			spos := MARK (NONE);
			ERASE (vi$push_key_buf);
			POSITION (vi$push_key_buf);
			SET (INSERT, CURRENT_BUFFER);
			COPY_TEXT (CREATE_RANGE (spos, END_OF (vi$key_buf), NONE));

			!  Remove blank line at end, and possible DEFINE_KEY mapping.

			MOVE_VERTICAL (-1);
			ERASE_LINE;
			MOVE_VERTICAL (-1);
			ERASE_LINE;

			COPY_TEXT (key_buf);
			POSITION (BEGINNING_OF (vi$push_key_buf));
			vi$key_buf := vi$push_key_buf;
		ENDIF;
	ELSE
		ERASE (vi$push_key_buf);
		POSITION (vi$push_key_buf);
		SET (INSERT, CURRENT_BUFFER);
		COPY_TEXT (key_buf);
		vi$key_buf := vi$push_key_buf;
		POSITION (BEGINNING_OF (vi$push_key_buf));
	ENDIF;

	POSITION (pos);
ENDPROCEDURE;

!
!	Erase a the last key pushed back.
!
PROCEDURE vi$del_a_key
	LOCAL
		pos;

	pos := MARK (NONE);
	POSITION (vi$cur_keys);
	IF MARK (NONE) <> BEGINNING_OF (CURRENT_BUFFER) THEN
		MOVE_VERTICAL (-1);
		ERASE_LINE;
	ENDIF;
	POSITION (pos);

ENDPROCEDURE;

!
!	Read a single keystroke from either the keyboard, or from the push
!	back buffer if it is non-zero.
!
PROCEDURE vi$read_a_key

	LOCAL
		read_a_key,
		pos,
		ch;

	read_a_key := 0;

	! If there are no keys pushed, then read the keyboard.

	IF (vi$key_buf = 0) OR (GET_INFO (vi$key_buf, "TYPE") <> BUFFER) THEN
		read_a_key := 1;
		vi$m_level := 0;
		IF vi$term_vt200 THEN
			ch := READ_KEY;
		ELSE
			ch := READ_CHAR;
		ENDIF;
	ELSE

		! Otherwise extract the next key from the buffer.

		pos := MARK (NONE);
		POSITION (vi$key_buf);

		! Get the key code.

		ch := INT (vi$current_line);
		MOVE_VERTICAL (1);

		! Check for the end of the buffer.

		IF (LENGTH (vi$current_line) = 0) THEN
			vi$key_buf := 0;
		ENDIF;

		POSITION (pos);
	ENDIF;

	! If we are not running on a VT200, then do some key translations

	IF NOT vi$term_vt200 THEN
		IF ch = ASCII(27) THEN
			ch := F11;
		ENDIF;
	ENDIF;

	ch := KEY_NAME (ch);

	! If a key was read from the keyboard, then push it back.

	IF read_a_key THEN
		vi$push_a_key (ch);
	ENDIF;

	! Save the last key read.

	vi$last_key := ch;

	! Return the keycode of the character

	RETURN (ch);
ENDPROCEDURE;

!
!	Turn pasthru on, on the terminal
!
PROCEDURE vi$pasthru_on
	LOCAL
		junk;
	junk := CALL_USER (vi$cu_pasthru_on, "");
ENDPROCEDURE;

!
!	Turn pasthru off, on the terminal
!
PROCEDURE vi$pasthru_off
	LOCAL
		junk;
	junk := CALL_USER (vi$cu_pasthru_off, "");
ENDPROCEDURE;

!
!	Spawn with pasthru off
!
PROCEDURE vi$spawn (cmd)
	LOCAL
		junk;

	vi$pasthru_off;
	IF (cmd = 0) THEN
		SPAWN;
	ELSE
		SPAWN (cmd);
	ENDIF;
	vi$pasthru_on;
ENDPROCEDURE

!
!	Quit with pasthru off
!
PROCEDURE vi$quit
	vi$pasthru_off;
	QUIT;
	vi$pasthru_on;
ENDPROCEDURE

!
!	Perform read_line with pasthru off
!
PROCEDURE vi$read_line (prompt)
	LOCAL
		junk;

	vi$pasthru_off;
	junk := READ_LINE (prompt);
	vi$pasthru_on;
	RETURN (junk);
ENDPROCEDURE;

!
!	Initialize things by creating buffers and windows and perform other
!	assorted operations.
!
PROCEDURE tpu$init_procedure

	LOCAL
		journal_file,
		default_journal_name,
		aux_journal_name,
		cnt,
		input_file;

	!	Flag to indicate status of editor during startup.

	vi$starting_up := 1;

	vi$readonly := 0;
	IF (GET_INFO (COMMAND_LINE, "READ_ONLY") = 1) THEN
		vi$readonly := 1;
	ENDIF;
	vi$info_success_off;
	SET (MESSAGE_FLAGS, 1);
	SET (BELL, BROADCAST, ON);

	!	Set the variables to their initial values.

	vi$init_vars;

	!	Get some other information.

	vi$term_vt200 := GET_INFO (SCREEN, "vt200");
	vi$scr_width := GET_INFO (SCREEN, "WIDTH");
	vi$scr_length := GET_INFO (SCREEN, "VISIBLE_LENGTH");

	!	Create the message buffer and window.

	message_buffer := vi$init_buffer ("Messages", "");
	message_window := CREATE_WINDOW (vi$scr_length - 1, 2, ON);
	MAP (message_window, message_buffer);
	SET (STATUS_LINE, message_window, NONE, "");
	SET (MAX_LINES, message_buffer, 500);
	ADJUST_WINDOW (message_window, 1, 0);
	vi$mess_select (REVERSE);

	!	Command prompt area.

	command_buffer := vi$init_buffer ("Commands", "");
	command_window := CREATE_WINDOW (vi$scr_length, 1, OFF);

	!	Buffer for SHOW (xxx) stuff.

	show_buffer := vi$init_buffer ("Show", "");
	info_window := CREATE_WINDOW (1, vi$scr_length - 1, ON);
	SET (STATUS_LINE, info_window, NONE, "");

	!	A buffer for the tags file(s).

	vi$tag_buf := vi$init_buffer ("Tags buffer", "");
	vi$load_tags;
	vi$dcl_buf := vi$init_buffer ("DCL buffer", "[End of DCL buffer]");
	vi$info_success_off;

	!	A buffer and a window to start editing in.

	main_buffer := CREATE_BUFFER ("Main");
	main_window := CREATE_WINDOW (1, vi$scr_length - 1, ON);
	SET (EOB_TEXT, main_buffer, "[EOB]");
	SET (STATUS_LINE, main_window, NONE, "");

	!	A buffer for wild carding and such.

	choice_buffer := vi$init_buffer ("Choices", "");

	!	A buffer for the list of files we are currently editing.

	vi$file_names := vi$init_buffer ("file_names", "");

	!	Buffer to hold last text inserted into a buffer.

	vi$last_insert := vi$init_buffer ("$$last_insert$$", "");

	!	Buffer to hold KEY_NAME values of last key sequence.

	vi$cur_keys := vi$init_buffer ("$$current_keys$$", "");

	!	Buffer to hold keys to be performed when '.' is pressed.

	vi$last_keys := vi$init_buffer ("$$last_keys$$", "");

	!	Get a buffer to hold yank and deletes that are not aimed at named
	!	buffers.

	vi$temp_buf := vi$init_buffer ("$$temp_buffer$$", "");

	!	Set up some more stuff.

	SET (PROMPT_AREA, vi$scr_length, 1, BOLD);
	SET (JOURNALING, 7);    
	SET (FACILITY_NAME, "VI");

	!	Move to the initial buffer.

	MAP (main_window, main_buffer);
	POSITION (main_buffer);

	!	Get the filename to edit.

	input_file := GET_INFO (COMMAND_LINE, "FILE_NAME");
	IF input_file = "" THEN
		IF (GET_INFO (COMMAND_LINE, "OUTPUT")) THEN
			input_file := GET_INFO (COMMAND_LINE, "OUTPUT_FILE");
		ENDIF;
	ENDIF;

	!	If there is an input file, then get it for editing.

	IF input_file <> "" THEN
		cnt := vi$get_file (input_file);
	ELSE
		vi$bmode_main := vi$readonly;
	ENDIF;

	! Delete the unused main buffer if it is not used.

	IF (CURRENT_BUFFER <> main_buffer) AND (main_buffer <> 0) THEN
		DELETE (main_buffer);
	ENDIF;
	vi$what_line;

	! Start journaling if requested.

	IF (GET_INFO (COMMAND_LINE, "JOURNAL") = 1) THEN
		aux_journal_name := GET_INFO (CURRENT_BUFFER, "FILE_NAME");

		IF aux_journal_name = "" THEN
			aux_journal_name := GET_INFO (CURRENT_BUFFER, "OUTPUT_FILE");
		ENDIF;

		IF aux_journal_name = 0 THEN
			aux_journal_name := "";
		ENDIF;

		IF aux_journal_name = "" THEN
			default_journal_name := "MAIN.TJL";
		ELSE
			default_journal_name := ".TJL";
		ENDIF;

		journal_file := GET_INFO (COMMAND_LINE, "JOURNAL_FILE");
		journal_file := FILE_PARSE (journal_file, default_journal_name,
			 					 					aux_journal_name);
		JOURNAL_OPEN (journal_file);
	ENDIF;

	! Force undefined keystrokes ("all of them") to call vi$command_mode.

	SET (UNDEFINED_KEY, "tpu$key_map_list",
									COMPILE ("vi$command_mode (LAST_KEY)"));
	SET (SELF_INSERT, "tpu$key_map_list", OFF);

	vi$info_success_on;

	! Change PF1 so that it is NOT a shift key.

	SET (SHIFT_KEY, KEY_NAME (PF1, SHIFT_KEY));

	! Do any user added local initialization.

	tpu$local_init;

	! Do the INI file.

	IF FILE_SEARCH ("EXRC") = "" THEN
		vi$do_file ("SYS$LOGIN:VI.INI", 0);
	ELSE
		vi$do_file ("EXRC", 0);
	ENDIF;

	vi$do_exinit;

	! Enable passthru on the terminal so that ^Y does 'Push screen'.

	vi$pasthru_on;

	! Say we are no longer starting up.

	vi$starting_up := 0;
ENDPROCEDURE;

!
!	Process the EXINIT environment variable (Process Logical actually).
!
PROCEDURE vi$do_exinit
	LOCAL
		exinit;

	ON_ERROR
		RETURN;
	ENDON_ERROR;

	exinit := call_user (vi$cu_trnlnm_job, "EXINIT");
	vi$do_cmd_line (exinit);
ENDPROCEDURE;

!
!	Load the file given in fn, into a buffer and execute the contents as
!	a series of EX mode commands.  "complain" is boolean, and determines
!	whether or not we complain about a non existant file.
!
PROCEDURE vi$do_file (rfn, complain)
	LOCAL
		fn,
		ini_buffer,
		ini_file;

	fn := rfn;
	ini_file := FILE_SEARCH ("");
	fn := FILE_PARSE (fn);
	ini_file := FILE_SEARCH (fn);
	IF (ini_file = "") THEN
		IF (complain) THEN
			vi$info ("Can't find file """+fn+"""!");
		ENDIF;
		RETURN (1);
	ENDIF;

	vi$info_success_off;

	ini_buffer := CREATE_BUFFER ("VI$CMD$INI$$", ini_file);

	IF ini_buffer = 0 THEN
		IF (complain) THEN
			vi$info ("can't process file """+ini_file+"""!");
		ENDIF;
		vi$info_success_on;
		RETURN(1);
	ENDIF;

	vi$process_buffer (ini_buffer);
	DELETE (ini_buffer);

	vi$info_success_on;
	RETURN (1);
ENDPROCEDURE;  

!
!  Execute the contents of the passed buffer as EX mode commands
!
PROCEDURE vi$process_buffer (buffer_parm)

	LOCAL
		line,
		old_pos,
		cur_pos;

	old_pos := MARK (NONE);
	POSITION (BEGINNING_OF (buffer_parm));

	LOOP
		cur_pos := MARK (NONE);
		EXITIF (cur_pos = END_OF (buffer_parm));
		line := CURRENT_LINE;

		IF (LENGTH (line) > 0) AND (SUBSTR (line, 1, 1) <> '!') THEN
			POSITION (old_pos);

			vi$do_cmd_line (line);

			old_pos := MARK (NONE);
			POSITION (cur_pos);
		ENDIF;

		MOVE_VERTICAL (1);
	ENDLOOP;

	POSITION (old_pos);
ENDPROCEDURE;

!
!   Initialize a system/nowrite buffer.
!
PROCEDURE vi$init_buffer (new_buffer_name, new_eob_text)

	LOCAL
		new_buffer;		  	! New buffer

	new_buffer := CREATE_BUFFER (new_buffer_name);
	SET (EOB_TEXT, new_buffer, new_eob_text);
	SET (NO_WRITE, new_buffer);
	SET (SYSTEM, new_buffer);
	RETURN (new_buffer);

ENDPROCEDURE;

!
!	Expand the list of filenames given in "get_file_list" and return
!	the count of names found as the function value.  The file names will
!   be in the vi$file_names buffer, one per line.
!
PROCEDURE vi$expand_file_list (get_file_list)

	LOCAL
		num_names,
		fres,
		fn,
		fl,
		comma_pos,
		pos;

	fl := get_file_list;

	ERASE (choice_buffer);

	IF (vi$file_names = 0) THEN
		vi$file_names := vi$init_buffer ("file_names", "");
	ELSE                    
		ERASE (vi$file_names);
	ENDIF;

	! Expand the wild cards.  Note that this also eliminates non-existant
	! files from the list of files to edit.

	LOOP
		! Protect against earlier file_search.

		fres := FILE_SEARCH ("");

		EXITIF fl = "";
		comma_pos := INDEX (fl, ",");

		IF (comma_pos > 0) THEN
			fn := SUBSTR (fl, 1, comma_pos - 1);
			fl := SUBSTR (fl, comma_pos + 1, LENGTH (fl) - comma_pos);
		ELSE
			fn := fl;
			fl := "";
		ENDIF;

		LOOP
			fres := FILE_SEARCH (fn);
			EXITIF fres = "";
			vi$add_choice (fres);
		ENDLOOP;
	ENDLOOP;

	! Save current position.

	pos := MARK (NONE);

	! Save a copy of the filenames list

	POSITION (vi$file_names);
	COPY_TEXT (choice_buffer);
	POSITION (BEGINNING_OF (vi$file_names));

	! Move back to where we were.

	POSITION (pos);

	! Save the count of file names.

	num_names := GET_INFO (choice_buffer, "RECORD_COUNT");

	RETURN (num_names);
ENDPROCEDURE;
!
! Put a file in the current window.  If the file is already in a buffer,
! use the old buffer.  If not, create a new buffer.
!
! Parameters:
!
!	file_parameter	String containing file name - input
!
PROCEDURE vi$get_file (file_parameter)

	LOCAL
		pos,
		obuf,
		get_file_parm,
		outfile,                                         
		filename,
		file_read,
		get_file_name,			! Local copy of get_file_parameter
		get_file_list,			! Possible comma separated list
		temp_buffer_name,		! String for buffer name based on get_file_name
		file_search_result,		! Latest string returned by file_search
		temp_file_name,			! First file name string returned by file_search
		loop_cnt,				! Number of files left to process in loop
		file_cnt,				! Actual number of files found with FILE_SEARCH
		loop_buffer,			! Buffer currently being checked in loop
		new_buffer,				! New buffer created if needed
		found_a_buffer,			! True if buffer found with same name
		want_new_buffer;		! True if file should go into a new buffer

	ON_ERROR
		IF ERROR = TPU$_PARSEFAIL THEN
			vi$info (FAO ("Don't understand file name: !AS", get_file_name));
			RETURN (0);
		ENDIF;
	ENDON_ERROR;

	obuf := CURRENT_BUFFER;
	get_file_parm := file_parameter;
	IF (get_file_parm = 0) OR (get_file_parm = "") THEN
		vi$info ("File name must be supplied!");
		RETURN (0);
	ENDIF;

	get_file_list := get_file_parm;
	get_file_name := get_file_parm;
	temp_file_name := 0;

	loop_cnt := vi$expand_file_list (get_file_list);

	!	If none were found, then set up to enter the loop and get a new buffer

	IF (loop_cnt = 0) THEN
		loop_cnt := 1;
		POSITION (BEGINNING_OF (choice_buffer));
	ELSE
		IF loop_cnt > 1 THEN
			vi$info (FAO ("!UL files to edit!", loop_cnt));
		ENDIF;
		POSITION (BEGINNING_OF (choice_buffer));
		temp_file_name := vi$current_line;
		ERASE_LINE;
	ENDIF;

	file_cnt := loop_cnt;

	LOOP
		IF (GET_INFO (obuf, "TYPE") = BUFFER) THEN
			POSITION (obuf);
		ENDIF; 

		! See if we already have a buffer by that name

		IF temp_file_name = 0 THEN
			temp_buffer_name :=
				FILE_PARSE (get_file_name, "", "", NAME) +
				FILE_PARSE (get_file_name, "", "", TYPE);
		ELSE
			temp_buffer_name :=
		  		FILE_PARSE (temp_file_name, "", "", NAME) +
				FILE_PARSE (temp_file_name, "", "", TYPE);
		ENDIF;

		IF get_file_parm <> 0 THEN

			!  Trim the trailing dot off.

			EDIT (get_file_parm, UPPER, COLLAPSE);

			IF (SUBSTR (get_file_parm, LENGTH(get_file_parm), 1)
																<> '.') THEN
				IF (SUBSTR (temp_buffer_name,
								LENGTH(temp_buffer_name), 1) = '.') THEN

					temp_buffer_name :=
						SUBSTR (temp_buffer_name, 1,
												LENGTH(temp_buffer_name)-1);
			  	ENDIF;
			ENDIF;
		ENDIF;

		loop_buffer := GET_INFO (BUFFERS, "FIRST");
		found_a_buffer := 0;

		LOOP
			EXITIF loop_buffer = 0;
		  	IF temp_buffer_name = GET_INFO (loop_buffer, "NAME") THEN
				found_a_buffer := 1;
				EXITIF 1;
		  	ENDIF;
			loop_buffer := GET_INFO (BUFFERS, "NEXT");
		ENDLOOP;

		! If there is a buffer by that name, is it the same file?
		! We ignore version numbers to keep our sanity

		IF found_a_buffer THEN	  	! Have a buffer with the same name
		  	IF temp_file_name = 0 THEN	! No file on disk
				IF get_file_name = GET_INFO (loop_buffer, "OUTPUT_FILE") THEN
					want_new_buffer := 0;
		  		ELSE

		  			!	If the buffer is empty, then throw it
					!	away.

					IF (GET_INFO (loop_buffer, "RECORD_COUNT") > 0) THEN
			 			want_new_buffer := 0;
					ELSE
						IF (temp_file_name <> 0) and (temp_file_name <> "") THEN
							vi$info ("Buffer empty, reading file");
							POSITION (loop_buffer);
							vi$info (FAO ('Reading "!AS"', temp_file_name));
							file_read := READ_FILE (temp_file_name);

							IF file_read <> "" THEN
								SET (OUTPUT_FILE, loop_buffer, file_read);
								vi$status_lines (loop_buffer);
							ENDIF;
						ENDIF;

		  				want_new_buffer := 2;
		  				POSITION (BEGINNING_OF (loop_buffer));
						MAP (CURRENT_WINDOW, loop_buffer);
						obuf := loop_buffer;
					ENDIF;
				ENDIF;
			ELSE

				! Check to see if the same file

		  		outfile := GET_INFO (loop_buffer, "OUTPUT_FILE");
				filename := GET_INFO (loop_buffer, "FILE_NAME");

				!  Trim version numbers off all of the names.

				IF (outfile <> 0) THEN
					outfile := FILE_PARSE (outfile, "", "", DEVICE) +
					 			FILE_PARSE (outfile, "", "", DIRECTORY) +
					 			FILE_PARSE (outfile, "", "", NAME) +
					 			FILE_PARSE (outfile, "", "", TYPE);
		  		ENDIF;

				IF (filename <> 0) THEN
					filename := FILE_PARSE (filename, "", "", DEVICE) +
					 			FILE_PARSE (filename, "", "", DIRECTORY) +
					 			FILE_PARSE (filename, "", "", NAME) +
					 			FILE_PARSE (filename, "", "", TYPE);
				ENDIF;

				temp_file_name := FILE_PARSE (temp_file_name, "", "", DEVICE) +
					 			FILE_PARSE (temp_file_name, "", "", DIRECTORY) +
					 			FILE_PARSE (temp_file_name, "", "", NAME) +
					 			FILE_PARSE (temp_file_name, "", "", TYPE);

	  			!	If the buffer is empty, then throw it away.

				IF (GET_INFO (loop_buffer, "RECORD_COUNT") > 0) THEN
					IF (outfile = temp_file_name) OR
											(filename = temp_file_name) THEN
		 				want_new_buffer := 0;
					ELSE
		 				want_new_buffer := 1;
					ENDIF;
				ELSE
					IF temp_file_name <> 0 THEN
						vi$info ("Buffer empty, reading file");
						POSITION (loop_buffer);
						vi$info (FAO ('Reading "!AS"', temp_file_name));
						file_read := READ_FILE (temp_file_name);
						IF (file_read <> "") THEN
							SET (OUTPUT_FILE, loop_buffer, file_read);
							vi$status_lines (loop_buffer);
						ENDIF;
					ENDIF;

					want_new_buffer := 2;
					POSITION (BEGINNING_OF (loop_buffer));
					MAP (CURRENT_WINDOW, loop_buffer);
					obuf := loop_buffer;
				ENDIF;
			ENDIF;

			IF want_new_buffer = 1 THEN

				vi$info (FAO (
							"Buffer name !AS is in use", temp_buffer_name));

				temp_buffer_name :=
		  			vi$read_line (
						"Type new buffer name or press Return to cancel: ");

				IF temp_buffer_name = "" THEN
					vi$info ("No new buffer created");
				ELSE       
					new_buffer := vi$_create_buffer (temp_buffer_name,
												get_file_name, temp_file_name);
		  		ENDIF;
			ELSE
				IF (want_new_buffer = 0) and (CURRENT_BUFFER = loop_buffer) THEN
					vi$info (FAO (
					   			"Already editing file !AS", get_file_name));
				ELSE
					IF (want_new_buffer = 0) THEN
						IF (vi$check_auto_write) THEN
							RETURN;
						ENDIF;
						MAP (CURRENT_WINDOW, loop_buffer);
						obuf := loop_buffer;
		  			ENDIF;
		  		ENDIF;
			ENDIF;
		ELSE			! No buffer with the same name, so create a new buffer
			new_buffer := vi$_create_buffer (temp_buffer_name, get_file_name,
																temp_file_name);
		ENDIF;

		IF new_buffer <> 0 THEN
			SET (EOB_TEXT, new_buffer, "[EOB]");
			SET (TAB_STOPS, new_buffer, vi$tab_amount);
		ENDIF;

		loop_cnt := loop_cnt - 1;

		EXITIF loop_cnt <= 0;

		POSITION (BEGINNING_OF (choice_buffer));
		temp_file_name := vi$current_line;
		ERASE_LINE;
	ENDLOOP;

	IF (file_cnt > 1) THEN
		vi$_first_file (0);
	ENDIF;

	vi$set_status_line (CURRENT_WINDOW);
	RETURN (file_cnt);
ENDPROCEDURE;

!
!  This procedure collects the names of all buffers that are leading
!  derivatives of "buffer_name".  The function value is the boolean
!  value telling whether or not the name matched exactly.  The other
!  parameters are return values.
!
PROCEDURE vi$choose_buffer (buffer_name, how_many_buffers,
							 possible_buffer, possible_buffer_name, loop_buffer)

	LOCAL
		this_buffer,			! Current buffer
		loop_buffer_name,		! String containing name of loop_buffer
		found_a_buffer;			! True if buffer found with same exact name

	found_a_buffer := 0;
	EDIT (buffer_name, COLLAPSE);
	possible_buffer := 0;
	possible_buffer_name := 0;
	how_many_buffers := 0;

	! See if we already have a buffer by that name

	this_buffer := CURRENT_BUFFER;
	loop_buffer := GET_INFO (BUFFERS, "FIRST");
	CHANGE_CASE (buffer_name, UPPER);	! buffer names are uppercase
	ERASE (choice_buffer);

	LOOP
		EXITIF loop_buffer = 0;
		loop_buffer_name := GET_INFO (loop_buffer, "NAME");

		IF buffer_name = loop_buffer_name THEN
		  	found_a_buffer := 1;
			how_many_buffers := 1;
			EXITIF 1;
		ELSE
			IF buffer_name = SUBSTR (loop_buffer_name, 1,
													LENGTH (buffer_name)) THEN
				vi$add_choice (loop_buffer_name);
				possible_buffer := loop_buffer;
				possible_buffer_name := loop_buffer_name;
				how_many_buffers := how_many_buffers + 1;
			ENDIF;
		ENDIF;

		loop_buffer := GET_INFO (BUFFERS, "NEXT");
	ENDLOOP;   

	RETURN (found_a_buffer);
ENDPROCEDURE;

!
!	Return current line or empty string if at EOB
!
PROCEDURE vi$current_line
	IF (MARK (NONE) = END_OF (CURRENT_BUFFER)) THEN
		RETURN ("");
	ELSE
		RETURN (CURRENT_LINE);
	ENDIF;
ENDPROCEDURE;

!
!	If autowrite is active, then write the current buffer out.
!
PROCEDURE vi$check_auto_write
	LOCAL
		buf,
		win,
		owin,
		mod;

	mod := GET_INFO (CURRENT_BUFFER, "MODIFIED") AND
			(NOT GET_INFO (CURRENT_BUFFER, "SYSTEM")) AND
			(NOT GET_INFO (CURRENT_BUFFER, "NO_WRITE"));

	buf := CURRENT_BUFFER;

	IF mod AND vi$auto_write THEN
		IF (vi$can_write (CURRENT_BUFFER)) THEN
			vi$info ("Writing out """+GET_INFO (buf, "NAME")+"""");
			WRITE_FILE (buf);
		ELSE
			RETURN (1);
		ENDIF;
	ENDIF;

	IF (NOT mod) AND
			(NOT GET_INFO (CURRENT_BUFFER, "SYSTEM")) AND
			(NOT GET_INFO (CURRENT_BUFFER, "NO_WRITE")) AND
					   			(GET_INFO (buf, "RECORD_COUNT") = 0) THEN
		IF (vi$delete_empty) THEN
			vi$info ("Deleting empty buffer: "+GET_INFO (buf, "NAME"));
			MAP (CURRENT_WINDOW, message_buffer);
			owin := CURRENT_WINDOW;
			win := GET_INFO (WINDOWS, "FIRST");
			LOOP
				EXITIF win = 0;
				IF (GET_INFO (win, "BUFFER") = buf) THEN
					MAP (win, message_buffer);
					vi$set_status_line (win);
				ENDIF;
				win := GET_INFO (WINDOWS, "NEXT");
			ENDLOOP;
			POSITION (owin);
			DELETE (buf);     
		ELSE
			vi$last_mapped := buf;
		ENDIF;
	ELSE
		vi$last_mapped := buf;
	ENDIF;

	RETURN (0);
ENDPROCEDURE;

!
!	Only perform an update if there is not a keyboard macro in progress.
!
PROCEDURE vi$update (win)
	IF (vi$key_buf = 0) AND (vi$playing_back = 0) THEN
		UPDATE (win);
	ENDIF;
ENDPROCEDURE;

!
!	This procedure should be envoked after a wild card edit.  It will allow
!	a list of files that have been created due to a wildcard filespec to be
!	processed sequentially.
!
PROCEDURE vi$_next_file (bang)
	LOCAL
		win,
		fn,
		pos,
		found_one,
		btype,
		bn,
		how_many_buffers,
		possible_buffer,
		possible_buffer_name,
		loop_buffer,
		line;

	ON_ERROR
		! Ignore errors
	ENDON_ERROR;

	IF (NOT bang) AND (vi$check_auto_write) THEN
		RETURN;
	ENDIF;

	pos := MARK (NONE);
	win := CURRENT_WINDOW;

	POSITION (vi$file_names);
	IF (MARK (NONE) <> END_OF (CURRENT_BUFFER)) THEN
		MOVE_VERTICAL (1);
		IF (MARK (NONE) = END_OF (CURRENT_BUFFER)) THEN
			vi$info ("No more files!");
			MOVE_VERTICAL (-1);
			POSITION (win);
			RETURN (1);
		ENDIF;
	ELSE
		vi$info ("No more files!");
		POSITION (win);
		RETURN (1);
	ENDIF;

	fn := vi$current_line;

	bn := FILE_PARSE (fn, "", "", NAME);
	btype := FILE_PARSE (fn, "", "", TYPE);

	IF btype = "" THEN
		btype := ".";
	ENDIF;
	bn := bn + btype;

	found_one := vi$choose_buffer (bn, how_many_buffers,
			   		 		possible_buffer, possible_buffer_name, loop_buffer);

	IF (found_one) THEN
		POSITION (pos);
		IF (CURRENT_BUFFER = loop_buffer) THEN
			vi$info ("Already positioned in that buffer");
		ELSE
			UNMAP (win);
			MAP (win, loop_buffer);
			vi$set_status_line (CURRENT_WINDOW);
			vi$what_line;
		ENDIF;
	ELSE
		vi$info (FAO (
			"No such buffer ""!AS"", buffer has been deleted!", bn));
		POSITION (vi$file_names);
		MOVE_VERTICAL (1);
	ENDIF;

	POSITION (win);
	vi$kill_undo;
	vi$undo_end := 0;
	RETURN (1);
ENDPROCEDURE

!
!	This procedure should be envoked after a wild card edit.  It will allow
!	a list of files that have been created due to a wildcard filespec to be
!	processed sequentially.
!
PROCEDURE vi$_previous_file (bang)
	LOCAL
		win,
		fn,
		pos,
		found_one,
		btype,
		bn,
		how_many_buffers,
		possible_buffer,
		possible_buffer_name,
		loop_buffer,
		line;

	ON_ERROR
		! Ignore errors
	ENDON_ERROR;

	IF (NOT bang) AND (vi$check_auto_write) THEN
		RETURN;
	ENDIF;

	pos := MARK (NONE);
	win := CURRENT_WINDOW;

	fn := GET_INFO (CURRENT_BUFFER, "OUTPUT_FILE");

	POSITION (vi$file_names);
	IF (MARK (NONE) <> BEGINNING_OF (CURRENT_BUFFER)) THEN
		IF (MARK (NONE) = END_OF (CURRENT_BUFFER)) THEN
			MOVE_VERTICAL (-1);
		ENDIF;
		MOVE_VERTICAL (-1);
	ELSE
		vi$info ("No previous file!");
		POSITION (pos);
		RETURN (1);
	ENDIF;

	fn := vi$current_line;

	bn := FILE_PARSE (fn, "", "", NAME);
	btype := FILE_PARSE (fn, "", "", TYPE);

	IF btype = "" THEN
		btype := ".";
	ENDIF;
	bn := bn + btype;

	found_one := vi$choose_buffer (bn, how_many_buffers,
			   		 		possible_buffer, possible_buffer_name, loop_buffer);

	IF (found_one) THEN
		POSITION (pos);
		IF (CURRENT_BUFFER = loop_buffer) THEN
			vi$info ("Already positioned in that buffer");
		ELSE
			UNMAP (win);
			MAP (win, loop_buffer);
			vi$set_status_line (CURRENT_WINDOW);
		ENDIF;
	ELSE
		vi$info ("No previous file!");
	ENDIF;

	vi$kill_undo;
	vi$undo_end := 0;
	POSITION (win);
	RETURN (1);
ENDPROCEDURE

!
!	Map first file in file list to the current window, providing it makes
!	sense to do so (eg. no mapping should be done to the command window.
!
PROCEDURE vi$_first_file (bang)
	LOCAL
		win,
		fn,
		pos,
		found_one,
		btype,
		bn,
		how_many_buffers,
		possible_buffer,
		possible_buffer_name,
		loop_buffer,
		line;

	ON_ERROR
		! Ignore errors
	ENDON_ERROR;

	IF (NOT bang) AND (vi$check_auto_write) THEN
		RETURN;
	ENDIF;

	pos := MARK (NONE);
	win := CURRENT_WINDOW;

	POSITION (BEGINNING_OF (vi$file_names));
	IF (MARK (NONE) = END_OF (vi$file_names)) THEN
		vi$info ("No filename list!");
		POSITION (pos);
		RETURN (1);
	ENDIF;

	fn := vi$current_line;

	bn := FILE_PARSE (fn, "", "", NAME);
	btype := FILE_PARSE (fn, "", "", TYPE);

	IF btype = "" THEN
		btype := ".";
	ENDIF;

	bn := bn + btype;

	found_one := vi$choose_buffer (bn, how_many_buffers,
			   		 		possible_buffer, possible_buffer_name, loop_buffer);

	IF (found_one) THEN
		POSITION (pos);
		IF (CURRENT_BUFFER = loop_buffer) THEN
			vi$info ("Already positioned in that buffer");
		ELSE
			UNMAP (win);
			MAP (win, loop_buffer);
			vi$set_status_line (CURRENT_WINDOW);
		ENDIF;
	ELSE
		vi$info ("Buffer not found: " + bn + "!");
	ENDIF;

	vi$kill_undo;
	vi$undo_end := 0;
	POSITION (win);
	RETURN (1);
ENDPROCEDURE;

!
!	Show the contents of the tags buffer
!
PROCEDURE vi$_show_tags
	vi$show_list (vi$tag_buf,
		"Current tags from the files: "+vi$tag_files, info_window)
ENDPROCEDURE;

!
!	Show the list of filenames currently being used by the NEXT FILE, FIRST
!	FILE, and PREVIOUS FILE commands.
!
PROCEDURE vi$_show_files
	vi$show_list (vi$file_names, 
"  File names currently active for PREVIOUS, FIRST and NEXT line mode commands",
		info_window)

ENDPROCEDURE;

!
!	Show a buffer, dbuf, in a window, dwin, with the status line set to 'stat'.
!	Allow scrolling around, but no editing.  <ENTER> gets you out.
!
PROCEDURE vi$show_list (dbuf, stat, dwin)

	LOCAL
		this_key,
		win,
		pos;

	win := CURRENT_WINDOW;
	pos := MARK (NONE);

	MAP (dwin, dbuf);
	SET (STATUS_LINE, dwin, NONE, "");
	SET (STATUS_LINE, dwin, REVERSE, stat);
	POSITION (dwin);
	SET (EOB_TEXT, dbuf,
"[Press RETURN to continue editing]                        ");
	UPDATE (dwin);

	LOOP
		this_key := vi$read_a_key;
		EXITIF (this_key = RET_KEY);

		IF (this_key = CTRL_D_KEY) OR
		   (this_key = CTRL_U_KEY) OR
		   (this_key = CTRL_F_KEY) OR
		   (this_key = CTRL_B_KEY) OR
		   (this_key = KEY_NAME ('h')) OR
		   (this_key = KEY_NAME ('j')) OR
		   (this_key = KEY_NAME ('k')) OR
		   (this_key = KEY_NAME ('l')) THEN

	   		EXECUTE (LOOKUP_KEY (this_key, PROGRAM, vi$cmd_keys));
			UPDATE (CURRENT_WINDOW);
		ENDIF;
	ENDLOOP;

	UNMAP (dwin);
	SET (STATUS_LINE, dwin, NONE, "");
	SET (EOB_TEXT, dbuf, "");
	POSITION (win);
	POSITION (pos);
ENDPROCEDURE;

!
!	This procedure creates a new buffer with the named file in it.
!	Checking is done to see if the input file exists, and CREATE was on
!	the command line, etc...
!
PROCEDURE vi$_create_buffer (buffer_name, req_name, actual_file_name)

	LOCAL
		info,
		succ,
		outf,
		new_buffer;		! Buffer created

	ON_ERROR
		IF ERROR = TPU$_DUPBUFNAME THEN
		  	vi$info (FAO ("Buffer !AS already exists", buffer_name));
			RETURN (0);
		ENDIF;
	ENDON_ERROR;

	IF (actual_file_name = 0) OR (actual_file_name = "") THEN
		new_buffer := CREATE_BUFFER (buffer_name);

		IF (req_name <> 0) THEN
			outf := FILE_PARSE (req_name);
		    vi$info (FAO ("New file ""!AS""", outf));
		    SET (OUTPUT_FILE, new_buffer, outf);
		ENDIF;
	ELSE
		vi$info ("Reading file """+actual_file_name+"""");
		new_buffer := CREATE_BUFFER (buffer_name, actual_file_name);

		vi$info (FAO ("""!AS"", !UL lines", actual_file_name,
		   	GET_INFO (new_buffer, "RECORD_COUNT")));

		IF (vi$starting_up) THEN
			IF GET_INFO (COMMAND_LINE, "OUTPUT") THEN
				SET (OUTPUT_FILE, new_buffer,
					FILE_PARSE (GET_INFO (COMMAND_LINE, "OUTPUT_FILE"),
					                                    actual_file_name));

				!  Set the buffer to be modified so that the file will
				!  be written on exit.

				SPLIT_LINE;
				APPEND_LINE;
			ENDIF;
		ELSE
			SET (OUTPUT_FILE, new_buffer, actual_file_name);
		ENDIF;
	ENDIF;

	IF (vi$check_auto_write) THEN
		RETURN;
	ENDIF;

	vi$setbufmode (new_buffer, vi$readonly);

	MAP (CURRENT_WINDOW, new_buffer);
	vi$status_lines (new_buffer);

	SET (TAB_STOPS, new_buffer, vi$tab_amount);

	RETURN (new_buffer);
ENDPROCEDURE;

!
!	Add a string to the end of the choice buffer
!
PROCEDURE vi$add_choice (choice_string)

	LOCAL 
		pos;		! Current position in the buffer

	pos := MARK (NONE);
	POSITION (END_OF (choice_buffer));
	COPY_TEXT (choice_string);
	POSITION (pos);
ENDPROCEDURE;

!
!	Put a message into the message window, and note that it is there.  The
!	main command procedure will remove it later.
!
PROCEDURE vi$info (mess)
	MESSAGE (mess);
	vi$did_mess := 1;
ENDPROCEDURE;

!
!	Print the system error message corresponding to the error code passed.
!
PROCEDURE vi$system_message (errno)
	vi$info (CALL_USER (vi$cu_getmsg, STR(errno)));
ENDPROCEDURE;       

!
!  Below are the window manipulation routines.  They take care of
!  spliting and deleting windows.  The vi$prev_win and vi$next_win are
!  very VERY dependent on there not being any occusion of the windows
!  that they consider.  If a window is occluded, the results are
!  unpredictable.
!
!  Split the current window exactly where it is at
!
PROCEDURE vi$split_here

	LOCAL
		curwin,
		nextwin,
		curtop,
		curbuf,
		len,
		line,
		row,
		errno,
		spos,
		newwin,
		newlen,
		newtop,
		top;

	ON_ERROR
		errno := ERROR;
		line := ERROR_LINE;
		vi$info ("ERROR at line: "+ STR (line));
		vi$system_message (errno);
		RETURN(1);
	ENDON_ERROR

	IF (vi$in_occlusion) THEN
		vi$info ("Can't split while MAKE FULL SCREEN is active");
		RETURN (1);
	ENDIF;

	spos := MARK (NONE);
	curwin	:=	CURRENT_WINDOW;
	row		:=	GET_INFO (curwin, "CURRENT_ROW");
	top		:=	GET_INFO (curwin, "VISIBLE_TOP");
	len		:=	GET_INFO (curwin, "VISIBLE_LENGTH");

	IF (row - top < 1) OR (top + len - row < 3) THEN

		IF (len < 3) THEN
			vi$info ("Can't split window");
			RETURN(1);
		ENDIF;
		row := top + (len/2) - 1;
	ENDIF;

	curbuf := GET_INFO (curwin, "BUFFER");
	UNMAP (curwin);
	DELETE (curwin);

	! Create the upper window.

	newlen := row - top + 1;
	newwin := CREATE_WINDOW (top, newlen, ON);

	MAP (newwin, curbuf);
	vi$set_status_line (newwin);

	! Create the lower window.

	newtop := row + 1;
	newwin := CREATE_WINDOW (newtop, len - (newtop - top), ON);

	MAP (newwin, curbuf);
	vi$set_status_line (newwin);

	POSITION (newwin);
	vi$pos_in_middle (MARK (NONE));
	vi$previous_window;
	vi$pos_in_middle (MARK (NONE));

	vi$this_window := CURRENT_WINDOW;

	RETURN (0);
ENDPROCEDURE;

!
!	This procedure is used to initialize some things that are necessarily
!	changed when the editing environment changes because of window or other
!	operations.
!
PROCEDURE vi$new_env
	vi$how_much_scroll := GET_INFO (CURRENT_WINDOW, "VISIBLE_LENGTH") / 2;
	vi$new_offset := 1;
ENDPROCEDURE;

!
!  Delete the current window
!
PROCEDURE vi$delete_window
	LOCAL
		curwin;

	IF (vi$in_occlusion) THEN
		IF (CURRENT_WINDOW <> vi$occluding_win) THEN
			vi$info ("Can't delete this window.");
			RETURN;
		ENDIF;

		UNMAP (vi$old_occ_win);
		MAP (vi$old_occ_win, CURRENT_BUFFER);
		DELETE (vi$occluding_win);
		vi$in_occlusion := 0;
		vi$set_status_line (CURRENT_WINDOW);
		vi$new_env;
	ELSE
		curwin	:= GET_INFO (WINDOWS, "CURRENT");
		vi$del_win (curwin);
	ENDIF;
ENDPROCEDURE;

!
!	Do the actual work of deleting a window
!
PROCEDURE vi$del_win (curwin)

	LOCAL
		max_len,		! Maximum length of screen minus the
						! command window and message window
		prevwin,		! Window before the current
		nextwin,		! Window below the current
		prevtop,		! Top line of previous window
		nexttop,		! Top line of next window
		curtop,			! Top line of current window
		prevbuf,		! Buffer mapped to previous window
		prevlen,		! Length of previous window
		curlen,			! Length of current window
		nextbuf,		! Buffer mapped to next window
		nextend,		! Last line of next window
		newwin,
		nextlen;		! Length of next window

	max_len := vi$scr_length - 2;
	prevwin	:= vi$prev_win (curwin);
	nextwin	:= vi$next_win (curwin);
	curlen	:= GET_INFO (curwin, "VISIBLE_LENGTH");
	curtop	:= GET_INFO (curwin, "VISIBLE_TOP");

	IF (nextwin <> 0) THEN
		nextend	:= GET_INFO (nextwin, "VISIBLE_BOTTOM");
	ELSE
		nextend := max_len+1;  ! Something greater than the max_len used below
	ENDIF;

	IF (nextwin <> 0) AND (nextend <= max_len) THEN
		nextlen := GET_INFO (nextwin, "VISIBLE_LENGTH");
		nextbuf := GET_INFO (nextwin, "BUFFER");
		newwin := CREATE_WINDOW (curtop, curlen+nextlen, ON);
		UNMAP (curwin);
		UNMAP (nextwin);
		MAP (newwin, nextbuf);
		vi$set_status_line (newwin);
		DELETE (curwin);
		DELETE (nextwin);
	ELSE
		IF (prevwin <> 0) THEN
			prevlen := GET_INFO (prevwin, "VISIBLE_LENGTH");
			prevbuf := GET_INFO (prevwin, "BUFFER");
	 		prevtop := GET_INFO (prevwin, "VISIBLE_TOP");
			newwin := CREATE_WINDOW (prevtop, curlen+prevlen, ON);
			UNMAP (curwin);
			UNMAP (prevwin);
			MAP (newwin, prevbuf);
			vi$set_status_line (newwin);
			DELETE (curwin);
			DELETE (prevwin);
		ELSE
			vi$info ("Can't delete this window");
			RETURN;
		ENDIF;
	ENDIF;

	IF (vi$prev_win (CURRENT_WINDOW) = 0) THEN
		IF (vi$next_win (CURRENT_WINDOW) = 0) THEN
			SET (STATUS_LINE, CURRENT_WINDOW, NONE, "");
			REFRESH;
		ENDIF;
	ENDIF;
	vi$this_window := CURRENT_WINDOW;
	vi$pos_in_middle (MARK (NONE));
	vi$new_env;
ENDPROCEDURE;

!
!   Take the current buffer (if there is more than one window displayed on the
!   screen), and remap it to a new window that occludes all others and is
!   the size of the screen.
!
PROCEDURE vi$make_full_screen

	LOCAL
		win,
		buf;

	IF (vi$in_occlusion) THEN
		vi$info ("Already in full screen");
		RETURN;
	ENDIF;

	IF (vi$next_win (CURRENT_WINDOW) = 0) THEN
		IF (vi$prev_win (CURRENT_WINDOW) = 0) THEN
			vi$info ("Current window is only window");
			RETURN;
		ENDIF;
	ENDIF;

	vi$old_occ_win := CURRENT_WINDOW;

	buf := CURRENT_BUFFER;
	win := CREATE_WINDOW (1, vi$scr_length - 1, ON);
	vi$occluding_win := win;

	IF (win <> 0) THEN
		vi$in_occlusion := 1;
		SET (STATUS_LINE, win, NONE, "");
		MAP (win, buf);
		vi$pos_in_middle (MARK (NONE));
		vi$new_env;
	ELSE
		vi$info ("Error creating window, command aborted!");
	ENDIF;
ENDPROCEDURE;

!
!  Move to next window going down the screen
!
PROCEDURE vi$next_window

	LOCAL
		nextwin,
		curwin;

	IF (vi$in_occlusion) THEN
		RETURN;
	ENDIF;

	curwin := CURRENT_WINDOW;
	nextwin := vi$next_win (curwin);

	IF (nextwin <> 0) THEN
		POSITION (nextwin);
		vi$set_status_line (nextwin);
		vi$new_env;
	ENDIF;
ENDPROCEDURE;

!
!  Move to previous window going up the screen
!
PROCEDURE vi$previous_window

	LOCAL
		prevwin,
		curwin;

	IF (vi$in_occlusion) THEN
		RETURN;
	ENDIF;

	curwin := CURRENT_WINDOW;
	prevwin := vi$prev_win (curwin);

	IF (prevwin <> 0) THEN
		POSITION (prevwin);
		vi$set_status_line (prevwin);
		vi$new_env;
	ENDIF;
ENDPROCEDURE;

!          
!   Return the window that is below the current one, or ZERO if there is
!   none.  Note the special case that occurs while MAKE_FULL_SCREEN is active.
!
PROCEDURE vi$next_win (win)

	LOCAL
		winbot,
		nexttop,
		nextwin;

	IF (vi$in_occlusion) THEN
		RETURN (0);
	ENDIF;

	nextwin := GET_INFO (WINDOWS, "FIRST");
	winbot := GET_INFO (win, "VISIBLE_BOTTOM");

	IF (winbot >= (vi$scr_length - 3)) THEN
		RETURN (0);
	ENDIF;

	LOOP
		EXITIF nextwin = 0;

		IF (GET_INFO (nextwin, "BUFFER") <> 0) THEN
			nexttop := GET_INFO (nextwin, "VISIBLE_TOP");

			IF (winbot + 2 = nexttop) THEN
				RETURN (nextwin);
			ENDIF;
		ENDIF;

		nextwin := GET_INFO (nextwin, "NEXT");
	ENDLOOP;

	RETURN (0);
ENDPROCEDURE;                             

!
!   Return the window that is above the current one, or ZERO if there is
!   none.  Note the special case that occurs while MAKE_FULL_SCREEN is active.
!
PROCEDURE vi$prev_win (win)

	LOCAL
		max_len,	! Maximum length of screen minus the
					! command window, and message window.
		wintop,
		prevbot,
		prevwin;

	IF (vi$in_occlusion) THEN
		RETURN(0);
	ENDIF;

	max_len := vi$scr_length - 1;
	prevwin := GET_INFO (WINDOWS, "FIRST");
	wintop := GET_INFO (win, "VISIBLE_TOP");

	IF (max_len <= wintop) THEN
		RETURN (0);
	ENDIF;

	IF (max_len - 1 = GET_INFO (win, "VISIBLE_BOTTOM")) AND (wintop = 1) THEN
		RETURN (0);
	ENDIF;

	LOOP
		EXITIF prevwin = 0;

		IF (GET_INFO (prevwin, "BUFFER") <> 0) THEN
			prevbot := GET_INFO (prevwin, "VISIBLE_BOTTOM");

			IF (prevbot + 2 = wintop) THEN
				RETURN (prevwin);
			ENDIF;
		ENDIF;

		prevwin := GET_INFO (prevwin, "NEXT");
	ENDLOOP;

	RETURN (0);
ENDPROCEDURE;

!
!	Shrink the current window, lengthing the lower window if possible first.
!	If there is no window below, then try above.  If can't do that either,
!	then give up with a message
!
PROCEDURE vi$shrink_window (shrinkparm)

	LOCAL
	   	curwin,
		currow,
	 	prevwin,
		nextwin,
		newshrink;

	IF (vi$in_occlusion) THEN
		RETURN;
	ENDIF;

	newshrink := shrinkparm;

	curwin := GET_INFO (WINDOWS, "CURRENT");
	currow := GET_INFO (curwin, "VISIBLE_LENGTH");

	IF (currow < 3) THEN
		vi$info ("Can't shrink this window");
		RETURN;
	ENDIF;

	IF newshrink > currow - 2 THEN
		newshrink := currow - 2;
	ENDIF;

	IF newshrink <= 0 THEN
		vi$info ("Can't shrink this window");
		RETURN;
	ENDIF;

	nextwin := vi$next_win (curwin);
	prevwin := vi$prev_win (curwin);

	IF (nextwin <> 0) THEN
		ADJUST_WINDOW (curwin, 0, -newshrink);
		ADJUST_WINDOW (nextwin, -newshrink, 0);
	ELSE
		IF (prevwin <> 0) THEN
			ADJUST_WINDOW (curwin, newshrink, 0);
			ADJUST_WINDOW (prevwin, 0, newshrink);
		ELSE
		  	vi$info ("Can't shrink this window");
			RETURN;
		ENDIF;
	ENDIF;
	POSITION (curwin);
	vi$pos_in_middle (MARK(NONE));
ENDPROCEDURE;

!
!	Enlarge the current window if possible.  Try moving the bottom down.
!	If that doesn't work, then try moving the top up.
!
PROCEDURE vi$enlarge_window (enlargeparm)

	LOCAL
		curwin,
		prevwin,
		nextwin,
		nextrow,
		newenlarge,
		prevrow;

	IF (vi$in_occlusion) THEN
		RETURN;
	ENDIF;

	newenlarge := enlargeparm;

	curwin := GET_INFO (WINDOWS, "CURRENT");

	nextwin := vi$next_win (curwin);
	prevwin := vi$prev_win (curwin);

	IF (nextwin <> 0) THEN
		nextrow := GET_INFO (nextwin, "VISIBLE_LENGTH");

		IF (nextrow > 2) then
			IF (newenlarge + 2 > nextrow) THEN
				newenlarge := nextrow - 2;
			ENDIF;

			IF newenlarge <= 0 THEN
				vi$info ("Can't enlarge this window");
				RETURN;
			ENDIF;

			ADJUST_WINDOW (nextwin, newenlarge, 0);
			ADJUST_WINDOW (curwin, 0, newenlarge);
		ELSE
			vi$info ("Can't shrink next window");
			RETURN;
		ENDIF;
	ELSE
		IF (prevwin <> 0) THEN

			prevrow := GET_INFO (prevwin, "VISIBLE_LENGTH");

			IF (prevrow < 3) THEN
				vi$info ("Can't shrink previous window");
				RETURN;
			ENDIF;

			IF (newenlarge + 2 > prevrow) THEN
			 	newenlarge := prevrow - 2;
			ENDIF;

			IF newenlarge = 0 THEN
				vi$info ("Can't enlarge this window");
				RETURN;
			ENDIF;

			ADJUST_WINDOW (prevwin, 0, -newenlarge);
			ADJUST_WINDOW (curwin, -newenlarge, 0);
		ELSE
			vi$info ("Can't enlarge this window");
			RETURN;
		ENDIF;  
	ENDIF;

	POSITION (curwin);
	vi$pos_in_middle (MARK(NONE));
ENDPROCEDURE;

!
!	Set the status line for the window passed
!
PROCEDURE vi$set_status_line (win)
	LOCAL
		nowr,
		buf,
		fmtstr,
		fn;

	IF (GET_INFO (win, "STATUS_VIDEO") <> REVERSE) THEN
		RETURN;
	ENDIF;

	buf := GET_INFO (win, "BUFFER");
	nowr := " ";
	IF (GET_INFO (buf, "NO_WRITE")) THEN
		nowr := "*";
	ENDIF;
	fn := GET_INFO (buf, "NAME");
	SET (STATUS_LINE, win, NONE, "");
	fmtstr := "!" + STR (GET_INFO (win, "WIDTH"));
	SET (STATUS_LINE, win, REVERSE,
			FAO (fmtstr+"<!ASBuffer: !AS!>", nowr, fn));
ENDPROCEDURE;

!       
!	Position the location passed into the middle of the current window.
!
PROCEDURE vi$pos_in_middle (pos)
	LOCAL
		leng,
		s_amt,
		s_bot,
		s_top,
		cur_window;

	ON_ERROR    
	ENDON_ERROR;                                

	cur_window    := CURRENT_WINDOW;
	leng := GET_INFO (cur_window, "VISIBLE_LENGTH");

	s_amt := GET_INFO (cur_window, "SCROLL_AMOUNT");
	s_bot := GET_INFO (cur_window, "SCROLL_TOP");
	s_top := GET_INFO (cur_window, "SCROLL_BOTTOM");
	SET (SCROLLING, cur_window, ON, 0, 0, leng/2);
	POSITION (pos);
	vi$update (cur_window);
	SET (SCROLLING, cur_window, ON, s_top, s_bot, s_amt);
	POSITION (pos);
ENDPROCEDURE;

!
!	Update the status lines for windows with the buffer passed mapped to them
!
PROCEDURE vi$status_lines (buf)
	LOCAL
		win;

	win := GET_INFO (WINDOWS, "FIRST");
	LOOP
		EXITIF (win = 0);
		IF (GET_INFO (win, "BUFFER") = buf) THEN
			vi$set_status_line (win);
		ENDIF;
		win := GET_INFO (WINDOWS, "NEXT");
	ENDLOOP;
ENDPROCEDURE;

!
!	Send the string passed to a DCL process.  All the necessary stuff is
!	done to move to the DCL buffer, and start the DCL process, and all
!	of the other junk.
!
PROCEDURE vi$send_to_dcl (dcl_string)

	ON_ERROR
		IF ERROR = TPU$_CREATEFAIL THEN
			vi$info ("DCL subprocess could not be created");
			RETURN (1);
		ENDIF;
	ENDON_ERROR;

	IF CURRENT_BUFFER <> vi$dcl_buf THEN

		IF (GET_INFO (vi$dcl_buf, "MAP_COUNT") > 0) AND
				(vi$in_occlusion = 0) THEN
			POSITION (vi$dcl_buf);
		ELSE

			! Attempt to split the screen at the cursor position

			IF (vi$split_here = 1) THEN
				IF (vi$in_occlusion = 0) THEN
					vi$info ("Move cursor to middle of current window");
				ENDIF;
				RETURN (1);
			ENDIF;

			MAP (CURRENT_WINDOW, vi$dcl_buf);
		ENDIF;
	ENDIF;

	POSITION (END_OF (vi$dcl_buf));
	vi$status_lines (CURRENT_BUFFER);
	UPDATE (CURRENT_WINDOW);

	IF (GET_INFO (vi$dcl_process, "TYPE") = UNSPECIFIED) OR
						  					   (vi$dcl_process = 0) THEN
		vi$info ("Creating DCL subprocess...");
		vi$dcl_process := CREATE_PROCESS (vi$dcl_buf);
		IF (vi$dcl_process = 0) THEN
			RETURN;
		ENDIF;
		vi$info ("Process was created");
	ENDIF;

	SPLIT_LINE;
	COPY_TEXT (dcl_string);
	UPDATE (CURRENT_WINDOW);
	SEND (dcl_string, vi$dcl_process);
	POSITION (END_OF (vi$dcl_buf));
	UPDATE (CURRENT_WINDOW);

	RETURN (0);
ENDPROCEDURE;

!
!
!
PROCEDURE vi$mess_select (mode)
	LOCAL
		pos;

	pos := MARK (NONE);
	vi$message_select := 0;
	POSITION (END_OF (message_buffer));
	vi$message_select := SELECT (mode);
	POSITION (pos);
ENDPROCEDURE;

!
!  Allow local modifications to be done here.
!
PROCEDURE tpu$local_init
ENDPROCEDURE;

!      
!	Create a section file, and terminate.
!
vi$init_keys;
COMPILE ("PROCEDURE vi$init_keys ENDPROCEDURE;");
SAVE ("SYS$DISK:[]VI.GBL");
QUIT;
