<HTML>
<HEAD>
<TITLE>RuleWorks</TITLE>
</HEAD>
<BODY>

<FONT FACE="Arial" SIZE=6 color="navy"><P ALIGN="RIGHT">RuleWorks</P></FONT>

<B><I><FONT FACE="HELVETICA" SIZE=6 color="RED"><P ALIGN="RIGHT">
Application Programming Interface</P></B></I></FONT>


<P>This chapter contains reference information about each routine in the RuleWorks run-time library.</P>
<P>The table below explains the constants defined in the RuleWorks API:</P>
<B><FONT FACE="Arial" SIZE=2><P>
RuleWorks Defined Constants</P><P>Name  &#9;Description  &#9;Value</P>
</B></FONT><FONT FACE="NewCenturySchlbk" SIZE=1><P>RUL_C_INVALID_ATOM  &#9;The atomic value used to signal&#9;NULL  <BR>
&#9;an error </P>
<P>RUL_C_INVALID_LENGTH   &#9;An integer value used to signal&#9;-1  <BR>
&#9;an error </P>
<P>RUL_C_MAX_SYMBOL_SIZE   &#9;Maximum numbers of characters&#9;256 <BR>
&#9;in an atom of type SYMBOL </P>
<P>RUL_C_RESET_WM_ATOM  &#9;An object identifier defined to&#9;&#9;NULL <BR>
&#9;be the first (lowest) in working <BR>
&#9;memory.</P>
<P>&nbsp;</P>
<OL>

<LI></font><B><FONT FACE="Helvetica" SIZE=5><A NAME="atom_is_compound_page">rul_atom_is_compound</A></LI>
</B></FONT><FONT SIZE=2><P>Indicates whether a value is a RuleWorks COMPOUND value.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>truth_value</I> = <B>rul_atom_is_compound</B> (<I>atom_value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;Access</P>
</B></FONT><FONT FACE="NewCenturySchlbk" SIZE=1><P>truth_value  &#9;boolean  &#9;&#9;&#9;write</P>
<I><P>atom_value</I>  &#9;opaque atom  &#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean rul_atom_is_compound (rul_atom atom_value);</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>atom_value</P>
</B><P>The value to be tested.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>TRUE if its argument is a RuleWorks COMPOUND value; otherwise, FALSE.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_atom_is_fatom</P>
<P>rul_atom_is_iatom</P>
<P>rul_atom_is_symbol</P>
<P>rul_atom_is_instance_id</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="atom_is_is_fatom">rul_atom_is_fatom</A></LI>
</B></FONT><FONT SIZE=2><P>Indicates whether a value is a RuleWorks FLOAT atom.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>truth_value</I> = <B>rul_atom_is_fatom</B> (<I>atom_value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>truth_value</I>  &#9;boolean  &#9;&#9;&#9;write</P>
<I><P>atom_value</I>  &#9;opaque atom  &#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean rul_atom_is_fatom (rul_atom atom_value);</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>atom_value</P>
</B><P>The value to be tested.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>TRUE if its argument is a RuleWorks FLOAT atom; otherwise, FALSE.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_atom_is_compound</P>
<P>rul_atom_is_iatom</P>
<P>rul_atom_is_symbol</P>
<P>rul_atom_is_instance_id</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="atom_is_iatom_page">rul_atom_is_iatom</A></LI>
</B></FONT><FONT SIZE=2><P>Indicates whether a value is a RuleWorks INTEGER atom.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>truth_value</I> = <B>rul_atom_is_iatom</B> (<I>atom_value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>truth_value</I>  &#9;boolean  &#9;&#9;&#9;write</P>
<I><P>atom_value</I>  &#9;opaque atom  &#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean rul_atom_is_iatom (rul_atom atom_value);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>atom_value</P>
</B><P>The value to be tested.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>TRUE if the argument is a RuleWorks INTEGER atom; otherwise, FALSE.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_atom_is_compound</P>
<P>rul_atom_is_fatom</P>
<P>rul_atom_is_symbol</P>
<P>rul_atom_is_instance_id</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="atom_is_instance_id_page">rul_atom_is_instance_id</A></LI>
</B></FONT><FONT SIZE=2><P>Indicates whether a value is a RuleWorks INSTANCE-ID atom.</P>
<P>Note that rul_atom_is_instance_id does not indicate that the object associated with the INSTANCE-ID still exists. Use rul_is_instance to check that.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>truth_value</I> = <B>rul_atom_is_instance_id</B> (<I>atom_value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>truth_value</I>  &#9;boolean  &#9;&#9;&#9;write</P>
<I><P>atom_value</I>  &#9;opaque atom  &#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean rul_atom_is_instance_id (rul_atom atom_value);</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>atom_value</P>
</B><P>The value to be tested.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>TRUE if the argument is a RuleWorks INSTANCE-ID atom; otherwise, FALSE.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_atom_is_compound</P>
<P>rul_atom_is_fatom</P>
<P>rul_atom_is_iatom</P>
<P>rul_atom_is_symbol</P>
<P>rul_is_instance</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="atom_is_symbol_page">rul_atom_is_symbol</A></LI>
</B></FONT><FONT SIZE=2><P>Indicates whether a value is a RuleWorks SYMBOL atom.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>truth_value</I> = <B>rul_atom_is_symbol</B> (<I>atom_value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>truth_value</I>  &#9;boolean  &#9;&#9;&#9;write</P>
<I><P>atom_value</I>  &#9;opaque atom  &#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean rul_atom_is_symbol (rul_atom atom_value);</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>atom_value</P>
</B><P>The value to be tested.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>TRUE if the argument is a RuleWorks SYMBOL atom; otherwise, FALSE.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_atom_is_fatom</P>
<P>rul_atom_is_iatom</P>
<P>rul_atom_is_instance_id</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="atom_to_string_page">rul_atom_to_string</A></LI>
</B></FONT><FONT SIZE=2><P>Converts a RuleWorks atom to a string, regardless of the atom's type.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>num_chars</I> = <B>rul_atom_to_string</B> (<I>char_string, string_size, atom_value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>num_chars</I>  &#9;integer  &#9;&#9;&#9;write</P>
<I><P>char_string</I>  &#9;string  &#9;&#9;&#9;write</P>
<I><P>string_size</I>  &#9;integer  &#9;&#9;&#9;read</P>
<I><P>atom_value</I>  &#9;opaque atom  &#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>long rul_atom_to_string (  <BR>
char &#9;char_string <BR>
long&#9;string_size <BR>
rul_atom&#9;atom_value);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>char_string</P>
</B><P>The read form of the specified atom, set by the function (see Chapter 2 for information on read forms).</P>
<B>
<P>string_size</P>
</B><P>The maximum number of characters to copy into <I>char_string</I>.</P>
<B>
<P>atom_value</P>
</B><P>The RuleWorks atom to be converted.</P>
</FONT><B><I><P>Return Values</P>
</B></I><FONT SIZE=2><P>The number of characters in the string that represents the read form of the specified atom; or RUL_C_INVALID_LENGTH if an error occurs (for example, the buffer specified by <I>char_string</I> is too small for the read form).</P>

<P>Since the print form of a RuleWorks atom is at most RUL_C_MAX_SYMBOL_SIZE characters, allocating a buffer 3 + (2 &lt;math_char&gt;(times) RUL_C_MAX_SYMBOL_SIZE) characters long is guaranteed to be adequate for any read form.</P>
</FONT><B><I><LI>Examples</LI>
</B></I><FONT SIZE=2><P> The following example is in the C programming language.</P>
</FONT><FONT FACE="Courier" SIZE=1><P>char result[RUL_C_MAX_SYMBOL_SIZE + 1];</P>
<P>char_count = rul_atom_to_string (result, RUL_C_MAX_SYMBOL_SIZE + 1, my_atom);</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_atom_to_string_length</P>
<P>rul_string_to_atom</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="atom_to_string_length_page">rul_atom_to_string_length</A></LI>
</B></FONT><FONT SIZE=2><P>Finds the number of characters in the read form of a specified atom.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>num_chars</I> = <B>rul_atom_to_string_length</B> (<I>atom_value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>num_chars</I>  &#9;integer  &#9;&#9;&#9;write</P>
<I><P>atom_value</I>  &#9;opaque atom  &#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>long rul_atom_to_string_length (rul_atom atom_value);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>atom_value</P>
</B><P>The RuleWorks atom to be converted.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>The number of characters in the string that represents the read form of the specified atom.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_atom_to_string</P>
<P>rul_string_to_atom</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="attr_is_compound_page">rul_attr_is_compound</A></LI>
</B></FONT><FONT SIZE=2><P>Indicates whether an attribute is compound or scalar.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>truth_value</I> = <B>rul_attr_is_compound</B> (<I>class_name, attr_name, block_name</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>truth_value</I>  &#9;boolean  &#9;&#9;&#9;write</P>
<I><P>class_name</I>  &#9;string  &#9;&#9;&#9;read</P>
<I><P>attr_name</I>  &#9;string  &#9;&#9;&#9;read</P>
<I><P>block_name</I>  &#9;string  &#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean  rul_attr_is_compound (  <BR>
     char&#9;*class_name, <BR>
     char&#9;*attr_name, <BR>
     char&#9;*block_name);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>class_name</P>
</B><P>A string that names the object class of the attribute.</P>
<B>
<P>attr_name</P>
</B><P>A string that names the attribute to be tested.</P>
<B>
<P>block_name</P>
</B><P>A string that names the block in which the object class was declared.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>TRUE if <I>attr_name</I> is the name of an attribute declared to be compound in the object class specified by <I>class_name</I>; otherwise, FALSE.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_get_comp_attr_length</P>
<P>rul_get_comp_attr_string</P>
<P>rul_get_comp_elem_atom</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="copy_instance_page">rul_copy_instance</A></LI>
</B></FONT><FONT SIZE=2><P>Creates a new object identical to the one specified.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>new_object_id</I> = <B>rul_copy_instance</B> (<I>old_object_id</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>new_object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;write</P>
<I><P>old_object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_atom rul_copy_instance (rul_atom old_object_id)</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>old_object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object to be copied.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>The RuleWorks INSTANCE-ID atom associated with the newly-created object; or RUL_C_INVALID_ATOM if for any reason the function was unable to create the new object.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_get_instance</P>
<P>rul_make_instance</P>
<P>rul_specialize_instance</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="api_debug_page">rul_debug</A></LI>
</B></FONT><FONT SIZE=2><P>Causes the RuleWorks&gt; prompt to appear at the beginning of the next recognize-act cycle, if the active entry block was compiled with the Debug qualifier set to YES or MAYBE.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</I><FONT SIZE=2><P>rul_debug</B>  ( )</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>void rul_debug (void);</P>
</FONT><B><I><LI>Arguments</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>None.</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="double_to_fatom_page">rul_double_to_fatom</A></LI>
</B></FONT><FONT SIZE=2><P>Converts a double-precision floating-point number into a RuleWorks FLOAT atom.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>atom_value</I> = <B>rul_double_to_fatom</B> (<I>double_value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;&#9;Data Type &#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>atom_value</I>  &#9;&#9;opaque float atom  &#9;&#9;write</P>
<I><P>double_value</I>  &#9;&#9;double float  &#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean rul_double_to_fatom (double double_value);</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>double_value</P>
</B><P>The double-precision floating-point number to be converted.</P>
<P>(On OpenVMS VAX systems, this is a D_float value; on OpenVMS AXP systems, a G_float.)</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>A RuleWorks atom made from the floating-point number; or RUL_C_INVALID_ATOM if the function was unable to create the new atom for any reason.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_atom_is_fatom</P>
<P>rul_fatom_to_float</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="end_id_translation_page">rul_end_id_translation</A></LI>
</B></FONT><FONT SIZE=2><P>Signals the termination of an INSTANCE-ID translation table. See the description of rul_start_id_translation for details.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</I><FONT SIZE=2><P>rul_end_id_translation</B>  ( )</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>void rul_end_id_translation (void);</P>
</FONT><B><I><LI>Arguments</LI>
</B></I><FONT SIZE=2><P>None.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_make_instance</P>
<P>rul_start_id_translation</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="fatom_to_double_page">rul_fatom_to_double</A></LI>
</B></FONT><FONT SIZE=2><P>Converts a RuleWorks FLOAT atom into a double-precision floating-point number.</P>
<P>(On OpenVMS VAX systems, this is an F_float value; on OpenVMS AXP systems, a G_float.)</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>double_value</I> = <B>rul_fatom_to_double</B> (<I>atom_value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>double_value</I>  &#9;double float  &#9;&#9;&#9;write</P>
<I><P>atom_value</I>  &#9;opaque float atom  &#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt;</P>
<P>double rul_fatom_to_double (rul_atom atom_value);</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>atom_value</P>
</B><P>The RuleWorks FLOAT atom to be converted.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>A double-precision floating-point number made from the RuleWorks atom.  If the argument is not a float atom, the function returns 0.0 and issues a warning.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_atom_is_fatom</P>
<P>rul_fatom_to_float</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="fatom_to_float_page">rul_fatom_to_float</A></LI>
</B></FONT><FONT SIZE=2><P>Converts a RuleWorks FLOAT atom into a single-precision floating-point number.</P>
<P>(On VMS systems, this is an F_float value.)</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>float_value</I> = <B>rul_fatom_to_float</B> (<I>atom_value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>float_value</I>  &#9;single float  &#9;&#9;write</P>
<I><P>atom_value</I>  &#9;opaque float atom  &#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt;</P>
<P>float rul_fatom_to_float (rul_atom atom_value);</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>atom_value</P>
</B><P>The RuleWorks FLOAT atom to be converted.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>A single-precision floating-point number made from the RuleWorks atom.  If the argument is not a float atom, the function returns 0.0 and issues a warning.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_float_to_fatom</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="float_to_fatom_page">rul_float_to_fatom</A></LI>
</B></FONT><FONT SIZE=2><P>Converts a single-precision floating-point number into a RuleWorks FLOAT atom.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>atom_value</I> = <B>rul_float_to_fatom</B> (<I>float_value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>atom_value</I>  &#9;opaque float atom  &#9;&#9;write</P>
<I><P>float_value</I>  &#9;single float  &#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean rul_float_to_fatom (float float_value);</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>float_value</P>
</B><P>The floating-point number to be converted.</P>
<P>(On VMS systems, this is an F_float value.)</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>A RuleWorks atom made from the floating-point number; or RUL_C_INVALID_ATOM if the function was unable to create the new atom for any reason.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_atom_is_fatom</P>
<P>rul_fatom_to_float</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="api_genint_page">rul_genint</A></LI>
</B></FONT><FONT SIZE=2><P>Returns a RuleWorks INTEGER atom that is guaranteed to be unique throughout the run.</P>

<P>The RuleWorks atom generator is used by the RuleWorks GENATOM and GENINT functions, and by the rul_genint, rul_gensym and rul_gensymp API routines.  Every atom generated for any of these routines is unique while the program is running.</P>

<P>The generated atoms consist of an integer and an optional prefix. Within a program run, the first use of the atom generator returns 1, the second 2, and so on. The rul_genint routine and the GENINT action return an integer with no prefix. The rul_gensymp routine and the GENATOM action return an integer with a prefix that you can specify, or use the default prefix G:. The rul_gensym routine returns an integer prefixed by G:. The table below shows several uses of the atom generator and the atoms it returns:</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Routine Call or RHS Action  &#9;&#9;Atom Generated</P>
</B></FONT><FONT FACE="NewCenturySchlbk" SIZE=1><P>rul_genint()  &#9;&#9;&#9;1</P>
<P>rul_gensymp(R:)  &#9;&#9;&#9;R:2</P>
<P>(GENATOM)  &#9;&#9;&#9;G:3</P>
<P>(GENINT)  &#9;&#9;&#9;4</P>
<P>rul_gensym()  &#9;&#9;&#9;G:5</P>

</FONT><FONT SIZE=2><P>The atom generator is reset by the RESTORESTATE<B> </B>action and command.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>value</I> = <B>rul_genint</B> ( )</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>value</I>  &#9;opaque symbol atom  &#9;write</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_atom rul_genint (void);</P>
</FONT><B><I><LI>Arguments</LI>
</B></I><FONT SIZE=2><P>None.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>A RuleWorks-generated INTEGER atom.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_gensym</P>
<P>rul_gensymp</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="gensym_page">rul_gensym</A></LI>
</B></FONT><FONT SIZE=2><P>Generates a new symbol. See rul_genintfor an explanation of the RuleWorks atom generator.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>value</I> = <B>rul_gensym</B> ( )</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>value</I>  &#9;opaque symbol atom  &#9;write</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_atom rul_gensym (void);</P>
</FONT><B><I><LI>Arguments</LI>
</B></I><FONT SIZE=2><P>None.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>A RuleWorks SYMBOL atom guaranteed to be unique throughout the run.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_genint</P>
<P>rul_gensymp</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="gensymp_page">rul_gensymp</A></LI>
</B></FONT><FONT SIZE=2><P>Generates a new symbol, as does the rul_gensymroutine, but with a prefix that you specify instead of G:.  See rul_genintfor an explanation of the RuleWorks atom generator.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>value</I> = <B>rul_gensymp</B> ( <I>prefix</I> )</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>value</I>  &#9;opaque symbol atom  &#9;&#9;write</P>
<I><P>prefix</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_atom rul_gensymp (char *prefix);</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>prefix</P>
</B><P>A string to be placed in front of an integer by the RuleWorks atom generator. See rul_genintfor details.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>A RuleWorks SYMBOL atom guaranteed to be unique throughout the run.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_genint</P>
<P>rul_gensym</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="get_attr_atom_page">rul_get_attr_atom</A></LI>
</B></FONT><FONT SIZE=2><P>Accesses the value of a scalar attribute in an object.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>value</I> = <B>rul_get_attr_atom</B> (<I>object_id, attr_name</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>value</I>  &#9;opaque atom  &#9;&#9;&#9;write</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<I><P>attr_name</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_atom   rul_get_attr_atom ( <BR>
rul_atom   object_id, <BR>
char       *attr_name);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object to be accessed.</P>
<B>
<P>attr_name</P>
</B><P>A string that names the attribute whose value is returned.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>The RuleWorks atom value in the specified attribute of the specified object; or RUL_C_INVALID_ATOM if the function is unable to retrieve the value for any reason.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_get_instance</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="get_class_string_page">rul_get_class_string</A></LI>
</B></FONT><FONT SIZE=2><P>Accesses the class name of an object.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>num_chars</I> = <B>rul_get_class_string</B> (<I>char_string, string_size, object_id</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>num_chars</I>  &#9;integer  &#9;&#9;&#9;&#9;write</P>
<I><P>char_string</I>  &#9;string  &#9;&#9;&#9;&#9;write</P>
<I><P>string_size</I>  &#9;integer  &#9;&#9;&#9;&#9;read</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>long  rul_get_class_string ( <BR>
char      *char_string <BR>
long      string_size <BR>
rul_atom  object_id);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>char_string</P>
</B><P>The class name of the specified object, set by the function.</P>
<B>
<P>string_size</P>
</B><P>The number of characters in the class name.</P>
<B>
<P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object whose class name is returned.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>The number of characters in the string that contains the name of the class of the specified object; or RUL_C_INVALID_LENGTH if an error occurs (for example, the buffer specified by <I>char_string</I> is too small for the print form).</P>

<P>Since the class name can be no more than RUL_C_MAX_SYMBOL_SIZE characters,  allocating a buffer RUL_C_MAX_SYMBOL_SIZE + 1  characters long is guaranteed to be adequate.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_get_class_string_length</P>
<P>rul_get_instance</P>
<P>rul_is_instance</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="get_class_string_length_page">rul_get_class_string_length</A></LI>
</B></FONT><FONT SIZE=2><P>Returns the number of characters in the class name of an object.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>num_chars</I> = <B>rul_get_class_string_length</B> (<I>object_id</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>num_chars</I>  &#9;integer  &#9;&#9;&#9;&#9;write</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>long rul_get_class_string_length (rul_atom object_id);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object whose class name is measured.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>The number of characters in the name of the class of the specified object.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_get_class_string</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="get_comp_attr_length_page">rul_get_comp_attr_length</A></LI>
</B></FONT><FONT SIZE=2><P>Accesses the length of a compound attribute.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>length</I> = <B>rul_get_comp_attr_length</B> (<I>object_id, attr_name</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>length</I>  &#9;integer  &#9;&#9;&#9;&#9;write</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<I><P>attr_name</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>long  rul_get_comp_attr_length ( <BR>
rul_atom    object_id, <BR>
char         attr_name);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object to be accessed.</P>
<B>
<P>attr_name</P>
</B><P>A string that names a compound attribute in the object to be accessed.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>An integer that specifies the number of elements in the compound attribute's value; or RUL_C_INVALID_LENGTH if the function is unable to retrieve the specified attribute length for any reason.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_attr_is_compound</P>
<P>rul_get_comp_elem_atom</P>
<P>rul_get_comp_attr_string</P>
<P>rul_get_comp_attr_string_len</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="get_comp_attr_string_page">rul_get_comp_attr_string</A></LI>
</B></FONT><FONT SIZE=2><P>Accesses the read form of all the values in a compound attribute.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>num_chars</I> = <B>rul_get_comp_attr</B> (<I>values_string, string_size, object_id, attr_name</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>num_chars</I>  &#9;integer  &#9;&#9;&#9;&#9;write</P>
<I><P>values_string</I>  &#9;string  &#9;&#9;&#9;&#9;write</P>
<I><P>string_size</I>  &#9;integer  &#9;&#9;&#9;&#9;read</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<I><P>attr_name</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>long  rul_get_comp_attr_string ( <BR>
char     *values_string <BR>
long     string_size <BR>
rul_atom object_id <BR>
char     *attr_name);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>values_string</P>
</B><P>A string that contains the read form of each element in the specified compound attribute, set by the function. Values are separated by spaces.  This string does not include the name COMPOUND and is not enclosed in parentheses. (See Chapter 2 for more information on read forms.)</P>
<B>
<P>string_size</P>
</B><P>The number of characters in the read form.</P>
<B>
<P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object to be accessed.</P>
<B>
<P>attr_name</P>
</B><P>A string that names a compound attribute in the object to be accessed.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>The number of characters actually found in the string that contains the read forms of all the values in the compound attribute; or RUL_C_INVALID_LENGTH if an error occurs (for example, the buffer specified by <I>values_string</I> is too small for the read forms).</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_get_comp_attr_length</P>
<P>rul_get_comp_elem_atom</P>
<P>rul_get_comp_attr_string_len</P>
<P>rul_set_comp_attr_string</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="get_comp_attr_string_len_page">rul_get_comp_attr_string_len</A></LI>
</B></FONT><FONT SIZE=2><P>Returns the number of characters in the read form of all the values in a compound attribute.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>num_chars</I> = <B>rul_get_comp_attr_string_len</B> (<I>object_id, attr_name</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>num_chars</I>  &#9;integer  &#9;&#9;&#9;&#9;write</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<I><P>attr_name</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>long  rul_get_comp_attr_string_len ( <BR>
   rul_atom     object_id <BR>
   char         *attr_name);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object to be accessed.</P>
<B>
<P>attr_name</P>
</B><P>A string that names a compound attribute in the object to be accessed.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>The number of characters in the string that contains the read forms of all the values in the compound attribute.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_get_comp_attr_length</P>
<P>rul_get_comp_attr_string</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="get_comp_elem_atom_page">rul_get_comp_elem_atom</A></LI>
</B></FONT><FONT SIZE=2><P>Accesses the value of a single element of a compound attribute in an object.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>value</I> = <B>rul_get_comp_elem_atom</B> (<I>object_id, attr_name, element_index</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>value</I>  &#9;opaque atom  &#9;&#9;&#9;write</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<I><P>attr_name</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<I><P>element_index</I>  &#9;integer  &#9;&#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_atom  rul_get_comp_elem_atom ( <BR>
       rul_atom     object_id, <BR>
       char         *attr_name, <BR>
       long         element_index);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object to be accessed.</P>
<B>
<P>attr_name</P>
</B><P>A string that names a compound attribute in the object to be accessed.</P>
<B>
<P>element_index</P>
</B><P>An integer that specifies the position of the element to be accessed.</P>
</FONT><B><I><P>Return Values</P>
</B></I><FONT SIZE=2><P>The RuleWorks atom value of the specified compound attribute element; or RUL_C_INVALID_ATOM if the function is unable to retrieve the value for any reason.</P>
</FONT><B><I><P>See Also</P>
</B></I><FONT SIZE=2><P>rul_attr_is_compound</P>
<P>rul_get_comp_attr_length</P>
<P>rul_get_comp_attr_string</P>
</FONT><B><FONT FACE="Helvetica" SIZE=5><P><A NAME="get_firing_rule_page">rul_get_firing_rule</A></P>
</B></FONT><FONT SIZE=2><P>Identifies the rule that the RuleWorks run-time system is currently executing.</P>
</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>value</I> = <B>rul_get_firing_rule</B> ( )</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>value</I>  &#9;opaque symbol atom  &#9;write</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_atom  rul_get_firing_rule ( void );</P>
</FONT><B><I><LI>Arguments</LI>
</B></I><FONT SIZE=2><P>None.</P>
</FONT><B><I><P>Return Values</P>
</B></I><FONT SIZE=2><P>The SYMBOL atom that identifies the name of the rule that is currently executing, or the symbol NIL if no rule is executing.</P>
</FONT><B><FONT FACE="Helvetica" SIZE=5><P><A NAME="get_instance_page">rul_get_instance</A></P>
</B></FONT><FONT SIZE=2><P>Accesses the read form of a working-memory object.</P>
</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>num_chars</I> = <B>rul_get_instance</B> (<I>print_string, string_size, object_id</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>num_chars</I>  &#9;integer  &#9;&#9;&#9;&#9;write</P>
<I><P>print_string</I>  &#9;string  &#9;&#9;&#9;&#9;write</P>
<I><P>string_size</I>  &#9;integer  &#9;&#9;&#9;&#9;read</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>long  rul_get_instance (  <BR>
   char     *print_string <BR>
   long     string_size <BR>
   rul_atom object_id);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>print_string</P>
</B><P>The read form of the specified object, set by the function.  The string returned is in a form similar to that printed by the PPWM debugger command. It is enclosed in parentheses and includes the ^$ID value, so that it can be used with rul_start_id_translation and rul_end_id_translation</P>
<B>
<P>string_size</P>
</B><P>The number of characters allocated for the read form.</P>
<B>
<P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object to be accessed.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>The number of characters actually found in the string that contains the read form of the specified object; or RUL_C_INVALID_LENGTH if an error occurs (for example, the buffer specified by <I>string_size</I> is too small for the read form).</P>
</FONT><B><I><LI>Example</LI>
</B></I><FONT SIZE=2><P> See rul_make_instance and rul_get_instance_length.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_end_id_translation</P>
<P>rul_get_attr_atom</P>
<P>rul_get_comp_attr_length</P>
<P>rul_get_comp_attr_string</P>
<P>rul_get_instance_length</P>
<P>rul_make_instance</P>
<P>rul_start_id_translation</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="get_instance_length_page">rul_get_instance_length</A></LI>
</B></FONT><FONT SIZE=2><P>Returns the number of characters in the read form of a working-memory object.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>num_chars</I> = <B>rul_get_instance_length</B> (<I>object_id</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>num_chars</I>  &#9;integer  &#9;&#9;&#9;&#9;write</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>long rul_get_instance_length (rul_atom object_id);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object to be accessed.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>The number of characters in the read form of the specified object.</P>
</FONT><B><I><LI>Example</LI>
</B></I><FONT SIZE=2><P> The C routine below uses rul_get_instance_length to find the correct <I>string_size</I> argument for rul_get_instance:</P>
</FONT><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt;</P>
<P>#include &lt;stdlib.h&gt;__/* For malloc() */</P>
<P>#include &lt;stdio.h&gt;__/* For printf() */</P>
<P>/*</P>
<P> * Print the readform of the WME whose instance ID is passed.</P>
<P> */</P>
<P>void</P>
<P>print_wme(rul_atom wme_id)</P>
<P>{</P>
<P>    char *buffer;</P>
<P>    unsigned int buffer_size;</P>
<P>    buffer_size = rul_get_instance_length(wme_id) + 1;</P>
<P>____/* Add 1 for null terminator */</P>
<P>    buffer = (char *) malloc(buffer_size);</P>
<P>    if (buffer == NULL) {</P>
<P>_fprintf(stderr, "Unable to allocate memory");</P>
<P>_exit(EXIT_FAILURE);</P>
<P>    }</P>
<P>    rul_get_instance(buffer, buffer_size, wme_id);</P>
<P>    printf("%s\n", buffer);</P>
<P>    free(buffer);</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_get_instance</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="get_next_instance_page">rul_get_next_instance</A></LI>
</B></FONT><FONT SIZE=2><P>Allows iteration over the entire set of objects in working memory.</P>

<P>To do this, start by passing the defined constant, RUL_C_RESET_WM_ATOM, to rul_get_next_instance. The function then returns the INSTANCE-ID of the first object in working memory.  Pass this return value on the second call to rul_get_next_instance to get the INSTANCE-ID of the second object. Continue this cycle until the function returns RUL_C_INVALID_ATOM, which means the identifiers of all existing objects have been returned.</P>

<B><P>Note:</B> that this function returns INSTANCE-IDs in no particular order. If any objects are made, modified, or removed during iteration over the set of objects, undesired results will occur. For example, the function may return the same INSTANCE-ID more than once, or may never return a particular INSTANCE-ID.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>object_id</I> = <B>rul_get_next_instance</B> (<I>previous_instance_id</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;write</P>
<I><P>previous_instance_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_atom rul_get_next_instance (rul_atom previous_instance_id);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>previous_instance_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object previously accessed.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>The RuleWorks INSTANCE-ID atom that identifies the next object in the set.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_get_instance</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="iatom_to_integer_page">rul_iatom_to_integer</A></LI>
</B></FONT><FONT SIZE=2><P>Converts a RuleWorks INTEGER atom into an integer.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>integer_value</I> = <B>rul_iatom_to_integer</B> (<I>atom_value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>integer_value</I>  &#9;integer  &#9;&#9;&#9;write</P>
<I><P>atom_value</I>  &#9;opaque integer atom  &#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>long rul_iatom_to_integer (rul_atom atom_value);</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>atom_value</P>
</B><P>The RuleWorks INTEGER atom to be converted.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>An integer made from the RuleWorks atom. If the input argument is not an INTEGER atom, the function returns 0 and issues a warning.</P>
</FONT><B><I><LI>See Also</LI>
</B></I><FONT SIZE=2><P>rul_fatom_to_float</P>
<P>rul_integer_to_iatom</P>
</FONT><B><FONT FACE="Helvetica" SIZE=5><P><A NAME="integer_to_iatom_page">rul_integer_to_iatom</A></P>
</B></FONT><FONT SIZE=2><P>Converts an integer number into a RuleWorks INTEGER atom.</P>
</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>atom_value</I> = <B>rul_integer_to_iatom</B> (<I>integer_value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>atom_value</I>  &#9;opaque integer atom  &#9;write</P>
<I><P>integer_value</I>  &#9;integer  &#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_atom rul_integer_to_atom (long integer_value);</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>integer_value</P>
</B><P>The integer to be converted.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>The RuleWorks INTEGER atom made from the integer; or RUL_C_INVALID_ATOM if the function was unable to create the atom for any reason.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_float_to_fatom</P>
<P>rul_iatom_to_integer</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="is_attribute_page">rul_is_attribute</A></LI>
</B></FONT><FONT SIZE=2><P>Indicates whether an attribute is declared in the specified object class.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>truth_value</I> = <B>rul_is_attribute</B> (<I>class_name, attr_name, block_name</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>truth_value</I>  &#9;boolean  &#9;&#9;write</P>
<I><P>class_name</I>  &#9;string  &#9;&#9;read</P>
<I><P>attr_name</I>  &#9;string  &#9;&#9;read</P>
<I><P>block_name</I>  &#9;string  &#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean  rul_is_attribute ( <BR>
char   *class_name, <BR>
char   *attr_name, <BR>
char   *block_name);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>class_name</P>
</B><P>A string that names the desired object class.</P>
<B>
<P>attr_name</P>
</B><P>A string that names the desired attribute.</P>
<B>
<P>block_name</P>
</B><P>A string that names the block in which the object class was declared.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>TRUE if the attribute is declared in the specified class; FALSE if it is not declared.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_get_attr_atom</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="is_class_page">rul_is_class</A></LI>
</B></FONT><FONT SIZE=2><P>Indicates whether an object class with the specified name has been declared in an OBJECT-CLASS declaration.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>truth_value</I> = <B>rul_is_class</B> (<I>class_name, block_name</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>truth_value</I>  &#9;boolean  &#9;&#9;&#9;write</P>
<I><P>class_name</I>  &#9;string  &#9;&#9;&#9;read</P>
<I><P>block_name</I>  &#9;string  &#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean  rul_is_class ( <BR>
          char    *class_name, <BR>
          char    *block_name);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>class_name</P>
</B><P>A string that names the desired object class.</P>
<B>
<P>block_name</P>
</B><P>A string that names the block in which the object class was declared.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>TRUE if the specified object class name has been declared; FALSE if it has not been declared.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_get_class_string</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="is_instance_page">rul_is_instance</A></LI>
</B></FONT><FONT SIZE=2><P>Indicates whether the object that corresponds to the specified INSTANCE-ID exists.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>truth_value</I> = <B>rul_is_instance</B> (<I>object_id</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>truth_value</I>  &#9;boolean  &#9;&#9;&#9;&#9;write</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean rul_is_instance (rul_atom object_id);</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID associated with the object to be tested.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>TRUE if the argument is a RuleWorks INSTANCE-ID atom and the object associated with that INSTANCE-ID exists in working memory; otherwise, FALSE.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_atom_is_instance_id</P>
<P>rul_get_instance</P>
<P>rul_make_instance</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="is_subclass_page">rul_is_subclass</A></LI>
</B></FONT><FONT SIZE=2><P>Indicates whether one object class is a subclass of another.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>truth_value</I> = <B>rul_is_subclass</B> (<I>child_name, parent_name, block_name</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>truth_value</I>  &#9;boolean  &#9;&#9;write</P>
<I><P>child_name</I>  &#9;string  &#9;&#9;read</P>
<I><P>parent_name</I>  &#9;string  &#9;&#9;read</P>
<I><P>block_name</I>  &#9;string  &#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean  rul_is_subclass ( <BR>
          char    *child_name, <BR>
          char    *parent_name, <BR>
          char    *block_name);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>child_name</P>
</B><P>A string that names the object class to be tested for subclass status.</P>
<B>
<P>parent_name</P>
</B><P>A string that names the object class to be tested for ancestor status.</P>
<B>
<P>block_name</P>
</B><P>A string that names the block in which the object classes are declared.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>TRUE if both arguments are the names of declared object classes and the first argument is the name of a subclass of the second argument; otherwise, FALSE.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_is_class</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="make_instance_page">rul_make_instance</A></LI>
</B></FONT><FONT SIZE=2><P>Creates a new object from a string.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>object_id</I> = <B>rul_make_instance</B> (<I>char_string, block_name</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;write</P>
<I><P>char_string</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<I><P>block_name</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_atom  rul_make_instance (  <BR>
       char    *string,  <BR>
       char    *block_name);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>char_string</P>
</B><P>The string to be made into an object. This string must be in the same format as would be passed to a MAKE action in the RuleWorks language. The class name of the object to be created is required; attribute names and values are optional.  The object class must be declared in the block named by </P>
<I><P>block_name</I>.</P>

<P>The string may be enclosed in parentheses but they are not required. If the string includes the ^$ID value, it is ignored unless ID translation is on (see rul_start_id_translation.</P>
<B>
<P>block_name</P>
</B><P>A string that names the block in which the object class was declared.</P>
</FONT><B><I><P>Return Values</P>
</B></I><FONT SIZE=2><P>The RuleWorks INSTANCE-ID atom associated with the newly-created object; or RUL_C_INVALID_ATOM if the function is unable to create an object from the specified string for any reason.</P>
</FONT><B><I><P>Example</P>
</B></I><FONT SIZE=2><P>The following example, in the C programming language, makes an object of class  </FONT><FONT FACE="Courier" SIZE=2>animal</FONT><FONT SIZE=2> with attributes  </FONT><FONT FACE="Courier" SIZE=2>color</FONT><FONT SIZE=2> and  </FONT><FONT FACE="Courier" SIZE=2>species</FONT><FONT SIZE=2> set.</P>
</FONT><FONT FACE="Courier" SIZE=1><P>object_id = rul_make_instance ("(ANIMAL ^COLOR BLACK ^SPECIES PANTHER)",</P>
<P>                               "my-block")</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_copy_instance</P>
<P>rul_end_id_translation</P>
<P>rul_get_instance</P>
<P>rul_remove_instance</P>
<P>rul_specialize_instance</P>
<P>rul_start_id_translation</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="remove_instance_page">rul_remove_instance</A></LI>
</B></FONT><FONT SIZE=2><P>Removes an object from working memory.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>status</I> = <B>rul_remove_instance</B> (<I>object_id</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>status</I>  &#9;boolean  &#9;&#9;&#9;&#9;write</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean rul_remove_instance (rul_atom object_id);</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object to be removed.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>TRUE if the object is successfully removed; FALSE if the function is unable to remove the object for any reason.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_copy_instance</P>
<P>rul_make_instance</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="set_attr_atom_page">rul_set_attr_atom</A></LI>
</B></FONT><FONT SIZE=2><P>Changes the value of a scalar attribute.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>status</I> = <B>rul_set_attr_atom</B> (<I>object_id, attr_name, value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>status</I>  &#9;boolean  &#9;&#9;&#9;&#9;write</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<I><P>attr_name</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<I><P>value</I>  &#9;opaque atom  &#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean  rul_set_attr_atom (  <BR>
          rul_atom     object_id, <BR>
          char         *attr_name, <BR>
          rul_atom     value);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object to be modified.</P>
<B>
<P>attr_name</P>
</B><P>A string that names the attribute to be modified.</P>
<B>
<P>value</P>
</B><P>The RuleWorks atom that specifies the new value of the attribute.  This atom may be any RuleWorks data type, even INSTANCE-ID.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>TRUE if the attribute is successfully modified; FALSE if the function is unable to change the specified attribute value for any reason.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_set_attr_double</P>
<P>rul_set_attr_float</P>
<P>rul_set_attr_integer</P>
<P>rul_set_attr_string</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="set_attr_double_page">rul_set_attr_double</A></LI>
</B></FONT><FONT SIZE=2><P>Changes the value of a scalar attribute to a double-precision floating-point number.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>status</I> = <B>rul_set_attr_double</B> (<I>object_id, attr_name, value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>status</I>  &#9;boolean  &#9;&#9;&#9;&#9;write</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<I><P>attr_name</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<I><P>value</I>  &#9;double float  &#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean  rul_set_attr_double (  <BR>
          rul_atom     object_id, <BR>
          char         *attr_name, <BR>
          double       value);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object to be modified.</P>
<B>
<P>attr_name</P>
</B><P>A string that names the attribute to be modified.</P>
<B>
<P>value</P>
</B><P>The double-precision floating-point number that specifies the new value of the attribute. This argument is converted into a RuleWorks FLOAT atom before it is placed into the specified attribute.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>TRUE if the attribute is successfully modified; FALSE if the function is unable to change the specified attribute value for any reason.</P>
</FONT><B><I><P>See Also</P>
</B></I><FONT SIZE=2><P>rul_set_attr_atom</P>
<P>rul_set_attr_float</P>
<P>rul_set_attr_integer</P>
<P>rul_set_attr_string</P>
</FONT><B><FONT FACE="Helvetica" SIZE=5><P><A NAME="set_attr_float_page">rul_set_attr_float</A></P>
</B></FONT><FONT SIZE=2><P>Changes the value of a scalar attribute to a single-precision floating-point number.</P>
</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>status</I> = <B>rul_set_attr_float</B> (<I>object_id, attr_name, value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>status</I>  &#9;boolean  &#9;&#9;&#9;&#9;write</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<I><P>attr_name</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<I><P>value</I>  &#9;float  &#9;&#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean  rul_set_attr_float (  <BR>
          rul_atom     object_id, <BR>
          char         *attr_name, <BR>
          float        value);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object to be modified.</P>
<B>
<P>attr_name</P>
</B><P>A string that names the attribute to be modified.</P>
<B>
<P>value</P>
</B><P>The single-precision floating-point number that specifies the new value of the attribute. This argument is converted into a RuleWorks FLOAT atom before it is placed into the specified attribute.</P>
</FONT><B><I><P>Return Values</P>
</B></I><FONT SIZE=2><P>TRUE if the attribute is successfully modified; FALSE if the function is unable to change the specified attribute value for any reason.</P>
</FONT><B><I><P>See Also</P>
</B></I><FONT SIZE=2><P>rul_set_attr_atom</P>
<P>rul_set_attr_double</P>
<P>rul_set_attr_integer</P>
<P>rul_set_attr_string</P>
</FONT><B><FONT FACE="Helvetica" SIZE=5><P><A NAME="set_attr_integer_page">rul_set_attr_integer</A></P>
</B></FONT><FONT SIZE=2><P>Changes the value of a scalar attribute to an integer.</P>
</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>status</I> = <B>rul_set_attr_integer</B> (<I>object_id, attr_name, value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>status</I>  &#9;boolean  &#9;&#9;&#9;&#9;write</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<I><P>attr_name</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<I><P>value</I>  &#9;integer  &#9;&#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean  rul_set_attr_integer (  <BR>
          rul_atom     object_id, <BR>
          char         *attr_name, <BR>
          long         value);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object to be modified.</P>
<B>
<P>attr_name</P>
</B><P>A string that names the attribute to be modified.</P>
<B>
<P>value</P>
</B><P>The integer that specifies the new value of the attribute.  This argument is converted into a RuleWorks INTEGER atom before it is placed into the specified attribute.</P>
</FONT><B><I><LI>Return Values</LI>
</B></I><FONT SIZE=2><P>TRUE if the object is successfully modified; FALSE if the function is unable to change the attribute value for any reason.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_set_attr_atom</P>
<P>rul_set_attr_double</P>
<P>rul_set_attr_float</P>
<P>rul_set_attr_string</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="set_attr_string_page">rul_set_attr_string</A></LI>
</B></FONT><FONT SIZE=2><P>Changes the value of an attribute to a symbol.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>status</I> = <B>rul_set_attr_string</B> (<I>object_id, attr_name, value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>status</I>  &#9;boolean  &#9;&#9;&#9;&#9;write</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<I><P>attr_name</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<I><P>value</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean  rul_set_attr_string (  <BR>
          rul_atom     object_id, <BR>
          char         *attr_name, <BR>
          char         *value);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object to be modified.</P>
<B>
<P>attr_name</P>
</B><P>A string that names the attribute to be modified.</P>
<B>
<P>value</P>
</B><P>A string that specifies the new value of the attribute. This argument is converted to a SYMBOL atom before it is placed into the specified attribute (see Chapter 2 for more information on symbolic atoms).</P>
</FONT><B><I><P>Return Values</P>
</B></I><FONT SIZE=2><P>TRUE if the object is successfully modified; FALSE if the function is unable to change the attribute value for any reason.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_set_attr_atom</P>
<P>rul_set_attr_double</P>
<P>rul_set_attr_float</P>
<P>rul_set_attr_integer</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="set_comp_attr_string_page">rul_set_comp_attr_string</A></LI>
</B></FONT><FONT SIZE=2><P>Changes the value of an entire compound attribute to the values extracted from a single string.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>status</I> = <B>rul_set_comp_attr_string</B> (<I>object_id, attr_name, values</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>status</I>  &#9;boolean  &#9;&#9;&#9;&#9;write</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<I><P>attr_name</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<I><P>values</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean  rul_set_comp_attr_string (  <BR>
          rul_atom     object_id, <BR>
          char         *attr_name, <BR>
          char         *values);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object to be modified.</P>
<B>
<P>attr_name</P>
</B><P>A string that names the compound attribute to be modified.</P>
<B>
<P>values</P>
</B><P>A single string that contains the new value for each element in the compound attribute. The items in this string must be read forms that follow the RuleWorks rules for quoted atoms (see Chapter 2) and are separated by white space.</P>
</FONT><B><I><P>Return Values</P>
</B></I><FONT SIZE=2><P>TRUE if the object is successfully modified; FALSE if the function is unable to change the compound attribute for any reason.</P>
</FONT><B><I><LI>Example</LI>
</B></I><FONT SIZE=2><P> The following example, in the C programming language, changes the value of the compound attribute  </FONT><FONT FACE="Courier" SIZE=2>colors</FONT><FONT SIZE=2> with a single string containing four values.</P>
</FONT><FONT FACE="Courier" SIZE=1><P>status = rul_set_comp_attr ( object_id_1, "COLORS", "BLACK GREEN WHITE RED" );</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_get_comp_attr_string</P>
<P>rul_set_comp_elem_atom</P>
<P>rul_set_comp_elem_float</P>
<P>rul_set_comp_elem_integer</P>
<P>rul_set_comp_elem_string</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="set_comp_elem_atom_page">rul_set_comp_elem_atom</A></LI>
</B></FONT><FONT SIZE=2><P>Changes the value of a single element of a compound attribute to an atom value.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>status</I> = <B>rul_set_comp_elem_atom</B> (<I>object_id, attr_name, element_index, value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>status</I>  &#9;boolean  &#9;&#9;&#9;&#9;write</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<I><P>attr_name</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<I><P>element_index</I>  &#9;integer  &#9;&#9;&#9;&#9;read</P>
<I><P>value</I>  &#9;opaque atom  &#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean  rul_set_comp_elem_atom (  <BR>
          rul_atom      object_id, <BR>
          char          *attr_name, <BR>
          long          element_index, <BR>
          rul_atom      value);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object to be modified.</P>
<B>
<P>attr_name</P>
</B><P>A string that names the compound attribute to be modified.</P>
<B>
<P>element_index</P>
</B><P>An integer that specifies the position within the compound attribute of the element to be modified.</P>
<B>
<P>value</P>
</B><P>The RuleWorks atom that specifies the new value of the compound attribute element. This atom may be any RuleWorks data type, even INSTANCE-ID.</P>
</FONT><B><I><P>Return Values</P>
</B></I><FONT SIZE=2><P>TRUE if the compound element attribute is successfully modified; FALSE if the function is unable to change the element value for any reason.</P>
</FONT><B><I><P>See Also</P>
</B></I><FONT SIZE=2><P>rul_get_comp_elem_atom</P>
<P>rul_set_comp_elem_float</P>
<P>rul_set_comp_elem_double</P>
<P>rul_set_comp_elem_integer</P>
<P>rul_set_comp_elem_string</P>
</FONT><B><FONT FACE="Helvetica" SIZE=5><P><A NAME="set_comp_elem_double_page">rul_set_comp_elem_double</A></P>
</B></FONT><FONT SIZE=2><P>Changes the value of a single element of a compound attribute to a double-precision floating-point number.</P>
</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>status</I> = <B>rul_set_comp_elem_double</B> (<I>object_id, attr_name, element_index, value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>status</I>  &#9;boolean  &#9;&#9;&#9;&#9;write</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<I><P>attr_name</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<I><P>element_index</I>  &#9;integer  &#9;&#9;&#9;&#9;read</P>
<I><P>value</I>  &#9;float  &#9;&#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean  rul_set_comp_elem_double (  <BR>
          rul_atom      object_id, <BR>
          char          *attr_name, <BR>
          long          element_index, <BR>
          double        value);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object to be modified.</P>
<B>
<P>attr_name</P>
</B><P>A string that names the compound attribute to be modified.</P>
<B>
<P>element_index</P>
</B><P>An integer that specifies the position within the compound attribute of the element to be modified.</P>
<B>
<P>value</P>
</B><P>A double-precision floating-point number that specifies the new value of the compound attribute element. This number is converted to a RuleWorks FLOAT atom before the value is set.</P>
</FONT><B><I><P>Return Values</P>
</B></I><FONT SIZE=2><P>TRUE if the compound attribute element is successfully modified; FALSE if the function is unable to change the element value for any reason.</P>
</FONT><B><I><P>See Also</P>
</B></I><FONT SIZE=2><P>rul_get_comp_elem_atom</P>
<P>rul_set_comp_elem_atom</P>
<P>rul_set_comp_elem_float</P>
<P>rul_set_comp_elem_integer</P>
<P>rul_set_comp_elem_string</P>
</FONT><B><FONT FACE="Helvetica" SIZE=5><P><A NAME="set_comp_elem_float_page">rul_set_comp_elem_float</A></P>
</B></FONT><FONT SIZE=2><P>Changes the value of a single element of a compound attribute to a single-precision floating-point number.</P>
</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>status</I> = <B>rul_set_comp_elem_float</B> (<I>object_id, attr_name, element_index, value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>status</I>  &#9;boolean  &#9;&#9;&#9;&#9;write</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<I><P>attr_name</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<I><P>element_index</I>  &#9;integer  &#9;&#9;&#9;&#9;read</P>
<I><P>value</I>  &#9;float  &#9;&#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean  rul_set_comp_elem_float (  <BR>
          rul_atom&#9;object_id, <BR>
          char &#9;*attr_name, <BR>
          long&#9;&#9; element_index, <BR>
          float&#9; value);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object to be modified.</P>
<B>
<P>attr_name</P>
</B><P>A string that names the compound attribute to be modified.</P>
<B>
<P>element_index</P>
</B><P>An integer that specifies the position within the compound attribute of the element to be modified.</P>
<B>
<P>value</P>
</B><P>A single-precision floating-point number that specifies the new value of the compound attribute element. This number is converted to a RuleWorks FLOAT atom before the value is set.</P>
</FONT><B><I><P>Return Values</P>
</B></I><FONT SIZE=2><P>TRUE if the compound attribute element is successfully modified; FALSE if the function is unable to change the element value for any reason.</P>
</FONT><B><I><LI>See Also</LI>
</B></I><FONT SIZE=2><P>rul_get_comp_elem_atom</P>
<P>rul_set_comp_elem_atom</P>
<P>rul_set_comp_elem_double</P>
<P>rul_set_comp_elem_integer</P>
<P>rul_set_comp_elem_string</P>
</FONT><B><FONT FACE="Helvetica" SIZE=5><P><A NAME="set_comp_elem_integer_page">rul_set_comp_elem_integer</A></P>
</B></FONT><FONT SIZE=2><P>Changes the value of a single element of a compound attribute to an integer.</P>
</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>status</I> = <B>rul_set_comp_elem_integer</B> (<I>object_id, attr_name, element_index, value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>status</I>  &#9;boolean  &#9;&#9;&#9;&#9;write</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<I><P>attr_name</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<I><P>element_index</I>  &#9;integer  &#9;&#9;&#9;&#9;read</P>
<I><P>value</I>  &#9;integer  &#9;&#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean  rul_set_comp_elem_integer (  <BR>
          rul_atom    object_id, <BR>
          char        *attr_name, <BR>
          long        element_index, <BR>
          long        value);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object to be modified.</P>
<B>
<P>attr_name</P>
</B><P>A string that names the compound attribute to be modified.</P>
<B>
<P>element_index</P>
</B><P>An integer that specifies the position within the compound attribute of the element to be modified.</P>
<B>
<P>value</P>
</B><P>An integer that specifies the new value of the compound attribute element. The integer is converted to a RuleWorks INTEGER atom before the value is set.</P>
</FONT><B><I><P>Return Values</P>
</B></I><FONT SIZE=2><P>TRUE if the compound attribute element was successfully modified; FALSE if the function is unable to change the element value for any reason.</P>
</FONT><B><I><P>See Also</P>
</B></I><FONT SIZE=2><P>rul_get_comp_elem_atom</P>
<P>rul_set_comp_elem_atom</P>
<P>rul_set_comp_elem_float</P>
<P>rul_set_comp_elem_string</P>
</FONT><B><FONT FACE="Helvetica" SIZE=5><P><A NAME="set_comp_elem_string_page">rul_set_comp_elem_string</A></P>
</B></FONT><FONT SIZE=2><P>Changes the value of a single element of a compound attribute to a string.</P>
</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>status</I> = <B>rul_set_comp_elem_string</B> (<I>object_id, attr_name, element_index, value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>status</I>  &#9;boolean  &#9;&#9;&#9;&#9;write</P>
<I><P>object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<I><P>attr_name</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<I><P>element_index</I>  &#9;integer  &#9;&#9;&#9;&#9;read</P>
<I><P>value</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_boolean  rul_set_comp_elem_string (  <BR>
          rul_atom   object_id, <BR>
          char       *attr_name, <BR>
          long       element_index, <BR>
          char       *value);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object to be modified.</P>
<B>
<P>attr_name</P>
</B><P>A string that names the compound attribute to be modified.</P>
<B>
<P>element_index</P>
</B><P>An integer that specifies the position within the compound attribute of the element to be modified.</P>
<B>
<P>value</P>
</B><P>A character string that specifies the new value of the compound attribute element. The string is converted to a RuleWorks SYMBOL atom before the value is set.</P>
</FONT><B><I><P>Return Values</P>
</B></I><FONT SIZE=2><P>TRUE if the compound attribute element is successfully modified; FALSE if the function is unable to change the element value for any reason.</P>
</FONT><B><I><P>See Also</P>
</B></I><FONT SIZE=2><P>rul_get_comp_elem_atom</P>
<P>rul_set_comp_elem_atom</P>
<P>rul_set_comp_elem_float</P>
<P>rul_set_comp_elem_integer</P>
</FONT><B><FONT FACE="Helvetica" SIZE=5><P><A NAME="specialize_instance_page">rul_specialize_instance</A></P>
</B></FONT><FONT SIZE=2><P>Changes an instance of a parent class to an instance of a subclass.</P>
</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>same_object_id</I> = <B>rul_specialize_instance</B> (<I>old_object_id, subclass</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>same_object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;write</P>
<I><P>old_object_id</I>  &#9;opaque INSTANCE-ID atom  &#9;read</P>
<I><P>subclass</I>  &#9;string  &#9;&#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_atom  rul_specialize_instance ( <BR>
       rul_atom     old_object_id, <BR>
       char         *subclass);</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>old_object_id</P>
</B><P>The RuleWorks INSTANCE-ID atom associated with the object to be specialized.</P>
<B>
<P>subclass</P>
</B><P>A string that names an object class that inherits from the current class of the object being specialized.</P>
</FONT><B><I><P>Return Values</P>
</B></I><FONT SIZE=2><P>The RuleWorks INSTANCE-ID atom associated with the newly-modified object; or RUL_C_INVALID_ATOM if for any reason the function was unable to change the class. Note that the return value should be the same as the <I>old_object_id</I>.</P>
</FONT><B><I><P>See Also</P>
</B></I><FONT SIZE=2><P>rul_copy_instance</P>
<P>rul_get_instance</P>
<P>rul_make_instance</P>
</FONT><B><FONT FACE="Helvetica" SIZE=5><P><A NAME="start_id_translation_page">rul_start_id_translation</A></P>
</B></FONT><FONT SIZE=2><P> Signals the creation of an INSTANCE-ID translation table.</P>

<P>A translation table allows a set of objects saved by an application as a set of text strings to be recreated via rul_make_instance. Interobject references in the strings are correctly integrated with the current RuleWorks program. A translation table is built incrementally from the strings passed to the rul_make_instance function. The table stores the mapping between INSTANCE-IDs contained in the strings and INSTANCE-IDs actually allocated by the current program for the new objects created by the rul_make_instance function.</P>

<P>When rul_end_id_translation is called, all INSTANCE-ID attribute values in the newly-made objects are updated, and the table is deleted. INSTANCE-ID values within the strings passed to rul_make_instance that correspond to objects  created while ID translation was in effect are set to the actual INSTANCE-IDs of the new objects. INSTANCE-ID values within the strings whose corresponding objects were not created within the scope of the translation are set to INSTANCE-ID values for which no objects exist.</P>
</FONT><B><I><LI>Syntax</LI>
</I><FONT SIZE=2><P>rul_start_id_translation</B>  ( )</P>
</FONT><B><I><P>C Binding</P>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>void rul_start_id_translation (void);</P>
</FONT><B><I><LI>Arguments</LI>
</B></I><FONT SIZE=2><P>None.</P>
</FONT><B><I><LI>Example</LI></OL>
</OL>

</B></I><FONT SIZE=2><P> This example, in the C programming language, illustrates the effect of INSTANCE-ID translation on objects created by rul_make_instance.</P>
</FONT><FONT FACE="Courier" SIZE=1><P>rul_start_id_translation();</P>
<P>rul_make_instance ("SEAL ^$ID #293 ^NAME CHUBBY", NULL);</P>
<P>rul_make_instance ("SEAL ^$ID #232 ^NAME NOISY ^FATHER #293 ^MOTHER #288", 0);</P>
<P>rul_make_instance ("SEAL ^$ID #239 ^NAME SKINNY ^FATHER #298 ^MOTHER #288", 0);</P>
<P>rul_make_instance ("KILLER-WHALE ^$ID #103 ^NAME SHAMMY", 0);</P>
<P>rul_make_instance ("KILLER-WHALE ^$ID #137 ^NAME TAMMY ^FATHER #103", 0);</P>
<P>rul_make_instance ("KILLER-WHALE ^$ID #143 ^NAME WHAMMY  ^MOTHER #137", 0);</P>
<P>rul_end_id_translation(); The translation table for this example would contain the following INSTANCE-ID values:</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>INSTANCE-ID&#9;WMO Created? (^name)  &#9;New INSTANCE-ID<BR>
from String</P>
</B></FONT><FONT FACE="NewCenturySchlbk" SIZE=1><P>#293  &#9;Yes (Chubby)  &#9;&#9;#2112</P>
<P>#232  &#9;Yes (Noisy)  &#9;&#9;#2113</P>
<P>#288  &#9;No  &#9;&#9;&#9;#2114</P>
<P>#239  &#9;Yes (Skinny)  &#9;&#9;#2115</P>
<P>#298  &#9;No  &#9;&#9;&#9;#2116</P>
<P>#103  &#9;Yes (Shammy)  &#9;&#9;#2117</P>
<P>#137  &#9;Yes (Tammy)  &#9;&#9;#2118</P>
<P>#143  &#9;Yes (Whammy)  &#9;&#9;#2119</P>

</FONT><FONT SIZE=2><P>(The middle column is shown for clarity.) Note that a new INSTANCE-ID is generated to correspond to #288 even though no object with that INSTANCE-ID is made.</P>
</FONT><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;</FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">ppwm killer-whale ^name whammy</B></FONT><FONT FACE="Courier" SIZE=1> </P>
<P>#2119 7116 [NIL] (KILLER-WHALE ^NAME WHAMMY ^MOTHER #2118)</P>
</FONT><FONT SIZE=2><P>This PPWM command shows that the ^MOTHER attribute in the object created for Whammy correctly points to the object created for Tammy.  </P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt;</FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">ppwm seal</B></FONT><FONT FACE="Courier" SIZE=1> </P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>#2112 7111 [NIL] (SEAL ^NAME CHUBBY)</FONT><FONT FACE="Courier" SIZE=1> </P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>#2113 7112 [NIL] (SEAL ^NAME NOISY ^FATHER #2112 ^MOTHER #2114)</FONT><FONT FACE="Courier" SIZE=1> </P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>#2115 7113 [NIL] (SEAL ^NAME SKINNY ^FATHER #2116 ^MOTHER #2114)</P>
</FONT><FONT SIZE=2><P>This PPWM command shows that the ^MOTHER attribute in the objects created for Noisy and Skinny both point to the same nonexistent object.  Conversely, the ^FATHER and ^MOTHER attributes of Skinny point to different nonexistent objects.</P>
</FONT><B><I><P>See Also</P>
</B></I><FONT SIZE=2><P>rul_end_id_translation</P>
<P>rul_make_instance</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="string_to_atom_page">rul_string_to_atom</A></LI>
</B></FONT><FONT SIZE=2><P>Converts the first token of a string into a RuleWorks atom.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>atom_value</I> = <B>rul_string_to_atom</B> (<I>char_string</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>atom_value</I>  &#9;opaque atom  &#9;&#9;write</P>
<I><P>char_string</I>  &#9;string  &#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_atom rul_string_to_atom (char *char_string);</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>char_string</P>
</B><P>The read form of the atom to be made (see Chapter 2 for details on read forms).</P>
</FONT><B><I><LI>Return Values</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>The RuleWorks atom that corresponds to the first token in the character string. Tokens are groups of characters separated by white space: parentheses and other nonalphanumerics count as characters, not separators.  If possible, the returned atom is an INTEGER, FLOAT, or INSTANCE-ID; if not, a SYMBOL. See Chapter 2 for an explanation of atom types.</P>
</FONT><B><I><P>See Also</P>
</B></I><FONT SIZE=2><P>rul_atom_to_string</P>
<P>rul_string_to_compound</P>
<P>rul_string_to_symbol</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="string_to_compound_page">rul_string_to_compound</A></LI>
</B></FONT><FONT SIZE=2><P>Converts a string into a RuleWorks COMPOUND value.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>atom_value</I> = <B>rul_string_to_compound</B> (<I>char_string</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>atom_value</I>  &#9;opaque atom  &#9;&#9;write</P>
<I><P>char_string</I>  &#9;string  &#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_atom atom_value rul_string_to_compound (char *char_string);</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>char_string</P>
</B><P>The read form of the COMPOUND value to be made (see Chapter 2 for details on read forms).</P>
</FONT><B><I><P>Return Values</P>
</B></I><FONT SIZE=2><P>The RuleWorks COMPOUND value that corresponds to the character string.</P>
</FONT><B><I><LI>See Also</LI></OL>
</OL>

</B></I><FONT SIZE=2><P>rul_string_to_atom</P>
<P>rul_string_to_symbol</P>
<LI></FONT><B><FONT FACE="Helvetica" SIZE=5><A NAME="string_to_symbol_page">rul_string_to_symbol</A></LI>
</B></FONT><FONT SIZE=2><P>Converts a character string into a RuleWorks SYMBOL atom.</P><OL>

<OL>

</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>atom_value</I> = <B>rul_string_to_symbol</B> (<I>char_string</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>atom_value</I>  &#9;opaque symbol atom  &#9;write</P>
<I><P>char_string</I>  &#9;string  &#9;&#9;&#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>rul_atom rul_string_to_symbol (char *string);</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>char_string</P>
</B><P>The character string to be converted to a RuleWorks atom.</P>
</FONT><B><I><P>Return Values</P>
</B></I><FONT SIZE=2><P>The RuleWorks SYMBOL atom made from the string; or RUL_C_INVALID_ATOM if the function was unable to create the atom for any reason.</P>
</FONT><B><I><P>See Also</P>
</B></I><FONT SIZE=2><P>rul_string_to_atom</P>
<P>rul_string_to_compound</P>
<P>rul_symbol_to_string</P>
</FONT><B><FONT FACE="Helvetica" SIZE=5><P><A NAME="symbol_to_string_page">rul_symbol_to_string</A></P>
</B></FONT><FONT SIZE=2><P>Converts a RuleWorks SYMBOL atom into a character string.</P>
</FONT><B><I><LI>Syntax</LI>
</B><FONT SIZE=2><P>num_chars</I> = <B>rul_symbol_to_string</B> (<I>char_string, string_size, atom_value</I>)</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Argument &#9;Data Type &#9;&#9;&#9;Access</P>
</B></FONT><I><FONT FACE="NewCenturySchlbk" SIZE=1><P>num_chars</I>  &#9;integer  &#9;&#9;&#9;write</P>
<I><P>char_string</I>  &#9;string  &#9;&#9;&#9;write</P>
<I><P>string_size</I>  &#9;integer  &#9;&#9;&#9;read</P>
<I><P>atom_value</I>  &#9;opaque symbol atom  &#9;read</P>
<P>&nbsp;</P>
</FONT><B><I><LI>C Binding</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>#include &lt;rul_rtl.h&gt; </P>
<P>long  rul_symbol_to_string (  <BR>
   char      *char_string <BR>
   long      string_size <BR>
   rul_atom  atom_value);</P>
</FONT><B><I><LI>Arguments</LI></OL>
</OL>
</OL>
</OL>

</I><FONT SIZE=2><P>char_string</P>
</B><P>The print form of the specified symbol, set by the function.</P>
<B>
<P>string_size</P>
</B><P>The maximum number of characters to return in <I>char_string</I>.</P>
<B>
<P>atom_value</P>
</B><P>The RuleWorks atom to be converted.</P>
</FONT><B><I><P>Return Values</P>
</B></I><FONT SIZE=2><P>The number of characters in the string made from the RuleWorks atom; or RUL_C_INVALID_LENGTH if an error occurs (for example, the buffer specified by <I>char_string</I> is too small for the print form).</P>

<B><P>Note:</B> that since RuleWorks atoms are at most RUL_C_MAX_SYMBOL_SIZE characters long, a buffer that is RUL_C_MAX_SYMBOL_SIZE + 1 characters long is always adequate.</P>
</FONT><B><I><P>See Also</P>
</B></I><FONT SIZE=2><P>rul_string_to_symbol  </P>
</FONT></BODY>
</HTML>
