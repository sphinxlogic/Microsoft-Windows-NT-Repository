<HTML>
<HEAD>
<TITLE>RuleWorks Reference Dictionary</TITLE>
</HEAD>
<BODY>

<FONT FACE="Arial" SIZE=6 color="navy"><P ALIGN="RIGHT">www.RuleWorks.co.uk</P></FONT>

<B><I><FONT FACE="HELVETICA" SIZE=6 color="RED"><P ALIGN="RIGHT">
RuleWorks Reference Dictionary</P></B></I></FONT>

<P>This chapter contains complete descriptions of all constructs in the RuleWorks language, including tables and complete descriptions.  The following tables, presented at the beginning of this chapter, summarize the RuleWorks language constructs by category:</P>

<UL>
<LI>Operators</LI>
<LI>Predicates and Relational Operators</LI>
<LI>Statements</LI>
<LI>Actions</LI>
<LI>Functions</LI>
<LI>Commands</LI>
<LI>Declarations</LI>
<LI>SQL Interface routines</LI></UL>

<P>Many of the constructs described in this Reference Dictionary can be specified with arguments.  When you specify argument values, separate the categories with any combination of spaces, tabs, and carriage returns.</P>

<P>The descriptions of all constructs are presented after the tables, alphabetically by name, with the   non-alphabetic operators and predicates at the beginning.  The descriptions include:</P>

<UL>
<LI>usage details</LI>
<LI>syntax</LI>
<LI>format</LI>
<LI>arguments</LI>
<LI>examples</LI></UL>


<P>Note:</B> you cannot use expressions that contain variables or function calls (except the COMPOUND function) as argument values for commands.</P>
<P>The RuleWorks run-time library routines are described in Appendix A.</P>


<B><FONT FACE="Helvetica" SIZE=4>Summary of Operators</FONT></b>
<P><B>Table 1 Summary of Operators - Arithmetic Operators</B></P>
<TABLE border=1>
<TR><TD><B>Operator</B></TD><TD><B>Description</B></TD></TR>
<TR><TD align=middle>+</TD><TD>Performs addition on numeric values</TD></TR>
<TR><TD align=middle>-</TD><TD>Performs subtraction on numeric values</TD></TR>
<TR><TD align=middle>*</TD><TD>Performs multiplication on numeric values</TD></TR>
<TR><TD align=middle>/</TD><TD>Performs division on numeric values</TD></TR>
<TR><TD align=middle>\</TD><TD>Performs the modulus operation on integer values</TD></TR>
</TABLE>

<P>&nbsp;</P>
<P><B>Table 2 Summary of Operators - Match Operators</B></P>
<TABLE border=1>
<TR><TD><B>Operator</B></TD><TD><B>Description</B></TD></TR>
<TR><TD align=middle>^</TD><TD>Specifies an attribute of an object</TD></TR>
<TR><TD align=middle>{ }</TD><TD>Specifies a conjunction (logical AND) of values</TD></TR>
<TR><TD align=middle>&lt;&lt; &gt;&gt;</TD><TD>Specifies a disjunction (logical OR) between values</TD></TR>
</TABLE>

<P>&nbsp;</P>
<P><B>Table 3 Summary of Operators - Logical Operators*</B></P>
<TABLE border=1>
<TR><TD><B>Operator</B></TD><TD><B>Description</B></TD></TR>
<TR><TD align=middle>AND</TD><TD>Performs a conjunction on two relational expressions</TD></TR>
<TR><TD align=middle>NOT</TD><TD>Negates a relational expression</TD></TR>
<TR><TD align=middle>OR</TD><TD>Performs an inclusive disjunction on two relational expressions</TD></TR>
</TABLE>

<B><P>Note:</B> Logical operators can be used only within the context of IF ... THEN ... ELSE ... and WHILE ... DO ... actions.</P>
<B><FONT FACE="Helvetica" SIZE=4>Summary of Predicates and Relational Operators</B></FONT>
<B><P>Scalar predicates</B> are those that are valid only for scalar attributes. The exceptions are identity and nonidentity (== and &lt;&gt;, which are also valid for comparing a compound attribute to a compound value. <B>Compound predicates</B> are those that are valid for compound attributes.</P>

<B><P>Table 4. Summary of Scalar Predicates and Relational Operators</P></B>
<TABLE border=1>
<TR><TD><B>Domain</B></TD><TD><B>Predicate</B></TD><TD><B>Value Domain</B></TD><TD><B>Test</B></TD></TR>
<TR><TD align=middle>ANY</TD><td align=middle>==</TD><td align=middle>ANY</TD><TD>Identity: Same type as and equal to<BR>
This predicate is optional in LHS attribute-value tests. It is required in RHS relational expressions.</TD></TR>
<TR><td align=middle>ANY</TD><td align=middle>&lt;&gt;</TD><td align=middle>ANY</TD><TD>Nonidentity; converse of identity</TD></TR>
<TR><td align=middle>ANY</TD><td align=middle>=</TD><td align=middle>ANY</TD><TD>Equality: Identical or equivalent numbers; identical symbols except for case; identical values of all other data types</TD></TR>
<TR><td align=middle>ANY</TD><td align=middle>-=</TD><td align=middle>ANY</TD><TD>Inequality; converse of equality</TD></TR>
<TR><td align=middle>ANY</TD><td align=middle>~=</TD><td align=middle>ANY</TD><TD>Similarity: Equal or phonetically similar symbols; equal or  approximately equal numbers; identical values of all other data types</TD></TR>
<TR><td align=middle>ANY</TD><td align=middle>-~=</TD><td align=middle>ANY</TD><TD>Dissimilarity; converse of similarity</TD></TR>
<TR><td align=middle>NUMBER</TD><td align=middle>&gt;</TD><td align=middle>NUMBER</TD><TD>Greater than</TD></TR>
<TR><td align=middle>SYMBOL</TD><td align=middle>&gt;</TD><td align=middle>SYMBOL</TD><TD>Lexicographically after</TD></TR>
<TR><td align=middle>ANY</TD><td align=middle>&gt;=</TD><td align=middle>ANY</TD><TD>Greater than or equal numbers; lexicographically after or equal symbols; identical values for all other data types</TD></TR>
<TR><td align=middle>NUMBER</TD><td align=middle>&lt;</TD><td align=middle>NUMBER</TD><TD>Less than</TD></TR>
<TR><td align=middle>SYMBOL</TD><td align=middle>&lt;</TD><td align=middle>SYMBOL</TD><TD>Lexicographically before</TD></TR>
<TR><td align=middle>ANY</TD><td align=middle>&lt;=</TD><td align=middle>ANY</TD><TD>Less than or equal numbers; lexicographically before or equal symbols; identical values for all other data types</TD></TR>
<TR><td align=middle>ANY</TD><td align=middle>&lt;=&gt;</TD><td align=middle>ANY</TD><TD>Same type</TD></TR>
<TR><td align=middle>ANY</TD><td align=middle>&lt;-&gt;</TD><td align=middle>ANY</TD><TD>Different type</TD></TR>
</TABLE>

<P>&nbsp;</P>

<P><B>Table 5. Summary of Compound Predicates and Relational Operators</B></P>
<TABLE BORDER=1>
<TR><TD><B>Domain</B></TD><TD><B>Predicate</B></TD><TD><B>Value Domain</B></TD><TD><B>Test</B></TD></TR>
<TR><TD>COMPOUND</TD><TD align=middle>[+]</TD><TD>ATOM</TD><TD>Containment; compound contains atom;</TD></TR>
<TR><TD>COMPOUND</TD><TD align=middle>[-]</TD><TD>ATOM</TD><TD>Non-containment; converse of containment</TD></TR>
<TR><TD>COMPOUND</TD><TD align=middle>[=]</TD><TD>INTEGER</TD><TD>Length equal</TD></TR>
<TR><TD>COMPOUND</TD><TD align=middle>[&lt;&gt;]</TD><TD>INTEGER</TD><TD>Length not equal</TD></TR>
<TR><TD>COMPOUND</TD><TD align=middle>[&gt;]</TD><TD>INTEGER</TD><TD>Length greater</TD></TR>
<TR><TD>COMPOUND</TD><TD align=middle>[&gt;=]</TD><TD>INTEGER</TD><TD>Length greater than or equal</TD></TR>
<TR><TD>COMPOUND</TD><TD align=middle>[&lt;]</TD><TD>INTEGER</TD><TD>Length less than</TD></TR>
<TR><TD>COMPOUND</TD><TD align=middle>[&lt;=]</TD><TD>INTEGER</TD><TD>Length less than or equal</TD></TR>
</TABLE>

<P>&nbsp;</P>
<P><B><FONT FACE="Helvetica" SIZE=4>Summary of Statements</B></FONT></P>

<P>Rules and catchers may be contained in either an entry block or a rule block, but ON- statements must be contained in an entry block.</P>
<P><B>Table 6. Summary of Statements</B></P>
<TABLE BORDER=1>
<TR><TD><B>Statement</B></TD><TD><B>Description</B></TD></TR>
<TR><TD>CATCH</TD><TD>Contains actions that are executed after a specified number of recognize-act cycles (see also the AFTER action)</TD></TR>
<TR><TD>ON-EMPTY</TD><TD>Contains actions that are executed when the conflict set is empty</TD></TR>
<TR><TD>ON-ENTRY</TD><TD>Contains actions that are executed when the entry block is called, before the first recognize-act cycle</TD></TR>
<TR><TD>ON-EVERY</TD><TD>Contains actions that are executed after the act phase of each recognize-act cycle except the last</TD></TR>
<TR><TD>ON-EXIT</TD><TD>Contains actions that are executed after the act phase of the last recognize-act cycle, except when a QUIT action is performed</TD></TR>
<TR><TD>RULE</TD><TD>Contains actions that are executed when left-hand-side conditions are met and the instantiation wins conflict resolution</TD></TR>
</TABLE>

<P>&nbsp;</P>

<B><FONT FACE="Helvetica" SIZE=4>Summary of Actions</B></FONT>
<P><B>Table 7.  Summary of Actions</B></P>
<TABLE BORDER=1>
<TR><TD><B>Action</B></TD><TD><B>Description</B></TD></TR>
<TR><TD>ADDSTATE</TD><TD>Adds the contents of a file produced by the SAVESTATE  action or command to the current state of working memory and the conflict set</TD></TR>
<TR><TD>AFTER</TD><TD>Specifies the number of recognize-act cycles that must be  executed before a specified catcher is executed</TD></TR>
<TR><TD>BIND</TD><TD>Binds a variable to a value</TD></TR>
<TR><TD>CLOSEFILE</TD><TD>Closes the open files associated with specified file  identifiers and dissociates the identifiers from the files</TD></TR>
<TR><TD>COPY</TD><TD>Copies a new copy of an existing object</TD></TR>
<TR><TD>DEFAULT</TD><TD>Sets the terminal or a file as the default input source for the ACCEPT-ATOM and ACCEPTLINE-COMPOUND functions, or the default output destination for the WRITE action or for trace output</TD></TR>
<TR><TD>FOR-EACH</TD><TD>Iterates over a compound value, executing the specified actions</TD></TR>
<TR><TD>IF ...<BR>THEN ...<BR>ELSE...</TD><TD>Provides a branch in the flow of control, as in procedural languages</TD></TR>
<TR><TD>MAKE</TD><TD>Creates an object</TD></TR>
<TR><TD>MODIFY</TD><TD>Changes one or more values in an existing object</TD></TR>
<TR><TD>OPENFILE</TD><TD>Opens a file and associates it with a file identifier</TD></TR>
<TR><TD>QUIT</TD><TD>Stops execution of the active entry block and passes control back to the operating system, optionally returning a value</TD></TR>
<TR><TD>REMOVE</TD><TD>Deletes one or more objects</TD></TR>
<TR><TD>REMOVE-EVERY</TD><TD>Deletes all the working memory objects that are instances of the specified class or its subclasses</TD></TR>
<TR><TD>RESTORESTATE</TD><TD>Clears and then restores working memory and the  conflict set to the state recorded in a file produced by the SAVESTATE action  or command</TD></TR>
<TR><TD>RETURN</TD><TD>Stops execution of the active entry block, executes the ON-EXIT actions (if any), and passes control back to the caller of the entry block. May also pass a return value.</TD></TR>
<TR><TD>SAVESTATE</TD><TD>Copies the state of working memory and the conflict set to a file</TD></TR>
<TR><TD>SPECIALIZE</TD><TD>Converts an instance of one class to an instance of a descendent class</TD></TR>
<TR><TD>TRACE</TD><TD>Displays or sets the run-time system's trace setting</TD></TR>
<TR><TD>WHILE ...<BR>DO ...</TD><TD>Provides a loop in the flow of control, as in procedural languages</TD></TR>
<TR><TD>WRITE</TD><TD>Sends output from a program to the terminal or a file</TD></TR>
</TABLE>

<P>&nbsp;</P>
<B><FONT FACE="Helvetica" SIZE=4>Summary of Functions</B></FONT>
<B><P>Table 8. Summary of Functions</B></P>
<TABLE BORDER=1>
<TR><TD><B>Function</B></TD><TD><B>OK on LHS?</B></TD><TD><B>Description</B></TD></TR>
<TR><TD>ACCEPT-ATOM</TD><TD>No</TD><TD>Reads an atom from the terminal or a file</TD></TR>
<TR><TD>ACCEPTLINE-COMPOUND</TD><TD>No</TD><TD>Reads a line of input from the terminal or file into a compound value</TD></TR>
<TR><TD>COMPOUND</TD><TD>Yes</TD><TD>Creates a new compound value from any number of arguments, scalar or compound</TD></TR>
<TR><TD>CONCAT</TD><TD>Yes</TD><TD>Concatenates the print forms of its arguments</TD></TR>
<TR><TD>CRLF</TD><TD>No</TD><TD>Causes the WRITE action to produce output on a  new line</TD></TR>
<TR><TD>EVERY</TD><TD>No</TD><TD>Returns a compound value that contains the IDs of all instances of the specified class</TD></TR>
<TR><TD>FLOAT</TD><TD>Yes</TD><TD>Converts a numeric value into a floating-point number</TD></TR>
<TR><TD>GENATOM</TD><TD>No</TD><TD>Returns a system-generated atom</TD></TR>
<TR><TD>GET</TD><TD>No</TD><TD>Given a variable bound to an object identifier and an attribute name, returns the value of that object's attribute</TD></TR>
<TR><TD>INTEGER</TD><TD>Yes</TD><TD>Converts a numeric value into an integer</TD></TR>
<TR><TD>IS-OPEN</TD><TD>No</TD><TD>Tests whether a file is open</TD></TR>
<TR><TD>LENGTH</TD><TD>Yes</TD><TD>Returns the number of elements in a compound value</TD></TR>
<TR><TD>MAX</TD><TD>Yes</TD><TD>Returns the largest of its arguments</TD></TR>
<TR><TD>MIN</TD><TD>Yes</TD><TD>Returns the smallest of its arguments</TD></TR>
<TR><TD>NTH</TD><TD>Yes</TD><TD>Returns the value of a specified element in a compound value</TD></TR>
<TR><TD>POSITION</TD><TD>Yes</TD><TD>Finds the first occurrence of an element in a compound value</TD></TR>
<TR><TD>RJUST</TD><TD>No</TD><TD>Causes the WRITE action to right justify output in a field of specified width</TD></TR>
<TR><TD>SUBCOMPOUND</TD><TD>Yes</TD><TD>Returns a subrange of a compound value</TD></TR>
<TR><TD>SUBSYMBOL</TD><TD>Yes</TD><TD>Returns a fragment of a symbolic value</TD></TR>
<TR><TD>SYMBOL</TD><TD>Yes</TD><TD>Converts any atom into a symbol</TD></TR>
<TR><TD>TABTO</TD><TD>No</TD><TD>Causes the WRITE action to put output in a specified column</TD></TR>
</TABLE>

<P>&nbsp;</P>

<B><FONT FACE="Helvetica" SIZE=4>Summary of Commands</B></FONT>
<P><B>Table 9. Summary of Commands</B></P>
<TABLE BORDER=1>
<TR><TD><B>Command</B></TD><TD><B>Description</B></TD></TR>
<TR><TD>@</TD><TD>Opens a file containing RuleWorks commands and executes the  commands.  </TD></TR>
<TR><TD>ADDSTATE </TD><TD>Adds the contents of a file produced by the SAVESTATE  action or command to the current state of working memory. </TD></TR>
<TR><TD>AFTER</TD><TD>Specifies the number of recognize-act cycles that must be executed before a specified catcher is executed. </TD></TR>
<TR><TD>CLOSEFILE</TD><TD>Closes the open files associated with specified file  identifiers and dissociates the identifiers from the files.  </TD></TR>
<TR><TD>COPY</TD><TD>Makes a new copy of an existing object.  </TD></TR>
<TR><TD>CS</TD><TD>Displays the current contents of the conflict set.   </TD></TR>
<TR><TD>DEFAULT</TD><TD>Sets the terminal or a file as the default input source for the ACCEPT-ATOM  and ACCEPTLINE-COMPOUND functions, or the default output destination for  the WRITE action or trace output.  </TD></TR>
<TR><TD>DISABLE </TD><TD>Disables the WMHISTORY command and the display of block names.  </TD></TR>
<TR><TD> EBREAK</TD><TD>Displays entry blocks that have breakpoints set, sets breakpoints for entry blocks, or deletes breakpoints from entry blocks.  </TD></TR>
<TR><TD> ENABLE</TD><TD>Enables the WMHISTORY command and the display of block names.  </TD></TR>
<TR><TD> EXIT</TD><TD>Synonym for QUIT command </TD></TR>
<TR><TD> MAKE</TD><TD>Creates a working-memory object.  </TD></TR>
<TR><TD> MATCHES</TD><TD>Displays the identifiers and time-tags of objects that  match condition elements in a specified rule.  </TD></TR>
<TR><TD> MODIFY</TD><TD>Changes one or more values in an existing working-memory object.  </TD></TR>
<TR><TD> NEXT</TD><TD>Displays the instantiation the run-time system will select  from the conflict set for the act phase of the next recognize-act cycle.   </TD></TR>
<TR><TD> OPENFILE</TD><TD>Opens a file and associates it with a file identifier.  </TD></TR>
<TR><TD> PPCLASS</TD><TD>Displays the ancestors of an object class.  </TD></TR>
<TR><TD> PPWM</TD><TD>Displays working-memory objects that match a specified pattern.   </TD></TR>
<TR><TD> QUIT</TD><TD>Stops execution and returns control to the operating system; optionally returns an integer value.  </TD></TR>
<TR><TD> RBREAK</TD><TD>Displays rules that have breakpoints set, sets breakpoints for rules, or deletes breakpoints from rules.  </TD></TR>
<TR><TD> REMOVE</TD><TD>Deletes objects from working memory.  </TD></TR>
<TR><TD> REMOVE-EVERY</TD><TD>Deletes all working-memory objects that are instances of a specified class or subclass.</TD></TR>
<TR><TD>RESTORESTATE </TD><TD>Clears working memory and the conflict set, then loads them from a file produced by the SAVESTATE action or command.  </TD></TR>
<TR><TD> RETURN</TD><TD>Passes control back to the caller of the entry block; optionally returns a value.  </TD></TR>
<TR><TD> RUN</TD><TD>Executes recognize-act cycles.  </TD></TR>
<TR><TD> SAVESTATE</TD><TD>Copies the state of working memory and the conflict set to a file.  </TD></TR>
<TR><TD> SPECIALIZE</TD><TD>Changes a working-memory object from an instance of one class to an instance of a parent class.  </TD></TR>
<TR><TD> TRACE</TD><TD>Displays or sets the amount of debugging information displayed by the run-time system.   </TD></TR>
<TR><TD> WBREAK</TD><TD>Displays objects that have breakpoints set, sets breakpoints for objects, or deletes breakpoints from objects.  </TD></TR>
<TR><TD> WM</TD><TD>Displays working-memory objects.   </TD></TR>
<TR><TD> WMHISTORY</TD><TD>Displays the revision history of an object.   </TD></TR>
</TABLE>

<P>&nbsp;</P>

<B><FONT FACE="Helvetica" SIZE=4>Summary of Declarations</B></FONT>
<B><P>Table 10. Summary of Declarations</B></P>
<TABLE BORDER=1>
<TR><TD><B>Declaration</B></TD><TD><B>Description</B></TD></TR>
<TR><TD>DECLARATION-BLOCK </TD><TD>Begins a set of shareable object class and external routine declarations  </TD></TR>
<TR><TD>END-BLOCK</TD><TD>Ends an entry, declaration, or rule block </TD></TR>
<TR><TD>END-GROUP</TD><TD>Ends a rule group </TD></TR>
<TR><TD>ENTRY-BLOCK</TD><TD>Begins a callable RuleWorks routine </TD></TR>
<TR><TD>EXTERNAL-ROUTINE</TD><TD>Declares a routine written in a language other than RuleWorks, or another RuleWorks entry block  </TD></TR>
<TR><TD>OBJECT-CLASS </TD><TD>Defines a class name and its list of attribute names  </TD></TR>
<TR><TD>RULE-BLOCK </TD><TD>Begins a set of shareable rules and catchers </TD></TR>
<TR><TD>RULE-GROUP</TD><TD>Begins a named set of rules and catchers </TD></TR>
</TABLE>

<P>&nbsp;</P>
<B><FONT FACE="Helvetica" SIZE=4>Summary of SQL Actions</B></FONT>
<B><P>Table 11. Summary of SQL Actions</B></P>
<TABLE BORDER=1>
<TR><TD><B>Action</B></TD><TD><B>Description</B></TD></TR>
<TR><TD>SQL-ATTACH  </TD><TD>Specifies the database that is to be accessed by the other RuleWorks SQL actions.  </TD></TR>
<TR><TD>SQL-COMMIT  </TD><TD>Completes the current SQL transaction and makes permanent any changes made during the transaction.  </TD></TR>
<TR><TD>SQL-DELETE  </TD><TD>Deletes specified records from the database.  </TD></TR>
<TR><TD>SQL-DETACH  </TD><TD>Commits any outstanding transaction and detaches from the database.  </TD></TR>
<TR><TD>SQL-FETCH-EACH  </TD><TD>Binds field values to RuleWorks variables and executes RuleWorks actions that can use those variables.  </TD></TR>
<TR><TD>SQL-FETCH-AS-OBJECT  </TD><TD>Makes objects from database records.  </TD></TR>
<TR><TD>SQL-INSERT  </TD><TD>Stores new records in the database.  </TD></TR>
<TR><TD>SQL-INSERT-FROM-OBJECT  </TD><TD>Stores the contents of an object in a new database record.  </TD></TR>
<TR><TD>SQL-ROLLBACK  </TD><TD>Completes the current SQL transaction and undoes any changes made during the transaction.  </TD></TR>
<TR><TD>SQL-START  </TD><TD>Starts an SQL transaction and sets transaction options.  </TD></TR>
<TR><TD>SQL-UPDATE  </TD><TD>Modifies existing database records.  </TD></TR>
<TR><TD>SQL-UPDATE-FROM-OBJECT </TD><TD>Modifies existing database records, using the contents of an object.  </TD></TR>
</TABLE>

<P>&nbsp;</P>
<B><FONT FACE="Helvetica" SIZE=5><P>Operator Descriptions</P></B></FONT>
<P>This section contains a description of the RuleWorks operators, in alphabetical order.</P>

<P>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>+ (Addition)</B></FONT>
<P>Performs arithmetic addition on numeric values.</P>
<UL>
<B><I><LI>Format</LI</I></B>
<P><I>numeric-expression</I> <B>+</B> <I>numeric-expression</I></P>
</B></I>
<B><LI>Operands</LI></B>
<P><B>numeric-expression</B></P>
<P>The numeric expressions to be added. These may be numeric constants, arithmetic expressions, variables bound to numeric values, or functions that return numeric values.</P>
<B><I><LI>Example</LI></B></I>
<P>The following action shows addition of a bound variable and a constant.</P>
<FONT FACE="Courier" SIZE=3><P>(modify &lt;the-counter&gt; ^count ( &lt;c&gt; + 1 ) ) </P>
</FONT>
</UL>


<P>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>- (Negation and Subtraction)</FONT></B>
<P><B><I>As a Match Operator</I></B></P>
<P>Negates a condition element (see Chapter 3 for a discussion of negative CEs).</P>
<UL>
<B><I><LI>Format</LI</I></B>
<P><B>-</B> <I>condition-element</P></I>
</I>
<B><LI>Operand</LI></B>
<P><B>condition-element</B></P>
<P>The CE that is to be negated.</P>
</UL>
<B><I>As an Arithmetic Operator</B></I>
<P>Performs arithmetic subtraction on numeric values.</P>
<UL>
<B><I><LI>Format</LI></B></I>
<B><P>-</B> <I>numeric-expression</P>
<P>numeric-expression</I> <B>-</B> <I>numeric-expression</P></I>
<B><LI>Operands</LI>
<P>numeric-expression</P>
</B><P>The numeric expressions to be subtracted. These arguments may be numeric constants, arithmetic expressions, variables bound to numeric values, or functions that return numeric values.</P>
<B><I><LI>Example</LI></B></I>

<P>The following two CEs test for the existence of one and only one object of class MEMORY:</P>

<FONT FACE="Courier" SIZE=3><P>(memory ^$ID &lt;the-mem&gt;)</P>
<P>-(memory ^$ID &lt;&gt; &lt;the-mem&gt;)</P>
</FONT>

<P>The following action shows subtraction of a bound variable and a constant:</P>

<FONT FACE="Courier" SIZE=2><P>(write (crlf) |Read| ( &lt;c&gt; - 1 ) |items from input.| (crlf) ) </P></FONT>
</ul>

<P>&nbsp;</P>

<B><FONT FACE="Helvetica" SIZE=4>* (Multiplication)</B></FONT>
<P>Performs arithmetic multiplication on numeric values.</P>
<ul>
<B><I><LI>Format</LI></B>
<P>numeric-expression</I> <B>*</B> <I>numeric-expression</P>
<B><LI>Operands</LI>
</I><P>numeric-expression</P>
</B><P>The numeric expressions to be multiplied. These may be numeric constants, arithmetic expressions, variables bound to numeric values, or functions that return numeric values.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>If the KIWI.RUL program calculates sales tax, it can use the following action:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(modify &lt;the-total&gt; ^cost (&lt;cost&gt; + (&lt;cost&gt; * &lt;tax&gt;))) </P>
</FONT>
</ul>

<P>&nbsp;</P>
<B><FONT FACE="Helvetica" SIZE=4>/ (Division)
</B></FONT>
<P>Performs arithmetic division on numeric values.</P>
<ul>
<B><I><LI>Format</LI>
</B><FONT SIZE=2><P>numeric-expression</I> <B>/</B> <I>numeric-expression</P>
</FONT><B><LI>Operands</LI>
</I><FONT SIZE=2><P>numeric-expression</P>
</B><P>The numeric expressions to be divided. These may be numeric constants, arithmetic expressions, variables bound to numeric values, or functions that return numeric values.</P>
<P>The second operand must not evaluate to zero, or a warning is generated and the result is zero. The result is an integer only when both operands are integers.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following  action converts degrees Fahrenheit to degrees Celsius:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(bind &lt;degrees-c&gt; ((&lt;degrees-f&gt; - 32) * 5 / 9))</P>
</FONT><FONT SIZE=2><P>Note that the entire arithmetic expression must be enclosed in parentheses.  </P>
</FONT>

</ul>

<P>&nbsp;</P>
<B><FONT FACE="Helvetica" SIZE=4>\ (Modulus)
</B></FONT><FONT SIZE=2><P>Performs the arithmetic modulus operation on integer values.</P>


</FONT>
<ul><B><I><LI>Format</LI>
</B><FONT SIZE=2><P>integer-expression</I> <B>\</B> <I>integer-expression</P>
</I></FONT><B><LI>Operands</LI>
<FONT SIZE=2><P>integer-expression</P>
</B><P>The dividend and divisor for the modulus operation. These may be integers, arithmetic expressions that evaluate to integers, variables bound to integers, or functions that return integers.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following rule uses both division and modules on integers:</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(rule find-dozens</P>
<P>     (start ^$ID &lt;start&gt;)</P>
<P> --&gt;</P>
<P>     (write (crlf) |Enter an integer:  | )</P>
<P>     (bind &lt;eggs&gt; (accept-atom)</P>
<P>     (write (crlf) |There are| (&lt;eggs&gt; / 12) |dozen in|&lt;eggs&gt;); division</P>
<P>     (write (crlf) |  and there are| (&lt;eggs&gt; 12) |left over|)  ; modulus</P>
<P>      (modify &lt;start&gt;))</P>
</FONT><FONT FACE="Times" SIZE=3>
</FONT><FONT SIZE=2><P>This example produces the following output:</P>
</FONT><FONT FACE="Courier" SIZE=1><P>&#9;Enter an integer: </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">13</P>
</B></FONT><FONT FACE="Courier" SIZE=1><P>&#9;There are 1 dozen in 13</P>
<P>   and there are 1 left over</P>
<P>&#9;Enter an integer: </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">39</P>
</B></FONT><FONT FACE="Courier" SIZE=1><P>&#9;There are 3 dozen in 39</P>
<P>   and there are 3 left over</P>
<P>&#9;Enter an integer:</P>
</FONT>
</ul>

<P>&nbsp;</P>
<B><FONT FACE="Helvetica" SIZE=4>^ (Attribute)
</B></FONT><FONT SIZE=2><P>Specifies an attribute of an object. You must define all attributes in an OBJECT-CLASS declaration.  For more information about attributes, see Chapter 2.</P>


</FONT>
<ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>^</B><I>attribute-name</P>
</FONT><B><LI>Argument</LI>
</I><FONT SIZE=2><P>attribute-name</P>
</B><P>The name of a declared attribute.</P>

<P>In condition elements on the LHS, this argument must be a symbolic atom.  In actions on the RHS, this argument can be a symbol or  a variable that is bound to a declared attribute name.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following OBJECT-CLASS declaration defines the attribute ^ITEM for the class        INPUT-THING:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(OBJECT-CLASS input-thing</P>
<P>          ^item)</P>
</FONT><FONT SIZE=2><P>The following CE matches objects of class INPUT-THING whose ^ITEM attribute has the value HOME-KIWI. It also uses the built-in attribute ^$ID to bind an object variable:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(input-thing ^item home-kiwi ^$ID &lt;my-input-thing&gt;) </P>
</FONT><FONT FACE="Courier"><P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=3><P> </P>
</FONT>
</ul>

<P>&nbsp;</P><B><FONT FACE="Helvetica" SIZE=4>== (Identity)
</B></FONT><FONT SIZE=2><P>Produces a match, or evaluates to true, when both its operands have the same type and the same value.</P>

<P>Two compound values are identical if they contain the same values in the same order.</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>As a Match Predicate
</B></FONT><FONT SIZE=2><P>In an attribute-value test on the LHS, the identity predicate is optional.</P>

<P>If the value following the identity predicate is an unbound variable, that variable is bound to the value of the specified attribute. The identity and length-equal ([=]) predicates are the only predicates that can precede the first occurrence of a variable, because they are the only ones that can either bind a variable or compare its value.</P>
</FONT>
<ul>
<B><FONT FACE="Helvetica" SIZE=4><LI>Format</LI>
</B></FONT><FONT SIZE=2><P>^attribute= = value-expression</P>
<P>^attribute value-expression</P>
<P>&nbsp;</P>
</FONT>
</ul>
<B><FONT FACE="Helvetica" SIZE=4>As a Relational Operator
</B></FONT><FONT SIZE=2><P>In a relational expression on the RHS, the identity operator is required. There is no default or implied operator inside relational expressions.</P>
</FONT>
<ul><B><FONT FACE="Helvetica" SIZE=4><LI>Format</LI>
</B></FONT><FONT SIZE=2><P>Value-expression = = value-expression</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4><LI>operands</LI>
</FONT><FONT SIZE=2><P>^attribute</P>
</B><P>An attribute of a WMO whose value is to be tested</P>
<B>
<P>value-expression</P>
</B><P>Any RuleWorks expression, whose value is to be tested</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4><LI>Examples</LI>
</B></FONT><FONT SIZE=2><P>The following CE uses the implied identity predicate:</P>
<P>(active-context ^name verify-configuration)</P>

<P>The relational expression below, of necessity, uses the explicit identity predicate:</P>
<P>(if ((is-open infile) = = nil)</P>
<P>     then (openfile infile orders.dat in))</P>

<P>&nbsp;</P>
</ul>
<B><FONT FACE="Helvetica" SIZE=4>&lt;&gt; (Nonidentity)
</B></FONT><FONT SIZE=2><P>Produces a match when the identity predicate (see previous fails to match; evaluates to true when the identity operator evaluates to false.</P>


</FONT>
<ul><B><I><LI>Example</LI>




</B></I><FONT SIZE=2><P>The following two Ces test for the existence of one and only one object of class MEMORY:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(memory ^$ID &lt;the-mem&gt;)</P>
<p>-(memory ^$ID &lt;&gt; &lt;the-mem&gt;)</p>

</FONT>
</ul>


<P>&nbsp;</P>
<B><FONT FACE="Helvetica" SIZE=4>= (Equality)
</B></FONT><FONT SIZE=2><P>Produces a match, or evaluates to true, when its operands are identical or have equal values.</P>

<P>The equality predicate and operator performs automatic type conversion between INTEGER and FLOAT values. For example, 2 is equal to 2.0, but 2 is not identical to 2.0.</P>

<P>The equality predicate and operator ignores case when comparing SYMBOL values. For example, </FONT><FONT FACE="Courier" SIZE=2>|</FONT><FONT SIZE=2>cat </FONT><FONT FACE="Courier" SIZE=2>|</FONT><FONT SIZE=2> is equal to CAT, but  </FONT><FONT FACE="Courier" SIZE=2>|</FONT><FONT SIZE=2>cat </FONT><FONT FACE="Courier" SIZE=2>|</FONT><FONT SIZE=2> is not identical to CAT.</P>

<P>You cannot use the equality predicate with the binding instance of a variable. You must use the identity predicate.</P>


</FONT>
<ul>
<B><I><LI>Format</LI>
</I><FONT SIZE=2><P>^</B><I>attribute</I> <B>=</B> <I>value-expression</P>
</FONT><B><LI>Operands</LI>
</I><FONT SIZE=2><P>^attribute</P>
</B><P>An attribute of a WMO whose value is to be tested</P>
<B>
<P>value-expression</P>
</B><P>Any RuleWorks expression, whose value is to be tested</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following CE uses the less restrictive equality predicate:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(active-context ^name = verify-configuration) </P>
</FONT>
</ul>

<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>-= (Inequality)
</B></FONT><FONT SIZE=2><P>Produces a match when the equality predicate (see previous page) fails to match; evaluates to true when the equality operator evaluates to false.</P>


</FONT><ul><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>This attribute-value test is the converse of the previous example:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(active-context ^name -= verify-configuration)</P>
</FONT>
</ul>

<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>~= (Similarity)



</B></FONT><FONT SIZE=2><P>Produces a match, or evaluates to true, when its arguments are either both numbers or the same type,  and are similar to each other.  Similarity is defined as follows:</P>

<UL>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=2><LI>Two numbers are considered to be similar when the difference between their values is less than or equal to 1 percent of the larger absolute value. Like the equality predicate, the similarity predicate automatically converts between the INTEGER and FLOAT data types.</LI>
<LI>Two symbols are similar when one of the following is true:</LI>

<UL>
<LI>they are identical or equal (equality is independent of case)</LI>
<LI>Both symbols are at least three characters long, and adding a single character to one symbol makes it equal to the other</LI>
<LI>Both symbols are at least three characters long, and transposing two characters in one symbol makes it equal to the other</LI>
<LI>they have identical SOUNDEX values</LI>

<P>SOUNDEX values are calculated according to an algorithm similar to that published in <I>The Art of Computer Programming</I>, Volume 3, pages 391-392, by Donald Knuth. The English-language rules are as follows:</P>

<P>1.&#9;Find the first alphabetic character in the symbol, and convert it to uppercase.</P>
<P>2.&#9;Convert all non-alphabetic characters to a code of 0.</P>
<P>3.&#9;Ignoring case, replace each consonant (after the first alphabetic character), except H's and W's, with its corresponding consonant group code number:</P>
<P>B, F, P, V  &#9;&#9;&#9;1</P>
<P>C, G, J, K, Q, S, X, Z  &#9;2</P>
<P>D, T  &#9;&#9;&#9;3</P>
<P>L  &#9;&#9;&#9;&#9;4</P>
<P>M, N  &#9;&#9;&#9;5</P>
<P>R  &#9;&#9;&#9;&#9;6</P>

<P>4.&#9;If two or more adjacent characters contain the same code, remove all but the first.</P>
<P>5.&#9;Ignoring case and leaving the first alphabetic character, remove all the vowels (including Y), H's, and W's, and all remaining zeroes and spaces.</P>




</ul></ul>

<UL>
<LI>For all other data types, similarity is the same as identity. For example, assuming &lt;the-id&gt; is already bound, the two attribute-value tests shown below match under the same circumstances:</LI>




</FONT><FONT FACE="Courier" SIZE=3><P>^$ID == &lt;the-id&gt;</P>
<P>^$ID ~= &lt;the-id&gt;</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=2><P>The identity predicate is more efficient.</P>



</FONT><FONT SIZE=2><P>You cannot use the similarity predicate with the binding instance of a variable.</P>





</FONT>

<B><I><LI>Format</LI>
</I><FONT SIZE=2><P>^</B><I>attribute</I> <B>~=</B> <I>value-expression</P>
<P>value-expression</I> <B>~=</B> <I>value-expression</P>
</FONT><B>
<LI>Operands</LI>
</I><FONT SIZE=2><P>^attribute</P>
</B><P>An attribute of a WMO whose value is to be tested.</P>
<B>
<P>value-expression</P>
</B><P>Any RuleWorks expression, whose value is to be tested.</P>
</FONT><B><I><LI>Examples</LI>




</B></I><FONT SIZE=2><P><!a NAME="_Toc393858199">The first table shows the results of several similarity test on numbers:</P>


</FONT><B><FONT FACE="Arial" SIZE=2><P>Table 12. Similarity Testing</P>
<table border=1>
<tr><td><b>First Value</b></td><td><b>Second Value</b></td><td><b>Similar?</b></td></tr>
<tr><td>4.0</td><td>4</td><td>Yes</td></tr>
<tr><td>4.5</td><td>4</td><td>No</td></tr>
<tr><td>9.9</td><td>10</td><td>Yes</td></tr>
<tr><td>-9.9</td><td>-10</td><td>Yes</td></tr>
</table>

<FONT SIZE=2><P>The next table shows the SOUNDEX codes of several symbols. Note that the last three codes match exactly:</P>


</FONT>
<B><FONT FACE="Arial" SIZE=2><P>Table 13. SOUNDEX Codes and Symbols</P></b></font>
<table border=1>
<tr><td><b>Symbol</b></td><td><b>SOUNDEX Code</b></td></tr>
<tr><td>Tracy</td><td>T62</td></tr>
<tr><td>Larry</td><td>L6</td></tr>
<tr><td>St. Laurent</td><td>S34653</td></tr>
<tr><td>Steven</td><td>S315</td></tr>
<tr><td>Stephen</td><td>S315</td></tr>
<tr><td>Stefano</td><td>S315</td></tr>
</table>
</ul>

<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>
-~= (Dissimilarity)
</b></B></FONT><FONT SIZE=2><P>Produces a match, or evaluates to true, when the similarity predicate (see previous  fails to match, or evaluates to false.</P>


</FONT>
<ul>
<B><I><LI>Examples</LI>

</B></I><FONT SIZE=2><P>The table below shows the results of several dissimilarity tests:</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P><!a NAME="_Toc393858201">Table 14. Dissimilarity Testing</P></b>
<table border=1>
<tr><td><b>First Value</b></td><td><b>Second Value</b></td><td><b>Dissimilar?</b></td></tr>
<tr><td>4.0</td><td>4</td><td>No</td></tr>
<tr><td>4.5</td><td>4</td><td>Yes</td></tr>
<tr><td>9.9</td><td>10</td><td>No</td></tr>
<tr><td>-9.9</td><td>-10</td><td>No</td></tr>
</table>

</ul>
<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>
&gt; (Greater-than)
</B></FONT><FONT SIZE=2><P>Produces a match, or evaluates to true, when its first operand is greater than its second. The operands must be either both numbers or both symbols.</P>

<P>See appendix E for information on the collating sequences used by RuleWorks to compare symbolic values.</P>


</FONT>
<ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>^</B><I>attribute</I> <B>&gt;</B>  <I>value-expression</P>
<P>value-expression</I> <B>&gt;</B> <I>value-expression</P>
</FONT><B><LI>Operands</LI>
</I><FONT SIZE=2><P>^attribute</P>
</B><P>An attribute of a WMO whose value is to be tested.</P>

<B><P>value-expression</P>
</B><P>Any RuleWorks expression that evaluates to a symbol or a number.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following table shows the results of several greater-than tests</P>
</FONT>
<B><FONT FACE="Arial" SIZE=2><P><!a NAME="_Toc393858202">Table 15. Greater-than Testing</P></b>
<table border=1>
<tr><td><b>First Value</b></td> <td></td><td><b>Second Value</b></td><td><b>Match or True?</b></td></tr>
<tr><td>4.0</td><td>&gt;</td><td>3</td><td>Yes</td></tr>
<tr><td>4</td><td>&gt;</td><td>5.0</td><td>No</td></tr>
<tr><td>aardwolf</td><td>&gt;</td><td>aardvark</td><td>Yes</td></tr>
<tr><td>| greater-than |</td><td>&gt;</td><td>greater-than</td><td>No</td></tr>
</table>
</ul>

<p>&nbsp;</p>

<B><FONT FACE="Helvetica" SIZE=4>
&gt;= (Greater-than-or-equal)
</B></FONT><FONT SIZE=2><P>Produces a match, or evaluates to true, when its first operand is greater than or equal to its second. The operands must be either both numbers or both symbols.</P>

<P>See Appendix E for information on the collating sequences used by RuleWorks to compare symbolic values.</P>


</FONT><ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>^</B><I>attribute</I> <B>&gt;=</B>  <I>value-expression</P>
<P>value-expression</I> <B>&gt;=</B> <I>value-expression</P>
</FONT><B><LI>Operands</LI>
</I><FONT SIZE=2><P>^attribute</P>
</B><P>An attribute of a WMO whose value is to be tested.</P>
<B>
<P>value-expression</P>
</B><P>Any RuleWorks expression that evaluates to a symbol or a number.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following table shows the results of several greater-than-or-equal tests:</P>
</FONT>
<B><FONT FACE="Arial" SIZE=2><P><!a NAME="_Toc393858203">Table 16. Greater-than-or-Equal Testing</P></b>
<table border=1>
<tr><td><b>First Value</b></td> <td></td><td><b>Second Value</b></td><td><b>Match or True?</b></td></tr>
<tr><td>5.0</td><td>&gt;=</td><td>5</td><td>Yes</td></tr>
<tr><td>6</td><td>&gt;=</td><td>7.0</td><td>No</td></tr>
<tr><td>aardvark</td><td>&gt;=</td><td>Aardvark</td><td>Yes</td></tr>
<tr><td>| greater-than |</td><td>&gt;=</td><td>greater-than</td><td>Yes</td></tr>
</table>

<FONT SIZE=2><P>The aardvarks match because they are equal, which is a case insensitive comparison, not because the first value is greater than the second.  </P>
</FONT></ul>

<B><FONT FACE="Helvetica" SIZE=4>
&lt; (Less-than)
</B></FONT><FONT SIZE=2><P>Produces a match, or evaluates to true, when its first operand is less than its second. The operands must be either both numbers or both symbols.</P>

<P>See Appendix E for more information on the collating sequences used by RuleWorks to compare symbolic values.</P>


</FONT>
<ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>^</B><I>attribute</I> <B>&lt;</B>  <I>value-expression</P>
<P>value-expression</I> <B>&lt;</B>  <I>value-expression</P>
</FONT><B><LI>Operands</LI>
</I><FONT SIZE=2><P>^attribute</P>
</B><P>An attribute of a WMO whose value is to be tested.</P>
<B>
<P>value-expression</P>
</B><P>Any RuleWorks expression that evaluates to a symbol or a number.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following table shows the results of several less-than tests:</P>
</FONT>
<B><p>Table 17. Less-than Testing</P></b>
<table border=1>
<tr><td><b>First Value</b></td><td></td><td><b>Second Value</b></td><td><b>Match or True?</b></td></tr>
<tr><td>2.0</td><td>&lt;</td><td>3</td><td>Yes</td></tr>
<tr><td>5</td><td>&lt;</td><td>6.0</td><td>Yes</td></tr>
<tr><td>zygosis</td><td>&lt;</td><td>zygote</td><td>Yes</td></tr>
<tr><td>zoology</td><td>&lt;</td><td>Zoology</td><td>No</td></tr>
</table>
</ul>

<P>&nbsp;</P>
<B><FONT FACE="Helvetica" size=4>
&lt;= (Less-than-or-equal)
</B></FONT>
<FONT SIZE=2><P>Produces a match or evaluates to true, when its first operand is less than or equal to its second. The operands must be either both numbers or both symbols.</P>
<P> <!a NAME="_Toc373810087"></P>
<P>See Appendix E for information on the collating sequences used by RuleWorks to compare symbolic values.</P>


</FONT>
<ul><B><I><LI>Format</LI>
</B><FONT SIZE=2><P>^attribute &lt;= value-expression</P>
<P>value-expression &lt;= value-expression</P>
<P>&nbsp;</P>
</FONT><B><LI>Operands</LI>
</I><FONT SIZE=2><P>^attribute</P>
</B><P>An attribute of a WMO whose value is to be tested.</P>
<I>
</I><B><P>value-expression</P>
</B><P>Any RuleWorks expression that evaluates to a symbol or a number.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Examples</LI>

</B></I><FONT SIZE=2><P>The following table shows the results of several less-than-or equal tests:</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P>Table 18 Less-than-or-equal Testing</P></b></font>

<table border=1>
<tr><td><b>First Value</b></td><td></td><td><b>Second Value</b></td><td><b>Match or True?</b></td></tr>
<tr><td>2.0</td><td>&lt;=</td><td>3</td><td>Yes</td></tr>
<tr><td>5</td><td>&lt;=</td><td>5.0</td><td>Yes</td></tr>
<tr><td>zygosis</td><td>&lt;=</td><td>zygote</td><td>Yes</td></tr>
<tr><td>zoology</td><td>&lt;=</td><td>Zoology</td><td>Yes</td></tr>
</table>

<FONT SIZE=2><P>The symbols match because they are equal, which is a case insensitive comparison, not because the first value is less than the second.</P>
</FONT>
</ul>
<p>&nbsp;</p>

<B><FONT FACE="Helvetica" SIZE=4>
&lt;=&gt;  (Same Type)
</B></FONT><FONT SIZE=2><P>Produces a match, or evaluates to true, when both its operands are the same type. The RuleWorks data types are INTEGER, FLOAT, SYMBOL, INSTANCE-ID, and OPAQUE.</P>

<P>For example, if you specify this predicate with a symbol or a variable bound to a symbol, a match is produced when the atom in the WMO is a symbol.</P>

<P>The same-type predicate can be applied to scalar values only.</P>


</FONT>
<ul><B><I><LI>Format</LI>
</B></I><FONT SIZE=2><P> (<B>^</B><I>attribute</I> <B>&lt;=&gt;</B>  <I>value-expression</I>) </P>
<P>(<I>value-expression</I> <B>&lt;=&gt;</B> <I>value-expression</I>)</P>
<P>An attribute of a WMO whose value is to be tested.</P>
</FONT><B><I><LI>Arguments(Operands)</LI>
</I><FONT SIZE=2><P>value-expression</P>
</B><P>Any RuleWorks expression, whose value is to be tested.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following CE matches an object of class INPUT-THING whose ^ITEM attribute has a symbolic value:</P>

<P> (input-thing ^item &lt;=&gt; symbol )</P>
<P>&nbsp;</P>
</FONT>
</ul>

<B><FONT FACE="Helvetica" SIZE=4>
&lt;-&gt; (Different-type)
</B></FONT><FONT SIZE=2><P>Produces a match when the same-type predicate (see previous page) fails to match; evaluates to true when the same-type operator evaluates to false.</P>

<P>This predicate can be applied to scalar values only.</P>


</FONT>
<ul><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>This CE is the converse of the previous example:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(input-thing ^item &lt;-&gt; symbol)</P>
</FONT>
</ul>
<p>&nbsp;</p>

<B><FONT FACE="Helvetica" SIZE=4>
[+] (Containment)
</B></FONT><FONT SIZE=2><P>Produces a match, or evaluates to true, when its scalar operand is an element of its compound operand. That is, you can test whether a compound contains a scalar value, or you can test whether a scalar value is contained in a compound.</P>

<P>By default, the containment predicate tests for identity; you can specify a different test with an optional scalar predicate. The scalar predicate must appear next to the scalar argument.</P>


</FONT><ul><B><I><LI>Format</LI>
</B><FONT SIZE=2><P>^compound-attr [+] [predicate] scalar-value</P>
<P>^scalar-attr [predicate] [+] compound-value</P>
<P>compound-value [+] [predicate] scalar-value</P>
<P>scalar-value [predicate] [+] compound-value</P>
</I><P>&nbsp;</P>
</FONT><B><I><LI>Operands</LI>
</I><FONT SIZE=2><P>^compound-attr</P>
</B><P>The compound attribute whose value is to be searched for a scalar value.</P>

<B><P>Predicate</P>
</B><P>A predicate that specifies the comparison between elements of the compound value and the scalar value. This argument is optional; if you do not specify a predicate, RuleWorks uses the default identity predicate.</P>

<P>You can use any scalar predicate except containment and non-containment (see Table 4)</P>

<B><P>scalar-value</P>
</B><P>The scalar value for which a compound attribute is to be searched.</P>

<B><P>^scalar-attr</P>
</B><P>The scalar attribute for whose value a compound is to be searched.</P>

<B><P>compound-value</P>
</B><P> The compound value which is to be searched for a scalar value</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Examples</LI>

</B></I><FONT SIZE=2><P>The following CE matches an object class BOX whose ^CARD-IN-SLOT attribute contains at least one MEMORY element:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(box ^card-in-slot &lt;cards&gt; [+] memory)</P>
</FONT><FONT SIZE=2>
<P>The condition shown below is true when MEMORY is contained by &lt;CARDS&gt;:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(memory [+] &lt;cards&gt;)</P>
</FONT><FONT SIZE=2>
<P>The following attribute-value test uses the similarity predicate in conjunction with the containment predicate:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>^list [+] ~= color</P>
</FONT><FONT SIZE=2><P>This test matches when the compound value of the ^LIST attribute contains an element similar to COLOR, such as COLOUR or COULEUR.</P>
<P>&nbsp;</P>
</FONT>
</ul>
<B><FONT FACE="Helvetica" SIZE=4>[-] (Non-containment)
</B></FONT><FONT SIZE=2>
<P>Produces a match when the containment predicate (see previous page) fails to match; evaluates to true when the containment operator evaluates to false.</P>
<P>&nbsp;</P>


</FONT><ul><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following two CEs match a WMO of class BOX whose ^CARD-IN-SLOT-OBJ-ID attribute does not contain the object whose ID is bound to &lt;THE-MEM&gt;:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(memory ^$ID &lt;the-mem&gt;)</P>
<P>(box ^card-in-slot-obj-id [-] &lt;the mem&gt;)</P>
</FONT>
</ul>

<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>
[=] (Length-equal)
</B></FONT><FONT SIZE=2><P>Produces a match, or evaluates to true, when the number of elements in its compound operand is identical to its numeric operand.</P>

<P>As with identity predicate, the length-equal predicate can be used with the first appearance of a variable. This binds the variable to the actual number of elements in the compound attribute.</P>
<P>&nbsp;</P>


</FONT><ul><B><I><LI>Format</LI>
</B><FONT SIZE=2><P>^compound-attr [=] integer-value</P>
<P>compound-value [=] integer-value</P>
<P>&nbsp;</P>
</FONT><B><LI>Operands</LI>
</I><FONT SIZE=2><P>^compound-attr</P>
</B><P>The compound attribute whose length is to be tested.</P>

<B><P>Integer-value</P>
</B><P>The integer value to which the length of a compound value is to be compared. This operand may be any expression that evaluates to an integer greater than or equal to zero.</P>

<B><P>Compound-value</P>
</B><P>The compound value whose length is to be tested. This operand may be any expression that evaluates to a compound value.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Examples</LI>

</B></I><FONT SIZE=2><P>The CE below matches an object of class BOX whose ^CARD-IN-SLOT attribute is empty:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(box ^card-in-slot [=] 0)</P>
</FONT><FONT SIZE=2><P>This CE shows the syntax for testing the compound and binding a variable:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(box ^card-in-slot {[=] 0 [=] &lt;cards&gt;})</P>
<I><P>&nbsp;</P>
</I></FONT>
</ul>

<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>
[&lt;&gt;] (Length-not-equal)
</B></FONT><FONT FACE="Times" SIZE=3><P>Produces a match when the length-equal predicate (see previous page) fails to match; evaluates  to true when the length-equal operator evaluates to false.</P>


</FONT>
<ul><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following CE matches an object of class BOX whose ^CARD-IN-SLOT attribute is not empty:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(box ^card-in-slot [&lt;&gt;] 0)</P>
</FONT>
</ul>

<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>
[&gt;] (Length-greater-than)
</B></FONT><FONT FACE="Times" SIZE=3><P>Produces a match, or evaluates to true, if the number of elements in its compound operand is greater than its integer operand.</P>


</FONT><ul><B><I><LI>Format</LI>
</B><FONT FACE="Times" SIZE=3><P>^compound-attr [&gt;] integer-value</P>
<P>compound-value [&gt;] integer-value</P>
</FONT><B><LI>Operands</LI>
</I><FONT SIZE=2><P>^compound-attr</P>
</B><P>The compound attribute whose length is to be tested.</P>

<B><P>Integer-value</P>
</B><P>The integer value to which the length of a compound value is to be compared. This operand may be any expression that evaluates to an integer greater than or equal to zero.</P>

<B><P>Compound-value</P>
</B><P>The compound value whose length is to be tested. This operand may be any expression that evaluates to compound value.</P>

<B><P>Example</P>
</B><P>The following CE matches an object of class BOX whose ^CARD-In-SLOT attribute has more than two elements:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(box ^card-in-slot [&gt;] 2)</P>
</FONT><FONT FACE="Times" SIZE=3><P>&nbsp;</P>
</FONT>
</ul>

<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>
<P>[&gt;=] (Length-greater-than-or-equal)</P>
</B></FONT><FONT FACE="Times" SIZE=3><P>Produces a match, or evaluates to true, if the number of elements in its compound operand is greater than or equal to its integer operand.</P>
</FONT>
<ul><B><I><LI>Format</LI>
</B><FONT FACE="Times" SIZE=3><P>^compound-attr [&gt;=] integer-value</P>
<P>compound-value [&gt;=] integer-value</P>
</FONT><B><LI>Operands</LI>

</I><FONT FACE="Times" SIZE=3><P>^compound-attr</P>
</B><P>The compound attribute whose length is to be tested.</P>
<B><P>Integer-value</P>
</B><P>The integer value to which the length is to be tested. This operand may be any expression that evaluates to an integer greater than or equal to zero.</P>
<B><P>Compound-value</P>
</B><P>The compound value whose length is to be tested. This operand may be any expression that evaluates to a compound value.</P>
</FONT><B><I><P>Example</P>
</B></I><FONT FACE="Times" SIZE=3><P>The following CE matches an object of class BOX whose ^CARD-IN-SLOT attribute has two or more elements:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(box ^card-in-slot [&gt;=] 2)</P>
</FONT>
</ul>

<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>
[&lt;] (Length-less-than)
</B></FONT><FONT SIZE=2><P>Produces a match, or evaluates to true, if the number of elements in its compound operand is less than its integer operand.</P>


</FONT><ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>^</B><I>compound-attr</I> <B>[&lt;]</B>  <I>integer-value</I>) </P>
<I><P>compound-value</I> <B>[&lt;]</B>  <I>integer-value</P>
</FONT><B><LI>Operands</LI>
</I><FONT SIZE=2><P>^compound-attr</P>
</B><P>The compound attribute whose length is to be tested.</P>
<B>
<P>integer-value</P>
</B><P>The integer value to which the length of a compound value is to be compared. This operand may be any expression that evaluates to an integer greater than or equal to zero.</P>
<B>
<P>compound-value</P>
</B><P>The compound value whose length is to be tested.  This operand may be any expression that evaluates to a compound value.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following CE matches an object of class BOX whose ^CARD-IN-SLOT attribute has fewer than two elements:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(box ^card-in-slot [&lt;] 2 )</P>
</FONT>
</ul>

<p>&nbsp;</p><B><FONT FACE="Helvetica" SIZE=4>
[&lt;=] (Length-less-than-or-equal)
</B></FONT><FONT SIZE=2><P>Produces a match, or evaluates to true, if the number of elements in its compound operand is less than or equal to its integer operand.</P>


</FONT><ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>^</B><I>compound-attr</I>  [<B>&lt;=] </B> <I>integer-value</I> </P>
<I><P>compound-value</I>  [<B>&lt;=</B>] <I>integer-value</P>
</FONT><B><LI>Operands</LI>
</I><FONT SIZE=2><P>^compound-attr</P>
</B><P>The compound attribute whose length is to be tested.</P>
<B>
<P>integer-value</P>
</B><P>The integer value to which the length of a compound value is to be  compared. This operand may be any expression that evaluates to an integer greater than or equal to zero.</P>
<B>
<P>compound-value</P>
</B><P>This operand may be any expression that evaluates to a compound value.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following CE matches an object of class BOX whose ^CARD-IN-SLOT attribute has two or fewer elements.</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(box ^card-in-slot [&lt;=] 2 ) </P>
</FONT><FONT FACE="Courier"><P>&nbsp;</P>
<P> </P>
</FONT>
</ul>


<P><B><FONT FACE="Helvetica" SIZE=4>{ } (Conjunction)
</B></FONT>
<P>Specifies a conjunction. A conjunction is similar to a logical AND. It is a left-hand-side pattern containing one or more conditional tests, all of which a single attribute in an object must satisfy.</P>

<P>For more information about conjunctions, see Chapter 3.</P>


<ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>{</B> <I>conditional-test</I> ... <B>}</P>
</FONT><I><LI>Operands</LI>
</I><FONT SIZE=2><P>conditional-test</P>
</B><P>One or more conditional tests that the value of an attribute in an object is to satisfy.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following CE matches teenagers by testing for age greater than or equal to 13 AND less than 20:</P>
</FONT><FONT FACE="Courier" SIZE=3><P> (person ^age { &gt;= 13 &lt; 20})</P>
</FONT><FONT SIZE=2>
<P>The next CE contains a conjunction of two tests on the length of the compound attribute ^CARD-IN-SLOT. The first binds the length to the variable &lt;LEN&gt;. The second tests that the length is less than 6:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(box ^$ID &lt;the-box&gt; ^card-in-slot &lt;{&gt; [=] &lt;len&gt; [&lt;] 6})</P>
</FONT><FONT SIZE=2>
<P>You can use a conjunction when you want to bind as well as test an attribute. For example:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(hardware-option ^in-slot { &lt;slot-num&gt; &lt;&gt; NIL}) </P>
</FONT><P> </P></ul>

<p>&nbsp;</p>

<B><FONT FACE="Helvetica" SIZE=4>&lt;&lt;&gt;&gt; (Disjunction)
</B></FONT>

<P>Specifies a disjunction of values, similar to a logical inclusive OR. An attribute that matches any one of the values satisfies the disjunction (see also Chapter 3).</P>


<ul>
<B><I><LI>Format</LI>
</B></I><FONT SIZE=2><P>&lt;&lt; value-expression&gt;&gt;</P>
</FONT><B><I><LI>Operands</LI>
</I><FONT SIZE=2><P>Value-expression</P>
</B><P>The value that an attribute value in an object is to match. This argument can be a constant, a bound variable, an arithmetic expression, or a function call. It must have the same structure as the attribute, either scalar or compound. You can specify one or more values.</P>

<P>A disjunction of values is implicitly preceded by the identity predicate (= =). You cannot use any other predicate with a disjunction of values.</P>
</FONT><B><I><LI>Examples</LI>

</B></I><FONT SIZE=2><P>The following CE contains a disjunction of values:</P>
</FONT><FONT FACE="Courier" SIZE=2><P>(input-thing ^item &lt;&lt; NIL EOF END-OF-FILE &gt;&gt;)</P>
<P>The next example shows the syntax for a compound attribute:</P>
<P>(object ^$id &lt;object-1&gt;</P>
<P>&#9;^ integer-attr &lt;I&gt; ^symbol-attr &lt;s&gt; ^compound-attr &lt;c&gt;)</P>
<P>(object ^$id {&lt;object-2&gt; &lt;&gt; &lt;object-1&gt;}</P>
<P>&#9;^compound-attr &lt;&lt; &lt;c&gt;</P>
<P>&#9;&#9;&#9;(compound a &lt;s&gt; c)</P>
<P>&#9;&#9;&#9;(subcompound &lt;c&gt; 1 ((length &lt;c&gt;) - &lt;I&gt;)) &gt;&gt;)</P>
</FONT>
</ul>

<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>
@ (At)
</B></FONT>
<P>Opens a file containing RuleWorks commands and executes the commands. The file must contain only RuleWorks commands. If the file cannot be opened, the run-time system displays the following message:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>&lt;FAC&gt;-W-CANTOPEN, @ - Unable to open file <I>filename</I> for reading</P>
</font>

<ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>@</B> <I>filespec</P>
</FONT><B><LI>Argument</LI>
</I><FONT SIZE=2><P>filespec</P>
</B><P>The file specification for a file containing RuleWorks commands to  be executed. The restrictions on file specifications vary according to operating system; see Section C.1 for details.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The first command illustrates a simple file specification:</P>
</FONT><FONT FACE="Courier" SIZE=2 COLOR="#0000ff"><P>RuleWorks&gt;  </FONT><B><FONT FACE="Courier" SIZE=2 COLOR="#800000">@ init-mem.wm</P>
</B></FONT><FONT SIZE=2><P>The command below shows a file specification that includes a pathname, and must be quoted:</P>
</FONT><FONT FACE="Courier" SIZE=2 COLOR="#0000ff"><P>RuleWorks&gt;  </FONT><B><FONT FACE="Courier" SIZE=2 COLOR="#800000">@ |C:%MEM.COM|</P>
</B></FONT><P> </P>

</ul>

<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>ACCEPT-ATOM
</B></FONT>
<P> Reads an atom from the keyboard or a file. Ignores values after a semicolon (;) until the end of the line.</P>

<P>By default, the ACCEPT-ATOM function reads input from the keyboard. If you want the function to read input from a file, call the function with the file identifier of an open input file, or change the default for input.</P>


<ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>ACCEPT-ATOM</B> <I>[ file-id ]</P>
</FONT><B><LI>Argument</LI>
</I><FONT SIZE=2><P>file-id</P>
</B><P>The file identifier of the file from which input is to be read. The file must have been opened and associated with the identifier in a previous OPENFILE action or command.</P>

<P>This argument is optional. If you do not specify a file identifier, input is read from the current default for the ACCEPT-ATOM function (set with the DEFAULT action or command).  </P>

<B><P>Return Value</P>
</B><P>If the argument you specify is not associated with an open file, the run-time system issues a warning and the function returns the symbol NIL.</P>

<P>When the function reads past the end of a file, it returns the symbol END-OF-FILE.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following MAKE action uses the ACCEPT-ATOM function to create a Working Memory Object (WMO) that contains an atom read from the file associated with the file identifier INFIL.</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(make input-thing ^item (accept-atom infil)) </P>
</FONT><P>&nbsp;</P>
</ul>

<B><FONT FACE="Helvetica" SIZE=4>
ACCEPTLINE-COMPOUND
</B></FONT><P>Reads a line of input from the keyboard or a file and returns a compound value that contains the values read. Ignores values after a semicolon (;) until the end of the line.</P>

<P>If some of the atoms in the current line have already been read, the input line is defined as all the remaining atoms on the current line. If all the atoms on the current line have been read, the input line is the next. If the input line contains no atoms, the function returns the specified default compound value.</P>

<P>By default, the ACCEPTLINE-COMPOUND function reads input from the keyboard. If you want the function to read input from a file, call the function with the file identifier of an open input file, or change the default for input.</P>


<ul><B><I><LI>Format</LI>
</B><FONT FACE="Arial" SIZE=2><P>ACCEPTLINE-COMPOUND [file-id [default-compound-value]]</P>
</FONT><B><LI>Arguments</LI>
</I><FONT SIZE=2><P>File-id</P>
</B><P>The file identifier of the file from which input is to be read. The file must have been opened and associated with the identifier in a previous OPENFILE action or command.</P>

<P>This argument is optional. If you do not specify a file identifier, input is read from the current default for the ACCEPTLINE-COMPOUND function (set with the DEFAULT action or command).</P>

<B><P>Default-compound-value</P>
</B><P>The compound value to be returned when the function reads a blank line. This argument may be a bound compound variable or a function call that returns a compound value.</P>

<P>If you want to specify a default compound value, you must also specify a file identifier. If you want to specify a default compound value when reading from the default input source, use the symbol NIL for the file identifier.</P>
</FONT><B><I><LI>Return Value</LI>
</B></I><FONT SIZE=2><P>A compound value that contains all the atoms on the current input line. If the input line contains no atoms, the function returns the specified default compound value.</P>

<P>If the first argument you specify is not associated with an open file, the run-time system issues a warning and the function returns the empty compound value.</P>

<P>When the function reads past the end of a file, it returns a compound value that contains the single element END-OF-FILE.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following actions read a line of input as a compound variable, and write it one element at a time:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(bind &lt;my-compound&gt; (acceptline-compound))</P>
<P>(for-each &lt;x&gt; in &lt;my-compound&gt;</P>
<P>&#9;  (write (crlf) &lt;x&gt;))</P>
</FONT><I><FONT SIZE=2><P>&nbsp;</P>
</I>
</ul>
</FONT>
<B><FONT FACE="Helvetica" SIZE=4>ADDSTATE
</B></FONT><P>Adds the objects in a file produced by the SAVESTATE action or command to working memory.</P>
<P>The added objects have new INSTANCE-IDs and new time-tags. Any attributes in the added objects that have INSTANCE-ID values that point to other added objects are automatically updated so that the references remain consistent.</P>

<P>The ADDSTATE action and command is scoped to the entry block; it creates visible objects only. Trying to add objects whose class declarations are not visible to the entry block causes a run-time warning, and the WMOs are not made.</P>


<ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(ADDSTATE  <I>filespec</I>)</P>
</FONT><I><LI>Argument</LI>
</I><FONT SIZE=2><P>filespec</P>
</B><P>A file specification for a file previously produced by the SAVESTATE action or command. See Section C.1 for restrictions on file names.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>Suppose you use the SAVESTATE action or command to create the file CONFIG.DAT.  The following action adds the objects in the file to working memory.</P>
</FONT><FONT FACE="Courier" SIZE=3><P> (addstate config.dat)</P>
</FONT><FONT SIZE=2><P>The equivalent command is:</P>
</FONT><FONT FACE="Courier" SIZE=2 COLOR="#0000ff"><P>RuleWorks&gt;  </FONT><B><FONT FACE="Courier" SIZE=2 COLOR="#800000">addstate config.dat</P>
</B></FONT><FONT SIZE=2><P>On ULTRIX and Digital UNIX systems, the command could be:</P>
</FONT><FONT FACE="Courier" SIZE=2 COLOR="#0000ff"><P>RuleWorks&gt;  </FONT><B><FONT FACE="Courier" SIZE=2 COLOR="#800000">addstate  | config.dat | </P>
</B></FONT><P> </P>

</ul>

<p>&nbsp;</p>

<B><FONT FACE="Helvetica" SIZE=4>
AFTER
</B></FONT><P>Specifies the number of recognize-act cycles that must be executed before a  specified catcher is executed (see also Chapter 5).</P>

<P>Only one catcher can be active. Thus, the AFTER action and command disables the current catcher, if any, before it enables the new one.</P>

<P>The rule-firing counter is local to the current invocation of the active entry block.  Recognize-act cycles executed by an entry block called from the entry block that contains the AFTER and CATCH actions are not counted.</P>


<ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>AFTER</B> <I>cycles catcher-name</P>
</FONT><B><LI>Arguments</LI>
</I><FONT SIZE=2><P>cycles</P>
</B><P>A positive integer that specifies the number of recognize-act cycles that are to be executed before the specified catcher is executed. If this number of cycles is never reached, the catcher is not executed.</P>
<B>
<P>catcher-name</P>
</B><P>A symbol that names a catcher.</P>

<P>If the catcher executes another AFTER, the counter restarts.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following command specifies that the catcher named TOO-MANY-CYCLES is to be executed after 100 recognize-act cycles have been executed:</P>
</FONT><FONT FACE="Courier" SIZE=2 COLOR="#0000ff"><P>RuleWorks&gt;  </FONT><B><FONT FACE="Courier" SIZE=2 COLOR="#800000">AFTER 100 TOO-MANY-CYCLES</P>
</B></FONT><FONT SIZE=2><P>The equivalent action is:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(AFTER 100 TOO-MANY-CYCLES) </P>
</FONT>
</ul>

<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>AND
</B></FONT><P>Performs a logical conjunction on its two operands, that is, returns true only when both of its operands are true.</P>
<B><FONT FACE="NewCenturySchlbk" SIZE=2><P>Note:</B>  &#9;This is a relational operator only, not a match predicate. AND may be used only in relational expressions within IF...THEN...ELSE or  WHILE...DO... actions.</P>


</FONT>
<ul><B><I><LI>Format</LI>
</B><FONT SIZE=2><P>rel-expr</I> <B>AND</B> <I>rel-expr</P>
</FONT><B><LI>Operands</LI>
</I><FONT SIZE=2><P>rel-expr</P>
</B><P>The relational expressions to be combined. These arguments must evaluate to either true or false.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following code fragment shows the AND operator in a WHILE...DO...action:</P>
</FONT><FONT FACE="Courier" SIZE=3><P> (while ((&lt;cards-dealt&gt; &lt; 5) AND (&lt;dealing&gt; == true)) do</P>
<P>    (deal-a-card)) </P>
</FONT>

</ul>
<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>
BIND
</B></FONT><P> Binds a variable to a value.</P>

<P>The scope of the variable binding depends on the construct that contains the BIND action. Variables bound in rules, catchers, and methods are local. Variables bound to the input arguments of an entry block, and variables bound in any ON- statement, are visible to all subsequent ON- statements.</P>


<ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>BIND</B> <I>variable value-expression</P>
</FONT><B><LI>Arguments</LI>
</I><FONT SIZE=2><P>variable</P>
</B><P>The variable to which a value is to be bound.</P>
<B>
<P>value-expression</P>
</B><P>An expression that can evaluate to either a scalar or compound value. The action binds the specified variable to the value that results from the evaluation.</P>
</FONT><B><FONT FACE="NewCenturySchlbk" SIZE=2><P>Note:</B>  &#9;MAKE, COPY, MODIFY, and SPECIALIZE actions return a value of type INSTANCE-ID.  You can use them as the second argument to the BIND action, as well as anywhere else a value expression is permitted.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following action binds the variable &lt;NEW-OBJECT&gt; to the INSTANCE-ID returned by a MAKE action.  (See Chapter 3-3 for an example of a complete program):</P>
</FONT><FONT FACE="Courier" SIZE=3><P> (bind &lt;new-object&gt;</P>
<P>(make example-object ^next &lt;first-object&gt; ^last &lt;instance-id&gt;^value (&lt;val&gt; + 1))) </P>
</FONT><P> </P>
</ul>
<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>
CATCH
</B></FONT><P>Creates a catcher, which is a list of actions that are executed after a specified number of recognize-act cycles have been executed. An AFTER action or command specifies the number of recognize-act cycles to be executed before the catcher is executed.</P>

<P>The AFTER and the CATCH must be contained in the same block. The recognize-act cycles count includes only rule firings in the entry block that contains or activates the AFTER and the CATCH.</P>


<ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>CATCH</B> <I>catcher-name action</P>
</FONT><B><LI>Arguments</LI>
</I><FONT SIZE=2><P>catcher-name</P>
</B><P>A symbol that names the catcher being created. The symbol cannot be the name of another catcher, a rule, a rule group that already exits in the entry block.</P>
<B>
<P>action</P>
</B><P>Any RHS action. You can specify one or more actions.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following CATCH statement creates a catcher named TOO-MANY-CYCLES, which displays a message after the number of recognize-act cycles specified in an AFTER action or command have been executed, and stops execution:</P>
</FONT><FONT FACE="Courier" SIZE=2><P>(catch too-many-cycles</P>
<P>           (write (crlf) |Program appears to be looping.|)</P>
<P>           (quit))</P>
</FONT><B>

</ul>
<p>&nbsp;</p><FONT FACE="Helvetica" SIZE=4>
CLOSEFILE
</B></FONT><P>Closes the open files associated with specified file identifiers and  dissociates the identifiers from the files.</P>


<ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>CLOSEFILE</B> <I>file-id</I> ...</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>file-id</P>
</B><P>The file identifier of the file to be closed. The file must have been opened and associated with the identifier in a previous OPENFILE action or command.   </P>

<P>You can specify one or more file identifiers.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following command closes the open files associated with the file identifiers INFIL and OUTFIL:</P>
<P> </FONT><FONT FACE="Courier" SIZE=2 COLOR="#0000ff">RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=2 COLOR="#800000">CLOSEFILE INFIL OUTFIL</P>
</B></FONT><FONT SIZE=2><P>The equivalent action is:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(CLOSEFILE INFIL OUTFIL) </P>
</FONT><P> </P>

</ul>
<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>
COMPOUND
</B></FONT><P>Creates a new compound value from an arbitrary number of elements. If no elements are specified, the function returns the empty list.</P>

<P>COMPOUND is a stateless function and can be used on either the LHS or RHS.</P>


<ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>COMPOUND</B> <I>[ element ]</I> ...</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>element</P>
</B><P>Any valid scalar or compound value expression.</P>
</FONT><B><I><LI>Return Value</LI>
</B></I><FONT SIZE=2><P>A compound value that contains all the elements of the specified arguments.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following rule pushes a new value onto a stack by creating a new compound value from the new scalar value plus the current compound value.</P>
</FONT><FONT FACE="Courier" SIZE=3><P> (rule push-stack</P>
<P>        (agenda ^$ID &lt;Agenda-object&gt; ^tasks &lt;task-list&gt;)</P>
<P>     --&gt;</P>
<P>        (modify &lt;Agenda-object&gt; ^tasks (compound new-task &lt;task-list&gt;)))</P>
</FONT><FONT SIZE=2>
<B><P>Note</B>: RuleWorks does not support multilevel lists; the value returned above is a compound value whose elements are all scalar, not a compound value with one scalar element and a nested compound value.</P>

<B><P>COMPOUND </B>is the only function you can use in commands to the RuleWorks interpreter:</P>
</FONT><FONT FACE="Courier" SIZE=2 COLOR="#0000ff"><P>RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=2 COLOR="#800000">make box ^card-in-slot (compound memory keyboard)</P>
</B></FONT><P> </P>
</ul>
<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>
CONCAT
</B></FONT><P> Concatenates (splices) the print forms of its arguments.</P>


<ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>CONCAT</B> <I>[value-expr]</I>...</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>value-expr</P>
</B><P>A RuleWorks expression that evaluates to a value to be concatenated. You can specify any number of values.</P>

<P>If you specify a compound value, RuleWorks treats each element as a separate argument.</P>

</FONT><B><I><LI>Return Value</LI>
</B></I><FONT SIZE=2><P>A single scalar symbolic atom whose print name is the result of splicing together all of its arguments without inserting any spaces. If the result is too big to fit in a single atom, the function truncates it at the maximum symbol size (see chapter 2) and issues a warning.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following table shows three calls to the CONCAT function and their results:</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P><!a NAME="_Toc393858205">Table 18  CONCAT Function Calls and Results</P>
<P>Function Call  &#9;Print Form of Return Value</P>
</B></FONT><FONT FACE="NewCenturySchlbk" SIZE=2><P> </FONT><FONT FACE="Courier" SIZE=2>(CONCAT a b c)</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9; </FONT><FONT FACE="Courier" SIZE=2>ABC</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=2><P> </FONT><FONT FACE="Courier" SIZE=2>(CONCAT A | b | c)</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>   &#9; </FONT><FONT FACE="Courier" SIZE=2>AbC</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=2><P>  (</FONT><FONT FACE="Courier" SIZE=2>bind &lt;x&gt; | Fast | )</FONT><FONT FACE="NewCenturySchlbk" SIZE=2> <BR>
 </FONT><FONT FACE="Courier" SIZE=2>(bind &lt;y&gt; | program! | )</FONT><FONT FACE="NewCenturySchlbk" SIZE=2> <BR>
 </FONT><FONT FACE="Courier" SIZE=2>(CONCAT &lt;x&gt; || &lt;y&gt;)</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9; </FONT><FONT FACE="Courier" SIZE=2>Fast program!</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1><P> </P>
</FONT>
</ul>
<p>&nbsp;</p><B><FONT FACE="Helvetica" SIZE=4>
COPY
</B></FONT><P>Makes a new object from an existing object. The existing object remains unchanged as a result of this operation. If you specify one or more attributes and values in the COPY, the new object is created with the new values you supply.  In any case, the new object has a new $ID and a new time-tag.  For more information about objects, see Section 2.2.</P>

<P>Note that the first argument to the COPY action must be a variable, while the first argument to the COPY command must be a constant.</P>

<P>You can also use COPY as a function with the BIND action.</P>


<ul><B><I><LI>Format (for action) </LI>
</B></I><FONT SIZE=2><P>COPY ID-variable  [{^attribute value-expression}...]</P>
</FONT><B><I><LI>Format (for command) </LI>
</B></I><FONT SIZE=2><P>COPY instance-id [ {^attribute value}...]</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>ID-variable</P>
</B><P>A variable bound to a value of type INSTANCE-ID, indicating the object to be duplicated. The object must be visible to the active entry block. This argument can be used only in source code.</P>
<B>
<P>instance-id</P>
</B><P>A constant of type INSTANCE-ID, indicating the object to be duplicated.  The object must be visible to the active entry block.  This argument can be used only at the command interpreter level.</P>
<B>
<P>attribute</P>
</B><P>An optional argument, this represents an attribute whose value is to be changed during the copy operation.  You must specify a value with each attribute; you can specify any number of attribute-value pairs.</P>
<B>
<P>value-expression</P>
</B><P>Any scalar or compound value (if you specify a compound attribute) is a valid argument to the COPY action, including function calls and arithmetic expressions.</P>
<B>
<P>value</P>
</B><P>A scalar or compound value (if you specify a compound attribute).  You cannot use expressions or call functions (except the COMPOUND function) in an argument to the COPY command.</P>
</FONT><B><I><LI>Return Value</LI>
</B></I><FONT SIZE=2><P>The COPY action returns the INSTANCE-ID atom that identifies the new WMO.</P>
</FONT><B><I>
<LI>Example</LI>

</B></I><FONT SIZE=2><P>The following example shows a rule from the sample program, KIWI.OPS, rewritten to use a COPY action.</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(rule verify-configuration:kiwindows-needs-2-memory-cards-found-one</P>
<P>        (active-context ^name verify-configuration)</P>
<P>        (kiwindows)</P>
<P>        (memory ^$ID &lt;mem-id&gt;)</P>
<P>        - (memory ^$ID &lt;&gt; &lt;mem-id&gt;)</P>
<P>     --&gt;</P>
<P>        (make error ^severity warning ^message |Insufficient memory|)</P>
<P>        (write  (crlf) |Caution: KiWindows requires two memory cards,|</P>
<P>                (crlf) |  but you have only one memory card.|</P>
<P>                (crlf) |   Fixup: adding another memory card to your order.|</P>
<P>                (crlf) )</P>
<P>        (copy &lt;mem-id&gt;))</P>
</FONT><FONT SIZE=2>
<P>The following example shows the equivalent COPY command and its results:</P>
</FONT><FONT FACE="Courier" SIZE=2 COLOR="#0000ff"><P>RuleWorks&gt;  </FONT><B><FONT FACE="Courier" SIZE=2 COLOR="#800000">PPWM MEMORY</P>
</B></FONT><FONT FACE="Courier" SIZE=2 COLOR="#0000ff"><P> #31 [CONVERT-SINGLE-ITEM-INPUT-THING-TO-PARTS:MEMORY] (MEMORY)</P>
<P>RuleWorks&gt;  </FONT><B><FONT FACE="Courier" SIZE=2 COLOR="#800000">COPY #31</P>
</B></FONT><FONT FACE="Courier" SIZE=2 COLOR="#0000ff"><P>RuleWorks&gt;  </FONT><B><FONT FACE="Courier" SIZE=2 COLOR="#800000">PPWM MEMORY</P>
</B></FONT><FONT FACE="Courier" SIZE=2 COLOR="#0000ff"><P> #31 [CONVERT-SINGLE-ITEM-INPUT-THING-TO-PARTS:MEMORY] (MEMORY)</P>
<P> #32 [| main |] (MEMORY)</P>
</FONT><B>
</ul>
<p>&nbsp;</p>
<FONT FACE="Helvetica" SIZE=4>CRLF
</B></FONT><P> Causes the WRITE action to move to the next line. Valid inside a WRITE action only.</P>


<ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>CRLF</B> </P>
</FONT><B><I><LI>Arguments</LI>
</B></I><FONT SIZE=2><P>None</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following WRITE action:</P>
</FONT><FONT FACE="Courier" SIZE=3><P> (write  (crlf) |Caution: You need to buy the base CPU unit.|</P>
<P>        (crlf) |  Fixup: adding a CPU BOX to your order.|</P>
<P>        (crlf) )</P>
</FONT><FONT SIZE=2><P>produces the following output:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>Caution: You need to buy the base CPU unit.</P>
<P>  Fixup: adding a CPU BOX to your order.  </P></font>
</ul>
<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>CS



</B></FONT><P>Displays the active contents of the conflict set, that is, instantiations of rules contained in or activated by the active entry block.</P>

<P>The command displays instantiations in the following format:</P>
<I><P>rule-name</I> <B>#</B><I>instance-id-1 time-tag-1</I>   #<I>instance-id-2 time-tag-2</I> ... </P>
<P>where:</P>

<UL>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=2><LI>#<I>instance-id-1</I> is the INSTANCE-ID of an object that matches the first CE on the left-hand side and <I>time-tag-1</I> is its time-tag,</LI>
<LI> #<I>instance-id-2</I> matches the second CE, and so on.</LI></UL>






</FONT>
<ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>CS</B> </P>
</FONT><B><I><LI>Example</LI>




</B></I><FONT SIZE=2><P>The following command displays the contents of the conflict set:</P>
</FONT><FONT FACE="Courier" SIZE=2 COLOR="#0000ff"><P> RuleWorks&gt;  </FONT><B><FONT FACE="Courier" SIZE=2 COLOR="#800000">cs</P>



</B></FONT><FONT FACE="Courier" SIZE=1><P>POP-ACTIVE-CONTEXT #35 40</P>
<P>VERIFY-CONFIGURATION:APPLICATION-NEEDS-KIWOS #35 40 #32 37</P>
<P>VERIFY-CONFIGURATION:APPLICATION-NEEDS-KIWOS #35 40 #29 34</P>
<P>VERIFY-CONFIGURATION:NEED-DISK #35 40</P>
<P>VERIFY-CONFIGURATION:NEED-OUTPUT #35 40</P>
<P>MAKE-CONTEXT-ACTIVE #6 6</P>
<P>MAKE-CONTEXT-ACTIVE #5 5</P>
<P>MAKE-CONTEXT-ACTIVE #4 4</P>
<P>MAKE-CONTEXT-ACTIVE #3 3</P>



</FONT><P> </P>



</ul>
<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>
DEBUG
</B></FONT><P>Pauses execution after the current rule or ON- construct and invokes the RuleWorks command interpreter.</P>

<P>This action is effective only when contained in an entry or rule block that was compiled with the Debug qualifier set to YES or MAYBE (see Chapter 8 for more information on compiling RuleWorks programs). If the block was compiled with Debug NO, the DEBUG action is a no-op.</P>

<P>When you compile an entry block with Debug set to YES, the command interpreter automatically appears when the entry block begins executing and when it ends. To achieve this effect with Debug set to MAYBE, put a DEBUG action in your ON-ENTRY and ON-EXIT statements. Other good places to put DEBUG actions are in error-checking rules (rules that match when your program is not running correctly) and catchers.</P>


<ul><B><I><LI>Format</LI>
</I><FONT FACE="NewCenturySchlbk" SIZE=2><P>DEBUG</P>
</B></FONT><I><LI>Arguments</LI>
</I><FONT FACE="NewCenturySchlbk" SIZE=2><P>None</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>RuleWorks debugging commands are allowed after the DEBUG action, and will be executed by the command interpreter. For example:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(on-entry</P>
<P>      (make agenda ^tasks (compound start work stoop)</P>
<P>      (debug)</P>
<P>      (watch rules)</P>
<P>       (make control ^name print-err-messages)) </P>
</FONT>
</ul>
<p>&nbsp;</p><B><FONT FACE="Helvetica" SIZE=4>
DECLARATION-BLOCK
</B></FONT><P>Names a group of object class, method, or external routine declarations so that they can be shared among multiple entry block or rule blocks.</P>

<P>Declaration blocks are optional; both object classes and external routines can be declared inside entry blocks or rule blocks. However, if a declaration is inside an entry block or rule block, that declaration is private and cannot be shared. Instances of objects declared privately are not visible to any other block.</P>

<P>All object classes that are related by inheritance must be contained in the same block. A subclass cannot inherit from a parent class declared in a different block. Similarly, methods must be declared in the same block as the class to which they are attached.</P>

<P>A declaration block must not contain any executable program statements (that is, rules, catchers, or ON-constructs). It must be entirely contained in a single source file.</P>

<P>The block must be terminated with an END-BLOCK declaration.</P>


<ul><B><I><LI>Format</LI>
</B></I><FONT SIZE=2><P>(<B>DECLARATION-BLOCK</B> <I>block-name</I>)</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>block-name</P>
</B><P>A symbol that names the block. This name must be distinct from all other block names in your program.</P>
</FONT><B><I><LI>Example</LI>
</B></I><FONT SIZE=2><P>This example shows a block of two OBJECT-CLASS declarations:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(DECLARATION-BLOCK line-items)</P>
<P>       (OBJECT-class item</P>
<P>                     ^item-code</P>
<P>                     ^item-name</P>
<P>                     ^quantity</P>
<P>                     ^price-per</P>
<P>                     ^item-total)</P>
<P>       (OBJECT-CLASS shippable-item</P>
<P>                     (INHERITS-FROM  item)</P>
<P>                     ^part-number)</P>
<P>(END-BLOCK line-items)  ; the block name is optional here,</P>
<P>                        ; but is checked if supplied</P>
</FONT><FONT SIZE=2><P>                    </P>
</FONT>
</ul>
<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4><P>DEFAULT </P>
</B></FONT><P>Sets the default input source for the ACCEPT-ATOM and ACCEPT-LINE COMPOUND functions, or the default output destination for the WRITE action or trace output. If you do not use the DEFAULT command or action to specify otherwise, RuleWorks reads input from the keyboard and sends output to the screen (see chapter 2 for platform-specific details.)</P>
<ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>DEFAULT</B> <I>file-id io-type</P>
</FONT><B><LI>Arguments</LI>
</I><FONT SIZE=2><P>file-id</P>
</B><P>The source from which input is to be read or the destination to which output is to be written. The value can be either a file identifier or the symbol NIL. If you specify a file identifier, DEFAULT sets the source or destination to the open file associated with that name. If you specify NIL, the input is read from the keyboard or output is sent to the screen.  </P>

<P>Use the OPENFILE action or command to open a file for access in a specified mode and create a file identifier.</P>
<B>
<P>io-type</P>
</B><P>A keyword that specifies whether the default is to be set for input, debugging output, or program output.  The following table lists the keywords you can specify.</P>
</FONT>
<B><FONT FACE="Arial" SIZE=2><P><!a NAME="_Toc393858206">Table 19.  DEFAULT Keywords</P></font></b>
<TABLE BORDER=1>
<TR><TD><B>I/O Type</B></TD><TD><B>Mode</B></TD><TD><B>Description</B></TD></TR>
<TR><TD>ACCEPT</TD><TD>IN</TD><TD>Input read by the ACCEPT-ATOM and ACCEPT-LINE-COMPOUND functions.</TD></TR>
<TR><TD>TRACE</TD><TD>OUT, APPEND</TD><TD>Output generated by the TRACE debugging command.</TD></TR>
<TR><TD>WRITE</TD><TD>OUT, APPEND</TD><TD>Output produced by the WRITE action.</TD></TR>
</TABLE>

<P>&nbsp;</p>
<B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following commands open a file for input, associate it with a file identifier INFIL, and set it to be the default source for the ACCEPT-ATOM and ACCEPTLINE-COMPOUND functions:</P>
</FONT><FONT FACE="Courier" SIZE=2 COLOR="#0000ff"><P>RuleWorks&gt;  </FONT><B><FONT FACE="Courier" SIZE=2 COLOR="#800000">openfile infil order.dat in</P>
</B></FONT><FONT FACE="Courier" SIZE=2 COLOR="#0000ff"><P>RuleWorks&gt;  </FONT><B><FONT FACE="Courier" SIZE=2 COLOR="#800000">default infil accept</P>
</B></FONT><FONT SIZE=2><P>The equivalent actions are:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(openfile infil order.dat in)</P>
<P>(default infil accept) </P>
</FONT>
</ul>

<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>DISABLE
</B></FONT><P> Revokes a run-time feature that you had previously set with an ENABLE command. To disable a feature, specify the appropriate keyword.</P>
<P>&nbsp;</P>
<ul><B><FONT FACE="Arial" SIZE=2><P>Table 20.  DEFAULT Keywords</P></b></font>
<table border=1>
<tr><td><b>KEYWORD</b></td><td><b>Feature</b></td></tr>
<tr><td>BLOCK-NAMES</td><td>Block names displayed with rule names </td></tr>
<tr><td>WARNING</td><td>Run-time warning and error messages</td></tr>
<tr><td>WMHISTORY</td><td>WMHISTORY command</td></tr>
</table>
<p>&nbsp;</p>
<B><I><LI>Format</LI>
</I><FONT SIZE=2><P>DISABLE </B> <I>keyword</P>
</FONT><B><LI>Argument</LI>
</I><FONT SIZE=2><P>keyword</P>
</B><P>A keyword that specifies the feature to be disabled. The keywords and the features they disable are listed in DISABLE Keywords table.</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P><!a NAME="_Toc393858207">Table 21. DISABLE Keywords</P></b></font>
<table border=1>
<tr><td><b>Keyword</b></td><td><b>Feature</b></td></tr>
<tr><td>BACK</td><td>BACK command</td></tr>
<tr><td>TIMING</td><td>PME package</td></tr>
<tr><td>BLOCK-NAMES</td><td>Block names displayed with rule names</td></tr>
<tr><td>WARNING</td><td>Run-time warning and error messages</td></tr>
<tr><td>WMHISTORY</td><td>WMHISTORY command</td></tr>
</table>

<p>&nbsp;</p>
<B><I><LI>Example</LI>

</B></I><P>The following command disables the WMHISTORY command:</P>
<FONT FACE="Courier" SIZE=2 COLOR="#0000ff"><P> RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=2 COLOR="#800000">disable wmh</P>
</B></FONT>
</ul>

<p>&nbsp;</p>
<B><FONT FACE="Helvetica" size=4>EBREAK
</B></FONT><P>Controls breakpoints on entry blocks.</P>

<P>When used with no arguments, the command displays a numbered list of the entry blocks that have breakpoints set. When used with the ON and OFF keywords, respectively, EBREAK sets and clears breakpoints for entry blocks. Breakpoints are set or cleared on both the ON-ENTRY and ON-EXIT clauses by a single command.</P>

<P>When the run-time system encounters  a breakpoint on an entry block, it finishes the ON-ENTRY or ON-EXIT construct (if-any), displays a message in the following format, and invokes the command interpreter:</P>

<P>%RUL-I-BREAKNOTED, Execution paused by break</P>
<P>EBREAK entering entry-block-name</P>
<P>Or</P>
<P>EBREAK exiting entry-block-name</P>

<P>Note that the block name is always displayed in EBREAK messages, whether BLOCK-NAMES is enabled or disabled.</P>
<P>&nbsp;</P>


<ul><B><I><LI>Format</LI>

</B></I>
<table>
<tr><td align=middle valign=middle><b>EBREAK</b><td>
<td align=middle valign=middle><img src="../images/ebreak.gif"></td></tr>
</table>

<B><FONT FACE="Helvetica" SIZE=4>



</FONT><I><LI>Arguments</LI>

</I><FONT SIZE=2><P>entry-block-name</P>
</B><P>The name of an entry block. You can specify one or more entry block names.</P>

<B><P>number</P>
</B><P>An integer displayed with the list of entry blocks when you give an EBREAK command with no argument. This argument is valid with the OFF keyword only.
<br>*
<br>All entry blocks.
</FONT>
</ul>
<p>&nbsp;</p>

<B><FONT FACE="Helvetica" SIZE=4>
ENABLE
</B></FONT><P>Enables the run-time feature specified by a keyword argument (see ENABLE Keywords). The default  state for all features is disabled.</P>

<P>Giving an ENABLE command with no argument results in a display of the features that are currently enabled. You can revoke a feature with the DISABLE command.</P>


<ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>ENABLE</B> <I>keyword</P>
</FONT><B><LI>Argument</LI>
</I><FONT SIZE=2><P>keyword</P>
</B><P>A keyword that specifies the feature to be enabled.</P>
</FONT>
<B><FONT FACE="Arial" SIZE=2><P><!a NAME="_Toc393858208">Table 22. ENABLE Keywords</P></b></font>
<table border=1>
<tr><td><b>Keyword</b></td><td><b>Feature</b></td></tr>
<tr><td>BACK <I>[n]</I></td><td>BACK command. The optional argument, <I>n</I>, is an integer that specifies the number of cycles that may be backed  over. The default is 64.</td></tr>
<tr><td>TIMING</td><td>PME package.</td></tr>
<tr><td>BLOCK-NAMES</td><td>Block names displayed with rule names</td></tr>
<tr><td>WARNING</td><td>Run-time warning and error messages.</td></tr>
<tr><td>WMHISTORY</td><td>WMHISTORY command.</td></tr>
</table>

<p><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following command enables run-time messages.</P>
</FONT><FONT FACE="Courier" SIZE=2 COLOR="#0000ff"><P> RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=2 COLOR="#800000">enable war</P>
</B></FONT><P> </P>
</ul>

<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>
END-BLOCK
</B></FONT><FONT SIZE=2><P>Closes a block construct. Each DECLARATION-BLOCK, ENTRY-BLOCK, and RULE-BLOCK declaration must end with an END-BLOCK. If you want, you can repeat the name of the block in the END-BLOCK declaration.</P>
</FONT>
<ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(END-BLOCK</B> [block-name]<B>)</P>
</FONT><I><LI>Argument</LI>
</I><FONT SIZE=2><P>block-name</P>
</B><P>The symbol that names the block being terminated. This argument is optional, but if you provide it the compiler checks it.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>This example shows a simple DECLARATION-BLOCK with a matching END-BLOCK:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(DECLARATION-BLOCK line-items)</P>
<P>   (OBJECT-CLASS   item</P>
<ul><P>                   ^item-code</P>
<P>                   ^item-name</P>
<P>                   ^quantity</P>
<P>                   ^price-per</P>
<P>                   ^item-total)</P>
</ul><P>    (OBJECT-CLASS  shippable-item</P>
<ul><P>                   (INHERITS-FROM item)</P>
<P>                   ^part-number)</P>
</ul><P>(END-BLOCK line-items)  ; the block name is optional here,</P>
<P>                        ; but is checked if supplied</P>
</FONT>
</ul>

<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>
END-GROUP
</B></FONT><FONT SIZE=2><P>Closes a rule group. Each RULE_GROUP declaration must end with an END-GROUP. If you want, you can repeat the name of the group in the END-GROUP declaration.</P>
<ul>
</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(END-GROUP</B> [group-name]<B>)</P>
</FONT><I><LI>Argument</LI>

</I><FONT SIZE=2><P>Group-name</P>
</B><P>The symbol that names the group being terminated. This argument is optional, but if you provide it the compiler checks it.</P>
</FONT>
</ul>
<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>
ENTRY-BLOCK
</B></FONT><FONT SIZE=2><P>Defines an entry point that is visible to the system linker and is callable by RuleWorks and other languages.</P>

<P>At least one ENTRY-BLOCK declaration is required for each RuleWorks routine. To make a RuleWorks program that you can run, at least one entry block must be named MAIN (or |main|).</P>

<P>RuleWorks entry blocks can accept arguments and return a value. You declare arguments with an ACCEPTS clause and the return value with a RETURNS clause.</P>

<P>An entry block can contain object class, and external routine declarations, and executable RuleWorks statements (that is, ON-statements, rules and catchers). It must be entirely contained in a single source file. However, an entry block can invoke rule blocks and declaration blocks that are contained in other files.</P>

<P>The entry block must close with an END-BLOCK declaration.</P>


</FONT>

<ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(ENTRY-BLOCK</B> <I>block-name</P>
<ul><P>                               [(<B>ACCEPTS</B> {&lt;f-param-name&gt; [</I><B>[</B><I>[size]</I><B>]</B><I>] ext-type [passing-mech]})]</P>
<P>  [(<B>RETURNS</B> {&lt;f-param-name&gt; [</I><B>[</B><I>[size]</I><B>]</B><I>] ext-type [passing-mech]})]</P>
</I><P>&#9;&#9; <I>[(<B>ACTIVATES</B> rule-block-name)}</P>
<P>                             [(<B>USES</B> decl-block-name)]</P>
</I><P>                             [(<B>STRATEGY</B>|<B>MEA</B>|)])</P>
<P>&#9;&#9;&#9;          |<B>LEX</B>| )])</P>
</FONT></ul>
<B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>block-name</P>
</B><P>A symbol that names the block. This name must be distinct from all routine names and other block names in your program and must conform to any restrictions imposed by your platforms linker. It must also satisfy the C language requirements for a function name:</P>

<ul>
<P>&#9;cannot contain the characters &quot;&lt;&gt;[]%^-</P>
<P>&#9;less than 32 characters long</P>
<P>&#9;different from all C keywords</P>
</ul>
<B><P>Note: </B>Naming an entry block MAIN (or |main|), with no ACCEPTS or RETURNS clause, generates a C-compliant &quot;main function&quot;. RuleWorks automatically adds a return value of type LONG.</P>

<P>The RuleWorks compiler generates a warning if an entry block named MAIN violates the C language restrictions on passing parameters to the main function: either zero or two parameters, one SHORT and one array of strings.</P>

</FONT><B><I><LI>Clauses</LI>
</I><P>Accepts</P>
</B><P>Defines the input argument list of the entry block. Note that the name and data type are required for each argument; the size (of an array) and passing mechanism are optional.</P>

<table>
<tr><td valign=top><I>f-param-name</I></td><td>A RuleWorks variable name for the formal parameter.<br>
Variables bound to input arguments are visible to the entry blocks ON-statements. They are not visible to rules unless you put them in working memory in your ON-ENTRY or ON-EVERY statement.</td></tr>
<tr><td valign=top>[<I>[size]</I>]</td><td>If a parameter is an array, you can indicate its expected size with either an integer or a variable bound to a previous parameter. The size is optional; the brackets are not.</td></tr>
<tr><td valign=top><P>ext-type</I></td><td>The external data type of input argument is passed. This argument is optional; the default mechanism is determined by the arguments external data type (see Table 6-1)</td></tr>
<tr><td valign=top><I><P>passing-mech</I></td><td>The mechanism by which the argument is passed. This arument is optional; the default mechanism is determined by the arguments external data type.</td></tr>
</table>

<P><B><I><LI>RETURNS</LI></p>
</B></I>
<P>Specifies the external data type and passing mechanism information for the entry blocks return value, if any. This clause is optional, but if you provide one RuleWorks checks that you also provide at least one RETURN action.</P>

<table>
<tr><td><i><P>f-param-name</I></td><td>A variable name for the return value. This argument is optional; you can use a name to make your code easier to read.</td></tr>
<tr><td><I><P>[size]</I></td><td>If the return value is compound, you must indicate its expected size. You can use either an input parameter of an integer type (byte, short long, and so on; see Table 6-2), or an integer constant.</td></tr>
<tr><td><I><P>Ext-type</I></td><td>The external data type of the return value. See Table 6-1 for RuleWorks external data types.</td></tr>
<tr><td><I><P>Passing-mech</I></td><td>The passing mechanism by which the value is returned. This argument is optional; the default mechanism is determined by the values external data type (see Table 6-1)</td></tr>
</table>

<p><B><I><LI>ACTIVATES</LI></p>
</B></I>
<P>Indicates which rule blocks are eligible to fire. This clause is optional.</P>

<I><P>Rule-block-name</I>&#9;A symbol that names a rule block. You specify one or more rule blocks.</P>

<P>All rule blocks activated by an entry block are enabled automatically when the entry block is called. They must all use the same conflict-resolution strategy as the entry block that invoke them.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>USES</LI>
</B></I><FONT SIZE=2><P>Indicates which declaration blocks are shared by the entry block. This clause is optional.</P>
</FONT><B><I><P>Declaration</P>
<FONT FACE="Times" SIZE=3><P>decl-block-</FONT><FONT SIZE=2>name</B></I> &#9;A symbol that names a declaration block. You can specify one or more declaration blocks.</P>
</FONT><B><I><FONT FACE="Times" SIZE=3>
</B></I><P>The declaration block(s) used by an entry block must be compiled before the entry block itself can be compiled.</P>
<P>&nbsp;</P>
</FONT><B><I>
<LI>STRATEGY</LI>

</B></I><FONT FACE="Times" SIZE=3><P>Specifies the conflict-resolution strategy (see section 1.5). This clause is optional. If you do not declare a strategy, the default MEA is used.</P>

<B><P>LEX</B>&#9;The lexicographic-sort strategy.</P>
<B><P>MEA </B>&#9;The means-end analysis strategy</P>

<P>Example</P>
<P>This example shows a simple counting program:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(entry-block |main| </P>
<ul><P>&#9;(accepts &lt;argc&gt; long</P>
<ul><P>&#9;&#9; &lt;argv&gt; [2] asciz)</P>
</ul><P>&#9;(returns long))</P>
</ul><P>&nbsp;</P>
<P>(object-class iterator ^count)</P>
<P>(object-class limit ^value)</P>
<P>&nbsp;</P>
<P>(on-entry</P>
<ul><P>&#9;(write |argC is| &lt;argc&gt; |argV is| &lt;argv&gt; (crlf))</P>
<P>&#9;(bind &lt;num-arg&gt; (integer (nth &lt;argv&gt; 2)))</P>
<P>&#9;(make limit           ^value &lt;num-arg&gt;)</P>
<P>      &#9;(make iterator       ^count 1))</P>
</ul><P>&nbsp;</P>
<P>(on-exit  (return 0))</P>
<P>&nbsp;</P>
<P>(rule increment-rule</P>
<ul><P>&#9;(limit ^value &lt;lim&gt;)</P>
<P>&#9;(iterator ^$id &lt;it&gt; ^count {&lt;num&gt; &lt; &lt;lim&gt; })</P>
<P>          <FONT FACE="Wingdings">&#224;</FONT>
</P>
<P>&#9;&#9;&#9;(write &lt;num&gt; (crlf))</P>
<P>&#9;&#9;&#9;(modify &lt;it&gt; ^count (&lt;num&gt; +1)))</P>
</ul><P>&nbsp;</P>
<P>&#9;(rule now-done</P>
<ul><P>&#9;&#9;&#9;(limit ^$id &lt;limit-id&gt; ^value &lt;lim&gt;)</P>
<P>&#9;&#9;&#9;(iterator ^$id &lt;it&gt; ^count &lt;lim&gt;)</P>
<P>&#9;          <FONT FACE="Wingdings">&#224;</FONT>
</P>
<P>&#9;&#9;&#9;(write &lt;lim&gt; (crlf))</P>
<P>&#9;&#9;&#9;(remove &lt;it&gt;)</P>
<P>&#9;&#9;&#9;(remove &lt;limit-id))</P>
<P>&#9;</P>
<p>&nbsp;</p>
</ul><P>&#9;(end-block |main|)</P>
</FONT>
<p>&nbsp;</p>
</ul>
<P>This example produces the following output, when compiled with DEBUG yes:</P>
<P>System&gt; count 5</P>
<P> ArgC is 2 argV is $1$dua0:[williams.ruleworks]count.exe;4 5</P>
<P>%RUL-I-EBREAK, EBREAK encountered on |main| &amp;ON-ENTRY</P>
<P>RuleWorks&gt; run</P>
<P>1</P>
<P>2</P>
<P>3</P>
<P>4</P>
<P>5</P>
<P>%RUL-I-EBREAK, EBREAK encountered on |main| &amp;On-EXIT</P>
<P>RuleWorks&gt; run</P>
<P>System&gt;</P>
</FONT>

<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>
EVERY
</B></FONT>
<P>Finds all instances of a specific class, including descendents of that class.</P>
<ul>
<B><I><LI>Format</LI>
</I><FONT SIZE=2><P>EVERY</B> <I>class-name</P>
</FONT><B>
<P>Argument</P>
</I><FONT SIZE=2><P>Class-name</P>
</B><P>A symbolic atom that names an object class visible to the active entry block.</P>
</FONT><B><I><LI>Return Value</LI>
</B></I><FONT SIZE=2><P>A compound value whose elements are the INSTANCE-Ids of all WMOs that belong to <I>class-name</I>. If <I>class-name </I>has children, instances of those children are included in the returned compound.</P>

<P>The INSTANCE-Ids are returned in no particular order.</P>

<P>If the specified class is not visible, returns the empty list ((COMPOUND)).</P>

</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following uses the value returned by the EVERY function in a FOR-EACH action:</P>
</FONT>
<ul><FONT FACE="Courier" SIZE=3><P>(bind &lt;dogs&gt; (every dog))</P>
<P>(for-each &lt;dog&gt; in &lt;dogs&gt;</P>
<ul><P>&#9;(wash-pet &lt;dog&gt;)</P>
<P>&#9;(pet-to-vet &lt;dog&gt;)</P>
<P>&#9;(pet-gets-treat &lt;dog&gt;))</P>
</FONT></ul></ul>
<FONT SIZE=2>
<P>(Wash pet, pet-to-vet, and pet-gets-treat are hypothetical external routines. Their definitions are left as an exercise for the reader.)</P>
</FONT></ul>

<P>&nbsp;</P>
<B><FONT FACE="Helvetica" SIZE=4>
EXIT
</B></FONT><FONT SIZE=2><P>An obsolescent synonym for the QUIT command.</P>


</FONT>
<ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>EXIT</B> </P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following command exits from the command interpreter and returns control to the operating system:</P>
<P> </FONT><FONT FACE="Courier" SIZE=2 COLOR="#0000ff">RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=2 COLOR="#800000">EXIT</P>
</B></FONT><FONT FACE="Courier" SIZE=2 COLOR="#0000ff"><P>System&gt;</P>
</FONT><P> </P>
</ul>
<P>&nbsp;</P>

<B><FONT FACE="Helvetica" SIZE=4>
EXTERNAL-ROUTINE
</B></FONT><FONT SIZE=2><P>Declares a function or subroutine written in a language other than RuleWorks. Defines the data types and passing mechanisms of the arguments needed to call the external routine. (See Chapter 6.1 for information on data types and passing mechanisms.)</P>

<P>Other RuleWorks entry blocks must also be declared as external routines.  However, an entry block can call itself recursively with no external routine declaration.</P>


</FONT>
<ul><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(EXTERNAL-ROUTINE) <I>routine-name</P>
<ul><P>&#9;[(ALIAS </B>actual-routine-name<B>)]</P>
<P>&#9;[(ACCEPTS { </B>[&lt;f-param-name&gt; [ <B>[ </B>[si</I>ze]<B><I> ] </B>] ]<B> ext-type [passing-mech] })]</P>
<P>&#9;[(RETURNS </B>{ [&lt;f-param-name&gt;<B> </B>[<B>  </B>[size]<B> </B>] <B>] ext-type [passing-mech] })]</P>
</i></FONT></ul>
<B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>routine-name</P>
</B></b>
<P>The name of the external routine. This must be a symbol that is different from all other routine names and all block names in the program. It must also be different from all RuleWorks actions, built-in functions, and relational operators (AND, NOT, and OR). These restrictions are enforced by the RuleWorks compiler.</P>

<P>The routine name must also satisfy the C language requirements for a function name:</P>
</FONT>
<ul><FONT FACE="NewCenturySchlbk" SIZE=2><P>&#9;cannot contain the characters  </FONT><FONT FACE="Courier" SIZE=2>"&lt;&gt;[]%^-</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=2><P>&#9;less than 32 characters long</P>
<P>&#9;different from all C keywords</P>
</FONT></ul>
<B><I><LI>Clauses</LI>
</I><FONT SIZE=2><P>ALIAS</P>
</B><P>Declares that the external routine's name is not the actual name against which it is to be linked. The most common use of this clause is to map a case-sensitive routine name to a RuleWorks symbol.</P>

<P> <I>actual-routine-name</I> &#9;The real name of the external routine.</P>
<B>
<P>ACCEPTS</P>
</B><P>Specifies the name, data type and passing mechanism of the arguments to be passed out to the external routine. The ACCEPTS clause is optional. If you declare any arguments you must also declare the data type of each argument; the name and passing mechanism are optional.  Arguments for the ACCEPTS clause are as follows:</P>

<table>
<tr><td><I><P>f-param-name</I></td><td>A formal parameter name for an argument to be passed out, for documentation purposes.</td></tr>
<tr><td><B><P>[</B> <I>[size]</I> <B>]</B></td><td>If included, this declares the argument to be an array.  The size of the array is optional; the brackets are not.  The size may be an integer or a variable previously bound  to an integer in this ACCEPTS clause.</td></tr>
<tr><td><I><P>ext-type</I></td><td>The name of the external data type.  Valid external types are: BYTE, SHORT, LONG, UNSIGNED-BYTE, UNSIGNED-SHORT, UNSIGNED-LONG, SINGLE-FLOAT, DOUBLE-FLOAT, ASCIZ, ASCID, and ATOM.</td></tr>
<tr><td><I><P>passing-mech</I></td><td>Valid passing mechanisms are:  BY REFERENCE READ-ONLY, BY REFERENCE READ-WRITE, and BY VALUE.</td></tr>
</table>
<B><P>RETURNS</P>
</B><P>Also an optional clause, this describes the external routine's return value. Arguments for the RETURNS clause are as follows:</P>
<table>
<tr><td><I><P>f-param-name</I></td><td>A formal parameter name for the return value, for documentation purposes.</td></tr>
<tr><td><B><P>[</B><I>size</I><B>]</B></td><td>If the return value is an array, you must declare its size. You can use a constant or a variable.</td></tr>
<tr><td><I><P>ext-type</I></td><td>The name of the external data type. Valid external types are: BYTE, SHORT, LONG, UNSIGNED-BYTE, UNSIGNED-SHORT, UNSIGNED-LONG, SINGLE-FLOAT, DOUBLE-FLOAT, ASCIZ, ASCID, and ATOM.</td></tr>
<tr><td><I><P>passing-mech</I></td><td>Valid passing mechanisms are BY REFERENCE and BY VALUE.</td></tr>
</table>
</FONT>
<p><B><I><LI>Examples</LI></p>

</B></I><FONT SIZE=2><P>The following example declares a VMS routine that returns a random number:</P>
</FONT>
<ul><FONT FACE="Courier" SIZE=3><P> (EXTERNAL-ROUTINE mth$random</P>
<ul><P>    (ACCEPTS &lt;seed&gt; LONG BY REFERENCE)</P>
<P>    (RETURNS LONG BY VALUE)</P>
</FONT></ul></ul>
<FONT SIZE=2><P>The next example maps the case-sensitive name XtParent to the RuleWorks symbol XT_PARENT:</P>
</FONT>
<ul><FONT FACE="Courier" SIZE=3><P>(EXTERNAL-ROUTINE xt_parent</P>
<ul><P>    (ACCEPTS &lt;param1&gt; INTEGER)</P>
<P>    (RETURNS &lt;param2&gt; INTEGER)</P>
<P>    (ALIAS "XtParent"))</P>
</FONT></ul></ul>
<FONT SIZE=2>
<P>The following example declares the ULTRIX routine that returns an environment variable:</P>
</FONT>
<ul><FONT FACE="Courier" SIZE=3><P>(EXTERNAL-ROUTINE getenv__; from the POSIX library</P>
<ul><P>    (ACCEPTS &lt;env-name&gt; ASCIZ BY REFERENCE READ-ONLY)</P>
<P>    (RETURNS &lt;env-value&gt; ASCIZ BY REFERENCE)) </P>
</FONT>
</ul></ul>

<P>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810109">FOR-EACH </LI>
</B></FONT><FONT SIZE=2><P>Allows iteration over each element in a compound  &lt;CONDITION&gt;(TIN) or table  value.  The index variable is bound and the specified RHS actions are executed once for each iteration.</P>


</FONT><B><I><LI>Format (for a compound)</LI>
</B></I><FONT SIZE=2><P>(FOR-EACH &lt;element&gt; IN compound-value<BR>
&#9;&#9;&#9;RHS-action ... )</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>&lt;element&gt;</P>
</B><P>The index variable that is bound to each element of the compound value.</P>
<B>
<P>compound-value</P>
</B><P>The compound value to be acted upon. This argument may be a bound compound variable or an expression that returns a compound value.</P>
<B>
<P>RHS-action</P>
</B><P>Any valid RHS action. You can specify any number of actions.</P>
<B>
<P>&lt;data-value&gt;</P>
</B><P>The index variable that is bound to each data value in the table value.</P>
<B>
<P>&lt;key-name&gt;</P>
</B><P>The index variable that is bound to each key value in the  table value.</P>
<B>
<P>table-value</P>
</B><P>The table value to be acted upon. This argument may be a bound table variable or an expression that returns a table value.</P>
</FONT><B><I><LI>Examples</LI>

</B></I><FONT SIZE=2><P>The following examples uses the FOR-EACH action to print out the names of all the cards in a Kiwi-9200 computer card cage.  Note that this also shows how to bind an index variable.</P>
</FONT><FONT FACE="Courier" SIZE=3><P> (rule print-out-cage:do-it</P>
<P>     (active-context ^name print-out-cage)</P>
<P>     (box ^cards-in-slot &lt;cards&gt; )</P>
<P>  --&gt;</P>
<P>     (write (crlf) |The card cage will contain: |)</P>
<P>     (bind &lt;slot-counter&gt; 1)</P>
<P>     (for-each &lt;card&gt; in &lt;cards&gt;</P>
<P>     (write (crlf) (tabto 20) |Slot number| &lt;slot-counter&gt;</P>
<P>                              |contains a| &lt;card&gt;)</P>
<P>     (bind &lt;slot-counter&gt; ( &lt;slot-counter&gt; + 1 ) ) ) )</P>
</FONT><P>&nbsp;</P>
<B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810110">FLOAT </LI>
</B></FONT><FONT SIZE=2><P>Converts a numeric value into a floating-point number. FLOAT is a stateless function and can be used on either the LHS or RHS.</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(FLOAT  <I>numeric-expr</I> )</P>
</FONT><I><LI>Argument</LI>

</I><FONT SIZE=2><P>numeric-expr</P>
</B><P>An expression that evaluates to an INTEGER or FLOAT. If supplied with a SYMBOL, the FLOAT function converts the first white space delimited token, if possible. If not, or if the argument is an OPAQUE or INSTANCE-ID, the function issues a warning message and returns the floating-point number zero.</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P><!a NAME="_Toc393858209">Table 23.  FLOAT Calls and their Return Values</P>
<P>Function Call  &#9;Return Value  &#9;Warning Message?</P>
</B></FONT><FONT FACE="Courier" SIZE=2><P>(FLOAT 3)</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9; </FONT><FONT FACE="Courier" SIZE=2>3.0</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9;No</P>
<P> </FONT><FONT FACE="Courier" SIZE=2>(FLOAT 3.2)</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9; </FONT><FONT FACE="Courier" SIZE=2>3.2</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9;No</P>
<P> </FONT><FONT FACE="Courier" SIZE=2>(FLOAT |3.2|)</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9; </FONT><FONT FACE="Courier" SIZE=2>3.2</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9;No</P>
<P> </FONT><FONT FACE="Courier" SIZE=2>(FLOAT |76 trombones|)</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9; </FONT><FONT FACE="Courier" SIZE=2>76.0</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9;No</P>
<P> </FONT><FONT FACE="Courier" SIZE=2>(FLOAT 2+2)</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9; </FONT><FONT FACE="Courier" SIZE=2>0.0</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9;Yes</P>
<P> </FONT><FONT FACE="Courier" SIZE=2>(FLOAT #32)</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9; </FONT><FONT FACE="Courier" SIZE=2>0.0</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9;Yes</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1><P>&nbsp;</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810111">GENATOM </LI>
</B></FONT><FONT SIZE=2><P>Returns a system-generated atom, with an optional prefix.</P>

<P>The RuleWorks atom generator is used by the GENATOM and GENINT actions, and by the rul_genint, rul_gensym, and rul_gensymp routines. Every atom generated for any of these routines is unique while the program is running. The atom generator is global, so that all entry blocks called in a program have unique generated atoms.</P>

<P>The generated atoms consist of an integer and an optional prefix. Within a program run, the first use of the atom generator returns 1, the second 2, and so on. The rul_genint routine and the GENINT action return an integer with no prefix. The rul_gensymp routine and the GENATOM action return an integer with a prefix that you can specify, or use the default prefix G:. The rul_gensym routine returns an integer prefixed by G:. The table below shows several uses of the atom generator and the atoms it returns:</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P><!a NAME="_Toc393858210">Table -24.  Atom Generator and Returns</P>
<P>Routine Call or RHS Action  &#9;Atom Generated</P>
</B></FONT><FONT FACE="NewCenturySchlbk" SIZE=2><P>rul_genint  &#9;1</P>
<P>rul_gensymp(R:)  &#9;R:2</P>
<P>(GENATOM)  &#9;G:3</P>
<P>(GENINT)  &#9;4</P>
<P>rul_gensym  &#9;G:5</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1>
</FONT><FONT SIZE=2><P>The atom generator is reset by the RESTORESTATE action and command.</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(GENATOM  </B><I>[prefix])</I><B> </P>
</FONT><I><LI>Argument</LI>
</I><FONT SIZE=2><P>prefix</P>
</B><P>A RuleWorks expression, the print form of which will be the first part of the return value. The default prefix is G:</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Return Value</LI>
</B></I><FONT SIZE=2><P>A symbol that consists of the prefix you specify (if any) with an integer appended to it.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following BIND action binds the variable &lt;TRANSACTION-ID&gt; to the atom produced by the GENATOM function:</P>
</FONT><FONT FACE="Courier" SIZE=3><P> (bind &lt;transaction-id&gt; (genatom trans-)) </P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810112">GENINT</LI>
</B></FONT><FONT SIZE=2><P>Returns a system-generated INTEGER. See GENATOM for details on the RuleWorks atom generator.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(GENINT)</P>
</B><P>&nbsp;</P>
</FONT><B><I><LI>Return Value</LI>
</B></I><FONT SIZE=2><P>An INTEGER value.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following BIND action binds the variable &lt;TRANSACTION-ID&gt; to the atom produced by the GENINT function:</P>

<P>(bind &lt;transaction-id&gt; (genint))</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>GET</LI>
</B></FONT><FONT SIZE=2><P>Given a variable bound to an object identifier and an attribute name, returns the value of that attribute of that object. The variable can be bound on either the LHS or the RHS, but GET is allowed on the RHS only.</P>

<P>The GET function lets you access attribute values on the RHS that you did not bind to variables on the LHS. You can bind the identifier of the object on the LHS, and then use the GET function to return the value of any attribute in that object. You do not need to bind each attribute value separately, only the INSTANCE-ID.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(GET</B> <I>object-id ^attribute-name</I><B>)</P>
<P>&nbsp;</P>
</FONT><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>Object-id</P>
</B><P>A variable bound to, or an expression that evaluates to, an INSTANCE_ID value. Variables can be bound on either the LHS or the RHS of the rule. The class of the object must be visible to the active entry block.</P>

<P>The RuleWorks compiler issues a warning if it is unable to verify that this argument is an INSTANCE-ID.</P>

<B><P>attribute-name</P>
</B><P>A symbolic expression that names an attribute in the specified object. It is a run-time warning to use an attribute that is not declared for the specified class.</P>

<P>Return Value</P>
<P>The value of the specified attribute in the specified instance; or NIL if the arguments are not correct.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following example shows one use of the GET function:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(OBJECT-CLASS fruit</P>
<P>&#9;&#9;^fruit-name</P>
<P>&#9;&#9;^color)</P>
<P>&nbsp;</P>
<P>(rule make-a-similar-one</P>
<P>   (fruit ^$ID &lt;The-fruit&gt; ^fruit-name apple)</P>
<P><FONT FACE="Wingdings">&#224;</FONT>
</P>
<P>(MAKE fruit ^fruit-name apple ^color (GET &lt;The-fruit&gt; ^color)))</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>IFTHENELSE</LI>
</B></FONT><FONT SIZE=2><P>Executes one or more RHS actions when a relational expression is true, or executes one or more different RHS actions when the expression is false. In other words, provides a branch in the flow of control.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</B></I><FONT SIZE=2><P>(<B>IF</B> (rel-expr)</P>
<P>      <B>THEN</B> RHS-action</P>
<P>       [<B>ELSE</B> RHS-action..])</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>rel-expr</P>
</B><P>A relational expression that determines which RHS actions are to be executed. This argument must evaluate to either true or false. It may not contain any SQL functions.</P>

<P>Note: RuleWorks does not have Boolean values. Therefore, this argument must be a comparison of two expressions. It must not be a single value. For example, RuleWorks does not allow <B>(IF (TRUE) THEN)</B>. </P>

<B><P>RHS-action</P>
</B><P>Any RuleWorks action. You can specify any number of actions.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Clauses</LI>

</I><FONT SIZE=2><P>THEN</P>
</B><P>Specifies the actions that are to be executed when the relational expression is true. This clause is required.</P>

<B><P>ELSE</P>
</B><P>Specifies the actions that are to be executed when the relational expression is false. This clause is optional.</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>INTEGER </LI>
</B></FONT><FONT SIZE=2><P>Converts a numeric atom into an integer. INTEGER is a stateless function and can be used on either the LHS or RHS.</P>


</FONT><B><I><LI>Format</LI>
</B></I><FONT SIZE=2><P>(INTEGER  <I>numeric-expr</I><B> )</P>
</FONT><I><LI>Argument</LI>
</I><FONT SIZE=2><P>numeric-expr</P>
</B><P>An expression that evaluates to an INTEGER or FLOAT.  If supplied with a SYMBOL, the INTEGER function converts the firs-t white space delimited token, if possible. If not, or if the Argument is an OPAQUE or INSTANCE-ID, the function issues a warning message and returns the integer zero.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Return Value</LI>
</B></I><FONT SIZE=2><P>The nearest integer (by rounding) that corresponds to the specified value.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Examples </LI>

</B></I><FONT SIZE=2><P>The following table shows several calls to the INTEGER function and their results:</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P><!a NAME="_Toc393858211">Table 25.  INTEGER Return Values</P>
<P>Function Call  &#9;Return Value  &#9;Warning Message?</P>
</B></FONT><FONT FACE="Courier" SIZE=2><P>(INTEGER 3)</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9; </FONT><FONT FACE="Courier" SIZE=2>3</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9;No</P>
</FONT><FONT FACE="Courier" SIZE=2><P>(INTEGER 3.5)</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9; </FONT><FONT FACE="Courier" SIZE=2>4</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9;No</P>
</FONT><FONT FACE="Courier" SIZE=2><P>(INTEGER 3.5e4)</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9; </FONT><FONT FACE="Courier" SIZE=2>35000</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9;No</P>
</FONT><FONT FACE="Courier" SIZE=2><P>(INTEGER |3.2|)</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9; </FONT><FONT FACE="Courier" SIZE=2>3</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9;No</P>
</FONT><FONT FACE="Courier" SIZE=2><P>(INTEGER |110 cornets|)</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>   &#9; </FONT><FONT FACE="Courier" SIZE=2>110</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9;No</P>
</FONT><FONT FACE="Courier" SIZE=2><P>(INTEGER 2+2)</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9; </FONT><FONT FACE="Courier" SIZE=2>0</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9;Yes</P>
</FONT><FONT FACE="Courier" SIZE=2><P>(INTEGER #12)</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9; </FONT><FONT FACE="Courier" SIZE=2>0</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>  &#9;Yes</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1><P> </P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810113">IS-OPEN</LI>
</B></FONT><FONT SIZE=2><P>Tests whether a file has already been opened. IS-OPEN is valid on the RHS only.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</B></I><FONT SIZE=2><P>(IS-OPEN file-id)</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>File-id</P>
</B><P>A symbolic atom that was associated with a filespec in an OPENFILE action. (See Section 4.5 for more information on input and output.)</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Return Value</LI>
</B></I><FONT SIZE=2><P>The mode (IN or OUT) if the file is open; NIL if it is not. If the file is open in mode APPEND, the function returns OUT. (See the OPENFILE action for more information on I/O mode.)</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following IFTHENELSE action uses the IS-OPEN function:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(if ((is-open infil) &lt;&gt; nil)</P>
<P>     then</P>
<P>&#9;(closefile infil))</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>LENGTH</LI>
</B></FONT><FONT SIZE=2><P>Returns the number of elements in a compound value. LENGTH is a stateless function and can be used on either the LHS or RHS.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</B></I><FONT SIZE=2><P>LENGTH compound-val</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Argument</LI>
</B></I><FONT SIZE=2><P>Compound-val</P>
<P>The compound value to be counted. This argument can be a bound compound variable or a function that returns a compound value.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Return Value</LI>
</B></I><FONT SIZE=2><P>An integer that specifies the number of elements in the compound value.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Examples</LI>

</B></I><FONT SIZE=2><P>The following condition element shows the LENGTH function used on the LHS:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(box ^card-in-slot &lt;cards&gt; ^max-cards &lt;= (length &lt;cards&gt;))</P>
</FONT><FONT SIZE=2>
<P>The following action shows the LENGTH function used on the RHS:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(write |The card cage contains| (length &lt;cards&gt; ) |cards.|)</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>MAKE </LI>
</B></FONT><FONT SIZE=2><P>Creates a working-memory object of the specified class, with the specified attribute values (if any). RuleWorks uses the default values for attributes you do not specify (see Chapter 2).</P>
<B><P>Note:</B> When you create WMOs at the command interpreter prompt, the first Argument to the MAKE command must be a constant. In contrast, when you create WMOs in source code, the first Argument to the MAKE action can be a variable or a call to the GET function.</P>
<P>You can also use MAKE as a function with the BIND action.</P>


</FONT><B><I><LI>Format (for action) </LI>
</B></I><FONT SIZE=2><P>(MAKE class-name [ { ^attribute value-expression }... ] )</P>
</FONT><B><I><LI>Format (for command) </LI>
</B></I><FONT SIZE=2><P>MAKE class-name [ { ^attribute value }... ] )</P>
</FONT><B><I><LI>Arguments(Arguments)</LI>
</I><FONT SIZE=2><P>class-name</P>
</B><P>A symbol or variable that names the class of the object to be created; it must be visible to the active entry block.</P>

<B><P>attribute</P>
</B><P>A symbol that names an attribute declared in the specified class.  This Argument is optional, but if you specify any attributes, you must specify a value with each attribute.</P>
<B>
<P>value-expression</P>
</B><P>Any scalar or compound expression (if you specify a compound attribute) is a valid Argument to the MAKE action, including function calls and arithmetic expressions.</P>
<B>
<P>value</P>
</B><P>A scalar or compound value (if you specify a compound attribute).  You cannot use expressions or call functions (except the COMPOUND function) in an Argument to the MAKE command.</P>
</FONT><B><I><LI>Return Value</LI>
</B></I><FONT SIZE=2><P>The MAKE action returns the INSTANCE-ID atom that identifies the new WMO.</P>
</FONT><B><I><LI>Examples</LI>

</B></I><FONT SIZE=2><P>The following rule uses the MAKE action to create an object of class ACTIVE-CONTEXT, with a bound variable as the value of the ^NAME attribute.</P>
</FONT><FONT FACE="Courier" SIZE=3><P> (rule make-context-active</P>
<P>        (context ^name &lt;context-name&gt; ^$ID &lt;context-id&gt;)</P>
<P>     --&gt;</P>
<P>        (make active-context ^name &lt;context-name&gt;)</P>
<P>        (remove &lt;context-id&gt;))</P>
</FONT><FONT FACE="Times" SIZE=3>
</FONT><FONT SIZE=2><P>The following MAKE command creates an object of class BOX with one element  each in the compound attributes ^CARD-IN-SLOT and ^CARD-IN-SLOT-OBJ-ID:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt;  </FONT><FONT FACE="Courier" SIZE=1>(MAKE BOX ^CARD-IN-SLOT (COMPOUND MEMORY)</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>_RuleWorks&gt;  </FONT><FONT FACE="Courier" SIZE=1>&lt;u&gt;(^CARD-IN-SLOT-OBJ-ID (COMPOUND #32))</P>
</FONT><FONT SIZE=2><P>The MAKE command below uses the bracket notation to index a compound attribute:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt; </FONT><FONT FACE="Courier" SIZE=1>MAKE BOX ^CARD-IN-SLOT[3] KEYBOARD ^CARD-IN-SLOT-OBJ-ID[3] #49</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810114">MATCHES </LI>
</B></FONT><FONT SIZE=2><P>Displays the INSTANCE-IDs of the objects that match CEs in the specified rule(s). The command lists the objects that match the first CE, then the second CE, then the first two CEs, and so on. The class name of each CE is shown as part of its heading. The output is in the following format:</P>

<P>&gt;&gt;&gt;RULE_NAME&lt;&lt;&lt;</P>
<B><P>***matches for (class-name-1)***</P>
</B><P>#instance-id</P>
<P></P>
<B><P>***matches for (class-name-2)***</P>
</B><P>#instance-id</P>
<P></P>
<B><P>***matches for 1 2 ***</P>
</B><P>#instance-id ~instance-id</P>
<P></P>
<P>***complete instantiations***</P>
<P>#instance-id time-tag #instance-id time-tag</P>

<P>For more information about displaying match information, see Chapter 9.</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>MATCHES </B><I>rule-name</I>...</P>
</FONT><B><I><LI>Argument</LI>


</I><FONT FACE="NewCenturySchlbk" SIZE=2><LI>rule-name</LI>

</B></FONT><FONT SIZE=2><P>The name of a rule for which match information is to be displayed. You can specify the name of one or more rules.</P>
</FONT><B><I><LI>Examples</LI>

</B></I><FONT SIZE=2><P>The following command displays match information of a rule that is not eligible for the conflict set.</P>
</FONT><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">matches foo</P>
</B></FONT><FONT FACE="Courier" SIZE=1><P>&gt;&gt;&gt; foo &lt;&lt;&lt;</P>
<P>to be specified</P>
</FONT><FONT SIZE=2><P>Note: that there is no instantiation displayed after the last heading.  The next command displays the matches of a rule that is eligible for the conflict set:</P>
</FONT><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;  </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">matches bar</P>
</B></FONT><FONT FACE="Courier" SIZE=1><P>&gt;&gt;&gt; bar &lt;&lt;&lt;</P>
<P>to be specified</P>
</FONT><FONT SIZE=2><P>(The third CE in this rule is negative, so no matches for 3, with a match for 1 and 2, means the rule can fire.) </P>
</FONT><B><FONT FACE="Helvetica"><LI> </LI>
</FONT><FONT FACE="Helvetica" SIZE=4><LI><!a NAME="_Toc373810115">MAX</LI>
</B></FONT><FONT SIZE=2><P>Given one or more arguments, returns the largest. The elements of compound values are added to the argument list as if they were separate scalar values.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</B></I><FONT SIZE=2><P>(MAX value)</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>value</P>
</B><P>Any RuleWorks expression. The first value determines the valid data type; using mixed types causes a warning message. You may specify any number of value, either compound or scalr.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Return Value</LI>
</B></I><FONT SIZE=2><P>The greatest of the arguments.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Examples</LI>

</B></I><FONT SIZE=2><P>The following table shows several calls to the MAX function and their results:</P>
</FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=589>
<TR><TD WIDTH="45%" VALIGN="TOP">
<B><I><FONT FACE="Helvetica" SIZE=4><LI>Function Call</B></I></FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<B><I><FONT FACE="Helvetica" SIZE=4><LI>Return Value</B></I></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><I><FONT FACE="Helvetica" SIZE=4><LI>Warning Message?</B></I></FONT></TD>
</TR>
<TR><TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><LI>(MAX 3 2.0 1)</LI>
<P>(MAX 3.2 10)</P>
<P>(MAX 3.2 10)</P>
<P>(MAX boy (COMPOUND man woman) girl)</P>
<P>(MAX 3.2 cat 10)</FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT SIZE=2><LI>3</LI>
<P>10</P>
<P>-3.2</P>
<P>WOMAN</P>
<P>10</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT SIZE=2><LI>No</LI>
<P>No</P>
<P>No</P>
<P>No</P>
<P>Yes</FONT></TD>
</TR>
</TABLE>

<FONT SIZE=2>
<P>Note: that ruleworks issues a warning when it finds a value of an invalid data type, but it does process the rest of the arguments list. (See Appendix E for the collating sequences for symbols.)</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>MIN</LI>
</B></FONT><FONT SIZE=2><P>Given one or more arguments, returns the smallest. The elements of compound values are added to the argument list as if they were separate scalar values.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</B></I><FONT SIZE=2><P>(MIN value)</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>value</P>
</B><P>Any RuleWorks expression. The first value determines the valid data type; using mixed types causes a warning message. You may specify any numbert of values, either compound or scalar.</P>

<B><P>Return Value</P>
</B><P>The smallest of the arguments.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Examples</LI>

</B></I><FONT SIZE=2><P>The following table shows several calls to the MIN function and their results:</P>
</FONT>
<TABLE BORDER CELLSPACING=2 BORDERCOLOR="#000000" CELLPADDING=7 WIDTH=568>
<TR><TD WIDTH="46%" VALIGN="TOP">
<B><I><FONT FACE="Helvetica" SIZE=4><LI>Function Call</B></I></FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<B><I><FONT FACE="Helvetica" SIZE=4><LI>Return Value</B></I></FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<B><I><FONT FACE="Helvetica" SIZE=4><LI>Warning Message?</B></I></FONT></TD>
</TR>
<TR><TD WIDTH="46%" VALIGN="TOP">
<FONT SIZE=2><LI>(MIN 3 2.0 2)</LI>
<P>(MIN 3.2 10)</P>
<P>(MIN 3.2 10)</P>
<P>(MIN boy (COMPOUND man woman) girl)</P>
<P>(MIN 3.2 cat 10)</FONT></TD>
<TD WIDTH="21%" VALIGN="TOP">
<FONT SIZE=2><LI>1</LI>
<P>3.2</P>
<P>-10</P>
<P>BOY</P>
<P>3.2</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT SIZE=2><LI>No</LI>
<P>No</P>
<P>No</P>
<P>No</P>
<P>Yes</FONT></TD>
</TR>
</TABLE>

<FONT SIZE=2>
<B><P>Note:</B> that RuleWorks issues a warning when it find a value of an invalid data type, but it does process the rest of the arguments list.</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>MODIFY </LI>
</B></FONT><FONT SIZE=2><P>Changes one or more values in an existing working-memory object. The object must be visible to the active entry block. The object's time-tag is updated but its INSTANCE-ID remains the same.</P>
<B><P>Note:</B> When you change WMOs at the command interpreter prompt, the first Argument to the MODIFY command must be a constant. In contrast, when you change WMOs in a rule, the first Argument to the MODIFY action can be a variable or a call to the GET function.</P>
<P>You can also use MODIFY as a function with the BIND action.</P>


</FONT><B><I><LI>Format (for action) </LI>
</B></I><FONT SIZE=2><P>(MODIFY) ID-variable  {^attribute value-expression}... </P>
</FONT><B><I><LI>Format (for command) </LI>
</B></I><FONT SIZE=2><P>MODIFY instance-id {^attribute value}...)</P>
</FONT><B><I><LI>Arguments(Arguments)</LI>
</I><FONT SIZE=2><P>ID-variable</P>
</B><P>An expression of type INSTANCE-ID, indicating the object to be modified. This Argument can be used in rules only.</P>
<B>
<P>instance-id</P>
</B><P>A constant of type INSTANCE-ID, indicating the object to be modified.  This Argument can be used only at the command interpreter level.</P>
<B>
<P>attribute</P>
</B><P>An attribute name that specifies which value in the object is to be  changed. You must specify a value with each attribute.</P>
<B>
<P>value-expression</P>
</B><P>Any scalar or compound value (if you specify a compound attribute) is a valid Argument to the MODIFY action, including function calls and arithmetic expressions.</P>
<B>
<P>value</P>
</B><P>A scalar atom or a compound value containing constants (if you specify a compound attribute). You cannot use expressions or call functions (except COMPOUND) in an Argument to any command.</P>
</FONT><B><I><LI>Return Value</LI>
</B></I><FONT SIZE=2><P>The MODIFY action returns the INSTANCE-ID atom that identifies the changed WMO.</P>
</FONT><B><I>
<LI>Example</LI>

</B></I><FONT SIZE=2><P>The following  action changes on attribute of a SOFTWARE-OPTION object:</P>
</FONT><FONT FACE="Courier" SIZE=3><P> (modify &lt;the-software&gt; ^media-type FD-35)</P>
</FONT><FONT SIZE=2><P>The equivalent command is shown below:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt;  </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">WM #29</P>
</B></FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P> #29 [EXPAND-PART-SKELETONS:KIWICALC] (KIWICALC ^NAME KIWICALC ^PART-NUM</P>
</FONT><FONT FACE="Courier" SIZE=1><P>BER S-CA-9200 ^PRINTNAME KiwiCalc Spreadsheet Software ^PRICE 29.95 ^IS-EXPANDED YES</P>
<P>RuleWorks&gt;  </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">MODIFY #29 ^MEDIA-TYPE FD-35</P>
</B></FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt;  </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">WM #29</P>
</B></FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P> #29 [ |  | ] (KIWICALC ^MEDIA-TYPE FD-35 ^NAME KIWICALC ^PART-NUMBER S-CA</P>
</FONT><FONT FACE="Courier" SIZE=1><P>-9200 ^PRINTNAME KiwiCalc Spreadsheet Software ^PRICE 29.95 ^IS-EXPANDED YES)</P>
</FONT><FONT SIZE=2><P>See Chapter 4.4 for examples of modifying compound attributes.</P>
</FONT><B><FONT FACE="Helvetica"><LI> </LI>
<LI><!a NAME="_Toc373810116">NOT</LI>
</B></FONT><FONT SIZE=2><P>Performs a logical negation on its operand, that is, returns true when the operand is false and false when the operand is true.</P>

<P>Note: This is a relational operator, not a match predicate. NOT may be used only in relational expressions within IFTHENELSEor WHILEDOactions.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>NOT</B> <I>relation</P>
</I><P>&nbsp;</P>
</FONT><B><I><LI>Operand</LI>
</I><FONT SIZE=2><P>relation</P>
</B><P>The relational expression to be negated. This must evaluate to either true or false.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following code fragment shows the NOT operator in an IFTHENELSEaction:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(if (not (&lt;day&gt; = work-day))</P>
<P>     then (sleep-late)</P>
<P>     else (go-to-work))</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>NTH</LI>
</B></FONT><FONT SIZE=2><P>Accesses the value at the specified index into a compound value. NTH is a stateless function and can be used on either the LHS or RHS.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(NTH</B> <I>compound-value index</I><B>)</P>
</B><P>&nbsp;</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>compound-value</P>
</B><P>The compound value that is to be searched. This argument may be bound compound variable or a function that returns a compound value.</P>

<B><P>Index</P>
</B><P>An integer expression (anything that evaluates to an integer) that specifies the location of the desired value. The index of the first element is 1, not 0.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Return Value</LI>
</B></I><FONT SIZE=2><P>The element value at the specified location in a compound value. If the location does not exist, the function returns NIL.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Examples</LI>

</B></I><FONT SIZE=2><P>The following action prints the first element of a bound compound variable:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(write (crlf) |Slot 1 contains | (NTH &lt;cards&gt; 1) )</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>NEXT </LI>
</B></FONT><FONT SIZE=2><P>Displays the instantiation that the run-time system will select from the conflict set for the act phase of the next recognize-act cycle.  The NEXT command displays the instantiation in the same Format as the CS command, with the addition of the rule-firing counts: </P>
<I>
<P>n</I> (<I>m</I>): <I>rule-name</I> #<I>instance-id-1 time-tag-1</I> m)#<I>instance-id-2 time-tag-2</I>... </P>
<P>where <I>n</I> is the global count and <I>m</I> is the local (to the block invocation) count.</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>NEXT</B> </P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>NONE</P>
</FONT><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following command shows that the next instantiation the run-time system will select from the conflict set is the rule MODIFY-SOFTWARE-MEDIA:35-CHEAPEST acting on objects #38, #32, and #45:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt;  </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">NEXT</P>
</B></FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P> MODIFY-SOFTWARE-MEDIA:35-CHEAPEST #38 71 #32 58 #45 70</P>
</FONT><FONT FACE="Courier"><P> <!a NAME="_Toc373810118"></P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>OBJECT-CLASS </LI>
</B></FONT><FONT SIZE=2><P>Declares an object class and the attributes associated with it. All OBJECT-CLASS declarations must appear before any executable program elements. OBJECT-CLASS declarations can be contained in entry blocks, declaration blocks, or rule blocks.</P>


</FONT><B><I><LI>Format</LI>
</B></I><FONT FACE="Courier" SIZE=1><P>(OBJECT-CLASS) class-name</P>
<P>&#9;&#9;[(INHERITS-FROM parent-class)]</P>
<P>&#9;&#9;{^attribute-name [data-type]</P>
<P>&#9;&#9;&#9;&#9;      [(DEFAULT value)]</P>
<P>&#9;&#9;}</P>
<P>&#9;&#9;{^attribute-name COMPOUND</P>
<P>&#9;&#9;&#9;&#9;      [data-type]</P>
<P>&#9;&#9;&#9;&#9;      [(DEFAULT value)]</P>
<P>&#9;&#9;&#9;&#9;&#9;[(FIL value)]</P>
<P>&#9;&#9;})</P>
</FONT><B><FONT SIZE=2><P>Note:</B> This Format shows one scalar and one compound attribute, for clarity only. RuleWorks does <I>not</I> require that you declare all scalar attributes first, nor that you have at least one scalar attribute. You can declare compound and scalar attributes in any order.</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>class-name</P>
</B><P>The only required Argument, this represents the name of the new object class.  It must be a symbol that is different from all other classes in the block, and must not be a RuleWorks predicate.</P>

<P>If the OBJECT-CLASS declaration is contained in an entry block, and the entry block uses declaration blocks, the class name must also be different from all the classes in the used blocks.</P>

<P>A class name in an entry block may be the same as a class in a rule block, even if the entry block activates the rule block.</P>
<B>
<P>attribute-name</P>
</B><P>Specifies the name of an attribute for the new object class.</P>
<B>
<P>data-type</P>
</B><P>Specifies the data type of an attribute. This Argument is optional, but if you do specify a data type RuleWorks enforces that domain restriction.    The valid data types and their system-defined default values are shown in the RuleWorks Data Types table.</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P><!a NAME="_Toc393858212"></P>
<P>Table 26. RuleWorks Data Types</P>
<P>Name&#9;Default Value</P>
</B></FONT><FONT FACE="NewCenturySchlbk" SIZE=2><P>INTEGER  &#9;0</P>
<P>FLOAT  &#9;0.0</P>
<P>NUMBER  &#9;0</P>
<P>SYMBOL  &#9;NIL</P>
<P>OPAQUE  &#9;%x0</P>
<P>INSTANCE-ID  &#9;#0</P>
<P>          INSTANCE-ID OF  &#9;#0</P>
<P>ANY  &#9;NIL</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1>
</FONT><FONT SIZE=2><P>An attribute typed NUMBER can be assigned either an INTEGER or a FLOAT value.  ANY is the default when no data type is declared. INSTANCE-ID optionally restricts the value to a named object class when this Format is used:</P>

<B><P>INSTANCE-ID OF</B> <I>class-name</I> </P>
</FONT><B><I><LI>Clauses</LI>
</I><FONT SIZE=2><P>INHERITS-FROM</P>
</B><P>Specifies a parent object class from which the class being declared  is to acquire attribute names and characteristics. If present, this clause must precede any attribute names.  </P>
<B>
<P>parent-class &#9;</P>
</B><P>The name of the parent object class. The parent class must be previously declared in the same block.  A subclass cannot inherit from a parent class declared in a different block.</P>
<P>See Table 2-1 in Section 2.1 for a table on restrictions on declaring attributes in a subclass of a parent class.</P>

<B><P>DEFAULT</P>
</B><P>Establishes the initial value for an attribute when an object of this  object class is created. (The default value is ignored if another value is specified in the MAKE action.</P>
</FONT><I><FONT FACE="NewCenturySchlbk" SIZE=2><P>value</I> &#9;The default value must be the same attribute shape as the attribute. That is, scalar attributes must have a scalar default value; compound attributes must have a compound default value.  Use the COMPOUND function to create the default value for a compound attribute.</P>
</FONT><B><FONT SIZE=2><P>COMPOUND</P>
</B><P>Declares the attribute to be compound rather than scalar. See Chapter 2 for details.</P>
<B>
<P>FILL</P>
</B><P>Defines an initial value for certain elements of a compound  value. This filler value is used only when the length of the compound value is increased dynamically but no value is specified for those elements.</P>
<B>
<P>value &#9;</P>
</B><P>The scalar value to be used as a filler. See Chapter 2.3.5 for more information.</P>
</FONT><B><I>
<LI>Example</LI>

</B></I><FONT SIZE=2><P>The following example declares class BOX that inherits from class PART and has two additional compound attributes.</P>
</FONT><FONT FACE="Courier" SIZE=3><P>  (OBJECT-CLASS box</P>
<P>        (inherits-from part)</P>
<P>        ^card-in-slot compound</P>
<P>        ^card-in-slot-obj-id compound)) </P>
</FONT><B><FONT FACE="Helvetica"><LI> </LI>
<LI><!a NAME="_Toc373810119">ON-EMPTY</LI>
</B></FONT><FONT SIZE=2><P>Defines a set of RHS actions that are executed by RuleWorks when it reaches the selection phase of the recognize-act cycle and the conflict set is empty. After the ON-EMPTY actions are executed, the ON-EXIT actions fire (see Figure 5-1)</P>

<P>An ON-EMPTY statement must be contained in an ENTRY-BLOCK. You can use and change the input arguments of the entry block in the ON-EMPTY actions.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(ON-EMPTY</P>
</B><P>&#9;&#9;<U>action</U><B>)</P>
<P>&nbsp;</P>
</FONT><I><LI>Argument</LI>

</I><FONT SIZE=2><P>action</P>
</B><P>Any RuleWorks RHS action. You can specify one or more actions.</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4><P>&nbsp;</P>

<LI>ON-ENTRY</LI>
</B></FONT><FONT SIZE=2><P>Defines a set of RHS actions that are executed immediately after an entry block is calle and before any rules fire. After the ON-ENTRY actions are executed, the RuleWorks run-time proceeds to the match phase of the first recognize-act cycle.</P>

<P>An ON-ENTRY statement must be contained in an ENTRY-BLOCK. You can use and change the input arguments of the entry block in the ON-ENTRY actions.</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(ON-ENTRY</P>
</B><P>&#9;&#9;action<B>)</P>
<P>&nbsp;</P>
</FONT><I><LI>Argument</LI>

</I><FONT SIZE=2><P>action</P>
</B><P>Any RuleWorks RHS action. You can specify one or more actions.</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>ON-EVERY</LI>
</B></FONT><FONT SIZE=2><P>Defines a set of RHS actions that are executed by RuleWorks after the act phase of one recognize-act cycle and before the match phase of the next cycle.</P>

<P>If the last rule fired executes a RETURN or QUIT action, the ON-EVERY actions are not executed. When the conflict set is empty, the ON-EMPTY actions are executed but the ON-EVERY actions are not. (See Figure 5-1 for an illustration.)</P>

<P>An ON-EVERY statement must be contained in an ENTRY-BLOCK. You can use and change the input arguments of the entry block in the ON-EVERY actions.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(ON-EVERY</P>
</B><P>&#9;&#9;action<B>)</P>
<P>&nbsp;</P>
</FONT><I><LI>Argument</LI>

</I><FONT SIZE=2><P>action</P>
</B><P>Any RuleWorks RHS action. You can specify one or more actions.</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>ON-EXIT</LI>
</B></FONT><FONT SIZE=2><P>Defines a set of RHS actions that are executed by RuleWorks just before control returns to the caller of the entry block.</P>

<P>The ON-EXIT actions are executed when the reason for control being returned is that the conflict set is empty or that a RETURN action was executed. The ON-EXIT actions are not executed after a QUIT action is executed. (See Figure 5-1 for an illustration.)</P>

<P>An ON-EXIT statement must be contained in an ENTRY-BLOCK. You can use and change the input arguments of the entry block in the ON-EXIT actions.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(ON-EXIT</P>
</B><P>&#9;<I>action</I><B>)</P>
</B><P>&nbsp;</P>
</FONT><B><I><LI>Argument</LI>

</I><FONT SIZE=2><P>action</P>
</B><P>Any RuleWorks RHS action. You can specify one or more actions.</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>OPENFILE </LI>
</B></FONT><FONT SIZE=2><P>Opens a file for access in a specified mode, and associates it with a file identifier.</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(OPENFILE  <I>file-id filespec mode</I>)</P>
</FONT><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>file-id</P>
</B><P>A symbol that represents the file identifier with which the specified file is  to be associated.   </P>
<B>
<P>filespec</P>
</B><P>The file specification for the file to be opened. If you are opening a  file for input, the file must already exist.</P>
<B>
<P>mode</P>
</B><P>A keyword that indicates whether the specified file is to be opened for input or output.  The following table, OPENFILE Keywords, lists the keywords you can specify.</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P><!a NAME="_Toc393858213">Table</B> <B>27 OPENFILE Keywords</P>
<P>Mode  &#9;Effect </P>
</B></FONT><FONT FACE="NewCenturySchlbk" SIZE=1><P> OPENFILE KeywordsIN  &#9;The action opens an existing file for reading only.   </P>
<P>OUT  &#9;The action creates a new file and opens it for writing only.   </P>
<P>APPEND  &#9;The action opens an existing file for writing and sets the file pointer to the end of the file.   </P>
<P>&nbsp;</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following action opens the file ORDER.DAT for input and associates it with the file identifier INFIL:</P>
</FONT><FONT FACE="Courier" SIZE=3><P> (OPENFILE INFIL ORDER.DAT IN)</P>
</FONT><FONT SIZE=2><P>The equivalent command is:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt;  </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">OPENFILE INFIL ORDER.DAT IN</P>
</B></FONT><P> </P>
<B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810120">OR</LI>
</B></FONT><FONT SIZE=2><P>Performs a logical inclusive disjunction on its two operands, that is, returns true when either one or both of its operands is true.</P>
<B><P>Note:</B>  &#9;This is a relational operator, not a match predicate. OR may be used only in relational expressions within IF...THEN...ELSE... or  WHILE...DO... actions.</P>


</FONT><B><I><LI>Format</LI>

</B><FONT SIZE=2><P>relation</I> <B>OR</B> <I>relation</P>
</I><LI><!a NAME="_Toc373810121"></FONT><B><FONT FACE="Helvetica" SIZE=4>Operands</LI>
</FONT><FONT SIZE=2><P>relation</P>
</B><P>The relational expressions to be combined. These operands must evaluate to either true or false.</P>


</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following code fragment shows the OR operator in an IF ... THEN ... ELSE ... action:</P>
</FONT><FONT FACE="Courier" SIZE=3><P> (if ((&lt;weather&gt; = sunny) or (&lt;weather&gt; = warm))</P>
<P>    then (do_outdoor_chores)</P>
<P>    else (do_indoor_chores)) </P>
</FONT><P> </P>
<B><FONT FACE="Helvetica"><LI> </LI>
<LI><!a NAME="_Toc373810122">P (Production)</LI>
</B></FONT><FONT SIZE=2><P> Synonym for &quot;rule&quot;, the Production statement is provided for compatibility with DEC OPS5 Version 4.0A and other OPS systems. See RULE for details.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>

</B></I><FONT FACE="Courier" SIZE=3><P>(P production-name</P>
<P>    (condition-element)</P>
<P>     <FONT FACE="Wingdings">&#224;</FONT>
</P>
<P>    (action))</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>POSITION</LI>
</B></FONT><FONT SIZE=2><P>Scans the specified compound variables for the specified scalar value. POSITION is a stateless function and can be used on either the LHS or RHS.</P>

<P>By default, POSITION test for identity; you can specify a different predicate. The function always stops at the first occurrence of the predicate evaluating to true.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</B></I><FONT SIZE=2><P>(POSITION compound-var [predicate] scalar-value)</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>compound-var</P>
</B><P>A compound variable bound to the compound value that is to be scanned.</P>

<B><P>predicate</P>
</B><P>A predicate that specifies the comparison between elements of the compound value and the scalar value. This argument is optional; if you do not specify a predicate, RuleWorks uses the default identity predicate.</P>

<P>You can use any scalar predicate except containment and non-containment.</P>

<B><P>scalar-value</P>
</B><P>A scalar constant or a bound variable.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Return Value </LI>
</B></I><FONT SIZE=2><P>The integer index of the first element in compound-var that satifies the comparison specified by the predicate with the scalar-value; or zero if no element of compound-var satisfies the comparison.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Examples</LI>

</B></I><FONT SIZE=2><P>Given the following object:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=3><P>#28 69 (BOX ^CARD-IN-SLOT (COMPOUND MEMORY MEMORY MEMORY KEYBOARD FD-35) ^CARD-IN-SLOT-OBJ-ID (COMPOUND #31 #39 #37 #45) ^NAME BOX ^PART-NUMBER KI-9200 ^PRINTNAME Kiwi-9200 CPU Base Unit ^PRICE 999.95 ^IS-EXPANDED YES)</P>
</FONT><FONT SIZE=2>
<P>And assuming &lt;CARDS&gt; is bound to ^CARD-IN-SLOT, the following function call returns the value 1:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(POSITION &lt;CARDS&gt; MEMORY)</P>
</FONT><FONT SIZE=2>
<P>The following attribute-value tests use the containment and similarity predicates in conjunction with the POSITION function to test two consequtive elements of a compound value:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=3><P>^list {[+] ~= color &lt;list&gt;}</P>
<P>^list [(position &lt;list&gt; ~=color) + 1] &lt;&gt; blue</P>
</FONT><FONT SIZE=2>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4><LI>PPCLASS </LI>
</B></FONT><FONT SIZE=2><P>Displays the parents and attributes of the specified object class.  The attributes are listed under the name of the object class that declared them, with their shape, domain restriction, and default and fill values (if any).</P>
<P>Alternatively, displays the hierarchy of classes defined in the active block.</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>PPCLASS</B> <I>[ object-class ]</P>
</FONT><B><LI>Argument</LI>
</I><FONT SIZE=2><P>object-class</P>
</B><P>The name of an object class that is visible to the active entry block.</P>
<P>This Argument is optional. If you supply no Argument, PPCLASS displays the class structure of the active block.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following example shows the PPCLASS output for the class BOX from the sample program, KIWI.</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt;  </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">PPCLASS BOX</P>
</B></FONT><FONT FACE="Courier" SIZE=1><P>PART<BR>
^PART-NUMBER<BR>
^NAME symbol<BR>
^PRICE float<BR>
^IS-EXPANDED symbol (default NO)</P>
<P>BOX<BR>
^CARD-IN-SLOT compound symbol<BR>
^CARD-IN-SLOT-OBJ-ID compound instance-id</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810123">PPWM</LI>



</B></FONT><FONT SIZE=2><P>Displays all objects, or all instances of a specified class, or only those instances that match a specified object pattern. Object patterns are similar to CEs and can include attributes specified with values, tests, disjunctions, and conjunctions. Object patterns cannot include variables or function calls.</P>

<P>The PPWM command displays the following information about an object:</P>


<UL>
<LI>Its INSTANCE-ID</LI></UL>



<UL>
<LI>The name of the construct that last modified the object (for example, a rule or ON- clause). If you last modified the object at the interpreter prompt, the construct name is the symbol RUL.</LI></UL>



<UL>
<LI>Its class name, its attributes, and the attributes values</LI></UL>


<P>Scalar attributes whose value is NIL, and compound attributes whose value is (COMPOUND) are not displayed unless you have declared a DEFAULT value for the attribute.</P>

<P>The system displays this information in the following format:</P>

<P>#INSTANCE-ID [rule-name](class-name attribute-1 value-1 attribute-2 value-2 )</P>

<P>If you do not specify a pattern, the command displays all the visible WMOs.</P>
<P>&nbsp;</P>





</FONT><B><I><LI>Format</LI>
</B></I><FONT SIZE=2><P>PPWm  [class-name]    ^attribute </FONT><FONT SIZE=6>    </FONT><FONT SIZE=2>value</P>
<P>&#9;&#9;&#9;&#9;   Predicate value</P>
<P>&#9;&#9;&#9;&#9;   &lt;&lt;value&gt;&gt;</P>
<P>&#9;&#9;&#9;&#9;   {test}</P>

<P>&nbsp;</P>
</FONT><B><I><LI>Arguments</LI>




</I><FONT SIZE=2><P>class-name</P>
</B><P>A symbol that names an object class that is visible to the active entry block. If you specify a class that has inherited subclasses, objects of those subclasses are also displayed.</P>

<B><P>attribute</P>
</B><P>An attribute that describes a characteristic of the objects to be displayed and contains the corresponding value. If you specify any attributes, you must also specify at least one value for each attribute.</P>

<P>If you specify a compound attribute, you can index it with a left bracket, an integer constant, and a right bracket ([index}).</P>

<B><P>predicate</P>
</B><P>Any of the valid match predicate.</P>

<B><P>value</P>
</B><P>This argument must be a scalar atom. Compound values, created with the COMPOUND function, are not allowed.</P>

<B><P>&nbsp;</P>
<P>test</P>
</B><P>A value, a predicate followed by a value, or a disjunction of values:</P>

<P></P>




</FONT><B><FONT FACE="Helvetica" SIZE=4>



</FONT><I>



<LI>Examples</LI>
</B></I><FONT SIZE=2><P>The following commands illustrate the syntax for compound attributes:</P>

<P>RuleWorks&gt;ppwm box ^card-in-slot [3] keyboard</P>
<P>&#9;     #28 [CHOOSE-SLOTS:PLACE-NONMEMORY] (BOX ^CARD-IN-SLOT (COMPOUND MEMORY MEMORY KEYBOARD ^CARD-IN-SLOT-OBJ-ID (COMPOUND #31 #39 #37 ^PART-NUMBER ki-9200 ^NAME Kiwi-9200 CPU Base Unit ^PRICE 999.95 ^IS-EXPANDED YES)</P>
<P>RuleWorks&gt;ppwm box ^card-in-slot [+} memory</P>
<P>~28 {CHOOSE-SLOTS:PLACE-NONMEMORY] (BOX ^CARD-IN-SLOT (COMPOUND MEMORY MEMORY KEYBOARD) ^CARD-IN-SLOT-OBJ-ID (COMPOUND #31 #39 #37) ^part-NUMBER KI-9200 ^NAME Kiwi-9200 CPU Base Unit ^PRICE 999.95 ^IS-EXPANDED YES)</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4><P>&nbsp;</P>
<P>&nbsp;</P>
<P>QUIT </P>
</B></FONT><FONT SIZE=2><P>Terminates execution of the current image and returns control to the operating system.  If there are other actions in the rule, they are not executed.  The ON-EXIT actions are not executed after a QUIT action.  You can return a value with QUIT.  Valid Arguments for QUIT include $FAILURE and $SUCCESS, as well as any integer.  RuleWorks substitutes either 0 or 1, as appropriate for the operating system, for $FAILURE and $SUCCESS.     </P>

<P>Entering QUIT at the command interpreter is equivalent to  pressing Ctrl/Z on VMS systems, Ctrl/D on UNIX systems.</P>
</FONT><B><I><LI>Format (for action)</LI>
</I><FONT SIZE=2><P> (QUIT  </B>[value-expr]<B>) </P>
</FONT><I><LI>Format (for command) </LI>
</I><FONT SIZE=2><P>QUIT </B>[return-value]</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>value-expr</P>
</B><P>The value returned by RuleWorks. This Argument is optional; it can be an expression that evaluates to a scalar value, $FAILURE, or $SUCCESS.  This Argument can be used in rules only.</P>
<B>
<P>return-value</P>
</B><P>The value returned by RuleWorks. This Argument is optional; it can be a constant, $FAILURE, or $SUCCESS. You cannot use expressions or function calls (except to COMPOUND) as Arguments to any command.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following command exits from the command interpreter and returns control to the operating system:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#800000"><P>RuleWorks&gt;<B> QUIT</P>
</B></FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>$</P>
</FONT><FONT SIZE=2><P>The following example uses the QUIT action to terminate execution with  a return value indicating success.</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(rule success</P>
<P>        (context ^$ID &lt;context&gt; ^task complete)</P>
<P>   --&gt;</P>
<P>        (remove &lt;context&gt;)</P>
<P>        (quit $success))</P>
</FONT><FONT SIZE=2>
<P>When this rule fires, the QUIT action causes the run-time  system to stop executing recognize-act cycles immediately. The compiler provides a warning when any actions follow RETURN or QUIT actions.</P>

<P>The entry block's ON-EVERY and ON-EXIT statements are not executed after a QUIT action.</P>
<LI><!a NAME="_Toc373810124"></LI>
</FONT><B><FONT FACE="Helvetica" SIZE=4><LI>RBREAK </LI>
</B></FONT><FONT SIZE=2><P>Controls breakpoints on rules and rule groups.</P>

<P>When used with no Arguments, the command displays a numbered list of the rules and groups that have breakpoints set. When used with the ON and OFF keywords, respectively, RBREAK sets and clears breakpoints for rules and groups. Breakpoints for rule groups are set or cleared for all rules in the group by a single command.</P>

<P>When the run-time system encounters a breakpoint on a rule, it finishes the current recognize-act cycle, displays a message in the following Format, and invokes the command interpreter:      </P>

<P> %RUL-I-RBREAK, RBREAK encountered on rule<I>[</I>group<I>]</I>  <I>name</I><BR>
 %RUL-I-BREAKNOTED, Execution paused by break.</P>


</FONT><B><I><LI>Format</LI>
</B></I><FONT FACE="Courier" SIZE=1><P> <BR>
<B>ON</B> <BR>
 {<BR>
   <I>rule-name</I> <BR>
   <I>rule-group-name</I> <BR>
 }...<BR>
<B>OFF</B><BR>
 {<BR>
   <I>rule-name</I> <BR>
   <I>rule-group-name</I> <BR>
   <I>number</I> <BR>
 }</P>
</FONT><FONT SIZE=2>
<P>The keywords and Arguments are optional. If you do not specify the name of a rule, the command displays the names of the rules and groups for which breakpoints are set.</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>rule-name</P>
</B><P>A symbol that names a rule. You can specify one or more.</P>

<B><P>rule-group-name</P>
</B><P>A symbol that names a rule group. You can specify one or more.</P>
<B>
<P>*</P>
</B><P>All rules and groups that have breaks set.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following command displays the names of the rules of which breakpoints are set:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P> RuleWorks&gt;  </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">rbreak</P>
</B></FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P> 1 VERIFY-CONFIGURATION:MOUSE-PORT</P>
</FONT><FONT FACE="Courier" SIZE=1><P> 2 POP-ACTIVE-CONTEXT</P>
</FONT><FONT SIZE=2><P>The next commands delete one breakpoint and sets another:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">rbreak off 2</P>
</B></FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">rbreak on choose-slots:place-nonmemory</P>
</B></FONT><FONT SIZE=2><P>The following command redisplays the names of the rules for which  breakpoints are set:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">rbreak</P>
</B></FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P> 1 VERIFY-CONFIGURATION:MOUSE-PORT</P>
</FONT><FONT FACE="Courier" SIZE=1><P> 2 CHOOSE-SLOTS:PLACE-NONMEMORY</P>
</FONT><FONT SIZE=2>
<P>The following dialog shows what happens when the breakpoint is reached:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">run</P>
</B></FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>%RUL-I-RBREAK, RBREAK encountered on rule CHOOSE-SLOTS:PLACE-NONMEMORY</P>
</FONT><FONT FACE="Courier" SIZE=1><P>%RUL-I-BREAKNOTED, Execution paused by break</P>
<P>&nbsp;</P>
<P>RuleWorks&gt;  </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">next</P>
</B></FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P> CHOOSE-SLOTS:PLACE-NONMEMORY #47 62 #28 65 #37 56</P>
</FONT><B><FONT FACE="Helvetica"><LI> </LI>
</FONT><FONT FACE="Helvetica" SIZE=4><LI><!a NAME="_Toc373810125">REMOVE </LI>
</B></FONT><FONT SIZE=2><P>Deletes one or more objects from working memory. The object must be visible to the active entry block. Once an object has been removed, it can no longer be accessed. However, variables bound to the values of attributes of that object can still be used.</P>
<B><P>Note:</B>  When you delete WMOs at the command interpreter prompt, the first Argument to the REMOVE command must be a constant. In contrast, when you delete WMOs in a rule, the first Argument to the REMOVE action can be a variable or a call to the GET function.</P>


</FONT><B><I><LI>Format (for action) </LI>
</I><FONT SIZE=2><P>(REMOVE </B><I>ID-expr</I>... )</P>
</FONT><B><I><LI>Format (for command)</LI>
</B></I><FONT SIZE=2><P>REMOVE  {</P>
<I><P>    Instance-id</I>... </P>
<P>    *<BR>
}</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>ID-expr</P>
</B><P>A RuleWorks expression that evaluates to a value of type INSTANCE-ID, indicating the object to be deleted. You can specify one or more IDs.  This Argument can be used in rules only.</P>
<B>
<P>instance-id</P>
</B><P>A constant of type INSTANCE-ID, indicating the object to be deleted.  This Argument can be used only at the command interpreter level.</P>
<B>
<P>*</P>
</B><P>You can specify an asterisk (*) to delete all visible objects.  Objects whose class declarations are neither contained in nor used by the active entry block remain in working memory.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following command deletes all visible objects:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P> RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">REMOVE *</P>
</B></FONT><FONT SIZE=2><P>The following command deletes the objects whose identifiers are  #3 and #4:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">REMOVE #3 #4</P>
</B></FONT><FONT SIZE=2><P>Consider the following rule:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(rule make-context-active</P>
<P>        (context ^name &lt;context-name&gt; ^$ID &lt;context-id&gt;)</P>
<P>     --&gt;</P>
<P>        (make active-context ^name &lt;context-name&gt;)</P>
<P>        (remove &lt;context-id&gt;))</P>
</FONT><FONT SIZE=2><P>The REMOVE action deletes the object bound to the variable &lt;CONTEXT-ID&gt;.  </P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810126">REMOVE-EVERY </LI>
</B></FONT><FONT SIZE=2><P>Deletes all the working memory objects that are instances of the specified class or its subclasses. The class must be visible to the active entry block. Once an object has been removed, it can no longer be accessed. However, variables bound to values of attributes of that object can still be used.</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(REMOVE-EVERY  </B><I>class-name</I>... <B>)</P>
</FONT><I><LI>Argument</LI>
</I><FONT SIZE=2><P>class-name</P>
</B><P>An expression that evaluates to a symbol names an object class. The declaration of this class must be contained in or used by the active entry block.</P>

<P>You can also use the symbol $ROOT, to remove all visible objects.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following example removes working-memory objects when the conflict set is empty:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(on-empty</P>
<P>(write |Sorry... Program error. No satisfied rules".| (crlf))</P>
<P>    (remove-every control-context)</P>
<P>    (remove-every local)</P>
<P>    (remove-every input-thing)</P>
<P>    (remove-every error)</P>
<P>    (remove-every part)</P>
<P>    (remove-every input-count)</P>
<P>    (remove-every total-cost)</P>
<P>    (quit 0)) </P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810127">RESTORESTATE</LI>
</B></FONT><FONT SIZE=2><P>Clears and then restores working memory, the conflict set, the GENATOM counter, and the INSTANCE-ID generator to the state  recorded in a file produced by the SAVESTATE action or command.</P>

<P>The working memory objects contained in the SAVESTATE file must be visible to the active entry block. A run-time warning is generated if the files contains any objects whose class declarations are neither private to nor shared by the active entry block.</P>

<P>RESTORESTATE clears all working memory objects before loading the new state;  therefore, variable bindings are lost.</P>

<P>After a RESTORESTATE action, the GENATOM and GENINT functions produce     atoms that are different from any that were recorded in the saved file. They may repeat atoms that were generated before the RESTORESTATE action was executed.</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(RESTORESTATE  </B><I>filespec</I> <B>)</P>
</FONT><I><LI>Argument</LI>
</I><FONT SIZE=2><P>filespec</P>
</B><P>The file specification for a file previously produced by the  SAVESTATE action or command. The action uses the contents of the file to  restore the state of working memory and the conflict set. See Chapter 12 for restrictions on file names.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following action clears and then restores the contents of working memory and the conflict set to the same state recorded in the file CONFIG.DAT.</P>
</FONT><FONT FACE="Courier" SIZE=3><P> (restorestate config.dat) </P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810128">RETURN</LI>
</B></FONT><FONT SIZE=2><P>Stops the firing of rules in the current entry block, executes the ON-EXIT actions (if any), and passes control back to the caller of the entry block.  The RETURN action is executed immediately, so any actions that follow it are not executed and a warning is generated.</P>

<P>This action has one optional Argument, the value to be returned. Your RETURN action(s) should match the RETURNS clause of your ENTRY-BLOCK declaration. For example, if your entry block has no RETURNS clause, a RETURN action with an Argument generates a compiler warning. Similarly, if your entry block declares a symbolic return value, a RETURN action with a numeric Argument generates a run-time warning.</P>

<P>RETURN actions are valid in entry blocks but not in rule blocks.</P>
<P>Executing more than one RETURN action generates a warning.  If a value is being returned from the entry block, the value of the last RETURN action executed is used.</P>

<P>When you execute a RETURN command at the RuleWorks interpreter prompt, and the return is to a RuleWorks entry block, no action of the caller is executed before the prompt reappears. This allows you to see working memory in exactly the state the callee left it.</P>


</FONT><B><I><LI>Format (for action) </LI>
</I><FONT SIZE=2><P>(RETURN)  </B><I>[value-expr]</I> )</P>
</FONT><B><I><LI>Format (for command) </LI>
</B></I><FONT SIZE=2><P>RETURN <I>[value]</P>
</FONT><B><LI>Arguments</LI>
</I><FONT SIZE=2><P>value-expr</P>
</B><P>The value returned by the entry block. This Argument is optional; it can be any expression that evaluates to the structure (scalar or compound) and domain (integer, symbol, and so on) specified in the ENTRY-BLOCK declaration.</P>
<B>
<P>value</P>
</B><P>The value returned by the entry block. This Argument is optional; it may be a constant or a call to the COMPOUND function. You cannot use any other functions or expressions at the command line.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following example shows a simple rule that returns a value:</P>
</FONT><FONT FACE="Courier" SIZE=3><P> (rule when-done-return-number-filled</P>
<P>      (task ^name last-step)</P>
<P>      - (order ^status unfilled)</P>
<P>      (totals ^filled-orders &lt;count&gt;)</P>
<P>  --&gt;</P>
<P>      (return &lt;count&gt;)) </P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810129">RJUST </LI>
</B></FONT><FONT SIZE=2><P>Causes the WRITE action to right-justify output in a field of a specified  width. This function is useful for writing a column of numbers with decimal positions aligned.</P>
<B><P>Note: </B>The RJUST function is valid only inside the WRITE action.Calls to the RJUST function can follow calls to the CRLF and TABTO functions  but must directly precede the value being written.</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(RJUST </B><I>width</I> )</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>width</P>
</B><P>An integer expression (anything that evaluates to an integer) that indicates the width of the field in which output is to be placed. If the output being written requires more character positions than you specify for the field, the WRITE action behaves as if the RJUST function had not been specified. That is, the action inserts one space and then writes the output.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following WRITE action writes a vertical list of numbers right-justified in a column 10 characters wide:</P>
</FONT><FONT FACE="Courier" SIZE=3><P> (WRITE (CRLF) (RJUST 10) |10.06|</P>
<P>       (CRLF) (RJUST 10) |2.45|</P>
<P>       (CRLF) (RJUST 10) |56.00|</P>
<P>       (CRLF) (RJUST 10) |250.00|)</P>
</FONT><FONT SIZE=2><P>The output is:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>     10.06</P>
<P>      2.45</P>
<P>     56.00</P>
<P>    250.00 </P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810130">RULE </LI>
</B></FONT><FONT SIZE=2><P>Executes right-hand-side actions when left-hand-side conditions are met and  the rule has been selected from the conflict set.</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(RULE <I>rule-name</I>)</P>
</B><P>&#9;&#9;(<I>condition-element)</I>...</P>
<P>&#9;&#9;(<I>action</I> )... )</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>rule-name</P>
</B><P>A unique symbol that names the rule being created. The symbol cannot be the name of another rule, a rule-group, a method, or a catcher that already exists in the entry block.</P>
<B>
<P>condition-element</P>
</B><P>A specified pattern against which working memory objects can be matched. Condition elements can be negative, can contain conjunctions and disjunctions, and can bind variables that are used in other condition elements and in actions on the right-hand side.</P>

<P>You can specify one or more condition elements.  You cannot put a negative CE first.  See Chapter 3 for information on CEs.</P>
<B>
<P>action</P>
</B><P>Any RHS action. You can specify one or more actions.  See Chapter 4 for information on actions.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following rule, named CLOSE-INPUT-FILE:DO-IT, contains three CEs and three actions.  The second CE binds a $ID variable.,  &lt;MY-INPUT-THING&gt;, which is deleted by the REMOVE action.  The third CE binds an attribute variable, &lt;C&gt;, which is used in the WRITE action.</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(rule close-input-file:do-it</P>
<P>        (active-context ^name close-input-file)</P>
<P>        (input-thing ^item END-OF-FILE ^$ID &lt;my-input-thing&gt; )</P>
<P>        (input-count ^count &lt;c&gt;)</P>
<P>     --&gt;</P>
<P>        (closefile infil)</P>
<P>        (remove &lt;my-input-thing&gt;)</P>
<P>        (write (crlf) |Read| (&lt;c&gt; - 1) |items from input.| (crlf))) </P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810131">RULE-BLOCK</LI>
</B></FONT><FONT SIZE=2><P>Names a collection of rules so that they can be shared among multiple entry blocks. Rule blocks may contain rules, catchers, and declarations, but no RETURN actions and no ON- constructs.</P>

<P>A rule block must be activated by a RuleWorks entry block. Rule blocks can use declaration blocks but they cannot activate other rule blocks.</P>

<P>The rules in a rule block cannot match objects of classes declared inside the entry block; they can match only objects of classes declared inside the rule block or in a declaration block used by the rule block. Likewise, rules in the entry block cannot match objects of classes declared inside the rule block.</P>

<P>Each rule block can have its own STRATEGY clause. However, all rule blocks activated by an entry block must have the same strategy as that entry block.  It is a run-time warning to activate rule blocks that have different strategies.</P>

<P>The block must be closed with an END-BLOCK declaration.</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(RULE-BLOCK <I>block-name</I> </B>)</P>
<P>&#9;&#9;[<B>(USES</B> decl-block-name<B>)</B>]</P>
<P>&#9;&#9;[<B>(STRATEGY </P>

<P>&#9;&#9;&#9;&#9;&#9;   )])</P>
</FONT><I><LI>Argument</LI>
</I><FONT SIZE=2><P>block-name</P>
</B><P>A symbol that names the block. This name must be distinct from all other block names in your program and must also be a valid C function name:</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=2><P>&#9;cannot contain the characters  </FONT><FONT FACE="Courier" SIZE=2>"&lt;&gt;[]%^-</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=2><P>&#9;less than 32 characters long</P>
<P>&#9;different from all C keywords</P>
</FONT><B><I><LI>Clauses</LI>

</I><FONT SIZE=2><P>USES</P>
</B><P>Indicates which declaration blocks are shared by the entry block. This clause is optional.  </P>
</FONT><I><FONT FACE="NewCenturySchlbk" SIZE=2><P>decl-block-name</I>... &#9;A symbol that names a declaration block. You can specify one or more declaration blocks.</P>
</FONT><B><FONT SIZE=2><P>STRATEGY</P>
</B><P>Specifies the conflict-resolution strategy (see Chapter 1). This clause is optional. If you do not declare a strategy, the default MEA is used.  </P>
</FONT><B><FONT FACE="NewCenturySchlbk" SIZE=1><P>LEX</B> &#9;The lexicographic-sort strategy.</P>
<B><P>MEA</B> &#9;The means-ends analysis strategy.</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810132">RULE-GROUP</LI>
</B></FONT><FONT SIZE=2><P>Names a collection of rules inside a single entry block or rule block.  If you put each MEA group in a separate rule group, you can then enable TRACE for rule groups and see output for the MEA groups without seeing each individual rule.</P>

<P>Rule groups may contain rules and catchers, but no declarations, no methods, and no ON- constructs.</P>
<P>The rules in a rule group can match objects of classes declared in the containing block and objects of classes declared in a declaration block that is used by the containing block.</P>

<P>The group must be terminated with an END-GROUP declaration.</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(RULE-GROUP </B><I>group-name</I> <B>)</P>
</FONT><I><LI>Argument</LI>

</I><FONT SIZE=2><P>group-name</P>
</B><P>A symbol that names the group. This name must be distinct from the names of all other groups, rules, and catchers in the containing block.</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810133">RUN </LI>
</B></FONT><FONT SIZE=2><P>Causes the run-time system to execute recognize-act cycles. You can optionally specify the number of recognize-act cycles the system executes.</P>

<P>RuleWorks entry blocks start running by default. Use the DEBUG action or the Debug compiler switch to pause execution and invoke the RuleWorks command interpreter.</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>RUN</B> <I>[integer]</P>
</FONT><B><LI>Argument</LI>
</I><FONT SIZE=2><P>integer</P>
</B><P>The number of global recognize-act cycles the run-time system is to execute. This Argument is optional. If you do not specify an integer, the run-time system executes recognize-act cycles until no rules are satisfied or until a RETURN or QUIT action, or a breakpoint interrupts execution.</P>
<B><P>Note:</B>   If a breakpoint interrupts program execution, the run-time system does not execute the number of recognize-act cycles indicated by the integer.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following command starts executing recognize-act cycles:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P> RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">RUN</P>
</B></FONT><FONT SIZE=2><P>The following command executes four recognize-act cycles:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">RUN 4</P>
</FONT><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810134">SAVESTATE</LI>
</B></FONT><FONT SIZE=2><P>Copies to a file the state of working memory, the conflict set, the GENATOM and GENINT counter, and the INSTANCE-ID generator. You can later use the ADDSTATE or RESTORESTATE action or command to add to or overwrite the current memory with the contents of the file.</P>

<P>Only objects that are visible to the active entry block are saved.</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(SAVESTATE </B><I>filespec</I> )</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>filespec</P>
</B><P>The file specification for the file to which the state of working memory and the conflict set is to be copied.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following action copies the state of working memory and the conflict set to the file CONFIG.DAT.</P>
</FONT><FONT FACE="Courier" SIZE=3><P> (savestate config.dat)</P>
</FONT><FONT SIZE=2><P>The equivalent command is:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">savestate config.dat</P>
</FONT><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810135">SHOW SPACE</LI>
</B></FONT><FONT SIZE=2><P>Displays information about working memory and the RuleWorks symbol table. The information consists of the current number of objects and  symbol-table entries, the amount of memory that these currently occupy, and  the largest value that these have reached during this execution of the program.</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>SHOW SPACE</B> </P>
</FONT><B><I><LI>Arguments(NONE)</LI>
<LI>Example</LI>

</B></I><FONT SIZE=2><P>The following example shows the SHOWSPACE command:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P> RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">SHOW SPACE</P>
</B></FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P> WORKING-MEMORY OBJECTS SYMBOL TABLE ENTRIES</P>
</FONT><FONT FACE="Courier" SIZE=1><P>Current number - 10 Current number - 97</P>
<P>Current space used - 0.6 Kbytes Current space used - 4.4 Kbytes</P>
<P>Maximum number - 12 Maximum number - 97</P>
<P>Maximum space used - 0.7 Kbytes Maximum space used - 4.4 Kbytes</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810136">SHOW VERSION </LI>
</B></FONT><FONT SIZE=2><P>Displays the current version of the RuleWorks compiler (and the copyright notice).</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>SHOW VERSION</B> </P>
</FONT><B><I><LI>Arguments(NONE)</LI>
<LI>Example</LI>

</B></I><FONT SIZE=2><P>The following </P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">sho ver</P>
</B></FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P> RuleWorks <FONT FACE="Symbol">&#228;</FONT>
 - Version 2.0 EFT1 (11-18-94)</P>
</FONT><FONT SIZE=2><P>Copyright <FONT FACE="Symbol">&#227;</FONT>
 1994-1995 Digital Equipment Corporation. All Rights Reserved.</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810137">SPECIALIZE </LI>
</B></FONT><FONT SIZE=2><P>Converts an instance of a parent class to an instance of a descendent class. The converted object's INSTANCE-ID does not change as a result of this action. You can also set or change any attributes belonging to the descendent class.</P>
</FONT><B><FONT FACE="NewCenturySchlbk" SIZE=2><P>Note:</B>  &#9;When you convert WMOs at the command interpreter prompt, the first Argument to the SPECIALIZE command must be a constant. In contrast, when you convert WMOs in a rule, the first Argument to the SPECIALIZE action can be a variable or a call to the GET function.</P>


</FONT><B><I><LI>Format (for action) </LI>
</I><FONT SIZE=2><P>(SPECIALIZE </B>ID-variable new-class-name-expr</P>
<P>                           [ {attribute-name-expr value-expr}... ]  )</P>
</FONT><B><I><LI>Format (for command) </LI>
</I><FONT SIZE=2><P>SPECIALIZE </B>instance-id new-class-name</P>
<P>                           [ {attribute-name value}... ]</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>ID-variable</P>
</B><P>An expression of type INSTANCE-ID, indicating the object to be specialized. This Argument can be used in rules only.</P>
<B>
<P>new-class-name-expr</P>
</B><P>An expression that evaluates to a symbol that names an object class that inherits from the current class of the object being specialized.</P>
<B>
<P>attribute-name-expr</P>
</B><P>A symbol or bound variable that evaluates to an attribute declared in or inherited by the new class. This Argument is optional; if you do specify an attribute, you must also specify a value for it.</P>

<P>You can specify any number of attribute-value pairs.</P>
<B>
<P>value-expr</P>
</B><P>Any valid RuleWorks expression that evaluates to the same structure as the attribute.</P>
<B>
<P>instance-id</P>
</B><P>A constant of type INSTANCE-ID, indicating the object to be specialized. The object must be visible to be active entry block. This Argument can be used only at the command interpreter level.</P>
<B>
<P>new-class-name</P>
</B><P>A symbol that names an object class that inherits from the current class of the object being specialized.</P>
<B>
<P>attribute-name</P>
</B><P>A symbol that names an attribute declared in or inherited by the new class. This Argument is optional; if you do specify an attribute, you must also specify a value for it.</P>

<P>You can specify any number of attribute-value pairs.</P>
<B>
<P>value</P>
</B><P>A value that has the same structure as the attribute.</P>
</FONT><B><I><LI>Return Value</LI>
</B></I><FONT SIZE=2><P>The SPECIALIZE action returns the INSTANCE-ID atom that identifies the converted object.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following rule shows one possible use of the SPECIALIZE action:</P>
</FONT><FONT FACE="Courier" SIZE=3><P> (RULE animal-now-identified-as-a-zebra</P>
<P>       ; if current class is the generic class ANIMAL</P>
<P>      (animal ^$ID &lt;My-animal&gt; ^$object-class animal ^name &lt;n&gt;)</P>
<P>      (identification ^name &lt;n&gt; ^is-a zebra)</P>
<P> --&gt;</P>
<P>      (SPECIALIZE &lt;My-animal&gt; zebra; new class is ZEBRA</P>
<P>                 ^inter-breeds-with (compound horse donkey))) </P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810138">SQL-ATTACH</LI>
</FONT><FONT SIZE=5>
</B></FONT><FONT SIZE=2><P>Specifies the database of interest by executing a DECLARE SCHEMA statement. You can specify the source of the schema either by providing the database filespec itself or by providing a pathname to the CDD schema definition.</P>

<B><P>Note: </B>that the actual attachment to the database usually does not occur until the first executable SQL statement after this action is processed.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=3><P>SQL-ATTACH </B><I>database-spec ( DBKEY-scope ]</P>
<P>&nbsp;</P>
</FONT><B><LI>Arguments</LI>
</I><FONT SIZE=3><P>Database-spec</P>
</B></FONT><FONT SIZE=2><P>This argument must be either </FONT><FONT SIZE=1>FILENAME db-filespec or PATHNAME db-pathname. </FONT><FONT SIZE=2>The keyword FILENAME may be omitted; the keyword PATHNAME is required.</P>

<P>A logical name may be used for all or part of the database filespec or for the CDD pathname.</P>

</FONT><B><FONT SIZE=3><P>DBKEY-scope</P>
</B></FONT><FONT SIZE=2><P>A keyword that specifies the duration of validity of database key values, either TRANSACTION or ATTACH. ATTACH scoping means that a database key value is valid for the entire time your program is attached to a given database, rather than just for the duration of a single transaction. TRANSACTION scoping is the default.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Examples</LI>

</B></I><FONT SIZE=2><P>The following example uses the FILENAME method. MY_DB is a logical name pointing to the complete filespec for the database.</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(SQL-ATTACH FILENAME MY_DB)</P>
</FONT><FONT SIZE=1>
</FONT><FONT SIZE=2><P>The next example shows the same attachment except that the scope or duration of DBKEY validity is   the total time your program is attached to the database, rather than the duration of the transaction as in the previous example (by default).</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(SQL-ATTACH FILENAME MY_DB ATTACH )</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
</FONT><FONT SIZE=3><P>&nbsp;</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4><LI>SQL-COMMIT</LI>
</FONT><FONT SIZE=4>
</B></FONT><FONT SIZE=3><P>Completes the current SQL transaction and makes permanent any changes made to the database during the transaction. This action executes a COMMIT statement.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</B></I><FONT SIZE=3><P>SQL-COMMIT</P>
</FONT><FONT SIZE=4><P>&nbsp;</P>
</FONT><B><I><LI>Arguments</LI>

</B></I><FONT SIZE=4><P>None</P>

<P>&nbsp;</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>SQL-DELETE</LI>
</FONT><FONT SIZE=5>
</B></FONT><FONT SIZE=2><P>Deletes all or selected records from a specified database table, by executing a DELETE FROM statement. This action does not remove any RuleWorks objects; it is up to you to use REMOVE actions to do that.</P>

<P>The SQL-DELETE action can be executed only within the context of a READ WRITE transaction, which you must explicitly start with an SQL-START action.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=3><P>SQL-DELETE </B><I>table-name [WHERE-clause]</P>
<P>&nbsp;</P>
</FONT><B><LI>Arguments</LI>
</I><FONT SIZE=3><P>table-name</P>
</B></FONT><FONT SIZE=2><P>Specifies the database table from which rows are to be deleted.</P>

</FONT><B><FONT SIZE=3><P>WHERE-clause</P>
</B></FONT><FONT SIZE=2><P>Optionally specifies which records are to be deleted within the target table. If the where-clause is omitted, the default is to delete all records in the table specified in the first argument.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Examples</LI>

</B></I><FONT SIZE=2><P>The first example deletes all records in table W1:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(SQL-DELETE  W1)</P>
</FONT><FONT SIZE=1>
</FONT><FONT SIZE=2><P>The next example deletes only those records in table W1 that satisfy the WHERE clause:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(SQL-DELETE  W1 | WHERE fld1 = 10 AND fld2 = </FONT><FONT FACE="Courier" SIZE=1>'some text' | )</P>
</FONT><FONT SIZE=1>
</FONT><FONT SIZE=2><P>The records deleted are those with field fld1 equal to the value 10, and field fld2 equal to the string 'some text'. All other records in W1 are unaffected.</P>
</FONT><B><FONT FACE="Helvetica" SIZE=3>
</FONT><FONT FACE="Helvetica" SIZE=4><LI>SQL-DETACH</LI>
</FONT><FONT SIZE=5>
</B></FONT><FONT SIZE=3><P>Detaches your program from any database previously attached by an SQL-ATTACH action. This action executes a FINISH statement and a COMMIT statement on the current transaction, if any.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</B></I><FONT SIZE=2><P>SQL-DETACH</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Arguments</LI>

</B></I><FONT SIZE=3><P>None.</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>SQL-FETCH-EACH</LI>
</B></FONT><FONT SIZE=2><P>For each selected database record, binds field value(s) to specified RuleWorks variable(s) and then performs one or more RHS actions. This action executes a SELECT statement.</P>

<P>You can create or change instances of any OBJECT-CLASS in the RHS actions performed by the SQL-FETCH-EACH action. The OBJECT-CLASS does not have to match the database table name, nor do the attribute names have to match the database field names.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=3><P>SQL-FETCH-EACH</B> <I>&lt;var&gt;... (select-expr) </P>
<P>&#9;       (RHS-action)...</P>
<P>&nbsp;</P>
</FONT><B><LI>Arguments</LI>
</B></I><FONT SIZE=4><P>&lt;var&gt;</P>
</FONT><FONT SIZE=2><P>One or more RuleWorks variables to which database field values are to be bound. These variables must not be bound prior to the SQL-FETCH-EACH action. They can be used only in the RHS actions provided as the third argument.</P>

</FONT><FONT SIZE=4><P>select-expr</P>
</FONT><FONT SIZE=2><P>An SQL select expression that limits the fetch to specific database table(s) and record(s) and specifies which database fields are to be fetched. This expression can include variables bound prior to the SQ~FETCH-EACH action (either on the LHS or RHS), but cannot include variables specified in the first argument.</P>

</FONT><FONT SIZE=4><P>RHS-action</P>
</FONT><FONT SIZE=2><P>One or more RuleWorks RHS actions to be performed for each database record fetched. Note that these actions may not include any other SQL interface actions.</P>

<P>These actions can use both variables bound prior to the SQL-FETCH-EACH action and variables specified in the first argument. If these actions bind any variables, those bindings are maintained after the SQL-FETCH-EACH action is executed.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Examples</LI>

</B></I><FONT SIZE=2><P>The first example fetches records from database table tbl_1, and binds the values of fields fld1 and fld2 to the RuleWorks variables &lt;v1&gt; and &lt;v2&gt;. These variables are then used in two MAKE actions, creating new instances of classes W1 and W2. The actions are repeated for each database record that satisfies the FROM and WHERE clauses of the select expression.</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier New" SIZE=1><P>(SQL-FETCH-EACH  &lt;v1&gt; &lt;v2&gt;  (SELECT fld1, fld2 FROM tbl_1 WHERE fld3 = 1)</P>
<P>&#9;(MAKE  w1  <B>^a1  </B>&lt;v2&gt;  ^a2  tbl_1) </P>
<P>&#9;(MAKE  w2  ^a3  &lt;v1&gt;  ^a4  (&lt;v1&gt; + &lt;v2&gt;)))</P>
</FONT><FONT SIZE=1>
</FONT><FONT SIZE=2><P>The previous example uses symbols in the select expression. The following example uses RuleWorks variables that are (presumably) bound earlier in the rule that contains this SQL-FETCH-EACH action. The optional vertical bars ( | ) around the constant parts of the select expression allow the compiler to generate more efficient code.</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(SQL-FETCH &lt;v1&gt; &lt;v2&gt; (|SELECT * FROM| &lt;table-name&gt; |WHERE fld3= |&lt;val&gt;)</P>
<P>&#9;(MAKE w1 ^a1 &lt;v2&gt; ^a2 tbl_1)</P>
<P>&#9;(MAKE w2 ^a3 &lt;v1&gt; ^a4 (&lt;v1&gt; + &lt;v2&gt;)))</P>
</FONT><FONT SIZE=3>
<P>In this example, all the fields in the database are selected, because of the wildcard (*). However, only the first two fetched are used. Any extra field values are ignored.0</P>

<P>&nbsp;</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4><LI>SQL-FETCH-AS-OBJECT</LI>
</FONT><FONT SIZE=5>
</B></FONT><FONT SIZE=2><P>Makes WMOs from selected database records by executing a SELECT statement.</P>

<P>This action creates instances of a single OBJECT-CLASS only, even if it is retrieving data from multiple tables (for example, a join between source tables). The OBJECT-CLASS matches the (first) table name specified in the FROM clause of the select expression. SQLFETCH-AS-OBJECT creates one new object from each database record selected.</P>

<P>The database field names and the attribute names of the OBJECT-CLASS must match. Any selected fields that do not have a corresponding attribute are ignored. Any attributes that do not have a corresponding field are set to their DEFAULT values (if one was declared) or NIL. Attributes that correspond to fields whose value is "missing" are also set to NIL.</P>

<P>You can use the SQL-FETCH-AS-OBJECT action as the value argument to a BIND action. The variable argument of the BIND action is bound to a compound value that contains the INSTANCE-IDs of all the fetched WMOs.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=3><P>SQL-FETCH-AS-OBJECT</B> <I>select~expr</P>
<P>&nbsp;</P>
</FONT><B><LI>Argument</LI>
</I><FONT SIZE=3><P>select-expr</P>
</B></FONT><FONT SIZE=2><P>An SQL select expression that restricts the fetch to specific database records and specifies which database fields are to be fetched. The database table specified in the select expression is used as the object class name for the objects created by the SQL-FETCH-AS-OBJECT operation.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Return Value</LI>
</B></I><FONT SIZE=2><P>When used as in the second argument to the BIND action, the SQL-FETCH-AS-OBJECT action returns a compound value that contains the INSTANCE-IDs of all the objects created.</P>
<P>&nbsp;</P>
</FONT><B><I>
<LI>Examples</LI>

</B></I><FONT SIZE=2><P>In the first example, selected records from table W1 are fetched and used to create objects. Only records with field fld1 having a value less than field fld2 are fetched. (This is a numeric comparison; the last two examples use character string fields.)</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(SQL-FETCH-AS-OBJECT  SELECT * FROM W1 WEERE fld1 &lt; fld2 )</P>
</FONT><FONT SIZE=1>
</FONT><FONT SIZE=2><P>Any objects created by this action are instances of OBJECT-CLASS W1, as specified in the FROM clause. All record fields are used and mapped into object attributes, as requested by the use of an asterisk (*) in the select expression.</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(SQL-FETCH-AS-OBJECT  SELECT fld1, fld2, fld3 FROM W1 WHERE fld1 &lt; fld2)</P>
</FONT><FONT SIZE=1>
</FONT><FONT SIZE=2><P>The example above refines the first example by fetching fields fld1, fld2, and fld3 only. Again, as in the previous example, only records with field fld1 value less than that of fld2 are fetched.</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(SQL-FETCH-AS-OBJECT SELECT DISTINCT fld1, fld2 FROM W1 WHERE fld1 &lt; fld2)</P>
</FONT>
<B><FONT SIZE=1><P>&nbsp;</P>
<P>&nbsp;</P>
<P>&nbsp;</P>
</B></FONT><FONT SIZE=2><P>This example illustrates the DISTINCT qualifier, which restricts the new W1 objects to unique combinations of fld1 and fld2 values. Without the DISTINCT qualifier this action can yield multiple duplicate objects, depending on the database contents.</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(SQL-FETCH-AS-OBJECT  SELECT fld1, fld2, DBKEY From W1 WHERE fld1 &lt; fld2 )</P>
</FONT><FONT SIZE=1>
</FONT><FONT SIZE=2><P>This example fetches the DBKEY for each database record, along with the fld1 and fld2 values. The OBJECT-CLASS declaration for W1 in this case must include a DBKEY attribute, so that the action has a place to put the DBKEY value.</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(SQL-FETCH-AS-OBJECT  SELECT W1. *, DBKEY FROM W1 WHERE fld1 &lt; f1d2)</P>
</FONT><FONT SIZE=1>
</FONT><FONT SIZE=2><P>The action above shows how to select all fields and capture the DBKEY values. The required syntax is not the SELECT *, DBKEY that you might expect.</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(SQL-FETCH-AS-OBJECT SELECT * FROM W1 WHERE fld1 = 'abc' AND fld2 = '&lt;var&gt;')</P>
</FONT><FONT SIZE=1>
</FONT><FONT SIZE=2><P>This example uses string field comparisons in the select expression. Only those records that have fld1 equal to the string 'ABC' and fld2 equal to the string bound to the RuleWorks variable &lt;var&gt; are selected and fetched. Note that RuleWorks automatically converts the symbol 'abc' to the string 'ABC'.</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(bind </FONT><FONT FACE="Courier" SIZE=2>&lt;x&gt; </FONT><FONT FACE="Courier" SIZE=1>(SQL-FETCH-AS-OBJECT</P>
<P>SELECT * FROM W1 WHERE fld1 = 'abc' AND fld2 = '&lt;var&gt;'))</P>
</FONT><FONT SIZE=1>
</FONT><FONT SIZE=2><P>This example shows the previous SQL-FETCH-AS-OBJECT action used as an argument to the BIND action.</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>SQL-INSERT</LI>
</FONT><FONT SIZE=5>
</B></FONT><FONT SIZE=2><P>Stores new records in the specified database table by executing an INSERT statement. The fields to be set, and their new values, are provided in the second argument.</P>

<P>This action can be executed only within the context of a READ WRITE transaction, which you must explicitly start with an SQL-START action.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=3><P>SQL-INSERT </B><I>table-name SQL-expr</P>
<P>&nbsp;</P>
</FONT><B><LI>Arguments</LI>
</I><FONT SIZE=3><P>Table-name</P>
</B></FONT><FONT SIZE=2><P>Specifies the database table into which the new records are to be inserted.</P>

</FONT><B><FONT SIZE=3><P>SQL-expr</P>
</B></FONT><FONT SIZE=2><P>An SQL expression that specifies the target fields and their values.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Examples</LI>

</B></I><FONT SIZE=2><P>In this example a new record is created in database table tbl_l, with its field fld2 set to 123 and its field fld5 set to the string 'test'. The SQL expression is enclosed in vertical bars because it includes parentheses.</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(SQL-INSERT  tbl_1  | (f1d2, fld5) VALUES (123, 'test') |)</P>
</FONT><FONT SIZE=1>
</FONT><FONT SIZE=2><P>The next example is similar to the previous one, except that one of the field names is defined at run-time by the RuleWorks variable &lt;v2&gt; and the value for field fld5 is given by the RuleWorks variable &lt;v2&gt;.</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(SQL-INSERT tbl_1  |(|  &lt;v1&gt;  |, fld5) VALUES (456,|  '&lt;v2&gt;'  |)| )</P>
</FONT><FONT SIZE=1>
</FONT><FONT SIZE=2><P>Since fld5 is a character (string) field, the value substituted for &lt;v2&gt; must be enclosed in single quotes. </P>

<B><P>Note:</B> that both unquoted and quoted variables must be preceded and followed by whitespace, as in this example. Also, parentheses that are passed to SQL must be enclosed in vertical bars.</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>SOL-INSERT-FROM-OBJECT</LI>
</FONT><FONT SIZE=4>
</B></FONT><FONT SIZE=3><P>Stores the contents of a specified object in a new database record by executing an INSERT statement. The record is inserted into the database table that has the same name object's OBJECT~CLASS. The values of the object's </FONT><B><FONT SIZE=1>^$ID </B></FONT><FONT SIZE=3>and </FONT><B><FONT SIZE=2>^$INSTANCE-OF </B></FONT><FONT SIZE=3>attributes are not written to the database, even if the database explicitly provides fields </FONT><B><FONT SIZE=2>with </B></FONT><FONT SIZE=3>those names.</P>

<P>This action can be executed only within the context of a READ WRITE transaction, which you must explicitly start with a SQL-START action.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>SQL-INSERT-FROM-OBJECT </B></FONT><I><FONT SIZE=3>&lt;^$ID-variable&gt;</P>
<P>&nbsp;</P>
</FONT><B><LI>Argument</LI>
</B><FONT SIZE=3><P>&lt;^$ID-variable&gt;</P>
<P>A variable bound to the value of the ^$ID attribute of the object to be stored.</P>
</I></FONT><B><FONT SIZE=4><P>&nbsp;</P>
</FONT><I><LI>Example</LI>

</B></I><FONT SIZE=3>
<P>In this example the object identified by the &lt;W&gt; object identifier is inserted into the database, into the table having the same name as the &lt;W&gt; object's OBJECTCLASS- After the SQL-INSERT-FROM-OBJECT, you are free to remove the &lt;W&gt; object or leave it in working memory.</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(SQL-INSERT-FROM-OBJECT  &lt;W&gt;)</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>SQL-ROLLBACK</LI>
</FONT><FONT SIZE=5>
</B></FONT><FONT SIZE=3><P>Undoes any changes to the database made during the current transaction and completes the transaction. This action executes a ROLLBACK statement.</P>

<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>SQL-ROLLBACK</P>
</B><P>&nbsp;</P>
</FONT><B><I><LI>Arguments</LI>

</B></I><FONT SIZE=3><P>None.</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>SQL-START</LI>
</FONT><FONT SIZE=5>
</B></FONT><FONT SIZE=2><P>Executes a SET TRANSACTION statement to start a transaction with the specified options. These options can include a READ ONLY versus a READ WRITE transaction, and whether to retain any locks obtained on records during the course of the transaction.</P>

<P>You end the transaction started by this action with an SQL-COMMIT, SQL-DETACH, or SQL-ROLLBACK action.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=3><P>SQL-START</B> [txn-options]</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=3><P>Txn-options</P>
</B></FONT><FONT SIZE=2><P>Optional list of desired SQL transaction options. If this argument is not provided, a READ ONLY transaction is the default.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Examples</LI>

</B></I><FONT SIZE=2>
<P>The first example starts a READ ONLY transaction by default, because it has no transaction options.</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(SQL-START)</P>
</FONT><FONT SIZE=1>
</FONT><FONT SIZE=2><P>The following example shows an update transaction whose options request that any records accessed during the transaction have locks retained on them, so that the records may be updated again (in protected write mode).</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(SQL-START  |READ WRITE RESERVING W1 FOR PROTECTED WRITE| )</P>
</FONT><FONT SIZE=1>
</FONT><FONT SIZE=2><P>The vertical bars in this example are not required, but they do make the action more efficient.</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>SQL-UPDATE</LI>
</FONT><FONT SIZE=4>
</B></FONT><FONT SIZE=2><P>Modifies the contents of selected database records, where the fields to be modified and their new values are specified in the second argument.</P>

<P>This action can be executed only within the context of a READ WRITE transaction, which must be explicitly started by an SQL-START action.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=3><P>SQL-UPDATE </B><I>table-name SET-clause [WHERE-clause] </P>
<P>&nbsp;</P>
</FONT><B><LI>Arguments</LI>
</I><FONT SIZE=3><P>Table-name</P>
</B></FONT><FONT SIZE=2><P>Specifies database table to be modified.</P>

</FONT><B><FONT SIZE=3><P>SET-clause</P>
</B></FONT><FONT SIZE=2><P>An SQL expression to define which fields are to be updated within the target table, and the new values for these fields.</P>

</FONT><B><FONT SIZE=3><P>WHERE-clause</P>
</B></FONT><FONT SIZE=2><P>An optional select expression that specifies which database records are updated.</P>
<P>If it is omitted, the default action is to update all records in the specified table.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Examples</LI>

</B></I><FONT SIZE=2><P>The first example sets the numeric fld1 field value in all W1 table records, if any, to zero, and sets the char field fld2 to 'SOME TEXT')</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(SQL-UPDATE  W1 SET fld1 = 0, fld2 = 'some text' )</P>
</FONT><FONT SIZE=1>
</FONT><FONT SIZE=2><P>The second example modifies any and all records in the W1 table whose previous field a1 value was the old value &lt;val&gt; (bound in LHS of the rule) and field whose field a2 value was &lt;va12&gt;. These records have al set to &lt;new-val&gt; (bound on the RHS of the rule).</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(rule sql-update-example</P>
<P>(W1 ^</FONT><FONT FACE="Courier" SIZE=1>$ID </FONT><FONT FACE="Courier" SIZE=1>&lt;W1&gt; </FONT><B><FONT FACE="Courier" SIZE=3>^</B></FONT><FONT FACE="Courier" SIZE=1>a1{</FONT><B><FONT FACE="Courier" SIZE=1> </B></FONT><FONT FACE="Courier" SIZE=1>&lt; 10 &lt;val&gt; } </FONT><B><FONT FACE="Courier" SIZE=3>^</B></FONT><FONT FACE="Courier" SIZE=1>a2</FONT><B><FONT FACE="Courier" SIZE=1> </B></FONT><FONT FACE="Courier" SIZE=1>&lt;val2&gt;</P>
<P> <FONT FACE="Wingdings">&#224;</FONT>
</P>
<P>(bind &lt;new-val&gt; (&lt;val&gt; + 10))</P>
<P>(modify &lt;W1&gt; </FONT><B><FONT FACE="Courier" SIZE=3>^</B></FONT><FONT FACE="Courier" SIZE=1>a1</FONT><B><FONT FACE="Courier" SIZE=1> </B></FONT><FONT FACE="Courier" SIZE=1>&lt;new-val&gt;)</P>
<P>(SQL-UPDATE W1 SET al = &lt;new-val&gt; WHERE al = &lt;val&gt;, a2 = &lt;val2&gt; ))</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>SQL-UPDATE-FROM-OBJECT</LI>
</FONT><FONT SIZE=5>
</B></FONT><FONT SIZE=2><P>Uses the attribute values of an object to modify corresponding data fields in one or more existing database records. The values of the object's ^$ID and ^$INSTANCE-OF attributes are not written to the database, even if the database explicitly provides fields with those names.</P>

<P>This action can only be executed within the context of a READ WRITE transaction, which you must explicitly start with an SQL~START action.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=3><P>SQL-UPDATE-FROM-OBJECT</B> <I>&lt;$ID-variabl&gt; [where-clause ]</P>
<P>&nbsp;</P>
</FONT><B><LI>Arguments</LI>
</I><FONT SIZE=3><P>&lt;$ID-variable&gt;</P>
</B></FONT><FONT SIZE=2><P>A variable bound to the </FONT><B><FONT SIZE=1>^$ID </B></FONT><FONT SIZE=2>attribute of the object to be used. The OBJECT-</P>
<P>CLASS name of the associated object specifies the database table that is modified.</P>

</FONT><B><FONT SIZE=3><P>WHERE-clause</P>
</B></FONT><FONT SIZE=2><P>Optionally identifies which database records are to be modified using the object attribute values. If it is omitted, the default action is to update all records.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Examples</LI>

</B></I><FONT SIZE=2><P>The first example uses the attribute values in the object whose INSTANCE-ID is bound to &lt;W&gt; to modify database records whose field fld1 is equal to the value bound to the RuleWorks variable &lt;var1&gt; and whose character field fld2 is equal to the value bound to &lt;var2&gt;. This WHERE clause may or may or not be sufficiently restrictive to make the SQL-UPDATE-FROM-OBJECT action modify only one database record.</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(SQL-UPDATE-FROM-OBJECT &lt;W&gt; WHERE fld1 = &lt;var1&gt; AND f1d2 = '&lt;var2&gt;')</P>
</FONT><FONT SIZE=1>
</FONT><FONT SIZE=2><P>The database table containing the record(s) to be modified is the table with the same name as the OBJECT-CLASS of the object identified by the $ID variable </FONT><FONT SIZE=5>&lt;W1&gt;. </FONT><FONT SIZE=2>Note that the white space around the quoted variable </FONT><FONT SIZE=1>('&lt;var2&gt;' </FONT><FONT SIZE=2>in this example) is required.</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(rule sql-update-from-object-example</P>
<P>(W1 ^$ID &lt;W1&gt; <B>^a1</FONT><FONT FACE="Courier" SIZE=1>  </B></FONT><FONT FACE="Courier" SIZE=1>{ &lt; 10 &lt;val&gt; ) <B>^a2</FONT><FONT FACE="Courier" SIZE=1> </B></FONT><FONT FACE="Courier" SIZE=1>&lt;val2&gt;)</P>
<P> <FONT FACE="Wingdings">&#224;</FONT>
</P>
<P>(modify &lt;w1&gt; ^a1</FONT><B><I><FONT FACE="Courier" SIZE=1> </B></I></FONT><FONT FACE="Courier" SIZE=1>(&lt;val&gt; + 10))</P>
<P>(SQL-UPDATE-FROM-OBJECT &lt;w1&gt; WHERE al = &lt;val&gt; AND a2 = &lt;val2&gt;))</P>
</FONT><FONT SIZE=1>
</FONT><FONT SIZE=2><P>The above example modifies any and all records in the W1 table whose previous field al value was the old value &lt;val&gt; (bound in LHS of the rule) and whose field a2 value was &lt;val2&gt;. These records have field al set to the newly-computed value of the </FONT><FONT SIZE=1>^A1 </FONT><FONT SIZE=2>attribute (the object was modified just before the SQL-UPDATE-OBJECT action).</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>SUBCOMPOUND</LI>
</B></FONT><FONT SIZE=2><P>Creates a new compound value that is a subrange of an existing compound value.  SUBCOMPOUND is a stateless function and can be used on the LHS or RHS.</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(SUBCOMPOUND </B><I>compound-val index-1 index-2</I> )</P>
</FONT><B><I><LI>Arguments</LI>




</I><FONT SIZE=2><P>compound-val</P>
</B><P>The compound value from which a subrange is returned. This Argument can be a bound compound variable or a function that returns a compound value.</P>
<B>
<P>index-1 index-2</P>
</B><P>The positions of the first and last elements in the subrange, respectively. These Arguments can be either of the following:</P>

<UL>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=2><LI>Anything that evaluates to an integer greater than zero</LI>
<LI>The special symbol  </FONT><FONT FACE="Courier" SIZE=2>$LAST</LI></UL>

</FONT><FONT SIZE=2>
<P>The <I>index-1</I> Argument must be less than or equal to the <I>index-2</I> Argument.</P>
<B>
<P>Note:</B> that $LAST may not be used as part of an expression; it must stand alone.</P>





</FONT><B><I><LI>Example</LI>




</B></I><FONT SIZE=2><P>The following rule uses the SUBCOMPOUND function to remove the first element of a compound value:</P>

</FONT><FONT FACE="Courier" SIZE=3><P> (rule pop-stack</P>
<P>      (agenda ^$ID &lt;my-agenda&gt; ^tasks &lt;tasks&gt; )</P>
<P>   --&gt;</P>
<P>      (modify &lt;my-agenda&gt; ^tasks (SUBCOMPOUND &lt;tasks&gt; 2 $LAST))) </P>





</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810139">SUBSYMBOL</LI>
</B></FONT><FONT SIZE=2><P>Creates a new symbol value that is a fragment of an existing symbol value. SUBSYMBOL is a stateless function and can be used on either the LHS or RHS.</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(SUBSYMBOL </B><I>symbol-val index-1 index-2</I> )</P>
</FONT><B><I><LI>Arguments</LI>




</I><FONT SIZE=2><P>symbol-val</P>
</B><P>The symbol value from which a fragment is returned. This Argument can be a bound symbol variable or a function that returns a symbol value.</P>
<B>
<P>index-1 index-2</P>
</B><P>The positions of the first and last characters in the return value, respectively. These Arguments can be either of the following:</P>

<UL>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=2><LI>Anything that evaluates to an integer greater than or equal to one</LI>
<LI>The special symbol  </FONT><FONT FACE="Courier" SIZE=2>$LAST</LI></UL>

</FONT><FONT SIZE=2>
<P>The <I>index-1</I> Argument must be less than or equal to the <I>index-2</I> Argument.</P>
<P>Note that  $LAST may not be used as part of an expression; it must stand alone.</P>

<P>Return Value</P>
<P>A symbol that contains the specified fragment of the input symbol. If the fragment is specified incorrectly or does not exist, the function returns the empty symbol value, 11.</P>




</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810140">SYMBOL</LI>
</B></FONT><FONT SIZE=2><P>Converts any value into a symbol. SYMBOL is a stateless function and can be used on either the LHS or RHS.</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(SYMBOL </B><I>value-expr</I> )</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>value-expr</P>
</B><P>An expression that evaluates to the value to be converted.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Return Value</LI>
</B></I><FONT SIZE=2><P>The symbolic atom that corresponds to the specified value. In other words, the atom of type Symbol whose print form is identical to the print form of the argument.</P>

<P>The print form of a compound value includes a space between the elements, but does not include the function name COMPOUND or its parentheses. If the compound is too long to fit in a symbol, it is truncated.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>NYI</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810141">SYMBOL_LENGTH </LI>
</B></FONT><FONT SIZE=2><P>Returns the number of characters in a symbol. SYMBOL-LENGTH is a stateless function and can be used on either the LHS or RHS.</P>

<P>(See also the LENGTH function, which returns the number of elements in a compound value.)</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(SYMBOL-LENGTH  </B><I>symbol-val</I> <B>)</P>
</FONT><I><LI>Argument</LI>
</I><FONT SIZE=2><P>symbol-val</P>
</B><P>The symbolic value to be measured. This Argument can be a bound symbolic variable or a function that returns a symbolic value.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Return Value</LI>
</B></I><FONT SIZE=2><P>An integer that specifies the number of characters in the symbol.</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4><P><!a NAME="_Toc373810142">TABTO </P>
</B></FONT><FONT SIZE=2><P>Causes the WRITE action to start writing output in a specified column.</P>
<B><P>Note:</B>   The TABTO function is valid only inside the WRITE action.</P>
</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(TABTO </B><I>column</I> )</P>
</FONT><B><I><LI>Argument</LI>
</I><FONT SIZE=2><P>column</P>
</B><P>An integer expression that indicates the column in which the WRITE action is to start writing output. If you specify a column that is to the left of the last column in which output is written, the WRITE action writes the output on a new line, starting at the specified column.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following WRITE action displays the headers of three columns:</P>
</FONT><FONT FACE="Courier" SIZE=3><P> (WRITE (CRLF) (TABTO 10) NUMBER</P>
<P>               (TABTO 25) AMOUNT</P>
<P>               (TABTO 40) DATE)</P>
</FONT><FONT SIZE=2><P>The output is:</P>
</FONT><FONT FACE="Courier" SIZE=3><P>NUMBER&#9;&#9;AMOUNT&#9;&#9;DATE </P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810143">TRACE </LI>
</B></FONT><FONT SIZE=2><P>Displays or changes the run-time system's trace setting, which controls the amount of information the system displays while executing a program.</P>
<B><P>Note:</B>  The TRACE action in source code is effective only when the entry block that contains it was compiled with the DEBUG qualifier set to YES or MAYBE.</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>TRACE</B>  </P>
<P>[</P>

<B><P></B>&#9;ON           trace-name...</P>
<P>   &#9;OFF         *  </P>

<P>]</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>trace-name</P>
</B><P>The name of a trace setting, which are shown in the table, Trace Settings.  You can supply one or more names.</P>
<B><P>*</P>
</B><P>All trace settings shown in the table, Trace Settings.</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P><!a NAME="_Toc393858214">Table 28. Trace Settings</P>
<P>Name &#9;Information Displayed</P>
</B></FONT><FONT FACE="NewCenturySchlbk" SIZE=1><P>{ENTRY-BLOCK}   &#9;Entry blocks being entered or exited</P>
<P> {EB}</P>
<P>RULE &#9;Global and local rule firing counts and instantiation executed</P>
<P>{RULE-GROUP}&#9;Rule group name added to RULE trace information<BR>
{RG}</P>
<P>WM &#9;Objects being created, changed, or deleted from working memory</P>
<P>CS &#9;Instantiations into and out of the conflict set</P>
<P>PM &#9;Rules into and out of program memory</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>&nbsp;</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following command displays the current trace level:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P> RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">TRACE</P>
</B></FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>ENTRY-BLOCK RULE-GROUP RULE WM</P>
</FONT><FONT SIZE=2><P>The following commands change and redisplay the trace setting:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">TRACE OFF RG RULE</P>
</B></FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">TRACE</P>
</B></FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>ENTRY-BLOCK WM</P>
</FONT><FONT SIZE=2><P>For examples of trace output, see Chapter 9.9.</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810144">WBREAK</LI>
</B></FONT><FONT SIZE=2><P>Controls breakpoints on WMOs that match a specified pattern.</P>

<P>When used with no Arguments, the command displays a numbered list of the object patterns that have breakpoints set. When used with the ON and OFF keywords, respectively, RBREAK sets and clears breakpoints for object patterns.</P>

<P>Any rule that makes, copies, modifies, specializes, or removes an object that matches a pattern triggers the breakpoint on that pattern.  When the run-time system encounters a breakpoint on an object pattern,  it completes the current recognize-act cycle and displays messages in the format below, and invokes the command interpreter:  </P>

<P>%RUL-I-WBREAK, WBREAK encountered on <I>class-name</I>  <B>#</B><I>instance-id</I> <BR>
%RUL-I-BREAKNOTED, Execution paused by break</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>WBREAK</B>  </P>
<P>&#9;[</P>
<P>&#9;&#9;ON object pattern</P>
<P>&#9;&#9;OFF    {</P>
<P>&#9;&#9;&#9;object-pattern</P>
<P>&#9;&#9;&#9;number</P>
<P>&#9;&#9;&#9;*</P>
<P>&#9;&#9;}</P>
<P>&#9;]</P>
</FONT><B><I><LI>Arguments(Keywords)</LI>
</I><FONT SIZE=2><P>ON</P>
</B><P>Sets a new breakpoint on an object pattern.</P>
<B>
<P>OFF</P>
</B><P>Clears the existing breakpoint on an object pattern.</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>object-pattern</P>
</B><P>An expression, similar to a CE, that defines which objects cause a break. The object pattern must include the name of an object class that is visible to the active entry block, and may include any number of attribute-value tests.</P>

<P>If the class name in the object pattern has inheriting subclasses, objects of those subclasses also match the pattern.</P>
<B>
<P>number</P>
</B><P>An integer corresponding to an object pattern that currently has a breakpoint set. You get a list of integers and their patterns when you give the WBREAK command with no Arguments.</P>
<B><P>*</P>
</B><P>You can use an asterisk (star) with the OFF keyword to mean "clear all breakpoints on WMOs".</P>
</FONT><B><I>
<LI>Example</LI>

</B></I><FONT SIZE=2><P>The following is an example of the WBREAK command:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">wbreak on control-context</P>
</B></FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">run</P>
</B></FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>&lt;FAC&gt;-I-WBREAK, WBREAK encountered on ACTIVE-CONTEXT #2</FONT><FONT FACE="Courier" SIZE=1><BR>
=&gt;WM: #2 [MAKE-CONTEXT-ACTIVE] (ACTIVE-CONTEXT ^NAME TASKS-TO-DO)<BR>
&lt;=WM: #1 [ | main | ON-ENTRY] (CONTEXT ^NAME TASKS-TO-DO)</P>
<P>%RUL-I-BREAKNOTED, Execution paused by break</P>
<P>RuleWorks&gt; </P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810145">WHILEDO</LI>
</B></FONT><FONT SIZE=2><P>Repeatedly executes one or more RHS actions as long as a relational expression remains true. In other words, provides a loop in the flow of control.</P>
<P>&nbsp;</P>


</FONT><B><I><LI>Format</LI>
</B></I><FONT SIZE=2><P>(WHILE (rel-expr)</P>
<P>&#9; DO RHS-action)</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>rel-expr</P>
</B><P>A relational expression that determines whether RHS actions are to be executed. This argument must evaluate to eithe rtrue or false. It may not contain any SQL functionc.</P>

<B><P>Note:</B> RuleWorks does not have Boolean values. Therefore, this argument must be a comparison of two expressions. It must not be a single value. For example, RuleWorks does not allow (WHILE (TRUE) DO).</P>

<B><P>RHS-action</P>
</B><P>Any RuleWorks action. You can specify any number of actions.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Clause</LI>
</I><FONT SIZE=2><P>DO</P>
</B><P>Specifies the actions that are to be executed as long as the relational expression remains true. This clause is required.</P>
<P>&nbsp;</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The example below illustrates a simple relational expression in a WHILE</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=3><P>(WHILE (&lt;sun_shines&gt; = true) DO</P>
<P>&#9; (make hay))</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI>WM</LI>
</B></FONT><FONT SIZE=2><P>Displays the objects whose INSTANCE-IDs are specified.  The output includes the following information about each object:</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=2><P><FONT FACE="Symbol">&#183;</FONT>
&#9;Its INSTANCE-ID</P>
<P><FONT FACE="Symbol">&#183;</FONT>
&#9;The name of the construct that last modified the object (for example, a rule or ON- clause). If you last modified the object at the interpreter prompt, the construct name is the symbol RUL.</P>
<P><FONT FACE="Symbol">&#183;</FONT>
&#9;Its attributes' names and their values</P>
<P>Scalar attributes whose value is NIL, and compound attributes whose value is (COMPOUND), are not displayed unless you have declared a DEFAULT value for the attribute.</P>
</FONT><FONT SIZE=2><P>The system displays this information in the following format:</P>

<P>#<I>instance-id</I>  [<I>block-name</I>~<I>rule-name</I>]  (<I>class-name attribute-1 value-1 attribute-2 value-2</I>) ...</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>WM</B> [ instance-id ]...</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>instance-id</P>
</B><P>An INSTANCE-ID atom that identifies an object that  the command is to display. You can specify one or more INSTANCE-IDs.</P>
<P>The Argument is optional. If you do not specify any INSTANCE-IDs, the command  displays all the visible WMOs.</P>
</FONT><B><I><LI>Example</LI>

</B></I><FONT SIZE=2><P>The following command displays the objects whose identifiers are  #3 and #4:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">WM #3 #4</P>
</B></FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P> ???</P>
<P> ???</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810146">WMHISTORY</LI>
</B></FONT><FONT SIZE=2><P>Displays the history of a specified object, that is, which rules set the attribute values. You must specify the INSTANCE-ID of  the desired object; you may also specify a particular attribute.</P>
<P>When the WMHISTORY command displays an entire object, the output includes the following information:</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=2><P><FONT FACE="Symbol">&#183;</FONT>
&#9;INSTANCE-ID</P>
<P><FONT FACE="Symbol">&#183;</FONT>
&#9;Name of the rule that last modified the object</P>
<P><FONT FACE="Symbol">&#183;</FONT>
&#9;Object class name</P>
<P><FONT FACE="Symbol">&#183;</FONT>
&#9;Name of the rule that originally created the object</P>
<P><FONT FACE="Symbol">&#183;</FONT>
&#9;Name and value of each attribute</P>
<P><FONT FACE="Symbol">&#183;</FONT>
&#9;Name of the rule that set the current value of each attribute</P>
<P>Scalar attributes whose value is NIL, and compound attributes whose value is (COMPOUND), are not displayed unless you have declared a DEFAULT value for the attribute.</P>
</FONT><FONT SIZE=2>
<P>The system displays this information in the following format: </P>
<P>#<I>instance-id</I> [<I>rule-name-0</I>] (<I>class-name</I>  [<I>rule-name</I>] <I>{</I> ^<I>attr-1 value-1</I>  [<I>rule-name-1</I>] <I>}</I>  ...</P>

<P>When the WMHISTORY command displays a single attribute, the output includes the following information:</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=2><P><FONT FACE="Symbol">&#183;</FONT>
&#9;INSTANCE-ID</P>
<P><FONT FACE="Symbol">&#183;</FONT>
&#9;Name of the rule that last modified the object</P>
<P><FONT FACE="Symbol">&#183;</FONT>
&#9;Name and value of the specified attribute</P>
<P><FONT FACE="Symbol">&#183;</FONT>
&#9;Name of the rule that set the current value of the specified attribute</P>
</FONT><FONT SIZE=2>
<P>The system displays this information in the following format: </P>
<B><P>#</B><I>INSTANCE-ID</I>  <B>[</B><I>rule-name-0</I><B>]</B> <B>^</B><I>attribute value</I> <B>[</B><I>rule-name-n</I><B>]</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=2><P>Note:</B>  &#9;By default, WMHISTORY is disabled. You must turn it on with the ENABLE command before you can use it.</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>WMHISTORY</B>  instance-id <I>[</I> <B>^</B><I>attribute ]</P>
</FONT><B><LI>Arguments</LI>
</I><FONT SIZE=2><P>instance-id</P>
</B><P>The INSTANCE-ID of the object to be displayed.</P>
<B>
<P>attribute</P>
</B><P>An attribute that describes a characteristic of the object to be displayed. This Argument is optional. You can use at most one attribute name in a WMHISTORY command.</P>
</FONT><B><I>
<LI>Example</LI>

</B></I><FONT SIZE=2><P>The following example shows the history of an entire object:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>  RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">ENABLE WMHISTORY</P>
</B></FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">RUN</P>
</B></FONT><FONT SIZE=2><P>.<BR>
.<BR>
.</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">WMH #28</P>
</B></FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P> #28 [CHOOSE-SLOTS:PLACE-NONMEMORY] (BOX [CONVERT-PACKAGES-TO-PARTS:HOME-KIW</FONT><FONT FACE="Courier" SIZE=1>I] ^CARD-IN-SLOT (COMPOUND MEMORY MEMORY KEYBOARD FD-35) [CHOOSE-SLOTS:PLACE-NONMEMORY] ^CARD-IN-SLOT-OBJ-ID (COMPOUND #31 #39 #37 #45) [CHOOSE-SLOTS:PLACE-NONMEMORY] ^NAME BOX [EXPAND-PART-SKELETONS:BOX] ^PART-NUMBER KI-9200 [EXPAND-PART-SKELETONS:BOX] ^PRINTNAME Kiwi-9200 CPU Base Unit [EXPAND-PART-SKELETONS:BOX] ^PRICE 999.95 [EXPAND-PART-SKELETONS:BOX] ^IS-EXPANDED YES [EXPAND-PART-SKELETONS:BOX])</P>
</FONT><FONT SIZE=2><P>This example shows the history of an attribute:</P>
</FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P>RuleWorks&gt; </FONT><B><FONT FACE="Courier" SIZE=1 COLOR="#800000">WMH #28 ^CARD-IN-SLOT</P>
</B></FONT><FONT FACE="Courier" SIZE=1 COLOR="#0000ff"><P> #28 [CHOOSE-SLOTS:PLACE-NONMEMORY] (BOX [CONVERT-PACKAGES-TO-PARTS:HOME-KIW</FONT><FONT FACE="Courier" SIZE=1>I] ^CARD-IN-SLOT (COMPOUND MEMORY MEMORY KEYBOARD FD-35) [CHOOSE-SLOTS:PLACE-NONMEMORY])</P>
</FONT><B><FONT FACE="Helvetica" SIZE=4>
<LI><!a NAME="_Toc373810147">WRITE </LI>
</B></FONT><FONT SIZE=2><P>Sends output from a program to the terminal or a file. By default, the WRITE  action sends output to the terminal. To send output to a file, you can do one  of the following:</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=2><P><FONT FACE="Symbol">&#183;</FONT>
&#9;Specify the WRITE action with a file identifier</P>
<P><FONT FACE="Symbol">&#183;</FONT>
&#9;Change the default destination for the WRITE action, using the DEFAULT  action or command</P>


</FONT><B><I><LI>Format</LI>
</I><FONT SIZE=2><P>(WRITE </B><I>[file-id] RHS-expression</I> )</P>
</FONT><B><I><LI>Arguments</LI>
</I><FONT SIZE=2><P>file-id</P>
</B><P>The file identifier of the destination file for the WRITE action's output. This Argument is optional. If you do not specify the Argument or if the name you specify is not associated with an open output file, the output is sent to the current default for the WRITE action (set with the DEFAULT action or command).  </P>
<B>
<P>RHS-expression</P>
</B><P>A right-hand-side expression that represents the output. The action evaluates the expression and sends the output to the terminal or a file. Use the following functions to format the output:</P>
<P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=2><P><!a NAME="_Toc393858215">Table 29.  WRITE Functions</P>
<P>Function&#9;Description</P>
</B></FONT><FONT FACE="NewCenturySchlbk" SIZE=1><P>CRLF  &#9;Carriage return/line feed</P>
<P>TABTO  &#9;Tab</P>
<P>RJUST  &#9;Right-justify</P>

</FONT><FONT SIZE=2><P>If you do not use these functions, the WRITE action displays its output on the current output line with one space between values. For information about using these functions, see Chapter 4.</P>
</FONT><B><I><LI>Example</LI>




</B></I><FONT SIZE=2><P>The following WRITE action is from the rule OUTPUT-HARDWARE-OPTIONS:WITH-SLOT:</P>

</FONT><FONT FACE="Courier" SIZE=3><P> (write (crlf) &lt;num&gt; (tabto 12) RuleWorks</P>
<P>       (tabto 50) |in Slot:| &lt;slot-num&gt; (tabto 65) (rjust 10) &lt;price&gt;) )</P>
</FONT><FONT SIZE=2>

<P>This action produces the following output:</P>

</FONT><FONT FACE="Courier" SIZE=3><P>FD-35      3.5" Floppy Disk Drive                in Slot: 4          99.95</P>
<P>KB-9200    108-Key Keyboard with Mouse Port      in Slot: 3          99.95</P>
<P>MS-9200    Kiwi-9200 Memory card                 in Slot: 2         129.95</P>
<P>MS-9200    Kiwi-9200 Memory card                 in Slot: 1         129.95 </P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>
</FONT><FONT SIZE=2><P>&nbsp;</P>
</FONT></BODY>
</HTML>
