<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE> </TITLE>
</HEAD>
<BODY>

<FONT FACE="Arial" SIZE=6 color="navy"><P ALIGN="RIGHT">RuleWorks</P></FONT>

<B><I><FONT FACE="HELVETICA" SIZE=6 color="RED"><P ALIGN="RIGHT">
Debugging RuleWorks Programs</P></B></I></FONT>

<P>You can use the RuleWorks debugging commands to find errors in your program and to interact with it while it is running.  If your program calls routines written in another language, you must use that language's debugger to find errors in those routines.  That debugger sees the C code generated by the RuleWorks compiler, not your RuleWorks source code. DEBUG qualifier.</P>
<B><P>Note</B>: that the RuleWorks debugger, unlike other debuggers, is subordinate -- it is called from your program.  Other debuggers call your program. You control the appearance of the RuleWorks interpreter with the Debug compilation qualifier, DEBUG action, and the rul_debug RTL routine.  </P>


<B><FONT FACE="Helvetica" SIZE=5><P>Using the RuleWorks Command Interpreter</P></B></FONT>
<P>The RuleWorks command interpreter lets you interactively control the execution of an entry block by entering RuleWorks commands. Table 9-1 lists these commands with their corresponding  operations. </P>
<B><P>Table 9-1. Debugging Commands</P></B>

<TABLE BORDER=1>
<TR><TD><B>Commands</B></TD><TD><B>Operation</B></TD></TR>
<TR><TD>@</TD><TD>Execute contents of a command file  </TD></TR>
<TR><TD>EBREAK<BR>RBREAK<BR>WBREAK</TD><TD>Use breakpoints</TD></TR>
<TR><TD>PPCLASS</TD><TD>Display the inheritance hierarchy of an object class</TD></TR>
<TR><TD>PPWM<BR>WMHISTORY</TD><TD>Display objects in working memory</TD></TR>
<TR><TD>MAKE<BR>MODIFY<BR>COPY<BR>SPECIALIZE <BR>REMOVE <BR>REMOVE-EVERY </TD><TD>Change working memory</TD></TR>
<TR><TD>MATCHES</TD><TD>Display match information<BR>
<TR><TD>CS<BR>NEXT</TD><TD>Display the contents of the conflict set<BR>
<TR><TD>TRACE</TD><TD>Display trace information  </P>
<TR><TD>ADDSTATE<BR>RESTORESTATE<BR>SAVESTATE</TD><TD>Save and restore visible working memory and active conflict set</TD></TR>
<TR><TD>DISABLE<BR>ENABLE</TD><TD>Change the state of program operation</TD></TR>
<TR><TD>AFTER</TD><TD>Set the recognize-act counter for a catcher</TD></TR>
<TR><TD>RUN</TD><TD>Execute recognize-act cycles</TD></TR>
</TABLE>

<P>&nbsp;</P>
<P><B>Entering RuleWorks Commands</P></B>
<P>The RuleWorks command interpreter displays the following prompt:  </P>

<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt; </P>
</FONT></UL>

<P>To enter a RuleWorks command, type the command, with arguments if  appropriate, and then press the Return key. To extend a command over more than one line, you can either enclose it in parentheses (which you can optionally  use for single-line commands also) or use the continuation character (-). </P>

<P>An example of a single-line command entered, without parentheses, at the  interpreter prompt is shown below: </P>

<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>CS</P></B></FONT></UL>

<P>If you end a line with the continuation character, the command interpreter  prompts you for the rest of the command each time you press the Return key.  For example:</P>

<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>MAKE HD-30 ^IS-EXPANDED YES ^NAME HD-30 ^PART-NUMBER HD-30  </P>
</B><P>_RuleWorks&gt;<B>^PRINT-NAME |30 Megabyte Hard Disk Drive| ^PRICE 599.95 </P>
</B><P>_RuleWorks&gt;<B>^TAKES-SLOT YES</P>
</B></FONT></UL>

<P>If you begin a command with a parenthesis, you must make sure you have the same number of left and right parentheses, because the interpreter  matches each left parenthesis with a corresponding right parenthesis before  it accepts the command. The MAKE command above can also be entered with parentheses but without a continuation character:</P>

<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>MAKE HD-30 ^IS-EXPANDED YES ^NAME HD-30 ^PART-NUMBER HD-30 </P>
</B><P>_RuleWorks&gt;<B>^PRINT-NAME |30 Megabyte Hard Disk Drive| ^PRICE 599.95 </P>
</B><P>_RuleWorks&gt;<B>^TAKES-SLOT YES</P>
</B></FONT></UL>

<P>If you want to include an extra unmatched parenthesis in such a command, you must enclose it in quote characters, for example, ||.  Otherwise the interpreter counts it as a parenthesis to be matched before it allows you to end the command. </P>

<P>Arguments, which can be optional or required, must follow the command name. If you do not specify a required argument, the run-time system displays an error message, shows the correct syntax and an example, and finally redisplays the command interpreter prompt. For example:  </P>

<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>make </P>
</B><P>%RUL-E-SYNTAXERR, Syntax error:  MAKE command missing required parameters    Usage:     MAKE  class-name [ {^attribute value}... ]    </P>
<P>Example:   RuleWorks&gt;  make my-part ^number 801 ^color-list[3] yellow </P>

</FONT>
<B><P>Note:</B>&#9; The command interpreter does not evaluate arguments. Therefore, you cannot use variables as an argument to a RuleWorks command.  Similarly, you cannot use a call to any function except COMPOUND. </P>
</UL>


<B><P>Exiting the Command Interpreter</B></FONT>
<P>Use the EXIT command to exit the command interpreter. Depending on whether your RuleWorks code is set up as a main program or a callable routine, control returns either to the operating system or to the calling program.</P>

<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>exit </P>
</B><P>$</P></FONT></UL>

<B><FONT FACE="Helvetica" SIZE=5><P>Using RuleWorks Command Files</B></FONT>
<P>You can store a list of RuleWorks commands in a file and execute them later by using the RuleWorks @ command inside your ON-ENTRY statement or at the command interpreter.  For example, you can have an @ file of MAKE commands to create objects when your program starts. </P>
<P>The following command opens the file ORDER.WM and causes the command interpreter to execute the commands stored in that file:</P>

<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>@ ORDER.WM</P>
</B></FONT></UL>

<P>If the file you specify with the @ command contains information other than RuleWorks commands, the run-time system displays an error   message.  For example: </P>

<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>@ ORDER.DAT </P>
</B><P>%RUL-E-SYNTAXERR, Syntax error:  unknown command 'home-Kiwi'</P>
</FONT>
</UL>

<B><FONT FACE="Helvetica" SIZE=5><P>Using Breakpoints</B></FONT>
<P>A breakpoint causes your program to pause under certain conditions: a specified rule is about to be executed or an object that matches a specified pattern has just been created, changed, or deleted.  You can set, delete, and list breakpoints by using the EBREAK command for entry blocks; the RBREAK command for rules and rule groups; and the WBREAK command for WMOs.   </P>

<P>When the run-time system encounters a breakpoint, the system finishes executing the current recognize-act cycle, displays an informational message, and then invokes the command interpreter, to allow you to enter debugging commands.  The format of the message depends on your operating system.  For example, on VMS systems: </P>
<UL><FONT FACE="Courier" SIZE=1><P>%RUL-I-EBREAK, EBREAK encountered; pausing after ON-ENTRY in MAIN</P>
</FONT></UL>

<P>If a breakpoint is set for an entry block, the run-time system pauses for the breakpoint after executing the ON-ENTRY and ON-EXIT clauses (if any) of the entry block.  If a breakpoint is set for a rule, the run-time system pauses for the breakpoint just before executing that rule.  Setting a breakpoint on a rule group is equivalent to setting breakpoints on every rule in the group.  If a breakpoint is set for an object pattern, the run-time system pauses for the breakpoint after executing the rule that created, changed, or deleted the object. </P>
<B><P>Setting Breakpoints</B></P>
<P>To set a breakpoint, specify the EBREAK, RBREAK, or WBREAK command with the keyword ON and the name of the entry block or rule, or a pattern matched by the WMO.  </P>

<P>You can give more than one name with a break command.  For example, the following command sets breakpoints on two rules: </P>

<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>rbreak on verify-configuration:need-memory choose-slots:place-memory</P>
</B>
</FONT></UL>

<P>The WBREAK command accepts at most one object pattern. This pattern is similar to a CE but more limited: it must include an object class name and can also include attributes with predicates and values.  It cannot include variables, function calls or other expressions. </P>
<P>For example, suppose a breakpoint is already set for objects of class FLOPPY. The following two commands set a new breakpoint for objects with class name DISK and ^PRICE identical to 299.95, and delete the old one on class FLOPPY: </P>

<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>wbreak on disk ^price 299.95</B> </P>
</FONT></UL>

<P>When you specify an object class that has inheriting subclasses, objects of those subclasses are also affected by the WBREAK commands.  Thus, the command above affects objects of classes DISK, FLOPPY, FD-5, FD-35, HARD-DISK, HD-30, and HD-200.  See Chapter 2 for an illustration of the class inheritance hierarchy of the sample program KIWI.</P>

<B><P>Listing Breakpoints</B></p></FONT>
<P>To see what breakpoints are set, use the EBREAK, RBREAK, or WBREAK command without any keyword or arguments. The following example shows that breakpoints are set for two rules: </P>
<ul><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>rbreak </P>
</B><P>   RBREAKs set on:</P>
<P>    1  VERIFY-CONFIGURATION:NEED-MEMORY</P>
<P>    2  CHOOSE-SLOTS:PLACE-MEMORY</P>
</FONT></ul>

<P>This example shows that breakpoints are set for certain objects of class DISK:  </P>

<ul><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>wbreak </P>
</B><P>   WBREAKs set on:</P>
<P>    1  (DISK  ^PRICE &lt;= 299.95)</P>
</FONT></ul>

<p>&nbsp;</p>
<p><B>Deleting Breakpoints</p></B>
<P>To delete a breakpoint, specify the EBREAK, RBREAK, or WBREAK command with the keyword OFF, and one of the following:</P>

<UL>
<LI>the name of the entry block or rule, or a pattern matched by a WMO, that has a breakpoint set </LI>
<LI>a number displayed by a break command when given no arguments (as shown above)  </LI>
<LI>an asterisk (*)  </LI></UL>

<P>Use an asterisk to delete all breakpoints.  For example: </P>

<ul><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>rbreak off  </P>
</B><P>RuleWorks&gt;<B>rbreak</P>
</B><P>&#9;No RBREAKs set. </P>
</ul></FONT>

<P>&nbsp;</P>
<B><FONT FACE="Helvetica" SIZE=5><P>Displaying the Inheritance Hierarchy</B></FONT></P>
<P>Use the PPCLASS command with the name of an object class to display the inheritance hierarchy of that class. This command lists the ancestors of the class you specify, starting at the top-level user-defined class.  All attributes declared for that class, including those it inherits, are shown after the class name.  For example:</P>
<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>ppclass box </P></B>
<UL><P>   PART</P>
<UL><P>    BOX</P>
<UL><P>      ^$ID instance-id of BOX</P>
<P>      ^$INSTANCE-OF symbol (default BOX)</P>
<P>      ^PARTNUMBER</P>
<P>      ^NAME</P>
<P>      ^PRICE</P>
<P>      ^IS-EXPANDED (default NO)</P>
<P>      ^CARD-IN-SLOT compound</P>
<P>      ^CARD-IN-SLOT-OBJ-ID compound</P>
</UL></UL></UL></UL></FONT>

<P>An attribute's default and fill values, if any, are shown inside parentheses after the attribute's name.  Compound attributes are also identified as such.   </P>

<P>To display which object classes are visible to the active entry block, use the PPCLASS command with no argument.  This shows the name of the entry block (and declaration blocks, if any) and the top-level user-defined classes only.  For example: </P>

<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>ppclass </P></B>
<UL><P>   Entry block CONFIG</P>
<UL><P>        LOCAL</P></UL>
<P>    Declaration block KIWI_DECLS</P>
<UL><P>        CONTROL-CONTEXT</P>
<P>        ERROR</P>
<P>        INPUT-THING</P>
<P>        PART</P>
</UL></UL></UL></font>

<P>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=5><P>Displaying Working-Memory Objects</P></B></FONT>
<P>During a debugging session, you can examine the contents of working memory to make sure it contains correct information. Missing or erroneous objects can cause a rule to be executed at the wrong time.  The WM, PPWM, and WMHISTORY commands display the contents of working memory:  </P>

<B><P>Table 9-2.  Working Memory Commands</P></B>
<TABLE BORDER=1>
<TR><TD><B>Command</B></TD><TD><B>Description</B></TD></TR>
<TR><TD>WM</TD><TD>Displays all objects or objects with specified INSTANCE-IDs.</TD></TR>
<TR><TD>PPWM</TD><TD>Displays all objects or objects that match a specified pattern. </TD></TR>
<TR><TD>WMHISTORY</TD><TD>Displays the revision history of the object with a specified INSTANCE-ID, or of a specified attribute of that object. </TD></TR>
</TABLE>

<P>The WM and PPWM commands provide the following information about each object: </P>
<UL>
<LI>Its INSTANCE-ID </LI>
<LI>Its time-tag </LI>
<LI>The name of the rule that set the time-tag (that is, the rule that last modified the object) </LI>
<LI>Its object class name, its attributes, and the attributes' values</LI></UL>

<P>The run-time system displays this information in the following format:</P>

<UL><I><FONT FACE="Courier" SIZE=1><P>#INSTANCE-ID time-tage[rule-name] (class-name ^attr-1 value-1 ^attr-2 value-2 ...)</P>
</I></FONT></UL>

<P>The WMHISTORY command provides the following information about an object</P>

<UL>
<LI>Its INSTANCE-ID </LI>
<LI>Its time-tag </LI>
<LI>The name of the rule that last modified it </LI>
<LI>Its object class name </LI>
<LI>The name of the rule that set the object class name (that is, the  rule that originally created the object)  </LI>
<LI>Its attributes, the attributes' current values, and the names of the rules that set the attributes' current values </LI></UL>

<P>The run-time system displays this information in the following format:</P>
<UL><I><FONT FACE="Courier" SIZE=1><P>#INSTANCE-ID time-tage[rule-name-n] (class-name [rule-name] {attr-1 value-1 [rule-name-1]}   )</P>
</I></FONT></UL>

<P>When you create or change an object with an action contained in an &quot;ON-&quot;statement, the name of that statement appears inside the brackets rather than a rule name.  When you use a command, the atom RUL appears.  </P>

<P>The run-time system does not print an empty attribute unless you have specified a DEFAULT value for it.  Empty is defined as a NIL value for scalar attributes, (COMPOUND) for compound attributes.  Attributes that have a DEFAULT declaration are always printed.</P>

<P><B>Displaying the Contents of Working Memory</P></B>
<P>To display the entire contents of working memory, use either the WM or PPWM  command without an argument. For example: </P>

<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>wm </P></B>
<UL><P>   #1 1 [ON-ENTRY] (CONTEXT ^NAME TASKS-TO-DO)</P>
<P>   #2 2 [TASKS-TO-DO:TASKS-TO-DO] (CONTEXT ^NAME OUTPUT-NEW-ORDER)</P>
<P>   #3 3 [TASKS-TO-DO:TASKS-TO-DO] (CONTEXT ^NAME MODIFY-SOFTWARE-MEDIA) </P>
<P>   #4 4 [TASKS-TO-DO:TASKS-TO-DO] (CONTEXT ^NAME CHOOSE-SLOTS)</P>
</UL>
</FONT></UL>

<P>Object #1 was made in the ON-ENTRY statement, so that name  appears inside the brackets instead of the name of a rule.</P>

<P><B>Displaying Specific Working-Memory Objects</P></B>
<P>To display particular objects, specify their INSTANCE-IDs  with the WM command. The following example displays the  objects that have INSTANCE-IDs #23 and #24: </P>

<ul><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>wm #23 #24 </P></B>
<ul><P>   #23 27 [VERIFY-CONFIGURATION:MOUSE-PORT] (ERROR  ^SEVERITY WARNING  ^MESSAGE  |Missing mouse port|)</P>
<P>   #24 28 [VERIFY-CONFIGURATION:MOUSE-PORT] (KEYBOARD ^IS-EXPANDED NO ^IS-PLACED  NO)</P>
</ul></UL></FONT>

<P>You can find out which INSTANCE-IDs are assigned to which objects by setting the run-time system's TRACE level to WM. For further information on trace levels, See the Displaying Trace Information section of this chapter.</P>

<P><B>Displaying the History of Specific Working-Memory Objects</P></B>
<P>To display the names of the rules that have created or modified a particular object, specify the INSTANCE-ID of that object with the WMHISTORY command.  By default, the WMHISTORY command is disabled.  You must enable it with the ENABLE command before running the rules that affect the objects you want to display.  The following example shows the history of the object whose INSTANCE-ID is #36: </P>
<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>enable wmhistory </P>
</B><P>RuleWorks&gt;<B>run 45</P>
</B><P>RuleWorks&gt;<B>wmhistory 36</P>
</B>
<UL><P>&#9;#36 41 [EXPAND-PART-SKELETONS:FD-35] (FD-35 [VERIFY-CONFIGURATION:NEED-DISK] ^   TAKES-SLOT YES [EXPAND-PART-SKELETONS:FD-35]  ^NAME FD-35 [EXPAND-PART-SKELETONS: FD-35]  ^PART-NUMBER FD-35 [EXPAND-PART-SKELETONS:FD-35]  ^PRINTNAME 3.5" Floppy  Disk Drive [EXPAND-PART-SKELETONS:FD-35]  ^PRICE 99.95 [EXPAND-PART-SKELETONS:FD- 35]  ^IS-EXPANDED YES [EXPAND-PART-SKELETONS:FD-35])</P>
</FONT></UL></UL>

<P>In this example, the WMHISTORY command shows that the rule EXPAND-PART-SKELETONS:FD-35 most recently changed this object, because that is the rule shown after the time-tag.  Another rule,  VERIFY-CONFIGURATION:NEED-DISK, originally created the object, because that is the rule shown after the class name.  The rule EXPAND-PART-SKELETONS:FD-35  set the values of all the attributes. </P>

<P>If you are interested in which rule set a particular attribute value, you can specify the attribute name with the WMHISTORY command: </P>

<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>wmhistory #36 ^price </P>
</B>
<UL><P>   #36 41 [EXPAND-PART-SKELETONS:FD-35] (FD-35 [VERIFY-CONFIGURATION:NEED-DISK] </P>
<P>^ PRICE 99.95 [EXPAND-PART-SKELETONS:FD-35]) </P>
</FONT></UL></UL>
<P>When you use a command rather than an action inside a rule to create or modify an object, the atom RUL rather than the name of a rule appears inside the  brackets after the time-tag, class name, or attribute value. When you use an action inside an &quot;ON-&quot;statement, the name of that statement appears inside the brackets.</P>

<P><B>Displaying the Working-Memory Objects of an Object Class</P></B>
<P>To display the objects of a particular object class, use the PPWM command with the name of that class. For example: </P>
<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>ppwm error </P>
</B>
<UL><P>   #23 27 [VERIFY-CONFIGURATION:MOUSE-PORT] (ERROR  ^SEVERITY WARNING  ^MESSAGE | Missing mouse port|)</P>
<P>   #25 29 [VERIFY-CONFIGURATION:APPLICATION-NEEDS-KIWOS] (ERROR  ^SEVERITY WARNIN G  ^MESSAGE |Missing operating system|) </P>
<P>   #27 31 [VERIFY-CONFIGURATION:KIWOS-MEMORY] (ERROR  ^SEVERITY WARNING  ^MESSAGE  |Missing memory|) )</P>
</FONT></UL></UL>

<P>If you specify the name of an object class that has inheriting subclasses, objects of those subclasses are also displayed.  For example: </P>

<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>ppwm software-option </P>
</B>
<UL><P>   #27 69 [MODIFY-SOFTWARE-MEDIA:35-CHEAPEST] (KIWICALC  ^MEDIA-TYPE FD-35  ^NAME  KIWICALC  ^PART-NUMBER S-CA-9200  ^PRINTNAME KiwiCalc Spreadsheet Software  ^PRI CE 29.95  ^IS-EXPANDED YES) </P>
<P>   #29 70 [MODIFY-SOFTWARE-MEDIA:35-CHEAPEST] (KIWINDOWS  ^MEDIA-TYPE FD-35  ^NAM E KIWINDOWS  ^PART-NUMBER S-WI-9200  ^PRINTNAME KiWindows Windows Software  ^PRIC E 59.95  ^IS-EXPANDED YES) </P>
<P>   #39 71 [MODIFY-SOFTWARE-MEDIA:35-CHEAPEST] (KIWOS  ^MEDIA-TYPE FD-35  ^NAME KI WOS ^PART-NUMBER S-OS-9200  ^PRINTNAME KIWOS Operating System  ^PRICE 9.95  ^IS-E XPANDED YES)</P>
</UL></UL>
</FONT>

<P>(See Chapter 2 for an illustration of the class inheritance hierarchy of the sample program KIWI.RUL.)</P>

<P><B>Displaying Working-Memory Objects that Match a Pattern</P></B>
<P>To display the objects that match a specific object pattern, use the PPWM command with an object class name followed by the pattern you want to match.  This pattern is similar to an attribute-value test but variables and function calls are not allowed, except COMPOUND.</P>
<P>The following example displays all parts that match the object pattern ^PRICE &lt; 50.00.  The ^PRICE attribute is first declared in the PART class. Therefore, to display all objects that have the ^PRICE attribute, the object class name PART is specified in the PPWM command.  The objects that actually match the pattern are  instances of classes KIWICALC and KIWOS:   </P>
<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>ppwm part  ^price &lt; 50.00 </P>
</B>
<UL><P>   #27 69 [MODIFY-SOFTWARE-MEDIA:35-CHEAPEST] (KIWICALC  ^MEDIA-TYPE FD-35  ^NAME  KIWICALC  ^PART-NUMBER S-CA-9200  ^PRINTNAME KiwiCalc Spreadsheet Software  ^PRI CE 29.95  ^IS-EXPANDED YES) </P>
<P>   #39 71 [MODIFY-SOFTWARE-MEDIA:35-CHEAPEST] (KIWOS  ^MEDIA-TYPE FD-35  ^NAME KI WOS ^PART-NUMBER S-OS-9200  ^PRINTNAME KIWOS Operating System  ^PRICE 9.95  ^IS-EXPANDED YES)</P>
</UL></UL>
</FONT>

<P>&nbsp;</p>

<B><FONT FACE="Helvetica" SIZE=5><P>Modifying Working Memory</P></B></FONT>
<P>If working memory contains incorrect information, the rules in a program might not execute as you anticipate. You can modify working memory by: </P>

<UL>
<LI>Creating objects </LI>
<LI>Copying objects </LI>
<LI>Deleting objects </LI>
<LI>Changing the values in existing objects </LI></UL>

<P><B>Creating Working-Memory Objects</P></B>
<P>You can create a new object by using the MAKE command with an object class name. You can optionally specify attributes with constant values or the COMPOUND function with constant arguments. The following  command creates an object with the class name INPUT-THING and a value for its ^ITEM attribute.</P>
<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>make input-thing  ^item keyboard</P></B></UL></FONT>
<P>The object could be displayed as follows:  </P>
<UL><FONT FACE="Courier" SIZE=1><P>#18 20 [RUL] (INPUT-THING  ^ITEM KEYBOARD) </P></UL></FONT>
<P>Because the object was created by a command, the atom RUL is used instead of the name of a rule that set the time-tag.</P>

<P><B>Copying Working-Memory Objects</P></B>
<P>You can make a new copy of an existing object by using the COPY command with an  INSTANCE-ID. You can optionally specify attributes with values. The following command creates another object of class FD-35 with a different attribute value:</P>

<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>copy #36  ^price 119.95 </P>
</B><P>RuleWorks&gt;<B>ppwm fd-35  ^price 119.95 </P>
</B>
<UL><P>  #45 63 [RUL] (FD-35 [RUL]  ^TAKES-SLOT YES  ^NAME FD-35  ^PART-NUMBER FD-35  ^ PRINTNAME 3.5" Floppy Disk Drive  ^PRICE 199.95  ^IS-EXPANDED YES )</P>
</UL></UL>
</FONT>
<P>RUL is placed in the fields that store the names of the rules that created the object and that last modified it.  Note that both the INSTANCE-ID and the time-tag of the new object are different from the older object.</P>

<P><B>Changing the Class of Objects</P></B>
<P>You can change the class of an object from a parent class to a subclass with the SPECIALIZE command.  For example: </P>
<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>ppwm #48 </P>
</B>
<UL><P>   #48 54 [RUL] (FLOPPY ^IS-EXPANDED NO ^IS-PLACED NO) </P></UL>
<P>RuleWorks&gt;<B>specialize #48 fd-5</B> </P>
<P>RuleWorks&gt;<B>ppwm #48</B> </P>
<UL><P>   #48 55 [RUL] (FD-5 ^IS-EXPANDED NO ^IS-PLACED NO)</P>
</UL></UL></FONT>
<UL><B><P>Note:&#9;</B>The converted object's INSTANCE-ID does not change as a result of this action, but the time-tag does change. You can also change attribute values with this command.  </P></UL>

<P><B>Deleting Objects from Working Memory</P></B>
<P>The REMOVE command deletes objects from working memory. To delete specific  objects, specify their INSTANCE-IDs. The following example deletes the  objects whose identifiers are #20 and #63:</P>
<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>remove #20 #63</P>
</B></FONT></UL>
<P>To delete all visible objects, specify the command with an asterisk (*). For example: </P>
<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>remove *</P>
</B></FONT></UL>

<P>To delete all instances of an object class and its subclasses, use the REMOVE-EVERY command.  For example:  </P>
<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>remove-every input-thing</B> </P>
</UL></FONT>

<P><B>Changing the Values in Working-Memory Objects</P></B>
<P>To change one or more values in an object, use the MODIFY command with the INSTANCE-ID of the object whose atoms you want to change,  and specify the attributes and their new values. Suppose, for example, working memory contains the following objects: </P>
<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>ppwm input-thing</B> </P>
<UL><P>   #16 17 [READ-LINE-ITEM:READ-AN-ITEM] (INPUT-THING  ^ITEM HOME-KIWI) </P>
<P>   #17 19 [READ-LINE-ITEM:READ-AN-ITEM] (INPUT-THING  ^ITEM MOUSE) </P>
<P>   #18 21 [READ-LINE-ITEM:READ-AN-ITEM] (INPUT-THING  ^ITEM KIWINDOWS)</P>
</FONT></UL></UL>
<P>The following command changes the atom for the attribute ^ITEM of the object whose INSTANCE-ID is #16: </P>
<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>modify #16  ^item business-kiwi</P>
</B></FONT></UL>
<P>The run-time system then changes that attribute and gives the object a new time-tag:   </P>
<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>wm #16 </P>
</B>
<UL><P>   #16 22 [RUL] (INPUT-THING  ^ITEM BUSINESS-KIWI)</P>
</UL></UL></FONT>
<P>Note that the INSTANCE-ID remains the same.</P>

<P>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=5><P>Displaying Match Information</P></B></FONT>
<P>By examining match information, you can detect whether  condition elements are being matched correctly by WMOs. You can display match information for specific rules by using the  MATCHES command.  </P>
<P>Match information includes the INSTANCE-IDs and time-tags of objects that match  CEs in the rules you specify. First, the command displays  the name of the rule. Then the command lists the time-tags for the  objects that match the first CE, the second CE, the first and second CEs,  and so on.     For example, consider the following rule: </P>
<UL><FONT FACE="Courier" SIZE=1><P>(rule choose-slots:place-memory </P>
<ul><P>      (active-context ^name choose-slots)  </P>
<P>      (box ^$ID &lt;the-box&gt; ^card-in-slot { [=] &lt;len&gt; [&lt;] 6 }) </P>
<P>      (memory ^$ID &lt;the-mem&gt; ^is-placed NIL ^takes-slot YES)</P>
<P>    --&gt;  </P>
<P>      (modify &lt;the-box&gt;  </P>
<ul><P>              ^card-in-slot [(&lt;len&gt; + 1)] memory    </P>
<P>             ^card-in-slot-obj-id [(&lt;len&gt; + 1)] &lt;the-mem&gt;)  </P>
</ul><P>      (modify &lt;the-mem&gt; ^is-placed YES ^in-slot (&lt;len&gt; + 1))) </P>
</FONT></ul></ul>

<P>The following objects: </P>
<ul><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>wm #27 #37 #38 #46 </P>
</B><P>#27 59 [EXPAND-PART-SKELETONS:BOX] (BOX  ^NAME BOX  ^PART-NUMBER KI-9200  ^PRINTNAME Kiwi-9200 CPU Base Unit  ^PRICE 999.95  ^IS-EXPANDED YES) </P>
<P>#37 54 [EXPAND-PART-SKELETONS:MEMORY] (MEMORY  ^TAKES-SLOT YES  ^NAME MEMORY-CARD   ^PART-NUMBER MS-9200  ^PRINTNAME Kiwi-9200 Memory card  ^PRICE 129.95  ^IS-EXPANDED YES) </P>
<P>#38 53 [EXPAND-PART-SKELETONS:MEMORY] (MEMORY  ^TAKES-SLOT YES  ^NAME MEMORY-CARD   ^PART-NUMBER MS-9200  ^PRINTNAME Kiwi-9200 Memory card  ^PRICE 129.95  ^IS-EXPANDED YES </P>
<P>#46 60 [MAKE-CONTEXT-ACTIVE] (ACTIVE-CONTEXT  ^NAME CHOOSE-SLOTS))</P>
</FONT></ul>

<P>And the following MATCHES command:</P>
<ul><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>matches choose-slots:place-memory </P>
</B>
<ul><P>   &gt;&gt;&gt; CHOOSE-SLOTS:PLACE-MEMORY (&lt;&lt;&lt;)    *** matches for 1 ***  </P>
<P>   #46</P>
<P>    *** matches for 2 ***  </P>
<P>   #27</P>
<P>    *** matches for 1 2 ***  </P>
<P>   #46  #27</P>
<P>    *** matches for 3 ***  </P>
<P>   #38   </P>
<P>   #37</P>
<P>     *** complete instantiations ***  </P>
<P>   #46  #27  #37   </P>
<P>   #46  #27  #38 </P>
</FONT></ul></ul>

<P>The first five lines of output show that the object whose INSTANCE-ID is #46 matches the first CE in the rule and the object whose INSTANCE-ID is #27 matches the second CE.  These are called intraelement matches because each CE is considered individually.  The next two lines show that the combination of these two objects matches the combination of the first and second CEs.  This is called an interelement match. </P>
<P>The MATCHES command then displays the intraelement matches for the third CE, the objects whose INSTANCE-IDs are #37 and #38.  Note that each match is displayed on a separate line. </P>
<P>Finally, the command displays the instantiations of the rule. Because two objects match one of the CEs, there are two instantiations. </P>
<P>Instantiations removed from the active conflict set by refraction are not included in the MATCHES output.</P>

<B><FONT FACE="Helvetica" SIZE=4>Match Information for Negated CEs</P></B></FONT>
<P>Negated CEs are represented in the match information by headers just like the headers for positive CEs.  For example, the rule VERIFY-CONFIGURATION:MOUSE-PORT  has two positive CEs and one negated CE: </P>
<ul><FONT FACE="Courier" SIZE=1><P>(rule verify-configuration:mouse-port</P>
<ul><P>       (active-context ^name verify-configuration)</P>
<P>       (mouse)</P>
<P>       - (keyboard)    </p>
<p>--&gt;</P>
<P>       (make error ^severity warning ^message |Missing mouse port|)</P>
<P>       (write (crlf) |Caution: You want a mouse, but you don't have a|</P>
<ul><P>              (crlf) |  mouse controller port, which is part of the keyboard|</P>
<P>              (crlf) |  Fixup: adding a keyboard to your order.|</P>
<P>              (crlf)</P>
</ul><P>       (make keyboard))</P>
</FONT></ul></ul>

<P> The match information for this rule is shown below:</P>
<ul><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>matches verify-configuration:mouse-port </P>
</B>
<ul><P>   &gt;&gt;&gt; VERIFY-CONFIGURATION:MOUSE-PORT (&lt;&lt;&lt;)</P>
<P>    *** matches for 1 ***  </P>
<P>   #43</P>
<P>     *** matches for 2 ***  </P>
<P>   #31</P>
<P>     *** matches for 1 2 ***  </P>
<P>   #43  #31</P>
<P>     *** matches for 3 ***</P>
<P>    *** complete instantiations ***  </P>
<P>   #43  #31</P>
</FONT></ul></ul>

<P>There is a complete instantiation of this rule in the conflict set (because) there is no match for the negated third CE.</P>

<B><FONT FACE="Helvetica" SIZE=4><P>Match Information for Interelement Variables</P>
</B></FONT>
<P>Interelement variables are bound in one CE and then used again in another CE.  In match information, interelement variables result in fewer than expected matches for combinations of CEs, compared to the number of matches for individual CEs. </P>

<P>For example, suppose working memory contains the following objects:  </P>
<ul>
<P>#26 42 (BOX) </P>
<P>#28 65 (BOX  ^CARD-IN-SLOT-OBJ-ID (COMPOUND #31)</P>
<P>#31 64 (MEMORY  ^IN-SLOT 1  ^IS-PLACED YES) </P>
<P>#35 66 (MEMORY  ^IN-SLOT 1  ^IS-PLACED YES) </P>
<P>#39 69 (MEMORY  ^IN-SLOT 2  ^IS-PLACED YES) </P>
</ul>

<P>And the program contains this rule</P>
<ul><P>(rule display-memory-cards</P>
<ul><P>       (memory ^$ID &lt;mem&gt; ^is-placed yes)</P>
<P>       (box ^$ID &lt;box&gt; ^card-in-slot-obj-id [+] &lt;mem&gt;)</P>
<P>    --&gt;</P>
<P>       (write (crlf) box &lt;box&gt; contains memory card &lt;mem&gt;))</P>
</ul>
</ul>

<P> The following command displays the matches for this rule:</P>

<ul><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>matches display-memory-cards</B> </P>
<ul><P>   &gt;&gt;&gt; DISPLAY-MEMORY-CARDS (&lt;&lt;&lt;)    *** matches for 1 ***  </P>
<P>   #31   </P>
<P>   #35   </P>
<P>   #39     *** matches for 2 ***  </P>
<P>   #26   </P>
<P>   #28     *** complete instantiations ***  </P>
<P>   #31  #28  ) </P>
</FONT></ul></ul>

<P>There are three intraelement matches for the first CE and two for the second CE, so you might expect six matches for the entire LHS.  However, the interelement variable &lt;MEM&gt; limits the interelement matches to the combination of MEMORY #31 with BOX #28.</P>

<P>&nbsp;</P>
<B><FONT FACE="Helvetica" SIZE=5><P>Displaying Conflict Set Information</P></B></FONT>
<P>The instantiations in the conflict set indicate which rules can be executed. You can display the entire contents of the conflict set or the instantiation of the next rule to be executed.  The run-time system displays instantiations in the following format:  </P>
<ul><FONT FACE="Courier" SIZE=1><P>rule-name #INSTANCE-ID-1 time-tag-1 #INSTANCE-ID-2 time-tag-2   ...</P></ul></font>

<B><FONT FACE="Helvetica" SIZE=4><P>Displaying the Contents of the Conflict Set</P></B></FONT>
<P>The CS command displays the entire contents of the conflict set. For example:</P>
<ul><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>cs </P>
</B>
<B><P>.</P>
<P>.</P>
<P>.</P>
</B><P>&nbsp;</P>
<P>VERIFY-CONFIGURATION:KIWINDOWS-NEEDS-2-MEMORY-CARDS-FOUND-NONE #32 36  #29 33 </P>
<P>VERIFY-CONFIGURATION:APPLICATION-NEEDS-KIWOS #32 36  #29 33 </P>
<P>VERIFY-CONFIGURATION:APPLICATION-NEEDS-KIWOS #32 36  #27 31 </P>
<P>VERIFY-CONFIGURATION:NEED-DISK #32 36 </P>
<P>VERIFY-CONFIGURATION:NEED-OUTPUT #32 36 </P>
<P>VERIFY-CONFIGURATION:NEED-MEMORY #32 36  </P>
</ul>
</FONT>

<P>To display the instantiation of the next rule the run-time system will  execute, use the NEXT command. For example:</P>
<ul><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>next </P>
</B><P>   VERIFY-CONFIGURATION:KIWINDOWS-NEEDS-2-MEMORY-CARDS-FOUND-NONE #32 36  #29 33</P>
</FONT></ul>

<P>This shows that the next rule the run-time system will execute is  VERIFY-CONFIGURATION:KIWINDOWS-NEEDS-2-MEMORY-CARDS-FOUND-NONE. The rule will be executed with its CEs matched by the objects whose INSTANCE-IDs are #32 and #29. </P>

<p>&nbsp;</p>
<B><FONT FACE="Helvetica" SIZE=5><P>Displaying Trace Information</P></B></FONT>
<P>The RuleWorks run-time system displays trace information while executing a  program. Trace information can be enabled for entry blocks (EB), rule groups (RG), rules, working memory (WM), and the conflict set (CS).</P>

<B><FONT FACE="Helvetica" SIZE=4><P>Setting the Trace Level</P></B></FONT>
<P>To set the trace level, specify the TRACE command with the keyword ON or OFF and the type of information you want traced or not. The following table shows the valid keywords for the TRACE command.  The default setting is OFF *.</P>

<B><P>Table 9-3. Trace Keywords</B></P>
<TABLE BORDER=1>
<TR><TD><B>Name</B></TD><TD><B>Trace Information Affected</B></TD></TR>
<TR><TD>ENTRY-BLOCK<BR>EB</TD><TD>Entry blocks entered and exited</TD></TR>
<TR><TD>RULE-GROUP<BR>RG</TD><TD>Rule group containing rule that just fired</TD></TR>
<TR><TD>RULE</TD><TD>Rule firing counts and name of rule that just fired</TD></TR>
<TR><TD>WM</TD><TD>Changes to working memory</TD></TR>
<TR><TD>CS</TD><TD>Changes to the conflict set</TD></TR>
<TR><TD><B>.</B></TD><TD>All trace information</TD></TR>
</TABLE>

<P>For example, if you want the system to display as much trace information as possible, you can list all the keywords or use the asterisk  (*): </P>
<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>trace on eb rg rule wm cs</B>   </P>
<I><P>or</I>  </P>
<P>RuleWorks&gt;<B>trace * </P>
</UL></FONT>

<FONT FACE="Helvetica" SIZE=4><P>Displaying the Current Trace Level</P></B></FONT>
<P>To display the current trace level, use the TRACE command without an argument.  For example:  </P>
<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>trace </P>
<UL></B><P>   TRACE set on:  ENTRY-BLOCK RULE-GROUP RULE WM C</P>
</UL></UL>
</FONT>

<B><FONT FACE="Helvetica" SIZE=4><P>Tracing Entry Blocks</P></B></FONT>
<P>The TRACE ON EB command causes trace messages to be generated upon entering an entry block (before any ON-ENTRY actions are executed) and upon exiting (after any ON-EMPTY or ON-EXIT actions are executed).  </P>
<P>The trace output for entry blocks includes the name of the entry block. Trace output for entry blocks starts in column one.  All other trace messages are indented.  The following example shows sample trace output on entry blocks in <I>italic </I>type.</P>

<UL><B><P>Note:</B>&#9; The output of the following four examples are taken from a telephone directory program that uses the similarity predicate to find names that sound alike. </P></UL>


<P><B>Example 9-1.  Tracing Information on Entry Blocks</P></B>
<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>trace on eb  </P>
</B><P>RuleWorks&gt;<B>run </B> </P>
<P>   Name to look up:  RuleWorks&gt;stefan pelican </P>
<I><P> --&gt;Entry-Block: LOOKUP_PHONE_NUMBER  </P>
</I><P>    Could not find any likely matches for stefan pelican. </P>
<I><P>&lt;--Entry-Block: LOOKUP_PHONE_NUMBER </P>
</I><P>&nbsp;</P>
<P>   Name to look up: <B>stefan polocave </P>
</B><I><P>--&gt;Entry-Block: LOOKUP_PHONE_NUMBER  </P>
</I><P>    Found one potential match for stefan polocave.  </P>
<P>    The number for Steve Polikoff is 555-5391. </P>
<I><P>&lt;--Entry-Block: LOOKUP_PHONE_NUMBER </P>
</I></FONT></UL>

<B><FONT FACE="Helvetica" SIZE=4><P>Tracing Rule Groups</P></B></FONT>
<P>The TRACE RG command causes trace messages to be generated  whenever the rule group that contains the firing rule is different from the rule group that contains the previously fired rule.  The trace output for rule groups contains the name of the rule block or entry block that contains the rule group, as well as the name of the rule group itself.   The system displays this information in the following format:</P>
<UL><B><FONT FACE="Courier" SIZE=1><P>RULE-GROUP: </B><I>rule-group-name [in rule-block-name] in entry-block-name</P></UL>
</I></FONT>

<B><FONT FACE="Helvetica" SIZE=4><P>Tracing Rules</P></B></FONT>
<P>The TRACE RULE command causes a trace message to be generated each time the system executes a rule.  Trace output for rule firings contains the following information:   </P>
<UL>
<LI>The global rule-firing count (total number of recognize-act cycles in the program)  </LI>
<LI>The local rule-firing count (number of recognize-act cycles in this invocation of the active entry block) </LI>
<LI>The name of the rule executed </LI>
<LI>The INSTANCE-IDs and time-tags of the objects that matched the rule's CEs, in order </LI></UL>

<P>The run-time system displays this information in the following format:</P>

<UL><I><FONT FACE="Courier" SIZE=1><P>global(local): rule-name #instance-id-1 time-tag-1 #instance-id-2 time-tag-2 ...</P></UL></I></FONT>

<P>In the following example trace information for rules is shown in  <I>italic </I>print.</P>

<B><P>Example 9-2. Trace Output for Rules</P></B>
<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>trace on eb rule </P>
</B><P>RuleWorks&gt;<B>run </P>
</B><P>   Name to look up: <B>konny oiljars </P>
</B><P>--&gt;Entry-Block: LOOKUP_PHONE_NUMBER  </P>
<I><P>   1 (1):  INIT-PHONE-BOOK #41 41 </P>
<P>   2 (2):  LAST-RESORT:PRINT-ALL-SIMILAR #42 42  #41 41  #30 30</P>
</I><P>     Could not find a probable match for konny oiljars </P>
<P>     but found potential matches </P>
<P>----&gt;Entry-Block: PRINT_SIMILAR_NAMES </P>
<I><P>   3 (1):  PRINT-ALL-WITH-SIMILAR-LAST-NAME #65 65  #30 30</P>

</I></FONT><FONT FACE="NewCenturySchlbk" SIZE=2><P>        Connie Olegarz</P>

</FONT><FONT FACE="Courier" SIZE=1><P>&lt;---Entry-Block: PRINT_SIMILAR_NAMES </P>
<P>&lt;---Entry-Block: LOOKUP_PHONE_NUMBER  </P>
</FONT></UL>

<B><FONT FACE="Helvetica" SIZE=4><P>Tracing Working Memory</P></B></FONT>
<P>When the trace level includes WM, the run-time system displays  changes to working memory (that is, objects created, changed, or deleted). The system displays the following information for each object: </P>

<UL>
<LI>Its INSTANCE-ID </LI>
<LI>Its time-tag </LI>
<LI>The name of the rule that added, changed, or deleted it </LI>
<LI>Its attributes and their values </LI></UL>

<P> The system displays working memory trace information in the following format:</P>
<UL><I><FONT FACE="Courier" SIZE=1><P>#INSTANCE-ID time-tag [rule-name] (class-name attr-1 value-1 attr-2 value-2 ...)</P>
</I></FONT></UL>

<P>Each line of a working memory trace output is preceded by a symbol that indicates the nature of the change as shown in the following table.</P>
<P><B>Table 9-4.  Working Memory Trace Output Symbols</P></B>
<TABLE BORDER=1>
<TR><TD><B>Symbol</B></TD><TD><B>Meaning</B></TD></TR>
<TR><TD>=&gt;WM:</TD><TD>Object added to working memory </TD></TR>
<TR><TD>&lt;=WM:</TD><TD>Object deleted from working memory </TD></TR>
</TABLE>

<P>When an object is modified or specialized, the system displays <I>two</I> lines of output:  the first shows the old version being deleted, the second shows the new version being added.  The INSTANCE-ID, of course, does not change.</P>
<P>In the case of a SPECIALIZE action, the attribute changed is ^$INSTANCE-OF. </P>
<P>In the following example, trace output for working memory changes is shown in <I>italic</I> print.</P>

<P><B>Example 9-3. Trace Ouput for Working Memory</P></B>
<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>trace on eb rule wm </P>
</B><P>RuleWorks&gt;<B>run </P>
</B>
<UL><P>   Name to look up: <B>Jenny Baker </P>
</B><P>--&gt;Entry-Block: LOOKUP_PHONE_NUMBER </P>
<P>   =&gt;WM:  #65 65 [ON-ENTRY] (REQUEST ^FIRST-NAME |Jenny| ^LAST-NAME |Baker|) </P>
<P>   3 (1):  LAST-RESORT:PRINT-ALL-SIMILAR #42 42  #65 65  #3 3</P>
<P>&nbsp;</P>
<P>   Could not find a probable match for Jenny Baker but found potential matches -- </P>
<P>--&gt;Entry-Block: PRINT_SIMILAR_NAMES </P>
<P>   =&gt;WM:  #66 66 [ON-ENTRY] (REQUEST ^LAST-NAME |Baker|) </P>
<P>   4 (1):  PRINT-ALL-WITH-SIMILAR-LAST-NAME #66 66  #3 3</P>
<P>&nbsp;</P>
<P>        Ginny Baccer </P>
<P>&lt;--Entry-Block: PRINT_SIMILAR_NAMES </P>
<P>   &lt;=WM:  #66 66 [ON-ENTRY] (REQUEST ^LAST-NAME |Baker|)</P>
<P>&lt;--Entry-Block: LOOKUP_PHONE_NUMBER </P>
<P>   &lt;=WM:  #65 65 [ON-ENTRY] (REQUEST ^FIRST-NAME |Jenny| ^LAST-NAME |Baker|)</P>
</FONT></UL></UL>

<P>When all visible objects are deleted (for example, in a RESTORESTATE or REMOVE * action), the system displays:  &lt;=WM:  ** All Objects Removed ** </P>
<B><FONT FACE="Helvetica" SIZE=4>
<P>Tracing the Conflict Set</P></B></FONT>
<P>When the trace level includes CS, the run-time system displays the instantiations added to and deleted from the conflict set. The system displays the following information for each instantiation: </P>
<UL>
<LI>The name of the rule for which it was added or deleted  </LI>
<LI>The INSTANCE-IDs and time-tags of the objects that match the rule's LHS </LI></UL>
</UL>

<P>The system displays conflict set trace information in the following format:</P>
<UL><FONT FACE="Courier" SIZE=1><P>rule-name #INSTANCE-ID-1 time-tag    #INSTANCE-ID-2 time-tag-2</P>
</FONT></UL>

<P>Each line of conflict set trace output is preceded by a symbol that indicates whether the instantiation was added to or deleted from the conflict set: </P>

<B><P>Table 9-5.  Trace Output Symbols</P></B>

<TABLE BORDER=1>
<TR><TD><B>Symbol</B></TD><TD><B>Meaning</B></TD></TR>
<TR><TD>=&gt;CS:</TD><TD>Instantiation added to conflict set </TD></TR>
<TR><TD>&lt;=CS:</TD><TD>Instantiation deleted from conflict set </TD></TR>
</TABLE>

<P>In the following example, trace output about the conflict set is shown in  <I>italic</I> print.</P>

<B><P>Example 9-4. Trace Ouput for The Conflict Set</P></B>

<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>trace on eb rule wm cs </P>
</B><P>RuleWorks&gt;<B>run</B> </P>
<P>   Name to look up:  RuleWorks&gt;<B>Anne Beauchant </P>
</B><P>--&gt;Entry-Block: LOOKUP_PHONE_NUMBER</P>
<P>   =&gt;WM:  #69 69 [ON-ENTRY] (REQUEST ^FIRST-NAME |Anne| ^LAST-NAME |Beauchant|</P>
<P>   =&gt;CS:  LAST-SIMILAR-AND-FIRST-SIMILAR #44 44  #69 69  #2 2</P>
<P>   =&gt;CS:  LAST-RESORT:PRINT-ALL-SIMILAR #42 42  #69 69  #2 2 </P>
<P>   =&gt;CS:  LAST-RESORT:NO-MATCHES-AT-ALL #42 42  #69 69</P>
<P>   7 (1):  LAST-SIMILAR-AND-FIRST-SIMILAR #44 44  #69 69  #2 2</P>
<P>    Found a possible match for Anne Beauchant</P>
<P>.     The number for Ann Bachant is 555-5619.</P>
<P> &lt;--Entry-Block: LOOKUP_PHONE_NUMBER </P>
<P>   &lt;=WM:  #69 69 [ON-ENTRY] (REQUEST ^FIRST-NAME |Anne| ^LAST-NAME |Beauchant|)  </P>
</FONT></UL>

<P>When all conflict set elements are deleted, the system displays: </P>

<UL><FONT FACE="Courier" SIZE=1><P>&lt;=CS:  ** All CS Entries Removed ** </P></FONT></UL>

<P>&nbsp;</P>
<B><FONT FACE="Helvetica" SIZE=5><P>Saving and Restoring Program State</P></B></FONT>
<P>If you are debugging a RuleWorks program and you need to stop execution to do  something else, you might want to save the state of working memory and the  conflict set as it exists at that time.  Or, you might want to save a certain state so that you can rerun from that point many times. By using RuleWorks commands you can  save the state to a file and then restore it later.</P>
<B><FONT FACE="Helvetica" SIZE=4><P>SAVESTATE Command</P></B></FONT>
<P>You can copy the state of visible working memory and the active conflict set to a file by using the SAVESTATE command. The following command copies the state of working memory and the conflict set to the file MY_SAVE.DAT:</P>
<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>savestate my_save.dat </B></P>
</FONT></UL>

<UL><B><P>Note: </B>The state of user-defined external routines and open files is not saved by the SAVESTATE command and thus cannot be restored with the ADDSTATE or RESTORESTATE command.  </P></UL>

<B><FONT FACE="Helvetica" SIZE=4><P>RESTORESTATE Command</P></B></FONT>
<P>The RESTORESTATE command clears and restores visible working memory and the active conflict  set to the state recorded in a file produced by the SAVESTATE command. Suppose  you used the SAVESTATE command to copy the state of working memory and the  conflict set to the file MY_SAVE.DAT. The following command restores working  memory and the conflict set to the state recorded in the file MY_SAVE.DAT:</P>

<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>restorestate my_save.dat  </P>
</B></FONT></UL>

<P>The RESTORESTATE command: </P>

<UL>
<LI>Clears visible working memory </LI>
<LI>Clears the active conflict set </LI>
<LI>Restores working memory from the saved state Saved WMOs that are not visible to the active entry block are ignored. </LI>
<LI>Restores the conflict set from the saved state <BR>
<BR>
Saved conflict set information that does not pertain to the active entry block is ignored. </LI></UL>
<P>The RESTORESTATE command automatically performs ID translation on any INSTANCE-ID values stored in attributes of the saved WMOs.  That is, if you use IDs as pointers the relationships among saved WMOs are maintained.  (See the description of rul_start_id_translation in Chapter A for details on ID translation.)  </P>

<B><FONT FACE="Helvetica" SIZE=4>
<P>ADDSTATE Command</P></B></FONT>
<UL><FONT FACE="Courier" SIZE=1><P>RuleWorks&gt;<B>addstate my_save.dat  </P>
</B></FONT></UL>

<P>The ADDSTATE command: </P>

<UL>
<LI>Adds the objects in the saved state to visible working memory Saved WMOs that are not visible to the active entry block are ignored. </LI>
<LI>Adds the instantiations arising from the objects it just made to the active conflict set <BR>
<BR>
Saved instantiations that do not pertain to the active entry block are ignored. </LI></UL>

<P>Unlike the RESTORESTATE command, the ADDSTATE command does not delete any existing WMOs before creating new ones from the saved file.  Like the RESTORESTATE command, ADDSTATE automatically performs ID translation  on the saved WMOs (see rul_start_id_translation in Chapter A for details).   </P>


</BODY>
</HTML>
