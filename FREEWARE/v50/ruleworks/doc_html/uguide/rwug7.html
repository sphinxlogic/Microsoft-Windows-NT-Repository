<HTML>
<HEAD>
<TITLE>RuleWorks</TITLE>
</HEAD>
<BODY>

<FONT FACE="Arial" SIZE=6 color="navy"><P ALIGN="RIGHT">RuleWorks</P></FONT>

<B><I><FONT FACE="HELVETICA" SIZE=6 color="RED"><P ALIGN="RIGHT">
Persistant Data Storage</P></B></I></FONT>

<P>This chapter describes the interface between <B>SQL</B> (structured query language) and RuleWorks. The SQL interface allows you easily to read data from a database into RuleWorks working memory, and write values from working memory into a database.</P>
<P>&nbsp;</P><DIR>
<DIR>
<DIR>
<DIR>

</FONT><B><FONT FACE="NewCenturySchlbk" SIZE=2><P>Note:</B>  &#9;In the current version of RuleWorks, the <I>only</I> supported database is VAX Rdb/VMS.</P>
</FONT><FONT SIZE=2></DIR>
</DIR>
</DIR>
</DIR>

<P>This chapter covers the following topics:</P>
<P>&nbsp;</P>

<UL>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=2><LI>SQL Expression Syntax</LI>
<LI>Mapping Data to Working Memory Objects</LI>
<LI>Linking with the SQL Libraries</LI>
<LI>Attaching to a Database</LI>
<LI>Starting an SQL Transaction</LI>
<LI>Reading from a Database</LI>
<LI>Using Database Key Values</LI>
<LI>Writing to a Database</LI>
<LI>Error Handling</LI>
<LI>Ending an SQL Transaction</LI>
<LI>Detaching from a Database</LI></UL>

</FONT><FONT SIZE=2>
<P>We assume that you are familiar with SQL concepts and statements. If not, please refer to the VAX Rdb/VMS documentation, especially the <I>DEC Rdb Introduction to SQL </I>and the <I>DEC Rdb Guide to SQL Programming.</P>
<OL>
<OL>

</I><LI><A NAME="_Toc368493483"><A NAME="_Toc368505108"><A NAME="_Toc368672693"><A NAME="_Toc368708285"><A NAME="_Toc368758839"><A NAME="_Toc368793311"><A NAME="_Toc368929103"><A NAME="_Toc370199406"><A NAME="_Toc373768332"><A NAME="_Toc373773367"><A NAME="_Toc373776105"><A NAME="_Toc373809983"></FONT><B><FONT FACE="Helvetica" SIZE=5>SQL Expression Syntax</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_syntax_sec_"><A NAME="sql_syntax_sec"></A>SQL Expression Syntax</A></LI>
</B></FONT><FONT SIZE=2><P>The SQL interface consists of a set of RHS actions that generate the appropriate dynamic SQL statements (see the following table, SQL Statements Generated by RuleWorks Actions).  The arguments to the RHS actions are passed to the SQL statements unchanged. For example, the following RuleWorks action:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(sql-fetch-as-object select field1, field2 from table1 where field1 &lt; field2)</P>
</FONT><FONT SIZE=2>
<P>generates the following dynamic SQL statement:</P>
</FONT><FONT FACE="Courier" SIZE=1><P>&nbsp;</P>
<P>SELECT FIELD1, FIELD2 FROM TABLE1 WHERE FIELD1 &lt; FIELD2</P>
</FONT><FONT SIZE=2>
<P>Note that the select expression must start with SELECT spelled out in full, not abbreviated.</P>
<B><P><A NAME="_Toc368800770"><A NAME="_Toc368819350"><A NAME="_Toc369061796"><A NAME="_Toc370282900"><A NAME="_Toc393858174">Table -1. SQL Statements Generated by RuleWorks Actions</A></A></A></A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>RHS Action <BR>
SQL Statement&#9;Description</P>
</B></FONT><FONT FACE="NewCenturySchlbk" SIZE=1><P>SQL-ATTACH database-spec [dbkey-scope]&#9;Specifies the database that is to be DECLARE SCHEMA database-spec &#9;accessed by the other RuleWorks SQL DBKEY SCOPE IS dbkey-scope &#9;actions. </P>
<P>SQL-COMMIT&#9;Completes the current SQL transaction <BR>
         COMMIT &#9;the current SQL and makes permanent &#9;any changes made during the <BR>
&#9;transaction.  </P>
<P>SQL-DELETE table-name [where-clause]&#9;Deletes specified records from the <BR>
        DELETE FROM table-name where-clause &#9;database. </P>
<P>SQL-DETACH     &#9;Commits any outstanding transaction <BR>
        FINISH &#9;and detaches from the database.  </P>
<P>SQL-FETCH-EACH&lt;var&gt;...select-expr (rhs-action)...&#9;Binds field values to RuleWorks variables<BR>
         select-expr &#9;and executes RuleWorks actions that can <BR>
&#9;use those variables.  </P>
<P>SQL-FETCH-AS-OBJECT select-expr     &#9;Makes WMOs from database records.  <BR>
        select-expr</P>
<P>SQL-INSERT table-name sql-expr     &#9;Stores new records in the database.  <BR>
        INSERT INTO table-name sql-expr</P>
<P>SQL-INSERT-FROM-OBJECT &lt;$id-var&gt;&#9;Stores the contents of a WMO<BR>
        SQL-INSERT-INTO table-name (field-names)&#9;in a new database record.  <BR>
        SQL-INSERT-INTO )VALUES (field-values)</P>
<P>SQL-ROLLBACK     &#9;Completes the current SQL transaction<BR>
        ROLLBACK &#9;and undoes any changes made during the <BR>
&#9;transaction.  </P>
<P>SQL-START [txn-options]&#9;Starts an SQL transaction and sets<BR>
        SQL-SET TRANSACTION txn-options &#9;transaction options.  </P>
<P>SQL-UPDATE table-name set-clause [where-clause]&#9;Modifies existing database records.  <BR>
        SQL-UPDATE table-name set-clause where-clause</P>
<P>SQL-UPDATE-FROM-OBJECT &lt;$id-var&gt; [where-clause]&#9;Modifies existing database records,<BR>
 SQL-UPDATE table-name set-clause where-clause &#9;using the contents of a WMO.  </P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1><P>&nbsp;</P>
<OL>

</FONT><B><FONT FACE="Helvetica" SIZE=4><LI></LI>
<LI><A NAME="_Toc368493484"><A NAME="_Toc368505109"><A NAME="_Toc368672694"><A NAME="_Toc368708286"><A NAME="_Toc368758840"><A NAME="_Toc368793312"><A NAME="_Toc368929104"><A NAME="_Toc370199407"><A NAME="_Toc373768333"><A NAME="_Toc373773368"><A NAME="_Toc373776106"><A NAME="_Toc373809984">Using Vertical Bars ( | )</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_syntax_vbar_sec_"><A NAME="sql_syntax_vbar_sec"></A>Using Vertical Bars ( | )</A></LI></OL>
</OL>
</OL>

</B></FONT><FONT SIZE=2><P>To make the process more efficient, you can use vertical bars (the RuleWorks quote character,  | ) around the atoms that are passed to SQL. For example:</P>
<P>&nbsp;</P><DIR>
<DIR>
<DIR>

</FONT><FONT FACE="Courier" SIZE=1><P>(sql-fetch-as-object |select field1, field2 from table1 where field1 &lt; field2|)</P>
</FONT><FONT SIZE=2></DIR>
</DIR>
</DIR>

<P>In the action above, the RuleWorks parser makes a single atom out of the entire select expression. The same length restrictions apply to quoted atoms in select expressions as in other RuleWorks code (see Chapter 2).  You cannot use vertical bars around a multiline SQL expression; you must use a pair of vertical bars for each line. For example:</P>
<P>&nbsp;</P><DIR>
<DIR>
<DIR>

</FONT><FONT FACE="Courier" SIZE=1><P>(sql-fetch-as-object |select field1, field2|</P>
<P>                     |from table1|</P>
<P>                     |where field1 &lt; field2|)</P>
</FONT><FONT SIZE=2></DIR>
</DIR>
</DIR>

<P>Vertical bars are required in the following circumstances:</P>
<P>&nbsp;</P>

<UL>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=2><LI>When the information to be passed to SQL is case sensitive.  RuleWorks automatically converts unquoted atoms to uppercase.</LI>
<LI>When the information to be passed to SQL includes parentheses ().  For example, this RHS action:</LI></UL>
<DIR>
<DIR>
<DIR>

</FONT><FONT FACE="Courier" SIZE=1><P>(sql-insert table1 |(field1) values (| 'text' |)|)</P>
</FONT><FONT SIZE=2></DIR>
</DIR>
</DIR>

<P>generates this SQL statement:</P>
</FONT><FONT FACE="Courier" SIZE=1><P>&nbsp;</P><DIR>
<DIR>
<DIR>

<P>INSERT INTO TABLE1 (field1) values ('text')</P></DIR>
</DIR>
</DIR>

<OL>
<OL>
<OL>

<LI><A NAME="_Toc368493485"><A NAME="_Toc368505110"><A NAME="_Toc368672695"><A NAME="_Toc368708287"><A NAME="_Toc368758841"><A NAME="_Toc368793313"><A NAME="_Toc368929105"><A NAME="_Toc370199408"><A NAME="_Toc373768334"><A NAME="_Toc373773369"><A NAME="_Toc373776107"><A NAME="_Toc373809985"></FONT><B><FONT FACE="Helvetica" SIZE=4>Using Variables</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_syntax_var_sec_"><A NAME="sql_syntax_var_sec"></A>Using Variables</A> </LI>
</B></FONT><FONT SIZE=2><P>Variables must be surrounded by white space to allow the RuleWorks parser to recognize them as variables. A variable name followed immediately by a comma looks to the parser like an atom instead of a variable to be evaluated. In the following example:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>&lt;var1&gt;, &lt;var2&gt;</P>
</FONT><FONT SIZE=2>
<P>the RuleWorks parser treats &lt;VAR1&gt;, as a symbol and &lt;VAR2&gt; as a variable. The next example:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>&lt;var1&gt; , &lt;var2&gt;</P>
</FONT><FONT SIZE=2>
<P>results in the expected behavior.</P>
<LI><A NAME="_Toc368493486"><A NAME="_Toc368505111"><A NAME="_Toc368672696"><A NAME="_Toc368708288"><A NAME="_Toc368758842"><A NAME="_Toc368793314"><A NAME="_Toc368929106"><A NAME="_Toc370199409"><A NAME="_Toc373768335"><A NAME="_Toc373773370"><A NAME="_Toc373776108"><A NAME="_Toc373809986"></FONT><B><FONT FACE="Helvetica" SIZE=4>Using Single Quotes (')</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_syntax_squote_sec_"><A NAME="sql_syntax_squote_sec"></A>Using Single Quotes (')</A></LI>
</B></FONT><FONT SIZE=2><P>Anything that SQL treats as a character string must be enclosed in single quotes ('). This applies to both atoms and variables.  Quoted variables must have at least one white space character before the opening quote and after the closing quote.</P>

<P>Quoted variables expand to the variable value surrounded by single quotes. Quoted variables that are bound to compound values expand to the list of compound elements surrounded by a single set of single  quotes. The elements of the compound are not quoted. For example, assuming &lt;COMPOUND2&gt; is bound to the value (COMPOUND SOME MORE TEXT), the following RHS argument:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>'&lt;compound2&gt;'</P>
</FONT><FONT SIZE=2><P>&nbsp;</P>
<P>is passed to SQL as the literal:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>'SOME MORE TEXT'</P>
<LI><A NAME="_Toc368493487"><A NAME="_Toc368505112"><A NAME="_Toc368672697"><A NAME="_Toc368708289"><A NAME="_Toc368758843"><A NAME="_Toc368793315"><A NAME="_Toc368929107"><A NAME="_Toc370199410"><A NAME="_Toc373768336"><A NAME="_Toc373773371"><A NAME="_Toc373776109"><A NAME="_Toc373809987"></FONT><B><FONT FACE="Helvetica" SIZE=4>SQL Data Types</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_syntax_data_sec_"><A NAME="sql_syntax_data_sec"></A>SQL Data Types</A> </LI>
</B></FONT><FONT SIZE=2><P>The following table, SQL Data Types Supported in RuleWorks, shows the mapping between SQL and RuleWorks data types.</P>
<B><P><A NAME="_Toc368800773"><A NAME="_Toc368819353"><A NAME="_Toc369061797"><A NAME="_Toc370282901"><A NAME="_Toc393858175">Table -2. SQL Data Types Supported in RuleWorks*</A></A></A></A></A></P>
</FONT><FONT FACE="Arial" SIZE=2><P>SQL Data Type  &#9;Converted to RuleWorks Data Type</P>
</B></FONT><FONT FACE="NewCenturySchlbk" SIZE=1><P>CHAR  &#9;SYMBOL</P>
<P>VARCHAR  &#9;SYMBOL</P>
<P>SMALLINT  &#9;INTEGER</P>
<P>INTEGER  &#9;INTEGER</P>
<P>QUADWORD  &#9;SYMBOL</P>
<P>FLOAT  &#9;FLOAT</P>
<P>DOUBLE  &#9;FLOAT</P>
<P>DATE  &#9;SYMBOL</P>

</FONT><FONT SIZE=2><P>*   RuleWorks has no way to represent double-precision floating-point numbers or integers larger than 32 bits.</P>
<LI><A NAME="_Toc368493488"><A NAME="_Toc368505113"><A NAME="_Toc368672698"><A NAME="_Toc368708290"><A NAME="_Toc368758844"><A NAME="_Toc368793316"><A NAME="_Toc368929108"><A NAME="_Toc370199411"><A NAME="_Toc373768337"><A NAME="_Toc373773372"><A NAME="_Toc373776110"><A NAME="_Toc373809988"></FONT><B><FONT FACE="Helvetica" SIZE=4>Examples of SQL Expressions</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="new_sql_examples_sec_"><A NAME="new_sql_examples_sec"></A>Examples of SQL Expressions</A></LI></OL>
</OL>
</OL>

</B></FONT><FONT SIZE=2><P>This section contains further examples of RHS actions and the SQL statements they generate. All the examples in this section assume the following variable bindings:</P>
<B><P><A NAME="_Toc368800774"><A NAME="_Toc368819354"><A NAME="_Toc369061798"><A NAME="_Toc370282902"><A NAME="_Toc393858176">Table -3.  SQL Variable Bindings</A></A></A></A></A></P><DIR>
<DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>Variable  &#9;Value Bound to</P>
</B></FONT><FONT FACE="NewCenturySchlbk" SIZE=1><P>&lt;simple1&gt;  &#9;SELECT</P>
<P>&lt;simple2&gt;  &#9;10</P>
<P>&lt;simple3&gt; &#9; | 'text' |</P>
<P>&lt;simple4&gt;  &#9;TEXT</P>
<P>&lt;compound1&gt;  &#9;(COMPOUND SELECT * FROM W2 WHERE SI = 10)</P>
<P>&lt;compound2&gt;  &#9;(COMPOUND SOME MORE TEXT)</P>

</FONT><FONT SIZE=2><P>&nbsp;</P></DIR>
</DIR>

<P>In the following example, six actions are equivalent, but the second is the most efficient:</P>
<B><P><A NAME="_Toc368888917"><A NAME="_Toc369071868"><A NAME="_Toc370521158"><A NAME="_Toc393858530">Example -1.  SQL Expression - Equivalent Actions</A></A></A></A></P><DIR>
<DIR>
<DIR>

</B></FONT><FONT FACE="Courier" SIZE=1><P>(SQL-FETCH-AS-OBJECT SELECT * FROM W2 WHERE SI = 10)</P>
<P>(SQL-FETCH-AS-OBJECT |SELECT * FROM W2 WHERE SI = 10|)</P>
<P>(SQL-FETCH-AS-OBJECT SELECT * FROM W2 WHERE SI = &lt;simple2&gt;)</P>
<P>(SQL-FETCH-AS-OBJECT &lt;simple1&gt; * FROM W2 WHERE SI = &lt;simple2&gt;)</P>
<P>(SQL-FETCH-AS-OBJECT &lt;simple1&gt; |* FROM W2 WHERE SI =| &lt;simple2&gt;)</P>
<P>(SQL-FETCH-AS-OBJECT &lt;compound1&gt;)</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1></DIR>
</DIR>
</DIR>

</FONT><FONT SIZE=2><P>The SQL statement generated by the above six actions is shown below:</P><DIR>
<DIR>
<DIR>

</FONT><FONT FACE="Courier" SIZE=1><P>SELECT * FROM W2 WHERE SI = 10</P></DIR>
</DIR>
</DIR>

</FONT><B><FONT SIZE=2><P><A NAME="_Toc368888918"><A NAME="_Toc369071869"><A NAME="_Toc370521159"><A NAME="_Toc393858531">Example -2.  SQL Expression - Insert Into Table</A></A></A></A></P><DIR>
<DIR>
<DIR>

</B></FONT><FONT FACE="Courier" SIZE=1><P> (sql-insert table-name |(FIELD1) VALUES (| &lt;simple3&gt; |)|)</P>
<P>INSERT INTO TABLE-NAME (FIELD1) VALUES ( 'text' )</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1><P>&nbsp;</P></DIR>
</DIR>
</DIR>

</FONT><B><FONT SIZE=2><P><A NAME="_Toc368888919"><A NAME="_Toc369071870"><A NAME="_Toc370521160"><A NAME="_Toc393858532">Example -3.  SQL Expression - Insert Table Name</A></A></A></A></P><DIR>
<DIR>
<DIR>

</B></FONT><FONT FACE="Courier" SIZE=1><P> (sql-insert table-name (FIELD1) VALUES ( &lt;simple2&gt; ))</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1></DIR>
</DIR>
</DIR>

</FONT><FONT SIZE=2><P>The RuleWorks parser stops at the unquoted parentheses and does not generate any SQL statement.</P>
<B><P><A NAME="_Toc368888920"><A NAME="_Toc369071871"><A NAME="_Toc370521161"><A NAME="_Toc393858533">Example -4.  SQL Expression - Insert Text Into Table Name</A></A></A></A></P><DIR>
<DIR>
<DIR>

</B></FONT><FONT FACE="Courier" SIZE=1><P> (sql-insert table-name |(FIELD1) VALUES (| &lt;simple3&gt; '&lt;simple4&gt;' |)|)</P>
<P>INSERT INTO TABLE-NAME (FIELD1) VALUES ( 'text' 'TEXT' )</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1><P>&nbsp;</P></DIR>
</DIR>
</DIR>

</FONT><B><FONT SIZE=2><P><A NAME="_Toc368888921"><A NAME="_Toc369071872"><A NAME="_Toc370521162"><A NAME="_Toc393858534">Example -5.  SQL Expression - Insert More Text Into Table Name</A></A></A></A></P><DIR>
<DIR>
<DIR>

</B></FONT><FONT FACE="Courier" SIZE=1><P> (sql-insert table-name</P>
<P>            |(FIELD1, FIELD2, FIELD3, FIELD4)|</P>
<P>            |VALUES (10, 'text','TEXT', 'SOME MORE TEXT')|)</P>
<P>INSERT INTO TABLE-NAME (FIELD1, FIELD2, FIELD3, FIELD4) -</P>
<P>            VALUES (10, 'text','TEXT', 'SOME MORE TEXT')</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1>
</FONT><FONT SIZE=2><P>&nbsp;</P></DIR>
</DIR>
</DIR>

<P>Note that the RuleWorks-SQL interface does not actually generate multiline statements containing continuation characters (-). Multiline statements are shown here for clarity of the examples..</P>
<B><P><A NAME="_Toc368888922"><A NAME="_Toc369071873"><A NAME="_Toc370521163"><A NAME="_Toc393858535">Example -6.  SQL Expression - Multiline Statements</A></A></A></A></P><DIR>
<DIR>
<DIR>

</B></FONT><FONT FACE="Courier" SIZE=1><P> (sql-insert table-name</P>
<P>            |(FIELD1, FIELD2, FIELD3, FIELD4) VALUES (|</P>
<P>            &lt;simple2&gt; , &lt;simple3&gt; , '&lt;simple4&gt;' ,</P>
<P>            '&lt;compound2&gt;' |)|)</P>
<P>INSERT INTO TABLE-NAME (FIELD1, FIELD2, FIELD3, FIELD4) -</P>
<P>            VALUES ( 10 , 'text' , 'TEXT' , 'SOME MORE TEXT' )</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1></DIR>
</DIR>
</DIR>

</FONT><FONT SIZE=2><P>This SQL action is the same as in the above example, except for the lack of white space between the variables and the commas. RuleWorks does not report any errors in the action below, but passes symbols to SQL rather than values:</P>
<B><P><A NAME="_Toc368888923"><A NAME="_Toc369071874"><A NAME="_Toc370521164"><A NAME="_Toc393858536">Example -7.  SQL Expression - Passing Symbols to SQL</A></A></A></A> </P><DIR>
<DIR>
<DIR>

</B></FONT><FONT FACE="Courier" SIZE=1><P> (SQL-INSERT table-name</P>
<P>            |(FIELD1, FIELD2, FIELD3, FIELD4) VALUES (|</P>
<P>            &lt;simple2&gt;, &lt;simple3&gt;, '&lt;simple4&gt;', '&lt;compound2&gt;' |)|)</P>
<P>INSERT INTO TABLE-NAME (FIELD1, FIELD2, FIELD3, FIELD4) -</P>
<P>            VALUES ( &lt;SIMPLE2&gt;, &lt;SIMPLE3&gt;, '&lt;SIMPLE4&gt;', -</P>
<P>                     'SOME MORE TEXT' )</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1></DIR>
</DIR>
</DIR>

</FONT><FONT SIZE=2><P>If SQL detects an error in the generated SQL statement, the interface creates an instance of class SQL$MSG. See the section of this chapter, Error Handling, for details on message WMOs.</P>
<OL>
<OL>

<LI><A NAME="_Toc368493489"><A NAME="_Toc368505114"><A NAME="_Toc368672699"><A NAME="_Toc368708292"><A NAME="_Toc368758845"><A NAME="_Toc368793318"><A NAME="_Toc368929109"><A NAME="_Toc370199413"><A NAME="_Toc373768338"><A NAME="_Toc373773373"><A NAME="_Toc373776111"><A NAME="_Toc373809989"></FONT><B><FONT FACE="Helvetica" SIZE=5>Mapping Data to Working Memory Objects</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_map_sec_"><A NAME="sql_map_sec"></A>Mapping Data to Working Memory Objects</A></LI>
</B></FONT><FONT SIZE=2><P>The fetch, insert, and update actions come in two forms: simple and flexible. The simple forms require a one-to-one mapping between object class names and database table names, and between attribute names and database field names. The flexible forms have no mapping requirement.</P>
<OL>

<LI><A NAME="_Toc368493490"><A NAME="_Toc368505115"><A NAME="_Toc368672700"><A NAME="_Toc368708293"><A NAME="_Toc368758846"><A NAME="_Toc368793319"><A NAME="_Toc368929110"><A NAME="_Toc370199414"><A NAME="_Toc373768339"><A NAME="_Toc373773374"><A NAME="_Toc373776112"><A NAME="_Toc373809990"></FONT><B><FONT FACE="Helvetica" SIZE=4>One-to-One Mappings</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_map_restricted_sec_"><A NAME="sql_map_restricted_sec"></A>One-to-One Mappings</A></LI></OL>
</OL>
</OL>

</B></FONT><FONT SIZE=2><P>The simple forms of the SQL fetch, insert, and update actions are listed below:</P>
<P>&nbsp;</P>

<UL>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=2><LI>SQL-FETCH-AS-OBJECT</LI>
<LI>SQL-INSERT-FROM-OBJECT</LI>
<LI>SQL-UPDATE-FROM-OBJECT</LI></UL>

</FONT><FONT SIZE=2>
<P>The syntax for these actions is much simpler than the syntax for the flexible SQL actions, because an automatic mapping from WMOs to SQL records is performed. There must be a database table name that exactly matches the object class name; there must also be some database field names that match attribute names. A one-to-one correspondence is shown in the following comparison of an OBJECT-CLASS declaration in RuleWorks and a CREATE TABLE statement in SQL:</P>
<B><P><A NAME="_Toc368800775"><A NAME="_Toc368819355"><A NAME="_Toc369061799"><A NAME="_Toc370282903"><A NAME="_Toc393858177">Table -4.  One-to-One Mappings</A></A></A></A></A></P><DIR>
<DIR>

</FONT><FONT FACE="Arial" SIZE=2><P>RuleWorks  &#9;SQL</P>
</B></FONT><FONT FACE="NewCenturySchlbk" SIZE=1><P>  </FONT><FONT FACE="Courier" SIZE=1>(OBJECT-CLASS part &#9;</FONT><FONT FACE="NewCenturySchlbk" SIZE=1> </FONT><FONT FACE="Courier" SIZE=1>create table part</FONT><FONT FACE="NewCenturySchlbk" SIZE=1> <BR>
                               ^partnumber  &#9;                </FONT><FONT FACE="Courier" SIZE=1>(partnumberchar&#9;(10),<BR>
               ^name                         namechar &#9;(63), <BR>
               ^price)                       price&#9;double);</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1></DIR>
</DIR>

</FONT><FONT SIZE=2><P>The following simple fetch action is based on the declaration and statement shown above:</P>
<B><P><A NAME="_Toc368888924"><A NAME="_Toc369071875"><A NAME="_Toc370521165"><A NAME="_Toc393858537">Example -8.  Fetch Action</A></A></A></A></P><DIR>
<DIR>
<DIR>

</B></FONT><FONT FACE="Courier" SIZE=1><P> ; to fetch a particular part number</P>
<P> ; the part number is the symbolic value bound to &lt;my-part&gt;</P></DIR>

<P> (sql-fetch-as-object select * from part where partnumber = '&lt;my- part&gt;')</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1></DIR>
</DIR>

</FONT><FONT SIZE=2><P>Exceptions to the one-to-one correspondence can be achieved easily by defining a view of the database, or by using more complex SQL select expressions. Note however that updates or inserts to multitable views are not supported. (See the section of this chapter titled, Using Views to Fetch Data, for more information on views.)</P>

<P>You can have more attributes in the object class than fields in the database table, or more fields than attributes. The simple fetch action, SQL-FETCH-AS-OBJECT, ignores fields that do not correspond to attributes.  Attributes that do not correspond to fields are given their default value, if any, or the atom NIL. Similarly, the simple insert action SQL-INSERT-FROM-OBJECT ignores attributes that do not correspond to fields.  Database fields that do not correspond to attributes are set to their default value, if any, or to "missing."</P>

<P>The SQL interface preserves "missing" database field values. When SQL-FETCH-AS-OBJECT makes an object from a database table that has "missing" field values, it sets the corresponding attribute values to NIL. Conversely, when SQL-INSERT-FROM-OBJECT makes a database record from an object that has NIL attribute values, it sets the corresponding field values to "missing" (NULL). That is, NIL maps to "missing" in both directions, even if the NIL attribute value was explicitly set.</P>
<P>&nbsp;</P><DIR>
<DIR>
<DIR>
<DIR>

</FONT><B><FONT FACE="NewCenturySchlbk" SIZE=2><P>Note:</B>  &#9;Data values for the ^$ID and ^$INSTANCE-OF attributes are not written to the database by SQL-INSERT-FROM-OBJECT, even if the database explicitly provides fields with these names.</P>
<P>&nbsp;</P></DIR>
</DIR>
</DIR>
</DIR>


<UL>
<LI>The RuleWorks SQL interface does not automatically handle the built-in attributes ^$ID and ^$INSTANCE-OF. Values of type INSTANCE-ID can be written to database fields, but the SQL interface does not guarantee consistent pointers to objects. You can work around this restriction by using the rul_start_id_translation and rul_end_id  translation run-time library routines.</LI></UL>

</FONT><FONT SIZE=2>
<P>The SQL interface does not recognize class inheritance. For example, a subclass cannot be passed to SQL-INSERT-FROM-OBJECT for a table that matches a parent class. The table name must be the same as the value of the  ^$INSTANCE-OF attribute.</P>
<OL>
<OL>
<OL>

<LI><A NAME="_Toc368493491"><A NAME="_Toc368505116"><A NAME="_Toc368672701"><A NAME="_Toc368708294"><A NAME="_Toc368758847"><A NAME="_Toc368793320"><A NAME="_Toc368929111"><A NAME="_Toc370199415"><A NAME="_Toc373768340"><A NAME="_Toc373773375"><A NAME="_Toc373776113"><A NAME="_Toc373809991"></FONT><B><FONT FACE="Helvetica" SIZE=4>Flexible Mappings</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_map_flexible_sec_"><A NAME="sql_map_flexible_sec"></A>Flexible Mappings</A></LI></OL>
</OL>
</OL>

</B></FONT><FONT SIZE=2><P>The flexible SQL fetch, insert, and update actions allow you to specify particular database tables or fields that do not necessarily correspond to object class or attribute names. The flexible actions are listed below:</P>
<P>&nbsp;</P>

<UL>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=2><LI>SQL-FETCH-EACH</LI>
<LI>SQL-INSERT</LI>
<LI>SQL-UPDATE</LI></UL>

<OL>
<OL>

<LI><A NAME="_Toc368493492"><A NAME="_Toc368505117"><A NAME="_Toc368672702"><A NAME="_Toc368708297"><A NAME="_Toc368758848"><A NAME="_Toc368793324"><A NAME="_Toc368929112"><A NAME="_Toc370199418"><A NAME="_Toc373768341"><A NAME="_Toc373773376"><A NAME="_Toc373776114"><A NAME="_Toc373809992"></FONT><B><FONT FACE="Helvetica" SIZE=5>Linking with the SQL Libraries</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_link_sec_"><A NAME="sql_link_sec"></A>Linking with the SQL Libraries</A> </LI>
</B></FONT><FONT SIZE=2><P>You must link your RuleWorks application with the SQL library in order to use the SQL actions.  The easiest way is to define a logical name to point to the SQL library. For example:</P>
</FONT><FONT FACE="Courier" SIZE=2 COLOR="#0000ff">
<P>$</FONT><FONT SIZE=2> </FONT><FONT FACE="Courier" SIZE=2 COLOR="#800000">DEFINE LNK$LIBRARY SYS$LIBRARY:SQL$USER</P>
</FONT><FONT FACE="Courier" SIZE=2 COLOR="#0000ff"><P>$</FONT><FONT SIZE=2> </FONT><FONT FACE="Courier" SIZE=2 COLOR="#800000">LINK MY_FILE, RUL$LIBRARY:RUL_TRL/LIB</P>
</FONT><FONT SIZE=2>
<P>(See the <I>DEC rdb Introduction to SQL </I>for more information on the SQL library.)</P>
<LI><A NAME="_Toc368493493"><A NAME="_Toc368505118"><A NAME="_Toc368672703"><A NAME="_Toc368708298"><A NAME="_Toc368758849"><A NAME="_Toc368793325"><A NAME="_Toc368929113"><A NAME="_Toc370199419"><A NAME="_Toc373768342"><A NAME="_Toc373773377"><A NAME="_Toc373776115"><A NAME="_Toc373809993"></FONT><B><FONT FACE="Helvetica" SIZE=5>Attaching to a Database</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_attach_sec_"><A NAME="sql_attach_sec"></A>Attaching to a Database</A></LI>
</B></FONT><FONT SIZE=2><P>Before your first database transaction, you must specify which database you want to access. You do this with an SQL-ATTACH action, which executes a DECLARE SCHEMA statement.</P>
</FONT><FONT FACE="Times" SIZE=2>
</FONT><FONT SIZE=2><P> The syntax of the SQL-ATTACH action is show below: </P>

<B><P>SQL-ATTACH</B> <I>database-spec [ DBKEY-scope ]</P>
</I>
<P>The <I>database-spec</I> argument identifies which database you want to access. This argument can be either the filename of the Rdb database file,  or the pathname of the CDD schema source.  If you specify a filename, you can use the optional keyword FILENAME. If you specify a pathname, you must use the PATHNAME keyword.  You can use a logical name in either case. For example:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(sql-attach my_sql_db)         ;logical name for DBDISK:[DATABASE]MY_DB.RDB</P>
<P>(sql-attach pathname rul_db)   ;logical name for CDD$TOP.DEPT3.PERSONNEL</P>
</FONT><FONT SIZE=2>
<P>The optional <I>DBKEY-scope</I> argument can be either TRANSACTION or ATTACH.</P>
</FONT><B><FONT FACE="NewCenturySchlbk" SIZE=2><P>Note:</B>&#9;You can access only one database at a time. Simultaneous access to multiple databases is not supported in the RuleWorks &lt;vnum&gt; SQL interface.  <BR>
<BR>
You can sequentially access multiple databases in one RuleWorks program execution.</P>
</FONT><FONT SIZE=2>
<P>If SQL-ATTACH is executed while a database is already attached, the original attachment is terminated and the new database is attached (unless a transaction is active, in which case a warning WMO is made and the second attachment is not performed).</P>
<LI><A NAME="_Toc368493494"><A NAME="_Toc368505119"><A NAME="_Toc368672704"><A NAME="_Toc368708299"><A NAME="_Toc368758850"><A NAME="_Toc368793326"><A NAME="_Toc368929114"><A NAME="_Toc370199420"><A NAME="_Toc373768343"><A NAME="_Toc373773378"><A NAME="_Toc373776116"><A NAME="_Toc373809994"></FONT><B><FONT FACE="Helvetica" SIZE=5>Starting an SQL Transaction</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_start_sec_"><A NAME="sql_start_sec"></A>Starting an SQL Transaction</A></LI>
</B></FONT><FONT SIZE=2><P>In RuleWorks, explicitly starting an SQL transaction is optional if you are only going to read from the database; it is required if you are going to write to the database. The syntax for the SQL-START action is shown below: </P>

<P>SQL-START <I>[ txn-options ]</P>
</I>
<P>The <I>txn-options</I> argument is optional: its default value is READ ONLY. This argument can include any transaction option that is valid in a SET TRANSACTION statement. For example:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(sql-start read write reserving table_1 for shared read)</P>
</FONT><FONT SIZE=2>
<P>If a transaction is not currently active when a fetch action is executed, SQL implicitly starts a READ ONLY transaction. The interface ends this transaction immediately after the fetch is completed.</P>
<LI><A NAME="_Toc368493495"><A NAME="_Toc368505120"><A NAME="_Toc368672705"><A NAME="_Toc368708300"><A NAME="_Toc368758851"><A NAME="_Toc368793327"><A NAME="_Toc368929115"><A NAME="_Toc370199421"><A NAME="_Toc373768344"><A NAME="_Toc373773379"><A NAME="_Toc373776117"><A NAME="_Toc373809995"></FONT><B><FONT FACE="Helvetica" SIZE=5>Reading from a Database</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_fetch_sec_"><A NAME="sql_fetch_sec"></A>Reading from a Database</A></LI>
</B></FONT><FONT SIZE=2><P>The RuleWorks SQL interface provides two ways to read (fetch) data from a database. The simple form, SQL-FETCH-AS-OBJECT, automatically makes new objects from  selected database records. </P>
<P>The flexible form, SQL-FETCH-EACH, binds the values in selected database records to variables that can then be used in whatever RHS actions you specify.</P>

<P>Both forms of the fetch action use the SQL syntax for select expressions.  The select expression specifies which database records are selected, and which database fields are fetched. The select expression must be a valid one that you could put in a SELECT statement. For example: </P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>select fld1, fld2 from table_1 where fld3 &gt; 10 and fld4 = 'abc'</P>
<P>select * from table_2 where fld4 = '&lt;var&gt;'</P>
</FONT><B><FONT FACE="NewCenturySchlbk" SIZE=2><P>Note</B>:&#9;You must put single-quote ( </FONT><FONT FACE="Courier" SIZE=2>'</FONT><FONT FACE="NewCenturySchlbk" SIZE=2>)   characters around nonnumeric constants and variables. You must put at least one white space character before the opening quote and after the closing quote. However, you must not put any white space between the single quotes and a variable.</P>
<OL>

<LI><A NAME="_Toc368493496"><A NAME="_Toc368505121"><A NAME="_Toc368672706"><A NAME="_Toc368708301"><A NAME="_Toc368758852"><A NAME="_Toc368793328"><A NAME="_Toc368929116"><A NAME="_Toc370199422"><A NAME="_Toc373768345"><A NAME="_Toc373773380"><A NAME="_Toc373776118"><A NAME="_Toc373809996"></FONT><B><FONT FACE="Helvetica" SIZE=4>Using the Simple Fetch Action</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_fetch_object_sec_"><A NAME="sql_fetch_object_sec"></A>Using the Simple Fetch Action</A> </LI>
</B></FONT><FONT SIZE=2><P>The SQL-FETCH-AS-OBJECT action automatically makes a new object out of each selected database record. If the select expression causes <I>n</I> records to be fetched from the database, then a single execution of that SQL-FETCH-AS-OBJECT action creates <I>n</I> new objects.  The OBJECT-CLASS name of the new objects is the name of the database table.</P>

<P>The syntax of the SQL-FETCH-AS-OBJECT action is shown below: </P>

<P>SQL-FETCH-AS-OBJECT <I>select-expr</P>
</I>
<P>The names of WMO attributes to be set by SQL-FETCH-AS-OBJECT must match the field names of the database table (unless a view is used to access the table, in which case it is the view's local field names that must match the OBJECT-CLASS attribute names). For example:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(sql-fetch-as-object select * from part)</P>
</FONT><FONT SIZE=2>
<P>The example above corresponds to the OBJECT-CLASS declaration and CREATE TABLE statement in the section of this chapter, One-to-One Mappings.</P>
<LI><A NAME="_Toc368493497"><A NAME="_Toc368505122"><A NAME="_Toc368672707"><A NAME="_Toc368708302"><A NAME="_Toc368758853"><A NAME="_Toc368793329"><A NAME="_Toc368929117"><A NAME="_Toc370199423"><A NAME="_Toc373768346"><A NAME="_Toc373773381"><A NAME="_Toc373776119"><A NAME="_Toc373809997"></FONT><B><FONT FACE="Helvetica" SIZE=4>Using the Flexible Fetch Action</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_fetch_each_sec_"><A NAME="sql_fetch_each_sec"></A>Using the Flexible Fetch Action</A></LI>
</B></FONT><FONT SIZE=2><P>The SQL-FETCH-EACH action binds data from selected database fields to RuleWorks variables. You can then use these variables in RHS actions inside the SQL-FETCH-EACH action to create or change instances of any declared OBJECT-CLASS. If the select expression causes <I>n</I> records to be fetched from the database, then the variables are bound and the RHS actions are executed <I>n</I> times for a single execution of the SQL-FETCH-EACH action.</P>

<P>The syntax of the SQL-FETCH-EACH action is shown below: </P>

<P>SQL-FETCH-EACH  <I>&lt;variable&gt;</I> ...  (s<I>elect-expr</I>) <BR>
                                   (<I>RHS-action)</I>...</P>

<P>You can specify one or more variables as the first argument, but they must not be bound prior to the SQL-FETCH-EACH action. They can be used only in the RHS actions specified as the third argument. They cannot be used after the SQL-FETCH-EACH action.</P>

<P>If you use any variables in the select expression, they must be bound prior to the SQL-FETCH-EACH action. They can be bound on either the LHS or RHS of the rule.</P>

<P>You can specify one or more RHS-actions for the third argument. These actions can use the variables from the first argument as well as variables bound prior to the SQL-FETCH-EACH action. If you use a BIND action inside the SQL-FETCH-EACH action, that variable is still bound after the action executes.</P>

<P>SQL interface actions are not allowed inside the SQL-FETCH-EACH action.</P>
<B><P><A NAME="_Toc368888925"><A NAME="_Toc369071876"><A NAME="_Toc370521166"><A NAME="_Toc393858538">Example -9. Fetching Fields from an SQL Database</A></A></A></A> <A NAME="sql_fetch_each_eg_"><A NAME="sql_fetch_each_eg"></A>Fetching Fields from an SQL Database</A></P>
</B></FONT><FONT FACE="Courier" SIZE=1><P> </FONT><FONT FACE="Courier" SIZE=1>(rule fetch-items-from-database:software-option</P>
<P>        (active-context ^name fetch-items-from-database)</P>
<P>        (software-option ^$ID &lt;the-part&gt; ^is-expanded NIL</P>
<P>                         ^$INSTANCE-OF &lt;part-type&gt;)</P>
<P>    --&gt;</P>
<P>        (sql-fetch-each &lt;partnumber&gt; &lt;partname&gt; &lt;price&gt; &lt;media&gt;</P>
<P>                        (select partnumber , name , price , media_type</P>
<P>                                from sw_part</P>
<P>                                where classname = '&lt;part-type&gt;' )</P>
<P>                        (modify &lt;the-part&gt;</P>
<P>                                ^partnumber &lt;partnumber&gt;</P>
<P>                                ^name &lt;partname&gt;</P>
<P>                                ^price &lt;price&gt;</P>
<P>                                ^media-type &lt;media&gt;</P>
<P>                                ^is-expanded YES) ))</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1>
</FONT><FONT SIZE=2><P>SQL-FETCH-EACH does tolerate a mismatch between the number of RuleWorks variables specified in the action and the number of database fields to be fetched for each database record. If more variables are specified than fields fetched, the excess variables are set to NIL; if more fields are fetched than variables specified, the excess values are just ignored.  In either case, an SQL warning WMO is generated (see the section of this chapter, Error Handling).</P>

<P>Given the following OBJECT-CLASS declaration:</P>
</FONT><FONT FACE="Courier" SIZE=1><P>&nbsp;</P>
<P>(object-class objclass ^fld1 ^fld2 ^fld3)</P>
</FONT><FONT SIZE=2>
<P>In terms of the WMOs created and the final binding of the variable &lt;FETCHED-INSTANCES&gt;, the following two sequences of BIND and fetch actions are equivalent:</P>
<B><P><A NAME="_Toc368888926"><A NAME="_Toc369071877"><A NAME="_Toc370521167"><A NAME="_Toc393858539">Example -10.  Bind-Fetch Sequence</A></A></A></A></P>
</B></FONT><FONT FACE="Courier" SIZE=1><P>(BIND &lt;fetched-instances&gt; (COMPOUND))</P>
<P>(SQL-FETCH-EACH &lt;v1&gt; &lt;v2&gt; &lt;v3&gt;</P>
<P>    (|SELECT FLD1, FLD2, FLD3 FROM OBJCLASS WHERE FLD4 =10|)</P>
<P>    (BIND &lt;instance&gt;</P>
<P>          (MAKE objclass ^fld1 &lt;v1&gt; ^fld2 &lt;v2&gt; ^fld3 &lt;v3&gt;))</P>
<P>    (BIND &lt;fetched-instances&gt;</P>
<P>          (COMPOUND &lt;fetched-instances&gt; &lt;instance&gt;)))</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1>
</FONT><FONT SIZE=2><P>&nbsp;</P>
<P>If this is what is what you want to do, the second sequence is more efficient:</P>
<B><P><A NAME="_Toc368888927"><A NAME="_Toc369071878"><A NAME="_Toc370521168"><A NAME="_Toc393858540">Example -11.  Bind-Fetch Sequence - 2</A></A></A></A></P>
</B></FONT><FONT FACE="Courier" SIZE=1><P> (BIND &lt;fetched-instances&gt;</P>
<P>   (SQL-FETCH-AS-OBJECT</P>
<P>      |SELECT FLD1, FLD2, FLD3 FROM OBJCLASS WHERE FLD4 = 10|))</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1>
</FONT><FONT SIZE=2><P>Note however, that the SQL-FETCH-EACH action gives you more flexibility by allowing arbitrary RHS actions (except other SQL actions) to be performed after each fetch. Also, you are not restricted to the one-WMO-to-one-record data model. Consider the following actions that fetch the same data but place it into one working memory object:</P>
<B><P><A NAME="_Toc368888928"><A NAME="_Toc369071879"><A NAME="_Toc370521169"><A NAME="_Toc393858541">Example -12.  Placing Fetch Data into One Working Memory Object (WMO)</A></A></A></A></P>
</B></FONT><FONT FACE="Courier" SIZE=1><P> (object-class objclass</P>
<P>             ^fld1 COMPOUND</P>
<P>             ^fld2 COMPOUND</P>
<P>             ^fld3 COMPOUND)</P>
<P>...</P>
<P>(BIND &lt;fld1&gt; (COMPOUND))</P>
<P>(BIND &lt;fld2&gt; (COMPOUND))</P>
<P>(BIND &lt;fld3&gt; (COMPOUND))</P>
<P>(SQL-FETCH-EACH &lt;v1&gt; &lt;v2&gt; &lt;v3&gt;</P>
<P>    (|SELECT FLD1, FLD2, FLD3 FROM OBJCLASS WHERE FLD4 =10|)</P>
<P>    (BIND &lt;fld1&gt; (COMPOUND &lt;fld1&gt; &lt;v1&gt;))</P>
<P>    (BIND &lt;fld2&gt; (COMPOUND &lt;fld2&gt; &lt;v2&gt;))</P>
<P>    (BIND &lt;fld3&gt; (COMPOUND &lt;fld3&gt; &lt;v3&gt;)))</P>
<P>(BIND &lt;instance&gt;</P>
<P>      (MAKE objclass ^fld1 &lt;fld1&gt; ^fld2 &lt;fld2&gt; ^fld3 &lt;fld3&gt;))</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1><P>&nbsp;</P>
<LI><A NAME="_Toc368493498"><A NAME="_Toc368505123"><A NAME="_Toc368672708"><A NAME="_Toc368708303"><A NAME="_Toc368758854"><A NAME="_Toc368793330"><A NAME="_Toc368929118"><A NAME="_Toc370199424"><A NAME="_Toc373768347"><A NAME="_Toc373773382"><A NAME="_Toc373776120"><A NAME="_Toc373809998"></FONT><B><FONT FACE="Helvetica" SIZE=4>Using Views to Fetch Data</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_fetch_views_sec_"><A NAME="sql_fetch_views_sec"></A>Using Views to Fetch Data</A></LI></OL>

</B></FONT><FONT SIZE=2><P>Using SQL views to fetch data from one or more tables into a specified class of object is perfectly acceptable and easily done. However, if you are using multiple tables, you can use views only to read database records, not to insert or update database records in multiple tables. (You cannot use views that contain aggregates to write data either; see the <I>DEC Rdb Guide to SQL Programming </I>section on CREATE VIEW for restrictions.)</P>

<P>You can define a view to achieve the one-to-one mapping of object class to database table names, or of object attributes to database field names, required by the simple forms of the fetch, insert, and update actions. For example:</P>
<B><P><A NAME="_Toc368888929"><A NAME="_Toc369071880"><A NAME="_Toc370521170"><A NAME="_Toc393858542">Example -13.  Using Views to Fetch Data</A></A></A></A></P>
</B></FONT><FONT FACE="Courier" SIZE=1><P>CREATE TABLE Y (X INTEGER,</P>
<P>                Z CHAR(20), ...);</P>
<P>CREATE VIEW A  (B, C)</P>
<P>            AS SELECT X, Z FROM Y;</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1>
</FONT><FONT SIZE=2><P>In this example, attribute ^B of object class A maps to field B in  view A (satisfying the 1-to-1 name mapping requirement), while the view's field B in turn corresponds to field X in the underlying table Y to which the view provides access.</P>
<LI><A NAME="_Toc368493499"><A NAME="_Toc368505124"><A NAME="_Toc368672709"><A NAME="_Toc368708304"><A NAME="_Toc368758855"><A NAME="_Toc368793332"><A NAME="_Toc368929119"><A NAME="_Toc370199426"><A NAME="_Toc373768348"><A NAME="_Toc373773383"><A NAME="_Toc373776121"><A NAME="_Toc373809999"></FONT><B><FONT FACE="Helvetica" SIZE=5>Using Database Key Values</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_dbkey_sec_"><A NAME="sql_dbkey_sec"></A>Using Database Key Values</A> </LI>
</B></FONT><FONT SIZE=2><P>You can fetch database key values and use them inside RuleWorks, but you cannot use them to insert or update records. The SQL interface translates database key values into character strings, such as 1:2:3, for the database area, page, and line numbers of the fetched records.</P>

<P>You can declare an attribute called ^DBKEY and test whether it is NIL to find out if the object was fetched from the database or not.</P>

<P>You can compare two fetched database key values for equality.</P>
</FONT><B><FONT FACE="NewCenturySchlbk" SIZE=2><P>Note:&#9;</B>Database key values are not persistent. They are valid for only the duration of a single attachment to the database (or less if you use the default transaction scope).</P>
<LI><A NAME="_Toc368493500"><A NAME="_Toc368505125"><A NAME="_Toc368672710"><A NAME="_Toc368708305"><A NAME="_Toc368758856"><A NAME="_Toc368793333"><A NAME="_Toc368929120"><A NAME="_Toc370199427"><A NAME="_Toc373768349"><A NAME="_Toc373773384"><A NAME="_Toc373776122"><A NAME="_Toc373810000"></FONT><B><FONT FACE="Helvetica" SIZE=5>Writing to a Database</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_write_sec_"><A NAME="sql_write_sec"></A>Writing to a Database</A></LI></OL>
</OL>

</B></FONT><FONT SIZE=2><P>You can write WMO attribute values to a database in one of two ways: by updating existing database records or by inserting new ones. You can also choose either the simple or the flexible form of the update and insert actions.  This section describes the following RHS actions:</P>
<P>&nbsp;</P>

<UL>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=2><LI>SQL-UPDATE</LI>
<LI>SQL-UPDATE-FROM-OBJECT</LI>
<LI>SQL-INSERT</LI>
<LI>SQL-INSERT-FROM-OBJECT</LI></UL>

</FONT><FONT SIZE=2>
<P>Remember that you must explicitly start all write transactions with an SQL-START action.</P>
<OL>
<OL>
<OL>

<LI><A NAME="_Toc368493501"><A NAME="_Toc368505126"><A NAME="_Toc368672711"><A NAME="_Toc368708306"><A NAME="_Toc368758857"><A NAME="_Toc368793334"><A NAME="_Toc368929121"><A NAME="_Toc370199428"><A NAME="_Toc373768350"><A NAME="_Toc373773385"><A NAME="_Toc373776123"><A NAME="_Toc373810001"></FONT><B><FONT FACE="Helvetica" SIZE=4>Updating Existing Records</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_write_update_sec_"><A NAME="sql_write_update_sec"></A>Updating Existing Records</A></LI>
</B></FONT><FONT SIZE=2><P>Updating existing records modifies data fields without creating any new database records. The SQL-UPDATE-FROM-OBJECT action uses the contents of an object to modify existing database records; the SQL-UPDATE action uses constants or bound variables.</P>

<P>Both update actions allow you to use the SQL syntax for WHERE clauses to specify which database records are modified. The syntax for the SQL-UPDATE-FROM-OBJECT action is shown below: </P>

<P>SQL-UPDATE-FROM-OBJECT <I>&lt;$id-variable&gt; [ WHERE-clause ]</P>
</I>
<P>SQL-UPDATE-FROM-OBJECT modifies records in the database table whose name matches the OBJECT-CLASS of the WMO specified by the <I>$id-variable</I> argument. This argument also specifies which object provides the new data values for the update. If the object has attributes that do not correspond to fields in the target database table, those attributes are ignored. On the other hand, if the database table has fields that do not correspond to attributes in the object, those fields are not modified.</P>
<P>For example:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(sql-update-from-object &lt;W&gt; where fld1 = &lt;var&gt;)</P>
</FONT><FONT SIZE=2>
<P>Note that all of the fields in the database record(s) may be modified, not just fld1.  SQL-UPDATE-FROM-OBJECT uses all the attribute values for the specified RuleWorks object to modify all the corresponding data fields in the selected database records.  Depending on the WHERE clause, one or more records may be updated by a single SQL-UPDATE-FROM-OBJECT action.</P>

<P>The SQL-UPDATE action uses the SQL syntax for SET clauses to specify which database fields are modified. The syntax for the SQL-UPDATE action is shown below: </P>

<P>SQL-UPDATE <I>table-name SET-clause [WHERE-clause]</I> </P>

<P>The <I>table-name</I> argument can be a symbol or bound variable; the <I>SET-clause</I> argument can contain constants or bound variables.  As with SQL-UPDATE-FROM-OBJECT, the <I>WHERE-clause</I> argument is optional. For example:</P>
<P>&nbsp;</P>
</FONT><FONT FACE="Courier" SIZE=1><P>(sql-update tbl set fld1 = 0 where fld2 &gt; 10)</P>
</FONT><FONT SIZE=2>
<P>Note that one or many database records may be updated by a single RuleWorks SQL-UPDATE execution. If you want to update only one record per firing of this rule, you must write a WHERE clause that restricts the selection to a single record.</P>
<LI><A NAME="_Toc368493502"><A NAME="_Toc368505127"><A NAME="_Toc368672712"><A NAME="_Toc368708307"><A NAME="_Toc368758858"><A NAME="_Toc368793335"><A NAME="_Toc368929122"><A NAME="_Toc370199429"><A NAME="_Toc373768351"><A NAME="_Toc373773386"><A NAME="_Toc373776124"><A NAME="_Toc373810002"></FONT><B><FONT FACE="Helvetica" SIZE=4>Inserting New Records</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_write_insert_sec_"><A NAME="sql_write_insert_sec"></A>Inserting New Records</A></LI></OL>
</OL>
</OL>

</B></FONT><FONT SIZE=2><P>The SQL-INSERT-FROM-OBJECT action adds to the database a single new record whose field values are the attribute values of a specified object.  The SQL-INSERT action adds one or more new records to the database.  SQL-INSERT-FROM-OBJECT does not remove the object whose data it stores in the database.</P>

<P>The syntax of the SQL-INSERT-FROM-OBJECT action is shown below: </P>
<B>
<P>SQL-INSERT-FROM-OBJECT</B> <I>&lt;$id-variable&gt;</P>
</I>
<P>For example:</P>
<P>&nbsp;</P><DIR>
<DIR>
<DIR>

</FONT><FONT FACE="Courier" SIZE=1><P>(sql-insert-from-object &lt;W&gt;)</P>
</FONT><FONT SIZE=2></DIR>
</DIR>
</DIR>

<P>The syntax of the SQL-INSERT action is shown below:</P>

<P> SQL-INSERT <I>table-name SQL-expr</P>
</I>
<P>The <I>SQL-expr</I> argument lists the field names into which values are to be inserted and the new values themselves.  For example:</P>
<P>&nbsp;</P><DIR>
<DIR>
<DIR>

</FONT><FONT FACE="Courier" SIZE=1><P>(sql-insert tbl |(| fld1, fld2 |) values (| 10, 'abc' |)|)</P></DIR>
</DIR>
</DIR>

<OL>
<OL>

<LI><A NAME="_Toc368493503"><A NAME="_Toc368505128"><A NAME="_Toc368672713"><A NAME="_Toc368708309"><A NAME="_Toc368758859"><A NAME="_Toc368793338"><A NAME="_Toc368929123"><A NAME="_Toc370199433"><A NAME="_Toc373768352"><A NAME="_Toc373773387"><A NAME="_Toc373776125"><A NAME="_Toc373810003"></FONT><B><FONT FACE="Helvetica" SIZE=5>Error Handling</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_error_sec_"><A NAME="sql_error_sec"></A>Error Handling</A> </LI>
</B></FONT><FONT SIZE=2><P>The SQL interface signals error conditions by creating WMOs whose class name is SQL$MSG. In order to accept these objects, your RuleWorks program must include the following OBJECT-CLASS declaration: </P>
<B><P><A NAME="_Toc368888930"><A NAME="_Toc369071881"><A NAME="_Toc370521171"><A NAME="_Toc393858543">Example -14.  OBJECT-CLASS Declaration</A></A></A></A></P>
</B></FONT><FONT FACE="Courier" SIZE=1><P>(OBJECT-CLASS SQL$MSG</P>
<P>           ^SEV    ; severity code</P>
<P>           ^COND   ; condition code, or message name</P>
<P>           ^TEXT   ; description of the error</P>
<P>           ^RULE)  ; the name of the rule that executed the SQL action</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1>
</FONT><FONT SIZE=2><P>The following example, SQL Error Objects, shows a few sample objects of class SQL$MSG.</P>
<B><P><A NAME="_Toc368888931"><A NAME="_Toc369071882"><A NAME="_Toc370521172"><A NAME="_Toc393858544">Example -15.  SQL Error Objects</A></A></A></A> <A NAME="sql_msg_objects_ex_"><A NAME="sql_msg_objects_ex"></A>SQL Error Objects</A></P>
</B></FONT><FONT FACE="Courier" SIZE=2 COLOR="#0000ff"><P>RuleWorks&gt;</FONT><B><FONT FACE="Courier" SIZE=2 COLOR="#800000">PPWM SQL$MSG</P>
</B></FONT><FONT FACE="Courier" SIZE=1><P>#54 60 [ATTACH-DATABASE:DO-IT] (SQL$MSG ^SEV W ^COND SQLATTFAI ^TEXT SQL attac</P>
<P>h to database failed ^RULE ATTACH-DATABASE:DO-IT)</P>
<P>#56 62 [FETCH-ITEMS-FROM-DATABASE:HARDWARE-OPTION] (SQL$MSG ^SEV W ^COND SQLFET</P>
<P>PRE ^TEXT Preparation of SQL fetch statement failed ^RULE FETCH-ITEMS-FROM-DATA</P>
<P>BASE:HARDWARE-OPTION)</P>
<P>#60 66 [FETCH-ITEMS-FROM-DATABASE:HARDWARE-OPTION] (SQL$MSG ^SEV W ^COND SQLFET</P>
<P>PRE ^TEXT Preparation of SQL fetch statement failed ^RULE FETCH-ITEMS-FROM-DATA</P>
<P>BASE:HARDWARE-OPTION)</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1>
</FONT><FONT SIZE=2><P>You can write rules to process SQL$MSG objects as they are produced; you decide how, or whether, to proceed after an SQL warning.  The following example, Handling an SQL Error, shows a rule that halts the program when the attachment to the database fails.</P>
<B><P><A NAME="_Toc368888932"><A NAME="_Toc369071883"><A NAME="_Toc370521173"><A NAME="_Toc393858545">Example -16.  Handling an SQL Error</A></A></A></A> <A NAME="sql_error_ex_"><A NAME="sql_error_ex"></A>Handling an SQL Error</A></P>
</B></FONT><FONT FACE="Courier" SIZE=1><P>(rule abort-on-db-attach-failure</P>
<P>        (sql$msg ^cond sqlattfai ^text &lt;text&gt; ^rule )</P>
<P>   --&gt;</P>
<P>        (write (crlf) |Execution of|  |caused the following error:|)</P>
<P>        (write (crlf) &lt;text&gt;)</P>
<P>        (halt))</P>
</FONT><FONT FACE="NewCenturySchlbk" SIZE=1><P>&nbsp;</P>
<LI><A NAME="_Toc368493504"><A NAME="_Toc368505129"><A NAME="_Toc368672714"><A NAME="_Toc368708310"><A NAME="_Toc368758860"><A NAME="_Toc368793339"><A NAME="_Toc368929124"><A NAME="_Toc370199434"><A NAME="_Toc373768353"><A NAME="_Toc373773388"><A NAME="_Toc373776126"><A NAME="_Toc373810004"></FONT><B><FONT FACE="Helvetica" SIZE=5>Ending an SQL Transaction</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_end_sec_"><A NAME="sql_end_sec"></A>Ending an SQL Transaction</A></LI>
</B></FONT><FONT SIZE=2><P>When you end an SQL transaction, you can either apply (commit) any changes to the database made during the transaction, or you can undo them (rollback). Use the SQL-COMMIT action to apply the changes, the SQL-ROLLBACK action to undo them. Both of these actions complete the current SQL transaction. Their syntax is shown below: </P>

<P>SQL-COMMIT <BR>
SQL-ROLLBACK</P>

<P>The SQL interface automatically performs an SQL-COMMIT action to terminate any transaction you started implicitly by a fetch operation.</P>
<LI><A NAME="_Toc368493505"><A NAME="_Toc368505130"><A NAME="_Toc368672715"><A NAME="_Toc368708311"><A NAME="_Toc368758861"><A NAME="_Toc368793340"><A NAME="_Toc368929125"><A NAME="_Toc370199435"><A NAME="_Toc373768354"><A NAME="_Toc373773389"><A NAME="_Toc373776127"><A NAME="_Toc373810005"></FONT><B><FONT FACE="Helvetica" SIZE=5>Detaching from a Database</A></A></A></A></A></A></A></A></A></A></A></A> <A NAME="sql_detach_sec_"><A NAME="sql_detach_sec"></A>Detaching from a Database</A></LI></OL>
</OL>

</B></FONT><FONT SIZE=2><P>When your program is finished using the database, it should detach from the database. The syntax of the SQL-DETACH action is shown below: </P>

<P>SQL-DETACH </P>

<P>If there is a current transaction, the SQL-DETACH action performs an implicit SQL-COMMIT action to complete it before detaching.  </P></FONT></BODY>
</HTML>
