<HTML>
<HEAD>
<TITLE>RuleWorks</TITLE>
</HEAD>
<BODY>

<FONT FACE="Arial" SIZE=6 color="navy"><P ALIGN="RIGHT">RuleWorks</P></FONT>

<B><I><FONT FACE="HELVETICA" SIZE=6 color="RED"><P ALIGN="RIGHT">
User Guide Introduction</P></B></I></FONT>

<P>RuleWorks is a rules-based programming language that represents an 
evolutionary step beyond OPS5.  The major features of RuleWorks are listed 
below:</P>
<LI>Improved data representation</LI>
<UL><UL>
<LI>inheritance hierarchy</LI>
<LI>working memory can be partitioned</LI>
</UL></UL>

<LI>Improved program modularity</LI>
<UL>
<UL>
<LI>programs can be divided into independent, or dependent, modular subsystems</LI>
<LI>rules-based modules can easily be called, and can return a value</LI>
</UL></UL>

<LI>Portable implementation supporting numerous platforms</LI>

<P>OPS5 is a rules-based programming language that was used most often to 
develop knowledge-based and expert systems. It was created at Carnegie 
Mellon University in the late 1970s and early 1980s by Charles Forgy,  
John McDermott, the late Allen Newell, and Mike Rychener. Publication of 
Forgy's <I>OPS5 User’s Manual </I>in 1981 established a commonly used 
standard for the language. OPS5 is characterized by:</P>

<LI>A global database, called working memory.</LI>
<P>
<LI>Program statements called condition-action rules that match patterns in 
working memory and then perform actions that change working memory.</LI>
<P>
<LI>Execution order that is not procedural, but is driven by the data in 
working memory. The order in which rules are executed is controlled by the 
recognize-act cycle.</LI>
<P>
<LI>Computation with symbolic expressions and numbers.</LI>
</FONT>


<B><FONT FACE="HELVETICA" SIZE=5><P>Sample Program</P></B></FONT>

<P>Most of the examples in this guide are based on a sample 
program called KIWI, which solves the system configuration problems of a 
hypothetical manufacturer, the Kiwi Computer Company. Kiwi Computer Co. makes 
the computer parts shown in Table 1-1.  A customer can order a Kiwi computer 
as a package or as separate parts. The purpose of the KIWI program is to help 
the Kiwi sales force verify that the parts a customer has ordered can be 
assembled into a working computer.</P>

<B><P>Table 1-1 Parts Manufactured by Kiwi Computer Company </P></B>

<TABLE border=1>
<TR><TD><B>Part Number</B></TD><TD><B>Name</B></TD><TD><B>Price ($)</B></TD></TR>
<TR><TD>KI-9200</TD><TD>Kiwi-9200 CPU Base Unit</TD><TD align=right>999.95</TD></TR>
<TR><TD>MS-9200</TD><TD>Kiwi-9200 Memory Card</TD><TD align=right>129.95</TD></TR>
<TR><TD>FD-35</TD><TD>3.5-inch Floppy Disk Drive</TD><TD align=right>99.95</TD></TR>
<TR><TD>FD-525</TD><TD>5.25-inch Floppy Disk Drive</TD><TD align=right>109.95</TD></TR>
<TR><TD>HD-30</TD><TD>30-Megabyte Hard Disk Drive</TD><TD align=right>299.95</TD></TR>
<TR><TD>HD-200</TD><TD>200-Megabyte Hard Disk Drive</TD><TD align=right>599.95</TD></TR>
<TR><TD>TA-9200</TD><TD>High-Performance Cartridge Tape</TD><TD align=right>399.95</TD></TR>
<TR><TD>KB-9200</TD><TD>108-Key Keyboard with Mouse Port</TD><TD align=right>99.95</TD></TR>
<TR><TD>MOUSE-1</TD><TD>100 pulses per inch Graphic Mouse</TD><TD align=right>59.95</TD></TR>
<TR><TD>VM-9200</TD><TD>19-inch B/W Alphanumeric Monitor</TD><TD align=right>99.95</TD></TR>
<TR><TD>CM-9200</TD><TD>21-inch Color Graphic Display System</TD><TD align=right>199.95</TD></TR>
<TR><TD>NI-9200</TD><TD>Kiwi-9200 Network Interface</TD><TD align=right>39.95</TD></TR>
<TR><TD>S-OS-9200</TD><TD>KIWOS Operating System</TD><TD align=right>9.95</TD></TR>
<TR><TD>S-WI-9200</TD><TD>KiWindows Windows Software</TD><TD align=right>59.95</TD></TR>
<TR><TD>S-CA-9200</TD><TD>KiwiCalc Spreadsheet Software</TD><TD align=right>29.95</TD></TR>
<TR><TD>S-NE-9200</TD><TD>KiwiTalk Network Software</TD><TD align=right>89.95</TD></TR>
</TABLE>

<B><FONT FACE="HELVETICA" SIZE=5><P>Working Memory</P></FONT>
<P>Working memory</B> is a global, dynamic user workspace that 
contains information about a problem and the current state of its solution.  
Information is stored in <B>working memory objects</B> that are organized by <B>class</B>.  Each working memory object (WMO, pronounced "wim-oh") has a class name and a list of associated <B>attributes</B> and their values. The class name classifies the object according to the type of information it contains. The attributes and their values describe the object's characteristics. (In database terms, object classes are like tables and attributes are like fields).</P>

<P>The information in Table 1-1 could be represented in working memory by objects that are all instances of a single class, named PART. A better representation would use several classes to capture more information about the differences between types of parts.  For example, most of the Kiwi parts are optional (a customer can buy either a floppy disk drive or a hard disk drive) but one is required (the base unit that contains the CPU). This distinction can be represented by class OPTION for the optional components and class BOX for the required CPU box.</P>

<P>RuleWorks allows object classes to be organized into an inheritance hierarchy in which <B>subclasses</B> inherit from a <B>parent class</B>.  In this example, OPTION and BOX are subclasses (or <B>descendants</B>) of the parent class PART (see Figure 1-1).</P>

<P>All parts made by Kiwi Computer Company have the following three characteristics: a part number, a name, and a price. These characteristics are represented by attributes whose names are PART-NUMBER, NAME, and PRICE. These attributes are declared in object class PART and are inherited by its descendants.</P>

<B><P>Figure 1-1. Class Hierarchy of Parts</P></B>
<IMG src ="../images/f1-1.gif">

<P> (Figure 1-1 shows only part of the class hierarchy used in the sample program. For a complete illustration, see Figure 2-1)</P>

<P>Some of the optional parts are hardware; some are software. Hardware and software have different characteristics and are therefore separated into different classes with different attributes. For example, a hardware component can take up a slot in the CPU box while a software component does not. Conversely, software is available on different media (two sizes of floppy disk, or tape) while hardware is not.</P>

<P>The software options can be further divided between applications and the operating system. Kiwi Computer currently sells three applications, so there are three subclasses of APPLICATION. There is currently only one subclass of OPERATING-SYSTEM, but there may be other supported operating systems in the future.</P>

<P>A sample object of class BOX is shown below. The first three attributes are inherited from class PART and have values from Table 1-1.  The last two attributes belong to class BOX only, because the box is the only part that has slots:</P>

<FONT FACE="Courier" SIZE=1><P>(BOX ^PART-NUMBER KI-9200  ^NAME |Kiwi-9200 CPU Base Unit| ^PRICE 999.95 ^CARD-IN-SLOT  ^CARD-IN-SLOT-OBJ-ID)</P>

</FONT><P>The attribute names are preceded by a caret (^) to show that they are references into the object.</P>

<B><FONT FACE="HELVETICA" SIZE=5><P>Rules</P></B></FONT>
<P>Program statements in RuleWorks are condition-action (or "if ... then") rules that operate on working memory. A <B>rule</B> has a name and consists of a condition part (called the <B>left-hand side</B> or LHS) and an action part (called the <B>right-hand</B> <B>side </B>or RHS). The LHS is separated from the RHS by an arrow, created by typing two minus signs and a greater-than sign.  Figure 1-2 shows the format of a rule.</P>

<P>Rules express the requirements of the problem to be solved. For example, one requirement of the Kiwi program is that a customer who buys application software must also buy the KIWOS operating system. The rule shown in Example 1-1 enforces this requirement.  The left-hand side of the rule matches when the contents of working memory do not meet the KIWOS requirement; the right-hand side of the rule takes corrective actions.</P>
<B><FONT FACE="HELVETICA" SIZE=2><P>Figure 1-2. Format of a Rule</P></B></FONT>
<IMG SRC="../images/f1-2.gif">


<FONT FACE="HELVETICA" SIZE=2>
<P><B>Example 1-1. A Sample Rule</P></B></FONT>
<FONT FACE="Courier" SIZE=1>
<P> (rule verify-configuration:application-needs-kiwos
<ul><P>(active-context ^name verify-configuration)</P>
<P>(kiwos-application ^$instance-of &lt;applic&gt;)</P>
<P>-(kiwos)</P>
<P>--&gt;</P>
<P>(write (crlf) |Caution: to run an application| &lt;applic&gt;</P>
<P>        (crlf) |you need to have KIWOS, but you don't have KIWOS.|</P>
<P>        (crlf) |   Fixup:  adding KIWOS to your order.|</P>
<P>        (crlf)) </P>
<P> (make error ^severity warning ^message |No operating system|)</P>
<P> (make kiwos)</P>
</UL>
<P>)</P>
</FONT>

<B><FONT FACE="HELVETICA" SIZE=4>
<P>The Left-Hand Side</P></B></FONT>
<P>The LHS is a series of patterns called <B>condition elements</B> (CEs) that are compared to objects during program execution. RuleWorks implicitly performs a logical AND operation on all the CEs on the LHS. (In database terms, each CE is like a query against a table, and the LHS is a like a join across the results of those queries.)</P>

<P>The LHS of the sample rule in Example 1-1 consists of three CEs. The first CE is used to control the flow of execution of the program. It states that the program must be in the "verify configuration" phase of execution before this rule can <B>fire</B> (be executed).</P>

<P>The second CE states that an object of class KIWOS-APPLICATION or any of its subclasses exists in working memory. The customer order could include any application: KiWindows, KiwiCalc, or KiwiTalk. Because subclasses inherit <B>membership</B> in their parent classes, objects of classes KIWINDOWS, KIWICALC, or KIWITALK match the class name KIWOS-APPLICATION (see  Figure 1-1). The second CE also binds (assigns a value to) the variable &lt;APPLIC&gt;.</P>

<P>The third CE is negated. It states that no object of class KIWOS exists.</P>

<B><FONT FACE="HELVETICA" SIZE=4>
<P>The Right-Hand Side</P></B></FONT>
<P>The RHS is a series of actions that are taken when the rule is executed. Actions are taken in the order you write them.  An action consists of an action name and its arguments; it usually manipulates the contents of working memory.</P>

<P>The RHS of the sample rule in Example 1-1 contains three actions. The WRITE action displays a message to the user that the order is being changed. The variable &lt;APPLIC&gt; that was bound on the LHS is used here on the RHS. The two MAKE actions create new objects of the classes ERROR and KIWOS, respectively.  The creation of the KIWOS object changes the contents of working memory such that the operating system requirement is met. Thus, this rule will fire only once even if the customer orders all three applications.</P>

<B><FONT FACE="HELVETICA" SIZE=5>
<P>Recognize-Act Cycle</P></B></FONT>
<P>The <B>recognize-act cycle</B> is the pattern-matching procedure that takes place repeatedly as a RuleWorks program executes (see Figure 1-3). The cycle consists of the following steps:</P></FONT>

<TABLE CELLPADDING=5 BORDER=1>
<TR>
<TD valign=top>
<B>Match</B>
</TD>
<TD>Search working memory to find all combinations of objects that satisfy the condition elements in the left-hand sides of the program's rules. A rule name plus a combination of objects that satisfy that rule's condition elements is called an <B>instantiation</B>.  Place all instantiations in a list called the <B>conflict set</B>.  [In database terms, the conflict set is like a collection of the results of all the joins (left-hand sides) in the program.]</P>
</TD>
</TR>
<TR>
<TD valign=top>
<B><P>Select</B>
</TD>
<TD>Using an ordered sequence of criteria, take the instantiation with the highest priority out of the conflict set. If the conflict set is empty (because no left-hand side has been satisfied), the cycle stops.</P>
</TD>
</TR>
<TR>
<TD valign=top>
<B><P>Act</B>
</TD>
<TD>
Execute the actions on the right-hand side of the rule in the selected instantiation, operating on the objects matched by its left-hand side.</P>
</TD>
</TR>
</TABLE>
<P>You can think of the match and select steps together as recognizing which is the best rule to fire, thus the term recognize-act cycle.</P>

<B><FONT FACE="HELVETICA" SIZE=2><P>Figure 1-3 Recognize-Act Cycle</B></P>

<P><IMG SRC="../images/f1-3.gif" WIDTH=544 HEIGHT=433></P>
</B></FONT>

<P>The cycle can stop after the select step, if the conflict set is empty. It stops during the act step if a RETURN or QUIT action is executed.</P>

<B><FONT FACE="HELVETICA" SIZE=5><P>Conflict Resolution</P></B></FONT>
<P>The process by which the run-time system selects one instantiation from the conflict set is called <B>conflict resolution</B>. During conflict resolution, the run-time system uses one of two possible strategies to select the best instantiation, based on five different criteria (see Table 1-2).       </P>
<B><FONT FACE="Arial" SIZE=2><P>Table 1-2 Conflict Resolution Criteria</P></B></FONT>

<TABLE CELLPADDING=5 BORDER=1>
<TR>
<TD valign=top><B>Refraction</B>
</TD>
<TD>Select an instantiation only once.
<BR>
Refraction prevents programs from looping infinitely on the same data by removing instantiations from the conflict set after they have been selected.
</TD>
</TR>
<TR>
<TD valign=top><B>Recency</B>
</TD>
<TD>Select the instantiation that refers to the most recent information.
<BR>
Objects that have the highest time-tags contain the most recent data. Therefore, the system selects the instantiation that contains the highest time-tags.
</TD>
</TR>
<TR>
<TD valign=top><B>Class Specificity</B>
</TD>
<TD>Select the instantiation whose rule refers to the most specific class names.
<BR>Class specificity is determined by the position of object classes in the inheritance hierarchy. Top-level classes are less specific than low-level classes. For example, a PART object is least specific; a KIWINDOWS object is most specific.
</TD>
</TR>
<TR>
<TD valign=top><B>Test Specificity</B>
</TD>
<TD>Select an instantiation of the rule whose left-hand side is the most specific.
<BR>Test specificity is determined by the number of attribute-value tests in the rule's left-hand side. The rule whose left-hand side contains the most tests is the most specific.
</TD>
</TR>
<TR>
<TD valign=top><B>Arbitrary choice</B>
</TD>
<TD>After all other criteria have been applied and more than one instantination remains, select one at random.
</TR>
</TABLE>

<P>The RuleWorks run-time system supports two conflict-resolution strategies: the lexicographic-sort (LEX) strategy and the means-ends-analysis (MEA) strategy.  The LEX strategy applies each selection criterion once, in the order shown in Table 1-2.  The MEA strategy follows the same order, but it applies recency in two steps. First it selects the instantiation(s) whose first time-tag is most recent. It then selects from the remaining instantiation(s) the one(s) whose combined time-tags are most recent.</P>

<P>The sample program, KIWI, uses the MEA strategy to create a control structure. The program divides the problem into tasks, creates an object for each task, and places the condition element that matches the control object first on each left-hand side (see Example 1-1).  The extra step of the MEA strategy ensures that only instantiations that match the most recent control object can fire.</P>

<P>The default strategy for RuleWorks is MEA, and DIGITAL recommends using this strategy for almost all applications. You can change the strategy to LEX with the STRATEGY clause of the ENTRY-BLOCK declaration<B>.</B>  </P>

<B><FONT FACE="HELVETICA" SIZE=5><P>Other Program Components</P></B></FONT>
<P>In addition to rules, RuleWorks programs consist of block constructs, declarations, optional ON- statements, optional catchers, and optional comments. Each program must have at least one entry block; declaration blocks and rule blocks are optional. Inside an entry block, program statements must be ordered as shown in Figure 1-4: declarations first, then ON- statements (if any), last rules and catchers.</P></FONT>

<B><FONT FACE="HELVETICA" SIZE=2><P>Figure 1-4. Format of a RuleWorks Program</B></P></FONT>
<P><IMG SRC="../images/f1-4.gif" WIDTH=389 HEIGHT=480></P>

<FONT FACE="HELVETICA" SIZE=4>
<P><B>Block Constructs</B></P></FONT>
<P>RuleWorks provides block constructs for program and data modularity. In OPS5, all rules were active and all of working memory could be matched by any rule. In RuleWorks, the rules and WMOs of one block can be isolated from those of every other block.</P>
<P>RuleWorks provides three block constructs:</P>
<B><FONT FACE="Arial" SIZE=2><P>Table 1-3.  Block Construction</B></P></FONT>

<TABLE BORDER=1>
<TR>
<TD><B>Name</B></TD><TD><B>Purpose</B></TD>
</TR>
<TR>
<TD valign=top>
<B>ENTRY-BLOCK</B>
</TD>
<TD>Makes an entry point for your RuleWorks code so that it can be called from RuleWorks or other languages, accepting arguments and optionally returning a value. Objects whose class is declared inside an entry block can be matched by rules in that entry block only.
</TD>
</TR>
<TR>
<TD align=top>
<B>DECLARATION-BLOCK</B>
</TD>
<TD>Creates a collection of object class and external routine declarations that can be shared among entry blocks.  Objects whose class is declared inside a declaration block can be matched by rules in any entry or rule block that uses that declaration block.
</TD>
</TR>
<TR>
<TD align=top>
<B>RULE-BLOCK</B>
</TD>
<TD>Creates a collection of rules that can be shared among entry blocks. Objects whose class is declared inside a rule block can be matched by rules in that rule block only.
</TD>
</TR>
</TABLE>

<P>Each block must end with an END-BLOCK statement.  See Chapter 5 for more information on block constructs.</P></FONT>

<B><FONT FACE="HELVETICA" SIZE=4><P>Declarations</P></B></FONT>
<P>Declarations are units of code that define the object classes and external routines used in a program.  Object class and external routine declarations must precede any executable statement.</P></FONT>
<B><FONT FACE="HELVETICA" SIZE=4><P>ON- Statements</P></B></FONT>
<P>ON- statements contain actions that are executed at particular steps in the recognize-act cycle, without matching objects in working memory. RuleWorks provides four ON- statements:</P></FONT>

<B><FONT FACE="Arial" SIZE=2><P>Table 1-4.  ON-Statements</B></P></FONT>
<TABLE BORDER=1>
<TR>
<TD><B>Name</B></TD><TD><B>Time Executed</B></TD>
</TR>
<TR>
<TD align=top>
<B>ON-ENTRY</B>
</TD>
<TD>Before match step of first recognize-act cycle.
</TD>
</TR>
<TR>
<TD align=top>
<B>ON-EVERY</B>
</TD>
<TD>After act step of every cycle except the last one.
</TD>
</TR>
<TR>
<TD align=top>
<B>ON-EMPTY</B>
</TD>
<TD>After select step when the conflict set is empty.
</TD>
</TR>
<TR>
<TD align=top>
<B>ON-EXIT</B>
</TD>
<TD>After act step of the last cycle.
</TD>
</TR>
</TABLE>

<P>Like rules, ON- statements must be enclosed in parentheses. They must appear after declarations (if any) and before other executable statements (that is, rules and catchers). For more information see Chapter 5.</P>
<B><FONT FACE="HELVETICA" SIZE=4><P>Catchers </P></B></FONT>
<P>Catchers contain actions that are executed after a certain number of recognize-act cycles have fired, without matching objects in working memory.  You specify the number of cycles in an AFTER action. For more information see Chapter 5.</P>
<B><FONT FACE="HELVETICA" SIZE=4><P>Comments  </P></B></FONT>
<P>To improve the readability of your program, you can format units of code by using white space (spaces, tabs, and new-line characters) and comments. A comment starts with a semicolon and finishes at the end of the same line. For example:</P>
<FONT FACE="Courier" SIZE=3><P>;This is a comment.</P></FONT>

<P>If you want more than one line of comment text, you must start each line with a semicolon.</P>

<P>The compiler ignores the text of comments. Therefore, comments can contain any ASCII character and can start anywhere that a space character is valid.</P>

</BODY>


</HTML>
